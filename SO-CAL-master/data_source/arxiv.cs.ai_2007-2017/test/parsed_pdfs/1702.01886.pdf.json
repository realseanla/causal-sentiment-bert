{
  "name" : "1702.01886.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Extracting Lifted Mutual Exclusion Invariants from Temporal Planning Domains",
    "authors" : [ "Sara Bernardinia", "Fabio Fagnanib", "David E. Smithc" ],
    "emails" : [ "sara.bernardini@kcl.ac.uk", "fabio.fagnani@polito.it", "david.smith@nasa.gov" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We present a technique for automatically extracting mutual exclusion invariants from temporal planning instances. It first identifies a set of invariant templates by inspecting the lifted representation of the domain and then checks these templates against properties that assure invariance. Our technique builds on other approaches to invariant synthesis presented in the literature, but departs from their limited focus on instantaneous actions by addressing temporal domains. To deal with time, we formulate invariance conditions that account for the entire structure of the actions and the possible concurrent interactions between them. As a result, we construct a significantly more comprehensive technique than previous methods, which is able to find not only invariants for temporal domains, but also a broader set of invariants for non-temporal domains. The experimental results reported in this paper provide evidence that identifying a broader set of invariants results in the generation of fewer multi-valued state variables with larger domains. We show that, in turn, this reduction in the number of variables reflects positively on the performance of a number of temporal planners that use a variable/value representation by significantly reducing their running time.\nKeywords: Automated Planning, Temporal Planning, Mutual Exclusion Invariants, Automatic Domain Analysis"
    }, {
      "heading" : "1. Introduction",
      "text" : "This paper presents a technique for synthesising mutual exclusion invariants from temporal planning domains expressed in PDDL2.1 (Fox and Long, 2003). A mutual exclusion invariant over a set of ground atoms means that at most one atom in the set is true at any given moment. A set with this property can intuitively be seen as the domain of a multi-valued state variable.1 For\nEmail addresses: sara.bernardini@kcl.ac.uk (Sara Bernardini), fabio.fagnani@polito.it (Fabio Fagnani), david.smith@nasa.gov (David E. Smith)\n1To be precise, a set of mutually exclusive atoms is the domain of an implicit state variable only when augmented with a catch-all null value, which can be manufactured on demand. This is because a mutual exclusion invariant encodes the concept of “at most one”, whereas a state variable encodes the concept of “at least one”. The null value is then used when no atom is true, if these situations exist. Preprint submitted to Artificial Intelligence February 8, 2017\nar X\niv :1\n70 2.\n01 88\n6v 1\n[ cs\n.A I]\n7 F\neb 2\ninstance, consider the Floortile domain from the 8th International Planning Competition (IPC8 - see Appendix A)2. A mutual exclusion invariant for this domain states that two ground atoms that indicate the position of a robot can never be true at the same time. Intuitively, this means that a robot cannot be at two different locations simultaneously. To give a concrete case, consider a planning problem for the Floortile domain with one robot r1 and three locations, t1, t2 and t3. We can create a state variable that indicates the position of r1 with a domain of three values: robot-at_r1_t1, robot-at_r1_t2 and robot-at_r1_t3.\nAlthough a number of approaches to invariant synthesis have been proposed so far (Gerevini and Schubert, 2000; Rintanen, 2000, 2008; Fox and Long, 1998; Helmert, 2009), they are limited in scope because they deal with non-temporal domains only. Recently, Rintanen (2014) has proposed a technique for temporal domains, but this technique does not scale to complex problems because it requires to ground the domain. Our approach solves both these problems at the same time. We find invariants for temporal domains by applying an algorithm that works at the lifted level of the representation and, in consequence, is very efficient and scales to large instances.\nOur invariant synthesis builds on Helmert (2009), which presents a technique to translate the non-temporal subset of PDDL2.2 (Edelkamp and Hoffmann, 2004) into FDR, a multi-valued planning task formalism used by Fast Downward (Helmert, 2006). Since finding invariants for temporal tasks is much more complex than for tasks with instantaneous actions, a simple generalisation of Helmert’s technique to temporal settings does not work. In the temporal case, simultaneity and interference between concurrent actions can occur, hence our algorithm cannot check actions individually against the invariance conditions, but needs to consider the entire set of actions and their possible intertwinements over time. In capturing the temporal case, we formulate invariance conditions that take into account the entire structure of the action schemas as well as the possible interactions between them. As a result, we construct a significantly more comprehensive technique that is able to find not only invariants for temporal domains, but also a broader set of invariants for non-temporal domains.\nOur technique is based on a two-steps approach. First, we provide a general theory at the ground level and propose results that insure invariance under two types of properties: safety conditions for individual instantaneous and durative actions as well as collective conditions that prevent dangerous intertwinements between durative actions. Then, we lift these results at the level of schemas so that all checks needed for verifying invariance can be performed at this higher level, without the need of grounding the domain. Complexity of such checks are of linear or low polynomial order in terms of the number of schemas and literals appearing in the domain.\n1.1. Motivations\nAutomated planning is a well-established field of artificial intelligence and, over more than fifty years since its appearance, several paradigms have emerged. One fundamental difference between these paradigms is whether time is treated implicitly or explicitly. While classical planning focuses on the causal evolution of the world, temporal planning is concerned with the temporal properties of the world. In classical planning, actions are considered to be instantaneous, whereas in temporal planning actions have durations and can be executed concurrently. Another important difference between planning paradigms relates to whether the world is modelled by adopting a Boolean propositional representation or a representation based on multi-valued state variables. Traditionally, the majority of the work in planning has been devoted to classical\n2We call IPC3-IPC8 the competitions for temporal planning held in 2002, 2004, 2006, 2008, 2011 and 2014.\nplanning with domains expressed through propositional languages, and in particular PDDL (McDermott, 2000) and its successors (Fox and Long, 2003), the language of the IPC. However, in parallel with the development of classical propositional planning, a number of temporal planning systems have been proposed for coping with practical problems, especially space mission operations (Frank and Jónsson, 2003; Chien et al., 2000; Ghallab and Laruelle, 1994; Muscettola, 1994; Fratini et al., 2008). Typically, these systems use variable/value representations. Table 1 shows a classification of several well-known planners based on these different characteristics.\nRecently, a few techniques have been proposed for translating propositional representations into variable/value representations (Helmert, 2006; Bernardini and Smith, 2008b; Rintanen, 2014). A central task of all these techniques is the generation of state variables from propositions and actions. The basic procedure to do this (which we use as the baseline in our experiments) relies on generating one state variable with two values, true and false, for each proposition. Naturally, such translation produces no performance advantage. A more sophisticated strategy, which produces compact and optimised encodings, rests on extracting mutual exclusion invariants from propositional domains and using such invariants to generate multi-valued state variables. This is the focus on our work.\nThese translation techniques are important as they allow fair testing of planners developed for variable/value representations on PDDL benchmarks (which are propositional). The practical issue is that planners that permit variable/value representation need this feature to be wellexploited and perform competitively. Since translation between the two different representations can be cheaply automated, there is no reason to reject providing the richer representations to those planners that accept them (if the translation was expensive, one might reasonably argue about the fairness of this process). In consequence, these translating techniques are extremely useful for comparing alternative planning paradigms and for promoting cross-fertilisation of ideas between different planning communities, which is our primary motivation.\nHowever, the importance of these translation techniques goes beyond the engineering of a bridge between different input languages. In transforming propositional representations into state variable representations, they generate new domain knowledge, where new means accessible in this context. Effectively, these techniques turn into internal mini theorem provers since, rather than merely translating, they firstly selectively explore the deductive closure of the original theory to find theorems that permit optimising the representation and secondly execute those\noptimisations.3 We will show that the cost of performing these optimisations is worth it because it is very fast and can be amortised over many problems.\nMutual exclusion invariants are also beneficial in pruning the search space for search methods such as symbolic techniques based on SAT (Kautz and Selman, 1999; Huang et al., 2010) and backward chaining search (Blum and Furst, 1997). In addition, as invariants help to reduce the number of variables required to encode a domain, they are used in planning systems based on binary decision diagrams (BDDs) (Edelkamp and Helmert, 2001), constraint programming (Do and Kambhampati, 2001), causal graph heuristics (Helmert, 2006) and pattern databases (Haslum et al., 2007).\nFinally, from a knowledge engineering perspective, the invariant synthesis presented in this paper can be used as a powerful tool for debugging temporal planning domains, although we do not focus on this specifically in this paper. As shown in Cushing et al. (2007), several temporal planning tasks developed for the various IPC editions are bugged with the consequence that the planners take a long time to solve them, when they actually manage to do so. As invariants capture intuitive properties of the physical systems described in the domains, it is easy for a domain expert to identify modelling mistakes by inspecting them. Discrepancies between the invariants found by the automatic technique and those that the expert expects to see for a given domain indicate that the domain does not encode the physical system correctly. In consequence, the expert can revise the domain and repair it. For example, considering the Rover domain, we expect that a store could be either full or empty at any time point. However, the invariant synthesis does not produce an invariant with the atoms full and empty. It can be shown that this is because the action drop is not properly modelled. Our technique not only alerts the expert that the system is not properly modelled, but also refers the expert to the action that is not encoded correctly. This is a useful feature to fix modelling errors quickly and safely.\n1.2. Contributions of the paper\nIn brief, the contributions of this paper are the following. From a theoretical point of view:\n• We give the first formal account of a mutual exclusion invariant synthesis for temporal domains that works at the lifted level of the representation. Our presentation of this topic is rigorous and comprehensive and our theory is general and not tailored around IPC domains as with related techniques.\n• Our technique is based on inferring general properties of the state space by studying the structure of the action schemas and the lifted relations in the domain, without the need to ground it. This is generally an hard task. Our theoretical framework is sophisticated, but it results in practical tools that have high efficiency and low computational cost.\nFrom a practical point of view:\n• We provide a tool for optimising the generation of state variables from propositions and actions. This results in compact encodings that benefit the performance of planners, as we will show in our experimental results (see Section 10).\n3One might argue that optimising is a more technically precise term than translating\n• We offer a technique that can be used as a debugging tool for temporal planning domains. As this type of domains are particularly challenging to encode, especially when large and complex, a rigorous debugging process is crucial in producing correct representations of the systems under consideration.\n1.3. Organisation of the paper\nThis paper is organised as follows. After presenting PDDL and PDDL2.1, our input languages, in Section 2, we formally introduce the notion of invariance in Section 3.\nSections 4, 5 and 6 are devoted to a detailed analysis of actions at the ground level. In particular, Section 4 focuses on instantaneous actions: the fundamental concept of strong safety is introduced and analysed and a first sufficient result for invariance, Corollary 24, is established. Section 5 analyses sequences of actions and, in particular, durative actions (seen as a sequence of three instantaneous actions) for which two new concepts of safety are proposed and investigated: individual and simple safety. Our main technical results are presented in Section 6 and consist of Theorem 49, Theorem 51 and Corollary 57: these results insure invariance under milder safety requirements on the durative actions than Corollary 24. This is obtained by adding requirements that prevent the intertwinement of durative actions that are not strongly safe.\nSections 7 and 8 are devoted to lift the concepts and results obtained in the previous sections to the level of action schemas. In particular, Section 7 deals with the problem of lifting the concept of strong safety for instantaneous schemas, while Section 8 considers durative action schemas and presents the lifted version of our main results, Corollaries 95, 96 and 97.\nThese results are the basic ingredients of our algorithm to find invariants, which is proposed in Section 9. Section 10 reports an extensive experimental evaluation of our approach against the domains of the last three IPCs. Sections 11 and 12 conclude the paper with a description of related works and closing remarks. There are three appendices: Appendix A and B contain the specifications of the planning domains used as the running examples in the paper; Appendix C contains all the technical proofs."
    }, {
      "heading" : "2. Canonical Form of Planning Tasks",
      "text" : "In this work, we consider planning instances that are expressed in PDDL2.1 (Fox and Long, 2003). However, before applying our algorithm to find invariants, we manipulate the domain to enforce a regular structure in the specification of the action schemas. In what follows, we first give an overview of this canonical form that we use and then describe how such a form can be obtained starting from a domain expressed in PDDL2.1.\n2.1. PDDL Canonical Form\nA planning instance is a tuple I = (D,P), where D is a planning domain and P a planning problem. The domainD = (R,Ai,Ad, arity) is a 4-tuple consisting of finite sets of relation symbols, instantaneous actions, durative actions, and a function arity mapping all of these symbols to their respective arities. P = (O, Init,G) is a triple consisting of the objects in the domain, the initial logical state and the goal logical state specifications.\nThe ground atoms of the planning instance, Atms, are the (finitely many) expressions formed by applying the relations in R to the objects in O (respecting arities). A logical state is any subset of Atms and S = 2Atms denotes the set of logical states. The initial state Init ∈ S and the goal G ⊆ S is a subset of logical states (typically defined as a conjunction of literals). A state is a\ntuple in R×S, where the first value is the time of the state and the second value (logical state) is a subset of Atms. The initial state for I is of the form (t0, Init).\nThe set Ai is a collection of instantaneous action schemas. An instantaneous action schema α is composed of the following sets:\n• Vα, i.e. the free schema’s arguments;\n• Preα = Pre+α ∪ Pre−α , where Pre+α are the positive preconditions and Pre−α the negative preconditions;\n• E f fα = E f f +α ∪ E f f −α , where E f f +α are the add effects and E f f −α the delete effects.\nPreconditions and effects are sets of literals l of the form: ∀v1, . . . , vk : q where q is a nonquantified positive literal of the form r(v′1, . . . , v ′ n), where r ∈ R, arity(r) = n, {v1, . . . , vk} ⊆ {v′1, . . . , v′n} is the set of quantified arguments, {v′1, . . . , v′n} \\ {v1, . . . , vk} ⊆ Vα is the set of free arguments. The universal quantification can be trivial (i.e. quantification over zero arguments) and, in this case, it is omitted. We indicate the set of the positions of the free and the quantified arguments, respectively, as Var[l] and Varq[l], and the pair 〈r, a〉, where r is the relation symbol that appears in literal q and a is its arity, as Rel[l]. Given a position i, we indicate the corresponding argument as Arg[i, l].\nThe set Ad is a collection of durative action schemas. A durative action schema Dα is a triple of instantaneous action schemas Dα = (αst, αinv, αend) such that Vαst = Vαinv = Vαend (this common set is denoted VDα). We indicate as {Dα} the set {αst, αinv, αend}.\nWe call A the set of all the instantaneous actions schemas in the domain, including those induced by durative actions: A = Ai ∪ ⋃\nDα∈Ad {Dα}. Given any two action schemas α1 and α2 in\nA such that it does not exist a durative action Dα with both α1 and α2 in {Dα}, we assume that the free arguments of α1 and α2 are disjoint sets, i.e. Vα1 ∩ Vα2 = ∅.\nGiven an action schema α ∈ Ai with free arguments Vα, consider an injective grounding function gr : Vα → O that maps the free arguments in α to objectsO of the problem. The function gr induces a function on the literals in α as follows. Given a literal l that appears in α, we call g̃r(l) the literal that is obtained from l by grounding its free arguments according to gr and gr(l) the set of ground atoms obtained from g̃r(l) by substituting objects in O for each quantified argument in l in all possible ways. Note that, when there are no quantified arguments, g̃r(l) = gr(l) and they are singletons. Given a set L containing literals l1, . . . ln, we call g̃r(L) = g̃r(l1) ∪ . . . ∪ g̃r(ln) and gr(L) = gr(l1) ∪ . . . ∪ gr(ln). We call g̃r(α) the action schema obtained from α by grounding each literal l that appears in α according to gr and gr(α) the ground action that is obtained from g̃r(α) by replacing the quantified arguments with the set of ground atoms formed by substituting objects in O for the quantified arguments in all possible ways.\nGiven a durative action schema Dα ∈ Ad and a grounding function gr, the ground durative action gr(Dα) is obtained by applying gr to the instantaneous fragments of Dα: gr(Dα) = (gr(αst), gr(αinv), gr(αend)). Note that we cannot apply different grounding functions to different parts of a durative action schema.\nGiven a ground action a, we indicate its positive and negative preconditions as Pre±a and its add and delete effects as E f f ±a . We call GAi, GAd, respectively, the set of instantaneous, and durative ground actions. Finally, we call GA the set of all ground actions in I (obtained from grounding all schemas inA).\nA ground action a is applicable in a logical state s if Pre+a ⊆ s and Pre−a ∩ s = ∅. The result of applying a in s is the state s′ such that s′ = (s \\E f f −a )∪E f f +a . We call ξ this transition function: s′ = ξ(s, a).\nThe transition function ξ can be generalised to a set of ground actions A = {a1, . . . , an} to be executed concurrently: s′ = ξ(s, A). However, in order to handle concurrent actions, we need to introduce the so-called no moving targets rule: no two actions can simultaneously make use of a value if one of the two is accessing the value to update it. The value is a moving target for the other action to access. This rule avoids conflicting effects, but also applies to the preconditions of an action: no concurrent actions can affect the parts of the state relevant to the precondition tests of other actions in the set (regardless of whether those effects might be harmful or not). In formula, two ground actions a and b are non-interfering if:\nPrea ∩ (E f f +b ∪ E f f −b ) = Preb ∩ (E f f +a ∪ E f f −a ) = ∅\nE f f +a ∩ E f f −b = E f f +b ∩ E f f −a = ∅ If two actions are not non-interfering, they are mutex.\nIn this work, whenever we consider a set of concurrent actions A = {a1, . . . , an}, we implicitly assume that the component actions are pairwise non-interfering. In this case, given a state s such that each ai ∈ A is applicable in s, the transition function s′ = ξ(s, A) is defined as follows:\ns′ = (s \\ ⋃ a∈A E f f −a ) ∪ ⋃ a∈A E f f +a\nThe following useful result shows that the application of a set of actions can always be serialised.\nProposition 1 (Serialisability). Given a set of actions A = {a1, . . . , an} and a state s in which A is applicable, consider the sequence of states recursively defined as s0 = s and sk = ξ(sk−1, ak) for k = 1, . . . , n. Then,\n(i) The sequence sk is well defined: ak is applicable in sk for every k = 1, . . . , n;\n(ii) sn = ξ(s, A).\nAn instantaneous timed action has the following syntactic form: (t, a), where t is a positive rational number in floating point syntax and a is a ground instantaneous action. A durative timed action has the following syntactic form: (t,Da[t′]), where t is a rational valued time, Da is a ground durative action and t′ is a non-negative rational-valued duration. It is possible for multiple timed actions to be given the same time stamp, indicating that they should be executed concurrently.\nA simple plan π for an instance I is a finite collection of instantaneous timed actions and a plan Π consists of a finite collection of (instantaneous and durative) timed actions. The happening time sequence {ti}i=0,...,k̄ for a plan Π is:\n{t0} ∪ {t|(t, a) ∈ Π or (t,Da[t′]) ∈ Π or (t − t′,Da[t′]) ∈ Π}\nNote that the last disjunct allows the time corresponding to the end of execution of a durative action to be included as a happening time.\nGiven a plan Π, the induced simple plan for Π is the set of pairs π containing:\n(i) (t, a) for each (t, a) ∈ Π, where a is an instantaneous ground action;\n(i) (t, ast) and (t + t′, aend) for all pairs (t,Da[t′]) ∈ Π, where Da is a durative ground action; and\n(i) ((ti + ti+1)/2, ainv) for each pair (t,Da[t′]) ∈ Π and for each i such that t ≤ ti < (t + t′), where ti and ti+1 are in the happening sequence for Π.\nThe happening at time t of the plan π is defined as At = {a ∈ GA | ∃t (t, a) ∈ π}. Note that in π we have formally lost the coupling among the start and end fragments of durative actions. Since in certain cases this information is necessary, we set a definition: a durative action Da is said to happen in π in the time interval [t, t + t′] whenever this holds true in the original plan Π, namely when (t,Da[t′]) ∈ Π.\nA simple plan π for a planning instance I is executable if it defines a happening sequence {ti}i=0...k̄ and there is a sequence of logical states {si}i=0...k̄ such that s0 = Init and for each i = 0, . . . , k̄, si+1 is the result of executing the happening at time ti in π. Formally, we have that Ati+1 is applicable in si and si+1 = ξ(si, Ati+1 ). The state sk̄ is called the final logical state produced by π. The sequence of times and states {S i = (ti, si)i=0...k̄} is called the (unique) trace of π, trace(π). Two simple plans are said to be equivalent if they give rise to the same trace.\nThe following result holds, from the definition of mutex, induced plan and executability:\nRemark 2. Given a ground durative action Da = (ast, ainv, aend) and a ground instantaneous action a′, if a′ and ainv are mutex, then there is no executable simple plan that contains the timed actions (t1, ast), (t2, a′) and (t3, aend) with t1 < t2 < t3.\nA simple plan for a planning instance I is valid if it is executable and produces a final state sk̄ ∈ G.\nWe call Plans all the valid (induced and not) simple plans for I and Sr the union of all the logical states that appear in the traces associated with the plans in Plans: Sr = {s | ∃ π ∈ Plans and (t, s) ∈ trace(π)}. Note that Sr ⊆ S. We call the states in Sr reachable states.\n2.2. From PDDL2.1 to Canonical PDDL\nWe build the canonical form described above starting from PDDL2.1 instances, which are characterised by metric and temporal information (Fox and Long, 2003). Numeric variables can be seen as already in the variable/value form and so we do not handle them. We could potentially exploit metric information in order to find additional state variables, but currently we do not do that. Instead, we assume that numeric variables are already in the right form and ignore them and numeric constraints when we look for logical state variables.\nTemporal information are handled in PDDL2.1 by means of durative actions. They can be either discretised or continuous, but we focus on discretised durative actions only here. They have a duration field and temporally annotated conditions and effects. The duration field contains temporal constraints involving terms composed of arithmetic expressions and the dedicated variable duration. The annotation of a condition makes explicit whether the associated proposition must hold at the start of the interval (the point at which the action is applied), the end of the interval (the point at which the final effects are asserted) or over all the interval (open at both ends) from the start to the end (invariant over the duration of the action). The annotation of an effect makes explicit whether the effect is immediate (it happens at the start of the interval) or delayed (it happens at the end of the interval). No other time points are accessible. Logical changes are considered to be instantaneous and can only happen at the accessible points. To build our canonical form, we transform durative actions into triples of instantaneous actions. We do this in such a way that we do not change the set of plans that can be obtained for any goal\nspecification. Plans with durative actions, in fact, are always given a semantics in terms of the semantics of simple plans (Fox and Long, 2003), as explained in the previous section.\nLet us see now in more detail how we obtain the PDDL canonical form from PDDL2.1 instances.\nA PDDL2.1 instance looks the same as a canonical instance, except for the set of action schemas in the domain. In particular, in a PDDL2.1 domain, in place of the sets Ai and Ad, we find a set Aa that contains both instantaneous and durative action schemas, which have the following characteristics. Durative action schemas have temporally annotated conditions and effects, which we indicate as Prex and E f f x, where x is in the set {st, inv, end}. Given an action schema inAa (durative or not), the condition formula can be a relation, a negation, a conjunction or disjunction of relations or a quantified formula on relations. The effect formula can be a relation, a negation or a conjunction of relations, a universally quantified formula on relations or a conditional effect formula, which is a tuple formed by a precondition formula and and effect formula. We manipulate the action schemas in Aa to obtain Ai and Ad, where each action schema in these sets has the canonical form described in Section 2.1.\nFirst, we eliminate conditional effects and existentially quantified formulae through an operation referred to as flattening (see Fox and Long (2003) for details). Since these features are syntactic sugar, they can be eliminated by applying simple syntactic transformations. The resulting schemas are equivalent to the original ones.\nGiven a flatten action schema α, we take the formulas (temporally annotated or not) in its conditions and effects and normalise them by using the algorithm introduced by Helmert (2009) (we refer the interested reader to this paper for a full description of the normalisation process4). After normalisation, all action schema conditions and effects become sets of universally quantified first-order literals l of the form ∀v1, . . . , vk : q, where q is a non-quantified literal and the universal quantification can be trivial. We indicate by Pre+α and E f f + α the set of positive literals that appear positive in α and by Pre−α and E f f − α the set of positive literals that appear negative in α. Note that we consider illegal durative action schemas Dα such that it exists a literal l that satisfies one of the following conditions:\n• l ∈ Pre−invDα and l ∈ (Pre+stDα \\ E f f −stDα ) ∪ E f f +stDα ;\n• l ∈ Pre+invDα and l ∈ (Pre−stDα \\ E f f +stDα ) ∪ E f f −stDα ;\n• l ∈ Pre+invDα and l ∈ Pre−endDα ;\n• l ∈ Pre−invDα and l ∈ Pre+endDα We assume thatAa contains no durative action schemas of such types.\nAfter flattening and normalisation, we transform the durative action schemas inAa in triples of instantaneous action schemas. Given a durative action Dα ∈ Aa, we create two instantaneous action schemas that correspond to the end points of Dα, αst and αend, and one that corresponds to the invariant conditions that must hold over that duration of Dα, αinv. More formally, given a durative action schema Dα we create αst, αinv and αend as follows:\n4Our normalisation differs from Helmert (2009) only in that we preliminarily eliminate conditional effects by applying the flattening operation before normalisation and we keep universal quantification in the preconditions. We also apply normalisation not only to formulas appearing in instantaneous actions as in Helmert (2009), but also to temporally annotated formulas in durative actions. We normalise the formulas and leave the temporal annotation unchanged.\nAt this point, we are ready to construct Ai and Ad from Aa. We add each flatten and normalised instantaneous action in Aa to Ai. For each durative action Dα ∈ Aa, after applying flattening and normalisation, we create the corresponding tuple (αst, αinv, αend) and add it toAd.\nGiven a planning instance I in canonical form obtained from a PDDL2.1 instance I′ and a valid plan Π for I, Π can be converted into an equivalent valid plan Π′ for I′.\n2.3. Running Example: the Floortile Domain\nWe use the Floortile domain as our running example. It has been introduced in the IPC-2014 and then reused in 2015. The full PDDL2.1 specification is available in Appendix A. The domain describes a set of robots that use different colours to paint patterns in floor tiles. The robots can move around the floor tiles in four directions (up, down, left and right). Robots paint with one color at a time, but can change their spray guns to any available color. Robots can only paint the tile that is in front (up) and behind (down) them, and once a tile has been painted no robot can stand on it.\nWe have the following relations in this domain: R = { up, down, right, left, robot-at, robot-has, painted, clear, available-color }. They have arity two, except for the last two, which have arity one. clear indicates whether a tile is still unpainted, available-color whether a color gun is available to be picked by a robot and up, down, right, left indicate the respective positions of two tiles.\nThe set of instantaneous action schemasAi is empty, while the set of durative action schemas Ad is the following: Ad = {change-color, paint-up, paint-down, up, down, right, left }.\nAs an example, the durative action schema paint-up corresponds to the following triple: (paint-upst, paint-upinv, paint-upend), where the single instantaneous action schemas have the following specifications:\nNote that the triple of single instantaneous action schemas in canonical form is obtained from the following PDDL2.1 specification:\n( : d u r a t i v e− a c t i o n p a i n t−u p : p a r a m e t e r s ( ? r − r o b o t ? y − t i l e ? x − t i l e ? c − c o l o r ) : d u r a t i o n (= ? d u r a t i o n 2 ) : c o n d i t i o n ( and ( ove r a l l ( r o b o t−h a s ? r ? c ) )\n( a t s t a r t ( r o b o t− a t ? r ? x ) ) ( ove r a l l ( up ? y ? x ) ) ( a t s t a r t ( c l e a r ? y ) ) )\n: e f f e c t ( and ( a t s t a r t ( not ( c l e a r ? y ) ) ) ( a t end ( p a i n t e d ? y ? c ) ) ) )"
    }, {
      "heading" : "3. Mutual Exclusion Invariants and Templates",
      "text" : "In this section, we formally introduce the concepts of invariant and mutual exclusion invariant and give examples of them.\nDefinition 3 (Invariant). An invariant of a PDDL2.1 planning instance is a property of the world states such that when it is satisfied in the initial state Init, it is satisfied in all reachable states Sr.\nFor example, given the Floortile domain, a trivial invariant says that for each object x, if x is a robot, then x is not a tile. Similar invariants hold for each type defined in the domain. A more interesting invariant says that, for any two objects x and y, if up(x,y) holds, then down(y,x) holds too, but down(x,y) does not. It is possible to identify several invariants for the Floortile domain, ranging from trivial invariants such as those involving type predicates to very complex invariants.\nIn this paper, we focus on mutual exclusion invariants, which state that a set of ground atoms can never be true at the same time.\nExample 1 (Floortile domain). A mutual exclusion invariant for this domain states that two ground atoms indicating the position of a robot identified as rbt1, such as robot-at(rbt1, tile1) and robot-at(rbt1,tile2), can never be true at the same time. Intuitively, this means that rbt1 cannot be in two different positions simultaneously. Another more complex invariant states that, given a tile tile1, a robot rbt1 and a colour clr1, atoms of the form clear(tile1), robot-at(rbt1, tile1) and painted(tile1,clr1) can never be true at the same time. This means that a tile can be in one of three possible states: not yet painted (clear), occupied by a robot that is painting it or already painted.\nDefinition 4 (Mutual Exclusion Invariant). Given a planning instance I, let Z be a set of ground atoms in 2Atms. A mutual exclusion invariant is an invariant stating that at most one element of Z is true in any reachable state. We refer to a set Z with this property as a mutual exclusion invariant set.\nIn what follows, we refer to mutual exclusion invariants and mutual exclusion invariant sets as simply invariants and invariant sets for the sake of brevity.\nAlthough we aim to find sets of mutually exclusive ground atoms, we often work with relations and action schemas to control complexity. A convenient and compact way for indicating several invariant sets at the same time involves using invariant templates, which are defined below, after introducing a few preliminary definitions.\nDefinition 5 (Component). A component c is a tuple 〈r, a, p〉, where r is a relation symbol in R, a is a number that represents the arity of r, i.e. a = arity(r), and p ∈ {0, . . . , a} is a number that represents the position of one of the arguments of r, which is called the counted argument. We put p = a if there are no counted arguments. The set of the labelled fixed arguments of c is Fc = {(c, i) | i = 0, . . . , (a − 1); i , p}.\nGiven a set of components C = {c1, c2, . . . , cn}, we define the set of fixed arguments of C as FC = ⋃ c∈C Fc.\nDefinition 6 (Admissible Partition). Given a set of components C and a set of fixed arguments FC, an admissible partition of FC is a partition FC = {G1, . . . ,Gk} such that |G j ∩ Fc| = 1 for each c ∈ C.\nGiven two elements (c1, i) and (c2, j) of FC that belong to the same set of the partition FC we use the notation: (c1, i) ∼FC (c2, j). Remark 7. Note that the existence of an admissible partition of FC implies that all the components in C have the same number of fixed arguments, which is also the number of the sets in the partition. In the special case in which the number of fixed arguments in each component is equal to one, there is just one admissible (trivial) partition FC = {FC}.\nDefinition 8 (Template). A template T is a pair (C,FC) such that C is a set of components and FC is an admissible partition of FC. We simply write T = (C) when the partition is trivial, i.e. FC = {FC}.\nBy previous considerations, the set of relations appearing in the set of components C of a template, up to a permutation of the position of the arguments, will always have the following form:\n{ri(xi1, . . . , xik, vi) i = 1, . . . , n1} ∪ {ri(xi1, . . . , xik) i = n1 + 1, . . . , n1 + n2}\nwhere vis indicate the counted arguments, xil’s the fixed arguments and x i l ∼FC x j l for every l, i, j.\nDefinition 9 (Template’s Instance). Given a template T , an instance γ of T is a function that maps the elements in FC to the objects O of the problem P such that γ(c1, i) = γ(c2, j) if and only if (c1, i) ∼FC (c2, j).\nDefinition 10 (Template’s Instantiation). The instantiation of T according to instance γ, γ(T ), is the set of ground atoms in 2Atms obtained as follows: for each component c = 〈r, a, p〉 of T , take the relation symbol r, for each element (c, i) ∈ FC bind the argument in position i according to γ((c, i)) and the counted argument in position p to all the objects O of the problem P.\nGiven how we construct γ(T ), it is easy to see that its elements will look as follows: γ(T ) = {ri(γ(xi1), . . . , γ(xik), vi) i = 1, . . . , n1} ∪ {ri(γ(xi1), . . . , γ(xik)) i = n1 + 1, . . . , n1 + n2}.\nInstances are interesting because they can be used to reason about their (exponentially larger) instantiations without, in fact, constructing those instantiations.\nGiven a template T and an instance γ, if the ground atoms in the instantiation of T according to γ are mutually exclusive in the initial state Init and remain such in any state reachable s ∈ Sr, then γ(T ) is (by definition) a mutual exclusion invariant set. A template with this property for each possible instantiation γ is called invariant template.\nDefinition 11 (Invariant Template). A template T is an invariant template if, for each instance γ, the instantiation of T according to γ is a mutual exclusion invariant set.\nGiven an invariant template T , we can create one state variable for each of its instances. The domains of these variables are the corresponding mutual exclusion invariant sets with an additional null value, which is used when no element in the mutual exclusion invariant set is true.\nBefore describing in what situations we can feasibly prove that a template is invariant, we introduce a final concept:\nDefinition 12 (Template Instance’s Weight). Given an instance γ of a template T , its weight in a state s, w(T , γ, s), is the number of ground atoms in its instantiation γ(T ) that are true in s:\nw(T , γ, s) = |s ∩ γ(T )|\nProposition 13. A template T is an invariant template if and only if, for each instance γ and each state s ∈ Sr, w(T , γ, s) ≤ 1.\nProof. It follows from Definitions 11 and 12.\nExample 2 (Floortile domain). A template for this domain is T f t = ({c1, c2, c3}), where:\n• c1 = 〈robot-at, 2, 0〉 is the first component. It includes the relation robot-at that has an arity of two (i.e. the relation robot-at(robot,tile) has two arguments) and the argument in position zero, i.e. robot, is the counted argument. The remaining argument, tile, which is in position one, is the fixed argument: Fc1 = {(c1, 1)}.\n• c2 = 〈painted, 2, 1〉 is the second component with Fc2 = {(c2, 0)}.\n• c3 = 〈clear, 1, 1〉 is the last component with Fc3 = {(c3, 0)}.\nNote that, since the three components have one fixed argument, all components are in the same equivalent class (trivial partition).\nAssume that we have a problem P with two robots rbt1 and rbt2, three tiles, tile1, tile2 and tile3 and one colour black. Consider one possible instance γ1 such that γ1((c1, 1)) = γ1((c2, 0)) = γ1((c3, 0)) = tile1. The instantiation of the template T f t according to γ1 is: γ1(T f t) = { robot-at(rbt1,tile1), +robot-at(rbt2,tile1)+, +painted(tile1,black)+, clear(tile1) }.\nThe weight of the instance γ1 in a state s is the number of ground instantiations of +robotat+ +(robot,tile)+, +painted(tile,colour)+ and +clear(tile)+ that are true in s, where the variable tile has been instantiated as tile1. If we have a state s in which no instantiations of robot-at(robot,tile) and +painted(tile,colour)+ are true, but clear(tile1) is true, the weight in s is one.\nWe will see that we can actually prove that T f t is an invariant, which states that a tile can be clear, already painted or in the process of being painted by a robot. Hence, for the problem P, we can create a state variable that represents each of the three tiles, whose values are the possible configurations of such tiles and the null value. It can also be proved that at least and at most one element of the mutual exclusion invariant set need to be true in any reachable state and, in consequence, the null value can be removed from the domain of the state variable. Hence we have: SVtile1 = { robot-at(rbt1,tile1), robot-at(rbt2,tile1), painted (tile1, black), clear(tile1) } and similarly for SVtile2 and SVtile3."
    }, {
      "heading" : "4. Safe Instantaneous Ground Actions",
      "text" : "In this and in the following sections, given a planning instance I = (D,P) and a template T , we discuss the conditions that T needs to satisfy to be an invariant. We make the standing assumption that the initial state Init satisfies the weight condition w(T , γ, Init) ≤ 1 for every instance γ and determine sufficient conditions on the families of instantaneous and durative actions in D that ensure that T is an invariant. In this section, in particular, we work out a concept of safety for instantaneous actions that guarantees that, when a safe action is executed, the weight bound is not violated.\n4.1. Safe instantaneous ground actions We assume a template T to be fixed as well an instance γ. Consider a set of concurrent pairwise non-interfering ground actions A ⊆ GA. The set of states s ∈ S on which A is applicable is denoted by SA. We start with the following definition:\nDefinition 14 (Strongly safe actions). The set of actions A is strongly γ-safe if, for each s ∈ SA such that w(T , γ, s) ≤ 1, the successor state s′ = ξ(s, A) is such that w(T , γ, s′) ≤ 1.\nThe study of strong γ-safety for an action set A can be reduced to the study of the state dynamics on the template instantiation γ(T ). This is intuitive and is formalised below. Remark 15. Given an action a ∈ GA, define aγ and a¬γ as the actions, respectively, specified by\nPre±aγ = Pre ± a ∩ γ(T ), E f f ±aγ = E f f ±a ∩ γ(T ) Pre±a¬γ = Pre ± a ∩ γ(T )c, E f f ±a¬γ = E f f ±a ∩ γ(T )c\n(where Ac denotes the set complement of A). Accordingly, we define, given an action set A, the action sets Aγ = {aγ | a ∈ A} and A¬γ = {a¬γ | a ∈ A}. Split now the states in a similar way: given s ∈ S, put sγ = s ∩ γ(T ) and s¬γ = s ∩ γ(T )c. Then, it is immediate to see that given a state s we have that s ∈ SA if and only if sγ ∈ SAγ ands¬γ ∈ SA¬γ and it holds that:\ns′ = ξ(s, A) ⇔ {\ns′γ = ξ(sγ, Aγ) s′¬γ = ξ(s¬γ, A¬γ)\n(1)\nThis leads to the following simple but useful result.\nProposition 16. For a set of actions A, the following conditions are equivalent:\n(i) A is strongly γ-safe;\n(ii) Aγ is strongly γ-safe;\n(iii) For every s ∈ SAγ such that s ⊆ γ(T ) and w(T , γ, s) ≤ 1, it holds that the successor state s′ = ξ(s, Aγ) is such that w(T , γ, s′) ≤ 1.\nDefinition 17 (Classification of Ground Actions). A set of ground actions A is:\n• γ-unreachable if |Pre+Aγ | ≥ 2;\n• γ-heavy if |Pre+Aγ | ≤ 1 and |E f f + Aγ | ≥ 2;\n• γ-irrelevant if |Pre+Aγ | ≤ 1 and |E f f + Aγ | = 0;\n• γ-relevant for T if |Pre+Aγ | ≤ 1 and |E f f + Aγ | = 1.\nIt is immediate to see that each A ⊆ GA belongs to one and just one of the above four disjoint classes. The following result clarifies their relation with strong safety.\nTheorem 18. Let A be a set of ground actions. Then,\n1. if A is γ-unreachable or γ-irrelevant, A is strongly γ-safe;\n2. if A is heavy, A is not strongly γ-safe.\nAs the next example shows, relevant action sets may be strongly safe or not.\nExample 3. Consider a template T and an instance γ such that γ(T ) = {q, q′, q′′}, where q, q′ and q′′ are three ground atoms, and A = {a}, where a is a ground action such that E f f +a = {q}. Since |E f f +a ∩ γ(T )| = 1, a is γ-relevant. Consider a state s ∈ SA such that w(T , γ, s) ≤ 1.\n• Suppose that Pre+a = {q′} and E f f −a = {q′} as shown in Figure 1, left. In this case, a is strongly γ-safe. In fact, q′ ∈ s and in consequence w(T , γ, s) = 1. Given s′ = ξ(s, a), q′ < s′, but q ∈ s′ and therefore w(T , γ, s′) = 1.\n• Supposed that Pre+a = ∅ and E f f −a = {q′} as shown in Figure 1, left. In this case, a is γrelevant, but is not strongly γ-safe. In fact, suppose that q′′ ∈ s and therefore w(T , γ, s) = 1. Since q′′ < E f f −a and q ∈ E f f +a , s′ = ξ(s, a) is such that w(T , γ, s′) = 2.\nγ(T) = {q, q', q''}\nWe now propose the following classification of relevant actions.\nDefinition 19 (Classification of Relevant Actions). A γ-relevant set of ground actions A is:\n• balanced if |Pre+Aγ | = 1 and Pre + Aγ ⊆ E f f +Aγ ∪ E f f − Aγ ;\n• unbalanced if |Pre+Aγ | = 1 and Pre + Aγ ∩ (E f f +Aγ ∪ E f f − Aγ ) = ∅;\n• bounded if |Pre+Aγ | = 0 and PreAγ ∪ E f fAγ = γ(T );\n• unbounded if |Pre+Aγ | = 0 and PreAγ ∪ E f fAγ , γ(T ).\nAgain it is obvious that every relevant set of ground actions A belongs to one and just one of the above four disjoint classes. The following results completes the analysis of strong safety.\nTheorem 20. Let A be a γ-relevant set of ground actions. Then,\n1. if A is balanced or bounded, A is strongly γ-safe;\n2. if A is unbalanced or unbounded, A is not strongly γ-safe.\nImmediate consequence of Theorems 18 and 20 is the following result:\nCorollary 21. Let A be a set of ground actions. Then,\n1. if A is either γ-unreachable, γ-irrelevant, γ-relevant balanced, or γ-relevant bounded, A is strongly γ-safe;\n2. if A is either γ-heavy, γ-relevant unbalanced, or γ-relevant unbounded, A is not strongly γ-safe.\nFinally, this result shows that strong γ-safety can always be checked at the level of single actions.\nProposition 22. Let A be a set of actions. Then, A is strongly γ-safe if a is strongly γ-safe for all a ∈ A.\nExample 4 (Floortile domain). Consider a template T = ({c}, {{(c, 0)}}), where c = 〈painted, 2, 1〉. Take two instances γ1(c, 0) = tile1 and γ2(c, 0) = tile2 and the ground action a =paint -up(rbt1,tile1,tile3,red) (Table 4). This action is strongly γ2−safe since it is irrelevant, but it is γ1-relevant and not strongly γ1−safe. This is because, given a state s ∈ SA such that, for example, painted(tile4,black)∈ s, s′ = ξ(s, a) is such that painted(tile4,black), painted(tile1,black) ∈ s′, with w(T , γ1, s′) = 2.\nWe conclude now with a definition and a first result that expresses a sufficient condition for a template to be invariant.\nDefinition 23. Given a template T , a set of actions A ⊆ GA is strongly safe if it is strongly γ-safe for every instance γ.\nWe have the following result:\nCorollary 24. Given a template T , T is invariant if for each a ∈ GA, a is strongly safe.\nProof. It follows from Remark 22, Definition 23 and Proposition 13.\nThe condition expressed in Corollary 24 cannot be inverted in general. Indeed, a template can be invariant even if not all actions are strongly safe. We will see when this happens in the following section."
    }, {
      "heading" : "5. Safe action sequences and safe durative actions",
      "text" : "A template can be invariant even if not all ground actions are strongly safe. This happens for two reasons. On the one hand, since the set of reachable states Sr is in general smaller than S, it may be that all the states that are responsible for the lack of strong safety are unreachable, i.e. they are not in Sr. On the other hand, in domains with durative actions, some instantaneous\nactions are temporally coupled because they are the start and end fragments of the same durative action. This coupling imposes constraints on the states where the end part can be applied, which might prove helpful to establish that a template is invariant. While in this paper we will not analyse the first case as it would require an analysis of the set of reachable states Sr, which is practically unfeasible, we now elaborate suitable simple concepts of safety for durative actions, which are weaker than strong safety. This extension is of great importance to apply our technique to real-world planning domains. In fact, they often present durative actions that have a non strongly safe end fragment, but that nonetheless never violate the weight condition when appearing in a plan. We propose a definition of safety for durative actions that captures this case. However, given that in a plan a durative action may intertwine with other actions that happen in between its start and end points, we need to work out a concept of safety for more general sequence of actions than just durative ones.\nBelow, we consider general sequences of ground action sets A := (A1, A2, . . . , An). Note that any valid simple plan π naturally induces such a sequence. Indeed, if trace(π) = {S i = (ti, si)i=0,...,k̄} and Ati are the relative happenings, we can consider the so called happening sequence of π: Aπ = (At0 , . . . , Atk̄ ). Aπ contains all the information on the plan π except the time values at which the various actions happen.\nTo study the invariance of a template, we break the happening sequence of each plan into subsequences determined by the happenings of durative actions. More precisely, we consider sequences A := (A1, A2, . . . , An) where, for some durative action Da = (ast, ainv, aend), we have that ast ∈ A1 and aend ∈ An. A2, . . . , An−1, as well as A1 and An, possibly contain other actions that are executed over the duration of Da. However, in the first instance, it is convenient to consider general sequences of ground actions A := (A1, A2, . . . , An) without referring to plans or durative actions. Hence, in this section, we first propose a definition of safety for A such that, when A is effectively executed serially in any valid plan π, the weight constraint is not violated in any intermediate step and at the end of the sequence, if it is not violated in the state where the sequence is initially applied. For single action sets (sequences of length n = 1), such concept coincides with the notion of strong safety.\nWe then consider a slightly stronger notion of safety which is robust to the insertion, between elements of the sequence, of other ground actions whose positive effects have no intersection with the template. To do this, it is necessary to introduce a number of auxiliary concepts relating to the state dynamics induced by the execution of A. This general theory will be then applied to sequences constructed from durative actions.\n5.1. Safe ground action sequences\nGiven a sequence of ground action sets A := (A1, A2, . . . , An), we denote with SA the set of state sequences (s0, . . . , sn) ∈ Sn+1 such that\nAi is applicable in si−1 and si = ξ(si−1, Ai) ∀i = 1, . . . , n\nIf (s0, . . . , sn) ∈ SA, we say that (s0, . . . , sn) is a state sequence compatible with A. Given an instance γ, we also define SA(γ) as the set of compatible state sequences (s0, . . . , sn) such that w(T , γ, s0) ≤ 1. We use the following notation for subsequences of A: Akh = (Ah, Ah+1, . . . , Ak).\nWe now fix a template T and an instance γ and propose the following natural definition of safety for a sequence.\nDefinition 25 (Individually safe actions). A sequence of ground action sets A := (A1, A2, . . . , An) is individually γ-safe if for every sequence of states (s0, . . . , sn) ∈ SA we have that\nw(T , γ, s0) ≤ 1 ⇒ w(T , γ, si) ≤ 1∀i = 1, . . . , n\nThe invariance of a template can now be expressed in terms of individual safety for the happening sequences.\nProposition 26. Let T be a template. Suppose that for every valid simple plan π, the sequence Aπ is individually γ-safe for every instance γ. Then, T is invariant.\nBelow are elementary properties of individual γ-safety for subsequences of A.\nProposition 27. Consider a sequence of ground action sets A := (A1, A2, . . . , An). The following properties hold:\n(i) if, for some k and h such that k ≥ h − 1, Ak1 = (A1, A2, . . . , Ak) and Anh = (Ah, . . . , An) are both individually γ-safe, then also A is individually γ-safe;\n(ii) if A is individually γ-safe and Ak and Ak+1 are non-interfering, then A′ = (A1, A2, . . . , Ak ∪ Ak+1, . . . , An) is individually γ-safe;\n(iii) if A is individually γ-safe and B j, for j = 1, . . . , n are action sets such that E f fB j = ∅, then, A′ = (A1, B1, A2, . . . , Bn, An) and A′′ = (A1 ∪ B1, . . . , An ∪ Bn) are individually γ-safe.\nThe following is a useful consequence of the previous results: it asserts that if individual safety holds locally in a sequence, then it also holds globally.\nCorollary 28. For a sequence of ground action sets A := (A1, A2, . . . , An), the following conditions are equivalent:\n(i) the sequence A is individually γ-safe;\n(ii) for each j = 1, . . . , n, there exists a subsequence A j+sj−r , with r, s ≥ 0, that is individually γ-safe.\nProof. (i)⇒(ii) is trivial and (ii)⇒(i) follows from an iterative use of (i) of Proposition 27.\nIndividual safety is a weak property since it is not robust with respect to the insertion of other actions, even when these actions are irrelevant but possess delete effects. This is connected to the fact that, while individual safety has this nice local to global feature illustrated in Corollary 28, it does not possess the opposite feature: subsequences of individual safe sequences may not be individual safe. The following example shows both these phenomena.\nExample 5. Consider a template T and an instance γ such that γ(T ) = {q, q′}. The set of state sequences compatible with A := (a1, a2) (Figure 2 - top diagram) is: SA = {(s0, s1, s2)|q < s0, s1 = s0 ∪ {q′}, s2 = s1}. Note that q < s0 because, by hypothesis, a2 is applicable in s1 and s1 = s0 ∪ {q′}. A is individually γ-safe since w(T , γ, si) ≤ 1 for every state si that appears in SA. Note that a1 is γ-relevant unbounded and thus not strongly γ-safe.\nNow consider the sequence Ã := (a1, b, a2) (Figure 2 - bottom diagram) where a γ-irrelevant action b is inserted between a1 and a2. The new set of state sequences compatible with Ã is: SÃ = {(s0, s1, s2, s3)|s1 = s0 ∪ {q′}, s2 = s1 \\ {q}, s3 = s2}. Note that now q can be in s0 since it is\nthe action b that ensures the applicability of a2. If q ∈ s0, since a1 adds q′ to s0, w(T , γ, s1) = 2. Clearly, this new sequence is not individually γ-safe. The insertion of a γ-irrelevant action has failed the individual γ-safety of the sequence A.\nFor proving some of our results, the concept of individual safety is not sufficient. Below we present a stronger definition of safety for an action sequence that is robust with respect to the insertion of irrelevant actions in it. First, we define the simple concepts of executable and reachable sequences.\nDefinition 29 (Executable and reachable actions). The sequence A = (A1, A2, . . . , An) is called:\n• executable if SA , ∅;\n• γ-(un)reachable if SA(γ) , ∅ (SA(γ) = ∅).\nRemark 30. Note the following chain of implications\nnon − executable ⇒ γ−unreachable ⇒ individually γ−safe\nNote that if π is a valid simple plan with happening sequence Aπ, then Aπ is γ-reachable for every γ due to the standing assumption that w(T , γ, Init) ≤ 1 for every γ. Moreover, every subsequence A of Aπ is executable. If a subsequence A of Aπ is γ-unreachable, the weight will surely exceed 2 at some point of the plan π and thus the template T will not be invariant.\nIn the special case of a sequence of length 2, executability and reachability admit very simple characterisations. We report them below as we will need them later. First define, for a generic set of actions A, the subsets\nΓ+A := (Pre + A \\ E f f −A ) ∪ E f f +A , Γ−A := (Pre−A \\ E f f +A ) ∪ E f f −A\nWe have the following result:\nProposition 31. Given a sequence of two ground action sets A = (A1, A2), the following conditions are equivalent:\n(i) A is executable;\n(ii) Γ+A1 ∩ Pre − A2 = ∅ = Γ − A1 ∩ Pre + A2 .\nProposition 32. Given a sequence of two ground action sets A = (A1, A2), the following conditions are equivalent:\n(i) A is γ-reachable;\n(ii) A is executable and |Pre+ A1γ ∪ (Pre+ A2γ \\ E f f + A1γ )| ≤ 1.\nThe following are immediate properties of executability and unreachability:\nProposition 33. Consider a sequence A = (A1, A2, . . . , An) that is executable or γ-reachable. Then,\n(i) if B j ⊆ A j are such that E f fB j = ∅ for every j = 1, . . . , n − 1, then also A′ = (A1 \\ B1, A2 \\ B2, . . . , An \\ Bn) is, respectively, executable or γ-reachable.\n(ii) if A j = A′ j ∪ A′′ j for some j = 1, . . . , n, then also A′ = (A1, A2, . . . A′ j, A′′ j, . . . , An) is, respectively, executable or γ-reachable.\nHere is our stronger notion of safety:\nDefinition 34 (Safe actions). A sequence of ground action sets A := (A1, A2, . . . An) is γ-safe if it is executable and Ak1 is individually γ-safe for every k = 1, . . . , n.\nNote how the sequence A := (a1, a2) considered in Example 5 is indeed not γ-safe, since a1 is not individually γ-safe. The next example shows instead the reason why executability is required.\nExample 6. Consider a template T and an instance γ such that γ(T ) = {q, q′, q′′}. The sequence A := (a1, a2) (Figure 5 - top diagram) is individually γ−safe because SA = ∅ (¬q′′ is required false by a2, but it is asserted true by a1).\nNow consider the sequence Ã := (a1, b, a2) (Figure 5 - bottom diagram) where a γ-irrelevant action b is inserted between a1 and a2. This insertion makes SA , ∅. Since q, q′ ∈ s3, w(T , γ, s3) = 2 and therefore A is not individually γ−safe.\nRemark 35. If A = (A1, A2, . . . An) is γ-safe, the first action set A1 must necessarily be strongly γ-safe. On the other hand, if A is executable and every A j for j = 1, . . . , n is strongly γ-safe then, A is γ-safe.\nThis motivates the following definition.\nDefinition 36 (Strongly and simply safe actions). A sequence of ground action sets A = (A1, A2, . . . , An) is:\n• strongly γ-safe if it is executable and every A j for j = 1, . . . , n is strongly γ-safe;\n• simply γ-safe if it is γ-safe but not strongly γ-safe.\nThe following result shows that heavy or relevant unbalanced actions cannot be part of safe reachable sequences.\nProposition 37. Suppose A = (A1, A2, . . . , An) is a γ-safe and γ-reachable sequence of ground action sets. Then, for every j = 1, . . . , n, A j is not γ-heavy and is no γ-relevant unbalanced.\nThe property of γ-reachability is necessary for the previous result to hold, as the following example shows.\nExample 7. Consider a template T and an instance γ such that γ(T ) = {q, q′}. The sequence A := (a1, a2) (Figure 4) is γ-safe because it is executable and the subsequences (a1) and (a1, a2) are both individually safe given that a1 is γ-unreachable. In this case, Proposition 37 does not hold since a2 is γ-heavy.\nIn studying the two safety properties for a sequence A introduced so far, we can essentially restrict ourselves to study the state dynamics on the template instantiation γ(T ) as we did for strong γ-safety of instantaneous actions (see Remark 15).\nGiven the sequence A := (A1, A2, . . . An), we denote by Aγ := (A1γ, A2γ, . . . Anγ) and A¬γ := (A1¬γ, A 2 ¬γ, . . . A n ¬γ) the corresponding restricted sequences. We have the following result.\nProposition 38. Given the sequence A := (A1, A2, . . . An),\n1. A is executable if and only if Aγ and A¬γ are both executable;\n2. A is γ-reachable if and only if Aγ is γ-reachable and A¬γ is executable;\n3. A is individually γ-safe if and only if Aγ is individually γ-safe.\n4. A is γ-safe if and only if Aγ is γ-safe and A¬γ is executable.\nWe are now ready to state and prove the following fundamental result, which ensures that the concept of safe sequence is robust to the insertion of irrelevant actions.\nTheorem 39. Consider a γ-safe sequence A := (A1, A2) and γ-irrelevant ground action sets B1, B2, . . . , Bn. Then, the sequence Ã := (A1, B1, . . . , Bn, A2) is either non executable or γ-safe.\nWe conclude this section with a last definition:\nDefinition 40. Given a template T , a sequence of ground action sets A is, respectively, safe or strongly safe if it is, respectively, γ-safe or strongly γ-safe, for every instance γ. It is simply safe if it is safe but not strongly safe.\n5.2. Safe ground durative actions We now restrict our attention to ground durative actions Da = (ast, ainv, aend). If we interpret Da as a sequence of three actions, we can consider for it the properties defined for general sequences such as γ-safety and strong γ-safety. We propose an explicit characterisation of these properties in this case, which will be useful later on.\nFirst, let us focus on the specific way in which durative actions appear in the happening sequence of a plan. Consider a simple induced plan π having trace(π) = {S i = (ti, si)i=0,...,k̄} and happenings Ati . Let Aπ be the corresponding happening sequence. If a durative action Da happens in π in the time interval [ti+1, t j], we clearly have that ast ∈ Ati+1 and aend ∈ At j . Moreover, by the way π is constructed from the original plan, we also have that j − i is odd and for every even h = 2, 4, . . . , j − i − 1, Ati+h consists of {ainv} and, possibly, preconditions of other durative actions happening in the original plan Π simultaneously or intertwined with Da. This motivates the following definition.\nDefinition 41 (Admissible actions). A sequence A := (A1, A2, . . . , An) is:\n• admissible if, for any durative action Da′, it holds\na′st ∈ Ai ⇒ a′inv ∈ Ai+1 a′end ∈ A j ⇒ a′inv ∈ A j−1\n• Da-admissible, for some durative action Da, if it is admissible and the following conditions are satisfied:\n(a) ast ∈ A1 and aend ∈ An; (b) n is odd and for every j = 2, 4, . . . , n − 1, A j consists of {ainv} and, possibly, precondi-\ntions of other durative actions.\nAny subsequence of the happening sequence of a simple plan is admissible and if its starting and its ending coincide with, respectively, the start and the end of a durative action Da, it is Da-admissible.\nTo study the safety of a Da-admissible sequence, we can, in many cases, reduce the analysis of the durative action Da to the analysis of an auxiliary sequence of just two actions Da∗ = (ast∗ , a end ∗ ), where a st ∗ and a end ∗ are instantaneous actions such that:\nE f f ±ast∗ = E f f ± ast , Pre ± ast∗ = Pre±ast ∪ (Pre±ainv \\ E f f ± ast ) E f f ± aend∗ = E f f ±aend , Pre ± aend∗ = Pre±aend ∪ Pre ± ainv\nThe relation between the two sequences Da and Da∗ is clarified by the following result. Assume, as always, that a template T and an instance γ have been fixed.\nProposition 42. The following facts hold true:\n(i) (s0, s1, s2) ∈ S(ast ,ainv) if and only if s1 = s2 and (s0, s1) ∈ Sast∗ ;\n(ii) (s0, s1, s2) ∈ S(ainv,aend) if and only if s0 = s1 and (s1, s2) ∈ Saend∗ ;\n(iii) (s0, s1, s2, s3) ∈ SDa if and only if s1 = s2 and (s0, s1, s3) ∈ SDa∗ ;\n(iv) (ast, ainv) is individually γ-safe if and only if ast∗ is strongly γ-safe;\n(v) (ainv, aend) is individually γ-safe if and only if aend∗ is strongly γ-safe;\n(vi) Da is individually γ-safe if and only if Da∗ is individually γ-safe.\nThe next result studies the effect of exchanging the start and end of a durative action Da with those of the auxiliary sequence Da∗ in a Da-admissible sequence.\nProposition 43. Consider a durative action Da = (ast, ainv, aend) and a Da-admissible sequence of actions A = ({ast}, A2, . . . , An−1, {aend}). Put A∗ = ({ast∗ }, A2, . . . , An−1, {aend∗ }). Then SA = SA∗ . In particular, A is individually γ-safe if and only if A∗ is individually γ-safe.\nThe last proposition implies that, in analysing the state dynamics in a valid plan, we can replace the start and end of each durative action Da with the corresponding ones of the auxiliary sequence Da∗, if such start and end happen isolated from other actions. This is useful for two reasons. On the one hand, there are cases in which Da∗ is strongly safe even if Da is not. On the other hand, we can directly apply Theorem 39 to Da∗ since it is of length 2.\nAs we shall see later, our sufficient results for the invariance of a template always require safety (strong or simple) of the auxiliary actions Da∗ = (ast∗ , a end ∗ ). The check for strong safety can be done by considering the single components of Da∗ and referring back to the analysis that we carried out in previous chapter. Below, we propose a full characterisation of simple safety for auxiliary actions.\nNote first that if Da∗ = (ast∗ , a end ∗ ) is simply γ-safe (Definition 36), necessarily Da∗ is executable, ast∗ is strongly γ-safe and a end ∗ is not strongly γ-safe. If, besides these three properties, Da∗ is γ-unreachable, then, Da∗ is simply γ-safe because of Remark 30. If we instead assume that Da∗ is simply γ-safe and γ-reachable, then, because of Proposition 37, we have that aend∗ is γ-relevant unbounded. The following result completely characterises simple γ-safety for such actions.\nProposition 44. Assume that Da∗ = (ast∗ , aend∗ ) is a γ-reachable sequence such that ast∗ is strongly γ-safe and aend∗ is relevant unbounded. Then, Da∗ is simply γ-safe if and only if one of the following mutually exclusive conditions are satisfied:\n(a) ast∗ γ-irrelevant, |Pre+ast∗γ | = 1, Pre + ast∗γ ⊆ E f f −ast∗γ ;\n(b) ast∗ γ-irrelevant, |Pre+ast∗γ | = 1, Pre + ast∗γ * E f f −ast∗γ , Pre + ast∗γ ⊆ E f f − aend∗γ ∪ E f f + aend∗γ ;\n(c) ast∗ γ-irrelevant, |Pre+ast∗γ | = 0, Pre − ast∗γ ∪ E f f −ast∗γ ∪ E f f − aend∗γ ∪ E f f + aend∗γ = γ(T );\n(d) ast∗ γ-relevant, E f f + ast∗γ ⊆ E f f −ast∗γ ∪ E f f + ast∗γ .\nRemark 45. If Condition (a) of Proposition 44 holds, this implies that the same conditions needs to be satisfied by ast, namely it holds: |Pre+astγ | = 1, Pre + astγ ⊆ E f f −astγ .\nDefinition 46 (Safe durative actions). We say that Da∗ is simply γ-safe of type (x) where x ∈ {a, b, c, d} if it is γ-reachable, ast∗ is strongly γ-safe, aend∗ is γ-relevant unbounded, and, finally, Da∗ satisfies the condition (x) of Proposition 44.\nExample 8. Consider a template T and an instance γ such that γ(T ) = {q, q′}. Figure 5 shows possible instances of actions of types (a)-(d).\nWhen the start or the end of a durative action Da happen simultaneously with other actions, the reduction of Da to Da∗ cannot be performed in general as shown in the following example.\nExample 9. Consider a template T and an instance γ such that γ(T ) = {q, q′, q′′}. Figure 6 shows that, when the durative actions Da and Da′ are considered in isolation, both ast∗ and a′st∗ are strongly safe since they are γ-unreachable. Since a end ∗ and a ′end ∗ are irrelevant, Da and Da′ are strongly safe. However, if we now consider the case in which Da and Da′ happen simultaneously, giving rise to the sequence A = (A1 = {ast, a′st}, A2 = {ainv, a′inv}), we see that A is not individually γ-safe. In fact, if we put s0 = {q′′} with w(T , γ, s0) = 1, we have that s1 = ξ(s0, A1) = {q, q′′, q′′′} with w(T , γ, s1) = 3, which violates the definition of individual γ-safety.\nNote that, in the previous example, the two durative actions are γ-unreachable. The following result shows that such pathological phenomena can only happen in that case and will be instrumental for the results of the next section.\nProposition 47. Let Da be a γ-reachable durative action such that ast is not strongly γ-safe, while ast∗ is strongly γ-safe. Then,\n(i) ast∗ is γ-relevant bounded;\n(ii) for every ground action sets A1 such that ({ast} ∪ A1, ainv) is executable, ({ast} ∪ A1, ainv) is individually γ-safe.\nNo similar results hold for the end parts of durative actions as next example shows.\nExample 10. Consider a template T and an instance γ such that γ(T ) = {q, q′}. When the durative actions Da and Da′ (Figure 5.2) are considered in isolation, both aend∗ and a ′end ∗ are strongly γ-safe since they are γ-bounded. Since ast∗ and a ′st ∗ are irrelevant, Da and Da\n′ are strongly safe. However, if Da and Da′ happen simultaneously, giving rise to the sequence A = (A1 = {ainv, a′inv}, A2 = {aend, a′end}), A is not individually γ-safe. If we put s0 = ∅ with w(T , γ, s0) = 0, we have that s1 = ξ(s0, A1) = ∅ and s2 = ξ(s1, A2) = {q, q′} with w(T , γ, s2) = 2, which violates the definition of individual γ-safety."
    }, {
      "heading" : "6. Conditions for the invariance of a template",
      "text" : "Any plan π where all instantaneous ground actions are strongly safe, all durative ground actions are safe and take place in isolation, i.e. with no other actions happening in between them, yields a safe happening sequence Aπ, as a consequence of Corollary 28. The difficulty, in general, is that durative actions can in principle start or end together and be intertwined with other instantaneous or durative actions. Safety of durative actions must therefore be accompanied by suitable hypothesis guaranteeing that dangerous intertwinements or simultaneous happenings cannot take place in valid plans. In this way, we can work out sufficient conditions for the invariance of a template, which will be useful in analysing concrete examples.\nIn this section, we present two results that give sufficient conditions for the invariance of a template. The first deals with the particular case when all instantaneous actions are strongly safe and all durative actions Da are such that Da∗ is strongly safe. The second result considers a more general case when there are durative actions Da for which Da∗ is only simply safe. We recall our standing assumption that w(T , γ, Init) ≤ 1 for every γ.\nGiven a templateT and an instance γ, we denote byGAd(γ) the collection of durative actions which are not strongly γ-safe and with GAst(γ) and GAend(γ), respectively, the collection of their start and end fragments. The following property prevents the simultaneous end of durative actions that could yield unsafe phenomena.\nDefinition 48 (Relevant right isolated actions). Given a template T , the set of ground durative actions GAd is said to be relevant right isolated if, for every instance γ and for every Da1,Da2 ∈ GAd(γ), one of the following conditions is satisfied:\n(i) |E f f + a1endγ ∪ E f f + a2endγ | ≤ 1;\n(ii) at least one of the two pairs {a1end, a2end} or {a1inv, a2inv} is mutex;\n(iii) if they are both non-interfering, ({a1inv, a2inv}, {a1end, a2end}) is γ-unreachable.\nTheorem 49. Consider a template T and suppose that the set of instantaneous actions GAi and that of durative actions GAd satisfy the following properties:\n(i) every a ∈ GAi is strongly safe;\n(ii) for every instance γ and every Da ∈ GAd(γ), Da∗ is γ-reachable and strongly γ-safe;\n(iii) GAd is relevant right isolated.\nThen, T is invariant.\nNote that assumption (iii) in the statement of Theorem 49 is to exclude the simultaneous end of durative actions; if such phenomena can be excluded a-priori, the hypothesis can be removed.\nWhen there are durative ground actions Da for which Da∗ is not strongly γ-safe, further hypotheses are needed in order to guarantee that the template T is invariant. The main point is that, in this case, not only simultaneity can be harmful, but also any intertwinement between such a durative action and other actions. The following examples show the type of phenomena that can happen and that any theorem extending Theorem 49 needs to prevent.\nExample 11. Consider a template T and an instance γ such that γ(T ) = {q, q′, q′′}. Both the durative actions Da and Da′ (Figure 8) are γ-safe. However, they can intertwine in such a way to give rise to a sequence that is individually unsafe: A = (A1 = {ast}, A2 = {a′st}, A3 = {aend}, A4 = {a′end}). If we put s0 = {q} with w(T , γ, s0) = 1, we have that s4 = {q′, q′′} with w(T , γ, s4) = 2.\nast aend\nEff+: q'\nγ(T) = {q, q',q''}\nDa\na'st a'end\nEff+: q''\nDa'\nPre: q\ns1s0 s3\nEff-: q\nEff-: q\nPre+: q\nPre+: q\nEff+: q' Eff-: q Da\nDa'Pre: q\nEff+: q'' Eff-: q\ns2 s4\nq', q'' ∈ s4\nw(T,γ ,s4)=2\nFigure 8: Schemas Da and Da′ can intertwine in such a way to give rise to a sequence that is individually unsafe.\nThe following definition describes a set of durative actions for which such phenomena cannot take place. It consists of three requirements acting, for each instantiation γ, on the subset of dangerous durative actions GAd(γ). The first prevents the simultaneous happening of two start fragments of such durative actions. The second states that, between two successive start fragments of durative actions in GAd(γ), there must be the end of a third action also in GAd(γ). Finally, the third requirement prevents γ-relevant actions to happen in between a durative action in GAd(γ).\nDefinition 50 (Relevant non intertwining actions). Given a template T , the set of ground durative actions GAd is said to be relevant non intertwining if, for every instance γ, every Da ∈ GAd(γ) and for every γ-reachable Da-admissible sequence of actions\nA = ({ast} ∪ A1, A2, . . . , An−1, {aend} ∪ An) , (2)\nthe following conditions are satisfied:\n(i) A1 ∩ GAst(γ) = ∅;\n(ii) If A1 = ∅ and b ∈ A j ∩ GAst(γ) for j < n, then there exists b′ ∈ A j′ ∩ GAend(γ) for some 0 < j′ ≤ j;\n(iii) If A1 = ∅ and A j ∩ (GAst(γ) ∪ GAend(γ)) = ∅ for every j = 2, . . . , n − 1, then each A j is γ-irrelevant for j = 2, . . . , n − 1.\nWe are now ready to state and prove the main result of this section, that expresses a sufficient condition for a template to be invariant.\nTheorem 51. Consider a template T and suppose that the set of instantaneous actions GAi and that of durative actions GAd satisfy the following properties:\n(i) every a ∈ GAi is strongly safe;\n(ii) for every Da ∈ GAd, Da∗ is safe;\n(iii) the set GAd is relevant non-intertwining.\nThen, T is invariant.\nThe properties that the set of durative actions GAd needs to satisfy to be relevant non intertwining, which are expressed in Definition 50, are in general difficult to check as they require to consider sequences of actions of possibly any length. Below we propose a sufficient condition that guarantees such properties to hold, which is much simpler and suitable to be later analysed at the lifted level of action schemas.\nWe start with two definitions. The first is a left version of the relevant right isolated property. It prevents dangerous durative actions to start simultaneously. It is needed to insure condition (i) of Definition 50 of relevant non intertwining. The second definition allows us to reformulate conditions (ii) and (iii) of Definition 50.\nDefinition 52 (Relevant left isolated actions). Given a template T , the set of ground durative actions GAd is said to be relevant left isolated if, for every instance γ and for every Da1,Da2 ∈ GAd(γ), one of the following conditions is satisfied:\n(i) at least one of the two pairs {a1st, a2st} or {a1inv, a2inv} is mutex;\n(ii) if they are both non-interfering, ({a1st, a2st}, {a1inv, a2inv}) is γ-unreachable.\nDefinition 53 (Irrelevant unreachable actions). Consider a template T and an instance γ. A pair of actions (a, a′) is γ-irrelevant unreachable if any sequence of actions\nA = ({a}, A2, . . . , An−1, {a′})\nsuch that A2, . . . , An−1 are γ-irrelevant, is γ-unreachable.\nThe next result expresses a sufficient condition for the set GAd to be relevant non intertwining.\nProposition 54. Consider a template T . The set GAd is relevant non intertwining if the following conditions are satisfied:\n(i) GAd is relevant left isolated;\n(ii) for every instance γ, for every Da ∈ GAd(γ), and for every a′ ∈ GA \\ GAend(γ) that is not γ-irrelevant or a′ ∈ GAst(γ), {ainv, a′} is mutex or the pair (ast, a′) is γ-irrelevant unreachable.\nThe property of γ-irrelevant unreachable, though conceptually simpler than the original properties required in the definition of relevant non-intertwining actions, is still too complex for practical implementation, as it requires to verify properties over sequences of undefined length. We now propose a stronger version of it that is instead of simple computational complexity (linear in the number of ground actions).\nDefinition 55 (Strongly irrelevant unreachable actions). A pair of actions (a, a′) is strongly γirrelevant unreachable if any of the following conditions are satisfied:\n(i) there exists q ∈ Γ+a ∩ Pre−a′ such that, for every a′′ that is γ-irrelevant, q < E f f −a′′ ;\n(ii) there exists q ∈ Γ−a ∩ Pre+a′ such that, for every a′′ that is γ-irrelevant, q < E f f +a′′ ;\n(iii) |Pre+aγ ∪ (Pre+a′γ \\ E f f + aγ )| > 1.\nThe first condition essentially says that the application of the action a leads to a state containing a ground atom q that needs to be false in order to then apply a′ and that there is no γ-irrelevant action that can make this atom false. The second condition is the analogous of the first, but exchanges the role of true and false atoms. Finally, the third condition is equivalent to require that (a, a′) is a γ-unreachable pair, assuming that it is executable.\nProposition 56. If a pair of actions (a, a′) is strongly γ-irrelevant unreachable, it is also γirrelevant unreachable.\nBased on the previous results, we conclude with a simple sufficient condition for the invariance, which is very useful in analysing concrete cases.\nCorollary 57. Consider a template T and suppose that, for every instance γ,\n• every Da ∈ GAd(γ) is such that Da∗ is simply γ-safe of type (a);\n• every a ∈ GA \\ (GAst(γ) ∪ GAend(γ)) is either γ-irrelevant or γ-relevant balanced.\nThen, T is invariant."
    }, {
      "heading" : "7. Safety of Action Schemas for a Template",
      "text" : "In Section 6, we have established two results guaranteeing the invariance of a template, Theorems 49 and 51. To be applied, they both need to check that all instantaneous and durative ground actions satisfy a safety condition as well as that other extra properties, which prevent potentially dangerous simultaneous happenings or intertwinements among actions, hold true. Since we aim to find invariants off-line quickly and efficiently, our algorithm does not work at the level of\nground actions. Instead, it reasons at the lifted level and uses the structure of the action schemas, i.e. their conditions and effects, to decide whether the ground instantiations of these schemas are safe or not. Our main goal in this section is to obtain lifted versions of Theorems 49 and 51 and Corollary 57.\nIn general, we call liftable a property P of ground actions if, given an action schema α, if one instantiation a∗ = gr∗(α) satisfies P, then all instantiations a = gr(α) satisfy P. In this case, we say that the action schema α satisfies property P.\nThe results presented in this and the next sections achieve two main goals. On the one hand, they show that the properties of safety introduced for instantaneous and durative ground actions in Sections 4 and 5 are liftable as well the non-intertwining properties, even if in a weaker sense, behind the formulation of Theorems 49 and 51. On the other hand, they will give efficient characterisations of such properties at the lifted level, which we use in our algorithmic implementation (see Section 9).\nIn the remaining part of this section, we analyse instantaneous action schemas and their ground instantiations. We show that strong safety is liftable and work out a complete characterisation of this property at the lifted level. Next section is devoted to lifting properties for durative actions.\n7.1. Structure and properties of action schemas We start with the following definition that introduces the key concept of matching. It couples an action schema to a template and allows us to understand if, in the ground world, a ground literal appearing in an action schema is or is not in γ(T ).\nDefinition 58 (Matching). Given a template T = (C,FC) and an action schema α ∈ A, a literal l that appears in α such that it exists a template’s component c = 〈r, a, p〉 ∈ C with Rel[l] = 〈r, a〉 and, if l is universally quantified, Varq[l] = {p} is said to match T via the component c. Given two literals l and l′, we say that they are T -coupled (and we write l ∼T l′) if the following two conditions hold:\n(i) l and l′ individually match T via the components c and c′;\n(ii) if (c, i) ∼FC (c′, j), Arg[i, l] = Arg[ j, l′].\nWe now fix a template T and an action schema α and study the properties of the relation ∼T on the literals of α that match T , introduced above. First, it is useful to work out more concrete representations for literals: this is the content of next Remark.\nRemark 59. Suppose that l is a literal in the action schema α that matches the template T via the component c. The corresponding relation r will necessarily have the structure r(x1, . . . xk, v) where x j’s denote the fixed arguments, v the counted argument (which could also be absent) and l = r(a1, . . . ak, v) or l = r(a1, . . . ak, ak+1) depending if, respectively, l is universally quantified or simple, and where a1, . . . , ak, ak+1 are free arguments. Suppose now that l1 and l2 are two literals in the action schema α that match the template T via c1 and c2, respectively. Up to a permutation of the position of the fixed arguments, the corresponding relations r1 and r2 can be written as, ri(xi1, . . . x i k, v\ni) for i = 1, 2 where the fixed arguments satisfy the relations x1j ∼FC x2j for every j. If, moreover, l1 ∼T l2, the two literals will have the form li = ri(a1, . . . ak, ak+1) (or li = ∀v : ri(a1, . . . ak, v)), where a1, . . . , ak, ak+1 are the free arguments.\nProposition 60. Given a template T and an action schema α, ∼T is an equivalence relation.\nProof. The only property to be checked is transitivity and this is evident from the equivalent description of the relation ∼T proposed in Remark 59.\nAn equivalence class of literals with respect to ∼T is called a T -class. We now consider a grounding function gr for α and an instance γ for T . We recall the standing assumption that both gr and γ are injective maps (this will be often used in what follows). If l is a literal in α that matches T , the subset of ground atoms gr(l) is either a subset of γ(T ) or it must have empty intersection with γ(T ). This is simply because, both sets are closed under any modification of the assignment of the counted argument. This motivates the following definition:\nDefinition 61 (Coherence). gr and γ are coherent over l if gr(l) ⊆ γ(T ).\nCoherence is more concretely described in the following Remark.\nRemark 62. Suppose that l matches T via the component c whose relation is r. It follows from the considerations in Remark 59 that, depending if r posses a counted variable or not and if l is simple or universally quantified, r, l and gr(l) take the following forms:\nr(x1, . . . xk) l = r(a1, . . . ak) gr(l) = {r(gr(a1), . . . , gr(ak))} r(x1, . . . xk, v) l = r(a1, . . . ak, ak+1) gr(l) = {r(gr(a1), . . . , gr(ak), gr(ak+1))} r(x1, . . . xk, v) l = ∀v : r(a1, . . . ak, v) gr(l) = {r(gr(a1), . . . gr(ak), o), | o ∈ O}\nNote that, in all cases, the coherence condition gr(l) ⊆ γ(T ) is equivalent to require that:\ngr(a j) = γ(x j), ∀ j = 1, . . . , k (3)\nThe following result is immediate from the conditions (3):\nProposition 63. Let l be a literal of the action schema α. Then, for every grounding function gr, it is possible to find an instance γ such that gr and γ are coherent over l and viceversa.\nLemma 64. Assume that gr and γ are coherent over a literal l1 of α and let l2 be another literal in α that matches γ. Then, gr and γ are coherent over l2 if and only if l2 ∼T l1.\nThe following result immediately follows from the definition of coherence and Lemma 64.\nProposition 65. Suppose that M is a subset of literals appearing in α. Then, gr(M) ∩ γ(T ) = gr(M ∩ L) where L is the T -class of literals of α on which gr and γ are coherent.\nProposition 65 has an important practical consequence. Once gr and γ have been fixed, only the part of α made of literals in the class L where gr and γ are coherent affect the part of state dynamics concerning the set γ(T ). Precisely, if a = gr(α), it follows from the definition of aγ (see Remark 15) that:\nPre±aγ = gr(Pre ± α ∩ L), E f f ±aγ = gr(E f f ± α ∩ L)\nConsidering that, by Proposition 16, a is strongly γ-safe if and only if aγ is also strongly safe, the property of strong safety of an action schema α does not depend on the literals in α that do not match T . Hence, in principle, such a property should be analysed by studying the restrictions of α to the different T -classes L of matching literals. This intuition leads to the following definition.\nDefinition 66 (Pure Action Schemas). Given a template T , an action schema α and a T -class L of literals in α, we define αL to be the action schema where we only consider literals belonging to L. More precisely, αL is the action schema such that\nPre±αL = Pre ± α ∩ L, E f f ±αL = E f f ± α ∩ L\nWe call αL a pure action schema.\nExample 12 (Floortile domain). Consider the template T f t given in Example 2 and the action schema α =paint-upst: Pre+α = {robot-at(r,x), clear(y)}, E f f −α = {clear(y)}.\nNote that both literals robot-at(r,x) and clear(y) in α match T f t and form two differentT -classes because they do not satisfy condition (ii) in Definition 58: L1 = {robot-at(r, x)} and L2 = {clear(y)}.\nConsider the instance γ1 that associates tile1 to each fixed argument in the components of T f t and grounding function gr(r)=rbt1, gr(x) = tile1 and gr(y) = tile2. In this case, gr and γ1 are coherent on the T -class L1.\nWe have two pure action schemas corresponding to α: αL1 and αL2 . αL1 has the following specification: Pre+αL1 = {robot − at(r, x)} and αL2 : Pre + αL2 = {clear(y)}, E f f −αL2 = {clear(y)}.\n7.2. Pure Action Schema Classification\nWe now carry on a detailed analysis of pure action schemas, showing in particular how the check for strong safety for a ground action a = gr(α) can be efficiently performed at the lifted level working with the different pure action schemas αL.\nWe fix an action schema α and a T -class L of its literals. First, we introduce a concept of weight at the level of literals in L that allows us to distinguish between simple and universally quantified literals. Precisely, given l ∈ L, we put wl = 1 if l is simple, while wl = ω if l is universally quantified and where ω = |O|. Given a subset A ⊆ L, we define w(A) = ∑l∈A wl. Note that w(·) simply coincides with the notion of cardinality in case all literals in L are simple. If we consider a grounding function gr for α, then for every subset A ⊆ L, it holds:\n|gr(A)| = w(A) (4)\nSimilarly, if c is a component of T , we define wc equal to 1 or to ω if c, respectively, does not have or does have a counted variable.\nWe need a last concept:\nDefinition 67 (Coverage). Given a component c ∈ T , we let Lc to be the subset of literals in L that match T through the component c. A subset of literals M ⊆ L is said to cover the component c, if w(M ∩ Lc) ≥ wc. M is said to cover T , if M covers every component c ∈ T .\nRemark 68. If we consider a component c ∈ T , we have that all ground atoms generated by c are in gr(M) if and only if M covers c. In particular, γ(T ) = gr(M) if and only if M covers T .\nWe now propose a classification of the pure action schemas αL, formally analogous to the one introduced for action sets in Definitions 17 and 19: we simply replace preconditions and effects of aγ with those of αL and the concept of cardinality with that of weight.\nDefinition 69 (Classification of Pure Action Schemas). The pure action schema αL is:\n• unreachable for T if w(Pre+αL ) ≥ 2;\n• heavy for T if w(Pre+αL ) ≤ 1 and w(E f f +αL ) ≥ 2;\n• irrelevant for T if w(Pre+αL ) ≤ 1 and w(E f f +αL ) = 0;\n• relevant for T if w(Pre+αL ) ≤ 1 and w(E f f +αL ) = 1.\nDefinition 70 (Classification of Relevant Action Schemas). The pure relevant action schema αL is:\n• balanced for T if w(Pre+αL ) = 1 and Pre+α ⊆ E f f +αL ∪ E f f −αL ;\n• unbalanced for T if w(Pre+αL ) = 1 and Pre+α ∩ (E f f +αL ∪ E f f −αL ) = ∅;\n• bounded for T if w(Pre+αL ) = 0 and L covers T ;\n• unbounded for T if w(Pre+αL ) = 0 and L does not cover T .\nThe following result clarifies the relation with the corresponding ground actions.\nProposition 71. Consider an action schema α, a T -class L of its literals, a grounding function gr and an instance γ coherent over L. Put a = gr(α). Then, αL satisfies any of the properties expressed in Definitions 69 and 70 if and only if a satisfies the corresponding γ-property as defined in Definitions 17 and 19.\nProof. Immediate consequence of the fact that aγ = gr(αL), of equation (4), and of Remark 68.\nWe are now ready to propose the following final result concerning strong safety of general action schemas. It shows how strong safety can be seen as a property of an action schema and can be studied by analysing its pure parts.\nCorollary 72. Strong safety is a liftable property. Moreover, an action schema α is strongly safe if and only if, for every T -class of literals L of α, αL is unreachable, irrelevant, relevant balanced or relevant bounded.\nExample 13 (Floortile domain). Consider the templateT f t and the action schema α = paint-upst given in Example 12. The two pure action schemas αL1 and αL2 are both irrelevant and hence strongly safe. Hence, α is strongly safe.\nNow consider the action schema α′ =paint-upend with specification: E f f +α′ = {painted(y, c)}. This is a pure action schema. It is relevant unbounded and thus not strongly safe.\nAn immediate consequence of Corollary 24 is:\nCorollary 73. Given a template T , T is invariant if for each α ∈ A, α is strongly safe."
    }, {
      "heading" : "8. Durative action schemas",
      "text" : "Our goal now is to work out proper lifted versions of the properties of durative actions given in Section 5, in particular those involved in the statement of our main results, Theorems 49 and 51. Some of these properties concern just one durative action (e.g. safety), while others involve more actions (e.g. non-interfering, irrelevant unreachable). We start analysing the first type of\nproperties, presenting, in particular, an explicit characterisation of safety for durative actions at the lifted level.\nWe always use the following notation. Given a durative action schema Dα = (αst, αinv, αend) and a grounding function gr for Dα, we put Da = gr(Dα), where Da = (ast, ainv, aend) with ast = gr(αst), ainv = gr(αinv), and aend = gr(αend). Also, we define the auxiliary durative action schema Dα∗ = (αst∗ , α end ∗ ) where α st ∗ and α end ∗ are the instantaneous action schema such that:\nE f f ± αst∗ = E f f ±αst , Pre ± αst∗ = Pre±αst ∪ (Pre±αinv \\ E f f ± αst ) E f f ± αend∗ = E f f ± αend , Pre± αend∗ = Pre± αend ∪ Pre± αinv\nDa∗ = gr(Dα∗) is the corresponding ground auxiliary action already defined in Section 5.2.\n8.1. Safety of durative action schemas We now fix a template T and start to analyse safety. We consider a durative action schema Dα, its auxiliary action schema Dα∗ and its groundings Da = gr(Dα) and Da∗ = gr(Dα∗). Strong safety for durative actions reduces to check strong safety of its components and it is thus a liftable property. We can thus talk about the strong safety of Dα or Dα∗: this is equivalent to the strong safety of all its groundings, Da = gr(Dα) or, respectively, Da∗ = gr(Dα∗). Check of such property at the lifted level can be done using Corollary 72 for the starting and ending fragments.\nWe now want to characterise simple safety of the auxiliary durative action Da∗ = gr(Dα∗) at the lifted level. First we consider executability.\nDefine, for a generic action schema α, the subsets\nΓ+α := (Pre + α \\ E f f −α ) ∪ E f f +α , Γ−α := (Pre−α \\ E f f +α ) ∪ E f f −α\nWe have the following result:\nProposition 74. Executability of auxiliary durative actions is a lifted property. Precisely, Dα∗ is executable if and only if\nΓ+ αst∗ ∩ Pre− αend∗ = ∅ = Γ− αst∗ ∩ Pre+ αend∗ (5)\nProof. Immediate consequence of Proposition 31.\nAssume now Dα∗ to be executable. Fix an instance γ and let L be the the T -class of literals in Dα on which gr and γ are coherent. Put DαL = (αstL , α inv L , α end L ) and Dα∗L = (α st ∗L, α end ∗L ). Note that Da∗γ = gr(Dα∗L). Therefore, since simple γ-safety of Da∗ only depends on Da∗γ (since executability has already been assumed), we expect that such property can be formulated in terms of the pure auxiliary durative action schema Dα∗L. To this aim, we now propose, for such durative schemas, the same classification introduced for ground durative actions in Definition 46. First, we need a further concept:\nDefinition 75 (Reachable action schemas). Dα∗L is said to be reachable if it is executable and\nw(Pre+ αst∗L ∪ (Pre+ αend∗L \\ E f f + αst∗L )) ≤ 1\nProposition 76. If gr and γ are coherent over L and Da∗ = gr(Dα∗), we have that Da∗γ is γ-reachable if and only if Dα∗L is reachable.\nProof. Immediate consequence of Propositions 32 and 65 and of equation (4).\nDefinition 77 (Safe durative action schemas). When Dα∗L is such that\n(i) Dα∗L is reachable;\n(ii) αst∗L is strongly safe;\n(iii) αend∗L is relevant unbounded;\n(iv) Dα∗L satisfies any of the conditions below:\n(a) αst∗L irrelevant, w(Pre + αst∗L ) = 1, Pre+ αst∗L ⊆ E f f − αst∗L ; (b) αst∗L irrelevant, w(Pre + αst∗L ) = 1, Pre+ αst∗L * E f f − αst∗L , Pre+ αst∗L ⊆ E f f − αendL ∪ E f f + αendL ; (c) αst∗L irrelevant, w(Pre + αst∗L ) = 0, Pre− αst∗L ∪ E f f − αst∗L ∪ E f f − αendL ∪ E f f + αendL covers T ; (d) αst∗L relevant, E f f + αstL ⊆ E f f − αendL ∪ E f f + αendL .\nwe say that Dα∗L is simply safe of type (x) where x ∈ {a, b, c, d}.\nCorollary 78. Safety for durative auxiliary actions is a liftable property. Da∗ = gr(Dα∗) is safe if and only if:\n• Dα∗ is executable;\n• For every T -class L of literals in Dα, one of the following conditions hold:\n– Dα∗L is strongly safe; – αst∗L is strongly safe and Dα∗L is unreachable; – Dα∗L is simply safe of type (x) where x ∈ {a, b, c, d}.\nProof. Immediate consequence of previous definitions and Proposition 44.\nExample 14 (Floortile domain). Consider our usual template:\nT f t = ({〈robot-at, 2, 0〉, 〈painted, 2, 1〉, 〈clear, 1, 1〉}\nand the action schema:\nDα = paint − up : (paint − upst, paint − upinv, paint − upend)\nwhere the single instantaneous action schemas have the specifications as in Table 4. In this action schema, we have three literals that matchT f t: robot-at(r,x), clear(y) and painted(y,c). They form twoT -classes: L1 = {robot-at(r,x)} and L2 = {clear(y), painted(y,c)}. Note that in this case paint-upstLi is equal to paint-up st ∗Li for i = 1, 2 and the same holds for paint-upendLi . The pure action schemas paint-upstL1 , paint-up st L2\nand paint-upendL1 are strongly safe because they are irrelevant. The pure schema paint-upendL2 is relevant unbounded.\nThe pure durative action schema paint-upL1 is strongly safe because paint-up st L1 and paint-upendL1 are strongly safe since they are irrelevant.\nThe pure schema paint-upL2 is simply safe of type (a) since:\n• paint-upL2 is reachable because paint-upendL2 does not contain preconditions\n• paint-upstL2 is strongly safe since it is irrelevant;\n• paint-upendL2 is relevant unbounded;\n• w(Pre+ paint−upstL2 ) = 1 because the preconditions at start consist in clear(y);\n• Pre+ paint−upstL2 ⊆ E f f − paint−upstL2 because the delete effects at start also contain clear(y).\n8.2. Lifting properties of multiple actions\nIn this section, we study how properties that involve more than one action (e.g. mutex) can be lifted. This requires to work simultaneously with different groundings and, for this reason, additional concepts are need.\nConsider two action schemas α1 and α2 (instantaneous or durative) with set of free arguments Vα1 and Vα2 , respectively. Whenever we consider two groundings gr1 and gr2 for α1 and α2, respectively, the pairwise properties of the two actions ai = gri(αi) (e.g. properties regarding the sequence (a1, a2) or the set {a1, a2}) are non liftable, as in general they may depend on the specific groundings chosen. A key aspect is the possible presence, in the two action schemas, of pairs of free arguments vi ∈ V i f such that gr1(v1) = gr2(v2): this may cause the same ground atom to appear in the two actions a1 and a2, which in principle can affect the validity of certain properties, such as non-interference. To cope with this complexity at the lifted level, we introduce a concept of reduced union of the two sets Vα1 and Vα2 to be used as a common set of free arguments for the two schemas.\nWe define a matching between α1 and α2 as any subsetM ⊆ Vα1 × Vα2 such that:\n• If (v1, v2), (w1, v2) ∈ M, then v1 = w1;\n• If (v1, v2), (v1,w2) ∈ M, then v2 = w2.\nWe now define the set Vα1 tM Vα2 obtained by Vα1 ∪ Vα2 by reducing each pair of arguments v1 ∈ Vα1 and v2 ∈ Vα2 such that (v1, v2) ∈ M to a new argument, denoted as v1v2. Note that in the case whenM = ∅, no reduction takes place and Vα1 t∅ Vα2 = Vα1 ∪ Vα2 .\nGiven a matching M, we have natural maps πiM : V i f → Vα1 tM Vα2 associating to each argument vi, vi itself or the new reduced argument viv j in case (vi, v j) ∈ M. The two schemas α1 and α2 can thus be rewritten in this new alphabet by formally substituting each free argument vi ∈ V i f in their literals with πiM(v i). If li is a literal of αi, we denote by πiM(l i) the literal obtained with this substitution. Similarly, if Ai is a set of literals of αi, we put πiM(A i) = {πiM(l i) | li ∈ Ai}.\nOn the literals of the two schemas, expressed in the common argument set Vα1 tM Vα2 , we can jointly apply set theoretic operators. If li is a literal of αi and Ai is a set of literals of αi, for i = 1, 2, we will use the notation l1 =M l2 for π1M(l 1) = π2M(l 2) and l1 ∈M A2 for π1M(l1) ∈ π2M(A2). Similarly, we put A1 ∗M A2 = π1M(A1) ∗ π2M(A2) where ∗ ∈ {∪,∩, \\}. We now investigate the relation between matchings and specific groundings of the two schemas.\nDefinition 79 (Coherent grounding functions). Consider two action schemas α1 and α2 and a matching M between them. Two grounding functions gr1 and gr2 for α1 and α2, respectively, are said to beM-adapted if given vi ∈ V i f for i = 1, 2, it holds gr1(v1) = gr2(v2) if and only if (v1, v2) ∈ M.\nRemark 80. Note that, given two groundings gr1 and gr2, if we considerM = {(v1, v2) | gr1(v1) = gr2(v2)} we clearly have thatM is a matching (recall that maps gri are injective) and gr1 and gr2 areM-adapted.\nCoherent groundings can clearly be factorised through the reduced set Vα1 tM Vα2 :\nProposition 81. Consider two action schemas α1 and α2, a matching M between them, and grounding functions gri for αi, i = 1, 2. The following conditions are equivalent:\n(i) gr1 and gr2 areM-adapted;\n(ii) there exists an injective function gr : Vα1 tM Vα2 → O such that, gri = gr ◦ πiM for i = 1, 2.\nSuppose that gr1 and gr2 are twoM-adapted groundings of α1 and α2. If Ai is a set of literals of αi, for i = 1, 2, for any set theoretic operation ∗ ∈ {∪,∩, \\} it holds that:\ngr1(A1) ∗ gr2(A2) = gr(π1M(A1)) ∗ gr(π2M(A2)) = gr(A1 ∗M A2) (6)\nThis follows from Proposition 81 and the fact that gr is injective. An iterative use of (6) shows that any set theoretic expression on the two ground actions gri(αi) is in bijection (through gr) with a corresponding expression on the two schemas αi expressed in the common reduced set Vα1 tM Vα2 . As a consequence, any property of ground actions (with the standing assumption ofM-adapted groundings) that can be expressed by set theoretic operations on their literals can be reformulated by rewriting these literals in the new alphabet Vα1 tM Vα2 . This is the key observation in order to lift properties of pairs of actions. To be more concrete, we consider the example of non-interfering actions, which will be needed in what follows.\nDefinition 82 (Mutex simple action schemas). We say that two action schemas α1 and α2 areM non-interfering if for i , j\nE f f +(αi) ∩M E f f −(α j) = ∅ [Pre+(αi) ∪M Pre−(αi)] ∩M [E f f +(α j) ∪M E f f −(α j)] = ∅\nIf α1 and α2 are notM non-interfering, they are calledM-mutex.\nProposition 83. Suppose that α1 and α2 are M-mutex and suppose that gr1 and gr2 are two M-adapted grounding functions for α1 and α2, respectively. Then, the two ground actions ai = gri(αi) are mutex.\nProof. Immediate consequence of (6).\nRemark 84. Note that certain properties that depend on the matchingM have a monotonic behaviour, i.e. if they are true for a matchingM, they remain true for a larger matchingM′ ⊇ M. This is the case, for instance, of properties that can be expressed in terms of identities between literals of type l1 =M l2, such as theM-mutex property.\nTo cope with properties related to a template and its instantiations, it is useful to introduce a family of matchings induced by the presence of literals in the two schemas matching in a template. Precisely, consider now a template T = (C,FC) and two action schemas α1 and α2. Consider T -classes Li of literals of αi for i = 1, 2. There is a natural way to associate a matching to L1 and L2 as follows. Pick literals li ∈ Li for i = 1, 2 and consider components ci ∈ C such that li matches T through ci. Put\nML1,L2 := {(Arg[h, l1],Arg[k, l2]) | (c1, h) ∼FC (c2, k)} (7)\nIt immediately follows from the definition of T -coupled pairs of literals (Definition 58) that ML1,L2 does not depend on the particular literals li chosen, but only on the T -classes Li.\nEssentially, inML1,L2 , we are rewriting arguments in the literals of L1 and L2 that correspond to FC-equivalent variables in the template T . The next proposition shows the role played by such a matching.\nProposition 85. Consider two groundings gr1 and gr2 for α1 and α2, respectively, which are M-adapted. Then the following facts hold:\n(i) given an instance γ for T , if Li are the T -classes of literals of αi on which gri and γ are coherent. Then,ML1,L2 ⊆ M;\n(ii) given T -classes of literals Li of αi, if ML1,L2 ⊆ M, there exists just one instance γ of T such that gri and γ are coherent on Li.\nProof. Immediate consequence of the definition (7) and of Remark 62.\nWe are now ready to lift the properties used in Section 6. We start with unreachability.\nDefinition 86 (Unreachable durative action schemas). Given two durative action schemas Dα1, Dα2 and corresponding T -classes of literals L1 and L2, we say that ({α1inv, α2inv}, {α1end, α2end}) is (L1, L2)-unreachable if, denotedM =ML1,L2 , at least one of the following conditions is satisfied\n(i) Pre+ α1inv ∩M Pre−α2end , ∅;\n(ii) Pre− α1inv ∩M Pre+α2end , ∅;\n(iii) w((Pre+ α1inv L1 ∪ Pre+ α1end L1 ) ∪M (Pre+α2inv L2 ∪ Pre+ α2end L2 )) ≥ 2.\nProposition 87. Suppose that Dα1, Dα2 are two durative action schemas and gr1, gr2 two corresponding grounding functions. Put Dai = gr(Dαi) and consider an instance γ. Let Li be the T -class of literals of Dαi on which gri and γ are coherent. If ({α1inv, α2inv}, {α1end, α2end}) is (L1, L2)-unreachable, then ({a1inv, a2inv}, {a1end, a2end}) is γ-unreachable.\nWe now propose the lifted version of relevant right isolated.\nDefinition 88 (Relevant right isolated schemas). Given a template T , the set of durative action schemas Ad is said to be relevant right isolated if, for every Dα1,Dα2 ∈ Ad, corresponding T -classes L1, L2 of literals of each of them such that DαiLi are both not strongly safe, one of the following conditions is satisfied (we use the notationM =ML1,L2 ):\n(i) |E f f + α1end L1 ∪M E f f +α2end L2 | ≤ 1;\n(ii) at least one of the two pairs {α1end, α2end} or {α1inv, α2inv} isM-mutex;\n(iii) ({α1inv, α2inv}, {α1end, α2end}) is (L1, L2)-unreachable.\nProposition 89. Given a template T , suppose that the set of durative action schemas Ad is relevant right isolated. Then GAd is also relevant right isolated.\nSimilarly, we can lift the property of relevant left isolated expressed in Definition 52 by analogously defining:\nDefinition 90 (Relevant left isolated schemas). Given a template T , the set of durative action schemas Ad is said to be relevant left isolated if, for every Dα1,Dα2 ∈ Ad, corresponding T - classes L1, L2 of literals of each of them such that DαiLi are both not strongly safe, one of the following conditions is satisfied (we use the notationM =ML1,L2 ):\n(i) at least one of the two pairs {α1st, α2st} or {α1inv, α2inv} isM-mutex;\n(ii) ({α1st, α2st}, {α1inv, α2inv}) is (L1, L2)-unreachable.\nSimilarly, it holds:\nProposition 91. Given a template T , suppose that the set of durative action schemas Ad is relevant left isolated. Then GAd is also relevant left isolated.\nThe last property we want to lift is that of strong irrelevant unreachability expressed in Definition 55. This is important since it can be efficiently implemented at the algorithmic level.\nDefinition 92 (Strongly irrelevant unreachable schemas). Consider a template T , a pair of action schemas α1, α2 ∈ A, and corresponding T -classes of literals L1 and L2. We say that the pair (α1, α2) is strongly (L1, L2) -irrelevant unreachable if, denotedM =ML1,L2 , any of the following conditions is satisfied:\n(i) there exist l1 ∈ Γ+ α1 , l2 ∈ Pre− α2 with l1 =M l2 such that, for every action schema α, for every T -class L of literals of α for which αL is irrelevant, and for every matching M̃ between α1 and α for which M̃ ⊇ ML1,L, we have that l1 <M̃ E f f −α ;\n(ii) there exist l1 ∈ Γ− α1 , l2 ∈ Pre+ α2 with l1 =M l2 such that, for every action schema α, for every T -class L of literals of α for which αL is irrelevant, and for every matching M̃ between α1 and α for which M̃ ⊇ ML1,L, we have that l1 <M̃ E f f +α ;\n(iii) w(Pre+ α1 L1 ∪M (Pre+α2 L2 \\M E f f +α1 L1 )) > 1.\nProposition 93. Consider a template T , a pair of action schemas α1, α2 ∈ A and relative groundings gr1 and gr2. Put ai = gr(αi) and consider an instance γ. Let Li be the T -class of literals of αi on which gri and γ are coherent. If (α1, α2) is strongly (L1, L2)-irrelevant unreachable, then (a1, a2) is strongly γ-irrelevant unreachable.\nDenote by Ad(T ) the durative action schemas that are not strongly safe with respect to the template T and withAst(T ),Aend(T ) the corresponding start and ending fragments.\nProposition 94. Consider a template T . The set GAd is relevant non intertwining if the following conditions are satisfied:\n(i) Ad is relevant left isolated;\n(ii) for every Dα1 ∈ Ad and T -class L1, and for every α2 ∈ A and T -class L2 such that α1stL1 ∈ A st(T ), α2L2 < A end(T ) and is not irrelevant or α2L2 ∈ A\nst(T ), we have that (α1st, α2) is strongly (L1, L2)-irrelevant unreachable.\nWe are now ready to propose the lifted versions of our main Theorems 49, 51. Proofs are straightforward consequences of our previous definitions and results.\nCorollary 95. Consider a template T and suppose that the set of instantaneous action schemas Ai and that of durative action schemasAd satisfy the following properties:\n(i) every α ∈ Ai is strongly safe;\n(ii) for every Dα ∈ Ad and every T -class L such that DαL ∈ Ad(T ), Dα∗L is reachable and strongly safe;\n(iii) Ad is relevant right isolated.\nThen, T is invariant.\nCorollary 96. Consider a template T and suppose that the set of instantaneous action schemas Ai and that of durative action schemasAd satisfy the following properties:\n(i) every α ∈ Ai is strongly safe;\n(ii) for every Dα ∈ Ad, Dα∗ is safe;\n(iii) Ad satisfies the conditions expressed in Proposition 94.\nThen, T is invariant.\nFinally, it is useful to consider a lifted version of Corollary 57.\nCorollary 97. Consider a template T and suppose that the set of instantaneous action schemas Ai and that of durative action schemasAd satisfy the following properties:\n(i) for every Dα ∈ Ad and every T -class L, if DαL ∈ Ad(T ), then Dα∗L is simply safe of type (a);\n(ii) for every α ∈ A and every T -class L, if αL < Ast(T )∪Aend(T ), then, αL is either irrelevant or relevant balanced.\nThen, T is invariant. We end this section by presenting two examples from the IPCs in which we apply Corollaries 97 and 95 to demonstrate the invariance of the templates under consideration. Corollary 96 is the most general one and can be used in more complex cases.\nExample 15 (Floortile domain). Consider our usual template:\nT f t = ({〈robot-at, 2, 0〉, 〈painted, 2, 1〉, 〈clear, 1, 1〉}\nThe actions schemas in the domains are:\nAd = {change − color, paint − up, paint − down, up, down, right, left}\nThe schemas paint-up and paint-down are symmetrical and differ only on literals not in the components of T f t. They have the same T -classes L1 = {robot-at(r,x)} and L2 = {clear(y), painted(y,c)}. As seen in Example 14, the pure schemas paint-upst∗L1 and paint-upend∗L1 are irrelevant and paint-up∗L2 is simply safe of type (a). The same holds for paint-down∗L1 and paint-down∗L2 .\nThe schemas up, down, right, left are also symmetrical and differ only on literals not in the components of T f t. They have the same T -classes L3 = {robot-at(r, x), clear(x)} and L4 = {robot-at(r,y), clear(y)}. The schemas up∗Li , down∗Li , right∗Li and left∗Li , with i = 3, 4, are all simply safe of type (a).\nThe schema change-color has no equivalence classes and its start and end fragments are both irrelevant.\nBy Corollary 97, the template template T f t is invariant. Example 16 (Depot domain). Consider the domain Depot (see Appendix B) and the template:\nTdp = ({〈lifting, 2, 1〉, 〈available, 1, 1〉}\nInvariants of this template mean that, given a hoist, it can be in two possibile states: lifting a crate or available. The actions schemas in the domains are all durative:\nAd = {drive, lift, drop, load, unload}\nWe indicate them as Dα1, . . . ,Dα5 respectively and, given Dαi, its arguments as xi, yi, . . .. To demonstrate that Tdp is invariant, we want to apply Corollary 95. We start with condition (ii) sinceAi is empty. The action Dα1 =drive has no literals that match the template so it is strongly safe. The other schemas have respectively T -classes Li = {lifting(xi, yi), available(xi)}. There are only two fragments of the durative actions that are not strongly safe as they are relevant unbounded: α3endL3 and α 4end L4 . However, their auxiliary versions α3end∗L3 and α 4end ∗L4 are strongly safe since they are balanced (when the over all condition lifting(x3, y3) is added to the end effects, it matches the delete effect lifting(x3, y3) and balances the add effect available(x3); similar considerations hold for Dα4). Reachability for α3end∗L3 and α 4end ∗L4 is a straightforward check. In consequence, condition (ii) holds. We now need to verify condition (iii) of Corollary 95, i.e. Ad is relevant right isolated. Under the re-writingML3L4 , we have that x3 = x4 and y3 = y4 and therefore E f f +α3endL3 ∪ML3L4 E f f + α4endL4 = {available(x3) = available(x4)}. Hence condition (i) of Definition 88 is satisfied. We can conclude that Tdp is an invariant template."
    }, {
      "heading" : "9. Guess, Check and Repair Algorithm",
      "text" : "As with related techniques (Gerevini and Schubert, 2000; Rintanen, 2000; Helmert, 2009), our algorithm for finding invariants implements a guess, check and repair approach. It starts by generating a set of initial simple templates. For each template T , it then applies the results stated in the previous sections to check its invariance. If T is invariant, the algorithm outputs it. On the other hand, if the algorithm does not manage to prove the invariance of T , it discards it. Before rejection, however, the algorithm tries to fix the template by generating a set of new templates that are guaranteed not to fail for the same reasons as T . In turn, these new templates need to be checked against the invariance conditions as they might fail due to other reasons.\n9.1. Guessing initial templates\nWhen we create the set of initial templates, we ignore constant relations, i.e. relations whose ground atoms have the same truth value in all the states (for example, type predicates). In fact, they are trivially invariants and so are typically not interesting.\nFor each modifiable relation r with arity a, we generate a + 1 initial templates. They all have one component and zero or one counted argument (which can be in any position from 0 to (a−1)): 〈r, a, a〉 (no counted argument) and 〈r, a, p〉 with p ∈ {0, . . . , (a−1)}. Since the templates have one component, there is only one possible admissible partition FC, with C = {c}. Hence, we construct the template T = (C,FC).\nExample 17 (Floortile domain). Consider the components c1 = 〈robot-at, 2, 1〉. Put FC = {F1} where F1 = {(c1, 0)}. An initial template is T1 = ({c1}, {F1}). Intuitively, invariants of T1 mean that a robot can occupy only one position at any given time and our algorithm validates it as an invariant. Another initial template is built by considering the component c2 = 〈robot-at, 2, 0〉 and the partition FC = {F2} where F2 = {(c2, 1)}. We have another initial template: T2 = ({c2}, {F2}). Invariants of this template mean that a tile cannot be occupied by more than one robot, which is not true in general, and our algorithm correctly discards it. Finally, consider the component c3 = 〈robot-at, 2, 2〉 and the partition FC = {F3} where F3 = {(c3, 0), (c3, 1)}. Another initial template is T3 = ({c3}, {F3}). This is also not an invariant and is rejected.\nIf we repeat this process with every modifiable relation r in the Floortile domain, we obtain the full set of initial templates.\n9.2. Checking conditions for invariance\nGiven a template, we apply the results stated in the previous sections to check its invariance. In particular, we apply our most operative results: Corollary 73 and Corollaries 95 - 97. Remarkably, all these results work at the level of action schemas, not ground actions.\nWe first need to verify if all the instantaneous action schemas A in the domain, both the native ones and those obtained from the fragmentation of durative actions, respect the strong safety conditions. We then check safety conditions that only involve durative action schemas that are not strongly safe. Finally, we validate additional conditions that avoid the intertwinement of potentially dangerous durative actions. Given the different computational complexity of our results (see considerations below), our algorithm checks the applicability of them in the following order: first, Corollary 73, which involves only conditions for instantaneous schemas, then Corollary 97, which considers safety conditions for individual action schemas, and finally Corollaries 95 and\n96, which verify conditions involving pairs of durative action schemas. To implement this procedure, we apply the decision tree shown in Figure 10 to the set of action schemasA. The leaves labelled as Possibly Not Invariant arise when our sufficient results do not apply. In this case, we cannot assert anything about the invariance of the template.\nOur checks involve the analysis of all T -classes in each action schema α in the domain. Since the T -classes form a partition of the set of literals in the schema that match the template, the maximum number of T -classes is equal to the number of such literals. We can estimate this term with the product ω · |C| where ω is the maximum number of literals in any schema that share the same relation and |C| is the cardinality of the template’s component set C. We deduce that all safety checks for individual schemas (both the instantaneous and the durative ones) have a computational complexity of the order of M · |A| · ω · |C|, where M is the maximum number of the literals appearing in any schema and |A| is the total number of schemas. The check of right and left relevant isolated properties involve instead a pair of schemas and T -classes and, in consequence, the computational complexity is of the order of M2 · |A|2 · ω2 · |C|2. The check that two schemas are strongly irrelevant unreachable, as required in Corollary 96, involves considering a third action schema and a family of matchings, M̃. The complexity relating to the check of the matchings can be shown to be reducible to a check of complexity of the order of the maximum number N of arguments in any literal in the domain. Therefore, the total complexity of the check for strongly irrelevant unreachable schemas is of the order N · M3 · |A|3 · ω3 · |C|3. In our experiments, we have found no cases in which this check needs to be applied.\nExample 18 (Floortile domain). The parameters for the computational complexity analysis are as follows:\n|A| = 14, M = 4, ω = 1, |C| = 3,N = 2\n9.3. Repairing templates\nWhen, in analysing an action schema α, we reach a failure node in our decision tree, we discard the template T under consideration since we cannot prove its invariance. This might be because of two reasons: either T is not an invariant or our sufficient conditions are not powerful enough to capture it. Given that we cannot assume that the template is not invariant with certainty, before discarding it, we try to fix it in such a way to obtain new templates for which it might be possible to prove invariance under our conditions. In particular, based on the schema α, we enlarge the set of components of the template by adding suitable literals that appear in the preconditions and negative effects of α since they can be useful to prove that α is simple or strong safety.\nMore precisely, if the algorithm rejects T because it finds an instantaneous schema that is heavy or unbalanced (first step in the decision tree), no fixes are possible for T . Since α leads to a weight greater or equal to two for at least an instance of T , enlarging the set of components of T cannot help in repairing the template. Similarly, if there are durative schemas that are non executable or unreachable, no fixes are possible since these properties cannot be changed by adding components. However, when a failure node is reached in the presence of unbounded schemas, enlarging the set of components might prove useful in making them simply or strongly safe schemas. We operate as follows: for each unbounded schema α, we try to turn it into a balanced action schema and, when α is the end fragment of a durative action Dα, we alternatively attempt to make Dα a simply safe schema, as defined in Definition 77.\nGiven a template T = (C,FC) that has been rejected by the algorithm, put k the number of fixed arguments for T and m the number of its components. Consider an unbounded schema α with relevant literal l. We look for another literal l′ in α with the following characteristics:\n(i) Rel[l′] = 〈r′, a′〉, where a′ = k or a′ = (k + 1);\n(ii) There exists a bijection β from the set of free arguments of l to the set of free arguments of l′ such that Arg[i, l] = Arg[β(i), l′] for every i ∈ I;\n(iii) l′ ∈ Pre+α ∩ E f f −α .\nIf α is the end fragment of a durative action Dα, then condition (iii) can be substituted with one the alternative following conditions:\n(iv) l′ ∈ Pre+ αst∗ ∩ E f f − αst∗\n(iiv) l′ ∈ Pre+ αst∗ ∩ E f f − αend∗\nFor each literal l′ that satisfies conditions (i), (ii) and one between conditions (iii), (iv) and (v), we create a new component c′ = 〈r′, a′, p′〉, where p′ ∈ {0, . . . , a′}, and one new template T ′ = (C′,F ′C), where C′ = C ∪ {c′} and F ′C is an admissible partition of FC′ such that for each c1, c2 ∈ C, we have that (c1, i) ∼FC′ (c2, j) if and only if (c1, i) ∼FC (c2, j) and (c, i) ∼FC′ (c′, j) if and only if Arg[i, l] = Arg[ j, l′] (or, equivalently, j = β(i)).\nIf we find a literal l′ that satisfies condition (iii), the schema α is guaranteed to be balanced for T ′; if the literal l′ satisfies condition (iv), α is guaranteed to be simply safe of type (a) for T ′; finally, if the literal l′ satisfies condition (v), α is guaranteed to be simply safe of type (b) for T ′. Example 19 (Floortile domain). Consider the template T2 = ({c2}, {F2}) as indicated in Example 18 and the action schema α =upend: Preα = ∅, E f f +α = {robot-at(r,y), clear(x)}. The literal robot-at(r,y) matches the T2 and forms a T -class L1 = {robot-at(r,y)}. The pure action schema αL1 is relevant unbounded as well as the end parts of the other schemas that indicate movements. If we apply our decision tree to T2 and the set of actionsA, we cannot prove that T2 is an invariant since the unbounded schemas are not simply safe. Before discarding T2, we try to fix it. In particular, the literal clear(y) satisfies conditions (i), (ii) and (iv) above. If we add it to T2, we obtain a new template T ′2 = ({c2, c′2}, {F′2}) where c′2 = 〈clear, 1, 1〉 with Fc′2 = {(c ′ 2, 0)} and F′2 = {(c2, 1), (c′2, 0)}. If we apply our decision tree to this new template, we can prove that T ′2 is an invariant since Corollary 97 can be successfully applied (all schemas are either strongly sage or simply safe of type (a)). Intuitively, invariants of this template mean that, given a tile, either it is clear or it is occupied by a robot."
    }, {
      "heading" : "10. Experimental Results",
      "text" : "To evaluate the performance of our Temporal Invariant Synthesis, referred as TIS in what follows, we have performed a number of experiments on the IPC benchmarks. We implemented the TIS algorithm, reported in Section 9, in the Python language and conducted the experiments by using a 2.53 GHz Intel Core 2 Duo processor with a memory of 4 GB.\nCurrently, it is difficult to compare our technique for generating lifted temporal invariants to related techniques since they either handle non temporal domains only (STRIPS domains, in particular) (Fox and Long, 1998; Gerevini and Schubert, 2000; Rintanen, 2000, 2008; Helmert, 2009) or find ground temporal invariants (Rintanen, 2014). The approach that appears most similar to ours is the invariant synthesis implemented within the Temporal Fast Downward (TFD) planner (Eyerich et al., 2009). However, there is no formal account of such a technique and its soundness, and our knowledge of it is based on a manual inspection of the code5.\n5TFD-0.4 code available at http://gki.informatik.uni-freiburg.de/tools/tfd/index.html\nThe TFD invariant synthesis is a simple extension of Helmert’s original synthesis devised to deal with temporal and numeric domains. The algorithm analyses the temporal schemas directly, without slitting them into their start, overall and end fragments. As the original technique, only the weight of one is considered safe and only this weight is checked for assessing whether an action schema is safe or not. This implies that bounded action schemas (which are strongly safe) and simply safe schemas of type (c) are always considered unsafe. Only two types of relevant durative schemas are evaluated as safe: (i) those that add and delete relevant literals at start; and (ii) those that check that one relevant literal is true at start, then delete this literal at start and finally add another relevant literal at end. Case (i) corresponds to a balanced schema in our classification. However, the TFD synthesis misses schemas that are balanced at end. Case (ii) corresponds to simply safe schemas of type (a). In all the other cases, the action schemas are labelled as unsafe and the candidate invariant is dismissed.\nThe TFD invariant synthesis seems to have been carefully tailored to meet the particular requirements of the domains of the most recent competitions, the IPC6 in particular, in which almost all the action schemas fall in Cases (i) and (ii) above. In consequence, the TFD synthesis succeeds in finding useful invariants for these domains, but it fails in addressing the more general problem of finding invariants in generic PDDL temporal domains. While for the IPC6 domains the TIS and the TFD synthesis produce similar results, this is not true in general. Their output is different when the domains used offer a broader variety of action schema’s types, as shown in Figure 11. This figure highlights the limited applicability of the TFD synthesis in domains not included in the IPC6. In these domains, almost all the ground atoms end up being translated as state variables with two values (true and false) and the performance of TFD suffers from this trivial encoding6.\nGiven the limited scope of the TFD synthesis, in our experimental results, we propose a comparison between our TIS and another technique, which we call Simple Invariant Synthesis (SIS). We designed and used the SIS in order to analyse the impact on temporal planners’ performance\n6We do not include experiments concerning the performance of TFD as this is outside the scope of our paper.\nof different encodings, which result from synthesising state variables based on different sets of lifted invariants. The SIS is also a simple extension of Helmert’s original technique to temporal domains, but it is general in its applicability and not devised around specific IPC domains. It adopts the simplest strategy to extend the synthesis of invariants from instantaneous to durative actions: it considers safe only changes in weight that happen at the same time point. More in depth, there are two main differences between the TIS and the SIS: i) in the SIS, only a weight equal to one is considered to be legal when a template is checked, whereas in the TIS both zero and one are considered to be legal weights; and ii) in the SIS, all the potential interactions between concurrent action schemas that affect the weight of a template are considered to be problematic and so such schemas are labeled as unsafe. As a consequence of these conservative choices, the SIS algorithm considers safe only irrelevant schemas and schemas that we define as balanced in our classification, and judges unsafe all the other action schemas.\n10.1. Invariants, state variables and quality of the representation\nFigure 12 provides the readers with examples of the invariants that our algorithm finds when applied to IPC domains. Each set in Figure 12 corresponds to a set C of components, which are separated by a comma and indicated with the relation name (arity is omitted here), the positions of the fixed arguments (not enclosed in square brackets) and the position of the counted variable (enclosed in square brackets). For example, {at 0 [1], in 0 [1]} indicates the invariant with the components c1 = 〈at, 2, 1〉 and c2 = 〈in, 2, 1〉. For these domains, the only admissible partition is the trivial one and so it is not indicated. The only exception is the Parkprinter-strips domain and the invariant {hasimage 0 1 [2], notprintedwith 0 1 [2]}, in which we choose an admissible partition that connects together the fixed arguments in position 0 and those in position 1.\nTable 5-Left reports the number of invariants (# INV), number of invariants obtained by applying fixes (# FIX) and run time (RT) for generating invariants for the temporal domains of the IPC-6, IPC-7, and IPC-8 when the TIS algorithm is applied. The first two columns of Table 5-Left also compares the number of invariants found by the TIS to those found by the SIS. This table shows that the computational time to compute invariants is negligible and that there is no significant delay associated with splitting each action schema in its initial and final parts and with checking a broad set of configurations in the schemas’ conditions and effects. While these features of our algorithm do not impact the computational time, they allow us to find a more comprehensive set of invariants than related techniques.\nTables 5-Right and 6 show a comparison between the number of state variables obtained by instantiating invariants for the domains of the IPC-6, IPC-7, and IPC-8 obtained by applying our TIS and the SIS as well as by simply producing a state variable with two truth values (true and false) for each atom in the domain (Basic Invariant Synthesis, BIS). In many domains, the TIS produces a significant reduction in the number of state variables in comparison with the other two techniques. In several cases (see instances of Elevators, Sokoban, Transport , Drivelog, and Parking), the reduction is greater than an order of magnitude. In addition, Tables 5-Right and 6 report the mean (M) of the number of values in the domain of each state variable (when different from 2). In the BIS, the mean is always two as each state variable can only assume two values, true and false, and it is not indicated. In the SIS, the mean is often two with some exceptions, whereas in the TIS several state variables have larger domains with many values (see, for example, Elevators, Transport , Sokoban, Parking and Drivelog).\n10.2. Performance in Temporal Planners\nWe have performed a number of additional experiments in order to evaluate the impact of using the state variables generated by the TIS on the performance of those planners that use a variable/value representation. In particular, we focus here on the performance of two planners: Temporal Fast Downward (TFD) (Eyerich et al., 2009) and POPF-SV, a version of POPF (Coles et al., 2010) that makes use of multi-valued state variables7.\nTFD is a planning system for temporal and numeric problems based on Fast Downward (FD) (Helmert, 2006), which is limited to non temporal and non numeric domains. TFD uses a multivalued variable representation called “Temporal Numeric SAS+” (TN-SAS+), which is a direct extension of the “Finite Domain Representation” (FDR) used within FD to handle tasks with time and numeric fluents. TN-SAS+ captures all the features of PDDL - Level 3 and represents planning tasks by using: i) a set of state variables, which are divided into logical and numeric state variables; ii) a set of axioms, which are used to represent logical dependencies and arithmetic sub-terms; and iii) a set of durative actions, which comprise: a) a duration variable; b) start, persistent and end conditions; and c) start and end effects.\nTFD translates PDDL2.1 tasks into TN-SAS+ tasks first and then performs a heuristic search in the space of time-stamped states by using a context-enhanced additive heuristic (Helmert and Geffner, 2008) extended to handle time and numeric fluents. The translation from PDDL2.1 to TN-SAS+ works in four steps. First, the PDDL instance is normalised, i.e. types are removed and conditions and effects are simplified. Then, an instance where all the literals are ground is produced through a grounding step and the invariant synthesis is applied to generate invariants\n7This version of POPF is not documented, but it has been made available to us by their authors Andrew Coles and Amanda Coles\n(the grounding and the invariant synthesis can be performed in parallel). Starting from the invariants provided by the invariant synthesis and the ground domain, a set of multi-valued state variables is generated. Finally, a set of actions is obtained starting from PDDL actions, which describe how the state variables change over time.\nIn our experiments, we modified TFD by substituting the original invariant synthesis with the three alternative versions: TIS, BIS and SIS. The first is our technique, which we want to evaluate. The BIS is used as a baseline for our experiments. The SIS, as we explained above, is a simple but general alternative to generate invariants8.\nTables 7 display the search time (ST) in seconds for the planner TFD and the domains of the IPC-6, IPC-7 and IPC-8. The three different columns indicate the search time when state variables are obtained by applying the BIS, the SIS and the TIS. For each domain, the planner is run against the following problems: p01, p05, p10, p15, p20, p25 and p30. The dash symbol indicates that a plan is not found in 300 seconds. Problems for which a plan could not be found in 300 seconds by applying all three techniques do not appear in the table.\nThe tables show that in several domains having fewer state variables with larger domains is beneficial to the search. In particular, in domains such as Elevators, Sokoban, Transport ,\n8We do not offer a direct comparison between the original TFD and TFD integrated with our TIS because on IPC6 domains the two versions have comparable performance, while in the other domains TFD does not perform well. For big instances, it often produces no plans with a time bound of 10 minutes. As already mentioned, this behaviour can be linked to the fact that the TFD invariant synthesis works well for IPC6 domains, but it is not general enough to capture invariants in other domains.\nMapanalyser , and TurnAndOpen, the gain is high. If we analyse Table 7 in combination with Tables 5 and 6, we see that there is a strong correlation between the mean of the cardinality of the domains of the state variables and the impact of the state variables on performance. More specifically, state variables whose value domains have mean cardinality greater or equal to three seem to produce the strongest improvements on the search, whereas state variables whose value domains have mean cardinality around two do not yield significant differences in performance. This is not particularly surprising because the use of variables with only two values resolves in producing the same state space as it is obtained without applying any invariant synthesis. On the other hand, variables with three or more values provide an actual reduction in the number of states.\nWe speculate that the number of the state variables and the cardinality of their domains has an impact on the calculation of the heuristic estimates. In particular, let us consider the additive heuristic plus context used within TFD in terms of its corresponding causal graph interpretation Helmert and Geffner (2008). The causal graph heuristic gives an estimate of the number of actions needed to reach the goal from a state s in terms of the estimated costs of changing the value of each state variable that appears in the goal from its value in s to its value in the goal. In order to compute this estimate, the heuristic uses two structures: the domain transition graph, which describes the relations between the different values of a state variable, and the causal graph, which describes the dependencies between the different state variables. Both structures are highly influenced by the number of the state variables and the cardinality of their domains. Fewer state variables with larger domains result in a smaller number of domain transition graphs, each of which has a more complex structure. In addition, a smaller number of state variables gives rise to a much more compact and structured causal graph. We believe that, in a number of cases, these different configurations of the two types of graphs produce more effective heuristic estimates with the consequence of improving performance.\nPOPF-SV is a version of the forwards-chaining temporal planner POPF Coles et al. (2010) that is capable of reading a variable/value representation and making use of it to perform some inference in a pre-processing step and also to reduce the size of states during search. In particular, POPF-SV reads a standard PDDL task along with its corresponding TN-SAS+ translation and reasons with both representations. The multi-valued state variable representation of the task in not used in the heuristic computation, but it is used for two different purposes. An inference step based on the state variables is performed to support temporal preferences. This step extracts rules that are then used during search (for example, is it possible to have action a within 10 time units of action b). The second use of the invariant analysis aims to make the state representation more efficient. Only one proposition from each mutex group needs to be stored within a state since if one is true then the others must necessarily be false. This property results in massive savings in memory. This is particularly beneficial for POPF as memory is generally what causes the planner to fail (rather than time).\nTables 8 display the search time (ST) in seconds for the planner POPF-SV and the domains of the IPC-6 and IPC-7 (we do not show the domains of the IPC-8 as the planner has not been maintained since IPC-7 and so does not perform well on those domains). The three different columns indicate the search time when state variables are obtained by applying the BIS, the SIS and the TIS. For each domain, the planner is run against the following problems: p01, p05, p10, p15, p20, p25 and p30. Problems for which a plan could not be found in 300 seconds do not appear in the table.\nThe tables show that in several domains having fewer state variables with larger domains is beneficial to the search. In particular, in domains such as Elevators, Sokoban, Parking,\nOpenstacks and TurnAndOpen, the gain is significant. If we analyse Table 8 in combination with Tables 5 and 6, we again see that there is a correlation between the number of state variables and the performance of the planner. When the reduction in the number of variables is significant, the planner works significantly better than with the SIS or the BIS. In addition, we observe a correlation between the mean of the cardinality of the domains of the state variables and the impact of the state variables on performance."
    }, {
      "heading" : "11. Related Work",
      "text" : "The invariant synthesis presented in this paper builds on early work described in Bernardini and Smith (2011a). However, the theory behind the invariant synthesis presented here is significantly more comprehensive and the implementation of the technique, in reflecting this extended theory, is capable of finding more invariants and more complex ones. We work here with instantaneous action schemas instead of durative ones and we resort to them only when necessary. From a theoretical point of view, this makes our presentation cleaner and facilitates the exhibition of sound results. From a practical point of view, this makes our algorithm more efficient. The entire classification of action schemas is different from Bernardini and Smith (2011a) and, in consequence of this more sophisticated classification, our new approach can handle complex interactions between schemas that our original simplistic technique cannot. In fact, our original approach works well only in simple domains with balanced schemas, while it fails in more complex domains because the conditions imposed on potentially interfering schemas are too conservative.\nSeveral other approaches to invariant synthesis are available in the literature. In what follows, we present these approaches more in depth by highlighting differences and similarities with our technique.\n11.1. Fast Downward and Temporal Fast Downward\nIn Helmert (2009), Helmert present a translation from a subset of PDDL2.2 into FDR (Finite Domain Representation), a multi-valued planning task formalism used within the planner Fast Downward (Helmert, 2006). In particular, the translation only handles non-temporal and non-numeric PDDL2.2 domains, the so-called “PDDL Level 1” (equivalent to STRIPS (Fikes and Nilsson, 1971) with the extensions known as ADL (Pednault, 1986)). One of the step of this translation is the identification of mutual exclusion invariants and it is an extension of the technique presented in Edelkamp and Helmert (1999) developed for STRIPS.\nWhen considering non-temporal domains, the invariant synthesis presented in this paper works similarly to Helmert’s one. In particular, both work at the lifted level, while all the other related techniques discussed below work at the ground level. Both techniques start from simple invariant candidates, check them against conditions that ensure invariance by analysing the structure of the action schemas in the domain. When a candidate is rejected, they both try to refine it to create a new stronger candidate, which is then checked from scratch.\nHowever, in contrast with our technique, Helmert’s method considers safe only the weight one instead of both the weights of one and zero. This simplified analysis results in the identification of a smaller set of invariants with respect to our technique. For example, Helmert’s invariant synthesis labels as unsafe all the action schemas that add a relevant literal without deleting that literal or another relevant one, even when the preconditions impose that the weight is zero when the action schema is applied. In this way, Helmert’s invariant synthesis misses invariants that our technique is able to find.\nChen et al. (2009) builds on Helmert’s invariant synthesis and his multi-valued domain formulation to synthesise long-distance mutual exclusions (londex), which capture constraints over actions and facts not only at the same time step but also across multiple steps. The londex has been successfully used in SAT-based planners to improve their performance. In future work, we will explore how the concept of londex can be extended to temporal domains.\nWithin the context of Temporal Fast Downward (TFD) (Eyerich et al., 2009), a simple extension of Helmert’s invariant synthesis is used to deal with temporal and numeric domains of the ICPs. See Section 10 for a description of such a technique.\n11.2. Rintanen’s Invariant Synthesis\nAn algorithm for inferring invariants in propositional STRIPS domains is proposed by Rintanen (2000, 2008). It synthesises not only mutual-exclusion invariants, but also other types of invariants. The algorithm works on a ground representation of the domain and, starting from an inductive definition of invariants as formulae that are true in the initial state and are preserved by the application of every action, the algorithm is based on an iterative computation of a fix-point, which is useful for reasoning about all the invariants of a domain at the same time rather than inferring some invariants first and then use them for inferring others.\nRintanen’s algorithm uses a guess, check and repair approach but, unlike our technique, it starts from stronger invariant candidates and then progressively weaken them if they are not preserved by the actions. Thus, the repair phase consists in considering a less general invariant instead of a more general one. For example, let us consider the schema σ = x , y → P(x, y) ∨ Q(y, z) as a potential invariant (all the invariants considered have this implicative form). One of the weakening operation consists of identifying two variables. In this case, if z is set equal to x, the weaker candidate σ = x , y→ P(x, y) ∨ Q(y, x) is obtained and checked.\nThis technique has been successfully used within both Graphplan based planners (Blum and Furst, 1997), where it helps to identify unreachable subgoals, and SAT-based planners (Kautz and Selman, 1999), where it can be useful to reduce the amount of search needed. However, although its implementation is limited to invariants involving two literals at the most, it incurs a high performance penalty on large instances.\nIn Rintanen (2014), Rintanen extends the original algorithm presented in Rintanen (2000, 2008) in order to handle temporal domains. As the original algorithm, the temporal one works on ground domains, not using a lifted representation at any stage. The format of the invariants found is l1V(r) l2, where l1 and l2 are positive or negative ground facts, r is a floating point number, and the formula says that either l1 is true or l2 is true over the interval [0..r] relative to the current time point. If r = in f , the formula means that if l1 is false, then l2 will remain true forever.\nSince Rintanen’s invariant synthesis exploits the initial conditions and the ground representation of the domain, it usually finds a broader range of invariants than our technique. However, this makes the invariant synthesis suffer high computational cost. Reachability analysis on a ground representation of the planning instances is computationally very expensive and, while our algorithm takes a few seconds to run, Rintanen’s synthesis employs tens of minutes to find invariants in several domains (see Table 1 in Rintanen (2014)).\nWe do not directly compare our technique against Rintanen’s algorithm in Section 10 because the two techniques aim to find different types of invariants (our focuses on mutual exclusion invariants, while Rintanen’s tackles a broad range of invariant types) and they work on different representations of the problem (lifted versus ground). However, in what follows, we give examples of the output of Rintanen’s technique for completeness.\nLet us consider the Crewplanning domain (IPC6 and IPC7). For each crew member ci, Rintanen’s algorithm finds ground invariants of the type:\nnot current day − ci − d j V(in f ) not current day − ci − dk\nwhich means that if it is day d j for the crew member ci, it cannot be day dk at the same time. All these invariants correspond to the lifted invariant current day 0 [1] that is found by our invariant synthesis. For the same domain, however, Rintanen’s algorithm finds additional invariants that express temporal relations between atoms. Our technique does not aim to find this type of invariants. For example, Rintanen’s method finds temporal invariants of the form:\ndone sleep − ci − dk V(255) not done mealci − d(k+2)\nwhich means that, for the crew member ci, the atom done meal in day k + 1 becomes true 255 time units after the atom donesleep was true in day k. In fact, in day k, done sleep is made true by the end effects of the action sleep. From this time point, in order to make done meal true the day after k + 1, two actions need to be executed: post sleep, with duration 195, and have meal with duration 60, for a total time separation of 255 time units. For the Crewplanning domain, the run time of our algorithm is 0.29 seconds, while Rintanen’s one has a runtime of 1 minute and 23.24 seconds for hard instances. This is actually one of the best run times, since for problems such as Parcprinter , Elevators, Sokoban, Transport-numeric and other the algorithm has a run time of more than 4 hours. Given these run times, it does not seem plausible to use Rintanen’s algorithm as a pre-processing steps to improve search in planning, which is one of the most important cases of use of invariant synthesis algorithms."
    }, {
      "heading" : "11.3. DISCOPLAN",
      "text" : "DISCOPLAN (DIScovering State COnstraints for PLANning) (Gerevini and Schubert, 1998) is a technique for generating invariants from PDDL Level 1 tasks. DISCOPLAN discovers not only mutual exclusion invariants, but also other types of invariants: static predicates, simple implicative, (strict) single valuedness and n-valuedness, anti-simmetry, OR and XOR invariants.\nConsidering mutual exclusion invariants, DISCOPLAN uses a guess, check and repair approach similar to our approach: an hypothetical invariant is generated by analysing simultaneously the preconditions and the effects of each action to see whether an instantiation of a literal is deleted whenever another instantiation of the same literal is added. Then, this candidate is checked against all the other actions and the initial conditions. If the hypothetical invariant is not found to be valid, then all the unsafe actions are collected together and a set of possible refinements are generated. However, whereas our technique tries to refine a candidate as soon as an unsafe action is found, DISCOPLAN tries to address all the causes of unsafety at the same time while generating refinements. This approach leads to more informed choices on how to refine hypothetical invariants and can result in the identification of more invariants. However, it is more expensive from a computational point of view, which is why DISCOPLAN is often inefficient on big instances.\nDISCOPLAN can be used not only for finding invariants, but also for inferring actionparameter domains. An action-parameter domain is a set including all the objects that can be used to instantiate the parameters of an action. Such sets of possible tuples of arguments are found by forward propagation of ground atoms from the initial state. This technique is related to the reachability analysis performed by Graphplan (Blum and Furst, 1997), but does not implement mutual exclusion calculation.\nDISCOPLAN is usually used in combination with SAT encodings of planning problems. In particular, a pre-processing step is performed over the domain under consideration in order to find invariants and parameter domains, then the domain as well as the invariants and the parameter domains are translated into SAT. Finally, a SAT-based planner is used to solve the\nresulting translated domain. SAT-based planners (Kautz and Selman, 1999; Huang et al., 2010) show significant speed-up when invariants and action-parameter domains are used.\n11.4. Type Inference Module TIM (Type Inference Module) (Fox and Long, 1998) uses a different approach for finding invariants in PDDL Level 1 domains. More precisely, TIM is a pre-preprocessing technique for inferring object types on the basis of the actions and the initial state. Data obtained from this computation are then used for inferring invariants. TIM recognises four kinds of invariants (invariants of type 2 correspond to mutual exclusion invariants):\n1. Identity invariants (for example, considering the domain Blockworld , two objects cannot be at the same place at the same time);\n2. Unique state invariants (for example, every object must be in at most one place at any time point);\n3. State membership invariants (for example, every object must be in at least one place at any time point); and\n4. Resource invariants (for example, in a 3-blocks world, there are 4 surfaces).\nThe invariants found by TIM have been exploited for improving performance within the planner STAN (Fox and Long, 2011).\n11.5. Knowledge representation and engineering In addition to works that address the creation of invariants directly, there are works in the literature that highlight the importance of multi-valued state variables for debugging domain descriptions and for assisting the domain designer in building correctly encoded domains (Fox and Long, 1998; Bernardini and Smith, 2011b; Cushing et al., 2007). In particular, Cushing et al. (2007) analyse well-studied IPC temporal and numeric domains and reveal several modelling errors that affect such domains. This analysis lead the authors to suggest better ways of describing temporal domains. They identify as a central feature to do so the direct specification of multi-valued state variables and show how this can help domain experts to write correct models.\nOther works in the literature use the creation of invariants and state variables as an intermediate step in the translation from PDDL to other languages. In particular, Huang et al. (2010) introduce SASE, a novel SAT encoding scheme based on the SAS+ formalism Helmert (2009). The state variables (extracted from invariants) used by SASE play a key role in achieving its efficiency. Since our technique generates a broader set of invariants than related techniques, it gives rise to SAS+ tasks with smaller sets of state variables. We speculate that this would in turn reverberate positively on SAT-based planners that use a SASE encoding. Testing of this hypothesis is part of our future work."
    }, {
      "heading" : "12. Conclusions and Future Work",
      "text" : "In this paper, we present a technique for automatically finding lifted mutual exclusion invariants in temporal planning domains expressed in PDDL2.1. Our technique builds on Helmert’s invariant synthesis (Helmert, 2009), but generalised it and extends it to temporal domains. Synthesising invariants for temporal tasks is much more complex than for tasks with instantaneous actions only because actions can occur simultaneously or concurrently and interfere with each\nother. For this reason, a simple generalisation of Helmert’s approach does not work in temporal settings. In extending the theory to capture the temporal case, we have had to formulate invariance conditions that take into account the entire structure of the actions as well as the possible interactions between them. As a result, we have constructed a technique that is significantly more comprehensive than the related ones. Our technique is presented here formally and proofs are offered that support its soundness.\nSince our technique, differently from related approaches, works at the lifted level of the representation, it is very efficient. The experimental results show that its run time is negligible, while it allows us to find a wider set of invariants, which in turn results in synthesising a smaller number of state variables to represent a domain. The experiments also indicate that the temporal planners that use state variables to represent the world usually benefit from dealing with a smaller number of state variables.\nOur approach to finding invariants can be incorporated in any translation from PDDL2.1 to a language based on multi-valued state variables. For example, we have used (a simplified version of) the temporal invariant synthesis described in this paper in our translator from PDDL2.1 to NDDL, which is the domain specification language of the planner EUROPA2 (Bernardini and Smith, 2008b). EUROPA2 has been the core planning technology for several NASA space mission operations. It uses a language based on multi-valued state variables that departs from PDDL2.1 in several ways. The use of our translator from PDDL2.1 to NDDL has facilitated the testing of EUROPA2 against domains of the IPCs originally expressed in PDDL2.1 (Bernardini and Smith, 2007, 2008a). This has originally motivated our work on temporal invariant synthesis.\nIn future work, we plan to extend our experimental evaluation by incorporating our invariant synthesis in other planners that use a multi-valued variable representation and that are not currently publicly available. This will allow us to assess more exhaustively the impact that handling fewer state variables with broader domains has on the performance of temporal planners. In addition, we plan to exploit the metric information encoded in planning domains to find a broader range of invariants. Invariants for domains with metric fluents are interesting and challenging. We envisage that there are two kinds of situations to be considered: those in which it can be shown that a linear combination of fluents is invariant (relevant to domains with linear effects on variables) and those in which metric fluents interact with propositional fluents in a more complex structure. For example, one might think of a domain encoding the act of juggling in which the number of balls in the air plus the number in the hands is a constant, but the balls in the hand might be encoded propositionally (for example, by a literal holding left and so on), while those in the air as a count. Finding the invariant in this case is a challenging problem since it crosses the propositional and metric fluent spaces.\nAppendix A: PDDL2.1 Specification of the Floortile Domain\n( d e f i n e ( domain f l o o r − t i l e ) ( : r e q u i r e m e n t s : t y p i n g : d u r a t i v e− a c t i o n s ) ( : t y p e s r o b o t t i l e c o l o r − o b j e c t )\n( : p r e d i c a t e s ( r o b o t− a t ? r − r o b o t ? x − t i l e ) ( up ? x − t i l e ? y − t i l e ) ( down ? x − t i l e ? y − t i l e ) ( r i g h t ? x − t i l e ? y − t i l e ) ( l e f t ? x − t i l e ? y − t i l e ) ( c l e a r ? x − t i l e ) ( p a i n t e d ? x − t i l e ? c − c o l o r ) ( r o b o t−h a s ? r − r o b o t ? c − c o l o r ) ( a v a i l a b l e− c o l o r ? c − c o l o r ) ( f r e e− c o l o r ? r − r o b o t ) )\n( : d u r a t i v e− a c t i o n c h a n g e−c o l o r : p a r a m e t e r s ( ? r − r o b o t ? c − c o l o r ? c2 − c o l o r ) : d u r a t i o n (= ? d u r a t i o n 5 ) : c o n d i t i o n ( and ( a t s t a r t ( r o b o t−h a s ? r ? c ) )\n( ove r a l l ( a v a i l a b l e− c o l o r ? c2 ) ) ) : e f f e c t ( and ( a t s t a r t ( not ( r o b o t−h a s ? r ? c ) ) )\n( a t end ( r o b o t−h a s ? r ? c2 ) ) ) )\n( : d u r a t i v e− a c t i o n p a i n t−u p : p a r a m e t e r s ( ? r − r o b o t ? y − t i l e ? x − t i l e ? c − c o l o r ) : d u r a t i o n (= ? d u r a t i o n 2 ) : c o n d i t i o n ( and ( ove r a l l ( r o b o t−h a s ? r ? c ) )\n( a t s t a r t ( r o b o t− a t ? r ? x ) ) ( ove r a l l ( up ? y ? x ) ) ( a t s t a r t ( c l e a r ? y ) ) )\n: e f f e c t ( and ( a t s t a r t ( not ( c l e a r ? y ) ) ) ( a t end ( p a i n t e d ? y ? c ) ) ) )\n( : d u r a t i v e− a c t i o n paint−down : p a r a m e t e r s ( ? r − r o b o t ? y − t i l e ? x − t i l e ? c − c o l o r ) : d u r a t i o n (= ? d u r a t i o n 2 ) : c o n d i t i o n ( and ( ove r a l l ( r o b o t−h a s ? r ? c ) )\n( a t s t a r t ( r o b o t− a t ? r ? x ) ) ( ove r a l l ( down ? y ? x ) ) ( a t s t a r t ( c l e a r ? y ) ) )\n: e f f e c t ( and ( a t s t a r t ( not ( c l e a r ? y ) ) ) ( a t end ( p a i n t e d ? y ? c ) ) ) )\n( : d u r a t i v e− a c t i o n up : p a r a m e t e r s ( ? r − r o b o t ? x − t i l e ? y − t i l e ) : d u r a t i o n (= ? d u r a t i o n 3 ) : c o n d i t i o n ( and ( a t s t a r t ( r o b o t− a t ? r ? x ) )\n( ove r a l l ( up ? y ? x ) ) ( a t s t a r t ( c l e a r ? y ) ) )\n: e f f e c t ( and ( a t s t a r t ( not ( r o b o t− a t ? r ? x ) ) ) ( a t end ( r o b o t− a t ? r ? y ) ) ( a t s t a r t ( not ( c l e a r ? y ) ) ) ( a t end ( c l e a r ? x ) ) ) )\n( : d u r a t i v e− a c t i o n down : p a r a m e t e r s ( ? r − r o b o t ? x − t i l e ? y − t i l e ) : d u r a t i o n (= ? d u r a t i o n 1 ) : c o n d i t i o n ( and ( a t s t a r t ( r o b o t− a t ? r ? x ) )\n( ove r a l l ( down ? y ? x ) ) ( a t s t a r t ( c l e a r ? y ) ) )\n: e f f e c t ( and ( a t s t a r t ( not ( r o b o t− a t ? r ? x ) ) ) ( a t end ( r o b o t− a t ? r ? y ) ) ( a t s t a r t ( not ( c l e a r ? y ) ) ) ( a t end ( c l e a r ? x ) ) ) )\n( : d u r a t i v e− a c t i o n r i g h t : p a r a m e t e r s ( ? r − r o b o t ? x − t i l e ? y − t i l e ) : d u r a t i o n (= ? d u r a t i o n 1 ) : c o n d i t i o n ( and ( a t s t a r t ( r o b o t− a t ? r ? x ) )\n( ove r a l l ( r i g h t ? y ? x ) ) ( a t s t a r t ( c l e a r ? y ) ) )\n: e f f e c t ( and ( a t s t a r t ( not ( r o b o t− a t ? r ? x ) ) ) ( a t end ( r o b o t− a t ? r ? y ) ) ( a t s t a r t ( not ( c l e a r ? y ) ) ) ( a t end ( c l e a r ? x ) ) ) )\n( : d u r a t i v e− a c t i o n l e f t : p a r a m e t e r s ( ? r − r o b o t ? x − t i l e ? y − t i l e ) : d u r a t i o n (= ? d u r a t i o n 1 ) : c o n d i t i o n ( and ( a t s t a r t ( r o b o t− a t ? r ? x ) )\n( ove r a l l ( l e f t ? y ? x ) ) ( a t s t a r t ( c l e a r ? y ) ) )\n: e f f e c t ( and ( a t s t a r t ( not ( r o b o t− a t ? r ? x ) ) ) ( a t end ( r o b o t− a t ? r ? y ) ) ( a t s t a r t ( not ( c l e a r ? y ) ) ) ( a t end ( c l e a r ? x ) ) ) )\n)\nAppendix B: PDDL2.1 Specification of the Depot Domain\n( d e f i n e ( domain Depot ) ( : r e q u i r e m e n t s : t y p i n g : d u r a t i v e− a c t i o n s ) ( : t y p e s p l a c e l o c a t a b l e − o b j e c t\nd e p o t d i s t r i b u t o r − p l a c e t r u c k h o i s t s u r f a c e − l o c a t a b l e p a l l e t c r a t e − s u r f a c e )\n( : p r e d i c a t e s ( a t ? x − l o c a t a b l e ? y − p l a c e ) ( on ? x − c r a t e ? y − s u r f a c e ) ( i n ? x − c r a t e ? y − t r u c k ) ( l i f t i n g ? x − h o i s t ? y − c r a t e ) ( a v a i l a b l e ? x − h o i s t ) ( c l e a r ? x − s u r f a c e ) )\n( : d u r a t i v e− a c t i o n Dr ive : p a r a m e t e r s ( ? x − t r u c k ? y − p l a c e ? z − p l a c e ) : d u r a t i o n (= ? d u r a t i o n 10) : c o n d i t i o n ( and ( a t s t a r t ( a t ? x ? y ) ) ) : e f f e c t ( and ( a t s t a r t ( not ( a t ? x ? y ) ) ) ( a t end ( a t ? x ? z ) ) ) )\n( : d u r a t i v e− a c t i o n L i f t : p a r a m e t e r s ( ? x − h o i s t ? y − c r a t e ? z − s u r f a c e ? p − p l a c e ) : d u r a t i o n (= ? d u r a t i o n 1 ) : c o n d i t i o n ( and ( ove r a l l ( a t ? x ? p ) ) ( a t s t a r t ( a v a i l a b l e ? x ) )\n( a t s t a r t ( a t ? y ? p ) ) ( a t s t a r t ( on ? y ? z ) ) ( a t s t a r t ( c l e a r ? y ) ) )\n: e f f e c t ( and ( a t s t a r t ( not ( a t ? y ? p ) ) ) ( a t s t a r t ( l i f t i n g ? x ? y ) ) ( a t s t a r t ( not ( c l e a r ? y ) ) ) ( a t s t a r t ( not ( a v a i l a b l e ? x ) ) ) ( a t s t a r t ( c l e a r ? z ) ) ( a t s t a r t ( not ( on ? y ? z ) ) ) ) )\n( : d u r a t i v e− a c t i o n Drop : p a r a m e t e r s ( ? x − h o i s t ? y − c r a t e ? z − s u r f a c e ? p − p l a c e ) : d u r a t i o n (= ? d u r a t i o n 1 ) : c o n d i t i o n ( and ( ove r a l l ( a t ? x ? p ) ) ( ove r a l l ( a t ? z ? p ) ) ( ove r a l l ( c l e a r ? z ) ) ( ove r a l l ( l i f t i n g ? x ? y ) ) ) : e f f e c t ( and ( a t end ( a v a i l a b l e ? x ) ) ( a t end ( not ( l i f t i n g ? x ? y ) ) )\n( a t end ( a t ? y ? p ) ) ( a t end ( not ( c l e a r ? z ) ) ) ( a t end ( c l e a r ? y ) ) ( a t end ( on ? y ? z ) ) ) )\n( : d u r a t i v e− a c t i o n Load : p a r a m e t e r s ( ? x − h o i s t ? y − c r a t e ? z − t r u c k ? p − p l a c e ) : d u r a t i o n (= ? d u r a t i o n 3 ) : c o n d i t i o n ( and ( ove r a l l ( a t ? x ? p ) ) ( ove r a l l ( a t ? z ? p ) ) ( ove r a l l ( l i f t i n g ? x ? y ) ) ) : e f f e c t ( and ( a t end ( not ( l i f t i n g ? x ? y ) ) ) ( a t end ( i n ? y ? z ) )\n( a t end ( a v a i l a b l e ? x ) ) ) )\n( : d u r a t i v e− a c t i o n Unload : p a r a m e t e r s ( ? x − h o i s t ? y − c r a t e ? z − t r u c k ? p − p l a c e ) : d u r a t i o n (= ? d u r a t i o n 4 ) : c o n d i t i o n ( and ( ove r a l l ( a t ? x ? p ) ) ( ove r a l l ( a t ? z ? p ) ) ( a t s t a r t ( a v a i l a b l e ? x ) ) ( a t s t a r t ( i n ? y ? z ) ) ) : e f f e c t ( and ( a t s t a r t ( not ( i n ? y ? z ) ) ) ( a t s t a r t ( not ( a v a i l a b l e ? x ) ) )\n( a t s t a r t ( l i f t i n g ? x ? y ) ) ) )\n)"
    }, {
      "heading" : "Appendix C: Proofs",
      "text" : "Proof of Proposition 1. The action a1 is applicable in s0 by definition. Assuming that a j is applicable in s j−1 for j = 1, . . . , k, we now show that ak+1 is applicable in sk. Note that from\nthe definition of transition function ξ for single actions sk = (s \\ k⋃\nj=1 E f f −a j ) ∪ k⋃ j=1 E f f +a j . Since\nPre+ak+1 ⊆ s and Pre−ak+1 ∩ s = ∅ by assumption and ak+1 is not interfering with a1, a2, . . . , ak, we have that Pre+ak+1 ⊆ sk and Pre−ak+1∩ sk = ∅. In addition, note that: sn = (s\\ n⋃ j=1 E f f −a j )∪ n⋃ j=1 E f f +a j = ξ(s, A).\nProof of Proposition 16. (ii)⇒(iii) is trivial and (iii)⇒(i) is an immediate consequence of (1) and of the fact that w(T , γ, s) = w(T , γ, sγ) and w(T , γ, s′) = w(T , γ, s′γ).\nFinally, (i)⇒(ii) follows from the following argument. Given any s ∈ SAγ such that w(T , γ, s) ≤ 1, consider s∗ := sγ ∪ Pre+A¬γ . Since s ∗ γ = sγ ∈ SAγ and s∗¬γ = Pre+A¬γ ∈ SA¬γ , it follows that\ns∗ ∈ SA. If we consider the successor states s′ = ξ(s, Aγ) and s′∗ = ξ(s∗, Aγ), it follows from (1) that\ns′γ = ξ(sγ, Aγ) = ξ(s ∗ γ, Aγ) = s ′∗ γ\nTherefore, w(T , γ, s′) = w(T , γ, s′γ) = w(T , γ, s′∗γ ) = w(T , γ, s′∗) ≤ 1\nwhere the last equality follows from the assumption that A is strongly γ-safe.\nProof of Theorem 18. If A is γ-unreachable and A is applicable in the state s, It follows that Pre+A ⊆ s and thus w(T , γ, s) ≥ |Pre+Aγ )| ≥ 2. This shows that the condition w(T , γ, s) ≤ 1 is never verified and thus A is strongly γ-safe.\nIf A is γ-irrelevant and A is applicable in the state s, we have that the successor state s′ = ξ(s, a) ⊆ s. This yields w(T , γ, s′) ≤ w(T , γ, s). This implies that A is strongly γ-safe.\nSuppose A is γ-heavy and consider the state s = Pre+A. A is applicable in s and w(T , γ, s) = |Pre+Aγ | ≤ 1. After applying A in s, the successor state s\n′ = ξ(s, A) is such that s′ ⊇ E f f +Aγ This yields w(T , γ, s′) ≥ |E f f +α | ≥ 2 and proves that A is not strongly γ-safe.\nProof of Theorem 20. We will prove the corresponding property for Aγ making use of Condition (iii) of Proposition 16.\nWe first analyse the case when A is balanced or unbalanced. Let Pre+Aγ = {q1} and E f f + Aγ = {q2}. Suppose now that A is balanced and fix a state s ∈ γ(T ) such that w(T , γ, s) ≤ 1 and Aγ is applicable in s. Clearly, q1 ⊆ s so, necessarily, s = {q1} and w(T , γ, s) = 1. Consider the subsequent state s′ = ξ(s, Aγ). If q1 = q2, we have that s′ = s so that w(T , γ, s′) = 1. If instead q1 ∈ E f f −Aγ , we have that s\n′ ⊆ (s ∪ {q2}) \\ {q1} = {q2} and thus w(T , γ, s′) = 1. Suppose that A is unbalanced and consider the state s = {q1}. The subsequent state s′ = ξ(s, Aγ) = {q1, q2} so that w(T , γ, s′) = 2. We now consider the remaining two cases. Let E f f +Aγ = {q2}. Suppose now that A is bounded and fix a state s ∈ γ(T ) such that w(T , γ, s) ≤ 1 and Aγ is applicable in s. Since A is γ-relevant, the subsequent state s′ = ξ(s, Aγ) is such that w(T , γ, s′) ≤ w(T , γ, s) + 1. The only case we need to consider is thus when w(T , γ, s) = 1. Suppose that s = {q1}. Since, by assumption PreAγ ∪ E f fAγ = T (γ), it follows that q1 ∈ PreAγ ∪ E f fAγ . Clearly q1 < Pre−Aγ (otherwise Aγ would not be applicable on the state s). Therefore, necessarily, either q1 ∈ E f f +Aγ or q1 ∈ E f f − Aγ\n. In the first case, we have that q1 = q2 and thus s′ = s = {q1}. In the second case, s′ = {q2}. In both cases, w(T , γ, s′) = 1.\nFinally, if A is unbounded, we consider any ground atom q1 ∈ γ(T ) \\ (PreAγ ∪E f fAγ ) and we put s = {q1}. Clearly Aγ is applicable in q1 since Pre+Aγ = ∅ and q1 < Pre − Aγ\n, and w(T , γ, s) = 1. Since it also holds that q1 < E f f −Aγ , we have that the subsequent state s\n′ = ξ(s, Aγ) = {q1, q2} and w(T , γ, s′) = 2.\nProof of Proposition 22. Write A = {a1, . . . , an} and let s be state such that A is applicable in s. Note that from Proposition 1, the actions in A can be serialised and the successor state s′ = ξ(s, A) can be recursively obtained as s0 = s, sk = ξ(sk−1, ak), k = 2, . . . , n and s′ = sn. By the assumption, it follows that w(T , γ, si) ≤ 1 for every i. In particular, w(T , γ, s′) ≤ 1.\nProof of Proposition 26. Given any instance γ and any valid induced simple plan π having trace(π) = {S i = (ti, si)i=0,...,k̄} with happening sequence Aπ, we have that the state sequence (s0, . . . , sk̄) ∈ SAπ . Therefore, since w(T , γ, s0) ≤ 1 (recall that s0 = Init and w(T , γ, Init) ≤ 1 for every γ), the\nindividual γ-safety of Aπ implies that w(T , γ, s j) ≤ 1 for every j = 1, . . . , k̄. Since this holds for every γ and every valid plan, invariance of T follows.\nProof of Proposition 27. (i): If (s0, s1, . . . , sn) ∈ SA, we have that\n(s0, s1, . . . , sk) ∈ SAk1 , (s h−1, s1, . . . , sn) ∈ SAnh .\nTherefore, if w(T , γ, s0) ≤ 1, from the fact that Ak1 is individually γ-safe, it follows that w(T , γ, s j) ≤ 1 for every j = 1, . . . , k. In particular, being k ≥ h − 1, we have that w(T , γ, sh−1) ≤ 1. From the fact that Anh is also individually γ-safe, it now follows that w(T , γ, s j) ≤ 1 for every j = h, . . . , n. This implies that w(T , γ, s j) ≤ 1 for every j = 1, . . . , n and proves the thesis.\n(ii): Suppose (s0, s1, . . . , sk−1, sk+1, . . . , sn) ∈ SA′ where sk+1 = ξ(Ak ∪ Ak+1, sk−1). Put sk = ξ(Ak, sk−1) and note that, by serialisability (see Proposition 1), sk+1 = ξ(Ak+1, sk), and therefore (s0, s1, . . . , sk−1, sk, sk+1, . . . , sn) ∈ SA. This implies that w(T , γ, s j) ≤ 1 for every j = 1, . . . , n and proves the thesis.\n(iii): If (s0, s′0, s1, . . . , s′n−1, sn) ∈ SA′ , then, s′k−1 = sk for every k = 1, . . . , n and (s0, s1, . . . , sn) ∈ SA. Individual γ-safety of A now yields the thesis. Regarding A′′ thesis follows from the fact that A′ is individually γ-safe and previous item (ii).\nProof of Proposition 31. (i)⇒(ii): Note that if (s0, s1, s2) ∈ SA, it follows that Pre+A1 ⊆ s 0. Since s1 = (s0 \\E f f −A1 )∪E f f + A1 it follows that Γ + A1 ⊆ s 1. Analogously, using the fact that (Pre−A1 ) c ⊇ s0, it follows that (Γ−A1 ) ⊇ s 1. Since A2 must be applicable on s1 conditions (ii) immediately follow.\n(ii)⇒(i): Consider s0 = Pre+A1 ∪ (Pre + A2 \\ E f f + A1 ). Straightforward set theoretic computation, using conditions (ii), show that A1 can be applied on s0 and that A2 can be applied on s1 = ξ(A1, s0). This proves (i).\nProof of Proposition 32. (ii)⇒(i): It follows from the proof of (ii)⇒(i) in Proposition 31 that there exists (s0, s1, s2) ∈ SA with s0 = Pre+A1 ∪ (Pre + A2 \\ E f f + A1 ). By the assumption made w(T , γ, s0) ≤ 1 and this proves (i). (i)⇒(ii): it follows from the fact that if (s0, s1, s2) ∈ SA, necessarily Pre+A1∪(Pre + A2 \\E f f + A1 ) ⊆ s0.\nProof of Proposition 33. (i): If (s0, s1, . . . , sn−1, sn) ∈ SA, we have that (s0, s1, . . . , sn−1, s′n) ∈ SA′ for a suitable state s′n. Result then follows from the definition of executability and γreachability.\n(ii): This follows immediately from serialisability (see Proposition 1).\nProof of Proposition 37. Let (s0, . . . , sn) ∈ SA(γ) and suppose that A j is either γ-heavy or γrelevant unbalanced. Then, necessarily, w(T , γ, s j) ≥ 2.\nProof of Proposition 38. 1.: It follows from (1) that, given any sequence of states (s0, . . . , sn) ∈ Sn+1, we have that\n(s0, . . . , sn) ∈ SA ⇔ { (s0γ, . . . , s n γ) ∈ SAγ\n(s0¬γ, . . . , s n ¬γ) ∈ SA¬γ\n(8)\nThis immediately proves the ’only if’ implication. On the other hand, if s′ ∈ SAγ and s′′ ∈ SA¬γ , we have that s′γ ∈ SAγ and s′′¬γ ∈ SA¬γ and thus s = s′γ ∪ s′′¬γ ∈ SA by (8).\n2. can be proven analogously to 1. and 3. follows by a straightforward extension of the arguments used to prove Proposition 16. Finally, 4. follows from the definition of strong γsafety and previous items 1. and 2..\nProof of Theorem 39. Consider the sequences restricted on the instantiation γ(T ) and its complement: Aγ, A¬γ and, respectively, Ãγ, Ã¬γ. By virtue of Proposition 38, we have that Aγ is γ-safe and to prove the result it is sufficient to show that Ãγ is either non executable or γ-safe.\nAssume that Ãγ is executable and let (s0, s1, s2, . . . , sn+1, sn+2) ∈ SÃγ be such that w(T , γ, s0) ≤ 1. Since (s0, s1) ∈ SA1γ and A 1 γ is strongly safe, it follows that w(T , γ, s1) ≤ 1. Note now that s j = s j−1 \\ E f f − B j−1γ for j = 2, . . . , n + 1 and this immediately implies that\nw(T , γ, sn+1) ≤ w(T , γ, sn) ≤ · · · ≤ w(T , γ, s1) ≤ 1\nWhat remains to be shown is that also w(T , γ, sn+2) ≤ 1. To this aim, we introduce the following sets:\nΩ′ = (∪ni=1E f f −Biγ ) ∩ Pre − A2γ , Ω′′ = (∪ni=1E f f −Biγ ) \\ Pre − A2γ\nNote that since A is executable, we have that Pre− A2γ ∩E f f +A1 = ∅. Consequently, also Ω ′∩E f f + A1γ = ∅. Therefore, (s0 \\ Ω′, s1 \\ Ω′) ∈ SA1γ . On the other hand, we also have that A 2 γ is applicable on the state sn+1 ∪ Ω′′. This implies that there exists s̃ ∈ S such that (sn+1 ∪ Ω′′, s̃) ∈ SA2γ . Note that w(T , γ, s̃) ≥ w(T , γ, sn+2) Since sn+1 ∪ Ω′′ = (s1 \\ ∪ni=1E f f −Biγ ) ∪ Ω\n′′ = s1 \\ Ω′, we deduce that (s0 \\ Ω′, s1 \\ Ω′, s̃) ∈ SAγ . Since w(T , γ, s0 \\ Ω′) ≤ w(T , γ, s0) ≤ 1, the fact that Aγ is γ-safe implies that w(T , γ, s̃) ≤ 1. This also implies that w(T , γ, sn+2) ≤ 1 and the proof is complete.\nProof of Proposition 42. (i): Suppose (s0, s1, s2) ∈ S(ast ,ainv). Since ainv only contains preconditions, we have that s1 = s2. Note now that s1 = ξ(ast, s0) = (s0 ∪ E f f +ast ) \\ E f f −ast must satisfy the conditions Pre+ainv ⊆ s 1 ⊆ (Pre−ainv ) c. This yields Pre+ainv ⊆ s 0∪E f f +ast ) and thus Pre+ainv\\E f f + ast ⊆ s0. Similarly, from s0 \\ E f f −ast ⊆ (Pre−ainv ) c, we obtain that s0 ⊆ (Pre−ainv \\ E f f − ast )\nc. This implies that also ast∗ is applicable on s 0 and s1 = ξ(ast∗ , s 0) since ast and ast∗ have the same effects. If instead (s0, s1) ∈ Sast∗ , we have that ast is applicable on s0 (since the preconditions of ast are also preconditions of ast∗ ) and s 1 = ξ(ast∗ , s 0) = ξ(ast, s0). (ii) is proven similarly to (i). (iii) follows from (i) and (ii) and, finally, (iv), (v), and (vi) follow, respectively, from (i), (ii), and (iii).\nProof of Proposition 43. Since A∗ differs from A only for having more preconditions, it holds that SA ⊇ SA∗ . Conversely, suppose (s0, . . . , sn) ∈ SA. Then, (s0, s1, s1) ∈ S(ast ,ainv). Therefore, by (i) of Proposition 42, we have that (s0, s1) ∈ Sast∗ . Similarly, using (ii) of Proposition 42, we obtain that (sn−1, sn) ∈ Saend∗ . These two facts together with (s\n1, s2, . . . , sn−1) ∈ S(A2,...,An−1), yield (s0, . . . , sn) ∈ SA∗ .\nProof of Proposition 44. Note that Da∗, being γ-reachable and ast∗ strongly γ-safe, is simply γsafe if and only if Da∗γ is individually γ-safe. This last fact is equivalent to show that, given any state sequence (s0, s1, s2) ∈ SDa∗γ such that s0 ∈ γ(T ) and w(T , γ, s0) ≤ 1, it holds that w(T , γ, si) ≤ 1 for i = 2 (since for i = 1 follows from the strong safety of ast∗ ). Put\nWγ := {s1 ∈ γ(T ) | ∃s0, s2 ∈ γ(T ), w(T , γ, s0) ≤ 1, (s0, s1, s2) ∈ SDa∗γ }\nWe need to show that, for every s1 ∈ Wγ, we have that w(T , γ, s2) ≤ 1, where\ns2 = ξ(aend∗γ , s 1) = s1 ∪ E f f +aend∗γ \\ E f f − aend∗γ\nSince aend∗ is γ-relevant unbounded, the condition w(T , γ, s2) ≤ 1 is clearly equivalent to s1 ⊆ E f f +aend∗γ ∪ E f f − aend∗γ\n(9)\nSince ast∗ is γ-reachable and strongly γ-safe, it follows from Theorem 18 that is either γirrelevant or γ-relevant. If ast∗ is γ-irrelevant and |Pre+ast∗γ | = 1, we have thatWγ = {Pre + ast∗γ \\E f f −ast∗γ }. Combining with (9), we thus have that in this case Da∗ is γ-safe if and only if\nPre+ast∗γ \\ E f f + ast∗γ ⊆ E f f +aend∗γ ∪ E f f − aend∗γ\n(10)\nThis leads to the two possible cases (a) and (b). Suppose now that ast∗ is γ-irrelevant and |Pre+ast∗γ | = 0. In this case,\nWγ = {s1 ⊆ γ(T ) |w(T , γ, s1) ≤ 1, s1 ∩ (Pre−ast∗γ ∪ E f f − ast∗γ ) = ∅}\nCombining with (9), we thus have that in this case Da∗ is γ-safe if and only if\nPre−ast∗γ ∪ E f f − ast∗γ ∪ E f f +aend∗γ ∪ E f f − aend∗γ = γ(T ) (11)\nThis leads to case (c). Finally, if αst∗γ is relevant we have thatWγ = {E f f +ast∗γ }. Combining again with (9), we obtain that in this case Da∗ is γ-safe if and only if condition (d) is verified.\nProof of Proposition 47. Since Da is γ-reachable, it follows from Proposition 37, that ast must necessarily be γ-relevant unbounded. In particular, this yields Pre+astγ = ∅. Therefore, Pre + ast∗γ = Pre+ ainvγ \\ E f f +astγ cannot have any intersection with E f fastγ . This says that a st ∗ cannot be γ-relevant balanced. Since it can neither be γ-unreachable (since Da is γ-reachable), it follows from Corollary 21 that ast∗ must be γ-relevant bounded. This proves (i).\nSuppose now that the sequence ({ast} ∪ A1, ainv) is executable and let q ∈ E f f + A1γ . By (i), it follows that q ∈ E f f +astγ ∪E f f − astγ ∪Pre−ast∗γ . Note that q cannot either belong to E f f − astγ or Pre−astγ since ast and the actions in A1 must be non-interfering. On the other hand, q cannot belong to Pre− ainvγ otherwise the sequence would not be executable. Therefore the only possibility is that q ∈ E f f +astγ . Therefore we have that E f f +\nA1γ ⊆ E f f +astγ . Consider now Ã 1 the action set obtained from A1 by\neliminating all positive effects belonging to γ(T ). Clearly, {ast} ∪ A1 = {ast} ∪ Ã1. Consider now the sequence (Ã1, ast, ainv) and note that Ã1 is γ-irrelevant, and (ast, ainv) is γ-individually safe because of (iv) of Proposition 42. Therefore, by Proposition 27, also (Ã1, ast, ainv) is individually γ-safe, and thus also ({ast} ∪ A1, ainv).\nProof of Theorem 49. Fix any valid simple plan π with happening sequence Aπ = (At0 , . . . , Atk̄ ) and any instance γ. We prove that Aπ is individually γ-safe.\nWe split happenings as follows: Ati = A st ti ∪ A s ti ∪ A end ti where\n• Astti is either empty or consists in the start fragments of durative actions in GA d(γ);\n• Aendti is either empty or consists in the ending fragments of durative actions in GA d(γ);\n• Asti = At \\ (A st ti ∪ A end ti ) consists of strongly γ-safe actions (either instantaneous or possibly\nthe starting and ending of durative ones in GAd \\ GAd(γ)).\nNote that if Astti , ∅, it either consists of all strongly γ-safe actions and is thus strongly γ-safe, or there exists a durative action Da ∈ GAd(γ) such that ast is not strongly safe and ast ∈ Astti . Note that Ati+1 simply consists of {ainv} possibly together with other overall fragments of durative actions. Consequently, since (Astti , Ati+1 ) is executable, it is also executable (A st ti , a\ninv) (see (i) of Proposition 33). By hypothesis, Da is γ-reachable and ast∗ is strongly γ-safe, we can thus apply Proposition 47 and conclude that (Astti , a\ninv) is individually γ-safe. Using (iii) of Proposition 27, we obtain that (Astti , Ati+1 ) is individually γ-safe. Therefore, in any case, if A st ti , ∅, (A st ti , Ati+1 ) is individually γ-safe. Similarly, if Aendti , ∅, it either consists of all strongly γ-safe actions and is thus strongly γsafe, or there exists a durative action Da ∈ GAd(γ) such that aend is not strongly safe and aend ∈ Aendti . Suppose that it exists another durative action Da\n′ ∈ GAd(γ) such that a′end ∈ Aendti and {aend, a′end} is γ-heavy. Then, since GAd is right relevant isolated and the two pairs {ainv, a′inv}, {aend, a′end} are both non-interfering, the sequence ({ainv, a′inv}, {aend, a′end}) is γ-unreachable. Since Ati−1 only consists of actions with no effects, it then follows from Proposition 33 that also the sequence (Ati−1 , A end ti ) is γ-unreachable. The other possibility is that E f f +\nAendtγ = E f f + aendγ . Con-\nsider in this case Ãendti to be the action set obtained from A end ti \\ {a end} by eliminating all positive effects belonging to γ(T ). Clearly, Aendti = {a end} ∪ Ãendti . Note now that (a inv, aend) is individually γ-safe by (v) of Proposition 42. Considering that Ati−1 \\ {ainv} only contains preconditions and Ãendti is strongly γ-safe, a repeated application of the different items of Proposition 27 implies that (Ati−1 , A end ti ) is individually γ-safe.\nNote that, given each happening time ti, there are four possibilities:\n• Astti = ∅, A end ti = ∅: in this case Ati = A s ti is strongly γ-safe by definition;\n• Astti , ∅, A end ti = ∅: in this case, since A s ti and (A st ti , Ati+1 ) are individually γ-safe, using (i) and\n(ii) of Proposition 27, we obtain that also (Asti , A st ti , Ati+1 ) and (Ati , Ati+1 ) = (A s ti ∪ A st ti , Ati+1 ) are individually γ-safe.\n• Astti = ∅, A end ti , ∅: arguing analogously to the case above we obtain that (Ati−1 , Ati ) is\nindividually γ-safe.\n• Astti , ∅, A end ti , ∅: arguing analogously to the case above we obtain that (Ati−1 , Ati , Ati+1 ) is\nindividually γ-safe.\nUsing Corollary 28 we obtain that Aπ is individually γ-safe.\nProof of Theorem 51 . Fix any valid (possibly induced) simple plan π with happening sequence Aπ = (At0 , . . . , Atk̄ ) and any instance γ. We prove that Aπ is individually γ-safe.\nSuppose that we can prove that if Da ∈ GAd(γ) appears in π on the time window [th, tk] (namely, ast ∈ Ath and aend ∈ Atk ), the corresponding action sequence A = (Ath , . . . , Atk ) satisfies the following conditions:\n(a) for every i ∈ (h, k), Ati consists exclusively of γ-irrelevant actions;\n(b) for every i ∈ [h, k), Ati does not contain actions in GAst(γ).\nNote that if (b) holds true for every Da ∈ GAd(γ), we also have automatically that,\n(c) for every i ∈ (h, k], Ati does not contain actions in GAend(γ).\nAssuming this to hold, we now proceed as in the proof of Theorem 49 and we split each happening Ati in the following way. We put Ati = A st ti ∪ A s ti ∪ A end ti where:\n• Astti is either empty or consists in a start fragment in GA st(γ);\n• Aendti is either empty or consists in an ending fragment in GA end(γ);\n• Asti = At \\ (A st ti ∪ A end ti ).\nWe now consider the new plan π̃ given by\nπ̃ = {(t, a) ∈ π | a ∈ Ast } ∪ {(t − , a) ∈ π | a ∈ Aendt } ∪ {(t + , a) ∈ π | a ∈ Astt }\nwhere > 0 is chosen in such a way that < ti+1 − ti for every i = 0, . . . , k̄ − 1.\nπ\ntt-ε t+ε t\nπ~\nIt follows from Proposition 1 on serializability that plan π̃ is also valid. We denote its happening sequence as Aπ̃ = (Ãt0 , . . . , Ãtk̄ ). For the sake of notation simplicity, happening times are denoted as those in π even if in general they differ and form a larger set. Note now that the happening times in π̃ can be split into singletons ti such that Ãti only consists of strongly γ-safe actions, and intervals [ti+1, t j] such that there exists a durative action Da ∈ GAd(γ) happening in that interval. In this case we have that the subsequence A = (Ãti+1 , . . . Ãt j ) is Da-admissible. Put A∗ = (Ãti ∪ {ainv}, . . . At j ∪ {ainv}). Note that, since A is executable (as it appears in a valid plan), also A∗ is executable by Proposition 43. Since, by assumption (ii), Da∗ is γ-safe, it follows from Theorem 39, that A∗ is also γ-safe. Using again Proposition 43 we finally obtain that A is individually γ-safe.\nWe have thus proven that each happening time ti in the new plan π̃ stays inside an individually γ-safe sequence (possibly of length 1). By Corollary 28 this implies that Aπ̃ is individually γ-safe. A repetitive use of (ii) of Proposition 27 now yields that Aπ is also individually γ-safe.\nWe are thus left with proving that every durative action Da ∈ GAd(γ) happening in π satisfies properties (a) and (b) stated above. Suppose this is not true and let Da be the first (as starting time) to happen in π (in the time window [th, tk]) and to violate either condition (a) or (b). Note that all durative actions in GAd(γ) happening in π and starting strictly before time th, will necessarily end at a time t ≤ th by the way Da has been chosen. Moreover, all such durative actions will satisfy properties (a) and (b). We can then proceed as before and consider the splitting Ati = Astti ∪ A s ti ∪ A end ti for every i ≤ h (note that in th there could be, in principle, more than one starting actions in Astth ). Consider now the auxiliary plan π̃ constructed exactly like before for t ≤ th and coinciding with π for t > th. As before, we denote its happening sequence as Aπ̃ = (Ãt0 , . . . , Ãtk̄ ) using the same notation for the happening times as in π and we assume that Ãth = A st th (this is for simplicity of notation considering that it would be instead Ãth+ = A st th ). Arguing as above,\nwe obtain that (Ãt0 , . . . , Ãth−1 ) is individually γ-safe. If we take any (s̃0, . . . , s̃k̄) ∈ SÃπ (γ), we thus have that w(T , γ, s̃h̃−1) ≤ 1. Consider now A = (Ãth , Ãth+1 . . . , Ãtk ) = (Astth , Ath+1 , . . . Atk ) and note that, (s̃h−1, . . . , s̃k) ∈ SÃ(γ) so that Ã is γ-reachable. It then follows from the relevant non intertwining property ((i) of Definition 50) that Astth = {a\nst}. Suppose now that property (b) stated above is not satisfied and let l ∈ (h, k) be the first index such that Atl ∩ GAst(γ) , ∅. By (ii) of Definition 50, it follows there must exists a durative action Da′ ∈ GAd(γ) such that a′end ∈ Atl′ for some l′ ∈ (h, l]. Note that such durative action cannot start, in the plan π and thus also in the plan π̃, before time th for the way Da was chosen, it cannot either start at time th by previous considerations and neither in the interval (th, tl′ ) by the way l′ has been chosen. This proves that property (b) must be satisfied. Note that this also shows that Ati does not contain actions in GAend(γ) for any i ∈ (h, k) (as the corresponding start fragment cannot happen neither before or after time th). Finally, Ati is γ-irrelevant for every i ∈ (h, k) because of (iii) of Definition 50. Therefore A satisfies properties (a) and (b) contrarily to the assumptions made on Da. Proof is now complete.\nProof of Proposition 54. Consider Da ∈ GAd(γ) and a γ-reachable Da-admissible sequence\nA = ({ast} ∪ A1, A2, . . . , An−1, {aend} ∪ An) .\nIf a′st ∈ GAst(γ) ∩ A1, necessarily, ast and a′st are non-interfering, and, by Proposition 33, the sequence ({ast, a′st}, {ainv, a′inv}) is γ-reachable contradicting assumption (i). Therefore GAst(γ) ∩ A1 = ∅. This proves (i) in Definition 50.\nSuppose now that A1 = ∅ and suppose that (ii) in Definition 50 does not hold true for A. Let j > 1 be the first index for which (ii) is violated. Let a′st ∈ A j ∩ GAst(γ). Since ({ast}, A2, . . . , A j−1, {a′st}) is γ-reachable and for sure the pair {ainv, a′st} is non-interfering, it follows from assumption (ii) that there must exist 0 < j′ < j such that A j ′ is not γ-irrelevant. Let j′ be the first index for which this happens and let b ∈ A j′ be an action which is not γ-irrelevant . Note that b < GAend(γ) (otherwise a′st would not violate (ii)). This however contradicts assumption (ii). Therefore this proves (ii) in Definition 50.\nSuppose now that A1 = ∅ and A j ∩ (GAst(γ) ∪ GAend(γ)) = ∅ for every j = 2, . . . , n − 1. If (iii) in Definition 50 does not hold true for A, consider j > 1 to be the first index for which (iii) is violated, namely A j is not γ-irrelevant, and let b ∈ A j be any action which is not γirrelevant. Since ({ast}, A2, . . . , A j−1, {b}) is γ-reachable, it follows from assumption (ii) that there must exist 0 < j′ < j such that A j ′ is γ-relevant but this contradicts the choice of j. Proof is thus complete.\nProof of Proposition 56. Assume that, by contradiction, there exists a γ-reachable sequence\nA = ({a}, A2, . . . , An−1, {a′})\nsuch that A2, . . . , An−1 are γ-irrelevant set of actions. Consider (s0, . . . , sn) ∈ SA(γ). Suppose condition (i) is satisfied. Clearly, q ∈ s1 and, because of the assumption made, it follows that q < E f f −A j for every j = 2, . . . , n − 1. Therefore, q ∈ s n−1. Since q ∈ Pre−a′ , this is a contradiction. A similar arguments can be used if instead condition (ii) is satisfied. Finally, assume that condition (iii) is satisfied. Note that, since A2, . . . , An−1 are γ-irrelevant, Pre+aγ ∪ (Pre+a′γ \\ E f f + aγ ) ⊆ s0 and this contradicts the fact that (s0, . . . , sn) ∈ SA(γ).\nProof of Corollary 57. It is clear that condition (i) and (ii) of Theorem 51 are satisfied. In order to check thatGAd is relevant non intertwining, we show that the properties (i) and (ii) of Proposition 54 are satisfied. Fix any instance γ.\nConsider Da1,Da2 ∈ GAd(γ). It follows from the fact that Da1∗ and Da2∗ are both simply γ-safe of type (a) (see Remark 45) that\nPre+ai stγ = {q i} ⊆ E f f −ai stγ , i = 1, 2\nIf a1 st and a2 st are non-interfering, it follows that q1 , q2 and, in this case, {a1 st, a2 st} is γunreachable. This proves (i).\nConsider now Da ∈ GAd(γ) and a′ ∈ GA \\ GAend(γ) that is γ-relevant or a′ ∈ GAst(γ). Then, by assumptions (i) and (ii) we have that\nPre+astγ = {q} ⊆ E f f − astγ , Pre+a′γ = {q ′}\nIf q = q′, we have that q ∈ Γ−ast ∩ Pre+a′ and, since q ∈ γ(T ), for sure q < E f f +a′′ for any a′′ which is γ-irrelevant. This implies that condition (ii) of Definition 55 is satisfied. If instead q , q′, we have that the condition (iii) is instead satisfied. In any case this says that the pair (ast, a′) is strongly γ-irrelevant unreachable and thus also, because of Proposition 56, γ-irrelevant unreachable.\nProof of Lemma 64. We use the formalism introduced in Remarks 59 and 62. Assume that, for i = 1, 2, li matches T via the component ci whose corresponding relation has the form ri(xi1, . . . x i k, v) so that li = r(a i 1, . . . , a i k, a i k+1) or li = ∀v : r(ai1, . . . , aik, v) for free arguments ai1, . . . , a i k, a i k+1. We have that\ngr(a1j ) = γ(x 1 j ) = γ(x 2 l ), ∀ j = 1, . . . , k (12)\nwhere the first equality follows from the assumption of coherence over l1, while the second follows from the definition of an instance. Now, if l2 ∼T l1, we have that a1j = a2j for every j. It thus follows from (12) that\ngr(a2j ) = γ(x 2 l ), ∀ j = 1, . . . , k (13)\nwhich says that gr and γ are coherent over l2. On the other hand, if l2 T l1, it follows that a1j , a 2 j for some j and, since gr is injective, we also have gr(a 2 j ) , gr(a 1 j ) = γ(x 2 l ) which says that gr and γ are not coherent over l2.\nProof of Corollary 72. Suppose that a = gr(α) for some gr and let γ be an instance. Then, aγ = gr(αL) where L is the T -class on which gr and γ are coherent. Result is now a straightforward consequence of Proposition 71 and Corollary 21.\nProof of Proposition 87 . Note first of all that each of the conditions (i), (ii), (iii) expressed in Definition 86, if true forM = ML1,L2 is also true for any matchingM ⊇ ML1,L2 : this is evident for properties (i) and (ii) (see Remark 84) while for (iii) follows from the following argument. Condition (iii), forM =ML1,L2 , holds true if, either, w(Pre+αi inv\nLi ∪ Pre+ α1end Li ) ≥ 2 for i = 1 or 2 (and this does not depend onM), or if there exist two unquantified literals li ∈ Pre+\nαi inv Li ∪ Pre+ α1end Li for\ni = 1, 2 such that l1 ,ML1 ,L2 l 2. This implies that, necessarily, l1, l2 match T through components\nc1 =< r1, a1, p1 > and c2 =< r2, a2, p2 > with r1 , r2. This yields Rel[l1] , Rel[l2] and, as a consequence, l1 ,M l2 with respect to any possible matchingM.\nLet M be the matching such that gr1 and gr2 are M-adapted. It follows from Proposition 85 that ML1,L2 ⊆ M. Consequently we know that at least one of the conditions (i), (ii), (iii) expressed in Definition 86 holds true for suchM. It then follows from (6) that at least one of the following conditions hold\n(ib) Pre+a1inv ∩ Pre − a2end , ∅;\n(iib) Pre−a1inv ∩ Pre + a2end , ∅;\n(iiib) |Pre+ a1invγ ∪ Pre+ a1endγ ∪ Pre+ a2invγ ∪ Pre+ a2endγ | ≥ 2.\nBy virtue of Propositions 31 and 32 this implies that ({a1inv, a2inv}, {a1end, a2end}) is γ-unreachable.\nProof of Proposition 93. Fix any instance γ and consider Da1,Da2 ∈ GAd(γ). Let Dαi and gri, for i = 1, 2, durative schemas and groundings such that Dai = gr(Dαi). Let Li be the T -class of literals of each schema Dαi such that gri and γ are coherent over Li for i = 1, 2. Therefore, Dα1 and Dα2 must satisfy one of the conditions (i) to (iii) in the Definition 88. LetM be the matching respect to which gr1 and gr2 are adapted (in the sense of Remark 80). We know from Proposition 85 thatM ⊇ ML1,L2. Note now that if condition (i) holds true, it also holds true for such larger M (Remark 84) and this yields condition (i) of Definition 48. Similarly, condition (ii) yields the same condition with this newM (Remark 84) from which condition (ii) in Definition 88 follows using Proposition 83. Finally, if condition (iii) holds true, then condition (iii) in Definition 88 follows by using Proposition 87. Therefore, by Definition 88 we have that the two durative action schemas Dα1 and Dα2 must satisfy one of the conditions (i) to (iii) in the definition. From the fact that gr1 and gr2 areM-adapted, it follows that conditions (i) of Definition 88 yields condition (i) of Definition 48. Condition (ii) and (iii) in Definition 48 finally follow conditions (ii) and (iii) in Definition 88 using Propositions 83 and 87.\nProof of Proposition 93 . LetM be the matching respect to which the two groundings gr1 and gr2 are M-adapted. By Proposition 85, we have that M ⊇ ML1,L2 . Arguing like in the proof of Proposition 87 we obtain that one of the conditions (i)) to (iii) of Definition 92 must hold true for such a matching M. Suppose (i) holds and put q = gr1(l1) = gr2(l2) ∈ Γ1+a ∩ Pre2−a . Consider now any ground action a which is γ-irrelevant and let α be an action schema such that a = gr(α) for some grounding gr. Let L be the T -class of literals of α on which gr and γ are coherent. It follows that αL is irrelevant. Consider now the matching M̃ between α1 and α respect to which gr1 and gr are M̃-adapted. We have that M̃ ⊇ ML1,L. Then, by (i) we have that l1 <M̃ E f f + α which implies that q < E f f − a . This shows that condition (i) of Definition 55 is satisfied. Similarly, one can prove that condition (ii) of Definition 92 yields condition (ii) of Definition 55. Finally the fact that (iii) of Definition 92 yields condition (iii) of Definition 55 follows from a repeated application of relation (6).\nProof of Proposition 94. We simply have to prove that the assumptions of Proposition 54 are satisfied. Note that (i) implies (i) of Proposition 54 because of Proposition 91. We now prove (ii) of Proposition 54.\nTo this aim, fix an instance γ and a1st ∈ GAst(γ) and a2 ∈ GA \\ GAend(γ) that is not γirrelevant. Let Dα1 ∈ Ad and α2 ∈ A, gr1 and gr2 be action schemas and groundings such that gr1(Dα1) = Da1 and a2 = gr2(α2). Let Li, for i = 1, 2, be T -classes of literals of Dα1 and α2, respectively, such that gri and γ are coherent over Li. We have that α1stL1 ∈ GA\nst(T ), α2L2 < GA\nend(T ) and is not irrelevant. By assumption (ii) it then follows that α1st, α2 is strongly (L1, L2)-irrelevant unreachable and thus, by Proposition 93, (a1st, a2) is strongly γ-irrelevant unreachable. In the case when instead a2 ∈ GAst(γ) proof is analogous."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank Malte Helmert, Gabriele Roger and Jussi Rintanen for making their code for synthesising invariants available, William Cushing for helpful discussions about the configurations of temporal actions and Maria Fox and Derek Long for insightful discussions on the semantics of PDDL2.1. This work has been supported by Royal Holloway University of London, Politecnico di Torino and the NASA Exploration Systems Program."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "We present a technique for automatically extracting mutual exclusion invariants from temporal planning instances. It first identifies a set of invariant templates by inspecting the lifted representation of the domain and then checks these templates against properties that assure invariance. Our technique builds on other approaches to invariant synthesis presented in the literature, but departs from their limited focus on instantaneous actions by addressing temporal domains. To deal with time, we formulate invariance conditions that account for the entire structure of the actions and the possible concurrent interactions between them. As a result, we construct a significantly more comprehensive technique than previous methods, which is able to find not only invariants for temporal domains, but also a broader set of invariants for non-temporal domains. The experimental results reported in this paper provide evidence that identifying a broader set of invariants results in the generation of fewer multi-valued state variables with larger domains. We show that, in turn, this reduction in the number of variables reflects positively on the performance of a number of temporal planners that use a variable/value representation by significantly reducing their running time.",
    "creator" : "LaTeX with hyperref package"
  }
}