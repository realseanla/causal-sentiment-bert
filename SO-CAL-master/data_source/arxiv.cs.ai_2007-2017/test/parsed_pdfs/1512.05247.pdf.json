{
  "name" : "1512.05247.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Solving Stable Matching Problems using Answer Set Programming",
    "authors" : [ "SOFIE DE CLERCQ", "STEVEN SCHOCKAERT", "MARTINE DE COCK" ],
    "emails" : [ "SofieR.DeClercq@ugent.be)", "SchockaertS1@cardiff.ac.uk)", "MDeCock@u.washington.edu)", "ANowe@vub.ac.be)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 2.\n05 24\nKEYWORDS: Answer Set Programming, Logic Rules, Stable Marriage Problem, Optimal Stable Matchings"
    }, {
      "heading" : "1 Introduction",
      "text" : "The stable marriage problem (SMP) is a well-known matching problem introduced by Gale and Shapley (1962). The input of an SMP instance consists of (i) a set of n men and n women, (ii) for each man a ranking of the women as preferred\npartners, and (iii) for each woman a ranking of the men as preferred partners. A blocking pair of an SMP instance consists of a man and a woman who are in different marriages but both prefer each other to their actual partners. Given the problem, one can compute a stable matching or stable set of marriages, which is defined as a set of n couples (marriages) such that there are no blocking pairs. Due to its practical relevance, countless variants on the SMP have been investigated, enabling a wider range of applications. Examples of such applications include the kidney-exchange problem (Irving 2007), which matches donors in incompatible donor-recipient pairs to compatible recipients in other incompatible pairs and vice versa, and the hospital-resident problem (Manlove et al. 2002), which matches residents to the free positions in hospitals. In 2012, Roth and Shapley won the Nobel Prize for Economics for their theory of stable allocations and the practice of market design, which directly resulted from an application of the SMP.\nIn the literature, typically each time a new variant or generalization of the SMP or a different optimality criterion is considered, a new algorithm is developed; see e.g. (Gusfield 1987; Irving et al. 1987; McDermid and Irving 2012), or (Manlove 2013) for an overview. In this paper, we propose to use answer set programming (ASP) as a general vehicle for modeling a large class of extensions and variations of the SMP. We show how ASP encodings can be used to compute stable matchings, and how this encoding can be extended to compute optimal stable matchings. Although the SMP has been widely investigated, and efficient approximation or exact algorithms are available for several of its variants (Iwama et al. 2010; McDermid and Irving 2012), to the best of our knowledge, our encoding offers the first exact implementation to find sex-equal, minimum regret, egalitarian or maximum cardinality stable matchings for SMP instances with unacceptable partners and ties (see below).\nIn this paper, we will consider two well-known adaptions of the SMP. First, we will consider problem instances in which every person can specify a set of unacceptable partners. The second alteration consists of allowing ties in the preferences, i.e. one can be indifferent between some possible partners. In the literature, the SMP variant with unacceptable partners – or, equivalently, with incomplete preference lists – is abbreviated as SMI. The variant with ties is denoted as SMT and the variant which allows both extensions as SMTI. Note that the original SMP is a special case of the SMTI, i.e. the set of unacceptable partners is empty for each man and woman, and there are no ties. Therefore, our paper focusses on the SMTI variant, as it is the most general one.\nAnother way to generalize the SMP is by introducing optimality criteria for stable matchings. This is motivated by the fact that, if multiple stable matchings exist, some may be more interesting than others. In this paper, we focus on sex-equality, minimum regret, egalitarity and maximum cardinality of the stable matchings, as these are commonly investigated optimality criteria in the matching literature. Note, however, that there exist several other optimality criteria in the context of matchings, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous max-\nimum (Irving 2003). As this list is non-exhaustive, we refer the interested reader to (Manlove 2013) for an overview.\nThe structure of the paper is as follows. First we give some background about the SMP and ASP in Section 2. Then we introduce our encoding of the SMTI with ASP and prove its correctness in Section 3.1. To illustrate the flexibility of the approach, we show how it can be used to tackle three-dimensional stable matching problems in Section 3.2. In Section 4, we first discuss several optimality criteria and then extend the encoding from Section 3.1, enabling us to find optimal stable matchings. We show how optimal stable matchings of an SMTI instance can be found by solving the corresponding induced disjunctive ASP program and prove the soundness of our approach. This paper is an extended version of (De Clercq et al. 2013) and additionally provides detailed examples, complete correctness proofs and an ASP encoding of the three-dimensional stable matching problem. The three-dimensional stable matching problem is very important for practical applications, such as the kidney exchange program (Biró and McDermid 2010)."
    }, {
      "heading" : "2 Background",
      "text" : ""
    }, {
      "heading" : "2.1 The Stable Marriage Problem",
      "text" : "To solve the original SMP, Gale and Shapley (Gale and Shapley 1962) constructed an iterative algorithm —known as the Gale-Shapley algorithm, G-S algorithm or deferred-acceptance algorithm— to compute a particular stable matching of an SMP instance. The algorithm works as follows: in round 1 every man proposes to his first choice of all women. A woman, when being proposed, then rejects all men but her first choice among the subset of men who proposed to her. That first choice becomes her temporary husband. In the next rounds, all rejected men propose to their first choice among the subset of women by whom they were not rejected yet, regardless of whether this woman already has a temporary husband. Each woman, when being proposed, then rejects all men but her first choice among the subset of men who just proposed to her and her temporary mate. This process continues until all women have a husband. This point, when everyone has a partner, is always reached after a polynomial number of steps and the corresponding set of marriages is stable (Gale and Shapley 1962). It should be noted, however, that only one of the potentially exponentially many stable matchings is found in this way.\nThe classical SMP can be generalized by (i) allowing men and women to point out unacceptable partners, i.e. exclude them from their preference list and (ii) dropping the restriction that the number of men n equals the number of women p. In this variant, men and women can remain single in a stable matching. Intuitively, one prefers remaining single over being matched with an unacceptable partner. This variant is also referred to as the SMP with incomplete preference lists, abbreviated as SMI. A stable matching for an SMI instance always exists and can be found in polynomial time (Roth and Sotomayor 1990) by a slightly modified G-S algorithm. As we focus on an extension of the SMI, we refer to the online appendix for the formal definitions of the classical SMP and the SMI.\nThe SMI variant can further be generalized by additionally allowing ties in the preference lists. For this variant (SMTI) there are several ways to define stability, but we will use the notion of weak stability (Irving 1994). We denote a set of men as M = {m1, . . . ,mn} and a set of women W = {w1, . . . , wp}. A set of marriages or a matching is a collection of man-woman pairs and singles (persons paired to themselves) such that every man and every woman occurs in just one pair.\nDefinition 1 (SMTI ) An instance of the SMTI is a pair (SM , SW ) with SM = {σ1M , . . . , σ n M} and SW = {σ1W , . . . , σ p W }. For every i ∈ {1, . . . , n}, σ i M is a list of disjoint subsets of {1, . . . , p}. Symmetrically σiW is a list of disjoint subsets of {1, . . . , n} for every i ∈ {1, . . . , p}. We call σiM and σ i W the preferences of man mi and woman wi respectively and we denote the length of the list σiM as |σ i M |. If k ∈ σ i M (j), woman wk is in man mi’s j th most preferred group of women. All the women in that group are equally preferred by mi. The case k ∈ σiW (j) is similar. If there is no l such that j ∈ σ i M (l), woman wj is an unacceptable partner for man mi, and similarly when there is no l such that j ∈ σiW (l). For every k in the set σ i M (|σ i M |), man mi equally prefers staying single to being paired to woman wk, and symmetrically for the preferences of a woman wi. This is the only set in σ i M that might be empty, and similar for σiW . Man m and woman w form a blocking pair in a set of marriages S if m strictly prefers w to his partner in S and w strictly prefersm to her partner in S. A blocking individual in S is a person who stricly prefers being single to being paired to his partner in S. A weakly stable matching is a set of marriages without blocking pairs or individuals.\nA weakly stable matching always exists for an instance of the SMTI and it can be found in polynomial time by arbitrarily breaking the ties (Iwama and Miyazaki 2008). However, as opposed to the SMI variant, the number of matched persons is no longer constant for every stable matching in this variant.\nWe introduce the following notations:\nacceptableiM = σ i M (1) ∪ σ i M (2) ∪ . . . ∪ σ i M (|σ i M | − 1)\n︸ ︷︷ ︸\n= preferred iM\n∪ σiM (|σ i M |)\n︸ ︷︷ ︸\n= neutraliM\nFurthermore unacceptableiM = {1, . . . , p} \\ acceptable i M . We define the ordering ≤miM on {wj | j ∈ acceptable i M} ∪ {mi} as x ≤ mi M y iff mi prefers person x at least as much as person y. Note that mi is included in its own preference ordering to encode the possibility of staying single. The strict ordering <miM is defined in the obvious way and analogous notations are used for σjW .\nExample 1 Suppose M = {m1, m2}, W = {w1, w2, w3, w4} and SM = {σ1M = ({1, 3}, {4}), σ 2 M = ({2, 3}, {})}. Hence manm1 prefers women w1 and w3 to woman w4. There is a tie between woman w1 and w3 as well as between woman w4 and staying single. Woman w2 is unacceptable for man m1. Man m2 prefers woman w2 and w3 to staying single, but finds w1 and w4 unacceptable. It holds that w1 < m1 M m1, i.e. m1 prefers\nmarrying w1 over staying single, acceptable 1 M = {1, 3, 4}, preferred 1 M = {1, 3}, neutral1M = {4} and unacceptable 1 M = {2}."
    }, {
      "heading" : "2.2 Answer Set Programming",
      "text" : "Answer set programming or ASP is a form of declarative programming (Brewka et al. 2011). Its transparence, elegance and ability to deal with ΣP2 -complete problems make it an attractive method for solving combinatorial search and optimization problems. An ASP program is a finite collection of first-order rules\nA1 ∨ . . . ∨ Ak ← B1, . . . , Bm, not C1, . . . , not Cn\nwhere A1, . . . , Ak, B1, . . . , Bm, C1, . . . , Cn are predicates, possibly negated by ¬, and not is the negation-as-failure operator, whose meaning is explained below. The semantics are defined by the ground version of the program, consisting of all ground instantiations of the rules w.r.t. the constants that appear in it (see e.g. (Brewka et al. 2011) for a good overview). This grounded program is a propositional ASP program. The building blocks of these programs are atoms, literals and rules. The most elementary are atoms, which are propositional variables that can be true or false. A literal is an atom or a negated atom, denoted with ¬. Beside strong negation, ASP uses a special kind of negation, namely negation-as-failure (naf), denoted with ‘not’. For a literal a we call ‘not a’ the naf-literal associated with a. The extended literals consist of all literals and their associated naf-literals. A disjunctive rule has the following form\na1 ∨ . . . ∨ ak ← b1, . . . , bm, not c1, . . . , not cn\nwhere a1, . . . , ak, b1, . . . , bm, c1, . . . , cn are literals from a fixed set L, determined by a fixed set A of atoms. We call a1 ∨ . . . ∨ ak the head of the rule while the set of extended literals b1, . . . , bm, not c1, . . ., not cn is called the body. The rule above intuitively encodes that a1, a2, . . . or ak is true when we have evidence that b1, . . . , bm are true and we have no evidence that at least one of c1, . . . , cn is true. When a rule has an empty body, we call it a fact ; when the head is empty, we speak of a constraint. A rule without occurrences of not is called a simple disjunctive rule. A simple disjunctive ASP program is a finite collection of simple disjunctive rules and similarly a disjunctive ASP program P is a finite collection of disjunctive rules. If each rule head consists of at most one literal, we speak of a normal ASP program.\nWe define an interpretation I of a disjunctive ASP program P as a subset of L. An interpretation I satisfies a simple disjunctive rule a1 ∨ . . . ∨ ak ← b1, . . . , bm when a1 ∈ I or a2 ∈ I or . . . or ak ∈ I or {b1, . . . , bm} 6⊆ I. An interpretation which satisfies all rules of a simple disjunctive program is called a model of that program. An interpretation I is an answer set of a simple disjunctive program P iff it is a minimal model of P , i.e. no strict subset of I is a model of P (Gelfond and Lifschitz 1988). The reduct PI of a disjunctive ASP program P w.r.t. an interpretation I is defined as the simple disjunctive ASP program PI = {a1 ∨ . . . ∨ ak ← b1, . . . , bm | (a1 ∨ . . . ∨ ak ← b1, . . . , bm, not c1, . . . , not cn) ∈\nP , {c1, . . . , cn} ∩ I = ∅}. An interpretation I of a disjunctive ASP program P is an answer set of P iff I is an answer set of PI .\nExample 2\nLet P be the ASP program with the following 4 rules:\nman(john) ←, person(john) ←, person(fiona) ←\nwoman(X) ∨ child(X) ← person(X), notman(X)\nThe first 3 rules are facts; hence their heads will be in any answer set. The fourth rule encodes that any person who is not a man, is a woman or child. The latter rule is grounded to 2 rules in whichX is resp. replaced by john and fiona. We check that the interpretation I = {man(john), woman(fiona), person(john), person(fiona)} is an answer set of the ground version of P by computing the reduct PI . As the grounded rule with X = john is deleted since man(john) is in I, PI is:\nman(john) ←, person(john) ←, person(fiona) ←\nwoman(fiona) ∨ child(fiona) ← person(fiona)\nIt is clear that I is a minimal model of this simple program, so I is an answer set of P . By replacing woman(fiona) by child(fiona) in I, another answer set is obtained.\nTo automatically compute the answer sets of the programs in this paper, we have used the ASP solver DLV (www.dlvsystem.com), due to its ability to handle predicates, disjunction and numeric values, with built-in aggregate functions (Faber et al. 2008). The numeric values are only used for grounding."
    }, {
      "heading" : "3 Modeling the Stable Marriage Problem in ASP",
      "text" : ""
    }, {
      "heading" : "3.1 Modeling the SMTI in ASP",
      "text" : "In this section we model the SMTI, using ASP. A few proposals of using nonmonotonic reasoning for modeling the SMP have already been described in the literature. For instance, in (Marek et al. 1990) a specific variant of the SMP is mentioned (in which boys each know a subset of a set of girls and want to be matched to a girl they know) and in (Dung 1995) an abductive program is used to find a stable matching of marriages in which two fixed persons are paired, with strict, complete preference lists. To the best of our knowledge, beyond a few specific examples, no comprehensive study has been made of using ASP or related paradigms in this context. In particular, the generality of our ASP framework for weakly stable matchings of SMTI instances allows to easily adjust the encoding to variants of the SMP, such as the stable roommate problem (Gale and Shapley 1962), in which matches need to be found within one group instead of between two groups, or the three-dimensional stable matching problem (Ng and Hirschberg 1991), which matches triples between three groups instead of pairs between two.\nThe expression accept(m,w) denotes that a man m and a woman w accept each\nother as partners. The predicate manpropose(m,w) expresses that man m is willing to propose to woman w and analogously womanpropose(m,w) expresses that woman w is willing to propose to man m. Inspired by the Gale-Shapley algorithm, we look for an ASP formalization to find the stable matchings.\nDefinition 2 (ASP program induced by SMTI ) The ASP program P induced by an instance ({σ1M , . . . , σ n M}, {σ 1 W , . . . , σ p W }) of the SMTI is the program containing for every i ∈ {1, . . . , n}, j ∈ {1, . . . , p} the following rules:\naccept(mi, wj) ← manpropose(mi, wj), womanpropose(mi, wj) (1) accept(mi,mi) ← {not accept(mi, wk) | k ∈ acceptable i M} (2) accept(wj, wj) ← {not accept(mk, wj) | k ∈ acceptable j W} (3)\nand for every i ∈ {1, . . . , n}, j ∈ acceptableiM :\nmanpropose(mi, wj) ← {not accept(mi, x) |x ≤ mi M wj and wj 6= x} (4)\nand for every j ∈ {1, . . . , p}, i ∈ acceptablejW :\nwomanpropose(mi, wj) ← {not accept(x,wj) |x ≤ wj W mi and mi 6= x} (5)\nIntuitively (1) means that a man and woman accept each other as partners if they propose to each other. Due to (2), a man accepts himself as a partner (i.e. stays single) if no woman in his preference list is prepared to propose to him. Rule (4) states that a man proposes to a woman if he is not paired to a more or equally preferred woman. For j ∈ neutraliM the body of (4) contains not accept(mi,mi). No explicit rules are stated about the number of persons someone can propose to or accept but as we will see below, in Proposition 1, this is unnecessary. Note that, for k = max(n, p), the number of grounded rules in the induced ASP program is O(k2). We now illustrate our approach with an example.\nExample 3 Consider the following instance (SM , SW ) of the SMTI. Let M = {m1,m2} and W = {w1, w2, w3}. Furthermore:\nσ1M = ({1}, {2, 3}, {}) σ2M = ({2}, {1})\nσ1W = ({1, 2}, {}) σ2W = ({1}, {}) σ3W = ({2}, {1}, {})\nThe ASP program induced by this SMTI instance is:\naccept(X,Y ) ← manpropose(X,Y ), womanpropose(X,Y )\nmanpropose(m1, w1) ←\nmanpropose(m1, w2) ← not accept(m1, w1), not accept(m1, w3)\nmanpropose(m1, w3) ← not accept(m1, w1), not accept(m1, w2)\naccept(m1,m1) ← not accept(m1, w1), not accept(m1, w2),\nnot accept(m1, w3)\nmanpropose(m2, w2) ←\nmanpropose(m2, w1) ← not accept(m2, w2), not accept(m2,m2)\naccept(m2,m2) ← not accept(m2, w2), not accept(m2, w1)\nwomanpropose(m1, w1) ← not accept(m2, w1)\nwomanpropose(m2, w1) ← not accept(m1, w1)\naccept(w1, w1) ← not accept(m1, w1), not accept(m2, w1)\nwomanpropose(m1, w2) ←\naccept(w2, w2) ← not accept(m1, w2)\nwomanpropose(m2, w3) ←\nwomanpropose(m1, w3) ← not accept(m2, w3)\naccept(w3, w3) ← not accept(m1, w3), not accept(m2, w3)\nIf we run the program in DLV, we get three answer sets, containing respectively:\n• {accept(m1, w3), accept(m2, w1), accept(w2, w2)}, • {accept(m1, w2), accept(m2, w1), accept(w3, w3)}, • {accept(m1, w1), accept(m2,m2), accept(w2, w2), accept(w3, w3)}.\nThese answer sets correspond to the three weakly stable matching of marriages of this SMTI instance, namely {(m1, w3), (m2, w1), (w2, w2)}, {(m1, w2), (m2, w1), (w3, w3)} and {(m1, w1), (m2,m2), (w2, w2), (w3, w3)}.\nThe following proposition states that our ASP encoding is sound, i.e. that there is a bijective correspondence between the answer sets of the induced program and the weak stable matchings of the SMTI. The complete proof is provided in the online appendix.\nProposition 1 Let (SM , SW ) be an instance of the SMTI and let P be the corresponding ASP program. If I is an answer set of P , then a weakly stable matching for (SM , SW ) is given by {(x, y) | accept(x, y) ∈ I}. Conversely, if {(x1, y1), . . ., (xk, yk)} is a weakly stable matching for (SM , SW ) then P has the following answer set I:\n{manpropose(xi, y) | i ∈ {1, . . . , k}, xi ∈ M, y < xi M yi ∨ y = yi 6= xi}\n∪{womanpropose(x, yi) | i ∈ {1, . . . , k}, yi ∈ W,x < yi W xi ∨ x = xi 6= yi} ∪{accept(xi, yi) | i ∈ {1, . . . , k}}\nA pair (m,w) is stable if there exists a stable matching that contains (m,w). In (Manlove et al. 2002) it is shown that the decision problem ‘is the pair (m,w) stable?’ for a given SMTI instance is an NP-complete problem, even in the absence of unacceptability. It is straightforward to see that we can reformulate this decision problem as ‘does there exist an answer set of the induced normal ASP program P which contains the literal accept(m,w)?’ (i.e. brave reasoning), which is known to be an NP-complete problem (Baral 2003). Thus our model forms a suitable framework for these kind of decision problems concerning the SMTI."
    }, {
      "heading" : "3.2 Modeling the 3-Dimensional SMTI in ASP",
      "text" : "To illustrate further the flexibility of our ASP approach, we consider a variant of the SMP and show how small adaptations of the ASP encoding can solve this variant. Extending the SMP by adding another dimension to the problem was first proposed in (Knuth 1976). We work out the three-dimensional SMTI, where n men are to be matched with p women and r children. Definition 1 can straightforwardly be generalized to a three-dimensional instance (SM , SW , SC), in which preference lists of the men are defined over the set of woman-child pairs and similarly the women have preferences over man-child pairs and the children have preferences over manwoman pairs. In the three-dimensional case, σiM becoms a list of disjoint subsets of {1, . . . , p}×{1, . . . , r}, and analogously for σjW and σ k C . Similarly as before, we can define the notions of acceptableiM etc. Note that the orderings ≤ mi M , ≤ wj W and ≤ ck C are resp. defined on pairs in W ×C, M ×C and M ×W . A stable matching is now defined as a set of man-woman-child triples and singles, with the properties that no man, woman and child can be found such that each of them prefers the pair formed by the others above their current mates in the matching and no person prefers being single to being matched with its current mates. The practical relevance of this problem is pointed out in (Biró and McDermid 2010).\nExtending the ASP program from Definition 2, we can write an ASP program\ninduced by an instance of the three-dimensional matching problem.\nDefinition 3 (ASP program induced by 3D SMTI ) The ASP program P induced by an instance ({σ1M , . . . , σ n M}, {σ 1 W , . . . , σ p W }, {σ 1 C , . . . , σrC}) of the 3-dimensional SMTI is the program containing the following rules for every i ∈ {1, . . . , n}, j ∈ {1, . . . , p} and k ∈ {1, . . . , r}:\naccept(mi, wj , ck) ← manprop(mi, wj , ck), womprop(mi, wj , ck),\nchildprop(mi, wj , ck)\naccept(mi,mi,mi) ← {not accept(mi, wu, cv) | (u, v) ∈ acceptable i M}\naccept(wj, wj , wj) ← {not accept(mu, wj , cv) | (u, v) ∈ acceptable j W}\naccept(ck, ck, ck) ← {not accept(mu, wv, ck) | (u, v) ∈ acceptable k C}\nand for every i ∈ {1, . . . , n} and (j, k) ∈ acceptableiM :\nmanprop(mi, wj , ck) ← {not accept(mi, x, y) | (x, y) ≤ mi M (wj , ck); (wj , ck) 6= (x, y)}\nand for every j ∈ {1, . . . , p} and (i, k) ∈ acceptablejW : womprop(mi, wj , ck) ← {not accept(x,wj, y) | (x, y) ≤ wj W (mi, ck); (mi, ck) 6= (x, y)}\nand for every k ∈ {1, . . . , r} and (i, j) ∈ acceptablejC:\nchildprop(mi, wj , ck) ← {not accept(x, u, ck) | (x, y) ≤ ck C (mi, wj); (mi, wj) 6= (x, y)}\nNg and Hirschberg (Ng and Hirschberg 1991) proved that deciding whether a stable matching exists for the three-dimensional problem – in the absence of unacceptability and ties – is an NP-complete problem. Completely analogously as for the two-sided SMP, one can prove that this encoding yields a bijective correspondence\nbetween the answer sets of the ASP program and the stable matchings of the threedimensional matching problem. Note that, for k = max(n, p, r), the number of grounded rules in the induced ASP program is O(k3)."
    }, {
      "heading" : "4 Selecting Optimal Stable Matchings",
      "text" : ""
    }, {
      "heading" : "4.1 Notions of Optimality of Stable Matchings",
      "text" : "When several stable matchings can be found for an instance of the SMP, some may be more interesting than others. The stable matching found by the G-S algorithm is M-optimal (Roth and Sotomayor 1990), i.e. every man likes this set at least as well as any other stable matching. Exchanging the roles of men and women in the G-S algorithm yields a W-optimal stable matching (Gale and Shapley 1962), optimal from the women’s point of view.\nWhile some applications may require us to favour either the men or the women, in others it makes more sense to treat both parties equally. To formalize some commonly considered notions of fairness and optimality w.r.t. the SMP, we define the cost cx(y) of being matched with y for an individual x, where cx(y) = k if y is x’s kth preferred partner. More precisely, for a man mi, we define cmi(y) = |{z : z <miM y}|+1 for every y ∈ acceptable i M ; for a woman wj , cwj is defined analogously. So in case of ties we assign the same list position to equally preferred partners, as illustrated in Example 4.\nExample 4 Let x = m1 be a man with preference list σ 1 M = ({1}, {2, 3}, {4}) then cx(w1) = 1, cx(w2) = cx(w3) = 2 and w4 yields cx(w4) = 4. The cost for being single would be 4, i.e. cx(m1) = 4, since m1 prefers women w1, w2 and w3 to being single, but is indifferent between being paired to w4 or staying single.\nDefinition 4 (Optimal Stable Matchings) Let S be a set of marriages and let S(x) denote the partner of x in S.\n• The sex-equality cost of S is csexeq(S) = | ∑ x∈M cx(S(x))− ∑\nx∈W cx(S(x))|, • the egalitarian cost of S is cweight(S) = ∑ x∈M∪W cx(S(x)), • the regret cost of S is cregret(S) = maxx∈M∪W cx(S(x)), and • the cardinality cost of S is csingles(S) = |{z : (z, z) ∈ S}|.\nS is a sex-equal stable matching iff S is a stable matching with minimal sex-equality cost. Similarly, S is an egalitarian (resp. minimum regret, maximum cardinality) stable matching iff S is a stable matching with minimal egalitarian (resp. regret or cardinality) cost.\nA sex-equal stable matching assigns an equal importance to the preferences of the men and women, i.e. the men are as pleased with the matching as the women. An egalitarian stable matching is a stable matching in which the preferences of every individual are considered to be equally important, i.e. it minimizes the difference in happiness of all the men and women. In (Xu and Li 2011) the use of an egalitarian stable matching is proposed to optimally match virtual machines (VM) to servers in\norder to improve cloud computing by equalizing the importance of migration overhead in the data center network and VM migration performance. A minimum regret stable matching is optimal for the person who is worst off, i.e. there does not exist a stable matching such that the person who is most displeased with the matching is happier than the most displeased person in the minimum regret stable matching. A maximal or minimal cardinality stable matching is a stable matching with resp. as few or as many singles as possible. Examples of practical applications include an efficient kidney exchange program (Roth et al. 2005), which matches donors of incompatible pairs to recipients of other incompatible pairs and vice versa, and the National Resident Matching Program (www.nrmp.org) (Manlove et al. 2002), which matches healthcare professionals to graduate medical education and advanced training programs. Maximizing cardinality guarantees that as many recipients as possible will get a compatible donor and as many healthcare professionals as possible will get a position.\nRemark 1 It might be somewhat confusing that the term utilitarian is more frequently used in sociological and economical contexts for an optimization of the overall happiness (here called egalitarian), while egalitarian is more used for an optimization which minimizes the unhappiness of the individuals (tending more to minimum regret). However, we will use the cost terms as defined above, since these are standard in the context of the SMP.\nFor an overview of literature results concerning the computational complexity of finding optimal stable matchings in the SMP, SMI, SMT and SMTI, we refer to the online appendix.\nNote that other notions of preferred matchings have been described in the litera-\nture, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous maximum (Irving 2003). For more details on these and other optimality criteria, we refer the interested reader to (Manlove 2013) for an overview."
    }, {
      "heading" : "4.2 Finding Stable Matchings using Disjunctive Naf-free ASP",
      "text" : "As we discuss in Section 4.3, we can extend our ASP encoding of the SMTI such that the optimal stable matchings correspond to the answer sets of an associated ASP program. In particular, we use the saturation technique (Eiter and Gottlob 1995) to filter non-optimal answer sets. Intuitively, the idea is to create a program with 3 components: (i) a first part describing the solution candidates, (ii) a second part also describing the solution candidates since comparison of solutions requires multiple solution candidates within the same answer set whereas the first part in itself produces one solution per answer set, (iii) a third part comparing the solutions described in the first two parts and selecting the preferred solutions by saturation. It is, however, known that the presence of negation-as-failure can cause problems when applying saturation. This is due to the fact that rules containing naf-literals\ncan be altered in the reduct. To address this issue, we use saturation in combination with a disjunctive naf-free ASP program instead of the ASP program in Definition 2. To this end, we use a SAT encoding (Janhunen 2004) of the ASP program in Definition 2 and define a disjunctive naf-free ASP program in Definition 5 which selects particular models of the SAT problem.\nNote that our original normal program is absolutely tight, i.e. there is no infinite sequence l1, l2, . . . of literals such that for every i there is a program rule for which li+1 is a positive body literal and li is in the head (Erdem and Lifschitz 2003). We use the completion to derive an ASP encoding for finding optimal stable matchings. The completion of a normal ASP program is a set of propositional formulas. For every atom a with a ← bodyi (i ∈ {1, . . . , k}) all the program rules with head a, the propositional formula a ≡ body′1 ∨ . . .∨ body ′ k is in the completion of that program, where body′i is the conjunction of literals derived from bodyi by replacing every occurrence of ‘not’ with ‘¬’. If an atom a of the program does not occur in any rule head, then a ≡⊥ is in the completion of the program. Similarly the completion of the program contains the propositional formula ⊥≡ body′1 ∨ . . . ∨ body ′ l where the disjunction extends over all the program constraints ← bodyi (i ∈ {1, . . . , l}). Because our program is absolutely tight, we know that every propositional model of the completion will correspond to an answer set of the original program and vice versa (Erdem and Lifschitz 2003). When applied to the induced normal ASP program in Definition 2, the completion contains the following formulas, for all i ∈ {1, . . . , n} and j ∈ {1, . . . , p}:\naccept(mi, wj) ≡ manpropose(mi, wj) ∧womanpropose(mi, wj), accept(mi,mi) ≡ ∧\nk∈acceptablei M\n¬accept(mi, wk),\naccept(wj , wj) ≡ ∧\nk∈acceptable j\nW\n¬accept(mk, wj),\nand for all i ∈ {1, . . . , n} and j ∈ acceptableiM :\nmanpropose(mi, wj) ≡ ∧\nx≤ mi M wj ,x 6=wj\n¬accept(mi, x),\nand similarly for all j ∈ {1, . . . , p} and i ∈ acceptablejW :\nwomanpropose(mi, wj) ≡ ∧\nx≤ wj\nW mi,x 6=mi\n¬accept(x,wj),\nand for all i ∈ {1, . . . , n} and j ∈ unacceptableiM :\nmanpropose(mi, wj) ≡⊥,\nand similarly for all j ∈ {1, . . . , p} and i ∈ unacceptablejW :\nwomanpropose(mi, wj) ≡⊥ .\nUsing these formulas, which form the completion of the normal ASP program\nfrom Definition 2, we can define an equivalent disjunctive ASP program without negation-as-failure.\nDefinition 5 (Induced disj. naf-free ASP program) The disjunctive naf-free ASP programPdisj induced by an SMTI instance (SM , SW ) contains the following rules for every i ∈ {1, . . . , n}, j ∈ {1, . . . , p}:\n¬accept(mi, wj) ∨manpropose(mi, wj) ←\n¬accept(mi, wj) ∨ womanpropose(mi, wj) ←\naccept(mi, wj) ∨ ¬manpropose(mi, wj) ∨ ¬womanpropose(mi, wj) ←\nFor every i ∈ {1, . . . , n}, l ∈ unacceptableiM , j ∈ acceptable i M , x ≤ mi M wj , x 6= wj Pdisj contains: ∨\nk∈acceptablei M\naccept(mi, wk) ∨ accept(mi,mi) ←\n¬accept(mi,mi) ∨ ¬accept(mi, wj) ←\n¬manpropose(mi, wj) ∨ ¬accept(mi, x) ← ∨\nx≤ mi M wj ,x 6=wj\naccept(mi, x) ∨manpropose(mi, wj) ←\n¬manpropose(mi, wl) ←\nand symmetrical for j ∈ {1, . . . , p} and womanpropose.\nNote that, for k = max(n, p), the number of grounded rules in the induced naf-free program is O(k3). The following lemma follows from the fact that the completion corresponds to the original program (Erdem and Lifschitz 2003).\nLemma 1 Let P be the normal ASP program from Definition 2 and Pdisj the disjunctive ASP program from Definition 5. It holds that for any answer set I of P there exists an answer set Idisj of Pdisj such that the atoms of I and Idisj coincide. Conversely for any answer set Idisj of Pdisj there exists an answer set I of P such that the atoms of I and Idisj coincide."
    }, {
      "heading" : "4.3 ASP Program to Select Optimal Solutions",
      "text" : "Let (SM , SW ) be an SMTI instance with SM = {σ1M , . . . , σ n M} and SW = {σ 1 W , . . . , σ p W }, and let Pnorm be the induced normal ASP program from Definition 2. Our technique for extending this program to a program that can respectively optimize for the sex-equality, egalitarian, minimum regret and maximum cardinality criterion is in each case very similar. We start by explaining it for the case of sex-equality. Our first step is to add a set of rules that compute the sex-equality cost of a set of marriages. For every man mi and every x ∈ acceptableiM ∪ {mi} we use the following rule to determine the cost for mi:\nmancost(i, cmi(x)) ← accept(mi, x) (6)\nand similarly for every wj and every x ∈ acceptable j W ∪ {wj}:\nwomancost(j, cwj (x)) ← accept(x,wj) (7)\nWe also use the following rules with i ranging from 1 to n and j from 1 to p:\nmanweight(Z) ← #sum{B,A : mancost(A,B)} = Z,#int(Z) (8)\nwomanweight(Z) ← #sum{B,A : womancost(A,B)} = Z,#int(Z) (9)\nsexeq(Z) ← manweight(X), womanweight(Y ), Z = X − Y\nsexeq(Z) ← manweight(X), womanweight(Y ), Z = Y −X (10)\nNote that #sum, #max, #int and #count are DLV aggregate functions (Faber et al. 2008). The ‘A’ mentioned as variable in #sum indicates that a cost must be included for every person (otherwise the cost is included only once when persons have the same cost). Rule (8) determines the sum of the male costs and similarly (9) determines the sum of the female costs. According to Definition 4 the absolute difference of these values yields the sex-equality cost, as determined by rules (10). Since numeric variables are restricted to positive integers in DLV, we omit conditions as ‘X ≥ Y ’ or ‘X < Y ’. The program Pnorm extended with rules (6) – (10) is denoted P sexeq ext .\nWe construct a program Psexeq, composed by subprograms, that selects optimal solutions. Let P ′disj be the disjunctive naf-free ASP program, induced by the same SMTI instance, in which a prime symbol is added to all literal names (e.g. accept becomes accept′). Define a new program P ′sexeqext with all the rules of P ′ disj in which every occurrence of ¬atom is changed into natom for every atom atom, i.e. replace all negation symbols by a prefix ‘n’. For every occurring atom atom in P ′sexeqext , add the following rule to exclude non-consistent solutions:\nsat ← atom, natom (11)\nFor instance, the rule sat ← accept′(m1, w1), naccept ′(m1, w1) is added. Finally add rules (6) – (10) with prime symbols to the literal names to P ′sexeqext but replace rule (8) and rule (9) by:\nmansum′(n,X) ← mancost′(n,X)\nmansum′(J, Z) ← mansum′(I,X),mancost′(J, Y ), Z = X + Y,#succ(J, I)\nmanweight′(Z) ← mansum′(1, Z)\nwomansum′(p,X) ← womancost′(p,X)\nwomansum′(J, Z) ← womansum′(I,X), womancost′(J, Y ), Z = X + Y,\n#succ(J, I)\nwomanweight′(Z) ← womansum′(1, Z) (12)\nThe DLV aggregate function #succ(J, I) is true whenever J+1 = I. We replace the rules with the aggregate function #max by these rules to make sure the saturation happens correctly. When saturation is used, the DLV aggregate functions #max, #sum and #count would not yield the right criterion values. Moreover, DLV does not accept these aggregate functions in saturation because of the cyclic dependency of literals within the aggregate functions created by the rules for saturation. These\nadjusted rules, however, will not pose any problems because of the successive way they compute the criterion values. This becomes more clear in the proof of Proposition 2. We define the ASP program Psexeq as the union of P sexeq ext , P ′sexeq ext and Psat. The ASP program Psat contains the following rules to select minimal solutions based on sex-equality:\nsat ← sexeq(X), sexeq′(Y ), X ≤ Y (13)\n← not sat (14)\nmancost′(X,Y ) ← sat,manargcost′1(X),manargcost ′ 2(Y )\nwomancost′(X,Y ) ← sat, womanargcost′1(X), womanargcost ′ 2(Y ) (15)\nmanpropose′(X,Y ) ← sat,man(X), woman(Y )\nwomanpropose′(X,Y ) ← sat,man(X), woman(Y )\naccept′(X,X) ← sat,man(X)\naccept′(X,X) ← sat, woman(X)\naccept′(X,Y ) ← sat,man(X), woman(Y ) (16)\nand analogous to (16) a set of rules with prefix ‘n’ for the head predicates. Finally we add the factsmanargcost′1(1..n) ←,manargcost ′ 2(1..(p+1)) ←, womanargcost ′ 1(1..p) ←, womanargcost′2(1..(n + 1)) ←, man(x) ← for every man x and woman(x) ← for every woman x to Psat. The rule manargcost′1(1..n) ← is DLV syntax for the n facts manargcost′1(1) ←, . . . ,manargcost ′ 1(n) ←. Intuitively the rules of Psat express the key idea of saturation. First every answer set is forced to contain the atom sat by rule (14). Then the rules (15) – (16) and the facts make sure that any answer set should contain all possible literals with a prime symbol that occur in Psexeq. Rule (13) will establish that only optimal solutions will correspond to minimal models and thus lead to answer sets. For any non-optimal solution, the corresponding interpretation containing sat will never be a minimal model of the reduct. It is formally proven in Proposition 2 below that Psexeq produces exactly the stable matchings with minimal sex-equality cost.\nFurthermore, only small adjustments to Psexeq are needed to create programs Pweight, Pregret, and Psingles that respectively produce egalitarian, minimum regret and maximum cardinality stable matchings. Indeed, the ASP program Pweight can easily be defined as Psexeq in which the predicates sexeq and sexeq ′ are respectively replaced by weight and weight′ and the rules (10) are replaced by (17), determining the egalitarian cost of Definition 4 as the sum of the male and female costs:\nweight(Z) ← manweight(X), womanweight(Y ), Z = X + Y (17)\nSimilarly the ASP program Pregret is defined as Psexeq in which the predicates sexeq and sexeq′ are resp. replaced by regret and regret′ and rules (8) – (10) are replaced by the following rules:\nmanregret(Z) ← #max{B : mancost(A,B)} = Z,#int(Z) (18)\nwomanregret(Z) ← #max{B : womancost(A,B)} = Z,#int(Z) (19)\nregret(X) ← manregret(X), womanregret(Y ), X > Y\nregret(Y ) ← manregret(X), womanregret(Y ), X ≤ Y (20)\nRule (18) determines the regret cost but only for the men. Similarly (19) determines the regret cost for the women. The regret cost as defined in Definition 4 is the maximum of these two values, determined by the rules in (20). Again we adjust rules (18) and (19) for the program part P ′regretext by replacing them with a variant based on the successor function:\nmanmax′(n,X) ← mancost′(n,X)\nmanmax′(J,X) ← manmax′(I,X),mancost′(J, Y ), X ≥ Y,#succ(J, I)\nmanmax′(J, Y ) ← manmax′(I,X),mancost′(J, Y ), X < Y,#succ(J, I)\nmanregret′(Z) ← manmax′(1, Z)\nwomanmax′(p,X) ← womancost′(p,X)\nwomanmax′(J,X) ← womanmax′(I,X), womancost′(J, Y ), X ≥ Y,#succ(J, I)\nwomanmax′(J, Y ) ← womanmax′(I,X), womancost′(J, Y ), X < Y,#succ(J, I)\nwomanregret′(Z) ← womanmax′(1, Z) (21)\nFinally we define the ASP program Psingles as Psexeq in which the predicates sexeq and sexeq′ are resp. replaced by singles and singles′. Furthermore we replace rules (6) – (10) by (22), determining the number of singles:\nsingles(Z) ← #count{B : accept(B,B)} = Z,#int(Z) (22)\nThis time we adjust rule (22) for the program part P ′singlesext as follows:\nsingle′(p+ i, 1) ← accept′(mi,mi), single ′(p+ i, 0) ← naccept′(mi,mi)\nsingle′(j, 1) ← accept′(wj , wj), single ′(j, 0) ← naccept′(wj , wj)\nsinglesum′(n+ p,X) ← single′(n+ p,X)\nsinglesum′(J, Z) ← singlesum′(I,X), single′(J, Y ), Z = X + Y,#succ(J, I)\nsingles′(Z) ← singlesum′(1, Z) (23)\nNote that, for k = max(n, p), the number of grounded rules in the induced ASP program is O(k3) for minimum regret and maximum cardinality, but O(k4) for sexequalness and egalitarity. The latter programs have a higher number of grounded rules because of how the weights are counted in the first and second program part. We illustrate our method with an example.\nExample 5 We reconsider Example 3. This SMTI instance had 3 stable matchings of marriages:\n• S1 = {accept(m1, w3), accept(m2, w1), accept(w2, w2)}, • S2 = {accept(m1, w2), accept(m2, w1), accept(w3, w3)}, • S3 = {accept(m1, w1), accept(m2,m2), accept(w2, w2), accept(w3, w3)}.\nIt is easy to compute the respective regret costs as cregret(S1) = 2 and cregret(S2) = cregret(S3) = 3. The corresponding ASP program selecting this minimum regret stable matching is the program consisting of the rules in Example 3 in addition to:\nman(m1) ←, man(m2) ←,\nwoman(w1) ←, woman(w2) ←, woman(w3) ←\nmancost(1, 1) ← accept(m1, w1), womancost(1, 1) ← accept(m1, w1)\nmancost(1, 2) ← accept(m1, w2), womancost(1, 1) ← accept(m2, w1)\nmancost(1, 2) ← accept(m1, w3), womancost(1, 2) ← accept(w1, w1)\nmancost(1, 4) ← accept(m1,m1), womancost(2, 1) ← accept(m1, w2)\nmancost(2, 2) ← accept(m2, w1), womancost(2, 2) ← accept(w2, w2)\nmancost(2, 1) ← accept(m2, w2), womancost(3, 2) ← accept(m1, w3)\nmancost(2, 2) ← accept(m2,m2), womancost(3, 1) ← accept(m2, w3)\nwomancost(3, 3) ← accept(w3, w3)\nmanregret(Z) ← #max{B : mancost(A,B)} = Z,#int(Z)\nwomanregret(Z) ← #max{B : womancost(A,B)} = Z,#int(Z)\nregret(X) ← manregret(X), womanregret(Y ), X > Y\nregret(Y ) ← manregret(X), womanregret(Y ), X <= Y\nnaccept′(M,W ) ∨manpropose′(M,W ) ← man(M),\nwoman(W )\nnaccept′(M,W ) ∨ womanpropose′(M,W ) ← man(M),\nwoman(W )\naccept′(M,W ) ∨ nmanpropose′(M,W ) ∨ nwomanpropose′(M,W ) ← man(M),\nwoman(W )\naccept′(m1, w1) ∨ accept ′(m1, w2) ∨ accept ′(m1, w3) ∨ accept ′(m1,m1) ←\naccept′(m2, w1) ∨ accept ′(m2, w2) ∨ accept ′(m2,m2) ←\nnaccept′(m1,m1) ∨ naccept ′(m1, w1) ← naccept′(m1,m1) ∨ naccept ′(m1, w2) ← naccept′(m1,m1) ∨ naccept ′(m1, w3) ← naccept′(m2,m2) ∨ naccept ′(m2, w1) ← naccept′(m2,m2) ∨ naccept ′(m2, w2) ←\naccept′(m1, w1) ∨ accept ′(m2, w1) ∨ accept ′(w1, w1) ←\naccept′(m1, w2) ∨ accept ′(w2, w2) ←\naccept′(m1, w3) ∨ accept ′(m2, w3) ∨ accept ′(w3, w3) ←\nnaccept′(w1, w1) ∨ naccept ′(m1, w1) ← naccept′(w1, w1) ∨ naccept ′(m2, w1) ← naccept′(w2, w2) ∨ naccept ′(m1, w2) ← naccept′(w3, w3) ∨ naccept ′(m1, w3) ← naccept′(w3, w3) ∨ naccept ′(m2, w3) ←\nnmanpropose′(m1, w2) ∨ naccept ′(m1, w1) ← nmanpropose′(m1, w2) ∨ naccept ′(m1, w3) ←\nnmanpropose′(m1, w3) ∨ naccept ′(m1, w1) ← nmanpropose′(m1, w3) ∨ naccept ′(m1, w2) ←\nmanpropose′(m1, w1) ←\naccept′(m1, w1) ∨ accept ′(m1, w3) ∨manpropose ′(m1, w2) ← accept′(m1, w1) ∨ accept ′(m1, w2) ∨manpropose ′(m1, w3) ←\nnmanpropose′(m2, w1) ∨ naccept ′(m2, w2) ← nmanpropose′(m2, w1) ∨ naccept ′(m2,m2) ←\nmanpropose′(m2, w2) ←\naccept′(m2, w2) ∨ accept ′(m2,m2) ∨manpropose ′(m2, w1) ←\nnwomanpropose′(m1, w1) ∨ naccept ′(m2, w1) ← nwomanpropose′(m2, w1) ∨ naccept ′(m1, w1) ←\naccept′(m1, w1) ∨ womanpropose ′(m2, w1) ← accept′(m2, w1) ∨ womanpropose ′(m1, w1) ←\nwomanpropose′(m1, w2) ←\nnwomanpropose′(m1, w3) ∨ naccept ′(m2, w3) ←\nwomanpropose′(m2, w3) ←\naccept′(m2, w3) ∨ womanpropose ′(m1, w3) ←\nnmanpropose′(m2, w3) ← nwomanpropose′(m2, w2) ←\nsat ← manpropose′(X,Y ), nmanpropose′(X,Y ),man(X),\nwoman(Y )\nsat ← womanpropose′(X,Y ), nwomanpropose′(X,Y ),\nman(X), woman(Y )\nsat ← accept′(X,Y ), naccept′(X,Y ),man(X), woman(Y )\nsat ← accept′(X,X), naccept′(X,X),man(X)\nsat ← accept′(X,X), naccept′(X,X), woman(X)\nmancost′(1, 1) ← accept′(m1, w1), womancost ′(1, 1) ← accept′(m1, w1) mancost′(1, 2) ← accept′(m1, w2), womancost ′(1, 1) ← accept′(m2, w1) mancost′(1, 2) ← accept′(m1, w3), womancost ′(1, 2) ← accept′(w1, w1) mancost′(1, 4) ← accept′(m1,m1), womancost ′(2, 1) ← accept′(m1, w2) mancost′(2, 2) ← accept′(m2, w1), womancost ′(2, 2) ← accept′(w2, w2) mancost′(2, 1) ← accept′(m2, w2), womancost ′(3, 2) ← accept′(m1, w3) mancost′(2, 2) ← accept′(m2,m2), womancost ′(3, 1) ← accept′(m2, w3)\nwomancost′(3, 3) ← accept′(w3, w3)\nmanmax′(2, X) ← mancost′(2, X)\nmanmax′(J,X) ← manmax′(I,X),mancost′(J, Y ), X >= Y,#succ(J, I)\nmanmax′(J,X) ← manmax′(I,X),mancost′(J, Y ), X >= Y,#succ(J, I)\nmanregret′(Z) ← manmax′(1, Z)\nwomanmax′(3, X) ← womancost′(3, X)\nwomanmax′(J,X) ← womanmax′(I,X), womancost′(J, Y ), X >= Y,\n#succ(J, I)\nwomanmax′(J,X) ← womanmax′(I,X), womancost′(J, Y ), X >= Y,\n#succ(J, I)\nwomanregret′(Z) ← womanmax′(1, Z)\nregret′(X) ← manregret′(X), womanregret′(Y ), X > Y\nregret′(Y ) ← manregret′(X), womanregret′(Y ), X <= Y\nsat ← regret(X), regret′(Y ), X <= Y\n← not sat\nmanargcost′1(1..2) ←, womanargcost ′ 1(1..3) ← manargcost′2(1..4) ←, womanargcost ′ 2(1..3) ←\nmancost′(X,Y ) ← sat,manargcost′1(X),manargcost ′ 2(Y )\nwomancost′(X,Y ) ← sat, womanargcost′1(X), womanargcost ′ 2(Y )\nmanpropose′(X,Y ) ← sat,man(X), woman(Y )\nnmanpropose′(X,Y ) ← sat,man(X), woman(Y )\nwomanpropose′(X,Y ) ← sat,man(X), woman(Y )\nnwomanpropose′(X,Y ) ← sat,man(X), woman(Y )\naccept′(X,Y ) ← sat,man(X), woman(Y )\naccept′(X,X) ← sat,man(X)\naccept′(X,X) ← sat, woman(X)\nnaccept′(X,Y ) ← sat,man(X), woman(Y )\nnaccept′(X,X) ← sat,man(X)\nnaccept′(X,X) ← sat, woman(X)\nComputing the unique answer set of this disjunctive ASP program with DLV and filtering it to the literals accept and regret, yields {accept(m2, w1), accept(m1, w3), accept(w2, w2), regret(2)}, corresponding exactly to the minimum regret stable matching S1 of the SMTI instance and the corresponding regret cost.\nWe prove that there exists a bijective correspondence between the answer sets of the induced disjunctive ASP program and the optimal stable matchings of the SMTI (see the online appendix).\nProposition 2 Let the criterion crit be an element of {sexeq, weight, regret, singles}. For every answer set I of the program Pcrit induced by an SMTI instance the set SI = {(m,w) | accept(m, w) ∈ I} forms an optimal stable matching of marriages w.r.t. criterion crit and the optimal criterion value is given by the unique value vI for\nwhich crit(vI) ∈ I. Conversely for every optimal stable matching S = {(x1, y1), . . . , (xk, yk)} with optimal criterion value v there exists an answer set I of Pcrit such that {(x, y) | accept(x, y) ∈ I} = {(xi, yi) | i ∈ {1, . . . , k}} and v is the unique value for which crit(v) ∈ I.\nRemark 2 If we remove from Psexeq the rules (9) – (10) and replace rule (13) by the rule sat ← manweight(X), manweight′(Y ), X ≤ Y , then we obtain the M-optimal stable matchings. Analogously we can obtain the W-optimal stable matchings.\nIf a criterion is to be maximized, the symbol ≤ in rule (13) is simply replaced\nby ≥. E.g. for crit = singles we will get minimum cardinality stable matchings."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We have shown how ASP programs can be used to encode a number of variations and generalizations of the SMP. Apart from the availability of efficient ASP solvers, the main advantage of our approach is its flexibility, allowing us to find solutions for a wide range of stable matching problems. We can, for instance, compute stable matchings of variants such as the three-dimensional stable matching problem, as well as select stable matchings based on optimality criteria, even for problems with unacceptable partners and ties. We have illustrated our method for sex-equality, egalitarity, minimum regret and maximum cardinality, but the approach can readily be adapted to other optimality criteria (e.g. popular matchings) or to different matching problems (e.g. the roommate problem). To the best of our knowledge, no other exact algorithms exist to find an optimal stable matching for an SMP instance with ties, regardless of the presence of unacceptability and regardless of whether the optimality notion is sex-equality, egalitarity, minimum regret or maximum cardinality. Therefore, our encoding offers the first exact implementation for solving the aforementioned problems."
    } ],
    "references" : [ {
      "title" : "Popular matchings",
      "author" : [ "D. Abraham", "R. Irving", "K. Mehlhorn", "K. Telikepalli", "K. Mehlhorn" ],
      "venue" : "SIAM Journal on Computing 37, 4, 1030–1045.",
      "citeRegEx" : "Abraham et al\\.,? 2007",
      "shortCiteRegEx" : "Abraham et al\\.",
      "year" : 2007
    }, {
      "title" : "Knowledge Representation, Reasoning, and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press, New York, NY, USA.",
      "citeRegEx" : "Baral,? 2003",
      "shortCiteRegEx" : "Baral",
      "year" : 2003
    }, {
      "title" : "Three-sided stable matchings with cyclic preferences",
      "author" : [ "P. Biró", "E. McDermid" ],
      "venue" : "Algorithmica 58, 1, 5–18.",
      "citeRegEx" : "Biró and McDermid,? 2010",
      "shortCiteRegEx" : "Biró and McDermid",
      "year" : 2010
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "G. Brewka", "T. Eiter", "M. Truszczyński" ],
      "venue" : "Communications of the ACM 54, 12, 92–103.",
      "citeRegEx" : "Brewka et al\\.,? 2011",
      "shortCiteRegEx" : "Brewka et al\\.",
      "year" : 2011
    }, {
      "title" : "Modeling stable matching problems with answer set programming",
      "author" : [ "S. De Clercq", "S. Schockaert", "M. De Cock", "A. Nowé" ],
      "venue" : "Proceedings RuleML 2013. Lecture Notes in Computer Science, vol. 8035. 68–83.",
      "citeRegEx" : "Clercq et al\\.,? 2013",
      "shortCiteRegEx" : "Clercq et al\\.",
      "year" : 2013
    }, {
      "title" : "An argumentation-theoretic foundation for logic programming",
      "author" : [ "P. Dung" ],
      "venue" : "The Journal of Logic Programming 22, 2, 151–177.",
      "citeRegEx" : "Dung,? 1995",
      "shortCiteRegEx" : "Dung",
      "year" : 1995
    }, {
      "title" : "On the computational cost of disjunctive logic programming: Propositional case",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 15, 3-4, 289–323.",
      "citeRegEx" : "Eiter and Gottlob,? 1995",
      "shortCiteRegEx" : "Eiter and Gottlob",
      "year" : 1995
    }, {
      "title" : "Tight logic programs",
      "author" : [ "E. Erdem", "V. Lifschitz" ],
      "venue" : "Theory and Practice of Logic Programming 3, 499–518.",
      "citeRegEx" : "Erdem and Lifschitz,? 2003",
      "shortCiteRegEx" : "Erdem and Lifschitz",
      "year" : 2003
    }, {
      "title" : "Design and implementation of aggregate functions in the DLV system",
      "author" : [ "W. Faber", "G. Pfeifer", "N. Leone", "T. Dell’Armi", "G. Ielpa" ],
      "venue" : "Theory and Practice of Logic Programming",
      "citeRegEx" : "Faber et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Faber et al\\.",
      "year" : 2008
    }, {
      "title" : "College admissions and the stability of marriage",
      "author" : [ "D. Gale", "L. Shapley" ],
      "venue" : "The American Mathematical Monthly 69, 1, 9–15.",
      "citeRegEx" : "Gale and Shapley,? 1962",
      "shortCiteRegEx" : "Gale and Shapley",
      "year" : 1962
    }, {
      "title" : "Some remarks on the stable matching problem",
      "author" : [ "D. Gale", "M. Sotomayor" ],
      "venue" : "Discr. Appl. Math. 11, 223–232.",
      "citeRegEx" : "Gale and Sotomayor,? 1985",
      "shortCiteRegEx" : "Gale and Sotomayor",
      "year" : 1985
    }, {
      "title" : "Match making: Assignments based on bilateral preferences",
      "author" : [ "P. Gärdenfors" ],
      "venue" : "Behavioral Science 20, 3, 166–173.",
      "citeRegEx" : "Gärdenfors,? 1975",
      "shortCiteRegEx" : "Gärdenfors",
      "year" : 1975
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "ICLP/SLP. Vol. 88. 1070–1080.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Three fast algorithms for four problems in stable marriage",
      "author" : [ "D. Gusfield" ],
      "venue" : "SIAM J. Comput. 16, 1, 111–128.",
      "citeRegEx" : "Gusfield,? 1987",
      "shortCiteRegEx" : "Gusfield",
      "year" : 1987
    }, {
      "title" : "Stable marriage and indifference",
      "author" : [ "R. Irving" ],
      "venue" : "Discr. Appl. Math. 48, 3, 261–272.",
      "citeRegEx" : "Irving,? 1994",
      "shortCiteRegEx" : "Irving",
      "year" : 1994
    }, {
      "title" : "Greedy matchings",
      "author" : [ "R. Irving" ],
      "venue" : "Tech. Rep. TR-2003-136, Dept. of Computing Science, University of Glasgow. April.",
      "citeRegEx" : "Irving,? 2003",
      "shortCiteRegEx" : "Irving",
      "year" : 2003
    }, {
      "title" : "The cycle roommates problem: a hard case of kidney exchange",
      "author" : [ "R. Irving" ],
      "venue" : "Inf. Process. Lett. 103, 1, 1–4.",
      "citeRegEx" : "Irving,? 2007",
      "shortCiteRegEx" : "Irving",
      "year" : 2007
    }, {
      "title" : "An efficient algorithm for the “optimal” stable marriage",
      "author" : [ "R. Irving", "P. Leather", "D. Gusfield" ],
      "venue" : "J. ACM 34, 3, 532–543.",
      "citeRegEx" : "Irving et al\\.,? 1987",
      "shortCiteRegEx" : "Irving et al\\.",
      "year" : 1987
    }, {
      "title" : "A survey of the stable marriage problem and its variants",
      "author" : [ "K. Iwama", "S. Miyazaki" ],
      "venue" : "Proc. of the Intern. Conf. on Informatics Educ. and Research for KnowledgeCirculating Society. ICKS’08. IEEE Computer Society, 131–136.",
      "citeRegEx" : "Iwama and Miyazaki,? 2008",
      "shortCiteRegEx" : "Iwama and Miyazaki",
      "year" : 2008
    }, {
      "title" : "Approximation algorithms for the sex-equal stable marriage problem",
      "author" : [ "K. Iwama", "S. Miyazaki", "H. Yanagisawa" ],
      "venue" : "ACM Transactions on Algorithms (TALG) 7, 1, 2.",
      "citeRegEx" : "Iwama et al\\.,? 2010",
      "shortCiteRegEx" : "Iwama et al\\.",
      "year" : 2010
    }, {
      "title" : "Representing normal programs with clauses",
      "author" : [ "T. Janhunen" ],
      "venue" : "In Proc. of the 16th European Conference on Artificial Intelligence. IOS Press, 358–362.",
      "citeRegEx" : "Janhunen,? 2004",
      "shortCiteRegEx" : "Janhunen",
      "year" : 2004
    }, {
      "title" : "Mariages Stables",
      "author" : [ "D. Knuth" ],
      "venue" : "Les Presses de L’Université de Montréal.",
      "citeRegEx" : "Knuth,? 1976",
      "shortCiteRegEx" : "Knuth",
      "year" : 1976
    }, {
      "title" : "Algorithmics of matching under preferences",
      "author" : [ "D. Manlove" ],
      "venue" : "Series on Theoretical Computer Science, vol. 2. World Scientific Publishing.",
      "citeRegEx" : "Manlove,? 2013",
      "shortCiteRegEx" : "Manlove",
      "year" : 2013
    }, {
      "title" : "Hard variants of stable marriage",
      "author" : [ "D. Manlove", "R. Irving", "K. Iwama", "S. Miyazaki", "Y. Morita" ],
      "venue" : "Theoretical Computer Science 276, 1-2, 261–279.",
      "citeRegEx" : "Manlove et al\\.,? 2002",
      "shortCiteRegEx" : "Manlove et al\\.",
      "year" : 2002
    }, {
      "title" : "A theory of nonmonotonic rule systems I",
      "author" : [ "V. Marek", "A. Nerode", "J. Remmel" ],
      "venue" : "Ann. Math. Artif. Intell. 1, 241–273.",
      "citeRegEx" : "Marek et al\\.,? 1990",
      "shortCiteRegEx" : "Marek et al\\.",
      "year" : 1990
    }, {
      "title" : "Sex-equal stable matchings: Complexity and exact algorithms",
      "author" : [ "E. McDermid", "R. Irving" ],
      "venue" : "Algorithmica, 1–26.",
      "citeRegEx" : "McDermid and Irving,? 2012",
      "shortCiteRegEx" : "McDermid and Irving",
      "year" : 2012
    }, {
      "title" : "Three-dimensional stable matching problems",
      "author" : [ "C. Ng", "D. Hirschberg" ],
      "venue" : "SIAM Journal on Discrete Mathematics 4, 245–252.",
      "citeRegEx" : "Ng and Hirschberg,? 1991",
      "shortCiteRegEx" : "Ng and Hirschberg",
      "year" : 1991
    }, {
      "title" : "Pairwise kidney exchange",
      "author" : [ "A. Roth", "T. Sömnez", "M. Ünver" ],
      "venue" : "J. Econ. Theory 125, 2, 151 – 188.",
      "citeRegEx" : "Roth et al\\.,? 2005",
      "shortCiteRegEx" : "Roth et al\\.",
      "year" : 2005
    }, {
      "title" : "Two-Sided Matching: A Study in Game-Theoretic Modeling and Analysis",
      "author" : [ "A. Roth", "M. Sotomayor" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Roth and Sotomayor,? 1990",
      "shortCiteRegEx" : "Roth and Sotomayor",
      "year" : 1990
    }, {
      "title" : "Egalitarian stable matching for VM migration in cloud computing",
      "author" : [ "H. Xu", "B. Li" ],
      "venue" : "Computer Communications Workshops (INFOCOM WKSHPS), 2011 IEEE Conference on. IEEE, 631–636.",
      "citeRegEx" : "Xu and Li,? 2011",
      "shortCiteRegEx" : "Xu and Li",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "Since the introduction of the stable marriage problem (SMP) by Gale and Shapley (1962), several variants and extensions have been investigated.",
      "startOffset" : 63,
      "endOffset" : 87
    }, {
      "referenceID" : 9,
      "context" : "The stable marriage problem (SMP) is a well-known matching problem introduced by Gale and Shapley (1962). The input of an SMP instance consists of (i) a set of n men and n women, (ii) for each man a ranking of the women as preferred",
      "startOffset" : 81,
      "endOffset" : 105
    }, {
      "referenceID" : 16,
      "context" : "Examples of such applications include the kidney-exchange problem (Irving 2007), which matches donors in incompatible donor-recipient pairs to compatible recipients in other incompatible pairs and vice versa, and the hospital-resident problem (Manlove et al.",
      "startOffset" : 66,
      "endOffset" : 79
    }, {
      "referenceID" : 23,
      "context" : "Examples of such applications include the kidney-exchange problem (Irving 2007), which matches donors in incompatible donor-recipient pairs to compatible recipients in other incompatible pairs and vice versa, and the hospital-resident problem (Manlove et al. 2002), which matches residents to the free positions in hospitals.",
      "startOffset" : 243,
      "endOffset" : 264
    }, {
      "referenceID" : 13,
      "context" : "(Gusfield 1987; Irving et al. 1987; McDermid and Irving 2012), or (Manlove 2013) for an overview.",
      "startOffset" : 0,
      "endOffset" : 61
    }, {
      "referenceID" : 17,
      "context" : "(Gusfield 1987; Irving et al. 1987; McDermid and Irving 2012), or (Manlove 2013) for an overview.",
      "startOffset" : 0,
      "endOffset" : 61
    }, {
      "referenceID" : 25,
      "context" : "(Gusfield 1987; Irving et al. 1987; McDermid and Irving 2012), or (Manlove 2013) for an overview.",
      "startOffset" : 0,
      "endOffset" : 61
    }, {
      "referenceID" : 22,
      "context" : "1987; McDermid and Irving 2012), or (Manlove 2013) for an overview.",
      "startOffset" : 36,
      "endOffset" : 50
    }, {
      "referenceID" : 19,
      "context" : "Although the SMP has been widely investigated, and efficient approximation or exact algorithms are available for several of its variants (Iwama et al. 2010; McDermid and Irving 2012), to the best of our knowledge, our encoding offers the first exact implementation to find sex-equal, minimum regret, egalitarian or maximum cardinality stable matchings for SMP instances with unacceptable partners and ties (see below).",
      "startOffset" : 137,
      "endOffset" : 182
    }, {
      "referenceID" : 25,
      "context" : "Although the SMP has been widely investigated, and efficient approximation or exact algorithms are available for several of its variants (Iwama et al. 2010; McDermid and Irving 2012), to the best of our knowledge, our encoding offers the first exact implementation to find sex-equal, minimum regret, egalitarian or maximum cardinality stable matchings for SMP instances with unacceptable partners and ties (see below).",
      "startOffset" : 137,
      "endOffset" : 182
    }, {
      "referenceID" : 11,
      "context" : "Note, however, that there exist several other optimality criteria in the context of matchings, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous max-",
      "startOffset" : 114,
      "endOffset" : 131
    }, {
      "referenceID" : 10,
      "context" : "Note, however, that there exist several other optimality criteria in the context of matchings, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous max-",
      "startOffset" : 151,
      "endOffset" : 201
    }, {
      "referenceID" : 28,
      "context" : "Note, however, that there exist several other optimality criteria in the context of matchings, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous max-",
      "startOffset" : 151,
      "endOffset" : 201
    }, {
      "referenceID" : 15,
      "context" : "Note, however, that there exist several other optimality criteria in the context of matchings, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous max-",
      "startOffset" : 248,
      "endOffset" : 261
    }, {
      "referenceID" : 15,
      "context" : "imum (Irving 2003).",
      "startOffset" : 5,
      "endOffset" : 18
    }, {
      "referenceID" : 22,
      "context" : "As this list is non-exhaustive, we refer the interested reader to (Manlove 2013) for an overview.",
      "startOffset" : 66,
      "endOffset" : 80
    }, {
      "referenceID" : 2,
      "context" : "The three-dimensional stable matching problem is very important for practical applications, such as the kidney exchange program (Biró and McDermid 2010).",
      "startOffset" : 128,
      "endOffset" : 152
    }, {
      "referenceID" : 9,
      "context" : "To solve the original SMP, Gale and Shapley (Gale and Shapley 1962) constructed an iterative algorithm —known as the Gale-Shapley algorithm, G-S algorithm or deferred-acceptance algorithm— to compute a particular stable matching of an SMP instance.",
      "startOffset" : 44,
      "endOffset" : 67
    }, {
      "referenceID" : 9,
      "context" : "This point, when everyone has a partner, is always reached after a polynomial number of steps and the corresponding set of marriages is stable (Gale and Shapley 1962).",
      "startOffset" : 143,
      "endOffset" : 166
    }, {
      "referenceID" : 28,
      "context" : "A stable matching for an SMI instance always exists and can be found in polynomial time (Roth and Sotomayor 1990) by a slightly modified G-S algorithm.",
      "startOffset" : 88,
      "endOffset" : 113
    }, {
      "referenceID" : 14,
      "context" : "For this variant (SMTI) there are several ways to define stability, but we will use the notion of weak stability (Irving 1994).",
      "startOffset" : 113,
      "endOffset" : 126
    }, {
      "referenceID" : 18,
      "context" : "A weakly stable matching always exists for an instance of the SMTI and it can be found in polynomial time by arbitrarily breaking the ties (Iwama and Miyazaki 2008).",
      "startOffset" : 139,
      "endOffset" : 164
    }, {
      "referenceID" : 3,
      "context" : "Answer set programming or ASP is a form of declarative programming (Brewka et al. 2011).",
      "startOffset" : 67,
      "endOffset" : 87
    }, {
      "referenceID" : 3,
      "context" : "(Brewka et al. 2011) for a good overview).",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 12,
      "context" : "no strict subset of I is a model of P (Gelfond and Lifschitz 1988).",
      "startOffset" : 38,
      "endOffset" : 66
    }, {
      "referenceID" : 8,
      "context" : "com), due to its ability to handle predicates, disjunction and numeric values, with built-in aggregate functions (Faber et al. 2008).",
      "startOffset" : 113,
      "endOffset" : 132
    }, {
      "referenceID" : 24,
      "context" : "For instance, in (Marek et al. 1990) a specific variant of the SMP is mentioned (in which boys each know a subset of a set of girls and want to be matched to a girl they know) and in (Dung 1995) an abductive program is used to find a stable matching of marriages in which two fixed persons are paired, with strict, complete preference lists.",
      "startOffset" : 17,
      "endOffset" : 36
    }, {
      "referenceID" : 5,
      "context" : "1990) a specific variant of the SMP is mentioned (in which boys each know a subset of a set of girls and want to be matched to a girl they know) and in (Dung 1995) an abductive program is used to find a stable matching of marriages in which two fixed persons are paired, with strict, complete preference lists.",
      "startOffset" : 152,
      "endOffset" : 163
    }, {
      "referenceID" : 9,
      "context" : "In particular, the generality of our ASP framework for weakly stable matchings of SMTI instances allows to easily adjust the encoding to variants of the SMP, such as the stable roommate problem (Gale and Shapley 1962), in which matches need to be found within one group instead of between two groups, or the three-dimensional stable matching problem (Ng and Hirschberg 1991), which matches triples between three groups instead of pairs between two.",
      "startOffset" : 194,
      "endOffset" : 217
    }, {
      "referenceID" : 26,
      "context" : "In particular, the generality of our ASP framework for weakly stable matchings of SMTI instances allows to easily adjust the encoding to variants of the SMP, such as the stable roommate problem (Gale and Shapley 1962), in which matches need to be found within one group instead of between two groups, or the three-dimensional stable matching problem (Ng and Hirschberg 1991), which matches triples between three groups instead of pairs between two.",
      "startOffset" : 350,
      "endOffset" : 374
    }, {
      "referenceID" : 23,
      "context" : "In (Manlove et al. 2002) it is shown that the decision problem ‘is the pair (m,w) stable?’ for a given SMTI instance is an NP-complete problem, even in the absence of unacceptability.",
      "startOffset" : 3,
      "endOffset" : 24
    }, {
      "referenceID" : 1,
      "context" : "brave reasoning), which is known to be an NP-complete problem (Baral 2003).",
      "startOffset" : 62,
      "endOffset" : 74
    }, {
      "referenceID" : 21,
      "context" : "Extending the SMP by adding another dimension to the problem was first proposed in (Knuth 1976).",
      "startOffset" : 83,
      "endOffset" : 95
    }, {
      "referenceID" : 2,
      "context" : "The practical relevance of this problem is pointed out in (Biró and McDermid 2010).",
      "startOffset" : 58,
      "endOffset" : 82
    }, {
      "referenceID" : 26,
      "context" : "Ng and Hirschberg (Ng and Hirschberg 1991) proved that deciding whether a stable matching exists for the three-dimensional problem – in the absence of unacceptability and ties – is an NP-complete problem.",
      "startOffset" : 18,
      "endOffset" : 42
    }, {
      "referenceID" : 28,
      "context" : "The stable matching found by the G-S algorithm is M-optimal (Roth and Sotomayor 1990), i.",
      "startOffset" : 60,
      "endOffset" : 85
    }, {
      "referenceID" : 9,
      "context" : "Exchanging the roles of men and women in the G-S algorithm yields a W-optimal stable matching (Gale and Shapley 1962), optimal from the women’s point of view.",
      "startOffset" : 94,
      "endOffset" : 117
    }, {
      "referenceID" : 29,
      "context" : "In (Xu and Li 2011) the use of an egalitarian stable matching is proposed to optimally match virtual machines (VM) to servers in",
      "startOffset" : 3,
      "endOffset" : 19
    }, {
      "referenceID" : 27,
      "context" : "Examples of practical applications include an efficient kidney exchange program (Roth et al. 2005), which matches donors of incompatible pairs to recipients of other incompatible pairs and vice versa, and the National Resident Matching Program (www.",
      "startOffset" : 80,
      "endOffset" : 98
    }, {
      "referenceID" : 23,
      "context" : "org) (Manlove et al. 2002), which matches healthcare professionals to graduate medical education and advanced training programs.",
      "startOffset" : 5,
      "endOffset" : 26
    }, {
      "referenceID" : 11,
      "context" : "Note that other notions of preferred matchings have been described in the literature, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous maximum (Irving 2003).",
      "startOffset" : 105,
      "endOffset" : 122
    }, {
      "referenceID" : 10,
      "context" : "Note that other notions of preferred matchings have been described in the literature, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous maximum (Irving 2003).",
      "startOffset" : 142,
      "endOffset" : 192
    }, {
      "referenceID" : 28,
      "context" : "Note that other notions of preferred matchings have been described in the literature, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous maximum (Irving 2003).",
      "startOffset" : 142,
      "endOffset" : 192
    }, {
      "referenceID" : 15,
      "context" : "Note that other notions of preferred matchings have been described in the literature, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous maximum (Irving 2003).",
      "startOffset" : 239,
      "endOffset" : 252
    }, {
      "referenceID" : 15,
      "context" : "Note that other notions of preferred matchings have been described in the literature, such as popularity (Gärdenfors 1975), Pareto optimality (Gale and Sotomayor 1985; Roth and Sotomayor 1990) or profile-based notions such as rank-maximum (Irving 2003), greedy maximum and generous maximum (Irving 2003).",
      "startOffset" : 290,
      "endOffset" : 303
    }, {
      "referenceID" : 22,
      "context" : "For more details on these and other optimality criteria, we refer the interested reader to (Manlove 2013) for an overview.",
      "startOffset" : 91,
      "endOffset" : 105
    }, {
      "referenceID" : 6,
      "context" : "In particular, we use the saturation technique (Eiter and Gottlob 1995) to filter non-optimal answer sets.",
      "startOffset" : 47,
      "endOffset" : 71
    }, {
      "referenceID" : 20,
      "context" : "To this end, we use a SAT encoding (Janhunen 2004) of the ASP program in Definition 2 and define a disjunctive naf-free ASP program in Definition 5 which selects particular models of the SAT problem.",
      "startOffset" : 35,
      "endOffset" : 50
    }, {
      "referenceID" : 7,
      "context" : "of literals such that for every i there is a program rule for which li+1 is a positive body literal and li is in the head (Erdem and Lifschitz 2003).",
      "startOffset" : 122,
      "endOffset" : 148
    }, {
      "referenceID" : 7,
      "context" : "Because our program is absolutely tight, we know that every propositional model of the completion will correspond to an answer set of the original program and vice versa (Erdem and Lifschitz 2003).",
      "startOffset" : 170,
      "endOffset" : 196
    }, {
      "referenceID" : 7,
      "context" : "The following lemma follows from the fact that the completion corresponds to the original program (Erdem and Lifschitz 2003).",
      "startOffset" : 98,
      "endOffset" : 124
    }, {
      "referenceID" : 8,
      "context" : "Note that #sum, #max, #int and #count are DLV aggregate functions (Faber et al. 2008).",
      "startOffset" : 66,
      "endOffset" : 85
    } ],
    "year" : 2015,
    "abstractText" : "Since the introduction of the stable marriage problem (SMP) by Gale and Shapley (1962), several variants and extensions have been investigated. While this variety is useful to widen the application potential, each variant requires a new algorithm for finding the stable matchings. To address this issue, we propose an encoding of the SMP using answer set programming (ASP), which can straightforwardly be adapted and extended to suit the needs of specific applications. The use of ASP also means that we can take advantage of highly efficient off-the-shelf solvers. To illustrate the flexibility of our approach, we show how our ASP encoding naturally allows us to select optimal stable matchings, i.e. matchings that are optimal according to some user-specified criterion. To the best of our knowledge, our encoding offers the first exact implementation to find sex-equal, minimum regret, egalitarian or maximum cardinality stable matchings for SMP instances in which individuals may designate unacceptable partners and ties between preferences are allowed.",
    "creator" : "LaTeX with hyperref package"
  }
}