{
  "name" : "1608.06910.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "ANTHONY P. LECLERC" ],
    "emails" : [ "patrick.kahl@navy.mil", "anthony.leclerc@navy.mil", "leclerca@cofc.edu", "tson@cs.nmsu.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Keywords: Epistemic Logic Program Solver, Logic Programming Tools, Epistemic Specifications, Answer Set Programming Extensions, Solver Algorithms"
    }, {
      "heading" : "1 Introduction",
      "text" : "The language of Epistemic Specifications [12,13] was introduced in the early 1990s by Michael Gelfond after observing the need for more powerful introspective reasoning than that offered by answer set programming (ASP) alone, extending ASP with modal operators K (“known”) and M (“may be true”). A program written in this language is called an epistemic logic program (ELP), with semantics defined using the notion of a world view—a collection of sets of literals (belief sets), analogous to the answer sets of an ASP program. A renewed interest in Epistemic Specifications [27,8] in 2011 included a proposed change to the semantics by Gelfond [14] in a preliminary effort to avoid unintended world views. That work was continued by Kahl et al. [19,20] in the hopes of finding a satisfactory semantics with respect to intuition and modeling of problems. Later attempts to improve the semantics were offered by Su et al. [26,9] and more recently by Shen & Eiter [24] to further address unintended world view issues.\nAlong with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang’s algorithm [30], ESmodels by Zhizheng Zhang et al. [25,7,34,33], and most recently ELPS by Balai [2,3].\nIn this paper, we present results of our efforts to implement a new ELP solver that incorporates updated semantics and uses a scalable approach that greatly decreases both the memory and time required for solving harder ELPs compared to other solvers.\nar X\niv :1\n60 8.\n06 91\n0v 2\n[ cs\n.A I]\n1 3\nO ct"
    }, {
      "heading" : "2 Syntax and Semantics",
      "text" : "In general, the syntax and semantics of the language of Epistemic Specifications follow that of ASP with the notable addition of modal operators K and M, plus the new notion of a world view. We assume familiarity with logic programming—ASP in particular. For a good introduction, see any of [6,18,10,15]. For simplicity, the syntax presented does not include certain language features (e.g., aggregates) of the proposed ASP core standard [1], but that does not mean such features should necessarily be considered excluded from the language. As previous authors have done before us, we will use AS(P) to denote the set of all answer sets of an ASP program P."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "An epistemic logic program is a set of rules of the form\n`1 or ... or `k ← g1, ..., gm, not gm+1, ..., not gn.\nwhere k ≥ 0, m ≥ 0, n ≥ m, each `i is a literal (an atom or a classically-negated atom), and each gi is either a literal (often called an objective literal within the context of Epistemic Specifications), or a subjective literal (a literal immediately preceded by K or M). As in ASP, a rule having a literal with a variable term is a shorthand for all ground instantiations of the rule."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "It should be noted that the semantics described below differs somewhat from that of [19,20] as a world view has an additional requirement based on [24].\nDefinition 1. [When a Subjective Literal Is Satisfied] LetW be a non-empty set of consistent sets of ground literals, and ` be a ground literal.\n• K ` is satisfied by W if ∀A ∈W : ` ∈ A. • not K ` is satisfied by W if ∃A ∈W : ` /∈ A. • M` is satisfied by W if ∃A ∈W : ` ∈ A. • not M` is satisfied by W if ∀A ∈W : ` /∈ A.\nWe will use symbol |= to mean satisfies; e.g., W |= K ` means K ` is satisfied by W.\nDefinition 2. [Modal Reduct] LetΠ be a ground epistemic logic program andW be a non-empty set of consistent sets of ground literals. We denote by ΠW the modal reduct of Π with respect to W defined as the ASP program1 obtained from Π by replacing/removing subjective literals and/or deleting associated rules in Π per the following table: subjective literal ϕ if W |= ϕ then... if W 6|= ϕ then...\nK ` replace K ` with ` delete rule containing K ` not K ` remove not K ` replace not K ` with not ` M` remove M` replace M` with not not ` not M` replace not M` with not ` delete rule containing not M`\n1 with nested expressions of the form not not ` as defined in [22]\nDefinition 3. [Epistemic Negations2] Let Π be a ground epistemic logic program and W be a non-empty set of consistent sets of literals. We denote by EP (Π) the set of distinct subjective literals in Π taking the form not K` and M` (called epistemic negations) as follows:\nEP (Π) = { not K` : K` appears in Π } ∪ {M` : M` appears in Π }.\nWe use Φ to denote a subset of EP (Π), and we denote by ΦW the subset of epistemic negations inEP (Π) that are satisfied byW ; i.e., ΦW = { ϕ : ϕ ∈ EP (Π) ∧W |= ϕ }.\nDefinition 4. [World View] Let Π be a ground epistemic logic program and W be a non-empty set of consistent sets of literals. W is a world view of Π if:\n• W= AS(ΠW); and • there is no W ′ such that W ′= AS(ΠW ′) and ΦW ′ ⊃ ΦW .\nNote here the addition of a maximality requirement on ΦW with respect to other guesses (corresponding to other candidate world views) that is not in the semantics of [19,20]. See [24] for discussion concerning the intuition behind the proposed new semantics."
    }, {
      "heading" : "2.3 Discussion and Additional Definitions",
      "text" : "The semantics of an epistemic logic program Π as described herein is equivalent to the semantics described by Shen & Eiter in [24] for Π translated to their syntax. The proof can be found in the appendix.\nAlthough we prefer our syntax to that proposed in [24], we find the definition of an epistemic reduct an excellent tool for describing the new semantics, particularly with the emphasis on our ELP solver. We therefore present the following additional definitions.\nDefinition 5. [Epistemic Reduct, Reduct-verifiable] LetΠ be a ground epistemic logic program, Φ be a subset ofEP (Π), and Ψ=EP (Π)\\Φ. We denote by ΠΦ the epistemic reduct of Π with respect to Φ defined as the ASP program obtained from Π (assuming existence of corresponding W) by considering as\nSATISFIED: the subjective literals in Φ and the complements of the subjective literals in Ψ NOT SATISFIED: the subjective literals in Ψ and the complements of the subjective literals in Φ3\nand taking actions according to the table given for the modal reduct in Definition 2.\nFor given Π, we say that Φ is reduct-verifiable if W=AS(ΠΦ), W 6=∅, and ΦW=Φ.\nDefinition 6. [World View (alternative definition)] Let Π be a ground ELP, Φ⊆EP (Π), and W=AS(ΠΦ). W is a world view of Π if:\n• Φ is reduct-verifiable and • there exists no reduct-verifiable Φ′ ⊆EP (Π) such that Φ′ ⊃ Φ.\n2 introduced by Shen & Eiter in [24] using a different syntax (see the appendix) 3 K ` and not K ` are complements; M ` and not M ` are complements"
    }, {
      "heading" : "3 Algorithms for Computing World Views",
      "text" : "Definitions 5 and 6 show that a world view of a program Π can be computed by guessing a set Φ ⊆ EP (Π) and verifying that Φ is maximal (with respect to ⊆) reductverifiable. As such, we use the term guess to refer to a set of elements from EP (Π) in the descriptions of our algorithms. For completeness of the paper, we include herein the basic algorithm implemented in existing state-of-the-art ELP solvers (Algorithm 1). A pictorial description of Algorithm 1 is given in Figure 1(a). It is easy to see Algorithm 1 is complete if Translation (Step 2) guarantees all world views ofΠ are disjoint subsets (groups) of the answer sets of Π ′. One such translation was proposed in [20].\nAlgorithm 1: Compute World Views – Old Algorithm Input: Π : an epistemic logic program Output: The set Ω = {ω : ω is a world view of Π} 1 Ω ← ∅ 2 Translation: ASP program Π ′ is created from input ELP Π (effecting generation of ΠΦ\nfor all guesses Φ ⊆ EP (Π)). 3 Computation: Π ′ is solved using an ASP solver. 4 Aggregation: Answer sets of Π ′ are grouped according to corresponding Φ. 5 Verification: Each group G is verified (if ΦG = Φ then G is added to Ω). 6 return Ω\nAlthough Algorithm 1 is simple and easy to implement as an add-on to an ASP solver, its main drawback lies in Steps 3 & 4. Specifically, it requires that all answer sets of program Π ′ are computed and then grouped before world views can be identified. This works well for very small programs but can be impractical memory-wise since the number of guesses grows exponentially with the number of subjective literals. In addition, existing implementations of this algorithm do not allow for early termination when the number of world views found reaches a user-specified limit (e.g., 1)."
    }, {
      "heading" : "3.1 New Algorithm",
      "text" : "Our new algorithm improves Algorithm 1 by addressing the memory growth problem. It divides the work into parts instead of computing everything in one call. The basic steps are given in Algorithm 2. A pictorial description of the algorithm is given in Figure 1(b). In the form shown, the algorithm does not address the maximality requirement of the updated semantics. Details of how the values of guesses are added to the program in the Paritition step (Step 4) will be described in the implementation section, where selection of guesses is done systematically via an ordered search with pruning that ensures the maximality requirement is properly addressed. It is easy to see how limiting the number of guesses during the Partition step of Algorithm 2 can alleviate the memory concerns of Algorithm 1; however, as the selection of guesses for each iteration is not specified, the algorithm can be implemented in a variety of ways. The algorithm will thus be further refined in Algorithms 3, 4, and 5.\nAlgorithm 2: Compute World Views – New Algorithm Input: Π : an epistemic logic program Output: The set Ω = {ω : ω is a world view of Π} 1 Ω ← ∅ 2 Translation: ASP program Π ′ is created from input ELP Π (without the inclusion of\nguesses for subjective literals) 3 repeat 4 Partition: Π ′′ is created by adding ASP representation of guesses (Φ values) to Π ′ 5 Computation: Π ′′ is solved using an ASP solver 6 Aggregation: Answer sets of Π ′′ are grouped according to corresponding Φ. 7 Verification: Each group G is verified (if ΦG = Φ then G is added to Ω). 8 until all guesses tried 9 return Ω\nAlgorithm 2 offers advantages over Algorithm 1 by providing a divide-and-conquer search method that is configurable to allow for:\n• efficient use of memory, • parallel processing, and • early termination after a pre-specified number of world views found."
    }, {
      "heading" : "3.2 Instantiations of the New Algorithm: Overview",
      "text" : "The basic idea behind the new algorithm is to follow Definition 6 in computing the world views. To ensure completeness in an efficient manner, guesses need to be selected in a way that facilitates satisfaction of the second condition of the definition. In our approach, guesses are ranked (into levels) in decreasing order by their cardinality. The\ncardinality of a guess, |Φ|, is called the guess size. A guess is filtered out if it is a subset of a prior guess that was found to be reduct-verifiable. Combined with the selection order, this eliminates the possibility of a reduct-verifiable guess being a superset of any guess that is not filtered out. We therefore start with the guess Φ = EP (Π) and work systematically down in order of guess size, filtering out guesses that are subsets of previously found world views. So to determine if a guess yields a world view, we need only compute the answer sets of the epistemic reduct (ΠΦ) and check that Φ is reduct-verifiable. Algorithm 3 implements this idea. In this algorithm, ASP(Φ) denotes the ASP representation of subjective literals that are considered satisfied when creating ΠΦ, and Π ′ is constructed in such a way that the corresponding AS(Π ′′)4= AS(ΠΦ).\nAlgorithm 3: Compute World Views – Level Order, One Guess at a Time Input: Π : an epistemic logic program, nΩ : max number of world views desired Output: The set Ω = {ω : ω is a world view of Π} 1 Ω ← ∅ 2 Π ′ ← result of Step 2 of Algorithm 2 3 foreach subset Φ of EP (Π) in decreasing order of |Φ| do 4 if (∃ω ∈ Ω : Φ ⊂ Φω) then continue // pruning filter 5 construct Π ′′ = Π ′ ∪ ASP(Φ) 6 compute C = AS(Π ′′) // candidate world view 7 if (C 6= ∅) ∧ (ΦC = Φ) then add C to Ω // check if world view 8 if |Ω| = nΩ then break // return if desired # world views found"
    }, {
      "heading" : "9 return Ω",
      "text" : "Note the pruning filter on Line 4 of Algorithm 3 that, combined with the search order, implements the maximality requirement of Definition 6. This filter can be turned off to revert to the semantics of [20]. We refer to this filter later in Algorithms 4 & 5 without explicit pseudocode when we say filtered.\nAlthough Algorithm 3 solves the memory problem, it increases the number of calls to the ASP solver. As such, the algorithm can be inefficient. To address this concern, we implement Algorithm 4 that computes the world views for multiple guesses at the same time. The trade-off is that grouping (the Aggregation step of Algorithm 2) must be performed. Additionally, care needs to be taken to ensure completeness and avoid repetition. We accomplish this by requiring that all guesses in a set have the same guess size, all sets of guesses are pairwise disjoint, and all guesses of the same size are tried (or filtered out) before moving to the next level. This is achieved as follows. We introduce parameter nG representing the (maximum) number of guesses per ASP solver call, and partition each level Lk = {Φ : (Φ ⊆ EP (Π)) ∧ (|Φ| = k)} (for 0 ≤ k ≤ |EP (Π)|) into groups of at most nG guesses. Detail on the implementation is given in the next subsection. Figure 2 shows a visual description of this algorithm.\nFinally, in order to utilize the computing power of modern computers and enhance the performance of the solver, we implement a parallel version of the algorithm. For brevity, we omit parameter nΩ and associated pseudocode for early termination when desired number of world views is found.\n4 modulo certain fresh literals (see Section 3.3)\nAlgorithm 4: Compute World Views – Level Order, Multiple Guesses at a Time Input: Π : an epistemic logic program, nG : #groups per ASP solver call Output: The set Ω = {ω : ω is a world view of Π} 1 Ω ← ∅ 2 Π ′ ← result of Step 2 of Algorithm 2 3 for k ← |EP (Π)| downto 0 do // for each level do . . .\n4 Partition Lk into t = ⌈ |Lk | nG ⌉ groups G1k, . . . , G t k such that |Gik| ≤ nG 5 foreach filtered group Gik of Lk do 6 construct Π ′′ = Π ′ ∪ASP(Gik) 7 compute Gas = AS(Π ′′) 8 foreach associated candidate world view C of Gas do // group 9 if (C 6= ∅) ∧ (ΦC = Φ) then add C to Ω // check if world view\n10 return Ω\nAlgorithm 5: Compute World Views – Parallel Version Input: Π : an epistemic logic program, nG : #groups per ASP solver call, np : #processes Output: The set Ω = {ω : ω is a world view of Π} 1 Ω ← ∅ 2 Π ′ ← result of Step 2 of Algorithm 2 3 for k ← |EP (Π)| downto 0 do // for each level do . . .\n4 Partition Lk into t = ⌈ |Lk | nG ⌉ groups G1k, . . . , G t k such that |Gik| ≤ nG\n5 Mark every group as not considered 6 repeat 7 for i← 1 to np do // for each processor do . . . 8 select a filtered group G from G1k, . . . , G t k that is marked as not considered\n9 mark group G as considered 10 construct Π ′′i = Π\n′ ∪ASP(G) 11 for i← 1 to np do in parallel // solve in parallel 12 compute Gasi = AS(Π ′′ i )\n// accumulate the results of each processor and . . . 13 for i← 1 to np do 14 foreach associated candidate world view C of Gasi do // group 15 if (C 6= ∅)∧ (ΦC = Φ) then add C to Ω // check if world view\n16 until every group is either marked as considered or filtered out\n17 return Ω"
    }, {
      "heading" : "3.3 Implementation Representation",
      "text" : "Let Π be a ground ELP and EP (Π) be its set of epistemic negations. Let IEP be an enumeration of EP (Π) and for each ϕ ∈ EP (Π), let ord(ϕ) be the index of ϕ in IEP . We represent each guess Φ ⊆ EP (Π) with a bitvector of length n = |EP (Π)| as follows: BΦ = [b1, b2, ..., bn] where for i = ord(ϕ), bit bi = 1 iff ϕ ∈ Φ.\nEach bitvector representing a guess can be represented by an integer X such that 0 ≤ X ≤ 2n−1; thus, eachX represents a unique subset ofEP (Π) and vice versa. This one-to-one correspondence is useful in the implementation as it allows for fast checking of the subset relation between guesses (Line 4, Algorithm 3). For later use, we denote by popcount(X) the number of one bits in the binary representation of X .\nAs an example, consider EP (Π) = {not K `1, not K `2, M `3}. Assuming we enumerate the elements of EP (Π) from left to right, the bitvector BΦ = [b1, b2, b3] would be constructed with bit b1 representing the truth value (w.r.t. membership in Φ, where 1=True and 0=False) of not K `1, b2 representing the truth value of not K `2, and b3 representing the truth value of M `3. For example, a bitvector BΦ = [0, 1, 1] would represent Φ = {not K `2, M `3}.\nFor the translation of an ELP Π to an ASP program, we use a variant of the one developed in [20]. For each literal ` in the epistemic negations of EP (Π) of the form not K `, let k `, k0 `, and k1 ` be fresh atoms created by prefixing ` with k , k0 , and k1 (respectively), substituting 2 for ¬ if ` is a classically-negated atom. Likewise, for epistemic negations of the form M ` in EP (Π), let m `, m0 `, m1 ` be fresh atoms\ncreated in like fashion. For example, if `=p(a) then k ` denotes k p(a), but if `=¬p(a) then k ` denotes k 2p(a). An atom denoted by k `, k0 `, or k1 ` will be referred to as a k-atom, whereas an atom denoted by m `, m0 `, or m1 ` will be referred to as an matom. By a k-/m-literal we mean a k-/m-atom or its negation. For a set of sets of literals C, we use the notation C\\km to mean C modulo k-/m-literals (i.e., with k-/m-literals removed from the sets of C).\nIntuitive meanings of the atoms are: k1 ` stands for “K ` is True,” k0 ` stands for “K ` is False,” m1 ` stands for “M ` is True,” and m0 ` stands for “M ` is False.” We can thus view k1 ` as corresponding to K `, k0 ` as corresponding to not K `, etc."
    }, {
      "heading" : "3.4 Implementation Details",
      "text" : "We describe here implementation details for Algorithm 5.\n1. Translation: Given ground ELP Π , we create ASP program Π ′ by (i) leaving rules without subjective literals unchanged; and (ii) for rules containing subjective literals, replacing subjective literals and adding new rules per the following table.\nSUBJECTIVE LITERAL REPLACE WITH\nADD RULES\nK ` not ¬k `, ` ¬k ` ← k0 `. not K ` ¬k ` ¬k ` ← k1 `, not `.\nM ` m ` m `← m1 `. not M ` not m ` m `← m0 `, not not `.\nWe note that this translation is slightly different from the translation in [20] in that it does not add the rules for guessing the values of elements in EP (Π). On the other hand, it implies that if equivalent rules for guessing the values of elements inEP (Π) are added to Π ′ then correctness of the algorithm is maintained. This property is guaranteed by the partitioning step of the algorithm.\n2. Partition: The algorithm employs a bitvector representation for guesses in partitioning the search space. The partitioning of a level, Lk, occurs on Line 4 of the\nalgorithm. Each group of bitvectors, G1k, . . . , G t k for t = ⌈ |Lk | nG ⌉ , is produced “on\ndemand” with group size at most nG, and G1k containing the first nG elements of Lk, G 2 k containing the next nG elements of Lk, etc. Partitioning is accomplished using a generating function “seeded” with an appropriate bitvector of length n with k one bits. Each subsequent call to the generating function produces the “next” bitvector of length n with k one bits. Thus, storage is required only for representing groups of guesses currently under consideration. 3. Π ′′ = Π ′ ∪ ASP(G), where G is a set of bitvectors, is implemented as Π ′ ∪ ASP({XB : (B ∈ G) ∧ (XB is the integer whose binary representation isB)}). 4. Aggregation: Answer sets of Π ′′ are grouped by common k-/m-atoms of the form k0 `, k1 `, m0 `, and m1 `, each group representing a candidate world view. It is easy to see that a group’s k-/m-atoms correspond to a guess ΦX for some X ∈ G.\n5. Verification: For each group C representing a candidate world view, check that the following conditions are met for all its k-/m-atoms:\n(a) if k1 ` is in the sets of C, then ` is in every set of C; (b) if k0 ` is in the sets of C, then ` is missing from at least one set of C; (c) if m1 ` is in the sets of C, then ` is in at least one set of C; and (d) if m0 ` is in the sets of C, then ` is missing from every set of C.\nC\\km is a world view of Π if the conditions above are met."
    }, {
      "heading" : "3.5 Correctness of Algorithm",
      "text" : "The correctness of the algorithm follows from the proofs for soundness and completeness given in [20] when one considers that we are simply partitioning the search space into groups of manageable size (rather than generating all possible combinations of subjective literal truth values en masse) and imposing a popcount-level search order. It is easy to see that the maximality requirement of the new semantics is guaranteed by the level-based search order and filtering by considering that: • if a set of answer sets C corresponding to ΦC is found that satisfies the verification\nconditions of Step 5, then the ordered search and the filtering out of any corresponding Φ ⊂ ΦC ensures that no previous world view W was found corresponding to ΦW such that ΦW ⊃ ΦC ; and • if a set of answer sets C corresponding to ΦC is found to be a world view, then any set C ′ corresponding to ΦC′ where ΦC′ ⊂ ΦC will be filtered out thereafter."
    }, {
      "heading" : "4 Test Results",
      "text" : "We tested an implementation of our algorithm on a DellTM PrecisionTM T3500 server with an Intel R© Xeon R©W3670@3.2GHz with 6 cores and 12 GB RAM running CentOS v6.7 operating system. For the front-end, we used the ELPS solver by Balai [2] to convert an ELPS program (see [3]) to an associated ASP program, grounding it with ASP grounder gringo by Kaminski [23] in order to obtain what would be the result of Step 2 of our algorithm for a corresponding ground ELP from the ungrounded ELPS program. We then took the resulting ground ASP program as input to our solver, ELPsolve—a loosely-coupled system that uses ASP solver clingo by Kaminski & Kaufmann [23].\nThis method allowed us to directly compare our solver performance with that of ELPS for the same input programs. The following table shows our results, giving the best run time (elapsed time in seconds) observed over the course of testing. A dash (–) in the ELPS column indicates that a runtime error occurred due to insufficient memory.\nΠ |EP (Π)| ELPS ELPsolve Π |EP (Π)| ELPS ELPsolve eligible01 2 <1s <1s yale1 5 <1s <1s eligible06 12 1s <1s yale2 8 <1s <1s eligible08 16 16s 1s yale3 11 <1s <1s eligible09 18 150s 2s yale4 14 <1s <1s eligible10 20 – 4s yale5 17 13s <1s eligible12 24 – 119s yale6 26 – <1s eligible14 28 – 1667s yale7 30 – 2s eligible16 32 – 16124s yale8 34 – 76s\nThe eligibleN programs are ELPS implementations of the scholarship eligibility problem (see [12]) with N corresponding to the number of students. The yaleN programs are ELPS implementations of a version of the Yale shooting problem (see [17]) that use the epistemic conformant planning module defined in [20] with N corresponding to the horizon (number of steps in a plan). For the yaleN programs, ELPsolve incorporates two heuristics found during analysis of the conformant planning module:\n1. reduction of the search space size by a factor of 4 by recognizing that two specific subjective literals must be satisfied in a world view;5 and 2. the horizon corresponds to a particular level (guess size) for searching.\nFigure 3 shows how run times for solving eligible12 with ELPsolve improve with an increase in the number of processors used. Note that although the 6-core Xeon processor in our test machine is hyperthread-enabled, it is unlikely that there would be any significant speed-up by simply increasing the number of processors assigned to multi-task beyond 6 as our implementation uses 2-thread multi-threading for each task.\nFigure 4 shows the peak memory usage for ELPS and ELPsolve (max #guesses per ASP call set at 300 for both 1 and 6 processors) when solving various eligibleN programs. Note the blue line curving sharply upward for ELPS asN grows whereas the memory required for ELPsolve remains relatively low and flat.\n5 This heuristic is generalizable, though a thorough discussion will be left for a future paper."
    }, {
      "heading" : "5 Related Work",
      "text" : "In [30], Yan Zhang investigated computational properties of epistemic logic programs, leading to the development of an algorithm for computing world views. Michael Kelly implemented the algorithm as solver Wviews [28], a project for his Honours Thesis.\nCui, Zhizheng Zhang and Zhao [7] investigated the problem of grounding an epistemic logic program. That work culminated in the development of a grounder known as ESParser. Their more recent efforts [34,33] include the development of an associated solver called ESmodels [25]. See [20] for a comparison of solver performance between ESmodels and ELPS.\nBalai and Kahl [3] extended Epistemic Specifications by adding a sorted signature. A modification of the algorithm in [20,19] was implemented by Balai to develop solver ELPS [2]. Our solver complements this work by addressing the memory growth problem and updating it for the new semantics.\nZhizheng Zhang and Shutao Zhang [32] investigated combining ideas from Graded Modal Logic with ASP. Their langauge can be viewed as an extension of Epistemic Specifications, adding the modal concepts “at least as many as” and “at most as many as” to the language. They continued this work with Wang [31], referring to the language as GI-log. A GI-log solver called GIsolver [25] was developed using a generate-andtest algorithm similar (at a high level) to the one described in Algorithm 1.\nShen and Eiter [24] proposed the updated semantics used in this paper and implemented in our solver, albeit using different syntactic notation. Their work resolved most of the open questions raised in [19] and provided inspiration for our algorithm."
    }, {
      "heading" : "6 Conclusions and Future Work",
      "text" : "We improved the algorithm and developed a solver for epistemic logic programs that:\n• incorporates the latest semantics (as proposed by Shen & Eiter [24]), • addresses the memory issues that plague some other implementations, • uses multi-processing to improve performance, • allows early termination when desired number of solutions found, • solves harder programs faster, and • permits solving programs on a typical laptop computer that were previously beyond\nthe capabilities of other solvers with reasonable resources.\nFor the future, we plan to enhance our solver further by allowing the use of distributed processing to make it reasonable to solve more programs. We also plan to look at generalizing certain heuristics that could significantly reduce the search space for certain classes of programs. Finally, we plan to look at techniques such as multi-shot solving [11] to avoid the need for repeatedly restarting the ASP solver from scratch.\nWe observe that with small modification our implementation could solve GI-log programs [31], though a suitable front end is needed to handle the program syntax.\nFollow-up work will be to explore applications for the language as solver improvements make its use more practical. Promising areas include planning & scheduling, policy management, diagnostics, and computer-assisted decision making."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We would like to acknowledge the efforts of Yi-Dong Shen and Thomas Eiter whose work provided a positive influence on the development of our solver. We thank Evgenii Balai for providing the front end to our solver by adding an extra option to ELPS to output the ASP translation. We couldn’t produce our results without the use of gringo & clingo from the Potassco team, especially Roland Kaminski and Ben Kaufmann. Finally, we thank the anonymous reviewers for their comments and suggestions."
    }, {
      "heading" : "Appendix: Proof of Semantic Equivalence to Shen-Eiter Semantics",
      "text" : "In this appendix, we prove the equivalence between the semantics of epistemic logic programs (Section 2) and the semantics of logic programs with epistemic negation as defined by Shen & Eiter in [24].\nFor the benefit of the reader, the following table summarizes the notational differences between our language and that of Shen & Eiter for semantically equivalent forms.\nOUR NOTATION SE NOTATION TERMINOLOGY ¬ ∼ classical (strong) negation not ¬ default negation not K not epistemic negation\nK ¬ not M not ¬\nnot M ¬ not ¬\nLet Π be a ground epistemic logic program. Let r be a rule in Π . In this appendix, we use the following short hand to represent r:\nH ← B+, not B−, K L1, not K L2, M L3, not M L4 (1)\nwhereH is h1 or . . . or hn andB+,B−, L1, ..., L4 are sets of objective literals. For L = {`1, ..., `m}, xL stands for {x`1, ..., x`m}with x ∈ {not,K,not K,M,not M}. In Shen-Eiter notation [24], the above rule will become the following:\nH ← B+, ¬B−, ¬ not L1, not L2, not ¬L3, ¬ not ¬L4 (2)\nWe denote by SE(x) the corresponding syntactic form of x in Shen-Eiter notation; e.g., SE(Π) denotes the program obtained by translating Π to Shen-Eiter notation. We further define EP (SE(Π)) as being equivalent to SE(EP (Π)) (see Definition 3). When clear from the context, we may use ΦW to mean SE(ΦW), r to mean SE(r), etc.\nIn proving the correspondence between the two semantics, we make the following assumptions and notes:\n• The presence of classical negation can be eliminated using standard transformation (e.g., the one proposed in [16]). For this reason, we will assume that programs in consideration do not contain classical negation. • Shen-Eiter programs allow not ¬` (not K not ` in our notation) which we con-\nsider equivalent to M ` in our syntax. • In Shen-Eiter programs, ¬¬` (not not ` in our notation) is treated as `.\nWe use “X-reduct” where X is “KLS” (to refer to the modal reduct discussed in this paper) or “SE” (to refer to the epistemic reduct proposed by Shen & Eiter in [24]). For ASP programs with nested default negation, a “nested-negation removal transformation” refers to the usual substitution of not not ` with not `′ plus the addition of rule `′ ← not ` where `′ is a fresh literal and answer sets are modulo `′ as described in [22]. We use “Gelfond-Lifschitz transformation” to refer to the reduction from logic programs with default negation to positive programs as per [16]. We say that a rule whose body contains a conjunct of the form ¬> in Shen-Eiter notation is a useless rule as this rule is always satisfied (body is false) and cannot be used to justify anything.\nIn the following, whenever we refer to a rule r, we mean a rule with sets of atoms L1, . . . , L4 as in (1). We use Π to denote an arbitrary but fixed ground epistemic logic program. Furthermore, for a program Π, a set of sets of atoms W, a set A ∈ W, and a rule r ∈ Π, by the reduct of r in (ΠW )A (resp. reduct of SE(r) in (SE(Π)ΦW )A) we mean the rule (if it exists) obtained from r after:\n1. computing the modal reduct ofΠ with respect toW according to Definition 2 (resp. the epistemic reduct of SE(Π) with respect to ΦW as per [24]); and then 2. computing the Gelfond-Lifschitz transformation on the result with respect to A.\nLemma 1. Let r be a rule inΠ ,W be a collection of sets of atoms inΠ , andA ∈W. If there exists some ` ∈ L1 of r such that W 6|= K ` then there is no reduct of r in (ΠW )A and either there is no reduct of r in (SE(Π)ΦW )A or the reduct of r is a useless rule.\nProof. W 6|= K ` implies that r is removed in the KLS-reduct and hence (ΠW )A does not contain the reduct of r.\nW 6|= K ` means that W |= not K `. This means that not ` ∈ ΦW . Thus, the SEreduct of r in SE(Π) is a rule whose body contains ¬>, a useless rule. This implies that (SE(Π)ΦW )A contains no reduct of r if the Gelfond-Lifschitz transformation removes it; or a useless rule, which is the reduct of r.\nLemma 2. Let r be a rule inΠ,W be a collection of sets of atoms inΠ, andA ∈W. If there exists some ` ∈ L2∩A such thatW 6|= not K`, then (ΠW )A and (SE(Π)ΦW )A contain no reduct of r.\nProof. W 6|= not K ` implies that there exists some S ∈ W such that ` 6∈ S. This implies that W 6|= not ` and so not ` 6∈ ΦW .\nLet r′ and r′′ be the result obtained by applying the KLS-reduct and the SE-reduct on r, respectively. We have r′ ∈ ΠW and r′′ ∈ SE(Π)ΦW .\nSinceW 6|= not K`, not ` occurs in the body of r′. Because ` ∈ A, the GelfondLifschitz transformation will remove the rule r′ from ΠW when constructing (ΠW )A, i.e., (ΠW )A does not contain the reduct of r.\nSimilarly, since not ` 6∈ ΦW , ¬` occurs in the body of r′′ in SE(Π), and ` ∈ A, the Gelfond-Lifschitz transformation will remove the rule r′′ when constructing (SE(Π)ΦW )A, i.e., (SE(Π)ΦW )A does not contain the reduct of r.\nSo, in this case, neither (ΠW )A nor (SE(Π)ΦW )A contains the reduct of r.\nLemma 3. Let r be a rule inΠ ,W be a collection of sets of atoms inΠ andA ∈W . If there exists some ` ∈ L3 such that W 6|= M ` then (ΠW )A and (SE(Π)ΦW )A contain no reduct of r or a useless reduct of r with respect to A.\nProof. W 6|= M ` implies that there exists no S ∈ W such that ` ∈ S, i.e., for every S ∈W , ` 6∈ S. This implies that W 6|= not ¬` and so not ¬` 6∈ ΦW . This also implies that ` 6∈ A.\nIn this case, we observe that not not ` occurs in the body of the KLS-reduct r′ of r in ΠW and ¬¬` occurs in the body of the SE-reduct r′′ of r in SE(Π)ΦW. Shen & Eiter treat ¬¬` as `. Since ` 6∈ A, (SE(Π)ΦW )A will contain no reduct of r (if it is removed by the Gelfond-Lifschitz reduct) or a useless rule with respect to A.\nIn KLS, nested default negation is treated differently. The nested-negation removal transformation results in not not ` appearing in the body of r′. Furthermore, ΠW contains the rule “not `← not `” where not ` is a fresh atom representing not `. LetΠn be the programs obtained fromΠW after the nested-negation removal transformation. Because ` 6∈ A, any answer set A′ of Πn whose reduction results into A must contain not `. This implies that the Gelfond-Lifschitz transformation will remove r′ from Πn when constructing (ΠW )A.\nSo, in this case, (ΠW )A does not contain the reduct of r and (SE(Π)ΦW )A contain no reduct of r or a useless reduct of r with respect to A.\nLemma 4. Let r be a rule in Π , W be a collection of sets of atoms in Π and A ∈ W . If there exists some ` ∈ L4 such that W 6|= not M ` then (ΠW )A contains no reduct of r and (SE(Π)ΦW )A contains no reduct of r or a useless reduct of r.\nProof. W 6|= not M ` implies that r is removed in the KLS-reduct and hence (ΠW )A does not contain the reduct of r.\nW 6|= not M ` implies that there exists some S ∈ W such that ` ∈ S. It means that W 6|= K not ` and hence not ¬` ∈ ΦW . Thus, the SE-reduct of r in SE(Π)ΦW is a rule whose body contains ¬>. Again, this means that (SE(Π)ΦW )A contains no reduct of r or a useless rule which is the reduct of r.\nTheorem 1. LetW be a collection of sets of atoms inΠ .W is a world view ofΠ under the KLS semantics if and only if W is a candidate world view of SE(Π) w.r.t. ΦW .\nProof. Observe that for each not ` occurring in SE(Π), it holds that\n• if not ` ∈ ΦW then not ` is true in W ; or • if not ` ∈ EP (SE(Π)) \\ ΦW then not ` is false in W .\nLet Lt2 = {` | ` ∈ L2∧W |= not K `} and L f 2 = {` | ` ∈ L2∧W 6|= not K `}. Let Lt3 = {` | ` ∈ L3 ∧ W |= M `} and L f 3 = {` | ` ∈ L3 ∧ W 6|= M `}. Consider A ∈ W and let r be a rule of the form (1). Lemmas 1-4 show that if (ΠW )A or (SE(Π)ΦW )A contains a useful reduct of r then the following conditions hold:\n• L1 ⊆ A (Lemma 1). • for every ` ∈ Lf2 , ` 6∈ A (Lemma 2). • Lf3 = ∅ (Lemma 3). • L4 ∩A = ∅ (Lemma 4). • B− ∩ A = ∅ (otherwise, the rule will be removed by the Gelfond-Liftschitz\ntransformation).\nUnder the above conditions, the reduct of r in ΠW is\nr′ : H ← B+, not B−, L1, not Lf2 , not L4\nand its reduct in (SE(Π))ΦW is\nr′′ : H ← B+, not B−,¬¬L1,¬Lf2 ,¬¬¬L4\nSince ¬¬L = L as stated in Shen & Eiter’s proposal and because L4 ∩ A = ∅ and Lf2 ∩A = ∅, we can conclude that the reduct of r in (ΠW )A and in (SE(Π)ΦW )A is\nr+ : `1 or `2 . . . or `n ← B+, L1\nIn other words, we have that (ΠW )A is identical6 to (SE(Π)ΦW )A. As such, if W is a world view of Π , A is an answer set of (ΠW )A, i.e., A is also an answer set of (SE(Π)ΦW )A. Conversely, if W is a candidate world view of Π with respect to ΦW then A is an answer set of (SE(Π)ΦW )A and hence also an answer set of (ΠW )A. Since this holds for every A ∈W , we have the conclusion of the theorem.\n6 with the exception of the useless rules in different programs and some extra fresh atoms such as not a representing not a and the rule not a ← not a introduced to deal with not not a; such atoms can be eliminated by using the splitting set theorem and the fact that, by construction, not not a appears in ΠW only if a 6∈ A"
    } ],
    "references" : [ {
      "title" : "Texas Tech University, software & documentation available for download at https://github.com/iensen/elps/wiki",
      "author" : [ "E. Balai" ],
      "venue" : "ELPS",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2015
    }, {
      "title" : "Epistemic logic programs with sorts",
      "author" : [ "E. Balai", "P. Kahl" ],
      "venue" : "Inclezan, D., Maratea, M. (eds.) ASPOCP 2014",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "sismodels (2001), see http://www.mbal.tk/ for more information",
      "author" : [ "M. Balduccini" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2001
    }, {
      "title" : "Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning—Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday, Lecture Notes in Computer Science, vol",
      "author" : [ "M. Balduccini", "Son", "T.C. (eds." ],
      "venue" : "6565. Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Knowledge Representation, Reasoning, and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "ESParser: An epistemic specification grounder",
      "author" : [ "R. Cui", "Z. Zhang", "K. Zhao" ],
      "venue" : "Delgrande, J.P., Faber, W. (eds.) CSSS-12. pp. 1823–1827. IEEE Computer Society CPS",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Epistemic equilibrium logic",
      "author" : [ "L. Fariñas del Cerro", "A. Herzig", "E.I. Su" ],
      "venue" : "Yang, Q., Wooldridge, M. (eds.) IJCAI 2015. AAAI Press / IJCAI",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Answer Set Solving in Practice",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Synthesis Lectures on Artificial Intelligence and Machine Learning, Morgan & Claypool Publishers",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Clingo = ASP + control: Preliminary report",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Kowalski, R.A., Bowen, K.A. (eds.) ICLP 2014. vol. abs/1405.3694. The MIT Press",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Strong introspection",
      "author" : [ "M. Gelfond" ],
      "venue" : "Dean, T.L., McKeown, K. (eds.) AAAI-91. vol. 1, pp. 386–391. AAAI Press / The MIT Press",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Logic programming and reasoning with incomplete information",
      "author" : [ "M. Gelfond" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 12(1–2), 89–116",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "New definition of epistemic specifications",
      "author" : [ "M. Gelfond" ],
      "venue" : "Delgrande, J.P., Faber, W. (eds.) LPNMR-11. Lecture Notes in Computer Science, vol. 6645, pp. 260–265. Springer",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Knowledge Representation, Reasoning, and the Design of Intelligent Agents: The Answer-Set Programming Approach",
      "author" : [ "M. Gelfond", "Y. Kahl" ],
      "venue" : "Cambridge University Press",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9(3/4), 365–385",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Nonmonotonic logic and temporal projection",
      "author" : [ "S. Hanks", "D. McDermott" ],
      "venue" : "Artificial Intelligence 33(3), 379–412",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Handbook of Knowledge Representation",
      "author" : [ "F. van Harmelen", "V. Lifschitz", "Porter", "B. (eds." ],
      "venue" : "Foundations of Artificial Intelligence, Elsevier",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Refining the Semantics for Epistemic Logic Programs",
      "author" : [ "P. Kahl" ],
      "venue" : "Ph.D. thesis, Texas Tech University, Lubbock, TX, USA",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "The language of epistemic specifications (refined) including a prototype solver",
      "author" : [ "P. Kahl", "R. Watson", "E. Balai", "M. Gelfond", "Y. Zhang" ],
      "venue" : "Journal of Logic and Computation",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Wviews: A Worldview Solver for Epistemic Logic Programs",
      "author" : [ "M. Kelly" ],
      "venue" : "Honour’s thesis, University of Western Sydney",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Nested expressions in logic programs",
      "author" : [ "V. Lifschitz", "L.R. Tang", "H. Turner" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 369–389",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Evaluating epistemic negation in answer set programming",
      "author" : [ "Y.D. Shen", "T. Eiter" ],
      "venue" : "Artificial Intelligence 237, 115–135",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Extensions of Equilibrium Logic by Modal Concepts",
      "author" : [ "E.I. Su" ],
      "venue" : "Ph.D. thesis, University of Toulouse, Toulouse, France",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "An Inference Engine for Epistemic Specifications",
      "author" : [ "R.G. Watson" ],
      "venue" : "Master’s thesis, University of Texas at El Paso",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Computational properties of epistemic logic programs",
      "author" : [ "Y. Zhang" ],
      "venue" : "Doherty, P., Mylopoulos, J., Welty, C.A. (eds.) KR-06. pp. 308–317. AAAI Press",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Logic programming with graded introspection",
      "author" : [ "Z. Zhang", "B. Wang", "S. Zhang" ],
      "venue" : "Inclezan, D., Maratea, M. (eds.) ASPOCP 2015",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Logic programming with graded modality",
      "author" : [ "Z. Zhang", "S. Zhang" ],
      "venue" : "Calimeri, F., Ianni, G., Truszczyński, M. (eds.) LPNMR 2015. Lecture Notes in Artificial Intelligence, vol. 9345. Springer-Verlag",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "ESmodels: An epistemic specification solver",
      "author" : [ "Z. Zhang", "K. Zhao" ],
      "venue" : "CoRR abs/1405.3486",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "ESmodels: An inference engine of epistemic specifications",
      "author" : [ "Z. Zhang", "K. Zhao", "R. Cui" ],
      "venue" : "Luo, J. (ed.) ICTAI 2013. pp. 769–774. IEEE",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "The language of Epistemic Specifications [12,13] was introduced in the early 1990s by Michael Gelfond after observing the need for more powerful introspective reasoning than that offered by answer set programming (ASP) alone, extending ASP with modal operators K (“known”) and M (“may be true”).",
      "startOffset" : 41,
      "endOffset" : 48
    }, {
      "referenceID" : 10,
      "context" : "The language of Epistemic Specifications [12,13] was introduced in the early 1990s by Michael Gelfond after observing the need for more powerful introspective reasoning than that offered by answer set programming (ASP) alone, extending ASP with modal operators K (“known”) and M (“may be true”).",
      "startOffset" : 41,
      "endOffset" : 48
    }, {
      "referenceID" : 11,
      "context" : "A renewed interest in Epistemic Specifications [27,8] in 2011 included a proposed change to the semantics by Gelfond [14] in a preliminary effort to avoid unintended world views.",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 16,
      "context" : "[19,20] in the hopes of finding a satisfactory semantics with respect to intuition and modeling of problems.",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 17,
      "context" : "[19,20] in the hopes of finding a satisfactory semantics with respect to intuition and modeling of problems.",
      "startOffset" : 0,
      "endOffset" : 7
    }, {
      "referenceID" : 21,
      "context" : "[26,9] and more recently by Shen & Eiter [24] to further address unintended world view issues.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 6,
      "context" : "[26,9] and more recently by Shen & Eiter [24] to further address unintended world view issues.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 20,
      "context" : "[26,9] and more recently by Shen & Eiter [24] to further address unintended world view issues.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 22,
      "context" : "Along with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang’s algorithm [30], ESmodels by Zhizheng Zhang et al.",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 2,
      "context" : "Along with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang’s algorithm [30], ESmodels by Zhizheng Zhang et al.",
      "startOffset" : 159,
      "endOffset" : 162
    }, {
      "referenceID" : 18,
      "context" : "Along with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang’s algorithm [30], ESmodels by Zhizheng Zhang et al.",
      "startOffset" : 180,
      "endOffset" : 187
    }, {
      "referenceID" : 23,
      "context" : "Along with maturation of the language were various attempts at developing a solver or inference engine, including ELMO by Watson [29], sismodels by Balduccini [4], Wviews by Kelly [28,21] implementing Yan Zhang’s algorithm [30], ESmodels by Zhizheng Zhang et al.",
      "startOffset" : 223,
      "endOffset" : 227
    }, {
      "referenceID" : 5,
      "context" : "[25,7,34,33], and most recently ELPS by Balai [2,3].",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 27,
      "context" : "[25,7,34,33], and most recently ELPS by Balai [2,3].",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 26,
      "context" : "[25,7,34,33], and most recently ELPS by Balai [2,3].",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 0,
      "context" : "[25,7,34,33], and most recently ELPS by Balai [2,3].",
      "startOffset" : 46,
      "endOffset" : 51
    }, {
      "referenceID" : 1,
      "context" : "[25,7,34,33], and most recently ELPS by Balai [2,3].",
      "startOffset" : 46,
      "endOffset" : 51
    }, {
      "referenceID" : 4,
      "context" : "For a good introduction, see any of [6,18,10,15].",
      "startOffset" : 36,
      "endOffset" : 48
    }, {
      "referenceID" : 15,
      "context" : "For a good introduction, see any of [6,18,10,15].",
      "startOffset" : 36,
      "endOffset" : 48
    }, {
      "referenceID" : 7,
      "context" : "For a good introduction, see any of [6,18,10,15].",
      "startOffset" : 36,
      "endOffset" : 48
    }, {
      "referenceID" : 12,
      "context" : "For a good introduction, see any of [6,18,10,15].",
      "startOffset" : 36,
      "endOffset" : 48
    }, {
      "referenceID" : 16,
      "context" : "It should be noted that the semantics described below differs somewhat from that of [19,20] as a world view has an additional requirement based on [24].",
      "startOffset" : 84,
      "endOffset" : 91
    }, {
      "referenceID" : 17,
      "context" : "It should be noted that the semantics described below differs somewhat from that of [19,20] as a world view has an additional requirement based on [24].",
      "startOffset" : 84,
      "endOffset" : 91
    }, {
      "referenceID" : 20,
      "context" : "It should be noted that the semantics described below differs somewhat from that of [19,20] as a world view has an additional requirement based on [24].",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 19,
      "context" : "1 with nested expressions of the form not not ` as defined in [22]",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 16,
      "context" : "Note here the addition of a maximality requirement on ΦW with respect to other guesses (corresponding to other candidate world views) that is not in the semantics of [19,20].",
      "startOffset" : 166,
      "endOffset" : 173
    }, {
      "referenceID" : 17,
      "context" : "Note here the addition of a maximality requirement on ΦW with respect to other guesses (corresponding to other candidate world views) that is not in the semantics of [19,20].",
      "startOffset" : 166,
      "endOffset" : 173
    }, {
      "referenceID" : 20,
      "context" : "See [24] for discussion concerning the intuition behind the proposed new semantics.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 20,
      "context" : "The semantics of an epistemic logic program Π as described herein is equivalent to the semantics described by Shen & Eiter in [24] for Π translated to their syntax.",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 20,
      "context" : "Although we prefer our syntax to that proposed in [24], we find the definition of an epistemic reduct an excellent tool for describing the new semantics, particularly with the emphasis on our ELP solver.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 20,
      "context" : "2 introduced by Shen & Eiter in [24] using a different syntax (see the appendix) 3 K ` and not K ` are complements; M ` and not M ` are complements",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 17,
      "context" : "One such translation was proposed in [20].",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 17,
      "context" : "This filter can be turned off to revert to the semantics of [20].",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 17,
      "context" : "For the translation of an ELP Π to an ASP program, we use a variant of the one developed in [20].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 17,
      "context" : "We note that this translation is slightly different from the translation in [20] in that it does not add the rules for guessing the values of elements in EP (Π).",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 17,
      "context" : "The correctness of the algorithm follows from the proofs for soundness and completeness given in [20] when one considers that we are simply partitioning the search space into groups of manageable size (rather than generating all possible combinations of subjective literal truth values en masse) and imposing a popcount-level search order.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 0,
      "context" : "For the front-end, we used the ELPS solver by Balai [2] to convert an ELPS program (see [3]) to an associated ASP program, grounding it with ASP grounder gringo by Kaminski [23] in order to obtain what would be the result of Step 2 of our algorithm for a corresponding ground ELP from the ungrounded ELPS program.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 1,
      "context" : "For the front-end, we used the ELPS solver by Balai [2] to convert an ELPS program (see [3]) to an associated ASP program, grounding it with ASP grounder gringo by Kaminski [23] in order to obtain what would be the result of Step 2 of our algorithm for a corresponding ground ELP from the ungrounded ELPS program.",
      "startOffset" : 88,
      "endOffset" : 91
    }, {
      "referenceID" : 9,
      "context" : "The eligibleN programs are ELPS implementations of the scholarship eligibility problem (see [12]) with N corresponding to the number of students.",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 14,
      "context" : "The yaleN programs are ELPS implementations of a version of the Yale shooting problem (see [17]) that use the epistemic conformant planning module defined in [20] with N corresponding to the horizon (number of steps in a plan).",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 17,
      "context" : "The yaleN programs are ELPS implementations of a version of the Yale shooting problem (see [17]) that use the epistemic conformant planning module defined in [20] with N corresponding to the horizon (number of steps in a plan).",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 23,
      "context" : "In [30], Yan Zhang investigated computational properties of epistemic logic programs, leading to the development of an algorithm for computing world views.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 5,
      "context" : "Cui, Zhizheng Zhang and Zhao [7] investigated the problem of grounding an epistemic logic program.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 27,
      "context" : "Their more recent efforts [34,33] include the development of an associated solver called ESmodels [25].",
      "startOffset" : 26,
      "endOffset" : 33
    }, {
      "referenceID" : 26,
      "context" : "Their more recent efforts [34,33] include the development of an associated solver called ESmodels [25].",
      "startOffset" : 26,
      "endOffset" : 33
    }, {
      "referenceID" : 17,
      "context" : "See [20] for a comparison of solver performance between ESmodels and ELPS.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 1,
      "context" : "Balai and Kahl [3] extended Epistemic Specifications by adding a sorted signature.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 17,
      "context" : "A modification of the algorithm in [20,19] was implemented by Balai to develop solver ELPS [2].",
      "startOffset" : 35,
      "endOffset" : 42
    }, {
      "referenceID" : 16,
      "context" : "A modification of the algorithm in [20,19] was implemented by Balai to develop solver ELPS [2].",
      "startOffset" : 35,
      "endOffset" : 42
    }, {
      "referenceID" : 0,
      "context" : "A modification of the algorithm in [20,19] was implemented by Balai to develop solver ELPS [2].",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 25,
      "context" : "Zhizheng Zhang and Shutao Zhang [32] investigated combining ideas from Graded Modal Logic with ASP.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 24,
      "context" : "They continued this work with Wang [31], referring to the language as GI-log.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 20,
      "context" : "Shen and Eiter [24] proposed the updated semantics used in this paper and implemented in our solver, albeit using different syntactic notation.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 16,
      "context" : "Their work resolved most of the open questions raised in [19] and provided inspiration for our algorithm.",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 20,
      "context" : "• incorporates the latest semantics (as proposed by Shen & Eiter [24]), • addresses the memory issues that plague some other implementations, • uses multi-processing to improve performance, • allows early termination when desired number of solutions found, • solves harder programs faster, and • permits solving programs on a typical laptop computer that were previously beyond the capabilities of other solvers with reasonable resources.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 8,
      "context" : "Finally, we plan to look at techniques such as multi-shot solving [11] to avoid the need for repeatedly restarting the ASP solver from scratch.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 24,
      "context" : "We observe that with small modification our implementation could solve GI-log programs [31], though a suitable front end is needed to handle the program syntax.",
      "startOffset" : 87,
      "endOffset" : 91
    } ],
    "year" : 2016,
    "abstractText" : "As the practical use of answer set programming (ASP) has grown with the development of efficient solvers, we expect a growing interest in extensions of ASP as their semantics stabilize and solvers supporting them mature. Epistemic Specifications, which adds modal operators K and M to the language of ASP, is one such extension. We call a program in this language an epistemic logic program (ELP). Solvers have thus far been practical for only the simplest ELPs due to exponential growth of the search space. We describe a solver that is able to solve harder problems better (e.g., without exponentially-growing memory needs w.r.t. K and M occurrences) and faster than any other known ELP solver.",
    "creator" : "LaTeX with hyperref package"
  }
}