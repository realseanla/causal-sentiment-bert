{
  "name" : "1302.4421.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Towards a theory of good SAT representations",
    "authors" : [ "Matthew Gwynne" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n30 2.\n44 21\nv4 [\ncs .A\nI] 1\nThe hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F ∈ UCk is to be achieved for k as small as feasible. Here UC1 = UC has been introduced in [26] for the purpose of knowledge compilation. In general, UCk is the set of clause-sets F such that unsatisfiable instantiations (by partial assignments) are recognisable by k-times nested unit-clause propagation. We also touch upon the hierarchy PCk of propagation complete clause-sets of level k, where PC1 = PC has been introduced in [15]. The hierarchy PCk refines the hierarchy UCk by providing intermediate layers. In order to make use of full resolution, we consider the hierarchy WCk of width-refutation complete clauses-sets of level k, employing an improved notion of width (so that we always have UCk ⊆ WCk).\nVia the absolute condition, the quality of the representation F is fully captured by the target class, and the only relation between f and F is that F must “represent” f . If F does not contain new variables, then this means that F is equivalent to f , while with new variables the satisfying assignments of F projected to the variables of f must be precisely the satisfying assignments of f . Without new variables, the relative and absolute condition coincide, but with new variables, the absolute condition is stronger. As we remark in this article, for the relative condition and new variables at least the hierarchies UCk and PCk collapse, and we also conjecture that the WCk hierarchy collapses. The main result of this article is that without new variables, none of these hierarchies collapses. That means that there are boolean functions with only exponential-size equivalent clause-sets at level k, but with poly-size equivalent clause-sets at level k + 1.\nRepresentations with new variables in general allow shorter representations. However representations without new variables can be systematically searched for, opening a new algorithmic avenue for good SAT representations, where in a pre-processing phase the representation is being optimised. When using a two-stage approach, then first non-algorithmically a representation with new variables can be constructed, which then can be optimised by searching for an equivalent better clause-set.\nWe believe that many common CNF representations either already fit into the UCk scheme or can be made fit by slight improvements. We give some basic tools to construct representations in UC1, now with new variables and based on the Tseitin translation. We conclude with a discussion of open problems and future directions, with special emphasis on separations for the various hierarchies involved.\nContents"
    }, {
      "heading" : "1 Introduction 3",
      "text" : "1.1 A general framework: hierarchies and measurement . . . . . . . . . . 4 1.2 Representation of boolean functions . . . . . . . . . . . . . . . . . . 6 1.3 Strictness of hierarchies . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.4 Understanding the combinatorial structure of satisfiable clause-sets . 7 1.5 The UC hierarchy is strict regarding equivalence . . . . . . . . . . . 7 1.6 Relevance of these hierarchies for SAT solving . . . . . . . . . . . . . 8 1.7 Tools for good representations . . . . . . . . . . . . . . . . . . . . . . 9 1.8 Experimental results . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 1.9 Remarks on the term “hardness” . . . . . . . . . . . . . . . . . . . . 10 1.10 Overview on results . . . . . . . . . . . . . . . . . . . . . . . . . . . 11"
    }, {
      "heading" : "2 Preliminaries 12",
      "text" : "2.1 Clause-sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.2 CNF versus DNF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13 2.3 On “good” equivalent clause-sets . . . . . . . . . . . . . . . . . . . . 14"
    }, {
      "heading" : "3 Measuring “SAT representation complexity” 14",
      "text" : "3.1 Hardness and UCk . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 3.2 W-Hardness and WCk . . . . . . . . . . . . . . . . . . . . . . . . . . 17"
    }, {
      "heading" : "4 Minimal premise sets and doped clause-sets 18",
      "text" : "4.1 Minimal premise sets . . . . . . . . . . . . . . . . . . . . . . . . . . . 18 4.2 Doping clause-sets . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 4.3 Hardness of doped clause-sets . . . . . . . . . . . . . . . . . . . . . . 21"
    }, {
      "heading" : "5 Doping tree clause-sets 22",
      "text" : "5.1 Preliminaries on minimal unsatisfiability . . . . . . . . . . . . . . . . 22 5.2 Total minimal premise sets . . . . . . . . . . . . . . . . . . . . . . . 24 5.3 Doping SMUδ=1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27"
    }, {
      "heading" : "6 Lower bounds 28",
      "text" : "6.1 Trigger hypergraphs . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 6.2 Extremal trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30 6.3 The exponential lower bound . . . . . . . . . . . . . . . . . . . . . . 33"
    }, {
      "heading" : "7 Analysing the Tseitin translation 35",
      "text" : "7.1 CNF-representations . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 7.2 The canonical translation . . . . . . . . . . . . . . . . . . . . . . . . 36 7.3 XOR-clauses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42"
    }, {
      "heading" : "8 Hardness under union 43",
      "text" : ""
    }, {
      "heading" : "9 Basic experiments 44",
      "text" : "9.1 The instances . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45 9.2 Solver performances . . . . . . . . . . . . . . . . . . . . . . . . . . . 46"
    }, {
      "heading" : "10 Conclusion and open problems 49",
      "text" : "10.1 Strictness of hierarchies . . . . . . . . . . . . . . . . . . . . . . . . . 50 10.2 Separating the different hierarchies . . . . . . . . . . . . . . . . . . . 50 10.3 Compilation procedures . . . . . . . . . . . . . . . . . . . . . . . . . 51 10.4 Exploring w-hardness . . . . . . . . . . . . . . . . . . . . . . . . . . 52 10.5 Hard boolean functions handled by oracles . . . . . . . . . . . . . . . 52"
    }, {
      "heading" : "1 Introduction",
      "text" : "It has been shown that the practical performance of SAT solvers can depend heavily on the SAT representation used. See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography. In order to obtain “good” representations, until now the emphasis has been on translating constraints into SAT such that “arc-consistency” is “maintained”, via unit-clause propagation; for an introduction into the literature see Section 22.6.7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5]. That is, for all (partial) assignments to the variables of the constraint, the task is to ensure that if there is a forced assignment (i.e., some variable which must be set to a particular value to avoid inconsistency), then unit-clause propagation (UCP) is sufficient to find and set this assignment. In a similar vein, there is the class PC of propagation-complete clause-sets (see [15]), containing all clause-sets for which unit-clause propagation is sufficient to detect all forced assignments.\nMaintaining arc-consistency and propagation-completeness may at a glance seem the same concept. However there is an essential difference. When translating a constraint into SAT, typically one does not just use the variables of the constraint, but one adds auxiliary variables to allow for a compact representation. Now when speaking of maintaining arc-consistency, one only cares about assignments to the constraint variables. But propagation-completeness deals only with the representing clause-set, thus can not know about the distinction between original and auxiliary variables, and thus it is a property on the (partial) assignments over all variables! So a SAT representation, which maintains arc-consistency via UCP, will in general not be propagation-complete, due to assignments over both constraint and new variables yielding a forced assignment or even an inconsistency which UCP doesn’t detect; see Example 7.10 and Lemma 7.11. In contrast to this, for the basic concepts of “good” representations investigated in this paper, considering all variables is a fundamental feature. This motivates our focus on classes of clause-sets (as the target of good SAT representations), rather than maintaining consistency over some higher level constraint network, since in this way we have full control of the properties at the level of the SAT solver (at the CNF-level).\nIn [45] it is shown that conflict-driven solvers with branching restricted to input variables have only superpolynomial run-time on EPHP′n, an Extended Resolution\nextension to the pigeon-hole formulas, while unrestricted branching determines unsatisfiability quickly (see Subsection 10.5 for more on this). Also experimentally it is demonstrated in [47] that input-restricted branching can have a detrimental effect on solver times and proof sizes for modern CDCL solvers. This adds motivation to our fundamental choice of considering all variables (rather than just input variables), when deciding what properties we want for SAT translations. We call this the “absolute (representation) condition”, taking also the auxiliary variables into account, while the “relative condition” only considers the original variables. Besides avoiding the creation of hard unsatisfiable sub-problems, the absolute condition also enables one to study the target classes, like PC, on their own, without relation to what is represented.\nIn a certain sense, the underlying idea of maintaining arc-consistency and propagation-complete translations is to compress all of the constraint knowledge into the SAT translation, and then to use UCP to extract this knowledge when appropriate. Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties. Rather than requiring that UCP detects all forced assignments (as for PC), a clause-set is in UC iff for all partial assignments resulting in an unsatisfiable clause-set UCP detects this.\nSo we have UC and PC as potential target classes for “good” SAT representations. In both cases we know, that if the SAT solver ends up in an unsatisfiable part of the search space, then the ubiquitous unit-clause propagation will immediately determine this and the solver will avoid potentially exponential work. However, how to come up with representations in UC? There are easy examples of “good” clause-sets which are not in UC, e.g., 2-CNF. Given that UCP is a relatively simple mechanism, perhaps it would be better to consider more powerful inference methods allowing for a greater variety and possibly shorter representations (“more compression”)? For this end, to add more power, we introduce “hardness measurement”."
    }, {
      "heading" : "1.1 A general framework: hierarchies and measurement",
      "text" : "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of “hardness” at most k, that is, refutation is (always) possible via rk. Replacing r1 with rk in the same way in PC yields the propagation-completeness hierarchy PCk (with PC1 = PC). In the limit these hierarchies cover all clause-sets, with the levels of the hierarchy offering the possibility to trade complexity of the inference method (rk) for size of the representation. Generalising existing results we show in Lemma 6.5 of [37, 38] that various poly-time solvable SAT classes are contained within levels of the UCk hierarchy. That is HO ⊂ RHO ⊂ UC1 (Horn and renamable Horn clause-sets), 2–CLS ⊂ QHO ⊂ UC2 (2-clause-sets and q-Horn clauses-sets, see Section 6.10.2 in [22] and [85]) and HOk ⊂ UCk (generalised Horn clause-sets, see [51]).\nThere are strong proof theoretic connections for UCk to tree-resolution. In [46] the argument is made that tree-resolution complexity can not provide a good measure of hardness of instances for SAT solving, citing the ability of CDCL solvers to simulate exponentially more powerful full resolution (see [2] for evidence that CDCL solvers can simulate full resolution). However, the aim of UCk is not to measure hardness, but to offer a target class for SAT translation. In this respect tree-resolution complexity measures are ideal, because they provide the strongest translations, and upper-bound measures for full resolution.\nOn the other hand, for tighter target classes in the case of full resolution, we also consider the notion of width-hardness as introduced in [37, 38], based on the\nwidth-based hierarchies of unsatisfiable clause-sets in [53, 59]. That is, a clause-set is in WCk, the hierarchy of clause-sets of width-hardness k, iff under any partial assignment resulting in an unsatisfiable clause-set there is a “k-resolution” refutation as introduced in [51]. Here, unlike the typical notion, we allow resolutions where only one parent clause needs to have length at most k, and thus properly generalising unit-resolution (one could speak of “asymmetric width” here, compared to the standard “symmetric width”). This allows to simulate nested input resolution, and thus we have UCk ⊆ WCk for all k, whereas otherwise in the standard (symmetrical) sense even Horn clause-sets require unbounded width (recall that HO ⊂ UC1).\nFundamental for each hierarchy is an underlying measure h0 : USAT → CLS, measuring the “hardness” of unsatisfiable clause-sets, which is extended to h : CLS → N0, where h(F ) for an arbitrary clause-set F measures the “hardness” to derive any conclusion F |= C for clauses C, by letting h(F ) be the maximum of h0(ϕ∗F ) over all partial assignments ϕ such that application yields an unsatisfiable result ϕ ∗ F . The hierarchy at level k collects all F with h(F ) ≤ k. For the PCUC hierarchy the corresponding measure phd(F ) resp. hd(F ) can be described in many ways; most intuitive from a SAT point of view is to say that it measures the necessary nesting level of UCP, that is, which rk is required.\nA precursor A generalisation of UC was already discussed in [27]. Assuming a polytime SAT-decision algorithm P : C → {0, 1} for some C ⊆ CLS, the class PC ⊆ CLS of “P-complete” clause-sets is defined as the set of F ∈ CLS such that for all implicates C holds P (ϕC ∗ F ) = 0.1) This is an obvious generalisation of UCk, when using Ck := {F ∈ CLS : rk(F ) ∈ {⊤, {⊥}}} and Pk : Ck → {0, 1} with Pk(F ) = 1 ⇔ rk(F ) = ⊤. But it does not cover the hierarchies PCk or WCk, which are based on different principles.2) We note the conceptual weakness of demanding a SAT-decision algorithm P , where actually only a means for detecting unsatisfiability is needed.\n[27] continues by considering the (generic) hierarchy (Πk)k∈N0 from [71], a precursor of [53]. Π0 ⊆ CLS in principal is arbitrary, but is assumed to be polytime decidable and SAT-decidable. Then Πk for k > 0 is the set of F ∈ CLS such that F ∈ Πk−1 or there is a literal x ∈ lit(F ) with 〈x → 1〉 ∗ F ∈ Πk−1 and 〈x → 1〉 ∗ F ∈ Πk. We note that if we choose Π0 = {F ∈ CLS : ⊥ ∈ F}, then Πk = UCk ∩ USAT for all k ≥ 0. However this choice for Π0 was never considered for that hierarchy from [71], which might have two reasons: Implicit preference is given to classes Π0 closed under sub-clause-set formation (see Section 6.3 in [38] for more discussions on this issue). And furthermore SAT and UNSAT is not distinguished in [71] and in subsequent work directly relying on it; see Subsection 1.2 in [53] for a discussion of this. So the four choices for Π0 considered in [27] are HO, 2–CLS, RHO and QHO. Accordingly UC0∩USAT is not contained at any Πk, and so not even r1 on unsatisfiable clause-set is covered by the considered hierarchies.\nDue to these weaknesses, [27] does not consider a hierarchy generalising UC. From our point of view one could say, that Πk is only considered as a resource for polytime recognition of certain instances for UCk resp. UCk+1; compare Subsections 6.2, 6.3 in [38] for results in this direction.\n1)[27] actually favours adding unit-clauses to F , but we consider applying partial assignments as more fundamental.\n2)This is obvious for k ≥ 1 and PCk , since PCk ∩ USAT = UCk ∩ USAT , while PCk ∩ SAT ⊂ UCk ∩SAT . We conjecture that for k ≥ 3 there is no (polytime) P with PC = WCk (as remarked in Subsection 3.2, for k ∈ {0, 1, 2} there exists such a P )."
    }, {
      "heading" : "1.2 Representation of boolean functions",
      "text" : "By definition each PCk,UCk,WCk is just a class of clause-sets. However when using these classes for representing boolean functions, then there are further aspects. In general, for translations to SAT a typical path is\nProblem → Constraints → Boolean functions → SAT ︸ ︷︷ ︸\nour focus\n.\nBy considering target classes for “good” SAT representations. we focus our attention on the final stage, the translation of boolean functions to SAT, ignoring the issue of encoding non-boolean domains into the boolean. Now there are three main dimensions to consider (choices to make):\n1. Inference properties (PCk versus UCk versus WCk, and the value of k): How strong a property we require of the clause-set we translate to (PCk is strongest, WCk weakest, and the lower k the stronger the condition).\n2. Logical equivalence versus new variables: whether the SAT translation is equivalent to the input function (i.e., no new variables), or uses new variables to extend the original function.\n3. Relative versus absolute condition: in case new variables are used, whether the property we require for the translation refers to partial assignments only on the original variables or also on the new variables.\nSee Subsection 7.1 for more on the relative condition; our point of view is that the absolute condition is fundamental for the representation of boolean functions, not the relative condition (which has been dominant in the literature until now).\nIn the area of Knowledge Compilation, the task is also to represent (“compile”) boolean functions to allow good inference under (repeated) queries. In particular, one wants to find a representation for a boolean function which allows queries such as clausal entailment (F |= C), equivalence, and model counting to be answered efficiently (in polynomial time). In this sense, we can think of “finding a good representation” as a form of SAT knowledge compilation, where we care (only) about clausal entailment, since CNF-clauses directly correspond to falsifying partial assignments. [18] gives an overview of the CNF-based target languages (prime implicates, UC, 2–CLS, Horn clause-sets). [29] consider disjunctions of simple CNF classes. [25] provides an overview of target compilation languages based on “nested” (graph-based) classes, namely variants of NNF, DNNF and BDDs. In all cases query complexity and succinctness is investigated. We focus on CNF representations, since we want good representations for current resolution-based SAT solvers. All of the CNF classes studied in [18, 25, 29] are included at the first three levels of the hierarchy UCk, namely, sets of prime implicates in UC0, (renamable) Horn clausesets in UC1 = UC, and 2–CLS in UC2. Translations from target classes such as DNNF to CNF are also of interest and fit into the framework of UCk via using new variables; see Section 7.2 for the most basic positive considerations. And see [49] for a basic negative result, characterising what can be represented under the relative condition (i.e., arc consistency)."
    }, {
      "heading" : "1.3 Strictness of hierarchies",
      "text" : "A fundamental question is the strictness of these hierarchies PCk, UCk, and WCk in each of those two remaining dimensions. That is, whether each level offers new possibilities for polysize representations of (sequences of) boolean functions within the confines of the specified dimensions, i.e., relative versus absolute and without versus with new variables. Using the basic choice of the absolute condition, we\nhave six proper hierarchies (3 conjectured, 3 proven), namely PCk, UCk and WCk for representations without (Theorem 6.14) and with new variables (Conjecture 7.3).3) However when using representations based on the relative condition (and using new variables), then all these hierarchies collapse to their first level: two collapses are similar to existing results, while the collapse for WCk should follow also in this way, and is spelled out as Conjecture 7.5.\nConsidered together, under the relative condition only the levels PC0 ⊂ UC0 ⊂ PC1 are strict regarding polysize representations, where the two classes PC0 ⊂ UC0 do not gain anything from the new variables, while everything of PCk, UCk and WCk for k ≥ 1 can be reduced (in polytime, with exponent depending on k) to PC1 = PC. And PC under the relative condition is the same as the well-known condition of “arc consistency” for SAT translation. The main result of this paper, that PCk, UCk and WCk for the absolute condition and without new variables do not collapse, shows that a rich structure was hidden under the carpet of the relative condition aka arc consistency. A basic difference between relative and absolute condition is that under the relative condition the new variables can be used to perform certain “computations”, since there are no conditions on the new variable other than not to distort the satisfying assignments. This is used to show the collapse to arc consistency, by encoding the stronger condition into the clause-sets in such a way that UCP can perform the “computations”."
    }, {
      "heading" : "1.4 Understanding the combinatorial structure of satisfiable clause-sets",
      "text" : "To be able to prove properties about all equivalent representations of some clause-set F , we must be able to understand its combinatorial structure in relation to the set of all its prime implicates. The notion of minimal unsatisfiability (MU) and minimally unsatisfiable subsets (MUS) is important in understanding the combinatorics of unsatisfiable clause-sets (see [52, 66]). To understand the structure of satisfiable clause-sets and their associated boolean functions, we now consider the concept of “minimal premise sets” (MPS) introduced in [62]. The notion of MPS generalises that of MU by considering clause-sets F which are minimal w.r.t implying any clause C rather than just those implying ⊥. And accordingly we consider the minimal-premise subsets (MPSS) of a clause-set F .\nEvery prime implicate C of a clause-set F has an associated MPSS (just consider the minimal sub-clause-set of F that implies C), but not every MPSS of F yields a prime implicate (e.g., consider the MPSS {C} for some non-prime clause C ∈ F ). However, by “doping” the clause-set, i.e., adding a new unique variable to every clause, every clause in an MPSS F ′ makes a unique contribution to its derived clause C. This results in a new clause-set D(F ) which has an exact correspondence between its minimal premise sets (which are (essentially) also those of F ) and its prime implicates. In this way, by considering clause-sets F with a very structured set of minimal premise subsets, we can derive clause-sets D(F ) with very structured set of prime implicates."
    }, {
      "heading" : "1.5 The UC hierarchy is strict regarding equivalence",
      "text" : "A sequence (fh)h∈N of boolean functions, which separates UCk+1 from UCk w.r.t. clause-sets equivalent to fh in UCk+1 resp. UCk, should have the following properties:\n1. A large number of prime implicates: the number of prime implicates for fh should at least grow super-polynomially in h, since otherwise already\n3)Regarding PCk we get only a separation of PCk and PCk+2; this will be addressed in future work.\nthe set of prime implicates is a small clause-set in UC0 (see Definition 3.3) equivalent to fh.\n2. Easily characterised prime implicates: the prime implicates of fh should be easily characterised, since otherwise we can not understand how clause-sets equivalent to fh look like.\n3. Poly-size representations: there must exist short clause-sets in UCk+1 equivalent to fh for all h ∈ N.\n[75] introduced a special type of boolean functions, called Non-repeating Unate Decision trees (NUD) there, by adding new variables to each clause of clause-sets in SMUδ=1, which is the class of unsatisfiable hitting clause-sets of deficiency δ = 1. These boolean functions have a large number of prime implicates (the maximum regarding the original number of clauses), and thus are natural to consider as candidates to separate the levels of UCk. In Section 4 we show that it is actually the underlying SMUδ=1 clause-sets that contribute the structure. The clause-sets in SMUδ=1 are exactly those with the maximum number of minimal premise sets, and then doping elements of SMUδ=1 yields clause-sets with the maximal number of prime implicates. We utilise the tree structure of SMUδ=1 to prove lower bounds on the size of equivalent representations of doped SMUδ=1 clause-sets in UCk.\nIn Section 6 we introduce the basic method (see Theorem 6.4) for lower bounding the size of equivalent clause-sets of a given hardness, via the transversal number of “trigger hypergraphs”. Using this lower bound method, in Theorem 6.13 we show a lower bound on the matching number of the trigger hypergraph of doped “extremal” SMUδ=1-clause-sets. From this follows immediately Theorem 6.14, that for every k ∈ N0 there are polysize clause-sets in UCk+1, where every equivalent clause-set in WCk is of exponential size. Thus the UCk as well as the WCk hierarchy is strict regarding equivalence of polysize clause-sets.\nIn [26] (Example 2) a separation was already shown between UC0 (clause-sets containing all of their prime implicates) and UC1 = UC, and the question was raised of the worst-case growth when compiling from an arbitrary CNF clause-set F to some equivalent F ′ ∈ UC. This question was partly answered in [8] (although the connection was not made), where the authors provide examples of poly-size clausesets with only super-polynomial size representations in UC, even when allowing new variables (see Subsections 7.1, 10.5, and [9] for more on the connection between [8] and UCk). This shows a super-polynomial lower-bound on the worst-case growth, but no method or new (larger) target-class for knowledge-compilation. Our separation result now answers the question of worst-case growth from [26] in full generality with the hierarchy UCk. Each level of UCk is exponentially more expressive than the previous (i.e., with possible exponential blow-up when compiling from some F ∈ UCk+1 to equivalent F ′ ∈ UCk), and so each level offers its own new, larger class for knowledge compilation, at the expense of increased query time (now O(ℓ(F ) ·n(F )2k−2) for UCk compared to O(ℓ(F )) for UC). This separation, between UCk+1 and UCk for arbitrary k, is more involved than the simple separation in [26], due to the parameterised use of more advanced polynomial-time methods than r1 (UCP). Especially the separation between UC0 and UC1 is rather simple, since UC0 does not allow any form of compression."
    }, {
      "heading" : "1.6 Relevance of these hierarchies for SAT solving",
      "text" : "The poly-time methods used to detect unsatisfiability of instantiations of clause-sets in UCk resp. WCk have a running-time with an exponent depending on k, and in the latter case also space-complexity depends in the exponent on k.\n1. This seems a necessary condition for showing a separation result as shown in this paper. It is needed that the different levels are qualitatively different. And this seems very unlikely to be achievable with a parameter which would allow fixed-parameter tractability, and which thus would only be a quantitative parameter (like the number of variables), only expressing a gradual increase in complexity. See Lemma 10.4 for an example of a collapsing hierarchy.\n2. The class UCk uses generalised UCP, namely the reduction rk. Especially r2, which is (complete) failed-literal elimination, is used in look-ahead SAT solvers (see [42] for an overview) such as OKsolver ([57]), march ([41]) and Satz ([65]). Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique. Furthermore, in general rk is used, in even stronger versions, in the St̊almarck-solver (see [81, 40, 73], and see Section 3.5 of [53] for a discussion of the connections to rk), and via breadth-first “branch/merge” rules in HeerHugo (see [33]).\n3. Our example class G1k,h (see Section 9) shows experimentally that higher levels of hardness may still be solved easily by SAT solvers. These examples have such read-once resolution refutations (linear in the size of the input) which are detectable by “2-subsumption resolution”, i.e., the replacement of two clauses C ∪{v}, C ∪ {v} by one clause C. So with this preprocessing SAT solvers can solve them in linear time. But also without this preprocessing SAT solvers seem to solve these problems in linear time. The alternative representations have lower hardness, but due to their bigger sizes SAT solvers perform orders of magnitudes worse on the larger instances.\n4. In general, a SAT solver does not need to have these mechanisms built-in in general: as practical experience shows, SAT solvers are rather good in finding resolution refutations, and the parameter k in UCk resp. WCk is just a general way of bounding resolution complexity. In [68, 69] it is argued that modern SAT solvers can simulate full resolution — and this is considered to be a good property of SAT solvers. Thus they are also capable in general of finding the refutations guaranteed by UCk resp. WCk. An important point here is, that for theoretical reasoning all unsatisfiable instantiations must be handled, while in a SAT-solver run only a selected set of instantiations is encountered, and thus “leaner means” can suffice (as the practical success of SAT solving shows)."
    }, {
      "heading" : "1.7 Tools for good representations",
      "text" : "We conclude our investigations by considering translations based on the Tseitin translation in Section 7, and show that interesting classes of boolean function can be polynomially translated to UC under the absolute condition using new variables. First we discuss the notion of “representation” in general in Subsection 7.1, with special emphasise on the “relative” versus the “absolute condition”.\nThe Tseitin translation for DNF’s we call “canonical translation”, and we investigate it in Subsection 7.2. In particular, in Lemma 7.12 we show that every orthogonal (or “disjoint”, or “hitting”) DNF is translated to UC, while in Lemma 7.17 we show that actually every DNF is translated to UC, when using the “reduced” canonical translation, which uses only the necessary part of the equivalences constitutive for the Tseitin translation. Applied to our examples yielding the separation of UCk+1 from WCk (Theorem 6.14, regarding polysize representations without new variables), we obtain a representation in UC in Theorem 7.14 (for the canonical translation), demonstrating the power of using new variables.\nIt has been noted in the literature at several places (see [70, 44, 28]), that one might use only one of the two directions of the equivalences in the Tseitintranslation. Regarding the canonical translation we have the full translation (Definition 7.6) versus the reduced translation (Definition 7.15). The full translation yields UC for special inputs (Lemma 7.12), and has relative hardness 1 for general DNF (Lemma 7.9), however (absolute) hardness for arbitrary DNF-inputs can be arbitrarily high as shown in Lemma 7.11. On the other hand, the reduced translation yields always UC (Lemma 7.17). So we have the following explanations why using either both directions or only one direction in the Tseitin translation, in the context of translating DNF’s, can perform better than the other form:\n• When using both directions (i.e., the canonical translation), splitting on the auxiliary variables is powerful, which is an advantage over using only one direction (i.e., the reduced canonical translation), where setting an auxiliary variable to false says nothing.\n• On the other hand, the canonical translation, when applied to non-hitting DNFs, can create hard unsatisfiable sub-problems (via partial assignments), which can not happen for the reduced translation.\nIt seems very interesting to us to turn these arguments into theorems (for concrete examples), and also to experimentally evaluate them. In this way we hope that in the future more precise directions can be given when to use which form of the Tseitin translation.\nIn Subsection 7.3 we turn to the translation of “XOR-clauses”. Section 1.5 of [37, 38] discusses the translation of the so-called “Schaefer classes” into the UCk hierarchy; see Section 12.2 in [24] for an introduction, and see [23] for an in-depth overview on recent developments. All Schaefer classes except affine equations have natural translations into either UC1 or UC2. The open question is whether systems of XOR-clauses (i.e., affine equations) can be translated into UCk for some fixed k. We consider the most basic questions in a sense. On the positive side, for single XOR clauses, we show in Lemma 7.19 that the Tseitin translation of a typical XOR summation circuit is in UC. On the negative side, in Theorem 8.5, we show for all k ≥ 3 that applying this translation piecewise to systems of just two largeenough XOR clauses yields a SAT translation not in UCk. Conjecture 7.21 then hypothesises that, in general, systems of XOR-clauses have no representation of bounded hardness."
    }, {
      "heading" : "1.8 Experimental results",
      "text" : "In Section 9 we consider the usage of the class of boolean functions f used for the lower bound as a constraint in a general SAT problem. We have equivalent clausesets in UCk for the optimal k, as well as short orthogonal DNF representations, which enable us to apply the canonical translation as well as the reduced canonical translation. We complement these three constraint-representations in a fixed way to obtain an unsatisfiable clause-set. The experiments show that for all solver types the optimal UCk representations performs much better in terms of running time. This yields some evidence to our claim that equivalent representations in UCk even for higher k (in our experiments we considered k ≤ 5) might outperform representations obtained by introducing new variables, due to using (possibly) much less variables and clauses."
    }, {
      "heading" : "1.9 Remarks on the term “hardness”",
      "text" : "In general, if one speaks of the “hardness measure” hd : CLS → N0 (Definition 3.3) in context with other measures, then one should call it more specifically\ntree-hardness (“t-hardness”), denoted by thd(F ), due to its close relation to treeresolution (and its space complexity). So we have three basic types of hardnessmeasures, namely t-hardness thd(F ), the minimum k with F ∈ UCk, p-hardness phd(F ), the minimum k with F ∈ PCk, and w-hardness, the minimum k with in F ∈ WCk. In this article, since thd(F ) is still most important here, we denote it by hd(F ) = thd(F ).\nIn what respect is the terminology “hardness” appropriate? The hardness measure hd(F ) has been introduced in [53, 59], based on quasi-automatisation of tree-resolution, that is, on a specific algorithmic approach (close to St̊almarcks approach).4) In [1], hd(F ) for unsatisfiable F was proposed as measure of SAT-solverhardness in general. This was criticised in [46] by the argument, that conflict-driven SAT solvers would be closer to dag-resolution (full resolution) than tree-resolution. Due to their heuristical nature, it seems to us that there is no robust measure of SAT-solver-hardness. Instead, our three basic measures, which are robust and mathematically meaningful, measure how good a clause-set F is in representing an underlying boolean function in the following sense:\n• Regarding instantiation we take a worst-case approach, that is, we consider all partial assignments ϕ and their applications ϕ ∗ F (insofar they create unsatisfiability or forced literals).\nA SAT-solver only uses certain partial assignments, and thus this worst-case approach is overkill. However when using F in any context, then it makes sense to consider all partial assignments.\n• Regarding algorithms, we take a breadth-first approach, that is, the smallest k such that rk or k-resolution succeeds. For k > 1 a SAT-solver might not find these inferences. In Subsection 1.6 we have discussed the issue of incorporating these reductions into SAT solving. From a theoretical point of view, the maximisation over all partial assignments needs to be complemented with a minimisation (over k) in order to yield something interesting."
    }, {
      "heading" : "1.10 Overview on results",
      "text" : "The preliminaries (Section 2) define the basic notions. The classes UCk andWCk are introduced in Section 3. In Section 4 we investigate minimal premise sets and doping in general, while in Section 5 we apply these notions to our source of hard examples. In Section 6 we are then able to show the separation result. In Section 7 we then turn from lower bounds to upper bounds, and analyse the Tseitin translation. To investigate the hardness of a special case, we present some tools for determining (w-)hardness in Section 8. Section 9 discusses our basic experiments. Finally, in Section 10 one finds many open problems.\nThe main results on minimal premise sets and doping are:\n1. Theorem 4.18 shows the correlation between prime implicates of doped clausesets and minimal premise-sets of the original (undoped) clause-sets.\n2. Theorem 5.12 characterises unsatisfiable clause-sets where every non-empty sub-clause-set is a minimal premise set.\n3. Theorem 5.22 gives basic characteristics of doped SMUδ=1-clause-sets.\nThe main results on size lower bounds for the hardness are:\n4)Using the simplest oracle, on unsatisfiable instances the measure from [53, 59] yields hd(F ). But on satisfiable instances the approach of [53, 59] is very different, namely an algorithmic polynomial-time approach is taken, extending the breadth-first search for tree-resolution refutations in a natural way.\n1. Theorem 6.4 introduces the basic method for lower bounding the size of equivalent clause-sets of a given hardness, via the transversal number of “trigger hypergraphs”.\n2. Theorem 6.13 shows a lower bound on the matching number of the trigger hypergraph of doped “extremal” SMUδ=1-clause-sets.\n3. Theorem 6.14 shows that for every k ∈ N0 there are polysize clause-sets in UCk+1, where every equivalent clause-set in WCk is of exponential size.\nAnd regarding upper bounds, that is, short representations (with new variables) with low hardness, we have the following main results:\n1. Lemmas 7.12, 7.17 show how the canonical translation can yield results in UC.\n2. Theorem 7.14 shows that all doped SMUδ=1-clause-sets (and in fact all doped unsatisfiable hitting clause-sets) have short CNF-representations in UC via the canonical translation.\n3. Lemma 7.19 shows that translating a single XOR-clause to UC is easy, while Theorem 8.5 shows that applying this translation to just two XOR-clauses already yields high hardness."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We follow the general notations and definitions as outlined in [52]. We use N = {1, 2, . . .}, N0 = N ∪ {0}, and P(M) for the set of subsets of set M ."
    }, {
      "heading" : "2.1 Clause-sets",
      "text" : "Let VA be the infinite set of variables, and let LIT = VA ∪ {v : v ∈ VA} be the set of literals, the disjoint union of variables as positive literals and complemented variables as negative literals. We use L := {x : x ∈ L} to complement a set L of literals. A clause is a finite subset C ⊂ LIT which is complement-free, i.e., C∩C = ∅; the set of all clauses is denoted by CL. A clause-set is a finite set of clauses, the set of all clause-sets is CLS. By var(x) ∈ VA we denote the underlying variable of a literal x ∈ LIT , and we extend this via var(C) := {var(x) : x ∈ C} ⊂ VA for clauses C, and via var(F ) := ⋃\nC∈F var(C) for clause-sets F . The possible literals\nin a clause-set F are denoted by lit(F ) := var(F ) ∪ var(F ). Measuring clausesets happens by n(F ) := |var(F )| for the number of variables, c(F ) := |F | for the number of clauses, and ℓ(F ) := ∑\nC∈F |C| for the number of literal occurrences. A special clause-set is ⊤ := ∅ ∈ CLS, the empty clause-set, and a special clause is ⊥ := ∅ ∈ CL, the empty clause.\nA partial assignment is a map ϕ : V → {0, 1} for some finite V ⊂ VA, where we set var(ϕ) := V , and where the set of all partial assignments is PASS . For v ∈ var(ϕ) let ϕ(v) := ϕ(v) (with 0 = 1 and 1 = 0). We construct partial assignments by terms 〈x1 → ε1, . . . , xn → εn〉 ∈ PASS for literals x1, . . . , xn with different underlying variables and εi ∈ {0, 1}. We use ϕC := 〈x → 0 : x ∈ C〉 for the partial assignment setting precisely the literals in clause C ∈ CL to false.\nFor ϕ ∈ PASS and F ∈ CLS we denote the result of applying ϕ to F by ϕ ∗ F , removing clauses C ∈ F containing x ∈ C with ϕ(x) = 1, and removing literals x with ϕ(x) = 0 from the remaining clauses. By SAT := {F ∈ CLS | ∃ϕ ∈ PASS : ϕ∗F = ⊤} the set of satisfiable clause-sets is denoted, and by USAT := CLS\\SAT the set of unsatisfiable clause-sets.\nSo clausal entailment, that is the relation F |= C for F ∈ CLS and C ∈ CL, which by definition holds true iff for all ϕ ∈ PASS with ϕ ∗ F = ⊤ we have ϕ ∗ {C} = ⊤, is equivalent to ϕC ∗ F ∈ USAT .\nTwo clauses C,D ∈ CL are resolvable iff they clash in exactly one literal x, that is, C ∩D = {x}, in which case their resolvent is C ⋄D := (C ∪D) \\ {x, x} (with resolution literal x). A resolution tree is a full binary tree formed by the resolution operation. We write T : F ⊢ C if T is a resolution tree with axioms (the clauses at the leaves) all in F and with derived clause (at the root) C. A resolution tree T : F ⊢ C is regular iff along each path from the root of T to a leaf no resolutionvariable is used more than once. In this article we use only resolution trees, even when speaking of unrestricted resolution, that is, we always unfold dag-resolution proofs to (full) binary resolution trees. Completeness of resolution means that F |= C (semantic implication) is equivalent to F ⊢ C, i.e., there is some C′ ⊆ C and some T with T : F ⊢ C′.\nA prime implicate of F ∈ CLS is a clause C such that a resolution tree T with T : F ⊢ C exists, but no T ′ exists for some C′ ⊂ C with T ′ : F ⊢ C′; the set of all prime implicates of F is denoted by prc\n0 (F ) ∈ CLS. The term “implicate” refers\nto the implicit interpretation of F as a conjunctive normal form (CNF). Considering clauses as combinatorial objects one can speak of “prime clauses”, and the “0” in our notation reminds of “unsatisfiability”, which is characteristic for CNF. Two clause-sets F, F ′ ∈ CLS are equivalent iff prc0(F ) = prc0(F ′). A clause-set F is unsatisfiable iff prc0(F ) = {⊥}. The set of prime implicants of a clause-set F ∈ CLS is denoted by prc1(F ) ∈ CLS, and is the set of all clauses C ∈ CL such that for all D ∈ F we have C ∩D 6= ∅, while this holds for no strict subset of C."
    }, {
      "heading" : "2.2 CNF versus DNF",
      "text" : "As we said, the default interpretation of a clause-set F is as a CNF, which we can emphasise by speaking of the “CNF-clause-set F”, that is, the interpretation as a boolean function is\nF ❀ ∧\nC∈F\n∨\nx∈C x.\nWe might consider F also as a DNF-clause-set, which does not change F itself, but only changes the interpretation of F in considerations regarding the semantics:\nF ❀ ∨\nC∈F\n∧\nx∈C x.\nNote that by the de Morgan rules from the CNF-formula we obtain the DNFformula via negating the whole formula together with negating the literals (in other words, the underlying boolean function of a CNF-clause-set F is the “dual” of the underlying boolean function of the DNF-clause-set F ; see [22]). Thus the logical negation (as CNF) of a clause-set F (as CNF) is obtained from a DNF-clause-set equivalent to F by negating all literals.\nExample 2.1 The clause-set F = {{v}} has the equivalent DNF-clause-set F = {{v}} (the underlying boolean function is “self-dual”; see [22]), while the negation is {{v}}. And F = {{v, w}} has the equivalent DNF-clause-set {{v}, {w}}, while the negation is {{v}, {w}}.\nThe above description of the sets prc0(F ), prc1(F ) as the set of prime implicates resp. implicants holds for the default interpretation of F as CNF, while for the DNFinterpretation prc0(F ) becomes the set of prime implicants, while prc1(F ) becomes the set of prime implicates (of the boolean function underlying F ). A CNF-clauseset F is equivalent to a DNF-clause-setG iff prc0(F ) = prc1(G). The total satisfying\nassignments of a (CNF-)clause-set F can be identified with the elements of the canonical DNF of F , which is defined via the map DNF : CLS → CLS, where for F ∈ CLS we set DNF(F ) := {C ∈ CL | var(C) = var(F ) ∧ ∀D ∈ F : C ∩D 6= ∅}.\nWhile clause-sets and partial assignments themselves are neutral regarding CNFor DNF-interpretation, the application ϕ ∗ F is based on the CNF-interpretation of F ; if we wish to use the DNF-interpretation of F , then we use ϕ ∗ F , where ϕ := 〈v → ϕ(v) : v ∈ var(ϕ)〉. While ⊤ in the CNF-interpretation stands for “true”, in the DNF-interpretation it becomes “false”.\nExample 2.2 Consider F := {{a}, {b}} ∈ CLS (with n(F ) = c(F ) = ℓ(F ) = 2). Then DNF(F ) = {{a, b}}, and for ϕ := 〈a, b → 1〉 we have ϕ ∗ F = ⊤. This corresponds to the CNF-interpretation a ∧ b of F , which has exactly one satisfying assignment ϕ. If we consider the DNF-interpretation a ∨ b of F , then we have three satisfying total assignments for the DNF-clause-set F , and for example the satisfying assignment ψ := 〈a → 1〉 is recognised via ψ ∗ F = 〈a → 0〉 ∗ F = {⊥, {b}}, where the result as DNF is a tautology, since ⊥ as a DNF-clause becomes the constant 1 (as the empty conjunction)."
    }, {
      "heading" : "2.3 On “good” equivalent clause-sets",
      "text" : "A basic problem considered in this article is for a given F ∈ CLS to find a “good” equivalent F ′ ∈ CLS. How “good” F ′ is depends in our context on two factors, which have to be balanced against each other:\n• the size of F ′: we measure c(F ′), and the smaller the better;\n• the inference power of F ′: inference from F ′ should be “as easy as possible”, and we consider two measures in this article, (tree-)hardness in Subsection 3.1, and width-hardness in Subsection 3.2; the smaller these measures, the easier inference w.r.t. tree resolution resp. (generalised) width-bounded resolution.\nThe basic size-lower-bound for F ′ is given by the essential prime implicates, which are those C ∈ prc0(F ) such that prc0(F ) \\ {C} is not equivalent to F :\nLemma 2.3 Consider F ∈ CLS, and let P ⊆ prc0(F ) be the set of essential prime implicates of F . Now for every F ′ ∈ CLS equivalent to F there exists an injection i : P → F ′ such that for all C ∈ P holds C ⊆ i(C). Thus c(F ′) ≥ c(P ).\nProof: For every C′ ∈ F ′ there exists a C ∈ prc0(F ) such that C ⊆ C′; replacing every C′ ∈ F by such a chosen C we obtain F ′′ ⊆ prc0(F ) with P ⊆ F ′′.\nNote that Lemma 2.3 crucially depends on not allowing new variables (see Subsection 7.1 for what it means that an F ′ with new variable “represents” F ) — when allowing new variable, then we currently do not have any overview on the possibilities for “better” F ′. The most powerful representation regarding inference alone (with or without new variables) is given by the set prc0(F ) of all prime implicates of F , and will have “hardness” 0, as defined in the following section. (The problem is of course that in most cases this representation is too large, and thus higher hardness must be allowed.)"
    }, {
      "heading" : "3 Measuring “SAT representation complexity”",
      "text" : "In this section we define and discuss the measures hd, phd,whd : CLS → N0 and the corresponding classes UCk,PCk,WCk ⊂ CLS. It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.\n3.1 Hardness and UCk First we turn to the most basic hardness measurement. It can be based on resolution refutation trees, as we do here, but it can also be defined algorithmically, via generalised unit-clause propagation (see Lemma 3.4).\nDefinition 3.1 For a full binary tree T the height ht(T ) ∈ N0 and the HortonStrahler number hs(T ) ∈ N0 are defined as follows:\n1. If T is trivial (i.e., #nds(T ) = 1), then ht(T ) := 0 and hs(T ) := 0.\n2. Otherwise let T1, T2 be the two subtrees of T :\n(a) ht(T ) := 1 +max(ht(T1), ht(T2))\n(b) If hs(T1) = hs(T2), then hs(T ) := 1 + max(hs(T1), hs(T2)), otherwise hs(T ) := max(hs(T1), hs(T2)).\nObviously we always have hs(T ) ≤ ht(T ).\nExample 3.2 For the tree T from Example 5.3 we have ht(T ) = 3, hs(T ) = 2. The Horton-Strahler numbers of the subtrees are as follows:\n2\n2 ♦♦♦\n♦♦♦ ♦♦♦\n♦♦♦ ♦\n1 ♦♦♦\n♦♦♦ ♦♦♦\n♦♦♦ ♦\n0 ⑧⑧ ⑧⑧ ⑧⑧ ⑧\n0 ❄❄\n❄❄ ❄❄\n❄ 1 ❖❖❖\n❖❖❖ ❖❖❖\n❖❖❖ ❖\n0 ⑧⑧ ⑧⑧ ⑧⑧ ⑧\n0 ❄❄\n❄❄ ❄❄\n❄\n1 ❖❖❖\n❖❖❖ ❖❖❖\n❖❖❖ ❖\n0 ⑧⑧ ⑧⑧ ⑧⑧ ⑧\n0 ❄❄\n❄❄ ❄❄\n❄\nDefinition 3.3 The hardness hd : CLS → N0 is defined for F ∈ CLS as follows:\n1. If F ∈ USAT , then hd(F ) is the minimum hs(T ) for T : F ⊢ ⊥.\n2. If F = ⊤, then hd(F ) := 0.\n3. If F ∈ SAT \\ {⊤}, then hd(F ) := maxϕ∈PASS{hd(ϕ ∗ F ) : ϕ ∗ F ∈ USAT }.\nHardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38]. Definition 3.3 defines hardness proof-theoretically; importantly, it can also be characterised algorithmically via necessary levels of generalised unit-clause propagation (see [36, 37, 38] for the details):\nLemma 3.4 Consider the reductions rk : CLS → CLS for k ∈ N0 as introduced in [53]; it is r1 unit-clause propagation, while r2 is (full, iterated) failed-literal elimination. Then hd(F ) for F ∈ CLS is the minimal k ∈ N0 such that for all ϕ ∈ PASS with ϕ ∗F ∈ USAT holds rk(ϕ ∗F ) = {⊥}, i.e., the minimal k such that rk detects unsatisfiability of any instantiation.\nWe can now define our main hierarchy, the UCk-hierarchy (with “UC” for “unitrefutation complete”) via (tree-)hardness:\nDefinition 3.5 For k ∈ N0 let UCk := {F ∈ CLS : hd(F ) ≤ k}.\nUC1 = UC is the class of unit-refutation complete clause-sets, as introduced in [26]. In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]). Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k ≥ 1. The class UC2 is the class of all clause-sets where unsatisfiability for any partial assignment is detected by failed-literal reduction (see Section 5.2.1 in [42] for the usage of failed literals in SAT solvers).\nA basic fact is that the classes UCk are stable under application of partial assignments, in other words, for F ∈ CLS and ϕ ∈ PASS we have hd(ϕ∗F ) ≤ hd(F ). For showing lower bounds on the hardness for unsatisfiable clause-sets, we can use the methodology developed in Subsection 3.4.2 of [53]. A simplified version of Lemma 3.17 from [53], sufficient for our purposes, is as follows (with a technical correction, as explained in Example 3.7):\nLemma 3.6 Consider C ⊆ USAT and a function h : C → N0. For k ∈ N0 let Ck := {F ∈ C : h(F ) ≥ k}. Then ∀F ∈ C : hd(F ) ≥ h(F ) holds if and only if UC0 ∩ C1 = ∅, and for all k ∈ N, F ∈ Ck and x ∈ lit(F ) there exist clause-sets F0, F1 ∈ CLS fulfilling the following three conditions:\n(i) n(Fε) < n(F ) for both ε ∈ {0, 1};\n(ii) hd(Fε) ≤ hd(〈x → ε〉 ∗ F ) for both ε ∈ {0, 1};\n(iii) F0 ∈ Ck or F1 ∈ Ck−1.\nProof: The given conditions are necessary for ∀F ∈ C : hd(F ) ≥ h(F ), since we can choose Fε := 〈v → ε〉 ∗ F for ε ∈ {0, 1}. To see sufficiency, assume for the sake of contradiction that there is F ∈ C with hd(F ) < h(F ), and consider such an F with minimal n(F ). If hd(F ) = 0, so h(F ) = 0 by assumption, and thus hd(F ) ≥ 1 would hold. So assume hd(F ) ≥ 1. It follows that there is a literal x ∈ lit(F ) with hd(〈x → 1〉 ∗ F ) < hd(F ). Let k := h(F ); so F ∈ Ck. By assumption there are F0, F1 ∈ CLS with hd(Fε) ≤ hd(〈x → ε〉 ∗ F ) for both ε ∈ {0, 1}, and F0 ∈ Ck or F1 ∈ Ck−1. If F0 ∈ Ck, then hd(F0) ≤ hd(F ) < k ≤ h(F0), while n(F0) < n(F ), contradicting minimality of F . And if F1 ∈ Ck−1, then hd(F1) ≤ hd(F ) − 1 < k − 1 ≤ h(F1), while n(F1) < n(F ), contradicting again minimality of F .\nLemma 3.17 in [53] doesn’t state the condition (i) from Lemma 3.6. The following example shows that this condition actually needs to be stated (that is, if we just have (ii) and (iii), then h doesn’t need to be a lower bound for hd); fortunately in all applications in [53] this (natural) condition is fulfilled.\nExample 3.7 Consider C := UC1 ∩ USAT . Define h : C → {0, 1, 2} as h(F ) = 0 iff ⊥ ∈ F , and h(F ) = 1 iff ⊥ /∈ F and there is v ∈ var(F ) with {v}, {v} ∈ F . So we have h(F ) = 2 if and only if for all literals x ∈ lit(F ) holds hd(〈x → 1〉 ∗ F ) = hd(〈x → 0〉 ∗F ) = 1. By definition we have UC0 ∩C1 = ∅. Now consider k ∈ {1, 2}, F ∈ Ck and x ∈ lit(F ). If h(F ) = 1, then let Fε := 〈x → ε〉 ∗ F , while otherwise Fε := F for ε ∈ {0, 1}. Now Conditions (ii), (iii) of Lemma 3.6 are fulfilled (if h(F ) = 1, then for Condition (iii) always F1 ∈ Ck−1 holds, while in case of h(F ) = 2 we always have F0 ∈ Ck). But by definition h is not a lower bound on hd.\nComplementary to “unit-refutation completeness”, there is the notion of “propagation-completeness” as investigated in [69, 15], yielding the class PC ⊂ UC. This was captured and generalised by a measure phd : CLS → N0 of “propagationhardness” along with the associated hierarchy, defined in [37, 38] as follows:\nDefinition 3.8 For F ∈ CLS we define the propagation-hardness (for short “p-hardness”) phd(F ) ∈ N0 as the minimal k ∈ N0 such that for all partial assignments ϕ ∈ PASS we have rk(ϕ ∗ F ) = r∞(ϕ ∗ F ), where rk : CLS → CLS is generalised UCP ([53, 59]), and r∞ : CLS → CLS applies all forced assignments, and can be defined by r∞(F ) := rn(F )(F ). For k ∈ N0 let PCk := {F ∈ CLS : phd(F ) ≤ k} (the class of propagation-complete clause-sets of level k).\nWe have PC = PC1. For k ∈ N0 we have PCk ⊂ UCk ⊂ PCk+1.\n3.2 W-Hardness and WCk A basic weakness of the standard notion of width-restricted resolution, which demands that both parent clauses must have length at most k for some fixed k ∈ N0 (the “width”; see [7]), is that even Horn clause-sets require unbounded width in this sense. The correct solution, as investigated and discussed in [53, 59], is to use the notion of “k-resolution” as introduced in [51], where only one parent clause needs to have length at most k (thus properly generalising unit-resolution). Nested input-resolution ([53, 59]) is the proof-theoretic basis of hardness, and approximates tree-resolution. In the same vein, k-resolution is the proof-theoretic basis of “w-hardness”, and approximates dag-resolution (see Theorem 6.12 in [59]):\nDefinition 3.9 The w-hardness whd : CLS → N0 (“width-hardness”) is defined for F ∈ CLS as follows:\n1. If F ∈ USAT , then whd(F ) is the minimum k ∈ N0 such that k-resolution refutes F , that is, such that T : F ⊢ ⊥ exists where for each resolution step R = C ⋄D in T we have |C| ≤ k or |D| ≤ k (this corresponds to Definition 8.2 in [53], and is a special case of widU introduced in Subsection 6.1 of [59]).\n2. If F = ⊤, then whd(F ) := 0. 3. If F ∈ SAT \\ {⊤}, then whd(F ) := max\nϕ∈PASS {whd(ϕ ∗ F ) : ϕ ∗ F ∈ USAT }.\nFor k ∈ N0 let WCk := {F ∈ CLS : whd(F ) ≤ k}.\nWe haveWC0 = UC0, WC1 = UC1, and for all k ∈ N0 holds UCk ⊆ WCk (this follows by Lemma 6.8 in [59] for unsatisfiable clause-sets, which extends to satisfiable clausesets by definition). For unsatisfiable F , whether whd(F ) = k holds for k ∈ {0, 1, 2} can be decided in polynomial time; this is non-trivial for k = 2 ([17]) and unknown for k > 2. Nevertheless, the clausal entailment problem F |= C for F ∈ WCk and fixed k ∈ N0 is decidable in polynomial time, as shown in Subsection 6.5 of [59], by actually using a slight strengthening of k-resolution, which combines width-bounded resolution and input resolution. While space-complexity of the decision F |= C for F ∈ UCk is linear (for fixed k), now for WCk space-complexity is O(ℓ(F )·n(F )O(k)).\nAs a special case of Theorem 6.12 in [59] we obtain for F ∈ USAT , n(F ) 6= 0, the following general lower bound on resolution complexity:\nCompR(F ) > b whd(F )2 n(F ) ,\nwhere b := e 1 8 = 1.1331484 . . ., while CompR(F ) ∈ N is the minimal number of different clauses in a (tree-)resolution refutation of F . Similar to Theorem 14 in [36] resp. Theorem 5.7 in [37, 38] we thus obtain:\nLemma 3.10 For F ∈ CLS and k ∈ N0, such that for every C ∈ prc0(F ) with |C| < n(F ) there exists a resolution proof of C from F using at most b (k+1)2 n(F )−|C| different clauses, we have whd(F ) ≤ k."
    }, {
      "heading" : "4 Minimal premise sets and doped clause-sets",
      "text" : "In this section we study “minimal premise sets”, “mps’s” for short, introduced in [62], together with the properties of “doped” clause-sets, generalising a construction used in [75]. Mps’s are generalisations of minimally unsatisfiable clause-sets stronger than irredundant clause-sets, while doping relates prime implicates and sub-mps’s.\nRecall that a clause-set F is minimally unsatisfiable if F ∈ USAT , while for all C ∈ F holds F \\ {C} ∈ SAT . The set of all minimally unsatisfiable clause-sets is MU ⊂ CLS; see [52] for more information. In other words, for F ∈ CLS we have F ∈ MU if and only if F |= ⊥ and F is minimal regarding this entailment relation. Now an mps is a clause-set F which minimally implies some clause C, i.e., F |= C, while F ′ 6|= C for all F ′ ⊂ F . In Subsection 4.1 we study the basic properties of mps’s F , and determine the unique minimal clause implied by F as puc(F ), the set of pure literals of F .\nFor a clause-set F its doped version D(F ) ∈ CLS receives an additional new (“doping”) variable for each clause. The basic properties are studied in Subsection 4.2, and in Theorem 4.18 we show that the prime implicates of D(F ) correspond 1-1 to the mps’s contained in F . In Subsection 4.3 we determine the hardness of doped clause-sets."
    }, {
      "heading" : "4.1 Minimal premise sets",
      "text" : "In Section 4.1 in [62] basic properties of minimal premise sets are considered:\nDefinition 4.1 A clause-set F ∈ CLS is a minimal premise set (“mps”) for a clause C ∈ CL if F |= C and ∀F ′ ⊂ F : F ′ 6|= C, while F is a minimal premise set if there exists a clause C such that F is a minimal premise set for C. The set of all minimal premise (clause-)sets is denoted by MPS.\nRemarks:\n1. ⊤ is not an mps (since no clause follows from ⊤).\n2. An unsatisfiable clause-set is an mps iff it is minimally unsatisfiable, i.e., MPS ∩ USAT = MU . In Corollary 4.8 we will see that the minimally unsatisfiable clause-sets are precisely the mps’s without pure literals.\n3. Every minimal premise clause-set is irredundant (no clause follows from the other clauses).\n4. For a clause-set F and any implicate F |= C there exists a minimal premise sub-clause-set F ′ ⊆ F for C.\n5. A single clause C yields an mps {C}.\n6. Two clauses C 6= D yield an mps {C,D} iff C,D are resolvable.\n7. If F1, F2 ∈ MPS with var(F1)∩ var(F2) = ∅, then F1 ∪F2 /∈ MPS except in case of F1 = F2 = {⊥}.\nExample 4.2 {{a}, {b}} for variables a 6= b is irredundant but not an mps.\nWith Corollary 4.5 in [62] we see that no clause-set can minimally entail more than one clause:\nLemma 4.3 For F ∈ MPS there exists exactly one C ∈ prc0(F ) such that C is a minimal premise set for C, and C is the smallest element of the set of clauses for which F is a minimal premise set.\nWe remark that Lemma 4.3 does not mean that |prc0(F )| = 1 for F ∈ MPS; indeed, F can have many F ′ ⊂ F with F ′ ∈ MPS, and each such F ′ might contribute a prime implicate, as we will see later. We wish now to determine that unique prime implicate C which follows minimally from an mps F . It is clear that C must contain all pure literals from F , since all clauses of F must be used, and we can not get rid off pure literals.\nDefinition 4.4 For F ∈ CLS the pure clause of F , denoted by puc(F ) ∈ CL, is the set of pure literals of F , that is, puc(F ) := L \\ (L ∩ L), where L := ⋃F is the set of literals occurring in F .\nExample 4.5 For F = {{a, b}, {a, c}} we have puc(F ) = {b, c}.\nThe main observation for determining C is that the conclusion of a regular resolution proof consists precisely of the pure literals of the axioms (this follows by definition):\nLemma 4.6 For a regular resolution proof T : F ⊢ C, where every clause of F is used in T , we have C = puc(F ).\nDue to the completeness of regular resolution we thus see, that puc(F ) is the desired unique prime implicate:\nLemma 4.7 For F ∈ MPS the unique prime implicate C, for which F is a minimal premise set (see Lemma 4.3), is C = puc(F ).\nProof: Consider a regular resolution proof T : F ⊢ C (recall that regular resolution is complete); due to F ∈ MPS every clause of F must be used in T , and thus the assertion follows by Lemma 4.6.\nCorollary 4.8 If we have F ∈ MPS with puc(F ) = ⊥, then F ∈ MU.\nBy Lemma 4.4 in [62] we get the main characterisation of mps’s, namely that after elimination of pure literals they must be minimally unsatisfiable:\nLemma 4.9 Consider a clause-set F ∈ CLS. Then F ∈ MPS if and only if the following two conditions hold for ϕ := ϕpuc(F ) (setting precisely the pure literals of F to false):\n1. ϕ∗F ∈ MU (after removing the pure literals we obtain a minimal unsatisfiable clause-sets).\n2. ϕ is contraction-free for F , that is, for clauses C,D ∈ F with C 6= D we have ϕ ∗ {C} 6= ϕ ∗ {D}.\nThese two conditions are equivalent to stating that ϕ ∗ F as a multi-clause-set (not contracting equal clauses) is minimally unsatisfiable.\nThus we obtain all mps’s by considering some minimally unsatisfiable clause-sets and adding new variables in the form of pure literals:\nCorollary 4.10 The following process generates precisely the F ′ ∈ MPS:\n1. Choose F ∈ MU .\n2. Choose a clause P with var(P ) ∩ var(F ) = ∅ (“P” like “pure”).\n3. Choose a map e : F → P(P ) (“e” like “extension”).\n4. Let F ′ := {C ∪ e(C) : C ∈ F}. For unsatisfiable clause-sets the set of minimally unsatisfiable sub-clause-sets has been studied extensively in the literature; see [66] for a recent overview. The set of subsets which are mps’s strengthen this notion (now for all clause-sets):\nDefinition 4.11 For a clause-set F ∈ CLS by mps(F ) ⊂ CLS the set of all minimal premise sub-clause-sets is denoted: mps(F ) := P(F ) ∩MPS.\nWe have |mps(F )| ≤ 2c(F )−1.5) The minimal elements of mps(F ) are {C} ∈ mps(F ) for C ∈ F . Since every prime implicate of a clause-set has some minimal premise sub-clause-set, we get that running through all sub-mps’s in a clause-set F and extracting the clauses with the pure literals we obtain at least all prime implicates:\nLemma 4.12 For F ∈ CLS the map F ′ ∈ mps(F ) 7→ puc(F ′) ⊆ {C ∈ CL : F |= C} covers prc0(F ) (i.e., its range contains the prime implicates of F ).\nExample 4.13 Examples where we have more minimal premise sub-clause-sets than prime implicates are given by F ∈ MU , where prc0(F ) = {⊥}, while in the most extreme case every non-empty subset of F can be a minimal premise subclause-set (see Theorem 5.12)."
    }, {
      "heading" : "4.2 Doping clause-sets",
      "text" : "“Doping” is the process of adding a unique new variable to every clause of a clauseset. It enables us to follow the usage of this clause in derivations:\nDefinition 4.14 For every clause-set F ∈ CLS we assume an injection uF : F → VA\\var(F ) in the following, assigning to every clause C a different variable uFC. For a clause C ∈ CL and a clause-set F ∈ CLS we then define the doping DF (C) := C ∪ {uFC} ∈ CL, while D(F ) := {DF (C) : C ∈ F} ∈ CLS.\nRemarks:\n1. In the following we drop the upper index in “uFC”, i.e., we just use “uC”.\n2. We have D : CLS → SAT .\n3. For F ∈ CLS we have n(D(F )) = n(F ) + c(F ) and c(D(F )) = c(F ).\n4. For F ∈ CLS we have puc(D(F )) = puc(F ) ∪ {uC : C ∈ F}. We are interested in the prime implicates of doped clause-sets. It is easy to see that all doped clauses are themselves essential prime implicates:\nLemma 4.15 For F ∈ CLS we have D(F ) ⊆ prc0(D(F )), and furthermore all elements of D(F ) are essential prime implicates.\nProof: Every resolvent of clauses from D(F ) contains at least two doping variables, and thus the clauses of D(F ) themselves (which contain only one doping variable) are prime and necessary. Thus by Lemma 2.3 among all the clause-sets equivalent to D(F ) this clause-set itself is the smallest. Directly by Lemma 4.9 we get that a clause-set is an mps iff its doped form is an mps:\n5)There is a typo in Corollary 4.6 of [62], misplacing the “−1” into the exponent.\nLemma 4.16 For F ∈ CLS holds F ∈ MPS ⇔ D(F ) ∈ MPS. Thus the map F ′ ∈ mps(F ) 7→ D(F ′) is a bijection from mps(F ) to mps(D(F )).\nFor doped clause-sets the surjection of Lemma 4.12 is bijective:\nLemma 4.17 Consider a clause-set F ∈ CLS, and let G := D(F ).\n1. The map F ′ ∈ mps(G) 7→ puc(F ′) ∈ CL is a bijection from mps(G) to prc0(G).\n2. The inverse map from prc0(G) to mps(G) obtains from C ∈ prc0(G) the clause-set F ′ ∈ mps(G) with puc(F ′) = C as F ′ = {D(D) : D ∈ F ∧ uD ∈ var(C)}.\nProof: By Lemma 4.12 it remains to show that the map of Part 1 is injective and does not have subsumptions in the image. Assume for the sake of contradiction there are G′, G′′ ∈ mps(G), G′ 6= G′′, with puc(G′) ⊆ puc(G′′). Since every clause of F has a different doping-variable, G′ ⊂ G′′ must hold. Consider the F ′, F ′′ ∈ mps(F ) with D(F ′) = G′ and D(F ′′) = G′′. We have F ′ ⊂ F ′′, and thus puc(F ′) 6⊆ puc(F ′′), since for every F ∈ MPS the clause puc(F ) is a prime implicate of F . It follows that puc(G′) 6⊆ puc(G′′), contradicting the assumption.\nBy Lemma 4.16 and Lemma 4.17 we obtain:\nTheorem 4.18 Consider F ∈ CLS. Then the map F ′ ∈ mps(F ) 7→ puc(D(F ′)) ∈ CL is a bijection from mps(F ) to prc0(D(F )).\nTheorem 4.18 together with the description of the inversion map in Lemma 4.17 yields computation of the set mps(F ) for F ∈ CLS via computation of prc0(D(F )).\nCorollary 4.19 For F ∈ CLS we obtain a map from prc0(D(F )) to the set of implicates of F covering prc0(F ) by the mapping C ∈ prc0(D(F )) 7→ C \\ V for V := {uC : C ∈ F}.\nProof: The given map can be obtained as a composition as follows: For C ∈ prc0(D(F )) take (the unique) F\n′ ∈ mps(F ) with puc(D(F ′)) = C, and we have C \\ V = puc(F ′)."
    }, {
      "heading" : "4.3 Hardness of doped clause-sets",
      "text" : "The hardness of a doped clause-set is the maximal hardness of sub-clause-sets of the original clause-set:\nLemma 4.20 For F ∈ CLS we have hd(D(F )) = maxF ′⊆F hd(F ′).\nProof: We have hd(F ′) ≤ hd(D(F )) for all F ′ ⊆ F , since via applying a suitable partial assignment we obtain F ′ from F , setting the doping-variables in F ′ to false, and the rest to true. And if we consider an arbitrary partial assignment ϕ with ϕ∗D(F ) ∈ USAT , then w.l.o.g. all doping variables are set (we can set the dopingvariables not used by ϕ to true, since these variables are all pure), and then we have a partial assignment making F ′ unsatisfiable for that F ′ ∈ USAT given by all the doping variables set by ϕ to false.\nExample 4.21 For an example of a clause-set F ∈ USAT with hd(D(F )) > hd(F ) consider any clause-set F ′ ∈ CLS with hd(F ′) > 0, and then take F := F ′ ∪ {⊥} (note that ⊥ /∈ F ′). Thus hd(F ) = 0. And by Part 1 of Lemma 6.5 in [37, 38], all UCk are closed under partial assignments, so for ϕ := 〈u⊥ → 1〉∪〈uC → 0 | C ∈ F ′〉 we have hd(D(F )) ≥ hd(ϕ ∗D(F )) = hd(F ′) > hd(F ) = 0."
    }, {
      "heading" : "5 Doping tree clause-sets",
      "text" : "As explained in Subsection 1.5, we want to construct boolean functions (given by clause-sets) with a large number of prime implicates, and where we have strong control over these prime implicates. For this purpose we dope “minimally unsatisfiable clause-sets of deficiency 1”, that is the elements of SMUδ=1. First we review in Subsection 5.1 the background (for more information see [52]). In Subsection 5.2 we show that these clause-sets are the core of “total minimal premise sets”, which have as many minimal-premise sub-clause-sets as possible. In Theorem 5.12 we show that F ∈ SMUδ=1 are precisely the unsatisfiable clause-sets such that every non-empty subset is an mps. Then in Subsection 5.3 we consider doping of these special clause-sets, and in Theorem 5.22 we determine basic properties of D(F )."
    }, {
      "heading" : "5.1 Preliminaries on minimal unsatisfiability",
      "text" : "A minimally unsatisfiable F ∈ MU is saturated minimally unsatisfiable iff for all clauses C ∈ F and for every literal x with var(x) /∈ var(C) the clause-set (F \\C) ∪ (C ∪ {x}) is satisfiable. The set of all saturated minimally unsatisfiable clause-sets is denoted by SMU ⊂ MU . By SMUδ=k we denote the set of F ∈ SMU with δ(F ) = k, where the deficiency of a clause-set F is given by δ(F ) := c(F )− n(F ). In [56] (generalised in [62]) it is shown that the elements of SMUδ=1 are exactly the clause-sets introduced in [21]. The details are as follows. For rooted trees T we use nds(T ) for the set of nodes and lvs(T ) ⊆ lvs(T ) for the set of leaves, and we set #nds(T ) := |nds(T )| and #lvs(T ) := |lvs(T )|. In our context, the nodes of rooted trees are just determined by their positions, and do not have names themselves. Another useful notation for a tree T and a node w is Tw, which is the sub-tree of T with root w; so lvs(T ) = {w ∈ nds(T ) : #nds(Tw) = 1}. Recall that for a full binary tree T (every non-leaf node has two children) we have #nds(T ) = 2#lvs(T )− 1.\nDefinition 5.1 Consider a full binary tree T and an injective vertex labelling u : (nds(T ) \\ lvs(T )) → VA for the inner nodes; the set of all such pairs is denoted by T1. The induced edge-labelling assigns to every edge from an inner node w to a child w′ the literal u(w) resp. u(w) for a left resp. right child. We define the clause-set representation F1(T, u) (where “1” reminds of deficiency 1 here; see Lemma 5.2) to be F1(T, u) := {Cw : w ∈ lvs(T )}, where clause Cw consists of all the literals (i.e., edge-labels) on the path from the root of T to w.\nBy Lemma C.5 in [56]:\nLemma 5.2 F1 : T1 → SMUδ=1 is a bijection.\nBy T1 : SMUδ=1 → T1 we denote the inversion of F1. Typically we identify (T, u) ∈ T1 with T , and let the context determine u. So T1(F ) is the full binary tree, where the variable v labelling the root (for F 6= {⊥}) is the unique variable occurring in every clause of F , and the clause-sets determining the left resp. right subtree are 〈v → 0〉∗F resp. 〈v → 1〉∗F . By wC for C ∈ F we denote the leaf w of T1(F ) such that Cw = C. Furthermore we identify the literals of F with the edges of T1(F ). Note that c(F ) = #lvs(T1(F )) and n(F ) = #nds(T1(F ))−#lvs(T1(F )).\nExample 5.3 Consider the following labelled binary tree T :\nv1\nv2\nv1 ♦♦♦ ♦♦♦\n♦♦♦ ♦♦ ♦\nv3\nv2 ♦♦♦ ♦♦♦\n♦♦♦ ♦♦♦\n1\nv3 ⑧⑧ ⑧⑧ ⑧⑧ ⑧\n2\nv3\n❄❄ ❄❄\n❄❄ ❄ v4\nv2\n❖❖❖ ❖❖❖\n❖❖❖ ❖❖❖\n3\nv4 ⑧⑧ ⑧⑧ ⑧⑧ ⑧\n4\nv4\n❄❄ ❄❄\n❄❄ ❄\nv5\nv1\n❖❖❖ ❖❖❖\n❖❖ ❖❖❖\n❖\n5\nv5 ⑧⑧ ⑧⑧ ⑧⑧ ⑧\n6\nv5\n❄❄ ❄❄\n❄❄ ❄\nThen F1(T ) = {{v1, v2, v3}, {v1, v2, v3}, {v1, v2, v4}, {v1, v2, v4}, {v1, v5}, {v1, v5}}, where for example C3 = {v1, v2, v4} and w{v1,v5} = 6.\nWe note in passing, that those F1(T ) with hs(T ) ≤ 1 can be easily characterised as follows. A clause C ∈ F for F ∈ CLS is called full if var(C) = var(F ), that is, C contains all variables of F .\nLemma 5.4 F ∈ SMUδ=1 contains a full clause if and only if hs(T1(F )) ≤ 1.\nSee Example 6.10 for more on these special clause-sets. The effect of applying a partial assignment to some element of SMUδ=1 is easily described as follows:\nLemma 5.5 Consider F ∈ SMUδ=1 and x ∈ lit(F ), and let F ′ := 〈x → 1〉 ∗ F . We have:\n1. F ′ ∈ SMUδ=1.\n2. Let T := T1(F ) and T ′ := T1(F ′). The tree T ′ is obtained from T as follows:\n(a) Consider the node w ∈ T labelled with var(x). Let Tx, Tx be the two subtrees hanging at w, following the edge labelled with x resp. x. (b) Now T ′ is obtained from T ′ by removing subtree Tx, and attaching Tx directly at position w.\nExample 5.6 Consider the labelled binary tree T from Example 5.3 where\nF1(T ) = {{v1, v2, v3} ︸ ︷︷ ︸\nC1\n, {v1, v2, v3} ︸ ︷︷ ︸\nC2\n, {v1, v2, v4} ︸ ︷︷ ︸\nC3\n, {v1, v2, v4} ︸ ︷︷ ︸\nC4\n, {v1, v5} ︸ ︷︷ ︸\nC5\n, {v1, v5} ︸ ︷︷ ︸\nC6\n}\nNow consider the application of the partial assignment 〈v2 → 1〉 to F1(T ):\n1. Clauses C1 and C2 are satisfied, and so are removed (both contain v2).\n2. Clauses C3 and C4 both contain v2 and so this literal is removed.\nThis yields:\n〈v2 → 1〉 ∗ F1(T ) = { {v1, v4} ︸ ︷︷ ︸\nC3 \\ {v2}\n, {v1, v4} ︸ ︷︷ ︸\nC4 \\ {v2}\n, {v1, v5} ︸ ︷︷ ︸\nC5\n, {v1, v5} ︸ ︷︷ ︸\nC6\n}\nThe satisfaction (removal) of clauses and removal of literals is illustrated directly on T in Figure 1 with dotted and dashed lines for clause and literal removal respectively. The tree corresponding to 〈v2 → 1〉 ∗ F1(T ) is illustrated in Figure 2.\nCorollary 5.7 SMUδ=1 is stable under application of partial assignments, that is, for F ∈ SMUδ=1 and ϕ ∈ PASS holds ϕ ∗ F ∈ SMUδ=1.\nFrom Lemma 5.2 follows SMUδ=1 ⊂ UHIT , where HIT ⊂ CLS is the set of hitting clause-sets, that is, those F ∈ CLS where every two clauses clash in at least one literal, i.e., for all C,D ∈ F , C 6= D, we have |C ∩ D| ≥ 1, and UHIT := HIT ∩USAT . It is well-known that UHIT ⊂ SMU holds (for a proof see Lemma 2 in [63])."
    }, {
      "heading" : "5.2 Total minimal premise sets",
      "text" : "We are interested in clause-sets which have as many sub-mps’s as possible:\nDefinition 5.8 A clause-set F 6= ⊤ is a total mps if mps(F ) = P(F ) \\ {⊤}.\nEvery total mps is an mps.\nExample 5.9 {{a, b}, {a, b}, {b}} is a total mps, while {{a, b}, {a}, {b}} is an mps (since minimally unsatisfiable), but not a total mps.\nTo determine all total mps’s, the central task to determine the minimally unsatisfiable total mps’s. Before we can prove that these are precisely the saturated minimally unsatisfiable clause-sets of deficiency 1, we need to state a basic property of these clause-sets, which follows by definition of T1(F ) for F ∈ SMUδ=1 (recall Subsection 5.1):\nLemma 5.10 Consider F ∈ SMUδ=1 and F ′ ⊆ F . Let T := T1(F ). The set puc(F ′) of pure literals of F ′ can be determined as follows:\n1. Let WF ′ := {wC : C ∈ F ′} ⊆ lvs(T ) be the set of leaves corresponding to the clauses of F ′.\n2. For a literal x ∈ lit(F ) let w ∈ nds(T ) be the node labelled with var(x), and let Tx the the subtree of w reached by x, and let Tx be the subtree of w reached by x.\n3. Now x ∈ puc(F ′) if and only if WF ′ ∩ lvs(Tx) 6= ∅ and WF ′ ∩ lvs(Tx) = ∅.\nExample 5.11 Consider the clause-set\nF := { {v1, v2, v3} ︸ ︷︷ ︸\nC1\n, {v1, v2, v3} ︸ ︷︷ ︸\nC2\n, {v1, v2, v4} ︸ ︷︷ ︸\nC3\n, {v1, v2, v4} ︸ ︷︷ ︸\nC4\n,\n{v1, v5, v6} ︸ ︷︷ ︸\nC5\n, {v1, v5, v6} ︸ ︷︷ ︸\nC6\n, {v1, v5} ︸ ︷︷ ︸\nC7\n}\nand the subset F ′ := {C1, C3, C4, C7}. The tree T1(F ) is as follows, with the dashed edges representing literals not in ⋃ F ′ = {v1, v2, v3, v4, v1, v2, v4, v5}:\nv1\nv2\nv1\n❥❥❥ ❥❥❥\n❥❥❥ ❥❥❥\n❥❥❥ ❥\nv3\nv2\n♦♦♦ ♦♦♦\n♦♦♦ ♦♦\n1\nv3 ⑧⑧ ⑧⑧ ⑧⑧\n2\nv3\n❄ ❄\n❄ v4\nv2\n❖❖❖ ❖❖❖\n❖❖❖ ❖❖\n3\nv4 ⑧⑧ ⑧⑧ ⑧⑧\n4\nv4 ❄❄ ❄❄\n❄❄\nv5\nv1\n❚❚❚ ❚❚❚\n❚❚❚ ❚❚❚\n❚❚❚ ❚\nv6\nv5 ⑧ ⑧ ⑧\n5\nv6 ⑧ ⑧ ⑧\n6\nv6\n❄ ❄\n❄ 7\nv5 ❄❄ ❄❄\n❄❄\nWe have WF ′ = {1, 3, 4, 7} and\npuc(F ′) = ⋃\nF ′ \\ { v2, v2 ︸ ︷︷ ︸\nC1, C3\n, v1, v1 ︸ ︷︷ ︸\nC1, C7\n, v4, v4 ︸ ︷︷ ︸\nC3, C4\n} = {v3, v5}.\nNow consider x ∈ lit(F ):\n1. For x = v3 holds lvs(Tv3)∩WF ′ = {1} and Tv3 ∩WF ′ = ∅, thus v3 ∈ puc(F ′).\n2. For x = v5 holds lvs(Tv5)∩WF ′ = {7} and Tv5 ∩WF ′ = ∅, thus v5 ∈ puc(F ′).\n3. Considering for example x = v1, we have lvs(Tv1)∩WF ′ = {1, 3} and lvs(Tv1)∩ WF ′ = {7}, thus v1 /∈ puc(F ′), while for x = v6 we have lvs(Tv6) ∩WF ′ = ∅ and lvs(Tv6) ∩WF ′ = ∅, thus v6 /∈ puc(F ′).\nTheorem 5.12 An unsatisfiable clause-set F ∈ USAT is a total mps if and only if F ∈ SMUδ=1.\nProof: First assume that F is a total mps. Then every two clauses C,D ∈ F , C 6= D, clash in exactly one literal (otherwise {C,D} /∈ MPS). In [58], Corollary 34, it was shown that that an unsatisfiable clause-sets F has precisely one clash between any pair of different clause-sets iff F ∈ SMUδ=1 holds (an alternative proof was found in [75]).6) Now assume F ∈ SMUδ=1, and we have to show that F\n6)In [58] the notation “UHIT ” was used to denote “uniform hitting clause-sets”, which is now more appropriately called “(conflict-)regular hitting clause-sets”, while “U” now stands for “unsatisfiable”.\nis a total mps. So consider F ′ ∈ P(F ) \\ {⊤}, and let C := puc(F ), ϕ := ϕC . Since F ′ is a hitting clause-set, ϕ is contraction-free for F ′, and according to Lemma 4.9 it remains to show that F ′′ := ϕ ∗ F ′ is unsatisfiable (recall that hitting clause-sets are irredundant). Assume that F ′′ is satisfiable, and consider a partial assignment ψ with ψ ∗ F ′′ = ⊤ and var(ψ) ∩ var(ϕ) = ∅. We show that then ϕ ∪ ψ would be a satisfying assignment for F , contradicting the assumption. To this end it suffices to show that for all D ∈ F \\ F ′ holds C ∩D 6= ∅. Consider T := T1(F ), and let WF ′ be defined as in Lemma 5.10. Starting from the leaf wD, let w be the first node on the path to the root of T such that one of the two subtrees of w contains a leaf of WF ′ . Let x be the literal at w on the path to wD. So by Lemma 5.10 we have x ∈ C, while by definition x ∈ D.\nCorollary 5.13 For a clause-set F ∈ CLS the following properties are equivalent:\n1. F is a total mps.\n2. ϕpuc(F ) ∗ F ∈ SMUδ=1, and ϕpuc(F ) is contraction-free for F .\nProof: Let F ′ := ϕpuc(F ) ∗ F . If F is a total mps, then by Lemma 4.9 follows F ′ ∈ MU , where ϕpuc(F ) is contraction-free for F . Also by Lemma 4.9 follows then, that F ′ ∈ MPS, and thus by Theorem 5.12 we obtain F ′ ∈ SMUδ=1. For the other direction, if F ′ ∈ SMUδ=1 holds, where ϕpuc(F ) is contraction-free for F , then by Theorem 5.12 follows that F ′ is a total mps, which by Lemma 4.9 yields that F is a total mps.\nThus we can precisely construct all total mps’s, if we start the process described in Corollary 4.10 not with an arbitrary F ∈ MU , but with an F ∈ SMUδ=1.\nExample 5.14 That every 2-element sub-clause-set of F ∈ CLS is an mps, that is, every two (different) clauses of F clash in precisely one literal, says that F is 1-regular hitting in the terminology of [62], Section 6. For F ∈ USAT the proof of Theorem 5.12 shows, that F is a total mps iff F is 1-regular hitting. However for F ∈ SAT this is not true, and the simplest example is F := {{a, b}, {b, c}, {c, a}}: F is 1-regular hitting, but has no pure literal and is satisfiable, and thus F /∈ MPS. In this case we have δ(F ) = 0. For an interesting example with deficiency 1 see Section 5 in [58].\nWe arrive at a simple and perspicuous proof of the main result of [75], that the clause-sets F with |prc0(F )| = 2c(F ) − 1 are precisely the clause-sets D(F ) for F ∈ SMUδ=1 when allowing to replace the single doping variable of a clause by any non-empty set of new (pure) literals:\nLemma 5.15 For F ∈ CLS \\ {⊤} holds |prc0(F )| = 2c(F ) − 1 if and only if the following two conditions hold:\n1. F is a total mps.\n2. For every clause C ∈ F there is x ∈ C such that var(x) /∈ var(F \\ {C}).\nProof: First assume |prc0(F )| = 2c(F ) − 1. Thus the map F ′ ∈ mps(F ) 7→ puc(F ′) ⊆ {C ∈ CL : F |= C}, which according to Lemma 4.12 covers prc0(F ), must indeed be a bijection from mps(F ) to prc0(F ), and hence F is a total mps (here we need F 6= ⊤). If there would be C ∈ F such that for all x ∈ C we have var(x) ∈ var(F \\ {C}), then puc(F ) ⊆ puc(F \\ {C}), and thus F \\ {C} could not yield a prime implicate different from the prime implicate obtained from F .\nThe inverse direction follows by the observation, that the existence of the unique “doping literals” x ∈ C has the consequence, that for ⊤ ⊂ F ′, F ′′ ⊆ F with F ′ 6= F ′′ we get puc(F ′) 6= puc(F ′′), since these doping literals make a difference."
    }, {
      "heading" : "5.3 Doping SMUδ=1",
      "text" : "We are turning now our attention to a closer understanding of the prime implicates C of doped F ∈ SMUδ=1. We start with their identification with non-empty subclause-sets F ′ of D(F ):\nLemma 5.16 Consider a clause-set F ∈ SMUδ=1. By Theorem 5.12 each nonempty subset yields a minimal premise set. Thus by Theorem 4.18 we have:\n1. prc0(D(F )) = {puc(F ′) | ⊤ 6= F ′ ⊆ D(F )}.\n2. |prc0(D(F ))| = 2c(F ) − 1.\nSince the clauses of D(F ) can be identified with leaves of the tree T1(F ), we obtain a bijection between non-empty sets V of leaves of the tree T1(F ) and prime implicates of D(F ):\nDefinition 5.17 For F ∈ SMUδ=1 and ∅ 6= V ⊆ lvs(T1(F )) the clause CV is the prime implicate puc({Cw ∈ F | w ∈ V }) of D(F ) according to Lemma 5.16. For w ∈ lvs(T1(F )) we furthermore set uw := uCw .\nBy Lemma 5.16:\nLemma 5.18 For F ∈ SMUδ=1 holds prc0(D(F )) = {CV | ∅ 6= V ⊆ lvs(T1(F ))}.\nHow precisely from V ⊆ lvs(T1(F )) the prime implicate CV is constructed shows the following lemma:\nLemma 5.19 Consider F ∈ SMUδ=1 and ∅ 6= V ⊆ lvs(T1(F )). We have CV = UV ∪ PV , UV ∩ PV = ∅, where\n1. UV := {uw | w ∈ V }, and\n2. PV := puc(F ′) for F ′ := {Cw : w ∈ V } as given in Lemma 5.10, that is, PV\nis the set of literals x such that V ∩ lvs(Tx) 6= ∅ and V ∩ lvs(Tx) = ∅.\nExample 5.20 Consider the clause-set\nF := {{v1, v2}, {v1, v2}, {v1, v3}, {v1, v3}} ∈ SMUδ=1\ncorresponding to the tree\nv1\nv2\nv1 ♦♦♦ ♦♦♦\n♦♦♦ ♦♦♦\n1\nv2 ⑧⑧ ⑧⑧ ⑧⑧ ⑧\n2\nv2\n❄❄ ❄❄\n❄❄ ❄ v3\nv1\n❖❖❖ ❖❖❖\n❖❖ ❖❖❖\n❖\n3\nv3 ⑧⑧ ⑧⑧ ⑧⑧ ⑧\n4\nv3\n❄❄ ❄❄\n❄❄ ❄\nwith the doped clause-set\nD(F ) = {{v1, v2, u1}, {v1, v2, u2}, {v1, v3, u3}, {v1, v3, u4}}.\nNow consider the set V := {1, 3}. According to Definition 5.17 we have that CV = puc({{v1, v2, u1}, {v1, v3, u3}}) = {v2, v3, u1, u3}. By Lemma 5.19 we have that CV = UV ∪ PV , where UV = {u1, u3} and PV = puc({{v1, v2}, {v1, v3}} = {v2, v3}. Note that for both x ∈ {v2, v3} = PV we have that lvs(Tx)∩V 6= ∅ and lvs(Tx)∩V = ∅, but we do not have this for x ∈ lit(F ) \\ {v2, v3}.\nThe hardness of F as well as D(F ) is the Horton-Strahler number of T1(F ):\nLemma 5.21 Consider F ∈ SMUδ=1, and let k := hs(T1(F )). Then we have hd(F ) = hd(D(F )) = k.\nProof: Let T := T1(F ). First we show hd(F ) = k. We have hd(F ) ≤ k, since T is by definition of F = F1(T ) already a resolution tree (when extending the labelling of leaves to all nodes), deriving ⊥ from F . To show hd(F ) ≥ k, we use Lemma 3.6 with C := SMUδ=1 and h(F ) := hs(T1(F )). Based on Lemma 5.5, we consider the effect on the Horton-Strahler number of assigning a truth value to one variable v ∈ var(F ). Let w ∈ nds(T ) be the (inner) node labelled with v, and let Tw0 , Tw1 be the left resp. right subtree hanging at w. Now the effect of assigning ε ∈ {0, 1} to v is to replace Tw with T w ε . Let Tε be the (whole) tree obtained by assigning ε to v, that is, Tε := T 1(〈v → ε〉 ∗ F ). If hs(Tw0 ) = hs(Tw1 ), then we have hs(Tε) ≥ k − 1, since at most one increase of the Horton-Strahler number for subtrees is missed out now. Otherwise we have hs(T0) = hs(T ) or hs(T1) = hs(T ), since removal of the subtree with the smaller Horton-Strahler number has no influence on the HortonStrahler number of the whole tree. So altogether Lemma 3.6 is applicable, which concludes the proof of hd(F ) = k.\nFor showing hd(D(F )) = k we use Lemma 4.20: so consider F ′ ⊆ F and ϕ ∈ PASS with ϕ ∗ F ′ ∈ USAT , let F ′′ := ϕ ∗ F ′, and we have to show hd(F ′′) ≤ k. W.l.o.g. var(ϕ) ⊆ var(F ′). By Corollary 5.7 we have that ϕ ∗ F ∈ SMUδ=1, and thus ϕ ∗ F = F ′′ must hold, and hd(F ′′) = hs(T1(F ′′)) (by the first part). By Lemma 5.5, T1(F ′′) results from T by a sequence of removing subtrees, and it is easy to see, that thus hs(T1(F ′′)) ≤ k holds.\nWe summarise what we have learned about D(F ) for F ∈ SMUδ=1:\nTheorem 5.22 Consider F ∈ SMUδ=1.\n1. For each clause-set F ′ equivalent to D(F ) there is an injection i : D(F ) → F ′ with ∀C ∈ D(F ) : C ⊆ i(C) (by Lemma 4.15).\n2. D(F ) is a total mps (by Corollary 5.13).\n3. The prime implicates of D(F ) are given by Lemmas 5.18, 5.19.\n4. hd(D(F )) = hs(T1(F )) (by Lemma 5.21)."
    }, {
      "heading" : "6 Lower bounds",
      "text" : "This section proves the main result of this article, Theorem 6.14, which exhibits for every k ≥ 0 sequences (F kh )h∈N of small clause-sets of hardness k + 1, where every equivalent clause-set of hardness k (indeed of w-hardness k) is of exponential size. In this way we show that the UCk hierarchy is useful, i.e., equivalent clause-sets with higher hardness can be substantially shorter. These F kh are doped versions of clause-sets from SMUδ=1 (recall Theorem 5.22), which are “extremal”, that is, their underlying trees T1(F kh ) are for given Horton-Strahler number k+1 and height h as large as possible.\nThe organisation of this section is as follows: In Subsection 6.1 the main tool for showing size-lower-bounds for equivalent clause-sets of a given (w-)hardness is established in Theorem 6.4. Subsection 6.2 introduces the “extremal trees”. Subsection 6.3 shows the main lower bound in Theorem 6.13, and applies it to show the separation Theorem 6.14."
    }, {
      "heading" : "6.1 Trigger hypergraphs",
      "text" : "Our goal is to construct clause-sets F kh of hardness k + 1, which have no short equivalent clause-set F with whd(F ) ≤ k, where w.l.o.g. F ⊆ prc0(F kh ) = prc0(F ). This subsection is about the general lower-bound method. How are we going to find a lower bound on the number of clauses of F ? The property whd(F ) ≤ k means, that for every C ∈ prc0(F ) the unsatisfiable clause-set ϕC ∗ F can be refuted by k-resolution. In order for k-resolution to have a chance, there must be at least one clause of length at most k in ϕC ∗ F — and this necessary condition is all what we consider. So our strategy is to show that every F ⊆ prc0(F kh ), such that for all C ∈ prc0(F kh ) there is a clause of length at most k in ϕC ∗ F , is big.\nIt is useful to phrase this approach in hypergraph terminology. Recall that a hypergraph is a pair G = (V,E), where V is a set (of “vertices”) and E ⊆ P(V ) (the set of hyperedges), where one uses V (G) := V and E(G) := E. A transversal of G is a set T ⊆ V (G) such that for all E ∈ E(G) holds T ∩E 6= ∅. The minimum size of a transversal is denoted by τ(G), the transversal number.\nDefinition 6.1 Consider k ∈ N0 and F ∈ CLS. The trigger hypergraph Tk(F ) is the hypergraph with the prime implicates of F as its vertices, and for every prime implicate C of F a hyperedge EkC . The hyperedge E k C contains all prime implicates C′ ∈ prc0(F ) which are not satisfied by ϕC and yield a clause of size at most k under ϕC . That is,\n1. V (Tk(F )) := prc0(F ), and\n2. E(Tk(F )) := {EkC | C ∈ prc0(F )}, where EkC := {C′ ∈ prc0(F ) | C′ ∩ C = ∅ ∧ |C′ \\ C| ≤ k}.\nNote that the trigger hypergraph of F ∈ CLS depends only on the underlying boolean function of F , and thus for every equivalent F ′ we have Tk(F ′) = Tk(F ).\nExample 6.2 Consider the clause-set\nF := { {v1, v3, v4} ︸ ︷︷ ︸\nC1\n, {v2, v3, v4} ︸ ︷︷ ︸\nC2\n, {v2, v3, v4} ︸ ︷︷ ︸\nC3\n, {v2, v3, v4} ︸ ︷︷ ︸\nC4\n, {v1, v3, v4} ︸ ︷︷ ︸\nC5\n, {v1, v2} ︸ ︷︷ ︸\nC6\n} .\nAs shown in Example 8.2 of [37, 38] we have prc0(F ) = F . The trigger hypergraph T0(F ) is (as always) the hypergraph with all singleton sets, i.e., E(T0(F )) ={ {C1}, . . . , {C6} } . The hypergraphs Tk(F ) for k ∈ {1, 2} are represented by Figures 3, 4.\nC1++\nC2 ss\nC5 ss\nww C333 ** C6RR\n``❇❇❇❇❇❇❇❇ OO >>⑤⑤⑤⑤⑤⑤⑤⑤ oo C4 kk OO\nFigure 3: T1(F )\nC1++\n❇ ❇❇\n❇❇ ❇❇\n❇ C2 ss\nC5 ss\n~~⑤⑤ ⑤⑤ ⑤⑤ ⑤⑤\nC333 // C6RR\n`` OO >>\noo C4 kk\nOO\nFigure 4: T2(F )\nTo interpret the diagrams:\n1. An arrow from a clause C to a clause D represents that C ∈ EkD.\n2. A dotted arrow from C to D represents that |D \\ C| > k (so C /∈ EkD), but C ∩D = ∅, and thus for some large enough k′ > k we will have C ∈ Ek′D .\n3. No arrow between C and D indicates that C ∩D 6= ∅ (i.e., for all k′ we have C /∈ EkD and D /∈ EkC).\n4. The size of a hyperedge EkD is the in-degree of the vertex D.\nConsider E1C6 = {C6} and E2C6 = {C1, C2, C3, C5, C6}. As we will see in Lemma 6.3, therefore every F ′ ⊆ F equivalent to F such that F ′ ∈ UC1 must have C6 ∈ F ′. However, E2C6 contains more clauses than E 1 C6\n, and for example F \\ {C6} ∈ UC2 \\ UC1 as shown in Example 8.2 of [37, 38]. Using the above diagrammatic notation, we can also see that for all k′ ≥ 2 we have Tk′(F ) = T2(F ), as there are no dotted lines for T2(F ) (i.e., no clauses C and D such that |D \\ C| > 2 but C ∩D = ∅).\nThe point of the trigger hypergraph Tk(F ) is, that every clause-set equivalent to F and of w-hardness at most k must be a transversal of it:\nLemma 6.3 Consider k ∈ N0 and F ∈ CLS with whd(F ) ≤ k. Then there is a clause-set F ′ such that\n1. F ′ ⊆ prc0(F ) and F ′ is equivalent to F ;\n2. there is an injection i : F ′ → F such that ∀C ∈ F ′ : C ⊆ i(C);\n3. whd(F ′) ≤ k;\n4. F ′ is a transversal of Tk(F ).\nProof: Obtain F ′ from F by choosing for every C ∈ F some C′ ∈ prc0(F ) with C′ ⊆ C. Then the first two properties are obvious, while Property 3 follows from Part 1 of Lemma 6.1 in [59]. Assume that F ′ is not a transversal of Tk(F ), that is, there is C ∈ prc0(F ) with F ′ ∩ EkC = ∅. Then ϕC ∗ F ′ ∈ USAT , but every clause has length strictly greater than k, and thus k-resolution does not derive ⊥ from ϕC ∗ F ′, contradicting whd(F ′) ≤ k.\nOur lower bound method is now captured by the following theorem, which directly follows from Lemma 6.3:\nTheorem 6.4 For k ∈ N0 and F ∈ WCk we have c(F ) ≥ τ(Tk(F )).\nInstead of lower-bounding the transversal number of Tk(F ), we use that every transversal has to have at least as many elements as there are disjoint hyperedges. So let ν(G) be the matching number of hypergraph G, the maximum number of pairwise disjoint hyperedges; we have τ(G) ≥ ν(G) for all hypergraphs G. So we have to show that there is a set S ⊆ prc0(F kh ) of exponential size, such that the hyperedges EkC for C ∈ S are pairwise disjoint. For F kh we use the doped clause-set D(F1(T )) as considered in Subsection 5.3, where the special trees T are constructed in the subsequent subsection."
    }, {
      "heading" : "6.2 Extremal trees",
      "text" : "For a given hardness k ≥ 1 we need to construct (full binary) trees which are as large as possible; this is achieved by specifying the height, and using trees which are “filled up” completely for the given parameter values:\nDefinition 6.5 A pair (k, h) ∈ N20 with h ≥ k and k = 0 ⇒ h = 0 is called an allowed parameter pair. For an allowed parameter pair (k, h) a full binary tree T is called an extremal tree of Horton-Strahler number k and height h if\n1. hs(T ) = k, ht(T ) = h;\n2. for all T ′ with hs(T ′) ≤ k and ht(T ′) ≤ h we have nds(T ′) ≤ nds(T ). We denote the set of all extremal trees with Horton-Strahler number k and height h by HS(k, h).\nNote that for allowed parameter pairs (k, h) we have k = 0 ⇔ h = 0. Extremal trees are easily characterised and constructed as follows:\n1. HS(0, 0) contains only the trivial tree (with one node).\n2. HS(1, h) for h ∈ N consists exactly of the full binary trees T with hs(T ) = 1 and ht(T ) = h, which can also be characterised as those full binary trees T with ht(T ) = h such that every node has at least one child which is a leaf.\n3. For k ≥ 2 and h ≥ k we have T ∈ HS(k, h) iff T has the left subtree T0 and the right subtree T1, and there is ε ∈ {0, 1} with Tε ∈ HS(k − 1, h − 1) and T1−ε ∈ HS(min(k, h− 1), h− 1).\nLemma 6.6 For all allowed parameter pair (k, h) we have HS(k, h) 6= ∅. The unique elements of HS(k, k) for k ∈ N0 are the perfect binary trees of height k, which are the smallest binary trees of Horton-Strahler number k.\nLemma 6.7 For an allowed parameter pair (k, h) and for T ∈ HS(k, h) we have #lvs(T ) = α(k, h) :=\n∑k i=0 ( h i ) . We have α(k, h) = Θ(hk) for fixed k.\nProof: For k ≤ 1 we have α(0, 0) = 1 and α(1, h) = 1 + h. which are obviously correct. Now consider k ≥ 2. By induction hypothesis we get\n#nds(T ) = α(k − 1, h− 1) + α(min(k, h− 1), h− 1). If h = k, then α(k, h) = 2k (for all k), and we get #nds(T ) = α(k − 1, k − 1) + α(k − 1, k − 1) = 2 · 2k−1 = 2k = α(k, k). Otherwise we have\n#nds(T ) = α(k − 1, h− 1) + α(k, h− 1) = k−1∑\ni=0\n( h− 1 i ) + k∑\ni=0\n( h− 1 i ) = ( h− 1 0 ) + k∑\ni=1\n( h− 1 i− 1 ) + ( h− 1 i ) =\n( h− 1 0 ) + k∑\ni=1\n( h\ni\n)\n=\nk∑\ni=0\n( h\ni\n)\n= α(k, h).\nExample 6.8 Consider the following labelled binary tree T :\nv1\nv2\nv1\n❥❥❥ ❥❥❥\n❥❥❥ ❥❥❥\n❥❥❥ ❥\nv3\nv2\n♦♦♦ ♦♦♦\n♦♦♦ ♦♦\n10\nv3 ⑧⑧ ⑧⑧ ⑧\n21\nv3 ❄❄\n❄❄ ❄\nv4\nv2\n❖❖❖ ❖❖❖\n❖❖❖ ❖❖\n31\nv4 ⑧⑧ ⑧⑧ ⑧\n42\nv4 ❄❄\n❄❄ ❄\nv5\nv1\n❚❚❚ ❚❚❚\n❚❚❚ ❚❚❚\n❚❚❚ ❚\nv6\nv5 ⑧⑧ ⑧⑧ ⑧⑧\n51\nv6 ⑧⑧ ⑧⑧ ⑧\n62\nv6 ❄❄\n❄❄ ❄ 72\nv5 ❄❄\n❄❄ ❄\nApplying the recursive construction/characterisation we see T ∈ HS(2, 3). By simple counting we see that T has 7 leaves, in agreement with Lemma 6.7, i.e., ∑2\nj=0 ( 3 j ) = ( 3 0 ) + ( 3 1 ) + ( 3 2 ) = 1 + 3 + 3 = 7. Assuming that of the two subtrees at an inner node, the left subtree has Horton-Strahler numbers as least as big as the right subtree, the idea is that the sum runs over the number j of right turns in a path from the root to the leaves. In the above tree T , the number of right turns is indicated as an index to the leaf-name. If the Horton-Strahler number is k, with at most k right-turns we must be able to reach every leaf.\nWe summarise the additional knowledge over Theorem 5.22 (using additionally that most leaves of T ∈ HS(k, h) have depth precisely h):\nLemma 6.9 Consider an allowed parameter pair (k, h) and T ∈ HS(k, h), and let F := F1(T ).\n1. n(D(F )) = 2 · α(k, h)− 1 (= Θ(hk) for fixed k).\n2. c(D(F )) = α(k, h) (= Θ(hk) for fixed k).\n3. ℓ(D(F )) ≤ h · α(k, h) (= Θ(hk+1) for fixed k).\n4. D(F ) ∈ UCk \\ UCk−1 (for k ≥ 1).\nIn Theorem 6.14 we will see that these D(F ) from Lemma 6.9 do not have short equivalent clause-sets of hardness k − 1. A simple example demonstrates the separation between UC0 and UC1 (similar to [26], Example 2, which uses Example 6.1 from [50]):\nExample 6.10 The strongest separation is obtained by using Fh := D(F 1(T )) for T ∈ HS(1, h) and h ∈ N:\n1. F1(T ), when considering all possible T , covers precisely the saturated minimally unsatisfiable renamable Horn clause-set with h variables, which is up to isomorphism equal to {{v1}, {v1, v2}, . . . , {v1, . . . , vh−1, vh}, {v1, . . . , vh}}. By Lemma 5.4 these are precisely those F ∈ SMUδ=1 with n(F ) ≥ 1 which contain a full clause.\n2. n(Fh) = 2h+ 1, c(Fh) = h+ 1, and hd(Fh) = 1.\n3. |prc0(Fh)| = 2h+1 − 1.\nConsidering Gn := {{v1}, . . . , {vn}, {v1, . . . , vn}} for n ≥ 2 and Fn := D(Gn) we obtain an example similar (but simpler) to Example 6.1 from [50]:\n1. n(Gn) = n and c(Gn) = n+ 1.\n2. Gn ∈ MUδ=1 \\ SMUδ=1. The above clause-sets F1(T ) are obtained precisely as saturations of the Gn (due to Lemma 5.4; a saturation adds literal occurrences until we obtain a saturated minimally unsatisfiable clause-set).\n3. mps(Gn) consists precisely of the subsets of Gn containing the negative clause, plus the singleton-subsets given by the unit-clauses.\n4. Thus |mps(Gn)| = 2n + n.\n5. n(Fn) = 2n+ 1, c(Fn) = n+ 1, and hd(Fn) = 1.\n6. |prc0(Fn)| = 2n + n."
    }, {
      "heading" : "6.3 The exponential lower bound",
      "text" : "The task is to find many disjoint hyperedges in Tk(F k h ), where F k h := D(F 1(T )) for T ∈ HS(k+1, h). Our method for this is to show that there are many “incomparable” subsets of leaves in T in the following sense. The depth of a node w in a rooted tree T , denoted by dT (w) ∈ N0, is the length of the path from the root of T to w. Recall that two sets A,B are incomparable iff A 6⊆ B and B 6⊆ A. Furthermore we call two sets A,B incomparable on a set C if the sets A ∩ C and B ∩ C are incomparable.\nDefinition 6.11 Consider a full binary tree T , where every leaf has depth at least k + 1. Consider furthermore ∅ ⊂ V, V ′ ⊆ lvs(T ). Then V and V ′ are depth-kincomparable for T if V and V ′ are incomparable on lvs(Tw) for all w ∈ nds(T ) with dT (w) = k.\nNote that for all allowed parameter pairs (k, h) and T ∈ HS(k, h) every leaf has depth at least k.\nLemma 6.12 Consider k ∈ N0, T ∈ T1, and ∅ 6= V0, V1 ⊆ lvs(T ) which are depthk-incomparable for T . Let F := F1(T ) and consider Tk(F ) (recall Definition 6.1). Then the hyperedges EkCV0 , EkCV1 are disjoint (recall Definition 5.17).\nProof: Assume that EkCV0 , EkCV1 are not disjoint; thus there is ∅ 6= V ⊆ lvs(T ) with CV ∈ EkCV0 ∩ E k CV1\n. We will show that there is ε ∈ {0, 1} with |CV \\ CVε | ≥ k + 1, which contradicts the definition of Tk(F ).\nSince V 6= ∅, there is w ∈ V . Consider the first k + 1 nodes w1, . . . , wk+1 on the path from the root to w. Let w′i be the child of wi−1 different from wi for i ∈ {2, . . . , k + 1}, and let Ti := Tw′ i+1 for i ∈ {1, . . . , k}, while Tk+1 := Twk+1 ; see Figure 5. We show that each of T1, . . . , Tk+1 contributes at least two unique literals to |CV \\CV0 |+ |CV \\CV1 |, so that we get |CV \\CV0 |+ |CV \\CV1 | ≥ (k+1) · 2, from which follows that there is ε ∈ {0, 1} with |CV \\ CVε | ≥ k + 1 as claimed.\nDue to the depth-k-incomparability of V, V ′, for each i ∈ {1, . . . , k+1} and each ε ∈ {0, 1} there are nodes vεi with vεi ∈ (lvs(Ti) ∩ Vε) \\ Vε. We have two cases now:\nI If vεi ∈ V , then uvεi ∈ CV \\ CVε .\nII If vεi /∈ V , then consider the first node v on the path from vεi to the root such that for the other child v′ of v, not on that path to the root, holds lvs(Tv′)∩ V 6= ∅: now for the literal x labelling the edge from v to v′ we have x ∈ CV \\ CVε . Note that v is below or equal to wi (due to w ∈ V ).\nFor each ε ∈ {0, 1}, the literals collected in CV \\ CVε from these k + 1 sources do not coincide, due to the pairwise node-disjointness of the trees T1, . . . , Tk+1.\nTheorem 6.13 Consider k ∈ N0, h ≥ k + 1, and T ∈ HS(k + 1, h); let F := D(F1(T )) and m := α(1, h− k) = 1 + h− k. We have\nν(Tk(F )) ≥ ( m\n⌊m2 ⌋\n)\n> 1√ 2 2m√ m = Θ( 2h√ h ),\nwhere the second inequality assumes h ≥ k+5, while the Θ-estimation assumes fixed k.\nProof: For every S ⊆ P(lvs(T )) with ∅ /∈ S, such that every two different elements of S are depth-k-incomparable for T , we have ν(Tk(F )) ≥ |S| by Lemma 6.12. We can actually determine the maximal size of such an S, which is M :=\n( m m′ ) , where\nm′ := ⌊m2 ⌋, as follows. Let T := {Tw : w ∈ nds(T ) ∧ dT (w) = k}; note that for T ′, T ′′ ∈ T with T ′ 6= T ′′ we have lvs(T ′)∩lvs(T ′′) = ∅. Choose T0 ∈ T with minimal #lvs(T0); by Lemma 6.7 we have #lvs(T0) = m. Let S0 := {V ∩ lvs(T0) : V ∈ S}. Then S0 is an antichain (i.e., the elements of S0 are pairwise incomparable) and |S0| = |S|. By Sperner’s Theorem ([80]) holds |S0| ≤ M , and this upper bound M is realised, just observing the antichain-condition, by choosing for S0 the set( lvs(T0) m′ ) of subsets of lvs(T0) of size m\n′. This construction of S0 can be extended to a construction of S (of the same size) by choosing for each T ′ ∈ T an injection jT ′ : S0 → ( lvs(T ′) m′ ) and defining S := {⋃T ′∈T jT ′(V )}V ∈S0 . The given estimation of M follows from Stirling’s approximation.\nWe are now able to state the main result of this article, proving Conjecture 1.1 from [37, 38] that UCk, and indeed also WCk, is a proper hierarchy of boolean functions regarding polysize representations without new variables (see Subsection 7.1 for a discussion of “representations” in general):\nTheorem 6.14 Consider k ∈ N0. For h ≥ k + 1 choose one Th ∈ HS(k + 1, h) (note there is up to left-right swaps exactly one element in HS(k + 1, h)), and let Fh := D(Th). Consider the sequence (Fh)h≥k+1.\n1. By Lemma 6.9 we have n(Fh) = Θ(h k+1) as well as c(Fh) = Θ(h k+1), and Fh ∈ UCk+1.\n2. Consider a sequence (F ′h)h≥k+1 of clause-sets with F ′ h equivalent to Fh, such\nthat F ′h ∈ WCk. By Theorems 6.13, 6.4 we have c(F ′h) = Ω( 2 h √ h ).\nWe conjecture that Theorem 6.14 can be strengthened by including the PChierarchy in the following way:\nConjecture 6.15 For every k ∈ N0 there exists a sequence (Fn)n∈N of clausesets in PCk+1, where for convenience we assume n(Fn) = n for all n, such that (ℓ(Fn))n∈N is polynomially bounded, and such that for every sequence (F ′n)n∈N in WCk, where for all n ∈ N holds that F ′n is equivalent to Fn, the sequence (ℓ(F ′n))n∈N is not polynomially bounded."
    }, {
      "heading" : "7 Analysing the Tseitin translation",
      "text" : "We now turn to upper bounds, investigating cases where the Tseitin translation yields representations in UC. We consider two main cases: translating a DNF into a CNF, or translating an XOR-circuit. In Subsection 7.1 we discuss the general notion of “CNF representation”. In Subsection 7.2 we discuss translating DNF into CNF, which we consider as a map from CLS to CLS, and which we call the “canonical translation”. Lemma 7.11 shows that the hardness of canonical translation results can be arbitrarily high. On the other hand, Lemma 7.12 shows that for hitting DNF the canonical translation result is in UC, and Theorem 7.14 applies this to our lower bound examples, in contrast to Theorem 6.14 (so we see that new variables here help). Finally by using only the necessary direction of the equivalences in the Tseitin translation, in Lemma 7.17 we see that for this “reduced canonical translation” the result is always in UC. We conclude by discussing representations of XOR-clause-sets in Subsection 7.3."
    }, {
      "heading" : "7.1 CNF-representations",
      "text" : "In Subsections 1.4 and 9.2 of [37, 38] we discussed representations of boolean functions in general. The most general notion useful in the SAT-context seems to allow existentially quantified new variables, which yields the following basic definition:\nDefinition 7.1 A CNF-representation of F ∈ CLS (as CNF) is a clause-set F ′ ∈ CLS with var(F ) ⊆ var(F ′) such that the satisfying assignments of F ′ (as CNF) projected to var(F ) are precisely the satisfying assignments of F .\nExample 7.2 Consider F := {{a, b}}. Then F ′ := F ∪ {{v, a}} is a CNFrepresentation of F , since the satisfying assignments of F can be extended to satisfying assignments of F ′ by assigning v → 1, while no new satisfying assignments are present, since F ′ is a superset of F . Also F ∪{{v}} is a CNF-representation of F , but F ∪ {{a}} is not, since the satisfying assignment 〈a → 0, b → 1〉 of F would be lost. Also {{v, a, b}} is not a CNF-representation of F , since here now we would obtain a new satisfying assignment for F , namely 〈a, b → 0〉.\nThe CNF-representations F ′ of F without new variables, that is, with var(F ′) = var(F ), are precisely the clause-sets F ′ equivalent to F with var(F ′) = var(F ). We have conjectured in [37, 38] (Conjecture 9.4) that Theorem 6.14 (and Conjecture 6.15) also holds when allowing new variables, which in this context we can rephrase as follows, also extending the conjecture by including WCk (see Conjecture 10.2 for a further strengthening):\nConjecture 7.3 For every k ∈ N0 there exists a sequence (Fn)n∈N of clause-sets, such that there is a sequence (F ′n)n∈N, where\n• each F ′n is a CNF-representation of Fn,\n• ℓ(F ′n) is polynomial in n,\n• and we have F ′n ∈ PCk+1,\nbut where there is no such sequence (F ′′n )n∈N with F ′′ n ∈ WCk.\nOur basic condition for a “good” representation F ′ of F ∈ CLS is that F ′ ∈ UCk holds for some “low” k (a constant if F depends on parameters). This is what we call the absolute condition — regarding the requirement of detecting unsatisfiability of ϕ ∗ F ′ for some partial assignment ϕ we do not distinguish between original variables (those in var(F )) and new variables (those in var(F ′) \\ var(F )), that is, var(ϕ) ⊆ var(F ′) is considered. If we consider only var(ϕ) ⊆ var(F ), then we obtain the relative condition:\nDefinition 7.4 For F ∈ CLS and V ⊆ VA the relative hardness hdV (F ) ∈ N0 is defined as the minimum k ∈ N0 such that for all partial assignments ϕ ∈ PASS with var(ϕ) ⊆ V and ϕ ∗ F ∈ USAT we have rk(ϕ ∗ F ) = {⊥}. And the relative w-hardness whdV (F ) ∈ N0 is defined as the minimum k ∈ N0 such that for all partial assignments ϕ ∈ PASS with var(ϕ) ⊆ V and ϕ ∗ F ∈ USAT we have that k-resolution derives ⊥ from ϕ ∗ F .\nObviously hdV (F ) ≤ hd(F ) and hdvar(F )(F ) = hd(F ), as well as whdV (F ) ≤ whd(F ) and whdvar(F )(F ) = whd(F ). Having a representation F ′ of F with hdvar(F )(F ′) ≤ 1 is closely related to what is typically called “maintaining arc consistency”; it would be precisely that if we would use p-hardness instead of hardness, while using (only) hardness is a certain weakening. Having hdvar(F )(F ′) = 0 here is equivalent to prc0(F ) ⊆ F ′, and thus for hardness 0 new variables are not helpful, neither for the relative nor the absolute condition.\nConjecture 7.3 is false for relative hardness, since regarding relative hardness the hierarchy collapses to the first level: we will present the details in a future paper, but they are not difficult — since there are no conditions on the new variables, the rk-computations for k > 1 can be encoded into CNF, only relying on r1. Such an encoding is an extension of Theorem 1 in [8], using similar techniques. More involved is the collapse of the WCk-hierarchy to the first level regarding relative hardness; we believe we can also show this, but we better formulate it explicitly as a conjecture:\nConjecture 7.5 For every k ≥ 1 there is a polytime function t(F, V ), which takes a clause-set F and a finite set V of variables as arguments, such that in case of whdV (F ) ≤ k the output t(F, V ) is a representation of F with whdV (t(F )) ≤ 1.\nNote that for all F ∈ CLS and V ⊆ VA holds whdV (F ) ≤ 1 ⇔ hdV (F ) ≤ 1. The collapse of all considered hierarchies to their first level, when considering the relative condition, is for us a major argument in favour of the absolute condition: Within the class of representations of relative hardness at most 1 (when using new variables) there is a lot of structure, and many representations fulfil absolute conditions; some basic examples follow in the remainder of this section."
    }, {
      "heading" : "7.2 The canonical translation",
      "text" : "If for the F ∈ CLS to be represented we have an equivalent DNF G ∈ CLS, then we can apply the Tseitin translation, using one new variable v to express one DNFclause, i.e., using prc0(v ↔ ∧\nx∈C x) for C ∈ G. The details are as follows. We assume that an injection vct : {(F,C) | F ∈ CLS ∧C ∈ F} → VA is given, yielding the variables of the canonical translation, such that these variables are\nnew for F , that is, var(F ) ∩ {vct(F,C)}C∈F = ∅ holds for all F ∈ CLS. We write vctC\nF := vct(F,C).\nDefinition 7.6 The map ct : CLS → CLS is defined for F ∈ CLS as\nct(F ) := { {vctCF , x} : C ∈ F ∧ x ∈ C } ∪ { {vctCF } ∪C : C ∈ F } ∪\n{ {vctCF }C∈F } .\nThe first two types of clauses are the prime implicates of the boolean functions vctCF ↔ ∧\nx∈C x, while the last type (a long, single clause) says that one of the (DNF-)clauses from F must be true. To emphasise: the map ct is a map from clausesets to clause-sets, where the (implicit) interpretation of the input and the output is different: the input F ∈ CLS is interpreted as DNF, while the output ct(F ) ∈ CLS is interpreted as CNF. Some basic properties of the canonical translation:\n1. The basic measures of the canonical translation for F ∈ CLS are given by\n(a) n(ct(F )) = n(F ) + c(F )\n(b) c(ct(F )) = 1 + c(F ) + ℓ(F ) for F 6= {⊥}. (c) ℓ(ct(F )) = 2c(F ) + 3ℓ(F ) for F 6= {⊥}.\n2. ct(⊤) = {⊥} and ct({⊥}) = {{vct⊥{⊥}}}.\n3. Consider ϕ ∈ PASS with var(ϕ) ⊆ var(F ), and treat F as a multi-clause-set, that is, if application of ϕ to different non-satisfied clauses from F makes these clauses equal, then no contractions are performed. Then the canonical translation behaves homomorphic regarding application of partial assignments in the sense that ct(ϕ ∗ F ) (recall that we need to treat F here as a DNF) is isomorphic to (ϕ∪ψ) ∗ ct(F ), where ψ sets those vctCF to 0 for which there is x ∈ C with ϕ(x) = 0.\nExample 7.7 We give some simple examples for canonical translations.\n1. For F := {{v1} ︸︷︷︸\nC1\n,⊥} we have\nct(F ) = {{vctC1F , v1}, {vctC1F , v1} ︸ ︷︷ ︸\nv1 ↔ vct C1\nF\n, {vct⊥F } ︸ ︷︷ ︸\n1 ↔ vct⊥ F\n, {vctC1F , vct⊥F } ︸ ︷︷ ︸\nvctC1 F ∨ vct⊥ F\n}.\n2. For F := {{v1, v2, v3} ︸ ︷︷ ︸\nC1\n, {v1, v2, v4} ︸ ︷︷ ︸\nC2\n} we have\nct(F ) = {{vctC1F , v1}, {vctC1F , v2}, {vctC1F , v3}, {vctC1F , v1, v2, v3} ︸ ︷︷ ︸\n(v1 ∧ v2 ∧ v3) ↔ vct C1\nF\n,\n{vctC2F , v1}, {vctC2F , v2}, {vctC2F , v4}, {vctC2F , v1, v2, v4} ︸ ︷︷ ︸\n(v1 ∧ v2 ∧ v4) ↔ vct C2\nF\n, {vctC1F , vctC2F } ︸ ︷︷ ︸\nvctC1 F ∨ vctC2 F\n}.\n3. Applying ϕ := 〈v3 → 1, v4 → 1〉 to the last example (Case 2) yields\nϕ ∗ ct(F ) = {{vctC1F , v1}, {vctC1F , v2}, {vctC1F , v1, v2} ︸ ︷︷ ︸\n(v1 ∧ v2) ↔ vct C1\nF\n,\n{vctC2F , v1}, {vctC2F , v2}, {vctC2F , v1, v2} ︸ ︷︷ ︸\n(v1 ∧ v2) ↔ vct C2\nF\n, {vctC1F , vctC2F } ︸ ︷︷ ︸\nvctC1 F ∨ vctC2 F\n}.\n4. Applying ϕ := 〈v3 → 0〉 to Case 2 yields\nϕ ∗ ct(F ) = {{vctC1F , v1}, {vctC1F , v2}, {vctC1F } ︸ ︷︷ ︸\nvctC1 F\n,\n{vctC2F , v1}, {vctC2F , v2}, {vctC2F , v4}, {vctC2F , v1, v2, v4} ︸ ︷︷ ︸\n(v1 ∧ v2 ∧ v4) ↔ vct C2\nF\n, {vctC1F , vctC2F } ︸ ︷︷ ︸\nvctC1 F ∨ vctC2 F\n}.\n5. While applying ϕ := 〈v3 → 0〉 and ψ := {vctC1F → 0} to Case 2 yields\n(ϕ ∪ ψ) ∗ ct(F ) = {{vctC2F , v1}, {vctC2F , v2}, {vctC2F , v4}, {vctC2F , v1, v2, v4} ︸ ︷︷ ︸\n(v1 ∧ v2 ∧ v4) ↔ vct C2\nF\n, {vctC2F } ︸ ︷︷ ︸\nvctC2 F\n}.\nIn Case 3 we see an example of why for the canonical translation to have the homomorphism property we must consider F as a multi-clause-set. That is, ϕ ∗ F = {{v1, v2}}, and so ϕ ∗ ct(F ) 6= ct(ϕ ∗ F ): the clause {v1, v2} is represented by two separate new variables in ϕ ∗ ct(F ) compared to only one in ct(ϕ ∗ F ).\nIn Case 4 we see an example where for the homomorphism property of the canonical translation not just renaming, but also some unit-clause elimination is needed. These unit-clauses are added in Case 5, extending the assignment to falsify the new variable vctC1F corresponding to falsified DNF-clause C1.\nLemma 7.8 Consider F ∈ CLS (as CNF) and an equivalent DNF-clause-set G ∈ CLS. Then ct(G) is a CNF-representation of F . Proof: ct(F ) is true iff at least one of its vct-variables is set to true, which is precisely the case iff at least one of DNF-clauses of G is satisfied, where the (DNF)clauses of G cover precisely the satisfying assignments of F .\nLemma 7.9 For F ∈ CLS we have hdvar(F )(ct(F )) ≤ 1 (recall Definition 7.4).\nProof: Consider ϕ ∈ PASS with var(ϕ) ⊆ var(F ) and ϕ ∗ ct(F ) ∈ USAT . Then all DNF-clauses of F are falsified, which yields via UCP that all vct-variables are set to false, and thus r1(ϕ ∗ ct(F )) = {⊥}. In [49] a more general version of Lemma 7.9 is proven, showing that for all “smooth” DNNFs (Disjoint Negation Normal Form) the Tseitin translation yields a clauseset which maintains arc-consistency via UCP (a somewhat stronger property than relative hardness ≤ 1 as in Lemma 7.9).7) That Lemma 7.9 only establishes the\n7)There is a mistake in [49] in that it claims that the Tseitin translation of all DNNFs maintain arc-consistency via UCP, however this is shown only for smooth DNNFs as confirmed by George Katirelos via e-mail in January 2012.\nrelative condition, and not the absolute one, is due to the fact that setting vctvariables to 0 can pose arbitrarily hard conditions; a concrete example follows, while a more drastic general construction is given in Lemma 7.11. However the difficulties can be overcome, by just removing them: In Lemma 7.17 we will see that when dropping the part of the canonical translation which gives meaning to setting vct-variables to 0, that then we actually can establish the absolute condition.\nExample 7.10 Consider the following clause-set with variables x1, . . . , x5:\nF := { {x1, x2, x3} ︸ ︷︷ ︸\nC1\n, {x1, x2, x4} ︸ ︷︷ ︸\nC2\n, {x1, x2, x5} ︸ ︷︷ ︸\nC3\n} .\nThe canonical translation is\nct(F ) = {{x1, vctC1F }, {x2, vctC1F }, {x3, vctC1F }}, {x1, x2, x3, vctC1F } ︸ ︷︷ ︸\nvctC1 F ↔ (x1 ∧ x2 ∧ x3)\n∪\n{{x1, vctC2F }, {x2, vctC2F }, {x4, vctC2F }}, {x1, x2, x4, vctC2F } ︸ ︷︷ ︸\nvctC2 F ↔ (x1 ∧ x2 ∧ x4)\n∪\n{{x1, vctC3F }, {x2, vctC3F }, {x5, vctC3F }}, {x1, x2, x5, vctC3F } ︸ ︷︷ ︸\nvctC3 F ↔ (x1 ∧ x2 ∧ x5)\n∪\n{{vctC1F , vctC2F , vctC3F }} ︸ ︷︷ ︸\n(vctC1 F ∨ vctC2 F ∨ vctC3 F )\n.\nApplying the partial assignment ϕ := 〈x3 → 1, x4 → 1, x5 → 1, vctC3F → 0〉 yields F ′ := ϕ ∗ ct(F ) = {{x1, vctC1F }, {x2, vctC1F }}, {x1, x2, vctC1F }\n︸ ︷︷ ︸\nvctC1 F ↔ (x1 ∧ x2)\n∪\n{{x1, vctC2F }, {x2, vctC2F }}, {x1, x2, vctC2F } ︸ ︷︷ ︸\nvctC2 F ↔ (x1 ∧ x2)\n∪\n{{x1, x2}} ︸ ︷︷ ︸\n¬(x1 ∧ x2)\n∪ {{vctC1F , vctC2F }} ︸ ︷︷ ︸\n(vctC1 F ∨ vctC2 F )\n.\nWe have F ′ ∈ USAT , where F ′ has no unit-clauses, whence hd(F ′) ≥ 2, and so ct(F ) /∈ UC1.\nFor general input-DNFs, the hardness of the canonical translation can be arbitrary high:\nLemma 7.11 Consider F ∈ CLS. Let v ∈ VA\\var(F ) and F ′ := F ∪{{v}}. Then hd(ct(F ′)) ≥ hd(F ).\nProof: Let ϕ := 〈vctCF ′ → 0 : C ∈ F 〉 ∪ 〈v, vct {v} F ′ → 1〉. Then ϕ ∗ ct(F ′) = F ′′ := {C : C ∈ F}, where hd(ct(F ′)) ≥ hd(F ′′) = hd(F ).\nIf we do not have just a DNF, but a “disjoint” or “orthogonal” DNF (see Section 1.6 and Chapter 7 in [22]), which are as clause-sets precisely the hitting clause-sets, then we obtain absolute hardness 1:\nLemma 7.12 For F ∈ HIT we have ct(F ) ∈ UC, where ct(F ) is a representation of the DNF-clause-set F .\nProof: Consider a partial assignment ϕ such that ϕ ∗ ct(F ) is unsatisfiable. Since HIT is stable under application of partial assignments, and furthermore here no contractions take place, w.l.o.g. we can assume that var(ϕ) ∩ var(F ) = ∅. If ϕ sets two or more vct-variables to true, then UCP yields a contradiction, since any two clauses from F clash. If ϕ would set precisely one vct-variable to true, then we had ϕ ∗ ct(F ) = ⊤. So assume that ϕ sets no vct-variable to true. Now ϕ must set all vct-variables to false, since, as already mentioned, just setting one vct-variable to true satisfies ct(F ). And thus ⊥ ∈ ct(F ).\nWe now want to show that via the canonical translation we can obtain representations of D(F ) for F ∈ UHIT . For this we show first that all such D(F ) have short hitting DNF clause-sets. For F ∈ CLS let #sat(F ) ∈ N0 denote the number of satisfying assignments for F , that is, #sat(F ) = |DNF(F )|.\nLemma 7.13 Consider F ∈ UHIT , and let m := n(F ) + c(F ).\n1. #sat(D(F )) = 2m−1.\n2. Let F ′ := { C∪{uC} | C ∈ F } ; by definition we have F ′ ∈ HIT . Furthermore\n#sat(F ′) = 2m−1.\n3. F ′ as a DNF-clause-set is equivalent to the CNF-clause-set D(F ).\nProof: We have ∑ C∈F 2 −|C| = 1 (see [52]). Thus ∑ C∈D(F ) 2 −|C| = 12 , which proves Part 1 (note m = n(D(F )) and D(F ) ∈ HIT ). Part 2 follows from Part 1, since F ′ results from D(F ) by flipping literals. Finally we consider Part 3. All elements of F ′, as DNF-clauses (i.e., conjunctions of literals), represent satisfying assignments for D(F ), that is, for all C ∈ F ′ and D ∈ D(F ) we have C ∩D 6= ∅. By Part 2, precisely half of the total assignments of DNF-clause-set F ′ are falsifying, and thus precisely half of the total assignments are satisfying: since this is the same number as the satisfying assignments of D(F ), we obtain that the DNF-clause-set F ′ is equivalent to the CNF-clause-set F .\nAn alternative line of argumentation is that for F ∈ UHIT the (logical) negation of D(F ) (as a CNF) is given by D(F )′, which is obtained from D(F ) by flipping all doping literals, i.e., replacing clauses C ∪{uC} by C∪{uC}. That this is indeed the negation, follows from the two facts, that D(F ) ∪D(F )′ ∈ HIT by definition, and that D(F ) ∪D(F )′ results from F by replacing each clause C with the two clauses C ∪ {uC}, C ∪ {uC}, which are together equivalent to C.\nBy Lemma 7.13 and Lemma 7.12 we obtain now that doped unsatisfiable hitting clause-sets have good representations via the canonical translation:\nTheorem 7.14 For F ∈ UHIT there is a short CNF-representation (using new variables) of D(F ) in UC, namely F ′ := ct({C ∪ {uC} : C ∈ F}) ∈ UC, where:\n1. n(F ′) = n(F ) + 2c(F ).\n2. c(F ′) = 1 + 2c(F ) + ℓ(F ).\nThis applies especially for F ∈ SMUδ=1 ⊂ UHIT .\nFinally we show that when relaxing the canonical translation, using only the necessary direction of the constitutive equivalences, then we actually obtain representations in UC for every DNF-clause-set:\nDefinition 7.15 The map ct– : CLS → CLS (“reduced canonical translation”) is defined for F ∈ CLS as ct–(F ) := {{vctCF , x} : C ∈ F ∧ x ∈ C} ∪ {{vctCF }C∈F}.\nNote that all clauses of ct–(F ) are binary except of the long clause stating that one of the vct-variables must become true. And also note that in case of ⊥ /∈ F the additional clauses of ct(F ), that is, the C ∈ ct(F ) \\ ct–(F ), are all blocked for ct(F ) (see [54, 55]), since C can not be resolved on the vct-variable in it. We have var(ct–(F )) = var(ct(F )), while the basic measure for F ∈ CLS are given as follows:\n1. n(ct–(F )) = n(F ) + c(F )\n2. c(ct–(F )) = 1 + ℓ(F )\n3. ℓ(ct–(F )) = c(F ) + 2ℓ(F ).\nWith the same proof as Lemma 7.8 we get:\nLemma 7.16 Consider F ∈ CLS (as CNF) and an equivalent DNF-clause-set G ∈ CLS. Then ct–(G) is a CNF-representation of F .\nWe show now that dropping the additional (blocked) clauses, present in the full form ct(F ), actually leads to the hardness dropping to 1 for arbitrary input-DNFs (recall Lemma 7.11), exploiting that now there are less possibilities for making ct–(F ) unsatisfiable by instantiation:\nLemma 7.17 For F ∈ CLS we have ct–(F ) ∈ UC (i.e., ct– : CLS → UC).\nProof: For the sake of contradiction consider a partial assignment ϕ such that F ′ := r1(ϕ ∗ ct–(F )) ∈ USAT but F ′ 6= {⊥}. Note that F ′ contains neither ⊥ nor a unit-clause, and thus F ′ is a subset of ct–(F ) except of the possibly shortened or satisfied long vct-clause. If F ′ contains no new variables, then thus F ′ = ⊤, a contradiction. So there exists some C ∈ F such that vctCF occurs in F ′. Consider the assignment ϕ′, which sets vctCF and all x ∈ C to true, while setting all other (remaining) new variables to false: ϕ′ satisfies F ′, a contradiction.\nExample 7.18 We conclude our basic considerations of “canonical translations” by discussing “unique extension properties”. A representation F ′ of F has the unique extension property (“uep”) if for every total satisfying assignment of F there is exactly one extension to a satisfying assignment of F ′. For every F ∈ CLS the representation ct(F ) of F has the uep, since a variable vctCF must be set to 1 precisely for those C ∈ F which are satisfied by ϕ in the DNF-sense (i.e., ϕ ∗ {C} = {⊥}). On the other hand, the representation ct–(F ) of F in general has not the uep: The total satisfying assignments for ct(F ) extending ϕ are exactly those which set at least one of the variables vctCF true for those C ∈ F which are satisfied in the DNF-sense.\nA representation F ′ of F has the strong unique extension property if for every partial assignment ϕ with ⊥ ∈ ϕ ∗ F (i.e., ϕ satisfied at least one of the DNFclauses) there is exactly one extension on the new variables (alone) to a satisfying assignment of F ′. For F ∈ HIT the representation ct(F ) of F has the strong uep, since the satisfying assignments given by the clauses of F are inconsistent with each other."
    }, {
      "heading" : "7.3 XOR-clauses",
      "text" : "For the n-bit parity function x1 ⊕ · · · ⊕ xn = 0 the unique equivalent clause-set prc0(x1 ⊕ · · · ⊕ xn = 0) (unique since the prime implicates are not resolvable) has 2n−1 clauses. We now show that a typical SAT translation of the n-bit parity function, using new variables yi (for i ∈ {2, . . . , n− 1}) to compute the xor of the first i bits, is in UC.\nLemma 7.19 Consider n ≥ 3, literals x1, . . . , xn with different underlying variables, and new variables y2, . . . , yn−1. Let F := P2 ∪ ( ⋃n−1 i=3 Pi ) ∪ Pn, where\n1. P2 := prc0(x1⊕x2 = y2) = {{x1, x2, y2}, {x1, x2, y2}, {x1, x2, y2}, {x1, x2, y2}}\n2. Pi := prc0(yi−1 ⊕ xi = yi) = {{yi−1, xi, yi}, {yi−1, xi, yi}, {yi−1, xi, yi}, {yi−1, xi, yi}}\n3. Pn := prc0(yn−1 ⊕ xn = 0) = {{yn−1, xn}, {yn−1, xn}}.\nWe have F ∈ UC, and F represents prc0(x1 ⊕ · · · ⊕ xn = 0).\nProof: Assume for the sake of contradiction that F /∈ UC. Thus there exists a partial assignment ϕ such that for F ′ := r1(ϕ ∗ F ) we have F ′ ∈ USAT , but F ′ 6= {⊥}. By definition F ′ has no clauses of size ≤ 1 and is non-empty. Observe that setting any variable in Pi for i ∈ {2, . . . , n− 1} yields a pair of binary clauses representing an equivalence or anti-equivalence between the two remaining variables. Also if Pi ∩ F ′ 6= ∅ for some i ∈ {2, . . . , n − 1}, then we have Pi ⊆ F ′, since all clauses of Pi contain all variables of Pi. Therefore we have F\n′ = E ∪ ⋃i∈I Pi for some subset I ⊆ {2, . . . , n− 1}, where E is a set of clauses representing a chain of equalities and inequalities. Consider the assignment ϕ′ := 〈xi → 0 : i ∈ I〉. We have ϕ′ ∗ Pi = ϕ′ ∗ prc0(yi−1 + xi = yi) = prc0(yi−1 = yi); note that xi is only in Pi, and so 〈xi → 1〉 only touches Pi. So ϕ′ ∗ F ′ now contains only variable-disjoint chains of equivalences and anti-equivalences, each trivially satisfiable, yielding a contradiction.\nExample 7.20 For n = 3 we get\nF = { {x1, x2, y2}, {x1, x2, y2}, {x1, x2, y2}, {x1, x2, y2} ︸ ︷︷ ︸\nx1 ⊕ x2 = y2\n, {y2, x3}, {y2, x3} ︸ ︷︷ ︸\ny2 ⊕ x3 = 0\n} .\nA very interesting question is how much the (simple) Lemma 7.19 can be extended, towards representing arbitrary systems of linear equations. It seems to us, that we do not have polysize representations with bounded hardness in the UC-framework:\nConjecture 7.21 As usual, an “XOR-clause” is a (boolean) constraint of the form x1 ⊕ · · · ⊕ xn = 0 for literals x1, . . . , xn, which we just represent by the clause {x1, . . . , xn} ∈ CL. An “XOR-clause-set” F is a set of XOR-clauses, which is just represented by an ordinary clause-set F ∈ CLS (with an alternative interpretation). The conjecture now is that XOR-clause-sets do not have good representations with bounded hardness, not even when using relative hardness. That is, there is no k ∈ N0 and no polynomial p(x) such that for all clause-sets F ∈ CLS there exists a CNF-representation F ′ ∈ CLS (possibly using new variables), taking F as an XOR-clause-set, with ℓ(F ′) ≤ p(ℓ(F )) and hdvar(F )(F ′) ≤ k.\nBasic results for showing such a lower bound are obtained in [8]. As we have already remarked (after Definition 7.4), regarding relative hardness only k ∈ {0, 1} are of relevance (because we allow new variables), while regarding absolute hardness we conjecture that also with new variables we have a proper hierarchy (Conjecture 7.3).\nWe conclude now our initial study on “good representations” by the basic observations regarding the naive approach for translating XOR-clause-sets."
    }, {
      "heading" : "8 Hardness under union",
      "text" : "When applied piecewise to a system of linear equations (with different auxiliary variables for each single equation), the translation from Lemma 7.19 does not yield a clause-set in UC, as we show in Theorem 8.5. To facilitate the precise computation of the hardness of the union of two such XOR-clause-translations, we present two general tools for upper bounds on hardness and one for lower bounds.\nLemma 8.1 Consider F ∈ CLS and V ⊆ var(F ). Let P be the set of partial assignments ψ with var(ψ) = V . Then hd(F ) ≤ |V |+maxψ∈P hd(ψ ∗ F ).\nProof: Consider a partial assignment ϕ with ϕ ∗ F ∈ USAT ; we have to show hd(ϕ ∗F ) ≤ |V |+maxψ∈P hd(ψ ∗F ). Build a resolution refutation of ϕ ∗F by first creating a splitting tree (possibly degenerated) on the variables of V ; this splitting tree (a perfect binary tree) has height |V |, and at each of its leaves we have a clause-set ϕ∗(ψ∗F ) for some appropriate ψ ∈ P . Thus at each leaf we can attach a splitting tree of Horton-Strahler number of hardness at most maxψ∈P hd(ψ∗F ), and from that (via the well-known correspondence of splitting trees and resolution trees; see [53, 59] for details) we obtain a resolution tree fulfilling the desired hardness bound.\nWe obtain an upper bound on the hardness of the union of two clause-sets:\nCorollary 8.2 For F1, F2 ∈ CLS holds hd(F1 ∪ F2) ≤ max(hd(F1), hd(F2)) + |var(F1) ∩ var(F2)|.\nProof: Apply Lemma 8.1 with F := F1∪F2 and V := var(F1)∩var(F2), and apply the general upper bound hd(F1 ∪ F2) ≤ max(hd(F1), hd(F2)) for variable-disjoint F1, F2 (Lemma 15 in [36]).\nSubstitution of literals can not increase (w-)hardness:\nLemma 8.3 Consider a clause-set F ∈ USAT and (arbitrary) literals x, y. Denote by Fx←y ∈ USAT the result of replacing x by y and x by y in F , followed by removing clauses containing complementary literals. Then we have hd(Fx←y) ≤ hd(F ) and whd(Fx←y) ≤ whd(F ).\nProof: Consider T : F ⊢ ⊥. It is a well-known fact (and a simply exercise), that the substitution of y into x can be performed in T , obtaining Tx←y : Fx←y ⊢ ⊥. This is easiest to see by performing first the substitution with T itself, obtaining a tree T ′ which as a binary tree is identical to T , using “pseudo-clauses” with (possibly) complementary literals; the resolution rule for sets C,D of literals with x ∈ C and x ∈ D allows to derive the clause (C \\ {x}) ∪ (D \\ {x}), where the resolution-variables are taken over from T . Now “tautological” clauses (containing complementary literals) can be cut off from T ′: from the root (labelled with ⊥) go to a first resolution step where the resolvent is non-tautological, while one of the parent clauses is tautological (note that not both parent clauses can be tautological)\n— the subtree with the tautological clause can now be cut off, obtaining a new pseudo-resolution tree where clauses only got (possibly) shorter (see Lemma 6.1, part 1, in [59]). Repeating this process we obtain Tx←y as required. Obviously hs(Tx←y) ≤ hs(T ), and if in T for every resolution step at least one of the parent clauses has length at most k for some fixed (otherwise arbitrary) k ∈ N0, then this also holds for Tx←y.\nExample 8.4 The simplest example showing that for satisfiable clause-sets F (w)hardness can be increased by substitution is given by F := {{x}, {y}} for var(x) 6= var(y). Here hd(F ) = 0, while Fx←y = {{y}, {y}}, and thus hd(Fx←y) = 1.\nNow we are ready to determine the (high) hardness of the union of the (piecewise) translation of two XOR-clauses for a basic special case:\nTheorem 8.5 For n ≥ 3 consider the system x1 ⊕ x2 ⊕ · · · ⊕ xn = 0 x1 ⊕ x2 ⊕ · · · ⊕ xn = 0.\nLet F := F1 ∪ F2, where F1 is the translation of the first equation by Lemma 7.19, and F2 is the translation of the second equation, using different auxiliary variables (so n(F ) = 2 · (n+ (n− 2))− n = 3n− 4). We have F ∈ USAT with hd(F ) = n. Proof: From Corollary 8.2 and Lemma 7.19 we obtain hd(F ) ≤ n + 1. Better is to apply Lemma 8.1 with V := var({x2, . . . , xn−1}). By definition we see that ψ ∗ F ∈ 2–CLS (i.e., all clauses have length at most two) for ψ with var(ψ) = V . By Lemma 19 in [36] we have hd(ψ ∗ F ) ≤ 2, and thus hd(F ) ≤ (n − 2) + 2 = n. The lower bound is obtained by an application of Lemma 3.6. Consider any literal x ∈ lit(Fn), where the subscript in Fn = F makes explicit the dependency on n. Setting x to true or false results either in an equivalence or in an anti-equivalence. Propagating this (anti-)equivalence yields a clause-set F ′ isomorphic to Fn−1, where by Lemma 8.3 this propagation does not increase hardness, so we have hd(〈x → 1〉 ∗ Fn) ≥ hd(F ′) = hd(Fn−1). The argumentation can be trivially extended for n ∈ {0, 1, 2}, and so by Lemma 3.6 we get hd(F ) ≥ n. If F1, F2 in Theorem 8.5 were the direct translations (with hd(F1) = hd(F2) = 0), then hd(F ) = n would follow easily with Lemma 3.18 in [53], since then F would be simply the clause-set with all 2n clauses of length n. Of course, regarding a good translation of the system from Theorem 8.5 we can just use {⊥}, easily computed by preprocessing — however the content of Conjecture 7.21 is, that no preprocessing is powerful enough to handle arbitrary (satisfiable!) systems of linear equations (over the two-element field)."
    }, {
      "heading" : "9 Basic experiments",
      "text" : "In this section we perform some experiments on the use of the three different mechanisms for representing boolean functions f studied in this article:\n1. clause-sets F equivalent to f with F ∈ UCk where k is as low as feasible; 2. the canonical translation ct(G) for a DNF-clause-set G equivalent to f ;\n3. and the reduced canonical translation ct–(G).\nThe instances are described in Subsection 9.1, while the experimental results are discussed in Subsection 9.2. Our focus is on gaining a better understanding of the interaction between solver behaviour and problem representation, and so we consider various representative complete SAT solvers."
    }, {
      "heading" : "9.1 The instances",
      "text" : "For our experiments we want to take a boolean function fk,h as a constraint in a bigger SAT problem Gk,h. The “optimal” equivalent representation Fk,h of fk,h shall have hardness k, and fk,h should also have a small equivalent DNF, so that the canonical and reduced canonical translation are available.\nFor fk,h we take the boolean functions from Theorem 6.13, which have the short CNF’s (without new variables) Fk,h := D(F\n1(Tk,h)) for k ≥ 2 and h ≥ k + 1, where Tk,h ∈ HS(k, h). So Fk,h has hardness k, while every equivalent clause-set of hardness at most k−1 contains at least b(m) := ( m\n⌊m2 ⌋ ) many clauses for m := h−k.\nFor the “completion” to Gk,h let F ′ k,h be the negation of Fk,h according to the remarks to Lemma 7.13, that is, F ′k,h is obtained from Fk,h by complementing the doping literals in each clause. Let F := {C : C ∈ F} for F ∈ CLS. Note that F ′k,h is the DNF for Fk,h. We define G i k,h for i = 1, 2, 3 as always including F ′ k,h, and additionally\n1. G1k,h uses Fk,h, i.e., G 1 k,h := F ′ k,h ∪ Fk,h.\n2. G2k,h uses the canonical translation according to Theorem 7.14 (and Lemma\n7.13), i.e., G2k,h := F ′ k,h ∪ ct(F ′k,h).\n3. G3k,h uses the reduced canonical translation according to Lemma 7.17 (and\nLemma 7.13), i.e., G3k,h := F ′ k,h ∪ ct–(F ′k,h),\nThe sizes of the Gik,h are determined as follows:\n• By Lemma 6.9 we have c(Fk,h) = α(k, h), while n(Fk,h) = 2c(Fk,h) − 1 = 2α(k, h)− 1.\n• The size of F ′k,h is precisely the same.\n• So n(G1k,h) = 2α(k, h)− 1 and c(G1k,h) = 2α(k, h), while ℓ(G1k,h) = 2ℓ(Fk,h).\n• n(G2k,h) = n(G3k,h) = 3α(k, h)− 1.\n• c(G3k,h) = 1 + α(k, h) + ℓ(Fk,h) and ℓ(G3k,h) = α(k, h) + 3ℓ(Fk,h).\n• c(G2k,h) = 1 + 2α(k, h) + ℓ(Fk,h) and ℓ(G3k,h) = 2α(k, h) + 4ℓ(Fk,h).\nSee Figure 6 for the numerical data. The lower bounds b(h−k) there for the number of clauses in any clause-set F equivalent to Fk,h and with F ∈ WCk−1 show that these representations are infeasible here. As an amusing fact one can note here that the number of clauses in F ∈ WC0 would be (precisely) 2c − 1, which even for the smallest example considered is a rather astronomical number. We can determine the hardness of the Gik,h precisely; first an auxiliary lemma:\nLemma 9.1 For F ∈ CLS and F ′ ∈ {ct(F ), ct–(F )} holds F ∪ F ′ ∈ USAT and hd(F ∪ F ′) ≤ 2.\nProof: Due to ct–(F ) ⊆ ct(F ) w.l.o.g. F ′ = ct–(F ), since UC2 ∩ USAT is closed under formation of super-clause-sets by Lemma 6.7 in [38]. For all C ∈ F and x ∈ C the binary clause vctC → x is in F ′. Thus setting vctC to 1 in F ∪ F ′ results in setting x to 1 via r1, which altogether falsifies C ∈ F . Thus r2 applied to F ∪ F ′ sets all vctC to 0, which falsifies {vctC : C ∈ F} ∈ F ′.\nNow the (total) hardness of the unsatisfiable SAT problems Gk,h is as follows:\nLemma 9.2 Consider k, h ∈ N with k ≥ 2 and h ≥ k + 1. We have: 1. hd(G1k,h) = k + 1.\n2. hd(G2k,h) = hd(G 3 k,h) = 2.\nProof: hd(G1k,h) = k+1 follows from the fact, that by definition G 1 k,h ∈ SMU δ=1 holds, where the corresponding tree T := T1(G1k,j) has Horton-Strahler number k + 1 (recall Lemma 5.21): T is obtained from the underlying Tk,h by replacing each leaf with the full binary tree with three nodes. G2k,h and G 3 k,h have hardness at least 2 since they are unsatisfiable and contain no unit-clauses. The remaining assertions follow by Lemma 9.1."
    }, {
      "heading" : "9.2 Solver performances",
      "text" : "For the experiments we used a 64-bit workstation with 32 GB RAM and Intel i52320 CPUs (6144 KB cache) running with 3 GHz, where we only employed a single CPU. To emphasise again, the aim of these experiments is to obtain a qualitative picture of the behaviour of a range of contemporary SAT solvers, and not to find out which solver is “fastest”. For our experimentation we use the following solvers:\n1. OKsolver ([57]): a look-ahead solver, used as a “theoretical” solver.\n2. MiniSat-family:\n(a) MiniSat, version 2.2 (see [79]).\n(b) CryptoMiniSat, version 2.9.6 (see [76]).\n(c) Glucose, version 2.0 (see [3]).\n3. Lingeling-family:\n(a) PicoSAT, version 913 (see[10, 12]).\n(b) PrecoSAT, version 570 ([11]).\n(c) Lingeling, version ala-b02aa1a-121013 (see [12, 13]).\nFirst we consider the OKsolver (see Figure 6), as a look-ahead solver (see [42, 60] for the general concepts), as well as a solver with a “clean” behaviour, due to the minimisation of the use of heuristical shortcuts. For example, the OKsolver seems to be the only SAT-solver computing r2, while all other solvers (recall the discussion in Subsection 1.6) only test selected literals for failed literals. We see that the G1k,h are far easier than the G 2,3 k,h, although they require branching. Indeed, the straightforward heuristics choosing a variable occurring most often will find a backtracking tree of optimal, i.e., linear size (note that all F ∈ SMUδ=1 have exactly one variable occurring in every clause, and splitting on this variable creates two variable-disjoint instances). In conformance with this, linear regression shows with high correlation that the instances G1k,h are solved by the OKsolver in linear time, i.e., O(ℓ). Considering now G2,3k,h, recall that by Lemma 9.2 all these instances have hardness 2, that is, they can be solved without branching. And in fact the number of r2-reductions of the OKsolver for these instances is precisely c(Fk,h)− 1, in accordance with Lemma 9.1. The worst-case running time for r2 is O(n\n2 · ℓ), but in this case going once through the list of all variables is sufficient to find the contradiction. Again in conformance with this, linear regression shows with high correlation that the instances G2,3k,h are solved in time O(n · ℓ). We note here that the OKsolver is actually the fastest solver on these instances, for all three types, though this is not the focus of these experiments.\nOther look-ahead solvers performed badly on these instances. satz performs very badly even on the very easy ones: on G12,22 it needed 4.3 sec, and on G 1 2,32 already 2 hours. Thus it was not considered further. march pl performed somewhat better, but was also not able to complete even the easier instancesG1k,h; furthermore it crashed on various instances, and was thus also not considered further.\nNow we turn to the conflict-driven solvers (see [67] for a general introduction), where we consider the MiniSat-family (Figure 7) and the Lingeling-family (Figure 8). Considering G1k,h, we note that MiniSat as well as PrecoSAT always solve these instances by preprocessing. And actually MiniSat -no-pre (without preprocessing) solves these instances faster (by branching) than with preprocessing. While PicoSAT, which also does not use preprocessing, is not much slower than PrecoSAT. With the largest instance G15,35, all solvers except of PrecoSAT have considerable difficulties, but all can handle it (only PicoSAT aborts, likely due to a bug). That OKsolver is much faster here we believe is due to the fact, that in general look-ahead solvers should be better than conflict-driven solvers on unsatisfiable instances, where the shortest refutations are (close to) tree-like (and in this case the tree-like refutation of F ∈ SMUδ=1 given by the underlying tree T1(F ) is the shortest possible overall).\nTurning to G2,3k,h, we see that CryptoMiniSat as well as PicoSAT solve the easier instances with failed-literal elimination (without branching). Most of the time these instances are harder than their G1k,h counterparts, and for k ∈ {4, 5} much more so, and actually no solver here was able to handle k = 5 with h = 35. There seems to be no essential difference between G2k,h and G 3 k,h (different from the OKsolver, whose running time was proportionally larger for G2k,h, according to the bigger size)."
    }, {
      "heading" : "10 Conclusion and open problems",
      "text" : "We have discussed three hierarchies PCk, UCk and WCk of target classes for “good” SAT representations. We showed that each level of UCk+1 contains clause-sets without equivalent short clause-sets inWCk. And we showed conditions under which\nthe Tseitin translation produces translations in UC. We conclude by directions for future research."
    }, {
      "heading" : "10.1 Strictness of hierarchies",
      "text" : "A fundamental question is the strictness of the hierarchies PCk, UCk and WCk in each of the dimensions. In Theorem 6.14 we have shown w.r.t. logical equivalence (i.e., without new variables) that the UCk and WCk hierarchies are strict. It follows that for PCk at least every second level yields an advance regarding logical equivalence (and polysize). This offer evidence that these hierarchies are useful, for example using failed literal reduction can allow one to use exponentially smaller SAT translations. Open are the questions of strictness for the hierarchies allowing new variables. To summarise, the main conjectures are:\n1. Conjecture 6.15 strengthens Theorem 6.14 by taking the PC-hierarchy into account.\n2. Conjecture 7.3 roughly says that all of PCk, UCk and WCk are strict (similar to Theorem 6.14), when allowing new variables under the absolute condition.\n3. Conjecture 7.5 says that the WCk hierarchy collapses to WC1 (and thus to PC1), when allowing new variables under the relative condition."
    }, {
      "heading" : "10.2 Separating the different hierarchies",
      "text" : "For stating our three main conjectures relating the three hierarchies, we use the following notions:\n• A sequence (F ′n)n∈N is called a CNF-representation of (Fn)n∈N if for all n ∈ N the clause-set F ′n is a CNF-representation of Fn.\n• A polysize sequence in C ⊆ CLS is a sequence (Fn)n∈N with Fn ∈ C for all n ∈ N, such that (ℓ(Fn))n∈N is polynomially bounded (i.e., there is a polynomial p(x) with ℓ(Fn) ≤ p(n) for all n ∈ N).\nWe conjecture that WC2 even without new variables offers possibilities for good representations not offered by any UCk:\nConjecture 10.1 There exists a polysize (Fn)n∈N in WC2, such that for no k ∈ N0 there exists a polysize CNF-representation (F ′n)n∈N of (Fn)n∈N in UCk. A proof of Conjecture 10.1 needed, besides the novel handling of the new variables, to develop lower-bounds methods specifically for hardness, since the method via trigger hypergraphs yields already lower bounds for w-hardness.\nWe conjecture that new variables can not simulate higher hardness, strengthening Theorem 6.14, Conjecture 6.15 and Conjecture 7.3:\nConjecture 10.2 For every k ∈ N0 there exists a polysize (Fn)n∈N in PCk+1, such that there is no polysize CNF-representation (F ′n)n∈N of (Fn)n∈N in WCk.\nFinally we conjecture that there is a sequence of boolean functions which has polysize arc-consistent representations, but no polysize representations of bounded hardness, even for the w-hardness:\nConjecture 10.3 There exists a polysize (Fn)n∈N in CLS, such that there is a polysize CNF-representation (F ′n)n∈N of (Fn)n∈N with hd\nvar(Fn)(F ′n) ≤ 1 for all n ∈ N, while for no k ∈ N0 there is a polysize CNF-representation (F ′′n )n∈N of (Fn)n∈N in WCk.\nRegarding our notion of a “polysize sequence” (Fn)n∈N, this is a very liberal notion, allowing to express arbitrary boolean functions, since the number of variables could be logarithmic in the index, and thus Fn could contain exponentially many clauses in the number of variables. The sequence of Theorem 6.14 also fulfils n(Fn) = Ω(n), and making this provision one could speak of “simple” boolean functions, however this would complicate the formulations of our conjectures, and so we abstained from it.\nWe conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR∗(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38]. From the point of view of polysize representations without new variables, the hierarchy CANON(k) collapses to CANON(0) = UC0:\nLemma 10.4 For F ∈ CLS let k(F ) be the minimal k ∈ N0 such that F ∈ CANON(k). Then the function prc0 : CLS → CANON(0) = UC0 can be computed in time O(c(F )3·2 k · ℓ(F )), when the input is F together with k := k(F ).\nProof: Let K := 2k. So for every C ∈ prc0(F ) there exists F ′ ⊆ F with F ′ |= C and c(F ′) ≤ K, since a resolution tree of height k has at most K leaves. Now we compute prc0(F ) as follows:\n1. Set P := ∅.\n2. Run through all F ′ ⊆ F with c(F ′) ≤ K; their number is O(c(F )K ).\n3. For each F ′ determine whether F ′ |= puc(F ′) holds, in which case clause puc(F ′) is added to P ; note that the test can be performed in time O(2K ·K).\n4. The final P obtained has O(c(F )K ) many elements. After performing subsumption elimination (in cubic time) we obtain prc0(F ) (by Lemma 4.7).\nIt seems an interesting question whether the two other hierarchies SLUR(k), SLUR∗(k) collapse or not, and whether they can be reduced to some UCk."
    }, {
      "heading" : "10.3 Compilation procedures",
      "text" : "For a given boolean function f and k ∈ N0, how do we find algorithmically a “small” equivalent F ∈ UCk ? In [38], Section 8, the notion of a “k-base for f” is introduced, which is an F ∈ UCk equivalent to f , with F ⊆ prc0(f) and where no clause can be removed without increasing the hardness or destroying equivalence. It is shown that if f is given as a 2-CNF, then a smallest k-base is computable in polynomial time, but even for f with given prc0(f), where prc0(f) is a Horn clause-set, deciding whether a k-base of a described size for a fixed k ≥ 1 exists is NP-complete.\nThere are interesting applications where prc0(f) is given (or can be computed), and where then some small equivalent F ∈ UCk is sought. The most basic approach filters out unneeded prime implicates; see [35, 34] for some initial applications to cryptanalysis. A simple filtering heuristic, used in [35, 34], is to favour (keeping) short-clauses. In a first phase, starting with the necessary elements of prc0(f), further elements are added (when needed) in ascending order of size for building up the initial F ∈ UCk (which in general is not a base). In the second phase, clauses from F are removed in descending order of size when reducing to a k-base. The intuition behind this heuristic is that small clauses cover more total assignments (so fewer are needed), and they are also more likely to trigger rk, making them more useful in producing small, powerful representations. Essentially the same heuristic is considered in [15] (called “length-increasing iterative empowerment”) when generating representations in PC.\nFor the case that f is given by a CNF F0, in [26] one finds refinements of the resolution procedure applied to F0, which would normally compute prc0(f), i.e., the 0-base in UC0, and where by some form of “compression” now an equivalent F ∈ UC1 is computed. This approach needed to be generalised to arbitrary UCk."
    }, {
      "heading" : "10.4 Exploring w-hardness",
      "text" : "It is to be expected that w-hardness can behave very differently from hardness. For example, as expressed by Conjecture 10.1, already its second level should enable contain short clause-sets not representable in any UCk. However yet we do not have tools at hand to handle w-hardness (we do not even have yet a conjectured example for such a separation). A first task is to investigate which of the results on hardness from this article and from [38] can be adapted to w-hardness. In [9] we will present some basic methods for w-hardness bounds.\nCan the classes WCk go beyond monotone circuits, which were shown in [8] to be strongly related to the expressive power of arc-consistent CNF representations (see the following subsection for some further remarks)? Conjecture 7.5 would show the contrary, namely that in the (unrestricted) presence of new variables also whardness boils down, modulo polytime computations, to PC1 (under the relative condition!). If this is true, then the believable greater power of WCk over UCk would all take place inside arc-consistency; and by Conjecture 10.3 it would take place strictly inside arc-consistency."
    }, {
      "heading" : "10.5 Hard boolean functions handled by oracles",
      "text" : "Finally we turn to concrete (sequences of) boolean functions which are currently out of reach of good presentations, and where the use of oracles thus is necessary.\nConjecture 7.21 says that systems of XOR-clauses (affine equations) have no good representation, even when just considering arc-consistency. So the conjecture is that here we have another example for the limitations of arc-consistent representations as shown in [8]. To overcome these (conjectured) limitations, the theory started here has to be generalised via the use of oracles as developed in [53, 59], and further discussed in Subsection 9.4 of [37, 38]. The point of these oracles, which are just sets U ⊆ USAT of unsatisfiable clause-sets stable under application of partial assignments, is to discover hard unsatisfiable (sub-)instances (typically in polynomial time). Thus they are conceptually simpler than the current integration of SAT solvers and methods from linear algebra (see [78, 20, 77, 39, 64]).\nAn important aspect of the theory to be developed must be the usefulness of the representation (with oracles) in context, that is, as a “constraint” in a bigger problem: a boolean function f represented by a clause-set F is typically contained in F ′ ⊃ F , where F ′ is the SAT problem to be solved (containing also other constraints). One approach is to require from the oracle also stability under addition of clauses, as we have it already for the resolution-based reductions like rk, so that the (relativised) reductions rUk can always run on the whole clause-set (an instantiation of F ′). However for example for the oracle mentioned below, based on semidefinite programming, this would be prohibitively expensive. And for some oracles, like detection of minimally unsatisfiable clause-sets of a given deficiency, the problems would turn from polytime to NP-hard in this way ([30, 16]). Furthermore, that we have some representation of a constraint which would benefit for example from some XOR-oracle, does not mean that in other parts of the problems that oracle will also be of help. So in many cases it is better to restrict the application of the oracle U to that subset F ⊂ F ′ where to achieve the desired hardness the oracle is actually required.\nAnother example of a current barrier is given by the satisfiable pigeonhole clausesets PHPmm, which have variables pi,j for i, j ∈ {1, . . . ,m}, and where the satisfying assignments correspond precisely to the permutations of {1, . . . ,m}. The question is about “good” representations. In [9] we show hd(PHPmm) = whd(PHP m m) = m − 1, and so the (standard representation) PHPmm ∈ CLS itself is not a good representation (it is small, but has high w-hardness). Actually, as explained in [9], from [8] it follows that PHPmm has no polysize arc-consistent representation at all! So again, here oracles are needed; see Subsection 9.4 of [37, 38] for a proposal of an interesting oracle (with potentially good stability properties)."
    } ],
    "references" : [ {
      "title" : "Measuring the hardness of SAT instances",
      "author" : [ "Carlos Ansótegui", "Maŕıa Luisa Bonet", "Jordi Levy", "Felip Manyà" ],
      "venue" : "Proceedings of the 23th AAAI Conference on Artificial Intelligence",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2008
    }, {
      "title" : "Predicting learnt clauses quality in modern SAT solvers",
      "author" : [ "Gilles Audemard", "Laurent Simon" ],
      "venue" : "Proceedings of the 21st International Joint Conference on Artificial intelligence,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "Efficient CNF encoding of boolean cardinality constraints",
      "author" : [ "Olivier Bailleux", "Yacine Boufkhad" ],
      "venue" : "In Principles and Practice of Constraint Programming – CP 2003,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2003
    }, {
      "title" : "On hierarchies over the SLUR class",
      "author" : [ "Tomáš Balyo", "Štefan Gurský", "Petr Kučera", "Václav Vlček" ],
      "venue" : "In Twelfth International Symposium on Artificial Intelligence and Mathematics (ISAIM",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2012
    }, {
      "title" : "Short proofs are narrow — resolution made simple",
      "author" : [ "Eli Ben-Sasson", "Avi Wigderson" ],
      "venue" : "In Proceedings of the 31th Annual ACM Symposium on Theory of Computing",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1999
    }, {
      "title" : "Circuit complexity and decompositions of global constraints",
      "author" : [ "Christian Bessiere", "George Katsirelos", "Nina Narodytska", "Toby Walsh" ],
      "venue" : "In Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence (IJCAI-",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Hardness measures and resolution lower bounds, with applications to Pigeonhole principles",
      "author" : [ "Olaf Beyersdorff", "Matthew Gwynne", "Oliver Kullmann" ],
      "venue" : "In preparation,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2013
    }, {
      "title" : "Picosat essentials",
      "author" : [ "Armin Biere" ],
      "venue" : "Journal on Satisfiability, Boolean Modeling and Computation,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2008
    }, {
      "title" : "Lingeling, Plingeling, PicoSAT and PrecoSAT at SAT Race",
      "author" : [ "Armin Biere" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2010
    }, {
      "title" : "Lingeling and friends entering the SAT Challenge",
      "author" : [ "Armin Biere" ],
      "venue" : "Proceedings of SAT Challenge 2012: Solver and Benchmark Descriptions,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "Handbook of Satisfiability, volume 185 of Frontiers in Artificial Intelligence and Applications",
      "author" : [ "Armin Biere", "Marijn J.H. Heule", "Hans van Maaren", "Toby Walsh", "editors" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2009
    }, {
      "title" : "Knowledge compilation with empowerment",
      "author" : [ "Lucas Bordeaux", "Joao Marques-Silva" ],
      "venue" : "SOFSEM 2012: Theory and Practice of Computer Science,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "The complexity of read-once resolution",
      "author" : [ "Hans Kleine Büning", "Xishun Zhao" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2002
    }, {
      "title" : "On resolution with short clauses",
      "author" : [ "Michael Buro", "Hans Kleine Büning" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1996
    }, {
      "title" : "A survey of knowledge compilation",
      "author" : [ "Marco Cadoli", "Francesco M. Donini" ],
      "venue" : "AI Communications,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1997
    }, {
      "title" : "Properties of SLUR formulae",
      "author" : [ "Ondřej Čepek", "Petr Kučera", "Václav Vlček" ],
      "venue" : "SOFSEM 2012: Theory and Practice of Computer Science,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2012
    }, {
      "title" : "An exponential example for analytic tableaux",
      "author" : [ "Stephen A. Cook" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1973
    }, {
      "title" : "Boolean Functions: Theory, Algorithms, and Applications, volume 142 of Encyclopedia of Mathematics and Its Applications",
      "author" : [ "Yves Crama", "Peter L. Hammer" ],
      "venue" : null,
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2011
    }, {
      "title" : "Complexity of Constraints: An Overview of Current Research Themes, volume 5250 of Lecture Notes in Computer",
      "author" : [ "Nadia Creignou", "Phokion Kolaitis", "Heribert Vollmer", "editors" ],
      "venue" : "Science (LNCS). Springer,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2008
    }, {
      "title" : "A knowledge compilation map",
      "author" : [ "Adnan Darwiche", "Pierre Marquis" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2002
    }, {
      "title" : "Tractable databases: How to make propositional unit resolution complete through compilation",
      "author" : [ "Alvaro del Val" ],
      "venue" : "In Proceedings of the 4th International Conference on Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1994
    }, {
      "title" : "On some tractable classes in deduction and abduction",
      "author" : [ "Alvaro del Val" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2000
    }, {
      "title" : "Translating pseudo-boolean constraints into SAT",
      "author" : [ "Niklas Eén", "Niklas Sörensson" ],
      "venue" : "Journal on Satisfiability, Boolean Modeling and Computation,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2006
    }, {
      "title" : "Extending the knowledge compilation map: Krom, Horn, Affine and beyond",
      "author" : [ "Hélène Fargier", "Piere Marquis" ],
      "venue" : "ECAI 2008,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2008
    }, {
      "title" : "Polynomial–time recognition of minimal unsatisfiable formulas with fixed clause–variable difference",
      "author" : [ "Herbert Fleischner", "Oliver Kullmann", "Stefan Szeider" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2002
    }, {
      "title" : "A perspective on certain polynomial-time solvable classes of satisfiability",
      "author" : [ "John Franco", "Allen Van Gelder" ],
      "venue" : "Discrete Applied Mathematics,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2003
    }, {
      "title" : "Arc consistency in SAT",
      "author" : [ "Ian P. Gent" ],
      "venue" : "Proceedings of the 15th European Conference on Artificial Intelligence (ECAI",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2002
    }, {
      "title" : "The propositional formula checker HeerHugo",
      "author" : [ "Jan Friso Groote", "Joost P. Warners" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2000
    }, {
      "title" : "Towards a better understanding of hardness",
      "author" : [ "Matthew Gwynne", "Oliver Kullmann" ],
      "venue" : "In The Seventeenth International Conference on Principles and Practice of Constraint Programming (CP 2011): Doctoral Program Proceedings,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2011
    }, {
      "title" : "Towards a better understanding of SAT translations",
      "author" : [ "Matthew Gwynne", "Oliver Kullmann" ],
      "venue" : "Logic and Computational Complexity (LCC’11),",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2011
    }, {
      "title" : "Generalising and unifying SLUR and unit-refutation completeness",
      "author" : [ "Matthew Gwynne", "Oliver Kullmann" ],
      "venue" : "SOFSEM 2013: Theory and Practice of Computer Science,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2013
    }, {
      "title" : "Generalising unit-refutation completeness and SLUR via nested input resolution",
      "author" : [ "Matthew Gwynne", "Oliver Kullmann" ],
      "venue" : "Technical Report arXiv:1204.6529v5 [cs.LO],",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2013
    }, {
      "title" : "Generalising unit-refutation completeness and SLUR via nested input resolution",
      "author" : [ "Matthew Gwynne", "Oliver Kullmann" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2013
    }, {
      "title" : "When boolean satisfiability meets Gaussian elimination in a Simplex way",
      "author" : [ "Cheng-Shen Han", "Jie-Hong Roland Jiang" ],
      "venue" : "Computer Aided Verification,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2012
    }, {
      "title" : "St̊almarck’s algorithm as a HOL derived rule. In Theorem proving in higher order logics: 9th International Conference, TPHOLs’96",
      "author" : [ "John Harrison" ],
      "venue" : "Lecture Notes in Computer Science",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 1996
    }, {
      "title" : "Marcheq: Implementing additional reasoning into an efficient look-ahead SAT solver",
      "author" : [ "Marijn Heule", "Mark Dufour", "Joris van Zwieten", "Hans van Maaren" ],
      "venue" : "In Hoos and Mitchell",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2034
    }, {
      "title" : "Limitations of restricted branching in clause",
      "author" : [ "Matti Järvisalo", "Tommi Junttila" ],
      "venue" : "learning. Constraints,",
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 2009
    }, {
      "title" : "Živný. Relating proof complexity measures and practical hardness of SAT",
      "author" : [ "Matti Järvisalo", "Arie Matsliah", "Jakob Nordström", "Stanislav" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2012,",
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 2012
    }, {
      "title" : "The effect of structural branching on the efficiency of clause learning SAT solving: An experimental study",
      "author" : [ "Matti Järvisalo", "Ilkka Niemelä" ],
      "venue" : "Journal of Algorithms,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 2008
    }, {
      "title" : "Algebraic attacks using SAT-solvers",
      "author" : [ "Philipp Jovanovic", "Martin Kreuzer" ],
      "venue" : "Groups-Complexity-Cryptology,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 2010
    }, {
      "title" : "Two encodings of DNNF theories, July 2008. Presented at ECAI’08 Workshop on Inference methods based on Graphical Structures of Knowledge",
      "author" : [ "Jean Christoph Jung", "Pedro Barahoma", "George Katsirelos", "Toby Walsh" ],
      "venue" : "Proceedings at http://www.irit.fr/LC/",
      "citeRegEx" : "49",
      "shortCiteRegEx" : "49",
      "year" : 2008
    }, {
      "title" : "An incremental method for generating prime implicants/implicates",
      "author" : [ "Alex Kean", "George Tsiknis" ],
      "venue" : "Journal of Symbolic Computation,",
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 1990
    }, {
      "title" : "On generalized Horn formulas and k-resolution",
      "author" : [ "Hans Kleine Büning" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "51",
      "shortCiteRegEx" : "51",
      "year" : 1993
    }, {
      "title" : "Investigating a general hierarchy of polynomially decidable classes of CNF’s based on short tree-like resolution proofs",
      "author" : [ "Oliver Kullmann" ],
      "venue" : "Technical Report TR99-041, Electronic Colloquium on Computational Complexity (ECCC), October",
      "citeRegEx" : "53",
      "shortCiteRegEx" : "53",
      "year" : 1999
    }, {
      "title" : "New methods for 3-SAT decision and worst-case analysis",
      "author" : [ "Oliver Kullmann" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "54",
      "shortCiteRegEx" : "54",
      "year" : 1999
    }, {
      "title" : "On a generalization of extended resolution",
      "author" : [ "Oliver Kullmann" ],
      "venue" : "Discrete Applied Mathematics,",
      "citeRegEx" : "55",
      "shortCiteRegEx" : "55",
      "year" : 1999
    }, {
      "title" : "An application of matroid theory to the SAT problem",
      "author" : [ "Oliver Kullmann" ],
      "venue" : "In Fifteenth Annual IEEE Conference on Computational Complexity",
      "citeRegEx" : "56",
      "shortCiteRegEx" : "56",
      "year" : 2000
    }, {
      "title" : "Investigating the behaviour of a SAT solver on random formulas",
      "author" : [ "Oliver Kullmann" ],
      "venue" : "Technical Report CSR 23-2002,",
      "citeRegEx" : "57",
      "shortCiteRegEx" : "57",
      "year" : 2002
    }, {
      "title" : "The combinatorics of conflicts between clauses",
      "author" : [ "Oliver Kullmann" ],
      "venue" : "In Enrico Giunchiglia and Armando Tacchella, editors, Theory and Applications of Satisfiability Testing 2003,",
      "citeRegEx" : "58",
      "shortCiteRegEx" : "58",
      "year" : 2004
    }, {
      "title" : "Upper and lower bounds on the complexity of generalised resolution and generalised constraint satisfaction problems",
      "author" : [ "Oliver Kullmann" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "59",
      "shortCiteRegEx" : "59",
      "year" : 2004
    }, {
      "title" : "Theory and Applications of Satisfiability Testing - SAT 2009, volume 5584 of Lecture",
      "author" : [ "Oliver Kullmann", "editor" ],
      "venue" : "Notes in Computer Science. Springer,",
      "citeRegEx" : "61",
      "shortCiteRegEx" : "61",
      "year" : 2009
    }, {
      "title" : "Constraint satisfaction problems in clausal form II: Minimal unsatisfiability and conflict structure",
      "author" : [ "Oliver Kullmann" ],
      "venue" : "Fundamenta Informaticae,",
      "citeRegEx" : "62",
      "shortCiteRegEx" : "62",
      "year" : 2011
    }, {
      "title" : "On Davis-Putnam reductions for minimally unsatisfiable clause-sets",
      "author" : [ "Oliver Kullmann", "Xishun Zhao" ],
      "venue" : "Technical Report arXiv:1202.2600v5 [cs.DM],",
      "citeRegEx" : "63",
      "shortCiteRegEx" : "63",
      "year" : 2012
    }, {
      "title" : "Conflict-driven XOR-clause learning",
      "author" : [ "Tero Laitinen", "Tommi Junttila", "Ilkka Niemelä" ],
      "venue" : "Theory and Applications of Satisfiability Testing SAT 2012, volume LNCS 7317 of Lecture Notes in Computer Science,",
      "citeRegEx" : "64",
      "shortCiteRegEx" : "64",
      "year" : 2012
    }, {
      "title" : "Heuristics based on unit propagation for satisfiability problems",
      "author" : [ "Chu Min Li", "Anbulagan" ],
      "venue" : "In Proceedings of 15th International Joint Conference on Artificial Intelligence",
      "citeRegEx" : "65",
      "shortCiteRegEx" : "65",
      "year" : 1997
    }, {
      "title" : "Computing minimally unsatisfiable subformulas: State of the art and future directions",
      "author" : [ "Joao Marques-Silva" ],
      "venue" : "Journal of Multiple-Valued Logic and Soft Computing,",
      "citeRegEx" : "66",
      "shortCiteRegEx" : "66",
      "year" : 2012
    }, {
      "title" : "On the power of clause-learning SAT solvers with restarts",
      "author" : [ "Knot Pipatsrisawat", "Adnan Darwiche" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2009,",
      "citeRegEx" : "68",
      "shortCiteRegEx" : "68",
      "year" : 2009
    }, {
      "title" : "On the power of clause-learning SAT solvers as resolution engines",
      "author" : [ "Knot Pipatsrisawat", "Adnan Darwiche" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "69",
      "shortCiteRegEx" : "69",
      "year" : 2011
    }, {
      "title" : "A structure-preserving clause form translation",
      "author" : [ "David A. Plaisted", "Steven Greenbaum" ],
      "venue" : "Journal of Symbolic Computation,",
      "citeRegEx" : "70",
      "shortCiteRegEx" : "70",
      "year" : 1986
    }, {
      "title" : "Hierarchies of polynomially solvable satisfiability problems",
      "author" : [ "Daniele Pretolani" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "71",
      "shortCiteRegEx" : "71",
      "year" : 1996
    }, {
      "title" : "A tutorial on St̊almarck’s proof procedure for propositional logic",
      "author" : [ "Mary Sheeran", "Gunnar St̊almarck" ],
      "venue" : "In FMCAD’98,",
      "citeRegEx" : "73",
      "shortCiteRegEx" : "73",
      "year" : 1998
    }, {
      "title" : "Towards an optimal CNF encoding of boolean cardinality constraints",
      "author" : [ "Carsten Sinz" ],
      "venue" : "In Principles and Practice of Constraint Programming – CP 2005,",
      "citeRegEx" : "74",
      "shortCiteRegEx" : "74",
      "year" : 2005
    }, {
      "title" : "On k-term DNF with the largest number of prime implicants",
      "author" : [ "Robert H. Sloan", "Balázs Sörényi", "György Turán" ],
      "venue" : "SIAM Journal on Discrete Mathematics,",
      "citeRegEx" : "75",
      "shortCiteRegEx" : "75",
      "year" : 2007
    }, {
      "title" : "Cryptominisat 2.5.0",
      "author" : [ "Mate Soos" ],
      "venue" : "http://baldur.iti.uka.de/ sat-race-2010/descriptions/solver_13.pdf,",
      "citeRegEx" : "76",
      "shortCiteRegEx" : "76",
      "year" : 2010
    }, {
      "title" : "Enhanced Gaussian elimination in DPLL-based SAT solvers",
      "author" : [ "Mate Soos" ],
      "venue" : "Pragmatics of SAT,",
      "citeRegEx" : "77",
      "shortCiteRegEx" : "77",
      "year" : 2010
    }, {
      "title" : "Ein Satz über Untermengen einer endlichen Menge",
      "author" : [ "Emanuel Sperner" ],
      "venue" : "Mathematische Zeitschrift,",
      "citeRegEx" : "80",
      "shortCiteRegEx" : "80",
      "year" : 1928
    }, {
      "title" : "Modeling and verifying systems and software in propositional logic",
      "author" : [ "Gunnar St̊almarck", "M. Säflund" ],
      "venue" : "Safety of Computer Control Systems",
      "citeRegEx" : "81",
      "shortCiteRegEx" : "81",
      "year" : 1990
    }, {
      "title" : "Compiling finite linear CSP into SAT",
      "author" : [ "Naoyuki Tamura", "Akiko Taga", "Satoshi Kitagawa", "Mutsunori Banbara" ],
      "venue" : null,
      "citeRegEx" : "82",
      "shortCiteRegEx" : "82",
      "year" : 2009
    }, {
      "title" : "A compact and efficient SAT-encoding of finite domain CSP",
      "author" : [ "Tomoya Tanjo", "Naoyuki Tamura", "Mutsunori Banbara" ],
      "venue" : "Theory and Applications of Satisfiability Testing - SAT 2011, volume LNCS 6695 of Lecture Notes in Computer Science,",
      "citeRegEx" : "83",
      "shortCiteRegEx" : "83",
      "year" : 2011
    }, {
      "title" : "The complexity of propositional proofs",
      "author" : [ "Alasdair Urquhart" ],
      "venue" : "The Bulletin of Symbolic Logic,",
      "citeRegEx" : "84",
      "shortCiteRegEx" : "84",
      "year" : 1995
    }, {
      "title" : "A short note on some tractable cases of the satisfiability problem",
      "author" : [ "Hans van Maaren" ],
      "venue" : "Information and Computation,",
      "citeRegEx" : "85",
      "shortCiteRegEx" : "85",
      "year" : 2000
    }, {
      "title" : "Classes of boolean formulae with effectively solvable SAT",
      "author" : [ "V. Vlček" ],
      "venue" : "In Jana Safrankova and Jiri Pavlu, editors, Proceedings of the 19th Annual Conference of Doctoral Students - WDS 2010,",
      "citeRegEx" : "86",
      "shortCiteRegEx" : "86",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 30,
      "context" : "The hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F ∈ UCk is to be achieved for k as small as feasible.",
      "startOffset" : 84,
      "endOffset" : 96
    }, {
      "referenceID" : 31,
      "context" : "The hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F ∈ UCk is to be achieved for k as small as feasible.",
      "startOffset" : 84,
      "endOffset" : 96
    }, {
      "referenceID" : 32,
      "context" : "The hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F ∈ UCk is to be achieved for k as small as feasible.",
      "startOffset" : 84,
      "endOffset" : 96
    }, {
      "referenceID" : 20,
      "context" : "Here UC1 = UC has been introduced in [26] for the purpose of knowledge compilation.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 11,
      "context" : "We also touch upon the hierarchy PCk of propagation complete clause-sets of level k, where PC1 = PC has been introduced in [15].",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 2,
      "context" : "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.",
      "startOffset" : 16,
      "endOffset" : 27
    }, {
      "referenceID" : 61,
      "context" : "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.",
      "startOffset" : 16,
      "endOffset" : 27
    }, {
      "referenceID" : 22,
      "context" : "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.",
      "startOffset" : 16,
      "endOffset" : 27
    }, {
      "referenceID" : 67,
      "context" : "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.",
      "startOffset" : 65,
      "endOffset" : 73
    }, {
      "referenceID" : 68,
      "context" : "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.",
      "startOffset" : 65,
      "endOffset" : 73
    }, {
      "referenceID" : 39,
      "context" : "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.",
      "startOffset" : 123,
      "endOffset" : 131
    }, {
      "referenceID" : 29,
      "context" : "See for example [4, 74, 28] for work on cardinality constraints, [82, 83] for work on general constraint translations, and [48, 35] for investigations into different translations in cryptography.",
      "startOffset" : 123,
      "endOffset" : 131
    }, {
      "referenceID" : 26,
      "context" : "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].",
      "startOffset" : 53,
      "endOffset" : 75
    }, {
      "referenceID" : 2,
      "context" : "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].",
      "startOffset" : 53,
      "endOffset" : 75
    }, {
      "referenceID" : 61,
      "context" : "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].",
      "startOffset" : 53,
      "endOffset" : 75
    }, {
      "referenceID" : 22,
      "context" : "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].",
      "startOffset" : 53,
      "endOffset" : 75
    }, {
      "referenceID" : 40,
      "context" : "7 in [72], while various casestudies can be found in [32, 4, 74, 28, 49, 5].",
      "startOffset" : 53,
      "endOffset" : 75
    }, {
      "referenceID" : 11,
      "context" : "In a similar vein, there is the class PC of propagation-complete clause-sets (see [15]), containing all clause-sets for which unit-clause propagation is sufficient to detect all forced assignments.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 36,
      "context" : "In [45] it is shown that conflict-driven solvers with branching restricted to input variables have only superpolynomial run-time on EPHPn, an Extended Resolution",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 38,
      "context" : "Also experimentally it is demonstrated in [47] that input-restricted branching can have a detrimental effect on solver times and proof sizes for modern CDCL solvers.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 30,
      "context" : "Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties.",
      "startOffset" : 40,
      "endOffset" : 52
    }, {
      "referenceID" : 31,
      "context" : "Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties.",
      "startOffset" : 40,
      "endOffset" : 52
    }, {
      "referenceID" : 32,
      "context" : "Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties.",
      "startOffset" : 40,
      "endOffset" : 52
    }, {
      "referenceID" : 20,
      "context" : "Motivated by the absolute condition, in [36, 37, 38] we considered the somewhat more fundamental class UC of refutation complete clause-sets, introduced in [26] as a method for propositional knowledge compilation, and studied its properties.",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 30,
      "context" : "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of “hardness” at most k, that is, refutation is (always) possible via rk.",
      "startOffset" : 3,
      "endOffset" : 15
    }, {
      "referenceID" : 31,
      "context" : "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of “hardness” at most k, that is, refutation is (always) possible via rk.",
      "startOffset" : 3,
      "endOffset" : 15
    }, {
      "referenceID" : 32,
      "context" : "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of “hardness” at most k, that is, refutation is (always) possible via rk.",
      "startOffset" : 3,
      "endOffset" : 15
    }, {
      "referenceID" : 43,
      "context" : "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of “hardness” at most k, that is, refutation is (always) possible via rk.",
      "startOffset" : 96,
      "endOffset" : 104
    }, {
      "referenceID" : 49,
      "context" : "In [36, 37, 38], using generalised unit-clause propagation rk (with r1 being UCP) introduced in [53, 59], we developed a hierarchy UCk (with UC1 = UC) of clause-sets of “hardness” at most k, that is, refutation is (always) possible via rk.",
      "startOffset" : 96,
      "endOffset" : 104
    }, {
      "referenceID" : 31,
      "context" : "5 of [37, 38] that various poly-time solvable SAT classes are contained within levels of the UCk hierarchy.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "5 of [37, 38] that various poly-time solvable SAT classes are contained within levels of the UCk hierarchy.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 17,
      "context" : "2 in [22] and [85]) and HOk ⊂ UCk (generalised Horn clause-sets, see [51]).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 70,
      "context" : "2 in [22] and [85]) and HOk ⊂ UCk (generalised Horn clause-sets, see [51]).",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 42,
      "context" : "2 in [22] and [85]) and HOk ⊂ UCk (generalised Horn clause-sets, see [51]).",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 37,
      "context" : "In [46] the argument is made that tree-resolution complexity can not provide a good measure of hardness of instances for SAT solving, citing the ability of CDCL solvers to simulate exponentially more powerful full resolution (see [2] for evidence that CDCL solvers can simulate full resolution).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 31,
      "context" : "On the other hand, for tighter target classes in the case of full resolution, we also consider the notion of width-hardness as introduced in [37, 38], based on the",
      "startOffset" : 141,
      "endOffset" : 149
    }, {
      "referenceID" : 32,
      "context" : "On the other hand, for tighter target classes in the case of full resolution, we also consider the notion of width-hardness as introduced in [37, 38], based on the",
      "startOffset" : 141,
      "endOffset" : 149
    }, {
      "referenceID" : 43,
      "context" : "width-based hierarchies of unsatisfiable clause-sets in [53, 59].",
      "startOffset" : 56,
      "endOffset" : 64
    }, {
      "referenceID" : 49,
      "context" : "width-based hierarchies of unsatisfiable clause-sets in [53, 59].",
      "startOffset" : 56,
      "endOffset" : 64
    }, {
      "referenceID" : 42,
      "context" : "That is, a clause-set is in WCk, the hierarchy of clause-sets of width-hardness k, iff under any partial assignment resulting in an unsatisfiable clause-set there is a “k-resolution” refutation as introduced in [51].",
      "startOffset" : 211,
      "endOffset" : 215
    }, {
      "referenceID" : 21,
      "context" : "A precursor A generalisation of UC was already discussed in [27].",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 21,
      "context" : "[27] continues by considering the (generic) hierarchy (Πk)k∈N0 from [71], a precursor of [53].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 59,
      "context" : "[27] continues by considering the (generic) hierarchy (Πk)k∈N0 from [71], a precursor of [53].",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 43,
      "context" : "[27] continues by considering the (generic) hierarchy (Πk)k∈N0 from [71], a precursor of [53].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 59,
      "context" : "However this choice for Π0 was never considered for that hierarchy from [71], which might have two reasons: Implicit preference is given to classes Π0 closed under sub-clause-set formation (see Section 6.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 32,
      "context" : "3 in [38] for more discussions on this issue).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 59,
      "context" : "And furthermore SAT and UNSAT is not distinguished in [71] and in subsequent work directly relying on it; see Subsection 1.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 43,
      "context" : "2 in [53] for a discussion of this.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 21,
      "context" : "So the four choices for Π0 considered in [27] are HO, 2–CLS, RHO and QHO.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 21,
      "context" : "Due to these weaknesses, [27] does not consider a hierarchy generalising UC.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 32,
      "context" : "3 in [38] for results in this direction.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 21,
      "context" : "1)[27] actually favours adding unit-clauses to F , but we consider applying partial assignments as more fundamental.",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 14,
      "context" : "[18] gives an overview of the CNF-based target languages (prime implicates, UC, 2–CLS, Horn clause-sets).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[29] consider disjunctions of simple CNF classes.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[25] provides an overview of target compilation languages based on “nested” (graph-based) classes, namely variants of NNF, DNNF and BDDs.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "All of the CNF classes studied in [18, 25, 29] are included at the first three levels of the hierarchy UCk, namely, sets of prime implicates in UC0, (renamable) Horn clausesets in UC1 = UC, and 2–CLS in UC2.",
      "startOffset" : 34,
      "endOffset" : 46
    }, {
      "referenceID" : 19,
      "context" : "All of the CNF classes studied in [18, 25, 29] are included at the first three levels of the hierarchy UCk, namely, sets of prime implicates in UC0, (renamable) Horn clausesets in UC1 = UC, and 2–CLS in UC2.",
      "startOffset" : 34,
      "endOffset" : 46
    }, {
      "referenceID" : 23,
      "context" : "All of the CNF classes studied in [18, 25, 29] are included at the first three levels of the hierarchy UCk, namely, sets of prime implicates in UC0, (renamable) Horn clausesets in UC1 = UC, and 2–CLS in UC2.",
      "startOffset" : 34,
      "endOffset" : 46
    }, {
      "referenceID" : 40,
      "context" : "And see [49] for a basic negative result, characterising what can be represented under the relative condition (i.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 55,
      "context" : "The notion of minimal unsatisfiability (MU) and minimally unsatisfiable subsets (MUS) is important in understanding the combinatorics of unsatisfiable clause-sets (see [52, 66]).",
      "startOffset" : 168,
      "endOffset" : 176
    }, {
      "referenceID" : 51,
      "context" : "To understand the structure of satisfiable clause-sets and their associated boolean functions, we now consider the concept of “minimal premise sets” (MPS) introduced in [62].",
      "startOffset" : 169,
      "endOffset" : 173
    }, {
      "referenceID" : 62,
      "context" : "[75] introduced a special type of boolean functions, called Non-repeating Unate Decision trees (NUD) there, by adding new variables to each clause of clause-sets in SMUδ=1, which is the class of unsatisfiable hitting clause-sets of deficiency δ = 1.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "In [26] (Example 2) a separation was already shown between UC0 (clause-sets containing all of their prime implicates) and UC1 = UC, and the question was raised of the worst-case growth when compiling from an arbitrary CNF clause-set F to some equivalent F ′ ∈ UC.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 5,
      "context" : "This question was partly answered in [8] (although the connection was not made), where the authors provide examples of poly-size clausesets with only super-polynomial size representations in UC, even when allowing new variables (see Subsections 7.",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 6,
      "context" : "5, and [9] for more on the connection between [8] and UCk).",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 5,
      "context" : "5, and [9] for more on the connection between [8] and UCk).",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 20,
      "context" : "Our separation result now answers the question of worst-case growth from [26] in full generality with the hierarchy UCk.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 20,
      "context" : "This separation, between UCk+1 and UCk for arbitrary k, is more involved than the simple separation in [26], due to the parameterised use of more advanced polynomial-time methods than r1 (UCP).",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 47,
      "context" : "Especially r2, which is (complete) failed-literal elimination, is used in look-ahead SAT solvers (see [42] for an overview) such as OKsolver ([57]), march ([41]) and Satz ([65]).",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 35,
      "context" : "Especially r2, which is (complete) failed-literal elimination, is used in look-ahead SAT solvers (see [42] for an overview) such as OKsolver ([57]), march ([41]) and Satz ([65]).",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 54,
      "context" : "Especially r2, which is (complete) failed-literal elimination, is used in look-ahead SAT solvers (see [42] for an overview) such as OKsolver ([57]), march ([41]) and Satz ([65]).",
      "startOffset" : 172,
      "endOffset" : 176
    }, {
      "referenceID" : 63,
      "context" : "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 7,
      "context" : "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.",
      "startOffset" : 71,
      "endOffset" : 79
    }, {
      "referenceID" : 8,
      "context" : "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.",
      "startOffset" : 71,
      "endOffset" : 79
    }, {
      "referenceID" : 8,
      "context" : "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 9,
      "context" : "Also conflict-driven solvers such as CryptoMiniSat ([76]) and PicoSAT ([10, 12]) integrate r2 during search, and solvers such as Lingeling ([12, 13]) use r2 as a preprocessing technique.",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 66,
      "context" : "Furthermore, in general rk is used, in even stronger versions, in the St̊almarck-solver (see [81, 40, 73], and see Section 3.",
      "startOffset" : 93,
      "endOffset" : 105
    }, {
      "referenceID" : 34,
      "context" : "Furthermore, in general rk is used, in even stronger versions, in the St̊almarck-solver (see [81, 40, 73], and see Section 3.",
      "startOffset" : 93,
      "endOffset" : 105
    }, {
      "referenceID" : 60,
      "context" : "Furthermore, in general rk is used, in even stronger versions, in the St̊almarck-solver (see [81, 40, 73], and see Section 3.",
      "startOffset" : 93,
      "endOffset" : 105
    }, {
      "referenceID" : 43,
      "context" : "5 of [53] for a discussion of the connections to rk), and via breadth-first “branch/merge” rules in HeerHugo (see [33]).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 27,
      "context" : "5 of [53] for a discussion of the connections to rk), and via breadth-first “branch/merge” rules in HeerHugo (see [33]).",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 56,
      "context" : "In [68, 69] it is argued that modern SAT solvers can simulate full resolution — and this is considered to be a good property of SAT solvers.",
      "startOffset" : 3,
      "endOffset" : 11
    }, {
      "referenceID" : 57,
      "context" : "In [68, 69] it is argued that modern SAT solvers can simulate full resolution — and this is considered to be a good property of SAT solvers.",
      "startOffset" : 3,
      "endOffset" : 11
    }, {
      "referenceID" : 58,
      "context" : "It has been noted in the literature at several places (see [70, 44, 28]), that one might use only one of the two directions of the equivalences in the Tseitintranslation.",
      "startOffset" : 59,
      "endOffset" : 71
    }, {
      "referenceID" : 22,
      "context" : "It has been noted in the literature at several places (see [70, 44, 28]), that one might use only one of the two directions of the equivalences in the Tseitintranslation.",
      "startOffset" : 59,
      "endOffset" : 71
    }, {
      "referenceID" : 31,
      "context" : "5 of [37, 38] discusses the translation of the so-called “Schaefer classes” into the UCk hierarchy; see Section 12.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "5 of [37, 38] discusses the translation of the so-called “Schaefer classes” into the UCk hierarchy; see Section 12.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 18,
      "context" : "2 in [24] for an introduction, and see [23] for an in-depth overview on recent developments.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 43,
      "context" : "In what respect is the terminology “hardness” appropriate? The hardness measure hd(F ) has been introduced in [53, 59], based on quasi-automatisation of tree-resolution, that is, on a specific algorithmic approach (close to St̊almarcks approach).",
      "startOffset" : 110,
      "endOffset" : 118
    }, {
      "referenceID" : 49,
      "context" : "In what respect is the terminology “hardness” appropriate? The hardness measure hd(F ) has been introduced in [53, 59], based on quasi-automatisation of tree-resolution, that is, on a specific algorithmic approach (close to St̊almarcks approach).",
      "startOffset" : 110,
      "endOffset" : 118
    }, {
      "referenceID" : 0,
      "context" : "In [1], hd(F ) for unsatisfiable F was proposed as measure of SAT-solverhardness in general.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 37,
      "context" : "This was criticised in [46] by the argument, that conflict-driven SAT solvers would be closer to dag-resolution (full resolution) than tree-resolution.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 43,
      "context" : "The main results on size lower bounds for the hardness are: 4)Using the simplest oracle, on unsatisfiable instances the measure from [53, 59] yields hd(F ).",
      "startOffset" : 133,
      "endOffset" : 141
    }, {
      "referenceID" : 49,
      "context" : "The main results on size lower bounds for the hardness are: 4)Using the simplest oracle, on unsatisfiable instances the measure from [53, 59] yields hd(F ).",
      "startOffset" : 133,
      "endOffset" : 141
    }, {
      "referenceID" : 43,
      "context" : "But on satisfiable instances the approach of [53, 59] is very different, namely an algorithmic polynomial-time approach is taken, extending the breadth-first search for tree-resolution refutations in a natural way.",
      "startOffset" : 45,
      "endOffset" : 53
    }, {
      "referenceID" : 49,
      "context" : "But on satisfiable instances the approach of [53, 59] is very different, namely an algorithmic polynomial-time approach is taken, extending the breadth-first search for tree-resolution refutations in a natural way.",
      "startOffset" : 45,
      "endOffset" : 53
    }, {
      "referenceID" : 17,
      "context" : "Note that by the de Morgan rules from the CNF-formula we obtain the DNFformula via negating the whole formula together with negating the literals (in other words, the underlying boolean function of a CNF-clause-set F is the “dual” of the underlying boolean function of the DNF-clause-set F ; see [22]).",
      "startOffset" : 296,
      "endOffset" : 300
    }, {
      "referenceID" : 17,
      "context" : "1 The clause-set F = {{v}} has the equivalent DNF-clause-set F = {{v}} (the underlying boolean function is “self-dual”; see [22]), while the negation is {{v}}.",
      "startOffset" : 124,
      "endOffset" : 128
    }, {
      "referenceID" : 43,
      "context" : "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.",
      "startOffset" : 67,
      "endOffset" : 87
    }, {
      "referenceID" : 49,
      "context" : "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.",
      "startOffset" : 67,
      "endOffset" : 87
    }, {
      "referenceID" : 30,
      "context" : "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.",
      "startOffset" : 67,
      "endOffset" : 87
    }, {
      "referenceID" : 31,
      "context" : "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.",
      "startOffset" : 67,
      "endOffset" : 87
    }, {
      "referenceID" : 32,
      "context" : "It is mostly of an expository nature, explaining what we need from [53, 59, 36, 37, 38], with some additional remarks.",
      "startOffset" : 67,
      "endOffset" : 87
    }, {
      "referenceID" : 43,
      "context" : "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 49,
      "context" : "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 0,
      "context" : "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].",
      "startOffset" : 141,
      "endOffset" : 144
    }, {
      "referenceID" : 30,
      "context" : "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].",
      "startOffset" : 176,
      "endOffset" : 188
    }, {
      "referenceID" : 31,
      "context" : "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].",
      "startOffset" : 176,
      "endOffset" : 188
    }, {
      "referenceID" : 32,
      "context" : "Hardness for unsatisfiable clause-sets was introduced in [53, 59], while this generalisation to arbitrary clause-sets was first mentioned in [1], and systematically studied in [36, 37, 38].",
      "startOffset" : 176,
      "endOffset" : 188
    }, {
      "referenceID" : 30,
      "context" : "3 defines hardness proof-theoretically; importantly, it can also be characterised algorithmically via necessary levels of generalised unit-clause propagation (see [36, 37, 38] for the details):",
      "startOffset" : 163,
      "endOffset" : 175
    }, {
      "referenceID" : 31,
      "context" : "3 defines hardness proof-theoretically; importantly, it can also be characterised algorithmically via necessary levels of generalised unit-clause propagation (see [36, 37, 38] for the details):",
      "startOffset" : 163,
      "endOffset" : 175
    }, {
      "referenceID" : 32,
      "context" : "3 defines hardness proof-theoretically; importantly, it can also be characterised algorithmically via necessary levels of generalised unit-clause propagation (see [36, 37, 38] for the details):",
      "startOffset" : 163,
      "endOffset" : 175
    }, {
      "referenceID" : 43,
      "context" : "4 Consider the reductions rk : CLS → CLS for k ∈ N0 as introduced in [53]; it is r1 unit-clause propagation, while r2 is (full, iterated) failed-literal elimination.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 20,
      "context" : "UC1 = UC is the class of unit-refutation complete clause-sets, as introduced in [26].",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 30,
      "context" : "In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]).",
      "startOffset" : 3,
      "endOffset" : 15
    }, {
      "referenceID" : 31,
      "context" : "In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]).",
      "startOffset" : 3,
      "endOffset" : 15
    }, {
      "referenceID" : 32,
      "context" : "In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]).",
      "startOffset" : 3,
      "endOffset" : 15
    }, {
      "referenceID" : 25,
      "context" : "In [36, 37, 38] we show that UC = SLUR, where SLUR is the class of clause-sets solvable via Single Lookahead Unit Resolution (see [31]).",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 15,
      "context" : "Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k ≥ 1.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 30,
      "context" : "Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k ≥ 1.",
      "startOffset" : 27,
      "endOffset" : 39
    }, {
      "referenceID" : 31,
      "context" : "Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k ≥ 1.",
      "startOffset" : 27,
      "endOffset" : 39
    }, {
      "referenceID" : 32,
      "context" : "Using [19] we then obtain ([36, 37, 38]) that membership decision for UCk (= SLURk) is coNP-complete for k ≥ 1.",
      "startOffset" : 27,
      "endOffset" : 39
    }, {
      "referenceID" : 43,
      "context" : "2 of [53].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 43,
      "context" : "17 from [53], sufficient for our purposes, is as follows (with a technical correction, as explained in Example 3.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 43,
      "context" : "17 in [53] doesn’t state the condition (i) from Lemma 3.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 43,
      "context" : "The following example shows that this condition actually needs to be stated (that is, if we just have (ii) and (iii), then h doesn’t need to be a lower bound for hd); fortunately in all applications in [53] this (natural) condition is fulfilled.",
      "startOffset" : 202,
      "endOffset" : 206
    }, {
      "referenceID" : 57,
      "context" : "Complementary to “unit-refutation completeness”, there is the notion of “propagation-completeness” as investigated in [69, 15], yielding the class PC ⊂ UC.",
      "startOffset" : 118,
      "endOffset" : 126
    }, {
      "referenceID" : 11,
      "context" : "Complementary to “unit-refutation completeness”, there is the notion of “propagation-completeness” as investigated in [69, 15], yielding the class PC ⊂ UC.",
      "startOffset" : 118,
      "endOffset" : 126
    }, {
      "referenceID" : 31,
      "context" : "This was captured and generalised by a measure phd : CLS → N0 of “propagationhardness” along with the associated hierarchy, defined in [37, 38] as follows:",
      "startOffset" : 135,
      "endOffset" : 143
    }, {
      "referenceID" : 32,
      "context" : "This was captured and generalised by a measure phd : CLS → N0 of “propagationhardness” along with the associated hierarchy, defined in [37, 38] as follows:",
      "startOffset" : 135,
      "endOffset" : 143
    }, {
      "referenceID" : 43,
      "context" : "8 For F ∈ CLS we define the propagation-hardness (for short “p-hardness”) phd(F ) ∈ N0 as the minimal k ∈ N0 such that for all partial assignments φ ∈ PASS we have rk(φ ∗ F ) = r∞(φ ∗ F ), where rk : CLS → CLS is generalised UCP ([53, 59]), and r∞ : CLS → CLS applies all forced assignments, and can be defined by r∞(F ) := rn(F )(F ).",
      "startOffset" : 230,
      "endOffset" : 238
    }, {
      "referenceID" : 49,
      "context" : "8 For F ∈ CLS we define the propagation-hardness (for short “p-hardness”) phd(F ) ∈ N0 as the minimal k ∈ N0 such that for all partial assignments φ ∈ PASS we have rk(φ ∗ F ) = r∞(φ ∗ F ), where rk : CLS → CLS is generalised UCP ([53, 59]), and r∞ : CLS → CLS applies all forced assignments, and can be defined by r∞(F ) := rn(F )(F ).",
      "startOffset" : 230,
      "endOffset" : 238
    }, {
      "referenceID" : 4,
      "context" : "A basic weakness of the standard notion of width-restricted resolution, which demands that both parent clauses must have length at most k for some fixed k ∈ N0 (the “width”; see [7]), is that even Horn clause-sets require unbounded width in this sense.",
      "startOffset" : 178,
      "endOffset" : 181
    }, {
      "referenceID" : 43,
      "context" : "The correct solution, as investigated and discussed in [53, 59], is to use the notion of “k-resolution” as introduced in [51], where only one parent clause needs to have length at most k (thus properly generalising unit-resolution).",
      "startOffset" : 55,
      "endOffset" : 63
    }, {
      "referenceID" : 49,
      "context" : "The correct solution, as investigated and discussed in [53, 59], is to use the notion of “k-resolution” as introduced in [51], where only one parent clause needs to have length at most k (thus properly generalising unit-resolution).",
      "startOffset" : 55,
      "endOffset" : 63
    }, {
      "referenceID" : 42,
      "context" : "The correct solution, as investigated and discussed in [53, 59], is to use the notion of “k-resolution” as introduced in [51], where only one parent clause needs to have length at most k (thus properly generalising unit-resolution).",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 43,
      "context" : "Nested input-resolution ([53, 59]) is the proof-theoretic basis of hardness, and approximates tree-resolution.",
      "startOffset" : 25,
      "endOffset" : 33
    }, {
      "referenceID" : 49,
      "context" : "Nested input-resolution ([53, 59]) is the proof-theoretic basis of hardness, and approximates tree-resolution.",
      "startOffset" : 25,
      "endOffset" : 33
    }, {
      "referenceID" : 49,
      "context" : "12 in [59]):",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 43,
      "context" : "2 in [53], and is a special case of widU introduced in Subsection 6.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 49,
      "context" : "1 of [59]).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 49,
      "context" : "8 in [59] for unsatisfiable clause-sets, which extends to satisfiable clausesets by definition).",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 13,
      "context" : "For unsatisfiable F , whether whd(F ) = k holds for k ∈ {0, 1, 2} can be decided in polynomial time; this is non-trivial for k = 2 ([17]) and unknown for k > 2.",
      "startOffset" : 132,
      "endOffset" : 136
    }, {
      "referenceID" : 49,
      "context" : "5 of [59], by actually using a slight strengthening of k-resolution, which combines width-bounded resolution and input resolution.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 49,
      "context" : "12 in [59] we obtain for F ∈ USAT , n(F ) 6= 0, the following general lower bound on resolution complexity:",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 30,
      "context" : "Similar to Theorem 14 in [36] resp.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 31,
      "context" : "7 in [37, 38] we thus obtain:",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "7 in [37, 38] we thus obtain:",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 51,
      "context" : "In this section we study “minimal premise sets”, “mps’s” for short, introduced in [62], together with the properties of “doped” clause-sets, generalising a construction used in [75].",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 62,
      "context" : "In this section we study “minimal premise sets”, “mps’s” for short, introduced in [62], together with the properties of “doped” clause-sets, generalising a construction used in [75].",
      "startOffset" : 177,
      "endOffset" : 181
    }, {
      "referenceID" : 51,
      "context" : "1 in [62] basic properties of minimal premise sets are considered:",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 51,
      "context" : "5 in [62] we see that no clause-set can minimally entail more than one clause:",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 51,
      "context" : "4 in [62] we get the main characterisation of mps’s, namely that after elimination of pure literals they must be minimally unsatisfiable:",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 55,
      "context" : "For unsatisfiable clause-sets the set of minimally unsatisfiable sub-clause-sets has been studied extensively in the literature; see [66] for a recent overview.",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 51,
      "context" : "6 of [62], misplacing the “−1” into the exponent.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 31,
      "context" : "5 in [37, 38], all UCk are closed under partial assignments, so for φ := 〈u⊥ → 1〉∪〈uC → 0 | C ∈ F ′〉 we have hd(D(F )) ≥ hd(φ ∗D(F )) = hd(F ′) > hd(F ) = 0.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "5 in [37, 38], all UCk are closed under partial assignments, so for φ := 〈u⊥ → 1〉∪〈uC → 0 | C ∈ F ′〉 we have hd(D(F )) ≥ hd(φ ∗D(F )) = hd(F ′) > hd(F ) = 0.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 46,
      "context" : "In [56] (generalised in [62]) it is shown that the elements of SMUδ=1 are exactly the clause-sets introduced in [21].",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 51,
      "context" : "In [56] (generalised in [62]) it is shown that the elements of SMUδ=1 are exactly the clause-sets introduced in [21].",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 16,
      "context" : "In [56] (generalised in [62]) it is shown that the elements of SMUδ=1 are exactly the clause-sets introduced in [21].",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 46,
      "context" : "5 in [56]:",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 52,
      "context" : "It is well-known that UHIT ⊂ SMU holds (for a proof see Lemma 2 in [63]).",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 48,
      "context" : "In [58], Corollary 34, it was shown that that an unsatisfiable clause-sets F has precisely one clash between any pair of different clause-sets iff F ∈ SMUδ=1 holds (an alternative proof was found in [75]).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 62,
      "context" : "In [58], Corollary 34, it was shown that that an unsatisfiable clause-sets F has precisely one clash between any pair of different clause-sets iff F ∈ SMUδ=1 holds (an alternative proof was found in [75]).",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 48,
      "context" : "Now assume F ∈ SMUδ=1, and we have to show that F 6)In [58] the notation “UHIT ” was used to denote “uniform hitting clause-sets”, which is now more appropriately called “(conflict-)regular hitting clause-sets”, while “U” now stands for “unsatisfiable”.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 51,
      "context" : "14 That every 2-element sub-clause-set of F ∈ CLS is an mps, that is, every two (different) clauses of F clash in precisely one literal, says that F is 1-regular hitting in the terminology of [62], Section 6.",
      "startOffset" : 192,
      "endOffset" : 196
    }, {
      "referenceID" : 48,
      "context" : "For an interesting example with deficiency 1 see Section 5 in [58].",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 62,
      "context" : "We arrive at a simple and perspicuous proof of the main result of [75], that the clause-sets F with |prc0(F )| = 2 ) − 1 are precisely the clause-sets D(F ) for F ∈ SMUδ=1 when allowing to replace the single doping variable of a clause by any non-empty set of new (pure) literals:",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 31,
      "context" : "2 of [37, 38] we have prc0(F ) = F .",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "2 of [37, 38] we have prc0(F ) = F .",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 31,
      "context" : "2 of [37, 38].",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "2 of [37, 38].",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 49,
      "context" : "1 in [59].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 20,
      "context" : "A simple example demonstrates the separation between UC0 and UC1 (similar to [26], Example 2, which uses Example 6.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 41,
      "context" : "1 from [50]):",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 41,
      "context" : "1 from [50]:",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 65,
      "context" : "By Sperner’s Theorem ([80]) holds |S0| ≤ M , and this upper bound M is realised, just observing the antichain-condition, by choosing for S0 the set ( lvs(T0) m′ ) of subsets of lvs(T0) of size m ′.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 31,
      "context" : "1 from [37, 38] that UCk, and indeed also WCk, is a proper hierarchy of boolean functions regarding polysize representations without new variables (see Subsection 7.",
      "startOffset" : 7,
      "endOffset" : 15
    }, {
      "referenceID" : 32,
      "context" : "1 from [37, 38] that UCk, and indeed also WCk, is a proper hierarchy of boolean functions regarding polysize representations without new variables (see Subsection 7.",
      "startOffset" : 7,
      "endOffset" : 15
    }, {
      "referenceID" : 31,
      "context" : "2 of [37, 38] we discussed representations of boolean functions in general.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "2 of [37, 38] we discussed representations of boolean functions in general.",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 31,
      "context" : "We have conjectured in [37, 38] (Conjecture 9.",
      "startOffset" : 23,
      "endOffset" : 31
    }, {
      "referenceID" : 32,
      "context" : "We have conjectured in [37, 38] (Conjecture 9.",
      "startOffset" : 23,
      "endOffset" : 31
    }, {
      "referenceID" : 5,
      "context" : "Such an encoding is an extension of Theorem 1 in [8], using similar techniques.",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 40,
      "context" : "In [49] a more general version of Lemma 7.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 40,
      "context" : "9 only establishes the 7)There is a mistake in [49] in that it claims that the Tseitin translation of all DNNFs maintain arc-consistency via UCP, however this is shown only for smooth DNNFs as confirmed by George Katirelos via e-mail in January 2012.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 17,
      "context" : "6 and Chapter 7 in [22]), which are as clause-sets precisely the hitting clause-sets, then we obtain absolute hardness 1:",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 44,
      "context" : "And also note that in case of ⊥ / ∈ F the additional clauses of ct(F ), that is, the C ∈ ct(F ) \\ ct(F ), are all blocked for ct(F ) (see [54, 55]), since C can not be resolved on the vct-variable in it.",
      "startOffset" : 138,
      "endOffset" : 146
    }, {
      "referenceID" : 45,
      "context" : "And also note that in case of ⊥ / ∈ F the additional clauses of ct(F ), that is, the C ∈ ct(F ) \\ ct(F ), are all blocked for ct(F ) (see [54, 55]), since C can not be resolved on the vct-variable in it.",
      "startOffset" : 138,
      "endOffset" : 146
    }, {
      "referenceID" : 5,
      "context" : "Basic results for showing such a lower bound are obtained in [8].",
      "startOffset" : 61,
      "endOffset" : 64
    }, {
      "referenceID" : 43,
      "context" : "Thus at each leaf we can attach a splitting tree of Horton-Strahler number of hardness at most maxψ∈P hd(ψ∗F ), and from that (via the well-known correspondence of splitting trees and resolution trees; see [53, 59] for details) we obtain a resolution tree fulfilling the desired hardness bound.",
      "startOffset" : 206,
      "endOffset" : 214
    }, {
      "referenceID" : 49,
      "context" : "Thus at each leaf we can attach a splitting tree of Horton-Strahler number of hardness at most maxψ∈P hd(ψ∗F ), and from that (via the well-known correspondence of splitting trees and resolution trees; see [53, 59] for details) we obtain a resolution tree fulfilling the desired hardness bound.",
      "startOffset" : 206,
      "endOffset" : 214
    }, {
      "referenceID" : 30,
      "context" : "1 with F := F1∪F2 and V := var(F1)∩var(F2), and apply the general upper bound hd(F1 ∪ F2) ≤ max(hd(F1), hd(F2)) for variable-disjoint F1, F2 (Lemma 15 in [36]).",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 49,
      "context" : "1, part 1, in [59]).",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 30,
      "context" : "By Lemma 19 in [36] we have hd(ψ ∗ F ) ≤ 2, and thus hd(F ) ≤ (n − 2) + 2 = n.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 43,
      "context" : "18 in [53], since then F would be simply the clause-set with all 2 clauses of length n.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 32,
      "context" : "7 in [38].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 47,
      "context" : "OKsolver ([57]): a look-ahead solver, used as a “theoretical” solver.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 63,
      "context" : "6 (see [76]).",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 1,
      "context" : "0 (see [3]).",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 7,
      "context" : "(a) PicoSAT, version 913 (see[10, 12]).",
      "startOffset" : 29,
      "endOffset" : 37
    }, {
      "referenceID" : 8,
      "context" : "(a) PicoSAT, version 913 (see[10, 12]).",
      "startOffset" : 29,
      "endOffset" : 37
    }, {
      "referenceID" : 8,
      "context" : "(c) Lingeling, version ala-b02aa1a-121013 (see [12, 13]).",
      "startOffset" : 47,
      "endOffset" : 55
    }, {
      "referenceID" : 9,
      "context" : "(c) Lingeling, version ala-b02aa1a-121013 (see [12, 13]).",
      "startOffset" : 47,
      "endOffset" : 55
    }, {
      "referenceID" : 71,
      "context" : "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR∗(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 15,
      "context" : "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR∗(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 3,
      "context" : "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR∗(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].",
      "startOffset" : 167,
      "endOffset" : 170
    }, {
      "referenceID" : 30,
      "context" : "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR∗(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].",
      "startOffset" : 218,
      "endOffset" : 230
    }, {
      "referenceID" : 31,
      "context" : "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR∗(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].",
      "startOffset" : 218,
      "endOffset" : 230
    }, {
      "referenceID" : 32,
      "context" : "We conclude our considerations on hierarchies by considering the three hierarchies SLUR(k) introduced in [86], SLUR∗(k) introduced in [19], and CANON(k) introduced in [6], which we have compared to the UC-hierarchy in [36, 37, 38].",
      "startOffset" : 218,
      "endOffset" : 230
    }, {
      "referenceID" : 32,
      "context" : "3 Compilation procedures For a given boolean function f and k ∈ N0, how do we find algorithmically a “small” equivalent F ∈ UCk ? In [38], Section 8, the notion of a “k-base for f” is introduced, which is an F ∈ UCk equivalent to f , with F ⊆ prc0(f) and where no clause can be removed without increasing the hardness or destroying equivalence.",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 29,
      "context" : "The most basic approach filters out unneeded prime implicates; see [35, 34] for some initial applications to cryptanalysis.",
      "startOffset" : 67,
      "endOffset" : 75
    }, {
      "referenceID" : 28,
      "context" : "The most basic approach filters out unneeded prime implicates; see [35, 34] for some initial applications to cryptanalysis.",
      "startOffset" : 67,
      "endOffset" : 75
    }, {
      "referenceID" : 29,
      "context" : "A simple filtering heuristic, used in [35, 34], is to favour (keeping) short-clauses.",
      "startOffset" : 38,
      "endOffset" : 46
    }, {
      "referenceID" : 28,
      "context" : "A simple filtering heuristic, used in [35, 34], is to favour (keeping) short-clauses.",
      "startOffset" : 38,
      "endOffset" : 46
    }, {
      "referenceID" : 11,
      "context" : "Essentially the same heuristic is considered in [15] (called “length-increasing iterative empowerment”) when generating representations in PC.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 20,
      "context" : "For the case that f is given by a CNF F0, in [26] one finds refinements of the resolution procedure applied to F0, which would normally compute prc0(f), i.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 32,
      "context" : "A first task is to investigate which of the results on hardness from this article and from [38] can be adapted to w-hardness.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 6,
      "context" : "In [9] we will present some basic methods for w-hardness bounds.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 5,
      "context" : "Can the classes WCk go beyond monotone circuits, which were shown in [8] to be strongly related to the expressive power of arc-consistent CNF representations (see the following subsection for some further remarks)? Conjecture 7.",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 5,
      "context" : "So the conjecture is that here we have another example for the limitations of arc-consistent representations as shown in [8].",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 43,
      "context" : "To overcome these (conjectured) limitations, the theory started here has to be generalised via the use of oracles as developed in [53, 59], and further discussed in Subsection 9.",
      "startOffset" : 130,
      "endOffset" : 138
    }, {
      "referenceID" : 49,
      "context" : "To overcome these (conjectured) limitations, the theory started here has to be generalised via the use of oracles as developed in [53, 59], and further discussed in Subsection 9.",
      "startOffset" : 130,
      "endOffset" : 138
    }, {
      "referenceID" : 31,
      "context" : "4 of [37, 38].",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "4 of [37, 38].",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 64,
      "context" : "Thus they are conceptually simpler than the current integration of SAT solvers and methods from linear algebra (see [78, 20, 77, 39, 64]).",
      "startOffset" : 116,
      "endOffset" : 136
    }, {
      "referenceID" : 33,
      "context" : "Thus they are conceptually simpler than the current integration of SAT solvers and methods from linear algebra (see [78, 20, 77, 39, 64]).",
      "startOffset" : 116,
      "endOffset" : 136
    }, {
      "referenceID" : 53,
      "context" : "Thus they are conceptually simpler than the current integration of SAT solvers and methods from linear algebra (see [78, 20, 77, 39, 64]).",
      "startOffset" : 116,
      "endOffset" : 136
    }, {
      "referenceID" : 24,
      "context" : "And for some oracles, like detection of minimally unsatisfiable clause-sets of a given deficiency, the problems would turn from polytime to NP-hard in this way ([30, 16]).",
      "startOffset" : 161,
      "endOffset" : 169
    }, {
      "referenceID" : 12,
      "context" : "And for some oracles, like detection of minimally unsatisfiable clause-sets of a given deficiency, the problems would turn from polytime to NP-hard in this way ([30, 16]).",
      "startOffset" : 161,
      "endOffset" : 169
    }, {
      "referenceID" : 6,
      "context" : "In [9] we show hd(PHPmm) = whd(PHP m m) = m − 1, and so the (standard representation) PHPmm ∈ CLS itself is not a good representation (it is small, but has high w-hardness).",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 6,
      "context" : "Actually, as explained in [9], from [8] it follows that PHPmm has no polysize arc-consistent representation at all! So again, here oracles are needed; see Subsection 9.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 5,
      "context" : "Actually, as explained in [9], from [8] it follows that PHPmm has no polysize arc-consistent representation at all! So again, here oracles are needed; see Subsection 9.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 31,
      "context" : "4 of [37, 38] for a proposal of an interesting oracle (with potentially good stability properties).",
      "startOffset" : 5,
      "endOffset" : 13
    }, {
      "referenceID" : 32,
      "context" : "4 of [37, 38] for a proposal of an interesting oracle (with potentially good stability properties).",
      "startOffset" : 5,
      "endOffset" : 13
    } ],
    "year" : 2013,
    "abstractText" : "We consider the fundamental task of representing a boolean function f by a conjunctive normal form (clause-set) F for the purpose of SAT solving. The boolean function f here acts as a kind of constraint, like a cardinality constraint or an S-box in a cryptosystem, while F is a subset of the whole SAT problem to be solved. The traditional approach towards “good” properties of F considers “arc consistency”, which demands that for every partial instantiation of f , all forced assignments can be recovered from the corresponding partial assignment to F via unit-clause propagation (UCP). We propose to consider a more refined framework: First, instead of considering the above relative condition, a relation between f and F , we consider an absolute condition, namely that goodness of F is guaranteed by F being element of a suitable target class. And second, instead of just considering UCP, we consider hierarchies of target classes, which allow for different mechanisms than UCP and allow for size/complexity trade-offs. The hierarchy UCk of unit-refutation complete clause-sets of level k, introduced in [36, 37, 38], provides the most basic target classes, that is, F ∈ UCk is to be achieved for k as small as feasible. Here UC1 = UC has been introduced in [26] for the purpose of knowledge compilation. In general, UCk is the set of clause-sets F such that unsatisfiable instantiations (by partial assignments) are recognisable by k-times nested unit-clause propagation. We also touch upon the hierarchy PCk of propagation complete clause-sets of level k, where PC1 = PC has been introduced in [15]. The hierarchy PCk refines the hierarchy UCk by providing intermediate layers. In order to make use of full resolution, we consider the hierarchy WCk of width-refutation complete clauses-sets of level k, employing an improved notion of width (so that we always have UCk ⊆ WCk). Via the absolute condition, the quality of the representation F is fully captured by the target class, and the only relation between f and F is that F must “represent” f . If F does not contain new variables, then this means that F is equivalent to f , while with new variables the satisfying assignments of F projected to the variables of f must be precisely the satisfying assignments of f . Without new variables, the relative and absolute condition coincide, but with new variables, the absolute condition is stronger. As we remark in this article, for the relative condition and new variables at least the hierarchies UCk and PCk collapse, and we also conjecture that the WCk hierarchy collapses. The main result of this article is that without new variables, none of these hierarchies collapses. That means that there are boolean functions with only exponential-size equivalent clause-sets at level k, but with poly-size equivalent clause-sets at level k + 1.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}