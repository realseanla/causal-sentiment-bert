{
  "name" : "1401.3475.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Prime Implicates and Prime Implicants: From Propositional to Modal Logic",
    "authors" : [ "Meghyn Bienvenu" ],
    "emails" : [ "meghyn@informatik.uni-bremen.de" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Prime implicates and prime implicants are important notions in artificial intelligence. They have given rise to a significant body of work in automated reasoning and have been applied to a number of different sub-areas in AI. Traditionally, these concepts have been studied in the context of propositional logic, but they have also been considered for many-valued (Ramesh & Murray, 1994) and first-order logic (Marquis, 1991a, 1991b). Not much is known, however, about prime implicates and prime implicants in other logics. In particular, no definition of prime implicate or prime implicant has ever been proposed for a modal or description logic, nor has it been shown that no reasonable definition can be provided. Given the increasing interest in modal and description logics as knowledge representation languages, one naturally wonders whether these notions can be suitably generalized to these more expressive logics.\nWe recall that in propositional logic the prime implicates of a formula are defined to be its logically strongest clausal consequences. The restriction to clauses is made in order to reduce redundant elements from a formula’s set of consequences: there is no use in keeping around the consequence a∧ b when one already has the consequences a and b. The decision to consider only the logically strongest clausal consequences is motivated by a desire to eliminate irrelevant weaker consequences: if we already have the consequence a, there is\nc©2009 AI Access Foundation. All rights reserved.\nno point in retaining the consequences a ∨ b or a ∨ ¬b. Prime implicates thus provide a complete yet compact representation of the set of logical consequences of a formula. What is particularly nice about this representation is that it makes many computational tasks simpler: satisfiability, tautology, entailment, and equivalence queries and the conditioning and forgetting transformations are all tractable for formulae represented by their prime implicates (Darwiche & Marquis, 2002). This is why prime implicates are considered an interesting target language for knowledge compilation (Cadoli & Donini, 1997; Darwiche & Marquis, 2002). Prime implicates have also proved relevant to other sub-areas of AI, like distributed reasoning (Adjiman, Chatalic, Goasdoué, Rousset, & Simon, 2006), belief revision (Bittencourt, 2007; Pagnucco, 2006), non-monotonic reasoning (cf. Przymusinski, 1989), and characterizations of relevance (Lakemeyer, 1995; Lang, Liberatore, & Marquis, 2003).\nThe dual notion to prime implicates is prime implicants, which are defined to be the logically weakest terms (= conjunctions of literals) which imply a given formula. The main application domain for prime implicants is in abduction and diagnosis. We recall that in abduction, one is given a background theory and an observation, and the objective is to find an explanation for the observation. In logical terms, an explanation is a formula which logically entails the observation when taken together with the background theory. As the set of explanations for an abduction problem can be very large, an important question is how to select a representative subset of explanations. One very common approach is to use prime implicants: the relevant explanations for an observation o with respect to a background theory t are taken to be the prime implicants of t → o (de Kleer, Mackworth, & Reiter, 1992; Eiter & Makino, 2002).\nFor many applications in AI, the expressive power of propositional logic proves insufficient. First-order logic provides a much greater level of expressivity, but at the price of undecidability. Modal and description logics offer an interesting trade-off between expressivity and complexity, as they are generally more expressive than propositional logic yet are better-behaved computationally than first-order logic. This explains the growing trend towards using such languages for knowledge representation.\nA prototypical description logic isALC, which extends propositional logic with restricted forms of universal and existential quantification. An example expression in ALC is\nFemale ⊓ ∃hasChild.Female ⊓ ∀hasChild.(Doctor ⊔ Professor)⊓ ∃hasPet.Dog\nwhich describes the set of individuals who are female, have at least one daughter and one pet dog, and are such that all of their children are either doctors or professors. The above concept expression can be represented equally well in the modal logic K2 by the formula:\nFemale ∧ 31Female ∧ 21(Doctor ∨ Professor)∧ 32Dog\nSchild (1991) proved a general result which showed that the description logic ALC with n binary relations is in fact a notational variant of the multi-modal logic Kn. This means that results concerning Kn can be transferred to ALC, and vice-versa.\nIn this paper, we investigate the notions of prime implicates and prime implicants for the modal logic K = K1, but actually all of our results hold for formulae in Kn, and hence also for concept expressions in ALC. The decision to present our results in terms of K\nrather than in terms of Kn or ALC was motivated solely by a desire to simplify notation and increase the readability of the proofs.\nThe question of how the notions of prime implicates and prime implicants can be suitably defined for the logic K is clearly of interest from a theoretical point of view. We argue, however, that this question is also practically relevant. To support this claim, we briefly discuss two application areas in which the study of prime implicates and prime implicants in K might prove useful.\nThe first domain of application we will consider is abductive reasoning in K. As noted above, one of the key foundational issues in abductive reasoning is the selection of an interesting subset of explanations. This issue is especially crucial for logics like K which allow for an infinite number of non-equivalent formulae, since this means that the number of non-equivalent explanations for an abduction problem is not just large but in fact infinite, making it simply impossible to enumerate the entire set of explanations. As prime implicants are a widely-accepted means of characterizing relevant explanations in propositional logic, a reasonable starting point for research into abductive reasoning in the logic K is the study of different possible definitions of prime implicant in K and their properties.\nThe investigation of prime implicates in K is also relevant to the development of knowledge compilation procedures for K. We recall that knowledge compilation (cf. Darwiche & Marquis, 2002) is a general technique for coping with the intractability of reasoning which consists in an off-line phase in which a knowledge base is rewritten as an equivalent knowledge base which allows for tractable reasoning, followed by an online phase in which reasoning is performed on the compiled knowledge base. The idea is that the initial cost of compiling the knowledge base will be offset by computational savings on later queries. Currently, most work on knowledge compilation is restricted to propositional logic, even though this technique could prove highly relevant for modal and description logics, which generally suffer from an even higher computational complexity than propositional logic. As prime implicates are one of the better-known mechanisms for compiling formulae in propositional logic, it certainly makes sense to investigate whether this approach to knowledge compilation can be fruitfully extended to logics like K.\nOur paper is organized as follows. After some preliminaries, we consider how to appropriately generalize the notions of clauses and terms to K. As there is no obvious definition, we enumerate a list of syntactic, semantic, and complexity-theoretic properties of the propositional definitions, which we then use to compare the different candidate definitions. We next consider the different definitions in light of the notions of prime implicate and prime implicant they induce. Once again, we list some basic properties from the propositional case that we would like to satisfy, and we see how the different definitions measure up. In the second half of the paper, we investigate the computational properties of the most satisfactory definition of prime implicates. We consider the problems of prime implicate generation and recognition, and we provide sound and complete algorithms for both tasks. We also study the complexity of the prime implicate recognition problem, showing it to be Pspace-complete and thus of the same complexity as satisfiability and deduction in K. We conclude the paper with a discussion of the relevance of our results to the two application areas cited above and some directions for future research. In order to enhance the readability of the paper, proofs have been omitted from the body of the text. Full proofs can be found in the appendix."
    }, {
      "heading" : "2. Preliminary Definitions and Notation",
      "text" : "We briefly recall the basics of the modal logic K (refer to Blackburn, de Rijke, & Venema, 2001; Blackburn, van Benthem, & Wolter, 2006, for good introductions to modal logic). Formulae in K are built up from a set of propositional variables V, the standard logical connectives (¬, ∧, and ∨), and the modal operators 2 and 3. We will call a formula of the form 2ϕ (resp. 3ϕ) a 2-formula (resp. 3-formula). Where convenient we will use ϕ → ψ as an abbreviation for ¬ϕ∨ψ. We adopt the shorthand 2kϕ (resp. 3kϕ) to refer to the formula consisting of ϕ preceded by k copies of 2 (resp. 3), with the convention that 2\n0ϕ = 30ϕ = ϕ. We will use var(ϕ) to refer to the set of propositional variables appearing in a formula ϕ. The modal depth of a formula ϕ, written δ(ϕ), is defined as the maximal number of nested modal operators appearing in ϕ, e.g. δ(3(a∧2a)∨a) = 2. We define the length of a formula ϕ, written |ϕ|, to be the number of occurrences of propositional variables, logical connectives, and modal operators in ϕ. For example, we would have |(a ∧ ¬b)| = 4 and |3(a ∨ b) ∧ 2¬a| = 8.\nNegation normal form (NNF) is defined just as in propositional logic: a formula is said to be in NNF if negation only appears directly before propositional variables. Every formula ϕ in K can be transformed into an equivalent formula in NNF using the recursive procedure Nnf defined as follows:\nNnf(l)=l (for propositional literals l) Nnf(2ψ)=2Nnf(ψ) Nnf(ψ1 ∧ ψ2)=Nnf(ψ1)∧Nnf(ψ2) Nnf(¬2ψ)=3Nnf(¬ψ) Nnf(¬(ψ1 ∧ ψ2))=Nnf(¬ψ1)∨Nnf(¬ψ2) Nnf(3ψ)=3Nnf(ψ) Nnf(ψ1 ∨ ψ2)=Nnf(ψ1)∨Nnf(ψ2) Nnf(¬3ψ)=2Nnf(¬ψ) Nnf(¬(ψ1 ∨ ψ2))=Nnf(¬ψ1)∧Nnf(¬ψ2) Nnf(¬¬ψ)=Nnf(ψ)\nFor example, applying Nnf to the formula ¬2(a∧3(¬b∨ c)) results in the formula 3(¬a∨ 2(b∧¬c)) which is in NNF. The transformation Nnf takes linear time, and yields a formula which is no more than double the size of the original formula and has the same modal depth and propositional variables as the original.\nA model for K is a tuple M = 〈W,R, v〉, where W is a non-empty set of possible worlds, R ⊆ W ×W is a binary relation over worlds, and v : W ×V → {true, false} is a valuation of the propositional variables at each world. Models can be understood as labelled directed graphs, in which the vertices correspond to the elements of W, the directed edges represent the binary relation R, and the vertices are labeled by propositional valuations which specify the propositional variables which are true in the corresponding possible world.\nSatisfaction of a formula ϕ in a model M at the world w (written M, w |= ϕ) is defined inductively as follows:\n• M, w |= a if and only if v(w, a) = true\n• M, w |= ¬ϕ if and only if M, w 6|= ϕ\n• M, w |= ϕ ∧ ψ if and only if M, w |= ϕ and M, w |= ψ\n• M, w |= ϕ ∨ ψ if and only if M, w |= ϕ or M, w |= ψ\n• M, w |= 2ϕ if and only if M, w′ |= ϕ for all w′ such that wRw′\n• M, w |= 3ϕ if and only if M, w′ |= ϕ for some w′ such that wRw′\nIf we think of models as labeled directed graphs, then determining the satisfaction of a formula 2ϕ at vertex w consists in evaluating ϕ at all of the vertices which can be reached from w via an edge; 2ϕ is satisfied at w just in the case that ϕ holds in each of these successor vertices. Similarly, in order to decide whether a formula 3ϕ holds at a vertex w, we consider each of the successors of w in the graph and check whether at least one of these vertices satisfies ϕ.\nA formula ϕ is said to be a tautology, written |= ϕ, if M, w |= ϕ for every model M and world w. A formula ϕ is satisfiable if there is some model M and some world w such that M, w |= ϕ. If there is no M and w for which M, w |= ϕ, then ϕ is called unsatisfiable, and we write ϕ |= ⊥.\nLadner (1977) showed that satisfiability and unsatisfiability in K are Pspace-complete. For Pspace membership, Ladner exhibited a polynomial space tableaux-style algorithm for deciding satisfiability of K formulae. Pspace-hardness was proven by means of a reduction from QBF validity (the canonical Pspace-complete problem).\nIn modal logic, the notion of logical consequence (or entailment) can be defined in one of two ways:\n• a formula ψ is a global consequence of ϕ if whenever M, w |= ϕ for every world w of a model M, then M, w |= ψ for every world w of M\n• a formula ψ is a local consequence of ϕ if M, w |= ϕ implies M, w |= ψ for every model M and world w\nIn this paper, we will only consider the notion of local consequence, and we will take ϕ |= ψ to mean that ψ is a local consequence of ϕ. When ϕ |= ψ, we will say that ϕ entails ψ. Two formulae ϕ and ψ will be called equivalent, written ϕ ≡ ψ, if both ϕ |= ψ and ψ |= ϕ. A formula ϕ is said to be logically stronger than ψ if ϕ |= ψ and ψ 6|= ϕ.\nWe now highlight some basic properties of logical consequence and equivalence in K which will play an important role in the proofs of our results.\nTheorem 1. Let ψ, ψ1, ..., ψm, χ, χ1, ..., χn be formulae in K, and let γ be a propositional formula. Then\n1. ψ |= χ ⇔|= ¬ψ ∨ χ ⇔ ψ ∧ ¬χ |= ⊥\n2. ψ |= χ ⇔ 3ψ |= 3χ ⇔ 2ψ |= 2χ\n3. γ∧3ψ1∧...∧3ψm∧2χ1∧...∧2χn |= ⊥ ⇔ (γ |= ⊥ or ψi∧χ1∧...∧χn |= ⊥ for some i)\n4. |= γ ∨3ψ1 ∨ ... ∨3ψm ∨2χ1 ∨ ... ∨ 2χn ⇔ (|= γ or |= ψ1 ∨ ... ∨ ψm ∨ χi for some i)\n5. 2χ |= 2χ1 ∨ ... ∨ 2χn ⇔ χ |= χi for some i\n6. 3ψ1 ∨ ... ∨ 3ψm ∨ 2χ1 ∨ ... ∨ 2χn ≡ 3ψ1 ∨ ... ∨ 3ψm ∨ 2(χ1 ∨ ψ1 ∨ ... ∨ ψm) ∨ ... ∨ 2(χn ∨ ψ1 ∨ ... ∨ ψm)\nStatement 1 of Theorem 1 shows how the three reasoning tasks of entailment, unsatisfiability, and tautology-testing can be rephrased in terms of one another. Statement 2 tells us how entailment between two 2- or 3-formulae can be reduced to entailment between those formulae with the first modality removed. Statements 3 and 4 define the conditions under which a conjunction (resp. disjunction) of propositional literals and 2- and 3-formulae is unsatisfiable (resp. a tautology). Statement 5 gives us the conditions under which a 2-formula implies a disjunction of 2-formulae. Statement 6 demonstrates the interaction between 2- and 3-formulae in a disjunction.\nTheorem 2. Let λ be a disjunction of propositional literals and 2- and 3-formulae. Then each of the following statements holds:\n1. If λ |= γ for some non-tautological propositional clause γ, then every disjunct of λ is either a propositional literal or an unsatisfiable 3-formula\n2. If λ |= 3ψ1 ∨ ... ∨ 3ψn, then every disjunct of λ is a 3-formula\n3. If λ |= 2χ1 ∨ ... ∨ 2χn and 6|= 2χ1 ∨ ... ∨ 2χn, then every disjunct of λ is either a 2-formula or an unsatisfiable 3-formula\nTheorem 3. Let λ = γ ∨3ψ1 ∨ ...∨3ψm ∨2χ1 ∨ ...∨2χn and λ ′ = γ′ ∨3ψ′1 ∨ ...∨3ψ ′ p ∨ 2χ′1 ∨ ... ∨ 2χ ′ q be formulae in K. If γ and γ ′ are both propositional and 6|= λ′, then\nλ |= λ′ ⇔\n \n\nγ |= γ′ and ψ1 ∨ ... ∨ ψm |= ψ ′ 1 ∨ ... ∨ ψ ′ p and for every χi there is some χ ′ j such that χi |= ψ ′ 1 ∨ ... ∨ ψ ′ p ∨ χ ′ j\nTheorems 2 and 3 concern entailment relations between formulae which are disjunctions of propositional literals and 2- and 3-formulae. Theorem 2 tells us what kinds of formulae of this type can entail a propositional clause, a disjunction of 3-formulae, or a disjunction of 2-formulae, while Theorem 3 outlines the conditions under which two formulae of this type can be related to each other by the entailment relation. We illustrate Theorem 3 on a small example.\nExample 4. Consider the formula λ = ¬b ∨ 3(a ∧ 3c) ∨ 3(d ∧ 2a) ∨ 2(c ∨ d). Then according to Theorem 3, we have:\n• λ |= ¬b∨¬d∨3(a∨ d)∨2c, since ¬b |= ¬b∨¬d and (a∧3c)∨ (d∧2a) |= a∨ d and c ∨ d |= c ∨ (a ∨ d)\n• λ 6|= a ∨ 3c, since ¬b 6|= a\n• λ 6|= a ∨ ¬b ∨ 3(a ∧ c), since (a ∧ 3c) ∨ (d ∧ 2a) 6|= a ∧ c\n• λ 6|= ¬b ∨ 3(a ∨ 2a) ∨ 2c, since c ∨ d 6|= c ∨ (a ∨ 2a)"
    }, {
      "heading" : "3. Literals, Clauses, and Terms in K",
      "text" : "As we have seen in the introduction, the notions of prime implicates and implicants are straightforwardly defined using the notions of clauses and terms. Thus, if we aim to provide suitable definitions of prime implicates and implicants for the logic K, we first need to decide upon a suitable definition of clauses and terms in K. Unfortunately, whereas clauses and terms are standard notions in both propositional and first-order logic1, there is no generally accepted definition of clauses and terms in K. Indeed, several quite different notions of clauses and terms have been proposed in the literature for different purposes.\nInstead of blindly picking a definition and hoping that it is appropriate, we prefer to list a number of characteristics of literals, clauses, and terms in propositional logic, giving us a principled means of comparing different candidate definitions. Each of the properties below describes something of what it is to be a literal, clause, or term in propositional logic. Although our list cannot be considered exhaustive, we do believe that it covers the principal syntactic, semantic, and complexity-theoretic properties of the propositional definition.\nP1 Literals, clauses, and terms are in negation normal form.\nP2 Clauses do not contain ∧, terms do not contain ∨, and literals contain neither ∧ nor ∨.\nP3 Clauses (resp. terms) are disjunctions (resp. conjunctions) of literals.\nP4 The negation of a literal is equivalent to another literal. Negations of clauses (resp. terms) are equivalent to terms (resp. clauses).\nP5 Every formula is equivalent to a finite conjunction of clauses. Likewise, every formula is equivalent to a finite disjunction of terms.\nP6 The task of deciding whether a given formula is a literal, term, or clause can be accomplished in polynomial-time.\nP7 The task of deciding whether a clause (resp. term) entails another clause (resp. term) can be accomplished in polynomial-time.\nOne may wonder whether there exist definitions of literals, clauses, and terms for K satisfying all of these properties. Unfortunately, we can show this to be impossible.\nTheorem 5. Any definition of literals, clause, and terms for K that satisfies properties P1 and P2 cannot satisfy P5.\nThe proof of Theorem 5 only makes use of the fact that ∧ does not distribute over 3 and ∨ does not distribute over 2, which means that our impossibility result holds equally well for most standard modal and description logics.\nWe will now consider a variety of possible definitions and evaluate them with respect to the above criteria. The first definition that we will consider is that proposed by Cialdea\n1. One might wonder why we do not simply translate our formulae in K into first-order formulae and then put them into clausal form. The reason is simple: we are looking to define clauses and terms within the language of K, and the clauses we obtain on passing by first-order logic are generally not expressible in K. Moreover, if we were to define clauses in K as those first-order clauses which are representable in K, we would obtain a set of clauses containing no 3 modalities, thereby losing much of the expressivity of K.\nMayer and Pirri (1995) in a paper on abductive reasoning in modal logic. They define terms to be the formulae which can be constructed from the propositional literals using only ∧, 2, and 3. Modal clauses and literals are not used in the paper but can be defined analogously, yielding the following definition2:\nL ::= a | ¬a |2L |3L D1 C ::= a | ¬a |2C |3C |C ∨ C\nT ::= a | ¬a |2T |3T |T ∧ T\nIt is easy to see by inspection that this definition satisfies properties P1-P2, P4, and P6. Property P3 is not satisfied, however, since there are clauses that are not disjunctions of literals – take for instance 2(a∨ b). From Theorem 5 and the fact that both P1 and P2 are satisfied, we can conclude that property P5 cannot hold. At first glance, it may seem that entailment between clauses or terms could be accomplished in polynomial time, but this is not the case. In fact, we can show this problem to be NP-complete. The proof relies on the very strong resemblance between terms of D1 and concept expressions in the description logic ALE (for which both unsatisfiability and deduction are known to be NP-complete).\nBy using a slightly different definition, we can gain P3:\nL ::= a | ¬a |2L |3L D2 C ::= L |C ∨ C\nT ::= L |T ∧ T\nIt can be easily verified that definition D2 satisfies properties P1-P4 and P6. As definition D1 does not satisfy P5, and definitionD2 is even less expressive, it follows thatD2 does not satisfy P5 either. This reduced expressiveness does not however improve its computational complexity: property P7 is still not satisfied as we can show that entailment between clauses or terms is NP-complete using the same reduction as was used for definition D1. The fact that even an extremely inexpressive definition likeD2 does not allow for polynomial entailment between clauses and terms suggests that property P7 cannot be satisfied by any reasonable definition of clauses and terms for K.\nLet us now consider some more expressive options. We begin with the following definition of clauses that was proposed by Enjalbert and Fariñas del Cerro (1989) for the purpose of modal resolution:\nD3 C ::= a | ¬a |2C |3ConjC |C ∨C ConjC ::= C |ConjC ∧ConjC\nThis definition of clauses can be extended to a definition of terms and literals which satisfies P3 or P4, but there is no extension which satisfies both properties. Let us first consider one of the possible extensions which satisfies P4 and a maximal subset of P1-P7:\nL ::= a | ¬a |2L |3L D3a C ::= a | ¬a |2C |3ConjC |C ∨ C\nConjC ::= C |ConjC ∧ ConjC T ::= a | ¬a |2DisjT |3T |T ∧ T DisjT ::= T |DisjT ∨DisjT\n2. Note that here and in what follows, we let a range over propositional variables and L, C, and T range over the sets of literals, clauses, and terms, respectively.\nThis definition satisfies P1 and P4-P6 (satisfaction of P5 was shown in Enjalbert & Fariñas del Cerro, 1989). It does not satisfy P3 as there are clauses that are not disjunctions of literals – take for example 2(a ∨ b). Given that definition D3a is strictly more expressive than definitions D1 and D2, it follows that entailment between clauses or terms must be NP-hard, which means that D3a does not satisfy P7. In fact, we can show that entailment between clauses or terms of definition D3a is Pspace-complete. To do so, we modify the polynomial translation of QBF into K used to prove Pspace-hardness of K so that the translated formula is a conjunction of clauses with respect to D3a. We then notice that a formula ϕ is unsatisfiable if and only if 3ϕ entails 3(a ∧ ¬a). We thus reduce QBF validity to entailment between clauses, making this task Pspace-hard, and hence (being a subproblem of entailment in K) Pspace-complete. This same idea is used to show Pspacecompleteness for definitions D3b and D5 below.\nIf instead we extend D3 so as to enforce property P3, we obtain the following definition:\nL ::= a | ¬a |2C |3ConjC D3b C ::= a | ¬a |2C |3ConjC |C ∨ C\nConjC ::= C |ConjC ∧ ConjC T ::= L |T ∧ T\nThis definition satisfies all of the properties except P2, P4, and P7. Property P4 fails to hold because the negation of the literal 3(a ∨ b) is not equivalent to any literal. The proof that P5 holds is constructive: we use standard logical equivalences to rewrite formulae as equivalent conjunctions of clauses and disjunctions of terms (this is also what we do for definitions D4 and D5 below).\nWe now consider two rather simple definitions that satisfy properties P3, P4, and P5. The first definition, which is inspired by the notion of modal atom proposed by Giunchiglia and Sebastiani (1996), defines literals as the set of formulae in NNF that cannot be decomposed propositionally.\nL ::= a | ¬a |2F |3F D4 C ::= L |C ∨ C\nT ::= L |T ∧ T F ::= a | ¬a |F ∧ F |F ∨ F |2F |3F\nD4 satisfies all of the properties except P2 and P7. For P7, we note that an arbitrary formula ϕ in NNF is unsatisfiable (a Pspace-complete problem) if and only if 3ϕ |= 3(a ∧ ¬a).\nDefinition D4 is very liberal, imposing no structure on the formulae behind modal operators. If we define literals to be the formulae in NNF that cannot be decomposed modally (instead of propositionally), we obtain a much stricter definition which satisfies exactly the same properties as D4.\nL ::= a | ¬a |2C |3T D5 C ::= L |C ∨ C\nT ::= L |T ∧ T\nA summary of our analysis of the different definitions with respect to properties P1-P7 is provided in the following table.\nTheorem 6. The results in Figure 1 hold.\nClearly deciding between different candidate definitions is more complicated than counting up the number of properties that the definitions satisfy, the simple reason being that some properties are more important than others. Take for instance property P5 which requires clauses and terms to be expressive enough to represent all of the formulae in K. If we just use the standard propositional definition of clauses and terms (thereby disregarding the modal operators), then we find that it satisfies every property except P5, and hence more properties than any of the definitions considered in this section, and yet we would be hard-pressed to find someone who considers the propositional definition an appropriate definition for K. This demonstrates that expressiveness is a particularly important property, so important in fact that we should be willing to sacrifice properties P2 and P7 to keep it. Among the definitions that satisfy P5, we prefer definitions D4 and D5 to definitions D3a and D3b, as the latter definitions have less in common with the propositional definition and present no advantages over D4 and D5.\nOf course, when it comes down to it, the choice of a definition must depend on the particular application in mind. There may very well be circumstances in which a less expressive or less elegant definition may prove to be the most suitable. In this paper we are using clauses and terms to define prime implicates and prime implicants, so for us the most important criteria for choosing a definition will be the quality of the notions of prime implicates and prime implicants that the definition induces."
    }, {
      "heading" : "4. Prime Implicates/Implicants in K",
      "text" : "Once a definition of clauses and terms has been fixed, we can define prime implicates and prime implicants in exactly the same manner as in propositional logic:\nDefinition 7. A clause λ is an implicate of a formula ϕ if and only if ϕ |= λ. λ is a prime implicate of ϕ if and only if:\n1. λ is an implicate of ϕ\n2. If λ′ is an implicate of ϕ such that λ′ |= λ, then λ |= λ′\nDefinition 8. A term κ is an implicant of the formula ϕ if and only if κ |= ϕ. κ is a prime implicant of ϕ if and only if:\n1. κ is an implicant of ϕ\n2. If κ′ is an implicant of ϕ such that κ |= κ′, then κ′ |= κ\nOf course, the notion of prime implicate (resp. implicant) that we get will be determined by the definition of clause (resp. term) that we have chosen. We will compare different definitions using the following well-known properties of prime implicates/implicants in propositional logic:\nFiniteness The number of prime implicates (resp. prime implicants) of a formula is finite modulo logical equivalence.\nCovering Every implicate of a formula is entailed by some prime implicate of the formula. Conversely, every implicant of a formula entails some prime implicant of the formula.\nEquivalence A model M is a model of ϕ if and only if M is a model of all the prime implicates of ϕ if and only if M is a model of some prime implicant of ϕ3.\nImplicant-Implicate Duality Every prime implicant of a formula is equivalent to the negation of some prime implicate of the negated formula. Conversely, every prime implicate of a formula is equivalent to the negation of a prime implicant of the negated formula.\nDistribution If λ is a prime implicate of ϕ1 ∨ ... ∨ ϕn, then there exist prime implicates λ1, ..., λn of ϕ1, ..., ϕn such that λ ≡ λ1 ∨ ... ∨ λn. Likewise, if κ is a prime implicant of ϕ1 ∧ ... ∧ ϕn, then there exist prime implicants κ1, ..., κn of ϕ1, ..., ϕn such that κ ≡ κ1 ∧ ... ∧ κn\nFiniteness ensures that the prime implicates/implicants of a formula can be finitely represented, while Covering means the prime implicates provide a complete representation of the formula’s implicates. Equivalence guarantees that no information is lost in replacing a formula by its prime implicates/implicants, whereas Implicant-Implicate Duality allows us to transfer results and algorithms for prime implicates to prime implicants, and vice-versa. Finally, Distribution relates the prime implicates/implicants of a formula to the prime implicates/implicants of its sub-formulae. This property will play a key role in the prime implicate generation algorithm presented in the next section.\nWe can show that definition D4 satisfies all five properties. For Finiteness and Covering, we first demonstrate that every implicate λ of a formula ϕ is entailed by some implicate λ′ of ϕ with var(λ′) ⊆ var(ϕ) and having depth at most δ(ϕ) + 1 (and similarly for implicants). As there are only finitely many non-equivalent formulae on a finite language and with bounded depth, it follows that there are only finitely many prime implicates/implicants of a given formula, and that there can be no infinite chains of increasingly stronger implicates (or increasingly weaker implicants). Equivalence follows directly from Covering and the property P5 of the previous section: we use P5 to rewrite ϕ as a conjunction of clauses, each of which is implied by some prime implicate of ϕ because of Covering. The property Implicant-Implicate Duality is an immediate consequence of the duality\n3. The property Equivalence is more commonly taken to mean that a formula is equivalent to the conjunction of its prime implicates and the disjunction of its prime implicants. We have chosen a model-theoretic formulation in order to allow for the possibility that the set of prime implicates/implicants is infinite.\nbetween clauses and terms (P4). Distribution can be shown using Covering plus the fact that a disjunction of clauses is a clause and a conjunction of terms is a term (P3).\nTheorem 9. The notions of prime implicates and prime implicants induced by definition D4 satisfy Finiteness, Covering, Equivalence, Implicant-Implicate Duality, and Distribution.\nWe remark by way of contrast that in first-order logic the notion of prime implicate induced by the standard definition of clauses has been shown to falsify Finiteness, Covering, and Equivalence (Marquis, 1991a, 1991b).\nWe now show that definition D4 is the only one of our definitions to satisfy all five properties. For definitions D1 and D2, we show that Equivalence does not hold. This is a fairly straightforward consequence of the fact that these definitions do not satisfy property P5.\nTheorem 10. The notions of prime implicates and prime implicants induced by definitions D1 and D2 do not satisfy Equivalence.\nFor the notions of prime implicates induced by definitions D3a, D3b, and D5, we show in the appendix that the clause 23ka ∨ 3(a ∧ b ∧ 2k¬a) is a prime implicate of 2(a ∧ b) for every k ≥ 14. We thereby demonstrate not only that these definitions admit formulae with infinitely many distinct prime implicates but also that they allow seemingly irrelevant clauses to be counted as prime implicates. This gives us strong grounds for dismissing these definitions as much of the utility of prime implicates in applications comes from their ability to eliminate such irrelevant consequences.\nTheorem 11. The notions of prime implicates and prime implicants induced by D3a, D3b, and D5 falsify Finiteness.\nWhile the comparison in the last section suggested that D5 was at least as suitable as D4 as a definition of clauses and terms, the results of this section rule out D5 as a suitable definition for prime implicates and prime implicants. In the remainder of the paper, we will concentrate our attention on the notions of prime implicates and prime implicants induced by definition D4, as these have been shown to be the most satisfactory generalizations of the propositional case."
    }, {
      "heading" : "5. Prime Implicate Generation and Recognition",
      "text" : "In this section, we investigate the computational aspects of modal prime implicates. As we will be primarily focusing on the notion of prime implicate induced by definition D4, for the remainder of the paper we will use the words “clause”, “term”, and “prime implicate” to mean clause, term, and prime implicate with respect to definition D4, except where explicitly stated otherwise.\nWe remark that, without loss of generality, we can restrict our attention to prime implicates since by Implicant-Implicate Duality (Theorem 9) any algorithm for generating or recognizing prime implicates can be easily adapted into an algorithm for generating or recognizing prime implicants.\n4. For D4, the only prime implicate of 2(a ∧ b) is itself."
    }, {
      "heading" : "5.1 Generating Prime Implicates",
      "text" : "We start by considering the problem of generating the set of prime implicates of a given formula. This task is important if we want to produce abductive explanations, or if we want to compile a formula into its set of prime implicates.\nFor our generation algorithm, we will require a means of transforming the input formula into an equivalent disjunction of “simpler” formulae. To this end, we introduce in Figure 2 the helper function Dnf-4(ϕ) which returns a set of satisfiable terms with respect to D4 whose disjunction is equivalent to ϕ. The function Dnf-4 is defined in terms of another function Iter-Dnf-4 which takes an input a set S of formulae in NNF and returns in an iterative fashion a set of satisfiable terms whose disjunction is equivalent to S. The following lemmas highlight some important properties of these functions.\nLemma 12. Iter-Dnf-4 terminates and requires only polynomial space in the size of its input.\nLemma 13. The output of Dnf-4 on input ϕ is a set of satisfiable terms with respect to D4 whose disjunction is equivalent to ϕ.\nLemma 14. There are at most 2|ϕ| terms in Dnf-4(ϕ). Each of the terms has length at most 2|ϕ|, depth at most δ(ϕ), and contains only those propositional variables appearing in var(ϕ).\nWe present in Figure 3 the algorithm GenPI which computes the set of prime implicates of a given formula. Our algorithm works as follows: in Step 1, we check whether ϕ is unsatisfiable, outputting a contradictory clause if this is the case. For satisfiable ϕ, we set T equal to a set of satisfiable terms whose disjunction is equivalent to ϕ. Because of Distribution, we know that every prime implicate of ϕ is equivalent to some disjunction of prime implicates of the terms in T . In Step 2, we set ∆(T ) equal to the propositional\nliterals in T (LT ) plus the strongest 2-literal implied by T (2βT ) plus the strongest 3- literals implied by T ({3(ζ ∧ βT ) | ζ ∈ DT }). It is not too hard to see that every prime implicate of T must be equivalent to one of the elements in ∆(T ). This means that in Step 3 we are guaranteed that every prime implicate of the input formula is equivalent to some candidate prime implicate in Candidates. During the comparison phase in Step 4, non-prime candidates are eliminated, and exactly one prime implicate of each equivalence class will be retained.\nWe illustrate the behavior of GenPI on an example:\nExample 15. We run GenPI on input ϕ = a∧((3(b∧c)∧3b)∨(3b∧3(c∨d)∧2e∧2f)).\nStep 1: As ϕ is satisfiable, we call the function Dnf-4 on ϕ, and it returns the two terms T1 = a ∧ 3(b ∧ c) ∧ 3b and T2 = a ∧ 3b ∧ 3(c ∨ d) ∧ 2e ∧ 2f .\nStep 2: We have LT1 = {a}, DT1 = {b ∧ c, b}, and there are no 2-literals in T1, so we get ∆(T1) = {a,3(b ∧ c),3b}. For T2, we have LT2 = {a}, DT2 = {b, c ∨ d}, and βT2 = e ∧ f , giving us ∆(T2) = {a,2(e ∧ f),3(b ∧ e ∧ f),3((c ∨ d) ∧ e ∧ f)}.\nStep 3: The set Candidates will contain all the different possible disjunctions of elements in ∆(T1) with elements in ∆(T2), of which there are 12: a∨a, a∨2(e∧f), a∨3(b∧e∧f), a ∨ 3((c ∨ d) ∧ e ∧ f), 3(b ∧ c) ∨ a, 3(b ∧ c) ∨ 2(e ∧ f), 3(b ∧ c) ∨ 3(b ∧ e ∧ f), 3(b∧c)∨3((c∨d)∧e∧f), 3b∨a, 3b∨2(e∧f), 3b∨3(b∧e∧f), and 3b∨3((c∨d)∧e∧f).\nStep 4: We will remove from Candidates the clauses a ∨ 2(e ∧ f), a ∨ 3(b ∧ e ∧ f), a ∨ 3((c ∨ d) ∧ e ∧ f), 3(b ∧ c) ∨ a, and 3b ∨ a since they are strictly weaker than a ∨ a. We will also eliminate the clauses 3b ∨ 2(e ∧ f), 3b ∨ 3(b ∧ e ∧ f), and\n3b ∨ 3((c ∨ d) ∧ e ∧ f) since they are weaker than the clauses 3(b ∧ c) ∨ 2(e ∧ f), 3(b ∧ c) ∨ 3(b ∧ e ∧ f), 3(b ∧ c) ∨ 3((c ∨ d) ∧ e ∧ f).\nStep 5: GenPI will return the four remaining clauses in Candidates, which are a ∨ a, 3(b ∧ c) ∨ 2(e ∧ f), 3(b ∧ c) ∨ 3(b ∧ e ∧ f), and 3(b ∧ c) ∨ 3((c ∨ d) ∧ e ∧ f).\nOur algorithm can be shown to be a sound and complete procedure for generating prime implicates.\nTheorem 16. The algorithm GenPI always terminates and outputs exactly the set of prime implicates of the input formula.\nBy examining the prime implicates produced by the algorithm, we can place an upper bound on the length of a formula’s prime implicates.\nTheorem 17. The length of the smallest clausal representation of a prime implicate of a formula is at most single exponential in the length of the formula.\nThis upper bound is optimal as we can find formulae with exponentially large prime implicates. This situation contrasts with propositional logic, where the length of prime implicates is linearly bounded by the number of propositional variables in the formula.\nTheorem 18. The length of the smallest clausal representation of a prime implicate of a formula can be exponential in the length of the formula.\nIt is interesting to note that the formula used in the proof of Theorem 18 has a depth of 1, which means that we cannot avoid this worst-case spatial complexity by restricting our attention to formulae of shallow depth. Nor can we escape this exponential worst-case spatial complexity by dropping down to one of the less expressive notions of prime implicates examined in the previous section, as the following theorem attests.\nTheorem 19. If prime implicates are defined using either D1 or D2, then the length of the smallest clausal representation of a prime implicate of a formula can be exponential in the length of the formula.\nAn examination of the set of candidate prime implicates constructed by our algorithm allows us to place a bound on the maximal number of non-equivalent prime implicates a formula can possess.\nTheorem 20. The number of non-equivalent prime implicates of a formula is at most double exponential in the length of the formula.\nThis bound can also be shown to be optimal. This situation contrasts with propositional logic, where there can be at most single exponentially many non-equivalent prime implicates of a given formula.\nTheorem 21. The number of non-equivalent prime implicates of a formula may be double exponential in the length of the formula.\nAgain, this worst-case result is robust in that it can be improved neither by restricting the depth of formulae, nor by using less expressive notions of prime implicate, as the following theorem demonstrates.\nTheorem 22. If prime implicates are defined using either D1 or D2, then the number of non-equivalent prime implicates of a formula may be double exponential in the length of the formula.\nTheorems 19 and 22 together suggest that definitions D1 or D2 do not yield especially interesting approximate notions of prime implicate, as they induce a significant loss of expressivity without any improvement in the size or number of prime implicates in the worst-case.\nOur generation algorithm GenPI corresponds to the simplest possible implementation of the distribution property, and it is quite clear that it does not represent a practicable way for producing prime implicates. One major source of inefficiency is the large number of clauses that are generated, so if we want to design a more efficient algorithm, we need to find ways to generate fewer candidate clauses. There are a couple of different techniques that could be used. One very simple method which could yield a smaller number of clauses is to eliminate from ∆(T ) those elements which are not prime implicates of T , thereby decreasing the cardinalities of the ∆(T ) and hence of Candidates. To do this, we simply test whether βT is a tautology (and remove it if it is) and then compare the 3-literals in ∆(T ), discarding any weaker elements. If we apply this technique to Example 15, we would remove 3b from ∆(T1), thereby reducing the cardinality of Candidates from 12 to 8.\nMore substantial savings could be achieved by using a technique developed in the framework of propositional logic (cf. Marquis, 2000) which consists in calculating the prime implicates of T1, then the prime implicates of T1∨T2, then those of T1∨T2∨T3, and so on until we get the prime implicates of the full disjunction of terms. By interleaving comparison and construction, we can eliminate early on a partial clause that cannot give rise to prime implicates instead of producing all of the extensions of the partial clause and then deleting them one by one during the comparison phase. In our example, there were only two terms, but imagine that there was a third term T3. Then by applying this technique, we would first produce the 4 prime implicates of T1 ∨ T2 and then we would compare the 4|∆(T3)| candidate clauses of T1 ∨T2∨T3. Compare this with the current algorithm which generates and then compares 12|∆(T3)| candidate clauses.\nGiven that the number of elements in Candidates can be double exponential in the length of the input, cutting down on the size of the input to GenPI could yield significant savings. One obvious idea would be to break conjunctions of formulae into their conjuncts, and then calculate the prime implicates of each of the conjuncts. Unfortunately, however, we cannot apply this method to every formula as the prime implicates of the conjuncts are not necessarily prime implicates of the full conjunction. One solution which was proposed in the context of approximation of description logic concepts (cf. Brandt & Turhan, 2002) is to identify simple syntactic conditions that guarantee that we will get the same result if we break the formula into its conjuncts. For instance, one possible condition is that the conjuncts do not share any propositional variables. The formula ϕ in our example satisfies this condition since the variables in a and ((3(b∧ c)∧3b)∨ (3b∧3(c∨ d)∧2e∧2f)) are disjoint. By generating the prime implicates of the conjuncts separately, we can directly identify the prime implicate a, and we only have 6 candidate clauses of ((3(b ∧ c) ∧ 3b) ∨ (3b∧3(c∨d)∧2e∧2f)) to compare. If we also remove weaker elements from the ∆(Ti) as\nsuggested above, we get only 3 candidate clauses for ((3(b∧c)∧3b)∨(3b∧3(c∨d)∧2e∧2f)), all of which are prime implicates of ϕ.\nAnother important source of inefficiency in our algorithm is the comparison phase in which we compare all candidate clauses one-by-one in order to identify the strongest ones. The problem with this is of course that in the worst-case there can be a double exponential number of candidate clauses, simply because there may be double exponentially many distinct prime implicates, and each prime implicate must be equivalent to some candidate clause. Keeping all of these double exponentially many clauses in memory will generally not be feasible. Fortunately, however, it is not necessary to keep all of the candidate clauses in memory at once since we can generate them on demand from the sets ∆(T ). Indeed, as we demonstrate in the appendix, by implementing our algorithm in a more clever fashion, we obtain an algorithm which outputs the prime implicates iteratively while requiring only single-exponential space (the output of the algorithm could of course be double exponentially large because of Theorem 21).\nTheorem 23. There exists an algorithm which runs in single-exponential space in the size of the input and incrementally outputs, without duplicates, the set of prime implicates of the input formula.\nAlthough our modified algorithm has a much better spatial complexity than the original, it still does not yield a practicable means for generating prime implicates. The reason is that we still need to compare each of the candidate clauses against all the other candidate clauses in order to decide whether a candidate is a prime implicate or not. Given that the set of candidate clauses may be double exponential in number, this means that our algorithm may need to perform double exponentially many entailment tests before producing even a single prime implicate. A much more promising approach would be to test directly whether or not a candidate clause is a prime implicate without considering all of the other candidate clauses. In order to implement such an approach, we must of course come up with a procedure for determining whether or not a given clause is a prime implicate. This will be our objective in the following section."
    }, {
      "heading" : "5.2 Recognizing Prime Implicates",
      "text" : "The focus of this section is the problem of recognizing prime implicates, that is, the problem of deciding whether a clause λ is a prime implicate of a formula ϕ. As has been discussed in the previous subsection, this problem is of central importance, as any algorithm for generating prime implicates must contain (implicitly or explicitly) some mechanism for ensuring that the generated clauses are indeed prime implicates.\nIn propositional logic, prime implicate recognition is BH2-complete (Marquis, 2000), being as hard as both satisfiability and deduction. In K, satisfiability and unsatisfiability are both Pspace-complete, so we cannot hope to find a prime implicate recognition algorithm with a complexity of less than Pspace.\nTheorem 24. Prime implicate recognition is Pspace-hard.\nIn order to obtain a first upper bound, we can exploit Theorem 17 which tells us that there exists a polynomial function f such that every prime implicate of a formula ϕ is\nequivalent to some clauses of length at most 2f(|ϕ|). This leads to a simple procedure for determining if a clause λ is a prime implicate of a formula ϕ. We simply check for every clause λ′ of length at most 2f(|ϕ|) whether λ′ is an implicate of ϕ which implies λ but is not implied by λ. If this is the case, then λ is not a prime implicate (we have found a logically stronger implicate of ϕ), otherwise, there exists no stronger implicate, so λ is a prime implicate. It is not too hard to see that this algorithm can be carried out in exponential space, which gives us an Expspace upper bound.\nOf course, the problem with this naive approach is that it does not at all take into account the structure of λ, so we end up comparing a huge amount of irrelevant clauses, which is exactly what we were hoping to avoid. The algorithm that we propose later in this section avoids this problem by exploiting the information in the input formula and clause in order to cut down on the number of clauses to test. The key to our algorithm is the following theorem which shows how the general problem of prime implicate recognition can be reduced to the more specialized tasks of prime implicate recognition for propositional formulae, 2-formulae, and 3-formulae. To simplify the presentation of the theorem, we let Π(ϕ) refer to the set of prime implicates of ϕ, and we use the notation λ \\ {l1, ..., ln} to refer to the clause obtained by removing each of the literals li from λ. For example (a ∨ b ∨ 3c) \\ {a,3c} refers to the clause b.\nTheorem 25. Let ϕ be a formula of K, and let λ = γ1∨ ...∨γk∨3ψ1∨ ...∨3ψn∨2χ1∨ ...∨ 2χm (γj propositional literals) be a non-tautologous clause such that (a) χi ≡ χi∨ψ1∨...∨ψn for all i, and (b) there is no literal l in λ such that λ ≡ λ \\ {l}. Then λ ∈ Π(ϕ) if and only if the following conditions hold:\n1. γ1 ∨ ... ∨ γk ∈ Π(ϕ ∧ ¬(λ \\ {γ1, ..., γk}))\n2. 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψn) ∈ Π(ϕ ∧ ¬(λ \\ {2χi})) for every i\n3. 3(ψ1 ∨ ... ∨ ψn) ∈ Π(ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψn}))\nWe remark that the restriction to clauses for which χi ≡ χi ∨ ψ1 ∨ ... ∨ ψm for all i and for which λ 6≡ λ \\ {l} for all l is required. If we drop the first requirement, then there are some non-prime implicates that satisfy all three conditions, and if we drop the second, there are prime implicates which fail to satisfy one of the conditions5. These restrictions are without loss of generality however since every clause can be transformed into an equivalent clause satisfying them. For the first condition, we replace each 2χi by 2(χi∨ψ1∨ ...∨ψm), thereby transforming a clause γ1∨ ...∨γk∨3ψ1∨ ...3ψm∨2χ1∨ ...∨2χn into the equivalent γ1∨ ...∨γk ∨3ψ1∨ ...3ψm ∨2(χ1∨ψ1 ∨ ...∨ψm)∨ ...∨2(χn ∨ψ1∨ ...∨ψm). Then to make the clause satisfy the second condition, we simply remove from λ those literals for which λ ≡ λ \\ {l} until no such literal remains.\nTheorem 25 shows how prime implicate recognition can be split into three more specialized sub-tasks, but it does not tell us how to carry out these tasks. Thus, in order to turn\n5. For the first restriction, consider the formula ϕ = 3(a∧b∧c)∨2a and the clause λ = 3(a∧b)∨2(a∧¬b). It can be easily shown that λ is an implicate of ϕ, but λ is not a prime implicate of ϕ since there exist stronger implicates (e.g. ϕ itself). Nonetheless, it can be verified that both 2(a ∧ ¬b ∧ ¬(a ∧ b)) ∈ Π(ϕ∧¬(λ\\{2(a∧¬b)})) and 3(a∧b) ∈ Π(ϕ∧¬(λ\\{3(a∧b)})). For the second restriction, consider the formula 2a and the clause 2a∨2(a∧b). We have 2(a∧b) 6∈ Π(2a∧¬(2a)) even though 2a∨2(a∧b) ≡ 2a is a prime implicate of 2a.\nthis theorem into an algorithm for prime implicate recognition, we need to figure out how to test whether a propositional clause, a 2-formula, or a 3-formula is a prime implicate of a formula.\nDetermining whether a propositional clause is a prime implicate of a formula in K is conceptually no more difficult than determining whether a propositional clause is a prime implicate of a propositional formula. We first ensure that the clause is an implicate of the formula and then make sure that all literals appearing in the clause are necessary.\nTheorem 26. Let ϕ be a formula of K, and let γ be a non-tautologous propositional clause such that ϕ |= γ and such that there is no literal l in γ such that γ ≡ γ \\{l}. Then γ ∈ Π(ϕ) if and only if ϕ 6|= γ \\ {l} for all l in γ.\nWe now move on to the problem of deciding whether a clause of the form 2χ is a prime implicate of a formula ϕ. We remark that if 2χ is implied by ϕ, then it must also be implied by each of the terms Ti ∈Dnf-4(ϕ). But if Ti |= 2χ, then by Theorem 1, it must be the case that the conjunction of the 2-literals in Ti implies 2χ. This means that the formula 2β1 ∨ ... ∨ 2βn (where βi is the conjunction of the formulae ζ such that 2ζ is in Ti) is an implicate of ϕ which implies 2χ, and moreover it is the strongest such implicate. It follows then that 2χ is a prime implicate of ϕ just in the case that 2χ |= 2β1 ∨ ... ∨ 2βn, which is true if and only if χ |= βi for some i (by Theorem 1). Thus, by comparing the formula χ with the formulae βi associated with the terms of ϕ, we can decide whether or not 2χ is a prime implicate of ϕ.\nTheorem 27. Let ϕ be a formula of K, and let λ = 2χ be a non-tautologous clause such that ϕ |= λ. Then λ ∈ Π(ϕ) if and only if there exists some term T ∈Dnf-4(ϕ) such that χ |= βT , where βT is the conjunction of formulae ψ such that 2ψ is in T .\nFinally let us turn to the problem of deciding whether a clause 3ψ is a prime implicate of a formula ϕ. Now we know by Covering that if 3ψ is an implicate of ϕ, then there must be some prime implicate π of ϕ which implies 3ψ. It follows from Theorem 2 that π must be a disjunction of 3-literals, and from Theorem 16 that π is equivalent to a disjunction ∨\nT∈Dnf-4(ϕ) 3dT where 3dT is an element of ∆(T ) for every T (refer back to Figure 3 for the definition of ∆(T )). According to Definition 7, 3ψ is a prime implicate of ϕ just in the case that 3ψ |= ∨\nT∈Dnf-4(ϕ) 3dT , or equivalently ψ |= ∨\nT∈Dnf-4(ϕ) dT . Thus, 3ψ is not a prime implicate of ϕ just in the case that there is a choice of 3dT ∈ ∆(T ) for each T ∈ Dnf-4(ϕ) such that ∨\nT∈Dnf-4(ϕ) dT |= ψ and ψ 6|= ∨\nT∈Dnf-4(ϕ) dT . Testing directly whether ψ entails some formula ∨\nT∈Dnf-4(ϕ) dT could take exponential space in the worst case since there may be exponentially many terms in Dnf-4(ϕ). Luckily, however, we can get around this problem by exploiting the structure of the formula ∨\nT∈Dnf-4(ϕ) dT . We remark that because of the way ∆(T ) is defined the formula dT must be a conjunction of formulae ζ such that 2ζ or 3ζ appears in Nnf(ϕ) outside the scope of modal operators – we will use X to denote the set of formulae ζ satisfying this condition. We show in the appendix that ψ 6|= ∨\nT∈Dnf-4(ϕ) dT implies the existence of a subset S ⊆ X such that (a) ψ 6|= ∨\nλ∈S λ and (b) every dT has at least one conjunct from the set S. Conversely, the existence of such a subset of X implies ψ 6|= ∨\nT∈Dnf-4(ϕ) dT . This observation is the basis for the algorithm Test3PI given in Figure 4. The basic idea behind the algorithm is to try out each of the different subsets of X in order to see whether some subset satisfies the\naforementioned conditions. If we find a suitable subset, this proves that 3ψ is not a prime implicate, and if no such subset exists, then we can be sure there is no stronger implicate than 3ψ. The algorithm can be shown to run in polynomial space since there can be at most |ϕ| elements in X , and we can consider the terms in Dnf-4(ϕ) one at a time.\nTheorem 28. Let ϕ be a formula, and let 3ψ be an implicate of ϕ. Then the algorithm Test3PI returns yes on input (3ψ, ϕ) if and only if 3ψ is a prime implicate of ϕ.\nTheorem 29. The algorithm Test3PI runs in polynomial space.\nWe now illustrate the algorithm Test3PI with two examples.\nExample 30. We use Test3PI to test whether the clause λ = 3(a∧b) is a prime implicate of ϕ = a ∧ (2(b ∧ c) ∨ 2(e ∨ f)) ∧ 3(a ∧ b).\nStep 1: As ϕ is satisfiable, we pass directly to Step 2.\nStep 2: We set X equal to the set of formulae ζ such that 2ζ or 3ζ appears in Nnf(ϕ) outside the scope of modal operators. In our case, we set X = {b ∧ c, e ∨ f, a ∧ b} since ϕ =Nnf(ϕ) and b ∧ c, e ∨ f , and a ∧ b are the only formulae satisfying the requirements.\nStep 3: We examine each of the different subsets of X to determine whether they satisfy conditions (a) and (b). In particular, we consider the subset S = {b ∧ c, e ∨ f}. We remark that this subset satisfies condition (a) since a ∧ b 6|= (b ∧ c) ∨ (e ∨ f). In order to check condition (b), we first call the function Dnf-4 on ϕ which returns the two terms T1 = a ∧ 2(b ∧ c) ∧ 3(a ∧ b) and T2 = a ∧ 2(e ∨ f) ∧ 3(a ∧ b). We notice that the conjuncts 3(a∧ b) and 2(b∧ c) of T1 satisfy conditions (i) and (ii) since b∧ c ∈ S and 3(a∧ b∧ (b∧ c)) |= λ. We then notice that the conjuncts 3(a∧ b) and 2(e∨ f) of T2 also satisfy conditions (i) and (ii) since e∨ f ∈ S and 3(a∧ b∧ (e∨ f)) |= λ. That\nmeans that we have found a subset S of X which satisfies conditions (a) and (b), so the algorithm returns no. This is the correct output since 3(a∧ b∧ ((b∧ c)∨ (e∨ f))) is an implicate of ϕ which is strictly stronger than λ.\nExample 31. We use Test3PI to test whether the clause λ = 3(a ∧ b ∧ c) is a prime implicate of ϕ = a ∧ (2(b ∧ c) ∨ 2(e ∨ f)) ∧ 3(a ∧ b) ∧ ¬2(e ∨ f ∨ (a ∧ b ∧ c)).\nStep 1: We proceed directly to Step 2 since ϕ is satisfiable.\nStep 2: We set X = {b∧ c, e∨ f, a∧ b,¬e∧¬f ∧ (¬a∨¬b∨¬c))} since Nnf(ϕ)=a∧ (2(b∧ c) ∨ 2(e ∨ f)) ∧ 3(a ∧ b) ∧ 3(¬e ∧ ¬f ∧ (¬a ∨ ¬b ∨ ¬c)).\nStep 3: We check whether there is some subset of X satisfying conditions (a) and (b). We claim that there is no such subset. To see why, notice that a ∧ 2(b ∧ c) ∧ 3(a ∧ b) ∧ 3(¬e∧¬f ∧ (¬a∨¬b∨¬c)) is the only term in Dnf-4(ϕ). Moreover, there is only one set of conjuncts of this term which implies 3(a ∧ b ∧ c), namely {3(a ∧ b),2(b ∧ c)}. But that means that S must contain either a ∧ b or b ∧ c in order to satisfy condition (b)(i). As a ∧ b ∧ c implies both a ∧ b and b ∧ c, we are guaranteed that a ∧ b ∧ c will imply the disjunction of elements in S, thereby falsifying condition (a). It follows that there is no subset of X satisfying the necessary conditions, so Test3PI returns yes, which is the desired result.\nIn Figure 5, we present our algorithm for testing whether a clause λ is a prime implicate of a formula ϕ. The first two steps of the algorithm treat the limit cases where λ is not an implicate or where one or both of ϕ and λ is a tautology or contradiction. In Step 3,\nwe apply equivalence-preserving transformations to λ to make it satisfy the requirements of Theorem 25. Then in Steps 4, 5, and 6 we use the procedures from Theorems 26, 27, and 28 to test whether the three conditions in Theorem 25 are verified. If the three tests succeed, then by Theorem 25, the clause is a prime implicate, so we return yes. If some test fails, we return no as the clause has been shown not to be a prime implicate.\nTheorem 32. The algorithm TestPI always terminates, and it returns yes on input (λ, ϕ) if and only if λ is a prime implicate of ϕ.\nWe demonstrate the use of TestPI on an example.\nExample 33. We use TestPI to test if the clauses λ1 = b, λ2 = 2b∨2(e∨f), λ3 = a∨3c, λ4 = 3(a ∧ b), and λ5 = 3(a ∧ b ∧ c) ∨ 3(a ∧ b ∧ c ∧ f) ∨ 2(e ∨ f) are prime implicates of ϕ = a ∧ (2(b ∧ c) ∨ 2(e ∨ f)) ∧ 3(a ∧ b).\nλ1: We output no in Step 1 since ϕ 6|= λ1.\nλ2: We skip Steps 1 and 2 since λ |= λ2 and neither ϕ |= ⊥ nor |= λ2. In Step 3, we make no changes to λ2 since it contains no redundant literals nor any 3-literals. We skip Step 4 since λ2 has no propositional disjuncts. In Step 5, we return no since Dnf-4(ϕ∧¬(λ2 \\ {2b})) = {a∧2(b∧ c)∧3(a∧ b)∧3(¬e∧¬f)} and 2b 6|= 2(b∧ c).\nλ3: We proceed directly to Step 3 since λ |= λ3, ϕ 6|= ⊥, and 6|= λ3. No modifications are made to λ3 in Step 3 as it does not contain any redundant literals or 2-literals. In Step 4, we test whether or not ϕ |= λ3 \\ {a}. As ϕ 6|= 3c, we proceed on to Step 5, and then directly on to Step 6 since λ3 contains no 2-literals. In Step 6, we call Test3PI(3c, ϕ ∧ ¬(λ3 \\ {3c})), which outputs no since ϕ ∧ ¬(λ3 \\ {3c}) |= ⊥ and c 6|= ⊥.\nλ4: Steps 1-5 are all inapplicable, so we skip directly to Step 6. In this step, we call Test3PI with as input the clause 3(a∧b) and the formula ϕ∧¬(λ4\\{3(a∧b)}) = ϕ. We have already seen in Example 30 above that Test3PI returns no on this input, which means that TestPI also returns no.\nλ5: We proceed directly to Step 3, where we delete the redundant literal 3(a ∧ b ∧ c ∧ f) and then modify the literal 2(e∨f). At the end of this step, we have λ5 = 3(a∧b∧c)∨ 2((e∨f)∨(a∧b∧c)). Step 4 is not applicable since there are no propositional disjuncts in λ5. In Step 5, we continue since Dnf-4(ϕ ∧ ¬(λ5 \\ {2((e ∨ f ∨ (a ∧ b ∧ c))})) = {a∧2(e∨f)∧3(a∧b)∧2(¬a∨¬b∨¬c)}, and 2(((e∨f ∨(a∧b∧c))∧(¬a∨¬b∨¬c)) |= 2(e∨ f)∧2(¬a∨¬b∨¬c). In Step 6, we return yes since we call Test3PI on input (3(a ∧ b ∧ c), ϕ ∧ ¬(λ5 \\ {3(a ∧ b ∧ c)})), and we have previously shown in Example 31 that Test3PI returns yes on this input.\nWe show in the appendix that the algorithm TestPI runs in polynomial space. As we have already shown that TestPI decides prime implicate recognition, it follows that this problem is in Pspace:\nTheorem 34. Prime implicate recognition is in Pspace.\nBy putting together Theorems 24 and 34, we obtain a tight complexity bound for the prime implicate recognition task.\nCorollary 35. Prime implicate recognition is Pspace-complete."
    }, {
      "heading" : "6. Conclusion and Future Work",
      "text" : "The first contribution of this work is a detailed comparison of several different possible definitions of clauses, terms, prime implicates, and prime implicants for the modal logic K. The results of this investigation were largely positive: although we have shown that no perfect definition exists, we did exhibit a very simple definition (D4) which satisfies most of the desirable properties of the propositional case. The second contribution of our work is a thorough investigation of the computational aspects of the selected definition D4. To this end, we presented a sound and complete algorithm for generating prime implicates, as well as a number of optimizations to improve the efficiency of the algorithm. An examination of the structure of the prime implicates generated by our algorithm allowed us to place upper bounds on the length of prime implicates and on the number of prime implicates a formula can possess. We showed these bounds to be optimal by exhibiting matching lower bounds, and we further proved that the lower bounds hold even for some much less expressive notions of prime implicates. Finally, we constructed a polynomial-space algorithm for deciding prime implicate recognition, thereby showing this problem to be Pspace-complete, which is the lowest complexity that could reasonably be expected. Although the focus of the paper was on the logic K, all of our results can be easily lifted to multi-modal K and to concept expressions in the well-known description logic ALC.\nAs was mentioned in the introduction, one of the main applications of prime implicants in propositional logic is to the area of abductive reasoning, where prime implicants play the role of abductive explanations. The results of our paper can be directly applied to the problem of abduction in K: our notion of prime implicants can be used as a definition of abductive explanations in K, and our prime implicate generation algorithm provides a means of producing all of the abductive explanations to a given abduction problem. Moreover, because the notion of term underlying our definition of abductive explanations is more expressive than that used by Cialdea Mayer and Pirri (1995), we are able to find explanations which are overlooked by their method. For instance, if we look for an explanation of the observation c given the background information 2(a ∨ b) → c, we obtain 2(a ∨ b), whereas their framework yields 2a and 2b. This is an argument in favor of our approach since generally in abduction one is looking to find the weakest conditions guaranteeing the truth of the observation given the background information.\nAlso of interest are our results on the size and number of prime implicates, as these yield corresponding lower bounds on the size and number of abductive explanations. In particular, our results imply that the abductive explanations of Cialdea Mayer and Pirri (1995) can have exponential size and be double exponentially many in number in the worst case, and thus behave no better in these respects than the notion of abductive explanation induced by our preferred definition D4. Moreover, the fact that these lower bounds hold even in the case of the extremely inexpressive notion of abductive explanations induced by definition D2 suggests that these high worst-case complexity results really cannot be\navoided. In light of these intractability results, an interesting question for future research would be to study the problem of generating a single prime implicate, since in some applications it may prove sufficient to produce a single minimal explanation for an observation. Another interesting subject for future work which is relevant from the point of view of abduction is the investigation of the notion of prime implicate over a fixed vocabulary. The development of generation algorithms for this more refined notion of prime implicate would allow one to generate only those abductive explanations which are built up from a given set of propositional variables.\nThe second domain of application which was mentioned in the introduction was the area of knowledge compilation. In propositional logic, one well-known target language for knowledge compilation is prime implicate normal form, in which a formula is represented as the conjunction of its prime implicates. A natural idea would be to use our selected definition of prime implicate to define in an analogous manner a notion of prime implicate normal form for K formulae. Unfortunately, the normal form we obtain satisfies few of the nice properties of the propositional case. For instance, we find that entailment between two formulae in prime implicate normal form is no easier than between arbitrary K formulae. To see why, consider any pair of formulae ϕ and ψ in negation normal form. The formulae 3ϕ and 3ψ are their own prime implicates and hence are in prime implicate normal form according to the naive definition. As ϕ |= ψ just in the case that 3ϕ |= 3ψ, we can reduce entailment between arbitrary K formulae in NNF to entailment between formulae in prime implicate normal form. As the former problem is known to be Pspace-complete, it follows that the latter is Pspace-complete as well.\nAt first sight, this appears to be quite a disappointing result as one would hope that the computational difficulty of representing a formula by its prime implicates would be offset by some good computational properties of the resulting formula. As it turns out, however, the problem lies not in our definition of prime implicates but rather in the naive way of defining prime implicate normal form. Indeed, in a continuation of the present work (Bienvenu, 2008), we proposed a more sophisticated definition of prime implicate normal form, in which we specify which of the many different clausal representations of a prime implicate should be used. This normal form was shown to enjoy a number of desirable properties which make it interesting from the viewpoint of knowledge compilation. Most notably, it was proven that entailment between formulae in K in our prime implicate normal form can be carried out in polynomial time using a simple structural comparison algorithm which is reminiscent of the structural subsumption algorithms used in subpropositional description logics. It should be noted that the proof of this and other results by Bienvenu (2008) make ample use of the material presented in the current paper.\nIn this work, we studied prime implicates with respect to the local consequence relation, so a natural direction for future work would be the investigation of prime implicates with respect to the global consequence relation. This question is particularly interesting given that global consequence is the type of consequence used in description logic ontologies. Unfortunately, our preliminary investigations suggest that defining and generating prime implicates with respect to the global consequence relation will likely prove more difficult than for the local consequence relation. For one thing, if we use a definition of clause which is reasonably\nexpressive, then the notion of prime implicate we obtain does not satisfy Covering since we can construct infinite sequences of stronger and stronger implicates. Take for instance the formula (¬a ∨ b) ∧ (¬b ∨ 3b) which implies (using the global consequence relation) each of the increasingly stronger clauses in the infinite sequence ¬a ∨ 3b, ¬a ∨ 3(b ∧ 3b), ¬a∨3(b∧3(b∧3b)), ... This is a familiar situation for description logic practitioners since these infinite sequences are responsible for the non-existence of most specific concepts in many common DLs (cf. Küsters & Molitor, 2002) and the lack of uniform interpolation for ALC TBoxes (Ghilardi, Lutz, & Wolter, 2006). A standard solution to this problem is to simply place a bound on the depth of formulae to be considered, effectively blocking these problematic infinite sequences. This will not allow us to regain Covering, but it will give us a weaker version of this property, which should be sufficient for most applications. The development of generation algorithms for the global consequence relation may also prove challenging, since it is unclear at this point whether we will be able to draw inspiration from pre-existing methods. Despite these potential difficulties, we feel that this subject is worth exploring since it could contribute to the development of more flexible ways of accessing and structuring information in description logic ontologies.\nFinally, another natural direction for future research would be to extend our investigation of prime implicates and prime implicants to other popular modal and description logics. Particularly of interest are modal logics of knowledge and belief and expressive description logics used for the semantic web. We are confident that the experience gained from our investigation of prime implicates and prime implicants in K will prove a valuable asset in the exploration of other modal and description logics."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This paper corrects and significantly extends an earlier conference publication (Bienvenu, 2007). This paper was written while the author was a PhD student working at IRIT, Université Paul Sabatier, France. The author would like to thank her thesis supervisors Andreas Herzig, Jérôme Lang, and Jérôme Mengin, as well as the anonymous reviewers for very helpful feedback."
    }, {
      "heading" : "Appendix A. Proofs",
      "text" : "Theorem 1 Let ψ, ψ1, ..., ψm, χ, χ1, ..., χn be formulae in K, and let γ be a propositional formula. Then\n1. ψ |= χ ⇔|= ¬ψ ∨ χ ⇔ ψ ∧ ¬χ |= ⊥\n2. ψ |= χ ⇔ 3ψ |= 3χ ⇔ 2ψ |= 2χ\n3. γ∧3ψ1∧...∧3ψm∧2χ1∧...∧2χn |= ⊥ ⇔ (γ |= ⊥ or ψi∧χ1∧...∧χn |= ⊥ for some i)\n4. |= γ ∨3ψ1 ∨ ... ∨3ψm ∨2χ1 ∨ ... ∨ 2χn ⇔ (|= γ or |= ψ1 ∨ ... ∨ ψm ∨ χi for some i)\n5. 2χ |= 2χ1 ∨ ... ∨ 2χn ⇔ χ |= χi for some i\n6. 3ψ1 ∨ ... ∨ 3ψm ∨ 2χ1 ∨ ... ∨ 2χn ≡ 3ψ1 ∨ ... ∨ 3ψm ∨ 2(χ1 ∨ ψ1 ∨ ... ∨ ψm) ∨ ... ∨ 2(χn ∨ ψ1 ∨ ... ∨ ψm)\nProof. The first statement is a well-known property of local consequence, but we prove it here for completeness:\nψ |= χ ⇔ M, w |= ψ implies M, w |= χ for all M, w ⇔ M, w 6|= ψ or M, w |= χ for all M, w ⇔ M, w |= ¬ψ or M, w |= χ for all M, w ⇔ |= ¬ψ ∨ χ ⇔ M, w 6|= ψ ∧ ¬χ for all M, w ⇔ ψ ∧ ¬χ |= ⊥\nFor the second statement, if ψ 6|= χ, then there is some M, w such that M, w |= ψ ∧¬χ. Create a new model M′ from M by adding a new world w′ and placing a single arc from w′ to w. Then M′, w′ |= 3ψ ∧ 2¬χ, which means that 3ψ ∧ 2¬χ is satisfiable and hence 3ψ 6|= 3χ (since ¬2¬χ ≡ 3χ). For the other direction, suppose 3ψ 6|= 3χ. Then there exists M, w such that M, w |= 3ψ ∧ ¬3χ ≡ 3ψ ∧ 2¬χ. But this means that there is some w′ for which ψ ∧ ¬χ, hence ψ 6|= χ. To complete the proof, we use the following chain of equivalences: 2ψ |= 2χ ⇔ ¬2χ |= ¬2ψ ⇔ 3¬χ |= 3¬ψ ⇔ ¬χ |= ¬ψ ⇔ ψ |= χ.\nFor 3, suppose that γ ∧ 3ψ1 ∧ ... ∧3ψm ∧ 2χ1 ∧ ... ∧ 2χn 6|= ⊥. Then there exist M, w such that M, w |= γ ∧ 3ψ1 ∧ ...3ψm ∧ 2χ1 ∧ ... ∧ 2χn. As M, w |= γ, we cannot have γ |= ⊥, nor can we have ψi ∧ χ1 ∧ ... ∧ χn |= ⊥ since for each i there is some w\n′ such that M, w′ |= ψi ∧ χ1 ∧ ... ∧ χn. Now for the other direction suppose that γ and all of the ψi ∧ χ1 ∧ ... ∧ χn are satisfiable. Then there is some propositional model w of γ, and for each i, we can find Mi, wi such that Mi, wi |= ψi ∧ χ1 ∧ ... ∧ χn. Now we construct a new Kripke structure which contains the models Mi and the world w and in which there are arcs going from w to each of the wi. It is not hard to see that in this new model Mnew we have Mnew, w |= γ ∧ 3ψ1 ∧ ...3ψm ∧ 2χ1 ∧ ...2χn, so γ ∧ 3ψ1 ∧ ...3ψm ∧ 2χ1 ∧ ... ∧ 2χn 6|= ⊥.\nStatement 4 follows easily from the third statement. We simply notice that γ ∨ 3ψ1 ∨ ... ∨ 3ψm ∨ 2χ1 ∨ ... ∨ 2χn is a tautology just in the case that its negation ¬γ ∧ 3¬χ1 ∧ ... ∧ 3¬χn ∧ 2¬ψ1 ∧ ... ∧ 2¬ψm is unsatisfiable.\nFor 5, we use statements 1 and 4 to get the following chain of equivalences:\n2χ |= 2χ1 ∨ ... ∨ 2χn ⇔ |= 3¬χ ∨ 2χ1 ∨ ... ∨ 2χn ⇔ |= ¬χ ∨ χi for some i ⇔ χ |= χi for some i\nThe first implication of the equivalence in 6 is immediate since 3ψ1 ∨ ... ∨ 3ψm |= 3ψ1∨ ...∨3ψm and 2χi |= 2(χi∨ψ1∨ ...∨ψm) for all i. For the other direction, we remark that by using statements 1 and 3, we get the following equivalences:\n2(χi ∨ ψ1 ∨ ... ∨ ψm) |= 2χi ∨ 3ψ1 ∨ ... ∨ 3ψm ⇔ 2(χi ∨ ψ1 ∨ ... ∨ ψm) ∧ ¬(2χi ∨ 3ψ1 ∨ ... ∨ 3ψm) |= ⊥ ⇔ 2(χi ∨ ψ1 ∨ ... ∨ ψm) ∧ 3¬χi ∧ 2¬ψ1 ∧ ... ∧ 2¬ψm |= ⊥ ⇔ (χi ∨ ψ1 ∨ ... ∨ ψm) ∧ ¬χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm |= ⊥\nAs (χi ∨ ψ1 ∨ ... ∨ ψm) ∧ ¬χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm is clearly unsatisfiable, it follows that 2(χi ∨ψ1 ∨ ...∨ψm) |= 2χi ∨3ψ1 ∨ ...∨3ψm for every i and hence that 3ψ1 ∨ ...∨3ψm ∨ 2(χ1 ∨ ψ1 ∨ ... ∨ ψm) ∨ ... ∨ 2(χn ∨ ψ1 ∨ ... ∨ ψm) |= 3ψ1 ∨ ... ∨ 3ψm ∨ 2χ1 ∨ ... ∨ 2χn, completing the proof.\nTheorem 2 Let λ be a disjunction of propositional literals and 2- and 3-formulae. Then each of the following statements holds:\n1. If λ |= γ for some non-tautological propositional clause γ, then every disjunct of λ is either a propositional literal or an unsatisfiable 3-formula\n2. If λ |= 3ψ1 ∨ ... ∨ 3ψn, then every disjunct of λ is a 3-formula\n3. If λ |= 2χ1 ∨ ... ∨ 2χn and 6|= 2χ1 ∨ ... ∨ 2χn, then every disjunct of λ is either a 2-formula or an unsatisfiable 3-formula\nProof. For (1), let γ be a non-tautologous propositional clause such that λ |= γ, and suppose for a contradiction that λ contains a disjunct 2χ or a disjunct 3ψ where ψ 6|= ⊥. In the first case, we have 2χ |= γ, and hence |= 3¬χ ∨ γ. It follows from Theorem 1 that |= γ, contradicting our assumption that γ is not a tautology. In the second case, we have 3ψ |= γ, and thus |= 2¬ψ ∨ γ. By Theorem 1, either |= ¬ψ or |= γ. In both cases, we reach a contradiction since we have assumed that ψ 6|= ⊥ and 6|= γ. It follows then that λ cannot have any 2-formulae or satisfiable 3-formulae as disjuncts.\nThe proofs of (2) and (3) proceed similarly.\nTheorem 3 Let λ = γ ∨3ψ1 ∨ ... ∨3ψm ∨2χ1 ∨ ...∨2χn and λ ′ = γ′ ∨3ψ′1 ∨ ... ∨3ψ ′ p ∨ 2χ′1 ∨ ... ∨ 2χ ′ q be formulae in K. If γ are γ ′ are both propositional and 6|= λ′, then\nλ |= λ′ ⇔\n \n\nγ |= γ′ and ψ1 ∨ ... ∨ ψm |= ψ ′ 1 ∨ ... ∨ ψ ′ p and for every χi there is some χ ′ j such that χi |= ψ ′ 1 ∨ ... ∨ ψ ′ p ∨ χ ′ j\nProof. Since we have 6|= λ′, we know that 6|= γ′ and 6|= ψ′1 ∨ ... ∨ ψ ′ p ∨ χ ′ i for all i. Using this information together with Theorem 1, we get the following equivalences:\nγ |= λ′ ⇔ |= ¬γ ∨ γ′ ∨ 3ψ′1 ∨ ... ∨ 3ψ ′ p ∨ 2χ ′ 1 ∨ ... ∨ 2χ ′ m\n⇔ |= ¬γ ∨ γ′ ⇔ γ |= γ′\n3ψ1 ∨ ... ∨ 3ψm |= λ ′ ⇔ 3(ψ1 ∨ ... ∨ ψm) |= λ ′\n⇔ |= γ′ ∨ 3ψ′1 ∨ ... ∨ 3ψ ′ p ∨ 2¬(ψ1 ∨ ... ∨ ψm) ∨ 2χ ′ 1 ∨ ... ∨ 2χ ′ q ⇔ |= ψ′1 ∨ ... ∨ ψ ′ p ∨ ¬(ψ1 ∨ ... ∨ ψm) ⇔ ψ1 ∨ ... ∨ ψm |= ψ ′ 1 ∨ ... ∨ ψ ′ p\n2χi |= λ ′ ⇔ |= γ′ ∨ 3(ψ′1 ∨ ... ∨ ψ ′ p ∨ ¬χi) ∨ 2χ ′ 1 ∨ ... ∨ 2χ ′ q\n⇔ there is some j such that |= ψ′1 ∨ ... ∨ ψ ′ p ∨ ¬χi ∨ χ ′ j ⇔ there is some j such that χi |= ψ ′ 1 ∨ ... ∨ ψ ′ p ∨ χ ′ j\nTo complete the proof, we use the fact λ |= λ′ if and only if γ |= λ′, 3ψ1 ∨ ... ∨ 3ψm |= λ ′, and 2χi |= λ ′ for every i.\nTheorem 5 Any definition of literals, clause, and terms for K that satisfies properties P1 and P2 cannot satisfy P5.\nProof. We remark that the set of clauses (resp. terms) with respect to definition D1 is precisely the set of formulae in NNF which do not contain ∧ (resp. ∨), i.e. D1 is the most expressive definition satisfying both P1 and P2. Thus, to show the result, it suffices to show that D1 does not satisfy P5.\nSuppose for a contradiction thatD1 does satisfy P5. Then there must exist clauses λ1, ..., λn such that 3(a∧ b) ≡ λ1 ∧ ...∧ λn. Each of the clauses λi is a disjunction li,1 ∨ ....∨ li,pi . By distributing ∧ over ∨, we obtain the following:\n3(a ∧ b) ≡ ∨\n(j1,...,jn)∈{1,...,p1}×...×{1,...,pn}\nn∧\ni=1\nli,ji\nfrom which we can infer that for each (j1, ..., jn) ∈ {1, ..., p1} × ...× {1, ..., pn} we have\nn∧\ni=1\nli,ji |= 3(a ∧ b)\nConsider some (j1, ..., jn) such that ∧n\ni=1 li,ji is consistent (there must be at least one such tuple, otherwise we would have 3(a ∧ b) ≡ ⊥). The formulae li,ji are either propositional literals or formulae of the form 2κ or 3κ for some clause κ. It follows that\n∧n i=1 li,ji must\nhave the following form:\nγ1 ∧ ... ∧ γk ∧ 3ψ1 ∧ ... ∧ 3ψm ∧ 2χ1 ∧ ... ∧ 2χn\nwhere γ1, ..., γk are propositional literals and ψ1, ..., ψm, χ1, ..., χn are clauses with respect to D1. As we know that\n∧n i=1 li,ji |= 3(a∧ b) and ∧n i=1 li,ji 6|= ⊥, by Theorem 1, there must\nbe some 3ψq such that 3ψq ∧ 2χ1 ∧ ... ∧ 2χn |= 3(a ∧ b)\nWe now show that 3ψq 6|= 3(a ∧ b) (and hence that 6|= χ1 ∧ ... ∧ χn). Suppose for a contradiction that this is not the case. Then we must have ψq |= a and ψq |= b. But by Theorem 1, every disjunct of ψq (which we recall is a D1-clause) must either be unsatisfiable or equal to both a and b. As the latter is impossible, it follows that ψq |= ⊥, which is a contradiction since we assumed that\n∧n i=1 li,ji is satisfiable. It follows then that in order to\nget 3ψq ∧ 2χ1 ∧ ... ∧ 2χn |= 3(a ∧ b), there must be some χr which is not a tautology. Now let us consider the formula\nτ = ∨\n{(j1,...,jn)| Vn\ni=1 li,ji 6≡⊥}\n2χj1,...,jn\nwhere 2χj1,...,jn is a non-tautological 2-formula appearing in ∧n\ni=1 li,ji (we have just shown that such a formula must exist). Clearly it must be the case that\n∨\n(j1,...,jn)∈{1,...,p1}×...×{1,...,pn}\nn∧\ni=1\nli,ji |= τ\nfrom which we get:\n3(a ∧ b) |= τ\nBut according to Theorem 2, a satisfiable 3-formula cannot imply a disjunction of 2- formulae unless that disjunction is a tautology, so we must have |= τ . However, this is impossible since it would imply (Theorem 1) that there is some χj1,...,jn which is a tautology, contradicting our earlier assumption to the contrary. We can thus conclude that there is no set of clauses λ1, ..., λn with respect to D1 such that 3(a∧ b) ≡ λ1 ∧ ... ∧ λn, and hence that any definition which satisfies P1 and P2 cannot satisfy P5.\nIn order to prove Theorem 6, we will make use of the following lemmas:\nLemma 6.1 Definition D5 satisfies P5.\nProof. We demonstrate that any formula in K in NNF is equivalent to a conjunction of clauses with respect to definition D5. The restriction to formulae in NNF is without loss of generality as every formula is equivalent to a formula in NNF. The proof proceeds by induction on the structural complexity of formulae. The base case is propositional literals, which are already conjunctions of clauses since every propositional literal is a clause with respect to D5. We now suppose that the statement holds for formulae ψ1 and ψ2 and show that it holds for more complex formulae.\nWe first consider ϕ = ψ1 ∧ ψ2. By assumption, we can find clauses ρi and ζj such that ψ1 ≡ ρ1 ∧ ... ∧ ρn and ψ2 ≡ ζ1 ∧ ... ∧ ζm. Thus, ϕ is equivalent to the formula ρ1 ∧ ... ∧ ρn ∧ ζ1 ∧ ... ∧ ζm, which is a conjunction of clauses with respect to D5.\nNext we consider ϕ = ψ1 ∨ ψ2. By the induction hypothesis, we have ψ1 ≡ ρ1 ∧ ... ∧ ρn and ψ2 ≡ ζ1 ∧ ... ∧ ζm for some clauses ρi and ζj. Thus, ϕ ≡ (ρ1 ∧ ... ∧ ρn) ∨ (ζ1 ∧ ... ∧ ζm), which can be written equivalently as ϕ ≡ ∧(i,j)∈{1,...,n}×{1,...,m}(ρi ∨ ζj). Since the union of two clauses produces another clause, all of the ρi ∨ ζj are clauses, completing the proof.\nWe now consider the case where ϕ = 2ψ1. By assumption, ψ1 ≡ ρ1∧ ...∧ρn, where each ρi is a clause. So ϕ ≡ 2(ρ1∧...∧ρn). But we also know that 2(ρ1∧...∧ρn) ≡ 2ρ1∧...∧2ρn. It follows that ϕ is equivalent to 2ρ1 ∧ ...∧2ρn, which is a conjunction of clauses since the 2ρi are all clauses.\nFinally, we consider ϕ = 3ψ1. Using the induction hypothesis, we have ϕ ≡ 3(ρ1 ∧ ... ∧ ρn) for clauses ρi. But since the ρi are clauses, each ρi is a disjunction of literals li,1 ∨ ...∨ li,pi . After distributing ∧ over ∨ and ∨ over 3, we find that ϕ is equivalent to the formula\n∨\n(j1,...,jn)∈{1,...,p1}×...×{1,...,pn}\n3(l1,j1 ∧ l2,j2 ∧ ... ∧ ln,jn)\nwhich is a clause with respect to D5.\nThe proof that every formula is equivalent to a disjunction of terms with respect to D5 proceeds analogously.\nLemma 6.2 Every clause (resp. term) with respect to D5 is a clause (resp. term) with respect to definitions D3a, D3b, and D4.\nProof. We will show by induction on the structural complexity of formulae that:\n1. every clause C with respect to D5 is a clause with respect to definitions D3a, D3b, and D4 and a disjunction of terms with respect to D3a\n2. every term T with respect to D5 is a term with respect to definitions D3a, D3b, and D4 and a conjunction of clauses with respect to D3a and D3b\nWe require this stronger formulation of the statement to prove some of the sub-cases.\nThe base case for our induction is propositional literals, which are both clauses and terms with respect to D5. It is easy to see that (1) and (2) are verified since propositional literals are both clauses and terms with respect to definitions D3a, D3b, and D4 (and hence they are also disjunctions of terms with respect to D3a and conjunctions of clauses with respect to D3a and D3b).\nFor the induction step, we will show that the above statements hold for arbitrary clauses or terms with respect to D5 under the assumption that the statments hold for all of their proper sub-clauses and sub-terms.\nWe begin with clauses. Let C be a D5-clause such that all proper sub-clauses and subterms of C satisfy (1) and (2). Now since C is a clause with respect to D5, it can either be a propositional literal or a formula of the form C1 ∨ C2 for clauses C1 and C2, 2C1 for some clause C1, or 3T1 for some term T1. The case where C is a propositional literal has already been treated in the base case. Let us thus consider the case where C = C1 ∨ C2. The first part of (1) holds since by the induction hypothesis both C1 and C2 are clauses with respect to definitions D3a, D3b, and D4, and for all three definitions the disjunction of two clauses is a clause. The second half of (1) is also verified since both C1 and C2 are disjunctions of terms with respect to D3a, and thus so is their disjunction C1 ∨ C2. We next consider the case where C = 2C1 for some clause C1 with respect to D5. The first part of (1) follows easily as we know that C1 must also be a clause with respect to D3a, D3b, and D4, and for all of these definitions putting a 2 before a clause yields another clause. The second part of (1) holds as well since C1 is a disjunction of terms with respect to D3a and thus 2C1 is a term with respect to this same definition. We now suppose that C = 3T1 for some term T1 with respect to D5. For definitions D3a and D3b, we know from the induction hypothesis that T1 is a conjunction of clauses with respect to D3a and D3b and hence that 3T1 is a clause with respect to these definitions. For D4, the result obviously holds since we are allowed to put any formula in NNF behind 3. The second part of (1) holds since by the induction hypothesis T1 is a term with respect to D3a and hence 3T1 is also a term with respect to this definition.\nWe next consider terms. Let T be a D5-term such that all proper sub-clauses and subterms of T satisfy (1) and (2). Then T must be either a propositional literal or a formula of the form T1 ∧ T2 for terms T1 and T2, 2C1 for some clause C1, or 3T1 for some term T1. If T = T1 ∧T2, the first half of (2) holds since we know T1 and T2 to be terms with respect to D3a, D3b, and D4, and conjunctions of terms are also terms for all three definitions. The second half is also verified since both T1 and T2 are assumed to be conjunctions of clauses with respect to D3a and D3b, which means that T is also a conjunction of clauses with respect to these definitions. Next suppose that T = 2C1. For definitions D3b and D4, it is easy to see that T is a literal and hence a term. For D3a, the induction hypothesis tells us that C1 is a disjunction of terms, from which we can deduce that 2C1 is a term. Moreover, since C1 is known to be a clause with respect to D3a and D3b, then 2C1 must also be a\nclause with respect to these definitions, so T is a conjunction of clauses with respect to both D3a and D3b. Finally, we treat the case where T = 3T1. For D3a, we use the fact that T1 is a term with respect to D3a, which means that 3T1 must also be a term. For D3b, we use the supposition that T1 is a conjunction of clauses with respect to D3b, from which we get that 3T1 is a literal and hence a term. The first part of (2) clearly also holds for D4 since any formula behind 3 yields a literal and thus a term. The second half of (2) follows from the fact that by the induction hypothesis T1 is a conjunction of clauses with respect to D3a and D3b, so 3T1 is a clause (and hence a conjunction of clauses) with respect to these definitions.\nLemma 6.3 Entailment between terms or clauses is NP-complete for both definitions D1 and D2.\nProof. In the proofs of both NP-membership and NP-hardness, we will exploit the relationship between terms with respect to definitions D1 and D2 and concept expressions in the description logic ALE (cf. Baader, McGuiness, Nardi, & Patel-Schneider, 2003). We recall that concept expressions in this logic are constructed as follows (we use a modal logic syntax and assume a single modal operator in order to facilitate comparison between the formalisms):\nϕ ::= ⊤ |⊥ | a | ¬a |ϕ ∧ ϕ |2ϕ |3ϕ\nThe semantics of the symbols ⊤ and ⊥ is as one would expect: M, w |= ⊤ and M, w 6|= ⊥ for every model M and world w. The semantics of atomic literals, conjunctions, and universal and existential modalities is exactly the same as for K.\nIt is not hard to see that every term with respect to D1 or D2 is a concept expression in ALE. As entailment between ALE expressions is decidable in nondeterministic polynomial time (cf. Donini, Lenzerini, Nardi, Hollunder, Nutt, & Marchetti Spaccamela, 1992), it follows that deciding entailment between terms with respect to either D1 or D2 can also be accomplished in nondeterministic polynomial time, i.e. these problems belong to NP.\nIt remains to be shown that these problems are NP-hard. To prove this, we show how the polynomial-time reduction of Donini (2003) (adapted from the original NP-hardness proof by Donini et al., 1992) of the NP-complete exact cover (XC) problem (Garey &\nJohnson, 1979) to unsatisfiability in ALE can be modified so as to give a polynomial-time reduction from XC to entailment between terms with respect to D1 or D2.\nThe exact cover problem is the following: given a set U = {u1, ..., un} and a set S = {S1, ..., Sm} of subsets of U , determine whether there exists an exact cover, that is, a subset {Si1 , ..., Siq} of S such that Sih ∩ Sik = ∅ for h 6= k and ⋃q k=1 Sik = U . Donini has proven (2003) that U ,S has an exact cover if and only if the formula ϕU ,S pictured in Figure 6 is unsatisfiable. Notice that ϕU ,S is not a term with respect to either D1 and D2 as it uses the symbols ⊤ and ⊥. We would like to find a similar formula which is a term with respect to our definitions and which is satisfiable if and only if ϕU ,S is. Consider the formula\nϕ′U ,S = ϕ ′ 1,1 ∧ ... ∧ ϕ ′ 1,m ∧ ψ ′\nwhere ϕ′i,j and ψ ′ are defined exactly like ϕi,j and ψ except that we replace ⊤ by a and ⊥ by ¬a. It is easy to verify that ϕ′U ,S is indeed a term with respect to both D1 and D2. Moreover, it is not too hard to see that ϕ1,1 ∧ ... ∧ ϕ1,m |= 3 2n⊤ if and only if ϕ′1,1 ∧ ... ∧ ϕ ′ 1,m |= 3 2na and hence that ϕU ,S and ϕ ′ U ,S are equisatisfiable. As U ,S has an exact cover if and only if ϕU ,S is unsatisfiable, and ϕU ,S is unsatisfiable just in the case that ϕ′U ,S is, it follows that U ,S has an exact cover if and only if ϕ ′ U ,S is unsatisfiable. Moreover, ϕ′U ,S can be produced in linear time from ϕU ,S , so we have a polynomial-time reduction from XC to unsatisfiability of terms in D1 or D2. But a formula is unsatisfiable just in the case that it entails the term a∧¬a. So, XC can be polynomially-reduced to entailment between terms with respect to either D1 or D2, making these problems NP-hard and hence NP-complete.\nIn order to show the NP-completeness of clausal entailment, we remark that for both definitions D1 and D2, the function Nnf transforms negations of clauses into terms and negations of terms into clauses. This means that we can test whether a clause λ entails a clause λ′ by testing whether the term Nnf(¬λ′) entails the term Nnf(¬λ). Likewise, we can test whether a term κ entails another term κ′ by testing whether the clause Nnf(¬κ′) entails the clause Nnf(¬κ). As the NNF transformation is polynomial, it follows that entailment between clauses is exactly as difficult as entailment between terms, so clausal entailment is NP-complete.\nLemma 6.4 For definition D5, entailment between clauses or terms is Pspace-complete.\nProof. Membership in Pspace is immediate since entailment between arbitrary formulae in K can be decided in polynomial space. To prove Pspace-hardness, we adapt an existing proof of Pspace-hardness of K.\nFigure 7 presents an encoding of a QBF β = Q1p1...Qmpmθ in a K-formula f(β) that is used in section 6.7 of (Blackburn et al., 2001) to demonstrate the Pspace-hardness of K. The formula f(β) has the property that it is satisfiable just in the case that β is a QBF-validity. As the formula f(β) can be generated in polynomial-time from β, and the QBF-validity problem is known to be Pspace-hard, it follows that satisfiability of formulae in K is Pspace-hard as well.\nIn Figure 8, we show a modified encoding. We claim the following:\n(1) f(β) and f ′(β) are logically equivalent\n(2) if θ is in CNF, then f ′(β) is a conjunction of clauses with respect to D5\n(3) if θ is in CNF, then f ′(β) can be generated in polynomial time from f(β)\nTo show (1), it suffices to show that (i)≡(i’), (ii)≡(ii’), (iiia)≡(iiia’), (iiib)≡(iiib’), (iv)≡(iv’), and (v)≡(v’). The first equivalence is immediate since (i) and (i’) are identical. (ii)≡(ii’) follows from the fact that 2k(qi → ∧j 6=i¬qj) ≡ ∧j 6=i2\nk(¬qi ∨ ¬qj). (iiia)≡(iiia’) holds since (iiia’) is just (iiia) with qi → 3qi+1 replaced with ¬qi ∨ 3qi+1. We have (iiib)≡(iiib’) since 2i(qi → (3(qi+1 ∧ pi+1) ∧ 3(qi+1 ∧ ¬pi+1))) ≡ 2 i(¬qi ∨ 3(qi+1 ∧ pi+1)) ∧ 2 i(¬qi ∨ 3(qi+1 ∧ ¬pi+1)). The equivalence (iv)≡(iv’) holds as 2 j((pi → 2pi) ∧ (¬pi → 2¬pi)) ≡ 2 j(¬pi ∨2pi) ∧2\nj(pi ∨2¬pi). Finally, we have (v)≡(v’) since θ ≡ θ1 ∧ ... ∧ θl. Thus, f(β) and f ′(β) are logically equivalent.\nTo prove (2), we show that each of the component formulae in f ′(β) is a conjunction of clauses with respect to D5, provided that θ is in CNF. Clearly this is the case for (i’) as (i’) is a propositional literal. The formula (ii’) is also a conjunction of clauses with respect to D5 since it is a conjunction formulae of the form 2k(¬qi ∨ ¬qj). Similarly, (iiia’), (iiib’), and (iv’) are all conjunctions of clauses since the formulae 2k(¬qi ∨ 3qi+1), 2 i(¬qi ∨ 3(qi+1 ∧ pi+1)), 2 i(¬qi ∨ 3(qi+1 ∧ ¬pi+1)), 2 k(¬pi ∨ 2pi), and 2 k(pi ∨ 2¬pi) are all clauses with respect to D5. The formula (v’) must also be a conjunction of clauses since the θi are assumed to be propositional clauses, making each 2\nm(¬qm ∨ θi) a clause with respect to D5, and (v’) a conjunction of clauses with respect to D5.\nFor (3), it is clear that we can transform (i), (iiia), (iiib), and (iv) into (i’), (iiia’), (iiib’), and (iv’) in polynomial time as the transformations involve only simple syntactic operations and the resulting formulae are at most twice as large. The transformation from (ii) to (ii’) is very slightly more involved, but it is not too hard to see the resulting formula is at most m times as large as the original (and m can be no greater than the length of f(β)). The only step which could potentially result in an exponential blow-up is the transformation from (v) to (v’), as we put θ into CNF. But under the assumption that θ is already in CNF, the transformation can be executed in polynomial time and space, as all we have to do is separate θ into its conjuncts and rewrite the (qm → θi) as (¬qm ∨ θi).\nNow let β = Q1p1...Qmpmθ be a QBF such that θ = θ1 ∧ ... ∧ θl for some propositional clauses θi. Let f\n′(β) be the formula as defined in Figure 8. By (2) above, we know that f ′(β) = λ1 ∧ ... ∧ λp for some clauses λi with respect to D5. Now consider the following formula\nζ = 3(2λ1 ∧ ... ∧ 2λp ∧ 32(a ∨ ¬a))\nWe can show that f ′(β) is satisfiable if and only if ζ is satisfiable as follows:\nζ is unsatisfiable\n⇔ 2λ1 ∧ ... ∧ 2λp ∧ 32(a ∨ ¬a) is unsatisfiable\n⇔ λ1 ∧ ... ∧ λp ∧ 2(a ∨ ¬a) is unsatisfiable\n⇔ λ1 ∧ ... ∧ λp is unsatisfiable ⇔ f ′(β) is unsatisfiable\nBut we also know from (1) above that f ′(β) ≡ f(β), and from (Blackburn et al., 2001) that f(β) is satisfiable just in the case that β is a QBF validity. It is also easy to see that ζ is satisfiable if and only if ζ does not entail the contradiction 3(a ∧ ¬a). Putting this altogether, we find that β is valid just in the case that ζ does not entail 3(a ∧ ¬a). As ζ and 3(a ∧ ¬a) are both clauses and terms with respect to D5, we have shown that the QBF-validity problem for QBF with propositional formulae in CNF can be reduced to the problems of entailment of clauses or terms with respect to D5. Moreover, this is a polynomial time reduction since it follows from (3) that the transformation from β to ζ can be accomplished in polynomial time. This suffices to show Pspace-hardness, since it is well-known that QBF-validity remains Pspace-hard even when we restrict the propositional part θ to be a formula in CNF (cf. Papadimitriou, 1994).\nTheorem 6 The results in Figure 1 hold.\nProof. The satisfaction or dissatisfaction of properties P1 and P2 can be immediately determined by inspection of the definitions, as can the satisfaction of P3 by definitions D2, D3b, D4, and D5. Counterexamples to P3 for definitions D1 and D3a were provided in body of the paper: the formula 2(a ∨ b) is a clause but not a disjunction of literals with respect to both definitions.\nIn order to show that definition D3b does not satisfy P4, we remark that the negation of the literal 3(a ∨ b) is equivalent to 2(¬a ∧ ¬b) which cannot be expressed as a literal in D3b. For each of the other definitions, it can be shown (by a straightforward inductive proof) that Nnf(¬L) is a literal whenever L is a literal, that Nnf(¬C) is a term whenever\nC is a clause, and that Nnf(¬T ) is a clause whenever T is a term. This is enough to prove that these definitions satisfy P4 since Nnf(ϕ) is equivalent to ϕ.\nSince we know that definitions D1 and D2 satisfy both properties P1 and P2, it follows by Theorem 5 that these definitions do not satisfy P5. We have seen in Lemma 6.1 that definition D5 does satisfy P5, i.e. that every formula is equivalent to some conjunction of clauses with respect to D5 and some disjunction of terms with respect to D5. As every clause (resp. term) of D5 is also a clause (resp. term) with respect to definitionsD3a, D3b, and D4 (by Lemma 6.2), it follows that every formula is equivalent to some conjunction of clauses and some disjunction of terms with respect to these definitions, which means they all satisfy P5.\nIt is easy to see that property P6 is satisfied by all of the definitions since all of our definitions are context-free grammars, and it is well-known that deciding membership for context-free grammars can be accomplished in polynomial time (cf. Younger, 1967).\nFrom Lemma 6.3, we know that deciding entailment between clauses or terms with respect to either D1 or D2 is NP-complete (and hence not in P, unless P=NP). Entailment between clauses/terms is Pspace-complete for D5 (Lemma 6.4). As every clause (resp. term) of D5 is also a clause (resp. term) with respect to definitions D3a, D3b, and D4 (from Lemma 6.2), it follows that entailment between clauses or terms is Pspace-hard for these definitions. Membership in Pspace is immediate since entailment between arbitary K formulae is in Pspace.\nWe prove Theorem 9 in several steps:\nLemma 9.1 The notions of prime implicates and prime implicants induced by D4 satisfy Implicant-Implicate Duality.\nProof. Suppose for a contradiction that we have a prime implicant κ of some formula ϕ which is not equivalent to the negation of a prime implicate of ¬ϕ. Let λ be a clause which is equivalent to ¬κ (there must exist such a clause because of property P4, cf. Theorem 6). The clause λ is an implicate of ¬ϕ since κ |= ϕ and λ ≡ ¬κ. As we have assumed that λ is not a prime implicate, there must be some implicate λ′ of ¬ϕ such that λ′ |= λ and λ 6|= λ′. But then let κ′ be a term equivalent to ¬λ′ (here again we use P4). Now κ′ must be an implicant of ϕ since ¬ϕ |= ¬κ′. Moreover, κ′ is strictly weaker than κ since λ′ |= λ and λ 6|= λ′ and κ ≡ ¬λ and κ′ ≡ ¬λ′. But this means that κ cannot be a prime implicant, contradicting our earlier assumption. Hence, we can conclude that every prime implicant of a formula ϕ is equivalent to the negation of some prime implicate of ¬ϕ. The proof that every prime implicate of a formula ϕ is equivalent to the negation of a prime implicant of ¬ϕ proceeds analogously.\nLemma 9.2 If clauses and terms are defined according to definition D4, then every implicate λ of a formula ϕ is entailed by some implicate λ′ of ϕ with var(λ′) ⊆ var(ϕ) and with depth at most δ(ϕ) + 1, and every implicant κ of ϕ entails an implicant κ′ of ϕ with var(κ′) ⊆ var(ϕ) and depth at most δ(ϕ) + 1.\nProof. We intend to show that the following statement holds: for any formula ϕ and any implicate λ of ϕ, there exists a clause λ′ such that ϕ |= λ′ |= λ and var(λ′) ⊆ var(ϕ) and\nδ(λ) ≤ δ(ϕ) + 1. So let ϕ be an arbitrary formula, and let λ be some implicate of ϕ. If ϕ is a tautology, then we can set λ′ = a ∨ ¬a (where a ∈ var(ϕ)). If λ ≡ ⊥, then we can set λ′ = 3(a ∧ ¬a) (where a ∈ var(ϕ)), as this clause verifies all of the necessary conditions. Now we consider the case where neither ϕ nor λ is a tautology or a falsehood, and we show how to construct the clause λ′. The first thing we do is use Dnf-4 to rewrite ϕ as a disjunction of satisfiable terms Ti with respect to D4 such that the Ti contain only the variables appearing in ϕ and have depth at most δ(ϕ):\nϕ = T1 ∨ ... ∨ Tz\nAs ϕ |= λ, it must be the case that Ti |= λ for every Ti. Our aim is to find a clause λi for each of the terms Ti such that Ti |= λi |= λ and var(λi) ⊆ var(Ti) and δ(λi) ≤ δ(Ti). So consider some Ti. Since Ti is a term, it has the form γ1 ∧ ...∧ γk ∧3ψ1 ∧ ...∧3ψm ∧2χ1 ∧ ...∧2χn, where γ1, ..., γk are propositional literals. As λ is a clause, it must be of the form ρ1 ∨ ... ∨ ρp ∨3ǫ1 ∨ ... ∨3ǫq ∨2ζ1 ∨ ... ∨2ζr, where ρ1, ..., ρp are propositional literals. As Ti |= λ, it must be the case that the formula\nγ1 ∧ ... ∧ γk ∧ 3ψ1 ∧ ... ∧ 3ψm ∧ 2χ1 ∧ ... ∧ 2χn∧ ¬ρ1 ∧ ... ∧ ¬ρp ∧ 2¬ǫ1 ∧ ... ∧ 2¬ǫq ∧ 3¬ζ1 ∧ ... ∧ 3¬ζr\nis unsatisfiable. By Theorem 1, one of the following must hold:\n(a) there exists γu and ρv such that γu ≡ ρv\n(b) there exists ψu such that ψu ∧ χ1 ∧ ... ∧ χn ∧ ¬ǫ1 ∧ ... ∧ ¬ǫq |= ⊥\n(c) there exists ζu such that ¬ζu ∧ χ1 ∧ ... ∧ χn ∧ ¬ǫ1 ∧ ... ∧ ¬ǫq |= ⊥\nNow if (a) holds, we can set λi = γu since Ti |= γu |= λ, δ(γu) = 0 ≤ δ(Ti), and var(γu) ⊆ var(Ti). If it is (b) that holds, then it must be the case that\nψu ∧ χ1 ∧ ... ∧ χn |= ǫ1 ∨ ... ∨ ǫq\nand hence that 3(ψu ∧ χ1 ∧ ... ∧ χn) |= 3ǫ1 ∨ ... ∨ 3ǫq |= λ\nWe can set λi = 3(ψu ∧ χ1 ∧ ... ∧ χn), since Ti |= 3(ψu ∧ χ1 ∧ ... ∧ χn) |= λ, δ(3(ψu ∧ χ1 ∧ ... ∧ χn)) ≤ δ(Ti), and var(3(ψu ∧ χ1 ∧ ... ∧ χn)) ⊆ var(Ti). Finally, if (c) holds, then it must be the case that\nχ1 ∧ ... ∧ χn |= ǫ1 ∨ ... ∨ ǫq ∨ ζu\nand hence that 2(χ1 ∧ ... ∧ χn) |= 3ǫ1 ∨ ... ∨ 3ǫq ∨ 2ζu |= λ\nSo we can set λi = 2(χ1 ∧ ...∧χn), as Ti |= 2(χ1∧ ...∧χn) |= λ, δ(2(χ1 ∧ ...∧χn)) ≤ δ(Ti), and var(2(χ1 ∧ ... ∧ χn)) ⊆ var(Ti). Thus, we have shown that for every Ti, there is some λi such that Ti |= λi |= λ and var(λi) ⊆ var(Ti) and δ(λi) ≤ δ(Ti). But then λ1 ∨ ...∨ λz is a clause implied by every Ti, and hence by ϕ, and such that var(λi) ⊆ ∪ivar(Ti) ⊆ var(ϕ) and δ(λi) ≤ maxi δ(Ti) ≤ δ(ϕ).\nNow let κ be an implicant of ϕ, and let λ be the formula Nnf(¬κ). We know that the NNF transformation is equivalence-preserving, hence λ ≡ ¬κ, and it is straightforward\nto show that λ must be a clause with respect to D4. But then λ is an implicate of ¬ϕ, so there must be some clause λ′ with var(λ′) ⊆ var(¬ϕ) = var(ϕ) and depth at most δ(¬ϕ) + 1 = δ(ϕ) + 1 such that ¬ϕ |= λ′ |= λ. Let κ′ be Nnf(¬λ′). It can be easily verified that κ′ is a term. Moreover, by properties of the NNF transformation, we have κ′ ≡ ¬λ′, var(κ′) = var(¬λ′) = var(λ′), and δ(κ′) = δ(¬λ′) = δ(λ′). But then κ′ is a term such that var(κ′) ⊆ var(ϕ), δ(κ′) ≤ δ(ϕ) + 1, and κ |= κ′ |= ϕ.\nLemma 9.3 The notions of prime implicates and prime implicants induced by D4 satisfy Finiteness.\nProof. Consider an arbitrary formula ϕ. From Lemma 9.2, we know that for each prime implicate λ of ϕ, there must be an implicate λ′ of ϕ containing only those propositional atoms appearing in ϕ and such that δ(λ′) ≤ δ(ϕ) + 1 and λ′ |= λ. But since λ is a prime implicate, we must also have λ |= λ′ and hence λ ≡ λ′. Thus, every prime implicate of ϕ is equivalent to some clause built from the finite set of propositional symbols in ϕ and having depth at most δ(ϕ) + 1. As there are only finitely many non-equivalent formulae on a finite alphabet and with fixed depth, it follows that there can be only finitely many distinct prime implicates. By Lemma 9.1, every prime implicant of ϕ is equivalent to the negation of some prime implicate of ¬ϕ. It follows then that every formula can only have finitely many distinct prime implicants.\nLemma 9.4 The notions of prime implicates and prime implicants induced by D4 satisfy Covering.\nProof. Let ϕ be an arbitrary formula. From Lemma 9.2, we know that every implicate of ϕ is entailed by some implicate of ϕ whose propositional variables are contained in var(ϕ) and whose depth is at most δ(ϕ) + 1. Now consider the following set\nΣ = {σ |ϕ |= σ, σ is a clause, var(σ) ⊆ var(ϕ), δ(σ) ≤ δ(ϕ) + 1}\nand define another set Π from Σ as follows:\nΠ = {σ ∈ Σ | 6 ∃σ′ ∈ Σ. σ′ |= σ and σ 6|= σ′}\nIn other words, Π is the set of all of the logically strongest implicates of ϕ having depth at most δ(ϕ) + 1 and built from the propositional letters in ϕ. We claim the following:\n(1) every π ∈ Π is a prime implicate of ϕ\n(2) for every implicate λ of ϕ, there is some π ∈ Π such that π |= λ\nWe begin by proving (1). Suppose that (1) does not hold, that is, that there is some π ∈ Π which is not a prime implicate of ϕ. Since π is by definition an implicate of ϕ, it follows that there must be some implicate λ of ϕ such that λ |= π and π 6|= λ. But by Lemma 9.2, there is some implicate λ′ of ϕ such that δ(λ′) ≤ δ(ϕ) + 1, var(λ′) ⊆ var(ϕ), and λ′ |= λ. But that means that λ′ is an element of Σ which implies but is not implied by π, contradicting the assumption that π is in Π. We can thus conclude that every element of Π must be a prime implicate of ϕ.\nFor (2): let λ be some implicate of ϕ. Then by Lemma 9.2, there exists some clause λ′ ∈ Σ such that λ′ |= λ. If λ′ ∈ Π, we are done. Otherwise, there must exist some σ ∈ Σ such that σ |= λ′ and λ′ 6|= σ. If σ ∈ Π, we are done, otherwise, we find another stronger member of Σ. But as Σ has finitely many elements modulo equivalence, after a finite number of steps, we will find some element which is in Π and which implies λ. Since we have just seen that all members of Π are prime implicates of ϕ, it follows that every implicate of ϕ is implied by some prime implicate of ϕ.\nFor the second part of Covering, let κ be an implicant of ϕ, and let λ be a clause equivalent to ¬κ (there must be one because D4 satisfies P4). Now since κ |= ϕ, we must also have ¬ϕ |= λ. According to what we have just shown, there must be some prime implicate π of ¬ϕ such that ¬ϕ |= π |= λ. By Lemma 9.1, π must be equivalent to the negation of some prime implicant ρ of ϕ. But since ρ ≡ ¬π and π |= λ and λ ≡ ¬κ, it follows that κ |= ρ, completing the proof.\nLemma 9.5 The notions of prime implicates and prime implicants induced by D4 satisfy Equivalence.\nProof. Let ϕ be some formula in K, and suppose that M is a model of every prime implicate of ϕ. As D4 is known to satisfy property P5 (by Theorem 6), we can find a conjunction of clauses which is equivalent to ϕ. By Covering (Lemma 9.3), each of these clauses is implied by some prime implicate of ϕ, so M must be a model of each of these clauses. It follows that M is a model of ϕ. For the other direction, we simply note that by the definition of prime implicates if M is a model of ϕ, then it must also be a model of every prime implicate of ϕ. We have thus shown that M is a model of ϕ if and only if it is a model of every prime implicate of ϕ. Using a similar argument, we can show that M is a model of ϕ if and only if it is a model of some prime implicant of ϕ.\nLemma 9.6 The notions of prime implicates and prime implicants induced by D4 satisfy Distribution.\nProof. Let λ be a prime implicate of ϕ1 ∨ ... ∨ ϕn. Now for each ϕi, we must have ϕi |= λ. From Covering, we know that there must exist some prime implicate λi for each ϕi such that λi |= λ. This means that the formula λ1 ∨ ... ∨ λn (which is a clause because it is a disjunction of clauses) entails λ. But since λ is a prime implicate, it must also be the case that λ |= λ1∨ ...∨λn, and hence λ ≡ λ1∨ ...∨λn. The proof for prime implicants is entirely similar.\nTheorem 9 The notions of prime implicates and prime implicants induced by definition D4 satisfy Finiteness, Covering, Equivalence, Implicant-Implicate Duality, and Distribution.\nProof. Follows directly from Lemmas 9.1-9.6.\nTheorem 10 The notions of prime implicates and prime implicants induced by definitions D1 and D2 do not satisfy Equivalence.\nProof. The proof is the same for both definitions. Suppose that Equivalence holds. Then for every formula ϕ, the set Π of prime implicates of ϕ is equivalent to ϕ. But this means that the set Π∪ {¬ϕ} is inconsistent, and hence by compactness of K (cf. Blackburn et al., 2001, p. 86) that there is some finite subset S ⊆ Π ∪ {¬ϕ} which is inconsistent. If ϕ 6≡ ⊥, then we know that the set S must contain ¬ϕ because the set of prime implicates of ϕ cannot be inconsistent. But then the conjunction of elements in S \\ {¬ϕ} is a conjunction of clauses which is equivalent to ϕ. It follows that every formula ϕ is equivalent to some conjunction of clauses. As we have shown earlier in the proof of Theorem 5 that there are formulae which are not equivalent to a conjunction of clauses with respect to D1 or D2, it follows that Equivalence cannot hold for these definitions.\nTheorem 11 The notions of prime implicates and prime implicants induced by definitions D3a, D3b, and D5 do not satisfy Finiteness.\nProof. Suppose that clauses are defined with respect to definition D3a, D3b, or D5 (the proof is the same for all three definitions). Consider the formula ϕ = 2(a ∧ b). It follows from Theorem 3 that ϕ implies λk = 2(3\nka) ∨ 3(a ∧ b ∧ 2k¬a) for every k ≥ 1. As the formulae λk are clauses (with respect to D3a, D3b, and D5), the λk are all implicates of ϕ. To complete the proof, we show that every λk is a prime implicate of ϕ. Since the λk are mutually non-equivalent (because 2p¬a 6|= 2q¬a whenever p 6= q), it follows that ϕ has infinitely many prime implicates modulo equivalence.\nConsider some λk and some implicate µ = 3ψ1 ∨ ... ∨ 3ψm ∨ 2χ1 ∨ ... ∨ 2χn of ϕ that implies it (by Theorem 2 there cannot be any propositional literals in µ). Using Theorem 3 and the fact that ϕ |= µ |= λk, we get the following:\n(a) a ∧ b |= χi ∨ ψi ∨ ... ∨ ψm for some χi\n(b) χi |= (3 ka) ∨ (a ∧ b ∧ 2k¬a) for every χi\n(c) ψ1 ∨ ... ∨ ψm |= a ∧ b ∧ 2 k¬a\nLet χi be such that a ∧ b |= χi ∨ ψi ∨ ... ∨ ψm. We remark that χi must be satisfiable since otherwise we can combine (a) and (c) to get a∧b |= a∧b∧2k¬a. Now by (b), we know that χi |= (3 ka)∨ (a∧ b∧2k¬a) and hence that χi∧ (2 k¬a)∧ (¬a∨¬b∨3ka) is inconsistent. It follows that both χi∧ (2 k¬a)∧¬a and χi∧ (2\nk¬a)∧¬b are inconsistent. Using Theorem 1, we find that either χi |= 3\nka or χi |= a ∧ b. As χi is a satisfiable clause with respect to definitions D3a, D3b, and D5, it cannot imply a ∧ b, so we must have χi |= 3\nka. By putting (a) and (c) together, we find that\na ∧ b ∧ ¬χi |= ψ1 ∨ ... ∨ ψm |= a ∧ b ∧ 2 k¬a\nIt follows that ¬χi |= 2 k¬a, i.e. 3ka |= χi. We thus have χi ≡ 3 ka and ψ1 ∨ ... ∨ ψm ≡ a ∧ b ∧ 2k¬a. As 3ka |= χi and a ∧ b ∧ 2\nk¬a |= ψ1 ∨ ... ∨ ψm, by Theorem 3 we get 2(3ka) ∨ 3(a ∧ b ∧ 2k¬a) |= 2χi ∨ 3ψi ∨ ... ∨ 3ψm |= µ and hence λk ≡ µ. We have thus shown that any implicate of ϕ which implies λk must be equivalent to λk. This means that each λk is a prime implicate of ϕ, completing the proof.\nLemmas 12, 13, and 14 follow easily from known properties of the disjunctive normal form transformation in propositional logic (cf. Bienvenu, 2009, ch. 2).\nIn the proof of Theorem 16, we will make use of the following lemmas:\nLemma 16.1 The algorithm GenPI always terminates.\nProof. We know from Lemma 12 that the algorithm Dnf-4 always terminates and returns a finite set of formulae. This means that there are only finitely many terms T to consider. For each T , the set ∆(T ) contains only finitely many elements (this is immediate given the definition of ∆(T )), which means that the set Candidates also has finite cardinality. In the final step, we compare at most once each pair of elements in Candidates. As the comparison always terminates, and there are only finitely many pairs to check, it follows that the algorithm GenPI terminates.\nLemma 16.2 The algorithm GenPI outputs exactly the set of prime implicates of the input formula.\nProof. We first prove that every prime implicate of a satisfiable term T is equivalent to some element in ∆(T ). Let T = γ1 ∧ ... ∧ γk ∧ 3ψ1 ∧ ... ∧ 3ψm ∧ 2χ1 ∧ ... ∧ 2χn be some satisfiable term, and let λ = ρ1 ∨ ... ∨ ρp ∨ 3ǫ1 ∨ ... ∨ 3ǫq ∨ 2ζ1 ∨ ... ∨ 2ζr be one of its prime implicates. We restrict our attention to the interesting case in which both T and λ are non-tautologous. As T |= λ, it must be the case that\nγ1 ∧ ... ∧ γk ∧ 3ψ1 ∧ ... ∧ 3ψm ∧ 2χ1 ∧ ... ∧ 2χn∧ ¬ρ1 ∧ ... ∧ ¬ρp ∧ 2¬ǫ1 ∧ ... ∧ 2¬ǫq ∧ 3¬ζ1 ∧ ... ∧ 3¬ζr\nis unsatisfiable. By Theorem 1, one of the following must hold:\n(a) there exists γu and ρv such that γu ≡ ρv\n(b) there exists ψu such that ψu ∧ χ1 ∧ ... ∧ χn |= ǫ1 ∨ ... ∨ ǫq\n(c) there exists ζu such that χ1 ∧ ... ∧ χn |= ζu ∨ ǫ1 ∨ ... ∨ ǫq\nIf (a) holds, then γu |= λ, so λ must be equivalent to γu or else we would have found a stronger implicate, contradicting our assumption that λ is a prime implicate of T . But then the result holds since γu is in ∆(T ). If (b) holds, then the formula 3(ψu ∧ χ1 ∧ ... ∧ χn) is an implicate of T which implies λ, so λ ≡ 3(ψu ∧ χ1 ∧ ... ∧ χn). We are done since 3(ψu ∧χ1 ∧ ...∧χr) is a member of ∆(T ). Finally we consider the case where (c) holds. In this case, 2(χ1 ∧ ...∧χn) is an implicate of T which implies λ, and so is equivalent to λ (as λ is a prime implicate). But then we have the desired result since 2(χ1 ∧ ... ∧ χn) is one of the elements in ∆(T ). Thus we can conclude that every prime implicate of a term T is equivalent to some element in ∆(T ). By Lemma 13, the elements in Dnf-4(ϕ) are terms, and their disjunction is equivalent to ϕ. As D4 satisfies Distribution, it follows that every prime implicate of the input ϕ is equivalent to some element in Candidates. This means that if an element λi in Candidates is not a prime implicate of ϕ, then there is some prime implicate π of ϕ that implies but is not implied by λi, and hence some λj ∈ Candidates such that λj |= λi and λi 6|= λj. Thus, during the comparison phase, this clause will be removed from Candidates. Now suppose that the clause λ is a prime implicate of ϕ. Then\nwe know that there must be some λi ∈ Candidates such that λi ≡ λ, and moreover, we can choose λi so that there is no λj with j < i such that λj |= λi. When in the final step we compare λi with all the clauses λj with j 6= i, we will never find that λj |= λi for j < i, nor that λj |= λi 6|= λj for some j > i, otherwise λ would not be a prime implicate. It follows then that λi remains in the set Candidates which is returned by the algorithm. We have thus shown that the set of formulae output by GenPI on input ϕ is precisely the set of prime implicates of ϕ.\nTheorem 16 The algorithm GenPI always terminates and outputs exactly the set of prime implicates of the input formula.\nProof. Follows directly from Lemmas 16.1 and 16.2.\nTheorem 17 The length of the smallest clausal representation of a prime implicate of a formula is at most single exponential in the length of the formula.\nProof. Prime implicates generated by GenPI can have at most 2|ϕ| disjuncts as there are at most 2|ϕ| terms in Dnf-4(ϕ) by Lemma 14. Moreover, each disjunct has length at most 2|ϕ| (also by Lemma 14). This gives us a total of 2|ϕ| ∗ 2|ϕ| symbols, to which we must add the at most 2|ϕ| − 1 disjunction symbols connecting the disjuncts. We thus find that the length of the smallest representation of a prime implicate of a formula ϕ is at most 2|ϕ| ∗ 2|ϕ| + (2|ϕ| − 1).\nTheorem 18 The length of the smallest clausal representation of a prime implicate of a formula can be exponential in the length of the formula.\nProof. Consider the formula\nϕ =\nn∧\ni=1\n(2ai,1 ∨ 2ai,2)\nand the clause\nλ = ∨\n(j1,...,jn)∈{1,2}n\n2(a1,j1 ∧ a2,j2 ∧ ... ∧ an,jn)\nwhere ak,l 6= am,p whenever k 6= m or l 6= p. It is not difficult to see that ϕ and λ are equivalent, which means that λ must be a prime implicate of ϕ. All that remains to be shown is that any clause equivalent to λ must have length at least |λ|. This yields the result since λ clearly has size exponential in n, whereas the length of ϕ is only linear in n.\nLet λ′ be a shortest clause which is equivalent to λ. As λ′ is equivalent to λ, it follows from Theorem 2 that λ′ is a disjunction of 2-literals and of inconsistent 3-literals. But since λ′ is assumed to be a shortest representation of λ, it cannot contain any inconsistent 3-literals or any redundant 2-literals, since we could remove them to find an equivalent shorter clause. So λ′ must be of the form 2χ1 ∨ ... ∨ 2χm, where χl 6|= χk whenever l 6= k. Now since λ′ |= λ, every disjunct 2χp must also imply λ. As λ is a disjunction of 2-literals, it follows from Theorem 3 that every disjunct 2χp of λ\n′ implies some disjunct 2δq of λ. But that means that every 2χp must have length at least 2n + 1, since each χp is a satisfiable formula which implies a conjunction of n distinct propositional variables. We also know that every disjunct 2δq of λ implies some disjunct 2χp of λ ′ since λ |= λ′. We now wish\nto show that no two disjuncts of λ imply the same disjunct of λ′. Suppose that this is not the case, that is, that there are distinct disjuncts 2δ1 and 2δ2 of λ and some disjunct 2χp of λ′ such that 2δ1 |= 2χp and 2δ2 |= 2χp. Now since 2δ1 and 2δ2 are distinct disjuncts, there must be some i such that 2δ1 |= ai,1 and 2δ2 |= ai,2 or 2δ1 |= ai,2 and 2δ2 |= ai,1. We know that 2χp |= 2δq for some δq, and that every δq implies either ai1 or ai2, so either 2χp |= 2ai1 or 2χp |= 2ai2. But we know that the 2δq each imply either 2ai,1 or 2ai,2 but not both, so one of 2δ1 and 2δ2 must not imply 2χp. This contradicts our earlier assumption that 2δ1 |= 2χp and 2δ2 |= 2χp, so each disjunct of λ must imply a distinct disjunct of λ′. We have thus demonstrated that λ′ contains just as many disjuncts as λ. As we have already shown that the disjuncts of λ′ are no shorter than the disjuncts of λ, it follows that |λ′| ≥ |λ|, and hence |λ′| = |λ|. We conclude that every clause equivalent to λ has length at least |λ|, completing the proof.\nFor Theorem 19, we will prove that the following clause\nλ = ∨\n(q1,...,qn)∈{3,2}n\n2q1...qn c\nis a prime implicate (with respect to both D1 and D2) of the formula\nϕ = (23(b0 ∧ b1) ∨ 22(b0 ∧ b1) ) ∧ n∧\ni=2\n(2i3bi ∨ 2 i 2bi )\n∧ n−1∧\ni=1\n2 i+1 ( (bi−1 ∧ bi) → 2bi ) ∧ 2 n+1 ( (bn−1 ∧ bn) → c )\nand moreover that there is no shorter way to represent λ.\nThe proof of Theorem 19 makes use of the following lemmas.\nLemma 19.1 Let l1 ∨ ...∨ lm be a D1-clause which implies q1...qna, where qi ∈ {2,3} and a is a propositional variable. Then l1 ∨ ... ∨ lm ≡ q1...qna.\nProof. In the proof, we will make use of the fact that every D1-clause is satisfiable. This is very straightforwardly shown by structural induction. The base case is propositional literals, which are clearly satisfiable. For the induction step, we consider a D1-clause λ such that all its proper sub-clauses are satisfiable. There are three possibilities: either λ is of the form 2ψ or 3ψ where ψ is a satisfiable D1-clause, or a disjunction ψ1 ∨ ψ2 of satisfiable D1-clauses ψ1 and ψ2. In all three cases, we find that λ must also be satisfiable.\nThe proof of the lemma is by induction on n. When n = 0, we have just l1∨ ...∨ lm |= a. According to Theorem 2, every disjunct of l1∨ ...∨ lm must be either a or some unsatisfiable formula. But we have shown in the previous paragraph that every D1-clause is satisfiable, so l1 ∨ ... ∨ lm ≡ a.\nNow suppose the result holds whenever n ≤ k, and suppose that we have l1 ∨ ... ∨ lm |= q1...qk+1a. For every li, we must have li |= q1...qk+1a, and hence |= ¬li ∨ q1...qk+1a. Using Theorem 1, we arrive at the following four possibilities:\n(a) |= q1...qk+1a\n(b) li ≡ ⊥\n(c) q1 = 3 and li ≡ 3l ′ i and l ′ i |= q2...qk+1a\n(d) q1 = 2 and li ≡ 2l ′ i and l ′ i |= q2...qk+1a\nWe can eliminate case (a) since 6|= q1...qk+1a for every string of modalities q1...qk+1. We can also eliminate (b) since all of the li must be satisfiable as they are D1-clauses. We remark that if (c) holds, then according to the induction hypothesis, li ≡ 3q2...qk+1a. Similarly, if (d) holds, then li ≡ 2q2...qk+1a. It follows then that each li is equivalent to q1...qk+1a, and so l1 ∨ ... ∨ lm ≡ q1...qk+1a.\nLemma 19.2 Fix (q1, ..., qn) ∈ {2,3} n, and let T = 2q1(b0 ∧ b1) ∧ ( ∧n k=2 2\nkqkbk) ∧∧n−1 k=1 2 k+1 ( (bk−1 ∧ bk) → 2bk ) ∧ 2 n+1 ( (bn−1 ∧ bn) → c ). Then T |= 2r1...rnc if and only if rk = qk for all 1 ≤ k ≤ n.\nProof. We begin by showing that for all 1 ≤ i ≤ n− 1 the formula\nbi−1 ∧ bi ∧ ( n∧\nk=i+1\n2 k−i−1qkbk ) ∧ (\nn−1∧\nk=i\n2 k−i((bk−1 ∧ bk) → 2 bk) ) ∧ 2 n−i((bn−1 ∧ bn) → c)\nentails the formula ri+1...rnc just in the case that qi+1...qn = ri+1...rn.\nThe proof is by induction on i. The base case is i = n− 1. We have\nbn−2 ∧ bn−1 ∧ qnbn ∧ ((bn−2 ∧ bn−1) → 2bn−1) ∧ 2((bn−1 ∧ bn) → c) |= rnc (1)\nif and only if\nbn−2 ∧ bn−1 ∧ qnbn ∧ 2bn−1 ∧ 2((bn−1 ∧ bn) → c) |= rnc\nif and only if (Theorem 1) either\nqn = 3 and rn = 2 and bn−1 ∧ ((bn−1 ∧ bn) → c) |= c\nor\nqn = rn and bn−1 ∧ bn ∧ ((bn−1 ∧ bn) → c) |= c\nAs bn−1 ∧ ((bn−1 ∧ bn) → c) 6|= c, we cannot have the first alternative. It follows then that if Equation (1) holds, then the second alternative must hold, in which case we get qn = rn, as desired. For the other direction, we simply note that bn−1 ∧ bn ∧ ((bn−1 ∧ bn) → c) |= c is a valid entailment, which means qn = rn implies Equation (1).\nNext let us suppose that the above statement holds for all 1 < j ≤ i ≤ n− 1, and let us prove the statement holds when i = j − 1. Then\nbj−2 ∧ bj−1 ∧ ( n∧\nk=j\n2 k−jqk bk) ∧ (\nn−1∧\nk=j−1\n2 k−j+1(bk−1 ∧ bk → 2bk) )\n∧ 2n−j+1((bn−1 ∧ bn) → c) |= rj ...rnc (2)\nif and only if one of the following holds:\n(a) qj = 3 and rj = 2 and\nbj−1 ∧ ( n∧\nk=j+1\n2 k−j−1qk bk) ∧ (\nn−1∧\nk=j\n2 k−j((bk−1 ∧ bk) → 2bk) ) ∧ 2 n−j((bn−1 ∧ bn) → c)\n|= rj+1...rnc\n(b) qj = rj and\nbj−1 ∧ bj ∧ ( n∧\nk=j+1\n2 k−j−1qkbk) ∧ (\nn−1∧\nk=j\n2 k−j((bk−1 ∧ bk) → 2bk)) ∧ 2 n−j((bn−1 ∧ bn) → c)\n|= rj+1...rnc\nWe will first show that the entailment in (a) does not hold. Consider the model M = 〈W,R, v〉 defined as follows:\n• W = {wj , ..., wn}\n• R = {(wj , wj+1), ..., (wn−1, wn)}\n• v(c, w) = false for all w ∈ W\n• for w 6= wj : v(bk, w) = true if and only if w = wk\n• v(bk, wj) = true if and only if k = j − 1\nNotice that since each world (excepting wn) has exactly one successor, the 2- and 3- quantifiers have the same behaviour (except at wn). It can easily be verified that M, wj satisfies the left-hand side of the above entailment for any tuple qj+1...qn: we have M, wj |= bj−1 by definition, we have M, wj |= ∧n k=j+1 2 k−j−1qk bk because M, wk |= bk for k 6= j, we have M, wj |= ∧n−1 k=j 2 k−j((bk−1 ∧ bk) → 2bk) ) since M, wj 6|= bj and M, wk 6|= bk−1 for k 6= j, and finally we have M, wj |= 2 n−j((bn−1 ∧ bn) → c) since wn 6|= bn−1. However, the right-hand side rj+1...rnc is not satisfied at wj: the only world accessible from wj in n− j steps is wn which does not satisfy c.\nWe have just shown that case (a) cannot hold, which means that Equation (2) holds if and only if (b) does. But if we apply the induction hypothesis to the entailment in (b), we find that it holds just in the case that qj+1...qn = rj+1...rn. It follows then that Equation (2) if and only if qj...qn = rj...rn, as desired. This completes our proof of the above statement.\nWe now proceed to the proof of the lemma. By Theorem 1,\n2q1(b0 ∧ b1) ∧ ( n∧\nk=2\n2 kqkbk) ∧ (\nn−1∧\nk=1\n2 k+1 ( (bk−1 ∧ bk) → 2bk ) ∧ 2 n+1 ( (bn−1 ∧ bn) → c )\n|= 2r1...rnc\nholds just in the case that\nq1(b0 ∧ b1) ∧ ( n∧\nk=2\n2 k−1qkbk) ∧\nn−1∧\nk=1\n2 k ( (bk−1 ∧ bk) → 2bk ) ∧ 2 n ( (bn−1 ∧ bn) → c )\n|= r1...rnc\nwhich in turn holds if and only if one of the following statements holds:\n(i) q1 = 3 and r1 = 2 and\n(\nn∧\nk=2\n2 k−2qkbk ) ∧ (\nn−1∧\nk=1\n2 k−1((bk−1 ∧ bk) → 2bk) ) ∧ 2 n−1((bn−1 ∧ bn) → c) |= r2...rnc\n(ii) q1 = r1 and\nb0 ∧ b1 ∧ ( n∧\nk=2\n2 k−2qkbk ) ∧ (\nn−1∧\nk=1\n2 k−1((bk−1 ∧ bk) → 2bk) ) ∧ 2 n−1((bn−1 ∧ bn) → c)\n|= r2...rnc\nWe remark that if we set j = 1 in (a) above, then the left-hand side of the entailment in (i) is logically weaker than that in (a), and the right-hand side matches that in (a). As we have already shown that the entailment in (a) does not hold, it follows that the entailment in (i) cannot hold either. Thus, we find that the desired entailment relation in the statement of the lemma holds if and only if (ii) does. This completes the proof since we have already shown in the induction above that the entailment in (ii) holds if and only if q2...qn = r2...rn, i.e. (ii) is true just in the case that q1...qn = r1 = rn.\nLemma 19.3 There is no D1-clause equivalent to λ and with strictly smaller size than λ.\nProof. Let λ′ be a D1-clause which is equivalent to λ. Suppose furthermore that λ′ is a shortest such clause. As λ is non-tautologous and contains only 2-literals as disjuncts, it follows that every disjunct of λ′ must be either unsatisfiable or a 2-literal (cf. Theorem 2). But D1-clauses are always satisfiable (cf. proof of Lemma 19.1), so λ′ must contain only 2-literals.\nSince λ′ |= λ, every disjunct 2l of λ′ must imply some disjunct 2q1...qnc of λ. Also, every disjunct 2l of λ′ must be implied by some disjunct 2q1...qnc of λ, since otherwise we could remove 2l from λ′ while preserving the equivalence between λ and λ′.\nIt follows then that each disjunct of λ′ is implied by some disjunct of λ and implies some disjunct of λ. But since the disjuncts of λ do not imply each other (because of Lemma 19.1), it follows that each disjunct of λ′ is equivalent to some disjunct of λ, and moreover that every disjunct of λ is equivalent to some disjunct of λ′.\nThis completes the proof since it is clear that the disjuncts 2q1...qnc of λ cannot be more compactly represented.\nOur proof works equally well for D2, since every D2-clause is also a D1-clause.\nTheorem 19 If prime implicates are defined using either D1 or D2, then the length of the smallest clausal representation of a prime implicate of a formula can be exponential in the length of the formula.\nProof. We begin with definition D1. Let λ and ϕ be as defined on page 112. We begin by distributing ∨ over ∧ in order to transform ϕ into an equivalent disjunction of D4-terms:\nϕ ≡ ∨\n(q1,...,qn)∈{2,3}n\nTq1,...,qn\nwhere Tq1,...,qn is equal to\n2q1(b0 ∧ b1) ∧ ( n∧\ni=2\n2 iqibi) ∧\nn−1∧\ni=1\n2 i+1 ( (bi−1 ∧ bi) → 2bi ) ∧ 2 n+1 ( (bn−1 ∧ bn) → c )\nBy Lemma 19.2, Tq1,...,qn |= 2q1...qnc, and hence Tq1,...,qn |= λ. We thus have ϕ |= λ. We now show that there is no stronger clause with respect to D1 which is implied by ϕ. Let λ′ be a D1-clause such that ϕ |= λ′ |= λ. As λ is a non-tautologous disjunction of 2-literals, we know from Lemma 2 that every disjunct of λ′ must be of the form 2l where l is a D1-clause such that l |= r1...rnc for some quantifier string r1...rn. But according to Lemma 19.1, if l |= r1...rnc, then l is equivalent to r1...rnc. It follows that λ\n′ is equivalent to a clause having only disjuncts of the forms 2r1...rnc.\nAs ϕ |= λ′, it must be the case that each of the terms Tq1,...,qn implies λ ′, or equivalently Tq1,...,qn ∧ ¬λ ′ |= ⊥. As we have shown above that the disjuncts of λ′ are all 2-literals, it follows from Theorem 1 that each term implies some disjunct of λ′. Moreover, we know from the preceding paragraph that each of the disjuncts of λ′ is equivalent to some formula of the form 2r1...rnc. By Lemma 19.2, the only formula of this type which is implied by Tq1,...,qn is the formula 2q1...qnc. This means that for every tuple of quantifiers (q1, ..., qn), there is a disjunct of λ′ which is equivalent to 2q1...qnc. It follows that every disjunct of λ is equivalent to some disjunct of λ′, giving us λ |= λ′. We can thus conclude that λ is a prime implicate of ϕ.\nThis completes the proof, since we have already shown in Lemma 19.3 that there is no shorter D1-clause which is equivalent to λ than λ itself.\nThe above proof also works for definition D2 since every D2-clause is also a D1-clause. In particular this means that any D2-clause which is a prime implicate with respect to D1 is also a prime implicate with respect to D2, and that any D2-clause which is shortest among all equivalent D1-clauses is also shortest among D2-clauses.\nTheorem 20 The number of non-equivalent prime implicates of a formula is at most double exponential in the length of the formula.\nProof. We know from Theorem 16 that every prime implicate of ϕ is equivalent to some clause returned by GenPI. Every such clause is of the form ∨\nT∈Dnf-4(ϕ) θT where θT ∈\n∆(T ). As there can be at most 2|ϕ| terms in Dnf-4(ϕ) by Lemma 14, these clauses can have no more than 2|ϕ| disjuncts. Moreover, there are at most 2|ϕ| choices for each disjunct θT since the cardinality of ∆(T ) is bounded above by the size of T , which we know from Lemma 1.3 to be no more than 2|ϕ|. It follows then that there are at most (2|ϕ|)2 |ϕ| clauses returned by GenPI, hence at most (2|ϕ|)2 |ϕ| non-equivalent prime implicates of ϕ.\nTheorem 21 The number of non-equivalent prime implicates of a formula may be double exponential in the length of the formula.\nProof. Let n be some natural number, and let a11, a12, ..., an1, an2, b11, b12, b12, ..., bn1, bn2 be 4n distinct propositional variables. Consider the formula ϕ defined as\nn∧\ni=1\n((3ai1 ∧ 2bi1) ∨ (3ai2 ∧ 2bi2))\nIt is not hard to see that there will be 2n terms in Dnf-4(ϕ), corresponding to the 2n ways of deciding for each i ∈ {1, ..., n} whether to take the first or second disjunct. Each term T ∈ Dnf-4(ϕ) will be of the form\nn∧\ni=1\n(3ai f(i,T ) ∧ 2bi f(i,T ))\nwhere f(i, T ) ∈ {1, 2} for all i. For each T , denote by D(T ) the set of formulae {3(a f(i,T )∧ b1 f(1,T ) ∧ ... ∧ bnf(n,T ))) | 1 ≤ i ≤ n}. Now consider the set of clauses C defined as\n{ ∨\nT∈Dnf-4(ϕ)\ndT | dT ∈ D(T )}\nNotice that there are n2 n clauses in C since each clause corresponds to a choice of one of the n elements in D(T ) for each of the 2n terms T in Dnf-4(ϕ). This number is double exponential in |ϕ| since the length of ϕ is linear in n. In order to complete the proof, we show that (i) all of the clauses in C are prime implicates of ϕ and (ii) that the clauses in C are mutually non-equivalent.\nWe begin by showing that λ1 6|= λ2 for every pair of distinct elements λ1 and λ2 in C. This immediately gives us (ii) and will prove useful in the proof of (i). Let λ1 and λ2 be distinct clauses in C. As λ1 and λ2 are distinct, there must be some term T ∈ Dnf-4(ϕ) for which λ1 and λ2 choose different elements from D(T ). Let d1 be the element from D(T ) appearing as a disjunct in λ1, let d2 be the element in D(T ) which is a disjunct in λ2, and let aj,k be the a-literal which appears in d2 (and hence not in d1). Consider the formula ρ = 2(¬aj,k ∧¬b1,k1 ∧ ...∧¬bn,kn), where the tuple (k1, ..., kn) is just like the tuple associated with T except that the 1’s and 2’s are inversed. Clearly d1 ∧ ρ is consistent, since the variables in ρ do not appear in d1. But ρ is inconsistent with every disjunct in λ2, since by construction every disjunct in λ2 contains a literal whose negation appears in ρ. It follows that λ2 |= ¬ρ but λ1 6|= ¬ρ, and hence λ1 6|= λ2.\nWe now prove (i). Let λ be a clause in C, and let π be a prime implicate of ϕ which implies λ. By Theorem 16, we know that π must be equivalent to one of the clauses output by GenPI, and more specifically to a clause output by GenPI which is a disjunction of 3-literals (because of Theorem 2). We remark that the set C is composed of exactly those candidate clauses which are disjunctions of 3-literals, so π must be equivalent to some clause in C. But we have just shown that the only element in C which implies λ is λ itself. It follows that π ≡ λ, which means that λ is a prime implicate of ϕ.\nTheorem 22 If prime implicates are defined using either D1 or D2, then the number of non-equivalent prime implicates of a formula may be double exponential in the length of the formula.\nProof. Let λ and ϕ be as defined on page 112. Set ϕ′ equal to the formula obtained from ϕ by replacing c in the last conjunct of ϕ by c ∧ d. Set Σ equal to the set of clauses that can be obtained from λ by replacing zero or more occurrences of c by d. For example, if n = 1, then Σ = {23c ∨ 22c,23d ∨ 22c,23c ∨ 22d,23d ∨ 22d}. There are 22 n elements in Σ since we choose for each of the 2n disjuncts of λ whether to change c into d. We intend\nto show that the clauses in Σ are all pairwise non-equivalent prime implicates of ϕ′. The proof that every element in Σ is indeed a prime implicate of ϕ′ (with respect to both D1 and D2) proceeds quite similarly to the proof that λ is a prime implicate of ϕ (see proof of Theorem 19), so we will not repeat it here. Instead we will show that all of the elements in Σ are pairwise non-equivalent. To do so, we consider any two distinct elements α and β of Σ. Since α and β are distinct, there must be some string of quantifiers q1...qn such that α has a disjunct 2q1...qnγ (γ ∈ {c, d}) which is not a disjunct of β. Now if α |= β, then we would have 2q1...qnγ |= β, and hence 2q1...qnγ |= 2r1...rnζ for some disjunct r1...rnζ of β. But by using Lemma 19.1, we see that this can only happen if r1...rn = q1...qn and γ = ζ , i.e. if 2q1...qn is a disjunct of β. This is a contradiction, so we must have α 6|= β. It follows that the elements of Σ are pairwise non-equivalent, and hence that ϕ′ possesses a double exponential number of prime implicates.\nTheorem 23 There exists an algorithm which runs in single-exponential space in the size of the input and incrementally outputs, without duplicates, the set of prime implicates of the input formula.\nProof. Let the sets T and Candidates and the function ∆ be defined as in Figure 3. We assume that T is ordered: T = {T1, ..., Tn}. For each Ti ∈ T , we let max i denote the number of elements in ∆(Ti), and we assume an ordering on the elements of ∆(Ti): ∆(Ti) = {τi,1, ..., τi,max i}. Notice that the tuples in {1, ..,max 1}× ...×{1, ...,max n} can be ordered using the standard lexicographic ordering <lex: (a1, ..., an) <lex (b1, ..., bn) if and only if there is some 1 ≤ j ≤ n such that aj < bj and ak ≤ bk for all 1 ≤ k ≤ j − 1. Now set maxindex = Πni=1maxi, and let f : {1, ..,max 1}× ...×{1, ...,maxn} → {1, ...,maxindex } be the bijection defined as follows: f(a1, ..., an) = m if and only if (a1, ..., an) is the m-th tuple in the lexicographic ordering of {1, ..,max 1} × ... × {1, ...,max n}. We will denote by λm the unique clause of form τ1,a1 ∨ ... ∨ τn,an such that f(a1, ..., an) = m. We remark that given an index m ∈ {1, ...,maxindex } and the sets ∆(T1), ..., ∆(Tn), it is possible to generate in polynomial space (in the size of the sets ∆(T1), ..., ∆(Tn)) the clause λm. We make use of this fact in our modified version of algorithm GenPI, which is defined as follows:\nFunction IterGenPI(ϕ) (1) Same as in GenPI. (2) Same as in GenPI. (3) For i = 1 to maxindex : if λj 6|= λi for all j < i and either λj 6|= λi or λi |= λj\nfor every i < j ≤ maxindex , then output λi.\nThe proofs of termination, correctness, and completeness of IterGenPI are very similar to corresponding results for GenPI (Theorem 16), so we will omit the details. We will instead focus on the spatial complexity of IterGenPI. The first step of IterGenPI clearly runs in single-exponential space in |ϕ|, since deciding the satisfiability of ϕ takes only polynomial space in |ϕ|, and generating the elements in Dnf-4(ϕ) takes at most single-exponential space in |ϕ| (refer to Lemma 14). Step 2 also uses no more than singleexponential space in |ϕ|, since each of the sets ∆(T ) associated with a term Ti ∈ T has polynomial size in Ti. Finally, for Step 3, we use the above observation that the generation of a given λi from its index i can be done in polynomial space in the size of the sets\n∆(T1), ..., ∆(Tn), and hence in single-exponential space in |ϕ|. This is sufficient since for the comparisons in Step 3, we only need to keep two candidate clauses in memory at any one time, and deciding whether one candidate clause entails another can be accomplished in single-exponential space (since both clauses have single-exponential size in |ϕ|).\nTheorem 24 Prime implicate recognition is Pspace-hard.\nProof. The reduction is simple: a formula ϕ is unsatisfiable if and only if 3(a ∧ ¬a) is a prime implicate of ϕ. This suffices as the problem of checking the unsatisfiability of formulae in K is known to be Pspace-complete.\nWe will need the following two lemmas for Theorem 25:\nLemma 25.1 Let ϕ be a formula from K, and let λ = γ1 ∨ ... ∨ γk ∨ 3ψ1 ∨ ... ∨ 3ψm ∨ 2χ1 ∨ ...∨2χn (γj propositional literals) be a non-tautologous clause. Suppose furthermore that there is no literal l in λ such that λ ≡ λ \\ {l}. If λ ∈ Π(ϕ), then γ1 ∨ ... ∨ γk ∈ Π(ϕ∧¬(λ \\{γ1, ..., γk})) and 3(ψ1 ∨ ...∨ψn) ∈ Π(ϕ∧¬(λ \\{3ψ1, ...,3ψm})) and for every i, 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) ∈ Π(ϕ ∧ ¬(λ \\ {2χi})).\nProof. We will prove the contrapositive: if γ1 ∨ ... ∨ γk 6∈ Π(ϕ ∧ ¬(λ \\ {γ1, ..., γk})) or 3(ψ1 ∨ ... ∨ ψn) 6∈ Π(ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψm})) or there is some i for which 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) 6∈ Π(ϕ ∧ ¬(λ \\ {2χi})), then λ 6∈ Π(ϕ). We will only consider the case where ϕ |= λ because if ϕ 6|= λ then we immediately get λ 6∈ Π(ϕ).\nLet us first suppose that γ1∨...∨γk 6∈ Π(ϕ∧¬(λ\\{γ1, ..., γk})). Since ϕ |= λ, we must also have ϕ∧¬(λ\\{γ1, ..., γk}) |= γ1∨...∨γk, so γ1∨...∨γk is an implicate of ϕ∧¬(λ\\{γ1, ..., γk}). As γ1 ∨ ...∨ γk is known not to be a prime implicate of ϕ∧¬(λ \\{γ1, ..., γk}), it follows that there must be some clause λ′ such that ϕ∧¬(λ\\{γ1, ..., γk}) |= λ ′ |= γ1∨ ...∨γk 6|= λ ′. Now consider the clause λ′′ = λ′∨3ψ1∨ ...∨3ψm∨2χ1∨ ...∨2χn. We know that ϕ |= λ ′′ since ϕ∧¬(λ\\{γ1, ..., γk}) |= λ ′, and that λ′′ |= λ because λ′ |= γ1∨ ...∨γk. We also have λ 6|= λ ′′ since λ′ must be equivalent to a propositional clause (by Theorem 2) and the propositional part of λ (namely γ1 ∨ ... ∨ γk) does not imply λ\n′. It follows then that ϕ |= λ′′ |= λ 6|= λ′′, so λ 6∈ Π(ϕ).\nNext suppose that 3(ψ1∨ ...∨ψn) 6∈ Π(ϕ∧¬(λ\\{3ψ1, ...,3ψm})). Now 3(ψ1∨ ...∨ψn) must be an implicate of ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψm}) since we have assumed that ϕ |= λ. As 3(ψ1 ∨ ... ∨ ψn) is not a prime implicate of ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψm}), it follows that there is some λ′ such that ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψm}) |= λ ′ |= 3(ψ1 ∨ ... ∨ ψn) 6|= λ ′. Let λ′′ = γ1∨...∨γk∨λ ′∨2χ1∨...∨2χn. Because of Theorem 2, we know that λ\n′ is a disjunction of 3-literals, so according to Theorem 3 we must have λ 6|= λ′′ since 3(ψ1 ∨ ... ∨ ψn) 6|= λ\n′. We also know that ϕ |= λ′′ since ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψm}) |= λ\n′ and that λ′′ |= λ since λ′ |= 3(ψ1 ∨ ... ∨ ψn). That means that ϕ |= λ\n′′ |= λ 6|= λ′′, so λ 6∈ Π(ϕ). Finally consider the case where there is some i for which 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) 6∈ Π(ϕ ∧ ¬(λ \\ {2χi})). We know that ϕ |= λ and hence that ϕ ∧ ¬(λ \\ {2χi}) |= 2χi. Moreover, since ¬(λ \\ {2χi}) |= ¬3ψj for all j, we have ϕ ∧ ¬(λ \\ {2χi}) |= 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm). Thus, if 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) 6∈ Π(ϕ ∧ ¬(λ \\ {2χi})), it must mean that there is some λ′ such that ϕ ∧ ¬(λ \\ {2χi}) |= λ ′ |= 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) 6|= λ ′. By assumption, λ is not a tautology, so 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) cannot be a tautology\neither. As λ′ |= 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) and 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) is not a tautology, it follows from Theorem 2 that λ′ is equivalent to some formula 2ζ1 ∨ ... ∨ 2ζp. Let λ′′ = γ1∨ ...∨ γk ∨3ψ1 ∨ ...∨3ψm ∨2χ1 ∨ ...∨2χi−1 ∨ (2ζ1∨ ...∨2ζp)∨2χi+1 ∨ ...∨2χn. As ϕ ∧ ¬(λ \\ {2χi}) |= 2ζ1 ∨ ... ∨ 2ζp, it must be the case that ϕ |= λ\n′′. Also, we know that there can be no j such that χi |= ζj ∨ ψ1 ∨ ... ∨ ψm because otherwise we would have χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm |= ζj and hence 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) |= 2ζ1 ∨ ... ∨ 2ζp. Similarly, there can be no k 6= i such that 2χi |= 2(χk ∨ ψ1 ∨ ... ∨ ψm) because this would mean that λ ≡ λ \\ {2χi}, contradicting our assumption that there are no superfluous disjuncts in λ. It follows then by Theorem 3 that λ 6|= λ′′. Thus, ϕ |= λ′′ |= λ 6|= λ′′, which means λ 6∈ Π(ϕ).\nLemma 25.2 Let ϕ be a formula of K, and let λ = γ1∨...∨γk∨3ψ1∨...∨3ψm∨2χ1∨...∨2χn (γj propositional literals) be a non-tautologous clause. Suppose furthermore that there is no literal l in λ such that λ ≡ λ \\ {l}. Then if λ 6∈ Π(ϕ), either γ1 ∨ ... ∨ γk 6∈ Π(ϕ ∧ ¬(λ \\ {γ1, ..., γk})) or 3(ψ1 ∨ ...∨ψm) 6∈ Π(ϕ∧¬(γ1 ∨ ...∨ γk ∨2(χ1 ∨ψ1 ∨ ...∨ψm)∨ ...∨2(χn ∨ ψ1 ∨ ... ∨ ψm))) or 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) 6∈ Π(ϕ ∧ ¬(λ \\ {2χi})) for some i.\nProof. We will only consider the case where ϕ |= λ because if ϕ 6|= λ then we immediately get the result. Suppose then that λ 6∈ Π(ϕ) and ϕ |= λ. By Definition 7, there must be some λ′ = γ′1 ∨ ...γ ′ o ∨3ψ ′ 1 ∨ ...∨3ψ ′ p ∨2χ ′ 1 ∨ ...∨2χ ′ q such that ϕ |= λ\n′ |= λ 6|= λ′. Since λ 6|= λ′, by Proposition 3 we know that either γ1∨ ...∨γk 6|= γ ′ 1∨ ...∨γ ′ o or ψ1∨ ...∨ψm 6|= ψ ′ 1∨ ...∨ψ ′ p or there is some i for which χi 6|= χ ′ j ∨ ψ ′ 1 ∨ ... ∨ ψ ′ p for all j.\nWe begin with the case where γ1 ∨ ... ∨ γk 6|= γ ′ 1 ∨ ... ∨ γ ′ o. As λ ′ |= λ, by Theorem 3, ψ′1∨ ...∨ψ ′ p |= ψ1∨ ...∨ψm and for every i there is some j such that χ ′ i |= ψ1∨ ...∨ψm∨χj. It follows then (also by Theorem 3) that ϕ |= λ′ |= γ′1∨...∨γ ′ o∨3ψ1∨...∨3ψm∨2χ1∨...∨2χn, and hence that ϕ∧¬(λ\\{γ1, ..., γk}) |= γ ′ 1∨...∨γ ′ o. As γ ′ 1∨...∨γ ′ o |= γ1∨...∨γk 6|= γ ′ 1∨...∨γ ′ o, we have found an implicate of ϕ ∧ ¬(λ \\ {γ1, ..., γk}) which is stronger than γ1 ∨ ... ∨ γk, so γ1 ∨ ... ∨ γk 6∈ Π(ϕ ∧ ¬(λ \\ {γ1, ..., γk})).\nNext suppose that ψ1∨ ...∨ψm 6|= ψ ′ 1∨ ...∨ψ ′ p. As λ ′ |= λ, it follows from Theorem 3 that γ′1∨ ...∨γ ′ o |= γ1∨ ...∨γk and that for every i there is some j such that χ ′ i |= ψ1∨ ...∨ψm∨χj. We thereby obtain ϕ |= λ′ |= γ1 ∨ ... ∨ γk ∨ 3ψ ′ 1 ∨ ... ∨ 3ψ ′ p ∨ 2(χ1 ∨ ψ1 ∨ ... ∨ ψm) ∨ ... ∨ 2(χn ∨ ψ1 ∨ ... ∨ ψm). From this, we can infer that ϕ ∧ ¬(γ1 ∨ ... ∨ γk ∨ 2(χ1 ∨ ψ1 ∨ ... ∨ ψm) ∨ ... ∨ 2(χn ∨ ψ1 ∨ ... ∨ ψm)) |= 3ψ ′ 1 ∨ ... ∨ 3ψ ′ p |= 3ψ1 ∨ ... ∨ 3ψm 6|= 3ψ ′ 1 ∨ ... ∨ 3ψ ′ p. As 3ψ1 ∨ ...∨3ψm ≡ 3(ψ1 ∨ ... ∨ψm), it follows that 3(ψ1 ∨ ... ∨ψm) 6∈ Π(ϕ ∧¬(γ1 ∨ ...∨ γk ∨ 2(χ1 ∨ ψ1 ∨ ... ∨ ψm) ∨ ... ∨ 2(χn ∨ ψ1 ∨ ... ∨ ψm))).\nFinally suppose that χi 6|= χ ′ j ∨ψ ′ 1∨ ...∨ψ ′ p for all j and furthermore that ψ1∨ ...∨ψm |=\nψ′1 ∨ ... ∨ ψ ′ p (we have already shown the result holds when ψ1 ∨ ... ∨ ψm 6|= ψ ′ 1 ∨ ... ∨ ψ′p). Now 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) is an implicate of ϕ ∧ ¬(λ \\ {2χi})) so to show that 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) is not a prime implicate of ϕ ∧ ¬(λ \\ {2χi})), we must find some stronger implicate. Consider the set S = {s ∈ {1, ..., q} : χ′s |= χi ∨ ψ1 ∨ ... ∨ ψm and χ ′ s 6|= χk∨ψ1∨...∨ψm for k 6= i}. We note that there must be at least one element in S as we have assumed ϕ 6|= λ\\{2χi}. Now since γ ′ 1∨ ...∨γ ′ o |= γ1∨ ...∨γk, ψ ′ 1∨ ...∨ψ ′ p |= ψ1∨ ...∨ψm, for every s 6∈ S there is some r 6= i such that χ′s |= χr ∨ψ1∨ ...∨ψm, and χ ′ s |= χ ′ s for s ∈ S, we get ϕ |= λ′ |= γ1∨...∨γk∨3ψ1∨...∨3ψm∨( ∨ j 6=i 2χj)∨( ∨ s∈S 2χ ′ s). It follows that ϕ∧¬(λ\\ {2χi}) |= ∨ s∈S 2(χ ′ s∧¬ψ1∧ ...∧¬ψm), which means that ∨ s∈S 2(χ ′ s∧¬ψ1∧ ...∧¬ψm) is an\nimplicate of ϕ∧¬(λ\\{2χi}). Moreover, ∨ s∈S 2(χ ′ s∧¬ψ1∧...∧¬ψm) |= 2(χi∧¬ψ1∧...∧¬ψm) since by construction χ′s |= χi ∨ ψ1 ∨ ... ∨ ψm for every s ∈ S. It remains to be shown that 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) 6|= ∨ s∈S 2(χ ′ s ∧ ¬ψ1 ∧ ... ∧ ¬ψm). Suppose for a contradiction that the contrary holds. Then 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) |=∨ s∈S 2(χ ′ s ∧ ¬ψ1 ∧ ... ∧ ¬ψm), so by Theorem 1, there must be some s ∈ S for which χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm |= χ ′ s ∧ ¬ψ1 ∧ ... ∧ ¬ψm. But then χi |= χ ′ s ∨ ψ1 ∨ ... ∨ ψm, and thus χi |= χ ′ s ∨ψ ′ 1 ∨ ...∨ψ ′ p since we have assumed ψ1 ∨ ...∨ψm |= ψ ′ 1 ∨ ...∨ψ ′ p. This contradicts our earlier assumption that χi 6|= χ ′ j ∨ ψ ′ 1 ∨ ... ∨ ψ ′ p for all j. Thus, we have shown that 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) 6|= ∨ s∈S 2(χ ′ s ∧ ¬ψ1 ∧ ... ∧ ¬ψm), so 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψm) 6∈ Π(ϕ ∧ ¬(λ \\ {2χi})).\nTheorem 25 Let ϕ be a formula of K, and let λ = γ1∨...∨γk∨3ψ1∨...∨3ψn∨2χ1∨...∨2χm (γj propositional literals) be a non-tautologous clause such that (a) χi ≡ χi ∨ ψ1 ∨ ... ∨ ψn for all i, and (b) there is no literal l in λ such that λ ≡ λ \\ {l}. Then λ ∈ Π(ϕ) if and only if the following conditions hold:\n1. γ1 ∨ ... ∨ γk ∈ Π(ϕ ∧ ¬(λ \\ {γ1, ..., γk}))\n2. 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψn) ∈ Π(ϕ ∧ ¬(λ \\ {2χi})) for every i\n3. 3(ψ1 ∨ ... ∨ ψn) ∈ Π(ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψn}))\nProof. The forward direction was shown in Lemma 25.1. The other direction follows from Lemma 25.2 together with the hypothesis that χi ≡ χi ∨ ψ1 ∨ ... ∨ ψn for all i (which ensures that ϕ ∧ ¬(γ1 ∨ ... ∨ γk ∨ 2(χ1 ∨ ψ1 ∨ ... ∨ ψm) ∨ ... ∨ 2(χn ∨ ψ1 ∨ ... ∨ ψm)) ≡ ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψn})).\nTheorem 26 Let ϕ be a formula of K, and let γ be a non-tautologous propositional clause such that ϕ |= γ and such that there is no literal l in γ such that γ ≡ γ \\{l}. Then γ ∈ Π(ϕ) if and only if ϕ 6|= γ \\ {l} for all l in γ.\nProof. Consider a formula ϕ and a non-tautologous propositional clause λ such that ϕ |= λ and such that there is no literal l in λ such that λ ≡ λ \\ {l}. Suppose that ϕ |= λ \\ {l} for some l in λ. As we know that λ 6≡ λ \\ {l}, it follows that λ \\ {l} is an implicate of ϕ which is strictly stronger than λ, so λ is not a prime implicate of ϕ. For the other direction, suppose that λ 6∈ Π(ϕ). Then it must be the case that there is some clause ρ such that ϕ |= ρ |= λ 6|= ρ. Since ρ |= λ, it follows from Theorem 2 that each literal in ρ is a propositional literal of λ or is inconsistent. If all of the literals in ρ are inconsistent, then both ρ and ϕ must be inconsistent, so clearly ϕ |= γ \\ {l} for every l in γ. Otherwise, ρ is equivalent to a propositional clause, and more specifically to a propositional clause containing only those literals appearing in λ (since ρ |= λ). As ρ is strictly stronger than λ, there must be some literal l in λ which does not appear in ρ. But that means ρ |= λ \\ {l} and so ϕ |= λ \\ {l}, completing the proof.\nTheorem 27 Let ϕ be a formula of K, and let λ = 2χ be a non-tautologous clause such that ϕ |= λ. Then λ ∈ Π(ϕ) if and only if there exists some term T ∈Dnf-4(ϕ) such that χ |= βT , where βT is the conjunction of formulae ψ such that 2ψ is in T .\nProof. Let ϕ be some formula, and let λ = 2χ be a non-tautologous clause such that ϕ |= λ. For the first direction, suppose that there is no term T ∈Dnf-4(ϕ) such that χ |= βT , where βT is the conjunction of formulae ψ such that 2ψ is in T . There are two cases: either there are no terms in Dnf-4(ϕ) because ϕ is unsatisfiable, or there are terms but none satisfy the condition. In the first case, 2χ is not a prime implicate of ϕ, since any contradictory clause (e.g. 3(a ∧ ¬a)) is stronger. In the second case, consider the clause λ′ = ∨\nT 2βT , where βT is the conjunction of formulae ψ such that 2ψ is in T . Now for every T we must have 2βT |= 2χ, otherwise we would have T 6|= 2χ, and hence ϕ 6|= 2χ. Moreover, ϕ |= ∨\nT 2βT since T |= 2βT for every T . But by Theorem 1, 2χ 6|= ∨\nT 2βT since χ 6|= βT for all T . So we have ϕ |= λ′ |= λ 6|= λ′, which means that λ is not a prime implicate of ϕ.\nFor the other direction, suppose that 2χ is not a prime implicate of ϕ and that ϕ 6|= ⊥. Then Dnf-4(ϕ) is non-empty. As ϕ |= 2χ, we must have T |= 2χ for all T ∈Dnf-4(ϕ), so ∨\nT 2βT also implies 2χ. We now show that ∨\nT 2βT is a prime implicate of ϕ. We let κ be some implicate of ϕ which implies ∨\nT 2βT . Now since κ |= ∨ T 2βT and ∨\nT 2βT is non-tautologous, it follows from Theorem 2 that κ ≡ 2ζ1 ∨ ... ∨ 2ζn for some formulae ζi. As ϕ |= κ, we must have T |= 2ζ1∨ ...∨2ζn for all T ∈Dnf-4(ϕ). But that can only be the case if 2βT |= 2ζ1 ∨ ...∨2ζn for all T , which means ∨ T 2βT |= 2ζ1 ∨ ...∨2ζn. As ∨\nT 2βT implies every implicate of ϕ that implies it, ∨\nT 2βT must be a prime implicate of ϕ. But this means that 2χ 6|= ∨\nT 2βT , since we have assumed that 2χ is not a prime implicate of ϕ. It follows from Theorem 1 that χ 6|= βT for all T ∈Dnf-4(ϕ).\nIn order to show Theorem 28 we will need the following lemmas:\nLemma 28.1 If 3ψ is an implicate of ϕ which is not a prime implicate, the algorithm Test3PI returns no on input (3ψ, ϕ).\nProof. Suppose that 3ψ is not a prime implicate of ϕ. If ϕ is unsatisfiable, then ψ must be satisfiable, so we will return no in the first step. If ϕ is satisfiable, then since we have assumed that 3ψ is an implicate of ϕ, there must be some clause λ such that ϕ |= λ |= 3ψ but 3ψ 6|= λ. As λ |= 3ψ, it follows from Theorem 2 that λ is equivalent to a disjunction of 3-formulae, and hence to some clause 3ψ′.\nWe know from Lemma 13 that ϕ is equivalent to the disjunction of terms in Dnf-4(ϕ). It must thus be the case that Ti |= 3ψ\n′ for all Ti ∈ Dnf-4(ϕ). Since each Ti is a satisfiable conjunction of propositional literals and 2- and 3-formulae, it follows that there exists a set {3ηi,2µi,1, ...,2µi,k(i)} of conjuncts of Ti such that 3(ηi∧µi,1∧...∧µi,k(i)) |= 3ψ\n′, otherwise Ti would fail to imply 3ψ\n′. Moreover, all of the elements of {3ηi,2µi,1, ...,2µi,k(i)} must appear in the NNF of ϕ outside modal operators, so the formulae ηi, µi,1, ..., µi,k(i) must all be elements of the set X . It is immediate that both\n3\n∨\ni\n(ηi ∧ µi,1 ∧ ... ∧ µi,k(i)) |= 3ψ ′ |= 3ψ (3)\nand\n3ψ 6|= 3 ∨\ni\n(ηi ∧ µi,1 ∧ ... ∧ µi,k(i))\nThe latter implies that the formula 3ψ∧¬(3 ∨\ni(ηi ∧µi,1∧ ...∧µi,k(i))) must be consistent, which means that\nψ ∧ ¬( ∨\ni\n(ηi ∧ µi,1 ∧ ... ∧ µi,k(i))) ≡ ψ ∧ ∧\ni\n(¬ηi ∨ ¬µi,1 ∨ ... ∨ ¬µi,k(i))\nmust be consistent as well. But then it must be the case that we can select for each i some σi ∈ {ηi, µi,1, ..., µi,k(i)} such that ψ ∧ ∧\ni ¬σi is consistent. Let S be the set of σi. The set S satisfies the condition of the algorithm since:\n• S ⊆ X\n• ψ 6|= ∨ σ∈S σ (because we know ψ ∧ ∧ i ¬σi to be consistent)\n• for each Ti ∈ Dnf-4(ϕ), the conjuncts 3ηi,2µi,1, ...,2µi,k(i) of Ti are such that:\n– {ηi, µi,1, ..., µi,k(i)} ∩ S 6= ∅ (since S contains σi ∈ {ηi, µi,1, ..., µi,k(i)})\n– 3(ηi ∧ µi,1 ∧ ... ∧ µi,k(i)) |= 3ψ (follows from (3) above)\nSince there exists a set S ⊆ X satisfying these conditions, the algorithm returns no.\nLemma 28.2 If the algorithm Test3PI returns no on input (3ψ, ϕ), then 3ψ is not a prime implicate of ϕ.\nProof. Suppose Test3PI returns no on input (3ψ, ϕ). If this happens during the first step, it must be the case that ϕ is unsatisfiable and 3ψ is unsatisfiable, in which case 3ψ is not a prime implicate of ϕ. The other possibility is that the algorithm returns no in Step 3, which means there must be some S ⊆ X satisfying:\n(a) ψ 6|= ∨\nλ∈S λ\n(b) for each Ti ∈ Dnf-4(ϕ), there exist conjuncts 3ηi,2µi,1, ...,2µi,k(i) of Ti such that: (i) {ηi, µi,1, ..., µi,k(i)} ∩ S 6= ∅ (ii) 3(ηi ∧ µi,1 ∧ ... ∧ µi,k(i)) |= 3ψ\nLet α be the clause ∨\ni 3(ηi ∧ µi,1 ∧ ... ∧ µi,k(i)). We remark that for each Ti, we have Ti |= 3(ηi∧µi,1∧ ...∧µi,k(i)), and hence ∨ i Ti |= ∨\ni 3(ηi∧µi,1∧ ...∧µi,k(i)). From the definition of Dnf-4(ϕ), we also have ϕ ≡ ∨\ni Ti. It immediately follows that ϕ |= ∨\ni 3(ηi∧µi,1∧...∧µi,k(i)) and hence ϕ |= α. From 2 (b) (ii), we have that 3(ηi ∧ µi,1 ∧ ... ∧ µi,k(i)) |= 3ψ for every i, and hence ∨\ni 3(ηi ∧ µi,1 ∧ ...∧ µi,k(i)) |= 3ψ which yields α |= 3ψ. From 2 (b) (i), we have that {ηi, µi,1, ..., µi,k(i)} ∩ S 6= ∅ and hence that for every i there is some λ ∈ S such that ηi∧µi,1∧ ...∧µi,k(i) |= λ. From this we can infer that ∨ i 3(ηi∧µi,1∧ ...∧µi,k(i)) |= ∨\nλ∈S 3λ, and hence α |= 3 ∨\nλ∈S λ. But we know from 2 (a) and Theorem 1 that 3ψ 6|= 3 ∨\nλ∈S λ. It follows then that 3ψ 6|= α. Putting all this together, we see that there exists a clause α such that ϕ |= α |= 3ψ but 3ψ 6|= α, and hence that 3ψ is not a prime implicate of ϕ.\nTheorem 28 Let ϕ be a formula, and let 3ψ be an implicate of ϕ. Then the algorithm Test3PI returns yes on input (3ψ, ϕ) if and only if 3ψ is a prime implicate of ϕ.\nProof. It is clear that Test3PI terminates since unsatisfiability testing and the NNF transformation always terminate, and there are only finitely many S and Ti. Lemmas 28.1 and 28.2 show us that the algorithm always gives the correct response.\nTheorem 29 The algorithm Test3PI runs in polynomial space.\nProof. We remark that the sum of the lengths of the elements in X is bounded by the length of the formula Nnf(ϕ), and hence by Lemma 14 the sum of the lengths of the elements of a particular S ⊆ X cannot exceed 2|ϕ|. Testing whether ψ 6|= ∨\nλ∈S λ can thus be accomplished in polynomial space in the length of ϕ and ψ as it involves testing the satisfiability of the formula ψ ∧ ∧\nλ∈S ¬λ whose length is clearly polynomial in ϕ and ψ.\nNow let us turn to Step 3 (b). We notice that it is not necessary to keep all of the Ti in memory at once, since we can generate the terms Ti one at a time using only polynomial space by Lemma 12. By Lemma 14, the length of any Ti in Dnf-4(ϕ) can be at most 2|ϕ|. It follows that checking whether {ηi, µi,1, ..., µi,k(i)} ∩ S 6= ∅, or whether 3(ηi ∧ µi,1 ∧ ... ∧ µi,k(i)) |= 3ψ can both be accomplished in polynomial space in the length of ϕ and ψ. We conclude that the algorithm Test3PI runs in polynomial space.\nIn order to show Theorem 32, we use the following lemmas:\nLemma 32.1 If λ is a clause that is not a prime implicate of ϕ, then TestPI outputs no on this input.\nProof. Let us begin by considering a formula λ which is a clause but that is not a prime implicate of ϕ. There are two possible reasons for this: either λ is not an implicate of ϕ, or it is an implicate but there exists some stronger implicate. In the first case, TestPI returns no in Step 1, as desired. We will now focus on the case where λ is an implicate but not a prime implicate. We begin by treating the limit cases where one or both of ϕ and λ is a tautology or contradiction. Given that we know λ to be a non-prime implicate of ϕ, there are only two possible scenarios: either 6|= ϕ and |= λ, or ϕ |= ⊥ and λ 6|= ⊥. In both cases, the algorithm returns no in Step 2.\nIf λ is an implicate of ϕ, and neither ϕ nor λ is a tautology or contradiction, then the algorithm will continue on to Step 3. In this step, any redundant literals will be deleted from λ, and if λ contains 3-literals, we add an extra disjunct to the 2-literals so that λ satisfies the syntactic requirements of Theorem 25. Let γ1 ∨ ...γk ∨3ψ1 ∨ ...∨3ψm ∨2χ1 ∨ ... ∨ 2χn be the clause λ at the end of Step 3 once all modifications have been made. As the transformations in Step 3 are equivalence-preserving (Theorem 1), the modified λ is equivalent to the original, so λ is still a non-tautologous non-prime implicate of ϕ. This means ϕ and λ now satisfy all of the conditions of Theorem 25. It follows then that one of the following holds:\n(a) γ1 ∨ ... ∨ γk 6∈ Π(ϕ ∧ ¬(λ \\ {γ1, ..., γk})\n(b) 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψn) 6∈ Π(ϕ ∧ ¬(λ \\ {2χi})) for some i\n(c) 3(ψ1 ∨ ... ∨ ψn) 6∈ Π(ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψn}))\nSuppose that (a) holds. Now γ1 ∨ ... ∨ γk is a non-tautologous propositional clause implied by ϕ ∧ ¬(λ \\ {γ1, ..., γk}) which contains no redundant literals. This means that ϕ ∧ ¬(λ \\ {γ1, ..., γk}) and γ1∨...∨γk satisfy the conditions of Theorem 26. According to this theorem, as γ1 ∨ ... ∨ γk 6∈ Π(ϕ ∧ ¬(λ \\ {γ1, ..., γk}), then there must be some γj such that ϕ ∧ ¬(λ \\ {γ1, ..., γk}) |= γ1∨ ...∨γj−1∨γj+1∨ ...∨γk . This means that ϕ |= λ\\{γj}, so the algorithm returns no in Step 4.\nSuppose next that (b) holds, and let i be such that 2(χi ∧ ¬ψ1 ∧ ... ∧ ¬ψn) 6∈ Π(ϕ ∧ ¬(λ \\ {2χi})). By Theorem 27, this means that there is no T ∈Dnf-4(ϕ) such that 2(χi∧¬ψ1∧ ...∧¬ψn) entails the conjunction of 2-formulae conjuncts of T . It follows that the algorithm returns no in Step 5.\nFinally consider the case where neither (a) nor (b) holds but (c) does. Then in Step 6, we will call Test3PI(3(\n∨m i=1 ψi), ϕ∧¬(λ\\{3ψ1 , ...,3ψm})). As 3( ∨m i=1 ψi) is not a prime\nimplicate of ϕ∧¬(λ\\{3ψ1, ...,3ψm})) and we have shown Test3PI to be correct (Theorem 28), Test3PI will return no, so TestPI will return no as well. As we have covered each of the possible cases, we can conclude that if λ is a clause that is not a prime implicate of ϕ, then TestPI outputs no.\nLemma 32.2 If TestPI outputs no with input (λ, ϕ) and λ is a clause, then λ is not a prime implicate of ϕ.\nProof. There are 5 different ways for TestPI to return no (these occur in Steps 1, 2, 4, 5, and 6). Let us consider each of these in turn. The first way that the algorithm can return no is in Step 1 if we find that ϕ 6|= λ. This is correct since λ cannot be a prime implicate if it is not a consequence of ϕ. In Step 2, we return no if ϕ is unsatisfiable but λ is not, or if λ is a tautology but ϕ is not. This is also correct since in both cases λ cannot be a prime implicate since there exist stronger implicates (any contradictory clause if ϕ ≡ ⊥, and any non-tautologous implicate of ϕ if λ ≡ ⊤). In Step 3, we may modify λ, but the resulting formula is equivalent to the original, and so it is a prime implicate just in the case that the original clause was. Let γ1∨ ...γk∨3ψ1∨ ...∨3ψm∨2χ1∨ ...∨2χn be the clause at the end of Step 3. Now in Step 4, we return no if we find some propositional literal l in λ for which ϕ |= λ\\{l}. Now since in Step 3, we have removed redundant literals from λ, we can be sure that λ \\ {l} is strictly stronger than λ. So we have ϕ |= λ \\ {l} |= λ and λ 6|= λ \\ {l}, which means that λ is not a prime implicate of ϕ. We now consider Step 5 of TestPI. In this step, we return no if for some disjunct 2χi there is no term T inDnf-4(ϕ∧¬(λ\\{2χi})) for which 2(χi∧¬ψ1∧ ...∧¬ψm) entails the conjunction of 2-literals in T . According to Theorem 27, this means that 2(χi ∧¬ψ1 ∧ ...∧¬ψm) is not a prime implicate of ϕ∧¬(λ \\ {2χi}), which means that λ is not a prime implicate of ϕ by Theorem 25. . In this step, we return no if Test3PI returns no on input (3(\n∨k i=1 ψi), ϕ∧¬(λ \\ {3ψ1, ...,3ψm})). By Theorem 28,\nwe know that this happens just in the case that 3( ∨k\ni=1 ψi) is not a prime implicate of ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψm}). It follows from Theorem 25 that λ is not a prime implicate of ϕ.\nTheorem 32 The algorithm TestPI always terminates, and it returns yes on input (λ, ϕ) if and only if λ is a prime implicate of ϕ.\nProof. The algorithm TestPI clearly terminates because Steps 1 to 5 involve a finite number of syntactic operations on λ and a finite number of entailment checks. Moreover, the call to Test3PI in Step 6 is known to terminate (Theorem 28). Correctness and completeness have already been shown in Lemmas 32.1 and 32.2.\nWe make use of the following lemma in the proof of Theorem 34:\nLemma 34.1 The algorithm TestPI provided in Figure 5 runs in polynomial space in the length of the input.\nProof. It is clear that steps 1 through 5 can be carried out in polynomial space in the length of the input, since they simply involve testing the satisfiability of formulae whose lengths are polynomial in |λ|+ |ϕ|. Step 6 can also be carried out in polynomial space since by Theorem 29 deciding whether the formula 3(\n∨m i=1 ψi) is a prime implicate of ϕ∧¬(λ \\ {ψ1, ..., ψm}))\ntakes only polynomial space in |3( ∨m\ni=1 ψi)| + |ϕ ∧ ¬(λ \\ {3ψ1, ...,3ψm}))|, and hence in |λ|+ |ϕ|. We can thus conclude that the algorithm TestPI runs in polynomial space in the length of the input.\nTheorem 34 Prime implicate recognition is in Pspace.\nProof. We have show in Theorem 32 that TestPI always terminates and returns yes whenever the clause is a prime implicate and no otherwise. This means that TestPI is a decision procedure for prime implicate recognition. Since the algorithm has been shown to run in polynomial space (Lemma 34.1), we can conclude that prime implicate recognition is in Pspace.\nCorollary 35 Prime implicate recognition is Pspace-complete.\nProof. Follows directly from Theorems 24 and 34."
    } ],
    "references" : [ {
      "title" : "Distributed reasoning in a peer-to-peer setting: Application to the semantic web",
      "author" : [ "P. Adjiman", "P. Chatalic", "F. Goasdoué", "Rousset", "M.-C", "L. Simon" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Adjiman et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Adjiman et al\\.",
      "year" : 2006
    }, {
      "title" : "The Description Logic Handbook",
      "author" : [ "F. Baader", "D.L. McGuiness", "D. Nardi", "P. Patel-Schneider" ],
      "venue" : null,
      "citeRegEx" : "Baader et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2003
    }, {
      "title" : "Prime implicates and prime implicants in modal logic",
      "author" : [ "M. Bienvenu" ],
      "venue" : "Proceedings of the Twenty-Second Conference on Artificial Intelligence (AAAI’07), pp. 397–384.",
      "citeRegEx" : "Bienvenu,? 2007",
      "shortCiteRegEx" : "Bienvenu",
      "year" : 2007
    }, {
      "title" : "Prime implicate normal form for ALC concepts",
      "author" : [ "M. Bienvenu" ],
      "venue" : "Proceedings of the Twenty-Third Conference on Artificial Intelligence (AAAI’08), pp. 412–417.",
      "citeRegEx" : "Bienvenu,? 2008",
      "shortCiteRegEx" : "Bienvenu",
      "year" : 2008
    }, {
      "title" : "Consequence Finding in Modal Logic",
      "author" : [ "M. Bienvenu" ],
      "venue" : "Ph.D. thesis, Université de Toulouse.",
      "citeRegEx" : "Bienvenu,? 2009",
      "shortCiteRegEx" : "Bienvenu",
      "year" : 2009
    }, {
      "title" : "Combining syntax and semantics through prime form representation",
      "author" : [ "G. Bittencourt" ],
      "venue" : "Journal of Logic and Computation, 18 (1), 13–33.",
      "citeRegEx" : "Bittencourt,? 2007",
      "shortCiteRegEx" : "Bittencourt",
      "year" : 2007
    }, {
      "title" : "An approach for optimized approximation",
      "author" : [ "S. Brandt", "A. Turhan" ],
      "venue" : "In Proceedings of the KI-2002 Workshop on Applications of Description Logics (KIDLWS’01)",
      "citeRegEx" : "Brandt and Turhan,? \\Q2002\\E",
      "shortCiteRegEx" : "Brandt and Turhan",
      "year" : 2002
    }, {
      "title" : "A survey on knowledge compilation",
      "author" : [ "M. Cadoli", "F.M. Donini" ],
      "venue" : "AI Communications,",
      "citeRegEx" : "Cadoli and Donini,? \\Q1997\\E",
      "shortCiteRegEx" : "Cadoli and Donini",
      "year" : 1997
    }, {
      "title" : "Propositional abduction in modal logic",
      "author" : [ "M. Cialdea Mayer", "F. Pirri" ],
      "venue" : "Logic Journal of the IGPL,",
      "citeRegEx" : "Mayer and Pirri,? \\Q1995\\E",
      "shortCiteRegEx" : "Mayer and Pirri",
      "year" : 1995
    }, {
      "title" : "A knowledge compilation map",
      "author" : [ "A. Darwiche", "P. Marquis" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Darwiche and Marquis,? \\Q2002\\E",
      "shortCiteRegEx" : "Darwiche and Marquis",
      "year" : 2002
    }, {
      "title" : "Characterizing diagnoses and systems",
      "author" : [ "J. de Kleer", "A.K. Mackworth", "R. Reiter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Kleer et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Kleer et al\\.",
      "year" : 1992
    }, {
      "title" : "The Description Logic Handbook, chap",
      "author" : [ "F.M. Donini" ],
      "venue" : "Complexity of Reasoning. Cambridge University Press.",
      "citeRegEx" : "Donini,? 2003",
      "shortCiteRegEx" : "Donini",
      "year" : 2003
    }, {
      "title" : "The complexity of existential qualification in concept languages",
      "author" : [ "F.M. Donini", "M. Lenzerini", "D. Nardi", "B. Hollunder", "W. Nutt", "A. Marchetti Spaccamela" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Donini et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Donini et al\\.",
      "year" : 1992
    }, {
      "title" : "On computing all abductive explanations",
      "author" : [ "T. Eiter", "K. Makino" ],
      "venue" : "In Proceedings of the Eighteenth National Conference on Artificial Intelligence",
      "citeRegEx" : "Eiter and Makino,? \\Q2002\\E",
      "shortCiteRegEx" : "Eiter and Makino",
      "year" : 2002
    }, {
      "title" : "Modal resolution in clausal form",
      "author" : [ "P. Enjalbert", "L. Fariñas del Cerro" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "Enjalbert and Cerro,? \\Q1989\\E",
      "shortCiteRegEx" : "Enjalbert and Cerro",
      "year" : 1989
    }, {
      "title" : "Computers and intractability. A guide to the theory of NP-completeness",
      "author" : [ "M.R. Garey", "D.S. Johnson" ],
      "venue" : null,
      "citeRegEx" : "Garey and Johnson,? \\Q1979\\E",
      "shortCiteRegEx" : "Garey and Johnson",
      "year" : 1979
    }, {
      "title" : "Did I damage my ontology? A case for conservative extensions in description logics",
      "author" : [ "S. Ghilardi", "C. Lutz", "F. Wolter" ],
      "venue" : "In Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "Ghilardi et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Ghilardi et al\\.",
      "year" : 2006
    }, {
      "title" : "A SAT-based decision procedure for ALC",
      "author" : [ "F. Giunchiglia", "R. Sebastiani" ],
      "venue" : "In Proceedings of the Fifth International Conference on Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "Giunchiglia and Sebastiani,? \\Q1996\\E",
      "shortCiteRegEx" : "Giunchiglia and Sebastiani",
      "year" : 1996
    }, {
      "title" : "Approximating most specific concepts in logics with existential restrictions",
      "author" : [ "R. Küsters", "R. Molitor" ],
      "venue" : "AI Communications,",
      "citeRegEx" : "Küsters and Molitor,? \\Q2002\\E",
      "shortCiteRegEx" : "Küsters and Molitor",
      "year" : 2002
    }, {
      "title" : "The computational complexity of provability in systems of modal propositional logic",
      "author" : [ "R. Ladner" ],
      "venue" : "SIAM Journal of Computing, 6 (3), 467–480.",
      "citeRegEx" : "Ladner,? 1977",
      "shortCiteRegEx" : "Ladner",
      "year" : 1977
    }, {
      "title" : "A logical account of relevance",
      "author" : [ "G. Lakemeyer" ],
      "venue" : "Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence (IJCAI’95), pp. 853–861.",
      "citeRegEx" : "Lakemeyer,? 1995",
      "shortCiteRegEx" : "Lakemeyer",
      "year" : 1995
    }, {
      "title" : "Propositional independence: Formulavariable independence and forgetting",
      "author" : [ "J. Lang", "P. Liberatore", "P. Marquis" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Lang et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Lang et al\\.",
      "year" : 2003
    }, {
      "title" : "Contribution á l’étude des méthodes de construction d’hypothèses en intelligence artificielle",
      "author" : [ "P. Marquis" ],
      "venue" : "french, Université de Nancy I.",
      "citeRegEx" : "Marquis,? 1991a",
      "shortCiteRegEx" : "Marquis",
      "year" : 1991
    }, {
      "title" : "Extending abduction from propositional to first-order logic",
      "author" : [ "P. Marquis" ],
      "venue" : "Proceedings of Fundamentals of Artificial Intelligence Research Workshop, pp. 141–155.",
      "citeRegEx" : "Marquis,? 1991b",
      "shortCiteRegEx" : "Marquis",
      "year" : 1991
    }, {
      "title" : "Handbook on Defeasible Reasoning and Uncertainty Management Systems, Vol",
      "author" : [ "P. Marquis" ],
      "venue" : "5, chap. Consequence Finding Algorithms, pp. 41–145. Kluwer.",
      "citeRegEx" : "Marquis,? 2000",
      "shortCiteRegEx" : "Marquis",
      "year" : 2000
    }, {
      "title" : "Knowledge compilation for belief change",
      "author" : [ "M. Pagnucco" ],
      "venue" : "Proceedings of the Nineteenth Australian Conference on Artificial Intelligence (AI’06), pp. 90–99.",
      "citeRegEx" : "Pagnucco,? 2006",
      "shortCiteRegEx" : "Pagnucco",
      "year" : 2006
    }, {
      "title" : "Computational Complexity",
      "author" : [ "C. Papadimitriou" ],
      "venue" : "Addison Welsey.",
      "citeRegEx" : "Papadimitriou,? 1994",
      "shortCiteRegEx" : "Papadimitriou",
      "year" : 1994
    }, {
      "title" : "An algorithm to compute circumscription",
      "author" : [ "T. Przymusinski" ],
      "venue" : "Artificial Intelligence, 38 (1), 49–73.",
      "citeRegEx" : "Przymusinski,? 1989",
      "shortCiteRegEx" : "Przymusinski",
      "year" : 1989
    }, {
      "title" : "Computing prime implicants/implicates for regular logics",
      "author" : [ "A. Ramesh", "N. Murray" ],
      "venue" : "In Proceedings of the Twenty-Fourth IEEE International Symposium on MultipleValued Logic,",
      "citeRegEx" : "Ramesh and Murray,? \\Q1994\\E",
      "shortCiteRegEx" : "Ramesh and Murray",
      "year" : 1994
    }, {
      "title" : "A correspondence theory for terminological logics: Preliminary report",
      "author" : [ "K. Schild" ],
      "venue" : "Proceedings of the Twelth International Joint Conference on Artificial Intelligence (IJCAI’91), pp. 466–471. Younger, D. H. (1967). Recognition and parsing of context-free languages in time n3. Information and Control, 10 (2), 189–208.",
      "citeRegEx" : "Schild,? 1991",
      "shortCiteRegEx" : "Schild",
      "year" : 1991
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "Prime implicates have also proved relevant to other sub-areas of AI, like distributed reasoning (Adjiman, Chatalic, Goasdoué, Rousset, & Simon, 2006), belief revision (Bittencourt, 2007; Pagnucco, 2006), non-monotonic reasoning (cf.",
      "startOffset" : 167,
      "endOffset" : 202
    }, {
      "referenceID" : 25,
      "context" : "Prime implicates have also proved relevant to other sub-areas of AI, like distributed reasoning (Adjiman, Chatalic, Goasdoué, Rousset, & Simon, 2006), belief revision (Bittencourt, 2007; Pagnucco, 2006), non-monotonic reasoning (cf.",
      "startOffset" : 167,
      "endOffset" : 202
    }, {
      "referenceID" : 20,
      "context" : "Przymusinski, 1989), and characterizations of relevance (Lakemeyer, 1995; Lang, Liberatore, & Marquis, 2003).",
      "startOffset" : 56,
      "endOffset" : 108
    }, {
      "referenceID" : 19,
      "context" : "Ladner (1977) showed that satisfiability and unsatisfiability in K are Pspace-complete.",
      "startOffset" : 0,
      "endOffset" : 14
    }, {
      "referenceID" : 17,
      "context" : "The first definition, which is inspired by the notion of modal atom proposed by Giunchiglia and Sebastiani (1996), defines literals as the set of formulae in NNF that cannot be decomposed propositionally.",
      "startOffset" : 80,
      "endOffset" : 114
    }, {
      "referenceID" : 24,
      "context" : "In propositional logic, prime implicate recognition is BH2-complete (Marquis, 2000), being as hard as both satisfiability and deduction.",
      "startOffset" : 68,
      "endOffset" : 83
    }, {
      "referenceID" : 8,
      "context" : "Moreover, because the notion of term underlying our definition of abductive explanations is more expressive than that used by Cialdea Mayer and Pirri (1995), we are able to find explanations which are overlooked by their method.",
      "startOffset" : 134,
      "endOffset" : 157
    }, {
      "referenceID" : 8,
      "context" : "Moreover, because the notion of term underlying our definition of abductive explanations is more expressive than that used by Cialdea Mayer and Pirri (1995), we are able to find explanations which are overlooked by their method. For instance, if we look for an explanation of the observation c given the background information 2(a ∨ b) → c, we obtain 2(a ∨ b), whereas their framework yields 2a and 2b. This is an argument in favor of our approach since generally in abduction one is looking to find the weakest conditions guaranteeing the truth of the observation given the background information. Also of interest are our results on the size and number of prime implicates, as these yield corresponding lower bounds on the size and number of abductive explanations. In particular, our results imply that the abductive explanations of Cialdea Mayer and Pirri (1995) can have exponential size and be double exponentially many in number in the worst case, and thus behave no better in these respects than the notion of abductive explanation induced by our preferred definition D4.",
      "startOffset" : 134,
      "endOffset" : 867
    }, {
      "referenceID" : 3,
      "context" : "Indeed, in a continuation of the present work (Bienvenu, 2008), we proposed a more sophisticated definition of prime implicate normal form, in which we specify which of the many different clausal representations of a prime implicate should be used.",
      "startOffset" : 46,
      "endOffset" : 62
    }, {
      "referenceID" : 2,
      "context" : "Indeed, in a continuation of the present work (Bienvenu, 2008), we proposed a more sophisticated definition of prime implicate normal form, in which we specify which of the many different clausal representations of a prime implicate should be used. This normal form was shown to enjoy a number of desirable properties which make it interesting from the viewpoint of knowledge compilation. Most notably, it was proven that entailment between formulae in K in our prime implicate normal form can be carried out in polynomial time using a simple structural comparison algorithm which is reminiscent of the structural subsumption algorithms used in subpropositional description logics. It should be noted that the proof of this and other results by Bienvenu (2008) make ample use of the material presented in the current paper.",
      "startOffset" : 47,
      "endOffset" : 761
    }, {
      "referenceID" : 2,
      "context" : "This paper corrects and significantly extends an earlier conference publication (Bienvenu, 2007).",
      "startOffset" : 80,
      "endOffset" : 96
    }, {
      "referenceID" : 11,
      "context" : "Donini, Lenzerini, Nardi, Hollunder, Nutt, & Marchetti Spaccamela, 1992), it follows that deciding entailment between terms with respect to either D1 or D2 can also be accomplished in nondeterministic polynomial time, i.e. these problems belong to NP. It remains to be shown that these problems are NP-hard. To prove this, we show how the polynomial-time reduction of Donini (2003) (adapted from the original NP-hardness proof by Donini et al.",
      "startOffset" : 0,
      "endOffset" : 382
    }, {
      "referenceID" : 11,
      "context" : "Donini has proven (2003) that U ,S has an exact cover if and only if the formula φU ,S pictured in Figure 6 is unsatisfiable.",
      "startOffset" : 0,
      "endOffset" : 25
    } ],
    "year" : 2009,
    "abstractText" : "Prime implicates and prime implicants have proven relevant to a number of areas of artificial intelligence, most notably abductive reasoning and knowledge compilation. The purpose of this paper is to examine how these notions might be appropriately extended from propositional logic to the modal logic K. We begin the paper by considering a number of potential definitions of clauses and terms for K. The different definitions are evaluated with respect to a set of syntactic, semantic, and complexity-theoretic properties characteristic of the propositional definition. We then compare the definitions with respect to the properties of the notions of prime implicates and prime implicants that they induce. While there is no definition that perfectly generalizes the propositional notions, we show that there does exist one definition which satisfies many of the desirable properties of the propositional case. In the second half of the paper, we consider the computational properties of the selected definition. To this end, we provide sound and complete algorithms for generating and recognizing prime implicates, and we show the prime implicate recognition task to be Pspace-complete. We also prove upper and lower bounds on the size and number of prime implicates. While the paper focuses on the logic K, all of our results hold equally well for multi-modal K and for concept expressions in the description logic ALC.",
    "creator" : "dvips(k) 5.97 Copyright 2008 Radical Eye Software"
  }
}