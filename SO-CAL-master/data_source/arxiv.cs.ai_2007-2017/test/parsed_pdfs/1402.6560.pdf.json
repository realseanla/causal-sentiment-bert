{
  "name" : "1402.6560.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Even more generic solution construction in Valuation-Based Systems",
    "authors" : [ "Jordi Roca-Lacostena", "Jesus Cerquides" ],
    "emails" : [ "cerquide}@iiia.csic.es" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 2.\n65 60\nv1 [\ncs .A\nI] 2\n6 Fe\nRecently, formal requirements for the presence of solutions and a generic algorithm for solution construction based on the results of a previously executed inference scheme have been proposed [9, 8]. Unfortunately, the formalization of Pouly and Kohlas relies on a theorem for which we provide a counter example. In spite of that, the mainline of the theory described is correct, although some of the necessary conditions to apply some of the algorithms have to be revised. To fix the theory, we generalize some of their definitions and provide correct sufficient conditions for the algorithms. As a result, we get a more general and corrected version of the theory presented at [9, 8]."
    }, {
      "heading" : "1 Introduction",
      "text" : "Solving discrete optimization problems is an important and well-studied task in computer science. One particular approach to tackle them is known as dynamic programming [2] and can be found in almost every handbook about algorithms and programming techniques. The works of Bellman [1], Nemhauser [7] and Bertelè and Brioschi [2] present non-serial dynamic programming as an algorithm for optimization problems for functions taking values in the real numbers. A more general approach was taken by Mitten [6] and further generalized by Shenoy in 1996 [10], for functions taking values in any ordered set ∆. Shenoy introduces a set of axioms that later on will be known as valuation algebras. In those terms, Shenoy is the first one to connect the concept of solution with the marginalization operation of the valuation algebra.\nIn 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set ∆. They present several algorithms,\n∗IIIA - CSIC, Campus UAB, Spain, email: {jroca, cerquide}@iiia.csic.es\nand characterize the sufficient conditions for its correctness. Pouly and Kohlas’ algorithms are more general than their predecessors in the literature. This increased generality comes at no computational cost, since when applied in the previously covered scenarios, their particularization coincides exactly with the previously proposed algorithm. Furthermore, by dropping the assumption that valuations are functions, their algorithms can be applied to previously uncovered cases such as the solution of linear equation systems or the algebraic path problem. Unfortunately, one of the fundamental results in Pouly and Kohlas’ theory is incorrect.\nThe contributions of this work are:\n1. We provide a counterexample that invalidates Pouly and Kohlas’ results.\n2. We generalize the problem solved by Pouly and Kohlas, and provide and algorithm to solve it.\n3. We provide a new sufficient condition for the correctness of the algorithm.\nThese results provide the most general theory for dynamic programming up-todate."
    }, {
      "heading" : "2 Background",
      "text" : "In this section we start by defining valuation algebras. Later on, we introduce the marginalization problem and finally we review the Collect algorithm to solve that problem.\nThe basic elements of a valuation algebra are so-called valuations, that we subsequently denote by lower-case Greek letters such as φ or ψ. Let D be a lattice[4] with a partial order≤, two operations meet ∧ and join ∨, a top element ⊤, and a bottom element ⊥. Given a set of valuations Φ, and a lattice of domains D, a valuation algebras has three operations:\n1. Labeling: Φ → D;φ 7→ d(φ),\n2. Combination: Φ× Φ → Φ; (φ, ψ) 7→ φ⊗ ψ,\n3. Projection: Φ×D → Φ; (φ, x) 7→ φ↓x for x ≤ d(φ).\nsatisfying the following axioms:\nA1 Commutative semigroup: Φ is associative and commutative under ⊗.\nA2 Labeling: For ψ, φ ∈ Φ, d(φ⊗ ψ) = d(φ) ∨ d(ψ).\nA3 Projection: For φ ∈ Φ, x ∈ D, and x ≤ d(φ), d(φ↓x) = x.\nA4 Transitivity: For φ ∈ Φ and x ≤ y ≤ d(φ), (φ↓y)↓x = φ↓x.\nA5 Combination: For φ, ψ ∈ Φ with d(φ) = x, d(ψ) = y, and z ∈ D such that x ≤ z ≤ x ∨ y, (ψ ⊗ φ)↓z = φ⊗ ψ↓z∧y.\nA6 Domain: For φ ∈ Φ with d(φ) = x, φ↓x = φ.\nWe say that valuation e ∈ Φ is an identity valuation provided that d(e) = ⊥ and φ ⊗ e = φ for each φ ∈ Φ. As proven in [9], any valuation algebra that does not have and identity valuation can easily be extended to have one. In the following and without loss of generality we assume that our valuation algebra has an identity valuation e.\nVariable systems, frames and tuples. In most practical applications of valuation algebras, the domains of the valuations are subsets of a given set of variables V . It is well known (e.g. [3] page 36) that for any set V, the ordered set 〈P(V ),⊆〉 is a complete lattice, referred to as the power set lattice. Thus, most of the work on valuation algebras assumes that the lattice D is the power set lattice of a set V of variables.\nLet V = {x1, . . . , xn} be a finite set of variables1. We assume that for each variable x ∈ V we can assign a set Ωx of possible values, called its frame. Similarly, the frame of X ⊆ V is ΩX = ∏\nx∈X Ωx. It is mathematically convenient to include a singleton element (noted as ⋄) in Ω∅. Thus, Ω∅ = {⋄}. A pair 〈V,Ω〉 is known as a variable system. In many cases a variable system is naturally linked to a valuation algebra. Then we say that the valuation algebra is equipped with a variable system. A typical example is when valuations are discrete real functions and the domain of a valuation is the set of discrete variables over which the function is defined.\nA tuple x with finite domain X ⊆ V is an element of ΩX . A projection operation can be defined on tuples, unrelated to the projection operation of the valuation algebra. Given a tuple x with domain X and Y ⊆ X we define the projection of x to Y as the tuple y that results from x by discarding the values of the variables in X − Y. We note the projection of x to Y as x↓Y . We can write x = (x↓Y ,x↓X−Y ). Furthermore, x = (x, ⋄) = (⋄,x).\nExample 1. Given a set of binary variables V , we consider its power set lattice as the domain lattice of the valuation algebra. The set of valuations is composed by all the functions φ : ΩX → {0, 1} , where X ⊆ V . The labeling operation is defined by d(φ) = X . The combination of two valuations φ, ψ, is the valuation (φ⊗ψ)(x) = φ(x↓d(φ))+ψ(x↓d(ψ)), whereas the projection of a valuation φ with d(φ) = X to a domain Y ⊆ X is the valuation φ↓Y (y) = max z∈ΩX−Y φ(y, z). As proven in [9] the valuation algebra of Boolean functions satisfies axioms A1-A6.\nSome other relevant examples of valuation algebras are relational algebra, which is fundamental to databases, or the algebra of probability potentials, which underlies many results in probabilistic graphical models and the more abstract class of semiring induced valuation algebras [5].\n1All the definitions are correct not only for finite but also for countable V"
    }, {
      "heading" : "2.1 Finding the marginal of a factorized valuation",
      "text" : "A relevant problem in many valuation algebras in the problem of finding the marginal of a factorized valuation.\nProblem 1. Let (Φ, D) be a valuation algebra, and φ1, . . . , φn be valuations in Φ. Find (φ1 × · · · × φn) ↓X .\nNote that when our valuations are probability potentials, this is the well studied problem of finding the marginal of a factorized distribution, also known as Markov Random Field.\nThe Fusion algorithm [10] (a.k.a. variable elimination) or the Collect algorithm (a.k.a. junction tree or cluster tree algorithm)[9, 8] can be used to find marginals. Since our results build on top of the Collect algorithm, we provide a more accurate description below.\nA necessary condition to apply the Collect algorithm is that we can organize the valuations φ1, . . . , φn into a covering join tree, which we introduce next.\nDefinition 1. A labeled tree is any tree (V,E) together with a function λ : V → D that links each node with a single domain in D.\nA join tree is a labeled tree T = (V,E, λ,D) such that for any i, j ∈ V it holds that λ(i) ∧ λ(j) ≤ λ(k) for all nodes k on the path between i and j. In that case, we say that T satisfies the running intersection property.\nDefinition 2. Given a valuation φ = φ1 × · · · × φn we say that a join tree T = (V,E, λ,D) is a covering join tree for this factorization if |V | = n and for all φi there is a node j ∈ V such that d(φi) ≤ λ(j) .\nDefinition 3. Let i be a node in a rooted junction tree whose root is r. We use p(i) to denote the parent of i in the tree. The separator of i is si = {\n⊥ , if i = r\nλ(i) ∧ λ(p(i)) , otherwise\nAlgorithm 1 provides a description of the Collect algorithm. It is based on sending messages up the tree, through the edges of the covering join tree, until the root node is reached. The message sent from each node summarizes the information in the corresponding subtree which is relevant to its parent. The running intersection property guarantees that no information is lost.\nTheorem 1. After running the Collect algorithm (Algorithm 1) over the\nnodes of a covering join tree for φ = ∏ k φk, we have that ψ ′ i =\n(\n∏\nj∈Ti ψj\n)↓λ(i)\n.\nIn particular, if r is the root ψ′r = φ ↓λ(r).\nThe theorem is an adaptation of Theorem 3.6 in [9]. As a consequence of this theorem, we can use the Collect algorithm to solve problem 1 provided that we are given a covering join tree for the factorization we would like to marginalize.\nAlgorithm 1 Collect algorithm Each node i of the junction tree executes\n1: ⊲ Assess the product of valuations assigned to i 2: ψi ← e× ∏ j∈a−1(i) φj 3: From each child j of i, receive a message µj→i. 4: ⊲ Incorporate messages from children 5: ψ′i ← ψi × ∏ j µj→i. 6: if i is not the root then 7: Send message ψ\n↓si i to its parent p(i)\n8: end if"
    }, {
      "heading" : "3 Generic solutions in valuation algebras with",
      "text" : "variable system\nIn the previous section we have shown that the Collect algorithm can be used to find marginals. In this section we focus on the solution finding problem (SFP).\nThe problem is of foremost importance, since it lies at the foundation of dynamic programming [10, 2]. Furthermore, problems such as satisfiability, solving Maximum a Posteriori queries in a probabilistic graphical models, or maximum likelihood decoding are particular instances of the SFP.\nWe start by formally defining the problem and then we review the results of Pouly [8] and Pouly and Kohlas [9], who give algorithms for solving those problems and establish the conditions under which those algorithms are guaranteed to work. Unfortunately, although the inspirational ideas underlying Pouly and Kohlas’ work are correct, their formal development is not. Thus, we end up the section providing a counter example to one of their main theorems."
    }, {
      "heading" : "3.1 The SFP for valuation algebras with variable system",
      "text" : "Up to know, the most general formalization of the SFP is the one provided by [10] and adapted by Pouly and Kohlas to the formal framework of valuation algebras in Chapter 8 of [9]. They assume a valuation algebra 〈Φ, D〉 equipped with a variable system 〈V,Ω〉. As in the marginal assessment problem, in the SFP, we are given a set of valuations φ1, . . . , φm ∈ Φ as input. However, instead of a marginal of its combination φ = φ1 × . . .× φm, we are required to provide a tuple x with domain d(φ), such that x is a solution for φ. In order for the previous sentence to make any sense we need to properly define our concept of solution. The most general way in which we can do this is by defining a family c = {cφ|φ ∈ Φ} of solution sets, such that for each valuation φ ∈ Φ, the solution set cφ contains the subset of Ωd(φ) such that x ∈ Ωd(φ) is considered a solution for φ if and only if x ∈ cφ. We say that the family of sets c is a solution concept. Now we can formally define the SFP as follows\nProblem 2 (SFP with variable system). Given a valuation algebra 〈Φ, D〉 equipped with a variable system 〈V,Ω〉 and a solution concept c, and a set\nof valuations φ1, . . . , φm ∈ Φ, find x ∈ Ωd(φ) such that x is a solution for φ = φ1 × . . .× φm."
    }, {
      "heading" : "3.2 Solving the solution finding problem by composing partial solutions",
      "text" : "Several authors have provided algorithms that solve the SFP and characterized under which conditions they can be successfully applied.\nAs described in the introduction, several works have sought to provide a formal foundation to dynamic programming, which we can now identify as a particular case of the SFP. In their works in 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set ∆. They present several algorithms, and characterize the sufficient conditions for its correctness. By dropping the assumption that valuations are functions, their algorithms can be applied to previously uncovered cases .\nEssentially, the sufficient conditions for the correctness of Pouly and Kohlas’ algorithms connect the operations in the valuation algebra with the solution concept by means of a family of configuration extension sets.2A family of configuration extension sets W assigns a configuration extension set to each pair 〈φ,x〉 such that φ is a valuation and x is a tuple whose domain X is a subset of d(φ). That is W = {Wφ(x) ⊆ Ωd(φ)−X |φ ∈ Φ, X ⊆ d(φ),x ∈ ΩX}. Furthermore, a family of configuration extension sets has to satisfy two conditions. The first one connects the projection operation of the valuation algebra with the extension sets by imposing that every extension set can be calculated in two steps. The second one connects the set of solutions of a valuation with the set of extensions of the empty tuple ⋄. These conditions can be stated formally as follows\n1. For each φ ∈ Φ, for each X ⊆ Y ⊆ d(φ) and for each x ∈ ΩX we have that Wφ(x) = {z ∈ Ωd(φ)−X | z ↓Y−X ∈ Wφ↓Y (x) and z ↓d(φ)−Y ∈\nWφ(x, z ↓Y−X)}.\n2. For each φ ∈ Φ, cφ =Wφ(⋄).\nBased on this definition, Pouly and Kohlas state the following theorem\nTheorem 2 (Theorem 8.1 in [9]). For any valuation φ ∈ Φ and any X,Y ⊆ d(φ), we have\nc ↓X∪Y\nφ = {z ∈ ΩX∪Y | z ↓Y ∈ c↓Y φ and z ↓X−Y ∈ Wφ↓X (z ↓X∩Y )}. (1)\nUnfortunately, the theorem is not correct. We will use the valuation algebra on Boolean functions from example 1to build a counterexample for it. Pouly and Kohlas (equation 8.19) defined the extension sets for the algebra of Boolean lattices as Wφ(x) = {y ∈ Ωd(φ)−X | φ(x,y) = φ\n↓X(x)}, where X ⊆ d(φ), x ∈ ΩX .\n2Although they do never formally introduce families of configuration extension sets, we have introduced the concept here for mathematical correctness and so that the reader can easily follow the generalization that will come later on.\nCounterexample 1. Taking φ as the Boolean function φ(x,y) =\n{\n1 if x = y, 0 otherwise ,\nX = {x}, and Y = {y} the result in theorem 2 does not hold.\nTo see why, we can assess both sides of equation 1 and see that they are not the same. For the left hand side, note that c↓X∪Yφ = cφ = Wφ(⋄). Thus, cφ = {(x,y) ∈ ΩX∪Y | φ(x,y) = φ↓∅(⋄)}. We can assess φ↓∅(⋄) = maxx.y φ(⋄, (x,y)) = maxx,y φ(x,y) = 1. Hence, c ↓X∪Y φ = cφ = {(0, 0), (1, 1)}.\nLet A denote the set at the r.h.s. of equation 1. SinceX∩Y = ∅ andX−Y = X, we have that A = {z ∈ ΩX∪Y | z↓Y ∈ c ↓Y φ and z ↓X−Y ∈ Wφ↓X (z ↓X∩Y )} = {z ∈ ΩX∪Y | z↓Y ∈ c ↓Y φ and z ↓X ∈ Wφ↓X (⋄)}. We can assess c ↓Y φ = {z ↓Y | z ∈ cφ} = {(0), (1)}. Furthermore, we have that Wφ↓X (⋄) = {x ∈ ΩX | | φ ↓X(x) = (φ↓X)↓∅(⋄)} = {x ∈ ΩX | φ↓X(x) = φ↓∅(⋄)} = {x ∈ ΩX | φ↓X(x) = 1}. We have that for all x ∈ X, φ↓X(x) = maxy φ(x,y) = 1 , and thus, Wφ↓X (⋄) = ΩX = {0, 1}. Hence, A = {z ∈ ΩX∪Y | z↓Y ∈ ΩY and z↓X ∈ ΩX} = ΩX∪Y = {(0, 0), (0, 1), (1, 0), (1, 1)}} 6= cX∪Yφ , contradicting equation 1.\nSummarizing, in their works [8, 9] in 2011, Pouly and Kohlas make an attempt to generalize the results of Shenoy to valuation algebras equipped with a variable system, not restricting the valuations to be functions into a value set ∆. However, as proved by counterexample 1, one of the key results in their development is not correct. Since the correctness proofs provided by Pouly and Kohlas for their algorithms rely on this result, what could be a minor technical detail ends up having strong consequences for the validity of the theory as a whole.\nThe main objective of the next section is to identify necessary conditions for the application of the algorithms presented by Pouly and Kohlas and to prove that their correctness under those conditions."
    }, {
      "heading" : "4 Even more generic solutions in valuation alge-",
      "text" : "bras\nDuring our efforts to identify the necessary conditions for the application of the algorithms presented by Pouly and Kohlas we realized that nothing in the theory we were building required that the valuation algebra was equipped with a variable system. Thus, as a byproduct of the correction effort, the resulting theory is the first one that proposes a generic algorithm, the so-called Collect+Extend algorithm, to solve the SFP for valuation algebras which are not necessarily equipped with a variable system. The generality of the Collect+Extend algorithm allows it to be applied to valuation algebras such as the algebra of sparse potentials, an example that until now was not covered by any previous formalization.\nWe start this section by generalizing the definition of the SFP problem so that it does not enforces the valuation algebra to be equipped with a variable system. Then, we introduce the concept of piecewise extensibility, and we prove\nthat it is a sufficient condition for the correctness of the Collect+Extend. Finally, we introduce the Collect+ExtendAll algorithm, whose objective is obtaining not a single solution to the SFP, but every solution. We introduced fully piecewise extensibility and prove that it is a sufficient condition for the correctness of the Collect+ExtendAll algorithm."
    }, {
      "heading" : "4.1 A more general solution finding problem",
      "text" : "We start by introducing the concept of configuration system, a generalization of the concept of variable system that does not enforce tuples to be members of a Cartesian product. Then we generalize the SFP to configuration systems.\nConfiguration systems, compatibility and merge-friendliness. We start by relating each element of the domain lattice with a set of configurations, and then we impose a minimal constraint among those sets of configurations, resulting in the notion of configuration system.\nDefinition 4 (Configuration system). Given a lattice D, a configuration system 〈Γ, π〉 is composed of (i) a set of configurations Γs for each s ∈ D and (ii) for each pair of domains s, t ∈ D such that s ≤ t, a surjective mapping πt→s : Γt → Γs. Without loss of generality, the configuration sets are assumed to be mutually exclusive. Furthermore, Γ⊥ = {♦}.\nWhenever x ∈ Γt, we say that x is a configuration with scope t. Given x ∈ Γt, we note xs = πt→s(x).\nIt is easy to see that any variable system is a configuration system. However, there are configuration systems which do not have an equivalent variable system.\nA relevant concept in a configuration system is that of compatibility between configurations.\nDefinition 5 (Compatibility, merger, merge-friendly). Let s, t ∈ D and let x ∈ Γs, and y ∈ Γt. We say that x and y are compatible whenever there is z ∈ Γs∨t such that zs = x and zt = y. We say that such a z is a merger of x and y. The definitions of compatibility and merger can be easily extended to a set of configurations instead of two. A configuration system is merge-friendly if for any s, t ∈ D, any x ∈ Γs, and any y ∈ Γt whenever xs∧t = ys∧t, we have that x and y are compatible.\nWe are interested in merge-friendly configuration systems where a merger of a set of compatible configurations can be efficiently found. For example, in variable systems we can understand each tuple as restricting the values of some variables. Two tuples are compatible when there is no variable to which they assign a different value, and a merger can be easily obtained by imposing simultaneously the restrictions of both tuples.\nThe solution finding problem for valuation algebras with configuration systems. The definition of solution concept can be migrated from variable\nsystem to configuration system. In the latter case, a configuration system is a family c = {cφ|φ ∈ Φ} of solution sets, such that for each valuation φ ∈ Φ, the solution set cφ contains the subset of Γd(φ) such that x ∈ Γd(φ) is considered a solution for φ if and only if x ∈ cφ. The generalization of the solution finding problem is as follows\nProblem 3 (SFP). Given a valuation algebra 〈Φ, D〉 equipped with a configuration system 〈Γ, π〉, and a solution concept c, and a set of valuations φ1, . . . , φm ∈ Φ, find x ∈ Γd(φ) such that x is a solution for φ = φ1 × . . .× φm.\nFollowing Pouly and Kohlas, in order to be able to state the algorithms that solve the SFP we need the solution concept to lie inside a family of configuration extension sets. This connects the configuration system of the domain lattice with the marginalization operation of the valuation algebra and with the solution concept.\nDefinition 6 (Family of configuration extension sets). Given a valuation algebra 〈Φ, D〉, and a configuration system 〈Γ, π〉 over D, and a solution concept c, a family of configuration extension sets is a family of sets E = {Eφ(x)|d ∈ D,φ ∈ Φ,x ∈ Γd}, that\n1. For all φ ∈ Φ, for all x ∈ Γd(φ) ,\nEφ(x) = {x}. (2)\n2. For all φ ∈ Φ, for all s, t ∈ D such that s 6= t and s ≤ t ≤ d(φ), and for all x ∈ Γs ,\nEφ(x) = {y ∈ Γd(φ)|yt ∈ Eφ↓t(x) and y ∈ Eφ(yt)}. (3)\n3. For all φ ∈ Φ, cφ = Eφ(⋄). (4)\nWhenever y ∈ Eφ(x) we say that y is an extension of x to φ. Note that in order for y to be an extension of x, the scope s of x must be smaller than the scope of y. We can extend the definition of extension to a scope u whatsoever: given x ∈ Γu we say that y ∈ Γt is an extension of x to φ if y ∈ Eφ(xt∧u). This states that y is an extension of x if it y is an extension of that part of x which is of interest to φ.\nNext, we introduce the Collect+Extend algorithm. The algorithm can be run on any valuation algebra equipped with a configuration system and a family of configuration extension sets. As the Collect algorithm, the Collect+Extend algorithm requires the existence of a covering join tree for the factorization. It has two different phases. During the first phase, the Collect algorithm is used to obtain the marginal of φ at the root of the tree. After that, during the second phase, the root starts from an empty configuration (⋄), and selects a configuration that belongs to the set of extensions of ⋄ to his marginal. From there on, each node i of the tree receives from his parent p(i) enough\nAlgorithm 2 Extend algorithm Each node i of the junction tree executes\n1: if i is the root then 2: νi ← ⋄ 3: else 4: From its parent pa(i), receive a message νi. 5: end if 6: ⊲ Extend the parent solution to i’s scope. 7: Select ηi ∈ Eψ′\ni (νi).\n8: for all j children of i do 9: Send message νj = πdi→s(j)(ηi) to children j. 10: end for\ninformation from the configuration selected by p(i) so that i can successfully extend it to his domain configuration set. We call this second phase the Extend phase. Algorithm 2 describes it in a more precise way. At the end of the Extend phase, each node i of the tree has a configuration ηi over its domain. Provided that these configurations are compatible, we get a single configuration in Γd(φ) by assessing its merger.\n4.2 Sufficient conditions for the correctness of the Col-\nlect+Extend algorithm\nIn this section we consider the problem of determining under which conditions the configuration assessed by the Collect+Extend algorithm is a solution to the SFP problem. The main result is the following theorem\nTheorem 3 (Collect+Extend suff. cond.). Let 〈Φ, D〉 be a valuation algebra equipped with a merge-friendly configuration system 〈Γ, φ〉, and a solution concept c. Let E be a piecewise extensible family of configuration extension sets. After running the Collect algorithm followed by the Extend algorithm (Algorithms 1 and 2) over the nodes of a covering join tree T for φ = ∏n\nk=1 φk, we have that there is at least a merger z of {ηi|i ∈ V }, and that z is a solution of φ.\nThe theorem requires the family of configuration extension sets E to be piecewise extensible. Next, we define piecewise extensibility and then we prove that it is a sufficient condition for the correctness of the Collect+Extend algorithm.\nPiecewise extensibility Intuitively, this means requiring that whenever a configuration z independently belongs to the set of extensions of two different valuations φ1 and φ2, then it does belong to the set of extensions to its product.\nDefinition 7. A configuration x (with scope s) is extensible to a valuation φ (with domain t) whenever Eφ(xs∧t) 6= ∅. For any z ∈ Eφ(xs∧t), we say that z is an extension of x to φ.\nA family of configuration extension sets E is piecewise extensible when for any two valuations φ1, φ2 ∈ Φ with d1 = d(φ1) and d2 = d(φ2), any t ∈ D, d1 ∨ d2 ≥ t ≥ d1 ∧ d2, any x ∈ Γt and any extension z of x to both φ1 and φ2 , we have that z is an extension of x to φ1 × φ2.\nNote that the piecewise extensibility requirement is defined only for pairs of valuations φ1 and φ2. The following lemma shows that provided that we have piecewise extensibility for two valuations, we can extend it to products of m valuations.\nLemma 1. Let (i) E be a piecewise extensible family of configuration extension sets, (ii) φ1, . . . , φm ∈ Φ, and φ = ∏m i=1 φi, and (iii) t ∈ D, such that ∨m i=1 di ≥ t ≥ ∨m\ni=1 ri, where ri = di∧ ( ∨ j 6=i dj ) , and di = d(φi). For any x ∈ Γt and any\nextension z of x to φ1, . . . , φm we have that z is an extension of x to φ.\nProof. By induction on the number of terms m. If m = 2, the result follows directly from the definition of piecewise extensible. Assume it is true for m < M, and prove it for m = M. We have that φ = ∏M\ni=1 φi.We can break it as φ = φ1× ∏M i=2 φi = φ1×ξ, making ξ = ∏M i=2 φi. We know z is an extension of x to φ1.We can apply the induction hypothesis to ξ = ∏M\ni=2 φi, to show that z is also an extension of x to ξ and then we apply piecewise extensibility to conclude that z is an extension of x to φ.\nIn order to apply the induction hypothesis, we take ξ = ∏M i=2 φi, and t ′ =\nt∧d(ξ). It is easy to see that ∨M i=2 di = d(ξ) ≥ t∧d(ξ) = t ′. On the other hand, t′ ≥ ∨M i=2 ri. Since z is an extension of xt′ to φ2, . . . , φM , we have that for each i, z ∈ Eφi(xsi), where si = t ∧ di.\nNote that d(ξ) = ∨M i=2 di. Take t ′ = t ∧ d(ξ). We can see that ∨M i=2 di ≥\nt′ ≥ ∨M i=2 ri. Furthermore, for i 6= 1, we have that s ′ i = t ′ ∧ di = t ∧ d(ξ) ∧ di = t ∧ ( ∨M\ni=2 di) ∧ di = t ∧ di = si, and hence z is an extension of z ∈ Eφi(xs′i ). Applying the induction hypothesis we have that zd(ξ) ∈ Eξ(xt′) = Eξ(xt∧d(ξ)).\nThe conditions to apply piecewise extensibility to φ1 × ξ are now in place.\nObserve that d1 ∨ d(ξ) ≥ t ≥ ( ∨M\ni=2 di\n)\n∧ d1 = d(ξ) ∧ d1, that zd1 ∈ Eφ1(xs1 ),\nand that zd(ξ) ∈ Eξ(xt∧d(ξ)). Since E is piecewise extensible we have that z is an extension of x to φ.\nSufficient condition for the correctness of Collect+Extend. Next, we see that on piecewise extensible family of configuration extension sets, it is possible to take benefit of the factorization of the valuation to find a solution by merging partial solutions to the different factors which are coherent between them. We start by proving this for a product of two valuations and a product of m valuations. Then we apply those results to prove that the Collect+Extend algorithm is correct.\nWe start proving the following lemma, that shows that provided we have piecewise extensibility, for any valuation that is the product of two factors, if\nwe are given a solution to the projection of the product to the domain of one of the factors and an extension of that solution to the second factor, the merger of these two is a solution to the product.\nLemma 2. Let E be a piecewise extensible family of configuration extension sets. Let φ1, φ2 ∈ Φ, and let d1 = d(φ1), d2 = d(φ2), and φ = φ1 × φ2. For any x ∈ cφ↓d1 ,any extension y of x to φ2, and any merger z of x and y, we have that z ∈ cφ.\nProof. First, we will use piecewise extensibility to prove that z ∈ Eφ(x). To do that we apply definition 7 with t = d1. By hypothesis, we have that zd2 = y ∈ Eφ2(xd2∧d1). From equation 2, we have that Eφ1(x) = {x}. Hence, zd1 = x ∈ Eφ1(x). Thus, z is a coherent extension of x to both φ1 and φ2 and we can apply piecewise extensibility to conclude that z ∈ Eφ(x).\nThen, we can jointly apply equations 4 and 3 to conclude that z ∈ cφ = Eφ(⋄).\nAs in the previous section, we can generalize this result to products of m valuations.\nLemma 3. Let E be a piecewise extensible family of configuration extension sets. Let φ = φρ × ∏m i=1 φi, with di = d(φi), dρ = d(φρ), ri = di∧ ( ∨ j 6=i dj ) , and dρ ≥ ∨m\ni=1 ri. Given x ∈ cφ↓dρ , for each 1 ≤ i ≤ m, yi an extension of x to φi, and any merger z of x and y1, . . . ,ym, we have that z ∈ cφ.\nProof. Let By induction on m. If m = 1, we can directly apply Lemma 2. Assume it is true form < M.We have to prove that it is true form =M. Let ξ = ∏m i=1 φi. First, we will prove that zdξ ∈ Eξ(xdρ∧dξ) and then we will apply Lemma 2. To see that zdξ ∈ Eξ(xdρ∧dξ), we apply Lemma 1 with t = dρ ∧ dξ. We need to verify that ∨m\ni=1 di ≥ t ≥ ∨m\ni=1 ri. The left inequality is satisfied since t = dρ∧dξ = dρ∧( ∨m i=1 di) ≤ ∨m i=1 di. Since for all i, ri ≤ dξ, we have that ∨m\ni=1 ri ≤ dξ. Since by hypothesis we have that dρ ≥ ∨m\ni=1 ri, we can conclude that dρ ∧ dξ ≥ ∨m\ni=1 ri.\nFurthermore we can verify that for each i ∈ {1, . . . ,m}, zdi = yi ∈ Eφi(xt∧di). Note that t∧di = dρ ∧dξ ∧di = dρ ∧ ( ∨m\ni=1 di)∧di = dρ ∧di, and by hypothesis we have that zdi = yi ∈ Eφi(xdρ∧di,).\nApplying Lemma 1, we get that zdξ ∈ Eξ(xdρ∧dξ) and since by hypothesis we have that x ∈ cφ↓dρ , we can conclude from Lemma 2 that z ∈ cφρ×φξ = cφ.\nThe former results allow us to state the following theorem (the main result of the section) proving that when a valuation breaks as a product of smaller valuations, the Collect+Extend algorithm can be used to assess a solution to it.\nTheorem 3 (Collect+Extend suff. cond.). Let 〈Φ, D〉 be a valuation algebra equipped with a merge-friendly configuration system 〈Γ, φ〉, and a solution concept c. Let E be a piecewise extensible family of configuration extension\nsets. After running the Collect algorithm followed by the Extend algorithm (Algorithms 1 and 2) over the nodes of a covering join tree T for φ = ∏n\nk=1 φk, we have that there is at least a merger z of {ηi|i ∈ V }, and that z is a solution of φ.\nProof. By induction on the number of nodes of the junction tree. If the junction tree has only one node then the proof is trivial.\nAssume that the junction tree has m > 1 nodes. We can see that the conditions to apply Lemma 3 are satisfied at the root.\n1. φ = ψρ × ∏ i∈Children(ρ) ξi, where ξi = ∏ j∈Ti ψi. Let d ′ i = d(ξi)\n2. For each i, j ∈ Children(ρ) such that i 6= j, due to the running intersection\nproperty we have that dρ ≥ d′i ∧ ( ∨ j 6=i d ′ j ) .\n3. x ∈ cφ↓dρ .\n4. For each i ∈ Children(ρ), yi ∈ Eξi(xdρ∧d′i)\n5. z is a merger of x and each of the y′is\nAs a consequence of lemma 3, we can conclude that z ∈ cφ.\nFully piecewise extensibility and assessing all solutions. By strengthening the concept of piecewise extensibility, we can use an algorithm similar to Collect+Extend to assess all solutions instead of only one. The strengthening is named fully piecewise extensibility.\nDefinition 8. A family of configuration extension sets E is fully piecewise extensible when for any two valuations φ1, φ2 ∈ Φ with d1 = d(φ1) and d2 = d(φ2), any t ∈ D, d1 ∨ d2 ≥ t ≥ d1 ∧ d2, any x ∈ Γt and any z, we have that z is an extension of x to both φ1 and φ2 , if and only if z is an extension of x to φ1 × φ2.\nThe algorithm and the theorem that shows that this is a sufficient condition are omitted due to lack of space but can be derived without effort."
    }, {
      "heading" : "5 Conclusions",
      "text" : "We have corrected and generalized the theory and algorithms for the generic construction of solutions in valuation based systems. To the best of our knowledge, these results provide the most general theory for dynamic programming up-to-date, covering commonly used examples such as finding the maximum of a combination of sparse functions, which the current theory did not cover."
    } ],
    "references" : [ {
      "title" : "Dynamic Programming",
      "author" : [ "R.E. Bellman" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1957
    }, {
      "title" : "Nonserial Dynamic Programming, volume 91 of Mathematics in Science and Engineering",
      "author" : [ "Umberto Bertelè", "Francesco Brioschi" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1972
    }, {
      "title" : "Introduction to lattices and order",
      "author" : [ "B.A. Davey", "H.A. Priestley" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2008
    }, {
      "title" : "Lattice Theory: Foundation",
      "author" : [ "George Grätzer" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2011
    }, {
      "title" : "Semiring induced valuation algebras: Exact and approximate local computation algorithms",
      "author" : [ "J Kohlas", "N Wilson" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2008
    }, {
      "title" : "Composition Principles for Synthesis of Optimal Multistage Processes",
      "author" : [ "L.G. Mitten" ],
      "venue" : "Operations Research,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1964
    }, {
      "title" : "Introduction to Dynamic Programming",
      "author" : [ "George L. Nemhauser" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1966
    }, {
      "title" : "Generic solution construction in valuation-based systems",
      "author" : [ "Marc Pouly" ],
      "venue" : "Advances in Artificial Intelligence,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2011
    }, {
      "title" : "Generic Inference",
      "author" : [ "Marc Pouly", "Jürg Kohlas" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Axioms for Dynamic Programming",
      "author" : [ "Prakash P Shenoy" ],
      "venue" : "Computational Learning and Probabilistic Reasoning,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "Recently, formal requirements for the presence of solutions and a generic algorithm for solution construction based on the results of a previously executed inference scheme have been proposed [9, 8].",
      "startOffset" : 192,
      "endOffset" : 198
    }, {
      "referenceID" : 7,
      "context" : "Recently, formal requirements for the presence of solutions and a generic algorithm for solution construction based on the results of a previously executed inference scheme have been proposed [9, 8].",
      "startOffset" : 192,
      "endOffset" : 198
    }, {
      "referenceID" : 8,
      "context" : "As a result, we get a more general and corrected version of the theory presented at [9, 8].",
      "startOffset" : 84,
      "endOffset" : 90
    }, {
      "referenceID" : 7,
      "context" : "As a result, we get a more general and corrected version of the theory presented at [9, 8].",
      "startOffset" : 84,
      "endOffset" : 90
    }, {
      "referenceID" : 1,
      "context" : "One particular approach to tackle them is known as dynamic programming [2] and can be found in almost every handbook about algorithms and programming techniques.",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 0,
      "context" : "The works of Bellman [1], Nemhauser [7] and Bertelè and Brioschi [2] present non-serial dynamic programming as an algorithm for optimization problems for functions taking values in the real numbers.",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 6,
      "context" : "The works of Bellman [1], Nemhauser [7] and Bertelè and Brioschi [2] present non-serial dynamic programming as an algorithm for optimization problems for functions taking values in the real numbers.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 1,
      "context" : "The works of Bellman [1], Nemhauser [7] and Bertelè and Brioschi [2] present non-serial dynamic programming as an algorithm for optimization problems for functions taking values in the real numbers.",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 5,
      "context" : "A more general approach was taken by Mitten [6] and further generalized by Shenoy in 1996 [10], for functions taking values in any ordered set ∆.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 9,
      "context" : "A more general approach was taken by Mitten [6] and further generalized by Shenoy in 1996 [10], for functions taking values in any ordered set ∆.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 8,
      "context" : "In 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set ∆.",
      "startOffset" : 26,
      "endOffset" : 32
    }, {
      "referenceID" : 7,
      "context" : "In 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set ∆.",
      "startOffset" : 26,
      "endOffset" : 32
    }, {
      "referenceID" : 3,
      "context" : "Let D be a lattice[4] with a partial order≤, two operations meet ∧ and join ∨, a top element ⊤, and a bottom element ⊥.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 8,
      "context" : "As proven in [9], any valuation algebra that does not have and identity valuation can easily be extended to have one.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 2,
      "context" : "[3] page 36) that for any set V, the ordered set 〈P(V ),⊆〉 is a complete lattice, referred to as the power set lattice.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "As proven in [9] the valuation algebra of Boolean functions satisfies axioms A1-A6.",
      "startOffset" : 13,
      "endOffset" : 16
    }, {
      "referenceID" : 4,
      "context" : "Some other relevant examples of valuation algebras are relational algebra, which is fundamental to databases, or the algebra of probability potentials, which underlies many results in probabilistic graphical models and the more abstract class of semiring induced valuation algebras [5].",
      "startOffset" : 282,
      "endOffset" : 285
    }, {
      "referenceID" : 9,
      "context" : "The Fusion algorithm [10] (a.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 8,
      "context" : "junction tree or cluster tree algorithm)[9, 8] can be used to find marginals.",
      "startOffset" : 40,
      "endOffset" : 46
    }, {
      "referenceID" : 7,
      "context" : "junction tree or cluster tree algorithm)[9, 8] can be used to find marginals.",
      "startOffset" : 40,
      "endOffset" : 46
    }, {
      "referenceID" : 8,
      "context" : "6 in [9].",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 9,
      "context" : "The problem is of foremost importance, since it lies at the foundation of dynamic programming [10, 2].",
      "startOffset" : 94,
      "endOffset" : 101
    }, {
      "referenceID" : 1,
      "context" : "The problem is of foremost importance, since it lies at the foundation of dynamic programming [10, 2].",
      "startOffset" : 94,
      "endOffset" : 101
    }, {
      "referenceID" : 7,
      "context" : "We start by formally defining the problem and then we review the results of Pouly [8] and Pouly and Kohlas [9], who give algorithms for solving those problems and establish the conditions under which those algorithms are guaranteed to work.",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 8,
      "context" : "We start by formally defining the problem and then we review the results of Pouly [8] and Pouly and Kohlas [9], who give algorithms for solving those problems and establish the conditions under which those algorithms are guaranteed to work.",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 9,
      "context" : "Up to know, the most general formalization of the SFP is the one provided by [10] and adapted by Pouly and Kohlas to the formal framework of valuation algebras in Chapter 8 of [9].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 8,
      "context" : "Up to know, the most general formalization of the SFP is the one provided by [10] and adapted by Pouly and Kohlas to the formal framework of valuation algebras in Chapter 8 of [9].",
      "startOffset" : 176,
      "endOffset" : 179
    }, {
      "referenceID" : 8,
      "context" : "In their works in 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set ∆.",
      "startOffset" : 41,
      "endOffset" : 47
    }, {
      "referenceID" : 7,
      "context" : "In their works in 2011, Pouly and Kohlas [9, 8] drop the assumption that valuations are functions that map tuples into a value set ∆.",
      "startOffset" : 41,
      "endOffset" : 47
    }, {
      "referenceID" : 8,
      "context" : "1 in [9]).",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 7,
      "context" : "Summarizing, in their works [8, 9] in 2011, Pouly and Kohlas make an attempt to generalize the results of Shenoy to valuation algebras equipped with a variable system, not restricting the valuations to be functions into a value set ∆.",
      "startOffset" : 28,
      "endOffset" : 34
    }, {
      "referenceID" : 8,
      "context" : "Summarizing, in their works [8, 9] in 2011, Pouly and Kohlas make an attempt to generalize the results of Shenoy to valuation algebras equipped with a variable system, not restricting the valuations to be functions into a value set ∆.",
      "startOffset" : 28,
      "endOffset" : 34
    } ],
    "year" : 2014,
    "abstractText" : "Valuation algebras abstract a large number of formalisms for automated reasoning and enable the definition of generic inference procedures. Many of these formalisms provide some notions of solutions. Typical examples are satisfying assignments in constraint systems, models in logics or solutions to linear equation systems. Recently, formal requirements for the presence of solutions and a generic algorithm for solution construction based on the results of a previously executed inference scheme have been proposed [9, 8]. Unfortunately, the formalization of Pouly and Kohlas relies on a theorem for which we provide a counter example. In spite of that, the mainline of the theory described is correct, although some of the necessary conditions to apply some of the algorithms have to be revised. To fix the theory, we generalize some of their definitions and provide correct sufficient conditions for the algorithms. As a result, we get a more general and corrected version of the theory presented at [9, 8].",
    "creator" : "LaTeX with hyperref package"
  }
}