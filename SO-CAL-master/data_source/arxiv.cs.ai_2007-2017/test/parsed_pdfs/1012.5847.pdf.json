{
  "name" : "1012.5847.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On Elementary Loops of Logic Programs",
    "authors" : [ "Martin Gebser", "Joohyung Lee", "Yuliya Lierler" ],
    "emails" : [ "gebser@cs.uni-potsdam.de)", "joolee@asu.edu)", "yuliya@cs.uky.edu)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n01 2.\n58 47\nKEYWORDS: stable model semantics, loop formulas, unfounded sets"
    }, {
      "heading" : "1 Introduction",
      "text" : "The theorem on loop formulas due to Lin and Zhao (2004) has contributed to understanding the relationship between the stable model semantics and classical logic. Unlike other translations that modify the vocabulary of a logic program (Ben-Eliyahu and Dechter 1994; Lin and Zhao 2003; Janhunen 2006), the original\ntheorem on loop formulas characterizes the stable models of a nondisjunctive program in terms of the models of its completion that satisfy the loop formulas of all loops of the program. This allows us to compute stable models using SAT solvers, which led to the design of answer set solvers assat1 (Lin and Zhao 2004) and cmodels2 (Giunchiglia et al. 2004). Due to its importance in semantic understanding as well as in stable model computation, the theorem on loop formulas has been extended to more general classes of logic programs, such as disjunctive programs (Lee and Lifschitz 2003), infinite programs and programs containing classical negation (Lee 2005), and programs containing aggregates (Liu and Truszczynski 2006; You and Liu 2008; Lee and Meng 2009). Moreover, it has been applied to other nonmonotonic logics, such as circumscription (Lee and Lin 2006) and nonmonotonic causal logic (Lee 2004). The stable model semantics for first-order formulas given in (Ferraris et al. 2007; Ferraris et al. 2011) is also closely related to the idea of loop formulas, as described in (Lee and Meng 2008).\nBy slightly modifying the definition of a loop, Lee (2005) showed that loop formulas can be viewed as a generalization of completion (Clark 1978). The modeltheoretic account of loop formulas give in (Lee 2005) also tells us that the idea of loop formulas is closely related to assumption sets (Saccá and Zaniolo 1990) or unfounded sets (Leone et al. 1997). In a sense, the theorem by Lin and Zhao is an enhancement of the unfounded set based characterization of stable models given in (Saccá and Zaniolo 1990; Leone et al. 1997). The unfounded set based characterization takes into account the loop formulas of all sets of atoms, while the theorem by Lin and Zhao considers the loop formulas of loops only. Gebser and Schaub (2005) improved this enhancement even further. They defined the notion of an elementary loop of a nondisjunctive program and showed that the theorem by Lin and Zhao remains correct even if we consider loop formulas of elementary loops only.\nIn this article, we reformulate the definition of an elementary loop of a nondisjunctive program by Gebser and Schaub, extend it to disjunctive programs, and study several properties of elementary loops, including how maximal elementary loops are related to minimal unfounded sets. Based on the notion of an elementary loop, we present the class of Head-Elementary-loop-Free (HEF) program, which strictly generalizes the class of Head-Cycle-Free (HCF) programs due to Ben-Eliyahu and Dechter (1994). Like an HCF program, an HEF program can be turned into an equivalent nondisjunctive program in polynomial time by shifting head atoms into the body—a simple transformation defined in (Gelfond et al. 1991). This tells us that an HEF program is an “easy” disjunctive program, which is merely a syntactic variant of a nondisjunctive program. We also observe that several other properties of nondisjunctive and HCF programs can be generalized to HEF programs. The main results from (Lin and Zhao 2003) and (You et al. 2003), characterizing stable models in terms of inherent tightness and weak tightness, respectively, can be extended to HEF programs, and likewise the operational characterization of stable models of HCF programs due to Leone et al. (1997) can be extended to HEF pro-\n1 http://assat.cs.ust.hk/ 2 http://www.cs.utexas.edu/users/tag/cmodels/\ngrams. The properties of elementary loops and HEF programs studied here may be useful in improving the computation of disjunctive answer set solvers, such as claspd3 (Drescher et al. 2008), cmodels (Lierler 2005), dlv4 (Leone et al. 2006), and gnt5 (Janhunen et al. 2006).\nThe outline of this paper is as follows. In Section 2, we present our reformulated definition of an elementary loop of a nondisjunctive program and provide a corresponding refinement of the theorem on loop formulas, as well as some properties of elementary loops. These results are extended to disjunctive programs in Section 3. In Section 4, we introduce the class of HEF programs and show that their shifted variants preserve stable models. In Section 5, we generalize the notion of inherent tightness to HEF programs. An operational characterization of stable models of HEF programs is presented in Section 6. Finally, Section 7 concludes the paper.\nThis paper is an extended version of the conference papers (Gebser et al. 2006)\nand (Gebser et al. 2007).6"
    }, {
      "heading" : "2 Nondisjunctive Programs",
      "text" : "After providing the relevant background on nondisjunctive programs, this section introduces elementary loops of nondisjunctive programs. We further refine elementary loops to elementarily unfounded sets, yielding a syntactic characterization of minimal unfounded sets. Moreover, we show that elementary loops of nondisjunctive programs can be recognized in polynomial time. (The statements of the theorems and the propositions in this section which apply to nondisjunctive programs will be generalized to disjunctive programs or HEF programs in later sections and the proofs will be given there.) Finally, we compare our reformulation of elementary loops with the definition by Gebser and Schaub (2005)."
    }, {
      "heading" : "2.1 Background",
      "text" : "A nondisjunctive rule is an expression of the form\na1 ← a2, . . . , am, not am+1 , . . . , not an (1)\nwhere n ≥ m ≥ 1 and a1, . . . , an are propositional atoms. A nondisjunctive program is a finite set of nondisjunctive rules.\nWe will identify a nondisjunctive rule (1) with the propositional formula\na2 ∧ · · · ∧ am ∧ ¬am+1 ∧ · · · ∧ ¬an → a1 , (2)\nand will often write (1) as\na1 ← B,F (3)\n3 http://potassco.sourceforge.net/ 4 http://www.dbai.tuwien.ac.at/proj/dlv/ 5 http://www.tcs.hut.fi/Software/gnt/ 6 In (Gebser et al. 2006; Gebser et al. 2007), the term “elementary set” was used in place of “elementary loop.”\np qr s q\ni\n)\n1\nFig. 1. The dependency graph of Program Π1\nwhere B is a2, . . . , am and F is not am+1 , . . . , not an . We will sometimes identify B with its corresponding set of atoms.\nWe will identify an interpretation with the set of atoms that are true in it. We say that a set X of atoms satisfies a rule (1) if X satisfies (2). Moreover, X satisfies a nondisjunctive program Π (symbolically, X |= Π) if X satisfies every rule (1) of Π. If X satisfies Π, we also call X a model of Π.\nThe reduct ΠX of a nondisjunctive program Π w.r.t. a set X of atoms is obtained from Π by deleting each rule (3) such that X 6|= F , and replacing each remaining rule (3) with a1 ← B. A set X of atoms is a stable model, also called an answer set, of Π if X is minimal among the sets of atoms that satisfy ΠX .\nThe (positive) dependency graph of a nondisjunctive program Π is the directed graph such that its vertices are the atoms occurring in Π, and its edges go from a1 to a2, . . . , am for all rules (1) of Π. A nonempty set Y of atoms is called a loop of Π if, for every pair a, b of atoms in Y , there is a path (possibly of length 0) from a to b in the dependency graph of Π such that all vertices in the path belong to Y . In other words, a nonempty set Y of atoms that occur in Π is a loop of Π if the subgraph of the dependency graph of Π induced by Y is strongly connected. It is clear that every singleton whose atom occurs in Π is a loop of Π.\nFor illustration, consider the following program Π1:\np ← not s p ← r q ← r r ← p, q .\nFigure 1 shows the dependency graph of Π1. Program Π1 has seven loops: {p}, {q}, {r}, {s}, {p, r}, {q, r}, and {p, q, r}.\nFor any set Y of atoms, the external support formula of Y for a nondisjunctive program Π, denoted by ESΠ(Y ), is the disjunction of conjunctions B ∧ F for all rules (3) of Π such that a1 ∈ Y and B ∩ Y = ∅. The first condition expresses that the atom “supported” by (3) is an element of Y . The second condition ensures that this support is “external”: the atoms in B that it relies on do not belong to Y . Thus, Y is called externally supported by Π w.r.t. a set X of atoms if X |= ESΠ(Y ).\nFor any set Y of atoms, by LFΠ(Y ), we denote the following formula:\n∧\na∈Y\na → ESΠ(Y ) . (4)\n(The expression in the antecedent stands for the conjunction of all elements in Y .) Formula (4) is called the (conjunctive) loop formula of Y for Π. Note that we still call (4) a loop formula even when Y is not a loop of Π.\nThe following reformulation of the Lin-Zhao theorem, which characterizes the\nstability of a model by loop formulas, is a part of the main theorem from (Lee 2005) for the nondisjunctive case.\nTheorem 1 ((Lee 2005))\nFor any nondisjunctive program Π and any set X of atoms that occur in Π, if X is a model of Π, then the following conditions are equivalent:\n(a) X is a stable model of Π;\n(b) X satisfies LFΠ(Y ) for all nonempty sets Y of atoms that occur in Π; (c) X satisfies LFΠ(Y ) for all loops Y of Π.\nAccording to the equivalence between conditions (a) and (b) in Theorem 1, a model of Π1 is stable iff it satisfies the loop formulas of all fifteen nonempty sets of atoms formed from the atoms occurring in Π1. On the other hand, condition (c) tells us that it is sufficient to restrict attention to the following loop formulas of the seven loops of Π1:\np → ¬s ∨ r q → r r → p ∧ q s → ⊥ p ∧ r → ¬s q ∧ r → ⊥ p ∧ q ∧ r → ¬s .\n(5)\nProgram Π1 has six models: {p}, {s}, {p, s}, {q, s}, {p, q, r}, and {p, q, r, s}. Among them, {p} is the only stable model of Π1, which is also the only model of Π1 that satisfies all loop formulas in (5).\nAs noted in (Lee 2005), the equivalence between conditions (a) and (c) is a reformulation of the theorem by Lin and Zhao; the equivalence between conditions (a) and (b) is a reformulation of Corollary 2 from (Saccá and Zaniolo 1990) and Theorem 4.6 from (Leone et al. 1997) (in the nondisjunctive case), which characterizes the stability of a model in terms of unfounded sets. For any sets X , Y of atoms, we say that Y is unfounded by Π w.r.t. X if Y is not externally supported by Π w.r.t. X . Condition (b) can be stated in terms of unfounded sets as follows:\n(b′) X contains no nonempty unfounded sets for Π w.r.t. X ."
    }, {
      "heading" : "2.2 Elementary Loops of Nondisjunctive Programs",
      "text" : "Gebser and Schaub (2005) showed that Y in LFΠ(Y ) in Theorem 1 can be restricted to “elementary” loops only. In this section, we present a reformulation of their definition of an elementary loop and investigate its properties. We compare our reformulation with the original definition by Gebser and Schaub in Section 2.5.\nTo begin with, the following proposition tells us that a loop can be defined without\nmentioning a dependency graph.\nProposition 1 For any nondisjunctive program Π and any nonempty set X of atoms that occur in Π, X is a loop of Π iff, for every nonempty proper subset Y of X , there is a rule (3) in Π such that a1 ∈ Y and B ∩ (X \\ Y ) 6= ∅.\nFor any set X of atoms and any subset Y of X , we say that Y is outbound in X\nfor a nondisjunctive program Π if there is a rule (3) in Π such that\n• a1 ∈ Y , • B ∩ (X \\ Y ) 6= ∅, and • B ∩ Y = ∅.\nThe following proposition describes the relationship between the external support\nformula of a set Y of atoms and the external support formula of a subset Z of Y that is not outbound in Y .\nProposition 2 For any nondisjunctive program Π and any sets X , Y , Z of atoms such that Z ⊆ Y ⊆ X , if Z is not outbound in Y for Π and X |= ESΠ(Z), then X |= ESΠ(Y ).\nProposition 2 tells us that, in order to verify that a set Y of atoms is externally supported by Π w.r.t. a superset X of Y , it is sufficient to identify some externally supported subset of Y that is not outbound in Y for Π. Conversely, if Y is not externally supported by Π w.r.t. X , then every subset of Y that is externally supported by Π w.r.t. X is outbound in Y for Π.\nFor any nonempty set X of atoms that occur in Π, we say that X is an elementary loop of Π if all nonempty proper subsets of X are outbound in X for Π. As with loops, it is clear from the definition that every singleton whose atom occurs in Π is an elementary loop of Π. It is also clear that every elementary loop of Π is a loop of Π: the condition for being an elementary loop implies the condition for being a loop as stated in Proposition 1. On the other hand, a loop is not necessarily an elementary loop. For instance, one can check that {p, q, r} is not an elementary loop of Π1 since {p, r} (or {q, r}) is not outbound in {p, q, r} for Π1. All other loops of Π1 are elementary loops. Note that an elementary loop may be a proper subset of another elementary loop (both {p} and {p, r} are elementary loops of Π1).\nThe following program replaces the last rule of Π1 with two other rules:\np ← not s p ← r q ← r r ← p r ← q .\n(6)\nThe program has the same dependency graph as Π1, and hence has the same loops. However, its elementary loops are different from those of Π1: all its loops are elementary loops as well, including {p, q, r}.\nThe definition of an elementary loop X given above is not affected if we check the outboundness condition only for all loops or for all elementary loops that belong to X instead of all nonempty proper subsets of X .\nProposition 3 For any nondisjunctive program Π and any nonempty set X of atoms that occur in Π, X is an elementary loop of Π iff all proper subsets of X that are elementary loops of Π are outbound in X for Π.\nThe following proposition describes an important relationship between loop for-\nmulas of elementary loops and loop formulas of arbitrary sets of atoms.\nProposition 4 For any nondisjunctive program Π and any nonempty set Y of atoms that occur in Π, there is an elementary loop Z of Π such that Z is a subset of Y and LFΠ(Z) entails LFΠ(Y ).\nProposition 4 allows us to limit attention to loop formulas of elementary loops only. This yields the following theorem, which is a reformulation of Theorem 3 from (Gebser and Schaub 2005).\nTheorem 1 (d) The following condition is equivalent to each of conditions (a)–(c) in Theorem 1:\n(d) X satisfies LFΠ(Y ) for all elementary loops Y of Π.\nFor instance, according to Theorem 1 (d), a model of Π1 is stable iff it satisfies the first six loop formulas in (5); the loop formula of the non-elementary loop {p, q, r} (the last one in (5)) can be disregarded."
    }, {
      "heading" : "2.3 Elementarily Unfounded Sets for Nondisjunctive Programs",
      "text" : "If we modify condition (c) in Theorem 1 by replacing “loops” in its statement with “maximal loops,” the condition becomes weaker, and the modified statement of Theorem 1 is incorrect. For instance, Π1 has only two maximal loops, {p, q, r} and {s}, and their loop formulas are satisfied by a non-stable model {p, q, r}. In fact, maximal loop {p, q, r} is not even an elementary loop of Π1. Similarly, it is not sufficient to consider maximal elementary loops only. If we replace “elementary loops” in the statement of Theorem 1 (d) with “maximal elementary loops,” then the modified statement is incorrect. For instance, the program\np ← q, not p q ← p, not p p ← .\nhas two models, {p} and {p, q}, among which the latter is not stable. On the other hand, the only maximal elementary loop of the program is {p, q}, and its loop formula p ∧ q → ⊤ is satisfied by both models, so that this loop formula alone is not sufficient to refute the stability of {p, q}. (Model {p, q} does not satisfy the loop formula of {q}, which is q → p ∧ ¬p.)\nHowever, in the following we show that, if we consider the “relevant” part of a program w.r.t. a given interpretation, it is sufficient to restrict attention to maximal elementary loops. For any nondisjunctive program Π and any set X of atoms, by\nΠX , we denote the set of all rules (3) of Π such that X |= B,F . The following proposition states that all nonempty proper subsets of an elementary loop of ΠX are externally supported by Π w.r.t. X .\nProposition 5 For any nondisjunctive program Π, any set X of atoms, and any elementary loop Y of ΠX , X satisfies ESΠ(Z) for all nonempty proper subsets Z of Y .\nProposition 5 tells us that any elementary loop Y of ΠX that is unfounded by Π w.r.t. X is maximal among the elementary loops of ΠX . From this, we obtain the following result.\nTheorem 1 (e) The following condition is equivalent to each of conditions (a)–(c) in Theorem 1:\n(e) X satisfies LFΠ(Y ) for every set Y of atoms such that Y is\n— a maximal elementary loop of ΠX , or — a singleton whose atom occurs in Π.\nGiven a nondisjunctive program Π and a set X of atoms, we say that a set Y of\natoms that occur in Π is elementarily unfounded by Π w.r.t. X if Y is\n• an elementary loop of ΠX that is unfounded by Π w.r.t. X or • a singleton that is unfounded by Π w.r.t. X .7\nProposition 5 tells us that any non-singleton elementarily unfounded set for Π w.r.t. X is a maximal elementary loop of ΠX .\nIt is clear from the definition that every elementarily unfounded set for Π w.r.t. X is an elementary loop of Π and that it is also unfounded by Π w.r.t. X . However, the converse does not hold in general. For instance, {p, q} is an elementary loop that is unfounded by the program\np ← q, not r q ← p, not r\nw.r.t. {p, q, r}, but {p, q} is not an elementarily unfounded set w.r.t. {p, q, r}.\nThe following corollary, which follows from Proposition 5, states that all nonempty proper subsets of an elementarily unfounded set are externally supported. It is essentially a reformulation of Theorem 5 from (Gebser and Schaub 2005).\nCorollary 1 For any nondisjunctive program Π, any set X of atoms, and any elementarily unfounded set Y for Π w.r.t. X , X does not satisfy ESΠ(Y ), but satisfies ESΠ(Z) for all nonempty proper subsets Z of Y .\nCorollary 1 tells us that elementarily unfounded sets form an “anti-chain”: one of them cannot be a proper subset of another. (On the other hand, an elementary loop may contain another elementary loop as its proper subset.) Also it tells us that elementarily unfounded sets are minimal among the nonempty unfounded sets occurring in Π. Interestingly, the converse also holds.\n7 Elementarily unfounded sets are closely related to “active elementary loops” defined in (Gebser and Schaub 2005). We further investigate this relationship in Section 2.5.\nTheorem 2\nFor any nondisjunctive program Π and any sets X , Y of atoms, Y is an elementarily unfounded set for Π w.r.t. X iff Y is minimal among the nonempty sets of atoms occurring in Π that are unfounded by Π w.r.t. X .\nNotably, the correspondence between elementarily unfounded sets and minimal nonempty unfounded sets has also led to an alternative characterization of UEmodels (Gebser et al. 2008), which characterizes uniform equivalence (Eiter and Fink 2003) of nondisjunctive programs as well as disjunctive programs.\nSimilar to Theorem 1 (b′), Theorem 1 (e) can be stated in terms of elementarily unfounded sets, thereby restricting attention to minimal nonempty unfounded sets.\nTheorem 1 (e′)\nThe following condition is equivalent to each of conditions (a)–(c) in Theorem 1:\n(e′) X contains no elementarily unfounded sets for Π w.r.t. X .\nThe notion of an elementarily unfounded set may help improve computation performed by SAT-based answer set solvers. Since there are exponentially many “relevant” loops in the worst case (Lifschitz and Razborov 2006), SAT-based answer set solvers do not add all loop formulas at once. Instead, they check whether a model returned by a SAT solver is stable. If not, a loop formula that is not satisfied by the model is added, and the SAT solver is invoked again. This process is repeated until a stable model is found or the search space is exhausted. In view of Theorem 1 (e′), it is sufficient to restrict attention to elementarily unfounded sets during the computation. This ensures that the considered loop formulas belong to elementary loops. Since every elementary loop is a loop, but not vice versa, the computation may involve fewer loop formulas overall than in the case when arbitrary loops are considered. However, whether this idea will lead to more efficient computation in practice requires further investigation."
    }, {
      "heading" : "2.4 Recognizing Elementary Loops of Nondisjunctive Programs",
      "text" : "The definition of an elementary loop given in Section 2.2 involves considering all its nonempty proper subsets (or at least all elementary loops that are subsets). This may seem to imply that deciding whether a given set of atoms is an elementary loop is a computationally hard problem. However, Gebser and Schaub (2005) showed that this is not the case for nondisjunctive programs. They also noted that the notion of a positive dependency graph is not expressive enough to distinguish between elementary and non-elementary loops (Program Π1 and the program in (6) have the same dependency graph, but their elementary loops are different), and instead used the rather complicated notion of a body-head dependency graph to identify elementary loops. In this section, we simplify their result by still referring to a positive dependency graph. We show that removing some unnecessary edges from a positive dependency graph is just enough to distinguish between elementary and non-elementary loops.\np qr q )\nThis is a “bottom-up” construction based on strongly connected components, i.e., maximal strongly connected subgraphs of a given graph. Thus EC iΠ(X) is a subset of EC i+1Π (X), and the graph (X,ECΠ(X)) is a subgraph of the positive dependency graph of Π. We call the graph (X,ECΠ(X)) the elementary subgraph of X for Π. Figure 2 shows the elementary subgraph of {p, q, r} for Π1, which is not strongly connected.\nThe following theorem is similar to Theorem 10 from (Gebser and Schaub 2005), but instead of referring to the notion of a body-head dependency graph, it refers to the notion of an elementary subgraph.\nTheorem 3 For any nondisjunctive program Π and any nonempty set X of atoms that occur in Π, X is an elementary loop of Π iff the elementary subgraph ofX for Π is strongly connected.\nSince an elementary subgraph can be constructed in polynomial time, the problem of deciding whether a given set of atoms is an elementary loop of a nondisjunctive program is tractable."
    }, {
      "heading" : "2.5 Comparison with Gebser-Schaub Definition",
      "text" : "In this section, we compare our reformulation of elementary loops with the original definition by Gebser and Schaub (2005) for nondisjunctive programs.\nLet Π be a nondisjunctive program. A loop of Π is called trivial if it consists of a single atom such that the dependency graph of Π does not contain an edge from the atom to itself, and nontrivial otherwise.8 For a nontrivial loop L of Π, let\n• R−Π(L) = {(3) ∈ Π | a1 ∈ L, B ∩ L = ∅}, and • R+Π(L) = {(3) ∈ Π | a1 ∈ L, B ∩ L 6= ∅}.\nDefinition 1 ((Gebser and Schaub 2005)) A nontrivial loop L of a nondisjunctive program Π is called a GS-elementary loop of Π if R−Π(L ′) ∩R+Π(L) 6= ∅ for all proper subsets L ′ of L that are nontrivial loops of Π.\n8 In (Lin and Zhao 2004) and (Gebser and Schaub 2005), loops were defined to be nontrivial.\nProposition 6\nFor any nondisjunctive program Π and any set L of atoms, L is a GS-elementary loop of Π iff L is a nontrivial elementary loop of Π.\nProof. From left to right: Assume that L is a GS-elementary loop of Π. If L is a singleton, it is a (nontrivial) elementary loop according to our definition. If L is not a singleton, we have that R−Π(L ′) ∩ R+Π(L) 6= ∅ for any proper subset L ′ of L that is a nontrivial loop of Π. In other words, there is a rule (3) in Π such that\na1 ∈ L ′, (7)\nB ∩ L′ = ∅, (8)\nand\nB ∩ (L \\ L′) 6= ∅. (9)\nWe thus have that L′ is outbound in L for Π. Furthermore, for any trivial loop {a1} of Π contained in L, there must be a rule (3) in Π such that B ∩ (L \\ {a1}) 6= ∅, as L cannot be a loop of Π otherwise. Since {a1} is trivial, B ∩ {a1} = ∅, so that {a1} is outbound in L for Π. By Proposition 3, it follows that L is a (nontrivial) elementary loop of Π.\nFrom right to left: Assume that L is a nontrivial elementary loop of Π. From the definition of an elementary loop, it follows that any proper subset L′ of L that is a nontrivial loop of Π is outbound in L for Π. That is, there is a rule (3) in Π such that (7), (8), and (9) hold, so that L is a GS-elementary loop of Π.\nFor a nondisjunctive program Π and a set X of atoms, a loop L of ΠX is a GS-elementary loop of ΠX iff L is a nontrivial elementary loop of ΠX . Thus an active elementary loop of Π according to (Gebser and Schaub 2005) is a nontrivial elementary loop of ΠX that is unfounded by Π w.r.t. X . Hence, any active elementary loop L of Π is an elementarily unfounded set for Π w.r.t. X , while the converse does not hold in general if L is a singleton.\nIn fact, there are a few differences between Definition 1 and our definition of an elementary loop. First, our definition of an elementary loop does not a priori assume that its atoms form a loop. Rather, the fact that an elementary loop is a loop follows from its definition in view of Proposition 1. Second, the two definitions do not agree on trivial loops: a trivial loop is an elementary loop, but not a GSelementary loop. This originates from the difference between the definition of a loop in (Lin and Zhao 2004) and its reformulation given in (Lee 2005). As shown in the main theorem from (Lee 2005), identifying a trivial loop as a loop admits a simpler reformulation of the Lin-Zhao theorem by allowing us to view completion formulas (Clark 1978) as a special case of loop formulas. Furthermore, the reformulated definition of an elementary loop enables us to identify a close relationship between maximal elementary loops (elementarily unfounded sets) and minimal nonempty unfounded sets.\nImportantly, trivial loops allow us to extend the notion of an elementary loop to disjunctive programs without producing counterintuitive results. For instance,\nconsider the following disjunctive program:\np ; q ← r p ; r ← q q ; r ← p .\n(10)\nThe nontrivial loops of this program are {p, q}, {p, r}, {q, r}, and {p, q, r}, but not the singletons {p}, {q}, and {r}. If we were to extend GS-elementary loops to disjunctive programs, a natural extension would say that {p, q, r} is a GSelementary loop since {p, q}, {p, r}, and {q, r} are “outbound” in {p, q, r}. But note that {p, q, r} is unfounded w.r.t. {p, q, r}; moreover, every singleton is also unfounded w.r.t {p, q, r}. This is in contrast with Proposition 5, according to which all nonempty proper subsets of an elementary loop should be externally supported. The next section shows that such an anomaly does not arise with our definition of an elementary loop that is extended to disjunctive programs."
    }, {
      "heading" : "3 Disjunctive Programs",
      "text" : "After providing the relevant background on disjunctive programs, this section generalizes the notions of an elementary loop and an elementarily unfounded set to disjunctive programs. We also provide the proofs of the generalizations of the statements given in the previous section; such generalized results also apply to the class of nondisjunctive programs as a fragment of disjunctive programs. Furthermore, we show that, in contrast to nondisjunctive programs, recognizing an elementary loop is intractable in the case of arbitrary disjunctive programs, but stays tractable under a certain syntactic condition."
    }, {
      "heading" : "3.1 Background",
      "text" : "A disjunctive rule is an expression of the form\na1; . . . ; ak ← ak+1, . . . , al, not al+1 , . . . , not am , not not am+1 , . . . , not not an (11) where n ≥ m ≥ l ≥ k ≥ 0 and a1, . . . , an are propositional atoms. A disjunctive program is a finite set of disjunctive rules. Note that any program with nested expressions can be turned into an equivalent program whose rules are of the form (11) (Lifschitz et al. 1999).\nWe will identify a disjunctive rule (11) with the propositional formula\nak+1 ∧ · · · ∧ al ∧ ¬al+1 ∧ · · · ∧ ¬am ∧ ¬¬am+1 ∧ · · · ∧ ¬¬an → a1 ∨ · · · ∨ ak\nand will often write (11) as\nA ← B,F (12)\nwhere A is a1, . . . , ak, B is ak+1, . . . , al, and F is\nnot al+1 , . . . , not am , not not am+1 , . . . , not not an .\nWe will sometimes identify A and B with their corresponding sets of atoms.\nThe reduct ΠX of a disjunctive program Π w.r.t. a set X of atoms is obtained from Π by deleting each rule (12) such that X 6|= F , and replacing each remaining rule (12) with A ← B. A set X of atoms is a stable model, also called an answer set, of Π if X is minimal among the sets of atoms that satisfy ΠX .\nThe definition of a (positive) dependency graph is extended to a disjunctive program Π in the straightforward way: the vertices of the graph are the atoms occurring in Π, and its edges go from the elements of A to the elements of B for all rules (12) of Π. With this extended definition of a dependency graph, the definition of a loop for a nondisjunctive program is straightforwardly extended to a disjunctive program.\nFor any set Y of atoms, the external support formula of Y for a disjunctive\nprogram Π, denoted by ESΠ(Y ), is the disjunction of conjunctions\nB ∧ F ∧ ∧\na∈A\\Y\n¬a\nfor all rules (12) of Π such that A∩Y 6= ∅ and B∩Y = ∅. When Π is a nondisjunctive program, this definition reduces to the definition of ESΠ(Y ) for nondisjunctive programs given earlier. As before, we say that Y is externally supported by Π w.r.t. a set X of atoms if X |= ESΠ(Y ); Y is unfounded Π w.r.t. X if X 6|= ESΠ(Y ).\nThe notion of LFΠ(Y ) and the term (conjunctive) loop formula similarly apply\nto formulas (4) when Π is a disjunctive program.\nAs shown in (Lee 2005), Theorem 1 remains correct after replacing “nondisjunc-\ntive program” in its statement with “disjunctive program.”\nTheoremd 1 ((Lee 2005)) For any disjunctive program Π and any set X of atoms that occur in Π, if X is a model of Π, then the following conditions are equivalent: 9\n(a) X is a stable model of Π; (b) X satisfies LFΠ(Y ) for all nonempty sets Y of atoms that occur in Π;\n(b′) X contains no nonempty unfounded sets for Π w.r.t. X ;\n(c) X satisfies LFΠ(Y ) for all loops Y of Π.\nFor instance, the loop formulas of the seven loops of the program in (10) are:\np → (r ∧ ¬q) ∨ (q ∧ ¬r) q → (r ∧ ¬p) ∨ (p ∧ ¬r) r → (q ∧ ¬p) ∨ (p ∧ ¬q) p ∧ q → r p ∧ r → q q ∧ r → p p ∧ q ∧ r → ⊥ .\n(13)\n∅ is the only model of (13) and it is the only stable model of (10) in accordance with the equivalence between (a) and (c) in Theoremd 1.\n9 Superscript d indicates that the statement is a generalization to disjunctive programs."
    }, {
      "heading" : "3.2 Elementary Loops of Disjunctive Programs",
      "text" : "In this section, we generalize the definition of an elementary loop to disjunctive programs.\nA loop of a disjunctive program can be defined without referring to a dependency\ngraph, as in Proposition 1.\nPropositiond 1 For any disjunctive program Π and any nonempty set X of atoms that occur in Π, X is a loop of Π iff, for every nonempty proper subset Y of X , there is a rule (12) in Π such that A ∩ Y 6= ∅ and B ∩ (X \\ Y ) 6= ∅.\nProof. From left to right: Assume that X is a loop of Π. If X is a singleton, it is clear. If X is not a singleton, take any nonempty proper subset Y of X . Since both Y and X \\ Y are nonempty, there is a path from some atom in Y to some atom in X \\Y in the dependency graph of Π such that all vertices in the path belong to X . This implies that there is an edge from an atom in Y to an atom in X \\ Y , i.e., A ∩ Y 6= ∅ and B ∩ (X \\ Y ) 6= ∅ for some rule (12) in Π.\nFrom right to left: Assume that X is not a loop of Π. Then the subgraph of the dependency graph of Π induced byX is not strongly connected. Consequently, there is a nonempty proper subset Y of X such that no edge connects an atom in Y to an atom in X \\ Y . This implies that there is no rule (12) in Π such that A∩ Y 6= ∅ and B ∩ (X \\ Y ) 6= ∅.\nFor any set X of atoms and any subset Y of X , we say that Y is outbound in X\nfor a disjunctive program Π if there is a rule (12) in Π such that\n• A ∩ Y 6= ∅, • B ∩ (X \\ Y ) 6= ∅, • A ∩ (X \\ Y ) = ∅, and • B ∩ Y = ∅.\nAs with nondisjunctive programs, for any nonempty set X of atoms that occur in Π, we say that X is an elementary loop of Π if all nonempty proper subsets of X are outbound in X for Π. Clearly, every singleton whose atom occurs in Π is an elementary loop of Π, and every elementary loop of Π is a loop of Π. The definition of an elementary loop of a disjunctive program is stronger than the alternative characterization of a loop provided in Propositiond 1: it requires that the rule (12) satisfy two additional conditions, A ∩ (X \\ Y ) = ∅ and B ∩ Y = ∅.\nTo illustrate the definition of an elementary loop of a disjunctive program, consider the loop {p, q, r} of the program in (10). The loop is not an elementary loop because, for instance, {p} is not outbound in {p, q, r}: although the first two rules (12) in (10) are such that A∩{p} 6= ∅, B∩{q, r} 6= ∅, and B∩{p} = ∅, we also have that A∩{q, r} 6= ∅ for each of them. Similarly, {q} and {r} are not outbound in {p, q, r}. On the other hand, the remaining loops of the program, {p}, {q}, {r}, {p, q}, {p, r}, and {q, r}, are elementary loops.\nWith the extended definitions given above, Propositions 2, 3, 4 and Theorem 1 (d) remain correct after replacing “nondisjunctive program” in their statements with “disjunctive program.” In the following, we present proofs for these generalizations.\nPropositiond 2 For any disjunctive programΠ and any setsX , Y , Z of atoms such that Z ⊆ Y ⊆ X , if Z is not outbound in Y for Π and X |= ESΠ(Z), then X |= ESΠ(Y ).\nProof. Assume that Z is not outbound in Y for Π and that X |= ESΠ(Z). From the latter, it follows that there is a rule (12) in Π such that\nA ∩ Z 6= ∅ , (14)\nB ∩ Z = ∅ , (15)\nX |= B,F , (16)\nand\nX ∩ (A \\ Z) = ∅ . (17)\nFrom (14), since Z ⊆ Y ,\nA ∩ Y 6= ∅ . (18)\nFrom (17), since Z ⊆ Y ⊆ X ,\nX ∩ (A \\ Y ) = ∅ (19)\nand\nY ∩ (A \\ Z) = ∅ ,\nwhere the latter is equivalent to\nA ∩ (Y \\ Z) = ∅ . (20)\nSince Z is not outbound in Y for Π, from (14), (15), and (20), it follows that\nB ∩ (Y \\ Z) = ∅ ,\nwhich, in combination with (15), gives us that\nB ∩ Y = ∅ . (21)\nFinally, from (16), (18), (19), and (21), we conclude that X |= ESΠ(Y ).\nPropositiond 3 For any disjunctive program Π and any nonempty set X of atoms that occur in Π, X is an elementary loop of Π iff all proper subsets of X that are elementary loops of Π are outbound in X for Π.\nProof. From left to right is clear.\nFrom right to left: Assume that X is not an elementary loop of Π. Then there is a nonempty proper subset Y of X that is not outbound in X for Π. If Y is an elementary loop of Π, it is clear. Otherwise, there is a nonempty proper subset Z of Y that is not outbound in Y for Π. For the sake of contradiction, assume that Z is outbound in X for Π, i.e., that there is a rule (12) in Π such that\nA ∩ Z 6= ∅ , (22)\nB ∩ (X \\ Z) 6= ∅ , (23)\nA ∩ (X \\ Z) = ∅ , (24)\nand\nB ∩ Z = ∅ . (25)\nFrom (22) and (24), since Z ⊆ Y ⊆ X ,\nA ∩ Y 6= ∅ , (26)\nA ∩ (X \\ Y ) = ∅ , (27)\nand\nA ∩ (Y \\ Z) = ∅ . (28)\nSince Z is not outbound in Y for Π, from (22), (25), and (28), it follows that\nB ∩ (Y \\ Z) = ∅ ,\nwhich, in combination with (23) and (25), gives us that\nB ∩ Y = ∅ (29)\nand\nB ∩ (X \\ Y ) 6= ∅ . (30)\nHowever, (26), (27), (29), and (30) together contradict that Y is not outbound in X for Π, from which we conclude that Z is not outbound in X for Π. We have thus shown that every nonempty proper subset of X that is not outbound in X for Π and not an elementary loop of Π contains in turn a nonempty proper subset that is not outbound in X for Π. Since X is finite, there is some (not necessarily unique) minimal nonempty proper subset of X that is not outbound in X for Π, and such a subset must be an elementary loop of Π.\nPropositiond 4\nFor any disjunctive program Π and any nonempty set Y of atoms that occur in Π, there is an elementary loop Z of Π such that Z is a subset of Y and LFΠ(Z) entails LFΠ(Y ).\nProof. If Y is an elementary loop of Π, it is clear. Otherwise, by Propositiond 3, some proper subset Z of Y is an elementary loop of Π that is not outbound in Y for Π. Take any set X of atoms such that X |= LFΠ(Z). If Y 6⊆ X , then X 6|=∧ a∈Y a and X |= LFΠ(Y ). If Y ⊆ X , X |= ∧ a∈Z a and X |= ESΠ(Z), and, by Propositiond 2, we conclude that X |= ESΠ(Y ) and X |= LFΠ(Y ).\nTheoremd 1 (d) The following condition is equivalent to each of conditions (a)–(c) in Theoremd 1:\n(d) X satisfies LFΠ(Y ) for all elementary loops Y of Π.\nProof. We show the equivalence between (b) and (d). From (b) to (d) is clear, and from (d) to (b) follows immediately from Propositiond 4.\nFor instance, for the program in (10), the loop formula of non-elementary loop\n{p, q, r} (the last one in (13)) can be disregarded in view of Theoremd 1 (d)."
    }, {
      "heading" : "3.3 Elementarily Unfounded Sets for Disjunctive Programs",
      "text" : "Let Π be a disjunctive program. For any sets X , Y of atoms, by ΠX,Y we denote the set of all rules (12) of Π such that X |= B,F and X ∩ (A \\ Y ) = ∅. That is, the program ΠX,Y contains all rules of Π that can provide supports for Y w.r.t. X . If Y = X , we also denote ΠX,Y by ΠX . When Π is a nondisjunctive program, this definition reduces to the definition of ΠX for nondisjunctive programs given earlier. Furthermore, when Π is nondisjunctive and Y is not a singleton, then Y is an elementary loop of ΠX,Y iff Y is an elementary loop of ΠX .\nWe extend the definition of an elementarily unfounded set to disjunctive programs by replacing “ΠX” with “ΠX,Y ”: for a disjunctive program Π and a set X of atoms, we say that a set Y of atoms that occur in Π is elementarily unfounded by Π w.r.t.X if Y is\n• an elementary loop of ΠX,Y that is unfounded by Π w.r.t. X or • a singleton that is unfounded by Π w.r.t. X .\nIt is clear from the definition that every elementarily unfounded set for Π w.r.t. X is an elementary loop of Π and that it is also unfounded by Π w.r.t. X .\nFor instance, let Π be the program (10). The program Π{p,q,r},{p,q} consists of the first rule in (10), so that {p, q} is not an elementary loop of Π{p,q,r},{p,q}. On the other hand, Π{p,q},{p,q} consists of the last two rules in (10), and {p, q} is an elementary loop of Π{p,q},{p,q}. Since {p, q} is also unfounded by Π w.r.t. {p, q}, it is an elementarily unfounded set for Π w.r.t. {p, q}.\nProposition 5, Corollary 1, and Theorem 2 remain correct after replacing “nondisjunctive program” in their statements with “disjunctive program,” and “ΠX” with “ΠX,Y .”\nPropositiond 5 For any disjunctive program Π, any set X of atoms, and any elementary loop Y of ΠX,Y , X satisfies ESΠ(Z) for all nonempty proper subsets Z of Y .\nProof. From the fact that Y is an elementary loop of ΠX,Y , it follows that any nonempty proper subset Z of Y is outbound in Y for ΠX,Y . If Y is not a singleton, this implies that Y is a subset of X and that, for each nonempty proper subset Z of Y , there is a rule (12) in Π such that\nA ∩ Z 6= ∅ , (31)\nA ∩ (Y \\ Z) = ∅ , (32)\nB ∩ Z = ∅ , (33)\nX |= B,F , (34)\nand\nX ∩ (A \\ Y ) = ∅ . (35)\nFrom (32) and (35), it follows that\nX ∩ (A \\ Z) = ∅ . (36)\nFinally, from (31), (33), (34), and (36), we conclude that X |= ESΠ(Z).\nCorollaryd 1\nFor any disjunctive programΠ, any setX of atoms, and any elementarily unfounded set Y for Π w.r.t. X , X does not satisfy ESΠ(Y ), but satisfies ESΠ(Z) for all nonempty proper subsets Z of Y .\nProof. From the definition of an elementarily unfounded set, X 6|= ESΠ(Y ), and, by Propositiond 5, X |= ESΠ(Z) for all nonempty proper subsets Z of Y .\nTheoremd 2 For any disjunctive program Π and any sets X , Y of atoms, Y is an elementarily unfounded set for Π w.r.t. X iff Y is minimal among the nonempty sets of atoms occurring in Π that are unfounded by Π w.r.t. X .\nProof. From left to right follows immediately from Corollaryd 1.\nFrom right to left: Assume that Y is minimal among the nonempty unfounded sets for Π w.r.t. X whose atoms occur in Π. If Y is a singleton, it is elementarily unfounded by Π w.r.t. X . Otherwise, if Y 6⊆ X , there is an atom a ∈ (Y \\X), and one can check that (Y \\{a}) is also unfounded by Π w.r.t. X , which contradicts that Y is a minimal nonempty unfounded set for Π w.r.t. X . Hence, from the minimality assumption on Y , it follows that Y is a subset of X . It also holds that X |= ESΠ(Z) for every nonempty proper subset Z of Y , so that there is a rule (12) in Π such that\nA ∩ Z 6= ∅ , (37)\nB ∩ Z = ∅ , (38)\nX |= B,F , (39)\nand\nX ∩ (A \\ Z) = ∅ . (40)\nFrom (40), since Z ⊆ Y ⊆ X ,\nA ∩ (Y \\ Z) = ∅ (41)\nand\nX ∩ (A \\ Y ) = ∅ . (42)\nSince Y is unfounded by Π w.r.t. X , from (37), (39), and (42), it follows that\nB ∩ Y 6= ∅ ,\nwhich, in combination with (38), gives us that\nB ∩ (Y \\ Z) 6= ∅ . (43)\nIn view of (39) and (42), we have that the rule (12) is contained in ΠX,Y . From (37), (38), (41), and (43), we further conclude that Z is outbound in Y for ΠX,Y . Consequently, Y is an elementary loop of ΠX,Y and elementarily unfounded by Π w.r.t.X .\nTheorem 1 (e) and (e′) can now be extended to disjunctive programs as follows.\nTheoremd 1 (e′) The following conditions are equivalent to each of conditions (a)–(c) in Theoremd 1:\n(e) X satisfies LFΠ(Y ) for every set Y of atoms such that Y is\n— maximal among all sets Z of atoms that are elementary loops of ΠX,Z or — a singleton whose atom occurs in Π;\n(e′) X contains no elementarily unfounded sets for Π w.r.t. X .\nProof. We first show the equivalence between (b′) and (e′): from (b′) to (e′) is clear, and from (e′) to (b′) follows immediately from Theoremd 2. Moreover, the equivalence between (e′) and (e) holds in view of Propositiond 5, which tells us that an elementarily unfounded set Y for Π w.r.t. X cannot be a proper subset of any set Z of atoms that is an elementary loop of ΠX,Z ."
    }, {
      "heading" : "3.4 Recognizing Elementary Loops of Disjunctive Programs",
      "text" : "Although deciding whether a given set of atoms is an elementary loop of a nondisjunctive program can be done efficiently, it turns out that the corresponding problem in the case of arbitrary disjunctive programs is intractable.\nTheorem 4 For any disjunctive program Π and any set Y of atoms, deciding whether Y is an elementary loop of Π is coNP-complete.\nProof. Containment in coNP is clear, since it is easy to check that a given nonempty proper subset of Y is not outbound in Y for Π.\nFor coNP-hardness, we reduce the coNP-hard problem of deciding whether a finite set X of atoms is “unfounded-free” for a disjunctive program Π (Leone et al. 1997), i.e., X contains no nonempty unfounded sets for Π w.r.t. X . Using a new atom e that does not occur in Π or X , we construct a program Π′ as follows: for every rule (12) of ΠX , include a rule A ← e,B, F in Π′, and, for every a ∈ X ∪ {e}, include a rule e ← a in Π′. Given the rules of the latter type, it is clear that any proper subset Z of Y = X ∪{e} that is not outbound in Y for Π′ cannot contain e. For every rule (12) of Π′ such that A 6= {e}, since e ∈ B, we then have that\nB ∩ (Y \\ Z) 6= ∅ .\nHence, if a nonempty proper subset Z of Y is not outbound in Y for Π′, for every rule (12) of Π′ such that A 6= {e}, at least one of the following conditions holds:\nA ∩ Z = ∅ , (44)\nA ∩ (Y \\ Z) 6= ∅ , (45)\nor\nB ∩ Z 6= ∅ . (46)\nSince e /∈ A, (45) implies that\nA ∩ (X \\ Z) 6= ∅ . (47)\nWe have thus shown that (44), (46), or (47) holds for every rule (12) of Π′ such that A 6= {e}, and, similarly, for every rule (12) of ΠX . Furthermore, we have that\nX 6|= B,F (48)\nfor every rule (12) of Π \\ΠX . Consequently, (44), (46), (47), or (48) holds for every rule (12) of Π, which shows that Z is unfounded by Π w.r.t. X . Conversely, if a nonempty subset Z of X is unfounded by Π w.r.t. X , the fact that (44), (46), or (47) holds for every rule (12) of ΠX implies that every rule (12) of Π ′ satisfies (44), (45), or (46), so that Z is not outbound in Y for Π′. Consequently, we conclude that X is unfounded-free for Π iff Y = X ∪ {e} is an elementary loop of Π′.\nHowever, for the class of disjunctive programs called “Head-Cycle-Free” (Ben-Eliyahu and Dechter 1994),\ndeciding whether a set of atoms is an elementary loop is tractable. We say that a disjunctive program Π is Head-Cycle-Free (HCF) if |A ∩ Y | ≤ 1 for every rule (12) of Π and every loop Y of Π.\nThe definition of an elementary subgraph for a nondisjunctive program can be extended to disjunctive programs by modifying the equation for EC i+1Π as follows:\nEC i+1Π (X) = {(a, b) | there is a rule (12) in Π such that A ∩X = {a},\nb ∈ B ∩X , and all atoms in B ∩X belong to the same strongly connected component in (X,EC iΠ(X))} .\nWith this extended definition of an elementary subgraph, Theorem 3 remains correct after replacing “nondisjunctive program” in its statement with “HCF program.”\nIn the next section, we introduce “Head-Elementary-loop-Free” programs, and\nshow that Theorem 3 can be further generalized to such programs."
    }, {
      "heading" : "4 Head-Elementary-Loop-Free Programs",
      "text" : "In general, computing stable models of a disjunctive program is harder than computing stable models of a nondisjunctive program (Eiter and Gottlob 1995). On the other hand, HCF programs are “easy” disjunctive programs that can be turned into equivalent nondisjunctive programs in polynomial time (Ben-Eliyahu and Dechter 1994). This property plays an important role in the computation of stable models of disjunctive programs, and is used by answer set solvers claspd, cmodels, and dlv.\nBy referring to elementary loops in place of loops in the definition of an HCF program, we define a class of programs that is more general than HCF programs: we say that a disjunctive program Π is Head-Elementary-loop-Free (HEF) if |A∩Y | ≤ 1 for every rule (12) of Π and every elementary loop Y of Π. Since every elementary loop is also a loop, it is clear that every HCF program is an HEF program as well. However, not all HEF programs are HCF. For example, consider the following program Π2:\np ← r q ← r r ← p, q p ; q ← .\nThis program has six loops: {p}, {q}, {r}, {p, r}, {q, r}, and {p, q, r}. Since the head of the last rule contains two atoms from the loop {p, q, r}, Π2 is not HCF. On the other hand, Π2 is HEF since {p, q, r} is not an elementary loop of Π2: its subsets {p, r} and {q, r} are not outbound in {p, q, r} for Π2.\nLet us write a rule (12) in the following form:\na1; . . . ; ak ← B,F . (49)\nGelfond et al. (1991) defined a mapping from a disjunctive program Π to a nondisjunctive program Πsh , the shifted variant of Π, by replacing each rule (49) with k > 1 in Π by k new rules:\nai ← B,F, not a1 , . . . , not ai−1 , not ai+1 , . . . , not ak . (50)\nThey showed that every stable model of Πsh is also a stable model of Π. Although the converse does not hold in general, Ben-Eliyahu and Dechter (1994) showed that the converse holds if Π is HCF. We below extend this result to HEF programs.\nThe following proposition compares the elementary loops of Π with the elemen-\ntary loops of Πsh .\nProposition 7 For any disjunctive program Π, if X is an elementary loop of Π, then X is an elementary loop of Πsh .\nProof. Assume that X is an elementary loop of Π. Then every nonempty proper subset Y of X is outbound in X for Π, so that there is a rule (49) in Π such that\n{a1, . . . , ak} ∩ Y 6= ∅ , (51)\nB ∩ (X \\ Y ) 6= ∅ , (52)\n{a1, . . . , ak} ∩ (X \\ Y ) = ∅ ,\nand\nB ∩ Y = ∅ . (53)\nFor some ai ∈ {a1, . . . , ak} ∩ Y , (51) implies that some rule (50) in Πsh satisfies\n{ai} ∩ Y 6= ∅\nand\n{ai} ∩ (X \\ Y ) = ∅ .\nTogether with (52) and (53), this means that Y is outbound in X for Πsh . Consequently, X is an elementary loop of Πsh .\nThe converse of Proposition 7 does not hold even if Π is HEF. For example,\nconsider the following HEF program Π3:\np ; q ← r r ← p r ← q .\nSet {p, q, r} is not an elementary loop of Π3 since, for instance, {p} is not outbound in {p, q, r} for Π3. On the other hand, {p, q, r} is an elementary loop of (Π3)sh :\np ← r, not q q ← r, not p r ← p r ← q .\n(54)\nHowever, the following proposition shows that there is a certain subset of Πsh whose elementary loops are also elementary loops of Π.\nProposition 8 For any disjunctive program Π, any set X of atoms, and any subset Y of X , if Y is an elementary loop of (Πsh )X , then Y is an elementary loop of Π.\nProof. Assume that Y is an elementary loop of (Πsh )X , and not an elementary loop of Π for the sake of contradiction. Consider any rule (49) in Π, and any proper subset Z of Y . Since Y is not an elementary loop of Π, at least one of the following conditions holds:\n{a1, . . . , ak} ∩ Z = ∅ , {a1, . . . , ak} ∩ (Y \\ Z) 6= ∅ , B ∩ Z 6= ∅ , or B ∩ (Y \\ Z) = ∅ .\n(55)\nWe will show that any rule (50) in (Πsh )X obtained from (49) by shifting satisfies\nat least one of the following conditions:\n{ai} ∩ Z = ∅ , {ai} ∩ (Y \\ Z) 6= ∅ , B ∩ Z 6= ∅ , or B ∩ (Y \\ Z) = ∅ .\nThis contradicts the assumption that Y is an elementary loop of (Πsh )X .\nCase 1: The first, the third, or the fourth condition of (55) holds. The claim trivially follows.\nCase 2: {a1, . . . , ak} ∩ (Y \\ Z) 6= ∅. Recall that\nX |= B, F, not a1, . . . , not ai−1, not ai+1, not ak,\nby (Πsh )X construction. It follows that |{a1, . . . , ak} ∩X | ≤ 1. From the fact that Y ⊆ X and Z ⊂ Y we conclude that |{a1, . . . , ak}∩Y | ≤ 1 and {a1, . . . , ak}∩Z = ∅, so that {ai} ∩ Z = ∅.\nFor instance, for X = {p, q, r} and (Π3)sh , we have that [(Π3)sh ]X consists of the last two rules in (54). Only the singletons {p}, {q}, and {r} are elementary loops of [(Π3)sh ]X , and clearly they are elementary loops of Π3 as well.\nWe are now ready to show the equivalence between an HEF program and its\nshifted variant.\nTheorem 5 For any HEF program Π and any set X of atoms, X is a stable model of Π iff X is a stable model of Πsh .\nProof. From left to right: Assume that X is a stable model of Π. Then X is a model of Πsh such that all its atoms occur in Πsh and also in [Πsh ]X . Furthermore, by Theoremd 1 (d), we have that X satisfies LFΠ(Y ) for all elementary loops Y of Π. By Proposition 8, the elementary loops of Π include all elementary loops Y of [Πsh ]X that are contained in X , and, since Π is HEF, it holds that ESΠsh (Y ) and ESΠ(Y ) as well as LFΠsh (Y ) and LFΠ(Y ) are equivalent to each other. This implies that X satisfies ESΠsh (Y ) for all elementary loops Y of [Πsh ]X that are contained in X , so that X contains no elementarily unfounded sets for Πsh w.r.t. X . By Theoremd 1 (e′), we conclude that X is a stable model of Πsh .\nFrom right to left: Assume that X is a stable model of Πsh . Then X is a model of Π such that all its atoms occur in Π. Furthermore, by Theoremd 1 (d), we have that X satisfies LFΠsh (Y ) for all elementary loops Y of Πsh . By Proposition 7, the elementary loops of Πsh include all elementary loops Y of Π, and, since Π is HEF, it holds that ESΠ(Y ) and ESΠsh (Y ) as well as LFΠ(Y ) and LFΠsh (Y ) are equivalent to each other. This implies that X satisfies LFΠ(Y ) for all elementary loops Y of Π. By Theoremd 1 (d), we conclude that X is a stable model of Π.\nFor instance, one can check that both Π2 and (Π2)sh have {p} and {q} as their stable models. It follows that HEF programs are not more expressive than nondisjunctive programs, so that one can regard the use of disjunctive rules in such programs as a syntactic variant. Furthermore, the problem of deciding whether a model is stable for an HEF program is tractable, just as the same problem for a nondisjunctive program. (In the case of arbitrary disjunctive programs, it is coNP-complete (Eiter and Gottlob 1995).) These properties were known for HCF programs, and here we extended them to HEF programs.\nIn Section 3.4, we defined the notion of an elementary subgraph of a set X of\natoms for a disjunctive program Π. Theorem 3 still applies to HEF programs.\nTheoremhef 3 For any HEF program Π and any nonempty set X of atoms that occur in Π, X is an elementary loop of Π iff the elementary subgraph of X for Π is strongly connected.\nProof. From left to right: Assume that X is an elementary loop of Π, and, for the sake of contradiction, that the elementary subgraph of X for Π is not strongly\nconnected. Then there is a strongly connected component in (X,ECΠ(X)) whose atoms Y are not reached from any atom in X \\ Y . Clearly Y is a nonempty proper subset of X , and so is X \\ Y . Furthermore, for every rule (12) in Π, at least one of the following conditions holds:\n|A ∩X | > 1 , (56)\nA ∩ (X \\ Y ) = ∅ , (57)\nB ∩ Y = ∅ , (58)\nor\nB ∩ (X \\ Y ) 6= ∅ . (59)\nHowever, (56) contradicts the assumption that Π is HEF. Also the fact that at least one of the conditions (57), (58), and (59) holds contradicts the assumption that X \\ Y is outbound in X for Π.\nFrom right to left: Assume that the elementary subgraph of X for Π is strongly connected. For every nonempty proper subset Y of X , there is a minimum integer i ≥ 0 such that EC iΠ(X) does not contain any edge from an atom in Y to an atom in X \\ Y , but EC i+1Π (X) contains such an edge. Thus some rule (12) in Π satisfies\n|A ∩X | = 1 , (60)\nA ∩ Y 6= ∅ , (61)\nB ∩ (X \\ Y ) 6= ∅ ,\nand\nB ∩ Y = ∅ .\nFrom (60) and (61), since Y ⊆ X ,\nA ∩ (X \\ Y ) = ∅ .\nThis shows that Y is outbound in X for Π. We conclude that X is an elementary loop of Π.\nAlthough many properties of HCF programs still apply to HEF programs (e.g., equivalence between an HEF program and its shifted variant), the computational complexities of recognizing them are different. While an HCF program can be recognized in polynomial time (by computing the strongly connected components of its dependency graph), Fassetti and Palopoli (2010) showed that deciding whether a disjunctive program is HEF is coNP-complete.10 Theorem 4 established a similar complexity gap by showing that elementary loops are hard to verify in the case of arbitrary disjunctive programs, while for loops it remains a question of reachability.\n10 The problem was left open in (Gebser et al. 2007), one of our conference papers that this paper extends.\nSuch elevated complexities may appear daunting, but the semantic similarities between HEF and HCF programs still exhibit that the syntactic concept of reachability merely gives a rough approximation of properties rendering disjunctive programs more difficult than nondisjunctive ones. As noted in (Fassetti and Palopoli 2010), identifying subclasses of (not necessarily HCF) disjunctive programs for which verifying the HEF property is tractable may be an interesting line of future research."
    }, {
      "heading" : "5 HEF Programs and Inherent Tightness",
      "text" : "When we add more rules to a program, a stable model of the original program remains to be a stable model of the extended program if it satisfies the new rules.\nProposition 9\nFor any disjunctive program Π and any model X of Π, X is a stable model of Π iff there is a subset Π′ of Π such that X is a stable model of Π′.\nProof. From left to right is clear.\nFrom right to left: Assume that X is not a stable model of Π. Then some proper subset Y of X is a model of ΠX . For each subset Π′ of Π, we have that (Π′)X ⊆ ΠX , so that Y is a model of (Π′)X and X is not a stable model of Π′.\nIn view of Theoremd 1, Proposition 9 tells us that, provided that X is a model of Π, in order to verify that X is a stable model of Π, it is sufficient to identify a subset Π′ of Π such that X is a stable model of Π′. Of course, one can trivially take Π itself as the subset Π′, but there are nontrivial subsets that deserve attention. In fact, if Π is nondisjunctive, it is known that the subset Π′ can be further restricted to a “tight” program (Fages 1994; Erdem and Lifschitz 2003)—the result known as “inherently tight” (Lin and Zhao 2003) or “weakly tight” (You et al. 2003) program. In the following, we simplify these notions and show that they can be extended to HEF programs.\nRecall that a loop of Π is called trivial if it consists of a single atom such that the dependency graph of Π does not contain an edge from the atom to itself. In other words, a loop {a} of Π is trivial if there is no rule (12) in Π such that a ∈ A ∩B.\nDefinition 2 ((Lee 2005))\nA disjunctive program Π is called tight if every loop of Π is trivial.\nAs defined previously (Apt et al. 1988; Baral and Gelfond 1994; Inoue and Sakama 1998;\nLee 2005), we call a set X of atoms supported by a disjunctive program Π if, for every a ∈ X , there is a rule (12) in ΠX such that A ∩X = {a}. Note that Definition 2 and the notion of support also apply to nondisjunctive programs as a special case.\nThe property of inherent tightness, introduced by Lin and Zhao (2003) for the case of nondisjunctive programs, can now be reformulated and generalized as follows.\nDefinition 3 A disjunctive program Π is called inherently tight on a set X of atoms if there is a subset Π′ of Π such that Π′ is tight and X is supported by Π′.\nIn the case of nondisjunctive programs, this reformulation of inherent tightness is similar to “well-supportedness” (Fages 1994). Furthermore, weak tightness, introduced in (You et al. 2003), is closely related to the notion of inherent tightness.\nFor nondisjunctive programs, it is known that their stable models can be char-\nacterized in terms of inherent tightness.\nProposition 10 ((Fages 1994; Lin and Zhao 2003; You et al. 2003)) For any nondisjunctive program Π and any model X of Π, X is a stable model of Π iff Π is inherently tight on X .\nOne may wonder whether Proposition 10 can be extended to disjunctive programs as well, given that Definition 3 readily applies to them. However, only one direction of Proposition 10 holds in the case of arbitrary disjunctive programs.\nProposition 11 For any disjunctive program Π and any model X of Π, if Π is inherently tight on X , then X is a stable model of Π.\nProof. Assume that Π is inherently tight onX . Then there is a subset Π′ of Π such that Π′ is tight andX is supported by Π′. By Proposition 2 from (Lee and Lifschitz 2003), X is a stable model of Π′, and, by Proposition 9, X is a stable model of Π.\nTo see that the converse of Proposition 11 does not hold, consider Π as follows:\np ← q q ← p p ; q ← .\nSet {p, q} is a stable model of Π. On the other hand, since any tight subset Π′ of Π must exclude the first or the second rule, it follows that {p, q} is not supported by Π′. But this means that Π is not inherently tight on {p, q}. It is also worthwhile to note that {p, q} is an elementary loop of Π, so that Π is not HEF (and not HCF). Indeed, the following theorem tells us that Proposition 10 can be extended to HEF programs.\nTheorem 6 For any HEF program Π and any model X of Π, X is a stable model of Π iff Π is inherently tight on X .\nProof. From left to right:Assume thatX is a stable model of Π. By Propositiond 3 (and the fact that every atom of X occurs in ΠX), any nonempty subset Y of X contains some elementary loop Z of ΠX that is not outbound in Y for ΠX . 11 That is, every rule (12) of ΠX satisfies at least one of the following conditions:\nA ∩ Z = ∅ ,\n11 If Y is an elementary loop of ΠX , take Z = Y .\nB ∩ (Y \\ Z) = ∅ , (62)\nA ∩ (Y \\ Z) 6= ∅ , (63)\nor\nB ∩ Z 6= ∅ .\nFrom (63), since Y ⊆ X ,\nA ∩ (X \\ Z) 6= ∅ .\nOn the other hand, since X is a stable model of Π and Z is a nonempty subset of X , by Theoremd 1 (b), there is a rule (12) in ΠX such that\nA ∩ Z 6= ∅ , (64)\nA ∩ (X \\ Z) = ∅ , (65)\nand\nB ∩ Z = ∅ , (66)\nso that (62) must hold, which, in combination with (66), gives us that\nB ∩ Y = ∅ . (67)\nFurthermore, since ΠX ⊆ Π, we have that Z is an elementary loop of Π. Given that Π is HEF, from (64) and (65), we conclude that\nA ∩X = {a} (68)\nfor some a ∈ Z, where a ∈ Y also holds because Z ⊆ Y . We have thus shown that, for any nonempty subset Y of X , there is a rule (12) in ΠX such that (67) and (68) for a ∈ Y hold. Starting from X0 = ∅ and Π0 = ∅, when, for 1 ≤ i ≤ |X |, we let\n• Y = (X \\X i−1), • Πi is obtained from Πi−1 by adding some rule (12) in ΠX such that (67) and\n(68) for a ∈ Y hold, and\n• X i = X i−1 ∪ {a},\nthen X is supported by Π′ = Π|X|. Furthermore, since a rule (12) in (Πi \\ Πi−1) satisfies A ∩ X i−1 = ∅ and B ⊆ X i−1 for every 1 ≤ i ≤ |X |, Π′ is tight by construction, which shows that Π is inherently tight on X .\nFrom right to left follows immediately from Proposition 11.\nSince every HCF program is HEF, Theorem 6 applies also to HCF programs. We demonstrated that, by turning to the notion of an elementary loop in place of a loop, we obtain generalizations of results known for loops, such as Theorem 5. This brings our attention to the following question. As a tight program can be characterized in terms of loops, can the notion of a tight program be generalized by referring to elementary loops instead? To answer it, let us first modify Definition 2 in the following way.\nDefinition 4 A disjunctive program Π is called e-tight if every elementary loop of Π is trivial.\nSince every elementary loop is a loop, it is clear that a tight program is e-tight as well. But is the class of e-tight programs more general than the class of tight programs? One reason why this is an interesting question to consider is because, if so, it would lead to a generalization of Fages’ theorem (Fages 1994), which would yield a more general class of programs for which the stable model semantics coincides with the completion semantics. However, it turns out that e-tight programs are not more general than tight programs.\nProposition 12 For any disjunctive program Π, Π is e-tight iff Π is tight.\nProof. From left to right: Assume that Π is not tight. Then there is a minimal nontrivial loop X of Π, and the subgraph of the dependency graph of Π induced by X yields a simple directed cycle. That is, for any nonempty proper subset Y of X , there is a rule (12) in Π such that A∩X = {a}, B∩X = {b} for atoms a ∈ Y , b ∈ X \\ Y . This shows that Y is outbound in X for Π, so that X is a nontrivial elementary loop of Π.\nFrom right to left is clear.\nThis result also tells us that the notion of an inherently tight program does not become more general by referring to elementary loops, i.e., by replacing the part “Π′ is tight” in the statement of Definition 3 with “Π′ is e-tight.”"
    }, {
      "heading" : "6 HEF Programs and Stability Checking",
      "text" : "For a disjunctive program, the problem of deciding whether a given model is stable is coNP-complete (Eiter and Gottlob 1995). On the other hand, in view of Theorem 5, the same problem is tractable for HEF programs. In order to check the stability of a model in polynomial time, Leone et al. (1997) presented an operational framework, which, for HCF programs, allows for deciding whether a model is stable. Given a disjunctive program Π and sets X , Y of atoms, they defined a sequence R0Π,X(Y ), R 1 Π,X(Y ), . . . , which converges to a limit R ω Π,X(Y ), in the following way:\n• R0Π,X(Y ) = Y and • Ri+1Π,X(Y ) is obtained by removing every atom a from R i Π,X(Y ) such that some\nrule (12) in ΠX satisfies A ∩ (X ∪ {a}) = {a} and B ∩R i Π,X(Y ) = ∅. 12\nThe disjunctive rules considered in (Leone et al. 1997) do not admit double negations in rule bodies, but its (dis)use merely affects conditions like X |= B,F (or X 6|= B,F ) determining ΠX , while it is inconsequential otherwise. Hence, the following results remain valid for disjunctive programs whose rules are of the form (12).\n12 If Y is a subset of X, the condition “A∩ (X ∪{a}) = {a}” can be replaced with “A∩X = {a}” without altering Rω\nΠ,X (Y ).\nProposition 13 ((Leone et al. 1997, Lemma 6.4)) For any disjunctive program Π and any sets X , Y of atoms that occur in Π, all subsets of Y that are unfounded by Π w.r.t. X are contained in RωΠ,X(Y ).\nProposition 14 ((Leone et al. 1997, Proposition 6.5)) For any disjunctive programΠ and any setX of atoms that occur in Π, ifRωΠ,X(X) = ∅, then X contains no nonempty unfounded sets for Π w.r.t. X .\nProposition 15 ((Leone et al. 1997, Theorem 6.9)) For any HCF program Π and any set X of atoms that occur in Π, X contains no nonempty unfounded sets for Π w.r.t. X iff RωΠ,X(X) = ∅.\nFor a model X of Π, in view of Theoremd 1 (b′), Proposition 14 tells us that X is a stable model of Π if RωΠ,X(X) = ∅. As stated in Proposition 15, the converse also holds if Π is HCF. We below extend this result to HEF programs.\nProposition 16 For any HEF program Π, any set X of atoms, and any subset Y of X whose atoms occur in Π, if RωΠ,X(Y ) 6= ∅, then R ω Π,X(Y ) contains an elementary loop Z of Π that is unfounded by Π w.r.t. X .\nProof. Assume that RωΠ,X(Y ) 6= ∅. Then, for every rule (12) of ΠX , at least one of the following conditions holds:\n|A ∩X | > 1 , (69)\nA ∩RωΠ,X(Y ) = ∅ , (70)\nor\nB ∩RωΠ,X(Y ) 6= ∅ . (71)\nBy Propositiond 3, RωΠ,X(Y ) contains some elementary loop Z of Π that is not outbound in RωΠ,X(Y ) for Π. 13 For the sake of contradiction, assume that Z is not unfounded by Π w.r.t. X . Then there is a rule (12) in ΠX such that\nA ∩ Z 6= ∅ , (72)\nA ∩ (X \\ Z) = ∅ , (73)\nand\nB ∩ Z = ∅ . (74)\nFrom (73), since RωΠ,X(Y ) ⊆ X ,\nA ∩ (RωΠ,X(Y ) \\ Z) = ∅ ,\nwhich, in combination with (72), (74), and the fact that Z is not outbound in RωΠ,X(Y ) for Π, gives us that\nB ∩ (RωΠ,X(Y ) \\ Z) = ∅ . (75)\n13 If Rω Π,X (Y ) is an elementary loop of Π, take Z = Rω Π,X (Y ).\nFrom (74) and (75), we conclude that (71) does not hold. Furthermore, since Z ⊆ RωΠ,X(Y ), (72) implies that (70) does not hold. Hence, (69) must hold, which, in combination with (73), gives us that\n|A ∩ Z| > 1 .\nBut since Z is an elementary loop of Π, this contradicts that Π is HEF.\nWe are now ready to generalize Proposition 15 to HEF programs.\nTheorem 7 For any HEF program Π and any set X of atoms that occur in Π, X contains no nonempty unfounded sets for Π w.r.t. X iff RωΠ,X(X) = ∅.\nProof. From left to right follows immediately from Proposition 16.\nFrom right to left follows immediately from Proposition 14.\nRegarding the models of HEF programs, we derive the following corollary.\nCorollary 2 For any HEF program Π and any set X of atoms that occur in Π, X is a stable model of Π iff X is a model of Π such that RωΠ,X(X) = ∅.\nProof. Both directions follow immediately from Theoremd 1 (b′) and Theorem 7.\nFor instance, reconsider Π2 from Section 4, which is HEF, but not HCF. Hence, Corollary 2 applies, but Proposition 15 does not apply. Indeed, since RωΠ2,X(X) = X for (non-stable) model X = {p, q, r} of Π2, Corollary 2 allows us to conclude that X is not a stable model of Π2. On the other hand, for model {p} of Π2, we have that RωΠ2,{p}({p}) = ∅, which implies that {p} is a stable model of Π2.\nIn Section 3.3, we defined the notion of an elementarily unfounded set and showed that it coincides with a minimal nonempty unfounded set. Thus stability checking can be cast into the problem of ensuring the absence of elementarily unfounded sets. Since every elementarily unfounded set is a loop, it is clearly contained in a maximal loop, which allows us to modularize the consideration of (elementarily) unfounded sets. The idea of using maximal loops for partitioning a program and confining stability checking to subprograms was already exploited by Leone et al. (1997) and Koch et al. (2003). In fact, for a disjunctive program Π and a set X of atoms, Leone et al. (1997) showed how stability can be checked separately for maximal loops of Π, and Koch et al. (2003) developed this idea further by considering maximal loops of the smaller program ΠX,Rω Π,X (X). We below describe a notion called “bounding loops,” which go beyond such maximal loops.\nFor a disjunctive program Π and a set X of atoms, we say that a subset Y of X is a bounding loop of Π w.r.t. X if Y is maximal among all subsets Z of X such that Z is a loop of ΠX,Z and R ω Π,X(Z) = Z. Note that there are two crucial differences between bounding loops and elementarily unfounded sets. First, a bounding loop Y of Π w.r.t. X is not necessarily an elementary loop of ΠX,Y . Next, it does not need to be unfounded by Π w.r.t. X . To see this, observe that X = {p, q, r} is a\nbounding loop of Π2 w.r.t. X that is not (elementarily) unfounded by Π2 w.r.t. X . Furthermore, one can check that {p, r} and {q, r} are (elementarily) unfounded by Π2 w.r.t. X , and thus Proposition d 5 tells us that X is not an elementary loop of (Π2)X,X .\nThe following two propositions describe properties of bounding loops that are similar to those of maximal loops, as used in (Leone et al. 1997; Koch et al. 2003).\nProposition 17 For any disjunctive program Π and any set X of atoms, all bounding loops of Π w.r.t. X are mutually disjoint.\nProof. Let Y1, Y2 be subsets of X such that Y1 is a loop of ΠX,Y1 , Y2 is a loop of ΠX,Y2 , R ω Π,X(Y1) = Y1, and R ω Π,X(Y2) = Y2. If Y1 ∩ Y2 6= ∅, the fact that ΠX,Y1 ∪ ΠX,Y2 ⊆ ΠX,Y1∪Y2 implies that Y1 ∪ Y2 is a loop of ΠX,Y1∪Y2 . Furthermore, since RωΠ,X(Y1) = Y1 and R ω Π,X(Y2) = Y2, for any rule (12) of ΠX such that A ∩ (Y1 ∪ Y2) 6= ∅ and B ∩ (Y1 ∪ Y2) = ∅, we have that |A ∩ X | > 1, from which we conclude that RωΠ,X(Y1 ∪ Y2) = Y1 ∪ Y2. Since bounding loops of Π w.r.t. X are maximal among all subsets Z of X such that Z is a loop of ΠX,Z and R ω Π,X(Z) = Z, this shows that they must be mutually disjoint.\nProposition 18 For any disjunctive program Π and any set X of atoms that occur in Π, every elementarily unfounded set for Π w.r.t. X is a singleton or contained in some bounding loop of Π w.r.t. X .\nProof. Assume that Y is an elementarily unfounded set for Π w.r.t. X that is not a singleton. From the definition of an elementarily unfounded set, it follows that Y is a loop of ΠX,Y and a subset of X . Since Y is also unfounded by Π w.r.t. X , by Proposition 13, we have that RωΠ,X(Y ) = Y . This shows that Y is contained in some maximal subset Z of X such that Z is a loop of ΠX,Z and R ω Π,X(Z) = Z.\nProposition 17 and Proposition 18 tell us that checking the absence of elemen-\ntarily unfounded sets can be accomplished separately for bounding loops.\nProposition 19 For any disjunctive program Π and any model X of Π, X is a stable model of Π iff\n• X is supported by Π and • no bounding loop of Π w.r.t. X contains a nonempty unfounded set for Π\nw.r.t X .\nProof. From left to right follows immediately from Theoremd 1 (b′) (and the fact that every atom of X occurs in Π).\nFrom right to left: Assume that X is not a stable model of Π but supported by Π. Then, by Theoremd 1 (e′), X contains some elementarily unfounded set Y for Π w.r.t. X . If Y is not a singleton, by Proposition 18, Y is contained in some bounding loop of Π w.r.t. X . Otherwise, if Y is a singleton, the assumption that X is supported by Π implies that there is a rule (12) in ΠX,Y such that A ∩X = Y , so\nthat Y is a loop of ΠX,Y . Since Y is unfounded by Π w.r.t. X , by Proposition 13, we also have that RωΠ,X(Y ) = Y . This shows that Y is contained in some maximal subset Z of X such that Z is a loop of ΠX,Z and R ω Π,X(Z) = Z.\nAs it is easy to check that X is supported by Π, Proposition 19 tells us that the investigation of bounding loops constitutes the hard part of stability checking. But this is not due to the hardness of identifying them. In fact, the following method can be used to compute all bounding loops Z of Π w.r.t. X in polynomial time:\n1. Let Y = X . 2. Let Z = RωΠ,X(Y ). (Note that Z = R ω Π,X(Z).) 3. If Z is a loop of ΠX,Z , then mark Z as a bounding loop of Π w.r.t. X .\nOtherwise, proceed with Step 2 for every maximal loop Y of ΠX,Z that is contained in Z.\nThe soundness of this approach is straightforward, given that operator R is monotone, i.e., RωΠ,X(Z) ⊆ R ω Π,X(Y ) if Z ⊆ Y (used in Step 2), and likewise that ΠX,Y ⊆ ΠX,Z if Y ⊆ Z (used in Step 3).\nFor illustration, consider the following program Π4:\np ← r s ← p p ; q ← u q ← r s ← t s ; t ← q r ← p, q t ← s, u r ; u ← t u ; v ← .\nFor X = {p, q, r, s, t, u}, it holds that (Π4)X,X = Π4 and also that X is a loop of Π4. However, Y = R ω Π4,X (X) = {p, q, r, s, t} 6= X , so that X is not a bounding loop of Π4 w.r.t. X . On the other hand, Y is not a loop of (Π4)X,Y , which does not include the last two rules where u occurs in the head. Rather, Z = {p, q, r} and Z ′ = {s, t} are the maximal loops of (Π4)X,Y that are contained in Y . In view of the rules in the second column, RωΠ4,X(Z ′) = ∅, which shows that no subset of Z ′ is a bounding loop of Π4 w.r.t. X . For Z = {p, q, r}, we obtain RωΠ4,X(Z) = Z, and Z is also a loop of (Π4)X,Z (due to the rules in the first column). That is, Z is the single bounding loop of Π4 w.r.t. X .\nLet us compare this outcome with the ones of previous methods for modularizing stability checking. Since the approach described in (Leone et al. 1997) considers maximal loops of the original program and X = {p, q, r, s, t, u} is a (maximal) loop of Π4, it cannot be used to decompose X , and the only applicable simplification is to remove u by means of R, that is, Y = RωΠ4,X(X) = {p, q, r, s, t}. The approach in (Koch et al. 2003) considers the maximal loops of ΠX,Rω Π,X (X), which, for (Π4)X,Y , gives Z = {p, q, r} and Z ′ = {s, t}. As described in (Koch et al. 2003), since the subprograms (Π4)X,Z and (Π4)X,Z′ are not HCF, they are not simplified any further and used to separately check for a nonempty unfounded subset of Z or Z ′, respectively. Unlike this, the notion of a bounding loop allowed us to eliminate all subsets of Z ′ as potential nonempty unfounded sets.\nTurning back to HEF programs, from Proposition 16, we derive the following proposition for a subprogramΠX,Y associated with a bounding loop Y of Π w.r.t.X .\nProposition 20\nFor any disjunctive program Π, any set X of atoms, and any bounding loop Y of Π w.r.t. X , if ΠX,Y is HEF, then Y contains a nonempty unfounded set for Π w.r.t. X .\nProof. Assume that ΠX,Y is HEF. From the definition of a bounding loop, it follows that all atoms of Y occur in ΠX,Y and that Y = R ω Π,X(Y ) = R ω (ΠX,Y ),X (Y ) ⊆ X . By Proposition 16, we conclude that Rω(ΠX,Y ),X(Y ) contains an elementary loop Z of ΠX,Y that is unfounded by ΠX,Y w.r.t. X . From the definition of ΠX,Y and since Z is contained in Y , we conclude that Z is also unfounded by Π w.r.t. X .\nProposition 20 tells us that the existence of a bounding loop Y of Π w.r.t. X whose associated subprogram ΠX,Y is HEF is already sufficient to conclude that X is not a stable model of Π. Reconsidering the bounding loop Z = {p, q, r} of Π4 w.r.t. X = {p, q, r, s, t, u}, we have that (Π4)X,Z , consisting of the rules in the first column along with the disjunctive rule containing p and q in the head, is HEF (neither {p, q} nor {p, q, r} is an elementary loop of (Π4)X,Z). Thus X is not a stable model of Π4. Indeed, Z contains two (elementarily) unfounded sets for Π4 w.r.t. X : {p, r} and {q, r}."
    }, {
      "heading" : "7 Conclusion",
      "text" : "The notion of an elementary loop and its properties provide useful insights into the concept of a loop and the relationship between nondisjunctive programs and disjunctive programs. By turning to the notion of an elementary loop in place of a loop, we could strengthen the theorem by Lin and Zhao (2004), its generalization to disjunctive programs (Lee and Lifschitz 2003), and the main theorem (for programs in canonical form) from (Lee 2005). The semantic (e.g., Theoremd 2) and complexity-theoretic (e.g., Theorem 4) properties of elementary loops indicate their close relationship to unfounded sets. Compared with loops, elementary loops provide a deeper understanding of the internal structure of unfounded sets. In fact, we have shown that loop formulas of non-elementary loops are unnecessary for checking the stability of a model. It is an interesting open question whether this result can be used to improve computation performed by answer set solvers that calculate loop formulas, such as assat, claspd, and cmodels.\nA method to identify an elementarily unfounded set for an HEF program was presented in (Gebser et al. 2007).14 An orthogonal approach is implemented in claspd: it greedily adds atoms a to an unfounded set Y if Y ∪{a} stays unfounded and has a shorter loop formula than Y . However, the potential of unfounded set “optimization” has not been studied in-depth so far, and the theoretical foundations laid here may be useful for future investigations in this direction. Regarding nondisjunctive programs, elementary loops can be distinct from loops of programs called “binary” (Janhunen 2006). Moreover, modularity aspects of disjunctive stable models (Janhunen et al. 2009), which are closely related to loop formulas (Lemma 5.4 from (Janhunen et al. 2009)), can be refined by referring to elementary loops in\n14 It is omitted in this paper for brevity.\nplace of loops. Lifting elementary loops to first-order programs, as already done for loops (Chen et al. 2006; Lee and Meng 2008), may also be a direction to explore.\nThe notion of an HEF program is a strict generalization of the notion of an HCF program. On the one hand, nice properties of HCF programs still apply to HEF programs. In particular, their inherent tightness on stable models grants the soundness of shifting head atoms into the body as well as the possibility of performing stability checks in polynomial time. This however implies that a disjunctive program encoding an instance of a ΣP2 -hard problem is unlikely to be HEF. On the other hand, recognizing elementary loops and verifying the HEF property are both intractable in the case of arbitrary disjunctive programs, but tractable for nondisjunctive and HCF programs. This parallels the complexity of stability checking (Eiter and Gottlob 1995), and it also tells us that the inherent complexities of computational tasks dealing with elementary loops tightly correlate to the fragment of disjunctive programs under consideration. As the latter does not apply to recognizing loops or verifying the HCF property, the notion of an HEF program more precisely renders what makes arbitrary disjunctive programs more difficult than nondisjunctive programs. Whether this admits (syntactic) characterizations of yet unknown subclasses of disjunctive programs for which verifying the HEF property is tractable is an interesting open question."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We are grateful to Selim Erdoğan, Tomi Janhunen, Dan Lessin, Vladimir Lifschitz, Torsten Schaub, Jicheng Zhao, and the anonymous referees of (Gebser et al. 2006; Gebser et al. 2007) and this paper for their useful comments. Martin Gebser was partially supported by the German Research Foundation under Grant SCHA 550/8-1. Joohyung Lee was partially supported by the National Science Foundation under Grant IIS-0916116 and by the Office of the Director of National Intelligence (ODNI), Intelligence Advanced Research Projects Activity (IARPA), through US army. Yuliya Lierler was partially supported by the National Science Foundation under Grant IIS-0712113 and by a 2010 Computing Innovation Fellowship."
    } ],
    "references" : [ {
      "title" : "Towards a theory of declarative knowledge",
      "author" : [ "K. Apt", "H. Blair", "A. Walker" ],
      "venue" : "Foundations of Deductive Databases and Logic Programming, J. Minker, Ed. Morgan Kaufmann, 89–148.",
      "citeRegEx" : "Apt et al\\.,? 1988",
      "shortCiteRegEx" : "Apt et al\\.",
      "year" : 1988
    }, {
      "title" : "Logic programming and knowledge representation",
      "author" : [ "C. Baral", "M. Gelfond" ],
      "venue" : "Journal of Logic Programming 19,20, 73–148.",
      "citeRegEx" : "Baral and Gelfond,? 1994",
      "shortCiteRegEx" : "Baral and Gelfond",
      "year" : 1994
    }, {
      "title" : "Propositional semantics for disjunctive logic programs",
      "author" : [ "R. Ben-Eliyahu", "R. Dechter" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 12, 53–87.",
      "citeRegEx" : "Ben.Eliyahu and Dechter,? 1994",
      "shortCiteRegEx" : "Ben.Eliyahu and Dechter",
      "year" : 1994
    }, {
      "title" : "First-order loop formulas for normal logic programs",
      "author" : [ "Y. Chen", "F. Lin", "Y. Wang", "M. Zhang" ],
      "venue" : "Proceedings of the Tenth International Conference on Principles of Knowledge Representation and Reasoning (KR’06), P. Doherty, J. Mylopoulos, and C. Welty, Eds. AAAI Press, 298–307.",
      "citeRegEx" : "Chen et al\\.,? 2006",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2006
    }, {
      "title" : "Negation as failure",
      "author" : [ "K. Clark" ],
      "venue" : "Logic and Data Bases, H. Gallaire and J. Minker, Eds. Plenum Press, New York, 293–322.",
      "citeRegEx" : "Clark,? 1978",
      "shortCiteRegEx" : "Clark",
      "year" : 1978
    }, {
      "title" : "Conflict-driven disjunctive answer set solving",
      "author" : [ "C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. König", "M. Ostrowski", "T. Schaub" ],
      "venue" : "Proceedings of the Eleventh International Conference on Principles of Knowledge Representation and Reasoning (KR’08), G. Brewka and J. Lang, Eds. AAAI Press, 422–432.",
      "citeRegEx" : "Drescher et al\\.,? 2008",
      "shortCiteRegEx" : "Drescher et al\\.",
      "year" : 2008
    }, {
      "title" : "Uniform equivalence of logic programs under the stable model semantics",
      "author" : [ "T. Eiter", "M. Fink" ],
      "venue" : "Proceedings of the Nineteenth International Conference on Logic Programming (ICLP’03), C. Palamidessi, Ed. Springer-Verlag, 224–238.",
      "citeRegEx" : "Eiter and Fink,? 2003",
      "shortCiteRegEx" : "Eiter and Fink",
      "year" : 2003
    }, {
      "title" : "On the computational cost of disjunctive logic programming: Propositional case",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 15, 3-4, 289–323.",
      "citeRegEx" : "Eiter and Gottlob,? 1995",
      "shortCiteRegEx" : "Eiter and Gottlob",
      "year" : 1995
    }, {
      "title" : "Tight logic programs",
      "author" : [ "E. Erdem", "V. Lifschitz" ],
      "venue" : "Theory and Practice of Logic Programming 3, 499–518.",
      "citeRegEx" : "Erdem and Lifschitz,? 2003",
      "shortCiteRegEx" : "Erdem and Lifschitz",
      "year" : 2003
    }, {
      "title" : "Consistency of Clark’s completion and existence of stable models",
      "author" : [ "F. Fages" ],
      "venue" : "Journal of Methods of Logic in Computer Science 1, 51–60.",
      "citeRegEx" : "Fages,? 1994",
      "shortCiteRegEx" : "Fages",
      "year" : 1994
    }, {
      "title" : "On the complexity of identifying head elementary set free programs",
      "author" : [ "F. Fassetti", "L. Palopoli" ],
      "venue" : "Theory and Practice of Logic Programming 10(1), 113–123.",
      "citeRegEx" : "Fassetti and Palopoli,? 2010",
      "shortCiteRegEx" : "Fassetti and Palopoli",
      "year" : 2010
    }, {
      "title" : "A new perspective on stable models",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI’07). 372–379.",
      "citeRegEx" : "Ferraris et al\\.,? 2007",
      "shortCiteRegEx" : "Ferraris et al\\.",
      "year" : 2007
    }, {
      "title" : "Stable models and circumscription",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Artificial Intelligence 175, 236–263.",
      "citeRegEx" : "Ferraris et al\\.,? 2011",
      "shortCiteRegEx" : "Ferraris et al\\.",
      "year" : 2011
    }, {
      "title" : "Elementary sets for logic programs",
      "author" : [ "M. Gebser", "J. Lee", "Y. Lierler" ],
      "venue" : "Proceedings of the Twenty-first AAAI Conference on Artificial Intelligence (AAAI’06).",
      "citeRegEx" : "Gebser et al\\.,? 2006",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2006
    }, {
      "title" : "Head-elementary-set-free logic programs",
      "author" : [ "M. Gebser", "J. Lee", "Y. Lierler" ],
      "venue" : "Procedings of the Ninth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’07). 149–161.",
      "citeRegEx" : "Gebser et al\\.,? 2007",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2007
    }, {
      "title" : "Loops: Relevant or redundant? In Proceedings of the Eighth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’05)",
      "author" : [ "M. Gebser", "T. Schaub" ],
      "venue" : "53–65.",
      "citeRegEx" : "Gebser and Schaub,? 2005",
      "shortCiteRegEx" : "Gebser and Schaub",
      "year" : 2005
    }, {
      "title" : "Alternative characterizations for program equivalence under answer-set semantics based on unfounded sets",
      "author" : [ "M. Gebser", "T. Schaub", "H. Tompits", "S. Woltran" ],
      "venue" : "Proceedings of the Fifth International Symposium on Foundations of Information and Knowledge Systems (FoIKS’08), S. Hartmann and G. Kern-Isberner, Eds. Springer-Verlag, 24–41.",
      "citeRegEx" : "Gebser et al\\.,? 2008",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2008
    }, {
      "title" : "Disjunctive defaults",
      "author" : [ "M. Gelfond", "V. Lifschitz", "H. Przymusińska", "M. Truszczyński" ],
      "venue" : "Proceedings of the Second International Conference on Principles of Knowledge Representation and Reasoning (KR’91), J. Allen, R. Fikes, and E. Sandewall, Eds. 230–237.",
      "citeRegEx" : "Gelfond et al\\.,? 1991",
      "shortCiteRegEx" : "Gelfond et al\\.",
      "year" : 1991
    }, {
      "title" : "SAT-based answer set programming",
      "author" : [ "E. Giunchiglia", "Y. Lierler", "M. Maratea" ],
      "venue" : "Proceedings of the Nineteenth AAAI Conference on Artificial Intelligence (AAAI). 61–66.",
      "citeRegEx" : "Giunchiglia et al\\.,? 2004",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 2004
    }, {
      "title" : "Negation as failure in the head",
      "author" : [ "K. Inoue", "C. Sakama" ],
      "venue" : "Journal of Logic Programming 35, 39–78.",
      "citeRegEx" : "Inoue and Sakama,? 1998",
      "shortCiteRegEx" : "Inoue and Sakama",
      "year" : 1998
    }, {
      "title" : "Some (in)translatability results for normal logic programs and propositional theories",
      "author" : [ "T. Janhunen" ],
      "venue" : "Journal of Applied Non-Classical Logics 16, 1-2, 35–86.",
      "citeRegEx" : "Janhunen,? 2006",
      "shortCiteRegEx" : "Janhunen",
      "year" : 2006
    }, {
      "title" : "Unfolding partiality and disjunctions in stable model semantics",
      "author" : [ "T. Janhunen", "I. Niemelä", "D. Seipel", "P. Simons", "You", "J.-H." ],
      "venue" : "ACM Transactions on Computational Logic 7, 1, 1–37.",
      "citeRegEx" : "Janhunen et al\\.,? 2006",
      "shortCiteRegEx" : "Janhunen et al\\.",
      "year" : 2006
    }, {
      "title" : "Modularity aspects of disjunctive stable models",
      "author" : [ "T. Janhunen", "E. Oikarinen", "H. Tompits", "S. Woltran" ],
      "venue" : "Journal of Artificial Intelligence Research 35, 813– 857.",
      "citeRegEx" : "Janhunen et al\\.,? 2009",
      "shortCiteRegEx" : "Janhunen et al\\.",
      "year" : 2009
    }, {
      "title" : "Enhancing disjunctive logic programming systems by SAT checkers",
      "author" : [ "C. Koch", "N. Leone", "G. Pfeifer" ],
      "venue" : "Artificial Intelligence 151, 177–212.",
      "citeRegEx" : "Koch et al\\.,? 2003",
      "shortCiteRegEx" : "Koch et al\\.",
      "year" : 2003
    }, {
      "title" : "Nondefinite vs",
      "author" : [ "J. Lee" ],
      "venue" : "definite causal theories. In Proceedings of the Seventh International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’04). 141–153.",
      "citeRegEx" : "Lee,? 2004",
      "shortCiteRegEx" : "Lee",
      "year" : 2004
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "J. Lee" ],
      "venue" : "Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI’05). Professional Book Center, 503–508.",
      "citeRegEx" : "Lee,? 2005",
      "shortCiteRegEx" : "Lee",
      "year" : 2005
    }, {
      "title" : "Loop formulas for disjunctive logic programs",
      "author" : [ "J. Lee", "V. Lifschitz" ],
      "venue" : "Proceedings of Nineteenth International Conference on Logic Programming (ICLP’03). 451–465.",
      "citeRegEx" : "Lee and Lifschitz,? 2003",
      "shortCiteRegEx" : "Lee and Lifschitz",
      "year" : 2003
    }, {
      "title" : "Loop formulas for circumscription",
      "author" : [ "J. Lee", "F. Lin" ],
      "venue" : "Artificial Intelligence 170, 2, 160–185.",
      "citeRegEx" : "Lee and Lin,? 2006",
      "shortCiteRegEx" : "Lee and Lin",
      "year" : 2006
    }, {
      "title" : "On loop formulas with variables",
      "author" : [ "J. Lee", "Y. Meng" ],
      "venue" : "Proceedings of the Eleventh International Conference on Knowledge Representation and Reasoning (KR’08). 444–453.",
      "citeRegEx" : "Lee and Meng,? 2008",
      "shortCiteRegEx" : "Lee and Meng",
      "year" : 2008
    }, {
      "title" : "On reductive semantics of aggregates in answer set programming",
      "author" : [ "J. Lee", "Y. Meng" ],
      "venue" : "Procedings of the Tenth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’09). 182–195.",
      "citeRegEx" : "Lee and Meng,? 2009",
      "shortCiteRegEx" : "Lee and Meng",
      "year" : 2009
    }, {
      "title" : "The dlv system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7, 3.",
      "citeRegEx" : "Leone et al\\.,? 2006",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2006
    }, {
      "title" : "Disjunctive stable models: Unfounded sets, fixpoint semantics, and computation",
      "author" : [ "N. Leone", "P. Rullo", "F. Scarcello" ],
      "venue" : "Information and Computation 135(2), 69– 112.",
      "citeRegEx" : "Leone et al\\.,? 1997",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 1997
    }, {
      "title" : "cmodels: SAT-based disjunctive answer set solver",
      "author" : [ "Y. Lierler" ],
      "venue" : "Proceedings of the Eighth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’05). 447–452.",
      "citeRegEx" : "Lierler,? 2005",
      "shortCiteRegEx" : "Lierler",
      "year" : 2005
    }, {
      "title" : "Nested expressions in logic programs",
      "author" : [ "V. Lifschitz", "L.R. Tang", "H. Turner" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 369–389.",
      "citeRegEx" : "Lifschitz et al\\.,? 1999",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 1999
    }, {
      "title" : "Why are there so many loop formulas",
      "author" : [ "V. Lifschitz", "A. Razborov" ],
      "venue" : "ACM Transactions on Computational Logic 7,",
      "citeRegEx" : "Lifschitz and Razborov,? \\Q2006\\E",
      "shortCiteRegEx" : "Lifschitz and Razborov",
      "year" : 2006
    }, {
      "title" : "On tight logic programs and yet another translation from normal logic programs to propositional logic",
      "author" : [ "F. Lin", "J. Zhao" ],
      "venue" : "Proceedings of the Eighteenth International Joint Conference on Artificial Intelligence (IJCAI’03). 853–858.",
      "citeRegEx" : "Lin and Zhao,? 2003",
      "shortCiteRegEx" : "Lin and Zhao",
      "year" : 2003
    }, {
      "title" : "ASSAT: Computing answer sets of a logic program by SAT solvers",
      "author" : [ "F. Lin", "Y. Zhao" ],
      "venue" : "Artificial Intelligence 157, 115–137.",
      "citeRegEx" : "Lin and Zhao,? 2004",
      "shortCiteRegEx" : "Lin and Zhao",
      "year" : 2004
    }, {
      "title" : "Properties and applications of programs with monotone and convex constraints",
      "author" : [ "L. Liu", "M. Truszczynski" ],
      "venue" : "Journal of Artificial Intelligence Research 27, 299– 334.",
      "citeRegEx" : "Liu and Truszczynski,? 2006",
      "shortCiteRegEx" : "Liu and Truszczynski",
      "year" : 2006
    }, {
      "title" : "Stable models and non-determinism in logic programs with negation",
      "author" : [ "D. Saccá", "C. Zaniolo" ],
      "venue" : "Proceedings of the Ninth ACM Symposium on Principles of Database Systems (PODS). 205–217.",
      "citeRegEx" : "Saccá and Zaniolo,? 1990",
      "shortCiteRegEx" : "Saccá and Zaniolo",
      "year" : 1990
    }, {
      "title" : "Loop formulas for logic programs with arbitrary constraint atoms",
      "author" : [ "You", "J.-H.", "G. Liu" ],
      "venue" : "Proceedings of the Twenty-third AAAI Conference on Artificial Intelligence (AAAI’08). 584–589.",
      "citeRegEx" : "You et al\\.,? 2008",
      "shortCiteRegEx" : "You et al\\.",
      "year" : 2008
    }, {
      "title" : "On the equivalence between answer sets and models of completion for nested logic programs",
      "author" : [ "You", "J.-H.", "Yuan", "L.-Y.", "M. Zhang" ],
      "venue" : "Proceedings of the Eighteenth International Joint Conference on Artificial Intelligence (IJCAI’03). 859–866.",
      "citeRegEx" : "You et al\\.,? 2003",
      "shortCiteRegEx" : "You et al\\.",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "Unlike other translations that modify the vocabulary of a logic program (Ben-Eliyahu and Dechter 1994; Lin and Zhao 2003; Janhunen 2006), the original",
      "startOffset" : 72,
      "endOffset" : 136
    }, {
      "referenceID" : 35,
      "context" : "Unlike other translations that modify the vocabulary of a logic program (Ben-Eliyahu and Dechter 1994; Lin and Zhao 2003; Janhunen 2006), the original",
      "startOffset" : 72,
      "endOffset" : 136
    }, {
      "referenceID" : 20,
      "context" : "Unlike other translations that modify the vocabulary of a logic program (Ben-Eliyahu and Dechter 1994; Lin and Zhao 2003; Janhunen 2006), the original",
      "startOffset" : 72,
      "endOffset" : 136
    }, {
      "referenceID" : 33,
      "context" : "The theorem on loop formulas due to Lin and Zhao (2004) has contributed to understanding the relationship between the stable model semantics and classical logic.",
      "startOffset" : 36,
      "endOffset" : 56
    }, {
      "referenceID" : 36,
      "context" : "This allows us to compute stable models using SAT solvers, which led to the design of answer set solvers assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al.",
      "startOffset" : 111,
      "endOffset" : 130
    }, {
      "referenceID" : 18,
      "context" : "This allows us to compute stable models using SAT solvers, which led to the design of answer set solvers assat (Lin and Zhao 2004) and cmodels (Giunchiglia et al. 2004).",
      "startOffset" : 143,
      "endOffset" : 168
    }, {
      "referenceID" : 26,
      "context" : "Due to its importance in semantic understanding as well as in stable model computation, the theorem on loop formulas has been extended to more general classes of logic programs, such as disjunctive programs (Lee and Lifschitz 2003), infinite programs and programs containing classical negation (Lee 2005), and programs containing aggregates (Liu and Truszczynski 2006; You and Liu 2008; Lee and Meng 2009).",
      "startOffset" : 207,
      "endOffset" : 231
    }, {
      "referenceID" : 25,
      "context" : "Due to its importance in semantic understanding as well as in stable model computation, the theorem on loop formulas has been extended to more general classes of logic programs, such as disjunctive programs (Lee and Lifschitz 2003), infinite programs and programs containing classical negation (Lee 2005), and programs containing aggregates (Liu and Truszczynski 2006; You and Liu 2008; Lee and Meng 2009).",
      "startOffset" : 294,
      "endOffset" : 304
    }, {
      "referenceID" : 37,
      "context" : "Due to its importance in semantic understanding as well as in stable model computation, the theorem on loop formulas has been extended to more general classes of logic programs, such as disjunctive programs (Lee and Lifschitz 2003), infinite programs and programs containing classical negation (Lee 2005), and programs containing aggregates (Liu and Truszczynski 2006; You and Liu 2008; Lee and Meng 2009).",
      "startOffset" : 341,
      "endOffset" : 405
    }, {
      "referenceID" : 29,
      "context" : "Due to its importance in semantic understanding as well as in stable model computation, the theorem on loop formulas has been extended to more general classes of logic programs, such as disjunctive programs (Lee and Lifschitz 2003), infinite programs and programs containing classical negation (Lee 2005), and programs containing aggregates (Liu and Truszczynski 2006; You and Liu 2008; Lee and Meng 2009).",
      "startOffset" : 341,
      "endOffset" : 405
    }, {
      "referenceID" : 27,
      "context" : "Moreover, it has been applied to other nonmonotonic logics, such as circumscription (Lee and Lin 2006) and nonmonotonic causal logic (Lee 2004).",
      "startOffset" : 84,
      "endOffset" : 102
    }, {
      "referenceID" : 24,
      "context" : "Moreover, it has been applied to other nonmonotonic logics, such as circumscription (Lee and Lin 2006) and nonmonotonic causal logic (Lee 2004).",
      "startOffset" : 133,
      "endOffset" : 143
    }, {
      "referenceID" : 11,
      "context" : "The stable model semantics for first-order formulas given in (Ferraris et al. 2007; Ferraris et al. 2011) is also closely related to the idea of loop formulas, as described in (Lee and Meng 2008).",
      "startOffset" : 61,
      "endOffset" : 105
    }, {
      "referenceID" : 12,
      "context" : "The stable model semantics for first-order formulas given in (Ferraris et al. 2007; Ferraris et al. 2011) is also closely related to the idea of loop formulas, as described in (Lee and Meng 2008).",
      "startOffset" : 61,
      "endOffset" : 105
    }, {
      "referenceID" : 28,
      "context" : "2011) is also closely related to the idea of loop formulas, as described in (Lee and Meng 2008).",
      "startOffset" : 76,
      "endOffset" : 95
    }, {
      "referenceID" : 4,
      "context" : "By slightly modifying the definition of a loop, Lee (2005) showed that loop formulas can be viewed as a generalization of completion (Clark 1978).",
      "startOffset" : 133,
      "endOffset" : 145
    }, {
      "referenceID" : 25,
      "context" : "The modeltheoretic account of loop formulas give in (Lee 2005) also tells us that the idea of loop formulas is closely related to assumption sets (Saccá and Zaniolo 1990) or unfounded sets (Leone et al.",
      "startOffset" : 52,
      "endOffset" : 62
    }, {
      "referenceID" : 38,
      "context" : "The modeltheoretic account of loop formulas give in (Lee 2005) also tells us that the idea of loop formulas is closely related to assumption sets (Saccá and Zaniolo 1990) or unfounded sets (Leone et al.",
      "startOffset" : 146,
      "endOffset" : 170
    }, {
      "referenceID" : 31,
      "context" : "The modeltheoretic account of loop formulas give in (Lee 2005) also tells us that the idea of loop formulas is closely related to assumption sets (Saccá and Zaniolo 1990) or unfounded sets (Leone et al. 1997).",
      "startOffset" : 189,
      "endOffset" : 208
    }, {
      "referenceID" : 38,
      "context" : "In a sense, the theorem by Lin and Zhao is an enhancement of the unfounded set based characterization of stable models given in (Saccá and Zaniolo 1990; Leone et al. 1997).",
      "startOffset" : 128,
      "endOffset" : 171
    }, {
      "referenceID" : 31,
      "context" : "In a sense, the theorem by Lin and Zhao is an enhancement of the unfounded set based characterization of stable models given in (Saccá and Zaniolo 1990; Leone et al. 1997).",
      "startOffset" : 128,
      "endOffset" : 171
    }, {
      "referenceID" : 17,
      "context" : "Like an HCF program, an HEF program can be turned into an equivalent nondisjunctive program in polynomial time by shifting head atoms into the body—a simple transformation defined in (Gelfond et al. 1991).",
      "startOffset" : 183,
      "endOffset" : 204
    }, {
      "referenceID" : 35,
      "context" : "The main results from (Lin and Zhao 2003) and (You et al.",
      "startOffset" : 22,
      "endOffset" : 41
    }, {
      "referenceID" : 40,
      "context" : "The main results from (Lin and Zhao 2003) and (You et al. 2003), characterizing stable models in terms of inherent tightness and weak tightness, respectively, can be extended to HEF programs, and likewise the operational characterization of stable models of HCF programs due to Leone et al.",
      "startOffset" : 46,
      "endOffset" : 63
    }, {
      "referenceID" : 9,
      "context" : "The stable model semantics for first-order formulas given in (Ferraris et al. 2007; Ferraris et al. 2011) is also closely related to the idea of loop formulas, as described in (Lee and Meng 2008). By slightly modifying the definition of a loop, Lee (2005) showed that loop formulas can be viewed as a generalization of completion (Clark 1978).",
      "startOffset" : 62,
      "endOffset" : 256
    }, {
      "referenceID" : 3,
      "context" : "By slightly modifying the definition of a loop, Lee (2005) showed that loop formulas can be viewed as a generalization of completion (Clark 1978). The modeltheoretic account of loop formulas give in (Lee 2005) also tells us that the idea of loop formulas is closely related to assumption sets (Saccá and Zaniolo 1990) or unfounded sets (Leone et al. 1997). In a sense, the theorem by Lin and Zhao is an enhancement of the unfounded set based characterization of stable models given in (Saccá and Zaniolo 1990; Leone et al. 1997). The unfounded set based characterization takes into account the loop formulas of all sets of atoms, while the theorem by Lin and Zhao considers the loop formulas of loops only. Gebser and Schaub (2005) improved this enhancement even further.",
      "startOffset" : 134,
      "endOffset" : 732
    }, {
      "referenceID" : 2,
      "context" : "Based on the notion of an elementary loop, we present the class of Head-Elementary-loop-Free (HEF) program, which strictly generalizes the class of Head-Cycle-Free (HCF) programs due to Ben-Eliyahu and Dechter (1994). Like an HCF program, an HEF program can be turned into an equivalent nondisjunctive program in polynomial time by shifting head atoms into the body—a simple transformation defined in (Gelfond et al.",
      "startOffset" : 186,
      "endOffset" : 217
    }, {
      "referenceID" : 2,
      "context" : "Based on the notion of an elementary loop, we present the class of Head-Elementary-loop-Free (HEF) program, which strictly generalizes the class of Head-Cycle-Free (HCF) programs due to Ben-Eliyahu and Dechter (1994). Like an HCF program, an HEF program can be turned into an equivalent nondisjunctive program in polynomial time by shifting head atoms into the body—a simple transformation defined in (Gelfond et al. 1991). This tells us that an HEF program is an “easy” disjunctive program, which is merely a syntactic variant of a nondisjunctive program. We also observe that several other properties of nondisjunctive and HCF programs can be generalized to HEF programs. The main results from (Lin and Zhao 2003) and (You et al. 2003), characterizing stable models in terms of inherent tightness and weak tightness, respectively, can be extended to HEF programs, and likewise the operational characterization of stable models of HCF programs due to Leone et al. (1997) can be extended to HEF pro-",
      "startOffset" : 186,
      "endOffset" : 972
    }, {
      "referenceID" : 5,
      "context" : "The properties of elementary loops and HEF programs studied here may be useful in improving the computation of disjunctive answer set solvers, such as claspd (Drescher et al. 2008), cmodels (Lierler 2005), dlv (Leone et al.",
      "startOffset" : 158,
      "endOffset" : 180
    }, {
      "referenceID" : 32,
      "context" : "2008), cmodels (Lierler 2005), dlv (Leone et al.",
      "startOffset" : 15,
      "endOffset" : 29
    }, {
      "referenceID" : 30,
      "context" : "2008), cmodels (Lierler 2005), dlv (Leone et al. 2006), and gnt (Janhunen et al.",
      "startOffset" : 35,
      "endOffset" : 54
    }, {
      "referenceID" : 21,
      "context" : "2006), and gnt (Janhunen et al. 2006).",
      "startOffset" : 15,
      "endOffset" : 37
    }, {
      "referenceID" : 13,
      "context" : "This paper is an extended version of the conference papers (Gebser et al. 2006) and (Gebser et al.",
      "startOffset" : 59,
      "endOffset" : 79
    }, {
      "referenceID" : 14,
      "context" : "2006) and (Gebser et al. 2007).",
      "startOffset" : 10,
      "endOffset" : 30
    }, {
      "referenceID" : 15,
      "context" : ") Finally, we compare our reformulation of elementary loops with the definition by Gebser and Schaub (2005).",
      "startOffset" : 83,
      "endOffset" : 108
    }, {
      "referenceID" : 13,
      "context" : "fi/Software/gnt/ 6 In (Gebser et al. 2006; Gebser et al. 2007), the term “elementary set” was used in place of “elementary loop.",
      "startOffset" : 22,
      "endOffset" : 62
    }, {
      "referenceID" : 14,
      "context" : "fi/Software/gnt/ 6 In (Gebser et al. 2006; Gebser et al. 2007), the term “elementary set” was used in place of “elementary loop.",
      "startOffset" : 22,
      "endOffset" : 62
    }, {
      "referenceID" : 25,
      "context" : "stability of a model by loop formulas, is a part of the main theorem from (Lee 2005) for the nondisjunctive case.",
      "startOffset" : 74,
      "endOffset" : 84
    }, {
      "referenceID" : 25,
      "context" : "Theorem 1 ((Lee 2005)) For any nondisjunctive program Π and any set X of atoms that occur in Π, if X is a model of Π, then the following conditions are equivalent:",
      "startOffset" : 11,
      "endOffset" : 21
    }, {
      "referenceID" : 25,
      "context" : "As noted in (Lee 2005), the equivalence between conditions (a) and (c) is a reformulation of the theorem by Lin and Zhao; the equivalence between conditions (a) and (b) is a reformulation of Corollary 2 from (Saccá and Zaniolo 1990) and Theorem 4.",
      "startOffset" : 12,
      "endOffset" : 22
    }, {
      "referenceID" : 38,
      "context" : "As noted in (Lee 2005), the equivalence between conditions (a) and (c) is a reformulation of the theorem by Lin and Zhao; the equivalence between conditions (a) and (b) is a reformulation of Corollary 2 from (Saccá and Zaniolo 1990) and Theorem 4.",
      "startOffset" : 208,
      "endOffset" : 232
    }, {
      "referenceID" : 31,
      "context" : "6 from (Leone et al. 1997) (in the nondisjunctive case), which characterizes the stability of a model in terms of unfounded sets.",
      "startOffset" : 7,
      "endOffset" : 26
    }, {
      "referenceID" : 15,
      "context" : "This yields the following theorem, which is a reformulation of Theorem 3 from (Gebser and Schaub 2005).",
      "startOffset" : 78,
      "endOffset" : 102
    }, {
      "referenceID" : 15,
      "context" : "It is essentially a reformulation of Theorem 5 from (Gebser and Schaub 2005).",
      "startOffset" : 52,
      "endOffset" : 76
    }, {
      "referenceID" : 15,
      "context" : "7 Elementarily unfounded sets are closely related to “active elementary loops” defined in (Gebser and Schaub 2005).",
      "startOffset" : 90,
      "endOffset" : 114
    }, {
      "referenceID" : 16,
      "context" : "Notably, the correspondence between elementarily unfounded sets and minimal nonempty unfounded sets has also led to an alternative characterization of UEmodels (Gebser et al. 2008), which characterizes uniform equivalence (Eiter and Fink 2003) of nondisjunctive programs as well as disjunctive programs.",
      "startOffset" : 160,
      "endOffset" : 180
    }, {
      "referenceID" : 6,
      "context" : "2008), which characterizes uniform equivalence (Eiter and Fink 2003) of nondisjunctive programs as well as disjunctive programs.",
      "startOffset" : 47,
      "endOffset" : 68
    }, {
      "referenceID" : 34,
      "context" : "Since there are exponentially many “relevant” loops in the worst case (Lifschitz and Razborov 2006), SAT-based answer set solvers do not add all loop formulas at once.",
      "startOffset" : 70,
      "endOffset" : 99
    }, {
      "referenceID" : 15,
      "context" : "However, Gebser and Schaub (2005) showed that this is not the case for nondisjunctive programs.",
      "startOffset" : 9,
      "endOffset" : 34
    }, {
      "referenceID" : 15,
      "context" : "The following theorem is similar to Theorem 10 from (Gebser and Schaub 2005), but instead of referring to the notion of a body-head dependency graph, it refers to the notion of an elementary subgraph.",
      "startOffset" : 52,
      "endOffset" : 76
    }, {
      "referenceID" : 15,
      "context" : "In this section, we compare our reformulation of elementary loops with the original definition by Gebser and Schaub (2005) for nondisjunctive programs.",
      "startOffset" : 98,
      "endOffset" : 123
    }, {
      "referenceID" : 15,
      "context" : "Definition 1 ((Gebser and Schaub 2005)) A nontrivial loop L of a nondisjunctive program Π is called a GS-elementary loop of Π if R Π(L ) ∩R Π(L) 6= ∅ for all proper subsets L ′ of L that are nontrivial loops of Π.",
      "startOffset" : 14,
      "endOffset" : 38
    }, {
      "referenceID" : 36,
      "context" : "8 In (Lin and Zhao 2004) and (Gebser and Schaub 2005), loops were defined to be nontrivial.",
      "startOffset" : 5,
      "endOffset" : 24
    }, {
      "referenceID" : 15,
      "context" : "8 In (Lin and Zhao 2004) and (Gebser and Schaub 2005), loops were defined to be nontrivial.",
      "startOffset" : 29,
      "endOffset" : 53
    }, {
      "referenceID" : 15,
      "context" : "Thus an active elementary loop of Π according to (Gebser and Schaub 2005) is a nontrivial elementary loop of ΠX that is unfounded by Π w.",
      "startOffset" : 49,
      "endOffset" : 73
    }, {
      "referenceID" : 36,
      "context" : "This originates from the difference between the definition of a loop in (Lin and Zhao 2004) and its reformulation given in (Lee 2005).",
      "startOffset" : 72,
      "endOffset" : 91
    }, {
      "referenceID" : 25,
      "context" : "This originates from the difference between the definition of a loop in (Lin and Zhao 2004) and its reformulation given in (Lee 2005).",
      "startOffset" : 123,
      "endOffset" : 133
    }, {
      "referenceID" : 25,
      "context" : "As shown in the main theorem from (Lee 2005), identifying a trivial loop as a loop admits a simpler reformulation of the Lin-Zhao theorem by allowing us to view completion formulas (Clark 1978) as a special case of loop formulas.",
      "startOffset" : 34,
      "endOffset" : 44
    }, {
      "referenceID" : 4,
      "context" : "As shown in the main theorem from (Lee 2005), identifying a trivial loop as a loop admits a simpler reformulation of the Lin-Zhao theorem by allowing us to view completion formulas (Clark 1978) as a special case of loop formulas.",
      "startOffset" : 181,
      "endOffset" : 193
    }, {
      "referenceID" : 33,
      "context" : "Note that any program with nested expressions can be turned into an equivalent program whose rules are of the form (11) (Lifschitz et al. 1999).",
      "startOffset" : 120,
      "endOffset" : 143
    }, {
      "referenceID" : 25,
      "context" : "As shown in (Lee 2005), Theorem 1 remains correct after replacing “nondisjunctive program” in its statement with “disjunctive program.",
      "startOffset" : 12,
      "endOffset" : 22
    }, {
      "referenceID" : 25,
      "context" : "Theorem 1 ((Lee 2005)) For any disjunctive program Π and any set X of atoms that occur in Π, if X is a model of Π, then the following conditions are equivalent: 9",
      "startOffset" : 11,
      "endOffset" : 21
    }, {
      "referenceID" : 31,
      "context" : "For coNP-hardness, we reduce the coNP-hard problem of deciding whether a finite set X of atoms is “unfounded-free” for a disjunctive program Π (Leone et al. 1997), i.",
      "startOffset" : 143,
      "endOffset" : 162
    }, {
      "referenceID" : 2,
      "context" : "However, for the class of disjunctive programs called “Head-Cycle-Free” (Ben-Eliyahu and Dechter 1994), deciding whether a set of atoms is an elementary loop is tractable.",
      "startOffset" : 72,
      "endOffset" : 102
    }, {
      "referenceID" : 7,
      "context" : "In general, computing stable models of a disjunctive program is harder than computing stable models of a nondisjunctive program (Eiter and Gottlob 1995).",
      "startOffset" : 128,
      "endOffset" : 152
    }, {
      "referenceID" : 2,
      "context" : "On the other hand, HCF programs are “easy” disjunctive programs that can be turned into equivalent nondisjunctive programs in polynomial time (Ben-Eliyahu and Dechter 1994).",
      "startOffset" : 142,
      "endOffset" : 172
    }, {
      "referenceID" : 2,
      "context" : "Although the converse does not hold in general, Ben-Eliyahu and Dechter (1994) showed that the converse holds if Π is HCF.",
      "startOffset" : 48,
      "endOffset" : 79
    }, {
      "referenceID" : 7,
      "context" : "(In the case of arbitrary disjunctive programs, it is coNP-complete (Eiter and Gottlob 1995).",
      "startOffset" : 68,
      "endOffset" : 92
    }, {
      "referenceID" : 10,
      "context" : "While an HCF program can be recognized in polynomial time (by computing the strongly connected components of its dependency graph), Fassetti and Palopoli (2010) showed that deciding whether a disjunctive program is HEF is coNP-complete.",
      "startOffset" : 132,
      "endOffset" : 161
    }, {
      "referenceID" : 14,
      "context" : "10 The problem was left open in (Gebser et al. 2007), one of our conference papers that this paper extends.",
      "startOffset" : 32,
      "endOffset" : 52
    }, {
      "referenceID" : 10,
      "context" : "As noted in (Fassetti and Palopoli 2010), identifying subclasses of (not necessarily HCF) disjunctive programs for which verifying the HEF property is tractable may be an interesting line of future research.",
      "startOffset" : 12,
      "endOffset" : 40
    }, {
      "referenceID" : 9,
      "context" : "In fact, if Π is nondisjunctive, it is known that the subset Π can be further restricted to a “tight” program (Fages 1994; Erdem and Lifschitz 2003)—the result known as “inherently tight” (Lin and Zhao 2003) or “weakly tight” (You et al.",
      "startOffset" : 110,
      "endOffset" : 148
    }, {
      "referenceID" : 8,
      "context" : "In fact, if Π is nondisjunctive, it is known that the subset Π can be further restricted to a “tight” program (Fages 1994; Erdem and Lifschitz 2003)—the result known as “inherently tight” (Lin and Zhao 2003) or “weakly tight” (You et al.",
      "startOffset" : 110,
      "endOffset" : 148
    }, {
      "referenceID" : 35,
      "context" : "In fact, if Π is nondisjunctive, it is known that the subset Π can be further restricted to a “tight” program (Fages 1994; Erdem and Lifschitz 2003)—the result known as “inherently tight” (Lin and Zhao 2003) or “weakly tight” (You et al.",
      "startOffset" : 188,
      "endOffset" : 207
    }, {
      "referenceID" : 40,
      "context" : "In fact, if Π is nondisjunctive, it is known that the subset Π can be further restricted to a “tight” program (Fages 1994; Erdem and Lifschitz 2003)—the result known as “inherently tight” (Lin and Zhao 2003) or “weakly tight” (You et al. 2003) program.",
      "startOffset" : 226,
      "endOffset" : 243
    }, {
      "referenceID" : 25,
      "context" : "Definition 2 ((Lee 2005)) A disjunctive program Π is called tight if every loop of Π is trivial.",
      "startOffset" : 14,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "As defined previously (Apt et al. 1988; Baral and Gelfond 1994; Inoue and Sakama 1998; Lee 2005), we call a set X of atoms supported by a disjunctive program Π if, for every a ∈ X , there is a rule (12) in ΠX such that A ∩X = {a}.",
      "startOffset" : 22,
      "endOffset" : 96
    }, {
      "referenceID" : 1,
      "context" : "As defined previously (Apt et al. 1988; Baral and Gelfond 1994; Inoue and Sakama 1998; Lee 2005), we call a set X of atoms supported by a disjunctive program Π if, for every a ∈ X , there is a rule (12) in ΠX such that A ∩X = {a}.",
      "startOffset" : 22,
      "endOffset" : 96
    }, {
      "referenceID" : 19,
      "context" : "As defined previously (Apt et al. 1988; Baral and Gelfond 1994; Inoue and Sakama 1998; Lee 2005), we call a set X of atoms supported by a disjunctive program Π if, for every a ∈ X , there is a rule (12) in ΠX such that A ∩X = {a}.",
      "startOffset" : 22,
      "endOffset" : 96
    }, {
      "referenceID" : 25,
      "context" : "As defined previously (Apt et al. 1988; Baral and Gelfond 1994; Inoue and Sakama 1998; Lee 2005), we call a set X of atoms supported by a disjunctive program Π if, for every a ∈ X , there is a rule (12) in ΠX such that A ∩X = {a}.",
      "startOffset" : 22,
      "endOffset" : 96
    }, {
      "referenceID" : 0,
      "context" : "As defined previously (Apt et al. 1988; Baral and Gelfond 1994; Inoue and Sakama 1998; Lee 2005), we call a set X of atoms supported by a disjunctive program Π if, for every a ∈ X , there is a rule (12) in ΠX such that A ∩X = {a}. Note that Definition 2 and the notion of support also apply to nondisjunctive programs as a special case. The property of inherent tightness, introduced by Lin and Zhao (2003) for the case of nondisjunctive programs, can now be reformulated and generalized as follows.",
      "startOffset" : 23,
      "endOffset" : 407
    }, {
      "referenceID" : 9,
      "context" : "In the case of nondisjunctive programs, this reformulation of inherent tightness is similar to “well-supportedness” (Fages 1994).",
      "startOffset" : 116,
      "endOffset" : 128
    }, {
      "referenceID" : 40,
      "context" : "Furthermore, weak tightness, introduced in (You et al. 2003), is closely related to the notion of inherent tightness.",
      "startOffset" : 43,
      "endOffset" : 60
    }, {
      "referenceID" : 9,
      "context" : "Proposition 10 ((Fages 1994; Lin and Zhao 2003; You et al. 2003)) For any nondisjunctive program Π and any model X of Π, X is a stable model of Π iff Π is inherently tight on X .",
      "startOffset" : 16,
      "endOffset" : 64
    }, {
      "referenceID" : 35,
      "context" : "Proposition 10 ((Fages 1994; Lin and Zhao 2003; You et al. 2003)) For any nondisjunctive program Π and any model X of Π, X is a stable model of Π iff Π is inherently tight on X .",
      "startOffset" : 16,
      "endOffset" : 64
    }, {
      "referenceID" : 40,
      "context" : "Proposition 10 ((Fages 1994; Lin and Zhao 2003; You et al. 2003)) For any nondisjunctive program Π and any model X of Π, X is a stable model of Π iff Π is inherently tight on X .",
      "startOffset" : 16,
      "endOffset" : 64
    }, {
      "referenceID" : 26,
      "context" : "By Proposition 2 from (Lee and Lifschitz 2003), X is a stable model of Π, and, by Proposition 9, X is a stable model of Π.",
      "startOffset" : 22,
      "endOffset" : 46
    }, {
      "referenceID" : 9,
      "context" : "But is the class of e-tight programs more general than the class of tight programs? One reason why this is an interesting question to consider is because, if so, it would lead to a generalization of Fages’ theorem (Fages 1994), which would yield a more general class of programs for which the stable model semantics coincides with the completion semantics.",
      "startOffset" : 214,
      "endOffset" : 226
    }, {
      "referenceID" : 7,
      "context" : "For a disjunctive program, the problem of deciding whether a given model is stable is coNP-complete (Eiter and Gottlob 1995).",
      "startOffset" : 100,
      "endOffset" : 124
    }, {
      "referenceID" : 7,
      "context" : "For a disjunctive program, the problem of deciding whether a given model is stable is coNP-complete (Eiter and Gottlob 1995). On the other hand, in view of Theorem 5, the same problem is tractable for HEF programs. In order to check the stability of a model in polynomial time, Leone et al. (1997) presented an operational framework, which, for HCF programs, allows for deciding whether a model is stable.",
      "startOffset" : 101,
      "endOffset" : 298
    }, {
      "referenceID" : 31,
      "context" : "12 The disjunctive rules considered in (Leone et al. 1997) do not admit double negations in rule bodies, but its (dis)use merely affects conditions like X |= B,F (or X 6|= B,F ) determining ΠX , while it is inconsequential otherwise.",
      "startOffset" : 39,
      "endOffset" : 58
    }, {
      "referenceID" : 29,
      "context" : "The idea of using maximal loops for partitioning a program and confining stability checking to subprograms was already exploited by Leone et al. (1997) and Koch et al.",
      "startOffset" : 132,
      "endOffset" : 152
    }, {
      "referenceID" : 23,
      "context" : "(1997) and Koch et al. (2003). In fact, for a disjunctive program Π and a set X of atoms, Leone et al.",
      "startOffset" : 11,
      "endOffset" : 30
    }, {
      "referenceID" : 23,
      "context" : "(1997) and Koch et al. (2003). In fact, for a disjunctive program Π and a set X of atoms, Leone et al. (1997) showed how stability can be checked separately for maximal loops of Π, and Koch et al.",
      "startOffset" : 11,
      "endOffset" : 110
    }, {
      "referenceID" : 23,
      "context" : "(1997) and Koch et al. (2003). In fact, for a disjunctive program Π and a set X of atoms, Leone et al. (1997) showed how stability can be checked separately for maximal loops of Π, and Koch et al. (2003) developed this idea further by considering maximal loops of the smaller program ΠX,Rω Π,X (X).",
      "startOffset" : 11,
      "endOffset" : 204
    }, {
      "referenceID" : 31,
      "context" : "The following two propositions describe properties of bounding loops that are similar to those of maximal loops, as used in (Leone et al. 1997; Koch et al. 2003).",
      "startOffset" : 124,
      "endOffset" : 161
    }, {
      "referenceID" : 23,
      "context" : "The following two propositions describe properties of bounding loops that are similar to those of maximal loops, as used in (Leone et al. 1997; Koch et al. 2003).",
      "startOffset" : 124,
      "endOffset" : 161
    }, {
      "referenceID" : 31,
      "context" : "Since the approach described in (Leone et al. 1997) considers maximal loops of the original program and X = {p, q, r, s, t, u} is a (maximal) loop of Π4, it cannot be used to decompose X , and the only applicable simplification is to remove u by means of R, that is, Y = R Π4,X(X) = {p, q, r, s, t}.",
      "startOffset" : 32,
      "endOffset" : 51
    }, {
      "referenceID" : 23,
      "context" : "The approach in (Koch et al. 2003) considers the maximal loops of ΠX,Rω Π,X (X), which, for (Π4)X,Y , gives Z = {p, q, r} and Z ′ = {s, t}.",
      "startOffset" : 16,
      "endOffset" : 34
    }, {
      "referenceID" : 23,
      "context" : "As described in (Koch et al. 2003), since the subprograms (Π4)X,Z and (Π4)X,Z′ are not HCF, they are not simplified any further and used to separately check for a nonempty unfounded subset of Z or Z , respectively.",
      "startOffset" : 16,
      "endOffset" : 34
    }, {
      "referenceID" : 26,
      "context" : "By turning to the notion of an elementary loop in place of a loop, we could strengthen the theorem by Lin and Zhao (2004), its generalization to disjunctive programs (Lee and Lifschitz 2003), and the main theorem (for programs in canonical form) from (Lee 2005).",
      "startOffset" : 166,
      "endOffset" : 190
    }, {
      "referenceID" : 25,
      "context" : "By turning to the notion of an elementary loop in place of a loop, we could strengthen the theorem by Lin and Zhao (2004), its generalization to disjunctive programs (Lee and Lifschitz 2003), and the main theorem (for programs in canonical form) from (Lee 2005).",
      "startOffset" : 251,
      "endOffset" : 261
    }, {
      "referenceID" : 14,
      "context" : "A method to identify an elementarily unfounded set for an HEF program was presented in (Gebser et al. 2007).",
      "startOffset" : 87,
      "endOffset" : 107
    }, {
      "referenceID" : 20,
      "context" : "Regarding nondisjunctive programs, elementary loops can be distinct from loops of programs called “binary” (Janhunen 2006).",
      "startOffset" : 107,
      "endOffset" : 122
    }, {
      "referenceID" : 22,
      "context" : "Moreover, modularity aspects of disjunctive stable models (Janhunen et al. 2009), which are closely related to loop formulas (Lemma 5.",
      "startOffset" : 58,
      "endOffset" : 80
    }, {
      "referenceID" : 22,
      "context" : "4 from (Janhunen et al. 2009)), can be refined by referring to elementary loops in",
      "startOffset" : 7,
      "endOffset" : 29
    }, {
      "referenceID" : 26,
      "context" : "By turning to the notion of an elementary loop in place of a loop, we could strengthen the theorem by Lin and Zhao (2004), its generalization to disjunctive programs (Lee and Lifschitz 2003), and the main theorem (for programs in canonical form) from (Lee 2005).",
      "startOffset" : 102,
      "endOffset" : 122
    }, {
      "referenceID" : 3,
      "context" : "Lifting elementary loops to first-order programs, as already done for loops (Chen et al. 2006; Lee and Meng 2008), may also be a direction to explore.",
      "startOffset" : 76,
      "endOffset" : 113
    }, {
      "referenceID" : 28,
      "context" : "Lifting elementary loops to first-order programs, as already done for loops (Chen et al. 2006; Lee and Meng 2008), may also be a direction to explore.",
      "startOffset" : 76,
      "endOffset" : 113
    }, {
      "referenceID" : 7,
      "context" : "This parallels the complexity of stability checking (Eiter and Gottlob 1995), and it also tells us that the inherent complexities of computational tasks dealing with elementary loops tightly correlate to the fragment of disjunctive programs under consideration.",
      "startOffset" : 52,
      "endOffset" : 76
    }, {
      "referenceID" : 13,
      "context" : "We are grateful to Selim Erdoğan, Tomi Janhunen, Dan Lessin, Vladimir Lifschitz, Torsten Schaub, Jicheng Zhao, and the anonymous referees of (Gebser et al. 2006; Gebser et al. 2007) and this paper for their useful comments.",
      "startOffset" : 141,
      "endOffset" : 181
    }, {
      "referenceID" : 14,
      "context" : "We are grateful to Selim Erdoğan, Tomi Janhunen, Dan Lessin, Vladimir Lifschitz, Torsten Schaub, Jicheng Zhao, and the anonymous referees of (Gebser et al. 2006; Gebser et al. 2007) and this paper for their useful comments.",
      "startOffset" : 141,
      "endOffset" : 181
    } ],
    "year" : 2011,
    "abstractText" : "Using the notion of an elementary loop, Gebser and Schaub refined the theorem on loop formulas due to Lin and Zhao by considering loop formulas of elementary loops only. In this article, we reformulate their definition of an elementary loop, extend it to disjunctive programs, and study several properties of elementary loops, including how maximal elementary loops are related to minimal unfounded sets. The results provide useful insights into the stable model semantics in terms of elementary loops. For a nondisjunctive program, using a graph-theoretic characterization of an elementary loop, we show that the problem of recognizing an elementary loop is tractable. On the other hand, we show that the corresponding problem is coNP-complete for a disjunctive program. Based on the notion of an elementary loop, we present the class of Head-Elementary-loop-Free (HEF) programs, which strictly generalizes the class of Head-Cycle-Free (HCF) programs due to Ben-Eliyahu and Dechter. Like an HCF program, an HEF program can be turned into an equivalent nondisjunctive program in polynomial time by shifting head atoms into the body.",
    "creator" : "LaTeX with hyperref package"
  }
}