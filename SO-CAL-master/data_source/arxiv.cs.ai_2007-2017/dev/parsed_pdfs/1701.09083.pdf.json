{
  "name" : "1701.09083.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Efficient Rank Aggregation via Lehmer Codes",
    "authors" : [ "Pan Li", "Arya Mazumdar", "Olgica Milenkovic" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 1.\n09 08\n3v 1\n[ cs\n.L G\n] 2\n8 Ja\nn 20\n17\nWe propose a novel rank aggregation method based on converting permutations into their corresponding Lehmer codes or other subdiagonal images. Lehmer codes, also known as inversion vectors, are vector representations of permutations in which each coordinate can take values not restricted by the values of other coordinates. This transformation allows for decoupling of the coordinates and for performing aggregation via simple scalar median or mode computations. We present simulation results illustrating the performance of this completely parallelizable approach and analytically prove that both the mode and median aggregation procedure recover the correct centroid aggregate with small sample complexity when the permutations are drawn according to the well-known Mallows models. The proposed Lehmer code approach may also be used on partial rankings, with similar performance guarantees."
    }, {
      "heading" : "1 Introduction",
      "text" : "Rank aggregation is a family of problems concerned with fusing disparate ranking information, and it arises in application areas as diverse as social choice, meta-search, natural language processing, bioinformatics, and information retrieval [1, 2, 3]. The observed rankings are either linear orders (permutations) or partial (element-tied) rankings1. Sometimes, rankings are assumed to be of the form of a set of pairwise comparisons [4, 5]. Note that, many massive ordinal datasets arise from ratings, rather than actual comparisons. Rank aggregation, rather than averaging of ratings, is justified due to the fact that most raters have different rating “scales”. As an example, the rating three of one user may indicate that the user liked the item, while the rating three by another user may indicate that the user disliked the item. Hence, actual preferences can only be deduced using ranked ratings.\nIn rank aggregation, the task at hand is to find a ranking that is at the smallest cumulative distance from a given set of rankings. Here, the cumulative distance from a set equals the sum of the distances from each element of the set, and the most frequently used distance measure for the case of permutations is the Kendall τ distance. For the case of partial rankings, the distance of choice is the Kemeny distance [6]. The Kendall τ distance between two permutations equals the smallest number of adjacent transpositions needed to convert one permutation into the other. The Kemeny distance contains an additional weighted correction term that accounts for ties in the rankings.\nIt is well known that for a wide range of distance functions, learning the underlying models and aggregating rankings is computationally hard [7]. Nevertheless, for the case when the distance measure is the Kendall τ distance, a number of approximation algorithms have been developed that offer various trade-offs between quality of aggregation and computational complexity [8, 9]. The techniques used for aggregating permutations in a given set include randomly choosing a permutation from the set (PICK-A-PERM), pivoting via random selections of elements and divide-and-conquer approaches (FAS-PIVOT), Markov chain methods akin to PageRank, and minimum weight graph matching methods exploiting the fact that the Kendall τ distance is well-approximated by the Spearman footrule distance (SM) [10]. Methods with provable performance guarantees – PICK-A-PERM, FAS-PIVOT, and SM – give a 2-approximation for the objective function, although combinations thereof are known to improve the constant to 11/7 or 4/3 [9]. There also exists a polynomial time approximation scheme (PTAS) for the aggregation problem [11].\nUnfortunately, most of these known approximate rank aggregation algorithms have high complexity for use with massive datasets and may not be implemented in a parallel fashion. Furthermore, they do\n∗A shorter version of this will appear in Artificial Intelligence and Statistics (AISTATS), 2017. †The authors are with the Coordinated Science Laboratory, Department of Electrical and Computer Engineering, University of Illinois at Urbana-Champaign (email: panli2@illinois.edu, milenkov@illinois.edu) ‡The author is with Department of Computer Science, University of Massachusetts(email: arya@cs.umass.edu). 1In the mathematics literature, partial rankings are commonly referred to as weak orders, while the term partial order is used to describe orders of subsets of elements of a ground set. We nevertheless use the term partial ranking to denote orders with ties, as this terminology is more widely adopted by the machine learning community.\nnot easily extend to partial rankings. In many cases, a performance analysis on probabilistic models [12] such as the Plackett-Luce model [13] or the Mallows model [14, 15], is intractable.\nIn this paper, we propose a new approach to the problem of rank aggregation that uses a combinatorial transform, the Lehmer code (LC). The gist of the approach is to convert permutations into their Lehmer code representations, in which each coordinate takes values independently from other coordinates. Aggregation over the Lehmer code domain reduces to computing the median or mode of a bounded set of numbers, which can be done in linear time. Furthermore, efficient conversion algorithms between permutations and Lehmer codes – also running in linear time – are known, making the overall complexity of the parallel implementation of the scheme O(m + n), where m denotes the number of permutations to be aggregated, and n denotes the length (size) of the permutations. To illustrate the performance of the Lehmer code aggregators (LCAs) on permutations, we carry out simulation studies showing that the algorithms perform comparably with the best known methods for approximate aggregation, but at a significantly lower computational cost. We then proceed to establish a number of theoretical performance guarantees for the LCA algorithms: In particular, we consider the Mallows model with the Kendall τ distance for permutations and Kemeny distance for partial rankings where ties are allowed. We show that the centroid permutation of the model or a derivative thereof may be recovered from O(log n) samples from the corresponding distribution with high probability.\nThe paper is organized as follows. Section 2 contains the mathematical preliminaries and the definitions used throughout the paper. Section 3 introduces our new aggregation methods for two types of rankings, while Section 4 describes our analysis pertaining to the Mallows and generalized Mallows models. Section 5 contains illustrative simulation results comparing the performance of the LC aggregators to that of other known aggregation methods, both on simulated and real ranking data. A number of technical results, namely detailed proofs of theorems and lemmas, can be found in the Appendix."
    }, {
      "heading" : "2 Mathematical Preliminaries",
      "text" : "Let S denote a set of n elements, which without loss of generality we assume to be equal to [n] ≡ {1, 2, . . . , n}. A ranking is an ordering of a subset of elements Q of [n] according to a predefined rule. When Q = [n], we refer to the order as a permutation (full ranking). When a ranking includes ties, we refer to it as a partial ranking (weak or bucket order). Partial rankings may be used to complete rankings of subsets of element in [n] in a number of different ways [16], one being to tie all unranked elements at the last position.\nRigorously, a permutation is a bijection σ : [n] → [n], and the set of permutations over [n] forms the symmetric group of order n! denoted by Sn. For any σ ∈ Sn and x ∈ [n], σ(x) denotes the rank (position) of the element x in σ. We say that x is ranked higher than y (ranked lower than y) iff σ(x) < σ(y) (σ(x) > σ(y)). The inverse of a permutation σ is denoted by σ−1 : [n] → [n]. Clearly, σ−1(i) represents the element ranked at position i in σ. We define the projection of a permutation σ over a subset of elements Q ⊆ [n], denoted by σQ : Q → [|Q|], as an ordering of elements in Q such that x, y ∈ Q, σQ(x) > σQ(y) iff σ(x) > σ(y). As an example, the projection of σ = (2, 1, 4, 5, 3, 6) over Q = {1, 3, 5, 6} equals σQ = (1, 3, 2, 4), since σ(1) < σ(5) < σ(3) < σ(6). As can be seen, σQ(x) equals the rank of element x ∈ Q in σ.\nWe use a similar set of definitions for partial rankings [16]. A partial ranking σ is also defined as a mapping [n] → [n]. In contrast to permutations, where the mapping is a bijection, the mapping in partial ranking allows for ties, i.e., there may exist two elements x 6= y such that σ(x) = σ(y). A partial ranking is often represented using buckets, and is in this context referred to as a bucket order [16]. In a bucket order, the elements of the set [n] are partitioned into a number of subsets, or buckets, B1,B2, ...,Bt. We let σ(x) denote the index of the bucket containing the element x in σ, so the element x is assigned to bucket Bσ(x). Two elements x, y lie in the same bucket if and only if they are tied in σ. We may also define a projection of a partial ranking σ over a subset of elements Q ⊂ [n], denoted by σQ, so that for x, y ∈ Q, σQ(x) > σQ(y) iff σ(x) > σ(y) and σQ(x) = σQ(y) iff σ(x) = σ(y). For a given partial ranking σ, we use B1(σ),B2(σ), ...,Bt(σ) to denote its corresponding buckets. In addition, we define rk(σ) , ∑k j=1 |Bj(σ)| and lk(σ) , ∑k−1\nj=1 |Bj(σ)|+ 1. Based on the previous discussion, rσ(x)(σ)− lσ(x)(σ) + 1 = |Bσ(x)(σ)| (the number of elements that are in the bucket containing x). When referring to the bucket for a certain element x, we use Bσ(x), rσ(x), lσ(x) whenever no confusion arises. Note that if we arbitrarily break ties in σ to create a permutation σ′, then lσ(x) ≤ σ\n′(x) ≤ rσ(x); clearly, if σ is a permutation, we have lσ(i) = σ(i) = rσ(i).\nA number of distance functions between permutations are known from the social choice, learning and discrete mathematics literature [10]. One distance function of interest is based on transpositions: A\ntransposition (a, b) is a swap of elements at positions a and b, a 6= b. If |a − b| = 1, the transposition is referred to as an adjacent transposition. It is well known that transpositions (adjacent transpositions) generate Sn, i.e., any permutation π ∈ Sn can be converted into another permutation σ ∈ Sn through a sequence of transpositions (adjacent transpositions) [17]. The smallest number of adjacent transpositions needed to convert a permutation π into another permutation σ is known as the Kendall τ distance between π and σ, and is denoted by dτ (π, σ). Alternatively, the Kendall τ distance between two permutations π and σ over [n] equals the number of mutual inversions between the elements of the two permutations:\ndτ (σ, π) = |{(x, y) : π(x) > π(y), σ(x) < σ(y)}|. (1)\nAnother distance measure, that does not rely on transpositions, is the Spearman footrule, defined as\ndS(σ, π) = ∑\nx∈[n]\n|σ(x) − π(x)|.\nA well known result by Diaconis and Graham [10] asserts that dτ (π, σ) ≤ dS(π, σ) ≤ 2dτ (π, σ). One may also define an extension of the Kendall τ distance for the case of two partial rankings π and σ over the set [n], known as the Kemeny distance:\ndK(π, σ) =|{(x, y) : π(x) > σ(y), π(x) < σ(y)}|\n+ 1\n2 |{(x, y) : π(x) = π(y), σ(x) > σ(y),\nor π(x) > π(y), σ(x) = σ(y), }|. (2)\nThe Kemeny distance includes a component equal to the Kendal τ distance between the linear chains in the partial rankings, and another, scaled component that characterizes the distance of tied pairs of elements [16]. The Spearman footrule distance may also be defined to apply to partial rankings [16], and it equals the sum of the absolute differences between “positions” of elements in the partial rankings. Here, the position of an element x in a partial ranking σ is defined as\nposσ(x) ,\nσ(x)−1 ∑\nj=1\n|Bj(σ)| + |Bσ(x)(σ)|+ 1\n2 .\nThe above defined Spearman distance is a 2-approximation for the Kemeny distance between two partial rankings [16].\nA permutation σ = (σ(1), . . . , σ(n)) ∈ Sn may be uniquely represented via its Lehmer code (also called the inversion vector), i.e. a word of the form\ncσ ∈ Cn , {0} × [0, 1]× [0, 2]× · · · × [0, n− 1],\nwhere for i = 1, . . . , n,\ncσ(x) = |{y : y < x, σ(y) > σ(x)}|, (3)\nand for integers a ≤ b, [a, b] ≡ [a, a + 1, . . . , b]. By default, cσ(1) = 0, and is typically omitted. For instance, we have\ne 1 2 3 4 5 6 7 8 9 σ 2 1 4 5 7 3 6 9 8 cσ 0 1 0 0 0 3 1 0 1\nIt is well known that the Lehmer code is bijective, and that the encoding and decoding algorithms have linear complexity (n) [18, 19]. Codes with similar properties to the Lehmer codes have been extensively studied under the name of subdiagonal codes. An overview of such codes and their relationship to Mahonian statistics on permutations may be found in [20].\nWe propose next our generalization of Lehmer codes to partial rankings. Recall that the x-th entry in the Lehmer code of a permutation σ is the number of elements with index smaller than x that are ranked lower than x in σ (3). For a partial ranking, in addition to cσ, we use another code that takes into account ties according to:\nc ′ σ(x) = |{y ∈ [n] : y < x, σ(y) ≥ σ(x)}|. (4)\nClearly, c′σ(x) ≥ cσ(x) for all x ∈ [n]. It is straightforward to see that using cσ(x) and c ′ σ(x), one may recover the original partial ranking σ. In fact, we prove next that the linear-time Lehmer encoding and decoding algorithms may be used to encode and decode cσ and c ′ σ in linear time as well.\nGiven a partial ranking σ, we may break the ties in each bucket to arrive at a permutation σ′ as follows: For x, y ∈ S, if σ(x) = σ(y),\nσ′(x) < σ′(y) if and only if x < y. (5)\nWe observe that the entries of the Lehmer codes of σ and σ′ satisfy the following relationships for all i ∈ [n]:\nc ′ σ(x) = cσ′(x) + INx − 1, cσ(x) = cσ′(x),\nwhere INx = |{y ∈ [n] ∩ Bσ(x) : y ≤ x}|. An example illustrating these concepts is given below.\ne 1 2 3 4 5 6 7 8 9 σ 1 1 2 2 3 1 2 3 3 σ′ 1 2 4 5 7 3 6 8 9 cσ′ 0 0 0 0 0 3 1 0 0 IN 1 2 1 2 1 3 3 2 3 cσ 0 0 0 0 0 3 1 0 0 c ′ σ 0 1 0 1 0 5 3 1 2\nNote that INx, as well as cσ and c ′ σ may be computed in linear time. The encoding procedure is\noutlined in Algorithm 1.\nAlgorithm 1: Lehmer encoder for partial rankings Input: a partial ranking σ; 1: Set N to be the number of buckets in σ; 2: Initialize IN = (0, 0, ..., 0) ∈ Nn\nand BucketSize = (0, 0, ..., 0) ∈ NN ; 3: For x from 1 to n do 4: BucketSize(σ(x)) + +; 5: IN(x) ← BucketSize(σ(x)); 6: Break ties of σ to get σ′ according to (5); 7: cσ′ ← Lehmer code of σ\n′; Output: Output cσ = cσ′ , c ′ σ = cσ + IN− 1;"
    }, {
      "heading" : "3 Aggregation Algorithms",
      "text" : "Assume that we have to aggregate a set of m rankings, denoted by Σ = (σ1, σ2, . . . , σm), σk ∈ Sn, 1 ≤ k ≤ m. Aggregation may be performed via the distance-based Kemeny-Young model, in which one seeks a ranking σ that minimizes the cumulative Kendall τ (Kemeny) distance dτ (dK) from the set Σ, formally defined as:\nD(Σ, σ) =\nm ∑\ni=1\ndτ (σi, σ).\nNote that when the set Σ comprises permutations only, σ is required to be a permutation; if Σ comprises partial rankings, we allow the output to be either a permutation or a partial ranking.\nThe LCA procedure under the Kendall τ distance is described in Algorithm 2. Note that each step of the algorithm may be executed in parallel. If no parallelization is used, the first step requires O(mn) time, given that the Lehmer codes may be computed in O(n) time [18, 19]. If parallelization on Σ is used instead, the time reduces to O(m + n). Similarly, without parallelization the second step requires O(mn) time, while coordinate parallelization reduces this time to O(m). This third step requires O(n) computations. Hence, the overall complexity of the algorithm is either O(mn) or O(m + n), depending on parallelization being used or not.\nAlgorithm 2: The LCA Method (Permutations) Input: Σ = {σ1, σ2, ..., σm}, where σi ∈ Sn, i ∈ [n]. 1: Compute the Lehmer codewords cσj for all σj ∈ Σ. 2: Compute the median/mode of the coordinates:\nĉ(i) = median/mode ( cσ1(i), cσ2(i), . . . , cσm(i) ) .\n3: Compute σ̂, the inverse Lehmer code of ĉ. Output: Output σ̂.\nFor permutations, the aggregation procedure may be viewed as specialized voting: The ranking σk casts a vote to rank x at position x− cσk(x), for the case that only elements ≤ x are considered (A vote corresponds to some score confined to [0, 1]). However, when σk is a partial ranking involving ties, the vote should account for all possible placements between x−c′σ(x) and x−cσ(x). More precisely, suppose that the vote cast by σk to place element x in position y ∈ [x] is denoted by vk→x(y). Then, one should have\nvk→x(y) =\n{\n1, for the mode, 1\nc ′ σ(x)−cσ(x)+1\n, for the median, (6)\nif and only if y ∈ [x − c′σ(x), x − cσ(x)], and zero otherwise. Note that when the mode is used, the “positive votes” are all equal to one, while when the median is used, a vote counts only a fractional value dictated by the length of the “ranking interval”.\nNext, we use Vx(y) = ∑m\nk=1 vk→x(y) to denote the total voting score element x received to be ranked at position y. The inverse Lehmer code of the aggregator output σ̂ is computed as:\nmode: ĉ(x) = argy∈[x]maxVx(y)− 1, (7)\nmedian: ĉ(x) = min{k :\n∑k y=1 Vx(y)\nm ≥ 1/2} − 1.\nTo compute the values Vx(y) for all y ∈ [x], the LCA algorithm requires O(mx) time, which yields an overall aggregation complexity of O(mn2) when no parallelization is used. This complexity is reduced to O(m + n2) for the parallel implementation. Note that the evaluations of the V functions may be performed in a simple iterative manner provided that the votes vk→x(y) are positive constants, leading to a reduction in the overall complexity of this step to O(mn+n2) when no parallelization is used. Relevant details regarding the iterative procedure may be found in Appendix G.\nNote that the output σ̂ of Algorithm 2 is a permutation. To generate a partial ranking that minimizes the Kemeny distance while being consistent2 with σ̂, one can use a O(mn2+n3)-time algorithm outlined in Appendix G. Alternatively, the following simple greedy method always produces practically good partial rankings with O(mn) complexity: Scan the elements in the output permutation from highest (j = 1) to lowest rank (j = n − 1) and decide to put σ̂−1(j + 1) and σ̂−1(j) in the same bucket or not based on which of the two choices offers smaller Kemeny distance with respect to the subset {σ̂−1(1), ..., σ̂−1(j)}.\nDiscussion. In what follows, we briefly outline the similarities and differences between the LCA method and existing positional as well as InsertionSort based aggregation methods. Positional methods are a class of aggregation algorithms that seek to output a ranking in which the position of each element is “close” to the position of the element in Σ. One example of a positional method is Borda’s algorithm, which is known to produce a 5-approximation to the Kemeny-Young problem for permutations [21]. Another method is the Spearman footrule aggregation method which seeks to find a permutation that minimizes the sum of the Spearman footrule distance between the output and each ranking in Σ. As already mentioned, the latter method produces a 2-approximation for the Kendall τ aggregate for both permutations and partial ranking. LCA also falls under the category of positional methods, but the positions on which scoring is performed are highly specialized by the Lehmer code. And although it appears hard to prove worst-case performance guarantees for the method, statistical analysis on particular ranking models shows that it can recover the correct results with small sample complexity. It also offers significant reductions in computational time compared to the Spearman footrule method, which reduces to solving a weighted bipartite matching problem and hence has complexity at least O(mn2 + n3) [22], or O(mn) when implemented in MapReduce [23].\nA related type of aggregation is based on InsertionSort [8, 22]. In each iteration, an element is randomly chosen to be inserted into the sequence containing the already sorted elements. The position of\n2We say that two partial rankings σ, π are consistent if for any two elements x, y, σ(x) < σ(y) if and only if π(x) ≤ π(y) and vise versa.\nthe insertion is selected as follows. Assume that the elements are inserted according to the identity order e = (1, 2, . . . , n) so that at iteration t, element t is chosen to be inserted into some previously constructed ranking over [t− 1]. Let St−1 = [t− 1] and the symbol t is inserted into the ranking over St−1 to arrive at σSt , the ranking available after iteration t. If t is inserted between two adjacent elements σ −1 St−1 (i− 1) and σ−1St−1(i), then one should have σSt(x) = σSt−1(x) when σSt−1(x) ≤ i − 1, σSt(x) = σSt−1(x − 1) + 1 when σSt−1(x) ≥ i and σSt(t) = i. Let σSt(t) denote the rank assigned to element t over St, the choice of which may vary from method to method. The authors of [8] proposed setting σSt(t) to\nmax\n\n\n\ni ∈ [t− 1] : ∑\nk∈[m]\n1σk(t)<σk(σ−1St−1 (i)) <\nm\n2\n\n\n\n,\nor t when the above set is empty. This insertion rule does not ensure a constant approximation guarantee in the worst case (It has an expected worst-case performance guarantee of Ω(n)), although it leads to a Locally Kemeny optimal solution.\nWe next describe how the LCA method may be viewed as an InsertionSort method with a special choice of σSt(t). Consider the permutation LCA method of Algorithm 2, and focus on estimating the t-th coordinate of the Lehmer code ĉ(t) (step 2) and the inverse Lehmer code via insertion (step 3) simultaneously. Once ĉ(t) is generated, it’s corresponding inverse Lehmer transform may be viewed as the operation of placing the element t at position (t − ĉ(t)) over St. In other words, inverting the incomplete ranking reduces to setting σSt(t) = (t − ĉ(t)), where σSt(t) essentially equals the mode or median of the positions of t in the rankings of Σ, projected onto St. The same is true of partial rankings, with the only difference being that the selection of σSt(t) has to be changed because of ties between elements."
    }, {
      "heading" : "4 Analysis of the Mallows Model",
      "text" : "We provide next a theoretical performance analysis of the LCA algorithm under the assumption that the rankings are generated according to the Mallows and generalized Mallows Model. In the Mallows model MM(σ0, φ) with parameters σ0 and φ, σ0 denotes the centroid ranking and φ ∈ (0, 1] determines the variance of the ranking with respect to σ0. The probability of a permutation σ is proportional to φdτ (σ0,σ). For partial rankings, we assume that the samples are generated from a generalized Mallows Model (GMM) whose centroid is allowed to be a partial ranking and where the distance is the Kemeny dk, rather than the Kendall τ distance dτ .\nOur analysis is based on the premise that given a sufficiently large number of samples (permutations), one expects the ranking obtained by a good aggregation algorithm to be equal to the centroid σ0 with high probability. Alternative methods to analytically test the quality of an aggregation algorithm are to perform a worst-case analysis, which for the LCA method appears hard, or to perform a simulation-based analysis which produces a comparison of the objective function values for the Kemeny-Young problem given different aggregation methods. We report on the latter study in the section to follow.\nTo ease the notational burden, we henceforth use φs:t , ∑t k=s φ k in all subsequent results and derivations. Detailed proofs are relegated to the appendix. One of our main theoretical result is the following.\nTheorem 4.1. Assume that Σ = {σ1, σ2, ..., σm}, where σk i.i.d ∼ MM(σ0, φ), k ∈ [m], arem i.i.d. samples of the given Mallows model. If φ+ φ2 < 1 + φn and m ≥ c log n 2\n2δ with c = 2(1+q)2 (1−q)4 and q = φ1:n−1 1+φ3:n , then\nthe output ranking of Algorithm 2 under the mode rule equals σ0 with probability at least 1− δ.\nThe idea behind the proof is to view the LCA procedure as an InsertionSort method, in which the probability of the event that the selected position is incorrect with respect to σ0 is very small for sufficiently large m. Based on the lemma that follows (Lemma 4.2), one may show that if φ satisfies φ+φ2 < 1+φn, the most probable position of an element in a ranking σ ∼ MM(σ0, φ) corresponds to its rank in the centroid σ0. Given enough samples, one can estimate the rank of an element in the centroid by directly using the mode of the rank of the element in the drawn samples.\nLemma 4.2. Let σ ∼ MM(σ0, φ). Consider an element u. Then, the following two statements describe\nthe distribution of σ(u):\n1) P[σ(u) = j + 1]\nP[σ(u) = j] ∈ [φ, φ1:n−1 1 + φ3:n ] when σ0(u) ≤ j < n.\n2) P[σ(u) = j − 1]\nP[σ(u) = j] ∈ [φ, φ1:n−1 1 + φ3:n ] when 1 < j ≤ σ0(u).\nIn 1), the upper bound is achieved when σ0(u) = n− 1 and j = σ0(u), while the lower bound is achieved when σ0(u) = 1. In 2), the upper bound is achieved when σ0(u) = 2 and j = σ0(u), while the lower bound is achieved when σ0(u) = n.\nRemark 4.1. The result above may seem counterintuitive since it implies that for φ + φ2 > 1 + φn, the probability of ranking some element u at a position different from its position in σ0 is larger than the probability of raking it at position σ0(u). An easy-to-check example that shows that this indeed may be the case corresponds to σ0 = (1, 2, 3, 4) and φ = 0.9. Here, we have P[σ(3) = 3] = 0.2559 < P[σ(3) = 4] = 0.2617.\nLemma 4.2 does not guarantee that in any single iteration the position of the element will be correct, since the ranking involves only a subset of elements. Therefore, Lemma 4.3, a generalized version for the subset-projected ranking, is required for the proof.\nLemma 4.3. Let σ ∼ MM(σ0, φ) and let A ⊂ [n]. Consider an element u ∈ A. Then, the following two statements describe the distribution of σA(u):\n1) P[σA(u) = j + 1]\nP[σA(u) = j] ≤ max l∈[0,n−|A|] φ+ φlφ2:n−l−1 1 + φ2lφ3:n−l\nwhen |A| > j ≥ σ0,A(u).\n2) P[σA(u) = j − 1]\nP[σA(u) = j] ≤ max l∈[0,n−|A|] φ+ φlφ2:n−l−1 1 + φ2lφ3:n−l\nwhen 1 < j ≤ σ0,A(u).\nObserve that the conditions that allow one to achieve the upper bound in Lemma 4.2 also ensure that the upper bounds are achieved in Lemma 4.3. Moreover, when φ+ φ2 < 1 + φn, the right hand sides are ≤ φ1:n−11+φ3:n .\nThe next result establishes the performance guarantees for the LCA algorithm with the median operation.\nTheorem 4.4. Assume that Σ = {σ1, σ2, ..., σm}, where σk i.i.d ∼ MM(σ0, φ), k ∈ [m]. If φ < 0.5 and m ≥ c log 2nδ , where c = 2\n(1−2φ)2 , then the output of Algorithm 2 under the median operation equals σ0 with probability at least 1− δ.\nThe proof follows by observing that if the median of the Lehmer code cσk(t) over all k ∈ [m] converges to t − σ0,St(t) as m → ∞, then each σk should have P[σk,St(t) > σ0,St(t)],P[σk,St(t) < σ0,St(t)] < 1/2. According to the following Lemma, in this case, one needs φ < 0.5.\nLemma 4.5. Let σ ∼ MM(σ0, φ) and let A ⊆ [n]. For any u ∈ A, the following two bounds hold:\n1) P[σA(u) > σ0,A(u)] ≤ φ1:(|A|−σ0,A(u))\nφ0:(|A|−σ0,A(u)) < φ,\n2) P[σA(u) < σ0,A(u)] ≤ φ1:σ0,A(u)\nφ0:σ0,A(u) < φ.\nThe inequality 1) is met for A = S and σ0(u) = 1, while the inequality 2) is met for A = S and σ0(u) = n.\nWe now turn our attention to partial rankings and prove the following extension of the previous result for the GMM, under the LCA algorithm that uses the median of coordinate values. Note that the output of Algorithm 2 is essentially a permutation, although it may be transformed into a partial ranking via the bucketing method described in Section 2.\nTheorem 4.6. Assume that Σ = {σ1, σ2, ..., σm}, where σk i.i.d ∼ GMM(σ0, φ), k ∈ [m]. If φ + φ 1/2 < 1 and m ≥ c log 2nδ with c = 2 (1−2q′)2 , where q ′ = 1 − 12φ 1/2 − 12φ, then the output ranking of the LCA algorithm (see Appendix E) under the median operation is in Σ0 with probability at least 1 − δ. Here, Σ0 denotes the set of permutations generated by breaking ties in σ0.\nThe proof of this theorem relies on showing that the InsertionSort procedure places elements in their correct position with high probability. If the median is used for partial ranking aggregation, one vote is uniformly distributed amongst all possible positions in the range given by (6). To ensure that the output permutation is in Σ0, we need to guarantee that the median of the positions of the votes for t over St is in [lσ0,St(t), rσ0,St(t)] for large enough m (as in this case, [lσ0,St(t), rσ0,St(t)] represents the bucket in σ0 that contains t).\nFor a σ ∼ GMM(σ0, φ), let v(j) be the vote that the partial ranking σ cast for position j. Then, one requires that\nE[\nrσ0,A(u) ∑\nk=1\nv(j)] > 0.5 and E[\nn ∑\nk=lσ0,A(u)\nv(j)] > 0.5.\nThe expectations in the expressions above may be evaluated as follows (We only consider the expectation on the left because of symmetry). If the eventW = {rσSt (t) ≤ rσ0,St (t)} occurs, then the vote of σ that contributes to the sum equals 1. If the event Q = ∪ n−rσ0,St (t)\nj=1 Qj , where Qj = {rσSt (t) = j+rσ0,St (t), lσSt(t) ≤\nrσ0,St (t)} occurs, then the vote that σ contributes to the sum equals Vj = rσ0,St (t) −lσSt (t) +1\nrσSt (t) −lσSt (t)\n+1 . Therefore,\nwe have\nE[\nrσ0,St (t) ∑\nk=1\nv(k)] = P[W ] +\nn−rσ0(u) ∑\nj=1\nVjP[Qj ]. (8)\nThe following lemma describes a lower bound for (8).\nLemma 4.7. Let σ ∼ GMM(σ0, φ) and let A ⊆ [n] be such that it contains a predefined element u. Let A′ = A− {x ∈ A : x 6= u, σ0,A(x) ≤ σ0,A(u)}. Define\nW = {rσA(u) ≤ rσ0,A(u)},\nQj = {rσA(u) = j + rσ0,A(u), lσA(u) ≤ rσ0,A(u)}, W ′ = {rσA′ (u) ≤ rσ0,A′ (u)}, Q′j = {rσA′ (u) = j + rσ0,A′ (u), lσ′A(u) ≤ rσ0,A′ (u)}.\nThen, one can prove that\nP[W ] + ∑|A|−rσ0,A (u)\nj=1 VjP[Qj ]\n≥ P[W ′] + ∑|A′|−rσ 0,A′ (u)\nj=1 1 j+1VjP[Q ′ j]\n≥ 1− 12φ 1/2 − 12φ.\nIf φ+φ1/2 < 1, the lower bound above exceeds 1/2. Theorem 4.6 then follows using the union bound and Hoeffding’s inequality."
    }, {
      "heading" : "5 Performance Evaluation",
      "text" : "We next evaluate the performance of the LCA algorithms via experimental methods and compare it to that of other rank aggregation methods using both synthetic and real datasets. For comparative analysis, we choose the Fas-Pivot and FasLP-Pivot (LP) methods [9], InsertionSort with Comparison (InsertionComp) from [8], and the optimal Spearman Footrule distance aggregator (Spearman) [10]. For the randomized algorithms Fas-Pivot and FasLP-Pivot, the pivot in each iteration is chosen randomly. For InsertionSort with Comparison, the insertion order of the elements is also chosen randomly. Furthermore, for all three methods, the procedure is executed five times, and the best solution is selected. For Fas-Pivot and FasLP-Pivot, we chose the better result of Pick-A-Perm and the given method, as suggested in [9].\nIn the context of synthetic data, we only present results for the Mallows model in which the number of ranked items equals n = 10, and the number of rankings equals m = 50. The variance parameter was chosen according to φ = e−λ, where λ is allowed to vary in [0, 1]. For each parameter setting, we ran 50 independent simulations and computed the average cumulative Kendall τ distance (normalized by m) between the output ranking and Σ, given as Dav = D(σ,Σ)\nm . We then normalized the Dav value of each algorithm by that of FasLP-Pivot, since FasLP-Pivot always offered the best performance. The results\nare depicted in Fig. 1. Note that we used MostProb to describe the most probable ranking, which is the centroid for the Mallows Model.\nNote that for parameter values λ ≥ 0.6 LCA algorithms perform almost identically to the best aggregation method, the LP-based pivoting scheme. For smaller values of λ, small performance differences may be observed; these are compensated by the significantly smaller complexity of the LCA methods which in the parallel implementation mode is only linear in n and m. Note that the InsertionSort Comp method performs poorly, although it ensures local Kemeny optimality.\nWe also conducted experiments on a number of real-world datasets. To test the permutation LCA aggregation algorithms, we used the Sushi ranking dataset [24] and the Jester dataset [25]. The Sushi dataset consists of 5000 permutations involving n = 10 types of sushi. The Jester dataset contains scores in the continuous interval [−10, 10] for n = 100 jokes submitted by 48483 individuals. We chose the scores of 14116 individuals who rated all 100 jokes and transformed the rating into permutations by sorting the scores. For each dataset, we tested our algorithms by randomly choosing m many samples out of the complete list and by computing the average cumulative Kendall τ distance normalized by m via 50 independent tests. The results are listed in the Table 1 and Table 2.\nTo test our partial ranking aggregation algorithms, we used the complete Jester dataset [25] and the Movielens dataset [26]. For the Jester dataset, we first rounded the scores to the nearest integer and\nthen placed the jokes with the same integer score in the same bucket of the resulting partial ranking. We also assumed that the unrated jokes were placed in a bucket ranked lower than any other bucket of the rated jokes. The movielens dataset contains incomplete lists of scores for more than 1682 movies rated by 943 users. The scores are integers in [5], so that many ties are present. We chose the 50 most rated movies and 500 users who rated these movies with largest coverage. Similarly as for the Jester dataset, we assumed that the unrated movies were tied for the last position. In each test, we used the iterative method described in Section 3 to transform permutations into partial rankings. Note that when computing the Kemeny distance between two partial rankings of (2), we omitted the penalty incurred by ties between unrated elements, because otherwise the iterative method would yield too many ties in the output partial ranking. More precisely, we used the following formula to assess the distance between two incomplete partial rankings (9):\ndτ (π, σ) = |{(x, y) : π(x) > σ(y), π(x) < σ(y)}|\n+ 1\n2 |{(x, y) : [π(x) = π(y), σ(x) > σ(y), x, y rated byπ]\nor [π(x) > π(y), σ(x) = σ(y), x, y rated byσ]}|. (9)\nThe results are listed in Table 3 and Table 4. As may be seen, the parallelizable, low-complexity LCA methods tend to offer very similar performance to that of the significantly more computationally demanding LP pivoting algorithm."
    }, {
      "heading" : "A Proof of Lemma 4.2",
      "text" : "Before proceeding with the proof, we remark that some ideas in our derivatione have been motivated by Lemma 10.7 of [27].\nLet i , σ0(u). Suppose that n > j ≥ i and that we want to prove statement 1) (the second case when 0 < j ≤ i may be handled similarly). When i = 1, the underlying ratio is exactly equal to φ. Hence, we only consider the case when i > 1. Let E = {σ : σ(u) = j} and T = {σ : σ(u) = j + 1}. In this case, P[σ(u) = j] = P[E] and P[σ(u) = j + 1] = P[T ]. Define the sets:\nE1 = {σ : σ(u) = j, σ0(σ −1(j + 1)) > i}, E2 = {σ : σ(u) = j, σ0(σ −1(j + 1)) < i}, T1 = {σ : σ(u) = j + 1, σ0(σ −1(j)) > i}, T2 = {σ : σ(u) = j + 1, σ0(σ −1(j)) < i}.\nClearly, P[E] = P[E1] +P[E2] and P[T ] = P[T1] +P[T2]. By swapping u and σ −1(j+1), we can construct two bijections E1 ↔ T1 and E2 ↔ T2. Statement 1) can then be easily proved by using the following three claims:\nP[T1] = φP[E1], P[T2] = 1\nφ P[S2],\n0 < P[T2] a) ≤ φ1:n−1P[T1]. (10)\nObserve that inequality is achieved in a) when j = n − 1. The first two claims are straightforward to check, and hence we only prove the third claim.\nConsider a mapping from T2 to T1 based on circular swapping of elements, and let σ ∈ T2. Since σ(u)−1 = j ≥ i and σ0(σ\n−1(j)) < i, there must exist an element x such that σ0(x) > σ0(u) and σ(x) < j. Choose the element x with the largest corresponding value of σ(x) and construct a new ranking σ′ such that\nσ′(y) =\n\n\n σ(y), if σ(y) < σ(x) or σ(y) ≥ σ(u), σ(y)− 1, if σ(x) < σ(y) ≤ σ(u), j, if σ(y) = σ(x).\nIt is easy to see that σ′ ∈ T1. Given that all elements ranked between x and u in σ have rank higher than σ0(x), we have P[σ] = φ\nσ(u)−σ(x)−1P[σ′] = φj−σ(x)P[σ′]. Note that the above mapping is neither a bijection nor an injection. Denote the mapping by M : Tj,2 → T2. For each σ\n′ ∈ T1, define T2,σ′ ⊂ T2, so that for all σ ∈ T2,σ′ , M(σ) = σ\n′. Then, ∪σ′∈T1T2,σ′ = T2 forms a partition of the set T2. Next, consider two distinct rankings σ1, σ2 ∈ T2,σ′ . These rankings must rank the element x differently, i.e., one must have σ1(x) 6= σ2(x). Therefore, P[T2,π′ ] ≤ P[π ′]φ1:j−1 = P[π ′]φ1:j−1. As a result, P[T2] ≤ P[T1]φ1:n−1, which proves the third claim. We conclude by observing that the condition under which equality is achieved in the bound stated in the lemma is exactly the same condition under which equality is achieved in the bound stated in the third claim."
    }, {
      "heading" : "B Proof of Lemma 4.3",
      "text" : "Let i , σ0,A(u). Suppose that n > j ≥ i and that we want to prove statement 1) (the case when 0 < j ≤ i may be handled similarly). Let E = {π : πA(u) = j} and T = {π : πA(u) = j + 1}. The left-hand-side in the statement of 1) equals the ratio P[T ] P[E] . Note that removing a fixed number of elements in S of lowest (or highest) rank in the centroid ranking does not change the probability of the ranking involving the remaining elements (see Lemma F.1 for the proof). We can hence assume that σ−10,A(1) is the element with highest rank in σ0.\nWhen i = 1, for any ranking σ in T , we can swap the element u with the element x ∈ A for which σA(x) = σA(u) − 1 to obtain another ranking σ\n′ ∈ E. Moreover, it is easy to check that P[σ′]φ ≥ P[σ], so that the ratio in the statement 1) does not exceed φ. Note that we have inequality “ ≥′′ instead of equality “ =′′ in P[σ′]φ ≥ P[σ], since there may potentially exists other elements in S/A ranked between x and u in σ.\nNext, consider the case when i > 1. Define the sets\nE1 = {σ : σA(u) = j, σ0,A(σ −1 A (j + 1)) > i}, E2 = {σ : σA(u) = j, σ0,A(σ −1 A (j + 1)) < i}, T1 = {σ : σA(u) = j + 1, σ0,A(σ −1 A (j + 1)) > i}, T2 = {σ : σA(u) = j + 1, σ0,A(σ −1 A (j + 1)) < i}.\nThen, P[E] = P[E1] + P[E2] and P[T ] = P[T1] + P[T2]. By swapping u and σ −1 A (j + 1), we can construct two bijections E1 ↔ T1 and E2 ↔ T2 as follows. Let us consider a finer partition of T2 in terms of permutations with four labels. More precisely, associate each ranking σ ∈ T2 with a label vector (x1, x2, ℓ1, ℓ2), where:\nx1 = π −1(j). Note that σ0,A(x1) < i due to the definition of T2.\nx2 = argmaxx:σ0,A(x)>i,σA(x)<σA(u) σA(x); the label x2 is well-defined due to the pigeon-hole principle.\nℓ1 = the cardinality of the set F1 defined as\nF1 = {x ∈ [n] : σ0(x1) < σ0(x) < σ0(u), σ(σ −1 A (j − 1)) < σ(x) < σ(x1)}.\nℓ2 = the cardinality of the set F2 defined as\nF2 = {x ∈ [n] : σ0(x1) < σ0(x) < σ0(u), σ(x1) < σ(x) < σ(u)}.\nWe summarize those labels in a vector L = (x1, x2, ℓ1, ℓ2) and thus partition T2 according to different label vectors L, i.e.,\nT2 = ∪LT2,L. (11)\nA ranking in T2 is in T2,L if its corresponding label vector equals L. We further construct a mapping M from T2 to T1 by swapping elements ranked between x1 and x2, so that σ′ = M(σ) equals\nσ′A(x) =\n\n  \n   j, σA(x) = σA(x2), σA(x)− 1, σA(x2) < σA(x) < j, σA(x)− 1, σA(x) = σA(x1), σA(x), for other x ∈ A.\nThe above mapping basically performs circular swapping by moving x2 to the position one rank higher and adjacent to u and by moving each element in A between x2 and x1, including x1, to a higher position adjacent to the original one. Based on M, one can also form a partition of T1 as\nT1 = (∪LT1,L) ∪ T1,Lc (12)\nwhere T1,L contains the rankings mapped from T2,L via M. Note that T1,Lc denote the “remainder set” of permutations that do not have a preimage in T2. In this remainder set, a ranking σ has the property that the elements σ−1A (j) and σ −1 A (j− 1) are both ranked lower than u in the centroid ranking. Since the swapping operations establish a bijection between E1 ↔ T1 and E2 ↔ T2, one can also partition E1, E2 as\nE1 = (∪LE1,L) ∪ E1,Lc , (13)\nE2 = ∪LE2,L. (14)\nLet R(L) denote P[∪L∈L(T1,L∪T2,L)] P[∪L∈L(E1,L∪E2,L)] and let R(L) denote the same type of ratio but for a specific choice\nof L, i.e., P[T1,L∪T2,L] P[E1,L∪E2,L] . Also, let L0 denote the set of all possible values of L. To prove the upper bound on P[T ] P[E] , we proceed through four steps.\n1. Partition T and E and verify the validity of (11), (12), (13) and (14).\n2. Prove that P[T1,Lc ] P[E1,Lc ] ≤ φ.\n3. Prove the upper bound for R(L) when ℓ1 = ℓ2.\n4. Prove the upper bound for R(L ∪ L′), where L = (k1, k2, ℓ1, ℓ2) and L ′ = (k1, k2, ℓ2, ℓ1), for the\ncase that ℓ1 6= ℓ2.\nThe second step is easy to prove by directly swapping σ−1A (j) and u in any given ranking σ ∈ T1,Lc . We hence only need to establish the validity of the results in Steps 3 and 4.\nFor any L = (k1, k2, ℓ1, ℓ2), the following claims hold:\nP[E1,L] ≥ φ −1 P[T1,L], P[E2,L] = φ 1+2ℓ2P[T2,L],\nP[T2,L] ≤ φ 2ℓ1fLP[T1,L], where fL ≤ φ1:|A|−2−ℓ1−ℓ2 , (15)\nwhere the first two claims are easy to prove, while the equation (15) may be verified similarly as (10) in the proof of Lemma 5.2 (See Appendix A).\nFor any σ ∈ T2,L, σ ′ = M(σ) ∈ T1,L. Given that all the elements in A ranked between x2 and u in σ\nare ranked lower than u, x2 in the centroid, and due to swapping, we have\nP[σ] P[σ′] ≤ φσA(u)−σA(x2)−1+2ℓ1 = φj−σA(x2)+2ℓ1 .\nConsider two distinct rankings σ1, σ2 ∈ T2,L. If M(σ1) = M(σ2), both rankings rank the element x2 differently over A, i.e., σ1,A(x2) 6= σ2,A(x2). Therefore, we must have\n∑\nσ:M(σ)=σ′\nP[σ] P[σ′] ≤ φ2(ℓ1+ℓ2)φ1:|A|−2−ℓ1−ℓ2 .\nBy examining all mappings from P[T2,L] to P[T1,L], we conclude that fL(φ) = φ −2(ℓ1+ℓ2) P[T2,L]\nP[T1,L] ≤\nφ1:|A|−2−s, which establishes the third claim in (15). Substituting the above expressions into R(L), we have\nR(L) ≤ 1 + φ2ℓ1φ1:|A|−2−ℓ1−ℓ2\nφ−1 + φ1+2(ℓ1+ℓ2)φ1:|A|−2−ℓ1−ℓ2 . (16)\nSuppose next that ℓ1 = ℓ3 = ℓ. Then,\nR(L) ≤ 1 + φ2ℓφ1:|A|−2−2ℓ\nφ−1 + φ1+4ℓφ1:|A|−2−2ℓ . (17)\nwhich completes the proof of the bound in Step 3. Let us now consider the bound in Step 4. When ℓ1 6= ℓ2, direct optimization over ℓ1, ℓ2 cannot yield the required upper bound as ℓ2 → ∞ may increase the right-hand-side of (18). Hence, in addition to L = (k1, k2, ℓ1, ℓ2), let us also simultaneously consider L\n′ = (k1 , k2 , ℓ2, ℓ1), as a larger ℓ2 will yield a smaller R(L′), .\nWithout loss of generality, suppose that ℓ2 > ℓ1. First, we prove the following Lemma.\nLemma B.1. For a pair (L, L′) defined as above with ℓ2 > ℓ1, one has\nP[T1,L] P[T1,L′ ] ≤ φ(ℓ2−ℓ1).\nProof. Recall the definition of the set F2 and the fact that for a ranking σ ∈ T1,L, σ is obtained via M(π) for some π ∈ T2,L. Hence, in σ, the elements in F1 are now ranked higher than x2 and lower than x1, while the elements in F2 are now ranked higher than u and lower than x2. Based on this structure of σ, for each ranking σ ∈ T1,L, one may perform a swapping operation to obtain another ranking σ\n′ in T1,L′. The swapping constitutes a bijection. To see this, consider the set of ℓ2 − ℓ1 elements with highest rank in σF2 (Note that we assumed ℓ2 > ℓ1 but could have otherwise considered the ℓ1 − ℓ2 elements with lowest rank in σF1 .). Swapping the element x2 and the selected elements in F2 ranked from high to low yields a ranking σ′ ∈ T1,L′. Since for any element x ∈ F2, σ0(x) < σ0(u) < σ0(x2), we have P([σ]) ≤ P([σ′])φℓ2−ℓ1 . This completes the proof.\nLet P , P[T1,L] P[T1,L′ ] . Substituting the results of all claims (15) into R(L ∪ L′), we obtain\nR(L ∪ L′) = P[T1,L ∪ T2,L] + P[T1,L′ ∪ T2,L′ ]\nP[E1,L ∪ E2,L] + P[E1,L′ ∪ E2,L′ ] (18)\n≤ P (1 + φ2ℓ1φ1:|A|−2−ℓ1−ℓ2) + (1 + φ 2ℓ2φ1:|A|−2−ℓ1−ℓ2)\n(P + 1)(φ−1 + φ1+2(ℓ1+ℓ2)φ1:|A|−2−ℓ1−ℓ2) (19)\nb) ≤ 1 + φℓ1+ℓ2φ1:|A|−2−ℓ1−ℓ2\n(φ−1 + φ2(ℓ1+ℓ2)φ2:|A|−1−ℓ1−ℓ2) . (20)\nHere, the inequality b) follows from Lemma B.1. By using |A| ≤ n and letting ℓ = ℓ1 + ℓ2, we obtain\nR(L ∪ L′) ≤ 1 + φℓφ1:n−ℓ−2\nφ−1 + φ2ℓφ2:n−ℓ−1 ,\nwhich completes the proof of the result in Step 4.\nLemma B.2. If φ+ φ2 < 1 + φn, for all ℓ ∈ N, one has\n1 + φℓφ1:n−ℓ−2 φ−1 + φ2ℓφ2:n−ℓ−1 ≤ φ1:n−1 1 + φ3:n .\nProof. First, for ℓ ≥ 1,\nφℓ+1\nφ2ℓ+1:2ℓ+2 − φn+ℓ ≥\n1\nφ+ φ2 − φn−1 > 1.\nThus,\nφ2:ℓ+1 φ3:2ℓ+2 − φn+1:n+ℓ =\n∑ℓ t=1 φ t+1\n∑ℓ t=1 φ2t+1:2t+2 − ∑ℓ t=1 φ\nn+t > 1.\nSince we also have φ1:n−11+φ3:n < 1, it follows that\nφ1:n−1 1 + φ3:n > φ1:n−1 − φ2:ℓ+1 1 + φ3:n − (φ3:2ℓ+2 − φn+1:n+ℓ) = φ+ φℓφ2:n−ℓ−1 1 + φ2ℓφ3:n−ℓ .\nThis proves the claimed result and completes the proof of the lemma."
    }, {
      "heading" : "C Proof of Lemma 4.5",
      "text" : "Lemma 4.5 is a corollary of the following lemma.\nLemma C.1. Let σ ∼ MM(σ0, φ). If two subsets of elements A, A ′ satisfy A′ = A ∪ {x}, where x /∈ A, and if u ∈ A, then for all t ∈ [|A|] one has\n1) P[σA(u) ≥ t] ≤ P[σA′(u) ≥ t].\n2) P[σA(u) ≤ t] ≤ P[σA′(u) ≤ t+ 1].\nProof. Because of symmetry, it suffices to prove the first claim only. The left-hand-side of the first inequality equals the probability of the event that the element u is ranked in the t-th position or lower within the set of elements in A. The right-hand-side of the inequality equals the probability of the event that the element u is ranked in the t-th position or lower within the set of elements in A′. Since A′ is the union of A and another element x /∈ A, inserting x into a ranking may only increase the rank of already present elements.\nNow, consider Lemma 4.5 in the main text. Choose an element x ∈ S if there is such and element that satisfies σ0(x) > σ(u). Let A\n′ = A ∪ {x}. Then, the statement of the above result implies that the probability that element u is ranked lower than or equal to its correct rank σ0,A(u) will increase if we add an element x to A that is ranked lower than u in σ0. Therefore, by removing all elements from A that are ranked lower than u in σ0, we obtain a new subset A\n′′ and consequently have P[σA(u) ≥ σ0,A(u)] ≥ P[σA′′(u) ≥ σ0,A′′ (u)]. Note that u is the element with the lowest rank in σ0,A′′ . Therefore, it is easy to check that P[σA′′(u) = σ0,A′′(u)] ≥\n1 φ0:|A′′|−1 . Then, one has the inequality P[σA(u) ≥ σ0,A(u)] ≥ 1 φ0:|A′′|−1 ."
    }, {
      "heading" : "D Proof of Lemma 4.7",
      "text" : "For convenience, we restate Lemma 4.7 first.\nLemma D.1. Let σ ∼ GMM(σ0, φ) and let A be a subset of elements containing an element u. Let A′ = A − {x ∈ A : x 6= u, σ0,A(x) ≤ σ0,A(u)}. Define W = {rσA(u) ≤ rσ0,A(u)}, Qj = {rσA(u) = j + rσ0,A(u), lσA(u) ≤ rσ0,A(u)}, W ′ = {rσA′ (u) ≤ rσ0,A′ (u)} and Q ′ j = {rσA′ (u) = j + rσ0,A′ (u), lσ′A(u) ≤ rσ0,A′ (u)}. Then, the following two claims hold.\nP[W ]+\n|A|−rσ0,A (u) ∑\nj=1\nVjP[Qj ]\n≥P[W ′] +\n|A′|−rσ 0,A′\n(u) ∑\nj=1\n1\nj + 1 VjP[Q\n′ j] (21)\n≥1− 1\n2 φ1/2 −\n1 2 φ. (22)\nProof. The idea behind the proof is similar to that of the proof of Lemma C.1. Our first goal is to show that removing the element x from A that is ranked highest in σ0,A decreases the left-hand-side of (21). Then, by induction, we may prove (21).\nFor simplicity, let A′′ = A−{x}. Note that because of the choice of the rank of the element x in σ0,A, we have rσ0,A′′ (u) = rσ0,A(u) − 1 and lσ0,A′′ (u) = lσ0,A(u) − 1. For a ranking σ ∈ {σ : lσA(u) ≤ rσ0,A(u)}, the removal of x produces another ranking σ′′. When rσA(x) < rσA(u), σ and σ ′′ will contribute the same “vote” to the left-hand-side of (21). When rσA(x) = rσA(u), σ ′′ contributes the same vote when σ ∈ W , or smaller vote when σ ∈ Qj for some j. When rσA(x) > rσA(u), σ ′′ will always contribute a smaller vote. For a ranking σ /∈ {σ : lσA(u) ≤ rσ0,A(u)}, both σ and σ ′′ contribute a zero vote. Therefore, removing x from A strictly decreases the left-hand-side of (21). We now prove inequality (22). Note that due to the definition of A′, we have rσ0,A′ (y) = 1. Also, due to Lemma F.1 of this document, we can further assume that rσ0(y) = 1, i.e., that y is the only element in the first bucket of σ0. Because of its definition, W\n′ includes the rankings σ such that y is the only element in the first bucket of σ′A while Q ′ j includes the rankings σ such that there are, in addition to y, some j other elements in the first bucket of σ′A. Partition W ′ according to the size of the second bucket of σ′A, i.e., let W ′ = ∪|B2(σ′A)|=jW ′ j . Then, we can construct a bijection from W ′j to Q ′ j by putting y into the second bucket. It is easy to check that\nP[Q′j] ≤ P[W ′ j ]φ j/2.\nDenote the set of partial rankings σ for which the first bucket of σA does not contain y but some j other elements in U ′j . We can also construct a mapping from Q ′ j to U ′ j by moving y from the first bucket to any other possible position higher than the first bucket. Hence, we have\nP[U ′j] ≤ P[Q ′ j ]φ j/2(1 + φ1/2 + φ+ · · · ) ≤ P[Q′j ] φj/2\n1− φ1/2 .\nLet Z ′j = W ′ j ∪Q ′ j ∪ U ′ j , so that ∪jZ ′ j covers all possible partial rankings. Hence,\nP(W ′j) + 1 j+1P(Q ′ j)\nP(Z ′j) =\nP(W ′j) + 1 j+1P(Q ′ j)\nP(W ′j) + P(Q ′ j) + P(U ′ j)\n≥ 1 + 1j+1φ j/2\n1 + φj/2 + φ j\n1−φ1/2\n≥ 1 + 12φ 1/2\n1 + φ1/2 + φ 1−φ1/2\n= 1− 1\n2 φ1/2 −\n1 2 φ,\nwhere the second inequality follows from φ1/2 + φ < 1. This completes the proof."
    }, {
      "heading" : "E Proof of the Main Results",
      "text" : ""
    }, {
      "heading" : "E.1 Proof for permutation aggregation",
      "text" : "Let the Lehmer code of the output permutation σ be denoted by ĉσ. We say that the LCA algorithm succeeds if σ = σ0, or equivalently, if ĉσ = cσ0 . Given that ĉσ(1) = 0 = cσ0(1), by using the union\nbound, we arrive at\nP[σ = σ0] = P[ĉσ = cσ0 ] ≥ 1−\nn−1 ∑\nt=2\nP[ĉσ(t) 6= cσ0(t)].\nIn Section 4, we explained that the algorithm based on the Lehmer code ĉσ may be viewed as a form of InsertionSort, in which during the t-th iteration one places the element t at the (t − ĉσ(t))-th position over the subset of elements St = [t]. With this specific choice of subset St, for any permutation π, we have πSt(t) = t− cπ(t). Hence, the event {ĉσ(t) 6= cσ0(t)} is equivalent to the event {σSt(t) 6= σ0,St(t)}, which we denote by Dt. For convenience, we let i , σ0,St(t). Given that the ranking σk ∈ Σ is sampled from a MM(σ0, φ) distribution, we also define a random variable Xk(j) = 1{σk,St (t)=j} to indicate whether the element t is ranked at the j-th position in σk,St . Therefore, ∑\nk∈[m] Xk(j) equals the number of rankings in Σ in which element t is ranked at the j-th position."
    }, {
      "heading" : "E.1.1 Proof of Theorem 4.1 (Mode)",
      "text" : "Given that we aggregate using the mode function, we have σSt(t) = argmaxj∈[t] ∑ k∈[m] Xk(j). In what follows, we aim to prove an upper bound on P[σSt(t) 6= σ0,St(t)] = P[D(t)].\nTo this end, let q = φ1:n−11+φ3:n , so that when φ + φ 2 < 1 + φn, we have q < 1. Based on Lemma 4.3 in\nthe main text, we have\nP[Xk(i) = 1] = P[Xk(i) = 1]\n∑t j=1 P[Xk(j) = 1]\n= P[σk,St(t) = i]\n∑t j=1 P[σk,St(t) = j]\n≥ 1\n1 + 2q/(1− q) =\n1− q 1 + q .\nMoreover, if E = E[Xk(i)−Xk(j)], then\nE ≥ P[Xk(i) = 1](1 − q |i−j|) ≥\n(1 − q)2\n1 + q .\nTherefore, since the σk, k ∈ [m], are i.i.d, Hoeffding’s inequality establishes\nP[ ∑\nk∈[m]\nXk(i) < ∑\nk∈[m]\nXk(j)] = P[ ∑\nk∈[m]\n(Xk(i)−Xk(j)) ≤ 0] ≤ exp(− mE2\n2 ) ≤ exp(−\nm(1− q)4 2(1 + q)2 ).\nHence,\nP[Dt] ≤ ∑\nj∈[t],j 6=i\nP\n\n\n∑\nk∈[m]\nXk(i) < ∑\nk∈[m]\nXk(j)\n  < (t− 1) exp(− m(1− q)4\n2(1 + q)2 ).\nAs a result, for m ≥ c log n 2 2δ with c = 2(1+q)2 (1−q)4 and q = φ1:n−1 1+φ3:n , we have P[σ = σ0] > 1− δ."
    }, {
      "heading" : "E.1.2 Proof of Theorem 4.3 (Median)",
      "text" : "Let Yk(j0) = ∑j0 j=1 Xk(j). Since we use the median to form the aggregate, we need to establish that σSt(t) = min{j : 1 m ∑ k∈[m] Yk(j) ≥ 0.5}. According to Lemma 4.5 of the main text, we have P[Yk(i) = 1] = 1 − P[σk,A(x) > i] ≥ 1 − φ while P[Yk(i− 1) = 1] = P[σk,A(x) < i] ≤ φ. Therefore, if φ < 0.5, using Hoeffding’s inequality, we have\nP[Dt] ≤ P\n\n\n1\nm\n∑\nk∈[m]\nYk(i) < 0.5\n\n + P\n\n\n1\nm\n∑\nk∈[m]\nYk(i − 1) > 0.5\n\n ≤ 2e−2m( 1 2−φ) 2 .\nAs a result, for m ≥ c log 2nδ with c = 2 (1−2φ)2 , we have P[σ = σ0] > 1− 2ne −2m(12−φ) 2 ≥ 1− δ."
    }, {
      "heading" : "E.2 Proof of the Performance Guarantees for Partial Ranking Aggregation",
      "text" : "Denote the Lehmer code of the output permutation σ of Algorithm 2 of the main text by ĉσ. We say that the LCA algorithm succeeds if σ is in Σ0, which is equivalent to saying that ĉσ(t) ∈ [cσ(t), c ′ σ(t)]. Given that ĉσ(1) = 0 = cσ0(1) = c ′ σ(1), from the union bound, we have\nP[σ ∈ Σ0] = P[ĉσ(t) ∈ [cσ(t), c ′ σ(t)], ∀t] ≥ 1−\nn−1 ∑\nt=2\nP[ĉσ(t) 6∈ [cσ(t), c ′ σ(t)]].\nIn Section 4 of the main text, we explained how the Lehmer code transform ĉσ may be viewed as a form of InsertionSort, which in the t-th iteration places the element t at the (t− ĉσ(t))th position within the subset of elements St = [t]. With this choice of subset St, for any π, we have that πSt(t) = t − cπ(t). Hence, the event {ĉσ(t) 6∈ [cσ(t), c\n′ σ(t)]} is equivalent to the event {σSt(t) < lσ0,St (t) or σSt(t) > rσ0,St (t)},\nwhich we denote by Dt. The proof reduces to finding a lower bound on P[Dt]. For convenience, we let l , lσ0,St (t) and r , rσ0,St (t). Given that the ranking σk ∈ Σ is sampled from a GMM(σ0, φ), we define the random variable Xk(j) as the vote that σk cast for t to be at position j in St. Then, V (j) = ∑\nk∈[m] Xk(j) is the total vote cast by all partial rankings in Σ to rank t at the j-th position."
    }, {
      "heading" : "E.2.1 Proof of Theorem 4.6 (Median)",
      "text" : "Let Yk(j0) = ∑j0\nj=1 Xk(j). Since we use the median to form the aggregate, we have σSt(t) = min{j : 1 m ∑ k∈[m] Yk(j) ≥ 0.5}. Define the event W = {rσk,St (t) ≤ r}. When W occurs, σk contributes 1 to Yk(r). Let Q = ∪ n−r j=1Qj, where Qj = {rσk,St (t) = j + r, lσk,St(u) ≤ r}. When Qj occurs, σk contributes a fractional vote Vj to Yk(r), where Vj = r−lσk,St (t) +1\nrσk,St (t) −lσk,St (t)\n+1 ≥ V ′ j = 1 j+1 . In fact, Vj = V ′ j when\nlσk,St(t) = r. Therefore, based on the Lemma 4.7 of the main text, we have\nE[Yk(r)] ≥ P[W ] +\nt−r ∑\nj=1\n1\nj + 1 P[Qj ] (23)\n≥ 1− 1\n2 φ1/2 −\n1 2 φ. (24)\nLet q′ = 1 − 12φ 1/2 − 12φ. When φ 1/2 + φ < 1, it follows that q′ > 0.5. By using Hoeffding’s inequality, we obtain\nP\n\n\n1\nm\n∑\nk∈[m]\nYk(r) < 0.5\n\n ≤ exp(−2m(1/2− q′)2).\nLet Zk(j0) = ∑t\nj=j0 Xk(j). In an analogous manner, we can prove that\nP\n\n\n1\nm\n∑\nk∈[m]\nZk(l) < 0.5\n\n ≤ exp(−2m(1/2− q′)2).\nTherefore, the probability of success of iteration t may be bounded as\nP[Dt] ≤P\n[\n1\nm\nm ∑\nk=1\nYk(r) < 0.5\n]\n+ P\n[\n1\nm\nm ∑\nk=1\nZk(l) < 0.5\n]\n≤ 2e−2m(1/2−q ′)2 .\nAs a result, when m ≥ c log 2nδ with c = 2 (1−2q′)2 , where q ′ = 1− 12φ 1/2 − 12φ, we have P[σ ∈ Σ0] > 1− δ."
    }, {
      "heading" : "F Other Lemmas and Proofs",
      "text" : "Lemma F.1. Let σ0 be a ranking over S and let A ⊆ S be such that A contains the elements ranked highest in σ0. Consider a ranking σ ∼MM(σ0, φ). Then, the marginal distribution of σ over S/A is the distribution MM(σ0,S/A, φ).\nProof. It suffices to prove the result for A = {x}, where x is the element ranked highest in σ0, as this result may be applied inductively. Consider all permutations σ such that for σS/{x} = π and some j ∈ [|S|], one has\nσ−1(t) =\n\n\n π−1(t), 1 ≤ t < j, π−1(t− 1), j < t ≤ |S|, x, t = j.\nFor simplicity of notation, we use σ(j) to denote a permutation with the above property. Then,\nP[σS/{x} = σ ′] =\n|S| ∑\nj=1\nP[σ(j)] = 1\nZ|S|\n|S| ∑\nj=1\nφdτ (σ (j) ,σ0) =\n1\nZ|S|\n|S| ∑\nj=1\nφj−1+dτ (σ (j) S/{x} ,σ0,S/{x})\n=\n∑|S| j=1 φ j−1\nZ|S| φdτ (π,σ0,S/{x}) =\n1\nZ|S/{x}| φdτ (π,σ0,S/{x}),\nwhere Zn = ∏n−1\ni=1 ∑i j=0 φ j denotes the normalization constant in the Mallows distribution of permutations with n elements.\nObserve that the same result holds when A is assumed to contain the lowest ranked element in σ0."
    }, {
      "heading" : "G Supplementary Algorithms",
      "text" : ""
    }, {
      "heading" : "G.1 Efficient Algorithms for Computing the Mode/Median for Partial Ranking Aggregation",
      "text" : "In Section 3 of the main text which discusses partial ranking aggregation, we pointed out that one can efficiently compute the voting function Vx(y), and hence the mode/median ĉ as well. Algorithm VII.1 of this text explains how to efficiently compute Vx(y), provided that for fixed k, x, vk→x(y) is positive over a continuous interval, or more precisely, when [x − cσk(x), x− cσ′k(x)]. Algorithm VII.1 has complexity O(m+x) and the computation of the mode/median of the component ĉ(x) requires O(x) time. Therefore, the total complexity of Algorithm 2 of the main text for partial rankings equals O(mn+ n2).\nAlgorithm VII.1: Computing {Vx(y)}y∈[x] when vk→x(y) is positive over [x− cσk(x), x− cσ′k(x)] Input: cσk , c ′ σk , votes vk→x(y) = vk→x1x−c′σk≤y≤x−cσk , ∀ k ∈ [m];\n1: Initialize Vx(y) = 0, for all y ∈ [x+ 1]; 2: For k from 1 to m do 3: Vx(x− c\n′ σk (x)) = Vx(x− c ′ σk (x)) + vk→x;\n4: Vx(x+ 1− cσk(x)) = Vx(x+ 1− cσk(x)) − vk→x; 5: For k from 2 to x+ 1 do 6: Vx(y) = Vx(y − 1) + Vx(y); 7: Output: Vx(y);"
    }, {
      "heading" : "G.2 A Kemeny-Distance Optimal Algorithm for Transforming Permutations into Partial Rankings",
      "text" : "In Section 3 of the main text pertaining to partial ranking aggregation, we pointed out that one can optimally transform the permutation output of Algorithm 2 into a partial ranking. Algorithm VII.2 of this text explains how to perform this transform. In the description of the algorithm, we used a : b = (a, a+1, ..., b) where a, b ∈ Z, b ≥ a. For a vector V , we used V (a : b) to denote (V (a), V (a+1), ..., V (b)). Algorithm VII.2 has complexity O(mn2 + n3).\nAlgorithm VII.2: Transforms a Permutation into a Partial Ranking that is Kemeny-Distance Optimal Input: Permutation σ, Set of partial rankings Σ; 1: Initialize BucketSize= (1, 1, ..., 1) ∈ Nn; 2: Initialize W = {wij}i,j∈[n] where wij = 1 m ∑ k∈[m] 1σk(σ−1(i))<σk(σ−1(j));\n3: [Val, BucketSize]=Dynamic-Programming(W , BucketSize); 4: Construct a partial ranking σ′ by putting the lowest BucketSize(1) many elements of σ into B1(σ\n′); Proceed by taking BucketSize(2) many elements of σ and placing them into B2(σ\n′) and so on; 5: Output: σ′. Dynamic-Programming(W , BucketSize) 1: n′ =length(BucketSize); 2: If n′ = 1 return [0, BucketSize]; 3: s = ⌊n′/2⌋; When σ−1(s) and σ−1(s+ 1) are in different buckets (4-6) 4: [Val1, BucketSize1]=Dynamic-Programming(W (1 : s, 1 : s), BucketSize(1 : s)); 5: [Val2, BucketSize2]=Dynamic-Programming(W (s+ 1 : n′, s+ 1 : n′), BucketSize(s+ 1 : n));\n6: Val-div=Val1+Val2+ ∑n′\ni=s+1 ∑s j=1 wij + 1 2\n∑n′\ni=s+1 ∑s j=1(BucketSize(i) ∗ BucketSize(j)− wji − wij).\nWhen σ−1(s) and σ−1(s+ 1) are in the same bucket (7-13) 7: wsi = wsi + w(s+1)i, for all i ∈ [n\n′]; 8: wis = wis + wi(s+1), for all i ∈ [n\n′]; 9: Val3=1/2 ∗ wss ; 10: Construct W ′ ∈ Rn ′−1×n′−1 by deleting the s+ 1th row and s+ 1th column of W ; 11: Construct newBucketSize: newBucketSize(i)=BucketSize(i) for 1 ≤ i ≤ s; newBucketSize(i)=BucketSize(i+ 1) for s+ 1 ≤ i ≤ n′ − 1; newBucketSize(s)=BucketSize(s)+BucketSize(s+ 1); 12: [Val4, BucketSize3]=Dynamic-Programming(W ′, newBucketSize); 13: Val-con= Val3+Val4; 14: if Val-con>Val-div,\nConstruct BucketSize4 via concatenation of BucketSize1 and BucketSize2; return [Val-div, BucketSize4];\n15: else return [Val-con, BucketSize3];"
    } ],
    "references" : [ {
      "title" : "Learning to rank using gradient descent",
      "author" : [ "Chris Burges", "Tal Shaked", "Erin Renshaw", "Ari Lazier", "Matt Deeds", "Nicole Hamilton", "Greg Hullender" ],
      "venue" : "Proceedings of the 22nd international conference on Machine learning. ACM, 2005, pp. 89–96.",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Learning to rank for information retrieval",
      "author" : [ "Tie-Yan Liu" ],
      "venue" : "Foundations and Trends in Information Retrieval, vol. 3, no. 3, pp. 225–331, 2009.",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Hydra: gene prioritization via hybrid distancescore rank aggregation",
      "author" : [ "Minji Kim", "Farzad Farnoud", "Olgica Milenkovic" ],
      "venue" : "Bioinformatics, p. btu766, 2014.",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Iterative ranking from pair-wise comparisons",
      "author" : [ "Sahand Negahban", "Sewoong Oh", "Devavrat Shah" ],
      "venue" : "Advances in Neural Information Processing Systems, 2012, pp. 2474–2482.",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Pairwise ranking aggregation in a crowdsourced setting",
      "author" : [ "Xi Chen", "Paul N Bennett", "Kevyn Collins-Thompson", "Eric Horvitz" ],
      "venue" : "Proceedings of the sixth ACM international conference on Web search and data mining. ACM, 2013, pp. 193–202.",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Mathematics without numbers",
      "author" : [ "John G Kemeny" ],
      "venue" : "Daedalus, vol. 88, no. 4, pp. 577–591, 1959.",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1959
    }, {
      "title" : "A computational study of the kemeny rule for preference aggregation",
      "author" : [ "Andrew Davenport", "Jayant Kalagnanam" ],
      "venue" : "AAAI, 2004, vol. 4, pp. 697–702.",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Rank aggregation revisited",
      "author" : [ "Cynthia Dwork", "Ravi Kumar", "Moni Naor", "D Sivakumar" ],
      "venue" : "2001.",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Aggregating inconsistent information: ranking and clustering",
      "author" : [ "Nir Ailon", "Moses Charikar", "Alantha Newman" ],
      "venue" : "Journal of the ACM (JACM), vol. 55, no. 5, pp. 23, 2008.",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Spearman’s footrule as a measure of disarray",
      "author" : [ "Persi Diaconis", "Ronald L Graham" ],
      "venue" : "Journal of the Royal Statistical Society. Series B (Methodological), pp. 262–268, 1977.",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "How to rank with few errors",
      "author" : [ "Claire Kenyon-Mathieu", "Warren Schudy" ],
      "venue" : "Proceedings of the thirty-ninth annual ACM symposium on Theory of computing. ACM, 2007, pp. 95–103.",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Probability models and statistical analyses for ranking data, vol",
      "author" : [ "Michael A Fligner", "Joseph S Verducci" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1993
    }, {
      "title" : "Efficient bayesian inference for generalized bradley–terry models",
      "author" : [ "Francois Caron", "Arnaud Doucet" ],
      "venue" : "Journal of Computational and Graphical Statistics, vol. 21, no. 1, pp. 174–196, 2012.",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Learning mallows models with pairwise preferences",
      "author" : [ "Tyler Lu", "Craig Boutilier" ],
      "venue" : "Proceedings of the 28th International Conference on Machine Learning (ICML-11), 2011, pp. 145–152.",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Cranking: Combining rankings using conditional probability models on permutations",
      "author" : [ "Guy Lebanon", "John Lafferty" ],
      "venue" : "ICML. Citeseer, 2002, vol. 2, pp. 363–370.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Comparing and aggregating rankings with ties",
      "author" : [ "Ronald Fagin", "Ravi Kumar", "Mohammad Mahdian", "D Sivakumar", "Erik Vee" ],
      "venue" : "Proceedings of the twenty-third ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems. ACM, 2004, pp. 47–58.",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Enumerative combinatorics, Number 49",
      "author" : [ "Richard P Stanley" ],
      "venue" : "Cambridge university press,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2011
    }, {
      "title" : "Linear-time ranking of permutations",
      "author" : [ "Martin Mareš", "Milan Straka" ],
      "venue" : "Algorithms–ESA 2007, pp. 187–193. Springer, 2007.",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Ranking and unranking permutations in linear time",
      "author" : [ "Wendy Myrvold", "Frank Ruskey" ],
      "venue" : "Information Processing Letters, vol. 79, no. 6, pp. 281–284, 2001.",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Lehmer code transforms and mahonian statistics on permutations",
      "author" : [ "Vincent Vajnovszki" ],
      "venue" : "Discrete Mathematics, vol. 313, no. 5, pp. 581–589, 2013.",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Ordering by weighted number of wins gives a good ranking for weighted tournaments",
      "author" : [ "Don Coppersmith", "Lisa Fleischer", "Atri Rudra" ],
      "venue" : "Proceedings of the seventeenth annual ACM-SIAM symposium on Discrete algorithm. Society for Industrial and Applied Mathematics, 2006, pp. 776– 782. 11",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Rank aggregation methods for the web",
      "author" : [ "Cynthia Dwork", "Ravi Kumar", "Moni Naor", "Dandapani Sivakumar" ],
      "venue" : "Proceedings of the 10th international conference on World Wide Web. ACM, 2001, pp. 613–622.",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Efficient large-scale graph analysis in mapreduce",
      "author" : [ "Karthik Kambatla", "Georgios Kollias", "Ananth Grama" ],
      "venue" : "2012.",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Nantonac collaborative filtering: recommendation based on order responses",
      "author" : [ "Toshihiro Kamishima" ],
      "venue" : "Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining. ACM, 2003, pp. 583–588.",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Eigentaste: A constant time collaborative filtering algorithm",
      "author" : [ "Ken Goldberg", "Theresa Roeder", "Dhruv Gupta", "Chris Perkins" ],
      "venue" : "Information Retrieval, vol. 4, no. 2, pp. 133–151, 2001.",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "The movielens datasets: History and context",
      "author" : [ "F Maxwell Harper", "Joseph A Konstan" ],
      "venue" : "ACM Transactions on Interactive Intelligent Systems (TiiS), vol. 5, no. 4, pp. 19, 2016.",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Rank aggregation is a family of problems concerned with fusing disparate ranking information, and it arises in application areas as diverse as social choice, meta-search, natural language processing, bioinformatics, and information retrieval [1, 2, 3].",
      "startOffset" : 242,
      "endOffset" : 251
    }, {
      "referenceID" : 1,
      "context" : "Rank aggregation is a family of problems concerned with fusing disparate ranking information, and it arises in application areas as diverse as social choice, meta-search, natural language processing, bioinformatics, and information retrieval [1, 2, 3].",
      "startOffset" : 242,
      "endOffset" : 251
    }, {
      "referenceID" : 2,
      "context" : "Rank aggregation is a family of problems concerned with fusing disparate ranking information, and it arises in application areas as diverse as social choice, meta-search, natural language processing, bioinformatics, and information retrieval [1, 2, 3].",
      "startOffset" : 242,
      "endOffset" : 251
    }, {
      "referenceID" : 3,
      "context" : "Sometimes, rankings are assumed to be of the form of a set of pairwise comparisons [4, 5].",
      "startOffset" : 83,
      "endOffset" : 89
    }, {
      "referenceID" : 4,
      "context" : "Sometimes, rankings are assumed to be of the form of a set of pairwise comparisons [4, 5].",
      "startOffset" : 83,
      "endOffset" : 89
    }, {
      "referenceID" : 5,
      "context" : "For the case of partial rankings, the distance of choice is the Kemeny distance [6].",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 6,
      "context" : "It is well known that for a wide range of distance functions, learning the underlying models and aggregating rankings is computationally hard [7].",
      "startOffset" : 142,
      "endOffset" : 145
    }, {
      "referenceID" : 7,
      "context" : "Nevertheless, for the case when the distance measure is the Kendall τ distance, a number of approximation algorithms have been developed that offer various trade-offs between quality of aggregation and computational complexity [8, 9].",
      "startOffset" : 227,
      "endOffset" : 233
    }, {
      "referenceID" : 8,
      "context" : "Nevertheless, for the case when the distance measure is the Kendall τ distance, a number of approximation algorithms have been developed that offer various trade-offs between quality of aggregation and computational complexity [8, 9].",
      "startOffset" : 227,
      "endOffset" : 233
    }, {
      "referenceID" : 9,
      "context" : "The techniques used for aggregating permutations in a given set include randomly choosing a permutation from the set (PICK-A-PERM), pivoting via random selections of elements and divide-and-conquer approaches (FAS-PIVOT), Markov chain methods akin to PageRank, and minimum weight graph matching methods exploiting the fact that the Kendall τ distance is well-approximated by the Spearman footrule distance (SM) [10].",
      "startOffset" : 411,
      "endOffset" : 415
    }, {
      "referenceID" : 8,
      "context" : "Methods with provable performance guarantees – PICK-A-PERM, FAS-PIVOT, and SM – give a 2-approximation for the objective function, although combinations thereof are known to improve the constant to 11/7 or 4/3 [9].",
      "startOffset" : 210,
      "endOffset" : 213
    }, {
      "referenceID" : 10,
      "context" : "There also exists a polynomial time approximation scheme (PTAS) for the aggregation problem [11].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 11,
      "context" : "In many cases, a performance analysis on probabilistic models [12] such as the Plackett-Luce model [13] or the Mallows model [14, 15], is intractable.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 12,
      "context" : "In many cases, a performance analysis on probabilistic models [12] such as the Plackett-Luce model [13] or the Mallows model [14, 15], is intractable.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 13,
      "context" : "In many cases, a performance analysis on probabilistic models [12] such as the Plackett-Luce model [13] or the Mallows model [14, 15], is intractable.",
      "startOffset" : 125,
      "endOffset" : 133
    }, {
      "referenceID" : 14,
      "context" : "In many cases, a performance analysis on probabilistic models [12] such as the Plackett-Luce model [13] or the Mallows model [14, 15], is intractable.",
      "startOffset" : 125,
      "endOffset" : 133
    }, {
      "referenceID" : 15,
      "context" : "Partial rankings may be used to complete rankings of subsets of element in [n] in a number of different ways [16], one being to tie all unranked elements at the last position.",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 15,
      "context" : "We use a similar set of definitions for partial rankings [16].",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 15,
      "context" : "A partial ranking is often represented using buckets, and is in this context referred to as a bucket order [16].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 9,
      "context" : "A number of distance functions between permutations are known from the social choice, learning and discrete mathematics literature [10].",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 16,
      "context" : ", any permutation π ∈ Sn can be converted into another permutation σ ∈ Sn through a sequence of transpositions (adjacent transpositions) [17].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 9,
      "context" : "A well known result by Diaconis and Graham [10] asserts that dτ (π, σ) ≤ dS(π, σ) ≤ 2dτ (π, σ).",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 15,
      "context" : "(2) The Kemeny distance includes a component equal to the Kendal τ distance between the linear chains in the partial rankings, and another, scaled component that characterizes the distance of tied pairs of elements [16].",
      "startOffset" : 215,
      "endOffset" : 219
    }, {
      "referenceID" : 15,
      "context" : "The Spearman footrule distance may also be defined to apply to partial rankings [16], and it equals the sum of the absolute differences between “positions” of elements in the partial rankings.",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 15,
      "context" : "The above defined Spearman distance is a 2-approximation for the Kemeny distance between two partial rankings [16].",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 0,
      "context" : "a word of the form cσ ∈ Cn , {0} × [0, 1]× [0, 2]× · · · × [0, n− 1], where for i = 1, .",
      "startOffset" : 35,
      "endOffset" : 41
    }, {
      "referenceID" : 1,
      "context" : "a word of the form cσ ∈ Cn , {0} × [0, 1]× [0, 2]× · · · × [0, n− 1], where for i = 1, .",
      "startOffset" : 43,
      "endOffset" : 49
    }, {
      "referenceID" : 17,
      "context" : "e 1 2 3 4 5 6 7 8 9 σ 2 1 4 5 7 3 6 9 8 cσ 0 1 0 0 0 3 1 0 1 It is well known that the Lehmer code is bijective, and that the encoding and decoding algorithms have linear complexity (n) [18, 19].",
      "startOffset" : 186,
      "endOffset" : 194
    }, {
      "referenceID" : 18,
      "context" : "e 1 2 3 4 5 6 7 8 9 σ 2 1 4 5 7 3 6 9 8 cσ 0 1 0 0 0 3 1 0 1 It is well known that the Lehmer code is bijective, and that the encoding and decoding algorithms have linear complexity (n) [18, 19].",
      "startOffset" : 186,
      "endOffset" : 194
    }, {
      "referenceID" : 19,
      "context" : "An overview of such codes and their relationship to Mahonian statistics on permutations may be found in [20].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 17,
      "context" : "If no parallelization is used, the first step requires O(mn) time, given that the Lehmer codes may be computed in O(n) time [18, 19].",
      "startOffset" : 124,
      "endOffset" : 132
    }, {
      "referenceID" : 18,
      "context" : "If no parallelization is used, the first step requires O(mn) time, given that the Lehmer codes may be computed in O(n) time [18, 19].",
      "startOffset" : 124,
      "endOffset" : 132
    }, {
      "referenceID" : 0,
      "context" : "For permutations, the aggregation procedure may be viewed as specialized voting: The ranking σk casts a vote to rank x at position x− cσk(x), for the case that only elements ≤ x are considered (A vote corresponds to some score confined to [0, 1]).",
      "startOffset" : 239,
      "endOffset" : 245
    }, {
      "referenceID" : 20,
      "context" : "One example of a positional method is Borda’s algorithm, which is known to produce a 5-approximation to the Kemeny-Young problem for permutations [21].",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 21,
      "context" : "It also offers significant reductions in computational time compared to the Spearman footrule method, which reduces to solving a weighted bipartite matching problem and hence has complexity at least O(mn + n) [22], or O(mn) when implemented in MapReduce [23].",
      "startOffset" : 209,
      "endOffset" : 213
    }, {
      "referenceID" : 22,
      "context" : "It also offers significant reductions in computational time compared to the Spearman footrule method, which reduces to solving a weighted bipartite matching problem and hence has complexity at least O(mn + n) [22], or O(mn) when implemented in MapReduce [23].",
      "startOffset" : 254,
      "endOffset" : 258
    }, {
      "referenceID" : 7,
      "context" : "A related type of aggregation is based on InsertionSort [8, 22].",
      "startOffset" : 56,
      "endOffset" : 63
    }, {
      "referenceID" : 21,
      "context" : "A related type of aggregation is based on InsertionSort [8, 22].",
      "startOffset" : 56,
      "endOffset" : 63
    }, {
      "referenceID" : 7,
      "context" : "The authors of [8] proposed setting σSt(t) to",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 8,
      "context" : "For comparative analysis, we choose the Fas-Pivot and FasLP-Pivot (LP) methods [9], InsertionSort with Comparison (InsertionComp) from [8], and the optimal Spearman Footrule distance aggregator (Spearman) [10].",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 7,
      "context" : "For comparative analysis, we choose the Fas-Pivot and FasLP-Pivot (LP) methods [9], InsertionSort with Comparison (InsertionComp) from [8], and the optimal Spearman Footrule distance aggregator (Spearman) [10].",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 9,
      "context" : "For comparative analysis, we choose the Fas-Pivot and FasLP-Pivot (LP) methods [9], InsertionSort with Comparison (InsertionComp) from [8], and the optimal Spearman Footrule distance aggregator (Spearman) [10].",
      "startOffset" : 205,
      "endOffset" : 209
    }, {
      "referenceID" : 8,
      "context" : "For Fas-Pivot and FasLP-Pivot, we chose the better result of Pick-A-Perm and the given method, as suggested in [9].",
      "startOffset" : 111,
      "endOffset" : 114
    }, {
      "referenceID" : 0,
      "context" : "The variance parameter was chosen according to φ = e, where λ is allowed to vary in [0, 1].",
      "startOffset" : 84,
      "endOffset" : 90
    }, {
      "referenceID" : 23,
      "context" : "To test the permutation LCA aggregation algorithms, we used the Sushi ranking dataset [24] and the Jester dataset [25].",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 24,
      "context" : "To test the permutation LCA aggregation algorithms, we used the Sushi ranking dataset [24] and the Jester dataset [25].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 24,
      "context" : "To test our partial ranking aggregation algorithms, we used the complete Jester dataset [25] and the Movielens dataset [26].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 25,
      "context" : "To test our partial ranking aggregation algorithms, we used the complete Jester dataset [25] and the Movielens dataset [26].",
      "startOffset" : 119,
      "endOffset" : 123
    }, {
      "referenceID" : 4,
      "context" : "The scores are integers in [5], so that many ties are present.",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "[1] Chris Burges, Tal Shaked, Erin Renshaw, Ari Lazier, Matt Deeds, Nicole Hamilton, and Greg Hullender, “Learning to rank using gradient descent,” in Proceedings of the 22nd international conference on Machine learning.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[2] Tie-Yan Liu, “Learning to rank for information retrieval,” Foundations and Trends in Information Retrieval, vol.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[3] Minji Kim, Farzad Farnoud, and Olgica Milenkovic, “Hydra: gene prioritization via hybrid distancescore rank aggregation,” Bioinformatics, p.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[4] Sahand Negahban, Sewoong Oh, and Devavrat Shah, “Iterative ranking from pair-wise comparisons,” in Advances in Neural Information Processing Systems, 2012, pp.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5] Xi Chen, Paul N Bennett, Kevyn Collins-Thompson, and Eric Horvitz, “Pairwise ranking aggregation in a crowdsourced setting,” in Proceedings of the sixth ACM international conference on Web search and data mining.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[6] John G Kemeny, “Mathematics without numbers,” Daedalus, vol.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[7] Andrew Davenport and Jayant Kalagnanam, “A computational study of the kemeny rule for preference aggregation,” in AAAI, 2004, vol.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[8] Cynthia Dwork, Ravi Kumar, Moni Naor, and D Sivakumar, “Rank aggregation revisited,” 2001.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9] Nir Ailon, Moses Charikar, and Alantha Newman, “Aggregating inconsistent information: ranking and clustering,” Journal of the ACM (JACM), vol.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 9,
      "context" : "[10] Persi Diaconis and Ronald L Graham, “Spearman’s footrule as a measure of disarray,” Journal of the Royal Statistical Society.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11] Claire Kenyon-Mathieu and Warren Schudy, “How to rank with few errors,” in Proceedings of the thirty-ninth annual ACM symposium on Theory of computing.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[12] Michael A Fligner and Joseph S Verducci, Probability models and statistical analyses for ranking data, vol.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[13] Francois Caron and Arnaud Doucet, “Efficient bayesian inference for generalized bradley–terry models,” Journal of Computational and Graphical Statistics, vol.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 13,
      "context" : "[14] Tyler Lu and Craig Boutilier, “Learning mallows models with pairwise preferences,” in Proceedings of the 28th International Conference on Machine Learning (ICML-11), 2011, pp.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 14,
      "context" : "[15] Guy Lebanon and John Lafferty, “Cranking: Combining rankings using conditional probability models on permutations,” in ICML.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[16] Ronald Fagin, Ravi Kumar, Mohammad Mahdian, D Sivakumar, and Erik Vee, “Comparing and aggregating rankings with ties,” in Proceedings of the twenty-third ACM SIGMOD-SIGACT-SIGART symposium on Principles of database systems.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[17] Richard P Stanley, Enumerative combinatorics, Number 49.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 17,
      "context" : "[18] Martin Mareš and Milan Straka, “Linear-time ranking of permutations,” in Algorithms–ESA 2007, pp.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[19] Wendy Myrvold and Frank Ruskey, “Ranking and unranking permutations in linear time,” Information Processing Letters, vol.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] Vincent Vajnovszki, “Lehmer code transforms and mahonian statistics on permutations,” Discrete Mathematics, vol.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "[21] Don Coppersmith, Lisa Fleischer, and Atri Rudra, “Ordering by weighted number of wins gives a good ranking for weighted tournaments,” in Proceedings of the seventeenth annual ACM-SIAM symposium on Discrete algorithm.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "[22] Cynthia Dwork, Ravi Kumar, Moni Naor, and Dandapani Sivakumar, “Rank aggregation methods for the web,” in Proceedings of the 10th international conference on World Wide Web.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "[23] Karthik Kambatla, Georgios Kollias, and Ananth Grama, “Efficient large-scale graph analysis in mapreduce,” 2012.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[24] Toshihiro Kamishima, “Nantonac collaborative filtering: recommendation based on order responses,” in Proceedings of the ninth ACM SIGKDD international conference on Knowledge discovery and data mining.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "[25] Ken Goldberg, Theresa Roeder, Dhruv Gupta, and Chris Perkins, “Eigentaste: A constant time collaborative filtering algorithm,” Information Retrieval, vol.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "[26] F Maxwell Harper and Joseph A Konstan, “The movielens datasets: History and context,” ACM Transactions on Interactive Intelligent Systems (TiiS), vol.",
      "startOffset" : 0,
      "endOffset" : 4
    } ],
    "year" : 2017,
    "abstractText" : "We propose a novel rank aggregation method based on converting permutations into their corresponding Lehmer codes or other subdiagonal images. Lehmer codes, also known as inversion vectors, are vector representations of permutations in which each coordinate can take values not restricted by the values of other coordinates. This transformation allows for decoupling of the coordinates and for performing aggregation via simple scalar median or mode computations. We present simulation results illustrating the performance of this completely parallelizable approach and analytically prove that both the mode and median aggregation procedure recover the correct centroid aggregate with small sample complexity when the permutations are drawn according to the well-known Mallows models. The proposed Lehmer code approach may also be used on partial rankings, with similar performance guarantees.",
    "creator" : "LaTeX with hyperref package"
  }
}