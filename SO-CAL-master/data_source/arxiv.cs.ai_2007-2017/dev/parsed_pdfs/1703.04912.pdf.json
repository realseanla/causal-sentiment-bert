{
  "name" : "1703.04912.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "ZHIQIANG ZHUANG", "KEWEN WANG", "Sebastian Binnewies", "Zhiqiang Zhuang", "Kewen Wang" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 3.\n04 91\n2v 2\n[ cs\n.A I]\n1 7\nM ar\n2 01\n7\n00\nSyntax-Preserving Belief Change Operators for Logic Programs\nSEBASTIAN BINNEWIES, Griffith University ZHIQIANG ZHUANG, Griffith University KEWEN WANG, Griffith University BELA STANTIC, Griffith University\nRecent methods have adapted the well-established AGM and belief base frameworks for belief change to cover belief revision in logic programs. In this study here, we present two new sets of belief change operators for logic programs. They focus on preserving the explicit relationships expressed in the rules of a program, a feature that is missing in purely semantic approaches that consider programs only in their entirety. In particular, operators of the latter class fail to satisfy preservation and support, two important properties for belief change in logic programs required to ensure intuitive results.\nWe address this shortcoming of existing approaches by introducing partial meet and ensconcement constructions for logic program belief change, which allow us to define syntax-preserving operators that satisfy preservation and support. Our work is novel in that our constructions not only preserve more information from a logic program during a change operation than existing ones, but they also facilitate natural definitions of contraction operators, the first in the field to the best of our knowledge.\nIn order to evaluate the rationality of our operators, we translate the revision and contraction postulates from the AGM and belief base frameworks to the logic programming setting. We show that our operators fully comply with the belief base framework and formally state the interdefinability between our operators. We further propose an algorithm that is based on modularising a logic program to reduce partial meet and ensconcement revisions or contractions to performing the operation only on the relevant modules of that program. Finally, we compare our approach to two state-of-the-art logic program revision methods and demonstrate that our operators address the shortcomings of one and generalise the other method.\nCCS Concepts: rComputing methodologies → Logic programming and answer set programming; Nonmonotonic, default reasoning and belief revision; rTheory of computation → Constraint and logic programming;\nAdditional Key Words and Phrases: Logic Program, Belief Change, Strong Equivalence, Answer Set\nACM Reference Format: Sebastian Binnewies, Zhiqiang Zhuang, Kewen Wang, and Bela Stantic 2017. Syntax-Preserving Belief Change Operators for Logic Programs. ACM Trans. Embedd. Comput. Syst. 0, 0, Article 00 (March 2000), 44 pages. DOI: 0000001.0000001"
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "A key ingredient for any machine to be considered ‘artificially intelligent’ is a system to represent and reason about knowledge in the application domain of interest [McCarthy 1958]. In analogy to a human brain, such a system should be capable of storing information in some knowledge base and reasoning over existing information to deduce new information. Moreover, information in a knowledge base should be amenable to change, whether it be adding, deleting, or modifying information. The study of belief\nAuthor’s addresses: Sebastian Binnewies and Zhiqiang Zhuang and Kewen Wang and Bela Stantic, School of Information and Communication Technology, Griffith University, Australia; Email: s.binnewies@griffith.edu.au, z.zhuang@griffith.edu.au, k.wang@griffith.edu.au, b.stantic@griffith.edu.au. Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permitted. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. Request permissions from permissions@acm.org. c© 2000 ACM. 1539-9087/2000/03-ART00 $15.00 DOI: 0000001.0000001\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nchange [Doyle 1979; Fagin et al. 1983; Gärdenfors 1988; Hansson 1999; Harper 1976; Levi 1980] concerns itself exactly with these kinds of dynamics in knowledge bases. It aims at providing mechanisms to change a knowledge base whenever new information is acquired. The majority of these mechanisms rely on two fundamental principles: the principle of primacy of new information, stating that new information should be treated with priority over existing information in the knowledge base, and the principle of minimal change, stating that as much existing information as possible should be preserved during a change operation [Dalal 1988]. An important endeavour to guide change operations on a knowledge base and by now the most widely-adopted belief change paradigm is the so-called AGM framework, named after the initials of the author trio [Alchourrón et al. 1985]. It classifies the possible changes to a knowledge base as expansion, revision, and contraction operations. In an expansion, new information is incorporated into a knowledge base, regardless of any inconsistencies that may arise. A revision operation also incorporates new information into a knowledge base, but in such a way that the resulting knowledge base is consistent. This is achieved by discarding some existing information. During a contraction, no new information is added to a knowledge base but some existing information is removed from it. On the one hand, the framework provides a set of postulates that each rational change operator should satisfy, and, on the other hand, defines specific constructions of expansion, revision, and contraction that satisfy these criteria. While the underlying assumption of the AGM framework is that any information implied by a knowledge base is represented explicitly in the knowledge base, the belief base framework of belief change [Fuhrmann 1991; Hansson 1989; Rott 1992] does not require this assumption. Postulates and constructions for expansion, revision, and contraction operators in the belief base framework have been defined to complement those from the AGM model (Hansson [1999] provides a summary). While the AGM and belief base frameworks have been applied to a variety of knowledge representation formalisms (an overview is given by Wassermann [2011]), work on an adaptation to knowledge representation in the form of logic programs [Colmerauer and Roussel 1996; Kowalski 1974; Lloyd 1987] has been slow to progress. A major challenge in the adaptation of the AGM and belief base frameworks to logic programming lies in the semantics of logic programs. While the frameworks and their previous adaptations are based on monotonic semantics, the standard answer set semantics [Gelfond and Lifschitz 1988] of logic programs is nonmonotonic. Only recently have operators been proposed for belief revision in logic programs. Program-level revision [Delgrande 2010] and screened semi-revision [Krümpelmann and Kern-Isberner 2012] are initial approaches to logic program revision, yet have strict limitations in their expressiveness due to the nonmonotonicity of the underlying answer set semantics. A breakthrough arrived with the distance-based approach [Delgrande et al. 2013] to logic program revision, which rests upon characterising an agent’s beliefs in terms of the set of SE (strong equivalence) models [Lifschitz et al. 2001; Turner 2003] of a logic program. A logic program P has the same set of SE models as a program Q if and only if, for any programR, the answer sets of P combinedwith R are exactly the same as the answer sets of Q combined with R. SE model semantics provides an alternative, monotonic characterisation for logic programs and thus circumvents obstacles presented by nonmonotonicity. To revise a program P by a program Q, the distance-based revision operator determines those SE models from the set of SE models of Q that are closest to the SE models of P . Even though the distance-based approach is a major milestone for logic program revision, it has some critical shortcomings. Firstly, as it relies on the set of SE models of an entire program as the representation of beliefs expressed by the program, it operates on the program-level only. This means that a program may freely be substituted\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nwith any other that has the same set of SE models and the revision output will remain the same. However, the information expressed by a program is more than just its set of SE models – a program also encodes relationships between the atoms occurring in it [Leite and Pereira 1998]. Such relationships are expressed on the rule-level, by the individual rules contained in a program. By neglecting information expressed on the rule-level, the distance-based approach fails to satisfy the property of preservation [Inoue and Sakama 2004] and the property of support [Inoue and Sakama 2004; Slota and Leite 2013]. This leads to some highly unintuitive results, as illustrated by the following two examples.\nIt is the 31st of December and I plan to drive from San Jose to San Francisco to see the New Year fireworks. Due to previous experience I believe that if there is heavy fog in San Francisco, then the city will cancel the fireworks. It has been clear and sunny for the last days, so I believe that it will not be foggy today either. I decide to check the weather forecast nonetheless, which says that there will be heavy fog tonight in San Francisco. Since I trust the forecast more than my own meteorological skills, I have to revise my beliefs. By employing the distance-based revision method, I would end up believing that it will be foggy, while being undecided whether the fireworks will be cancelled. Formally, let P1 = {⊥ ← fog., no fireworks ← fog. } and Q1 = { fog. }. Then the distance-based revision of P1 by Q1 would return { fog. }.\nI drive from San Jose to San Francisco every morning for work. I can use the 101 highway or the 280 freeway, but neither is particularly quicker. However, I believe that if there are roadworks on the 101, then the 280 is quicker. I was told by a friend that there are roadworks on the 101 currently, so I have been travelling on the 280. Now I hear on the radio that the roadworks finished and revise my beliefs. Using the distance-based revision method, I would end up with the belief that there are no roadworks on the 101, while still keeping the belief that the 280 is quicker. Formally, let P2 = { 101 roadworks., 280 quicker ← 101 roadworks. } and Q2 = {⊥ ← 101 roadworks. }. Then the distance-based revision of P2 by Q2 would return {⊥ ← 101 roadworks., 280 quicker. }.\nThe first example demonstrates that the distance-based approach does not satisfy the preservation property. I do not conclude that the fireworks will be cancelled, even though I know now that it will be foggy. The revision operation simply disregards the second rule of P1, which expresses the relationship between fog and fireworks cancellation. The reason for this is that the set of SE models of the first rule of P1 is a proper subset of the set of SE models of the second rule. Thus, the set of SE models of P1 is exactly the set of SE models of the first rule, which means that the second rule is invisible in the program-level view. The second example demonstrates that the distance-based approach does not satisfy the support property. I keep believing that the 280 is quicker, although the grounds to believe so do not hold any longer. The problem is that the dependency relationship between 280 quicker and 101 roadworks is captured on the rule-level, by the set of SE models of the second rule of P2, but not on the program-level, by the set of SE models of the entire program P2. A second shortcoming is that the distance-based approach makes the definition of a corresponding contraction operator difficult to come by. In classical logic, contraction can be defined in terms of revision by using the negation of a sentence. However, in logic programswe do not have the luxury of negation of a program. A workaround could be to use the complement of the set of SE models of the contracting program Q and\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nselect from this set the SE models that are closest to the ones of the initial program P . Yet, such a method may return SE models that are somewhat unrelated to P or Q, especially when the complement consists of a large number of SE models. Themotivation for this work is to address these limitations. In particular, we propose here, on the one hand, revision operators that take into account information expressed by a program on the program-level and the rule-level in order to avoid such unintuitive results as just shown. On the other hand, we present corresponding contraction operators with similar properties. The main contributions of this work can be summarised as follows.\n—We provide new translations of the AGM and belief base revision and contraction postulates to the logic programming setting and establish formal relationships between these postulates and to previous translations. —We introduce two sets of belief change operators for logic programs – partial meet revision and contraction operators and ensconcement revision and contraction operators – and show that each operator satisfies the relevant belief base revision or contraction postulates as well as the majority of AGM revision or contraction postulates. We also demonstrate that our partial meet and ensconcement revision operators address the shortcomings of the distance-based approach to logic program revision and that they are generalisations of the screened semi-revision approach for logic programs. —We establish that our ensconcement operators are generalisations of our partial meet operators and that the Levi and Harper identities hold for our operators. We further show that the outcome of a revision or contraction operation remains unaffected whether an ensconcement is defined over rules or subsets of a program. —We propose an algorithm to optimise the operations of partial meet and ensconcement revision or contraction of a logic program. —We connect our results to the classic belief change frameworks by showing that our operators possess similar properties as their counterparts in propositional logic, that they conform fully to the belief base framework, and that they align more closely to the AGM and belief base frameworks than the distance-based revision operators.\nThe remainder of this paper is organised as follows. We first provide the preliminaries in Section 2 and review related work in Section 3. We then present new translations of the AGM and belief base revision and contraction postulates to logic programs in Section 4. In Sections 5 and 6, we propose partial meet and ensconcement belief change operators for logic programs, respectively, and evaluate their suitability with respect to the relevant postulates and existing operators. We establish the formal relationships between our operators in Section 7. In Section 8, we present an algorithm to optimise the operations of revision or contraction on a logic program. We finally discuss our findings in relation to the classic belief change frameworks in Section 9 and conclude with a summary in Section 10. Preliminary results from Sections 5 and 8 were presented in a conference paper [Binnewies et al. 2015]."
    }, {
      "heading" : "2. PRELIMINARIES",
      "text" : "We first briefly recall syntax and semantics of logic programs and then review the foundations of belief change."
    }, {
      "heading" : "2.1. Logic Programming",
      "text" : "Let A be a finite vocabulary of propositional atoms. A rule r over A has the form\na1; . . . ; ak;not b1; . . . ;not bl ← c1, . . . , cm, not d1, . . . , not dn. (1)\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nHere, all ai, bi, ci, di ∈ A and k, l,m, n ≥ 0. The operators ‘not’, ‘;’, and ‘,’ stand for default negation, disjunction, and conjunction, respectively. For convenience, letH+(r) = {a1, . . . , ak}, H−(r) = {b1, . . . , bl}, B+(r) = {c1, . . . , cm}, and B−(r) = {d1, . . . , dn}. If k = 1 and l = m = n = 0, then r is called a fact and we omit ‘←’; if k = l = 0, then r is a constraint and we denote the empty disjunction by ⊥. Let At(r) and At(R) denote the set of all atoms that occur in a rule of the form (1) and in a set of rules R, respectively. A (generalised) logic program is a finite set of rules of the form (1). We write LPA for the class of all logic programs that can be constructed from A. An interpretation Y ⊆ A satisfies a program P , denoted by Y |= P , if and only if (iff) it is a model of all rules under the standard definition for propositional logic such that each rule represents a conditional and default negation is transcribed to classical negation. Let Mod(P ) = { Y | Y |= P }. An answer set [Gelfond and Lifschitz 1988] of a program P is any subset-minimal interpretation Y that satisfies the reduct of P with respect to Y , denoted by P Y and defined as:\nP Y = {H+(r) ← B+(r) | r ∈ P,H−(r) ⊆ Y, and B−(r) ∩ Y = ∅ }.\nThe set of all answer sets of P is denoted by AS(P ). An SE interpretation is a tuple (X,Y ) of interpretations withX ⊆ Y ⊆ A. We usually write, e.g., (ab, ab) instead of ({a, b}, {a, b}) for legibility. Let SE be the set of all SE interpretations over A. For any set S of SE interpretations, by S we denote the complement of S with respect to SE , that is, S = SE \\S. An SE interpretation (X,Y ) is an SE model [Turner 2003] of a program P iff Y |= P and X |= P Y . The set of all SE models of P is denoted by SE(P ) and P is satisfiable iff SE(P ) 6= ∅. An interpretation Y is an answer set of P iff (Y, Y ) ∈ SE(P ) and, for any X ⊂ Y , (X,Y ) 6∈ SE(P ). Often we drop explicit set notation for rules and their union, e.g., for rules r, r′ ∈ P , we use SE(r) to denote SE({r}) and write SE(r∪r′) instead of SE({r}∪{r′}). Note that SE(P ) = ⋂\nr∈P SE(r). Given two programs P andQ, we say that P is strongly equivalent [Lifschitz et al. 2001] to Q, denoted by P ≡s Q, iff SE(P ) = SE(Q), and P implies Q, denoted by P |=s Q, iff SE(P ) ⊆ SE(Q). In the particular case of SE(P ) ⊂ SE(Q), we say that P strictly implies Q. The relation |=s is antitonic with respect to the program subset relation, i.e., Q ⊆ P implies P |=s Q. Furthermore, we write |=s P to express SE(P ) = SE . SE models are a refinement of answer sets as they provide more information about the atoms in a program and their dependencies. For example, each of the following programs P1, P2, . . . , P9 over A = {a, b} has {∅} as the only answer set but the sets of SE models are different for each program:\nP1 = {⊥ ← a. } SE(P1) = {(∅, ∅), (∅, b), (b, b)}\nP2 = {⊥ ← b. } SE(P2) = {(∅, ∅), (∅, a), (a, a)}\nP3 = { a ← b. } SE(P3) = {(∅, ∅), (∅, a), (a, a), (∅, ab), (a, ab), (ab, ab)}\nP4 = { b ← a. } SE(P4) = {(∅, ∅), (∅, b), (b, b), (∅, ab), (b, ab), (ab, ab)}\nP5 = {⊥ ← a, b. } SE(P5) = {(∅, ∅), (∅, a), (a, a), (∅, b), (b, b)}\nP6 = {⊥ ← not a, b. } SE(P6) = {(∅, ∅), (∅, a), (a, a), (∅, ab), (a, ab), (b, ab), (ab, ab)}\nP7 = {⊥ ← a, not b. } SE(P7) = {(∅, ∅), (∅, b), (b, b), (∅, ab), (a, ab), (b, ab), (ab, ab)}\nP8 = { a;not b. } SE(P8) = {(∅, ∅), (∅, a), (a, a), (a, ab), (ab, ab)}\nP9 = {not a; b. } SE(P9) = {(∅, ∅), (∅, b), (b, b), (b, ab), (ab, ab)}\nInformally, we can interpret the content of an SE model (X,Y ) on a three-valued scale. Any atoms in X are true, any atoms not in Y are false, and any atoms in Y but not in X are undefined.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."
    }, {
      "heading" : "2.2. Belief Change",
      "text" : "The AGM framework [Alchourrón et al. 1985; Gärdenfors 1988] defines expansion, revision, and contraction as the change operations on a body of beliefs held by an agent, called a belief state henceforth, in light of some new information. In an expansion, new beliefs are incorporated into a belief state, regardless of any inconsistencies that may arise. A revision operation also incorporates new beliefs into a belief state, but in such a way that the resulting belief state is consistent. This is achieved by discarding some existing beliefs. During a contraction, some beliefs in a belief state are removed without adding new beliefs. In the AGM framework, a belief state is modelled as a belief set, defined as a set of sentences from some logic-based language L that is closed under logical consequence, i.e., when all beliefs implied by a knowledge base are explicitly represented in the knowledge base. Let K be a belief set, φ and ψ sentences, K⊥ denote the inconsistent belief set, and Cn(·) stand for a logical consequence function. By φ ≡ ψ we mean Cn(φ) = Cn(ψ). The expansion of K by φ, written K ⊕ φ, is defined as K ⊕ φ = Cn(K ∪ {φ}). The AGM framework provides a set of postulates that any rational revision operator should satisfy. The postulates are listed as follows, where ⊛ represents a revision operator.\n(⊛1) K ⊛ φ is a belief set (⊛2) φ ∈ K ⊛ φ (⊛3) K ⊛ φ ⊆ K ⊕ φ (⊛4) If ¬φ 6∈ K, then K ⊕ φ ⊆ K ⊛ φ (⊛5) K ⊛ φ = K⊥ iff ⊢ ¬φ (⊛6) If φ1 ≡ φ2, then K ⊛ φ1 = K ⊛ φ2 (⊛7) K ⊛ (φ ∧ ψ) ⊆ (K ⊛ φ)⊕ ψ (⊛8) If ¬ψ 6∈ K ⊛ φ, then (K ⊛ φ)⊕ ψ ⊆ K ⊛ (φ ∧ ψ)\n(⊛1) requires that the outcome of a revision is a belief set. (⊛2) states that the revising sentence is contained in the revised belief set. (⊛3) asserts that a belief set revised by a sentence is always a subset of the belief set expanded by that sentence. (⊛3) and (⊛4) together state that revision coincides with expansion in cases when the revising sentence is consistent with the initial belief set. (⊛5) guarantees that a revision outcome is consistent, unless the revising sentence is logically impossible. (⊛6) ensures that logically equivalent sentences lead to the same revision outcomes. (⊛7) and (⊛8) together enforce K to be minimally changed in a revision by both φ and ψ, such that the outcome is the same as the expansion of K ⊛ φ by ψ, provided that ψ is consistent with K ⊛ φ. In the concrete case that a belief state is represented as a finite set of propositional formulas, the following set of postulates is equivalent to the set (⊛1)–(⊛8) [Katsuno and Mendelzon 1991]. Let φ, ψ, µ be propositional formulas.\n(⊛1KM) φ⊛ ψ implies ψ (⊛2KM) If φ ∧ ψ is satisfiable, then φ⊛ ψ ≡ φ ∧ ψ (⊛3KM) If ψ is satisfiable, then φ⊛ ψ is satisfiable (⊛4KM) If φ1 ≡ φ2 and ψ1 ≡ ψ2, then φ1 ⊛ ψ1 ≡ φ2 ⊛ ψ2 (⊛5KM) (φ ⊛ ψ) ∧ µ implies φ⊛ (ψ ∧ µ) (⊛6KM) If (φ⊛ ψ) ∧ µ is satisfiable, then φ⊛ (ψ ∧ µ) implies (φ ⊛ ψ) ∧ µ\n(⊛1KM) requires that the revising formula can be derived from the revision outcome. (⊛2KM) specifies that revision corresponds to conjunction whenever the revising formula is consistent with the formula to be revised. (⊛3KM) guarantees consistency of a revision outcome whenever the revising formula is consistent. (⊛4KM) states that\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nrevising logically equivalent formulas by logically equivalent formulas leads to logically equivalent results. (⊛5KM) and (⊛6KM) together stipulate that the revision by a conjunction leads to the same outcome as revising by one conjunct and then forming the conjunction with the other conjunct, provided that the conjunction thus formed is satisfiable. The AGM framework also provides a set of postulates that any rational contraction operator should satisfy. The postulates are given below, where ⊖ represents a contraction operator.\n(⊖1) K ⊖ φ is a belief set (⊖2) K ⊖ φ ⊆ K (⊖3) If φ 6∈ K, then K ⊖ φ = K (⊖4) If 6⊢ φ, then φ 6∈ K ⊖ φ (⊖5) K ⊆ (K ⊖ φ) ⊕ φ (⊖6) If φ1 ≡ φ2, then K ⊖ φ1 = K ⊖ φ2 (⊖7) K ⊖ φ ∩K ⊖ ψ ⊆ K ⊖ φ ∧ ψ (⊖8) If φ 6∈ K ⊖ φ ∧ ψ, then K ⊖ φ ∧ ψ ⊆ K ⊖ φ\n(⊖1) requires that the outcome of a contraction is a belief set. (⊖2) ensures that no new beliefs are introduced during a contraction. (⊖3) stipulates that the belief set remains unchanged during a contraction operation whenever the sentence to be contracted is not contained in it. (⊖4) states that a contracting sentence is not a logical consequence of the contracted belief set, unless the sentence is a tautology. (⊖5) requires that the original belief set can be recovered by expanding a contracted belief set by the sentence that was contracted. (⊖6) ensures that logically equivalent sentences lead to the same contraction outcomes. (⊖7) guarantees that any beliefs retained in a contraction by φ and in a contraction by ψ are also retained in a contraction by both φ and ψ. (⊖8) specifies that any beliefs retained in a contraction by both φ and ψ are also retained in a contraction by φ, whenever φ itself is not retained. The appropriateness of the Recovery postulate (⊖5) within this set of contraction postulates has been discussed intensively [Fuhrmann 1991; Hansson 1991; Makinson 1987; Nayak 1994; Niederée 1991]. To replace the Recovery postulate in expressing that no beliefs should be retracted unduly during a contraction operation, alternative postulates were proposed. Hansson [1991] offered the following postulate:\n(⊖5r) If ψ ∈ K \\ (K ⊖ φ), then there is a set K ′ such that K ⊖ φ ⊆ K ′ ⊂ K and φ 6∈ Cn(K ′) but φ ∈ Cn(K ′ ∪ {ψ}).\nThe Relevance postulate (⊖5r) states that a sentence ψ should only be removed during the contraction of a sentence φ from K if ψ is relevant for implying φ. In the presence of (⊖1)–(⊖3), (⊖5) is equivalent to (⊖5r) in propositional logic [Hansson 1991]. More recently, Fermé et al. [2008] presented the following Disjunctive Elimination postulate (⊖5de):\n(⊖5de) If ψ ∈ K \\ (K ⊖ φ), then K ⊖ φ 6⊢ φ ∨ ψ.\nAccording to (⊖5de), a sentence ψ should only be removed during the contraction of a sentence φ fromK if the contraction result does not imply the disjuntion of φ and ψ. In the presence of (⊖2)–(⊖3), (⊖5r) is equivalent to (⊖5de) in propositional logic [Fermé et al. 2008]. One of the classic constructions to implement belief change is partial meet contraction [Alchourrón et al. 1985], which we recapitulate here. A set K ′ is a remainder set of a set K ⊆ L with respect to a sentence φ iff\na) K ′ ⊆ K,\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nb) K ′ 6⊢ φ, and c) for any K ′′ with K ′ ⊂ K ′′ ⊆ K : K ′′ ⊢ φ.\nThe set of all remainder sets of K with respect to φ is denoted by K⊥φ. A selection function γ for a belief set K is a function such that (i) if K⊥φ 6= ∅, then ∅ 6= γ(K⊥φ) ⊆ K⊥φ and (ii) γ(K⊥φ) = {K} otherwise. A partial meet contraction operator⊖γ forK is defined as: K ⊖γ φ = ⋂\nγ(K⊥φ). The following representation theorem shows that the set of postulates (⊖1)–(⊖6) exactly characterises the class of partial meet contraction operators.\nTHEOREM 2.1. [Alchourrón et al. 1985] For any belief set K, ⊖γ is a partial meet contraction operator for K iff ⊖γ satisfies (⊖1)–(⊖6).\nBy placing further restrictions on the selection function, the representation theorem can be extended to the full set of postulates. A transitively relational selection function γ′ for K is determined by a transitive relation ✂ over 2K such that γ′(K⊥φ) = {K ′ ∈ K⊥φ | K ′′ ✂ K ′ for all K ′′ ∈ K⊥φ }. A partial meet contraction operator ⊖γ′ determined by a transitively relational selection function γ′ is called a transitively relational partial meet contraction operator.\nTHEOREM 2.2. [Alchourrón et al. 1985] For any belief set K, ⊖γ′ is a transitively relational partial meet contraction operator for K iff ⊖γ′ satisfies (⊖1)–(⊖8).\nA corresponding (transitively relational) partial meet revision operator ⊛γ (⊛γ′) that satisfies (⊛1)–(⊛6) ((⊛1)–(⊛8)) can be obtained from a (transitively relational) partial meet contraction operator via the Levi identity: K ⊛ φ = (K ⊖ ¬φ) ⊕ φ [Gärdenfors 1981; Levi 1977]. The inverse identity, which constructs a contraction operator from a revision operator, is due to Harper [1976]: K ⊖ φ = K ∩ (K ⊛ ¬φ). While the AGM approach provides an effective framework to conduct belief change, the representation of belief states in the form of belief sets has some shortcomings (see [Hansson 1999] for a detailed discussion). From a practical perspective, main drawbacks of belief sets are that they are generally large objects, since all logical consequences of all beliefs are contained, and that it is impossible to distinguish between inconsistent belief sets, as inconsistent belief sets consist of the entire language. Belief bases [Fuhrmann 1991; Hansson 1989; Rott 1992] are an alternative representation of belief states. A belief base is a set of sentences from L that is not necessarily closed under logical consequence. Hansson [1993] defined a partial meet base contraction operator −γ for a belief base B as B −γ φ = ⋂\nγ(B⊥φ) and showed that the following set of postulates exactly characterises the class of partial meet base contraction operators.\n(−1) B − φ ⊆ B (−2) If 6⊢ φ, then φ 6∈ Cn(B − φ) (−3) If ψ ∈ B \\ (B−φ), then there is a set B′ such that B−φ ⊆ B′ ⊂ B and φ 6∈ Cn(B′) but φ ∈ Cn(B′ ∪ {ψ}) (−4) If it holds for all B′ ⊆ B that φ ∈ Cn(B′) iff ψ ∈ Cn(B′), then B − φ = B − ψ\nTHEOREM 2.3. [Hansson 1993] For any belief base B, −γ is a partial meet base contraction operator for B iff −γ satisfies (−1)–(−4).\nNote that (−1), (−2), and (−3) in the belief base setting correspond directly to (⊖2), (⊖4), and (⊖5r) in the AGM setting, respectively. (−4) states that if any parts of B which imply φ also imply ψ, then the same parts of B will be retained in a contraction by φ as in a contraction by ψ.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nHe also defined a corresponding partial meet base revision operator >γ for a belief base B as B >γ φ = (B −γ ¬φ) ∪ {φ} and showed that the following set of postulates exactly characterises the class of partial meet base revision operators.\n(>1) φ ∈ B > φ (>2) B > φ ⊆ B ∪ {φ} (>3) If ψ ∈ B \\ (B > φ), then there is a set B′ such that B > φ ⊆ B′ ⊂ B ∪ {φ} and ¬φ 6∈ Cn(B′) but ¬φ ∈ Cn(B′ ∪ {ψ}) (>4) If it holds for all B′ ⊆ B that B′ ∪ {φ} is consistent iff B′ ∪ {ψ} is consistent, then B ∩ (B > φ) = B ∩ (B > ψ) (>5) If 6⊢ ¬φ, then ¬φ 6∈ Cn(B > φ)\nTHEOREM 2.4. [Hansson 1993] For any belief base B, >γ is a partial meet base revision operator for B iff >γ satisfies (>1)–(>5).\nThe pendants to (>1) and (>2) in the AGM framework are (⊛2) and (⊛3), respectively. (>3) requires ψ to only be removed from B if it would otherwise make the revision outcome inconsistent. (>4) mandates that if any parts of B which are consistent with φ are also consistent with ψ, then the same parts of B will be retained in a revision by φ as in a revision by ψ. (>5) is a weaker version of (⊛5). Williams [1994] proposed further belief change operators for belief bases, which rely on an ordering over the sentences contained in a belief base, called ensconcement. An ensconcement associated with a belief base B is any total preorder4 on B that satisfies the following conditions.\n(41) For all φ ∈ B : {ψ ∈ B | φ ≺ ψ } 6⊢ φ (42) For all φ, ψ ∈ B : φ 4 ψ iff ⊢ ψ\nA sentence ψ is at least as ensconced as a sentence φ iff φ 4 ψ, and ψ is strictly more ensconced than φ iff φ ≺ ψ. Condition (41) states that sentences which are strictly more ensconced than a sentence φ do not entail φ. Condition (42) requires any tautologies in the belief base to be most ensconced. The proper cut of B for φ is cut≺(φ) = {ψ ∈ B | {χ ∈ B | ψ 4 χ } 6⊢ φ }. An ensconcement contraction operator ⊖4 for B is defined as: ψ ∈ B ⊖4 φ iff ψ ∈ B and either ⊢ φ or cut≺(φ) ∪ {¬φ} ⊢ ψ. An ensconcement revision operator ⊛4 for B is defined as: ψ ∈ B ⊛4 φ iff (i) ψ = φ or (ii) ψ ∈ B and either ⊢ ¬φ or cut≺(¬φ) ∪ {φ} ⊢ ψ. An ensconcement contraction operator ⊖4 satisfies (−1), (−2), and\n(−5) If φ 6∈ Cn(B), then B − φ = B (−6) If φ1 ≡ φ2, then B − φ1 = B − φ2 (−7) B − φ ∧ ψ = B − φ or B − φ ∧ ψ = B − ψ or B − φ ∧ ψ = B − φ ∩B − ψ (−8) If ψ ∈ B \\ (B − φ), then B − φ 6⊢ φ ∨ ψ\nTHEOREM 2.5. [Fermé et al. 2008] Let B be a belief base and ⊖4 an ensconcement contraction operator for B. Then ⊖4 satisfies (−1), (−2), and (−5)–(−8).1\nPostulates (−5), (−6), and (−8) correspond directly to (⊖3), (⊖6), and (⊖5de) in the AGM setting, respectively. (−7) states that a contraction by a conjuntion is the result of contracting by the first of the conjuncts, the result of contracting by the second of the conjuncts, or the common part of these two results. In the belief base framework, the relationship between (−3) and (−8) is different to the one between (⊖5r) and (⊖5de) in the AGM framework: (−3) implies (−8) but not vice versa [Fermé et al. 2008].\n1Please note that the proof of the representation theorem (Theorem 14 in [Fermé et al. 2008]) contains an error, as acknowledged by the authors. The theorem only holds in the direction from operator to postulates as stated above.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."
    }, {
      "heading" : "3. RELATED WORK",
      "text" : "One of the key developments for adapting the AGM framework of belief change to logic programs came with the distance-based approach to logic program revision [Delgrande et al. 2013]. It is built on the monotonic SE semantics for logic programs and understands a belief state as the set of SE models of a program. In that work, the formula-based revision postulates (⊛1KM)–(⊛6KM) are translated to logic programs as follows, where a revision operator ∗ is a function from LPA × LPA to LPA and the expansion of P by Q, denoted P ∔ Q, is understood as P ∔ Q = R such that R ∈ LPA and SE(R) = SE(P ) ∩ SE(Q).\n(∗1m) P ∗Q |=s Q (∗2m) If P ∔Q is satisfiable, then P ∗Q ≡s P ∔Q (∗3m) If Q is satisfiable, then P ∗Q is satisfiable (∗4m) If P1 ≡s P2 and Q1 ≡s Q2, then P1 ∗Q1 ≡s P2 ∗Q2 (∗5m) (P ∗Q)∔R |=s P ∗ (Q ∔R) (∗6m) If (P ∗Q)∔R is satisfiable, then P ∗ (Q ∔R) |=s (P ∗Q)∔R\nThe approach adapts two revision operators from classic belief change to logic programs, namely, Dalal’s revision operator [Dalal 1988] and Satoh’s revision operator [Satoh 1988]. Informally, to revise a program P by a program Q, the operators return those SE models from the set of SE models of Q that are closest to the SE models of P , where closeness is determined by Dalal’s or Satoh’s notion of distance. Delgrande et al. [2013] identified that the adaptation of Satoh’s revision operator gives more intuitive results than the adaptation of Dalal’s revision operator, so we will focus on the former here. This restriction has no effect on our later discussions. We briefly restate the definition and main result of the distance-based approach. Let ∆ stand for the symmetric difference between two sets X,Y , that is, X∆Y = (X \\ Y ) ∪ (Y \\X). For any two pairs of sets (X,X ′), (Y, Y ′), let\n(X,X ′)∆(Y, Y ′) = (X∆Y,X ′∆Y ′);\n(X,X ′) ⊆ (Y, Y ′) iff X ′ ⊆ Y ′, and if X ′ = Y ′, then X ⊆ Y ;\n(X,X ′) ⊂ (Y, Y ′) iff (X,X ′) ⊆ (Y, Y ′) and (Y, Y ′) * (X,X ′).\nFor any two sets E,E′, let\nσ(E,E′) = {A1 ∈ E | there exists a B1 ∈ E ′ such that for all A2 ∈ E\nand for all B2 ∈ E ′ it holds that A1∆B1 ⊆ A2∆B2 }.\nDEFINITION 3.1. [Delgrande et al. 2013] Let P,Q ∈ LPA. The revision of P by Q, denoted P ⋆ Q, is defined as P ⋆ Q = R such that R ∈ LPA and SE(R) = SE(Q) if SE(P ) = ∅, and otherwise\nSE(R) = { (X,Y ) | Y ∈ σ(Mod(Q),Mod(P )), X ⊆ Y,\nand if X ⊂ Y, then (X,Y ) ∈ σ(SE(Q), SE(P )) }.\nTHEOREM 3.1. [Delgrande et al. 2013] The revision operator ⋆ satisfies (∗1m)–(∗5m).\nThe distance-based approach was extended by two representation theorems [Delgrande et al. 2013; Schwind and Inoue 2013], stating that any logic program revision operator satisfying (∗1m)–(∗6m) plus some additional conditions can be characterised by some preorder over a set of SE models. Besides the distance-based approach, few other methods for logic program revision have been proposed. The screened semi-revision approach for logic programs [Krümpelmann and Kern-Isberner 2012] is based on answer set semantics and aligns itself with the belief base framework. The approach assumes a belief state to be the\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nset of rules belonging to a program and combines adaptations of the constructions of semi-revision [Hansson 1997] and screened revision [Makinson 1997] into a screened consolidation operation for logic programs. The consolidation operator first finds all maximal subsets of one program that are consistent with a second program under answer set semantics, then selects exactly one of these subsets, and returns this subset together with the second program as the outcome. We review the formal definitions of the screened consolidation operator and the main result here. Let P ∈ LPA and Q ⊆ P . The set of screened remainder sets of P with respect to Q is\nP⊥!Q = {R | Q ⊆ R ⊆ P,AS(R) 6= ∅ and for all R ′ with R ⊂ R′ ⊆ P : AS(R′) = ∅ }.\nA maxichoice selection function γP for P is a function such that for any Q ∈ LPA: (i) if P⊥!Q 6= ∅, then γP (P⊥!Q) = R for some R ∈ P⊥!Q, and (ii) if P⊥!Q = ∅, then γP (P⊥!Q) = P .\nDEFINITION 3.2. [Krümpelmann and Kern-Isberner 2012] Let P,Q ∈ LPA and γP be a maxichoice selection function for P . A screened consolidation operator !γP for P is defined as P !γPQ = γP (P⊥!Q).\nThe authors propose the following adaptation of partial meet base revision postulates that any screened consolidation operator ! should satisfy, where ! is a function from LPA × LPA to LPA, and show that !γP is exactly characterised by these postulates.\n(!1) Q ⊆ P !Q (!2) P !Q ⊆ P (!3) If r ∈ P \\ (P !Q), then AS(P !Q) 6= ∅ and AS(P !Q ∪ {r}) = ∅ (!4) If it holds for all P ′ ⊆ P that AS(P ′ ∪ Q) 6= ∅ iff AS(P ′ ∪ R) 6= ∅, then P ∩ ((P ∪ Q) !Q) = P ∩ ((P ∪R) !R) (!5) If there exists some P ′ such that Q ⊆ P ′ ⊆ P and AS(P ′) 6= ∅, then AS(P !Q) 6= ∅\nTHEOREM 3.2. [Krümpelmann and Kern-Isberner 2012] For any P ∈ LPA, !γP is a screened consolidation operator for P iff !γP satisfies (!1)–(!5).\nThe program-level approach to logic program revision [Delgrande 2010] is also based on answer set semantics and assumes the beliefs that make up a belief state to be the answer sets of a program. The revision operation relies on extending the standard answer set semantics to three-valued answer set semantics for determining the outcome. To revise a program P by a program Q, for each three-valued answer set X of Q, all maximal subsets R of P are selected such that X is a subset of each three-valued answer set X ′ of R ∪Q. The revision operation returns a set of answer sets that correspond to each X ′ as the result. In the author’s view, the AGM revision postulates (⊛3), (⊛4), (⊛7), and (⊛8) are inappropriate in the context of nonmonotonic semantics. An adaptation of the remaining postulates is fulfilled by the revision operation. The work of Zhuang et al. [2016] concerns itself with the revision of a disjunctive logic program by another. The authors observed that for a belief revision operator in a nonmonotonic setting, the task of inconsistency resolving can be done not only by removing old beliefs but also by adding new beliefs. Based on this observation, they proposed a variant of partial meet revision. For resolving the inconsistency between the original and the new beliefs, the variant obtains not only maximal subsets of the initial program that are consistent with the new one, but also minimal supersets of the initial program that are consistent with the new one. A representation theorem is provided. Since the idea of resolving inconsistency by adding new beliefs is beyond the classic AGM approach, some extra postulates are required to characterise the variant.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nInoue and Sakama [2004] argue that neither the set of answer sets nor the set of SE models of a program provide enough detail to revise a program. They illustrate that while two programs { a., b ← not a. } and { a. } have the same set of SE models, and thus the same set of answer sets, they should be treated differently during a revision operation, since b should be derived from the first program whenever the rule a. is discarded. We call this property preservation here. They further argue that revision operations should distinguish between two programs { a., b. } and { a., b ← a. }. While these two programs again share the same set of SE models, they too should not be interchangeable, since after a removal of the rule a., b should not be derived from the latter program any more. This property has become known as support [Slota and Leite 2013]. To address these two issues, Inoue and Sakama [2004] introduced a new notion of program equivalence that is stricter than strong equivalence, called C-update equivalence: any two programs P1, P2 ∈ LPA are C-update equivalent iff P1 \\ P2 ≡s P2 \\ P1. A relative of belief revision is belief update [Katsuno and Mendelzon 1992]. The difference between these two is usually understood in the way that belief revision addresses changes to a belief state brought about by some new information about a static world, whereas belief update covers changes to a belief state due to dynamics in the world described by the belief state. Similar to belief revision, the belief update framework prescribes a set of postulates that each rational update operator should satisfy and provides a construction that complies with it. A number of update operators for logic programs have been proposed, which differ greatly in the degree of alignment to the classic belief update framework. On the whole, these approaches rely predominantly on syntactic transformations of programs and return a set of answer sets instead of an updated program as the outcome. The landscape of update operators has already been reviewed exhaustively in other places, for example, detailed overviews are given by Delgrande et al. [2004] and Slota [2012]. Of interest in the current context is the exception-based update approach [Slota and Leite 2012], which introduces RE (robust equivalence) models as an extension of SE models. An RE model of a program P is any SE interpretation (X,Y ) such that X |= P Y . The authors regard a belief state as the collection of the sets of RE models of the rules in a program. In the update operation, exceptions in the form of RE models are added to those sets of RE models of the initial program that are incompatible with the RE models of the updating program. Incompatibilities between two sets of RE models are determined by differences in the truth values of atoms occurring in both sets. The update operator satisfies the majority of the update postulates adapted to logic programs. An ordered logic program is a tuple (P,<) such that P is a logic program and < is a preference ordering over the rules in P . Thus, it is conceivable to express the revision of P by Q as (P ∪ Q,<), where < is some appropriate preference ordering on P ∪ Q (from [Delgrande et al. 2007], for example), and employ one of the different semantics proposed [Brewka and Eiter 1999; Delgrande et al. 2003; Schaub and Wang 2003] to obtain the preferred answer sets of this ordered logic program. An ordered logic program can be transformed into a standard logic program, so that the preferred answer sets of the former are exactly the answer sets of the latter [Delgrande et al. 2003]. Yet, the transformed program may bear no syntactic relation to the original program. More importantly, an ordered logic program (P ∪ Q,<) may be inconsistent, i.e., may have no answer sets, even if P and Q themselves are consistent [Delgrande et al. 2004]. These characteristics make ordered logic programs rather unsuitable as a methodology for logic program belief change in general.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."
    }, {
      "heading" : "4. ADAPTING THE BELIEF CHANGE FRAMEWORKS",
      "text" : "Before we set out to define new constructions of logic program belief change, we translate the ideas of the classic belief change frameworks to the logic programming setting. We assume that a belief state is represented in the form of a program from LPA and new information to expand/revise/contract this program comes in the form of another program from LPA. Even though a consequence relation for logic programs under SE semantics exists [Eiter et al. 2004; Wong 2008], logic programs are per se not closed under logical consequence. Thus, it seems natural to align logic program belief change with the belief base framework. However, as the majority of previous approaches to logic program revision have focussed on adapting the AGM framework, we will consider it here as well to enable us to draw proper comparisons. As pointed out above, in the case of propositional knowledge bases the set of formulabased revision postulates (⊛1KM)–(⊛6KM) is equivalent to the set (⊛1)–(⊛8). However, in the context of logic programs, it is worth having a closer look at the relationship between these two sets. Besides adaptations for the purpose of logic program ‘update’ operations under answer set semantics [Eiter et al. 2002] or N2 logic [Osorio and Cuevas 2007], we find that postulates for logic program revision have usually been built on the formula-based revision postulates (⊛1KM)–(⊛6KM) until now [Delgrande et al. 2013; Delgrande et al. 2013; Schwind and Inoue 2013]. They are given in the form of (∗1m)–(∗6m) (see Section 3). We will now present a new set of postulates for logic program revision operators, based on the original AGM postulates (⊛1)–(⊛8), and then explain their relationship to (∗1m)–(∗6m). We will discover that the equivalence of the two sets of postulates under propositional logic does not carry over to logic programs, that, in fact, the adaptation of (⊛1)–(⊛8) to logic programs leads to postulates that are in most cases stricter than (∗1m)–(∗6m), since Q ⊆ P implies P |=s Q but the converse does not hold. Let P,Q,R ∈ LPA and a revision operator ∗ be a function from LPA×LPA to LPA. In the following, we understand expansion, denoted by the operator +, as P +Q = P ∪Q.\n(∗1) P ∗Q ∈ LPA (∗2) Q ⊆ P ∗Q (∗3) P ∗Q ⊆ P +Q (∗4) If P +Q is satisfiable, then P +Q ⊆ P ∗Q (∗5) P ∗Q is satisfiable iff Q is satisfiable (∗6) If Q ≡s R, then P ∗Q ≡s P ∗R (∗7) P ∗ (Q +R) ⊆ (P ∗Q) +R (∗8) If (P ∗Q) +R is satisfiable, then (P ∗Q) +R ⊆ P ∗ (Q+R)\n(∗1) is a basic but nonetheless crucial condition that is included in previous adaptations by the requirement that ∗ is a function from LPA × LPA to LPA. (∗2) stipulates that the revising program is always included in a revision outcome and is a stronger version of (∗1m) since (∗2) implies (∗1m) but not vice versa. (∗3) requires that a revision outcome never contains elements not in P or Q. This condition is covered by previous adaptations only for the case that P +Q is satisfiable in (∗2m). Together, (∗3) and (∗4) state that revision coincides with expansion if P+Q is satisfiable and thus imply (∗2m) but not vice versa. (∗5) is the stricter, biconditional version of (∗3m) emphasising the consistency of a revision outcome. (∗6) guarantees that revision by strongly equivalent programs leads to strongly equivalent results. Unlike belief sets, logic programs are not closed under logical consequence, so that we cannot expect from two different bodies of information that are merely strongly equivalent to be equal after a revision. Thus, the consequent is translated as “P ∗Q ≡s P ∗R” from the original postulate (⊛6). (∗4m) is stricter than (∗6). (∗7) and (∗8) capture the minimal change condition by re-\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nquiring that the revision of P by the expansion of Q with R has the same outcome as P ∗ Q expanded with R, whenever the latter is satisfiable. (∗7) and (∗8) imply (∗5m) and (∗6m) but not vice versa, respectively. A translation of the AGM contraction postulates to logic programs is listed below, where P,Q,R ∈ LPA and a contraction operator .− is a function from LPA × LPA to LPA.\n( .−1) P .−Q ∈ LPA ( .−2) P .−Q ⊆ P ( .−3) If P 6|=s Q, then P\n.−Q = P ( .−4) If 6|=s Q, then P\n.−Q 6|=s Q ( .−5) P ⊆ (P .−Q) +Q ( .−6) If Q ≡s R, then P\n.−Q = P .−R ( .−7) (P .−Q) ∩ (P .−R) ⊆ P .− (Q+R) ( .−8) If P .− (Q +R) 6|=s Q, then P .− (Q +R) ⊆ P .−Q\nAny contraction outcome is required to be a logic program by ( .−1) and a subset of the initial program by ( .−2). According to ( .−3), if the beliefs to be contracted are not implied by the initial belief state, then nothing is to be retracted. ( .−4) requires that the beliefs to be contracted are not implied by the contracted belief state, unless they are tautologies. ( .−5) states that all parts of the initial program P that are discarded in a contraction by Q can be recovered by a subsequent expansion with Q. ( .−6) ensures that contraction by strongly equivalent programs leads to the same outcomes. ( .−7) demands that any parts retained in both P .−Q and P .−R are also retained in P .−(Q+R). Whenever Q is not implied by the result of a contraction by Q + R, then ( .−8) states that this result is also retained in a contraction by Q alone. ( .−1), ( .−2), ( .−5), ( .−6), and ( .−7) are direct translations of (⊖1), (⊖2), (⊖5), (⊖6), and (⊖7), respectively. In the adaptation of (⊖3) to ( .−3), we use “P 6|=s Q” instead of “Q * P ”. Belief sets are closed under logical consequence, which means K ⊢ φ iff φ ∈ K, so that either can be used as the condition in (⊖3). However, for logic programs under SE semantics, we can conclude P |=s Q from Q ⊆ P but not Q ⊆ P from P |=s Q. Therefore, it is more appropriate to use “P 6|=s Q” than “Q * P ”, as P 6|=s Q implies Q * P . For the same reason is “P .−Q 6|=s Q” used instead of “Q * P\n.−Q” in ( .−4), and “P .− (Q +R) 6|=s Q” instead of “Q * P\n.− (Q +R)” in ( .−8). We now adapt the belief base revision postulates (>1)–(>5) to logic programs, where\nagain P,Q,R ∈ LPA and a revision operator ∗ is a function from LPA × LPA to LPA.\n(∗1b) Q ⊆ P ∗Q (∗2b) P ∗Q ⊆ P +Q (∗3b) If r ∈ P \\ (P ∗Q), then there exists a program P ′ such that P ∗Q ⊆ P ′ ⊂ P +Q and P ′ is satisfiable but P ′ ∪ {r} is not satisfiable (∗4b) If it holds for all P ′ ⊆ P that P ′ + Q is satisfiable iff P ′ + R is satisfiable, then P ∩ (P ∗Q) = P ∩ (P ∗R) (∗5b) If Q is satisfiable, then P ∗Q is satisfiable\nAll five postulates are direct translations of (>1)–(>5). We have (∗1b) = (∗2) and (∗2b) = (∗3). (∗3b) requires a rule r to be removed during a revision of P by Q if r contributes to making P irreconcilable with Q. (∗4b) states that if all subsets of P that agree with Q also agree with R, then the same elements of P will be retained in a revision by Q as in a revision by R. (∗5b) guarantees satisfiability of the revision result whenever the revising program itself is satisfiable. (∗4b) is a stronger version of (∗6) and (∗5b) is a weaker version of (∗5).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nFinally, we translate the belief base contraction postulates (−1)–(−8) to logic programs, where P,Q,R ∈ LPA and a contraction operator\n.− is a function from LPA × LPA to LPA. ( .−1b) P .−Q ⊆ P ( .−2b) If 6|=s Q, then P\n.−Q 6|=s Q ( .−3b) If r ∈ P \\ (P .−Q), then there exists a program P ′ such that P .−Q ⊆ P ′ ⊂ P and P ′ 6|=s Q but P ′ ∪ {r} |=s Q ( .−4b) If it holds for all P ′ ⊆ P that P ′ 6|=s Q iff P ′ 6|=s R, then P\n.−Q = P .−R ( .−5b) If P 6|=s Q, then P\n.−Q = P ( .−6b) If Q ≡s R, then P\n.−Q = P .−R ( .−7b) P .− (Q+R) = P .−Q or P .− (Q+R) = P .−R or P .− (Q+R) = (P .−Q)∩ (P .−R) ( .−8b) If r ∈ P \\ (P .−Q), then SE(P .−Q) * SE(Q) ∪ SE(r)\nThese postulates are direct translations of (−1)–(−8). We have ( .−1b) = ( .−2), ( .−2b) = ( .−4), ( .−5b) = ( .−3), and ( .−6b) = ( .−6). ( .−3b) requires a rule r to only be removed during the contraction of P by Q if r somehow contributes to implying Q. ( .−4b) states that if exactly those subsets of P that do not imply Q also do not imply R, then the same elements of P will be retained in a contraction by Q as in a contraction by R. As for revision, ( .−4b) is again a stronger version of ( .−6). ( .−7b) specifies that a contraction by two programs is the outcome of contracting the first program, the outcome of contracting the second program, or the intersection of these two outcomes. ( .−8b) stipulates that r should only be removed if the contracted program has at least one SE model that is not an SE model of Q or r. While the postulates (⊖5r) and (⊖5de) are equivalent in the presence of certain other postulates in the AGM framework for propositional logic, the relationship between the postulates ( .−3b) and ( .−8b) for logic programs is hierarchical, similar as in the belief base framework. Satisfaction of ( .−3b) implies satisfaction of ( .−8b) but not vice versa.\nPROPOSITION 4.1. Let .− be a contraction operator on LPA. If .− satisfies ( .−3b),\nthen it satisfies ( .−8b).\nThe other direction does not hold as evidenced later by Example 6.6. The Levi identity [Gärdenfors 1981; Levi 1977] allows us to construct a revision from a contraction and the Harper identity [Harper 1976] a contraction from a revision. In their propositional form, they use the classical negation of a sentence α to construct a revision/contraction by α. For logic programs, we do not have the classical negation of a program at at our disposal. However, we can abstractly represent the Levi and Harper identities for logic programs as follows, where Q ∈ LPA iff Q ∈ LPA and SE(Q) = SE(Q).\nDEFINITION 4.1. Let P,Q ∈ LPA. If ∗ is a revision operator for P and .− a contrac-\ntion operator for P , then\nP ∗Q = (P .−Q) +Q (Levi identity),\nP .−Q = P ∩ (P ∗Q) (Harper identity).\nWe adapted the AGM and belief base postulates to logic programs in such a way that the revising or contracting beliefs are entire programs, not just individual rules. We have thus essentially defined conditions for what is known in classic belief change as choice contraction [Fuhrmann andHansson 1994] and revision. In a choice contraction, a set of sentences may be contracted by either a single sentence or a set of sentences, for example, K ⊖ {φ, ψ}. Yet, since adapting the postulates that exactly characterise partial meet choice contractions would yield the postulates ( .−1b)–( .−3b) and ( .−6b), we do not have to pursue this distinction here further.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."
    }, {
      "heading" : "5. PARTIAL MEET BELIEF CHANGE",
      "text" : "Inspired by our motivation, we begin in this section with defining belief change operators for logic programs that preserve syntactic information, in order to take into account information on the program-level as well as on the rule-level. We first adapt the idea of a partial meet construction from classic belief change and formulate revision and contraction operators for logic programs. We utilise the translations of the AGM and belief base revision and contraction postulates from the previous section to test the rationality of our operators."
    }, {
      "heading" : "5.1. Partial Meet Revision",
      "text" : "As the basis for our construction of partial meet revision, we define a compatible set of some program with respect to another program as the dual of a remainder set [Alchourrón et al. 1985].\nDEFINITION 5.1 (COMPATIBLE SET). Let P,Q ∈ LPA. The set of compatible sets of P with respect to Q is\nPQ = {R ⊆ P |SE(R) ∩ SE(Q) 6= ∅ and, for all R ′,\nR ⊂ R′ ⊆ P implies SE(R′) ∩ SE(Q) = ∅ }.\nEach compatible set is a maximal subset of P that is consistent with Q under SE semantics. Each is thus a candidate to be returned together with Q as the outcome of a revision. To determine exactly which candidate(s) to choose, we employ a selection function. In the classic case, a selection function for a belief set is defined only over a set of remainder sets of that belief set (see Section 2.2). Since we plan to use our selection function for different types of sets, we define it freely with respect to an arbitrary set as follows.\nDEFINITION 5.2 (SELECTION FUNCTION). A selection function γ for a set S is a function such that:\n(1) S ⊆ 2S, (2) γ(S) ⊆ S, and (3) if S 6= ∅, then γ(S) 6= ∅.\nA special case of our selection function is the following single-choice selection function, which restricts the selection function γ to select at most one element of a set.\nDEFINITION 5.3 (SINGLE-CHOICE SELECTION FUNCTION). A single-choice selection function γ1 for a set S is a function such that:\n(1) S ⊆ 2S, (2) γ1(S) = R for some R ∈ S, and (3) if S 6= ∅, then γ1(S) 6= ∅.\nWe can now define partial meet revision for logic programs as the intersection of the selected compatible sets added to Q.\nDEFINITION 5.4 (PARTIAL MEET REVISION). Let P ∈ LPA and γ be a selection function for P . A partial meet revision operator ∗γ for P is defined such that for any Q ∈ LPA:\nP ∗γ Q =\n{\nP +Q if Q is not satisfiable, ⋂\nγ(PQ) +Q otherwise.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nWe illustrate the revision operation by an example. In the examples throughout this paper, we assume that the underlying language contains only the symbols that occur in the programs or that are otherwise mentioned explicitly.\nEXAMPLE 5.1. Let P = { a., b ← a. } and Q = {⊥ ← a. }. We have PQ = { { b ← a. } } = γ(PQ), for any selection function γ, and thus P ∗γ Q = { b ← a., ⊥ ← a. }.\nThe following theorem states which translated AGM revision postulates the revision operator ∗γ satisfies.\nTHEOREM 5.1. The revision operator ∗γ satisfies (∗1)–(∗6).\nAs in the classic case, to satisfy the supplementary revision postulates (∗7)–(∗8) we would need to place further restrictions on the selection function.\nDEFINITION 5.5 (RELATIONAL SELECTION FUNCTION). A transitively relational selection function γ′ for a set S is a selection function for S such that S ⊆ 2S and:\nγ′(S) =\n{\n∅ if S = ∅, {R ∈ S | R′ ✂R for all R′ ∈ S } otherwise,\nwhere ✂ is a transitive relation over 2S . The relation ✂ is maximised iff R ⊂ R′ implies R✁R′ for all R,R′ ∈ 2S .\nYet, even if we make these additional restrictions on a selection function γ′ for P , postulates (∗7) and (∗8) are not satisfied by ∗γ′, as shown respectively in the next two examples. For legibility, we confine the examples to abstract notation. Corresponding canonical logic programs can be constructed via the method provided by Eiter et al. [2013].\nEXAMPLE 5.2. Let P = {r1, r2, r3}with SE(r1) = {B,C}, SE(r2) = {A,C}, SE(r3) = {A,B,C}, and {r1, r3} ✂ {r2, r3} ✂ {r1, r3}. If SE(Q) = {A,B} and SE(Q + R) = {A}, then PQ = {{r1, r3}, {r2, r3}} and thus ⋂\nγ′(PQ) = {r3}. On the other hand, we have PQ+R = {{r2, r3}} = ⋂\nγ′(PQ+R). This means (P ∗γ′ Q) + R = {r3} ∪ Q ∪ R while P ∗γ′ (Q+R) = {r2, r3} ∪Q ∪R.\nEXAMPLE 5.3. Let P = {r1, r2, r3, r4, r5} with SE(r1) = {A,B,C,D,E}, SE(r2) = {A,B,C,E}, SE(r3) = {A,E}, SE(r4) = {B,E}, SE(r5) = {D,E}, and {r1, r2} ✁ {r1, r5} ✁ {r1, r2, r3}, {r1, r2, r4}. If SE(Q) = {A,B,C,D} and SE(Q + R) = {C,D}, then PQ = {{r1, r2, r3}, {r1, r2, r4}, {r1, r5}} and PQ+R = {{r1, r2}, {r1, r5}}. It follows from γ′(PQ) = {{r1, r2, r3}, {r1, r2, r4}} that ⋂\nγ′(PQ) = {r1, r2}, while γ′(PQ+R) = {{r1, r5}} = ⋂\nγ′(PQ+R). Therefore, (P ∗γ′ Q) +R = {r1, r2} ∪Q∪R * {r1, r5} ∪Q∪R = P ∗γ′ (Q+R). Note that SE((P ∗γ′ Q)+R) = SE( ⋂\nγ′(PQ))∩SE(Q+R) = {A,B,C,E}∩ {C,D} = {C} 6= ∅.\nOur partial meet revision operator does not satisfy the entire set of AGM revision postulates, only the subset of basic postulates (∗1)–(∗6). This stands in contrast to the result in classical logics, according to which any partial meet revision operator is characterised by the set of basic and supplementary revision postulates. However, that result holds for logically closed belief sets, and when we consider our partial meet revision operator ∗γ in the light of the belief base framework, we obtain the following representation theorem.\nTHEOREM 5.2. An operator ∗γ is a partial meet revision operator for P ∈ LPA determined by a selection function γ for P iff ∗γ satisfies (∗1b)–(∗5b).\nReturning to our motivation, we now give some formal examples to highlight the drawbacks of the distance-based revision operator and then show how our partial meet\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\noperator addresses these. Recall that the distance-based revision operator ⋆ does not specify the structure of the revised program. For convenience, we provide a possible program that corresponds to the revision outcome for each example below, which we denote by P ⋆ Q.\n1) P = { a., b ← a. } P ⋆ Q = {⊥ ← a., b. }\nQ = {⊥ ← a. } SE(P ⋆ Q) = {(b, b)}\n2) P = {⊥ ← a., b ← not a. } P ⋆ Q = { a., b. }\nQ = { a. } SE(P ⋆ Q) = {(ab, ab)}\n3) P = {⊥ ← a., b ← a. } P ⋆ Q = { a. }\nQ = { a. } SE(P ⋆ Q) = {(a, a), (a, ab), (ab, ab)}\n4) P = { a., b ← not a. } P ⋆ Q = {⊥ ← a. }\nQ = {⊥ ← a. } SE(P ⋆ Q) = {(∅, ∅), (∅, b), (b, b)}\n5) P = { a., b ← not c. } P ⋆ Q = { a., b., ⊥ ← c. }\nQ = {⊥ ← c. } SE(P ⋆ Q) = {(ab, ab)} Examples 1) and 2) demonstrate that the revision operator ⋆ does not satisfy the support property. In Example 1), the initial belief state expressed by program P consists of a and b. In fact, the second rule in P says that we believe b if we believe a. After revising by the program Q, which simply states that we do not believe a, we still believe b even though the reason to believe b is not given any more. The explanation for this is that the revision operator acts on a program-level, not on a rule-level, as it considers just the SE models of the program in its entirety. However, the dependency of b on a is not captured by the SE models of the program, only by the SE models of the second rule. Therefore, b is treated as an independent fact during the revision process. The situation is similar in Example 2). Here, we initially believe b due to the absence of belief a. After the revision, we continue to believe b even though the grounds for b do not exist any more. Examples 3) and 4) demonstrate that the revision operator ⋆ does not satisfy the preservation property. In Example 3), according to our initial belief state expressed by program P , we believe b whenever we believe a, but since we do not believe a currently, we are indifferent with respect to b at the moment. After revising by programQ, which states that we now believe a, we are still indifferentwith respect to b. In Example 4), we initially believe a and would believe b whenever we do not believe a or are indifferent with respect to a. After revising by Q, which carries the information that we do not believe a any longer, we are still indifferent with respect to b. In both examples, the revision operation effectively disregards the second rule in P . However, there is no justification for such behaviour, as the information in Q only conflicts with the first rule in P , so that the second rule in P can safely be retained and thus b should be derived in both examples. This behaviour is due to the fact that the set of SE models of P is exactly the set of SE models of the first rule. The second rule is invisible in the program-level view. Consequently, the revision operator returns a result as if P had consisted merely of the first rule. Finally, Example 4) stands in stark contrast to Example 5), where the revision operation coincides with expansion. In Example 5), we are indifferent with respect to b initially and should believe b when we do not believe c or are indifferent with respect to c. The revising program Q contains information that c indeed does not hold. Thus, b is incorporated into the new belief state. Yet, Example 4) described a similar scenario in which b is not included in the resulting belief state, thereby showing a clear discrep-\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nancy to the behaviour of the revision operator in Example 5). Since the set of SE models of the first rule of P in Example 5) is not a subset of the set of SE models of the second rule, the latter is preserved during the revision operation. It becomes apparent from this comparison that some dependencies between atoms expressed in P are respected by the revision operator ⋆, while others are not. We now show that our partial meet revision operator ∗γ addresses these shortcomings of the distance-based revision method. Below are the results of our partial meet revision operator for the five examples above. In each example, the result is independent of the choice of selection function.\n1) P ∗γ Q = {⊥ ← a., b ← a. }\nSE(P ∗γ Q) = {(∅, ∅), (∅, b), (b, b)}\n2) P ∗γ Q = { a., b ← not a. }\nSE(P ∗γ Q) = {(a, a), (a, ab), (ab, ab)}\n3) P ∗γ Q = { a., b ← a. }\nSE(P ∗γ Q) = {(ab, ab)}\n4) P ∗γ Q = {⊥ ← a., b ← not a. }\nSE(P ∗γ Q) = {(b, b)}\n5) P ∗γ Q = { a., b ← not c., ⊥ ← c. }\nSE(P ∗γ Q) = {(ab, ab)} In Examples 1) and 2), the partial meet revision operator preserves the dependency of b on a and not a, respectively. This is expressed on the syntactic level by the revised program P ∗γQ and on the semantic level by SE(P ∗γQ). In Examples 3) and 4), our partial meet revision operator takes into account all rules in a program, even those that may be “invisible” from a purely model-based perspective, as shown by the respective revision outcomes. Finally, regarding Examples 4) and 5), our partial meet revision operator treats the dependency of b on not a and not c, respectively, in the same manner and adds b to the belief state uniformly in both examples. The reason for this behaviour is that our partial meet construction enables us to preserve information expressed on the rule-level by the individual rules in a program. Revisiting our two real-life examples from the introduction, we can see that our partial meet revision operator returns the desired results. The first example (“fireworks”) was formalised as Example 3) above, where a = fog and b = no fireworks. Applying the revision operator ∗γ returns { fog., no fireworks ← fog. }, that is, it leaves us with the beliefs that it will be foggy and that there are no fireworks whenever it is foggy, from which we can derive that the fireworks will be cancelled. The second example (“101 or 280”) was formalised as Example 1), where a = 101 roadworks and b = 280 quicker. Applying the revision operator ∗γ to this example returns {⊥ ← 101 roadworks., 280 quicker ← 101 roadworks. }, that is, we believe that there are no roadworks on the 101 and that the 280 is quicker whenever there are roadworks on the 101, but not that the 280 is still the better choice. Regarding the screened semi-revision approach by Krümpelmann and KernIsberner [2012] (see Section 3), we can show that our partial meet revision operator ∗γ is a generalisation of their screened consolidation operator !γP . For any P,Q ∈ LPA with Q ⊆ P , let\nP⊥SE! Q = {R |Q ⊆ R ⊆ P, SE(R) 6= ∅, and, for all R ′,\nR ⊂ R′ ⊆ P implies SE(R′) = ∅ },\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nand P !SEγP Q = γP (P⊥ SE ! Q).\nPROPOSITION 5.1. Let P,Q ∈ LPA. For any maxichoice selection function γP for P , there exists a selection function γ for P such that (P ∪Q)!SEγP Q = P ∗γ Q.\nConversely, if we translate our partial meet revision operator ∗γ to answer set semantics and restrict our selection function to be single-choice, then it will coincide with the screened consolidation operator !γP . Before we can do so, we need to translate our definition of compatible sets to answer set semantics. For any P,Q ∈ LPA, let\nPASQ = {R ⊆ P |AS(R ∪Q) 6= ∅ and, for all R ′,\nR ⊂ R′ ⊆ P implies AS(R′ ∪Q) = ∅ }.\nDEFINITION 5.6 (PARTIAL MEET REVISION UNDER ANSWER SET SEMANTICS). Let P ∈ LPA and γ\n1 be a single-choice selection function for P . A partial meet revision operator ∗ASγ1 for P under answer set semantics is defined such that for any Q ∈ LPA:\nP ∗ASγ1 Q =\n{\nP ∪Q if AS(Q) = ∅ and PASQ = ∅, γ1(PASQ ) ∪Q otherwise.\nPROPOSITION 5.2. Let P,Q ∈ LPA and γ1, γP be single-choice and maxichoice selection functions, respectively, for P such that γ1(2P ) ∪ Q = γP ({R ∪ Q | R ∈ 2\nP }). Then P ∗ASγ1 Q = (P ∪Q)!γP Q."
    }, {
      "heading" : "5.2. Partial Meet Contraction",
      "text" : "Having defined a revision operator, we now turn to the case of belief contraction. In line with classic belief change, the contraction of a program P by a program Q should eliminate from P all those beliefs from which Q can be derived. We use the complement of SE(Q), denoted by SE(Q), to determine all maximal subsets of P that do not imply Q, called remainder sets.\nDEFINITION 5.7 (REMAINDER SET). Let P,Q ∈ LPA. The set of remainder sets of P with respect to Q is\nP−Q = {R ⊆ P |SE(R) ∩ SE(Q) 6= ∅ and, for all R ′,\nR ⊂ R′ ⊆ P implies SE(R′) ∩ SE(Q) = ∅ }.\nDEFINITION 5.8 (PARTIAL MEET CONTRACTION). Let P ∈ LPA and γ be a selection function for P . A partial meet contraction operator .−γ for P is defined such that for any Q ∈ LPA:\nP .−γ Q =\n{\nP if |=s Q, ⋂\nγ(P−Q) otherwise.\nThe following example demonstrates the contraction operation.\nEXAMPLE 5.4. Let P = { a., b ← a. } and Q = { a ← b. }. Since SE(Q) = {(∅, b), (b, b), (b, ab)}, SE({ a. }) = {(a, a), (a, ab), (ab, ab)}, and SE({ b ← a. }) = {(∅, ∅), (∅, b), (b, b), (∅, ab), (b, ab), (ab, ab)}, it follows that P−Q = { { b ← a. } } = γ(P − Q), for any selection function γ, and thus we obtain P .−γ Q = { b ← a. }.\nThe next theorem lists the translated AGM contraction postulates that are fulfilled by .−γ .\nTHEOREM 5.3. The contraction operator .−γ satisfies ( .−1)–( .−4) and ( .−6).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nIt is easy to see from Example 5.4 above that .−γ does indeed not satisfy ( .−5).\nIn the AGM framework, it is sufficient that the selection function γ is determined by a transitive relation so that ⊖ satisfies (⊖7). Here, we require the relation ✂ to be maximised as well to guarantee satisfaction of ( .−7). This is in line with the result for partial meet base contractions, which also require the underlying selection function to be determined by a maximised transitive relation in order to satisfy such a property [Hansson 1993].\nTHEOREM 5.4. Let γ′ be determined by a maximised transitive relation. The contraction operator .−γ′ satisfies ( .−7).\nThe following example demonstrates that .−γ′ does not satisfy ( .−8).\nEXAMPLE 5.5. Consider again P and ✂ from Example 5.3. If SE(Q) = {A,B,E}\nand SE(Q + R) = {E}, then SE(Q) = {C,D} and SE(Q+R) = {A,B,C,D}. We obtain P−Q+R = {{r1, r2, r3}, {r1, r2, r4}, {r1, r5}} and P − Q = {{r1, r2}, {r1, r5}}. It follows from γ′(P−Q+R) = {{r1, r2, r3}, {r1, r2, r4}} that ⋂ γ′(P−Q+R) = {r1, r2}, while γ ′(P−Q) = {{r1, r5}} and thus ⋂ γ′(P−Q) = {r1, r5}. Therefore, P .−γ′ (Q + R) = {r1, r2} * {r1, r5} = P .−γ′ Q. Note that SE(P .−γ′ (Q +R)) = SE( ⋂\nγ′(P−Q+R)) = {A,B,C,E} * {A,B,E} = SE(Q).\nAs in the case of our revision operator earlier, our partial meet contraction operator does not properly align with the AGM framework, but the following representation theorem holds for the contraction operator .−γ with respect to the belief base postulates.\nTHEOREM 5.5. An operator .−γ is a partial meet contraction operator for P ∈ LPA determined by a selection function γ for P iff .−γ satisfies ( .−1b)–( .−4b).\nBesides the representation theorem above via ( .−1b)–( .−4b), we have the following additional properties of .−γ regarding the remaining belief base contraction postulates ( .−5b)–( .−8b).\nPROPOSITION 5.3. The contraction operator .−γ satisfies ( .−5b), ( .−6b), and ( .−8b).\nThe next example illustrates that .−γ does not satisfy ( .−7b).\nEXAMPLE 5.6. Let P = {r1, r2, r3, r4} with SE(r1) = {A,B,C,D,E}, SE(r2) = {A,B,E}, SE(r3) = {A,C,E}, and SE(r4) = {C,D,E}. If SE(Q) = {A,D,E} and\nSE(R) = {B,C,E}, then SE(Q) = {B,C}, SE(R) = {A,D}, and SE(Q+R) = {A,B,C,D}. We thus have P−Q = {{r1, r2}, {r1, r3, r4}}, P − R = {{r1, r2, r3}, {r1, r4}}, and P−Q+R = {{r1, r2, r3}, {r1, r3, r4}}. Let γ(P − Q) = P − Q, γ(P − R) = P − R, and γ(P − Q+R) = P − Q+R. It then follows that ⋂\nγ(P−Q) = {r1}, ⋂ γ(P−R) = {r1}, and ⋂ γ(P−Q+R) = {r1, r3}. Therefore, P .−γ (Q +R) 6= P .−γ Q = P .−γ R = (P .−γ Q) ∩ (P .−γ R)."
    }, {
      "heading" : "6. ENSCONCEMENT BELIEF CHANGE",
      "text" : "In this section, we will introduce further belief revision and contraction operators for logic programs, which are based on an ordering over the beliefs contained in a program. We begin by defining an ensconcement relation for logic programs as follows.\nDEFINITION 6.1 (ENSCONCEMENT). Let P ∈ LPA. An ensconcement associated with P is any total preorder on P that satisfies the following conditions:\n( 1) For any r ∈ P : SE({ r′ ∈ P \\ {r} | r r′ }) 6⊂ SE(r) ( 2) For any r, r′ ∈ P : r r′ r iff {r} ≡s {r′}\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nPer this definition, an ensconcement associated with a logic program P is simply an ordering over the rules occurring in P . With P representing our entire set of beliefs, an ensconcement enables us to sort rules of P , which form our individual beliefs, hierarchically by their epistemic importance, or in other words, by how willing we are to give up one belief over another. Informally, r ≺ r′ means that the beliefs represented by r′ are more important to us than the beliefs represented by r. Condition ( 1) states that the set of SE models of any rule or combination of rules at least as ensconced as a given rule r may not be a proper subset of the set of SE models of r. Condition ( 2) requires that strongly equivalent rules are equally ensconced. Condition ( 1) is formulated slightly stronger than Condition (41) (see Section 2.2) from the original definition [Williams 1994]. Condition (41) allows a sentence ψ, that implies a sentence φ without being equivalent to φ, to be placed on the same ensconcement level as φ. In contrast, Condition ( 1) prohibits strict implication on the same ensconcement level. For instance, given rules a., a ← b., and a; b. contained in some program, both a ← b. and a; b. must be strictly more ensconced than a. according to Condition ( 1), whereas in a direct adaptation of Condition (41) at least one of the two rules a ← b. and a; b. would have to be equally ensconced as a.. The merit of this additional restriction will become evident shortly, when we show some examples of applying an ensconcement to perform revision operations in Section 6.1. The idea behind Condition (42) of the original definition is that any tautologies must be most ensconced, a requirement that is automatically captured in our Condition ( 1). Using the concept of logic program ensconcements, we now go on to define logic program revision and contraction operators and investigate their properties."
    }, {
      "heading" : "6.1. Ensconcement Revision",
      "text" : "During a revision operation, new information from a program Q is added to an initial belief state in the form of a program P , and some beliefs from P have to be given up to achieve a consistent outcome. When the beliefs in P are ordered by an ensconcement, we can introduce the notion of a cut to determine the specific level in the ensconcement where all beliefs on and above this level are consistent with the revising program. Since an ensconcement associated with P is a relation over all rules of P , when we write r r′, we implicitly mean r ∈ P and r′ ∈ P .\nDEFINITION 6.2 (CUT). Let P,Q ∈ LPA and be an ensconcement associated with P . The (proper) cut of P for Q, written cut (Q), is defined as\ncut (Q) = { r ∈ P | SE ({ r ′ ∈ P | r r′ }) ∩ SE(Q) 6= ∅ } .\nSome interesting properties of the cut are listed below.\nLEMMA 6.1. Let P,Q,R ∈ LPA and be an ensconcement associated with P .\na) If P +Q is satisfiable, then cut (Q) = P . b) If Q is satisfiable, then cut (Q) +Q is satisfiable. c) If Q is not satisfiable, then cut (Q) = ∅. d) If Q |=s R, then cut (Q) ⊆ cut (R). e) cut (Q+R) ⊆ cut (Q). f) If cut (Q) |=s R, then cut (Q+R) = cut (Q).\nA cut is the principal element for the following definition of an ensconcement revision operator.\nDEFINITION 6.3 (ENSCONCEMENT REVISION). Let P ∈ LPA and be an ensconcement associated with P . An ensconcement revision operator ∗ for P is defined such\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nthat for any Q ∈ LPA:\nP ∗ Q =\n{\nP +Q if Q is not satisfiable,\n{ r ∈ P | SE(cut (Q)) ∩ SE(Q) ⊆ SE(r) } +Q otherwise.\nThe revision operator ∗ retains all elements of the cut. This is an obvious requirement since the cut contains our most firmly held beliefs which are entirely consistent withQ. In addition, any rule of P not in the cut that shares the same SEmodels withQ as the cut is retained as well. The example below illustrates the operation.\nEXAMPLE 6.1. Let P = { a., a ← b., b ← a. } and Q = {⊥ ← b. }. Figure 1 shows all possible ensconcements associated with P , with rules displayed at the top being more ensconced than rules at the bottom. We have the following results:\n1. cut 1(Q) = { a ← b., b ← a. } and P ∗ 1 Q = { a ← b., b ← a., ⊥ ← b. } 2. cut 2(Q) = { a ← b., b ← a. } and P ∗ 2 Q = { a ← b., b ← a., ⊥ ← b. } 3. cut 3(Q) = { a ← b., b ← a. } and P ∗ 3 Q = { a ← b., b ← a., ⊥ ← b. } 4. cut 4(Q) = { a ← b. } and P ∗ 4 Q = { a ← b., ⊥ ← b. } 5. cut 5(Q) = { a ← b., a. } and P ∗ 5 Q = { a ← b., a., ⊥ ← b. }\nIn Example 6.1, the belief expressed by the combination of rules { a. } and { b ← a. } is inconsistent with the new information {⊥ ← b. }. Thus, at least one of these two rules must be discarded to reach a consistent belief state, while the rule { a ← b. } can be safely retained. The example shows that the revision operator ∗ indeed retains { a ← b. } in all cases and discards one or both other rules depending on their ensconcement level. Whenever { b ← a. } is more ensconced than { a. }, the latter is discarded and vice versa. Only when both rules are equally ensconced, that is, when we cannot make up our mind which the two beliefs we hold more firmly, the revision operator discards both. We can see from the definition of ∗ that the set of SE models of P ∗ Q is exactly the set of SE models that are shared by cut (Q) and Q.\nPROPOSITION 6.1. Let P,Q ∈ LPA and be an ensconcement associated with P . Then SE(P ∗ Q) = SE(cut (Q) +Q).\nThe next theorem states which of the adapted AGM revision postulates the revision operator ∗ satisfies.\nTHEOREM 6.1. The revision operator ∗ satisfies (∗1)–(∗6) and (∗8).\nThe revision operator ∗ does not satisfy (∗7), as shown in the next example.\nEXAMPLE 6.2. Let P = {r1, r2, r3}with SE(r1) = {B,C}, SE(r2) = {A,C}, SE(r3) = {A,B,C}, and be an ensconcement associated with P such that r1 r2 r1 ≺ r3. If SE(Q) = {A,B} and SE(Q + R) = {A}, then cut (Q) = cut (Q + R) = {r3}, yet (P ∗ Q) +R = {r3} ∪Q ∪R while P ∗ (Q +R) = {r2, r3} ∪Q ∪R.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nEven though ensconcement revision was originally defined for belief bases, our ensconcement revision operator ∗ satisfies the majority of AGM revision postulates for belief sets. Our operator does not satisfy any of the postulates that are unique to the belief base framework, as stated in the next theorem.\nTHEOREM 6.2. The revision operator ∗ satisfies (∗1b), (∗2b), and (∗5b).\nIn the following two examples, we illustrate that ∗ does indeed not satisfy (∗3b) and (∗4b), respectively.\nEXAMPLE 6.3. Let SE = {A,B,C,D}, SE(Q) = {A,B}, and P = {r1, r2, r3} with SE(r1) = {C,D}, SE(r2) = {B,C}, and SE(r3) = {A,B,C}. If is an ensconcement associated with P such that r1 r2 r1 ≺ r3, then cut (Q) = {r3} and P ∗ Q = {r3}+Q. While r2 ∈ P\\(P∗ Q), there exists no program P ′ such that P∗ Q ⊆ P ′ ⊆ P+Q and P ′ is satisfiable but P ′ ∪ {r2} is not satisfiable.\nEXAMPLE 6.4. Let SE = {A,B,C,D}, SE(Q) = {A,B}, SE(R) = {A}, and P = {r1, r2, r3} with SE(r1) = {C,D}, SE(r2) = {A,C}, and SE(r3) = {A,B,C}. If is an ensconcement associated with P such that r1 r2 r1 ≺ r3, then it holds for any P ′ ⊆ P that P ′+Q is satisfiable iff P ′+R is satisfiable. However, we have cut (Q) = {r3} and P ∩ (P ∗ Q) = {r3}, while cut (R) = {r3} and P ∩ (P ∗ R) = {r2, r3}.\nWe will now examine the behaviour of our ensconcement revision operator with respect to the set of five examples from Section 5.1. In each example, the revision outcome is independent of the possible ensconcements that can be associated with P .\n1) P ∗ Q = {⊥ ← a., b ← a. }\nSE(P ∗ Q) = {(∅, ∅), (∅, b), (b, b)}\n2) P ∗ Q = { a., b ← not a. }\nSE(P ∗ Q) = {(a, a), (a, ab), (ab, ab)}\n3) P ∗ Q = { a., b ← a. }\nSE(P ∗ Q) = {(ab, ab)}\n4) P ∗ Q = {⊥ ← a., b ← not a. }\nSE(P ∗ Q) = {(b, b)}\n5) P ∗ Q = { a., b ← not c., ⊥ ← c. }\nSE(P ∗ Q) = {(ab, ab)} For all five examples, the ensconcement revision operator ∗ returns the same desired results as the partial meet revision operator ∗γ . Examining in particular Examples 3) and 4), it now becomes evident why we diverted in our formulation of Condition ( 1) from the classic definition. Condition ( 1) prohibits strict implication on the same ensconcement level. Without this refined requirement, for Example 3) we could construct an ensconcement associated with P such that ⊥ ← a. b ← a. ⊥ ← a., which would give us the outcome P ∗ Q = { a. }. For Example 4), we could construct an ensconcement associated with P such that a. b ← not a. a., which would lead to the outcome P ∗ Q = {⊥ ← a. }. These revision outcomes would correspond exactly to the undesired results of the distance-based revision operator ⋆, which we set out to avoid because they disrespect the preservation property."
    }, {
      "heading" : "6.2. Ensconcement Contraction",
      "text" : "We now use the concept of an ensconcement to present another contraction operator for logic programs. Analogous to revision, we first define for some P,Q ∈ LPA and an\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nensconcement associated with P that\ncut− (Q) = { r ∈ P | SE ({ r ′ ∈ P | r r′ }) ∩ SE(Q) 6= ∅ }.\nSome useful properties of cut− (Q) are listed here.\nLEMMA 6.2. Let P,Q,R ∈ LPA.\na) If P 6|=s Q, then cut − (Q) = P . b) If 6|=s Q, then cut − (Q) 6|=s Q. c) If |=s Q, then cut − (Q) = ∅. d) If Q |=s R, then cut − (R) ⊆ cut − (Q). e) cut− (Q) ⊆ cut − (Q+R).\nf) If cut− (Q) |=s R, then cut − (Q+R) = cut − (Q).\ng) If cut− (Q) 6|=s R, then cut − (Q+R) = cut − (R).\nDEFINITION 6.4 (ENSCONCEMENT CONTRACTION). Let P ∈ LPA and be an ensconcement associated with P . An ensconcement contraction operator .− for P is defined such that for any Q ∈ LPA:\nP .− Q =\n{\nP if |=s Q, { r ∈ P | SE(cut− (Q)) ∩ SE(Q) ⊆ SE(r) } otherwise.\nThe contraction operator .− works in a dual way to the revision operator ∗ . It relies on cut− (Q) to determine from which level upward in the ensconcement associated\nwith P elements are retained in the operation, and adds any further parts of P that do not compromise the set of SE models of cut− (Q) inconsistent with Q.\nWe can formalise the relationship between the SE models of P .− Q and cut − (Q) as\nfollows.\nPROPOSITION 6.2. Let P,Q ∈ LPA and be an ensconcement associated with P . Then SE(P .− Q) ∩ SE(Q) = SE(cut − (Q)) ∩ SE(Q).\nThe contraction operator .− satisfies all AGM contraction postulates except Recovery.\nTHEOREM 6.3. The contraction operator .− satisfies ( .−1)–( .−4) and ( .−6)–( .−8).\nThe next example shows why .− does not satisfy the Recovery postulate ( .−5).\nEXAMPLE 6.5. Consider again P and Q from Example 5.4. For any ensconcement associated with P , it holds that P\n.− Q = { b ← a. }. Thus, P = { a., b ← a. } * { b ← a., a ← b. } = (P .− Q) +Q.\nThe main reason for non-satisfaction of Recovery is that our ensconcement contraction operator .− operates on programs that are not logically closed, and Recovery is a key AGM postulate that characterises contractions of logically closed belief sets. On the other hand, our ensconcement contraction operator satisfies the same set of belief base postulates as its classic counterpart.\nTHEOREM 6.4. The contraction operator .− satisfies (−1b), (−2b) and (−5b)–(−8b).\nThe following two examples demonstrate that the contraction operator .− does not satisfy ( .−3b) and ( .−4b), respectively.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nEXAMPLE 6.6. Let SE = {A,B,C,D}, SE(Q) = {C}, and consider again P and from Example 6.3. Then cut− (Q) = {r3} = P .− Q. While r2 ∈ P \\ (P .− Q), there exists no program P ′ such that P .− Q ⊆ P ′ ⊆ P and P ′ 6|=s Q but P ′ ∪ {r2} |=s Q.\nEXAMPLE 6.7. Let SE = {A,B,C,D}, SE(Q) = {C}, SE(R) = {B,C}, and consider again P and from Example 6.4. Then it holds for any P ′ ⊆ P that P ′ 6|=s Q iff P ′ 6|=s R. However, we have cut − (Q) = {r3} and P .− Q = {r3}, while cut − (R) = {r3} and P .− R = {r2, r3}."
    }, {
      "heading" : "7. CONNECTIONS BETWEEN THE OPERATORS",
      "text" : "Having defined partial meet revision and contraction operators and ensconcement revision and contraction operators in the previous sections, we now establish the formal connections between them. We first relate partial meet revision to ensconcement revision and partial meet contraction to ensconcement contraction. We then investigate whether the granularity of ensconcements, that is, whether an ensconcement is defined over rules or subsets of a program, influences that relationship. Finally, we connect partial meet revision to partial meet contraction and ensconcement revision to ensconcement contraction via the Levi and Harper identities."
    }, {
      "heading" : "7.1. Relating Partial Meet Operators to Ensconcement Operators",
      "text" : "We already saw from the set of postulates that ∗ and ∗γ satisfy, that partial meet revision and ensconcement revision share similar properties. In the following characterisation theorem we state the exact relationship between the two.\nTHEOREM 7.1. Let P,Q ∈ LPA. For any selection function γ, there exists an ensconcement associated with P such that P ∗γ Q = P ∗ Q.\nTheorem 7.1 asserts that ∗γ can be characterised in terms of ∗ . The other direction is not possible, as shown in the example below.\nEXAMPLE 7.1. Let P = { a., b., c. }, Q = {⊥ ← a. }, and be the ensconcement associated with P as shown in Figure 2. It follows that cut (Q) = { c. } and P ∗ Q = { c., ⊥ ← a. }. Yet PQ = { { b., c. } } = γ(PQ), for any selection function γ, so that P ∗γQ = { b., c., ⊥ ← a. }. We have P ∗ Q 6= P ∗γ Q.\nOn the one hand, the requirement SE(cut (Q)) ∩ SE(Q) ⊆ SE(R) in Definition 6.3 requires any subset R of P that is not part of the cut to have all SE models shared by the cut and Q, in order to be included in the revision outcome. In the previous example, the SE models shared by the cut and Q are (c, c), (c, bc), and (bc, bc). Since (c, c) 6∈ SE({ b. }) (and also (c, bc) 6∈ SE({ b. })), it follows that { b. } * P ∗ Q. On the other hand, the definition of partial meet revision is based on compatible sets, which are required to be maximal and to share only a minimum of one SE model with Q (Definition 5.1). This requirement limits the result of a partial meet revision for this example to the one above, regardless of the the type of selection function employed. We also find that the partial meet contraction operator .−γ can be characterised in terms of the ensconcement contraction operator .− , formalised in the next theorem.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nTHEOREM 7.2. Let P,Q ∈ LPA. For any selection function γ, there exists an ensconcement associated with P such that P .−γ Q = P .− Q.\nThe other direction of this theorem does not hold. Consider again P and from Example 7.1 and let Q = { a. }. It is easy to see that P .−γ Q 6= P\n.− Q, for any selection function γ."
    }, {
      "heading" : "7.2. Granularity of Ensconcements",
      "text" : "For our partial meet construction, we determined the outcome of a revision or contraction operation by employing a function that selects among subsets of a program. For our ensconcement construction, we then used an ordering over individual rules of a program to select the rules to retain during a revision or contraction operation. Given the Characterisation Theorems 7.1 and 7.2 that hold only in one direction, it is worth investigating whether this difference in granularity, subsets or rules, plays a critical role in determining revision or contraction outcomes. To do so, we will now consider program subsets as the objects of change for our ensconcement revision and contraction operators. We begin with the definition of an ensconcement over subsets of a program.\nDEFINITION 7.1 (ENSCONCEMENT OVER SUBSETS). Given P ∈ LPA, a subsetensconcement associated with P is any total preorder R on 2P that satisfies the following conditions:\n( R1) For any R ⊆ P : SE({R′ ⊆ P \\R | R R′ }) 6⊂ SE(R) ( R2) For any R,R′ ⊆ P : R R′ R iff R ≡s R′\nWe define revision and contraction operators based on R as follows.\nDEFINITION 7.2 (SUBSET-ENSCONCEMENT REVISION). Let P ∈ LPA and R be a subset-ensconcement associated with P . A subset-ensconcement revision operator ∗ R for P is defined such that for any Q ∈ LPA:\nP ∗ R Q =\n{\nP +Q if Q is not satisfiable,\n{R ⊆ P | SE(cut R(Q)) ∩ SE(Q) ⊆ SE(R) }+Q otherwise,\nwhere cut R(Q) = {R ⊆ P | SE ({R ′ ⊆ P | R R′ }) ∩ SE(Q) 6= ∅ }.\nDEFINITION 7.3 (SUBSET-ENSCONCEMENT CONTRACTION). Let P ∈ LPA and R be a subset-ensconcement associated with P . A subset-ensconcement contraction operator .− R for P is defined such that for any Q ∈ LPA:\nP .− R Q =\n{\nP if |=s Q, {R ⊆ P | SE(cut− R (Q)) ∩ SE(Q) ⊆ SE(R) } otherwise,\nwhere cut− R(Q) = {R ⊆ P | SE ({R ′ ⊆ P | R R′ }) ∩ SE(Q) 6= ∅ }.\nIt turns out that it does not matter whether an ensconcement over subsets of a program or only over the individual rules is used to determine a revision or contraction outcome, provided that the individual rules are ordered in the same way in both ensconcements, as stated in the following theorem.\nTHEOREM 7.3. Let P,Q ∈ LPA, be an ensconcement associated with P , and R a subset-ensconcement associated with P such that {r} R {r′} iff r r′ for all r, r′ ∈ P . Then P ∗ Q = P ∗ R Q (or P .− Q = P .− R Q, alternatively).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000."
    }, {
      "heading" : "7.3. Relating Revision Operators to Contraction Operators",
      "text" : "We now formalise the connection between partial meet revision and partial meet contraction with the help of the Levi and Harper identities as given in Definition 4.1.\nPROPOSITION 7.1. Let P ∈ LPA, γ be a selection function for P , and ∗ an operator for P such that for any Q ∈ LPA: P ∗Q = (P .−γ Q) +Q. Then P ∗Q = P ∗γ Q.\nPROPOSITION 7.2. Let P ∈ LPA, γ be a selection function for P , and .− an operator\nfor P such that for any Q ∈ LPA: P .−Q = P ∩ (P ∗γ Q). Then P .−Q = P .−γ Q.\nThe characterisation via Levi and Harper identities also holds for ensconcement revision and ensconcement contraction.\nPROPOSITION 7.3. Let P ∈ LPA, be an ensconcement associated with P , and ∗ an operator for P such that for anyQ ∈ LPA: P ∗Q = (P .− Q)+Q. Then P ∗Q = P ∗ Q.\nPROPOSITION 7.4. Let P ∈ LPA, be an ensconcement associated with P , and .−\nan operator for P such that for anyQ ∈ LPA: P .−Q = P∩(P ∗ Q). Then P .−Q = P .− Q."
    }, {
      "heading" : "8. LOCALISED BELIEF CHANGE",
      "text" : "In Sections 5 and 6, we introduced two new sets of belief change operators for logic programs. While the definitions of our operators are based on classic declarative constructions, such formulations may not be optimal for practical implementations. In particular, the formation of a set of compatible sets to conduct a partial meet revision or contraction requires that all possible combinations of all rules in a program are evaluated with respect to their sets of SE models. When dealing with logic programs that contain a large number of rules, where only a small number of them are actually affected by the change operation, this procedure entails unreasonable costs. In this section, we present an algorithm to minimise these costs. We begin by identifying the subsets of a program, called modules, relevant to another program.\nDEFINITION 8.1 (MODULE). Let P ∈ LPA and a ∈ A. For any rule r ∈ P with a ∈ At(r), we recursively construct M(P )ri |a as\n{r} ∪ { r′ ∈ P | At(r′) ∩ ( At(r) ∪At(M(P )ri−1|a) ) \\ {a} 6= ∅ }\nfor i > 0 and M(P )r0|a = ∅. Since P is finite and M(P )ri |a is monotonic with respect to i, the sequence ⋃∞ i=0 M(P ) r i |a will reach a fixpoint. We denote the fixpoint by M(P )\nr|a and call it the module of P related to r including a (or the r-module including a, if P is clear from the context).\nEXAMPLE 8.1. Let r1: a., r2: b ← a., r3: c ← not b., and P = {r1, r2, r3}. The modules that can be constructed from P are: M(P )r1 |a = {r1},M(P )r2 |a = {r2, r3},M(P )r2|b = {r1, r2},M(P )r3|b = {r3}, and M(P )r3 |c = {r1, r2, r3}.\nStarting with a given atom a and a given rule r from P , the recursive definition first finds all rules in P that share atoms with r except for a. Then it finds all rules in P that share atoms with r or any of the rules found in the first step except for a, and so on. It does not matter whether atoms appear in the head or the body of a rule, or whether they occur with or without default negation. The resulting module is the collection of rules in P that are related to r through shared atoms. The reason for excluding a will become clear after the following definition of a set of relevant modules.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nDEFINITION 8.2 (RELEVANT MODULE). Let P ∈ LPA. Given an atom a ∈ A, we define the set of all modules of P including a as:\nM(P )|a = {M(P ) r|a | r ∈ P and a ∈ At(r) }.\nGiven Q ∈ LPA, we define the set of all modules of P relevant to Q as:\nM(P )|Q = {M(P ) r|a | r ∈ P and a ∈ At(r) ∩ At(Q) }.\nEssentially, the definition of a set of modules extracts those rules from a program that may be affected during a revision or contraction by another program. It thus aims for the same goal as the language-splitting technique in propositional logic [Parikh 1999], which splits a knowledge base into several partitions either relevant or irrelevant to a belief change. However, a distinct feature in the previous definitions is the construction of a module based on each rule in which a certain atom occurs. This feature allows us to get a closer look at which rules may conflict with some given information. Consider the program { a ← b., ⊥ ← b. }. If we were to add the information that “b holds” to this program, it would conflict with the latter rule but not with the first one. By creating a module for each occurrence of b, we split the program into two modules (one for each rule) and can assess the compatibility of each module with the new information separately. This also separates our approach from the method to compute compartments [Hansson and Wassermann 2002; Wassermann 2000]. That method assumes a graph representation of a belief base, where each sentence of the belief base is a node and edges connect sentences that share at least one atom. The parts of a belief base relevant to a given sentence φ for a change operation are the sentences that can be reached from φ. Thus, it does not distinguish between occurrences of φ as in our method. Furthermore, our method constructs modules for each individual atom occurring in Q and thus ensures that we are dealing with minimal units of P in a change operation. Obviously, a module may not be unique to a certain rule or a certain given atom so that modules may overlap or coincide. We say that a set of rules R conflicts with some program Q if SE(R)∩SE(Q) = ∅. All rules of P that conflict with Q are included in some module or combination of modules from M(P )|Q.\nPROPOSITION 8.1. Let P,Q ∈ LPA and SE(P ) 6= ∅ 6= SE(Q). For any R ⊆ P , if SE(R) ∩ SE(Q) = ∅ and for all R′ ⊂ R it holds that SE(R′) ∩ SE(Q) 6= ∅, then there exists M ∈ 2M(P )|Q such that R ⊆ ⋃ M.\nCOROLLARY 8.1. Let P,Q ∈ LPA and SE(P ) 6= ∅. Then SE(P ) ∩ SE(Q) = ∅ if and only if SE ( ⋃\nM(P )|Q) ∩ SE(Q) = ∅.\nWe are now ready to introduce an optimisation algorithm for logic program revision and contraction based on modules. Algorithm 1 resolves potential conflicts for all possible combinations of modules by applying revision or contraction on a modular level. It performs a bottom-up construction by first taking all 1-combinations (singleton sets of modules) of M and substituting a module with its changed version if they are not the same. It then takes all 2-combinations of M, which may now contain some changed modules, and replaces each module of the combination with the changed version of the combination if required. Replacing each module of a combination with the outcome guarantees that the algorithm considers all possible combinations. The algorithm terminates after handling the combination of all modules in M. The algorithm performs |M||M|/2 operations in the worst case, so its complexity is exponential. Since the formation of PQ or P − Q requires |2 P ||2 P |/2 operations in the worst case, the algorithm performs better whenever |M| is less than |2P |.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nALGORITHM 1: MODCHANGE\nInput: a set M of modules, an operator ◦, a program Q Output: the set M of changed modules n ← 1; while n ≤ |M| do\nforeach M ⊆ M such that |M| = n do if ◦ is a revision operator and SE( ⋃ M) ∩ SE(Q) = ∅ then\nforeach M ∈ M do replace M with ( ⋃ M ◦Q) \\Q in M; end\nelse if ◦ is a contraction operator and SE( ⋃\nM) ∩ SE(Q) = ∅ then foreach M ∈ M do\nreplace M with ⋃\nM ◦Q in M; end\nend n ← n+ 1;\nend return M;\nThe next theorem states that the algorithm MODCHANGE reduces a partial meet revision or contraction operation on a logic program to the revision or contraction operation on the relevant subsets of that program, given a suitable selection function γ. In the following, let P \\M(P )|Q = { r ∈ P | for all M ∈ M(P )|Q : r 6∈ M } and M(P )|◦Q denote the output of Algorithm 1 for the inputs M(P )|Q, ◦ ∈ {∗γ , .−γ , ∗ , .− }, and Q.\nTHEOREM 8.1. For any P,Q ∈ LPA, there exists a selection function γ for P such that P ∗γ Q = P \\M(P )|Q + ⋃ M(P )| ∗γ Q + Q (or P .−γ Q = P \\M(P )|Q + ⋃ M(P )| .−γ Q , respectively).\nThe reason why Theorem 8.1 does not hold for any arbitrary selection function is that during the operation of MODCHANGE a selection function chooses from subsets of modules, while it chooses from subsets of a program during the operation of ∗γ per Definition 5.4 ( .−γ per Definition 5.8, respectively). Consequently, the result of the former operation may not in all cases correspond to the result of the latter operation. We have already established in Theorems 7.1 and 7.2 that ∗γ and\n.−γ can be characterised in terms of ∗ and\n.− , respectively. Therefore, we can directly extend Theorem 8.1 to ensconcement revision and contraction.\nCOROLLARY 8.2. For any P,Q ∈ LPA, there exists an ensconcement associated with P such that P ∗ Q = P \\M(P )|Q + ⋃ M(P )| ∗ Q +Q (or P\n.− Q = P \\M(P )|Q + ⋃\nM(P )| .− Q , respectively)."
    }, {
      "heading" : "9. DISCUSSION",
      "text" : "From our investigations in the previous sections, we can extract two main findings. Firstly, the belief change operators for logic programs that we proposed here are able to address the unintuitive behaviour of the distance-based approach. The latter takes a holistic, program-level view on logic programs and their revisions, by assuming a belief state to be the set of SE models of the entire program. Due to its focus on the program-level, the distance-based approach neglects information about relationships between atoms that is only captured on the rule-level, by the individual rules of a program, and therefore violates the properties of preservation and support.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nFor our approach, we adapted partial meet and ensconcement constructions, which allowed us to define operators that are more sensitive with respect to the information expressed by the individual rules of a program. In particular, we considered the rules of a program in their syntactic form as a belief state and thus as the objects of change, which made it possible to preserve necessary information on the syntactic level during a change operation. This characteristic turned out to be key for satisfying the preservation and support properties. It should be noted, however, that our operators are still model-based and not purely syntactic operators. Our operators rely on satisfaction defined under SE model semantics to determine compatible sets, remainder sets, ensconcements, and cuts, not on syntactic transformations of program components. Rather, our operators bridge the gap between purely semantic and purely syntactic methods, which is why we call them syntax-preserving. Secondly, we found that our operators fit properly into the belief base framework for belief change. Tables I, II, III, and IV provide an overview of the postulates that are satisfied by each operator. Our partial meet revision operator ∗γ satisfies all basic AGM revision postulates (∗1)–(∗6). However, the partial meet revision operator does not satisfy the supplementary postulates (∗7)–(∗8), even with further restrictions on the selection function, which allow operators under propositional logic to satisfy the supplementary postulates. A similar situation exists for our partial meet contraction operator .−γ . The partial meet contraction operator satisfies all basic postulates (\n.−1)– ( .−6) with the exception of the controversial Recovery postulate ( .−5). It satisfies ( .−7) but not ( .−8) of the supplementary postulates when the selection function is restricted to be determined by a maximised transitive relation. On the other hand, evaluating our partial meet revision and contraction operators with respect to the belief base postulates showed that they exhibit the same characteristics as the partial meet base revision and contraction operators for propositional logic [Hansson 1993]. The partial meet revision operator is represented by (∗1b)–(∗5b) (Theorem 5.2) and the partial meet contraction operator by ( .−1b)–( .−4b) (Theorem 5.5), and thus both operators fit neatly into the belief base framework.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nOur ensconcement revision operator .− satisfies the same basic AGM postulates (∗1)–(∗6) as our partial meet revision operator and in addition (∗8), but also disrespects (∗7). Our ensconcement contraction operator .− satisfies all AGM postulates ( .−1)–( .−8) with the exception of ( .−5). Since an ensconcement-based construction is essentially geared towards belief bases [Williams 1994], our ensconcement operators should align well with the belief base framework. Indeed, our ensconcement contraction operator .− satisfies the same set of belief base postulates as its counterpart for propositional logic [Fermé et al. 2008], that is, ( .−1b), ( .−2b), and ( .−5b)–( .−8b). As the classic belief base revision postulates (>1)–(>5) have originally been proposed to characterise partial meet base revision operations, their applicability to characterise ensconcement revision operations is limited. It would be interesting for future work to define a set of belief base revision postulates that can exactly characterise ensconcement revision operations. Until then, we can use our adaptation of the Harper identity to show that any ensconcement contraction operator determined by our ensconcement revision operator ∗ satisfies (\n.−1b), ( .−2b), and ( .−5b)–( .−8b). It is now left to examine how our operators compare to the distance-based operator in terms of the AGM and belief base postulates. Tables V and VI display the postulates satisfied by the distance-based operator ⋆. We can see that both our partial meet revision operator ∗γ and our ensconcement revision operator ∗ are better-behaved than ⋆ on the scale of AGM postulates as well as on the scale of belief base postulates. It should be noted, however, that ⋆ satisfies (∗4m), which has a stricter antecedent than (∗6), but neither ∗γ nor ∗ satisfies (∗4m)."
    }, {
      "heading" : "10. CONCLUSION",
      "text" : "In this work, we presented two new constructions of belief change in logic programs. Our specific aim was to overcome the drawbacks of existing semantic revision operators, namely, that they do not satisfy the properties of preservation and support. These are fundamental properties for a logic program belief change operator to return intuitive results. For this purpose, we chose to adapt partial meet and ensconcement constructions from classic belief change, which allowed us to define syntax-preserving belief change operators for logic programs that satisfy preservation and support. Our approach is novel in that the partial meet and ensconcement constructions not only enabled our operators to preserve more information from a logic program during a change operation than purely semantic operators, but they also facilitated natural definitions of contraction operators for logic programs, the first in the field to the best of our knowledge. In order to evaluate the rationality of our operators, we translated the revision and contraction postulates from the classic AGM and belief base frameworks to logic programs. We established that our operators fit properly within the belief base framework and showed their interdefinability. We also demonstrated that our operators align more closely to the AGM and belief base frameworks than the distance-based revision operators and that they generalise the screened semi-revision operator. We further presented an algorithm to optimise our revision and contraction operations.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nIn future work, we aim to develop and implement an algorithm for constructing the relevant modules of a program. While our partial meet and ensconcement operators specify how a program changes during a revision or contraction operation, they do not specify how the associated selection function or ensconcement relation changes. A selection function or ensconcement is associated with a program before the change operation. During the change operation, some rules may be discarded from the program and some new rules may be added to it in the case of revision, and any effects on the initial selection function or ensconcement or entrenchment should be taken into consideration. Such an extension to our approach would be worthwhile to pursue in the future."
    }, {
      "heading" : "APPENDIX: PROOFS",
      "text" : "PROPOSITION 4.1: Let .− be a contraction operator on LPA. If .− satisfies ( .−3b), then it satisfies ( .−8b).\nPROOF. Proof by contrapositive: Let r ∈ P \\ (P .−Q). Assume SE(P .−Q) ⊆ SE(Q)∪ SE(r). Then for all P ′ such that P .− Q ⊆ P ′ ⊆ P with SE(P ′) * SE(Q): SE(P ′) ∩ SE(r) * SE(Q), due to the assumption and due to SE(P ′) ⊆ SE(P .−Q).\nTHEOREM 5.1: The revision operator ∗γ satisfies (∗1)–(∗6).\nPROOF. (∗1): Follows directly from Definition 5.4. (∗2): Follows directly from Definition 5.4. (∗3): If Q is not satisfiable, then P ∗γ Q = P +Q. Otherwise, since ⋂\nγ(PQ) ⊆ P we have ⋂\nγ(PQ) +Q ⊆ P +Q. (∗4): If P + Q is satisfiable, then PQ = {P} = γ(PQ), for any selection function γ, and thus P ∗γ Q = P +Q. (∗5): If Q is not satisfiable, then P ∗γ Q = P + Q is not satisfiable. If Q is satisfiable, then for any R ∈ PQ, R+Q is satisfiable, which implies P ∗γ Q is satisfiable. (∗6): Follows directly from Definition 5.4.\nLEMMA A.1. Let P,Q ∈ LPA and γ be a selection function for P . If r ∈ P ∩Q, then r ∈ ⋂\nγ(PQ).\nPROOF. Let P,Q ∈ LPA. Assume there exists r ∈ (P ∩ Q) \\ ( ⋂\nγ(PQ)). Then there existsR ∈ γ(PQ) : r 6∈ R. It follows that SE(R∪{r})∩SE(Q) 6= ∅ since SE(R)∩SE(Q) 6= ∅ by Definition 5.1 and r ∈ Q implies SE(Q) ⊆ SE(r). This is a contradiction because R is maximal by Definition 5.1.\nTHEOREM 5.2: An operator ∗γ is a partial meet revision operator for P ∈ LPA determined by a selection function γ for P iff ∗γ satisfies (∗1b)–(∗5b).\nPROOF. We first show that a partial meet revision operator ∗γ for P determined by a given selection function γ for P satisfies (∗1b)–(∗5b). (∗1b): Since (∗1b) = (∗2) and ∗γ satisfies (∗2), ∗γ also satisfies (∗1b). (∗2b): Since (∗2b) = (∗3) and ∗γ satisfies (∗3), ∗γ also satisfies (∗2b). (∗3b): Let r ∈ P . Assume that for all P ′ with P ∗γ Q ⊆ P ′ ⊂ P + Q and P ′ being satisfiable, it holds that P ′ ∪ {r} is satisfiable. In particular, for each R ∈ PQ with P ∗γ Q ⊆ R ∪ Q, this implies R ∪ Q ∪ {r} is satisfiable. As each R is subset-maximal, it follows that r ∈ R and thus r ∈ ⋂\nγ(PQ). From Definition 5.4 we can then conclude r 6∈ P \\ (P ∗γ Q). (∗4b): For all P ′ ⊆ P , let P ′ + Q be satisfiable iff P ′ + R is satisfiable. Then PQ = PR by Definition 5.1 and so ⋂ γ(PQ) = ⋂ γ(PR) as well as P ∩ ⋂ γ(PQ) = P ∩ ⋂\nγ(PR). By Lemma A.1 we obtain (P ∩ ⋂ γ(PQ)) ∪ (P ∩ Q) = (P ∩ ⋂ γ(PR)) ∪ (P ∩ R). This means\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nP ∩ ( ⋂ γ(PQ) ∪Q) = P ∩ ( ⋂\nγ(PR) ∪R). Thus, P ∩ (P ∗γ Q) = P ∩ (P ∗γ R). (∗5b): If Q is satisfiable, then for any R ∈ PQ, R+Q is satisfiable, which implies P ∗γ Q is satisfiable. We now show that any operator ◦γ for P satisfying (∗1b)–(∗5b) is a partial meet revision operator for P determined by some selection function for P . We first find a selection function γ for P . Let γ be such that (i) if PQ = ∅, then γ(PQ) = ∅ and (ii) γ(PQ) = {R ∈ PQ | P ∩ (P ◦γ Q) ⊆ R } otherwise. We begin by showing that γ is a function. If PQ = PR, then P ∩(P ◦γQ) = P ∩(P ◦γR) by (∗4b). This means γ(PQ) = γ(PR) according to our definition of γ. We next show that γ is a selection function. Clearly, γ(PQ) ⊆ PQ by our definition of γ. If PQ 6= ∅, thenQ is satisfiable by Definition 5.1 and thus P ◦γQ is satisfiable by (∗5b). Since Q ⊆ P ◦γ Q by (∗1b) and P ◦γ Q ⊆ P ∪Q by (∗2b), it follows that (P ∩ (P ◦γ Q))∪Q is satisfiable. This means that there exists R ∈ PQ such that P ∩ (P ◦γ Q) ⊆ R. From our definition of γ we therefore obtain that γ(PQ) 6= ∅. Finally, we show that ◦γ is a partial meet revision operator for P , that is, P ◦γ Q = P ∪ Q if Q is not satisfiable and P ◦γ Q = ⋂\nγ(PQ) ∪ Q otherwise. Consider first the limiting case that Q is not satisfiable. If r ∈ P \\ (P ◦γ Q), then there exists P ′ such that P ◦γ Q ⊆ P ′ ⊂ P ∪Q and P ′ is satisfiable but P ′ ∪ {r} is not satisfiable by (∗3b). This is a contradiction since Q ⊆ P ′ by (∗1b). Therefore, it holds for all r ∈ P that r ∈ P ◦γ Q, that is, P ⊆ P ◦γ Q. Since Q ⊆ P ◦γ Q by (∗1b) and P ◦γ Q ⊆ P ∪ Q by (∗2b), we can conclude P ◦γ Q = P ∪Q. Assume now that Q is satisfiable. Let r ∈ P \\ (P ◦γ Q). If PQ = ∅, then it follows from (∗1b) and (∗3b) that P ◦γ Q = Q. Since γ(PQ) = ∅ by our definition of γ, we thus have P ◦γ Q = Q = ⋂\nγ(PQ) ∪ Q. If PQ 6= ∅, then it follows directly from our definition of γ that P ∩ (P ◦γQ) ⊆ ⋂ γ(PQ). From (∗1b) and (∗2b) we then obtain P ◦γQ ⊆ ⋂\nγ(PQ)∪Q. To show the converse inclusion, first assume the case that P ∪ Q is satisfiable. This implies that for any P ′ ⊆ P ∪Q it holds that P ′ is satisfiable. Applying (∗3b), we obtain P \\(P ◦γQ) = ∅ and thus P ⊆ P ◦γQ. From (∗1b) and (∗2b) it follows that P ◦γQ = P ∪Q. Moreover, due to the assumption that P ∪ Q is satisfiable and Definition 5.1, we have PQ = {P}. By our definition of γ, we obtain γ(PQ) = {P} and thus ⋂\nγ(PQ) = P and can conclude P ◦γQ = ⋂\nγ(PQ)∪Q. Lastly, assume the case that P ∪Q is not satisfiable. We will show that r 6∈ P ◦γ Q implies r 6∈ ⋂\nγ(PQ) ∪ Q. If r 6∈ P , then r 6∈ (P ◦γ Q) \\ Q by (∗1b) and (∗2b) and r 6∈ ⋂\nγ(PQ) by Definition 5.1. Since r 6∈ P ◦γ Q implies r 6∈ Q by (∗1b), it follows that r 6∈ ((P ◦γ Q) \\Q)∪Q) = P ◦γ Q and r ∈ ⋂\nγ(PQ)∪Q. Now assume r ∈ P \\ (P ◦γ Q). According to (∗3b), then there exists P ′ such that P ◦γ Q ⊆ P ′ ⊂ P ∪Q and P ′ is satisfiable but P ′∪{r} is not satisfiable. This means that there exists R ∈ PQ such that P ∩ P ′ ⊆ R and r 6∈ R. Since P ∩ (P ◦γ Q) ⊆ P ∩ P ′ ⊆ R, we obtain from our definition of γ that R ∈ γ(PQ). We can thus conclude from r 6∈ R that r 6∈ ⋂ γ(PQ).\nPROPOSITION 5.1: Let P,Q ∈ LPA. For any maxichoice selection function γP for P , there exists a selection function γ for P such that (P ∪Q)!SEγP Q = P ∗γ Q.\nPROOF. Let P,Q ∈ LPA and γP be a maxichoice selection function for P . We will prove by cases. Case 1: Q is not satisfiable. This means (P ∪ Q)⊥SE! Q = ∅ by definition of P⊥ SE ! Q. Then γP ((P ∪ Q)⊥SE! Q) = P ∪ Q by definition of γP . It follows that (P ∪ Q)! SE γP Q = P ∪Q = P ∗γ Q by definition of !SEγP and Definition 5.4.\nCase 2: Q is satisfiable and for all R ⊆ P : SE(R ∪ Q) = ∅. Then (P ∪ Q)⊥SE! Q = {Q} by definition of ⊥SE! and PQ = ∅ = ⋂\nγ(PQ) by Definition 5.1. It follows that (P ∪Q)!SEγP Q = γP ((P ∪Q)⊥ SE ! Q) = Q = P ∗γ Q by definition of ! SE γP and Definition 5.4.\nCase 3: Q is satisfiable and there exists R ⊆ P : SE(R ∪ Q) 6= ∅ such that for all R′ with R ⊂ R′ ⊆ P : SE(R′) = ∅. Then R ∪ Q ∈ (P ∪ Q)⊥SE! Q by definition of ⊥ SE !\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nand R ∈ PQ by Definition 5.1. Let γ be a maxichoice selection function for P such that γ(2P ) ∪ Q = γP ({R ∪ Q | R ∈ 2P }). This implies γP ((P ∪ Q)⊥SE! Q) = γ(PQ) ∪ Q = ⋂\nγ(PQ) ∪Q. Thus, (P ∪Q)!SEγP Q = P ∗γ Q by definition of ! SE γP and Definition 5.4.\nPROPOSITION 5.2: Let P,Q ∈ LPA and γ 1, γP be single-choice and maxichoice selection functions, respectively, for P . If γ1(2P ) ∪Q = γP ({R ∪Q | R ∈ 2P }) for any γP , then P ∗ASγ1 Q = (P ∪Q)!γP Q.\nPROOF. Let P,Q ∈ LPA and γ 1, γP be single-choice and maxichoice selection functions, respectively, for P . Assume that γ1(2P ) ∪ Q = γP ({R ∪ Q | R ∈ 2P }) for any γP . We will prove by cases. Case 1: AS(Q) = ∅ and for all R ⊆ P : AS(R ∪ Q) = ∅. This implies PASQ = ∅ by definition of PASQ and thus P ∗γQ = P ∪Q by Definition 5.6. It also implies (P ∪Q)⊥!Q = ∅ by definition of P⊥!Q and therefore γP ((P ∪ Q)⊥!Q) = P ∪Q by definition of γP . We can conclude (P ∪Q)!γP Q = P ∪Q by Definition 3.2. Case 2: AS(Q) 6= ∅ and for all R ⊆ P : AS(R ∪ Q) = ∅. Then PASQ = ∅ = γ\n1(PASQ ) by definitions of PASQ and γ 1. We also have (P ∪ Q)⊥!Q = {Q} = γP ((P ∪ Q)⊥!Q) by definitions of ⊥! and γP . It follows that P ∗ASγ1 Q = Q = (P ∪ Q)!γPQ by Definitions 5.6 and 3.2. Case 3: There exists R ⊆ P : AS(R ∪ Q) 6= ∅ and for all R′ with R ⊂ R′ ⊆ P : AS(R′ ∪ Q) = ∅. Then R ∈ PASQ by definition of P AS Q and R ∪ Q ∈ (P ∪ Q)⊥!Q by definition of ⊥!. Due to the assumption, it holds that γ1(PASQ ) ∪ Q = γP ((P ∪ Q)⊥!Q). Thus, P ∗ASγ1 Q = (P ∪Q)!γP Q by Definitions 5.6 and 3.2.\nTHEOREM 5.3: The contraction operator .−γ satisfies ( .−1)–( .−4) and ( .−6).\nPROOF. ( .−1): Follows directly from Definition 5.8. ( .−2): Follows directly from Definition 5.8. ( .−3): If P 6|=s Q, then P − Q = {P} = γ(P − Q), for any selection function γ, and thus P\n.−γQ = P . ( .−4): Let 6|=s Q. For any R ∈ P − Q, R 6|=s Q, which implies P\n.−γ Q 6|=s Q. ( .−6): Follows directly from Definition 5.8.\nLEMMA A.2. Let P ∈ LPA. For any Q,R ∈ LPA, it holds that P − Q+R ⊆ P − Q ∪ P − R.\nPROOF. Let P,Q,R ∈ LPA. It follows from SE(Q+R) = SE(Q) ∪ SE(R) and the definition of P−Q+R that P − Q+R = {S ∈ P − Q ∪ P − R | S 6⊂ S ′ for any S′ ∈ P−Q ∪ P − R }. Thus, P−Q+R ⊆ P − Q ∪ P − R.\nLEMMA A.3. Let P ∈ LPA and γ ′ be determined by a maximised transitive relation.\nFor any Q,R ∈ LPA, it holds that γ′(P − Q+R) ⊆ γ ′(P−Q) ∪ γ ′(P−R).\nPROOF. Let P,Q,R ∈ LPA. Assume there exists S ∈ γ′(P − Q+R) : S 6∈ γ ′(P−Q) ∪ γ ′(P−R).\nThen S 6∈ γ′(P−Q) and S 6∈ γ ′(P−R). Case 1: If S 6∈ P − Q, this means that S ∈ P − R by Lemma A.2. From Definition 5.5 it follows that there exists S′ ∈ P−R : S ⊂ S ′, a contradiction since S ∈ P−Q+R. Case 2: S ∈ P − Q. Follows analogously as Case 1.\nTHEOREM 5.4: Let γ′ be determined by a maximised transitive relation. The contraction operator .−γ′ satisfies ( .−7).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nPROOF. Let P,Q,R ∈ LPA and r ∈ (P .−γ′Q)∩(P .−γ′R). This means that r ∈ ⋂ γ′(P−Q)\nand r ∈ ⋂ γ′(P−R). By Lemma A.3, we have for all S ∈ γ ′(P−Q+R) : r ∈ S, so that r ∈ ⋂\nγ′(P−Q+R). Thus, (P .−γ′ Q) ∩ (P .−γ′ R) ⊆ P .−γ′ (Q+R).\nTHEOREM 5.5: An operator .−γ is a partial meet contraction operator for P ∈ LPA determined by a selection function γ for P iff .−γ satisfies ( .−1b)–( .−4b).\nPROOF. We first show that a partial meet contraction operator .−γ for P determined by a given selection function γ for P satisfies ( .−1b)–( .−4b). ( .−1b): Follows from ( .−1b) = ( .−2) and satisfaction of ( .−2). ( .−2b): Follows from ( .−2b) = ( .−4) and satisfaction of ( .−4). ( .−3b): Let r ∈ P . Assume that for all P ′ with P .−γ Q ⊆ P ′ ⊂ P and P ′ 6|=s Q, it holds that P ′ ∪ {r} 6|=s Q. In particular, for each R ∈ P − Q with P\n.−γ Q ⊆ R, this implies R ∪ {r} 6|=s Q. As each R is subset-maximal by Definition 5.7, it follows that r ∈ R and thus r ∈ P .−γ Q. ( .−4b): For all P ′ ⊆ P , let P ′ 6|=s Q iff P ′ 6|=s R. Then P − Q = P − R by Definition 5.7 and so γ(P−Q) = γ(P − R) as well as ⋂ γ(P−Q) = ⋂ γ(P−R). Thus, P .−γ Q = P\n.−γ R by Definition 5.8. We now show that any operator ◦γ for P satisfying (\n.−1b)–( .−4b) is a partial meet contraction operator for P determined by some selection function for P . We first find a selection function γ for P. Let γ be such that (i) if P−Q = ∅, then γ(P − Q) = ∅ and (ii) γ(P−Q) = {R ∈ P − Q | P ◦γ Q ⊆ R } otherwise.\nWe begin by showing that γ is a function. If P−Q = P − R, then P ◦γ Q = P ◦γ R by ( .−4b).\nThis means γ(P−Q) = γ(P − R) according to our definition of γ.\nWe next show that γ is a selection function. Clearly, γ(P−Q) ⊆ P − Q by our definition of γ. If P−Q 6= ∅, then 6|=s Q by Definition 5.7 and thus P ◦γ Q 6|=s Q by ( .−2b). It follows from P ◦γ Q ⊆ P due to ( .−1b) that there exists R ∈ P−Q such that P ◦γ Q ⊆ R. From our definition of γ we therefore obtain that γ(P−Q) 6= ∅. Finally, we show that ◦γ is a partial meet contraction operator for P , that is, P ◦γQ = P if |=s Q and P ◦γ Q = ⋂\nγ(P−Q) otherwise. Consider first the limiting case that |=s Q. If r ∈ P \\ (P ◦γ Q), then there exists P ′ such that P ◦γ Q ⊆ P ′ ⊂ P and P ′ 6|=s Q but P ′ ∪ {r} |=s Q by (\n.−3b). This is a contradiction since |=s Q. Therefore, it holds for all r ∈ P that r ∈ P ◦γ Q, that is, P ⊆ P ◦γ Q. Since P ◦γ Q ⊆ P by (\n.−1b), we can conclude P ◦γ Q = P . Assume now that 6|=s Q. Let r ∈ P \\ (P ◦γ Q). If P − Q = ∅, then it follows from ( .−2b) and ( .−3b) that P ◦γ Q = ∅. Since γ(P − Q) = ∅ by our definition of γ, we thus have P ◦γ Q = ⋂ γ(P−Q). If P − Q 6= ∅, then it follows directly from our definition of γ that P ◦γ Q ⊆ ⋂\nγ(P−Q). To show the converse inclusion, first assume the case that P 6|=s Q. This implies that for any P ′ ⊆ P it holds that P ′ 6|=s Q. Applying (\n.−3b), we obtain"
    }, {
      "heading" : "P \\ (P ◦γ Q) = ∅ and thus P ⊆ P ◦γ Q. From (",
      "text" : ".−1b) it follows that P ◦γ Q = P . Moreover, due to the assumption that P 6|=s Q and Definition 5.7, we have P − Q = {P}. By our definition of γ, we obtain γ(P−Q) = {P} and thus ⋂\nγ(P−Q) = P and can conclude P ◦γQ = ⋂\nγ(P−Q). Lastly, assume the case that P |=s Q. We will show that r 6∈ P ◦γ Q implies\nr 6∈ ⋂ γ(P−Q). If r 6∈ P , then r 6∈ P ◦γ Q by ( .−1b) and r 6∈ ⋂ γ(P−Q) by Definition 5.7. Now assume r ∈ P \\ (P ◦γ Q). According to (\n.−3b), then there exists P ′ such that P ◦γ Q ⊆ P ′ ⊂ P and P ′ 6|=s Q but P ′ ∪ {r} |=s Q. This means that there exists R ∈ P − Q\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nsuch that P ′ ⊆ R and r 6∈ R. Since P ◦γ Q ⊆ P ′ ⊆ R, we obtain from our definition of γ that R ∈ γ(P−Q). We can thus conclude from r 6∈ R that r 6∈ ⋂ γ(P−Q).\nPROPOSITION 5.3: The contraction operator .−γ satisfies ( .−5b), ( .−6b), and ( .−8b).\nPROOF. ( .−5b): Since ( .−5b) = ( .−3) and .−γ satisfies ( .−3), .−γ also satisfies ( .−5b). ( .−6b): Since ( .−6b) = ( .−6) and .−γ satisfies ( .−6), .−γ also satisfies (\n.−6b). ( .−8b): Follows from satisfaction of ( .−3b) and Proposition 4.1.\nLEMMA 6.1: Let P,Q,R ∈ LPA and be an ensconcement associated with P .\na) If P +Q is satisfiable, then cut (Q) = P . b) If Q is satisfiable, then cut (Q) +Q is satisfiable. c) If Q is not satisfiable, then cut (Q) = ∅. d) If Q |=s R, then cut (Q) ⊆ cut (R). e) cut (Q+R) ⊆ cut (Q). f) If cut (Q) |=s R, then cut (Q +R) = cut (Q).\nPROOF. a) – d) Follow directly from Definition 6.2. e) Follows directly from d). f) Let cut (Q) |=s R. It follows that SE(cut (Q)) ∩ SE(Q) ⊆ SE(R), which implies SE(cut (Q)) ∩ SE(Q) ∩ SE(R) 6= ∅ since SE(cut (Q)) ∩ SE(Q) 6= ∅ by Definition 6.2. We can rewrite this as SE(cut (Q)) ∩ SE(Q+R) 6= ∅. Thus, cut (Q) ⊆ cut (Q+R) by Definition 6.2. By Lemma 6.1 e), we obtain cut (Q) = cut (Q+R).\nPROPOSITION 6.1: Let P,Q ∈ LPA and be an ensconcement associated with P . Then SE(P ∗ Q) = SE(cut (Q) +Q).\nPROOF. Let P,Q ∈ LPA and be an ensconcement associated with P . If Q is not satisfiable, then by Definition 6.3 we have SE(P ∗ Q) = SE(P + Q) = ∅ and by Lemma 6.1 c) we also have SE(cut (Q)+Q) = SE(Q) = ∅. Otherwise, by Definition 6.3, P ∗ Q = cut (Q)∪(P ∗ Q)\\(cut (Q)+Q)∪Q, which means SE(P ∗ Q) = SE(cut (Q))∩ SE((P ∗ Q) \\ (cut (Q) + Q)) ∩ SE(Q). Since for any r ∈ (P ∗ Q) \\ (cut (Q) + Q) : SE(cut (Q)) ∩ SE(Q) ⊆ SE(r), we obtain SE(P ∗ Q) = SE(cut (Q)) ∩ SE(Q).\nTHEOREM 6.1: The revision operator ∗ satisfies (∗1)–(∗6) and (∗8).\nPROOF. (∗1): Follows directly from Definition 6.3. (∗2): Follows directly from Definition 6.3. (∗3): If Q is not satisfiable, then P ∗ Q = P +Q by Definition 6.3. Otherwise, for any r ∈ P ∗ Q it holds that r ∈ P ∪Q, which implies P ∗ Q ⊆ P +Q. (∗4): If P +Q is satisfiable, then cut (Q) = P by Lemma 6.1 a). Since SE(P ) ⊆ SE(r) for all r ∈ P , it follows from Definition 6.3 that P ∗ Q = P +Q. (∗5): If Q is not satisfiable, then P ∗ Q = P + Q is not satisfiable. Now assume Q is satisfiable. By Lemma 6.1 b) it holds that cut (Q) + Q is satisfiable. Since P ∗ Q ≡s cut (Q) +Q by Proposition 6.1, it follows that P ∗ Q is satisfiable. (∗6): Follows directly from Definition 6.3. (∗8): Let (P ∗ Q) + R be satisfiable. By Definition 6.3, this means SE(cut (Q)) ∩ SE((P ∗ Q)\\cut (Q))∩SE(Q)∩SE(R) 6= ∅ and thus SE(cut (Q))∩SE(Q)∩SE(R) 6= ∅. From Lemma 6.1 e) and Definition 6.2 it follows that cut (Q + R) = cut (Q). Then obviously SE(cut (Q + R)) ∩ SE(Q) = SE(cut (Q)) ∩ SE(Q), which implies SE(cut (Q + R)) ∩ SE(Q) ∩ SE(R) ⊆ SE(cut (Q)) ∩ SE(Q). It thus also holds that\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\n{ r ∈ P | SE(cut (Q)) ∩ SE(Q) ⊆ SE(r) } ⊆ { r ∈ P | SE(cut (Q + R)) ∩ SE(Q + R) ⊆ SE(r) }, from which we can conclude that (P ∗ Q) +R ⊆ P ∗ (Q+R).\nTHEOREM 6.2: The revision operator ∗ satisfies (∗1b), (∗2b), and (∗5b).\nPROOF. (∗1b): Since (∗1b) = (∗2) and ∗ satisfies (∗2), ∗ also satisfies (∗1b). (∗2b): Since (∗2b) = (∗3) and ∗ satisfies (∗3), ∗ also satisfies (∗2b). (∗5b): If Q is satisfiable, then by Lemma 6.1 b) it holds that cut (Q) +Q is satisfiable. Since P ∗ Q ≡s cut (Q)+Q by Proposition 6.1, it follows that P ∗ Q is satisfiable.\nLEMMA 6.2: Let P,Q,R ∈ LPA.\na) If P 6|=s Q, then cut − (Q) = P . b) If 6|=s Q, then cut − (Q) 6|=s Q. c) If |=s Q, then cut − (Q) = ∅. d) If Q |=s R, then cut − (R) ⊆ cut − (Q). e) cut− (Q) ⊆ cut − (Q +R).\nf) If cut− (Q) |=s R, then cut − (Q+R) = cut − (Q).\ng) If cut− (Q) 6|=s R, then cut − (Q+R) = cut − (R).\nPROOF. a) – d) Follow directly from the definition of cut− (Q).\ne) Follows directly from d). f) Assume cut− (Q + R) 6= cut − (Q). Then cut − (Q) ⊂ cut − (Q + R) by Lemma 6.2 e). Let\nr ∈ cut− (Q + R) \\ cut − (Q). This means SE({ r ′ ∈ P | r r′ }) ∩ SE(Q+R) 6= ∅ and\nSE({ r′ ∈ P | r r′ }) ∩ SE(Q) = ∅ by Definition of cut− (Q). Thus, SE({ r ′ ∈ P | r\nr′ }) ∩ SE(R) 6= ∅. Furthermore, cut− (Q) ⊆ { r ′ ∈ P | r r′ } by Definition of cut− (Q).\nWe therefore obtain SE(cut− (Q)) ∩ SE(R) 6= ∅, which implies cut − (Q) 6|=s R. g) Assume cut− (Q +R) 6= cut − (R). Then cut − (R) ⊂ cut − (Q + R) by Lemma 6.2 e). Let\nr ∈ cut− (Q + R) \\ cut − (R). This means SE({ r ′ ∈ P | r r′ }) ∩ SE(Q+R) 6= ∅ and\nSE({ r′ ∈ P | r r′ }) ∩ SE(R) = ∅ by Definition of cut− (R). Thus, SE({ r ′ ∈ P | r\nr′ }) ∩ SE(Q) 6= ∅ and so { r′ ∈ P | r r′ } ⊆ cut− (Q) by Definition of cut − (Q). We\ntherefore obtain SE(cut− (Q)) ∩ SE(R) = ∅, which implies cut − (Q) |=s R.\nPROPOSITION 6.2: Let P,Q ∈ LPA and be an ensconcement associated with P . Then SE(P .− Q) ∩ SE(Q) = SE(cut − (Q)) ∩ SE(Q).\nPROOF. If |=s Q, then SE(Q) = ∅ and SE(P .− Q)∩SE(Q) = SE(cut − (Q))∩SE(Q).\nOtherwise, by Definition 6.4, P .− Q = cut − (Q) ∪ (P .− Q) \\ cut − (Q), which means SE(P .− Q) ∩ SE(Q) = SE(cut − (Q)) ∩ SE((P .− Q) \\ cut − (Q)) ∩ SE(Q). For all r ∈ (P .− Q) \\ cut − (Q) we have SE(cut − (Q))∩SE(Q) ⊆ SE(r), so that we obtain SE(P .−\nQ) ∩ SE(Q) = SE(cut− (Q)) ∩ SE(Q).\nTHEOREM 6.3: The contraction operator .− satisfies ( .−1)–( .−4) and ( .−6)–( .−8).\nPROOF. ( .−1): Follows directly from Definition 6.4. ( .−2): Follows directly from Definition 6.4.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\n( .−3): If P 6|=s Q, then cut − (Q) = P by Lemma 6.2 a). Since SE(P ) ⊆ SE(r) for all r ∈ P , this means SE(cut− (Q)) ∩ SE(Q) ⊆ SE(r) for all r ∈ P and by Definition 6.4 we thus have P .− Q = P . ( .−4): Let 6|=s Q. If P 6|=s Q, then P .− Q = P 6|=s Q by ( .−3). Now assume P |=s Q and let S = SE(cut− (Q)) ∩ SE(Q). For each r ∈ P , if r ∈ P .− Q, then S ⊆ SE(r) by Definition 6.4, and thus S ⊆ SE(P .− Q). Since S∩SE(Q) = ∅, we obtain P .− Q 6|=s Q. ( .−6): Follows directly from Definition 6.4. ( .−7): For all r ∈ (P .− Q) ∩ (P .− R) : SE(cut − (Q)) ∩ SE(Q) ⊆ SE(r) and\nSE(cut− (R)) ∩ SE(R) ⊆ SE(r). This implies SE(cut − (Q + R)) ∩ SE(Q) ⊆ SE(r) since\ncut− (Q) ⊆ cut − (Q + R) by Lemma 6.2 e) and SE(cut − (Q + R)) ∩ SE(R) ⊆ SE(r) since\ncut− (R) ⊆ cut − (Q+R) by Lemma 6.2 e). From SE(Q+R) = SE(Q)∪SE(R) we obtain SE(cut− (Q+R)) ∩ SE(Q+R) ⊆ SE(r) and thus r ∈ P .− (Q +R) by Definition 6.4. ( .−8): Assume SE(P .− (Q + R)) * SE(Q). Then, SE(cut − (Q + R)) ∩ SE((P .− (Q +\nR)) \\ cut− (Q + R)) * SE(Q), which means SE(cut − (Q + R)) ∩ SE(Q) 6= ∅ (i). Recall that cut− (Q) is maximal and cut − (Q) ⊆ cut − (Q + R) (ii) by Lemma 6.2 e). From (i)\nand (ii) it follows that cut− (Q) = cut − (Q + R). Since SE(Q) ⊆ SE(Q+R), we have\nSE(cut− (Q)) ∩ SE(Q) ⊆ SE(cut − (Q+R)) ∩ SE(Q+R), which implies P .− (Q+R) ⊆ P .− Q by Definition 6.4.\nTHEOREM 6.4: The contraction operator .− satisfies (−1b), (−2b) and (−5b)–(−8b).\nPROOF. ( .−1b): Follows from ( .−1b) = ( .−2) and satisfaction of ( .−2). ( .−2b): Follows from ( .−2b) = ( .−4) and satisfaction of ( .−4). ( .−5b): Follows from ( .−5b) = ( .−3) and satisfaction of ( .−3). ( .−6b): Follows from ( .−6b) = ( .−6) and satisfaction of ( .−6). ( .−7b): If |=s Q+R, then P\n.− (Q+R) = P by Definition 6.4 and |=s Q and |=s R, which means P .− Q = P and P\n.− R = P by Definition 6.4. Now let 6|=s Q+ R. We proceed by cases. Case 1: cut− (Q) |=s R. Then cut − (Q + R) = cut − (Q) by Lemma 6.2 f). Let r ∈ P .− (Q+R). This means r ∈ P by ( .−2) and SE(cut− (Q+R))∩SE(Q+R) ⊆ SE(r) by Defi-\nnition 6.4. It follows that SE(cut− (Q +R)) ∩ SE(Q) ⊆ SE(r). Due to the case assumption, we obtain SE(cut− (Q)) ∩ SE(Q) ⊆ SE(r) and thus r ∈ P .− Q by Definition 6.4. Now let r ∈ P .− Q. This means r ∈ P by ( .−2) and SE(cut− (Q)) ∩ SE(Q) ⊆ SE(r)\nby Definition 6.4. Then SE(cut− (Q + R)) ∩ SE(Q) ⊆ SE(r) due to the case assump-\ntion. It also follows from the case assumption that SE(cut− (Q)) ∩ SE(R) = ∅ and\nSE(cut− (Q + R)) ∩ SE(R) = ∅. We thus have SE(cut − (Q + R)) ∩ (SE(Q) ∪ SE(R)) ⊆ SE(r), that is, SE(cut− (Q+R)) ∩ SE(Q+R) ⊆ SE(r). Therefore, r ∈ P .− (Q+R) by\nDefinition 6.4. Case 2: cut− (R) |=s Q. Follows analogous to Case 1 so that P .− (Q +R) = P .− R.\nCase 3: cut− (Q) 6|=s R and cut − (R) 6|=s Q. Then cut − (Q + R) = cut − (Q) = cut − (R) by Lemma 6.2 g). Let r ∈ P .− (Q + R). This means r ∈ P by ( .−2) and SE(cut− (Q +\nR))∩ SE(Q+R) ⊆ SE(r) by Definition 6.4. We thus have SE(cut− (Q+R)) ∩ SE(Q) ⊆\nSE(r) and SE(cut− (Q + R)) ∩ SE(R) ⊆ SE(r). From the case assumption it follows\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nthat SE(cut− (Q)) ∩ SE(Q) ⊆ SE(r) and SE(cut − (R)) ∩ SE(R) ⊆ SE(r). This means r ∈ P .− Q and r ∈ P .− R by Definition 6.4 and therefore r ∈ (P .− Q) ∩ (P .− R). ( .−8b): Assume SE(P .− Q) ⊆ SE(Q) ∪ SE(r), that is, SE(P .− Q) ∩ SE(Q) ⊆ SE(r). By Proposition 6.2, SE(P .− Q) ∩ SE(Q) = SE(cut − (Q)) ∩ SE(Q), so that we obtain SE(cut− (Q)) ∩ SE(Q) ⊆ SE(r). This implies r ∈ P .− Q by Definition 6.4. We can conclude r ∈ P by ( .−2).\nTHEOREM 7.1: Let P,Q ∈ LPA. For any selection function γ, there exists an ensconcement associated with P such that P ∗γ Q = P ∗ Q.\nPROOF. Let P,Q ∈ LPA and γ be a selection function that determines the outcome of P ∗γ Q. By S = (P ∗γ Q) ∩ P = ⋂\nγ(PQ) we denote the subset of P that is retained in the revision and by S′ = P \\ S the subset of P that is discarded. We can then create an ensconcement associated with P that has a minimal number of levels, such that for all r ∈ S and for all r′ ∈ S′: r′ ≺ r. We now show that (P ∗ Q) ∩ P = S. Clearly, cut (Q) = S by Definition 6.2, which implies S ⊆ (P ∗ Q)∩P . Assume that there exists an r′ ∈ S′ with SE(cut (Q)) ∩ SE(Q) ⊆ SE(r′). Then for each selected compatible set R ∈ γ(PQ) it would hold that r′ ∈ R because R is maximal by the definition of PQ. Yet this implies r′ ∈ S, a contradiction.\nTHEOREM 7.2: Let P,Q ∈ LPA. For any selection function γ, there exists an ensconcement associated with P such that P .−γ Q = P .− Q.\nPROOF. Follows analogously to the proof of Theorem 7.1.\nLEMMA A.4. Let R be a subset-ensconcement associated with some P ∈ LPA and R ⊆ P . For any rule r ∈ R, it holds that R R {r}.\nPROOF. Since R |=s {r}, it follows from Conditions ( R1) and ( R2) that {r} 6≺R\nR.\nTHEOREM 7.3: Let P,Q ∈ LPA, be an ensconcement associated with P , and R a subset-ensconcement associated with P such that {r} R {r′} iff r r′ for all r, r′ ∈ P . Then P ∗ Q = P ∗ R Q (or P .− Q = P .− R Q, alternatively).\nPROOF. Let P,Q ∈ LPA, an ensconcement associated with P , and R a subsetensconcement associated with P . Assume that {r} R {r′} iff r r′ for all r, r′ ∈ P . From LemmaA.4 it is clear that cut (Q) = cut R(Q), which implies for all r ∈ (P ∗ Q)\\ Q : SE(cut R(Q))∩SE(Q) ⊆ SE({r}), and thus P ∗ Q ⊆ P ∗ RQ. Since SE(R) ⊆ SE(r) for any R ⊆ P and each r ∈ R, we also have P ∗ R Q ⊆ P ∗ Q. Analogous for contraction.\nPROPOSITION 7.1: Let P ∈ LPA, γ be a selection function for P , and ∗ an operator for P such that for any Q ∈ LPA: P ∗Q = (P .−γ Q) +Q. Then P ∗Q = P ∗γ Q.\nPROOF. Let SE(Q) = SE . Then P .−γ Q = P by Definition 5.8 and thus P ∗ Q = (P .−γ Q) + Q = P + Q = P ∗γ Q by Definition 5.4. Otherwise, SE(Q) 6= SE such that P− Q = {R ⊆ P | SE(R)∩SE(Q) 6= ∅ and for all R′ with R ⊂ R′ ⊆ P : SE(R′)∩SE(Q) = ∅ } = PQ by Definition 5.1. It follows that P ∗Q = (P .−γ Q)+Q = ⋂\nγ(PQ)+Q = P ∗γ Q by Definitions 5.4 and 5.8.\nPROPOSITION 7.2: Let P ∈ LPA, γ be a selection function for P , and .− an operator\nfor P such that for any Q ∈ LPA: P .−Q = P ∩ (P ∗γ Q). Then P .−Q = P .−γ Q.\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nPROOF. Let SE(Q) = ∅. Then P ∗γ Q = P + Q by Definition 5.4 and thus P .− Q = P ∩ (P ∗γ Q) = P = P .−γ Q by Definition 5.8. Otherwise, SE(Q) 6= ∅ such that"
    }, {
      "heading" : "PQ = {R ⊆ P | SE(R)∩SE(Q) 6= ∅ and for all R",
      "text" : "′ with R ⊂ R′ ⊆ P : SE(R′)∩SE(Q) = ∅ } = P−Q by Definition 5.7. It follows that P .− Q = P ∩ (P ∗γ Q) = P ∩ ( ⋂ γ(P−Q) + Q) by Definition 5.4. Assume there exists a rule r ∈ Q with r ∈ P \\ ⋂\nγ(P−Q). Then there\nexists an R ∈ γ(P−Q) : r 6∈ R, a contradiction since SE(Q) = SE(Q) ⊆ SE(r) and R is maximal. We therefore obtain P .−Q = P .−γ Q by Definition 5.8.\nPROPOSITION 7.3: Let P ∈ LPA, be an ensconcement associated with P , and ∗ an operator for P such that for any Q ∈ LPA: P ∗Q = (P .− Q)+Q. Then P ∗Q = P ∗ Q.\nPROOF. Let SE(Q) = SE . Then P .− Q = P by Definition 6.4 and thus P ∗ Q = (P .− Q) +Q = P +Q = P ∗ Q by Definition 6.3. Otherwise, SE(Q) 6= SE such that cut− (Q) = { r ∈ P | SE ({ r ′ ∈ P | r r′ })∩SE(Q) 6= ∅ } = cut (Q) by Definition 6.2. It follows that P∗Q = (P .− Q)+Q = { r ∈ P | SE(cut (Q))∩SE(Q) ⊆ SE(r) }+Q = P∗ Q by Definitions 6.3 and 6.4.\nPROPOSITION 7.4: Let P ∈ LPA, be an ensconcement associated with P , and .− an\noperator for P such that for any Q ∈ LPA: P .−Q = P ∩ (P ∗ Q). Then P .−Q = P .− Q.\nPROOF. Let SE(Q) = ∅. Then P ∗ Q = P + Q by Definition 6.3 and thus P .− Q = P ∩ (P ∗ Q) = P = P .− Q by Definition 6.4. Otherwise, SE(Q) 6= ∅ such that cut (Q) = { r ∈ P | SE ({ r′ ∈ P | r r′ }) ∩ SE(Q) 6= ∅ } = cut − (Q) by definition of cut− (Q). It follows that P .−Q = P ∩ (P ∗ Q) = P ∩ ({ r ∈ P | SE(cut − (Q)) ∩ SE(Q) ⊆\nSE(r) } + Q) by Definition 6.3. Assume there exists a rule r′ ∈ Q with r′ ∈ P \\ { r ∈ P | SE(cut− (Q)) ∩ SE(Q) ⊆ SE(r) }. Since SE(Q) = SE(Q) ⊆ SE(r ′), it holds that\nSE(cut− (Q)) ∩ SE(Q) ⊆ SE(r ′). This implies r′ ∈ { r ∈ P | SE(cut− (Q)) ∩ SE(Q) ⊆ SE(r) }, a contradiction. We therefore obtain P .−Q = P .− Q by Definition 6.4.\nPROPOSITION 8.1: Let P,Q ∈ LPA and SE(P ) 6= ∅ 6= SE(Q). For any R ⊆ P , if SE(R) ∩ SE(Q) = ∅ and for all R′ ⊂ R : SE(R′) ∩ SE(Q) 6= ∅, then there exists M ∈ 2M(P )|Q such that R ⊆ ⋃ M.\nPROOF. Let P,Q be satisfiable logic programs andR ⊆ P such that SE(R)∩SE(Q) = ∅ and for each R′ ⊂ R : SE(R′) ∩ SE(Q) 6= ∅. Then there exists some aj ∈ A such that aj ∈ At(Q) and there exist one or more rules ri ∈ R for each aj such that aj ∈ At(ri). For each ri, there exists a corresponding ri-module M(P )\nri |aj including aj , such that ri ∈ M(P )ri |aj . It follows from Definition 8.1 that for all remaining rules r\n′ ∈ R \\ ri : r′ ∈ ⋃\ni,j M(P ) ri |aj .\nCOROLLARY 8.1: Let P,Q ∈ LPA and SE(P ) 6= ∅. Then SE(P ) ∩ SE(Q) = ∅ if and only if SE ( ⋃\nM(P )|Q) ∩ SE(Q) = ∅.\nPROOF. “If”: Since SE(P ) ⊆ SE ( ⋃ M(P )|Q), if SE ( ⋃\nM(P )|Q) ∩ SE(Q) = ∅, then also SE(P ) ∩ SE(Q) = ∅. “Only if”: Follows from Proposition 8.1 if Q is satisfiable. Trivial if Q is not satisfiable.\nTHEOREM 8.1: For any P,Q ∈ LPA, there exists a selection function γ for P such that P ∗γ Q = P \\M(P )|Q + ⋃ M(P )| ∗γ Q + Q (or P .−γ Q = P \\M(P )|Q + ⋃ M(P )| .−γ Q , respectively).\nACM Transactions on Embedded Computing Systems, Vol. 0, No. 0, Article 00, Publication date: March 2000.\nPROOF. To prove the equation for revision, we need to show that P \\ M(P )|Q + ⋃\nM(P )| ∗γ Q = ⋂\nγ(PQ) for some γ. Let Z ⊆ P be the set of rules that are eliminated during the operation of ∗γ per Definition 5.4, i.e., P ∗γ Q = ⋂\nγ(PQ) +Q = P \\ Z + Q, and let Z ′ ⊆ P be the set of rules that are eliminated by MODCHANGE. We first show that Z ⊆ Z ′. Assume that Z ′ = ∅ until the last iteration of the while-loop. In the last iteration, we have n = |M(P )|Q| and MODCHANGE computes ⋃\nM(P )|Q ∗γ Q = ⋃ M(P )| ∗γ Q . Thus, P \\ M(P )|Q + ⋃ M(P )| ∗γ Q = P \\ M(P )|Q +\n( ⋃ M(P )|Q ∗γ Q). Let MQ denote the set {R ⊆ ⋃\nM(P )|Q | SE(R) ∩ SE(Q) 6= ∅ and, for all R′, R ⊂ R′ ⊆ P implies SE(R′) ∩ SE(Q) = ∅ }. If it holds for all R ∈ γ(PQ) that R ∩ ⋃ M(P )|Q ∈ γ(MQ), then P \\M(P )|Q + ( ⋃\nM(P )|Q ∗γ Q) = ((P \\M(P )|Q) ∪ ⋃\nM(P )|Q) ∗γ Q = P ∗γ Q, which implies Z = Z ′. We now show that Z ′ ⊆ Z. Assume that each revision operation in the following is\nthe most restrictive type, that is, for any set M , γ(M) = M . Thus, if r ∈ ⋂\nγ(PQ), then r ∈ R for allR ∈ PQ. For eachM as specified in the outer foreach loop of MODCHANGE, let z′ be the set of rules eliminated during the revision of ⋃ M by Q: z′ = ⋃ M\\ (( ⋃\nM∗γ Q) \\Q). From SE(P ) ⊆ SE( ⋃ M) it then follows that z′ ∩ ⋂ γ(PQ) = ∅. Since ⋃\nz′ = Z ′, we obtain Z ′ ∩ ⋂\nγ(PQ) = ∅. Analogous for contraction.\nCOROLLARY 8.2: For any P,Q ∈ LPA, let P \\ M(P )|Q = { r ∈ P | for all M ∈ M(P )|Q : r 6∈ M } andM(P )|◦Q denote the output of Algorithm 1 for the inputsM(P )|Q, ◦ ∈ {∗ , .− }, and Q. Then P ∗ Q = P \\ M(P )|Q + ⋃ M(P )| ∗ Q + Q (or P .− Q = P \\M(P )|Q + ⋃ M(P )| .− Q , respectively) for some ensconcement associated with P .\nPROOF. Follows directly from Theorems 7.1, 7.2, and 8.1."
    } ],
    "references" : [ {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "Carlos E. Alchourrón", "Peter Gärdenfors", "David Makinson." ],
      "venue" : "Journal of Symbolic Logic 50, 2 (1985), 510–530.",
      "citeRegEx" : "Alchourrón et al\\.,? 1985",
      "shortCiteRegEx" : "Alchourrón et al\\.",
      "year" : 1985
    }, {
      "title" : "Partial meet revision and contraction in logic programs",
      "author" : [ "Sebastian Binnewies", "Zhiqiang Zhuang", "Kewen Wang." ],
      "venue" : "Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence, AAAI 2015. 1439–1445.",
      "citeRegEx" : "Binnewies et al\\.,? 2015",
      "shortCiteRegEx" : "Binnewies et al\\.",
      "year" : 2015
    }, {
      "title" : "Preferred answer sets for extended logic programs",
      "author" : [ "Gerhard Brewka", "Thomas Eiter." ],
      "venue" : "Artificial Intelligence 109, 1–2 (1999), 297–356.",
      "citeRegEx" : "Brewka and Eiter.,? 1999",
      "shortCiteRegEx" : "Brewka and Eiter.",
      "year" : 1999
    }, {
      "title" : "The Birth of Prolog",
      "author" : [ "Alain Colmerauer", "Philippe Roussel." ],
      "venue" : "History of Programming languages— II. 331–367.",
      "citeRegEx" : "Colmerauer and Roussel.,? 1996",
      "shortCiteRegEx" : "Colmerauer and Roussel.",
      "year" : 1996
    }, {
      "title" : "Investigations into a theory of knowledge base revision: Preliminary report",
      "author" : [ "Mukesh Dalal." ],
      "venue" : "Proceedings of the Seventh National Conference on Artificial Intelligence. 475–479.",
      "citeRegEx" : "Dalal.,? 1988",
      "shortCiteRegEx" : "Dalal.",
      "year" : 1988
    }, {
      "title" : "A program-level approach to revising logic programs under the answer set semantics",
      "author" : [ "James P. Delgrande." ],
      "venue" : "Theory and Practice of Logic Programming 10, Special Issue 4–6 (2010), 565–580.",
      "citeRegEx" : "Delgrande.,? 2010",
      "shortCiteRegEx" : "Delgrande.",
      "year" : 2010
    }, {
      "title" : "AGM-style belief revision of logic programs under answer set semantics",
      "author" : [ "James P. Delgrande", "Pavlos Peppas", "Stefan Woltran." ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning. Lecture Notes in Computer Science, Vol. 8148. 264–276.",
      "citeRegEx" : "Delgrande et al\\.,? 2013",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2013
    }, {
      "title" : "A framework for compiling preferences in logic programs",
      "author" : [ "James P. Delgrande", "Torsten Schaub", "Hans Tompits." ],
      "venue" : "Theory and Practice of Logic Programming 3, 2 (2003), 129–187.",
      "citeRegEx" : "Delgrande et al\\.,? 2003",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2003
    }, {
      "title" : "A preference-based framework for updating logic programs",
      "author" : [ "James P. Delgrande", "Torsten Schaub", "Hans Tompits." ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning. Lecture Notes in Computer Science, Vol. 4483. 71–83.",
      "citeRegEx" : "Delgrande et al\\.,? 2007",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2007
    }, {
      "title" : "A classification and survey of preference handling approaches in nonmonotonic reasoning",
      "author" : [ "James P. Delgrande", "Torsten Schaub", "Hans Tompits", "Kewen Wang." ],
      "venue" : "Computational Intelligence 20, 2 (2004), 308–334.",
      "citeRegEx" : "Delgrande et al\\.,? 2004",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2004
    }, {
      "title" : "A model-theoretic approach to belief change in answer set programming",
      "author" : [ "James P. Delgrande", "Torsten Schaub", "Hans Tompits", "Stefan Woltran." ],
      "venue" : "ACM Transactions on Computational Logic 14, 2 (2013), 14:1–14:46.",
      "citeRegEx" : "Delgrande et al\\.,? 2013",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2013
    }, {
      "title" : "A truth maintenance system",
      "author" : [ "Jon Doyle." ],
      "venue" : "Artificial Intelligence 12, 3 (1979), 231–272.",
      "citeRegEx" : "Doyle.,? 1979",
      "shortCiteRegEx" : "Doyle.",
      "year" : 1979
    }, {
      "title" : "Model-based recasting in answer-set programming",
      "author" : [ "Thomas Eiter", "Michael Fink", "Jörg Pührer", "Hans Tompits", "Stefan Woltran." ],
      "venue" : "Journal of Applied Non-Classical Logics 23, 1–2 (2013), 75–104.",
      "citeRegEx" : "Eiter et al\\.,? 2013",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2013
    }, {
      "title" : "On properties of update sequences based on causal rejection",
      "author" : [ "Thomas Eiter", "Michael Fink", "Giuliana Sabbatini", "Hans Tompits." ],
      "venue" : "Theory and Practice of Logic Programming 2, 6 (2002), 711–767.",
      "citeRegEx" : "Eiter et al\\.,? 2002",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2002
    }, {
      "title" : "Simplifying logic programs under uniform and strong equivalence",
      "author" : [ "Thomas Eiter", "Michael Fink", "Hans Tompits", "Stefan Woltran." ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning. Lecture Notes in Computer Science, Vol. 2923. 87–99.",
      "citeRegEx" : "Eiter et al\\.,? 2004",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2004
    }, {
      "title" : "On the semantics of updates in databases",
      "author" : [ "Ronald Fagin", "Jeffrey D. Ullman", "Moshe Y. Vardi." ],
      "venue" : "Proceedings of the 2nd ACM SIGACT-SIGMOD Symposium on Principles of Database Systems (PODS ’83). 352–365.",
      "citeRegEx" : "Fagin et al\\.,? 1983",
      "shortCiteRegEx" : "Fagin et al\\.",
      "year" : 1983
    }, {
      "title" : "An axiomatic characterization of ensconcement-based contraction",
      "author" : [ "Eduardo Fermé", "Martı́n Krevneris", "Maurı́cio Reis" ],
      "venue" : "Journal of Logic and Computation 18,",
      "citeRegEx" : "Fermé et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Fermé et al\\.",
      "year" : 2008
    }, {
      "title" : "Theory contraction through base contraction",
      "author" : [ "André Fuhrmann." ],
      "venue" : "Journal of Philosophical Logic 20, 2 (1991), 175–203.",
      "citeRegEx" : "Fuhrmann.,? 1991",
      "shortCiteRegEx" : "Fuhrmann.",
      "year" : 1991
    }, {
      "title" : "A survey of multiple contractions",
      "author" : [ "André Fuhrmann", "Sven Ove Hansson." ],
      "venue" : "Journal of Logic, Language and Information 3, 1 (1994), 39–75.",
      "citeRegEx" : "Fuhrmann and Hansson.,? 1994",
      "shortCiteRegEx" : "Fuhrmann and Hansson.",
      "year" : 1994
    }, {
      "title" : "An epistemic approach to conditionals",
      "author" : [ "Peter Gärdenfors." ],
      "venue" : "American Philosophical Quarterly 18, 3 (1981), 203–211.",
      "citeRegEx" : "Gärdenfors.,? 1981",
      "shortCiteRegEx" : "Gärdenfors.",
      "year" : 1981
    }, {
      "title" : "Knowledge in Flux: Modeling the Dynamics of Epistemic States",
      "author" : [ "Peter Gärdenfors." ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Gärdenfors.,? 1988",
      "shortCiteRegEx" : "Gärdenfors.",
      "year" : 1988
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "Michael Gelfond", "Vladimir Lifschitz." ],
      "venue" : "Proceedings of the Fifth International Conference on Logic Programming. 1070–1080.",
      "citeRegEx" : "Gelfond and Lifschitz.,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz.",
      "year" : 1988
    }, {
      "title" : "New operators for theory change",
      "author" : [ "Sven Ove Hansson." ],
      "venue" : "Theoria 55, 2 (1989), 114–132.",
      "citeRegEx" : "Hansson.,? 1989",
      "shortCiteRegEx" : "Hansson.",
      "year" : 1989
    }, {
      "title" : "Belief contraction without recovery",
      "author" : [ "Sven Ove Hansson." ],
      "venue" : "Studia Logica 50, 2 (1991), 251–260.",
      "citeRegEx" : "Hansson.,? 1991",
      "shortCiteRegEx" : "Hansson.",
      "year" : 1991
    }, {
      "title" : "Reversing the Levi identity",
      "author" : [ "Sven Ove Hansson." ],
      "venue" : "Journal of Philosophical Logic 22, 6 (1993), 637–669.",
      "citeRegEx" : "Hansson.,? 1993",
      "shortCiteRegEx" : "Hansson.",
      "year" : 1993
    }, {
      "title" : "Semi-revision",
      "author" : [ "Sven Ove Hansson." ],
      "venue" : "Journal of Applied Non-Classical Logics 7, 1–2 (1997), 151–175.",
      "citeRegEx" : "Hansson.,? 1997",
      "shortCiteRegEx" : "Hansson.",
      "year" : 1997
    }, {
      "title" : "A Textbook of Belief Dynamics",
      "author" : [ "Sven Ove Hansson." ],
      "venue" : "Theory Change and Database Updating. Kluwer.",
      "citeRegEx" : "Hansson.,? 1999",
      "shortCiteRegEx" : "Hansson.",
      "year" : 1999
    }, {
      "title" : "Local change",
      "author" : [ "Sven Ove Hansson", "Renata Wassermann." ],
      "venue" : "Studia Logica 70, 1 (2002), 49–76.",
      "citeRegEx" : "Hansson and Wassermann.,? 2002",
      "shortCiteRegEx" : "Hansson and Wassermann.",
      "year" : 2002
    }, {
      "title" : "Rational conceptual change",
      "author" : [ "William L. Harper." ],
      "venue" : "PSA: Proceedings of the Biennial Meeting of the Philosophy of Science Association Two: Symposia and Invited Papers (1976), 462–494.",
      "citeRegEx" : "Harper.,? 1976",
      "shortCiteRegEx" : "Harper.",
      "year" : 1976
    }, {
      "title" : "Equivalence of logic programs under updates",
      "author" : [ "Katsumi Inoue", "Chiaki Sakama." ],
      "venue" : "Logics in Artificial Intelligence. Lecture Notes in Computer Science, Vol. 3229. 174–186.",
      "citeRegEx" : "Inoue and Sakama.,? 2004",
      "shortCiteRegEx" : "Inoue and Sakama.",
      "year" : 2004
    }, {
      "title" : "Propositional knowledge base revision and minimal change",
      "author" : [ "Hirofumi Katsuno", "Alberto O. Mendelzon." ],
      "venue" : "Artificial Intelligence 52, 3 (1991), 263–294.",
      "citeRegEx" : "Katsuno and Mendelzon.,? 1991",
      "shortCiteRegEx" : "Katsuno and Mendelzon.",
      "year" : 1991
    }, {
      "title" : "On the difference between updating a knowledge base and revising it",
      "author" : [ "Hirofumi Katsuno", "Alberto O. Mendelzon." ],
      "venue" : "Belief revision, Peter Gärdenfors (Ed.). Chapter 7, 183–203.",
      "citeRegEx" : "Katsuno and Mendelzon.,? 1992",
      "shortCiteRegEx" : "Katsuno and Mendelzon.",
      "year" : 1992
    }, {
      "title" : "Predicate logic as a programming language",
      "author" : [ "Robert Kowalski." ],
      "venue" : "Proceedings of the IFIP Congress. 569–574.",
      "citeRegEx" : "Kowalski.,? 1974",
      "shortCiteRegEx" : "Kowalski.",
      "year" : 1974
    }, {
      "title" : "Belief base change operations for answer set programming",
      "author" : [ "Patrick Krümpelmann", "Gabriele Kern-Isberner." ],
      "venue" : "Logics in Artificial Intelligence. Lecture Notes in Computer Science, Vol. 7519. 294–306.",
      "citeRegEx" : "Krümpelmann and Kern.Isberner.,? 2012",
      "shortCiteRegEx" : "Krümpelmann and Kern.Isberner.",
      "year" : 2012
    }, {
      "title" : "Generalizing updates: From models to programs",
      "author" : [ "João Alexandre Leite", "Luı́s Moniz Pereira" ],
      "venue" : "In Logic Programming and Knowledge Representation. Lecture Notes in Computer Science,",
      "citeRegEx" : "Leite and Pereira.,? \\Q1998\\E",
      "shortCiteRegEx" : "Leite and Pereira.",
      "year" : 1998
    }, {
      "title" : "Subjunctives, dispositions and chances",
      "author" : [ "Isaac Levi." ],
      "venue" : "Dispositions. Synthese Library, Vol. 113. 303– 335.",
      "citeRegEx" : "Levi.,? 1977",
      "shortCiteRegEx" : "Levi.",
      "year" : 1977
    }, {
      "title" : "The Enterprise of Knowledge: An Essay on Knowledge, Credal Probability, and Chance",
      "author" : [ "Isaac Levi." ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Levi.,? 1980",
      "shortCiteRegEx" : "Levi.",
      "year" : 1980
    }, {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "Vladimir Lifschitz", "David Pearce", "Agustı́n Valverde" ],
      "venue" : "ACM Transactions on Computational Logic 2,",
      "citeRegEx" : "Lifschitz et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 2001
    }, {
      "title" : "Foundations of Logic Programming",
      "author" : [ "John W. Lloyd." ],
      "venue" : "Springer-Verlag New York.",
      "citeRegEx" : "Lloyd.,? 1987",
      "shortCiteRegEx" : "Lloyd.",
      "year" : 1987
    }, {
      "title" : "On the status of the postulate of recovery in the logic of theory change",
      "author" : [ "David Makinson." ],
      "venue" : "Journal of Philosophical Logic 16, 4 (1987), 383–394.",
      "citeRegEx" : "Makinson.,? 1987",
      "shortCiteRegEx" : "Makinson.",
      "year" : 1987
    }, {
      "title" : "Screened revision",
      "author" : [ "David Makinson." ],
      "venue" : "Theoria 63, 1–2 (1997), 14–23.",
      "citeRegEx" : "Makinson.,? 1997",
      "shortCiteRegEx" : "Makinson.",
      "year" : 1997
    }, {
      "title" : "Programs with common sense",
      "author" : [ "John McCarthy." ],
      "venue" : "Proceedings of the Symposium on Mechanisation of Thought Processes. 77–84.",
      "citeRegEx" : "McCarthy.,? 1958",
      "shortCiteRegEx" : "McCarthy.",
      "year" : 1958
    }, {
      "title" : "Foundational belief change",
      "author" : [ "Abhaya C. Nayak." ],
      "venue" : "Journal of Philosophical Logic 23, 5 (1994), 495–533.",
      "citeRegEx" : "Nayak.,? 1994",
      "shortCiteRegEx" : "Nayak.",
      "year" : 1994
    }, {
      "title" : "Multiple contraction",
      "author" : [ "Reinhard Niederée." ],
      "venue" : "A further case against Gärdenfors’ principle of recovery. In The Logic of Theory Change. Lecture Notes in Computer Science, Vol. 465. 322–334.",
      "citeRegEx" : "Niederée.,? 1991",
      "shortCiteRegEx" : "Niederée.",
      "year" : 1991
    }, {
      "title" : "Updates in answer set programming: An approach based on basic structural properties",
      "author" : [ "Mauricio Osorio", "Vı́ctor Cuevas" ],
      "venue" : "Theory and Practice of Logic Programming 7,",
      "citeRegEx" : "Osorio and Cuevas.,? \\Q2007\\E",
      "shortCiteRegEx" : "Osorio and Cuevas.",
      "year" : 2007
    }, {
      "title" : "Beliefs, Belief Revision, and Splitting Languages",
      "author" : [ "Rohit Parikh." ],
      "venue" : "Logic, Language and Computation 2 (1999), 266–278.",
      "citeRegEx" : "Parikh.,? 1999",
      "shortCiteRegEx" : "Parikh.",
      "year" : 1999
    }, {
      "title" : "Modellings for belief change: Base contraction, multiple contraction, and epistemic entrenchment (Preliminary report)",
      "author" : [ "Hans Rott." ],
      "venue" : "Logics in Artificial Intelligence. Lecture Notes in Computer Science, Vol. 633. 139–153.",
      "citeRegEx" : "Rott.,? 1992",
      "shortCiteRegEx" : "Rott.",
      "year" : 1992
    }, {
      "title" : "Nonmonotonic reasoning by minimal belief revision",
      "author" : [ "Ken Satoh." ],
      "venue" : "Proceedings of the International Conference on Fifth Generation Computer Systems. 455–462.",
      "citeRegEx" : "Satoh.,? 1988",
      "shortCiteRegEx" : "Satoh.",
      "year" : 1988
    }, {
      "title" : "A semantic framework for preference handling in answer set programming",
      "author" : [ "Torsten Schaub", "Kewen Wang." ],
      "venue" : "Theory and Practice of Logic Programming 3, 4–5 (2003), 569–607.",
      "citeRegEx" : "Schaub and Wang.,? 2003",
      "shortCiteRegEx" : "Schaub and Wang.",
      "year" : 2003
    }, {
      "title" : "Characterization theorems for revision of logic programs",
      "author" : [ "Nicolas Schwind", "Katsumi Inoue." ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning. Lecture Notes in Computer Science, Vol. 8148. 485– 498.",
      "citeRegEx" : "Schwind and Inoue.,? 2013",
      "shortCiteRegEx" : "Schwind and Inoue.",
      "year" : 2013
    }, {
      "title" : "Updates of hybrid knowledge bases",
      "author" : [ "Martin Slota." ],
      "venue" : "Ph.D. Dissertation. Universidade Nova de Lisboa.",
      "citeRegEx" : "Slota.,? 2012",
      "shortCiteRegEx" : "Slota.",
      "year" : 2012
    }, {
      "title" : "Robust equivalence models for semantic updates of answer-set programs",
      "author" : [ "Martin Slota", "João Leite." ],
      "venue" : "Principles of Knowledge Representation and Reasoning: Proceedings of the Thirteenth International Conference, KR 2012. 158–168.",
      "citeRegEx" : "Slota and Leite.,? 2012",
      "shortCiteRegEx" : "Slota and Leite.",
      "year" : 2012
    }, {
      "title" : "The rise and fall of semantic rule updates based on SE-models",
      "author" : [ "Martin Slota", "João Leite." ],
      "venue" : "Theory and Practice of Logic Programming FirstView (2013), 1–39.",
      "citeRegEx" : "Slota and Leite.,? 2013",
      "shortCiteRegEx" : "Slota and Leite.",
      "year" : 2013
    }, {
      "title" : "Strong equivalence made easy: Nested expressions and weight constraints",
      "author" : [ "Hudson Turner." ],
      "venue" : "Theory and Practice of Logic Programming 3, 4 (2003), 609–622.",
      "citeRegEx" : "Turner.,? 2003",
      "shortCiteRegEx" : "Turner.",
      "year" : 2003
    }, {
      "title" : "Resource-bounded belief revision",
      "author" : [ "Renata Wassermann." ],
      "venue" : "Ph.D. Dissertation. Universiteit van Amsterdam.",
      "citeRegEx" : "Wassermann.,? 2000",
      "shortCiteRegEx" : "Wassermann.",
      "year" : 2000
    }, {
      "title" : "On AGM for non-classical logics",
      "author" : [ "Renata Wassermann." ],
      "venue" : "Journal of Philosophical Logic 40, 2 (2011), 271–294.",
      "citeRegEx" : "Wassermann.,? 2011",
      "shortCiteRegEx" : "Wassermann.",
      "year" : 2011
    }, {
      "title" : "On the logic of theory base change",
      "author" : [ "Mary-Anne Williams." ],
      "venue" : "Logics in Artificial Intelligence. Lecture Notes in Computer Science, Vol. 838. 86–105.",
      "citeRegEx" : "Williams.,? 1994",
      "shortCiteRegEx" : "Williams.",
      "year" : 1994
    }, {
      "title" : "Sound and complete inference rules for SE-consequence",
      "author" : [ "Ka-Shu Wong." ],
      "venue" : "Journal of Artificial Intelligence Research 31 (2008), 205–216.",
      "citeRegEx" : "Wong.,? 2008",
      "shortCiteRegEx" : "Wong.",
      "year" : 2008
    }, {
      "title" : "Reconsidering AGMstyle belief revision in the context of logic programs",
      "author" : [ "Zhiqiang Zhuang", "James P. Delgrande", "Abhaya C. Nayak", "Abdul Sattar." ],
      "venue" : "Proceedings of the 22nd European Conference on Artificial Intelligence, ECAI 2016. 671–679.",
      "citeRegEx" : "Zhuang et al\\.,? 2016",
      "shortCiteRegEx" : "Zhuang et al\\.",
      "year" : 2016
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "change [Doyle 1979; Fagin et al. 1983; Gärdenfors 1988; Hansson 1999; Harper 1976; Levi 1980] concerns itself exactly with these kinds of dynamics in knowledge bases.",
      "startOffset" : 7,
      "endOffset" : 93
    }, {
      "referenceID" : 0,
      "context" : "An important endeavour to guide change operations on a knowledge base and by now the most widely-adopted belief change paradigm is the so-called AGM framework, named after the initials of the author trio [Alchourrón et al. 1985].",
      "startOffset" : 204,
      "endOffset" : 228
    }, {
      "referenceID" : 6,
      "context" : "A breakthrough arrived with the distance-based approach [Delgrande et al. 2013] to logic program revision, which rests upon characterising an agent’s beliefs in terms of the set of SE (strong equivalence) models [Lifschitz et al.",
      "startOffset" : 56,
      "endOffset" : 79
    }, {
      "referenceID" : 37,
      "context" : "2013] to logic program revision, which rests upon characterising an agent’s beliefs in terms of the set of SE (strong equivalence) models [Lifschitz et al. 2001; Turner 2003] of a logic program.",
      "startOffset" : 138,
      "endOffset" : 174
    }, {
      "referenceID" : 0,
      "context" : "An important endeavour to guide change operations on a knowledge base and by now the most widely-adopted belief change paradigm is the so-called AGM framework, named after the initials of the author trio [Alchourrón et al. 1985]. It classifies the possible changes to a knowledge base as expansion, revision, and contraction operations. In an expansion, new information is incorporated into a knowledge base, regardless of any inconsistencies that may arise. A revision operation also incorporates new information into a knowledge base, but in such a way that the resulting knowledge base is consistent. This is achieved by discarding some existing information. During a contraction, no new information is added to a knowledge base but some existing information is removed from it. On the one hand, the framework provides a set of postulates that each rational change operator should satisfy, and, on the other hand, defines specific constructions of expansion, revision, and contraction that satisfy these criteria. While the underlying assumption of the AGM framework is that any information implied by a knowledge base is represented explicitly in the knowledge base, the belief base framework of belief change [Fuhrmann 1991; Hansson 1989; Rott 1992] does not require this assumption. Postulates and constructions for expansion, revision, and contraction operators in the belief base framework have been defined to complement those from the AGM model (Hansson [1999] provides a summary).",
      "startOffset" : 205,
      "endOffset" : 1471
    }, {
      "referenceID" : 0,
      "context" : "An important endeavour to guide change operations on a knowledge base and by now the most widely-adopted belief change paradigm is the so-called AGM framework, named after the initials of the author trio [Alchourrón et al. 1985]. It classifies the possible changes to a knowledge base as expansion, revision, and contraction operations. In an expansion, new information is incorporated into a knowledge base, regardless of any inconsistencies that may arise. A revision operation also incorporates new information into a knowledge base, but in such a way that the resulting knowledge base is consistent. This is achieved by discarding some existing information. During a contraction, no new information is added to a knowledge base but some existing information is removed from it. On the one hand, the framework provides a set of postulates that each rational change operator should satisfy, and, on the other hand, defines specific constructions of expansion, revision, and contraction that satisfy these criteria. While the underlying assumption of the AGM framework is that any information implied by a knowledge base is represented explicitly in the knowledge base, the belief base framework of belief change [Fuhrmann 1991; Hansson 1989; Rott 1992] does not require this assumption. Postulates and constructions for expansion, revision, and contraction operators in the belief base framework have been defined to complement those from the AGM model (Hansson [1999] provides a summary). While the AGM and belief base frameworks have been applied to a variety of knowledge representation formalisms (an overview is given by Wassermann [2011]), work on an adaptation to knowledge representation in the form of logic programs [Colmerauer and Roussel 1996; Kowalski 1974; Lloyd 1987] has been slow to progress.",
      "startOffset" : 205,
      "endOffset" : 1646
    }, {
      "referenceID" : 1,
      "context" : "Preliminary results from Sections 5 and 8 were presented in a conference paper [Binnewies et al. 2015].",
      "startOffset" : 79,
      "endOffset" : 102
    }, {
      "referenceID" : 37,
      "context" : "Given two programs P andQ, we say that P is strongly equivalent [Lifschitz et al. 2001] to Q, denoted by P ≡s Q, iff SE(P ) = SE(Q), and P implies Q, denoted by P |=s Q, iff SE(P ) ⊆ SE(Q).",
      "startOffset" : 64,
      "endOffset" : 87
    }, {
      "referenceID" : 0,
      "context" : "The AGM framework [Alchourrón et al. 1985; Gärdenfors 1988] defines expansion, revision, and contraction as the change operations on a body of beliefs held by an agent, called a belief state henceforth, in light of some new information.",
      "startOffset" : 18,
      "endOffset" : 59
    }, {
      "referenceID" : 17,
      "context" : "The appropriateness of the Recovery postulate (⊖5) within this set of contraction postulates has been discussed intensively [Fuhrmann 1991; Hansson 1991; Makinson 1987; Nayak 1994; Niederée 1991]. To replace the Recovery postulate in expressing that no beliefs should be retracted unduly during a contraction operation, alternative postulates were proposed. Hansson [1991] offered the following postulate:",
      "startOffset" : 125,
      "endOffset" : 373
    }, {
      "referenceID" : 16,
      "context" : "More recently, Fermé et al. [2008] presented the following Disjunctive Elimination postulate (⊖5de):",
      "startOffset" : 15,
      "endOffset" : 35
    }, {
      "referenceID" : 16,
      "context" : "In the presence of (⊖2)–(⊖3), (⊖5r) is equivalent to (⊖5de) in propositional logic [Fermé et al. 2008].",
      "startOffset" : 83,
      "endOffset" : 102
    }, {
      "referenceID" : 0,
      "context" : "One of the classic constructions to implement belief change is partial meet contraction [Alchourrón et al. 1985], which we recapitulate here.",
      "startOffset" : 88,
      "endOffset" : 112
    }, {
      "referenceID" : 0,
      "context" : "[Alchourrón et al. 1985] For any belief set K, ⊖γ is a partial meet contraction operator for K iff ⊖γ satisfies (⊖1)–(⊖6).",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "[Alchourrón et al. 1985] For any belief set K, ⊖γ′ is a transitively relational partial meet contraction operator for K iff ⊖γ′ satisfies (⊖1)–(⊖8).",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 18,
      "context" : "A corresponding (transitively relational) partial meet revision operator ⊛γ (⊛γ′) that satisfies (⊛1)–(⊛6) ((⊛1)–(⊛8)) can be obtained from a (transitively relational) partial meet contraction operator via the Levi identity: K ⊛ φ = (K ⊖ ¬φ) ⊕ φ [Gärdenfors 1981; Levi 1977]. The inverse identity, which constructs a contraction operator from a revision operator, is due to Harper [1976]: K ⊖ φ = K ∩ (K ⊛ ¬φ).",
      "startOffset" : 247,
      "endOffset" : 388
    }, {
      "referenceID" : 17,
      "context" : "Belief bases [Fuhrmann 1991; Hansson 1989; Rott 1992] are an alternative representation of belief states. A belief base is a set of sentences from L that is not necessarily closed under logical consequence. Hansson [1993] defined a partial meet base contraction operator −γ for a belief base B as B −γ φ = ⋂",
      "startOffset" : 14,
      "endOffset" : 222
    }, {
      "referenceID" : 22,
      "context" : "[Hansson 1993] For any belief base B, >γ is a partial meet base revision operator for B iff >γ satisfies (>1)–(>5). The pendants to (>1) and (>2) in the AGM framework are (⊛2) and (⊛3), respectively. (>3) requires ψ to only be removed from B if it would otherwise make the revision outcome inconsistent. (>4) mandates that if any parts of B which are consistent with φ are also consistent with ψ, then the same parts of B will be retained in a revision by φ as in a revision by ψ. (>5) is a weaker version of (⊛5). Williams [1994] proposed further belief change operators for belief bases, which rely on an ordering over the sentences contained in a belief base, called ensconcement.",
      "startOffset" : 1,
      "endOffset" : 531
    }, {
      "referenceID" : 16,
      "context" : "[Fermé et al. 2008] Let B be a belief base and ⊖4 an ensconcement contraction operator for B.",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 16,
      "context" : "In the belief base framework, the relationship between (−3) and (−8) is different to the one between (⊖5r) and (⊖5de) in the AGM framework: (−3) implies (−8) but not vice versa [Fermé et al. 2008].",
      "startOffset" : 177,
      "endOffset" : 196
    }, {
      "referenceID" : 16,
      "context" : "Please note that the proof of the representation theorem (Theorem 14 in [Fermé et al. 2008]) contains an error, as acknowledged by the authors.",
      "startOffset" : 72,
      "endOffset" : 91
    }, {
      "referenceID" : 6,
      "context" : "One of the key developments for adapting the AGM framework of belief change to logic programs came with the distance-based approach to logic program revision [Delgrande et al. 2013].",
      "startOffset" : 158,
      "endOffset" : 181
    }, {
      "referenceID" : 6,
      "context" : "[Delgrande et al. 2013] Let P,Q ∈ LPA.",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 4,
      "context" : "The approach adapts two revision operators from classic belief change to logic programs, namely, Dalal’s revision operator [Dalal 1988] and Satoh’s revision operator [Satoh 1988]. Informally, to revise a program P by a program Q, the operators return those SE models from the set of SE models of Q that are closest to the SE models of P , where closeness is determined by Dalal’s or Satoh’s notion of distance. Delgrande et al. [2013] identified that the adaptation of Satoh’s revision operator gives more intuitive results than the adaptation of Dalal’s revision operator, so we will focus on the former here.",
      "startOffset" : 97,
      "endOffset" : 435
    }, {
      "referenceID" : 6,
      "context" : "[Delgrande et al. 2013] The revision operator ⋆ satisfies (∗1m)–(∗5m).",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 6,
      "context" : "The distance-based approach was extended by two representation theorems [Delgrande et al. 2013; Schwind and Inoue 2013], stating that any logic program revision operator satisfying (∗1m)–(∗6m) plus some additional conditions can be characterised by some preorder over a set of SE models.",
      "startOffset" : 72,
      "endOffset" : 119
    }, {
      "referenceID" : 5,
      "context" : "The program-level approach to logic program revision [Delgrande 2010] is also based on answer set semantics and assumes the beliefs that make up a belief state to be the answer sets of a program. The revision operation relies on extending the standard answer set semantics to three-valued answer set semantics for determining the outcome. To revise a program P by a program Q, for each three-valued answer set X of Q, all maximal subsets R of P are selected such that X is a subset of each three-valued answer set X ′ of R ∪Q. The revision operation returns a set of answer sets that correspond to each X ′ as the result. In the author’s view, the AGM revision postulates (⊛3), (⊛4), (⊛7), and (⊛8) are inappropriate in the context of nonmonotonic semantics. An adaptation of the remaining postulates is fulfilled by the revision operation. The work of Zhuang et al. [2016] concerns itself with the revision of a disjunctive logic program by another.",
      "startOffset" : 54,
      "endOffset" : 874
    }, {
      "referenceID" : 8,
      "context" : "Thus, it is conceivable to express the revision of P by Q as (P ∪ Q,<), where < is some appropriate preference ordering on P ∪ Q (from [Delgrande et al. 2007], for example), and employ one of the different semantics proposed [Brewka and Eiter 1999; Delgrande et al.",
      "startOffset" : 135,
      "endOffset" : 158
    }, {
      "referenceID" : 7,
      "context" : "2007], for example), and employ one of the different semantics proposed [Brewka and Eiter 1999; Delgrande et al. 2003; Schaub and Wang 2003] to obtain the preferred answer sets of this ordered logic program.",
      "startOffset" : 72,
      "endOffset" : 140
    }, {
      "referenceID" : 7,
      "context" : "An ordered logic program can be transformed into a standard logic program, so that the preferred answer sets of the former are exactly the answer sets of the latter [Delgrande et al. 2003].",
      "startOffset" : 165,
      "endOffset" : 188
    }, {
      "referenceID" : 9,
      "context" : ", may have no answer sets, even if P and Q themselves are consistent [Delgrande et al. 2004].",
      "startOffset" : 69,
      "endOffset" : 92
    }, {
      "referenceID" : 4,
      "context" : "The landscape of update operators has already been reviewed exhaustively in other places, for example, detailed overviews are given by Delgrande et al. [2004] and Slota [2012].",
      "startOffset" : 135,
      "endOffset" : 159
    }, {
      "referenceID" : 4,
      "context" : "The landscape of update operators has already been reviewed exhaustively in other places, for example, detailed overviews are given by Delgrande et al. [2004] and Slota [2012]. Of interest in the current context is the exception-based update approach [Slota and Leite 2012], which introduces RE (robust equivalence) models as an extension of SE models.",
      "startOffset" : 135,
      "endOffset" : 176
    }, {
      "referenceID" : 14,
      "context" : "Even though a consequence relation for logic programs under SE semantics exists [Eiter et al. 2004; Wong 2008], logic programs are per se not closed under logical consequence.",
      "startOffset" : 80,
      "endOffset" : 110
    }, {
      "referenceID" : 13,
      "context" : "Besides adaptations for the purpose of logic program ‘update’ operations under answer set semantics [Eiter et al. 2002] or N2 logic [Osorio and Cuevas 2007], we find that postulates for logic program revision have usually been built on the formula-based revision postulates (⊛1KM)–(⊛6KM) until now [Delgrande et al.",
      "startOffset" : 100,
      "endOffset" : 119
    }, {
      "referenceID" : 6,
      "context" : "2002] or N2 logic [Osorio and Cuevas 2007], we find that postulates for logic program revision have usually been built on the formula-based revision postulates (⊛1KM)–(⊛6KM) until now [Delgrande et al. 2013; Delgrande et al. 2013; Schwind and Inoue 2013].",
      "startOffset" : 184,
      "endOffset" : 254
    }, {
      "referenceID" : 6,
      "context" : "2002] or N2 logic [Osorio and Cuevas 2007], we find that postulates for logic program revision have usually been built on the formula-based revision postulates (⊛1KM)–(⊛6KM) until now [Delgrande et al. 2013; Delgrande et al. 2013; Schwind and Inoue 2013].",
      "startOffset" : 184,
      "endOffset" : 254
    }, {
      "referenceID" : 0,
      "context" : "As the basis for our construction of partial meet revision, we define a compatible set of some program with respect to another program as the dual of a remainder set [Alchourrón et al. 1985].",
      "startOffset" : 166,
      "endOffset" : 190
    }, {
      "referenceID" : 12,
      "context" : "Corresponding canonical logic programs can be constructed via the method provided by Eiter et al. [2013].",
      "startOffset" : 85,
      "endOffset" : 105
    }, {
      "referenceID" : 16,
      "context" : "− satisfies the same set of belief base postulates as its counterpart for propositional logic [Fermé et al. 2008], that is, ( .",
      "startOffset" : 94,
      "endOffset" : 113
    } ],
    "year" : 2017,
    "abstractText" : "Recent methods have adapted the well-established AGM and belief base frameworks for belief change to cover belief revision in logic programs. In this study here, we present two new sets of belief change operators for logic programs. They focus on preserving the explicit relationships expressed in the rules of a program, a feature that is missing in purely semantic approaches that consider programs only in their entirety. In particular, operators of the latter class fail to satisfy preservation and support, two important properties for belief change in logic programs required to ensure intuitive results. We address this shortcoming of existing approaches by introducing partial meet and ensconcement constructions for logic program belief change, which allow us to define syntax-preserving operators that satisfy preservation and support. Our work is novel in that our constructions not only preserve more information from a logic program during a change operation than existing ones, but they also facilitate natural definitions of contraction operators, the first in the field to the best of our knowledge. In order to evaluate the rationality of our operators, we translate the revision and contraction postulates from the AGM and belief base frameworks to the logic programming setting. We show that our operators fully comply with the belief base framework and formally state the interdefinability between our operators. We further propose an algorithm that is based on modularising a logic program to reduce partial meet and ensconcement revisions or contractions to performing the operation only on the relevant modules of that program. Finally, we compare our approach to two state-of-the-art logic program revision methods and demonstrate that our operators address the shortcomings of one and generalise the other method.",
    "creator" : "dvips(k) 5.996 Copyright 2016 Radical Eye Software"
  }
}