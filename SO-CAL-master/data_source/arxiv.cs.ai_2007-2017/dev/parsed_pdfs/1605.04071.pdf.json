{
  "name" : "1605.04071.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Bayesian Network Structure Learning with Integer Programming: Polytopes, Facets, and Complexity",
    "authors" : [ "James Cussens", "Matti Järvisalo", "Janne H. Korhonen", "Mark Bartlett" ],
    "emails" : [ "james.cussens@york.ac.uk", "matti.jarvisalo@helsinki.fi", "korhonen@ru.is", "mark.bartlett@york.ac.uk" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "The study of probabilistic graphical models is a central topic in modern artificial intelligence research. Bayesian networks (Koller & Friedman, 2009) form a central class of probabilistic graphical models that finds applications in various domains (Hugin, 2016; Sheehan et al., 2014). A central problem related to Bayesian networks (BNs) is that of learning them from data. An essential part of this learning problem is to learn the structure of a\nc©2016 AI Access Foundation. All rights reserved.\nar X\niv :1\n60 5.\n04 07\n1v 1\n[ cs\nBayesian network—represented as a directed acyclic graph—that accurately represents the joint probability distribution underlying the data.\nThere are two principal approaches to Bayesian network learning: constraint-based and score-based. In the constraint-based approach (Spirtes et al., 1993; Colombo et al., 2012) the goal is to learn a network which is consistent with conditional independence relations which have been inferred from the data. The score-based approach to Bayesian network structure learning (BNSL) treats the BNSL problem as a combinatorial optimization problem of finding a BN structure that optimises a score function for given data.\nLearning an optimal BN structure is a central but computationally challenging problem. Even when the score function is restricted to be a BDe score (Heckerman et al., 1995), the BNSL problem has been shown to be NP-hard (Chickering, 1996). Due to NPhardness, much work on BNSL has focused on developing approximate, local search style algorithms (Tsamardinos et al., 2006) that most often cannot give guarantees on how close to optimal, in terms of the objective function, are the structures found. Recently, despite its complexity, several advances in exact approaches to BNSL have surfaced (Koivisto & Sood, 2004; Silander & Myllymäki, 2006; Cussens, 2011; de Campos & Ji, 2011; Yuan & Malone, 2013; van Beek & Hoffmann, 2015), ranging from problem-specific dynamic programming branch-and-bound algorithms to approaches based on A∗-style state-space search, constraint programming, and integer linear programming (IP), which can, with certain restrictions, learn provably-optimal BN structures with tens to hundreds of nodes.\nAs shown in a recent study (Malone et al., 2014), perhaps the most successful exact approach to BNSL is provided by the gobnilp system (Cussens, 2011). gobnilp implements a branch-and-cut approach to BNSL, using state-of-the-art IP solving techniques together with specialised BNSL cutting planes. The focus of this work is on providing further understanding on the IP approach to BNSL from the theoretical perspective.\nViewed as a constrained optimization problem, a central source of intractability of BNSL is the acyclicity constraint imposed on BN structures. In the IP approach to BNSL— as implemented by gobnilp—the acyclicity constraint is handled in the branch-and-cut framework via deriving specialised cutting planes called cluster constraints. These cutting planes are found by solving a sequence of so-called sub-IPs arising from solutions to linear relaxations of the underlying IP formulation of BNSL without the acyclicity constraint. Finding these cutting planes is an example of a separation problem for a linear relaxation solution, so called since the cutting plane will separate that solution from the set of feasible solutions to the original (unrelaxed) problem. Understanding fundamental aspects of these cutting planes and the sub-IPs used to find them is important not only from a purely theoretical perspective, but also since it holds out the promise of further improving the efficiency of state-of-the-art approaches to solving BNSL exactly. This is the focus of and underlying motivation for this article.\nThe main contributions of this article are the following.\n• We study the computational complexity of the separation problem solved via sub-IPs with connections to the general separation problem for integer programs. As a main result, in Section 5 we establish that the sub-IPs are themselves NP-hard to solve. From the practical perspective, this both gives a theoretical justification for applying an exact IP solver to solve the sub-IPs within gobnilp, as well as motivating further\nwork on improving the efficiency of the sub-IP solving via either improved exact techniques and/or further approximate algorithms.\n• We formalise and analyse the relationship between three key polytopes underlying the IP-based approach to BNSL in Section 4. Stated in generic abstract terms, starting from the digraph polytope defined by a linear relaxation of the IP formulation without the acyclicity constraint, the search progresses towards an optimal BN structure via refining the digraph polytope towards the family-variable polytope, i.e., the convex hull of acyclic digraphs over the set of nodes in question. The complete set of cluster constraints gives rise to the cluster polytope as an intermediate.\n• We study the facets of the three polytopes both from the theoretical and practical perspective (Section 6). As a key theoretical result, we show that cluster constraints are in fact facet-defining inequalities of the family-variable polytope. From the more practical perspective, achieved via exhaustive computation, we provide a complete enumeration of facets for low-dimensional family-variable polytopes. Mapping to practice, explicit knowledge of such facets has the potential for providing further speed-ups in state-of-the-art BNSL solving by integrating (some of) these facets explicitly into search.\n• In Section 7 we derive facets of polytopes corresponding to (i) BNs consistent with a given node ordering and (ii) BNs with specified sink nodes. We then use the results on sink nodes to show how a family-variable polytope for p nodes can be constructed from a family-variable polytope for p−1 nodes using the technique of lift-and-project.\n• Finally, in Section 8 we provide a tight connection of the BNSL problem to the acyclic subgraph problem, as well as discussing the connection of the polytope underlying this problem to the three central polytopes underlying BNSL.\nBefore detailing the main contributions, we recall the BNSL problem in Section 2 and discuss the integer programming based approach to BNSL, central to this work, in Section 3."
    }, {
      "heading" : "2. Bayesian Network Structure Learning",
      "text" : "In this section, we recall the problem of learning optimal Bayesian network structures in the central score-based setting."
    }, {
      "heading" : "2.1 Bayesian Networks",
      "text" : "A Bayesian network represents a joint probability distribution over a set of random variables V . A Bayesian network consists of a structure and parameters.\n• The structure is an acyclic digraph (V,B) over the set V with directed edges B. The structure defines the conditional dependencies between the variables in V ; for edge i← j ∈ B we say that i is a child of j and j is a parent of i, and for a variable i ∈ V , we denote the set of parents of i by Pa(i, B).\n• The parameters define a distribution for each of random variables i ∈ V given the parents Pa(i, B), that is, the probabilities Pr ( i | Pa(i, B) ) .\nAs mentioned before, our focus is on learning Bayesian networks from data. Specifically, we focus on the Bayesian network structure learning (BNSL) problem, as once a BN structure has been decided, the parameters can be learned from the data in a straightforward manner."
    }, {
      "heading" : "2.2 Score-based BNSL",
      "text" : "In the integer programming based approach to BNSL which is the focus of this work, the learning problem is cast as a constrained optimisation problem: each candidate BN structure has a score measuring how well it ‘explains’ the given data and the task is to find a BN structure which maximises that score. This score function is defined in terms of the data, but for our purposes, it is sufficient to abstract away the details, see e.g. Koller and Friedman (2009).\nSpecifically, in this paper we restrict attention to decomposable score functions, where the score is defined locally by the parent set choices for each i ∈ V . That is, for i ∈ V and J ⊆ V \\ {i}, let i ← J denote the the pair (i, J), called a family. In our framework, we assume that the score function gives a local score ci←J for each family i ← J . This then defines a global score z(B) for each candidate structure (V,B) as\nz(B) = ∑ i∈V ci←Pa(i,B) (1)\nand we want to find the digraph (V,B) maximising z(B).\nIn practice, we typically want to restrict the set of parent sets in some way, given the large number of possible parents sets and the NP-hardness of BSNL. Typically this is done by limiting the cardinality of any candidate parent set, although other restrictions, perhaps reflecting prior knowledge, are also used. To facilitate this, we assume that a BSNL instance also defines a set of permissible parent sets P(i) ⊆ 2V \\{i} for each node i. For simplicity we shall only consider BNSL problems where ∅ ∈ P(i) for all nodes. This also ensures that the empty graph, at least, is a permitted BN structure. Thus, the full formulation of the BSNL problem is as follows.\nDefinition 1 (BSNL). A BSNL instance is a tuple (V,P, c), where\n1. V is a set of nodes;\n2. P : V → 22V is a function where, for each vertex i ∈ V , P(i) ⊆ 2V \\{i} is the set of permissible parent sets for that vertex, and ∅ ∈ P(i); and\n3. c is a function giving the local score ci←J for each i ∈ V and J ∈ P(i).\nGiven a BNSL instance (V,P, c), the BSNL problem is to find an edge set B ⊆ V ×V which maximises (1) subject to the following two conditions.\n1. Pa(i, B) ∈ P(i) for all i ∈ V .\n2. (V,B) is acyclic."
    }, {
      "heading" : "2.3 BNSL with Small Parent Sets",
      "text" : "As mentioned, it is common to put an upper bound on the cardinality of permitted parent sets. More precisely, a common setting is that we have a constant κ and the BSNL instances we consider are restricted so that all J ∈ P(i) satisfy |J | ≤ κ. For the rest of the paper we use the convention that κ denotes this parent set size upper bound.\nIn practice, BNSL instances with large node set size can often be solved to optimality fairly quickly when κ is small. For example, with κ = 2, Sheehan et al. (2014) were able to solve BNSL instances with |V | = 1614 in between 3 and 42 minutes. Even though BNSL remains NP-hard unless κ = 1 (Chickering, 1996), such results suggest that in practice the value of κ is an important determining factor of the hardness of a BNSL instance.\nHowever, we will show in the following that the situation is somewhat more subtle; that is, we show that any BNSL instance can be converted to a BNSL instance with κ = 2 and the same set of optimal solutions without significantly increasing the total size |V |+ ∑ i∈V |P(i)| of the instance. This suggests that the practical hardness of BSNL instances is in fact controlled primarily by this total instance size rather than node set size |V |; naturally, with larger κ, a smaller number of nodes is required for a large total size.\nWe first introduce some useful notation identifying the set of families in a BNSL instance. For a given set of nodes V and permitted parent sets P(i), let\nF(V,P) := {i← J | i ∈ V, J ∈ P(i)}, so that ∑\ni∈V |P(i)| = |F(V,P)| and total instance size is |V |+ |F(V,P)|.\nTheorem 2. Given a BNSL instance (V,P, c) with the property that for each i ∈ V , P(i) is downwards-closed, that is, I ⊆ J ∈ P(i) implies I ∈ P(i), we can construct another BNSL instance (V ′,P ′, c′) in time poly ( |V |+ |F(V,P)| ) such that\n1. |V ′| = O ( |V |+ |F(V,P)| ) and |F(V ′,P ′)| = O ( |F(V,P)| ) ,\n2. |J | ≤ 2 for all J ∈ P ′(i) and i ∈ V ′, and\n3. there is one-to-one correspondence between the optimal solutions of (V,P, c) and (V ′,P ′, c′).\nMoreover, the claim holds even when (V,P, c) does not satisfy the downwards-closed property, with bounds |V ′| = O ( |V |+ κ |F(V,P)| ) and |F(V ′,P ′)| = O ( κ |F(V,P)| ) , where κ is the size of the largest parent set permitted by P.\nProof. Given (V,P, c), we construct a new instance (V ′,P ′, c′) as follows. As a first step, we iteratively go through the permissible parent sets J ∈ P(i) for each i ∈ V and add the corresponding new parent set to P ′(i) using the following rules.\n• If |J | ≤ 2, we add J to P ′(i) with score c′i←J = ci←J .\n• If J = {j, k, l}, then we create a new node I ∈ V ′ corresponding to the subset I = {k, l}, and add the set J ′ = {j, I ′} to P ′(i) with score c′i←J ′ = ci←J .\n• If |J | ≥ 4, we partition J into two sets J1 and J2 with |J1| − |J2| ≤ 1 and create new corresponding nodes J1, J2 ∈ V ′. We then add J ′ = {J1, J2} to P ′(i) with score c′i←J ′ = ci←J .\nIn the above steps, new nodes corresponding to subsets of V will be created only once, re-using the same node if it is required multiple times.\nUnless all original parent sets have size at most two, this process will create new nodes J ∈ V ′ corresponding to subsets J ⊆ V with |J | ≥ 2. For each such new node J , we allow exactly one permissible parent set (of size 2) besides the empty set, as follows.\n• If J = {j, k}, then set P ′(J) = {∅, {j, k}}.\n• If J = {j, k, l}, then set P ′(J) = { ∅, {j, {k, l}} } , choosing j arbitrarily and creating a\nnew node {k, l} if necessary.\n• If |J | ≥ 4, then we partition J into some J1 and J2 where |J1| − |J2| ≤ 1 and set P ′(J) = {∅, {J1, J2}}, again creating new nodes J1 and J2 if necessary.\nHowever, we want to disallow the choice of ∅ for all new nodes in all optimal solutions, so we will set c′J←∅ = min ( − |V |,M |V | ) , where M is the minimum score given to any family by c, and set the local score for the other parent set choices to 0.\nThe creation of these parent sets may require the creation of yet further new nodes. If so, we create the permissible parent sets for each of them in the same way, iterating the process as long as necessary. This will clearly terminate, and if (V,P, c) satisfies the downwards-closed property, this will create exactly one new node in V ′ for each original permissible parent set, implying the bounds for |V ′| and |F(V ′,P ′)|. If the original instance does not have the downwards-closed property, the process may create up to |J | new nodes for each original J ∈ P(i), which in turn implies the weaker bound.\nFinally, note that any optimal solution to (V ′,P ′, c′) cannot pick the empty set as a parent set for a node corresponding to a subset of V . It is now not difficult to see that, from any optimal solution to our newly created BNSL instance, we can ‘read off’ an optimal solution to the original instance."
    }, {
      "heading" : "3. An Integer Programming Approach to Bayesian Network Structure",
      "text" : "Learning\nIn this section we discuss integer programming based approaches to BNSL, focusing on the branch-and-cut approach implemented by the gobnilp system for BNSL which motivates the theoretical results presented in this article."
    }, {
      "heading" : "3.1 An Integer Programming Formulation of BNSL",
      "text" : "Recall, from Section 2, that we refer to a node i together with its parent set J as a family. In the IP formulation of BNSL we create a family variable xi←J for each potential family. A family variable is a binary indicator variable: xi←J = 1 if J is the parent set for i and xi←J = 0 otherwise. It is not difficult to see that any digraph (acyclic or otherwise) with |V | nodes can be encoded by a zero-one vector whose components are family variables and where exactly |V | family variables are set to 1. Figure 1 and Table 1 show an example graph and its family variable encoding, respectively.\nAlthough every digraph can thus be encoded as a zero-one vector, it is clearly not the case that each zero-one vector encodes a digraph. The key to the IP approach to BNSL\nis to add appropriate linear constraints so that all and only zero-one vectors representing acyclic digraphs satisfy all the constraints.\nThe most basic constraints are illustrated by the arrangement of the example vector in Table 1 into three rows, one for each node. It is clear that exactly one family variable for each child node must equal one. So we have |V | convexity constraints∑\nJ∈P(i)\nxi←J = 1 ∀i ∈ V. (2)\nIt is not difficult to see that any vector x that satisfies all convexity constraints encodes a digraph. However, without further constraints, the digraph need not be acyclic. There are a number of ways of ruling out cycles (Cussens, 2010; Peharz & Pernkopf, 2012; Cussens et al., 2013). In this paper we focus on cluster constraints first introduced by Jaakkola et al. (2010). A cluster is simply a subset of nodes. For each cluster C ⊆ V (|C| > 1) the associated cluster inequality is ∑\ni∈C ∑ J∈P(i):J∩C=∅ xi←J ≥ 1. (3)\nAn alternative formulation, which exploits the convexity constraints, is∑ i∈C ∑ J∈P(i):J∩C 6=∅ xi←J ≤ |C| − 1. (4)\nTo see that cluster inequalities suffice to rule out cycles, suppose that the nodes in some cluster C formed a cycle; it is clear that in that case the LHS of (3) would be 0, violating the cluster constraint. On the other hand, suppose that x encodes an acyclic digraph. Since the digraph is acyclic, there is an associated total ordering in which parents precede their\nchildren. Let C ⊆ V be an arbitrary cluster. Then the earliest element of C in this ordering will have no parents in C and so the cluster constraint is satisfied.\nIt follows that any zero-one vector x that satisfies the convexity constraints (2) and cluster constraints (3) encodes an acyclic digraph. The final ingredient in the IP approach to BNSL is to specify objective coefficients for each family variable. These are simply the local scores ci←J introduced in Section 2. Collecting these elements together, we can define the IP formulation of the BNSL as follows.\nMaximise ∑\ni∈V,J∈P(i)\nci←Jxi←J (5)\nsubject to ∑\nJ∈P(i) xi←J = 1 ∀i ∈ V (6)∑ i∈C ∑ J∈P(i):J∩C=∅ xi←J ≥ 1 ∀C ⊆ V, |C| > 1 (7)\nxi←J ∈ {0, 1} ∀i ∈ V, J ∈ P(i) (8)\n3.2 The gobnilp System\nThe gobnilp system (https://www.cs.york.ac.uk/aig/sw/gobnilp/) solves the IP problem defined by (5–8) for a given set of objective coefficients ci←J . These coefficients are either given as input to gobnilp or computed by gobnilp from a discrete dataset with no missing values. The gobnilp approach to solving this IP are fully detailed by Bartlett and Cussens (2015); here we overview the essential ideas.\nSince there are only |V | convexity constraints (6), these are added as initial constraints to the IP. The cluster constraints, in contrast, are added as cutting planes. Initially, no cluster constraints (7) are in the IP, so we have a relaxed version of the original problem. Moreover, in its initial phase gobnilp drops the integrality condition (8) on the family variables so that only linear relaxations (i.e. LPs) of IPs are solved.\nThe solution (call it x∗) to the initial LP will be a digraph where a highest scoring parent set for each node is chosen, a digraph which will almost certainly contain cycles. Note that this initial solution happens to be integral, even though it is the solution to an LP not an IP. gobnilp then attempts to find clusters C such that the associated cluster constraint is violated by x∗. These cluster constraints are added to the LP, producing a new LP which is then solved, generating a new solution x∗. The process of LP solving and cluster constraint adding is continued until either (i) an LP solution is produced which corresponds to an acyclic digraph or (ii) this is not the case, but no further cutting planes can be found.\nIn the first (rare) case, the BNSL instance has been solved. The objective value of each x∗ that is produced is an upper bound on the objective value of an optimal digraph (since it is an exact solution to a relaxed version of the original BNSL instance), so if x∗ corresponds to an acyclic digraph it must be optimal.\nIn the second, more typical, case gobnilp stops ignoring the integrality constraint (8) on family variables and exploits it to make progress. If no cluster constraint cutting planes can be found, and the problem has not been solved, then x∗, the solution to the current linear relaxation, must be fractional, i.e. there must be at least one family variable xi←J\nsuch that 0 < x∗i←J < 1. One option is then to branch on such a variable to create two sub-problems: one where xi←J is fixed to 0 and one where it is fixed to 1. Note that x ∗ is infeasible in both sub-problems but there is an optimal solution in at least one of the sub-problems. gobnilp also has the option of branching on sums of mutually exclusive family variables. For example, if we had three nodes i, j and k, gobnilp has the option of branching on xi←{j} + xi←{j,k} + xj←{i} + xj←{i,k}, a quantity which is either 0 or 1 in any acyclic digraph. gobnilp then recursively applies the cutting plane approach to both sub-problems. gobnilp is thus a branch-and-cut approach to IP solving.\nThese are the essentials of the gobnilp system but the current implementation has many other aspects. gobnilp is implemented with the help of the SCIP system (scip. zib.de) (Achterberg, 2007) and it uses SCIP to generate many other cutting planes in addition to cluster constraints. gobnilp also adds in other initial inequalities in addition to the convexity constraints. For example, if we had three nodes i, j and k the inequality xi←{j,k}+xj←{i,k}+xk←{i,j} ≤ 1 would be added. All these extra constraints are redundant in the sense that they do not alter the set of optimal solutions to the IP (5–8). They do, however, have a great effect in the time taken to identify a provably optimal solution."
    }, {
      "heading" : "3.3 BNSL Cutting Planes via SUB-IPs",
      "text" : "The separation problem for an IP is the problem of finding a cutting plane which is violated by the current linear relaxation of the IP, or to show that none exists. In this paper we focus on the special case of finding a cluster constraint cutting plane for an LP solution x∗, or showing none exists. We call this the weak separation problem. We call it the ‘weak’ separation problem since cluster constraints are not the only possible cutting planes.\nIn gobnilp, this problem is solved via a sub-IP, as described earlier e.g. by Bartlett and Cussens (2015). Given an LP solution x∗ to separate, the variables of the sub-IP include binary variables yi←J for each family such that x ∗ i←J > 0. In addition, binary variables yi for each i ∈ V are created. The constraints of the sub-IP are such that yi = 1 indicates that i is a member of some cluster whose associated cluster constraint is a cutting plane for x∗. yi←J = 1 indicates that the family variable xi←J appears in the cluster constraint. The sub-IP is given by\nMaximise ∑\ni,J : x∗i←J>0\nx∗i←J · yi←J − ∑ i∈V yi (9)\nsubject to yi←J ⇒ yi ∀yi←J (10) yi←J ⇒ ∨ j∈J\nyj ∀yi←J (11)∑ i,J : x∗i←J>0 x∗i←J · yi←J − ∑ i∈V yi > −1 (12)\nyi←J , yi ∈ {0, 1} (13)\nThe sub-IP constraints (10–11) are displayed as propositional clauses for brevity, but note that these are linear constraints. They can be written as (1 − yi←J) + yi ≥ 1 and (1 − yi←J) + ∑ j∈J yj ≥ 1, respectively. The constraint (12) dictates that only solutions\nwith objective value strictly greater than -1 are allowed. In the gobnilp implementation this constraint is effected by directly placing a lower bound on the objective rather than posting the linear constraint (12), since the former is more efficient.\nIt is not difficult to show—Bartlett and Cussens (2015) provide the detail—that any feasible solution to sub-IP (9–13) determines a cutting plane for x∗ and that a proof of the sub-IP’s infeasibility establishes that there is no such cutting plane. Since gobnilp spends much of its time solving sub-IPs in the hunt for cluster constraint cutting planes, the issue of whether there is a better approach is important. Is it really a good idea to set up a sub-IP each time a cutting plane is sought? Is there some algorithm (perhaps a polynomial-time one) that can be directly implemented to provide a faster search for cutting planes? In Section 5 we make progress towards answering these questions. We show that the weak separation problem is NP-hard and so (assuming P 6= NP) there is no polynomial-time algorithm for weak separation."
    }, {
      "heading" : "4. Three Polytopes related to the BNSL IP",
      "text" : "As explained in Section 3.2, in the basic gobnilp algorithm one (i) first uses only the convexity constraints and then (ii) adds cluster constraints and (iii) if necessary, branches on variables to solve the IP. These three stages correspond to three different polytopes which will be defined and analyzed in Sections 4.2–4.4. Before providing this analysis we first give essential background on linear inequalities, polytopes and polyhedra (Conforti et al., 2014)."
    }, {
      "heading" : "4.1 Linear inequalities, polytopes and polyhedra",
      "text" : "Definition 3. A point x ∈ Rn is a convex combination of points in S ⊆ Rn if there exists a finite set of points x1, . . . , xp ∈ S and scalars λ1, . . . , λp such that\nx = p∑ j=1 λjx j ,\np∑ j=1 λj = 1, λ1, . . . , λp ≥ 0.\nDefinition 4. The convex hull conv(S) of a set S ⊆ Rn is the inclusion-wise minimal convex set containing S. Equivalently conv(S) = {x ∈ Rn | x is a convex combination of points in S}.\nDefinition 5. A subset P of Rn is a polyhedron if there exists a positive integer m, an m× n matrix A and a vector b ∈ Rm such that\nP = {x ∈ Rn | Ax ≤ b}.\nDefinition 6. A subset Q of Rn is a polytope if Q is the convex hull of a finite set of vectors in Rn.\nTheorem 7 (Minkowski-Weyl Theorem for Polytopes). A subset Q of Rn is a polytope if and only if Q is a bounded polyhedron.\nWhat the Minkowski-Weyl Theorem for Polytopes states is that a polytope can either be described as the convex hull of a finite set of points or as the set of feasible solutions to some linear program. It follows that, for a given linear objective, an optimal point can be\nfound by solving the linear program. This is a superficially attractive prospect since linear programs can be solved in polynomial time.\nUnfortunately, for NP-hard problems (such as BNSL) it is impractical to create, let alone solve, the linear program due to the size of A and b. Fully characterising the inequalities Ax ≤ b is also typically difficult. However, it is useful to identify at least some of these inequalities. These inequalities define facets of the polytope. A facet is a special kind of face defined as follows.\nDefinition 8. A face of a polyhedron P ⊆ Rn is a set of the form\nF := P ∩ {x ∈ Rn | cx = δ},\nwhere cx ≤ δ is a valid inequality for P , i.e., all points in P satisfy it. We say the inequality cx ≤ δ defines the face. A face is proper if it is non-empty and properly contained in P . An inclusion-wise maximal proper face of P is called a facet.\nFacets are important since they are given by the ‘strongest’ inequalities defining a polyhedron: the set of all facet-defining inequalities of a polyhedron provides a minimal representation Ax ≤ b of that polyhedron. It follows that (typically) facet-defining inequalities are the best inequalities to add as cutting planes, and so identifying them is of crucial importance for the computational efficiency of an IP approach.\nA face of an n-dimensional polytope is a facet if and only if it has dimension n− 1. To prove that a face F has dimension n− 1 it is enough to find n affinely independent points in F . Affine independence is defined as follows (Wolsey, 1998).\nDefinition 9. The points x1, . . . xk ∈ Rn are affinely independent if the k−1 directions x2− x1, . . . , xk − x1 are linearly independent, or alternatively the k vectors (x1, 1), . . . (xk, 1) ∈ Rn+1 are linearly independent. (Note that if x1, . . . xk ∈ Rn are linearly independent they are also affinely independent.)\nHaving provided these basic definitions we now move on to consider three polytopes of increasing complexity: the digraph polytope (Section 4.2), the cluster polytope (Section 4.3) and finally, our main object of interest, the family variable polytope (Section 4.4)."
    }, {
      "heading" : "4.2 The Digraph Polytope",
      "text" : "The digraph polytope is simply the convex hull of all digraphs permitted by P. Before providing a formal account of this polytope we define some notation. For a given set of nodes V and permitted parent sets P(i), recall from Section 2.3 that the set of families is defined as\nF(V,P) := {i← J | i ∈ V, J ∈ P(i)}.\nFurthermore, we notate the set of families that remain once the empty parent set for each vertex is removed by\nF(V,P) := F(V,P) \\ {i← ∅ | i ∈ V }.\nIn this and subsequent sections F(V,P) and will serve as an index set. We will abbreviate F(V,P) and F(V,P) to F and F unless it is necessary or useful to identify the node set V and permitted parent sets P(i).\nFor any edge set A ⊆ V × V , it is clear that any 0-1 vector in RA corresponds to a (possibly cyclic) subgraph of D = (V,A). However, there are many 0-1 vectors in RF (or RF) which do not correspond to digraphs, namely those where xi←J = xi←J ′ = 1 for some i ← J, i ← J ′ ∈ F with J 6= J ′. So clearly inequalities other than simple variable bounds are required to define the digraph polytope.\nSince any digraph (cyclic or acyclic) satisfies the |V | convexity constraints (2), the digraph polytope if expressed using the variables in F will not be full-dimensional—the dimension of the polytope will be less than the number of variables. This is inconvenient since only full-dimensional polytopes have a unique minimal description in terms of their facets.\nTo arrive at a full-dimensional polytope we remove the |V | family variables with empty parent sets and define the digraph polytope using index set F(V,P). Let PG(V,P) be the digraph polytope which is the convex hull of all points in RF(V,P) that correspond to digraphs (cyclic and acyclic).\nPG(V,P) :=conv { x ∈ RF(V,P) ∣∣∣ ∃B ⊆ V × V s.t. (14) Pa(i, B) ∈ P(i) ∀i ∈ V and xi←J = 1(J = Pa(i, B)) ∀J ∈ P(i) \\ ∅ } .\nWe will abbreviate PG(V,P) to PG where this will not cause confusion.\nProposition 10. PG is full-dimensional.\nProof. The digraph with no edges is represented by the zero vector in RF. Each vector in RF with only one component xi←J set to 1 and all others set to 0 represents an acyclic digraph (denoted ei←J) and so is in PG. These vectors together with the zero vector are clearly a set of |F|+ 1 affinely independent vectors from which it follows that PG is full-dimensional in RF.\nPG is a simple polytope: it is easy to identify all its facets.\nProposition 11. The facet-defining inequalities of PG are\n1. ∀i← J ∈ F : xi←J ≥ 0 (variable lower bounds), and 2. ∀i ∈ V : ∑\ni←J∈F(V,P) xi←J ≤ 1 (‘modified’ convexity constraints).\nProof. We use Wolsey’s third approach to establishing that a set of linear inequalities define a convex hull (Wolsey, 1998, p.145). Let c ∈ RF be an arbitrary objective coefficient vector. It is clear that the linear program maximising cx subject to the given linear inequalities has an optimal solution which is an integer vector representing a digraph: simply choose a ‘best’ parent set for each i ∈ V . (If all coefficients are non-positive choose the empty parent set.) Moreover for any digraph x, it easy to see that there is a c such that x is an optimal solution to the LP. It is also easy to see that each of the given linear inequalities is necessary—removing any one of them results in a different polytope. The result follows.\nProposition 11 establishes the unsurprising fact that the polytope defined by gobnilp’s initial constraints is PG(V,P), the convex hull of all digraphs permitted by P. It follows that we will have x∗ ∈ PG for any LP solution x∗ produced by gobnilp after adding cutting planes."
    }, {
      "heading" : "4.3 The Cluster Polytope",
      "text" : "Although gobnilp only adds those cluster constraints which are needed to separate LP solutions x∗, it is useful to consider the polytope which would be produced if all were added. The cluster polytope PCLUSTER(V,P) is defined by adding all cluster constraints to the facet-defining inequalities of the digraph polytope PG(V,P), thus ruling out (family variable encodings of) cyclic digraphs.\nPCLUSTER(V,P) := { x ∈ RF(V,P) ∣∣∣ xi←J ≥ 0 ∀i← J ∈ F(V,P), and∑ i←J∈F(V,P) xi←J ≤ 1 ∀i, and\n∑ i∈C ∑ J∈P(i):J∩C 6=∅ xi←J ≤ |C| − 1 ∀C ⊆ V, |C| > 1 } .\nWe will abbreviate PCLUSTER(V,P) to PCLUSTER where this will not cause confusion.\nProposition 12. PCLUSTER is full-dimensional.\nProof. Proof is essentially the same as that for Proposition 10.\nNote that, as with the digraph polytope, we use the index set F to ensure full-dimensionality, and consequently have to use formulation (4) for cluster constraints. Clearly PCLUSTER ⊆ PG (and the inclusion is proper if |V | > 1). Since gobnilp only adds some cluster constraints, the feasible set for each LP that is solved during its cutting plane phase is a polytope P where PCLUSTER ⊆ P ⊆ PG. More important is the connection between PCLUSTER and the family variable polytope which we now introduce."
    }, {
      "heading" : "4.4 The Family Variable Polytope",
      "text" : "The family variable polytope PF(V,P) is the convex hull of acyclic digraphs with node set V which are permitted by P. To define PF(V,P) it is first useful to introduce notation for the set of acyclic subgraphs of some digraph. Let D = (V,A) be a digraph, and\nA(D) := {B ⊆ A | B is acyclic in D}. (15)\nNow consider the case where D = (V, V × V ). The family variable polytope PF(V,P) is\nPF(V,P) := conv { x ∈ RF(V,P) ∣∣∣ ∃B ∈ A(D) s.t. Pa(i, B) ∈ P(i) ∀i ∈ V and (16) xi←J = 1(J = Pa(i, B)) ∀J ∈ P(i) \\ ∅ } .\nWe will abbreviate PF(V,P) to PF where this will not cause confusion.\nProposition 13. PF is full-dimensional.\nProof. Proof is essentially the same as that for Proposition 10.\nIt is clear that PF ⊆ PCLUSTER ⊆ PG. We will see in Section 6 that although cluster constraints turn out to be facet-defining inequalities of PF, they are not the only facetdefining inequalities, and so (if |V | > 2) PF ( PCLUSTER. We do, however, have that Z|F| ∩PF = Z|F| ∩PCLUSTER, since acyclic digraphs are the only zero-one vectors to satisfy all cluster and modified convexity constraints. These facts have important consequences for the IP approach to BNSL. They show that (i) cluster constraints are a good way of ruling out cycles (since they are facet-defining inequalities of PF) and that (ii) one can solve a BNSL by just using cluster constraints and branching on variables (to enforce an integral solution). That PF ( PCLUSTER also implies that it may be worth searching for facetdefining cuts which are not cluster inequalities, for example those discovered by Studený (2015)."
    }, {
      "heading" : "5. Computational Complexity of the BNSL Sub-IPs",
      "text" : "In this section we focus on the computational complexity of the BNSL sub-IPs, formalized as the weak separation problem for BNSL. As the main result of this section, we show that this problem is NP-hard.\nThe weak separation problem for BNSL is as follows: given a x∗ ∈ PG find a separating cluster C ⊆ V , |C| > 1, for which∑\ni∈C ∑ J∈P(i):J∩C 6=∅ x∗i←J > |C| − 1, (17)\nor establish that no such C exists. We first give a simple necessary condition on separating clusters.\nDefinition 14. Given x∗ ∈ PG define dDe(x∗), the rounding-up digraph for x∗, as follows: i← j is an edge in dDe(x∗) iff there is a family i← J such that j ∈ J and x∗i←J > 0.\nProposition 15. If C is a separating cluster for x∗ then dDe(x∗)C , the subgraph of the rounding-up digraph restricted to the nodes C, is cyclic.\nProof. Since x∗ ∈ PG, x∗ is a convex combination of extreme points of PG. So we can write x∗ = ∑K k=1 αkx k where each xk represents a graph and ∑K k=1 αk = 1. For each graph x k, let xkC be the subgraph restricted to the nodes C. It is easy to see that if x k C is acyclic,\nthen ∑ i∈C ∑ J∈P(i):J∩C 6=∅ x k Ci←J\n≤ |C| − 1. So if xkC is acyclic for all k = 1, . . . ,K, then∑ i∈C ∑ J∈P(i):J∩C 6=∅ x ∗ Ci←J\n≤ |C| − 1. But if dDe(x∗)C is acyclic, then so are all the xkC . The result follows.\nProposition 15 leads to a heuristic algorithm for the weak separation problem (which is available as an option in gobnilp). Given an LP solution x∗, the rounding up digraph dDe(x∗) is constructed and cycles in that digraph are searched for using standard techniques. For each cycle found, the corresponding cluster is checked to see whether it is a separating cluster for x∗. We now consider the central result on weak separation.\nTheorem 16. The weak separation problem for BNSL is NP-hard, even when restricted to instances (V,P, c) where J ∈ P(i) for all i ∈ V only if |J | ≤ 2.\nProof. We prove the claim by reduction from vertex cover; that is, given a graph G = (V,E) and an integer k, we construct x∗ ∈ PG(V ′,P ′) over a vertex set V ′ and permitted parent sets P ′ such that there is a cluster C ⊆ V ′ with |C| > 1 and∑\ni∈C ∑ J∈P ′(i):J∩C 6=∅ x∗i←J > |C| − 1\nif and only if there is a vertex cover of size at most k for G. Specifically, let us denote n = |V | and m = |E|. We construct x∗ ∈ PG(V ′,P ′) as follows.\n1. The vertex set is V ′ = V ∪ S, where S is disjoint from V and |S| = m.\n2. For s ∈ S and {u, v} ∈ E, we set x∗s←{u,v} = 1/m; in particular, ∑ {u,v}∈E x ∗ s←{u,v} = 1\nfor all s ∈ S.\n3. For s ∈ S and v ∈ V , we set\nx∗v←{s} = k\nm(k + 1) .\n4. x∗i←∅ = 0 for all i ∈ V ′.\n5. For all other choices of i ∈ V ′ and J ⊆ V ′ \\ {i}: J 6∈ P(i).\nFinally, for a cluster C ⊆ V ′, we define the score w(C) as\nw(C) = ∑ i∈C ∑ J∈P ′(i):J∩C 6=∅ x∗i←J − |C| .\nNow we claim that there is a set C ⊆ V ′ with w(C) > −1 if and only if G has a vertex cover of size at most k; this suffices to prove the claim.\nFirst, we observe that if U ⊆ V is a vertex cover in G, then\nw(U ∪ S) = −|U |+ ∑ v∈U ∑ s∈S xv←{s} − |S|+ ∑ s∈S ∑ e∈E 1 m\n= −|U |+ |U | mk m(k + 1) − |S|+ |S|m m\n= −|U | (\n1− k k + 1\n) = − |U |\nk + 1 ,\nwhich implies that w(U ∪ S) > −1 if |U | ≤ k. Now let C ⊆ V ′, and let us denote CV = C ∩ V and CS = C ∩ S. If |CV | ≥ k + 1, then we have\nw(C) ≤ −|CV |+ |CV | |CS |k\nm(k + 1)\n≤ −|CV |+ |CV | k\nk + 1 = −|CV | (\n1− k k + 1 ) = |CV | k + 1 ≤ −1 .\nOn the other hand, let us consider the case where |CV | ≤ k but CV is not a vertex cover for G; we may assume that CV 6= ∅, as otherwise we would have w(C) = −|C| ≤ −1. Let us write H = {e ∈ E | CV ∩ e 6= ∅} for the set of edges covered by CV . Since we assume that CV is not a vertex cover, we have |H| ≤ m− 1. Thus, it holds that\nw(C) = −|CV |+ |CV | |CS |k\nm(k + 1) − |CS |+ |CS | |H| m\n≤ −|CV |+ |CV | |CS |k\nm(k + 1) − |CS |+ |CS | m− 1 m\n= −|CV | (\n1− |CS |k m(k + 1)\n) − |CS |\nm ≤ − (\n1− |CS |k m(k + 1)\n) − |CS |\nm = −1− |CS | ( 1 m − k m(k + 1) ) = −1− |CS | m(k + 1) < −1 .\nThus, if CV is not a vertex cover of size at most k, then w(C) ≤ −1."
    }, {
      "heading" : "6. Facets of the Family Variable Polytope",
      "text" : "In this section a number of facets of the family variable polytope are identified and certain properties of facets are given. Section 6.1 provides simpler results, and Sections 6.2–6.4 more substantial ones, including a tight connection between facets and cluster constraints, liftings of facets, and the influence of restricting parent sets on facets. In Appendix A we provide a complete enumeration of the facet-defining inequalities over 2–4 nodes and confirm the enumeration is consistent with the theoretical results presented here."
    }, {
      "heading" : "6.1 Simple Results on Facets",
      "text" : "We start by showing that the full-dimensional family variable polytope PF is monotone via a series of lemmas. Once we have proved this result, we will use it to establish elementary properties of facets of PF and find the simple facets of the polytope.\nDefinition 17. A nonempty polyhedron P ⊆ Rn≥0 is monotone if x ∈ P and 0 ≤ y ≤ x imply y ∈ P .\nLemma 18. Let x ∈ PF and let the vector y be such that yi′←J ′ = 0 for some i′ ← J ′ and yi←J = xi←J if i← J 6= i′ ← J ′. Then y ∈ PF.\nProof. Since x ∈ PF, x = ∑ αkx\nk where each xk is an extreme point of PF corresponding to an acyclic digraph. For each xk define the vector yk where yki′←J ′ = 0 and all other components of yk are equal to those of xk. Each yk is also an extreme point corresponding to an acyclic digraph (a subgraph of xk). We clearly have that y = ∑ αky k and so y ∈ PF.\nLemma 19. Let x ∈ PF and let y be any vector such that yi′←J ′ ≤ xi′←J ′ for some i′ ← J ′ and yi←J = xi←J if i← J 6= i′ ← J ′. Then y ∈ PF.\nProof. This is immediate from Lemma 18.\nProposition 20. PF(V ) is monotone.\nProof. Suppose x ∈ PF and 0 ≤ y ≤ x. Construct a sequence of vectors x = y0, y1, . . . , yk, . . . , y|F| = y by replacing each component xi←J by yi←J one at a time (in any order). By Lemma 19 each yk ∈ PF, so y ∈ PF.\nHammer et al. (1975) showed that a polytope is monotone if and only if it can be described by a system x ≥ 0, Ax ≤ b with A, b ≥ 0. This provides the following result for PF.\nTheorem 21. Each facet-defining inequality of PF(V ) is either (i) a lower bound (of zero) on a family variable, or (ii) an inequality of the form πx ≤ π0, where π ≥ 0 and π0 > 0.\nProof. From Proposition 20 and the result of Hammer et al. (1975) we have the result but with π0 ≥ 0. That π0 > 0 follows directly by full-dimensionality.\nProposition 22. The following hold.\n1. xi←J ≥ 0 defines a facet of PF(V,P) for all families i← J ∈ F(V,P).\n2. For all i ∈ V , if J ′ ∈ P(i′) implies ∃J 6= ∅ ∈ P(i) for all other i′ ∈ V , where i 6∈ J ′ or i′ 6∈ J , then ∑ J 6=∅,J∈P(i) xi←J ≤ 1 defines a facet of PF(V,P).\nProof. (1) follows from the monotonicity of PF(V,P) (Hammer et al., 1975, Proposition 2). For (2) first define, for any i← J ∈ F(V,P) the unit vector ei←J ∈ RF(V,P), where ei←Ji←J = 1 and all other components of ei←J are 0. For each i ∈ V define Si = {ei←J | J 6= ∅, J ∈ P(i)} ∪ {ei′←J ′ + ei←J | i′ 6= i, J ′ 6= ∅, J ′ ∈ P(i′), J 6= ∅, and either i 6∈ J ′ or i′ 6∈ J}.\nThere is an obvious bijection between family variables and the elements of Si so |Si| = |F(V,P)|. It is easy to see that the vectors in Si are linearly independent (and thus affinely independent) and that each is an acyclic digraph satisfying ∑ J 6=∅,J∈P(i) xi←J = 1. The result follows.\nRecall that we use the name modified convexity constraints to describe inequalities of the form ∑ J 6=∅,J∈P(i) xi←J ≤ 1. That each node can have exactly one parent set in any digraph is a convexity constraint. If we remove the empty parent set, this convexity constraint becomes an inequality, and is thus modified. We have now shown that each modified convexity constraint is a facet of PF(V,P) as long as a weak condition is met. In fact, we have found this weak condition to be essentially always met in practice. Note also that it is always met when all parent sets are allowed (as long as |V | > 2).\nWe now show that if πx ≤ π0 defines a facet of the family-variable polytope, then, for each family, there is an acyclic digraph ‘containing’ that family for which the facet is ‘tight’.\nProposition 23. If πx ≤ π0 is a facet of PF which is not a lower bound on a family variable, then for all families i ← J ∈ F, there exists an extreme point x of PF such that xi←J = 1 and πx = π0.\nProof. Recall that by definition each extreme point of PF is a zero-one vector (representing an acyclic digraph). Now suppose that there were some i← J ∈ F such that xi←J = 0 for any extreme point x of PF such that πx = π0. Since πx ≤ π0 is a facet, there is a set of |F| affinely independent extreme points satisfying πx = π0. By our assumption, each such extreme point will also satisfy xi←J = 0. xi←J ≥ 0 is a facet. However, it is not possible for a set of |F| affinely independent points to lie on two distinct facets. The result follows.\nProposition 23 helps us prove an important property of facets of PF: coefficients are non-decreasing as parent sets increase. The proof of the following proposition rests on the simple fact that removing edges from an acyclic digraph always results in another acyclic digraph.\nProposition 24. Let πx ≤ π0 be a facet of PF. Then J ⊆ J ′ ⇒ πi←J ≤ πi←J ′.\nProof. Since πx ≤ π0 is a facet, there exists an extreme point x′ such that x′i←J ′ = 1 and πx′ = π0. Note that x ′ i←J = 0. Since x\n′ is an extreme point, it encodes an acyclic digraph. Let x be identical to x′ except that xi←J = 1 and xi←J ′ = 0. Since J ⊆ J ′, x also encodes an acyclic digraph and so is in PF so πx ≤ π0. Thus πx− πx′ ≤ 0. However, πx− πx′ = πi←J − πi←J ′ , and the result follows."
    }, {
      "heading" : "6.2 Cluster Constraints are Facets of the Family Variable Polytope",
      "text" : "In this section we show that each κ-cluster inequality is facet-defining for the family variable polytope in the special case where the cluster C is the entire node set V and where all parent sets are allowed for each vertex. The κ-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3). The cluster inequalities (3) are κ-cluster inequalities for the special case of κ = 1.\nIn the next section (Section 6.3) we will show how to ‘lift’ facet-defining inequalities. This provides an easy generalisation (Theorem 29) of the result of this section which shows that, when all parent sets are allowed, all κ-cluster inequalities are facets, not just those for which C = V . As a special case, this implies that the cluster inequalities devised by Jaakkola et al. (2010) are facets of the family variable polytope, when all parent sets are allowed.\nAn alternative proof for the fact that κ-cluster inequalities are facet-defining was recently provided by Cussens et al. (2015) (see Corollary 4 of that paper). The proof establishes not only that κ-cluster inequalities are facet-defining, but also that they are score-equivalent. A face of the family variable polytope is said to be score-equivalent if it is the optimal face for some score equivalent objective. An objective function is score equivalent if it gives the same value to any two acyclic digraphs which are Markov equivalent (encode the same conditional independence relations). In later work, Studený (2015) went further and showed that κ-cluster inequalities form just part of a more general class of facet-defining inequalities which can be defined in terms of connected matroids. However, we believe that our proof, as presented in the following, is valuable since it relies only on a direct application of a standard technique for proving that an inequality is facet-defining, and does not require any connection to be made to score-equivalence, let alone matroid theory. In addition, the general result (our Theorem 29) further shows how our results on ‘lifting’ can be usefully applied.\nFirst we define κ-cluster inequalities. There is a κ-cluster inequality for each cluster C ⊆ V , |C| > 1 and each κ < |C| which states that there can be at most |C| − κ nodes in C with at least κ parents in C. It is clear that such inequalities are at least valid, since all acyclic digraphs clearly satisfy them. We begin by considering the special case of C = V where the κ-cluster inequality states that there can be at most |V | − κ nodes with at least κ parents. We first introduce some helpful notation.\nDefinition 25. PV is defined as follows: PV (i) := 2V \\{i}, for all i ∈ V .\nWe will now show that κ-cluster inequalities are facet-defining.\nTheorem 26. Recall that PV (i) := 2V \\{i} for all i ∈ V . For any positive integer κ < |V |, the following valid inequality defines a facet of the family variable polytope PF(V,PV ):∑\ni∈V ∑ J⊆V \\{i},|J |≥κ xi←J ≤ |V | − κ. (18)\nProof. An indirect method of establishing affine independence is used. It is given, for example, by Wolsey (1998, p.144). Let x1, . . . xt be the set of all acyclic digraphs in PF(V,PV ) satisfying ∑\ni∈V ∑ J⊆V \\{i},|J |≥κ xi←J = |V | − κ. (19)\nSuppose that all these points lie on some generic hyperplane µx = µ0. Now consider the system of linear equations∑\ni∈V ∑ J 6=∅,J⊆V \\{i} µi←Jx ι i←J = µ0 for ι = 1, . . . t. (20)\nNote that dim PF(V,PV ) = |F(V,PV )| = |V |(2|V |−1− 1) and so there are the same number of µi←J variables. The system (20), in the |V |(2|V |−1 − 1) + 1 unknowns (µ, µ0), is now solved. This is done in three stages. First we show that µi←J must be zero if |J | < κ. Then we show that the remaining µi←J must all have the same value. Finally, we show that this common value is 1 whenever µ0 is |V | − κ.\nTo do this it is useful to consider acyclic tournaments on V . These are acyclic digraphs where there is a directed edge between each pair of distinct nodes. It is easy to see that\n1. for any κ < |V |, every acyclic tournament on V satisfies (19), and that\n2. for any xi←J there is an acyclic tournament, where xi←J = 1.\nLet x be an acyclic tournament on V with xi←J = 1 for some i ∈ V , |J | < κ, i.e., J is the non-empty parent set for i in x. Now consider x′ which is identical to x except that i has no parents, so that x − x′ = ei←J . Since x is an acyclic tournament it satisfies (19). But it is also easy to see that x′ satisfies (19), since no parent set of size at least κ has been removed. So µi←J = µe\ni←J = µ(x − x′) = µx − µx′ = µ0 − µ0 = 0. µi←J = 0 whenever |J | < κ. Call this Result 1.\nConsider now two distinct parent sets J and J ′ for some i ∈ V where J ≥ κ and J ′ ≥ κ. Let g be an acyclic tournament on the node set V \\ {i}. Let x be the acyclic digraph on\nnode set V obtained by adding {i} to g and drawing edges from each member of J to i. Similarly, let x′ be the acyclic digraph obtained by drawing edges from J ′ to i instead, so that x − x′ = ei←J − ei←J ′ . It is not difficult to see that both x and x′ satisfy (19). So µi←J − µi←J ′ = µ(ei←J − ei←J ′ ) = µ(x− x′) = µx− µx′ = µ0 − µ0 = 0. So µi←J = µi←J ′ . Call this Result 2. Now consider variables xi←J and xi′←J ′ where i 6= i′, J ∪ {i} = J ′ ∪ {i′} and |J | = |J ′| = κ. First note that in an acyclic tournament, (i) there is exactly one parent set of each size 0, . . . , κ, . . . |V | − 1 and so (ii) the nodes of an acyclic tournament can be totally ordered according to parent set size, and thus (iii) any total ordering of nodes determines a unique acyclic tournament. Let x be any acyclic tournament where xi←J = 1 and xi′←J(<κ) = 1 for some parent set J\n(<κ) where |J (<κ)| < κ. Clearly there are many such acyclic tournaments. Note that since x is an acyclic tournament, J (<κ) ⊆ J \\ {i, i′}. Now consider the acyclic tournament x′ produced by swapping i and i′ in the total order associated with x. This generates an acyclic tournament x′ where x′i′←J ′ = 1 and x ′ i←J(<κ) = 1. Note that components of x and x′ corresponding to family variables with parent set size strictly above κ are equal. Components of µ corresponding to family variables with parent set size strictly below κ all equal zero. From this we have that µx − µx′ = µi←J − µi←J ′ . Since µx− µx′ = µ0 − µ0 = 0, this shows that µi←J = µi′←J ′ Call this Result 3.\nNow consider a pair of variables µi←J ′′ and µi′←J ′′′ where i 6= i′, and the only restriction is that |J ′′|, |J ′′′| ≥ κ. If some other pair of variables µi←J and µi′←J ′ meet the conditions of Result 3, then µi←J = µi′←J ′ . However, by Result 2 µi←J ′′ = µi←J and µi′←J ′′′ = µi′←J ′ . Thus µi←J ′′ = µi′←J ′′′ .\nSo by the transitivity of equality µi←J = µi′←J ′ for any i, i ′, J, J ′ where |J | ≥ κ, |J ′| ≥ κ. Recall that we also have that µi←J = 0 whenever |J | < κ. Suppose that µ0 = 0. since all non-zero µi←J are equal and thus have the same sign, the only possible solution is for all µi←J = 0. Suppose then instead that µ0 6= 0. Then wlog we can set µ0 = |V | − κ. In each of the t equations (20), after substituting µi←J = 0 for |J | < κ, we have |V | − κ terms on the left hand side (LHS) which are known to be equal. On the right hand side (RHS) the value is |V | −κ, so all terms on the LHS must equal one. Each term µi←J where |J | ≥ κ, occurs in at least one of t equations (20), so this is enough to establish that µi←J = 1 whenever |J | ≥ κ. Thus, unless all µi←J = 0, the only possible solution to the system of linear equations (20) with RHS |V | − κ is • µi←J = 0 if |J | < κ, and\n• µi←J = 1 if |J | ≥ κ. These values match those in (19) and so (18) is facet-defining."
    }, {
      "heading" : "6.3 Lifting Facets of the Family Variable Polytope",
      "text" : "In this section we show that if all parent sets are allowed, then facet-defining inequalities for the family variable polytope for some node set V can be ‘lifted’ to provide facets for any family variable polytope for an enlarged node set V ′ ) V . Lemma 27. Recall that PV (i) := 2V \\{i} for all i ∈ V . Let∑\ni∈V ∑ J∈PV (i),J 6=∅ αi←Jxi←J ≤ β (21)\nbe a facet-defining inequality for the family variable polytope PF(V,PV ) which is not a lower bound on a variable. Let V ′ = V ∪ {i′} where i′ 6∈ V . Then∑\ni∈V ∑ J∈PV (i),J 6=∅ αi←J(xi←J + xi←J∪{i′}) ≤ β (22)\nis a facet-defining inequality of PF(V ′,PV ′). Furthermore, this inequality is not a lower bound on a variable.\nProof. Since (21) is facet-defining, there is a set S0 ⊆ RF(V,PV ) of affinely independent acyclic digraphs, with node set V , lying on its hyperplane. For each acyclic digraph in S0, create an acyclic digraph with node set V ∪ {i′} by adding i′ as an isolated node. Let S1 ⊆ RF(V\n′,PV ′ ) be the set of acyclic digraphs so created. Note that all members of S1 lie on the hyperplane for (22). Each vector in S1 corresponds to a vector in S0 with a zero vector of length |F(V ′,PV ′)|− |F(V,PV )| concatenated. Since S0 is an affinely independent set, so is S1.\nFor each non-empty subset J ⊆ V , construct an acyclic digraph by adding ei′←J to an arbitrary member of S1. Clearly the end result is an acyclic digraph lying on the hyperplane for (22). Let S2 be the set of all such acyclic digraphs.\nFor each J ⊆ V , i ∈ V , construct an acyclic digraph by finding an acyclic digraph x ∈ S1 such that xi←J = 1 and adding an arrow from i′ to i. Note that it is always possible to find an acyclic digraph with xi←J = 1. If this were not the case, then (21) would be a lower bound on xi←J . It is not difficult to see that any such acyclic digraph lies on the hyperplane defined by (22). Let S3 be the set of all such acyclic digraphs.\nLet S = S1 ∪ S2 ∪ S3. S2 and S3 have exactly one acyclic digraph for each component xi←J involving the node i\n′ (either i = i′ or i′ ∈ J). S1 has an acyclic digraph for each component xi←J not involving i\n′. So |S| = dim PF(F(V ′,PV ′)) = |F(V ′,PV ′)|. It remains to be established that the S is a set of affinely independent vectors.\nSuppose ∑\nxi∈S αix i = 0 and ∑ xi∈S αi = 0. Each component xi←J involving i\n′ is set to 1 in exactly one acyclic digraph in S2∪S3. Thus αi = 0 for xi ∈ S2∪S3. So ∑ xi∈S1 αix\ni = 0 and ∑ xi∈S1 αi = 0. The result then follows from the affine independence of the set S1.\nTheorem 28. Recall that PV (i) := 2V \\{i} for all i ∈ V . Let∑ i∈V ∑ J∈PV (i),J 6=∅ αi←Jxi←J ≤ β (23)\nbe a facet-defining inequality of the family variable polytope PF(V,PV ) which is not a lower bound on a variable. Let V ′ be a node set such that V ⊆ V ′. Then\n∑ i∈V ∑ J∈PV (i),J 6=∅ αi←J  ∑ J ′:J⊆J ′⊆V ′\\{i} xi←J ′  ≤ β (24) is facet-defining for PF(V ′,PV ′) and is not a lower bound on a variable.\nProof. Repeated application of Lemma 27.\nUsing Theorem 28, Theorem 26 can now be ‘lifted’ to establish that all k-cluster inequalities are facet-defining.\nTheorem 29. Recall that PV (i) := 2V \\{i} for all i ∈ V . For any C ⊆ V and any positive integer κ < |C|, the valid inequality∑\ni∈C ∑ J ||J∩C|≥κ xi←J ≤ |C| − κ (25)\nis facet-defining for the family variable polytope PF(V,PV ).\nProof. By Theorem 26, (25) is facet-defining for the family variable polytope for node set C. By applying Theorem 28 it follows that it also facet-defining for the family variable polytope for any node set V ⊇ C."
    }, {
      "heading" : "6.4 Facets when Parent Sets are Restricted",
      "text" : "The results in the preceding sections have all been for the special case PV when all possible parent sets are allowed for each node. If some parent sets are ruled out, for example by an upper bound κ on parent set cardinality, then some κ-cluster inequalities and some modified convexity constraints may not be facets.\nTo see this, suppose we had V = {a, b, c}. If all parent sets are allowed, then Theorem 29 shows that this 2-cluster inequality for C = {a, b, c},\nxa←{b,c} + xb←{a,c} + xc←{a,b} ≤ 1, (26)\nis a facet. However, if {a, b} is not allowed as a parent set for c, then the inequality becomes\nxa←{b,c} + xb←{a,c} ≤ 1, (27)\nwhich is not facet-defining since it is dominated by the 1-cluster inequality for C = {a, b},\nxa←{b} + xa←{b,c} + xb←{a} + xb←{a,c} ≤ 1. (28)\nAs another example, suppose {c} were removed from P(a). Then condition 2 of Proposition 22 is no longer met, and the modified convexity constraint for a becomes\nxa←{b} + xa←{b,c} ≤ 1, (29)\nwhich cannot be facet-defining since it is dominated by the inequality (28). For any P we have that the polytope PF(V,P) is a face of the all-parent-sets-allowed polytope PF(V,PV ) defined by the valid inequality∑ i∈V ∑ J∈PV (i)\\P(i) xi←J ≥ 0. (30)\nThe issue then is whether it is possible to determine when a facet of PF(V,PV ) is also a facet of this face. The issue of determining the facets of a face is of general interest. As Boyd and Pulleyblank (2009) note “As it is often technically much simpler to obtain results\nabout facets for a full dimensional polyhedron than one of lower dimension, it would be nice to . . . know under what conditions an inequality inducing a facet of P also induces a facet of a face F of P .” They go on to state that “. . . we know of no reasonable general result of this type”.\nHowever, in the case of the the family variable polytope, there is a strong result which shows that many facets of a family variable polytope PF(V,P) induce facets of a lowerdimensional family variable polytope PF(V, P̆) where P̆(i) ⊆ P(i) for all i ∈ V . In particular, this result shows that some facets of the all-parent-sets-allowed polytope PF(V,PV ) are also facets of the polytope that results by limiting the cardinality of parent sets. To establish this result we first prove a lemma.\nLemma 30. Let x ∈ PF(V,P). Let i ∈ V and let J, J ′ ∈ P(i) with J ( J ′, J 6= ∅. Define x̆ as follows: x̆i←J = xi←J +xi←J ′, x̆i←J ′ = 0, and x and x̆ are equal in all other components. Then x̆ is also in the family-variable polytope PF(V,P).\nProof. Since x ∈ PF(V,P), x = ∑K k=1 αkx k where each xk is an extreme point of PF(V,P) corresponding to an acyclic digraph. For each xk define x̆k as follows: x̆ki←J = x k i←J +x k i←J ′ , x̆ki←J ′ = 0 and x k and x̆k are equal in all other components. It is clear that each x̆ k corresponds to an acyclic digraph which differs from xk iff J ′ is the parent set for i in xk, in which case J becomes the parent set for i in x̆k. The digraph remains acyclic since J ( J ′. It is also clear that x̆ = ∑K k=1 αkx̆ k and so x̆ ∈ PF(V,P).\nThe main result of this section now follows. Our proof makes use of the elementary but useful fact that the number of linearly independent rows in a matrix (row rank) and the number of linearly independent columns in a matrix (column rank) are equal.\nTheorem 31. Let πx ≤ π0 define a facet for the family-variable polytope PF(V,P). Suppose that πi←J = πi←J ′ for some i ∈ V , J, J ′ ∈ P(i) with J ( J ′, J 6= ∅. Let π̆ be π with the component πi←J ′ removed. Let P̆ be identical to P except that J ′ is removed from P(i). Then π̆x ≤ π0 defines a facet for the polytope PF(V, P̆).\nProof. Since πx ≤ π0 is a facet for PF(V,P) it is obvious by Theorem 21 that π̆x ≤ π0 is at least a valid inequality for PF(V, P̆). We now show that this valid inequality defines a facet by proving the existence of |F(V, P̆)| affinely independent points lying in the facet.\nRecall that F(V,P) is the set of families determined by vertices V and allowed parent sets P. Abbreviate |F(V,P)| to m and note that |F(V, P̆)| = m− 1. Since πx ≤ π0 defines a facet for the family-variable polytope PF(V,P), there are m affinely independent points x1, . . . , xk, . . . , xm lying in this facet (i.e., πxk = π0, x\nk ∈ PF(V,P) for k = 1, . . . ,m). Since these points are affinely independent, the points (x1, 1), . . . , (xk, 1), . . . , (xm, 1) in Rm+1 are linearly independent.\nLet A1 be the m × (m + 1) matrix whose rows are the (xk, 1). Since the rows are linearly independent, A1 has rank m. Construct a new matrix A2 by adding the column for family i ← J ′ to that for i ← J . Since this is an elementary operation it does not change the rank of the matrix (Cohn, 1982), and so A2 has rank m. Now construct an m × m matrix A3 by removing the column for i ← J ′ from A2. Denote the rows of A3 by (x̆1, 1), . . . , (x̆k, 1), . . . , (x̆m, 1). From Lemma 30 it follows that each x̆k is in PF(V, P̆). Since πi←J = πi←J ′ , it is not difficult to see that each x̆ k satisfies π̆x = π0. Since A2\nhas rank m, there are m linearly independent columns in A2 and, since A3 is A2 with one column removed, at least m − 1 linearly independent columns in A3. So A3 has rank of at least m − 1. But this means that there are m − 1 linearly independent rows in A3, so there are m − 1 points among the x̆k that are affinely independent. So there are m − 1 affinely independent points in PF(V, P̆) satisfying π̆x = π0 and thus π̆x ≤ π0 defines a facet of PF(V, P̆).\nGiven a facet-defining inequality of an all-parent-sets-allowed polytope PF(V,PV ) and a parent set cardinality limit κ, Theorem 31 states that if the coefficients for all family variables xi←J ′ with |J ′| > κ are not strictly larger than the coefficient for some family variable xi←J with J ( J ′ so that |J | ≤ κ, then the inequality also defines a facet for the polytope with family variables restricted by κ. In Appendix A this is confirmed for the case where |V | = 4 and κ = 2. It follows that a normal (k = 1) cluster constraint is a facet for any limit κ on the size of parent sets. This explains why normal cluster constraints are more useful to look for than k-cluster constraints for k > 1. In gobnilp, although the user can ask the system to look for k-cluster constraints up to some defined limit k ≤ K, the default is to only search for normal (k = 1) cluster constraints since this has been observed to lead to faster solving."
    }, {
      "heading" : "7. Faces of the Family Variable Polytope defined by Orders and by Sinks",
      "text" : "In this section we analyse faces of the all-parent-sets-allowed family variable polytope defined by total orders and sink nodes, respectively. Faces of a polytope are themselves polytopes, and in this section we establish a complete characterisation of the facets of both types of polytope. Moreover, the faces defined by sink nodes lead to a useful extended representation for the family variable polytope which can be used to relate family variable polytopes for different numbers of nodes."
    }, {
      "heading" : "7.1 Order-defined Faces",
      "text" : "Let < be some total order on the node set V . An acyclic digraph (V,B) is consistent with < if i ← j ∈ B ⇒ j < i, so that parents come before children in the ordering. The valid inequality ∑ i,J :(∃j∈J s.t. i<j) xi←J ≥ 0 defines a face of the family variable polytope\nPF(V,<) = { x ∈ PF(V,PV ) ∣∣∣ ∑ i,J :(∃j∈J :i<j) xi←J = 0 } . (31)\nIn PF(V,<) each family variable inconsistent with< is set to zero. This is the only restriction on x. So clearly all acyclic digraphs consistent with < lie on the face PF(V,<) and no digraphs inconsistent with < do. It is also clear that any acyclic digraph lies on PF(V,<) for at least one choice of <.\nRemark 32. Abbreviate |V | to p. We have that dim(PF(V,<)) = 2p − p− 1. If the family variables clamped to zero in PF(V,<) are removed, PF(V,<) is full-dimensional in R2\np−p−1. (Recall that dim(PF(V,PV )) = p(2p−1 − 1).)\nRemark 33. If x is an extreme point of PF(V,PV ), then x ∈ ⋃ < PF(V,<).\nNote that exactly one acyclic tournament lies on PF(V,<) for any choice of <.\nProposition 34. The facet-defining inequalities of the full-dimensional polytope PF(V,< ) ⊆ R2p−p−1 are\n1. the variable lower bounds xi←J ≥ 0, and 2. the modified convexity constraints ∑\nJ⊆V :J 6=∅,j∈J→j<i xi←J ≤ 1,\nwhere variables xi←J with j ∈ J, i < j have been removed.\nProof. Let c ∈ R2p−p−1 be an arbitrary objective coefficient vector. Consider solving the LP with objective c subject to the linear inequalities given above. It is clear that an optimal solution to this LP is obtained by choosing a parent set J for each i ∈ V such that ci←J is maximal (or choosing none if all ci←J are negative or there are no parent sets available). This is an integer solution. The result follows."
    }, {
      "heading" : "7.2 Sink-defined Faces",
      "text" : "For some particular j ∈ V , consider the valid inequality ∑\ni 6=j,j∈J xi←J ≥ 0. This defines a face PF(V, j) of the family variable polytope as\nPF(V, j) := { x ∈ PF(V,PV ) ∣∣∣ ∑ j∈J,i6=j xi←J = 0 } . (32)\nThis face contains all acyclic digraphs for which j is a sink—it has no children. Since every acyclic digraph has at least one sink then each extreme point of the family variable polytope PF(V,PV ) lies on a face PF(V, j) for at least one choice of j.\nRemark 35. Abbreviate |V | to p and recall that dim(PF(V,PV )) = p(2p−1−1). dim(PF(V, j)) = dim(PF(V \\ {j},PV \\{j})) + 2p−1 − 1 = (p − 1)(2p−2 − 1) + 2p−1 − 1 = (p + 1)2p−2 − p. If the family variables clamped to zero in PF(V, j) are removed, PF(V, j) is full-dimensional in R(p+1)2p−2−p.\nRemark 36. Every acyclic digraph contains at least one sink. So if x is an extreme point of PF(V,PV ), then x ∈ ⋃ j∈V PF(V, j).\nProposition 37. The facet-defining inequalities of the full-dimensional polytope PF(V, j) ⊆ R(p+1)2p−2−p are\n1. the facet-defining inequalities of the polytope PF(V \\ {j},PV \\{j}), and 2. the modified convexity constraint for j, namely ∑\nJ⊆V \\{j},J 6=∅ xj←J ≤ 1.\nProof. Let c ∈ R(p+1)2p−2−p be an arbitrary objective coefficient vector and consider solving the LP with objective c subject to the linear inequalities given above. Since j is constrained to be a sink, an optimal solution in PF(V, j) is obtained by choosing a maximally scoring parent set for j and then an optimal acyclic digraph for V \\{j}. Since we have all the facets of the polytope PF(V \\ {j}), the optimal acyclic digraph for V \\ {j} is a maximal solution to the LP restricted to the relevant variables. So the full LP has an integer solution. The result follows."
    }, {
      "heading" : "7.3 A Sink-based Extended Representation for the Family Variable Polytope",
      "text" : "Since PF(V, j) ⊆ PF(V,PV ), for each j ∈ V we have ⋃ j∈V PF(V, j) ⊆ PF(V,PV ) and\nso conv (⋃ j∈V PF(V, j) ) ⊆ conv (PF(V,PV )) = PF(V,PV ). However, as noted in Re-\nmark 36, if x is an extreme point of PF(V,PV ), then x ∈ ⋃ j∈V PF(V, j), so PF(V,PV ) ⊆\nconv (⋃ j∈V PF(V, j) ) , and thus PF(V,PV ) = conv (⋃ j∈V PF(V, j) ) . Since there are only |V | = p sink-defined faces, this leads to a compact extended representation for the family variable polytope PF(V,PV ) in terms of the polytopes PF(V, j)j∈V . Since by Proposition 37 each PF(V, j) can be defined using PF(V \\ {j}), this allows PF(V,PV ) to be defined by the PF(V \\ {j},PV \\{j}). In Appendix B we detail how this is done for the specific case of |V | = 4; here we describe the method for the general case.\nA union of polytopes can be modelled by introducing additional variables. We follow the (standard) approach described by Conforti et al. (2014, §2.11). For each j ∈ V , we introduce a binary variable xj and add the constraint∑\nj∈V xj = 1, (33)\nwhere xj indicates that node j is a distinguished sink. The constraint states that in each acyclic digraph we can choose exactly one sink as the distinguished sink for that digraph.\nNext, for each j ∈ V , i← J ∈ F(V,PV ), we introduce a new variable xj,i←J indicating that i has J as its (non-empty) parent set and that j is the distinguished sink. In other words xj,i←J = xjxi←J . We add the following constraints linking the xj,i←J to the original xi←J :\nxi←J = ∑ j∈V xj,i←J . (34)\nDenote the vector of xj,i←J components for some j as x j . Then for each j ∈ V and each facet πx ≤ π0 of PF(V, j) we add the constraint\nπjxj ≤ π0xj , (35)\nwhere πjj,i←J = πi←J , and also the variable bounds\n0 ≤ xj,i←J ≤ xj . (36)\nEquations and inequalities (33–36) define ⋃ j∈V PF(V, j). To formulate PF(V,PV ) =\nconv (⋃ j∈V PF(V, j) ) , it suffices to merely drop the integrality condition on the xj variables, thus allowing PF(V,PV ) to be defined in terms of the lower-dimensional PF(V, j)."
    }, {
      "heading" : "8. Relating BNSL and the Acyclic Subgraph Problem",
      "text" : "As the final contribution of this article, we establish a tight connection between BNSL and the acyclic subgraph problem."
    }, {
      "heading" : "8.1 BSNL as the Acyclic Subgraph Problem",
      "text" : "BNSL is closely related to the well-known acyclic subgraph problem (ASP) (Grötschel et al., 1985). An instance of ASP is defined by digraph D = (V,A) with edge weights c(i← j) ∈ R for every edge i ← j ∈ A, and the goal is to find an acyclic subdigraph D′ = (V,B) of D which maximises ∑\ni←j∈B c(i← j). (37)\nIn ASP, the objective function is a linear function of (indicators for) the edges of some digraph; in BNSL, by contrast, the aim is to maximise an objective which is a linear function of (indicators for) sets of edges. As a Bayesian network structure learning instance can consist of up to Ω(2n) input values, it is presumably in general not possible to encode a BNSL instance as a ASP instance over the same node set as the original BNSL instance, as this would require in the worst case encoding an exponential number of parent set scores into a quadratic number of edge weights. However, we will next show that we can construct a BNSL-to-ASP reduction by introducing new nodes to represent all possible parent sets of the original instances (V,P, c), similarly as in Theorem 2.\nTheorem 38. Given BNSL instance (V1,P, c), we can construct an ASP instance D = (V,A) such that\n1. |V | = O ( |V1|+ |F(V1,P)| ) , and\n2. there is one-to-one correspondence between the optimal solutions of D and (V1,P, c). Moreover, given (V1,P, c), the instance D can be constructed in time poly ( |V1|+|F(V1,P)| ) .\nProof. Define the digraph D = (V,A) where V = V1 ∪ V2 ∪ V3 and\n• V2 = {J ⊆ V1 | J ∈ P(i) for some i ∈ V1},\n• V3 = {i← J | i ∈ V, J ∈ P(i)}.\nSee Figure 2 for an example node set where V1 is on the top row, V2 the middle one and V3 the bottom row.\nThe edge set for D is the disjoint union of four (colour-coded) edge sets A = A1 ∪A2 ∪ A3 ∪A4 where\n• A1 = {(i, J) | i ∈ V1, J ∈ V2, i ∈ J} (blue),\n• A2 = {(i← J, i) | i← J ∈ V3, i ∈ V1} (black),\n• A3 = {(J, i← J) | J ∈ V2, i← J ∈ V3} (red), and\n• A4 = {i← J, J ′) | i← J ∈ V3, J ′ ∈ V2, i 6∈ J ′, J 6= J ′} (green).\nThese four edge sets are coloured correspondingly in the example of Figure 2. Define an ASP instance for D = (V,A) where each (red) edge in A3 (J, i ← J) has weight ci←J ; we will assume that the scores c(i ← J) are strictly positive for all feasible parent sets choices, as adding the same value to each score will not change the optimal\nstructures. All other edges receive a weight sufficiently big to ensure that they are included in any optimal acyclic edge set. For example, giving each such edge a weight equal to a sum of all ci←J weights plus 1 will suffice.\nNote that (V,A\\A3) is acyclic. Recall also the objective coefficients of the ASP instance have been chosen to ensure that A \\ A3 ⊆ B for any optimal edge set B in D. Intuitively, we will thus only care about how the optimal solution looks on the edge set A3, and use this information to recover a solution to the original BSNL instance.\nLet (V,B) be an optimal solution to ASP instance D and define a digraph (V1, B ′) as follows: B′ = {i ← j | j ∈ J and (J, i ← J) ∈ B}. We will show (i) there is exactly one edge of form (J, i ← J) ∈ A3 for each i ∈ V1, (ii) the graph (V1, B′) graph is acyclic and (iii) that it is an optimal solution to the given BNSL instance (V1,P, c).\n(i) Suppose that (J, i ← J) and (J ′, i ← J ′) were both in B for some i ∈ V1 and J, J ′ ∈ V2, J 6= J ′. This is not possible because the edges (i ← J, J ′) and (i ← J ′, J) are both in A4 and thus in B. Having (J, i ← J) and (J ′, i ← J ′) both in B would cause a cycle (i← J)→ J → (i← J ′)→ J → (i← J) in B, and so is impossible.\n(ii) For any i, j, J with i 6= j, j ∈ J , there exist the following edges: the blue edge (j, J) ∈ A1 and the black edge (i ← J, i) ∈ A2. Note that both of these edges will be in B. If the red edge (J, i ← J) ∈ A3 is also in B then we have the following path in B: j → J → (i← J)→ i. So if j is a parent of i in B′, then there is a path from j to i in B. So if there were a cycle i1 → i2 . . . in → i1 in B′ there would be a cycle from i1 to i1 in B. Since B is acyclic this is a contradiction and so B′ must also be acyclic.\n(iii) We first show that any feasible solution G to the BNSL instance (V1,P, c) corresponds to a feasible solution to the ASP instance D = (V,A). This feasible solution to D = (V,A) consists of the edges A1 ∪ A2 ∪ A4 together with those red edges in A3 corresponding to the parent set choices for G. We need to show that this edge set—call it B(G)—is acyclic in D = (V,A). Since G is acyclic there is a total order <V1 on the nodes V1 such that parents always come before children in this order. We show that <V1 determines a total order <V on the nodes V such that parents always come before children in B(G) which establishes that B(G) is acyclic.\nTo aid understanding we first do this for the case where V1 = {a, b, c} and G is such that a <V1 b <V1 c. The general result is established later. In the special case all red edges (in A3) which are inconsistent with <V1 will be absent from B(G). In particular, since a is allowed no parents, the red edges going to the nodes a← {b}, a← {c}, and a← {b, c} will be absent. This means that these nodes are source nodes in B(G), so put these as the first 3 elements of the order <V . Since a ∈ V1 has only these 3 nodes as parents, put a as the 4th element in <V . Since the only parent for {a} is a, put {a} as the 5th element. Since c cannot be a parent of b, the red arrows going to b← {c} and b← {a, c} are absent from B(G), so these nodes are sources in B(G). Also the only arrow going to b ← {a} is from {a} which is already in the order. This allows us to put b← {a}, b← {c} and b← {a, c} as the next elements in <V . Having done this b can be placed next, and then {b} and {a, b}. The final placements are c ← {a}, c ← {b} and c ← {a, b}, then c and then the remaining nodes {c}, {a, c}, {b, c} and {a, b, c}.\nIn the general case, suppose we have G with a consistent ordering of its nodes i1 <V1 i2 · · · <Vn in. We construct a total ordering of the nodes of V consistent with B(G) as follows. Start with the nodes i1 ← J (in any order), and then put i and after that {i}.\nThen for k = 2, . . . , n add nodes as follows: the ik ← J nodes, then ik and then each J such that ik ∈ J and J ⊆ {i1 . . . ik}. It is not difficult to see that this total order contains all nodes of V and is consistent with B(G), so B(G) is acyclic.\nNow suppose B′ were not an optimal solution to the BNSL instance (V1,P, c). In that case there would be some strictly better solution corresponding to an acyclic graph G for which B(G) would be a feasible solution to the ASP instance D = (V,A) and this solution would be strictly better than B. This is a contradiction since B is an optimal solution and so it follows that B′ is an optimal solution to (V1,P, c).\nNote that, as Mart́ı and Reinelt (2011) show, ASP is equivalent to the linear ordering problem (LOP). This means that pure LOP approaches can be used to solve ASP and thus BNSL."
    }, {
      "heading" : "8.2 Relating the BNSL and Acyclic Subgraph Problem Polytopes",
      "text" : "There is a polytope naturally associated with any instance of ASP. Let RA be a real vector space where every component of a vector y ∈ RA is indexed by an edge i← j ∈ A. For every edge set B ⊆ A, the incidence vector yB ∈ RA of B is defined by yBi←j = 1 if i← j ∈ B and yBi←j = 0 if i← j 6∈ B. The acyclic subgraph polytope PAC(D) is\nPAC(D) := conv { yB ∈ RA ∣∣ B ∈ A(D)}. (38) It is not difficult to see that the all-parent-sets-allowed family variable polytope PF(V,PV )\ncan be projected onto the ASP polytope where the ASP edgeset A = V × V . Equivalently, BNSL is an extended formulation of such ASP instances. Since the ASP has been extensively studied it is important to investigate which results on ASP ‘translate’ to BNSL.\nWe can see that the ASP instance is a projection of the BNSL instance by introducing the edge indicator variables yi←j into BNSL together with the ‘linking’ equations\nyi←j = ∑ J :j∈J xi←J . (39)\nThe introduction of these variables (dimensions) and equations leaves the family variable polytope unaltered except that it now ‘lives in’ a higher-dimensional space. ‘Projecting away’ the xi←J variables from this higher-dimensional family variable polytope then produces the ASP polytope.\nUsing this relationship it is easy to map any ASP instance with edgeset A = V ×V into a BNSL instance: simply set ci←J = ∑ j∈J c(i ← j). A solution to the BNSL instance so produced will be a solution to the original ASP instance with the same objective value. A direct reverse mapping is only possible if there are edge weights such that the local score for each family is the sum of the weights of the edges corresponding to that family.\nProposition 39. If πy ≤ π0 is a valid inequality for ASP, then π′x ≤ π0 is a valid inequality, where π′i←J = ∑ j∈J πi←j .\nProof. Let x∗ ∈ RF represent an acyclic digraph and let y∗ ∈ RA represent the same digraph. We have that πy∗ ≤ π0. It is obvious that πy∗ = π′x∗. So all acyclic digraphs represented by family variables satisfy π′x ≤ π0. The result follows."
    }, {
      "heading" : "9. Conclusions",
      "text" : "Integer programming, and specifically the IP-based gobnilp system, offers a state-of-theart practical approach to the NP-hard optimization problem of learning optimal Bayesian network structures, BNSL. Thus providing fundamental insights into the IP approach to BNSL is important both from the purely scientific perspective—dealing with a central class of probabilistic graphical models with various applications in AI—and for developing a better understanding of the approach in the hope of further improving the current algorithmic approaches to BNSL. With these motivations, in this work we shed light on various fundamental computational and representational aspects of BNSL. From the practical perspective, many of our main contributions have tight connections to IP cutting planes derived in practice during search for optimal network structures. Specifically, our contributions include for example the following. We showed that the separation problem which in practice yields problem-specific BNSL cutting planes within gobnilp is in fact NP-hard, a previously open problem. We studied the relationship between three key polytopes underlying BNSL. We analyzed the facets of the three polytopes, and established that the so-called cluster constraints giving rise to BNSL cutting planes are in fact facet-defining inequalities of the family-variable polytope central to BNSL. We also provide (in Appendix A) a complete enumeration of facets for low-dimensional family-variable polytopes, connecting with problem-specific cutting planes ruling out all network structures with short cyclic substructures. In summary, the theoretical results presented in this work deepen the current understanding of fundamental aspects of BNSL from various perspectives."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The authors gratefully acknowledge financial support from: UK Medical Research Council Grant G1002312 (JC, MB); Senior Postdoctoral Fellowship SF/14/008 from KU Leuven (JC); UK NC3RS Grant NC/K001264/1 (JC); Academy of Finland under grants 251170 COIN Centre of Excellence in Computational Inference Research, 276412, and 284591 (MJ); Research Funds of the University of Helsinki (MJ); and Icelandic Research Fund grant 152679-051 (JHK)."
    }, {
      "heading" : "Appendix A. Enumeration of Facets for Low-dimensional Family",
      "text" : "Variable Polytopes\nIn Section 6 we provided general results on the facets of the family variable polytope. In this section, we provide a complete listing of all facet-defining inequalities (i.e. a minimal description of the convex hull by inequalities) of the family variable polytope PF(V,PV ) for |V | = 2, 3, 4. We will observe that all lower bounds on variables, modified convexity constraints and κ-cluster inequalities are indeed among the facets found, as predicted by our theoretical results. Proposition 24 and the lifting theorem (Theorem 28) are also consistent with the list of facets. In the case of |V | = 4, we also see that there are many facets not given in Section 6. In Section A.4 we enumerate all facet-defining inequalities for |V | = 4, where at most two parents are allowed and observe that the results are consistent with Theorem 31.\nWe use a, b, c, and d to label the nodes. To simplify notation, we abbreviate variables such as xb←{a,c} to xb←ac.\nA.1 Node Set of Size 2\nWhen |V | = 2, there are 3 acyclic digraphs and F(V,PV ) = {a← {b}, b← {a}}. There are three facets: the two lower bounds and the 1-cluster constraint xa←b + xb←a ≤ 1.\nA.2 Node Set of Size 3\nWhen |V | = 3, there are 25 acyclic digraphs and\nF(V,PV ) = {a← {b}, a← {c}, a← {b, c}, b← {a}, b← {c}, b← {a, c}, c← {a}, c← {b}, c← {a, b}}.\nUsing the cdd computer program (Fukuda, 2015), we found all the facets of the convex hull of the 25 acyclic digraphs. There are 17 facet-defining inequalities:\n• 9 lower bounds on the 9 xi←J family variables;\n• 3 modified convexity constraints, one for each of a, b, and c;\n• 4 1-cluster constraints, one for each of the clusters {a, b}, {a, c}, {b, c}, and {a, b, c}; and\n• 1 2-cluster constraint for the cluster {a, b, c}.\nA.3 Node Set of Size 4\nWhen |V | = 4, there are 543 acyclic digraphs and\nF(V,PV ) = {a← {b}, a← {c}, a← {d}, a← {b, c}, a← {b, d}, a← {c, d}, a← {b, c, d}, b← {a}, b← {c}, b← {d}, b← {a, c}, b← {a, d}, b← {c, d}, b← {a, c, d}, c← {a}, c← {b}, c← {d}, c← {a, b}, c← {a, d}, c← {b, d}, c← {a, b, d}, d← {a}, d← {b}, d← {c}, d← {a, b}, d← {a, c}, d← {b, c}, d← {a, b, c}}.\nUsing cdd we discovered that there are 135 facet-defining inequalities of the family variable polytope:\n• 28 lower bounds on the 28 xi←J family variables;\n• 4 modified convexity constraints, one for each of a, b, c, and d;\n• 6 1-cluster constraints for each of the (\n4 2\n) = 6 clusters of size 2;\n• 4 1-cluster constraints for each of the (\n4 3\n) = 4 clusters of size 3;\n• 1 1-cluster constraint for the (\n4 4\n) = 1 cluster of size 4;\n• 4 2-cluster constraints for each of the (\n4 3\n) = 4 clusters of size 3;\n• 1 2-cluster constraint for the (\n4 4\n) = 1 cluster of size 4;\n• 1 3-cluster constraint for the (\n4 4\n) = 1 cluster of size 4; and\n• 86 other facet-defining inequalities.\nWe now list these 86 other facet-defining inequalities. These 86 inequalities fall into 9 permutation classes, and we give just one member of each of these 9 classes. By symmetry, any permutation of the 4 nodes a, b, c, and d in a facet-defining inequality will produce another facet-defining inequality. Some permutations do not change the inequality. We indicate this, for each permutation class, by showing which nodes can be permuted without changing the facet. For example, the expression ab|cd indicates that either a and b, or c and d, can be swapped without altering the inequality, so that there are 4!/(2× 2) = 6 distinct inequality in such a permutation class.\nFor each permutation class, we give the (arbitrarily chosen) name for that class that is used by the gobnilp system. The names run from 4B to 4I—there is no permutation class called ‘4A’, since, at one time in gobnilp, this was used to designate κ-cluster inequalities. With the exception of ‘4F’ and ‘4J’ inequalities, if the user wants, gobnilp can search for these facets as cutting planes for a given LP solution. By default only ‘4B’ cutting planes are looked for, since these cutting planes have empirically been found to perform well. Interestingly, 4B facets can be defined in terms of connected matroids, as noted by Studený (2015).\n4B facets ab|cd\nxa←b + xa←bc + xa←bd + xa←cd + xa←bcd\n+xb←a + xb←ac + xb←ad + xb←cd + xb←acd\n+xc←ad + xc←bd + xc←abd +xd←ac + xd←bc + xd←abc ≤ 2 (40)\n6 inequalities\n4C facets a|b|cd\nxa←c + xa←d + xa←bc + xa←bd + xa←cd + xa←bcd\n+xb←cd + xb←acd\n+xc←ab + xc←bd + xc←abd +xd←ab + xd←bc + xd←abc ≤ 2\n12 inequalities\n4D facets a|b|cd\nxa←b + xa←c + xa←d + xa←bc + xa←bd + 2xa←cd + 2xa←bcd\n+xb←a + xb←c + xb←d + xb←ac + xb←ad + xb←cd + xb←acd\n+xc←a + xc←ab + xc←ad + xc←abd +xd←a + xd←ab + xd←ac + xd←abc ≤ 3\n12 inequalities\n4E facets a|bcd\nxa←bc + xa←bd + xa←cd + 2xa←bcd\n+xb←ac + xb←ad + xb←acd\n+xc←ab + xc←ad + xc←abd +xd←ab + xd←ac + xd←abc ≤ 2\n4 inequalities\n4F facets ab|cd\nxa←cd + xa←bcd\n+xb←cd + xb←acd\n+xc←a + xc←b + xc←d + xc←ab + xc←ad + xc←bd + 2xc←abd +xd←a + xd←b + xd←c + xd←ab + xd←ac + xd←bc + 2xd←abc ≤ 3\n6 inequalities\n4G facets a|b|c|d\nxa←cd + xa←bcd\n+xb←c + xb←ac + xb←cd + xb←acd\n+xc←b + xc←d + xc←ab + xc←ad + xc←bd + 2xc←abd +xd←a + xd←b + xd←c + xd←ab + 2xd←ac + xd←bc + 2xd←abc ≤ 3\n24 inequalities\n4H facets a|b|cd\nxa←c + xa←d + xa←bc + xa←bd + xa←cd + 2xa←bcd\n+xb←acd\n+xc←ab + xc←abd +xd←ab + xd←abc ≤ 2\n12 inequalities\n4I facets ab|cd\nxa←c + xa←d + xa←bc + xa←bd + xa←cd + 2xa←bcd\n+xb←c + xb←d + xb←ac + xb←ad + xb←cd + 2xb←acd\n+xc←a + xc←b + xc←d + 2xc←ab + xc←ad + xc←bd + 2xc←abd +xd←a + xd←b + xd←c + 2xd←ab + xd←ac + xd←bc + 2xd←abc ≤ 4\n6 inequalities\n4J facets a|bcd\nxa←b + xa←c + xa←d + 2xa←bc + 2xa←bd + 2xa←cd + 2xa←bcd\n+xb←a + xb←ac + xb←ad + xb←cd + xb←acd\n+xc←a + xc←ab + xc←ad + xc←bd + xc←abd +xd←a + xd←ab + xd←ac + xd←bc + xd←abc ≤ 3\n4 inequalities\nA.4 Node Set of Size 4, Parent Set Size at most 2\nBy Theorem 31, if we have 4 nodes but only allow acyclic digraphs with at most two parents, then the following facet-defining inequalities from Section A.3 (with family variables xa←bcd, xb←acd, xc←abd, and xd←abc removed) should be facet-defining inequalities of the resulting polytope.\n• 24 lower bounds on the 24 xi←J family variables;\n• 4 modified convexity constraints, one for each of a, b, c, and d; • 6 1-cluster constraints for each of the (\n4 2\n) = 6 clusters of size 2;\n• 4 1-cluster constraints for each of the (\n4 3\n) = 4 clusters of size 3;\n• 1 1-cluster constraint for the (\n4 4\n) = 1 cluster of size 4;\n• 4 2-cluster constraints for each of the (\n4 3\n) = 4 clusters of size 3; and\n• 1 2-cluster constraint for the (\n4 4\n) = 1 cluster of size 4.\nIn addition all facet-defining inequalities of types 4B, 4C, 4D, and 4J should remain facet-defining. There are 6, 12, 12, and 4 of these, respectively. This adds up to a total of 24+4+6+4+1+4+1+6+12+12+4=78 facet-defining inequalities. Using cdd we computed the facet-defining inequalities of the convex hull of the (family-variable encoded) 443 acyclic digraphs with 4 nodes and where each node has at most 2 parents. We found, as expected, that all of these 78 inequalities were included. Moreover, we found that these 78 constitute the complete set of facet-defining inequalities—there are no others."
    }, {
      "heading" : "Appendix B. Lift-and-Project for Family Variable Polytopes",
      "text" : "In this appendix, we apply a ‘lift-and-project’ method based on the sink-based extended representation of Section 7.3 to derive a representation of PF({a, b, c, d},P{a,b,c,d}), whose facets are given in Section A.3, in terms of PF({b, c, d},P{b,c,d}), PF({a, c, d},P{a,c,d}), PF({a, b, d},P{a,b,d}) and PF({a, b, c},P{a,b,c}), whose facet-defining inequalities are given in Section A.2. First we have the relevant formulation of (33),\nxa + xb + xc + xd = 1, (41)\nstating that exactly one of the four nodes is the distinguished sink in any acyclic digraph using those four nodes. Recall that xj,i←J indicates that j is the distinguished sink and that J is the parent set for i so that xj,i←J = 0 if j ∈ J , so that, for example, xb,a←b = 0. With this observation we can write the linking equations (34) as follows.\nxa←b = xa,a←b + xc,a←b + xd,a←b (42)\nxa←c = xa,a←c + xb,a←c + xd,a←c (43)\nxa←d = xa,a←d + xb,a←d + xc,a←d (44)\nxb←a = xb,b←a + xc,b←a + xd,b←a (45)\nxb←c = xa,b←c + xb,b←c + xd,b←c (46)\nxb←d = xa,b←d + xb,b←d + xc,b←d (47)\nxc←a = xb,c←a + xc,c←a + xd,c←a (48)\nxc←b = xa,c←b + xc,c←b + xd,c←b (49)\nxc←d = xa,c←d + xb,c←d + xc,c←d (50)\nxd←a = xb,d←a + xc,d←a + xd,d←a (51)\nxd←b = xa,d←b + xc,d←b + xd,d←b (52)\nxd←c = xa,d←c + xb,d←c + xd,d←d (53)\nxa←bc = xa,a←bc + xd,a←bc (54)\nxa←bd = xa,a←bd + xc,a←bd (55)\nxa←cd = xa,a←cd + xb,a←cd (56)\nxb←ac = xb,b←ac + xd,b←ac (57)\nxb←ad = xb,b←ad + xc,b←ad (58)\nxb←cd = xb,b←cd + xa,b←cd (59)\nxc←ab = xc,c←ab + xd,c←ab (60)\nxc←ad = xb,c←ad + xc,c←ad (61)\nxc←bd = xa,c←bd + xc,c←bd (62)\nxd←ab = xc,d←ab + xd,d←ab (63)\nxd←ac = xb,d←ac + xd,d←ac (64)\nxd←bc = xa,d←bc + xd,d←bc (65)\nxa←bcd = xa,a←bcd (66)\nxb←acd = xb,b←acd (67)\nxc←abd = xc,c←abd (68)\nxd←abc = xd,d←abc (69)\nThirdly we have all equations of type (35). We label all inequalities with xa on the RHS as follows. The modified convexity constraints for a, b, c, and d are labelled a-a, a-b, a-c, and a-d, respectively. All other constraints are cluster constraints which we label as a-C, where C is the cluster and κ = 1, and a-2-C, where C is the cluster and κ = 2. Inequalities with xb, xc, and xd on the RHS are labelled analogously. The 36 inequalities of type (35) are now listed using this labelling convention.\nxa,b←c + xa,b←d + xa,b←cd ≤ xa (a-b) xa,c←b + xa,c←d + xa,c←bd ≤ xa (a-c) xa,d←b + xa,d←c + xa,d←cd ≤ xa (a-d)\nxa,b←c + xa,b←cd + xa,c←b + xa,c←bd ≤ xa (a-bc) xa,b←d + xa,b←cd + xa,d←b + xa,d←bd ≤ xa (a-bd) xa,c←d + xa,c←bd + xa,d←c + xa,d←cd ≤ xa (a-cd)\nxa,b←c + xa,b←d + xa,b←cd + xa,c←b + xa,c←d + xa,c←bd\n+xa,d←b + xa,d←c + xa,d←cb ≤ 2xa (a-bcd) xa,b←cd + xa,c←bd + xa,d←bc ≤ xa (a-2-bcd)\nxa,a←b + xa,a←c + xa,a←d + xa,a←bc\n+xa,a←bd + xa,a←cd + xa,a←bcd ≤ xa (a-a)\nxb,a←c + xb,a←c + xb,a←cd ≤ xb (b-a) xb,c←a + xb,c←d + xb,c←ad ≤ xb (b-c) xb,d←a + xb,d←c + xb,d←ac ≤ xb (b-d)\nxb,a←c + xb,a←cd + xb,c←a + xb,c←ad ≤ xb (b-ac) xb,a←d + xb,a←cd + xb,d←a + xb,d←ac ≤ xb (b-ad) xb,c←d + xb,c←bd + xb,d←c + xb,d←cd ≤ xb (b-cd)\nxb,a←c + xb,a←d + xb,a←cd + xb,c←a + xb,c←d + xb,c←ad\n+xb,d←a + xb,d←c + xb,d←ac ≤ 2xb (b-acd) xb,a←cd + xb,c←ad + xb,d←ac ≤ xb (b-2-acd)\nxb,b←a + xb,b←c + xb,b←d + xb,b←ac\n+xb,b←ad + xb,b←cd + xb,b←acd ≤ xb (b-b)\nxc,a←b + xc,a←d + xc,a←bd ≤ xc (c-a) xc,b←a + xc,b←d + xc,b←ad ≤ xc (c-b) xc,d←a + xc,d←b + xc,d←ab ≤ xc (c-d)\nxc,a←b + xc,a←bd + xc,b←a + xc,b←ad ≤ xc (c-ab) xc,a←d + xc,a←bd + xc,d←a + xc,d←ab ≤ xc (c-ad) xc,b←d + xc,b←ad + xc,d←b + xc,d←ab ≤ xc (c-bd)\nxc,a←b + xc,a←d + xc,a←bd + xc,b←a + xc,b←d + xc,b←ad\n+xc,d←a + xc,d←b + xc,d←ab ≤ 2xc (c-abd) xc,a←bd + xc,b←ad + xc,d←ab ≤ xc (c-2-abd)\nxc,c←a + xc,c←b + xc,c←d + xc,c←ab\n+xc,c←ad + xc,c←bd + xc,c←abd ≤ xc (c-c)\nxd,a←b + xd,a←c + xd,a←bc ≤ xd (d-a) xd,b←a + xd,b←c + xd,b←ac ≤ xd (d-b) xd,c←a + xd,c←a + xd,c←ab ≤ xd (d-c)\nxd,a←b + xd,a←bc + xd,b←a + xd,b←ac ≤ xd (d-ab) xd,a←c + xd,a←bc + xd,c←a + xd,c←ab ≤ xd (d-ac) xd,b←c + xd,b←ac + xd,c←b + xd,c←ab ≤ xd (d-cd)\nxd,a←b + xd,a←c + xd,a←bc + xd,b←a + xd,b←c + xd,b←ac\n+xd,c←a + xd,c←b + xd,c←ab ≤ 2xd (d-abc) xd,a←bc + xd,b←ac + xd,c←ab ≤ xd (d-2-abd)\nxd,d←a + xd,d←b + xd,d←c + xd,d←ab\n+xd,d←ac + xd,d←bc + xd,d←abc ≤ xd (d-d)\nUsing (66–69) it is possible to eliminate the variables xa,a←bcd, xb,b←acd, xc,c←abd, and xd,d←abc, and (66–69) from the representation. This leaves us with a representation of\nPF({a, b, c, d},P{a,b,c,d}) using 4+28+4×(9+6) = 92 variables, 25 equations, 36 inequalities of type (35), four lower bounds on the variables xj , 56 lower bounds (of 0) on the variables xi,j←J where |J | < 3, and four lower bounds (of 0) on the variables xi←J where |J | = 3. In total we have 100 inequalities.\nWe have given an explicit extended representation of PF({a, b, c, d},P{a,b,c,d}). Here is that representation described more briefly.\n• xa + xb + xc + xd = 1.\n• 24/2 = 12 unique permutations of xa←b = xa,a←b + xc,a←b + xd,a←b.\n• 24/2 = 12 unique permutations of xa←bc = xa,a←bc + xd,a←bc.\n• 24/2 = 12 unique permutations of xa,b←c + xa,b←d + xa,b←cd ≤ xa.\n• 24/2 = 12 unique permutations of xa,b←c + xa,b←cd + xa,c←b + xa,c←bd ≤ xa.\n• 24/6 = 4 unique permutations of xa,b←c+xa,b←d+xa,b←cd+xa,c←b+xa,c←d+xa,c←bd+ xa,d←b + xa,d←c + xa,d←cb ≤ 2xa.\n• 24/6 = 4 unique permutations of xa,b←cd + xa,c←bd + xa,d←bc ≤ xa.\n• 24/6 = 4 unique permutations of xa,a←b+xa,a←c+xa,a←d+xa,a←bc+xa,a←bd+xa,a←cd+ xa←bcd ≤ xa.\n• 4 lower bounds on the variables xj .\n• 56 lower bounds on variables xi,j←J where |J | < 3.\n• 4 lower bounds on variables xi←J where |J | = 3.\nThe crucial point is that the convex hull of solutions to our extended representation can be found by simply dropping the integrality restrictions on variables. (See (Conforti et al., 2014, p. 71) for the relevant proof.) If we ‘project away’ the additional variables from this\nconvex hull we end up with PF(V,PV ) = conv (⋃ j∈V PF(V, j) ) .\nWe now show explicitly that the facet-defining inequalities of PF({a, b, c, d},P{a,b,c,d}) can be derived by projection from our extended representation. This projection is done by forming linear combinations of extended representation facet-defining inequalities which only contain ‘normal’ family variables xi←J .\nFor example, consider adding the following inequalities: (a-a), (a-2-bcd), (b-b), (b-2acd), (c-c), (c-ab), (d-d) and (d-ab). Note that the RHS of this inequality is xa + xa + xb +\nxb + xc + xc + xd + xd = 2. So the result is\nxa,a←b + xa,a←c + xa,a←d + xa,a←bc + xa,a←bd + xa,a←cd + xa←bcd\n+xa,b←cd + xa,c←bd + xa,d←bc\n+xb,b←a + xb,b←c + xb,b←d + xb,b←ac + xb,b←ad + xb,b←cd + xb←acd\n+xb,a←cd + xb,c←ad + xb,d←ac\n+xc,c←a + xc,c←b + xc,c←d + xc,c←ab + xc,c←ad + xc,c←bd + xc←abd\n+xc,a←b + xc,a←bd + xc,b←a + xc,b←ad\n+xd,d←a + xd,d←b + xd,d←c + xd,d←ab + xd,d←ac + xd,d←bc + xd←abc +xd,a←b + xd,a←bc + xd,b←a + xd,b←ac ≤ 2.\nUsing (42-65) we can simplify this to\nxa←b + xa,a←c + xa,a←d + xa←bc + xa←bd + xa←cd + xa←bcd\n+xa,b←cd\n+xb←a + xb,b←c + xb,b←d + xb←ac + xb←ad + xb,b←cd + xb←acd\n+\n+xc,c←a + xc,c←b + xc,c←d + xc,c←ab + xc←ad + xc←bd + xc←abd\n+\n+xd,d←a + xd,d←b + xd,d←c + xd,d←ab + xd←ac + xd←bc + xd←abc + ≤ 2. (70)\nThis inequality can then be weakened by adding the lower bounds for the 14 remaining extended variables (thus removing them) which results in the 4B facet (40) of PF({a, b, c, d},P{a,b,c,d}).\nWe now show how each of the facet classes 4B-4J for PF({a, b, c, d},P{a,b,c,d}) listed in Section A.3 can be derived by projection from the extended representation. Projection is achieved by multiplying each facet-defining inequality in the extended representation by a non-negative scalar. Let the vector of these scalars be denoted u ≥ 0. In the following list we only provide positive components of u and do not bother to list those components of u corresponding to variable lower bounds. (Note that since these u vectors generate facetdefining inequalities of PF({a, b, c, d},P{a,b,c,d}), they must be extreme rays of the relevant projection cone (Balas, 2005).)"
    }, {
      "heading" : "4B facet",
      "text" : "ua−a = 1, ua−2−bcd = 1, ub−b = 1, ub−2−acd = 1, uc−c = 1, uc−ab = 1, ud−d = 1, ud−ab = 1"
    }, {
      "heading" : "4C facet",
      "text" : "ua−a = 1, ua−2−bcd = 1, ub−b = 1, ub−a = 1, uc−c = 1, uc−ad = 1, ud−d = 1, ud−ac = 1"
    }, {
      "heading" : "4D facet",
      "text" : "ua−a = 2, ua−b = 1, ub−b = 1, ub−ac = 1, ub−ad = 1, uc−c = 1, uc−abd = 1, ud−d = 1, ud−abc = 1"
    }, {
      "heading" : "4E facet",
      "text" : "ua−a = 2, ub−b = 1, ub−2−acd = 1, uc−c = 1, uc−2−abd = 1, ud−d = 1, ud−2−abc = 1"
    }, {
      "heading" : "4F facet",
      "text" : "ua−a = 1, ua−bcd = 1, ub−b = 1, ub−acd = 1, uc−c = 2, uc−d = 1, ud−d = 2, ud−c = 1"
    }, {
      "heading" : "4G facet",
      "text" : "ua−a = 1, ua−bcd = 1, ub−b = 1, ub−ad = 1, ub−cd = 1, uc−c = 2, uc−d = 1, ud−d = 2, ud−bc = 1"
    }, {
      "heading" : "4H facet",
      "text" : "ua−a = 2, ub−b = 1, ub−a = 1, uc−c = 1, uc−ad = 1, ud−d = 1, ud−ac = 1"
    }, {
      "heading" : "4I facet",
      "text" : "ua−a = 2, ua−bcd = 1, ub−b = 2, ub−acd = 1, uc−c = 2, uc−ad = 1, uc−bd = 1, ud−d = 2, ud−ac = 1, ud−bc = 1"
    }, {
      "heading" : "4J facet",
      "text" : "ua−a = 2, ua−2−bcd = 1, ub−b = 1, ub−ac = 1, ub−ad = 1, uc−c = 1, uc−ab = 1, uc−ad = 1, ud−d = 1, ud−ab = 1, ud−ac = 1\nWe have shown how to generate all facets of PF(V,PV ) for |V | = 4 from the |V | = 3 case. This was done by constructing the desired convex hull using an extended representation and then projecting away the extraneous variables. Although in this case we already had the convex hull for |V | = 4 (by direct computation using cdd) it is clear that the same technique could be used to construct the convex hull for |V | = 5 and above. The difficulty with this approach is identifying which projections u ≥ 0 generate facets. It was noted above that we can restrict attention to u which are extreme rays of the relevant projection cone. However, in general, not all extreme rays generate facets, it also necessary that the number of dimensions ‘lost’ when projecting the entire polytope matches the number lost when projecting the face whose projection is the putative facet (Balas, 2005). We do not investigate this here, leaving this issue for future work."
    } ],
    "references" : [ {
      "title" : "Constraint Integer Programming",
      "author" : [ "T. Achterberg" ],
      "venue" : "Ph.D. thesis, TU Berlin.",
      "citeRegEx" : "Achterberg,? 2007",
      "shortCiteRegEx" : "Achterberg",
      "year" : 2007
    }, {
      "title" : "Projection, lifting and extended formulation in integer and combinatorial optimization",
      "author" : [ "E. Balas" ],
      "venue" : "Annals of Operation Research, 140, 125–161.",
      "citeRegEx" : "Balas,? 2005",
      "shortCiteRegEx" : "Balas",
      "year" : 2005
    }, {
      "title" : "Integer linear programming for the Bayesian network structure learning problem",
      "author" : [ "M. Bartlett", "J. Cussens" ],
      "venue" : null,
      "citeRegEx" : "Bartlett and Cussens,? \\Q2015\\E",
      "shortCiteRegEx" : "Bartlett and Cussens",
      "year" : 2015
    }, {
      "title" : "Facet generating techniques",
      "author" : [ "S. Boyd", "W.R. Pulleyblank" ],
      "venue" : "Research Trends in Combinatorial Optimization, Bonn Workshop on Combinatorial Optimization",
      "citeRegEx" : "Boyd and Pulleyblank,? \\Q2009\\E",
      "shortCiteRegEx" : "Boyd and Pulleyblank",
      "year" : 2009
    }, {
      "title" : "Learning Bayesian networks is NP-Complete",
      "author" : [ "D.M. Chickering" ],
      "venue" : "Fisher, D., & Lenz, H.-J. (Eds.), Learning from Data: AI & Statistics V, chap. 12, pp. 121–130. Springer.",
      "citeRegEx" : "Chickering,? 1996",
      "shortCiteRegEx" : "Chickering",
      "year" : 1996
    }, {
      "title" : "Algebra, Vol",
      "author" : [ "P.M. Cohn" ],
      "venue" : "1. Wiley.",
      "citeRegEx" : "Cohn,? 1982",
      "shortCiteRegEx" : "Cohn",
      "year" : 1982
    }, {
      "title" : "Learning highdimensional directed acyclic graphs with latent and selection variables",
      "author" : [ "D. Colombo", "M.H. Maathuis", "M. Kalisch", "T.S. Richardson" ],
      "venue" : "Annals of Statistics,",
      "citeRegEx" : "Colombo et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Colombo et al\\.",
      "year" : 2012
    }, {
      "title" : "Maximum likelihood pedigree reconstruction using integer programming",
      "author" : [ "J. Cussens" ],
      "venue" : "Proceedings of the Workshop on Constraint Based Methods for Bioinformatics (WCB-10).",
      "citeRegEx" : "Cussens,? 2010",
      "shortCiteRegEx" : "Cussens",
      "year" : 2010
    }, {
      "title" : "Bayesian network learning with cutting planes",
      "author" : [ "J. Cussens" ],
      "venue" : "Cozman, F. G., & Pfeffer, A. (Eds.), Proceedings of the 27th Conference on Uncertainty in Artificial Intelligence (UAI 2011), pp. 153–160. AUAI Press.",
      "citeRegEx" : "Cussens,? 2011",
      "shortCiteRegEx" : "Cussens",
      "year" : 2011
    }, {
      "title" : "Maximum likelihood pedigree reconstruction using integer linear programming",
      "author" : [ "J. Cussens", "M. Bartlett", "E.M. Jones", "N.A. Sheehan" ],
      "venue" : "Genetic Epidemiology,",
      "citeRegEx" : "Cussens et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Cussens et al\\.",
      "year" : 2013
    }, {
      "title" : "Polyhedral aspects of score equivalence in Bayesian network structure learning",
      "author" : [ "J. Cussens", "D. Haws", "M. Studený" ],
      "venue" : "Submitted to Mathematical Programming",
      "citeRegEx" : "Cussens et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Cussens et al\\.",
      "year" : 2015
    }, {
      "title" : "Efficient structure learning of Bayesian networks using constraints",
      "author" : [ "de Campos", "P. Cassio", "Q. Ji" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Campos et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Campos et al\\.",
      "year" : 2011
    }, {
      "title" : "cdd and ccdplus homepage.. https://www.inf.ethz.ch/personal/ fukudak/cdd_home",
      "author" : [ "K. Fukuda" ],
      "venue" : null,
      "citeRegEx" : "Fukuda,? \\Q2015\\E",
      "shortCiteRegEx" : "Fukuda",
      "year" : 2015
    }, {
      "title" : "On the acyclic subgraph polytope",
      "author" : [ "M. Grötschel", "M. Jünger", "G. Reinelt" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Grötschel et al\\.,? \\Q1985\\E",
      "shortCiteRegEx" : "Grötschel et al\\.",
      "year" : 1985
    }, {
      "title" : "Facets of regular 0-1 polytopes",
      "author" : [ "P.L. Hammer", "E. Johnson", "U.N. Peled" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Hammer et al\\.,? \\Q1975\\E",
      "shortCiteRegEx" : "Hammer et al\\.",
      "year" : 1975
    }, {
      "title" : "Learning discrete Bayesian networks",
      "author" : [ "D. Heckerman", "D. Geiger", "D.M. Chickering" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Heckerman et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Heckerman et al\\.",
      "year" : 1995
    }, {
      "title" : "Hugin case stories",
      "author" : [ "Hugin" ],
      "venue" : "http://www.hugin.com/case-stories/.",
      "citeRegEx" : "Hugin,? 2016",
      "shortCiteRegEx" : "Hugin",
      "year" : 2016
    }, {
      "title" : "Learning Bayesian network structure using LP relaxations",
      "author" : [ "T. Jaakkola", "D. Sontag", "A. Globerson", "M. Meila" ],
      "venue" : "Proceedings of 13th International Conference on Artificial Intelligence and Statistics (AISTATS 2010),",
      "citeRegEx" : "Jaakkola et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Jaakkola et al\\.",
      "year" : 2010
    }, {
      "title" : "Exact Bayesian structure discovery in Bayesian networks",
      "author" : [ "M. Koivisto", "K. Sood" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "Koivisto and Sood,? \\Q2004\\E",
      "shortCiteRegEx" : "Koivisto and Sood",
      "year" : 2004
    }, {
      "title" : "Probabilistic Graphical Models: Principles and Techniques",
      "author" : [ "D. Koller", "N. Friedman" ],
      "venue" : null,
      "citeRegEx" : "Koller and Friedman,? \\Q2009\\E",
      "shortCiteRegEx" : "Koller and Friedman",
      "year" : 2009
    }, {
      "title" : "Predicting the hardness of learning Bayesian networks",
      "author" : [ "B. Malone", "K. Kangas", "M. Järvisalo", "M. Koivisto", "P. Myllymäki" ],
      "venue" : "Proceedings of the 28th AAAI Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Malone et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Malone et al\\.",
      "year" : 2014
    }, {
      "title" : "The Linear Ordering Problem: Exact and Heuristic Methods in Combinatorial Optimization",
      "author" : [ "R. Mart́ı", "G. Reinelt" ],
      "venue" : null,
      "citeRegEx" : "Mart́ı and Reinelt,? \\Q2011\\E",
      "shortCiteRegEx" : "Mart́ı and Reinelt",
      "year" : 2011
    }, {
      "title" : "Exact maximum margin structure learning of Bayesian networks",
      "author" : [ "R. Peharz", "F. Pernkopf" ],
      "venue" : "In Proceedings of the 29th International Conference on Machine Learning (ICML",
      "citeRegEx" : "Peharz and Pernkopf,? \\Q2012\\E",
      "shortCiteRegEx" : "Peharz and Pernkopf",
      "year" : 2012
    }, {
      "title" : "Improved maximum likelihood reconstruction of complex multi-generational pedigrees",
      "author" : [ "N. Sheehan", "M. Bartlett", "J. Cussens" ],
      "venue" : "Theoretical Population Biology,",
      "citeRegEx" : "Sheehan et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Sheehan et al\\.",
      "year" : 2014
    }, {
      "title" : "A simple approach for finding the globally optimal Bayesian network structure",
      "author" : [ "T. Silander", "P. Myllymäki" ],
      "venue" : "In Proceedings of the 22nd Conference on Uncertainty in Artificial Intelligence (UAI",
      "citeRegEx" : "Silander and Myllymäki,? \\Q2006\\E",
      "shortCiteRegEx" : "Silander and Myllymäki",
      "year" : 2006
    }, {
      "title" : "Causation, Prediction and Search",
      "author" : [ "P. Spirtes", "C. Glymour", "R. Scheines" ],
      "venue" : null,
      "citeRegEx" : "Spirtes et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Spirtes et al\\.",
      "year" : 1993
    }, {
      "title" : "How matroids occur in the context of learning Bayesian network structure",
      "author" : [ "M. Studený" ],
      "venue" : "Meila, M., & Heskes, T. (Eds.), Proceedings of the 31st Conference on Uncertainty in Artificial Intelligence (UAI 2015), pp. 832–841. AUAI Press.",
      "citeRegEx" : "Studený,? 2015",
      "shortCiteRegEx" : "Studený",
      "year" : 2015
    }, {
      "title" : "The max-min hill-climbing Bayesian network structure learning algorithm",
      "author" : [ "I. Tsamardinos", "L.E. Brown", "C.F. Aliferis" ],
      "venue" : "Machine Learning,",
      "citeRegEx" : "Tsamardinos et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Tsamardinos et al\\.",
      "year" : 2006
    }, {
      "title" : "Machine learning of Bayesian networks using constraint programming",
      "author" : [ "P. van Beek", "H. Hoffmann" ],
      "venue" : "Proceedings of the 21st International Conference on Principles and Practice of Constraint Programming (CP 2015),",
      "citeRegEx" : "Beek and Hoffmann,? \\Q2015\\E",
      "shortCiteRegEx" : "Beek and Hoffmann",
      "year" : 2015
    }, {
      "title" : "Integer Programming",
      "author" : [ "L.A. Wolsey" ],
      "venue" : "John Wiley.",
      "citeRegEx" : "Wolsey,? 1998",
      "shortCiteRegEx" : "Wolsey",
      "year" : 1998
    }, {
      "title" : "Learning optimal Bayesian networks: A shortest path perspective",
      "author" : [ "C. Yuan", "B. Malone" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Yuan and Malone,? \\Q2013\\E",
      "shortCiteRegEx" : "Yuan and Malone",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 16,
      "context" : "Bayesian networks (Koller & Friedman, 2009) form a central class of probabilistic graphical models that finds applications in various domains (Hugin, 2016; Sheehan et al., 2014).",
      "startOffset" : 142,
      "endOffset" : 177
    }, {
      "referenceID" : 23,
      "context" : "Bayesian networks (Koller & Friedman, 2009) form a central class of probabilistic graphical models that finds applications in various domains (Hugin, 2016; Sheehan et al., 2014).",
      "startOffset" : 142,
      "endOffset" : 177
    }, {
      "referenceID" : 25,
      "context" : "In the constraint-based approach (Spirtes et al., 1993; Colombo et al., 2012) the goal is to learn a network which is consistent with conditional independence relations which have been inferred from the data.",
      "startOffset" : 33,
      "endOffset" : 77
    }, {
      "referenceID" : 6,
      "context" : "In the constraint-based approach (Spirtes et al., 1993; Colombo et al., 2012) the goal is to learn a network which is consistent with conditional independence relations which have been inferred from the data.",
      "startOffset" : 33,
      "endOffset" : 77
    }, {
      "referenceID" : 15,
      "context" : "Even when the score function is restricted to be a BDe score (Heckerman et al., 1995), the BNSL problem has been shown to be NP-hard (Chickering, 1996).",
      "startOffset" : 61,
      "endOffset" : 85
    }, {
      "referenceID" : 4,
      "context" : ", 1995), the BNSL problem has been shown to be NP-hard (Chickering, 1996).",
      "startOffset" : 55,
      "endOffset" : 73
    }, {
      "referenceID" : 27,
      "context" : "Due to NPhardness, much work on BNSL has focused on developing approximate, local search style algorithms (Tsamardinos et al., 2006) that most often cannot give guarantees on how close to optimal, in terms of the objective function, are the structures found.",
      "startOffset" : 106,
      "endOffset" : 132
    }, {
      "referenceID" : 8,
      "context" : "Recently, despite its complexity, several advances in exact approaches to BNSL have surfaced (Koivisto & Sood, 2004; Silander & Myllymäki, 2006; Cussens, 2011; de Campos & Ji, 2011; Yuan & Malone, 2013; van Beek & Hoffmann, 2015), ranging from problem-specific dynamic programming branch-and-bound algorithms to approaches based on A∗-style state-space search, constraint programming, and integer linear programming (IP), which can, with certain restrictions, learn provably-optimal BN structures with tens to hundreds of nodes.",
      "startOffset" : 93,
      "endOffset" : 229
    }, {
      "referenceID" : 20,
      "context" : "As shown in a recent study (Malone et al., 2014), perhaps the most successful exact approach to BNSL is provided by the gobnilp system (Cussens, 2011).",
      "startOffset" : 27,
      "endOffset" : 48
    }, {
      "referenceID" : 8,
      "context" : ", 2014), perhaps the most successful exact approach to BNSL is provided by the gobnilp system (Cussens, 2011).",
      "startOffset" : 94,
      "endOffset" : 109
    }, {
      "referenceID" : 19,
      "context" : "Koller and Friedman (2009). Specifically, in this paper we restrict attention to decomposable score functions, where the score is defined locally by the parent set choices for each i ∈ V .",
      "startOffset" : 0,
      "endOffset" : 27
    }, {
      "referenceID" : 4,
      "context" : "Even though BNSL remains NP-hard unless κ = 1 (Chickering, 1996), such results suggest that in practice the value of κ is an important determining factor of the hardness of a BNSL instance.",
      "startOffset" : 46,
      "endOffset" : 64
    }, {
      "referenceID" : 22,
      "context" : "For example, with κ = 2, Sheehan et al. (2014) were able to solve BNSL instances with |V | = 1614 in between 3 and 42 minutes.",
      "startOffset" : 25,
      "endOffset" : 47
    }, {
      "referenceID" : 7,
      "context" : "There are a number of ways of ruling out cycles (Cussens, 2010; Peharz & Pernkopf, 2012; Cussens et al., 2013).",
      "startOffset" : 48,
      "endOffset" : 110
    }, {
      "referenceID" : 9,
      "context" : "There are a number of ways of ruling out cycles (Cussens, 2010; Peharz & Pernkopf, 2012; Cussens et al., 2013).",
      "startOffset" : 48,
      "endOffset" : 110
    }, {
      "referenceID" : 7,
      "context" : "There are a number of ways of ruling out cycles (Cussens, 2010; Peharz & Pernkopf, 2012; Cussens et al., 2013). In this paper we focus on cluster constraints first introduced by Jaakkola et al. (2010). A cluster is simply a subset of nodes.",
      "startOffset" : 49,
      "endOffset" : 201
    }, {
      "referenceID" : 2,
      "context" : "The gobnilp approach to solving this IP are fully detailed by Bartlett and Cussens (2015); here we overview the essential ideas.",
      "startOffset" : 62,
      "endOffset" : 90
    }, {
      "referenceID" : 0,
      "context" : "de) (Achterberg, 2007) and it uses SCIP to generate many other cutting planes in addition to cluster constraints.",
      "startOffset" : 4,
      "endOffset" : 22
    }, {
      "referenceID" : 2,
      "context" : "by Bartlett and Cussens (2015). Given an LP solution x∗ to separate, the variables of the sub-IP include binary variables yi←J for each family such that x ∗ i←J > 0.",
      "startOffset" : 3,
      "endOffset" : 31
    }, {
      "referenceID" : 2,
      "context" : "It is not difficult to show—Bartlett and Cussens (2015) provide the detail—that any feasible solution to sub-IP (9–13) determines a cutting plane for x∗ and that a proof of the sub-IP’s infeasibility establishes that there is no such cutting plane.",
      "startOffset" : 28,
      "endOffset" : 56
    }, {
      "referenceID" : 29,
      "context" : "Affine independence is defined as follows (Wolsey, 1998).",
      "startOffset" : 42,
      "endOffset" : 56
    }, {
      "referenceID" : 26,
      "context" : "That PF ( PCLUSTER also implies that it may be worth searching for facetdefining cuts which are not cluster inequalities, for example those discovered by Studený (2015).",
      "startOffset" : 154,
      "endOffset" : 169
    }, {
      "referenceID" : 14,
      "context" : "From Proposition 20 and the result of Hammer et al. (1975) we have the result but with π0 ≥ 0.",
      "startOffset" : 38,
      "endOffset" : 59
    }, {
      "referenceID" : 8,
      "context" : "The κ-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3).",
      "startOffset" : 27,
      "endOffset" : 42
    }, {
      "referenceID" : 7,
      "context" : "The κ-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3). The cluster inequalities (3) are κ-cluster inequalities for the special case of κ = 1. In the next section (Section 6.3) we will show how to ‘lift’ facet-defining inequalities. This provides an easy generalisation (Theorem 29) of the result of this section which shows that, when all parent sets are allowed, all κ-cluster inequalities are facets, not just those for which C = V . As a special case, this implies that the cluster inequalities devised by Jaakkola et al. (2010) are facets of the family variable polytope, when all parent sets are allowed.",
      "startOffset" : 28,
      "endOffset" : 570
    }, {
      "referenceID" : 7,
      "context" : "The κ-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3). The cluster inequalities (3) are κ-cluster inequalities for the special case of κ = 1. In the next section (Section 6.3) we will show how to ‘lift’ facet-defining inequalities. This provides an easy generalisation (Theorem 29) of the result of this section which shows that, when all parent sets are allowed, all κ-cluster inequalities are facets, not just those for which C = V . As a special case, this implies that the cluster inequalities devised by Jaakkola et al. (2010) are facets of the family variable polytope, when all parent sets are allowed. An alternative proof for the fact that κ-cluster inequalities are facet-defining was recently provided by Cussens et al. (2015) (see Corollary 4 of that paper).",
      "startOffset" : 28,
      "endOffset" : 776
    }, {
      "referenceID" : 7,
      "context" : "The κ-cluster inequalities (Cussens, 2011) are a generalisation of cluster inequalities (3). The cluster inequalities (3) are κ-cluster inequalities for the special case of κ = 1. In the next section (Section 6.3) we will show how to ‘lift’ facet-defining inequalities. This provides an easy generalisation (Theorem 29) of the result of this section which shows that, when all parent sets are allowed, all κ-cluster inequalities are facets, not just those for which C = V . As a special case, this implies that the cluster inequalities devised by Jaakkola et al. (2010) are facets of the family variable polytope, when all parent sets are allowed. An alternative proof for the fact that κ-cluster inequalities are facet-defining was recently provided by Cussens et al. (2015) (see Corollary 4 of that paper). The proof establishes not only that κ-cluster inequalities are facet-defining, but also that they are score-equivalent. A face of the family variable polytope is said to be score-equivalent if it is the optimal face for some score equivalent objective. An objective function is score equivalent if it gives the same value to any two acyclic digraphs which are Markov equivalent (encode the same conditional independence relations). In later work, Studený (2015) went further and showed that κ-cluster inequalities form just part of a more general class of facet-defining inequalities which can be defined in terms of connected matroids.",
      "startOffset" : 28,
      "endOffset" : 1271
    }, {
      "referenceID" : 3,
      "context" : "As Boyd and Pulleyblank (2009) note “As it is often technically much simpler to obtain results",
      "startOffset" : 3,
      "endOffset" : 31
    }, {
      "referenceID" : 5,
      "context" : "Since this is an elementary operation it does not change the rank of the matrix (Cohn, 1982), and so A2 has rank m.",
      "startOffset" : 80,
      "endOffset" : 92
    }, {
      "referenceID" : 13,
      "context" : "1 BSNL as the Acyclic Subgraph Problem BNSL is closely related to the well-known acyclic subgraph problem (ASP) (Grötschel et al., 1985).",
      "startOffset" : 112,
      "endOffset" : 136
    }, {
      "referenceID" : 21,
      "context" : "Note that, as Mart́ı and Reinelt (2011) show, ASP is equivalent to the linear ordering problem (LOP).",
      "startOffset" : 14,
      "endOffset" : 40
    } ],
    "year" : 2016,
    "abstractText" : "The challenging task of learning structures of probabilistic graphical models is an important problem within modern AI research. Recent years have witnessed several major algorithmic advances in structure learning for Bayesian networks—arguably the most central class of graphical models—especially in what is known as the score-based setting. A successful generic approach to optimal Bayesian network structure learning (BNSL), based on integer programming (IP), is implemented in the gobnilp system. Despite the recent algorithmic advances, current understanding of foundational aspects underlying the IP based approach to BNSL is still somewhat lacking. Understanding fundamental aspects of cutting planes and the related separation problem is important not only from a purely theoretical perspective, but also since it holds out the promise of further improving the efficiency of state-of-the-art approaches to solving BNSL exactly. In this paper, we make several theoretical contributions towards these goals: (i) we study the computational complexity of the separation problem, proving that the problem is NP-hard; (ii) we formalise and analyse the relationship between three key polytopes underlying the IP-based approach to BNSL; (iii) we study the facets of the three polytopes both from the theoretical and practical perspective, providing, via exhaustive computation, a complete enumeration of facets for low-dimensional family-variable polytopes; and, furthermore, (iv) we establish a tight connection of the BNSL problem to the acyclic subgraph problem.",
    "creator" : "TeX"
  }
}