{
  "name" : "1505.00828.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Dynamic Consistency of Conditional Simple Temporal Networks via Mean Payoff Games: a Singly-Exponential Time DC-Checking",
    "authors" : [ "Carlo Comin", "Romeo Rizzi" ],
    "emails" : [ "carlo.comin@unitn.it", "romeo.rizzi@univr.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Index Terms—Conditional Simple Temporal Networks, Dynamic Consistency, Mean Payoff Games, Hyper Temporal Networks, Singly-Exponential Time, Reaction Time Analysis.\nI. INTRODUCTION AND MOTIVATION\nIn temporal planning and temporal scheduling, Simple Temporal Networks (STNs) [9] are directed weighted graphs, where nodes represent events to be scheduled in time and arcs represent temporal distance constraints between pairs of events. Recently, STNs have been generalized into Hyper Temporal Networks (HyTNs) [7], [8] by considering weighted directed hypergraphs, where each hyperarc models a disjunctive temporal constraint called hyper-constraint. The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff\nGames (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8]. Mean Payoff Games are a family of two-player infinite games played on finite graphs, well known for having theoretical interest in computational complexity, being it one of the few (natural) problems lying in NP∩ coNP, as well as various applications in model-checking and formal verification [11].\nThe present work unveils that HyTNs and MPGs are a natural underlying combinatorial model for checking the dynamicconsistency of conditional temporal problems. We focus on Conditional Simple Temporal Problems (CSTP) [16] and on their graph-based counterpart Conditional Simple Temporal Networks (CSTN) [12], a constraint-based model for conditional temporal planning. The CSTN formalism extends STNs in that: (1) some of the nodes are called observation events and to each of them is associated a boolean variable, to be disclosed only at execution time; (2) labels (i.e. conjunctions over the literals) are attached to all nodes and constraints, to indicate the situations in which each of them is required. The planning agent must schedule all the required nodes, meanwhile respecting all the required temporal constraints among them. This extended framework allows for the offline construction of conditional plans that are guaranteed to satisfy complex temporal constraints. Importantly, this can be achieved even while allowing for the decisions about the precise timing of actions to be postponed until execution time, in a least-commitment manner, thereby adding flexibility and making it possible to adapt the plan dynamically, during execution, in response to the observations made [16].\nThree notions of consistency arise for CSTNs: weak, strong, and dynamic. Dynamic consistency (DC) is in fact the most interesting one, as it requires the existence of conditional plans where decisions about the precise timing of actions are postponed until execution time, but it anyhow guarantees that all the relevant constraints will be ultimately satisfied. Still, it is the most challenging and it was conjectured to be hard to assess by Tsamardinos, Vidal and Pollack [16]. Indeed, the best-so-far algorithm for deciding whether a CSTN is dynamically-consistent is doubly-exponential time [16]. It first\nar X\niv :1\n50 5.\n00 82\n8v 4\n[ cs\n.D S]\n1 7\nJu l 2\nbuilds an equivalent Disjunctive Temporal Problem (DTP) of size exponential in the input CSTN, and then applies to it an exponential time DTP’s algorithm to check its consistency. However, this approach turns out to be limitative in practice: to the best of our knowledge, some experimental studies have shown that the resolution procedures, as well as the heuristics, for solving general DTPs becomes quite burdensome with ∼ 30, 35 DTP’s variables [13]–[15], thus dampening the practical applicability of the approach.\nContribution: In the present work we first offer a proof that deciding whether a CSTN is dynamically-consistent is coNP-hard. Secondly, and most importantly, we unveil a connection between the problem of checking dynamic-consistency of CSTNs and that of determining MPGs, thus providing the first sound-and-complete singly-exponential time algorithm for this same task of deciding the dynamic-consistency and yielding a dynamic execution strategy for CSTNs. The algorithm can actually be applied to a wider class of problems and it is based on representing any given instance on an exponential sized network, as first suggested in [16]. The difference, however, is that we propose to map CSTNs on HyTNs/MPGs rather than on DTPs. This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]). To summarize, we obtain an improved upper bound on the theoretical time complexity of the DC-checking for CSTNs (i.e., from 2-EXP to NE ∩ coNE) together with a faster DC-checking procedure, which can be used on CSTNs with a larger number of propositional variables and event nodes. At the heart of the algorithm a suitable reduction to MPGs is mediated by the HyTN model, i.e., the algorithm decides whether a CSTN is dynamically-consistent by solving a carefully constructed MPG. As a final contribution, in order to analyze the algorithm, we introduce a novel and refined notion of dynamic-consistency, named -dynamic-consistency, and present a sharp lower bounding analysis on the critical value of the reaction time ε̂ where the CSTN transits from being, to not being, dynamically-consistent. We believe that this contributes to clarifying (with respect to previous literature [12], [16]) the role played by the reaction time ε̂ in checking the dynamic-consistency of CSTNs. Furthermore, the proof technique introduced in this analysis of ε̂ is applicable more in general when dealing with linear difference constraints which include strict inequalities, therefore, it may be useful in the analysis of other models of temporal constraints.\nOrganization: In Section II A we recall the basic formalism, terminology and known results on CSTPs and CSTNs. Section II B is devoted to recall the HyTN model, its computational equivalence with MPGs and the related algorithmic results. Section III tackles on the algorithmics of dynamicconsistency: firstly, we provide a coNP-hardness lower bound, then, we describe the connection with HyTNs/MPGs and present a (pseudo) singly-exponential time DC-checking pro-\ncedure. Section IV is devoted to present a sharp lower bounding analysis on the critical value of the reaction time ε̂ where the CSTN transits from being, to not being, dynamicallyconsistent. In Section V some related works are discussed. The paper concludes in Section VI."
    }, {
      "heading" : "II. BACKGROUND",
      "text" : "In order to provide a formal support to the present work, this section recalls the basic formalism, terminology and known results on CSTPs and CSTNs. Since the forthcoming definitions are mostly inherited from the literature, the reader is referred to [16] and [12] for an intuitive semantic discussion and for some clarifying examples of the very same model.\nTo begin with, our graphs are directed and weighted on the arcs. Thus, if G = 〈V,A〉 is a graph, then every arc a ∈ A is a triplet 〈u, v, wa〉 where u = t(a) ∈ V is the tail of a, v = h(a) ∈ V is the head of a, and wa = w(u, v) ∈ Z the weight of a. The following definition recalls Simple Temporal Networks (STNs) [9], as they provide a powerful and general tool for representing conjunctions of minimum and maximum distance constraints between pairs of temporal variables.\nDefinition 1 (STNs). An STN [9] is a weighted directed graph whose nodes are events that must be placed on the real time line and whose arcs, called standard arcs, express binary constraints on the allocations of their end-points in time.\nAn STN G = 〈V,A〉 is called consistent if it admits a feasible scheduling, i.e., a scheduling φ : V 7→ R such that φ(v) ≤ φ(u) + w(u, v) for all arcs 〈u, v, w(u, v)〉 ∈ A.\nA. Conditional Simple Temporal Networks\nIn 2003, Tsamardinos, Vidal and Pollack introduced the Conditional Simple Temporal Problem (CSTP) as an extension of standard temporal constraint-satisfaction models used in non-conditional temporal planning. A CSTP augments an STN to include observation events. Each observation event has a boolean variable (or proposition) associated with it. When the observation event is executed, the truth-value of its associated proposition becomes known. In addition, each event and each constraint has a label that restricts the scenarios in which it plays a role. Although not included in the formal definition, Tsamardinos, et al. discussed some supplementary reasonability assumptions that any well-defined CSTP must satisfy. Subsequently, those conditions have been analyzed and formalized in [12], leading to the sound notion of Conditional Simple Temporal Network (CSTN), which is now recalled.\nLet P be a set of boolean variables, a label is any (possibly empty) conjunction of variables, or negations of variables, drawn from P . The empty label is denoted by λ. The label universe of P , denoted P ∗, is the set of all (possibly empty) labels whose literals are drawn from P . Two labels, `1 and `2, are called consistent, denoted1 by Con(`1, `2), when `1 ∧ `2 is satisfiable. A label `1 subsumes a label `2, denoted1 by Sub(`1, `2), when `1 ⇒ `2 holds. We are now in the position to recall the definition of CSTNs.\n1The notation Con(·, ·) and Sub(·, ·) is inherited from [12], [16].\nDefinition 2 (CSTNs). A Conditional Simple Temporal Network (CSTN) is a tuple 〈V,A,L,O,OV, P 〉 where: • V is a finite set of events; P = {p1, . . . , p|P |} is a finite\nset of boolean variables (or propositions); • A is a set of labeled temporal constraints each having the\nform 〈v− u ≤ w(u, v), `〉, where u, v ∈ V , w(u, v) ∈ Z, and ` ∈ P ∗; • L : V → P ∗ is a function that assigns a label to each event in V ; OV ⊆ V is a finite set of observation events; O : P → OV is a bijection that associates a unique observation event O(p) = Op to each proposition p ∈ P ; • The following reasonability assumptions must hold: (WD1) for any labeled constraint 〈v−u ≤ w, `〉 ∈ A the label ` is satisfiable and subsumes both L(u) and L(v); intuitively, whenever a constraint v−u ≤ w is required to be satisfied, then its endpoints u and v must be scheduled (sooner or later) by the planning agent; (WD2) for each p ∈ P and each u ∈ V such that either p or ¬p appears in L(u), we require: Sub(L(u), L(Op)), and 〈Op−u ≤ − , L(u)〉 ∈ A for some > 0; intuitively, whenever a label L(u) of an event node u contains proposition p, and u gets eventually scheduled, then the observation event Op must be scheduled strictly before u by the planning agent. (WD3) for each labeled constraint 〈v − u ≤ w, `〉 and p ∈ P , for which either p or ¬p appears in `, it holds that Sub(`, L(Op)); intuitively, assuming a required constraint contains proposition p, then the observation event Op must be scheduled (sooner or later) by the planner.\nExample 1. Fig. 1 depicts an example of a CSTN Γ1 having three event nodes A, B and C as well as two observation events Op and Oq .\nIn the following definitions we will implicitly refer to some\nCSTN which is denoted Γ = 〈V,A,L,O,OV, P 〉.\nDefinition 3 (Scenario). A scenario over a set P of boolean variables is a truth assignment s : P → {>,⊥}, i.e., s is a function that assigns a truth value to each proposition p ∈ P . The set of all scenarios over P is denoted ΣP . If s ∈ ΣP is a scenario and ` ∈ P ∗ is a label, then s(`) ∈ {>,⊥} denotes the truth value of ` induced by s in the natural way.\nNotice that any scenario s ∈ ΣP can be described by means of the label `s , l1∧· · ·∧l|P | such that, for every 1 ≤ i ≤ |P |, the literal li ∈ {pi,¬pi} satisfies s(li) = >.\nExample 2. Consider the set of propositional variables P = {p, q}. The scenario s : P → {>,⊥} defined as s(p) = > and s(q) = ⊥ can be compactly described by the label `s = p∧¬q.\nDefinition 4 (Scheduling). A scheduling for a subset of events U ⊆ V is a function φ : U → R that assigns a real number to each event in U . The set of all schedules over U is denoted ΦU .\nDefinition 5 (Scenario Restriction). Let s ∈ ΣP be a scenario. The restriction of V and A w.r.t. s are defined as follows: • V +s , {v ∈ V | s(L(v)) = >}; • A+s , {〈u, v, w〉 | ∃` 〈v − u ≤ w, `〉 ∈ A, s(`) = >}. The restriction of Γ w.r.t. s is defined as Γ+s , 〈V +s , A+s 〉. Finally, it is worth to introduce the notation V +s1,s2 , V + s1∩V + s2 .\nWe remark that the restriction Γ+s is always an STN.\nDefinition 6 (Execution Strategy). An execution strategy for Γ is a mapping σ : ΣP → ΦV such that, for any scenario s ∈ ΣP , the domain of the scheduling σ(s) is V +s . The set of execution strategies of Γ is denoted by SΓ. The execution time of an event v ∈ V +s in the schedule σ(s) ∈ ΦV +s is denoted by [σ(s)]v .\nDefinition 7 (Scenario History). Let σ ∈ SΓ be an execution strategy, let s ∈ ΣP be a scenario and let v ∈ V +s be an event. The scenario history scHst(v, s, σ) of v in the scenario s for the strategy σ is defined as: scHst(v, s, σ) , {(p, s(p)) | p ∈ P, Op ∈ V +s ∩ OV, [σ(s)]Op < [σ(s)]v}.\nThe scenario history can be compactly expressed by the conjunction of the literals corresponding to the observations comprising it. Thus, we may treat a scenario history as though it were a label.\nDefinition 8 (Viable Execution Strategy). We say that σ ∈ SΓ is a viable execution strategy if, for each scenario s ∈ ΣP , the scheduling σ(s) ∈ ΦV is feasible for the STN Γ+s .\nDefinition 9 (Dynamic Consistency). An execution strategy σ ∈ SΓ is called dynamic if, for any s1, s2 ∈ ΣP and any event v ∈ V +s1,s2 , the following implication holds:\nCon(scHst(v, s1, σ), s2)⇒ [σ(s1)]v = [σ(s2)]v.\nWe say that Γ is dynamically-consistent if it admits σ ∈ SΓ which is both viable and dynamic. The problem of checking whether a given CSTN is dynamically-consistent is named CSTN-DC.\nExample 3. Consider the CSTN Γ of Fig. 1, and let the scenarios s1, s2, s3, s4 be defined as: s1(p) = ⊥, s1(q) = ⊥; s2(p) = ⊥, s2(q) = >; s3(p) = >, s3(q) = ⊥; s4(p) = >, s4(q) = >. It follows an example of execution strategy σ ∈ SΓ: [σ(si)]A = 0 for every i ∈ {1, 2, 3, 4}; [σ(si)]B = 8 for every i ∈ {1, 2, 4} and [σ(s3)]B = 3; [σ(si)]C = 10 for every i ∈ {1, 2, 3, 4}; [σ(si)]Op = 1 for every i ∈ {1, 2, 3, 4}. [σ(si)]Oq = 2 for every i ∈ {3, 4} and [σ(si)]Oq = 9 for every i ∈ {1, 2}. The reader can check that σ is viable and dynamic. Indeed, σ admits the tree-like representation depicted in Fig 2.\nWe introduce next a crucial notion for studying dynamicconsistency of CSTNs, that is the difference set ∆(s1; s2).\nDefinition 10 (Difference Set). Let s1, s2 ∈ ΣP be two scenarios. The set of observation events in V +s1 ∩OV at which s1 and s2 differ is denoted by ∆(s1; s2). Formally,\n∆(s1; s2) , {Op ∈ V +s1 ∩ OV | s1(p) 6= s2(p)}.\nNotice that commutativity may not hold, i.e., in general it may be the case that ∆(s1; s2) 6= ∆(s2; s1).\nExample 4. Consider the CSTN Γ of Fig. 1 and the scenarios s1, s2 defined: s1(p) = ⊥, s1(q) = ⊥; s2(p) = ⊥, s2(q) = >.\nThen, ∆(s1; s2) = {Oq}.\nThe next lemma will be useful later on in Section III.\nLemma 1. Let s1, s2 ∈ ΣP and v ∈ V +s1,s2 . Let σ ∈ SΓ be an execution strategy. Then, σ is dynamic if and only if the following implication holds for every s1, s2 ∈ ΣP , u ∈ V +s1,s2 :( ∧ v∈∆(s1;s2) [σ(s1)]u ≤ [σ(s1)]v ) ⇒ [σ(s1)]u = [σ(s2)]u (L1)\nProof: Notice that, by definition of Con(·, ·) and scHst(·, ·, ·), Con(scHst(u, s1, σ), s2) holds if and only if there\nis no observation event v ∈ ∆(s1; s2) which is scheduled by σ(s1) strictly before u. Therefore, Con(scHst(u, s1, σ), s2) holds if and only if ∧ v∈∆(s1;s2)[σ(s1)]u ≤ [σ(s1)]v . Thus, by definition of dynamic execution strategy, the thesis follows.\nB. Hyper Temporal Networks\nThis subsection surveys the Hyper Temporal Network (HyTN) model, which is a strict generalization of STNs. The reader is referred to [7], [8] for an in-depth treatise on HyTNs.\nDefinition 11 (Hypergraph). A hypergraph H is a pair 〈V,A〉, where V is the set of nodes, andA is the set of hyperarcs. Each hyperarc A = 〈tA, HA, wA〉 ∈ A has a distinguished node tA, called the tail of A, and a nonempty set HA ⊆ V \\ {tA} containing the heads of A; to each head v ∈ HA is associated a weight wA(v) ∈ Z.\nProvided that |A| , |HA ∪ {tA}|, the size of a hypergraph H = 〈V,A〉 is defined as mA , ∑ A∈A |A|, and it is used as a measure for the encoding length of H. If |A| = 2, then A = 〈u, v, w〉 can be regarded as a standard arc. In this way, hypergraphs generalize graphs.\nA HyTN is a weighted hypergraph H = 〈V,A〉 where a node represents an event to be scheduled, and a hyperarc represents a set of temporal distance constraints between the tail and the heads,\nIn the HyTN framework the consistency problem is defined to be the following decision problem.\nDefinition 12 (HyTN-Consistency). Given a HyTN H = 〈V,A〉, decide whether there exists a scheduling function φ : V → R such that:\nφ(tA) ≥ min v∈HA φ(v)− wA(v), ∀ A ∈ A\nany such scheduling φ : V → R is called feasible. A HyTN is called consistent whenever it admits at least one feasible scheduling. The problem of checking whether a given HyTN is consistent is named HyTN-Consistency.\nIndeed, observe that HyTN-Consistency generalizes STNConsistency because an STN may be viewed as a HyTN. The converse is not true because feasible schedules for a HyTN do not need to form a convex polytope [7], [8] whereas, in general, the feasible schedules of an STN are the solutions of a linear system and, therefore, they form a convex polytope.\nThe computational equivalence between checking the consistency of HyTNs and determining the winning regions of MPGs was pointed out in [7], [8]. The tightest worst-case time complexity for solving HyTN-Consistency is expressed by the following theorem, which was proven by resorting to the Value Iteration Algorithm for MPGs [3]. The approach was shown to be robust by experimental evaluations in [2], [8], where HyTNs of size ∼ 106 were solved within ∼ 5 sec.\nTheorem 1. [7] The following propositions hold on HyTNs. 1) There exists an O((|V |+|A|)mAW ) pseudo-polynomial\ntime algorithm for checking HyTN-Consistency;\n2) There exists an O((|V |+|A|)mAW ) pseudo-polynomial time algorithm such that, given in input any consistent HyTN H = (V,A), then it returns as output a feasible scheduling φ : V → R of H;\nHere, W , maxA∈A,v∈HA |wA(v)|."
    }, {
      "heading" : "III. ALGORITHMICS OF DYNAMIC-CONSISTENCY",
      "text" : "To start with, we offer the following coNP-hardness lower bound on CSTN-DC.\nTheorem 2. CSTN-DC is coNP-hard.\nProof: We reduce 3-SAT to the complement of CSTNDC. Let ϕ be a boolean formula in 3CNF. Let X be the set of variables and let C = {C0, . . . , Cm−1} be the set of clauses comprising ϕ = ∧m−1 j=0 Cj .\n(1) Let Nϕ be the CSTN 〈V ϕ, Aϕ, Lϕ,Oϕ,OV ϕ, Pϕ〉, where: V ϕ , X ∪ C, and all the nodes are given empty label, i.e., Lϕ(v) = λ for every v ∈ V ϕ; Pϕ , OV ϕ , X; Oϕ is the identity function; for every u, v ∈ OV ϕ we have 〈u − v ≤ 0, λ〉 ∈ Aϕ; for every x ∈ X and C ∈ C we have 〈x−C ≤ −1, λ〉 ∈ Aϕ; for each j = 0, . . . ,m−1 and for each literal ` ∈ Cj , we have 〈Cj − C(j+1)mod m ≤ −1, `〉 ∈ Aϕ. Notice that |V ϕ| = n+m and |Aϕ| = n2 + nm+ 3m.\n(2) Assume that ϕ is satisfiable. Let ν be a satisfying truthassignment of ϕ. In order to prove that Nϕ is not dynamicallyconsistent, observe that the restriction of Nϕ w.r.t. the scenario ν is a non-consistent STN. Indeed, if for every j = 0, . . . ,m− 1 we pick a standard arc 〈Cj − C(j+1)mod m ≤ −1, `j〉 with `j being a literal in Cj such that ν(`j) = >, then we obtain a negative circuit.\n(3) Assume that ϕ is unsatisfiable. In order to prove that Nϕ is dynamically-consistent, we exhibit a viable and dynamic execution strategy σ for Nϕ. First, schedule every x ∈ X at σ(x) , 0. Therefore, by time 1, the planner has full knowledge of the observed scenario ν. Since ϕ is unsatisfiable, there exists an index jν such that ν(Cjν ) = ⊥. At this point, set σ(C(jν+k)mod m) , k for k = 1, . . . ,m. The reader can verify that σ is viable and dynamic for Nϕ.\nIt remains currently open whether CSTN-DC lies in PSPACE and whether it is PSPACE-hard.\nA. -Dynamic-Consistency\nIn CSTNs, decisions about the precise timing of actions are postponed until execution time, when informations meanwhile gathered at the observation nodes can be taken into account. However, the planner is allowed to factor in an outcome, and differentiate its strategy according to it, only strictly after the outcome has been observed (whence the strict inequality in Definition 7). Notice that this definition does not take into account the reaction time, which, in most applications, is nonnegligible. In order to deliver algorithms that can also deal with the reaction time of the planner, we employ a refined notion of dynamic-consistency.\nDefinition 13 ( -dynamic-consistency). Given any CSTN 〈V,A,L,O,OV, P 〉 and any real number ∈ (0,+∞), an\nexecution strategy σ ∈ SΓ is -dynamic if it satisfies all the H -constraints, namely, for any two scenarios s1, s2 ∈ ΣP and any event u ∈ V +s1,s2 , the execution strategy σ satisfies the following constraint, which is denoted H (s1; s2;u):\n[σ(s1)]u ≥ min ( {[σ(s2)]u}∪{[σ(s1)]v+ | v ∈ ∆(s1; s2)} ) We say that a CSTN Γ is -dynamically-consistent if it admits σ ∈ SΓ which is both viable and -dynamic. The problem of checking whether a given CSTN is -dynamically-consistent is named CSTN- -DC.\nIt follows directly from Definition 13 that, whenever σ ∈ SΓ satisfies some H (s1; s2;u), then σ satisfies H ′(s1; s2;u) for every ′ ∈ (0, ] as well. This proves the following lemma.\nLemma 2. If Γ is -dynamically-consistent, for some > 0, then Γ is ′-dynamically-consistent for every ′ ∈ (0, ].\nGiven any dynamically-consistent CSTN, we may ask for the maximum reaction time of the planner beyond which the network is no longer dynamically-consistent.\nDefinition 14 (Reaction time ̂). Let ̂ = ̂(Γ) be the greatest real number such that Γ is -dynamically-consistent.\nIf Γ is dynamically-consistent, then ̂(Γ) exists finite and ̂(Γ) > 0, as it is now proved in Lemma 3.\nLemma 3. Let σ be a dynamic execution strategy for the CSTN Γ. Then, there exists a sufficiently small real number ∈ (0,+∞) such that σ is -dynamic.\nProof: Let s1, s2 ∈ ΣP be two scenarios and let us consider any event u ∈ V +s1,s2 . Since σ is dynamic, then by Lemma 1 the following implication necessarily holds:( ∧ v∈∆(s1;s2) [σ(s1)]u ≤ [σ(s1)]v ) ⇒ [σ(s1)]u ≥ [σ(s2)]u (∗)\nNotice that, w.r.t. Lemma 1, we have relaxed the equality [σ(s1)]u = [σ(s2)]u in the implicand of (L1) by introducing the inequality [σ(s1)]u ≥ [σ(s2)]u. At this point, we convert (∗) from implicative to disjunctive form, first by applying the rule of material implication2, and then De Morgan’s law3. From this, we see that the following disjunction must hold:\n[σ(s1)]u ≥ [σ(s2)]u ∨ ∨\nv∈∆(s1;s2)\n[σ(s1)]u > [σ(s1)]v (∗∗)\nThen, we argue that there exists a real number ∈ (0,+∞) such that the following disjunction holds as well:\n[σ(s1)]u ≥ [σ(s2)]u ∨ ∨\nv∈∆(s1;s2)\n[σ(s1)]u ≥ [σ(s1)]v + .\nIn fact, since the disjunction (∗∗) necessarily holds, then one can define to be the minimum among all the values (s1; s2;u) ∈ (0,+∞) such that for every 〈s1, s2, u〉 ∈ ΣP ×ΣP ×V +s1,s2 the following is satisfied: (s1; s2;u) = 1 if\n2The rule of material implication: |= p⇒ q ⇐⇒ ¬p ∨ q 3De Morgan’s law: |= ¬(p ∧ q) ⇐⇒ ¬p ∨ ¬q\n[σ(s1)]u ≥ [σ(s2)]u; otherwise, (s1; s2;u) = min{[σ(s1)]u− [σ(s1)]v | v ∈ ∆(s1, s2), [σ(s1)]u > [σ(s1)]v}.\nThis implies that σ satisfies every H -constraint of Γ, and thus that σ is -dynamic.\nLemma 4. Let σ be an -dynamic execution strategy for the CSTN Γ, for some ∈ (0,+∞). Then, σ is dynamic.\nProof: For the sake of contradiction, let us suppose that σ is not dynamic. Let F be the non-empty set of all the triplets 〈u, s1, s2〉 ∈ V +s1,s2 × ΣP × ΣP , for which the implication (L1) does not hold. Then, 〈u, s1, s2〉 ∈ F if and only if the following two hold:\n1) [σ(s1)]u ≤ [σ(s1)]v for every v ∈ ∆(s1; s2); 2) [σ(s1)]u 6= [σ(s2)]u.\nLet 〈û, ŝ1〉 , arg min{[σ(s1)]u | ∃s2 〈u, s1, s2〉 ∈ F} be an event whose scheduling time is minimum and for which (1) and (2) hold. Since 〈û, ŝ1〉 is minimum in time, then [σ(ŝ1)]û ≤ [σ(s2)]û for every s2 ∈ ΣP such that 〈û, ŝ1, s2〉 ∈ F ; moreover, since 〈û, ŝ1, s2〉 ∈ F , then [σ(s1)]û 6= [σ(s2)]û by (2), so that [σ(ŝ1)]û < [σ(s2)]û. At this point, recall that σ is -dynamic by hypothesis, hence [σ(ŝ1)]û < [σ(s2)]û implies that there exists v ∈ ∆(ŝ1; s2) such that [σ(ŝ1)]û ≥ [σ(ŝ1)]v + > [σ(ŝ1)]v , but this inequality contradicts (1). Indeed, F = ∅ and σ is thus dynamic.\nIn Section IV, the following theorem is proved.\nTheorem 3. For any dynamically-consistent CSTN Γ, where V is the set of events and ΣP is the set of scenarios, we have that ̂(Γ) ≥ |ΣP |−1|V |−1.\nNotice that, in Definition 9, dynamic-consistency was defined by strict-inequality and equality constraints. However, by Theorem 4, dynamic-consistency can also be defined in terms of H -constraints only (i.e., no strict-inequalities are required).\nTheorem 4. Let , |ΣP |−1|V |−1. Then, Γ is dynamicallyconsistent if and only if Γ is -dynamically-consistent.\nBy Theorem 4, any algorithm for checking -dynamicconsistency can be used to check dynamic-consistency as well.\nB. A Singly-Exponential Time Algorithm for CSTN-DC\nIn this section, we present the first singly-exponential time algorithm for solving CSTN-DC, also producing a dynamic execution strategy whenever the input CSTN is dynamicallyconsistent. Hereafter, let us denote N0 , N \\ {0}. The main result of this paper is summarized in the following theorem, which is proven in this section.\nTheorem 5. The following two propositions hold. 1) There exists an O(|ΣP |2|A|2 + |ΣP |3|A||V ||P | + |ΣP |4|V |2|P |)WD time algorithm deciding CSTN- -DC on input 〈Γ, 〉, for any CSTN Γ = 〈V,A,L,O,OV, P 〉 and any rational number = N/D where N,D ∈ N0. In particular, given any -dynamically-consistent CSTN Γ, the algorithm returns as output a viable and - dynamic execution strategy for Γ.\n2) There exists an O(|ΣP |3|A|2|V | + |ΣP |4|A||V |2|P | + |ΣP |5|V |3|P |)W time algorithm for checking CSTN-DC on any input Γ = 〈V,A,L,O,OV, P 〉. In particular, given any dynamically-consistent CSTN Γ, the algorithm returns a viable and dynamic execution strategy for Γ.\nHere, W , maxa∈A |wa|.\nWe now present the reduction from CSTN-DC to HyTNConsistency.\nFirstly, we argue that any CSTN can be viewed as a succinct representation which can be expanded into an exponential sized STN. The Expansion of CSTNs is introduced below.\nDefinition 15 (Expansion 〈V ExΓ ,ΛExΓ 〉). Let Γ be a CSTN 〈V,A,L,O,OV, P 〉. Consider the distinct STNs 〈Vs, As〉, one for each scenario s ∈ ΣP , defined as follows:\nVs , {vs | v ∈ V +s } and As , {〈us, vs, w〉 | 〈u, v, w〉 ∈ A+s }.\nWe define the expansion 〈V ExΓ ,ΛExΓ 〉 of Γ as follows: 〈V ExΓ ,ΛExΓ 〉 , 〈 ⋃ s∈ΣP Vs, ⋃ s∈ΣP As 〉 .\nNotice that Vs1 ∩ Vs2 = ∅ whenever s1 6= s2 and that 〈V ExΓ ,ΛExΓ 〉 is an STN with at most |V ExΓ | ≤ |ΣP | |V | nodes and at most |ΛExΓ | ≤ |ΣP | |A| standard arcs.\nWe now show that the expansion of a CSTN can be enriched with some hyperarcs in order to model -dynamic-consistency, by means of a particular HyTN which is denoted H (Γ).\nDefinition 16 (HyTN H (Γ)). Given any ∈ (0,+∞) and any CSTN Γ = 〈V,A,L,O,OV, P 〉, a corresponding HyTN denoted by H (Γ) can be defined as follows: • For every scenarios s1, s2 ∈ ΣP and every event u ∈ V +s1,s2 , define a hyperarc α = α (s1; s2;u) as follows (with the intention to model H (s1; s2;u), see Def. 13):\nα (s1; s2;u) , 〈tα, Hα, wα〉,\nwhere: – tα , us1 is the tail of the hyperarc α; – Hα , {us2} ∪∆(s1; s2) is the set of the heads; – wα(us2) , 0; wα(v) , − for each v ∈ ∆(s1; s2).\n• Consider the expansion 〈V ExΓ ,ΛExΓ 〉 of Γ. Then, H (Γ) is defined as H (Γ) , 〈V ExΓ ,AH 〉, where,\nAH , ΛExΓ ∪ ⋃\ns1,s2∈ΣP u∈V +s1,s2\nα (s1; s2;u).\nNotice that each α (s1; s2;u) has size |α (s1; s2;u)| = O(∆(s1; s2)) = O(|P |). In Fig. 3, Algorithm 1 presents the pseudocode for constructing H (Γ). An excerpt of the HyTN corresponding to the CSTN of Fig. 1 is depicted in Fig. 4.\nThe following theorem establishes the connection between dynamic-consistency of CSTNs and consistency of HyTNs.\nTheorem 6. Given any CSTN Γ = 〈V,A,L,O,OV, P 〉, there exists a sufficiently small real number ∈ (0,+∞) such that Γ is dynamically-consistent if and only if H (Γ)\nis consistent. Moreover, H (Γ) has at most |VH | ≤ |ΣP | |V | nodes, |AH | = O(|ΣP | |A|+ |ΣP |2|V |) hyperarcs, and it has size at most mAH = O(|ΣP | |A|+ |ΣP | 2|V | |P |).\nProof: For any > 0, let H (Γ) = 〈V ExΓ ,AH 〉 be the HyTN of Definition 16.\n(1) Firstly, we prove that, for any > 0, H (Γ) is consistent if and only if Γ is -dynamically-consistent. (⇒) Given any feasible scheduling φ : V ExΓ → R for H (Γ), let σφ(s) ∈ SΓ be the execution strategy defined as: [σφ(s)]v , φ(vs), for every vs ∈ V EΓ , where v ∈ V and s ∈ ΣP . Notice that each hyperarc α (s1; s2;u) is satisfied by φ if and only if the corresponding H -constraint H (s1; s2;u) is satisfied by σφ; moreover, recall that ΛExΓ ⊆ AH , and that ΛExΓ contains all the original standard difference constraints of Γ. At this point, since φ is feasible for H (Γ), then σφ must be viable and -dynamic for Γ. Hence, Γ is -dynamically-consistent.\n(⇐) Given any viable and -dynamic execution strategy σ ∈ SΓ, for some > 0, let φσ : V ExΓ → R be the scheduling of H (Γ) defined as: φσ(vs) , [σ(s)]v for every vs ∈ V ExΓ , where v ∈ V and s ∈ ΣP . Also in this case we have ΛExΓ ⊆ AH , and a moment’s reflection reveals that each hyperarc α (s1; s2;u) is satisfied by φσ if and only if H (s1; s2;u) is satisfied by σ. At this point, since σ is viable and -dynamic for Γ, then φσ must be feasible for H (Γ). Hence H (Γ) is consistent.\n(2) At this point, by composition with (1), Lemma 3 implies that there exists a sufficiently small > 0 such that Γ is dynamically-consistent if and only if H (Γ) is consistent.\n(3) The size bounds follow directly from Definition 16. The pseudo-code for checking CSTN- -DC is given in Algorithm 2, whereas the pseudo-code for checking CSTNDC is provided in Algorithm 3. The latter algorithm goes as follows. Firstly, it computes a sufficiently small > 0 by resorting to Theorem 4, i.e., ̂ = |ΣP |−1|V |−1 (at line 1 of Algorithm 3). Secondly, it constructs Ĥ(Γ) (at line 1 of Algorithm 2) and then it scales every hyperarc’s weight to Z (at lines 2-3). Thirdly, Ĥ(Γ) is solved with the HyTNConsistency algorithm underlying Theorem 1 (at line 4), i.e., an instance of the HyTN-Consistency problem is solved by reduction to the decision problem for MPGs. If the HyTNConsistency algorithm outputs YES, together with a feasible scheduling φ of Ĥ(Γ), then the time values of φ are scaled back to size w.r.t. ̂ and then 〈YES, φ〉 is returned as output (lines 5-8); otherwise, the output is simply NO (at line 10).\nRemark 1. The same algorithm, with essentially the same upper bound on its running time and space, work also in case we allow for arbitrary boolean formulae as labels, rather than just conjunctions. At the same time, hyperarc constraints can also be allowed inside the input CSTNs, besides the standard arc constraints. Under this prospect, our algorithm actually solves a larger family of conditional temporal networks, that we may call Conditional Hyper Temporal Networks (CHyTNs).\nRemark 2. We remark that the HyTN/MPG algorithm that is at the heart of our approach requires integral weights (i.e., it requires that w(u, v) ∈ Z for every (u, v) ∈ A), and we could\nnot play it differently [7], [8]. Moreover, the algorithm always computes integral solution to HyTN/MPGs and, therefore, it always computes rational feasible schedules for the CSTNs given in input. As such, this “requirement“ actually turns out to be a plus in practice. To conclude, it is indeed integrality that allows us to analyze the algorithm quantitatively and to present a sharp lower bounding analysis on the critical value of the reaction time ̂, where the CSTN transits from being, to not being, dynamically consistent. We believe that these issues deserve much attention, going into them required an algorithmic discrete approach to the notion of numbers.\nNow, the correctness and the time complexity of Algorithm 3 is analyzed. To begin, notice that some of the temporal constraints introduced during the reduction step depends on a\nsufficiently small parameter > 0, whose magnitude turns out to depend on the size of the input CSTN. It is now proved that the time complexity of the algorithm depends multiplicatively on D, provided that = N/D for some N,D ∈ N0. In Section IV we will present a sharp lower bounding analysis on ̂, from which the (pseudo) singly-exponential time bound follows as corollary. So, assume for a moment line 1 to be valid, we prove it in Theorem 3. As a corollary of Theorem 6, we have that Algorithm 3 correctly decides CSTN-DC. The most time expensive step of the algorithm is clearly line 4 of Algorithm 2, which resorts to Theorem 1 in order to solve an instance of HyTN-Consistency. From Theorem 6 we have an upper bound on the size of H (Γ), while Theorem 1 gives us a pseudo-polynomial upper bound for the computation time. Also, recall that we scale weights by a factor D at lines 2-3 of Algorithm 2, where = N/D for some N,D ∈ N0. Thus, by composition, Algorithm 3 decides CSTN-DC in a time T|Γ| which is bounded as follows, where W , maxa∈A |wa|:\nT|Γ| = O((|VH (Γ)|+ |AH (Γ)|)mAH (Γ))WD.\nWhence, the following holds:\nT|Γ| = O(|ΣP |2|A|2 + |ΣP |3|A||V ||P |+ |ΣP |4|V |2|P |)WD.\nBy Theorem 3, it is sufficient to check -dynamicconsistency for = |ΣP |−1|V |−1. An O(|ΣP |3|V ||A|2 + |ΣP |4|A||V |2|P | + |ΣP |5|V |3|P |)W worst-case time bound follows for Algorithm 3. Since |ΣP | ≤ 2min(|P |,l) (where ` is the number of distinct labels that appear in Γ), the singlyexponential time bound follows. This proves Theorem 5."
    }, {
      "heading" : "IV. BOUNDING ANALYSIS ON THE REACTION TIME ̂",
      "text" : "In this section we present an asymptotically sharp lower bound for ̂(Γ), that is the critical value of reaction time where the CSTN transits from being, to not being, dynamicallyconsistent. The proof technique introduced in this analysis is applicable more in general, when dealing with linear difference constraints which include strict inequalities. Moreover, this bound implies that Algorithm 3 is a (pseudo) singlyexponential time algorithm for solving CSTN-DC. To begin, we are going to provide a proof of Theorem 3, but let us first introduce some further notation.\nLet Γ , 〈V,A,L,O,OV, P 〉 be a dynamically-consistent CSTN. By Theorem 6, there exists > 0 such that H (Γ) is consistent. Then, let φ : V ExΓ → R be a feasible scheduling for H (Γ). For any hyperarc A = 〈tA, HA, wA〉 ∈ AH , define a standard arc aA as follows:\naA , 〈tA, ĥ, wA(ĥ)〉, where ĥ , arg min h∈HA\n( φ(h)− wA(h) ) .\nThen, notice that the network Tφ (Γ) , 〈V ExΓ , ⋃ A∈AH\naA〉 is an STN. Moreover, φ is feasible for Tφ (Γ). At this point, assuming v ∈ V ExΓ , consider the fractional part rv of φv , i.e.,\nrv , φv − bφvc.\nThen, let R , {rv}v∈V ExΓ be the set of all the fractional parts. Sort R by the common ordering on R and assume that S ,\n{r1, . . . , rk} is the resulting ordered set without repetitions, i.e., |S| = k, S = R, r1 < . . . < rk. Now, let pos(v) be the index position such that:\n1 ≤ pos(v) ≤ k and rpos(v) = rv.\nThen, we define a new fractional part as follows:\nr′v , pos(v)− 1 |ΣP ||V |\n(NFP)\nalso, we define a new scheduling function as follows:\nφ′v , bφvc+ r′v (NSF)\nRemark 3. Notice that (NFP) doesn’t alter the ordering relation among the fractional parts, i.e.,\nr′u < r ′ v ⇐⇒ ru < rv, for any u, v ∈ V ExΓ ,\nmoreover, observe that (NSF) doesn’t change the value of any integral part, i.e.,\nbφ′uc = bφuc, for any u ∈ V ExΓ .\nWe are now in the position to prove Theorem 3. Proof of Theorem 3: Let Γ be dynamically-consistent, by Theorem 6 there exists ′ > 0 such that H ′(Γ) is consistent and admits some feasible scheduling φ : V ExΓ → R. Let , |ΣP |−1|V |−1. We argue that φ′, as defined in (NSF), is a feasible scheduling for the STN Tφ (Γ). Indeed, every difference constraint of Tφ (Γ) is of the form φv − φu ≤ w, for some w ∈ Z or w = − . Consider the case w ∈ Z. Then,\nφ′v − φ′u ≤ w holds because of Remark 3. Now, consider the case w = − . Then, φv − φu ≤ − implies φv 6= φu. Hence, by Remark 3, we have φ′v 6= φ′u. At this point, observe that the difference between φ′u and φ ′ v is therefore at least , i.e.,\nφ′u − φ′v ≥ |ΣP |−1|V |−1 = .\nThat is to say, φ′v−φ′u ≤ − . This proves that φ′ is a feasible scheduling for the STN Tφ (Γ). Since T φ (Γ) is thus consistent, then H (Γ) is consistent as well. Therefore, by Theorem 6, the CSTN Γ is -dynamically-consistent.\nAt this point, a natural question is whether the lower bound given by Theorem 3 can be improved up to ̂(Γ) = Ω(|V |−1). In turn, this would improve the time complexity for Algorithm 3 by a factor |ΣP |. However, the following theorem shows that this is not the case by exhibiting a CSTN for which ̂(Γ) = 2−Ω(|P |). This proves that the lower bound given by Theorem 3 is (almost) asymptotically sharp.\nTheorem 7. For each n ∈ N0 there exists a CSTN Γn such that ̂(Γn) < 2−n+1 = 2−|P\nn|/3+1, where Pn is the set of boolean variables of Γn.\nProof: For each n ∈ N0, define a CSTN Γn , 〈V n, An, Ln,On,OV n, Pn〉 as follows. See Fig. 5 for a clarifying illustration. • V n , {Xi, Yi, Zi | 1 ≤ i ≤ n}; • An , B ∪ ⋃n i=1 Ci ∪ ⋃n−1 i=1 Di ∪ E\nwhere: – B , {〈X1 − v ≤ 0, λ〉 | v ∈ V n} ∪ {〈Z1 − X1 ≤\n1, X1 ∧ Y1〉}; – Ci , {〈Yi − Xi ≤ 2,¬Xi〉, 〈Xi − Yi ≤ −2,¬Xi〉, 〈Zi−Yi ≤ 2,¬Yi〉, 〈Yi−Zi ≤ −2,¬Yi〉}; – Di , {〈Xi+1 − Xi ≤ 5, Zi〉, 〈Xi − Xi+1 ≤ −5, Zi〉, 〈Xi+1 − Yi〉 ≤ 5,¬Zi〉, 〈Yi − Xi+1 ≤ −5,¬Zi〉, 〈Zi+1 − Yi ≤ 5, Zi ∧Xi+1 ∧ Yi+1〉, 〈Yi − Zi+1 ≤ −5, Zi∧Xi+1∧Yi+1〉, 〈Zi+1−Zi ≤ 5,¬Zi∧ Xi+1∧Yi+1〉, 〈Zi−Zi+1 ≤ −5,¬Zi∧Xi+1∧Yi+1〉}; – E , {〈Yn − Xn ≤ 2,¬Xn〉, 〈Xn − Yn ≤ −2,¬Xn〉, 〈Zn − Yn ≤ 2,¬Yn〉, 〈Yn − Zn ≤ −2,¬Yn〉}; • Ln(v) , λ for every v ∈ V n; OV n , V n; On(v) , v for every v ∈ OV n; Pn , V n.\nWe exhibit a viable and dynamic execution strategy σn : ΣPn → ΦV n for Γn.\nLet {δi}ni=1 and {∆i}ni=1 be two real valued sequences s.t.:\n(1) ∆1 , 1; (2) 0 < δi < ∆i; (3) ∆i , min(δi−1,∆i−1−δi−1).\nThen, the following also holds for every 1 ≤ i ≤ n:\n(4) 0 < ∆i ≤ 2−i+1,\nwhere the equality holds if and only if δi = ∆i/2. In what follows, provided that s ∈ ΣP and ` ∈ P ∗, we will denote 1s(`) , 1 if s(`) = > and 1s(`) , 0 if s(`) = ⊥. We are ready to define σn(s) for any s ∈ ΣP : • [σn(s)]X1 , 0;\n• [σn(s)]Y1 , δ11s(X1) + 21s(¬X1); • [σn(s)]Z1 , 1s(X1∧Y1) + (2 + [σn(s)]Y1)1s(¬X1∨¬Y1); • [σn(s)]Xi , 5 + [σn(s)]Xi−11s(Zi−1) +\n+ [σn(s)]Yi−11s(¬Zi−1), for any 2 ≤ i ≤ n; • [σn(s)]Yi , [σn(s)]Xi + δi1s(Xi) + 21s(¬Xi), for any\n2 ≤ i ≤ n; • [σn(s)]Zi , ( 5 + [σn(s)]Yi−11s(Zi−1) +\n+ [σn(s)]Zi−11s(¬Zi−1) ) 1s(Xi∧Yi) +\n+ (2 + [σn(s)]Yi)1s(¬Xi∨¬Yi), for any 2 ≤ i ≤ n; It is not difficult to prove, by induction on n ≥ 1, that σn is viable and dynamic for Γn.\nHere we show that ̂(Γn) < 2−n+1 = 2−|P n|/3+1 for every n ≥ 1. Let us consider the following scenario ŝ for 1 ≤ i ≤ n:\nŝ(Xi) , ŝ(Yi) , >; ŝ(Zi) , { >, if δi ≤ ∆i/2 ⊥, if δi > ∆i/2 .\nWe assume that σ is an execution strategy for Γn and study necessary conditions to ensure that σ is viable and dynamic, provided that the observations follow scenario ŝ. First, σ must schedule X1 at time [σ(ŝ)]X1 = 0. Then, since ŝ(X1) = >,\nwe must have 0 < [σ(ŝ)]Y1 < 1, because of the constraint (Z1−X1 ≤ 1, X1∧Y1). Stated otherwise, it is necessary that:\n0 < [σ(ŝ)]Y1 − [σ(ŝ)]X1 < ∆1.\nAfter that, since ŝ(Y1) = >, then σ must schedule Z1 at time [σ(ŝ)]Z1 = 1 = ∆1. A moment’s reflection reveals that almost identical necessary conditions now recur for X2, Y2, Z2, with the crucial variation that it will be necessary to require: 0 < [σ(ŝ)]Y2 < ∆2. Indeed, proceeding inductively, it will be necessary that for every 1 ≤ i ≤ n and every n ∈ N0:\n0 < [σ(ŝ)]Yi − [σ(ŝ)]Xi < ∆i.\nAs already observed in (4), we have 0 < ∆n ≤ 2−n+1. Thus, any viable and dynamic execution strategy σ for Γn must satisfy:\n0 < [σ(ŝ)]Yn − [σ(ŝ)]Xn < 1\n2n−1 =\n1\n2|Pn|/3−1 .\nThus, once the planner has observed the outcome ŝ(Xn) = > from the observation event Xn, then he must react by scheduling Yn within time 2−n+1 = 2−|P\nn|/3+1 in the future w.r.t. [σ(ŝ)]Xn . Then ̂(Γ n) < 2−n+1 = 2−|P n|/3+1 any n ≥ 1."
    }, {
      "heading" : "V. RELATED WORKS",
      "text" : "This section discusses of some alternative approaches offered by the current literature. Recall that the article of Tsamardinos, et al. [16] has been discussed already in the introduction. The work of Cimatti, et al. [5] provided the first sound-and-complete algorithm for checking the dynamiccontrollability of CSTNs with Uncertainty (CSTNU) and thus it can be employed for checking the dynamic-consistency of CSTNs as a special case. The algorithm reduces to the problem of solving Timed Game Automata (TGA). Nevertheless, no worst-case bound on the time complexity of the procedure was provided in [5]. We observe that solving TGAs is a problem of much higher complexity than solving MPGs, compare the following known facts: solving 1-player TGAs is PSPACEcomplete and solving 2-player TGAs is EXP-complete; on the contrary, the problem of determining MPGs lie in NP∩ coNP and it is currently an open problem to prove whether it lies in P. Indeed, the algorithm in [5] is not singly-exponential time bounded. Finally, a sound algorithm for checking the dynamiccontrollability of CSTNUs was given by Combi, Hunsberger, Posenato in [6]. However, it was not shown to be complete. To the best of our knowledge, it is currently open whether or not it can be extended in order to prove completeness."
    }, {
      "heading" : "VI. CONCLUSION",
      "text" : "We gave the first singly-exponential time algorithm to check the dynamic-consistency of CSTNs, also yielding dynamic execution strategies. The algorithm actually manages a few more general variants of the problem, where labels are not required to be conjunctions and hyperarc constraints can be empolyed in the input CSTNs, besides the classical binary constraints. To summarize, at the heart of the algorithm a reduction to MPGs is mediated by the HyTN model. The CSTN is dynamicallyconsistent if and only if the corresponding MPG is everywhere\nwon, and a dynamic execution strategy can be conveniently read out by an everywhere winning positional strategy. The size of this MPG is at most polynomial in the number of the possible scenarios; as such, the term at the exponent is linear, at worst, in the number of the observation events. The same holds for the running time of the resulting algorithm. In future works we would like to settle the exact computational complexity of CSTN-DC, as well as to extend our approach in order to check the dynamic-controllability of CSTN with Uncertainty [12]. Finally, an extensive experimental evaluation is on the way.\nAcknowledgment: This work was partially supported by Department of Computer Science, University of Verona, Italy under Ph.D. grant “Computational Mathematics and Biology“."
    } ],
    "references" : [ {
      "title" : "The tropical shadowvertex algorithm solves mean payoff games in polynomial time on average",
      "author" : [ "X. Allamigeon", "P. Benchimol", "S. Gaubert" ],
      "venue" : "ICALP 2014, Copenhagen, Denmark, July 8-11, 2014, Proceedings, Part I, pages 89–100,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Using strategy improvement to stay alive",
      "author" : [ "L. Brim", "J. Chaloupka" ],
      "venue" : "Int. J. Found. Comput. Sci., 23(3):585–608,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Faster algorithms for mean-payoff games",
      "author" : [ "L. Brim", "J. Chaloupka", "L. Doyen", "R. Gentilini", "J.F. Raskin" ],
      "venue" : "Formal Methods in System Design, 38(2):97–118,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Polynomial-time algorithms for energy games with special weight structures",
      "author" : [ "K. Chatterjee", "M. Henzinger", "S. Krinninger", "D. Nanongkai" ],
      "venue" : "Algorithmica, 70(3):457–492,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Sound and complete algorithms for checking the dynamic controllability of temporal networks with uncertainty, disjunction and observation",
      "author" : [ "A. Cimatti", "L. Hunsberger", "A. Micheli", "R. Posenato", "M. Roveri" ],
      "venue" : "21st Intern. Symp. on Temp. Repres. and Reasoning, TIME 2014, Verona, Italy, pages 27–36,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "An algorithm for checking the dynamic controllability of a conditional simple temporal network with uncertainty",
      "author" : [ "C. Combi", "L. Hunsberger", "R. Posenato" ],
      "venue" : "ICAART 2013 - Proc. of the 5th Intern. Conf. on Agents and Artif. Intell., Vol. 2, Spain, 2013, pages 144–156,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "A tractable generalization of simple temporal networks and its relation to mean payoff games",
      "author" : [ "C. Comin", "R. Posenato", "R. Rizzi" ],
      "venue" : "21th International Symposium on Temporal Representation and Reasoning (TIME 2014), Verona, Italy, Sept",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Hyper temporal networks",
      "author" : [ "C. Comin", "R. Posenato", "R. Rizzi" ],
      "venue" : "CoRR, abs/1503.03974,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Temporal constraint networks",
      "author" : [ "R. Dechter", "I. Meiri", "J. Pearl" ],
      "venue" : "Artificial Intelligence, 49(1–3):61–95,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Positional strategies for mean payoff games",
      "author" : [ "A. Ehrenfeucht", "J. Mycielski" ],
      "venue" : "International Journal of Game Theory, 8(2):109–113,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "Automata Logics, and Infinite Games: A Guide to Current Research",
      "author" : [ "E. Grädel", "W. Thomas", "T. Wilke", "editors" ],
      "venue" : null,
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2002
    }, {
      "title" : "The dynamic controllability of conditional stns with uncertainty",
      "author" : [ "L. Hunsberger", "R. Posenato", "C. Combi" ],
      "venue" : "Proc. of the Plan. and Plan Exec. for Real-World Syst.: Princip. and Pract. (PlanEx), ICAPS-2012, page 121–128, Atibaia, Sao Paulo, Brazil,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Applying local search to disjunctive temporal problems",
      "author" : [ "M.D. Moffitt", "M.E. Pollack" ],
      "venue" : "IJCAI-05, Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence, Edinburgh, Scotland, UK, pages 242–247,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Constraint-based strategies for the disjunctive temporal problem: Some new results",
      "author" : [ "A. Oddi" ],
      "venue" : "Proceedings of the Sixth European Conference on Planning,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Efficient solution techniques for disjunctive temporal reasoning problems",
      "author" : [ "I. Tsamardinos", "M.E. Pollack" ],
      "venue" : "Artif. Intell., 151(1-2):43–89,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Ctp: A new constraint-based formalism for conditional, temporal planning",
      "author" : [ "I. Tsamardinos", "T. Vidal", "M. Pollack" ],
      "venue" : "Constraints, 8(4):365– 388,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "The complexity of mean payoff games on graphs",
      "author" : [ "U. Zwick", "M. Paterson" ],
      "venue" : "Theoretical Computer Science, 158:343–359,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "In temporal planning and temporal scheduling, Simple Temporal Networks (STNs) [9] are directed weighted graphs, where nodes represent events to be scheduled in time and arcs represent temporal distance constraints between pairs of events.",
      "startOffset" : 78,
      "endOffset" : 81
    }, {
      "referenceID" : 6,
      "context" : "Recently, STNs have been generalized into Hyper Temporal Networks (HyTNs) [7], [8] by considering weighted directed hypergraphs, where each hyperarc models a disjunctive temporal constraint called hyper-constraint.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 7,
      "context" : "Recently, STNs have been generalized into Hyper Temporal Networks (HyTNs) [7], [8] by considering weighted directed hypergraphs, where each hyperarc models a disjunctive temporal constraint called hyper-constraint.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 2,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].",
      "startOffset" : 132,
      "endOffset" : 135
    }, {
      "referenceID" : 9,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 16,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 6,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].",
      "startOffset" : 175,
      "endOffset" : 178
    }, {
      "referenceID" : 7,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].",
      "startOffset" : 180,
      "endOffset" : 183
    }, {
      "referenceID" : 1,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].",
      "startOffset" : 272,
      "endOffset" : 275
    }, {
      "referenceID" : 6,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].",
      "startOffset" : 277,
      "endOffset" : 280
    }, {
      "referenceID" : 7,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining winning regions in Mean Payoff Games (MPGs) [3], [10], [17] was pointed out as well in [7], [8], where the approach was shown to be robust thanks to extensive experimental evaluations [2], [7], [8].",
      "startOffset" : 282,
      "endOffset" : 285
    }, {
      "referenceID" : 10,
      "context" : "Mean Payoff Games are a family of two-player infinite games played on finite graphs, well known for having theoretical interest in computational complexity, being it one of the few (natural) problems lying in NP∩ coNP, as well as various applications in model-checking and formal verification [11].",
      "startOffset" : 293,
      "endOffset" : 297
    }, {
      "referenceID" : 15,
      "context" : "We focus on Conditional Simple Temporal Problems (CSTP) [16] and on their graph-based counterpart Conditional Simple Temporal Networks (CSTN) [12], a constraint-based model for conditional temporal planning.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 11,
      "context" : "We focus on Conditional Simple Temporal Problems (CSTP) [16] and on their graph-based counterpart Conditional Simple Temporal Networks (CSTN) [12], a constraint-based model for conditional temporal planning.",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 15,
      "context" : "Importantly, this can be achieved even while allowing for the decisions about the precise timing of actions to be postponed until execution time, in a least-commitment manner, thereby adding flexibility and making it possible to adapt the plan dynamically, during execution, in response to the observations made [16].",
      "startOffset" : 312,
      "endOffset" : 316
    }, {
      "referenceID" : 15,
      "context" : "Still, it is the most challenging and it was conjectured to be hard to assess by Tsamardinos, Vidal and Pollack [16].",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 15,
      "context" : "Indeed, the best-so-far algorithm for deciding whether a CSTN is dynamically-consistent is doubly-exponential time [16].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 12,
      "context" : "However, this approach turns out to be limitative in practice: to the best of our knowledge, some experimental studies have shown that the resolution procedures, as well as the heuristics, for solving general DTPs becomes quite burdensome with ∼ 30, 35 DTP’s variables [13]–[15], thus dampening the practical applicability of the approach.",
      "startOffset" : 269,
      "endOffset" : 273
    }, {
      "referenceID" : 14,
      "context" : "However, this approach turns out to be limitative in practice: to the best of our knowledge, some experimental studies have shown that the resolution procedures, as well as the heuristics, for solving general DTPs becomes quite burdensome with ∼ 30, 35 DTP’s variables [13]–[15], thus dampening the practical applicability of the approach.",
      "startOffset" : 274,
      "endOffset" : 278
    }, {
      "referenceID" : 15,
      "context" : "The algorithm can actually be applied to a wider class of problems and it is based on representing any given instance on an exponential sized network, as first suggested in [16].",
      "startOffset" : 173,
      "endOffset" : 177
    }, {
      "referenceID" : 6,
      "context" : "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).",
      "startOffset" : 108,
      "endOffset" : 111
    }, {
      "referenceID" : 7,
      "context" : "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).",
      "startOffset" : 113,
      "endOffset" : 116
    }, {
      "referenceID" : 0,
      "context" : "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).",
      "startOffset" : 317,
      "endOffset" : 320
    }, {
      "referenceID" : 1,
      "context" : "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).",
      "startOffset" : 322,
      "endOffset" : 325
    }, {
      "referenceID" : 3,
      "context" : "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).",
      "startOffset" : 327,
      "endOffset" : 330
    }, {
      "referenceID" : 7,
      "context" : "This makes a relevant difference since the consistency check for HyTNs can be reduced to MPGs determination [7], [8], which is amenable to practical and effective pseudo-polynomial time algorithms (indeed, in several cases the resolution methods for determining MPGs exhibit even a strongly-polynomial time behaviour [1], [2], [4], [8]).",
      "startOffset" : 332,
      "endOffset" : 335
    }, {
      "referenceID" : 11,
      "context" : "We believe that this contributes to clarifying (with respect to previous literature [12], [16]) the role played by the reaction time ε̂ in checking the dynamic-consistency of CSTNs.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 15,
      "context" : "We believe that this contributes to clarifying (with respect to previous literature [12], [16]) the role played by the reaction time ε̂ in checking the dynamic-consistency of CSTNs.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 15,
      "context" : "Since the forthcoming definitions are mostly inherited from the literature, the reader is referred to [16] and [12] for an intuitive semantic discussion and for some clarifying examples of the very same model.",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 11,
      "context" : "Since the forthcoming definitions are mostly inherited from the literature, the reader is referred to [16] and [12] for an intuitive semantic discussion and for some clarifying examples of the very same model.",
      "startOffset" : 111,
      "endOffset" : 115
    }, {
      "referenceID" : 8,
      "context" : "The following definition recalls Simple Temporal Networks (STNs) [9], as they provide a powerful and general tool for representing conjunctions of minimum and maximum distance constraints between pairs of temporal variables.",
      "startOffset" : 65,
      "endOffset" : 68
    }, {
      "referenceID" : 8,
      "context" : "An STN [9] is a weighted directed graph whose nodes are events that must be placed on the real time line and whose arcs, called standard arcs, express binary constraints on the allocations of their end-points in time.",
      "startOffset" : 7,
      "endOffset" : 10
    }, {
      "referenceID" : 11,
      "context" : "Subsequently, those conditions have been analyzed and formalized in [12], leading to the sound notion of Conditional Simple Temporal Network (CSTN), which is now recalled.",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 11,
      "context" : "1The notation Con(·, ·) and Sub(·, ·) is inherited from [12], [16].",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 15,
      "context" : "1The notation Con(·, ·) and Sub(·, ·) is inherited from [12], [16].",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 6,
      "context" : "The reader is referred to [7], [8] for an in-depth treatise on HyTNs.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 7,
      "context" : "The reader is referred to [7], [8] for an in-depth treatise on HyTNs.",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 6,
      "context" : "The converse is not true because feasible schedules for a HyTN do not need to form a convex polytope [7], [8] whereas, in general, the feasible schedules of an STN are the solutions of a linear system and, therefore, they form a convex polytope.",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 7,
      "context" : "The converse is not true because feasible schedules for a HyTN do not need to form a convex polytope [7], [8] whereas, in general, the feasible schedules of an STN are the solutions of a linear system and, therefore, they form a convex polytope.",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 6,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining the winning regions of MPGs was pointed out in [7], [8].",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 7,
      "context" : "The computational equivalence between checking the consistency of HyTNs and determining the winning regions of MPGs was pointed out in [7], [8].",
      "startOffset" : 140,
      "endOffset" : 143
    }, {
      "referenceID" : 2,
      "context" : "The tightest worst-case time complexity for solving HyTN-Consistency is expressed by the following theorem, which was proven by resorting to the Value Iteration Algorithm for MPGs [3].",
      "startOffset" : 180,
      "endOffset" : 183
    }, {
      "referenceID" : 1,
      "context" : "The approach was shown to be robust by experimental evaluations in [2], [8], where HyTNs of size ∼ 10 were solved within ∼ 5 sec.",
      "startOffset" : 67,
      "endOffset" : 70
    }, {
      "referenceID" : 7,
      "context" : "The approach was shown to be robust by experimental evaluations in [2], [8], where HyTNs of size ∼ 10 were solved within ∼ 5 sec.",
      "startOffset" : 72,
      "endOffset" : 75
    }, {
      "referenceID" : 6,
      "context" : "[7] The following propositions hold on HyTNs.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "not play it differently [7], [8].",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 7,
      "context" : "not play it differently [7], [8].",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 9,
      "context" : "p1 = ⊥ C1 B1 A1 [10, 10]",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 9,
      "context" : "p1 = ⊥ C1 B1 A1 [10, 10]",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 4,
      "context" : "2 0 [0, 5] [0, 9]",
      "startOffset" : 4,
      "endOffset" : 10
    }, {
      "referenceID" : 8,
      "context" : "2 0 [0, 5] [0, 9]",
      "startOffset" : 11,
      "endOffset" : 17
    }, {
      "referenceID" : 9,
      "context" : "[10, 10] 0",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 9,
      "context" : "[10, 10] 0",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 4,
      "context" : "[0, 5]",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 8,
      "context" : "[0, 9] 10",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "[2],¬X1 [2],¬Y1 [5], Z1 [5],¬Z1X2Y2",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[2],¬X1 [2],¬Y1 [5], Z1 [5],¬Z1X2Y2",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 4,
      "context" : "[2],¬X1 [2],¬Y1 [5], Z1 [5],¬Z1X2Y2",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 4,
      "context" : "[2],¬X1 [2],¬Y1 [5], Z1 [5],¬Z1X2Y2",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 4,
      "context" : "[5],¬Z1 [5], Z1X2Y2",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5],¬Z1 [5], Z1X2Y2",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 1,
      "context" : "[2],¬X2 [2],¬Y2",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[2],¬X2 [2],¬Y2",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 4,
      "context" : "[5],¬Z2 [5], Z2X3Y3 [5], Z2 [5],¬Z2X3Y3",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[5],¬Z2 [5], Z2X3Y3 [5], Z2 [5],¬Z2X3Y3",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 4,
      "context" : "[5],¬Z2 [5], Z2X3Y3 [5], Z2 [5],¬Z2X3Y3",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 4,
      "context" : "[5],¬Z2 [5], Z2X3Y3 [5], Z2 [5],¬Z2X3Y3",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 1,
      "context" : "[2],¬Xn [2],¬Yn [5], Zn−1 [5],¬Zn−1XnYn [5],¬Zn−1 [5], Zn−1XnYn",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[2],¬Xn [2],¬Yn [5], Zn−1 [5],¬Zn−1XnYn [5],¬Zn−1 [5], Zn−1XnYn",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 4,
      "context" : "[2],¬Xn [2],¬Yn [5], Zn−1 [5],¬Zn−1XnYn [5],¬Zn−1 [5], Zn−1XnYn",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 4,
      "context" : "[2],¬Xn [2],¬Yn [5], Zn−1 [5],¬Zn−1XnYn [5],¬Zn−1 [5], Zn−1XnYn",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 4,
      "context" : "[2],¬Xn [2],¬Yn [5], Zn−1 [5],¬Zn−1XnYn [5],¬Zn−1 [5], Zn−1XnYn",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 4,
      "context" : "[2],¬Xn [2],¬Yn [5], Zn−1 [5],¬Zn−1XnYn [5],¬Zn−1 [5], Zn−1XnYn",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 15,
      "context" : "[16] has been discussed already in the introduction.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "[5] provided the first sound-and-complete algorithm for checking the dynamiccontrollability of CSTNs with Uncertainty (CSTNU) and thus it can be employed for checking the dynamic-consistency of CSTNs as a special case.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "Nevertheless, no worst-case bound on the time complexity of the procedure was provided in [5].",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 4,
      "context" : "Indeed, the algorithm in [5] is not singly-exponential time bounded.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 5,
      "context" : "Finally, a sound algorithm for checking the dynamiccontrollability of CSTNUs was given by Combi, Hunsberger, Posenato in [6].",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 11,
      "context" : "In future works we would like to settle the exact computational complexity of CSTN-DC, as well as to extend our approach in order to check the dynamic-controllability of CSTN with Uncertainty [12].",
      "startOffset" : 192,
      "endOffset" : 196
    } ],
    "year" : 2015,
    "abstractText" : "Conditional Simple Temporal Network (CSTN) is a constraint-based graph-formalism for conditional temporal planning. It offers a more flexible formalism than the equivalent CSTP model of Tsamardinos, Vidal and Pollack, from which it was derived mainly as a sound formalization. Three notions of consistency arise for CSTNs and CSTPs: weak, strong, and dynamic. Dynamic consistency is the most interesting notion, but it is also the most challenging and it was conjectured to be hard to assess. Tsamardinos, Vidal and Pollack gave a doubly-exponential time algorithm for deciding whether a CSTN is dynamicallyconsistent and to produce, in the positive case, a dynamic execution strategy of exponential size. In the present work we offer a proof that deciding whether a CSTN is dynamicallyconsistent is coNP-hard and provide the first singly-exponential time algorithm for this problem, also producing a dynamic execution strategy whenever the input CSTN is dynamically-consistent. The algorithm is based on a novel connection with Mean Payoff Games, a family of two-player infinite games played on finite graphs, well known for having applications in model-checking and formal verification. The presentation of such connection is mediated by the Hyper Temporal Network model, a tractable generalization of Simple Temporal Networks whose consistency checking is equivalent to determining Mean Payoff Games. In order to analyze the algorithm we introduce a refined notion of dynamic-consistency, named -dynamic-consistency, and present a sharp lower bounding analysis on the critical value of the reaction time ε̂ where the CSTN transits from being, to not being, dynamically-consistent. The proof technique introduced in this analysis of ε̂ is applicable more generally when dealing with linear difference constraints which include strict inequalities.",
    "creator" : "LaTeX with hyperref package"
  }
}