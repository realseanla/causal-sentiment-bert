{
  "name" : "1601.00318.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Unified Approach for Learning the Parameters of Sum-Product Networks",
    "authors" : [ "Han Zhao", "Pascal Poupart" ],
    "emails" : [ "han.zhao@cs.cmu.edu", "ppoupart@uwaterloo.ca", "ggordon@cs.cmu.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Sum-product networks (SPNs) are new deep graphical model architectures that admit exact probabilistic inference in linear time in the size of the network [14]. Similar to traditional graphical models, there are two main problems when learning SPNs: structure learning and parameter learning. Parameter learning is interesting even if we know the ground truth structure ahead of time; structure learning depends on parameter learning , so better parameter learning can often lead to better structure learning. Poon and Domingos [14] and Gens and Domingos [6] proposed both generative and discriminative learning algorithms for parameters in SPNs. At a high level, these approaches view SPNs as deep architectures and apply projected gradient descent (PGD) to optimize the data log-likelihood. There are several drawbacks associated with PGD. For example, the projection step in PGD hurts the convergence of the algorithm and it will often lead to solutions on the boundary of the feasible region. Also, PGD contains an additional arbitrary parameter, the projection margin, which can be hard to set well in practice. In [14, 6], the authors also mentioned the possibility of applying EM algorithms to train SPNs by viewing sum nodes in SPNs as hidden variables. They presented an EM update formula without details. However, the update formula for EM given in [14, 6] is incorrect, as first pointed out and corrected by [12].\nIn this paper we take a different perspective and present a unified framework, which treats [14, 6] as special cases, for learning the parameters of SPNs. We prove that any complete and decomposable SPN is equivalent to a mixture of trees where each tree corresponds to a product of univariate distributions. Based on the mixture model perspective, we can precisely characterize the functional form of the objective function based on the network structure. We show that the optimization problem associated with learning the parameters of SPNs based on the MLE principle can be formulated as a signomial program (SP), where both PGD and exponentiated gradient (EG) can be viewed as first order approximations of the signomial program after suitable transformations of the objective\n29th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n60 1.\n00 31\n8v 4\n[ cs\n.L G\n] 2\n6 A\nug 2\nfunction. We also show that the signomial program formulation can be equivalently transformed into a difference of convex functions (DCP) formulation, where the objective function of the program can be naturally expressed as a difference of two convex functions. The DCP formulation allows us to develop two efficient optimization algorithms for learning the parameters of SPNs based on sequential monomial approximations (SMA) and the concave-convex procedure (CCCP), respectively. Both proposed approaches naturally admit multiplicative updates, hence effectively deal with the positivity constraints of the optimization. Furthermore, under our unified framework, we also show that CCCP leads to the same algorithm as EM despite that these two approaches are different from each other in general. Although we mainly focus on MLE based parameter learning, the mixture model interpretation of SPN also helps to develop a Bayesian learning method for SPNs [21].\nPGD, EG, SMA and CCCP can all be viewed as different levels of convex relaxation of the original SP. Hence the framework also provides an intuitive way to compare all four approaches. We conduct extensive experiments on 20 benchmark data sets to compare the empirical performance of PGD, EG, SMA and CCCP. Experimental results validate our theoretical analysis that CCCP is the best among all 4 approaches, showing that it converges consistently faster and with more stability than the other three methods. Furthermore, we use CCCP to boost the performance of LearnSPN [7], showing that it can achieve results comparable to state-of-the-art structure learning algorithms using SPNs with much smaller network sizes."
    }, {
      "heading" : "2 Background",
      "text" : ""
    }, {
      "heading" : "2.1 Sum-Product Networks",
      "text" : "To simplify the discussion of the main idea of our unified framework, we focus our attention on SPNs over Boolean random variables. However, the framework presented here is general and can be easily extended to other discrete and continuous random variables. We first define the notion of network polynomial. We use Ix to denote an indicator variable that returns 1 when X = x and 0 otherwise. Definition 1 (Network Polynomial [4]). Let f(·) ≥ 0 be an unnormalized probability distribution over a Boolean random vector X1:N . The network polynomial of f(·) is a multilinear function∑\nx f(x) ∏N n=1 Ixn of indicator variables, where the summation is over all possible instantiations of\nthe Boolean random vector X1:N .\nA Sum-Product Network (SPN) over Boolean variables X1:N is a rooted DAG that computes the network polynomial over X1:N . The leaves are univariate indicators of Boolean variables and internal nodes are either sum or product. Each sum node computes a weighted sum of its children and each product node computes the product of its children. The scope of a node in an SPN is defined as the set of variables that have indicators among the node’s descendants. For any node v in an SPN, if v is a terminal node, say, an indicator variable over X , then scope(v) = {X}, else scope(v) = ⋃ ṽ∈Ch(v) scope(ṽ). An SPN is complete iff each sum node has children with the same\nscope. An SPN is decomposable iff for every product node v, scope(vi) ⋂\nscope(vj) = ∅ where vi, vj ∈ Ch(v), i 6= j. The scope of the root node is {X1, . . . , XN}. In this paper, we focus on complete and decomposable SPNs. For a complete and decomposable SPN S, each node v in S defines a network polynomial fv(·) which corresponds to the sub-SPN (subgraph) rooted at v. The network polynomial of S, denoted by fS , is the network polynomial defined by the root of S, which can be computed recursively from its children. The probability distribution induced by an SPN S is defined as PrS(x) , fS(x)∑\nx fS(x) . The normalization constant∑\nx fS(x) can be computed in O(|S|) in SPNs by setting the values of all the leaf nodes to be 1, i.e.,∑ x fS(x) = fS(1) [14]. This leads to efficient joint/marginal/conditional inference in SPNs."
    }, {
      "heading" : "2.2 Signomial Programming (SP)",
      "text" : "Before introducing SP, we first introduce geometric programming (GP), which is a strict subclass of SP. A monomial is defined as a function h : Rn++ 7→ R: h(x) = dxa11 xa22 · · ·xann , where the domain is restricted to be the positive orthant (Rn++), the coefficient d is positive and the exponents ai ∈ R,∀i. A posynomial is a sum of monomials: g(x) = ∑K k=1 dkx a1k 1 x a2k 2 · · ·xankn . One of the key properties of posynomials is positivity, which allows us to transform any posynomial into the log\ndomain. A GP in standard form is defined to be an optimization problem where both the objective function and the inequality constraints are posynomials and the equality constraints are monomials. There is also an implicit constraint that x ∈ Rn++. A GP in its standard form is not a convex program since posynomials are not convex functions in general. However, we can effectively transform it into a convex problem by using the logarithmic transformation trick on x, the multiplicative coefficients of each monomial and also each objective/constraint function [3, 1].\nAn SP has the same form as GP except that the multiplicative constant d inside each monomial is not restricted to be positive, i.e., d can take any real value. Although the difference seems to be small, there is a huge difference between GP and SP from the computational perspective. The negative multiplicative constant in monomials invalidates the logarithmic transformation trick frequently used in GP. As a result, SPs cannot be reduced to convex programs and are believed to be hard to solve in general [1]."
    }, {
      "heading" : "3 Unified Approach for Learning",
      "text" : "In this section we will show that the parameter learning problem of SPNs based on the MLE principle can be formulated as an SP. We will use a sequence of optimal monomial approximations combined with backtracking line search and the concave-convex procedure to tackle the SP. Due to space constraints, we refer interested readers to the supplementary material for all the proof details."
    }, {
      "heading" : "3.1 Sum-Product Networks as a Mixture of Trees",
      "text" : "We introduce the notion of induced trees from SPNs and use it to show that every complete and decomposable SPN can be interpreted as a mixture of induced trees, where each induced tree corresponds to a product of univariate distributions. From this perspective, an SPN can be understood as a huge mixture model where the effective number of components in the mixture is determined by its network structure. The method we describe here is not the first method for interpreting an SPN (or the related arithmetic circuit) as a mixture distribution [20, 5, 2]; but, the new method can result in an exponentially smaller mixture, see the end of this section for more details. Definition 2 (Induced SPN). Given a complete and decomposable SPN S over X1:N , let T = (TV , TE) be a subgraph of S. T is called an induced SPN from S if\n1. Root(S) ∈ TV . 2. If v ∈ TV is a sum node, then exactly one child of v in S is in TV , and the corresponding\nedge is in TE . 3. If v ∈ TV is a product node, then all the children of v in S are in TV , and the corresponding\nedges are in TE . Theorem 1. If T is an induced SPN from a complete and decomposable SPN S , then T is a tree that is complete and decomposable.\nAs a result of Thm. 1, we will use the terms induced SPNs and induced trees interchangeably. With some abuse of notation, we use T (x) to mean the value of the network polynomial of T with input vector x. Theorem 2. If T is an induced tree from S over X1:N , then T (x) = ∏ (vi,vj)∈TE wij ∏N n=1 Ixn , where wij is the edge weight of (vi, vj) if vi is a sum node and wij = 1 if vi is a product node.\nRemark. Although we focus our attention on Boolean random variables for the simplicity of discussion and illustration, Thm. 2 can be extended to the case where the univariate distributions at the leaf nodes are continuous or discrete distributions with countably infinitely many values, e.g., Gaussian distributions or Poisson distributions. We can simply replace the product of univariate distributions term, ∏N n=1 Ixn , in Thm. 2 to be the general form ∏N n=1 pn(Xn), where pn(Xn) is a univariate distribution over Xn. Also note that it is possible for two unique induced trees to share the same product of univariate distributions, but in this case their weight terms ∏ (vi,vi)∈TE wij are guaranteed to be different. As we will see shortly, Thm. 2 implies that the joint distribution over {Xn}Nn=1 represented by an SPN is essentially a mixture model with potentially exponentially many components in the mixture.\nDefinition 3 (Network cardinality). The network cardinality τS of an SPN S is the number of unique induced trees.\nTheorem 3. τS = fS(1|1), where fS(1|1) is the value of the network polynomial of S with input vector 1 and all edge weights set to be 1.\nTheorem 4. S(x) = ∑τSt=1 Tt(x), where Tt is the tth unique induced tree of S. Remark. The above four theorems prove the fact that an SPN S is an ensemble or mixture of trees, where each tree computes an unnormalized distribution over X1:N . The total number of unique trees in S is the network cardinality τS , which only depends on the structure of S. Each component is a simple product of univariate distributions. We illustrate the theorems above with a simple example in Fig. 1.\nZhao et al. [20] show that every complete and decomposable SPN is equivalent to a bipartite Bayesian network with a layer of hidden variables and a layer of observable random variables. The number of hidden variables in the bipartite Bayesian network is equal to the number of sum nodes in S. A naive expansion of such Bayesian network to a mixture model will lead to a huge mixture model with 2O(M) components, where M is the number of sum nodes in S. Here we complement their theory and show that each complete and decomposable SPN is essentially a mixture of trees and the effective number of unique induced trees is given by τS . Note that τS = fS(1|1) depends only on the network structure, and can often be much smaller than 2O(M). Without loss of generality, assuming that in S layers of sum nodes are alternating with layers of product nodes, then fS(1|1) = Ω(2h), where h is the height of S. However, the exponentially many trees are recursively merged and combined in S such that the overall network size is still tractable."
    }, {
      "heading" : "3.2 Maximum Likelihood Estimation as SP",
      "text" : "Let’s consider the likelihood function computed by an SPN S over N binary random variables with model parameters w and input vector x ∈ {0, 1}N . Here the model parameters in S are edge weights from every sum node, and we collect them together into a long vector w ∈ RD++, where D corresponds to the number of edges emanating from sum nodes in S. By definition, the probability distribution induced by S can be computed by PrS(x|w) , fS(x|w)∑\nx fS(x|w) = fS(x|w)fS(1|w) .\nCorollary 5. Let S be an SPN with weights w ∈ RD++ over input vector x ∈ {0, 1}N , the network polynomial fS(x|w) is a posynomial: fS(x|w) = ∑fS(1|1) t=1 ∏N n=1 I (t) xn ∏D d=1 w Iwd∈Tt d , where Iwd∈Tt is the indicator variable whether wd is in the t-th induced tree Tt or not. Each monomial corresponds exactly to a unique induced tree SPN from S. The above statement is a direct corollary of Thm. 2, Thm. 3 and Thm. 4. From the definition of network polynomial, we know that fS is a multilinear function of the indicator variables. Corollary 5 works as a complement to characterize the functional form of a network polynomial in terms of w. It follows that the likelihood function LS(w) , PrS(x|w) can be expressed as the ratio of two posynomial functions. We now show that the optimization problem based on MLE is an SP. Using the definition of Pr(x|w) and Corollary 5, let τ = fS(1|1), the MLE problem can be rewritten as\nmaximizew fS(x|w) fS(1|w) =\n∑τ t=1 ∏N n=1 I (t) xn ∏D d=1 w\nIwd∈Tt d∑τ\nt=1 ∏D d=1 w Iwd∈Tt d\nsubject to w ∈ RD++\n(1)\nProposition 6. The MLE problem for SPNs is a signomial program.\nBeing nonconvex in general, SP is essentially hard to solve from a computational perspective [1, 3]. However, despite the hardness of SP in general, the objective function in the MLE formulation of SPNs has a special structure, i.e., it is the ratio of two posynomials, which makes the design of efficient optimization algorithms possible."
    }, {
      "heading" : "3.3 Difference of Convex Functions",
      "text" : "Both PGD and EG are first-order methods and they can be viewed as approximating the SP after applying a logarithmic transformation to the objective function only. Although (1) is a signomial program, its objective function is expressed as the ratio of two posynomials. Hence, we can still apply the logarithmic transformation trick used in geometric programming to its objective function and to the variables to be optimized. More concretely, let wd = exp(yd),∀d and take the log of the objective function; it becomes equivalent to maximize the following new objective without any constraint on y:\nmaximize log τ(x)∑ t=1 exp ( D∑ d=1 ydIyd∈Tt )− log( τ∑ t=1 exp ( D∑ d=1 ydIyd∈Tt )) (2)\nNote that in the first term of Eq. 2 the upper index τ(x) ≤ τ , fS(1|1) depends on the current input x. By transforming into the log-space, we naturally guarantee the positivity of the solution at each iteration, hence transforming a constrained optimization problem into an unconstrained optimization problem without any sacrifice. Both terms in Eq. 2 are convex functions in y after the transformation. Hence, the transformed objective function is now expressed as the difference of two convex functions, which is called a DC function [9]. This helps us to design two efficient algorithms to solve the problem based on the general idea of sequential convex approximations for nonlinear programming."
    }, {
      "heading" : "3.3.1 Sequential Monomial Approximation",
      "text" : "Let’s consider the linearization of both terms in Eq. 2 in order to apply first-order methods in the transformed space. To compute the gradient with respect to different components of y, we view each node of an SPN as an intermediate function of the network polynomial and apply the chain rule to back-propagate the gradient. The differentiation of fS(x|w) with respect to the root node of the network is set to be 1. The differentiation of the network polynomial with respect to a partial function at each node can then be computed in two passes of the network: the bottom-up pass evaluates the values of all partial functions given the current input x and the top-down pass differentiates the network polynomial with respect to each partial function. Following the evaluation-differentiation passes, the gradient of the objective function in (2) can be computed inO(|S|). Furthermore, although the computation is conducted in y, the results are fully expressed in terms of w, which suggests that in practice we do not need to explicitly construct y from w.\nLet f(y) = log fS(x|exp(y))− log fS(1|exp(y)). It follows that approximating f(y) with the best linear function is equivalent to using the best monomial approximation of the signomial program (1). This leads to a sequential monomial approximations of the original SP formulation: at each iteration y(k), we linearize both terms in Eq. 2 and form the optimal monomial function in terms of w(k). The additive update of y(k) leads to a multiplicative update of w(k) since w(k) = exp(y(k)), and we use a backtracking line search to determine the step size of the update in each iteration."
    }, {
      "heading" : "3.3.2 Concave-convex Procedure",
      "text" : "Sequential monomial approximation fails to use the structure of the problem when learning SPNs. Here we propose another approach based on the concave-convex procedure (CCCP) [18] to use the fact that the objective function is expressed as the difference of two convex functions. At a high level CCCP solves a sequence of concave surrogate optimizations until convergence. In many cases, the maximum of a concave surrogate function can only be solved using other convex solvers and as a result the efficiency of the CCCP highly depends on the choice of the convex solvers. However, we show that by a suitable transformation of the network we can compute the maximum of the concave surrogate in closed form in time that is linear in the network size, which leads to a very efficient\nalgorithm for learning the parameters of SPNs. We also prove the convergence properties of our algorithm.\nConsider the objective function to be maximized in DCP: f(y) = log fS(x| exp(y)) − log fS(1| exp(y)) , f1(y) + f2(y) where f1(y) , log fS(x| exp(y)) is a convex function and f2(y) , − log fS(1| exp(y)) is a concave function. We can linearize only the convex part f1(y) to obtain a surrogate function\nf̂(y, z) = f1(z) +∇yf1(z)T (y − z) + f2(y) (3)\nfor ∀y, z ∈ RD. Now f̂(y, z) is a concave function in y. Due to the convexity of f1(y) we have f1(y) ≥ f1(z) +∇yf1(z)T (y − z),∀y, z and as a result the following two properties always hold for ∀y, z: f̂(y, z) ≤ f(y) and f̂(y,y) = f(y). CCCP updates y at each iteration k by solving y(k) ∈ arg maxy f̂(y,y(k−1)) unless we already have y(k−1) ∈ arg maxy f̂(y,y(k−1)), in which case a generalized fixed point y(k−1) has been found and the algorithm stops.\nIt is easy to show that at each iteration of CCCP we always have f(y(k)) ≥ f(y(k−1)). Note also that f(y) is computing the log-likelihood of input x and therefore it is bounded above by 0. By the monotone convergence theorem, limk→∞ f(y(k)) exists and the sequence {f(y(k))} converges. We now discuss how to compute a closed form solution for the maximization of the concave surrogate f̂(y,y(k−1)). Since f̂(y,y(k−1)) is differentiable and concave for any fixed y(k−1), a sufficient and necessary condition to find its maximum is\n∇yf̂(y,y(k−1)) = ∇yf1(y(k−1)) +∇yf2(y) = 0 (4) In the above equation, if we consider only the partial derivative with respect to yij(wij), we obtain\nw (k−1) ij fvj (x|w(k−1)) fS(x|w(k−1)) ∂fS(x|w(k−1)) ∂fvi(x|w(k−1)) = wijfvj (1|w) fS(1|w) ∂fS(1|w) ∂fvi(1|w)\n(5)\nEq. 5 leads to a system of D nonlinear equations, which is hard to solve in closed form. However, if we do a change of variable by considering locally normalized weights w′ij (i.e., w ′ ij ≥ 0 and∑\nj w ′ ij = 1 ∀i), then a solution can be easily computed. As described in [13, 20], any SPN can be transformed into an equivalent normal SPN with locally normalized weights in a bottom up pass as follows:\nw′ij = wijfvj (1|w)∑ j wijfvj (1|w)\n(6)\nWe can then replace wijfvj (1|w) in the above equation by the expression it is equal to in Eq. 5 to obtain a closed form solution:\nw′ij ∝ w(k−1)ij fvj (x|w(k−1)) fS(x|w(k−1)) ∂fS(x|w(k−1)) ∂fvi(x|w(k−1))\n(7)\nNote that in the above derivation both fvi(1|w)/fS(1|w) and ∂fS(1|w)/∂fvi(1|w) can be treated as constants and hence absorbed since w′ij ,∀j are constrained to be locally normalized. In order to obtain a solution to Eq. 5, for each edge weight wij , the sufficient statistics include only three terms, i.e, the evaluation value at vj , the differentiation value at vi and the previous edge weight w (k−1) ij , all of which can be obtained in two passes of the network for each input x. Thus the computational complexity to obtain a maximum of the concave surrogate is O(|S|). Interestingly, Eq. 7 leads to the same update formula as in the EM algorithm [12] despite the fact that CCCP and EM start from different perspectives. We show that all the limit points of the sequence {w(k)}∞k=1 are guaranteed to be stationary points of DCP in (2).\nTheorem 7. Let {w(k)}∞k=1 be any sequence generated using Eq. 7 from any positive initial point, then all the limiting points of {w(k)}∞k=1 are stationary points of the DCP in (2). In addition, limk→∞ f(y (k)) = f(y∗), where y∗ is some stationary point of (2).\nWe summarize all four algorithms and highlight their connections and differences in Table 1. Although we mainly discuss the batch version of those algorithms, all of the four algorithms can be easily adapted to work in stochastic and/or parallel settings."
    }, {
      "heading" : "4 Experiments",
      "text" : ""
    }, {
      "heading" : "4.1 Experimental Setting",
      "text" : "We conduct experiments on 20 benchmark data sets from various domains to compare and evaluate the convergence performance of the four algorithms: PGD, EG, SMA and CCCP (EM). These 20 data sets are widely used in [7, 15] to assess different SPNs for the task of density estimation. All the features in the 20 data sets are binary features. All the SPNs that are used for comparisons of PGD, EG, SMA and CCCP are trained using LearnSPN [7]. We discard the weights returned by LearnSPN and use random weights as initial model parameters. The random weights are determined by the same random seed in all four algorithms. Detailed information about these 20 datasets and the SPNs used in the experiments are provided in the supplementary material."
    }, {
      "heading" : "4.2 Parameter Learning",
      "text" : "We implement all four algorithms in C++. For each algorithm, we set the maximum number of iterations to 50. If the absolute difference in the training log-likelihood at two consecutive steps is less than 0.001, the algorithms are stopped. For PGD, EG and SMA, we combine each of them with backtracking line search and use a weight shrinking coefficient set at 0.8. The learning rates are initialized to 1.0 for all three methods. For PGD, we set the projection margin to 0.01. There is no learning rate and no backtracking line search in CCCP. We set the smoothing parameter to 0.001 in CCCP to avoid numerical issues.\nWe show in Fig. 2 the average log-likelihood scores on 20 training data sets to evaluate the convergence speed and stability of PGD, EG, SMA and CCCP. Clearly, CCCP wins by a large margin over PGD, EG and SMA, both in convergence speed and solution quality. Furthermore, among the four algorithms, CCCP is the most stable one due to its guarantee that the log-likelihood (on training data) will not decrease after each iteration. As shown in Fig. 2, the training curves of CCCP are more smooth than the other three methods in almost all the cases. These 20 experiments also clearly show that CCCP often converges in a few iterations. On the other hand, PGD, EG and SMA are on par with each other since they are all first-order methods. SMA is more stable than PGD and EG and often achieves better solutions than PGD and EG. On large data sets, SMA also converges faster than PGD and EG. Surprisingly, EG performs worse than PGD in some cases and is quite unstable despite the fact that it admits multiplicative updates. The “hook shape” curves of PGD in some data sets, e.g. Kosarak and KDD, are due to the projection operations.\nThe computational complexity per update is O(|S|) in all four algorithms. The constant involved in the |S| term of CCCP is slightly larger than those of the other three algorithms as there are more exp(·) calls in CCCP. However, in practice, CCCP often takes less time than the other three algorithms because it takes fewer iterations to converge. We list detailed running time statistics for all four algorithms on the 20 data sets in the supplementary material."
    }, {
      "heading" : "4.3 Fine Tuning",
      "text" : "We combine CCCP as a “fine tuning” procedure with the structure learning algorithm LearnSPN and compare it to the state-of-the-art structure learning algorithm ID-SPN [15]. More concretely, we keep the model parameters learned from LearnSPN and use them to initialize CCCP. We then update the model parameters globally using CCCP as a fine tuning technique. This normally helps to obtain a better generative model since the original parameters are learned greedily and locally during the structure learning algorithm. We use the validation set log-likelihood score to avoid overfitting. The algorithm returns the set of parameters that achieve the best validation set log-likelihood score as output. For LearnSPN and ID-SPN, we use their publicly available implementations provided by the original authors and the default hyperparameter settings. Experimental results are reported in Table. 2. As shown in Table 2, the use of CCCP after LearnSPN always helps to improve the model performance. By optimizing model parameters on these 20 data sets, we boost LearnSPN to achieve better results than state-of-the-art ID-SPN on 7 data sets, where the original LearnSPN only outperforms ID-SPN on 1 data set. Note that the sizes of the SPNs returned by LearnSPN are much smaller than those produced by ID-SPN. Hence, it is remarkable that by fine tuning the parameters with CCCP, we can achieve better performance despite the fact that the models are smaller. For a fair comparison, we also list the size of the SPNs returned by ID-SPN in the supplementary material."
    }, {
      "heading" : "5 Conclusion",
      "text" : "We show that the network polynomial of an SPN is a posynomial function of the model parameters, and that learning the parameter by maximum likelihood yields a signomial program. We propose two convex relaxations to solve the SP. We analyze the convergence properties of CCCP for learning SPNs. Extensive experiments are conducted to evaluate the proposed approaches and current methods. We also recommend combining CCCP with current structure learning algorithms to boost the modeling accuracy."
    }, {
      "heading" : "Acknowledgments",
      "text" : "HZ and GG gratefully acknowledge support from ONR contract N000141512365. HZ also thanks Ryan Tibshirani for the helpful discussion about CCCP."
    }, {
      "heading" : "A Proof of SPNs as Mixture of Trees",
      "text" : "Theorem 1. If T is an induced SPN from a complete and decomposable SPN S , then T is a tree that is complete and decomposable.\nProof. Argue by contradiction that T is not a tree, then there must exist a node v ∈ T such that v has more than one parent in T . This means that there exist at least two pathsR, p1, . . . , v andR, q1, . . . , v that connect the root of S(T ), which we denote by R, and v. Let t be the last node in R, p1, . . . , v and R, q1, . . . , v such that R, . . . , t are common prefix of these two paths. By construction we know that such t must exist since these two paths start from the same root node R (R will be one candidate of such t). Also, we claim that t 6= v otherwise these two paths overlap with each other, which contradicts the assumption that v has multiple parents. This shows that these two paths can be represented as R, . . . , t, p, . . . , v and R, . . . , t, q, . . . , v where R, . . . , t are the common prefix shared by these two paths and p 6= q since t is the last common node. From the construction process defined in Def. 2, we know that both p and q are children of t in S . Recall that for each sum node in S , Def. 2 takes at most one child, hence we claim that t must be a product node, since both p and q are children of t. Then the paths that t→ p v and t→ q v indicate that scope(v) ⊆ scope(p) ⊆ scope(t) and scope(v) ⊆ scope(q) ⊆ scope(t), leading to ∅ 6= scope(v) ⊆ scope(p) ∩ scope(q), which is a contradiction of the decomposability of the product node t. Hence as long as S is complete and decomposable, T must be a tree. The completeness of T is trivially satisfied because each sum node has only one child in T . It is also straightforward to verify that T satisfies the decomposability as T is an induced subgraph of S , which is decomposable.\nTheorem 2. If T is an induced tree from S over X1:N , then T (x) = ∏ (vi,vj)∈TE wij ∏N n=1 Ixn , where wij is the edge weight of (vi, vj) if vi is a sum node and wij = 1 if vi is a product node.\nProof. First, the scope of T is the same as the scope of S because the root of S is also the root of T . This shows that for each Xi there is at least one indicator Ixi in the leaves otherwise the scope of the root node of T will be a strict subset of the scope of the root node of S. Furthermore, for each variable Xi there is at most one indicator Ixi in the leaves. This is observed by the fact that there is at most one child collected from a sum node into T and if Ixi and Ix̄i appear simultaneously in the leaves, then their least common ancestor must be a product node. Note that the least common ancestor of Ixi and Ix̄i is guaranteed to exist because of the tree structure of T . However, this leads to a contradiction of the fact that S is decomposable. As a result, there is exactly one indicator Ixi for each variable Xi in T . Hence the multiplicative constant of the monomial admits the form ∏n i=1 Ixi , which is a product of univariate distributions. More specifically, it is a product of indicator variables in the case of Boolean input variables.\nWe have already shown that T is a tree and only product nodes in T can have multiple children. It follows that the functional form of fT (x) must be a monomial, and only edge weights that are in T contribute to the monomial. Combing all the above, we know that fT (x) =∏\n(vi,vi)∈TE wij ∏N n=1 Ixn .\nTheorem 3. τS = fS(1|1), where fS(1|1) is the value of the network polynomial of S with input vector 1 and all edge weights set to be 1.\nTheorem 4. S(x) = ∑τSt=1 Tt(x), where Tt is the tth unique induced tree of S. Proof. We prove by induction on the height of S . If the height of S is 2, then depending on the type of the root node, we have two cases:\n1. If the root is a sum node with K children, then there are C1K = K different subgraphs that satisfy Def. 2, which is exactly the value of the network by setting all the indicators and edge weights from the root to be 1. 2. If the root is a product node then there is only 1 subgraph which is the graph itself. Again, this equals to the value of S by setting all indicators to be 1.\nAssume the theorem is true for SPNs with height ≤ h. Consider an SPN S with height h+ 1. Again, depending on the type of the root node, we need to discuss two cases:\n1. If the root is a sum node with K children, where the kth sub-SPN has fSk(1|1) unique induced trees, then by Def. 2 the total number of unique induced trees of S is∑K k=1 fSk(1|1) = ∑K k=1 1 · fSk(1|1) = fS(1|1).\n2. If the root is a product node with K children, then the total number of unique induced trees of S can then be computed by∏Kk=1 fSk(1|1) = fS(1|1).\nThe second part of the theorem follows by using distributive law between multiplication and addition to combine unique trees that share the same prefix in bottom-up order."
    }, {
      "heading" : "B MLE as Signomial Programming",
      "text" : "Proposition 6. The MLE problem for SPNs is a signomial program.\nProof. Using the definition of Pr(x|w) and Corollary 5, let τ = fS(1|1), the MLE problem can be rewritten as\nmaximizew fS(x|w) fS(1|w) =\n∑τ t=1 ∏N n=1 I (t) xn ∏D d=1 w\nIwd∈Tt d∑τ\nt=1 ∏D d=1 w Iwd∈Tt d\nsubject to w ∈ RD++\n(8)\nwhich we claim is equivalent to:\nminimizew,z − z subject to τ∑ t=1 z D∏ d=1 w Iwd∈Tt d − τ∑ l=1 N∏ n=1 I(t)xn D∏ d=1 w Iwd∈Tt d ≤ 0\nw ∈ RD++, z > 0\n(9)\nIt is easy to check that both the objective function and constraint function in (9) are signomials. To see the equivalence of (8) and (9), let p∗ be the optimal value of (8) achieved at w∗. Choose z = p∗ and w = w∗ in (9), then −z is also the optimal solution of (9) otherwise we can find feasible (z′,w′) in (9) which has −z′ < −z ⇔ z′ > z. Combined with the constraint function in (9), we have p∗ = z < z′ ≤ fS(x|w\n′) fS(1|w′) , which contradicts the optimality of p ∗. In the other direction, let z∗,w∗ be the solution that achieves optimal value of (9), then we claim that z∗ is also the optimal value of (8), otherwise there exists a feasible w in (8) such that z , fS(x|w)fS(1|w) > z\n∗. Since (w, z) is also feasible in (9) with −z < −z∗, this contradicts the optimality of z∗.\nThe transformation from (8) to (9) does not make the problem any easier to solve. Rather, it destroys the structure of (8), i.e., the objective function of (8) is the ratio of two posynomials. However, the equivalent transformation does reveal some insights about the intrinsic complexity of the optimization problem, which indicates that it is hard to solve (8) efficiently with the guarantee of achieving a globally optimal solution."
    }, {
      "heading" : "C Convergence of CCCP for SPNs",
      "text" : "We discussed before that the sequence of function values {f(y(k))} converges to a limiting point. However, this fact alone does not necessarily indicate that {f(y(k))} converges to f(y∗) where y∗ is a stationary point of f(·) nor does it imply that the sequence {y(k)} converges as k →∞. Zangwill’s global convergence theory [19] has been successfully applied to study the convergence properties of many iterative algorithms frequently used in machine learning, including EM [17], generalized alternating minimization [8] and also CCCP [11]. Here we also apply Zangwill’s theory and combine the analysis from [11] to show the following theorem:\nTheorem 7. Let {w(k)}∞k=1 be any sequence generated using Eq. 7 from any positive initial point, then all the limiting points of {w(k)}∞k=1 are stationary points of the DCP in (2). In addition, limk→∞ f(y (k)) = f(y∗), where y∗ is some stationary point of (2).\nProof. We will use Zangwill’s global convergence theory for iterative algorithms [19] to show the convergence in our case. Before showing the proof, we need to first introduce the notion of “point-toset mapping”, where the output of the mapping is defined to be a set. More formally, a point-to-set map Φ from a set X to Y is defined as Φ : X 7→ P(Y), where P(Y) is the power set of Y . Suppose X and Y are equipped with the norm || · ||X and || · ||Y , respectively. A point-to-set map Φ is said to be closed at x∗ ∈ X if xk ∈ X , {xk}∞k=1 → x∗ and yk ∈ Y, {yk}∞k=1 → y∗, yk ∈ Φ(xk) imply that y∗ ∈ Φ(x∗). A point-to-set map Φ is said to be closed on S ⊆ X if Φ is closed at every point in S. The concept of closedness in the point-to-set map setting reduces to continuity if we restrict that the output of Φ to be a set of singleton for every possible input, i.e., when Φ is a point-to-point mapping.\nTheorem 8 (Global Convergence Theorem [19]). Let the sequence {xk}∞k=1 be generated by xk+1 ∈ Φ(xk), where Φ(·) is a point-to-set map from X to X . Let a solution set Γ ⊆ X be given, and suppose that:\n1. all points xk are contained in a compact set S ⊆ X . 2. Φ is closed over the complement of Γ. 3. there is a continuous function α on X such that:\n(a) if x 6∈ Γ, α(x′) > α(x) for ∀x′ ∈ Φ(x). (b) if x ∈ Γ, α(x′) ≥ α(x) for ∀x′ ∈ Φ(x).\nThen all the limit points of {xk}∞k=1 are in the solution set Γ and α(xk) converges monotonically to α(x∗) for some x∗ ∈ Γ.\nLet w ∈ RD+ . Let Φ(w(k−1)) = exp(arg maxy f̂(y,y(k−1))) and let α(w) = f(logw) = f(y) = log fS(x| exp(y)) − log fS(1| exp(y)). Here we use w and y interchangeably as w = exp(y) or each component is a one-to-one mapping. Note that since the arg maxy f̂(y,y (k−1)) given y(k−1) is achievable, Φ(·) is a well defined point-to-set map for w ∈ RD+ . Specifically, in our case given w(k−1), at each iteration of Eq. 7 we have\nw′ij = wijfvj (1|w)∑ j wijfvj (1|w) ∝ w(k−1)ij fvj (x|w(k−1)) fS(x|w(k−1)) ∂fS(x|w(k−1)) ∂fvi(x|w(k−1))\ni.e., the point-to-set mapping is given by\nΦij(w (k−1)) =\nw (k−1) ij fvj (x|w(k−1)) ∂fS(x|w (k−1)) ∂fvi (x|w(k−1))∑\nj′ w (k−1) ij′ fvj′ (x|w(k−1)) ∂fS(x|w(k−1)) ∂fvi (x|w(k−1))\nLet S = [0, 1]D, the D dimensional hyper cube. Then the above update formula indicates that Φ(w(k−1)) ∈ S. Furthermore, if we assume w(1) ∈ S, which can be obtained by local normalization before any update, we can guarantee that {wk}∞k=1 ⊆ S, which is a compact set in RD+ .\nThe solution to maxy f̂(y,y(k−1)) is not unique. In fact, there are infinitely many solutions to this nonlinear equations. However, as we define above, Φ(w(k−1)) returns one solution to this convex program in the D dimensional hyper cube. Hence in our case Φ(·) reduces to a point-to-point map, where the definition of closedness of a point-to-set map reduces to the notion of continuity of a point-to-point map. Define Γ = {w∗ | w∗ is a stationary point of α(·)}. Hence we only need to verify the continuity of Φ(w) when w ∈ S. To show this, we first characterize the functional form of ∂fS(x|w) ∂fvi (x|w)\nas it is used inside Φ(·). We claim that for each node vi, ∂fS(x|w)∂fvi (x|w) is again, a posynomial function of w. A graphical illustration is given in Fig. 3 to explain the process. This can also be derived from the sum rules and product rules used during top-down differentiation. More specifically, if vi is a product node, let vj , j = 1, . . . , J be its parents in the network, which are assumed to be sum nodes, the differentiation of fS with respect to fvi is given by ∂fS(x|w) ∂fvi (x|w) = ∑J j=1 ∂fS(x|w) ∂fvj (x|w) ∂fvj (x|w) ∂fvi (x|w)\n. We reach\n∂fS(x|w) ∂fvi(x|w) = J∑ j=1 wij ∂fS(x|w) ∂fvj (x|w)\n(10)\nSimilarly, if vi is a sum node and its parents vj , j = 1, . . . , J are assumed to be product nodes, we have\n∂fS(x|w) ∂fvi(x|w) = J∑ j=1 ∂fS(x|w) ∂fvj (x|w) fvj (x|w) fvi(x|w)\n(11)\nSince vj is a product node and vj is a parent of vi, so the last term in Eq. 11 can be equivalently expressed as\nfvj (x|w) fvi(x|w) = ∏ h6=i fvh(x|w)\nwhere the index is range from all the children of vj except vi. Combining the fact that the partial differentiation of fS with respect to the root node is 1 and that each fv is a posynomial function, it follows by induction in top-down order that ∂fS(x|w)∂fvi (x|w) is also a posynomial function of w.\nWe have shown that both the numerator and the denominator of Φ(·) are posynomial functions of w. Because posynomial functions are continuous functions, in order to show that Φ(·) is also continuous on S\\Γ, we need to guarantee that the denominator is not a degenerate posynomial function, i.e., the denominator of Φ(w) 6= 0 for all possible input vector x. Recall that Γ = {w∗ | w∗ is a stationary point of α(·)}, hence ∀w ∈ S\\Γ, w 6∈ bd S, where bd S is the boundary of the D dimensional hyper cube S. Hence we have ∀w ∈ S\\Γ ⇒ w ∈ int S ⇒ w > 0 for each component. This immediately leads to fv(x|w) > 0,∀v. As a result, Φ(w) is continuous on S\\Γ since it is the ratio of two strictly positive posynomial functions.\nWe now verify the third property in Zangwill’s global convergence theory. At each iteration of CCCP, we have the following two cases to consider:\n1. If w(k−1) 6∈ Γ, i.e., w(k−1) is not a stationary point of α(w), then y(k−1) 6∈ arg maxy f̂(y,y\n(k−1)), so we have α(w(k)) = f(y(k)) ≥ f̂(y(k),y(k−1)) > f̂(y(k−1),y(k−1)) = f(y(k−1)) = α(w(k−1)). 2. If w(k−1) ∈ Γ, i.e., w(k−1) is a stationary point of α(w), then y(k−1) ∈ arg maxy f̂(y,y\n(k−1)), so we have α(w(k)) = f(y(k)) ≥ f̂(y(k),y(k−1)) = f̂(y(k−1),y(k−1)) = f(y(k−1)) = α(w(k−1)).\nBy Zangwill’s global convergence theory, we now conclude that all the limit points of {wk}∞k=1 are in Γ and α(wk) converges monotonically to α(w∗) for some stationary point w∗ ∈ Γ.\nRemark 1. Technically we need to choose w0 ∈ int S to ensure the continuity of Φ(·). This initial condition combined with the fact that inside each iteration of CCCP the algorithm only applies\npositive multiplicative update and renormalization, ensure that after any finite k steps, wk ∈ intS. Theoretically, only in the limit it is possible that some components of w∞ may become 0. However in practice, due to the numerical precision of float numbers on computers, it is possible that after some finite update steps some of the components in wk become 0. So in practical implementation we recommend to use a small positive number to smooth out such 0 components in wk during the iterations of CCCP. Such smoothing may hurt the monotonic property of CCCP, but this can only happens when wk is close to w∗ and we can use early stopping to obtain a solution in the interior of S. Remark 2. Thm. 7 only implies that any limiting point of the sequence {wk}∞k=1({yk}∞k=1) must be a stationary point of the log-likelihood function and {f(y)k}∞k=1 must converge to some f(y∗) where y∗ is a stationary point. Thm. 7 does not imply that the sequence {wk}∞k=1({yk}∞k=1) is guaranteed to converge. [11] studies the convergence property of general CCCP procedure. Under more strong conditions, i.e., the strict concavity of the surrogate function or that Φ() to be a contraction mapping, it is possible to show that the sequence {wk}∞k=1({yk}∞k=1) also converges. However, none of such conditions hold in our case. In fact, in general there are infinitely many fixed points of Φ(·), i.e., the equation Φ(w) = w has infinitely many solutions in S. Also, for a fixed value t, if α(w) = t has at least one solution, then there are infinitely many solutions. Such properties of SPNs make it generally very hard to guarantee the convergence of the sequence {wk}∞k=1({yk}∞k=1). We give a very simple example below to illustrate the hardness in SPNs in Fig. 4. Consider applying the CCCP procedure to learn the parameters on the SPN given in Fig. 4 with three instances {(0, 1), (1, 0), (1, 1)}. Then if we choose the initial parameter w0 such that the weights over the indicator variables are set as shown in Fig. 4, then any assignment of (w1, w2, w3) in the probability simplex will be equally optimal in terms of likelihood on inputs. In this example, there are uncountably infinite equal solutions, which invalidates the finite solution set requirement given in [11] in order to show the convergence of {wk}∞k=1. However, we emphasize that the convergence of the sequence {wk}∞k=1 is not as important as the convergence of {α(w)k}∞k=1 to desired locations on the log-likelihood surface as in practice any w∗ with equally good log-likelihood may suffice for the inference/prediction task.\nIt is worth to point out that the above theorem does not imply the convergence of the sequence {w(k)}∞k=1. Thm. 7 only indicates that all the limiting points of {w(k)}∞k=1, i.e., the limits of subsequences of {w(k)}∞k=1, are stationary points of the DCP in (2). We also present a negative example in Fig. 4 that invalidates the application of Zangwill’s global convergence theory on the analysis in this case.\nThe convergence rate of general CCCP is still an open problem [11]. [16] studied the convergence rate of unconstrained bound optimization algorithms with differentiable objective functions, of which our problem is a special case. The conclusion is that depending on the curvature of f1 and f2 (which are functions of the training data), CCCP will exhibit either a quasi-Newton behavior with superlinear convergence or first-order convergence. We show in experiments that CCCP normally exhibits a fast,\nsuperlinear convergence rate compared with PGD, EG and SMA. Both CCCP and EM are special cases of a more general framework known as Majorization-Maximization. We show that in the case of SPNs these two algorithms coincide with each other, i.e., they lead to the same update formulas despite the fact that they start from totally different perspectives."
    }, {
      "heading" : "D Experiment Details",
      "text" : "D.1 Methods\nWe will briefly review the current approach for training SPNs using projected gradient descent (PGD). Another related approach is to use exponentiated gradient (EG) [10] to optimize (8). PGD optimizes the log-likelihood by projecting the intermediate solution back to the positive orthant after each gradient update. Since the constraint in (8) is an open set, we need to manually create a closed set on which the projection operation can be well defined. One feasible choice is to project on to RD , {w ∈ RD++ | wd ≥ ,∀d} where > 0 is assumed to be very small. To avoid the projection, one direct solution is to use the exponentiated gradient (EG) method[10], which was first applied in an online setting and latter successfully extended to batch settings when training with convex models. EG admits a multiplicative update at each iteration and hence avoids the need for projection in PGD. However, EG is mostly applied in convex setting and it is not clear whether the convergence guarantee still holds or not in nonconvex setting.\nD.2 Experimental Setup\nThe sizes of different SPNs produced by LearnSPN and ID-SPN are shown in Table 3.\nWe list here the detailed statistics of the 20 data sets used in the experiments in Table 4. Table 5 shows the detailed running time of PGD, EG, SMA and CCCP on 20 data sets, measured in seconds."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "We present a unified approach for learning the parameters of Sum-Product networks<lb>(SPNs). We prove that any complete and decomposable SPN is equivalent to a<lb>mixture of trees where each tree corresponds to a product of univariate distributions.<lb>Based on the mixture model perspective, we characterize the objective function<lb>when learning SPNs based on the maximum likelihood estimation (MLE) principle<lb>and show that the optimization problem can be formulated as a signomial program.<lb>We construct two parameter learning algorithms for SPNs by using sequential<lb>monomial approximations (SMA) and the concave-convex procedure (CCCP),<lb>respectively. The two proposed methods naturally admit multiplicative updates,<lb>hence effectively avoiding the projection operation. With the help of the unified<lb>framework, we also show that, in the case of SPNs, CCCP leads to the same<lb>algorithm as Expectation Maximization (EM) despite the fact that they are different<lb>in general.",
    "creator" : "LaTeX with hyperref package"
  }
}