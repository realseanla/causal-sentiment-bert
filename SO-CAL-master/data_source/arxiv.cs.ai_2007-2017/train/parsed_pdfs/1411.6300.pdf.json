{
  "name" : "1411.6300.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Discrete Bayesian Networks: The Exact Posterior Marginal Distributions",
    "authors" : [ ],
    "emails" : [ "dminh@fullerton.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Keywords: Bayesian networks; Exact inference; Border algorithm; Revised polytree algorithm; Parentless polytree method"
    }, {
      "heading" : "1 The Bayesian Networks (BNs)",
      "text" : "Consider a directed graph G defined over a set of ` nodes V = {V1, V2, ..., V`}, in which each node represents a variable. (We denote both a variable and its corresponding node by the same notation, and use the two terms interchangeably.) The pairs of nodes (Vi, Vj) may be connected by either the\nar X\niv :1\n41 1.\n63 00\nv1 [\ncs .A\ndirected edge Vi → Vj or Vj → Vi, but not both. It is not necessary that all pairs be connected in this manner. In this paper, we will first use the graph in Figure 1 as an example.\nFor node V ∈ V , we call\n1. the nodes sending the directed edges to V the “parents” of V . We denote the set of the parents of V by HV . In Figure 1, HH = {C,D}. A node is said to be a “root” if it has no parents. (For example, nodes A, B and G.)\n2. the nodes receiving the directed edges from V the “children” of V . We denote the set of the children of V by LV . In Figure 1, LD = {H, I}. A node is said to be a “leaf” if it has no children. (For example, nodes J , K and L.) We also call the parents and children of V its “neighbors.”\n3. the parents of the children of V , except V , the “co-parents” of V . We denote the set of the co-parents of V by KV = {∪η∈LVHη} \\V . (We denote by X\\Y the set {X : X ∈ X , X /∈ Y}. X\\Y = ∅ iff X ⊆ Y .) In our example, KD = {C,F}.\nThe set of edges connecting nodes Vi and Vj either directly or via other nodes Vk, ..., Vm in the form of Vi → Vk → ... → Vm → Vj is called a “ directed path” from Vi to Vj. We restrict ourselves to the “directed acyclic\ngraph” (DAG) in which there is no directed path that starts and ends at the same node. If there is a directed path from Vi to Vj, we say Vi is an “ancestor” of Vj and Vj a “descendant” of Vi. Let NV andMV be the set of all ancestors and descendants of V , respectively. In Figure 1 , NI = {A,B,D, F},MC = {H, J,K}.\nThe “Markovian assumption” of a DAG is that every variable is conditionally independent of its non-descendants given its parents. Attached to each node V ∈ V is a conditional probability distribution Pr {V |HV }. If a node has no parent, its distribution is unconditional. We assume in this paper that all V ∈ V are discrete, and all conditional probability distributions are in the form of the conditional probability tables (CPTs), taking strictly positive values. We assume that the “size” of Pr {V |HV } (that is, the number of possible values of V and HV ) is finite for all V ∈ V .\nA “Bayesian network” (BN) is a pair (G,Θ), where G is a DAG over a set of variables V = {V1, V2, ..., V`} (called the “network structure”) and Θ a set of all CPTs (called the “network parametrization”). We will refer to the DAG in Figure 1 and its parametrization the Bayesian network A, or the BN A.\nIt has been shown that the dependence constraints imposed by G and the numeric constraints imposed by Θ result in the unique joint probability distribution,\nPr {V} = Pr {V1, V2, ..., V`} = ∏ V ∈V Pr {V |HV } . (1)\nThis equation is known as the “chain rule for Bayesian networks” (Pearl, 1987, Equation 3). In our example,\nPr {A = a,B = b, C = c, ..., L = `} = Pr {A = a}Pr {B = b}Pr {C = c|A = a,B = b} ...Pr {L = `|I = i} ."
    }, {
      "heading" : "1.1 The Marginal Distribution",
      "text" : "We wish to evaluate the marginal probability Pr {Q}, in which Q ∈ V is known as a “query variable.” This probability may be conditioned on the fact that some other variables in V are observed to take certain values.\nSuppose f is a function defined over a set of variables X ⊆ V . We say the “scope” of f is X . We list out the scope if necessary, such as f (X ); if not, we simply write f (·).\nIn this paper, suppose X = {Y ,Z} ⊆ V where Y∩Z = ∅ and Y = {Y1, ..., Yn}. We express Pr {X} as Pr {Y ,Z}. Given Pr {Y ,Z}, “summing out” (or “eliminating”) Y from Pr {Y ,Z} means obtaining Pr {Z} as follows: For every fixed Z = z,∑\nY\nPr {z,Y}\n= ∑ Y1 ... ∑ Yn−1 (∑ Yn Pr {z, Y1 = y1, ..., Yn−1 = yn−1, Yn = yn} ) = ∑ Y1 ... ∑ Yn−1 Pr {z, Y1 = y1, ..., Yn−1 = yn−1}\n = Pr {z} . We write, ∑\nY\nPr {Z,Y} = Pr {Z} . (2)\nOne way to evaluate the marginal probability Pr {Vj} is to use Equation (1) to calculate the joint probability Pr {V1, ..., V`}, then sum out all variables in {V1, ..., Vj−1, Vj+1, ..., V`}. This brute-force method is known to be NPhard; that is, there is often an exponential relationship between the number of variables ` and the complexity of computations (Cooper, 1990). Thus it may be infeasible for large networks.\nThere have been many attempts in the literature to find the most efficient methods to calculate Pr {Q}. They can be divided into two broad categories: the approximate and the exact methods. One example of the approximate methods is using Gibbs samplings to generate “variates” (or “instantiations”) for V , then using statistical techniques to find an estimate for Pr {Q}. (See Pearl, 1987.) In this paper, we present a method to compute Pr {Q} exactly, apart from precision or rounding errors.\nGuo & Hsu (2002) did a survey of the exact algorithms for the BNs, including the two most well-known ones, namely the variable eliminations (Zhang & Poole, 1996; Dechter, 1999) and the clique-tree propagations (Lauritzen & Spiegelhalter, 1988; Lepar & Shenoy, 1999). Other methods reviewed were the message propagations in polytrees (Kim & Pearl, 1983; Pearl 1986a, 1986b), loop cutset conditioning (Pearl, 1986b; Dı́ez, 1996), arc reversal/node reduction (Shachter, 1990), symbolic probabilistic inference (Shachter et al., 1990) and differential approach (Darwiche, 2003). We\nalso want to mention the more recent LAZY propagation algorithm (Madsen & Jensen, 1999).\nIn this paper, we first present the border algorithm. Like the clique-tree propagation, instead of obtaining the joint probability Pr {V1, ..., V`}, the border algorithm breaks a Bayesian network into smaller parts and calculate the marginal probabilities of these parts, avoiding the exponential blow-ups associated with large networks. In the next section, we first show how a BN can be so divided, in such a way that its independency structure can be exploited. In Section 3, we explain how to calculate the marginal probability of each part when there is no observed evidence. In Section 4, we show how to calculate them, conditional on some observed evidences.\nIn Section 5, we focus on a special kind of BN called the “polytrees,” and present in details, with some modifications and within the border algorithm framework, the “revised polytree algorithm” by Peot & Shachter (1991).\nIn Section 6, we present our parentless polytree method, which, coupled with the border algorithm, can convert any BN into a polytree. This part is static, in that they need to be done only once, off-line, prior to any dialogue with a user. Then we show the dynamic, on-line part of our method, in which the conditional marginal probabilities can be calculated whenever new evidences are entered or queries posed.\nFinally, our discussions and summary are presented in Section 7."
    }, {
      "heading" : "2 Partitioning a DAG",
      "text" : "In this section, we will show how a BN can be partitioned into smaller parts."
    }, {
      "heading" : "2.1 The Set Relationships",
      "text" : "Consider a non-empty set of nodes X ⊆ V . We also call\n1. HX = {∪V ∈XHV } \\X the “parent” of X . If HX = ∅, we say X is “parentless” (or “ancestral”). For the BN A, H{A,H} = {C,D}.\n2. LX = {∪V ∈XLV } \\ {X ,HX} the “child” of X . If LX = ∅, we say X is “childless.” For the BN A, L{A,H} = {J,K}. (Although D is a child of A, it is also a parent of H; so it is a member of H{A,H}, not of L{A,H}.)\n3. KX = {∪V ∈XKV } \\ {X ,HX ,LX} the “co-parent” of X . If a child of V ∈ X is also in X , then all its parents are in {X ,HX}. Thus we are only concerned with the children of V in LX . KX therefore can also be defined as {∪V ∈LXHV } \\ {X ,LX}. For BN A, K{A,H} = {B,G, I}. If KX = ∅, we say X is “co-parentless.”"
    }, {
      "heading" : "2.2 The Growing Parentless Set",
      "text" : "Consider a parentless set P ⊆ V . It is “growing” when it “recruits” new members. There are simple algorithms in the literature that allow P to recruit a member in a “topological order” (that is, after all its parents), so that it is always parentless. (For example, Koller & Friedman, 2009, p. 1146.) Let us call D = V\\P the “bottom part” of the BN. We present here an algorithm that not only constructs a growing parentless P , but also divides P into two parts: P = {A,B}, where A is called the “top part,” and B the “border” that separates A from D. It will become clear later why we wish to keep the size of border B (that is, the number of possible values of B and HB) as small as possible.\nWe call the members of A, B and D the “top variables,” the “border variables,” and the “bottom variables”, respectively.\nFor the initial top part A, we start with A = ∅. We use a co-parentless set of roots as the initial border B. There is at least one such set of roots in a BN. (Suppose a set of roots has a non-root co-parent. Then if we trace through the ancestors of this co-parent, we must encounter another set of roots. Again, if this set is not co-parentless, we trace up further. Eventually, we must see a co-parentless set of roots in a finite BN.) In our example, none of the roots is co-parentless, but the set {A,B} is.\nAll bottom variables will eventually join P . However, we do not choose which bottom variable to join next. This method does not give us control over the membership of the top part A. Instead, we first decide which variable in B is to be “promoted” to A. The promotion of a variable B ∈ B may leave a “hole” in the border B; thus B no longer separates A from D. This necessitates recruiting some bottom variables into B to fill that hole, allowing P to grow. We call the set of the bottom variables that are recruited into border B upon the promotion of node B the “cohort” of B and denote it by C. To fill the hole, C must include at least the part of the “Markov blanket” of B (that is, all its children and co-parents) in D. C may be empty, or may be more than what we need for B to separate A and D.\nFor P to remain parentless, it is necessary that HC ⊆ P . Because all members of C are separated from A by B, C cannot have any parent in A. So we only need HC ⊆ B. Below are the many ways by which we can choose the next variable B ∈ B to promote to A, approximately in order of preference to keep the size of B small:\n1. B has no bottom children, hence no bottom co-parent. Then C = ∅.\n2. B has bottom children, but no bottom co-parent. Then C = LB ∩ D. (This is why we start B with a co-parentless set of roots.)\n3. B has bottom co-parents, which are roots or have no bottom parents. Then C = {LB ∪ KB} ∩ D. In Figure 2, variable J (having co-parent N , with HN = K /∈ D) can be promoted with cohort {N,O}. Variable H can also be promoted with cohort {M,L}, because its co-parent L is a root.\n4. B is a fictitious variable ∅, the cohort of which is a bottom variable having all parents in P . In Figure 2, we can recruit variable V (resulting in new border {K, J, I,H, V }).\n5. B is a fictitious variable ∅, the cohort of which is a bottom root. In Figure 2, we can recruit root P (resulting in new border {K, J, I,H, P}) or root S (resulting in new border {K, J, I,H, S}).\n6. B is any variable in B, the cohort of which includes not only its bottom children, but also all their bottom ancestors (hence the bottom coparents of B and perhaps some roots). In Figure 2, I can be promoted with cohort {V,W,U, S}.\n7. B is a fictitious variable ∅, the cohort of which includes any bottom variable, together with all its bottom ancestors. Unless it is necessary, the worst (but legal) strategy is to bring all bottom variables simultaneously into B.\n8. B is a fictitious variable ∅, the cohort of which is the whole parentless set P∗ ⊆ D. This is equivalent to “merging” P and P∗. In Figure 2, we can merge P = {A,B} with the parentless P∗ = {P,Q,R, S, T, U}. If P∗ has already been divided into the top part A∗ and the border B∗, then A∗ can be merged with A and B∗ with B. (This is equivalent to\nsimultaneously promoting all members of A∗ after merging P and P∗.) In Figure 2, if B∗ = {U, T}, then the new border is {K, J, I,H, U, T}.\nWe continue to use the notations such as P , A, B and D. However, we also define the initial top part as A0 = ∅, and denote the initial border, comprising of a co-parentless set of roots, by B0.\nAt “time” j ≥ 1, the variable promoted to Aj−1 (which may be a fictitious variable ∅) is re-named as Vj; the resulting top part becomes Aj. Thus, for all j ≥ 1,\nAj = {Aj−1, Vj} = {V1, ..., Vj} . (3)\nLet C0 = B0. For all j ≥ 1, the cohort associated with Vj is re-named as Cj. After promoting Vj ∈ Bj−1 and recruiting Cj, the resulting border is, for all j ≥ 1,\nBj = {Bj−1\\Vj, Cj} , (4)\nwith HCj ⊆ Bj−1. Let P0 = B0. The parentless set P grows cohort-by-cohort as, for all j ≥ 1,\nPj = {Aj,Bj} = {Aj−1, Vj} ∪ {Bj−1\\Vj, Cj} = {Pj−1, Cj} = ∪jk=0Ck. (5)\nEventually, all variables in V will join P . Let γ be the time that this happens. We call Bγ the “last” border. Then V is partitioned into disjoint sets as V = Pγ = ∪γk=0Ck.\nLet the bottom part at time j (0 ≤ j ≤ γ) be\nDj = V\\Pj = Pγ\\Pj = ∪γk=j+1Ck = {Cj+1,Dj+1} . (6)\nThe above promotion rules do not result in a unique promotion order; and we do not attempt to optimize here, so that the maximum size of all borders Bi (i = 1, 2, ..., γ) is as small as possible. We can heuristically search among all members of Bj to identify the node whose promotion leads to the smallest next border Bj+1, but this does not guarantee a global minimum. The above order of preference may help.\nWe show the results obtained by one particular promotion order for the BN A in Table 1. The last column shows the rule we use to promote Vi. The function Φ (Ci) will be introduced later.\nTo keep {Pi, i = 1, 2, ..., γ} parentless, some borders Bi may have more members than what required to separate Ai and Di. Rule 1 is useful in this case, to reduce the membership of Bi to its minimum. For example, it was used to reduce B4 = {F,H, I} to B5 = {H, I}.\nHere we construct a directed chain of possibly overlapping borders {Bi, i = 1, 2, ..., γ}, called the “border chain.” A border chain is Markovian, in the sense that the knowledge of Bj is sufficient for the study of Bj+1. Figure 3 shows the corresponding border chain for the BN A."
    }, {
      "heading" : "3 Inferences without Evidences",
      "text" : "In this section, we explain how the “prior marginal probability” Pr {Bi} can be calculated, assuming that no variable is observed taking any value."
    }, {
      "heading" : "3.1 The Parentless Set Probabilities",
      "text" : "We first present the following important lemma, which is based on a simple observation that in a BN, a parentless set of nodes and its parametrization is a Bayesian sub-network :\nLemma 1 If P ⊆ V is parentless, then Pr {P} = ∏ V ∈P Pr {V |HV } .\nProof. The lemma follows from Equation (1) For the BN A, as {A,B,D} is parentless,\nPr {A,B,D} = Pr {A}Pr {B}Pr {D|A,B} .\nWe do not use {A,B,D} however, because D alone does not separate {A,B} from the rest of the network. So for a general BN, we start with the parentless P0 = B0 = C0 and define\nΦ (C0) = Pr {P0} = Pr {B0} = Pr {C0} = ∏ V ∈B0 Pr {V } . (7)\nRecall that, when Vj is promoted, it brings a cohort Cj into Bj−1. By the Markovian assumption, we do not need the whole Pr {Cj|Pj−1}, but only Pr { Cj|HCj } with HCj ⊆ Bj−1 ⊆ Pj−1. For all 0 ≤ j ≤ γ, let us denote\nthe “cohort probability tables” Pr { Cj|HCj } by Φ (Cj). If Cj = ∅, we set Φ (Cj) = 1. Column 5 of Table 1 shows the cohort probability tables for the BN A.\nTheorem 2 For all 0 ≤ j ≤ γ,\nPr {Pj} = Φ (Cj) Pr {Pj−1} = j∏\nk=0\nΦ (Ck) .\nProof. From Equation (5),\nPr {Pj} = Pr {Pj−1, Cj} = Pr {Cj|Pj−1}Pr {Pj−1} = Pr { Cj|HCj } Pr {Pj−1} = Φ (Cj) Pr {Pj−1} .\nThe theorem follows because Pr {P0} = Φ (C0). Theorem 2 can be used to obtain the joint probability of Pj when j is small. For example,\nPr {P1} = Pr {A,B,C,D, F} = Φ (C0) Φ (C1) .\nHowever, as P grows, eventually we return to Equation (1): Pr {V} = Pr {Pγ} = ∏γ k=0 Φ (Ck), which is what we did not want to use in the first place. Fortunately, as we will see in the next section, what we have here is a very “cruel” parentless set of nodes that, after promoting and extracting information from a member, immediately “eliminates” that member!"
    }, {
      "heading" : "3.2 The Border Probabilities",
      "text" : "We now show how Pr {Bj} can be recursively calculated from Pr {Bj−1}:\nTheorem 3 For all 1 ≤ j ≤ γ, Pr {Bj} = ∑ Vj Φ (Cj) Pr {Bj−1} .\nProof. For all Pj (1 ≤ j ≤ γ), our strategy is not to eliminate all members of Aj at the same time, in the form of\nPr {Bj} = ∑ Aj Pr {Aj,Bj} = ∑ Aj Pr {Pj} = ∑ Aj Φ (Cj) Pr {Pj−1} .\nRather, we eliminate the variables in Aj one-by-one: After variable Vj is promoted into Aj = {Aj−1, Vj}, it is immediately eliminated. In other words,\nbecause the scope of Φ (Cj) (which is { Cj,HCj } ⊆ {Cj,Bj−1}) does not include any member of Aj−1, as far as the summing out of Aj−1 is concerned, Φ (Cj) can be treated as a constant:\nPr {Bj} = ∑\n{Aj−1,Vj} Φ (Cj) Pr {Pj−1} = ∑ Vj Φ (Cj) ∑ Aj−1 Pr {Aj−1,Bj−1}  , hence the theorem.\nThere must be one value of τ (0 ≤ τ ≤ γ) such that Pr {Bτ} can be calculated. At least, from Equation (7), we know Pr {B0}. Starting with Pr {Bτ}, we can calculate Pr {Bj} for all τ < j ≤ γ recursively by the above theorem.\nWe call our algorithm the “border algorithm” because it breaks the large joint probability Pr {V} down into many smaller border probabilities Pr {Bj}, thus avoiding the exponential blow-ups associated with large networks. That is why we want the size of the largest border to be as small as possible.\nWe now show how the marginal probabilities can be obtained given some evidences."
    }, {
      "heading" : "4 Inferences with Evidences",
      "text" : "For a variable V ∈ V , let Va (V ) be the set of possible values of V such that Pr {V = v|HV } > 0. A variable E is said to be an “evidence variable” if it is observed taking value only in a subset Vae (E) ⊂ Va (E). Variable V is nonevidential if Vae (V ) = Va (V ). For example, suppose Va (X) = {1, 2, 3}. If X is observed not taking value 3, then it is evidential with Vae (X) = {1, 2}. Let E be the set of all evidence variables.\nConsider set Y = {Y1, ..., Yn} ⊆ V . We denote the event that Y occurs by\n[Y ] = {Y ∈ Vae (Y1)× ...× Vae (Yn)} .\nIf Y ∩ E = ∅, [Y ] is a sure event. Thus [Y ] = [Y ∩ E ]. One of the most important tasks in analyzing a BN is to calculate Pr {Q| [E ]}, which is known as the “posterior marginal distribution” (or the “conditional marginal distribution”) of a “query variable” Q.\nFor the rest of this paper, we will show how we can first calculate the joint distribution table Pr {Q, [E ]} for all possible values of Q. This allows\nus to calculate Pr {[E ]} = ∑\nQ Pr {Q, [E ]} and then\nPr {Q| [E ]} = Pr {Q, [E ]}∑ Q Pr {Q, [E ]} = Pr {Q, [E ]} Pr {[E ]} ."
    }, {
      "heading" : "4.1 The Evidence Indicator Columns",
      "text" : "Consider a table having t rows, each row corresponding to an instantiation of a set of variables X ⊆ V . If an evidence variable E is in X , we define an “evidence indicator column” IE having size t, such that it takes value 1 if E ∈ Vae (E), and 0 otherwise. For a non-evidence variable V ∈ X , we also define the column IV having size t, all members of which are 1.\nWe will use the following notation for a set of nodes X = Y ∪ Z ⊆ V :\nIX = ∏ V ∈X IV = IY∪Z = IYIZ .\nMultiplying a table having scope X with column IX is equivalent to zeroing out the rows inconsistent with the evidences in X .\nFor the CPT Pr {V |HV }, we define its “reduced CPT” as:\nPrr {V |HV } = Pr {V |HV } IV ∪HV . (8)\nPreviously we defined the cohort probability tables Φ (Cj) = Pr { Cj|HCj } for all 0 ≤ j ≤ γ. We now define the “reduced cohort probability tables” as\nφ (Cj) = Φ (Cj) ICj∪HCj .\nThe following lemma is the evidential version of Equation (2):\nLemma 4 Given Y ,Z ⊆ V, Y ∩ Z = ∅, then with scope Z,\nPr {Z, [Y ]} = ∑ Y Pr {Z,Y} IY .\nProof. If Y ∩ E = ∅, we have Equation (2) because IY = 1 and Pr {Z, [Y ]} = Pr {Z}. Suppose Y = {Y1, ..., Yn} is observed taking value in Vae (Y1)× ...×\nVae (Yn). For every fixed Z = z, summing out Y yields:∑ Y Pr {z,Y} IY\n= ∑ Y1 ... ∑ Yn−1 (∑ Yn Pr {z, Y1 = y1, ..., Yn−1 = yn−1, Yn = yn} n∏ i=1 IYi ) = ∑ Y1 ... ∑ Yn−1 Pr {z, Y1 = y1, ..., Yn−1 = yn−1, Yn ∈ Vae (Yn)} n−1∏ i=1 IYi\n = ∑ Y1 Pr {z, Y1 = y1, Y2 ∈ Vae (Y2) , ..., Yn ∈ Vae (Yn)} IY1 = Pr {z, [Y ]} .\nWe are now ready to obtain the necessary information for the calculations of Pr {Q, [E ]}."
    }, {
      "heading" : "4.2 The Downward Pass for the Top Evidences",
      "text" : "We first consider the “top evidences” within the top part Aj, and define the following notation: For all 0 ≤ j ≤ γ, by Lemma 4,\nΠ (Bj) = Pr {Bj, [Aj]} IBj = ∑ Aj Pr {Bj,Aj} IAj∪Bj = ∑ Aj Pr {Pj} IPj . (9)\nThe following theorem is the evidential version of Theorem 3:\nTheorem 5 For all 1 ≤ j ≤ γ, Π (Bj) = ∑ Vj φ (Cj) Π (Bj−1) .\nProof. Because HCj ⊆ Pj−1, we have Pj = Cj ∪ Pj−1 = Cj ∪ HCj ∪ Pj−1. From Definition (9) and Theorem 2,\nΠ (Bj) = ∑ Aj Pr {Pj} IPj = ∑ Aj Φ (Cj) ICj∪HCj Pr {Pj−1} IPj−1\n= ∑ Aj φ (Cj) Pr {Pj−1} IPj−1 .\nFrom Equation (3), and as the scope of φ (Cj) (which is { Cj,HCj } ) is not in Aj−1,\nΠ (Bj) = ∑ Vj φ (Cj) ∑ Aj−1 Pr {Pj−1} IPj−1 = ∑ Vj φ (Cj) Π (Bj−1) .\nThere must be one value of ν (0 ≤ ν ≤ γ) such that Π (Bν) can be calculated. Let α be the first time an evidence variable is recruited into P . For all 0 ≤ j < α, Aj has no evidence and IBj = 1; thus Π (Bj) = Pr {Bj}. Aα also has no evidence and thus,\nΠ (Bα) = Pr {Bα} IBα . (10)\nStarting with Π (Bν), we can calculate Π (Bj) recursively for all ν < j ≤ γ by the above theorem.\nFor the BN A, assume E = {H = h,K = k}. Since H ∈ C3, α = 3. Thus\nΠ (B0) = Pr {B0} = Pr {A,B} ; Π (B1) = Pr {B1} = Pr {B,C,D, F} ; Π (B2) = Pr {B2} = Pr {C,D, F} ; Π (B3) = Pr {D,F,H} IH = Pr {D,F, h} .\n1. Border B4 = {F,H, I} has V4 = D and C4 = I: Π (B4) = ∑ D φ (C4) Π (B3) = ∑ D Pr {I|D,F}Pr {D,F, h}\n= ∑ D Pr {D,F, I, h} = Pr {F, I, h} .\n2. Border B5 = {H, I} has V5 = F and C5 = ∅: Π (B5) = ∑ F φ (C5) Π (B4) = ∑ F Pr {F, I, h} = Pr {I, h} .\n3. Border B6 = {I, J,K,G} has V6 = H = h and C6 = {J,K,G}:\nΠ (B6) = φ (C6) Π (B5) = Pr {J |G, h}Pr {k|I, h}Pr {G}Pr {I, h} = Pr {I, J,G, k, h} .\n4. Border B7 = {I, J,K} has V7 = G and C7 = ∅:\nΠ (B7) = ∑ G φ (C7) Π (B6) = ∑ G Pr {I, J,G, k, h} = Pr {I, J, k, h} .\n5. Border B8 = {J,K, L} has V8 = I and C8 = L:\nΠ (B8) = ∑ I φ (C8) Π (B7) = ∑ I Pr {L|I}Pr {I, J, k, h} = Pr {J, L, k, h} ."
    }, {
      "heading" : "4.3 The Upward Pass for the Bottom Evidences",
      "text" : "Moving downward border-by-border from B0 to Bj, we can only collect information about the top evidences inside Pj. To collect information about the bottom evidences inside Dj, we move upward from the last border Bγ to Bj.\nIn the downward passes, we make use of the parentless property of Pj; in the upward passes we need the fact that the border Bj separates Aj and Dj = V\\Pj. Thus, to study Dj, we do not need the information of the whole Pj, but only of Bj.\nWe first present the following lemma:\nLemma 6 For all 1 ≤ j ≤ γ,\nPr {Dj−1|Bj−1} = γ∏ k=j Φ (Ck) = Φ (Cj) Pr {Dj|Bj} .\nProof. For all 1 ≤ j ≤ γ, as both V = Pγ = {Dj−1,Pj−1} and Pj−1 are parentless, from Theorem 2,\nPr {Pγ} = γ∏ k=0 Φ (Ck) = Pr {Dj−1,Pj−1} = Pr {Dj−1|Pj−1}Pr {Pj−1}\n= Pr {Dj−1|Bj−1} j−1∏ k=0 Φ (Ck) .\nAssuming all Pr {V |HV } > 0, Pr {Dj−1|Bj−1} = γ∏ k=j Φ (Ck) = Φ (Cj) γ∏ k=j+1 Φ (Ck) = Φ (Cj) Pr {Dj|Bj} .\nWe define the following notation: For all 0 ≤ j ≤ γ − 1, by Lemma 4, Λ (Bj) = Pr {[Dj] |Bj} IBj = ∑ Dj Pr {Dj|Bj} IDj∪Bj . (11)\nSince Dγ = ∅, we also define Λ (Bγ) = IBγ . Although we write Λ (Bj), the scope of Λ (Bj) may not be the whole Bj, because Bj may have more variables than the minimal set needed to separate Aj and Dj. For example, in the BN A, while B4 = {F,H, I}, we only need {H, I} for the study of D4 = {G, J,K, L}.\nTheorem 7 For all 1 ≤ j ≤ γ, Λ (Bj−1) = ∑ Cj φ (Cj) Λ (Bj) .\nProof. From Equation (6), Dj−1 = {Cj,Dj}. From Equation (4), Bj−1∪Cj = Vj ∪ Bj. Also, if Vj 6= ∅, then its cohort Cj must include all its bottom children, or Vj ∈ HCj ⊆ Bj−1. Thus,\nBj−1 ∪ Dj−1 = Bj−1 ∪ { Cj ∪HCj } ∪ {Cj ∪ Dj}\n= Vj ∪ Bj ∪HCj ∪ {Cj ∪ Dj} = Bj ∪HCj ∪ Cj ∪ Dj.\nFrom Lemma 6, Λ (Bj−1) = ∑ Dj−1 Pr {Dj−1|Bj−1} IBj−1∪Dj−1 = ∑ {Dj ,Cj} Φ (Cj) ICj∪HCj Pr {Dj|Bj} IDj∪Bj .\nBecause the scope of φ (Cj) (which is { Cj,HCj } ⊆ {Cj,Pj−1} = Pj) is not in Dj, from Equation (6),\nΛ (Bj−1) = ∑ Cj φ (Cj) ∑ Dj Pr {Dj|Bj} IDj∪Bj = ∑ Cj φ (Cj) Λ (Bj) .\nSuppose there is a value of ω (1 < ω ≤ γ) such that Λ (Bω) can be calculated. Especially, let β be the last time an evidence variable is recruited into P . Then for all β ≤ j ≤ γ, Dj has no evidence. Hence\nΛ (Bj) = IBj for all β ≤ j ≤ γ. (12)\nStarting with Λ (Bω), we can calculate Λ (Bj) for all 0 ≤ j < ω recursively by the above lemma.\nFor the BN A, with E = {H = h,K = k}. Thus β = 6 and Λ (B8) = Λ (B7) = Λ (B6) = IK .\n1. Because B6 has cohort C6 = {J,K,G}: Λ (B5) = ∑ C6 φ (C6) Λ (B6)\n= Pr {k|h, I} ∑ G\n( Pr {G}\n∑ J Pr {J |G, h}\n) IK = Pr {k|I, h} .\n2. Because B5 has cohort C5 = ∅:\nΛ (B4) = Λ (B5) = Pr {k|I, h} .\n3. Because B4 has cohort C4 = I: Λ (B3) = ∑ C4 φ (C4) Λ (B4) = ∑ I Pr {I|D,F}Pr {k|I, h}\n= ∑ I Pr {k, I|D,F, h} = Pr {k|D,F, h} .\n4. Because B3 has cohort C3 = H = h:\nΛ (B2) = φ (C3) Λ (B3) = Pr {h|C,D}Pr {k|D,F, h} = Pr {h, k|C,D, F} .\n5. Because B2 has cohort C2 = ∅:\nΛ (B1) = Λ (B2) = Pr {h, k|C,D, F} .\n6. Because B1 has cohort C1 = {C,D, F}: Λ (B0) = ∑ C1 φ (C1) Λ (B1)\n= ∑ {C,D,F} Pr {C|A,B}Pr {D|A,B}Pr {F |A,B}Pr {h, k|C,D, F}\n= Pr {h, k|A,B} ."
    }, {
      "heading" : "4.4 The Posterior Marginal Distributions",
      "text" : "Combining the downward and upward passes yields:\nTheorem 8 For all 0 ≤ j ≤ γ,\nPr {Bj, [E\\Bj]} IBj = Π (Bj) Λ (Bj) .\nProof. By Lemma 4, because the event [E\\Bj] is the same as the event [V\\Bj] = [Aj ∪ Dj],\nPr {Bj, [E\\Bj]} IBj = Pr {Bj, [Aj ∪ Dj]} IBj = ∑ {Aj ,Dj} Pr {Bj,Aj,Dj} IBj∪Aj∪Dj\n= ∑ {Aj ,Dj} Pr {Aj,Bj}Pr {Dj|Bj} IBj∪Aj∪Dj .\nAs Dj ∩ {Aj,Bj} = ∅,\nPr {Bj, [E\\Bj]} IBj = ∑ Aj Pr {Aj,Bj} IAj∪Bj ∑ Dj Pr {Dj|Bj} IDj∪Bj  = ∑ Aj Pr {Aj,Bj} IAj∪BjΛ (Bj) .\nAs Bj ∩ Aj = ∅,\nPr {Bj, [E\\Bj]} IBj = Λ (Bj) ∑ Aj Pr {Aj,Bj} IAj∪Bj = Π (Bj) Λ (Bj) .\nCorollary 9 For node Q ∈ Bj where 0 ≤ j ≤ γ,\nPr {Q, [E\\Q]} IQ = ∑ Bj\\Q Π (Bj) Λ (Bj) .\nIf Q /∈ E , Pr {Q, [E ]} = ∑ Bj\\Q Π (Bj) Λ (Bj) .\nProof. For node Q ∈ Bj, Pr {Q, [E\\Q]} IQ = ∑ E\\Q Pr {E} IE = ∑ Bj\\Q IBj ∑ E\\Bj Pr {Bj, E\\Bj} IE\\Bj\n= ∑ Bj\\Q IBj Pr {Bj, [E\\Bj]} = ∑ Bj\\Q Π (Bj) Λ (Bj) .\nRecall that β is the last time an evidence is recruited into P , if we are looking for the “post-evidence” Pr {Q, [E\\Q]} IQ where Q ∈ Bj and β ≤ j ≤ γ, then due to Equation (12), we can find them by the downward pass alone as ∑ Bj\\Q Π (Bj) IBj = ∑ Bj\\Q Π (Bj).\nFor the BN A with E = {H = h,K = k}, by the downward pass alone we already have\nPr {B8, [E\\B8]} IB8 = Π (B8) = Pr {J, L, k, h} ; Pr {B7, [E\\B7]} IB7 = Π (B7) = Pr {I, J, k, h} ; Pr {B6, [E\\B6]} IB6 = Π (B6) = Pr {I, J,G, k, h} .\nNow with Theorem 8,\n1. Π (B5) Λ (B5) = Pr {I, h}Pr {k|I, h} = Pr {I, h, k} .\n2. Π (B4) Λ (B4) = Pr {F, I, h}Pr {k|I, h} = Pr {F, I, h, k} .\n3. Π (B3) Λ (B3) = Pr {D,F, h}Pr {k|D,F, h} = Pr {D,F, h, k} .\n4. Π (B2) Λ (B2) = Pr {C,D, F}Pr {h, k|C,D, F} = Pr {C,D, F, h, k} .\n5. Π (B1) Λ (B1) = Pr {B,C,D, F}Pr {h, k|C,D, F} = Pr {B,C,D, F, h, k} .\n6. Π (B0) Λ (B0) = Pr {A,B}Pr {h, k|A,B} = Pr {A,B, h, k} .\nA variable V ∈ V may appear in more than one borders. For example, variable I appears in B4, B5, B6 and B7. We obtain the same result regardless which of these borders we choose to marginalize.\nBorder algorithm is applicable to all BNs. In the next section, we study a special kind of BNs called the polytrees, and present in details, with some modifications and within the border algorithm framework, the “revised polytree algorithm” by Peot & Shachter (1991). This is an important section, because we will show later that, with the help of the border algorithm, any BN can be modified to become a polytree."
    }, {
      "heading" : "5 The Revised Polytree Algorithm",
      "text" : "A polytree is a BN which is “singly connected;” that is, there is only one undirected path connecting any two nodes. (From now on, “path” means “undirected path.”) The BN A in Figure 1 is not a polytree because there are 2 paths from A to H, namely A− C −H and A−D −H.\nIn other words, while we assume all BNs are acyclic (that is, they have no directed cycles), a polytree also does not have any undirected cycle (or “loop”). The BN A has loop A− C −H −D − A.\nAs an illustration, we will use the polytree as shown in Figure 4, which we will refer to as the Polytree B."
    }, {
      "heading" : "5.1 To Find the Path Connecting Two Nodes",
      "text" : "Here we present a method to identify the unique path connecting any two nodes in a polytree.\nWe strategically designate some nodes as “hubs,” and pre-load the unique\npath connecting each pair of hubs, excluding the hubs themselves. The bigger the network, the more hubs we need. For the Polytree B, let us pick nodes J and H as hubs, connected by path I −M −D − C.\nFor each node, we also pre-load the path from it to its nearest hub. For node P the path is P − I − J ; for node A the path is A−D − C −H.\nTo find the path from node X to node Y :\n1. Form the (possibly cyclic) path from X to the hub nearest to X, then to the hub nearest to Y , then to Y . For nodes P and A, this path is (P − I − J)− (I −M −D − C)− (H − C −D − A).\n2. Replace the largest loop around each hub with its furthest node. With the above path, replace loop I − J − I with node I, and loop D − C −H − C −D with node D, resulting in path P − I −M −D − A connecting nodes P and A."
    }, {
      "heading" : "5.2 The Decompositions by Nodes",
      "text" : "Node V in a polytree decomposes the polytree into two parts:\n1. PV , the parentless set including V and all the nodes that are connected to V “from above,” via its parentsHV . (In Figure 4, PD is in the shaded region.) PV has border V and the top part AV = PV \\V . Consistent with Definition (9), we define\nΠ (V ) = Pr {V, [AV ]} IV = ∑ AV Pr {PV } IPV . (13)\n2. DV , the bottom set of PV , in which all nodes are connected to V “from below,” via its children LV . Consistent with Definition (11), we define\nΛ (V ) = Pr {[DV ] |V } IV = ∑ DV Pr {DV |V } IV ∪DV . (14)"
    }, {
      "heading" : "5.3 The Decompositions by Edges",
      "text" : "So far, we focused on the nodes in a BN. Let us now consider a typical edge X → Y . While node X decomposes the polytree into PX and DX , edge X → Y also decomposes it into two parts:\n1. TX→Y , the parentless set of nodes on the parent side of edge X → Y , having border X. Not only does TX→Y include PX , but also all the nodes that connect to X from below, except those via Y . In the Polytree B, in addition to PD, TD→M also includes {N,R12, L9, L10}. Consistent with Definition (9), we define the downward message about the evidences in TX→Y that node X can send to its child Y as\nΠY (X) = Pr {X, [TX→Y \\X]} IX = ∑\nTX→Y \\X\nPr {TX→Y } ITX→Y . (15)\n2. The bottom set UX→Y = V\\TX→Y , on the child side of edge X → Y , separated from TX→Y \\X by X. Not only does UX→Y include {Y,DY }, but also all the nodes that connect to Y from above, except those via X. Hence,\nUX→Y = { Y,DY ,∪V ∈HY \\XTV→Y } . (16)\nOn the other hand, TX→Y = { PX ,∪V ∈LX\\Y UX→V } . (17)\nConsistent with Definition (11), we define the upward message about the evidences in UX→Y that node Y can send to its parent X as\nΛY (X) = Pr {[UX→Y ] |X} IX = ∑ UX→Y Pr {UX→Y |X} IX∪UX→Y . (18)\nWe will often use the following two properties related to edge X → Y in a polytree:\n1. Because two distinct parents Z and T of X have X as a common child, the two parentless sets TZ→X and TT→X must be disjoint and independent (otherwise, there are two paths from their common member to Y , via the two parents). Thus,\nPr {∪V ∈HXTV→X} = ∏\nV ∈HX\nPr {TV→X} .\n2. Because two distinct children Y and W of X have X as a common parent, the two sets UX→Y and UX→W must be disjoint and independent given X (otherwise, there are two paths from X to their common member, via the two children). Thus,\nPr {∪V ∈LXUX→V |X} = ∏ V ∈LX Pr {UX→V |X} ."
    }, {
      "heading" : "5.4 The Message Propagations in the Polytrees",
      "text" : "We now present the lemmas about the relationships among Π (X), Λ (X), ΠY (X) and ΛY (X), which are known in the literature, but are now proven within the border algorithm framework:\nLemma 10 For edge X → Y in a polytree, ΠY (X) = Π (X) ∏\nV ∈LX\\Y\nΛV (X) .\nProof. Consider the parentless PX , having border X. As in Equation (17), recruiting the childless ∪V ∈LX\\Y UX→V without promotion results in the parentless TX→Y with border X ∪V ∈LX\\Y UX→V . From Theorem 5,\nΠ ( X ∪V ∈LX\\Y UX→V ) = Π (X) Pr { ∪V ∈LX\\Y UX→V |X } IX∪V ∈LX\\Y UX→V\n= Π (X) ∏\nV ∈LX\\Y\nPr {UX→V |X} IX∪UX→V .\nNow use Rule 1 to promote the childless ∪V ∈LX\\Y UX→V without cohort, resulting in the parentless TX→Y having border X. From Theorem 5,\nΠY (X) = ∑\n∪V ∈LX\\Y UX→V\nΠ ( X ∪V ∈LX\\Y UX→V ) =\n∑ ∪V ∈LX\\Y UX→V Π (X) ∏ V ∈LX\\Y Pr {UX→V |X} IX∪UX→V .\nAs the scope of Π (X) (which is X) is not in ∪V ∈LX\\Y UX→V ,\nΠY (X) = Π (X) ∏\nV ∈LX\\Y ( ∑ UX→V Pr {UX→V |X} IX∪UX→V ) ,\nwhich is the lemma by Definition (18). This is similar to Equation (4.45) in Pearl, 1988.\nLemma 11 For edge X → Y in a polytree,\nΛY (X) = ∑ Y Λ (Y ) ∑ HY \\X Prr {Y |HY } ∏ V ∈HY \\X ΠY (V ) .\nProof. Consider the parentless TX→Y , having border X and the bottom set UX→Y . As shown in Equation (16), recruiting Y ∪V ∈HY \\X TV→Y without promotion results in the parentless PY with bottom part DY . The reduced cohort table is\nPr { Y ∪V ∈HY \\X TV→Y |X } IX∪Y ∪V ∈HY \\XTV→Y\n= Pr { Y | ∪V ∈HY \\X TV→Y , X } Pr { ∪V ∈HY \\XTV→Y |X } IX∪Y ∪V ∈HY \\XTV→Y\nBecause HY ⊆ X ∪V ∈HY \\X TV→Y , the reduced cohort table becomes\nPr {Y |HY } IY ∪HY Pr { ∪V ∈HY \\XTV→Y } I∪V ∈HY \\XTV→Y\n= Prr {Y |HY } ∏\nV ∈HY \\X\nPr {TV→Y } ITV→Y .\nFrom Theorem 7, as Y /∈ ∪V ∈HY \\XTV→Y , ΛY (X) = ∑\nY ∪V ∈HY \\XTV→Y\nPrr {Y |HY } ∏ V ∈HY \\X Pr {TV→Y } ITV→Y Λ (Y ) = ∑ Y Λ (Y ) ∑ HY \\X Prr {Y |HY } ∏ V ∈HY \\X  ∑ TV→Y \\V Pr {TV→Y } ITV→Y\n , which is the lemma by Definition (15). This is similar to Equation (4.44) in Pearl (1988).\nThe values of Π (·) and Λ (·) can be calculated from the messages as in the following lemmas:\nLemma 12 For node X in a polytree, Π (X) = ∑ HX Prr {X|HX} ∏ V ∈HX ΠX (V ) .\nProof. Consider the parentless ∪V ∈HXTV→X having border HX and the top part ∪V ∈HX {TV→X\\V }. By Definition (9),\nΠ (HX) = ∑\n∪V ∈HX {TV→X\\V }\nPr {∪V ∈HXTV→X} I∪V ∈HX TV→X\n= ∏\nV ∈HX  ∑ TV→X\\V Pr {TV→X} ITV→X  = ∏ V ∈HX ΠX (V ) .\nNow recruit X, resulting in the parentless PX = X ∪V ∈HX TV→X . Then use Rule 1 to promote HX without cohort, leaving X as the border of PX . From Theorem 5,\nΠ (X) = ∑ HX Prr {X|HX}Π (HX) = ∑ HX Prr {X|HX} ∏ V ∈HX ΠX (V ) ,\nhence the lemma, which is similar to Equation (4.38) in Pearl (1988).\nLemma 13 For node X in a polytree, Λ (X) = ∏ V ∈LX ΛV (X) .\nProof. Consider the parentless PX , having border X. Recruit the rest of the network DX = ∪V ∈LXUX→V without promotion, resulting in the bottom part ∅ with Λ (∅) = 1. From Theorem 7,\nΛ (X) = ∑\n∪V ∈LXUX→V\nPr {∪V ∈LXUX→V |X} IX∪V ∈LXUX→V Λ (∅)\n= ∏ V ∈LX ∑ UX→V Pr {UX→V |X} IX∪UX→V ,\nhence the lemma by Definition (18), which is similar to Equation (4.35) in Pearl (1988).\nOur dealing with the evidences here is slightly different to that in Peot & Shachter (1991, pp. 308-309). While we attach the indicator column IV to all Π (V ), ΠY (V ), Λ (V ) and ΛY (V ), they call it the “local evidence” ΛV (V ) and attach it to Λ (V ) only.\nCombining Lemmas 10 and 12 yields:\nTheorem 14 If node X has received the messages from all members of HX∪ {LX\\Y }, then it can send a downward message to its child Y as\nΠY (X) =  ∏ V ∈LX\\Y ΛV (X) ∑ HX ( Prr {X|HX} ∏ V ∈HX ΠX (V ) ) .\nCombining Lemmas 11 and 13 yields:\nTheorem 15 If node X has received the messages from all members of {HX\\H} ∪ LX , then it can send an upward message to is parent H as\nΛX (H) = ∑ X ( ∏ V ∈LX ΛV (X) ) ∑ HX\\H Prr {X|HX} ∏ V ∈HX\\H ΠX (V )  ."
    }, {
      "heading" : "5.5 The Collection Phase",
      "text" : "In the first phase of the revised polytree algorithm, which is known as the “collection phase,” a randomly selected node P is designated as a “pivot,” and the messages are passed (or “propagated”) to P ."
    }, {
      "heading" : "5.5.1 The Evidential Cores",
      "text" : "The “evidential core” (or EC) of a polytree is the smallest sub-polytree which contains all the evidences. In other words, it comprises of the evidence set E and all the nodes and edges on the path connecting every pair of the evidence nodes. Corresponding to a particular evidence set, the EC is a unique.\nFigure 5 shows the EC in the Polytree B, corresponding to E = {B,C,K,L4}, not including the nodes or edges in dash, such as node L1. We call it the EC B.\nA node in a polytree is said to be “inside” if it is in the EC; otherwise it is “outside.” Likewise, an edge X → Y is “inside” if both X and Y are inside; otherwise it is “outside.” A path is “inside” if all its component edges are.\nIt is important to observe that, for an outside edge X → Y , the whole EC can only be either on its parent side TX→Y , or its child side UX→Y , not both. Otherwise, being connected, the EC must include edge X → Y on the path connecting the evidences on both sides."
    }, {
      "heading" : "5.5.2 The Boundary Conditions",
      "text" : "We want to use Theorems 14 and 15 for calculating the messages along the inside edges only. However, this requires the knowledge of the boundary conditions; that is, of the messages from the outside neighbors to the inside nodes, such as from those in dash in Figure 5. So we need the following theorem:\nTheorem 16 Consider an inside node X of an EC. (a) If V ∈ HX is outside, then ΠX (V ) = Pr {V }. (b) If V ∈ LX is outside, then ΛV (X) = IX .\nProof. (a) Because the inside X is on the child side of edge V → X, so is the whole EC, and thus TV→X has no evidence, or ITV→X = 1. Hence, by Definition (15), ΠX (V ) = Pr {V } .\n(b) If V ∈ LX is outside, then because the inside X is on the parent side of edge X → V , so is the whole EC; hence UX→V has no evidence. By Definition (18), ΛV (X) = IX .\nSo, assuming that all prior probabilities Pr {V } are pre-loaded, Theorems 14 and 15 can be used without the need to calculate the messages from the outside neighbors."
    }, {
      "heading" : "5.5.3 The Message Initializations",
      "text" : "Like all polytrees, an EC has its own roots and leaves. For example, the sets of roots and leaves of the EC B are {K,A,C} and {B,L4,M}, respectively.\nBy definition of the EC, every path in it must end with an evidence node, although there are evidence nodes not at the end of a path (such as nodes C in the EC B). Also, an evidence node at the end of a path can only have one inside child or parent, otherwise the path does not end with it. If it has one child, then it is a root of the EC (such as nodes K in the EC B); if one parent, it is a leaf (such as nodes B and L4 in the EC B).\nWe initialize the message propagations in an EC as follows:\nTheorem 17 Consider an EC. (a) For an evidence root R having one inside child C, ΠC (R) = Π (R) = Pr {R} IR. (b) For an evidence leaf L, Λ (L) = IL.\nProof. (a) Because AR = PR\\R is non-evidential, Π (R) = Pr {R} IR by Definition (13). Also, because R has only one inside child C, ΛV (R) = IR for all V ∈ LR\\C. Thus ΠC (R) = Π (R) from Lemma 10.\n(b) For an evidence leaf L, DL has no evidence and thus Λ (L) = IL by Definition (14)."
    }, {
      "heading" : "5.5.4 To the Pivot",
      "text" : "In the collection phase, starting with an evidence root or leaf in the EC, we send the messages from all the inside nodes to a randomly selected inside pivot node P . At any time, if P has not received a message along an edge to or from it, we trace along the possibly many inside paths leading to this edge, and must see either an inside node that is ready to do so, or an evidence node at the end of an inside path that can send its message to P by Theorem 17.\nWe may need both Theorems 14 and 15 to send the messages along a path, because the directions may change (for example, along path B ← A → D). In the EC B in Figure 5, if we use node D as the pivot, then the collection phase includes the messages sent along paths B ← A → D, L4 ← H ← C → D and K → M ← D."
    }, {
      "heading" : "5.6 The Distribution Phase",
      "text" : "In the second phase of the revised polytree algorithm, which is known as the “distribution phase,” the messages are passed from the pivot node P to a query variable."
    }, {
      "heading" : "5.6.1 The Informed Nodes",
      "text" : "Once a node Q has received the messages from all its neighbors, we say it is “informed.” At the end of the collection phase, the pivot node is the first informed node.\nThe posterior marginal probability of an informed node can now be obtained: With the messages from all its parents, we can use Lemma 12 to calculate Π (Q); with the messages from all its children, we can use Lemma 13 to calculate Λ (Q). Pr {Q, [E\\Q]} IQ then can be calculated by Theorem 8 as Π (Q) Λ (Q). Alternatively, we can use the following theorem:\nTheorem 18 With edge Q→ Y ,\nPr {Q, [E\\Q]} IQ = ΠY (Q) ΛY (Q) .\nProof. By Theorem 8, Lemmas 13 and 10, Pr {Q, [E\\Q]} IQ = Π (Q) Λ (Q) = Π (Q) ∏ V ∈LQ ΛV (Q)\n= Π (Q) ∏ V ∈LQ\\Y ΛV (Q) ΛY (Q) = ΠY (Q) ΛY (Q) ."
    }, {
      "heading" : "5.6.2 The Inside Query Variables",
      "text" : "Let p be the number of paths connecting an inside node V with the rest of the network (that is, the number of its neighbors). If it is not the pivot, then only one of these paths leads to the pivot node P . For us to use Theorem 14 or 15 to send a message from V to P in the collection phase, V must have received the messages along all p − 1 paths, except the one leading to P . Now, in the distribution phase, once it receives a message from the informed P , it becomes informed.\nLet J be the set of all the informed nodes, which we call the “informed set.” When we sent the messages from an informed node V to an uninformed node Q, not only Q, but also all the nodes along the path from V to Q become informed. In the EC B in Figure 5, the message propagations from the informed node D to node H also make node C informed. Thus, “spreading out” from a single pivot node, the informed set forms a connected sub-polytree, in that there is a single path connecting any two informed nodes and all nodes along that path are informed."
    }, {
      "heading" : "5.6.3 The Outside Query Variables",
      "text" : "Starting from an inside pivot node, the informed set J does not have to cover the EC and can spread beyond it.\nConsider now an outside uninformed node Q. The paths starting from Q to all nodes in J must go through a unique “gate” T ∈ J ; otherwise, because J is connected, there are more than one paths connecting Q with\nan informed node via the different gates. Thus Q only needs the messages sent from T to it (in this direction) to become informed, as this has all the evidential information. All other messages sent to it along other paths are from the outside neighbors. In this manner, the informed set J spreads to Q.\nFor the Polytree B in Figure 5, suppose J = {D,C,H} and the outside node R8 is a query variable. The gate from R8 to J is C and the messages along path C ← L3 → R8 are all that are needed to make R8 informed.\nPeot & Shachter’s revised polytree algorithm has been very much neglected in the literature because not many practical BNs have this form. While they further suggested that their algorithm be applied to a general BN via “cutset conditioning,” we continue this paper by presenting a novel method to convert any BN into a polytree."
    }, {
      "heading" : "6 The Border Polytrees (BPs)",
      "text" : "In Section 2, we showed that the border algorithm “stretches” a BN into a border chain, which is a special form of the polytrees, in which each node has at most one parent and one child. For example, we stretched the BN A in Figure 1 into a border chain in Figure 3. We will now show how to convert any BN into a polytree."
    }, {
      "heading" : "6.1 Stage I: The Macro-node Polytrees",
      "text" : "Our method involves two stages: In Stage I, we partition the BN to form a polytree.\nA set of nodes is said to be “combinable” into a “macro-node” if the network remains acyclic after the combination of its members. For example, we cannot combine nodes A and H in the BN A, as this results in the directed loop {A,H} → D → {A,H}. According to Chang & Fung’s (1989) Node Aggregation Theorem, if all directed paths connecting any two nodes in a set do not contain a node outside it, then this set is combinable. Hence, set {A,C,D,H} in the BN A is.\nIf two loops in a DAG share a common node, they belong to the same “independent loop set” (ILS). If we convert all ILSs in a DAG into polytrees, then the DAG itself becomes a polytree. Because each ILS is combinable, we can combine the nodes in each for this purpose. However this may yield some\nunnecessarily large macro-nodes. Chang & Fung suggest two methods of converting an ILS into a polytree; one is a heuristic search through the space of its “feasible partitions” for the optimal node combinations, the other is what they call the “graph-directed algorithm.” Here, we propose an algorithm which is somewhat along the line of Ng and Levitt’s method for incrementally extending what they called a “layered” polytree (1994)."
    }, {
      "heading" : "6.1.1 The Isolated Loops",
      "text" : "In a DAG, let us isolate one of its loops (that is, delete all nodes outside it) and call it an “isolated loop.” Some non-root and non-leaf nodes of the DAG may now become the roots or leaves of the isolated loop. On the other hand, some roots or leaves of the former may no longer be in the latter.\nLet us label the r roots in a loop consecutively as ρ1, ..., ρr, with ρr+1 = ρ1. (See Figure 6(a).)\nLemma 19 An isolated loop has the same number of roots and leaves, and can be organized into a star shape.\nProof. Two neighboring roots cannot be in a parent-child relationship, thus must be connected from below via a leaf.\nIf there are r = 2 roots, then we need two leaves to have a loop connecting all four. However, if r > 2 and there are more than one leaves in the direct path connecting any two consecutive roots, we have a loop connecting all four, in addition to the loop connecting all r roots, which violates our isolated loop assumption. Thus with r roots, we have r leaves. Figure 6(a) shows a typical loop which is organized into a star shape.\nLet λi be the single leaf between ρi and ρi+1. Let κi,k (k = 1, ..., ni) be the ni nodes in the directed path from ρi to λi and γi,k (k = 1, ...,mi) be the mi nodes in the directed path from ρi+1 to λi.\nThere are more than one ways we can combine the nodes in an isolated loop in order to “open” it; that is, to make it a polytree. For example, we can combine all its roots after some appropriate node combinations to make path ρi → ... → λi and path ρi+1 → ... → λi having the same “length;” that is, have the same number of macro-nodes. For example, to have the polytree in Figure 6(b), we form path ρ2 → γ2,1 → {λ1, γ2,2}, so that it has the same length as path ρ1 → κ1,1 → λ1, before combining them into path {ρ1, ρ2} → {γ2,1, κ1,1} → {λ1, γ2,2}. Similarly, we can combine all its leaves.\nAnother novel method is to “fold” the loop along one of its axes, bringing together the pairs of opposite paths in order to combine them, creating an acyclic semi-star. The star must be made “symmetrical” around the chosen axis first, in that each pair of opposite paths must have the same length. The loop in Figure 6(a) is not symmetrical around axis λ2 − ρ5. To make it symmetrical, among other combinations, we may form path {ρ2, γ2,1} → γ2,2 → λ1, so that it can be combined with path ρ3 → κ3,1 → λ3. The polytree in Figure 6(c) is one possible result of folding the loop in Figure 6(a) along its axis λ2 − ρ5.\nSo it seems that we can covert a DAG into a polytree by open all loops in isolation, one-by-one in this manner. Unfortunately, this procedure generally is not correct, as this may make other loops in the same ILS cyclic. For example, if there is an additional directed path ρ2 → η → ρ3 in Figure 6(a), then combining ρ2 and ρ3 as in Figure 6(c) violates the Node Aggregation Theorem. Furthermore, these cyclic loops may not be easily identifiable.\nWe now suggest a correct and systematic way to identify and open all loops in a DAG."
    }, {
      "heading" : "6.1.2 The Parentless Polytree Method",
      "text" : "In our “parentless polytree method,” we construct a growing parentless polytree from a DAG as follows: We start with a root in the DAG and execute the following steps:\n1. While there is an un-recruited node\n(a) Recruit node τ in a topological order (that is, after all its parents {π1, ..., πp}), together with edge τ ← π1\n(b) While there is an un-recruited edge τ ← πi i. recruit edge τ ← πi\nii. isolate and open any resulted loop\n(c) End while\n(d) Go to Step 1\n2. End while\nThe growing polytree must be kept parentless, so that no directed path can return to it, and thus no directed cycle via a node outside the polytree can occur as a result of any node combinations inside the polytree.\nWhen we recruit node τ having p parents into the polytree P , we bring with it p edges τ ← πi (i = 1, ..., p), where each pair {πi, πj} is connected by at most one path. (We have no path if πi and πj are in two unconnected subsets of P .) Recruiting τ with all its parents creates at most Cp2 loops.\n“Recruiting edge τ ← πi” means adding it in the polytree. Following Ng and Levitt (1994), not only do we recruit the nodes one-at-a-time, we also recruit the edges one-at-a-time. If τ has only one parent, then with edge τ ← π1 we still have a polytree. Otherwise, after recruiting edge τ ← π2, we have at most one loop τ ← π1 − ... − π2 → τ . After opening this loop, we again have a polytree. Then edge τ ← π3 yields at most another loop via π3.... In this way, we only have to open at most p− 1 easily identifiable loops.\nIf two loops created by τ have different pairs of parents {πi, πj} and {πk, πm}, then opening one cannot make the other cyclic. So let us consider two loops having parents {πi, πj} and {πj, πk} and recruit edges τ ← πi and τ ← πj first, resulting in a loop having path πi → τ ← πj. (If P is not parentless, we may have a loop with path πi → τ → ψ instead.) If we open this loop without combining τ with any node, then when we recruit edge τ ← πk later, the resulting loop is acyclic, because path πj → τ ← πk is still in it. It is feasible not to combine leaf τ in the folding method, as we do not need the macro-node {τ, πi} to reduce the length of path τ ← πi ← ...← ρk and we can choose the symmetrical axis going through τ , so that it is not combined with any other leaf.\nBut suppose we wish to combine leaf τ with node η in the loop with {πi, πj}, and only to find out later when recruiting edge τ ← πk that loop {η, τ} → ... → πk → {η, τ} is cyclic because of the directed path η → ... → πk → τ . In this case, we “open” this loop by expand the macro-node {η, τ} to {η, ..., πk, τ}. If there is any loop in this macro-node, it has the form τ ← ... − η → ... → πk → τ and therefore is not cyclic. After recruiting all p edges, we have a polytree (without any cycle, hence is acyclic), and can return to Step 1.\nAfter recruiting all nodes and their edges in a DAG in this manner, we will have partitioned the DAG into what we call a “macro-node polytree.”\nFor illustration, let us use the BN in Figure 7, which we will refer to as the Bayesian network C, or BN C. Assume that, after forming the macro-nodes {R, T} and {B,C}, we arrive at the parentless polytree above the curved line in Figure 7(a).\n1. Recruiting node X results in loop X −U −{R, T}−V −X, which can be opened by forming the macro-node {U, V } .\n2. Recruiting node Y and then node Z results in loop Z − Y − {U, V } − X − Z, which can be opened by forming the macro-node {X, Y } .\n3. Recruiting node Q results in loop Q− {U, V } − {R, T} − S −M −Q, which can be opened by forming the macro-node {M,S, U, V } .\n4. Recruiting edges P ← {M,S, U, P} and P ← Q results in loop P − Q−{M,S, U, V }−P , which can be opened by forming the macro-node {M,S, U, V,Q} .\n5. Recruiting edge P ← N results in loop P−N−L−{M,S, U, V,Q}−P , which can be opened by forming the macro-node {N,M,S, U, V,Q} .\n6. Recruiting edges J ← P and J ← O results in loop J−P−{N,M,S, U, V,Q}− O − J , which can be opened by forming the macro-node {O,P} .\n7. Recruiting edge J ← F results in loop J − {O,P} − {B,C} − F − J , which can be opened by forming the macro-node {F,O, P} .\n8. Recruiting node H results in loop H − {F,O, P} − {B,C} − D − H, which can be opened by forming the macro-node {D,F,O, P} .\n9. Recruiting node I results in loop I −H − {D,F,O, P} − I, which can be opened by forming the macro-node {I,H} .\nWe now can apply the revised polytree algorithm to the final macro-node polytree corresponding to the BN C, as shown in Figure 7(b). However, the size of some CPTs can be large, such as\nPr {D,F,O, P |N,M,S, U, V,Q,G,B,C} = Pr {O|S, G,B,C} , (19)\nwhere O = {D,F,O, P} and S = {N,M,S, U, V,Q}. This is why we do not stop after Stage I, but continue to Stage II."
    }, {
      "heading" : "6.2 Stage II: The Border Polytrees",
      "text" : "In Stage II, we use the border algorithm, which explores the independence relationships between the individual nodes within the macro-nodes, to stretch each macro-node into a border chain, if it is not already in this form.\nA result obtained for the BN C after Stage II is shown in Figure 8. Inside a macro-node, we follow the eight rules in §2.2 for promoting a node from a border and recruiting its cohort, so that each border separates the top part of the macro-node with its bottom part. However, because not all macro-notes are parentless, we need to introduce the following additional rules:\n9. We cannot stretch a macro-node before its parents. In the BN C, we must start with the macro-node {K}, {R, T}, {G} or {A}.\n10. Macro-node Γ cannot recruit any member of its macro-node child ∆. In the macro-node S of the BN C, border {N,M,Q} is obtained from border {N,M,Q, V } by promoting V without recruiting its child Y in macro-node {X, Y }.\n11. If macro-node ∆ has parents in macro-node Γ, the entire set Γ ∩ H∆ must be together in at least one border in Γ. In the BN C, because S ∩H{X,Y } = {U, V } we form border {N,M,U, V } ⊆ S, because S ∩HO = {N,M,Q} we form border {N,M,Q} ⊆ S. Also, because O ∩H{H,I} = {D,F} and O ∩HJ = {F,O, P}, we form border {D,F,O, P} ⊆ O.\n12. Suppose we wish to promote node B ∈ Bi−1 ⊆ ∆. By Rule 10, we do not recruit LB * ∆. However, we need to recruit all un-recruited members of LB ∩∆ (that is, FB = LB ∩ DBi−1 ∩∆) and all members of HFB ⊆ V (that is, the co-parents of B), even if they are not in ∆. Assume there are r macro-nodes Γk 6= ∆ (k = 1, ..., r) such that Γk ∩ HFB 6= ∅. By Rules 9 and 11, we must have already constructed in Γk a border Bi−1,k such that {Γk ∩HFB} ⊆ B∗i−1,k = {Γk ∩H∆} ⊆ Bi−1,k. For notational advantages, we also denote Bi−1 ⊆ ∆ by Bi−1,0 or B∗i−1,0.\nWe break our procedure into two steps: (i) We first recruit to ∆ all Γk ∩H∆ (k = 1, ..., r) (which have not been recruited) to form border\nBi = Bi−1 ∪rj=1 {Γk ∩H∆} = ∪rj=0B∗i−1,j ⊇ HFB , (20)\nwhere Bi has all Bi−1,k as parents. (ii) Then we promote node B from border Bi with cohort FB ⊆ ∆ by Rule 2. Note that the entire set Γk ∩ H∆ constructed by Rule 11 must be recruited into ∆ together. This is to ensure that there is at most one edge connecting any two stretched macro-nodes. Otherwise, the main benefit of the macro-node polytrees is destroyed.\nIn the BN C, suppose we wish to promote nodeN from border {N,P} ⊂ O. Because FN = LN ∩ D{N,P} ∩ O = O, we need to recruit nodes C ∈ {B,C} ∩ HO and G ∈ {G} ∩ HO. However, Rule 11 puts {B,C} ∩ HO = {B,C} in one border and instead of C alone, we recruit the whole set {B,C}. We thus form border ∪2j=0B∗i−1,j with B∗i−1,0 = {N,P}, B∗i−1,1 = {B,C}, B∗i−1,2 = {G} before promoting N with cohort O.\n13. Rule 12 also applies when we start stretching a non-root macro-node ∆. We do not start with the nodes having parents in it, but with node V having parents only in other macro-nodes Γk 6= ∆ (k = 1, ..., r); that is, ∆ ∩ HV = ∅, and Γk ∩ HV 6= ∅. In this case we first form border Bi as in Equation (20), with Bi−1,0 = B∗i−1,0 = ∅ and with B∗i−1,k such that {Γk ∩HV } ⊆ B∗i−1,k = {Γk ∩H∆} ⊆ Bi−1,k. Then we can recruit V .\nIn the BN C, to start stretching macro-node S with node S having parents in macro-nodes {L} and {R, T}, we first form border ∪2j=1B∗i−1,j with B∗i−1,1 = HS ∩ {L} = L and B∗i−1,2 = HS ∩ {R, T} = {R, T}. We then can promote R with cohort {S, U}. If r = 1 and B∗i−1,1 = Bi−1,1, then there is no need to repeat Bi = Bi−1,1. Suppose we wish to start stretching macro-node O in the BN C by recruiting node P . Because P only has parents in S, there is no need to repeat border B∗i−1,1 = Bi−1,1 = S ∩HO = {N,M,Q}. We simply promote M to recruit P .\nAfter stretching all macro-nodes, we obtain a “border polytree” or a BP, made up of the “borders.” The variables in each border are called its “component variables.” The BP in Figure 8 is called the BP C.\nFor comparison with a undirected junction tree of the well-known “Dyspnoea” example by Lauritzen & Spiegelhalter (1988, pp. 164 and 209), we include in Figure 9(a) its macro-node and border polytrees. Figure 9(b) shows the macro-node and border polytrees of the BN A.\nLike a clique tree (or a junction tree), a BP has the “running intersection property;” that is, after a variable is recruited into border Bj, it stays in all future consecutive borders Bj+1, Bj+2,... until its promotion; then it will never be recruited again into any later borders. However, a BP is not “family preserving,” in that it is not necessary that a variable must be with all its parents in one border. Most importantly, a BP is directional, while a clique tree is not.\nThe borders in a BP generally have smaller CPTs than the macro-nodes in macro-node polytree. In the BN C, instead of the CPT as in Equation (19) involving thirteen variables, we now have Pr {D,F,O, P |B,F,O, P}, with five variables {D,F,O, P,B}. Despite their smaller CPTs, their poste-\nrior marginal probabilities still can be calculated by adapting the results in Section 4 as we will show next."
    }, {
      "heading" : "6.3 The Message Propagations in a Border Polytree",
      "text" : "There are two types of non-root borders in a BP:\n1. Bi = {Bi−1, Ci} \\Vi, obtained by following Rules 1-8 in §2.2, having Bi−1 as a single parent. (If Bi = X and Bi−1 = Y , then Ci = X, Vi = Y .)\n2. Bi = ∪rj=0B∗i−1,j, obtained by Rule 12 or 13, withHBi = {Bi−1,j, j = 0, ..., r}.\nReturning to the proofs of Lemmas 10 and 13, we see that they are still valid for the BPs. However, we need to modify Lemmas 11 and 12 according to the type of border in a BP."
    }, {
      "heading" : "6.3.1 The Downward Propagations",
      "text" : "We first modify Lemma 12:\nLemma 20 For border Bi = {Bi−1, Ci} \\Vi,\nΠ (Bi) = ∑ Vi φ (Ci) ΠBi (Bi−1) ."
    }, {
      "heading" : "If Bi is the only child of Bi−1,",
      "text" : "Π (Bi) = ∑ Vi φ (Ci) Π (Bi−1) .\nProof. Consider the parentless TBi−1→Bi with border Bi−1. Promoting Vi ∈ Bi−1 with cohort Ci yields the parentless PBi with border Bi. This because, with {Bi−1\\Vi} ⊆ TBi−1→Bi ,\nTBi−1→Bi ∪ Ci = TBi−1→Bi ∪ {Bi−1\\Vi} ∪ Ci = TBi−1→Bi ∪ Bi = PBi .\nThe lemma follows from Theorem 5. If Bi is the only child of Bi−1, by Lemma 10, ΠBi (Bi−1) = Π (Bi−1).\nLemma 21 For border Bi = ∪rj=0B∗i−1,j,\nΠ (Bi) = r∏ j=0 ∑ Bi−1,j\\B∗i−1,j ΠBi (Bi−1,j) .\nProof. Consider the parentless T i−1 = ∪rj=0TBi−1,j→Bi having border Bi−1 = ∪rj=0Bi−1,j. Because all TBi−1,j→Bi are parentless and independent, from Definitions (9) and (15),\nΠ ( Bi−1 ) = Pr { Bi−1, [ T i−1\\Bi−1 ]} IBi−1\n= Pr { ∪rj=0 { Bi−1,j, [ TBi−1,j→Bi\\Bi−1,j ]}} I∪rj=0Bi−1,j\n= r∏ j=0 Pr { Bi−1,j, [ TBi−1,j→Bi\\Bi−1,j ]} IBi−1,j = r∏ j=0 ΠBi (Bi−1,j) .\nBecause Bi−1,j\\B∗i−1,j does not have children in the bottom set {Bi,DBi}, we use Rule 1 to promote ∪rj=0 { Bi−1,j\\B∗i−1,j } without cohort to obtain the same parentless T i−1 with border Bi = ∪rj=0B∗i−1,j. From Theorem 5,\nΠ (Bi) = ∑ ∪rj=0{Bi−1,j\\B∗i−1,j} Π ( Bi−1 ) = ∑ ∪rj=0{Bi−1,j\\B∗i−1,j} r∏ j=0 ΠBi (Bi−1,j) ,\nhence the lemma. Combining Lemma 10 with above lemmas yields the following BP version of Theorem 14.\nTheorem 22 If border Bi has received the messages from all members of HBi ∪ {LBi\\Bi+1,j}, then it can send a downward message to its child Bi+1,j as\nΠBi+1,j (Bi) = Π (Bi)  ∏ W∈LBi\\Bi+1,j ΛW (Bi)  , where Π (Bi) is calculated by Lemma 20 or 21."
    }, {
      "heading" : "6.3.2 The Upward Propagations",
      "text" : "We now present the following BP versions of Lemma 11:\nLemma 23 For border Bi = {Bi−1, Ci} \\Vi,\nΛBi (Bi−1) = ∑ Ci φ (Ci) Λ (Bi) ."
    }, {
      "heading" : "If Bi is the only child of Bi−1,",
      "text" : "Λ (Bi−1) = ∑ Ci φ (Ci) Λ (Bi) .\nProof. Consider the parentless TBi−1→Bi with border Bi−1. As shown in Lemma 20, promoting Vi ∈ Bi−1 with cohort Ci yields the parentless PBi with border Bi. The lemma follows from Theorem 7.\nIf Bi is the only child of Bi−1, by Lemma 13, ΛBi (Bi−1) = Λ (Bi−1).\nLemma 24 If border Bi = ∪rj=0B∗i−1,j, then for all 0 ≤ k ≤ r,\nΛBi (Bi−1,k) = ∑\nHBi\\Bi−1,k\nΛ (Bi) ∏\nW∈HBi\\Bi−1,k\nΠBi (W) .\nProof. Consider the parentless TBi−1,k→Bi (0 ≤ k ≤ r) having border Bi−1,k. Let Ii−1,k = HBi\\Bi−1,k. We recruit ∪W∈Ii−1,kTW→Bi without promotion, resulting in the parentless T i−1 = ∪rj=0TBi−1,j→Bi having border Bi−1 = ∪rj=0Bi−1,j. From Theorem 7,\nΛBi (Bi−1,k)\n= ∑\n∪W∈Ii−1,kTW→Bi\n ∏ W∈Ii−1,k Pr {TW→Bi} ITW→Bi Λ (Bi−1)\n= ∑ Ii−1,k  ∑\n∪W∈Ii−1,k{TW→Bi\\W}\n ∏ W∈Ii−1,k Pr {TW→Bi} ITW→Bi Λ (Bi−1)  .\nBecause Bi−1 ∩ { ∪W∈Ii−1,kTW→Bi\\W } = ∅,\nΛBi (Bi−1,k)\n= ∑ Ii−1,k Λ ( Bi−1 ) ∑\n∪W∈Ii−1,k{TW→Bi\\W}\n ∏ W∈Ii−1,k Pr {TW→Bi} ITW→Bi  \n= ∑ Ii−1,k Λ ( Bi−1 ) ∏ W∈Ii−1,k  ∑ TW→Bi\\W Pr {TW→Bi} ITW→Bi  . By Definition (15),\nΛBi (Bi−1,k) = ∑ Ii−1,k Λ ( Bi−1 ) ∏ W∈Ii−1,k ΠBi (W) .\nNow use Rule 1 to promote ∪rj=0 { Bi−1,j\\B∗i−1,j } without cohort, leaving\nborder Bi = ∪rj=0B∗i−1,j. From Theorem 7, Λ ( Bi−1 ) = Λ (Bi), hence the lemma. Lemma 24 can be carried out more efficiently as\nΛBi (Bi−1,k) = ∑ Bi−1,r Π Bi−1,r Bi ... ∑ Bi−1,k+1 Π Bi−1,k+1 Bi ∑ Bi−1,k−1 Π Bi−1,k−1 Bi ... ∑ Bi−1,0 Π Bi−1,0 Bi Λ (Bi) ,\nwhere Π Bi−1,j Bi = ΠBi (Bi−1,j) for all 0 ≤ j ≤ r.\nCombining Lemma 13 with the above lemmas yields the BP version of Theorem 15:\nTheorem 25 If border Bi has received the messages from all members of {HBi\\Bi−1,k} ∪ LBi, then it can send an upward message ΛBi (Bi−1,k) to its parent Bi−1,k as in Lemma 23 or 24, in which\nΛ (Bi) = ∏ W∈LBi ΛW (Bi) .\nBoth the downward and upward passes use the reduced cohort probability tables φ (·), rather than the individual CPTs. So all Φ (·) should be calculated and pre-loaded."
    }, {
      "heading" : "6.3.3 The Border Evidential Cores",
      "text" : "A border is evidential if one of its component variables is. Let the “border evidential core” (or “border EC”) be the smallest sub-polytree which contains all the evidence variables in its borders. For the BN C, let us assume E = {B,O,Q}. Then the largest sub-polytree in Figure 8 containing all the evidence variables includes path {N,M,Q, V } → {N,M,Q} → {N,P,Q} → ... → {D,F,O, P} and path {B,C} → {B,C,G,N, P}. However, its border EC is smaller, including only path {N,P,Q} → {N,P} → {B,C,G,N, P} → {B,C,G,O, P}. For some evidence sets E , the border EC is not unique.\nA border is “inside” if it is in the border EC; otherwise it is “outside;” edge Bi − Bj is “inside” if both borders are inside; otherwise it is “outside;” a path is “inside” if all its component edges are."
    }, {
      "heading" : "6.3.4 The Boundary Conditions",
      "text" : "As in the polytrees, the calculations of the messages along an inside edge of a border EC may require the knowledge of the boundary conditions; that is, the messages to an inside border from its outside neighboring borders. However, unlike the polytree, our definition of the border ECs allows the outside borders to be evidential. (For example, borders {N,M,Q, V } or {B,F,O, P} in Figure 8 with E = {B,O,Q}.) So we need the following BP version of Theorem 16:\nTheorem 26 Consider an inside border Bi. (a) If Bi−1 ∈ HBi is outside, then ΠBi (Bi−1) = Pr {Bi−1} IBi−1. (b) If Bi+1 ∈ LBi is outside, then ΛBi+1 (Bi) = IBi.\nProof. (a) In a border polytree, assume Bi is inside, Bi−1 ∈ HBi is outside, and the outside parentless TBi−1→Bi has an evidence variable E ∈ B̃1 such that E /∈ Bi. By its definition, the border EC must include another evidence border B̃2 3 E. By the running intersection property, the path connecting B̃1 and B̃2 cannot go through Bi. Thus there are two paths connecting B̃1 and B̃2, including the one via Bi. Because this is contradictory to the polytree assumption, we must have E ∈ Bi. By the running intersection property, E ∈ Bi−1. In other words, ITBi−1→Bi = IBi−1 . By Definition (15),\nΠBi (Bi−1) = ∑\nTBi−1→Bi\\Bi−1\nPr { TBi−1→Bi } ITBi−1→Bi = Pr {Bi−1} IBi−1 .\n(b) In a border polytree, assume Bi is inside, Bi+1 ∈ LBi is outside, and the bottom part UBi→Bi+1 has an evidence variable E ∈ B̃3 such that E /∈ Bi. The border EC must include another evidence border B̃4 3 E. By the running intersection property, the path connecting B̃3 and B̃4 cannot go through Bi. Thus there are two paths connecting B̃3 and B̃4, including the one via Bi. As this is a contradiction to the polytree assumption, all evidence variables in UBi→Bi+1 must be in Bi. In other words, IUBi→Bi+1 = IBi . By Definition (18),\nΛBi+1 (Bi) = ∑\nUBi→Bi+1\nPr { UBi→Bi+1 |Bi } IBi∪UBi→Bi+1\n= ∑\nUBi→Bi+1\nPr { UBi→Bi+1|Bi } IBi = IBi ."
    }, {
      "heading" : "6.3.5 The Message Initializations",
      "text" : "Following is the BP version of Theorem 17:\nTheorem 27 Consider a border EC. (a) If BR is a root with inside child BC, then Π (BR) = ΠBC (BR) = Pr {BR} IBR. (b) If BL is a leaf, then Λ (BL) = IBL in Lemma 23 or 24.\nProof. (a) Let BR be a root of the border EC. As shown in the proof of Theorem 26(a), for all W ∈ HBR , all evidence variables in TW→BR are in the inside BR; so are all evidence variables in PBR = BR ∪W∈HBR TW→BR . Hence IPBR = IBR . From Definition (13),\nΠ (BR) = ∑ ABR Pr {PBR} IPBR = ∑ ABR Pr {ABR ,BR} IBR = Pr {BR} IBR .\nAlso, because BR has only one inside child BC , ΛW (BR) = IBR for all W ∈ LBR\\BC . Thus Π (BR) = ΠBC (BR) from Lemma 10.\n(b) Let BL be a leaf of the border EC. As shown in the proof of Theorem 26(b), for allW ∈ LBL , all evidence variables in UBL→W must be in BL; so are all evidence variables in DBL = ∪W∈LBLUBL→W . Hence IDBL = IBL . From Definition (14),\nΛ (BL) = ∑ DBL Pr {DBL|BL} IBL∪DBL = ∑ DBL Pr {DBL|BL} IBL = IBL .\nFor the border chain obtained in Section 2, recall that we denote the first time and the last time an evidence is recruited into P by α and β, respectively. We now see that the part of the border chain from α to β is its border EC, and Theorem 27 is consistent with Equations (10) and (12)."
    }, {
      "heading" : "6.3.6 The Collection Phase",
      "text" : "The inferences in a border polytree are carried out in the same manner as in a polytree: In the collection phase, we start with Theorem 27 and propagate the messages inside the border EC to an arbitrarily chosen inside pivot border.\nFor the border EC in Figure 8 with E = {B,O,Q}, suppose we pick its leaf {B,C,G,O, P} as the pivot, then the collection phase includes:\n1. By Theorem 27(a),\nΠ (N,P,Q) = Pr {N,P,Q} IQ.\n2. By Lemma 20(b) and Theorem 22, Π{B,C,G,N,P} (N,P ) = Π (N,P ) = ∑ Q Pr {N,P,Q} IQ.\n3. By Lemma 21, with the boundary conditions Π{B,C,G,N,P} (B,C) = Pr {B,C} IB and Π{B,C,G,N,P} (G) = Pr {G},\nΠ (B,C,G,N, P )\n= Π{B,C,G,N,P} (B,C) Π{B,C,G,N,P} (G) Π{B,C,G,N,P} (N,P ) = Pr {B,C} IB Pr {G} ∑ Q Pr {N,P,Q} IQ.\n4. By Lemma 20(b), at the pivot border, Π (B,C,G,O, P ) = ∑ N Pr {O|C,G,N} IOΠ (B,C,G,N, P )\n= ∑ N Pr {O|C,G,N} IO Pr {B,C} IB Pr {G} ∑ Q Pr {N,P,Q} IQ.\n(21)\nWith the initial condition Λ (B,C,G,O, P ) = IBIO, the pivot border is now informed. By Corollary 9, Pr {P, [B,O,Q]} can be calculated as∑ {B,C,G,O} Π (B,C,G,O, P ) Λ (B,C,G,O, P )\n= ∑\n{B,C,G,O} ∑ N Pr {O|C,G,N} IO Pr {B,C} IB Pr {G} ∑ Q Pr {N,P,Q} IQ.\n(22)\nIt is easy to verify that the RHS is indeed Pr {P, [B,O,Q]}. On the other hand, suppose we pick root {N,P,Q} as the pivot border, then the collection phase includes:\n1. By Theorem 27(b),\nΛ (B,C,G,O, P ) = IBIO.\n2. By Lemma 23(b), Λ (B,C,G,N, P ) = ∑ O Pr {O|C,G,N} IOΛ (B,C,G,O, P )\n= ∑ O Pr {O|C,G,N} IOIB.\n3. By Theorem 25 and Lemma 24, with the boundary conditions Π{B,C,G,N,P} (B,C) = Pr {B,C} IB and Π{B,C,G,N,P} (G) = Pr {G},\nΛ (N,P ) = Λ{B,C,G,N,P} (N,P ) = ∑ {B,C,G} Π{B,C,G,N,P} (B,C) Π{B,C,G,N,P} (G) Λ (B,C,G,N, P )\n= ∑ {B,C,G} Pr {B,C} IB Pr {G} ∑ O Pr {O|C,G,N} IO.\n4. By Theorem 25 and Lemma 23(b), at the pivot border,\nΛ (N,P,Q) = Λ (N,P ) . (23)\nWith the initial condition Π (N,P,Q) = Pr {N,P,Q} IQ, the pivot border is now informed. By Corollary 9, Pr {P, [B,O,Q]} can be found by∑ {N,Q} Π (N,P,Q) Λ (N,P,Q)\n= ∑ {N,Q} Pr {N,P,Q} IQ ∑ {B,C,G} Pr {B,C} IB Pr {G} ∑ O Pr {O|C,G,N} IO,\nwhich is the same as Equation (22)."
    }, {
      "heading" : "6.3.7 The Distribution Phase",
      "text" : "In the collection phase, the messages converge to the pivot border; so it helps to know all the evidence variables and construct the border EC before the message propagations. Introducing a new evidence may require re-calculating some messages already sent to the pivot border. On the other hand, as discussed in §5.6, the distribution phase starts when the pivot border becomes the single member of the informed set J . Introducing a new query border Q, which includes a query variable, only requires calculating the messages from the corresponding gate in J to Q, making Q informed and thus allow Pr {Q, [E\\Q]} IQ to be calculated as Π (Q) Λ (Q) by Theorem 8. There is no message re-calculation when the query variables are considered one-at-a-time.\nFor the BN C with E = {B,O,Q}, assume we wish to obtain the posterior marginal of the outside variable M . With Λ (N,P,Q) obtained in Equation (23), we can use Lemma 23 to send an upward message to border {N,M,Q} as\nΛ (N,M,Q) = ∑ P Pr {P |N,M,Q} IQΛ (N,P,Q)\nFinally, with Π (N,M,Q) = Pr {N,M,Q} IQ, Pr {M, [B,O,Q]} = ∑ {N,Q} Π (N,M,Q) Λ (N,M,Q) = ∑ {N,Q} Pr {N,M,Q} IQΛ (N,M,Q) .\nOn the other hand, if we wish to obtain the posterior marginal of the outside variable F , then we can start with Π (B,C,G,O, P ) calculated in Equation (21):\n1. Using Lemma 20, Π (B,C,O, P ) = ∑ G Π (B,C,G,O, P ) .\n2. Using Lemma 20, Π (B,F,O, P ) = ∑\nC Pr {F |B,C} IBΠ (B,C,O, P ) .\nFinally, with Λ (B,F,O, P ) = IBIO, Pr {F, [B,O,Q]} = ∑ {B,O,P} Π (B,F,O, P ) IBIO.\nIf all non-evidence variables are the query variables, the messages may be sent “asynchronously,” without a goal; that is, once a border becomes informed, it may send the messages to all of its neighbors that have not received a message from it. (See Dı́ez & Mira, 1994.) Especially in this case,\n1. If the number of children of Bi is large, then it may be advantageous to calculate Λ (Bi) = ∏ W∈LBi ΛW (Bi) first, then, for all Bi+1,j ∈ LBi in The-\norem 22, we calculate Λ (Bi) /ΛBi+1,j (Bi) instead of ∏\nW∈LBi\\Bi+1,j ΛW (Bi);\n2. If the number of parents of Bi is large, then it may be advantageous to calculate Π (HBi) = ∏ W∈HBi ΠBi (W) first, then, for all Bi−1,k ∈ HBi in\nLemma 24, we calculate Π (HBi) /ΠBi (Bi−1,k) instead of ∏\nW∈HBi\\Bi−1,k ΠBi (W)."
    }, {
      "heading" : "7 Discussions",
      "text" : "1. Our algorithm can handle what are known as the “soft evidences.” An evidence variable E is soft if Vae (E), its set of observed values, may have more than one members. In other words, the evidence indicator column IE may have more than one non-zero values. This is less restrictive than the “hard evidence” assumption normally found in other inference algorithms, which requires Vae (E) to have only one value. (See Langevin & Valtorta, 2008.) 2. All junction-tree based inferences share a worst-case complexity, which is exponential with respect to the largest clique size of the underlying undirected graph. According to Wu and Butz (2005), “Lauritzen and Spiegelhalter... were concerned with the size of the clique in the junction tree (transformed from the DAG of a BN), and they realized that their method would not be computational feasible if a large clique is present in the junction tree. The Hugin architecture has the same concern as the Lauritzen-Spiegelhalter\narchitecture, namely, the size of the clique in a junction tree. The ShaferShenoy architecture... used hypertree and Markov tree (junction tree) to describe the architecture. In [9], it was repeatedly emphasized that the efficiency and feasibility of their architecture depends on the size of the clique in a junction tree.” ([9] referred to Shafer, 1996.) Wu and Butz (2005) then showed that “the presence of a node with a large number of parents can occur in both singly connected and multiply connected BNs. Therefore, in both singly and multiply connected BNs, the computation for exact inference will be exponential in the worst case.”\nIn our algorithm, let us similarly assume that the largest border size in a border polytree is not too large. This imposes some limitations on the sizes of all cohort probability tables Φ (·), which is dependent to the numbers of parents and children, and the number of possible values of each variable V ∈ V . 3. The collection phase collects information about the evidences in the entire border polytree. It is intuitive that this process should be reduced to within the sub-polytree border EC: We only need to pass messages within it, toward its inside pivot border, starting from its evidential roots and leaves as in Theorem 27. In other words, in the collection phase, the BP is “pruned” to its border EC. As illustrated above with the BN C having E = {B,O,Q}, the collection phase to the pivot border {N,P,Q} only requires four message propagations within its border EC.\nThis message passing reduction is possible in our algorithm because we know the boundary conditions: Having a directed border polytree, we can use Theorem 26 because we can determine whether a border’s outside neighbor is its parent or child. Also, it is important that all prior marginals Pr {Bi} are pre-calculated (only once) and pre-loaded for this theorem. For example, to use Equation (21), besides the CPTs Pr {O|C,G,N} and Pr {G}, we need the prior marginals Pr {N,P,Q} and Pr {B,C}.\nIn many applications, the difference between the prior and the posterior marginals of a variable is more telling than the posterior itself, so precalculating the prior marginals should be done anyhow. Off-line, we calculate Pr {Bi} as Π (Bi) without evidence, in a topological order of the macro-nodes and of the borders inside each macro-node, using Lemma 20 (with the complete cohort probability tables Φ (·)) and Lemma 21 (with ΠBi (Bi−1,j) = Π (Bi−1,j) by Theorem 22).\nIn the collection phase, each border in a EC sends only one message toward the pivot border. Thus the time complexity of the collection phase is lin-\near with respect to the number of borders within the sub-polytree border EC. With one additional evidence, this number increases by the number of borders between it and the pivot border. If N is the sole evidence in the BN C, then the collection phase is not needed, as the pivot border {N,P,Q} is automatically informed with Λ (N,P,Q) = IN and Π (N,P,Q) = Pr {N,P,Q} IN , where Pr {N,P,Q} is pre-loaded. Thus the time complexity in the collection phase is linear with respect to the number of evidence variables. 4. Similarly, in the distribution phase, we pass messages from the growing informed set J to a query border Q. As discussed above, the propagation starts from the informed gate connecting J with Q; hence there is no need to re-visit any node inside J . In other words, in the distribution phase, the BP is “pruned” to its “query core,” which is the smallest sub-polytree that contains all the query borders. The computational complexity in the distribution phase is linear with respect to the number of borders inside the query core, which in turn is linear with the number of query variables. Again, the pre-loaded prior marginals Pr {Bi} and the directed border polytrees are essential for the boundary conditions.\nConsider the case where all non-evidence variables are the query variables. As far as we know, all junction-tree based inference architectures (including the LAZY propagation algorithm, Madsen & Jensen, 1999) require two passes through the entire network, one in each phase. Our algorithm requires one pass through the smaller border EC in the collection phase, and one pass through the entire network in the distribution phase. On the other hand, consider the case in which the single evidence variable and the single query variable are in the same border; our algorithm requires no message propagation in both phases. 5. In summary, the novel features in this paper are:\ni. The parentless polytree method (§6.1) to partition a BN into a macronode polytree, by opening the loops in an otherwise growing parentless polytree.\nii. The border algorithm to construct a directed chain from a BN (§2), or from a macro-node (§6.2).\nCombining the above two algorithms, we can convert any Bayesian network into a border polytree. The border algorithm then provides the means to propagate the downward and upward messages in a border polytree, allowing us to calculate its posterior marginal probabilities (§6.3).\nAlso, the message propagations in the distribution phase is carried out one query border at a time, within the query core sub-polytree only (§5.5).\nWith the above novel features, the time complexity of our inferences in a Bayesian network is linear with respect to the number of its evidence and query variables, regardless of the number of borders in its corresponding border polytree, or the number of its variables."
    } ],
    "references" : [ {
      "title" : "Node Aggregation for Distributed Inference in Bayesian Networks",
      "author" : [ "K. Chang", "R. Fung" ],
      "venue" : "In Proceedings of the 11th International Joint Conference on Artificial Intelligence, Detroit,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1989
    }, {
      "title" : "The computational complexity of probabilistic inference using Bayesian belief networks",
      "author" : [ "G.F. Cooper" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1990
    }, {
      "title" : "A differential approach to inference in Bayesian networks",
      "author" : [ "A. Darwiche" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2003
    }, {
      "title" : "Bucket elimination: A unifying framework for reasoning",
      "author" : [ "R. Dechter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1999
    }, {
      "title" : "Local conditioning in Bayesian networks",
      "author" : [ "F. Dı́ez" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1996
    }, {
      "title" : "Distributed inference in Bayesian networks",
      "author" : [ "F. Dı́ez", "J. Mira" ],
      "venue" : "Cybernetics and Systems,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1994
    }, {
      "title" : "A survey of algorithms for real-time Bayesian network inference",
      "author" : [ "H. Guo", "W. Hsu" ],
      "venue" : "In the joint AAAI-02/KDD-02/UAI-02 workshop on Real-Time Decision Support and Diagnosis Systems",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2002
    }, {
      "title" : "A computational model for combined causal and diagnostic reasoning in inference engines",
      "author" : [ "J.H. Kim", "Pearl J" ],
      "venue" : "Proceedings of the 8th International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1983
    }, {
      "title" : "Probabilistic Graphical Models: Principles and Techniques, Massachusetts",
      "author" : [ "D. Koller", "N. Friedman" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2009
    }, {
      "title" : "Performance evaluation of algorithms for soft evidential update in Bayesian networks: First results",
      "author" : [ "S. Langevin", "M. Valtorta" ],
      "venue" : "Scalable Uncertainty Management,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2008
    }, {
      "title" : "Local computations with probabilities on graphical structures and their applications to expert systems",
      "author" : [ "S.L. Lauritzen", "D.J. Spiegelhalter" ],
      "venue" : "Journal of the Royal Statistical Society, Series B,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1988
    }, {
      "title" : "A comparison of Lauritzen-Spiegelhalter, Hugin, and Shenoy-Shafer architectures for computing marginals of probability distributions",
      "author" : [ "V. Lepar", "P. Shenoy" ],
      "venue" : "Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1999
    }, {
      "title" : "LAZY propagation: A junction tree inference algorithm based on lazy evaluation",
      "author" : [ "A.L. Madsen", "F.V. Jensen" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1999
    }, {
      "title" : "Incremental Dynamic Construction of Layered Polytree Networks",
      "author" : [ "K. Ng", "T.S. Levitt" ],
      "venue" : "Proceedings of the Tenth Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1994
    }, {
      "title" : "A constraint-propagation approach to probabilistic reasoning",
      "author" : [ "J. Pearl" ],
      "venue" : "Proceedings of the 2nd Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1986
    }, {
      "title" : "Fusion, propagation and structuring in belief networks",
      "author" : [ "J. Pearl" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1986
    }, {
      "title" : "Evidential reasoning using stochastic simulation of causal models",
      "author" : [ "J. Pearl" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1987
    }, {
      "title" : "Probabilistic Reasoning in Intelligent Systems: Networks of Plausible Inference",
      "author" : [ "J. Pearl" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1988
    }, {
      "title" : "Fusion and propagation with multiple observations in belief networks.",
      "author" : [ "M.A. Peot", "R.D. Shachter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1991
    }, {
      "title" : "Evidence absorption and propagation through evidence reversals",
      "author" : [ "R.D. Shachter" ],
      "venue" : "Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1990
    }, {
      "title" : "Symbolic probabilistic inference in belief networks",
      "author" : [ "R.D. Shachter", "B. D’Ambrosio", "B.D. Del Favero" ],
      "venue" : "Proceedings of the 8th National Conference on Artificial Intelligence,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1990
    }, {
      "title" : "Probabilistic Expert Systems, Society for Industrial and Applied Mathematics",
      "author" : [ "G. Shafer" ],
      "venue" : null,
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1996
    }, {
      "title" : "Exploiting causal independence in Bayesian network inference",
      "author" : [ "N.L. Zhang", "D. Poole" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1996
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "In [9], it was repeatedly emphasized that the efficiency and feasibility of their architecture depends on the size of the clique in a junction tree.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 8,
      "context" : "” ([9] referred to Shafer, 1996.",
      "startOffset" : 3,
      "endOffset" : 6
    } ],
    "year" : 2014,
    "abstractText" : "In a Bayesian network, we wish to evaluate the marginal probability of a query variable, which may be conditioned on the observed values of some evidence variables. Here we first present our “border algorithm,” which converts a BN into a directed chain. For the polytrees, we then present in details, with some modifications and within the border algorithm framework, the “revised polytree algorithm” by Peot & Shachter (1991). Finally, we present our “parentless polytree method,” which, coupled with the border algorithm, converts any Bayesian network into a polytree, rendering the complexity of our inferences independent of the size of network, and linear with the number of its evidence and query variables. All quantities in this paper have probabilistic interpretations.",
    "creator" : "LaTeX with hyperref package"
  }
}