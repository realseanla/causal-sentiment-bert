{
  "name" : "1401.3900.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Decidability and Undecidability Results for Propositional Schemata",
    "authors" : [ "Vincent Aravantinos", "Ricardo Caferra", "Nicolas Peltier" ],
    "emails" : [ "Vincent.Aravantinos@imag.fr", "Ricardo.Caferra@imag.fr", "Nicolas.Peltier@imag.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "∨ or ∧ ranging over\nintervals parameterized by arithmetic variables (e.g., ∧n\ni=1 pi, where n is a parameter). The satisfiability problem is shown to be undecidable for this new logic, but we introduce a very general class of schemata, called bound-linear, for which this problem becomes decidable. This result is obtained by reduction to a particular class of schemata called regular, for which we provide a sound and complete terminating proof procedure. This schemata calculus (called stab) allows one to capture proof patterns corresponding to a large class of problems specified in propositional logic. We also show that the satisfiability problem becomes again undecidable for slight extensions of this class, thus demonstrating that bound-linear schemata represent a good compromise between expressivity and decidability."
    }, {
      "heading" : "1. Introduction",
      "text" : "Being able to solve classes of problems – possibly efficiently and elegantly – strongly depends on the language in which they are specified. This is decisive in a lot of applications of Artificial Intelligence. One language long used by humans is that of schemata. As very general characterizations of the notion of schema would be useless, we have focused on a particular class of schemata arising naturally in practice, quite expressive and (as will be shown) with “good” computational properties. These schemata are those generated by unbounded repetitions of patterns, we call them ‘iterated schemata’.\nWe motivate our approach via an example, frequently used and well-known by the AI community: circuit verification. Circuit verification problems are often modeled as sequences of propositional problems parameterized by a natural number n that encodes the size of the data (e.g., the number of bits, number of layers in the circuit, etc.). We call these sequences iterated schemata, or simply schemata. A typical example is an n-bit sequential adder circuit i.e. a circuit which computes the sum of two bit-vectors of length n. Such a circuit is built by composing n 1-bit adders. The ith bits of each operand are written pi and qi. ri is the i\nth bit of the result and ci+1 is carried over to the next bit (thus c1 = 0). We set the notations (⊕ denotes exclusive or):\nSumi(p, q, c, r) def = ri ⇔ (pi ⊕ qi)⊕ ci\nc⃝2011 AI Access Foundation. All rights reserved.\nand\nCarryi(p, q, c) def = ci+1 ⇔ (pi ∧ qi) ∨ (ci ∧ pi) ∨ (ci ∧ qi).\nThen the formula:\nAdder(p, q, c, r) def = n∧ i=1 Sumi(p, q, c, r) ∧ n∧ i=1 Carryi(p, q, c) ∧ ¬c1\nwith the constraint n ≥ 1, schematises the adder circuit (it states that r encodes the sum of p and q). Adder contains iterations ranging on intervals depending on n. If n is instantiated by a natural number then the expression reduces to a propositional formula. Therefore each instance of this schema can be solved in propositional logic. However, proving that the schema is unsatisfiable (or satisfiable) for every instance of n is much harder. This problem cannot be specified in propositional logic and, as we shall see, this is even out of the scope of first-order logic. It can be expressed in higher order logics but it is well-known that such languages are less suitable for automation (see Section 3 for details).\nSuch iteration schemata are ubiquitous in formalized reasoning. Problems over finite domains can be specified as generic propositional formulae fitting the same pattern, the parameter being the (finite but unbounded) size of the domain. Among these patterns, those corresponding to the pigeonhole principle, Ramsey theory, coloring graphs problems or constraint programming specifications such as the n-queens problem (Marriott, Nethercote, Rafeh, Stuckey, Garćıa de la Banda, & Wallace, 2008) should be mentioned. Iterated schemata are also extremely useful for the formalization of mathematical proofs, because they allow one to express infinite proof sequences, which can avoid, for instance, explicit use of the induction principle. This idea has been used, e.g., in the work of Hetzl, Leitsch, Weller, and Woltzenlogel Paleo (2008).\nIn this paper we present the first (to the best of our knowledge) thorough analysis of propositional iterated schemata. We define a logic handling arithmetic variables, indexed propositions and iterated connectives. The satisfiability problem is obviously semi-decidable in the sense that a (straightforward) algorithm exists to enumerate all satisfiable schemata (i.e. all schemata with a satisfiable instance). However the set of (unrestricted) unsatisfiable schemata is not recursively enumerable. Thus we restrict ourselves to a particular class of schemata, called bound-linear and we provide a decision procedure for this class. This procedure is based on a reduction to a very simple class of schemata, called regular, for which a tableaux-based proof procedure is presented. Then we provide some undecidability results for (rather natural) extensions of this class.\nThe rest of the paper is structured as follows.\n• In Section 2 we introduce a logic (syntax and semantics) for handling propositional schemata and we establish some of its basic properties. The propositional symbols are indexed by arithmetic expressions (e.g., pn+1) containing arithmetic variables. These variables can be either parameters (i.e. free variables), or bound variables introduced by generalized connectives of the form ∨b i=a or ∧b i=a. These connectives can be read as\n∃i ∈ [a, b] or ∀i ∈ [a, b], where a, b are arithmetic expressions possibly containing (free or bound) variables. We restrict ourselves to monadic schemata (i.e. the propositions\nare indexed by at most one expression) and to linear arithmetic expressions1. We then introduce a particular subclass of schemata, called bound-linear. Intuitively, a schema is bound-linear if every arithmetic expression occurring in it contains at most one bound variable. Furthermore, the coefficient of this variable in the expression should be ±1 (or 0). Thus expressions such as 1, n, 2n − i or i + 2 are allowed (where n is the parameter and i a bound variable), but 2i or i+ j (where i, j are both bound) are not. The coefficient of the parameter n is not constrained.\n• Section 3 contains a brief survey of existing work on propositional schemata as well as (informal) comparisons with related logics.\n• In Section 4 we introduce a simpler class of schemata, called regular, and we provide an algorithm to transform every bound-linear schema into a (sat-)equivalent regular schema.\n• In Section 5 a tableaux-based proof procedure, called stab (standing for schemata tableaux), is introduced for reasoning with propositional schemata. This proof procedure is sound and complete (w.r.t. satisfiability) and terminates on every regular schema. Together with the results in Section 4 this implies that the class of boundlinear schemata is decidable.\n• Section 6 shows that relaxing very slightly the conditions on bound-linear schemata makes the satisfiability problem undecidable. Thus this class can be seen as “canonical”, with a good trade-off between expressivity, simplicity of the definition and decidability.\n• Finally, Section 7 summarizes the results and provides some lines of future work."
    }, {
      "heading" : "2. Schemata of Propositional Formulae",
      "text" : "In this section, we introduce the syntax and semantics of propositional schemata."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "The set of linear arithmetic expressions (denoted by N ) is built as usual on the signature 0, s,+,− and on a fixed and countably infinite set of arithmetic variables V, quotiented by the usual properties of the arithmetic symbols (e.g., n + s(0) + n + s(s(s(0))) and n + n + s(s(s(s(0)))) are assumed to be equivalent). As usual, sκ(0) is denoted by κ and i + . . . + i (κ times) is κ.i. If n is an arithmetic variable we denote by N×n the set of arithmetic expressions of the form α.n + β where α, β ∈ Z (with possibly α = 0) and by Nn the set of expressions of the form n + β where β ∈ Z. Obviously Nn ⊂ N×n ⊂ N . If n+ α, n+ β ∈ Nn we write n+ α ≤ n+ β iff α ≤ β.\n1. If one of these two conditions does not hold then the satisfiability problem is trivially undecidable. For instance, the Post correspondence problem can be easily encoded into schemata with non monadic variables (Aravantinos, Caferra, & Peltier, 2009b). Similarly, if non linear arithmetic expressions are considered then the 10th Hilbert’s problem can be encoded.\nFor the sake of readability, we adopt the following conventions. Integers are denoted by Greek letters α, β, γ, δ2, natural numbers by κ or ι, arithmetic variables by i, j, k, n, propositional variables by p, q, r (with indices). Arithmetic expressions are denoted by a, b, c, d. Schemata are denoted by ϕ, ψ. Π and Γ denote generic iteration connectives ∨ or∧\n.\nDefinition 2.1 (Indexed propositions) Let P be a fixed and countably infinite set of propositional symbols. An indexed proposition is an expression of the form pa where p ∈ P and a is a linear arithmetic expression (the index ). An indexed proposition pa s.t. a ∈ Z is called a propositional variable. A literal is an indexed proposition or its negation.\nIn contrast to our previous work (Aravantinos et al., 2009b) we only consider monadic propositions, i.e. every proposition has only one index.\nDefinition 2.2 (Schemata) The set of formula schemata is the smallest set satisfying the following properties.\n• ⊤, ⊥ are formula schemata.\n• If a, b are integer expressions then a < b is a formula schema.\n• Each indexed proposition is a formula schema.\n• If ϕ1, ϕ2 are schemata then ϕ1 ∨ ϕ2, ϕ1 ∧ ϕ2 and ¬ϕ1 are formula schemata.\n• If ϕ is a formula schema not containing <, and if a, b ∈ N , and i is an arithmetic variable, then ∧b i=a ϕ and ∨b i=a ϕ are formula schemata.\nNotice that, by definition, every schema must be finite. Schemata of the form a < b, pa or ⊤,⊥ are called atoms. Schemata of the form ∧b i=a ϕ and ∨b i=a ϕ are called iterations, a and b are the bounds of the iteration and b− a is its length (notice that b− a may contain variables). A schema is an arithmetic formula iff it contains no iteration and if every atom occurring in it is of the form ⊤,⊥ or a < b. In particular, every boolean combination of arithmetic atoms is a schema. a ≤ b (or b ≥ a) and a = b are used as abbreviations for ¬(b < a) and ¬(b < a) ∧ ¬(a < b) respectively. As for arithmetic expressions, arithmetic formulae are taken up to arithmetic equivalence, e.g., n = 1 and n < 2∧n > 0 are considered identical. The usual priority rules apply to disambiguate the reading of formula schemata. Analogously to first-order logic quantifiers, the iteration operators have the highest priority (e.g., ∧n i=1 pi ∨ pn ∧ ¬p1 should be read as ( ∧n i=1 pi) ∨ (pn ∧ ¬p1)). Example 2.3\nϕ = q1 ∧ n∧\ni=1 pi+2n ∧ 2n+1∨ j=n (¬qn−j ∨ qj+1)  ∧ n ≥ 0 is a formula schema. q1, pi, qj and qj+1 are indexed propositions. ∧n i=1 ( pi+2n ∧ ∨2n+1 j=n (¬qn−j ∨ qj+1)\n) and∨2n+1\nj=n (¬qn−j ∨ qj+1) are the only iterations occurring in S.\n2. This slightly unusual convention is used to avoid confusion between arithmetic variables and integers.\nRemark 2.4 Notice that the arithmetic atoms of the form a < b can only occur outside the iterations, i.e. n ≥ 1 ⇒ ∨n i=1 pi is allowed, but neither ∨n i=1(i ≤ 3 ∨ pi) nor ∨n i=1(n ≥ 1 ⇒ pi). This restriction is only used to simplify technicalities. As we shall see in Definition 2.5 (semantics of schemata), an arithmetic atom of the form a < b is equivalent to the schema ∨b i=a+1⊤.\nA variable i is bound in ϕ if ϕ contains an iteration of the form Πbi=aψ (Π ∈ { ∨ , ∧ }), it is free (or is a parameter of ϕ) if it has an occurrence in ϕ which is not in the scope of an iteration Πbi=aψ. From now on, we assume that no variable is simultaneously free and bound in a schema ϕ (thus schemata such as pn ∧ ∨10 n=1 ¬pn are not well-formed) and that if Πbi=aψ and Γ d j=cψ ′ (where Π,Γ ∈ { ∨ , ∧ }) are two distinct iterations occurring in ϕ then i and j are distinct.\nA substitution is a function mapping every arithmetic variable to a linear arithmetic expression. We write [a1/i1, . . . , aκ/iκ] for the substitution mapping respectively i1, . . . , iκ to a1, . . . , aκ. The application of a substitution σ to a schema (or arithmetic expression) ϕ is defined as usual and denoted by ϕσ. Notice that if a is an arithmetic expression and σ a substitution mapping every variable in a to a ground term (i.e. a term with no variable) then aσ is an integer (since we identify, e.g., 2− 1 and 1).\nThe previous notation is also used to denote the replacement of subexpressions: If ϕ is a schema, ψ is an expression (schema or arithmetic expression) occurring in ϕ and ψ′ is an expression of the same type as ψ, then ϕ[ψ′/ψ] denotes the formula obtained by replacing all the occurrences of ψ in ϕ by ψ′."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "An interpretation of the schemata language is a function mapping every integer variable to an integer and every propositional variable to a truth value T or F. If I is an interpretation and σ a substitution, we denote by Iσ the interpretation defined as follows: Iσ and I coincide on every propositional variable and for every variable n, Iσ(n) def= I(nσ). Consider for instance the following interpretation I:\nn 7→ 5 m 7→ 2 p1 7→ T p2 7→ F p3 7→ F p4 7→ F\nand whose definition is unsignificant for other (integer or propositional) variables. Let also be σ the substitution {n 7→ n− 1,m 7→ m− 2}. Then Iσ is:\nn 7→ 4 m 7→ 0 p1 7→ T p2 7→ F p3 7→ F p4 7→ F\nIf I is an interpretation, we denote by σI the restriction of I to V, i.e. the substitution mapping every variable n to I(n). If a is an arithmetic expression, we denote by JaKI the expression aσI . Since aσI is ground, it is (equivalent to) an integer.\nDefinition 2.5 (Semantics) The truth value JϕKI of a propositional schema in an interpretation I is inductively defined as:\n• J⊤KI = T, J⊥KI = F • Ja < bKI = T iff JaKI < JbKI . • JpaKI = I(pJaKI ) for p ∈ P. • J¬ΦKI = T iff JΦKI = F. • JΦ ∨ Φ′KI = T iff JΦKI = T or JΦ′KI = T. • JΦ ∧ Φ′KI = T iff JΦKI = T and JΦ′KI = T. • J∨bi=a ϕKI = T iff there is an integer α s.t. JaKI ≤ α ≤ JbKI and JϕKI[α/i] = T. • J∧bi=a ϕKI = T iff for every integer α s.t. JaKI ≤ α ≤ JbKI : JϕKI[α/i] = T.\nA schema ϕ is satisfiable iff there is an interpretation I s.t. JϕKI = T. I is called a model of ϕ (written I |= ϕ). Two schemata ϕ, ψ are equivalent (written ϕ ≡ ψ) iff I |= ϕ ⇔ I |= ψ. ϕ and ψ are sat-equivalent (written ϕ ≡S ψ) iff ϕ and ψ are both satisfiable or both unsatisfiable.\nIn the following, we assume that for every free variable n in ϕ and for every model I of ϕ, I(n) ∈ N. This can be ensured by explicitly adding the arithmetic atom n ≥ 0 to ϕ3.\nLet S be the following system of rewrite rules:\n3. Thus we assume that parameters are mapped to natural numbers. This convention is convenient because it allows one to use mathematical induction on the parameters (see Section 5.2). It is not restrictive since a schema ϕ where n ∈ Z could be replaced by the (equivalent) disjunction of the schemata ϕ ∧ n ≥ 0 and ϕ[−m/n] ∧m ≥ 0 (i.e. in the case in which n is negative, every occurrence of n is simply replaced by −m).\nS =  ∨β i=α ϕ → ⊥ if α, β ∈ Z, β < α∧β i=α ϕ → ⊤ if α, β ∈ Z, β < α∨β i=α ϕ → ( ∨β−1 i=α ϕ) ∨ ϕ[β/i] if α, β ∈ Z, β ≥ α∧β\ni=α ϕ → ( ∧β−1 i=α ϕ) ∧ ϕ[β/i] if α, β ∈ Z, β ≥ α\nFor instance the following formula:\n¬p1 ∧ 3∧\ni=1\n(pi ⇒ pi+1)\nis rewritten into:\n¬p1 ∧ (p1 ⇒ p2) ∧ (p2 ⇒ p3) ∧ (p3 ⇒ p4) Notice that no rule of S applies on ¬p1∧ ∧n\ni=1(pi ⇒ pi+1) as the upper bound of the iteration contains a parameter. S is actually designed to be used only on schemas whose parameters have been instantiated by a number.\nProposition 2.6 S is convergent and preserves equivalence."
    }, {
      "heading" : "Proof",
      "text" : "Termination is immediate since the length of an iteration strictly decreases at each step. Confluence is obvious since the critical pairs are trivially joinable. The fact that the obtained schema is equivalent to the original one is a straightforward consequence of Definition 2.5.\nWe denote by ϕ↓S the (unique) normal form of ϕ. If σ is a substitution mapping every free variable in ϕ to a natural number, ϕσ↓S is called a propositional realization of ϕ.\nIt is trivially semi-decidable to know if a schema is satisfiable:\nProposition 2.7 The set of satisfiable schemata is recursively enumerable."
    }, {
      "heading" : "Proof",
      "text" : "By Definition 2.5, for every interpretation I and for every schema ϕ, we have (I |= ϕ) ⇔ (I |= ϕσ), where σ = σI . Thus ϕ is satisfiable iff there exists a substitution σ such that ϕσ is satisfiable. We now prove that there exists an algorithm for checking the satisfiability of ϕσ. By Proposition 2.6, we have ϕσ ≡ ϕσ ↓S . By definition of σ, ϕσ contains no free variable. Let Πbi=aϕ be an outermost iteration in ϕ. By definition a and b must be ground, thus one of the rules in S applies which is impossible. Thus ϕσ ↓S contains no iteration hence ϕσ↓S is a propositional formula (in the usual sense) built on the set of propositional variables. Consequently, there exists an algorithm to check whether the formula ϕσ↓S≡ ϕσ is satisfiable or not. Since the set of ground substitutions is recursively enumerable, and since ϕ is satisfiable iff ϕσ is satisfiable for at least one substitution σ, this implies that it is semi-decidable to check whether ϕ is satisfiable or not.\nFor every schema ϕ and for every substitution σ we denote by [ϕ]σ the formula ϕσ↓S . For every arithmetic expression a (possibly containing bound variables) in a schema ϕ, we compute an interval [minϕ(a),maxϕ(a)] where minϕ(a),maxϕ(a) are arithmetic expressions only containing variables that are free in ϕ. The intuition is that a always “belongs” to this interval. Lemma 2.8 formalizes this property.\n• If a is an integer or a variable that is free in ϕ then minϕ(a) def = maxϕ(a) def = a.\n• If a is of the form b+ c then minϕ(a) def = minϕ(b)+minϕ(c) and maxϕ(a) def = maxϕ(b)+\nmaxϕ(c).\n• If a is of the form −b then maxϕ(a) def = −minϕ(b) and minϕ(a) def = −maxϕ(b).\n• If i is a bound variable, occurring in an iteration of the form Πbi=aϕ then minϕ(i) def =\nminϕ(a) and maxϕ(i) def = maxϕ(b).\nA ground substitution σ′ is a ϕ-expansion of another ground substitution σ for a subschema ψ in ϕ iff for every variable i that is bound in ψ, σ′(i) ∈ [σ(minϕ(i)), σ(maxϕ(i))] (since σ, σ′ are ground, the expressions σ′(i), σ(minϕ(i)), σ(maxϕ(i)) are considered as integers). The intuition behind ϕ-expansions is the following: A substitution σ does not affect the bound variables of a schema; so the values given by σ to such bound variables are unsignificant; on the contrary, the definition of a ϕ-expansion σ′ imposes that:\n1. the value given to a variable i bound in ϕ indeed falls in the set of values that i can take in the context of ϕ ;\n2. the value given by σ′ to a variable free in ϕ is the same as the one given by σ.\nW.r.t. substitution application, there is no difference between σ and σ′. The next lemma shows the importance of ϕ-expansions.\nLemma 2.8 Let ϕ be a schema and let i be a variable (possibly bound) occurring in ϕ. The expressions minϕ(i) and maxϕ(i) are well-defined. Moreover, for every ground substitution σ and for all atoms pα occurring in [ϕ]σ there exist an atom pa occurring in ϕ and a ϕ-expansion σ ′ of σ for pa s.t. σ ′(a) = α."
    }, {
      "heading" : "Proof",
      "text" : "This is an immediate consequence of Definition 2.5 (by a straightforward induction on the depth of the schema).\nWe write IC (ϕ) (standing for “Interval Constraints”) for the conjunction of arithmetic constraints of the form minϕ(i) ≤ i ∧ i ≤ maxϕ(i) where i is a variable that is bound in ϕ. IC (ϕ) can be extended to sets of schemata by handling them as conjunctions.\nConsider, e.g., ϕ = p0 ∧ ∧n−1\ni=1 (pi+1 ∧ ¬qi). We have: minϕ(i) = 1 and maxϕ(i) = n− 1. Consider furthermore σ = {n 7→ 4} and pα = p3. Then we can take pa = pi+1 (which indeed occurs in ϕ) and σ′ = {n 7→ 4, i 7→ 2}.\nWe see informally the use of ϕ-expansions: they allow, in some sense, to make the connection between a propositional variable occurring in the instance of a schema and the indexed proposition where it “comes from”."
    }, {
      "heading" : "2.3 The Class of Bound-Linear Schemata",
      "text" : "As we shall see (in, e.g., Theorem 6.2) the satisfiability problem is undecidable for schemata. In order to characterize a decidable subclass, we introduce the following definition:\nDefinition 2.9 A schema ϕ is bound-linear iff the following conditions hold:\n1. ϕ contains at most one free arithmetic variable n (called the parameter of ϕ).\n2. Every non arithmetic atom in ϕ is of the form pα.n+β.i+γ where p ∈ P and i is a bound variable, α, γ ∈ Z and β ∈ {−1, 0, 1}.\n3. If Πbi=aψ is an iteration in ϕ (where Π ∈ { ∨ , ∧ }) then a, b are respectively of the form\nα.n+β and γ.n+ δ+ ϵ.j where α, β, γ, δ ∈ Z, ϵ ∈ {−1, 0, 1} and j is a bound variable.\nThis class is comprehensive enough with respect to decidable satisfiability. The key point is that all the indices and iteration bounds contain at most one bound variable. Furthermore, the coefficient of this variable must be 1 (or 0)."
    }, {
      "heading" : "2.4 Expressiveness of Bound-Linear Schemata",
      "text" : "In order to show evidence that the class of bound-linear schemata is not an artificial or too narrow one, we provide in this section some examples of problems that can be naturally encoded into bound-linear schemata.\nIt is easy to check that the schema Adder(p, q, c, r) defined in the Introduction (formalizing a sequential adder) is bound-linear. Various properties of this circuit can be encoded. For instance, the following schema checks that 0 is a (left) neutral element:\n(Adder(p, q, c, r) ∧ n∧\ni=1\n¬pi) ⇒ n∧\ni=1\n(ri ⇔ qi)\nThe schema below checks that the adder is a function i.e. that the sum of two operands is unique.\n(Adder(p, q, c, r) ∧Adder(p, q, c′, r′)) ⇒ n∧\ni=1\n(ri ⇔ r′i)\nThe next one checks that it is commutative:\n(Adder(p, q, c, r) ∧Adder(q, p, c′, r′)) ⇒ n∧\ni=1\n(ri ⇔ r′i)\nMany similar circuits can be formalized in a similar way, such as a carry look-ahead adder (a faster version of the n-bit adder that reduces the amount of time required to compute carry bits):\nCLA-Adder(p, q, c) def = n∧ i=1 (ri ⇔ ((pi ⊕ qi)⊕ ci)) ∧ n∧ i=1 (ci+1 ⇔ (pi ∧ qi) ∨ (ci ∧ (pi ∨ qi)))\nThe equivalence of the two definitions is encoded as follows:\n(Adder(p, q, c, r) ∧ CLA-Adder(p, q, c′, r′)) ⇒ n∧\ni=1\n(ri ⇔ r′i)\nComparison between two natural numbers can easily be formalized, e.g. rn holds iff p ≥ q:\nr0 ∧ n∧\ni=1\n(ri ⇔ (ri−1 ∧ (pi ⇔ qi) ∨ pi ∧ ¬qi))\nBy composing the previous schemata, any (quantifier-free) formula of Presburger arithmetic can be encoded.\nMore generally, one can formalize every circuit composed by serially putting together n layers of the same basic circuit. These circuits are usually defined inductively, which can be easily encoded into our formalism with a formula of the form:\n(p0 ⇔ ϕbase) ∧ n−1∧ i=0 (pi+1 ⇔ ϕind),\nwhere ϕbase and ϕind are the formulae corresponding to the base case and inductive case, respectively. ϕind contains some occurrences of pi and encodes the basic circuit to be composed in sequence. Of course, for most complex circuits, pi may be replaced by a vector of bits pi, qi, ri defined inductively from the pi−1, qi−1, ri−1,. . . . Such inductively-defined circuits appear very frequently in practice (Gupta & Fisher, 1993).\nIf the index of the proposition denotes the time, then various finite state sequential systems can be encoded. The state of the system is described by a set of propositional variables, and pi encodes the value of p at step i. The parameter n denotes the number of steps in the transformation (which is assumed to be finite but unbounded). The transition function from state i to i + 1 can easily be formalized by a bound-linear schema. For instance, the inclusion of two automata can be encoded (the parameter being the length of the run). We provide another example. Consider a register with three cells p, q, r and assume that there are two possible actions rl and rr that rotate the values of the cells to the left and to the right respectively. The behavior of this system is modeled by the following schema (the propositions rli and rri indicate which action is applied at step i). First L(i) expresses the state of the registers at time i depending on their state at time i − 1, when rli has been applied to it:\nL(i) ≡ rli ⇒ ((pi ⇔ qi−1) ∧ (qi ⇔ ri−1) ∧ (ri ⇔ pi−1))\nThen R(i) is similar for rr:\nR(i) ≡ rri ⇒ ((pi ⇔ ri−1) ∧ (qi ⇔ pi−1) ∧ (ri ⇔ qi−1))\nFinally, we state that this holds at any time:\nϕn ≡ n∧\ni=1\nL(i) ∧ n∧\ni=1\nR(i)\nWe can then express properties on such registers. For instance, the following formula states that n rotations to the right followed by n rotations to the left are equivalent to identity:\n(ϕ2n ∧ n∧\ni=1\nrri ∧ 2n∧\ni=n+1\nrli) ⇒ (p0 ⇔ p2n) ∧ (q0 ⇔ q2n) ∧ (r0 ⇔ r2n)"
    }, {
      "heading" : "3. Related Work",
      "text" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of ‘proof skeleton’, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system. Pragmatically, schemata have been successfully used, e.g., in solving open questions in equivalential calculus (i.e. the field of formal logic concerned with the notion of equivalence) with the theorem-prover Otter (Wos, Overbeek, Lush, & Boyle, 1992). However, to the best of our knowledge, the formal handling of such schemata at the object level has never been considered. Although the notion of ‘schema’ is recognized as an important one, it deserves more applied works in our opinion. Sometimes schemata are not sufficiently emphasized, e.g., in the work of Barendregt and Wiedijk (2005) a nice and deep analysis about the challenge of computer mathematics is given. The authors overview the state of the art (by describing and comparing most powerful existing systems in use) but structuring proofs is not explicitly mentioned (maybe this feature can be included in what they call “mathematical style” or “support reasoning with gaps”). In our approach to schemata it is clear that they are a way of structuring proofs and can also help to overcome one of the obstacles to the automation of reasoning pointed out by Wos (1988), i.e. the size of deduction steps.\nThere exist term languages expressive enough to denote iteration schemata as those introduced in Definition 2.2: In particular, term schematisation languages can be used to denote infinite sequences of structurally similar terms or formulae. For instance the primal grammar (Hermann & Galbavý, 1997) f̂(n) → (p(n) ∨ f̂(n− 1)), f̂(0) → ⊥ denotes the iteration ∨n i=1 pi. It is worth mentioning that this iteration cannot be denoted by other term schematisation languages (Chen, Hsiang, & Kong, 1990; Comon, 1995) because the inductive context is not constant. However, term schematisation languages do not allow to reason on such iterations (they are only useful to represent them).\nEncoding schemata into first-order logic is a very natural idea, interpreting iterated connectives as bounded quantifiers. Additional axioms can be added to express arithmetic properties if needed. For instance the schema ( ∨n i=1 pi) ∧ ( ∧n i=1 ¬pi) can be encoded by ∃i.(1 ≤ i ∧ i ≤ n ∧ p(i)) ∧ ∀i.(1 ≤ i ∧ i ≤ n ⇒ ¬p(i)) which is obviously unsatisfiable. However, since inductive domains cannot be defined in first-order logic, such a translation necessarily introduces some unintended interpretations hence does not yield a complete procedure (satisfiability is not always preserved, although the unsatisfiability of the obtained formula necessarily entails the unsatisfiability of the original one). For instance, the schema p0∧ ∧n i=1(pi−1 ⇒ pi)∧¬pn is translated into p(0)∧∀i.(1 ≤ i∧i ≤ n∧p(i−1) ⇒ p(i)∧¬p(n)),\nwhich is actually satisfiable (we do not know that n ∈ N and there is no way to express this property). In order to obtain an unsatisfiable formula, some inductive axioms must be added to allow (necessarily restricted) applications of the induction principle. In this particular case, the proof can be obtained by a simple induction on i using the inductive lemma ∀i.(i ≤ n ⇒ p(i)), thus we could add the axiom: [q(0)∧∀i.(q(i) ⇒ q(i+1))] ⇒ ∀i.q(i) where q(i) ≡ i ≤ n ⇒ p(i). With this axiom, it is easy to check that the previous formula becomes unsatisfiable. However, in the general case it is hard to determine a priori the right axiom (if there is one). Actually the termination proof in Section 5 implicitly provides a way to determine candidate axioms (for the particular class of regular schemata): every looping node in the tableaux constructed by the proof procedure stab (see Section 5) corresponds to an application of the induction principle, hence to an induction axiom. The termination proof precisely shows that the size of these inductive lemmata is bounded, thus the whole set of potential induction axioms could be in principle computed and added to the formula before the beginning of the search. But the practical interest of this transformation is obviously highly questionable.\nSeveral procedures have been designed for proving inductive theorems, (Boyer & Moore, 1979; Bouhoula, Kounalis, & Rusinowitch, 1992; Comon, 2001; Bundy, van Harmelen, Horn, & Smaill, 1990; Bundy, 2001). Since schemata can be seen as an “explicit way” of handling mathematical induction, using such proof procedures for proving them is a very natural idea. In general, induction is used to define terms (e.g., recursive functions operating on inductive data structures), whereas in our case the formulae themselves are defined inductively. Obviously this problem could be solved by using an appropriate encoding of the formulae. However there are very few decidability results in inductive theorem proving and known classes (Giesl & Kapur, 2001) are not expressive enough to encode propositional schemata. Notice that most systems concentrate on universal quantifications, where we have to handle both iterated conjunctions (which can be interpreted as universal quantification on a finite domain) and iterated disjunctions (i.e. the analogous of existential quantifications). Adding existential quantification in inductive theorem proving is known to be a difficult problem. Most inductive theorem provers are designed to prove universal theorems of the form ∀x⃗.ψ where ψ is a quantifier-free formula (usually a clause) and the variables in x⃗ range over the set of (finite) terms. In our context, ψ would contain finite quantification (over intervals constrained by n), corresponding to the iterated connectives. In particular, schemata may have several models, thus implicit induction (Comon, 2001) (which explicitly requires that the underlying Herbrand model is unique) cannot be (directly) used.\nOf course, these problems can be overcome by encoding interpretations as terms (for instance by vectors or ordered lists of truth values) and schemata as functions mapping every interpretation to a truth value. Then inductive theorem provers may be used to prove inductive properties of these functions (showing for instance that their value is ⊥ for every interpretation). However these provers are not complete (due to well-known theoretical limitations) thus the practical interest of this encoding is unclear. For instance, we have tried to use the theorem prover acl2 to prove the validity of some of the benchmarks considered in Section 5, but it fails on all non trivial examples. We conjecture that this is not only due to efficiency problems, but that additional inductive lemmata are needed, which are very hard to determine in advance.\nThe above definitions should also remind the reader of fixed point logics. Indeed iterated schemata are obviously particular cases of fixed points, e.g., the schema ∧n i=1 pi might be represented as (µX(i).i ≤ 0∨(p(i)∧X(i−1)))(n). The “standard” fixed point logic is the (propositional) modal µ-calculus (Bradfield & Stirling, 2007) in which many temporal logics can be encoded, e.g., LTL or CTL. However the involved logic is very different from ours and actually simpler from a theoretical point of view. Indeed modal µ-calculus is decidable (and thus complete) whereas – as we shall see in Section 6 – iterated schemata are not (nor are they complete). Furthermore, our language allows one to use complex (though carefully restricted) arithmetic operations in the definition of the iterations, both in the indices and in the bounds. For instance we may relate the truth values of two propositions whose index are arbitrary far from each other (such as pi and pn−i). As far as we are aware, these operations cannot be directly encoded into propositional µ-calculus.\nActually iterated schemata share much more with least fixpoint logic, or LFP (Immerman, 1982), studied in finite model theory (Fagin, 1993; Ebbinghaus & Flum, 1999): LFP is a logic allowing to iterate first-order formulae maintaining constant the number of their variables. However we do no know of any calculus for deciding the satisfiability in LFP. We see two reasons for this: first, LFP is undecidable and not complete, second the purposes of this logic are mainly theoretical, hence the fact that research in this field has not focussed on decision procedures for some subclasses. In contrast with propositional µcalculus, first-order µ-calculus (Park, 1976) clearly embeds iterated schemata (allowing for instance the above fixed-point expression of ∧n i=1 pi), but no published research seems to be focused on the identification of complete subclasses. With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it.\nAs we shall see in Section 5.2, completeness of bound-linear schemata (or more precisely regular schemata) lies in the detection of cycles during the proof search. This idea is not new, it is used, e.g., in tableaux methods dealing with modal logics in transitive frames (Goré, 1999), or µ-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992). However cycle detection in our work is quite different because we use it to prove by induction. Notice in particular that we cannot in general ensure termination (contrarily to the above methods). It is more relevant to consider our method as a particular instance of cyclic proofs, which are studied in proof theory precisely in the context of proofs by induction. In the works of Brotherston (2005), and Sprenger and Dam (2003), it is shown that cyclic proofs seem as powerful as systems dealing classically with induction. A particular advantage of cyclic proofs is that finding an invariant is not needed, making them particularly suited to automation. However, once again those studies are essentially theoretical and there are no completeness results for particular subclasses.\nTo summarize, known decidable logics (such as propositional µ-calculus) or even semidecidable ones such as first-order logic are not expressive enough to directly embed iterated schemata, whereas those that are sufficiently expressive (such as fixpoint or higher order logics) are not suitable for automation. Together with the potential applications mentioned in Section 2.4, this justifies to our opinion the interest of the considered language."
    }, {
      "heading" : "4. Reduction to Regular Schemata",
      "text" : "In this section we reduce the satisfiability problem for bound-linear schemata (see Definition 2.9) to a much simpler class of schemata, called regular. This class is defined as follows:\nDefinition 4.1 A schema ϕ is:\n• flat if for every iteration Πbi=aψ occurring in ϕ, ψ does not contain any iteration (i.e. iterations cannot be nested in ϕ).\n• of bounded propagation if every atom that occurs in an iteration Πbi=aψ in ϕ is of the form pi+γ for some γ ∈ Z. Since the number of atoms is finite, there exist α, β ∈ Z s.t. for every atom pi+γ occurring in an iteration we have γ ∈ [α, β]. α, β are called the propagation limits.\n• aligned on [c, d] if all iterations occurring in ϕ are of the form Πdi=cψ (i.e. all iterations must have the same bounds).\n• regular if it has a unique parameter n and if it is flat, of bounded propagation and aligned on [α, n− β] for some α, β ∈ Z.\nAs an example, the schema Adder defined in the Introduction is regular, but the last example in Section 2.4 (three cells register with shift) is not. Obviously, every regular schema is also bound-linear (see Definition 2.9). We now define an algorithm that transforms every bound-linear schema into a sat-equivalent regular one. This result is somewhat surprising because the class of regular schemata seems much simpler than bound-linear schemata. In some sense, it points at regular schemata as a canonical decidable class of schemata."
    }, {
      "heading" : "4.1 Overview of the Transformation Algorithm",
      "text" : "We first give an informal overview of the algorithm reducing every bound-linear schema into a regular one, together with examples illustrating each transformation steps. This very high level description is intended to help the reader to grasp the intuitive ideas behind the formal definitions and more technical explanations provided in the next section. The transformation is divided into several steps.\n• The first step is the elimination of iterations occurring inside an iteration. Consider for instance the following schema ϕ : ∨n i=1(pi ⇒ ∧n j=1 qj). The reader can check\nthat ϕ is bound-linear but non regular. It is easy to transform ϕ into a sat-equivalent regular schema: since ∧n j=1 qj does not depend on the counter i, one can simply replace\nthis formula by a new propositional variable r and add the equivalence r ⇔ ∧n\nj=1 qj outside the iteration. This yields the schema: ∨n i=1(pi ⇒ r) ∧ (r ⇔ ∧n j=1 qj), which is clearly regular and sat-equivalent (but not equivalent) to ϕ. This process can be generalized; however, replacing an iteration by a proposition is only possible if the iteration contains no variable that is bound in the original schema. Consider the schema: ϕ′ : ∨n i=1 ∧n j=1(pi ⇒ qj). Here ∧n j=1(pi ⇒ qj) cannot be replaced by a variable r, since it depends on i. The solution is to get the variable pi containing i\nout of the iteration ∧n\nj=1(pi ⇒ qj): as pi does not involve j, it is easily seen that we can turn ∧n j=1(pi ⇒ qj) into pi ⇒ ∧n j=1 qj . This transformation can be generalized by using case-splitting: indeed, it is well-known that every formula ψ is equivalent to (r ∧ ψ[⊤/r]) ∨ (¬r ∧ ψ[⊥/r]), for every propositional variable r. Applying this decomposition scheme to ∧n j=1(pi ⇒ qj) and pi we get: ∧n j=1(pi ⇒ qj) ≡ (pi ∧∧n\nj=1(⊤ ⇒ qj)) ∨ (¬pi ∧ ∧n j=1(⊥ ⇒ qj)), i.e. (by usual transformations): ∧n\nj=1(pi ⇒ qj) ≡ (pi∧ ∧n j=1 qj)∨¬pi. Afterwards, the remaining iteration ∧n j=1 qj can be replaced by a new variable r.\nThe decomposition scheme just explained can be applied on every variable occurring in an iteration, but not containing the counter of this iteration. By definition of bound-linear schemata, the propositional symbols have only one index and this index contains at most one bound variable, thus this technique actually removes every atom containing a counter variable distinct from the one of the considered iteration. However, it does not remove the variables that occur in the bound of the iteration. Consider for instance the following formula: ϕ′′ def = ∨n i=1 ∧i j=1 qj . Here i occurs in the bound of the iteration and thus cannot be removed by the previous technique. The idea is then to encode the formula ∧i j=1 qj by a new variable ri, that can be defined inductively as follows: r0 is ⊤ and ri+1 is ri ∧ qi+1. This is expressed by the schema: r0 ∧ ∧n−1 i=0 (ri+1 ⇔ (ri ∧ qi+1)).\nNotice that ri needs only to be defined for i = 0, . . . , n because i ranges over the interval [1, n] in ϕ′′.\n• In order to get a regular schema one has to guarantee that every iteration ranges over the same interval of the form [α, n − β] (where β ∈ Z). This is actually simple to ensure by unfolding and shifting the iterations. For instance a schema ∨2n i=1 pi can\nbe transformed into ∨n i=1 pi ∨ ∨2n i=n+1 pi and then into ∨n i=1 pi ∨ ∨n\ni=1 pi+n. Similarly∨n i=2 pi∨ ∨n−1 j=1 qj can be reduced to ∨n−1 i=2 pi∨pn∨q1∨ ∨n−1 j=2 qj to get iterations defined on the same interval.\n• A major difference between regular schemata and bound-linear ones is that, in a regular schema, the indexed variables occurring inside an iteration cannot contain parameters (e.g., an iteration such as ∨n i=1 pi+n is forbidden). Therefore we have to\nreplace every variable of the form pα.n+β±i by a new variable qi, depending only on i. The problem is that in order to preserve sat-equivalence, one also has to encode the relation between these variables. For instance, assume that pn+i is replaced by qi and that p2n−j is replaced by rj . Then obviously, we must have qi ≡ rj if n+i = 2n−j, i.e. qi ≡ rn−i. This step may be problematic because in general there are infinitely many such axioms. However, by defining the translation carefully, we will show that actually only finitely many equivalences are required. To this aim, we have to assume that the initial coefficient of the parameter is even in every index (see Definition 4.2), which is easy to ensure by case splitting. Then the maximal number of overlaps between the newly defined variable is actually bounded (this is shown by the crucial lemma 4.6).\nFor instance, a formula ∨n i=0(¬pi ∨ p2n−i) is replaced by ∨n\ni=0(¬pi ∨ qi) ∧ (pn ⇔ qn). qi denotes the atom p2n−i and the equivalence encodes the fact that qn ≡ p2n−n = pn.\nSince i ranges over the interval [0..n] this is the only equation which is relevant w.r.t. ϕ (e.g. p0 ⇔ q2n is useless).\nThe algorithm for transforming every bound-linear schema ϕ into a sat-equivalent regular schema ψ is specified as a sequence of rewriting rules, operating on schemata and preserving sat-equivalence. The rules are depicted in Figure 1. They must be applied in the order of their presentation. As we shall see in Section 4.3, the rewrite system terminates (in exponential time). Moreover satisfiability is preserved and irreducible schemata are regular (see Section 4.4)."
    }, {
      "heading" : "4.2 Formal Definition of the Algorithm",
      "text" : "We now give a more detailed and precise description of the transformation algorithm (readers not interested in technical details can skip this section). We assume that the initial schema satisfies the following condition:\nDefinition 4.2 A bound-linear schema is normalized if the coefficient of the parameter n is even in any expression occurring in the formula (either as the index of a symbol in P or as the bound of an iteration).\nConsidering exclusively normalized schemata is not restrictive because a schema ϕ not satisfying this property can be replaced by ϕ[2n/n] ∨ ϕ[2n + 1/n] (e.g. p3n is turned into p6n ∨ p6n+3). The obtained schema is obviously sat-equivalent to ϕ and normalized4. The use of normalized schemata will be explained later (see Remark 4.7).\nRemark 4.3 The property of being normalized is only useful for the algorithm of Figure 1 to be welldefined. But the schema obtained after application of this algorithm is actually not normalized in general.\nWe now explain in more details the different steps of the transformation."
    }, {
      "heading" : "4.2.1 Elimination of Nested Iterations",
      "text" : "As explained in Section 4.1, the first step is to remove the iterations Πbi=aϕ occurring inside another iteration Γdj=cψ. This is done by the rules τ1, τ2, τ3, τ4. τ2 moves Π b i=aϕ out by introducing a new variable p as explained before. This is possible only if ϕ does not contain any free variable except i and the parameter n. Removing all other variables is precisely the role of τ1:\nτ1 Π b i=aϕ → (pc ∧Πbi=aϕ[⊤/pc]) ∨ (¬pc ∧Πbi=aϕ[⊥/pc])\nIf the variables in c are free in Πbi=aϕ, pc occurs in ϕ and if for every iteration Γdj=cϕ ′ containing Πbi=aϕ, pc contains either j or a variable bound in Γdj=cϕ ′.\n4. But the two formulae are not equivalent in general. For instance, if ϕ = pn, then the interpretation\ndefined by I(n) def= 1 and I(pκ) def = T iff κ = 1 validates pn but obviously not p2n ∨ p2n+1.\nThis rule aims at eliminating, in the body of an iteration Πbi=aϕ, every variable distinct from the iteration counter i and from the (unique) parameter n. This is feasible because no index can contain two variables distinct from n (by definition of bound-linear schemata). This implies that the indexed variables containing an arithmetic variable distinct from i and n cannot contain i thus they can be taken out of the iteration Πbi=aϕ by case splitting. Notice that the rule τ1 can increase exponentially the size of the formula.\nOnce ϕ contains no free variable except n and i, Πbi=aϕ may be taken out of the global iteration Γdj=cψ by renaming. This is very easy if the bounds of the iteration only depend on n, because in this case Πbi=aϕ contains no free variable except n, thus it may be replaced by a fresh variable p and the equivalence p ⇔ Πbi=aϕ may be added as an axiom. This is done by the rule τ2:\nτ2 ψ → (p ⇔ Πbi=aϕ) ∧ ψ[p/Πbi=aϕ] If p is a fresh symbol, ψ is the global schema, Πbi=aϕ occurs in an iteration in ψ and contains no free variable except n.\nThings get more complicated if the bounds of the iteration contain a bound variable j (e.g., the schema ∨n j=1(qi ⇒ ∨j i=1 ri)) because in this case the iteration cannot be taken out and j cannot be eliminated by τ1. Notice that, in this case, the lower bound a cannot contain j and the coefficient of j in the upper bound b must be ±1. In this case, Πbi=aϕ can be replaced by a new variable pj that can be defined inductively. For instance in the previous\nexample, ∨j i=1 ri is replaced by a variable pj defined as follows: ¬p0∧ ∧n\nj=1[pj ⇔ (rj∨pj−1)]. The transformation is formally specified by the rules τ3 (if the coefficient of j is 1) and τ4 (if the coefficient of j is −1). Notice that if ψ denotes the global schema, then pj must be defined for every j ∈ [minψ(j),maxψ(j)].\nτ3 ϕ → ∧a−b−1\nj=minϕ(j) ¬pj ∧ ∧maxϕ(j) j=a−b (pj ⇔ (pj−1 ∨ ψ[b+ j/i])) ∧ (ϕ[pj/ ∨b+j i=a ψ])\nIf p is a fresh symbol, ∨b+j\ni=a ψ occurs in an iteration of ϕ, j is bound in ϕ, a, b and ψ contain no free variable except n, ϕ is the global schema.\nτ4 ϕ → ∧maxϕ(j)\nj=b−a+1 ¬pj ∧ ∧b−a j=minϕ(j) (pj ⇔ (pj+1 ∨ ψ[b− j/i])) ∧ (ϕ[pj/ ∨b−j i=a ψ])\nIf p is a fresh symbol, ∨b−j\ni=a ψ occurs in an iteration of ϕ, j is bound in ϕ, a, b and ψ contain no free variable except n, ϕ is the global schema.\nThe rules τ ′3 and τ ′ 4 for\n∧ are defined in a similar way (see Figure 1)."
    }, {
      "heading" : "4.2.2 Transforming every Iteration into Iterations over Intervals of the",
      "text" : "Form [α, n− β]\nThe next step is to ensure that for every iteration Πbi=aϕ, a is an integer α and that b is of the form n− β, where β is a constant (initially both a and b must be of the form 2.δ.n+ γ (since the initial schema is normalized and no iteration is contained inside another one so no bound variable occurs in the upper bound). The first point is easily performed by an\nappropriate translation of the iteration counter (rule τ5):\nτ5 Π γ.n−δ i=α.n+βϕ → Π (γ−α).n−δ i=β ϕ[i+ α.n/i]\nIf α ̸= 0, β ∈ Z.\nThen we ensure that the coefficient of n in b is positive. Fortunately, if this coefficient is negative then there is κ ∈ N s.t. for every interpretation I s.t. I(n) > κ, the interval [I(a), I(b)] is empty, in which case Πbi=aϕ is either ⊤ or ⊥ (depending on Π). Since the value of n is positive, there exist finitely many values for n s.t. the iteration is non empty. One can eliminate the iteration by considering these cases separately. This is done by the rule τ6:\nτ6 ψ → [ψ]n 7→0 ∨ . . . ∨ [ψ]n7→κ ∨ (n > κ ∧ ψ[⋄/Πα.n−βi=γ ϕ]) If ψ contains Πα.n−βi=γ ϕ, with α, β, γ ∈ Z, α < 0 and Π ∈ { ∧ , ∨ },\nwhere κ = ⌈γ−βα ⌉ and Π is ∨ then ⋄ = ⊥ and if Π = ∧ then ⋄ = ⊤.\nFinally, we obtain the desired result by (recursively) decomposing an iteration interval of the form [γ, α.n + β] (where α > 1) into two smaller intervals [γ, (α − 1).n + β] and [(α− 1).n+ β + 1, α.n+ β]. Obviously, this is possible only if (α− 1).n+ β ≥ γ, thus the case where (α− 1).n+ β < γ must be considered separately. This is easy to achieve, since in this case there are only finitely many possible values of n, namely 0, 1, . . . , ⌊γ−βα−1⌋.\nτ7 ψ → ((α− 1).n− β ≥ γ ∧ ψ[ψ′/Πα.n−βi=γ ϕ]) ∨ ([ψ]n 7→0 ∨ . . . ∨ [ψ]n7→κ) where ψ contains an iteration Πα.n−βi=γ ϕ with α > 1,\nψ′ is Π (α−1).n−β i=γ ϕ ⋆Π n i=1ϕ[i+ (α− 1).n− β/i], with Π ∈ {\n∧ , ∨ },\nwhere κ = ⌊γ−βα−1⌋, Π = ∧ then ⋆ = ∧, if Π = ∨ then ⋆ = ∨."
    }, {
      "heading" : "4.2.3 Removing the Parameter from the Indices in the Iterations",
      "text" : "The next phase consists in removing the indexed variables of the form pα.n+ϵ.i+β where β ∈ Z and either α ̸= 0 or ϵ = −1 (to get variables indexed by expressions of the form i + β only). We first ensure that α is even. Although initially the coefficient of every occurrence of n is even, this property does not hold anymore at this point because of the rule τ7. Suppose a variable p(2γ+1).n+c, where c does not contain n, occurs in an iteration Πbi=aϕ. Then (since the schema is normalized) this variable must have been introduced by the rule τ7 and i has been shifted by (α − κ).n for some κ (by definition of τ7). This shift is applied to every index containing i (by definition of τ7), i.e. to every index of a variable occurring in Πbi=aϕ (otherwise the iteration would be reducible by τ1). As a consequence every index in this iteration has an odd coefficient for n. Hence if we add n to each index we retrieve even coefficients in all the iteration. Fortunately by commutativity of ∨ and ∧, any iteration Πbi=aϕ is equivalent to Π b−a i=0ϕ[b − i/i]. In our case b is of the form n − β for some β ∈ Z so applying this transformation precisely adds n to each index (and substracts a β). For instance, the iteration ∨n i=1(pn+i ∨ pn−i) can be replaced by ∨n−1 i=0 (p2n−i ∨ pi). This idea is formalized by the rule τ8:\nτ8 Π n−β i=γ ϕ → Π n−γ i=β ϕ[n− i/i]\nIf the indices of the variables in ϕ are of the form (2α+ 1).n+ c, where c ∈ Ni.\nOnce the coefficient of n in every indexed variable is even, we introduce, for every variable p and for every integer κ, two new (fresh) variables pκ + and pκ − s.t. pκ + a and p κ− a denote respectively p2.κ.n+a and p2.κ.n−a where a ∈ Ni ∪ Z i.e. a is of the form β.i + γ where β ∈ {0, 1}, γ ∈ Z (rule τ9). Then the index of pκ +\na does not contain n anymore. Furthermore, the index of pκ − a now contains +i instead of −i. Thus this transformation indeed achieves our goal however it does not preserve sat-equivalence because two variables p2α.n+a and p2β.n−b (respectively p2α.n+a and p2β.n+b, p2α.n−a and p2β.n−b) s.t. 2α.n + a = 2β.n − b (respectively 2α.n + a = 2β.n + b and 2α.n − a = 2β.n − b) may be replaced by distinct variables pα + a and p β− b (respectively p α+ a and p β+ b , p α− a and p β−\nb ). Notice that it is important to distinguish the sign + or − in front of a and b, as both are not integers but expressions of Ni ∪ Z. In order to preserve sat-equivalence one would have to explicitly add the following axioms to the schema:\n2α.n+ γ = 2β.n− δ ⇒ (pα+γ ⇔ p β− δ )\nand\n2α.n+ γ = 2β.n+ δ ⇒ (pα+γ ⇔ p β+ δ )\nand\n2α.n− γ = 2β.n− δ ⇒ (pα−γ ⇔ p β− δ )\nfor every tuple (α, β, γ, δ) ∈ Z4. This transformation is problematic, because there exist infinitely many such formulae. Fortunately, we do not have to add all these equivalences, but only those concerning propositional variables that occur in a propositional realization of the schema. As we shall see, this set (denoted by Ψ(ϕ)) is finite, because each expression γ, δ ranges over a set of the form [−ι, ι] ∪ [n− ι, n+ ι], where ι ∈ N.\nMore formally, let V + and V − be two disjoint subsets of P, distinct from the symbols already occurring in the considered formula. We assume that every pair (p, α) where p is a variable occurring in the formula and α an integer is mapped to two variables pα\n+ ∈ V + and pα\n− ∈ V −. pα+i and pα −\ni will denote the atoms p2α.n+i and p2α.n−i respectively. We denote by ϕ the schema obtained from ϕ by replacing every variable of the form p2α.n+a (where a ∈ Ni ∪N for some bound variable i) by pα +\na and each variable of the form p2α.n−a by pα − a (in both cases we may have α = 0, moreover, if a = 0 then the replacement may be done arbitrarily by pα +\n0 or p α− 0 ). Notice that all atoms in ϕ are of the form p α+ a or p α− a ,\nwhere a ∈ Ni ∪ N for some bound variable i. τ9 is defined as follows:\nτ9 ϕ → ϕ ∧ ∧ ψ∈Ψ(ϕ) ψ\nIf ϕ contains a variable p not occurring in V − ∪ V +, and where Ψ(ϕ) is defined by Definitions 4.4, 4.5 and Lemma 4.6."
    }, {
      "heading" : "4.2.4 Aligning Iterations",
      "text" : "Finally, it remains to ensure that all the iterations have the same bounds. At this point every iteration is of the form Πn−βi=α ϕ where α, β ∈ Z. Let α′, β′ be the greatest integers α, β. If we have α ̸= α′ or β ̸= β′, then we unfold the iteration once, yielding Πn−β−1i=α ϕ⋆ϕ[n−β/i]. By translation of the iteration counter, Πn−β−1i=α is equivalent to Π n−β−1+α′−α i=α′ ϕ[i−α\n′+α/i]. The lower bound of the obtained iteration is now identical to α′ and its length has been\ndecreased. This is repeated until we obtain an iteration on the interval [α′, β′]. The rule τ10 formalizes this transformation:\nτ10 Π n−β i=α ϕ → (n < α+ β ∧ ⋄) ∨\n(n ≥ α+ β ∧Πn−β−1+α ′−α\ni=α′ ϕ[i− α ′ + α/i] ⋆ ϕ[n− β/i])\nwhere α′ is the maximal lower bound of an iteration occurring in the whole formula and β′ is the minimal upper bound, α ̸= α′ or β ̸= β′, and if Π is ∨ then ⋄ = ⊥, ⋆ = ∨ and if Π = ∧ then ⋄ = ⊤, ⋆ = ∧."
    }, {
      "heading" : "4.2.5 Definition of Ψ(ϕ)",
      "text" : "The most difficult part of the transformation is the removal of the variable n in the index performed by the rule τ9, and more precisely the definition of Ψ(ϕ). We now establish the results ensuring the feasability of this transformation.\nDefinition 4.4 We denote by Ψ the set of schemata of the form:\n2α.n+ a = 2β.n− b ⇒ (pα+a ⇔ p β− b )\nor\n2α.n+ a = 2β.n+ b ⇒ (pα+a ⇔ p β+ b )\nor\n2α.n− a = 2β.n− b ⇒ (pα−a ⇔ p β− b )\nwhere α, β ∈ Z, a, b ∈ Nn ∪ Z.\nThe set Ψ is infinite. Thus we add a further restriction:\nDefinition 4.5 Let ϕ be a schema containing a unique parameter n. A schema ψ ⇒ (p ⇔ q) occurring in Ψ is said to be relevant w.r.t. ϕ iff the following conditions hold:\n• p and q are not syntactically identical.\n• There exists a natural number κ s.t. ψ[κ/n] is true and ϕ[κ/n] contains both p[κ/n] and q[κ/n]\nNotice that p and q do not necessarily occur in ϕ itself. For instance, take ϕ =∧n i=1(p2n−i ∨ ¬pi). So ϕ = ∧n i=1(p 2− i ∨ ¬p0 + i ). Then 2n − n = 4 ⇒ (p2 − n ⇔ p0 + 4 ) is easily seen to be relevant, however both p2 −\nn and p 0+ 4 do not occur in ϕ.\nThe next lemma provides a very simple necessary condition on relevant equivalences in Ψ. It also shows that for every schema ϕ the number of relevant equivalences in Ψ is finite (up to equivalence).\nLemma 4.6 Let ϕ be a schema containing a unique parameter n. Assume that the coefficient of n is even in every index in ϕ and that every iteration in ϕ is of the form Πn+ζi=ϵ ψ, where ϵ, ζ ∈ Z\n(ϵ, ζ may depend on the iteration). Let ι be the greatest natural number occurring in ϕ (possibly as a coefficient of n or in an expression of the form −ι).\nFor every relevant formula of the form 2α.n+ a = 2β.n− b ⇒ (pα+a ⇔ p β− b ), 2α.n+ a =\n2β.n + b ⇒ (pα+a ⇔ p β+ b ) or 2α.n − a = 2β.n − b ⇒ (p α− a ⇔ p β−\nb ) in Ψ, we have, for every κ ∈ N: α, β ∈ [−ι, ι] and a[κ/n], b[κ/n] ∈ [−2ι, 6ι] ∪ [κ− 2ι, κ+ 2ι]."
    }, {
      "heading" : "Proof",
      "text" : "Let σ stand for the substitution [κ/n]. By definition of a relevant formula, there must exist κ ∈ N such that pα+a σ and p β− b σ (respectively p β+ b σ) occur in [ϕ]σ (but notice that p α+ a , p β− b and pβ +\nb do not necessarily occur in ϕ). Furthermore we must have 2α.κ+ aσ = 2β.κ− bσ (resp. 2α.κ+ aσ = 2β.κ+ bσ).\nSince the coefficient of n is even in every index in ϕ and since a, b ∈ Nn ∪ Z, 2α, 2β necessarily occur in ϕ. Thus α, β ∈ [−ι/2, ι/2] ⊆ [−ι, ι].\nMoreover, by Lemma 2.8, there exist two atoms pα + a′ and p β− b′ (respectively p β+ b′ ) which\noccur in ϕ and two ϕ-expansions σ′ and σ′′ of σ for pα + a′ and p β− b′ (respectively p β+\nb′ ) s.t. we have aσ = a′σ′ and bσ = b′σ′′. By definition, a′, b′ come from the replacement of some proposition p2α.n+a′ (resp. p2β.n−b′ and p2β.n+b′) by p k+ a′ (resp. p k− b′ and p k+\nb′ ). Thus a′ and b′ do not contain n. Thus a′ and b′ are either in Z (and in this case we must have aσ, bσ ∈ [−ι, ι] ⊆ [−2ι, κ + 2ι]) or respectively of the form i + γ and i + δ where i is a bound variable and γ, δ ∈ Z. Then since σ′, σ′′ are ϕ-expansions of σ we have iσ′, iσ′′ ∈ [minϕ(i)σ,maxϕ(i)σ]. We have minϕ(i) = ϵ ≥ −ι and maxϕ(i) = n + ζ ≤ n + ι. Thus aσ, bσ ∈ [−2ι, κ+ 2ι].\nAssume that we have 2α.κ+ aσ = 2β.κ− bσ. Then aσ + bσ = 2.(β − α).κ.\n• If β ≤ α then aσ + bσ ≤ 0. Since aσ, bσ ≥ −2ι, we deduce aσ, bσ ≤ 2ι. Thus aσ, bσ ∈ [−2ι, 6ι].\n• If β > α then aσ + bσ ≥ 2κ. Since aσ ≤ κ + 2ι and bσ ≤ κ + 2ι we must have aσ ≥ κ− 2ι and bσ ≥ κ− 2ι. Thus aσ, bσ ∈ [κ− 2ι, κ+ 2ι].\nNow, assume that 2α.κ+ aσ = 2β.κ+ bσ. Then aσ − bσ = 2.(β − α).κ.\n• If α = β then we must have aσ = bσ. This contradicts the first condition in Definition 4.5 (the indexed variables cannot be syntactically identical).\n• If α < β then aσ − bσ > 2κ. This is possible only if aσ > 2κ + bσ > 2κ − 2ι, hence κ+2ι > 2κ−2ι, i.e. 4ι > κ. Then since we must have aσ, bσ ∈ [−2ι, κ+2ι] we deduce aσ, bσ ∈ [−2ι, 6ι].\n• The proof is symmetric if α > β.\nFinally if 2α.κ− aσ = 2β.κ− bσ then aσ − bσ = 2.(α− β).κ and the proof follows exactly as in the previous case.\nLemma 4.6 implies that the set of relevant formulae is finite (up to equivalence). Indeed, it suffices to instantiate α, β by every integer in [−ι, ι] and a, b either by elements of [−ι, 6ι]\nor by expressions of the form n + γ, where γ is an integer in [−2ι, 2ι]. Thus we denote by Ψ(ϕ) a finite subset of Ψ containing all relevant formulae (up to equivalence). Such a set can be easily computed by applying Lemma 4.6, but using refined criteria is possible, thus we opt for a generic definition.\nRemark 4.7 The fact that the coefficient of n is even (see Definition 4.2 of normalized schemata) is essential at this point. If arbitrary coefficients are allowed for n, then the coefficients 2α and 2β must be replaced by α and β respectively. Then in the second item in the proof of Lemma 4.6 we obtain ασ + bσ ≥ κ (instead of aσ + bσ ≥ 2κ). Thus we get eventually ασ, bσ > −2ι (instead of aσ ≥ κ − 2ι). This means that aσ, bσ range over the interval [−2ι, κ+ 2ι] instead of [−ι, 6ι] ∪ [κ− 2ι, κ+ 2ι]. But this interval is unbounded, thus Ψ(ϕ) is infinite (even up to equivalence).\nFor instance, suppose that we allow any coefficient for n (i.e. odd or even) and that pα.n+β is turned into p 1+ β . Consider then ϕ = ∨n i=1(pi∨pn−i). We get: ϕ = ∨n i=0(p 0+ i ∨p1 − i ). But the equivalence p0 +\ni ⇔ p1 −\nn−i is obviously needed for every i ∈ [1, n], which cannot be expressed by a finite number of equivalences.\nOn the other hand, if we only allow normalized schemata, i.e. even coefficients for n, then we first have to turn ϕ into ψ = ∨2n i=1(pi ∨ p2n−i) hence (by τ7) ψ = ∨n i=1(pi ∨\np2n−i) ∨ ∨n i=1(pn+i ∨ pn−i), and (by τ8) ψ = ∨n i=1(pi ∨ p2n−i) ∨ ∨n−1\ni=0 (p2n−i ∨ pi). Then ψ = ∨n i=1(p 0+ i ∨ p1 − i ) ∨ ∨n−1 i=0 (p 1− i ∨ p0 + i ). No equivalence is needed in this simple case.\nLemma 4.8 Let ϕ be a schema containing a unique parameter n s.t. every iteration in ϕ is of the form Πn+βi=α ψ, where α, β ∈ Z. ϕ is satisfiable iff ϕ ∪Ψ(ϕ) is satisfiable."
    }, {
      "heading" : "Proof",
      "text" : "Let I be an interpretation satisfying ϕ. Let κ = I(n). We define an interpretation J as follows: J (n) def= κ and for every pair of integers (α, β): J (pα+β ) def = ⊤ iff I(p2α.κ+β) = ⊤ and J (pα−β ) def = ⊤ iff I(p2α.κ−β) = ⊤. By definition for all ψ ∈ Ψ, J |= ψ. ϕ is obtained from ϕ by replacing every atom of the form p2α.n+a (respectively p2α.n−a) where a ∈ Ni ∪Z (for some bound variable i) by pα + a (respectively p α− a ). By definition of J , J |= pα + β iff I |= p2α.n+β and J |= pα −\nβ iff I |= p2α.n−β. Since I |= ϕ it is clear that we have J |= ϕ. Thus J |= ϕ ∪Ψ(ϕ).\nConversely, let I |= ϕ ∪ Ψ(ϕ). Let κ = I(n). Let J be the interpretation defined as follows. J (n) def= κ, J (p2α.κ+β) = I(pα + β ) if p α+ β occurs in [ϕ]I , and J (p2α.κ−β) = I(pα − β ) if pα −\nβ occurs in [ϕ]I . It is easy to check that J is well-defined since I |= Ψ(ϕ) and Ψ(ϕ) contains all the necessary equivalences. By definition, pα + a (respectively p α− a ) occurs in ϕ iff p2α.n+a (respectively p2α.n+a) occurs in ϕ. Thus, since I |= ϕ we have J |= ϕ."
    }, {
      "heading" : "4.3 Termination and Complexity",
      "text" : "In this section, we investigate the complexity of the transformation algorithm and show that it is exponential. For every schema ϕ, we denote by |ϕ| the size of ϕ, i.e. the number of symbols occurring in ϕ. τ denotes the system of rewrite rules of Figure 1.\nTheorem 4.9 Let ϕ be a normalized bound-linear schema. A normal form ψ of ϕ w.r.t. τ can be computed in O(2|ϕ|) rewriting steps. Moreover, |ψ| = O(2|ϕ|)."
    }, {
      "heading" : "Proof",
      "text" : "We first notice that the rules are always applied sequentially: it is easy to check that a rule cannot introduce a formula on which a previous rule applies. Thus we consider each rule in sequence.\nFirst, we consider the rule τ1. We call τ1-atoms the atoms pc on which the rule possibly applies, i.e. the atom occurring in an iteration Πbi=aψ but not containing the iteration counter i. This rule removes an atom occurring in an iteration but not containing the iteration counter. Due to the control (i.e. the application conditions of the rules), no atom satisfying this condition can be introduced into the formula (indeed, if the atom pc occurs in an iteration then, because of the second application condition of the rule, it must contain the corresponding iteration counter of this iteration). Therefore, the number of applications of this rule on an iteration is bounded by the number of τ1-atoms it contains. Since the rule duplicates the considered iteration the total number of applications of the rule is bounded by 2m, where m is the total number of τ1-atoms. Obviously m ≤ |ϕ|.\nThis is not sufficient to prove the second result, i.e. that the size of the formula is O(2|ϕ|), since each application of the rule can double the size of the formula (which would yield a double exponential blow-up since there are 2m rule applications). Consider the set of leaf positions of the considered formula. For each position p in this set, we denote by |p| the length of p and by rp the number of possible applications of the rule τ1 along p. Each application of the rule τ1 removes some positions p from this set (those corresponding to the leaves of the subformula on which the rule is applied) and replaces them by new positions p′1, . . . , p ′ κ. Both the number of these positions and their length possibly increase. However, we remark that the rule can only increase the length of these positions by 2 (by adding a disjunction of conjunctions), i.e. we have ∀ι ∈ [1, κ], |p′ι| ≤ |p|+2. Furthermore, the number rp necessarily decreases: ∀ι ∈ [1, κ], rp′ι < rp. Consequently, the value |p| + 2 × rp cannot increase (i.e. we have ∀ι ∈ [1, κ], |p′ι|+ 2× rp′ι ≤ |p|+ 2× rp), which implies that the length of the final positions (when rp′ι = 0) are lower than |pmax| + 2 × rmax, where rmax denotes the maximal number of possible applications of the rule τ1 along some position in the initial formula (i.e. the max of the rp in the initial formula) and pmax is the position of maximal length in the initial formula. Both |pmax| and rmax are O(|ϕ|), thus the depth of the final formula is O(|ϕ|), which implies that it size is O(2|ϕ|).\nWe now consider the other rules. First we analyze the transformation due to a single application of each of those rules (then we will analyze the number of such applications). Since the proofs for the different cases are actual very similar, we do not consider each rule separately, but we rather factorize some part of the analysis.\n• Each application of the rule τ2 only increases the size of the formula by a constant number of symbols, since a fixed number of new connectives is added and no part of the formula is duplicated.\n• The application of the rules τ3, τ ′3, τ4, τ ′4, τ5, τ8 and τ10 adds a constant number of new connectives in the formula and replaces each occurrence of the counter i in the\nformula ϕ by an expression of the form b+ j, b− j, i+α.n or n− i. The size of these expressions is bounded by the size of the original formula, thus the size of the formula increases quadratically (since the number of occurrences of i is also bound by the size of the formula).\n• Now consider the rules τ6 and τ7. These rules introduce a constant number of new connectives and occurrences of atoms and duplicate κ times a subformula ψ. The value of κ is bounded by the natural number γ that occurs in ϕ, thus the size of the formula increases polynomially (since natural numbers are encoded as unary terms s(. . . (s(0)) . . .) is our setting, hence κ is bounded by the size of the formula – notice that this would not be the case if the numbers were encoded as sequences of digits5).\nThus we only have to show that the number of applications of each of these rules is polynomially bounded by the size of the initial formula. Once again, we distinguish several cases:\n• The rules τ2, τ3, τ ′3, τ4, τ ′4 only apply on iterations occurring inside another iteration. During the application of the rule, this iteration is replaced by an atom, hence removed from the outermost iteration. The rule introduces new iterations, however they only occur at the root level, outside the scope of any iteration. Thus the total number of possible applications of these rules is bounded by the number of iterations initially occurring inside another iteration, hence by |ϕ|.\n• The rules τ5, τ6 and τ8 apply at most once on each iteration: τ5 applies on an iteration in which the lower bound contain n and gets rid of any occurrence of n in the lower bound. τ6 applies on iterations in which the upper bound contains −n and replaces these iterations by purely propositional formulae. τ8 applies if the coefficient of n in every index is odd. Since the rule adds n to each index, after the application of the rule, the coefficient of n must be even and the rule cannot apply again on the same iteration.\n• The rule τ7 decreases the value of the coefficient α of n in the upper bound by 1. Thus the number of applications of the rule τ7 on each iteration is lower than the initial value of α (which is bound by the size of the formulae since integers are encoded as terms). Similarly, since τ10 unfolds an iteration until an iteration of length n−β′−α′ is obtained, the number of applications of the rule τ10 on each iteration is bound by the value of −β + α+ β′ − α′.\n• Finally, the rule τ9 applies only once on the whole schema. The rule adds a conjunction of equivalence to the schema, but by Lemma 4.6, the size of the conjunction is polynomially bounded by the greatest natural number ι occurring in the schema, hence by the size of the formula.\nFor every schema ϕ, we denote by ϕ ↓τ a normal form of ϕ w.r.t. the rules in τ .\n5. Actually the translation is doubly exponential in this case."
    }, {
      "heading" : "4.4 Soundness and Completeness",
      "text" : "We prove that the rules in τ preserve sat-equivalence and that every irreducible formula is regular. We need the two propositions below:\nLemma 4.10 Let ψ, ϕ and ϕ′ be schemata. Let I be an interpretation such that for every ground substitution σ of the parameters of ψ and for every ψ-expansion θ of σ for ϕ, ϕ′, we have:JϕθKI = Jϕ′θKI . Then JψKI = Jψ[ϕ′/ϕ]KI ."
    }, {
      "heading" : "Proof",
      "text" : "The proof is by induction on ψ. If ψ does not contain ϕ the proof is trivial. If ψ = ϕ then ψ[ϕ′/ϕ] = ϕ′. By definition JϕKI = JϕσIKI and Jϕ′KI = Jϕ′σIKI . But σI is a ground substitution of the parameters of ψ = ϕ and thus is of course a ψ-expansion of itself for ϕ and ϕ′. Thus JϕσIKI = Jϕ′σIKI hence JψKI = Jψ′KI .\nAssume that ψ = ¬ψ′. We have Jψ[ϕ′/ϕ]KI = ¬Jψ′[ϕ′/ϕ]KI = ¬Jψ′KI (by induction). Thus Jψ[ϕ′/ϕ]KI = JψKI . The proof is similar if ψ = (ψ1 ∨ ψ2) or if ψ = (ψ1 ∧ ψ2).\nNow assume that ψ = ∧b i=a ψ ′. I |= ψ iff for every integer κ ∈ [JaKI , JbKI ] we have I[κ/i] |= ψ′. Let σ′ be the substitution such that σ′(i) = κ and σ′(x) def= σ(x) if x ̸= i. Let θ be a ψ-expansion of σ′ for ψ′. By definition κ ∈ [Jminψ(i)KI , Jmaxψ(i)KI ], thus θ is also a ψ-expansion of σ. Therefore we have JϕθKI = Jϕ′θKI , hence JϕθKI[κ/i] = Jϕ′θKI[κ/i] (since ϕθ and ϕ′θ do not contain i). Consequently, by the induction hypothesis, we haveJψ′KI[κ/i] = Jψ′[ϕ′/ϕ]KI[κ/i]. Hence I |= ψ iff for every integer κ ∈ [JaKI , JbKI ] we have I[κ/i] |= ψ′[ϕ′/ϕ] i.e. iff I |= ψ[ϕ′/ϕ]. The proof is similar if ψ = ∨b i=a ψ ′.\nLemma 4.11 For every schema ϕ and for every indexed proposition p that does not contain any variable bound in ϕ:\nϕ ≡ (p ∧ ϕ[⊤/p]) ∨ (¬p ∧ ϕ[⊥/p])"
    }, {
      "heading" : "Proof",
      "text" : "We have p ∨ ¬p ≡ ⊤ hence by distributivity ϕ ≡ (p ∧ ϕ) ∨ (¬p ∧ ϕ). We now show that for every interpretation I, Jp∧ϕKI = Jp∧ϕ[⊤/p]KI . If JpKI = F then both p∧ϕ and p∧ϕ[⊤/p] are false in I. Otherwise, by Lemma 4.10, we have JϕKI = Jϕ[⊤/p]KI . Similarly, we haveJ¬p ∧ ϕKI = J¬p ∧ ϕ[⊥/p]KI . Hence ϕ ≡ (p ∧ ϕ[⊤/p]) ∨ (¬p ∧ ϕ[⊥/p]). Theorem 4.12 Let ϕ be a normalized bound-linear schema. ϕ is satisfiable iff ϕ ↓τ is satisfiable."
    }, {
      "heading" : "Proof",
      "text" : "The proof is by inspection of the different rules (see the definition of the rules for the notations):\n• τ1. The proof is a direct application of Lemma 4.11.\n• τ2. For every model I of ψ, one can construct an interpretation J of (p ⇔ Πbi=aϕ) ∧ ψ[p/Πbi=aϕ] by interpreting p as JΠbi=aϕKI . By definition we have J |= (p ⇔ Πbi=aϕ).\nSince I |= ψ we have J |= ψ. By Lemma 4.10 we deduce that I |= ψ[p/Πbi=aϕ]. Hence J |= (p ⇔ Πbi=aϕ) ∧ ψ[p/Πbi=aϕ]. Conversely, if I is a model of (p ⇔ Πbi=aϕ)∧ψ[p/Πbi=aϕ], then due to the first conjunct Πbi=aϕ and p have the same truth value in I hence since I |= ψ[p/Πbi=aϕ], we deduce I |= ψ, by Lemma 4.10.\n• τ3. Assume that I |= ϕ. Let J be the extension of I obtained by interpreting pκ asJ∨b+κi=a ψKI . By Lemma 4.10 we have J |= (ϕ[pj/∨b+ji=a ψ]). Furthermore by definition of the semantics, we have J∨b+κi=a ψKI = F if Jb+κ−aKI < 0 hence J |= ¬pκ if κ < a−b. Thus J |= ¬pa−b−1∧ ∧a−b−1 j=minϕ(j)\n(pj ⇔ pa−b−1). Furthermore, for every ι ≥ Ja−bKI , we have J∨b+ιi=a ψKI = T iff either J∨b+ι−1i=a ψKI = T or Jψ[b+ι/j]KI = T. Hence JpιKI = T iff either Jpι−1KI = T or Jψ[b+ ι/j]KI = T. Therefore I |= ∧maxϕ(j)j=a−b (pj ⇔ (pj−1∨ψ)). Conversely, let I be a model of ¬pa−b−1 ∧ ∧a−b−1 j=minϕ(j) (pj ⇔ pa−b−1) ∧ ∧maxϕ(j)\nj=a−b (pj ⇔ (pj−1 ∨ ψ[b + j/i])) ∧ (ϕ[pj/ ∨b+j i=a ψ]). We show by induction on ι that I |= (pι ⇔∨b+ι\ni=a ψ) for every ι ∈ [Jminϕ(j)KI , Jmaxϕ(j)KI ]: – If ι < Ja − bKI then by definition J∨b+ιi=a ψKI = F. Moreover by the first two\nconjuncts in the previous formula we must have JpιKI = F. – Otherwise, we have J∨b+ιi=a ψKI = J∨b+ι−1i=a ψ∨ψ[b+ι/i]KI . Hence by the induction\nhypothesis: J∨b+ιi=a ψKI = Jpι−1KI ∨ ψ[b + ι/i], and by the third conjunct in the formula above, we get: J∨b+ιi=a ψKI = JpιKI .\nThen by Lemma 4.10 we deduce that I |= ψ. The proofs for the rules τ ′3, τ4 and τ ′4 are similar.\n• τ5. Assume that Π = ∨ (the case Π = ∧ is similar). By definition I |= ∨γ.n+ϵ\ni=α.n+β ϕ iff there exists κ ∈ [Jα.n+ βKI , Jγ.n+ ϵKI ] such that I |= ϕ[κ/i], i.e. iff there exists κ ∈ [JβKI , J(γ−α).n+ϵKI ] such that I |= ϕ[κ+Jα.nKI/i], i.e. iff I |= ∨(γ−α).n+ϵi=β ϕ[i+α.n/i].\n• τ6. We assume that Π = ∨ and ⋄ = ⊥ (the case Π = ∧, ⋄ = ⊤ is similar). Since we assume that I(n) ≥ 0 for every parameter n, we have I |= (n = 0∨ . . .∨n = κ∨n > κ) hence ψ is equivalent to: (n = 0 ∨ . . . ∨ n = κ ∨ n > κ) ∧ ψ. By distributivity we get ψ ≡ (n = 0∧ψ)∨ . . . (n = κ∧ψ)∨(n > κ∧ψ). But ∨α.n+β i=γ ϕ is empty (thus equivalent\nto ⊥) if I(n) > κ ≥ γ−βα , hence, by Lemma 4.10, we have ψ ≡ (n = 0 ∧ ψ) ∨ . . . (n = κ ∧ ψ) ∨ (n > κ ∧ ψ[⊥/ ∨α.n+β i=γ ϕ]). For every ι ∈ [0, κ], we have n = ι ∧ ψ |= [ψ]n 7→ι,\nhence ψ |= [ψ]n 7→0 ∨ . . . ∨ [ψ]n7→κ ∨ (n > κ ∧ ψ[⊥/ ∨α.n+β i=γ ϕ]). Conversely, if I |= [ψ]n 7→ι holds, then I can be straightforwardly extended into a model of n = ι∧ψ by interpreting n as ι. Thus for any model of [ψ]n 7→0∨ . . .∨ [ψ]n 7→κ∨ (n > κ ∧ ψ[⊥/ ∨α.n+β i=γ ϕ]) there exists a model of ψ, and τ6 preserves satisfiability.\n• τ7. Again, we assume that Π = ∨\nand ⋄ = ⊥. We have ((α−1).n+β < γ∨(α−1).n+ β ≥ γ) ≡ ⊤ hence ψ ≡ ((α−1).n+β < γ ∨ ((α−1).n+β ≥ γ)∧ψ ≡ ((α−1).n+β ≥ γ ∧ ψ) ∨ ((α − 1).n + β < γ ∧ ψ). Since the parameters are interpreted as natural\nnumbers, we have I |= (α − 1).n + β < γ iff I(n) ∈ [0, ⌈γ−βα−1⌉]. Then by definitionJψKI = J[ψ]n 7→I(n)KI . If I |= (α − 1).n + β ≥ γ then, by unfolding, J∨α.n+βi=γ ϕKI =J∨(α−1).n+βi=γ ϕ ∨ ∨α.n+βi=(α−1).n+β+1 ϕKI = J∨(α−1).n+βi=γ ϕ ∨ ∨ni=1 ϕ[i + (α − 1).n + β/i]KI . Hence τ7 preserves satisfiability.\n• τ8: the proof is similar to the one of τ6.\n• The soundness of the rule τ9 is a direct consequence of Lemma 4.8. • τ10. We assume that Π = ∨ and ⋄ = ⊥. We have ∨n−β i=α ϕ ≡ (n < α+β∧ ∨n−β\ni=α ϕ)∨(n ≥ α + β ∧ ∨n−β i=α ϕ). For every interpretation I, if I(n) < α + β then J∨n−βi=α ϕKI = F\nthus n < α + β ∧ ∨n−β i=α ϕ ≡ (n < α + β ∧ ⋄). If I(n) ≥ α + β, then J∨n−βi=α ϕKI ≡Jϕ[α/i] ∨ ∨n−βi=α+1 ϕKI . Furthermore by translation of the iteration counter we have∨n−β i=α+1 ϕ ≡ ∨n−β′ i=α+1−β′+β ϕ[i+ β ′ − β/i]. Hence τ10 preserves equivalence.\nTheorem 4.13 Let ϕ be a normalized bound-linear schema. ϕ ↓τ is regular."
    }, {
      "heading" : "Proof",
      "text" : "Firstly, we remark that the application of the rules in τ on a bound-linear schema generates a schema that is still bound-linear. Notice however that the obtained schema is not normalized in general.\nLet ϕ be a bound-linear formula, irreducible by τ . Assume that ϕ has been obtained from a normalized schema by application of the rules in τ . We need to prove that ϕ is regular.\nWe first prove that ϕ contains no nested iteration. Let ψ = Πbi=aχ be an iteration occurring in ϕ. Assume that χ contains an iteration Γdj=cγ. W.l.o.g. we assume that γ contains no iteration (otherwise we could simply take ψ = χ). By irreducibility w.r.t. the rule τ1, all the indices in γ must contain j. By definition of the class of bound-linear schemata, this implies that these indices cannot contain i. If j occurs in d then one of the rule τ3,τ ′ 3, τ4 or τ ′ 4 applies. Consequently the only free variable in Γ d j=cγ is n. Thus the rule τ2 applies which is impossible by irreducibility.\nThen we remark that for all iterations Πbi=aψ in ϕ, a ∈ Z and b is of the form n + α where α ∈ Z. Indeed, if a contains n then the rule τ5 applies and if the coefficient of n in b is different from 1 then the rule τ6 or τ7 applies.\nThe rule τ8 eliminates all indexed propositions in which the coefficient of n is odd (since the initial schema is normalized, these indexed variables have been necessarily introduced by the rule τ7, thus they must occur in an iteration and all the indices in the iteration must have an odd coefficient in front of n).\nτ9 eliminates all the variables of the form p2α.n±a, where α ∈ Z and a ∈ Ni∪N, for some bound variable i, and replaces them by variables indexed only by a.\nFinally τ10 ensures that all the iterations have the same bounds."
    }, {
      "heading" : "5. STAB: A Decision Procedure for Regular Schemata",
      "text" : "Now that we have shown how to transform a bound linear schema into a regular one, we show that the satisfiability problem is decidable for regular schemata. This is done by providing a set of block tableaux rules (Smullyan, 1968) that are complete w.r.t. satisfiability. Those rules are concise and natural, and, compared to the naive procedure described in the proof of Proposition 2.7, they are much more efficient and terminate more often (see the end of Section 5.1). The procedure is called stab (standing for schemata tableaux). Notice that it applies on any schema (not only on regular ones). We assume (w.l.o.g) that schemata are in negative normal form."
    }, {
      "heading" : "5.1 Inference Rules",
      "text" : "Definition 5.1 (Tableau) A tableau is a tree T s.t. each node N occurring in T is labeled by a set of schemata written ΦT (N).\nAs usual a tableau is generated from another tableau by applying some extension rules. Let r = P\nC1 . . . Cκ be a rule where P denotes a set of schemata (the premises), and\nC1, . . . , Cκ denote the conclusions. Let N be a leaf of a tree T . If a subset S of ΦT (N) matches P then we can extend the tableau by adding κ children to N , each of them labeled with Cισ ∪ (ΦT (N) \\ S) where ι = 1, . . . , κ and σ is the matching substitution. A leaf N is closed iff the set of arithmetic formulae (i.e. schemata containing only atoms of the form . . . < . . . and no iteration) in ΦT (N) is unsatisfiable. This can be detected using decision procedures for arithmetic without multiplication (Cooper, 1972).\nDefinition 5.2 (Extension rules) The extension rules of stab are defined as follows.\n• The usual rules of propositional tableaux:\n(∧): ϕ ∧ ψ\nϕ ψ (∨):\nϕ ∨ ψ\nϕ ψ\n• Rules proper to schemata (“iteration rules”)6:\n(Iterated ∧):\n∧b i=a ϕ\nb ≥ a∧b−1 i=a ϕ ∧ ϕ[b/i]\nb < a (Iterated ∨):\n∨b i=a ϕ\nb ≥ a∨b−1 i=a ϕ ∨ ϕ[b/i]\n6. The right branch in the conclusion of the Iterated ∧ rule is required, e.g., to detect that ∧n\ni=1 ⊥ is satisfiable with n = 0.\n• The closure rule adds the constraints needed for the branch not to be closed. The rule is applied only if a ̸= b does not already occur in the branch.\n(Closure):\npa ¬pb pa,¬pb, a ̸= b\nstab without the loop detection rule described in the next section is already better than the straightforward procedure introduced in the proof of Proposition 2.7. First, it terminates in some cases where the schema is unsatisfiable (whereas the naive procedure never terminates in such a case, unless the schema is just an unsatisfiable propositional formula). This is trivially the case for any schema ∧n i=1 ϕ with n ≥ 1, where ϕ is propositionally unsatisfiable. Second, it can find a model much faster than the naive procedure. Consider, e.g., ( ∧10000 i=n p)∧(¬p∨ϕ) where ϕ is an unsatisfiable formula. In this case stab immediately finds a model where n > 10000 and p is interpreted as F.\nRemark 5.3 Using a tableaux-based system for deciding regular schemata may seem surprising, since DPLL procedures (Davis, Logemann, & Loveland, 1962) are usually more efficient in propositional logic. However, extending such procedures to schemata is not straightforward. The main problem is that evaluating an atom in a schema is not immediate, since this atom may well appear in some realization of the schema without appearing in the schema itself. Thus, in contrast to the propositional case, it is not sufficient to replace syntactically the atom by its truth value. For instance, the atom p2 (implicitly) appears in the schema ∨n i=1 pi if\nn > 1. Thus evaluating p2 to, say, F would yield two distinct branches: ( ∨n\ni=1 pi) ∧ n ≤ 1 and (p1 ∨ ∨n i=3 pi)∧n > 1. Thus one would have to define rules operating at deep positions in the schema in order to unfold the iterations and instantiate the counter variables when needed. In contrast, the tableaux method operates only on formulae occurring at root level and compares literals only after they have been instantiated (using unfolding). This makes the procedure much easier to define and reason with (in particular the termination behavior is easier to control). Actually a DPLL procedure for schemata is presented in our previous work (Aravantinos, Caferra, & Peltier, 2009a, 2010), but it is much more complicated than the calculus presented here.\nOf course, one could combine the iteration rules of the tableaux procedure with a SATsolver used as a “black box” that could be in charge of the purely propositional part. However this is also not straightforward, mainly due to the fact that a partial evaluation is needed to propagate the values of the propositional variables into the iterations."
    }, {
      "heading" : "5.2 Discarding Infinite Derivations: the Looping Rule",
      "text" : "stab does not terminate in general. The reason is that an iteration is, in general, infinitely unfolded by the iteration rules. Assume for instance that ϕ is a propositional unsatisfiable formula. Then starting from ∨n i=1 ϕ one could derive an infinite sequence of formulae of the\nform ∨n−1 i=1 ϕ, . . . , ∨n−κ\ni=1 ϕ, for every κ ∈ N. We now introduce a loop detection rule that aims at improving the termination behavior of stab. Detecting looping is the most natural way to avoid this divergence: if, while extending the tableau, we find a schema that has already been seen, possibly up to a shift of arithmetic variables, then there is no need to\nconsider it again and we can stop the procedure. Such loopings can also be interpreted as well-foundedness arguments in an inductive proof.\nDefinition 5.4 (Looping) A shift is a substitution mapping every variable n to an expression of the form n− ι, where ι ∈ N s.t. there is at least one variable n s.t. nσ < n (which is not always the case since we may have ι = 0).\nIf I,J are two interpretations, we write I < J iff there exists a shift σ s.t. J = Iσ. Let ϕ, ψ be two schemata (or sets of schemata). We write ϕ |=s ψ iff for every model I\nof ϕ, there exists J < I s.t. J |= ψ. Let N,N ′ be two nodes of a tableau T . Then N ′ loops on N iff ΦT (N ′) |=s ΦT (N).\nIn existing work on cyclic proofs, N ′ is sometimes called a bud node and N is the companion node of N ′ (Brotherston, 2005). When a leaf loops, it is treated as a closed leaf (though it is not necessarily unsatisfiable). To distinguish this particular case of closed leaf from the usual one, we say that it is blocked (blocked leaves are closed). Notice that N and N ′ may be on different branches, thus looping may occur more often, allowing more simplifications.\nExample 5.5 Let Φ = { ∨n i=1 pi} and Ψ = { ∨n i=2 qi}. Intuitively, Φ and Ψ have the same “structure”: stab will behave similarly on both formulae. The relation |=s is supposed to formalize this notion. We show on this example that it is the case, as expected, i.e. that we have Ψ |=s Φ. Indeed, consider a model I of Ψ. We construct an interpretation J as follows: J (n) def= I(n) − 1 and for every κ ∈ [1,J (n)], J (pκ) def = I(qκ+1). Since I |= Ψ there exists κ ∈ [2, I(n)] such that I(qκ) = T. Thus there exists κ ∈ [1, I(n)−1] such that I(qκ+1) = T, i.e. there exists κ ∈ [1,J (n)] such that J (pκ) = T. Therefore J |= Φ.\nProposition 5.6 Let ϕ be a schema. If ϕ is satisfiable then ϕ has a model I that is minimal w.r.t. < (i.e. for every interpretation J , if J < I then J ̸|= ϕ)."
    }, {
      "heading" : "Proof",
      "text" : "Let V be the set of parameters of ϕ. Notice that V is finite. For every interpretation I we denote by I(V ) the integer: I(V ) def= Σn∈V I(n). Since we assumed that I(n) ∈ N for every variable n, we deduce that I(V ) ≥ 0.\nLet I be a model of ϕ such that I(V ) is minimal. Since the truth value of ϕ does not depend on the values of the variables that are not in V , we may assume that ∀n ̸∈ V, I(n) = 0. Let J be a model of ϕ such that J < I. By definition there exists a shift σ such that J = Iσ. For every arithmetic variable n, we have nσ = n− ιn, where ιn ∈ N; furthermore, there exists at least one variable m such that ιm > 0. Thus J (n) = I(σ(n)) ≤ I(n) and J (m) < I(m). Consequently we must have J (V ) ≤ I(V ), thus J (V ) = I(V ) (since I(V ) is minimal). By definition, this entails that ιn = 0 for every n ∈ V . Thus m ̸∈ V , but in this case I(m) = 0 hence J (m) < 0 which is impossible (since we assume that parameters are interpreted by natural numbers).\nTo apply the looping rule in practice one has to find a shift and check that the implication holds. Unfortunately, the relation |=s is obviously undecidable (for instance if ψ = ⊥, then\nit can be easily checked that ϕ |=s ψ iff ϕ is unsatisfiable, and as we shall see in Section 6 the satisfiability problem is undecidable for propositional schemata). Thus, in the following, we shall use a much stronger criterion that is sufficient for our purpose. An obvious solution would be to use set inclusion: indeed, ϕ |=s ψ if there exists a shift σ s.t. ϕ ⊇ ψσ. However, this criterion is too strong, as the following example shows.\nExample 5.7 The schema ϕ = pn ∧ (pn ⇒ qn) ∧ ¬q0 ∧ ∧n i=1(qi ⇒ qi−1) is obviously unsatisfiable. The reader can easily check that stab generates an infinite sequence of sets of schemata of the form:\n{pn, qn,¬q0, qn−1, . . . , qn−κ, n−κ∧ i=1 (qi ⇒ qi−1)}, where κ ∈ N\nNone of these sets contains a previous one up to a shift on n because of the indexed proposition pn that must occur in every set.\nThus we introduce a refinement of set inclusion based on the purity principle. The pure literal rule is standard in propositional theorem proving. It consists in evaluating a literal L to ⊤ in a formula ϕ (in NNF) if the complement of L does not occur in ϕ. Such a literal is called pure. It is well-known that this operation preserves satisfiability and may allow many simplifications.\nWe show how to extend the pure literal rule to schemata. The conditions on L have to be strengthened in order to take iterations into account. For instance, if L = pn and ϕ contains ∨2n i=1 ¬pi then L is not pure in ϕ, since ¬pi is the complement of L for i = n (and since 1 ≤ n ≤ 2n). On the other hand p2n+1 may be pure in ϕ (since 2n+ 1 ̸∈ [1, 2n]). For every set of schemata Φ we denote by ΦN the conjunction of purely arithmetic formulae in Φ: ΦN def = ∧ ϕ∈Φ,ϕ is arithmetic ϕ. 7\nDefinition 5.8 (Pure literal) A literal pa (respectively ¬pa) is pure in a set of schemata Φ iff for every occurrence of a literal ¬pb (respectively pb) in Φ, the arithmetic formula ΦN ∧IC (Φ)∧a = b is unsatisfiable8.\nDefinition 5.9 Let Φ,Ψ be two sets of schemata. We write Φ ⊇s Ψ iff there exists a shift σ for the set of parameters in Φ and Ψ s.t. for every ψ ∈ Ψ:\n• Either ψ is an arithmetic formula and ΦN |= ψσ.\n• Or ψ is a pure literal in Ψ.\n• Or ψσ ∈ Φ.\nThe first and third items correspond roughly to set inclusion (up to arithmetic properties). The second item only deals with Ψ and not with Φ. It corresponds to the informal idea that a pure literal can be removed. Of course it is the most important one.\n7. A possible improvement would be to add in ΦN formulae that are obvious logical consequences of Φ. For instance, if Φ = {pn ∧ (n > 1),¬p1} then ΦN would contain n > 1. This would make the notion of ‘pure literal’ slightly more general, e.g., pn would be pure in Φ, which is not the case with our current definition. 8. See page 606 for the definition of IC (Φ).\nExample 5.10 Let Ψ = {n ≥ 0, pn+1, pn, ∧n i=1(¬pi ∨ pi−1),¬p0} and Φ = {n ≥ 1, pn−1, ∧n−1 i=1 (¬pi ∨ pi−1),¬p0}. We have Φ ⊇s Ψ. Indeed, consider the shift σ = {n 7→ n − 1}. By definition ΦN = {n ≥ 1}. We have (n ≥ 0)σ = n − 1 ≥ 0 ≡ n ≥ 1, thus ΦN |= (n ≥ 0)σ. Since n ≥ 0 and i ∈ [1, n], pi cannot be identical to pn+1, thus pn+1 is pure in Ψ. Finally, we have pnσ = pn−1 ∈ Φ and ∧n i=1(¬pi ∨ pi−1)σ = ∧n−1 i=1 (¬pi ∨ pi−1) ∈ Φ.\nWe now show that ⊇s is decidable. First of all, it is trivial that syntactic equality is decidable as shown by the following definition and proposition:\nDefinition 5.11 Let U(ϕ, ψ) be the arithmetic formula defined as follows:\n• If ϕ = pa and ψ = pb then U(ϕ, ψ) def = (a = b).\n• If ϕ = (a ▹ b) and ψ = (c ▹ d) (with ▹ ∈ {≤, <}) then U(ϕ, ψ) def= (a = c) ∧ (b = d).\n• If ϕ = ¬ϕ′ and ψ = ¬ψ′ then U(ϕ, ψ) = U(ϕ′, ψ′).\n• If ϕ = (ϕ1πϕ2) (with π ∈ {∨,∧}) and ψ = (ψ1πψ2) then U(ϕ, ψ) = U(ϕ1, ψ1) ∧ U(ϕ2, ψ2).\n• If ϕ = Πbi=aϕ′ and ψ = Πdi=cψ′ then U(ϕ, ψ) def = (a = c) ∧ (b = d) ∧ U(ϕ′, ψ′).\n• Otherwise U(ϕ, ψ) def= ⊥.\nProposition 5.12 Let ϕ, ψ be two schemata. For every substitution σ, U(ϕ, ψ)σ is valid iff ϕσ and ψσ are syntactically identical."
    }, {
      "heading" : "Proof",
      "text" : "By a straightforward induction on the formulae.\nWe can prove the decidability of ⊇s:\nProposition 5.13 ⊇s is decidable."
    }, {
      "heading" : "Proof",
      "text" : "Since linear arithmetic is decidable, it is possible to check whether a literal is pure or not in a set of formulae Ψ. Then these pure literals can be simply removed from Ψ (since they satisfy the second condition in Definition 5.9). One now has to find a shift σ such that every remaining formula in Ψ satisfies the first or third condition. Let n1, . . . , nκ be the variables in Φ,Ψ. Let σ be a substitution mapping every parameter nι (1 ≤ ι ≤ κ) to nι − lι, where the lι are distinct variables not occurring in Φ,Ψ. One has to check that there exists a substitution θ mapping every variable lι to an integer such that:\n• ∀ι ∈ [1, κ], θ(lι) ≥ 0 and ∃ι ∈ [1, κ], θ(lι) > 0. Since κ is fixed, this condition can be stated as an arithmetic formula.\n• For every formula ψ ∈ Ψ, one of the following conditions holds:\n– ψ is an arithmetic formula and ΦN |= ψσθ, i.e. the formula ∀n1, . . . , nκ.ΦN ⇒ ψσθ is valid.\n– ψσθ occurs in Φ. This holds iff Φ contains a formula ϕ, such that ψσθ and ϕ are identical for every value of the parameters, i.e., by Proposition 5.12, iff ∀n1, . . . , nk.U(ϕ, ψσθ) is valid.\nSince every condition above is equivalent to an arithmetic formula, the whole condition can be expressed as an arithmetic formula (taking the conjunction of the formulae corresponding to each ψ ∈ Ψ and ϕ ∈ Φ). This formula is satisfiable iff there exists a substitution θ satisfying the desired property. Then the proof follows straightforwardly from the decidability of linear arithmetic.\nNow we prove that ⊇s is stronger than the relation |=s. Proposition 5.14 Let Φ,Ψ be two sets of schemata. If Φ ⊇s Ψ then Φ |=s Ψ."
    }, {
      "heading" : "Proof",
      "text" : "Let σ be the shift satisfying the conditions of Definition 5.9. Let I be an interpretation satisfying Φ. Let θ = σI . We have to show that there exists J < I s.t. J |= ψ, i.e. that there exists a shift σ′ s.t. J = Iσ′ and J |= ψ. Equivalently, we can show that there exists a model J of ψσ, i.e. that σ′ = σ is convenient. Let J be an interpretation s.t. J (L) = T if L is a literal that is pure in Ψσ and J (L) def= I(L) otherwise. Let ψ ∈ Ψ. We have to show that J |= ψσ. We distinguish three cases, according to the three items in Definition 5.9.\n• If ΦN |= ψσ, then since I |= Φ and since J and I coincide on every arithmetic variable we must have J |= ψσ.\n• If ψ is a literal pure in Ψ then ψσ is pure in Ψσ, thus we have J |= ψσ by definition.\n• If ψσ ∈ Φ, then I |= ψσ. Thus every literal that is pure in Φ must be pure in ψσ. The complementary of these literals cannot occur in [ψσ]θ. Since I and J coincide on all other literals and since ψ is in negative normal form, we must have J |= ψσ.\nConsequently J |= ψσ, hence J σ |= ψ.\n⊇s is strictly less general than |=s as evidenced by the following: Example 5.15 Let Φ = { ∨n i=1 pi} and Ψ = { ∨n i=2 pi}. We have shown that Ψ |=s Φ (see Example 5.5).\nHowever, we have Ψ ̸⊇s Φ, since there is no shift σ such that ( ∨n i=1 pi)σ = ∨n\ni=2 pi (this is obvious since 1σ cannot be equal to 2 whatever is σ)."
    }, {
      "heading" : "5.3 Examples",
      "text" : "Before proving the soundness, completeness and termination of stab, we provide some examples of tableaux."
    }, {
      "heading" : "5.3.1 A Simple Example",
      "text" : "Let ϕ be the following formula: (n ≥ 0) ∧ p0 ∧ ∧n\ni=1(¬pi−1 ∨ pi) ∧ ¬pn. We construct a tableau for ϕ. First the ∧-rule applies to transform the conjunction into a set of schemata. The closure rule applies on pn and p0, yielding the constraint n ̸= 0. Then the iteration rule applies on the schema ∧n i=1(¬pi−1∨ pi), yielding two branches. The first one corresponds to the case in which the iteration is non empty and can be unfolded, yielding ∧n−1 i=1 (¬pi−1∨pi) and ¬pn−1∨pn and the second one corresponds to the case where the iteration is empty (hence true), yielding the constraint n < 1. The latter branch can be closed immediately due to the constraints n ≥ 0 and n ̸= 0. In the former branch, the ∨-rule applies on the formula ¬pn−1 ∨ pn, yielding two branches with ¬pn−1 and pn respectively. The closure rule applies on the latter one, yielding the unsatisfiable constraint n ̸= n hence the branch can be closed. The last remaining branch loops on the initial one, with the shift n 7→ n−1. The obtained tableau is depicted in Figure 2. Closed leaves (resp. blocked leaves looping on α) are marked by × (resp. (α)). Only new (w.r.t. the previous block) formulae are presented in the blocks.\n5.3.2 n-Bit Adder\nIn this section we provide a slightly more complicated example. We use stab to prove a simple property of the n-bit Adder defined in the Introduction. We aim at proving that A + 0 = A. A SAT-solver can easily refute this formula for a fixed n (say n = 10). We prove it for all n ∈ N. This simple example has been chosen for the sake of readability and conciseness, notice that commutativity or associativity of the n-bit adder could be proven too (see Section 5.7).\nWe express the fact that the second operand is null: ∧n\ni=1 ¬qi, and the fact that the result equals the first operand: ∧n i=1(pi ⇔ ri), which gives ∨n i=1(pi ⊕ ri) by refutation. So\nwe want to prove that Adder ∧ ∧n i=1 ¬qi ∧ ∨n\ni=1(pi ⊕ ri) is unsatisfiable. Notice that this schema is regular.\nThe corresponding tableau is sketched in Figure 3. Sequences of propositional extension rules are not detailed.\nExplanations. The first big step decomposes all the iterations. The branching is due to ∨n i=1 pi ⊕ ri: first we have pn ⊕ rn, then ∨n−1 i=1 pi ⊕ ri. The right branch loops after a\nfew steps as all iterated conjunctions ∧n i=1 . . . contain ∧n−1\ni=1 . . . The left one is extended by propositional rules (the reader can easily check that Sumn, Carryn, pn ⊕ rn and ¬qn indeed lead to the presented branches, notice that cn must hold, otherwise we would have pn ⇔ rn).\nIn (2) we start by decomposing all iterations a second time. Iterations are aligned on [1, n − 1] so they all introduce the same constraints i.e. either n − 1 ≥ 1 (first branch) or n − 1 < 1 (second branch). In the second case, the introduced constraint implies that n = 1, thus cn = c1 which closes the branch. In the first case we decompose Carryn−1 and consider the various cases. Two of them are trivially discarded as they imply qn−1, whereas we easily obtain ¬qn−1 by an unfolding of ∧n i=1 ¬qi. It only remains one case which is easily seen to loop on (2). The branch (2′) is very similar to (2)."
    }, {
      "heading" : "5.4 Soundness and Completeness",
      "text" : "A leaf is irreducible if no extension rule applies to it. A derivation is a (possibly infinite) sequence of tableaux (Tι)ι∈I s.t. I is either [0, κ] for some κ ≥ 0, or N and s.t. for all ι ∈ I \\ {0}, Tι is obtained from Tι−1 by applying one of the extension rules. A derivation is fair if either there is ι ∈ I s.t. Tι contains an irreducible not closed leaf or if for all ι ∈ I and every not closed and not blocked leaf N in Tι there is λ ≥ ι s.t. a rule is applied on N in Tλ (i.e. no leaf can be “freezed”).\nDefinition 5.16 (Tableau Semantics) For every node N in a tableau T , ΦT (N) is interpreted as the conjunction of its elements. T is satisfied in an interpretation I iff there exists a leaf N in T s.t. I |= ΦT (N).\nLemma 5.17 If T ′ is a tableau obtained by applying one of the extension rules on a leaf N of a tableau T then I |= ΦT (N) iff there exists a leaf N ′ of T ′ s.t. N ′ is a child of N in T ′ and I |= ΦT ′(N ′) (i.e. the rules are sound and invertible)."
    }, {
      "heading" : "Proof",
      "text" : "Obvious, by inspection of the extension rules.\nLemma 5.18 If a leaf N in T is irreducible and not closed then T is satisfiable."
    }, {
      "heading" : "Proof",
      "text" : "Let Ψ be the set of arithmetic formulae in ΦT (N) and Φ def = ΦT (N) \\Ψ. As N is not closed Ψ is satisfiable (by definition), so let σ be a solution of Ψ. If Φ contains a formula ϕ that is not a literal, one of the extension rules applies and deletes ϕ, which is impossible. Let cT (N) be the number of pairs pa, ¬pb ∈ ΦT (N) s.t. there is an interpretation I validating Ψ s.t. JaKI = JbKI . If cT (N) ̸= 0, then the closure rule applies on pa, pb which is impossible. Hence cT (N) = 0 and in particular this implies that Φσ is propositionally satisfiable (i.e. contains no pair of complementary literals). Thus ΦT (N)σ is satisfiable and by definition T is satisfiable.\nTheorem 5.19 (Soundness and Completeness w.r.t. Satisfiability) Let (Tκ)κ∈I be a derivation.\n• If there exists ι ∈ I s.t. Tι contains an irreducible, not closed leaf then T0 is satisfiable.\n• If the derivation is fair and if T0 is satisfiable then there exist ι ∈ I and a leaf in Tι that is irreducible and neither closed nor blocked."
    }, {
      "heading" : "Proof",
      "text" : "The first item (i.e. soundness) follows from Lemmata 5.17 and 5.18.\nWe now prove that the procedure is complete w.r.t. satisfiability (the second item). Let I be an interpretation and ϕ a schema. We define mI(ϕ) as follows:\n• mI(ϕ) def = 0 if ϕ is an arithmetic atom (i.e. an atom of the form . . . < . . .).\n• mI(ϕ) def = 1 if ϕ is an indexed proposition or its negation, or ϕ is ⊤ or ⊥.\n• mI(ϕ1 ⋆ ϕ2) def = mI(ϕ1) +mI(ϕ2) if ⋆ ∈ {∨,∧}. • mI(Πbi=aϕ) def = 2 if JbKI < JaKI\n• mI(Πbi=aϕ) def = β − α+ 2+Σβι=αmI[ι/ı](ϕ) where Π ∈ { ∧ , ∨ }, α = JaKI , β = JbKI , and\nβ ≥ α.\nIf Φ is a set, then mI(Φ) def = {mI(ϕ) | ϕ ∈ Φ}. If T is a tableau and N is a leaf in T then mI(N, T ) def = (mI(ΦT (N)), cT (N)) where cT (N) is defined in the proof of Lemma 5.18. This measure is ordered using the multiset and lexicographic extensions of the usual ordering on natural numbers. Thus, it is obviously well-founded. We need the following:\nLemma 5.20 Let I be an interpretation. Let T be a tableau. If T ′ is deduced from T by applying an extension rule on a leaf N s.t. I |= ΦT (N), then for every child N ′ of N in T ′ s.t. I |= ΦT ′(N ′), we have mI(N ′, T ′) < mI(N, T )."
    }, {
      "heading" : "Proof",
      "text" : "All the rules except the iteration rule and the closure rule replace a formula by simpler ones, hence it is easy to see that mI(ΦT (N)) decreases. The iteration rules replace an iteration of length ι either by ⊤ or by a disjunction/conjunction of an iterated disjunction/conjunction of length ι− 1, and a smaller formula. Since ι > ι− 1, mI(ΦT (N)) decreases. The closure rule does not affect mI(ΦT (N)) but obviously decreases cT (N).\nLet I be a model of T0. By Proposition 5.6, we can assume that I is minimal w.r.t the ordering < introduced in Definition 5.4.\nBy Lemma 5.17, for all ι ∈ I, Tι contains a leaf Nι s.t. I |= ΦTι(Nι). Let κ ∈ I s.t. mI(Nκ, Tκ) is minimal (κ exists since mI(Ni, Ti) is well-founded). Assume a rule is applied on Nκ in the derivation, on some tableau Tλ. By Lemma 5.17 there is a child N ′ of Nκ s.t. I |= ΦTλ(N ′). By Lemma 5.20 we have mI(N ′, Tλ) < mI(Nk, Tκ) which is impossible. Thus no rule is applied on Nκ. Assume that Nκ is blocked. Then there exists a node N ′ s.t. Nκ loops on N ′. By Definition 5.4 there exists an interpretation J s.t. J |= N ′ and\nJ <V I. But then by Lemma 5.17 (“only if” implication), J |= T0, which contradicts the minimality of I. Since the derivation is fair, Nκ is irreducible (or there is another leaf that is irreducible). Furthermore, Nκ cannot be closed since it is satisfiable (I |= ΦTκ(Nκ)).\nIt is worth emphasizing that stab is sound and complete (w.r.t. satisfiability) for any schema, not only for bound-linear or regular ones. But the termination result in the next section only holds for regular schemata."
    }, {
      "heading" : "5.5 Termination on Regular Schemata",
      "text" : "We consider the following strategy ST for applying the extension rules:\n• The propositional extension rules, the looping and closure rules are applied as soon as possible on all leaves, with the highest priority. These rules obviously terminate on any schema.\n• The iteration rules are applied only on iterations of maximal length (w.r.t. the natural partial ordering on arithmetic expressions). For instance if we have the schema∧n\ni=1 pi∨ ∨n−1 j=1 qj then the iteration rules will only apply on the first iteration ∧n i=1 pi.\n• The relation ⊇s introduced in Section 5.2 is used to block looping nodes.\nTheorem 5.21 ST terminates on every regular schema."
    }, {
      "heading" : "Proof",
      "text" : "Let α, β, γ, δ ∈ Z and ϕ be a regular schema aligned on [α, n−β], of propagation limits γ, δ. Assume that an infinite branch is constructed. By definition of the strategy, after some time, the κ last ranks of every iteration have been unfolded by the iteration rules. Thus all the remaining iterations are of the form Πn−β−κi=α ϕ\n′ and we have the arithmetic constraint n− β − κ− α+ 1 ≥ 0, i.e. n ≥ β + κ+ α− 1.\nFrom now on, we only consider nodes that are irreducible w.r.t. propositional rules. We show that a finite set of formulae are generated by stab, up to a shift on n. As a consequence the looping rule must apply, at worst when all possible formulae have been generated.\nThe arithmetic formulae occurring in the initial formula must be of the form µ.n > ν or µ.n < ν. After the last κ ranks have been unfolded, the constraint n ≥ β + κ + α − 1 must have been added. Thus if κ is sufficiently big, µ.n > ν is equivalent to ⊤ and µ.n < ν is equivalent to ⊥. Thus every arithmetic formula occurring in the initial formula is either false or redundant w.r.t. n ≥ β + κ + α − 1. The remaining arithmetic formulae must have been introduced by the closure rule (since the iterations contain no occurrence of <). They are necessarily of the form a ̸= b where a, b are arithmetic expressions (appearing as indices in some formula of the derivation). If a, b both contain n, or if a, b ∈ Z then a ̸= b is equivalent either to ⊥ or to ⊤. Thus we only consider the case in which a contains n and b ∈ Z. If a occurs in the initial formula then it must be of the form µ.n + ν for µ, ν ∈ Z. Since n ≥ β + κ + α − 1, if κ is sufficiently big, the disequation µ.n + ν ̸= b must be false. If a did not occur in the initial formula then it must come from the (κ− ι)th unfolding of some iteration, for some ι ∈ [0, κ−1]. Since (by definition of a regular schema)\nthe indices are of the form i + λ, where λ ∈ [γ, δ], the disequation is actually of the form n − β − κ + ι + λ ̸= b, where λ ∈ [γ, δ], ι ∈ [0, κ − 1] (since the iteration counter i may be replaced by n− β, n− β − 1, . . . , n− β − κ+ 1) and b occurs in the initial formula. If the previous equation is not equivalent to ⊤, then, since we have the constraint n ≥ β+κ+α−1, we must have ι ∈ [0, b− α+ 1− λ]. Hence there are finitely many such formulae, up to the translation n 7→ n− κ.\nNow, consider the non arithmetic formulae occurring in the branch. These schemata must be either iterations or literals (by irreducibility w.r.t. the propositional extension rules).\nAll the iterations are of the form Πn−β−κi=α ϕ ′, where Πn−βi=α ϕ ′ is an iteration occurring in the initial formula. Obviously, the number of such iterations is finite up to the translation n 7→ n− κ.\nThe literals occurring in the branch (but not in the scope of an iteration) are either literals of the initial schema or literals introduced by previous applications of the iteration rules. The former are indexed by expressions of the form µ × n+ ν for some µ, ν ∈ Z and the latter by n− β − κ+ ϵ, where ϵ ∈ [γ + 1, δ + κ].\nIf a literal is indexed by an expression µ×n+ν that is outside [α+γ, n−β−κ+δ], then it must be pure in every iteration, hence (by irreducibility w.r.t. the closure rule) must be pure in the node. Actually, if κ is large enough then, by the above arithmetic constraints, µ × n + ν cannot be in [α + γ, n − β − κ + δ] if µ ̸= 0. Indeed, if µ is negative, then it suffices to take κ > α+γ−νµ −β−α+1 to ensure µ×n+ ν < α+ γ, otherwise κ ≥ δ−β− ν is enough to have µ × n + ν > n − β − κ + δ (as µ, n ≥ 1). Thus every literal indexed by integer terms of this form are pure, since by definition its index cannot be unifiable with an index occurring in an iteration (after unfolding).\nSimilarly literals indexed by expressions of the form n− β− κ+ ϵ where ϵ > δ are pure, thus we may assume that ϵ ∈ [γ, δ]. Consequently there are finitely many such literals up to the shift n 7→ n− κ.\nThis implies that the number of possible schemata obtained after κ unfolding steps is finite, up to a translation of n. By the pigeonhole principle, the looping rule necessarily applies at some point in the branch, which contradicts our initial assumption that an infinite branch is constructed.\nTermination of the strategy also ensures fairness:\nLemma 5.22 Any derivation constructed by ST (applied until irreducibility) is fair."
    }, {
      "heading" : "Proof",
      "text" : "Let (Tι)ι∈I be a derivation constructed by ST. Since ST terminates, there cannot be any infinite derivation, thus I is necessarily of the form [0, κ] for some κ ∈ N. By definition, every node in Tκ is either blocked or closed or irreducible (the strategy is applied until irreducibility). If Tκ contains a not closed irreducible leaf then the proof is completed (by definition of the notion of fairness). Otherwise, consider Tι with ι ≤ κ. Let then N be a not irreducible, not closed and not blocked leaf occurring in Tι. Assume that there is no λ ≥ ι s.t. a rule is applied on N in Tλ (which would contradict our definition of fairness). This means that no extension can possibly affect N , thus N must also occur in the final tableau\nTκ (and is labeled by the same set of schemata than in Tι). Thus N must be not closed and not irreducible. Moreover it cannot be blocked in Tκ, since no rule can affect the nodes on the branch behind N . But this is impossible since the nodes in Tκ must be either blocked or closed or irreducible.\nAs an immediate corollary, we have the following:\nTheorem 5.23 The satisfiability problem is decidable for bound-linear schemata."
    }, {
      "heading" : "Proof",
      "text" : "By Theorems 4.12 and 4.13, every bound-linear schema can be transformed into a satequivalent regular one. Theorem 5.21 shows that stab terminates on every regular schema, hence by Theorem 5.19 and Lemma 5.22, stab can be used to decide the satisfiability problem for regular schemata.\nA fine analysis of the previous termination proof ensures that we can solve the satisfiability problem for regular schemata in exponential time (if natural numbers are written in unary notation). As we have seen furthermore (Theorem 4.9) that the translation of boundlinear schemata into regular ones was exponential, we can conclude that the satisfiability problem for bound-linear schemata can be solved in double exponential time."
    }, {
      "heading" : "5.6 Model Building",
      "text" : "The existence of a non closed irreducible branch ensures that the root schema is satisfiable, as shown in Theorem 4.12. The arithmetic constraints in the branch specify the possible values of the parameter. The remaining formulae must be literals, since the extension rules apply on any complex formula (in particular, there can be no iteration schema). These literals specify the truth value of propositional variables exactly as in the usual case of propositional logic (the value of the propositional variables that do not appear in the branch may be chosen arbitrarily). Since the branch is not closed, it cannot contain any pair of complementary literals.\nWe illustrate this construction by a simple example. We consider the following tableau:\npn,¬q2,¬r1, ∨n i=1(¬pi ∧ qi ∧ ri)\nn ≥ 1, ∨n−1\ni=1 (¬pi ∧ qi ∧ ri)\nn ≥ 1, ∨n−2\ni=1 ¬pi ∧ qi ∧ ri\n. . .\nn− 1 ≥ 1,¬pn−1 ∧ qn−1 ∧ rn−1\n¬pn−1, qn−1, rn−1\nn− 1 ̸= n, n− 1 ̸= 2, n− 1 ̸= 1\n(1)\nn ≥ 1,¬pn ∧ qn ∧ rn\n¬pn, qn, rn\nn ̸= n\n×\nThe branch (1) is irreducible. It contains the following formulae: pn, ¬q2, ¬r1, n−1 ≥ 1, ¬pn−1, qn−1, rn−1, n− 1 ̸= n, n− 1 ̸= 2, n− 1 ̸= 1. The value of n can be determined by finding a solution to the above arithmetic constraints. We choose for instance the solution n = 4. After instantiation we get the remaining formulae: {p4,¬q2,¬r1,¬p3, q3, r3}, which gives for instance the following interpretation of p, q and r: pκ is true iff κ = 4 and qκ, rκ are true iff κ = 3. It is easy to check that the obtained interpretation satisfies the initial schema.\nA possible extension of this simple algorithm would be, from a given tableau, to compute a symbolic representation of the whole set of models of the root schema. This set is infinite and must be defined by induction. The closed irreducible branches correspond to concrete models, or base cases, whereas the loops correspond to inductive construction rules. These rules take a model I and construct a new model J of a strictly greater cardinality (the values of the parameters increase strictly). This would require to define a formal language for denoting sets of interpretations (one could use, e.g., automata recognizing sequences of tuples of Boolean values)."
    }, {
      "heading" : "5.7 The System",
      "text" : "The decision procedure has been implemented and the program (called RegStab) is freely available on the web page http://regstab.forge.ocamlcore.org/. It is written in OCaml and was successfully tested on MacOSX (10.5), Win32 (Windows XP SP3) and GNU Linux (Ubuntu 9.04) x86 platforms. The system comes with a manual including installation and usage instructions and a description of the input syntax. Functions can be defined to make the input file more readable (see Sum(i) and Carry(i) below). Here is an input file for the adder example in Section 5.3.2.\n// A+0=A let Sum(i) := S_i <-> (A_i (+) B_i (+) C_i) in let Carry(i) := C_i+1 <-> (A_i /\\ B_i \\/ C_i /\\ A_i \\/ C_i /\\ B_i) in let Adder := /\\i=1..n (Sum(i) /\\ Carry(i)) /\\ ~C_1 in let NullB := /\\i=1..n ~B_i in let Conclusion := \\/i=1..n (A_i (+) S_i) in"
    }, {
      "heading" : "Adder() /\\ NullB() /\\ Conclusion()",
      "text" : "The software simply prints the status of the schema (satisfiable or unsatisfiable). Options are provided to get more information about the search space (number of inference rules, depth of unfolding etc.), see the manual for details. An additional tool is offered to expand the schema into a propositional formula in DIMACS format (by fixing the value of n).\nFigure 4 gives some examples of problems that can be solved by RegStab and the corresponding running times (please refer to the distribution for input files and additional information).\nHere is an example of output, proving that 0 is a neutral element for the carry-propagate adder. We ran the system in verbose mode, in which it prints some useful information about the search: number of application of extension rules, number of closed and looping leaves, unfolding depth and set of lemmata (companion nodes)."
    }, {
      "heading" : "Conjecture:",
      "text" : "(((/\\i=1..n ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i))))) /\\ ~C_1) /\\ (/\\i=1..n ~B_i)) /\\ (\\/i=1..n (A_i (+) S_i))\nApplications of tableau rules: /\\: 67 \\/: 84 (+): 38 <->: 32 ->: 0 Iterated /\\: 12 Iterated \\/: 3 ------- Total propositional rules: 221 Total iterated rules: 15\nNumber of closed leaves: 137 Number of looping leaves: 30 Number of lemmas: 4\nMaximum number of unfoldings: 3 (if this number is surprising, notice that the tableau is constructed depth-first)"
    }, {
      "heading" : "Lemmas:",
      "text" : "[\\/i=1..n (A_i (+) S_i) ; /\\i=1..n ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i)))) ; /\\i=1..n ~B_i ; ~C_1] [\\/i=1..n-1 (A_i (+) S_i) ; /\\i=1..n-1 ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i)))) ; /\\i=1..n-1 ~B_i ; ~C_n ; ~C_1] (n > 0) [/\\i=1..n-2 ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i)))) ; /\\i=1..n-2 ~B_i ; C_n-1 ; ~C_1] (n > 1) [\\/i=1..n-2 (A_i (+) S_i) ; /\\i=1..n-2 ((S_i <-> ((A_i (+) B_i) (+) C_i)) /\\ (C_i+1 <-> (((A_i /\\ B_i) \\/ (C_i /\\ A_i)) \\/ (C_i /\\ B_i)))) ; /\\i=1..n-2 ~B_i ; C_n-1 ; ~C_1] (n > 1)\nUNSATISFIABLE"
    }, {
      "heading" : "6. Undecidability Results",
      "text" : "We provide some undecidability results for two natural extensions of the class of regular schemata."
    }, {
      "heading" : "6.1 Homothetic Transformations on the Iteration Counters",
      "text" : "We consider the class of schemata Ch defined as follows.\nDefinition 6.1 Ch (h stands for “homothetic”) is the set of schemata ϕ satisfying the following properties:\n• ϕ contains at most one parameter n. • Every iteration in ϕ is of the form ∧n i=1 ϕ or ∨n i=1 ϕ, where:\n– ϕ contains no iteration.\n– Every atomic formula in ϕ belongs to {pi, p2i, pi±1, p2i±1} where p is a variable.\n• The atomic formulae occurring in ϕ but not in the scope of an iteration are of the form p0 or pn where p is a variable 9.\nCh is rather simple and very close to the class of regular schemata. There is only one parameter n, all the iterations have the same bounds 1 and n, there is no nested iteration and the indices of the symbol in P must be affine images of the iteration counter. The only difference with the regular class is that, in Ch the coefficient of the iteration counter in the indexed variables may be equal to 2 whereas it must be equal to 0 or 1 in regular schemata. Thus regular schemata only contain translations of the iteration counter, whereas Ch may involve (very simple) homothetic transformations.\nDue to this closeness, one could expect that the satisfiability problem is decidable for Ch, but the next theorem shows that this is not the case.\nTheorem 6.2 The set of unsatisfiable formulae in Ch is not recursively enumerable.\nThe proof of Theorem 6.2 is difficult and the remaining part of this section is devoted to it. More precisely, we shall prove that the Post correspondence problem can be encoded into Ch. Notice that this problem is easily encoded with general schemata (Aravantinos et al., 2009b), whereas, here, the whole difficulty of the proof lies in the strong restrictions imposed by Ch. Observe that the difficult proof is really worth it as one would easily believe that just allowing multiplication by a constant is an unsignificant change."
    }, {
      "heading" : "6.1.1 Notations",
      "text" : "We first recall some basic definitions and introduce some useful notations. Let A be an alphabet. Let κ be a natural number. Let a = (a1, . . . , aκ) and b = (b1, . . . , bκ) be two sequences of words in A∗. If w ∈ {a, b} and ι ∈ [1, κ], |wι| denotes the length of wι and wλι denotes the λ-th character of the word wι (1 ≤ λ ≤ |wι|).\n9. Notice that p0 and pn can occur in the scope of a negation.\nIf ∆ = (∆1, . . . ,∆ι) is a sequence of indices in [1, κ] and if w = (w1, . . . , wκ) is a κ-tuple of words in A∗ (where w ∈ {a, b}) we denote by w∆ the word w∆1 . · · · .w∆ι (where “.” denotes the concatenation operator). A solution of the Post correspondence problem is a sequence ∆ s.t. a∆ = b∆. The witness of this solution is the word a∆.\nFor technical convenience, we assume (this is obviously not restrictive) that κ > 1, ∆ι = κ, ∆λ ̸= κ if λ < ι and that aκ = bκ = ⊥ where ⊥ is a special character (not occurring in a1, . . . , aι−1, b1, . . . , bι−1) denoting the end of the sequence."
    }, {
      "heading" : "6.1.2 Overview of the Encoding",
      "text" : "The intuition behind the encoding is the following. We show how to encode any instance of the problem into a schema ϕ so that ϕ is satisfiable iff this instance has a solution. More precisely, we construct ϕ of parameter n s.t. for all κ ∈ N , ϕ[κ/n] is satisfiable iff there is a solution of length κ.\nWe first present the encoding used to represent the potential solutions a∆ and b∆; then we will see how to check that those are really solutions. We represent the potential solution w∆ (where w = a, b) by a one-dimensional array of length n. More precisely, we do not store the characters themselves but rather, for each character, a pair containing the index ∆ν of the word w∆ν in which it occurs and its position in this word (as we shall see this is useful to find the next character in w∆). For instance the first index should contain the pair (∆1, 1) (first word, first character). Then the next index contains either (∆1, 2) (if |w∆1 | > 1, first word, second character) or (∆2, 1) (if |w∆1 | = 1, second word, first character).\nFor example, if A = {∗, ◦, ⋆}, a = (∗◦, ⋆) and ∆ = (1, 2), then the obtained array would be the following one:\nValues (1, 1) (1, 2) (2, 1) Indices 1 2 3\nHowever, the word w∆ is not stored into consecutive indices in the array. Indeed, as we shall see, we also need to store, for each character w∆λ of the witness, the indices ∆λ+1, . . . ,∆ι of the remaining words, occurring after w∆λ in w∆. This sequence is called the tail of the potential solution. Since the length of this sequence is unbounded, it cannot be encoded simply by indexed propositions: it must be stored into the array and the simplest solution is to store these indices just after the character itself. Notice that only the indices of words are stored in the tail i.e. there is no character position. Thus we get:\nValues (1, 1) 2 (1, 2) 2 (2, 1) Indices 1 2 3 4 5\nThe easiest way to proceed would be to store the first character of the witness at position 0, the indices of the remaining words at position 1, 2, . . . , ι, then the second character of the witness at position ι + 1 etc. That way, the λ-th character of the witness would be stored at position (λ− 1)× (ι+1) and the following characters in the sequence at positions (λ−1)× (ι+1)+1, . . . , (λ−1)× (ι+1)+ ι. For any character stored in an index λ, the next character would be stored at the index λ + ι + 1. But this simple solution is not suitable because it is outside the considered class. Indeed, it requires the use of another parameter ι (the first parameter being n: the length of the array) and also the use of this parameter\nin the indices (to relate the character stored in index λ to the one at index λ+ ι), which is forbidden in the class Ch.\nThus we need to find another encoding of the previous array. The idea is to store the first character at some index µ (where µ is assumed to be greater than ι), the second character at the index 2 × µ, . . . and more generally the λ-th character at the index µ × 2λ−1. The tail of the sequence is then stored at the indices (µ + 1) × 2λ−1, . . . , (µ + ι) × 2λ−1. This encoding ensures that the index of the next character after the one at index i is simply 2.i, and such homethetic transformations are precisely those allowed for the indices in Ch.\nFinally, the array corresponding to our recurrent example is the following one (with µ = 2):\nValues (1, 1) 2 (1, 2) 2 (2, 1) Indices 1 2 3 4 5 6 7 8\nThe witness is obtained by considering the characters stored at the indices 2,4 (= 2×2) and 8 (= 2×22), namely ∗ (first character of the first word), ◦ (first word, second character), and ⋆ (second word, first character). Obviously there are “holes” in the array, they are simply ignored."
    }, {
      "heading" : "6.1.3 The Signature",
      "text" : "The array is encoded by two indexed propositions: car(w, ν, λ) and t(w, ν) (t stands for “tail”) where w ∈ {a, b}, 1 ≤ ν ≤ κ, 1 ≤ λ ≤ |wν |. The intuition behind car(w, ν, λ)l is that it holds iff the index l in the array corresponding to w∆ contains the pair (ν, λ) (representing the character wλν ). t(w, ν)l states that the index l of the array corresponding to w∆ contains ν."
    }, {
      "heading" : "6.1.4 Formal Definition of the Encoding",
      "text" : "Let n be a variable (intended to denote the unique parameter of the schema). As explained in the previous section, we store the characters in an array, at the indices µ, 2µ, 4µ, etc. Intuitively, µ should be encoded as another parameter, but only one parameter n is allowed. However, we can encode µ with a new proposition symbol in P. We first define two symbols p, q s.t. pν holds iff ν = µ and s.t. qν holds iff ν ∈ [0, µ − 1]. The first schema defines q in such a way that it holds exactly on an interval of the form [0, µ− 1]:\nq0 ∧ ¬qn ∧ n∧\ni=1\n(qi+1 ⇒ qi)\nThe last formula obviously implies that if qν holds for some ν ∈ [1..n] then it must also hold for every λ ∈ [1..ν]. Then µ is simply the first index ν such that qν does not hold (this element necessarily exists, since qn does not hold).\nThe second schema defines p such that it holds exactly on the successor of the maximal element of the interval (i.e. µ). Notice that due to the previous formula we must have µ ̸= 0 and µ ≤ n:\nn∧ i=1 [pi ⇔ (qi−1 ∧ ¬qi)]\nFor the sake of clarity, we shall denote by (λ = µ) the atom pλ and by (λ < µ) the atom qλ (this makes the formulae much more readable).\nWe then define a variable wt s.t. wtν holds iff there exists λ ∈ N s.t. ν = µ.2λ: wt stands for “witness”, because wtν holds iff ν is the index of a character in the witness of a solution, as explained before:\n∧n i=1[((i = µ) ⇒ wti) ∧ ((i < µ) ⇒ ¬wti) (1)\n∧(¬(2i+ 1 = µ) ⇒ ¬wt2i+1) ∧ (¬(2i < µ) ∧ ¬(2i = µ)) ⇒ (wti ⇔ wt2i)]\nThe first line states that wtµ holds and that wti is false if i < µ. The second line defines that value of wti for i > µ: wt2i+1 is always false (except if 2i+1 = µ) and wt2i is equivalent to wti if 2i > µ. By an easy induction on the set of natural numbers, these properties imply that wtν holds iff ∃λ.ν = µ.2λ. Notice the crucial use of the homothetic transformation here.\nThe following formula states that an index cannot represent two distinct characters (pairs) in the same sequence:\nn∧ i=1 (¬car(w, ν, λ)i ∨ ¬car(w, ν ′, λ′)i)\nfor every w ∈ {a, b}, (ν, ν ′) ∈ [1, κ]2, λ ∈ [1, |wν |], λ′ ∈ [1, |wν′ |] s.t. (ν, λ) ̸= (ν ′, λ′)\nSimilarly, we state that every index contains at most one word in each sequence:\nn∧ i=1 (¬t(w, ν)i ∨ ¬t(w, ν ′)i) for every w ∈ {a, b}, ν, ν ′ ∈ [1, κ]2, ν ̸= ν ′\nBoth initial elements of the sequences corresponding to a and b must be of the form (ν, 1) (ν is the same in both sequences and is distinct from κ, since the word |wκ| marks the end of the sequence):\nn∧ i=1 ((i = µ) ⇒ ∃ν ∈ [1, κ− 1](car(a, ν, 1)i ∧ car(b, ν, 1)i))\nWe use existential quantification over intervals of natural numbers for the sake of clarity, but these quantifiers can be easily eliminated and transformed into finite (not iterated) disjunctions.\nThe next formula defines e(w) to mark the end of the sequence corresponding to w. e(w)l should hold iff l is of the form µ.2\nλ for some λ > 0 and if the character stored at the index l is the first character of the word κ (remember that by convention aκ = bκ = ⊤ where ⊤ marks the end of the witness). Besides, we must ensure that the end of the sequence is eventually reached i.e. that there exists an index l such that e(a)l and e(b)l both hold:\nn∨ i=1 (e(a)i ∧ e(b)i) ∧ n∧ i=1 ((wti ∧ car(w, κ, 1)i) ⇔ e(w)i) (⋆)\nfor every w ∈ {a, b}\nWe also have to ensure that the two sequences (i.e. the words a∆ and b∆) are identical. It suffices to check that for every index l s.t. wtl holds (i.e. for every index l of the form µ× 2λ), the character stored in l is the same in the sequences of a and b:\nn∧ i=1 (wti ⇒ (¬car(a, ν, λ)i ∨ ¬car(b, ν ′, λ′)i)) (⋆)\nfor every ν, ν ′ ∈ [1, κ]2, λ ∈ [1, |aν |], λ′ ∈ [1, |bν′ |] s.t. aλν ̸= bλ ′ ν′\nSo far, we have ensured that at most one character and word index can be stored in every index. We have defined the starting point and the end of the two sequences and ensured that the two represented words are identical. The next (and most difficult) step is to ensure that these sequences really encode two words of the form a∆ and b∆ respectively. To this aim, we shall relate the value of the character stored in every index µ.2λ+1 to the one stored in µ.2λ, to ensure that the former is really the successor of the latter in the witness. Since each character c is represented by a pair (ν, ι) where ν denotes the index of a word in w and ι is the position of c in wν , it is easy to find the next character: if ι < |wν | (i.e. if c is not the last character in wν) then the next character is simply (ν, ι + 1) (same word wν , next position ι+1). If ι = |wν | (i.e. if c is the last character in wν) then the next character is (ν ′, 1) where ν ′ denotes the next word index in the solution sequence (word wν′ , first position).\nIn order to determine the index word ν ′ we use the fact that (as explained in the informal overview above) the remaining indices in the solution are stored in the index µ.2λ + 1, µ.2λ + 2, . . .. Thus, we simply need to pick up the first element of this sequence.\nAfter checking that the character stored at µ.2λ+1 is the successor of the one in µ.2λ it remains to ensure that the indices stored at µ.2λ+1 + 1, µ.2λ+1 + 2,. . . correspond to the remaining part of the solution. If ι < |wν | then the sequence must actually be identical to the one stored at µ.2λ + 1, µ.2λ + 2,. . . If ι = |wν | then the first element of the sequence must be deleted (since we have entered into a new word).\nThe next formula states that if an index l of the form µ.2λ (i.e. an index s.t. wtl holds) contains a pair (ν, ι) and if wν contains more that ι characters then µ.2\nλ+1 should encode the next character in the word wν , namely (ν, ι+1). Moreover the tail of the sequence does not change, which is expressed using the variable c(w)l (c stands for “copy”) that will be specified thereafter:\nn∧ i=1 [(wti ∧ car(w, ν, λ)i) ⇒ (car(w, ν, λ+ 1)2i ∧ c(w)i+1)] (2)\nfor every w ∈ {a, b}, ν ∈ [1, κ], λ ∈ [1, |wν | − 1].\nNow we define the formula encoding the copy of the tail. The most simple way to proceed would be to copy the values stored into the indices l, l+1, . . . , l+µ−1 into 2l+1, . . . , 2l+µ−1. Unfortunately this cannot be done in this simple way because expressions of the form l+ j\nwould be required in the indices, which is forbidden in our class (only ±1 can be added). As explained before, we overcome this problem by copying the indices l + 1, . . . , l + µ − 1 into 2l + 2, 2l + 4, . . . , 2l + 2µ − 2, which can be done by doubling the iteration counter. The indices 2l+1, 2l+3, . . . , 2l+2µ− 1 are left empty (holes). This is not disturbing since such empty indices will simply be ignored. An important consequence is that the length of the sequence is doubled each time it is copied (we assume that the value of the parameter n and the natural number µ are sufficiently large to ensure that there is enough “space” in the array).\nThis is expressed by the following formula:\nn∧ i=1 (c(w)i ⇒ [¬t(w, ν)2i−1 ∧ (t(w, ν)i ⇔ t(w, ν)2i) ∧ (¬wti+1 ⇒ c(w)i+1)]) (3)\nfor every ν ∈ [1, κ], w ∈ {a, b} We illustrate this construction by an example. Let A = {∗, ◦, ⋆, ⋄}, a = (∗◦, ⋆, ⋄◦) and ∆ = (1, 2, 3). In the second line, we provide for every index l the pair (ν, ι) such that car(a, ν, ι)l holds (if any). The third line gives the represented character (∗,◦,⋆ or ⋄). In the fourth line we provide the integer ν such that t(a, ν)l holds. The fifth line gives the value of c(a). The indices between µ+ 2 and 2µ are empty (we assume that µ = 3).\ni µ µ+ 1 µ+ 2 2µ 2µ+ 1 2µ+ 2 2µ+ 3 2µ+ 4 car (1, 1) (1, 2) character ∗ ◦ t 2 3 2 3 c(a) T T\nBy formula (2) we must have cµ+1. By formula (3), the value of c(a)µ+1 is propagated to c(a)µ+2,. . . , c(a)2µ−1 (it is not propagated to c(a)2µ since wt2µ holds). Still by (2), if c(a)l holds then we have t(a, ν)l ⇔ t(a, ν)2l, and the cells corresponding to odd indices are left empty. Thus we get the array above.\nIf an index µ.2λ contains a pair (ν, ι) where |wν | = ι (such as 2µ in the previous example), then one must proceed to the next word. To this aim, we need to know what is the first character of the next word (after the current one). Because of the holes introduced by the special copying mechanism, the next word is not necessarily at index l+1. A simple solution is to change the contents of the tail so that each element contains not only the index of a word but also its first character. This is stated by the following formula:\nn∧ i=1 [¬wti ⇒ (t(w, ν)i ⇒ car(w, ν, 1)i)] (4)\nFurthermore, we copy this character into all the holes preceding the element. As a particular case we get what we wanted for the first non-empty word.10 This is stated by\n10. Notice that we could have as well copied the word’s index instead of its first character, since the index contains all the information we need to retrieve the corresponding character. However it will be useful in the following to know that there is no word index stored in a particular cell, so we store only the information that is useful for the problem we want to solve at this point, i.e. the first character of the word.\nthe following formula:\nn∧ i=1 [(¬wti−1 ∧ ¬wti ∧ ∀λ ∈ [1, κ] ¬t(w, λ)i−1) ⇒ (car(w, ν, 1)i ⇔ car(w, ν, 1)i−1)] (5)\nfor every ν ∈ [1, κ], w ∈ {a, b}\nNow, if the pair stored in ι is (ν, |wν |) and if this word is not the final word in the sequence (i.e. e(w)ι does not hold) then one has to store into 2ι the first character of the next word, which is, due to the two previous formulae, the character represented by ι+ 1. The previous picture must thus be completed as follows:\ni µ µ+ 1 µ+ 2 2µ 2µ+ 1 2µ+ 2 2µ+ 3 2µ+ 4 car (1, 1) (2, 1) (3, 1) (1, 2) (2, 1) (2, 1) (3, 1) (3, 1) character ∗ ⋆ ⋄ ◦ ⋆ ⋆ ⋄ ⋄ t 2 3 2 3\nBy the formula (4) above, if t(a, ν)i holds then car(a, ν, 1)i also holds. Then by the formula (5), the value of car(a, ν, 1)l is recursively propagated to car(a, ν, 1)l−1 until we have l − 1 = µ.2λ or t(a, ν)l−1 holds for some ν. Notice that a character is now stored in every index l but only the characters in the indices µ.2λ form the witness.\nThanks to this trick, finding the next character after the one stored in µ.2λ is now trivial: this is simply the one stored in µ.2λ + 1, which, by the previous formula, actually corresponds to the first position of the word stored in (µ+1).2λ (of course, we also need to check that the character is not final). This is expressed by the following formula:\nn∧ l=1 [(wtl ∧ ¬e(w)l ∧ car(w, ν, |wν |)l) ⇒ (car(w, λ, 1)2l ⇔ car(w, λ, 1)l+1) ∧ s(w)l+1]\nfor every ν, λ ∈ [1, κ], w ∈ {a, b}\nThe propositional variable s(w)l+1 (s stands for “shift”) indicates that the tail at 2l is obtained by removing the first word in the tail at l. This is done as follows: the indices 2l + 2, . . . , 2l + 2µ − 1 are obtained by copying the indices l + 1, . . . , l + µ − 1, except the first one, that is left empty. As for c(w), the indices 2l− 1, . . . , 2l+ 2µ− 3 are empty. s(w) is defined by the three following formulae.\ns(w) actually erases everything until it finds a non-empty index, which is expressed by the first formula: if s(w)l holds then the indices stored at 2l and 2l − 1 must be empty (furthermore, we also check that the end of the tail has not been reached):\nn∧ l=1 (s(w)l ⇒ ¬wtl ∧ ¬t(w, ν)2l ∧ ¬t(w, ν)2l−1) for every ν ∈ [1, κ], w ∈ {a, b} (6)\nThe second one propagates the erasure if the current index is empty:\nn∧ l=1 [(s(w)l ∧ ¬wtl+1 ∧ ∀ν ∈ [1, κ] ¬t(w, ν)l) ⇒ s(w)l+1] for every w ∈ {a, b} (7)\nThe third one states that once we have reached a non-empty index then we go on by copying everything (which is done by using the previous variable c(w)):\nn∧ l=1 (s(w)l ∧ ∃λ ∈ [1, κ] t(w, λ)l ⇒ c(w)l+1) for every w ∈ {a, b} (8)\nWe illustrate this construction by showing how the erasure works on the previous example:\ni 2µ 2µ+ 1 2µ+ 2 2µ+ 3 2µ+ 4 car (1, 2) (2, 1) (2, 1) (3, 1) (3, 1) character ◦ ⋆ ⋆ ⋄ ⋄ t 2 3 c(a) T T s(a) T T\ni 4µ 4µ+ 1 4µ+ 2 4µ+ 3 4µ+ 4 4µ+ 5 4µ+ 6 4µ+ 7 4µ+ 8 car (2, 1) (3, 1) (3, 1) (3, 1) (3, 1) (3, 1) (3, 1) (3, 1) (3,1) character ⋆ ⋄ ⋄ ⋄ ⋄ ⋄ ⋄ ⋄ ⋄ t 3\nThe character stored in 2µ is the last one of the first word thus we have to remove the first word in the tail of the solution. As explained before, the character stored in 4µ is the same as the one stored in 2µ+1, namely (2, 1), i.e. ⋆ (since we have car(a, ν, 1)4µ ⇔ car(a, ν, 1)2µ+1). Furthermore, s(a)2µ+1 holds. This implies by (6) that the indices 4µ + 2 and 4µ + 1 of t must be empty. Since t is empty for ι = 2µ + 1 (i.e. there is no ν such that t(a, ν)2µ+1 holds), the value of s(a)2µ+1 is propagated to s(a)2µ+2, by (7). Thus by (6), the indices 4µ + 4 and 4µ + 3 of t must also be empty. This time, however, t(a, 2)2µ+2 holds. Thus the value of s(a) is not propagated and c(a)2µ+3 must hold (by (8)). As before, this implies that the remaining part of the sequence (i.e. the cells 2µ+ 3, 2µ+ 4 of t) is copied (in the cells 4µ+6, 4µ+8, leaving the cells 4µ+5, 4µ+7 empty) until 4µ is reached. This implies in particular that t(a, 3)4µ+8 holds (since t(a, 3)2µ+4 holds). Hence we have car(a, 3, 1)4µ+8. Since t is empty for l ∈ [4µ + 1, . . . , 4µ + 7], this value of car(a, 3, 1) is propagated to the indices 4µ + 7, . . . , 4µ + 1 as explained before. We obtain the desired result, i.e. the first word in the sequence (namely 2) have been erased and the first character of the next word is stored into 4µ+ 1.\nFinally, in order to ensure that the obtained sequence is really a solution to the Post correspondence problem, it only remains to check that the two sequences are identical, i.e. that the words contained in µ+ 1, · · · , 2µ− 1 are the same for both sequences a and b. To this purpose we define a variable rl that is true iff l < 2µ.\nr0 ∧ ¬rn ∧ n∧\nl=1\n[(rl ⇒ rl−1) ∧ (l = µ) ⇒ (r2l−1 ∧ ¬r2l)] (⋆)\nn∧ l=1 [(rl ∧ ¬(l < µ)) ⇒ (t(a, ν)l ⇔ t(b, ν)l)] (⋆)\nfor every ν ∈ [1, κ]\nIt is straightforward to check that the obtained formula is in Ch. The reader acquainted with Post’s correspondence problem shall now be convinced that the obtained formula is satisfiable iff there exists a solution to the above Post problem, and can thus skip the end of this section. Otherwise we give in the following a sketch of the formal steps to this proof.\nWe denote by ϕ the conjunction of the above formulae, except the formulae marked (⋆). We first notice that ϕ is satisfiable (for every value of n). Indeed, as explained before, the formulae above impose that:\n• There exists a unique natural number µ such that pν holds iff ν = µ and qν holds iff ν ∈ [0, µ− 1].\n• car(w, ν, λ) and t(w, ν) encode (partial) functions fw, gw mapping every index in [1, n] to a pair (ν, λ) (where ν ∈ [1, κ], λ ∈ [1, |wν |]) and to a word index in [1, κ] respectively. Moreover we must have fa(µ) = (ν, 1) and fb(µ) = (ν, 1) for some ν ∈ [1..κ− 1].\n• wtν holds iff there exists λ ∈ N s.t. ν = µ.2λ.\nThis obviously defines a partial interpretation. Then the remaining formulae in ϕ simply give the values of car(w, ν, λ)ι, t(w, ν)ι, c(w)ι, s(w)ι for ι ≥ 2µ. It is easy to check that distinct formulae cannot give distinct values to the same propositional variable, hence satisfiability is guaranteed.\nLet I be an interpretation of ϕ. Let ι ∈ [1..n]. We define the following sequences.\n• hw(ι) is a sequence of word indices defined as follows: If wtι+1 holds then hw(ι) is empty. Otherwise, if gw(ι) = ν then hw(ι) def = ν.hw(ι + 1) and if gw(ι) is undefined\nthen hw(ι) def = hw(ι+1). Intuitively, hw(ι) is the sequence of word indices stored juste after ι (i.e. the tail) ignoring empty cells.\n• jw(ι) is a word defined as follows: if ι > n then jw(ι) is empty. Otherwise, jw(ι) def =\nwλν .jw(2ι) if fw(ι) is a pair (ν, λ) distinct from (κ, 1), jw(ι) def = ⊤ if fw(ι) = (κ, 1) and jw(ι) def = jw(2ι) if fw(ι) is undefined. jw(ι) denotes the word stored at the cells ι, 2ι . . . in the array corresponding to w ((κ, 1) marks the end of the word).\n• If fw(ι) = (ν, ν ′) then kw(ι) denotes the suffix of length |wν | − ν ′ + 1 of the word wν (notice that by construction we must have ν ′ ≤ |ν|).\nBy definition of the copying/erasing mechanism above, if fw(µ.2 λ) is of the form (ν, |wν |)\n(i.e. we are at the end of the word ν) then hw(µ.2 λ) = ν ′.hw(µ.2 λ+1), where fw(µ.2 λ+1) =\n(ν ′, 1) (i.e. the tail is equal to the next word followed by the next tail). Otherwise (i.e. if we are in the middle of a word) we have hw(µ.2 λ) = hw(µ.2 λ+1) and fw(µ.2\nλ+1) = (ν, ν ′ + 1) where fw(µ.2\nλ) = (ν, ν ′) (ν ′ ̸= |wν |)). By an easy induction on the length of jw(µ.2λ), we deduce that jw(µ.2 λ) is a prefix of kw(µ.2 λ).whw(µ.2λ): kw(µ.2\nλ) represents the end of the word considered at the character λ, and whw(µ.2λ) is the concatenation of all words in the tail.\nFor λ = 0 we get in particular that jw(µ) is a prefix of kw(µ).whw(µ). But by definition kw(µ) = wν for some ν (not depending on w). Thus jw(µ) is a prefix of wν.hw(µ).\nThe formulae occurring in the conjunction but not in ϕ check that ha(µ) = hb(µ) (same sequence of word indices for a and b), that ja(µ) = jb(µ) and that ja(µ) ends with a character ⊤ (marking the end of the witness).\nIf I is a model of the whole formula, then jw(µ) is a prefix of wν.hw(µ), ending with ⊤, thus must be of the form wν.∆ where ∆ is a prefix of hw(µ). Hence ν.∆ is a solution to the Post’s correspondence problem.\nConversely, if such a solution ν.∆ exists, then we simply consider a model I of ϕ such that ha(µ) = hb(µ) = ∆ (this implies that µ > |∆|, notice that the values of fw(l) and gw(l) can be fixed arbitrarily for l < 2µ) and I(n) > µ.2λ, where λ = |aν.∆|. jw(µ) is a prefix of wν.hw(µ). Since the length jw(µ) cannot be greater than the one of wν.∆, jw(µ) must end with ⊤. Thus we must have jw(µ) = wν.∆ (since ⊤ is the last character in wν.∆). Moreover since ν.∆ is a solution we have ja(µ) = jb(µ). Thus I validates all the formulae above."
    }, {
      "heading" : "6.2 Unbounded Translation",
      "text" : "One can wonder whether the decidability of the class of regular schemata still holds when unbounded translations are allowed in the indices, i.e. translations of the form i+m where i denotes the iteration counter and m a parameter (the case m ∈ Z is covered by the regular class). The following definition and theorem show that the answer is negative.\nDefinition 6.3 Ct (t stands for “translation”) is the set of schemata S satisfying the following properties.\n• S contains at most two parameters n,m. • Every iteration in S is of the form ∧n i=1 ϕ or ∨n i=1 ϕ, where:\n– ϕ contains no iteration.\n– Every atomic formula in ϕ is of the form pα.i+β+γ.m, where p is a variable, α, γ ∈ {0, 1} and β ∈ {−1, 0, 1}.\n• The atomic propositions occurring in ϕ but not in the scope of an iteration are of the form p0 or pn where p is a variable.\nTheorem 6.4 The set of unsatisfiable formulae in Ct is not recursively enumerable."
    }, {
      "heading" : "Proof",
      "text" : "(Sketch) We do not detail the proof since it is very similar to the previous one. We reuse the same encoding as in the proof of Theorem 6.2, except that the pairs (ν, λ) in the array\nare stored in indices of the form µ+m× ι instead of µ.2ι. Formally, the formulae (1), (2), (3) and (6) are replaced by the following ones, respectively:\nn∧ l=1 [((l = µ) ⇒ wtl) ∧ ((l < µ) ⇒ ¬wtl) ∧ (¬(l < µ) ∧ ¬(l = µ)) ⇒ (wtl ⇔ wtl+m)]\n(i.e. wtl holds now iff there exists ι s.t. l = µ+mι).\nn∧ l=1 [wtl ∧ car(w, ν, λ)l ⇒ (car(w, ν, λ+ 1)l+m ∧ c(w)l+1)]\n(i.e. the index 2l is now replaced by l +m).\nn∧ l=1 (c(w)l ⇒ [(t(w, ν)l ⇔ t(w, ν)l+m) ∧ (¬wti+1 ⇒ c(w)l+1)])\nn∧ l=1 (s(w)l ⇒ ¬wtl ∧ ¬t(w, ν)l+m)"
    }, {
      "heading" : "7. Conclusion",
      "text" : "We introduced the first (to the best of our knowledge) logic for reasoning with iterated propositional schemata. We defined a class of schemata called bound-linear for which the satisfiability problem is decidable. The decidability proof is constructive and divided into two parts: first we show how to transform every bound-linear schema into a sat-equivalent schema of a simpler form, called regular. Then a proof procedure is defined to decide the satisfiability of regular schemata. This proof procedure is sound and complete w.r.t. satisfiability for every schema (even if it is not regular or not bound-linear) and terminates on every regular schema. Termination relies on a special looping detection rule. This procedure has been implemented in the software RegStab.\nThe class of bound-linear schemata is expressive enough to capture specifications of many important problems in AI, especially in automated (or interactive) theorem proving (e.g., parameterized circuit verification problems). We proved that even a very slight relaxation of the conditions on bound-linear schemata makes the satisfiability problem undecidable (this is shown by a tricky reduction to the Post correspondence problem). As a consequence, bound-linear schemata can be considered as a “canonical” decidable class, providing a good compromise between expressivity and tractability.\nAs for future work, two ways are the most promising. Firstly, the extension of the previous results to particular classes of non-monadic schemata (i.e. schemata containing symbols with several indices, e.g., ∨n i=1 ∧n j=1 pi,j) would enlarge considerably applications of propositional schemata. Secondly, extending our approach to more expressive logics,\nsuch as first-order logic, description logics or modal logics, also deserves to be considered. The presented results should extend straightforwardly to many-valued propositional logic (provided the number of truth values is fixed and finite). This would allow to capture infinite constraint satisfaction languages."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work has been partly funded by the project ASAP of the French Agence Nationale de la Recherche (ANR-09-BLAN-0407-01). The authors wish to thank the anonymous referees for their insightful comments which helped improve an earlier version of this paper."
    } ],
    "references" : [ {
      "title" : "An Introduction to Inductive Definitions",
      "author" : [ "P. Aczel" ],
      "venue" : "Barwise, K. J. (Ed.), Handbook of Mathematical Logic, pp. 739–782. North-Holland, Amsterdam.",
      "citeRegEx" : "Aczel,? 1977",
      "shortCiteRegEx" : "Aczel",
      "year" : 1977
    }, {
      "title" : "A DPLL proof procedure for propositional iterated schemata. In Workshop “Structures and Deduction 2009",
      "author" : [ "V. Aravantinos", "R. Caferra", "N. Peltier" ],
      "venue" : null,
      "citeRegEx" : "Aravantinos et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Aravantinos et al\\.",
      "year" : 2009
    }, {
      "title" : "A schemata calculus for propositional logic",
      "author" : [ "V. Aravantinos", "R. Caferra", "N. Peltier" ],
      "venue" : "In TABLEAUX 09 (International Conference on Automated Reasoning with Analytic Tableaux and Related Methods),",
      "citeRegEx" : "Aravantinos et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Aravantinos et al\\.",
      "year" : 2009
    }, {
      "title" : "A Decidable Class of Nested Iterated Schemata",
      "author" : [ "V. Aravantinos", "R. Caferra", "N. Peltier" ],
      "venue" : "In IJCAR 2010 (International Joint Conference on Automated Reasoning),",
      "citeRegEx" : "Aravantinos et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Aravantinos et al\\.",
      "year" : 2010
    }, {
      "title" : "Note on the generalization of calculations",
      "author" : [ "M. Baaz" ],
      "venue" : "Theoretical Computer Science, 224, 3–11.",
      "citeRegEx" : "Baaz,? 1999",
      "shortCiteRegEx" : "Baaz",
      "year" : 1999
    }, {
      "title" : "Short proofs of tautologies using the schema of equivalence",
      "author" : [ "M. Baaz", "R. Zach" ],
      "venue" : "In Computer Science Logic (CSL’93),",
      "citeRegEx" : "Baaz and Zach,? \\Q1994\\E",
      "shortCiteRegEx" : "Baaz and Zach",
      "year" : 1994
    }, {
      "title" : "The challenge of computer mathematics",
      "author" : [ "H. Barendregt", "F. Wiedijk" ],
      "venue" : "Philosophical Transactions of the Royal Society A,",
      "citeRegEx" : "Barendregt and Wiedijk,? \\Q2005\\E",
      "shortCiteRegEx" : "Barendregt and Wiedijk",
      "year" : 2005
    }, {
      "title" : "SPIKE, an automatic theorem prover",
      "author" : [ "A. Bouhoula", "E. Kounalis", "M. Rusinowitch" ],
      "venue" : "In Proceedings of the International Conference on Logic Programming and Automated Reasoning (LPAR’92),",
      "citeRegEx" : "Bouhoula et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Bouhoula et al\\.",
      "year" : 1992
    }, {
      "title" : "A computational logic",
      "author" : [ "R.S. Boyer", "J.S. Moore" ],
      "venue" : null,
      "citeRegEx" : "Boyer and Moore,? \\Q1979\\E",
      "shortCiteRegEx" : "Boyer and Moore",
      "year" : 1979
    }, {
      "title" : "Local model checking for infinite state spaces",
      "author" : [ "J. Bradfield", "C. Stirling" ],
      "venue" : "In Selected papers of the Second Workshop on Concurrency and compositionality,",
      "citeRegEx" : "Bradfield and Stirling,? \\Q1992\\E",
      "shortCiteRegEx" : "Bradfield and Stirling",
      "year" : 1992
    }, {
      "title" : "Modal Mu-Calculi",
      "author" : [ "J. Bradfield", "C. Stirling" ],
      "venue" : null,
      "citeRegEx" : "Bradfield and Stirling,? \\Q2007\\E",
      "shortCiteRegEx" : "Bradfield and Stirling",
      "year" : 2007
    }, {
      "title" : "Cyclic Proofs for First-Order Logic with Inductive Definitions",
      "author" : [ "J. Brotherston" ],
      "venue" : "Beckert, B. (Ed.), Automated Reasoning with Analytic Tableaux and Related Methods: Proceedings of TABLEAUX 2005, Vol. 3702 of LNAI, pp. 78–92. Springer-Verlag.",
      "citeRegEx" : "Brotherston,? 2005",
      "shortCiteRegEx" : "Brotherston",
      "year" : 2005
    }, {
      "title" : "The automation of proof by mathematical induction",
      "author" : [ "A. Bundy" ],
      "venue" : "Robinson, J. A., & Voronkov, A. (Eds.), Handbook of Automated Reasoning, pp. 845–911. Elsevier and MIT Press.",
      "citeRegEx" : "Bundy,? 2001",
      "shortCiteRegEx" : "Bundy",
      "year" : 2001
    }, {
      "title" : "The Oyster-Clam system",
      "author" : [ "A. Bundy", "F. van Harmelen", "C. Horn", "A. Smaill" ],
      "venue" : "In Proceedings of the 10th International Conference on Automated Deduction,",
      "citeRegEx" : "Bundy et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Bundy et al\\.",
      "year" : 1990
    }, {
      "title" : "On finite representations of infinite sequences of terms",
      "author" : [ "H. Chen", "J. Hsiang", "H. Kong" ],
      "venue" : "In Conditional and Typed Rewriting Systems, 2nd International Workshop,",
      "citeRegEx" : "Chen et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 1990
    }, {
      "title" : "Tableau-based model checking in the propositional mu-calculus",
      "author" : [ "R. Cleaveland" ],
      "venue" : "Acta Inf., 27 (9), 725–747.",
      "citeRegEx" : "Cleaveland,? 1990",
      "shortCiteRegEx" : "Cleaveland",
      "year" : 1990
    }, {
      "title" : "Inductionless induction",
      "author" : [ "H. Comon" ],
      "venue" : "Robinson, A., & Voronkov, A. (Eds.), Handbook of Automated Reasoning, chap. 14, pp. 913–962. North-Holland.",
      "citeRegEx" : "Comon,? 2001",
      "shortCiteRegEx" : "Comon",
      "year" : 2001
    }, {
      "title" : "On unification of terms with integer exponents",
      "author" : [ "H. Comon" ],
      "venue" : "Mathematical System Theory, 28, 67–88.",
      "citeRegEx" : "Comon,? 1995",
      "shortCiteRegEx" : "Comon",
      "year" : 1995
    }, {
      "title" : "Theorem proving in arithmetic without multiplication",
      "author" : [ "D. Cooper" ],
      "venue" : "Meltzer, B., & Michie, D. (Eds.), Machine Intelligence 7, chap. 5, pp. 91–99. Edinburgh University Press.",
      "citeRegEx" : "Cooper,? 1972",
      "shortCiteRegEx" : "Cooper",
      "year" : 1972
    }, {
      "title" : "A Machine Program for Theorem Proving",
      "author" : [ "M. Davis", "G. Logemann", "D. Loveland" ],
      "venue" : "Communication of the ACM,",
      "citeRegEx" : "Davis et al\\.,? \\Q1962\\E",
      "shortCiteRegEx" : "Davis et al\\.",
      "year" : 1962
    }, {
      "title" : "Finite-Model Theory - A Personal Perspective",
      "author" : [ "R. Fagin" ],
      "venue" : "Theoretical Computer Science, 116, 3–31.",
      "citeRegEx" : "Fagin,? 1993",
      "shortCiteRegEx" : "Fagin",
      "year" : 1993
    }, {
      "title" : "Decidable classes of inductive theorems",
      "author" : [ "J. Giesl", "D. Kapur" ],
      "venue" : "IJCAR, Vol. 2083 of Lecture Notes in Computer Science,",
      "citeRegEx" : "Giesl and Kapur,? \\Q2001\\E",
      "shortCiteRegEx" : "Giesl and Kapur",
      "year" : 2001
    }, {
      "title" : "Chapter 6: Tableau Methods for Modal and Temporal Logics",
      "author" : [ "R. Goré" ],
      "venue" : "M D’Agostino, D Gabbay, R Hähnle, J Posegga (Ed.), Handbook of Tableau Methods, pp. 297–396. Kluwer Academic Publishers. http://arp.anu.edu.au/~ rpg (draft).",
      "citeRegEx" : "Goré,? 1999",
      "shortCiteRegEx" : "Goré",
      "year" : 1999
    }, {
      "title" : "Representation and symbolic manipulation of linearly inductive boolean functions",
      "author" : [ "A. Gupta", "A.L. Fisher" ],
      "venue" : "IEEE Computer Society",
      "citeRegEx" : "Gupta and Fisher,? \\Q1993\\E",
      "shortCiteRegEx" : "Gupta and Fisher",
      "year" : 1993
    }, {
      "title" : "Unification of Infinite Sets of Terms schematized by Primal Grammars",
      "author" : [ "M. Hermann", "R. Galbavý" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "Hermann and Galbavý,? \\Q1997\\E",
      "shortCiteRegEx" : "Hermann and Galbavý",
      "year" : 1997
    }, {
      "title" : "Proof analysis with HLK, CERES and ProofTool: Current status and future directions",
      "author" : [ "S. Hetzl", "A. Leitsch", "D. Weller", "B. Woltzenlogel Paleo" ],
      "venue" : "Workshop on Empirically Successful Automated Reasoning for Mathematics (ESARM),",
      "citeRegEx" : "Hetzl et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Hetzl et al\\.",
      "year" : 2008
    }, {
      "title" : "Relational queries computable in polynomial time (Extended Abstract)",
      "author" : [ "N. Immerman" ],
      "venue" : "STOC ’82: Proceedings of the fourteenth annual ACM symposium on Theory of computing, pp. 147–152, New York, NY, USA. ACM.",
      "citeRegEx" : "Immerman,? 1982",
      "shortCiteRegEx" : "Immerman",
      "year" : 1982
    }, {
      "title" : "The number of proof lines and the size of proofs in first-order logic",
      "author" : [ "J. Krajicek", "P. Pudlak" ],
      "venue" : "Archive for Mathematical Logic,",
      "citeRegEx" : "Krajicek and Pudlak,? \\Q1988\\E",
      "shortCiteRegEx" : "Krajicek and Pudlak",
      "year" : 1988
    }, {
      "title" : "Proof schemata in Hilbert-type axiomatic theories",
      "author" : [ "V.P. Orevkov" ],
      "venue" : "Journal of Mathematical Sciences, 55 (2), 1610–1620.",
      "citeRegEx" : "Orevkov,? 1991",
      "shortCiteRegEx" : "Orevkov",
      "year" : 1991
    }, {
      "title" : "Some results on the length of proofs",
      "author" : [ "R.J. Parikh" ],
      "venue" : "Transactions of the American Mathematical Society, 177, 29–36.",
      "citeRegEx" : "Parikh,? 1973",
      "shortCiteRegEx" : "Parikh",
      "year" : 1973
    }, {
      "title" : "Finiteness is Mu-ineffable",
      "author" : [ "D.M. Park" ],
      "venue" : "Theoretical Computer Science, 3, 173–181.",
      "citeRegEx" : "Park,? 1976",
      "shortCiteRegEx" : "Park",
      "year" : 1976
    }, {
      "title" : "Inductive Definitions in the system Coq - Rules and Properties",
      "author" : [ "C. Paulin-Mohring" ],
      "venue" : "TLCA ’93: Proceedings of the International Conference on Typed Lambda Calculi and Applications, pp. 328–345, London, UK. Springer-Verlag.",
      "citeRegEx" : "Paulin.Mohring,? 1993",
      "shortCiteRegEx" : "Paulin.Mohring",
      "year" : 1993
    }, {
      "title" : "First-Order Logic",
      "author" : [ "R.M. Smullyan" ],
      "venue" : "Springer.",
      "citeRegEx" : "Smullyan,? 1968",
      "shortCiteRegEx" : "Smullyan",
      "year" : 1968
    }, {
      "title" : "On the Structure of Inductive Reasoning: Circular and Tree-shaped Proofs in the mu-Calculus",
      "author" : [ "C. Sprenger", "M. Dam" ],
      "venue" : "In Proc. FOSSACS’03,",
      "citeRegEx" : "Sprenger and Dam,? \\Q2003\\E",
      "shortCiteRegEx" : "Sprenger and Dam",
      "year" : 2003
    }, {
      "title" : "Automated Reasoning: 33 Basic Research Problems",
      "author" : [ "L. Wos" ],
      "venue" : "Prentice Hall.",
      "citeRegEx" : "Wos,? 1988",
      "shortCiteRegEx" : "Wos",
      "year" : 1988
    }, {
      "title" : "Automated Reasoning: Introduction and Applications (Second edition)",
      "author" : [ "L. Wos", "R. Overbeek", "E. Lush", "J. Boyle" ],
      "venue" : null,
      "citeRegEx" : "Wos et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Wos et al\\.",
      "year" : 1992
    } ],
    "referenceMentions" : [ {
      "referenceID" : 29,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).",
      "startOffset" : 223,
      "endOffset" : 289
    }, {
      "referenceID" : 4,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).",
      "startOffset" : 223,
      "endOffset" : 289
    }, {
      "referenceID" : 28,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991).",
      "startOffset" : 223,
      "endOffset" : 289
    }, {
      "referenceID" : 17,
      "context" : "It is worth mentioning that this iteration cannot be denoted by other term schematisation languages (Chen, Hsiang, & Kong, 1990; Comon, 1995) because the inductive context is not constant.",
      "startOffset" : 100,
      "endOffset" : 141
    }, {
      "referenceID" : 4,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of ‘proof skeleton’, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.",
      "startOffset" : 94,
      "endOffset" : 305
    }, {
      "referenceID" : 4,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of ‘proof skeleton’, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.",
      "startOffset" : 94,
      "endOffset" : 357
    }, {
      "referenceID" : 4,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of ‘proof skeleton’, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.",
      "startOffset" : 94,
      "endOffset" : 417
    }, {
      "referenceID" : 4,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of ‘proof skeleton’, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system.",
      "startOffset" : 94,
      "endOffset" : 506
    }, {
      "referenceID" : 4,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of ‘proof skeleton’, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system. Pragmatically, schemata have been successfully used, e.g., in solving open questions in equivalential calculus (i.e. the field of formal logic concerned with the notion of equivalence) with the theorem-prover Otter (Wos, Overbeek, Lush, & Boyle, 1992). However, to the best of our knowledge, the formal handling of such schemata at the object level has never been considered. Although the notion of ‘schema’ is recognized as an important one, it deserves more applied works in our opinion. Sometimes schemata are not sufficiently emphasized, e.g., in the work of Barendregt and Wiedijk (2005) a nice and deep analysis about the challenge of computer mathematics is given.",
      "startOffset" : 94,
      "endOffset" : 1152
    }, {
      "referenceID" : 4,
      "context" : "Different forms of schemata have been used by several authors, either in propositional logic (Baaz & Zach, 1994) or in first-order logic to obtain results in proof theory, in particular related to the number of proof lines (Parikh, 1973; Baaz, 1999; Krajicek & Pudlak, 1988; Orevkov, 1991). Parikh (1973) presents a notion of schematic systems, Baaz (1999) uses the concept of unification, Krajicek and Pudlak (1988) introduce the notion of ‘proof skeleton’, very similar to that of schema, Orevkov (1991) studies schemata in first-order Hilbert-type system. Pragmatically, schemata have been successfully used, e.g., in solving open questions in equivalential calculus (i.e. the field of formal logic concerned with the notion of equivalence) with the theorem-prover Otter (Wos, Overbeek, Lush, & Boyle, 1992). However, to the best of our knowledge, the formal handling of such schemata at the object level has never been considered. Although the notion of ‘schema’ is recognized as an important one, it deserves more applied works in our opinion. Sometimes schemata are not sufficiently emphasized, e.g., in the work of Barendregt and Wiedijk (2005) a nice and deep analysis about the challenge of computer mathematics is given. The authors overview the state of the art (by describing and comparing most powerful existing systems in use) but structuring proofs is not explicitly mentioned (maybe this feature can be included in what they call “mathematical style” or “support reasoning with gaps”). In our approach to schemata it is clear that they are a way of structuring proofs and can also help to overcome one of the obstacles to the automation of reasoning pointed out by Wos (1988), i.",
      "startOffset" : 94,
      "endOffset" : 1692
    }, {
      "referenceID" : 16,
      "context" : "Several procedures have been designed for proving inductive theorems, (Boyer & Moore, 1979; Bouhoula, Kounalis, & Rusinowitch, 1992; Comon, 2001; Bundy, van Harmelen, Horn, & Smaill, 1990; Bundy, 2001).",
      "startOffset" : 70,
      "endOffset" : 201
    }, {
      "referenceID" : 12,
      "context" : "Several procedures have been designed for proving inductive theorems, (Boyer & Moore, 1979; Bouhoula, Kounalis, & Rusinowitch, 1992; Comon, 2001; Bundy, van Harmelen, Horn, & Smaill, 1990; Bundy, 2001).",
      "startOffset" : 70,
      "endOffset" : 201
    }, {
      "referenceID" : 16,
      "context" : "In particular, schemata may have several models, thus implicit induction (Comon, 2001) (which explicitly requires that the underlying Herbrand model is unique) cannot be (directly) used.",
      "startOffset" : 73,
      "endOffset" : 86
    }, {
      "referenceID" : 26,
      "context" : "Actually iterated schemata share much more with least fixpoint logic, or LFP (Immerman, 1982), studied in finite model theory (Fagin, 1993; Ebbinghaus & Flum, 1999): LFP is a logic allowing to iterate first-order formulae maintaining constant the number of their variables.",
      "startOffset" : 77,
      "endOffset" : 93
    }, {
      "referenceID" : 20,
      "context" : "Actually iterated schemata share much more with least fixpoint logic, or LFP (Immerman, 1982), studied in finite model theory (Fagin, 1993; Ebbinghaus & Flum, 1999): LFP is a logic allowing to iterate first-order formulae maintaining constant the number of their variables.",
      "startOffset" : 126,
      "endOffset" : 164
    }, {
      "referenceID" : 30,
      "context" : "In contrast with propositional μcalculus, first-order μ-calculus (Park, 1976) clearly embeds iterated schemata (allowing for instance the above fixed-point expression of ∧n i=1 pi), but no published research seems to be focused on the identification of complete subclasses.",
      "startOffset" : 65,
      "endOffset" : 77
    }, {
      "referenceID" : 0,
      "context" : "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers.",
      "startOffset" : 81,
      "endOffset" : 94
    }, {
      "referenceID" : 31,
      "context" : "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers.",
      "startOffset" : 142,
      "endOffset" : 164
    }, {
      "referenceID" : 22,
      "context" : ", in tableaux methods dealing with modal logics in transitive frames (Goré, 1999), or μ-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992).",
      "startOffset" : 69,
      "endOffset" : 81
    }, {
      "referenceID" : 15,
      "context" : ", in tableaux methods dealing with modal logics in transitive frames (Goré, 1999), or μ-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992).",
      "startOffset" : 96,
      "endOffset" : 142
    }, {
      "referenceID" : 0,
      "context" : "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it.",
      "startOffset" : 82,
      "endOffset" : 338
    }, {
      "referenceID" : 0,
      "context" : "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it. As we shall see in Section 5.2, completeness of bound-linear schemata (or more precisely regular schemata) lies in the detection of cycles during the proof search. This idea is not new, it is used, e.g., in tableaux methods dealing with modal logics in transitive frames (Goré, 1999), or μ-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992). However cycle detection in our work is quite different because we use it to prove by induction. Notice in particular that we cannot in general ensure termination (contrarily to the above methods). It is more relevant to consider our method as a particular instance of cyclic proofs, which are studied in proof theory precisely in the context of proofs by induction. In the works of Brotherston (2005), and Sprenger and Dam (2003), it is shown that cyclic proofs seem as powerful as systems dealing classically with induction.",
      "startOffset" : 82,
      "endOffset" : 1170
    }, {
      "referenceID" : 0,
      "context" : "With a similar expressive power one also finds logics with inductive definitions (Aczel, 1977) which are quite widespread in proof assistants (Paulin-Mohring, 1993), but again out of the range of automated theorem provers. As far as we know the only study of a complete subclass in such fixed point logics is in the work of Baelde (2009), and iterated schemata definitely do not lie in this class nor can be reduced to it. As we shall see in Section 5.2, completeness of bound-linear schemata (or more precisely regular schemata) lies in the detection of cycles during the proof search. This idea is not new, it is used, e.g., in tableaux methods dealing with modal logics in transitive frames (Goré, 1999), or μ-calculi (Cleaveland, 1990; Bradfield & Stirling, 1992). However cycle detection in our work is quite different because we use it to prove by induction. Notice in particular that we cannot in general ensure termination (contrarily to the above methods). It is more relevant to consider our method as a particular instance of cyclic proofs, which are studied in proof theory precisely in the context of proofs by induction. In the works of Brotherston (2005), and Sprenger and Dam (2003), it is shown that cyclic proofs seem as powerful as systems dealing classically with induction.",
      "startOffset" : 82,
      "endOffset" : 1199
    }, {
      "referenceID" : 32,
      "context" : "This is done by providing a set of block tableaux rules (Smullyan, 1968) that are complete w.",
      "startOffset" : 56,
      "endOffset" : 72
    }, {
      "referenceID" : 18,
      "context" : "This can be detected using decision procedures for arithmetic without multiplication (Cooper, 1972).",
      "startOffset" : 85,
      "endOffset" : 99
    }, {
      "referenceID" : 11,
      "context" : "In existing work on cyclic proofs, N ′ is sometimes called a bud node and N is the companion node of N ′ (Brotherston, 2005).",
      "startOffset" : 105,
      "endOffset" : 124
    } ],
    "year" : 2011,
    "abstractText" : "We define a logic of propositional formula schemata adding to the syntax of propositional logic indexed propositions (e.g., pi) and iterated connectives ∨ or ∧ ranging over intervals parameterized by arithmetic variables (e.g., ∧n i=1 pi, where n is a parameter). The satisfiability problem is shown to be undecidable for this new logic, but we introduce a very general class of schemata, called bound-linear, for which this problem becomes decidable. This result is obtained by reduction to a particular class of schemata called regular, for which we provide a sound and complete terminating proof procedure. This schemata calculus (called stab) allows one to capture proof patterns corresponding to a large class of problems specified in propositional logic. We also show that the satisfiability problem becomes again undecidable for slight extensions of this class, thus demonstrating that bound-linear schemata represent a good compromise between expressivity and decidability.",
    "creator" : " TeX output 2011.03.21:1228"
  }
}