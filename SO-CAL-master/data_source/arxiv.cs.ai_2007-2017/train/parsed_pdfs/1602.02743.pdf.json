{
  "name" : "1602.02743.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Michael Brand", "David L. Dowe" ],
    "emails" : [ "michael.brand@monash.edu", "david.dowe@monash.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 2.\n02 74\n3v 1\n[ cs\n.L O\n] 7\nF eb\nWe introduce a problem set-up we call the Iterated Matching Pennies (IMP) game and show that it is a powerful framework for the study of three problems: adversarial learnability, conventional (i.e., non-adversarial) learnability and approximability. Using it, we are able to derive the following theorems. (1) It is possible to learn by example all of Σ01 ∪ Π01 as well as some supersets; (2) in adversarial learning (which we describe as a pursuit-evasion game), the pursuer has a winning strategy (in other words, Σ01 can be learned adversarially, but Π01 not); (3) some languages in Π 0 1 cannot be approximated by any language in Σ 0 1.\nWe show corresponding results also for Σ0i and Π 0 i for arbitrary i.\nKeywords: Turing machine, recursively enumerable, decidable, approximation, matching pennies, halting, halting problem, elusive model paradox, red herring sequence, learnability, Nash equilibrium, approximability, adversarial learning"
    }, {
      "heading" : "1. Introduction",
      "text" : "This paper deals with three widely-discussed topics: approximability, conventional learnability and adversarial learnability, and introduces a unified framework in which all three can be studied.\nFirst, consider approximability. Turing’s seminal 1936 result [21] demonstrated that some languages that can be accepted by Turing machines (TMs) are not decidable. Otherwise stated, some R.E. languages are not recursive. Equivalently: some co-R.E. languages are not R.E.; any R.E. language must differ from them by at least one word. However, the diagonalisation process by which this result was originally derived makes no stronger claim regarding the number of words differentiating a co-R.E. language and an R.E. one. It merely shows one example of a word where a difference must exist.\nWe extend this original result by showing that some co-R.E. languages are, in some sense, as different from any R.E. language as it is possible to be.\nTo formalise this statement, consider an arbitrary (computable) enumeration, w1, w2, . . ., over the complete language (the language that includes all words over the chosen alpha-\nEmail addresses: michael.brand@monash.edu (Michael Brand), david.dowe@monash.edu (David L. Dowe)\nPreprint submitted to Elsevier February 10, 2016\nbet). Over this enumeration, {wi}, we define a distance metric, dissimilarity, between two languages, L1 and L2, as follows.\nDisSim(L1, L2) ≡ lim sup n→∞ |(L1△L2) ∩ {w1, . . . , wn}| n ,\nwhere L1△L2 is the symmetric difference. We note that the value of DisSim(L1, L2) depends on the enumeration chosen, and therefore, technically, DisSim(·) = DisSim{wi}(·). However, all results in this paper are true for all possible choices of the enumeration, for which reason we omit the choice of enumeration, opting for this more simplified notation.\nDisSim(L1, L2) ranges between 0 (the languages are essentially identical) and 1 (the languages are completely dissimilar).\nWe prove:\nTheorem 1. There is a co-R.E. language L̄ such that every R.E. language has a dissimilarity distance of 1 from L̄.\nConsider now learnability. Learnability is an important concept in statistics, econometrics, machine learning, inductive inference, data mining and other fields. This has been discussed by E. M. Gold and by L. G. Valiant in terms of language identification in the limit [7, 22], and also in statistics via the notion of statistical consistency, also known as “completeness” (converging arbitrarily closely in the limit to an underlying true model).\nFollowing upon his convergence results in [17], Solomonoff writes [20, sec. 2 (Completeness and Incomputability)]:\n“It is notable that completeness and incomputability are complementary properties: It is easy to prove that any complete prediction method must be incomputable. Moreover, any computable prediction method can not be complete – there will always be a large space of regularities for which its predictions are catastrophically poor.”\nIn other words, in Solomonoff’s problem set-up it is impossible for a Turing machine to learn every R.E. language: every computable learner is limited.\nNevertheless, in the somewhat different context within which we study learnability, we are able to show that this tension does not exist: a Turing machine can learn any computable language. Moreover, we will consider a set of languages that includes, as a proper subset of it, the languages Σ01∪Π01 and will prove that while no deterministic learning algorithm can learn every language in the set, a probabilistic one can (with probability 1), and a mixed strategy involving several deterministic learning algorithms can approximate this arbitrarily well.1\nLastly, consider adversarial learning [12, 11, 9]. This is different from the conventional learning scenario described above in that while in conventional learning we attempt to\n1Here and elsewhere we use the standard notations for language families in the arithmetical hierarchy [15]: Σ0\n1 is the set of recursively enumerable languages, Π0 1 is the set of co-R.E. languages.\nconverge to an underlying “true model” based on given observations, adversarial learning is a multi-player process in which each participant can observe (to some extent) other players’ predictions and adjust their own actions accordingly. This game-theoretic set-up becomes of practical importance in many scenarios. For example, in online bidding bidders use information available to them (e.g., whether they won a particular auction) to learn the strategy used by competing bidders, so as to be able to optimise their own strategy accordingly.\nWe consider, specifically, an adversarial learning scenario in which one player (the pursuer) attempts to copy a second player, while the second player (the evader) is attempting to avoid being copied. Specifically, each player generates a bit (0 or 1) and the pursuer wins if the two bits are equal while the evader wins if they are not. Though on the face of it this scenario may seem symmetric, we show that the pursuer has a winning strategy.\nTo attain all these results (as well as their higher-Turing-degree equivalents), we introduce a unified framework in which these questions and related ones can all be studied. The set-up used is an adaptation of one initially introduced by Scriven [16] of a predictor and a contrapredictive (or avoider) effectively playing what we might nowadays describe as a game of iterated matching pennies. In Section 2, we give a formal description of this problem set-up and briefly describe its historical evolution. In Section 3, we explain the relevance of the set-up to the learnability and approximability problems and analyse, as an example case, adversarial learning in the class of decidable languages. In Section 4, we extend the analysis to adversarial learning in all other classes in the arithmetical hierarchy, and in particular to Turing machines.\nIn Sections 5 and 6 we then return to conventional learnability and to approximability, respectively, and prove the remaining results by use of the set-up developed, showing how it can be adapted to these problems."
    }, {
      "heading" : "2. Matching Pennies",
      "text" : "The matching pennies game is a zero-sum two-player game where each player is required to output a bit. If the two bits are equal, this is a win for Player “=”; if they differ, this is a win for Player “ 6=”. The game is a classic example used in teaching mixed strategies [see, e.g. 6, pp. 283–284]: its only Nash equilibrium [14, 13] is a mixed strategy wherein each player chooses each of the two options with probability 1/2.\nConsider, now, an iterative version of this game, where at each round the players choose a new bit with perfect information of all previous rounds. Here, too, the best strategy is to choose at each round a new bit with probability 1/2 for each option, and with the added caveat that each bit must be independent of all previous bits. In the iterative variation, we define the payoff (of the entire game) to be\nS = S 6= =\n(\nlim inf N→∞\nN ∑\nn=1\nδn 2N\n)\n+\n(\nlim sup N→∞\nN ∑\nn=1\nδn 2N\n)\n(1)\nfor Player “ 6=”, where δn is 0 if the bits output in the n’th round are equal and 1 if they\nare different. The payoff for Player “=” is\nS= = 1− S 6= = (\nlim inf N→∞\nN ∑\nn=1\n1− δn 2N\n)\n+\n(\nlim sup N→∞\nN ∑\nn=1\n1− δn 2N\n)\n(2)\nThese payoff functions were designed to satisfy the following criteria:\n• They are always defined.\n• The game is zero-sum and strategically symmetric, except for the essential distinction between a player aiming to copy (Player “=”, the pursuer) and a player aiming for dissimilarity (Player “ 6=”, the evader).\n• The payoff is a function solely of the {δi} sequence. (This is important because in the actual IMP game being constructed players will only have visibility into past δi, not full information regarding the game’s evolution.)\n• Where a limit exists (in the lim sense) to the percentage of rounds to be won by a player, the payoff is this percentage.\nIn particular, note that when the payoff functions take the value 0 or 1, there exists a limit (in the lim sense) to the percentage of rounds to be won by a player, and in this case the payoff is this limit.\nIn the case of the strategy pair described above, for example, where bits are determined by independent, uniform-distribution coin tosses, the limit exists and the payoff is 1/2 for both players, indicating that the game is not biased towards either. This is a Nash equilibrium of the game: neither player can ensure a higher payoff for herself as long as the other persists in the equilibrium strategy. The game has other Nash equilibria, but all share the (1/2, 1/2) payoffs.\nAbove, we describe the players in the game as agents capable of randomisation: they choose a random bit at each new round. However, the game can be played, with the same strategies, also by deterministic agents. For this, consider every possible infinite bit-string as a possible strategy for each of the players. In this case, the game’s Nash equilibrium would be a strategy pair where each player allots a bit-string from a uniform distribution among all options.\nWe formalise this deterministic outlook on the matching pennies game as follows.\nDefinition 1 (Iterative Matching Pennies game). An Iterative Matching Pennies game (or IMP), denoted IMP(Σ=,Σ6=), is a two player game where each player chooses a language: Player “=” chooses L= ∈ Σ= and Player “ 6=” chooses L6= ∈ Σ6=, where Σ= and Σ6= are two collections of languages over the binary alphabet.\nWhere Σ= = Σ6= (= Σ), we denote the game IMP(Σ). Define ∆0 to be the empty string and define, for every natural i,\nδi def =\n{\n1 if ∆i−1 ∈ L=△L6= 0 if ∆i−1 6∈ L=△L6= ,\n∆i def = ∆i−1δi,\nThen the payoffs S= = S=(L=, L6=) and S 6= = S 6=(L=, L6=) are as defined in (2) and (1), respectively. The notation “∆i−1δi” indicates string concatenation.\nPlayer (mixed) strategies in this game are described as distributions, D= and D 6=, over Σ= and Σ6=, respectively. In this case, we define\nS=(D=, D 6=) = E(S=(L=, L6=)) L= ∼ D=, L6= ∼ D 6=.\nS 6=(D=, D 6=) = E(S 6=(L=, L6=)) L= ∼ D=, L6= ∼ D 6=.\nNote again that the game is zero sum: any pair of strategies, pure or mixed, satisfies\nS=(D=, D 6=) + S 6=(D=, D 6=) = 1. (3)\nTo better illustrate the dynamics embodied by Definition 1, let us add two more definitions: let\nO=(i) def =\n{\n1 if ∆i−1 ∈ L= 0 if ∆i−1 6∈ L=\n(4)\nand let\nO 6=(i) def =\n{\n1 if ∆i−1 ∈ L6= 0 if ∆i−1 6∈ L6= , (5)\nnoting that by Definition 1, δi = O=(i)⊕O 6=(i), where “⊕” denotes the exclusive or (“xor”) function.\nThe scenario encapsulated by the IMP game is that of a competition between two players, Player “=” and Player “ 6=”, where the strategy of the players is encoded in the form of the languages L= and L6=, respectively (or distributions over these in the case of mixed strategies).\nAfter i rounds, each player has visibility to the set of results so far. This is encoded by means of ∆i, a word composed of the characters δ1, . . . , δi, where each δk is 0 if the bits that were output by the two players in round k are equal and 1 if they are not. It is based on this history that the players now generate a new bit: Player “=” generates O=(i + 1) and Player “ 6=” generates O 6=(i + 1). The players’ strategies are therefore functions from a word (∆i) to a bit (O=(i + 1) for Player “=”, O 6=(i + 1) for Player “ 6=”). To encode these strategies in the most general form, we use languages: L= and L6= are simply sets containing all the words to which the response is “1”. Our choice of how weak or how strong a player can be is then ultimately in the question of what language family, Σ, its strategy is chosen from.\nOnce O=(i + 1) and O 6=(i + 1) are determined, δi+1 is simply their xor (1 if the bits differ, 0 if they are the same), and in this way the definition generates the infinite list of δi that is ultimately used to compute the game’s overall payoff for each player.\nWere we to actually try and run a real-world IMP competition by directly implementing the definitions above, and were we to try to implement the Nash equilibrium player strategies, we would immediately run into two elements in the set-up that are incomputable:\nfirst, the choice of a uniform infinitely-long bit-string, our chosen distribution among the potential strategies, is incomputable (it is a choice among uncountably many elements); second, for a deterministic player (an agent) to output all the bits of an arbitrary (i.e., general) bit-string, that player cannot be a Turing machine. There are only countably many Turing machines, so only countably many bit-strings that can thus be output.\nIn this paper, we examine the IMP game with several choices for Σ= and Σ6=. The main case studied is where Σ= = Σ6= = Σ 0 1. In this case, we still allow player mixed strategies to be incomputable distributions, but any L= and L6= are computable by TMs. The set-up described here, where Iterated Matching Pennies is essentially described as a pursuit-evasion game, was initially introduced informally by Scriven [16] in order to prove that unpredictability is innate to humans. Lewis and Richardson [10], without explicitly mentioning Turing machines or any (equivalent) models of computation, reinvestigated the model and used it to refute Scriven’s claim, with a proof that hinges on the halting problem, but references it only implicitly.\nThe set-up was redeveloped independently by Dowe, first in the context of the avoider trying to choose the next number in an integer sequence to be larger (by one) than the (otherwise) best inference that one might expect [1, sec. 0.2.7, p. 545, col. 2 and footnote 211], and then, as in [16], in the context of predicting bits in a sequence [2, p. 455][4, pp. 16–17]. Dowe was the first to introduce the terminology of TMs into the set-up. His aim was to illicit a paradox, which he dubbed “the elusive model paradox”, whose resolution relies on the undecidability of the halting problem. Thus, it would provide an alternative to the method of [21] to prove this undecidability. Variants of the elusive model paradox and of the “red herring sequence” (the optimal sequence to be used by an avoider) are discussed in [3, sec. 7.5], with the paradox also mentioned in [5, sec. 2.2][8, footnote 9].\nYet a third independent incarnation of the model was by Solomonoff, who discussed variants of the elusive model paradox and the red herring sequence in [19, Appendix B] and [18, sec. 3].\nWe note that the more formal investigations of Dowe and of Solomonoff were in contexts in which the “game” character of the set-up was not explored. Rather, the set-up was effectively a one-player game, where regardless of the player’s choice of next bit, the red herring sequence’s next bit was its reverse. We, on the other hand, return to the original spirit of Scriven’s formulation, investigating the dynamics of the two player game, but do so in a formal setting.\nSpecifically, we investigate the question of which of the two players (if either) has an advantage in this game, and, in particular, we will be interested in the game’s Nash equilibria, which are the pairs of strategies (D∗=, D ∗ 6=) for which\nS=(D ∗ =, D ∗ 6=) = sup\nD=\nS=(D=, D ∗ 6=)\nand S 6=(D ∗ =, D ∗ 6=) = sup\nD 6=\nS 6=(D ∗ =, D 6=).\nWe define minmax(Σ=,Σ6=) = inf\nD= sup D 6= S(D=, D 6=)\nand maxmin(Σ=,Σ6=) = sup\nD 6=\ninf D= S(D=, D 6=),\nwhere D= is a (potentially incomputable) distribution over Σ= and D 6= is a (potentially incomputable) distribution over Σ6=. Where Σ= = Σ6= (= Σ), we will abbreviate this to minmax(Σ) and maxmin(Σ).\nA Nash equilibrium (D∗=, D ∗ 6=) must satisfy\nS(D∗=, D ∗ 6=) = maxmin(Σ=,Σ6=) = minmax(Σ=,Σ6=), (6)\nwhere, as before, S = S 6=. We note that while it may seem, at first glance, that the introduction of game dynamics into the problems of learnability and approximability inserts an unnecessary complication into their analysis, in fact, we will show that the ability to learn and/or approximate languages, when worded formally, involves a large number of interlocking “lim”, “sup”, “inf”, “lim sup” and “lim inf” clauses that are most naturally expressed in terms of minmax and maxmin solutions, Nash equilibria and mixed strategies."
    }, {
      "heading" : "3. Halting Turing machines",
      "text" : "The IMP game serves as a natural platform for investigating adversarial learning: each of the players has the opportunity to learn from all previous rounds, extrapolate from this to the question of what algorithm their adversary is employing and then choose their own course of action to best counteract the adversary’s methods.\nFurthermore, where Σ= = Σ6= (= Σ), IMP serves as a natural arena to differentiate between the learning of a language (e.g., one selected from R.E.) and its complement (e.g., a language selected from co-R.E.), because Player “=”, the copying player, is essentially trying to learn a language from Σ, namely that chosen by Player “ 6=”, whereas Player “ 6=” is attempting to learn a language from co-Σ, namely the complement to that chosen by Player “=”. Any advantage to Player “=” can be attributed solely to the difficulty to learn co-Σ by an algorithm from Σ, as opposed to the ability to learn Σ.\nTo exemplify IMP analysis, consider first the game where Σ = ∆01, the set of decidable languages. Because decidable languages are a set known to be closed under complement, we expect Player “ 6=” to be equally as successful as Player “=” in this variation. Consider, therefore, what would be the Nash equilibria in this case.\nTheorem 2. Let Σ be the set of decidable languages over {0, 1}∗. The game IMP(Σ) does not have any Nash equilibria.\nWe remark here that most familiar and typically-studied games belong to a family of games where the space of mixed strategies is compact and convex, such as those having\na finite number of pure strategies, and such games necessarily have at least one Nash equilibrium. However, the same is not true for arbitrary games. (For example, the game of “guess the highest number” does not have a Nash equilibrium.) IMP, specifically, does not belong to a game family that guarantees the existence of Nash equilibria.\nProof. We begin by showing that for any (mixed) strategy D 6=,\nsup D= S=(D=, D 6=) = 1. (7)\nLet T0, T1, . . . be any (necessarily incomputable) enumeration over those Turing machines that halt on every input, and let L0, L1, . . . be the sequence of languages that is accepted by them. The sequence {Li} enumerates (with repetitions) over all languages in Σ = ∆01. Under this enumeration we have\nlim X→∞\nProb(∃x ≤ X , such that L6= = Lx) = 1; L6= ∼ D 6=.\nFor this reason, for any ǫ there exists an X such that\nProb(∃x ≤ X , such that L6= = Lx) ≥ 1− ǫ; L6= ∼ D 6=.\nWe devise a strategy, D=, to be used by Player =. This strategy will be pure: the player will always choose language L=, which we will now describe. The language L= is the one accepted by Algorithm 1.\nAlgorithm 1 Algorithm for learning a mixed strategy\n1: function calculate bit(∆) 2: d ← ‖∆‖1. ⊲ Number of prediction errors so far. 3: if d > X then 4: Accept. 5: else if ∆ ∈ Ld then 6: Accept. 7: else 8: Reject. 9: end if 10: end function\nNote that while the enumeration T0, T1, . . . is not computable, Algorithm 1 only requires T0, . . . , TX to be accessible to it, and this can be done because any such finite set of TMs can be hard coded into Algorithm 1.\nConsider the game, on the assumption that Player “ 6=”’s strategy is Lx for x ≤ X . After at most x prediction errors, Algorithm 1 will begin mimicking a strategy equivalent to Lx and will win every round from that point on.\nWe see, therefore, that for any x ∈ {0, . . . , X} we have S=(L=, Lx) = 1, from which we conclude that S=(D=, D 6=) ≥ 1− ǫ (or, equivalently, S 6=(D=, D 6=) ≤ ǫ), in turn proving that for any Nash equilibrium (D∗=, D ∗ 6=) we necessarily must have\nmaxmin(Σ) = 0. (8)\nFor exactly the symmetric reasons, when Σ = ∆01 we also have\nminmax(Σ) = 1 : (9)\nPlayer “ 6=” can follow a strategy identical to that described in Algorithm 1, except reversing the condition in Step 5.\nBecause we now have that minmax(Σ) 6= maxmin(Σ), we know that Equation (6) cannot be satisfied for any strategy pair. In particular, there are no Nash equilibria.\nThis result is not restricted to Σ = ∆01, the decidable languages, but also to any set of languages that is powerful enough to encode Algorithm 1 and its complement. It is true, for example, for ∆00 as well as for ∆ 0 1 with any set of Oracles, i.e., specifically, for any ∆ 0 i .\nDefinition 2. We say that a collection of languages Σ6= is adversarially learnable by a collection of strategies Σ= if minmax(Σ=,Σ6=) = 0.\nIf a collection is adversarially learnable by Σ01, we simply say that it is adversarially learnable.\nCorollary 2.1. ∀i,∆0i is not adversarially learnable by ∆0i .\nProof. As was shown in the proof of Theorem 2, minmax(∆0i ,∆ 0 i ) = 1.\nWe proceed, therefore, to the question of how well each player fares when Σ includes non-decidable R.E. languages, and is therefore no longer closed under complement."
    }, {
      "heading" : "4. Adversarial learning",
      "text" : "We claim that R.E. languages are adversarially learnable, and that it is therefore not possible to learn the complement of R.E. languages in general, in the adversarial learning scenario.\nTheorem 3. The game IMP(Σ01) has a strategy, L=, for Player “=” that guarantees S 6=(L=, L6=) = 0 for all L6= (and, consequently, also for all distributions among potential L6= candidates).\nIn particular, Σ01 is adversarially learnable.\nProof. We describe L= explicitly by means of an algorithm accepting it. This is given in Algorithm 2.\nNote that Algorithm 2 does not have any “Accept” or “Reject” statements. It returns a bit only if Td returns a bit and does not terminate if Td fails to terminate. To actually\nAlgorithm 2 Algorithm for learning an R.E. language\n1: function calculate bit(∆) 2: Let T0, T1, . . . be an enumeration over all Turing machines. 3: d ← ‖∆‖1. ⊲ Number of prediction errors so far. 4: Simulate Td 5: end function\nsimulate Td and to encode the enumeration T0, . . ., Algorithm 2 can simply use a universal Turing machine, U , and define the enumeration in a way such that U accepts the input “d#∆” if and only if Td accepts the input ∆.\nTo show that Algorithm 2 cannot be countered, consider any R.E. language to be chosen by Player “ 6=”. This language, L6=, necessarily corresponds to the output of Tx for some (finite) x. In total, Player “=” can lose at most x rounds. In every subsequent round, its output will be identical to that of Tx, and therefore identical to the bit chosen by Player “ 6=”.\nWe see, therefore, that the complement of Algorithm 2’s language cannot be learned by any R.E. language. Player “ 6=” cannot hope to win more than a finite number of rounds.\nNote that these results do not necessitate that Σ = Σ01, the R.E. languages. As long as Σ is rich enough to allow implementing Algorithm 2, the results hold. This is true, for example, for Σ sets that allow Oracle calls. In particular:\nCorollary 3.1. For all i > 0, Σ0i is adversarially learnable by Σ 0 i but not by Π 0 i ; Π 0 i is adversarially learnable by Π0i but not by Σ 0 i .\nProof. To show the learnability results, we use Algorithm 2. To show the non-learnability results, we appeal to the symmetric nature of the game: if Player “=” has a winning learning strategy, Player “ 6=” does not."
    }, {
      "heading" : "5. Conventional learnability",
      "text" : "To adapt the IMP game for the study of conventional (i.e., non-adversarial) learning and approximation, we introduce the notion of nonadaptive strategies.\nDefinition 3. A nonadaptive strategy is a language, L, over {0, 1}∗ such that\n∀u, v, |u| = |v| ⇒ (u ∈ L ⇔ v ∈ L),\nwhere |u| is the bit length of u. Respective to an arbitrarily chosen (computable) enumeration w1, w2, . . . over the complete language, we define the function NA() such that, for any language L, NA(L) is the language such that\nx ∈ NA(L) ⇔ w|x| ∈ L. Furthermore, for any collection of languages, Σ, we define NA(Σ) = {NA(L)|L ∈ Σ}. NA(Σ) is the nonadaptive application of Σ.\nTo elucidate this definition, consider once again a (computable) enumeration, w1, w2, . . . over the complete language.\nIn previous sections, we have analysed the case where the two competing strategies are adaptive (i.e., general). This was the case of adversarial learning. Modelling the conventional learning problem is simply done by restricting Σ6= to nonadaptive strategies. The question of whether a strategy L= (or D=) can learn L is the question of whether it can learn adversarially NA(L). The reason this is so is because the bit output at any round i by a nonadaptive strategy is independent of any response made by either player at any previous round: at each round i, O 6=(i+ 1), the response of Player “ 6=”, as defined in (5), is a function of ∆i, a word composed of exactly i bits. Definition 3 now adds to this the restriction that the response must be invariant to the value of these i bits and must depend only on the bit length, i, which is to say on the round number. Regardless of what the strategy of Player “=” is, the sequence O 6=(1), O 6=(2), . . . output by Player “ 6=” will always remain the same. Thus, a nonadaptive strategy for Player “ 6=” is one where the player’s output is a predetermined, fixed string of bits, and it is this string that the opposing strategy of Player “=” must learn to mimic.\nNote, furthermore, that if ΣNA is the set of all nonadaptive languages, then for every i > 0 we have\nNA(Σ0i ) = Σ 0 i ∩ ΣNA. (10)\nThe equality stems from the fact that calculating w|x| from x and vice versa (finding any x that matches w|x|) is, by definition, recursive, so there is a reduction from any L to NA(L) and back. If a language can be computed over the input w|x| by means of a certain nonempty set of quantifiers, no additional unbounded quantifiers are needed to compute it from x.\nThis leads us to Definition 4.\nDefinition 4. We say that a collection of languages Σ6= is (conventionally) learnable by a collection of strategies Σ= if minmax (Σ=,NA(Σ6=)) = 0.\nIf a collection is learnable by Σ01, we simply say that it is learnable.\nCorollary 3.2. For all i > 0, Σ0i is learnable by Σ 0 i . In particular, Σ 0 1 is learnable.\nProof. We have already shown (Corollary 3.1) that Σ0i is adversarially learnable by Σ 0 i , and NA(Σ0i ) is a subset of Σ 0 i , as demonstrated by (10).\nConstraining Player “ 6=” to only be able to choose nonadaptive strategies can only lower the minmax value. Because it is already at 0, it makes no change: we are weakening the player that is already weaker. It is more rewarding to constrain Player “=” and to consider the game IMP (NA(Σ0i ),Σ 0 i ). Note, however, that this is equivalent to the game IMP (Σ0i ,NA(Π 0 i )) under role reversal.\nTheorem 4. Π01 is learnable.\nProof. To begin, let us consider a simpler scenario than was discussed so far. Specifically, we will consider a scenario in which the feedback available to the learning algorithm at each point is not only ∆n, the information of which rounds it had “won” and which it had “lost”, but also O=(n) and O 6=(n), what the bit output by each machine was, at every step.2\nIn this scenario, Player “=” can calculate a co-R.E. function by calculating its complement in round n and then reading the result as the complement to O=(n), which is given to it in all later rounds.\nFor example, at round n Player “=” may simulate a particular Turing machine, T , in order to test whether it halts. If it does halt, the player halts and accepts the input, but it may also continue indefinitely. The end effect is that if T halts then O=(n) = 1 and otherwise it is 0. At round n + 1, Player “=” gets new inputs. (Recall that if one views the player as a Turing machine, it is effectively restarted at each round.) The new input in the real IMP game is ∆n, but for the moment we are assuming a simpler version where the input is the pair of strings (O=(1) . . .O=(n), O 6=(1) . . .O 6=(n)). This being the case, though whether T halts or not is in general not computable by a Σ01 player, once a simulation of the type described here is run at round n, starting with round n+1 the answer is available to the player in the form of O=(n), which forms part of its input.\nMore concretely, one algorithm employable by Player “=” against a known nonadaptive language NA(L6=) is one that calculates “w2n+1 /∈ L6=?” (which is an R.E. function) in every 2n’th round, and then uses this information in the next round in order to make the correct prediction. This guarantees S (L=,NA(L6=)) ≤ 1/2. However, it is possible to do better.\nTo demonstrate how, consider that Player “=” can determine the answer to the question “|{wi, . . . , wj} \\ L6=| ≥ k?” for any chosen i, j and k. The way to do this is to simulate simultaneously all j + 1 − i Turing machine runs that calculate “wl /∈ L6=?” for each i ≤ l ≤ j and to halt if k of them halt. As with the previous example, by performing this algorithm at any stage n, the algorithm will then be able to read out the result as O=(n) in all later rounds.\nConsider, now, that this ability can be used to determine |{wi, . . . , wj} \\ L6=| exactly (rather than simply bounding it) by means of a binary search, starting with the question “|{wi, . . . , wj} \\ L6=| ≥ 2m−1?” in the first round, and proceeding to increasingly finer determination of the actual set size on each later round. Player “=” can therefore determine the number of “1” bits in a set of j + 1 − i = 2m − 1 outputs of a co-R.E. function in this way in only m queries, after which the number will be written in binary form, from most significant bit to least significant bit, in its O= input. Once this cardinality has been determined, Player “=” can compute via a terminating computation the value of each of “wl ∈ L6=?”: the player will simulate, in parallel, all j + 1 − i machines, and will terminate the computation either when the desired bit value is found via a halting of the corresponding machine, or until the full cardinality of halting machines has been reached,\n2Because O=(n)⊕O6=(n)⊕ δn = 0, using any two of these as input to the TM is equivalent to using all three, because the third can always be calculated from the others.\nat which point, if the desired bit is not among the machines that halted, then the player can safely conclude that its computation will never halt.\nLet {mt} be an arbitrary (computable) sequence with limt→∞mt = ∞. If Player “=” repeatedly uses mt bits (each time picking the next value in the sequence) of its own output in order to determine Player “ 6=”’s next 2mt − 1 bits, the proportion of bits determined correctly by this will approach 1.\nHowever, the actual problem at hand is one where Player “=” does not have access to its own output bits, (O=(1), . . . , O=(n)). Rather, it can only see (δ1, . . . , δn), the exclusive or (xor) values of its bits and those of Player “ 6=”. To deal with this situation, we use a variation over the strategy described above.\nFirst, for convenience, assume that Player “=” knows the first m0 bits to be output by Player “ 6=”. Knowing Player “ 6=”’s bits and having visibility as to whether they are the same or different to Player “=”’s bits give, together, Player “=” access to its own past bits.\nNow, it can use these first m0 bits in order to encode, as before, the cardinality of the next 2m0 − 1 bits, and by this also their individual values (as was demonstrated previously with the calculation of “wl ∈ L6=?”). This now gives Player “=” the ability to win every one of the next 2m0−1 rounds. However, instead of utilising this ability to the limit, Player “=” will only choose to win the next 2m0 − 1 − m1, leaving the remaining m1 bits free to be used for encoding the cardinality of the next 2m1 − 1. This strategy can be continued to all mt. The full list of criteria required of the sequence {mt} for this construction to work and to ultimately lead to S (L=,NA(L6=)) = 0 is:\n1. limt→∞ mt = ∞. 2. ∀t,mt+1 ≤ 2mt − 1. 3. limt→∞ mt+1 2mt = 0.\nA sequence satisfying all these criteria can easily be found, e.g. mt = t+ 2. Two problems remain to be solved: (1) How to determine the value of the first m0 bits, and (2) how to deal with the fact that L6= is not known. We begin by tackling the second of these problems. Because L6= is not known, we utilise a strategy of enumerating over the possible languages, similar to what is done in Algorithm 2. That is to say, we begin by assuming that co-L6= = L0 and respond accordingly. Then, if we detect that the responses from Player “ 6=” do not match those of L0 we progress to assume that co-L6= = L1, etc.. We are not always in a position to tell if our current hypothesis of L6= is correct, but we can verify that it matches at least the first 2mt −mt+1 − 1 bits of each 2mt − 1 set. If Player “=” makes any incorrect predictions during any of these 2mt −mt+1−1 rounds, it can progress to the next hypothesis. We note that it is true that Player “=” can remain mistaken about the identity of L6= forever, as long as L6= is such that the first 2\nmt −mt+1 − 1 predictions of every 2mt − 1 are correct, but because these correct predictions alone are enough to ensure S (L=,NA(L6=)) = 0, the question of whether the correct L6= is ultimately found or not is moot.\nTo tackle the remaining problem, that of determiningm0 bits of L= in order to bootstrap the process, we make use of mixed strategies.\nConsider a mixed strategy involving probability 1/2m0 for each of 2m0 strategies, differing only by the m0 bits they assign as the first bits for each language in order to bootstrap the learning process. If co-L6= = L0, of the 2\nm0 strategies one will make the correct guess regarding the first m0 input bits, after which that strategy can ensure S (L=,NA(L6=)) = 0. However, note that, if implemented as described so far, this is not the case for any other Li. Suppose, for example, that co-L6= = L1. All 2\nm0 strategies begin by assuming, falsely, that co-L6= = L0, and all may discover later on that this assumption is incorrect, but they may do so at different rounds. Because of this, a counter-strategy can be designed to fool all 2m0 learner strategies.\nTo avoid this pitfall, all strategies must use the same bit positions in order to bootstrap learning for each Li, so these bit positions must be pre-allocated. We will use bits a2, . . . , a2 + m0 − 1 in order to bootstrap the i’th hypothesis, for some known a = a(i), regardless of whether the hypothesis L= = Li is known to require checking before these rounds, after, or not at all. The full set of rounds pre-allocated in this way still has only density zero among the integers, so even without a win for Player “=” in any of these rounds its final payoff remains 1.\nSuppose, now, that Li is still not the assumption currently being verified (or falsified) at rounds a2, . . . , a2+m0−1. The Hamming weight (number of “1”s) of which 2m0 −1 bits should be encoded by Player “=” in these rounds’ bits? To solve this, we will pre-allocate to each hypothesis an infinite number of bit positions, which, altogether for all hypotheses, still amount to a set of density 0 among the integers. The hypothesis will continuously predict the values of this pre-allocated infinite sequence of bits until it becomes the “active” assumption. If and when it does, it will expand its predictions to all remaining bit positions.\nThis combination of 2m0 strategies, of which one guarantees a payoff of 1, therefore guarantees in total an expected payoff of at least 1/2m0. We want to show, however, that minmax (Σ01,NA(Π 0 1)) = 0. To raise from 1/2\nm0 to 1, we describe a sequence of mixed strategies for which the expected payoff for Player “=” converges to 1.\nThe k’th element in the sequence of mixed strategies will be composed of 2m0k equal probability pure strategies. The strategies will follow the algorithm so far, but instead of moving from the hypothesis co-L6= = Li to co-L6= = Li+1 after a single failed attempt (which may be due to incorrect bootstrap bits), the algorithm will try each Li language k times. In total, it will guess at most m0k bits for each language, which are the m0k bits defining the strategy.\nThis strategy ensures a payoff of at least 1− (1−1/2m0)k, so converges to 1, as desired, for an asymptotically large k.\nThe full algorithm is described in Algorithm 3. It uses the function triangle, defined as follows: let\nbase(x) =\n⌊⌊ √ 8x+ 1⌋ − 1\n2\n⌋\nand triangle(x) = x− base(x)(base(x) + 1)/2. (11)\nThe value of triangle(x) for x = 0, 1, 2, . . . equals\n0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, . . . ,\ndescribing a triangular walk through the nonnegative integers. The algorithm is divided into two stages. In Step 1, the algorithm simulates its actions in all previous rounds, but without simulating any (potentially non-halting) Turing machine associated with any hypothesis. The purpose of this step is to determine which hypothesis (choice of Turing machine and bootstrapping) is to be used for predicting the next bit. Once the hypothesis is determined, Step 2 once again simulates all previous rounds, only this time simulating the chosen hypothesis wherever it is the active hypothesis. In this way, the next bit predicted by the hypothesis can be determined.\nThe specific {mt} sequence used in Algorithm 3 is mt = t + 2 (which was previously mentioned as an example of a sequence satisfying all necessary criteria).\nSome corollaries follow immediately.\nCorollary 4.1. There exists a probabilistic Turing machine that is able to learn any language in Π01 with probability 1.\nProof. Instead of using a mixed strategy, it is possible to use probabilistic Turing machines in order to generate the m0 guessed bits that bootstrap each hypothesis. In this case, there is neither a need for a mixed strategy nor a need to consider asymptotic limits: a single probabilistic Turing machine can perform a triangular walk over the hypotheses for L6=, investigating each option an unbounded number of times. The probability that for the correct L6= at least one bootstrap guess will be correct in this way equals 1.\nThe method for doing this is essentially the same as was described before. The only caveat is that because the probabilistic TM is re-initialised at each round and because it needs, as part of the algorithm, to simulate its actions in all previous rounds, the TM must have a way to store its random choices, so as to make them accessible in all later rounds.\nThe way to do this is to extend the hypothesis “bootstrap” phase from m0 bits to 2m0 bits. In each of the first m0 bits, the TM outputs a uniform random bit. The δn bit available to it in all future rounds is then this random bit xor the output of Player “ 6=”. δn is therefore also a uniform random bit. In this way, in all future rounds the TM has access to these m0 consistent random bits. It can then use these in the second set of m0 bootstrap bits as was done with the j value in the deterministic set-up.\nWe note, as before, that the construction described continues to hold, and therefore the results remain true, even if Oracles are allowed, that are accessible to both players, and, in particular, the results hold for any Π0i with i > 0:\nCorollary 4.2. For all i > 0, Π0i is learnable by Σ 0 i .\nFurthermore:\nAlgorithm 3 Algorithm for learning any co-R.E. language\n1: ⊲ The strategy is a uniform mixture of 4k algorithms. 2: ⊲ We describe the j’th algorithm. 3: function calculate bit(∆) 4: n ← length of ∆ ⊲ The round number. Let ∆ = δ1, . . . , δn. 5: ⊲ Step 1: Identify h, the current hypothesis. 6: NonActiveHypotheses ← {} 7: PredPos ← {} ⊲ A set managing which positions are predicted by which\nhypothesis. 8: for i ∈ 0, . . . , n do 9: if ∃(h, S, S ′) ∈ PredPos such that i ∈ S then 10: Let h, S, S ′ be as above. 11: ⊲ h = hypothesis number. 12: ⊲ S = predicted positions. 13: ⊲ S ′ = next positions to be predicted. 14: Let m be such that 2m−1 − 1 = |S ′|. ⊲ We only construct S ′ that have such\nan m. 15: else if ∃a, h such that a2 = i, h = triangle(a) and h /∈ NonActiveHypotheses\nthen 16: ⊲ First bootstrap bit for hypothesis h. 17: Let h be as above. 18: S ← {} 19: S ′ ← {i, i+ 1} 20: bootstrap(h) ← i 21: m ← 2 22: else if i = n then ⊲ Unusable bits. 23: Accept input. ⊲ Arbitrary choice. 24: else 25: Next i. 26: end if 27: e ← |{x ∈ S|x > i}| 28: if e ≥ m then 29: ⊲ These bits are predicted accurately for the correct hypothesis. 30: if i < n and δi+1 = 1 then 31: ⊲ Incorrect prediction, so hypothesis is false. 32: NonActiveHypotheses ← NonActiveHypotheses ∪ {h} 33: PredPos ← {(h̃, S̃, S̃ ′) ∈ PredPos|h̃ 6= h} 34: end if 35: else if e = m− 1 then ⊲ Bits with e < m are used to encode next bit counts. 36: S̃ ← {} ⊲ New positions to predict on. 37: p ← max(S ′)\n38: while |S̃| < 2m − 1 do 39: p ← p+ 1 40: if (∃a, b such that b ∈ {0, 1}, a2 + b = p and h = triangle(a)) or (h =\nmex(NonActiveHypotheses) and ∄a, b, h̃ such that b ∈ {0, 1}, a2+b = p, h̃ = triangle(a), h̃ /∈ NonActiveHypotheses) then 41: ⊲ “mex(T )” is the minimum nonnegative integer not appearing in T . 42: S̃ ← S̃ ∪ {p} 43: end if 44: end while 45: PredPos ← PredPos ∪ (h, S ′, S̃) 46: end if 47: end for 48: ⊲ Step 2: Predict, assuming h. 49: i ← bootstrap(h) 50: S ← {i, i+ 1} 51: M ← h div k ⊲ TM is the machine to be simulated. x div y def= ⌊x/y⌋. 52: try ← h mod k ⊲ The try number of this machine. 53: Prediction(i) ← (j div 4try) mod 2 54: Prediction(i+ 1) ← (j div (2 · 4try)) mod 2 55: for i ∈ 0, . . . , n do 56: if ∃S, S ′, (h, S, S ′) ∈ PredPos and i ∈ S then 57: Let m be such that 2m − 1 = |S ′|. 58: e ← |{x ∈ S|x > i}| 59: if e = m− 1 then 60: counter ← 0 ⊲ Number of 1’s in S ′. 61: end if 62: if e ≥ m then 63: if i = n then 64: if Prediction(i) = 1 then 65: Accept input. 66: else 67: Reject input. 68: end if 69: end if 70: else if i = n then 71: Simulate TM simultaneously on all inputs in S\n′ until counter + 2e are accepted. 72: ⊲ If this simulation does not terminate, this is a rejection of the input. 73: Accept input. 74: else\n75: if Prediction(i) 6= δi then ⊲ Previous simulation terminated. 76: counter ← counter+ 2e ⊲ Binary search. 77: end if 78: if e = 0 then ⊲ counter holds the number of terminations in S ′. 79: Simulate TM simultaneously on all inputs in S\n′ until counter are accepted. ⊲ Guaranteed to halt, if hypothesis is correct.\n80: Let Prediction(x) be 0 on all x ∈ S ′ that terminated, 1 otherwise. 81: end if 82: end if 83: end if 84: end for 85: end function\nCorollary 4.3. For all i > 0, the collection of languages learnable by Σ0i is a strict superset of Σ0i ∪Π0i .\nProof. We have already shown that Σ0i and Π 0 i are both learnable by Σ 0 i . Adding the Σ 0 i languages as additional hypotheses to Algorithm 3 we can see that the set Σ0i ∪Π0i is also learnable.\nTo give one example of a family of languages beyond this set which is also learnable by Σ0i , consider the following. Let Σ (c) i , for a fixed c > 1, be the set of languages recognisable by a ∆00 Turing machine which can make at most c calls to a Σ 0 i Oracle.\nThis set contains Σ0i and Π 0 i , but it also contains, for example, the xor of any two languages in Σ0i , which is outside of Σ 0 i ∪Π0i , and therefore strictly beyond the i’th level of the arithmetic hierarchy. We will adapt Algorithm 3 to learn Σ\n(c) i . The core of Algorithm 3 is its ability to use m\nbits of ∆n in order to predict 2 m − 1 bits. We will, instead, use cm bits in order to predict the same amount. Specifically, we will use the first m bits in order to predict the result of the first Oracle call in each of the predicted 2m − 1 positions, the next m bits in order to predict the second Oracle call in each of the predicted 2m − 1 positions, and so on.\nIn total, for this to work, all we need is to replace criterion 2 in our list of criteria for the {mt} sequence with the new criterion\n∀t, cmt+1 ≤ 2mt − 1.\nAn example of such a sequence is mt = t+max(c, 5).\nIn fact, Algorithm 3 can be extended even beyond what was described in the proof to Corollary 4.3. For example, instead of using a constant c, it is possible to adapt the algorithm to languages that use c(n) Oracle calls at the n’th round, for a sufficiently low-complexity c(n) by similar methods.\nAltogether, it seems that R.E. learning is significantly more powerful than being able to learn merely the first level of the arithmetic hierarchy, but we do not know whether it\ncan learn every language in ∆02. Indeed, we have no theoretical result that implies R.E. learning cannot be even more powerful than the second level of the arithmetic hierarchy.\nA follow-up question which may be asked at this point is whether it was necessary to use a mixed strategy, as was used in the proof of Theorem 4, or whether a pure strategy could have been designed to do the same.\nIn fact, no pure strategy would have sufficed:\nLemma 4.1. For all i, inf\nL=∈Σ0i sup L 6=∈NA(Π 0 i ) S(L=, L6=) = 1.\nThis result is most interesting in the context of Corollary 4.1, because it describes a concrete task that is accomplishable by a probabilistic Turing machine but not by a deterministic Turing machine.\nProof. We devise for each L= a specific L6= antidote. The main difficulty in doing this is that we cannot choose, as before, L6= = co-L=, because L6= is now restricted to be nonadaptive, whereas L= is general.\nHowever, consider L6= such that its bit for round k is the complement of L=’s response on ∆k−1 = 1 k−1. This is a nonadaptive strategy, but it ensures that ∆k will be 1 k for every k. Effectively, L6= describes L=’s “red herring sequence”."
    }, {
      "heading" : "6. Approximability",
      "text" : "When both players’ strategies are restricted to be nonadaptive, they have no means of learning each other’s behaviours: determining whether their next output bit will be 0 or 1 is done solely based on the present round number, not on any previous outputs. The output of the game is therefore solely determined by the dissimilarity of the two independently-chosen output strings.\nDefinition 5. We say that a collection of languages Σ6= is approximable by a collection of strategies Σ= if minmax (NA(Σ=),NA(Σ6=)) = 0.\nIf a collection is approximable by Σ01, we simply say that it is approximable.\nIn this context it is clear that for any Σ\nsup L 6=∈NA(Σ) inf L=∈NA(Σ) S(L=, L6=) = 0,\nbecause L= can always be chosen to equal L6=, but unlike in the case of adversarial learning, here mixed strategies do make a difference.\nThough we do not know exactly what the value of minmax (NA(Σ01)) is, we do know the following.\nLemma 4.2. If D= and D 6= are mixed strategies from NA(Σ 0 1), then\nsup D 6= inf D= E\n(\nlim sup N→∞\nN ∑\nn=1\nδn N\n)\n≥ 1 2\n(12)\nand\ninf D= sup D 6= E\n(\nlim sup N→∞\nN ∑\nn=1\nδn N\n)\n≥ 1 2 , (13)\nwhere δn is as in the definition of the IMP game.\nIn other words, Player “ 6=” can always at the very least break even, from a lim sup perspective.\nProof. Let D 6= be a mixture of the following two strategies: all zeros (L0), with probability 1/2; all ones (L1), with probability 1/2. By the triangle inequality, we have that for any language L=,\nE\n(\nlim sup N→∞\nN ∑\nn=1\nδn N\n)\n= DisSim(L=, L0) + DisSim(L=, L1) 2 ≥ DisSim(L0, L1) 2 = 1 2 ,\nand because this is true for each L= in D=, it is also true in expectation over all D=. The fact that D 6= is independent of D= in the construction means that this bound is applicable for both (12) and (13).\nJust as interesting (and with tighter results) is the investigation of lim inf. We show\nLemma 4.3.\ninf L=∈NA(Σ01) sup L 6=∈NA(Σ 0 1 ) lim inf N→∞\nN ∑\nn=1\nδn N\n= sup L 6=∈NA(Σ 0 1 ) inf L=∈NA(Σ01) lim inf N→∞\nN ∑\nn=1\nδn N = 0, (14)\nwhere δn is as in the definition of the IMP game.\nProof. Let triangle(x) be as in (11), and let caf(x) be the maximum integer, y, such that y! ≤ x.\nThe language L= will be defined by\nwi ∈ L= ⇔ wi ∈ Ltriangle(caf(i)),\nwhere L0, L1, L2, . . . is an enumeration over all R.E. languages. To prove that for any j, if L6= = Lj the claim holds, let us first join the rounds into “super-rounds”, this being the partition of the rounds set according to the value of y = caf(i). At each super-round, L= equals a specific Lx, and by the end of the superround, a total of (y − 1)/y of the total rounds will have been rounds in which L= equals this Lx. Hence, the Hamming distance between the two (the number of differences) at this time is at most 1/y of the string lengths. Because each choice of x repeats an infinite number of times, the lim inf of this proportion is 0.\nWith this lemma, we can now prove Theorem 1.\nProof. The theorem is a direct corollary of the proof of Lemma 4.3, because the complement of the language L= that was constructed in the proof to attain the infimum can be used as L̄.\nCombining Lemma 4.2 and 4.3 with the definition of the payoff function in (1), we get, in total:\nCorollary 4.4. 1/4 ≤ maxmin (\nNA(Σ01) ) ≤ 1/2 and\n1/4 ≤ minmax ( NA(Σ01) ) ≤ 1/2.\nThough we have the exact value of neither maxmin nor minmax in this case, we do see that the case is somewhat unusual in that neither player has a decisive advantage."
    }, {
      "heading" : "7. Conclusions and further research",
      "text" : "We have introduced the IMP game as an arena within which to test the ability of algorithms to learn and be learnt, and specifically investigated three scenarios:\nAdversarial learning, where both algorithms are simultaneously trying to learn each other by observations.\nNon-adversarial (conventional) learning, where an algorithm is trying to learn a language by examples.\nApproximation, where languages (or language distributions) try to mimic each other without having any visibility to their opponent’s actions.\nIn the case of adversarial learning, we have shown that Σ0i can learn Σ 0 i but not Π 0 i . In conventional learning, however, we have shown that Σi can learn Σ 0 i , Π 0 i and beyond into the (i+ 1)th level of the arithmetic hierarchy, but this learnability is yet to be upperbounded. Our conjecture is that the class of learnable languages is strictly a subset of ∆02. If so, then this defines a new class of languages between the first and second levels of the arithmetic hierarchy, and, indeed, between any consecutive levels of it.\nRegarding approximability, we have shown that (unlike in the previous results) no side has the absolute upper hand in the game, with the game value for Player “ 6=”, if it exists, lying somewhere between 1/4 and 1/2. We do not know, however, whether the game is completely unbiased or not.\nAn investigation of adversarial learning in the context of recursive languages was given as a demonstration of the fact that in IMP it may be the case that no Nash equilibrium exists at all, and pure-strategy learning was given as a concrete example of a task where probabilistic Turing machines have a provable advantage over deterministic ones."
    } ],
    "references" : [ {
      "title" : "Foreword re C",
      "author" : [ "D.L. Dowe" ],
      "venue" : "S. Wallace. Computer Journal, 51(5):523–560, September",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Minimum Message Length and statistically consistent invariant (objective?) Bayesian probabilistic inference – from (medical) “evidence",
      "author" : [ "D.L. Dowe" ],
      "venue" : "Social Epistemology, 22(4):433–460, Oct–Dec",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "MML, hybrid Bayesian network graphical models, statistical consistency, invariance and uniqueness",
      "author" : [ "D.L. Dowe" ],
      "venue" : "Bandyopadhyay, P.S. and Forster, M.R., editor, Handbook of the Philosophy of Science – Volume 7: Philosophy of Statistics, pages 901–982. Elsevier,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Introduction to Ray Solomonoff 85th Memorial Conference",
      "author" : [ "D.L. Dowe" ],
      "venue" : "Proceedings of Solomonoff 85th memorial conference – Lecture Notes in Artificial Intelligence (LNAI), volume 7070, pages 1–36. Springer,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Compression and intelligence: Social environments and communication",
      "author" : [ "D.L. Dowe", "J. Hernández-Orallo", "P.K. Das" ],
      "venue" : "AGI: 4th Conference on Artificial General Intelligence – Lecture Notes in Artificial Intelligence (LNAI), pages 204–211,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The Computational Beauty of Nature: Computer Explorations of Fractals, Chaos, Complex Systems, and Adaptation",
      "author" : [ "G.W. Flake" ],
      "venue" : "A Bradford book. Cambridge, Massachusetts,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Language identification in the limit",
      "author" : [ "E.M. Gold" ],
      "venue" : "Information and Control, 10(5):447– 474,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1967
    }, {
      "title" : "On more realistic environment distributions for defining, evaluating and developing intelligence",
      "author" : [ "J. Hernández-Orallo", "D.L. Dowe", "S. España-Cubillo", "M.V. Hernández-Lloreda", "J. Insa-Cabrera" ],
      "venue" : "AGI: 4th Conference on Artificial General Intelligence – Lecture Notes in Artificial Intelligence (LNAI), volume 6830, pages 82–91. Springer,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Adversarial machine learning",
      "author" : [ "Ling Huang", "Anthony D. Joseph", "Blaine Nelson", "Benjamin I.P. Rubinstein", "J.D. Tygar" ],
      "venue" : "In Proceedings of the 4th ACM Workshop on Security and Artificial Intelligence,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Scriven on human unpredictability",
      "author" : [ "D.K. Lewis", "J.S. Richardson" ],
      "venue" : "Philosophical Studies: An International Journal for Philosophy in the Analytic Tradition, 17(5):69– 74, October",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1966
    }, {
      "title" : "A Game Theoretical Model for Adversarial Learning",
      "author" : [ "Wei Liu", "Sanjay Chawla" ],
      "venue" : "PS and Wu, XD, editor,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2009
    }, {
      "title" : "Adversarial learning",
      "author" : [ "Daniel Lowd", "Christopher Meek" ],
      "venue" : "Proceedings of the Eleventh ACM SIGKDD International Conference on Knowledge Discovery in Data Mining,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2005
    }, {
      "title" : "Non-cooperative Games",
      "author" : [ "J. Nash" ],
      "venue" : "The Annals of Mathematics, 54(2):286–295,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1951
    }, {
      "title" : "Theory of Games and Economic Behavior",
      "author" : [ "J.v. Neumann", "O. Morgenstern" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1944
    }, {
      "title" : "Theory of Recursive Functions and Effective Computability",
      "author" : [ "Hartley Rogers", "Jr." ],
      "venue" : null,
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1987
    }, {
      "title" : "An essential unpredictability in human behavior",
      "author" : [ "M. Scriven" ],
      "venue" : "B.B. Wolman and E. Nagel, editors, Scientific Psychology: Principles and Approaches, pages 411–425. Basic Books (Perseus Books),",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1965
    }, {
      "title" : "Complexity-based induction systems: Comparisons and convergence theorems",
      "author" : [ "R.J. Solomonoff" ],
      "venue" : "IEEE Transaction on Information Theory, IT-24(4):422–432,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1978
    }, {
      "title" : "Algorithmic probability: Theory and applications",
      "author" : [ "R.J. Solomonoff" ],
      "venue" : "F. Emmert- Streib and M. Dehmer, editors, Information Theory and Statistical Learning, Springer Science and Business Media, pages 1–23. Springer, N.Y., U.S.A.,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Algorithmic probability, heuristic programming and AGI",
      "author" : [ "R.J. Solomonoff" ],
      "venue" : "Proceedings of the Third Conference on Artificial General Intelligence, AGI 2010, pages 251–257, Lugano, Switzerland, March",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Algorithmic probability – its discovery – its properties and application to strong AI",
      "author" : [ "R.J. Solomonoff" ],
      "venue" : "H. Zenil, editor, Randomness Through Computation: Some Answers, More Questions, pages 1–23. World Scientific Publishing Co., Inc., River Edge, NJ, USA,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "On computable numbers, with an application to the Entscheidungsproblem",
      "author" : [ "A.M. Turing" ],
      "venue" : "Proc. London Math. Soc., 42:230–265,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 1936
    }, {
      "title" : "A theory of the learnable",
      "author" : [ "Leslie G Valiant" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1984
    } ],
    "referenceMentions" : [ {
      "referenceID" : 20,
      "context" : "Turing’s seminal 1936 result [21] demonstrated that some languages that can be accepted by Turing machines (TMs) are not decidable.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 6,
      "context" : "Valiant in terms of language identification in the limit [7, 22], and also in statistics via the notion of statistical consistency, also known as “completeness” (converging arbitrarily closely in the limit to an underlying true model).",
      "startOffset" : 57,
      "endOffset" : 64
    }, {
      "referenceID" : 21,
      "context" : "Valiant in terms of language identification in the limit [7, 22], and also in statistics via the notion of statistical consistency, also known as “completeness” (converging arbitrarily closely in the limit to an underlying true model).",
      "startOffset" : 57,
      "endOffset" : 64
    }, {
      "referenceID" : 16,
      "context" : "Following upon his convergence results in [17], Solomonoff writes [20, sec.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 11,
      "context" : "Lastly, consider adversarial learning [12, 11, 9].",
      "startOffset" : 38,
      "endOffset" : 49
    }, {
      "referenceID" : 10,
      "context" : "Lastly, consider adversarial learning [12, 11, 9].",
      "startOffset" : 38,
      "endOffset" : 49
    }, {
      "referenceID" : 8,
      "context" : "Lastly, consider adversarial learning [12, 11, 9].",
      "startOffset" : 38,
      "endOffset" : 49
    }, {
      "referenceID" : 14,
      "context" : "Here and elsewhere we use the standard notations for language families in the arithmetical hierarchy [15]: Σ 1 is the set of recursively enumerable languages, Π 1 is the set of co-R.",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 15,
      "context" : "The set-up used is an adaptation of one initially introduced by Scriven [16] of a predictor and a contrapredictive (or avoider) effectively playing what we might nowadays describe as a game of iterated matching pennies.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 13,
      "context" : "283–284]: its only Nash equilibrium [14, 13] is a mixed strategy wherein each player chooses each of the two options with probability 1/2.",
      "startOffset" : 36,
      "endOffset" : 44
    }, {
      "referenceID" : 12,
      "context" : "283–284]: its only Nash equilibrium [14, 13] is a mixed strategy wherein each player chooses each of the two options with probability 1/2.",
      "startOffset" : 36,
      "endOffset" : 44
    }, {
      "referenceID" : 15,
      "context" : "The set-up described here, where Iterated Matching Pennies is essentially described as a pursuit-evasion game, was initially introduced informally by Scriven [16] in order to prove that unpredictability is innate to humans.",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 9,
      "context" : "Lewis and Richardson [10], without explicitly mentioning Turing machines or any (equivalent) models of computation, reinvestigated the model and used it to refute Scriven’s claim, with a proof that hinges on the halting problem, but references it only implicitly.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 15,
      "context" : "2 and footnote 211], and then, as in [16], in the context of predicting bits in a sequence [2, p.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 20,
      "context" : "Thus, it would provide an alternative to the method of [21] to prove this undecidability.",
      "startOffset" : 55,
      "endOffset" : 59
    } ],
    "year" : 2016,
    "abstractText" : "We introduce a problem set-up we call the Iterated Matching Pennies (IMP) game and show that it is a powerful framework for the study of three problems: adversarial learnability, conventional (i.e., non-adversarial) learnability and approximability. Using it, we are able to derive the following theorems. (1) It is possible to learn by example all of Σ1 ∪ Π1 as well as some supersets; (2) in adversarial learning (which we describe as a pursuit-evasion game), the pursuer has a winning strategy (in other words, Σ1 can be learned adversarially, but Π1 not); (3) some languages in Π 0 1 cannot be approximated by any language in Σ 0 1. We show corresponding results also for Σi and Π 0 i for arbitrary i.",
    "creator" : "LaTeX with hyperref package"
  }
}