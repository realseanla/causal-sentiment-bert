{
  "name" : "1509.02012.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Bounded Situation Calculus Action Theories",
    "authors" : [ "Giuseppe De Giacomo", "Yves Lespérance", "Fabio Patrizi" ],
    "emails" : [ "degiacomo@dis.uniroma1.it", "lesperan@cse.yorku.ca", "patrizi@dis.uniroma1.it" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The situation calculus [64,73] is a well-known first-order formalism with certain second-order features for representing dynamically changing worlds. It has proved to be an invaluable formal tool for understanding the subtle issues involved in reasoning about action. Its comprehensiveness allows us to place all aspects of dynamic systems in perspective. Basic action theories let us capture change as a result of actions in the system [72], while high-level languages such as Golog [58] and ConGolog [26] support the representation of processes over the dynamic system. Aspects such as time [74], knowledge and sensing [78], probabilities and utilities [16], and preferences [12], have all been addressed.\nThe price of such a generality is that decidability results for reasoning in the situation calculus are rare, e.g., [85] for an argument-less fluents fragment, and [49] for a description logic-like two-variable fragment. Obviously, we have the major feature of being able to rely on regression to reduce reasoning about a given future situation to reasoning about the initial situation [73]. Generalizations of this basic result such\n4 A preliminary version of this paper appeared as [27].\nar X\niv :1\n50 9.\n02 01\n2v 1\n[ cs\n.A I]\n7 S\nas just-in-time histories [32] can also be exploited. However, when we move to temporal properties, virtually all approaches are based on assuming a finite domain and a finite number of states, and often rely on propositional modal logics and model checking techniques [6,62]. There are only few exceptions such as [22,31,81], which develop incomplete fixpoint approximation-based methods.\nIn this paper, we present an important new result on decidability of the situation calculus, showing that verification of bounded action theories is decidable. Bounded action theories are basic action theories [73], where it is entailed that in all situations, the number of object tuples that belong to the extension of any fluent is bounded. In such theories, the object domain remains nonetheless infinite and an infinite run may involve an infinite number of objects, though at every single situation the number of objects we predicate on is finite and, in fact, bounded.\nBut why should we believe that practical domains conform to this boundedness assumption? While it is often assumed that the law of inertia applies and that fluent atoms persist indefinitely in the absence of actions that affect them, we all know that pretty much everything eventually decays and changes. We may not even know how the change may happen, but nevertheless know that it will. Another line of argument for boundedness is epistemic. Agents remember facts that they use and periodically try to confirm them, often by sensing. A fact that never gets used is eventually forgotten. If a fact can never be confirmed, it may be given up as too uncertain. Given this, it seems plausible that in several contexts an agent’s knowledge, in every single moment, can be assumed to be bounded. While these philosophical arguments are interesting and relate to some deep questions about knowledge representation, one may take a more pragmatic stance, and this is what we do here. We identify some interesting classes of bounded action theories and show how they can model typical example domains. We also show how we can transform arbitrary basic action theories into bounded action theories, either by blocking actions that would exceed the bound, or by having persistence (frame axioms) apply only for a finite number of steps. Moreover we show that we can effectively check whether any arbitrary theory with a bounded initial situation description remains bounded in all executable situations (to do so we need to use verification).\nThe main result of the paper is that verification of an expressive class of firstorder µ-calculus temporal properties in bounded action theories is decidable and in fact EXPTIME-complete. This means that we can check whether a system or process specified over such a theory satisfies some specification even if we have an infinite domain and an infinite set of situations or states. In a nutshell, we prove our results by focussing on the active domain of situations, i.e., the set of objects for which some atomic fluent holds; we know that the set of such active objects is bounded. We show that essentially we can abstract situations whose active domains are isomorphic into a single state, and thus, by suitably abstracting also actions, we can obtain an abstract finite transition system that satisfies exactly the same formulas of our variant of the µ-calculus.\nThis work is of interest not only for AI, but also for other areas of computer science. In particular it is of great interest for the work on data-aware business processes and services [53,45,38]. Indeed while there are well-established results and tools to analyze business processes and services, without considering the data manipulated, when data are taken into account results are scarce. The present work complements that in, e.g.,\n[36,4,9,5,10], and hints at an even more profund relevance of the situation calculus in those areas [63]. More generally, our results can be recast in other reasoning about action formalisms, both in AI and in CS.\nThe rest of the paper is organized as follows. In Section 2, we briefly review the situation calculus and basic action theories. Then in Section 3, we define bounded action theories. Following that in Section 4, we discuss various ways of obtaining bounded action theories, while showing that many practical domains can be handled. In Section 5, we introduce the µŁp language that we use to express first-order temporal properties and its semantics. After that, we show that verification of µŁp properties over bounded action theories is decidable, first in the case where we have complete information about the initial situation in Section 6, and then in the general incomplete information case in Section 7. Then in Section 8, we characterize the worst-case computational complexity of the problem as EXPTIME-complete. In Section 9, we give a technique based on our verification results to check whether an arbitrary basic action theory is maintains boundedness. In Section 10, we review the related literature. Finally, in Section 11, we conclude the paper mentioning topics for future work."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "The situation calculus [64,73] is a sorted predicate logic language for representing and reasoning about dynamically changing worlds. All changes to the world are the result of actions, which are terms in the language. We denote action variables by lower case letters a, action types by capital letters A, and action terms by α, possibly with subscripts. A possible world history is represented by a term called a situation. The constant S0 is used to denote the initial situation where no actions have yet been performed. Sequences of actions are built using the function symbol do, where do(a, s) denotes the successor situation resulting from performing action a in situation s. Besides actions and situations, there is also the sort of objects for all other entities. Predicates and functions whose value varies from situation to situation are called fluents, and are denoted by symbols taking a situation term as their last argument (e.g., Holding(x, s), meaning that the robot is holding object x in situation s). For simplicity, and without loss of generality, we assume that there are no functions other than constants and no non-fluent predicates. We denote fluents by F and the finite set of primitive fluents by F . The arguments of fluents (apart from the last argument which is of sort situation) are assumed to be of sort object.\nWithin this language, one can formulate action theories that describe how the world changes as the result of the available actions. Here, we concentrate on basic action theories as proposed in [66,73]. We also assume that there is a finite number of action types. Moreover, we assume that there is a countably infinite set of object constants N for which the unique name assumption holds. But we do not assume domain closure for objects.5 As a result a basic action theory D is the union of the following disjoint sets of first-order (FO) and second-order (SO) axioms:\n5 Such an assumption is made in [27], where standard names [57] are used to denote objects. Thus, the results here generalize those in [27].\n– D0: (FO) initial situation description axioms describing the initial configuration of the world (such a description may be complete or incomplete); – Dposs: (FO) precondition axioms of the form\nPoss(A(x), s) ≡ φA(x, s),\none per action type, stating the conditions φA(x, s) under which an action A(x) can be legally performed in situation s; these use a special predicate Poss(a, s) meaning that action a is executable in situation s; φA(x, s) is a formula of the situation calculus that is uniform in situation s, that is, a formula that mentions no other situation term but s and does not mention Poss (see [73] for a formal definition);\n– Dssa: (FO) successor state axioms of the form\nF (x, do(a, s)) ≡ φF (x, a, s),\none per fluent, describing how the fluent changes when an action is performed; the right-hand side (RHS) φF (x, a, s) is again a situation calculus formula uniform in s; successor state axioms encode the causal laws of the world being modeled; they take the place of the so-called effect axioms and provide a solution to the frame problem; – Dca: (FO) unique name axioms for actions and (FO) domain closure on action types; – Duno: (FO) unique name axioms for object constants in N ; – Σ: (SO) foundational, domain independent, axioms of the situation calculus [66].\nWe say that a situation s is executable, written Executable(s), if every action performed in reaching s was executable in the situation in which it occurred.\nOne of the key features of basic action theories is the existence of a sound and complete regression mechanism for answering queries about situations resulting from performing a sequence of actions [66,73]. In a nutshell, the regression operator R∗ reduces a formula φ about a particular future situation to an equivalent formula R∗[φ] about the initial situation S0, by basically substituting fluent relations with the righthand side formula of their successor state axioms. Here, we shall use a simple one-step only variant R of the standard regression operator R∗ for basic action theories. Let φ(do(α, s)) be a formula uniform in the situation do(α, s). ThenR[φ(do(α, s))] stands for the one-step regression of φ through the action term α, which is itself a formula uniform in s."
    }, {
      "heading" : "3 Bounded Action Theories",
      "text" : "Let b be some natural number. We use the notation |{x | φ(x)}| ≥ b, meaning that there exist at least b distinct tuples that satisfy φ, to stand for the following FOL formula:\n∃x1, . . . ,xb.φ(x1) ∧ · · · ∧ φ(xb) ∧ ∧\ni,j∈{1,...,b},i6=j\nxi 6= xj .\nWe also use the notation |{x | φ(x)}| < b, meaning that there are fewer than b distinct tuples that satisfy φ, to stand for: ¬(|{x | φ(x)}| ≥ b).\nUsing this, we define the notion of a fluent F (x, s) in situation s being bounded by a natural number b as follows:\nBoundedF,b(s) . = |{x | F (x, s)}| < b,\ni.e., fluent F is bounded by b in situation s if there are fewer than b distinct tuples in the extension of F in situation s.\nThe notion of situation s being bounded by a natural number b is defined as follows:\nBoundedb(s) . = ∧ F∈F BoundedF,b(s),\ni.e., every fluent is bounded by b in situation s. We say that an action theory D is bounded by b if every executable situation is bounded by b, formally:\nD |= ∀s.Executable(s) ⊃ Boundedb(s).\nExample 1. Consider a warehouse where items are moved around by a robot (a similar example is formalized in [30]). There are k storage locations where items can be stored. There is also a shipping dock where new items may arrive and stored items may be shipped out. We can axiomatize this domain as follows.\nWe have the following action precondition axioms:6\nPoss(move(x, l, l′), s) ≡ At(x, l, s) ∧ IsLoc(l′) ∧ ¬∃yAt(y, l′, s) Poss(arrive(x), s) ≡ ¬∃yAt(y, ShipDock) ∧ ¬∃lAt(x, l, s) Poss(ship(x), s) ≡ At(x, ShipDock, s)\nThe first axiom says that in situation s, the robot can perform action move(x, l, l′), i.e., move object x from location l to l′, if and only if x is at l in s and l′ is a location where no object is present in s. The second precondition axiom says that action arrive(x) is executable in situation s, i.e., object x may arrive at the warehouse in s, if and only if the shipping dock is empty and x is not somewhere else in the warehouse. The last axiom says that object x can be shipped in situation s if it is at the shipping dock in s.\nFor the fluent At, we have the following successor state axiom:\nAt(x, l, do(a, s)) ≡ γ(x, l, a, s)+ ∨At(x, l, s) ∧ ¬γ−(x, l, a, s), where γ+(x, l, a, s) = ∃r.a = move(x, l′, l) ∧At(x, l′, s) ∧ IsLoc(l′) ∧ ¬∃yAt(y, l, s)\n∨ a = arrive(x) ∧ l = ShipDock and γ−(x, l, a, s) = ∃l′.a = move(x, l, l′) ∧ l′ 6= l ∧ IsLoc(l′) ∧ ¬∃yAt(y, l′, s)\n∨ a = ship(x) ∧At(x, ShipDoc, s) 6 Throughout this paper, we assume that all free variables in a formula are implicitly universally\nquantified from the outside. Occasionally, to be clear, we will write ∀ϕ to denote the universal closure of ϕ explicitly.\nThis says that object x is at location l in the situation that results from doing action a in s if and only if γ(x, l, a, s)+ holds or if x is already at l in s and γ−(x, l, a, s) doesn’t hold. γ(x, l, a, s)+ specifies the conditions under which action a makes object x be at location l in situation s, i.e., if a is to move x to a free location l from another location l′ where x was in s, or a is x arriving and l is the shipping dock. γ−(x, l, a, s) specifies the conditions under which action a makes object x cease to be at location l in situation s, i.e., a is to move x to a different location that is free, or is to ship x.\nWe specify the initial situation with the following initial state axioms:\n¬At(x, l, S0) IsLoc(l) ≡ l = ShipDock ∨ l = SL1 ∨ . . . ∨ l = SLk\nWe also have unique name axioms for the locations. For clarity, we make IsLoc a nonfluent predicate, although it is easy to recast it as a fluent that is unaffected by any action.\nIt is not difficult to show that this theory is in fact bounded by k + 1. First note that there are k + 1 locations initially and the set of locations never changes, so IsLoc is bounded by k + 1. For fluent At, it is initially bounded by 0, but the arrive action can augment its extension. However, the action theory ensures there can be at most one item at each of the k+1 locations. ThusAt remains bounded by k+1. Therefore, the theory is bounded by k + 1.\nObserve that, as there are infinitely many constants denoting distinct objects, effectively an unbounded number of items may be handled by subsequent arrive, move, and ship actions. Despite this, the theory remains bounded.\nWe shall see that for bounded action theories, verification of sophisticated temporal properties is decidable."
    }, {
      "heading" : "4 Obtaining Bounded Action Theories",
      "text" : "Before focusing on verification, in this section we look at various interesting sufficient conditions that guarantee that a basic action theory is bounded. Later in Section 9, we will see that it is actually possible to use verification itself to check whether any arbitrary basic action theory, with a bounded initial situation description, is indeed bounded."
    }, {
      "heading" : "4.1 Bounding by Blocking",
      "text" : "We observe that the formula Boundedb(s) is a FO formula uniform in s and hence it is regressable for basic action theories. This allows us to introduce a first interesting class of bounded action theories. Indeed, from any basic action theory, we can immediately obtain a bounded action theory by simply blocking the execution of actions whenever the result would exceed the bound.\nLet D be a basic action theory. We define the bounded basic action theory Db by replacing each action precondition axiom in D of the form Poss(a(x), s) ≡ Φ(x, s) by a precondition axiom of the form\nPoss(a(x), s) ≡ Φ(x, s) ∧R[Boundedb(do(a(x), s))] (1)\nTheorem 1. Let D be a basic action theory with the initial description D0 such that D0 |= Boundedb(S0), for some b, and let Db be the basic action theory obtained as discussed above. Then, Db is bounded by b.\nProof. By (1) it is guaranteed that any executable action leads to a bounded situation. Hence by induction on executable situations, we get the thesis.\nExample 2. Suppose that we have a camera on a smart phone or tablet computer. We could model the storage of photos on the device using a fluent PhotoStored(p, s), meaning that photo p is stored in the device’s memory. Such a fluent might have the following successor state axiom:\nPhotoStored(p, do(a, s)) ≡ a = takePhoto(p) ∨ PhotoStored(p, s) ∧ a 6= deletePhoto(p)\nWe may also assume that action takePhoto(p) is always executable and that deletePhoto(p) is executable in s if p is stored in s:\nPoss(takePhoto(p), s) ≡ True Poss(deletePhoto(p), s) ≡ PhotoStored(p, s).\nNow such a device would clearly have a limited capacity for storing photos. If we assume for simplicity that photos come in only one resolution and file size, then we can model this by simply applying the transformation discussed above. This yields the following modified precondition axioms:\nPoss(takePhoto(p), s) ≡ |{p′ | PhotoStored(p′, s)}| < b− 1\nPoss(deletePhoto(p), s) ≡ PhotoStored(p, s) ∧ |{p′ | PhotoStored(p′, s)}| < b+ 1.\nNote how the condition on on the right hand side of the first axiom above ensures there are fewer than b photos stored after the action of taking a photo p occurs. Clearly, the resulting theory is bounded by b (assuming that the original theory is bounded by b in S0).\nNote that this way of obtaining a bounded action theory is far from realistic in modeling the actual constraints on the storage of photos. One could develop a more accurate model, taking into account the size of photos, the memory management scheme used, etc. This would also yield a bounded action theory, though one whose boundedness is a consequence of a sophisticated model of memory capacity.\nExample 3. Let’s extend the previous example by supposing that the device also maintains a contacts directory. We could model this using a fluent InPhoneDir(name, number, photo, s), with the following successor state axiom:\nInPhoneDir(na, no, p, do(a, s)) ≡ a = add(na, no, p) ∨ InPhoneDir(na, no, p, s) ∧ a 6= deleteName(na) ∧ a 6= deleteNumber(no)\nWe could then apply our transformation to this new theory to obtain a bounded action theory, getting precondition axioms such as the following:\nPoss(add(na, no, p), s) ≡ PhotoStored(p, s) ∧ |{p′ | PhotoStored(p′, s)}| < b ∧ |{〈na, no, p〉 | InPhoneDir(na, no, p, s)}| < b− 1\nThe resulting theory blocks actions from being performed whenever the action would result in a number of tuples in some fluent exceeding the bound.\nWe observe that this kind of bounded action theories are really modeling a capacity constraint on every fluent,7 which may block actions from being executed. As a result, an action may be executable in a situation in the original theory, but not executable in the bounded one. Thus an agent may want to “plan” to find a sequence of actions that would make the action executable again. In general, to avoid dead-ends, one should carefully choose the original action theory on which the bound is imposed, in particular there should always be actions that remove tuples from fluents."
    }, {
      "heading" : "4.2 Effect Bounded Action Theories",
      "text" : "Let’s consider another sufficient condition for boundedness. Without loss of generality we can take the general form of successor state axioms to be as follows:\nF (x, do(a, s)) ≡ Φ+F (x, a, s) ∨ (F (x, s) ∧ ¬Φ − F (x, a, s))\nWe say that fluent F is effect bounded if:\n|{x | Φ+F (x, a, s)}| ≤ |{x | Φ − F (x, a, s)}|,\ni.e., for every action and situation, the number of tuples added to the fluent is less than or equal to that deleted.\nWe say that a basic action theory is effect bounded if every fluent F ∈ F is effect bounded.\nTheorem 2. Let D be an effect bounded basic action theory with the initial situation description D0 such that D0 |= Boundedb(S0), for some b. Then D is bounded by b. Proof. By induction on executable situations.\nExample 4. Many axiomatizations of the Blocks World are not effect bounded. For instance, suppose that we have fluents OnTable(x, s), i.e., block x is on the table in situation s, and On(x, y, s), i.e., block x is on block y in situation s, with the following successor state axioms:\nOnTable(x, do(a, s)) ≡ a = moveToTable(x) ∨OnTable(x, s) ∧ ¬∃y.a = move(x, y)\nOn(x, y, do(a, s)) ≡ a = move(x, y) ∨On(x, y, s) ∧ ¬∃z.(z 6= y ∧ a = move(x, z)) ∧ a 6= moveToTable(x)\n7 The bound b applies to each fluent individually, so the total number of tuples in a situation is bounded by |F|b. Instead, one could equivalently impose a global capacity bound on the total number of tuples for which some fluent holds in a situation.\nThen, performing the action moveToTable(B1) will result in a net increase in the number of objects that are on the table (assuming that the action is executable and that B1 is not already on the table). Thus, fluent OnTable is not effect bounded in this theory.\nHowever, it is easy to develop an alternative axiomatization of the Blocks World that is effect bounded. Suppose that we use only the fluent On(x, y, s) and the single action move(x, y), where y is either a block or the table, which is denoted by the constant Table. We can axiomatize the domain dynamics as follows:\nOn(x, y, do(a, s)) ≡ a = move(x, y) ∨On(x, y, s) ∧ ¬∃z.(z 6= y ∧ a = move(x, z))\nThat is, x is on y after action a is performed in situation s if and only if a is moving x onto y or x is already on y in situation s and a does not involve moving x onto an object other than y. We say that move(x, y) is executable in situation s if and only if x is not the table in s, x and y are distinct, x is clear and on something other than y in s, and y is clear unless it is the table in s:\nPoss(move(x, y), s) ≡ x 6= Table ∧ x 6= y ∧ ¬∃z.On(z, x, s) ∧ ∃z.(z 6= y ∧On(x, z, s)) ∧ (y = Table ∨ ¬∃z.On(z, y, s))\nThen it is easy to show that any occurence of move(x, y) in a situation s where the action is executable, adds 〈x, y〉 toO = {〈x′, y′〉 | On(x′, y′, s)}while deleting 〈x, y′′〉 for some y′′ s.t. y′′ 6= y, leaving |O| unchanged. Note that we must require that x be on something in the action precondition axiom to get this. Any action other than move(x, y) leaves O unchanged. Thus On is effect bounded.\nThe precondition that x be on something formove(x, y) to be executable means that we cannot move a new unknown block onto another or the table. We must of course impose restrictions on “moving new blocks in” if we want to preserve effect boundedness. One way to do this is to add an action replace(x, y), i.e. replacing x by y. We can specify its preconditions as follows:\nPoss(replace(x, y), s) ≡ x 6= Table ∧ y 6= Table ∧ x 6= y ∧ ¬∃z.On(z, x, s) ∧ ∃z.On(x, z, s) ∧ ¬∃z.On(z, y, s) ∧ ¬∃z.On(y, z, s)\nThat is, replace(x, y) is executable in situation s if and only if x and y are not the table and are distinct, x is clear and on something in s, and y is clear and not on something in s. We can modify the successor state axiom for On to be:\nOn(x, y, do(a, s)) ≡ a = move(x, y) ∨ ∃z.(a = replace(z, x) ∧On(z, y, s)) ∨On(x, y, s) ∧ ¬∃z.(z 6= y ∧ a = move(x, z)) ∧ ¬∃z.(z 6= y ∧ a = replace(x, z)),\nwhereOn(x, y) becomes true if x replaces z and z was on y in s, andOn(x, y) becomes false if z replaces x and x was on y in s. It is straightforward to show that this change leaves On effect bounded.\nExample 5. For another simple example (perhaps more practical), let’s look at how we could specify the “favorite web sites” menu of an internet application. We can assume that there is a fixed number of favorite web sites positions on the menu, say 1 to k. We can replace what is at position n on the menu by the URL u by performing the action replace(n, u). This can be axiomatized as follows:\nFavoriteSites(n, u, do(a, s)) ≡ a = replace(n, u) ∨ FavoriteSites(n, u, s) ∧ ¬∃u′.(u′ 6= u ∧ a = replace(n, u′))\nPoss(replace(n, u), s) ≡ n ∈ [1..k] ∧ ∃u′.FavoriteSites(n, u′, s) It is easy to show that in this axiomatization, FavoriteSites is effect bounded. No action, including replace(n, u), causes the extension of the fluent to increase.\nThe FavoriteSites fluent is typical of many domain properties/relations, such as the passengers in a plane, the students in a class, or the cars parked in a parking lot, where we can think of the relation as having a finite capacity, and where we can reassign the objects that are in it. In some cases, the capacity bound may be difficult to pin down, e.g., the guests at a wedding, altough the capacity is by no means unbounded. As well, there are definitely examples where we need an unbounded theory, e.g., to model a pushdown automata that can recognize a particular context-free language. The situation calculus is a very expressive language that accomodates this, for instance, it has been used to model Turing machines [73]. One might arguably want an unbounded “favorite sites” menu or contacts directory, although this seems hardly practical. Another interesting question is how such capacity constraints might apply to a complex agent such as a robot that is modeling its environment. Clearly, such a robot would have limitations with respect to how many environment features/objects/properties it can memorize and track. Finally, note that the condition |{x | Φ+F (x, a, s)}| ≤ |{x | Φ − F (x, a, s)}| is not a FO formula and it is difficult (in fact, undecidable) in general to determine whether a basic action theory is effect bounded. But as our examples illustrate, there are many instances where it is easy to show that the bounded effects condition holds."
    }, {
      "heading" : "4.3 Fading Fluents Action Theories",
      "text" : "Fading fluents action theories are based on the idea that information over time loses strength and fades away unless it is reinforced explicitly. A fading fluents action theory with fading length given by a natural number ` is an action theory where a fluent F (x, s) is defined by making use of some auxiliary fluents Fi(x, s), for 0 ≤ i ≤ ` where F (x, s) . = ∨ 0≤i≤` Fi(x, s) and the auxiliary fluents have successor state axioms of the following special form:\nF`(x, do(a, s)) ≡ Φ+F (x, a, s) ∧ |{x | ∃a.Φ + F (x, a, s)}| < b\nand for 0 ≤ i < ` we have:\nFi(x, do(a, s)) ≡ ¬Φ+F (x, a, s) ∧ Fi+1(x, s) ∧ ¬Φ − F (x, a, s).\nThus, tuples are initially added to F`, and progressively lose their strength, moving from Fi to Fi−1 each time an action occurs that does not delete or re-add them; eventually they move out of F0 and are forgotten. Note that:\n– Technically, a fading fluents action theory is a basic action theory having as fluents only the auxiliary fluents. – It is simple to obtain a fading fluent version of any basic action theory. – It is often convenient to include explicit refreshF (x) actions, whose effect, when\napplied to a situation s, is simply to make F`(x, do(refreshF (x, s))) true, and Fi(x, do(refreshF (x, s))) false for 0 ≤ i < `. Similarly it may be convenient to include forgetF (x) actions, whose effect is to make Fi(x, do(forgetF (x, s))) false, for all i.\nTheorem 3. Let D be a fading fluents action theory with fading length ` and initial database D0 such that D0 |= Boundedb(S0), for some b. Then, D is bounded by b.\nProof. By induction on executable situations. For the base case, we have that initially for each fluent, we have at most b facts, hence S0 is bounded by b. For the inductive case, by the inductive hypothesis we have that Boundedb(s). Now, take an arbitrary action a(t), and an arbitrary fluent F . Then: (i) BoundedF`,b(do(a(t), s)), since positive effects are bounded by b in its successor state axiom; and (ii) for all 0 ≤ i < `, since Fi depends on Fi+1 in the previous situation in its successor state axioms, we have that BoundedFi,b(do(a(t), s)) since BoundedFi+1,b(s) and in the worst case the whole extension of Fi+1 in s is carried over to Fi in do(a(t), s).\nExample 6. Imagine a sort of “vacuum cleaner world” where a robotic vacuum cleaner may clean a room or region r [75]. If a room/region is used, then it becomes unclean. We could model this using a fluent IsClean(r, s) with the following successor state axiom:\nIsClean(r, do(a, s)) ≡ a = clean(r) ∨ IsClean(r, s) ∧ ¬a = use(r)\nClearly, cleanliness is a property that fades over time. By applying the proposed transformation to this specification, we obtain the following:\nIsClean`(r, do(a, s)) ≡ a = clean(r) ∧ 1 < b\nand for 0 ≤ i < ` we have:\nIsCleani(r, do(a, s)) ≡ a 6= clean(r) ∧ IsCleani+1(r, s) ∧ a 6= use(r)\nThis is a somewhat more realistic model where after ` steps, we forget about a room being clean.\nExample 7. Consider a robot that can move objects around. We might model this using a fluent At(objet, location, s) with the following successor state axiom:\nAt(o, l, do(a, s)) ≡ a = moveTo(o, l) ∨ a = observe(o, l) ∨ At(o, l, s) ∧ a 6= takeAway(o) ∧ ¬∃l′.l′ 6= l ∧ (a = moveTo(o, l′) ∨ a = observe(o, l′))\nHere, moveTo(o, l) represents the robot’s moving object o to location l. We also have an action observe(o, l) of observing that object o is at location l, a kind of exogenous\naction that might be produced by the robot’s sensors. As well, we have another exogenous action takeAway(o), representing another agent’s taking object o to an unknown location l. If the world is dynamic, most objects would not remain where they are indefinitely, even if the robot is unaware of anyone moving them. By applying the proposed transformation to this specification, we obtain a theory where information about the location of objects fades unless it is refreshed by the robot’s observations or actions. After ` steps, the robot forgets the location of an object it has not observed or moved; moreover, this happens immediately if the object is taken away by another agent.\nExample 8. As a final example, consider a softbot that keeps track of which hosts are online. We might model this using a fluent NonFaulty(host, s) with the following successor state axiom:\nNonFaulty(h, do(a, s)) ≡ a = pingS(h) ∨NonFaulty(h, s) ∧ a 6= pingF (r)\nHere the action pingS(h) means that the host h has been pinged successfully, and the action pingF (h) means that the host h has not responded to a pinging within the allocated time. As time passes, we may not want to assume that currently non-faulty hosts remain non-faulty. If we apply the proposed transformation to this specification, we obtain a theory where information about hosts being non-faulty fades. The agent must periodically ping the host successfully to maintain its knowledge that the host is non-faulty.\nAn interesting natural example of such fading representations is the pheromones left by insects. Note that it is also possible to model fading with time as opposed to fading with the number of actions, though in this case we have to bound how many actions can occur between clock ticks."
    }, {
      "heading" : "5 Expressing Dynamic Properties",
      "text" : "To express properties about Situation Calculus action theories, we introduce a specific logic, inspired by the µ-calculus [40,17], one of the most powerful temporal logics, subsuming both linear time logics, such as Linear Temporal Logic (LTL) [68] and PropertySpecification Language (PSL) [39], and branching time logics such as Computational Tree Logic CTL [21] and CTL∗ [41]. The main characteristic of the µ-calculus is its ability to express directly least and greatest fixpoints of (predicate-transformer) operators formed using formulae relating the current state to the next one. By using such fixpoint constructs one can easily express sophisticated properties defined by induction or co-induction. This is the reason why virtually all logics used in verification can be considered as fragments of µ-calculus. Technically, the µ-calculus separates local properties, asserted on the current state or on states that are immediate successors of the current one, from properties talking about states that are arbitrarily far away from the current one [17]. The latter are expressed through the use of fixpoints. Our variant of the µ-calculus is able to express first-order properties over situation. At the same time, it allows for a controlled form of first-order quantification across situations, inspired by [5], where the quantification ranges over objects that persist in the extension of some fluents across situations.\nFormally, we define the logic µŁp as:\nΦ ::= ϕ | ¬Φ | Φ1 ∧ Φ2 | ∃x.LIVE(x) ∧ Φ | LIVE(x) ∧ 〈−〉Φ | LIVE(x) ∧ [−]Φ | Z | µZ.Φ\nIn addition, we use the usual FOL abbreviations for ∨, ⊃, ≡, and ∀, plus the standard µ-calculus abbreviation νZ.Φ = ¬µZ.¬Φ[Z/¬Z]. Let us comment on some aspects of µŁp:\n– ϕ in the expression above is an arbitrary (possibly open) uniform situationsuppressed (i.e., with all situation arguments in fluents suppressed) situation calculus FO formula, in which the only constants that may appear are those explicitly mentioned in the situation calculus theory beyond Duno, i.e., those occurring in Dposs ∪ Dssa ∪ D0.8 Observe that quantification inside ϕ is not subject to any restriction; in particular, LIVE(·) is not required. – The boolean connectives have their usual meaning. Quantification over individuals in ∃x.LIVE(x)∧Φ and ∀x.LIVE(x) ⊃ Φ (i.e., ¬∃x.LIVE(x)∧¬Φ) has the expected meaning, with the proviso that individuals over which quantification ranges must belong to the active domain of the current situation, i.e., belong to the extension of some fluent in the current situation, as required by LIVE(·). – Intuitively, the use of LIVE(·) in µŁp ensures that objects are only considered in quantification across situations if they persist along the system evolution, while the evaluation of a formula with objects that are not present in the current extension of the fluents trivially evaluates to either false for ∃ or true for ∀. In particular: • LIVE(x) ∧ 〈−〉Φ denotes the set of situations s such that for some action a\nthat is executable in s, we have that Φ holds in do(a, s), with the variables occurring free in Φ, x, assigned to objects that are in the active domain of the current situation s. • LIVE(x) ∧ [−]Φ denotes those situations s such that for all actions a that are\nexecutable in s, we have that Φ holds in do(a, s) with the variables occurring free in Φ are assigned to objects that are in the active domain of the current situation s. • LIVE(x) ⊃ 〈−〉Φ (i.e., ¬(LIVE(x) ∧ [−]¬Φ)) denotes those situations s such\nthat for some action a that is executable in s, we have that Φ holds in do(a, s) as long as the variables occurring free in Φ are assigned to objects that are in the active domain of the current situation s. • LIVE(x) ⊃ [−]Φ (i.e., ¬(LIVE(x) ∧ 〈−〉¬Φ)) denotes those situations s such\nthat for all actions a that are executable in s, we have that Φ holds in do(a, s) as long as the variables occurring free in Φ are assigned to objects that are in the active domain of the current situation s.\n– Z is an SO (0-ary) predicate variable. – µZ.Φ and νZ.Φ are fixpoint formulas and denote respectively the least and the\ngreatest fixpoint of the formula Φ seen as a predicate transformer λZ.Φ. To guarantee the existence of such fixpoints, as usual in the µ-calculus, formulae of the form\n8 Clearly, we can get around this assumption by adding to the initial situation description, a new “dummy” fluent that holds for a bounded number of constants.\nµZ.Φ and νZ.Φ must satisfy syntactic monotonicity of Φ with respect to Z, which states that every occurrence of the variable Z in Φ must be within the scope of an even number of negation symbols. – µZ.Φ and νZ.Φ may contain free individual variables, which are those of Φ; technically these act as parameters of the fixpoint formula, i.e., the value of fixpoints µZ.Φ and νZ.Φ is determined only once an assignment to the free individual variables is given, see, e.g., [59] (chap. 10). – Finally, with a slight abuse of notation, we write LIVE(x1, . . . , xn) =∧ i∈{1,...,n} LIVE(xi), and we assume that in LIVE(x)∧〈−〉Φ and LIVE(x)∧ [−]Φ,\nthe variables x are exactly the free individual variables of Φ, after we have substituted each bound predicate variable Z in Φ by the corresponding binding fixpoint formula µZ.Φ′ or νZ.Φ′.\nWe can express arbitrary temporal/dynamic properties using least and greatest fixpoint constructions. For instance, to say that it is possible to eventually achieve ϕ, where ϕ is a closed situation suppressed formula, we use the least fixpoint formula µZ.ϕ∨〈−〉Z. Similarly, we can use a greatest fixpoint formula νZ.ϕ∧ [−]Z to express that ϕ must always hold.\nExample 9. We can give several examples of properties that we may want to verify for the warehouse robot domain of Example 1. First, suppose that we want to say that it is possible to eventually have shipped all items that are in the factory. This can be expressed in our language as a least fixpoint formula:\nµZ.¬∃x∃l.At(x, l) ∨ 〈−〉Z\nThis formula, let’s call it Φeg9, corresponds to the CTL formula EF¬∃x∃l.At(x, l). In the above, we rely on the fact that if there are no items left in the factory, then all items that were there must have been shipped. It is easy to check that the theory of Example 1, D1, entails that this formula holds in the initial situation S0, formally D1 |= Φeg9. In fact, we can also show that the above property always holds:\nD1 |= νZ.Φeg9 ∧ [−]Z.\nThis corresponds to the CTL formula AGEF¬∃x∃l.At(x, l). Note that more generally, a formula µZ.ϕ ∨ 〈−〉Z, i.e., EFϕ in CTL, represents an instance of a planning problem; it is entailed by a theory if there exists an executable sequence of actions such that the goal ϕ holds afterwards.\nA second example property that we may want to verify is that it is possible to eventually have all items shipped out of the factory and then later to eventually have all locations filled with items. This can be expressed as follows:\nD1 |= µZ.[(¬∃l∃x.At(x, l)) ∧ µZ.(∀l.IsLoc(l) ⊃ ∃x.At(x, l)) ∨ 〈−〉Z)] ∨ 〈−〉Z\nor equivalently in CTL notation\nD1 |= EF ((¬∃l∃x.At(x, l)) ∧ EF (∀l.IsLoc(l) ⊃ ∃x.At(x, l))).\nOur next example concerns a safety property; we can show that it is always the case that if an item is at the shipping dock it can be moved away or shipped out next:\nD1 |= νZ.[(∃x.At(x, ShipDock)) ⊃ 〈−〉(¬∃x.At(x, ShipDock))] ∧ [−]Z\nor equivalently in CTL notation\nD1 |= AG[(∃x.At(x, ShipDock)) ⊃ 〈−〉(¬∃x.At(x, ShipDock))].\nHowever, this is not the case for other locations, as it is possible for all locations to become occupied, at which point the agent must ship the item at the shipping dock before it can transfer the item at the location of interest there:\nD1 |= ¬νZ.[∀l.(LIVE(l) ⊃ (∃x.At(x, l) ⊃ (LIVE(l) ⊃ 〈−〉(¬∃x.At(x, l)))))] ∧ [−]Z\nwhich simplifies to (also observing that ∃x.At(x, l) implies LIVE(l)):\nD1 |= ¬νZ.[∀l.(∃x.At(x, l) ⊃ 〈−〉(¬∃x.At(x, l)))] ∧ [−]Z.\nBut it is always possible to clear a location in two steps:\nD1 |= νZ.[∀l.(∃x.At(x, l) ⊃ (〈−〉(LIVE(l) ∧ 〈−〉(¬∃x.At(x, l)))))] ∧ [−]Z\nThe above involves quantification across situations, and we require the location involved to persist (it trivially does).\nNow, let’s consider another example were we quantify across situations. We may want to say that it is always the case that if an item is in the warehouse, it is possible to have it persist until it is eventually shipped out:\nD1 |= νZ.[∀x.(∃l.At(x, l)) ⊃ µZ.(¬∃l.At(x, l)) ∨ LIVE(x) ∧ 〈−〉Z] ∧ [−]Z.\nor equivalently in CTL notation\nD1 |= AG[∀x.(∃l.At(x, l)) ⊃ EF¬∃l.At(x, l)].\nNote that the weaker property that it is always the case that if an item is in the warehouse, it is possible to have it shipped out eventually if it persists also holds:\nD1 |= νZ.[∀x.(∃l.At(x, l)) ⊃ µZ.(¬∃l.At(x, l)) ∨ (LIVE(x) ⊃ 〈−〉Z)] ∧ [−]Z.\nFinally, consider the property that if an item is eventually shipped, it is possible for it to eventually come back:\n∀x.∃l.At(x, l)) ⊃ AG[¬∃l.At(x, l) ⊃ EF∃l.At(x, l)].\nWe cannot express this property in µŁp because x does not persist after it has been shipped. The closest translation\n∀x.LIVE(x) ∧ ∃l.At(x, l) ⊃ νZ.[¬∃l.At(x, l) ⊃ µZ.(∃l.At(x, l)) ∨ LIVE(x) ∧ 〈−〉Z] ∧ [−]Z.\nis always false because if x is not at some location, then it is not in the active domain and LIVE(x) is false.\nNext we turn to semantics. Since µŁp contains formulae with free individual and predicate variables, given a model M of an action theory D with object domain ∆ and situation domain S, we introduce a valuation (v, V ) formed by an individual variable valuation v which maps each individual variable x to an object v(x) in ∆, and a parametrized predicate variable valuation V , which, given the valuation of the individual variables v, maps each predicate variable to Z to subset V (v, Z) of situations in S (notice that for each individual variable valuation v the mapping may change). Given a valuation (v, V ), we denote by (v, V )[x/d] the valuation (v′, V ′) such that: (i) for every individual variable y 6= x we have v′(y) = v(y) and v′(x) = d, (ii) for every predicate variableZ we have V ′(v′, Z) = V (v′, Z) Sometimes we also use the notation v[x/d] to denote v′ such that for every individual variable y 6= x we have v′(y) = v(y) and v′(x) = d. To express that v assigns the values d to the variables x, we use the notation x/d. Analogously, we denote by (v, V )[Z/E ] the valuation (v′, V ′) such that: (i) for every individual variable x we have v′(x) = v(x), (ii) for every predicate variable Y 6= Z we have V ′(v′, Y ) = V (v, Y ), and for Z we have V ′(v′, Y ) = E . Also we denote by adomM(s), the active (object) domain of situation s in the modelM, which is the set of all objects occurring in some FM(s) (F ∈ F) or as the denotation inM of a constant in the set C of object constants occurring in Dposs ∪ Dssa ∪ D0. Then we assign semantics to formulae by associating to a modelM, and a valuation (v, V ) an extension function (·)M(v,V ), which maps µŁp formulae to subsets of S as inductively defined as follows (for clarity, we interpret explicitly also the abbreviation νZ.Φ):\n(ϕ)M(v,V ) = {s ∈ S | M, v |= ϕ[s]} (¬Φ)M(v,V ) = S − (Φ) M (v,V ) (Φ1 ∧ Φ2)M(v,V ) = (Φ1) M (v,V ) ∩ (Φ2) M (v,V ) (∃x. LIVE(x) ∧ Φ)M(v,V ) = {s ∈ S | ∃d ∈ adom M(s). s ∈ (Φ)M(v,V )[x/d]} (LIVE(x) ∧ 〈−〉Φ)M(v,V ) = {s ∈ S | x/d ∈ v and d ⊆ adom M(s) and ∃a. (a, s) ∈ PossM and doM(a, s) ∈ (Φ)M(v,V )} (LIVE(x) ∧ [−]Φ)M(v,V ) = {s ∈ S | x/d ∈ v and d ⊆ adom\nM(s) and ∀a. (a, s) ∈ PossM implies doM(a, s) ∈ (Φ)M(v,V )}\n(Z)M(v,V ) = V (v, Z) (µZ.Φ)M(v,V ) = ⋂ {E ⊆ S | (Φ)M(v,V )[Z/E] ⊆ E}\n(νZ.Φ)M(v,V ) = ⋃ {E ⊆ S | E ⊆ (Φ)M(v,V )[Z/E]}\nNotice that given a (possibly open) uniform situation-suppressed situation calculus formula ϕ, slightly abusing notation, we denote by ϕ[s] the corresponding formula with situation calculus argument reintroduced and assigned to situation s.\nIntuitively, the extension function (·)M(v,V ) assigns the following meaning to the µŁp constructs:9\n9 By mentioning situations explicitly, it is also possible to define these operators directly in second-order logic as follows [33]:\nµZ.Φ[s] ≡ ∀Z.(∀ŝ.Φ[ŝ] ⊃ Z(ŝ)) ⊃ Z(s) νZ.Φ[s] ≡ ∃Z.(∀ŝ.Z(ŝ) ⊃ Φ[ŝ]) ∧ Z(s)\n– The extension of µZ.Φ is the smallest subset Eµ of situations such that, assigning to Z the extension Eµ, the resulting extension of Φ is contained in Eµ (with the assignments of the individual variables and the other predicate variables given by v and V , respectively). That is, the extension of µZ.Φ is the least fixpoint of the operator (Φ)M(v,V )[Z/E]. Notice that for each valuation of the free individual variables in Φ this operator will be different: the free variables act as parameters of the predicate transformer λZ.Φ. – Similarly, the extension of νZ.Φ is the greatest subset Eν of situations such that, assigning to Z the extension Eν , the resulting extension of Φ contains Eν . That is, the extension of νZ.Φ is the greatest fixpoint of the operator (Φ)M(v,V )[X/E].\nNotice also that when a µŁp formula Φ is closed, its extension (Φ)M(v,V ) does not depend on the valuation (v, V ). In fact, the only formulas of interest in verification are those that are closed.\nObservation 1 Observe that we do not have actions as parameters of [−]· and 〈−〉·. However we can easily remember the last action performed, and in fact a finite sequence of previous actions. To do this, for each action type A(x), we introduce a fluent LastA(x, s) with successor state axiom:\nLastA(x, do(a, s)) ≡ a = A(x)\nWe can also remember the second last action by introducing fluents SecondLastA(x, s) with successor state axioms:\nSecondLastA(x, do(a, s)) ≡ LastA(x, s)\nSimilarly for the third last action, etc. In this way we can store a finite suffix of the history in the current situation and write FO formulas relating the individuals in the parameters of actions occurring in the suffix. For example, we can write (assuming for simplicity that the mentioned fluents have all the same arity):\nµZ.(∃x.LastA(x) ∧ SecondLastB(x)) ∨ 〈−〉Z,\ni.e., it is possible to eventually do B(x) followed by A(x) for some x.\nObservation 2 Observe that while our µŁp allows for quantification over objects that persist across situations, the expressiveness of bounded action theories means that we can often to avoid its use. For instance, we can easily introduce a finite number of “registers”, i.e., fluents that store only one tuple, which can be used to store and refer to tuples across situations. We can do this by introducing fluents Regi(x, s) and two\nNote thatΦmay contain free individual and predicate variables, and indeed these remain free in µZ.Φ and νZ.Φ. In this paper, we prefer to leave the situation implicit to allow for interpreting formulas over arbitrary transition systems, including finite ones, and hence relating our logic to standard µ-calculus.\nactions setRegi(x) and clearRegi to set and clear the registerRegi respectively. These are axiomatized as follows:\nRegi(x, do(a, s)) ≡ a = setRegi(x) ∨ Regi(x, s) ∧ a 6= clearRegi Poss(setRegi(x), s) ≡ ¬∃x.Regi(x, s) Poss(clearRegi, s) ≡ ∃x.Regi(x, s)\nFor example, we can write (assuming for simplicity that the mentioned fluents have all the same arity):\nµZ.(∃x.Regi(x) ∧ F (x) ∧ 〈−〉∃y.Regi(y) ∧ F ′(y)) ∨ 〈−〉Z\nThis formula says that there exists a sequence of actions where eventually the tuple referred to by register i has property F and there is an action after which it has property F ′. Note also that this approach can be used to handle some cases of quantification over objects that don’t persist across situations."
    }, {
      "heading" : "6 Verification of Bounded Action Theories with Complete Information on S0",
      "text" : "We now show that verifying µŁp properties against bounded action theories is decidable. In this section we focus on action theories with complete information on the initial situation. The case of incomplete information is addressed in the next section. In particular, we assume that the extension of all fluents in the initial situation S0 is given as a (bounded) database. We further assume that the domain of interpretation for objects ∆ is also given. Notice that, as a consequence of the presence of infinitely many object constants and the unique name assumption on them Duno, such an object domain ∆ must be infinite.10 As a result of these two assumptions, we have that the action theory D admits only one modelM∆ [66], which, with a little abuse of terminology, we call the model of the action theory D (though in order to define it we need ∆ as well).\nOur main result is the following.\nTheorem 4. Let D be a bounded action theory with initial situation described by a (bounded) database and with infinite object domain ∆, and let Φ be a closed µŁp formula. Then checking whether D |= Φ is decidable.\nThe proof is structured as follows. Firstly, we show that actions terms can be eliminated from µŁp formulas with out loss of generality (cf. Section 6.1). Exploiting this, we show that only the fluent extensions in each situation and not situations themselves are relevant when evaluating µŁp formulas (cf. Section 6.2). In this step, we also prove that checking FO formulas and answering FO queries locally, i.e., on a given situation, are, respectively, decidable and effectively computable, under boundedness.\n10 By the way in case of action theories with a given finite object domain, verification becomes easily reducible to model checking, since the corresponding situation calculus model it is bisimilar to a finite propositional transition system.\nThen, based on the observations above, we introduce transition systems as alternative structures (to the models of situation calculus action theories), over which µŁp formulas can be evaluated. Transition systems are less rich than the models of situation calculus action theories, as they do not reflect, in general, the structure of the situation tree. Yet, they can accommodate the information of models needed to evaluate µŁp formulas (cf. Section 6.3 and 6.4). In this step, we define the notion of persistencepreserving bisimulation, i.e., a variant of standard bisimulation which requires a certain kind of isomorphism to exist between bisimilar states and their successors (cf. page 24), and prove that persistence-preserving bisimilar transition systems preserve the truthvalue of µŁ formulas (cf. Theorem 13). This is a key step in the proof, which allows us to reduce the verification of µŁp formulas over an infinite transition system to that over a bisimilar transition system that is finite.\nIn the third and fundamental step (Section 6.5), we carry out a faithful abstraction operation, and show how to actually construct a finite transition system that is persistence-preserving bisimilar to the one, infinite, induced by the model of the action theory (cf. Procedure 1 and Theorems 15 and 16). Finally, we prove that verification is decidable on finite transition systems, thus on the one induced by the model of the action theory (cf. Theorem 17).\nThe rest of this section details these steps."
    }, {
      "heading" : "6.1 Suppressing Action Terms",
      "text" : "Under uniqueness of action names, domain closure for actions, and the fact that action types are finitely many, w.l.o.g., we can remove action terms from uniform situation calculus formulas.\nTheorem 5. For every, possibly open, situation calculus FO formula ϕ(x, s) uniform in s and with free variables x, all of object sort, there exists a situation calculus formula ϕ′(x, s) uniform in s, where no action terms occur, such that\nDca |= ∀(ϕ(x, s) ≡ ϕ′(x, s)).\nProof. By induction on the structure of ϕ. For ϕ = F (t, s), we have that by definition t can only contain object terms so ϕ′ = ϕ, else ϕ′ = ϕ. For ϕ = A(y) = A′(y′), with x ⊆ y ∪ y′, if A = A′, then ϕ′ = y = y′, else ϕ′ = ⊥. The case of boolean connectives is straightforward. If ϕ = ∃a.φ(x, a, s), consider the formula ϕ′′ = ∨ A∈A ∃yA.φA(x,yA, s), with φA obtained from φ(x, a, s), by replacing each occurrence of a with A(yA), where yA are fresh variables. We obviously have: Dca |= ∀(ϕ ≡ ϕ′′). Now, for each φA, let φ′A be a formula containing no action terms, such that Dca |= ∀(φA ≡ φ′A). By induction hypothesis, such a φ′A exists. Finally, let ϕ′ = ∨ A∈A ∃yA.φ′A(x,yA, s). Clearly, ϕ′ contains no action terms and is uniform in s. By considering unique name axioms for actions and domain closure for action types (Dca), we can see that Dca |= ∀(ϕ′′ ≡ ϕ′). Thus, since Dca |= ∀(ϕ ≡ ϕ′′), the thesis follows, i.e., Dca |= ∀(ϕ ≡ ϕ′).\nSuch a result immediately extends to µŁp, since in µŁp formulas only uniform (situation suppressed) situation calculus FO subformulas can occur.\nTheorem 6. Any µŁp formula Φ can be rewritten into an equivalent µŁp formula Φ′, where no action terms occur, such that Dca |= ∀(Φ ≡ Φ′).\nOn the basis of this theorem, w.l.o.g., we will always rewrite µŁp formulas so as that actions do not occur in them."
    }, {
      "heading" : "6.2 Suppressing Situation Terms",
      "text" : "Since the FO components of µŁp formulas are situation-suppressed, situations are obviously irrelevant when checking µŁp formulas; more precisely, the FO components (thus the whole logic) are sensitive only to the interpretation of fluents (and constants) at each situation, while the situations themselves are not relevant. The impact of this observation on the evaluation of µŁp formulas in the general case will become evident in Section 6.4. Here, we focus on the local evaluation of FO components (on the interpretation of a single situation), or more specifically of FO situation calculus formulas uniform in s, and present some notable results that, besides being interesting per se, will be useful later on.\nGiven a basic action theory D, we denote by F the set of its fluent symbols and by C the (finite) set of constants inN explicitly mentioned inD, beyondDuno. Then given a modelM ofD with object domain∆ and a situation s, it is natural to associate s with a FO interpretation IM(s) . = 〈∆, ·I〉, where: (i) for every c ∈ C, cI = cM and (ii) for every (situation-suppressed) fluent F of D, F I = {d | 〈d, s〉 ∈ FM}. The following result is an obvious consequence of the definitions above.\nTheorem 7. For any possibly open FO situation-suppressed situation calculus formula ϕ uniform in s, any situation s and any object variable valuation v, we have that M, v |= ϕ[s] if and only if IM(s), v |= ϕ.\nIn other words, when evaluating a uniform FO situation-calculus formula on a situation, one needs only focus on the interpretation relative to the situation of interest.\nNext, we show that, for bounded action theories, we have decidability of evaluation of FO formulas in spite of the object domain being infinite. Even more, we obtain that we can compute the answers to FO queries on specific situations. Notice that the latter result is not obvious, in that the object domain is infinite and, thus, so could be the answer. Importantly, these results imply that we can check action executability and compute the effects of action executions, two facts that we will strongly leverage on when checking µŁp formulas.\nWe begin by showing some results concerning the decidability of FO formula evaluation in an interpretation with finite predicate extensions, but infinite domain. More precisely, we consider a finite set F of predicate symbols (situation-suppressed fluents) and a finite set C (a subset of N ) of constant symbols, a (FO) interpretation I, over an infinite domain ∆ is a tuple I = 〈∆, ·I〉, where ·I assigns an extension F I over ∆ to each predicate symbol F ∈ F , and a distinct object cI ∈ ∆ to every constant in C. The active domain of an interpretation I, denoted adom(I) is the set of all the individuals occurring in the extension of some fluent F ∈ F , or interpreting some constant c ∈ C, in I. Moreover, for simplicity, we assume that all constants mentioned in FO formulas of interest belong to C.\nFirst, let us recall a classical result saying that FO formulas (with no function symbols other than constants) can always be rewritten as formulas with quantified variables ranging only over the active domain of the interpretation. For an interpretation I = 〈∆, ·I〉, we define the restriction of I to its active domain as the interpretation Ĩ = 〈adom(I), ·I〉. In words, Ĩ is the same interpretation as I, except that the object domain is replaced by the active domain.\nTheorem 8 (Theorem 5.6.3 of [60]). For every FO formula ϕ, one can effectively compute a formula ϕ′, with quantified variables ranging only over the active domain, such that for any interpretation I = 〈∆, ·I〉 with infinite domain ∆, and any valuation v, we have that I, v |= ϕ if and only if Ĩ, v |= ϕ′.\nThis result says that checking whether I, v |= ϕ′ requires knowing only the interpretation function ·I of I, while the interpretation domain ∆ can be disregarded. In other words ϕ′ is a domain-independent formula [1]. One way to obtain domain-independent formulas is to avoid the use of negation and instead use logical difference with respect to the active domain. The above theorem says that it is always possible to transform a FO formula to be evaluated over an infinite domain to a domain-independent one to be evaluated over the active domain only (and actually its proof gives an effective procedure to do so).\nAn immediate consequence of Theorem 8 is that if adom(I) is finite, then checking whether I, v |= ϕ is decidable, no matter whether the interpretation domain of I is finite or infinite. Indeed, in the former case, decidability is obvious, while in the latter, one can simply check Ĩ, v |= ϕ′, which requires only lookups on the finite extensions of fluents and, in presence of quantified variables, iterating over the finitely many elements of the active domain. Thus, we have the following result.\nTheorem 9. Given a possibly open FO formula ϕ and an interpretation I = 〈∆, ·I〉 with infinite ∆, if adom(I) is finite, then, for any valuation v, checking whether I, v |= ϕ is decidable.\nProof. See discussion above.\nTheorem 9 can be lifted to computing all the valuations v such that I, v |= ϕ. Let ϕ be a FO formula with free variables x, and I = 〈∆, ·I〉 a FO interpretation. Then, the answer on I to ϕ is the relation ϕI .= {d ∈∆ | I, v |= ϕ, for v(x) = d}. Sometimes, it is useful to fix the valuation of some variables xin ⊆ x, say v(xin) = din, and then consider the answer to ϕ under this partial assignment, that is, the relation ϕIxin/din . = {dout ∈ ∆ | I, v |= ϕ, for v(xin) = din and v(x \\ xin) = dout}11. The following theorem says that if I has an infinite domain∆ but a finite active domain and the answer ϕIxin/din is finite, then the objects occurring in the answer come necessarily from either the active domain, or the values assigned to xin by v.\nTheorem 10. Consider a FO formula ϕ with free variables x. Let I be an interpretation with infinite ∆ and finite active domain. If ϕIxin/din is finite, then ϕ I xin/din\n⊆ (adom(I) ∪ din)n, where n = |x \\ xin|. 11 x \\ xin denotes the tuple obtained from x by projecting out the components of xin.\nProof. By contradiction. It can be easily proven that if I, v |= ϕ, for v(xi) = di /∈ (adom(I)∪din) and xi ∈ x\\xin, then for any other valuation v′ = v[xi/d′i] such that d′i ∈ ∆ \\ (adom(I) ∪ din), we have that I, v′ |= ϕ. Since ∆ is infinite and adom(I) is finite, such d′i are infinitely many, thus ϕ I xin/din is infinite. Contradiction.\nIn other words, any “new” object, with respect to those in adom(I), occurring in the answer, must come from din. A direct consequence of Theorems 9 and 10 is that one can actually compute the answer on I to ϕ.\nTheorem 11. Consider a FO formula ϕ with free variables x. Let I = 〈∆, ·I〉 be an interpretation with infinite∆ and finite active domain. If, for some valuation v such that v(xin) = din, ϕIxin/din is finite, then ϕ I xin/din is effectively computable.\nProof. It suffices to record in ϕIxin/din all those tuples dout such that for some v with v(xin) = din and v(x\\xin) = dout, it is the case that I, v |= ϕ. Since by Theorem 10 such dout are finitely many and can be obtained using values from adom(I) ∪ din, which is finite, and, by Theorem 9, checking whether I, v |= ϕ is decidable, it follows that ϕIxin/din is computable.\nThese results find immediate application to the case of bounded action theories. Indeed, bounded action theories guarantee that IM(s), in Theorem 7, is finite, (for s executable). Thus, by Theorem 9, for ϕ and v as above, we have that checking whether IM(s), v |= ϕ is decidable. A useful implication of this is that it is decidable to check whether an action AM(o) is executable in a given situation s. Indeed, this requires checking whether M, v |= Poss(A(x), s), with v(x) = o, which, by Theorem 7, is equivalent to IM(s), v |= φA(x), with φA(x, s) the RHS of the the precondition axiom of A, which, in turn, is decidable. Moreover, Theorem 11, can be used to show that for a bounded action theory, the effects of executing an action at a given situation, as determined the successor-state axioms, are computable and depend only on IM(s) (and the action). Indeed, we can exploit these results to get a sort of one-step regression theorem in our setting [66,73].\nTheorem 12. Let M be a model of a bounded action theory D, s an executable situation, and a = AM(o) an action, with action type A(y). Then, for any fluent F , there exists a situation-suppressed action-term-free formula φ = φ(x,y) such that F IM(do\nM(a,s)) = φ IM(s) y/o , and hence F IM(doM(a,s)) is effectively computable.\nProof. Let F (x, do(a, s)) ≡ φF (x, a, s) be the successor-state axiom for fluent F . For the extension of F at situation s′ = doM(a, s), we have that 〈p, s′〉 ∈ F iff M, v |= φF (x, A(y), s), for some v such that v(x) = p and v(y) = o. Notice that φF contains, in general, action and situation terms, and is uniform in s. However, by Theorem 5, it can be rewritten as an equivalent action-term-free formula φAF (x,y, s). Then, by suppressing the situation argument, we obtain: p ∈ F IM(s ′) iff IM(s), v |= φAF (x,y), for some v such that v(x) = p and v(y) = o. That is, for φ = φAF , F IM(s′) = φ IM(s) y/o . Thus, since by boundedness of D, F\nIM(s′) is finite, Theorem 11 implies the thesis.\nThis result implies that, given IM(s) and an action a = AM(o), we can obtain the interpretation of each F at doM(a, s) by simply “querying” IM(s). Hence, by taking the same interpretation of constants as inM, we can construct IM(doM(a, s)), from IM(s) and the successor-state axioms of D."
    }, {
      "heading" : "6.3 µŁp over Transition Systems",
      "text" : "The results presented in Section 6.1 and 6.2 suggest that, for the purpose of verification of µŁp formulas, one can operate on simpler structures than the models of situation calculus action theories. Indeed, as we saw, both actions and situations can be essentially disregarded. In this section, we introduce such simpler structures, namely transition systems (TS), show how µŁp formulas are evaluated over them, and present some important results that allow us to perform the verification on TSs instead of on the original model. The connection between models of situation calculus theories and transition systems will be discussed in Section 6.4. By Theorem 5, we can focus, without loss of generality, on a variant of µŁp where action terms do not occur.\nBy IntF,C∆ , we denote the set of all possible interpretations of the situation suppressed fluents in F and constants in C, over the object domain ∆. A transition system (TS) (over the situation-suppressed fluents F , constants C, and object domain ∆) is a tuple T = 〈∆,Q, q0,→, I〉, where:\n– ∆ is the object domain; – Q is the set of states; – q0 ∈ Q is the initial state; – →⊆ Q×Q is the transition relation; and – I : Q 7→ IntF,C∆ is the labeling function associating each state q with an interpre-\ntation I(q) = 〈∆, ·I(q)〉 such that the constants in C are interpreted in the same way in all the states over which I is defined.\nTo interpret a µŁp formula over a TS T = 〈∆,Q, q0,→, I〉, we use valuations (v, V ) formed by an individual variable valuation v and a parametrized predicate variable valuation V , as in Section 5. We define the extension function (·)T(v,V ), which maps µŁp formulas to subsets of Q, as follows:\n(ϕ)T(v,V ) = {q ∈ Q | I(q), v |= ϕ} (¬Φ)T(v,V ) = Q− (Φ) T (v,V ) (Φ1 ∧ Φ2)T(v,V ) = (Φ1) T (v,V ) ∩ (Φ2) T (v,V ) (∃x. LIVE(x) ∧ Φ)T(v,V ) = {q ∈ Q | ∃d ∈ adom(I(q)). q ∈ (Φ) T (v,V )[x/d]} (LIVE(x) ∧ 〈−〉Φ)T(v,V ) = {q ∈ Q | x/d ∈ v and d ⊆ adom(I(q)) and ∃q′.q → q′ and q′ ∈ (Φ)T(v,V )} (LIVE(x) ∧ [−]Φ)T(v,V ) = {q ∈ Q | x/d ∈ v and d ⊆ adom(I(q)) and ∀q′. q → q′ implies q′ ∈ (Φ)T(v,V )} (Z)T(v,V ) = V (Z)\n(µZ.Φ)T(v,V ) = ⋂ {E ⊆ Q | (Φ)T(v,V )[Z/E] ⊆ E}\nGiven a µŁp formula Φ, we say that a transition system T satisfies Φ at state q, under v and V , written T, q, (v, V ) |= Φ, if q ∈ (Φ)T(v,V ). When Φ is closed on predicate variables, we omit V , as irrelevant, and write T, q, v |= Φ. If Φ is closed on both individual and predicate variables we simply write T, q |= Φ. For closed formulas, we say that T satisfies Φ, written T |= Φ, if T, q0 |= Φ.\nFor our TSs we can prove a suitable version of the classical bisimulation invariance results for the µ-calculus, which state that bisimilar TSs satisfy exactly the same µcalculus formulas, see e.g., [17]. Obviously, the notion of bisimulation needed here is not the classical one, but one that takes into account the FO interpretations labeling the states of the transition systems, as well as the controlled form of quantification across states allowed in µŁp.\nWe first recall the standard notions of isomorphism and isomorphic interpretations. Two FO interpretations I1 = 〈∆1, ·I1〉 and I2 = 〈∆2, ·I2〉, over the same fluents F and constants C, are said to be isomorphic, written I1 ∼ I2, if there exists a bijection (called isomorphism) h : ∆1 7→ ∆2 such that: (i) for every F ∈ F , x ∈ F I1 if and only if h(x) ∈ F I2 ; (ii) for every c ∈ C, cI2 = h(cI1). It is immediate to see that if h is an isomorphism, then so is h−1, and that ∼ is an equivalence relation. Intuitively, for two interpretations to be isomorphic, it is required that one can be obtained from the other by renaming the individuals in the interpretation domain. Notice that, necessarily, the interpretation domains of isomorphic interpretations have same cardinality. When needed, to make it explicit that h is an isomorphism between I1 and I2, we write I1 ∼h I2. We denote by h|D1 the restriction of h toD1, i.e., the mapping h|D1 : D1 7→ h(D1), such that h|D1(d) = h(d), for every d ∈ D1. In addition, recall that Ĩ = 〈adom(I), ·I〉 denotes the restriction of an interpretation I = 〈∆, ·I〉 to its active domain.\nThe bisimulation relation that captures µŁp can be defined as follows. Let T1 = 〈∆1, Q1, q10,→1, I1〉 and T2 = 〈∆2, Q2, q20,→2, I2〉 be two transition systems (over the situation-suppressed fluents and constants of an action theory D), and let H be the set of all possible bijections h : D1 7→ D2, for D1 ⊆ ∆1 and D2 ⊆ ∆2. A relation B ⊆ Q1 × H × Q2 is a persistence-preserving bisimulation between T1 and T2, if 〈q1, h, q2〉 ∈ B implies that:\n1. Ĩ1(q1) ∼h Ĩ2(q2); 2. for each q′1 ∈ Q1, if q1 →1 q′1 then there exists q′2 ∈ Q2 such that:\n(a) q2 →2 q′2, (b) there exists a bijection h′ : adom(I1(q1))∪adom(I1(q′1)) 7→ adom(I2(q2))∪\nadom(I2(q′2)) such that its restriction h′|adom(I1(q1)) coincides with h and its restriction h′|adom(I1(q′1)) is such that 〈q ′ 1, h ′|adom(I1(q′1)), q ′ 2〉 ∈ B;\n3. for each q′2 ∈ Q2, if q2 →2 q′2 then there exists q′1 ∈ Q1 such that: (a) q1 →2 q′1, (b) there exists a bijection h′ : adom(I1(q1))∪adom(I1(q′1)) 7→ adom(I2(q2))∪\nadom(I2(q′2)) such that its restriction h′|adom(I1(q1)) coincides with h and its restriction h′|adom(I1(q′1)) is such that 〈q ′ 1, h ′|adom(I1(q′1)), q ′ 2〉 ∈ B.\nNotice that requirements 2b and 3b impose the existence of a bijection h′ that preserves the bijection h (in fact, the isomorphism) between the objects in adom(I1(q1)) and those in adom(I2(q2)); this essentially means that the “identity” of such objects is\npreserved along the transition. Moreover, h′ is required to induce an isomorphism between adom(I1(q′1)) and adom(I2(q′2)), when restricted to adom(I1(q′1)), such that 〈q′1, h′|adom(I1(q′1)), q ′ 2〉 ∈ B.\nWe say that a state q1 ∈ Q1 is (persistence-preserving) bisimilar to q2 ∈ Q2, written q1 ≈ q2, if there exists a persistence-preserving bisimulationB between T1 and T2 such that 〈q1, h, q2〉 ∈ B, for some h; when needed, we also write q1 ≈h q2, to explicitly name h. Finally, a transition system T1 is said to be persistence-preserving bisimilar to T2, written T1 ≈ T2, if q10 ≈ q20. It is immediate to see that bisimilarity between states and transition systems, i.e., the (overloaded) relation ≈, is an equivalence relation.\nNext, we prove a result (Theorem 13) saying that µŁp enjoys invariance under this notion of bisimulation. To this end, we first show the result for the simpler logic ŁP , obtained from µŁp by dropping the fixpoint construct. Namely, ŁP is defined as:\nΦ ::= ϕ | ¬Φ | Φ1 ∧ Φ2 | ∃x.LIVE(x) ∧ Φ | LIVE(x) ∧ 〈−〉Φ | LIVE(x) ∧ [−]Φ\nSuch a logic corresponds to a first-order variant of the Hennessy-Milner Logic [50]. Note that its semantics is completely independent from the second-order valuation.\nGiven an individual variable valuation v we denote by IM(v) its image on the object domain.\nLemma 1. Consider two transition systems T1 = 〈∆1, Q1, q10,→1, I1〉 and T2 = 〈∆2, Q2, q20,→2, I2〉, two states q1 ∈ Q1, q2 ∈ Q2, such that q1 ≈h q2, and two individual variable valuations v1 and v2 mapping variables to ∆1 and ∆2, respectively. If there exists a bijection ĥ between adom(I1(q1))∪ IM(v1) and adom(I2(q2))∪ IM(v2) whose restriction ĥ|adom(I1(q1)) coincides with h and such that for each individual variable x, ĥ(v1(x)) = v2(x), then for every formula Φ of ŁP , possibly open on individual variables, we have that:\nT1, q1, v1 |= Φ if and only if T2, q2, v2 |= Φ.\nProof. We proceed by induction on the structure of Φ. For Φ = ϕ, we observe that, by Theorem 8, Ii(qi), vi |= ϕ if and only if Ĩi(qi), vi |= ϕ′ (i = 1, 2), for ϕ′ the rewriting of ϕ as its domain-independent version. Further, since Ĩ1(q1) ∼h Ĩ2(q2), and there is a bijection ĥ between the objects assigned to variables by v1 and v2 (even if they are not in adom(I1(q1)) or adom(I2(q2))), by the invariance of FOL wrt isomorphic interpretations, it follows that Ĩ1(q1), v1 |= ϕ′ if and only if Ĩ2(q2), v2 |= ϕ′. These two facts easily imply the thesis. The cases of boolean connectives are obtained by straightforward induction using the same individual valuations v1 and v2 and the same bijection ĥ.\nFor Φ = ∃y.LIVE(y)∧Φ′. Suppose that T1, q1, v1 |= Φ. Then, for some d1, it is the case that T1, q1, v1[y/d1] |= LIVE(y)∧Φ′. Notice that this implies d1 ∈ adom(I1(q1)), then ĥ(d1) = h(d1) = d2, for some d2 ∈ adom(I2(q2)), as ĥ coincides with h on adom(I1(q1)). Consider the individual valuation v2[y/d2]. For every variable x we have ĥ(v1[y/d1](x)) = v2[y/d2](x) (for y we have v2[y/d2](y) = d2 = ĥ(d1) = ĥ(v1[y/d1](y))). Hence, using these new valuations and the same bijection ĥ, now restricted to IM(v1[y/d1]) and IM(v2[y/d2]) (to take into account the assignments\nto y), we can apply the induction hypothesis, and conclude that T2, q2, v2[y/d2] |= LIVE(y) ∧ Φ′, which implies T2, q2, v2 |= Φ. The other direction is proven symmetrically.\nFor Φ = LIVE(x) ∧ 〈−〉Φ′. Suppose that T1, q1, v1 |= (LIVE(x) ∧ 〈−〉Φ′). By definition, this implies that v1(xi) ∈ adom(I1(q1)) for each xi ∈ x, and there exists a transition q1 →1 q′1 such that T1, q′1, v1 |= Φ′. Since q1 ≈h q2, there exist: (i) a transition q2 →2 q′2, and (ii) a bijection h′ : adom(I1(q1)) ∪ adom(I1(q′1)) 7→ adom(I2(q2)) ∪ adom(I2(q′2)) such that its restriction h′|adom(I1(q1)) coincides with h, its restriction h′|adom(I1(q′1)) is an isomorphism such that Ĩ1(q ′ 1) ∼h′|adom(I1(q′1)) Ĩ2(q′2), and q′1 ≈h′|adom(I1(q′1)) q ′ 2. Now consider two new variable valuations v ′ 1 and v′2, defined as follows:\n– for xi ∈ x (for which we have that v1(xi) ∈ adom(I1(q1))), let v′1(xi) = v1(xi) and v′2(xi) = v2(xi); – choose d1 ∈ ∆1 and, for all y 6∈ x, let v′1(y) = d1, then: if d1 ∈ adom(I1(q1)) ∪ adom(I1(q′1)), for all y /∈ x, let v′2(y) = h′(d1); else, choose d2 6∈ adom(I2(q2)) ∪ adom(I2(q′2)), let, for all y /∈ x, v′2(y) = d2, and contextually extend h′ so that h′(d1) = d2.\nAs a result, for all variables x, we have h′(v′1(x)) = v ′ 2(x) (for h ′ possibly extended as above). Consider the bijection ĥ′ = h′|adom(I1(q′1))∪IM(v′1). With this new bijection and the valuations v′1 and v ′ 2, we can apply the induction hypothesis, and obtain that T1, q ′ 1, v1 |= Φ′ implies T2, q′2, v′2 |= Φ′, and since q2 →2 q′2, we have that T2, q2, v′2 |= (LIVE(x)∧〈−〉Φ′). Now, observe that the only free variables of (LIVE(x)∧〈−〉Φ′) are xi ∈ x, and that, for these, we have v′1(xi) = v1(xi) and v′2(xi) = v2(xi). Therefore, we can conclude that T2, q2, v2 |= (LIVE(x)∧〈−〉Φ′). The other direction can be proven in a symmetric way.\nFor Φ = LIVE(x) ∧ [−]Φ′′: we observe that we can rewrite Φ as ¬(LIVE(x) ⊃ 〈−〉Φ′), with Φ′ = ¬Φ′′. Then, assume that T1, q1, v1 |= (LIVE(x) ⊃ 〈−〉Φ′). By definition, this implies that: (i) either for some xi ∈ xwe have v1(xi) 6∈ adom(I1(q1)); or (ii) for all xi ∈ x we have v1(xi) ∈ adom(I1(q1)) and there exists a transition q1 →1 q′1 such that T1, q′1, v1 |= Φ′. We distinguish the two cases:\n– If for some xi ∈ x, v1(xi) 6∈ adom(I1(q1)), then we have that v2(xi) 6∈ adom(I2(q2)). Indeed, assume toward contradiction that v2(xi) ∈ adom(I2(q2)). Since Ĩ1(q1) ∼h Ĩ2(q2) it follows that the inverse h−1 of h is unique, hence h−1(v2(xi)) = v1(xi) and v1(xi) ∈ adom(I1(q1)), getting a contradiction. Thus, we have that T2, q2, v2 6|= LIVE(x) and so T2, q2, v2 |= (LIVE(x) ⊃ 〈−〉Φ′). – If for all xi ∈ x, vi(xi) ∈ adom(I1(q1)), we can proceed in the same way as for the case of Φ = LIVE(x) ∧ 〈−〉Φ′.\nThe other direction is proven symmetrically.\nWe can now extend the result to the whole µŁp.\nLemma 2. Consider two transition systems T1 = 〈∆1, Q1, q10,→1, I1〉 and T2 = 〈∆2, Q2, q20,→2, I2〉, two states q1 ∈ Q1, q2 ∈ Q2, such that q1 ≈h q2, and two\nindividual variable valuations v1 and v2 mapping variables to∆1 and∆2, respectively. If there exists a bijection ĥ between adom(I1(q1))∪IM(v1) and adom(I(2q2))∪IM(v2) whose restriction ĥ|adom(I1(q1)) coincides with h and such that for each individual variable x, ĥ(v1(x)) = v2(x), then for every formula Φ of µŁp, closed on the predicate variables but possibly open on the individual variables, we have:\nT1, q1, v1 |= Φ if and only if T2, q2, v2 |= Φ.\nProof. We prove the theorem in two steps. First, we show that Lemma 1 can be extended to the infinitary version of ŁP that supports arbitrary infinite disjunction of formulas sharing the same free variables [11]. Then, we recall that fixpoints can be translated into this infinitary logic, thus guaranteeing invariance for the whole µŁp logic. Let Ψ be a possibly infinite set of open ŁP formulas. Given a transition system T = 〈∆,Q, q0,→ , I〉, the semantics of ∨ Ψ is ( ∨ Ψ)T(v,V ) = ⋃ ψ∈Ψ (ψ) T (v,V ). Therefore, given a state q of T and a variable valuation v, we have T, q, v |= Ψ if and only if T, q, v |= ψ for some ψ ∈ Ψ . Arbitrary infinite conjunction is obtained for free through negation. Lemma 1 extends to this arbitrary infinite disjunction. By the induction hypothesis, under the assumption of the Lemma, we can assume that for every formula ψ ∈ Ψ , we have T1, q10, v1 |= ψ if and only if T2, q20, v2 |= ψ. Given the semantics of ∨ Ψ above, this\nimplies that T1, q10, v1 |= ∨ Ψ if and only if T2, q20, v2 |= ∨ Ψ .\nIn order to extend the result to the whole µŁp, we translate µ-calculus approximates into the infinitary ŁP by (see [17,11]), where the approximant of index α is denoted by µαZ.Φ for least fixpoint formulas µZ.Φ and ναZ.Φ for greatest fixpoint formulas νZ.Φ. This is a standard result that holds also for µŁp. In particular, such approximates are as follows:\nµ0Z.Φ = false ν0Z.Φ = true µβ+1Z.Φ = Φ[Z/µβZ.Φ] νβ+1Z.Φ = Φ[Z/νβZ.Φ] µλZ.Φ = ∨ β<λ µ βZ.Φ νλZ.Φ = ∧ β<λ ν βZ.Φ\nwhere λ is a limit ordinal, and the notation Φ[Z/νβZ.Φ] denotes the formula obtained from Φ by replacing each occurrence of Z by νβZ.Φ. By Tarski and Knaster Theorem [84], the fixpoints and their approximates are connected by the following properties: given a transition system T and a state q of T ,\n– q ∈ (µZ.Φ)T(v,V ) if and only if there exists an ordinal α such that s ∈ (µ αZ.Φ)T(v,V )\nand, for every β < α, it holds that s 6∈ (µβZ.Φ)M(v,V ); – q 6∈ (νZ.Φ)T(v,V ) if and only if there exists an ordinal α such that s 6∈ (ν\nαZ.Φ)T(v,V ) and, for every β < α, it holds that q ∈ (νβZ.Φ)M(v,V ).\nSince each approximate, including the ones corresponding exactly to the least and greatest fixpoints, can be written as an infinitary ŁP formula, we get the thesis.\nWith this lemma in place we can prove the invariance result.\nTheorem 13. Consider two transition systems T1 = 〈∆1, Q1, q10,→1, I1〉 and T2 = 〈∆2, Q2, q20,→2, I2〉. If T1 ≈ T2, then, for every µŁp closed formula Φ\nT1 |= Φ if and only if T2 |= Φ.\nProof. If T1 ≈ T2 then for some bijection h we have q10 ≈h q20. This implies that Ĩ1(q10) ∼h Ĩ2(q20). Now consider the variable valuations v1 and v2 defined as follows (notice that since Φ is closed such individual valuations are irrelevant in evaluating it): choose an arbitrary d1 ∈ ∆1 and let, for all variables x, v1(x) = d1; if d1 ∈ adom(I1(q1)), let, for all x, v2(x) = h(d1); else, choose d2 6∈ adom(I2(q2)) and let, for all x, v′2(x) = d2.\nNow, define a bijection h′ such that for all d ∈ adom(I(q1)), h′(d) = h(d), and if d1 6∈ adom(I1(q1)), h′(d1) = d2. It can be seen that h′ is a bijection between adom(I1(q1) ∪ IM(v1) and adom(I2(q2) ∪ IM(v2) such that Ĩ1(q1) ∼h′|adom(I1(q1)) Ĩ2(q2) and for all variables x, h′(v1(x)) = v2(x). Hence, by Lemma 2, we get the thesis.\nThus, to check whether a transition system T satisfies a µŁp formula Φ, one can perform the check on any transition system T ′ that is bisimilar to T . This is particularly useful in those cases where T is infinite-state but admits some finite-state bisimilar transition system. We exploit this result later on."
    }, {
      "heading" : "6.4 Transition Systems Induced by a Situation Calculus Theory",
      "text" : "Among the various TSs, we are interested in those induced by models of the situation calculus action theoryD. Consider a modelM ofD with object domain∆ and situation domain S. The TS induced byM is the labelled TS TM = 〈∆,Q, q0, I,→〉, such that:\n– Q = S is the set of possible states, each corresponding to a distinct executable situation in S; – q0 = SM0 ∈ Q is the initial state, with SM0 the initial situation of D; – → ⊆ Q×Q is the transition relation such that q → q′ iff there exists some action a such that 〈a, q〉 ∈ PossM and q′ = doM(a, q). – I : Q 7→ IntF,C∆ is the labeling function associating each state (situation) q with the interpretation I(q) = IM(q).\nAs it can be seen, the TS induced by a modelM is essentially the tree of executable situations, with each situation labelled by an interpretation of fluents (and constants), corresponding to the interpretation associated byM to that situation. Notice that transitions do not carry any information about the corresponding triggering action.\nWe can now show that the semantics of µŁp on a model can alternatively be given in terms of the corresponding induced TS.\nTheorem 14. LetD be an action theory,M a model ofD with (infinite) object domain ∆ and situation domain S, and TM the corresponding induced TS. Then for every µŁp formula Φ (with no occurrence of action terms) we have that:\n(Φ)M(v,V ) = (Φ) TM (v,V )\nProof. By induction on the structure of Φ. For the base case of an open uniform situation-suppressed situation calculus formula ϕ, we need to prove that\n(ϕ)M(v,V ) = {s ∈ S | M, v |= ϕ[s]} = (ϕ) TM (v,V ) = {s ∈ S | I(s), v |= ϕ}.\nThis is indeed the case: since no action terms occur in ϕ and ϕ is uniform in s, the evaluation of ϕ depends only on the interpretation of each fluent (and constant) at s, i.e., on IM(s). Once this base case is settled, the inductive cases are straightforward."
    }, {
      "heading" : "6.5 Abstract Finite-State Transition System",
      "text" : "As shown above, satisfaction of µŁp formulas is preserved by persistence-preserving bisimulations. This holds even between an infinite- and a finite-state TS. When this is the case, the verification can be performed on the finite TS using standard µ-calculus model checking techniques, which essentially perform fixpoint computations on a finite state space. We next show how, for the case of bounded theories, one can construct a finite TS TF that is bisimilar to the TS TM induced byM.\nWe construct TF using Procedure 1. The procedure takes as input an action theory D (with complete information on the initial situation) bounded by b and a model M of D with infinite object domain ∆,12 and returns a finite-state TS TF bisimilar to TM. TF is built incrementally, through iterative refinements of the set of states Q, the interpretation function I, and the transition relation →. Initially, Q contains only the initial state q0 (line 2); I(q0) interprets constants and fluents in the same way asM at the initial situation (line 3); and→ is empty (line 4). The set Qte contains the states of TF to be “expanded” (initially q0 only, line 5); this is done at each iteration of the while loop (lines 6–20), as explained next.\nFirstly, a state q is extracted from Qte (lines 7 and 8). Then, a finite subset O of objects from ∆ is defined (line 9). The values from O, together with those from adom(I(q)), are used, in combination with the action types, to generate actions executable on the interpretation I(q)13 (lines 10,11). The particular choice ofO guarantees that the set of generated actions, while finite, is fully representative, for the purpose of verification, of all the (possibly infinitely many) actions executable on I(q) (see Theorem 16). Moreover, the objects are chosen so as to maximize reuse of the objects occurring in the interpretation of the states already in Q.\nThe actual expansion step consists in computing, for each generated action, the interpretation I ′ obtained by executing the action on (a situation with interpretation) I(q). This is done by computing, on I(q), the answers to the right-hand side φ(a,y) of the (situation-suppressed) successor state axiom of each fluent F , with a set to the current action (line 12). Once I ′ has been computed, two cases are possible: either it is isomorphic to some interpretation I(q′) labeling an existing state q′ ∈ Q (line 13), under some isomorphism that preserves I(q), or it is not (line 15). In the former case, the transition relation is simply updated with a transition from q to q′ (line 14) and no new state is generated. We stress that, in this case, the isomorphism is defined over the whole ∆, not only over the active domains of the interpretations. In the latter case, a\n12 In fact, given the object domain ∆, the model M is fully determined by D modulo object renaming. 13 Notice that since Poss(a, s) is uniform in s, the situation does not play any role in establishing whether, for given a and s, Poss(a, s) holds. In fact, only the interpretation of fluents (and constants) at s matters. Consequently, one can take such an interpretation and safely suppress the situation argument.\nProcedure 1 Computation of a finite-state TS persistence-preserving bisimilar to TM. Input: A basic action theory D bounded by b, with complete information on S0, and a model M of D with infinite object domain ∆ Output: A finite-state TS TF = 〈∆,Q, q0, I,→〉 persistence-preserving bisimilar to TM 1: let F the set of fluents of D, C the set of constants explicitly mentioned in D; 2: let Q := {q0}, for q0 a fresh state; 3: let I(q0) = IM(SM0 ); 4: let→ := ∅; 5: let Qte := {q0}; 6: while (Qte 6= ∅) do 7: pick q ∈ Qte; 8: let Qte := Qte − {q}; 9: let O ⊆ ∆ be any (finite) set of objects such that:\n(i) |O| = max{|x| | A(x) ∈ A}; (ii) O ∩ adom(I(q)) = ∅; (iii) |O ∩ ⋃ q∈Q adom(I(q))| is maximal (subject to (i) and (ii)).\n10: for all action types A(x) of D do 11: for all valuations v such that v(x) ∈ (adom(I(q)) ∪O)|x| and I(q), v |= Poss(A(x)) do 12: let I′ = 〈∆, ·I ′ 〉 be an interpretation such that: (i) cI = cM, for all constants in\nC; (ii) F I ′ = {d | I(q), v[y/d] |= φF (A(x),y)}, for φF (a,y) the (situation-\nsuppressed) RHS of the SSA of fluent F . 13: if (there exists q′ ∈ Q and an isomorphism h between I′ and I(q′) that is the identity on adom(I(q))) then 14: → :=→∪ {q → q′}; 15: else 16: let Q := Q ] {q′}, for q′ a fresh state;\nI(q′) := I′; → :=→∪ {q → q′}; Qte := Qte ] {q′};\n17: end if 18: end for 19: end for 20: end while 21: return TF = 〈∆,Q, q0, I,→〉\nfresh state q′ with labeling I(q′) is added to Q, and the transition relation is updated with q → q′ (lines 16). Further, q′ is also added to Qte, so as to be expanded in future iterations. The procedure iterates over the expansion step until the set Qte is empty, i.e., unitl there are no more states to expand.\nWe observe that the choice of q′ at line 14 guarantees the existence of an isomorphism h′ between I ′ and I(q′) that is the identity on adom(I(q)). That is, any object occurring in I ′ that comes from I(q) must be mapped into itself. The purpose of this choice is to avoid adding a fresh state q′′ (with interpretation I ′) toQ but reuse any state q′ already in Q, if bisimilar to the candidate q′′. This is a key step for the procedure to construct a transition system that is both finite and persistence-preserving bisimilar to TM.\nWe can now show that Procedure 1 terminates and returns a TS persistencepreserving bisimilar to TM. This result is split into two main results: Theorem 15, which shows that the procedure terminates, returning a finite TS, and Theorem 16, which shows that the obtained TS is indeed persistence-preserving bisimilar to TM.\nTo prove termination, we first derive a bound on the active domain of the interpretations labeling the states in Q.\nLemma 3. There exists a value b′ = ∑ F∈F b · aF + |C| such that, at any iteration of Procedure 1 and for any q ∈ Q, |adom(I(q))| ≤ b′, where b is the value bounding D, aF the arity of fluent F , and C the set of constants explicitly mentioned in D.\nProof. We first show that: (†) for every q ∈ Q, there exists a situation s executable in D such that I(q) = IM(s). This intuitively means that, modulo situation suppression, every state of TF is labelled by an interpretation that matches that ofM on constants and fluents at some executable situation s.\nThe proof is by induction on Q. For q0, the thesis follows by the definition of I(q0) at line 3, as SM0 is executable. For the induction step, consider q ∈ Q and assume, by the induction hypothesis, that I(q) is as above, for an executable situation s. Then, for any valuation (of object variables) v, we have that I(q), v |= Poss(A(x)) if and only if IM(s), v |= Poss(A(x)), that is, by Theorem 7, M, v′ |= Poss(A(x), σ), for σ a situation variable and v′ a situation calculus variable assignment analogous to v on all individual variables and such that v′(σ) = s. Thus, by line 11, A(x) is executable at s (with respect to M and v). Similarly, for any fluent F and valuation v, we have that I(q), v |= φF (A(x),y) iff M, v′ |= φF (A(x),y, σ), that is, since F (y, do(a, σ)) ≡ φF (a,y, σ) (by definition of successor-state axiom), I(q), v |= φF (A(x),y) iff M, v′ |= F (y, do(A(x), σ)). But then, since by line 12, F I ′ = {d ∈ ∆ | I(q), v[y/d] |= φF (A(x),y)}, it follows that I ′, v |= F (y) iff M, v′[y/d] |= F (y, do(A(x), σ)). Thus, F I′ = {d ∈ ∆ | M, v′[y/d] |= F (x, do(A(x), σ))}. Therefore, when a state q′ is added to Q (line 16), its labeling I(q′) = I ′ is such that I(q′) = IM(doM(AM(v(x)), s)). This proves (†).\nObserve that (†) and the boundedness of D imply, together, that |adom(I(q))| is bounded, for any q ∈ Q. We denote by b′ the bound on |adomM(s)|, for any executable situation s of D, and on |adom(I(q))|, for q ∈ Q. Notice that, in general, b′ is different than b, in that the former bounds the number of objects occurring in the interpretations, while the latter bounds the number of tuples in the interpretation of fluents. To obtain\nb′, observe that if the theory is bounded by b, then, for any model, the extension of each fluent F ∈ F at any executable situation contains at most b distinct tuples. Thus, the extension of the generic fluent F cannot contain, at any executable situation, more than aF · b distinct objects, where aF is the arity of F (the maximum number of tuples, each with distinct objects, distinct also from all others in the extension). As a result, the extensions cannot contain, overall, more than ∑ F∈F aF · b distinct objects. Hence, considering that I(q) interprets both the fluents in F and the constants in C, it follows that |adom(I(q))| ≤ ∑ F∈F aF · b+ |C| . = b′.\nThen, we use the obtained bound to show that also the set of all objects occurring in the labelings of some state in Q, denoted adom(Q), is bounded.\nLemma 4. Let adom(Q) = ⋃ q∈Q adom(I(q)). At any iteration of Procedure 1, we have that |adom(Q)| ≤ 2b′ + N , for b′ the bound on |adom(I(q))| defined as in Lemma 3, and N the maximum number of parameters of the action types in D.\nProof. By induction on the size of Q. For Q = {q0}, we have that adom(Q) = adom(I(q0)), thus the thesis follows as, by Lemma 3, |adom(I(q0))| < b′. For Q = {q0, . . . , qn}, assume, by induction hypothesis, that |adom(Q)| < 2b′+N . Since, by Lemma 3, the state q ∈ Qte ⊆ Q picked at line 7 is such that |adom(I(q))| ≤ b′ and ∆ is infinite, then, by Theorem 10 (after applying Theorem 5, if action terms have to be suppressed in φF ), I ′ (line 12) is such that adom(I ′) ⊆ adom(I(q)) ∪ v(x).14 Now, observe that v(x) may take values from O and that the constraints on the choice of O (line 9) require that the reuse of objects from adom(Q) be maximized. That is, including fresh objects (with respect to adom(Q)) in O is allowed (in fact, required) only if needed to guarantee that |O| = |x| (whileO∩adom(I(q)) = ∅). Thus, two cases are possible: either |adom(Q) \\ adom(I(q))| < |x| (in which case fresh objects must be added to O), or not. In the first case, because |x| ≤ N and adom(I(q)) ⊆ adom(Q), it follows that |adom(Q)| − |adom(I(q))| < N . Thus, since |adom(I(q))| ≤ b′, we have that |adom(Q)| < N + b′. From this, observing that |adom(I(q′))| ≤ b′, we obtain |adom(Q ∪ {q′})| ≤ 2b′ + N . In the second case, O contains no fresh objects, thus |adom(Q ∪ {q′})| = |adom(Q)| ≤ 2b′ +N .\nExploiting this result, we can prove termination.\nTheorem 15. Procedure 1 terminates and returns a finite-state transition system TF .\nProof. Firstly, observe that, as a consequence of Lemma 4: (i) checking whether I(q), v |= Poss(A(x)) (line 11) is decidable, and (ii) F I′ (line 12) is computable. These, indeed, are implied by the fact that |adom(I(q))| is bounded, thus finite, and by Theorems 9 and 11, respectively. To apply these theorems, however, one needs to suppress action terms first, if present, in formulas φF (A(x),y) and φA(x). To this end, Theorem 5 can be used. Notice also that computability of F I(q0) (line 3) is a direct consequence of the fact that D has complete information and is bounded, therefore the extension of all fluents at S0 is finite. Items (i) and (ii) above guarantee that all the atomic steps of Procedure 1 can be completed in finite time.\n14 To simplify the notation, we use v(x) for the set {v(x1), . . . , v(xn)}.\nNext, we prove that eventually Qte = ∅. Observe that, since A (i.e., the set of action types of D), Q, O, adomM(S0), and adom(I(q)) are finite, it follows that, at every iteration of the while-loop (lines 6–20), the nested loops (lines 10–19) terminate; thus, proving that Qte becomes empty in a finite number of steps is sufficient to prove that only a finite number of iterations are executed and, hence, the procedure terminates. Obviously, this also implies that the returned Q, thus TF , is finite.\nTo see that eventuallyQte = ∅, notice thatQ is inflationary, i.e., states, once added, are never removed. Consequently, objects can be added to adom(Q) (when a fresh q′ is added) but not removed. This, together with the fact that, by Lemma 4, |adom(Q)| is bounded, implies that, from some iteration i on, adom(Q) remains unchanged. Let AQi be adom(Q) at iteration i (and at subsequent steps). Obviously, after that point, if a fresh state q′ is added, it must be such that adom(I(q′)) ⊆ AQi. Notice that, even though adom(Q) cannot change, this is not the case for Q. Indeed, new states q′ could still be added, as long as I(q′) = I ′ contains only objects from AQi. However, since |adom(Q)|, thus |AQi|, is bounded, only finitely many interpretations I ′ can be built using values from AQi. Consequently, if new states keep being introduced after i, it follows that, from some step i′ on, the interpretation I ′ generated at line 12 matches the interpretation I(q′) of some q′ already in Q. Hence, from i′ on, the condition at line 13 is always satisfied (with h the identity function), and no fresh state q′ can be added toQ any more. Therefore, no new state is added to Qte (line 16), which becomes eventually empty, as at every iteration one state is extracted from it (line 7). This completes the proof.\nFinally, we show that the returned TF retains all the information needed to check whetherM |= Φ. That is, by Theorem 13, we show that TF is persistence-preserving bisimilar to TM.\nTheorem 16. The TS TF computed by Procedure 1, on a basic action theory D (with complete information) bounded by b and a modelM for D, is persistence-preserving bisimilar to the TS TM induced byM.\nProof. Let TF = 〈∆,Q, q0, IF ,→F 〉 and TM = 〈∆,R, r0, IM,→M〉, and define the relation B ⊆ Q ×H × R such that 〈q, h, r〉 ∈ B if and only if ĨF (q) ∼h ĨM(r) (for any h). Notice that, since TF and TM have the same object domain ∆, h can always be extended to a standard isomorphism ĥ between IF (q) and IM(r): namely, one can take any bijection ĥ : ∆ 7→ ∆ such that ĥ|adom(IF (q)) = h.\nWe show that B is a persistence-preserving bisimulation between TF and TM. (page 24). Consider a tuple 〈q, h, r〉 ∈ B. Requirement 1 of the definition is trivially satisfied by the definition of B. As to requirement 2, let q′ ∈ Q be such that q →F q′. As shown in the proof of Theorem 15, there exists an executable situation s such that IF (q) = IM(s). Moreover, by the definition of TM, r is a situation such that IM(r) matches the interpretation given byM to fluents at r. Because q →F q′, by the construction of TF in Procedure 1 (line 11), we have that, for some valuation v and action type A, IF (q), v |= Poss(A(x)), that is, by the existence of s as above, M, v |= Poss(A(x), s). Then, by extending h to an isomorphism ĥ between IF (q) and IM(r), as discussed above, we can see that IM(r), v′ |= Poss(A(x), r), for v′ = ĥ◦v, which implies that M, v′ |= Poss(A(x), r). Therefore, by the definition of TM, for\nr′ = doM(AM(ĥ(v(x)), r) ∈ R, we have that r →M r′. Thus requirement 2a is fulfilled.\nNext, we show the existence of an isomorphism ĥ′ between IF (q′) and IM(r′) that extends h. Once proven, this implies the existence of a bijection h′ : adom(q) ∪ adom(q′) 7→ adom(r) ∪ adom(r′) such that h′|adom(IF (q)) = h and ĨF (q′) ∼h′|adom(IF (q′)) ĨM(r ′). Indeed, it is sufficient to take h′ = ĥ′|adom(q)∪adom(q′). Thus, the existence of ĥ′ implies requirement 2b. To prove that such an ĥ′ exists, we distinguish two cases: (i) when the transition q →F q′ is added at line 16 (i.e., q′ is a fresh state), and (ii) when it is added at line 14 (i.e., q′ is already in Q). For case (i), observe that IM(r′) can be obtained by applying the right-hand side of the successor-state axiom of each fluent F to IM(r) (see Theorem 12), which is also the way to obtain IF (q′) from IF (q), according to Procedure 1. Then, since ĥ is an isomorphism between IF (q) and IM(r), we have that IM(r) = ĥ(IF (q)), where ĥ(IF (q)) denotes the interpretation obtained from IF (q) by renaming its objects according to ĥ. Because v′ = ĥ ◦ v, it can be checked that IM(r′) = ĥ(IF (q′)), thus ĥ′ = ĥ is an isomorphism between IF (q′) and IM(r′), which obviously extends h. For case (ii), let I ′ be the interpretation obtained by applying the successor-state axioms to IF (q). By the discussion above, we have that IM(r′) = ĥ(I ′), while, in general, I ′ 6= IF (q′). However, the condition at line 13 guarantees the existence of an isomorphism g such that I ′ = g(IF (q′)), that is the identity on adom(IF (q)). Now, consider ĥ′ = ĥ ◦ g. Being a composition of isomorphisms, ĥ′ is an isomorphism itself, in particular such that IM(r′) = ĥ′(IF (q′)). Moreover, ĥ′ extends h|adom(IF (q)). This is a straightforward consequence of the facts that ĥ extends h and g is the identity on adom(IF (q)), which imply that ĥ′ matches h on adom(IF (q)). Thus, requirement 2 is fulfilled. The proof for requirement 3 follows the same argument, with h replaced by its inverse h−1.\nSince B is a persistence-preserving bisimulation, the fact that 〈q0, h0, r0〉 ∈ B, for h0 the identity, completes the proof.\nNext we prove that checking whether TF satisfies a µŁp formula, is decidable.\nTheorem 17. Given a transition system T = 〈∆,Q, q0, I,→〉, if Q is finite and, for every q ∈ Q, adom(I(q)) is finite, then for every µŁp formula Φ, checking whether T |= Φ is decidable.\nProof. Firstly, by applying Theorem 6 followed by Theorem 8 to the FO components of Φ, we rewrite Φ as an equivalent µŁp (closed) formula Φ′ where no action terms occur and whose FO components are domain-independent. Once done so, the theorem is a consequence of the finiteness of Q and adom(q), for q ∈ Q. Under these assumptions, (Φ′)T(v,V ) is easily computable by recursive applications of the definition of (·)T(v,V ) (page 23). In particular, for the base case of Φ\n′ a FO formula ϕ′, since ϕ′ is action-term-free and domain-independent, one can apply Theorem 9. As to quantified variables (outside the FO components), they can be easily dealt with, by the finiteness of adom(q). The other cases are straightforward.\nFinally, putting all the above results together, we obtain Theorem 4, by observing that one can compute TF using Procedure 1 and then check whether TF |= Φ by Theorem 17. Termination and correctness of this construction are guaranteed by Theorems 13, 15, and 16.15"
    }, {
      "heading" : "7 Dealing with Incomplete Information",
      "text" : "In this section, we address the case of partial information on the initial situation, by assuming that D0 is a set of axioms characterizing a possibly infinite set of bounded initial databases. Also in this case, we focus on theories whose models have infinite object domains (as we have infinitely many distinct constants).\nWe first prove that whenever two models interpret their respective initial situations in isomorphic ways, they are persistence-preserving bisimilar. We observe that this result holds independently of the cardinalities of the object domains of the models.\nTheorem 18. Let D be a bounded basic action theory. For every two modelsM and M′ of D, with possibly different infinite object domains ∆ and ∆′, respectively, if ĨM(SM0 ) ∼ ĨM′(SM ′ 0 ), then TM ≈ TM′ .\nProof. Let TM = 〈∆,Q, q0,→, I〉 and TM′ = 〈∆′, Q′, q′0,→′, I ′〉. We prove a stronger claim, i.e., that the relation B ⊆ Q × H × Q′ such that 〈q1, h, q2〉 ∈ B if and only if Ĩ(q1) ∼h Ĩ ′(q2) (for any h), is a persistence-preserving bisimulation relation between TM and TM′ . This result, once proven, implies the thesis; indeed, by ĨM(SM0 ) ∼ ĨM′(SM ′ 0 ), we have that there exists h̄ such that Ĩ(SM0 ) ∼h̄ Ĩ(SM ′\n0 ), thus, by the definition of B, 〈SM0 , h̄, SM ′\n0 〉 ∈ B, that is, 〈q0, h̄, q′0〉 ∈ B, as q0 = SM0 and q′0 = S M′ 0 .\nLet 〈q1, h, q2〉 ∈ B. Requirement 1 of the definition of bisimulation (page 24) is clearly satisfied. For requirement 2, first recall that, by definition of induced transition system (page 28), I(q1) = IM(q1) and I ′(q2) = IM′(q2), thus ĨM(q1) ∼h ĨM′(q2). Assume that there exists q′1 ∈ Q such that q1 → q′1. By definition of transition system induced by M (page 28), there exist an action type A and a valuation v such thatM, v |= φA(x, q1), for Poss(A(x), s) ≡ φA(x, s) the precondition axiom of A. This is equivalent to IM(q1), v |= φA(x), for φA(x) the situation-suppressed version of φA(x, s). Now, let φ′A(x) be the domain-independent version of φA(x). By Theorem 8, we have that IM(q1), v |= φA(x) if and only if ĨM(q1), v |= φ′A(x). If we extend h to v(x) in a way such that we obtain a bijection ĥ (by a cardinality argument, this is always possible), then, because ĨM(q1) ∼h ĨM′(q2), we have that ĨM(q1), v |= φ′A(x) if and only if ĨM′(q2), ĥ ◦ v |= φ′A(x). But then, again by Theorem 8, IM′(q2), ĥ ◦ v |= φA(x). Thus, by reintroducing the situation argument in φA, we have thatM′, v′ |= φA(x, q2), that is, there exists an action a′ = AM ′ (ĥ(v(x)))\n15 Notice that no assumption is made on the object domain ∆ ofM except for it to be infinite. Hence, these results hold also if we assume standard names for object domains, as done in [27]: in that case the object domain is infinite but numerable and coincides with the set of constantsN (this requires a second-order domain closure axiom).\nsuch that 〈a′, q2〉 ∈ PossM ′ . Therefore, by the definition of TM′ , it follows that q2 → q′2, for q′2 = doM(a′, q2). This proves requirement 2a. For requirement 2b, we first show that ĨM(q′1) can be obtained from ĨM(q1), through the successor-state axioms. To this end, notice that IM(q′1) can be obtained by taking, for each fluent F , the right-hand side φ(x, a, s) of the corresponding successorstate axiom (the subscript F is removed to simplify the notation), then deriving the equivalent action-term-free formula φ(y,x), as shown in Theorem 12, for action a = AM(v(x)), and finally letting F IM(q ′ 1) = φ\nIM(q1) x/v(x) , that is, by interpreting each\nF as the answer to the corresponding query φ on the interpretation IM(q1), under the partial assignment x/v(x) (constants are always interpreted as in M). Now observe that, since the action theory is bounded, so is the extension of each fluent F at q1 and q′1. Thus, by Theorem 10, the extension of each fluent at q ′ 1 contains only values from adom(IM(q1)) ∪ v(x), that is adom(IM(q′1)) ⊆ adom(IM(q1)) ∪ v(x). Hence, if we denote (for each F ) the domain-independent rewriting of φ(y,x) as φ′(y,x), by Theorem 8, we have that F IM(q ′ 1) = φ\nIM(q1) x/v(x) = φ ′ĨM(q1) x/v(x) , that is, by answering φ ′ on\nĨM(q1), we obtain the extension of F at q′1. Obviously, by doing so for every fluent F , we can obtain ĨM(q′1) from ĨM(q1). By an analogous argument, it can be shown that ĨM′(q′2) can be obtained from ĨM′(q2), for action a′ = AM ′ (ĥ(v(x))).\nNext, consider again the bijection ĥ defined above, and recall that ĥ extends h on v(x), and that ĨM(q1) ∼h ĨM′(q2). By the invariance of FO under isomorphic interpretations, we have that, for each fluent F , the answers to φ′ on ĨM(q1) and ĨM′(q2), under the partial assignments, respectively, x/v(x) and x/ĥ(v(x)), coincide, modulo the object renaming induced by ĥ. But then, it is immediate to check that h′ = ĥ|adom(IM(q1))∪adom(IM(q′1)) is a bijection such that ĨM(q ′ 1) ∼h′|adom(IM(q′1)) ĨM′(q′2) and, hence, by the definition of B, 〈q′1, h′|adom(IM(q′1)), q ′ 2〉 ∈ B. This proves requirement 2b. The proof of requirement 3b is analogous.\nNow, consider a set Mod of models ofD having isomorphic interpretations at S0. By Theorem 18, all such models have induced TSs that are persistence-preserving bisimilar to each other. Thus, by Theorem 13, to check whether a µŁp formula φ holds in all models of Mod , one can perform the check on any arbitrary model of Mod , using, e.g., the technique discussed for the case of complete information. This result, together with the assumption of boundedness, will be exploited next, to prove our main theorem.\nTheorem 19. Let D be an action theory bounded by b with incomplete information on the initial situation, and let Φ be a µŁp closed formula. Then, checking whether D |= Φ is decidable.\nProof. Let ModD be the set of all models of D, and consider a partition of it such that each cell contains only models whose interpretations at S0 match, modulo object renaming. Formally, we define ModD = (Mod1D,Mod 2 D, . . .) such that, for every two modelsM andM′ in Mod iD, ĨM(SM0 ) ∼ ĨM′(SM ′\n0 ). As a consequence of the boundedness of D, the number of cells in the partition is finite. Indeed, a bounded number of objects yields, up to object renaming, only a bounded number of possible interpretations (of finitely many fluents and constants) at S0. Thus, for some finite n depending on the theory D and the bound b, we have that ModD = (Mod1D,Mod 2 D, . . . ,Mod n D).\nSince, by Theorem 18, any two modelsM andM′ of the generic cell Mod iD induce persistence-preserving bisimilar transition systems, then, by Theorem 13, we have that all the models of Mod iD satisfy Φ if and only if some modelM of Mod i D satisfies Φ. Thus, to check whether D |= Φ, we can simply choose one modelMi per cell Mod iD, and then check whether, for all i = 1, . . . , n, Mi |= Φ; if this is the case, then, and only then, we can conclude that D |= Φ. Obviously, for this approach to be effective, we need a modelMi per cell Mod iD and a way to perform the check. The rest of the proof addresses these two points.\nLet F be the set of situation-suppressed fluents of D, and C the (finite) set of constant symbols explicitly mentioned in D (beyond Duno). We observe that each cell Mod iD of the partition ModD = (Mod 1 D, . . . ,Mod n D) can be uniquely identified by an interpretation Ii of F and C over some infinite object domain∆. Indeed, by transitivity of ∼, any two modelsM,M′ of D such that ĨM(SM0 ) ∼ Ii and Ĩ ′M(SM ′\n0 ) ∼ Ii are also such that ĨM(SM0 ) ∼ Ĩ ′M(SM ′\n0 ). Notice that Ii certainly exists, as one can simply take ĨM(SM0 ), for some modelM∈ Mod i D. Clearly, each Ii contains only a bounded number of objects in the active domain and satisfies D0, i.e., Ii |= D0.\nNow, assume given one interpretation Ii per cell Mod iD (we show below how to obtain them) and observe that, from Ii, we can extract a complete initial situation description as a database Di0. This can be easily done, as Ii is finite. Consider the theory Di = (D \\ D0) ∪ Di0, obtained by replacing D0 with Di0, and assume the same interpretation of constants in C as that defined by Ii. Under this assumption, Di defines a family of models that differ only in the object domain and in the interpretation of constants outsideC (which, however, must satisfyDuno). In particular, the interpretation of fluents inF and constants inC, at S0, of all such models, is the same as that of Ii. Thus, the models of Di constitute a subset of Mod iD. To isolate one of such models, we fix an arbitrary infinite object domain∆ (such that adom(Ii) ⊆ ∆), and arbitrarily extend the partial interpretation of constants over the constants outside C, satisfying Duno. Notice that this can always be done, as ∆ is infinite and the set of constant symbols countable. With ∆ and the denotation of all constants fixed, Di has complete information, i.e., yields a single modelMi, thus, by Theorem 4, we can check whether Di |= Φ , i.e., whetherMi |= Φ (notice that, as it turns out from Procedure 1, to perform the check, one does not even need to know the interpretation of constants outside C). This, by the discussion above, is equivalent to checking whether for all modelsM∈ Mod iD, it is the case thatM |= Φ. Therefore, if the set of interpretations Γ = {I1, . . . , In} is given, we can check whether D |= Φ.\nIt remains to explain how such a set of interpretations Γ = {I1, . . . , In} can be obtained. To this end, observe that, by Lemma 3, it follows that |adom(Ii)| ≤∑ F∈F aF · b + |C| . = b′. Based on this, the set Υ of interpretations Ii can be obtained by: (i) fixing a set O of b′ arbitrary objects; (ii) generating a set Υ ′ of all the finitely many interpretations of F and C over O, such that Duno is enforced on C and for every interpretation I ′ ∈ Υ ′, I ′ |= D0; (iii) for any set Υ ′′ ⊆ Υ ′ of isomorphic interpretations, removing from Υ ′ all but one of such interpretations (in fact, this step is not needed to our purposes, but avoids useless redundancies). The resulting Υ ′ is the set of desired interpretations I1, . . . , In, which we rename simply as Υ .\nNow, observe that, by the way it is defined, Υ contains, up to object renaming, all possible interpretations of F and C over a set of b′ distinct objects, that satisfy D0 and Duno (on C). Thus, since for a generic model M of D, the interpretation ĨM(SM0 ) contains at most b′ distinct objects (by the boundedness of D), it turns out that there exists an interpretation Ii ∈ Υ such that ĨM(SM0 ) ∼ Ii. Therefore, the cell Mod i D such that M ∈ Mod iD, is characterized by some interpretation Ii ∈ Υ , namely the interpretation at S0 shared, up to object renaming, by the models of the cell itself. On the other hand, because any Ii ∈ Υ enforces Duno and is such that I |= D0, it follows that there exists some model M of D such that ĨM(SM0 ) ∼ Ii. Therefore, every interpretation of Υ characterizes some cell Mod iD, specifically, that of the models M such that ĨM(SM0 ) ∼ Ii. Therefore, Υ is indeed the set of desired intepretations. This concludes the proof.\nThis result, besides stating decidability of the verification problem under incomplete information, provides us with an actual procedure to perform verification in this case."
    }, {
      "heading" : "8 Computational Complexity",
      "text" : "In this section, we asses the computational complexity of verifying µŁp formulas over a bounded situation calculus basic action theory D. In particular we show that the constructive techniques we have used for proving decidability are, in fact, optimal with respect to worst case computational complexity. We make the assumption that, for a basic action theory D, the maximum number of distinct objects occurring in the state of any situation, dominates the input size of D itself, and that there exists a bound āF on the maximum arity of fluents. This is a reasonable assumption, analogous to that, typical in databases, that the size of the database provides a higher bound on the size of the input along all dimensions, and that, in practical cases, there exists an upper bounds on the arity of relations. We exploit the constructive techniques introduced for showing decidability to get an exponential time upper-bound.\nTheorem 20. Verifying µŁp formulas over a situation calculus basic action theory bounded by b, with complete information on the initial situation, can be done in time exponential in b.\nProof. This is a consequence of Procedure 1 and the complexity of µŁp model checking. Firstly, consider Procedure 1 and observe that, by Lemma 4, at any iteration, the number m of distinct objects occurring, overall, in the interpretations of states (i.e. |adom(Q)| of Lemma 4) is bounded by 2b′ + N , where b′ = ∑ F∈F b · aF , aF is the arity of fluent F , and N is the maximum number of parameters in action types. Since we assume |F | and N bounded by b, and aF bounded by a constant, it turns out that m is polynomial in b. Now, observe that, with m distinct objects and aF bounded by a constant, one can obtain a number of interpretations of F and C that is at most exponential in m, i.e., in (a polynomial of) b. Then, because in Procedure 1 every state is associated with exactly one interpretation, and since no state is visited more than once, we have that the while-loop (lines 6–20) terminates after, at most, an exponential number of iterations.\nAs to each iteration, by our assumptions, we have that any loop inside the whileloop ends after at most exponentially many iterations. Indeed, for any action type with at most N parameters, we have at most mN possible assignments, thus mN ≤ mb′ , which gives an exponential bound, as both m and b′ are polynomial with respect to b. Now, observe that the dominant operation in the while-loop is checking whether two interpretations are isomorphic. Since also this check can be performed in exponential time with respect to b (the problem is in NP), we obtain, overall, an exponential timebound for Procedure 1.\nNow, recall that propositional µ-calculus model checking is polynomial with respect to the sizes of the input transition system and the input formula [40]. As to the transition system, the check is performed on the one returned by Procedure 1, which has size at most exponential in b (i.e., as many interpretations as one can obtain with at most m objects, plus a quadratic number of transitions wrt it). As to the formula, say Φ, we first rewrite it (in polynomial time) into its equivalent domain-independent version Φ′, and then “propositionalize” it, by quantifier elimination, using only the values that occur, overall, in the active domains of the interpretations of the states of the input transition system. This step can be done, again, in exponential time, and returns a quantifier-free formula exponentially larger than the original one, but equivalent to it, on the obtained finite transition system. Thus, since µ-calculus model checking is polynomial wrt the size of both the transition system and the formula, we obtain that, overall, the check requires time at most exponential wrt b.\nSuch an exponential bound is, in fact, tight, as we can show the EXPTIME-hardness of the problem by reduction from acceptance in a polynomial-space bounded alternating Turing machine.\nTheorem 21. Verifying µŁp formulas over bounded situation calculus basic action theories with complete information on the initial situation is EXPTIME-hard.\nProof. We show a reduction from polynomial-space bounded alternating Turing machines, whose acceptance problem is EXPTIME-complete [19]. An (one-tape) Alternating Turing Machine (ATM) [19] is a tuple M = (Q,Γ, δ, q0, g) where\n– Q is the finite set of states; – Γ is the finite tape alphabet; – δ : Q × Γ × Q × Γ × {L,R} is called the transition table (L shifts the head left\nand R shifts the head right); – q0 ∈ Q is the initial state; – g : Q→ {and, or, accept} specifies the type of each state.\nIf M is in a state q ∈ Q with g(q) = accept then that configuration is said to be accepting. A configuration with g(q) = and is said to be accepting if all configurations reachable in one step are accepting. A configuration with g(q) = or is said to be accepting when there exists some configuration reachable in one step which is accepting. (The latter is the type of all states in a Nondeterministic Turing Machine.) M is said to accept an input string w if the initial configuration of M (where the state of M is q0, the head is at the left end of the tape, and the tape contains w) is accepting. An ATM is\nsaid to be polynomial-space-bounded if it scans at most a number of tape cells that is polynomially-bounded by the size of the input.\nFollowing [73] (Chap. 4), we can axiomatize the ATM using the following fluents:\n– transTable(q, c, q′, c′,m, s). This is a situation-independent predicate (i.e., with a trivial successor-state-axioms preserving its content forever) describing the ATM’s transition table δ: when in state q scanning tape symbol c, the machine enters state q′, overwrites c with tape symbol c′, and moves its tape head in the direction m, which is one of L (left) or R (right). – gType(q, t, s). This is a situation-independent predicate assigning (once and for all) a type t ∈ {and, or, accept} to the state q of the ATM. – cell(i, c, s). This means that tape cell i ∈ [0, . . . , `] contains the symbol c ∈ Γ ∪ {blank} in situation s. Notice that in every situation the number of facts of the form cell(i, γ, s) is fixed and determined by the maximal length of the tape of the bounded ATM, `. Initially, the first cells contains the input word w while the others are blank. – state(q, s). This means that in situation s, the machine’s state is q. Initially, we have state(q0, S0), where q0 is the initial state of the ATM. – scan(i, s). This means that the machine’s head is scanning tape cell i ∈ [0, . . . , `] in situation s. Initially, the head is scanning tape cell 0. In any situation, there will only be one fact of the form scan(i, s).\nWe need just one action type trans(q′, c′,m), meaning that the machine makes a transition from the current configuration to a new configuration where the state is q′, tape symbol c′ is written, and the tape head moves in directionm, whose precondition axiom is as follows:\nPoss(trans(q′, c′,m), s) ≡ ∃q, i, c. state(q, s) ∧ scan(i, s) ∧ cell(i, c, s) ∧ transTable(q, c, q′, c′,m, s)\nThe successor state axioms for the fluents that can change are as follows:\nstate(q, do(a, s) ≡ ∃c,m.a = trans(q, c,m) ∨ state(q, s) ∧ ¬∃q′, c,m.a = trans(q′, c,m) ∧ q′ 6= q\nscan(i, do(a, s) ≡ ∃q, c, i′.a = trans(q, c, L) ∧ scan(i′, s) ∧\n(i′ = 0 ⊃ i = i′) ∧ (i′ 6= 0 ⊃ i = i′ − 1) ∨ ∃q, c.a = trans(q, c, R) ∧ scan(i′, s) ∧ i = i′ + 1 ∨ scan(i, s) ∧ ¬∃q, c,m.a = trans(q, c,m)\ncell(i, c, do(a, s) ≡ ∃q,m.a = trans(q, c,m) ∧ scan(i, s) ∨ cell(i, c, s) ∧ ¬∃q, c′,m.a = trans(q, c′,m) ∧ scan(i, s) ∧ c′ 6= c\nFor initial situation description, assuming the input w = c0 . . . ci, we have:\nstate(q0, S0), scan(0, S0), cell(0, c0, S0), . . . , cell(i, ci, S0), cell(j, blank, S0), for j ∈ [i, . . . , `]\nAcceptance of the ATM is defined using the following µŁp formula Φ:\nµZ. (∃q.state(q) ∧ gType(q, accept) ∨ (∃q.state(q) ∧ gType(q, and)) ∧ [−]Z ∨ (∃q.state(q) ∧ gType(q, or)) ∧ 〈−〉Z\nThen we have that D |= Φ if and only if M accepts w. Notice that in any situation there is exactly one fact of the form gType(q, t, s). Notice also that the above condition does not require quantification across situations."
    }, {
      "heading" : "9 Checking Boundedness",
      "text" : "We now show that we can always check whether any BAT maintains boundedness for a given bound. That is, if the initial situation description is bounded, then the entire theory is too (for all executable situations).\nFirst notice that we can determine in a situation s whether every executable action a if performed next does not exceed the bound (i.e. in do(a, s)). We can capture the notion of a fluent F being bounded at the next step by the formula:∧\nA∈A ∀x.Poss(A(x), s) ⊃ BoundedF,b(do(A(x), s)).\nNotice that eachBoundedF,b(do(A(x), s)) is regressable throughA(x). As a result the formula above is equivalent to a first-order situation calculus formula uniform in s; we call the latter formula NextOrigBoundedF,b(s), and we call NextOrigBoundedb(s) the formula ∧ F∈F NextOrigBoundedF,b(s).\nTo check that the theory is bounded by b it is sufficient to verify that the theory entails the temporal formula:\nAGNextOrigBoundedb . = νZ.NextOrigBoundedb ∧ [−]Z,\nwhich expresses that always along any path NextOrigBoundedb holds. Unfortunately deciding whether this formula is entailed by the action theory is directly doable with the techniques in previous sections only if the theory is bounded, which is what we want to check. However it turns out that we can construct a modified version of the action theory that is guaranteed to be bounded and that we can use to do the checking.\nLet D be the action theory. We define a new action theory DD obtained by augmenting D as follows:\n– DDS0 = DS0 ∪ {φ[F /F ′]|φ ∈ DS0} – DDSS = DSS ∪ {F ′(x, do(a, s)) ≡ Φ(x, a, s) ∧NextOrigBoundedb(s) | F (x, do(a, s)) ≡ Φ(x, a, s) ∈ DSS} – DDap = {Poss(A(x), s) ≡ Ψ(x, a, s) ∧NextOrigBoundedb(s) |\nPoss(A(x), s) ≡ Ψ(x, a, s) ∈ DAP }\nIntuitively DD extends D with primed copies of fluents, which are axiomatized to act, in any situation, as the original ones as long as the original theory remains bounded by b in that situation, otherwise they become empty (and actions cannot be executed according to Poss.) It is easy to show the following key property for DD.\nLemma 5.\nDD |= ∀s.(∀ŝ.ŝ < s ⊃ NextOrigBoundedb(ŝ)) ⊃ ∀x.(F ′(x, s) ≡ F (x, s)).\nProof. By induction on situations.\nNow we define a new action theory D′ which can be considered a sort of projection of DD over the primed fluents only. Let D′ be:\n– D′S0 = {φ[F /F ′]|φ ∈ DS0}. – D′SS = {F ′(x, do(a, s)) ≡ Φ[F /F ′](x, a, s) ∧NextOrigBoundedb[F/F ′](s) | F (x, do(a, s)) ≡ Φ(x, a, s) ∈ DSS} – D′ap = {Poss(A(x), s) ≡ Ψ [F /F ′](x, a, s) ∧NextOrigBoundedb[F/F ′](s) | Poss(A(x), s) ≡ Ψ(x, a, s) ∈ DAP }\nNotice that D′ is bounded by construction if D′S0 is, and furthermore it preserves the information about the original theory being bounded at the next step, though in terms of primed fluents. Exploiting the above lemma on DD and the construction of D′, we can show that D′ has the following notable property:\nLemma 6.\nD |= AGNextOrigBoundedb(S0) iff D′ |= AGNextOrigBoundedb[F /F ′](S0).16\nProof. By Lemma 5, it is immediate to see that D |= AGNextOrigBoundedb(S0) implies D′ |= AGNextOrigBoundedb[F /F ′](S0). For the opposite direction, suppose that D′ |= AGNextOrigBoundedb[F /F ′](S0), but D |= AGNextOrigBoundedb(S0) does not hold. This means that there exists a model of D and a situation S where ¬NextOrigBoundedb(S) holds, though in all previous situations s < S we have that NextOrigBoundedb(s) holds. Now by Lemma 5, we can construct a model forD′ such that the truth values of F are replicated in F ′ as long as NextOrigBoundedb holds in the previous situation. So in S, we must have ¬NextOrigBoundedb[F /F ′](S), which contradicts the assumption that D′ |= AGNextOrigBoundedb[F /F ′](S0).\nBy Lemma 6, since D′ is bounded by b if D′S0 is, it follows that:\nTheorem 22. Given a BAT whose initial situation description is bounded by b, then checking whether the entire theory is bounded by b is decidable.\nNotice that we pose no restriction on the initial situation description except that it is representable in first-order logic, hence checking its boundedness remains undecidable:\nTheorem 23. Given a FO description of the initial situation D0 and a bound b, it is undecidable to check whether all models of D0 are bounded by b. 16 Notice that NextOrigBoundedb[F /F\n′] expresses that in the original theory the next situations are bounded, though now syntactically replacing original fluents with their primed version.\nProof. By reduction to FO unsatisfiability. Suppose we have an algorithm to check whether a FO theory D0 is bounded by 0. Then we would have an algorithm to check (un)-satisfiability of D0. Indeed consider for a fixed fluent F̂ :\nD̂0 = (D0 ∧ ∃x.F̂ (x, S0)) ∨ ( ∧ F∈F ∀x.¬F (x, S0))\nNote that ∧ F∈F ∀x.¬F (x, S0) has only models bounded by 0, while ∃x.F̂ (x, S0) has only models with at least one tuple (and thus one object) in F̂ . Hence we get that D̂0 is bounded by 0 iff D0 is unsatisfiable. A similar argument holds for every bound b.\nNonetheless in many cases we know by construction that the initial situation is bounded. In such cases the proof technique of Theorem 22 provides an effective way to check if the entire theory is bounded."
    }, {
      "heading" : "10 Related Work",
      "text" : "Besides the situation calculus [64,73], many other formalisms for reasoning about actions have been developed in AI, including the event calculus [55,79,80], the features and fluents framework [76], action languages such as A [44] and C+ [47], the fluent calculus [86], and many others. In most of these, the focus is on addressing problems in the representation of action and change, such as the frame problem. Some attention has also been paid to specifying and verifying general temporal properties, especially in the context of planning. The Planning Domain Definition Language (PDDL) [65] has been developed for specifying planning domains and problems, and a recent version supports the expression of temporal constraints on the plan trajectory [46]. Approaches such as those in TLPlan [3], in TALplanner [56], or in planning via model checking [67] support planning with such temporal constraints. Within the situation calculus, temporal constraints for planning have been studied in, e.g., [12,7]. All these planningrelated approaches are essentially propositional and give rise to transition systems that are finite-state. One interesting attempt to interpret first-order linear temporal logic simultaneously as a declarative specification language and procedural execution language is that of MetateM [8], though verification is not addressed.\nMost work on verification has been done in computer science, generally focusing on finite-state systems and programs. Many logics have been developed to specify temporal properties of such systems and programs, including linear-time logics, such as Linear Temporal Logic (LTL) [68] and Property-Specification Language (PSL) [39], and branching time logics such as Computation Tree Logic (CTL) [21] and CTL∗ [41], the µ-calculus [40,17], which subsumes the previous two, as well as Propositional Dynamic Logic (PDL) [42], which incorporates programs in the language. Model checking (and satisfiability) in these propositional modal logics is decidable [6], but they can only represent finite domains and finite state systems. Practical verification systems, e.g., [52,20], have been developed for many such logics, based on model checking techniques [6].\nIn AI, verification by model checking has become increasingly popular in the autonomous agents and multi-agent systems area. There, many logics have been proposed that additionally deal with the informational and motivational attitudes of agents\n[70,71,61,88,24,81]. Some recent work has been specifically concerned with formalizing multi-agent knowledge/belief and their dynamics [37,51]. Moreover, various BeliefDesire-Intention (BDI) agent programming languages have been developed that operationalize these mental attitudes [69,15,25,13]. Verification is important in this area as agent autonomy makes it crucial to be able to guarantee that the system behaves as required [43]. Furthermore, one generally wants to ensure that the agents’ mental states as well as their behavior evolve in a way that satisfies certain properties. Agent logics can be used to specify such properties. Much of the verification work in this area focuses on the model checking of BDI programs. For instance, [14] shows how to use the SPIN model checker [52] to verify properties of finite-state AgentSpeak programs. [35,43] compile BDI programs and agent properties to verify into Java and use JPF [87] to model check them. [62] develops MCMAS, a symbolic model checker specifically for multi-agent systems. [2] develops a theorem proving-based verification framework for BDI programs that uses a PDL-like logic.\nIn the situation calculus, there is also some previous work on verification. Perhaps the first such work is [33], where verification of possibly non-terminating Golog [58] programs is addressed, though no effective techniques are given. Focusing on the propositional situation calculus (where fluents have only the situation as argument), [85] presents decidable verification techniques. In [48], these techniques are generalized to a one-object-argument fluents fragment of the situation calculus, and in [49] to theories expressed in two-object-argument fragment. Techniques for verification resorting to second-order theorem proving with no decidability guarantees are presented in [81,82], where the CASLve verification environment for multi-agent ConGolog [26] programs is described. In [22], characteristic graphs for programs are introduced to define a form of regression over programs to be used as a pre-image computation step in (sound) procedures for verifying Golog and ConGolog programs inspired by model checking. Verification of programs over a two-variable fragment of the situation calculus is shown to be decidable in [23]. [54] establishes conditions for verifying loop invariants and persistence properties. Finally, [31,77] propose techniques (with modelchecking ingredients) to reason about infinite executions of Golog and ConGolog programs based on second-order logic exploiting fixpoint approximates.\nMore recently, work closely related to ours [27,28,30,29] has shown that one gets robust decidability results for temporal verification of situation calculus action theories under the assumption that in every situation the number of object tuples forming the extension of each fluent is bounded by a constant. In particular, [27] introduced bounded situation calculus basic action theories; [27] however, assumes standard names for the object domain and, more significantly, disallows quantification across situations in the verification language. In the present paper, which is a direct extension of [27], both of these limitations are removed. In [28] an extended language with an explicit knowledge operator was considered, while in [30] online executions (i.e., executions where the agent only performs actions that it knows are executable) and progression are studied; like [27], these papers also assume standard names and rule out quantification across situations from the verification language. [29] addresses verification over online executions with sensing in bounded situation calculus theories, adopting as verification\nlanguage a first-order variant of Linear Temporal Logic (FO-LTL), again without quantification across situations.\nThe work in this paper is also closely related to [10]. There, an ad-hoc formalism for representing action and change is developed with the purpose of capturing data-aware artifact-centric processes. This formalism describes action preconditions and postconditions in first-order logic, and induces genericity [1] — there called uniformity — on the generated transition system. Intuitively genericity requires that if two states are isomorphic they induce the “same” transitions (modulo isomorphism). This means, in particular, that the system is essentially Markovian [73]. As verification language, they consider FO-CTL, a first-order variant of CTL that allows for quantifying across states without requiring object persistence, as, instead, we do here. Their results imply that one can construct a finite-state transition system over which the FO-CTL formula of interest can be verified. However, differently from our case, such a transition system depends also on the number of variables in the formula. While also bounded situation calculus action theories enjoy genericity, it is easy to see that, without assuming object persistence, we immediately lose the possibility of abstracting to a finite transition system independently from the formula to verify. This is true even if we drop completely fixpoints. Indeed, assume that we have an action replaces an object in the active domain by one in its parameters. Then, without persistence, for any bound n over the number of objects in a candidate finite abstraction, we can write a (fixpoint-free) formula saying that there exists a finite run with more than n distinct objects:\n∃x1.LIVE(x1) ∧ 〈−〉(∃x2.LIVE(x2) ∧ x2 6= x1 ∧ 〈−〉(∃x3LIVE(x3) ∧ x3 6= x1 ∧ x3 6= x2 ∧\n· · · 〈−〉(∃xn+1LIVE(xn+1) ∧ xn+1 6= x1 ∧ · · · ∧ xn+1 6= xn)))\nObviously, this formula is false in the finite abstraction, while true in the original transition system, where objects are not “reused”. Notice that the formula belongs also to FO-CTL and this limitation applies to [10] as well. This observation shows that the persistence condition is crucial to get an abstraction that is independent from the formula.\nIt is interesting to observe that while dropping persistence is certainly a valuable syntactic simplification, the deep reason behind it is that generic transition systems, including those generated by situation calculus basic action theories, are essentially unable to talk about objects that are not in the current active domain. If some object that is in the active domain disappears from it and reappears again, after some steps, the basic action theory will treat it essentially as a fresh object (i.e., an object never seen before). Hence, any special treatment of such objects must come from the formula we are querying the transition system with: for example, we may isolate runs with special properties and only on those do verification. The fact that FO-CTL can drop persistence while maintaining decidability of verification over generic transition systems tells us that FO-CTL is not powerful enough to isolate interesting runs to be used as a further assumption for verification.\nThe results in this paper are relevant not only for AI, but also for other areas of computer science (CS). There is some work in CS that uses model checking techniques on infinite-state systems. However, in most of this work the emphasis is on studying recursive control rather than on a rich data oriented state description; typically data are either\nignored or finitely abstracted, see e.g., [18]. There has recently been some attention paid in the field of business processes and services to including data into the analysis of processes [53,45,38]. Interestingly, while we have verification tools that are quite good for dealing with data and processes separately, when we consider them together, we get infinite-state transition systems, which resist classical model checking approaches to verification. Only lately has there been some work on developing verification techniques that can deal with such infinite-state processes [36,4,9,5,10]. In particular, the form of controlled quantification across situations in our µŁp language, which requires object persistence in the active domain, is inspired by the one in [5], which in turn extends the verification logic presented in [27]. There, the infinite-state data-aware transition systems (with complete information) to verify are defined using an ad-hoc formalism based on database operations, and the decidability results are based on two conditions over the transition systems, namely run-boundedness and state-boundedness. The latter is analogous to our situation-boundedness. In this paper, we make the idea of boundedness flourish in the general setting offered by the situation calculus, detailing conditions needed for decidability, allowing for incomplete information, and exploiting the richness of the situation calculus for giving sufficient conditions for boundedness that can easily be used in practice. Such results can find immediate application in the analysis of data-aware business processes and services."
    }, {
      "heading" : "11 Conclusion",
      "text" : "In this paper, we have defined the notion of bounded action theory in the situation calculus, where the number of fluent atoms that hold remains bounded. We have shown that this restriction is sufficient to ensure that verification of an expressive class of temporal properties remains decidable, and is in fact EXPTIME-complete, despite the fact that we have an infinite domain and state space. Our result holds even in the presence of incomplete information. We have also argued that this restriction can be adhered to in practical applications, by identifying interesting classes of bounded action theories and showing that these can be used to model typical example dynamic domains. Decidability is important from a theoretical standpoint, but we stress also that our result is fully constructive being based on a reduction to model checking of an (abstract) finite-state transition system. An interesting future enterprise is to build on such a result to develop an actual situation calculus verification tool.\nA future research direction of particular interest is a more systematic investigation of specification patterns for obtaining boundedness. This includes patterns that provide bounded persistence and patterns that model bounded/fading memory. These questions should be examined in light of different approaches that have been proposed for modeling knowledge, sensing, and revision in the situation calculus and related temporal logics [78,34,83,37]. This work has already started. In particular, as mentioned earlier, the approach of this paper has been extended in [30,29] to allow verification temporal properties over online executions of an agent, where the agent may acquire new information through sensing as it executes and only performs actions that are feasible according to its beliefs. In that work, the agent’s belief state is modeled meta-theoretically, as an action theory that is progressed as actions are performed and sensing results are\nobtained. In [28], temporal epistemic verification is tackled within a language-theoretic viewpoint, where the situation calculus is extended with a knowledge modality [78]. The form of boundedness studied in that case requires that the number of object tuples that the agent thinks may belong to any given fluent be bounded. In [30,29], instead, it is only required that number of distinct tuples entelied to belong to a fluent is bounded, while the number of tuples that are in the extension of a fluent in some model of the theory need not be bounded. More work is needed to fully reconcile these meta-theoretic and language-theoretic approaches.\nFinally, an important topic for future work is to tackle verification of agent programs [33], possibly expressed in a situation calculus-based high-level language like Golog [58] or ConGolog [26]. Some cases where verification of ConGolog programs is decidable are identified in [23]. It woud be interesting to extend our framework to support such a form of verification as well. This is not immediate, as a temporal property may hold over all executions of a program without holding over all branches of the situation tree. To extend our approach to programs, we need to ensure that not just the agent’s beliefs but the whole program configuration remains bounded."
    }, {
      "heading" : "Acknowledgements",
      "text" : "The authors acknowledge the support of: Ripartizione Diritto allo Studio, Università e Ricerca Scientifica of Provincia Autonoma di Bolzano–Alto Adige, under project VeriSynCoPateD (Verification and Synthesis from Components of Processes that Manipulate Data); EU Commission, under the IP project n. FP7-318338 Optique (Scalable End-user Access to Big Data); and the National Science and Engineering Research Council of Canada."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "In this paper, we investigate bounded action theories in the situation<lb>calculus. A bounded action theory is one which entails that, in every situation,<lb>the number of object tuples in the extension of fluents is bounded by a given<lb>constant, although such extensions are in general different across the infinitely<lb>many situations. We argue that such theories are common in applications, either<lb>because facts do not persist indefinitely or because the agent eventually forgets<lb>some facts, as new ones are learnt. We discuss various classes of bounded action<lb>theories. Then we show that verification of a powerful first-order variant of the μ-<lb>calculus is decidable for such theories. Notably, this variant supports a controlled<lb>form of quantification across situations. We also show that through verification,<lb>we can actually check whether an arbitrary action theory maintains boundedness.",
    "creator" : "LaTeX with hyperref package"
  }
}