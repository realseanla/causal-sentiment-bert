{
  "name" : "1401.3492.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "ParamILS: An Automatic Algorithm Configuration Framework",
    "authors" : [ "Frank Hutter", "Holger H. Hoos", "Kevin Leyton-Brown" ],
    "emails" : [ "HUTTER@CS.UBC.CA", "HOOS@CS.UBC.CA", "KEVINLB@CS.UBC.CA", "STUETZLE@ULB.AC.BE" ],
    "sections" : [ {
      "heading" : null,
      "text" : "velopment and application of algorithms. We describe an automatic framework for this algorithm configuration problem. More formally, we provide methods for optimizing a target algorithm’s performance on a given class of problem instances by varying a set of ordinal and/or categorical parameters. We review a family of local-search-based algorithm configuration procedures and present novel techniques for accelerating them by adaptively limiting the time spent for evaluating individual configurations. We describe the results of a comprehensive experimental evaluation of our methods, based on the configuration of prominent complete and incomplete algorithms for SAT. We also present what is, to our knowledge, the first published work on automatically configuring the CPLEX mixed integer programming solver. All the algorithms we considered had default parameter settings that were manually identified with considerable effort. Nevertheless, using our automated algorithm configuration procedures, we achieved substantial and consistent performance improvements."
    }, {
      "heading" : "1. Introduction",
      "text" : "Many high-performance algorithms have parameters whose settings control important aspects of their behaviour. This is particularly the case for heuristic procedures used for solving computationally hard problems.1 As an example, consider CPLEX, a commercial solver for mixed integer programming problems.2 CPLEX version 10 has about 80 parameters that affect the solver’s search mechanism and can be configured by the user to improve performance. There are many acknowledgements in the literature that finding performance-optimizing parameter configurations of heuristic algorithms often requires considerable effort (see, e.g., Gratch & Chien, 1996; Johnson, 2002; Diao, Eskesen, Froehlich, Hellerstein, Spainhower & Surendra, 2003; Birattari, 2004; Adenso-Diaz & Laguna, 2006). In many cases, this tedious task is performed manually in an ad-hoc way. Automating this task is of high practical relevance in several contexts.\n• Development of complex algorithms Setting the parameters of a heuristic algorithm is a highly labour-intensive task, and indeed can consume a large fraction of overall development\n1. Our use of the term ‘heuristic algorithm’ includes methods without provable performance guarantees as well as methods that have such guarantees, but nevertheless make use of heuristic mechanisms. In the latter case, the use of heuristic mechanisms often results in empirical performance far better than the bounds guaranteed by rigorous theoretical analysis. 2. http://www.ilog.com/products/cplex/\nc©2009 AI Access Foundation. All rights reserved.\ntime. The use of automated algorithm configuration methods can lead to significant time savings and potentially achieve better results than manual, ad-hoc methods.\n• Empirical studies, evaluations, and comparisons of algorithms A central question in comparing heuristic algorithms is whether one algorithm outperforms another because it is fundamentally superior, or because its developers more successfully optimized its parameters (Johnson, 2002). Automatic algorithm configuration methods can mitigate this problem of unfair comparisons and thus facilitate more meaningful comparative studies.\n• Practical use of algorithms The ability of complex heuristic algorithms to solve large and hard problem instances often depends critically on the use of suitable parameter settings. End users often have little or no knowledge about the impact of an algorithm’s parameter settings on its performance, and thus simply use default settings. Even if it has been carefully optimized on a standard benchmark set, such a default configuration may not perform well on the particular problem instances encountered by a user. Automatic algorithm configuration methods can be used to improve performance in a principled and convenient way.\nA wide variety of strategies for automatic algorithm configuration have been explored in the literature. Briefly, these include exhaustive enumeration, hill-climbing (Gratch & Dejong, 1992), beam search (Minton, 1993), genetic algorithms (Terashima-Marı́n, Ross & Valenzuela-Réndon, 1999), experimental design approaches (Coy, Golden, Runger & Wasil, 2001), sequential parameter optimization (Bartz-Beielstein, 2006), racing algorithms (Birattari, Stützle, Paquete & Varrentrapp, 2002; Birattari, 2004; Balaprakash, Birattari & Stützle, 2007), and combinations of fractional experimental design and local search (Adenso-Diaz & Laguna, 2006). We discuss this and other related work more extensively in Section 9. Here, we note that while some other authors refer to the optimization of an algorithm’s performance by setting its (typically few and numerical) parameters as parameter tuning, we favour the term algorithm configuration (or simply, configuration). This is motivated by the fact that we are interested in methods that can deal with a potentially large number of parameters, each of which can be numerical, ordinal (e.g., low, medium, or high) or categorical (e.g., choice of heuristic). Categorical parameters can be used to select and combine discrete building blocks of an algorithm (e.g., preprocessing and variable ordering heuristics); consequently, our general view of algorithm configuration includes the automated construction of a heuristic algorithm from such building blocks. To the best of our knowledge, the methods discussed in this article are yet the only general ones available for the configuration of algorithms with many categorical parameters.\nWe now give an overview of what follows and highlight our main contributions. After formally stating the algorithm configuration problem in Section 2, in Section 3 we describe ParamILS (first introduced by Hutter, Hoos & Stützle, 2007), a versatile stochastic local search approach for automated algorithm configuration, and two of its instantiations, BasicILS and FocusedILS.\nWe then introduce adaptive capping of algorithm runs, a novel technique that can be used to enhance search-based algorithm configuration procedures independently of the underlying search strategy (Section 4). Adaptive capping is based on the idea of avoiding unnecessary runs of the algorithm to be configured by developing bounds on the performance measure to be optimized. We present a trajectory-preserving variant and a heuristic extension of this technique. After discussing experimental preliminaries in Section 5, in Section 6 we present empirical evidence showing that adaptive capping speeds up both BasicILS and FocusedILS. We also show that BasicILS\noutperforms random search and a simple local search, as well as further evidence that FocusedILS outperforms BasicILS.\nWe present extensive evidence that ParamILS can find substantially improved parameter configurations of complex and highly optimized algorithms. In particular, we apply our automatic algorithm configuration procedures to the aforementioned commercial optimization tool CPLEX, one of the most powerful, widely used and complex optimization algorithms we are aware of. As stated in the CPLEX user manual (version 10.0, page 247), “A great deal of algorithmic development effort has been devoted to establishing default ILOG CPLEX parameter settings that achieve good performance on a wide variety of MIP models.” We demonstrate consistent improvements over this default parameter configuration for a wide range of practically relevant instance distributions. In some cases, we were able to achieve an average speedup of over an order of magnitude on previously-unseen test instances (Section 7). We believe that these are the first results to be published on automatically configuring CPLEX or any other piece of software of comparable complexity.\nIn Section 8 we review a wide range of (separately-published) ParamILS applications. Specifically, we survey work that has considered the optimization of complete and incomplete heuristic search algorithms for the problems of propositional satisfiability (SAT), most probable explanation (MPE), protein folding, university time-tabling, and algorithm configuration itself. In three of these cases, ParamILS was an integral part of the algorithm design process and allowed the exploration of very large design spaces. This could not have been done effectively in a manual way or by any other existing automated method. Thus, automated algorithm configuration in general and ParamILS in particular enables a new way of (semi-)automatic design of algorithms from components.\nSection 9 presents related work and, finally, Section 10 offers discussion and conclusions. Here we distill the common patterns that helped ParamILS to succeed in its various applications. We also give advice to practitioners who would like to apply automated algorithm configuration in general and ParamILS in particular, and identify promising avenues of research for future work."
    }, {
      "heading" : "2. Problem Statement and Notation",
      "text" : "The algorithm configuration problem we consider in this work can be informally stated as follows: given an algorithm, a set of parameters for the algorithm and a set of input data, find parameter values under which the algorithm achieves the best possible performance on the input data.\nTo avoid potential confusion between algorithms whose performance is optimized and algorithms used for carrying out that optimization task, we refer to the former as target algorithms and to the latter as configuration procedures (or simply configurators). This setup is illustrated in Figure 1. Different algorithm configuration problems have also been considered in the literature, including setting parameters on a per-instance basis and adapting the parameters while the algorithm is running. We defer a discussion of these approaches to Section 9.\nIn the following, we define the algorithm configuration problem more formally and introduce notation that we will use throughout this article. Let A denote an algorithm, and let p1, . . . , pk be parameters of A. Denote the domain of possible values for each parameter pi as Θi. Throughout this work, we assume that all parameter domains are finite sets. This assumption can be met by discretizing all numerical parameters to a finite number of values. Furthermore, while parameters\nmay be ordered, we do not exploit such ordering relations. Thus, we effectively assume that all parameters are finite and categorical.3\nOur problem formulation allows us to express conditional parameter dependencies (for example, one algorithm parameter might be used to select among search heuristics, with each heuristic’s behaviour controlled by further parameters). In this case, the values of these further parameters are irrelevant if the heuristic is not selected. ParamILS exploits this and effectively searches the space of equivalence classes in parameter configuration space. In addition, our formulation supports constraints on feasible combinations of parameter values. We use Θ ⊆ Θ1 × . . . × Θk to denote the space of all feasible parameter configurations, and A(θ) denoting the instantiation of algorithm A with parameter configuration θ ∈ Θ.\nLet D denote a probability distribution over a space Π of problem instances, and denote an element of Π as π. D may be given implicitly, as through a random instance generator or a distribution over such generators. It is also possible (and indeed common) for Π to consist of a finite sample of instances; in this case, we define D as the uniform distribution over Π.\nThere are many ways of measuring an algorithm’s performance. For example, we might be interested in minimizing computational resources consumed by the given algorithm (such as runtime, memory or communication bandwidth), or in maximizing the quality of the solution found. Since high-performance algorithms for computationally-challenging problems are often randomized, their behaviour can vary significantly between multiple runs. Thus, an algorithm will not always achieve the same performance, even when run repeatedly with fixed parameters on a single problem instance. Our overall goal must therefore be to choose parameter settings that minimize some cost statistic of the algorithm’s performance across the input data. We denote this statistic as c(θ). For example, we might aim to minimize mean runtime or median solution cost.\nWith this intuition in mind, we now define the algorithm configuration problem formally.\nDefinition 1 (Algorithm Configuration Problem). An instance of the algorithm configuration problem is a 6-tuple 〈A,Θ,D, κmax, o,m〉, where:\n• A is a parameterized algorithm; • Θ is the parameter configuration space of A;\n3. We are currently extending our algorithm configuration procedures to natively support other parameter types.\n• D is a distribution over problem instances with domain Π; • κmax is a cutoff time (or captime), after which each run of A will be terminated if still run-\nning; • o is a function that measures the observed cost of running A(θ) on an instance π ∈ Π with\ncaptime κ ∈ R (examples are runtime for solving the instance, or cost of the solution found) • m is a statistical population parameter (such as expectation, median, or variance). Any parameter configuration θ ∈ Θ is a candidate solution of the algorithm configuration problem. For each configuration θ, Oθ denotes the distribution of costs induced by function o, applied to instances π drawn from distribution D and multiple independent runs for randomized algorithms, using captime κ = κmax. The cost of a candidate solution θ is defined as\nc(θ) := m(Oθ), (1)\nthe statistical population parameter m of the cost distribution Oθ. An optimal solution, θ∗, minimizes c(θ):\nθ∗ ∈ arg min θ∈Θ c(θ). (2)\nAn algorithm configuration procedure is a procedure for solving the algorithm configuration problem. Unfortunately, at least for the algorithm configuration problems considered in this article, we cannot optimize c in closed form since we do not have access to an algebraic representation of the function. We denote the sequence of runs executed by a configurator as R = ((θ1, π1, s1, κ1, o1), . . . , (θn, πn, sn, κn, on)). The ith run is described by five values:\n• θi ∈ Θ denotes the parameter configuration being evaluated; • πi ∈ Π denotes the instance on which the algorithm is run; • si denotes the random number seed used in the run (we keep track of seeds to be able to block\non them, see Section 5.1.2); • κi denotes the run’s captime; and • oi denotes the observed cost of the run\nNote that each of θ, π, s, κ, and o can vary from one element of R to the next, regardless of whether or not other elements are held constant. We denote the ith run of R as R[i], and the subsequence of runs using parameter configuration θ (i.e., those runs with θi = θ) as Rθ. The configuration procedures considered in this article compute empirical estimates of c(θ) based solely on Rθ, but in principle other methods could be used. We compute these cost estimates both online, during runtime of a configurator, as well as offline, for evaluation purposes.\nDefinition 2 (Cost Estimate). Given an algorithm configuration problem 〈A,Θ,D, κmax, o,m〉, we define a cost estimate of a cost c(θ) based on a sequence of runs R = ((θ1, π1, s1, κ1, o1), . . . , (θn, πn, sn, κn, on)) as ĉ(θ,R) := m̂({oi | θi = θ}), where m̂ is the sample statistic analogue to the statistical population parameter m.\nFor example, when c(θ) is the expected runtime over a distribution of instances and random number seeds, ĉ(θ,R) is the sample mean runtime of runs Rθ.\nAll configuration procedures in this paper are anytime algorithms, meaning that at all times they keep track of the configuration currently believed to have the lowest cost; we refer to this configuration as the incumbent configuration, or in short the incumbent, θinc. We evaluate a configurator’s performance at time t by means of its incumbent’s training and test performance, defined as follows.\nDefinition 3 (Training performance). When at some time t a configurator has performed a sequence of runs R = ((θ1, π1, s1, κ1, o1), . . . , (θn, πn, sn, κn, on)) to solve an algorithm configuration problem 〈A,Θ,D, κmax, o,m〉, and has thereby found incumbent configuration θinc, then its training performance at time t is defined as the cost estimate ĉ(θinc,R).\nThe set of instances {π1, . . . , πn} discussed above is called the training set. While the true cost of a parameter configuration cannot be computed exactly, it can be estimated using training performance. However, the training performance of a configurator is a biased estimator of its incumbent’s true cost, because the same instances are used for selecting the incumbent as for evaluating it. In order to achieve unbiased estimates during offline evaluation, we set aside a fixed set of instances {π′1, . . . , π′T } (called the test set) and random number seeds {s′1, . . . , s′T }, both unknown to the configurator, and use these for evaluation.\nDefinition 4 (Test performance). At some time t, let a configurator’s incumbent for an algorithm configuration problem 〈A,Θ,D, κmax, o,m〉 be θinc (this is found by means of executing a sequence of runs on the training set). Furthermore, let R′ = ((θinc, π′1, s ′ 1, κmax, o1), . . . , (θinc, π ′ T , s′T , κmax, oT )) be a sequence of runs on the T instances and random number seeds in the test set (which is performed offline for evaluation purposes), then the configurator’s test performance at time t is defined as the cost estimate ĉ(θinc,R′).\nThroughout this article, we aim to minimize expected runtime. (See Section 5.1.1 for a discussion of that choice.) Thus, a configurator’s training performance is the mean runtime of the runs it performed with the incumbent. Its test performance is the mean runtime of the incumbent on the test set. Note that, while the configurator is free to use any κi ≤ κmax, test performance is always computed using the maximal captime, κmax.\nIt is not obvious how an automatic algorithm configurator should choose runs in order to best minimize c(θ) within a given time budget. In particular, we have to make the following choices:\n1. Which parameter configurations Θ′ ⊆ Θ should be evaluated? 2. Which problem instances Πθ′ ⊆ Π should be used for evaluating each θ′ ∈ Θ′, and how\nmany runs should be performed on each instance? 3. Which cutoff time κi should be used for each run?\nHutter, Hoos and Leyton-Brown (2009) considered this design space in detail, focusing on the tradeoff between the (fixed) number of problem instances to be used for the evaluation of each parameter configuration and the (fixed) cutoff time used for each run, as well as the interaction of these choices with the number of configurations that can be considered. In contrast, here, we study adaptive approaches for selecting the number of problem instances (Section 3.3) and the cutoff time for the evaluation of a parameter configuration (Section 4); we also study which configurations should be selected (Sections 3.1 and 6.2)."
    }, {
      "heading" : "3. ParamILS: Iterated Local Search in Parameter Configuration Space",
      "text" : "In this section, we address the first and most important of the previously mentioned dimensions of automated algorithm configuration, the search strategy, by describing an iterated local search framework called ParamILS. To start with, we fix the other two dimensions, using an unvarying benchmark set of instances and fixed cutoff times for the evaluation of each parameter configuration. Thus, the stochastic optimization problem of algorithm configuration reduces to a simple\noptimization problem, namely to find the parameter configuration that yields the lowest mean runtime on the given benchmark set. Then, in Section 3.3, we address the second question of how many runs should be performed for each configuration."
    }, {
      "heading" : "3.1 The ParamILS framework",
      "text" : "Consider the following manual parameter optimization process:\n1. begin with some initial parameter configuration; 2. experiment with modifications to single parameter values, accepting new configurations when-\never they result in improved performance; 3. repeat step 2 until no single-parameter change yields an improvement.\nThis widely used procedure corresponds to a manually-executed local search in parameter configuration space. Specifically, it corresponds to an iterative first improvement procedure with a search space consisting of all possible configurations, an objective function that quantifies the performance achieved by the target algorithm with a given configuration, and a neighbourhood relation based on the modification of one single parameter value at a time (i.e., a “one-exchange” neighbourhood).\nViewing this manual procedure as a local search algorithm is advantageous because it suggests the automation of the procedure as well as its improvement by drawing on ideas from the stochastic local search community. For example, note that the procedure stops as soon as it reaches a local optimum (a parameter configuration that cannot be improved by modifying a single parameter value). A more sophisticated approach is to employ iterated local search (ILS; Lourenço, Martin & Stützle, 2002) to search for performance-optimizing parameter configurations. ILS is a prominent stochastic local search method that builds a chain of local optima by iterating through a main loop consisting of (1) a solution perturbation to escape from local optima, (2) a subsidiary local search procedure and (3) an acceptance criterion to decide whether to keep or reject a newly obtained candidate solution.\nParamILS (given in pseudocode as Algorithm 1) is an ILS method that searches parameter configuration space. It uses a combination of default and random settings for initialization, employs iterative first improvement as a subsidiary local search procedure, uses a fixed number (s) of random moves for perturbation, and always accepts better or equally-good parameter configurations, but re-initializes the search at random with probability prestart.4 Furthermore, it is based on a one-exchange neighbourhood, that is, we always consider changing only one parameter at a time. ParamILS deals with conditional parameters by excluding all configurations from the neighbourhood of a configuration θ that differ only in a conditional parameter that is not relevant in θ."
    }, {
      "heading" : "3.2 The BasicILS Algorithm",
      "text" : "In order to turn ParamILS as specified in Algorithm Framework 1 into an executable configuration procedure, it is necessary to instantiate the function better that determines which of two parameter settings should be preferred. We will ultimately propose several different ways of doing this. Here, we describe the simplest approach, which we call BasicILS. Specifically, we use the term BasicILS(N ) to refer to a ParamILS algorithm in which the function better(θ1,θ2) is implemented as shown in Procedure 2: simply comparing estimates ĉN of the cost statistics c(θ1) and c(θ2) that are based on N runs each.\n4. Our original parameter choices 〈r, s, prestart〉 = 〈10, 3, 0.01〉 (from Hutter et al., 2007) were somewhat arbitrary, though we expected performance to be quite robust with respect to these settings. We revisit this issue in Section 8.4.\nAlgorithm Framework 1: ParamILS(θ0, r, prestart, s) Outline of iterated local search in parameter configuration space; the specific variants of ParamILS we study, BasicILS(N) and FocusedILS, are derived from this framework by instantiating procedure better (which compares θ,θ′ ∈ Θ). BasicILS(N) uses betterN (see Procedure 2), while FocusedILS uses betterFoc (see Procedure 3). The neighbourhood Nbh(θ) of a configuration θ is the set of all configurations that differ from θ in one parameter, excluding configurations differing in a conditional parameter that is not relevant in θ.\nInput : Initial configuration θ0 ∈ Θ, algorithm parameters r, prestart, and s. Output : Best parameter configuration θ found. for i = 1, . . . , r do1 θ ← random θ ∈ Θ;2 if better(θ,θ0) then θ0 ← θ;3\nθils ← IterativeFirstImprovement (θ0);4 while not TerminationCriterion() do5\nθ ← θils;6 // ===== Perturbation for i = 1, . . . , s do θ ← random θ′ ∈ Nbh(θ);7 // ===== Basic local search θ ← IterativeFirstImprovement (θ);8 // ===== AcceptanceCriterion if better(θ,θils) then θils ← θ;9 with probability prestart do θils ← random θ ∈ Θ;10\nreturn overall best θinc found;11\nProcedure IterativeFirstImprovement (θ)12 repeat13 θ′ ← θ;14 foreach θ′′ ∈ Nbh(θ′) in randomized order do15 if better(θ′′,θ′) then θ ← θ′′; break;16 until θ′ = θ;17 return θ;18\nBasicILS(N ) is a simple and intuitive approach since it evaluates every parameter configuration by running it on the same N training benchmark instances using the same random number seeds. Like many other related approaches (see, e.g., Minton, 1996; Coy et al., 2001; Adenso-Diaz & Laguna, 2006), it deals with the stochastic part of the optimisation problem by using an estimate based on a fixed training set of N instances. When benchmark instances are very heterogeneous or\nProcedure 2: betterN (θ1,θ2) Procedure used in BasicILS(N ) and RandomSearch(N ) to compare two parameter configurations. Procedure objective(θ, N) returns the user-defined objective achieved by A(θ) on the first N instances and keeps track of the incumbent solution, θinc; it is detailed in Procedure 4 on page 279.\nInput : Parameter configuration θ1, parameter configuration θ2 Output : True if θ1 does better than or equal to θ2 on the first N instances; false otherwise Side Effect : Adds runs to the global caches of performed algorithm runs Rθ1 and Rθ2 ; potentially\nupdates the incumbent θinc ĉN (θ2)← objective(θ2, N)1 ĉN (θ1)← objective(θ1, N)2 return ĉN (θ1) ≤ ĉN (θ2)3\nwhen the user can identify a rather small “representative” subset of instances, this approach can find good parameter configurations with low computational effort."
    }, {
      "heading" : "3.3 FocusedILS: Adaptively Selecting the Number of Training Instances",
      "text" : "The question of how to choose the number of training instances, N , in BasicILS(N ) has no straightforward answer: optimizing performance using too small a training set leads to good training performance, but poor generalization to previously unseen test benchmarks. On the other hand, we clearly cannot evaluate every parameter configuration on an enormous training set—if we did, search progress would be unreasonably slow.\nFocusedILS is a variant of ParamILS that deals with this problem by adaptively varying the number of training samples considered from one parameter configuration to another. We denote the number of runs available to estimate the cost statistic c(θ) for a parameter configuration θ by N(θ). Having performed different numbers of runs using different parameter configurations, we face the question of comparing two parameter configurations θ and θ′ for which N(θ) ≤ N(θ′). One option would be simply to compute the empirical cost statistic based on the available number of runs for each configuration. However, this can lead to systematic biases if, for example, the first instances are easier than the average instance. Instead, we compare θ and θ′ based on N(θ) runs on the same instances and seeds. This amounts to a blocking strategy, which is a straight-forward adaptation of a known variance reduction technique; see 5.1 for a more detailed discussion.\nThis approach to comparison leads us to a concept of domination. We say that θ dominates θ′ when at least as many runs have been conducted on θ as on θ′, and the performance ofA(θ) on the first N(θ′) runs is at least as good as that of A(θ′) on all of its runs.\nDefinition 5 (Domination). θ1 dominates θ2 if and only if N(θ1) ≥ N(θ2) and ĉN(θ2)(θ1) ≤ ĉN(θ2)(θ2).\nNow we are ready to discuss the comparison strategy encoded in procedure betterFoc(θ1,θ2), which is used by the FocusedILS algorithm (see Procedure 3). This procedure first acquires one additional sample for the configuration i having smallerN(θi), or one run for both configurations if they have the same number of runs. Then, it continues performing runs in this way until one configuration dominates the other. At this point it returns true if θ1 dominates θ2, and false otherwise. We also keep track of the total number of configurations evaluated since the last improving step (i.e., since the last time betterFoc returned true); we denote this number asB. Whenever betterFoc(θ1,θ2) returns true, we perform B “bonus” runs for θ1 and reset B to 0. This mechanism ensures that we perform many runs with good configurations, and that the error made in every comparison of two configurations θ1 and θ2 decreases on expectation.\nIt is not difficult to show that in the limit, FocusedILS will sample every parameter configuration an unbounded number of times. The proof relies on the fact that, as an instantiation of ParamILS, FocusedILS performs random restarts with positive probability.\nLemma 6 (Unbounded number of evaluations). Let N(J,θ) denote the number of runs FocusedILS has performed with parameter configuration θ at the end of ILS iteration J to estimate c(θ). Then, for any constant K and configuration θ ∈ Θ (with finite |Θ|), limJ→∞ P [N(J,θ) ≥ K] = 1.\nProof. After each ILS iteration of ParamILS, with probability prestart > 0 a new configuration is picked uniformly at random, and with probability 1/|Θ|, this is configuration θ. The probability of\nProcedure 3: betterFoc(θ1,θ2) Procedure used in FocusedILS to compare two parameter configurations. Procedure objective(θ, N) returns the user-defined objective achieved byA(θ) on the first N instances, keeps track of the incumbent solution, and updates Rθ (a global cache of algorithm runs performed with parameter configuration θ); it is detailed in Procedure 4 on page 279. For each θ, N(θ) = length(Rθ). B is a global counter denoting the number of configurations evaluated since the last improvement step.\nInput : Parameter configuration θ1, parameter configuration θ2 Output : True if θ1 dominates θ2, false otherwise Side Effect: Adds runs to the global caches of performed algorithm runs Rθ1 and Rθ2 ; updates the\nglobal counter B of bonus runs, and potentially the incumbent θinc B ← B + 11 if N(θ1) ≤ N(θ2) then2 θmin ← θ1; θmax ← θ23 if N(θ1) = N(θ2) then B ← B + 14\nelse θmin ← θ2; θmax ← θ15 repeat6 i← N(θmin) + 17 ĉi(θmax)← objective(θmax, i) // If N(θmin) = N(θmax), adds a new run to Rθmax .8 ĉi(θmin)← objective(θmin, i) // Adds a new run to Rθmin .9\nuntil dominates(θ1, θ2) or dominates(θ2, θ1)10 if dominates(θ1, θ2) then11 // ===== Perform B bonus runs. ĉN(θ1)+B(θ1)← objective(θ1, N(θ1) +B) // Adds B new runs to Rθ1 .12 B ← 013 return true14\nelse return false15\nProcedure dominates(θ1,θ2)16 if N(θ1) < N(θ2) then return false17 return objective(θ1, N(θ2)) ≤ objective(θ2, N(θ2))18\nvisiting θ in an ILS iteration is thus p ≥ prestart|Θ| > 0. Hence, the number of runs performed with θ is lower-bounded by a binomial random variable B(k; J, p). Then, for any constant k < K we obtain limJ→∞ B(k; J, p) = limJ→∞ ( J k ) pk(1− p)J−k = 0. Thus, limJ→∞ P [N(J,θ) ≥ K] = 1.\nDefinition 7 (Consistent estimator). ĉN (θ) is a consistent estimator for c(θ) iff\n∀ > 0 : lim N→∞ P (|ĉN (θ)− c(θ)| < ) = 1.\nWhen ĉN (θ) is a consistent estimator of c(θ), cost estimates become more and more reliable as N approaches infinity, eventually eliminating overconfidence and the possibility of mistakes in comparing two parameter configurations. This fact is captured in the following lemma.\nLemma 8 (No mistakes for N → ∞). Let θ1,θ2 ∈ Θ be any two parameter configurations with c(θ1) < c(θ2). Then, for consistent estimators ĉN , limN→∞ P (ĉN (θ1) ≥ ĉN (θ2)) = 0.\nProof. Write c1 as shorthand for c(θ1), c2 for c(θ2), ĉ1 for ĉN (θ1), and ĉ2 for ĉN (θ2). Define m = 12 · (c2 + c1) as the midpoint between c1 and c2, and = c2 − m = m − c1 > 0 as its distance from each of the two points. Since ĉN is a consistent estimator for c, the estimate ĉ1 comes arbitrarily close to the real cost c1. That is, limN→∞ P (|ĉ1 − c1| < ) = 1. Since\n|m − c1| = , the estimate ĉ1 cannot be greater than or equal to m: limN→∞ P (ĉ1 ≥ m) = 0. Similarly, limN→∞ P (ĉ2 < m) = 0. Since\nP (ĉ1 ≥ ĉ2) = P (ĉ1 ≥ ĉ2 ∧ ĉ1 ≥ m) + P (ĉ1 ≥ ĉ2 ∧ ĉ1 < m) = P (ĉ1 ≥ ĉ2 ∧ ĉ1 ≥ m) + P (ĉ1 ≥ ĉ2 ∧ ĉ1 < m ∧ ĉ2 < m) ≤ P (ĉ1 ≥ m) + P (ĉ2 < m),\nwe have limN→∞ P (ĉ1 ≥ ĉ2) ≤ limN→∞ (P (ĉ1 ≥ m) + P (ĉ2 < m)) = 0 + 0 = 0.\nCombining our two lemmata we can now show that in the limit, FocusedILS is guaranteed to converge to the true best parameter configuration.\nTheorem 9 (Convergence of FocusedILS). When FocusedILS optimizes a cost statistic c based on a consistent estimator ĉN , the probability that it finds the true optimal parameter configuration θ∗ approaches one as the number of ILS iterations goes to infinity.\nProof. According to Lemma 6, N(θ) grows unboundedly for each θ ∈ Θ. For each θ1, θ2, as N(θ1) and N(θ2) go to infinity, Lemma 8 states that in a pairwise comparison, the truly better configuration will be preferred. Thus eventually, FocusedILS visits all finitely many parameter configurations and prefers the best one over all others with probability arbitrarily close to one.\nWe note that in many practical scenarios cost estimators may not be consistent—that is, they may fail to closely approximate the true performance of a given parameter configuration even for a large number of runs of the target algorithm. For example, when a finite training set, Π, is used during configuration rather than a distribution over problem instances, D, then even for large N , ĉN will only accurately reflect the cost of parameter configurations on the training set, Π. For small training sets, Π, the cost estimate based on Π may differ substantially from the true cost as defined by performance across the entire distribution, D. The larger the training set, Π, the smaller the expected difference (it vanishes as training set size goes to infinity). Thus, it is important to use large training sets (which are representative of the distribution of interest) whenever possible."
    }, {
      "heading" : "4. Adaptive Capping of Algorithm Runs",
      "text" : "Now we consider the last of our dimensions of automated algorithm configuration, the cutoff time for each run of the target algorithm. We introduce an effective and simple capping technique that adaptively determines the cutoff time for each run. The motivation for this capping technique comes from a problem encountered by all configuration procedures considered in this article: often the search for a performance-optimizing parameter setting spends a lot of time with evaluating a parameter configuration that is much worse than other, previously-seen configurations.\nConsider, for example, a case where parameter configuration θ1 takes a total of 10 seconds to solve N = 100 instances (i.e., it has a mean runtime of 0.1 seconds per instance), and another parameter configuration θ2 takes 100 seconds to solve the first of these instances. In order to compare the mean runtimes of θ1 and θ2 based on this set of instances, knowing all runtimes for θ1, it is not necessary to run θ2 on all 100 instances. Instead, we can already terminate the first run of θ2 after 10 + seconds. This results in a lower bound on θ2’s mean runtime of 0.1 + /100 since the remaining 99 instances could take no less than zero time. This lower bound exceeds the mean runtime of θ1, and so we can already be certain that the comparison will favour θ1. This insight provides the basis for our adaptive capping technique."
    }, {
      "heading" : "4.1 Adaptive Capping in BasicILS",
      "text" : "In this section, we introduce adaptive capping for BasicILS. We first introduce a trajectory-preserving version of adaptive capping (TP capping) that provably does not change BasicILS’s search trajectory and can lead to large computational savings. We then modify this strategy heuristically to perform more aggressive adaptive capping (Aggr capping), potentially yielding even better performance in practice."
    }, {
      "heading" : "4.1.1 TRAJECTORY-PRESERVING CAPPING",
      "text" : "Observe that all comparisons between parameter configurations in ParamILS are pairwise. In BasicILS(N ), these comparisons are based on Procedure betterN (θ1,θ2), where θ2 is either the best configuration encountered in this ILS iteration or the best configuration of the last ILS iteration. Without adaptive capping, these comparisons can take a long time, since a poor parameter configuration θ can easily take more than an order of magnitude longer than good configurations.\nFor the case of optimizing the mean of non-negative cost functions (such as runtime or solution cost), we implement a bounded evaluation of a parameter configuration θ based on N runs and a given performance bound in Procedure objective (see Procedure 4). This procedure sequentially performs runs for parameter configuration θ and after each run computes a lower bound on ĉN (θ) based on the i ≤ N runs performed so far. Specifically, for our objective of mean runtime we sum the runtimes of each of the i runs, and divide this sum by N ; since all runtimes must be nonnegative, this quantity lower bounds ĉN (θ). Once the lower bound exceeds the bound passed as an argument, we can skip the remaining runs for θ. In order to pass the appropriate bounds to Procedure objective, we need to slightly modify Procedure betterN (see Procedure 2 on page 274) for adaptive capping. Procedure objective now has a bound as an additional third argument, which is set to∞ in line 1 of betterN , and to ĉN (θ2) in line 2.\nBecause this approach results in the computation of exactly the same function betterN as used in the original version of BasicILS, the modified procedure follows exactly the same search trajectory it would have followed without capping, but typically requires much less runtime. Hence, within the same amount of overall running time, this new version of BasicILS tends to be able to search a larger part of the parameter configuration space. Although in this work we focus on the objective of minimizing mean runtime for decision algorithms, we note that our adaptive capping approach can be applied easily to other configuration objectives."
    }, {
      "heading" : "4.1.2 AGGRESSIVE CAPPING",
      "text" : "As we demonstrate in Section 6.4, the use of trajectory-preserving adaptive capping can result in substantial speedups of BasicILS. However, sometimes this approach is still less efficient than it could be. This is because the upper bound on cumulative runtime used for capping is computed from the best configuration encountered in the current ILS iteration (where a new ILS iteration begins after each perturbation), as opposed to the overall incumbent. After a perturbation has resulted in a new parameter configuration θ, the new iteration’s best configuration is initialized to θ. In the frequent case that this new θ performs poorly, the capping criterion does not apply as quickly as when the comparison is performed against the overall incumbent.\nTo counteract this effect, we introduce a more aggressive capping strategy that can terminate the evaluation of a poorly-performing configuration at any time. In this heuristic extension of our adaptive capping technique, we bound the evaluation of any parameter configuration by the per-\nProcedure 4: objective(θ, N, optional parameter bound) Procedure that computes ĉN (θ), either by performing new runs or by exploiting previous cached runs. An optional third parameter specifies a bound on the computation to be performed; when this parameter is not specified, the bound is taken to be∞. For each θ, N(θ) is the number of runs performed for θ, i.e., the length of the global array Rθ. When computing runtimes, we count unsuccessful runs as 10 times their cutoff time.\nInput : Parameter configuration θ, number of runs, N , optional bound bound Output : ĉN (θ) if ĉN (θ) ≤ bound, otherwise a large constant (maxPossibleObjective) plus the number of instances that remain unsolved when the bound was exceeded Side Effect: Adds runs to the global cache of performed algorithm runs, Rθ; updates global\nincumbent, θinc // ===== Maintain invariant: N(θinc) ≥ N(θ) for any θ if θ 6= θinc and N(θinc) < N then1 ĉN (θinc)← objective(θinc, N,∞) // Adds N −N(θinc) runs to Rθinc2 // ===== For aggressive capping, update bound. if Aggressive capping then bound← min(bound, bm · ĉN (θinc))3 // ===== Update the run results in tuple Rθ . for i = 1...N do4 sum runtime← sum of runtimes in Rθ[1], . . . ,Rθ[i− 1] // Tuple indices starting at 1.5 κ′i ← max(κmax, N · bound− sum runtime)6 if N(θ) ≥ i then (θ, πi, κi, oi)← Rθ[i]7 if N(θ) ≥ i and ((κi ≥ κ′i and oi = “unsuccessful”) or (κi < κ′i and oi 6= “unsuccessful”))8 then o′i ← oi // Previous run is longer yet unsuccessful or shorter yet successful⇒ can re-use result else9\no′i ← objective from a newly executed run ofA(θ) on instance πi with seed si and captime κi10 Rθ[i]← (θ, πi, κ′i, o′i)11 if 1/N · (sum runtime + o′i) > bound then return maxPossibleObjective + (N + 1)− i12 if N = N(θinc) and (sum of runtimes in Rθ) < (sum of runtimes in Rθinc ) then θinc ← θ13 return 1/N · (sum of runtimes in Rθ)14\nformance of the incumbent parameter configuration multiplied by a factor that we call the bound multiplier, bm. When a comparison between any two parameter configurations θ and θ′ is performed and the evaluations of both are terminated preemptively, the configuration having solved more instances within the allowed time is taken to be the better one. (This behaviour is achieved by line 12 in Procedure objective, which keeps track of the number of instances solved when exceeding the bound.) Ties are broken to favour moving to a new parameter configuration instead of staying with the current one.\nDepending on the bound multiplier, the use of this aggressive capping mechanism may change the search trajectory of BasicILS. For bm = ∞ the heuristic method reduces to our trajectorypreserving method, while a very aggressive setting of bm = 1 means that once we know a parameter configuration to be worse than the incumbent, we stop its evaluation. In our experiments we set bm = 2, meaning that once the lower bound on the performance of a configuration exceeds twice the performance of the incumbent solution, its evaluation is terminated. (In Section 8.4, we revisit this choice of bm = 2, configuring the parameters of ParamILS itself.)"
    }, {
      "heading" : "4.2 Adaptive Capping in FocusedILS",
      "text" : "The main difference between BasicILS and FocusedILS is that the latter adaptively varies the number of runs used to evaluate each parameter configuration. This difference complicates, but does not prevent the use of adaptive capping. This is because FocusedILS always compares pairs of parameter configurations based on the same number of runs for each configuration, even though this number can differ from one comparison to the next.\nThus, we can extend adaptive capping to FocusedILS by using separate bounds for every number of runs, N . Recall that FocusedILS never moves from one configuration, θ, to a neighbouring configuration, θ′, without performing at least as many runs for θ′ as have been performed for θ. Since we keep track of the performance of θ with any number of runs M ≤ N(θ), a bound for the evaluation of θ′ is always available. Therefore, we can implement both trajectory-preserving and aggressive capping as we did for BasicILS.\nAs for BasicILS, for FocusedILS the inner workings of adaptive capping are implemented in Procedure objective (see Procedure 4). We only need to modify Procedure betterFoc (see Procedure 3 on page 276) to call objective with the right bounds. This leads to the following changes in Procedure betterFoc. Subprocedure dominates on line 16 now takes a bound as an additional argument and passes it on to the two calls to objective in line 18. The two calls of dominates in line 10 and the one call in line 11 all use the bound ĉθmax . The three direct calls to objective in lines 8, 9, and 12 use bounds∞, ĉθmax , and∞, respectively."
    }, {
      "heading" : "5. Experimental Preliminaries",
      "text" : "In this section we give background information about the computational experiments presented in the following sections. First, we describe the design of our experiments. Next, we present the configuration scenarios (algorithm/benchmark data combinations) studied in the following section. Finally, we describe the low-level details of our experimental setup."
    }, {
      "heading" : "5.1 Experimental Design",
      "text" : "Here we describe our objective function and the methods we used for selecting instances and seeds."
    }, {
      "heading" : "5.1.1 CONFIGURATION OBJECTIVE: PENALIZED AVERAGE RUNTIME",
      "text" : "In Section 2, we mentioned that algorithm configuration problems arise in the context of various different cost statistics. Indeed, in our past work we explored several of them: maximizing solution quality achieved in a given time, minimizing the runtime required to reach a given solution quality, and minimizing the runtime required to solve a single problem instance (Hutter et al., 2007).\nIn this work we focus on the objective of minimizing the mean runtime over instances from a distribution D. This optimization objective naturally occurs in many practical applications. It also implies a strong correlation between c(θ) and the amount of time required to obtain a good empirical estimate of c(θ). This correlation helps to make our adaptive capping scheme effective.\nOne might wonder whether means are the right way to aggregate runtimes. In some preliminary experiments, we found that minimizing mean runtime led to parameter configurations with overall good runtime performance, including rather competitive median runtimes, while minimizing median runtime yielded less robust parameter configurations that timed out on a large (but < 50%) fraction of the benchmark instances. However, when we encounter runs that do not terminate within\nthe given cutoff time the mean is ill-defined. In order to penalize timeouts, we define the penalized average runtime (PAR) of a set of runs with cutoff time κmax to be the mean runtime over those runs, where unsuccessful runs are counted as p · κmax with penalization constant p ≥ 1. In this study, we use p = 10."
    }, {
      "heading" : "5.1.2 SELECTING INSTANCES AND SEEDS",
      "text" : "As mentioned previously, often only a finite set Π of instances is available upon which to evaluate our algorithm. This is the case in the experiments we report here. Throughout our study, all configuration experiments are performed on a training set containing half of the given benchmark instances. The remaining instances are solely used as a test set to evaluate the found parameter configurations.\nFor evaluations within ParamILS that are based on N runs, we selected the N instances and random number seeds to be used by following a common blocking technique (see, e.g., Birattari et al., 2002; Ridge & Kudenko, 2006). We ensured that whenever two parameter configurations were compared, their cost estimates were based on exactly the same instances and seeds. This serves to avoid noise effects due to differences between instances and the use of different seeds. For example, it prevents us from making the mistake of considering configuration θ to be better than configuration θ′ just because θ was tested on easier instances.\nWhen dealing with randomized target algorithms, there is also a tradeoff between the number of problem instances used and the number of independent runs performed on each instance. In the extreme case, for a given sample size N , one could perform N runs on a single instance or a single run on N different instances. This latter strategy is known to result in minimal variance of the estimator for common optimization objectives such as minimization of mean runtime (which we consider in this study) or maximization of mean solution quality (see, e.g., Birattari, 2004). Consequently, we only performed multiple runs per instance when we wanted to acquire more samples of the cost distribution than there were instances in the training set.\nBased on these considerations, the configuration procedures we study in this article have been implemented to take a list of 〈instance, random number seed〉 pairs as one of their inputs. Empirical estimates ĉN (θ) of the cost statistic c(θ) to be optimized were determined from the firstN 〈instance, seed〉 pairs in that list. Each list of 〈instance, seed〉 pairs was constructed as follows. Given a training set consisting of M problem instances, for N ≤M , we drew a sample of N instances uniformly at random and without replacement and added them to the list. If we wished to evaluate an algorithm on more samples than we had training instances, which could happen in the case of randomized algorithms, we repeatedly drew random samples of size M as described before, where each such batch corresponded to a random permutation of the N training instances, and added a final sample of size N mod M < M , as in the case N ≤ M . As each sample was drawn, it was paired with a random number seed that was chosen uniformly at random from the set of all possible seeds and added to the list of 〈instance, seed〉 pairs."
    }, {
      "heading" : "5.1.3 COMPARISON OF CONFIGURATION PROCEDURES",
      "text" : "Since the choice of instances (and to some degree of seeds) is very important for the final outcome of the optimization, in our experimental evaluations we always performed a number of independent runs of each configuration procedure (typically 25). We created a separate list of instances and seeds for each run as explained above, where the kth run of each configuration procedure uses the same kth list of instances and seeds. (Note, however, that the disjoint test set used to measure performance of parameter configurations was identical for all runs.)\nWe performed a paired statistical test to compare the final results obtained in the runs of two configuration procedures. A paired test was required since the kth run of both procedures shared the same kth list of instances and seeds. In particular, we performed a two-sided paired Max-Wilcoxon test with the null hypothesis that there was no difference in the performances, considering p-values below 0.05 to be statistically significant. The p-values reported in all tables were derived using this test; p-values shown in parentheses refer to cases where the procedure we expected to perform better actually performed worse."
    }, {
      "heading" : "5.2 Configuration Scenarios",
      "text" : "In Section 6, we analyze our configurators based on five configuration scenarios, each combining a high-performance algorithm with a widely-studied benchmark dataset. Table 1 gives an overview of these, which we dub the BROAD scenarios. The algorithms and benchmark instance sets used in these scenarios are described in detail in Sections 5.2.1 and 5.2.2, respectively. In these five BROAD configuration scenarios, we set fairly aggressive cutoff times of five seconds per run of the target algorithm and allowed each configuration procedure to execute the target algorithm for an aggregate runtime of five CPU hours. These short cutoff times and fairly short times for algorithm configuration were deliberately chosen to facilitate many configuration runs for each BROAD scenario. In contrast, in a second set of configuration scenarios (exclusively focusing on CPLEX), we set much larger cutoff times and allowed more time for configuration. We defer a description of these scenarios to Section 7."
    }, {
      "heading" : "5.2.1 TARGET ALGORITHMS",
      "text" : "Our three target algorithms are listed in Table 2 along with their configurable parameters.\nSAPS The first target algorithm used in our experiments was SAPS, a high-performance dynamic local search algorithm for SAT solving (Hutter, Tompkins & Hoos, 2002) as implemented in UBCSAT (Tompkins & Hoos, 2004). When introduced in 2002, SAPS was a state-of-the-art solver, and it still performs competitively on many instances. We chose to study this algorithm because it is well known, it has relatively few parameters, and we are intimately familiar with it. SAPS’s four continuous parameters control the scaling and smoothing of clause weights, as well as the probability of random walk steps. The original default parameters were set manually based on experiments with prominent benchmark instances; this manual experimentation kept the percentage of random steps fixed and took up about one week of development time. Having subsequently gained more experience with SAPS’s parameters for more general problem classes (Hutter, Hamadi, Hoos & Leyton-Brown, 2006), we chose promising intervals for each parameter, including, but not centered at, the original default. We then picked seven possible values for each parameter spread uniformly across its respective interval, resulting in 2401 possible parameter configurations (these are exactly the same values as used by Hutter et al., 2007). As the starting configuration for ParamILS, we used the center point of each parameter’s domain.\nSPEAR The second target algorithm we considered was SPEAR, a recent tree search algorithm for solving SAT problems. SPEAR is a state-of-the-art SAT solver for industrial instances, and with appropriate parameter settings it is the best available solver for certain types of hardware and software verification instances (Hutter, Babić, Hoos & Hu, 2007). Furthermore, configured with ParamILS, SPEAR won the quantifier-free bit-vector arithmetic category of the 2007 Satisfiability Modulo Theories Competition. SPEAR has 26 parameters, including ten categorical, four integer, and twelve continuous parameters, and their default values were manually engineered by its developer. (Manual tuning required about one week.) The categorical parameters mainly control heuristics for variable and value selection, clause sorting, resolution ordering, and enable or disable optimizations, such as the pure literal rule. The continuous and integer parameters mainly deal with activity, decay, and elimination of variables and clauses, as well as with the interval of randomized restarts and percentage of random choices. We discretized the integer and continuous parameters by choosing lower and upper bounds at reasonable values and allowing between three and eight discrete values spread relatively uniformly across the resulting interval, including the default, which served as the starting configuration for ParamILS. The number of discrete values was chosen according to our intuition about the importance of each parameter. After this discretization, there were 3.7 ·1018 possible parameter configurations. Exploiting the fact that nine of the parameters are conditional (i.e., only relevant when other parameters take certain values) reduced this to 8.34 ·1017 configurations.\nCPLEX The third target algorithm we used was the commercial optimization tool CPLEX 10.1.1, a massively parameterized algorithm for solving mixed integer programming (MIP) problems. Out of its 159 user-specifiable parameters, we identified 81 parameters that affect CPLEX’s search trajectory. We were careful to omit all parameters that change the problem formulation (e.g., by changing the numerical accuracy of a solution). Many CPLEX parameters deal with MIP strategy heuristics (such as variable and branching heuristics, probing, dive type and subalgorithms) and with the amount and type of preprocessing to be performed. There are also nine parameters governing how frequently a different type of cut should be used (those parameters have up to four allowable magnitude values and the value “choose automatically”; note that this last value prevents the parameters from being ordinal). A considerable number of other parameters deal with simplex and\nbarrier optimization, and with various other algorithm components. For categorical parameters with an automatic option, we considered all categorical values as well as the automatic one. In contrast, for continuous and integer parameters with an automatic option, we chose that option instead of hypothesizing values that might work well. We also identified some numerical parameters that primarily deal with numerical issues, and fixed those to their default values. For other numerical parameters, we chose up to five possible values that seemed sensible, including the default. For the many categorical parameters with an automatic option, we included the automatic option as a choice for the parameter, but also included all the manual options. Finally, we ended up with 63 configurable parameters, leading to 1.78 · 1038 possible configurations. Exploiting the fact that seven of the CPLEX parameters were only relevant conditional on other parameters taking certain values, we reduced this to 1.38 ·1037 distinct configurations. As the starting configuration for our configuration procedures, we used the default settings, which have been obtained by careful manual configuration on a broad range of MIP instances."
    }, {
      "heading" : "5.2.2 BENCHMARK INSTANCES",
      "text" : "We applied our target algorithms to three sets of benchmark instances: SAT-encoded quasi-group completion problems, SAT-encoded graph-colouring problems based on small world graphs, and MIP-encoded winner determination problems for combinatorial auctions. Each set consisted of 2000 instances, partitioned evenly into training and test sets.\nQCP Our first benchmark set contained 23 000 instances of the quasi-group completion problem (QCP), which has been widely studied by AI researchers. We generated these QCP instances around the solubility phase transition, using the parameters given by Gomes and Selman (1997). Specifically, the order n was drawn uniformly from the interval [26, 43], and the number of holes H (open entries in the Latin square) was drawn uniformly from [1.75, 2.3] · n1.55. The resulting QCP instances were converted into SAT CNF format. For use with the complete solver, SPEAR, we sampled 2000 of these SAT instances uniformly at random. These had on average 1497 variables (standard deviation: 1094) and 13 331 clauses (standard deviation: 12 473), and 1182 of them were satisfiable. For use with the incomplete solver, SAPS, we randomly sampled 2000 instances from the subset of satisfiable instances (determined using a complete algorithm); their number of variables and clauses were very similar to those used with SPEAR.\nSW-GCP Our second benchmark set contained 20 000 instances of the graph colouring problem (GCP) based on the small world (SW) graphs of Gent et al. (1999). Of these, we sampled 2000 instances uniformly at random for use with SPEAR; these had on average 1813 variables (standard deviation: 703) and 13 902 clauses (standard deviation: 5393), and 1109 of them were satisfiable. For use with SAPS, we randomly sampled 2000 satisfiable instances (again, determined using a complete SAT algorithm), whose number of variables and clauses were very similar to those used with SPEAR.\nRegions100 For our third benchmark set we generated 2000 instances of the combinatorial auction winner determination problem, encoded as mixed-integer linear programs (MILPs). We used the regions generator from the Combinatorial Auction Test Suite (Leyton-Brown et al., 2000), with the goods parameter set to 100 and the bids parameter set to 500. The resulting MILP instances contained 501 variables and 193 inequalities on average, with a standard deviation of 1.7 variables and 2.5 inequalities."
    }, {
      "heading" : "5.3 Experimental Setup",
      "text" : "We carried out all of our experiments on a cluster of 55 dual 3.2GHz Intel Xeon PCs with 2MB cache and 2GB RAM, running OpenSuSE Linux 10.1. We measured runtimes as CPU time on these reference machines. All our configuration procedures were implemented as Ruby scripts, and we do not include the runtime of these scripts in the configuration time. In “easy” configuration scenarios, where most algorithm runs finish in milliseconds, the overhead of our scripts can be substantial. Indeed, the longest configuration run we observed took 24 hours to execute five hours worth of target algorithm runtime. In contrast, for the harder CPLEX scenarios described in Section 7 we observed virtually no overhead."
    }, {
      "heading" : "6. Empirical Evaluation of BasicILS, FocusedILS and Adaptive Capping",
      "text" : "In this section, we use our BROAD scenarios to empirically study the performance of BasicILS(N ) and FocusedILS, as well as the effect of adaptive capping. We first demonstrate the large speedups ParamILS achieved over the default parameters and then study the components responsible for this success."
    }, {
      "heading" : "6.1 Empirical Comparison of Default and Optimized Parameter Configurations",
      "text" : "In this section, for each of our five BROAD configuration scenarios, we compare the performance of the respective algorithm’s default parameter configuration against the final configurations found by BasicILS(100) and FocusedILS. Table 3 and especially Figure 2 show that the configurators led to very substantial speedups.\nIn Table 3, we report the final performance achieved by 25 independent runs of each configurator. For each independent configuration run, we used a different set of training instances and seeds (constructed as described in Section 5.1.2). We note that there was often a rather large variance in the performances found in different runs of the configurators, and that the configuration found\nin the run with the best training performance also tended to yield better test performance than the others. For that reason, we used that configuration as the result of algorithm configuration. (Note that choosing the configuration found in the run with the best training set performance is a perfectly legitimate procedure since it does not require knowledge of the test set. Of course, the improvements thus achieved come at the price of increased overall running time, but the independent runs of the configurator can easily be performed in parallel.)\nIn Figure 2, we compare the performance of this automatically-found parameter configuration against the default configuration, when runs are allowed to last up to an hour. The speedups are more obvious in this figure than in Table 3, since the penalized average runtime in that table counts runtimes larger than five seconds as fifty seconds (ten times the cutoff of five seconds), whereas the data in the figure uses a much larger cutoff time. The larger speedups are most apparent for scenarios SAPS-SWGCP, SAPS-QCP, and SPEAR-QCP: their corresponding speedup factors in mean runtime are now 3540, 416 and 11, respectively (see Figure 2).\nAlgorithm 5: RandomSearch(N,θ0) Outline of random search in parameter configuration space; θinc denotes the incumbent parameter configuration, betterN compares two configurations based on the first N instances from the training set.\nInput : Number of runs to use for evaluating parameter configurations, N ; initial configuration θ0 ∈ Θ.\nOutput : Best parameter configuration θinc found. θinc ← θ0;1 while not TerminationCriterion() do2 θ ← random θ ∈ Θ;3 if betterN (θ,θinc) then4 θinc ← θ;5\nreturn θinc6"
    }, {
      "heading" : "6.2 Empirical Comparison of BasicILS and Simple Baselines",
      "text" : "In this section, we evaluate the effectiveness of BasicILS(N ) against two of its components:\n• a simple random search, used in BasicILS for initialization (we dub it RandomSearch(N ) and provide pseudocode for it in Algorithm 5); and\n• a simple local search, the same type of iterative first improvement search used in BasicILS(N ) (we dub it SimpleLS(N )).\nTo evaluate one component at a time, in this section and in Section 6.3 we study our algorithms without adaptive capping. We then investigate the effect of our adaptive capping methods in Section 6.4.\nIf there is sufficient structure in the search space, we expect BasicILS to outperform RandomSearch. If there are local minima, we expect BasicILS to perform better than simple local search. Our experiments showed that BasicILS did indeed offer the best performance.\nHere, we are solely interested in comparing how effectively the approaches search the space of parameter configurations (and not how the found parameter configurations generalize to unseen test instances). Thus, in order to reduce variance in our comparisons, we compare the configuration methods in terms of their performance on the training set.\nIn Table 4, we compare BasicILS against RandomSearch for our BROAD configuration scenarios. On average, BasicILS always performed better, and in three of the five scenarios, the difference was statistically significant as judged by a paired Max-Wilcoxon test (see Section 5.1.3). Table 4 also lists the performance of the default parameter configuration for each of the scenarios. We note that both BasicILS and RandomSearch consistently achieved substantial (and statistically significant) improvements over these default configurations.\nNext, we compared BasicILS against its second component, SimpleLS. This basic local search is identical to BasicILS, but stops at the first local minimum encountered. We used it in order to study whether local minima pose a problem for simple first improvement search. Table 5 shows that in the three configuration scenarios where BasicILS had time to perform multiple ILS iterations, its training set performance was statistically significantly better than that of SimpleLS. Thus, we conclude that the search space contains structure that can be exploited with a local search algorithm as well as local minima that can limit the performance of iterative improvement search."
    }, {
      "heading" : "6.3 Empirical Comparison of FocusedILS and BasicILS",
      "text" : "In this section we investigate FocusedILS’s performance experimentally. In contrast to our previous comparison of RandomSearch, SimpleLS, and BasicILS using training performance, we now compare FocusedILS against BasicILS using test performance. This is because—in contrast to BasicILS and SimpleLS—FocusedILS grows the number of target algorithm runs used to evaluate a parameter configuration over time. Even different runs of FocusedILS (using different training sets and random seeds) do not use the same number of target algorithm runs to evaluate parameter configurations. However, they all eventually aim to optimize the same cost statistic, c, and therefore test set performance (an unbiased estimator of c) provides a fairer basis for comparison than training performance. We only compare FocusedILS to BasicILS, since BasicILS already outperformed RandomSearch and SimpleLS in Section 6.2.\nFigure 3 compares the test performance of FocusedILS and BasicILS(N ) with N = 1, 10 and 100. Using a single target algorithm run to evaluate each parameter configuration, BasicILS(1) was fast, but did not generalize well to the test set at all. For example, in configuration scenario SAPS-SWGCP, BasicILS(1) selected a parameter configuration whose test performance turned out to be even worse than the default. On the other hand, using a large number of target algorithm runs for each evaluation resulted in a very slow search, but eventually led to parameter configurations with good test performance. FocusedILS aims to achieve a fast search and good generalization to the test set. For the configuration scenarios in Figure 3, FocusedILS started quickly and also led to the best final performance.\nWe compare the performance of FocusedILS and BasicILS(100) for all configuration scenarios in Table 6. For three SAPS and CPLEX scenarios, FocusedILS performed statistically significantly better than BasicILS(100). These results are consistent with our past work in which FocusedILS achieved statistically significantly better performance than BasicILS(100) (Hutter et al., 2007). However, we found that in both configuration scenarios involving the SPEAR algorithm, BasicILS(100) actually performed better on average than FocusedILS, albeit not statistically significantly. We attribute this to the fact that for a complete, industrial solver such as SPEAR, the two benchmark distributions QCP and SWGCP are quite heterogeneous. We expect FocusedILS to have problems in dealing with highly heterogeneous distributions, due to the fact that it frequently tries to extrapolate performance based on a few runs per parameter configuration."
    }, {
      "heading" : "6.4 Empirical Evaluation of Adaptive Capping in BasicILS and FocusedILS",
      "text" : "We now present experimental evidence that the use of adaptive capping has a strong impact on the performance of BasicILS and FocusedILS.\nFigure 4 illustrates the extent to which TP capping sped up BasicILS for two configuration scenarios. In both cases, capping helped to improve training performance substantially; for SAPS-SWGCP, BasicILS found the same solutions up to about an order of magnitude faster than without capping. Table 7 quantifies the speedups for all five BROAD configuration scenarios. TP capping enabled up to four times as many ILS iterations (in SAPS-SWGCP) and improved average performance in all scenarios. The improvement was statistically significant in all scenarios, except SPEAR-QCP.\nAggressive capping further improved BasicILS performance for one scenario. For scenario SAPS-SWGCP, it increased the number of ILS iterations completed within the configuration time from 12 to 219, leading to a significant improvement in performance. In the first ILS iteration of BasicILS, both capping techniques are identical (the best configuration in that iteration is always the incumbent). Thus, we did not observe a difference on configuration scenarios SPEAR-SWGCP and CPLEX-REGIONS100, for which none of the 25 runs of the configurator finished its first ILS iteration. For the remaining two configuration scenarios, the differences were insignificant.\nWe now evaluate the usefulness of capping for FocusedILS. Training performance is not a useful quantity in the context of comparing different versions of FocusedILS, since the number of target algorithm runs this measure is based on varies widely between runs of the configurator. Instead, we used two other measures to quantify search progress: the number of ILS iterations performed and the number of target algorithm runs performed for the incumbent parameter configuration. Table 8 shows these two measures for our five BROAD configuration scenarios and the three capping schemes (none, TP, Aggr). FocusedILS with TP capping achieved higher values than without capping for all scenarios and both measures (although only some of the differences were statistically significant). Aggressive capping increased both measures further for all scenarios, and most of the differences between no capping and aggressive capping were statistically significant. Figure 5 demonstrates that for two configuration scenarios FocusedILS with capping reached the same solution qualities more quickly than without capping. However, after finding the respective configurations, FocusedILS showed no further significant improvement.\nRecall that the experiments in Section 6.2 and 6.3 compared our various configurators without adaptive capping. One might wonder how these comparisons change in the presence of adaptive capping. Indeed, adaptive capping also worked “out of the box” for RandomSearch and enabled it to evaluate between 3.4 and 33 times as many configurations than without capping. This improvement significantly improved the simple algorithm RandomSearch to the point where its average performance came within 1% of the one of BasicILS for two domains (SAPS-SWGCP and SPEAR-SWGCP; compare the much larger differences without capping reported in Table 4). For SPEAR-QCP, there was still a 25% difference in average performance, but this result was not significant. Finally, for SAPS-QCP and CPLEX-REGIONS100 the difference was still substantial and significant (22% and 55% difference in average performance, with p-values 5.2 · 10−5 and 0.0013, respectively).\nAdaptive capping also reduced the gap between BasicILS and FocusedILS. In particular, for SAPS-SWGCP, where, even without adaptive capping, FocusedILS achieved the best performance we have encountered for this scenario, BasicILS caught up when using adaptive capping. Similarly,\nfor CPLEX-REGIONS100, FocusedILS already performed very well without adaptive capping while BasicILS did not. Here, BasicILS improved based on adaptive capping, but still could not rival FocusedILS. For the other scenarios, adaptive capping did not affect the relative performance much; compare Tables 6 (without capping) and 3 (with capping) for details."
    }, {
      "heading" : "7. Case Study: Configuring CPLEX for Real-World Benchmarks",
      "text" : "In this section, we demonstrate that ParamILS can improve the performance of the commercial optimization tool CPLEX for a variety of interesting benchmark distributions. To our best knowledge, this is the first published study on automatically configuring CPLEX.\nWe use five CPLEX configuration scenarios. For these, we collected a wide range of MIP benchmarks from public benchmark libraries and other researchers, and split each of them 50:50 into disjoint training and test sets; we detail them in the following.\n• Regions200 This set is almost identical to the Regions100 set (described in Section 5.2.2 and used throughout the paper), but its instances are much larger. We generated 2 000 MILP instances with the generator provided with the Combinatorial Auction Test Suite (LeytonBrown et al., 2000), based on the regions option with the goods parameter set to 200 and the bids parameter set to 1 000. These instances contain an average of 1 002 variables and 385 inequalities, with respective standard deviations of 1.7 and 3.4.\n• MJA This set comprises 343 machine-job assignment instances encoded as mixed integer quadratically constrained programs (MIQCP). It was obtained from the Berkeley Computational Optimization Lab5 and was introduced by Aktürk, Atamtürk and S. Gürel (2007). These instances contain an average of 2 769 variables and 2 255 constraints, with respective standard deviations of 2 133 and 1 592.\n5. http://www.ieor.berkeley.edu/˜atamturk/bcol/, where this set is called conic.sch\n• CLS This set comprises 100 capacitated lot-sizing instances encoded as mixed integer linear programs (MILP). It was also obtained from the Berkeley Computational Optimization Lab and was introduced by Atamtürk and Muñoz (2004). All 100 instances contain 181 variables and 180 constraints.\n• MIK This set of 120 MILP-encoded mixed-integer knapsack instances was also obtained from the Berkeley Computational Optimization Lab and was originally introduced by Atamtürk (2003). These instances contain an average of 384 variables and 151 constraints, with respective standard deviations of 309 and 127.\n• QP This set of quadratic programs originated from RNA energy parameter optimization (Andronescu, Condon, Hoos, Mathews & Murphy, 2007). Mirela Andronescu generated 2 000 instances for our experiments. These instances contain 9 366±7 165 variables and 9 191±7 186 constraints. Since the instances are polynomial-time solvable quadratic programs, we set a large number of inconsequential CPLEX parameters concerning the branch and cut mechanism to their default values, ending up with 27 categorical, 2 integer and 2 continuous parameters to be configured, for a discretized parameter configuration space of size 3.27× 1017.\nTo study ParamILS’s behavior for these harder problems, we set significantly longer cutoff times for these CPLEX scenarios than for the BROAD scenarios from the previous section. Specifically, we used a cutoff time of 300 CPU seconds for each run of the target algorithm during training, and allotted two CPU days for every run of each of the configurators. As always, our configuration objective was to minimize penalized average runtime with a penalization constant of 10.\nIn Table 9, we compare the performance of CPLEX’s default parameter configuration with the final parameter configurations found by BasicILS(100) and FocusedILS (both with aggressive capping and bm = 2). Note that, similar to the situation described in Section 6.1, in some configuration scenarios (e.g., CPLEX-CLS, CPLEX-MIK) there was substantial variance between the different runs of the configurators, and the run with the best training performance yielded a parameter configuration that was also very good on the test set. While BasicILS outperformed FocusedILS in 3 of these 5 scenarios in terms of mean test performance across the ten runs, FocusedILS achieved the better test performance for the run with the best training performance for all but one scenario (in which it performed almost as well). For scenarios CPLEX-REGIONS200 and CPLEX-CLS, FocusedILS performed substantially better than BasicILS.\nNote that in all CPLEX configuration scenarios we considered, both BasicILS and FocusedILS found parameter configurations that were better than the algorithm defaults, sometimes by over an order of magnitude. This is particularly noteworthy since ILOG expended substantial effort to determine strong default CPLEX parameters. In Figure 6, we provide scatter plots for all five scenarios. For CPLEX-REGIONS200, CPLEX-CONIC.SCH, CPLEX-CLS, and CPLEX-MIK, speedups were quite consistent across instances (with average speedup factors reaching from 2 for CPLEX-CONIC.SCH to 23 for CPLEX-MIK). Finally, for CPLEX-QP we see an interesting failure mode of ParamILS. The optimized parameter configuration achieved good performance with the cutoff time used for the\n6. For configuration scenario CPLEX-MIK, nine out of ten runs of FocusedILS yielded parameter configurations with average runtimes smaller than two seconds. One run, however, demonstrated an interesting failure mode of FocusedILS with aggressive capping. Capping too aggressively caused every CPLEX run to be unsuccessful, such that FocusedILS selected a configuration which did not manage to solve a single instance in the test set. Counting unsuccessful runs as ten times the cutoff time, this resulted in an average runtime of 10 · 300 = 3000 seconds for this run. (For full details, see Section 8.1 of Hutter, 2009).\nconfiguration process (300 CPU seconds, see Figure 6(f)), but this performance did not carry over to the higher cutoff time we used in our tests (3600 CPU seconds, see Figure 6(e)). Thus, the parameter configuration found by FocusedILS did generalize well to previously unseen test data, but not to larger cutoff times."
    }, {
      "heading" : "8. Review of Other ParamILS Applications",
      "text" : "In this section, we review a number of other applications of ParamILS—some of them dating back to earlier stages of its development, others very recent—that demonstrate its utility and versatility.\n8.1 Configuration of SAPS, GLS+ and SAT4J\nHutter et al. (2007), in the first publication on ParamILS, reported experiments on three target algorithms to demonstrate the effectiveness of the approach: the SAT algorithm SAPS (which has 4 numerical parameters), the local search algorithm GLS+ for solving the most probable explanation (MPE) problem in Bayesian networks (which has 5 numerical parameters; Hutter, Hoos & Stützle, 2005), and the tree search SAT solver SAT4J (which has 4 categorical and 7 numerical parameters; http://www.sat4j.org). They compared the respective algorithm’s default performance, the performance of the CALIBRA system (Adenso-Diaz & Laguna, 2006), and the performance of BasicILS and FocusedILS. Out of the four configuration scenarios studied, FocusedILS significantly outperformed CALIBRA on two and performed better on average on the third. For the fourth one (configuring SAT4J), CALIBRA was not applicable due to the categorical parameters, while FocusedILS significantly outperformed BasicILS.\nOverall, automated parameter optimization using ParamILS achieved substantial improvements over the previous default settings: GLS+ was sped up by a factor > 360 (tuned parameters found solutions of better quality in 10 seconds than the default found in one hour), SAPS by factors of 8 and 130 on SAPS-QWH and SAPS-SW, respectively, and SAT4J by a factor of 11."
    }, {
      "heading" : "8.2 Configuration of Spear for Industrial Verification Problems",
      "text" : "Hutter et al. (2007) applied ParamILS to a specific “real-world” application domain: configuring the 26 parameters of the tree-search DPLL solver SPEAR to minimize its mean runtime on a set of practical verification instances. In particular, they considered two sets of industrial problem instances, bounded model-checking (BMC) instances from Zarpas (2005) and software verification (SWV) instances generated by the CALYSTO static checker (Babić & Hu, 2007).\nThe instances from both problem distributions exhibited a large spread in hardness for SPEAR. For the SWV instances, the default configuration solved many instances in milliseconds but failed to solve others in days. This was despite the fact that SPEAR was specifically developed for this type of instances, that its developer had generated the problem instances himself (and thus had intimate domain knowledge), and that a week of manual performance tuning had been expended in order to optimize the solver’s performance.\nSPEAR was first configured for good general performance on industrial SAT instances from previous SAT competitions. This already led to substantial improvements over the default perfor-\nmance in the 2007 SAT competition.7 While the SPEAR default solved 82 instances and ranked 17th in the first round of the competition, an automatically configured version solved 93 instances and ranked 8th, and a further optimized version solved 99 instances, ranking 5th (above MiniSAT). The speedup factors due to this general optimization were 20 and 1.3 on the SWV and BMC datasets, respectively.\nOptimizing on the specific instance sets yielded further, and much larger improvements (a factor of over 500 for SWV and 4.5 for BMC). Most encouragingly, the best parameter configuration found for the software verification instances did not take longer than 20 seconds to solve any of the SWV problem instances (compared to multiple timeouts after a CPU day for the original default values).\nKey to good performance in that application was to perform multiple independent runs of FocusedILS, and to select the found configuration with best training performance (as also done in Sections 6.1 and 7 of this article)."
    }, {
      "heading" : "8.3 Configuration of SATenstein",
      "text" : "KhudaBukhsh, Xu, Hoos and Leyton-Brown (2009 ) used ParamILS to perform automatic algorithm design in the context of stochastic local search algorithms for SAT. Specifically, they introduced a new framework for local search SAT solvers, called SATenstein, and used ParamILS to choose good instantiations of the framework for given instance distributions. SATenstein spans three broad categories of SLS-based SAT solvers: WalkSAT-based algorithms, dynamic local search algorithms and G2WSAT variants. All of these are combined in a highly parameterized framework solver with a total of 41 parameters and 4.82 · 1012 unique instantiations.\nFocusedILS was used to configure SATenstein on six different problem distributions, and the resulting solvers were compared to eleven state-of-the-art SLS-based SAT solvers. The results showed that the automatically configured versions of SATenstein outperformed all of the eleven state-of-the-art solvers in all six categories, sometimes by a large margin.\nThe SATENSTEIN work clearly demonstrated that automated algorithm configuration methods can be used to construct new algorithms by combining a wide range of components from existing algorithms in novel ways, and thereby go beyond simple “parameter tuning”. Due to the low level of manual work required by this approach, we believe this automated design of algorithms from components will become a mainstream technique in the development of algorithms for hard combinatorial problems.\nKey to the successful application of FocusedILS for configuring SATENSTEIN was the careful selection of homogeneous instance distributions, most instances of which could be solved within a comparably low cutoff time of 10 seconds per run. Again, the configuration with the best training quality was selected from ten parallel independent runs of FocusedILS per scenario."
    }, {
      "heading" : "8.4 Self-Configuration of ParamILS",
      "text" : "As a heuristic optimization procedure, ParamILS is itself controlled by a number of parameters: the number of random configurations, r, to be sampled at the beginning of search; the perturbation strength, s; and the probability of random restarts, prestart. Furthermore, our aggressive capping mechanism makes use of an additional parameter: the bound multiplier, bm. Throughout this article, we have used the manually-determined default values 〈r, s, prestart, bm〉 = 〈10, 3, 0.01, 2〉.\n7. See http://www.cril.univ-artois.fr/SAT07. SPEAR was not allowed to participate in the second round of this competition since its source code is not publicly available.\nIn recent work (see Section 8.2 of Hutter, 2009), we evaluated whether FocusedILS’s performance could be improved by using ParamILS to automatically find a better parameter configuration. In this self-configuration task, configuration scenarios play the role of instances, and the configurator to be optimized plays the role of the target algorithm. To avoid confusion, we refer to this configurator as the target configurator. Here, we set fairly short configuration times of one CPU hour for the target configurator. However, this was still significantly longer than the cutoff times we used in any of our other experiments, such that parallelization turned out to be crucial to finish the experiment in a reasonable amount of time. Because BasicILS is easier to parallelize than FocusedILS, we chose BasicILS(100) as the meta-configurator.\nAlthough the notion of having an algorithm configurator configure itself was intriguing, in this case, it turned out to only yield small improvements. Average performance improved for four out of the five scenarios and degraded for the remaining one. However, none of the differences was statistically significant."
    }, {
      "heading" : "8.5 Other Applications of ParamILS",
      "text" : "Thachuk, Shmygelska and Hoos (2007 ) used BasicILS in order to determine performance-optimizing parameter settings of a new replica-exchange Monte Carlo algorithm for protein folding in the 2DHP and 3D-HP models.8 Even though their algorithm has only four parameters (two categorical and two continuous), BasicILS achieved substantial performance improvements. While the manuallyselected configurations were biased in favour of either short or long protein sequences, BasicILS found a configuration which consistently yielded good mean runtimes for all types of sequences. On average, the speedup factor achieved was approximately 1.5, and for certain classes of protein sequences up to 3. While all manually-selected configurations performed worse than the previous state-of-the-art algorithm for this problem on some instances, the robust parameter configurations selected by BasicILS yielded uniformly better performance.\nIn very recent work, Fawcett, Hoos and Chiarandini (2009) used several variants of ParamILS (including a version that has been slightly extended beyond the ones presented here) to design a modular stochastic local search algorithm for the post-enrollment course timetabling problem. They followed a design approach that used automated algorithm configuration in order to explore a large design space of modular and highly parameterised stochastic local search algorithms. This quickly led to a solver that placed third in Track 2 of the 2nd International Timetabling Competition (ITC2007) and subsequently produced an improved solver that is shown to achieve consistently better performance than the top-ranked solver from the competition."
    }, {
      "heading" : "9. Related Work",
      "text" : "Many researchers before us have been dissatisfied with manual algorithm configuration, and various fields have developed their own approaches for automatic parameter tuning. We start this section with the most closely-related work—approaches that employ direct search to find good parameter configurations—and then describe other methods. Finally, we discuss work on related problems, such as finding the best parameter configuration or algorithm on a per-instance basis, and approaches that adapt their parameters during an algorithm’s execution (see also Hoos, 2008, for further related work on automated algorithm design).\n8. BasicILS was used, because FocusedILS had not yet been developed when that study was conducted."
    }, {
      "heading" : "9.1 Direct Search Methods for Algorithm Configuration",
      "text" : "Approaches for automated algorithm configuration go back to the early 1990s, when a number of systems were developed for adaptive problem solving. One of these systems is Composer (Gratch & Dejong, 1992), which performs a hill-climbing search in configuration space, taking moves if enough evidence has been gathered to render a neighbouring configuration statistically significantly better than the current configuration. Composer was successfully applied to improving the five parameters of an algorithm for scheduling communication between a collection of ground-based antennas and spacecrafts (Gratch & Chien, 1996).\nAround the same time, the MULTI-TAC system was introduced by Minton (1993, 1996). MULTITAC takes as input generic heuristics, a specific problem domain, and a distribution over problem instances. It adapts the generic heuristics to the problem domain and automatically generates domain-specific LISP programs implementing them. A beam search is then used to choose the best LISP program where each program is evaluated by running it on a fixed set of problem instances sampled from the given distribution.\nAnother search-based approach that uses a fixed training set was introduced by Coy et al. (2001). Their approach works in two stages. First, it finds a good parameter configuration θi for each instance Ii in the training set by a combination of experimental design (full factorial or fractional factorial) and gradient descent. Next, it combines the parameter configurations θ1, . . . ,θN thus determined by setting each parameter to the average of the values taken in all of them. Note that this averaging step restricts the applicability of the method to algorithms with only numerical parameters.\nA similar approach, also based on a combination of experimental design and gradient descent, using a fixed training set for evaluation, is implemented in the CALIBRA system of Adenso-Diaz and Laguna (2006). CALIBRA starts by evaluating each parameter configuration in a full factorial design with two values per parameter. It then iteratively homes in to good regions of parameter configuration space by employing fractional experimental designs that evaluate nine configurations around the best performing configuration found so far. The grid for the experimental design is refined in each iteration. Once a local optimum is found, the search is restarted (with a coarser grid). Experiments showed CALIBRA’s ability to find parameter settings for six target algorithms that matched or outperformed the respective originally-proposed parameter configurations. Its main drawback is the limitation to tuning numerical and ordinal parameters, and to a maximum of five parameters. When we first introduced ParamILS, we performed experiments comparing its performance against CALIBRA (Hutter et al., 2007). These experiments are reviewed in Section 8.1.\nTerashima-Marı́n et al. (1999) introduced a genetic algorithm for configuring a constraint satisfaction algorithm for large-scale university exam scheduling. They constructed and configured an algorithm that works in two stages and has seven configurable categorical parameters. They optimized these choices with a genetic algorithm for each of 12 problem instances, and for each of them found a configuration that improved performance over a modified Brelaz algorithm. However, note that they performed this optimization separately for each instance. Their paper did not quantify how long these optimizations took, but stated that “Issues about the time for delivering solutions with this method are still a matter of research”.\nWork on automated parameter tuning can also be found in the numerical optimization literature. In particular, Audet and Orban (2006) proposed the mesh adaptive direct search algorithm. Designed for purely continuous parameter configuration spaces, this algorithm is guaranteed to converge to a local optimum of the cost function. Parameter configurations were evaluated on a fixed\nset of large unconstrained regular problems from the CUTEr collection, using as optimization objectives runtime and number of function evaluations required for solving a given problem instance. Performance improvements of around 25% over the classical configuration of four continuous parameters of interior point methods were reported.\nAlgorithm configuration is a stochastic optimization problem, and there exists a large body of algorithms designed for such problems (see, e.g., Spall, 2003). However, many of the algorithms in the stochastic optimization literature require explicit gradient information and are thus inapplicable to algorithm configuration. Some algorithms approximate the gradient from function evaluations only (e.g., by finite differences), and provably converge to a local minimum of the cost function under mild conditions, such as continuity. Still, these methods are primarily designed to deal with numerical parameters and only find local minima. We are not aware of any applications of general purpose algorithms for stochastic optimization to algorithm configuration."
    }, {
      "heading" : "9.2 Other Methods for Algorithm Configuration",
      "text" : "Sequential parameter optimization (SPO) (Bartz-Beielstein, 2006) is a model-based parameter optimization approach based on the Design and Analysis of Computer Experiments (DACE; see, e.g., Santner, Williams & Notz, 2003), a prominent approach in statistics for blackbox function optimization. SPO starts by running the target algorithm with parameter configurations from a Latin hypercube design on a number of training instances. It then builds a response surface model based on Gaussian process regression and uses the model’s predictions and predictive uncertainties to determine the next parameter configuration to evaluate. The metric underlying the choice of promising parameter configurations is the expected improvement criterion used by Jones, Schonlau and Welch (1998). After each algorithm run, the response surface is refitted, and a new parameter configuration is determined based on the updated model. In contrast to the previously-mentioned methods, SPO does not use a fixed training set. Instead, it starts with a small training set and doubles its size whenever a parameter configuration is determined as incumbent that has already been incumbent in a previous iteration. A recent improved mechanism resulted in a more robust version, SPO+ (Hutter, Hoos, Leyton-Brown & Murphy, 2009). The main drawbacks of SPO and its variants, and in fact of the entire DACE approach, are its limitation to continuous parameters and to optimizing performance for single problem instances, as well as its cubic runtime scaling in the number of data points.\nAnother approach is based on adaptations of racing algorithms in machine learning (Maron & Moore, 1994) to the algorithm configuration problem. Birattari et al. (2002; 2004) developed a procedure dubbed F-Race and used it to configure various stochastic local search algorithms. F-Race takes as input an algorithm A, a finite set of algorithm configurations Θ, and an instance distribution D. It iteratively runs the target algorithm with all “surviving” parameter configurations on a number of instances sampled from D (in the simplest case, each iteration runs all surviving configurations on one instance). A configuration is eliminated from the race as soon as enough statistical evidence is gathered against it. After each iteration, a non-parametric Friedman test is used to check whether there are significant differences among the configurations. If this is the case, the inferior configurations are eliminated using a series of pairwise tests. This process is iterated until only one configuration survives or a given cutoff time is reached. Various applications of F-Race have demonstrated very good performance (for an overview, see Birattari, 2004). However, since at the start of the procedure all candidate configurations are evaluated, this approach is limited to situations in which the space of candidate configurations can practically be enumerated. In fact, published ex-\nperiments with F-Race have been limited to applications with only around 1200 configurations. A recent extension presented by Balaprakash et al. (2007) iteratively performs F-Race on subsets of parameter configurations. This approach scales better to large configuration spaces, but the version described by Balaprakash et al. (2007) handles only algorithms with numerical parameters."
    }, {
      "heading" : "9.3 Related Algorithm Configuration Problems",
      "text" : "Up to this point, we have focused on the problem of finding the best algorithm configuration for an entire set (or distribution) of problem instances. Related approaches attempt to find the best configuration or algorithm on a per-instance basis, or to adapt algorithm parameters during the execution of an algorithm. Approaches for setting parameters on a per-instance basis have been described by Patterson and Kautz (2001), Cavazos and O’Boyle (2006), and Hutter et al. (2006). Furthermore, approaches that attempt to select the best algorithm on a per-instance basis have been studied by Leyton-Brown, Nudelman and Shoham (2002), Carchrae and Beck (2005), Gebruers, Hnich, Bridge and Freuder (2005), Gagliolo and Schmidhuber (2006), and Xu, Hutter, Hoos and Leyton-Brown (2008). In other related work, decisions about when to restart an algorithm are made online, during the run of an algorithm (Horvitz, Ruan, Gomes, Kautz, Selman & Chickering, 2001; Kautz, Horvitz, Ruan, Gomes & Selman, 2002; Gagliolo & Schmidhuber, 2007). So-called reactive search methods perform online parameter modifications (Battiti, Brunato & Mascia, 2008). This last strategy can be seen as complementary to our work: even reactive search methods tend to have parameters that remain fixed during the search and can hence be configured using offline approaches such as ParamILS."
    }, {
      "heading" : "9.4 Relation to Other Local Search Methods",
      "text" : "Since ParamILS performs an iterated local search with a one-exchange neighbourhood, it is very similar in spirit to local search methods for other problems, such as SAT (Selman, Levesque & Mitchell, 1992; Hoos & Stützle, 2005), CSP (Minton, Johnston, Philips & Laird, 1992), and MPE (Kask & Dechter, 1999; Hutter et al., 2005). Since ParamILS is a local search method, existing theoretical frameworks (see, e.g., Hoos, 2002; Mengshoel, 2008), could in principle be used for its analysis. The main factor distinguishing our problem from the ones faced by “standard” local search algorithms is the stochastic nature of our optimization problem (for a discussion of local search for stochastic optimization, see, e.g., Spall, 2003). Furthermore, there exists no compact representation of the objective function that could be used to guide the search. To illustrate this, consider local search for SAT, where the candidate variables to be flipped can be limited to those occurring in currently-unsatisfied clauses. In general algorithm configuration, on the other hand, such a mechanism cannot be used, because the only information available about the target algorithm is its performance in the runs executed so far. While, obviously, other (stochastic) local search methods could be used as the basis for algorithm configuration procedures, we chose iterated local search, mainly because of its conceptual simplicity and flexibility."
    }, {
      "heading" : "10. Discussion, Conclusions and Future work",
      "text" : "In this work, we studied the problem of automatically configuring the parameters of complex, heuristic algorithms in order to optimize performance on a given set of benchmark instances. We extended our earlier algorithm configuration procedure, ParamILS, with a new capping mechanism\nand obtained excellent results when applying the resulting enhanced version of ParamILS to two high-performance SAT algorithms as well as to CPLEX and a wide range of benchmark sets.\nCompared to the carefully-chosen default configurations of these target algorithms, the parameter configurations found by ParamILS almost always performed much better when evaluated on sets of previously unseen test instances, for some configuration scenarios by as much as two orders of magnitude. The improvements over CPLEX’s default parameter configuration are particularly noteworthy, though we do not claim to have found a new parameter configuration for CPLEX that is uniformly better than its default. Rather, given a somewhat homogeneous instance set, we find a configuration specific to that set that typically outperforms the default, sometimes by a factor as high as 20. Note that we achieved these results even though we are not intimately familiar with CPLEX and its parameters; we chose the parameters to optimize as well as the values to consider based on a single person-day of studying the CPLEX user manual. The success of automated algorithm configuration even under these extreme conditions demonstrates the potential of the approach.\nThe ParamILS source code and executable are freely available at http://www.cs.ubc.ca/labs/beta/Projects/ParamILS/,\nalong with a quickstart guide and data for the configuration scenarios studied in this article.9\nIn order to apply ParamILS, or other such automated algorithm configuration methods, a practitioner must supply the following ingredients.\n• A parameterized algorithm A It must be possible to set A’s configurable parameters externally, e.g., in a command line call. Often, a search for hard-coded parameters hidden in the algorithm’s source code can lead to a large number of additional parameters to be exposed. • Domains for the parameters Algorithm configurators must be provided with the allowable\nvalues for each parameter. Depending on the configurator, it may be possible to include additional knowledge about dependencies between parameters, such as the conditional parameters supported by ParamILS. For the use of ParamILS, numerical parameters must be discretized to a finite number of choices. Depending on the type of parameter, a uniform spacing of values or some other spacing, such as uniform on a log scale, is typically reasonable. • A set of problem instances The more homogeneous the problem set of interest is, the better\nwe can expect any algorithm configuration procedure to perform on it. While it is possible to configure an algorithm for good performance on rather heterogeneous instance sets (e.g., on industrial SAT instances, as we did with SPEAR as reported in Section 8.2), the results for homogeneous subsets of interest will improve when we configure on instances from that subset. Whenever possible, the set of instances should be split into disjoint training and test sets in order to safeguard against over-tuning. When configuring on a small and/or heterogeneous benchmark set, ParamILS (or any other configuration procedure) might not find configurations that perform well on an independent test set. • An objective function While we used median performance in our first study on ParamILS\n(Hutter et al., 2007), we have since found cases where optimizing median performance led to parameter configurations with good median but poor overall performance. In these cases, optimizing for mean performance yielded more robust parameter configurations. However, when optimizing mean performance one has to define the cost for unsuccessful runs. In this article, we have penalized such runs by counting them as ten times the cutoff time. How to deal with unsuccessful runs in a more principled manner is an open research question.\n9. ParamILS continues to be actively developed; it is currently maintained by Chris Fawcett.\n• A cutoff time for unsuccessful runs The smaller the cutoff time for each run of the target algorithm is chosen, the more quickly any configuration procedure will be able to explore the configuration space. However, choosing too small a cutoff risks the failure mode we experienced with our CPLEX-QP scenario. Recall that there, choosing 300 seconds as a timeout yielded a parameter configuration that was very good when judged with that cutoff time (see Figure 6(f)), but performed poorly for longer cutoffs (see Figure 6(e)). In all of our other experiments, parameter configurations performing well with low cutoff times turned out to scale well to harder problem instances as well. In many configuration scenarios, in fact, we noticed that our automatically-found parameter configurations showed much better scaling behaviour than the default configuration. We attribute this to our use of mean runtime as a configuration objective. The mean is often dominated by the hardest instances in a distribution. However, in manual tuning, algorithm developers typically pay more attention to easier instances, simply because repeated profiling on hard instances takes too long. In contrast, a “patient” automatic configurator can achieve better results because it avoids this bias.\n• Computational resources The amount of (computational) time required for the application of automated algorithm configuration clearly depends on the target application. If the target algorithm takes seconds to solve instances from a homogeneous benchmark set of interest, in our experience a single five-hour configuration run will suffice to yield good results and for some domains we have achieved good results with configuration times as short as half an hour. In contrast, if runs of the target algorithm are slow and only performance with a large cutoff time can be expected to yield good results on the instances of interest, then the time requirements of automated algorithm configuration grow. We also regularly perform multiple parallel configuration runs and pick the one with best training performance in order to deal with variance across configuration runs.\nOverall, we firmly believe that automated algorithm configuration methods such as ParamILS will play an increasingly prominent role in the development of high-performance algorithms and their applications. The study of such methods is a rich and fruitful research area with many interesting questions remaining to be explored.\nIn ongoing work, we are currently developing methods that adaptively adjust the domains of integer-valued and continuous parameters during the configuration process. Similarly, we plan to enhance ParamILS with dedicated methods for dealing with continuous parameters that do not require discretization by the user. Another direction for further development concerns the strategic selection of problem instances used during evaluation of configurations and of instance-specific cutoff times used in this context. By heuristically preventing the configuration procedure from spending inordinate amounts of time trying to evaluate poor parameter settings on very hard problem instances, it should be possible to improve its scalability.\nWe believe that there is significant room for combining aspects of the methods studied here with concepts from related work on this and similar algorithm configuration problems. In particular, we believe it would be fruitful to integrate statistical testing methods—as used, e.g., in F-Race— into ParamILS. Furthermore, we see much potential in the use of response surface models and active learning, and believe these can be combined with our approach. Finally, while the algorithm configuration problem studied in this article is of significant practical importance, there is also much to be gained from studying methods for related problems, in particular, instance-specific algorithm configuration and the online adjustment of parameters during the run of an algorithm."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We thank Kevin Murphy for many helpful discussions regarding this work. We also thank Domagoj Babić, the author of SPEAR, and Dave Tompkins, the author of the UBCSAT SAPS implementation we used in our experiments. We thank the researchers who provided the instances or instance generators used in our work, in particular Gent et al. (1999), Gomes and Selman (1997), LeytonBrown et al. (2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al. (2007), Atamtürk and Muñoz (2004), Atamtürk (2003), and Andronescu et al. (2007). Lin Xu created the specific sets of QCP and SWGCP instances we used. Thanks also to Chris Fawcett and Ashique KhudaBukhsh for their comments on a draft of this article. Finally, we thank the anonymous reviewers as well as Rina Dechter and Adele Howe for their valuable feedback. Thomas Stützle acknowledges support from the F.R.S.-FNRS, of which he is a Research Associate. Holger Hoos acknowledges support through NSERC Discovery Grant 238788."
    } ],
    "references" : [ {
      "title" : "Fine-tuning of algorithms using fractional experimental design and local search",
      "author" : [ "B. Adenso-Diaz", "M. Laguna" ],
      "venue" : "Operations Research,",
      "citeRegEx" : "Adenso.Diaz and Laguna,? \\Q2006\\E",
      "shortCiteRegEx" : "Adenso.Diaz and Laguna",
      "year" : 2006
    }, {
      "title" : "A strong conic quadratic reformulation for machine-job assignment with controllable processing times. Research Report BCOL.07.01, University of CaliforniaBerkeley",
      "author" : [ "S.M. Aktürk", "A. Atamtürk", "S. Gürel" ],
      "venue" : null,
      "citeRegEx" : "Aktürk et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Aktürk et al\\.",
      "year" : 2007
    }, {
      "title" : "Efficient parameter estimation for RNA secondary structure",
      "author" : [ "M. Andronescu", "A. Condon", "H.H. Hoos", "D.H. Mathews", "K.P. Murphy" ],
      "venue" : "prediction. Bioinformatics,",
      "citeRegEx" : "Andronescu et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Andronescu et al\\.",
      "year" : 2007
    }, {
      "title" : "On the facets of the mixed–integer knapsack polyhedron",
      "author" : [ "A. Atamtürk" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Atamtürk,? \\Q2003\\E",
      "shortCiteRegEx" : "Atamtürk",
      "year" : 2003
    }, {
      "title" : "A study of the lot-sizing polytope",
      "author" : [ "A. Atamtürk", "J.C. Muñoz" ],
      "venue" : "Mathematical Programming,",
      "citeRegEx" : "Atamtürk and Muñoz,? \\Q2004\\E",
      "shortCiteRegEx" : "Atamtürk and Muñoz",
      "year" : 2004
    }, {
      "title" : "Finding optimal algorithmic parameters using the mesh adaptive direct search algorithm",
      "author" : [ "C. Audet", "D. Orban" ],
      "venue" : "SIAM Journal on Optimization,",
      "citeRegEx" : "Audet and Orban,? \\Q2006\\E",
      "shortCiteRegEx" : "Audet and Orban",
      "year" : 2006
    }, {
      "title" : "Structural Abstraction of Software Verification Conditions",
      "author" : [ "D. Babić", "A.J. Hu" ],
      "venue" : "Computer Aided Verification: 19th International Conference, CAV 2007,",
      "citeRegEx" : "Babić and Hu,? \\Q2007\\E",
      "shortCiteRegEx" : "Babić and Hu",
      "year" : 2007
    }, {
      "title" : "Improvement strategies for the F-Race algorithm: Sampling design and iterative refinement",
      "author" : [ "P. Balaprakash", "M. Birattari", "T. Stützle" ],
      "venue" : "4th International Workshop on Hybrid Metaheuristics (MH’07),",
      "citeRegEx" : "Balaprakash et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Balaprakash et al\\.",
      "year" : 2007
    }, {
      "title" : "Experimental Research in Evolutionary Computation: The New Experimentalism",
      "author" : [ "T. Bartz-Beielstein" ],
      "venue" : "Natural Computing Series",
      "citeRegEx" : "Bartz.Beielstein,? \\Q2006\\E",
      "shortCiteRegEx" : "Bartz.Beielstein",
      "year" : 2006
    }, {
      "title" : "Reactive Search and Intelligent Optimization, volume 45 of Operations research/Computer Science Interfaces",
      "author" : [ "R. Battiti", "M. Brunato", "F. Mascia" ],
      "venue" : null,
      "citeRegEx" : "Battiti et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Battiti et al\\.",
      "year" : 2008
    }, {
      "title" : "The Problem of Tuning Metaheuristics as Seen from a Machine Learning Perspective",
      "author" : [ "M. Birattari" ],
      "venue" : "PhD thesis, Université Libre de Bruxelles,",
      "citeRegEx" : "Birattari,? \\Q2004\\E",
      "shortCiteRegEx" : "Birattari",
      "year" : 2004
    }, {
      "title" : "A racing algorithm for configuring metaheuristics",
      "author" : [ "M. Birattari", "T. Stützle", "L. Paquete", "K. Varrentrapp" ],
      "venue" : "Proceedings of the Genetic and Evolutionary Computation Conference (GECCO2002),",
      "citeRegEx" : "Birattari et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Birattari et al\\.",
      "year" : 2002
    }, {
      "title" : "Applying machine learning to low-knowledge control of optimization algorithms",
      "author" : [ "T. Carchrae", "J.C. Beck" ],
      "venue" : "Computational Intelligence,",
      "citeRegEx" : "Carchrae and Beck,? \\Q2005\\E",
      "shortCiteRegEx" : "Carchrae and Beck",
      "year" : 2005
    }, {
      "title" : "Method-specific dynamic compilation using logistic regression",
      "author" : [ "J. Cavazos", "M.F.P. O’Boyle" ],
      "venue" : "Proceedings of the ACM SIGPLAN International Conference on Object-Oriented Programming, Systems, Languages, and Applications",
      "citeRegEx" : "Cavazos and O.Boyle,? \\Q2006\\E",
      "shortCiteRegEx" : "Cavazos and O.Boyle",
      "year" : 2006
    }, {
      "title" : "Using experimental design to find effective parameter settings for heuristics",
      "author" : [ "S.P. Coy", "B.L. Golden", "G.C. Runger", "E.A. Wasil" ],
      "venue" : "Journal of Heuristics,",
      "citeRegEx" : "Coy et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Coy et al\\.",
      "year" : 2001
    }, {
      "title" : "Generic online optimization of multiple configuration parameters with application to a database server",
      "author" : [ "Y. Diao", "F. Eskesen", "S. Froehlich", "J.L. Hellerstein", "L. Spainhower", "M. Surendra" ],
      "venue" : "14th IFIP/IEEE International Workshop on Distributed Systems: Operations and Management (DSOM-03),",
      "citeRegEx" : "Diao et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Diao et al\\.",
      "year" : 2003
    }, {
      "title" : "An automatically configured modular algorithm for post enrollment course timetabling",
      "author" : [ "C. Fawcett", "H.H. Hoos", "M. Chiarandini" ],
      "venue" : "Technical Report TR-2009-15,",
      "citeRegEx" : "Fawcett et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Fawcett et al\\.",
      "year" : 2009
    }, {
      "title" : "Dynamic algorithm portfolios",
      "author" : [ "M. Gagliolo", "J. Schmidhuber" ],
      "venue" : "Ninth International Symposium on Artificial Intelligence and Mathematics (AI-MATH-06)",
      "citeRegEx" : "Gagliolo and Schmidhuber,? \\Q2006\\E",
      "shortCiteRegEx" : "Gagliolo and Schmidhuber",
      "year" : 2006
    }, {
      "title" : "Learning restart strategies",
      "author" : [ "M. Gagliolo", "J. Schmidhuber" ],
      "venue" : "Proceedings of the Twentieth International Joint Conference on Artificial Intelligence (IJCAI’07),",
      "citeRegEx" : "Gagliolo and Schmidhuber,? \\Q2007\\E",
      "shortCiteRegEx" : "Gagliolo and Schmidhuber",
      "year" : 2007
    }, {
      "title" : "Using CBR to select solution strategies in constraint programming",
      "author" : [ "C. Gebruers", "B. Hnich", "D. Bridge", "E. Freuder" ],
      "venue" : "Proceedings of the 6th International Conference on Case Based Reasoning (ICCBR’05),",
      "citeRegEx" : "Gebruers et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Gebruers et al\\.",
      "year" : 2005
    }, {
      "title" : "Morphing: Combining structure and randomness",
      "author" : [ "I.P. Gent", "H.H. Hoos", "P. Prosser", "T. Walsh" ],
      "venue" : "Proceedings of the Sixteenth National Conference on Artificial Intelligence (AAAI’99), (pp. 654–660).,",
      "citeRegEx" : "Gent et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Gent et al\\.",
      "year" : 1999
    }, {
      "title" : "Problem structure in the presence of perturbations",
      "author" : [ "C.P. Gomes", "B. Selman" ],
      "venue" : "Proceedings of the Fourteenth National Conference on Artificial Intelligence (AAAI’97),",
      "citeRegEx" : "Gomes and Selman,? \\Q1997\\E",
      "shortCiteRegEx" : "Gomes and Selman",
      "year" : 1997
    }, {
      "title" : "Adaptive problem-solving for large-scale scheduling problems: A case study",
      "author" : [ "J. Gratch", "S.A. Chien" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Gratch and Chien,? \\Q1996\\E",
      "shortCiteRegEx" : "Gratch and Chien",
      "year" : 1996
    }, {
      "title" : "Composer: A probabilistic solution to the utility problem in speed-up learning",
      "author" : [ "J. Gratch", "G. Dejong" ],
      "venue" : "Proceedings of the Tenth National Conference on Artificial Intelligence (AAAI’92),",
      "citeRegEx" : "Gratch and Dejong,? \\Q1992\\E",
      "shortCiteRegEx" : "Gratch and Dejong",
      "year" : 1992
    }, {
      "title" : "A mixture-model for the behaviour of SLS algorithms for SAT",
      "author" : [ "H.H. Hoos" ],
      "venue" : "In Proceedings of the Eighteenth National Conference on Artificial Intelligence",
      "citeRegEx" : "Hoos,? \\Q2002\\E",
      "shortCiteRegEx" : "Hoos",
      "year" : 2002
    }, {
      "title" : "Computer-aided design of high-performance algorithms",
      "author" : [ "H.H. Hoos" ],
      "venue" : "Technical Report TR-2008-16,",
      "citeRegEx" : "Hoos,? \\Q2008\\E",
      "shortCiteRegEx" : "Hoos",
      "year" : 2008
    }, {
      "title" : "Stochastic Local Search – Foundations & Applications",
      "author" : [ "H.H. Hoos", "T. Stützle" ],
      "venue" : null,
      "citeRegEx" : "Hoos and Stützle,? \\Q2005\\E",
      "shortCiteRegEx" : "Hoos and Stützle",
      "year" : 2005
    }, {
      "title" : "A Bayesian approach to tackling hard computational problems",
      "author" : [ "E. Horvitz", "Y. Ruan", "C.P. Gomes", "H. Kautz", "B. Selman", "D.M. Chickering" ],
      "venue" : "Proceedings of the Seventeenth Conference on Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Horvitz et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Horvitz et al\\.",
      "year" : 2001
    }, {
      "title" : "Automated Configuration of Algorithms for Solving Hard Computational Problems",
      "author" : [ "F. Hutter" ],
      "venue" : "PhD thesis,",
      "citeRegEx" : "Hutter,? \\Q2009\\E",
      "shortCiteRegEx" : "Hutter",
      "year" : 2009
    }, {
      "title" : "Boosting Verification by Automatic Tuning of Decision Procedures",
      "author" : [ "F. Hutter", "D. Babić", "H.H. Hoos", "A.J. Hu" ],
      "venue" : "In Proceedings of Formal Methods in Computer Aided Design (FMCAD’07),",
      "citeRegEx" : "Hutter et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Hutter et al\\.",
      "year" : 2007
    }, {
      "title" : "Performance prediction and automated tuning of randomized and parametric algorithms",
      "author" : [ "F. Hutter", "Y. Hamadi", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "Principles and Practice of Constraint Programming – CP 2006: Twelfth International Conference,",
      "citeRegEx" : "Hutter et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hutter et al\\.",
      "year" : 2006
    }, {
      "title" : "Tradeoffs in the empirical evaluation of competing algorithm designs",
      "author" : [ "F. Hutter", "H. Hoos", "K. Leyton-Brown" ],
      "venue" : "Technical Report TR-2009-21,",
      "citeRegEx" : "Hutter et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Hutter et al\\.",
      "year" : 2009
    }, {
      "title" : "An experimental investigation of model-based parameter optimisation: SPO and beyond",
      "author" : [ "F. Hutter", "H.H. Hoos", "K. Leyton-Brown", "K.P. Murphy" ],
      "venue" : "In Proceedings of the Genetic and Evolutionary Computation Conference (GECCO-2009),",
      "citeRegEx" : "Hutter et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Hutter et al\\.",
      "year" : 2009
    }, {
      "title" : "Efficient stochastic local search for MPE solving",
      "author" : [ "F. Hutter", "H.H. Hoos", "T. Stützle" ],
      "venue" : "In Proceedings of the Nineteenth International Joint Conference on Artificial Intelligence (IJCAI’05),",
      "citeRegEx" : "Hutter et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Hutter et al\\.",
      "year" : 2005
    }, {
      "title" : "Automatic algorithm configuration based on local search",
      "author" : [ "F. Hutter", "H.H. Hoos", "T. Stützle" ],
      "venue" : "Proceedings of the Twenty-second National Conference on Artificial Intelligence (AAAI’07),",
      "citeRegEx" : "Hutter et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Hutter et al\\.",
      "year" : 2007
    }, {
      "title" : "Scaling and probabilistic smoothing: Efficient dynamic local search for SAT",
      "author" : [ "F. Hutter", "D.A.D. Tompkins", "H.H. Hoos" ],
      "venue" : "Principles and Practice of Constraint Programming – CP 2002: Eighth International Conference,",
      "citeRegEx" : "Hutter et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Hutter et al\\.",
      "year" : 2002
    }, {
      "title" : "A theoretician’s guide to the experimental analysis of algorithms",
      "author" : [ "D.S. Johnson" ],
      "venue" : null,
      "citeRegEx" : "Johnson,? \\Q2002\\E",
      "shortCiteRegEx" : "Johnson",
      "year" : 2002
    }, {
      "title" : "Efficient global optimization of expensive black box functions",
      "author" : [ "D.R. Jones", "M. Schonlau", "W.J. Welch" ],
      "venue" : "Journal of Global Optimization,",
      "citeRegEx" : "Jones et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Jones et al\\.",
      "year" : 1998
    }, {
      "title" : "Stochastic local search for Bayesian networks",
      "author" : [ "K. Kask", "R. Dechter" ],
      "venue" : "In The Seventh International Workshop on Artificial Intelligence and Statistics (AISTATS’99)",
      "citeRegEx" : "Kask and Dechter,? \\Q1999\\E",
      "shortCiteRegEx" : "Kask and Dechter",
      "year" : 1999
    }, {
      "title" : "Dynamic restart policies",
      "author" : [ "H. Kautz", "E. Horvitz", "Y. Ruan", "C.P. Gomes", "B. Selman" ],
      "venue" : "Proceedings of the Eighteenth National Conference on Artificial Intelligence (AAAI’02),",
      "citeRegEx" : "Kautz et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Kautz et al\\.",
      "year" : 2002
    }, {
      "title" : "SATenstein: Automatically building local search sat solvers from components",
      "author" : [ "A. KhudaBukhsh", "L. Xu", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "In Proceedings of the Twenty-first International Joint Conference on Artificial Intelligence (IJCAI’09),",
      "citeRegEx" : "KhudaBukhsh et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "KhudaBukhsh et al\\.",
      "year" : 2009
    }, {
      "title" : "Fifty-five solvers in Vancouver: The SAT 2004 competition",
      "author" : [ "D. Le Berre", "L. Simon" ],
      "venue" : "Theory and Applications of Satisfiability Testing: Proceedings of the Seventh International Conference (SAT’04),",
      "citeRegEx" : "Berre and Simon,? \\Q2004\\E",
      "shortCiteRegEx" : "Berre and Simon",
      "year" : 2004
    }, {
      "title" : "Learning the empirical hardness of optimization problems: The case of combinatorial auctions",
      "author" : [ "K. Leyton-Brown", "E. Nudelman", "Y. Shoham" ],
      "venue" : "Principles and Practice of Constraint Programming – CP 2002: Eighth International Conference,",
      "citeRegEx" : "Leyton.Brown et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Leyton.Brown et al\\.",
      "year" : 2002
    }, {
      "title" : "Towards a universal test suite for combinatorial auction algorithms",
      "author" : [ "K. Leyton-Brown", "M. Pearson", "Y. Shoham" ],
      "venue" : null,
      "citeRegEx" : "Leyton.Brown et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Leyton.Brown et al\\.",
      "year" : 2000
    }, {
      "title" : "Iterated local search",
      "author" : [ "H.R. Lourenço", "O. Martin", "T. Stützle" ],
      "venue" : "Handbook of Metaheuristics (pp",
      "citeRegEx" : "Lourenço et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Lourenço et al\\.",
      "year" : 2002
    }, {
      "title" : "Hoeffding races: Accelerating model selection search for classification and function approximation",
      "author" : [ "O. Maron", "A. Moore" ],
      "venue" : "Advances in Neural Information Processing Systems 7 (NIPS-94),",
      "citeRegEx" : "Maron and Moore,? \\Q1994\\E",
      "shortCiteRegEx" : "Maron and Moore",
      "year" : 1994
    }, {
      "title" : "Understanding the role of noise in stochastic local search: Analysis and experiments",
      "author" : [ "O.J. Mengshoel" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Mengshoel,? \\Q2008\\E",
      "shortCiteRegEx" : "Mengshoel",
      "year" : 2008
    }, {
      "title" : "An analytic learning system for specializing heuristics",
      "author" : [ "S. Minton" ],
      "venue" : "Proceedings of the Thirteenth International Joint Conference on Artificial Intelligence (IJCAI’93),",
      "citeRegEx" : "Minton,? \\Q1993\\E",
      "shortCiteRegEx" : "Minton",
      "year" : 1993
    }, {
      "title" : "Automatically configuring constraint satisfaction programs: A case",
      "author" : [ "S. Minton" ],
      "venue" : "study. Constraints,",
      "citeRegEx" : "Minton,? \\Q1996\\E",
      "shortCiteRegEx" : "Minton",
      "year" : 1996
    }, {
      "title" : "Minimizing conflicts: A heuristic repair method for constraint-satisfaction and scheduling problems",
      "author" : [ "S. Minton", "M.D. Johnston", "A.B. Philips", "P. Laird" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Minton et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Minton et al\\.",
      "year" : 1992
    }, {
      "title" : "Auto-WalkSAT: a self-tuning implementation of WalkSAT",
      "author" : [ "D.J. Patterson", "H. Kautz" ],
      "venue" : "In Electronic Notes in Discrete Mathematics (ENDM),",
      "citeRegEx" : "Patterson and Kautz,? \\Q2001\\E",
      "shortCiteRegEx" : "Patterson and Kautz",
      "year" : 2001
    }, {
      "title" : "Sequential experiment designs for screening and tuning parameters of stochastic heuristics",
      "author" : [ "E. Ridge", "D. Kudenko" ],
      "venue" : "Workshop on Empirical Methods for the Analysis of Algorithms at the Ninth International Conference on Parallel Problem Solving from Nature (PPSN),",
      "citeRegEx" : "Ridge and Kudenko,? \\Q2006\\E",
      "shortCiteRegEx" : "Ridge and Kudenko",
      "year" : 2006
    }, {
      "title" : "The Design and Analysis of Computer Experiments",
      "author" : [ "T.J. Santner", "B.J. Williams", "W.I. Notz" ],
      "venue" : null,
      "citeRegEx" : "Santner et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Santner et al\\.",
      "year" : 2003
    }, {
      "title" : "A new method for solving hard satisfiability problems",
      "author" : [ "B. Selman", "H.J. Levesque", "D. Mitchell" ],
      "venue" : "Proceedings of the Tenth National Conference on Artificial Intelligence (AAAI’92),",
      "citeRegEx" : "Selman et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Selman et al\\.",
      "year" : 1992
    }, {
      "title" : "Introduction to Stochastic Search and Optimization",
      "author" : [ "J.C. Spall" ],
      "venue" : null,
      "citeRegEx" : "Spall,? \\Q2003\\E",
      "shortCiteRegEx" : "Spall",
      "year" : 2003
    }, {
      "title" : "Evolution of constraint satisfaction strategies in examination timetabling",
      "author" : [ "H. Terashima-Marı́n", "P. Ross", "M. Valenzuela-Réndon" ],
      "venue" : "In Proceedings of the Genetic and Evolutionary Computation Conference (GECCO-1999),",
      "citeRegEx" : "Terashima.Marı́n et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Terashima.Marı́n et al\\.",
      "year" : 1999
    }, {
      "title" : "A replica exchange monte carlo algorithm for protein folding in the hp model",
      "author" : [ "C. Thachuk", "A. Shmygelska", "H.H. Hoos" ],
      "venue" : "BMC Bioinformatics,",
      "citeRegEx" : "Thachuk et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Thachuk et al\\.",
      "year" : 2007
    }, {
      "title" : "UBCSAT: An implementation and experimentation environment for SLS algorithms for SAT & MAX-SAT",
      "author" : [ "D.A.D. Tompkins", "H.H. Hoos" ],
      "venue" : "In Theory and Applications of Satisfiability Testing: Proceedings of the Seventh International Conference (SAT’04),",
      "citeRegEx" : "Tompkins and Hoos,? \\Q2004\\E",
      "shortCiteRegEx" : "Tompkins and Hoos",
      "year" : 2004
    }, {
      "title" : "SATzilla: portfolio-based algorithm selection for SAT",
      "author" : [ "L. Xu", "F. Hutter", "H.H. Hoos", "K. Leyton-Brown" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Xu et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Xu et al\\.",
      "year" : 2008
    }, {
      "title" : "Benchmarking SAT Solvers for Bounded Model Checking",
      "author" : [ "E. Zarpas" ],
      "venue" : "Theory and Applications of Satisfiability Testing: Proceedings of the Eighth International Conference (SAT’05),",
      "citeRegEx" : "Zarpas,? \\Q2005\\E",
      "shortCiteRegEx" : "Zarpas",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 36,
      "context" : "There are many acknowledgements in the literature that finding performance-optimizing parameter configurations of heuristic algorithms often requires considerable effort (see, e.g., Gratch & Chien, 1996; Johnson, 2002; Diao, Eskesen, Froehlich, Hellerstein, Spainhower & Surendra, 2003; Birattari, 2004; Adenso-Diaz & Laguna, 2006).",
      "startOffset" : 170,
      "endOffset" : 331
    }, {
      "referenceID" : 10,
      "context" : "There are many acknowledgements in the literature that finding performance-optimizing parameter configurations of heuristic algorithms often requires considerable effort (see, e.g., Gratch & Chien, 1996; Johnson, 2002; Diao, Eskesen, Froehlich, Hellerstein, Spainhower & Surendra, 2003; Birattari, 2004; Adenso-Diaz & Laguna, 2006).",
      "startOffset" : 170,
      "endOffset" : 331
    }, {
      "referenceID" : 36,
      "context" : "• Empirical studies, evaluations, and comparisons of algorithms A central question in comparing heuristic algorithms is whether one algorithm outperforms another because it is fundamentally superior, or because its developers more successfully optimized its parameters (Johnson, 2002).",
      "startOffset" : 269,
      "endOffset" : 284
    }, {
      "referenceID" : 47,
      "context" : "Briefly, these include exhaustive enumeration, hill-climbing (Gratch & Dejong, 1992), beam search (Minton, 1993), genetic algorithms (Terashima-Marı́n, Ross & Valenzuela-Réndon, 1999), experimental design approaches (Coy, Golden, Runger & Wasil, 2001), sequential parameter optimization (Bartz-Beielstein, 2006), racing algorithms (Birattari, Stützle, Paquete & Varrentrapp, 2002; Birattari, 2004; Balaprakash, Birattari & Stützle, 2007), and combinations of fractional experimental design and local search (Adenso-Diaz & Laguna, 2006).",
      "startOffset" : 98,
      "endOffset" : 112
    }, {
      "referenceID" : 8,
      "context" : "Briefly, these include exhaustive enumeration, hill-climbing (Gratch & Dejong, 1992), beam search (Minton, 1993), genetic algorithms (Terashima-Marı́n, Ross & Valenzuela-Réndon, 1999), experimental design approaches (Coy, Golden, Runger & Wasil, 2001), sequential parameter optimization (Bartz-Beielstein, 2006), racing algorithms (Birattari, Stützle, Paquete & Varrentrapp, 2002; Birattari, 2004; Balaprakash, Birattari & Stützle, 2007), and combinations of fractional experimental design and local search (Adenso-Diaz & Laguna, 2006).",
      "startOffset" : 287,
      "endOffset" : 311
    }, {
      "referenceID" : 10,
      "context" : "Briefly, these include exhaustive enumeration, hill-climbing (Gratch & Dejong, 1992), beam search (Minton, 1993), genetic algorithms (Terashima-Marı́n, Ross & Valenzuela-Réndon, 1999), experimental design approaches (Coy, Golden, Runger & Wasil, 2001), sequential parameter optimization (Bartz-Beielstein, 2006), racing algorithms (Birattari, Stützle, Paquete & Varrentrapp, 2002; Birattari, 2004; Balaprakash, Birattari & Stützle, 2007), and combinations of fractional experimental design and local search (Adenso-Diaz & Laguna, 2006).",
      "startOffset" : 331,
      "endOffset" : 437
    }, {
      "referenceID" : 24,
      "context" : "Hutter, Hoos and Leyton-Brown (2009) considered this design space in detail, focusing on the tradeoff between the (fixed) number of problem instances to be used for the evaluation of each parameter configuration and the (fixed) cutoff time used for each run, as well as the interaction of these choices with the number of configurations that can be considered.",
      "startOffset" : 8,
      "endOffset" : 37
    }, {
      "referenceID" : 14,
      "context" : "Like many other related approaches (see, e.g., Minton, 1996; Coy et al., 2001; Adenso-Diaz & Laguna, 2006), it deals with the stochastic part of the optimisation problem by using an estimate based on a fixed training set of N instances.",
      "startOffset" : 35,
      "endOffset" : 106
    }, {
      "referenceID" : 29,
      "context" : "Indeed, in our past work we explored several of them: maximizing solution quality achieved in a given time, minimizing the runtime required to reach a given solution quality, and minimizing the runtime required to solve a single problem instance (Hutter et al., 2007).",
      "startOffset" : 246,
      "endOffset" : 267
    }, {
      "referenceID" : 21,
      "context" : "We generated these QCP instances around the solubility phase transition, using the parameters given by Gomes and Selman (1997). Specifically, the order n was drawn uniformly from the interval [26, 43], and the number of holes H (open entries in the Latin square) was drawn uniformly from [1.",
      "startOffset" : 103,
      "endOffset" : 127
    }, {
      "referenceID" : 20,
      "context" : "SW-GCP Our second benchmark set contained 20 000 instances of the graph colouring problem (GCP) based on the small world (SW) graphs of Gent et al. (1999). Of these, we sampled 2000 instances uniformly at random for use with SPEAR; these had on average 1813 variables (standard deviation: 703) and 13 902 clauses (standard deviation: 5393), and 1109 of them were satisfiable.",
      "startOffset" : 136,
      "endOffset" : 155
    }, {
      "referenceID" : 43,
      "context" : "We used the regions generator from the Combinatorial Auction Test Suite (Leyton-Brown et al., 2000), with the goods parameter set to 100 and the bids parameter set to 500.",
      "startOffset" : 72,
      "endOffset" : 99
    }, {
      "referenceID" : 29,
      "context" : "These results are consistent with our past work in which FocusedILS achieved statistically significantly better performance than BasicILS(100) (Hutter et al., 2007).",
      "startOffset" : 143,
      "endOffset" : 164
    }, {
      "referenceID" : 3,
      "context" : "It was obtained from the Berkeley Computational Optimization Lab5 and was introduced by Aktürk, Atamtürk and S. Gürel (2007). These instances contain an average of 2 769 variables and 2 255 constraints, with respective standard deviations of 2 133 and 1 592.",
      "startOffset" : 96,
      "endOffset" : 125
    }, {
      "referenceID" : 3,
      "context" : "It was also obtained from the Berkeley Computational Optimization Lab and was introduced by Atamtürk and Muñoz (2004). All 100 instances contain 181 variables and 180 constraints.",
      "startOffset" : 92,
      "endOffset" : 118
    }, {
      "referenceID" : 3,
      "context" : "• MIK This set of 120 MILP-encoded mixed-integer knapsack instances was also obtained from the Berkeley Computational Optimization Lab and was originally introduced by Atamtürk (2003). These instances contain an average of 384 variables and 151 constraints, with respective standard deviations of 309 and 127.",
      "startOffset" : 168,
      "endOffset" : 184
    }, {
      "referenceID" : 24,
      "context" : "Thachuk, Shmygelska and Hoos (2007 ) used BasicILS in order to determine performance-optimizing parameter settings of a new replica-exchange Monte Carlo algorithm for protein folding in the 2DHP and 3D-HP models.8 Even though their algorithm has only four parameters (two categorical and two continuous), BasicILS achieved substantial performance improvements. While the manuallyselected configurations were biased in favour of either short or long protein sequences, BasicILS found a configuration which consistently yielded good mean runtimes for all types of sequences. On average, the speedup factor achieved was approximately 1.5, and for certain classes of protein sequences up to 3. While all manually-selected configurations performed worse than the previous state-of-the-art algorithm for this problem on some instances, the robust parameter configurations selected by BasicILS yielded uniformly better performance. In very recent work, Fawcett, Hoos and Chiarandini (2009) used several variants of ParamILS (including a version that has been slightly extended beyond the ones presented here) to design a modular stochastic local search algorithm for the post-enrollment course timetabling problem.",
      "startOffset" : 24,
      "endOffset" : 983
    }, {
      "referenceID" : 29,
      "context" : "When we first introduced ParamILS, we performed experiments comparing its performance against CALIBRA (Hutter et al., 2007).",
      "startOffset" : 102,
      "endOffset" : 123
    }, {
      "referenceID" : 12,
      "context" : "Another search-based approach that uses a fixed training set was introduced by Coy et al. (2001). Their approach works in two stages.",
      "startOffset" : 79,
      "endOffset" : 97
    }, {
      "referenceID" : 0,
      "context" : "A similar approach, also based on a combination of experimental design and gradient descent, using a fixed training set for evaluation, is implemented in the CALIBRA system of Adenso-Diaz and Laguna (2006). CALIBRA starts by evaluating each parameter configuration in a full factorial design with two values per parameter.",
      "startOffset" : 176,
      "endOffset" : 206
    }, {
      "referenceID" : 0,
      "context" : "A similar approach, also based on a combination of experimental design and gradient descent, using a fixed training set for evaluation, is implemented in the CALIBRA system of Adenso-Diaz and Laguna (2006). CALIBRA starts by evaluating each parameter configuration in a full factorial design with two values per parameter. It then iteratively homes in to good regions of parameter configuration space by employing fractional experimental designs that evaluate nine configurations around the best performing configuration found so far. The grid for the experimental design is refined in each iteration. Once a local optimum is found, the search is restarted (with a coarser grid). Experiments showed CALIBRA’s ability to find parameter settings for six target algorithms that matched or outperformed the respective originally-proposed parameter configurations. Its main drawback is the limitation to tuning numerical and ordinal parameters, and to a maximum of five parameters. When we first introduced ParamILS, we performed experiments comparing its performance against CALIBRA (Hutter et al., 2007). These experiments are reviewed in Section 8.1. Terashima-Marı́n et al. (1999) introduced a genetic algorithm for configuring a constraint satisfaction algorithm for large-scale university exam scheduling.",
      "startOffset" : 176,
      "endOffset" : 1180
    }, {
      "referenceID" : 0,
      "context" : "A similar approach, also based on a combination of experimental design and gradient descent, using a fixed training set for evaluation, is implemented in the CALIBRA system of Adenso-Diaz and Laguna (2006). CALIBRA starts by evaluating each parameter configuration in a full factorial design with two values per parameter. It then iteratively homes in to good regions of parameter configuration space by employing fractional experimental designs that evaluate nine configurations around the best performing configuration found so far. The grid for the experimental design is refined in each iteration. Once a local optimum is found, the search is restarted (with a coarser grid). Experiments showed CALIBRA’s ability to find parameter settings for six target algorithms that matched or outperformed the respective originally-proposed parameter configurations. Its main drawback is the limitation to tuning numerical and ordinal parameters, and to a maximum of five parameters. When we first introduced ParamILS, we performed experiments comparing its performance against CALIBRA (Hutter et al., 2007). These experiments are reviewed in Section 8.1. Terashima-Marı́n et al. (1999) introduced a genetic algorithm for configuring a constraint satisfaction algorithm for large-scale university exam scheduling. They constructed and configured an algorithm that works in two stages and has seven configurable categorical parameters. They optimized these choices with a genetic algorithm for each of 12 problem instances, and for each of them found a configuration that improved performance over a modified Brelaz algorithm. However, note that they performed this optimization separately for each instance. Their paper did not quantify how long these optimizations took, but stated that “Issues about the time for delivering solutions with this method are still a matter of research”. Work on automated parameter tuning can also be found in the numerical optimization literature. In particular, Audet and Orban (2006) proposed the mesh adaptive direct search algorithm.",
      "startOffset" : 176,
      "endOffset" : 2012
    }, {
      "referenceID" : 8,
      "context" : "Sequential parameter optimization (SPO) (Bartz-Beielstein, 2006) is a model-based parameter optimization approach based on the Design and Analysis of Computer Experiments (DACE; see, e.",
      "startOffset" : 40,
      "endOffset" : 64
    }, {
      "referenceID" : 8,
      "context" : "Sequential parameter optimization (SPO) (Bartz-Beielstein, 2006) is a model-based parameter optimization approach based on the Design and Analysis of Computer Experiments (DACE; see, e.g., Santner, Williams & Notz, 2003), a prominent approach in statistics for blackbox function optimization. SPO starts by running the target algorithm with parameter configurations from a Latin hypercube design on a number of training instances. It then builds a response surface model based on Gaussian process regression and uses the model’s predictions and predictive uncertainties to determine the next parameter configuration to evaluate. The metric underlying the choice of promising parameter configurations is the expected improvement criterion used by Jones, Schonlau and Welch (1998). After each algorithm run, the response surface is refitted, and a new parameter configuration is determined based on the updated model.",
      "startOffset" : 41,
      "endOffset" : 779
    }, {
      "referenceID" : 7,
      "context" : "A recent extension presented by Balaprakash et al. (2007) iteratively performs F-Race on subsets of parameter configurations.",
      "startOffset" : 32,
      "endOffset" : 58
    }, {
      "referenceID" : 7,
      "context" : "A recent extension presented by Balaprakash et al. (2007) iteratively performs F-Race on subsets of parameter configurations. This approach scales better to large configuration spaces, but the version described by Balaprakash et al. (2007) handles only algorithms with numerical parameters.",
      "startOffset" : 32,
      "endOffset" : 240
    }, {
      "referenceID" : 36,
      "context" : "Approaches for setting parameters on a per-instance basis have been described by Patterson and Kautz (2001), Cavazos and O’Boyle (2006), and Hutter et al.",
      "startOffset" : 81,
      "endOffset" : 108
    }, {
      "referenceID" : 12,
      "context" : "Approaches for setting parameters on a per-instance basis have been described by Patterson and Kautz (2001), Cavazos and O’Boyle (2006), and Hutter et al.",
      "startOffset" : 109,
      "endOffset" : 136
    }, {
      "referenceID" : 12,
      "context" : "Approaches for setting parameters on a per-instance basis have been described by Patterson and Kautz (2001), Cavazos and O’Boyle (2006), and Hutter et al. (2006). Furthermore, approaches that attempt to select the best algorithm on a per-instance basis have been studied by Leyton-Brown, Nudelman and Shoham (2002), Carchrae and Beck (2005), Gebruers, Hnich, Bridge and Freuder (2005), Gagliolo and Schmidhuber (2006), and Xu, Hutter, Hoos and Leyton-Brown (2008).",
      "startOffset" : 109,
      "endOffset" : 162
    }, {
      "referenceID" : 12,
      "context" : "Approaches for setting parameters on a per-instance basis have been described by Patterson and Kautz (2001), Cavazos and O’Boyle (2006), and Hutter et al. (2006). Furthermore, approaches that attempt to select the best algorithm on a per-instance basis have been studied by Leyton-Brown, Nudelman and Shoham (2002), Carchrae and Beck (2005), Gebruers, Hnich, Bridge and Freuder (2005), Gagliolo and Schmidhuber (2006), and Xu, Hutter, Hoos and Leyton-Brown (2008).",
      "startOffset" : 109,
      "endOffset" : 315
    }, {
      "referenceID" : 12,
      "context" : "Furthermore, approaches that attempt to select the best algorithm on a per-instance basis have been studied by Leyton-Brown, Nudelman and Shoham (2002), Carchrae and Beck (2005), Gebruers, Hnich, Bridge and Freuder (2005), Gagliolo and Schmidhuber (2006), and Xu, Hutter, Hoos and Leyton-Brown (2008).",
      "startOffset" : 153,
      "endOffset" : 178
    }, {
      "referenceID" : 12,
      "context" : "Furthermore, approaches that attempt to select the best algorithm on a per-instance basis have been studied by Leyton-Brown, Nudelman and Shoham (2002), Carchrae and Beck (2005), Gebruers, Hnich, Bridge and Freuder (2005), Gagliolo and Schmidhuber (2006), and Xu, Hutter, Hoos and Leyton-Brown (2008).",
      "startOffset" : 153,
      "endOffset" : 222
    }, {
      "referenceID" : 12,
      "context" : "Furthermore, approaches that attempt to select the best algorithm on a per-instance basis have been studied by Leyton-Brown, Nudelman and Shoham (2002), Carchrae and Beck (2005), Gebruers, Hnich, Bridge and Freuder (2005), Gagliolo and Schmidhuber (2006), and Xu, Hutter, Hoos and Leyton-Brown (2008).",
      "startOffset" : 153,
      "endOffset" : 255
    }, {
      "referenceID" : 12,
      "context" : "Furthermore, approaches that attempt to select the best algorithm on a per-instance basis have been studied by Leyton-Brown, Nudelman and Shoham (2002), Carchrae and Beck (2005), Gebruers, Hnich, Bridge and Freuder (2005), Gagliolo and Schmidhuber (2006), and Xu, Hutter, Hoos and Leyton-Brown (2008). In other related work, decisions about when to restart an algorithm are made online, during the run of an algorithm (Horvitz, Ruan, Gomes, Kautz, Selman & Chickering, 2001; Kautz, Horvitz, Ruan, Gomes & Selman, 2002; Gagliolo & Schmidhuber, 2007).",
      "startOffset" : 153,
      "endOffset" : 301
    }, {
      "referenceID" : 33,
      "context" : "Since ParamILS performs an iterated local search with a one-exchange neighbourhood, it is very similar in spirit to local search methods for other problems, such as SAT (Selman, Levesque & Mitchell, 1992; Hoos & Stützle, 2005), CSP (Minton, Johnston, Philips & Laird, 1992), and MPE (Kask & Dechter, 1999; Hutter et al., 2005).",
      "startOffset" : 283,
      "endOffset" : 326
    }, {
      "referenceID" : 46,
      "context" : "Since ParamILS is a local search method, existing theoretical frameworks (see, e.g., Hoos, 2002; Mengshoel, 2008), could in principle be used for its analysis.",
      "startOffset" : 73,
      "endOffset" : 113
    }, {
      "referenceID" : 29,
      "context" : "• An objective function While we used median performance in our first study on ParamILS (Hutter et al., 2007), we have since found cases where optimizing median performance led to parameter configurations with good median but poor overall performance.",
      "startOffset" : 88,
      "endOffset" : 109
    }, {
      "referenceID" : 15,
      "context" : "We thank the researchers who provided the instances or instance generators used in our work, in particular Gent et al. (1999), Gomes and Selman (1997), LeytonBrown et al.",
      "startOffset" : 107,
      "endOffset" : 126
    }, {
      "referenceID" : 15,
      "context" : "We thank the researchers who provided the instances or instance generators used in our work, in particular Gent et al. (1999), Gomes and Selman (1997), LeytonBrown et al.",
      "startOffset" : 107,
      "endOffset" : 151
    }, {
      "referenceID" : 15,
      "context" : "We thank the researchers who provided the instances or instance generators used in our work, in particular Gent et al. (1999), Gomes and Selman (1997), LeytonBrown et al. (2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al.",
      "startOffset" : 107,
      "endOffset" : 178
    }, {
      "referenceID" : 2,
      "context" : "(2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al.",
      "startOffset" : 8,
      "endOffset" : 28
    }, {
      "referenceID" : 2,
      "context" : "(2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al.",
      "startOffset" : 8,
      "endOffset" : 43
    }, {
      "referenceID" : 2,
      "context" : "(2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al.",
      "startOffset" : 8,
      "endOffset" : 70
    }, {
      "referenceID" : 1,
      "context" : "(2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al. (2007), Atamtürk and Muñoz (2004), Atamtürk (2003), and Andronescu et al.",
      "startOffset" : 71,
      "endOffset" : 92
    }, {
      "referenceID" : 1,
      "context" : "(2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al. (2007), Atamtürk and Muñoz (2004), Atamtürk (2003), and Andronescu et al.",
      "startOffset" : 71,
      "endOffset" : 119
    }, {
      "referenceID" : 1,
      "context" : "(2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al. (2007), Atamtürk and Muñoz (2004), Atamtürk (2003), and Andronescu et al.",
      "startOffset" : 71,
      "endOffset" : 136
    }, {
      "referenceID" : 1,
      "context" : "(2000), Babić and Hu (2007), Zarpas (2005), Le Berre and Simon (2004), Aktürk et al. (2007), Atamtürk and Muñoz (2004), Atamtürk (2003), and Andronescu et al. (2007). Lin Xu created the specific sets of QCP and SWGCP instances we used.",
      "startOffset" : 71,
      "endOffset" : 166
    } ],
    "year" : 2009,
    "abstractText" : "The identification of performance-optimizing parameter settings is an important part of the development and application of algorithms. We describe an automatic framework for this algorithm configuration problem. More formally, we provide methods for optimizing a target algorithm’s performance on a given class of problem instances by varying a set of ordinal and/or categorical parameters. We review a family of local-search-based algorithm configuration procedures and present novel techniques for accelerating them by adaptively limiting the time spent for evaluating individual configurations. We describe the results of a comprehensive experimental evaluation of our methods, based on the configuration of prominent complete and incomplete algorithms for SAT. We also present what is, to our knowledge, the first published work on automatically configuring the CPLEX mixed integer programming solver. All the algorithms we considered had default parameter settings that were manually identified with considerable effort. Nevertheless, using our automated algorithm configuration procedures, we achieved substantial and consistent performance improvements.",
    "creator" : "TeX"
  }
}