{
  "name" : "1406.4110.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Acyclicity Notions for Existential Rules and Their Application to Query Answering in Ontologies",
    "authors" : [ "Bernardo Cuenca Grau", "Ian Horrocks", "Markus Krötzsch", "Despoina Magka", "Boris Motik", "Zhe Wang" ],
    "emails" : [ "bernardo.cuenca.grau@cs.ox.ac.uk", "ian.horrocks@cs.ox.ac.uk", "markus.kroetzsch@cs.ox.ac.uk", "clemens.kupke@cs.ox.ac.uk", "despoina.magka@cs.ox.ac.uk", "boris.motik@cs.ox.ac.uk", "zhe.wang@cs.ox.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Existential rules are closely related to the Horn fragments of the OWL 2 ontology language; furthermore, several prominent OWL 2 reasoners implement CQ answering by using the chase to materialise all relevant facts. In order to avoid termination problems, many of these systems handle only the OWL 2 RL profile of OWL 2; furthermore, some systems go beyond OWL 2 RL, but without any termination guarantees. In this paper we also investigate whether various acyclicity notions can provide a principled and practical solution to these problems. On the theoretical side, we show that query answering for acyclic ontologies is of lower complexity than for general ontologies. On the practical side, we show that many of the commonly used OWL 2 ontologies are MSA, and that the number of facts obtained by materialisation is not too large. Our results thus suggest that principled development of materialisation-based OWL 2 reasoners is practically feasible."
    }, {
      "heading" : "1. Introduction",
      "text" : "Existential rules are first-order implications between conjunctions of function-free atoms that may contain existentially quantified variables in the implication’s consequent (Baget, Leclère, Mugnier, & Salvat, 2011a; Cal̀ı, Gottlob, Lukasiewicz, Marnette, & Pieris, 2010a). Such rules are used in a variety of ways in databases, knowledge representation, and logic programming. In database theory, existential rules are known as tuple-generating dependencies (Abiteboul, Hull, & Vianu, 1995) and are used to capture a wide range of schema\nc©2013 AI Access Foundation. All rights reserved.\nconstraints. Furthermore, they are also used as declarative data transformation rules in data exchange—the process of transforming a database structured according to a source schema into a database structured according to a target schema (Fagin, Kolaitis, Miller, & Popa, 2005). Existential rules also provide the foundation for several prominent knowledge representation formalisms, such as Datalog± (Cal̀ı, Gottlob, & Pieris, 2010b; Cal̀ı et al., 2010a), and they are also closely related to logic programs with function symbols in the head. Practical applications of existential rules range from bioinformatics (Mungall, 2009) to modelling complex structures of chemical compounds (Magka, Motik, & Horrocks, 2012; Hastings, Magka, Batchelor, Duan, Stevens, Ennis, & Steinbeck, 2012).\nAnswering conjunctive queries (CQs) over a set of facts extended with existential rules is a fundamental, yet undecidable (Beeri & Vardi, 1981) reasoning problem for existential rules. The problem can be characterised using chase (Johnson & Klug, 1984; Maier, Mendelzon, & Sagiv, 1979)—a technique closely related to the hypertableau calculus (Motik, Shearer, & Horrocks, 2009b; Baumgartner, Furbach, & Niemelä, 1996). In a forward-chaining manner, the chase extends the original set of facts with facts that can be derived using the rules. The result of the chase is a universal model, in the sense that an arbitrary CQ over the original facts and rules can be answered by evaluating the query in this model."
    }, {
      "heading" : "1.1 Chase Termination and Acyclicity Notions",
      "text" : "Rules with existentially quantified variables in the head—so-called generating rules—require the introduction of fresh individuals. Cyclic applications of generating rules may prevent the chase from terminating, and in fact determining whether chase terminates on a set of rules and facts is undecidable (Deutsch, Nash, & Remmel, 2008). However, several decidable classes of existential rules have been identified, and the existing proposals can be classified into two main groups. In the first group, rules are restricted such that their possibly infinite universal models can be represented using finitary means. This group includes rules with universal models of bounded treewidth (Baget et al., 2011a), guarded rules (Cal̀ı et al., 2010a), and ‘sticky’ rules (Cal̀ı, Gottlob, & Pieris, 2011). In the second group, one uses a sufficient (but not necessary) acyclicity notion that ensures chase termination.\nRoughly speaking, acyclicity notions analyse the information flow between rules to ensure that no cyclic applications of generating rules are possible. Weak acyclicity (WA) (Fagin et al., 2005) was one of the first such notions, and it was extended to notions such as safety (Meier, Schmidt, & Lausen, 2009), stratification (Deutsch et al., 2008), acyclicity of a graph of rule dependencies (aGRD) (Baget, Mugnier, & Thomazo, 2011b), joint acyclicity (JA) (Krötzsch & Rudolph, 2011), and super-weak acyclicity (SWA) (Marnette, 2009). Syntactic acyclicity criteria have also been investigated in the context of logic programs with function symbols in the rule heads, where the goal is to recognise logic programs with finite stable models. Several such notions have been implemented in state of the art logic programming engines, such as omega-restrictedness (Syrjänen, 2001) from the Smodels system (Syrjänen & Niemelä, 2001), lambda-restrictedness from the ASP grounder GrinGo (Gebser, Schaub, & Thiele, 2007), argument-restrictedness (Lierler & Lifschitz, 2009) from the DLV system (Leone, Pfeifer, Faber, Eiter, Gottlob, Perri, & Scarcello, 2006), and many others (Calimeri, Cozza, Ianni, & Leone, 2008; Greco, Spezzano, & Trubitsyna, 2012; De Schreye & Decorte, 1994)."
    }, {
      "heading" : "1.2 Applications of Acyclicity Notions",
      "text" : "Acyclicity notions are interesting for several reasons. First, unlike guarded rules, acyclic rules can axiomatise structures of arbitrary shapes, as long as these structures are bounded in size. Second, the result of the chase for acyclic rules can be stored and manipulated as if it were a database; this is important, for example, in data exchange, where the goal is to materialise the transformed database.\nIn this paper, we further argue that acyclicity notions are also relevant to description logics (DLs)—knowledge representation formalisms underpinning the OWL 2 ontology language (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider, & Sattler, 2008). CQ answering over DL ontologies is a key reasoning service in many DL applications, and the problem was studied for numerous different DLs (Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007; Krötzsch, Rudolph, & Hitzler, 2007; Glimm, Horrocks, Lutz, & Sattler, 2008; Ortiz, Calvanese, & Eiter, 2008; Lutz, Toman, & Wolter, 2009; Pérez-Urbina, Motik, & Horrocks, 2009; Rudolph & Glimm, 2010; Kontchakov, Lutz, Toman, Wolter, & Zakharyaschev, 2011). Answering CQs over ontologies, however, is quite technical and often of high computational complexity. Therefore, practical OWL 2 reasoners frequently solve this problem using materialisation—a reasoning technique in which the relevant consequences of the ontology are precomputed using chase, allowing queries to be directly evaluated in the materialised set of facts. Examples of materialisation-based systems include Oracle’s Semantic Data Store (Wu, Eadon, Das, Chong, Kolovski, Annamalai, & Srinivasan, 2008), Sesame (Broekstra, Kampman, & van Harmelen, 2002), OWLIM (Kiryakov, Ognyanov, & Manov, 2005), Jena (Carroll, Dickinson, Dollin, Reynolds, Seaborne, & Wilkinson, 2004), and DLE-Jena (Meditskos & Bassiliades, 2008). Such reasoning is possible if (i) the ontology is Horn (Hustadt, Motik, & Sattler, 2005) and thus does not require disjunctive reasoning, and (ii) the chase is guaranteed to terminate. To satisfy the second assumption, reasoners often consider only axioms in the OWL 2 RL profile (Motik, Cuenca Grau, Horrocks, Wu, Fokoue, & Lutz, 2009a); this systematically excludes generating rules and thus trivially ensures chase termination, but it also makes the approach incomplete. Generating rules are partially supported in systems such as OWLim (Bishop & Bojanov, 2011) and Jena, but such support is typically ad hoc and provides no completeness and/or termination guarantees. Acyclicity notions can be used to address these issues: if an ontology is Horn and acyclic, a complete materialisation can be computed without the risk of non-termination."
    }, {
      "heading" : "1.3 Our Contributions",
      "text" : "Motivated by the practical importance of chase termination, in this paper we present two new acyclicity notions: model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA). Roughly speaking, these acyclicity notions use a particular model of the rules to analyse the implications between existential quantifiers, which is why we call them model based. In particular, MFA uses the actual ‘canonical’ model induced by the facts and the rules, which makes the notion very general. We prove that checking whether a set of existential rules is MFA is 2ExpTime-complete, and it becomes ExpTime-complete if the predicates in the rules are of bounded arity. Due to the high complexity, MFA may be unsuitable for practical application. Thus, we introduce MSA, which can be understood as MFA in which the analysis is performed over models that ‘summarise’ (or overestimate) the\nactual models. Checking MSA of existential rules can be realised via checking entailment of ground atoms in datalog programs. We use this close connection between MSA and datalog to prove that checking MSA is ExpTime-complete for general existential rules, and that it becomes coNP-complete if the arity of rule predicates is bounded.\nWe next conduct a detailed investigation of the landscape of known acyclicity notions, augmented with MFA and MSA. For the class of logic programs that correspond to existential rules with skolemised existential quantifiers, we show that MSA and MFA strictly subsume existing acyclicity notions known from logic programming. We also show that MSA is strictly more general than SWA—one of the most general acyclicity notions known in database theory. Furthermore, we investigate the relationship between the known notions and thus complete the picture with respect to their relative expressiveness.\nBoth MSA and MFA can be applied to general existential rules without equality. Equality can be incorporated via singularisation—a technique proposed by Marnette (2009) that transforms the rules to encode the effects of equality. Singularisation is orthogonal to acyclicity: after computing the transformed rules, one can use MFA, MSA, or in fact any notion to check whether the result is acyclic; if so, the chase of the signularised rules terminates, and the chase result can be used in a particular way to answer arbitrary CQs. Unfortunately, singularisation is nondeterministic: some ways of transforming the rules may produce acyclic rule sets, but not all ways are guaranteed to do so. In this paper, we refine singularisation to obtain practically useful upper and lower bounds for acyclicity. We also show that, when used with JA, our lower bound actually coincides with WA.\nWe next turn our attention to theoretical and practical issues of using acyclicity for materialisation-based CQ answering over ontologies. On the theoretical side, we show that checking MFA and MSA of Horn-SROIF ontologies is ExpTime- and PTime-complete, respectively, and that answering CQs over acyclic Horn-SROIF ontologies is ExpTimecomplete as well. Furthermore, we show that, for Horn-SHIF ontologies, the complexity of checking MFA and of answering CQs drops to PSpace. Answering CQs is ExpTimecomplete for general (i.e., not acyclic) Horn-SHIF ontologies (Eiter, Gottlob, Ortiz, & Simkus, 2008; Ortiz, Rudolph, & Simkus, 2011), so acyclicity makes this problem easier. Furthermore, Horn ontologies can be extended with arbitrary SWRL rules (Horrocks & Patel-Schneider, 2004) without affecting decidability or worst-case complexity, provided that the union of the ontology and SWRL rules is acyclic; this is in contrast to the general case, where SWRL extensions of DLs easily lead to undecidability.\nOn the practical side, we explore the limits of reasoning with acyclic OWL 2 ontologies via materialisation. We checked MFA, MSA, and JA for 336 Horn ontologies; furthermore, to estimate the impact of materialisation, we compared the size of the materialisation with the number of facts in the original ontologies. Our experiments revealed that many ontologies are MSA, and that some complex ones are MSA but not JA; furthermore, the universal models obtained via materialisation are typically not too large. Thus, our results suggest that principled, materialisation-based reasoning for ontologies beyond the OWL 2 RL profile may be practically feasible.\nThis is an extended version of a paper by Cuenca Grau, Horrocks, Krötzsch, Kupke, Magka, Motik, and Wang (2012) published at KR 2012."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "In this section we introduce definitions and notation used in the rest of our paper."
    }, {
      "heading" : "2.1 First-Order Logic",
      "text" : "We use the standard notions of constants, function symbols, and predicate symbols, where ≈ is the equality predicate, > is universal truth, and ⊥ is universal falsehood. Each function or predicate symbol is associated with a nonnegative integer arity. Variables, terms, substitutions, atoms, first-order formulae, sentences, interpretations (i.e., structures), and models are defined as usual. By a slight abuse of notation, we often identify a conjunction with the set of its conjuncts. Furthermore, we often abbreviate a vector of terms t1, . . . , tn as ~t; we define |~t| = n; and we often identify ~t with the set of indexed terms {t1, . . . , tn}. With ϕ(~x) we stress that ~x = x1, . . . , xn are the free variables of a formula ϕ, and with ϕσ we denote the result of applying a substitution σ to ϕ. A term, atom, or formula is ground if it does not contain variables; a fact is a ground atom. The depth dep(t) of a term t is defined as 0 if t is a constant or a variable, and dep(t) = 1 + maxni=1 dep(ti) if t = f(t1, . . . , tn). A term t′ is a subterm of a term t if t′ = t or t = f(~s) and t′ is a subterm of some si ∈ ~s; if additionally t′ 6= t, then t′ is a proper subterm of t. A term s is contained in an atom P (~t) if s ∈ ~t, and s occurs in P (~t) if s is a subterm of some term ti ∈ ~t; thus, if s is contained in P (~t), then s also occurs in P (~t), but the converse may not hold. A term s is contained (resp. occurs) in a set of atoms I if s is contained (resp. occurs) in some atom in I.\nIn first-order logic, the equality predicate ≈ is commonly assumed to have a predefined interpretation—that is, every first-order interpretation is required to interpret ≈ as the smallest reflexive relation over the domain. Satisfaction of a sentence ϕ in an interpretation I where ≈ is interpreted in this way is written I |= ϕ, and entailment of a sentence ψ from a sentence ϕ is written ϕ |= ψ. Unless otherwise stated, we use this standard interpretation of equality throughout this paper.\nEquality, however, can also be treated as an ordinary predicate with an explicit axiomatisation. Let Σ be an arbitrary set of function-free first-order formulae. Then, Σ≈ = ∅ if ≈ does not occur in Σ; otherwise, Σ≈ contains formulae (1)–(3) and an instance of formula (4) for each n-ary predicate P occurring in Σ different from ≈, and for each 1 ≤ i ≤ n. Note that all variables in all of these formulae are (implicitly) universally quantified.\n→ x ≈ x (1) x1 ≈ x2 → x2 ≈ x1 (2)\nx1 ≈ x2 ∧ x2 ≈ x3 → x1 ≈ x3 (3) P (x1, . . . , xi, . . . , xn) ∧ xi ≈ x′i → P (x1, . . . , x′i, . . . , xn) (4)\nIf ≈ is treated as an ordinary predicate, satisfaction of a formula ϕ in a model I is written I |=≈ ϕ, and entailment of a formula ψ from formula ϕ is written ϕ |=≈ ψ. Please note that, according to our definitions, I |=≈ ϕ can hold even if interpretation I interprets predicate ≈ in an arbitrary way; in contrast, I |= ϕ can hold only if interpretation I interprets predicate ≈ as the identity relation on the model’s domain. The consequences of Σ w.r.t. |= and of Σ ∪ Σ≈ w.r.t. |=≈ coincide—that is, for each first-order sentence ψ constructed using the symbols from Σ, we have Σ |= ψ if and only if Σ ∪ Σ≈ |=≈ ψ."
    }, {
      "heading" : "2.2 Rules and Queries",
      "text" : "An instance is a finite set of function-free facts. An existential rule (or just rule) is a function-free sentence of the form\n∀~x∀~z.[ϕ(~x, ~z)→ ∃~y.ψ(~x, ~y)] (5)\nwhere ϕ(~x, ~z) and ψ(~x, ~y) are conjunctions of atoms, and tuples of variables ~x, ~y, and ~z are pairwise disjoint. Formula ϕ is the body and formula ψ is the head of the rule. For brevity, quantifiers ∀~x∀~z are often omitted. For convenience, we sometimes identify a rule body or head with the set of the respective conjuncts. A datalog rule is a rule where ~y is empty. A rule is equality-free if it does not contain the equality predicate ≈. A term s occurs in an existential rule if s occurs in a head or body atom of the rule, and these definitions are extended to a set of rules in the obvious way; existential rules do not contain function symbols, so an analogous notion of s being contained in a rule coincides with this one. Two variables are directly connected in a rule if they occur together in a body atom of the rule; furthermore, connected is the transitive closure of directly connected ; finally, a rule of the form (5) is connected if all pairs of variables w,w′ ∈ ~x ∪ ~z are connected in the rule.\nA conjunctive query (CQ) is a formula of the form Q(~x) = ∃~y.ϕ(~x, ~y), where ϕ(~x, ~y) is a conjunction of atoms; the query is Boolean if ~x is empty. A substitution θ mapping ~x to constants is an answer to Q(~x) w.r.t. a set of rules Σ and instance I if Σ ∪ I |= Q(~x)θ. Answering CQs is the core reasoning problem in many applications of existential rules.\nWhen answering a conjunctive query Q(~x) over a set of rules Σ and an instance I, in the rest of this paper we implicitly assume that Q(~x) and I contain only the predicates from Σ. This simplifies the presentation since it allows us to define various transformations of Σ without having to take into account possible predicates that occur in Q(~x) or I only. This assumption is w.l.o.g., as we can always extend Σ with tautological rules of the form P (~x)→ P (~x) for each predicate P occurring in Q(~x) or I but not in Σ.\nFurthermore, we assume that ≈ does not occur in the body of any rule in Σ or in the query Q(~x). This is w.l.o.g. since we can eliminate each atom of the form x ≈ t in a rule body and further replace x with t in the rest of the rule; furthermore, to eliminate body atoms of the form a ≈ b with a and b constants, we can introduce a fresh predicate Oa, add a new rule → Oa(a), replace each body atom a ≈ b with conjunction Oa(x) ∧ x ≈ b in which x is a fresh variable, and finally eliminate atom x ≈ b as before. Similarly, we do not provide an explicit support for the inequality predicate 6≈. Inequality in rule heads can be simulated using an ordinary predicate: each atom of the form s 6≈ t occurring in a rule head can be replaced with NotEqual(s, t), where NotEqual is a fresh ordinary predicate that is explicitly axiomatised as irreflexive; note that, if ≈ is handled as a regular predicate explicitly axiomatised by rules (1)–(4), then the replacement axioms (4) must be instantiated for P = NotEqual as well. In contrast, atoms involving the inequality predicate occurring in rule bodies generally require disjunctive reasoning, which is not supported by existential rules.\nFinally, we assume that conjunctions ϕ(~x, ~z) and ψ(~x, ~y) in each rule of the form (5) are both not empty. We also assume that > and ⊥ are treated as ordinary unary predicates, and that the semantics of > is captured explicitly in Σ by instantiating the following rule for each n-ary predicate P occurring in Σ:\nP (x1, . . . , xn)→ >(x1) ∧ . . . ∧ >(xn) (6)\nThese assumptions ensure that I ∪ Σ is always satisfiable, but that Σ ∪ I |= ∃y.⊥(y) if and only if I ∪ Σ is unsatisfiable w.r.t. the conventional treatment of > and ⊥. By allowing body atoms of the form >(x), without loss of generality we can require each existential rule to be safe (i.e., that each universally quantified variable occurring in a head atom also occurs in a body atom of the rule), which greatly simplifies many of our definitions.\nIn database theory, satisfaction and entailment are often considered only w.r.t. finite interpretations under the unique name assumption (UNA); the latter ensures that distinct constants are interpreted as distinct elements. In contrast, such assumptions are not customary in ontology-based KR. In this paper, we do not assume UNA, as UNA can be axiomatised explicitly if needed using the inequality predicate (or a simulation thereof). Furthermore, in this paper we investigate theories that are satisfiable in finite models (i.e., for which the chase is finite); thus, the difference between finite and infinite satisfiability is immaterial to our results.\nWe frequently use skolemisation to interpret rules in Herbrand interpretations, which are defined as possibly infinite sets of ground atoms. In particular, for each rule r of the form (5) and each variable yi ∈ ~y, let f ir be a function symbol globally unique for r and yi of arity |~x|; furthermore, let θsk be the substitution such that θsk(yi) = f ir(~x) for each yi ∈ ~y. Then, the skolemisation sk(r) of r is the following rule:\nϕ(~x, ~z)→ ψ(~x, ~y)θsk (7)\nThe skolemisation sk(Σ) of a set of rules Σ is obtained by skolemising each rule in Σ. Skolemisation does not affect the answers to CQs—that is, for each conjunctive query Q(~x) formed from only the predicates in Σ, each instance I, and each substitution σ, we have Σ ∪ I |= Q(~x)σ if and only if sk(Σ) ∪ Σ≈ ∪ I |=≈ Q(~x)σ."
    }, {
      "heading" : "2.3 The Skolem Chase",
      "text" : "Answering CQs can be characterised using chase, and in this paper we use the skolem chase variant (Marnette, 2009). Let r = ϕ→ ψ be a skolemised rule and let I be a set of ground atoms. A set of ground atoms S is a consequence of r on I if substitution σ exists mapping the variables in r to the terms occurring in I such that ϕσ ⊆ I and S ⊆ ψσ. The result of applying r to I, written r(I), is the union of all consequences of r on I. For Ω a set of skolemised rules, Ω(I) = ⋃ r∈Ω r(I). Let I be a finite set of ground atoms, let Σ be a set of rules, let Σ′ = sk(Σ) ∪ Σ≈, and let Σ′f and Σ′n be the subsets of Σ′ containing rules with and without function symbols, respectively. The chase sequence for I and Σ is a sequence of sets of facts I0Σ, I 1 Σ, . . . where I 0 Σ = I and, for each i > 0, set I i Σ is defined as follows:\n• if Σ′n(Ii−1Σ ) 6⊆ I i−1 Σ , then I i Σ = I i−1 Σ ∪ Σ′n(I i−1 Σ ), • otherwise IiΣ = I i−1 Σ ∪ Σ′f (I i−1 Σ ).\nThe chase of I and Σ is defined as I∞Σ = ⋃ i I i Σ; note that I ∞ Σ can be infinite. The chase can be used as a ‘database’ for answering CQs: a substitution σ is an answer to Q over Σ and I if and only if I∞Σ |=≈ Qσ. The chase of I and Σ terminates if i ≥ 0 exists such that IiΣ = I j Σ for each j ≥ i; the chase of Σ terminates universally if the chase of I and Σ terminates for each I. If the skolem chase of I and Σ terminates, then both the nonoblivious chase (Fagin et al., 2005) and the core chase (Deutsch et al., 2008) of I and Σ terminate as well.\nThe critical instance I∗Σ for a set of rules Σ contains all facts that can be constructed using all predicates occurring in Σ, all constants occurring in the body of a rule in Σ, and one special fresh constant ∗. The skolem chase for I∗Σ and Σ terminates if and only if the skolem chase of Σ terminates universally (Marnette, 2009)."
    }, {
      "heading" : "2.4 Acyclicity Notions",
      "text" : "Checking whether the skolem chase terminates on a given instance is undecidable, and checking universal skolem chase termination is conjectured to be undecidable as well. Consequently, various sufficient acyclicity notions have been proposed in the literature. Formally, an acyclicity notion X is a class of finite sets of rules; such a definition allows us to talk about (proper) containment between acyclicity notions. We sometimes write ‘Σ is X’, by which we mean ‘Σ ∈ X’. We next introduce weak and joint acyclicity: the former is one of the first such notions considered in the literature; and as we show in Section 3, the latter notion is relatively powerful, yet still easy to understand. We use these two notions throughout the paper to present examples and state various technical claims. In Section 3 we present the definitions of many other acyclicity notions known in the literature.\nIn the following, let Σ be a set of rules where no variable occurs in more than one rule. A position is an expression of the form P |i where P is an n-ary predicate and i is an integer with 1 ≤ i ≤ n. Given a rule r of the form (5) and a variable w occurring in r, the set PosB(w) of body positions of w contains each position P |i such that P (t1, . . . , tn) ∈ ϕ(~x, ~z) and ti = w for some vector ~t of terms. The set PosH(w) of head positions is defined analogously, but w.r.t. the head atoms of r. Note that, since each variable occurs in at most one rule in Σ, sets PosB(w) and PosH(w) are (indirectly) associated with the rule that contains w. In the rest of this paper, whenever we use notation such as PosH(w) or PosB(w), we silently assume that no variable occurs in more than one rule and so the notation is unambiguous. This is clearly w.l.o.g. as one can always arbitrarily rename variables in different rules.\nWeak acyclicity (WA) (Fagin et al., 2005) can be applied to existential rules that contain the equality predicate. The WA dependency graph WA(Σ) for Σ contains positions as vertices; furthermore, for each rule r ∈ Σ of the form (5), each variable x ∈ ~x, each position P |i ∈ PosB(x), and each variable y ∈ ~y, graph WA(Σ) contains\n• a regular edge from P |i to each Q|j ∈ PosH(x) such that Q 6= ≈ and,\n• a special edge from P |i to each Q|j ∈ PosH(y) such that Q 6= ≈.\nSet Σ is WA if WA(Σ) does not contain a cycle that involves a special edge. Equality atoms are effectively ignored by WA.\nJoint acyclicity (JA) (Krötzsch & Rudolph, 2011) generalises WA, but it is applicable only to equality-free rules. For an existentially quantified variable y in Σ, let Move(y) be the smallest set of positions such that\n• PosH(y) ⊆ Move(y), and\n• for each existential rule r ∈ Σ and each universally quantified variable x occurring in r, if PosB(x) ⊆ Move(y), then PosH(x) ⊆ Move(y).\nThe JA dependency graph JA(Σ) of Σ is defined as follows. The vertices of JA(Σ) are the existentially quantified variables occurring in Σ. Given arbitrary two such variables y1 and y2, the JA dependency graph JA(Σ) contains an edge from y1 to y2 whenever the rule that contains y2 also contains a universally quantified variable x such that PosH(x) 6= ∅ and PosB(x) ⊆ Move(y1). Set Σ is JA if JA(Σ) does not contain a cycle."
    }, {
      "heading" : "2.5 Rule Normalisation",
      "text" : "Existential rules can often be transformed into other existential rules by replacing parts of the rule head or body with atoms involving fresh predicates. Such a transformation is called normalisation, and is often used as a preprocessing step to bring the rules into a suitable form. For example, Horn OWL 2 axioms can be translated into existential rules by using the well known transformations of first-order logic, and the latter can then be normalised to a form we describe in Section 6. In this section we introduce a definition of rule normalisation that captures all similar methods known to us.\nLet r be a rule of the form (8), where ϕ1, ϕ2, ψ1, and ψ2 are conjunctions of atoms satisfying ~x1 ∪ ~x2 = ~x3 ∪ ~x4, ~z2 ∩ ~z3 = ∅, and ~y2 ∩ ~y3 = ∅.\nϕ1(~x1, ~z1, ~z2) ∧ ϕ2(~x2, ~z1, ~z3)→ ∃~y1, ~y2, ~y3.[ψ1(~x3, ~y1, ~y2) ∧ ψ2(~x4, ~y1, ~y3)] (8)\nA normalisation step replaces a conjunction in either the head or the body of the rule with an atom involving a fresh predicate. More precisely, a head normalisation step replaces ψ1(~x3, ~y1, ~y2) with atom Q(~x3, ~y1) where Q is a fresh predicate, thus replacing r with rule (9), and it adds rule (10).\nϕ1(~x1, ~z1, ~z2) ∧ ϕ2(~x2, ~z1, ~z3)→ ∃~y1, ~y3.[Q(~x3, ~y1) ∧ ψ2(~x4, ~y1, ~y3)] (9) Q(~x3, ~y1)→ ∃~y2.ψ1(~x3, ~y1, ~y2) (10)\nAlternatively, a body normalisation step replaces ϕ1(~x1, ~z1, ~z2) with atom Q(~x1, ~z1) where Q is a fresh predicate, thus replacing r with rule (11), and it adds rule (12).\nQ(~x1, ~z1) ∧ ϕ2(~x2, ~z1, ~z3)→ ∃~y1, ~y2, ~y3.[ψ1(~x3, ~y1, ~y2) ∧ ψ2(~x4, ~y1, ~y3)] (11) ϕ1(~x1, ~z1, ~z2)→ Q(~x1, ~z1) (12)\nGiven a set of existential rules Σ, normalisation steps are often applied to Σ iteratively. If the predicate Q introduced in each step is always fresh, we call such normalisation without structure sharing. In contrast, normalisation with structure sharing allows the predicate Q to be reused across different normalisation steps. For example, once a predicate Q is introduced in a head normalisation step to replace ϕ1(~x1, ~z1, ~z2), then a conjunction of the form ϕ1(~x ′ 1, ~z ′ 1, ~z ′ 2) where ~x ′ 1, ~z ′ 1, ~z ′ 2 are renamings of ~x1, ~z1, ~z2 can be replaced with Q(~x ′ 3, ~y ′ 1) without introducing the corresponding rule (10). An analogous optimisation can be used in a body normalisation step.\nLet Σ′ be a set of rules obtained via normalisation (with or without structure sharing) from Σ. It is well known that Σ′ is a conservative extension of Σ. Consequently, for each instance I and each BCQ Q that does not use the freshly introduced predicates, we have Σ ∪ I |= Q if and only if Σ′ ∪ I |= Q."
    }, {
      "heading" : "3. Novel Acyclicity Notions",
      "text" : "Weak acyclicity has considerably influenced the field of data exchange in databases, but it is a rather strict notion and so it may not be sufficient in many applications of existential rules. Joint acyclicity significantly relaxes weak acyclicity and was developed mainly for rule based knowledge representation applications.\nIn Section 3.1 we show that even joint acyclicity—one of the most general acyclicity notions developed so far—does not capture rules corresponding to axioms commonly found in ontologies for which the chase terminates universally. To address this important limitation, we propose in Section 3.2 model-faithful acyclicity (MFA)—a novel, very general, notion that can be used to successfully ensure chase termination for many ontologies used in practice. The computational cost of checking MFA is, however, rather high; hence, in Section 3.3 we introduce model-summarising acyclicity (MSA)—a more strict notion that is easier to check and produces the same results as MFA on most existing ontologies."
    }, {
      "heading" : "3.1 Limitations of Existing Acyclicity Notions",
      "text" : "To motivate our new acyclicity notions, we first present an example that shows how known acyclicity notions, such as JA, are not satisfied by rules that are equivalent to very simple axioms that abound in OWL ontologies.\nExample 1. Let Σ be the set of rules (13)–(17).\nr1 = A(x1)→ ∃y1.R(x1, y1) ∧B(y1) (13) r2 = R(x2, z1) ∧B(z1)→ A(x2) (14) r3 = B(x3)→ ∃y2.R(x3, y2) ∧ C(y2) (15) r4 = C(x4)→ D(x4) (16) r5 = R(x5, z2) ∧D(z2)→ B(x5) (17)\nRules r1 and r2 correspond to the description logic axiom A ≡ ∃R.B, rule r3 corresponds to axiom B v ∃R.C, rule r4 corresponds to axiom C v D, and rule r5 corresponds to axiom ∃R.D v B. Such axioms are very common in OWL ontologies.\nBy the definition of JA from Section 2, we have Move(y1) = {R|2, B|1, R|1, A|1}. Thus, the JA dependency graph contains an edge from y1 to itself, so the set of axioms Σ is not JA. In contrast, the following table shows the chase sequence for I∗Σ and Σ.\nA(∗) R(∗, f(∗)) R(f(∗), g(f(∗))) D(g(f(∗))) B(∗) B(f(∗)) C(g(f(∗))) C(∗) R(∗, g(∗)) D(g(∗)) D(∗) C(g(∗))\nR(∗, ∗)\nRule r2 is not applicable to R(f(∗), g(f(∗))) since I3 does not contain the fact B(g(f(∗))) necessary to match the atom B(z1) from the rule. Thus, the chase terminates. ♦\nAll existing acyclicity notions essentially try to estimate whether an application of a rule can produce facts that can (possibly by applying chase to other rules) repeatedly\ntrigger the same rule in an infinite manner. The key difference between various notions is how rule applicability is determined. In particular, JA considers each variable in a rule in isolation and does not check satisfaction of all body atoms at once; for example, rule (14) is not applicable to the facts generated by rule (15), but this can be determined only by considering variables x2 and z1 in rule (14) simultaneously. These notions thus overestimate rule applicability and, as a result, they can fail to detect chase termination."
    }, {
      "heading" : "3.2 Model-Faithful Acyclicity (MFA)",
      "text" : "Our main intuition for addressing this problem is that more precise chase termination guarantees can be obtained by tracking rule applicability more ‘faithfully’. A simple solution is to be completely precise about rule applicability: one can run the skolem chase and then use sufficient checks to identify cyclic computations. Since no sufficient, necessary, and computable test can be given for the latter, we must adopt a practical approach. For example, we can ‘raise the alarm’ and stop the process if the chase derives a ‘cyclic’ term f(~t), where f occurs in ~t. This idea can be further refined; for example, one could stop only if f occurs nested in a term some fixed number of times. The choice of the appropriate test thus depends on an application; however, as our experiments show, checking only for one level of nesting suffices in many cases. In particular, no term f(~t) with f occurring in ~t is generated in the chase of the set of rules Σ from Example 1.\nDefinition 2. A term t is cyclic if a function symbol f exists such that some term f(~s) is a subterm of t, and some term f(~u) is a proper subterm of f(~s).\nOur notion of acyclicity is declarative: the given set of rules Σ is transformed into a new set of rules Σ′ that tracks rule dependencies using fresh predicates; then, Σ is identified as being acyclic if Σ′ does not entail a special nullary predicate C. Since acyclicity is defined via entailment, it can be decided using any theorem proving procedure for existential rules that is sound and complete. Acyclicity guarantees termination of the skolem chase, which also guarantees termination of nonoblivious chase and core chase. We call our notion modelfaithful acyclicity because it estimates rule application precisely, by examining the actual structure of the universal model of Σ.\nDefinition 3. For each rule r = ϕ(~x, ~z)→ ∃~y.ψ(~x, ~y) and each variable yi ∈ ~y, let Fir be a fresh unary predicate unique for r and yi; furthermore, let S and D be fresh binary predicates, and let C be a fresh nullary predicate. Then, MFA(r) is the following rule:\nϕ(~x, ~z)→ ∃~y. ψ(~x, ~y) ∧ ∧ yi∈~y Fir(yi) ∧ ∧ xj∈~x S(xj , yi)  For a set Σ of rules, MFA(Σ) is the smallest set that contains MFA(r) for each rule r ∈ Σ, rules (18)–(19), and rule (20) instantiated for each Fir corresponding to some r ∈ Σ:\nS(x1, x2)→ D(x1, x2) (18) D(x1, x2) ∧ S(x2, x3)→ D(x1, x3) (19)\nFir(x1) ∧ D(x1, x2) ∧ Fir(x2)→ C (20)\nThe set Σ is model-faithful acyclic (MFA) w.r.t. an instance I if I ∪MFA(Σ) 6|= C; furthermore, Σ is universally MFA1 if Σ is MFA w.r.t. I∗Σ.\nExample 4. Let Σ be the set of rules from Example 1. Then, MFA(r1) and MFA(r3) are given by (21) and (22), respectively; since r1 and r3 contain a single existentially quantified variable each, we omit the superscripts in Fr1 and Fr3 for the sake of clarity. Thus, MFA(Σ) consists of rules (14), (16), and (17), rules (21)–(22), rules (18)–(19), and rule (20) instantiated for Fr1 and Fr3.\nA(x1)→ ∃y1.R(x1, y1) ∧B(y1) ∧ Fr1(y1) ∧ S(x1, y1) (21) B(x3)→ ∃y2.R(x3, y2) ∧ C(y2) ∧ Fr3(y2) ∧ S(x3, y2) (22)\nIt is straightforward to see that the chase of I∗Σ and MFA(Σ) consists of the facts presented in Example 1, augmented with the following facts:\nS(∗, f(∗)) D(∗, f(∗)) D(f(∗), g(f(∗))) S(∗, g(∗)) D(∗, g(∗)) D(∗, g(f(∗))) Fr1(f(∗)) S(f(∗), g(f(∗))) Fr3(g(∗)) Fr3(g(f(∗)))\nThe chase of I∗Σ and MFA(Σ) does not contain C, which implies that I ∪MFA(Σ) 6|= C. As a result, Σ is universally MFA. ♦\nMFA is formulated as a semantic, rather than a syntactic notion, and is thus mainly independent from algorithmic details: entailment I ∪MFA(Σ) 6|= C can be checked using an arbitrary sound and complete first-order calculus. In Section 4 we discuss the relationship between MFA and existing notions, and we show that MFA generalises most of them.\nThe following proposition shows that MFA characterises the derivations of the skolem chase in which no cyclic terms occur.\nProposition 5. A set Σ of rules is not MFA w.r.t. an instance I if and only if I∞MFA(Σ) contains a cyclic term.\nProof. Let Σ′ = MFA(Σ), and let I0Σ′ , I 1 Σ′ , . . . be the chase sequence for I and Σ ′. Moreover, let f ir be the function symbol used to skolemise the i-th existentially quantified variable in rule r, as defined in Section 2.2. We next prove that the following claims hold for all terms t and t′ occurring in IkΣ′ , each rule r, each integer i, and each integer k, as well as k =∞.\n1. Term t is of the form f ir(~u) if and only if F i r(t) ∈ IkΣ′ .\n2. Term t is of the form f ir(~u) and t ′ ∈ ~u if and only if S(t′, t) ∈ IkΣ′ .\n3. If t′ is a proper subterm of t, then D(t′, t) ∈ Ik+2Σ′ ; furthermore, D(t ′, t) ∈ I∞Σ′ if and\nonly if t′ is a proper subterm of t.\n1. In the rest of this paper we often omit ‘universally’; furthermore, when used as an acyclicity notion, MFA means ‘universally MFA’.\n(Claims 1 and 2, direction ⇒) The proof is by induction on k. Set I0Σ′ does not contain functional terms, and so it clearly satisfies both claims. For the induction step, assume that both claims hold for Ik−1Σ′ and consider I k Σ′ . Since I k−1 Σ′ ⊆ I k Σ′ , both claims clearly hold for each term t that occurs in Ik−1Σ′ . Consider an arbitrary term t of the form f i r(~u) that does not occur in Ik−1Σ′ , and an arbitrary term t ′ ∈ ~u. Clearly, t is introduced into IkΣ′ by an application of the skolemisation of MFA(r) for some rule r ∈ Σ. Since the head of MFA(r) contains atoms Fir(yi) and S(xj , yi) for each xj ∈ ~x, we have Fir(t) ∈ IkΣ′ and S(t′, t) ∈ IkΣ′ for each t′ ∈ ~u, and so we have Fir(t) ∈ I∞Σ′ and S(t′, t) ∈ I∞Σ′ for each t′ ∈ ~u as well. Finally, since I∞Σ′ = ⋃ k I k Σ′ , these claims clearly hold for k =∞.\n(Claims 1 and 2, direction⇐) Predicate S and each predicate Fir occur in Σ′ only in head atoms of the form Fir(yi) and S(xj , yi); hence, the skolemised rules contain these predicates only in head atoms of the form Fir(f i r(~x)) and S(xj , f i r(~x)), which clearly implies our claim.\n(Claim 3, the first part for k 6=∞) The proof is by induction on k. The base case holds vacuously since I0Σ′ does not contain functional terms. Assume now that the claim holds for some k − 1, and consider an arbitrary term t = f ir(~u) occurring in IkΣ′ such that t′ is a subterm of some ti ∈ ~u. By Claim 2, we have S(ti, t) ∈ IkΣ′ ; furthermore, ti occurs in Ik−1Σ′ , so by the induction assumption we have D(t\n′, ti) ∈ Ik+1Σ′ . Finally, the rules without functional terms are applied before the rules with functional terms; hence, by rule (19) we have D(t′, t) ∈ Ik+2Σ′ , as required.\n(Claim 3, the second part) The ‘proper subterm’ relation is transitive, and rules (18) and (19) effectively define D as the transitive closure of S, which clearly implies this claim.\nAssume now that I∞Σ′ contains a cyclic term t. Then, some term t1 = f i r(~s) is a subterm of t and some term t2 = f i r(~u) is a proper subterm of t1. By Claims 1 and 3, then we have {Fir(t2),D(t2, t1),Fir(t1)} ⊆ I∞Σ′ . But then, since Σ′ contains rule (20), we have C ∈ I∞Σ′ , so Σ is not MFA. For the converse claim, assume that Σ is not MFA w.r.t. an instance I. Then, by Definition 3 we have that I ∪MFA(Σ) |= C. Since the special nullary predicate C occurs only on the right-hand side of rule (20), there exist terms t1 and t2, a rule r ∈ Σ, and a predicate Fir such that {Fir(t1),D(t1, t2),Fir(t2)} ⊆ I∞Σ′ . Since Fir(t1) and Fir(t2) are contained in I∞Σ′ , Claim 1 implies that t1 and t2 are of the form t1 = f i r( ~u1) and t2 = f i r( ~u2), respectively. Finally, D(t1, t2) ∈ I∞Σ′ and Claim 3 imply that t1 is a proper subterm of t2, so I∞Σ′ contains a cyclic term.\nThis characterisation implies termination of skolem chase of MFA rules Σ in 2ExpTime. In particular, a term t derived by the skolem chase of Σ′ = MFA(Σ) cannot be cyclic by Proposition 5; such t can then be seen as a tree with branching factor bounded by the maximum arity of a function symbol in sk(Σ′) and with depth bounded by the number of function symbols in sk(Σ′). The chase can thus generate at most a doubly exponential number of different terms and atoms. The 2ExpTime bound already holds if the rules are WA (Cal̀ı et al., 2010b), so CQ answering for MFA rules is not harder than for WA rules.\nProposition 6. If a set of rules Σ is MFA w.r.t. an instance I, then the skolem chase for I and Σ terminates in double exponential time.\nProof. Let Σ′ = MFA(Σ), let c, f , and p be the number of constants, function symbols, and predicate symbols, respectively, occurring in sk(Σ′), let ` be the maximum arity of a function symbol, and let a be the maximum arity of a predicate symbol in sk(Σ′). Consider\nnow an arbitrary term t occurring in I∞Σ′ ; clearly, t can be seen as a tree with branching factor ` containing constants in the leaf nodes and function symbols in the internal nodes; furthermore, since t is not cyclic, dep(t) ≤ f , the number of leaves is bounded by `f , and the total number of nodes is bounded by f · `f . Each node is assigned a constant or a function symbol, so the number of different terms occurring in I∞Σ′ is bounded by ℘ = (c+ f)\nf ·`f , and the number of different atoms in I∞Σ′ is bounded by p · ℘a, which is clearly doubly exponential in Σ and I. Consequently, the size of I∞Σ′ is at most doubly exponential in Σ and I. Furthermore, for an arbitrary set of facts I ′ and rule r, the set r(I ′) can be computed by examining all mappings of the variables in r to the terms occurring in I ′, which requires exponential time in the size of r and polynomial time in the size of I ′. Consequently, I∞Σ′ can be computed in time that is double exponential in I and Σ. Finally, it is straightforward to see that I∞Σ ⊆ I∞Σ′ , so I∞Σ can be computed in double exponential time as well.\nBy Proposition 6, answering a BCQ over MFA rules is in 2ExpTime. We next prove that checking MFA w.r.t. a specific instance I is also in 2ExpTime, and that checking universal MFA is 2ExpTime-hard. This provides tight complexity bounds for both problems. Towards this goal, we first establish in Lemma 7 a relationship between answering certain kinds of queries over certain kinds of rules and checking whether a related set of rules is universally MFA; we use this relationship in several hardness proofs in the rest of this paper. Then, in Theorem 8 we present our main complexity result.\nLemma 7. Let Σ be a set of weakly acyclic, constant-free, equality-free, and connected rules with predicates of nonzero arity, let A and B be unary predicates, let R be a fresh binary predicate, let a be a constant, and let Ω be Σ extended with rule (23).\nR(z, x) ∧B(x)→ ∃y.[R(x, y) ∧A(y)] (23)\nThen, we have {A(a)} ∪ Σ 6|= B(a) if and only if Ω is universally MFA.\nProof. Let I = {A(a)}, and let I0Σ, I1Σ, . . . be the chase sequence for I and Σ. Furthermore, let Ω′ = MFA(Ω), let J = I∗Ω, let J 0 Ω′ , J 1 Ω′ , . . . be the chase sequence for J and Ω\n′, and let f be the function symbol used to skolemise the existential quantifier in rule (23). Set Σ is constant-free, so a is the only constant occurring in each set IiΣ.\nWe next show that the facts in J jΩ′ are of a certain form. To this end, for each ` ≥ 0, let t` = f(. . . f(∗) . . .) where the function symbol f is repeated ` times (by this definition, we have t0 = ∗); also, each term or fact obtained from t` by zero or more applications of predicates or function symbols not in {f,D, S,C, R} is of level `. By induction on the chase sequence for J and Ω′, we next prove that the sequence satisfies the following property ( ):\nfor each fact F ∈ J jΩ′ , some integer ` exists such that F is of the form R(∗, ∗) or R(t`, t`+1), or the predicate of F is contained in {D, S,C}, or F is an `-level fact and the predicate of F is not contained in {D, S,C, R}.\nSet J0Ω′ = J clearly satisfies property ( ) since each fact in it is clearly of level 0. Now assume that J jΩ′ satisfies property ( ) for some j, and consider an application of a rule r ∈ Ω\n′. If r corresponds to rule (18), (19), (20), or (23), then the result of the rule application clearly satisfies property ( ). Otherwise, r is safe and no body atom contains a predicate in\n{D, S,C, R}; by induction assumption, then some atom is matched to a fact of some level `; the body atoms of r are connected, so all body atoms are matched to facts of the same level; finally, the head atoms of r contain function symbols different from f , but no constants or predicates of zero arity, so each fact derived by an atom in the head of r either contains predicate S or is of level `.\nWe next show that the chase sequences for I and Σ, and for J and Ω′ are related by the following property (♦):\nfor each fact F ′ of level 1 and the fact F obtained by replacing each t1 in F ′ with a, we have F ∈ IiΣ for some i if and only if F ′ ∈ J j Ω′ \\ J for some j.\nThe proof of (♦) is straightforward: J contains R(∗, ∗) and B(∗), so J1Ω′ contains R(∗, f(∗)) and A(f(∗)); moreover, due to ( ), term t1 plays in the chase sequence for J and Ω′ the ‘same role’ as constant a in the chase sequence for I and Σ, so the rule applications to facts of level 1 in the former chase sequence correspond one-to-one with rule applications in the latter chase sequence. We omit the formal details for the sake brevity.\nNow assume that {A(a)} ∪ Σ |= B(a). Then, B(a) ∈ IiΣ holds for some i. By property (♦), then integer j exists such that B(f(∗)) ∈ J jΩ′ . But then, due to rule (23), some ` ≥ j exists such that A(f(f(∗))) ∈ J `Ω′ . By Proposition 5, then Ω is not universally MFA.\nConversely, assume that {A(a)} ∪ Σ 6|= B(a). Since Σ is weakly acyclic and equalityfree, Σ is super-weakly acyclic (Marnette, 2009); as we will show in Section 4 (see Theorem 19), Σ is then MFA as well. Now consider an arbitrary integer j and fact F ∈ J jΩ′ . If F is of level 0 or 1, since Σ is MFA, fact F does not contain a cyclic term. Furthermore, B(a) 6∈ I∞Σ so, by property (♦), fact F is not of the form B(f(∗)); thus, rule (23) does not ‘fire’ to introduce facts of level greater than 1. Consequently, F does not contain a cyclic term, and so, by Proposition 5, the set Ω is universally MFA.\nTheorem 8. Given a set of rules Σ, deciding whether Σ is MFA w.r.t. an instance I is in 2ExpTime, and deciding whether Σ is universally MFA is 2ExpTime-hard. Both results hold even if the arity of predicates in Σ is bounded.\nProof. (Membership) Let Σ′ = MFA(Σ), let I0Σ′ , I 1 Σ′ , . . . be the chase sequence for I and Σ ′, and let ℘, p, and a be as stated in the proof of Proposition 6. The number of different atoms that can be constructed from ℘ terms is bounded by k = p · ℘a; note that this is double exponential even if a is bounded. Let k′ = k + 4; we next show that whether Σ is MFA w.r.t. I can be decided by constructing Ik\n′ Σ′ and then checking whether C ∈ Ik ′ Σ′ . As in\nthe proof of Proposition 6, the latter can be done in double exponential time. If IkΣ′ = I k′ Σ′ , then I ∞ Σ′ = I k Σ′ , so Σ is not MFA if and only if C ∈ IkΣ′ . Otherwise, we have IkΣ′ ( I k′ Σ′ ; but then, I k+1 Σ′ clearly contains at least one cyclic term t = f i r(~t) such that t′ = f ir(~s) is a subterm of some ti ∈ ~t. Since Ik+1Σ′ satisfies Claims 1–3 from the proof of Proposition 5, we have D(ti, t) ∈ Ik+3Σ′ ; by rule (20) and the fact that rules without functional terms are applied before rules with functional terms, we have C ∈ Ik′Σ′ ; thus, C ∈ I∞Σ′ , so Σ is not MFA by Proposition 5.\n(Hardness) We prove the claim by a reduction from the problem of checking I ∪ Σ |= Q, where Σ is a weakly acyclic set of equality-free rules and with predicates of bounded arity,\nI is an instance, and Q = ∃~y.ξ(~y) is a Boolean conjunctive query. Cal̀ı et al. (2010b) show that, for such I, Σ, and Q, deciding I ∪ Σ |= Q is 2ExpTime-complete. We next transform I, Σ, and Q so that we can apply Lemma 7, which proves our claim.\nLet Σ1 = Σ ∪ {ξ(~y)→ B} where B is a fresh predicate of zero arity; clearly, I ∪ Σ |= Q holds if and only if I ∪ Σ1 |= B holds.\nLet Σ2 and I2 be obtained by eliminating constants from the rules in Σ1; that is, we initially set I2 = I and then, for each rule r ∈ Σ and each constant c occurring in r, we replace all occurrences in c with a fresh variable wc, add an atom Oc(wc) to the body of r where Oc is a fresh predicate uniquely associated with c, and add a fact Oc(c) to I2. It is straightforward to see that I ∪ Σ1 |= B if and only if I2 ∪ Σ2 |= B.\nFinally, to transform Σ2 and I2 into Σ3, we define some notation. Let P̂ be a fresh n+1ary predicate unique for each n-ary predicate P , and let w be a fresh variable not occurring in Σ2. For a conjunction of atoms ϕ, let ϕ̂ = ∧ P (~t)∈ϕ P̂ (~t, w). Rule (24) is obtained from I2 as specified below, where A is a fresh unary predicate, each constant c occurring in I2 is associated with a distinct, fresh variable vc, and ~vc is the vector of all such variables:\nA(w)→ ∃~vc. ∧\nP (c1,...,ck)∈I2\nP̂ (vc1 , . . . , vck , w) (24)\nFinally, the set Σ3 contains rule (24) and a rule\nϕ̂(~x, ~z, w)→ ∃~y.ψ̂(~x, ~y, w) for each rule ϕ(~x, ~z)→ ∃~y.ψ(~x, ~y) in Σ2. (25)\nClearly, all predicates in Σ3 are of nonzero arity; all rules in Σ3 are constant-free and connected; and A occurs only in the body of rule (24) and Σ2 is WA, so Σ3 is WA as well. Finally, let I3 = {A(a)} where a is a fresh constant; by induction on the chase sequences for Σ2 and I2, and Σ3 and I3, it is straightforward to show that, for each integer i and each fact P (c1, . . . , ck), we have P (c1, . . . , ck) ∈ (I2)iΣ2 if and only if P̂ (fc1(a), . . . , fck(a), a) ∈ (I3) i+1 Σ3\n, where fc1 , . . . , fck are the skolem functions used to skolemise vc1 , . . . , vck in rule (24). Thus, I2 ∪ Σ2 |= B if and only if I3 ∪ Σ3 |= B̂(a), which by Lemma 7 implies our claim.\nThe results of Theorem 8 are somewhat discouraging: known acyclicity notions can typically be checked in PTime or in NP. We consider MFA to be an ‘upper bound’ of practically useful acyclicity notions. We see two possibilities for improving these results. In Section 3.3 we introduce an approximation of MFA that is easier to check; our experiments (see Section 7) show that this notion often coincides with MFA in practice. Furthermore, we show next that the complexity is lower for rules of the following shape.\nDefinition 9. A rule r of the form (5) is an ∃-1 rule if ~y is empty or ~x contains at most one variable.\nAs we discuss in the following sections, ∃-1 rules capture (extensions of) Horn DLs. We next show that BCQ answering and MFA checking for ∃-1 rules is easier than for general rules. Intuitively, if Σ is MFA and contains only ∃-1 rules, then all functional terms in sk(MFA(Σ)) are unary and hence the number of different terms and atoms derivable by chase becomes exponentially bounded, as shown by the following theorem.\nTheorem 10. Let Σ be a set of ∃-1 rules, and let I be an instance. Checking whether Σ is MFA w.r.t. I is in ExpTime, and checking whether Σ is universally MFA is ExpTime-hard. Moreover, if Σ is MFA w.r.t. I, then answering a BCQ over Σ and I is ExpTime-complete.\nProof. We defer the proof of both hardness claims to Section 6, which deals with an even smaller class of rules that correspond to Horn description logic ontologies. In particular, we prove hardness of BCQ answering in Lemma 59, and hardness of checking whether Σ is MFA w.r.t. I in Lemma 60. In the rest of this proof, we show both membership results.\nLet Σ′ = MFA(Σ); let c be the number of constants in an instance; and let f be the number of function symbols in the rules. Since Σ contains only ∃-1 rules, Σ′ also contains only ∃-1 rules; consequently, all functional terms in sk(Σ′) are of arity 1. Hence, each noncyclic term can be understood as a sequence of at most f function symbols, so the total number of different noncyclic terms is bounded by ℘ = c · (f + 1)f . The total number of atoms is bounded by p · ℘a, where p is the number of predicates and a is the maximum arity of a predicate in Σ′. Note that this is exponential even if a is fixed. As in the proof of Proposition 6, we can now show that either the chase for Σ′ and I terminates or a cyclic term is derived in exponential time, which proves that the complexity of checking whether Σ is MFA w.r.t. I is in ExpTime.\nFinally, since I∞Σ ⊆ I∞Σ′ , if Σ is MFA, then I∞Σ can be computed in exponential time, so a BCQ over Σ and I can be answered in ExpTime."
    }, {
      "heading" : "3.3 Model-Summarising Acyclicity (MSA)",
      "text" : "The high cost of checking MFA of Σ arises because the arity of function symbols in sk(Σ) is unbounded and the depth of cyclic terms can be linear in Σ. To obtain an acyclicity notion that is easier to check, we must coarsen the structure used for cycle analysis. We thus next introduce model-summarising acyclicity, which ‘summarises’ the models of Σ by reusing the same constant to satisfy an existential quantifier, instead of introducing ‘deep’ terms.\nDefinition 11. Let S, D, and Fir be as specified in Definition 3; furthermore, for each rule r = ϕ(~x, ~z)→ ∃~y.ψ(~x, ~y) and each variable yi ∈ ~y, let cir be a fresh constant unique for r and yi. Then, MSA(r) is the following rule, where θMSA is the substitution that maps each variable yi ∈ ~y to cir:\nϕ(~x, ~z)→ ψ(~x, ~y)θMSA ∧ ∧ yi∈~y Fir(yi)θMSA ∧ ∧ xj∈~x S(xj , yi)θMSA  For a set Σ of rules, MSA(Σ) is the smallest set that contains MSA(r) for each rule r ∈ Σ, rules (18)–(19), and rule (20) instantiated for each predicate Fir. Set Σ is modelsummarising acyclic (MSA) w.r.t. an instance I if I ∪MSA(Σ) 6|= C; furthermore, Σ is universally MSA if Σ is MSA w.r.t. I∗Σ.\nExample 12. Consider again the set of rules Σ from Example 1. MSA(r1) and MSA(r3) are given by rules (26) and (27), respectively; since r1 and r3 contain a single existentially quantified variable each, we omit the superscripts in Fr1, Fr3, cr1, and cr3 for the sake of\nclarity. Thus, MSA(Σ) consists of rules (14), (16), and (17), rules (26)–(27), rules (18)– (19), and rule (20) instantiated for Fr1 and Fr3.\nA(x1)→ R(x1, cr1) ∧B(cr1) ∧ Fr1(cr1) ∧ S(x1, cr1) (26) B(x3)→ R(x3, cr3) ∧ C(cr3) ∧ Fr3(cr3) ∧ S(x3, cr3) (27)\nThe following table shows the chase sequence for I∗Σ and MSA(Σ).\nA(∗) R(∗, cr1) R(cr1 , cr3) D(cr1 , cr3) B(∗) R(∗, cr3) D(cr3) C(∗) B(cr1) S(cr1 , cr3) D(∗) C(cr3) D(∗, cr3)\nR(∗, ∗) S(∗, cr1) D(∗, cr1) S(∗, cr3) Fr1(cr1)\nFr3(cr3)\nThe result of the chase does not contain C, and so Σ is universally MSA. ♦\nNote that MSA(Σ) is equivalent to a set of datalog rules: the only minor difference is that the rules in MSA(Σ) can contain several head atoms, but such rules can clearly be transformed into equivalent datalog rules. Thus, MSA can be checked using a datalog reasoner. This connection with datalog and the complexity results by Dantsin, Eiter, Gottlob, and Voronkov (2001) for checking entailment of a ground atom in a datalog program provide us with the upper complexity bound for checking MSA in Theorem 13. The complexity of datalog reasoning is O(r · nv) where r is the number of rules, v is the maximum number of variables in a rule, and n is the size of the set of facts that the rules are applied to; thus, checking MSA should be feasible if the rules in Σ are ‘short’ and so v is ‘small’.\nTheorem 13. For Σ a set of rules, deciding whether Σ is MSA w.r.t. an instance I is in ExpTime, and deciding whether Σ is universally MSA is ExpTime-hard. The two problems are in coNP and coNP-hard, respectively, if the arity of the predicates in Σ is bounded.\nProof. (Membership) Let Σ′ = MSA(Σ), and note that Σ is MSA w.r.t. I if and only if I ∪ Σ′ 6|= C if and only if C 6∈ I∞Σ′ . The total number of atoms occurring in I∞Σ′ is p ·ca, where p is the number of predicates, c is the number of constants, and a is the maximum arity of the predicates in Σ′; this number is clearly exponential if a is not bounded. The rest of the proof is the same as in Theorem 8.\nAssume now that a is bounded; then the number of ground atoms in I∞Σ′ becomes polynomial. Furthermore, by the definition of the chase, C ∈ I∞Σ′ if and only if there exist a sequence of rules r1, . . . , rn of the form ri = ϕi → ψi and a sequence of substitutions σ1, . . . , σn such that ϕσi ⊆ I ∪ {ψjσj | j < i} ⊆ I∞Σ′ for each 1 ≤ i ≤ n and ψnσn = C. Clearly, we can assume that n ≤ p · ca, which is polynomial. Thus, we can guess the two sequences in nondeterministic polynomial time, and we can check the required property in polynomial time. Thus, I ∪ Σ′ |= C can be checked in nondeterministic polynomial time, so checking whether Σ is MSA w.r.t. I is in coNP.\n(Hardness) Let Σ be a set of datalog rules, let I be an instance, and let Q be ground atom. Checking whether I ∪ Σ |= Q is ExpTime-complete in general (Dantsin et al., 2001). Furthermore, the problem is NP-hard if the arity of predicates is bounded: a rule in Σ can encode an arbitrary Boolean conjunctive query with atoms of bounded arity but arbitrarily many variables, for which answering is well known to be NP-hard.\nLet Σ4 and I4 be obtained from Σ as in the proof of Theorem 8; then, I ∪ Σ |= Q if and only if I4 ∪ Σ4 |= B(a), and the set of rules Ω obtained from Σ4 as specified in Lemma 7 is universally MFA if and only if I4 ∪ Σ4 6|= B(a). Finally, the only existential variable in Ω occurs in a rule of the form (23), so it is straightforward to see that Ω is universally MFA if and only if T ′ is universally MSA.\nBefore concluding this section, we present Theorem 14 and Example 15, which together show that MFA is strictly more general than MSA.\nTheorem 14. If a set of rules Σ is MSA (w.r.t. an instance I), then Σ is MFA (w.r.t. I) as well.\nProof. Let Σ1 = MFA(Σ) and let Σ2 = MSA(Σ). Furthermore, let h be the mapping of ground terms to constants defined such that h(t) = cir if t is of the form f i r(. . .), and h(t) = t if t is a constant; for an atom A = P (t1, . . . , tn), let h(A) = P (h(t1), . . . , h(tn)); and for an instance I, let h(I) = {h(A) | A ∈ I}. Finally, let I0Σ1 , I 1 Σ1 , . . . be the chase sequence for I and Σ1, and let I 0 Σ2 , I1Σ2 , . . . be the chase sequence for I and Σ2. Note that sk(Σ2) = Σ2 differs from sk(Σ1) only in that the former contains the constant c i r in place of each functional term f ir(~x). Please note that, although our definition of the chase applies rules with function symbols after rules without function symbols, one can clearly construct the chase of the function-free set of rules Σ2 using any order of rule applications, including the one corresponding to the order of rule applications in the chase of Σ1. Assuming this slight modification, one can show by a straightforward induction on i that h(IiΣ1) ⊆ I i Σ2\nfor each i; this implies h(I∞Σ1) ⊆ I ∞ Σ2 . Consequently, C 6∈ I∞Σ2 clearly implies C 6∈ I ∞ Σ1\n; hence, if Σ is MSA, then Σ is MFA as well, as required.\nExample 15. Let Σ be the set of rules (28)–(31).\nr1 = A(x)→ ∃y.R(x, y) ∧B(y) (28) r2 = B(x)→ ∃y.S(x, y) ∧ T (y, x) (29) r3 = A(z) ∧ S(z, x)→ C(x) (30) r4 = C(z) ∧ T (z, x)→ A(x) (31)\nIt is straightforward to check that Σ is universally MFA, but not universally MSA. ♦"
    }, {
      "heading" : "3.4 Acyclicity Notions and Normalisation",
      "text" : "As mentioned in Section 2.5, existential rules are often normalised into a particular form; however, this cannot destroy acyclicity: if a set of rules Σ is MFA, then each set of rules obtained from Σ by normalisation is MFA as well. This claim involves certain technical assumptions about the treatment of equality, which is why we postpone a formal proof of this statement until Section 5. Next, however, we show that normalisation can have a positive effect on acyclicity.\nExample 16. Let Σ be the set containing only the following rule:\nA(x)→ ∃y.[B(x) ∧A(y)] (32)\nAs specified in Section 2.2, this rule is skolemised as follows, which causes that the skolem chase of Σ and instance I = {A(a)} does not terminate.\nA(x)→ B(x) ∧A(f(x)) (33)\nNote, however, that atoms B(x) and A(y) in the head of the rule do not share variables, so we can normalise this rule as follows, where Q is a fresh predicate of zero arity:\nA(x)→ B(x) ∧Q (34) Q→ ∃y.A(y) (35)\nIt is straightforward to check that this normalised set of rules is MFA; in fact, the normalised set of rules is even JA. Intuitively, normalisation, as defined in Section 2.5, ensures that each functional symbol introduced during normalisation depends on as few variables in the rule as possible. ♦\nNormalisation, however, can have a negative effect on universal termination, as shown by the following example.\nExample 17. Let Σ be the set containing only the following rule:\nC(z) ∧R(z, x) ∧B(x)→ ∃y1∃y2.[R(x, y1) ∧R(y1, y2) ∧B(y2)] (36)\nOne can readily check that Σ is universally MFA. Now let Σ′ be the following set of rules, which is obtained by replacing conjunction R(y1, y2) ∧B(y2) in the rule head with Q(y1):\nC(z) ∧R(z, x) ∧B(x)→ ∃y1.[R(x, y1) ∧Q(y1)] (37) Q(y1)→ ∃y2.[R(y1, y2) ∧B(y2)] (38)\nLet f1 and f2 be function symbols used to skolemise the existential quantifier in rule (37) and (38), respectively. Since Q(∗) ∈ I∗Σ′, the chase of Σ′ and I∗Σ′ derives R(∗, f2(∗)) and B(f2(∗)); but then, these facts, C(∗), and rule (37) derive Q(f1(f2(∗))), after which rule (38) derives R(f1(f2(∗)), f2(f1(f2(∗)))) and B(f2(f1(f2(∗)))). The chase of Σ′ and I∗Σ′ thus contains a cyclic term, so Σ′ is not universally MFA.\nIntuitively, this problem occurs because the critical instance I∗Σ′ for Σ ′ also instantiates the predicate Q introduced during normalisation. Such predicates, however, cannot occur in arbitrary input instances, so we can use the critical instance for Σ. Since Q(∗) 6∈ I∗Σ, the skolem chase of Σ′ and I∗Σ does not derive a cyclic term, from which we can conclude that the skolem chase of Σ′ terminates on each instance I that contains facts constructed using only the predicates occurring in Σ. ♦"
    }, {
      "heading" : "4. Relationship with Known Acyclicity Notions",
      "text" : "Many acyclicity notions have been proposed in the literature, but the relationships between them have been only partially investigated. We next investigate the relationship between MFA, MSA, and the acyclicity notions known to us, and we produce a detailed picture of their relative expressiveness. We show that MFA and MSA generalise most of these notions."
    }, {
      "heading" : "4.1 Acyclicity in Databases",
      "text" : "Acyclicity notions have been considered in databases in data integration and data exchange scenarios. Weak acyclicity (Fagin et al., 2005) was one of the first such notions, and it has spurred on the research into more sophisticated notions for ensuring chase termination."
    }, {
      "heading" : "4.1.1 Super-Weak Acyclicity",
      "text" : "Marnette (2009) proposed super-weak acyclicity (SWA), which generalises weak acyclicity provided that the rules are equality-free. We next recapitulate the definition of SWA, and then we show that MSA and MFA are strictly more general than SWA.\nDefinition 18. Let Σ be a set of existential rules in which no variable occurs in more than one rule, and let θsk be the substitution used to skolemise the rules in Σ.\n2 A place is a pair 〈A, i〉 where A is an n-ary atom occurring in a rule in Σ and 1 ≤ i ≤ n. A set of places P ′ covers a set of places P if, for each place 〈A, i〉 ∈ P , a place 〈A′, i′〉 ∈ P ′ and substitutions σ and σ′ exist such that Aσ = A′σ′ and i = i′. Given a variable w occurring in a rule r = ϕ→ ∃~y.ψ, sets of places In(w), Out(w), and Move(w) are defined as follows:\n• set In(w) contains each place 〈R(~t), i〉 such that R(~t) ∈ ϕ and ti = w;\n• set Out(w) contains each place 〈R(~t)θsk, i〉 such that R(~t) ∈ ψ and ti = w; and\n• set Move(w) is the smallest set of places such that\n– Out(w) ⊆ Move(w) and – Out(w′) ⊆ Move(w) for each variable w′ that is universally quantified in some\nrule in Σ such that Move(w) covers In(w′).\nThe SWA dependency graph SWA(Σ) of Σ contains a vertex for each rule of Σ, and an edge from a rule r ∈ Σ to a rule r′ ∈ Σ if a variable x′ occurring in both the body and the head of r′ and an existentially quantified variable y occurring in the head of r exists such that Move(y) covers In(x′). Set Σ is super-weakly acyclic (SWA) if SWA(Σ) is acyclic.\nMarnette (2009) uses a slightly different definition: the notation for places is the same as our notation for positions; a variable may occur in more than one rule so sets In(w), Out(w), and Move(w) are defined w.r.t. a rule and a variable; and a rule trigger relation is used instead of the SWA dependency graph. For simplicity, Definition 18 introduces SWA in the same style as JA; however, both definitions capture the same class of rules.\nThe following theorem shows that MSA is more general than SWA. Furthermore, in Example 12 we argued that the set of rules Σ from Example 1 is MSA, and one can readily check that Σ is not SWA. Consequently, MSA is strictly more general than SWA.\nTheorem 19. If a set of rules Σ is SWA, then Σ is universally MSA.\n2. Substitution θsk is unique for each rule in Section 2.2; however, since each variable in Σ occurs in at most one rule, w.l.o.g. we can take θsk as the substitution used to skolemise all the rules in Σ.\nProof. Let Σ′ = MSA(Σ), let I0, I1, . . . be the chase sequence for I∗Σ and Σ ′, and let I∞ be the chase of I∗Σ and Σ ′. Furthermore, let ρ be the function that maps constants to themselves and that maps ground functional terms as ρ(f ir(~t)) = c i r, where f i r and c i r were introduced in Section 2.2 and Definition 11, respectively. Finally, let ρ(P (t1, . . . , tn)) = P (ρ(t1), . . . , ρ(tn)). We next prove the following property ( ): for each rule r ∈ Σ, each existentially quantified variable yi occurring in r, each P (~t) ∈ I∞ where P 6∈ {S,D,C}, and each tj ∈ ~t such that tj = c i r, a substitution τ and a place 〈A, j〉 ∈ Move(yi) exist such that P (~t) = ρ(Aτ). The proof is by induction on the length of the chase. Since I0 = I∗Σ does not contain a constant of the form cir, property ( ) holds vacuously for I\n0. Assume now that property ( ) holds for some Ik−1, and consider an arbitrary rule r ∈ Σ, an existentially quantified variable yi in r, a fact P (~t) ∈ Ik \\ Ik−1 with P 6∈ {S,D,C}, and a term tj ∈ ~t such that tj = cir. Fact P (~t) is derived in Ik from the head atom H of some rule r1 ∈ MSA(Σ). Let σ be the substitution used in the rule application; clearly, we have Hσ = P (~t). Furthermore, let r2 ∈ Σ be the rule such that r1 = MSA(r2), let r3 = sk(r2), and let H3 be the head atom of r3 that corresponds to H; clearly, we have ρ(H3σ) = P (~t). Now if H has cir in position j, then r = r 1 since r1 is the only rule that contains cir; thus, 〈H3, j〉 ∈ Out(yi) ⊆ Move(yi), so property ( ) holds. Otherwise, H contains at position j a universally quantified variable x such that σ(x) = cir. Let B1, . . . , Bn be the body atoms of r\n1 that contain x; clearly, {B1σ, . . . , Bnσ} ⊆ Ik−1. All these atoms satisfy the induction assumption, so for each Bm ∈ {B1, . . . , Bn} and each ` such that Bm contains variable x at position `, a place 〈B′m, `〉 ∈ Move(yi) and substitution τm exist such that Bmσ = ρ(B ′ mτ\nm). Let σ′ be the substitution obtained from σ by setting σ′(w) = τm(w) for each variable w for which τm(w) is a functional term; clearly, Bmσ ′ = B′mτ m. But then, Move(yi) covers In(x); hence, by the definition of Move, we have that 〈H3, j〉 ∈ Move(yi), so property ( ) holds. We additionally prove the following property (♦): if S(cir, c i′ r′) ∈ I∞ for some i and i′, then SWA(Σ) contains an edge from r to r′. Consider an arbitrary such fact, let yi be the existentially quantified variable of r corresponding to cir, and let k be the smallest integer such that S(cir, c i′ r′) ∈ Ik. Clearly, S(cir, ci ′ r′) is derived in I k from the head atom S(x, ci ′ r′) of rule r′. Let σ be the substitution used in the rule application; thus, σ(x) = cir. Let B1, . . . , Bn be the body atoms of r that contain x; clearly, we have {B1σ, . . . , Bnσ} ⊆ Ik−1. All these atoms satisfy property ( ), so for each Bm ∈ {B1, . . . , Bn} and each ` such that Bm contains variable x at position `, a place 〈B′m, `〉 ∈ Move(yi) and substitution τm exist such that Bmσ = ρ(B ′ mτ\nm). But then, as in the previous paragraph we have that Move(yi) covers In(x), so SWA(Σ) contains an edge from r to r′.\nAssume now that Σ is not MSA, so C ∈ I∞; then {Fir(t),D(t, t′),Fir(t′)} ⊆ I∞ holds for some Fir due to rules (20). But then, since predicate F i r occurs in Σ ′ only in an atom Fir(c i r), we have t = t′ = cir. Finally, since D is axiomatised in Σ ′ as the transitive closure of S, clearly SWA(Σ) contains a path from r to itself, and so Σ is not SWA.\nThe rule set in Example 1 is MSA but not SWA. Furthermore, it is known that SWA is more general than JA, and the two notions differ only if at least one rule contains a body atom in which at least one variable occurs more than once (Krötzsch & Rudolph, 2013). The following example shows that SWA is strictly more general than JA.\nExample 20. Let Σ be the set of the following rules:\nr1 = A(x1)→ ∃y.R(x1, y) ∧R(y, x1) ∧R(x1, x1) (39)\nr2 = R(x2, x2)→ B(x2) (40) r3 = B(x3)→ A(x3) (41)\nOne can readily verify that Σ is SWA, but not JA. ♦\nTheorem 19 holds even if Σ contains the equality predicate, but provided that the axiomatisation of equality (cf. Section 2) is taken as part of the input. On such rule sets, however, SWA, JA, MSA, and MFA are not strictly more general than WA. We discuss the underlying problems, as well as possible solutions, in Section 5."
    }, {
      "heading" : "4.1.2 Acyclicity by Rewriting",
      "text" : "Spezzano and Greco (2010) proposed an acyclicity notion called Adn-WA. Roughly speaking, one first rewrites a set of rules Σ into another set of rules Σ′ by adorning the positions in the predicates that can contain infinitely many terms during the chase; then, one checks whether Σ′ is WA. The rewriting algorithm is rather involved, so we do not recapitulate its definition; instead, we discuss it by means of an example. Spezzano and Greco used this example to show that Adn-WA is not subsumed by SWA, but the same example also shows that Adn-WA is not subsumed by MFA either.\nExample 21. Let Σ be the set containing the following rules:\nA(x)→ ∃y.R(x, y) (42) B(z) ∧R(z, x)→ A(x) (43)\nThe transformation by Spezzano and Greco (2010) produces a set Σ′ that consists of three groups of rules. The first group contains rules (44)–(47).\nAb(x)→ ∃y.Rbf (x, y) (44) Bb(z) ∧Rbb(z, x)→ Ab(x) (45) Bb(z) ∧Rbf (z, x)→ Af (x) (46)\nAf (x)→ ∃y.Rff (x, y) (47)\nFor each n-ary predicate P , the transformation introduces predicates of the form Pm , where m is an adornment—a string of length n of letters b or f . Intuitively, if m contains letter b at position i, then during the chase construction the i-th position of Pm can contain only constants occurring in an instance. Rules (44)–(47) were derived as follows. Rule (44) is obtained from rule (42) by marking all positions of variable x with b, which effectively creates a variant of the rule whose body is applicable only to constants. Variable y in the head of rule (44) occurs under an existential quantifier, so the corresponding position is marked with f . Rule (45) is obtained from rule (43) in an analogous way. But then, since facts introduced by rule (44) can trigger an application of rule (43), the latter rule is marked as rule (46); predicate Af in the head of rule (46) reflects the fact that variable x in the rule body is instantiated by atom Rbf (z, x). Finally, facts derived by rule (46) can trigger an application of rule (42), so the latter rule is instantiated as (47). At this point the algorithm terminates: since no rule was instantiated with a marking Bf in the head, it is not possible to use predicate Rff to mark the body of rule (43) in a consistent way.\nThe second group consists of rules (48)–(50), which ‘populate’ the adorned predicates with the contents of an instance.\nR(x1, x2)→ Rbb(x1, x2) (48) A(x)→ Ab(x) (49) B(x)→ Bb(x) (50)\nThe third group consists of rules (51)–(56), which ‘gather’ the content of each adorned predicate Pm into a fresh output predicates P̂ .\nRbb(x1, x2)→ R̂(x1, x2) (51) Rbf (x1, x2)→ R̂(x1, x2) (52) Rff (x1, x2)→ R̂(x1, x2) (53)\nAb(x)→ Â(x) (54) Af (x)→ Â(x) (55) Bb(x)→ B̂(x) (56)\nIt is straightforward to check that Σ is not MFA. In contrast, Σ′ is WA; furthermore, Spezzano and Greco (2010) show that, for each instance I and each vector of ground terms ~t, we have P̂ (~t) ∈ I∞Σ′ if and only if P (~t) ∈ I∞Σ . Since Σ′ is WA, I∞Σ′ is finite, and, by the previously mentioned property, I∞Σ is finite as well. ♦\nThe following example shows that MFA is not subsumed by Adn-WA, which indicates that MFA and Adn-WA are incomparable.\nExample 22. Let Σ be the set containing the following rules:\nr1 = A(x)→ ∃y.R(x, y) ∧B(y) (57) r2 = S(z, x) ∧B(x)→ ∃y.S(x, y) (58)\nThe rules in the first group of the set Σ′ obtained by the transformation are shown below; we do not show the rules in the second and the third group for the sake of brevity.\nAb(x)→ ∃y.Rbf (x, y) ∧Bf (y) (59) Sbb(z, x) ∧Bb(x)→ ∃y.Sbf (x, y) (60) Sbf (z, x) ∧Bf (x)→ ∃y.Sff (x, y) (61) Sff (z, x) ∧Bf (x)→ ∃y.Sff (x, y) (62)\nThe last rule ensures that the WA dependency graph for Σ′ contains a special edge from position Sff |2 to itself; thus, Σ′ is not WA, and therefore Σ is not Adn-WA. In contrast, one can readily verify that Σ is MFA. ♦\nSpezzano and Greco (2010) also proposed several optimisations of this transformation, the discussion of which is out of scope of this paper. All of them can be seen as ‘unfolding’ the rules in Σ up to a certain number of chase steps. This seems close to an idea by Baget\net al. (2011b), who propose to run the chase for some fixed number of steps before checking for potential cycles. A similar effect could be obtained by extending the notion of MFA to check for terms that contain a function symbol nested some fixed number of times.\nFinally, note that the transformation by Spezzano and Greco (2010) is independent from the notion used to check the acyclicity of the transformed rule set; hence, given an arbitrary acyclicity notion X, one can define Adn-X in the obvious way. Given arbitrary notions X and Y such that X ⊆ Y , it is obvious that Adn-X ⊆ Adn-Y ; consequently, we have Adn-X 6⊆ MFA for each X such that WA ⊆ X. In contrast, however, it not obvious whether the inclusion between Adn-X and Adn-Y is strict whenever the inclusion between X and Y is strict, or whether MFA is contained in Adn-X for some X with WA ⊆ X. Finally, we conjecture that X ⊆ Adn-X holds for an arbitrary notion X, but we do not have a formal proof of this conjecture. Due to the complex nature of the rewriting, we refrain from further analysis of these relationships."
    }, {
      "heading" : "4.1.3 Monitor Graph",
      "text" : "Meier et al. (2009) propose an idea that is similar in spirit to MFA. The idea is to track each chase step in an additional data structure called the monitor graph. If the chase is infinite, then the monitor graph contains cycles of arbitrary length; conversely, if one can show that the monitor graph does not contain a cycle of some fixed length, then the chase is guaranteed to terminate. While this idea is closely related to MFA, note that the definition of MFA is semantic; hence, one can use an arbitrary theorem proving technique to check whether MFA(Σ) |= C. In contrast, the notion of a monitor graph is specifically tied to the nonoblivious chase. It is well known that the result of the nonoblivious chase depends on the order in which the rules applied; consequently, a set of rules can be identified as cyclic or acyclic depending on the selected rule application strategy. Because of this dependence, it is difficult to compare the monitor graph approach with other acyclicity notions."
    }, {
      "heading" : "4.2 Acyclicity in Knowledge Representation",
      "text" : "Existential rules can capture knowledge representation formalisms such as Horn fragments of description logics (see Section 6), conceptual graphs (Baget, 2004; Baget et al., 2011a), and datalog± rules (Cal̀ı et al., 2010a), and so acyclicity notions allow for materialisationbased query answering over knowledge bases. In this context, Baget (2004) and Baget et al. (2011a) proposed the notion of acyclic graph rule dependencies (aGRD). Intuitively, aGRD introduces a rule dependency relation ≺ for which r1 ≺ r2 means that an application of rule r1 on an instance I can subsequently trigger an application of rule r2. If the relation ≺ is acyclic, then no rule can trigger itself so the skolem chase terminates on an arbitrary instance. This can be formalised as follows.\nDefinition 23. The rule dependency relation ≺ ⊆ Σ× Σ on a set of rules Σ is defined as follows. Let r1 = ϕ1 → ∃~y1.ψ1 and r2 = ϕ2 → ∃~y2.ψ2 be arbitrary rules in Σ, and let sk(r1) = ϕ1 → ψ′1 and sk(r2) = ϕ2 → ψ′2. Then, r1 ≺ r2 if and only if there exist an instance I, a substitution σ1 for all variables in sk(r1), and a substitution σ2 for all variables in sk(r2) such that ϕ1σ1 ⊆ I, ϕ2σ2 6⊆ I, ϕ2σ2 ⊆ I ∪ ψ′1σ1, and ψ′2σ2 6⊆ I ∪ ψ′1σ1. Set Σ has an acyclic graph of rules dependencies (aGRD) if the relation ≺ on Σ is acyclic.\nDefinition 23 differs from the original definition by Baget (2004) in several ways. First, Baget uses fresh nulls to capture the effect of existential quantifiers, whereas Definition 23 uses skolem functions; however, this does not change the resulting relation ≺ in any way. Second, Baget does not require ψ′2σ2 6⊆ I ∪ ψ′1σ1. This condition intuitively ensures that an application of r1 to I enables r2 to derive something new; analogous optimisations were proposed by Deutsch et al. (2008) and Greco et al. (2012). It should be clear that Definition 23 is stronger than the one by Baget. To unify the notions used in various parts of this paper, we included this optimisation into Definition 23; however, we nevertheless call the resulting stronger notion aGRD.\nThe following example shows that aGRD, even in its weaker form as originally proposed by Baget (2004), is not contained in SWA.\nExample 24. Let Σ be the set consisting of the following rule:\nr = A(z1, x, z2) ∧B(z2)→ ∃y1∃y2.A(x, y1, y2) (63)\nTo see that r ≺ r does not hold, consider the skolemisation r′ of r:\nsk(r) = A(z1, x, z2) ∧B(z2)→ A(x, f1(x), f2(x)) (64)\nNow let I be an arbitrary instance, and let σ1 and σ2 be arbitrary substitutions such that {A(z1, x, z2)σ1, B(z2)σ1} ⊆ I and {A(z1, x, z2)σ2, B(z2)σ2} 6⊆ I. Since instance I contains only constants, atom A(x, f1(x), f2(x))σ1 is of the form A(a, f1(a), f2(a)); but then, for {A(z1, x, z2)σ2, B(z2)σ2} ⊆ I ∪ {A(a, f1(a), f2(a))} to hold, it must be that σ2(z2) = f2(a); thus, B(z2)σ2 = B(f2(a)) should be contained in I, which is impossible since I is an instance and thus does not contain functional terms. Note that the additional condition by Greco et al. (2012) plays no role here. Thus, we have r 6≺ r, so Σ is aGRD even in the weaker form by Baget (2004). However, one can easily check that Σ is not SWA. ♦\nHowever, aGRD seems to be a rather weak notion: as the following example shows, even a set of rules without existential quantifiers can be cyclic according to this criterion.\nExample 25. Let Σ be the set consisting of the following rules:\nr1 = A(x)→ B(x) (65) r2 = B(x)→ C(x) (66) r3 = C(x)→ A(x) (67)\nTo see that r1 ≺ r2, let I = {A(a)}, let σ = {x 7→ a}, and note that A(x)σ ∈ I, B(x)σ 6∈ I, B(x)σ ∈ I ∪ {B(x)σ}, and C(x)σ 6∈ I ∪ {B(x)σ}. Analogously, by taking I = {B(a)} we get r2 ≺ r3, and by taking I = {C(a)} we get r3 ≺ r1. Consequently, Σ is not aGRD. However, Σ is obviously WA since it does not contain existentially quantified variables. ♦\nBaget et al. (2011a) suggested that rule dependencies become more powerful if they are combined with an arbitrary acyclicity notion X. Intuitively, the main idea is to use ≺ to partition a set of rules into strongly connected components, and then check whether each component is X; we call this notion X≺. This idea can be formalised as follows.\nDefinition 26. Let Σ be a set of existential rules, and let ≺ be the rule dependency relation on Σ. Relation ≺ is extended to arbitrary sets C ⊆ Σ and C ′ ⊆ Σ such that C ≺ C ′ if and only if rules r ∈ C and r′ ∈ C ′ exist such that r ≺ r′. A dependency partition of Σ is a sequence of sets Σ1, . . . ,Σn such that Σ = ⋃n i=1 Σi, each Σi is a strongly connected component of ≺, and Σj 6≺ Σi for all i and j such that 1 ≤ i < j ≤ n. Let X be an arbitrary acyclicity notion. Then, Σ ∈ X≺ if a dependency partition Σ1, . . . ,Σn of Σ exists such that, for each 1 ≤ i ≤ n, we have Σi ∈ X, or Σi consists of a single rule ri such that ri 6≺ ri.\nIf Σ is aGRD, then each strongly connected component Σi contains a single rule ri such that ri 6≺ ri. Now if Definition 26 did not consider the special case where Σi consists of a single rule that does not depend on itself, then SWA≺ would not extend aGRD; for example, the rule in Example 24 would not be in SWA≺. The extra condition in Definition 26 thus ensures that aGRD is contained in X≺ regardless of the choice of X, and that aGRD can be understood as ∅≺—the acyclicity notion obtained by extending the empty notion (i.e., the notion under which no rule set is acyclic) with rule dependencies.\nWe next present two simple results. Proposition 27 precludes inclusions between certain acyclicity notions and will thus help us establish proper inclusions between many acyclicity notions. Furthermore, Proposition 28 shows that combining an acyclicity notion contained in SWA with rule dependencies creates a strictly stronger acyclicity notion; note that this holds even for the weaker form of rule dependencies originally proposed by Baget (2004).\nProposition 27. Let X and Y be acyclicity notions such that X ⊆ Y . Then, X≺ ⊆ Y ≺. Furthermore, if there exists a set Σ ∈ Y \\X whose rule dependency relation has a cycle containing all the rules from Σ, then Y 6⊆ X≺, Y ≺ 6⊆ X≺, and X≺ ( Y ≺.\nProof. Relationship X≺ ⊆ Y ≺ is immediate from Definition 26. Assume now that there exists a set of rules Σ ∈ Y \\X whose rule dependency relation has a cycle containing all the rules from Σ. By Definition 26, Σ 6∈ X implies Σ 6∈ X≺, and Σ ∈ Y implies Σ ∈ Y ≺. But then, we clearly have Y 6⊆ X≺ and Y ≺ 6⊆ X≺, and the latter clearly implies X≺ ( Y ≺.\nProposition 28. For each acyclicity notion X such that X ⊆ SWA, we have X ( X≺ and aGRD 6⊆ X.\nProof. Set Σ from Example 24 is in aGRD and thus in X≺; however, Σ is not in SWA and hence not in X either.\nMSA also does not contain aGRD; however, unlike for SWA, our claim depends on the optimisation in Definition 23. An analysis of the relationship between MSA and the version of rule dependencies originally proposed by Baget (2004) is out of scope of this paper.\nExample 29. Let Σ be the set consisting of the following rules:\nr1 = R(x1, x1) ∧ U(x1, z) ∧ U(x2, z)→ R(x1, x2) (68) r2 = R(z, x)→ ∃y.T (x, y) (69) r3 = T (z, x)→ ∃y.U(x, y) (70)\nIt is obvious that r1 ≺ r2, r1 6≺ r3, r2 6≺ r1, r2 6≺ r2, r2 ≺ r3, r3 6≺ r2, and r3 6≺ r3. We next argue that r1 6≺ r1 and r3 6≺ r1, which implies that Σ is aGRD.\nTo see that r1 6≺ r1, assume that an application of r1 to an instance I produces an atom of the form R(a, b); due to atom R(x1, x1) in the body of r1, we have R(a, a) ∈ I. Now let I ′ = I ∪ {R(a, b)}; since R(a, a) ∈ I, the rule application derives ‘something new’ only if a 6= b. Now assume that a substitution σ2 exists that makes r1 applicable to I ′ but not to I; this rule application must ‘use’ the fact R(a, b), which implies that R(x1, x1)σ2 = R(a, b); however, this is impossible since a 6= b. Consequently, we have r1 6≺ r1, and this holds even for the version of rule dependencies by Baget (2004).\nFurthermore, to see that r3 6≺ r1, assume that r3 is applicable to an instance I, and that the rule application derives a fact of the form U(a, f(a)). Now let I ′ = I ∪ {U(a, f(a))}, and assume that a substitution σ2 exists that makes r1 applicable to I\n′ but not to I; this rule application must ‘use’ the fact U(a, f(a)), which implies that σ2(x1) = σ2(x2) = a and σ2(z) = f(a). Furthermore, rule r1 is applicable only if R(a, a) ∈ I; but then, the rule application does not derive ‘something new’ since R(x1, x2)σ2 = R(a, a). Consequently, we have r3 6≺ r1; however, unlike in the previous paragraph, this claim depends on the optimisation in Definition 23.\nConsider now the chase of I∗Σ and MSA(Σ) as shown below (facts involving the predicates D, Fr2, and Fr3 are omitted for clarity). The chase result contains C, so Σ is not in MSA, and thus aGRD 6⊆ MSA; as a corollary, we also get MSA ( MSA≺.\nR(∗, ∗) T (∗, cr2) U(cr2 , cr3) R(∗, cr2) T (cr2 , cr2) C T (∗, ∗) U(∗, cr3) S(cr2 , cr3) S(cr2 , cr2) U(∗, ∗) S(∗, cr2)\nS(∗, cr3)\nNote that R(∗, cr2) is derived from R(∗, ∗), U(∗, cr3), and U(cr2 , cr3), where the latter two facts are obtained from distinct instantiations of MSA(r3). Rule dependencies, however, analyse rule applicability w.r.t. sk(r3), which is closer to the actual skolem chase. ♦\nIn contrast to this result, in Theorem 32 we will show that extending MFA with rule dependencies does not create a stronger notion: MFA≺ coincides with MFA, which implies that X≺ ⊆ MFA for each notion X such that X ⊆ MFA. Towards this goal, we show in Lemma 30 that independent rule sets can be evaluated independently, and in Lemma 31 that a single rule that does not depend on itself can be applied only once.\nLemma 30. Let Σ1 and Σ2 be sets of existential rules such that Σ2 6≺ Σ1, and let F be a set of ground facts not containing a function symbol in sk(Σ2). Then, F ∞ Σ1∪Σ2 = (F ∞ Σ1 )∞Σ2.\nProof. Let F0 = F ∞ Σ1\n; let F0, F1, . . . be the chase sequence for F0 and Σ2 where, for convenience, we assume each Fi to be obtained from Fi−1 by a single rule application (this assumption is clearly w.l.o.g.); and let F ′ = (F0) ∞ Σ2\n. By the definition of the skolem chase, we clearly have F ′ ⊆ F∞Σ1∪Σ2 . Furthermore, assume that F ∞ Σ1∪Σ2 6⊆ F\n′; then, a skolemised rule r1 ∈ sk(Σ1) of the form r1 = ϕ1(~x1)→ ψ1(~x1) exists such that F ′ ( r1(F ′). Fix the smallest i such that Fi ( r1(Fi) (we clearly have i > 0), and let σ1 be the substitution used in the application of r1. Furthermore, let r2 ∈ sk(Σ2) be the skolemised rule of the form\nr2 = ϕ2(~x2)→ ψ2(~x2) that is used to derive Fi from Fi−1, and let σ2 be the substitution used in the application of r2. Now consider an arbitrary term f(~x2) in the head of r2 and assume that f(~x2)σ2 occurs in Fi−1; since the function symbol f is ‘private’ to r2, the head of r2 must have been already instantiated for σ2; but then, ψ2σ2 ⊆ Fi−1, which contradicts our assumption that ψ2σ2 ∈ Fi \\ Fi−1. Thus, we have the following property (?):\nfor each term f(~x2) occurring in the head of r2, ground term f(~x2)σ2 does not occur in Fi−1.\nFinally, let δ be a function that maps each ground term in Fi−1 to a fresh distinct constant; let I = δ(Fi−1); let σ ′ 2 be the substitution defined by σ ′ 2(w) = δ(σ2(w)) for each variable w in r2; and let σ ′ 1 be the substitution defined as follows for each variable w in r1:\n• σ′1(w) = f(δ(~t)) if σ1(w) = f(~t) for f a function symbol ‘private’ to r2; and\n• σ′1(w) = δ(σ1(w)) otherwise.\nWe clearly have ϕ2σ ′ 2 ⊆ I and ψ2σ′2 6⊆ I; furthermore, by (?), we also have ϕ1σ′1 ⊆ I ∪ ψ2σ′2 and ψ1σ ′ 1 6⊆ I ∪ ψ2σ′2. Moreover, ϕ1σ′1 6⊆ I follows from our assumption that i is the smallest integer such that Fi ( r1(Fi). But then, by Definition 23, we have r2 ≺ r1 and, consequently, Σ2 ≺ Σ1 as well, which is a contradiction.\nLemma 31. Let Σ = {r} be a singleton rule set such that r 6≺ r, and let F be a set of facts not containing a function symbol in sk(Σ). Then, F∞Σ = Σ(F ).\nProof. Let F0 = F , and let F0, F1, . . . be sets of facts such that each Fi+1 is the union of Fi with the result of a distinct single application of r to F0; clearly, ⋃ i Fi = Σ(F0). Now\nassume that ⋃ i Fi ( Σ( ⋃ i Fi); then analogously to the proof of Lemma 30, one can show that r ≺ r, which is a contradiction; we omit the details for the sake of brevity.\nTheorem 32. Let Σ be an arbitrary set of rules and let I be an arbitrary instance. If Σ is MFA≺ w.r.t. I, then Σ is also MFA w.r.t. I.\nProof. Assume that Σ is in MFA≺; let I be an arbitrary instance; let Σ1, . . . ,Σn be a dependency partition of Σ; let Υ0 = ∅ and I0 = I; and, for each 1 ≤ i ≤ n, let Υi = ⋃i `=1 Σ` and Ii = (Ii−1) ∞ Σi\n. By the definition of dependency partitions, we have that Σi 6≺ Υi−1 holds for each 1 ≤ i ≤ n. We next show that, for each 0 ≤ i ≤ n, the following two properties hold:\n(a) Ii = (I0) ∞ Υi , and\n(b) Ii does not contain a cyclic term.\nSet I0 does not contain functional terms and hence it trivially satisfies (a) and (b). Now consider arbitrary 0 < i < n such that Ii−1 satisfies (a) and (b). By the induction assumption, Lemma 30, Σi 6≺ Υi−1, and Υi = Σi ∪Υi−1, we have that (I0)∞Υi = ((I0) ∞ Υi−1\n)∞Σi ; thus, Ii satisfies (a). To see that Ii satisfies (b), note that no function symbol used to skolemise the rules in Σi is used to skolemise the rules in Υi−1; we call this property (?). Now there are two ways to compute Ii.\n• Assume that Σi = {ri} such that ri 6≺ ri. By Lemma 31, we have Ii = ri(Ii−1); but then, Ii does not contain a cyclic term due to (?).\n• If Σi is MFA, then Ii does not contain a cyclic term due to (?) and Proposition 5.\nFrom the above claim we have that In = I ∞ Υn = I∞Σ and that In does not contain a cyclic term; but then, Σ is MFA w.r.t. I by Proposition 5.\nCombinations of rule dependencies with acyclicity notions have also been considered in databases: Deutsch et al. (2008) proposed a notion of stratification, and Meier et al. (2009) further developed this idea and proposed a notion of c-stratification. Roughly speaking, each such notion checks whether all strongly connected components of a certain rule dependency graph are WA. The rule dependency notions, however, were developed for the nonoblivious chase and are thus different from Definition 23, as illustrated by the following rule:\nr = R(z, x)→ ∃y.R(x, y) ∧R(y, y) (71)\nThe skolem chase on the critical instance for r is infinite, and r ≺ r by Definition 23. In contrast, rule r does not pose problems for the nonoblivious chase. In particular, assume that the rule is matched to an atom R(t1, t2), and that it derives R(t2, t3) and R(t3, t3). Then, rule r is not applicable to R(t2, t3) or R(t3, t3) since in either case the head atom is satisfied; hence, the rule dependency graphs by Deutsch et al. and Meier et al. are both empty. These results can be summarised as follows: if a rule set Σ satisfies the notion by Deutsch et al., then for each instance I there exists a finite nonoblivious chase sequence; furthermore, if Σ satisfies the notion by Meier et al., then for each instance I all chase sequences (regardless of the rule application strategy) are finite. Meier (2010) discusses in detail the subtle differences between these notions. Since these notions consider a different chase variant, we do not discuss them any further in this paper."
    }, {
      "heading" : "4.3 Acyclicity and Logic Programming",
      "text" : "Acyclicity notions have also been considered in the context of disjunctive logic programs with function symbols under the answer set semantics, with the goal of ensuring that a given program has finitely many answer sets, all of which are finite. All of these notions must deal with disjunction and nonmonotonic negation, which is one of the main differences to the notions considered thus far. All notions from logic programming, however, are applicable to rules without disjunction and nonmonotonic negation, in which case they ensure termination of the skolem chase. Therefore, in this section we compare such specialisations of the acyclicity notions from logic programming with aGRD, WA, JA, SWA, MSA, and MFA. We simplify all definitions so that they apply only to skolemised existential rules—that is, we do not present parts of definitions that handle disjunctions in the head and nonmonotonic negation and function symbols in the body."
    }, {
      "heading" : "4.3.1 Finite Domain Notion",
      "text" : "Calimeri et al. (2008) proposed a finite domain (FD) notion. We next recapitulate this definition, but we do so in the style of Greco et al. (2012), which will come useful in Section 4.3.3 when we introduce Γ-acyclicity. Both approaches use an argument graph to determine possible ways for propagating ground terms between positions during chase. The definition of the argument graph is the same as that of the WA dependency graph (see Section 2.4),\nbut without the distinction between regular and special edges. To simplify the presentation, we consistently use the WA dependency graph instead of the argument graph.\nDefinition 33. Let Σ be a set of rules. A position P |i is Σ-recursive with a position Q|j if the WA dependency graph WA(Σ) contains a cycle (consisting of regular and/or special edges) going through P |i and Q|j. The set PosFD(Σ) of finite domain positions of Σ is the largest set of positions in Σ such that, for each position P |i ∈ PosFD(Σ), each rule r ∈ Σ of the form r = ϕ(~x, ~z)→ ∃~y.ψ(~x, ~y), and each head atom of r of the form P (~t), the following conditions are satisfied:\n• if the i-th component of ~t is a variable x ∈ ~x, then PosB(x) ∩ PosFD(Σ) 6= ∅; and\n• if the i-th component of ~t is a variable y ∈ ~y, then, for each variable x ∈ ~x, some position Q|j ∈ PosB(x) ∩ PosFD(Σ) exists that is not Σ-recursive with P |i.\nSet Σ is FD if PosFD(Σ) coincides with the set of all positions in Σ.\nNote that the notion of Σ-recursive positions introduced above is symmetric: if P |i is Σ-recursive with Q|j , then Q|j is also Σ-recursive with P |i. Furthermore, note that Calimeri et al. (2008) defined FD as follows:\nA set of rules Σ is FD if, for each rule r = ϕ(~x, ~z)→ ∃~y.ψ(~x, ~y) in Σ, each atom Q(~t) in the head of r, each j-th term of ~t that is an existential variable y, and each variable x ∈ ~x, there exists a position P |i ∈ PosB(x) such that Q|j is not Σ-recursive with P |i.\nConditions in the above definition clearly correspond to the conditions in Definition 33; but then, since PosFD(Σ) was defined as the maximal set satisfying these conditions, the two definitions of FD coincide.\nWe next show that WA is strictly contained in FD. To this end, we first prove that WA is contained in FD, and then we present an example showing that the inclusion is strict.\nProposition 34. If a set of rules Σ is WA, then Σ is FD.\nProof. Let Σ be a set of rules that is not FD. Then, there exist a rule r ∈ Σ, an atom Q(~t) in the head of r, a j-th term of ~t equal to an existential variable y, and a variable x ∈ ~x such that each position P |i ∈ PosB(x) is Σ-recursive with Q|j . The set PosB(x) is not empty (~x contains precisely those variables occurring both in the body and the head of the rule), so choose an arbitrary position P |i ∈ PosB(x). The WA dependency graph WA(Σ) then contains a special edge from P |i to Q|j . Furthermore, since Q|j is Σ-recursive with P |i, graph WA(Σ) contains a cycle going through P |i and Q|j . Thus, WA(Σ) clearly contains a cycle containing a special edge, so Σ is not WA.\nExample 35. Let Σ be the set containing rules (72) and (73).\nr1 = R(z, x) ∧A(x)→ ∃y.S(x, y) (72) r2 = S(x1, x2)→ R(x1, x2) (73)\nSet Σ is not WA since the WA dependency graph contains a special edge from R|2 to S|2 and a regular edge from S|2 to R|2. However, Σ is FD because position S|2 is not Σ-recursive with A|1 ∈ PosB(x). Together with Proposition 34, we can conclude that WA ( FD.\nIn addition, we have r1 ≺ r2 and r2 ≺ r1. In Section 4.3.2 we will prove that FD ⊆ JA; hence, FD ( FD≺, WA≺ ( FD≺, and FD 6⊆WA≺ from Propositions 27, 28, and 34. ♦"
    }, {
      "heading" : "4.3.2 Argument-Restricted Rule Sets",
      "text" : "Lierler and Lifschitz (2009) proposed the notion of argument-restricted rule sets, whose definition we summarise next.\nDefinition 36. An argument ranking for a set of rules Σ is a function α that assigns a nonnegative integer to each position in Σ such that the following conditions are satisfied for each rule r ∈ Σ, each universally quantified variable x in r, and each existentially quantified variable y in r:\n1. for each P |i ∈ PosH(x), some Q|j ∈ PosB(x) exists such that α(P |i) ≥ α(Q|j); and\n2. for each P |i ∈ PosH(y), some Q|j ∈ PosB(x) exists such that α(P |i) > α(Q|j).\nSet Σ is argument restricted (AR) if an argument ranking for Σ exists.\nAn argument-restricted set of rules has a finite skolem chase on an arbitrary instance: by a straightforward induction on the chase sequence, one can show that dep(ti) ≤ α(P |i) for each ground fact P (t1, . . . , tn) derived by the chase and each 1 ≤ i ≤ n.\nWe next show that JA is strictly more general than AR. Towards this goal, we first prove an auxiliary lemma that establishes a relationship between the set Move from the definition of JA and an argument ranking; next, we use this lemma to prove that AR ⊆ JA; and finally we present an example that shows this inclusion to be proper.\nLemma 37. Let Σ be a set of rules, let α be an argument ranking for Σ, let y be an existentially quantified variable in Σ, and let Move(y) be the set of positions used in the definition of JA. For each position P |i ∈ Move(y), some position Q|j ∈ PosH(y) exists such that α(P |i) ≥ α(Q|j) holds.\nProof. Let y be an existentially quantified variable occurring in some rule r ∈ Σ, and consider an arbitrary position P |i ∈ Move(y). We prove the claim by induction on the definition of Move(y). The base case when P |i ∈ PosH(y) is trivial. Assume now that P |i ∈ PosH(x) for some variable x occurring in a rule r′ ∈ Σ, and that PosB(x) ⊆ Move(y), so P |i needs to be added to Move(y). By the definition of an argument ranking and since P |i ∈ PosH(x), position P ′|` ∈ PosB(x) exists such that α(P |i) ≥ α(P ′|`). But then, since P ′|` ∈ PosB(x) ⊆ Move(y), by the induction hypothesis we have that position Q|j ∈ PosH(y) exists such that α(P ′|`) ≥ α(Q|j). Thus, α(P |i) ≥ α(Q|j) holds, as required.\nTheorem 38. If a set of rules Σ is AR, then Σ is JA.\nProof. Assume that Σ is AR, let α be an argument ranking for Σ, and let JA(Σ) be the JA dependency graph for Σ. We next prove the following claim: for each edge in JA(Σ) from a variable y1 to a variable y2, and for each position Q|j ∈ PosH(y2), there exists a position\nP |i ∈ PosH(y1) such that α(P |i) < α(Q|j). Consider an arbitrary edge from y1 to y2 in JA(Σ) and an arbitrary position Q|j ∈ PosH(y2). By the definition of the JA dependency graph, then the rule r that contains y2 also contains a universally quantified variable x such that x occurs in the head of r and PosB(x) ⊆ Move(y1). Since α is an argument ranking for Σ, some position P ′|` ∈ PosB(x) exists such that α(P ′|`) < α(Q|j). Since P ′|` ∈ Move(y1), by Lemma 37 position P |i ∈ PosH(y1) exists such that α(P |i) ≤ α(P ′|`). Thus, we have α(P |i) < α(Q|j), and so our claim holds. But then, this claim clearly implies that the JA dependency graph JA(Σ) is acyclic, and therefore Σ is JA.\nExample 39. Let Σ be the set consisting of the following rules:\nr1 = R(z1, x1)→ ∃y1.S(x1, y1) (74) r2 = R(z2, x2)→ ∃y2.S(y2, x2) (75) r3 = S(x3, x4)→ T (x3, x4) (76) r4 = T (x5, x6) ∧ T (x6, x5)→ R(x5, x6) (77)\nLet α be an argument ranking for Σ. Then, α(R|2) < α(S|2) due to (74); α(R|2) < α(S|1) due to (75); α(S|1) ≤ α(T |1) and α(S|2) ≤ α(T |2) due to (76); and α(T |2) ≤ α(R|2) or α(T |1) ≤ α(R|2) due to (77). Together, these observations are contradictory, so such α cannot exist and Σ is not AR. In contrast, Move(y1) = {S|2, T |2} and Move(y2) = {S|1, T |1}, and so Σ is JA.\nIn addition, we have r1 ≺ r3, r2 ≺ r3, r3 ≺ r4, r4 ≺ r1, and r4 ≺ r2; hence, we have AR ( AR≺, AR≺ ( JA≺, and JA 6⊆ AR≺ from Theorem 38 and Propositions 27 and 28. ♦\nLierler and Lifschitz (2009, Thm. 4) proved that AR is strictly more general than FD. We next present an example that shows FD ( AR, but that also settles the relationships between FD≺ and AR≺.\nExample 40. Let Σ be the set consisting of the following rules:\nr1 = A(x)→ ∃y.R(x, y) (78) r2 = R(x1, x2)→ S(x1, x2) (79) r3 = S(z, x) ∧B(x)→ A(x) (80)\nThe WA dependency graph for Σ contains a special edge from A|1 to R|2, as well as regular edges from R|2 to S|2 and from S|2 to A|1; thus, R|2 is Σ-recursive with A|1. Consequently, rule (78) cannot satisfy the conditions in Definition 33, so we have R|2 6∈ PosFD(Σ), and thus Σ is not FD. In contrast, Σ is AR, as evidenced by the following argument ranking:\nα = {A|1 7→ 0, B|1 7→ 0, R|1 7→ 0, R|2 7→ 1, S|1 7→ 0, S|2 7→ 1}\nIn addition, we have r1 ≺ r2, r2 ≺ r3, and r3 ≺ r1; hence, FD ( FD≺, FD≺ ( AR≺, and AR 6⊆ FD≺ from Propositions 27 and 28. ♦\nFinally, we note that λ-restricted programs by Gebser et al. (2007) and ω-restricted programs by Syrjänen (2001) are both included in FD and AR; thus, when restricted to skolemised existential rules, these notions are also included in JA."
    }, {
      "heading" : "4.3.3 Γ-Acyclicity",
      "text" : "Greco et al. (2012) recently proposed the notion of Γ-acylicity for logic programs with function symbols. The original definition of Γ-acyclicity is rather complex, so we next present a simplified version of Γ-acyclicity that is applicable to existential rules. To unify the naming style for the notions in this paper, we often write Γ-acyclicity as ΓA.\nGreco et al. (2012) introduce a notion of an activation graph, which tracks whether a rule can trigger another rule. This notion is closely related to the notion of rule dependencies from Definition 23, but with the requirement that I is an arbitrary finite set of ground facts (possibly containing functional terms). To understand why the latter is needed in logic programming, consider the following logic program:\nr1 = A(x) ∧B(x)→ A(f(x)) (81) r2 = A(x) ∧B(x)→ B(f(x)) (82)\nIf we restrict the set I in Definition 23 to be an instance, then r1 6≺ r2 and r2 6≺ r1; however, the skolem chase of r1, r2, and facts A(a) and B(a) is infinite. Intuitively, r1 and r2 contain the same function symbol f , so to determine whether an application of r1 can trigger an application of r2, we must allow the set I in Definition 23 to contain facts such as B(f(a)). In our setting, however, function symbols are introduced by skolemisation and are thus ‘private’ to each rule, which allows us to restrict the set I in Definition 23 to facts without functional terms. Thus, in the rest of this section, we simply reuse the rule dependency relation ≺ from Definition 23, which gives us a slightly stronger version of ΓA for existential rules than the one proposed by Greco et al. (2012).\nFurthermore, Greco et al. (2012) handle logic programming rules with functional terms in the body. Such rules, however, are not considered in this paper, which allows us to omit the definition of a labelled argument graph and simplify the notion of a propagation graph to a subset of the WA dependency graph.\nWe are now ready to present a simplified version of Γ-acyclicity that is applicable to existential rules.\nDefinition 41. Let Σ be a set of rules. The rule dependency relation ≺ is taken from Definition 23, and the set of finite domain positions PosFD(Σ) is taken from Definition 33.\nThe set of safe positions of Σ, written PosS(Σ), is the least set of the positions of Σ such that PosFD(Σ) ⊆ PosS(Σ), and P |i ∈ PosS(Σ) if and only if, for each rule r ∈ Σ, at least one of the following conditions is satisfied:\n• if P occurs in the head of r, then ≺ does not contain a cycle going through r, or\n• for each atom P (~t) in the head of sk(r) and each variable x that occurs in i-th component of ~t, we have PosB(x) ∩ PosS(Σ) 6= ∅.\nA position is affected if it is not safe. The propagation graph PG(Σ) for Σ has the affected positions of Σ as vertices, and the edges of PG(Σ) are defined as in weak acyclicity, but restricted to affected positions. The set Σ is Γ-acyclic (ΓA) if PG(Σ) does not contain a cycle that involves a special edge.\nIn order to relate ΓA to the notions considered thus far, we first establish some containment relationships. It is obvious from Definition 41 that FD ⊆ ΓA: if all positions in Σ are finite domain, then they are also safe and so the propagation graph is empty. Furthermore, the set of rules in Example 40 is actually ΓA (all positions are safe), but not FD; hence, by Proposition 27, we have that FD ( ΓA, FD≺ ( ΓA≺, and ΓA 6⊆ FD≺. Next, Proposition 42 observes that aGRD is contained in ΓA, and Theorem 43 shows that, perhaps somewhat surprisingly, ΓA≺ is contained in AR≺.\nProposition 42. If a set of rules Σ is aGRD, then Σ is ΓA.\nProof. If the rule dependency relation ≺ on Σ is acyclic, then by the first safety condition in Definition 41 all positions in Σ are safe; but then, PG(Σ) is empty, and so Σ is ΓA.\nTheorem 43. If a set of rules Σ is ΓA≺, then Σ is AR≺.\nProof. The claim clearly follows from the following property: if the rule dependency relation ≺ for Σ has just one strongly connected component and Σ is ΓA, then Σ is AR. Thus, assume that each rule r ∈ Σ occurs on a cycle of ≺. We next construct a mapping α that assigns a nonnegative integer to each position in Σ, and then we show that α is an argument ranking for Σ. In the rest of this proof, we write p1 p2 if WA(Σ) (see Section 2.4) contains a path (consisting of regular and/or special edges) from position p1 to position p2.\nDue to our assumption on Σ, the first item in Definition 41 never applies. Furthermore, let Ψ be the function that maps a set S of positions into another set of positions as follows:\nΨ(S) = S ∪ {P |i | PosB(x) ∩ S 6= ∅ for each r ∈ Σ, each atom P (~t) in the head of sk(r), and each variable x occurring in the i-th component of ~t}\nLet Ψ0(S) = S, Ψk(S) = Ψ(Ψk−1(S)) for each k > 0, and Ψ∞(S) = ⋃\nΨk(S). From Definition 41 it is obvious that PosS(Σ) = Ψ\n∞(PosFD(Σ)). We next define the mapping α. In the rest of this proof, let Y be the set containing each position p ∈ PosFD(Σ) for which an existentially quantified variable y in Σ exists such that p ∈ PosH(y). Furthermore, we use a convention that max ∅ = 0.\n• For each position p ∈ PosFD(Σ), we define α(p) as follows:\nα(p) = { |{p′ ∈ Y | p′ p and p′ 6= p}|+ 1 if p ∈ Y |{p′ ∈ Y | p′ p}| if p 6∈ Y\n• For each position p ∈ PosS(Σ) \\ PosFD(Σ), we define α(p) as follows: α(p) = [ min{k | p ∈ Ψk(PosFD(Σ))} ] + [max{α(q) | q ∈ PosFD(Σ)}]\n• For each position p in Σ with p 6∈ PosS(Σ), we define α(p) as follows, where m(p) is the maximum number of special edges occurring in PG(Σ) on a path ending at p:\nα(p) = m(p) + 1 + [max{α(q) | q ∈ PosS(Σ)}]\nSince Σ is ΓA≺, PG(Σ) does not contain a cycle involving a special edge, so m(p) is always a nonnegative integer and α(p) is correctly defined.\nWe next show that α is an argument ranking—that is, that it satisfies all conditions of Definition 36. To this end, consider an arbitrary rule r ∈ Σ, an arbitrary existentially quantified variable y in r, an arbitrary universally quantified variable x in r, and an arbitrary position P |i ∈ PosH(y); we have the following cases.\n• P |i ∈ PosFD(Σ). By Definition 33, position Q|j ∈ PosB(x) ∩ PosFD(Σ) exists that is not Σ-recursive with P |i. Thus, we have P |i 6 Q|j ; furthermore, Q|j P |i by the definition of WA(Σ). Together, the latter two properties imply the following:\n{p′ ∈ Y | p′ Q|j and p′ 6= Q|j} ⊆ {p′ ∈ Y | p′ P |i and p′ 6= P |i}\nIf Q|j ∈ Y , this inclusion is strict since Q|j is contained in the set on the righthand side, but not in the set on the left-hand side; thus, α(Q|j) < α(P |i) holds, as required. If Q|j 6∈ Y , then α(Q|j) < α(P |i) holds since the definition of α ensures that α(P |i)− α(Q|j) is at least 1.\n• P |i ∈ PosS(Σ) \\ PosFD(Σ). Let k be the smallest number with P |i ∈ Ψk(PosFD(Σ)). By the definition of Ψ, there exists a position Q|j ∈ PosB(x) ∩Ψk−1(PosFD(Σ)), so k − 1 ≥ α(Q|j) by the definition of α. Thus, α(P |i) > α(Q|j) holds, as required.\n• P |i 6∈ PosS(Σ). The first possibility is that some position Q|j ∈ PosB(x) ∩ PosS(Σ) exists; but then, by the definition of α, we have α(Q|j) < α(P |i), as required. The second possibility is that there exists some affected position Q|j ∈ PosB(x); but then, Q|j has at least one less incoming special edge in PG(Σ) than P |i; thus, we also have α(Q|j) < α(P |i), as required.\nTo complete the proof, we must also consider an arbitrary position P |i ∈ PosH(x); however, the cases are analogous as above, so we omit them for the sake of brevity.\nTo place ΓA precisely in the landscape of acyclicity notions, we present three examples that disprove relevant containment relationships. Greco et al. (2012) stated that AR is strictly contained in ΓA, but we were unable to find a formal proof of that statement; in fact, Example 44 shows that this is not the case, and that actually ΓA≺ ( AR≺ holds. Moreover, Example 45 shows that ΓA 6⊆ MSA. Finally, Example 46 shows that WA≺ 6⊆ ΓA.\nExample 44. Let Σ be the set consisting of the following rules:\nr1 = A(x)→ ∃y.R(x, y) (83) r2 = R(x1, x2)→ S(x1, x2) (84) r3 = S(z, x) ∧B(x)→ A(x) (85) r4 = R(z, x)→ T (x, x) (86) r5 = T (x, z)→ R(x, x) (87) r6 = T (z1, x) ∧R(z2, x)→ ∃y.T (x, y) (88)\nOne can readily verify that the following mapping of positions to nonnegative integers is an argument ranking for Σ:\nα = {A|1 7→ 0, B|1 7→ 0, R|1 7→ 1, R|2 7→ 1, S|1 7→ 1, S|2 7→ 1, T |1 7→ 1, T |2 7→ 2}\nWe next argue that Σ is not ΓA. First, the rule dependency relation in Σ holds (at least) between the pairs of rules shown below. Thus, each rule in Σ occurs in ≺ on a cycle, and so Σ is the only strongly connected component of ≺.\nr1 ≺ r2 r2 ≺ r3 r3 ≺ r1 r1 ≺ r4 r4 ≺ r5 r5 ≺ r2 r5 ≺ r6 r6 ≺ r5\nSecond, the WA dependency graph for Σ contains a special edge from A|1 to R|2 due to rule r1, a regular edge from R|2 to S|2 due to rule r2, and a regular edge from S|2 to A|1due to rule r3; consequently, R|2 is Σ-recursive with A|1; but then, rule r1 does not satisfy the conditions in Definition 33, and so R|2 6∈ PosFD(Σ). Furthermore, due to rule r4, we have T |1 6∈ PosFD(Σ) and T |2 6∈ PosFD(Σ) as well. Finally, R|1 6∈ PosFD(Σ) due to rule r5. Consequently, the set of finite domain positions is given by PosFD(Σ) = {A|1, B|1, S|1}.\nThird, we argue that PosS(Σ) = PosFD(Σ). In particular, there is no need to extend PosS(Σ) with R|2: position R|2 occurs in the head of rule r5, but since T |2 is not a finite domain position and r5 occurs on a cycle of ≺, neither condition from Definition 41 holds. Analogously, positions T |1 and T |2 do not need to be added to PosS(Σ) either.\nFourth, since positions R|2, T |1, and T |2 are all affected, the propagation graph PG(Σ) contains a special edge from T |2 to itself due to rule r6. Consequently, Σ is not ΓA.\nFinally, since Σ is the only strongly connected component of ≺, this example also shows that AR 6⊆ ΓA≺ and AR≺ 6⊆ ΓA≺; but then, by Theorem 43, we have ΓA≺ ( AR≺. ♦\nExample 45. Let Σ be the set of rules from Example 29. As explained in the example, Σ is aGRD, but not MSA and thus also not JA, AR, or FD. By Proposition 42, Σ is ΓA, which implies ΓA 6⊆ MSA, and thus ΓA 6⊆ SWA, ΓA 6⊆ JA, ΓA 6⊆ AR, and ΓA 6⊆ FD. ♦\nExample 46. Let Σ be the set consisting of the following rules:\nr1 = R(x1, x1)→ ∃y1∃y2.[A(x1) ∧ S(y1, x1) ∧ S(x1, y2)] (89) r2 = A(x2)→ B(x2) (90) r3 = B(x3)→ R(x3, x3) (91) r4 = S(x4, x4)→ ∃y3∃y4.[C(x4) ∧R(y3, x4) ∧R(x4, y4)] (92) r5 = C(x5)→ D(x5) (93) r6 = D(x6)→ S(x6, x6) (94)\nNote that r1 6≺ r4 and r4 6≺ r1, so the rule dependency relation ≺ in Σ has two strongly connected components: the first one consists of r1, r2, and r3, and the second one consists of r4, r5, and r6. Moreover, each strongly connected component is WA, so Σ is WA\n≺. In contrast, each position in Σ is Σ-recursive with itself, so PosFD(Σ) = ∅. Moreover, each position in Σ occurs in the head of a rule that (i) appears in ≺ in a cycle and (ii) does not satisfy the second safety condition in Definition 41; hence, PosS(Σ) = ∅, and all positions are affected. But then, PG(Σ) = WA(Σ), and so Σ is not ΓA. ♦\nIt may seem counterintuitive that AR 6⊆ ΓA, but ΓA≺ ( AR≺. Intuitively, the notion of safe positions from Definition 41 uses the rule dependency relation, which allows us to construct an example that is in ΓA but not in AR. In ΓA≺, this extra condition is always applied to rules that occur in ≺ on a cycle; thus, the notion of safe positions collapses to a notion weaker than AR, which in turn allows ΓA≺ to be subsumed by AR≺."
    }, {
      "heading" : "4.4 The Landscape of Acyclicity Notions",
      "text" : "To obtain a complete picture of the relative expressiveness of the acyclicity notions considered in this paper, we make the following observations.\n• The rule set from Example 15 is MFA but not MSA, and one can readily verify that r1 ≺ r2 ≺ r3 ≺ r4 ≺ r1; but then, MSA≺ ( MFA≺ = MFA by Proposition 27.\n• The rule set from Example 20 is SWA but not JA, and one can readily verify that r1 ≺ r2 ≺ r3 ≺ r1; but then, JA≺ ( SWA≺ and SWA 6⊆ JA≺ by Proposition 27.\n• The rule set from Example 1 is MSA but not SWA, and one can readily verify that r1 ≺ r3 ≺ r4 ≺ r5 ≺ r2 ≺ r1; but then, SWA≺ ( MSA≺ and MSA 6⊆ SWA≺ by Proposition 27.\n• The rule set from Example 22 is aGRD: we have r1 6≺ r1, r1 6≺ r2, r2 6≺ r1, and r2 6≺ r2. Thus, aGRD 6⊆ Adn-WA.\n• The rule set from Example 22 is FD: we can assume all positions in the rule set to be finite domain without violating conditions of Definition 33. Thus, FD 6⊆ Adn-WA.\nThe landscape of the acyclicity notions considered in this paper is shown in Figure 1. All inclusions between notions shown in the figure are strict: if a notion X is reachable from a notion Y via one or more (directed) arcs, then X is strictly more general than Y . Furthermore, all inclusions are also complete: if a notion X is not reachable from a notion Y via one or more (directed) arcs, then X does not contain Y ."
    }, {
      "heading" : "5. Handling Equality via Singularisation",
      "text" : "Most acyclicity notions presented so far provide no special provision for the equality predicate. If a set of rules Σ contains the equality predicate, one can always axiomatise equality explicitly and then check acyclicity. More precisely, the acyclicity of Σ ∪ Σ≈ (under any notion introduced thus far) guarantees termination of the skolem chase of Σ. Furthermore, note that MFA and MSA are defined as entailment checks in first-order logic with equality, which effectively incorporates the rules of equality into these checks even if rules (1)–(4) are not explicitly given; however, the effect of such a definition is the same.\nWhile handling equality explicitly may be simple, such an approach does not ensure termination of the skolem chase in many practically relevant cases. In particular, the following example shows that the equalities between terms tend to proliferate during skolem chase, which can lead to non-termination.\nExample 47. Consider the set of rules Σ containing rules (95)–(96).\nA(x) ∧B(x)→ ∃y.[R(x, y) ∧B(y)] (95) R(z, x1) ∧R(z, x2)→ x1 ≈ x2 (96)\nThe skolem chase of I∗Σ and Σ derives the following infinite set of facts:\nR(∗, f(∗)) B(f(∗)) ∗ ≈ f(∗) A(f(∗)) R(f(∗), f(f∗))) B(f(f(∗))) . . .\nThus, Σ is not universally MFA by Proposition 5, and by Theorem 14 it is not universally MSA either. ♦\nIt is worth noticing that in the presence of equality WA is no longer subsumed by MFA and hence both notions become incomparable. As explained in Section 2.4, WA can be applied to rules containing the equality predicate (and without an explicit axiomatisation of equality). Under such a treatment, the rules in Example 47 are WA. This, however, does not contradict the results from Section 4: WA does not require an explicit axiomatisation of equality because it ensures termination of nonoblivious chase—an optimised chase variant that expands existential quantifiers only if necessary and that handles equality by replacing equal terms with canonical representatives. In contrast, the results in Section 4 ensure termination of the skolem chase; since this chase variant uses an explicit axiomatisation of equality, all of our results hold only for equality-free rules (or, equivalently, for the rules containing an explicit axiomatisation of equality). The rules in Example 47 are not WA if equality is axiomatised explicitly, which explains the apparent mismatch with Section 4.\nIn order to use the skolem chase with rule sets such as the ones in Example 47, Marnette (2009) proposed the singularisation technique. Roughly speaking, singularisation replaces the equality predicate ≈ with a fresh binary predicate Eq to clarify that the two are to be treated differently; furthermore, it axiomatises Eq as reflexive, symmetric, and transitive, but it does not introduce replacement rules analogous to (4); finally, it modifies the rules in Σ to take the lack of the replacement rules into account. The chase of the transformed rule set is not a model of Σ, but it can be used to answer queries over Σ in a particular welldefined way. The modification of Σ, however, is nondeterministic: there are many ways to modify Σ and, while some may ensure termination of the skolem chase, not all are required to do so. We next recapitulate the definition of singularisation by Marnette (2009).\nDefinition 48. A marking Mr of a rule r of the form (5) is a mapping that assigns to each variable w ∈ ~x ∪ ~z a single occurrence of w in ϕ; the marked occurrence of w in a rule is written w . All other occurrences of w are unmarked, and all occurrences of constants are unmarked as well. For Σ a set of rules, a marking M of Σ contains exactly one marking Mr for each r ∈ Σ. Let Eq be a fresh binary predicate not occurring in Σ. The singularisation of Σ under M is the set Sing(Σ,M) that contain rules\n→ Eq(x, x) (97) Eq(x1, x2)→ Eq(x2, x1) (98)\nEq(x1, x2) ∧ Eq(x2, x3)→ Eq(x1, x3) (99)\nand, for each rule r ∈ Σ, the rule obtained from r by replacing each atom s ≈ t with atom Eq(s, t), and by replacing each unmarked occurrence of a term t in a body atom with a fresh variable z′ and then adding atom Eq(t, z′) to the rule body.\nNote that Sing(Σ,M) is unique up to the renaming of the fresh variables. Furthermore, note that rule (97) can be transformed into a safe rule as explained in Section 2.2. Finally, note that Sing(Σ,M) is equality-free (since ≈ and Eq are different predicates); therefore, no specific treatment of equality is needed when computing its chase or checking its acyclicity.\nExample 49. Singularisation of the marked rule (100) produces rule (101).\nA(x ) ∧B(x) ∧R(x, z )→ C(x) (100) A(x) ∧B(x1) ∧R(x2, z) ∧ Eq(x, x1) ∧ Eq(x, x2)→ C(x) (101)\nNote that singularisation should be applied ‘globally’ to all rules, including the ones that do not contain the equality predicate. ♦\nThe properties of singularisation can be summarised as follows. Let Σ be a set of rules, let I be an instance, and let M be a marking for Σ. Furthermore, let Σ′ = Sing(Σ,M), and let I ′ = I∞Σ′ be the chase of I and Σ\n′. Finally, note that predicate Eq is interpreted in I ′ as an equivalence relation, so let ρ be a function that maps each term t occurring in I ′ to an arbitrarily chosen representative from the equivalence class of t. The first-order interpretation ρ(I ′) is defined as follows, where rng(ρ) is the range of the mapping ρ, the set 4ρ(I′) is the universe of ρ(I ′), and (P )ρ(I′) is the interpretation of a predicate P :\n4ρ(I′) = rng(ρ) (P )ρ(I\n′) = {〈ρ(t1), . . . , ρ(tn)〉 | P (t1, . . . , tn) ∈ I} for each P different from Eq (Eq)ρ(I ′) = {〈x, x〉 | x ∈ 4ρ(I′)}\nNote that ρ(I ′) interprets ≈ as true equality—that is, each term t is interpreted in ρ(I ′) as a representative of the equivalence class that contains t; hence, ρ(I ′) is not a Herbrand interpretation. Marnette (2010) showed that, for an arbitrary ρ, interpretation ρ(I ′) is a universal model of Σ and I—that is, ρ(I ′) can be homomorphically embedded into an arbitrary model of Σ and I. Thus, ρ(I) can be used for query answering: for a Boolean conjunctive query Q, we have I ∪ Σ |= Q if and only if ρ(I ′) |= Q.\nThis result can be reformulated as follows. Let Σ, I, M , and I ′ be as specified above, and let us assume that Q is of the form Q = ∃~y.ϕ(~y). Furthermore, let r be the following rule, and let M ′ be an arbitrary marking of r:\nr = ϕ(~y)→ H (102)\nThen, the above characterisation of singularisation implies that\nI ∪ Σ |= Q if and only if I ∪ Sing(Σ ∪ {r},M ∪M ′) |= H if and only if\nI ′ ∪ Sing({r},M ′) |= H.\nHence, we can answer Q w.r.t. Σ and I by evaluating Sing({r},M ′) in the chase of I and Sing(Σ,M). It is straightforward to generalise this approach to non-Boolean queries.\nThe absence of replacement rules (4) often allows the skolem chase to terminate on Sing(Σ,M), but this may depend on the selected marking.\nExample 50. Rule (95) from Example 47 admits the following two markings:\nA(x ) ∧B(x)→ ∃y.[R(x, y) ∧B(y)] (103) A(x) ∧B(x )→ ∃y.[R(x, y) ∧B(y)] (104)\nThe skolem chase does not universally terminate for the singularisation obtained from (104) and (96). In contrast, the singularisation obtained from (103) and (96) is JA. ♦\nDefinition 51. For X ∈ {MFA,MSA, JA}, acyclicity notion X∃ (resp. X∀) contains each finite set of rules Σ such that Sing(Σ,M) ∈ X for some (resp. each) marking M of Σ.\nClearly, X∀ ⊆ X∃ for each X ∈ {MFA,MSA, JA}, and Example 50 shows this inclusion to be proper. We next show that JA∀ actually coincides with WA.\nTheorem 52. For Σ an arbitrary finite set of rules, Σ is JA∀ if and only if Σ is WA.\nProof. (JA∀ ⊆WA) We prove the contrapositive, so let Σ be an arbitrary set of rules that is not WA; w.l.o.g. we assume that each variable in Σ occurs in at most one rule. We consider each edge from p to q in the WA dependency graph WA(Σ) to be a triple e = 〈p, q, t〉, where t = · if the edge is regular and t = ∗ if the edge is special. By the definition of WA, for each such e, a rule r ∈ Σ and universally quantified variable x occurring in the head and the body of r exist such that p ∈ PosB(x), so let xe be one such arbitrarily chosen but fixed variable; furthermore, if edge e is special, then an existentially quantified variable y exists such that q ∈ PosH(y), so let ye be one such arbitrarily chosen but fixed variable.\nA cycle in WA(Σ) is a sequence of edges e1, . . . , en of the form ei = 〈pi, qi, ti〉 such that qi = pi+1 for each 1 ≤ i < n and and qn = p1. Such a cycle is dangerous if an edge ek exists that is special; and such a cycle is simple if xei 6= xej for all 1 ≤ i < j ≤ n.3\nNow let Π′ = e1, . . . , en be an arbitrary dangerous cycle in WA(Σ). If Π ′ is not simple, we show how to transform Π′ to a shorter dangerous cycle. Towards this goal, assume that Π′ contains edges ei = 〈pi, qi, ti〉 and ej = 〈pj , qj , tj〉 such that 1 ≤ i < j ≤ n and xei = xej ; hence, some rule r ∈ Σ contains body atoms in which xei occurs at positions pi and pj . Furthermore, let ek be an arbitrarily chosen, but fixed special edge in Π\n′; such ek exists since Π′ is dangerous. We have the following possibilities.\n3. Note that a cycle of length one is always simple.\n• If i ≤ k < j, let Π′′ = e, ei+1, . . . , ej−1 where e = 〈pj , qi, ti〉. If ei is regular, then xei occurs in a head atom of r at position qi; furthermore, if ei is special, then some head atom of r contains an existentially quantified variable at position qi. Either way, e is an edge of WA(Σ), so Π′′ is a cycle in WA(Σ). Furthermore, e is special if k = i, and Π′′ contains ek otherwise; hence, Π ′′ is dangerous.\n• Otherwise, let Π′′ = e1, . . . , ei−1, e, ej+1, . . . , en where e = 〈pi, qj , tj〉. Edges e and ej are of the same type, so e is an edge of WA(Σ) and Π′′ is a cycle in WA(Σ). Furthermore, e is special if k = j, and Π′′ contains ek otherwise; hence, Π ′′ is dangerous.\nIn both cases, Π′′ contains at least one edge less than Π′. Thus, we can iteratively transform an arbitrary dangerous cycle in WA(Σ) to a simple dangerous cycle Π.\nNow let M be a marking for Σ that marks each variable w occurring in the body of a rule r ∈ Σ as follows.\n• If an edge e = 〈p, q, t〉 in Π exists such that w = xe, then M marks an occurrence of w in r at position p (if there are multiple such occurrences, one is chosen arbitrarily). Since Π is simple, edge e is unique, and so M is correctly defined.\n• Otherwise, M marks an arbitrarily chosen occurrence of w in r.\nLet Σ′ = Sing(Σ,M), and let JA(Σ′) be the JA dependency graph for Σ′. To show that JA(Σ′) contains a cycle, we first prove the following property (?).\nFor each subpath e1, . . . , ek of Π where edge e1 is special and each edge ei with 1 < i ≤ k is regular, we have {qi, Eq|1} ⊆ Move(ye1) for each 1 ≤ i ≤ k.4\nSince Σ′ contains rule (97), we clearly have Eq|1 ∈ Move(ye1). We next prove (?) by induction on k. For the base case k = 1, we have q1 ∈ Move(ye1) by the definition of JA. For the induction step, assume that the claim holds for all subpaths of length k, and consider a subpath e1, . . . , ek, ek+1. By the induction assumption and the fact that qk = pk+1, we have pk+1 ∈ Move(ye1). Furthermore, variable xek+1 occurs in the body and the head atom of some rule r ∈ Σ′ at positions pk+1 and qk+1, respectively. Finally, by the definition of M and the properties of singularisation, we have that PosB(xek+1) contains pk+1 and possibly Eq|1. But then, by the definition of JA, we have qk+1 ∈ Move(ye1), as required.\nTo complete the proof, consider now an arbitrary subpath e1, . . . , e` of Π where edges e1 and e` are special and each edge ei with 1 < i < k is regular. By (?) and the fact that q`−1 = p`, we have {p`, Eq|1} ⊆ Move(ye1). Furthermore, as in the previous paragraph, PosB(xe`) contains p` and possibly Eq|1; but then, JA(Σ′) contains an edge from ye1 to ye` . Since Π is a cycle, JA(Σ′) clearly contains a cycle, so Σ′ is not JA, as required.\n(JA∀ ⊇WA) Assume that Σ 6∈ JA∀, so there exists a marking M for Σ such that Σ′ = Sing(Σ,M) is not JA. We assume that Σ does not contain an existentially quantified variable that occurs in an equality atom; this is w.l.o.g. as we can always replace each equality atom y ≈ t with an atom R(x, t) and add a rule R(x1, x2)→ x1 ≈ x2 for R a fresh binary predicate, and such a transformation clearly does not affect the membership of the\n4. The notion of a subpath is defined in the obvious way; however, please note that, although Π is defined as a sequence of edges, subpaths of Π can ‘wrap around’ this sequence as Π is a cycle.\nrule set in JA∀ and WA. Now consider an arbitrary existentially quantified variable y, and arbitrary positions p ∈ PosH(y) and q ∈ Move(y) that do not involve Eq (both sets are w.r.t. Σ′); by induction on the construction of Move(v), one can prove that WA(Σ) then contains a sequence of regular edges from p to q. The proof is straightforward, and we omit the details for the sake of brevity. Similarly, consider an arbitrary edge from y1 to y2 in JA(Σ\n′), and arbitrary positions p ∈ PosH(y1) and q ∈ PosH(y2) that do not involve Eq; by the definition of JA, a variable x occurring in the rule of y2 and a position s not involving Eq exist such that s ∈ Move(y1) and s ∈ PosB(x). But then WA(Σ) contains a path consisting of regular edges from p to s, as well as a special edge from s to q. Since JA(Σ′) is cyclic, WA(Σ) clearly contains a cycle involving a special edge.\nChecking all possible markings may be infeasible: the number of candidates is exponential in the total number of variables that occur more than once in a rule body. Theorem 52 shows that JA∀ can be decided using WA. For the other cases, the following simple observation shows how to reduce the number of markings.\nDefinition 53. A variable x is relevant for a rule r ∈ Σ if x occurs more than once in the body of r, and the head of r contains an atom P (~t) such that x ∈ ~t and P is not ≈.\nProposition 54. Let M and M ′ be markings for Σ such that, for each rule r ∈ Σ, the markings for r in M and M ′ coincide on each relevant variable in r. Then, for each instance I, the result of the skolem chase for I and Sing(Σ,M) coincides with the result of the skolem chase for I and Sing(Σ,M ′); furthermore, Sing(Σ,M) is JA/MSA/MFA if and only if Sing(Σ,M ′) is JA/MSA/MFA.\nProof. Consider an arbitrary rule r ∈ Σ. If a variable x occurs only in the body of r, then marking various occurrences of x in r clearly produces rules equivalent up to the renaming of variables. Furthermore, assume that a variable x occurs in the head of r only in an equality atom of the form x ≈ t, and that the markings of x differ. Then, the rules obtained from r by singularisation will all have the same body (up to the renaming of variables); furthermore, the bodies contain atoms Eq(xi, x), and the rule heads are of the form Eq(x, t). Since Sing(Σ,M) and Sing(Σ,M ′) contain rules (97)–(99), the skolem chase for I and Sing(Σ,M) clearly derives the same ground atoms as the skolem chase for I and Sing(Σ,M ′).\nDespite this optimisation, the number of markings to check can still be exponential in the size of Σ, so we next describe a useful approximation. LetM be a maximal set of markings for Σ such that, for all M1,M2 ∈M, each rule r ∈ Σ, and each variable x that is not relevant in r, the markings of x in r under M1 and M2 coincide. Intuitively, such M contains all possible markings of the relevant variables, but the markings of all other variables coincide. By Proposition 54 it is clear that, given two such sets M1 and M2, the skolem chase of⋃ M∈M1 Sing(Σ,M) and ⋃ M∈M2 Sing(Σ,M) coincides for an arbitrary instance I; thus, let\nM be one arbitrarily chosen such set of markings. Also, let Sing∪(Σ) = ⋃ M∈M Sing(Σ,M), let MFA∪ be the class containing each rule set Σ such that Sing∪(Σ) ∈ MFA, and let MSA∪ and JA∪ be defined analogously. As the following proposition shows, Sing∪(Σ) provides a ‘lower bound’ on acyclicity that can be obtained via singularisation.\nProposition 55. For each X ∈ {MFA,MSA, JA}, we have that X∪ ⊆ X∀. Furthermore, the size of Sing∪(Σ) is exponential in the maximal number of relevant variables in a rule in Σ, and it is linear in the number of rules in Σ.\nProof. The first claim follows from the fact that all considered notions of acyclicity are monotone in the sense that every subset of an acyclic rule set is also acyclic. The second claim follows from the fact that, if a rule r exists that contains k relevant variables and each variable occurs m times in r, then M contains mk different markings for r.\nThis result is interesting when dealing with rules that are obtained from DLs, where each rule has at most one relevant variable: on such rule sets, the size of Sing∪(Σ) is linear in the size of Σ. For the general case, the complexity of acyclicity checking does not increase despite the exponential increase in the number of rules.\nTheorem 56. Deciding whether Σ is in MFA∪ (MFA∃, MFA∀) is 2ExpTime-complete. Deciding whether Σ is in MSA∪ (MSA∃, MSA∀) is ExpTime-complete.\nProof. If Σ contains no equality, it is easy to see that Σ is in MFA∪ (MFA∃, MFA∀) if and only if it is in MFA. The same can be observed for MSA. Thus, hardness follows from Theorems 8 and 13.\nFor membership, we first consider the cases of MFA∃, MFA∀, MSA∃, and MSA∀. Each of these properties can be decided by considering all of the at most exponentially many markings. Since Sing(Σ,M) is linear in the size of Σ, the property can be checked for each marking for MFA in 2ExpTime (cf. Theorem 8) and for MSA in ExpTime (cf. Theorem 13). This yields the required bound since an exponential factor is not significant for the considered complexity classes.\nFor MFA∪ and MSA∪, membership follows by observing that the membership of MFA and MSA in 2ExpTime and ExpTime, respectively, is obtained from the double/single exponential bound on the number of ground facts that potentially need to be derived in order to decide the required property. While Sing∪(Σ) is exponentially larger than Σ, the maximal number of relevant ground facts is still the same since no new predicates or constant symbols are introduced. The increased number of rules leads to an exponential increase of the time to check applicability of all rules in each of the doubly/singly exponentially many steps, but this exponential factor does not affect membership of the decision problem in 2ExpTime/ExpTime.\nWe finish this section by examining the interaction between rule normalisation and singularisation. Note that normalisation reduces the number of variables in a rule, which at least at first sight suggests that normalisation could prevent one from finding a marking that ensures acyclicity of the singularised rules. We next show that this cannot happen if normalisation is used without structure sharing: if the original set of rules is MFA w.r.t. some set of markings, then the transformed set of rules is MFA w.r.t. a set of markings as well. Furthermore, we show that this does not hold if normalisation is used with structure sharing; hence, normalisation should be applied with care when used with singularisation.\nTheorem 57. Let Σ be a set of existential rules, let Σ′ be obtained from Σ by applying a single normalisation step without structure sharing, and let I be an instance. Then each\nmarking M of Σ for which Sing(Σ,M) is MFA w.r.t. I can be extended to a marking M ′ of Σ′ such that Sing(Σ′,M ′) is MFA w.r.t. I.\nProof. Let M be a marking of Σ such that Sing(Σ,M) is MFA, let r ∈ Σ be the rule of the form (8) to which the normalisation step is applied, and let Σ′ be the set of rules obtained from Σ after the application of a normalisation step to r. We next prove that the claim holds for both a head and a body normalisation step.\n(Head Normalisation) Assume that the set of rules Σ′ is obtained by replacing a rule r ∈ Σ with rules r1 and r2 of the following forms, where ~x = ~x3 ∪ ~x4:\nr = ϕ(~x, ~z)→ ∃~y1, ~y2, ~y3.[ψ1(~x3, ~y1, ~y2) ∧ ψ2(~x4, ~y1, ~y3)] r1 = ϕ(~x, ~z)→ ∃~y1, ~y3.[Q(~x3, ~y1) ∧ ψ2(~x4, ~y1, ~y3)] r2 = Q(~x3, ~y1)→ ∃~y2.ψ1(~x3, ~y1, ~y2)\nLet M ′ be a marking that coincides with M on all rules different from r, that marks r1 in the same way as M marks r, and that marks r2 in the only possible way (note that the body of this rule does not contain repeated occurrences of variables); furthermore, let Ω = Sing(Σ,M) and Υ = Sing(Σ′,M ′). We assume that rule r is skolemised by replacing each variable y ∈ ~y1 with gy1(~x), each variable y ∈ ~y2 with g y 2(~x), and each variable y ∈ ~y3 with gy3(~x); rule r1 is skolemised as r; and rule r2 is skolemised by replacing each variable y ∈ ~y2 with hy(~x3, ~y1). Thus, the skolemised and singularised rules have the following form; formula ϕ′ is a singularisation of ϕ, and all freshly introduced variables are contained in ~z1:\nϕ′(~x, ~z1)→ ψ1(~x3, ~g1(~x), ~g2(~x)) ∧ ψ2(~x4, ~g1(~x), ~g3(~x)) ϕ′(~x, ~z1)→ Q(~x3, ~g1(~x)) ∧ ψ2(~x4, ~g1(~x), ~g3(~x))\nQ(~x3, ~y1)→ ψ1(~x3, ~y1,~h(~x3, ~y1))\nFinally, we inductively define a partial mapping µ from terms to terms as follows:\n• µ(c) = c for each constant c,\n• µ(f(~t)) = f(µ(~t)) for each function symbol f not of the form hy or gy1 and all terms ~t such that µ(~t) is defined, and\n• µ(hy(~s,~g1(~s,~t))) = gy2(µ(~s), µ(~t)) for each function symbols of the form hy, the corresponding symbol gy2 , and all terms ~s and ~t such that µ(~s) and µ(~t) are defined.\nWe next show the following property (?): for each A(~t) ∈ I∞Υ where A is a predicate occurring in Ω (i.e., A was not introduced by the normalisation step), µ(t) is defined and A(µ(~t)) ∈ I∞Ω . The proof is by induction on the chase sequence I0Υ, I1Υ, . . . for I and Υ. The base case holds trivially. Furthermore, since Ω and Υ coincide on all rules apart from r, r1, and r2, the proof of the claim is trivial for each conclusion of a rule different from r1 or r2. For the remaining cases, we can assume w.l.o.g. that I i+1 Υ is obtained from I i Υ by a single application of r1 of substitution σ and an application of r2 to the result; thus, the rules together derive the following facts:\nQ(~x3σ,~g1(~xσ))\nψ1(~x3σ,~g1(~xσ),~h(~x3σ,~g1(~xσ))) ψ2(~x4σ,~g1(~xσ), ~g3(~xσ))\nBy the induction assumption, ϕ′(µ(~xσ), µ(~zσ)) ⊆ I∞Ω , and so I∞Ω contains the following facts:\nψ1(µ(~x3σ), ~g1(µ(~xσ)), ~g2(µ(~xσ))) ψ2(µ(~x4σ), ~g1(µ(~xσ)), ~g3(µ(~xσ)))\nClearly, each term hy(~x3σ,~g1(~xσ)) is of the form h y(~s,~g1(~s,~t)), so the mapping µ is defined on the term. Furthermore, by the definition of µ, it is clear that property (?) holds. The proof of (?) also reveals that functions symbols hy occur in I∞Υ always in (sub)terms of the form hy(~s,~g1(~s,~t)), and that µ(u) is defined for each term u occurring in I ∞ Υ . This observation and the following property of µ clearly imply the claim of this theorem: if u is a cyclic term and µ(u) is defined, then µ(u) is cyclic as well. To prove the latter, it suffices to consider the following two cases.\n• Assume that u is cyclic due to the repetition of a function symbol f not of the form hy. Thus, u contains a subterm of the form f(~s), and some si ∈ ~s contains a subterm of the form f(~t). By the definition of µ, then µ(u) contains a term of the form f(µ(~s)), and some s′i ∈ µ(~s) contains a subterm of the form f(µ(~t)). Clearly, µ(u) is cyclic.\n• Assume that u is cyclic due to the repetition of a function symbol of the form hy. By the above observation, then u contains a subterm of the form hy(~s,~g1(~s,~t)), and some si ∈ ~s ∪ ~t contains a subterm of the form hy(~v,~g1(~v, ~w)). By the definition of µ, then µ(u) contains a subterm of the form gy2(µ(~s), µ(~t)), and some s ′ i ∈ µ(~s) ∪ µ(~t) contains\na subterm of the form gy2(µ(~v), µ(~w)). Clearly, u is cyclic.\n(Body Normalisation) Assume that the set of rules Σ′ is obtained by replacing a rule r ∈ Σ with rules r1 and r2 of the following forms, where ~x = ~x1 ∪ ~x2 ∪ ~x3, and ~x1, ~x2, ~x3, ~z1, ~z2, and ~z3 are all pairwise disjoint:\nr = ϕ1(~x1, ~x2, ~z1, ~z2) ∧ ϕ2(~x1, ~x3, ~z1, ~z3)→ ∃~y.ψ(~x, ~y) r1 = ϕ1(~x1, ~x2, ~z1, ~z2)→ Q(~x1, ~x2, ~z1) r2 = Q(~x1, ~x2, ~z1) ∧ ϕ2(~x1, ~x3, ~z1, ~z3)→ ∃~y.ψ(~x, ~y)\nFor each marked variable v, let ~uv be the variables used to replace v in singularisation. Then, the singularised rule r can be represented as follows, where for clarity we do not show the free variables of various formulae, ϕ′1 and ϕ ′ 2 do not contain atoms with predicate Eq, and Γ1 and Γ2 are the conjunctions of atoms with predicate Eq obtained by renaming unmarked occurrences of the variables in ϕ1(~x1, ~x2, ~z1, ~z2) and ϕ2(~x1, ~x3, ~z1, ~z3), respectively:\nϕ′1 ∧ ϕ′2 ∧ Γ1 ∧ Γ2 → ∃~y.ψ(~x, ~y)\nNow let M ′ be a marking that coincides with M on all rules different from r, and that, for each marked occurrence of a variable w ∈ ~x1 ∪ ~x2 ∪ ~z1 in r, marks r1 and r2 as follows.\n• If the marked occurrence of w appears in ϕ1(~x1, ~x2, ~z1, ~z2), then the corresponding occurrence of w is marked in r1; in addition, if w ∈ ~x1 ∪ ~x2 ∪ ~z1, then the occurrence of w in atom Q(~x1, ~x2, ~z1) is marked in r2.\n• If the marked occurrence of w appears in ϕ2(~x1, ~x3, ~z1, ~z3), then the corresponding occurrence of w is marked in r2; in addition, if w ∈ ~x1 ∪ ~x2 ∪ ~z1, then an arbitrary occurrence of w is marked in r1.\nSince there is no structure sharing, Σ does not contain r1, so the above definition is wellformed. The singularisation of r1 and r2 under M ′ can be represented as follows:\nϕ′′1 ∧ Γ′′1 → Q(~x1, ~x2, ~z1) Q(~x′1, ~x2, ~z ′ 1) ∧ ϕ′2 ∧ Γ′2 → ∃~y.ψ(~x, ~y)\nBy the definition of M ′, it should be clear that ϕ′′1 ∧ Γ′′1 is isomorphic to a subset of ϕ′1 ∧ Γ′1. Based on this observation, it is now routine to prove that, if A(~t) ∈ I∞Sing(Σ,M) and A is different from the newly introduced predicate Q, then A(~t) ∈ I∞Sing(Σ′,M ′), which clearly implies our claim.\nIn contrast to Theorem 57, the following example shows that normalisation with structure sharing can prevent one from finding a marking that makes the normalised rules acyclic. This example shows that normalisation must be used with care in applications that use singularisation to deal with equality.\nExample 58. Let Σ be the following set of rules marked by a marking M shown below.\nA(x) ∧ T (x , z) ∧B(z )→ ∃y.[R(x, y) ∧A(y)] (105) A(x ) ∧ T (x, z) ∧ C(z )→ ∃y1∃y2.[S(x, y1) ∧ T (y1, y2)] (106)\nR(z , x 1) ∧R(z, x 2)→ x1 ≈ x2 (107) S(z , x 1) ∧ S(z, x 2)→ x1 ≈ x2 (108) T (z , x 1) ∧ T (z, x 2)→ x1 ≈ x2 (109)\nOne can show that Sing(Σ,M) is MFA w.r.t. the instance I given below.\nI = {A(a), R(a, a), T (a, b), B(b), A(a′), S(a′, a′), T (a′, b′), C(b′)}\nFurthermore, let M1 be a marking identical to M but which marks A(x ) in rule (105), and let M2 be a marking identical to M but which marks T (x , z) in rule (106). One can show that neither Sing(Σ,M1) nor Sing(Σ,M2) is MFA w.r.t. I. Now let Σ′ be obtained from Σ by applying normalisation with structure sharing to rules (105) and (106); thus, rules (105) and (106) are replaced with the following rules:\nQ(x, z) ∧B(z)→ ∃y.[R(x, y) ∧A(y)] (110) Q(x, z) ∧ C(z)→ ∃y1∃y2.[S(x, y1) ∧ T (y1, y2)] (111) A(x) ∧ T (x, z)→ Q(x, z) (112)\nNote that conjunction A(x) ∧ T (x, z) occurs in Σ′ only in rule (112); therefore, variable x in this conjunction can be marked in only one way. This, however, has the same effect as choosing M1 or M2 for Σ: no possible marking M\n′ will make Sing(Σ′,M ′) MFA w.r.t. I. Intuitively, normalisation with structure sharing reduces the space of available markings, due to which it may be impossible to find a marking that makes the rules acyclic. ♦"
    }, {
      "heading" : "6. Applying Acyclicity to Horn Description Logics",
      "text" : "In this section we apply various acyclicity notions to reasoning problems in description logic (DL) ontologies. Description logics are knowledge representation formalisms that underpin the Web Ontology Language (OWL). DL ontologies are constructed from atomic concepts (i.e., unary predicates), atomic roles (i.e., binary predicates), and individuals (i.e., constants). Special atomic concepts > and ⊥ denote universal truth and falsehood, respectively. For each atomic role R, expression R− is an inverse role; furthermore, a role is an atomic or an inverse role. DLs provide a rich set of constructors for building concepts (first-order formulae with one free variable) from atomic concepts and roles. A description logic TBox is a set of axioms, which correspond to first-order sentences. In this paper we consider only Horn description logics, in which TBoxes can be translated into existential rules. Furthermore, in this paper we will consider only normalised TBoxes, in which concepts do not occur nested in other concepts. The latter assumption is without loss of generality as each Horn description logic TBox can be normalised in linear time, and the normalised ontology is a model-conservative extension of the original one.\nIn this paper we consider several logics all of which are fragments of the description logic Horn-SROIF , which provides the formal underpinning for a prominent subset of OWL. A normalised Horn-SROIF TBox T consists of axioms shown on the left-hand side of Table 1; in the table, A, B, and C are atomic concepts (including possibly > and ⊥), R, S, and T are (not necessarily atomic) roles, and a is an individual. To guarantee decidability of reasoning, T must satisfy certain global conditions (Kutz, Horrocks, & Sattler, 2006), which we omit for the sake of brevity. Roughly speaking, only so-called simple roles are allowed to occur in axioms of Type 2, and axioms of Type 6 must be regular according to a particular condition that allows such axioms to be represented using a nondeterministic finite automaton. We also consider the following fragments of Horn-SROIF .\n• Horn-SRI TBoxes are not allowed to contain axioms of Type 2 or 7.\n• Horn-SHIF TBoxes are not allowed to contain axioms of Type 7, and all axioms of Type 6 satisfy R = S = T . Note that all Horn-SHIF TBoxes are regular.\n• Horn-SHI TBoxes inherit the restrictions from Horn-SHIF and are further not allowed to contain axioms of type 2.\nTo simplify the presentation, we do not consider general at-least number restrictions— that is, concepts of the form ≥nR.A with n > 1. The translation of such concepts into rules would require an explicit inequality predicate. As explained in Section 2.2, the inequality predicate can be simulated using an ordinary predicate, and so the extension of our results to general at-least number restrictions is straightforward.\nIn the rest of this paper we allow inverse roles to occur in atoms, so we take an atom of the form R−(t1, t2) with R an atomic role as an abbreviation for R(t2, t1). Then, each Horn-SROIF axiom corresponds to an existential rule as shown in Table 1. As explained in Section 2.2, we treat > and ⊥ as ordinary unary predicates where > is explicitly axiomatised. Thus, we can take a substitution θ to be an answer to a CQ Q(~x) w.r.t. a T and I if T ∪ I |= Q(~x)θ or I ∪ T |= ∃y.⊥(y); the latter condition takes into account that an unsatisfiable theory entails all possible formulae. Due to this close correspondence between\ndescription logic axioms and existential rules, in the rest of this paper we identify a TBox T with the corresponding set of rules.\nThe complexity of answering Boolean conjunctive queries over general (i.e., not acyclic) DL TBoxes is 2ExpTime- and ExpTime-complete for Horn-SROIF (Ortiz et al., 2011) and Horn-SHIF (Eiter et al., 2008), respectively. In the rest of this section we investigate the complexity of this problem on acyclic ontologies, as well as the complexity of acyclicity checking. In particular, in Section 6.1 we consider the case when the TBox is expressed in Horn-SROIF , for which we show that both BCQ answering and MFA checking are ExpTime-complete. Then, in Section 6.2 we consider Horn-SHIF TBoxes, for which we show that the complexity of these problems drops to PSpace.\n6.1 Acyclic Horn-SROIF TBoxes\nWe start by showing that BCQ answering for WA Horn-SRI TBoxes is ExpTime-hard. Intuitively, this is due to the axioms of Type 6, which can be used to axiomatise existence of non-tree-like structures. Although regularity ensures that axioms of Type 6 can be represented by a nondeterministic finite automaton, this automaton can be exponential; as a consequence, axioms of Type 6 can axiomatise exponential non-tree-like structures, which is the main source of complexity.\nLemma 59. Let T be a WA Horn-SRI TBox, let I be an instance, and let F be a fact. Then, checking whether I ∪ T |= F is ExpTime-hard.\nProof. LetM = (S,Q, δ, Q0, Qa) be a deterministic Turing machine, where S is a finite set of symbols, Q is a finite set of states, δ : Q× S → Q× S × {←,→} is a transition function, Q0 ∈ Q is the initial state, and Qa the accepting state. Furthermore, assume that an integer k exists such thatM halts on each input of length n in time 2nk . Given an arbitrary input Si1 , . . . , Sin , we construct an MFA set of Horn-SRI rules T and an instance I such that I ∪ T |= Qa(a) if and only ifM accepts the input. To simplify the presentation, we will use a slightly more general rule syntax than what is allowed by Table 1; however, all such rules can be brought into the required form by renaming parts of the rules with fresh predicates.\nLet ` = nk; since k is a constant, ` is polynomial in n. Our construction uses a unary predicate for each symbol and state; for simplicity, we do not distinguish between the predicate and the symbol/state. In addition, the construction also uses binary predicates Li, Ri, Ti, Ui, Di, Hi, and Vi for 1 ≤ i ≤ `, unary predicates Ai and Bi for 0 ≤ i ≤ `, and unary predicates O1, . . . , On+1, N1, and N2. Instance I contains only the fact A0(a). We\nnext present the rules of T . The set T will contain only Horn rules without empty heads, so it will be satisfiable in a minimal Herbrand model. For readability, we divide T into groups of rules and prove for each group various facts about this minimal Herbrand model of T ∪ I, which is shown schematically in Figure 2. The construction of T proceeds along the following lines.\n• The first, the second, and the third group of rules construct the exponential grid shown at the bottom of Figure 2, whose edges are labelled with H` and V`. Each sequence of V`-edges will be used to encode the contents of the tape of the Turing machine at some point in time; furthermore, precisely one vertex in each such sequence will be labelled with a state, thus representing the position of the head. In contrast, H`-edges will connect different points in time and will be used to encode the transitions of the Turing machine.\n• The fourth group labels the right-most V`-chain with Si1 , . . . , Sin , St, St, . . . , St, St, where St represents the empty tape symbol.\n• The fifth and the sixth groups ensure that the symbols on the tape that are not modified by a move of a Turing machine are propagated between time points.\n• The seventh and the eighth group encode the transitions of the Turing machine.\n• The ninth group propagates the acceptance condition to the top of the figure by labelling the individual a with the accepting state Qa.\nWe next present the rules of T in detail.\nThe first group of rules in T contains rules (113)–(115) for each 0 < i ≤ `, and rule (116) for each 1 < i ≤ `.\nAi−1(x)→ ∃y.[Li(x, y) ∧Ai(y)] (113) Ai−1(x)→ ∃y.[Ri(x, y) ∧Ai(y)] (114) Ri(z, x) ∧ Li(z, x′)→ Ti(x, x′) (115)\nLi(z, x) ∧ Ti−1(z, z′) ∧Ri(z′, x′)→ Ti(x, x′) (116)\nOn I, these rules axiomatise existence of a triangular structure in the top part of Figure 2 containing Ti links.\nThe second group of rules in T contains rule (117), rules (118)–(120) for each 0 < i ≤ `, and rule (121) for each 1 < i ≤ `.\nA`(x)→ B0(x) (117) Bi−1(x)→ ∃y.[Ui(x, y) ∧Bi(y)] (118) Bi−1(x)→ ∃y.[Di(x, y) ∧Bi(y)] (119) Ui(z, x) ∧Di(z, x′)→ Vi(x, x′) (120)\nDi(z, x) ∧ Vi−1(z, z′) ∧ Ui(z′, x′)→ Vi(x, x′) (121)\nThese rules axiomatise existence of triangular structures in the bottom part of Figure 2 containing Vi links.\nThe third group of rules in T contains rule (122), and rules (123) and (124) for each 0 < i ≤ `.\nT`(x, x ′)→ H0(x, x′) (122)\nUi(z, x) ∧Hi−1(z, z′) ∧ Ui(z′, x′)→ Hi(x, x′) (123) Di(z, x) ∧Hi−1(z, z′) ∧Di(z′, x′)→ Hi(x, x′) (124)\nThese rules axiomatise existence of Hi links, which with Vi links form a grid of size 2 i × 2i shown in Figure 2. In the rest of this proof, for variables w0 and w`, we use R\n`(w0, w`) as an abbreviation for R1(w0, w1) ∧ . . . ∧R`(w`−1, w`), where each wi with 0 < i < m is a variable not occurring outside the conjunction. Furthermore, we analogously use U `(w0, w`) as an abbreviation for U1(w0, w1) ∧ . . . ∧ U`(w`−1, w`).\nThe fourth group of rules in T contains rule (125), rules (126) and (127) for each 1 ≤ j ≤ n, and rules (128)–(129), where St is the empty tape symbol. Remember that Si1 , . . . , Sin encodes the input to M.\nA0(z) ∧R`(z, z′) ∧ U `(z′, x)→ O1(x) ∧Q0(x) (125) Oj(z) ∧ V`(z, x)→ Oj+1(x) (126)\nOj(x)→ Sij (127) On+1(z) ∧ V`(z, x)→ On+1(x) (128)\nOn+1(x)→ St(x) (129)\nRule (125) labels the grid origin and sets the initial state as shown in Figure 2. Rules (126) ensure that the n subsequent nodes are labelled with O2, . . . , On+1, and rule (128) propagates On+1 to the rest of the V`-chain. Finally, rules (127) and (129) ensure that nodes labelled with Oj are also labelled with Sij , and that nodes labeled with On+1 are labeled with St. Thus, this group of rules in T ensures that the right-most V`-chain in the grid contains the initial state of the tape of M.\nThe fifth group of rules in T contains rules (130)–(131) for each state Qk ∈ Q, and rules (132)–(133). These rules essentially ensure that all nodes before and after a node labelled with some state Qk ∈ Q are labeled with N1 and N2, respectively, thus indicating that the head is not above the node.\nQk(z) ∧ V`(x, z)→ N1(x) (130) Qk(z) ∧ V`(z, x)→ N2(x) (131) N1(z) ∧ V`(x, z)→ N1(x) (132) N2(z) ∧ V`(z, x)→ N2(x) (133)\nThe sixth group of rules in T contains rules (134)–(135) instantiated for each symbol Sk ∈ S; these rules ensure that the contents of the tape is copied between successive time points for all points in the grid not containing the head.\nN1(z) ∧ Sk(z) ∧H`(z, x)→ Sk(x) (134) N2(z) ∧ Sk(z) ∧H`(z, x)→ Sk(x) (135)\nThe seventh group of rules in T contains rules (136)–(137) instantiated for each symbol Sk ∈ S and each state Qk ∈ Q such that δ(Qk, Sk) = (Qk′ , Sk′ ,←). These rules encode moves of M where the head moves left.\nQk(z) ∧ Sk(z) ∧H`(z, x)→ Sk′(x) (136) Qk(z) ∧ Sk(z) ∧H`(z, z′) ∧ V`(x, z′)→ Qk′(x) (137)\nThe eighth group of rules in T contains rules (138)–(139) instantiated for each symbol Sk ∈ S and each state Qk ∈ Q such that δ(Qk, Sk) = (Qk′ , Sk′ ,→). These rules encode moves of M where the head moves right.\nQk(z) ∧ Sk(z) ∧H`(z, x)→ Sk′(x) (138) Qk(z) ∧ Sk(z) ∧H`(z, z′) ∧ V`(z′, x)→ Qk′(x) (139)\nThe ninth group of rules in T contains rules (140)–(143) for each 1 ≤ i ≤ `; these rules simply ensure that acceptance is propagated back to the root of the upper tree.\nQa(z) ∧ Ui(x, z)→ Qa(x) (140) Qa(z) ∧Di(x, z)→ Qa(x) (141) Qa(z) ∧ Li(x, z)→ Qa(x) (142) Qa(z) ∧Ri(x, z)→ Qa(x) (143)\nThe above discussion shows that labelling of the nodes in the grid shown in Figure 2 simulates the execution ofM on input Si1 , . . . , Sin , where the contents of the tape at some time instant is represented by a V`-chain, and H`-links connect tape cells at successive time instants. Thus, I ∪ T |= Qa(a) if and only if M accepts Si1 , . . . , Sin in time 2`. It is straightforward to see that T is WA, so the claim of this theorem holds.\nThe proof of Lemma 59 can be adapted to obtain the lower bound for checking MFA of Horn-SRI rules.\nLemma 60. Checking whether a Horn-SRI TBox is universally MFA is ExpTime-hard.\nProof. LetM be an arbitrary deterministic Turing machine and let Si1 , . . . , Sin be an input string on which M terminates in time 2nk . For such M and Si1 , . . . , Sin , let T be as in the proof of Lemma 59. TBox T is WA, it contains only constant-free, equality-free, and connected rules, and no predicate in T is of zero arity; hence, by Lemma 7, a Horn-SRI TBox T ′ exists such thatM accepts Si1 , . . . , Sin if and only if T ′ is not universally MFA.\nNote that Lemmas 59 and 60 apply to Horn-SRI and thus do not rely on a particular treatment of equality. We can deal with the equality predicate in Horn-SROIF TBoxes using singularisation as described in Section 5, which leads us to the following result.\nTheorem 61. Let T be a Horn-SROIF TBox, let M be a marking of T , let I be an instance, and let Q be a BCQ. Then, checking whether Sing(T ,M) is MFA w.r.t. I is ExpTime-complete. Furthermore, if Sing(T ,M) is MFA w.r.t. I, then checking whether I ∪ T |= Q holds is ExpTime-complete as well.\nProof. Note that all rules in Table 1 are ∃-1 rules. Since all rules in Sing(T ,M) are ∃-1 rules as well, Theorem 10 gives us an ExpTime upper bound for both of our problems. The matching lower bounds follow from Lemmas 59 and 60 (note that every Horn-SRI TBox is also a Horn-SROIF TBox) and the fact that their proofs do not use predicate ≈.\nIn fact, Theorem 10 provides us with even stronger complexity bounds. In particular, even if T does not satisfy all the required global conditions, and even if T is extended with SWRL rules (Horrocks, Patel-Schneider, Bechhofer, & Tsarkov, 2005), the rules in T are all still ∃-1 rules. Thus, one can decide whether such T is MFA (universally or w.r.t. an instance) in ExpTime, and if that is the case, one can answer BCQs in ExpTime as well. Consequently, ontology-based applications can freely use the expressivity beyond what is currently available in OWL without an increase in the complexity of reasoning, assuming that the resulting TBox is acyclic.\nWe conclude this section by observing that MSA provides us with a tractable notion for Horn-SROIF rules. Intuitively, all rules in MSA(T ) have a bounded number of variables and all predicates in MSA(T ) are of bounded arity, which eliminates all sources of intractability in datalog reasoning. We prove the matching lower bound in Section 6.2 for the more specific case of Horn-SHIF ontologies.\nTheorem 62. Let T be Horn-SROIF TBox, let M be a marking, and let I be an instance. Then, checking whether Sing(T ,M) is MSA w.r.t. I is in PTime.\nProof. As one can see in Table 1, the rules in T all contain a bounded number of variables and atoms in the body, and so the number of variables in the body of each rule in MSA(Sing(T ,M)) is bounded as well. Furthermore, the datalog program MSA(Sing(T ,M)) contains predicates of bounded arity, so its chase w.r.t. I is polynomial in size. Thus, the chase of I and MSA(T ) can be computed in polynomial time, which implies our claim.\n6.2 Acyclic Horn-SHIF TBoxes\nThe exponential lower bound of Lemmas 59 and 60 critically depend on axioms of Type 6, which can be used to encode exponential structures; furthermore, a combination of inverse roles and axioms of Types 2 and 7 (i.e., of inverse roles, number restrictions, and nominals) is also well known to be problematical (Horrocks & Sattler, 2007). In practice, however, TBoxes are often expressed in Horn-SHIF , which disallows such axioms in TBoxes. We next show that, for such TBoxes, the complexity of both problems drops to PSpace.\nWe first prove PSpace-hardness for both problems. Note that the PSpace-hardness proof of concept satisfiability checking by Baader, Calvanese, McGuinness, Nardi, and PatelSchneider (2007) is not applicable to Horn ontologies since it uses disjunctive concepts. Nonetheless, PSpace-hardness can be proved by a reduction from checking QBF validity.\nLemma 63. Let T be a WA Horn-SHI TBox, let I be an instance, and let F be a fact. Then, checking whether I ∪ T |= F is PSpace-hard.\nProof. Let ϕ = Q1x1 . . . Qnxn.C1 ∧ . . . ∧ Ck be an arbitrary quantified Boolean formula defined over variables x1, . . . , xn, where each Qi ∈ {∃,∀}, 1 ≤ i ≤ n is a quantifier, and each Cj , 1 ≤ j ≤ k is a clause of the form Cj = Lj,1 ∨ Lj,2 ∨ Lj,3. Checking validity of ϕ is the canonical PSpace-hard problem.\nIn the rest of this proof, for a binary predicate P and variables w0 and wm, we use Pm(w0, wm) as an abbreviation for P (w0, w1) ∧ . . . ∧ P (wm−1, wm), where each wi with 0 < i < m is a variable not occurring outside the conjunction. Let T be the Horn-SHI TBox containing rules (144)–(147) for each 1 ≤ i ≤ n, rule (148) for each clause Cj and each literal Lj,m = x` occurring in Cj , rule (149) for each clause Cj and each literal Lj,m = ¬x` occurring in Cj , rule (150), rule (151) for each 1 ≤ i ≤ n such that Qi = ∃, and rule (152) for each 1 ≤ i ≤ n such that Qi = ∀.\nAi−1(x)→ ∃y.[X+i (x, y) ∧Ai(y)] (144) Ai−1(x)→ ∃y.[X−i (x, y) ∧Ai(y)] (145)\nX+i (x, x ′)→ P (x, x′) (146) X−i (x, x ′)→ P (x, x′) (147)\nX+` (z ′, z) ∧ Pn−`(z, x) ∧An(x)→ Cj(x) (148) X−` (z ′, z) ∧ Pn−`(z, x) ∧An(x)→ Cj(x) (149)\nC1(x) ∧ . . . ∧ Ck(x)→ Fn(x) (150) P (x, z) ∧ Fi(z)→ Fi−1(x) (151)\nX+i (x, z) ∧ Fi(z) ∧X − i (x, z ′) ∧ Fi(z′)→ Fi−1(x) (152)\nStrictly speaking, rules (148), (149), (150), and (152) are not Horn-SHI rules, but they can be transformed into Horn-SHI rules by replacing parts of their bodies with fresh concepts. It is straightforward to see that T is WA.\nLet I = {A0(a)}, and let I∞T be the chase of I and T . Due to rules (144)–(145), I∞T contains a binary tree of depth n in which each leaf node is reachable from a via a path that, for each 1 ≤ i ≤ n, contains either X+i or X − i . If we interpret the presence of X + i and X−i as assigning variable xi to t and f, respectively, then each leaf node corresponds to one possible assignment of x1, . . . , xn. Rules (148) and (149) then clearly label each leaf node with the clauses that are true in the node, and rule (150) labels each leaf node with Fn for which all clauses are true. Finally, rules (151) and (152) label each interior node of the tree with Fi−1 according to the semantics of the appropriate quantifier of ϕ. Clearly, ϕ is valid if and only if I ∪ T |= F0(a), which implies our claim.\nWe next turn our attention to the upper bounds on the complexity of answering a BCQ over an MFA TBox, and checking whether a TBox is MFA. While in Section 6.1 we considered a TBox T singularised according to some marking M , in this section we assume that equality in T is handled by means of an explicit axiomatisation T≈. As we explain next, this is because singularised rules are not ‘local’, which makes a PSpace membership proof quite difficult. For example, consider the following singularised rule:\nA(x) ∧ x ≈ x′ ∧B(x′)→ C(x) (153)\nAtoms A(x) and B(x′) in the rule do not share variables and therefore need not be matched ‘locally’ in the chase of Sing(T ,M) and I; furthermore, the chase can be exponential in size, so it is not trivial to see how it can be explored using polynomial space. Nevertheless, we conjecture that it is possible to extend our proof to singularised rules as well; however, the details involved seem quite technical, without explaining much about the nature of BCQ answering under equality. Therefore, we leave this problem open and restrict ourselves to the technically simpler case when equality in T is encoded explicitly using T≈.\nWe next show that answering a BCQ Q over an MFA Horn-SHIF TBox T and an instance I can be performed in polynomial space. The proof uses the well-known tracing technique of inspecting a model of T ∪ I using polynomial space. The key aspect of this result, however, is dealing with the transitive roles in the query, which allow the query to be embedded non-locally into the chase of T and I. Note, however, that we can guess an embedding of Q into the result of I∞T using nondeterministic polynomial time; furthermore, since I∞T is a minimal Herbrand model of T (i.e., since T is Horn), we can check the entailment of each mapped atom of Q separately, and in doing so we can use the wellknown encoding by Demri and de Nivelle (2005) to handle transitive roles.\nTheorem 64. Let T be Horn-SHIF TBox, let I be an instance such that T is MFA w.r.t. I, and let Q be a BCQ. Then, checking whether I ∪ T |= Q is PSpace-complete.\nProof. Hardness follows from Lemma 63. We next present a nondeterministic polynomial space algorithm that decides I ∪ T |= Q; by Savitch’s Theorem, this algorithm can be transformed into a deterministic polynomial space algorithm, which proves our claim.\nAssume that BCQ Q is of the form Q = ∃~y.B1 ∧ . . . ∧Bn. Furthermore, let Υ = sk(T ). Since ⊥ is just a regular atomic concept, I ∪ T is always satisfiable in the chase I∞T of I\nand T . Furthermore, I ∪ T |= Q if and only if a substitution θ from the variables in ~y to the terms in I∞T exists such that Biθ ∈ I∞T for each 1 ≤ i ≤ n; the latter clearly holds if and only if I ∪Υ |= Biθ. As shown in the proof of Theorem 10, each term in I∞T is of the form g1(. . . g`(a) . . .), where ` is less than or equal to the number of function symbols in Υ. Thus, the first step in deciding I ∪ T |= Q is to examine all possible θ and then check I ∪Υ |= Biθ for each 1 ≤ i ≤ n; this can clearly be done using a deterministic Turing machine that uses polynomial space to store θ, provided that each individual check I ∪Υ |= Biθ can also be decided in polynomial space.\nIf Biθ is of the form C(t), then let Υ ′ = Υ, and let D = C. Alternatively, if Biθ is of the form R(t′, t), then let Υ′ be Υ extended with the following rules, where D and E are fresh concepts not occurring in Υ and I:\n→ E(t′) (154) E(z) ∧R(z, x)→ D(x) (155)\nIt is straightforward to see that I ∪Υ |= R(t′, t) if and only if I ∪Υ′ |= D(t). Let Υ′′ be obtained from Υ′ by deleting each rule in Υ′ of the form\nR(x1, z) ∧R(z, x2)→ R(x1, x2) (156)\nand, for each role R occurring in such a rule, replacing each rule of the form\nA(z) ∧R(z, x)→ B(x) (157)\nwith the following rules, where QA,R,B is a fresh concept unique for A, R, and B:\nA(z) ∧R(z, x)→ QA,R,B(x) (158) QA,R,B(z) ∧R(z, x)→ QA,R,B(x) (159)\nQA,R,B(x)→ B(x) (160)\nThis transformation corresponds to the well-known elimination of transitivity by Demri and de Nivelle (2005), so I ∪Υ′ |= D(t) if and only if I ∪Υ′′ |= D(t); the proof of this claim is straightforward and we omit it for the sake of brevity.\nLet Ξ be Υ′′ extended with the equality axioms (2) and (4). Since ≈ does not occur in the body of the rules in Υ′′, we have that I ∪Υ′′ 6|= D(t) if and only if I ∪ Ξ 6|=≈ D(t). Let I∞Ξ be the chase for I and Ξ; then I ∪ Ξ 6|=≈ D(t) if and only if D(t) 6∈ I∞Ξ . Note that Ξ contains rules of Types 1–5 from Table 1, rules (2) and (4), and possibly rules of the form → E(t1). These facts can be used to show that each assertion in I∞Ξ is of one of the following forms, where a and b are constants, t is a constant or a term that contains only unary function symbols, f and g are unary function symbols, C is an atomic concept, and R is an atomic role:\n• C(t),\n• R(a, b), R(a, f(b)), R(f(b), a), R(t, f(t)), R(f(t), t), or\n• t ≈ f(g(t)), f(t) ≈ g(t), a ≈ b, a ≈ f(b), or an equality symmetric to these ones.\nThe proof is by induction on the length of the chase sequence for I and Ξ, and the claim follows straightforwardly from the I∞Ξ form of rules of Types 1–5. Motik et al. (2009b) prove an analogous claim for a more general description logic, and their proof carries over to the above setting with only syntactic changes.\nWe say that x is the central variable in a rule of Type 1 or 3, and that z is the central variable in a rule of Type 2 or 4. W.l.o.g. we assume that the body of a rule of Type 5 does not contain inverse roles; then, x1 is the central variable of a rule of Type 5. Finally, in the equality replacement rules (4), the central variable is the variable being replaced.\nClearly, D(t) 6∈ I∞Ξ if and only if a Herbrand interpretation J exists in which all assertions are of the form mentioned above, such that I∞Ξ ⊆ J , J |=≈ Ξ, and D(t) 6∈ J . We next show how to check the existence of such J using a nondeterministic Turing machine that runs in polynomial space.\nLet f1, . . . , fm be all function symbols occurring in Ξ. We first guess a Herbrand interpretation J0 over the constants of I satisfying I ⊆ J0, and we check whether all rules in Ξ not of Type 1 are satisfied in J0. If that is the case, we consider each constant c in J0 and call the following procedure for s = c and i = 1:\n1. If i = m+ 1 return true.\n2. Guess a Herbrand interpretation J i such that each assertion in J i is of a form as specified earlier and involves at least one term among f1(s), . . . , fm(s).\n3. If D(t) ∈ J i, return false.\n4. Check whether the equality symmetry rule (4) is satisfied in J i; if not, return false.\n5. Check whether J i ∪ J i−1 ∪ . . . ∪ J0 satisfies each rule in Ξ if the central variable of the rule is mapped to s; if this is not the case for each rule, return false.\n6. For each 1 ≤ k ≤ m, recursively call this procedure for fk(s) and i+ 1; if one of this calls returns false, return false as well.\n7. Return true.\nAssume that this procedure returns true for each constant c, and let J be the union of all J i considered in the process. It is straightforward to see that I ⊆ J and D(t) 6∈ J ; furthermore, J |=≈ Ξ holds since the satisfaction of each rule r ∈ Ξ in J can be ascertained ‘locally’, by inspecting the vicinity of the ground term that is mapped to the central variable of r. Furthermore, the recursion depth of our algorithm is m and at each recursion level we need to keep a polynomially sized interpretation J i, so our algorithm can be implemented using a nondeterministic Turing machine that uses polynomial space.\nTheorem 65. Let T be Horn-SHIF TBox, and let I be an instance. Then, deciding whether T is MFA w.r.t. I is in PSpace, and deciding whether T is universally MFA is PSpace-hard.\nProof. (Membership) Rules in MFA(T ) are ‘almost’ Horn-SHIF rules: rule (19) can be made a Horn-SHIF rule by replacing S in the body with D (which clearly does not affect the consequences of the rule), and the fact that rule (20) contains a nullary atom in the\nhead is immaterial. Thus, the claim can be proved by a straightforward adaptation of the membership proof of Theorem 64. The main difference in the algorithm is that, with n function symbols, we need to examine the models to depth n+1; however, such an algorithm still uses polynomial space.\n(Hardness) Let ϕ be an arbitrary QBF, and let T be as in the hardness proof of Lemma 63. TBox T is WA; it contains only constant-free, equality-free, and connected rules; and it does not contain a predicate of zero arity. Hence, by Lemma 7, a Horn-SHI TBox T ′ exists such that ϕ is valid if and only if T ′ is not universally MFA.\nWe finish this section by proving that checking whether a set of Horn-SHI rules is universally MSA is PTime-hard; in this way, we also obtain a matching lower bound for theorem Theorem 62 from Section 6.1.\nTheorem 66. Checking whether a Horn-SHI TBox T is universally MSA is PTime-hard.\nProof. Let N be a set of Horn propositional clauses of the form ¬v1 ∨ . . . ∨ ¬vn ∨ vn+1 and let v be a propositional variable; deciding N |= v is well known to be PTime-hard. Let Vi be a concept uniquely associated with each propositional variable vi; let A be a fresh concept; and let T be the TBox obtained by transforming each propositional clause in N of the above form into rule (161).\nA(x) ∧ V1(x) ∧ . . . ∧ Vn(x)→ Vn+1(x) (161)\nFinally, let I = {A(a)}. Clearly, N |= v holds if and only if I ∪ T |= V (a) holds. TBox T is WA, it contains only constant-free, equality-free, and connected rules, and no predicate in T is of zero arity; hence, by Lemma 7, a Horn-SHI TBox T ′ exists such that N 6|= v holds if and only if T ′ is universally MFA. Finally, the only existential variable in T ′ occurs in a rule of the form (23), so it is straightforward to see that T ′ is universally MFA if and only if T ′ is universally MSA."
    }, {
      "heading" : "7. Experiments",
      "text" : "To estimate the extent to which various acyclicity notions can be used in practice, we conducted two sets of experiments. First, we implemented MFA, MSA, JA, and WA checkers, and we used them to check acyclicity of a large corpus of Horn ontologies. Our goal was to see how many ontologies are acyclic and could thus be used with (suitably extended) materialisation-based OWL reasoners. Second, we computed the materialisation of the acyclic Horn ontologies and compared the number of facts before and after materialisation. The goal of these tests was to see whether materialisation-based reasoning with acyclic ontologies is practically feasible.\nTests were performed on a Windows R2 Server with two Intel Xeon 3.06GHz processors. We used a repository of 336 OWL ontologies whose TBox axioms can be transformed into existential rules where at least one rule contains an existential quantifier in the head. These ontologies include a large subset of the Gardiner ontology corpus (Gardiner, Tsarkov, & Horrocks, 2006), the LUBM ontology, several Phenoscape ontologies, and a number of ontologies from two versions of the Open Biomedical Ontology (OBO) corpus. Please note\nthat no test ontology has been obtained from conceptual models (e.g., the ER models or UML diagrams): due to the specific modelling patterns used in conceptual modelling, such ontologies are less likely to be acyclic. Each test ontology can be accessed online from our ontology repository by means of a unique ID.5 Each ID identifies one self-contained OWL ontology ‘frozen in time’ with all of its imports resolved at the time the ontology was added to the repository; furthermore, any possible future version of the ontology will be assigned a fresh ID. These measures should ensure that our experiments can be independently repeated at any point in the future."
    }, {
      "heading" : "7.1 Acyclicity Tests",
      "text" : "We implemented all acyclicity checks by adapting the HermiT reasoner.6 HermiT was used to transform an ontology into DL-clauses—formulae quite close to existential rules. In the result, at-least number restrictions in head atoms were replaced with existential quantification, atoms involving datatypes were eliminated, and the DL-clauses with no head atoms were removed: datatypes and empty heads can cause inconsistencies, but they cannot prevent the skolem chase from terminating.\nEach set of rules Σ obtained by the above preprocessing steps was considered in combination with each acyclicity notion X ∈ {WA, JA,MSA,MFA} as follows. If Σ did not contain the equality predicate, we simply checked whether Σ ∈ X. If Σ contained the equality predicate, we checked whether Σ ∈ X∪, and we also checked whether Σ′ ∈ X for Σ′ ⊆ Σ the set of all rules of Σ that do not contain the equality predicate; these tests provided us with a ‘lower’ and an ‘upper’ bound for acyclicity, respectively. Each acyclicity test was performed by modifying Σ (or Σ′) as required by X and then running HermiT to check for a particular logical entailment on the critical instance.\nOur tests revealed MFA and MSA to be indistinguishable for all 336 test ontologies; that is, all MFA ontologies were found to be MSA as well (the converse holds per Theorem 14). A total of 213 (63.4%) ontologies were found to be MSA, including 43 of the 49 (87.8%) ontologies from the Gardiner corpus, 164 of the 208 (78.8%) OBO ontologies, and the LUBM ontology. In contrast, the GALEN ontology and its variants, the GO ontology and its extensions, and the 55 Phenoscape ontologies were found not to be MFA. These results are summarised in Table 2. Given the large number of ontologies tested, it would be impractical to present the results for each ontology individually. Instead, the ontologies are grouped by number of generating rules (G-rules), which are the rules containing an existential quantifier; for each group, Table 2 shows the total number of ontologies, as well as the numbers of ontologies found to be MSA, JA, and WA. Of the 123 ontologies that are not MFA, seven ontologies are in ELHr, so CQ answering over these ontologies can be realised using the combined approaches by Lutz et al. (2009) and Kontchakov et al. (2011).\nThe five older versions of OBO ontologies (IDs 00359, 00374, 00376, 00382, and 00486) are MSA, whereas their newer versions (IDs 00360, 00375, 00377, 00383, and 00487) are not MFA. In contrast, two older versions of OBO ontologies are not MFA (IDs 00432 and 00574), but their newer versions (IDs 00433 and 00575) are MSA.\n5. URL http://www.cs.ox.ac.uk/isg/ontologies/UID/xxxxx.owl can be used to download an ontology that has been assigned ID ‘xxxxx’. 6. http://www.hermit-reasoner.com/\nFinally, we found 15 large OBO ontologies (including different versions of the same ontologies) that are MSA but not JA. Thus, MSA seems to be particularly useful on complex ontologies since it analyses implications between existentially quantified variables more precisely than the previously known notions. Table 3 shows for each of these ontologies the number of generating rules (G-rules), whether the ontology uses the equality predicate (Eq), the ontology expressivity in the description logic family of languages (DL), and the number of classes (C), properties (P), and axioms (A) that the ontology contains. Different versions of the same ontology are distinguished in the table as ‘old’ and ‘new’. Two further ontologies (IDs 00762 and 00766) containing the equality predicate are MSA∪, but their status regarding joint acyclicity is unknown: they are JA when the rules involving the equality predicate are deleted, but are not JA∪."
    }, {
      "heading" : "7.2 Materialisation Tests",
      "text" : "To estimate the practicability of materialisation in acyclic ontologies, we measured the maximal depth of function symbol nesting in terms generated by materialisation on critical instances. This measure, which we call ontology depth, is of interest as it provides us with a bound on the size of the materialisation. Out of the 213 MSA ontologies, our test succeeded on 207 of them (tests were aborted if they did not finish in three hours). On the latter ontologies, depth was distributed as follows:\n• 123 (59.4%) ontologies have depth less than 5;\n• 30 (14.5%) ontologies have depth between 5 and 9;\n• 47 (22.7%) ontologies have depth between 10 to 19;\n• 5 (2.4%) ontologies have depth between 20 and 49; and\n• 2 (1.0%) ontologies have depth between 50 to 70.\nThese results leads us to believe that many (but clearly not all) ontologies have manageable depths, which should allow for successful materialisation-based query answering.\nWe also computed the materialisation for several acyclic ontologies. As our implementation is prototypical, our primary goal was not to evaluate the performance of computing the materialisation, but rather to estimate the blowup in the number of facts. We clearly do\nnot expect this blowup to depend linearly on size of the input number of facts; however, our results should provide us with a rough estimate of the performance of materialisation-based reasoning in practice. Most of our test ontologies, however, do not contain many facts: ontologies are often constructed as general vocabularies, while facts are often applicationspecific and are thus not publicly available. To overcome this problem, we conducted two kinds of experiments.\nFirst, we computed the materialisation of two ontologies that contain facts: LUBM with one university (ID 00347), and the ‘kmi-basic-portal’ ontology (ID 00078). The TBox of LUBM has eight generating rules and depth one, and there are 100, 543 facts before ma-"
    }, {
      "heading" : "10–70 54 9396 1807 1286 175 1297 189",
      "text" : "terialisation. Materialisation took only 2 seconds, and it produced 231, 200 new facts, of which 97, 860 were added by the generating rules. The ‘kmi-basic-portal’ ontology has ten generating rules and depth two, and there were 198 facts before materialisation. Materialisation took only 0.03 seconds, and it produced 744 new facts, of which 145 were added by the generating rules.\nSecond, for each of the ontologies identified as MSA, we instantiated each class and each property with fresh individuals. We then computed the materialisation and measured the generated size (the number of facts introduced by the generating rules divided by the number of facts before materialisation), the materialisation size (the number of facts after materialisation divided by the number of facts before materialisation), and the time needed to compute the materialisation. Since most generating rules in these ontologies have singleton body atoms (i.e., they are of the form A(x)→ ∃R.C(x)), these measures should provide a reasonable estimate of the increase in the number of facts during materialisation. Table 4 summarises the results of our tests for the 207 ontologies on which the test succeeded. Ontologies are grouped by their depth, and each group shows the number of ontologies (#), and the maximal and average materialisation time, generated size, and materialisation size.\nThus, materialisation seems practically feasible for many ontologies: for 123 ontologies with depth less than 5, materialisation increases the ontology size by a factor of 8. This suggests that principled, materialisation-based reasoning for ontologies beyond the OWL 2 RL profile may be feasible, especially for ontologies with relatively small depths."
    }, {
      "heading" : "8. Conclusions",
      "text" : "In this paper, we investigated acyclicity notions—sufficient conditions that ensure termination for skolem chase on existential rules. We proposed two novel notions, called MFA and MSA, for which we determined tight complexity bounds for membership checking, as well as for conjunctive query answering over acyclic existential rules.\nWe also conducted a thorough investigation of the acyclicity notions known in the literature, and we produced a complete taxonomy of their relative expressiveness. Our results show that MFA and MSA generalise most of the previously considered notions.\nWe next investigated ways to ensure acyclicity of existential rules that contain the equality predicate. To this end, we presented several optimisations of the singularisation technique by Marnette (2009). Our optimisations can often reduce the number of acyclicity checks needed, thus making the singularisation technique more suitable for practical use.\nFinally, we studied the problem of answering conjunctive queries over acyclic DL ontologies. On the theoretical side, we showed that acyclicity can make this problem computation-\nally easier; furthermore, provided that the result is acyclic, one can extend Horn ontologies with arbitrary SWRL rules without affecting decidability and the worst-case complexity of query answering. On the practical side, we investigated the extent to which acyclicity notions enable principled extensions of materialisation-based ontology reasoners with support for existential quantification. Our tests show that many ontologies commonly used in practice are acyclic, and that the blowup in the number of facts due to materialisation is manageable. This suggests that principled extensions of materialisation-based ontology reasoners are practically feasible and useful.\nAn interesting topic for future work is to see whether our acyclicity notions can be used in a more general logic programming setting. We see several main sources of technical difficulties towards this goal. First, general logic programs can contain functional terms in body atoms. Such terms can ‘cancel out’ function symbols introduced by head atoms, and it is not clear how to take this into account in an acyclicity test. Second, logic programs can contain atoms under nonmonotonic negation, which are likely to need special treatment; Magka, Krötzsch, and Horrocks (2013) recently made a first step in that direction. Third, it might be desirable to modularise the ways in which these different concerns are handled and thus arbitrarily combine the approaches for handling function symbols in the body and/or the head with the approaches for dealing with nonmonotonic negation."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work was supported by the Royal Society, the Seventh Framework Program (FP7) of the European Commission under Grant Agreement 318338, ‘Optique’, and the EPSRC projects ExODA, Score!, and MaSI3."
    } ],
    "references" : [ {
      "title" : "The Description Logic Handbook: Theory, Implementation and Applications (2nd edition)",
      "author" : [ "F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider" ],
      "venue" : null,
      "citeRegEx" : "Baader et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2007
    }, {
      "title" : "Improving the Forward Chaining Algorithm for Conceptual Graphs Rules",
      "author" : [ "Baget", "J.-F" ],
      "venue" : "Proc. of the 9th Int. Conf. on Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "Baget and J..F.,? \\Q2004\\E",
      "shortCiteRegEx" : "Baget and J..F.",
      "year" : 2004
    }, {
      "title" : "On rules with existential variables: Walking the decidability line",
      "author" : [ "Baget", "J.-F", "M. Leclère", "Mugnier", "M.-L", "E. Salvat" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Baget et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Baget et al\\.",
      "year" : 2011
    }, {
      "title" : "Towards Farsighted Dependencies for Existential Rules",
      "author" : [ "Baget", "J.-F", "Mugnier", "M.-L", "M. Thomazo" ],
      "venue" : "Proc. of the 5th Int. Conf. on Web Reasoning and Rule Systems (RR 2011),",
      "citeRegEx" : "Baget et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Baget et al\\.",
      "year" : 2011
    }, {
      "title" : "Hyper Tableaux",
      "author" : [ "P. Baumgartner", "U. Furbach", "I. Niemelä" ],
      "venue" : "In Proc. of the European Workshop on Logics in Artificial Intelligence (JELIA ’96),",
      "citeRegEx" : "Baumgartner et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Baumgartner et al\\.",
      "year" : 1996
    }, {
      "title" : "The Implication Problem for Data Dependencies",
      "author" : [ "C. Beeri", "M.Y. Vardi" ],
      "venue" : "Proc. of the 8th Colloquium on Automata, Languages and Programming (ICALP 1981),",
      "citeRegEx" : "Beeri and Vardi,? \\Q1981\\E",
      "shortCiteRegEx" : "Beeri and Vardi",
      "year" : 1981
    }, {
      "title" : "Implementing OWL 2 RL and OWL 2 QL rule-sets for OWLIM",
      "author" : [ "B. Bishop", "S. Bojanov" ],
      "venue" : "Proc. of the OWL: Expreiences and Directions Workshop (OWLED 2011),",
      "citeRegEx" : "Bishop and Bojanov,? \\Q2011\\E",
      "shortCiteRegEx" : "Bishop and Bojanov",
      "year" : 2011
    }, {
      "title" : "Sesame: A Generic Architecture for Storing and Querying RDF and RDF Schema",
      "author" : [ "J. Broekstra", "A. Kampman", "F. van Harmelen" ],
      "venue" : "Proc. of the 1st Int. Semantic Web Conf. (ISWC 2002),",
      "citeRegEx" : "Broekstra et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Broekstra et al\\.",
      "year" : 2002
    }, {
      "title" : "Query Answering under Non-guarded Rules in Datalog±",
      "author" : [ "A. Cal̀ı", "G. Gottlob", "A. Pieris" ],
      "venue" : "Proc. of the 4th Int. Conf. on Web Reasoning and Rule Systems (RR 2010),",
      "citeRegEx" : "Cal̀ı et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Cal̀ı et al\\.",
      "year" : 2010
    }, {
      "title" : "New Expressive Languages for Ontological Query Answering",
      "author" : [ "A. Cal̀ı", "G. Gottlob", "A. Pieris" ],
      "venue" : "Proc. of the 25th National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Cal̀ı et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Cal̀ı et al\\.",
      "year" : 2011
    }, {
      "title" : "Computable Functions in ASP: Theory and Implementation",
      "author" : [ "F. Calimeri", "S. Cozza", "G. Ianni", "N. Leone" ],
      "venue" : "Proc. of the 24th Int. Conf. on Logic Programming (ICLP 2008),",
      "citeRegEx" : "Calimeri et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Calimeri et al\\.",
      "year" : 2008
    }, {
      "title" : "Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "Jena: Implementing the Semantic Web Recommendations",
      "author" : [ "J.J. Carroll", "I. Dickinson", "C. Dollin", "D. Reynolds", "A. Seaborne", "K. Wilkinson" ],
      "venue" : "Proc. of the 13th Int. Conf. on World Wide Web (WWW 2004)—Alternate Track,",
      "citeRegEx" : "Carroll et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Carroll et al\\.",
      "year" : 2004
    }, {
      "title" : "Acyclicity Conditions and their Application to Query Answering in Description Logics",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "M. Krötzsch", "C. Kupke", "D. Magka", "B. Motik", "Z. Wang" ],
      "venue" : "Proc. of the 13th Int",
      "citeRegEx" : "Grau et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2012
    }, {
      "title" : "OWL 2: The next step for OWL",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "B. Motik", "B. Parsia", "P. Patel-Schneider", "U. Sattler" ],
      "venue" : "Journal of Web Semantics: Science, Services and Agents on the World Wide Web,",
      "citeRegEx" : "Grau et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov" ],
      "venue" : "ACM Computing Surveys,",
      "citeRegEx" : "Dantsin et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Dantsin et al\\.",
      "year" : 2001
    }, {
      "title" : "Termination of Logic Programs: The Never-Ending Story",
      "author" : [ "D. De Schreye", "S. Decorte" ],
      "venue" : "Journal of Logic Programming,",
      "citeRegEx" : "Schreye and Decorte,? \\Q1994\\E",
      "shortCiteRegEx" : "Schreye and Decorte",
      "year" : 1994
    }, {
      "title" : "Deciding Regular Grammar Logics with Converse Through First-Order Logic",
      "author" : [ "S. Demri", "H. de Nivelle" ],
      "venue" : "Journal of Logic, Language and Information,",
      "citeRegEx" : "Demri and Nivelle,? \\Q2005\\E",
      "shortCiteRegEx" : "Demri and Nivelle",
      "year" : 2005
    }, {
      "title" : "The chase revisited",
      "author" : [ "A. Deutsch", "A. Nash", "J.B. Remmel" ],
      "venue" : "Proc. of the 27th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS",
      "citeRegEx" : "Deutsch et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Deutsch et al\\.",
      "year" : 2008
    }, {
      "title" : "Query Answering in the Description Logic Horn-SHIQ",
      "author" : [ "T. Eiter", "G. Gottlob", "M. Ortiz", "M. Simkus" ],
      "venue" : "Proc. of the 11th European Conference on Logics in Artificial Intelligence (JELIA 2008),",
      "citeRegEx" : "Eiter et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2008
    }, {
      "title" : "Data exchange: semantics and query answering",
      "author" : [ "R. Fagin", "P.G. Kolaitis", "R.J. Miller", "L. Popa" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "Fagin et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Fagin et al\\.",
      "year" : 2005
    }, {
      "title" : "Framework for an Automated Comparison of Description Logic Reasoners",
      "author" : [ "T. Gardiner", "D. Tsarkov", "I. Horrocks" ],
      "venue" : "Proc. of the 5th Int. Semantic Web Conference (ISWC 2006),",
      "citeRegEx" : "Gardiner et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Gardiner et al\\.",
      "year" : 2006
    }, {
      "title" : "GrinGo: A New Grounder for Answer Set Programming",
      "author" : [ "M. Gebser", "T. Schaub", "S. Thiele" ],
      "venue" : "Proc. of the 9th Int. Conf. on Logic Programming and Nonmonotonic Reasoning (LPNMR 2007),",
      "citeRegEx" : "Gebser et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2007
    }, {
      "title" : "Conjunctive Query Answering for the Description Logic SHIQ",
      "author" : [ "B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Glimm et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Glimm et al\\.",
      "year" : 2008
    }, {
      "title" : "On the Termination of Logic Programs with Function Symbols",
      "author" : [ "S. Greco", "F. Spezzano", "I. Trubitsyna" ],
      "venue" : "Proc. of the 8th Int. Conf. on Logic Programming (ICLP 2012),",
      "citeRegEx" : "Greco et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Greco et al\\.",
      "year" : 2012
    }, {
      "title" : "Structure-based classification and ontology in chemistry",
      "author" : [ "J. Hastings", "D. Magka", "C. Batchelor", "L. Duan", "R. Stevens", "M. Ennis", "C. Steinbeck" ],
      "venue" : "Journal of Cheminformatics,",
      "citeRegEx" : "Hastings et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Hastings et al\\.",
      "year" : 2012
    }, {
      "title" : "A Proposal for an OWL Rules Language",
      "author" : [ "I. Horrocks", "P.F. Patel-Schneider" ],
      "venue" : "In Proc. of the 13th Int. World Wide Web Conference (WWW",
      "citeRegEx" : "Horrocks and Patel.Schneider,? \\Q2004\\E",
      "shortCiteRegEx" : "Horrocks and Patel.Schneider",
      "year" : 2004
    }, {
      "title" : "A Tableau Decision Procedure for SHOIQ",
      "author" : [ "I. Horrocks", "U. Sattler" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Horrocks and Sattler,? \\Q2007\\E",
      "shortCiteRegEx" : "Horrocks and Sattler",
      "year" : 2007
    }, {
      "title" : "Owl rules: A proposal and prototype implementation",
      "author" : [ "I. Horrocks", "P.F. Patel-Schneider", "S. Bechhofer", "D. Tsarkov" ],
      "venue" : "J. Web Sem.,",
      "citeRegEx" : "Horrocks et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Horrocks et al\\.",
      "year" : 2005
    }, {
      "title" : "Data Complexity of Reasoning in Very Expressive Description Logics",
      "author" : [ "U. Hustadt", "B. Motik", "U. Sattler" ],
      "venue" : "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Hustadt et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Hustadt et al\\.",
      "year" : 2005
    }, {
      "title" : "Testing Containment of Conjunctive Queries under Functional and Inclusion Dependencies",
      "author" : [ "D.S. Johnson", "A.C. Klug" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "Johnson and Klug,? \\Q1984\\E",
      "shortCiteRegEx" : "Johnson and Klug",
      "year" : 1984
    }, {
      "title" : "OWLIM – A Pragmatic Semantic Repository for OWL",
      "author" : [ "A. Kiryakov", "D. Ognyanov", "D. Manov" ],
      "venue" : "Proc. of the Int. Workshop on Web Information Systems Engineering (WISE 2005),",
      "citeRegEx" : "Kiryakov et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Kiryakov et al\\.",
      "year" : 2005
    }, {
      "title" : "The Combined Approach to Ontology-Based Data Access",
      "author" : [ "R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2011
    }, {
      "title" : "Extending Decidable Existential Rules by Joining Acyclicity and Guardedness",
      "author" : [ "M. Krötzsch", "S. Rudolph" ],
      "venue" : "Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Krötzsch and Rudolph,? \\Q2011\\E",
      "shortCiteRegEx" : "Krötzsch and Rudolph",
      "year" : 2011
    }, {
      "title" : "On the Relationship of Joint Acyclicity and SuperWeak Acyclicity",
      "author" : [ "M. Krötzsch", "S. Rudolph" ],
      "venue" : "Tech. rep. 3037,",
      "citeRegEx" : "Krötzsch and Rudolph,? \\Q2013\\E",
      "shortCiteRegEx" : "Krötzsch and Rudolph",
      "year" : 2013
    }, {
      "title" : "Conjunctive Queries for a Tractable Fragment of OWL",
      "author" : [ "M. Krötzsch", "S. Rudolph", "P. Hitzler" ],
      "venue" : "Proc. of the 6th Int. Semantic Web Conference (ISWC 2007),",
      "citeRegEx" : "Krötzsch et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Krötzsch et al\\.",
      "year" : 2007
    }, {
      "title" : "The Even More Irresistible SROIQ",
      "author" : [ "O. Kutz", "I. Horrocks", "U. Sattler" ],
      "venue" : "Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Kutz et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Kutz et al\\.",
      "year" : 2006
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "Leone et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2006
    }, {
      "title" : "One More Decidable Class of Finitely Ground Programs",
      "author" : [ "Y. Lierler", "V. Lifschitz" ],
      "venue" : "Proc. of the 25th Int. Conf. on Logic Programming (ICLP 2009),",
      "citeRegEx" : "Lierler and Lifschitz,? \\Q2009\\E",
      "shortCiteRegEx" : "Lierler and Lifschitz",
      "year" : 2009
    }, {
      "title" : "Conjunctive Query Answering in the Description Logic EL Using a Relational Database System",
      "author" : [ "C. Lutz", "D. Toman", "F. Wolter" ],
      "venue" : null,
      "citeRegEx" : "Lutz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2009
    }, {
      "title" : "Computing Stable Models for Nonmonotonic Existential Rules",
      "author" : [ "D. Magka", "M. Krötzsch", "I. Horrocks" ],
      "venue" : "In Proc. of the 23rd Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Magka et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Magka et al\\.",
      "year" : 2013
    }, {
      "title" : "Modelling Structured Domains Using Description Graphs and Logic Programming",
      "author" : [ "D. Magka", "B. Motik", "I. Horrocks" ],
      "venue" : "Proc. of the 9th Extended Semantic Web Conference (ESWC 2012),",
      "citeRegEx" : "Magka et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Magka et al\\.",
      "year" : 2012
    }, {
      "title" : "Testing Implications of Data Dependencies",
      "author" : [ "D. Maier", "A.O. Mendelzon", "Y. Sagiv" ],
      "venue" : "ACM Transactions on Database Systems,",
      "citeRegEx" : "Maier et al\\.,? \\Q1979\\E",
      "shortCiteRegEx" : "Maier et al\\.",
      "year" : 1979
    }, {
      "title" : "Generalized schema-mappings: from termination to tractability",
      "author" : [ "B. Marnette" ],
      "venue" : "Proc. of the 28th ACM SIGMOD-SIGACT-SIGART Symposium on Principles of Database Systems (PODS",
      "citeRegEx" : "Marnette,? \\Q2009\\E",
      "shortCiteRegEx" : "Marnette",
      "year" : 2009
    }, {
      "title" : "Tractable Schema Mappings Under Oblivious Termination",
      "author" : [ "B. Marnette" ],
      "venue" : "Ph.D. thesis,",
      "citeRegEx" : "Marnette,? \\Q2010\\E",
      "shortCiteRegEx" : "Marnette",
      "year" : 2010
    }, {
      "title" : "Combining a DL Reasoner and a Rule Engine for Improving Entailment-Based OWL Reasoning",
      "author" : [ "G. Meditskos", "N. Bassiliades" ],
      "venue" : "International Semantic Web Conference,",
      "citeRegEx" : "Meditskos and Bassiliades,? \\Q2008\\E",
      "shortCiteRegEx" : "Meditskos and Bassiliades",
      "year" : 2008
    }, {
      "title" : "On the Termination of the Chase Algorithm",
      "author" : [ "M. Meier" ],
      "venue" : "Ph.D. thesis, Universität Freiburg",
      "citeRegEx" : "Meier,? \\Q2010\\E",
      "shortCiteRegEx" : "Meier",
      "year" : 2010
    }, {
      "title" : "On Chase Termination Beyond Stratification",
      "author" : [ "M. Meier", "M. Schmidt", "G. Lausen" ],
      "venue" : "Proceedings of the VLDB Endowment,",
      "citeRegEx" : "Meier et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Meier et al\\.",
      "year" : 2009
    }, {
      "title" : "OWL 2 Web Ontology Language: Profiles, W3C Recommendation",
      "author" : [ "B. Motik", "B. Cuenca Grau", "I. Horrocks", "Z. Wu", "A. Fokoue", "C. Lutz" ],
      "venue" : null,
      "citeRegEx" : "Motik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2009
    }, {
      "title" : "Hypertableau Reasoning for Description Logics",
      "author" : [ "B. Motik", "R. Shearer", "I. Horrocks" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Motik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2009
    }, {
      "title" : "Experiences Using Logic Programming in Bioinformatics",
      "author" : [ "C. Mungall" ],
      "venue" : "Proc.óf the 25th Int. Conf. on Logic Programming (ICLP 2009),",
      "citeRegEx" : "Mungall,? \\Q2009\\E",
      "shortCiteRegEx" : "Mungall",
      "year" : 2009
    }, {
      "title" : "Data Complexity of Query Answering in Expressive Description Logics via Tableaux",
      "author" : [ "M. Ortiz", "D. Calvanese", "T. Eiter" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2008
    }, {
      "title" : "Query Answering in the Horn Fragments of the Description Logics SHOIQ and SROIQ",
      "author" : [ "M. Ortiz", "S. Rudolph", "M. Simkus" ],
      "venue" : "Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2011
    }, {
      "title" : "Tractable Query Answering and Rewriting under Description Logic Constraints",
      "author" : [ "H. Pérez-Urbina", "B. Motik", "I. Horrocks" ],
      "venue" : "Journal of Applied Logic,",
      "citeRegEx" : "Pérez.Urbina et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Pérez.Urbina et al\\.",
      "year" : 2009
    }, {
      "title" : "Nominals, Inverses, Counting, and Conjunctive Queries or: Why Infinity is your Friend",
      "author" : [ "S. Rudolph", "B. Glimm" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Rudolph and Glimm,? \\Q2010\\E",
      "shortCiteRegEx" : "Rudolph and Glimm",
      "year" : 2010
    }, {
      "title" : "Chase Termination: A Constraints Rewriting Approach",
      "author" : [ "F. Spezzano", "S. Greco" ],
      "venue" : "Proceedings of the VLDB Endownment,",
      "citeRegEx" : "Spezzano and Greco,? \\Q2010\\E",
      "shortCiteRegEx" : "Spezzano and Greco",
      "year" : 2010
    }, {
      "title" : "Omega-Restricted Logic Programs",
      "author" : [ "T. Syrjänen" ],
      "venue" : "Proc. of the 6th Int. Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR 2001),",
      "citeRegEx" : "Syrjänen,? \\Q2001\\E",
      "shortCiteRegEx" : "Syrjänen",
      "year" : 2001
    }, {
      "title" : "The Smodels System",
      "author" : [ "T. Syrjänen", "I. Niemelä" ],
      "venue" : "Proc. of the 6th Int. Conf. on Logic Programming and Nonmonotonic Reasoning (LPNMR 2001),",
      "citeRegEx" : "Syrjänen and Niemelä,? \\Q2001\\E",
      "shortCiteRegEx" : "Syrjänen and Niemelä",
      "year" : 2001
    }, {
      "title" : "Implementing an Inference Engine for RDFS/OWL Constructs and UserDefined Rules in Oracle",
      "author" : [ "Z. Wu", "G. Eadon", "S. Das", "E.I. Chong", "V. Kolovski", "M. Annamalai", "J. Srinivasan" ],
      "venue" : "Proc. of the 24th Int. Conf. on Data Engineering (ICDE",
      "citeRegEx" : "Wu et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Wu et al\\.",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 50,
      "context" : "Practical applications of existential rules range from bioinformatics (Mungall, 2009) to modelling complex structures of chemical compounds (Magka, Motik, & Horrocks, 2012; Hastings, Magka, Batchelor, Duan, Stevens, Ennis, & Steinbeck, 2012).",
      "startOffset" : 70,
      "endOffset" : 85
    }, {
      "referenceID" : 20,
      "context" : "Weak acyclicity (WA) (Fagin et al., 2005) was one of the first such notions, and it was extended to notions such as safety (Meier, Schmidt, & Lausen, 2009), stratification (Deutsch et al.",
      "startOffset" : 21,
      "endOffset" : 41
    }, {
      "referenceID" : 18,
      "context" : ", 2005) was one of the first such notions, and it was extended to notions such as safety (Meier, Schmidt, & Lausen, 2009), stratification (Deutsch et al., 2008), acyclicity of a graph of rule dependencies (aGRD) (Baget, Mugnier, & Thomazo, 2011b), joint acyclicity (JA) (Krötzsch & Rudolph, 2011), and super-weak acyclicity (SWA) (Marnette, 2009).",
      "startOffset" : 138,
      "endOffset" : 160
    }, {
      "referenceID" : 43,
      "context" : ", 2008), acyclicity of a graph of rule dependencies (aGRD) (Baget, Mugnier, & Thomazo, 2011b), joint acyclicity (JA) (Krötzsch & Rudolph, 2011), and super-weak acyclicity (SWA) (Marnette, 2009).",
      "startOffset" : 177,
      "endOffset" : 193
    }, {
      "referenceID" : 56,
      "context" : "Several such notions have been implemented in state of the art logic programming engines, such as omega-restrictedness (Syrjänen, 2001) from the Smodels system (Syrjänen & Niemelä, 2001), lambda-restrictedness from the ASP grounder GrinGo (Gebser, Schaub, & Thiele, 2007), argument-restrictedness (Lierler & Lifschitz, 2009) from the DLV system (Leone, Pfeifer, Faber, Eiter, Gottlob, Perri, & Scarcello, 2006), and many others (Calimeri, Cozza, Ianni, & Leone, 2008; Greco, Spezzano, & Trubitsyna, 2012; De Schreye & Decorte, 1994).",
      "startOffset" : 119,
      "endOffset" : 135
    }, {
      "referenceID" : 43,
      "context" : "Equality can be incorporated via singularisation—a technique proposed by Marnette (2009) that transforms the rules to encode the effects of equality.",
      "startOffset" : 73,
      "endOffset" : 89
    }, {
      "referenceID" : 43,
      "context" : "Equality can be incorporated via singularisation—a technique proposed by Marnette (2009) that transforms the rules to encode the effects of equality. Singularisation is orthogonal to acyclicity: after computing the transformed rules, one can use MFA, MSA, or in fact any notion to check whether the result is acyclic; if so, the chase of the signularised rules terminates, and the chase result can be used in a particular way to answer arbitrary CQs. Unfortunately, singularisation is nondeterministic: some ways of transforming the rules may produce acyclic rule sets, but not all ways are guaranteed to do so. In this paper, we refine singularisation to obtain practically useful upper and lower bounds for acyclicity. We also show that, when used with JA, our lower bound actually coincides with WA. We next turn our attention to theoretical and practical issues of using acyclicity for materialisation-based CQ answering over ontologies. On the theoretical side, we show that checking MFA and MSA of Horn-SROIF ontologies is ExpTime- and PTime-complete, respectively, and that answering CQs over acyclic Horn-SROIF ontologies is ExpTimecomplete as well. Furthermore, we show that, for Horn-SHIF ontologies, the complexity of checking MFA and of answering CQs drops to PSpace. Answering CQs is ExpTimecomplete for general (i.e., not acyclic) Horn-SHIF ontologies (Eiter, Gottlob, Ortiz, & Simkus, 2008; Ortiz, Rudolph, & Simkus, 2011), so acyclicity makes this problem easier. Furthermore, Horn ontologies can be extended with arbitrary SWRL rules (Horrocks & Patel-Schneider, 2004) without affecting decidability or worst-case complexity, provided that the union of the ontology and SWRL rules is acyclic; this is in contrast to the general case, where SWRL extensions of DLs easily lead to undecidability. On the practical side, we explore the limits of reasoning with acyclic OWL 2 ontologies via materialisation. We checked MFA, MSA, and JA for 336 Horn ontologies; furthermore, to estimate the impact of materialisation, we compared the size of the materialisation with the number of facts in the original ontologies. Our experiments revealed that many ontologies are MSA, and that some complex ones are MSA but not JA; furthermore, the universal models obtained via materialisation are typically not too large. Thus, our results suggest that principled, materialisation-based reasoning for ontologies beyond the OWL 2 RL profile may be practically feasible. This is an extended version of a paper by Cuenca Grau, Horrocks, Krötzsch, Kupke, Magka, Motik, and Wang (2012) published at KR 2012.",
      "startOffset" : 73,
      "endOffset" : 2579
    }, {
      "referenceID" : 43,
      "context" : "Answering CQs can be characterised using chase, and in this paper we use the skolem chase variant (Marnette, 2009).",
      "startOffset" : 98,
      "endOffset" : 114
    }, {
      "referenceID" : 20,
      "context" : "If the skolem chase of I and Σ terminates, then both the nonoblivious chase (Fagin et al., 2005) and the core chase (Deutsch et al.",
      "startOffset" : 76,
      "endOffset" : 96
    }, {
      "referenceID" : 18,
      "context" : ", 2005) and the core chase (Deutsch et al., 2008) of I and Σ terminate as well.",
      "startOffset" : 27,
      "endOffset" : 49
    }, {
      "referenceID" : 43,
      "context" : "The skolem chase for I∗ Σ and Σ terminates if and only if the skolem chase of Σ terminates universally (Marnette, 2009).",
      "startOffset" : 103,
      "endOffset" : 119
    }, {
      "referenceID" : 20,
      "context" : "Weak acyclicity (WA) (Fagin et al., 2005) can be applied to existential rules that contain the equality predicate.",
      "startOffset" : 21,
      "endOffset" : 41
    }, {
      "referenceID" : 43,
      "context" : "Since Σ is weakly acyclic and equalityfree, Σ is super-weakly acyclic (Marnette, 2009); as we will show in Section 4 (see Theorem 19), Σ is then MFA as well.",
      "startOffset" : 70,
      "endOffset" : 86
    }, {
      "referenceID" : 8,
      "context" : "Cal̀ı et al. (2010b) show that, for such I, Σ, and Q, deciding I ∪ Σ |= Q is 2ExpTime-complete.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 15,
      "context" : "Checking whether I ∪ Σ |= Q is ExpTime-complete in general (Dantsin et al., 2001).",
      "startOffset" : 59,
      "endOffset" : 81
    }, {
      "referenceID" : 20,
      "context" : "Weak acyclicity (Fagin et al., 2005) was one of the first such notions, and it has spurred on the research into more sophisticated notions for ensuring chase termination.",
      "startOffset" : 16,
      "endOffset" : 36
    }, {
      "referenceID" : 55,
      "context" : "The transformation by Spezzano and Greco (2010) produces a set Σ′ that consists of three groups of rules.",
      "startOffset" : 22,
      "endOffset" : 48
    }, {
      "referenceID" : 55,
      "context" : "In contrast, Σ′ is WA; furthermore, Spezzano and Greco (2010) show that, for each instance I and each vector of ground terms ~t, we have P̂ (~t) ∈ I∞ Σ′ if and only if P (~t) ∈ I∞ Σ .",
      "startOffset" : 36,
      "endOffset" : 62
    }, {
      "referenceID" : 55,
      "context" : "Finally, note that the transformation by Spezzano and Greco (2010) is independent from the notion used to check the acyclicity of the transformed rule set; hence, given an arbitrary acyclicity notion X, one can define Adn-X in the obvious way.",
      "startOffset" : 41,
      "endOffset" : 67
    }, {
      "referenceID" : 2,
      "context" : "Existential rules can capture knowledge representation formalisms such as Horn fragments of description logics (see Section 6), conceptual graphs (Baget, 2004; Baget et al., 2011a), and datalog± rules (Cal̀ı et al., 2010a), and so acyclicity notions allow for materialisationbased query answering over knowledge bases. In this context, Baget (2004) and Baget et al.",
      "startOffset" : 160,
      "endOffset" : 349
    }, {
      "referenceID" : 2,
      "context" : "Existential rules can capture knowledge representation formalisms such as Horn fragments of description logics (see Section 6), conceptual graphs (Baget, 2004; Baget et al., 2011a), and datalog± rules (Cal̀ı et al., 2010a), and so acyclicity notions allow for materialisationbased query answering over knowledge bases. In this context, Baget (2004) and Baget et al. (2011a) proposed the notion of acyclic graph rule dependencies (aGRD).",
      "startOffset" : 160,
      "endOffset" : 374
    }, {
      "referenceID" : 18,
      "context" : "This condition intuitively ensures that an application of r1 to I enables r2 to derive something new; analogous optimisations were proposed by Deutsch et al. (2008) and Greco et al.",
      "startOffset" : 143,
      "endOffset" : 165
    }, {
      "referenceID" : 18,
      "context" : "This condition intuitively ensures that an application of r1 to I enables r2 to derive something new; analogous optimisations were proposed by Deutsch et al. (2008) and Greco et al. (2012). It should be clear that Definition 23 is stronger than the one by Baget.",
      "startOffset" : 143,
      "endOffset" : 189
    }, {
      "referenceID" : 18,
      "context" : "This condition intuitively ensures that an application of r1 to I enables r2 to derive something new; analogous optimisations were proposed by Deutsch et al. (2008) and Greco et al. (2012). It should be clear that Definition 23 is stronger than the one by Baget. To unify the notions used in various parts of this paper, we included this optimisation into Definition 23; however, we nevertheless call the resulting stronger notion aGRD. The following example shows that aGRD, even in its weaker form as originally proposed by Baget (2004), is not contained in SWA.",
      "startOffset" : 143,
      "endOffset" : 539
    }, {
      "referenceID" : 24,
      "context" : "Note that the additional condition by Greco et al. (2012) plays no role here.",
      "startOffset" : 38,
      "endOffset" : 58
    }, {
      "referenceID" : 24,
      "context" : "Note that the additional condition by Greco et al. (2012) plays no role here. Thus, we have r 6≺ r, so Σ is aGRD even in the weaker form by Baget (2004). However, one can easily check that Σ is not SWA.",
      "startOffset" : 38,
      "endOffset" : 153
    }, {
      "referenceID" : 18,
      "context" : "Combinations of rule dependencies with acyclicity notions have also been considered in databases: Deutsch et al. (2008) proposed a notion of stratification, and Meier et al.",
      "startOffset" : 98,
      "endOffset" : 120
    }, {
      "referenceID" : 18,
      "context" : "Combinations of rule dependencies with acyclicity notions have also been considered in databases: Deutsch et al. (2008) proposed a notion of stratification, and Meier et al. (2009) further developed this idea and proposed a notion of c-stratification.",
      "startOffset" : 98,
      "endOffset" : 181
    }, {
      "referenceID" : 18,
      "context" : "Then, rule r is not applicable to R(t2, t3) or R(t3, t3) since in either case the head atom is satisfied; hence, the rule dependency graphs by Deutsch et al. and Meier et al. are both empty. These results can be summarised as follows: if a rule set Σ satisfies the notion by Deutsch et al., then for each instance I there exists a finite nonoblivious chase sequence; furthermore, if Σ satisfies the notion by Meier et al., then for each instance I all chase sequences (regardless of the rule application strategy) are finite. Meier (2010) discusses in detail the subtle differences between these notions.",
      "startOffset" : 143,
      "endOffset" : 539
    }, {
      "referenceID" : 10,
      "context" : "Furthermore, note that Calimeri et al. (2008) defined FD as follows:",
      "startOffset" : 23,
      "endOffset" : 46
    }, {
      "referenceID" : 22,
      "context" : "Finally, we note that λ-restricted programs by Gebser et al. (2007) and ω-restricted programs by Syrjänen (2001) are both included in FD and AR; thus, when restricted to skolemised existential rules, these notions are also included in JA.",
      "startOffset" : 47,
      "endOffset" : 68
    }, {
      "referenceID" : 22,
      "context" : "Finally, we note that λ-restricted programs by Gebser et al. (2007) and ω-restricted programs by Syrjänen (2001) are both included in FD and AR; thus, when restricted to skolemised existential rules, these notions are also included in JA.",
      "startOffset" : 47,
      "endOffset" : 113
    }, {
      "referenceID" : 24,
      "context" : "Thus, in the rest of this section, we simply reuse the rule dependency relation ≺ from Definition 23, which gives us a slightly stronger version of ΓA for existential rules than the one proposed by Greco et al. (2012). Furthermore, Greco et al.",
      "startOffset" : 198,
      "endOffset" : 218
    }, {
      "referenceID" : 24,
      "context" : "Thus, in the rest of this section, we simply reuse the rule dependency relation ≺ from Definition 23, which gives us a slightly stronger version of ΓA for existential rules than the one proposed by Greco et al. (2012). Furthermore, Greco et al. (2012) handle logic programming rules with functional terms in the body.",
      "startOffset" : 198,
      "endOffset" : 252
    }, {
      "referenceID" : 24,
      "context" : "Greco et al. (2012) stated that AR is strictly contained in ΓA, but we were unable to find a formal proof of that statement; in fact, Example 44 shows that this is not the case, and that actually ΓA≺ ( AR≺ holds.",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 43,
      "context" : "In order to use the skolem chase with rule sets such as the ones in Example 47, Marnette (2009) proposed the singularisation technique.",
      "startOffset" : 80,
      "endOffset" : 96
    }, {
      "referenceID" : 43,
      "context" : "In order to use the skolem chase with rule sets such as the ones in Example 47, Marnette (2009) proposed the singularisation technique. Roughly speaking, singularisation replaces the equality predicate ≈ with a fresh binary predicate Eq to clarify that the two are to be treated differently; furthermore, it axiomatises Eq as reflexive, symmetric, and transitive, but it does not introduce replacement rules analogous to (4); finally, it modifies the rules in Σ to take the lack of the replacement rules into account. The chase of the transformed rule set is not a model of Σ, but it can be used to answer queries over Σ in a particular welldefined way. The modification of Σ, however, is nondeterministic: there are many ways to modify Σ and, while some may ensure termination of the skolem chase, not all are required to do so. We next recapitulate the definition of singularisation by Marnette (2009).",
      "startOffset" : 80,
      "endOffset" : 904
    }, {
      "referenceID" : 43,
      "context" : "Marnette (2010) showed that, for an arbitrary ρ, interpretation ρ(I ′) is a universal model of Σ and I—that is, ρ(I ′) can be homomorphically embedded into an arbitrary model of Σ and I.",
      "startOffset" : 0,
      "endOffset" : 16
    }, {
      "referenceID" : 52,
      "context" : ", not acyclic) DL TBoxes is 2ExpTime- and ExpTime-complete for Horn-SROIF (Ortiz et al., 2011) and Horn-SHIF (Eiter et al.",
      "startOffset" : 74,
      "endOffset" : 94
    }, {
      "referenceID" : 19,
      "context" : ", 2011) and Horn-SHIF (Eiter et al., 2008), respectively.",
      "startOffset" : 22,
      "endOffset" : 42
    }, {
      "referenceID" : 48,
      "context" : "Motik et al. (2009b) prove an analogous claim for a more general description logic, and their proof carries over to the above setting with only syntactic changes.",
      "startOffset" : 0,
      "endOffset" : 21
    }, {
      "referenceID" : 38,
      "context" : "Of the 123 ontologies that are not MFA, seven ontologies are in ELH, so CQ answering over these ontologies can be realised using the combined approaches by Lutz et al. (2009) and Kontchakov et al.",
      "startOffset" : 156,
      "endOffset" : 175
    }, {
      "referenceID" : 32,
      "context" : "(2009) and Kontchakov et al. (2011). The five older versions of OBO ontologies (IDs 00359, 00374, 00376, 00382, and 00486) are MSA, whereas their newer versions (IDs 00360, 00375, 00377, 00383, and 00487) are not MFA.",
      "startOffset" : 11,
      "endOffset" : 36
    }, {
      "referenceID" : 43,
      "context" : "To this end, we presented several optimisations of the singularisation technique by Marnette (2009). Our optimisations can often reduce the number of acyclicity checks needed, thus making the singularisation technique more suitable for practical use.",
      "startOffset" : 84,
      "endOffset" : 100
    } ],
    "year" : 2013,
    "abstractText" : "Answering conjunctive queries (CQs) over a set of facts extended with existential rules is a prominent problem in knowledge representation and databases. This problem can be solved using the chase algorithm, which extends the given set of facts with fresh facts in order to satisfy the rules. If the chase terminates, then CQs can be evaluated directly in the resulting set of facts. The chase, however, does not terminate necessarily, and checking whether the chase terminates on a given set of rules and facts is undecidable. Numerous acyclicity notions were proposed as sufficient conditions for chase termination. In this paper, we present two new acyclicity notions called model-faithful acyclicity (MFA) and model-summarising acyclicity (MSA). Furthermore, we investigate the landscape of the known acyclicity notions and establish a complete taxonomy of all notions known to us. Finally, we show that MFA and MSA generalise most of these notions. Existential rules are closely related to the Horn fragments of the OWL 2 ontology language; furthermore, several prominent OWL 2 reasoners implement CQ answering by using the chase to materialise all relevant facts. In order to avoid termination problems, many of these systems handle only the OWL 2 RL profile of OWL 2; furthermore, some systems go beyond OWL 2 RL, but without any termination guarantees. In this paper we also investigate whether various acyclicity notions can provide a principled and practical solution to these problems. On the theoretical side, we show that query answering for acyclic ontologies is of lower complexity than for general ontologies. On the practical side, we show that many of the commonly used OWL 2 ontologies are MSA, and that the number of facts obtained by materialisation is not too large. Our results thus suggest that principled development of materialisation-based OWL 2 reasoners is practically feasible.",
    "creator" : "TeX"
  }
}