{
  "name" : "1309.7145.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Propagating Regular Counting Constraints",
    "authors" : [ "Nicolas Beldiceanu", "Pierre Flener", "Justin Pearson", "Pascal Van Hentenryck" ],
    "emails" : [ "Nicolas.Beldiceanu@mines-nantes.fr", "pvh@nicta.com.au" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n30 9.\n71 45\nv1 [\ncs .A\nI] 2\n7 Se"
    }, {
      "heading" : "1 Introduction",
      "text" : "Constraints over finite sequences of variables arise in many sequencing and timetabling applications, and the last decade has witnessed significant research on how to model and propagate, in a generic way, idiosyncratic constraints that are often featured in these applications. The resulting modelling techniques are often based on formal languages and, in particular, deterministic finite automata (DFA). Indeed, DFAs are a convenient tool to model a wide variety of constraints, and their associated propagation algorithms can enforce domain consistency in polynomial time [3,9].\nThis paper is concerned with the concept of counter-DFA (cDFA), an extension of DFAs proposed in [3], and uses it to model regular counting constraints, that is constraints on the number of regular-language patterns occurring in a sequence of variables. cDFAs typically result in more concise and natural encodings of regular counting constraints compared to DFAs, but it is unknown if\nthey admit efficient propagators enforcing domain consistency. This paper originated as an attempt to settle this question. We consider the subset of cDFAs satisfying two conditions: (1) all their states are accepting, and (2) they manipulate a single counter that can be incremented by transitions. These conditions are satisfied for many regular counting constraints and offer a good compromise between expressiveness and efficiency.\nOur main contribution is to show that, for such a counter automaton A, it is possible to enforce domain consistency efficiently on atmost and atleast regular counting constraints. Constraint cAutomatonAtMost(N,X,A) holds if the counter of A is at most N after A has consumed sequence X . Constraint cAutomatonAtLeast(N,X,A) is defined similarly. We also prove the NPhardness of satisfiability testing for constraint cAutomaton(N,X,A), which holds if the counter of A is exactly N after A has consumed X . Compared to the CostRegular constraint [6], as generalised for the Choco solver [8], our contribution is a propagator for exact regular counting that uses asymptotically less space (for its internal datastructures) and yet propagates more on the variables of X . Furthermore, our propagators for atmost and atleast regular counting achieve domain consistency on the counter variable N (and X) in the same asymptotic time as the CostRegular propagator achieves only bounds consistency on N (but also domain consistency on X).\nThe rest of the paper is organised as follows. Section 2 defines cDFAs, regular counting constraints, and the class of cDFAs considered. Section 3 gives the propagator, its complexity, and its evaluation. Section 4 concludes the paper and discusses related work."
    }, {
      "heading" : "2 Background",
      "text" : ""
    }, {
      "heading" : "2.1 Deterministic Finite Counter Automata",
      "text" : "Recall that a deterministic finite automaton (DFA) is a tuple 〈Q,Σ, δ, q0, F 〉, where Q is the set of states, Σ is the alphabet, δ : Q ×Σ → Q is the transition function, q0 ∈ Q is the start state, and F ⊆ Q is the set of accepting states.\nThis paper considers a subclass of counter-DFAs in which all states are accepting and only one counter is used. The counter is initialised to 0 and increases by a given natural number at every transition. Such an automaton accepts every string and assigns a value to its counter. More formally, a counter-DFA (cDFA) is here specified as a tuple 〈Q,Σ, δ, q0, F 〉, where Q, Σ, q0, and F are as in a DFA except that F = Q and the DFA transition function δ is extended to the signature Q × Σ → Q × N, so that δ(q, ℓ) = 〈r, inc〉 indicates that r is the successor state of state q upon reading alphabet symbol ℓ and the counter must be incremented by inc. We also define two projections of this extended transition function: if δ(q, ℓ) = 〈r, inc〉, then δQ(q, ℓ) = r and δN(q, ℓ) = inc. Given δ(q, ℓ) = 〈r, inc〉, we denote by C(q ℓ → r) the counter increase inc of transition q ℓ → r from state q to state r upon consuming symbol ℓ. Similarly, we denote by C(q σ r) the counter increase of a path q σ r from state q to state r upon consuming a (possibly empty) string σ.\nExample 1. Consider the automatonAAB in Figure 1. It represents a cDFA with state set Q = {ǫ, a, aa} and alphabet Σ = {a, b}. The transition function δ is given by the labelled arcs between states, and the start state is q0 = ǫ (indicated by an arc coming from no state; we often denote the start state by ǫ, because it can be reached by consuming the empty string ǫ). Since the final states F are all the states in Q, this automaton recognises every string over {a, b} and is thus by itself not very interesting. However, the cDFA features a counter k that is initialised to 0 at the start state, incremented by 1 on the transition from state aa to state ǫ upon reading symbol ‘b’, and incremented by 0 on all other transitions. As a result, the final value of k is the number of occurrences of the word “aab” within the string."
    }, {
      "heading" : "2.2 Regular Counting Constraints",
      "text" : "A regular counting constraint is defined as a constraint that can be modelled by a cDFA. The cAutomaton(N,X,A) constraint holds if the value of variable N , called the counter variable, is equal to the final value of the counter after cDFA A has consumed the values of the entire sequence X of variables. Consider the constraint NumberWord(N,X,w), which holds if N is the number of occurrences of the non-empty word w in the sequence X of variables. Constraint NumberWord(N,X, “aab”) can be modelled by the cAutomaton(N,X,AAB) constraint with the automaton AAB specified in Figure 1."
    }, {
      "heading" : "2.3 Signature Constraints",
      "text" : "A constraint on a sequence X of variables can sometimes be modelled with the help of a DFA or cDFA that operates not on X , but on a sequence of signature variables that functionally depend via signature constraints on a sliding window of variables within X [3].\nFor example, the Among(N,X,V) constraint [4] requires N to be the number of variables in the sequence X that are assigned a value from the given set V . With signature constraints xi ∈ V ⇔ si = 1 and xi /∈ V ⇔ si = 0 (with xi ∈ X), we obtain a sequence of |X | signature variables si that can be used in a cDFA that counts the number of occurrences of value 1 in that sequence. Rather than labelling the transitions of such a cDFA with values of the domain of the signature variables (the set {0, 1} here), we label them with the corresponding\nconditions of the signature constraints, as in the cDFA AMONG given in Figure 2. Note that the choice of Among is purely pedagogical: we do not argue that this is the best way to model and propagate this constraint.\nIf each signature variable depends on a sliding window of size 1 within X (as for Among), then the signature constraints are unary. Our results also apply to cDFAs with unary signature constraints because a network of a cAutomatonAtMost constraint and unary signature constraints is Berge-acyclic."
    }, {
      "heading" : "3 The Propagator",
      "text" : ""
    }, {
      "heading" : "3.1 Feasibility Test and Domain Consistency Filtering",
      "text" : "Our propagator is defined in terms of the following concepts, which assume a sequence x1, . . . , xn of variables:\n– Define QCF(i) (respectively QCF(i)) to be the set of pairs 〈q, c〉 where c is the minimum (respectively maximum) counter increase (or value) after the automaton consumes string σ from state q0 to reach state q, for all strings σ = σ1 · · ·σi where i ∈ [0, n] and σj ∈ dom(xj) for each j ∈ [1, i].\n– Define QCB(i) (respectively QCB(i)) to be the set of pairs 〈q, c〉 where c is the minimum (respectively maximum) counter increase after the automaton consumes string σ from state q to reach a state appearing in QCF(n)\n(respectively QCF(n)), for all strings σ = σi · · ·σn where i ∈ [1, n+ 1] and σj ∈ dom(xj) for each j ∈ [i, n].\nExample 2. By illustrating one representative of these four quantities, we show that we have to maintain the maximum counter value for every state reachable from q0 in i steps, rather than just maintaining the overall maximum counter value and the set of states reachable from q0 in i steps. Consider the automaton RST in Figure 3, where q0 is ǫ. In a sequence of n = 6 variables x1, . . . , x6 that\nmust be assigned value ‘r’ or ‘t’, we have:\nQCF(0) = {〈ǫ, 0〉}\nQCF(1) = {〈ǫ, 0〉, 〈r, 1〉}\nQCF(2) = {〈ǫ, 1〉, 〈r, 1〉, 〈rr , 1〉}\nQCF(3) = {〈ǫ, 1〉, 〈r, 2〉, 〈rr , 1〉, 〈rrt , 1〉}\nQCF(4) = {〈ǫ, 2〉, 〈r, 2〉, 〈rr , 2〉, 〈rrt , 1〉, 〈rrtr , 3〉}\nQCF(5) = {〈ǫ, 2〉, 〈r, 3〉, 〈rr , 3〉, 〈rrt , 2〉, 〈rrtr , 3〉}\nQCF(6) = {〈ǫ, 3〉, 〈r, 3〉, 〈rr , 3〉, 〈rrt , 3〉, 〈rrtr , 4〉}\nIndeed, 〈rrtr , 4〉 ∈ QCF(6) because 〈rrt , 2〉 ∈ QCF(5) and there is a transition in A from rrt to rrtr on symbol ‘r’ with a counter increase of 2, even though three states have a higher counter value (namely 3) than rrt in QCF(5).\nTo compute QCF(i) and QCB(i), we need an operation that takes a set of state-and-integer pairs and keeps only the pairs 〈q, c〉 where there is no pair 〈q, c′〉 with c′ < c. Formally, trimMin(S) = {〈q, c〉 ∈ S | ∄〈q, c′〉 ∈ S : c′ < c}.\nFor brevity, we use trimMin φ(q,c) (〈q, c〉) to denote trimMin({〈q, c〉 | φ(q, c)}), for any condition φ. We inductively define QCF(i) and QCB(i) as follows:\nQCF(i) =\n\n \n \n{〈q0, 0〉} if i = 0\ntrimMin 〈q,c〉∈QCF(i−1)\nℓ∈dom(xi)\n(〈δQ(q, ℓ), c+ δN(q, ℓ)〉) if i ∈ [1, n]\nQCB(i) =\n\n  \n  \n{〈q, 0〉 | ∃c ∈ N : 〈q, c〉 ∈ QCF(n)} if i = n+ 1\ntrimMin 〈q′,c′〉∈QCB(i+1)\nℓ∈dom(xi) δ(q,ℓ)=〈q′,inc〉\n(〈q, c′ + inc〉) if i ∈ [1, n]\nWe prove that the inductively computed quantities correspond to the definitions of QCF(i) and QCB(i). First consider QCF(i). The base case QCF(0) follows from the initialisation to zero of the counter. By induction, suppose the set QCF(i−1) is correct. Before applying trimMin, the set contains all pairs obtained upon reading the symbol ℓ starting from some pair 〈q, c〉 in QCF(i− 1), where c is the minimum counter value for q over sequences of length i− 1. The trimMin operation then filters out all the pairs 〈q′, c′〉 with non-minimum counter value for q′. The correctness proof for QCB(i) is similar.\nWe define the cAutomatonAtMost(N,X,A) propagator. The propagator for cAutomatonAtLeast is similar. The following theorem gives a feasibility test.\nTheorem 1. A cAutomatonAtMost(N, [x1, . . . , xn],A) constraint has a solution iff the minimum value of the counter of A after consuming the entire sequence is at most the maximum of the domain of N :\nmin 〈q,c〉∈QCF(n) c ≤ max(dom(N))\nProof. Suppose c is the minimum counter value such that 〈q, c〉 ∈ QCF(n) for some state q. By the definition of QCF(n), there is some sequence σ = σ1 · · ·σn where for all 1 ≤ j ≤ n the symbol σj belongs to dom(xj) such that C(q0 σ q) = c. Because each σj belongs to the domain of the corresponding variable, we have that σ is a solution to cAutomatonAtMost iff c ≤ max(dom(N)).\nWe now show how to achieve domain consistency on cAutomatonAtMost.\nTheorem 2. For a cAutomatonAtMost(N, [x1, . . . , xn],A) constraint, define the minimum value of the counter of A for variable xi to take value ℓ:\nm(i, ℓ) = min 〈q,c〉∈QCF(i−1)\nq′=δQ(q,ℓ)\n〈q′,c′〉∈QCB(i+1)\n(c+ δN(q, ℓ) + c ′)\n1. A value ℓ in dom(xi) (with i ∈ [1, n]) appears in a solution iff the minimum value of the counter is at most the maximum of the domain of N :\nm(i, ℓ) ≤ max(dom(N))\n2. A value in dom(N) appears in a solution iff it is at least the minimum counter value given in Theorem 1.\nProof. We start with the first claim. (If) We show that any ℓ ∈ dom(xi) with m(i, ℓ) ≤ max(dom(N)) participates in a solution. Suppose m(i, ℓ) equals c + δN(q, ℓ) + c\n′ for some 〈q, c〉 ∈ QCF(i − 1) and some 〈q′, c′〉 ∈ QCB(i + 1), with q′ = δQ(q, ℓ). Then there exist two strings σ = σ1 · · ·σi−1 and τ = σi+1 · · ·σn and some state qn such that\nC(q0 σ q) = c\nand\nC(q′ τ qn) = c ′\nwith σj ∈ dom(xj) for all j ∈ [1, n]. Note that the length of σℓτ is n. We have:\nC(q0 σℓτ qn) = C(q0 σ q) + δN(q, ℓ) + C(q ′ τ qn)\n= c+ δN(q, ℓ) + c ′\n= m(i, ℓ) ≤ max(dom(N)).\nHence the assignment corresponding to σℓτ satisfies the domains and the constraint, so ℓ ∈ dom(xi) participates in a solution. (Only if) If ℓ ∈ dom(xi) participates in a solution, then the counter of that solution is at least m(i, ℓ) and at most max(dom(N)), hence m(i, ℓ) ≤ max(dom(N)).\nThe second claim follows from Theorem 1. Indeed, let c = min〈q,c〉∈QCF(n) c So there exists a sequence σ = σ1 · · ·σn with each σj ∈ dom(xj) such that C(q0 σ q) = c. Further, for any σ′ = σ′1 · · ·σ ′ n with each σ ′ j ∈ dom(xj) for all j ∈ [1, n], we have c ≤ C(q0 σ′ q′n) for some state q ′ n. So, by Theorem 1, we need to prove that v ∈ dom(N) participates in a solution iff c ≤ v. (Only if) If v ∈ dom(N) participates in a solution, then there exists a sequence σ′ = σ′1 · · ·σ ′ n such that each σ′j ∈ dom(xj) and C(q0 σ′ q′n) ≤ v. Since c ≤ C(q0 σ′\nq′n), we have c ≤ v. (If) If c ≤ v, then the sequence σ above necessarily also forms a solution with N = v.\nA propagator is obtained by directly implementing the expressions and conditions of Theorems 1 and 2. It is idempotent."
    }, {
      "heading" : "3.2 Complexity",
      "text" : "The complexity of a non-incremental implementation of the propagator is established as follows. Recall that we consider sequences of n variables xi, each with at most the automaton alphabet Σ as domain. Let the automaton have |Q| states. Each set QCF(i) has O(|Q|) elements and takes O(|Σ| · |Q|) time to construct and trim (assuming it is implemented as a counter-value array indexed by Q, with all cells initialised to +∞). There are n+1 such sets, hence the entire QCF(·) vector takes O(n · |Σ| · |Q|) time and Θ(n · |Q|) space. Similarly, the entire QCB(·) vector takes O(n · |Σ| · |Q|) time and Θ(n · |Q|) space. Each value m(i, ℓ) takes O(|Q|) time to construct, since at most |Q| pairs 〈q, c〉 of QCF(i − 1) are iterated over and the corresponding pair 〈q′, c′〉 is unique and can be retrieved in constant time (under the assumed data structure). There are n · |Σ| such values, hence the entire m(·, ·) matrix takes O(n · |Σ| · |Q|) time and Θ(n · |Σ|) space. Each test of a domain value takes constant time, hence Θ(n+1) time in total for the n variables xi and the counter variable N . In total, such an implementation takes O(n · |Σ| · |Q|) time, and Θ(n · (|Q|+ |Σ|)) space."
    }, {
      "heading" : "3.3 The Exact Regular Counting Constraint",
      "text" : "Not surprisingly, decomposing cAutomaton(N,X,A) into the conjunction of cAutomatonAtMost(N,X,A) and cAutomatonAtLeast(N,X,A) does not yield domain consistency at the fixpoint of their propagators: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, x, 2],B), with N ∈ {0, 1, 2} and x ∈ {1, 2}, it misses the inference of N 6= 1. Worse, achieving domain consistency on exact regular counting is actually NP-hard:\nTheorem 3. The feasibility of cAutomaton constraints is NP-hard.\nProof. By reduction from Subset-Sum. Consider an instance 〈{a1, . . . , ak}, s〉 of Subset-Sum, which holds if there is a subset A ⊆ {a1, . . . , ak} such that ∑\nv∈A v = s. Construct a cDFAA with one state and alphabetΣ = {a1, . . . , ak, 0}. A transition labelled by ai increases the counter by ai, and the transition labelled by 0 does not increase the counter. Build a sequence of variables X = 〈x1, . . . , xk〉 such that dom(xi) = {0, ai} and a variable N such that dom(N) = {s}. Such a reduction can be done in polynomial time. Subset-Sum holds iff cAutomaton(N,X,A) holds.\nThe propagator for cAutomatonAtMost can be generalised into an incomplete propagator for cAutomaton. A value ℓ is removed from the domain of variable xi if the following condition holds:\n∀〈q, c〉 ∈ QCF(i− 1) : ∧\n〈q,c〉∈QCF(i−1) q′=δQ(q,ℓ)\n〈q′,c′〉∈QCB(i+1) 〈q′,c′〉∈QCB(i+1)\n[\nc+ δN(q, ℓ) + c ′, c+ δN(q, ℓ) + c′\n]\n∩ dom(N) = ∅\nThis propagator has the same space complexity as cAutomatonAtMost, but it may need more than one run to achieve idempotency. Indeed, it differs from the previous propagator in that lower and upper bounds have to be calculated for each state in QCF(i − 1), and it is possible that some states will give different bounds. Hence the first run of the propagator might not reach idempotency. The propagator is strictly stronger than computing the fixpoint of cAutomatonAtMost and cAutomatonAtLeast, because the intersection test with respect to dom(N) is strictly stronger than the conjunction of the\ntwo comparisons on the atmost and atleast sides: for the cDFA in Figure 4 and the cAutomaton(1, [2, x, 1, y, z],B) constraint, with x, y, z ∈ {1, 2}, the cAutomaton propagator infers z 6= 2, whereas the decomposition misses this inference. The cAutomaton propagator is also incomplete: the counter-example before Theorem 3 for the decomposition also applies to it."
    }, {
      "heading" : "3.4 Evaluation",
      "text" : "We implemented in SICStus Prolog version 4.2.1 [5] the described propagators for cAutomatonAtMost, cAutomatonAtLeast, and cAutomaton. As a sanity check, we tested them extensively as follows.\nWe generated random cDFAs of up to five states (note that all 34 counter automata of the Global Constraint Catalogue [2] have at most five states) using the random DFA generator [1] of FAdo (version 0.9.6) and doing a counter increment by 1 on each arc with a probability of 20%. For each random cDFA, we generated random instances, with random lengths (up to n = 10) of X = [x1, . . . , xn] and random initial domains of the counter variable N (one value, two values, and intervals of length 2 or 3) and the signature variables si (intervals of any length, and sets with holes).\nThe results, upon many millions of random instances, are that no counterexample to the domain consistency of cAutomatonAtMost has been generated (giving credence to Theorems 1 and 2), and that no pruning by the three propagators of actually supported values was observed. Also, our propagator for cAutomaton never propagates less but often more, to the point of detecting more failures, than the built-in Automaton [3] of SICStus Prolog, and that it is already often up to twice faster than the latter, even though it is currently näıvely implemented in Prolog while the built-in works by decomposition into a conjunction of other global constraints, all of which are very carefully implemented in C.\nTable 1 gives the cumulative runtimes (under Mac OS X 10.7.5 on a 2.8 GHz Intel Core 2 Duo with a 4 GB RAM), the numbers of detected failures, and (when both propagators succeed) the numbers of pruned values for random instances of some constraints, the four-state cDFA for the NumberWord(N,X, “toto”) constraint being unnecessary here.\nTo demonstrate the power of our propagators, we have also tested them on constraints whose counter-DFAs have binary signature constraints, so that our atleast and atmost regular counting propagators may not achieve domain consistency, because they were designed for unary signature constraints. For example, the Inflexion(N,X) constraint holds if there are N inflexions (local optima) in the integer sequence X ; a cDFA is given in [2], with signature constraints using the predicates xi {<,=, >} xi+1 on the sliding window [xi, xi+1] of size 2. Our exact regular counting propagator outperforms the built-in Automaton [3] of SICStus Prolog, as shown in the last line of Table 1. Further, our instance generator has not yet constructed any counter-example to domain consistency on atmost regular counting."
    }, {
      "heading" : "4 Conclusion",
      "text" : "This paper considers regular counting constraints over finite sequences of variables, which are ubiquitous and very diverse in sequencing and timetabling (e.g., restricting the number of monthly working weekends, or two-day-periods where a nurse works during a night followed by an afternoon). It studies a class of counter deterministic finite automata (cDFA) that provides much more concise models for regular counting constraints than representations using standard DFAs."
    }, {
      "heading" : "4.1 Summary and Extensions",
      "text" : "Our main contribution is to show how to enforce domain consistency in polynomial time for atmost and atleast regular counting constraints, based on the frequent case of a counter-DFA with only accepting states and a single counter that can be incremented by transitions. We have also proved that determining the feasibility of exact regular counting constraints is NP-hard.\nIt is possible to lift our restriction to counter automata where all states are accepting, even though we are then technically outside the realm of regular counting. For instance, this would allow us to constrain the number N of occurrences of some pattern, recognised by cDFA A1, in a sequence X of variables, while X is not allowed to contain any occurrence of another pattern, recognised by cDFA A2. Rather than decomposing this constraint into the conjunction of cAutomaton(N,X,A1) and cAutomaton(0, X,A2), with poor propagation through the shared variables, we can design a cDFA A12 that counts the number of occurrences of the first pattern and fails at any occurrence of the second pattern (instead of counting them) and post the unique constraint cAutomaton(N,X,A12), after using the following recipe. Add an accepting state, say q, and an alphabet symbol, say $, whose meaning is end-ofstring. Add transitions on $ from all existing accepting states to q, with counter increase by zero. Add transitions on $ from all non-accepting states to q, with counter increase by a suitably large number, such as max(dom(N))+1. Make the non-accepting states accepting. Append the symbol $ to the sequence X when posting the constraint, so that the extended automaton never actually stops in\na state different from q, thereby making it irrelevant whether the original states are accepting or not."
    }, {
      "heading" : "4.2 Related Work",
      "text" : "Our regular counting constraints are related to the CostRegular(X,A, N, C) constraint [6], an extension of the Regular(X,A) constraint [9]: a ground instance holds if the sum of the variable-value assignment costs is exactly N after DFA A has accepted X , where the two-dimensional cost matrix C, indexed by Σ and X , gives the costs of assigning each value of the alphabet Σ of A to each variable of the sequence X . Indeed, both the abstractions and the underlying algorithms of regular counting constraints and CostRegular are closely related. However, we now argue that regular counting constraints sometimes provide both a more natural abstraction and some computational benefits, namely more propagation and asymptotically less space, within the same asymptotic time.\nAt the conceptual level, the regular counting and CostRegular constraints differ in how costs are expressed. In the CostRegular constraint the costs are associated with variable-value assignments, while in regular counting constraints the costs (seen as counter increments) are associated with the transitions of the counter automaton. This is an important conceptual distinction, as counter automata provide a more natural and compact abstraction for a variety of constraints, where the focus is on counting rather than costing. Footnote 1 of [6, page 318] points out that the cost matrix C can be made three-dimensional, indexed also by the states Q of A, but this is not discussed further in [6]. This allows the expression of costs on transitions, and it seems that this has no impact on the time complexity of their propagator. This generalisation is implemented in the Choco solver [8]. It is only with such a three-dimensional cost matrix that it is possible for the modeller to post a regular counting constraint by using the CostRegular constraint: first unroll the counter automaton for the length |X | into a directed acyclic weighted graph G (as described in [9], and the counter increments become the weights) and then post CostRegular(X,N,G); the Choco implementation [8, page 95] of CostRegular features this option. The alternative is to read the three-dimensional cost matrix C off A only (since X is not needed) and to post CostRegular(X,A′, N, C), where DFA A′ is counter-DFA A stripped of its counter increments. Either way, this encoding is not particularly convenient and it seems natural to adopt counter automata as an abstraction. Also note that the cost matrix C has to be computed for every different value of |X | that occurs in the problem model, while this is not the case with counter automata. Essentially, regular counting is a specialisation of the generalised CostRegular constraint (with a three-dimensional cost matrix), obtained by projecting the generalised cost matrix onto two different dimensions than in the original CostRegular constraint, namely Q and Σ, and using it to extend the transition function of the DFA to the signature Q × Σ → Q × N and calling the extended DFA a counter-DFA.\nAt the efficiency level, regular counting constraints are propagated using dynamic programming, like CostRegular. This is not surprising. The time\ncomplexity is the same as for the encoding using CostRegular, namely O(n · |Σ| · |Q|), where n = |X |, as the unrolling of the cDFA takes the same time as the propagator itself. It is interesting however to note that the structure of regular counting constraints enables a better space complexity thanks to the compactness of a counter automaton as the input datastructure, as well as fundamentally different internal datastructures: we do not store the unrolled automaton. Indeed, we have shown that regular counting constraints have a space complexity of Θ(n · (|Q| + |Σ|)), while the encoding by CostRegular constraint takes Θ(n · |Σ| · |Q|) space, to store either the three-dimensional cost matrix C or the unrolled graph G (Choco allows both ways of parametrising CostRegular). Note that adding a counter to a DFA bears no asymptotic space overhead on the representation of the DFA.\nAt the consistency level, it is important to note that our atmost and atleast regular counting propagators achieve domain consistency on the counter variable N in the same asymptotic time as the CostRegular propagator [6,8] achieves only bounds consistency on N . As an aside, the claim by [6,8] that their polynomial-time propagator achieves domain consistency on the variables of the sequence X is invalidated by Theorem 3, hence this would only be the case for atmost and atleast variants of CostRegular: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, 2, x, 2, y],B), with N ∈ {1, 3} and x, y ∈ {1, 2}, their propagator misses the inference of y 6= 2, and so does our propagator for exact regular counting. Our datastructures are more compact (see above), and yet enable more propagation on X for exact regular counting.\nTo summarise, although regular counting constraints and the CostRegular constraint are closely related, we believe that the results of this paper contribute both to our understanding of these constraints and to the practice in the field.\nThe SeqBin constraint [10,7] can be represented by a regular counting constraint, but it would require non-unary signature constraints."
    }, {
      "heading" : "4.3 Future Work",
      "text" : "There are many issues that remain open. They include the following questions. Can we implement our propagator to run in O(n·|Σ|) time? Which counter-DFAs admit a propagator achieving domain consistency for exact regular counting? Can we generalise our domain-consistency result to non-unary signature constraints? Can we generalise our results to non-deterministic counter automata (since all our notation depends on the transition function δ being total)?"
    }, {
      "heading" : "Acknowledgements",
      "text" : "The second and third authors are supported by grants 2011-6133 and 2012-4908 of the Swedish Research Council (VR). NICTA is funded by the Australian Government as represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence program. We wish to thank Mats Carlsson for help with\nSICStus Prolog, Joseph Scott for help with FAdo, and Arnaud Letord for help with performing the test with CostRegular in Choco."
    }, {
      "heading" : "Appendix: SICStus Prolog Implementation",
      "text" : ":− use module ( l i b r a r y ( l i s t s ) ) . :− use module ( l i b r a r y ( av l ) ) . :− use module ( l i b r a r y ( c l p f d ) ) .\ncautomatonAtmost(A, N, Vars ) :− dom suspensions (Vars , Susp ) , f d g l o b a l ( cautomatonAtmost(A,N, Vars ) , atmost , [max(N) | Susp ] ) .\ncautomatonAtleast (A, N, Vars ) :− dom suspensions (Vars , Susp ) , f d g l o b a l ( cautomatonAtleast (A,N, Vars ) , a t l e a s t , [ min (N) | Susp ] ) .\ncautomaton (A, N, Vars ) :− dom suspensions (Vars , Susp ) , f d g l o b a l ( cautomaton (A,N, Vars ) , among , [ dom(N) | Susp ] ,\n[ idempotent ( f a l s e ) ] ) .\ndom suspensions (Vs , Ss ) :− ( f o r e ach (V, Vs) ,\nf o r e ach (dom(V) , Ss ) do true ) .\n:− mu l t i f i l e c l p f d : d i s p a t c h g l o b a l /4 . c l p f d : d i s p a t c h g l o b a l ( cautomatonAtmost(A,N, Vars ) , atmost , atmost ,\nActions ) :− A = automaton( , , , S tate s , Trans i t ions , , , ) , t r a n s a v l ( Trans i t ions , TransAVL) , compute qcf qcb ( State s , TransAVL , N, Vars , Doms , QCF, QCB, MinN, ) , fd max (N, MaxN) , MinN =< MaxN, Actions = [N in MinN . .MaxN | Actions2 ] , QCB = [ |RQCB] , prune vars (Vars , Doms , , QCF, RQCB, atmost , TransAVL , , MaxN, ValuesToRemove ) , p rune ac t i on s (ValuesToRemove , Actions2 ) .\nc l p f d : d i s p a t c h g l o b a l ( cautomatonAtleast (A,N, Vars ) , a t l e a s t , a t l e a s t , Actions ) :−\nA = automaton( , , , S tate s , Trans i t ions , , , ) , t r a n s a v l ( Trans i t ions , TransAVL) , compute qcf qcb ( State s , TransAVL , N, Vars , Doms , QCF, QCB, , MaxN) , fd min (N, MinN) , MinN =< MaxN, Actions = [N in MinN . .MaxN | Actions2 ] , QCB = [ |RQCB] , prune vars (Vars , Doms , , QCF, RQCB, a t l e a s t , TransAVL , MinN,\n, ValuesToRemove ) , p rune ac t i on s (ValuesToRemove , Actions2 ) .\nc l p f d : d i s p a t c h g l o b a l ( cautomaton (A,N, Vars ) , among , among , Actions ) :− A = automaton( , , , S tate s , Trans i t ions , , , ) , t r a n s a v l ( Trans i t ions , TransAVL) , compute qcf qcb ( State s , TransAVL , N, Vars , Doms , QCF, QCB,\nMinN, MaxN) , MinN =< MaxN, Actions = [N in MinN . .MaxN | Actions2 ] , QCB = [ |RQCB] , convert dvars to doms ( [N] , [DomN] ) , prune vars (Vars , Doms , DomN, QCF, RQCB, among , TransAVL , MinN, MaxN, ValuesToRemove ) , p rune ac t i on s (ValuesToRemove , Actions2 ) .\nt r a n s a v l ( Trans i t ions , TransAVL) :− ( f o r e ach (Arc , Tran s i t i on s ) ,\nfromto (KL1 , [ key (Q,V, 0 )−va lue (Q0, I ) , key (Q0,V, 1 )−va lue (Q, I ) |KL2] ,KL2 , [ ] ) do ( Arc = arc (Q0,V,Q) −> I = 0\n; Arc = arc (Q0,V,Q, [ +Inc ] ) −> I = Inc )\n) , keysort (KL1, KL3) , keyclumped (KL3, KL4) , o r d l i s t t o a v l (KL4, TransAVL) .\np rune ac t i on s (ValuesToRemove , Actions ) :− ( f o r e ach (X−Delete , ValuesToRemove ) ,\nf o r e ach (X i n s e t KeepSet , Actions ) do f d s e t (X, Set ) ,\nl i s t t o f d s e t ( Delete , DelSet ) , f d s e t s u b t r a c t ( Set , DelSet , KeepSet )\n) .\nprune vars (RV, RD, DomN, RF, RB, Flag , TransAVL , MinN, MaxN, Remove) :− ( f o r e ach (Var ,RV) ,\nf o r e ach (Dom,RD) , fromto (RF, [ QCF prev |RF1] ,RF1 , [ ] ) , f o r e ach (QCB next ,RB) , f o r e ach (Var−ValuesToRemove , Remove) , param(DomN, Flag , TransAVL ,MinN,MaxN)\ndo prune var (Dom, DomN, Flag , TransAVL , QCF prev , QCB next , MinN, MaxN, ValuesToRemove )\n) .\nprune var (R, DomN, Flag , TransAVL , QCF prev , QCB next , MinN , MaxN, S0 ) :−\n( f o r e ach (Val ,R) , fromto (S0 , S1 , S2 , [ ] ) , param(DomN, Flag , TransAVL , QCF prev , QCB next , MinN, MaxN)\ndo ( check va lue (QCF prev , Val , DomN, Flag , TransAVL , QCB next , MinN , MaxN)\n−> S1 = [ Val | S2 ] ; S1 = S2 )\n) .\ncheck va lue (R, Val , DomN, Flag , TransAVL , QCB next , MinN, MaxN) :− ( f o r e ach ( t (Q,MinQ,MaxQ) ,R) ,\nparam(Val , DomN, Flag , TransAVL , QCB next , MinN , MaxN) do check va lue ( Flag , Q, MinQ, MaxQ, Val , DomN, TransAVL ,\nQCB next , MinN , MaxN) ) .\ncheck va lue ( atmost , Q, MinQ, , Val , , TransAVL , QCB next , , MaxN) :− ( g e t n ex t p r e v s t a t e (1 , Q, Val , TransAVL , NextQ , Inc ) ,\nmember( t (NextQ ,MinNextQ , ) , QCB next ) −> MinQ + Inc + MinNextQ > MaxN ; true ) .\ncheck va lue ( a t l e a s t , Q, , MaxQ, Val , , TransAVL , QCB next , MinN, ) :− ( g e t n ex t p r e v s t a t e (1 , Q, Val , TransAVL , NextQ , Inc ) ,\nmember( t (NextQ , ,MaxNextQ) , QCB next ) −> MaxQ + Inc + MaxNextQ < MinN ; true ) .\ncheck va lue (among , Q, MinQ, MaxQ, Val , DomN, TransAVL , QCB next , MinN , MaxN) :−\n( g e t n ex t p r e v s t a t e (1 , Q, Val , TransAVL , NextQ , Inc ) , member( t (NextQ ,MinNextQ ,MaxNextQ) , QCB next )\n−> In f i s min (MaxN+1, MinQ + Inc + MinNextQ) , Sup i s max(MinN−1, MaxQ + Inc + MaxNextQ)\n; In f = MaxN+1, Sup = MinN−1\n) , ( In f =< Sup −> \\+i n t e r s e c t (DomN, In f , Sup ) ; true ) .\ncompute qcf qcb ( State s , TransAVL , N, Vars , Doms , [ F i r s t |RQCF] , QCB, MinN, MaxN) :−\nconvert dvars to doms (Vars , Doms) , once (member( source ( I n i t i a l S t a t e ) , S ta t e s ) ) , F i r s t = [ t ( I n i t i a l S t a t e , 0 , 0 ) ] , comple te qc f qcb (Doms , 1 , TransAVL , Fi r st , RQCF) , l a s t ( [ F i r s t |RQCF] , LastState s ) , fd min (N, InitMinN ) , fd max (N, InitMaxN) , InitMin i s InitMaxN + 1 , InitMax i s InitMinN − 1 , s e t c ou n t e r s t o z e r o ( LastState s , Last , InitMin , InitMax , MinN,\nMaxN) , r e v e r s e (Doms , RDoms) ,\ncomple te qc f qcb (RDoms, 0 , TransAVL , Last , RQCB) , r e v e r s e ( [ Last |RQCB] , QCB) .\ncomple te qc f qcb (R, Flag , TransAVL , States0 , S) :− ( f o r e ach (Dom,R) ,\nf o r e ach ( States2 , S) , fromto ( States0 , States1 , States2 , ) , param( Flag , TransAVL)\ndo compute nexts ( States1 , Flag , Dom, TransAVL , State s2 ) ) .\ncompute nexts ( PrevStates , Flag , Dom, TransAVL , NextStates ) :− compute next state s ( PrevStates , Flag , Dom, TransAVL , KL1, [ ] ) , keysort (KL1, KL2) , keyclumped (KL2, KL3) , ( f o r e ach (Tag−Pairs ,KL3) ,\nf o r e ach ( t (Tag ,Min ,Max) , NextStates ) do transpose ( Pairs , [ MinOf ,MaxOf ] ) ,\nmin member(Min , MinOf) , max member(Max, MaxOf)\n) .\ncompute next state s (R, Flag , Dom, TransAVL) −−> ( f o r e ach ( t (Q,Min ,Max) ,R) ,\nparam( Flag , Dom, TransAVL) do ( f o r e ach (Val ,Dom) ,\nparam( Flag , TransAVL ,Q,Min ,Max) do ( { g e t n e x t p r ev s t a t e s ( Flag , Q, Val , TransAVL ,\nValues ) } , ( f o r e ach ( va lue (NextPrevQ , Inc ) , Values ) ,\nparam(Min ,Max) do {NextPrevMin i s Min + Inc } ,\n{NextPrevMax i s Max + Inc } , [ NextPrevQ−[NextPrevMin , NextPrevMax ] ]\n) )\n) ) .\ng e t n ex t p r ev s t a t e ( Flag , Q0, Val , TransAVL , Q, Inc ) :− g e t n ex t p r e v s t a t e s ( Flag , Q0, Val , TransAVL , Values ) , member( va lue (Q, Inc ) , Values ) .\ng e t n e x t p r ev s t a t e s ( Flag , Q0, Val , TransAVL , Values ) :− a v l f e t c h ( key (Q0, Val , Flag ) , TransAVL , Values ) , ! . g e t n e x t p r ev s t a t e s ( , , , , [ ] ) .\ns e t c o un t e r s t o z e r o (R, S , Min0 , Max0 , Min , Max) :− ( f o r e ach ( t (Q,MinT,MaxT) ,R) ,\nf o r e ach ( t (Q, 0 , 0 ) ,S ) , fromto (Min0 ,Min1 ,Min2 ,Min) , fromto (Max0 ,Max1,Max2 ,Max)\ndo Min2 i s min(MinT, Min1) , Max2 i s max(MaxT, Max1) ) .\nconvert dvars to doms (R, S) :− ( f o r e ach (V,R) ,\nf o r e ach (D, S) do f d s e t (V, SV) , f d s e t t o l i s t (SV, D) ) .\ni n t e r s e c t ( [V | ] , In f , Sup ) :− In f =< V, V =< Sup , ! . i n t e r s e c t ( [ |R] , In f , Sup ) :− i n t e r s e c t (R, In f , Sup ) ."
    } ],
    "references" : [ {
      "title" : "Enumeration and generation with a string automata representation",
      "author" : [ "M. Almeida", "N. Moreira", "R. Reis" ],
      "venue" : "Theoretical Computer Science 387(2),",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2007
    }, {
      "title" : "Global constraint catalogue: Past, present, and future",
      "author" : [ "N. Beldiceanu", "M. Carlsson", "S. Demassey", "T. Petit" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2007
    }, {
      "title" : "Deriving filtering algorithms from constraint checkers",
      "author" : [ "N. Beldiceanu", "M. Carlsson", "T. Petit" ],
      "venue" : "Wallace, M. (ed.) CP 2004. LNCS, vol. 3258, pp. 107–122. Springer",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Introducing global constraints in CHIP",
      "author" : [ "N. Beldiceanu", "E. Contejean" ],
      "venue" : "Journal of Mathematical and Computer Modelling 20(12), 97–123",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "An open-ended finite domain constraint solver",
      "author" : [ "M. Carlsson", "G. Ottosson", "B. Carlson" ],
      "venue" : "Glaser, H., Hartel, P., Kuchen, H. (eds.) PLILP 1997. LNCS, vol. 1292, pp. 191–206. Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "A Cost-Regular based hybrid column generation approach",
      "author" : [ "S. Demassey", "G. Pesant", "L.M. Rousseau" ],
      "venue" : "Constraints 11(4), 315–333",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "The SEQBIN constraint revisited",
      "author" : [ "G. Katsirelos", "N. Narodytska", "T. Walsh" ],
      "venue" : "Milano, M. (ed.) CP 2012. LNCS, vol. 7514, pp. 332–347. Springer",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Choco solver: Documentation, version",
      "author" : [ "F. Laburthe", "N. Jussien" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2012
    }, {
      "title" : "A regular language membership constraint for finite sequences of variables",
      "author" : [ "G. Pesant" ],
      "venue" : "Wallace, M. (ed.) CP 2004. LNCS, vol. 3258, pp. 482–495. Springer",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2004
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "We also prove that the satisfaction of exact regular counting constraints is NP-hard and indicate that an incomplete algorithm for exact regular counting constraints is faster and provides more pruning than the existing propagator from [3].",
      "startOffset" : 236,
      "endOffset" : 239
    }, {
      "referenceID" : 2,
      "context" : "Indeed, DFAs are a convenient tool to model a wide variety of constraints, and their associated propagation algorithms can enforce domain consistency in polynomial time [3,9].",
      "startOffset" : 169,
      "endOffset" : 174
    }, {
      "referenceID" : 8,
      "context" : "Indeed, DFAs are a convenient tool to model a wide variety of constraints, and their associated propagation algorithms can enforce domain consistency in polynomial time [3,9].",
      "startOffset" : 169,
      "endOffset" : 174
    }, {
      "referenceID" : 2,
      "context" : "This paper is concerned with the concept of counter-DFA (cDFA), an extension of DFAs proposed in [3], and uses it to model regular counting constraints, that is constraints on the number of regular-language patterns occurring in a sequence of variables.",
      "startOffset" : 97,
      "endOffset" : 100
    }, {
      "referenceID" : 5,
      "context" : "Compared to the CostRegular constraint [6], as generalised for the Choco solver [8], our contribution is a propagator for exact regular counting that uses asymptotically less space (for its internal datastructures) and yet propagates more on the variables of X .",
      "startOffset" : 39,
      "endOffset" : 42
    }, {
      "referenceID" : 7,
      "context" : "Compared to the CostRegular constraint [6], as generalised for the Choco solver [8], our contribution is a propagator for exact regular counting that uses asymptotically less space (for its internal datastructures) and yet propagates more on the variables of X .",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 2,
      "context" : "A constraint on a sequence X of variables can sometimes be modelled with the help of a DFA or cDFA that operates not on X , but on a sequence of signature variables that functionally depend via signature constraints on a sliding window of variables within X [3].",
      "startOffset" : 258,
      "endOffset" : 261
    }, {
      "referenceID" : 3,
      "context" : "For example, the Among(N,X,V) constraint [4] requires N to be the number of variables in the sequence X that are assigned a value from the given set V .",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 2,
      "context" : "Comparison between cAutomaton and Automaton [3] of SICStus Prolog",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 4,
      "context" : "1 [5] the described propagators for cAutomatonAtMost, cAutomatonAtLeast, and cAutomaton.",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 1,
      "context" : "We generated random cDFAs of up to five states (note that all 34 counter automata of the Global Constraint Catalogue [2] have at most five states) using the random DFA generator [1] of FAdo (version 0.",
      "startOffset" : 117,
      "endOffset" : 120
    }, {
      "referenceID" : 0,
      "context" : "We generated random cDFAs of up to five states (note that all 34 counter automata of the Global Constraint Catalogue [2] have at most five states) using the random DFA generator [1] of FAdo (version 0.",
      "startOffset" : 178,
      "endOffset" : 181
    }, {
      "referenceID" : 2,
      "context" : "Also, our propagator for cAutomaton never propagates less but often more, to the point of detecting more failures, than the built-in Automaton [3] of SICStus Prolog, and that it is already often up to twice faster than the latter, even though it is currently näıvely implemented in Prolog while the built-in works by decomposition into a conjunction of other global constraints, all of which are very carefully implemented in C.",
      "startOffset" : 143,
      "endOffset" : 146
    }, {
      "referenceID" : 1,
      "context" : "For example, the Inflexion(N,X) constraint holds if there are N inflexions (local optima) in the integer sequence X ; a cDFA is given in [2], with signature constraints using the predicates xi {<,=, >} xi+1 on the sliding window [xi, xi+1] of size 2.",
      "startOffset" : 137,
      "endOffset" : 140
    }, {
      "referenceID" : 2,
      "context" : "Our exact regular counting propagator outperforms the built-in Automaton [3] of SICStus Prolog, as shown in the last line of Table 1.",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 5,
      "context" : "Our regular counting constraints are related to the CostRegular(X,A, N, C) constraint [6], an extension of the Regular(X,A) constraint [9]: a ground instance holds if the sum of the variable-value assignment costs is exactly N after DFA A has accepted X , where the two-dimensional cost matrix C, indexed by Σ and X , gives the costs of assigning each value of the alphabet Σ of A to each variable of the sequence X .",
      "startOffset" : 86,
      "endOffset" : 89
    }, {
      "referenceID" : 8,
      "context" : "Our regular counting constraints are related to the CostRegular(X,A, N, C) constraint [6], an extension of the Regular(X,A) constraint [9]: a ground instance holds if the sum of the variable-value assignment costs is exactly N after DFA A has accepted X , where the two-dimensional cost matrix C, indexed by Σ and X , gives the costs of assigning each value of the alphabet Σ of A to each variable of the sequence X .",
      "startOffset" : 135,
      "endOffset" : 138
    }, {
      "referenceID" : 5,
      "context" : "Footnote 1 of [6, page 318] points out that the cost matrix C can be made three-dimensional, indexed also by the states Q of A, but this is not discussed further in [6].",
      "startOffset" : 165,
      "endOffset" : 168
    }, {
      "referenceID" : 7,
      "context" : "This generalisation is implemented in the Choco solver [8].",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 8,
      "context" : "It is only with such a three-dimensional cost matrix that it is possible for the modeller to post a regular counting constraint by using the CostRegular constraint: first unroll the counter automaton for the length |X | into a directed acyclic weighted graph G (as described in [9], and the counter increments become the weights) and then post CostRegular(X,N,G); the Choco implementation [8, page 95] of CostRegular features this option.",
      "startOffset" : 278,
      "endOffset" : 281
    }, {
      "referenceID" : 5,
      "context" : "At the consistency level, it is important to note that our atmost and atleast regular counting propagators achieve domain consistency on the counter variable N in the same asymptotic time as the CostRegular propagator [6,8] achieves only bounds consistency on N .",
      "startOffset" : 218,
      "endOffset" : 223
    }, {
      "referenceID" : 7,
      "context" : "At the consistency level, it is important to note that our atmost and atleast regular counting propagators achieve domain consistency on the counter variable N in the same asymptotic time as the CostRegular propagator [6,8] achieves only bounds consistency on N .",
      "startOffset" : 218,
      "endOffset" : 223
    }, {
      "referenceID" : 5,
      "context" : "As an aside, the claim by [6,8] that their polynomial-time propagator achieves domain consistency on the variables of the sequence X is invalidated by Theorem 3, hence this would only be the case for atmost and atleast variants of CostRegular: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, 2, x, 2, y],B), with N ∈ {1, 3} and x, y ∈ {1, 2}, their propagator misses the inference of y 6= 2, and so does our propagator for exact regular counting.",
      "startOffset" : 26,
      "endOffset" : 31
    }, {
      "referenceID" : 7,
      "context" : "As an aside, the claim by [6,8] that their polynomial-time propagator achieves domain consistency on the variables of the sequence X is invalidated by Theorem 3, hence this would only be the case for atmost and atleast variants of CostRegular: for the cDFA B in Figure 4 and the constraint cAutomaton(N, [2, 2, x, 2, y],B), with N ∈ {1, 3} and x, y ∈ {1, 2}, their propagator misses the inference of y 6= 2, and so does our propagator for exact regular counting.",
      "startOffset" : 26,
      "endOffset" : 31
    }, {
      "referenceID" : 6,
      "context" : "The SeqBin constraint [10,7] can be represented by a regular counting constraint, but it would require non-unary signature constraints.",
      "startOffset" : 22,
      "endOffset" : 28
    } ],
    "year" : 2013,
    "abstractText" : "Constraints over finite sequences of variables are ubiquitous in sequencing and timetabling. Moreover, the wide variety of such constraints in practical applications led to general modelling techniques and generic propagation algorithms, often based on deterministic finite automata (DFA) and their extensions. We consider counter-DFAs (cDFA), which provide concise models for regular counting constraints, that is constraints over the number of times a regular-language pattern occurs in a sequence. We show how to enforce domain consistency in polynomial time for atmost and atleast regular counting constraints based on the frequent case of a cDFA with only accepting states and a single counter that can be incremented by transitions. We also prove that the satisfaction of exact regular counting constraints is NP-hard and indicate that an incomplete algorithm for exact regular counting constraints is faster and provides more pruning than the existing propagator from [3]. Regular counting constraints are closely related to the CostRegular constraint but contribute both a natural abstraction and some computational advantages.",
    "creator" : "LaTeX with hyperref package"
  }
}