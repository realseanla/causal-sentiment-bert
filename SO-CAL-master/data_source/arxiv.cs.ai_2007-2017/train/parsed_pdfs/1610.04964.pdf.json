{
  "name" : "1610.04964.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Improvements in Sub-optimal Solving of the (N − 1)-Puzzle via Joint Relocation of Pebbles and its Applications to Rule-based Cooperative Path-Finding",
    "authors" : [ "Pavel Surynek", "Petr Michalík" ],
    "emails" : [ "pavel.surynek@mff.cuni.cz,", "petr.michalik@accenture.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "1\ntion. An improvement to the existent polynomial-time algorithm is proposed and experimentally analyzed. The improved algorithm is trying to move pebbles in a more efficient way than the original algorithm by grouping them into so-called snakes and moving them jointly within the snake. An experimental evaluation showed that the algorithm using snakes produces solutions that are 8% to 9% shorter than solutions generated by the original algorithm.\nThe snake-based relocation has been also integrated into rule-based algorithms for solving the CPF problem sub-optimally, which is a closely related task. The task in CPF is to relocate a group of abstract robots that move over an undirected graph to given goal vertices. Robots can move to unoccupied neighboring vertices and at most one robot can be placed in each vertex. The (\uD835\uDC5B2 − 1)-puzzle is a special case of CPF where the underlying graph is represented by a 4-connected grid and there is only one vacant vertex. Two major rule-based algorithms for CPF were included in our study – BIBOX and PUSH-and-SWAP (PUSH-and-ROTATE). Improvements gained by using snakes in the BIBOX algorithm were stable around 30% in (\uD835\uDC5B2 − 1)-puzzle solving and up to 50% in CPFs over bi-connected graphs with various ear decompositions and multiple vacant vertices. In the case of the PUSHand-SWAP algorithm the improvement achieved by snakes was around 5% to 8%. However, the improvement was unstable and hardly predictable in the case of PUSH-and-SWAP.\nKeywords: (\uD835\uDC5B2 − 1)-puzzle, 15-puzzle, Parberry’s algorithm, cooperative path-finding, multi-agent path-finding, polynomial complexity, multi-robot path planning, BIBOX algorithm, PUSH-and-SWAP algorithm, PUSH-and-ROTATE algorithm.1"
    }, {
      "heading" : "1. Introduction and Motivation",
      "text" : "The (\uD835\uDC5B2 − 1)-puzzle [9, 10, 12, 13] represents one of the best-known examples of a socalled cooperative path-finding (CPF) [23, 33, 38, 42] problem. It is important both practically and theoretically. From the theoretical point of view it is interesting for the hardness of its optimization variant which is known to be \uD835\uDC41\uD835\uDC43-hard [16, 17].\nPractically it is important since many real-life relocation problems can be solved by techniques developed for the (\uD835\uDC5B2 − 1)-puzzle. Those include path planning for multiple\nThis is a preprint submitted to ArXiv on October 17, 2016.\nrobots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic. Moreover, the reasoning about relocation/coordination tasks should not be limited to physical entities only. Many tasks such as planning of data transfer, commodity transportation, and motion planning of units in computer-generated imagery can be tackled using techniques originally developed for the (\uD835\uDC5B2 − 1)-puzzle.\nIn this manuscript, we concentrate on solving the (\uD835\uDC5B2 − 1)-puzzle sub-optimally, that is, by fast polynomial-time algorithms. We are trying to improve the basic incremental placing of pebbles as it is done by the existent state-of-the-art on-line solving algorithm of Parberry [13] by moving them jointly in groups called snakes. Moving pebbles jointly in snakes is supposed to be more efficient in terms of the total number of moves than moving them individually as it was originally proposed [13]. An improved algorithm exploiting snake-based movements is presented.\nWe utilized experiences gained during making snake-based improvements to Parberry’s algorithm in solving of CPFs sub-optimally by rule-based algorithms. We took existing rule-based cooperative path finding algorithms and conducted a study how they can be improved via joint robot movements in snakes. There are two rule-based algorithms for CPF – BIBOX [26, 33] and PUSH-and-SWAP (PUSH-and-ROTATE) [12, 42, 43] similar to the Parberry’s algorithm. Both algorithms operate in a similar way to the algorithm of Parberry; that is, they also place robots one by one to their goal positions as it is done by Parberry’s algorithm with pebbles. Hence, the snake-based reasoning for joint movements of pebbles can be applied with certain effort within these algorithms as well. The BIBOX algorithm is originally developed for CPFs over bi-connected graphs with at least two vacant vertices while PUSH-and-SWAP is more general – it can be applied to CPF over arbitrary graph with at least two vacant vertices. Both rule-based algorithms are thus applicable the puzzle where one more blank is added – that is to (\uD835\uDC5B2 − 2)-puzzle – which allows us to make competitive comparison of all the algorithms.\nThe snake-based reasoning is focused on improving solutions generated by selected algorithms in terms of the number of moves. In this context, we need to mention a great progress that has been done in solving the CPF problem as well as the (\uD835\uDC5B2 − 1)-puzzle optimally with respect to various objectives such as the total number of moves [21], parallel makespan [34], and derivations of these. There exist great variety of search-based optimal algorithms such as ID+OD (Independence Detection + Operator Decomposition) [25], ICTS (Increasing Cost Tree Search) [21], and CBS (Conflict-based Search) [22] to name few. Reductions of optimal CPF solving to other formalisms such as SAT (Propositional Satisfiability) [34] or ASP (Answer Set Programming) [6] allow using external solvers for a given formalism. Although mentioned optimal approaches are still improved to be able to solve larger instances optimally they are far in term of size from the instances that can be solved by studied sub-optimal approaches. While either the optimal techniques need few robots only or sparse environments, the sub-optimal approaches can tackle large densely occupied instances.\nAn extensive competitive experimental evaluation was done to evaluate qualities of snake-based improvements in solving (\uD835\uDC5B2 − 1)-puzzle as well as in solving of CPFs over bi-connected graphs. All the algorithms were tested against their variant with snake-based reasoning on a number of benchmark instances.\nThe manuscript is organized as follows. The problem of (\uD835\uDC5B2 − 1)-puzzle is formally introduced in Section 2. An overview of existent solving algorithm and other related solving approaches is given in Section 3. The main part of the paper is constituted by Section 4, Section 5, and Section where the snake movement is introduced into the Parberry’s algorithm, into BIBOX, and into PUSH-and-SWAP. Although these algorithms share certain similarities, they are also fundamentally different. Hence, the snake-based reasoning needed to be adapted for each algorithm substantially. An extensive experimental evaluation is finally given in Section 6."
    }, {
      "heading" : "2. Problem Statement",
      "text" : "The (\uD835\uDC5B2 − 1)-puzzle consists of a set of pebbles that are moved over a square grid of size \uD835\uDC5B×\uD835\uDC5B [1, 13, 16, 17, 44]. There is exactly one position vacant on the grid and others are occupied by exactly one pebble. A pebble can be moved to the adjacent vacant position. The task is to rearrange pebbles on the grid into a desired goal state.\n2.1. Formal Definition\nSets of pebbles will be denoted as Ω\uD835\uDC5B for \uD835\uDC5B ∈ ℕ. It holds that |Ω\uD835\uDC5B| = \uD835\uDC5B 2 − 1 for every \uD835\uDC5B ∈ ℕ. It is supposed that pebbles from a set Ω\uD835\uDC5B are arranged on a square grid of the size \uD835\uDC5B×\uD835\uDC5B where each pebble is placed into one of the cells of the grid. There is at most one pebble in each cell of the grid; one cell on the grid remains always vacant (Figure 1).\nDefinition 1 (configuration in a grid). An configuration of a set of pebbles Ω\uD835\uDC5B in a square grid of the size \uD835\uDC5B×\uD835\uDC5B with \uD835\uDC5B ∈ ℕ is fully described using two functions \uD835\uDC65\uD835\uDC5B: Ω\uD835\uDC5B ⟶ ℕ and \uD835\uDC66\uD835\uDC5B: Ω\uD835\uDC5B ⟶ ℕ that satisfy the following puzzle conditions:\n(i) \uD835\uDC65\uD835\uDC5B(\uD835\uDC5D) ∈ {1,2, … , \uD835\uDC5B} and \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D) ∈ {1,2, … , \uD835\uDC5B} ∀\uD835\uDC5D ∈ Ω\uD835\uDC5B\n(ii) |{\uD835\uDC5D ∈ Ω\uD835\uDC5B|(\uD835\uDC65\uD835\uDC5B(\uD835\uDC5D), \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)) = (\uD835\uDC56, \uD835\uDC57)}| ≤ 1 for ∀\uD835\uDC56, \uD835\uDC57 ∈ {1,2, … , \uD835\uDC5B}\n(every cell of the grid is occupied by at most one pebble)\n(iii) ∃\uD835\uDC56, \uD835\uDC57 ∈ {1,2, … , \uD835\uDC5B} such that ∀\uD835\uDC5D ∈ Ω\uD835\uDC5B (\uD835\uDC65\uD835\uDC5B(\uD835\uDC5D), \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)) ≠ (\uD835\uDC56, \uD835\uDC57)\n(there exists a cell in the grid that remains vacant).\nFor convenience, we will also use some kind of an inverse to \uD835\uDC65\uD835\uDC5B and \uD835\uDC66\uD835\uDC5B which will be called an occupancy function and denoted as \uD835\uDF0E\uD835\uDC5B: {1,2, … , \uD835\uDC5B}×{1,2, … , \uD835\uDC5B} ⟶ Ω\uD835\uDC5B ∪ {⊥}. It holds that \uD835\uDF0E\uD835\uDC5B(\uD835\uDC56, \uD835\uDC57) = \uD835\uDC5D if and only if \uD835\uDC5D ∈ Ω\uD835\uDC5B and \uD835\uDC65\uD835\uDC5B(\uD835\uDC5D) = \uD835\uDC56 and \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D) = \uD835\uDC57 or \uD835\uDF0E\uD835\uDC5B(\uD835\uDC56, \uD835\uDC57) =⊥ if no such pebble \uD835\uDC5D exists (that is, if the cell (\uD835\uDC56, \uD835\uDC57) is vacant). □\n(1)\n(2)\n(3)\nThe configuration of pebbles in the grid can be changed through moves. An allowed move is to shift a pebble horizontally or vertically from its original cell to the adjacent vacant cell. Formally, the notion of move is described in the following definition. Four types of moves are distinguished here: left, right, up, and down – only left move is defined formally; right, up, and down moves are analogous.\nDefinition 2 (left move). A left move with pebble \uD835\uDC5D ∈ Ω\uD835\uDC5B can be done if \uD835\uDC65\uD835\uDC5B(\uD835\uDC5D) > 1 and \uD835\uDF0E\uD835\uDC5B(\uD835\uDC65\uD835\uDC5B(\uD835\uDC5D) − 1, \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)) =⊥; it holds for the resulting configuration after the move described by \uD835\uDC65\uD835\uDC5B ′ and \uD835\uDC66\uD835\uDC5B ′ that \uD835\uDC65\uD835\uDC5B ′ (\uD835\uDC5E) = \uD835\uDC65\uD835\uDC5B(\uD835\uDC5E) and \uD835\uDC66\uD835\uDC5B ′ (\uD835\uDC5E) = \uD835\uDC66\uD835\uDC5B(\uD835\uDC5E) ∀\uD835\uDC5E ∈ Ω\uD835\uDC5B such that \uD835\uDC5E ≠ \uD835\uDC5D and \uD835\uDC65\uD835\uDC5B ′ (\uD835\uDC5D) = \uD835\uDC65\uD835\uDC5B(\uD835\uDC5D) − 1 and \uD835\uDC66\uD835\uDC5B ′ (\uD835\uDC5D) = \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D). □\nWe are now able to define the (\uD835\uDC5B2 − 1)-puzzle using the formal constructs we have just introduced. The task is to transform a given initial configuration of pebbles in the grid to a given goal one using a sequence of allowed moves.\nDefinition 3 ((\uD835\uDC8F\uD835\uDFD0 − \uD835\uDFCF)-puzzle). An instance of the (\uD835\uDC5B2 − 1)-puzzle is a tuple (\uD835\uDC5B, Ω\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B 0, \uD835\uDC66\uD835\uDC5B 0, \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +) where \uD835\uDC5B ∈ ℕ is the size of the instance, Ω\uD835\uDC5B is a set of pebbles, \uD835\uDC65\uD835\uDC5B 0 and \uD835\uDC66\uD835\uDC5B 0 is a pair of functions that describes the initial configuration of pebbles in the grid, and \uD835\uDC65\uD835\uDC5B + and \uD835\uDC66\uD835\uDC5B + is a pair of functions that describes the goal configuration of pebbles. The task is to find a sequence of allowed moves that transforms the initial configuration into the goal one. Such sequence of moves will be called a solution to the instance. □\nAgain it is supposed that the occupancy function is available with respect to the initial\nconfiguration \uD835\uDC65\uD835\uDC5B 0, \uD835\uDC66\uD835\uDC5B 0 and the goal configuration \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +; that is, we are provided with occupancy functions \uD835\uDF0E\uD835\uDC5B 0 and \uD835\uDF0E\uD835\uDC5B +. To avoid special cases it will be also supposed that \uD835\uDF0E\uD835\uDC5B +(\uD835\uDC5B, \uD835\uDC5B) = ⊥; that is, the vacant position is finally in the right bottom corner.\n2.2. Complexity and Variants of the Problem\nIt is known that the decision variant of the (\uD835\uDC5B2 − 1)-puzzle (that is, the yes/no question whether there exists a solution to the given instance) is in \uD835\uDC43 [1, 13, 44]. It can be checked by using simple parity criterion. Using techniques for rearranging pebbles over graphs [1] a solution of length \uD835\uDCAA(\uD835\uDC5B6) can be constructed in the worst-case time of \uD835\uDCAA(\uD835\uDC5B6) if there exists any. An approach dedicated exclusively to the (\uD835\uDC5B2 − 1)-puzzle is able to generate a solution of length \uD835\uDCAA(\uD835\uDC5B3) in the worst-case time of \uD835\uDCAA(\uD835\uDC5B3) if there exists any [13].\nIf a requirement on the length of the solution is added, the problem becomes harder. It is known that the decision problem of whether there exists a solution to a given (\uD835\uDC5B2 − 1)-puzzle of at most the given length is \uD835\uDC41\uD835\uDC43-complete [17]."
    }, {
      "heading" : "3. The Original Solving Algorithm and Related Works",
      "text" : "A special sub-optimal solving algorithm dedicated for the (\uD835\uDC5B2 − 1)-puzzle has been proposed by Parberry in [13]. As our new solving algorithm is based on the framework of the original one, we need to recall it at least briefly in this section.\n3.1. Algorithm of Parberry\nThe algorithm of Parberry [13] sequentially places pebbles into rows and columns. More precisely, pebbles are placed sequentially into the first row and then into the first column, which reduces the instance to that of the same type but smaller – that is, we obtain an instance of the ((\uD835\uDC5B − 1)2 − 1)-puzzle.\nThis process of pebble placement is repeated until an 8-puzzle on the grid of size 3×3 is obtained. The final case of the 8-puzzle is then solved optimally by the A* algorithm [18].\nThe main loop of the algorithm is shown in pseudo-code as Algorithm 1. The algorithm uses two high-level functions Place-Pebble, which conducts placement of a pebble to a given position, and Solve-8-Puzzle, which finalizes the solution by solving the residual 8-puzzle.\nThe placement of pebbles implemented within the function Place-Pebble will be discussed in more details later in the context of our improvement. Nevertheless, it is done quite naturally by moving a pebble first diagonally towards the goal position if necessary and then horizontally or vertically. To be able to conduct diagonal, horizontal and vertical movement a vacant position needs to be moved together with the pebble being placed. Actually, the vacant position is moving around the pebble always to the front in the direction of the intended move. After having vacant position in the front, the pebble is moved forward. It is necessary to avoid already placed pebbles when placing a new one.\nAlgorithm 1. The original algorithm of Parberry for solving the (\uD835\uDC5B2 − 1)-puzzle [13]. The main loop of the algorithm is shown. Detailed description of placement of individual pebbles is not shown here –it will be discussed in the context of new approach for pebble placement.\nprocedure Solve-N^2-1-Puzzle(\uD835\uDC5B, Ω\uD835\uDC5B, \uD835\uDC65\uD835\uDC5B 0, \uD835\uDC66\uD835\uDC5B 0, \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +) /* A procedure that produces a sequence of moves that solves the given (\uD835\uDC5B2 − 1)-puzzle. Parameters: \uD835\uDC5B, Ω\uD835\uDC5B - a size of the puzzle and a set of pebbles, \uD835\uDC65\uD835\uDC5B 0, \uD835\uDC66\uD835\uDC5B 0 - an initial configuration of pebbles in the grid,\n\uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B + - a goal configuration of pebbles in the grid. */\n1: (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B) ← (\uD835\uDC65\uD835\uDC5B 0, \uD835\uDC66\uD835\uDC5B 0) 2: for \uD835\uDC56 = 1,2, … , \uD835\uDC5B − 3 do 3: for \uD835\uDC57 = \uD835\uDC56, \uD835\uDC56 + 1, … , \uD835\uDC5B do {current row is solved – from the left to the right} 4: \uD835\uDC5D ← \uD835\uDF0E\uD835\uDC5B\n+(\uD835\uDC56, \uD835\uDC57) 5: if (\uD835\uDC56, \uD835\uDC57) ≠ (\uD835\uDC65\uD835\uDC5B +(\uD835\uDC5D), \uD835\uDC66\uD835\uDC5B +(\uD835\uDC5D)) then 6: (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B) ← Place-Pebble(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDC56, \uD835\uDC57, \uD835\uDC5D) 7: Ω\uD835\uDC5B ← Ω\uD835\uDC5B ∖ {\uD835\uDC5D} 8: for \uD835\uDC57 = \uD835\uDC5B, \uD835\uDC5B − 1, … , \uD835\uDC56 + 1 do {current column is solved – from the bottom to the up} 9: \uD835\uDC5D ← \uD835\uDF0E\uD835\uDC5B\n+(\uD835\uDC56, \uD835\uDC57) 10: if (\uD835\uDC56, \uD835\uDC57) ≠ (\uD835\uDC65\uD835\uDC5B +(\uD835\uDC5D), \uD835\uDC66\uD835\uDC5B +(\uD835\uDC5D)) then 11: (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B) ← Place-Pebble(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDC56, \uD835\uDC57, \uD835\uDC5D) 12: Ω\uD835\uDC5B ← Ω\uD835\uDC5B ∖ {\uD835\uDC5D} 13: Ω3 ← Ω\uD835\uDC5B; \uD835\uDC653 0 ← \uD835\uDC65\uD835\uDC5B|Ω3; \uD835\uDC663 0 ← \uD835\uDC66\uD835\uDC5B|Ω3; \uD835\uDC653 + ← \uD835\uDC65\uD835\uDC5B +|Ω3; \uD835\uDC663 + ← \uD835\uDC66\uD835\uDC5B +|Ω3 {restriction on Ω\uD835\uDC5B} 14: Solve-8-Puzzle(Ω3, \uD835\uDC653 0, \uD835\uDC663 0, \uD835\uDC653 +, \uD835\uDC663 +) {the residual 8-puzzle is solved by A* algorithm}\n3.2. Other Related Works\nThe (\uD835\uDC5B2 − 1)-puzzle represents a special variant of a more general problem of cooperative path-finding - CPF (also known as pebble motion problem on a graph) [10, 11, 19, 20, 23, 29, 44]. The generalization consists in the fact that there is an arbitrary undirected graph representing the environment instead of the regular 4-connected grids as it is in the case of (\uD835\uDC5B2 − 1)-puzzle. There are also pebbles, in context of CPF called robots (or agents), that are placed in vertices of the graph while at least one vertex remains vacant. The allowed state transition is a single move with a robot to a vacant adjacent vertex. The task is expectably to rearrange robots from a given initial configuration to a given goal one.\nAlthough the problem has been already studied [10, 44], new results appeared recently. One of recent works shows solvability of every instance of pebble motion problem consisting of bi-connected graph [36, 40, 41] containing at least two vacant positions [26]. The related solving algorithm called BIBOX [26] can produce solution of length at most \uD835\uDCAA(|\uD835\uDC49|3) in the worst-case time of \uD835\uDCAA(|\uD835\uDC49|3) (\uD835\uDC49 is the set of vertices of the input graph). The BIBOX algorithm also generates solutions that are significantly shorter than those generated by algorithms from previous works [10, 44].\nA generalization of BIBOX algorithm called BIBOX-θ is described in [29]. It does not need the second vacant position and again can solve instances on bi-connected graphs (no-\ntice that the grid of the (\uD835\uDC5B2 − 1)-puzzle is a bi-connected graph; hence BIBOX-θ is applicable to it). Theoretically, it generates solutions of the worst-case length of \uD835\uDCAA(|\uD835\uDC49|4); however, practically solutions are much shorter.\nA more general algorithm called PUSH-and-SWAP has been published in [11] – it shows that for every solvable instance on an arbitrary graph containing at least two vacant positions a solution of length \uD835\uDCAA(|\uD835\uDC49|3) can be generated. The algorithm omits few cases that make it incomplete; however a corrected version of PUSH-and-SWAP called PUSHand-ROTATE has been appeared in [42, 43].\nIn all the above results the solution length is sub-optimal and the worst-case time complexity is guaranteed (it is polynomial). A progress has been also made in optimal solving of the pebble motion problem. A new technique that can optimally solve a special case consisting of a grid with obstacles and relatively small number of pebbles is described in [25] as ID+OD algorithm (Independence Detection + Operator Decomposition). It is based on an informed search with powerful heuristics, which however does not guarantee time necessary to produce a solution (the time may be exponential in the size of the instance) as in the case of sub-optimal methods studied in this work. A more recent progress in searchbased techniques for optimal CPF solving is represented by [3, 4, 21, 22].\nSpecial cases of the problem with large graphs and relatively sparsely arranged pebbles are studied in [38, 39]. These new techniques are focused on applications in computer games. The complexity as well as the solution quality is guaranteed by these techniques. Another specialized technique for relatively large graphs and small number of pebbles has been developed within [19, 20]. The graph representing the environment is decomposed into subgraph patterns, which are subsequently used for more efficient solving by search."
    }, {
      "heading" : "4. A New Solving Approach Based on ‘Snakes’",
      "text" : "In this section, we are about to define a new concept of a so-called snake. Informally, a snake is a sequence of pebbles that consecutively neighbors with a pebble that proceeds. As we will show, moving and placing a snake as a whole is much more efficient than moving and placing individual pebbles it consists of.\nRecall that original algorithm for solving the puzzle [13] places pebbles individually into currently solved row or column. This may be inefficient if two or more pebbles that need to be placed are grouped together in some location distant from their goal location. In such a case, it is necessary that the vacant position is moved together with the pebble being placed and then it is moved back to the distant location to allow movement of the next pebble. If we manage all the pebbles forming the group to move from their distant location to their goal positions jointly, multiple movements of the vacant position between the distant location and goal positions may be eliminated.\n4.1. Formal Definition of a ‘Snake’\nConsider a situation shown in Figure 2 where pebbles 1 and 2 are grouped together in a location distant from their goal positions. The original algorithm consumes 16\uD835\uDC5B − 20 moves to place both pebbles successfully to their goal positions. If pebbles are moved not one by one but jointly as it is shown in Figure 3, much less movements are necessary. Grouping pebbles can save up to 4 ∙ \uD835\uDC5B moves.\nThis is the basic idea behind the concept of snake. Let us start with definition of a metric\non the grid of the puzzle. Then the definition of the snake will follow.\nDefinition 4 (Manhattan distance). A Manhattan distance for the (\uD835\uDC5B2 − 1)-puzzle \uD835\uDF07\uD835\uDC5B: {1,2, … , \uD835\uDC5B} 2×{1,2, … , \uD835\uDC5B}2 ⟶ {0,1, … ,2\uD835\uDC5B − 1} is a metric on the square grid such that \uD835\uDF07\uD835\uDC5B((\uD835\uDC651, \uD835\uDC661); (\uD835\uDC652, \uD835\uDC662)) = |\uD835\uDC651 − \uD835\uDC652| + |\uD835\uDC661 − \uD835\uDC662|. □\nThe input parameters of the Manhattan distance \uD835\uDF07 are coordinates of two positions. Having a metric on the grid of the puzzle, we are able to define neighborhood of a pebble. A snake will be then defined using the notion of neighborhood as a sequence of pebbles that consecutively lies in neighborhood of a pebble that proceeds.\nDefinition 5 (Manhattan neighborhood). A Manhattan neighborhood of a pebble \uD835\uDC5D denoted as \uD835\uDF08(\uD835\uDC5D) is a set of those pebbles that are located directly left, right, above and below\nto \uD835\uDC5D with respect to the configuration on the grid. That is, \uD835\uDF08(\uD835\uDC5D) = {\uD835\uDC5E ∈ Ω\uD835\uDC5B|\uD835\uDF07\uD835\uDC5B((\uD835\uDC65\uD835\uDC5B(\uD835\uDC5D), \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)); (\uD835\uDC65\uD835\uDC5B(\uD835\uDC5E), \uD835\uDC66\uD835\uDC5B(\uD835\uDC5E))) = 1}. □\nDefinition 6 (Snake). A snake \uD835\uDC60 of size \uD835\uDC58 is a sequence of pebbles \uD835\uDC60 = [\uD835\uDC601, \uD835\uDC602, … , \uD835\uDC60\uD835\uDC58] such that ∀\uD835\uDC56 ∈ {1,2, … , \uD835\uDC58} \uD835\uDC60\uD835\uDC56 ∈ Ω\uD835\uDC5B and ∀\uD835\uDC57 ∈ {2,3, … , \uD835\uDC58} \uD835\uDC60\uD835\uDC57 ∈ \uD835\uDF08(\uD835\uDC60\uD835\uDC57−1). Pebble \uD835\uDC601 is called a head of the snake; pebble \uD835\uDC60\uD835\uDC58 is called a tail of the snake. □\nNotice that each pebble itself forms a trivial snake of size 1. Composed movements of a snake horizontally, vertically, and diagonally can be defined analogically as in the case of a single pebble. If fact, they are generalizations of composed movements for single pebble. It is always assumed that the vacant position is in front of the head of snake in the direction of the intended movement. In such a setup, the snake can move forward by one position. The vacant position then needs to be moved around the snake in front of its head again to allow the next movement forward. See Figure 4 for illustration of composed movements for snakes (movements for a snake of length 2 are shown; it is easy to generalize composed movements for snakes of arbitrary length).\nThe horizontal and vertical composed movements consume 2\uD835\uDC58 + 3 moves. The number of moves consumed by the diagonal movement depends on the shape of a snake in the middle section – it is not that easy to express. However, if we need to move a snake of length 2 diagonally forward following the shape from Figure 4, then it consumes 10 moves.\nUnfortunately it is rarely the case that a group of pebbles in some distant from goal location forms a snake. Even it is not that frequent that pebbles which are to be placed consecutively are close to each other. Hence, to take the advantage of moving a group of pebbles as a snake we need first to form a snake of them. This is however not for free as a number of moves are necessary to form a snake. Thus, it is advisable to consider whether\nforming a snake is worthwhile. Moreover, there are many ways how to form a snake while each may be of different cost in terms of the number of moves.\nGenerally, the simplest way is to move one pebble to the other or vice versa in order to form a snake of length 2. It is known by using above calculations what number of moves is consumed by moving a snake as well as what number of moves are consumed by moving a pebble towards other pebble. Hence, it is easy to estimate the cost of using a snake in either of both ways as well as the cost of not using it at all in terms of the number of moves. Thus, it is possible to choose the most efficient option. This is another core idea of our new algorithm.\n4.2. A ‘Snake’ Based Algorithm\nOur new algorithm for solving the (\uD835\uDC5B2 − 1)-puzzle will use snakes of length 2. The algorithm proceeds in the same way as the original algorithm of Parberry [13]. That is, pebbles are placed into the first row and then into the first column and after the first row and the first column are finished the task is reduced to the puzzle of the same type but smaller (namely, the task is reduced to solve the ((\uD835\uDC5B − 1)2 − 1)-puzzle). The trivial case of the 8- puzzle on a grid of the size 3×3 is again solved by the A* algorithm [18].\nAlong the solving process, the concept of snakes is used to move pebbles in a more efficient way. The basic idea is to make an estimation whether it will be beneficial to form a snake of two pebbles that are about to be placed. If so then a snake is formed in one of the two ways – the first pebble is moved towards the second one or vice versa – the better option according to the estimations is always chosen. If forming a snake turns out not to be beneficial then pebbles are moved in the same way as in the case of the original algorithm; that is, one by one.\nAlgorithm 2. The main function of a new algorithm for solving the (\uD835\uDC5B2 − 1)-puzzle. The function for producing a sequence of moves for placing two consecutive pebbles using snakes (if using snakes turns out to be beneficial) is shown.\nfunction Place-Pebbles(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +, \uD835\uDC5D, \uD835\uDC5E): pair /* A function that produces a sequence of moves for placing two consecutive pebbles\nwith respect to the order of placement. The new configuration is returned in a return value. Parameters: \uD835\uDC65\uD835\uDC5B, \uD835\uDC65\uD835\uDC66 - a current configuration of pebbles in the grid, \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B + - a goal configuration of pebbles in the grid,\n\uD835\uDC5D, \uD835\uDC5E - two consecutive pebbles that will be placed. */ 1: \uD835\uDC50 ← cost1(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +)(\uD835\uDC5D, \uD835\uDC5E) 2: \uD835\uDC52\uD835\uDC5D,\uD835\uDC5E ← estimatesnake(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B, \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B\n+)(\uD835\uDC5D, \uD835\uDC5E) 3: \uD835\uDC52\uD835\uDC5E,\uD835\uDC5D ← estimatesnake(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +)(\uD835\uDC5E, \uD835\uDC5D) 4: if min {\uD835\uDC52\uD835\uDC5D,\uD835\uDC5E , \uD835\uDC52\uD835\uDC5E,\uD835\uDC5D} < 1.2\uD835\uDC50 then 5: if \uD835\uDC52\uD835\uDC5D,\uD835\uDC5E < \uD835\uDC52\uD835\uDC5E,\uD835\uDC5D then 6: let (\uD835\uDC56, \uD835\uDC57) be a position such that |\uD835\uDC56 − \uD835\uDC65\uD835\uDC5B(\uD835\uDC5D)| + |\uD835\uDC57 − \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)| = 1 7: (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B) ← Move-Vacant(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDC56, \uD835\uDC57) 8: \uD835\uDC51\uD835\uDC5A\uD835\uDC56\uD835\uDC5B ← min {|\uD835\uDC56 ′ − \uD835\uDC65\uD835\uDC5B(\uD835\uDC5D)| + |\uD835\uDC57 ′ − \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)|| \uD835\uDC56 ′, \uD835\uDC57′ ∈ ℕ ∧ |\uD835\uDC56′ − \uD835\uDC65\uD835\uDC5B(\uD835\uDC5E)| + |\uD835\uDC57 ′ − \uD835\uDC66\uD835\uDC5B(\uD835\uDC5E)| = 1} 9: let (\uD835\uDC56, \uD835\uDC57) be a position such that |\uD835\uDC56 − \uD835\uDC65\uD835\uDC5B(\uD835\uDC5D)| + |\uD835\uDC57 − \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)| = \uD835\uDC51\uD835\uDC5A\uD835\uDC56\uD835\uDC5B adjacent to \uD835\uDC5E 10: (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B) ← Place-Pebble(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B, \uD835\uDC56, \uD835\uDC57, \uD835\uDC5D) 11: else 12: let (\uD835\uDC56, \uD835\uDC57) be a position such that |\uD835\uDC56 − \uD835\uDC65\uD835\uDC5B(\uD835\uDC5E)| + |\uD835\uDC57 − \uD835\uDC66\uD835\uDC5B(\uD835\uDC5E)| = 1 13: (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B) ← Move-Vacant(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDC56, \uD835\uDC57) 14: \uD835\uDC51\uD835\uDC5A\uD835\uDC56\uD835\uDC5B ← min {|\uD835\uDC56 ′ − \uD835\uDC65\uD835\uDC5B(\uD835\uDC5E)| + |\uD835\uDC57 ′ − \uD835\uDC66\uD835\uDC5B(\uD835\uDC5E)|| \uD835\uDC56 ′, \uD835\uDC57′ ∈ ℕ ∧ |\uD835\uDC56′ − \uD835\uDC65\uD835\uDC5B(\uD835\uDC5D)| + |\uD835\uDC57 ′ − \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)| = 1} 15: let (\uD835\uDC56, \uD835\uDC57) be a position such that |\uD835\uDC56 − \uD835\uDC65\uD835\uDC5B(\uD835\uDC5E)| + |\uD835\uDC57 − \uD835\uDC66\uD835\uDC5B(\uD835\uDC5E)| = \uD835\uDC51\uD835\uDC5A\uD835\uDC56\uD835\uDC5B adjacent to \uD835\uDC5D 16: (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B) ← Place-Pebble(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B, \uD835\uDC56, \uD835\uDC57, \uD835\uDC5E) 17: let \uD835\uDC60 = [\uD835\uDC5D, \uD835\uDC5E] be a snake {actually \uD835\uDC5D and \uD835\uDC5E form a snake at this point} 18: let \uD835\uDF0B be a shortest path from (\uD835\uDC65\uD835\uDC5B(\uD835\uDC5D), \uD835\uDC66\uD835\uDC5B(\uD835\uDC5D)) to (\uD835\uDC65\uD835\uDC5B +(\uD835\uDC5D), \uD835\uDC66\uD835\uDC5B +(\uD835\uDC5D)) such that\n\uD835\uDF0B[|\uD835\uDF0B| − 1] = (\uD835\uDC65\uD835\uDC5B +(\uD835\uDC5E), \uD835\uDC66\uD835\uDC5B +(\uD835\uDC5E)) and \uD835\uDF0B does not intersect any position containing already placed pebble\n19: for \uD835\uDC58 = 1,2, … , |\uD835\uDF0B| − 1 do 20: (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B) ← Snake-Composed-Movement(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDF0B[\uD835\uDC58], \uD835\uDF0B[\uD835\uDC58 + 1], \uD835\uDC60)\n{when vacant position is moved it should avoid already placed pebbles}\n21: else 22: (\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B) ← Place-Pebble(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B, \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B\n+, \uD835\uDC5D) 23: (\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B) ← Place-Pebble(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B, \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +, \uD835\uDC5E) 24: return (\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B)\nLet estimatesnake(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B, \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +): Ω\uD835\uDC5B×Ω\uD835\uDC5B ⟶ ℕ0 is a functional that estimates the number of moves necessary to place a given two pebbles using the snake like motion. More precisely, estimatesnake(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +)(\uD835\uDC5D, \uD835\uDC5E) is the estimation of the number of moves necessary to form a snake by moving pebble \uD835\uDC5D towards \uD835\uDC5E and to place the formed snake into the goal location where \uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B and \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B + denote the current and the goal configurations respectively. It is an admissible heuristic if considered in term of A*. Notice, that\nestimatesnake(\uD835\uDC65\uD835\uDC5B, \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +) can be calculated as sum of distances between several sections multiplied by number of moves needed to travel a unit of distance in that section. However, as different shapes of snake may occur, this calculation may not be exact. Next, let cost1(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +): Ω\uD835\uDC5B×Ω\uD835\uDC5B ⟶ ℕ0 be a functional that calculates exact number of moves necessary to place given two pebbles individually. As the case of individual pebbles is not distorted by any irregularities (such as different shapes as in the case of snake) the number of moves can be calculated exactly – again it is the sum of distances between given sections multiplied by the number of moves needed to travel unit distance in the individual sections.\nA preliminary experimental evaluation has shown that it suitable to use the following\ndecision rule: if min {estimatesnake(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +)(\uD835\uDC5D, \uD835\uDC5E), estimatesnake(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +) (\uD835\uDC5D, \uD835\uDC5E)} < 1.2cost1(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B, \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +)(\uD835\uDC5D, \uD835\uDC5E) holds then it is tried to form a snake in the better of two ways and to compare the number of moves when snake is used with cost1(\uD835\uDC65\uD835\uDC5B , \uD835\uDC66\uD835\uDC5B , \uD835\uDC65\uD835\uDC5B +, \uD835\uDC66\uD835\uDC5B +)(\uD835\uDC5D, \uD835\uDC5E). If snake is still better then it is actually used to produce sequence of moves into the solution. Otherwise, the original way of placement of pebbles one by one is used.\nThe main function Place-Pebbles for placing a pair of pebbles using snake like motions is shown using pseudo-code as Algorithm 2. It is supposed that the function is used within the main loop of the solving algorithm (Algorithm 1). Several primitives, which all gets current configuration of pebbles as its first two parameters, are used within Algorithm 2: a\nfunction Move-Vacant moves the vacant position to a specified new location; a function Place-Pebble implements the pebble placement process from the original algorithm of Parberry – here it is used as generic procedure to move pebble from one position to another. Finally, a Snake-Composed-Movement is a function that implements composed movements of a specified snake; two positions are specified – the current position of the head of snake and the new position for the head. It is also assumed that movement of the snake does not interfere with already placed pebbles. An example of snake formation and its placement is shown in Figure 5.\n4.3. Discussion on Longer Snakes\nWe have also considered usage of snakes of length greater than 2. However, certain difficulties preclude using them effectively. There are many more options how to form a snake of length greater than 2. In the case of length \uD835\uDC58, there are at least \uD835\uDC58! basic options how a snake can be formed (the order of pebbles is determined and then the snake collects pebbles in this order). Moreover, those do not include all the options (for example, it may be beneficial to form two snakes instead of a long one and so on). Therefore considering all the options and choosing the best one is computationally infeasible. Hence, using snakes of length 2 seems to be a good trade-off.\n4.4. Theoretical Analysis\nAlthough our new algorithm produces locally better sequence of moves for placing a pair of pebbles, it may not be necessarily better globally. Consider that different way of placing the pair of pebbles rearranges other pebbles differently as well, which may influence subsequent movements. Hence, theoretical analysis is quite difficult here. To evaluate the benefit of the new technique in a more realistic manner, we need some experimental evaluation. Nevertheless, theoretical analysis of worst cases can be done at least to get basic insight.\nIt has been shown that the original algorithm can always find a solution of the length at\nmost 5\uD835\uDC5B3 + 92\uD835\uDC5B 2 + 19 2 \uD835\uDC5B − 89; that is, 5\uD835\uDC5B3 + \uD835\uDCAA(\uD835\uDC5B2) (precisely 5\uD835\uDC5B3 + 4.5\uD835\uDC5B2) [13].\nProposition 1 (Worst-case Solution Length). Our improved algorithm based on snakes can always produce a solution to a given instance of the (\uD835\uDC5B2 − 1)-puzzle of the length of at most 14\n3 \uD835\uDC5B3 + \uD835\uDCAA(\uD835\uDC5B2) (precisely 14 3 \uD835\uDC5B3 + 14\uD835\uDC5B2). \nProof. The worst situation for the worst case calculation of the number of steps using snake-based algorithm we are about to present occurs when the two pebbles – let us denote them \uD835\uDC5D and \uD835\uDC5E – are located in the last row or column. In such a case, we need 14\uD835\uDC5B + \uD835\uDCAA(1) moves in the worst case. Without loss of generality let us suppose both pebbles \uD835\uDC5D and \uD835\uDC5E to be placed in the last row while \uD835\uDC5D is in the first column and \uD835\uDC5E is in the last column. Exactly it is needed: at most 2\uD835\uDC5B − 1 moves to move the vacant position near \uD835\uDC5E; then at most 5(\uD835\uDC5B −\n1) moves to move \uD835\uDC5E towards \uD835\uDC5D which forms a snake; and finally 7\uD835\uDC5B + \uD835\uDCAA(1) moves to relocate the snake into the first row of the grid. These calculations relies on the fact that relocation of the vacant position can be executed by sliding pebbles along a path connecting the source with the goal of the vacant position where each step requires single move. Moving single pebble requires moving vacant position around the pebble to free the position in front of the pebble so moving the pebble one step forward requires 5 moves. Finally, moving the snake is executed in a similar way but the vacant position needs to be moved around the snake, which requires 7 moves.\nThe algorithm needs to place \uD835\uDC5B − 1 pairs of pebbles and one pebble individually in the row. Observe that moving one pebble individually to its goal position requires at most 8\uD835\uDC5B moves if snake like movement is used.\nHence, the first row and the first column requires at most 14\uD835\uDC5B2 + \uD835\uDC501\uD835\uDC5B + \uD835\uDC500 moves where \uD835\uDC500, \uD835\uDC501 ∈ ℝ with \uD835\uDC500, \uD835\uDC501 ≥ 0. Let \uD835\uDC40(\uD835\uDC5B) denotes number of moves needed to solve the (\uD835\uDC5B2 − 1)-puzzle of size \uD835\uDC5B×\uD835\uDC5B. After placing pebbles in the first row and the first columns we have the puzzle of the same type but smaller (the (\uD835\uDC5B − 1)2 − 1 puzzle is obtained by omitting the finished row and column) which can used for bounding the number of moves by the following recurrent inequality: \uD835\uDC40(\uD835\uDC5B) ≤ \uD835\uDC40(\uD835\uDC5B − 1) + 14\uD835\uDC5B2 + \uD835\uDC501\uD835\uDC5B + \uD835\uDC500. The solution of this inequality is \uD835\uDC40(\uD835\uDC5B) = 14\n3 \uD835\uDC5B3 + \uD835\uDCAA(\uD835\uDC5B2). \nProposition 2 (Worst-case Time Complexity). Our new algorithm based on snakes has the worst case time complexity of \uD835\uDCAA(\uD835\uDC5B3). \nProof. The total time consumed by calls of Move-Vacant and Place-Pebble is linear in the number of moves that are performed. The time necessary to find shortest path avoiding already placed vertices is linear as well since the path has always a special shape that is known in advance (diagonal followed by horizontal or vertical). There is no need to use any path-search algorithm.\nTime necessary for calculating estimatesnake is at most the time necessary to finish the\ncall of Place-Pebble, that is, linear in the number of moves again.\nFinally, we need to observe that the call of Snake-Composed-Movement consumes time linear in the number of moves again since first the shortest path of the special shape needs to be found and then a snake needs to be moved along the path. "
    }, {
      "heading" : "5. Application of ‘Snakes’ in Cooperative Path-Finding",
      "text" : "Promising theoretical and preliminary experimental results from the application of the idea of ‘snakes’ in solving (\uD835\uDC5B2 − 1)-puzzle inspired us to extend the idea to a closely related problem of cooperative path-finding (CPF). The task in cooperative path-finding is to relocate a set of abstract robots over a given undirected graph in a non-colliding way so that each robot eventually reaches its goal vertex [23]. Similarly as in (\uD835\uDC5B2 − 1)-puzzle robots can move into unoccupied vertex while no other robot is allowed to enter the same target vertex at the same time. The natural requirement in CPF is that at least one vertex is empty\nin the input CPF instance to allow robots to move. Unlike the situation in (\uD835\uDC5B2 − 1)-puzzle, CPF allows multiple robots to move simultaneously provided there are multiple vacant vertices.\nThe (\uD835\uDC5B2 − 1)-puzzle is thus clearly a special variant of CPF where there is only one unoccupied vertex in the graph and the graph, where pebbles (robots) move, has a special structure of the 4-connected grid. A possible application of snakes in CPF is further supported by the fact that several polynomial-time rule-based algorithms that address CPF such as BIBOX [26], PUSH-and-SWAP [11], and PUSH-and-ROTATE [42] relocate robots one by one over the graph towards their goal locations. That is, in the same way as it is done in the algorithm of Parberry. Hence, these algorithms are candidates for integrating snake movements into their solving process.\n5.1. Cooperative Path Finding Formally\nCooperative path-finding takes place over an undirected graph \uD835\uDC3A = (\uD835\uDC49, \uD835\uDC38) where \uD835\uDC49 = {\uD835\uDC631, \uD835\uDC632, … , \uD835\uDC63\uD835\uDC5B} is a finite set of vertices and \uD835\uDC38 ⊆ ( \uD835\uDC49 2 ) is a set of edges. The configuration of robots over the graph is modeled by assigning them vertices of the graph. Let \uD835\uDC45 = {\uD835\uDC5F1, \uD835\uDC5F2, … , \uD835\uDC5F\uD835\uDF07} be a finite set of robots. Then, a configuration of robots in vertices of graph \uD835\uDC3A will be fully described by a location function \uD835\uDEFC: \uD835\uDC45 ⟶ \uD835\uDC49; the interpretation is that an robot \uD835\uDC5F ∈ \uD835\uDC45 is located in a vertex \uD835\uDEFC(\uD835\uDC5F). At most one robot can be located in a vertex; that is \uD835\uDEFC is a uniquely invertible function. A generalized inverse of \uD835\uDEFC denoted as \uD835\uDEFC−1: \uD835\uDC49 ⟶ \uD835\uDC45 ∪ {⊥} will provide us a robot located in a given vertex or ⊥ if the vertex is empty.\nDefinition 7 (Cooperative Path-Finding). An instance of cooperative path-finding problem (CPF) is a quadruple Σ = [\uD835\uDC3A = (\uD835\uDC49, \uD835\uDC38), \uD835\uDC45, \uD835\uDEFC0, \uD835\uDEFC+] where location functions \uD835\uDEFC0 and \uD835\uDEFC+ define the initial and the goal configurations of a set of robots \uD835\uDC45 in \uD835\uDC3A respectively. □\nThe dynamicity of the model assumes a discrete time divided into time steps. A configuration \uD835\uDEFC\uD835\uDC56 at the \uD835\uDC56-th time step can be transformed by a transition action which instantaneously moves robots in the non-colliding way to form a new configuration \uD835\uDEFC\uD835\uDC56+1. The resulting configuration \uD835\uDEFC\uD835\uDC56+1 must satisfy the following validity conditions:\n(i) ∀\uD835\uDC5F ∈ \uD835\uDC45 either \uD835\uDEFC\uD835\uDC56(\uD835\uDC5F) = \uD835\uDEFC\uD835\uDC56+1(\uD835\uDC5F) or {\uD835\uDEFC\uD835\uDC56(\uD835\uDC5F), \uD835\uDEFC\uD835\uDC56+1(\uD835\uDC5F)} ∈ \uD835\uDC38 holds\n(robots move along edges or not move at all),\n(ii) ∀\uD835\uDC5F ∈ \uD835\uDC45 \uD835\uDEFC\uD835\uDC56(\uD835\uDC5F) ≠ \uD835\uDEFC\uD835\uDC56+1(\uD835\uDC5F) ⇒ \uD835\uDEFC\uD835\uDC56 −1(\uD835\uDEFC\uD835\uDC56+1(\uD835\uDC5F)) =⊥\n(robots move to vacant vertices only), and\n(iii) ∀\uD835\uDC5F, \uD835\uDC60 ∈ \uD835\uDC34 \uD835\uDC5F ≠ \uD835\uDC60 ⇒ \uD835\uDEFC\uD835\uDC56+1(\uD835\uDC5F) ≠ \uD835\uDEFC\uD835\uDC56+1(\uD835\uDC60)\n(no two robots enter the same target/unique invertibility of the resulting configuration).\nThe task in cooperative path finding is to transform \uD835\uDEFC0 using above valid transitions to\n\uD835\uDEFC+. An illustration of CPF and its solution is depicted in Figure 6.\n(4)\n(5)\n(6)\nDefinition 8 (Solution). A solution of a makespan \uD835\uDC5A to a cooperative path finding instance Σ = [\uD835\uDC3A, \uD835\uDC45, \uD835\uDEFC0, \uD835\uDEFC+] is a sequence of configurations \uD835\uDC60 = [\uD835\uDEFC0, \uD835\uDEFC1, \uD835\uDEFC2, … , \uD835\uDEFC\uD835\uDC5A] where \uD835\uDEFC\uD835\uDC5A = \uD835\uDEFC+ and \uD835\uDEFC\uD835\uDC56+1 is a result of valid transformation of \uD835\uDEFC\uD835\uDC56 for every = 1,2, … , \uD835\uDC5A − 1. □\nThe number |\uD835\uDC60| = \uD835\uDC5A is a makespan of solution \uD835\uDC60. It is known that deciding whether there exists a solution of CPF of a given makespan is \uD835\uDC41\uD835\uDC43-complete [17, 30].\n5.2. Introducing ‘Snakes’ into the BIBOX Algorithm\nWe will briefly recall basics of the BIBOX algorithm before the improvement with snakes will be integrated into it. The comprehensive description and evaluation of the algorithm is given in [33] to which we refer the reader for further details. The algorithm is designed for CPFs over bi-connected graphs with at least two unoccupied vertices (modifications for single unoccupied vertex exist as well [29]).\nObserve that, if a graph is bi-connected, then every two distinct vertices are connected by at least two vertex disjoint paths (equivalently, there is a cycle containing both vertices; only internal vertices of paths are considered when speaking about vertex disjoint paths -\n\uD835\uDC6A\uD835\uDFCE\n\uD835\uDC73\uD835\uDFCF\n\uD835\uDC73\uD835\uDFD0\n\uD835\uDC73\uD835\uDFD1\n\uD835\uDC3A = (\uD835\uDC49, \uD835\uDC38)\nvertex disjoint paths can intersect in their start points and endpoints). An example of biconnected graph is shown in Figure 7.\nAn algorithmically important property of bi-connected graphs is that every bi-connected graph can be constructed from a cycle by adding sequence of ears to the currently constructed graph [36, 40, 41]. The BIBOX algorithm is substantially based on this property. Consider a graph \uD835\uDC3A = (\uD835\uDC49, \uD835\uDC38); the new ear with respect to \uD835\uDC3A is a sequence \uD835\uDC3F = [\uD835\uDC62, \uD835\uDC641, \uD835\uDC642, … , \uD835\uDC64ℎ , \uD835\uDC63] where ℎ ∈ ℕ0, \uD835\uDC62, \uD835\uDC63 ∈ \uD835\uDC49 such that \uD835\uDC62 ≠ \uD835\uDC63 (called connection vertices) and \uD835\uDC64\uD835\uDC56 ∉ \uD835\uDC49 for \uD835\uDC56 = 1,2, … , ℎ (\uD835\uDC64\uD835\uDC56 are fresh vertices). The result of the addition of the ear \uD835\uDC3F to the graph \uD835\uDC3A is a new graph \uD835\uDC3A′ = (\uD835\uDC49′, \uD835\uDC38′) where \uD835\uDC49′ = \uD835\uDC49 ∪ {\uD835\uDC641, \uD835\uDC642, … , \uD835\uDC64ℎ} and either \uD835\uDC38′ = \uD835\uDC38 ∪ {{\uD835\uDC62, \uD835\uDC63}} in the case of ℎ = 0 or \uD835\uDC38′ = \uD835\uDC38 ∪ {{\uD835\uDC62, \uD835\uDC641}, {\uD835\uDC641, \uD835\uDC642}, … , {\uD835\uDC64ℎ−1, \uD835\uDC64ℎ}, {\uD835\uDC64ℎ , \uD835\uDC63}} in the case of ℎ > 0. Let the sequence of ears together with the initial cycle be called an ear decomposition of the given bi-connected graph. Again, see Figure 7 for illustrative example.\nLemma 1 (ear decomposition) [36, 40, 41]. Any bi-connected \uD835\uDC3A = (\uD835\uDC49, \uD835\uDC38) graph can be obtained from a cycle by a sequence of operations of adding an ear. \nThe important property of the construction of a bi-connected graph according to its ear decomposition is that the currently constructed graph is bi-connected at every stage of the construction. The algorithm for solving CPFs over bi-connected graphs can proceed inductively according to the ear decomposition by arranging robots into individual ears – after finishing placement of robots into an ear, the problem reduces to a problem of the same type but on a smaller graph without the currently solved ear.\nAs the BIBOX algorithm has been already thoroughly published, its enhancement with snakes described using pseudo-code has been deferred to Appendix B (Algorithm 3). The idea behind using snakes within the BIBOX algorithm is similar as in the case of the algorithm of Parberry.\nAgain, snakes of length 2 are used within the modified BIBOX algorithm. Consider that robots \uD835\uDC5F and \uD835\uDC60 are two consecutive robots within the processed ear \uD835\uDC3F\uD835\uDC56. In the original algorithm, they are moved one by one towards the ear connection vertex and stacked inside the ear by its rotation afterwards; that is, relocation and stacking inside the ear of \uD835\uDC5F and \uD835\uDC60 is done separately. When snake reasoning is used, it is first checked if \uD835\uDC5F and \uD835\uDC60 are close enough to each other before \uD835\uDC5F is relocated towards the ear connection vertex. If it is the case, then \uD835\uDC5F and \uD835\uDC60 are relocated together jointly until \uD835\uDC5F reaches the connection vertex. After such relocation, robot \uD835\uDC60 is next to the connection vertex and can be then stacked into the ear quickly. If robots \uD835\uDC5F and \uD835\uDC60 are too far from each other, then the original relocation of both robots separately is used. The process of relocation of two consecutive robots is implemented by procedure Move-Robot-Snake within the pseudo-code of Algorithm 3.\nLet us now clarify what does it mean that robots are close enough to each other and what the joint relocation means. When considering if snake based relocation pays-off, a simple distance heuristic is used. The cost of relocation is estimated by the length of shortest path between the original and target location. Let \uD835\uDC63 be an ear connection vertex, \uD835\uDEFC current configuration of robots and let distG(\uD835\uDC62, \uD835\uDC63) for \uD835\uDC62, \uD835\uDC63 ∈ \uD835\uDC3A denote the shortest path between \uD835\uDC62 and \uD835\uDC63 in \uD835\uDC3A = (\uD835\uDC49, \uD835\uDC38). Then robots \uD835\uDC5F and \uD835\uDC60 are relocated jointly if:\ndistG(\uD835\uDC63, \uD835\uDEFC(\uD835\uDC5F)) + distG(\uD835\uDEFC(\uD835\uDC5F), \uD835\uDEFC(\uD835\uDC60)) < distG(\uD835\uDC63, \uD835\uDEFC(\uD835\uDC5F)) + distG(\uD835\uDC63, \uD835\uDEFC(\uD835\uDC60))\nThat is, if relocation of \uD835\uDC60 towards \uD835\uDC5F and relocation of \uD835\uDC5F and \uD835\uDC60 jointly towards \uD835\uDC63 seems\nto be less costly than relocation of \uD835\uDC5F and \uD835\uDC60 towards \uD835\uDC63 separately.\nThe original relocation of a robot \uD835\uDC5F within the BIBOX algorithm is done by finding a cycle which includes the target vertex and robot \uD835\uDC5F. One vertex within the cycle is made unoccupied which enable rotation of the cycle. Robot \uD835\uDC5F is moved towards its target by rotating the cycle until \uD835\uDC5F appears in the target vertex. The original relocation is implemented by Move-Robot procedure in the pseudo-code.\nThe joint relocation of a pair of robots uses the very same idea. First, robot \uD835\uDC60 is moved next to \uD835\uDC5F by the original way of relocating robots (Move-Robot). Then a cycle containing the edge, whose endpoints are occupied by \uD835\uDC5F and \uD835\uDC60 respectively, is rotated. The cycle rotated until \uD835\uDC5F reached its target. Throughout the series of rotations of the cycle, robots \uD835\uDC5F and \uD835\uDC60 are preserved to stay next to each other, which eventually means that \uD835\uDC60 is close to its target at the end of joint relocation. The joint relocation is implemented by Move-RobotSnake within the pseudo-code. The illustration of the process of joint relocation of a pair of robots is shown in Figure 8.\n5.3. Introducing ‘Snakes’ into the PUSH-and-SWAP Algorithm\nThe PUSH-and-SWAP algorithm [11] and its later corrected version PUSH-and-ROTATE [42, 43] are more general than BIBOX as they are complete for CPFs over arbitrary graphs with at least two unoccupied vertices. We will concentrate here on the original version of PUSH-and-SWAP though it is not complete since certain cases are not treated by the algorithm [43] – these cases causing incompleteness however do not affect our study.\nThe PUSH-and-SWAP algorithm proceeds in solving of CPF in a similar way as BIBOX and the Parberry’s algorithm since it also places robots to their goal positions one by one while already placed robots are restricted to move. This characteristic makes the algorithm suitable for improvement via snakes. Moving multiple robots opportunistically together towards their goals may save moves over the process of moving them towards goals separately. This is a hypothesis that we would like to investigate.\nWe will focus here on two basic operations, on that the algorithm relies, known as Push and Swap. A robot is always moved towards its goal along a path that connects the current position of the robot with its goal. After the robot reaches its goal it is locked there so the\n(7)\nsubsequent robot rearrangements can move the robot out of its goal vertex temporarily only (the robot must eventually return to its goal).\nThe Push operation tries to push the robot by one step (by one vertex) towards its goal along the path. If the next vertex on the path is occupied by a robot and is unlocked then Push tries to make the next vertex unoccupied by moving the robot out of it.\nIf the Push operation is unsuccessful then it is the turn of the Swap operation. The Swap operation exchanges positions of the robot being relocated and the next robot on the path. Assume that robot \uD835\uDC5F is relocated towards the goal and the next vertex on the path is occupied by robot \uD835\uDC60. The Swap operation will try to move robots \uD835\uDC5F and \uD835\uDC60 to a vertex of the degree at least 3 where \uD835\uDC5F and \uD835\uDC60 are exchanged.\nAssume we have vertex \uD835\uDC63 with deg\uD835\uDC3A(\uD835\uDC63) ≥ 3. Robots \uD835\uDC5F and \uD835\uDC60 are moved together towards \uD835\uDC63 while \uD835\uDC5F is the leading robot followed by \uD835\uDC60. Vertex locking is disregarded now so robots can be moved out of their locked goals. With \uD835\uDC5F in \uD835\uDC63 and \uD835\uDC60 next to it, the two robots are locked in their positions so the subsequent operations cannot move them out. Then two neighbors of \uD835\uDC63 are vacated. As \uD835\uDC5F and \uD835\uDC60 locked in their positions, we have \uD835\uDC5F with two blanks and \uD835\uDC60 as its neighbors. In such a configuration it is possible to exchange \uD835\uDC5F and \uD835\uDC60.\nRobots moved out of their goals during the process preceding the exchange need to be put back. This is done by recording all the moves that precede the exchange at \uD835\uDC63. By executing the recorded moves reversely in the reverse order we restore placement of other robots except \uD835\uDC5F and \uD835\uDC60 which finish swapped at their original positions.\nThe idea behind introducing snakes into the PUSH-and-SWAP algorithm is that moving robots by the Swap operation may consume fewer moves if robots are relocated as a pair (snake of length 2) instead of being moved separately (see Figure 9). This is formally justified by following two lemmas and the following calculation (see Figure 10 for illustration of lemmas).\nLemma 2 (exchange of robot). A pair of robots can be exchanged at a vertex with at least 2 vacant neighbors by using 6 moves. A triple of robots can be exchanged at a vertex with at least 3 vacant neighbors by using 12 moves. \nThe proof of the first statement is given in [43]; the illustration of the second statement\nis shown in Figure 11.\nLemma 3 (robot relocation). Relocation of a robot along a path of length \uD835\uDC58 while disregarding the locked vertices requires at most \uD835\uDC58 removals of a robot from the next vertex on the path. Relocation of a pair of robots along a path of length \uD835\uDC58 requires at most \uD835\uDC58 removals of a robot from the next vertex on the path as well. \nAssume that relocation of two robots needs to traverse paths of length \uD835\uDC58 using the Swap operation while reaching vertices of the degree at least three means to travel distance \uD835\uDC5A in total. This means that a vertex is vacated 2 ∙ \uD835\uDC5A + 2 ∙ \uD835\uDC58 times and a pair of robots is exchanged 2 ∙ \uD835\uDC58 times which is equivalent to 2 ∙ \uD835\uDC58 ∙ 6 = 12 ∙ \uD835\uDC58 moves altogether in the worst case.\nIf the pair of robots is relocated in the similar configuration (the length of path is \uD835\uDC58 and reaching the vertices of the degree at least 4 requires traversing the distance \uD835\uDC5A in total)\njointly, then we need to vacate a vertex \uD835\uDC5A + 3 ∙ \uD835\uDC58 times and a triple of robots is exchanged \uD835\uDC58 times which is equivalent to 12 ∙ \uD835\uDC58 moves in the worst case. Hence, the difference consists in how many times a vertex is vacated during the process. If \uD835\uDC5A + 3 ∙ \uD835\uDC58 < 2 ∙ \uD835\uDC5A + 2 ∙ \uD835\uDC58 that is, if \uD835\uDC58 < \uD835\uDC5A then relocation of robots jointly should produce fewer moves in the worst case as fewer vertex vacations are needed.\nAlthough the above calculation is based on strong assumptions that may not fully hold in practice it lead us to the design of a version of the PUSH-and-SWAP algorithm where robots are relocated together in pairs towards their goals. We suggested an analogy to the Push and Swap operations called Twin-Push and Twin-Swap (see Figure 11 for illustration) that instead of moving a single robot, move a pair of robots jointly. The formal description of the PUSH-and-SWAP algorithm enhanced with snakes is given using pseudo-code in Appendix C. Let us now describe only the top-level change to the original PUSH-andSWAP algorithm. The detailed implementation of basic operations is described in the appendix.\nInstead of placing single robot to its goal, two robots consecutive in some ordering are taken and relocated towards the goal of the former one jointly. The hypothesis is that if a right ordering of robots is taken, then the later robot appears close to its goal after relocation of the pair and only few moves are needed to reach the goal eventually by the latter robot. The (sequential) ordering of robots according to which robots are taken for placement to their goals should satisfy that robots close to each other in the sequence should have goals close to each other in the underlying graph as well. Such a sequential ordering of robots can be obtained by the breadth first search of graph.\nHowever, the joint relocation cannot be applied immediately. First, robots those are consecutive with respect to the given ordering need to be placed next to each other, which requires some extra work and decision-making.\nThere are three options how to perform the relocation of the two robots:\n(i) move the former robot next to the latter one and then relocate robots together\ntowards the goal of the former robot\n(ii) move the latter robot next to the former one and then relocate robots together\ntowards the goal of the former robot\n(iii) do not use the joint relocation at all\nA heuristic decision based on shortest paths calculation can be used to choose one of these options (as suggested in inequality (7)). However, our preliminary experimental evaluation indicated that such a heuristic does not provide acceptable results. The estimation by shortest path does not correspond to the actual number of moves performed by the algorithm (it is a lower bound far from the actual number of moves). This is a significant difference from the BIBOX algorithm where this heuristic worked well. Hence, we used simulation by which we are able to calculate exact number of moves consumed by each of the three options and chose that one that consumed fewest moves.\nIn the case of PUSH-and-SWAP algorithm snakes longer than 2 were not considered as more vacant vertices would be needed and the algorithm will become too complex. Also the above decision making will become much more as the number of options grows exponentially with the increasing length of snakes."
    }, {
      "heading" : "6. Experimental Evaluation",
      "text" : "An experimental evaluation is necessary to explore qualities of our new snake-based improvements to the studied rule-based pebble relocation and cooperative path-finding algorithms. The snake-based improvements to Parberry’s algorithm as well as its variants within rule-based cooperative path-finding algorithms BIBOX and PUSH-and-SWAP have been implemented in C++ to make the experimental evaluation possible.\nThe Parberry’s algorithm and the PUSH-and-SWAP algorithm have been fully re-implemented in C++. The snake-based reasoning within the BIBOX algorithm has been integrated into its original C++ implementation [26] where only minor changes to the code needed to be made. Using the C++ language and the same coding style for implementations of all the evaluated algorithms allowed us to ensure equal testing conditions.\nA series of tests has been conducted to measure the total number of moves performed by each algorithm in various problem setups. The runtime necessary to solve given instances has been measured too.\nIn order to give well readable results we used basic versions of all the evaluated algorithms where sequence of moves with no parallelism is produced as a solution. Further solution improvements that increases parallelism [28, 39, 43] (multiple independent moves can be performed in a single time-step) and removes redundancies [27, 32, 39, 43] were not applied as it is out of scope of this study.\nWe have three rule-based algorithms and the snake-based improvement of each of them, which makes six algorithms to be tested altogether. Such an extensive experimental setup needs to be well designed to obtain meaningful results.\nHence, we suggested evaluating each snake-improved algorithm against its original variant to see how beneficial the introduction of snakes is. This evaluation has been done on (\uD835\uDC5B2 − 1)-puzzles and in the case of more general CPF algorithms BIBOX and PUSHand-SWAP also on instances over randomly generated bi-connected graphs.\nThe complete C++ source code and raw experimental data are available for download on the website: http://ktiml.mff.cuni.cz/~surynek/research/j-puzzle-2015 to allow full reproducibility of presented results and own experiments with snake-based improvements in tested algorithms.\n6.1. Experimental Evaluation of Snakes in the Parberry’s Algorithm\nIn the case of snake-based improvement to the Parberry’s algorithm, we have only the upper bound estimation of the total number of steps so far which however does not show that the new algorithm actually produces fewer moves. Thus, a thorough empiric evaluation needs to be done.\nRegarding the choice of testing puzzles, we followed the benchmark generation already used in the literature by Korf and Taylor [9] where random instances of the (52 − 1)-puzzle were used. There is experimental evidence that solving random instances of the (52 − 1)-puzzle optimally is difficult [9]. Although there is a difference between optimal\n4\n4,5\n5\n5,5\n6\n6,5\n7\n7,5\n8\n8,5\n9\n0 10 20 30 40 50\nR e\nla ti\nve im\np ro\nve m\nen t\n(p er\nce n\nts )\nRelative Improvement in Parberry\nRelative Improvement in Parberry’s Algorithm \uD835\uDC8F Length\nImprovement (%)\n4 5.58 5 4.79 6 5.57 8 5.75\n10 6.34 12 6.51 14 6.59 16 6.66 18 7.29 20 7.51 22 7.54 25 7.49 30 7.84 35 7.84 40 8.07 45 8.26 50 8.26\nTable 1. Relative improvement achieved by using snakes in the Parberry’s algorithm. Again, the improvement has been measured for several sizes of the puzzle ranging from 4 to 50. For each size, 40 random instances were generated and the average improvement was calculated.\nFigure 13. Illustration of the trend in the average improvement. It can be observed that the relative improvement tends to stabilize between 8% and 9% as instances are getting larger.\nPuzzle size (n)\nand sub-optimal solving we consider that these instances are suitable for producing interesting results in a sub-optimal case as well.\nA random instance of the (\uD835\uDC5B2 − 1)-puzzle is generated by placing pebbles randomly (with uniform distribution) to remaining unoccupied positions within the initial arrangement. The goal arrangement consists of pebbles ordered linearly in rows of the 4-connected grid forming the environment starting in the first row and the first column and continuing to the last row and last column where unoccupied position is located. Among randomly generated instances those solvable are taken for experiments.\n6.1.1. Competitive Comparison of the Parberry’s Algorithm with Snakes on Puzzle Instances\nThe competitive comparison of the total number of moves produces by the algorithm of Parberry and its snake-based improvement is shown in Figure 12. The improvement achieved by snake-based approach is illustrated as well. For each size of the instance, average out of 40 random instances is shown.\nIt is observable that the growth of the number of moves for growing size of the instance is polynomial. Next, it can be observed that snakes achieve a stable improvement, which is proportional to the total number of moves. The more detailed insight into the achieved improvement of the total number of moves is provided in Figure 13 and Table 1. It clearly indicates that the improvement is becoming stable between 8% and 9% with respect to the original algorithm, as instances are getting larger.\n6.1.2. Parberry’s Algorithm on Individual Puzzle Instances\nComparison of the total number of moves on the individual instances of various sizes is shown in Figure 14. These results show that using snakes, even though it is locally a better choice, can lead to global worsening of the solution. This phenomenon sometimes occurs exclusively on small instances. Here it is visible for instances of the size of 4×4.\nOn larger instances, the local benefit of using snakes dominates over any local worsening of the configuration so there is stably significant improvement of 7% and 9%. That is, the improvement is not only observable in average calculated from several instances but also on a single instance.\n6.2. Experimental Evaluation of Snakes in the BIBOX Algorithm\nThe BIBOX algorithm can be used to solve (\uD835\uDC5B2 − 1)-puzzle instances, as they are special cases of CPF. We evaluated BIBOX algorithm under the same set of tests as the algorithm of Parberry. As the BIBOX algorithm is more general – it solves instances of cooperative path-finding over bi-connected graphs while the underlying 4-connected grid of the (\uD835\uDC5B2 − 1)-puzzle is a special case of bi-connected graph – the BIBOX algorithms has been submitted to additional tests over more general bi-connected graphs.\n6.2.1. Competitive Comparison of the BIBOX Algorithm with Snake Improvement on Puzzle Instances\nLet us recall that the original BIBOX algorithm as presented in [26] requires two unoccupied vertices so it not immediately applicable to (\uD835\uDC5B2 − 1)-puzzle. These two unoccupied vertices are needed to arrange robots/pebbles in the initial cycle of the ear decomposition while just one vacant vertex is sufficient to arrange pebbles in regular ears [33]. There exists a variant of the algorithm called BIBOX-θ [27, 33] that suffices with just one unoccupied vertex that uses special transposition rules to arrange pebbles in the initial cycle. This algorithm is a candidate to be used in our experiments but as we are working with graphs of fixed 4-connected structure in (\uD835\uDC5B2 − 1)-puzzle there is no need to use the general transposition rules of BIBOX-θ for the initial cycle. Instead, a look-up table with optimal solution to all the possible rearrangements in the original cycle consisting of 4 vertices has been used.\nThere is also a possible parameterization of the BIBOX algorithm with the ear decomposition to be used. As it is shown in [35] various ear decompositions can affect the number of generated moves by the algorithm greatly. Hence, we fixed the ear decomposition of the 4-connected grid so that internal ears consist of a single vertex (that is, we start with the initial 4-cycle and continue by adding ears that fills the underlying 4-connected grid row by row). Such ear decomposition is most similar to how Parberry’s algorithm proceeds.\nResults from the comparison of the number of steps in solutions of the puzzle generated by the BIBOX algorithm and its snake-based improvement are shown in Figure 15. Observe that the BIBOX algorithm generates approximately 3 times larger solutions than the algorithm of Parberry. This is however natural result as BIBOX algorithm is more general for bi-connected graphs and does not exploit the advantage of a priori knowledge that the underlying graph is a 4-connected grid. It is also noticeable that using snakes in case of the BIBOX algorithm saves much more steps in absolute terms than in the case of Parberry’s algorithm.\nThe relative improvement after introducing snakes into the BIBOX algorithm as shown in Figure 16 and Table 2 is around 30% in larger puzzle instance. In small instances even worsening may appear which is caused by inaccuracy of the distance heuristic (7) which does not take into account that the number of performed moves does not need to correspond to shortest paths and that the second robot (denoted as \uD835\uDC60 in section 5.2) may relocate after relocating the first robot (denoted as \uD835\uDC5F).\n6.2.2. BIBOX Algorithm on Individual Puzzle Instances\nSimilarly as in the case of Parberry’s algorithm, we show results of test of the BIBOX algorithm over individual instances of the puzzle. Results are shown in Figure 17. In small instances, relatively significant worsening may appear after using snakes in algorithm\n-15\n-10\n-5\n0\n5\n10\n15\n20\n25\n30\n35\n0 10 20 30 40 50\nR el\nat iv\ne im\np ro\nve m\nen t\n(p er\nce n\nts )\nRelative Improvement in BIBOX\nRelative Improvement\nin BIBOX Algorithm\n\uD835\uDC8F Length\nImprovement (%)\n4 -9.29 5 -1.46 6 2.72 8 13.98\n10 18.48 12 19.71 14 22.08 16 22.42 18 23.54 20 24.45 22 26.03 25 26.46 30 26.88 35 29.04 40 29.79 45 30.07 50 30.14\nTable 2. Relative improvement achieved by using snakes in the BIBOX algorithm. Again, the improvement has been measured for several sizes of the puzzle ranging from (42 − 1) to (502 − 1) with 40 random instances per size. Relative improvement is significantly larger in the case of BIBOX algorithm than in Parberry’s algorithm.\nFigure 16. Illustration of the trend in the average improvement in the BIBOX algorithm. It can be observed that the relative improvement tends to stabilize around 30% as instances of the (n2 − 1)-puzzle are getting larger.\nPuzzle size (n)\nBIBOX. On the other hand, in large instances significant improvement over 30% can be achieved. Again, the worsening in small instances can be explained by inaccuracy of distance heuristic (7) as in small instances stronger interference between two relocated robots is more likely.\n6.2.3. Evaluation of Using Snakes in BIBOX Algorithm on CPFs over Bi-connected Graphs\nPromising results obtained in solving (\uD835\uDC5B2 − 1)-puzzle by snake-improved algorithms inspired us to evaluate snake-based version of the BIBOX algorithm on instances of CPF over more general bi-connected graphs that are structurally different from the puzzle.\nThis is motivated by the fact that the ear decomposition of the 4-connected grid, where (n2 − 1)-puzzle takes place, is quite special – it consists of ears having just one internal vertex in most case. Hence, it would be interesting to see how snake improvement behaves in BIBOX algorithm over bi-connected graphs with longer ears.\nIn addition to structurally different underlying graphs, we evaluated snake-based improvements over CPF instances in presence of various numbers of robots; that is, when multiple vacant vertices are available. Availability of multiple unoccupied vertices may affect snake formation and interference between two robots relocated jointly significantly. We expect the higher accuracy of the distance heuristic (7) in cases of with fewer robots (more vacant vertices) as there should be weaker interference between two relocated robots.\nA series of tests with CPFs over bi-connected graphs with various ear decompositions has been also done to evaluate benefits of snakes in situations structurally different from those in (\uD835\uDC5B2 − 1)-puzzle.\nSeveral random bi-connected graphs were constructed over which random CPF instances were generated. Random instances over fixed graph are obtained by generating random initial and goal configuration of robots. Results from the evaluation on CPFs over bi-connected graphs are shown in Figure 18.\nThe notation \uD835\uDC35\uD835\uDC56\uD835\uDC50\uD835\uDC5C\uD835\uDC5B\uD835\uDC5B\uD835\uDC52\uD835\uDC50\uD835\uDC61\uD835\uDC52\uD835\uDC51(\uD835\uDC50, \uD835\uDC52, \uD835\uDC5A) denotes random bi-connected graph with an ear decomposition where the initial cycle consists of \uD835\uDC50 vertices, the average number of internal vertices of ears is \uD835\uDC52, and the total number of ears is \uD835\uDC5A. Several bi-connected graphs containing approximately 90 vertices were used in the evaluation.\nRandom bi-connected graph is constructed by adding ears of random length (uniform distribution where \uD835\uDC52 is the mean) to randomly selected endpoints in the already constructed part of the graph. The construction process starts with the initial cycle of given size \uD835\uDC50 and terminates after the given number of vertices \uD835\uDC5A is exceeded.\nThe occupancy by robots in the tested instances grown from one robot up to as many robots so that there were only two unoccupied vertices in the graph (the standard BIBOX algorithm could be used).\nResults with the BIBOX algorithm over random bi-connected graphs indicate that the snake-based improvement is more efficient if there are more unoccupied vertices in the instance, which conforms to our expectation (though the scale of improvement was not expected). Up to 50% moves can be saved after employing snakes in CPF solving over biconnected graphs with approximately half of vertices occupied by robots and even larger proportion (up to 80%) of moves can be saved in sparsely occupied graphs.\nWorsening after using snakes appears more frequently than in the case of puzzle. It may appear especially with long ears in densely occupied graphs. This behavior can be explained by the fact that there are fewer alternative paths in bi-connected graphs with long ears and by the fact that robot can sometimes be influenced by other robots in densely occupied graph which can divert it from its direction. Due to absence of alternative paths the diversion cannot be repaired as easily as in the case of (\uD835\uDC5B2 − 1)-puzzle – in other words distance heuristic (7) tends to be quite inaccurate in such cases.\n6.3. Experimental Evaluation of Snakes in the PUSH-and-SWAP Algorithm\nThe last of algorithms included in our testing and snake-based improvements is PUSHand-SWAP. The algorithm is fundamentally different from other two algorithms in its nonlocal behavior. Let us recall that when the Swap or the Twin-Swap operations are about to be executed to exchange a pair or a triple of robots respectively, a vertex with enough neighbors is searched where the exchange can be conducted. Such a vertex with enough neighbors may be potentially located far from the current occurrence the pair or the triple of robots (especially in the case of bi-connected graphs with long ears). Hence, these operations may take place over a significant part of the environment while many robots can be affected.\nAlmost the same set of testing instances of the puzzle has been used for the PUSH-andSWAP algorithm as in the previous tests. The algorithms however needs at least two unoccupied vertices and in its snake-based improved variant at least three unoccupied vertices are needed. Hence instead of solving the (\uD835\uDC5B2 − 1)-puzzle the (\uD835\uDC5B2 − 3)-puzzle has been solved to be able to make any comparison. The generation of instances of the (\uD835\uDC5B2 − 3)- puzzle differs from those for (\uD835\uDC5B2 − 1)-puzzle in not adding the last two pebbles.\nThe PUSH-and-SWAP algorithm is yet more general than BIBOX as it can solve CPF instances over arbitrary graph with at least two unoccupied vertices. However, in our comparison it was sufficient to be restricted on bi-connected graph tests where we used the same set of instances as in the case of the BIBOX algorithm with omitting instances containing only two unoccupied vertices.\nThe known problematic behavior of the PUSH-and-SWAP algorithm described in [42, 43] due to which the Rotate operation has been introduced does not occur in our testing scenarios.\n6.3.1. Competitive Comparison of the PUSH-and-SWAP Algorithm with Snake Improvement\nAn important parameter of the PUSH-and-SWAP algorithm is the linear ordering of vertices/robots, which is followed when robots are placed one by one to their goal positions. Since the snake-improvement is sensitive to locality as indicated by the previous experiments and by additional experiments conducted during the development, we used ordering of robots that preserves locality in the environment. That is, robots that are close to each other in the ordering should be close to each other in the graph. Such an ordering can be obtained by the breadth first search.\nThe comparison of the number of moves generated by the PUSH-and-SWAP algorithm and its snake improvement on (\uD835\uDC5B2 − 3)-puzzle instances is shown in Figure 19. It can be clearly observed that the improvement obtained by snakes is small in comparison with the size of the original solution though in absolute terms the many moves are saved. Although the absolute improvement grows for growing size of the puzzle instances, the improvement growth is not stable.\nFurther investigation of the relative solution improvement achieved by using snakes is presented in Figure 20 and Table 3. The relative improvement is between 3% to 10% and most frequently around 6%, which renders the PUSH-and-SWAP algorithm to be the worst candidate for the snake improvement among the tested three algorithms for the puzzle instances. Moreover, the relative improvement is unstable for growing size of the instance. That is, having bigger instance does not necessarily imply larger relative improvement of the solution. There is also no sign of convergence of the relative improvement for growing puzzle instances.\n6.3.2. PUSH-and-SWAP Algorithm on Individual Puzzle Instances\nThe hypothesis explaining the unstable relative improvements in the solutions is that local improvement – that is, the joint relocation of a pair of robots – may lead to a global worsening of the solution. This is quite likely in the case of PUSH-and-SWAP algorithm since the relocation of a pair of robots often requires extensive swap of a triple of robots (TwinSwap operation) which affects many other robots except the swapped triple and makes it hardly predictable if the local improvement propagates to the global quality of the solution.\nThe behavior of the snake improvement on individual puzzle instances is presented in Figure 21. As in the previous tests, we evaluated the algorithm and its snake improvement on 40 random instances generated for each size of the puzzle – 4×4, 16×16, 30×30, and 50×50. The instances in the collection of 40 instances for each size of the puzzle are sorted according to the growing number of moves generated by the original PUSH-and-SWAP.\nResults confirm the hypothesis that the local improvement obtained by using snakes often leads to the worsening of the size of the overall solution. Worsening appears more frequently when original PUSH-and-SWAP generates relatively small solution.\n6.3.3. Evaluation of Using Snakes in the PUSH-and-SWAP Algorithm on CPFs over Bi-connected Graphs\nFinally, we made experimental evaluation of the PUSH-and-SWAP algorithm on random bi-connected graphs. Again, the same instances have been used as for other two algorithms. Results for random bi-connected graphs are presented in Figure 22.\nResults indicate again relatively unstable improvements between 5% and 10% by using snakes in the PUSH-and-SWAP algorithm. However, worsening by up to 10% appears frequently as well. It is observable that the relative improvement becomes better in instances with longer ears in the ear decomposition while in instance with short ears significant worsening by more than 10% appears frequently.\nThe slightly better behavior for longer ears can be explained by the cheaper relocation of a pair of robots jointly along long ears than their separate relocation. When the swapping is needed during the relocation of a pair or triple of robots, the affected part of the graph\n-2\n0\n2\n4\n6\n8\n10\n12\n0 10 20 30 40 50\nR el\nat iv\ne im\np ro\nve m\nen t\n(p er\nce n\nts )\nRelative Improvement in PUSH-and-SWAP\nRelative Improvement\nin PUSH-and-SWAP Algorithm\n\uD835\uDC8F Length\nImprovement (%)\n4 3,31 5 4,42 6 -0,27 8 6,03\n10 5,94 12 3,81 14 3,17 16 4,74 18 5,44 20 5,85 22 4,36 25 8,10 30 10,75 35 6,02 40 9,90 45 8,78 50 5,61\nTable 3. Relative improvement achieved by using snakes in the PUSH-and-SWAP algorithm. Again, the same set of testing instances of the (\uD835\uDC5B2 − 3)-puzzle has been used. The improvement is smaller in the PUSH-and-SWAP algorithm than in other two tested algorithms.\nFigure 20. Illustration of the trend in the average improvement in the PUSH-and-SWAP algorithm. It can be observed, that the relative improvement is visibly unstable with respect to the increasing size of the instance.\nPuzzle size (n)\ntraversed during the Swap operation or Twin-Swap respectively by visiting a distant vertex with enough number of neighbors is not much different. Hence, both operations produce approximately the same number of moves while in the case of the separate relocation of the pair of agents all the moves needed to reach the distant vertex with enough neighbors where exchange of robots is done need to be executed twice. Thus the benefit of the joint relocation is more expectable with longer ears as the necessary vertex with many neighbors is more likely to be far from the current location of the pair or triple of robots being swapped.\n6.4. Runtime Measurement\nFinally, results regarding runtime are presented in Table 4. The average runtime for puzzles of size up to 50×50 are shown (in case of the PUSH-and-SWAP algorithm it is (\uD835\uDC5B2 − 3)- puzzle and (\uD835\uDC5B2 − 1)-puzzle in other cases).\nExpectably, snake-based improvement of Parberry’s algorithm is slower as it makes decisions that are more complex (in fact, it is running the original algorithm plus snake placement to compare if snake is locally better). Nevertheless, the slowdown is well acceptable.\nBoth algorithms – Parberry’s and its snake-based improvement – are capable of solving puzzles with solutions consisting of hundreds of thousands of moves almost immediately. Hence, it can be concluded that both algorithms scales up extremely well and they can be used in on-line applications (the scalability is indeed not because of the use of snakes – this is due to scalability of the original algorithm).\nThe absolute time in the case of the BIBOX algorithm is much worse since the algorithm works on general bi-connected graph while the Parberry’s algorithm works on fixed grid thus there is much less decisions in the Parberry’s algorithm.\nThe important result is the difference between the original and snake-improved version in case of the BIBOX algorithm. It is noticeable that although snakes require more complex computations these in fact should not increase the runtime significantly – the distance heuristic (7); that is, the distance between currently placed robot and the next robot to be placed can be calculated by looking into table containing all-pairs of shortest paths. The time needed for this pre-calculation is dominated by the runtime of the rest of the BIBOX algorithm theoretically as well as empirically. The performance in terms of the runtime is better when snakes are utilized because the algorithm does need to produce significantly fewer moves.\n1 All the tests with Parberry’s algorithm were run on a commodity PC with CPU Intel Core2 Duo 3.00 GHz and 2 GB of RAM under Windows XP 32-bit edition. The C++ code was compiled with Microsoft Visual Studio 2008 C++ compiler. Tests with the BIBOX algorithm and the PUSH-and-SWAP algorithm were run on an experimental server with the 4-core CPU Xeon 2.0GHz and 12GB RAM under Linux kernel 3.5.0-48.\nInteresting results were obtained for the PUSH-and-SWAP algorithm. Although PUSHand-SWAP generates several times longer solutions than BIBOX its original version is up to several times faster than BIBOX. However, the snake-based improvement within PUSHand-SWAP slows down the algorithm by at least one order of magnitude making it the slowest algorithm out of our portfolio. Marginal improvements obtainable by introducing snakes in PUSH-and-SWAP at relatively high computational cost make it an unpromising option.\n6.5. Summary of Experimental Evaluation\nThe conducted experimental evaluation clearly shows the hat snake-based reasoning integrated to the original algorithm of Parberry as well as to the BIBOX algorithm brings significant improvements in terms of the quality of generated solutions (defined as total number of moves). This claim is experimentally supported in both (\uD835\uDC5B2 − 1)-puzzle and yet more distinctively in cooperative path finding instances on bi-connected graphs. The integration of the snake-based reasoning in the PUSH-and-SWAP algorithm did not bring as promising results as in case of other two algorithms. Although the snake-based reasoning can slightly improve the solution generated by the PUSH-and-SWAP algorithm this is computationally costly and hence does not represent a good trade-off.\nExperiments support the claim that using snakes greedily (that is, if they are locally better) leads to global improvement of the solution even though the current configuration may be worsened sometimes from the global point of view in case of algorithms which exhibit local character of robot/pebble relocation – that is, algorithms of Parberry and BIBOX. As instances are getting larger, the improvement tends to stabilize itself between 8% and 9% in average in case of Parberry’s algorithm and around 30% in the case of BIBOX algorithm on (\uD835\uDC5B2 − 1)-puzzle. On larger instances – that is larger than 30×30 – possible fluctuations towards worsening the solution are eliminated, hence using snakes expectably leads to mentioned improvement on an individual instance.\nThe similar claim cannot be extended on the PUSH-and-SWAP algorithm as it has been shown by the conducted experimental evaluation. Local improvements by using the joint relocation of pairs of robots in the PUSH-and-SWAP algorithm often lead to global worsening of the solution. The explanation of this behavior is that the algorithm does not have a local behavior when robots are relocated – large parts of the graph may be affected during relocation of robots in the PUSH-and-SWAP algorithm, which makes it difficult to predict the impact of local improvement.\nRuntime measurements show that original Parberry’s algorithm and its snake-based improvement solve instances of tested sizes in less than 0.2\uD835\uDC60. Thus, it can be concluded that scalability is extremely good.\nSurprisingly, snake-based reasoning within the BIBOX algorithm improves solutions quite dramatically in CPFs on bi-connected graphs with longer ears in the decomposition and fewer robots in the graph. In such cases, snakes help the BIBOX algorithm to reduce the size of the solution by up to 50% or even 80% in sparsely populated instances.\nIt is also an interesting result that the PUSH-and-SWAP algorithm generates up to 10 times more moves than BIBOX (despite PUSH-and-SWAP has two more free vertices) while BIBOX generates up to 3 times more moves than the Parberry’s algorithm on tested puzzle instances."
    }, {
      "heading" : "7. Conclusions and Future Work",
      "text" : "We have presented an improvement to the polynomial-time algorithm for solving the (\uD835\uDC5B2 − 1)-puzzle in an on-line mode sub-optimally. The improvement is based on an idea to move pebbles jointly in groups called snakes, which was supposed to reduce the total number of moves. The experimental evaluation eventually confirmed this claim and showed that the new algorithm outperforms the original algorithm of Parberry [13] by 8% to 9% in terms of the average length of the solution. Theoretical upper bounds on the worst-case length of the solution are also better for the new algorithm as we have shown.\nRegarding the runtime, the new algorithm is marginally slower due to its more complex computations, however this is acceptable for any real-life application as the runtime is linear in the number of produced moves (approximately 106 moves can be produced per second).\nPromising results with snake-based joint pebble moving in (\uD835\uDC5B2 − 1)-puzzle led us to the idea to try to integrate snake-based movement into methods for solving the problem of cooperative path-finding (CPF) of which the (\uD835\uDC5B2 − 1)-puzzle is a special case. We have integrated snake reasoning into the BIBOX algorithm [33] and into the PUSH-and-SWAP algorithm. Both algorithms operate in a similar way to the algorithm of Parberry (that is, robots are placed one by one and after the robot is placed it does not move any more or is restricted to move).\nImprovements gained after integrating snake-based reasoning into BIBOX algorithm were even more significant than in case of Parberry’s algorithm. Up to 30% improvement was reached in solving (\uD835\uDC5B2 − 1)-puzzle with algorithm BIBOX and up to 50% improvement has been reached in CPFs over bi-connected graphs with long ears and multiple unoccupied vertices. Moreover, the improvement in CPFs on bi-connected graphs has the growing tendency as the number of unoccupied vertices increases.\nSnake based joint relocation of robots in the PUSH-and-SWAP algorithm improved solutions by 5% to 8% - the least of all the tested algorithms. Moreover, the improvement in PUSH-and-SWAP is unstable. That is, unlike in other two algorithms the absolute improvement (the number of saved moves with respect to the original version of the algorithm) does not grow steadily with respect to the growing size of instances.\nThe better behavior of the snake-based joint relocation of robots/pebbles is expectable in algorithms where relocation of a robot/pebble does not affect too many vertices of the underlying graph – the case of Parberry and BIBOX. On the other hand, the relocation of a robot in PUSH-and-SWAP algorithm may affect large portion of the underlying graph as\nsuitable vertex with enough neighbors need to be reached many times which may significantly distort local improvements of the snake based relocation in the global outcome.\nIt will be interesting for future work to add more measures for reducing the total number of moves towards the optimum. Choosing a more promising local rearrangement among several options can be easily parallelized.\nWe are also interested in generalized variants of the (\uD835\uDC5B2 − 1)-puzzle where there is more than one vacant position. These variants are known as the (\uD835\uDC5B2 − \uD835\uDC58)-puzzle with \uD835\uDC58 > 1 [29]. Although it seems that obtaining optimal solutions remains hard in this case, multiple vacant positions can be used to rearrange pebbles more efficiently in the sub-optimal approach.\nIt seems that adapting the BIBOX algorithm for snakes of length more than 2 is also possible. A robot can collect the snake along its relocation towards the ear connection vertex. Long snakes however bring significant technical difficulties as it may happen that the snake intersects itself – an opportunistic formation of a snake and eventual break-up of the snake when it is not longer maintainable is a possible option.\nAnother open question is how the snake-based approach could perform in the directed version of CPF [1, 45]. Unidirectional environment puts additional constraints on relocation and hence solution reduction using snakes may have greater effect.\nFinally, it is interesting for us to study techniques for optimal solving of this and related problems; especially the case with small unoccupied space (that is, with \uD835\uDC58 ≪ \uD835\uDC5B2). This is quite open area as today’s optimal solving techniques [25] can manage only small number of pebbles compared to the size of the unoccupied space."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This is supported by Charles University in Prague within the PRVOUK and UNCE projects. We would like gratefully thank reviewers for their comments, which significantly helped us to improve the paper and gave us valuable advice."
    }, {
      "heading" : "Appendix A – Analysis of the Average Case",
      "text" : "Regarding the average case analysis we will assume in accordance with [13] that every initial configuration of pebbles can occur with the same probability1. We will first show that algorithm of Parberry [13] produces 4\uD835\uDC5B3 − 1 2 \uD835\uDC5B2 + 3 2 \uD835\uDC5B − 70 moves in the average case. Then we will simulate this analysis also for our snake-based algorithm. Unfortunately, it seems not to be possible to express the average number of moves as any simple formula in the case of the snake-based algorithms. However, we can provide some arguments that the average solution length of the snake-based algorithm is strictly better than that of Parberry’s algorithm.\nBefore we start with proofs of main propositions, we will introduce several technical lemmas. Proofs of these lemmas are omitted since they are easy and rather technical (detailed proofs can be found in [12]).\nLemma 4. The average value of \uD835\uDF07\uD835\uDC5B((1,1); (\uD835\uDC65, \uD835\uDC66)) for \uD835\uDC65, \uD835\uDC66 ∈ {1,2, … , \uD835\uDC5B} (that is the average Manhattan distance from the position (1,1)) is \uD835\uDC5B − 1. \nLemma 5. The average value of \uD835\uDF07\uD835\uDC5B((1, \uD835\uDC58); (\uD835\uDC65, \uD835\uDC66)) for \uD835\uDC58, \uD835\uDC65, \uD835\uDC66 ∈ {1,2, … , \uD835\uDC5B} such that for \uD835\uDC65 > \uD835\uDC58 or for \uD835\uDC66 > 1 (that is, for a given \uD835\uDC58 we consider only (\uD835\uDC65, \uD835\uDC66) positions that follows the position (1, \uD835\uDC58) in the top-down/left-right direction) is at most \uD835\uDC5B − 1\n2 . \nThe similar result can be obtained for positions in the first column. But here the esti-\nmation of the Manhattan distance is lower – namely \uD835\uDC5B − 1.\nLemma 6. The number of moves necessary to move a pebble from a position (\uD835\uDC56, \uD835\uDC57) to a position (1, \uD835\uDC58) supposed that the position (1, \uD835\uDC58) is unoccupied is at most 6\uD835\uDF07\uD835\uDC5B((1, \uD835\uDC58); (\uD835\uDC56, \uD835\uDC57)) + 1. \n1 Results presented in this appendix were superseded by the recent works of Parberry [14, 15] where better average case bounds of have been shown. These results were not known at the time of submission of this paper hence we decided to move the average case analysis from the main text to the appendix.\nProposition 3 (Average-case Solution Length - Parberry). The average length of solutions to (\uD835\uDC5B2 − 1)-puzzle produced by Parberry’s algorithm is at most 4\uD835\uDC5B3 − 1 2 \uD835\uDC5B2 + 3 2 \uD835\uDC5B − 70. \nProof sketch. From the Lemma 5 and Lemma 6 we can obtain that the expected number of moves necessary to solve the first row of the puzzle is at most: \uD835\uDC5B ∙ (6 ∙ (\uD835\uDC5B − 1 2 ) + 1) = 6\uD835\uDC5B2 − 2\uD835\uDC5B. Similarly for the first column: (\uD835\uDC5B − 1) ∙ (6 ∙ (\uD835\uDC5B − 1) + 1) = 6\uD835\uDC5B2 − 11\uD835\uDC5B + 5. Altogether the upper estimation of the number of moves to solve the first row and the first column is: 12\uD835\uDC5B2 − 13\uD835\uDC5B + 5.\nSuppose that the position (1,1) is unoccupied and let us denote \uD835\uDC46(\uD835\uDC5B) the estimation of the number of moves to solve the entire (\uD835\uDC5B2 − 1)-puzzle. Then it holds that: \uD835\uDC46(\uD835\uDC5B) = \uD835\uDC46(\uD835\uDC5B − 1) + 12\uD835\uDC5B2 − 13\uD835\uDC5B + 5, where \uD835\uDC46(3) = 34 (calculated as the upper for average length of optimal solutions). After solving the recurrent equation we obtain that: \uD835\uDC46(\uD835\uDC5B) = 4\uD835\uDC5B3 − 1 2 \uD835\uDC5B2 + 3 2 \uD835\uDC5B − 70. \nNotice, that this is a new theoretical result for the Parberry’s algorithm (in [13] only the\nworst case upper bound of 5\uD835\uDC5B3 + \uD835\uDCAA(\uD835\uDC5B2) and lower bounds are given).\nObservation 1 (Average-case Solution Length – Snake-based). The average length of solutions to (\uD835\uDC5B2 − 1)-puzzle generated by the Snake-based algorithm is strictly lower than that of solutions generated by the algorithm of Parberry. \nSketch of proof. The average length of the solution in random instances in the case of the snake-based algorithm can be expressed as the average number of moves necessary to place first two pebbles (top-down/left-right direction) plus the average solution length to instances where first two pebbles are already placed. Notice that the average number of moves to place the first two pebbles is strictly lower in the snake-based algorithm. Hence, if we unfold the recurrence expression for the average length of the solution entirely the result will be strictly smaller than the average length of solutions of Parberry’s algorithm. \nAlthough we don’t provide any explicit formula for the average length of solutions generated by our snake-base algorithm we know that it is strictly less than 4\uD835\uDC5B3 − 1 2 \uD835\uDC5B2 + 3 2 \uD835\uDC5B − 70."
    }, {
      "heading" : "Appendix B – BIBOX Algorithm with Snakes",
      "text" : "A commented pseudo-code of the BIBOX algorithm enhanced with snakes is given in this appendix. The original BIBOX algorithm arranges robots into ears while the problem inductively reduces on a smaller bi-connected graph whenever robots are arranged into the ear – robots in such an ear do not move any more. The algorithm is listed below as Algorithm 1.\nThe algorithm uses several auxiliary functions to solve subtasks. Pseudo-code of aux-\niliary functions is given in [33] – here they are only briefly described.\nThe algorithm starts with constructing ear decomposition (line 1). It is assumed that a cycle denoted as \uD835\uDC36(\uD835\uDC3F\uD835\uDC56) is associated with each ear; \uD835\uDC36(\uD835\uDC3F\uD835\uDC56) can be constructed by adding a path connecting ear’s connection vertices \uD835\uDC62 and \uD835\uDC63. Then the goal configuration of robots is transformed so that vacant vertices are eventually located in the initial cycle of the decomposition (line 2). The algorithm solves this modified instance afterwards. The solution of the original instance is obtained by relocating vacant vertices from initial cycle to their original goal locations (line 8). This instance transformation is carried out by auxiliary functions Transform-Goal and Finish-Solution that relocates vacant vertices along two vertex disjoint paths. The main loop (lines 4-6) processes ear from the last one towards the initial cycle. Robots are arranged by another auxiliary procedure Solve-Original-Cycle in the original cycle (line 7).\nIndividual ears are processed by the procedure Solve-Regular-Ear. It arranges robots into the ear in stack like manner. First, unoccupied vertices are moved out of the processed ear as they will be needed there (lines 10-14). Then robots, whose goal positions are in the ear, are processed. Two cases are distinguished depending on whether the processed robot is located outside the ear (lines 17-25) or within the ear (lines 27-51).\nThe easier case is with robot outside – in this case, the robot is moved to the connection vertex \uD835\uDC62 using either Move-Robot or Move-Robot-Snake auxiliary procedure. The other connection vertex \uD835\uDC63 is vacated by Make-Unoccupied procedure. If some vertex is free on the cycle \uD835\uDC36(\uD835\uDC3F\uD835\uDC50) then the cycle can be rotated which is done once in the positive direction by Rotate-Cycle+ function. The rotation places the robot into the ear. Throughout the relocation of robots vertex locking is used (functions Lock and Unlock) to fix an robot in certain vertex while other robots or vacant vertex are relocated.\nA more difficult case appears if the robot is inside the handle. In such case, the robot must be rotated out of the handle to the rest of the graph (lines 30-32). The number of positive rotations to get the robot out of the handle is counted (lines 27-32). The counted number of rotations is used to restore the situation by the corresponding number of negative rotations (lines 42 -44). At this point, the situation is the same as in the previous case. Thus, the robot is stacked into the handle in the same way.\nThe difference of BIBOX algorithm with snakes from the original BIBOX algorithm consists in adding Move-Robot-Snake procedure. When robots are relocated towards the currently processed ear, the snake based reasoning considers two consecutive robots whenever possible (lines 18-19 and 35-36). That is, while in the original algorithm, a single robot has been always relocated, in the snake version, the next to be relocated robot is considered as well. If both consecutive robots are close enough to each other they are relocated towards their target ear together jointly (the process of the joint relocation is implemented within Move-Robot-Snake procedure).\nAlgorithm 3. The BIBOX with snakes algorithm. The algorithm solves cooperative path-finding problem (CPF) over bi-connected graphs consisting of a cycle and at least one ear with two unoccupied vertices. The algorithm proceeds inductively according to the ear decomposition. The two unoccupied vertices are necessary for arranging robots within the initial cycle in the rest of the graph only one unoccupied vertex is needed. The pseudo-code is built around several higher-level operations. The modification from the original version consists in placing robots into an ear where two consecutive robots are considered at once. If consecutive robots are close enough to each other they are relocated towards the ear in a snake like manner together.\n Lock(\uD835\uDC48) locks all the vertices from set \uD835\uDC48; each vertex is either locked or unlocked; an robot must not be moved out of the\nlocked vertex which is respected by other operations\n Unlock(\uD835\uDC48) unlocks all the vertices from set \uD835\uDC48  Make-Unoccupied(\uD835\uDC63) vacates vertex \uD835\uDC63 sensitively to locked vertices  Make-Unoccupied’(\uD835\uDC63) vacates vertex \uD835\uDC63 irrespective of locked vertices  Move-Robot(\uD835\uDC5F, \uD835\uDC63) moves robot \uD835\uDC5F from its current location to vertex \uD835\uDC63  Move-Robot-Snake(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC63) moves robots \uD835\uDC5F and \uD835\uDC60 from their current locations\ntowards \uD835\uDC63; that is \uD835\uDC5F is moved to \uD835\uDC63 and \uD835\uDC60 is moved together with \uD835\uDC60 in a snake-like manner if \uD835\uDC5F and \uD835\uDC60 are close enough initially (distG(\uD835\uDC63, \uD835\uDEFC(\uD835\uDC5F)) + distG(\uD835\uDEFC(\uD835\uDC5F), \uD835\uDEFC(\uD835\uDC60)) < distG(\uD835\uDC63, \uD835\uDEFC(\uD835\uDC5F)) + distG(\uD835\uDC63, \uD835\uDEFC(\uD835\uDC60)); that is, the total distance towards destination \uD835\uDC63 is smaller if robots go together than if they go one by one)\n Rotate-Cycle+(\uD835\uDC36) rotates cycle \uD835\uDC36 in the positive direction; a vacant vertex must be present in the cycle  Rotate-Cycle−(\uD835\uDC36) rotates cycle \uD835\uDC36 in the negative direction  Transform-Goal(\uD835\uDC3A, \uD835\uDC45, \uD835\uDEFC+) transforms goal configuration \uD835\uDEFC+ to a new configuration so\nthat finally unoccupied vertices are located in the initial cycle of the ear decomposition; two disjoint paths along which empty vertices are relocated are returned\n Finish-Solution(\uD835\uDF11, \uD835\uDF12) transforms the configuration with two unoccupied vertices in the initial cycle to the original goal configuration; \uD835\uDF11 and \uD835\uDF12 are two disjoint paths along which empty vertices shifted  Solve-Original-Cycle arranges robots within the initial cycle of the ear decompo-\nsition to comply with the transformed goal configuration; two empty vertices are employed to arrange robots\nprocedure BIBOX-Snake-Solve(\uD835\uDC3A = (\uD835\uDC49, \uD835\uDC38), \uD835\uDC45, \uD835\uDEFC0, \uD835\uDEFC +)\n/* Top level function of the BIBOX algorithm with snakes; solves a given CPF. Parameters: \uD835\uDC3A - a graph modeling the environment, \uD835\uDC45 - a set of robots, \uD835\uDEFC0 - a initial configuration of robots, \uD835\uDEFC+ - a goal configuration of robots. */\n1: let \uD835\uDC9F = [\uD835\uDC360, \uD835\uDC3F1, \uD835\uDC3F2, … , \uD835\uDC3F\uD835\uDC58] be a ear decomposition of \uD835\uDC3A 2: (\uD835\uDEFC+, \uD835\uDF11, \uD835\uDF12) ← Transform-Goal(\uD835\uDC3A, \uD835\uDC45, \uD835\uDEFC+) 3: \uD835\uDEFC ← \uD835\uDEFC0 4: for \uD835\uDC50 = \uD835\uDC58, \uD835\uDC58 − 1, … ,1 do 5: if |\uD835\uDC3F\uD835\uDC50| > 2 then 6: Solve-Regular-Ear(\uD835\uDC50) 7: Solve-Original-Cycle() 8: Finish-Solution(\uD835\uDF11, \uD835\uDF12)\nprocedure Snake-Solve-Regular-Ear(\uD835\uDC50) /* Places robots which destinations are within a\near \uD835\uDC3F\uD835\uDC50; robots placed in the ear \uD835\uDC3F\uD835\uDC50 are finally locked so they cannot move any more.\nParameters: \uD835\uDC50 – index of a ear */ 9: let [\uD835\uDC62, \uD835\uDC641, \uD835\uDC642, … , \uD835\uDC64\uD835\uDC59 , \uD835\uDC63] = \uD835\uDC3F\uD835\uDC50 /* Both unoccupied vertices must be located\noutside the currently solved ear. */\n10: let \uD835\uDC65, \uD835\uDC67 ∈ \uD835\uDC49 ∖ ⋃ (\uD835\uDC3F\uD835\uDC57 \uD835\uDC58 \uD835\uDC50=\uD835\uDC57 ∖ {\uD835\uDC62, \uD835\uDC63}) such that \uD835\uDC65 ≠ \uD835\uDC67 11: Make-Unoccupied(\uD835\uDC65) 12: Lock({\uD835\uDC65}) 13: Make-Unoccupied(\uD835\uDC67) 14: Unlock({\uD835\uDC65}) 15: for \uD835\uDC56 = \uD835\uDC59, \uD835\uDC59 − 1, … ,1 do 16: Lock(\uD835\uDC3F\uD835\uDC50 ∖ {\uD835\uDC62, \uD835\uDC63}) /* An robot to be placed is outside the ear \uD835\uDC3F\uD835\uDC50. */ 17: if \uD835\uDEFC(\uD835\uDEFC+ −1(\uD835\uDC64\uD835\uDC56)) ∉ (\uD835\uDC3F\uD835\uDC50 ∖ {\uD835\uDC62, \uD835\uDC63}) then 18: if \uD835\uDC56 > 1 then 19: Move-Robot-Snake(\uD835\uDEFC+ −1(\uD835\uDC64\uD835\uDC56), \uD835\uDEFC+ −1(\uD835\uDC64\uD835\uDC56−1), \uD835\uDC62) 20: else 21: Move-Robot(\uD835\uDEFC+ −1(\uD835\uDC64\uD835\uDC56), \uD835\uDC62) 22: Lock({\uD835\uDC62}) 23: Make-Unoccupied(\uD835\uDC63) 24: Unlock(\uD835\uDC3F\uD835\uDC50) 25: Rotate-Cycle+(\uD835\uDC36(\uD835\uDC3F\uD835\uDC50)) /* An robot to be placed is inside the ear \uD835\uDC3F\uD835\uDC50. */ 26: else 27: Make-Unoccupied(\uD835\uDC62) 28: Unlock(\uD835\uDC3F\uD835\uDC50) 29: \uD835\uDF0C ← 0 30: while \uD835\uDEFC(\uD835\uDEFC+\n−1(\uD835\uDC64\uD835\uDC56)) ≠ \uD835\uDC63 do 31: Rotate-Cycle+(\uD835\uDC36(\uD835\uDC3F\uD835\uDC50)) 32: \uD835\uDF0C ← \uD835\uDF0C + 1 33: Lock(\uD835\uDC3F\uD835\uDC50 ∖ {\uD835\uDC62, \uD835\uDC63}) 34: let \uD835\uDC66 ∈ \uD835\uDC49 ∖ (⋃ (\uD835\uDC3F\uD835\uDC57 ∖ {\uD835\uDC62, \uD835\uDC63}) ∪ \uD835\uDC51 \uD835\uDC57=\uD835\uDC50+1 \uD835\uDC36(\uD835\uDC3F\uD835\uDC57)) 35: if \uD835\uDC56 > 1 then 36: Move-Robot-Snake(\uD835\uDEFC+ −1(\uD835\uDC64\uD835\uDC56), \uD835\uDEFC+ −1(\uD835\uDC64\uD835\uDC56−1), \uD835\uDC66) 37: else 38: Move-Robot (\uD835\uDEFC+ −1(\uD835\uDC64\uD835\uDC56), \uD835\uDC66) 39: Lock ({\uD835\uDC66}) 40: Make-Unoccupied (\uD835\uDC62) 41: Unlock (\uD835\uDC3F\uD835\uDC50) 42: while \uD835\uDF0C > 0 do 43: Rotate-Cycle(\uD835\uDC36(\uD835\uDC3F\uD835\uDC50)) 44: \uD835\uDF0C ← \uD835\uDF0C − 1 45: Unlock ({\uD835\uDC66}) 46: Lock (\uD835\uDC3F\uD835\uDC50 ∖ {\uD835\uDC62, \uD835\uDC63}) 47: Move-Robot (\uD835\uDEFC+ −1(\uD835\uDC64\uD835\uDC56), \uD835\uDC62)\nmodification w.r.t. original BIBOX\nmodification w.r.t. original BIBOX\n48: Lock ({\uD835\uDC62}) 49: Make-Unoccupied (\uD835\uDC63) 50: Unlock (\uD835\uDC3F\uD835\uDC50) 51: Rotate-Cycle+(\uD835\uDC36(\uD835\uDC3F\uD835\uDC50)) 52: Lock (\uD835\uDC3F\uD835\uDC50 ∖ {\uD835\uDC62, \uD835\uDC63})\nAppendix C – Simplified PUSH-and-SWAP Algorithm Enhanced with Snakes\nA commented pseudo-code of the simplified PUSH-and-SWAP algorithm enhanced with snakes is given in this appendix. The original PUSH-and-SWAP algorithm [11] is designed to solve CPF over arbitrary graph containing at least two unoccupied vertices. Our simplification omits several special cases that ensure completeness of the algorithm over arbitrary graphs. These cases did not occur in the puzzle and random bi-connected graph instances used in the presented experimental evaluation. Moreover, the simplification also has no impact on the joint relocation of robots in pairs.\nThough the PUSH-and-SWAP algorithm has been further corrected in [42, 43] (the corrected algorithm is called PUSH-and-ROTATE) we follow the original one as the cases treated in the corrected version are omitted in our simplification.\nThe algorithm distinguishes vertices between locked and unlocked ones similarly as in the case of the BIBOX algorithm. Another similarity with the BIBOX algorithm is that robots are placed to their destinations one by one. Whenever a robot reaches its goal vertex the goal vertex becomes locked. Robots can freely move in and out unlocked vertices but robots in locked vertices cannot move regularly; they can be temporarily moved out of their goal vertex provided they return.\nThe snake enhancement of the PUSH-and-SWAP algorithm presented here adds two major operations Twin-Push and Twin-Swap and several supporting operations. These operations represent an analogy to Push and Swap operations of the original algorithm. The two new operations move a pair of robots jointly towards the goal of the former one. In addition to Twin-Push and Twin-Swap, operations Twin-Multipush, Twin-Exchange, and few others are introduced.\nThe main loop of the simplified algorithm (lines 2-8) places robots one by one to their goals. If more than one robot is remaining then relocation of a pair of consecutive robots jointly is chosen (3-5) otherwise the last robot is placed as single. The placement of two consecutive robots – say robots \uD835\uDC5F and \uD835\uDC60 – first decides if it is better to first move \uD835\uDC60 next to \uD835\uDC5F (line 14) or vice versa (line 20) or not use the joint relocation at all (line 13). Not using the joint relocation can be used as the third option. The decision in the presented pseudocode is based upon lengths of shortest paths between current positions of robots; however, it can be done according to other criteria. We used simulation to calculate the number of moves necessary for each of the two options in the actual C++ implementation used in experiments (this is the major reason why snake enhanced PUSH-and-SWAP consumes order of magnitude more time than the original version). The option that consumes fewer moves is finally chosen.\nAlgorithm 4. The simplified PUSH-and-SWAP with snakes algorithm. The algorithm solves cooperative path-finding problem (CPF) over arbitrary graphs with at least three unoccupied vertices. It is a simplified version of the original PUSH-and-SWAP; the simplification consists in omitting treatments of special cases that occur with general graphs. Hence, the presented algorithm is incomplete for arbitrary graphs. The simplification however does not affect the behavior of the snake improvement over tested puzzle and random bi-connected graph instances.\n Lock(\uD835\uDC48) locks all the vertices from set \uD835\uDC48; each vertex is either locked or unlocked; a robot can be moved out of the locked\nvertex if it is later returned back (a case of Swap and TwinSwap operations)\n Unlock(\uD835\uDC48) unlocks all the vertices from set \uD835\uDC48  Move-Robot(\uD835\uDC5F, \uD835\uDC63) moves robot \uD835\uDC5F from its current location to vertex \uD835\uDC63  Make-Unoccupied(\uD835\uDC63) vacates vertex \uD835\uDC63 sensitively to locked vertices  Make-Unoccupied(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61, \uD835\uDC63) vacates vertex \uD835\uDC63 irrespective to locked vertices but preserving positions of robots \uD835\uDC5F, \uD835\uDC60, and \uD835\uDC61  Relocate-Robot(\uD835\uDC5F, \uD835\uDC63) relocates robot \uD835\uDC5F from its current location to \uD835\uDC63 and locks it\nthere; this function is implemented within the original algorithm – it uses Push and Swap basic operations\n Start-Undo() start recording of performed moves for later undoing them (execute reverse moves in the reverse order); saves\nthe current robot arrangement\n Stop-Undo() stops recording of performed  Execute-Undo() undoes the sequence of recorded moves;\nclears the recorded undo sequence\n Cancel-Undo() clears the recorded undo sequence and restores robot arrangement saved at the beginning of undo recording  Twin-Exchange(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61, \uD835\uDC63) exchanges a triple of robots \uD835\uDC5F, \uD835\uDC60, and \uD835\uDC61 at vertex \uD835\uDC63 having at least 4 neighbors  Make-Unoccupied-3(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61, \uD835\uDC63) vacates 3 neighbors of vertex \uD835\uDC63 while positions of robots \uD835\uDC5F, \uD835\uDC60, \uD835\uDC61 with \uD835\uDC61 standing at \uD835\uDC63 is preserved\nfunction PUSH-and-SWAP-Snake-Solve(\uD835\uDC3A = (\uD835\uDC49, \uD835\uDC38), \uD835\uDC45, \uD835\uDEFC0, \uD835\uDEFC +): boolean\n/* Top level function of the PUSH-and-SWAP algorithm with snakes; solves a given cooperative path-finding problem. Returns \uD835\uDC47\uD835\uDC45\uD835\uDC48\uD835\uDC38 if succeeds or \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 in case of failure (untreated case). Parameters: \uD835\uDC3A - a graph modeling the environment,\n\uD835\uDC45 - a set of robots, \uD835\uDEFC0 - a initial configuration of robots, \uD835\uDEFC+ - a goal configuration of robots. */\n1: let \uD835\uDC45 = [\uD835\uDC5F1, \uD835\uDC5F2, … , \uD835\uDC5F\uD835\uDF07] some ordering of robots 2: for \uD835\uDC56 = 1,2, … , \uD835\uDF07 do 3: if \uD835\uDC56 < \uD835\uDF07 − 1 then 4: if not Relocate-Twin-Robots(\uD835\uDC5F\uD835\uDC56 , \uD835\uDC5F\uD835\uDC56+1, \uD835\uDEFC+(\uD835\uDC5F\uD835\uDC56)) then 5: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 6: else 7: if not Relocate-Robot (\uD835\uDC5F\uD835\uDC56) then 8: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 9: return \uD835\uDC47\uD835\uDC45\uD835\uDC48\uD835\uDC38\nmodification w.r.t. original PUSH-and-SWAP\nfunction Relocate-Twin-Robots(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC63): boolean /* Relocates a pair of robots jointly towards the goal vertex of the first of them.\nReturns \uD835\uDC47\uD835\uDC45\uD835\uDC48\uD835\uDC38 if succeeds or \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 in case of failure (no vertex of degree at least 4). Parameters: \uD835\uDC5F, \uD835\uDC60 - a pair of robots,\n\uD835\uDC63 – goal vertex of \uD835\uDC5F. */ 10: let \uD835\uDC62 ∈ \uD835\uDC49 be a neighbor of \uD835\uDEFC(\uD835\uDC5F) 11: let \uD835\uDC64 ∈ \uD835\uDC49 be a neighbor of \uD835\uDEFC(\uD835\uDC60) 12: \uD835\uDC51\uD835\uDC61\uD835\uDC4E\uD835\uDC5B\uD835\uDC51\uD835\uDC52\uD835\uDC5A ← min{distG(\uD835\uDEFC(\uD835\uDC60), \uD835\uDC62) + distG(\uD835\uDEFC(\uD835\uDC5F), \uD835\uDC63), distG(\uD835\uDEFC(\uD835\uDC5F), \uD835\uDC64) + distG(\uD835\uDEFC(\uD835\uDC60), \uD835\uDC63)} 12: \uD835\uDC51\uD835\uDC60\uD835\uDC52\uD835\uDC5D\uD835\uDC4E\uD835\uDC5F\uD835\uDC4E\uD835\uDC61\uD835\uDC52 ← min {distG(\uD835\uDEFC(\uD835\uDC5F), \uD835\uDEFC +(\uD835\uDC5F)) + distG(\uD835\uDEFC(\uD835\uDC60), \uD835\uDEFC +(\uD835\uDC60))} 13: if \uD835\uDC51\uD835\uDC61\uD835\uDC4E\uD835\uDC5B\uD835\uDC51\uD835\uDC52\uD835\uDC5A < \uD835\uDC51\uD835\uDC60\uD835\uDC52\uD835\uDC5D\uD835\uDC4E\uD835\uDC5F\uD835\uDC4E\uD835\uDC61\uD835\uDC52 then 14: if distG(\uD835\uDEFC(\uD835\uDC60), \uD835\uDC62) + distG(\uD835\uDEFC(\uD835\uDC5F), \uD835\uDC63) < distG(\uD835\uDEFC(\uD835\uDC5F), \uD835\uDC64) + distG(\uD835\uDEFC(\uD835\uDC60), \uD835\uDC63) then /* It seems to be better to move \uD835\uDC60 next to \uD835\uDC5F and then move together towards \uD835\uDC63. */ 15: if Relocate-Robot(\uD835\uDC60, \uD835\uDC62) then 16: let \uD835\uDF0B = [\uD835\uDC62 = \uD835\uDC5D1, \uD835\uDEFC(\uD835\uDC5F) = \uD835\uDC5D2, \uD835\uDC5D3, … , \uD835\uDC5D\uD835\uDC58 = \uD835\uDC63] be the shortest 17: path connecting a positions of \uD835\uDC5F and \uD835\uDC60 with \uD835\uDC63 18: else 19: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 20: else /* It seems to be better to move \uD835\uDC5F next to \uD835\uDC60 and then move together towards \uD835\uDC63. */ 21: if Relocate-Robot(\uD835\uDC5F, \uD835\uDC64) then 22: let \uD835\uDF0B = [\uD835\uDEFC(\uD835\uDC60) = \uD835\uDC5D1, \uD835\uDC64 = \uD835\uDC5D2, \uD835\uDC5D3, … , \uD835\uDC5D\uD835\uDC58 = \uD835\uDC63] be the shortest 23: path connecting a positions of \uD835\uDC5F and \uD835\uDC60 with \uD835\uDC63 24: else 25: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 26: for \uD835\uDC56 = 1,2, … , \uD835\uDC58 − 2 do 27: if not Twin-Push(\uD835\uDC5D\uD835\uDC56 , \uD835\uDC5D\uD835\uDC56+1, \uD835\uDC5D\uD835\uDC56+2) then 28: if not Twin-Swap(\uD835\uDC5D\uD835\uDC56 , \uD835\uDC5D\uD835\uDC56+1, \uD835\uDC5D\uD835\uDC56+2) then 29: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 30: if not Relocate-Robot(\uD835\uDC60, \uD835\uDEFC+(\uD835\uDC60)) then 31: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 32: else 33: if not Relocate-Robot(\uD835\uDC5F, \uD835\uDEFC+(\uD835\uDC5F)) then 34: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 35: if not Relocate-Robot(\uD835\uDC60, \uD835\uDEFC+(\uD835\uDC60)) then 36: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 37: return \uD835\uDC47\uD835\uDC45\uD835\uDC48\uD835\uDC38\nfunction Twin-Push(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC63): boolean 38: if \uD835\uDEFC−1(\uD835\uDC63) ≠⊥ then 39: Lock({\uD835\uDEFC(\uD835\uDC5F), \uD835\uDEFC(\uD835\uDC60)}) 40: if not Make-Unoccupied(\uD835\uDC63) then 41: Unlock({\uD835\uDEFC(\uD835\uDC5F), \uD835\uDEFC(\uD835\uDC60)}) 42: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 43: Unlock({\uD835\uDEFC(\uD835\uDC5F), \uD835\uDEFC(\uD835\uDC60)}) 44: Move-Robot(\uD835\uDC5F, \uD835\uDC63) 45: Move-Robot(\uD835\uDC60, \uD835\uDC62)\nfunction Twin-Swap(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC63): boolean 46: \uD835\uDC47 ← {\uD835\uDC62 ∈ \uD835\uDC49|degG(\uD835\uDC62) ≥ 4} 47: for each \uD835\uDC62 ∈ \uD835\uDC47 do 48: Start-Undo() 49: \uD835\uDC61 ← \uD835\uDEFC−1(\uD835\uDC63) 50: if Twin-Multipush(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61, \uD835\uDC62) then 51: if not Make-Unoccupied-3(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61, \uD835\uDC62) then 52: Cancel-Undo() 53: continue 54: Stop-Undo() 55: Twin-Exchange(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61, \uD835\uDC62) 56: Execute-Undo() 57: return \uD835\uDC47\uD835\uDC45\uD835\uDC48\uD835\uDC38 58: else 59: Cancel-Undo() 60: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38\nfunction Twin-Multipush(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61, \uD835\uDC63): boolean 61: let \uD835\uDF0B = [\uD835\uDEFC(\uD835\uDC5F) = \uD835\uDC5D1, \uD835\uDEFC(\uD835\uDC60) = \uD835\uDC5D2, \uD835\uDEFC(\uD835\uDC61) = \uD835\uDC5D3, … , \uD835\uDC5D\uD835\uDC58 = \uD835\uDC63] be the shortest 62: path connecting a positions of \uD835\uDC5F, \uD835\uDC60, and \uD835\uDC61 with \uD835\uDC62 63: for each \uD835\uDC56 = 1,2, … , \uD835\uDC58 − 3 do 64: if not Make-Unoccupied(\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61, \uD835\uDC5D\uD835\uDC56+3) then 65: return \uD835\uDC39\uD835\uDC34\uD835\uDC3F\uD835\uDC46\uD835\uDC38 66: Move-Robot(\uD835\uDC61, \uD835\uDC5D\uD835\uDC56+3) 67: Move-Robot(\uD835\uDC5F, \uD835\uDC5D\uD835\uDC56+2) 68: Move-Robot(\uD835\uDC60, \uD835\uDC5D\uD835\uDC56+1) 69: return \uD835\uDC47\uD835\uDC45\uD835\uDC48\uD835\uDC38\nHaving the consecutive robots \uD835\uDC5F and \uD835\uDC60 next to each other they are moved jointly towards the goal of the former robot \uD835\uDC5F (lines 24-27). If robots are ordered topologically according to their goals – that is, robots that are close to each other in the ordering have their goal close to each other in the graph – the later robot \uD835\uDC60 should appear close to its goal after the relocation of the pair. If the later robot is not in its goal after the joint relocation, the final single robot relocation corrects this (lines 28-29). It is optimistically assumed that final single robot relocation does not produce too many moves thanks to chosen ordering of robots.\nThe joint relocation of the pair relies on Twin-Push and Twin-Swap operations. After finding a path that connects the current occurrence of the pair of robots with the goal of the former one, the pair of robots is moved along this path. It is assumed that robot \uD835\uDC5F is the leader of the snake followed by robot \uD835\uDC60.\nThe Twin-Push operation is applicable if a vertex on the path in front of the leading robot \uD835\uDC5F can be freed by moving robots in not yet locked vertices (line 40). After vacating the vertex in front of \uD835\uDC5F, the pair is moved one step forward. If the operation Twin-Push fails, that is, if the next vertex on the path is occupied and cannot be freed by moving robots in unlocked vertices, then Twin-Swap operation is applied.\nAssume that robot \uD835\uDC61 resides in the next vertex on the path so it is the task to jump with \uD835\uDC5F and \uD835\uDC60 over \uD835\uDC61. This can be done by finding a vertex with at least 4 neighbors \uD835\uDC63 to which the triple is moved by the Twin-Multipush auxiliary operation (line 50) and where the order of the three robot is changed from [\uD835\uDC61, \uD835\uDC5F, \uD835\uDC60] to [\uD835\uDC5F, \uD835\uDC60, \uD835\uDC61] (the change of the order is illustrated in Figure 11). The relocation of the triple of robots by Twin-Multipush to \uD835\uDC63 and subsequent freeing of the neighbors of \uD835\uDC63 by Make-Unoccupied-3 (line 44) to enable order change disregards vertex locking.\nHence, robots in locked vertices may move out of their goals. They are moved back to their goals by undoing all the moves (supported by auxiliary operations Start-Undo, StopUndo, Cancel-Undo, and Execute-Undo) that relocated the triple of robots to \uD835\uDC63 and vacated its neighbors (moves that caused the change of the ordering are not undone). Undoing the moves (lines 48-56) preceding the change of ordering of the triple results in the situation, in which order of the three robots is changed at their current position while all other robots reside in their positions as well.\nRegarding the ordering of vertices of degree at least 4 to make the Twin-Swap possible, the nearest such vertices to the triple being exchanged are tried first in our implementation. The same implementation is used within the Swap operation where a vertex of the degree at least 3 is being searched."
    } ],
    "references" : [ {
      "title" : "Centralized path planning for multiple robots: Optimal decoupling into sequential plans",
      "author" : [ "J. van den Berg", "J. Snoeyink", "M.C. Lin", "D. Manocha" ],
      "venue" : "Proceedings of Robotics: Science and Systems V, University of Washington,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2009
    }, {
      "title" : "Multi-Robot Path Finding on Bi-connected Directed Graphs",
      "author" : [ "A. Botea", "P. Surynek" ],
      "venue" : "Proceedings of the 29th AAAI Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2015
    }, {
      "title" : "ICBS: Improved Conflict-Based Search Algorithm for Multi-Agent Pathfinding",
      "author" : [ "E. Boyarski", "A. Felner", "R. Stern", "G. Sharon", "D. Tolpin", "O. Betzalel", "S.E. Shimony" ],
      "venue" : "Proceedings of the 24th International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2015
    }, {
      "title" : "Don't Split, Try To Work It Out: Bypassing Conflicts in Multi-Agent Pathfinding",
      "author" : [ "E. Boyarski", "A. Felner", "G. Sharon", "R. Stern" ],
      "venue" : "Proceedings of the Twenty-Fifth International Conference on Automated Planning and Scheduling (ICAPS",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "On Multiple Moving Objects",
      "author" : [ "M.A. Erdmann", "T. Lozano-Pérez" ],
      "venue" : "Algorithmica, Volume",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1987
    }, {
      "title" : "A General Formal Framework for Pathfinding Problems with Multiple Agents",
      "author" : [ "E. Erdem", "D.G. Kisa", "U. Öztok", "P. Schüller" ],
      "venue" : "Proceedings of the 27th AAAI Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2013
    }, {
      "title" : "Toward efficient trajectory planning: The path-velocity decomposition",
      "author" : [ "K. Kant", "S.W. Zucker" ],
      "venue" : "The International Journal of Robotics Research,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1986
    }, {
      "title" : "A Polynomial-Time Algorithm for NonOptimal Multi-Agent Pathfinding",
      "author" : [ "M.M. Khorshid", "R.C. Holte", "N.R. Sturtevant" ],
      "venue" : "Proceedings of the 4th Annual Symposium on Combinatorial Search (SOCS",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2011
    }, {
      "title" : "Finding Optimal Solutions to the 24-Puzzle",
      "author" : [ "R.E. Korf", "L.A. Taylor" ],
      "venue" : "Proceedings of the 13th National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1996
    }, {
      "title" : "Coordinating Pebble Motion on Graphs, the Diameter of Permutation Groups, and Applications",
      "author" : [ "D. Kornhauser", "G.L. Miller", "P.G. Spirakis" ],
      "venue" : "Proceedings of the 25th Annual Symposium on Foundations of Computer Science (FOCS",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1984
    }, {
      "title" : "Push and Swap: Fast Cooperative Path-Finding with Completeness Guarantees",
      "author" : [ "R. Luna", "K.E. Bekris" ],
      "venue" : "Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2011
    }, {
      "title" : "Sub-optimal Algorithms for Solving Sliding Puzzles",
      "author" : [ "P. Michalík" ],
      "venue" : "Master thesis, Charles University in Prague, Czech Republic,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    }, {
      "title" : "Solving the (n^2 - 1)-Puzzle with 8/3",
      "author" : [ "I. Parberry" ],
      "venue" : "Expected Moves. Algorithms,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2015
    }, {
      "title" : "Memory-Efficient Method for Fast Computation of Short 15-Puzzle Solutions",
      "author" : [ "I. Parberry" ],
      "venue" : "IEEE Transaction on Computational Intelligence and AI in Games, Volume",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2015
    }, {
      "title" : "Finding a Shortest Solution for the N×N Extension of the 15-PUZZLE Is Intractable",
      "author" : [ "D. Ratner", "M.K. Warmuth" ],
      "venue" : "Proceedings of the 5th National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1986
    }, {
      "title" : "Artificial Intelligence – A modern approach",
      "author" : [ "S. Russel", "P. Norvig" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2003
    }, {
      "title" : "Graph Decomposition for Efficient Multi-Robot Path Planning",
      "author" : [ "M.R.K. Ryan" ],
      "venue" : "Proceedings of the 20th International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2007
    }, {
      "title" : "Exploiting Subgraph Structure in Multi-Robot Path Planning",
      "author" : [ "M.R.K. Ryan" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR), Volume",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2008
    }, {
      "title" : "The increasing cost tree search for optimal multi-agent pathfinding",
      "author" : [ "G. Sharon", "R. Stern", "M. Goldenberg", "A. Felner" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2013
    }, {
      "title" : "Conflict-based search for optimal multiagent pathfinding",
      "author" : [ "G. Sharon", "R. Stern", "A. Felner", "N.R. Sturtevant" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2015
    }, {
      "title" : "Cooperative Pathfinding",
      "author" : [ "D. Silver" ],
      "venue" : "Proceedings of the 1st Artificial Intelligence and Interactive Digital Entertainment Conference (AIIDE",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2005
    }, {
      "title" : "Finding a Needle in an Exponential Haystack: Discrete RRT for Exploration of Implicit Roadmaps in Multi-robot Motion Planning. Algorithmic Foundations of Robotics XI - Selected Contributions of the 11th International Workshop on the  Improvements in Sub-optimal Solving of the (N^2-1)-Puzzle via Joint Relocation of Pebbles",
      "author" : [ "K. Solovey", "O. Salzman", "D. Halperin" ],
      "venue" : "Algorithmic Foundations of Robotics, Springer Tracts in Advanced Robotics",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2015
    }, {
      "title" : "Finding Optimal Solutions to Cooperative Pathfinding Problems",
      "author" : [ "T. Standley" ],
      "venue" : "Proceedings of the 24th AAAI Conference on Artificial Intelligence",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2010
    }, {
      "title" : "A Novel Approach to Path Planning for Multiple Robots in Bi-connected Graphs",
      "author" : [ "P. Surynek" ],
      "venue" : "Proceedings of the 2009 IEEE International Conference on Robotics and Automation (ICRA",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2009
    }, {
      "title" : "Towards Shorter Solutions for Problems of Path Planning for Multiple Robots in θ-like Environments",
      "author" : [ "P. Surynek" ],
      "venue" : "Proceedings of the 22nd International Florida Artificial Intelligence Research Society Conference (FLAIRS",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2009
    }, {
      "title" : "Making Solutions of Multi-robot Path Planning Problems Shorter Using Weak Transpositions and Critical Path Parallelism",
      "author" : [ "P. Surynek" ],
      "venue" : "Proceedings of the 2009 International Symposium on Combinatorial Search (SoCS",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2009
    }, {
      "title" : "An Application of Pebble Motion on Graphs to Abstract Multi-robot Path Planning",
      "author" : [ "P. Surynek" ],
      "venue" : "Proceedings of the 21st International Conference on Tools with Artificial Intelligence (ICTAI",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2009
    }, {
      "title" : "An Optimization Variant of Multi-Robot Path Planning is Intractable",
      "author" : [ "P. Surynek" ],
      "venue" : "Pro-ceedings of the 24th AAAI Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2010
    }, {
      "title" : "Redundancy Elimination in Highly Parallel Solutions of Motion Coordination Problems",
      "author" : [ "P. Surynek" ],
      "venue" : "Proceedings of the 23rd IEEE International Conference on Tools with Artificial Intelligence (ICTAI",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2011
    }, {
      "title" : "Compact Representations of Cooperative Path-Finding as SAT Based on Matchings in Bipartite Graphs",
      "author" : [ "P. Surynek" ],
      "venue" : "Proceedings of the 26th IEEE International Conference on Tools with Artificial Intelligence (ICTAI",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2014
    }, {
      "title" : "The Impact of a Bi-connected Graph Decomposition on Solving Cooperative Path-finding Problems",
      "author" : [ "P. Surynek", "P. Surynková", "M. Chromý" ],
      "venue" : "Fundamenta Informaticae, Volume 135,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2014
    }, {
      "title" : "Subdimensional expansion for multirobot path planning",
      "author" : [ "G. Wagner", "H. Choset" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2015
    }, {
      "title" : "Scalable Multi-Robot Pathfinding on Grid Maps with Tractability and Completeness Guarantees",
      "author" : [ "K.C. Wang", "A. Botea" ],
      "venue" : "Proceedings of ECAI 2010 - 19th European Conference on Artificial Intelligence (ECAI",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2010
    }, {
      "title" : "Solution Quality Improvements for Massively Multi-Robot Pathfinding",
      "author" : [ "K.C. Wang", "A. Botea", "P. Kilby" ],
      "venue" : "Proceedings of the 25th AAAI Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2011
    }, {
      "title" : "Introduction to Graph Theory",
      "author" : [ "D.B. West" ],
      "venue" : null,
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2000
    }, {
      "title" : "Maintaining bridge-connected and bi-connected components online",
      "author" : [ "J. Westbrook", "R.E. Tarjan" ],
      "venue" : "Algorithmica, Volume 7, Number",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 1992
    }, {
      "title" : "Push and rotate: cooperative multi-agent path planning",
      "author" : [ "B. de Wilde", "A. ter Mors", "C. Witteveen" ],
      "venue" : "Proceedings of the International conference on Autonomous Agents and Multi-Agent Systems (AAMAS",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2013
    }, {
      "title" : "Push and Rotate: a Complete Multi-robot Pathfinding Algorithm",
      "author" : [ "B. de Wilde", "A. ter Mors", "C. Witteveen" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR), Volume",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2014
    }, {
      "title" : "Graph Puzzles, Homotopy, and the Alternating Group",
      "author" : [ "R.M. Wilson" ],
      "venue" : "Journal of Combinatorial Theory, Ser. B",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 1974
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "The (n − 1)-puzzle [9, 10, 12, 13] represents one of the best-known examples of a socalled cooperative path-finding (CPF) [23, 33, 38, 42] problem.",
      "startOffset" : 19,
      "endOffset" : 34
    }, {
      "referenceID" : 9,
      "context" : "The (n − 1)-puzzle [9, 10, 12, 13] represents one of the best-known examples of a socalled cooperative path-finding (CPF) [23, 33, 38, 42] problem.",
      "startOffset" : 19,
      "endOffset" : 34
    }, {
      "referenceID" : 11,
      "context" : "The (n − 1)-puzzle [9, 10, 12, 13] represents one of the best-known examples of a socalled cooperative path-finding (CPF) [23, 33, 38, 42] problem.",
      "startOffset" : 19,
      "endOffset" : 34
    }, {
      "referenceID" : 20,
      "context" : "The (n − 1)-puzzle [9, 10, 12, 13] represents one of the best-known examples of a socalled cooperative path-finding (CPF) [23, 33, 38, 42] problem.",
      "startOffset" : 122,
      "endOffset" : 138
    }, {
      "referenceID" : 32,
      "context" : "The (n − 1)-puzzle [9, 10, 12, 13] represents one of the best-known examples of a socalled cooperative path-finding (CPF) [23, 33, 38, 42] problem.",
      "startOffset" : 122,
      "endOffset" : 138
    }, {
      "referenceID" : 36,
      "context" : "The (n − 1)-puzzle [9, 10, 12, 13] represents one of the best-known examples of a socalled cooperative path-finding (CPF) [23, 33, 38, 42] problem.",
      "startOffset" : 122,
      "endOffset" : 138
    }, {
      "referenceID" : 14,
      "context" : "From the theoretical point of view it is interesting for the hardness of its optimization variant which is known to be NP-hard [16, 17].",
      "startOffset" : 127,
      "endOffset" : 135
    }, {
      "referenceID" : 0,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 7,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 16,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 17,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 23,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 26,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 22,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 33,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 36,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 7,
      "endOffset" : 41
    }, {
      "referenceID" : 4,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 63,
      "endOffset" : 69
    }, {
      "referenceID" : 6,
      "context" : "robots [1, 8, 19, 20, 26, 29, 25, 39, 42], trajectory planning [5, 7], rearranging of shipping containers in warehouses, or coordination of vehicles in dense traffic.",
      "startOffset" : 63,
      "endOffset" : 69
    }, {
      "referenceID" : 23,
      "context" : "There are two rule-based algorithms for CPF – BIBOX [26, 33] and PUSH-and-SWAP (PUSH-and-ROTATE) [12, 42, 43] similar to the Parberry’s algorithm.",
      "startOffset" : 52,
      "endOffset" : 60
    }, {
      "referenceID" : 11,
      "context" : "There are two rule-based algorithms for CPF – BIBOX [26, 33] and PUSH-and-SWAP (PUSH-and-ROTATE) [12, 42, 43] similar to the Parberry’s algorithm.",
      "startOffset" : 97,
      "endOffset" : 109
    }, {
      "referenceID" : 36,
      "context" : "There are two rule-based algorithms for CPF – BIBOX [26, 33] and PUSH-and-SWAP (PUSH-and-ROTATE) [12, 42, 43] similar to the Parberry’s algorithm.",
      "startOffset" : 97,
      "endOffset" : 109
    }, {
      "referenceID" : 37,
      "context" : "There are two rule-based algorithms for CPF – BIBOX [26, 33] and PUSH-and-SWAP (PUSH-and-ROTATE) [12, 42, 43] similar to the Parberry’s algorithm.",
      "startOffset" : 97,
      "endOffset" : 109
    }, {
      "referenceID" : 18,
      "context" : "In this context, we need to mention a great progress that has been done in solving the CPF problem as well as the (n − 1)-puzzle optimally with respect to various objectives such as the total number of moves [21], parallel makespan [34], and derivations of these.",
      "startOffset" : 208,
      "endOffset" : 212
    }, {
      "referenceID" : 29,
      "context" : "In this context, we need to mention a great progress that has been done in solving the CPF problem as well as the (n − 1)-puzzle optimally with respect to various objectives such as the total number of moves [21], parallel makespan [34], and derivations of these.",
      "startOffset" : 232,
      "endOffset" : 236
    }, {
      "referenceID" : 22,
      "context" : "There exist great variety of search-based optimal algorithms such as ID+OD (Independence Detection + Operator Decomposition) [25], ICTS (Increasing Cost Tree Search) [21], and CBS (Conflict-based Search) [22] to name few.",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 18,
      "context" : "There exist great variety of search-based optimal algorithms such as ID+OD (Independence Detection + Operator Decomposition) [25], ICTS (Increasing Cost Tree Search) [21], and CBS (Conflict-based Search) [22] to name few.",
      "startOffset" : 166,
      "endOffset" : 170
    }, {
      "referenceID" : 19,
      "context" : "There exist great variety of search-based optimal algorithms such as ID+OD (Independence Detection + Operator Decomposition) [25], ICTS (Increasing Cost Tree Search) [21], and CBS (Conflict-based Search) [22] to name few.",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 29,
      "context" : "Reductions of optimal CPF solving to other formalisms such as SAT (Propositional Satisfiability) [34] or ASP (Answer Set Programming) [6] allow using external solvers for a given formalism.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 5,
      "context" : "Reductions of optimal CPF solving to other formalisms such as SAT (Propositional Satisfiability) [34] or ASP (Answer Set Programming) [6] allow using external solvers for a given formalism.",
      "startOffset" : 134,
      "endOffset" : 137
    }, {
      "referenceID" : 0,
      "context" : "The (n − 1)-puzzle consists of a set of pebbles that are moved over a square grid of size n×n [1, 13, 16, 17, 44].",
      "startOffset" : 94,
      "endOffset" : 113
    }, {
      "referenceID" : 14,
      "context" : "The (n − 1)-puzzle consists of a set of pebbles that are moved over a square grid of size n×n [1, 13, 16, 17, 44].",
      "startOffset" : 94,
      "endOffset" : 113
    }, {
      "referenceID" : 38,
      "context" : "The (n − 1)-puzzle consists of a set of pebbles that are moved over a square grid of size n×n [1, 13, 16, 17, 44].",
      "startOffset" : 94,
      "endOffset" : 113
    }, {
      "referenceID" : 0,
      "context" : "It is known that the decision variant of the (n − 1)-puzzle (that is, the yes/no question whether there exists a solution to the given instance) is in P [1, 13, 44].",
      "startOffset" : 153,
      "endOffset" : 164
    }, {
      "referenceID" : 38,
      "context" : "It is known that the decision variant of the (n − 1)-puzzle (that is, the yes/no question whether there exists a solution to the given instance) is in P [1, 13, 44].",
      "startOffset" : 153,
      "endOffset" : 164
    }, {
      "referenceID" : 0,
      "context" : "Using techniques for rearranging pebbles over graphs [1] a solution of length O(n) can be constructed in the worst-case time of O(n) if there exists any.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 15,
      "context" : "The final case of the 8-puzzle is then solved optimally by the A* algorithm [18].",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 9,
      "context" : "The (n − 1)-puzzle represents a special variant of a more general problem of cooperative path-finding - CPF (also known as pebble motion problem on a graph) [10, 11, 19, 20, 23, 29, 44].",
      "startOffset" : 157,
      "endOffset" : 185
    }, {
      "referenceID" : 10,
      "context" : "The (n − 1)-puzzle represents a special variant of a more general problem of cooperative path-finding - CPF (also known as pebble motion problem on a graph) [10, 11, 19, 20, 23, 29, 44].",
      "startOffset" : 157,
      "endOffset" : 185
    }, {
      "referenceID" : 16,
      "context" : "The (n − 1)-puzzle represents a special variant of a more general problem of cooperative path-finding - CPF (also known as pebble motion problem on a graph) [10, 11, 19, 20, 23, 29, 44].",
      "startOffset" : 157,
      "endOffset" : 185
    }, {
      "referenceID" : 17,
      "context" : "The (n − 1)-puzzle represents a special variant of a more general problem of cooperative path-finding - CPF (also known as pebble motion problem on a graph) [10, 11, 19, 20, 23, 29, 44].",
      "startOffset" : 157,
      "endOffset" : 185
    }, {
      "referenceID" : 20,
      "context" : "The (n − 1)-puzzle represents a special variant of a more general problem of cooperative path-finding - CPF (also known as pebble motion problem on a graph) [10, 11, 19, 20, 23, 29, 44].",
      "startOffset" : 157,
      "endOffset" : 185
    }, {
      "referenceID" : 26,
      "context" : "The (n − 1)-puzzle represents a special variant of a more general problem of cooperative path-finding - CPF (also known as pebble motion problem on a graph) [10, 11, 19, 20, 23, 29, 44].",
      "startOffset" : 157,
      "endOffset" : 185
    }, {
      "referenceID" : 38,
      "context" : "The (n − 1)-puzzle represents a special variant of a more general problem of cooperative path-finding - CPF (also known as pebble motion problem on a graph) [10, 11, 19, 20, 23, 29, 44].",
      "startOffset" : 157,
      "endOffset" : 185
    }, {
      "referenceID" : 9,
      "context" : "Although the problem has been already studied [10, 44], new results appeared recently.",
      "startOffset" : 46,
      "endOffset" : 54
    }, {
      "referenceID" : 38,
      "context" : "Although the problem has been already studied [10, 44], new results appeared recently.",
      "startOffset" : 46,
      "endOffset" : 54
    }, {
      "referenceID" : 34,
      "context" : "One of recent works shows solvability of every instance of pebble motion problem consisting of bi-connected graph [36, 40, 41] containing at least two vacant positions [26].",
      "startOffset" : 114,
      "endOffset" : 126
    }, {
      "referenceID" : 35,
      "context" : "One of recent works shows solvability of every instance of pebble motion problem consisting of bi-connected graph [36, 40, 41] containing at least two vacant positions [26].",
      "startOffset" : 114,
      "endOffset" : 126
    }, {
      "referenceID" : 23,
      "context" : "One of recent works shows solvability of every instance of pebble motion problem consisting of bi-connected graph [36, 40, 41] containing at least two vacant positions [26].",
      "startOffset" : 168,
      "endOffset" : 172
    }, {
      "referenceID" : 23,
      "context" : "The related solving algorithm called BIBOX [26] can produce solution of length at most O(|V|) in the worst-case time of O(|V|) (V is the set of vertices of the input graph).",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 9,
      "context" : "The BIBOX algorithm also generates solutions that are significantly shorter than those generated by algorithms from previous works [10, 44].",
      "startOffset" : 131,
      "endOffset" : 139
    }, {
      "referenceID" : 38,
      "context" : "The BIBOX algorithm also generates solutions that are significantly shorter than those generated by algorithms from previous works [10, 44].",
      "startOffset" : 131,
      "endOffset" : 139
    }, {
      "referenceID" : 26,
      "context" : "A generalization of BIBOX algorithm called BIBOX-θ is described in [29].",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 10,
      "context" : "A more general algorithm called PUSH-and-SWAP has been published in [11] – it shows that for every solvable instance on an arbitrary graph containing at least two vacant positions a solution of length O(|V|) can be generated.",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 36,
      "context" : "The algorithm omits few cases that make it incomplete; however a corrected version of PUSH-and-SWAP called PUSHand-ROTATE has been appeared in [42, 43].",
      "startOffset" : 143,
      "endOffset" : 151
    }, {
      "referenceID" : 37,
      "context" : "The algorithm omits few cases that make it incomplete; however a corrected version of PUSH-and-SWAP called PUSHand-ROTATE has been appeared in [42, 43].",
      "startOffset" : 143,
      "endOffset" : 151
    }, {
      "referenceID" : 22,
      "context" : "A new technique that can optimally solve a special case consisting of a grid with obstacles and relatively small number of pebbles is described in [25] as ID+OD algorithm (Independence Detection + Operator Decomposition).",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 2,
      "context" : "A more recent progress in searchbased techniques for optimal CPF solving is represented by [3, 4, 21, 22].",
      "startOffset" : 91,
      "endOffset" : 105
    }, {
      "referenceID" : 3,
      "context" : "A more recent progress in searchbased techniques for optimal CPF solving is represented by [3, 4, 21, 22].",
      "startOffset" : 91,
      "endOffset" : 105
    }, {
      "referenceID" : 18,
      "context" : "A more recent progress in searchbased techniques for optimal CPF solving is represented by [3, 4, 21, 22].",
      "startOffset" : 91,
      "endOffset" : 105
    }, {
      "referenceID" : 19,
      "context" : "A more recent progress in searchbased techniques for optimal CPF solving is represented by [3, 4, 21, 22].",
      "startOffset" : 91,
      "endOffset" : 105
    }, {
      "referenceID" : 32,
      "context" : "Special cases of the problem with large graphs and relatively sparsely arranged pebbles are studied in [38, 39].",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 33,
      "context" : "Special cases of the problem with large graphs and relatively sparsely arranged pebbles are studied in [38, 39].",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 16,
      "context" : "Another specialized technique for relatively large graphs and small number of pebbles has been developed within [19, 20].",
      "startOffset" : 112,
      "endOffset" : 120
    }, {
      "referenceID" : 17,
      "context" : "Another specialized technique for relatively large graphs and small number of pebbles has been developed within [19, 20].",
      "startOffset" : 112,
      "endOffset" : 120
    }, {
      "referenceID" : 15,
      "context" : "The trivial case of the 8puzzle on a grid of the size 3×3 is again solved by the A* algorithm [18].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 20,
      "context" : "The task in cooperative path-finding is to relocate a set of abstract robots over a given undirected graph in a non-colliding way so that each robot eventually reaches its goal vertex [23].",
      "startOffset" : 184,
      "endOffset" : 188
    }, {
      "referenceID" : 23,
      "context" : "A possible application of snakes in CPF is further supported by the fact that several polynomial-time rule-based algorithms that address CPF such as BIBOX [26], PUSH-and-SWAP [11], and PUSH-and-ROTATE [42] relocate robots one by one over the graph towards their goal locations.",
      "startOffset" : 155,
      "endOffset" : 159
    }, {
      "referenceID" : 10,
      "context" : "A possible application of snakes in CPF is further supported by the fact that several polynomial-time rule-based algorithms that address CPF such as BIBOX [26], PUSH-and-SWAP [11], and PUSH-and-ROTATE [42] relocate robots one by one over the graph towards their goal locations.",
      "startOffset" : 175,
      "endOffset" : 179
    }, {
      "referenceID" : 36,
      "context" : "A possible application of snakes in CPF is further supported by the fact that several polynomial-time rule-based algorithms that address CPF such as BIBOX [26], PUSH-and-SWAP [11], and PUSH-and-ROTATE [42] relocate robots one by one over the graph towards their goal locations.",
      "startOffset" : 201,
      "endOffset" : 205
    }, {
      "referenceID" : 27,
      "context" : "It is known that deciding whether there exists a solution of CPF of a given makespan is NP-complete [17, 30].",
      "startOffset" : 100,
      "endOffset" : 108
    }, {
      "referenceID" : 26,
      "context" : "The algorithm is designed for CPFs over bi-connected graphs with at least two unoccupied vertices (modifications for single unoccupied vertex exist as well [29]).",
      "startOffset" : 156,
      "endOffset" : 160
    }, {
      "referenceID" : 34,
      "context" : "An algorithmically important property of bi-connected graphs is that every bi-connected graph can be constructed from a cycle by adding sequence of ears to the currently constructed graph [36, 40, 41].",
      "startOffset" : 188,
      "endOffset" : 200
    }, {
      "referenceID" : 35,
      "context" : "An algorithmically important property of bi-connected graphs is that every bi-connected graph can be constructed from a cycle by adding sequence of ears to the currently constructed graph [36, 40, 41].",
      "startOffset" : 188,
      "endOffset" : 200
    }, {
      "referenceID" : 34,
      "context" : "Lemma 1 (ear decomposition) [36, 40, 41].",
      "startOffset" : 28,
      "endOffset" : 40
    }, {
      "referenceID" : 35,
      "context" : "Lemma 1 (ear decomposition) [36, 40, 41].",
      "startOffset" : 28,
      "endOffset" : 40
    }, {
      "referenceID" : 10,
      "context" : "The PUSH-and-SWAP algorithm [11] and its later corrected version PUSH-and-ROTATE [42, 43] are more general than BIBOX as they are complete for CPFs over arbitrary graphs with at least two unoccupied vertices.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 36,
      "context" : "The PUSH-and-SWAP algorithm [11] and its later corrected version PUSH-and-ROTATE [42, 43] are more general than BIBOX as they are complete for CPFs over arbitrary graphs with at least two unoccupied vertices.",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 37,
      "context" : "The PUSH-and-SWAP algorithm [11] and its later corrected version PUSH-and-ROTATE [42, 43] are more general than BIBOX as they are complete for CPFs over arbitrary graphs with at least two unoccupied vertices.",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 37,
      "context" : "We will concentrate here on the original version of PUSH-and-SWAP though it is not complete since certain cases are not treated by the algorithm [43] – these cases causing incompleteness however do not affect our study.",
      "startOffset" : 145,
      "endOffset" : 149
    }, {
      "referenceID" : 37,
      "context" : "The proof of the first statement is given in [43]; the illustration of the second statement is shown in Figure 11.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 23,
      "context" : "The snake-based reasoning within the BIBOX algorithm has been integrated into its original C++ implementation [26] where only minor changes to the code needed to be made.",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 25,
      "context" : "Further solution improvements that increases parallelism [28, 39, 43] (multiple independent moves can be performed in a single time-step) and removes redundancies [27, 32, 39, 43] were not applied as it is out of scope of this study.",
      "startOffset" : 57,
      "endOffset" : 69
    }, {
      "referenceID" : 33,
      "context" : "Further solution improvements that increases parallelism [28, 39, 43] (multiple independent moves can be performed in a single time-step) and removes redundancies [27, 32, 39, 43] were not applied as it is out of scope of this study.",
      "startOffset" : 57,
      "endOffset" : 69
    }, {
      "referenceID" : 37,
      "context" : "Further solution improvements that increases parallelism [28, 39, 43] (multiple independent moves can be performed in a single time-step) and removes redundancies [27, 32, 39, 43] were not applied as it is out of scope of this study.",
      "startOffset" : 57,
      "endOffset" : 69
    }, {
      "referenceID" : 24,
      "context" : "Further solution improvements that increases parallelism [28, 39, 43] (multiple independent moves can be performed in a single time-step) and removes redundancies [27, 32, 39, 43] were not applied as it is out of scope of this study.",
      "startOffset" : 163,
      "endOffset" : 179
    }, {
      "referenceID" : 33,
      "context" : "Further solution improvements that increases parallelism [28, 39, 43] (multiple independent moves can be performed in a single time-step) and removes redundancies [27, 32, 39, 43] were not applied as it is out of scope of this study.",
      "startOffset" : 163,
      "endOffset" : 179
    }, {
      "referenceID" : 37,
      "context" : "Further solution improvements that increases parallelism [28, 39, 43] (multiple independent moves can be performed in a single time-step) and removes redundancies [27, 32, 39, 43] were not applied as it is out of scope of this study.",
      "startOffset" : 163,
      "endOffset" : 179
    }, {
      "referenceID" : 8,
      "context" : "Regarding the choice of testing puzzles, we followed the benchmark generation already used in the literature by Korf and Taylor [9] where random instances of the (5 − 1)-puzzle were used.",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 8,
      "context" : "There is experimental evidence that solving random instances of the (5 − 1)-puzzle optimally is difficult [9].",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 23,
      "context" : "Let us recall that the original BIBOX algorithm as presented in [26] requires two unoccupied vertices so it not immediately applicable to (n − 1)-puzzle.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 24,
      "context" : "There exists a variant of the algorithm called BIBOX-θ [27, 33] that suffices with just one unoccupied vertex that uses special transposition rules to arrange pebbles in the initial cycle.",
      "startOffset" : 55,
      "endOffset" : 63
    }, {
      "referenceID" : 30,
      "context" : "As it is shown in [35] various ear decompositions can affect the number of generated moves by the algorithm greatly.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 36,
      "context" : "The known problematic behavior of the PUSH-and-SWAP algorithm described in [42, 43] due to which the Rotate operation has been introduced does not occur in our testing scenarios.",
      "startOffset" : 75,
      "endOffset" : 83
    }, {
      "referenceID" : 37,
      "context" : "The known problematic behavior of the PUSH-and-SWAP algorithm described in [42, 43] due to which the Rotate operation has been introduced does not occur in our testing scenarios.",
      "startOffset" : 75,
      "endOffset" : 83
    }, {
      "referenceID" : 26,
      "context" : "These variants are known as the (n − k)-puzzle with k > 1 [29].",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 0,
      "context" : "Another open question is how the snake-based approach could perform in the directed version of CPF [1, 45].",
      "startOffset" : 99,
      "endOffset" : 106
    }, {
      "referenceID" : 22,
      "context" : "This is quite open area as today’s optimal solving techniques [25] can manage only small number of pebbles compared to the size of the unoccupied space.",
      "startOffset" : 62,
      "endOffset" : 66
    } ],
    "year" : 2016,
    "abstractText" : "The problem of solving (n − 1)-puzzle and cooperative path-finding (CPF) sub-optimally by rule based algorithms is addressed in this manuscript. The task in the puzzle is to rearrange n − 1 pebbles on the square grid of the size of n×n using one vacant position to a desired goal configuration. An improvement to the existent polynomial-time algorithm is proposed and experimentally analyzed. The improved algorithm is trying to move pebbles in a more efficient way than the original algorithm by grouping them into so-called snakes and moving them jointly within the snake. An experimental evaluation showed that the algorithm using snakes produces solutions that are 8% to 9% shorter than solutions generated by the original algorithm. The snake-based relocation has been also integrated into rule-based algorithms for solving the CPF problem sub-optimally, which is a closely related task. The task in CPF is to relocate a group of abstract robots that move over an undirected graph to given goal vertices. Robots can move to unoccupied neighboring vertices and at most one robot can be placed in each vertex. The (n − 1)-puzzle is a special case of CPF where the underlying graph is represented by a 4-connected grid and there is only one vacant vertex. Two major rule-based algorithms for CPF were included in our study – BIBOX and PUSH-and-SWAP (PUSH-and-ROTATE). Improvements gained by using snakes in the BIBOX algorithm were stable around 30% in (n − 1)-puzzle solving and up to 50% in CPFs over bi-connected graphs with various ear decompositions and multiple vacant vertices. In the case of the PUSHand-SWAP algorithm the improvement achieved by snakes was around 5% to 8%. However, the improvement was unstable and hardly predictable in the case of PUSH-and-SWAP.",
    "creator" : "Microsoft® Word 2016"
  }
}