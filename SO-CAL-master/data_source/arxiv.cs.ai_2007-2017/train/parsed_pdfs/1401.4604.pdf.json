{
  "name" : "1401.4604.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Completeness Guarantees for Incomplete Ontology Reasoners: Theory and Practice",
    "authors" : [ "Bernardo Cuenca Grau", "Boris Motik", "Giorgos Stoilos", "Ian Horrocks" ],
    "emails" : [ "bernardo.cuenca.grau@cs.ox.ac.uk", "boris.motik@cs.ox.ac.uk", "giorgos.stoilos@cs.ox.ac.uk", "ian.horrocks@cs.ox.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "In this paper, we present a novel logic-based framework that allows one to check whether a reasoner is complete for a given query Q and ontology T —that is, whether the reasoner is guaranteed to compute all answers to Q w.r.t. T and an arbitrary data set A. Since ontologies and typical queries are often fixed at application design time, our approach allows application developers to check whether a reasoner known to be incomplete in general is actually complete for the kinds of input relevant for the application.\nWe also present a technique that, given a query Q, an ontology T , and reasoners R1 and R2 that satisfy certain assumptions, can be used to determine whether, for each data set A, reasoner R1 computes more answers to Q w.r.t. T and A than reasoner R2. This allows application developers to select the reasoner that provides the highest degree of completeness forQ and T that is compatible with the application’s scalability requirements.\nOur results thus provide a theoretical and practical foundation for the design of future ontology-based information systems that maximise scalability while minimising or even eliminating incompleteness of query answers."
    }, {
      "heading" : "1. Introduction",
      "text" : "Efficient management and querying of large amounts of data is a core problem for a growing range of applications in fields as diverse as biology (Sidhu, Dillon, Chang, & Sidhu, 2005), medicine (Golbreich, Zhang, & Bodenreider, 2006), geography (Goodwin, 2005), astronomy (Derriere, Richard, & Preite-Martinez, 2006), agriculture (Soergel, Lauser, Liang, Fisseha, Keizer, & Katz, 2004), and defence (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill, 2005). In order to facilitate interoperability, such applications often use standard data models and query languages. In particular, RDF (Hayes, 2004) provides a standard model for semistructured data, SPARQL (Prud’hommeaux & Seaborne, 2008) is a standard query language for RDF, and ontology languages such as OWL (Horrocks, Patel-Schneider, & van Harmelen, 2003) and OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider,\nc2012 AI Access Foundation. All rights reserved.\n& Sattler, 2008b) can be used to describe background knowledge about the application domain. Thus, answering SPARQL queries over RDF data sets structured using an OWL ontology is a key service in ontology-based information systems.\nAn important question in the design of such systems is the selection of an appropriate reasoner. Systems such as Pellet (Sirin, Parsia, Cuenca Grau, Kalyanpur, & Katz, 2007), HermiT (Motik, Shearer, & Horrocks, 2009b), and RACER (Haarslev & Möller, 2001) are based on (hyper)tableau algorithms that are provably complete—that is, they are guaranteed to compute all answers for each query, ontology, and data set. Completeness, however, comes at the cost of scalability, as answering queries over OWL 2 ontologies is of high computational complexity (Glimm, Horrocks, Lutz, & Sattler, 2007; Ortiz, Calvanese, & Eiter, 2008; Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007; Lutz, Toman, & Wolter, 2009). Thus, complete systems often fail to meet the scalability demands of applications that manage data sets consisting of hundreds of millions or even billions of assertions.\nScalability of query answering can be ensured by restricting the expressive power of the ontology language to the level that makes provably complete reasoning tractable. This has led to the development of three profiles of OWL 2 (Motik, Cuenca Grau, Horrocks, Wu, Fokoue, & Lutz, 2009a): OWL 2 EL, OWL 2 RL, and OWL 2 QL. Query answering in all three profiles can be implemented in polynomial time w.r.t. the size of data (and even in logarithmic space in the case of OWL 2 QL). Such appealing theoretical properties have spurred the development of specialised reasoners such as QuONTO (Acciarri, Calvanese, De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2005) that target specific profiles and typically reject ontologies that fall outside the target profile.\nA different solution to the scalability problem is adopted in reasoners such as Oracle’s Semantic Data Store (Wu, Eadon, Das, Chong, Kolovski, Annamalai, & Srinivasan, 2008), Sesame (Broekstra, Kampman, & van Harmelen, 2002), Jena (McBride, Brian, 2001), OWLim (Kiryakov, Ognyanov, & Manov, 2005), Minerva (Ma, Yang, Qiu, Xie, Pan, & Liu, 2006), DLE-Jena (Meditskos & Bassiliades, 2008), and Virtuoso (Erling & Mikhailov, 2009). These reasoners accept all OWL 2 ontologies as input—that is, they never reject inputs. Furthermore, to the best of our knowledge, all of these systems are intended to be sound, which means that all results of a query are indeed correct answers. Finally, these reasoners typically use scalable reasoning techniques, such as various (deductive) database algorithms. As a consequence, the reasoners are incomplete: for each reasoner, at least one query, ontology, and data set exist for which the reasoner does not return all answers to the query. Some of these reasoners were actually designed to be complete for a particular profile of OWL 2 (typically this is OWL 2 RL due to its close connection with datalog), and they can often additionally handle certain kinds of axiom that fall outside the target profile.\nSince incomplete reasoners can handle large data sets, they often provide the best practical choice for developers of ontology-based applications. For example, OWLim was used for reasoning in the backend of the BBC’s 2010 World Cup website, and Oracle’s reasoner is being used by the University of Texas Health Science Center to improve large-scale public health surveillance. In order to verify that the selected reasoner meets the application’s requirements, developers typically resort to empirical testing, in which they check the reasoner’s answers w.r.t. the application ontology and queries for representative data sets. Although primarily intended for testing performance, benchmark suites such as the Lehigh\nUniversity Benchmark (LUBM) (Guo, Pan, & Heflin, 2005) and the University Ontology Benchmark (UOBM) (Ma et al., 2006) have been used for such completeness testing.\nEmpirical completeness testing, however, has several important limitations. First, tests are not generic, as data sets used for testing typically have a fixed and/or repetitive structure, which can skew test results. Second, test data is not exhaustive, as completeness is tested only w.r.t. a limited number of data sets. Finally, query answers may not be verifiable: since complete reasoners fail to handle large data sets, they often cannot compute the control answers needed to check the answers produced by an incomplete reasoner. As a consequence, empirical completeness tests provide only limited assurance of a reasoner’s ability to meet the requirements of a given application.\nIn this paper, we present a radically different approach to solving these problems. We observed that, given a query Q and ontology T , even if a reasoner is not complete for the language of T , the reasoner may be able to correctly answerQ w.r.t. T and an arbitrary data set A; in such a case, we say that the reasoner is (Q, T )-complete. Given that ontology-based applications often use a limited set of queries and a fixed ontology (or at least the queries and the ontology evolve relatively slowly), a scalable reasoner that is generally incomplete, but is (Q, T )-complete for all relevant combinations of Q and T , may provide a solid foundation for ontology-based applications, allowing them to enjoy ‘the best of both worlds’: regardless of the data set encountered, such applications will enjoy completeness guarantees normally available only with computationally-intensive complete reasoners, while at the same time exhibiting scalability levels normally available only by sacrificing completeness. To develop an approach for testing the (Q, T )-completeness of a given reasoner, we proceed as follows.\nIn Section 3 we develop a logic-based framework that allows us to establish formally provable (Q, T )-completeness guarantees. The following two notions are central to our framework. First, in order to abstract away from the implementation details of concrete reasoners, we introduce the notion of an abstract reasoner—an idealised reasoner that captures the intended behaviour and salient features (such as soundness and monotonicity) of a class of concrete reasoners. Second, we introduce the notion of a test suite—a finite set of data sets and queries. Intuitively, given Q and T , our goal is to construct a test suite such that, if a reasoner correctly answers all queries on all data sets in the test suite, then the reasoner is guaranteed to be (Q, T )-complete.\nUnfortunately, as we show in Section 3.4, for certain Q and T , it is impossible to construct a finite test suite that will provide the aforementioned completeness guarantees. Therefore, we investigate assumptions onQ, T , and the reasoner under which testing (Q, T )- completeness becomes practically feasible.\nIn Section 3.5 we consider the case where Q and T can be rewritten into a union of conjunctive queries R—that is, when answering Q w.r.t T and a data set A is equivalent to evaluating R over A. For T expressed in OWL 2 QL, a rewriting R can be computed using the algorithm by Calvanese et al. (2007); additionally, the algorithm by Pérez-Urbina, Motik, and Horrocks (2010) can sometimes compute R even if T is syntactically outside this fragment. We show that such R can be converted into a test suite ER that can be used for testing the (Q, T )-completeness of any reasoner that satisfies some basic assumptions; roughly speaking, the reasoner’s answers should not depend on the names of the individuals occurring in a data set, and its answers must increase monotonically when new data is added. The size of each test in ER is polynomial in the size of the longest conjunctive query in R,\nso it should be feasible to compute correct answers to the tests using a complete reasoner. The number of tests in ER, however, can be exponential in the size of R, which may lead to problems in practice. As a remedy, in Section 3.6 we strengthen our assumptions and require the reasoner not to drop answers when ‘merging’ individuals—that is, if the reasoner returns a given inputs Q, T , and A, then for each (possibly noninjective) mapping µ the reasoner returns µ(a) given inputs Q, T , and µ(A)—and we show that (Q, T )-completeness of such reasoners can be checked using a test suite IR obtained from R by a linear transformation.\nThat Q and T should be rewritable into a union of conjunctive queries effectively prevents T from stating recursive axioms. To overcome this restriction, in Section 3.7 we consider first-order reproducible reasoners—that is, reasoners whose behaviour on Q, T , and A can be seen as computing certain answers of Q w.r.t. some (possibly unknown) first-order theory FT and A. Since FT can be a datalog program, most reasoners based on deductive databases are first-order reproducible. In addition, we require Q and T to be rewritable into datalog±,∨—an extension of datalog that allows for existential quantifiers and disjunction in rule heads. In many cases, T can be transformed into a datalog±,∨ program using equivalence-preserving transformations; furthermore, the algorithm by Pérez-Urbina et al. (2010) can in many cases produce a plain datalog rewriting. We then show how to transform a datalog±,∨ rewriting of Q and T into a test suite that can be used to test (Q, T )-completeness of first-order reproducible reasoners.\nIn Section 4 we turn our attention to comparing incomplete reasoners. Roughly speaking, given Q and T , reasoner R1 is ‘more complete’ than reasoner R2 if, for each data set A, reasoner R1 computes all the answers to Q w.r.t. T and A that are computed by R2. We show that comparing incomplete reasoners is infeasible in general. Therefore, we introduce the notion of compact reasoners—that is, reasoners whose behaviour on Q, T , and A can be seen as first selecting some subset T  of T and then using a complete reasoner to evaluate Q w.r.t. T  and A. Thus, the class of compact reasoners captures all reasoners that reduce the input ontology T to a set of axioms that match certain parameters, such as fitting into language fragments. For Q and T that can be rewritten into a union of conjunctive queries R, we show that the test suite IR can be used to compare compact reasoners.\nWe have implemented our approaches for computing test suites, and have tested completeness of several well-known reasoners (see Section 5). These show that test suites can be efficiently computed for realistic ontologies. Furthermore, we were able to guarantee (Q, T )-completeness of the evaluated reasoners for many queries and ontologies. Finally, when no (Q, T )-completeness guarantee could be provided, we were able to compute a counter-example—a small data set for which the reasoner at hand was incomplete."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "In this section we briefly introduce Description Logics (DLs) (Baader, McGuinness, Nardi, & Patel-Schneider, 2002)—a family of knowledge representation formalisms which underpin the OWL and OWL 2 ontology languages. We describe description logics in the wider framework of first-order logic since many of our results hold for arbitrary first-order theories.\nWe then introduce the datalog±,∨ and datalog languages, and we define the syntax and semantics of unions of conjunctive queries (UCQs). Finally, we introduce the notions of UCQ, datalog, and datalog±,∨ rewritings, which underpin many of our techniques."
    }, {
      "heading" : "2.1 Description Logics and First-Order Logic",
      "text" : "Most of the results in this paper hold for arbitrary first-order theories, rather than description logics. Our work, however, is motivated by description logics and ontologies, so we use the DL terminology throughout the paper; for example, we often talk about TBoxes and ABoxes instead of first-order theories and sets of facts.\nAll definitions in this paper are implicitly parameterised by a signature Σ = ΣP ,ΣI, which consists of countably infinite disjoint sets of predicates ΣP and individuals (commonly called constants in first-order logic) ΣI . Each predicate is associated with a nonnegative arity ; predicates of zero arity are commonly called propositional symbols. The notions of variables, terms, atoms, first-order formulae, and sentences are defined as usual (Fitting, 1996); we do not consider function symbols in this article and we assume all formulae to be function-free. The atom that is false (true) in all interpretations is written ⊥ (). An atom is a fact if it does not contain variables. We use the standard first-order notions of satisfiability, unsatisfiability, and entailment (written |=) of sets of first-order sentences.\nWe assume that ΣP contains the special equality and inequality predicates ≈ and ≈, respectively; atoms of the form ≈(t1, t2) and ≈(t1, t2) are commonly written as t1 ≈ t2 and t1 ≈ t2, respectively. We make a technical assumption that ≈ and ≈ are distinct predicates rather than, as it is common in first-order logic, that t1 ≈ t2 is an abbreviation for ¬(t1 ≈ t2); furthermore, we assume that each theory that uses ≈ and ≈ axiomatises their semantics as follows, where (5) is instantiated for each predicate P of arity n and each i with 1 ≤ i ≤ n.\n∀x, y.[x ≈ y ∧ x ≈ y → ⊥] (1) ∀x.[x ≈ x] (2)\n∀x, y.[x ≈ y → y ≈ x] (3) ∀x, y, z.[x ≈ y ∧ y ≈ z → x ≈ z] (4)\n∀x1, . . . , xi, . . . , xn, yi.[P (x1, . . . , xi, . . . , xn) ∧ xi ≈ yi → P (x1, . . . , yi, . . . , xn)] (5)\nNote that, according to this assumption, each set of facts is satisfiable. For example, the set of atoms {a ≈ b, a ≈ b} is satisfiable since both a ≈ b and a ≈ b are positive variable-free atoms that are semantically independent from each other; moreover, axiom (1) is required to obtain the expected contradiction.\nAn individual renaming (often just renaming) is a partial function µ : ΣI → ΣI that maps individuals to individuals. The domain and the range of µ are written dom(µ) and rng(µ); unless otherwise noted, we assume that dom(µ) is finite. For α an object containing individuals (such as a formula, a set of formulae, or a tuple of individuals), ind(α) is the set of individuals occurring in α, and µ(α) is obtained from α by simultaneously replacing each individual a ∈ ind(α) ∩ dom(µ) with µ(a).\nWe use the notion of substitutions from first-order logic; that is, a substitution σ is a mapping of variables to terms. For α a term, an atom, or a formula, the result of applying a substitution σ to α is written as σ(α).\nA TBox T a is a finite set of first-order sentences that contains axioms (1)–(5) whenever ≈ and/or ≈ are used. An ABox A is a finite set of facts. Note that this definition allows for atoms of the form a ≈ b and a ≈ b in ABoxes; furthermore, since ABoxes can contain only positive atoms, each ABox (when considered without a TBox) is satisfiable.\nA description logic DL is a (usually infinite) recursive set of TBoxes satisfying the following conditions:\n• for each T ∈ DL and each renaming µ, we have µ(T ) ∈ DL, and\n• for each T ∈ DL and each T  ⊆ T , we have T  ∈ DL. If T ∈ DL, we say that T is a DL-TBox. Finally, FOL is the largest description logic that contains all finite sets of first-order sentences over the signature in question.\nWe next present an overview of the DLs commonly considered in the literature. Typically, the predicates in DL signatures are required to be unary or binary; the former are commonly called atomic concepts and the latter are commonly called atomic roles. DLs typically use a specialised syntax, summarised in Table 1, that provides a set of constructors for constructing complex concepts and roles from simpler ones, as well as different kinds of axioms. Using the translation from Table 2, concepts can be translated into first-order formulae with one free variable, roles can be translated into first-order formulae with two free variables, and axioms can be translated into first-order sentences. Note that the translation uses counting quantifiers ∃≥n and ∃≤n, which can be expressed by using ordinary quantifiers and equality by well-known transformations.\nIn the rest of this paper, we commonly write TBoxes and ABoxes in DL syntax; however, to simplify the presentation, we identify T and A written in DL syntax with π(T ) and π(A)."
    }, {
      "heading" : "2.2 Datalog±,∨",
      "text" : "We next introduce a fragment of first-order logic called datalog±,∨ as an extension of datalog± by Cal̀ı, Gottlob, Lukasiewicz, Marnette, and Pieris (2010). A datalog±,∨ rule (or commonly just a rule) r is a formula of the form (6), where each Bj is an atom different from ⊥ whose free variables are contained in x, and\n• m = 1 and ϕ1(x, y1) = ⊥, or\n• m ≥ 1 and, for each 1 ≤ i ≤ m, formula ϕi(x, yi) is a conjunction of atoms different from ⊥ whose free variables are contained in x ∪ yi.\n∀x.[B1 ∧ . . . ∧Bn → m\ni=1\n∃yi.ϕi(x, yi)] (6)\nA rule is safe if each variable in x also occurs in some Bj ; unless otherwise noted, all rules are assumed to be safe. For brevity, the outer quantifier ∀x is commonly left implicit. The body of r is the set of atoms body(r) = {B1, . . . , Bn}, and the head of r is the formula head(r) = m i=1 ∃yi.ϕi(x, yi). A datalog±,∨ program is a finite set of safe datalog±,∨ rules. Note that, since≈ and ≈ are treated as ordinary predicates, they can occur in rules, provided that their semantics is appropriately axiomatised; furthermore, note that the latter can be achieved using datalog±,∨ rules.\nLet r be a datalog±,∨ rule. Then, r is a datalog∨ rule if head(r) contains no existential quantifier. Also, r is a datalog± rule if m = 1. Finally, r is a datalog rule if m = 1 and the head of r is a single atom without existential quantifiers (Ceri, Gottlob, & Tanca, 1989).\nIn several places in this paper, we check whether a set of first-order sentences entails a datalog±,∨ rule, which can be accomplished using the following simple result.\nProposition 2.1. Let F be a set of first-order sentences, and let r be a datalog±,∨ rule of the form (6). Then, for each substitution σ mapping the free variables of r to distinct individuals not occurring in F or r, we have F |= r if and only if\nF ∪ {σ(B1), . . . ,σ(Bn)} |= m\ni=1\n∃yi.ϕi(σ(x), yi)\nProof. Let x be the tuple of free variables in r and let σ be an arbitrary substitution mapping the variables in x to distinct individuals not occurring in F or r. The claim of this proposition follows from the following equivalences:\nF |= ∀x.[B1 ∧ . . . ∧Bn → m\ni=1\n∃yi.ϕi(x, yi)] iff\nF ∪ {¬[∀x.B1 ∧ . . . ∧Bn → m\ni=1\n∃yi.ϕi(x, yi)]} is unsatisfiable iff\nF ∪ {∃x.[B1 ∧ . . . ∧Bn ∧ ¬ m\ni=1\n∃yi.ϕi(x, yi)]} is unsatisfiable iff (skolem. of ∃x)\nF ∪ {σ(B1) ∧ . . . ∧ σ(Bn) ∧ ¬ m\ni=1\n∃yi.ϕi(σ(x), yi)} is unsatisfiable iff\nF ∪ {σ(B1), . . . ,σ(Bn),¬ m\ni=1\n∃yi.ϕi(σ(x), yi)} is unsatisfiable iff\nF ∪ {σ(B1), . . . ,σ(Bn)} |= m\ni=1\n∃yi.ϕi(σ(x), yi)."
    }, {
      "heading" : "2.3 Queries",
      "text" : "In order to achieve a high degree of generality, we define a query Q as a finite set of firstorder sentences containing a distinct query predicate Q. Intuitively, the query predicate Q determines the answers of Q. In order to simplify the notation, we typically assume that the association between Q and the query predicate is implicit (e.g., we may require each query to contain precisely one such predicate), and we assume that no query predicate occurs in a TBox or an ABox.\nA tuple of constants a is a certain answer to a query Q with query predicate Q with respect to a TBox T and an ABox A if the arity of a agrees with the arity of Q and T ∪A ∪Q |= Q(a). The set of all certain answers of Q w.r.t. T and A is denoted as cert(Q, T ,A). If the query predicate of Q is propositional (i.e., if the query is Boolean), then cert(Q, T ,A) is either empty or it contains the tuple of zero length; in such cases, we commonly write cert(Q, T ,A) = f and cert(Q, T ,A) = t, respectively.\nWe use ∗ as the special Boolean query that checks a first-order theory for unsatisfiability. Thus, cert(∗, T ,A) = t if and only if T ∪A is unsatisfiable.\nA query Q with a query predicate Q is a union of conjunctive queries (UCQ) if it is a datalog program in which each rule contains Q in the head but not in the body. A UCQ Q is a conjunctive query (CQ) if it contains exactly one rule.\nA union of conjunctive queries Q is ground if, for each rule r ∈ Q, each variable occurring in the body of r also occurs in the head of r. Roughly speaking, when computing cert(Q, T ,A) for a ground Q, all variables in Q can be matched only to the individuals in T and A, but not to unnamed objects whose existence is guaranteed by existential quantifiers. Many state of the art reasoners used in practice support only ground UCQs. Note that Q = {A(x) → Q(x), R(x, y) → Q(x, y)} is not a ground UCQ; in fact, Q is not even a valid first-order theory since predicate Q does not have unique arity. To obtain a UCQ, one can ‘pad’ the head of the first rule—that is, one can introduce a special fresh individual null and rewrite the rules as Q = {A(x) → Q(x,null), R(x, y) → Q(x, y)}.\nBy the properties of first-order logic entailment, cert satisfies the following properties for each query Q, all TBoxes T and T , and all ABoxes A and A.\n1. Monotonicity : T ⊆ T  and A ⊆ A imply\n• cert(∗, T ,A) = t implies cert(∗, T ,A) = t, and • cert(Q, T ,A) ⊆ cert(Q, T ,A).\n2. Invariance under renamings: For each renaming µ and each tuple of individuals a,\n• cert(∗, T ,A) = t implies cert(∗, µ(T ), µ(A)) = t, and • a ∈ cert(Q, T ,A) implies µ(a) ∈ cert(µ(Q), µ(T ), µ(A))."
    }, {
      "heading" : "2.4 Rewritings",
      "text" : "Intuitively, a rewriting of a query Q w.r.t. a TBox T is another query that captures all the information from T that is relevant for answering Q over an arbitrary ABox A (Calvanese et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009; Pérez-Urbina et al., 2010). In practice, UCQs (Calvanese et al., 2007) and datalog (Pérez-Urbina et al., 2010) are the most widely used target languages for query rewriting. For the sake of generality, however, in this paper we use a notion of a datalog±,∨ rewriting.\nDefinition 2.2. Let Q be a query and let T be a TBox. A datalog±,∨ rewriting (or simply a rewriting) of Q w.r.t. T is a triple R = RD,R⊥,RQ where\n• RD is a datalog±,∨ program not containing ⊥ or Q such that T |= RD,\n• R⊥ is a datalog program such that head(r) = ⊥ for each r ∈ R⊥, and\n• RQ is a UCQ whose query predicate is Q,\nsuch that the following properties hold for each ABox A:\n• cert(∗, T ,A) = cert(∗,RD ∪R⊥,A), and\n• if cert(∗, T ,A) = f, then cert(Q, T ,A) = cert(RQ,RD ∪R⊥,A).\nRewriting R is a datalog rewriting if RD is a datalog program. Furthermore, rewriting R is a UCQ rewriting if RD = ∅; such an R is usually written as just R = R⊥,RQ.\nNote that Definition 2.2 requires T |= RD to hold, which precludes rewritings consisting of axioms that are unsound w.r.t. T . For example, let Q = {A(x) → Q(x)} and T = ∅; then, RD = {B(x) → A(x)} does not satisfy the definition of a rewriting since formula B(x) → A(x) is not a logical consequence of T .\nFor a wide range of T and Q, a datalog±,∨ rewriting of Q w.r.t. T can be computed using straightforward equivalence-preserving transformations of T ; this can be further optimised by eliminating axioms from T that are irrelevant to answering Q. Furthermore, several algorithms for computing UCQ and datalog rewritings have been proposed in the literature. For example, Calvanese et al. (2007) showed how to compute a UCQ rewriting in cases when T is expressed in a logic from the DL-Lite family, and this approach can be extended to the OWL 2 QL profile of OWL 2 (Motik et al., 2009a). Similarly, Pérez-Urbina et al. (2010) proposed an algorithm for computing the simplest possible datalog rewriting when T is expressed in the description logic ELHIO.\nRewritings produced by known algorithms often contain predicates that do not occur in T and Q; such predicates are sometimes called fresh. For example, many rewriting algorithms normalise TBoxes by replacing complex concepts with fresh atomic concepts. A rewriting R = RD,R⊥,RQ obtained in such a way is unlikely to satisfy the requirement that T |= RD. However, predicates occurring in R but not in T can often be eliminated via unfolding. For example, let Q = {A(x) → Q(x)} and T = {∃R.∃S.B  A}, and assume that a rewriting algorithm produces\nRD = {S(x, y) ∧B(x) → C(x), R(x, y) ∧ C(y) → A(x)}.\nTo satisfy Definition 2.2, predicate C can be unfolded and RD replaced with\nRD = {R(x, y) ∧ S(y, z) ∧B(z) → A(x)},\nfor which T |= RD holds. Unfolding, however, may not always be possible (e.g., this might be the case when fresh predicates occur in recursive axioms), which may limit the applicability of some of the results presented in this paper."
    }, {
      "heading" : "3. Completeness Guarantees for Incomplete Reasoners",
      "text" : "In this section, we introduce the formal framework that will allow us to establish completeness guarantees for incomplete reasoners. Our results are not restricted to any particular description logic, but are applicable to all TBoxes that satisfy the following criterion.\nDefinition 3.1. A TBox T is admissible if a description logic DL exists such that T is a DL-TBox, and both checking TBox satisfiability and answering Boolean UCQs w.r.t. an arbitrary ABox are decidable for DL."
    }, {
      "heading" : "3.1 Concrete and Abstract Reasoners",
      "text" : "Concrete reasoners are complex software systems that differ greatly in the functionality and the supported interfaces, and that use a range of different implementation techniques. To make our results general and independent from specific implementation techniques, we introduce the notion of an abstract reasoner. An abstract reasoner can be thought of as an\nidealised reasoner that captures the intended behaviour and salient features of a class of concrete reasoners. A concrete reasoner belonging to this class may use arbitrary algorithms, as long as their observable behaviour mirrors that of the abstract reasoner.\nDefinition 3.2. An abstract reasoner ans for a description logic DL is a computable function that takes as input an arbitrary DL-TBox T , an arbitrary ABox A, and either the special unsatisfiability query ∗ or an arbitrary UCQ Q. The return value of ans is defined as follows:\n• ans(∗, T ,A) is either t or f;\n• if ans(∗, T ,A) = t, then ans(Q, T ,A) is of no interest and can be arbitrary; and\n• if ans(∗, T ,A) = f, then ans(Q, T ,A) is a finite set of tuples of individuals, where the arity of each tuple is equal to the arity the query predicate of Q.\nAn abstract reasoner ans for DL is said to be applicable to a TBox T if T is a DL-TBox.\nIntuitively, ans(∗, T ,A) asks the abstract reasoner to check whether T ∪ A is unsatisfiable, and ans(Q, T ,A) asks the abstract reasoner to evaluate Q w.r.t. T ∪ A. If T ∪ A is unsatisfiable, then each tuple of constants of the same arity as the query predicate Q is an answer to Q on T ∪ A; therefore, the result of ans(Q, T ,A) is of interest only if ans(∗, T ,A) = f—that is, if ans identifies T ∪A as satisfiable.\nExample 3.3. Consider the abstract reasoners rdf, rdfs, rl, and classify which, given as input a UCQ Q, a TBox T , and an ABox A, compute the answer to Q w.r.t. T and A as described next.\nAbstract reasoner rdf ignores T and evaluatesQ w.r.t.A; more precisely, rdf(∗, T ,A) = f and rdf(Q, T ,A) = cert(Q, ∅,A). Thus, rdf captures the behaviour of RDF reasoners.\nAbstract reasoner rdfs evaluates Q w.r.t. A and a datalog program Prdfs that is constructed by translating each RDFS axiom α in T into an equivalent datalog rule; more precisely, rdfs(∗, T ,A) = f and rdfs(Q, T ,A) = cert(Q,Prdfs,A). Thus, rdfs captures the behaviour of RDFS reasoners such as Sesame.\nAbstract reasoner rl evaluates Q w.r.t. A and a datalog program Prl that is constructed by translating each OWL 2 RL axiom α in T into an equivalent datalog rule; more precisely, rl(∗, T ,A) = cert(∗,Prl,A) and rl(Q, T ,A) = cert(Q,Prl,A). Thus, rl captures the behaviour of OWL 2 RL reasoners such as Jena and Oracle’s Semantic Data Store.\nAbstract reasoner classify first classifies T using a complete OWL 2 DL reasoner; that is, it computes a TBox T  containing each subclass axiom A  B such that T |= A  B, and A and B are atomic concepts occurring in T . The abstract reasoner then proceeds as rl, but considers T ∪ T  instead of T ; more precisely, classify(∗, T ,A) = rl(∗, T ∪ T ,Ain) and classify(Q, T ,A) = rl(Q, T ∪ T ,A). In this way, classify captures the behaviour of OWL 2 RL reasoners such as Minerva and DLE-Jena that try to be ‘more complete’ by materialising certain consequences of T . ♦\nAn ‘ideal’ abstract reasoner is one such that, for an arbitrary UCQ Q, TBox T , and ABox A, we have ans(∗, T ,A) = cert(∗, T , A), and ans(Q, T ,A) = cert(Q, T , A) whenever ans(∗, T ,A) = f. We next introduce and discuss several properties of abstract reasoners\nthat are likely to affect how close they come to this ideal and that may also be relevant to the applicability of our results.\nThe following notion of soundness describes abstract reasoners that return only answers that logically follow from Q, T , and A.\nDefinition 3.4. An abstract reasoner ans for DL is sound if the following conditions hold for each UCQ Q, DL-TBox T , and ABox A:\n• ans(∗, T ,A) = t implies cert(∗, T ,A) = t; and\n• ans(∗, T ,A) = f implies ans(Q, T ,A) ⊆ cert(Q, T ,A).\nThe following notion of monotonicity describes abstract reasoners for which extending the input TBox and ABox never leads to dropping answers. We also consider a weaker notion of (Q, T )-monotonicity, in which the input query Q and TBox T are fixed.\nDefinition 3.5. An abstract reasoner ans for DL is monotonic if the following conditions hold for each UCQ Q, all DL-TBoxes T and T , and all ABoxes A and A such that T ⊆ T  and A ⊆ A:\n• ans(∗, T ,A) = t implies ans(∗, T ,A) = t; and\n• ans(∗, T ,A) = f and ans(∗, T ,A) = f imply ans(Q, T ,A) ⊆ ans(Q, T ,A).\nGiven a UCQ Q and a DL-TBox T , ans is (Q, T )-monotonic if the following conditions hold for all ABoxes A and A such that A ⊆ A:\n• ans(∗, T ,A) = t implies ans(∗, T ,A) = t; and\n• ans(∗, T ,A) = f and ans(∗, T ,A) = f imply ans(Q, T ,A) ⊆ ans(Q, T ,A).\nAs discussed in Section 2.3, the logical consequences of a first-order theory are invariant under renaming and merging of individuals. To define analogous properties for abstract reasoners, we first introduce the notions of T -stable and (Q, T )-stable renamings—that is, renamings that leave all individuals occurring in T (respectively, in Q and T ) unchanged.\nDefinition 3.6. Let Q be a query, let T be a TBox, and let µ be a renaming. Then, µ is T - stable if µ(a) = a for each individual a ∈ dom(µ) ∩ ind(T ); furthermore, µ is (Q, T )-stable if µ(a) = a for each individual a ∈ dom(µ) ∩ ind(Q ∪ T ).\nThe following notion of weak faithfulness describes abstract reasoners whose answers are invariant under replacement of individuals with fresh individuals. Furthermore, weak (Q, T )-faithfulness relaxes this property to the case when Q and T are fixed.\nDefinition 3.7. An abstract reasoner ans for DL is weakly faithful if the following conditions hold for each UCQ Q, DL-TBox T , ABox A, injective renaming µ, and tuple a:\n• ans(∗, T ,A) = t and ind(T ∪A) ⊆ dom(µ) imply ans(∗, µ(T ), µ(A)) = t; and\n• ans(∗, T ,A) = f, ind(Q ∪ T ∪A) ⊆ dom(µ), and a ∈ ans(Q, T ,A) imply ans(∗, µ(T ), µ(A)) = f and µ(a) ∈ ans(µ(Q), µ(T ), µ(A)).\nGiven a UCQ Q and a DL-TBox T , ans is weakly (Q, T )-faithful if the following conditions hold for each ABox A, injective renaming µ, and tuple a:\n• ans(∗, T ,A) = t, ind(T ∪A) ⊆ dom(µ), and µ is T -stable imply ans(∗, T , µ(A)) = t; and\n• ans(∗, T ,A) = f, ind(Q ∪ T ∪A) ⊆ dom(µ), µ is (Q, T )-stable, and a ∈ ans(Q, T ,A) imply ans(∗, T , µ(A)) = f and µ(a) ∈ ans(Q, T , µ(A)).\nThe following notion of strong faithfulness describes abstract reasoners whose answers are invariant under merging of individuals. Furthermore, strong (Q, T )-faithfulness relaxes this property to the case when Q and T are fixed.\nDefinition 3.8. An abstract reasoner ans for DL is strongly faithful if the following conditions hold for each UCQ Q, DL-TBox T , ABox A, renaming µ, and tuple a:\n• ans(∗, T ,A) = t implies ans(∗, µ(T ), µ(A)) = t; and\n• ans(∗, T ,A) = f, a ∈ ans(Q, T ,A), and ans(∗, µ(T ), µ(A)) = f imply µ(a) ∈ ans(µ(Q), µ(T ), µ(A)).\nGiven a UCQ Q and a DL-TBox T , ans is strongly (Q, T )-faithful if the following conditions hold for each ABox A, renaming µ, and tuple a:\n• ans(∗, T ,A) = t and µ is T -stable imply ans(∗, T , µ(A)) = t; and\n• ans(∗, T ,A) = f, µ is (Q, T )-stable, a ∈ ans(Q, T ,A), and ans(∗, T , µ(A)) = f imply µ(a) ∈ ans(Q, T , µ(A)).\nThe results that we present in the rest of this paper are applicable only to abstract reasoners that satisfy various combinations of these properties; as a minimum, we require (Q, T )-monotonicity and weak (Q, T )-faithfulness. The abstract reasoners described in Example 3.3 all satisfy these properties. Testing if this is the case for concrete reasoners may, however, be infeasible in practice; indeed, we are not aware of a technique that would allow one to check whether a concrete reasoner satisfies the required properties. We believe, however, that all concrete reasoners commonly used in practice are intended to be sound, monotonic, and at least weakly faithful, and that strong faithfulness is a reasonable assumption in most cases. If a concrete reasoner fails to satisfy some of these properties on certain inputs, this is likely to be due to implementation bugs; thus, any consequent failure of completeness can be seen as a bug, and detecting such situations should be viewed as a part of a more general problem of testing software systems.\nWe next present several examples of abstract reasoners that do not satisfy some of the mentioned properties.\nExample 3.9. Consider an abstract reasoner that behaves as rdf whenever the number of assertions in the input ABox is smaller than a certain threshold, and that returns the empty set of answers for larger ABoxes. Intuitively, such an abstract reasoner characterises a concrete RDF reasoner that processes inputs only up to a certain size. Such a reasoner is not (Q, T )-monotonic for an arbitrary Q and T . ♦\nExample 3.10. Consider an abstract reasoner that behaves like rdf, but that, for trust reasons, removes from each input ABox all assertions whose individuals are ‘blacklisted’ (e.g., they come from an untrusted source). Such an abstract reasoner is not weakly (Q, T )- faithful for an arbitrary Q and T . ♦\nExample 3.10 suggests that, for an abstract reasoner to be weakly faithful, it should not make decisions that depend on specific names of individuals.\nExample 3.11. Consider an abstract reasoner rl= that, given as input a UCQ Q, a TBox T , and an ABox A, proceeds as follows. First, rl= computes the ABox A obtained by evaluating the datalog program Prl from Example 3.3 over A. Second, rl= computes the query Q= obtained from Q by adding to the body of each rule r ∈ Q an inequality x ≈ y for all pairs of distinct variables x and y occurring in r. Third, rl= evaluates Q= over A by considering A as a database—that is, as a finite first-order interpretation in which each individual is mapped to itself (and thus different individuals are distinct). Thus, rl= characterises concrete reasoners that evaluate queries by matching different variables to different individuals. Abstract reasoner rl= is sound, monotonic, and weakly faithful, but it is not strongly faithful. For example, given query Q = {R(x, y) → Q(x)}, ABox A = {R(a, b)}, and renaming µ = {a → c, b → c}, we have rl=(Q, ∅,A) = {a}, but rl=(Q, ∅, µ(A)) = ∅. ♦\nExample 3.11 suggests that, for an abstract reasoner to be strongly faithful, it should allow distinct variables in queries and axioms to be mapped to the same individuals.\nWe next identify classes of abstract reasoners that we use throughout this paper. Note that soundness is not required, which contributes to the generality of our results.\nDefinition 3.12. Given a UCQ Q and a TBox T , CQ,Tw (CQ,Ts ) is the class of all (Q, T )- monotonic and weakly (strongly) (Q, T )-faithful abstract reasoners applicable to T .\nFinally, note that all the abstract reasoners introduced in Example 3.3 are sound, monotonic, and strongly (and therefore also weakly) faithful. Consequently, all concrete reasoners based on reasoning techniques outlined in Example 3.3 can be considered sound, monotonic, and strongly faithful, modulo implementation bugs."
    }, {
      "heading" : "3.2 Completeness of Abstract Reasoners",
      "text" : "We next define the central notion of abstract reasoner completeness for a given query Q and TBox T . Intuitively, a (Q, T )-complete abstract reasoner is indistinguishable from a complete abstract reasoner when applied to Q, T , and an arbitrary ABox A.\nDefinition 3.13. Let DL be a description logic, and let ans be an abstract reasoner for DL. Then, ans is (Q, T )-complete for a UCQ Q and a DL-TBox T if the following conditions hold for each ABox A:\n• if cert(∗, T ,A) = t, then ans(∗, T ,A) = t;\n• if cert(∗, T ,A) = f and ans(∗, T ,A) = f, then cert(Q, T ,A) ⊆ ans(Q, T ,A).\nFinally, ans is complete if it is (Q, T )-complete for each UCQ Q and each DL-TBox T .\nExample 3.14. Consider the EL-TBox T consisting of the following axioms; the translation of the axioms into first-order logic is shown after the  symbol.\n∃takesCo.MathCo  St  ∀x, y.[takesCo(x, y) ∧MathCo(y) → St(x)] (7) CalcCo  MathCo  ∀x.[CalcCo(x) → MathCo(x)] (8)\nMathSt  ∃takesCo.MathCo  ∀x.[MathSt(x) → ∃y.[takesCo(x, y) ∧MathCo(y)]] (9) St  Prof  ⊥  ∀x.[St(x) ∧ Prof(x) → ⊥] (10)\nAxiom (7) states that everyone taking a maths course is a student; axiom (8) states that each calculus course is also a maths course; axiom (9) states that each maths student takes some maths course; and axiom (10) states that no person can be both a student and a professor. Axiom (8) is an RDFS axiom, and all other axioms in T apart from (9) are OWL 2 RL axioms. Consider also query (11) that retrieves students taking a maths course.\nQ = {St(x) ∧ takesCo(x, y) ∧MathCo(y) → Q(x)} (11)\nNone of the abstract reasoners rdf, rdfs, rl, and classify from Example 3.3 are complete in general for answering UCQs over EL-TBoxes. Furthermore, for Q and T from the previous paragraph, abstract reasoners rdf, rdfs, and rl are not (Q, T )-complete, as all of them return the empty set of answers for ABox A = {MathSt(c)}. In contrast, in the following sections we will show that abstract reasoner classify is (Q, T )-complete—that is, that it returns all certain answers to Q, T , and an arbitrary ABox A. ♦"
    }, {
      "heading" : "3.3 Test Suites",
      "text" : "Checking (Q, T )-completeness of a concrete reasoner by applying the reasoner to all possible ABoxes and comparing the reasoner’s answers with that of a complete reasoner is clearly infeasible in practice since there are infinitely many candidate input ABoxes. To obtain a practical approach, we need a finite number of tests. We formalise this idea using the following definition.\nDefinition 3.15. Let T be a TBox. A T -test suite is a pair S = S⊥,SQ where\n• S⊥ is a finite set of ABoxes such that cert(∗, T ,A) = t for each A ∈ S⊥, and\n• SQ is a finite set of pairs A,Y where A is an ABox such that cert(∗, T ,A) = f and Y is a UCQ.\nAn abstract reasoner ans applicable to T passes a T -test suite S if ans satisfies the following two conditions:\n• for each A ∈ S⊥, we have ans(∗, T ,A) = t, and\n• for each A,Y ∈ SQ, if ans(∗, T ,A) = f, then cert(Y, T ,A) ⊆ ans(Y, T ,A).\nLet Q be a UCQ, and let C be a class of abstract reasoners applicable to T . Then, S is exhaustive for C and Q if each ans ∈ C that passes S is (Q, T )-complete.\nA T -test suite S is Q-simple if Q is the only query occurring in SQ; then, SQ is commonly written as just a set of ABoxes, and A,Q ∈ SQ is commonly abbreviated as A ∈ SQ.\nIntuitively, a T -test suite S = S⊥,SQ determines the tests that an abstract reasoner should be subjected to. For a reasoner to pass S, it must correctly identify each ABox A ∈ S⊥ as unsatisfiable, and for each ABox–query pair A,Y ∈ SQ the reasoner must correctly answer Y w.r.t. T and A.\nGiven Q and T , our goal is to identify a T -test suite S that is exhaustive for Q—that is, a test suite such that each abstract reasoner that passes S is guaranteed to be (Q, T )- complete. Depending on the properties of abstract reasoners, however, different test suites may or may not achieve this goal. Therefore, the notion of exhaustiveness is relative to a class of abstract reasoners C: if S is exhaustive for some class of abstract reasoners C, then S can be used to test an arbitrary abstract reasoner in C. Note that S depends on the target class of abstract reasoners, but not on the actual abstract reasoner being tested; in order words, the construction of S depends on the properties that one can assume to hold for the target abstract reasoner. Furthermore, if an abstract reasoner not contained in C passes S, this will in general not imply a (Q, T )-completeness guarantee. Example 3.16. Let Q and T be as specified in Example 3.14, and let A1–A6 be the following ABoxes.\nA1 = {takesCo(c, d),MathCo(d)} A2 = {takesCo(c, c),MathCo(c)} A3 = {takesCo(c, d),CalcCo(d)} A4 = {takesCo(c, c),CalcCo(c)} A5 = {MathSt(c)} A6 = {St(c),Prof(c)}\nIn the following sections, we will show that the Q-simple T -test suite S = S⊥,SQ defined by S⊥ = {A6} and SQ = {A1, . . . ,A5} is exhaustive for the class CQ,Tw and Q; consequently, S can be used to test all abstract reasoners from Example 3.3.\nIn particular, note that abstract reasoners rdf and rdfs fail all tests in S⊥ and SQ, and that abstract reasoner rl fails the test A5 ∈ SQ; furthermore, all failed tests provide a counterexample of (Q, T )-completeness. In contrast, abstract reasoner classify from Example 3.14 passes the tests in S, which implies that the abstract reasoner is indeed (Q, T )-complete.\nFinally, consider a variant of the abstract reasoner classify that, similarly to the abstract reasoner described in Example 3.9, returns the empty set of answers if the input ABox contains more than, say, ten assertions. Such an abstract reasoner is not (Q, T )-monotonic and hence does not belong to CQ,Tw . This abstract reasoner clearly passes S; however, since it does not belong to CQ,Tw , passing S (correctly) does not imply that the abstract reasoner is (Q, T )-complete. ♦\nWe next state the following property, the proof of which is trivial.\nProposition 3.17. Let Q be a UCQ, let T be a TBox, and let C1 and C2 be classes of abstract reasoners applicable to T such that C1 ⊆ C2.\n1. If a T -test suite S is exhaustive for C2 and Q, then S is also exhaustive for C1 and Q.\n2. If no T -test suite exists that is exhaustive for C1 and Q, then no T -test suite exists that is exhaustive for C2 and Q.\nTherefore, when proving existence of a T -test suite exhaustive for Q, the most general result is the one that applies to the largest possible class of abstract reasoners. Furthermore,\nin the following section we will identify cases for which no T -test suite exhaustive for Q can be found; by Proposition 3.17 it suffices to provide nonexistence results for the smallest possible class of abstract reasoners.\nWe finish this section by pointing out an important practically relevant property of Q-simple T -test suites, which has been illustrated in Example 3.16.\nProposition 3.18. Let S = S⊥,SQ be a Q-simple T -test suite and let ans be an abstract reasoner applicable to T . If ans does not pass S, then ans is not (Q, T )-complete.\nProof. The ABox in S⊥ or SQ for which ans does not satisfy the conditions from Definition 3.15 is a counterexample for the (Q, T )-completeness of ans.\nThus, a Q-simple T -test suite S exhaustive for C and Q provides a sufficient and necessary test for (Q, T )-completeness of the abstract reasoners in C. In contrast, if S is not Q-simple, we show in Section 3.7 that then S provides only a sufficient, but not also a necessary test for (Q, T )-completeness of the abstract reasoners in C."
    }, {
      "heading" : "3.4 Negative Results",
      "text" : "In Sections 3.5 (resp. Section 3.6) we identify restrictions on a UCQ Q and a TBox T that guarantee existence of T -test suites exhaustive for CQ,Tw (resp. CQ,Ts ) and Q. Before presenting these positive results, we first outline the limits of (Q, T )-completeness testing and thus justify the restrictions we use in the following sections."
    }, {
      "heading" : "3.4.1 Monotonicity and Weak Faithfulness",
      "text" : "Our approaches for testing (Q, T )-completeness of abstract reasoners are applicable only to reasoners that are (Q, T )-monotonic and weakly (Q, T )-faithful. In this section, we provide a formal justification for these requirements in the form of the following two theorems.\n• Theorem 3.19 shows that exhaustive test suites do not exist if we consider the class of abstract reasoners satisfying all properties from Section 3.1 apart from (Q, T )- monotonicity; this includes soundness, strong faithfulness (which implies weak faithfulness), and monotonicity w.r.t. the TBox only.\n• Theorem 3.20 shows that exhaustive test suites do not exist if we consider the class of abstract reasoners satisfying all properties defined in Section 3.1 with the exception of (Q, T )-weak faithfulness; these properties include soundness and monotonicity.\nThe negative results of Theorems 3.19 and 3.20 are very strong: they hold for smallest classes of abstract reasoners we can define based on the notions introduced in Section 3.1 (by Proposition 3.17, the smaller the class of abstract reasoners, the more general the negative result); and they hold regardless of the Q and T considered (modulo a minor technicality: unlike Theorem 3.19, Theorem 3.20 requires T to be satisfiable).\nThe proof of Theorem 3.19 can intuitively be understood as follows. We first assume that S is a T -test suite exhaustive for Q and the class of abstract reasoners to which the theorem applies. Then, we specify an abstract reasoner ans that ‘does the right thing’ (i.e., it returns the correct answer) when it is given as input the query Q, the TBox T , and\nan arbitrary ABox containing at most as many assertions as the largest test ABox in S; otherwise, ans returns a sound, but an incomplete answer. We finally show the following three properties of ans.\n• Abstract reasoner ans belongs to the relevant class of abstract reasoners.\n• Abstract reasoner ans passes S.\n• Abstract reasoner ans is incomplete for at least one input ABox.\nThese three properties then show that S is not exhaustive for Q and the relevant class of abstract reasoners. Intuitively, this means that the class of abstract reasoners is ‘too large’, allowing abstract reasoners to treat their input in an erratic way.\nTheorem 3.19. Let Q be an arbitrary UCQ, and let T be an arbitrary admissible TBox. Then, no T -test suite exists that is exhaustive for Q and the class of all sound and strongly faithful abstract reasoners applicable to T satisfying the following conditions for each TBox T  with T ⊆ T  and each ABox A:\n• ans(∗, T ,A) = t implies ans(∗, T ,A) = t;\n• ans(∗, T ,A) = f and ans(∗, T ,A) = f imply ans(Q, T ,A) ⊆ ans(Q, T ,A).\nProof. Consider an arbitrary T -test suite S = S⊥,SQ. Let n be the maximum number of assertions in an ABox from S. Furthermore, let ans be the abstract reasoner that takes as input a UCQ Qin, an FOL-TBox Tin, and an ABox Ain. The result of ans(∗, Tin,Ain) is determined as follows.\n1. Try to find a renaming ξ such that dom(ξ) = ind(T ) and ξ(T ) ⊆ Tin; if no such ξ exists, then return f.\n2. If Ain contains at most n assertions, then check the satisfiability of ξ(T ) ∪Ain using a sound and complete reasoner; return t if ξ(T ) ∪Ain is unsatisfiable.\n3. Return f.\nFurthermore, the result of ans(Qin, Tin,Ain) is determined as follows.\n4. Try to find a renaming ξ such that dom(ξ) = ind(Q ∪ T ), ξ(T ) ⊆ Tin, and ξ(Q) = Qin; if no such ξ exists, then return ∅.\n5. If Ain contains at most n assertions, then compute cert(ξ(Q), ξ(T ),Ain) using a sound and complete reasoner and return the result.\n6. Return ∅.\nSince T is admissible, checks in steps 2 and 5 can be performed in finite time; furthermore, step 1 can be realised by enumerating all mappings from ind(T ) to ind(Tin), and step 4 can be realised analogously; consequently, ans can be implemented such that it terminates on all inputs. To see that ans is sound and monotonic w.r.t. the TBox, consider arbitrary input Qin, Tin, T in, and Ain such that Tin ⊆ T in.\n• Assume that ans(∗, Tin,Ain) = t. Then, on Qin, Tin, and Ain the abstract reasoner returns in step 2 because ξ(T ) ∪Ain is unsatisfiable; but then, since ξ(T ) ⊆ Tin, we have that Tin ∪Ain is unsatisfiable as well, as required for soundness. Furthermore, since ξ(T ) ⊆ Tin ⊆ T in, on Qin, T in, and Ain the abstract reasoner returns in step 2 as well, so ans(∗, T in,Ain) = t, as required for monotonicity w.r.t. the TBox.\n• Assume that a ∈ ans(Qin, Tin,Ain). Then, on Qin, Tin, and Ain the abstract reasoner returns in step 5, and therefore we have a ∈ cert(ξ(Q), ξ(T ),Ain); but then, since ξ(Q) = Qin and ξ(T ) ⊆ Tin, we have a ∈ cert(Qin, Tin,Ain), as required for soundness. Furthermore, since ξ(T ) ⊆ Tin ⊆ T in, on Qin, T in, and Ain the abstract reasoner returns in step 5 as well, so a ∈ ans(Qin, T in,Ain), as required for monotonicity w.r.t. the TBox.\nTo see that ans is strongly faithful, consider an arbitrary renaming λ. If renaming ξ exists such that ξ(Q) = Qin and ξ(T ) ⊆ Tin, then clearly renaming ξ exists such that ξ(Q) = λ(Qin) and ξ(T ) ⊆ λ(Tin). Consequently, if ans(∗, Tin,Ain) returns in step 2, then ans(∗,λ(Tin),λ(Ain)) returns in step 2 as well; similarly, if ans(Qin, Tin,Ain) returns in step 5, then ans(λ(Qin),λ(Tin),λ(Ain)) returns in step 5 as well; clearly, ans is strongly faithful. Finally, it is straightforward to see that ans passes S.\nNow let A be an ABox containing at least n + 1 assertions such that cert(Q, ∅,A) = ∅; such A clearly exists. If T ∪A is unsatisfiable, then ans(∗, T ,A) = f; furthermore, if T ∪A is satisfiable, then ans(Q, T ,A) = ∅; consequently, ans is not (Q, T )-complete. Thus, S is not exhaustive for Q and the class of abstract reasoners considered in this theorem.\nWe next prove Theorem 3.20. The proof is similar to the proof of Theorem 3.19, and the main difference is in the abstract reasoner ans we construct. In particular, given a test suite S, we take ans to return the correct answer on the query Q, the TBox T , and each ABox that contains only the individuals occurring in S; otherwise, the abstract reasoner returns a sound, but an incomplete answer. Again, the class of the abstract reasoners is ‘too large’, allowing ans to treat inputs in an erratic way.\nUnlike Theorem 3.19, the following theorem requires T to be satisfiable; to understand why, consider an arbitrary unsatisfiable TBox T and UCQ Q. Let S = S⊥,SQ be the T -test suite defined by S⊥ = {∅} (i.e., S⊥ contains a single empty ABox) and SQ = ∅ (i.e., SQ contains no ABoxes), and consider an arbitrary monotonic abstract reasoner ans that passes S⊥. Since ans passes S, we have ans(∗, T , ∅) = t; but then, since ans is monotonic, for an arbitrary ABox A we have ans(∗, T ,A) = t as well, which in turn implies that ans is (Q, T )-complete. Failure to satisfy weak faithfulness is thus irrelevant if T is unsatisfiable.\nTheorem 3.20. Let T be an arbitrary admissible and satisfiable TBox and let Q be an arbitrary UCQ. Then, no T -test suite exists that is exhaustive for Q and the class of all sound and monotonic abstract reasoners applicable to T .\nProof. Consider an arbitrary T -test suite S = S⊥,SQ. Let I be the set of all individuals occurring in S, Q, and T . Furthermore, let ans be the abstract reasoner that takes as input a UCQ Qin, an FOL-TBox Tin, and an ABox Ain. The result of ans(∗, Tin,Ain) is determined as follows.\n1. If T ⊆ Tin, then return f.\n2. Let Ain,I be the set of assertions in Ain that mention only the individuals in I.\n3. Check the satisfiability of T ∪Ain,I using a sound and complete reasoner; return t if T ∪Ain,I is unsatisfiable, and return f otherwise.\nFurthermore, given a UCQ Qin, the result of ans(Qin, Tin,Ain) is determined as follows:\n4. If T ⊆ Tin or Q = Qin, then return ∅.\n5. Let Ain,I be the set of assertions in Ain that mention only the individuals in I.\n6. Compute cert(Q, T ,Ain,I) using a sound and complete reasoner and return the result.\nThat ans can be implemented such that it terminates on all inputs can be shown as in the proof of Theorem 3.19. Furthermore, the soundness of ans follows from the following two observations.\n• Assume that ans(∗, Tin,Ain) = t. Then, the abstract reasoner returns in step 3 since T ∪Ain,I is unsatisfiable; but then, since T ⊆ Tin and Ain,I ⊆ Ain, we have that Tin ∪Ain is unsatisfiable as well, as required.\n• Assume that a ∈ ans(Qin, Tin,Ain). Then, the abstract reasoner returns in step 6, and therefore we have a ∈ cert(Q, T ,Ain,I); but then, since Q = Qin, T ⊆ Tin, and Ain,I ⊆ Ain, we have a ∈ cert(Qin, Tin,Ain), as required.\nFor monotonicity, consider an arbitrary T in and Ain such that Tin ⊆ T in and Ain ⊆ Ain; clearly, we have T ⊆ T in and Ain,I ⊆ Ain,I ; but then, by monotonicity of first-order logic, ans(∗, Tin,Ain) = t implies ans(∗, T in,Ain) = t, and ans(Q, Tin,Ain) ⊆ ans(Q, T in,Ain). Finally, it is straightforward to see that ans passes S.\nNow consider an arbitrary ABox A such that ind(A) ∩ I = ∅ and cert(Q, ∅,A) = ∅; such A clearly exists. If T ∪A is unsatisfiable, since the ABox constructed in step 2 is empty and T is satisfiable, we have ans(∗, T ,A) = f; furthermore, if T ∪A is satisfiable, since the ABox constructed in step 5 is empty, ans(Q, T ,A) cannot contain individuals not occurring in I; consequently, ans is not (Q, T )-complete. Thus, S is not exhaustive for Q and the class of abstract reasoners considered in this theorem."
    }, {
      "heading" : "3.4.2 Monotonicity and Weak Faithfulness do not Suffice",
      "text" : "Next, we show that (Q, T )-monotonicity and (Q, T )-faithfulness in general do not guarantee existence of a T -test suite exhaustive for Q. In particular, Theorem 3.21 shows that, if T contains a single recursive axiom, no test suite exists that is exhaustive for the class of all sound, monotonic, and strongly faithful abstract reasoners (and by Proposition 3.17 for CQ,Ts and CQ,Tw as well, for each UCQ Q). Although our result is applicable only to a particular Q and T , it is straightforward to adapt the proof to any TBox with a recursive axiom that is ‘relevant’ to the given query. Example 3.22, however, shows that the concept of ‘relevance’ is rather difficult to formalise: even if T entails a recursive axiom, this axiom is not necessarily ‘relevant’ to answering the query. In order not to complicate matters any further, we state the following result for fixed Q and T , and we hope that our proof clearly illustrates the limitations incurred by recursive axioms.\nTheorem 3.21. For Q = {A(x) → Q(x)} and T = {∃R.A  A}, no T -test suite exists that is exhaustive for Q and the class of all sound, monotonic, and strongly faithful abstract reasoners applicable to T .\nProof. Consider an arbitrary T -test suite S = S⊥,SQ. Since S is a T -test suite, S⊥ contains only ABoxes A such that T ∪A is unsatisfiable; clearly, no such ABox exists for T as stated in the theorem, so S⊥ = ∅. Let SQ be an arbitrary, but finite, set of pairs A,Y with A an ABox and Y a UCQ, and let n be the maximum number of assertions in an ABox in SQ. Furthermore, consider the following ABox, where ai = aj for all 1 ≤ i < j ≤ n + 1:\nAn+1 = {R(a0, a1), . . . , R(an, an+1), A(an+1)}\nWe next construct an abstract reasoner pEvaln with the following properties:\n(P1) for each A,Y ∈ SQ, we have cert(Y, T ,A) ⊆ pEvaln(Y, T ,A);\n(P2) a0 ∈ pEvaln(Q, T ,An+1); and\n(P3) pEvaln is sound, monotonic, and strongly faithful.\nNote that a0 ∈ cert(Q, T ,An+1), so the above three properties imply that S is not exhaustive for Q and the class of abstract reasoners considered in this theorem.\nAbstract reasoner pEvaln accepts as input an FOL-TBox Tin and an ABox Ain. The result of pEvaln(∗, Tin,Ain) is determined as follows.\n1. Return f.\nFurthermore, given a UCQ Qin, the result of pEvaln(Qin, Tin,Ain) is determined as follows.\n2. If T ⊆ Tin or Q = Qin, return ∅.\n3. Asat := Ain\n4. Repeat the following computation n times:\n• Asat := Asat ∪ {σ(A(x)) | σ is a substitution s.t. {σ(R(x, y)),σ(A(y))} ⊆ Asat}\n5. Return cert(Q, ∅,Asat).\nAbstract reasoner pEvaln clearly satisfies Property (P2) because deriving the assertion A(a0) requires n+1 iterations of the loop in step 4. Furthermore, pEvaln also satisfies (P1) because every ABox A occurring in SQ contains at most n individuals and T can be seen as the rule R(x, y) ∧A(y) → A(x), which pEvaln applies n times to the input ABox Ain.\nWe finally show (P3). Abstract reasoner pEvaln is clearly sound. Furthermore, for each renaming µ we have µ(T ) = T and µ(Q) = Q, so pEvaln is clearly strongly faithful.\nTo show that pEvaln is monotonic, consider arbitrary Tin, T in, Ain, and Ain such that Tin ⊆ T in and Ain ⊆ Ain; since pEvaln(∗, Tin,Ain) = f for each input, the following are the only relevant cases.\n• pEvaln returns ∅ in step 2 on input Qin, T in, and Ain, in which case either T ⊆ T in or Q = Qin. Since Tin ⊆ T in, clearly pEvaln also returns ∅ in step 2 on input Qin, Tin, and Ain, and monotonicity holds.\n• pEvaln returns in step 5 on input Qin, T in, and Ain. Then, pEvaln can return in either step 2 or step 5 on input Qin, Tin and Ain; in the former case, monotonicity holds trivially, and in the latter case, pEvaln(Qin, Tin,Ain) ⊆ pEvaln(Qin, T in,Ain) follows directly from the fact that Ain ⊆ Ain.\nThe following example shows that the presence of recursive axioms in T does not preclude the existence of a T -test suite exhaustive for Q.\nExample 3.22. Consider Q and T defined as follows:\nQ = {A(x) ∧B(x) → Q(x)} T = {∃R.A  A, B  ∃R.A}\nNote that T contains the axiom mentioned in Theorem 3.21; however, note also that T |= B  A, and so\nR = ∅, {B(x) → Q(x)}\nis a UCQ rewriting of Q w.r.t. T . In Section 3.5 we show that the existence of a UCQ rewriting of Q w.r.t. T guarantees existence of a Q-simple T -test suite that is exhaustive for CQ,Tw (and hence also for CQ,Ts ) and Q; for example, S = ∅, { {B(a)} } is one such T -test suite. Intuitively, T |= B  A is the only consequence of T that is relevant for answering Q; hence, for T  = {B  A} andQ = {A(x) → Q(x)}, we have that cert(Q, T ,A) = cert(Q, T ,A) for an arbitrary ABox A. Hence, the recursive axiom in T is ‘irrelevant’ for answering Q, and therefore its presence in T does not preclude the existence of a T -test suite that is exhaustive for CQ,Tw and Q. ♦\n3.5 Testing (Q, T )-Monotonic and Weakly (Q, T )-Faithful Abstract Reasoners\nIn this section, we identify a sufficient condition that guarantees existence of a Q-simple T -test suite S exhaustive for CQ,Tw and Q; by Proposition 3.17, this result applies to CQ,Ts as well. Roughly speaking, such S can always be computed by ‘instantiating’ the rules in a UCQ rewriting of Q w.r.t. T in a suitable way. The requirement that Q should be UCQrewritable w.r.t. T invalidates the negative result of Theorem 3.21 since no UCQ rewriting of Q = {A(x) → Q(x)} w.r.t. T = {∃R.A  A} exists.\nThis result allows one to compute Q-simple T -test suites exhaustive for Q in numerous practically relevant cases. In particular, a UCQ rewriting is guaranteed to exist if T is expressed in the DLs underpinning the QL profile of OWL 2 (Motik et al., 2009a; Calvanese et al., 2007); furthermore, as illustrated in Example 3.22, a UCQ rewriting may exist even if T is expressed in other fragments of OWL 2 such as the OWL 2 EL (Motik et al., 2009a; Baader, Brandt, & Lutz, 2005). In practice, such rewritings can be computed using systems such as QuOnto (Acciarri et al., 2005) and REQUIEM (Pérez-Urbina et al., 2010).\nWe establish the desired result in two steps. First, in Section 3.5.1 we present a general characterisation of Q-simple T -test suites exhaustive for CQ,Tw and Q. Then, in Section 3.5.2 we use this characterisation to establish the desired connection between rewritings and Q-simple T -test suites exhaustive for Q."
    }, {
      "heading" : "3.5.1 Characterisation of Simple and Exhaustive Test Suites",
      "text" : "We next prove that a Q-simple T -test suite S = S⊥,SQ is exhaustive for CQ,Tw and Q if and only if S contains an isomorphic copy of each ‘data pattern’ (i.e., a subset of an ABox) that can produce a certain answer to Q and ∗ w.r.t. T , but that ‘preserves’ the identity of the individuals occurring in T and Q. To show that this is not just a sufficient, but also a necessary condition for the existence of an exhaustive T -test suite, we observe that, if S does not contain one such copy of a ‘data pattern’, we can always find an abstract reasoner in CQ,Tw that passes S but that misses certain answers obtained via the missing data pattern and that is therefore not (Q, T )-complete.\nTheorem 3.23. Let Q be a UCQ, let T be an admissible TBox, and let S = S⊥,SQ be a Q-simple T -test suite. Then, S is exhaustive for CQ,Tw and Q if and only if the following properties are satisfied for each ABox A.\n1. If T ∪A is unsatisfiable, then there exist an ABox A ∈ S⊥ and an injective T -stable renaming µ such that dom(µ) = ind(T ∪A) and µ(A) ⊆ A.\n2. If T ∪A is satisfiable, then for each tuple a ∈ cert(Q, T ,A) there exist an ABox A ∈ SQ, a tuple b ∈ cert(Q, T ,A), and an injective (Q, T )-stable renaming µ such that µ(b) = a, dom(µ) = ind(Q ∪ T ∪A), and µ(A) ⊆ A.\nProof. (⇐) Let S be an arbitrary Q-simple T -test suite that satisfies Properties 1 and 2; we next show that S is exhaustive for CQ,Tw and Q. Consider an arbitrary abstract reasoner ans ∈ CQ,Tw that passes S—that is, ans satisfies the following two properties:\n(a) ans(∗, T ,A) = t for each A ∈ S⊥, and\n(b) ans(∗, T ,A) = f implies cert(Q, T ,A) ⊆ ans(Q, T ,A) for each A ∈ SQ.\nWe next show that ans is (Q, T )-complete—that is, that ans satisfies the two conditions in Definition 3.13 for an arbitrary ABox A. For an arbitrary such A, we have the following two possibilities, depending on the satisfiability of T ∪A.\nAssume that T ∪ A is unsatisfiable. Since S satisfies Property 1, there exist an ABox A ∈ S⊥ and an injective T -stable renaming µ s.t. dom(µ) = ind(T ∪A) and µ(A) ⊆ A. By Condition (a) we have ans(∗, T ,A) = t. Since ans is weakly (Q, T )-faithful, µ is injective and T -stable, and dom(µ) = ind(T ∪A), we have ans(∗, T , µ(A)) = t; finally, since ans is (Q, T )-monotonic and µ(A) ⊆ A, we have ans(∗, T ,A) = t, as required by Definition 3.13.\nAssume that T ∪ A is satisfiable and ans(∗, T ,A) = f. Furthermore, consider an arbitrary tuple a ∈ cert(Q, T ,A). Since S satisfies Property 2, there exist an ABox A ∈ SQ, a tuple b ∈ cert(Q, T ,A), and an injective (Q, T )-stable renaming µ such that µ(b) = a, dom(µ) = ind(Q ∪ T ∪A), and µ(A) ⊆ A. Since µ(A) ⊆ A, ans(∗, T ,A) = f, and ans is (Q, T )-monotonic, we have ans(∗, T , µ(A)) = f; furthermore, ind(T ∪A) ⊆ dom(µ), µ is injective and (Q, T )-stable, and ans is weakly (Q, T )-faithful, so ans(∗, T , µ(A)) = f implies ans(∗, T ,A) = f. But then, by Condition (b) we have cert(Q, T ,A) ⊆ ans(Q, T ,A), so b ∈ ans(Q, T ,A). Since ans is weakly (Q, T )-faithful, µ is injective and (Q, T )-stable, and dom(µ) = ind(Q ∪ T ∪A), we have µ(b) ∈ ans(Q, T , µ(A)); since µ(b) = a, we have\na ∈ ans(Q, T , µ(A)); finally, since ans is (Q, T )-monotonic and µ(A) ⊆ A, we then have a ∈ ans(Q, T ,A), as required by Definition 3.13.\n(⇒) Assume that S is exhaustive for CQ,Tw and Q; we next show that Properties 1 and 2 are satisfied for an arbitrary ABoxA. To this end, we consider a particular abstract reasoner ans for which we prove that ans ∈ CQ,Tw and that ans passes S; this abstract reasoner will help us identify the ABox, the tuple, and the renaming required to prove Properties 1 and 2.\nLet ans be the abstract reasoner that takes as input a UCQ Qin, an FOL-TBox Tin, and an ABox Ain. The result of ans(∗, Tin,Ain) is determined as follows.\n1. If T = Tin, then return f.\n2. For each ABox A ∈ S⊥, do the following.\n(a) Check the satisfiability of T ∪ A using a sound, complete, and terminating reasoner.\n(b) If T ∪A is unsatisfiable, and if an injective T -stable renaming µ exists such that dom(µ) = ind(T ∪A) and µ(A) ⊆ Ain, then return t.\n3. Return f.\nFurthermore, the result of ans(Qin, Tin,Ain) is determined as follows.\n4. If T = Tin or Q = Qin, then return ∅.\n5. Out := ∅.\n6. For each tuple a of constants occurring in Ain of arity equal to the arity of the query predicate of Q, and for each A ∈ SQ do the following.\n(a) Compute C := cert(Q, T ,A) using a sound, complete and terminating reasoner. (b) If a tuple b ∈ C and an injective (Q, T )-stable renaming µ exist such that\nµ(b) = a, dom(µ) = ind(Q ∪ T ∪A), and µ(A) ⊆ Ain, then add a to Out.\n7. Return Out.\nWe next show that ans belongs to CQ,Tw ; to this end, we prove that ans terminates on all inputs, and that it is (Q, T )-monotonic and weakly (Q, T )-faithful. Termination. Since T is admissible, checking satisfiability of T ∪A and the computation of cert(Q, T ,A) are decidable, so the relevant sound, complete and terminating reasoners exist. Furthermore, checking whether a T -stable (resp. (Q, T )-stable) injective renaming µ exists can be done by enumerating all renamings from ind(T ∪A) (resp. ind(Q ∪ T ∪A)) to ind(T ∪Ain) (resp. ind(Q ∪ T ∪Ain)). Therefore, ans can be implemented such that it terminates on each input. (Q, T )-Monotonicity. Consider arbitrary input Qin, Tin, Ain, and Ain such that Ain ⊆ Ain.\n• Assume that ans(∗, Tin,Ain) = t, so on Tin and Ain the abstract reasoner terminates in step 2(b) for some A ∈ S⊥ and µ. But then, since µ(A) ⊆ Ain ⊆ Ain, on Tin and Ain the abstract reasoner also terminates in step 2(b), so ans(∗, Tin,Ain) = t, as required.\n• Assume that ans(∗, Tin,Ain) = f and ans(∗, Tin,Ain) = f, and consider an arbitrary tuple a ∈ ans(Qin, Tin,Ain). Then a is added to Out in step 7(b) for some A ∈ SQ and µ. But then, since µ(A) ⊆ Ain ⊆ Ain, on Qin, Tin, and Ain the abstract reasoner also adds a to Out in step 7(b), so a ∈ ans(Qin, Tin,Ain), as required.\nWeak (Q, T )-Faithfulness. Consider an arbitrary input Qin, Tin, and Ain, and an arbitrary injective renaming λ.\n• Assume that ans(∗, Tin,Ain) = t, dom(λ) ⊆ ind(T ∪A), and λ is T -stable. Thus, on Tin and Ain the abstract reasoner terminates in step 2(b) for some A ∈ S⊥ and µ. Let µ be the renaming such that µ(c) = λ(µ(c)) for each c ∈ ind(T ∪A). Clearly, we have dom(µ) = ind(T ∪A), renaming µ is T -stable and injective, and µ(A) ⊆ λ(Ain). Thus, on Tin and λ(Ain) the abstract reasoner terminates in step 2(b), so we therefore have ans(∗, Tin,λ(Ain)) = t, as required.\n• Assume that ans(∗, Tin,Ain) = f, dom(λ) ⊆ ind(Q ∪ T ∪A), and λ is (Q, T )-stable, and consider an arbitrary truple a ∈ ans(Qin, Tin,Ain). Then a is added to Out in step 7(b) for some A ∈ SQ, µ, and b. Let µ be the renaming defined s.t. µ(c) = λ(µ(c)) for each individual c ∈ ind(Q ∪ T ∪A). Clearly, we have dom(µ) = ind(Q ∪ T ∪A), renaming µ is (Q, T )-stable and injective, µ(A) ⊆ λ(Ain), and µ(b) = λ(a). Thus, on Qin, Tin, and λ(Ain) the abstract reasoner terminates in step 7(b) and we clearly have λ(a) ∈ ans(Qin, Tin,λ(Ain)), as required.\nThis concludes the proof that ans ∈ CQ,Tw . Furthermore, ans clearly passes S; but then, since S is exhaustive for CQ,Tw and Q, abstract reasoner ans is (Q, T )-complete. We next prove the main claim of this theorem. To this end, consider an arbitrary ABox A; we have the following possibilities, depending on the satisfiability of T ∪A.\n• Assume that T ∪A is unsatisfiable. Then ans(∗, T ,A) = t, so the abstract reasoner returns in step 2(b) for some ABox A ∈ S⊥ and some T -stable renaming µ such that µ(A) ⊆ A and dom(µ) = ind(T ∪A). Thus, Property 1 holds as required.\n• Assume that T ∪A is satisfiable, and consider an arbitrary tuple a ∈ cert(Q, T ,A). Then ans(∗, T ,A) = f and a ∈ ans(Q, T ,A), so a is added to Out in step 7(b) for some ABox A ∈ SQ, tuple b ∈ cert(Q, T ,A), and an injective (Q, T )-stable renaming µ such that µ(b) = a, dom(µ) = ind(Q ∪ T ∪A), and µ(A) ⊆ A. Thus, Property 2 holds as required.\nThe following example illustrates Theorem 3.23.\nExample 3.24. Let Q and T be as specified in Example 3.14, and let S = S⊥,SQ be specified in Example 3.16. As we show in Section 3.5.2, S is exhaustive for CQ,Tw and Q.\nConsider now an ABox A = {St(a),MathSt(b), takesCo(a, b1)}. Clearly, T ∪ A is satisfiable and cert(Q, T ,A) = {b}. By Theorem 3.23, this certain answer can be obtained by evaluating Q w.r.t. T and an ABox in SQ. Indeed, note that ABox A5 ∈ SQ is isomorphic to the subset A = {MathSt(b)} of A via renaming µ = {b → c}, and that applying Q to T and A5 produces c, which is isomorphic to b via µ.\nNote also that, if we remove A5 from S, we no longer have a T -test suite that is exhaustive for Q. For example, abstract reasoner rl from Example 3.16 would pass such a test suite, but it would not return the required certain answers when applied to A5 (and, consequently, when applied to A either). ♦\n3.5.2 Computing Test Suites Exhaustive for CQ,Tw Based on Theorem 3.23, in this section we show that a T -test suite exhaustive for CQ,Tw and Q an be obtained by instantiating a UCQ rewriting R of Q w.r.t. T —that is, by replacing all variables in R with individuals in all possible ways. Please note that such an instantiation must be full, in the sense that all possible replacements must be considered. This is because the class CQ,Tw can contain abstract reasoners such as rl= from Example 3.11 that are not strongly faithful and that may incorrectly handle the case when distinct variables are bound to the same individuals.\nDefinition 3.25. Let I be a set of individuals, let r be a datalog rule, and let σ be a substitution. Then, σ is an instantiation substitution for r w.r.t. I if σ(x) ∈ I for each variable x occurring in r. If the latter holds, then the instantiation of r w.r.t. σ is the ABox\nArσ := {σ(B) | B ∈ body(r)}.\nLet Q be a UCQ, let T be a TBox, let R = R⊥,RQ be a UCQ rewriting of Q w.r.t."
    }, {
      "heading" : "T , let m be the maximum number of distinct variables occurring in a rule in R, and let I be a set containing all individuals occurring in R, Q, and T , as well as m fresh individuals.",
      "text" : "The full instantiation of R w.r.t. I is the pair ER,I = ER,I⊥ ,E R,I Q  where E R,I ⊥ and E R,I Q are the smallest sets of ABoxes such that\n• Arσ ∈ E R,I ⊥ for each r ∈ R⊥ and each instantiation substitution σ for r w.r.t. I, and\n• Arσ ∈ E R,I Q for each r ∈ RQ and each instantiation substitution σ for r w.r.t. I such\nthat cert(∗,R⊥,Arσ) = f.\nER,I is clearly unique up to the renaming of the fresh individuals in I, so I is typically left implicit, and one talks of the full instantiation ER = ER⊥ ,ERQ of R.\nExample 3.26. Let Q and T be as specified in Example 3.14, and let R = R⊥,RQ be such that R⊥ = {St(x) ∧ Prof(x) → ⊥} and RQ consists of the following datalog rules:\ntakesCo(x, y) ∧MathCo(y) → Q(x) takesCo(x, y) ∧ CalcCo(y) → Q(x)\nMathSt(x) → Q(x)\nThen, R is a UCQ rewriting of Q w.r.t. T , and one can see that the Q-simple T -test suite S = S⊥,SQ from Example 3.16 is the full instantiation of R. ♦\nThe following theorem shows that the full instantiation of a UCQ rewriting of Q w.r.t. T is a Q-simple T -test suite exhaustive for CQ,Tw and Q. According to this theorem, the T -test suite S in Example 3.26 is exhaustive for CQ,Tw and Q.\nTheorem 3.27. Let Q be a UCQ, let T be an admissible TBox, let R = R⊥,RQ be a UCQ rewriting of Q w.r.t. T , and let ER = ER⊥ ,ERQ be the full instantiation of R. Then, ER is a Q-simple T -test suite that is exhaustive for CQ,Tw and Q.\nProof. Let I be the set of individuals that ER is obtained from. We first show that ER is a Q-simple T -test suite—that is, that it satisfies the two properties in Definition 3.15.\n• Consider an arbitrary ABox A ∈ ER⊥ . Then, a rule r ∈ R⊥ and an instantiation substitution σ for r exist such that A = Arσ; clearly cert(∗, {r},A) = t; since R is a UCQ rewriting, T ∪A is unsatisfiable, as required.\n• Consider an arbitrary ABox A ∈ ERQ . Then, cert(∗,R⊥,A) = f by Definition 3.25; since R is a UCQ rewriting, T ∪A is satisfiable, as required.\nWe next show that ER satisfies Properties 1 and 2 of Theorem 3.23 for an arbitrary ABox A.\n(Property 1) Assume that T ∪A is unsatisfiable. Since R is a UCQ rewriting, by Definition 2.2 we have cert(∗,R⊥,A) = t; but then, a rule r ∈ R⊥ and a substitution ρ exist such that Arρ ⊆ A and cert(∗, {r},Arρ) = t. Let ν be an injective renaming such that for each individual c occurring in R or T we have ν(c) = c, and for each individual d occurring in Arρ but not in R and T we have that ν(d) is a fresh individual in I; such ν exists since the number of variables in r is smaller or equal to the number of fresh individuals in I. Let σ be an instantiation substitution for r such that σ(x) = ν(ρ(x)) for each variable x occurring in r; then Arσ ∈ ER⊥ holds since ER is the full instantiation of R w.r.t. I. Let µ be any injective renaming that coincides with the inverse of ν on each individual occurring in Arσ, R, or T ; such µ exists since ν is injective and the range of ν contains each individual occurring in Arσ, R, and T . Clearly µ(Arσ) = Arρ holds, so µ(Arσ) ⊆ A. Furthermore, µ is clearly T -stable. Thus, Property (1) is satisfied for Arσ ∈ ER⊥ and µ.\n(Property 2) Assume that T ∪A is satisfiable, and consider an arbitrarily chosen tuple a ∈ cert(Q, T ,A). Since R is a UCQ rewriting, by Definition 2.2 we have cert(∗,R⊥,A) = f and a ∈ cert(RQ,R⊥,A); but then, clearly a ∈ cert(RQ, ∅,A) as well. Then, a rule r ∈ RQ and a substitution ρ exist such that Arρ ⊆ A and a ∈ cert({r}, ∅,Arρ). Let ν be an injective renaming such that for each individual c occurring in R, Q, or T we have ν(c) = c, and for each individual d occurring in Arρ but not in R, Q, and T we have that ν(d) is a fresh individual in I; such ν clearly exists since the number of variables in r is smaller or equal to the number of fresh individuals in I. Let σ be an instantiation substitution for r such that σ(x) = ν(ρ(x)) for each variable x occurring in r; then Arσ ∈ ERQ holds since ER is the full instantiation of R w.r.t. I. Let µ be any injective renaming that coincides with the inverse of ν on each individual occurring in Arσ, R, Q, or T ; such µ exists since ν is injective and the range of ν contains each individual occurring in Arσ, R, Q, and T . Furthermore, clearly a tuple b ∈ cert({r}, ∅,Arσ) exists such that σ(head(r)) = Q(b); since R is a UCQ rewriting and T ∪Arσ is satisfiable, we have b ∈ cert(Q, T ,Arσ); furthermore, since µ is injective, µ(b) = a clearly holds. But then, Property (2) is satisfied for Arσ ∈ ERQ , µ, and b."
    }, {
      "heading" : "3.5.3 Minimising Exhaustive Test Suites",
      "text" : "In practice, it is clearly beneficial to compute test suites that are as ‘small’ as possible. This goal can be achieved by applying known techniques for minimising UCQ rewritings (Calvanese et al., 2007; Pérez-Urbina, Horrocks, & Motik, 2009). By Theorem 3.27, the smallest such rewriting can be instantiated to obtain an exhaustive test suite.\nState of the art query rewriting systems employ subsumption and condensation techniques in order to reduce the size of a rewriting. A datalog rule r subsumes a datalog rule r if a substitution σ exists such that σ(r) ⊆ r; intuitively, r is then ‘more general’ than r. If a rewriting contains such rules r and r, then r can be safely removed from the rewriting. Furthermore, if a rule r contains distinct unifiable body atoms Bi and Bj , a condensation of r is the rule σ(r) where σ is the most general unifier of Bi and Bj . If a rewriting contains such rule r and σ(r) subsumes r, the rule can safely be replaced with σ(r). The following example illustrates how these techniques can be used to obtain small test suites.\nExample 3.28. Let Q and T be as specified in Example 3.14, and let R be the rewriting of Q w.r.t. T from Example 3.26. Then R = R⊥,RQ where RQ consists of the following rules is also a UCQ rewriting of Q w.r.t. T .\ntakesCo(x, y) ∧ takesCo(x, z) ∧MathCo(y) → Q(x) (12) takesCo(x, x) ∧ CalcCo(x) ∧MathCo(x) → Q(x) (13)\ntakesCo(x, y) ∧ CalcCo(y) → Q(x) (14) St(x) ∧MathSt(x) → Q(x) (15)\nMathSt(x) → Q(x) (16)\nBy Theorem 3.27, the full instantiation of R is also a T -test suite exhaustive for CQ,Tw and Q. The rewriting R, however, contains redundancy and hence the resulting test suite is unnecessarily large. In particular, by applying condensation to query (12), subsumption to queries (13) and (14), and subsumption again to queries (15) and (16), we can obtain the simpler rewriting R. ♦\nFinally, note that the test suites obtained via full instantiation can contain isomorphic ABoxes. Clearly, all isomorphic copies of an ABox can safely be eliminated from a test suite without losing exhaustiveness for CQ,Tw and Q.\n3.6 Testing (Q, T )-Monotonic and Strongly (Q, T )-Faithful Abstract Reasoners Due to full instantiation, test suites obtained by Definition 3.25 can be exponentially larger than the rewriting they are generated from. As a result, even rewritings of moderate size can yield test suites containing thousands of ABoxes. Intuitively, full instantiation is required to obtain a test suite exhaustive for the class CQ,Tw because this class contains abstract reasoners such as rl= from Example 3.11, which do not correctly handle the case when distinct variables in a query are matched to the same individual.\nIn this section, we show that test suites exhaustive for the class CQ,Ts can be obtained by an injective instantiation of a rewriting—that is, by replacing each variable with a distinct fresh individual. Test suites obtained in such a way are linear in the size of the rewriting, and are thus substantially smaller than test suites obtained by full instantiation.\nExample 3.29. Let Q and T be as specified in Example 3.14, and let S = S⊥,SQ be the Q-simple T -test suite from Example 3.16. Furthermore, consider the abstract reasoner rl= from Example 3.11 that is weakly, but not strongly (Q, T )-faithful. It is easy to check that rl= returns complete answers on A1 and A3, but not on A2 and A4. Therefore, by Theorem 3.27, for S to be exhaustive for CQ,Tw and Q, we must include in SQ ABoxes A2 and A4, which are respectively obtained from ABoxes A1 and A3 by merging individual d into c.\nStrongly (Q, T )-faithful abstract reasoners, however, correctly handle inputs obtained by merging individuals. Based on this observation, in this section we show that the Q-simple T -test suite S = S⊥,SQ where SQ = {A1,A3,A5}, obtained by injectively instantiating the rewriting R from Example 3.26, is exhaustive for CQ,Ts and Q. ♦\nAs in Section 3.5, we first develop a characterisation of Q-simple T -test suites that are exhaustive for CQ,Ts and Q; this result is analogous to Theorem 3.23.\nTheorem 3.30. Let Q be a UCQ, let T be an admissible TBox, and let S = S⊥,SQ be a Q-simple T -test suite. Then, S is exhaustive for CQ,Ts and Q if and only if the following properties are satisfied for each ABox A.\n1. If T ∪A is unsatisfiable, then there exist an ABox A ∈ S⊥ and a T -stable renaming µ such that dom(µ) = ind(T ∪A) and µ(A) ⊆ A.\n2. If T ∪A is satisfiable, then for each tuple a ∈ cert(Q, T ,A) there exist an ABox A ∈ SQ, a tupleb ∈ cert(Q, T ,A), and a (Q, T )-stable renaming µ such that µ(b) = a, dom(µ) = ind(Q ∪ T ∪A), and µ(A) ⊆ A.\nProof. (⇐) Let S be an arbitrary Q-simple T -test suite that satisfies Properties 1 and 2; we next show that S is exhaustive for CQ,Ts and Q. Consider an arbitrary abstract reasoner ans ∈ CQ,Ts that passes S—that is, ans satisfies the following two properties:\n(a) ans(∗, T ,A) = t for each A ∈ S⊥, and\n(b) ans(∗, T ,A) = f implies cert(Q, T ,A) ⊆ ans(Q, T ,A) for each A ∈ SQ.\nWe next show that ans is (Q, T )-complete—that is, that ans satisfies the two conditions in Definition 3.13 for an arbitrary ABox A. For an arbitrary such A, we have the following two possibilities, depending on the satisfiability of T ∪A.\nAssume that T ∪ A is unsatisfiable. Since S satisfies Property 1, there exist an ABox A ∈ S⊥ and a T -stable renaming µ such that dom(µ) = ind(T ∪A) and µ(A) ⊆ A. By Condition (a) we have ans(∗, T ,A) = t. Since ans is strongly (Q, T )-faithful and µ is T - stable, we have ans(∗, T , µ(A)) = t; finally, since ans is (Q, T )-monotonic and µ(A) ⊆ A, we have ans(∗, T ,A) = t, as required by Definition 3.13.\nAssume that T ∪ A is satisfiable and ans(∗, T ,A) = f. Furthermore, consider an arbitrary tuple a ∈ cert(Q, T ,A). Since S satisfies Property 2, there exist an ABox A ∈ SQ, a tupleb ∈ cert(Q, T ,A), and a (Q, T )-stable renaming µ such that µ(b) = a, µ(A) ⊆ A, and dom(µ) = ind(Q ∪ T ∪A). Since µ(A) ⊆ A, ans(∗, T ,A) = f, and ans is (Q, T )-monotonic, we have ans(∗, T , µ(A)) = f; furthermore, µ is (Q, T )-stable and ans is strongly faithful, so ans(∗, T , µ(A)) = f implies ans(∗, T ,A) = f. But then, by Condition (b) we have cert(Q, T ,A) ⊆ ans(Q, T ,A), sob ∈ ans(Q, T ,A). Now ans is strongly (Q, T )-faithful and\nµ is (Q, T )-stable, so µ(b) ∈ ans(Q, T , µ(A)); since µ(b) = a, we have a ∈ ans(Q, T , µ(A)); finally, since ans is (Q, T )-monotonic and µ(A) ⊆ A, we have a ∈ ans(Q, T ,A), as required by Definition 3.13.\n(⇒) Assume that S is exhaustive for CQ,Ts and Q; we next show that Properties 1 and 2 are satisfied for an arbitrary ABoxA. To this end, we consider a particular abstract reasoner ans for which we prove that ans ∈ CQ,Ts and that ans passes S; this abstract reasoner will help us identify the ABox, the tuple, and the renaming required to prove Properties 1 and 2.\nLet ans be the abstract reasoner that takes as input a UCQ Qin, an FOL-TBox Tin, and an ABox Ain. The result of ans(∗, Tin,Ain) is determined as follows.\n1. If T = Tin, then return f.\n2. For each ABox A ∈ S⊥, do the following.\n(a) Check the satisfiability of T ∪ A using a sound, complete, and terminating reasoner.\n(b) If T ∪A is unsatisfiable, and if a T -stable renaming µ exists such that dom(µ) = ind(T ∪A) and µ(A) ⊆ Ain, then return t.\n3. Return f.\nFurthermore, the result of ans(Qin, Tin,Ain) is determined as follows.\n4. If T = Tin or Q = Qin, then return ∅.\n5. Out := ∅.\n6. For each tuple a of constants occurring in Ain of arity equal to the arity of the query predicate of Q, and for each A ∈ SQ do the following.\n(a) Compute C := cert(Q, T ,A) using a sound, complete and terminating reasoner. (b) If a tuple b ∈ C and a (Q, T )-stable renaming µ exist such that µ(b) = a,\ndom(µ) = ind(Q ∪ T ∪A), and µ(A) ⊆ Ain, then add a to Out.\n7. Return Out.\nWe next show that ans belongs to CQ,Ts . The proofs that ans terminates and that it is (Q, T )-monotonic are analogous to the proofs in Theorem 3.23. To show strong (Q, T )- faithfulness, consider an arbitrary Qin, Tin, and Ain, and an arbitrary renaming λ.\n• Assume that ans(∗, Tin,Ain) = t and λ is T -stable. Thus, on Tin and Ain the abstract reasoner terminates in step 2(b) for some A ∈ S⊥ and µ. Let µ be the renaming such that µ(c) = λ(µ(c)) for each c ∈ ind(T ∪A). Clearly, we have dom(µ) = ind(T ∪A), renaming µ is T -stable, and µ(A) ⊆ λ(Ain). Thus, on Tin and λ(Ain) the abstract reasoner terminates in step 2(b), so we have ans(∗, Tin,λ(Ain)) = t, as required.\n• Assume that ans(∗, Tin,Ain) = f and λ is (Q, T )-stable, and consider an arbitrary tuple a ∈ ans(Qin, Tin,Ain). Then a is added to Out in step 7(b) for some A ∈ SQ,\nµ, and b. Let µ be the renaming defined such that µ(c) = λ(µ(c)) for each individual c ∈ ind(Q ∪ T ∪A). Clearly, we have dom(µ) = ind(Q ∪ T ∪A), mapping µ is (Q, T )-stable, µ(A) ⊆ λ(Ain), and µ(b) = λ(a). Thus, on Qin, Tin, and λ(Ain) the abstract reasoner terminates in step 7(b), so λ(a) ∈ ans(Qin, Tin,λ(Ain)), as required.\nThis concludes the proof that ans ∈ CQ,Ts . Furthermore, ans clearly passes S; but then, since S is exhaustive for CQ,Ts and Q, abstract reasoner ans is (Q, T )-complete. The main claim of this theorem can now be shown as in Theorem 3.23.\nWe next use Theorem 3.30 to show that a Q-simple T -test suite that is exhaustive for CQ,Ts and Q can be obtained as an injective instantiation of a UCQ rewriting of Q w.r.t. T .\nDefinition 3.31. Let Q be a UCQ, let T be a TBox, let R = R⊥,RQ be a UCQ rewriting of Q w.r.t. T , and let λ be a substitution mapping each variable occurring in R into a distinct fresh individual. The injective instantiation of R w.r.t. λ is the pair IR,λ = IR,λ⊥ , I R,λ Q  where IR,λ⊥ and I R,λ Q are the smallest sets of ABoxes such that\n• Arλ ∈ I R,λ ⊥ for each r ∈ R⊥, and\n• Arλ ∈ I R,λ Q for each r ∈ RQ such that cert(∗,R⊥,Arλ) = f.\nIR,λ is clearly unique up to the renaming of the fresh individuals in λ, so λ is typically left implicit, and one talks of the injective instantiation IR = IR⊥ , IRQ of R.\nTheorem 3.32. Let Q be a UCQ, let T be an admissible TBox, let R = R⊥,RQ be a UCQ rewriting of Q w.r.t. T , and let IR = IR⊥ , IRQ be the injective instantiation of R. Then, IR is a Q-simple T -test suite that is exhaustive for CQ,Ts and Q.\nProof. Let λ be the substitution that IR is obtained from. We first show that IR is a Q-simple T -test suite—that is, that it satisfies the two properties in Definition 3.15.\n• Consider an arbitrary A ∈ IR⊥ . Then, a rule r ∈ R⊥ exist such that A = Arλ; clearly cert(∗, {r},A) = t; since R is a UCQ rewriting, T ∪A is unsatisfiable, as required.\n• Consider an arbitrary A ∈ IRQ . Then, cert(∗,R⊥,A) = f by Definition 3.31; since R is a UCQ rewriting, T ∪A is satisfiable, as required.\nWe next show that IR satisfies Properties 1 and 2 of Theorem 3.30 for an arbitrary ABox A.\n(Property 1) Assume that T ∪A is unsatisfiable. Since R is a UCQ rewriting, by Definition 2.2 we have cert(∗,R⊥,A) = t; but then, a rule r ∈ R⊥ and a substitution ρ exist such that Arρ ⊆ A and cert(∗, {r},Arρ) = t. Let µ be a renaming such that for each individual c occurring in R or T we have µ(c) = c, and for each variable x in r we have µ(λ(x)) = ρ(x). Clearly, µ(Arλ) = Arρ, so µ(Arλ) ⊆ A. Furthermore, it is clear that µ is T -stable. Thus, Property (1) holds for Arλ ∈ IR⊥ and µ.\n(Property 2) Assume that T ∪A is satisfiable, and consider an arbitrarily chosen tuple a ∈ cert(Q, T ,A). Since R is a UCQ rewriting, by Definition 2.2 we have cert(∗,R⊥,A) = f and a ∈ cert(RQ,R⊥,A); but then, clearly a ∈ cert(RQ, ∅,A) as well. Then, a rule r ∈ RQ\nand a substitution ρ exist such that Arρ ⊆ A and a ∈ cert({r}, ∅,Arρ). Let µ be the renaming such that for each individual c occurring in R, Q, or T we have µ(c) = c, and for each variable x in r we have µ(λ(x)) = ρ(x). Clearly, µ(Arλ) = Arρ, so µ(Arλ) ⊆ A. Furthermore, it is clear that µ is (Q, T )-stable. Finally, clearly a tuple b ∈ cert({r}, ∅,Arλ) exists such that λ(head(r)) = Q(b); since R is a UCQ rewriting and T ∪Arλ is satisfiable, we have b ∈ cert(Q, T ,Arλ); furthermore, µ(b) = a clearly holds. But then, Property (2) is satisfied for Arλ ∈ IRQ , µ, and b."
    }, {
      "heading" : "3.7 Dealing with Recursive Axioms",
      "text" : "The negative result in Theorem 3.21 (which applies to both CQ,Tw and CQ,Ts ) depends on the presence of a recursive axiom in the TBox; thus, the positive results in Sections 3.5 and 3.6 require the input UCQ to be rewritable w.r.t. the input TBox, which effectively prohibits recursion in TBox axioms. Instead of disallowing recursive axioms, in this section we overcome the limitation of Theorem 3.21 by placing additional requirements on the abstract reasoners by requiring them to be first-order reproducible. Intuitively, the latter means that the reasoner’s behaviour can be seen as complete reasoning in some unknown first-order theory. Such abstract reasoners are not allowed to partially evaluate recursive axioms, which invalidates the approach used to prove Theorem 3.21.\nWe show that a T -test suite exhaustive for Q and the class of first-order reproducible abstract reasoners can be obtained by instantiating a datalog±,∨ rewriting of Q w.r.t. T . Such rewritings exist for a wide range of TBoxes and queries, which in turn allows our results to be applicable to a range of practically interesting cases. In contrast to test suites computed from a UCQ rewriting, however, the test suites obtained from a datalog±,∨ rewriting may not be Q-simple. In fact, we show in Section 3.7.2 that, for certain Q and T , a T -test suite exhaustive for Q and the class of first-order reproducible abstract reasoners exists, but no such test suite is Q-simple. This has an important practicallyrelevant consequence: if a T -test suite S is not Q-simple, a first-order reproducible abstract reasoner that passes S is guaranteed to be (Q, T )-complete; however, if an abstract reasoner does not pass S, in general we cannot conclude that the reasoner is not (Q, T )-complete."
    }, {
      "heading" : "3.7.1 First-Order Reproducible Abstract Reasoners",
      "text" : "State of the art concrete reasoners such as Oracle’s reasoner, Jena, OWLim, Minerva, Virtuoso, and DLE-Jena are all implemented as RDF triple stores extended with deductive database features. Given T and A as input, these reasoners first precompute all assertions that follow from T ∪ A in a preprocessing step. In practice, this step is commonly implemented by (a technique that can be seen as) evaluating a datalog program over A. After preprocessing, these reasoners can then answer an arbitrary UCQ Q by simply evaluating Q in the precomputed set of assertions.\nMotivated by this observation, we next introduce the new class of first-order reproducible abstract reasoners—that is, abstract reasoners whose behaviour can be conceived as complete reasoning in some unknown first-order theory. Note that this theory is not required to be a datalog program; for example, it can contain existential quantifiers, which can be used to capture the behaviour of concrete reasoners such as Jena and OWLim (Bishop, Kiryakov,\nOgnyanoff, Peikov, Tashev, & Velkov, 2011) that handle existential quantifiers in the input by introducing fresh individuals.\nDefinition 3.33. An abstract reasoner ans for a description logic DL is first-order reproducible if, for each DL-TBox T , a set of first-order sentences FT exists such that, for each ABox A,\n• ans(∗, T ,A) = cert(∗,FT ,A), and\n• if ans(∗, T ,A) = f, then for each UCQ Q, we have ans(Q, T ,A) = cert(Q,FT ,A).\nIf FT contains predicates and/or individuals not occurring in T , these are assumed to be ‘internal’ to ans and not accessible in queries, TBoxes, ABoxes, test suites, and so on. Given a TBox T , CTf is the class of all first-order reproducible abstract reasoners applicable to T .\nExample 3.34. Abstract reasoners rdf, rdfs, rl and classify from Example 3.3 are all firstorder reproducible. Indeed, theory FT is empty in the case of rdf, and it is precisely Prdfs and Prl in the cases of rdfs and rl, respectively. Finally, for abstract reasoner classify, theory FT is the union of Prl and the program containing the axiom ∀x.[A(x) → B(x)] for each atomic subsumption A  B entailed by the input TBox. ♦\nPlease note that a first-order reproducible abstract reasoner ans does not need to actually construct FT : it only matters that some (possibly unknown) theory FT exists that characterises the reasoner’s behaviour as specified in Definition 3.33.\nSince Q∪FT ∪A |= Q∪FT ∪A whenever A ⊆ A, each first-order reproducible abstract reasoner is (Q, T )-monotonic for arbitrary Q and T . Furthermore, it is straightforward to see that each first-order reproducible abstract reasoner is also strongly (Q, T )-faithful. Consequently, we have CTf ⊆ C Q,T s for each UCQ Q and each TBox T .\nWe next show that the negative result in Theorem 3.21 does not directly apply to the class CTf . In particular, we show that the abstract reasoner pEvaln used to prove Theorem 3.21 is not first-order reproducible. Intuitively, pEvaln can be understood as partial evaluation of a datalog program—that is, the rules in the program are applied to the facts only a fixed number of times rather then until a fixpoint is reached.\nProposition 3.35. For each positive integer n, the abstract reasoner pEvaln defined in the proof of Theorem 3.21 is not first-order reproducible.\nProof. Let T = {∃R.A  A}, let Q = {A(x) → Q(x)}, and consider an arbitrary nonnegative integer n. Furthermore, assume that pEvaln ∈ CTf ; then, a finite set of first-order sentences FT exists such that pEvaln(Q, T ,A) = cert(Q,FT ,A) for each ABox A.\nLet k be a positive integer; furthermore, let rk be the datalog rule and let Ak be the ABox defined as follows, for a0, . . . , ak arbitrary distinct but fixed individuals not occurring in Q ∪ FT :\nrk = R(x0, x1) ∧ . . . ∧R(xk−1, xk) ∧A(xk) → A(x0) Ak = {R(a0, a1), . . . , R(ak−1, ak), A(ak)}\nThe following condition holds by Proposition 2.1:\nFT |= rk if and only if FT ∪Ak |= A(a0) (17)\nBy the definition of pEvaln, we have\na0 ∈ pEvaln(Q, T ,Ak) for each 1 ≤ k ≤ n, and a0 ∈ pEvaln(Q, T ,Ak) for each k > n.\nSince pEvaln(Q, T ,A) = cert(Q,FT ,A), we have\na0 ∈ cert(Q,FT ,Ak) for each 1 ≤ k ≤ n, and a0 ∈ cert(Q,FT ,Ak) for each k > n.\nSince Q contains only the atom A(x) in the body, we have\nFT ∪Ak |= A(a0) for each 1 ≤ k ≤ n, and FT ∪Ak |= A(a0) for each k > n.\nBy condition (17), we then have\nFT |= rk for each 1 ≤ k ≤ n FT |= rk for each k > n.\nThis, however, contradicts the obvious observation that r1 |= rk for each k ≥ 1.\nNote that the proof of Proposition 3.35 relies on the fact that the theory FT only depends on the input TBox, and not on the input query. As shown next, had we defined first-order reproducible abstract reasoners by allowing FT to depend also on the input query, then the negative result from Theorem 3.21 would have applied.\nDefinition 3.36. An abstract reasoner ans for DL first-order q-reproducible if, for each UCQ Q and each DL-TBox T , a finite set of first-order sentences FQ,T exists such that, for each ABox A,\n• ans(∗, T ,A) = cert(∗,FQ,T ,A), and\n• if ans(∗, T ,A) = f, then ans(Q, T ,A) = cert(Q,FQ,T ,A).\nTheorem 3.37. For Q = {A(x) → Q(x)} and T = {∃R.A  A}, no T -test suite exists that is exhaustive for Q and the class of all sound, monotonic, strongly faithful, and qreproducible abstract reasoners applicable to T .\nProof. To prove this claim, it suffices to show that, for each nonnegative integer n, the abstract reasoner pEvaln defined in the proof of Theorem 3.21 is first-order q-reproducible. Consider an arbitrary nonnegative integer n, an arbitrary DL-TBox T , and an arbitrary UCQ Q. We define FQ,T  such that, if T ⊆ T  or Q = Q, then FQ,T  = ∅; otherwise, FQ,T  consists of the following n rules:\nA(x0) → Q(x0) R(x0, x1) ∧A(x1) → Q(x0)\n. . .\nR(x0, x1) ∧R(x1, x2) ∧ . . . ∧R(xn−1, xn) ∧A(xn) → Q(x0)\nClearly, pEvaln(∗, T ,A) = cert(∗,FQ,T  ,A) = f for each UCQ Q, DL-TBox T  and ABox A, as required. Furthermore, for each Q and T  such that either T ⊆ T  or Q = Q and each ABox A, we have pEvaln(Q, T ,A) = cert(Q,FQ,T  ,A) = ∅. Finally, for Q = Q, each T  such that T ⊆ T , and each ABox A, we clearly have pEvaln(Q, T ,A) = cert(Q,FQ,T  ,A), as required."
    }, {
      "heading" : "3.7.2 Simple vs. Non-Simple Test Suites",
      "text" : "Proposition 3.18 from Section 3.3 shows that each Q-simple T -test suite that is exhaustive for Q and a class of abstract reasoners provides a sufficient and necessary test for (Q, T )- completeness. We next show that an analogous result does not hold if T contains recursive axioms, even if we consider only first-order reproducible abstract reasoners. As in Theorem 3.21, we prove the claim for a fixed Q and T since the concept of ‘relevant recursive axioms’ might be difficult to formalise; however, our proof can easily be adapted to other UCQs and TBoxes. Our result essentially states that no T -test suite exists that provides a necessary and sufficient condition for (Q, T )-completeness of each abstract reasoner in CTf ; consequently, by Proposition 3.18 each T -test suite exhaustive for CTf and Q is not Q-simple. Furthermore, in Section 3.7.3 we show how to compute a T -test suite exhaustive for CTf and Q, so the following claim does not hold vacuously.\nTheorem 3.38. Let Q = {A(x) ∧B(x) → Q(x)}, let T = {∃R.A  A}, and let C be the class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T . Then, no T -test suite S exists that satisfies the following two properties:\n1. S is exhaustive for C and Q; and\n2. for each abstract reasoner ans ∈ C, if ans is (Q, T )-complete then ans passes S.\nProof. Assume that a T -test suite S = S⊥,SQ exists that satisfies properties 1 and 2 of the theorem. Let n be the maximal number of assertions occurring in an ABox in S. We next define two abstract reasoners ans1 and ans2; it is straightforward to check that both are sound, monotonic, strongly faithful, and first-order reproducible.\nGiven an arbitrary FOL-TBox Tin, abstract reasoner ans1 uses the datalog program F1Tin defined as follows:\n• If T ⊆ Tin, then F1Tin = ∅.\n• If T ⊆ Tin, then F1Tin contains the following n rules:\nr0 = B(x0) ∧A(x0) → A(x0) r1 = B(x0) ∧R(x0, x1) ∧A(x1) → A(x0) r2 = B(x0) ∧R(x0, x1) ∧R(x1, x2) ∧A(x3) → A(x0)\n. . . rn = B(x0) ∧R(x0, x1) ∧ . . . ∧R(xn−1, xn) ∧A(xn) → A(x0)\nGiven an arbitrary FOL-TBox Tin, abstract reasoner ans2 uses the datalog program F2Tin defined as follows, where predicate Z is private to F 2 Tin (and hence it does not affect the soundness of the abstract reasoner):\n• If T ⊆ Tin, then F2Tin = ∅.\n• If T ⊆ Tin, then F2Tin contains F 1 Tin as well as the following rules:\nrZ1 = R(x0, x1) ∧ . . . ∧R(xn, xn+1) ∧A(xn+1) → Z(x0) rZ2 = R(x0, x1) ∧ Z(x1) → Z(x0) rZ3 = Z(x) ∧B(x) → A(x)\nNow let A be an arbitrary ABox containing at most n assertions. We next show that, for each assertion α not containing predicate Z, we have F1Tin ∪A |= α if and only if F2Tin ∪A |= α. The (⇒) direction is trivial since F 1 Tin ⊆ F 2 Tin , so we consider the (⇐) direction. Furthermore, since rZ3 is the only rule in F2Tin \\ F 1 Tin that does not contain Z in the head, the claim is nontrivial only if α is of the form A(a0) for some individual a0 occurring in A. Since the antecedent of rZ3 is satisfied for a0, we have B(a0) ∈ A and F2Tin ∪A |= Z(a0). But then, for the latter to be implied by rZ1 and rZ2 , individuals a0, a1, . . . , ak with 0 ≤ k exist such that R(ai, ai+1) ∈ A for each 1 ≤ i < k, and A(ak) ∈ A. Since A contains at most n assertions, w.l.o.g. we can assume that k ≤ n. But then, since F1Tin contains rule rk, we have F 1 Tin ∪A |= A(a0) as well, which proves our claim. As a consequence of this claim and the fact that all ABoxes in S contain at most n assertions, we have cert(∗,F1Tin ,A) = cert(∗,F 2 Tin ,A) for each A ∈ S⊥, and cert(Y,F 1 Tin ,A) = cert(Y,F 2 Tin ,A) for each A,Y ∈ SQ. Let A = {B(a0), R(a0, a1), . . . , R(an, an+1), A(an+1)}. Then cert(Q, T ,A) = {a0} and cert(Q,F1Tin ,A) = ∅, so ans1 is not (Q, T )-complete. Since S is exhaustive for C and Q, abstract reasoner ans1 does not pass S; by the claim from the previous paragraph, abstract reasoner ans2 does not pass S either. We next show that ans2 is (Q, T )-complete, which contradicts the assumption that S satisfies property 2 and thus proves the claim of this theorem.\nConsider an arbitrary ABoxA containing m assertions. Clearly, a0 ∈ cert(Q, T ,A) if and only if individuals a0, a1, . . . , ak with 0 ≤ k ≤ m exist such that B(a0) ∈ A, R(ai, ai+1) ∈ A for each 1 ≤ i < k, and A(ak) ∈ A. Now assume that k ≤ n; since rk ∈ F2Tin , we have F2Tin ∪A |= A(a0) and thus a0 ∈ cert(Q,F 2 Tin ,A). In contrast, assume that k > n; since rZ1 ∈ F2Tin , we have F 2 Tin ∪A |= Z(ak−n−1); since rZ2 ∈ F 2 Tin , we have F 2 Tin ∪A |= Z(ai) for each 0 ≤ i ≤ k − n− 1; finally, since rZ3 ∈ F2Tin , we have F 2 Tin ∪A |= A(a0); but then, a0 ∈ cert(Q,F2Tin ,A), as required.\nAs a corollary to Theorem 3.38, we next show that testing abstract reasoners in CTf cannot be done in general using Q-simple test suites.\nCorollary 3.39. For Q = {A(x) ∧B(x) → Q(x)} and T = {∃R.A  A}, no Q-simple T - test suite exists that is exhaustive for Q and the class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T .\nProof. If S is a Q-simple T -test suite that is exhaustive for Q and the class mentioned in the Theorem, by Proposition 3.18 each abstract reasoner ans from the class that does not pass S is not (Q, T )-complete, which contradicts Theorem 3.38.\nTheorem 3.38 effectively says that, if an abstract reasoner ans ∈ CTf does not pass a T - test suite S, we cannot conclude that ans is not (Q, T )-complete. Please note that this holds only if ans fails a test of the form A,Y where Q = Y: if Q = Y, then A is a counterexample to (Q, T )-completeness of ans. Thus, S may show ans to be not (Q, T )-complete, but it is not guaranteed to do so. This is illustrated by the following example.\nExample 3.40. LetQ = {A(x) ∧B(x) → Q(x)} and let T = {∃R.A  A,∃R.C  C}. Furthermore, let S = ∅,SQ be the general test suite defined as follows:\nSQ = {  {A(c) }, {A(x) ∧B(x) → Q(x) } ,  {R(c, d), A(d) }, {A(c) → Q } ,  {R(c, d), C(d) }, {C(c) → Q }  }\nLet R = RD, ∅,Q where RD = {R(x, y) ∧A(y) → A(x), R(x, y) ∧ C(y) → C(x)}; clearly, R is a rewriting Q w.r.t. T . In Section 3.7.3 we show how to compute S from R using a variant of injective instantiation in a way that guarantees exhaustiveness for CTf and Q.\nNow let ans1 ∈ CTf be the abstract reasoner defined by F1T = {R(x, y) ∧A(y) → A(x)}. The reasoner does not pass S since cert({C(c) → Q},F1T , {R(c, d), C(d)}) = f. Note, however, that the reasoner is (Q, T )-complete. Thus, if a test suite is not Q-simple, passing it is a sufficient, but not a necessary condition for (Q, T )-completeness. In fact, note that T contains the TBox for Theorem 3.38, so by the theorem we cannot ‘reduce’ S so that it correctly identifies all reasoners in CTf that are not (Q, T )-complete.\nIn practice, however, one can try to mitigate this fundamental theoretical limitation by eliminating the irrelevant axioms from the rewriting R and thus increasing the likelihood of obtaining a T -test suite that a (Q, T )-complete abstract reasoner will pass. For example, using the techniques by Cuenca Grau, Horrocks, Kazakov, and Sattler (2008a) we can extract the module of R relevant to the query. In the example from the previous paragraph, this would remove the rule R(x, y) ∧ C(y) → C(x) from R, and injective instantiation will produce the test suite S = ∅,SQ where SQ is defined as follows:\nSQ = {  {A(c) }, {A(x) ∧B(x) → Q(x) } ,  {R(c, d), A(d) }, {A(c) → Q }  }\nAbstract reasoner ans1 from the previous paragraph now passes S and is thus guaranteed to be (Q, T )-complete.\nNow let ans2 be the abstract reasoner defined by F2T = {B(x) ∧R(x, y) ∧A(y) → A(x)}. Clearly, abstract reasoner ans2 is not (Q, T )-complete, so ans2 does not pass SQ. From the latter, however, we cannot immediately conclude that S is not (Q, T )-complete: the test that fails does not involve the original query Q. As a possible remedy, we can try to unfold R to a certain level and then injectively instantiate the result in hope of obtaining a T -test suite that will identify ans2 as not being (Q, T )-complete. In particular, the first unfolding of R produces the following query:\nB(x) ∧R(x, y) ∧A(y) → Q(x)\nInstantiating this rewriting produces the following test suite, which does not prove that ans2 is not (Q, T )-complete.\nSQ = {  {B(c), R(c, d), A(d) }, {A(x) ∧B(x) → Q(x) }  }\nAnother round of unfolding, however, produces the following query:\nB(x) ∧R(x, y) ∧R(y, z) ∧A(z) → Q(x)\nInstantiating this query produces the following test suite:\nSQ = {  {B(c), R(c, d), R(d, e), A(e) }, {A(x) ∧B(x) → Q(x) }  }\nNow ans2 does not pass SQ, so we can conclude that ans2 is not (Q, T )-complete. ♦\nTo better understand Example 3.40, consider a first-order reproducible abstract reasoner ans, an arbitrary UCQ Q, and a TBox T such that R = RD, ∅,RQ is a datalog rewriting of Q w.r.t. T . Datalog program RD ∪RQ is equivalent to the (possibly infinite) UCQ RuQ obtained from RD ∪RQ via exhaustive unfolding. We now have the following possibilities.\nFirst, assume that ans is not (Q, T )-complete. Since RD ∪RQ is equivalent to RuQ, each certain answer a to Q w.r.t. T and an arbitrary ABox A is ‘produced’ by some r ∈ RuQ. But then, the injective instantiation Arλ of r will provide us with the counterexample for the (Q, T )-completeness of ans. Thus, we can prove that ans is not (Q, T )-complete by generating the elements of RuQ in a fair manner (i.e., without indefinitely delaying the generation of some element of RuQ) and checking whether cert(Q, T ,Arλ) ⊆ ans(Q, T ,Arλ); we are guaranteed to eventually encounter some r ∈ RuQ that invalidates this condition and thus proves that ans is not (Q, T )-complete.\nSecond, assume that ans is (Q, T )-complete. Using the above approach, we will determine that cert(Q, T ,Arλ) ⊆ ans(Q, T ,Arλ) holds for each r ∈ RuQ. Now if RuQ is finite (i.e., if the unfolding of RD ∪RQ terminates), then RuQ is the UCQ rewriting of Q w.r.t. T , so by the results from Section 3.6 we can conclude that ans is indeed (Q, T )-complete. If, however, RuQ is infinite, then we will never obtain a sufficient assurance for the (Q, T )-complete of ans. In the following section we show a possible remedy to this problem."
    }, {
      "heading" : "3.7.3 Testing First-Order Reproducible Abstract Reasoners",
      "text" : "In this section, we show how to compute a T -test suite S = S⊥,SQ exhaustive for CTf and Q from a datalog±,∨ rewriting R = RD,R⊥,RQ of Q w.r.t. T . Since first-order reproducible abstract reasoners are strongly faithful, we need to consider only injective instantiations of R. Thus, the rules in R⊥ and RQ should be instantiated as in Section 3.6. A rule r ∈ RD, however, is instantiated into a pair A,Y ∈ SQ with A the ABox obtained by instantiating the body of r and Y the Boolean UCQ obtained by instantiating the head of r. Intuitively, such tests allow us to check whether the (unknown) first-order theory FT that captures the behaviour of the abstract reasoner entails r.\nDefinition 3.41. Let Q be a UCQ with query predicate Q, let T be an admissible TBox, let R = RD,R⊥,RQ be a datalog±,∨ rewriting of Q w.r.t. T , and let λ be a substitution mapping each variable occurring in R into a distinct fresh individual. The injective instantiation of R w.r.t. λ is the pair IR,λ = IR,λ⊥ , I R,λ Q  where I R,λ ⊥ is the smallest set of ABoxes and IR,λQ is the smallest set of pairs of an ABox and a UCQ such that\n• Arλ ∈ I R,λ ⊥ for each r ∈ R⊥,\n• Arλ,Q ∈ I R,λ Q for each r ∈ RQ such that cert(∗,RD ∪R⊥,Arλ) = f, and\n• Arλ,Y ∈ I R,λ Q for each r ∈ RD of the form (6) such that cert(∗,RD ∪R⊥,Arλ) = f,\nwhere Y is the UCQ Y = {ϕi(λ(x), yi) → Q | 1 ≤ i ≤ m} with the propositional query predicate Q.\nIR,λ is clearly unique up to the renaming of the fresh individuals in λ, so λ is typically left implicit, and one talks of the injective instantiation IR = IR⊥ , IRQ of R.\nExample 3.42. Consider the query Q = {A(x) → Q(x)} and the EL-TBox T consisting of the following axioms, whose translation into first-order logic is shown after the  symbol.\n∃R.A  B  ∀x, y.[R(x, y) ∧A(y) → B(x)] ∃R.C  A  ∀x, y.[R(x, y) ∧ C(y) → A(x)]\nB  C  ∀x.[B(x) → C(x)] C  ∃R.D  ∀x.[C(x) → ∃y.[R(x, y) ∧D(y)]] A D  ⊥  ∀x.[A(x) ∧D(x) → ⊥]\nThen, R = RD,R⊥,RQ as defined next is a datalog rewriting of Q w.r.t. T .\nRD = { R(x, y) ∧A(y) → B(x), R(x, y) ∧ C(y) → A(x), B(x) → C(x) } R⊥ = { A(x) ∧D(x) → ⊥ } RQ = { A(x) → Q(x) }\nThe injective instantiation IR = IR⊥ , IRQ of R is shown below.\nIR⊥ = { {A(c), D(c) } } IRQ = {  {A(c) }, {A(x) → Q(x) } ,\n {R(c, d), A(d) }, {B(c) → Q } ,  {R(c, d), C(d) }, {A(c) → Q } ,  {B(c) }, {C(c) → Q }  } ♦\nWe now show that the injective instantiation of a datalog±,∨ rewriting of Q w.r.t. T is a T -test suite exhaustive for CTf and Q.\nTheorem 3.43. Let Q be a UCQ, let T be a TBox, let R = RD,R⊥,RQ be a datalog±,∨ rewriting of Q w.r.t. T , and let IR = IR⊥ , IRQ be the injective instantiation of R. Then, IR is a T -test suite that is exhaustive for CTf and Q.\nProof. Let λ be the substitution that IR is obtained from. We first show that IR is a T -test suite.\n• Consider an arbitrary A ∈ IR⊥ . Then, a rule r ∈ R⊥ exist such that A = Arλ; clearly cert(∗, {r},A) = t, so cert(∗,RD ∪R⊥,A) = t as well; since R is a datalog±,∨ rewriting of Q w.r.t. T , we have that T ∪A is unsatisfiable, as required.\n• Consider an arbitrary A ∈ IRQ . Then, cert(∗,RD ∪R⊥,A) = f by Definition 3.41; since R is a datalog±,∨ rewriting of Q w.r.t. T , we have that T ∪A is satisfiable, as required.\nTo show that IR is exhaustive for CTf and Q, consider an arbitrary abstract reasoner ans ∈ CTf that passes IR—that is, ans satisfies the following two properties:\n(a) ans(∗, T ,A) = t for each A ∈ IR⊥ , and\n(b) ans(∗, T ,A) = f implies cert(Y, T ,A) ⊆ ans(Y, T ,A) for each Y,A ∈ IRQ .\nSince ans is first-order reproducible, a set of first-order sentences FT exists such that, for each ABox A, we have\n• ans(∗, T ,A) = cert(∗,FT ,A), and\n• if ans(∗, T ,A) = f, then ans(Q, T ,A) = cert(Q,FT ,A).\nBy the assumption on FT in Definition 3.33 and the fact that λ maps variables to fresh individuals, we have rng(λ) ∩ ind(FT ) = ∅.\nLet R1D and R2D be the smallest sets of rules satisfying the following conditions for each rule r ∈ RD:\n• cert(∗,FT ,Arλ) = t implies r ∈ R1D, where r is obtained from r by replacing the head with ⊥, and\n• cert(∗,FT ,Arλ) = f implies r ∈ R2D.\nFurthermore, let R1Q and R2Q be the sets of rules obtained from RQ in an analogous way. Since R1D ∪R2D is obtained from RD by replacing some head formulae with ⊥, we clearly have R1D ∪R2D |= RD; analogously, we have R1Q ∪R2Q |= RQ.\nWe next show that FT |= R⊥; the latter holds if and only if FT |= r for each rule r ∈ R⊥. Consider an arbitrary rule r ∈ R⊥; note that head(r) = ⊥. Then, by Definition 3.41 we have Arλ ∈ IR⊥ ; by (a) we have ans(∗, T ,Arλ) = t; by Definition 3.33 we have cert(∗,FT ,Arλ) = t and hence FT ∪Arλ |= ⊥; finally, since rng(λ) ∩ ind(FT ) = ∅, by Proposition 2.1 we have FT |= r, as required.\nWe next show that FT |= R1D; the latter holds if and only if FT |= r for each rule r ∈ R1D. Consider an arbitrary rule r ∈ R1D; note that head(r) = ⊥. Then, by the definition of R1D we have cert(∗,FT ,Arλ) = t and hence FT ∪Arλ |= ⊥; finally, since rng(λ) ∩ ind(FT ) = ∅, by Proposition 2.1 we have FT |= r, as required.\nIn a completely analogous way as in the previous paragraph, it is possible to show that FT |= R1Q.\nWe next show that FT |= R2D; the latter holds if and only if FT |= r for each rule r ∈ R2D. Consider an arbitrary rule r ∈ R2D of the form (6); by the definition of R2D we have cert(∗,FT ,Arλ) = f, so by Definition 3.33 we have ans(∗, T ,Arλ) = f. Then, by Definition 3.41 we have Arλ,Y ∈ IRQ where Y is the UCQ Y = {ϕi(λ(x), yi) → Q | 1 ≤ i ≤ m}. Note that T |= r by Definition 2.2, so by Proposition 2.1 we have that T ∪Arλ |= m i=1 ϕi(λ(x), yi); by the definition of Y and the fact that Q does not occur in T , we have Y ∪ T ∪Arλ |= Q;\nbut then, cert(Y, T ,Arλ) = t. The latter observation, ans(∗, T ,Arλ) = f, and (b) then imply ans(Y, T ,Arλ) = t, so by Definition 3.33 we have cert(Y,FT ,Arλ) = t. Since Q occurs only in Y (note that each predicate occurring in FT but not in T is private to FT , so Q cannot occur in FT ), we have FT ∪Arλ |= m i=1 ϕi(λ(x), yi). Finally, since rng(λ) ∩ ind(FT ) = ∅, by Proposition 2.1 we have FT |= r, as required. We next show that Q ∪ FT |= R2Q; the latter holds if and only if Q ∪ FT |= r for each rule r ∈ R2Q. Consider an arbitrary rule r ∈ R2Q; note that head(r) is an atom with predicate Q, and that by the definition of R2Q we have cert(∗,FT ,Arλ) = f, so by Definition 3.33 we have ans(∗, T ,Arλ) = f. Furthermore, by Definition 3.41, we have cert(∗,RD ∪R⊥,Arλ) = f. Let a be the tuple of the arguments in λ(head(r)). Then, by Definition 3.41 we have Arλ,Q ∈ IRQ ; clearly, a ∈ cert({r}, ∅,Arλ), but then we have a ∈ cert(RQ,RD ∪R⊥,Arλ) by the monotonicity of first-order logic. Since R is a rewriting of Q w.r.t. T , by Definition 2.2 we have a ∈ cert(Q, T ,Arλ). The latter observation, ans(∗, T ,Arλ) = f, and (b) then imply a ∈ ans(Q, T ,Arλ). By Definition 3.33 we have a ∈ cert(Q,FT ,Arλ); hence, FT ∪Arλ |= Q(a). Finally, since we have rng(λ) ∩ ind(FT ) = ∅, by Proposition 2.1 we have FT |= r, as required.\nThe following table summarises the entailment relationships between various first-order theories obtained thus far:\nFT |= R⊥ FT |= R1D FT |= R2D FT |= R1Q Q ∪ FT |= R2Q R1Q ∪R2Q |= RQ R1D ∪R2D |= RD\nClearly, this implies the following entailments:\nFT |= RD ∪R⊥ Q ∪ FT |= RD ∪R⊥ ∪RQ\nWe now complete the proof of this theorem and show that ans is (Q, T )-complete. To this end, consider an arbitrary ABox A; we have the following possibilities, depending on the satisfiability of T ∪A.\n• Assume that T ∪ A is unsatisfiable. Then cert(∗,RD ∪R⊥,A) = t by Definition 2.2; by the above mentioned entailments, we have cert(∗,FT ,A) = t; consequently, ans(∗, T ,A) = t by Definition 3.33, as required.\n• Assume that T ∪A is satisfiable and ans(∗, T ,A) = f, and consider an arbitrary tuple a ∈ cert(Q, T ,A). Then, cert(∗,RD ∪R⊥,A) = f and a ∈ cert(RQ,RD ∪R⊥,A) by Definition 2.2. By the above mentioned entailments, we have a ∈ cert(Q,FT ,A); hence, a ∈ ans(Q, T ,A) by Definition 3.33, as required.\nNote that the size of the test suite obtained by Theorem 3.43 is linear in the size of the rewriting, which, we believe, makes our approach suitable for use in practice."
    }, {
      "heading" : "3.7.4 Testing Ground Queries",
      "text" : "As shown in Section 3.7.2, if an abstract reasoner ans ∈ CTf does not pass a T -test suite S that is not Q-simple, we cannot always conclude that ans is not (Q, T )-complete. From a practical point of view, it would be highly beneficial to identify situations where not passing S would show that ans is indeed incomplete forQ and T . Furthermore, in applications where\nprototypical queries are not known at design time, we would like to design completeness tests that are query-independent—that is, which test an abstract reasoner for completeness w.r.t. T regardless of the input data and query. In this section, we show that we can achieve these two goals by focusing on ground queries. This restriction is not unreasonable in practice, since any SPARQL query can be equivalently expressed as a ground UCQ.\nWe first define a query-independent notion of exhaustiveness of a test suite.\nDefinition 3.44. Let T be a TBox, let S be a T -test suite, and let C be a class of abstract reasoners applicable to T . Then, S is exhaustive for C and all ground UCQs if each ans ∈ C that passes S is (Q, T )-complete for each ground UCQ Q.\nThen, we define the notion of a ground rewriting of T —a rewriting that captures all query answers w.r.t. T , regardless of the input ground query and ABox—and we show how to instantiate such ground rewritings.\nDefinition 3.45. A ground rewriting of a TBox T is a pair R = RD,R⊥ such that, for each ground UCQ Q, the triple RD,R⊥,Q is a datalog∨ rewriting of T w.r.t. Q. An injective instantiation IR of such R is defined as IR = IR for R = RD,R⊥, ∅.\nNote that Definition 3.45 implies that each variable occurring in the head of a rule in R also occurs in the rule body. Tools such as REQUIEM and KAON2 can easily be adapted to compute a ground rewriting of a TBox T in practice. We next show that injective instantiation of a ground rewriting of T yields a T -test suite that provides us with sufficient and necessary check for completeness w.r.t. all ground UCQs.\nTheorem 3.46. Let T be a TBox, and let R = RD,R⊥ be a ground rewriting of T . Then, the following two claims hold.\n1. IR is exhaustive for CTf and all ground UCQs.\n2. Each abstract reasoner ans ∈ CTf that does not pass IR is not (Q, T )-complete for some ground UCQ Q.\nProof. (Property 1) Consider an arbitrary abstract reasoner ans ∈ CTf that passes IR. Let FT be the first-order theory that characterises the behaviour of ans; as in the proof of Theorem 3.43, the fact that ans passes IR implies FT |= RD ∪R⊥. Furthermore, consider an arbitrary ground UCQ Q and an arbitrary ABox A. That ans is (Q, T )-complete can be shown as in the proof of Theorem 3.43, with the minor difference that a ∈ cert(Q, T ,A) implies a ∈ cert(Q,RD ∪R⊥,A) by Definition 3.45.\n(Property 2) Note that, since R is a ground rewriting of T , by Definition 3.41 all UCQs in IR are ground. Thus, if some abstract reasoner ans ∈ CTf does not pass IR, this clearly shows that ans is not (Q, T )-complete for some ground UCQ Q."
    }, {
      "heading" : "4. Comparing Incomplete Abstract Reasoners",
      "text" : "In this section, we investigate techniques that, given a query Q and a TBox T , allow us to determine whether an abstract reasoner ans2 is ‘more complete’ than an abstract reasoner ans1—that is, whether for all ABoxes A, abstract reasoner ans2 computes more answers to Q and T than abstract reasoner ans1. This idea is formalised by the following definition.\nDefinition 4.1. Let Q be a UCQ, let T be a TBox, and let ans1 and ans2 be abstract reasoners applicable to T . Then, ans1 ≤Q,T ans2 if the following conditions hold for each ABox A:\n1. cert(∗, T ,A) = t and ans1(∗, T ,A) = t imply ans2(∗, T ,A) = t; and\n2. cert(∗, T ,A) = f, ans1(∗, T ,A) = f, and ans2(∗, T ,A) = f imply\nans1(Q, T ,A) ∩ cert(Q, T ,A) ⊆ ans2(Q, T ,A) ∩ cert(Q, T ,A).\nFurthermore, ans1 <Q,T ans2 if ans1 ≤Q,T ans2 and an ABox A exists such that at least one of the following two conditions holds:\n3. cert(∗, T ,A) = t, ans1(∗, T ,A) = f, and ans2(∗, T ,A) = t; or\n4. cert(∗, T ,A) = f, ans1(∗, T ,A) = f, ans2(∗, T ,A) = f, and\nans1(Q, T ,A) ∩ cert(Q, T ,A)  ans2(Q, T ,A) ∩ cert(Q, T ,A).\nExample 4.2. Consider the abstract reasoners rdf, rdfs, rl, and classify introduced in Example 3.3 and the query Q and TBox T from Example 3.14. We clearly have the following:\nrdf ≤Q,T rdfs ≤Q,T rl ≤Q,T classify\nFurthermore, for any two of these abstract reasoners, an ABox exists that distinguishes the abstracts reasoners w.r.t.Q and T ; for example, for ABox A = {takesCo(c, d),MathsCo(d)}, we have rdfs(Q, T ,A) = ∅ and rl(Q, T ,A) = {c}. As a result, we also have the following:\nrdf <Q,T rdfs <Q,T rl <Q,T classify ♦\nWe would like to check whether ans1 ≤Q,T ans2 and ans1 <Q,T ans2 for any given pair of abstract reasoners by subjecting the reasoners to a finite set of tests. Towards this goal, we next define the relations ≤RQ,T and <RQ,T that compare abstract reasoners w.r.t. a given finite set R of ABoxes. Ideally, given Q and T , we would like to compute a finite R such that ≤RQ,T and <RQ,T coincide with ≤Q,T and <Q,T on all abstract reasoners from a class C of interest. These ideas are captured by the following definitions.\nDefinition 4.3. Let Q be a UCQ, let T be a TBox, let R be a finite set of ABoxes, and let ans1 and ans2 be abstract reasoners applicable to T .\nThen, ans1 ≤RQ,T ans2 if Conditions 1 and 2 from Definition 4.1 hold for each ABox A ∈ R. Furthermore, ans1 <RQ,T ans2 if ans1 ≤RQ,T ans2 and either Condition 3 or Condition 4 from Definition 4.1 holds for some ABox A ∈ R.\nDefinition 4.4. Let Q be a UCQ, let T be a TBox, and let C be a class of abstract reasoners applicable to T . A finite set R of ABoxes is (Q, T )-representative for C if the following conditions hold for all ans1, ans2 ∈ C:\n1. ans1 ≤RQ,T ans2 if and only if ans1 ≤Q,T ans2; and\n2. ans1 <RQ,T ans2 if and only if ans1 <Q,T ans2.\nAs we show next, to prove that R is (Q, T )-representative, it suffices to show the ‘only if’ implication in Condition 1 and the ‘if’ implication in Condition 2 from Definition 4.4.\nProposition 4.5. Let Q be a UCQ, let T be a TBox, let C be a class of abstract reasoners applicable to T , and let R be a finite set of ABoxes such that\n1. ans1 ≤RQ,T ans2 implies ans1 ≤Q,T ans2, and\n2. ans1 <Q,T ans2 implies ans1 < R Q,T ans2.\nThen, R is (Q, T )-representative for C.\nProof. Note that ans1 ≤Q,T ans2 trivially implies ans1 ≤RQ,T ans2; thus, Condition 1 of this proposition clearly implies Condition 1 of Definition 4.4. Furthermore, if some ABox A ∈ R satisfies Condition 3 or 4 of Definition 4.1, Condition 1 or 2 of Definition 4.1 holds as well; consequently, Conditions 1 and 2 of this proposition imply Condition 2 of Definition 4.4.\nAn obvious question is whether a Q-simple T -test suite that is exhaustive for a class C and Q is also (Q, T )-representative for C. The following example shows that this is not necessarily the case.\nExample 4.6. Let Q and T be as specified in Example 3.14, and let R = {A1, . . . ,A6} for the ABoxes as specified in Example 3.16. As shown in Section 3, the Q-simple T -test suite S = S⊥,SQ with S⊥ = {A6} and SQ = {A1, . . . ,A5} is exhaustive for CQ,Tw and Q.\nLet trivial be the abstract reasoner that returns the empty set on each input, and consider also the RDF-based abstract reasoner rdf from Example 3.3, which ignores the TBox and evaluates the query directly against the ABox. Clearly, trivial ≤Q,T rdf; furthermore, trivial <Q,T rdf since for A = {St(c), takesCo(c, d),MathCo(d)} we have rdf(Q, T ,A) = {c} whereas trivial(Q, T ,A) = ∅. Both abstract reasoners, however, return the empty set of answers for all ABoxes in R and thus rdf ≤RQ,T trivial. Hence, by using R we cannot differentiate the two abstract reasoners. ♦"
    }, {
      "heading" : "4.1 Negative Result",
      "text" : "The following strong result shows that, for numerous TBoxes T , no finite set of ABoxes exists that can differentiate two arbitrary abstract reasoners from the class of all sound, first-order reproducible, monotonic, and strongly faithful reasoners. Note that this result is stronger than the negative result in Theorem 3.21, as it applies to a smaller class of abstract reasoners and all TBoxes that imply at least one concept subsumption.\nTheorem 4.7. Let T be an arbitrary TBox mentioning an atomic role R and atomic concepts A and B such that T |= A  B, and let Q = {B(x) → Q(x)}. Then, no finite set of ABoxes exists that is (Q, T )-representative for the class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T .\nProof. Assume that a finite set of ABoxes R exists that is (Q, T )-representative for the class of all sound, monotonic, strongly faithful, and first-order reproducible abstract reasoners applicable to T . Let n be the maximum number of assertions in an ABox in R.\nFor an arbitrary integer k ≥ 1, let ansk be the first-order reproducible abstract reasoner that, given an FOL-TBox Tin, uses the following datalog program FkTin :\nFkTin =  ∅ if Tin |= A  B A(x0) ∧R(x0, x1) ∧ . . . ∧R(xk−1, xk) → B(x0) if Tin |= A  B\nClearly, each ansk is sound, monotonic, and strongly faithful; furthermore, ansk(∗, T ,A) = f for each ABox A. We next show that ansn+1(Q, T ,A) ⊆ ansn+2(Q, T ,A) for each ABox A ∈ R. Consider an arbitrary a0 ∈ ansn+1(Q, T ,A); then, individuals a0, a1, . . . , an+1 exist such that R(a−1, a) ∈ A for each 1 ≤  ≤ n + 1. Since A contains at most n assertions but the rule in Fn+1T contains n + 1 body atoms, we have ai = aj for some i = j—that is, A contains an R-cycle. But then, the rule in Fn+2T can be matched to A by mapping x0 to a0, so a0 ∈ ansn+2(Q, T ,A). Therefore, we have ansn+1 ≤RQ,T ansn+2.\nForA = {A(a0), R(a0, a1), . . . , R(an, an+1)}, however, we have a0 ∈ ansn+1(Q, T ,A) and ansn+2(Q, T ,A) = ∅; thus, ansn+1 ≤Q,T ansn+2 does not hold, which contradicts our assumption that R is exhaustive for the class of abstract reasoners from this theorem."
    }, {
      "heading" : "4.2 Compact Abstract Reasoners",
      "text" : "Theorem 4.7 suggests that we need to make additional assumptions on the abstract reasoners that we wish to compare using a finite set of ABoxes. In this section, we show that representative sets of ABoxes can be computed in practice if we further restrict ourselves to abstract reasoners that we call (Q, T )-compact. Intuitively, such an abstract reasoner processes Q, T , and A by computing all certain answers of Q, A, and some subset T  of T , where the subset depends only on T and Q. In other words, the behaviour of compact abstract reasoners can be simulated by the following process: select the subset of axioms in the input TBox that can be processed, and then compute all certain answers w.r.t. the selected fragment of the TBox. The class of (Q, T )-compact abstract reasoners thus captures the properties of concrete reasoners such as Jena or Oracle’s Semantic Data Store that discard axioms from the input TBox that fall outside a certain fragment (e.g., existential restrictions on the right-hand of implications) and then encode the remaining axioms into a suitable set of rules.\nDefinition 4.8. Let Q be a UCQ, and let T be a TBox. An abstract reasoner ans applicable to T is (Q, T )-compact if a TBox T  ⊆ T exists such that the following properties hold for each ABox A:\n1. cert(∗, T ,A) = t implies ans(∗, T ,A) = t;\n2. cert(∗, T ,A) = f implies ans(∗, T ,A) = f and ans(Q, T ,A) = cert(Q, T ,A).\nAbstract reasoner ans is compact if it is (Q, T )-compact for each UCQ Q and each TBox T to which ans is applicable. Finally, CQ,Tc is the class of all (Q, T )-compact and strongly (Q, T )-faithful abstract reasoners applicable to T .\nExample 4.9. All abstract reasoners defined in Example 3.3 are (Q, T )-compact for the query Q and EL-TBox T from Example 3.14. Indeed, for abstract reasoner rdf the subset T  of T is given by T  = ∅; for abstract reasoner rdfs it is T  = {(8)}; for abstract reasoner rl it is T  = {(8), (9), (10)}; and for abstract reasoner classify it is T  = T . ♦\nThe abstract reasoners ansk defined in the proof of of Theorem 4.7 are not (Q, T )- compact for the query and the TBoxes to which Theorem 4.7 applies.\nProposition 4.10. Let Q = {B(x) → Q(x)} and let T = {A  B, C  ∃R.}. Then, for each k ≥ 1, abstract reasoner ansk from the proof of Theorem 4.7 is not (Q, T )-compact.\nProof. Let Q and T be as stated in the theorem and consider an arbitrary k ≥ 1. Let A1 and A2 be ABoxes defined as follows:\nA1 = {A(a0)} A2 = {A(a0), R(a0, a1), . . . , R(ak−1, ak)}\nClearly, we have the following:\nansk(Q, T ,A1) = ∅ ansk(Q, T ,A2) = {a0}\nOne can straightforwardly check, however, that the following holds for each T  with T  ⊆ T :\ncert(Q, T ,A1) = cert(Q, T ,A2)\nThus, ansk is not (Q, T )-compact.\nThus, the negative result from Theorem 4.7 does not immediately apply to a class containing only compact abstract reasoners."
    }, {
      "heading" : "4.3 Comparing Compact Abstract Reasoners",
      "text" : "In this section, we show that a set of ABoxes that is (Q, T )-representative for CQ,Tc can be obtained by computing, for each subset T  of T , a Q-simple T -test suite that is exhaustive for CQ,T  s . A minor complication arises due to the fact that T  can contain fewer individuals than T . To deal with such cases correctly, the ABoxes in ST ⊥ are not allowed to contain individuals occurring in T but not in T , and the ABoxes in ST Q are not allowed to contain individuals occurring in T but not in Q ∪ T . This assumption is without loss of generality: given a (Q, T )-test suite ST  , one can replace all individuals in T but not in Q ∪ T  with fresh individuals; the result of such replacement is a (Q, T )-test suite exhaustive for CQ,T  s .\nTheorem 4.11. Let Q be a UCQ, and let T be a TBox. Furthermore, for each T  ⊆ T , let ST  = ST ⊥ ,ST  Q  be a Q-simple T -test suite that is exhaustive for C Q,T  s and Q such that no ABox in ST ⊥ contains an individual from ind(T ) \\ ind(T ) and no ABox in ST \nQ contains an individual from ind(T ) \\ ind(Q ∪ T ). Then, the set R of ABoxes defined by\nR = \nT ⊆T ST  ⊥ ∪ ST  Q\nis (Q, T )-representative for CQ,Tc .\nProof. Assume that R satisfies the conditions of the theorem, and let ans1 and ans2 be arbitrary abstract reasoners in CQ,Tc . We next show that ans1 and ans2 satisfy the two properties in Proposition 4.5.\n• Property 1 of Proposition 4.5: ans1 ≤RQ,T ans2 implies ans1 ≤Q,T ans2 Since ans1 is (Q, T )-compact, a TBox T  ⊆ T exists that satisfies the conditions of Definition 4.8. Assume that ans1 ≤RQ,T ans2; we next show that Conditions 1 and 2 of Definition 4.1 are satisfied for an arbitrary ABox A.\n(Condition 1) Assume that cert(∗, T ,A) = t and ans1(∗, T ,A) = t. By the contrapositive of property 2 of Definition 4.8, then cert(∗, T ,A) = t. Since R contains all the ABoxes of some Q-simple T -test suite that is exhaustive for CQ,T  s and Q, by Theorem 3.30 there exist an ABox A ∈ R and a T -stable renaming µ such that dom(µ) = ind(T  ∪A) and µ(A) ⊆ A; since A does not contain individuals from ind(T ) \\ ind(T ), renaming µ is also T -stable. By the definition of a T -test suite, cert(∗, T ,A) = t; furthermore, by property 1 of Definition 4.8 we have ans1(∗, T ,A) = t. Since ans1 ≤RQ,T ans2 we have ans2(∗, T ,A) = t. Since ans2 is strongly (Q, T )-faithful and µ is T -stable, we have ans2(∗, T , µ(A)) = t. Finally, since µ(A) ⊆ A and ans2 is (Q, T )-monotonic, we have ans2(∗, T ,A) = t, as required.\n(Condition 2) Assume that cert(∗, T ,A) = f, ans1(∗, T ,A) = f, and ans2(∗, T ,A) = f, and consider an arbitrary tuple a ∈ ans(Q, T ,A) ∩ cert(Q, T ,A). By the contrapositive of property 1 of Definition 4.8, then cert(∗, T ,A) = f; but then, by property 2 of Definition 4.8, we have a ∈ cert(Q, T ,A). Since R contains all the ABoxes of some Qsimple T -test suite that is exhaustive for CQ,T  s and Q, by Theorem 3.30 there exist an ABox A ∈ R, a tuple b ∈ cert(Q, T ,A), and a (Q, T )-stable renaming µ such that dom(µ) = ind(Q ∪ T  ∪A), µ(A) ⊆ A, and µ(b) = a; since A does not contain individuals from ind(T ) \\ ind(Q ∪ T ), renaming µ is also (Q, T )-stable. By the definition of a (Q, T )-test suite, cert(∗, T ,A) = f; furthermore, by property 2 of Definition 4.8 we have b ∈ ans1(Q, T ,A). Since ans1 ≤RQ,T ans2 we have b ∈ ans2(Q, T ,A). Since ans2 is strongly (Q, T )-faithful and µ is (Q, T )-stable, we have that a ∈ ans2(Q, T , µ(A)). Finally, since µ(A) ⊆ A and ans2 is (Q, T )-monotonic, we have a ∈ ans2(Q, T ,A), as required.\n• Property 2 of Proposition 4.5: ans1 <Q,T ans2 implies ans1 <RQ,T ans2 Assume that ans1 <Q,T ans2. By Definition 4.1, then ans1 ≤Q,T ans2 and an ABox A exists satisfying Conditions 3 and 4 of Definition 4.1. Clearly, ans1 ≤RQ,T ans2; hence, what remains to be shown is that R contains an ABox that satisfies Conditions 3 and 4 of Definition 4.1. Since ans1 is (Q, T )-compact, a TBox T  ⊆ T exists that satisfies the conditions of Definition 4.8.\n(Condition 3) Assume that cert(∗, T ,A) = t, and assume also that ans1(∗, T ,A) = t and ans2(∗, T ,A) = f. As in the proof of Condition 1, we can identify an ABox A ∈ R and a T -stable renaming µ such that ans1(∗, T ,A) = t and µ(A) ⊆ A. Since ans2 is (Q, T )- monotonic and ans2(∗, T ,A) = f, we have ans2(∗, T , µ(A)) = f; furthermore, since ans2 is strongly (Q, T )-faithful and µ is T -stable, we also have ans2(∗, T ,A) = f. But then, Condition 3 of Definition 4.1 is satisfied for A ∈ R.\n(Condition 4) Assume that cert(∗, T ,A) = f and ans1(∗, T ,A) = ans2(∗, T ,A) = f, and consider an arbitrary tuple a ∈ [ans1(Q, T ,A) ∩ cert(Q, T ,A)] \\ ans2(Q, T ,A). As in the proof of Condition 2, we can identify an ABox A ∈ R, a (Q, T )-stable renaming µ, and a\ntupleb ∈ cert(Q, T ,A) such that µ(A) ⊆ A, µ(b) = a, andb ∈ ans1(Q, T ,A). Since ans2 is (Q, T )-monotonic and a ∈ ans2(Q, T ,A), we have a ∈ ans2(Q, T , µ(A)); furthermore, since ans2 is strongly (Q, T )-faithful and µ is (Q, T )-stable, we also have b ∈ ans2(Q, T ,A). But then, Condition 4 of Definition 4.1 is satisfied for A ∈ R.\nTheorems 3.32 and 4.11 immediately suggest an approach for computing a set of ABoxes that is a (Q, T )-representative for CQ,Tc . First, we compute a UCQ rewriting of Q w.r.t. each subset of T ; then, we instantiate each rule in each such rewriting using an injective instantiation mapping; finally, we compute R as a union of all ABoxes in all test suites. Such a näıve procedure, however, is not practical since it requires computing an exponential number of UCQ rewritings. We next present a more practical approach to computing a set of ABoxes that is (Q, T )-representative for CQ,Tc . Intuitively, instead of computing exponentially many rewritings, one can compute a single UCQ rewriting of Q w.r.t. T that is subset-closed—that is, which contains a rewriting for each subset of T .\nDefinition 4.12. A UCQ rewriting R = R⊥,RQ of Q w.r.t. T is subset-closed if for each T  ⊆ T a tuple R = R⊥,RQ exists such that R⊥ ⊆ R⊥, RQ ⊆ RQ and R is a UCQ rewriting of Q w.r.t. T .\nThe following corollary is an immediate consequence of Theorems 3.27, 3.32, and 4.11.\nCorollary 4.13. Let Q be a UCQ, let T be a TBox, let R be a subset-closed UCQ rewriting of Q w.r.t. T , and let IR = IR⊥ , IRQ be the injective instantiation of R. Then, the set of ABoxes R = IR⊥ ∪ IRQ is (Q, T )-representative for C Q,T c .\nPractical query rewriting systems such as REQUIEM are optimised to produce as small a UCQ rewriting as possible, so their output is typically not subset-closed. Therefore, our technique requires the modification of UCQ rewriting algorithms implemented in existing systems. As illustrated by the following example, the required modification typically involves disabling (at least partially) subsumption-based optimisations.\nExample 4.14. Let Q and T be as specified in Example 3.14, and let S = S⊥,SQ be the T -test suite from Example 3.16. A system such as REQUIEM can compute such R for the given Q and T . Note, however, that R is not subset-closed; for example, a UCQ rewriting of Q w.r.t. T  = ∅ is Q, and it is not a subset of RQ. The rewriting can be made subset-closed by extending RQ with the following rules:\nSt(x) ∧ takesCo(x, y) ∧MathCo(x, y) → Q(x) St(x) ∧ takesCo(x, y) ∧ CalcCo(x, y) → Q(x)\nMathSt(x) ∧ St(x) → Q(x)\nSystems such as REQUIEM, however, typically discard such rules by applying subsumption optimisations described in Section 3.5.3. ♦\nAs the following example shows, a subset-closed UCQ rewriting of Q w.r.t. T can, in the worst case, be exponentially larger than the ‘minimal’ UCQ rewritings of Q w.r.t. T . Example 4.15. Let Q = {C(x) → Q(x)}, and let T be the following TBox:\nT = {B  Ai | 1 ≤ i ≤ n} ∪ {A1  . . . An  C}\nFurthermore, let R = R⊥,RQ be such that R⊥ = ∅ and RQ contains the following rules:\nC(x) → Q(x) B(x) → Q(x)\nA1(x) ∧ . . . ∧An(x) → Q(x)\nClearly, R is a UCQ rewriting of Q w.r.t. T ; however, the number of rules in a subset-closed UCQ rewriting of Q w.r.t. T is exponential in n. ♦"
    }, {
      "heading" : "5. Evaluation",
      "text" : "We implemented our techniques for computing exhaustive test suites and for comparing incomplete concrete reasoners in a prototype tool called SyGENiA.1 Our tool uses REQUIEM for computing UCQ and datalog rewritings.2\nWe considered two evaluation scenarios. The first one uses the well-known Lehigh University Benchmark (LUBM) (Guo et al., 2005), which consists of a relatively small TBox about an academic domain, 14 test queries, and a data generator. The second one uses a small version of GALEN (Rector & Rogers, 2006)—a complex ontology commonly used in medical applications.\nWe evaluated the following concrete reasoners: Sesame v2.3-prl,3 DLE-Jena v2.0,4 OWLim v2.9.1,5 Minerva v1.5,6 and Jena v2.6.37 in all of its three variants (Micro, Mini, and Max)."
    }, {
      "heading" : "5.1 Computing Exhaustive Test Suites",
      "text" : "Given a UCQ Q and a TBox T , our tool uses REQUIEM to compute a datalog rewriting R for Q and T . If R is a UCQ rewriting, then our tool computes a simple test suite by either full or injective instantiation (see Sections 3.5 and 3.6, respectively); otherwise, the tool computes a non-simple test suite by instantiating R as described in Section 3.7.3."
    }, {
      "heading" : "5.1.1 Simple Test Suites",
      "text" : "In the case of the LUBM benchmark, each of the 14 test queries leads to a UCQ rewriting w.r.t. the TBox.8 Therefore, we computed a UCQ rewriting for each query Q in the benchmark using REQUIEM and instantiated it, both fully and injectively, thus obtaining Q-simple T -test suites that are exhaustive for Q and CQ,Tw and CQ,Ts , respectively. The times needed to compute the test suites and the size of each test suite are shown in Table 3, where S denotes the total number of ABoxes in the corresponding test suites.\n1. http://code.google.com/p/sygenia/ 2. http://www.cs.ox.ac.uk/projects/requiem/home.html 3. http://www.openrdf.org/ 4. http://lpis.csd.auth.gr/systems/DLE-Jena/ 5. http://www.ontotext.com/owlim/ 6. http://www.alphaworks.ibm.com/tech/semanticstk 7. http://jena.sourceforge.net/ 8. Since REQUIEM does not currently support individuals in the queries, we replaced the individuals in\nqueries by distinguished variables.\nAs shown in the table, simple test suites could be computed in times ranging from 0.05 to 7 seconds, both for CQ,Tw and CQ,Ts . The optimisations implemented in REQUIEM ensure that the UCQ rewritings are relatively small, so the resulting test suites also consist of a relatively small number of ABoxes. Notice, however, the significant difference between the numbers of ABoxes in test suites obtained via injective instantiation (which range from 1 to 169 with an average of 32), and those obtained via full instantiation (which range from 1 to 3, 919 with an average of 702). Furthermore, each rule in a rewriting contains at most 6 atoms, therefore each ABox in a test suite also contains at most 6 assertions.\nIn the case of GALEN, we used the following sample queries, for which REQUIEM can compute a UCQ rewriting:\nQ1 : HaemoglobinConcentrationProcedure(x) → Q(x) Q2 : PlateletCountProcedure(x) → Q(x) Q3 : LymphocyteCountProcedure(x) → Q(x) Q4 : HollowStructure(x) → Q(x)\nWe instantiated each UCQ rewriting both fully and injectively. The times needed to compute the test suites and the size of each test suite are shown in Table 4.\nAs shown in the table, simple test suites for GALEN can be computed in times ranging from 1.7 to 67 seconds with an average of 33 seconds. Thus, computing test suites for GALEN is more time consuming than for LUBM. This is unsurprising since the TBox of GALEN is significantly more complex than that of LUBM. The number of ABoxes in the test suites ranged from 25 to 151 in the case of injective instantiations and from 79 to over 12, 000 in the case of full instantiations; again, note the significant difference between the sizes of the two kinds of test suites. In all cases, however, each individual ABox was very small, with the largest one containing only 11 assertions."
    }, {
      "heading" : "5.1.2 Non-Simple Test Suites",
      "text" : "We also computed non-simple test suites for cases where no UCQ rewriting exists. As already mentioned, all LUBM queries are UCQ-rewritable. Therefore, we manually added the following query, for which REQUIEM computes a recursive datalog rewriting.\nQ15 : Organization(x) → Q(x)\nDue to the complex structure of the GALEN TBox, test queries that are not UCQ rewritable can be easily identified. We have evaluated the following four.\nQ5 : WestergrenESRProcedure(x) → Q(x) Q6 : ArthroscopicProcedure(x) → Q(x) Q7 : TrueCavity(x) → Q(x) Q8 : BacterialCellWall(x) → Q(x)\nTimes needed to compute test suites and the size of each test suite are shown in Table 5."
    }, {
      "heading" : "5.2 Completeness Guarantees",
      "text" : "As already discussed, existing concrete reasoners are captured by strongly (Q, T )-faithful abstract reasoners. Hence, in order to establish completeness guarantees for such concrete reasoners, we restricted our tests to test suites computed using injective instantiations."
    }, {
      "heading" : "5.2.1 Results for Simple Test Suites",
      "text" : "Our results for the original queries of the LUBM benchmark are shown in Table 6. For each concrete reasoner, the first column of the table shows the queries for which we were able to prove completeness using our techniques (i.e., the queries that are complete for an arbitrary data set), and the second column of the table shows the queries on which the concrete reasoner computes all answers on the canonical LUBM data set with one university. Our results clearly show that completeness w.r.t. the data set in the LUBM benchmark is no guarantee of completeness for arbitrary data sets; for example, OWLim, Minerva, and Jena Mini/Micro are complete for all queries w.r.t. the LUBM data set (and some of these systems are even complete for the more expressive UOBM benchmark); however, for certain queries, these systems were found to be incomplete for a data set in our test suites.\nJena Max and DLE-Jena are the only systems that are guaranteed to be complete for all 14 LUBM queries regardless of the data set—that is, these systems behave exactly like a complete OWL reasoner for all LUBM queries and the LUBM TBox. According to Jena’s\ndocumentation, Jena Max supports all types of axioms used in the LUBM TBox, hence it is expected to be complete for the LUBM TBox and queries. Interestingly, when tested with some of the LUBM data sets, Jena Max could not compute the answers to many of the queries, so we used smaller LUBM data sets instead. This demonstrates an additional advantage of our approach: it does not require reasoning w.r.t. very large data sets, since the ABoxes in test suites typically contain only a small number of assertions. Regarding DLEJena, according to its technical description (Meditskos & Bassiliades, 2008), the system uses a complete DL reasoner to materialise certain subsumptions in a preprocessing step and then uses Jena to saturate the ABox, much like the abstract reasoner classify from Example 3.3. Hence, DLE-Jena is at least as complete as Jena Mini and, in addition, it is able to draw the inferences that Jena Mini is missing (see below).\nOWLim is complete for all LUBM queries that do not involve reasoning with existential quantifiers in the consequent of implications. It is well known that the latter is not supported by the system. Jena Mini and Micro exhibited exactly the same behaviour as OWLim, despite the fact that Jena Mini can handle a larger fragment of OWL than OWLim. Clearly, the LUBM TBox and queries are not sufficiently complex to reveal the differences between OWLim, and Jena Mini/Micro.\nMinerva is guaranteed to be complete for only six queries. Like DLE-Jena, it uses a DL reasoner to materialise entailed subsumptions between atomic concepts, but it uses a custom method for saturating the ABox. After investigating several ABoxes from the test suites we concluded that Minerva cannot correctly handle (at-least) inverse role axioms; for example, it cannot find the entailment { R  R−, R(a, b) } |= R(b, a).\nFinally, Sesame is complete for only four queries. This is unsurprising since Sesame is an RDFS reasoner and is thus complete only for a small fragment of OWL 2 DL.\nWe next discuss the results of tests based on the GALEN ontology and test queries Q1–Q4. We could not run Jena Max since GALEN heavily uses existential restrictions, which (according to Jena’s documentation) might cause problems. Minerva was the only system that provided completeness guarantee for at least one query (Q4); this is because Minerva precomputes subsumption relationships between atomic concepts that depend on existential restrictions on the right hand side of TBox axioms, which most other systems do not handle. Also, unlike LUBM, the version of GALEN that we used does not contain inverse roles, so Minerva performed much better on this ontology. All other systems were identified as being incomplete for all test queries."
    }, {
      "heading" : "5.2.2 Results for Non-Simple Test Suites",
      "text" : "Results for test queries that are not UCQ-rewritable are summarised in Table 7. Symbol ‘’ indicates that the concrete reasoner was found complete for the given query. Furthermore, whenever a concrete reasoner failed a test suite, we tried to prove the reasoner to be incomplete as discussed in the examples in Section 3.7.2; in all cases we were successful, so symbol ‘×’ indicates that the concrete reasoner was identified as being incomplete for a given query. Finally, symbol ‘−’ indicates that the concrete reasoner ran out of memory.\nIn the case of LUBM, we were able to establish completeness guarantees w.r.t. query Q15 for OWLim, Jena Micro, DLE-Jena, and Jena Max. Note that all these systems can handle recursive TBox statements, so completeness for Q15 is not surprising. RDFS,\nhowever, cannot express recursive TBox statements involving roles, so Sesame—an RDFS reasoner—fails to compute certain answers to some tests.\nIn the case of GALEN, completeness is guaranteed on query Q8 for OWLim, Jena Micro, DLE-Jena, and Minerva, and additionally on query Q6 for Minerva. As already mentioned, answers to queries on GALEN depend on positive occurrences of existential restrictions in axioms, which most systems cannot handle. We could not run Jena Max on GALEN."
    }, {
      "heading" : "5.3 Comparing Incomplete Concrete Reasoners",
      "text" : "We also implemented the techniques for comparing reasoners from Section 4.3. To this end, we modified REQUIEM to compute subset-closed rewritings, which are then injectively instantiated to obtain a (Q, T )-representative sets of ABoxes R."
    }, {
      "heading" : "5.3.1 Tests with LUBM",
      "text" : "As shown in Table 8, representative sets of ABoxes could be computed in just a few seconds for most LUBM queries. The only exception wasQ9, for which REQUIEM did not terminate after disabling rule subsumption optimisations. The size of the representative sets ranged between 1 and 777 ABoxes. As expected, representative sets contain more ABoxes than the exhaustive test suites for the same query and TBox (see Table 3).\nAll combinations of system and query for which the tests in Section 5.2 identified the system as incomplete are shown in Table 9. The table shows the proportion of certain answers that each system returned when applied to the LUBM data set, the ABoxes in R, and the ABoxes in the test suite S used in Section 5.2 to check the system’s completeness. As shown in the table, OWLim and Jena Micro exhibited the same behaviour and were ‘almost’ complete. In contrast, Sesame was the least complete for all queries. Furthermore, please note the difference between the values obtained for R and those for S; in particular, Sesame did not compute any certain answer for Q5 on S, whereas the system is able to compute certain answers for Q5 on some ABoxes (e.g., on the LUBM data set). This is because the ABoxes in S cannot distinguish Sesame from a trivial reasoner that always returns the empty set of answers; however, the set R can make such a distinction."
    }, {
      "heading" : "5.3.2 Tests with GALEN",
      "text" : "As shown in Table 10, representative sets of ABoxes for GALEN could be computed in times ranging from 2 to 70 seconds, and each set contains only a small number of ABoxes.\nFor each system and query, Table 11 shows the proportion of certain answers returned by the system on R and the test suite S from Section 5.2. Minerva was the most complete system. Jena Micro was better than DLE-Jena (apart from query Q4), while DLE-Jena and OWLim behaved in almost the same way (again apart from query Q4). As expected, Sesame was the least complete system.\nThe discrepancies between OWLim, Jena Micro, DLE-Jena and Minerva are rather surprising. OWLim and Jena theoretically support the same features of OWL; furthermore, DLE-Jena is an extension of Jena (Meditskos & Bassiliades, 2008) so DLE-Jena should be at least as complete as Jena, as in the case of LUBM. In order to explain these discrepancies, we analysed the test suites for queries Q1–Q4. More precisely, we selected ABoxes on which OWLim fails to return all certain answers but on which Jena Micro is complete, and then we identified the minimal set of TBox axioms that entail all certain answers. Our analysis revealed that, for query Q4, OWLim fails to find the entailment\nT ∪ {Device(a),HollowTopology(b), hasTopology(a, b)} |= HollowStructure(a),\nwhich follows from the following GALEN axioms:\nHollowTopology ≡ Topology  ∃hasState.Hollow Device  SolidStructure\nHollowStructure ≡ SolidStructure  ∃hasTopology.(Topology  ∃hasState.Hollow)\nAlthough existential restrictions appear in several axioms, we can observe that no reasoning over existential variables is actually required, as the first and third axioms imply (by a simple structural transformation) the following axiom:\nSolidStructure  ∃hasTopology.HollowTopology  HollowStructure\nThis axiom entails the required answer, and both systems can deal with axioms of this form; however, unlike Jena Micro, OWLim appears to be incapable of dealing with such cases.\nRegarding DLE-Jena, according to its technical description (Meditskos & Bassiliades, 2008), the system has replaced several inference rules of Jena with queries to the DL reasoner, so it does not strictly extend Jena. Our investigation of the exhaustive test suite for query Q4 revealed that DLE-Jena returns many answers that are based on existential restrictions on the right hand side of TBox axioms which Jena misses; however, the investigation also revealed that DLE-Jena misses several inferences that Jena’s TBox reasoner can capture, which is probably due to the replacement of Jena’s inference rules. This also explains why DLE-Jena performs worse than Minerva on GALEN.\nThese results clearly show that the behaviour of systems greatly depends on the given application scenario. For example, DLE-Jena was complete for all LUBM queries, but it did not perform equally well on GALEN. In contrast, Minerva did not perform well on LUBM, but it was the most complete system for GALEN. Our results thus allow application developers to conduct a thorough comparison of reasoning systems for a given application."
    }, {
      "heading" : "6. Conclusion",
      "text" : "In this paper we have proposed a theoretical framework and practical techniques for establishing formally provable and algorithmically verifiable completeness guarantees for incomplete ontology reasoners. Our approach radically departs from ad hoc evaluation based on well-known benchmarks, and it provides a solid foundation for striking the balance between scalability and completeness in practical applications.\nOur approach also opens up numerous and exciting possibilities for future research. For example, our work opens the door to the design of ontology-based information systems that are optimised for a class of ontologies, queries, and data relevant to a particular application. Such information systems could maximise scalability of reasoning while still ensuring completeness of query answers, even for rich ontologies and sophisticated queries."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This is an extended version of the paper ‘How Incomplete is your Semantic Web Reasoner?’ by Giorgos Stoilos, Bernardo Cuenca Grau, and Ian Horrocks published at AAAI 2010 and the paper ‘Completeness Guarantees for Incomplete Reasoners’ by the same authors published at ISWC 2010.\nThis research has been supported by the EU project SEALS (FP7-ICT-238975), and by the EPSRC projects ExODA (EP/H051511/1) and HermiT (EP/F065841/1). B. Cuenca Grau is supported by a Royal Society University Research Fellowship."
    } ],
    "references" : [ {
      "title" : "Quonto: Querying ontologies",
      "author" : [ "A. Acciarri", "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "M. Palmieri", "R. Rosati" ],
      "venue" : "In Proceedings of the 20th National Conference on Artificial Intelligence",
      "citeRegEx" : "Acciarri et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Acciarri et al\\.",
      "year" : 2005
    }, {
      "title" : "The DL-Lite family and relations",
      "author" : [ "A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "J. Artificial Intelligence Research (JAIR),",
      "citeRegEx" : "Artale et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Artale et al\\.",
      "year" : 2009
    }, {
      "title" : "The Description Logic Handbook: Theory, implementation and applications",
      "author" : [ "F. Baader", "D. McGuinness", "D. Nardi", "P. Patel-Schneider" ],
      "venue" : "In Proceedings of the 19th International Joint Conference on AI (IJCAI-05),",
      "citeRegEx" : "Baader et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2002
    }, {
      "title" : "OWLIM: A family of scalable semantic repositories",
      "author" : [ "B. Bishop", "A. Kiryakov", "D. Ognyanoff", "I. Peikov", "Z. Tashev", "R. Velkov" ],
      "venue" : "Semantic Web,",
      "citeRegEx" : "Bishop et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Bishop et al\\.",
      "year" : 2011
    }, {
      "title" : "Sesame: A generic architecture for storing and querying RDF and RDF Schema",
      "author" : [ "J. Broekstra", "A. Kampman", "F. van Harmelen" ],
      "venue" : "In Proceedings of the 1st International Semantic Web Conference (ISWC",
      "citeRegEx" : "Broekstra et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Broekstra et al\\.",
      "year" : 2002
    }, {
      "title" : "Datalog+/-: A family of logical knowledge representation and query languages for new applications",
      "author" : [ "A. Cal̀ı", "G. Gottlob", "T. Lukasiewicz", "B. Marnette", "A. Pieris" ],
      "venue" : "In Proc. of the 25th Annual IEEE Symposium on Logic in Computer Science (LICS),",
      "citeRegEx" : "Cal̀ı et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Cal̀ı et al\\.",
      "year" : 2010
    }, {
      "title" : "Tractable reasoning and efficient query answering in description logics: The DL-Lite family",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "What you always wanted to know about datalog (and never dared to ask)",
      "author" : [ "S. Ceri", "G. Gottlob", "L. Tanca" ],
      "venue" : "IEEE Trans. Knowledge Data Engineering,",
      "citeRegEx" : "Ceri et al\\.,? \\Q1989\\E",
      "shortCiteRegEx" : "Ceri et al\\.",
      "year" : 1989
    }, {
      "title" : "Modular Reuse of Ontologies: Theory and Practice",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Grau et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "OWL 2: The next step for OWL",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "B. Motik", "B. Parsia", "P. Patel-Schneider", "U. Sattler" ],
      "venue" : "Journal of Web Semantics (JWS),",
      "citeRegEx" : "Grau et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "An Ontology of Astronomical Object Types for the Virtual Observatory",
      "author" : [ "S. Derriere", "A. Richard", "A. Preite-Martinez" ],
      "venue" : "In Proc. of the 26th meeting of the IAU: Virtual Observatory in Action: New Science, New Technology, and Next Generation Facilities,",
      "citeRegEx" : "Derriere et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Derriere et al\\.",
      "year" : 2006
    }, {
      "title" : "RDF support in the virtuoso DBMS",
      "author" : [ "O. Erling", "I. Mikhailov" ],
      "venue" : "Networked Knowledge - Networked Media,",
      "citeRegEx" : "Erling and Mikhailov,? \\Q2009\\E",
      "shortCiteRegEx" : "Erling and Mikhailov",
      "year" : 2009
    }, {
      "title" : "First-Order Logic and Automated Theorem Proving, 2nd Edition",
      "author" : [ "M. Fitting" ],
      "venue" : "Texts in Computer Science. Springer.",
      "citeRegEx" : "Fitting,? 1996",
      "shortCiteRegEx" : "Fitting",
      "year" : 1996
    }, {
      "title" : "Conjunctive query answering for the description logic SHIQ",
      "author" : [ "B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler" ],
      "venue" : "In Proceedings of the International Joint Conference on AI (IJCAI),",
      "citeRegEx" : "Glimm et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Glimm et al\\.",
      "year" : 2007
    }, {
      "title" : "The Foundational Model of Anatomy in OWL: Experience and Perspectives",
      "author" : [ "C. Golbreich", "S. Zhang", "O. Bodenreider" ],
      "venue" : "Journal of Web Semantics,",
      "citeRegEx" : "Golbreich et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Golbreich et al\\.",
      "year" : 2006
    }, {
      "title" : "Experiences of using OWL at the Ordnance Survey",
      "author" : [ "J. Goodwin" ],
      "venue" : "Proc. of the OWL: Experiences and Directions Workshop (OWLED 2005), Galway, Ireland.",
      "citeRegEx" : "Goodwin,? 2005",
      "shortCiteRegEx" : "Goodwin",
      "year" : 2005
    }, {
      "title" : "LUBM: A Benchmark for OWL Knowledge Base Systems",
      "author" : [ "Y. Guo", "Z. Pan", "J. Heflin" ],
      "venue" : "Journal of Web Semantics,",
      "citeRegEx" : "Guo et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Guo et al\\.",
      "year" : 2005
    }, {
      "title" : "RACER System Description",
      "author" : [ "V. Haarslev", "R. Möller" ],
      "venue" : "Proc. of the 1st Int. Joint Conf. on Automated Reasoning (IJCAR",
      "citeRegEx" : "Haarslev and Möller,? \\Q2001\\E",
      "shortCiteRegEx" : "Haarslev and Möller",
      "year" : 2001
    }, {
      "title" : "RDF Semantics",
      "author" : [ "P. Hayes" ],
      "venue" : "World Wide Web Consortium (W3C) Recommendation.",
      "citeRegEx" : "Hayes,? 2004",
      "shortCiteRegEx" : "Hayes",
      "year" : 2004
    }, {
      "title" : "From SHIQ and RDF to OWL: the making of a web ontology language",
      "author" : [ "I. Horrocks", "P.F. Patel-Schneider", "F. van Harmelen" ],
      "venue" : "Journal Web Semantics,",
      "citeRegEx" : "Horrocks et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Horrocks et al\\.",
      "year" : 2003
    }, {
      "title" : "Owlim-a pragmatic semantic repository for owl",
      "author" : [ "A. Kiryakov", "D. Ognyanov", "D. Manov" ],
      "venue" : "WISE Workshops,",
      "citeRegEx" : "Kiryakov et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Kiryakov et al\\.",
      "year" : 2005
    }, {
      "title" : "Experiences Using OWL in Military Applications",
      "author" : [ "L. Lacy", "G. Aviles", "K. Fraser", "W. Gerber", "A. Mulvehill", "R. Gaskill" ],
      "venue" : "In Proc. of the OWL: Experiences and Directions Workshop (OWLED",
      "citeRegEx" : "Lacy et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Lacy et al\\.",
      "year" : 2005
    }, {
      "title" : "Conjunctive query answering in the description logic EL using a relational database system",
      "author" : [ "C. Lutz", "D. Toman", "F. Wolter" ],
      "venue" : "In Proceedings of the 21st International Joint Conference on AI (IJCAI),",
      "citeRegEx" : "Lutz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Lutz et al\\.",
      "year" : 2009
    }, {
      "title" : "Towards a complete OWL ontology benchmark",
      "author" : [ "L. Ma", "Y. Yang", "Z. Qiu", "G.T. Xie", "Y. Pan", "S. Liu" ],
      "venue" : "In Proceedings of the 3rd European Semantic Web Conference (ESWC",
      "citeRegEx" : "Ma et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Ma et al\\.",
      "year" : 2006
    }, {
      "title" : "Jena: Implementing the RDF Model and Syntax Specification",
      "author" : [ "McBride", "Brian" ],
      "venue" : "International Workshop on the Semantic Web 2001.",
      "citeRegEx" : "McBride and Brian,? 2001",
      "shortCiteRegEx" : "McBride and Brian",
      "year" : 2001
    }, {
      "title" : "Combining a DL reasoner and a rule engine for improving entailment-based OWL reasoning",
      "author" : [ "G. Meditskos", "N. Bassiliades" ],
      "venue" : "In Proceedings of the 7th International Semantic Web Conference (ISWC",
      "citeRegEx" : "Meditskos and Bassiliades,? \\Q2008\\E",
      "shortCiteRegEx" : "Meditskos and Bassiliades",
      "year" : 2008
    }, {
      "title" : "OWL 2 Web Ontology Language Profiles",
      "author" : [ "B. Motik", "B. Cuenca Grau", "I. Horrocks", "Z. Wu", "A. Fokoue", "C. Lutz" ],
      "venue" : null,
      "citeRegEx" : "Motik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2009
    }, {
      "title" : "Hypertableau Reasoning for Description Logics",
      "author" : [ "B. Motik", "R. Shearer", "I. Horrocks" ],
      "venue" : "J. Artificial Intelligence Research (JAIR),",
      "citeRegEx" : "Motik et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2009
    }, {
      "title" : "Data complexity of query answering in expressive description logics via tableaux",
      "author" : [ "M. Ortiz", "D. Calvanese", "T. Eiter" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2008
    }, {
      "title" : "Efficient Query Answering for OWL",
      "author" : [ "H. Pérez-Urbina", "I. Horrocks", "B. Motik" ],
      "venue" : "Proceedings of the 8th International Semantic Web Conference (ISWC 2009),",
      "citeRegEx" : "Pérez.Urbina et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Pérez.Urbina et al\\.",
      "year" : 2009
    }, {
      "title" : "Tractable query answering and rewriting under description logic constraints",
      "author" : [ "H. Pérez-Urbina", "B. Motik", "I. Horrocks" ],
      "venue" : "Journal of Applied Logic,",
      "citeRegEx" : "Pérez.Urbina et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Pérez.Urbina et al\\.",
      "year" : 2010
    }, {
      "title" : "SPARQL query language for RDF",
      "author" : [ "E. Prud’hommeaux", "A. Seaborne" ],
      "venue" : "World Wide Web Consortium (W3C)",
      "citeRegEx" : "Prud.hommeaux and Seaborne,? \\Q2008\\E",
      "shortCiteRegEx" : "Prud.hommeaux and Seaborne",
      "year" : 2008
    }, {
      "title" : "Ontological and practical issues in using a description logic to represent medical concept systems: Experience from galen",
      "author" : [ "A.L. Rector", "J. Rogers" ],
      "venue" : "Reasoning Web, Second International Summer School",
      "citeRegEx" : "Rector and Rogers,? \\Q2006\\E",
      "shortCiteRegEx" : "Rector and Rogers",
      "year" : 2006
    }, {
      "title" : "Protein Ontology Development using OWL",
      "author" : [ "A. Sidhu", "T. Dillon", "E. Chang", "B.S. Sidhu" ],
      "venue" : "In Proc. of the OWL: Experiences and Directions Workshop (OWLED",
      "citeRegEx" : "Sidhu et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Sidhu et al\\.",
      "year" : 2005
    }, {
      "title" : "Pellet: A practical OWL-DL reasoner",
      "author" : [ "E. Sirin", "B. Parsia", "B. Cuenca Grau", "A. Kalyanpur", "Y. Katz" ],
      "venue" : "Journal of Web Semantics,",
      "citeRegEx" : "Sirin et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Sirin et al\\.",
      "year" : 2007
    }, {
      "title" : "Reengineering Thesauri for New Applications: The AGROVOC Example",
      "author" : [ "D. Soergel", "B. Lauser", "A. Liang", "F. Fisseha", "J. Keizer", "S. Katz" ],
      "venue" : "J. of Digital Information,",
      "citeRegEx" : "Soergel et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Soergel et al\\.",
      "year" : 2004
    }, {
      "title" : "Implementing an inference engine for rdfs/owl constructs and user-defined rules in oracle",
      "author" : [ "Z. Wu", "G. Eadon", "S. Das", "E.I. Chong", "V. Kolovski", "M. Annamalai", "J. Srinivasan" ],
      "venue" : "In Proceedings of the 2008 IEEE 24th International Conference on Data Engineering (ICDE",
      "citeRegEx" : "Wu et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Wu et al\\.",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "Efficient management and querying of large amounts of data is a core problem for a growing range of applications in fields as diverse as biology (Sidhu, Dillon, Chang, & Sidhu, 2005), medicine (Golbreich, Zhang, & Bodenreider, 2006), geography (Goodwin, 2005), astronomy (Derriere, Richard, & Preite-Martinez, 2006), agriculture (Soergel, Lauser, Liang, Fisseha, Keizer, & Katz, 2004), and defence (Lacy, Aviles, Fraser, Gerber, Mulvehill, & Gaskill, 2005).",
      "startOffset" : 244,
      "endOffset" : 259
    }, {
      "referenceID" : 18,
      "context" : "In particular, RDF (Hayes, 2004) provides a standard model for semistructured data, SPARQL (Prud’hommeaux & Seaborne, 2008) is a standard query language for RDF, and ontology languages such as OWL (Horrocks, Patel-Schneider, & van Harmelen, 2003) and OWL 2 (Cuenca Grau, Horrocks, Motik, Parsia, Patel-Schneider,",
      "startOffset" : 19,
      "endOffset" : 32
    }, {
      "referenceID" : 23,
      "context" : "University Benchmark (LUBM) (Guo, Pan, & Heflin, 2005) and the University Ontology Benchmark (UOBM) (Ma et al., 2006) have been used for such completeness testing.",
      "startOffset" : 100,
      "endOffset" : 117
    }, {
      "referenceID" : 6,
      "context" : "For T expressed in OWL 2 QL, a rewriting R can be computed using the algorithm by Calvanese et al. (2007); additionally, the algorithm by Pérez-Urbina, Motik, and Horrocks (2010) can sometimes compute R even if T is syntactically outside this fragment.",
      "startOffset" : 82,
      "endOffset" : 106
    }, {
      "referenceID" : 6,
      "context" : "For T expressed in OWL 2 QL, a rewriting R can be computed using the algorithm by Calvanese et al. (2007); additionally, the algorithm by Pérez-Urbina, Motik, and Horrocks (2010) can sometimes compute R even if T is syntactically outside this fragment.",
      "startOffset" : 82,
      "endOffset" : 179
    }, {
      "referenceID" : 28,
      "context" : "In many cases, T can be transformed into a datalog±,∨ program using equivalence-preserving transformations; furthermore, the algorithm by Pérez-Urbina et al. (2010) can in many cases produce a plain datalog rewriting.",
      "startOffset" : 138,
      "endOffset" : 165
    }, {
      "referenceID" : 12,
      "context" : "The notions of variables, terms, atoms, first-order formulae, and sentences are defined as usual (Fitting, 1996); we do not consider function symbols in this article and we assume all formulae to be function-free.",
      "startOffset" : 97,
      "endOffset" : 112
    }, {
      "referenceID" : 6,
      "context" : "a TBox T is another query that captures all the information from T that is relevant for answering Q over an arbitrary ABox A (Calvanese et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009; Pérez-Urbina et al., 2010).",
      "startOffset" : 125,
      "endOffset" : 230
    }, {
      "referenceID" : 30,
      "context" : "a TBox T is another query that captures all the information from T that is relevant for answering Q over an arbitrary ABox A (Calvanese et al., 2007; Artale, Calvanese, Kontchakov, & Zakharyaschev, 2009; Pérez-Urbina et al., 2010).",
      "startOffset" : 125,
      "endOffset" : 230
    }, {
      "referenceID" : 6,
      "context" : "In practice, UCQs (Calvanese et al., 2007) and datalog (Pérez-Urbina et al.",
      "startOffset" : 18,
      "endOffset" : 42
    }, {
      "referenceID" : 30,
      "context" : ", 2007) and datalog (Pérez-Urbina et al., 2010) are the most widely used target languages for query rewriting.",
      "startOffset" : 20,
      "endOffset" : 47
    }, {
      "referenceID" : 6,
      "context" : "For example, Calvanese et al. (2007) showed how to compute a UCQ rewriting in cases when T is expressed in a logic from the DL-Lite family, and this approach can be extended to the OWL 2 QL profile of OWL 2 (Motik et al.",
      "startOffset" : 13,
      "endOffset" : 37
    }, {
      "referenceID" : 6,
      "context" : "For example, Calvanese et al. (2007) showed how to compute a UCQ rewriting in cases when T is expressed in a logic from the DL-Lite family, and this approach can be extended to the OWL 2 QL profile of OWL 2 (Motik et al., 2009a). Similarly, Pérez-Urbina et al. (2010) proposed an algorithm for computing the simplest possible datalog rewriting when T is expressed in the description logic ELHIO.",
      "startOffset" : 13,
      "endOffset" : 268
    }, {
      "referenceID" : 6,
      "context" : "In particular, a UCQ rewriting is guaranteed to exist if T is expressed in the DLs underpinning the QL profile of OWL 2 (Motik et al., 2009a; Calvanese et al., 2007); furthermore, as illustrated in Example 3.",
      "startOffset" : 120,
      "endOffset" : 165
    }, {
      "referenceID" : 0,
      "context" : "In practice, such rewritings can be computed using systems such as QuOnto (Acciarri et al., 2005) and REQUIEM (Pérez-Urbina et al.",
      "startOffset" : 74,
      "endOffset" : 97
    }, {
      "referenceID" : 30,
      "context" : ", 2005) and REQUIEM (Pérez-Urbina et al., 2010).",
      "startOffset" : 20,
      "endOffset" : 47
    }, {
      "referenceID" : 6,
      "context" : "This goal can be achieved by applying known techniques for minimising UCQ rewritings (Calvanese et al., 2007; Pérez-Urbina, Horrocks, & Motik, 2009).",
      "startOffset" : 85,
      "endOffset" : 148
    }, {
      "referenceID" : 16,
      "context" : "The first one uses the well-known Lehigh University Benchmark (LUBM) (Guo et al., 2005), which consists of a relatively small TBox about an academic domain, 14 test queries, and a data generator.",
      "startOffset" : 69,
      "endOffset" : 87
    } ],
    "year" : 2012,
    "abstractText" : "To achieve scalability of query answering, the developers of Semantic Web applications are often forced to use incomplete OWL 2 reasoners, which fail to derive all answers for at least one query, ontology, and data set. The lack of completeness guarantees, however, may be unacceptable for applications in areas such as health care and defence, where missing answers can adversely affect the application’s functionality. Furthermore, even if an application can tolerate some level of incompleteness, it is often advantageous to estimate how many and what kind of answers are being lost. In this paper, we present a novel logic-based framework that allows one to check whether a reasoner is complete for a given query Q and ontology T —that is, whether the reasoner is guaranteed to compute all answers to Q w.r.t. T and an arbitrary data set A. Since ontologies and typical queries are often fixed at application design time, our approach allows application developers to check whether a reasoner known to be incomplete in general is actually complete for the kinds of input relevant for the application. We also present a technique that, given a query Q, an ontology T , and reasoners R1 and R2 that satisfy certain assumptions, can be used to determine whether, for each data set A, reasoner R1 computes more answers to Q w.r.t. T and A than reasoner R2. This allows application developers to select the reasoner that provides the highest degree of completeness forQ and T that is compatible with the application’s scalability requirements. Our results thus provide a theoretical and practical foundation for the design of future ontology-based information systems that maximise scalability while minimising or even eliminating incompleteness of query answers.",
    "creator" : "TeX"
  }
}