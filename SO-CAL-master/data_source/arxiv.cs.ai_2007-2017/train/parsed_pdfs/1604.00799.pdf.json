{
  "name" : "1604.00799.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Enrico Franconi" ],
    "emails" : [ "artale@inf.unibz.it", "franconi@inf.unibz.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 4.\n00 79\n9v 1\n[ cs\n.A I]\n4 A"
    }, {
      "heading" : "1 Introduction",
      "text" : "We introduce in this paper the language DLR` which extends the n-ary description logicsDLR [Calvanese et al., 1998; Baader et al., 2003] andDLRifd [Calvanese et al., 2001] as follows:\n– the semantics is based on attribute-labelled tuples: an element of a tuple is identified by an attribute and not by its position in the tuple, e.g., the relation Person has attributes firstname, lastname, age, height with instance: x firstname: Enrico, lastname: Franconi, age: 53, height: 1.90y;\n– renaming of attributes is possible, e.g., to recover the positional semantics: firstname,lastname,age,heightí 1,2,3,4;\n– it can express projections of relations, and therefore inclusion dependencies, e.g., Drfirstname,lastnamesStudent Ď Drfirstname,lastnamesPerson;\n– it can express multiple-attribute cardinalities, and therefore functional dependencies and multiple-attribute keys, e.g., the functional dependency fromfirstname, lastname to age in Person can be written as: Drfirstname,lastnamesPerson Ď Dď1rfirstname,lastnamespDrfirstname,lastname,agesPersonq; – it can express global and local objectification (also known as reification): a tuple\nmay be identified by a unique global identifier, or by an identifier which is unique only within the interpretation of a relation, e.g., to identify the name of a person we can write Name Ď Ä Drfirstname,lastnamesPerson.\nWe show how a simple syntactic condition on the appearance of projections in the knowledge base makes the language decidable without increasing the computational complexity of the basic DLR language. We call DLR˘ this fragment of DLR`."
    }, {
      "heading" : "DLR",
      "text" : "˘ is able to correctly express the UML fragment as introduced in [Berardi et al., 2005; Artale et al., 2007] and the ORM fragment as introduced in [Franconi and Mosca, 2013].\n2 Syntax of the Description Logic DLR`\nWe first define the syntax of the language DLR`. A signature in DLR` is a triple L “ pC,R,U , τq consisting of a finite set C of concept names (denoted by CN ), a finite set R of relation names (denoted by RN ) disjoint from C, and a finite set U of attributes (denoted by U ), and a relation signature function τ associating a set of attributes to each relation name, τpRNq “ tU1, . . . , Unu Ď U with n ě 2.\nThe syntax of concepts C, relations R, formulas ϕ, and attribute renaming axioms ϑ is defined in Figure 1, where q is a positive integer and 2 ď k ă ARITYpRq. We extend the signature function τ to arbitrary relations as specified in Figure 2. We define the ARITY of a relation R as the number of the attributes in its signature, namely |τpRq|.\nA DLR` TBox T is a finite set of formulas, i.e., concept inclusion axioms of the form C1 Ď C2 and relation inclusion axioms of the form R1 Ď R2. A renaming schema induces an equivalence relation pí,Uq over the attributes U , providing a partition of U into equivalence classes each one representing the alternative ways to name attributes. We write rU sℜ to denote the equivalence class of the attribute U w.r.t. the equivalence relation pí,Uq. We allow only well founded renaming schemas, namely schemas such that each equivalence class rU sℜ in the induced equivalence relation never contains two attributes from the same relation signature. In the\nfollowing we use the shortcut U1 . . . Un í U 11 . . . U 1 n to group many renaming axioms, with the obvious meaning that Ui í U 1i , for all i “ 1, . . . , n. A DLR` knowledge base KB “ pT ,ℜq is composed by a TBox T and a renaming schema ℜ. The renaming schema reconciles the attribute and the positional perspectives on relations (see also the similar perspectives in relational databases [Abiteboul et al., 1995]). They are crucial when expressing both inclusion axioms and operators ([, \\, z) between relations, which make sense only over union compatible relations. Two relations R1, R2 are union compatible if their signatures are equal up to the attribute renaming induced by the renaming schema ℜ, namely, τpR1q “ tU1, . . . , Unu and τpR2q “ tV1, . . . , Vnu have the same arity n and rUisℜ “ rVisℜ for each 1 ď i ď n. Notice that, thanks to the renaming schema, relations can use just local attribute names that can then be renamed when composing relations. Also note that it is obviously possible for the same attribute to appear in the signature of different relations.\nTo show the expressive power of the language, let us consider the following example with tree relation names R1, R2 and R3 with the following signature:\nτpR1q “ tU1, U2, U3, U4, U5u\nτpR2q “ tV1, V2, V3, V4, V5u\nτpR3q “ tW1,W2,W3,W4u\nTo state that tU1, U2u is the multi-attribute key of R1 we add the axiom:\nDrU1, U2sR1 Ď D ď1rU1, U2sR1\nwhere DrU1, . . . , UksR stands for Dě1rU1, . . . , UksR. To express that there is a functional dependency from the attributes tV3, V4u to the attribute tV5u of R2 we add the axiom:\nDrV3, V4sR2 Ď D ď1rV3, V4spDrV3, V4, V5sR2q (1)\nThe following axioms express that R2 is a sub-relation of R1 and that a projection of R3 is a sub-relation of a projection of R1, together with the corresponding axioms for the renaming schema to explicitly specify the correspondences between the attributes of the two inclusion dependencies:\nR2 Ď R1\nDrW1,W2,W3sR3 Ď DrU3, U4, U5sR1\nV1V2V3V4V5 í U1U2U3U4U5\nW1W2W3 í U3U4U5"
    }, {
      "heading" : "3 Semantics",
      "text" : "The semantics makes use of the notion of labelled tuples over a domain set ∆: a Ulabelled tuple over ∆ is a function t : U Ñ ∆. For U P U , we write trU s to refer\nto the domain element d P ∆ labelled by U , if the function t is defined for U – that is, if the attribute U is a label of the tuple t. Given d1, . . . , dn P ∆, the expression xU1 : d1, . . . , Un : dny stands for the U-labelled tuple t over ∆ (tuple, for short) such that trUis “ di, for 1 ď 1 ď n. We write trU1, . . . , Uks to denote the projection of the tuple t over the attributes U1, . . . , Uk, namely the function t restricted to be undefined for the labels not in U1, . . . , Uk. The set of all U-labelled tuples over ∆ is denoted by T∆pUq.\nA DLR` interpretation, I “ p∆, ¨I , ρ, ı, ℓRN1, ℓRN2 , . . .q, consists of a nonempty domain ∆, an interpretation function ¨I , a renaming function ρ, a global objectification function ı, and a family of local objectification functions ℓRNi , one for each named relation RNi P R.\nThe renaming function ρ for attributes is a total function ρ : U Ñ U representing a canonical renaming for all attributes. We consider, as a shortcut, the notation ρptU1, . . . , Ukuq “ tρpU1q, . . . , ρpUkqu. The global objectification function is an injective function, ı : T∆pUq Ñ ∆, associating a unique global identifier to each possible tuple. The local objectification functions, ℓRNi : T∆pUq Ñ ∆, are distinct for each relation name in the signature, and as the global objectification function they are injective: they associate an identifier – which is unique only within the interpretation of a relation name – to each possible tuple. The interpretation function ¨I assigns a set of domain elements to each concept name, CNI Ď ∆, and a set of U-labelled tuples over ∆ to each relation name conforming with its signature and the renaming function:\nRNI Ď T∆ptρpUq | U P τpRNquq.\nThe interpretation function ¨I is unambiguously extended over concept and relation expressions as specified in the inductive definition of Fig. 3.\nAn interpretation I satisfies a concept inclusion axiom C1 Ď C2 if CI1 Ď C I 2 , it satisfies a relation inclusion axiom R1 Ď R2 if RI1 Ď R I 2\n, and it satisfies a renaming schema ℜ if the renaming function ρ renames the attributes in a consistent way with respect to ℜ, namely if\n@U . ρpUq P rU sℜ ^ @V P rU sℜ. ρpUq “ ρpV q.\nAn interpretation is a model for a knowledge base pT ,ℜq if it satisfies all the formulas in the TBox T and it satisfies the renaming schema ℜ. We define KB satisfiability as the problem of deciding the existence of a model of a given knowledge base, concept satisfiability (resp. relation satisfiability) as the problem of deciding whether there is a model of the knowledge base that assigns a non-empty extension to a given concept (resp. relation), and entailment as the problem to check whether a given knowledge base logically implies a formula, that is, whenever all the models of the knowledge base are also models of the formula. For example, from the knowledge base KB introduced in the previous Section the following logical implication holds:\nKB |ù DrV1, V2sR2 Ď D ď1rV1, V2sR2\ni.e., the attributes V1, V2 are a key for the relation R2.\nProposition 1. The problems of KB satisfiability, concept and relation satisfiability, and entailment are mutually reducible in DLR`.\nProof. We first show that we can reduce all the problems to concept satisfiability, where a concept C is satisfiable iff KB * C Ď K.\n– KB is satisfiable iff KB * J Ď K; – KB |ù C1 Ď C2 iff KB |ù C1 [ C2 Ď K; – KB |ù R1 Ď R2 iff KB |ù DrU spR1 [ R2q Ď K, for some U P τpR1q; – KB * R Ď K iff KB * DrU sR Ď K, for some U P τpRq.\nViceversa, we can show that concept satisfiability can be reduced to any other problem. First, note that concept satisfiability is already expressed as a logical implication problem. For the other cases, given a fresh new binary relation P , we have that\n– KB * C Ď K iff KB Y tJ Ď DrU1spP [ σU2:CP qu is satisfiable; – KB * C Ď K iff KB * σU2:CP Ď K. [\\\nDLR ` can express complex inclusion and functional dependencies, for which it is well known that reasoning is undecidable [Mitchell, 1983; Chandra and Vardi, 1985]."
    }, {
      "heading" : "DLR",
      "text" : "` also includes the DLR extension DLRifd together with unary functional dependencies [Calvanese et al., 2001], which also has been proved to be undecidable.\n4 The DLR˘ fragment of DLR`\nGiven a DLR` knowledge base pT ,ℜq, we define the projection signature as the set T including the signatures τpRNq of the relations RN P R, the singletons associated with each attribute name U P U , and the relation signatures as they appear explicitly in projection constructs in the relation inclusion axioms of the knowledge base, together with their implicit occurrences due to the renaming schema:\n1. τpRNq P T if RN P R; 2. tUu P T if U P U ; 3. tU1, . . . , Uku P T if DĳqrV1, . . . , VksR P T and tUi, Viu Ď rUisℜ for 1ď iďk.\nWe call projection signature graph the directed acyclic graph pĄ,T q with the attribute singletons tUu being the sinks. The DLR˘ fragment of DLR` allows only for knowledge bases with a projection signature graph being a multitree, namely the set of nodes reachable from any node of the projection signature graph should form a tree. Given a relation name RN , the subgraph of the projection signature graph dominated by RN is a tree where the leaves are all the attributes in τpRNq and the root is τpRNq. We call TtU1,...,Uku the tree formed by the nodes in the projection signature graph dominated by the set of attributes tU1, . . . , Uku. Given two relation signatures (i.e., two sets of attributes) τ1, τ2 Ď U , by PATHT pτ1, τ2q we denote the path in pĄ,T q between τ1 and τ2, if it exists. Note that PATHT pτ1, τ2q “ H both when a path does not exist and when τ1 Ď τ2, and PATHT is functional in DLR\n˘ due to the multitree restriction on projection signatures. The notation CHILDT pτ1, τ2q means that τ2 is a child of τ1 in pĄ,T q.\nIn addition to the above multitree condition, the DLR˘ fragment of DLR` allows for knowledge bases with projection constructs DĳqrU1, . . . , UksR (resp. DĳqrU sR) with a cardinality q ą 1 only if the length of the path PATHT ptU1, . . . , Uku, τpRqq (resp. PATHT ptUu, τpRqq) is 1. This allows to map cardinalities in DLR\n˘ into cardinalities in ALCQI.\nFigure 4 shows that the projection signature graph of the knowledge base introduced in Section 2 is indeed a multitree. Note that in the figure we have collapsed equivalent attributes in a unique equivalence class, according to the renaming schema.\nDLR ˘ restricts DLR` only in the way multiple projections of relations appear in the knowledge base. It is easy to see that DLR is included in DLR˘, since the projection signature graph of any DLR knowledge base has maximum depth equal to 1. DLRifd [Calvanese et al., 2001] together with (unary) functional dependencies is also included in DLR˘, with the proviso that projections of relations in the knowledge base form a multitree projection signature graph. Since (unary) functional dependencies are expressed via the inclusions of projections of relations (see, e.g., the functional dependency (1) in the previous example), by constraining the projection signature graph to be a multitree, the possibility to build combinations of functional dependencies as the ones in [Calvanese et al., 2001] leading to undecidability is ruled out. Also note that DLR˘ is able to correctly express the UML fragment as introduced in [Berardi et al., 2005; Artale et al., 2007] and the ORM fragment as introduced in [Franconi and Mosca, 2013].\n5 Mapping DLR˘ to ALCQI\nWe show that reasoning in DLR˘ is EXPTIME-complete by providing a mapping from DLR˘ knowledge bases to ALCQI knowledge bases; the reverse mapping from ALCQI knowledge bases to DLR knowledge bases is well known. The proof is based on the fact that reasoning with ALCQI knowledge bases is EXPTIME-complete [Baader et al., 2003]. We adapt and extend the mapping presented for DLR in [Calvanese et al., 1998].\nIn the following we use the shortcut pS1 ˝ . . . ˝Snq´ for S´n ˝ . . . ˝S ´ 1\n, the shortcut Dĳ1S1 ˝ . . . ˝ Sn.C for Dĳ1S1. . . . . Dĳ1Sn.C and the shortcut @S1 ˝ . . . ˝ Sn.C for @S1. . . . .@Sn.C. Note that these shortcuts for the role chain constructor “˝” are not correct in general, but they are correct in the context of the specific ALCQI knowledge bases used in this paper.\nLet KB “ pT ,ℜq be a DLR˘ knowledge base. We first rewrite the knowledge base as follows: for each equivalence class rU sℜ a single canonical representative of the class is chosen, and the KB is consistently rewritten by substituting each attribute with its canonical representative. After this rewriting, the renaming schema does not play any role in the mapping.\nThe mapping function ¨: maps each concept name CN in the DLR˘ knowledge base to an ALCQI concept name CN , each relation name RN in the DLR˘ knowledge base to an ALCQI concept name ARN (its global reification), and each attribute name U in the DLR˘ knowledge base to an ALCQI role name, as detailed below. For each relation name RN the mapping introduces a concept name AlRN and a role name QRN (to capture the local reification), and a concept name A τi RN for each projected signature τi in the projection signature graph dominated by τpRNq, τi P TτpRNq (to capture global reifications of the projections of RN ). Note that AτpRNqRN coincides with ARN . Furthermore, the mapping introduces a role name Qτi for each projected signature τi in the projection signature, τi P T , such that there exists τj P T with CHILDT pτj , τiq, i.e., we exclude the case where τi is one of the roots of the multitree\ninduced by the projection signature. The mapping ¨: applies also to a path. Let τ, τ 1 P T be two generic sets of attributes such that the function PATHT pτ, τ 1q “ τ, τ1, . . . , τn, τ 1, then, a path is mapped as follows:\nPATHT pτ, τ 1q: “ Qτ1 ˝ . . . ˝Qτn ˝Qτ 1 .\nIntuitively, the mapping reifies each node in the projection signature graph: the target ALCQI signature of the example of the previous section is partially presented in Fig. 5, together with the projection signature graph. Each node is labelled with the corresponding (global) reification concept (AτjRi ), for each relation name Ri and each projected signature τj in the projection signature graph dominated by τpRiq, while the edges are labelled by the roles (Qτi) needed for the reification.\nThe mapping ¨: is extended to concept and relation expressions as in Figure 6, with the proviso that whenever PATHT pτ1, τ2q returns an empty path then the translation for\nthe corresponding expression becomes the bottom concept. Note that in DLR˘ the cardinalities on a path are restricted to the case q “ 1 whenever a path is of length greater than 1, so we still remain within the ALCQI description logic when the mapping applies to cardinalities. So, if we need to express a cardinality constraint DĳqrUisR,] with q ą 1, then Ui should not be mentioned in any other projection of the relation R in such a way that |PATHT pτpRq, tUiuq| “ 1.\nIn order to explain the need for the path function in the mapping, notice that a relation is reified according to the decomposition dictated by projection signature graph it dominates. Thus, to access an attribute Uj of a relation Ri it is necessary to follow the path through the projections that use that attribute. This path is a role chain from the signature of the relation (the root) to the attribute as returned by the PATHT pτpRiq, Uiq function. For example, considering Fig. 5, in order to access the attribute U4 of the relation R3 in the expression pσU4:CR3q, the path PATHT pτpR3q, tU4uq\n: is equal to the role chain QtU3,U4,U5u˝QtU3,U4u˝QtU4u, so that pσU4:CR3q\n: “ AR3[@QtU3,U4,U5u˝ QtU3,U4u ˝QtU4u.C. Similar considerations can be done when mapping cardinalities over relation projections.\nThe mapping γpKBq of a DLR˘ knowledge base KB with a signature pC,R,U , τq is defined as the following ALCQI TBox:\nγpKBq “ γdsj Y ď\nRNPR\nγrelpRNq Y ď\nRNPR\nγlobjpRNq Y\nď\nC1ĎC2PKB\nC : 1 Ď C : 2 Y\nď\nR1ĎR2PKB\nR : 1 Ď R : 2\nwhere\nγdsj “ AτiRN1 Ď A τj RN2 | RN1, RN2 P R, τi, τj P T , |τi| ě 2, |τj| ě 2, τi ‰ τj (\nγrelpRNq “ ď\nτiPTτpRNq\nď\nCHILDT pτi,τjq\nAτiRN Ď DQτj .A τj RN , D ě2Qτj .J Ď K (\nγlobjpRNq “ tARN Ď DQRN .AlRN , D ě2QRN .J Ď K,\nAlRN Ď DQ ´ RN .ARN , D ě2Q´RN .J Ď Ku.\nIntuitively, γdsj ensures that relations with different signatures are disjoint, thus, e.g., enforcing the union compatibility. The axioms in γrel introduce classical reification axioms for each relation and its relevant projections. The axioms in γlobj make sure that each local objectification differs form the global one.\nClearly, the size of γpKBq is polynomial in the size of KB (under the same coding of the numerical parameters), and thus we are able to state the main result of this paper.\nTheorem 2. A DLR˘ knowledge base KB is satisfiable iff the ALCQI knowledge base γpKBq is satisfiable.\nProof. We assume that the KB is consistently rewritten by substituting each attribute with its canonical representative, thus, we do not have to deal with the renaming of attributes. Furthermore, we extend the function ı to singleton tuples with the meaning\nthat ıpxUi : diyq “ di. (ñ) Let I “ p∆I , ¨I , ρ, ı, ℓRN1, . . .q be a model for a DLR\n˘ knowledge base KB. To construct a model J “ p∆J , ¨J q for the ALCQI knowledge base γpKBq we set ∆J “ ∆I . Furthermore, we set: pCN :qJ “ pCNqI , for every atomic conceptCN P C, while for every RN P R and τi P TτpRNq we set\npAτiRN q J “ tıpxU1 : d1, . . . , Uk : dkyq | tU1, . . . , Uku “ τi and\nDt P RNI . trU1s “ d1, . . . , trUks “ dku. (2)\nFor each role name Qτi , τi P T , we set\npQτiq J “ tpd1, d2q P ∆ J ˆ∆J | Dt P RNI s.t. d1 “ ıptrτjsq, d2 “ ıptrτisq\nand CHILDT pτj , τiq, for some RN P Ru. (3)\nFor every RN P R we set\nQJRN “ tpd1, d2q P ∆ J ˆ ∆J | Dt P RNI s.t. d1 “ ıptq and d2 “ ℓRN ptqu, (4)\nand\npAlRN q J “ tℓRNptq | t P RN Iu. (5)\nWe now show that J is indeed a model of γpKBq.\n1. J |ù γdsj. This is a direct consequence of the fact that ı is an injective function and that tuples with different aryties are different tuples. 2. J |ù γrelpRNq, for everyRN P R. We show that, for each τi, τj s.t. CHILDT pτi, τjq and τi P TτpRNq, J |ù A τi RN Ď DQτj .A τj RN and J |ù D\ně2Qτj .J Ď K: – J |ù AτiRN Ď DQτj .A τj RN . Let d P pA τi RN q\nJ , by (2), Dt P RNI s.t. d “ ıptrτisq. Since CHILDT pτi, τjq, then Dd1 “ ıptrτjsq and, by (3), pd, d1q P QJτj , while by (2), d1 P pAτjRN q J . Thus, d P pDQτj .A τj RN q\nJ . – J |ù Dě2Qτj .J Ď K. The fact that each Qτj is interpreted as a funcional role\nis a direct consequence of the construction (3) and the fact that ı is an injective function.\n3. J |ù γlobjpRNq, for every RN P R. Similar as above, considering the fact that each ℓRN is an injective function and equations (4)-(5). 4. J |ù C: 1 Ď C : 2 and J |ù R: 1 Ď R : 2 . Since I |ù C1 Ď C2 and I |ù R1 Ď R2, It is\nenough to show the following: – d P CI iff d P pC:qJ , for all DLR˘ concepts; – t P RI iff ıptq P pR:qJ , for all DLR˘ relations. Before we proceed with the proof, it is easy to show by structural induction that the following property holds:\nIf ıptq P R:J then Dıpt1q P RN :J s.t. t “ t1rτpRqs, for some RN P R. (6)\nWe now proceed with the proof by structural induction. The base cases, for atomic concepts and roles, are immediate form the definition of both CNJ and RNJ . The\ncases where complex concepts and relations are constructed using either boolean operators or global reification are easy to show. We thus show only the following cases. Let d P p Ä\nRNqI . Then, d “ ℓRN ptq with t P RNI . By induction, ıptq P AJRN and, by γlobjpRNq, there is a d1 P ∆J s.t. pıptq, d1q P QJRN and d 1 P pAlRN q J . By (4), d1 “ ℓRNptq and, since ℓRN is injective, d1 “ d. Thus, d P p Ä\nRNq:J . Let d P pDěqrUisRqI . Then, there are different t1, . . . , tq P RI s.t. tlrUis “ d, for all l “ 1, . . . , q. By induction, ıptlq P R:J while, by (6), ıpt1lq P RN\n:J , for some atomic relation RN P R and a tuple t1l s.t. tl “ t 1 lrτpRqs. By γrelpRNq and (3), pıpt1lq, ıptlqq P pPATHT pτpRN q, τpRqq :qJ and pıptlq, dq P pPATHT pτpRq, tUiuq:qJ . Since ı is injective, ıptlq ‰ ıptjq when l ‰ j, thus, d P pDěqrUisRq:J . Let t P pσUi:CRq I . Then, t P RI and trUis P CI and, by induction, ıptq P R:J and trUis P C:J . As before, by γrelpRNq and by (3) and (6), pıptq, trUisq P pPATHT pτpRq, tUiuq\n:qJ . Since PATHT pτpRq, Uiq: is functional, then we have that ıptq P pσUi:CRq\n:J . Let t P pDrU1, . . . , UksRqI . Then, there is a tuple t1 P RI s.t. t1rU1, . . . , Uks “ t and, by induction, ıpt1q P R:J . As before, by γrelpRNq and by (3) and (6), we can show that pıpt1q, ıptqq P PATHT pτpRq, tU1, . . . , Ukuq:J and thus ıptq P pDrU1, . . . , UksRq\n:J . All the other cases can be proved in a similar way. We now show the vice versa. Let d P p Ä\nRNq:J . Then, d P pAlRN q J and d “ lRN ptq, for some t P RN I , i.e., d P p Ä\nRNqI . Let d P pDěqrUisRq:J . Then, there are different d1, . . . , dq P ∆J s.t. pdl, dq P pPATHT pτpRq, tUiuq\n:qJ and dl P R:J , for l “ 1, . . . , q. By induction, each dl “ ıptlq and tl P RI . Since ı is injective, then tl ‰ tj for all l, j “ 1, . . . , q, l ‰ j. We need to show that tlrUis “ d, for all l “ 1, . . . , q. By (3) and the fact that pdl, dq P pPATHT pτpRq, tUiuq\n:qJ , then d “ ıptlrUisq “ tlrUis. Let ıptq P pσUi:CRq\n:J . Then, ıptq P R:J and, by induction, t P RI . Let trUis “ d. We need to show that d P CI . By γrelpRNq and by (3) and (6), pıptq, dq P pPATHT pτpRq, tUiuq\n:qJ , then d P C:J and, by induction, d P CI . Let ıptq P pDrU1, . . . , UksRq:J . Then, there is d P ∆J s.t.\npd, ıptqq P pPATHT pτpRq, tU1, . . . , Ukuq :qJ\nand d P RJ . By induction, d “ ıpt1q and t1 P RI . By (3), ıptq “ ıpt1rU1, . . . , Uksq, i.e., t “ t1rU1, . . . , Uks. Thus, t P pDrU1, . . . , UksRqI . (ð) Let J “ p∆J , ¨J q be a model for the knowledge base γpKBq. Without loss of generality, we can assume that J is a tree model. We then construct a model I “ p∆I , ¨I , ρ, ı, ℓRN1, . . .q for a DLR\n˘ knowledge base KB. We set: ∆I “ ∆J , CNI “ pCN :qJ , for every atomic concept CN P C, while, for every RN P R, we set:\nRNI “ tt “ xU1 : d1, . . . , Un : dny P T∆I pτpRNqq | Dd P A J RN s.t.\npd, trUisq P pPATHT pτpRNq, tUiuq :qJ for i “ 1, . . . , nu. (7)\nSince J satisfies γrelpRNq, then, for every d P A J RN there is a unique tuple xU1 : d1, . . . , Un : dny P RN I , we say that d generates xU1 : d1, . . . , Un : dny and, in\nsymbols, d Ñ xU1 : d1, . . . , Un : dny. Furthermore, since J is tree shaped, to each tuple corresponds a unique d that generates it. Thus, let d Ñ xU1 : d1, . . . , Un : dny, by setting ıpxU1 : d1, . . . , Un : dnyq “ d and\nıpxU1 : d1, . . . , Un : dnyrτisq “ dτi , s.t.\npd, dτiq P pPATHT ptU1, . . . , Unu, τiq :qJ , (8)\nfor all τi P TtU1,...,Unu, then, the function ı is as required. By setting\nℓRN pxU1 : d1, . . . , Un : dnyq “ d, s. t.\npıpxU1 : d1, . . . , Un : dnyq, dq P Q J RN , (9)\nby γlobjpRNq, both QRN and its inverse are interpreted as a functional roles by J , thus the function ℓRN is as required. It is easy to show by structural induction that the following property holds:\nIf t P RI then Dt1 P RNI s.t. t “ t1rτpRqs, for some RN P R. (10)\nWe now show that I is indeed a model of KB, i.e., I |ù C1 Ď C2 and I |ù R1 Ď R2. As before, since J |ù C : 1 Ď C : 2 and J |ù R: 1 Ď R : 2 , it is enough to show the following: – d P CI iff d P pC:qJ , for all DLR˘ concepts; – t P RI iff ıptq P pR:qJ , for all DLR˘ relations. The proof is by structural induction. The base cases are trivially true. Similarly for the boolean operators and global reification. We thus show only the following cases. Let d P p Ä\nRNqI . Then, d “ ℓRN ptq with t P RNI . By induction, ıptq P AJRN and, by γlobjpRNq, there is a d1 P ∆J s.t. pıptq, d1q P QJRN and d 1 P pAlRN q J . By (9), d “ d1 and thus, d P p Ä\nRNq:J . Let d P pDěqrUisRqI . Then, there are different t1, . . . , tq P RI s.t. tlrUis “ d, for all l “ 1, . . . , q. For each tl, by (10), there is a t1l P RN\nI s.t. tl “ t1lrτpRqs, for some RN P R, while, by induction, ıptlq P R:J and ıpt1lq P RN\n:J . Thus, t1lrUis “ tlrUis “ d and, by (7), pıpt 1 lq, dq P pPATHT pτpRNq, tUiuq\n:qJ while, by (8), pıpt1lq, ıptlqq P pPATHT pτpRNq, τpRqqq\n:J . Since DLR˘ allows only for knowledge bases with a projection signature graph being a multitree, then,\nPATHT pτpRNq, tUiuq : “ PATHT pτpRNq, τpRqq : ˝ PATHT pτpRq, tUiuq :.\nThus, pıptlq, dq P pPATHT pτpRq, tUiuq:qJ and, since ı is injective, then, ıptlq ‰ ıptjq when l ‰ j. Thus, d P pDěqrUisRq:J . Let t P pσUi:CRq\nI . Then, t P RI and trUis “ d P CI . By induction, ıptq P R:J and d P C:J . As before, by (7), (8) and (10), we can show that pıptq, dq P pPATHT pτpRq, tUiuq\n:qJ and, since PATHT pτpRq, tUiuq: is functional, then ıptq P pσUi:CRq\n:J . Let t P pDrU1, . . . , UksRqI . Then, there is a tuple t1 P RI s.t. t1rU1, . . . , Uks “ t\nand, by induction, ıpt1q P R:J . As before, by (8) and (10), we can show that pıpt1q, ıptqq P PATHT pτpRq, tU1, . . . , Ukuq\n:J and thus ıptq P pDrU1, . . . , UksRq:J . All the other cases can be proved in a similar way. We now show the vice versa.\nLet d P p Ä RNq:J . Then, d P pAlRN q J and, by γlobjpRNq, there is a d1 P ∆J s.t. pd1, dq P QJRN and d 1 P AJRN . By induction, d\n1 “ ıpt1q with t1 P RNI and thus, pıpt1q, dq P QJRN and, by (9), ℓRN pt 1q “ d, i.e., d P p Ä\nRNqI . Let d P pDěqrUisRq:J . Thus, there are different d1, . . . , dq P ∆J s.t. pdl, dq P pPATHT pτpRq, tUiuq\n:qJ and dl P R:J , for l “ 1, . . . , q. By induction, each dl “ ıptlq and tl P RI . Since ı is injective, then tl ‰ tj for all l, j “ 1, . . . , q, l ‰ j. We need to show that tlrUis “ d, for all l “ 1, . . . , q. By (10), there is a t1l P RN I s.t. tl “ t1lrτpRqs, for some RN P R and, by (8), pıpt 1 lq, ıptlqq P pPATHT pτpRNq, τpRqq :qJ . Since pıptlq, dq P pPATHT pτpRq, tUiuq:qJ and PATHT is functional in DLR˘, then, pıpt1lq, dq P pPATHT pτpRNq, tUiuq :qJ and, by (7), t1lrUis “ tlrUis “ d. Let ıptq P pσUi:CRq\n:J . Thus, ıptq P R:J and, by induction, t P RI . Let trUis “ d. We need to show that d P CI . As before, by (10) and (8), we have that pıptq, dq P pPATHT pτpRq, tUiuq\n:qJ . Then d P C:J and, by induction, d P CI . Let ıptq P pDrU1, . . . , UksRq:J . Then, there is d P ∆J s.t.\npd, ıptqq P pPATHT pτpRq, tU1, . . . , Ukuq :qJ\nand d P R:J . By induction, d “ ıpt1q and t1 P RI . As before, by (8) and (10), we can show that there is a tuple t2 P RN s.t. pıpt2q, ıptqq P pPATHT pτpRNq, tU1, . . . , Ukuq:qJ and thus, t “ t1rU1, . . . , Uks, i.e., t P pDrU1, . . . , UksRqI . [\\\nAs a direct consequence of the above theorem and the fact that DLR is a sublanguage of DLR˘, we have that\nCorollary 3. Reasoning in DLR˘ is an EXPTIME-complete problem."
    }, {
      "heading" : "6 Acknowledgements",
      "text" : "We thank Alessandro Mosca for working with us on all the preliminary work necessary to understand how to get these technical results."
    } ],
    "references" : [ {
      "title" : "Reasoning over extended ER models",
      "author" : [ "Artale et al", "2007. A. Artale", "D. Calvanese", "R. Kontchakov", "V. Ryzhikov", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 26th Int. Conf. on Conceptual Modeling (ER’07),",
      "citeRegEx" : "al. et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2007
    }, {
      "title" : "The Description Logic Handbook: Theory, Implementation and Applications",
      "author" : [ "Baader et al", "2003. Franz Baader", "Diego Calvanese", "Deborah McGuinness", "Daniele Nardi", "Peter F. Patel-Schneider", "editors" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2003
    }, {
      "title" : "Reasoning on UML class diagrams",
      "author" : [ "Berardi et al", "2005. D. Berardi", "D. Calvanese", "G. De Giacomo" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "al. et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2005
    }, {
      "title" : "On the decidability of query containment under constraints",
      "author" : [ "Calvanese et al", "1998. D. Calvanese", "G. De Giacomo", "M. Lenzerini" ],
      "venue" : "In Proc. of the 17th ACM Sym. on Principles of Database Systems",
      "citeRegEx" : "al. et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 1998
    }, {
      "title" : "Identification constraints and functional dependencies in description logics",
      "author" : [ "Calvanese et al", "2001. Diego Calvanese", "Giuseppe De Giacomo", "Maurizio Lenzerini" ],
      "venue" : "In Proceedings of the Seventeenth International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "al. et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2001
    }, {
      "title" : "The implication problem for functional and inclusion dependencies is undecidable",
      "author" : [ "Chandra", "Vardi", "1985. Ashok K. Chandra", "Moshe Y. Vardi" ],
      "venue" : "SIAM Journal on Compututing,",
      "citeRegEx" : "Chandra et al\\.,? \\Q1985\\E",
      "shortCiteRegEx" : "Chandra et al\\.",
      "year" : 1985
    }, {
      "title" : "Towards a core ORM2 language (research note)",
      "author" : [ "Franconi", "Mosca", "2013. Enrico Franconi", "Alessandro Mosca" ],
      "venue" : "In OTM Workshops,",
      "citeRegEx" : "Franconi et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Franconi et al\\.",
      "year" : 2013
    }, {
      "title" : "The implication problem for functional and inclusion dependencies",
      "author" : [ "Mitchell", "1983. John C. Mitchell" ],
      "venue" : "Information and Control,",
      "citeRegEx" : "Mitchell and Mitchell.,? \\Q1983\\E",
      "shortCiteRegEx" : "Mitchell and Mitchell.",
      "year" : 1983
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "We introduce an extension of the n-ary description logic DLR to deal with attribute-labelled tuples (generalising the positional notation), with arbitrary projections of relations (inclusion dependencies), generic functional dependencies and with global and local objectification (reifying relations or their projections). We show how a simple syntactic condition on the appearance of projections and functional dependencies in a knowledge base makes the language decidable without increasing the computational complexity of the basic DLR language.",
    "creator" : "LaTeX with hyperref package"
  }
}