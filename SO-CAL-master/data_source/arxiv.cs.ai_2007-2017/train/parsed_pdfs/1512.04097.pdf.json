{
  "name" : "1512.04097.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Using Linear Constraints for Logic Program Termination Analysis",
    "authors" : [ "MARCO CALAUTTI", "SERGIO GRECO", "CRISTIAN MOLINARO", "IRINA TRUBITSYNA" ],
    "emails" : [ "calautti@dimes.unical.it", "greco@dimes.unical.it", "cmolinaro@dimes.unical.it", "trubitsyna@dimes.unical.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "KEYWORDS: Answer set programming, function symbols, bottom-up evaluation, program evaluation termination, stable models"
    }, {
      "heading" : "1 Introduction",
      "text" : "Enriching answer set programming with function symbols has recently seen a surge\nin interest. Function symbols make modeling easier, increase the expressive power,\nand allow us to deal with infinite domains. At the same time, this comes at a cost:\ncommon inference tasks (e.g., cautious and brave reasoning) become undecidable.\nRecent research has focused on identifying classes of logic programs that im-\npose some limitations on the use of function symbols but guarantee decidability\nof common inference tasks. Efforts in this direction are the class of finitely-ground\nprograms (Calimeri et al. 2008) and the more general class of bounded term-size\nprograms (Riguzzi and Swift 2013). Finitely-ground programs have a finite number\nof stable models, each of finite size, whereas bounded term-size (normal) programs\nhave a finite well-founded model. Unfortunately, checking if a logic program is\nbounded term-size or even finitely-ground is semi-decidable.\nar X\niv :1\n51 2.\n04 09\n7v 2\n[ cs\n.A I]\nConsidering the stable model semantics, decidable subclasses of finitely-ground\nprograms have been proposed. These include the classes of ω-restricted programs (Syr-\njanen 2001), λ-restricted programs (Gebser et al. 2007), finite domain programs (Cal-\nimeri et al. 2008), argument-restricted programs (Lierler and Lifschitz 2009), safe\nand Γ-acyclic programs (Greco et al. 2012; Calautti et al. 2014), mapping-restricted\nprograms (Calautti et al. 2013), and bounded programs (Greco et al. 2013a). The\nabove techniques, that we call termination criteria, provide (decidable) sufficient\nconditions for a program to be finitely-ground.\nDespite the significant body of work in this area, there are still many simple\npractical programs whose evaluation terminates but this is not detected by any of\nthe current termination criteria. Below is an example.\nExample 1\nConsider the following program P1 implementing the bubble sort algorithm:\nr0 : bub(L, [ ], [ ])← input(L). r1 : bub([Y|T], [X|Cur], Sol)← bub([X|[Y|T]], Cur, Sol), X ≤ Y. r2 : bub([X|T], [Y|Cur], Sol)← bub([X|[Y|T]], Cur, Sol), Y < X. r3 : bub(Cur, [ ], [X|Sol])← bub([X|[ ]], Cur, Sol).\nThe list to be sorted is given by means of a fact of the form input([a1, ..., an]). The bottom-up evaluation of this program always terminates for any input list. The\nordered list Sol can be obtained from the atom bub([ ], [ ], Sol) in the program’s\nminimal model. 2\nAlthough the bottom-up evaluation of P1 always terminates for any input list, none of the termination criteria in the literature is able to realize it. One problem\nwith them is that when they analyze how terms are propagated from the body to\nthe head of rules, they look at arguments individually. For instance, in rule r1 above, the simple fact that the second argument of bub has a size in the head greater than\nthe one in the body prevents several techniques from realizing termination of the bottom-up evaluation of P1. More general classes such as mapping-restricted and bounded programs are able to do a more complex (yet limited) analysis of how\nsome groups of arguments affect each other. Still, all current termination criteria are not able to realize that in every rule of P1 the overall size of the terms in the head does not increase w.r.t. the overall size of the terms in the body. One of the\nnovelties of the technique proposed in this paper is the capability of doing this kind\nof analysis, thereby identifying programs (whose evaluation terminates) that none\nof the current techniques include.\nThe technique proposed in this paper easily realizes that the bottom-up evaluation of P1 always terminates for any input list. In particular, this is done using linear constraints which measure the size of terms and atoms in order to check if\nthe rules’ head sizes are bounded by the size of some body atom when propagation\noccurs. Thus, our technique can understand that, in every rule, the overall size\nof the terms in the body does not increase during their propagation to the head,\nas there is only a simple redistribution of terms. Many practical programs dealing\nwith lists and tree-like structures satisfy this property—below are two examples.\nHowever, our technique is not limited only to this kind of programs.\nExample 2 Consider the program P2 below, performing a depth-first traversal of an input tree:\nr0 : visit(Tree, [ ], [ ])← input(Tree). r1 : visit(Left, [Root|Visited], [Right|ToVisit])←\nvisit(tree(Root, Left, Right), Visited, ToVisit).\nr2 : visit(Next, Visited, ToVisit)← visit(null, Visited, [Next|ToVisit]).\nThe input tree is given by means of a fact of the form input(tree(value, left, right))\nwhere tree is a ternary function symbol used to represent tree structures. The\nprogram visits the nodes of the tree and puts them in a list following a depth-first\nsearch. The list L of visited elements can be obtained from the atom visit(null, L, [ ])\nin the program’s minimal model. For instance, if the input tree is\ninput(tree(a, tree(c, null, tree(d, null, null)), tree(b, null, null))).\nthe program produces the list [b, d, c, a] containing the nodes of the tree in opposite\norder w.r.t. the traversal. 2\nAlso in the case above, even if the program evaluation terminates for every input\ntree, none of the currently known techniques is able to detect it, while the technique\nproposed in this paper does.\nExample 3 Consider the following program P3 computing the concatenation of two lists:\nr0 : reverse(L1, [ ]) ← input1(L1). r1 : reverse(L1, [X|L2]) ← reverse([X|L1], L2). r2 : append(L1, L2) ← reverse([ ], L1), input2(L2). r3 : append(L1, [X|L2]) ← append([X|L1], L2).\nHere input1 and input2 are used to store the lists L1 and L2 to be concatenated. The result list L can be retrieved from the atom append([ ], L) in the minimal model of P3. Clearly, the bottom-up evaluation of the program always terminates. 2\nWe point out that the problem of detecting decidable classes of programs is rel-\nevant not only from a theoretical point of view, as real applications make use of\nstructured data and functions symbols (e.g., lists, sets, bags, arithmetic). Classical\napplications need the use of structured data such as bill of materials consisting\nin the description of all items that compose a product, down to the lowest level\nof detail (Ceri et al. 1990), management of strings in bioinformatics applications,\nmanaging and querying ontological data using logic languages (Cali et al. 2010;\nChaudhri et al. 2013), as well as applications based on greedy and dynamic pro-\ngramming algorithms (Greco et al. 1992; Greco 1999).\nContribution. We propose novel techniques for checking if the evaluation of a\nlogic program terminates (clearly, we define sufficient conditions). Our techniques\novercome several limitations of current approaches being able to perform a more\nglobal analysis of how terms are propagated from the body to the head of rules.\nTo this end, we use linear constraints to measure and relate the size of head and\nbody atoms. We first introduce the class of rule-bounded programs, which looks\nat individual rules, and then propose the class of cycle-bounded programs, which\nrelies on the analysis of groups of rules. We show the correctness of the proposed\ntechniques and provide upper bounds on their complexity. We also study the rela-\ntionship between the proposed classes and current termination criteria.\nOrganization. Section 2 reports preliminaries on logic programs with function\nsymbols. Sections 3 introduces the class of rule-bounded programs, whereas Sec-\ntion 4 presents several theoretical results on its correctness and expressivity. Sec-\ntion 5 introduces the class of cycle-bounded programs along with results on its\ncorrectness and expressivity. The complexity analysis is addressed in Section 6.\nRelated work and conclusions are reported in Sections 7 and 8, respectively."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "This section recalls syntax and the stable model semantics of logic programs with\nfunction symbols (Gelfond and Lifschitz 1988; Gebser et al. 2012).\nSyntax. We assume to have (pairwise disjoint) infinite sets of logical variables,\npredicate symbols, and function symbols. Each predicate and function symbol g is\nassociated with an arity, denoted arity(g), which is a non-negative integer. Function\nsymbols of arity 0 are called constants. Variables appearing in logic programs are\ncalled “logical variables” and will be denoted by upper-case letters in order to\ndistinguish them from variables appearing in linear constraints, which are called\n“integer variables” and will be denoted by lower-case letters. A term is either a\nlogical variable, or an expression of the form f(t1, ..., tm), where f is a function symbol of arity m ≥ 0 and t1, ..., tm are terms. An atom is of the form p(t1, ..., tn), where p is a predicate symbol of arity n ≥ 0 and t1, ..., tn are terms. A literal is an atom A (positive literal) or its negation ¬A (negative literal).\nA rule r is of the form A1 ∨ ... ∨ Am ← B1, ..., Bk,¬C1, ...,¬Cn, where m > 0, k ≥ 0, n ≥ 0, and A1, ..., Am, B1, ..., Bk, C1, ..., Cn are atoms. The disjunction A1 ∨ ... ∨ Am is called the head of r and is denoted by head(r). The conjunction B1, ..., Bk,¬C1, ...,¬Cn is called the body of r and is denoted by body(r). With a slight abuse of notation, we sometimes use body(r) (resp. head(r)) to also denote\nthe set of literals appearing in the body (resp. head) of r. If m = 1, then r is\nnormal; in this case, head(r) denotes the head atom. If n = 0, then r is positive.\nA program is a finite set of rules. A program is normal (resp. positive) if every rule\nin it is normal (resp. positive). We assume that programs are range restricted, i.e.,\nfor every rule, every logical variable appears in some positive body literal. W.l.o.g.,\nwe also assume that different rules do not share logical variables.\nA term (resp. atom, literal, rule, program) is ground if no logical variables occur\nin it. A ground normal rule with an empty body is also called a fact. A predicate\nsymbol p is defined by a rule r if p appears in the head of r.\nA substitution θ is of the form {X1/t1, ..., Xn/tn}, where X1, ..., Xn are distinct logical variables and t1, ..., tn are terms. The result of applying θ to an atom (or term) A, denoted Aθ, is the atom (or term) obtained from A by simultaneously\nreplacing each occurrence of a logical variable Xi in A with ti if Xi/ti belongs to θ. Two atoms A1 and A2 unify if there exists a substitution θ, called a unifier of A1 and A2, such that A1θ = A2θ. The composition of two substitutions θ = {X1/t1, ..., Xn/tn} and ϑ = {Y1/u1, ..., Ym/um}, denoted θ ◦ ϑ, is the substitution obtained from the set {X1/t1ϑ, ...,Xn/tnϑ, Y1/u1, ..., Ym/um} by removing every Xi/tiϑ such that Xi = tiϑ and every Yj/uj such that Yj ∈ {X1, ..., Xn}. A substitution θ is more general than a substitution ϑ if there exists a substitution η such that ϑ = θ ◦ η. A unifier θ of A1 and A2 is called a most general unifier (mgu) of A1 and A2 if it is more general than any other unifier of A1 and A2 (indeed, the mgu is unique modulo renaming of logical variables).\nSemantics. Consider a program P. The Herbrand universe HP of P is the possibly infinite set of ground terms constructible using function symbols (and thus, also constants) appearing in P. The Herbrand base BP of P is the set of ground atoms constructible using predicate symbols appearing in P and ground terms of HP .\nA rule (resp. atom) r′ is a ground instance of a rule (resp. atom) r in P if r′ can be obtained from r by substituting every logical variable in r with some ground\nterm in HP . We use ground(r) to denote the set of all ground instances of r and define ground(P) to denote the set of all ground instances of the rules in P, i.e., ground(P) = ∪r∈Pground(r).\nAn interpretation of P is any subset I of BP . The truth value of a ground atom A w.r.t. I, denoted valueI(A), is true if A ∈ I, false otherwise. The truth value of ¬A w.r.t. I, denoted valueI(¬A), is true if A 6∈ I, false otherwise. A ground rule r is satisfied by I, denoted I |= r, if there is a ground literal L in body(r) s.t. valueI(L) = false or there is a ground atom A in head(r) s.t. valueI(A) = true. Thus, if the body of r is empty, r is satisfied by I if there is an atom A in head(r) s.t. valueI(A) = true. An interpretation of P is a model of P if it satisfies every ground rule in ground(P). A model M of P is minimal if no proper subset of M is a model of P. The set of minimal models of P is denoted by MM(P).\nGiven an interpretation I of P, let PI denote the ground positive program derived from ground(P) by (i) removing every rule containing a negative literal ¬A in the body with A ∈ I, and (ii) removing all negative literals from the remaining rules. An interpretation I is a stable model of P if I ∈MM(PI). The set of stable models of P is denoted by SM(P). It is well known that stable models are minimal models (i.e., SM(P) ⊆MM(P)), and SM(P) =MM(P) for positive programs.\nA positive normal program P has a unique minimal model, which, with a slight abuse of notation, we denote as MM(P). The immediate consequence operator of P is a function TP : 2BP → 2BP defined as follows: for every interpretation I, TP(I) = {A | A ← B1, ..., Bn ∈ ground(P) and {B1, ..., Bn} ⊆ I}. The i-th iteration of TP (i ≥ 1) w.r.t. an interpretation I is defined as follows: T 1P(I) =\nTP(I) and T i P(I) = TP(T i−1 P (I)) for i > 1. The minimal model of P coincides with T∞P (∅). Finite programs. A program P is said to be finite under stable model semantics if, for every finite set of facts D, the program P∪D admits a finite number of stable models and each is of finite size, that is, |SM(P ∪ D)| is finite and every stable model M ∈ SM(P ∪D) is finite.\nEquivalently, a positive normal program P is finite if for every finite set of facts D, there is a finite natural number n such that TnP∪D(∅) = T∞P∪D(∅). We call such programs terminating. In this paper we study new conditions under which a positive normal program P is terminating. It is worth mentioning that such conditions can be easily extended to general programs. This will be shown in the next section."
    }, {
      "heading" : "3 Rule-bounded Programs",
      "text" : "In this section, we present rule-bounded programs, a class of programs whose evalua-\ntion always terminates and for which checking membership in the class is decidable.\nTheir definition relies on a novel technique which uses linear inequalities to mea-\nsure terms and atoms’ sizes and checks if the size of the head of a rule is always\nbounded by the size of a mutually recursive body atom (we will formally define\nwhat “mutually recursive” means in Definition 2 below).\nFor ease of presentation, we restrict our attention to positive normal programs. However, our technique can be applied to an arbitrary program P with disjunction in the head and negation in the body by considering a positive normal program st(P) derived from P as follows. Every rule A1 ∨ ... ∨ Am ← body in P is replaced with m positive normal rules of the form Ai ← body+ (1 ≤ i ≤ m) where body+ is obtained from body by deleting all negative literals. In fact, the minimal model of st(P) contains every stable model of P (Greco et al. 2012)—whence, the termination of st(P), which implies finiteness and computability of the minimal model will also imply that P has a finite number of stable models, each of finite size, which can be computed. In the rest of the paper, a program is understood to be positive and\nnormal. We start by introducing some preliminary notions.\nDefinition 1 (Firing graph) The firing graph of a program P, denoted Ω(P), is a directed graph whose nodes are the rules in P and such that there is an edge 〈r, r′〉 if there exist two (not necessarily distinct) rules r, r′ ∈ P s.t. head(r) and an atom in body(r′) unify. 2\nIntuitively, an edge 〈r, r′〉 of Ω(P) means that rule r may cause rule r′ to “fire”. The firing graph of program P1 of Example 1 is depicted in Figure 1. In the definition above, when r = r′ we assume that r and r′ are two “copies” that do not share any\nlogical variable.\nWe say that a rule r depends on a rule r′ if r can be reached from r′ through the edges of Ω(P). A strongly connected component (SCC) of a directed graph G is a maximal set C of nodes of G s.t. every node of C can be reached from every node of C (through the edges in G). We say that an SCC C is non-trivial if there exists at least one edge in G between two not necessarily distinct nodes of C. For instance,\nthe firing graph in Figure 1 has two SCCs, C1 = {r0} and C2 = {r1, r2, r3}, but only C2 is non-trivial. Given a program P and an SCC C of Ω(P), pred(C) denotes the set of predicate symbols defined by the rules in C. We now define when the head atom and a body atom of a rule are mutually recursive.\nDefinition 2 (Mutually recursive atoms) Let P be a program and r a rule in P. The head atom A = head(r) and an atom B ∈ body(r) are mutually recursive if there is an SCC C of Ω(P) s.t.:\n1. C contains r, and 2. C contains a rule r′ (possibly equal to r) s.t. head(r′) and B unify. 2\nIn the previous definition, when r = r′ we assume that r and r′ are two “copies”\nthat do not share any logical variable. Intuitively, the head atom A of a rule r\nand an atom B in the body of r are mutually recursive when there might be an\nactual propagation of terms from A to B (through the application of a sequence\nof rules). As a very simple example, if we have an SCC consisting only of the rule p(f(X)) ← p(X), p(g(X)), the first body atom is mutually recursive with the head, while the second one is not as it does not unify with the head atom.\nGiven a rule r, we use rbody(r) to denote the set of atoms in body(r) which are\nmutually recursive with head(r). Moreover, we define sbody(r) as the set consisting\nof every atom in body(r) that contains all logical variables appearing in head(r), and define srbody(r) = rbody(r) ∩ sbody(r). We say that a rule r in a program P is relevant if it is not a fact and the set of atoms body(r) \\ rbody(r) does not contain all logical variables in head(r). Roughly speaking, a non-relevant rule will be ignored because either it cannot propagate\nterms or its head size is bounded by body atoms which are not mutually recursive\nwith the head. We illustrate the notions introduced so far in the following example.\nExample 4 Consider the following program P4:\nr1 : s(f(X), Y)︸ ︷︷ ︸ A ← q(X, f(Y))︸ ︷︷ ︸ B , s(Z, f(Y))︸ ︷︷ ︸ C . r2 : q(f(U), V)︸ ︷︷ ︸ D ← s(U, f(V))︸ ︷︷ ︸ E .\nThe firing graph consists of the edges 〈r1, r1〉, 〈r1, r2〉, 〈r2, r1〉. Thus, there is only one SCC C = {r1, r2}, which is non-trivial, and pred(C) = {q, s}. Atoms A and B (resp. A and C, D and E) are mutually recursive. Moreover, rbody(r1) = {B,C}, srbody(r1) = {B}, rbody(r2) = srbody(r2) = {E}. Both r1 and r2 are relevant. 2\nWe use N to denote the set of natural numbers {1, 2, 3, ...} and N0 to denote the set of natural numbers including the zero. Moreover, Nk = {(v1, ..., vk) | vi ∈ N for 1 ≤ i ≤ k} and Nk0 = {(v1, ..., vk) | vi ∈ N0 for 1 ≤ i ≤ k}. Given a k-vector v = (v1, ..., vk) in Nk0 , we use v[i] to refer to vi, for 1 ≤ i ≤ k. Given two k-vectors v = (v1, ..., vk) and w = (w1, ..., wk) in Nk0 , we use v ·w to denote the classical scalar product, i.e., v · w = ∑k i=1 vi · wi.\nAs mentioned earlier, the basic idea of the proposed technique is to measure the\nsize of terms and atoms in order to check if the rules’ head sizes are bounded when\npropagation occurs. Thus, we introduce the notions of term and atom size.\nDefinition 3 Let t be a term. The size of t is recursively defined as follows:\nsize(t) = x if t is a logical variable X;m+ m∑ i=1 size(ti) if t = f(t1, ..., tm).\nwhere x is an integer variable. The size of an atom A = p(t1, ..., pn), denoted size(A), is the n-vector (size(t1), ..., size(tn)). 2\nIn the definition above, an integer variable x intuitively represents the possible\nsizes that the logical variable X can have during the bottom-up evaluation. The\nsize of a term of the form f(t1, ..., tm) is defined by summing up the size of its terms ti’s plus the arity m of f . Note that from the definition above, the size of every constant is 0.\nExample 5 Consider rule r1 of program P1 (see Example 1). Using lc to denote the list constructor operator “|”, the rule can be rewritten as follows:\nbub(lc(Y, T), lc(X, Cur), Sol)← bub(lc(X, lc(Y, T)), Cur, Sol), X ≤ Y.\nLet A (resp. B) be the atom in the head (resp. the first atom in the body). Then,\nsize(A) = (2 + y + t, 2 + x+ cur, sol)\nsize(B) = (2 + [x+ (2 + y + t)], cur, sol) 2\nWe are now ready to define rule-bounded programs.\nDefinition 4 (Rule-bounded programs) Let P be a program, C a non-trivial SCC of Ω(P), and pred(C) = {p1, ..., pk}. We say that C is rule-bounded if there exist k vectors αph ∈ Narity(ph), 1 ≤ h ≤ k, such that for every relevant rule r ∈ C with A = head(r) = pi(t1, ..., tn), there exists an atom B = pj(u1, ..., um) in srbody(r) s.t. the following inequality is satisfied\nαpj · size(B)− αpi · size(A) ≥ 0\nfor every non-negative value of the integer variables in size(B) and size(A).\nWe say that P is rule-bounded if every non-trivial SCC of Ω(P) is rule-bounded. 2\nIntuitively, for every relevant rule of a non-trivial SCC of Ω(P), Definition 4 checks if the size of the head atom is bounded by the size of a mutually recursive\nbody atom for all possible sizes the terms can assume.\nExample 6 Consider again program P4 of Example 4. Recall that the only non-trivial SCC of Ω(P4) is C = {r1, r2}, and both r1 and r2 are relevant. To determine if the program is rule-bounded we need to check if C is rule-bounded. Thus, we need to find αq, αs ∈ N2 such that there is an atom in srbody(r1) and an atom in srbody(r2) which satisfy the two inequalities derived from r1 and r2 for all non-negative values of the integer variables therein. Since both srbody(r1) and srbody(r2) contain only one element, we have only one choice, namely the one where B is selected for r1 and E is selected for r2. Thus, we need to check if there exist αq, αs ∈ N2 s.t. the following linear constraints are satisfied for all non-negative values of the integer variables appearing in them:{\nαq · size(B)− αs · size(A) ≥ 0 αs · size(E)− αq · size(D) ≥ 0 ⇒ { αq · (x, 1 + y)− αs · (1 + x, y) ≥ 0 αs · (u, 1 + v)− αq · (1 + u, v) ≥ 0\nBy expanding the scalar products and isolating every integer variable we obtain:{ (αq[1]− αs[1]) · x+ (αq[2]− αs[2]) · y + (αq[2]− αs[1]) ≥ 0 (αs[1]− αq[1]) · u+ (αs[2]− αq[2]) · v + (αs[2]− αq[1]) ≥ 0\nThe previous inequalities must hold for all x, y, u, v ∈ N0; it is easy to see that this is the case iff the following system admits a solution:{\nαq[1]− αs[1] ≥ 0, αq[2]− αs[2] ≥ 0, αq[2]− αs[1] ≥ 0, αs[1]− αq[1] ≥ 0, αs[2]− αq[2] ≥ 0, αs[2]− αq[1] ≥ 0\nSince a solution does exist, e.g. αs[1] = αs[2] = αq[1] = αq[2] = 1 (recall that every α[i] must be greater than 0), the SCC C is rule-bounded, and so is the program. 2\nThe method in the previous example to find vectors αp for all p ∈ pred(C) can always be applied. That is, we can always isolate the integer variables in the original\ninequalities and then derive one inequality for each expression that multiplies an in-\nteger variable plus the one for the constant term, imposing that all such expressions\nmust be greater than or equal to 0—we precisely state this property in Lemma 5.\nIt is worth noting that the proposed technique can easily recognize many termi-\nnating practical programs where terms are simply exchanged from the body to the\nhead of rules (e.g., see Examples 1, 2, and 3).\nExample 7 Consider program P1 of Example 1. Recall that the only non-trivial SCC of Ω(P1) is {r1, r2, r3} (see Figure 1) and all rules in it are relevant. Since |srbody(ri)| = 1 for every ri in the SCC, we have only one set of inequalities, which is the following one after isolating integer variables(we assume that the empty list is represented by a simple constant): (αb[1]− αb[2]) · x1 + (2αb[1]− 2αb[2]) ≥ 0 (αb[1]− αb[2]) · y2 + (2αb[1]− 2αb[2]) ≥ 0 (αb[1]− αb[3]) · x3 + (αb[2]− αb[1]) · cur3 + (2αb[1]− 2αb[3]) ≥ 0\nwhere subscript b stands for predicate symbol bub, whereas subscripts associated\nwith integer variables are used to refer to the occurrences of logical variables in\ndifferent rules (e.g., y2 is the integer variable associated to the logical variable Y in rule r2). A possible solution is αb = (1, 1, 1) and thus P1 is rule-bounded. Considering program P2 of Example 2, we obtain the following constraints:{ (αv[1]− αv[2]) · root1 + (αv[1]− αv[3]) · right1 + (3αv[1]− 2αv[2]− 2αv[3]) ≥ 0 (αv[3]− αv[1]) · next2 + 2αv[3] ≥ 0\nwhere subscript v stands for predicate symbol visit. By setting αv = (2, 1, 2), we get positive integer values of αv[1], αv[2], αv[3] s.t. the inequalities above are satisfied for all root1, right1, next2 ∈ N0. Thus, P2 is rule-bounded. The firing graph of program P3 of Example 3 has two non-trivial SCCs C1 = {r1} and C2 = {r3}. The constraints for C1 are:{ (αr[1]− αr[2]) · x1 + (2αr[1]− 2αr[2]) ≥ 0\nwhere subscript r stands for predicate symbol reverse. It is easy to see that by choosing any (positive integer) values of αr[1] and αr[2] such that αr[1] ≥ αr[2], the inequality above holds for all x1 ∈ N0. Likewise, the constraints for C2 are{\n(αa[1]− αa[2]) · x3 + (2αa[1]− 2αa[2]) ≥ 0\nwhere subscript a stands for predicate symbol append. By choosing any (positive integer) values of αa[1] and αa[2] such that αa[1] ≥ αa[2], the inequality above holds for all x3 ∈ N0. Thus, P3 is rule-bounded. 2"
    }, {
      "heading" : "4 Correctness and expressiveness",
      "text" : "In this section, we show that every rule-bounded program is terminating and provide\nresults on the relative expressiveness of rule-bounded programs and other criteria.\nNote that every program P can be partitioned into an ordered sequence of subprograms P1, ...,Pn, called stratification, such that, for every 1 ≤ i ≤ n, every rule r in Pi depends only on rules belonging to some sub-program Pj with 1 ≤ j ≤ i. Recall that a rule r depends on a rule r′ if r can be reached from r′ through the\nedges of the firing graph. Moreover, there always exists a stratification where every sub-program Pi is either a non-trivial SCC or a set of trivial SCCs. Given a set of facts D, it is well known thatMM(P ∪D) can be defined in terms of the minimal model of the Pi’s following the order of the partition as follows: if M0 = D and Mi =MM(Pi ∪Mi−1) for 1 ≤ i ≤ n, then Mn =MM(P ∪D).\nLemma 1 A program P is terminating iff every non-trivial SCC of Ω(P) is terminating."
    }, {
      "heading" : "Proof",
      "text" : "(⇒) Clearly, if there is an SCC which is not terminating, then P is not terminating. (⇐) Assume now that P does not terminate and all its non-trivial SCCs terminates. This means that there is a set of facts D such that the fixpoint of P∪D is not finite.\nSince P ∪ D can be partitioned into (P1, ...,Pn), there must be a non-trivial (i.e. recursive) SCC Pi such that Pi ∪Mi−1 does not terminate. This contradicts the hypothesis that all non-trivial SCCs terminate. Indeed if Pi terminates, then for every set of facts D′ including the facts in Mi−1, the fixpoint of Pi ∪D′ terminates and, therefore, the fixpoint of Pi ∪Mi−1 terminates as well.\nWe now refine the previous lemma by showing that to see if a program P is terminating it is not necessary to analyze every non-trivial SCC entirely, but we can focus on its relevant rules. Henceforth, for every set of rules C, we use Rel(C) to denote the set of relevant rules of C.\nLemma 2 Let P be a program and let C be an SCC of Ω(P). Then, C is terminating iff Rel(C) is terminating."
    }, {
      "heading" : "Proof",
      "text" : "It follows from the fact that we can derive only a finite number of ground atoms using the rules in ground(C) \\ ground(Rel(C)) starting from a finite set of facts— recall that, by definition, every non-relevant rule has a set of atoms in the body that\nare not mutually recursive with the head and contain all variables in the head.\nTo show the correctness of our approach, we first show that every rule-bounded\nprogram can be rewritten into an “equivalent” program belonging to a simpler class\nof programs, called size-bounded. Then, we prove that size-bounded programs are\nterminating and this entails that rule-bounded programs are terminating as well.\nDefinition 5 (Program expansion) Let P be a program and let ω = {ωp1 , ..., ωpn} be a set of vectors such that ωpi ∈ Narity(pi) and pi ∈ pred(P) for 1 ≤ i ≤ n. For any atom A = p(t1, ..., tm) occurring in P, we define Aω = A, if p 6∈ pred(P), otherwise Aω = p(t1, ..., tm), where each tj is the sequence tj , ..., tj of length ωp[j]. Finally, Pω denotes the program derived from P by replacing every atom A with Aω. 2\nIntuitively, the expansion of a program is obtained from the original program by\nincreasing the arity of each predicate symbol according to ω. Below is an example.\nExample 8 Consider program P4 of Example 4 and the set of vectors ω = {ωs, ωq} where ωs = (2, 3) and ωq = (2, 1). The program P ω 4 is as follows:\nr1 : s(f(X), f(X), Y, Y, Y) ← q(X, X, f(Y)), s(Z, Z, f(Y), f(Y), f(Y)). r2 : q(f(U), f(U), V) ← s(U, U, f(V), f(V), f(V)). 2\nWe now show that for every program P and every set of vectors ω, P is terminating iff Pω is terminating. In the following, for every program P, we define ω(P) = { {ωp1 , ..., ωpn} | pi ∈ pred(P) ∧ ωpi ∈ Narity(pi)}.\nLemma 3 For every program P and every ω ∈ ω(P), P is terminating iff Pω is terminating."
    }, {
      "heading" : "Proof",
      "text" : "For every atom Aω occurring in Pω let A be the corresponding atom in P. The claim follows from the observation that whenever there is a instance D such that T∞P∪D(∅) is infinite, it is always possible to construct the instance Dω which guarantees that T∞Pω∪Dω (∅) is infinite as well. Conversely, for every instance Dω of Pω, if T∞Pω∪Dω (∅) is infinite, then we can always construct the instance D guaranteeing that T∞P∪D(∅) is infinite as well.\nWe now introduce the class of size-bounded programs and show that such pro-\ngrams are terminating. To this aim, we define the total size of an atom A = p(t1, ..., tn) as tsize(A) = n∑ i=1 size(ti).\nDefinition 6 (Size-bounded program) A program P is said to be size-bounded if for every rule r ∈ P which is not a fact, there is an atom B in sbody(r) such that tsize(B) ≥ tsize(head(r)) for every non-negative value of the integer variables occurring in tsize(B) and tsize(head(r)).\nTheorem 1\nEvery size-bounded program is terminating."
    }, {
      "heading" : "Proof",
      "text" : "Let P be a size-bounded program and D a finite set of facts, we consider only rules in P having a non-empty body. Given an atom A and a ground instance A′ of A, let θ be the mgu of A and A′. Notice that θ is of the form {X1/t1, ..., Xn/tn} where the Xi’s are exactly the logical variables occurring in A and all the tj ’s are ground terms. It can be easily verified that tsize(A′) can be obtained from tsize(A) by\nreplacing every integer variable xi in tsize(A) with size(ti).\nWe now show that for every ground rule r′ ∈ ground(P) there is an atom B′ ∈ body(r′) such that tsize(B′) ≥ tsize(head(r′)). Consider a rule r in P of the form A← B1, ..., Bk and a ground rule r′ ∈ ground(r) of the form A′ ← B′1, ..., B′k. Since P is size-bounded, there exists an atom Bj in sbody(r) such that tsize(Bj) ≥ tsize(A) for every non-negative value of the integer variables occurring in the in-\nequality. Notice every logical variable in A appears also in Bj by definition of sbody. Let {X1/t1, ..., Xn/tn} be the mgu of Bj and B′j . As tsize(Bj) ≥ tsize(A) holds for all non-negative value of its integer variables, it also holds when every integer variable xi is replaced with size(ti), for 1 ≤ i ≤ n. Thus, tsize(B′j) ≥ tsize(A′). Let us denote T iP∪D(∅) as Mi for every i ≥ 1 and let tsizemax = max{tsize(B) | B ← is a fact in P ∪D}. We show that for every i ≥ 1 and every ground atom A in Mi the following holds tsizemax ≥ tsize(A). The proof is by induction on i. • Base case (i=1). It follows from the fact that M1={B | B← is a fact in P ∪ D}. • Inductive step (i → i + 1). Let r′ be a ground rule in ground(P) such that body(r′) ⊆ Mi. Then, as shown above, there is an atom B in body(r′) such that tsize(B) ≥ tsize(head(r′)). By the induction hypothesis, tsizemax ≥ tsize(B) and thus tsizemax ≥ tsize(head(r′)).\nThus, for every i ≥ 1 and every ground atom A in Mi, we have that tsize(A)\nis bounded by tsizemax. Since programs are range-restricted, atoms in ∪i≥1Mi are built from constants and function symbols appearing in P ∪D, which are finitely many. These observations and the definition of tsize imply that we can have only finitely many ground atoms in ∪i≥1Mi. Hence, P is terminating. We are now ready to show the correctness of the rule-bounded technique.\nTheorem 2 Every rule-bounded program is terminating."
    }, {
      "heading" : "Proof",
      "text" : "Let P be a rule-bounded program and C a non-trivial SCC of Ω(P). Since P is rule-bounded, then there exists ω ∈ ω(C) which satisfies the condition of Definition 4, that is, C is rule-bounded. This implies that Rel(C)ω is size-bounded. Thus, Rel(C)ω is terminating by Theorem 1. Lemma 3 implies that Rel(C) is terminating and Lemma 2 in turn implies that C is terminating. Finally, by Lemma 1, we can conclude that P is terminating.\nThe class of rule-bounded programs is incomparable with different termination\ncriteria in the literature, including the most general ones.\nTheorem 3 Rule-bounded programs are incomparable with argument-restricted, mapping-re-\nstricted, and bounded programs."
    }, {
      "heading" : "Proof",
      "text" : "Recall that both bounded and mapping-restricted programs include argument-\nrestricted programs. To prove the claim we show that (i) there is a program which\nis rule-bounded but is neither mapping-restricted nor bounded, and (ii) there is a\nprogram which is argument-restricted but not rule-bounded. (i) As already shown, program P1 of Example 1 is rule-bounded; however, it can be easily verified that P1 is neither mapping-restricted nor bounded. (ii) Consider the program consisting of the rules p(f(X))← q(X) and q(Y)← p(f(Y)). This program is argument-restricted (and thus also mapping-restricted and bounded) but is not rule-bounded.\nRegarding the termination criteria mentioned in Theorem 3, we recall that map-\nping restriction (MR) and bounded programs (BP ) are incomparable and both\nextend argument restriction (AR). Concerning the computational complexity, while\nAR is polynomial time, both MR and BP are exponential. As a remark, it is inte-\nresting to note that the above result highlights the fact that our technique analyzes\nlogic programs from a radically different point of view w.r.t. previously defined\napproaches, which analyze how complex terms are propagated among arguments."
    }, {
      "heading" : "5 Cycle-bounded Programs",
      "text" : "As saw in the previous section, to determine if a program is rule-bounded we check\nthrough linear constraints if the size of the head atom is bounded by the size of\na body atom for every relevant rule in a non-trivial SCC of the firing graph (cf.\nDefinition 4). Looking at each rule individually has its limitations, as shown by the\nfollowing example.\nExample 9 Consider the following simple program P9:\nr1 : p(X, Y) ← q(f(X), Y). r2 : q(W, f(Z)) ← p(W, Z).\nIt is easy to see that the program above is terminating, but it is not rule-bounded. The linear inequalities for the program are (cf. Definition 4):{ (αq[1]− αp[1]) · x+ (αq[2]− αp[2]) · y + αq[1] ≥ 0 (αp[1]− αq[1]) · w + (αp[2]− αq[2]) · z − αq[2] ≥ 0\nIt can be easily verified that there are no positive integer values for αp[1], αp[2], αq[1], αq[2] such that the inequalities hold for all x, y, w, z ∈ N0. The reason is the presence of the expression −αq[2] in the second inequality. Intuitively, this is because the size of the head atom increases w.r.t. the size of the body atom in r2. However, notice that the cycle involving r1 and r2 does not increase the overall size of propagated terms. This suggests we can check if an entire cycle (rather than\neach individual rule) propagates terms of bounded size. 2\nTo deal with programs like the one shown in the previous example, we introduce\nthe class of cycle-bounded programs, which is able to perform an analysis of how\nterms propagate through a group of rules, rather than looking at rules individually\nas done by the rule-bounded criterion.\nGiven a program P, a cyclic path π of Ω(P) is a sequence of edges 〈r1, r2〉, 〈r2, r3〉, ..., 〈rn, r1〉. Moreover a cyclic path π is basic if every edge π does not occur more than once. We say that π is relevant if every ri is relevant, for 1 ≤ i ≤ n.\nIn the following, we first present the cycle-bounded criterion for linear programs\nand then show how it can be applied to non-linear ones.\nDealing with linear programs. A program P is linear if every rule in P is linear. A rule r is linear if |rbody(r)| ≤ 1. Notice that rbody(r) contains exactly one atom B for every linear rule r in a non-trivial SCC of the firing graph; thus, with a slight\nabuse of notation, we use rbody(r) to refer to B.\nDefinition 7 (Cycle constraints) Let P be a linear program and let π = 〈r1, r2〉, ..., 〈rn, r1〉 be a basic cyclic path of Ω(P). For every mgu θi of head(ri) and rbody(ri+1) (1 ≤ i < n)1, we define the set of (linear) equalities eq(θi) = {x = size(t) | X/t ∈ θi}. Then, we define eq(π) =\n⋃ 1≤i<n eq(θi). 2\nExample 10 Consider the program P9 and the two basic cyclic paths π1 = 〈r1, r2〉 〈r2, r1〉 and π2 = 〈r2, r1〉 〈r1, r2〉 of Ω(P9). The mgu of head(r1) and rbody(r2) is θ = {X/W, Y/Z} and thus eq(π1) = {x = w, y = z}. Furthermore, the mgu of head(r2) and rbody(r1) is θ = {W/f(X), Y/f(Z)} and thus eq(π2) = {w = 1 + x, y = 1 + z}. 2\n1 Note that such θi’s always exist by definition of firing graph.\nDefinition 8 (Linear cycle-bounded programs) Let P be a linear program, π = 〈r1, r2〉 ... 〈rn, r1〉 be a basic cyclic path of Ω(P) and p be the predicate defined by rn. We say that π is cycle-bounded if eq(π) is satisfiable for some non-negative value of its integer variables and there exists a vector αp ∈ Narity(p) such that the constraint\nαp · size(rbody(r1))− αp · size(head(rn)) ≥ 0\nis satisfied for every non-negative value of its integer variables that satisfy eq(π). We say that P is cycle-bounded if every relevant basic cyclic path of Ω(P) is cyclebounded. 2\nIn the definition above, we assume that distinct basic cyclic paths do not share\nany logical variable.\nExample 11 Consider again program P9 of Example 9. The program is clearly linear and Ω(P9) has only two relevant basic cyclic paths π1 = 〈r1, r2〉〈r2, r1〉 and π2 = 〈r2, r1〉〈r1, r2〉. To check if P9 is cycle-bounded, we need to check if eq(π1) = {x1 = w1, y1 = z1} and eq(π2) = {w2 = 1 + x2, y2 = 1 + z2} admit a solution and if there exist αp, αq ∈ N2 s.t. the constraints:\nαq · (x1 + 1, y1) − αq · (w1, z1 + 1) ≥ 0, αp · (w2, z2) − αp · (x2, y2) ≥ 0\nare satisfied for all x1, y1, w1, z1 ∈ N0 and all x2, y2, w2, z2 ∈ N0 that satisfy eq(π1) and eq(π2).\nBy applying the equality conditions eq(π1) and eq(π2) to the above constraints\nwe get the below inequalities for the basic cyclic paths π1 and π2:\n(αq[1], αq[2]) · (x1 + 1, z1) − (αq[1], αq[2])) · (x1, z1 + 1) ≥ 0, (αp[1], αp[2])) · (x2 + 1, z2) − (αp[1], αp[2])) · (x2, z2 + 1) ≥ 0\nIt is easy to see that the first constraint (resp. the second) is satisfied for every vector αp ∈ N2 (resp. αq ∈ N2) such that αp[1] ≥ αp[2] (resp. αq[1] ≥ αq[2]). Thus, P9 is cycle-bounded. 2\nTo prove the correctness of our approach, we introduce a simpler class of termi-\nnating programs, as we did in the case of rule-bounded programs.\nDefinition 9 (Linear cycle-size-bounded programs) Let P be a linear program. We say that P is cycle-size-bounded if for every relevant basic cyclic path π = 〈r1, r2〉 ... 〈rn, r1〉 of Ω(P), eq(π) is satisfiable for some nonnegative value of its integer variables and the constraint\ntsize(rbody(r1))− tsize(head(rn)) ≥ 0\nis satisfied for every non-negative value of its integer variables that satisfy eq(π). 2\nTheorem 4\nEvery linear cycle-size-bounded program is terminating."
    }, {
      "heading" : "Proof",
      "text" : "Let P be a cycle-size-bounded program and D a finite set of facts. Consider a relevant basic cyclic path π = 〈r1, r2〉 ... 〈rn, r1〉 of Ω(P). Let r′1, ..., r′n be ground rules s.t. r′i ∈ ground(ri) for 1 ≤ i ≤ n and head(r′i) = rbody(r′i+1) for 1 ≤ i < n. For 1 ≤ i ≤ n, let θhi be the mgu of head(ri) and head(r′i), and θbi the mgu of rbody(ri) and rbody(r ′ i). Then, • tsize(head(r′i)) can be obtained from tsize(head(ri)) by replacing every integer variable x in tsize(head(ri)) with size(t) provided that X/t ∈ θhi , for 1 ≤ i ≤ n; • tsize(rbody(r′i)) can be obtained from tsize(rbody(ri)) by replacing every integer variable x in tsize(rbody(ri)) with size(t) provided that X/t ∈ θbi , for 1 ≤ i ≤ n; • if we replace every integer variable x in eq(π) with size(t) iff X/t belongs to ∪ni=1(θhi ∪ θbi ), then eq(π) is satisfied.\nThe items above entail that tsize(rbody(r′1))− tsize(head(r′n)) ≥ 0. This means that we cannot derive atoms of increasing size through the cyclic application of rules and thus P ∪D is terminating.\nTheorem 5 (Soundness) Every linear cycle-bounded program is terminating."
    }, {
      "heading" : "Proof",
      "text" : "The proof is similar to the one presented for rule-bounded programs. Given a linear cycle-bounded program P, we are going to construct an equivalent program (like Pω) to P as follows: for every relevant basic cyclic path π = 〈r1, r2〉 ... 〈rn, r1〉 of Ω(P), let αp be the vector such that αp · size(rbody(r1))−αp · size(head(rn)) ≥ 0. Then, remove rules r1 and rn from P and insert the rules head(r1)← rbody(r1)αp and head(rn)\nαp ← rbody(rn) respectively. Finally, in order to preserve the activation of rules in the obtained program, for every pair of basic cyclic paths π1 = 〈r1, r2〉 ... 〈rn, r1〉, π2 = 〈s1, s2〉 ... 〈sm, s1〉, where p is the predicate defined by rn and sn with arity k, add to P a rule of the form Aαp ← Aβp , where A is the atom p(X1, ..., Xk) and αp, βp are the vectors such that αp · size(rbody(r1))− αp · size(head(rn)) ≥ 0 and βp · size(rbody(s1))− βp · size(head(sm)) ≥ 0 respectively. It is not difficult to show that the obtained program is terminating iff P is terminating. Moreover, since P is cycle-bounded the new program is consequently cycle-size-bounded. From Theorem 4, we get that the new program is terminating and so it is P.\nDealing with non-linear programs. The application of the cycle-bounded cri-\nterion to arbitrary programs consists in applying the technique to a set of linear\nprograms derived from the original one. Given a rule r, the set of linear versions of r is defined as the set of rules `(r) = {head(r) ← B | B ∈ rbody(r)}. Given a program P = {r1, ..., rn}, the set of linear versions of P is defined as the set of linear programs `(P) = {{r′1, ..., r′n} | r′i ∈ `(ri) for 1 ≤ i ≤ n}.\nDefinition 10 (Cycle-bounded programs) A (possibly non-linear) program P is cycle-bounded if every (linear) program in `(P) is cycle-bounded. 2\nTheorem 6\nEvery cycle-bounded program is terminating."
    }, {
      "heading" : "Proof",
      "text" : "Notice that every linear version P ′ ∈ `(P) of P is such that for every set of facts D, MM(D ∪ P) ⊆MM(D ∪ P ′). Thus, if every linear version of P is cycle-bounded then for every set of facts D, MM(D ∪ P) is finite.\nTheorem 7 (Expressivity)\nCycle-bounded programs are incomparable with rule-bounded, argument-restricted,\nmapping-restricted and bounded programs."
    }, {
      "heading" : "Proof",
      "text" : "As shown in Example 9, program P9 is cycle-bounded, but it can be easily verified that it is neither mapping-restricted (and thus not argument-restricted) nor rulebounded. Moreover, the one rule program {p(X, Y, f(Z, W)) ← p(f(Z, Y), X, W).} is cycle-bounded but it is not bounded. Conversely, the program {p(f(X)) ← p(f(f(X))), p(X).} is rule-bounded, argumentrestricted (and thus mapping-restricted) and bounded but not cycle-bounded."
    }, {
      "heading" : "6 Complexity",
      "text" : "In this section, we provide upper bounds for the time complexity of checking whe-\nther a program is rule-bounded or cycle-bounded. We assume that constant space\nis used to store each constant, logical variable, function symbol, and predicate symbol. The syntactic size2 of a term t (resp. atom, rule, program), denoted by ||t||, is the number of symbols occurring in t, except for the symbols “(”, “)”, “,”, “.”, and “←”. Thus, in this section, the complexity of a problem involving P is assumed to be w.r.t. ||P||. Obviously |P| = O(||P||).\nLemma 4 Given a program P, constructing Ω(P) is in PTIME ."
    }, {
      "heading" : "Proof",
      "text" : "The construction of Ω(P) requires checking, for every atom A in the head of a rule and every atom B in the body of a rule, if A and B unify. Since we need to check\n|P| × ∑ r∈P |body(r)| times if two atoms unify and checking whether two atoms A and B unify can be done in quadratic time w.r.t. ||A|| and ||B|| (Venturini Zilli 1975), then the construction of Ω(P) is in PTIME .\nIt is worth noting that the number of SCCs is bounded by O(|P|) and that after having built Ω(P), the cost of checking whether a SSC is trivial or nontrivial is constant, whereas the cost of checking whether a rule is relevant is bounded by O(||P||). Inequalities associated with basic cycles can be rewritten by grouping\n2 We use the name syntactic size to distinguish it from the notion of size introduced in Definition 3.\nterms with respect to integer coefficients (also called α-coefficients) or with respect\nto integer variables. Therefore, in the following we assume that inequalities grouped with respect to integer variables are of the form γ1 ·x1,+ · · ·+γn ·xn+γ0 ≥ 0, where each γi, for 0 ≤ i ≤ n, is an arithmetic expression built by using α-coefficients and natural numbers, whereas inequalities grouped with respect to integer coefficients are of the form α1 · w1,+ · · · + αm · wm ≥ 0, where each wj , for 1 ≤ i ≤ m, is an arithmetic expression built by using integer variables and natural numbers.\nObviously, each γi can be considered an integer coefficient, whereas each wj can be considered an integer variable.\nLemma 5\nConsider a linear inequality of the form\nγ1 · x1 + ...+ γn · xn + γ0 ≥ 0\nwhere the γi’s are integer coefficients and the xj ’s are integer variables. The inequality is satisfied for every non-negative value of the xj ’s iff γi ≥ 0 for every 0 ≤ i ≤ n."
    }, {
      "heading" : "Proof",
      "text" : "(⇐) Straightforward. (⇒) By contradiction, assume that the inequality is satisfied for every non-negative value of the integer variables occurring in it, but there exists 0 ≤ i ≤ n such that γi < 0. If 1 ≤ i ≤ n, then the inequality is not satisfied when xi = babs(γn+1/γi)c+ 1 and xj = 0 for every j 6= i. If i = 0, then the inequality is not satisfied when xj = 0 for every 1 ≤ j ≤ n.\nTheorem 8 Checking whether a program P is rule-bounded is in NP ."
    }, {
      "heading" : "Proof",
      "text" : "In order to check whether P is rule-bounded we need to: 1) construct the firing graph Ω(P) of P, 2) compute the SCCs of Ω(P), and 3) check if every non-trivial SCC is rule-bounded.\n1) The construction of the firing graph is in PTIME by Lemma 4.\n2) It is well known that computing the SCCs of a directed graph can be done in\nlinear time w.r.t. the number of nodes and edges. Since the number of nodes of Ω(P) is |P| and the maximum number of edges of Ω(P) is |P|2, then computing all the SCCs is clearly in PTIME . 3) Let C be a non-trivial SCC of Ω(P), n = O(|P|) the number of relevant rules in C, v the maximum number of distinct variables occurring in the head atoms of the relevant rules in C, and a the maximum arity of the predicate symbols in pred(C). Since it is always possible to rewrite the constraints as in Definition 4 in the form presented by Lemma 5, given a fixed choice of one atom in srbody(r) for every relevant rule r of C, checking whether C is rule-bounded according to that choice can be done by solving a set of at most n × (v + 1) linear constraints with at most 2 × a non-negative coefficients per constraint—clearly, the size of the set\nof constraints is bounded by O(||P||) and if the set of constraints admit a solution, then there is a solution where the size of the α-coefficients is polynomial in the size of ||P|| (bounded by O(v × n × k), where k is the maximum constant appearing in the set of inequalities). As checking if such a set of linear constraints admits a\nsolution can be done in non-deterministic polynomial time (Papadimitriou 1981),\nit follows from the above discussion that this can be checked in polynomial time.\nHence, checking whether P is rule-bounded is in NP .\nWe discuss now the complexity of checking whether a program is cycle-bounded.\nTo this aim, we first introduce a technical lemma similar to Lemma 5.\nLemma 6\nConsider a linear inequality of the form\nα1 · w1 + ...+ αn · wn < 0 (1)\nwhere the wi’s are integer variables and the αj ’s positive integer coefficients. The inequality is satisfied iff wi ≤ 0 for every 1 ≤ i ≤ n and wj < 0 for some 1 ≤ j ≤ n."
    }, {
      "heading" : "Proof",
      "text" : "(⇐) It follows straightforwardly from the fact that each αj > 0 for every j ∈ [1, n]. (⇒) By contradiction, assume that (1) is satisfied for every αj > 0, where j ∈ [1, n], but either there is i ∈ [1, n] such that wi > 0 or wi ≤ 0 for every i ∈ [1, n] but none of such inequalities is strict. If there is i ∈ [1, n], (i = 1, for example) such that w1 > 0, then, since αj > 0 for each j ∈ [1, n], any assignment of α1, ..., αn > 0 such that α1 > |α2 ·w2 + ...+αn ·wn| will not satisfy (1). In the case whether no wi ≤ 0 is strict, then wi = 0 for every i ∈ [1, n] and thus α1 ·w1 + ...+αn ·wn will be zero, which does not satisfy (1).\nThe next result says that checking if a program P is cycle-bounded is in coNP . We recall that a given a set of linear constraints depending on some integer variables\nis satisfiable if there exist non-negative integer values of its integer variables that\nsatisfy the constraints. A solution of such linear constraints is any assignment for\ntheir integer variables to some non-negative integer values satisfying the constraints.\nTheorem 9 Checking whether a program P is cycle-bounded is in coNP ."
    }, {
      "heading" : "Proof",
      "text" : "In order to prove the claim, we focus on the complement of our problem. By definition, a program P is not cycle-bounded if there exists a linear version P ′ of P which is not cycle-bounded, which means that a relevant basic cyclic path π = 〈r1, r2〉...〈rn, r1〉 of Ω(P ′) is such that either eq(π) is not satisfiable or there is a solution of eq(π) for which the inequality αp ·size(rbody(r1))−αp ·size(head(rn)) ≥ 0 is false, for every αp ∈ Narity(p). Checking the statement above can be carried out by the following non-deterministic procedure.\nGuess a linear version P ′ of P and a basic cyclic path π of Ω(P ′) and check If π is relevant. if it is not, then reject (i.e., the program is cycle-bounded). Then,\ncheck if eq(π) is satisfiable, if it is not then accept (i.e., the program is not cycle-\nbounded). Now, it remains to check whether there is a solution of eq(π) such that αp · size(rbody(r1)) − αp · size(head(rn)) ≥ 0 is false for all αp ∈ Narity(p). To accomplish the aforementioned task, we can check wheher αp ·size(rbody(r1))−αp · size(head(rn)) < 0 is true. Moreover, isolating every term αp[i] (1 ≤ i ≤ arity(p)) in the inequality, we get an expression of the form αp[1] · w1 + ... + αp[arity(p)] · warity(p) < 0, where each wi depends only on variables occurring in eq(π). Since from Lemma 6, this is equivalent to check whether wi ≤ 0 for i ∈ [1, n] and there is j ∈ [1, n] such that wj < 0, checking whether there is a solution of eq(π) such that αp · size(rbody(r1)) − αp · size(head(rn)) ≥ 0 is false for all αp ∈ Narity(p) is equivalent to guessing a j ∈ [1, n] and check that the set of linear constraints eq(π)∪{w1 ≤ 0}∪ · · · ∪ {wj < 0}∪ · · · ∪ {wn ≤ 0} is satisfiable. The input program is not cycle-bounded iff the previous set of linear constraints is satisfiable.\nTo show the desired upper bound, note that guessing a linear version P ′ of P and a basic cyclic path of Ω(P ′) can be done in non-deterministic polynomial time, since |P ′| = |P| and the maximum length of a basic cyclic path coincides with the number of edges of Ω(P ′). Moreover, as previously stated, constructing the firing graph is feasible in deterministic polynomial time. Furthermore, the construction\nof eq(π) can be carried on in polynomial time too, by using a polynomially sized\nrepresentation of the mgu’s of the rules occurring in π (Venturini Zilli 1975). Finally,\nas shown in (Papadimitriou 1981), checking whether the set of linear constraints eq(π) ∪ {w1 ≤ 0} ∪ · · · ∪ {wj < 0} ∪ · · · ∪ {wn ≤ 0} is satisfiable is in NP ."
    }, {
      "heading" : "7 Related Work",
      "text" : "A significant body of work has been done on termination of logic programs under\ntop-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011;\nMarchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye\n2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al.\n2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009)\nand in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008;\nArts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996). Termination\nproperties of query evaluation for normal programs under tabling have been studied\nin (Riguzzi and Swift 2013; Riguzzi and Swift 2014; Verbaeten et al. 2001).\nIn this paper, we consider logic programs with function symbols under the stable\nmodel semantics (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) (recall\nthat, as discussed in Section 3, our approach can be applied to programs with\ndisjunction and negation by transforming them into positive normal programs),\nand thus all the excellent works above cannot be straightforwardly applied to our\nsetting—for a discussion on this see, e.g., (Calimeri et al. 2008; Alviano et al. 2010).\nIn our context, (Calimeri et al. 2008) introduced the class of finitely-ground pro-\ngrams, guaranteeing the existence of a finite set of stable models, each of finite size,\nfor programs in the class. Since membership in the class is not decidable, decidable\nsubclasses have been proposed: ω-restricted programs, λ-restricted programs, finite\ndomain programs, argument-restricted programs, safe programs, Γ-acyclic programs,\nmapping-restricted programs, and bounded programs. An adornment-based approach\nthat can be used in conjunction with the techniques above to detect more programs\nas finitely-ground has been proposed in (Greco et al. 2013b). This paper refines and\nextends (Calautti et al. 2014).\nCompared with the aforementioned classes, rule- and cycle-bounded programs\nallow us to perform a more global analysis and identify many practical programs\nas terminating, such as those where terms in the body are rearranged in the head,\nwhich are not included in any of the classes above. We observe that there are also\nprograms which are not rule- or cycle-bounded but are recognized as terminating\nby some of the aforementioned techniques (see Theorems 3 and 7).\nSimilar concepts of “term size” have been considered to check termination of logic\nprograms evaluated in a top-down fashion (Sohn and Gelder 1991), to check local\nstratification of logic programs (Palopoli 1992), in the context of partial evaluation\nto provide conditions for strong termination and quasi-termination (Vidal 2007;\nLeuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and\nSwift 2013; Riguzzi and Swift 2014). These approaches are geared to work under\ntop-down evaluation, looking at how terms are propagated from the head to the\nbody, while our approach is developed to work under bottom-up evaluation, looking\nat how terms are propagated from the body to the head. This gives rise to significant\ndifferences in how the program analysis is carried out, making one approach not applicable in the setting of the other. As a simple example, the rule p(X) ← p(X) leads to a non-terminating top-down evaluation, while it is completely harmless\nunder bottom-up evaluation.\nWe conclude by mentioning that our work is also related to research done on ter-\nmination of the chase procedure, where existential rules are considered (Marnette\n2009; Greco and Spezzano 2010; Greco et al. 2011); a survey on this topic can be\nfound in (Greco et al. 2012). Indeed, sufficient conditions ensuring termination of\nthe bottom-up evaluation of logic programs can be directly applied to existential\nrules. Specifically, one can analyze the logic program obtained from the skolemiza-\ntion of existential rules, where existentially quantified variables are replaced with\ncomplex terms (Marnette 2009). In fact, the evaluation of such a program behaves\nas the “semi-oblivious” chase (Marnette 2009), whose termination guarantees the\ntermination of the standard chase (Meier 2010; Onet 2013)."
    }, {
      "heading" : "8 Conclusions",
      "text" : "As a direction for future work, we plan to investigate how our techniques can be\ncombined with current termination criteria in a uniform way. Since they look at\nprograms from radically different standpoints, an interesting issue is to study how\nthey can be integrated so that they can benefit from each other.\nTo this end, an interesting approach would be to plug termination criteria in the\ngeneric framework proposed in (Eiter et al. 2013) and study their combination in\nsuch a framework. Another intriguing issue would be to analyze the relationships\nbetween the notions of safety of (Eiter et al. 2013) and the notions of boundedness\nused by termination criteria."
    } ],
    "references" : [ {
      "title" : "Disjunctive ASP with functions: Decidable queries and effective computation",
      "author" : [ "M. Alviano", "W. Faber", "N. Leone" ],
      "venue" : "Theory and Practice of Logic Programming 10, 46, 497–512.",
      "citeRegEx" : "Alviano et al\\.,? 2010",
      "shortCiteRegEx" : "Alviano et al\\.",
      "year" : 2010
    }, {
      "title" : "Termination of term rewriting using dependency pairs",
      "author" : [ "T. Arts", "J. Giesl" ],
      "venue" : "Theoretical Computer Science 236, 1-2, 133–178.",
      "citeRegEx" : "Arts and Giesl,? 2000",
      "shortCiteRegEx" : "Arts and Giesl",
      "year" : 2000
    }, {
      "title" : "On finitely recursive programs",
      "author" : [ "S. Baselice", "P.A. Bonatti", "G. Criscuolo" ],
      "venue" : "Theory and Practice of Logic Programming 9, 2, 213–238.",
      "citeRegEx" : "Baselice et al\\.,? 2009",
      "shortCiteRegEx" : "Baselice et al\\.",
      "year" : 2009
    }, {
      "title" : "Reasoning with infinite stable models",
      "author" : [ "P.A. Bonatti" ],
      "venue" : "Artificial Intelligence 156, 1, 75–111.",
      "citeRegEx" : "Bonatti,? 2004",
      "shortCiteRegEx" : "Bonatti",
      "year" : 2004
    }, {
      "title" : "Termination analysis of logic programs through combination of type-based norms",
      "author" : [ "M. Bruynooghe", "M. Codish", "J.P. Gallagher", "S. Genaim", "W. Vanhoof" ],
      "venue" : "ACM Transactions on Programming Languages and Systems 29, 2.",
      "citeRegEx" : "Bruynooghe et al\\.,? 2007",
      "shortCiteRegEx" : "Bruynooghe et al\\.",
      "year" : 2007
    }, {
      "title" : "Checking termination of logic programs with function symbols through linear constraints",
      "author" : [ "M. Calautti", "S. Greco", "C. Molinaro", "I. Trubitsyna" ],
      "venue" : "International Web Rule Symposium. 97–111.",
      "citeRegEx" : "Calautti et al\\.,? 2014",
      "shortCiteRegEx" : "Calautti et al\\.",
      "year" : 2014
    }, {
      "title" : "Checking termination of bottom-up evaluation of logic programs with function symbols",
      "author" : [ "M. Calautti", "S. Greco", "F. Spezzano", "I. Trubitsyna" ],
      "venue" : "Theory and Practice of Logic Programming .",
      "citeRegEx" : "Calautti et al\\.,? 2014",
      "shortCiteRegEx" : "Calautti et al\\.",
      "year" : 2014
    }, {
      "title" : "Detecting decidable classes of finitely ground logic programs with function symbols",
      "author" : [ "M. Calautti", "S. Greco", "I. Trubitsyna" ],
      "venue" : "Principles and Practice of Declarative Programming. 239–250.",
      "citeRegEx" : "Calautti et al\\.,? 2013",
      "shortCiteRegEx" : "Calautti et al\\.",
      "year" : 2013
    }, {
      "title" : "Datalog+/-: A family of logical knowledge representation and query languages for new applications",
      "author" : [ "A. Cali", "G. Gottlob", "T. Lukasiewicz", "B. Marnette", "A. Pieris" ],
      "venue" : "Proceedings of the 25th Annual IEEE Symposium on Logic in Computer Science, LICS 2010, 11-14 July 2010, Edinburgh, United Kingdom. 228–242.",
      "citeRegEx" : "Cali et al\\.,? 2010",
      "shortCiteRegEx" : "Cali et al\\.",
      "year" : 2010
    }, {
      "title" : "Computable functions in ASP: Theory and implementation",
      "author" : [ "F. Calimeri", "S. Cozza", "G. Ianni", "N. Leone" ],
      "venue" : "International Conference on Logic Programming. 407–424.",
      "citeRegEx" : "Calimeri et al\\.,? 2008",
      "shortCiteRegEx" : "Calimeri et al\\.",
      "year" : 2008
    }, {
      "title" : "Logic Programming and Databases",
      "author" : [ "S. Ceri", "G. Gottlob", "L. Tanca" ],
      "venue" : "Springer.",
      "citeRegEx" : "Ceri et al\\.,? 1990",
      "shortCiteRegEx" : "Ceri et al\\.",
      "year" : 1990
    }, {
      "title" : "Object-oriented knowledge bases in logic programming",
      "author" : [ "V.K. Chaudhri", "S. Heymans", "S. Tran", "M.A. Wessel" ],
      "venue" : "Theory and Practice of Logic Programming 13, 45-Online-Supplement.",
      "citeRegEx" : "Chaudhri et al\\.,? 2013",
      "shortCiteRegEx" : "Chaudhri et al\\.",
      "year" : 2013
    }, {
      "title" : "Testing for termination with monotonicity constraints",
      "author" : [ "M. Codish", "V. Lagoon", "P.J. Stuckey" ],
      "venue" : "International Conference on Logic Programming. 326–340.",
      "citeRegEx" : "Codish et al\\.,? 2005",
      "shortCiteRegEx" : "Codish et al\\.",
      "year" : 2005
    }, {
      "title" : "Termination of logic programs: The neverending story",
      "author" : [ "D. De Schreye", "S. Decorte" ],
      "venue" : "Journal of Logic Programming 19/20, 199–260.",
      "citeRegEx" : "Schreye and Decorte,? 1994",
      "shortCiteRegEx" : "Schreye and Decorte",
      "year" : 1994
    }, {
      "title" : "Liberal safety for answer set programs with external sources",
      "author" : [ "T. Eiter", "M. Fink", "T. Krennwallner", "C. Redl" ],
      "venue" : "AAAI Conference on Artificial Intelligence.",
      "citeRegEx" : "Eiter et al\\.,? 2013",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2013
    }, {
      "title" : "Matrix interpretations for proving termination of term rewriting",
      "author" : [ "J. Endrullis", "J. Waldmann", "H. Zantema" ],
      "venue" : "Journal of Automated Reasoning 40, 2-3, 195–220.",
      "citeRegEx" : "Endrullis et al\\.,? 2008",
      "shortCiteRegEx" : "Endrullis et al\\.",
      "year" : 2008
    }, {
      "title" : "Total termination of term rewriting",
      "author" : [ "M.C.F. Ferreira", "H. Zantema" ],
      "venue" : "Applicable Algebra in Engineering, Communication and Computing 7, 2, 133–162.",
      "citeRegEx" : "Ferreira and Zantema,? 1996",
      "shortCiteRegEx" : "Ferreira and Zantema",
      "year" : 1996
    }, {
      "title" : "Answer Set Solving in Practice",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Synthesis Lectures on Artificial Intelligence and Machine Learning. Morgan & Claypool Publishers.",
      "citeRegEx" : "Gebser et al\\.,? 2012",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2012
    }, {
      "title" : "Gringo: A new grounder for answer set programming",
      "author" : [ "M. Gebser", "T. Schaub", "S. Thiele" ],
      "venue" : "Logic Programming and Non-Monotonic Reasoning. 266–271.",
      "citeRegEx" : "Gebser et al\\.,? 2007",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2007
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "International Conference on Logic Programming/SLP. 1070–1080.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 3/4, 365–386.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1991",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "Dynamic programming in datalog with aggregates",
      "author" : [ "S. Greco" ],
      "venue" : "IEEE Trans. Knowl. Data Eng. 11, 2, 265–283.",
      "citeRegEx" : "Greco,? 1999",
      "shortCiteRegEx" : "Greco",
      "year" : 1999
    }, {
      "title" : "Incomplete Data and Data Dependencies in Relational Databases",
      "author" : [ "S. Greco", "C. Molinaro", "F. Spezzano" ],
      "venue" : "Synthesis Lectures on Data Management. Morgan & Claypool Publishers.",
      "citeRegEx" : "Greco et al\\.,? 2012",
      "shortCiteRegEx" : "Greco et al\\.",
      "year" : 2012
    }, {
      "title" : "Bounded programs: A new decidable class of logic programs with function symbols",
      "author" : [ "S. Greco", "C. Molinaro", "I. Trubitsyna" ],
      "venue" : "International Joint Conference on Artificial Intelligence. 926–932.",
      "citeRegEx" : "Greco et al\\.,? 2013a",
      "shortCiteRegEx" : "Greco et al\\.",
      "year" : 2013
    }, {
      "title" : "Logic programming with function symbols: Checking termination of bottom-up evaluation through program adornments",
      "author" : [ "S. Greco", "C. Molinaro", "I. Trubitsyna" ],
      "venue" : "Theory and Practice of Logic Programming 13, 4-5, 737–752.",
      "citeRegEx" : "Greco et al\\.,? 2013b",
      "shortCiteRegEx" : "Greco et al\\.",
      "year" : 2013
    }, {
      "title" : "Chase termination: A constraints rewriting approach",
      "author" : [ "S. Greco", "F. Spezzano" ],
      "venue" : "PVLDB 3, 1, 93–104.",
      "citeRegEx" : "Greco and Spezzano,? 2010",
      "shortCiteRegEx" : "Greco and Spezzano",
      "year" : 2010
    }, {
      "title" : "Stratification criteria and rewriting techniques for checking chase termination",
      "author" : [ "S. Greco", "F. Spezzano", "I. Trubitsyna" ],
      "venue" : "PVLDB 4, 11, 1158–1168.",
      "citeRegEx" : "Greco et al\\.,? 2011",
      "shortCiteRegEx" : "Greco et al\\.",
      "year" : 2011
    }, {
      "title" : "On the termination of logic programs with function symbols",
      "author" : [ "S. Greco", "F. Spezzano", "I. Trubitsyna" ],
      "venue" : "International Conference on Logic Programming (Technical Communications). 323–333.",
      "citeRegEx" : "Greco et al\\.,? 2012",
      "shortCiteRegEx" : "Greco et al\\.",
      "year" : 2012
    }, {
      "title" : "Greedy by choice",
      "author" : [ "S. Greco", "C. Zaniolo", "S. Ganguly" ],
      "venue" : "Proceedings of the Eleventh ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, June 2-4, 1992, San Diego, California, USA. 105–113.",
      "citeRegEx" : "Greco et al\\.,? 1992",
      "shortCiteRegEx" : "Greco et al\\.",
      "year" : 1992
    }, {
      "title" : "Fast offline partial evaluation of logic programs",
      "author" : [ "M. Leuschel", "G. Vidal" ],
      "venue" : "Information and Computation 235, 0, 70–97.",
      "citeRegEx" : "Leuschel and Vidal,? 2014",
      "shortCiteRegEx" : "Leuschel and Vidal",
      "year" : 2014
    }, {
      "title" : "One more decidable class of finitely ground programs",
      "author" : [ "Y. Lierler", "V. Lifschitz" ],
      "venue" : "International Conference on Logic Programming. 489–493.",
      "citeRegEx" : "Lierler and Lifschitz,? 2009",
      "shortCiteRegEx" : "Lierler and Lifschitz",
      "year" : 2009
    }, {
      "title" : "Proving existential termination of normal logic programs",
      "author" : [ "M. Marchiori" ],
      "venue" : "Algebraic Methodology and Software Technology. 375–390.",
      "citeRegEx" : "Marchiori,? 1996",
      "shortCiteRegEx" : "Marchiori",
      "year" : 1996
    }, {
      "title" : "Generalized schema-mappings: from termination to tractability",
      "author" : [ "B. Marnette" ],
      "venue" : "PODS. 13–22.",
      "citeRegEx" : "Marnette,? 2009",
      "shortCiteRegEx" : "Marnette",
      "year" : 2009
    }, {
      "title" : "On the Termination of the Chase Algorithm",
      "author" : [ "M. Meier" ],
      "venue" : "Albert-Ludwigs-Universitat Freiburg (Germany).",
      "citeRegEx" : "Meier,? 2010",
      "shortCiteRegEx" : "Meier",
      "year" : 2010
    }, {
      "title" : "Termination analysis of logic programs based on dependency graphs",
      "author" : [ "M.T. Nguyen", "J. Giesl", "P. Schneider-Kamp", "D. De Schreye" ],
      "venue" : "International Symposium on Logic-based Program Synthesis and Transformation. 8–22.",
      "citeRegEx" : "Nguyen et al\\.,? 2007",
      "shortCiteRegEx" : "Nguyen et al\\.",
      "year" : 2007
    }, {
      "title" : "Termination of narrowing via termination of rewriting",
      "author" : [ "N. Nishida", "G. Vidal" ],
      "venue" : "Applicable Algebra in Engineering, Communication and Computing 21, 3, 177–225.",
      "citeRegEx" : "Nishida and Vidal,? 2010",
      "shortCiteRegEx" : "Nishida and Vidal",
      "year" : 2010
    }, {
      "title" : "Termination of logic programs: Transformational methods revisited",
      "author" : [ "E. Ohlebusch" ],
      "venue" : "Applicable Algebra in Engineering, Communication and Computing 12, 1/2, 73–116.",
      "citeRegEx" : "Ohlebusch,? 2001",
      "shortCiteRegEx" : "Ohlebusch",
      "year" : 2001
    }, {
      "title" : "The chase procedure and its applications in data exchange",
      "author" : [ "A. Onet" ],
      "venue" : "Data Exchange, Integration, and Streams. 1–37.",
      "citeRegEx" : "Onet,? 2013",
      "shortCiteRegEx" : "Onet",
      "year" : 2013
    }, {
      "title" : "Testing logic programs for local stratification",
      "author" : [ "L. Palopoli" ],
      "venue" : "Theor. Comput. Sci. 103, 2, 205–234.",
      "citeRegEx" : "Palopoli,? 1992",
      "shortCiteRegEx" : "Palopoli",
      "year" : 1992
    }, {
      "title" : "On the complexity of integer programming",
      "author" : [ "C.H. Papadimitriou" ],
      "venue" : "Journal of the ACM 28, 4, 765–768.",
      "citeRegEx" : "Papadimitriou,? 1981",
      "shortCiteRegEx" : "Papadimitriou",
      "year" : 1981
    }, {
      "title" : "Well-definedness and efficient inference for probabilistic logic programming under the distribution semantics",
      "author" : [ "F. Riguzzi", "T. Swift" ],
      "venue" : "Theory and Practice of Logic Programming 13, 2, 279–302.",
      "citeRegEx" : "Riguzzi and Swift,? 2013",
      "shortCiteRegEx" : "Riguzzi and Swift",
      "year" : 2013
    }, {
      "title" : "Terminating evaluation of logic programs with finite three-valued models",
      "author" : [ "F. Riguzzi", "T. Swift" ],
      "venue" : "ACM Transactions on Computational Logic.",
      "citeRegEx" : "Riguzzi and Swift,? 2014",
      "shortCiteRegEx" : "Riguzzi and Swift",
      "year" : 2014
    }, {
      "title" : "Automated termination proofs for logic programs by term rewriting",
      "author" : [ "P. Schneider-Kamp", "J. Giesl", "A. Serebrenik", "R. Thiemann" ],
      "venue" : "ACM Transactions on Computational Logic 11, 1.",
      "citeRegEx" : "Schneider.Kamp et al\\.,? 2009",
      "shortCiteRegEx" : "Schneider.Kamp et al\\.",
      "year" : 2009
    }, {
      "title" : "Automated termination analysis for logic programs with cut",
      "author" : [ "P. Schneider-Kamp", "J. Giesl", "T. Ströder", "A. Serebrenik", "R. Thiemann" ],
      "venue" : "Theory and Practice of Logic Programming 10, 4-6, 365–381.",
      "citeRegEx" : "Schneider.Kamp et al\\.,? 2010",
      "shortCiteRegEx" : "Schneider.Kamp et al\\.",
      "year" : 2010
    }, {
      "title" : "On termination of meta-programs",
      "author" : [ "A. Serebrenik", "D. De Schreye" ],
      "venue" : "Theory and Practice of Logic Programming 5, 3, 355–390.",
      "citeRegEx" : "Serebrenik and Schreye,? 2005",
      "shortCiteRegEx" : "Serebrenik and Schreye",
      "year" : 2005
    }, {
      "title" : "Termination detection in logic programs using argument sizes",
      "author" : [ "K. Sohn", "A.V. Gelder" ],
      "venue" : "Symposium on Principles of Database Systems. 216–226.",
      "citeRegEx" : "Sohn and Gelder,? 1991",
      "shortCiteRegEx" : "Sohn and Gelder",
      "year" : 1991
    }, {
      "title" : "Root-labeling",
      "author" : [ "C. Sternagel", "A. Middeldorp" ],
      "venue" : "Rewriting Techniques and Applications. 336–350.",
      "citeRegEx" : "Sternagel and Middeldorp,? 2008",
      "shortCiteRegEx" : "Sternagel and Middeldorp",
      "year" : 2008
    }, {
      "title" : "Omega-restricted logic programs",
      "author" : [ "T. Syrjanen" ],
      "venue" : "Logic Programming and NonMonotonic Reasoning. 267–279.",
      "citeRegEx" : "Syrjanen,? 2001",
      "shortCiteRegEx" : "Syrjanen",
      "year" : 2001
    }, {
      "title" : "Complexity of the unification algorithm for first-order expressions",
      "author" : [ "M. Venturini Zilli" ],
      "venue" : "CALCOLO 12, 4, 361–371.",
      "citeRegEx" : "Zilli,? 1975",
      "shortCiteRegEx" : "Zilli",
      "year" : 1975
    }, {
      "title" : "Termination proofs for logic programs with tabling",
      "author" : [ "S. Verbaeten", "D. De Schreye", "K.F. Sagonas" ],
      "venue" : "ACM Transactions on Computational Logic 2, 1, 57–92.",
      "citeRegEx" : "Verbaeten et al\\.,? 2001",
      "shortCiteRegEx" : "Verbaeten et al\\.",
      "year" : 2001
    }, {
      "title" : "Quasi-terminating logic programs for ensuring the termination of partial evaluation",
      "author" : [ "G. Vidal" ],
      "venue" : "ACM SIGPLAN Workshop on Partial Evaluation and Semantics-based Program Manipulation. 51–60.",
      "citeRegEx" : "Vidal,? 2007",
      "shortCiteRegEx" : "Vidal",
      "year" : 2007
    }, {
      "title" : "Non-termination analysis of logic programs with integer arithmetics",
      "author" : [ "D. Voets", "D. De Schreye" ],
      "venue" : "Theory and Practice of Logic Programming 11, 4-5, 521–536.",
      "citeRegEx" : "Voets and Schreye,? 2011",
      "shortCiteRegEx" : "Voets and Schreye",
      "year" : 2011
    }, {
      "title" : "Termination of term rewriting by semantic labelling",
      "author" : [ "H. Zantema" ],
      "venue" : "Fundamenta Informaticae 24, 1/2, 89–105.",
      "citeRegEx" : "Zantema,? 1995",
      "shortCiteRegEx" : "Zantema",
      "year" : 1995
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "Efforts in this direction are the class of finitely-ground programs (Calimeri et al. 2008) and the more general class of bounded term-size programs (Riguzzi and Swift 2013).",
      "startOffset" : 68,
      "endOffset" : 90
    }, {
      "referenceID" : 40,
      "context" : "2008) and the more general class of bounded term-size programs (Riguzzi and Swift 2013).",
      "startOffset" : 63,
      "endOffset" : 87
    }, {
      "referenceID" : 47,
      "context" : "These include the classes of ω-restricted programs (Syrjanen 2001), λ-restricted programs (Gebser et al.",
      "startOffset" : 51,
      "endOffset" : 66
    }, {
      "referenceID" : 18,
      "context" : "These include the classes of ω-restricted programs (Syrjanen 2001), λ-restricted programs (Gebser et al. 2007), finite domain programs (Calimeri et al.",
      "startOffset" : 90,
      "endOffset" : 110
    }, {
      "referenceID" : 9,
      "context" : "2007), finite domain programs (Calimeri et al. 2008), argument-restricted programs (Lierler and Lifschitz 2009), safe and Γ-acyclic programs (Greco et al.",
      "startOffset" : 30,
      "endOffset" : 52
    }, {
      "referenceID" : 30,
      "context" : "2008), argument-restricted programs (Lierler and Lifschitz 2009), safe and Γ-acyclic programs (Greco et al.",
      "startOffset" : 36,
      "endOffset" : 64
    }, {
      "referenceID" : 22,
      "context" : "2008), argument-restricted programs (Lierler and Lifschitz 2009), safe and Γ-acyclic programs (Greco et al. 2012; Calautti et al. 2014), mapping-restricted programs (Calautti et al.",
      "startOffset" : 94,
      "endOffset" : 135
    }, {
      "referenceID" : 5,
      "context" : "2008), argument-restricted programs (Lierler and Lifschitz 2009), safe and Γ-acyclic programs (Greco et al. 2012; Calautti et al. 2014), mapping-restricted programs (Calautti et al.",
      "startOffset" : 94,
      "endOffset" : 135
    }, {
      "referenceID" : 7,
      "context" : "2014), mapping-restricted programs (Calautti et al. 2013), and bounded programs (Greco et al.",
      "startOffset" : 35,
      "endOffset" : 57
    }, {
      "referenceID" : 23,
      "context" : "2013), and bounded programs (Greco et al. 2013a).",
      "startOffset" : 28,
      "endOffset" : 48
    }, {
      "referenceID" : 10,
      "context" : "Classical applications need the use of structured data such as bill of materials consisting in the description of all items that compose a product, down to the lowest level of detail (Ceri et al. 1990), management of strings in bioinformatics applications, managing and querying ontological data using logic languages (Cali et al.",
      "startOffset" : 183,
      "endOffset" : 201
    }, {
      "referenceID" : 8,
      "context" : "1990), management of strings in bioinformatics applications, managing and querying ontological data using logic languages (Cali et al. 2010; Chaudhri et al. 2013), as well as applications based on greedy and dynamic programming algorithms (Greco et al.",
      "startOffset" : 122,
      "endOffset" : 162
    }, {
      "referenceID" : 11,
      "context" : "1990), management of strings in bioinformatics applications, managing and querying ontological data using logic languages (Cali et al. 2010; Chaudhri et al. 2013), as well as applications based on greedy and dynamic programming algorithms (Greco et al.",
      "startOffset" : 122,
      "endOffset" : 162
    }, {
      "referenceID" : 28,
      "context" : "2013), as well as applications based on greedy and dynamic programming algorithms (Greco et al. 1992; Greco 1999).",
      "startOffset" : 82,
      "endOffset" : 113
    }, {
      "referenceID" : 21,
      "context" : "2013), as well as applications based on greedy and dynamic programming algorithms (Greco et al. 1992; Greco 1999).",
      "startOffset" : 82,
      "endOffset" : 113
    }, {
      "referenceID" : 19,
      "context" : "This section recalls syntax and the stable model semantics of logic programs with function symbols (Gelfond and Lifschitz 1988; Gebser et al. 2012).",
      "startOffset" : 99,
      "endOffset" : 147
    }, {
      "referenceID" : 17,
      "context" : "This section recalls syntax and the stable model semantics of logic programs with function symbols (Gelfond and Lifschitz 1988; Gebser et al. 2012).",
      "startOffset" : 99,
      "endOffset" : 147
    }, {
      "referenceID" : 22,
      "context" : "In fact, the minimal model of st(P) contains every stable model of P (Greco et al. 2012)—whence, the termination of st(P), which implies finiteness and computability of the minimal model will also imply that P has a finite number of stable models, each of finite size, which can be computed.",
      "startOffset" : 69,
      "endOffset" : 88
    }, {
      "referenceID" : 39,
      "context" : "As checking if such a set of linear constraints admits a solution can be done in non-deterministic polynomial time (Papadimitriou 1981), it follows from the above discussion that this can be checked in polynomial time.",
      "startOffset" : 115,
      "endOffset" : 135
    }, {
      "referenceID" : 39,
      "context" : "Finally, as shown in (Papadimitriou 1981), checking whether the set of linear constraints eq(π) ∪ {w1 ≤ 0} ∪ · · · ∪ {wj < 0} ∪ · · · ∪ {wn ≤ 0} is satisfiable is in NP .",
      "startOffset" : 21,
      "endOffset" : 41
    }, {
      "referenceID" : 31,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 36,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 12,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 35,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 42,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 43,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 34,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 4,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 3,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 2,
      "context" : "A significant body of work has been done on termination of logic programs under top-down evaluation (De Schreye and Decorte 1994; Voets and De Schreye 2011; Marchiori 1996; Ohlebusch 2001; Codish et al. 2005; Serebrenik and De Schreye 2005; Nishida and Vidal 2010; Schneider-Kamp et al. 2009; Schneider-Kamp et al. 2010; Nguyen et al. 2007; Bruynooghe et al. 2007; Bonatti 2004; Baselice et al. 2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al.",
      "startOffset" : 100,
      "endOffset" : 400
    }, {
      "referenceID" : 52,
      "context" : "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).",
      "startOffset" : 40,
      "endOffset" : 156
    }, {
      "referenceID" : 46,
      "context" : "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).",
      "startOffset" : 40,
      "endOffset" : 156
    }, {
      "referenceID" : 1,
      "context" : "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).",
      "startOffset" : 40,
      "endOffset" : 156
    }, {
      "referenceID" : 15,
      "context" : "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).",
      "startOffset" : 40,
      "endOffset" : 156
    }, {
      "referenceID" : 16,
      "context" : "2009) and in the area of term rewriting (Zantema 1995; Sternagel and Middeldorp 2008; Arts and Giesl 2000; Endrullis et al. 2008; Ferreira and Zantema 1996).",
      "startOffset" : 40,
      "endOffset" : 156
    }, {
      "referenceID" : 40,
      "context" : "Termination properties of query evaluation for normal programs under tabling have been studied in (Riguzzi and Swift 2013; Riguzzi and Swift 2014; Verbaeten et al. 2001).",
      "startOffset" : 98,
      "endOffset" : 169
    }, {
      "referenceID" : 41,
      "context" : "Termination properties of query evaluation for normal programs under tabling have been studied in (Riguzzi and Swift 2013; Riguzzi and Swift 2014; Verbaeten et al. 2001).",
      "startOffset" : 98,
      "endOffset" : 169
    }, {
      "referenceID" : 49,
      "context" : "Termination properties of query evaluation for normal programs under tabling have been studied in (Riguzzi and Swift 2013; Riguzzi and Swift 2014; Verbaeten et al. 2001).",
      "startOffset" : 98,
      "endOffset" : 169
    }, {
      "referenceID" : 19,
      "context" : "In this paper, we consider logic programs with function symbols under the stable model semantics (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) (recall that, as discussed in Section 3, our approach can be applied to programs with disjunction and negation by transforming them into positive normal programs), and thus all the excellent works above cannot be straightforwardly applied to our setting—for a discussion on this see, e.",
      "startOffset" : 97,
      "endOffset" : 153
    }, {
      "referenceID" : 20,
      "context" : "In this paper, we consider logic programs with function symbols under the stable model semantics (Gelfond and Lifschitz 1988; Gelfond and Lifschitz 1991) (recall that, as discussed in Section 3, our approach can be applied to programs with disjunction and negation by transforming them into positive normal programs), and thus all the excellent works above cannot be straightforwardly applied to our setting—for a discussion on this see, e.",
      "startOffset" : 97,
      "endOffset" : 153
    }, {
      "referenceID" : 9,
      "context" : ", (Calimeri et al. 2008; Alviano et al. 2010).",
      "startOffset" : 2,
      "endOffset" : 45
    }, {
      "referenceID" : 0,
      "context" : ", (Calimeri et al. 2008; Alviano et al. 2010).",
      "startOffset" : 2,
      "endOffset" : 45
    }, {
      "referenceID" : 9,
      "context" : "In our context, (Calimeri et al. 2008) introduced the class of finitely-ground programs, guaranteeing the existence of a finite set of stable models, each of finite size, for programs in the class.",
      "startOffset" : 16,
      "endOffset" : 38
    }, {
      "referenceID" : 24,
      "context" : "An adornment-based approach that can be used in conjunction with the techniques above to detect more programs as finitely-ground has been proposed in (Greco et al. 2013b).",
      "startOffset" : 150,
      "endOffset" : 170
    }, {
      "referenceID" : 5,
      "context" : "This paper refines and extends (Calautti et al. 2014).",
      "startOffset" : 31,
      "endOffset" : 53
    }, {
      "referenceID" : 45,
      "context" : "Similar concepts of “term size” have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).",
      "startOffset" : 124,
      "endOffset" : 146
    }, {
      "referenceID" : 38,
      "context" : "Similar concepts of “term size” have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).",
      "startOffset" : 196,
      "endOffset" : 211
    }, {
      "referenceID" : 50,
      "context" : "Similar concepts of “term size” have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).",
      "startOffset" : 317,
      "endOffset" : 354
    }, {
      "referenceID" : 29,
      "context" : "Similar concepts of “term size” have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).",
      "startOffset" : 317,
      "endOffset" : 354
    }, {
      "referenceID" : 40,
      "context" : "Similar concepts of “term size” have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).",
      "startOffset" : 396,
      "endOffset" : 444
    }, {
      "referenceID" : 41,
      "context" : "Similar concepts of “term size” have been considered to check termination of logic programs evaluated in a top-down fashion (Sohn and Gelder 1991), to check local stratification of logic programs (Palopoli 1992), in the context of partial evaluation to provide conditions for strong termination and quasi-termination (Vidal 2007; Leuschel and Vidal 2014), and in the context of tabled resolution (Riguzzi and Swift 2013; Riguzzi and Swift 2014).",
      "startOffset" : 396,
      "endOffset" : 444
    }, {
      "referenceID" : 32,
      "context" : "We conclude by mentioning that our work is also related to research done on termination of the chase procedure, where existential rules are considered (Marnette 2009; Greco and Spezzano 2010; Greco et al. 2011); a survey on this topic can be found in (Greco et al.",
      "startOffset" : 151,
      "endOffset" : 210
    }, {
      "referenceID" : 25,
      "context" : "We conclude by mentioning that our work is also related to research done on termination of the chase procedure, where existential rules are considered (Marnette 2009; Greco and Spezzano 2010; Greco et al. 2011); a survey on this topic can be found in (Greco et al.",
      "startOffset" : 151,
      "endOffset" : 210
    }, {
      "referenceID" : 26,
      "context" : "We conclude by mentioning that our work is also related to research done on termination of the chase procedure, where existential rules are considered (Marnette 2009; Greco and Spezzano 2010; Greco et al. 2011); a survey on this topic can be found in (Greco et al.",
      "startOffset" : 151,
      "endOffset" : 210
    }, {
      "referenceID" : 22,
      "context" : "2011); a survey on this topic can be found in (Greco et al. 2012).",
      "startOffset" : 46,
      "endOffset" : 65
    }, {
      "referenceID" : 32,
      "context" : "Specifically, one can analyze the logic program obtained from the skolemization of existential rules, where existentially quantified variables are replaced with complex terms (Marnette 2009).",
      "startOffset" : 175,
      "endOffset" : 190
    }, {
      "referenceID" : 32,
      "context" : "In fact, the evaluation of such a program behaves as the “semi-oblivious” chase (Marnette 2009), whose termination guarantees the termination of the standard chase (Meier 2010; Onet 2013).",
      "startOffset" : 80,
      "endOffset" : 95
    }, {
      "referenceID" : 33,
      "context" : "In fact, the evaluation of such a program behaves as the “semi-oblivious” chase (Marnette 2009), whose termination guarantees the termination of the standard chase (Meier 2010; Onet 2013).",
      "startOffset" : 164,
      "endOffset" : 187
    }, {
      "referenceID" : 37,
      "context" : "In fact, the evaluation of such a program behaves as the “semi-oblivious” chase (Marnette 2009), whose termination guarantees the termination of the standard chase (Meier 2010; Onet 2013).",
      "startOffset" : 164,
      "endOffset" : 187
    }, {
      "referenceID" : 14,
      "context" : "To this end, an interesting approach would be to plug termination criteria in the generic framework proposed in (Eiter et al. 2013) and study their combination in such a framework.",
      "startOffset" : 112,
      "endOffset" : 131
    }, {
      "referenceID" : 14,
      "context" : "Another intriguing issue would be to analyze the relationships between the notions of safety of (Eiter et al. 2013) and the notions of boundedness used by termination criteria.",
      "startOffset" : 96,
      "endOffset" : 115
    } ],
    "year" : 2015,
    "abstractText" : "It is widely acknowledged that function symbols are an important feature in answer set programming, as they make modeling easier, increase the expressive power, and allow us to deal with infinite domains. The main issue with their introduction is that the evaluation of a program might not terminate and checking whether it terminates or not is undecidable. To cope with this problem, several classes of logic programs have been proposed where the use of function symbols is restricted but the program evaluation termination is guaranteed. Despite the significant body of work in this area, current approaches do not include many simple practical programs whose evaluation terminates. In this paper, we present the novel classes of rule-bounded and cycle-bounded programs, which overcome different limitations of current approaches by performing a more global analysis of how terms are propagated from the body to the head of rules. Results on the correctness, the complexity, and the expressivity of the proposed approach are provided. Under consideration in Theory and Practice of Logic Programming (TPLP).",
    "creator" : "LaTeX with hyperref package"
  }
}