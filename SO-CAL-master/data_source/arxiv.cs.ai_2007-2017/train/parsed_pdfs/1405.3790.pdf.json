{
  "name" : "1405.3790.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Transaction Logic with (Complex) Events",
    "authors" : [ "Ana Sofia Gomes", "José Júlio Alferes" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "With this as goal, we build on Transaction Logic (T R), a logic precisely designed to model and execute transactions in KBs defined by arbitrary logic theories. In it, transactions are written in a logic-programming style, by combining primitive update operations over a general KB, with the usual logic programming connectives and some additional connectives e.g. to express sequence of actions. While T R is a natural choice to deal with transactions, it remains the question whether T R can be used to express complex events, but also to deal simultaneously with the detection of complex events and the execution of transactions. In this paper we show that the former is possible while the latter is not. For that, we start by illustrating how T R can express complex events, and in particular, how SNOOP event expressions can be translated in the logic. Afterwards, we show why T R fails to deal with the two issues together, and to solve the intended problem propose Transaction Logic with Events, its syntax, model theory and executional semantics. The achieved solution is a non-monotonic extension of T R, which guarantees that every complex event detected in a transaction is necessarily responded.\nTo appear in Theory and Practice of Logic Programming (TPLP)\nKEYWORDS: reactivity, complex events, transaction logic"
    }, {
      "heading" : "1 Introduction",
      "text" : "Reactivity stands for the ability to detect complex changes (also denoted as events) in the environment and react automatically to them according to some pre-defined rules. This is a pre-requisite of many real-world applications, such as web-services providing different services depending on external information, multi-agent systems adapting their knowledge and actions according to the changes in the environment, or monitoring systems reacting to information detected by their sensors and issuing actions automatically in response to it. In reactive systems, e.g. in those based on Event-Condition-Action (ECA) languages (Alferes et al. 2011; Bry et al. 2006; Chomicki et al. 2003), the reaction triggered by the detection of a complex event may itself be a complex action, formed e.g. by the sequencial execution of several basic actions. Moreover, we sustain that sometimes reactive systems are also required to execute transactions in response to events. For example, consider an airline web-service scenario where an external event arrives stating that a partner airline is on strike for a given time period. Then, the airline must address this event by e.g.\n∗ The authors thank Michael Kifer for the valuable discussions in a preliminary version of this work. The first author was supported by the grant SFRH/BD/64038/2009 and by project ERRO (PTDC/EIA-CCO/121823/2010). The second author was supported by project ASPEN PTDC/EIA-CCO/110921/2009\nar X\niv :1\n40 5.\n37 90\nv1 [\ncs .A\nI] 1\n5 M\nay 2\nrescheduling flights with alternative partners or refund tickets for passengers who do not accept the changes. Clearly, some transactional properties regarding these actions must be ensured: viz. it can never be the case that a passenger is simultaneously not refunded nor have an alternative flight; or that she is completely refunded and has a rescheduled flight.\nAlthough the possibility of executing transactions is of crucial importance in many of today’s systems, and a must e.g. in database systems, most reactive languages do not deal with it. Some exceptions exist, but are either completely procedural and thus lack from a clear declarative semantics (as e.g. in (Papamarkos et al. 2006)), or have a strong limitation on the expressivity of either the actions or events (as e.g. in (Zaniolo 1995; Lausen et al. 1998)).\nIn this paper we propose Transaction Logic with Events, T Rev , an extension of T R (Bonner and Kifer 1993) integrating the ability to reason and execute transactions over very general forms of KBs, with the ability to detect complex events. For this, after a brief overview of T R, we show how it can be used to express and reason about complex events, and in particular, how it can express most SNOOP event operators (Adaikkalavan and Chakravarthy 2006) (Section 2). We proceed by showing why T R alone is not able to deal with both the detection of complex events and the execution of transactions, and, in particular, why it does not guarantee that all complex events detected during the execution of a transaction are responded within that execution. For solving this problem, we define T Rev , its language and model theory (Section 3.1), as well as its executional semantics (Section 3.2)."
    }, {
      "heading" : "2 Using T R to express complex events",
      "text" : "In this section we briefly recall T R’s syntax and semantics with minor syntactic changes from the original, to help distinguish between actions and event occurrences, something that is useful ahead in the paper when extending T R to deal with reactive features and complex events.\nAtoms in T R have the form p(t1, . . . , tn) where p is a predicate symbol and ti’s are terms (variables, constants, function terms). For simplicity, and without loss of generality (Bonner and Kifer 1998), we consider Herbrand instantiations, as usual. To build complex formulas, T R uses the classical connectives ∧,∨,¬,← and the connectives ⊗,♦ denoting serial conjunction and hypothetical execution. Informally, φ ⊗ ψ is an action composed of an execution of φ followed by an execution of ψ; and ♦φ tests if φ can be executed without materializing the changes. In general, formulas are viewed as (the execution of) transactions, where, φ∧ψ is the simultaneous execution of φ and ψ; φ ∨ ψ the non-deterministic choice of executing φ or ψ. φ ← ψ is a rule saying that one way to execute of φ is by executing ψ. As in classical logic, ∧ and← can be written using ∨ and ¬ (e.g. φ ∧ ψ ≡ ¬(¬φ ∨ ¬ψ)). Finally, we also use the connective ; as it is useful to express common complex events. φ;ψ says that ψ is true after φ but possibly interleaved with other occurrences, and it can be written in T R syntax as: φ⊗ path⊗ ψ where path ≡ (ϕ ∨ ¬ϕ) is a tautology that holds in paths of arbitrary size (Bonner and Kifer 1998).\nFor making possible the separation between the theory of states and updates, from the logic that combines them in transactions, T R considers a pair of oracles – Od (data oracle) and Ot (transition oracle) – as a parameter of the theory. These oracles are mappings that assume a set of state identifiers. Od is a mapping from state identifiers to a set of formulas that hold in that state, and Ot is a mapping from pairs of state identifiers to sets of formulas that hold in the transition of those states. These oracles can be instantiated with a wide variety of semantics, as e.g. relational databases, well-founded semantics, action languages, etc. (Bonner and Kifer 1993). For example, a relational database can be modeled by having states represented as sets of\nground atomic formulas. Then, the data oracle simply returns all these formulas, i.e., Od(D) = D, and for each predicate p in the KB, the transition oracle defines p.ins and p.del, representing the insertion and deletion of p, respectively. Formally, p.ins ∈ Ot(D1, D2) iff D2 = D1 ∪ {p} and, p.del ∈ Ot(D1, D2) iff D2 = D1\\{p}. SQL-style bulk updates can also be defined by Ot.\nExample 1 (Moving objects - T R) As a T R’s illustration, assume the prior relational database oracles and the actionmove(O,X, Y ) defining the relocation of object O from position X into position Y . In such a KB, states are defined using the predicates location(O,P ) saying that object O is in position P , and clear(X) stating that X is clear to receive an object. In T R, the move (trans)action can be expressed by: move(O,X, Y )← location(O,X)⊗ clear(Y )⊗ localUpdt(O,X, Y ) localUpdt(O,X, Y )← location(O,X).del ⊗ location(O, Y ).ins⊗ clear(Y ).del ⊗ clear(X).ins\nT R’s theory is built upon the notion of sequences of states denoted as paths. Formulas are evaluated over paths, and truth in T R means execution: a formula is said to succeed over a path, if that path represents a valid execution for that formula. Although not part of the original T R, here paths’ state transitions are labeled with information about what (atomic occurrences) happen in the transition of states. Precisely, paths have the form 〈D0O1→D2O2→ . . .Ok→Dk〉, where Di’s are states and Oi’s are labels (used later to annotate atomic event occurrences).\nAs usual, satisfaction of complex formulas is based on interpretations. These define what atoms are true in what paths, by mapping every path to a set of atoms. However, only the mappings compliant with the specified oracles are interpretations:\nDefinition 1 (Interpretation) An interpretation is a mapping M assigning a set of atoms (or >1) to every path, with the following restrictions (where Dis are states, and ϕ a formula):\n1. ϕ ∈M(〈D〉) if ϕ ∈ Od(D) 2. {ϕ,o(ϕ)} ⊆M(〈D1o(ϕ)→D2〉) if ϕ ∈ Ot(D1, D2)\nIn point 2 we additionally (i.e., when compared to the original definition) force o(ϕ) to belong to the same path where the primitive action ϕ is made true by the oracle, something that later (in Section 3) will help detect events associated with primitive actions, like “on insert/delete”.\nNext, we define operations on paths, and satisfaction of complex formulas over general paths.\nDefinition 2 (Path Splits, Subpaths and Prefixes) Let π be a k-path, i.e. a path of length k of the form 〈D1 O1→ . . .Ok−1→Dk〉. A split of π is any pair of subpaths, π1 and π2, such that π1 = 〈D1O1→ . . .Oi−1→Di〉 and π2 = 〈Di Oi→ . . . Ok−1→Dk〉 for some i (1 ≤ i ≤ k). In this case, we write π = π1 ◦ π2. A subpath π′ of π is any subset of states and annotations of π where both the order of the states and their annotations is preserved. A prefix π1 of π is any subpath of π sharing the initial state.\n1 For not having to consider partial mappings, besides formulas, interpretations can also return the special symbol >. The interested reader is referred to (Bonner and Kifer 1993) for details.\nDefinition 3 (T R Satisfaction of Complex Formulas) Let M be an interpretation, π a path and φ a formula. If M(π) = > then M,π |=T R φ; else:\n1. Base Case: M,π |=T R φ iff φ ∈M(π) for every event occurrence φ 2. Negation: M,π |=T R ¬φ iff it is not the case that M,π |=T R φ 3. Disjunction: M,π |=T R φ ∨ ψ iff M,π |=T R φ or M,π |=T R ψ. 4. Serial Conjunction:M,π |=T R φ⊗ψ iff there exists a split π1◦π2 of π s.t.M,π1 |=T R φ\nand M,π2 |=T R ψ 5. Executional Possibility: M,π |=T R ♦φ iff π is a 1-path of the form 〈D〉 for some state D\nand M,π′ |=T R φ for some path π′ that begins at D.\nModels and logical entailment are defined as usual. An interpretation models/satisfies a set of rules if each rule is satisfied in every possible path, and an interpretation models a rule in a path, if whenever it satisfies the antecedent, it also satisfies the consequent.\nDefinition 4 (Models, and Logical Entailment) An interpretation M is a model of a formula φ iff for every path π, M,π |=T R φ. M is a model of a set of rules P (denoted M |=T R P ) iff it is a model of every rule in P . φ is said to logically entail another formula ψ iff every model of φ is also a model of ψ.\nLogical entailment is useful to define general equivalence and implication of formulas that express properties like “transaction φ is equivalent to transaction ψ” or “whenever transaction ψ is executed, ψ′ is also executed”. Moreover, if instead of transactions, we view the propositions as representing event occurrences, this entailment can be used to express complex events. For instance, imagine we want to state a complex event alarm, e.g. triggered whenever event ev1 occurs after both ev2 and ev3 occur simultaneously. This can be expressed in T R as:\no(alarm)← (o(e2) ∧ o(e3));o(e1) (1)\nIn every model of this formula, whenever there is a (sub)path where both o(e2) and o(e3) are true, followed by a (sub)path where o(e1) holds, then o(alarm) is true in the whole path.\nOther complex event definitions are possible, and in fact we can encode most of SNOOP (Adaikkalavan and Chakravarthy 2006) operators in T R. This is shown in Theorem 1 where, for a given history of past event occurrences, we prove that if an event expression is true in SNOOP, then there is a translation into a T R formula which is also true in that history. Since a SNOOP history is a set of atomic events associated with discrete points in time, the first step is to build a T R path expressing such history. We construct it as a sequence of state identifiers labeled with time, where time point i takes place in the transition of states 〈si, si+1〉, and only consider interpretations M over such a path that are compatible with SNOOP’s history, i.e. such that, for every atomic event that is true in a time i, M makes the same event true in the path 〈si, si+1〉.\nTheorem 1 (SNOOP Algebra and T R) Let E be a SNOOP algebra expression without periodic and aperiodic operators, H be a history containing the set of all SNOOP primitive events eij [t1] that have occurred over the time interval t1, tmax, and 〈s1, . . . smax+1〉 be a path with size tmax− t1+1. Let τ be the following function:\nPrimitive: τ(E) = o(E) where E is a primitive event Sequence: τ(E1;E2) = τ(E1)⊗ path⊗ τ(E2) Or: τ(E1OE2) = τ(E1) ∨ τ(E2) AND: τ(E14E2) = [(τ(E1)⊗ path) ∧ (path⊗ τ(E2))] ∨ [(τ(E2)⊗ path) ∧ (path⊗ τ(E1))] NOT: τ(¬(E3)[E1, E2]) = τ(E1)⊗ ¬τ(E3)⊗ τ(E2)\nThen, [ti, tf ] ∈ E[H] ⇒ ∀M compatible with H , M, 〈sti , . . . , stf+1〉 |=T R τ(E), where, cf. (Adaikkalavan and Chakravarthy 2006), E[H] is the set of time intervals (ti, tf ) where E occurs over H in an unrestricted context, and where M is compatible with H if, for each eij [ti] ∈ H: M, 〈sti , sti+1〉 |=T R o(ej).\nBesides the logical entailment, T R also provides the notion of executional entailment for reasoning about properties of a specific execution path.\nDefinition 5 (Executional Entailment) Let P be a set of rules, φ a formula, and D0O1→ . . .On→Dn a path. P, (D0\nO1→ . . .On→Dn) |= φ (?) iff for every model M of P , M, 〈D0O1→ . . .On→Dn〉 |= φ. Additionally, P,D0– |= φ holds, if there is a path D0O1→ . . .On→Dn that makes (?) true.\nP, (D0 O1→ . . .On→Dn) |= φ says that a successful execution of transaction φ respecting the\nrules in P , can change the KB from stateD0 intoDn with a sequence of occurrencesO1, . . . , On. E.g., in the Example 1 (with obvious abbreviations), the statementP, ({cl(t), l(c, o)}o(l(c,o).del)→ {cl(t)}o(l(c,t).ins)→{cl(t), l(c, t)}o(cl(t).del)→{l(c, t)}o(cl(o).ins)→{l(c, t), cl(o)}) |= move(c, o, t) means that a possible result of executing the transactionmove(c, oven, table) starting in the state {clear(table), loc(c, oven)} is the path with those 5 states, ending in {loc(c, table), clear(oven)}.\nThis entailment has a corresponding proof theory (Bonner and Kifer 1993) which, for a subset of T R, is capable of constructing such a path given a program, a T R formula, and an initial state. I.e. a path where the formula can be executed. If no such path exists, then the transaction fails, and nothing is built after the initial state.\n3 T Rev: combining the execution of transactions with complex event detection\nReactive languages need to express behaviors like: “on alarm do action a1 followed by action a2”, where the actions a1 ⊗ a2 may define a transaction, and alarm is e.g. the complex event in (1). Clearly, T R can individually express and reason about transaction a1 ⊗ a2, and its complex event. So, the question is whether it can deal with both simultaneously. For that, two important issues must be tackled: 1) how to model the triggering behavior of reactive systems, where the occurrence of an event drives the execution of a transaction in its response; 2) how to model the transaction behavior that prevents transactions to commit until all occurring events are responded.\nRegarding 1), (Bonner et al. 1993) shows that simple events can be triggered in T R as: p← body ⊗ ev ev ← r(ev) (2)\nWith such rules, in all paths that make p true (i.e., in all executions of transaction p) the event ev is triggered/fired (after the execution of some arbitrary body), and ev’s response, r(ev), is executed. Note that, both r(ev) and body can be defined as arbitrary formulas.\nBut, this is just a very simple and specific type of event: atomic events that are explicitly triggered by a transaction defined in the program. In general, atomic events can also arrive as external events, or because some primitive action is executed in a path (e.g. as the database triggers - “on insert/on delete”). Triggering external events in T R can be done by considering the paths that make the external event true. E.g., if one wants to respond to an external event ev from an initial state, all we need to do is find the paths π starting in that state, s.t. P, π |= ev, where P includes the last rule from (2) plus the rules defining ev’s response.\nThe occurrences of primitive actions can be tackled by Point 2 of Def. 1, and the occurrence of complex events can be defined as prescribed in Section 2. However, the above approach of\n(Bonner et al. 1993) does not help for driving the execution of an event response when such occurrences become true. For instance, the ECA-rule before could be stated as:\no(alarm)← (o(e2) ∧ o(e3));o(e1) r(alarm)← a1 ⊗ a2\nBut this does not drive the execution of r(alarm) when o(alarm) holds; one has further to force that whenever o(alarm) holds, r(alarm) must be made true subsequently. Of course, adding a rule r(alarm) ← o(alarm) would not work: such rule would only state that, one alternative way to satisfy the response of alarm is to make its occurrence true. And for that, it would be enough to satisfy o(alarm) to make r(alarm) true, which is not what is intended.\nClearly, this combination implies two different types of formulas with two very different behaviors: the detection of events which are tested for occurrence w.r.t. a past history; and the execution of transactions as a response to them, which intends to construct paths where formulas can succeed respecting transactional properties. This has to be reflected in the semantics and these formulas should be evaluated differently accordingly to their nature.\nRegarding 2), as in database triggers, transaction’s execution must depend on the events triggered. Viz., an event occurring during a transaction execution can delay that transaction to commit/succeed until the event response is successfully executed, and the failure of such response should imply the failure of the whole transaction. Encoding this behavior requires that, if an event occurs during a transaction, then its execution needs to be expanded with the event response. Additionally, this also precludes transactions to succeed in paths where an event occurs and is not responded (even if the transaction would succeed in that path if the event did not existed).\nFor addressing these issues, below we define T Rev . This extension of T R evaluates event formulas and transaction formulas differently, using two distinct relations (respectively |=T R and |=), and occurrences and responses are syntactic represented w.r.t. a given event name e, as o(e) and r(e), respectively. In this context, |= requires transactions to be satisfied in expanded paths, where every occurring event (made true by |=T R) is properly responded.\n3.1 T Rev Syntax and Model Theory\nTo make possible a different evaluation of events and transactions, predicates in T Rev are partitioned into transaction names (Pt), event names (Pe), and oracle primitives (PO) and, as with T R, we work with the Herbrand instantiation of the language.\nFormulas in T Rev are partitioned into transaction formulas and event formulas. Event formulas denote formulas meant to be detected and are either an event occurrence, or an expression defined inductively as ¬φ, φ ∧ ψ, φ ∨ ψ, φ ⊗ ψ, or φ;ψ where φ and ψ are event formulas. An event occurrence is of the form o(ϕ) s.t. ϕ ∈ Pe or ϕ ∈ PO. Note that, we preclude the usage of ♦ in event formulas, as it would make little sense to detect occurrences based on what could possibly be executed.\nTransaction formulas are formulas that can be executed, and are either a transaction atom, or an expression defined inductively as ¬φ, ♦φ, φ ∧ ψ, φ ∨ ψ, or φ ⊗ ψ. A transaction atom is either a transaction name (in Pt), an oracle defined primitive (in PO), the response to an event (r(ϕ) where ϕ ∈ PO ∪ Pe), or an event name (in Pe) The latter corresponds to the (trans)action of explicitly triggering an event directly in a transaction as in (2) or as an external event. As we shall see (Def. 7) explicitly triggering an event changes the path of execution (by asserting the information that the event has happened in the current state) and, as such, is different from simply inferring (or detecting) what events hold given a past path.\nFinally, rules have the form ϕ ← ψ and can be transaction or (complex) event rules. In a transaction rule ϕ is a transaction atom and ψ a transaction formula; in an event rule ϕ is an event occurrence and ψ is a event formula. A program is a set of transaction and event rules.\nImportantly, besides the data and transition oracles, T Rev is also parametric on a choice function defining what event should be selected at a given time in case of conflict. Since defining what event should be picked from the set of occurring events depends on the application in mind, T Rev does not commit to any particular definition, encapsulating it in function choice .\nAs a reactive system, T Rev receives a series of external events which may cause the execution of transactions in response. This is defined as P,D0– |= e1 ⊗ . . . ⊗ ek, where D0 is the initial KB state and e1 ⊗ . . .⊗ ek is the sequence of external events that arrive to the system. Here, we want to find the pathD0O1→ . . .On→Dn encoding a KB evolution that responds to e1⊗ . . .⊗ek.\nAs mentioned, triggering explicit events is a transaction formula encoding the action of making an occurrence explicitly true. This is handled by the definition of interpretation, in a similar way to how atomic events defined by oracles primitives are made true:\nDefinition 6 (T Rev interpretations) A T Rev interpretation is a T R interpretation that additionally satisfies the restriction: 3) o(e) ∈ M(〈Do(e)→D〉) if e ∈ Pe\nWe can now define the satisfaction of complex formulas, and then models of a program. Event formulas are evaluated w.r.t. the relation |=T R specified in Def. 3. Transaction formulas are evaluated w.r.t. the relation |= which requires formulas to be true in expanded paths, in which every occurring event is responded (something dealt by expM (π), defined below).\nDefinition 7 (Satisfaction of Transaction Formulas and Models) Let M be an interpretation, π a path, φ transaction formula. If M(π) = > then M,π |= φ; else:\n1. Base Case: M,π |= p iff ∃π′ prefix of π s.t. p ∈ M(π′) and π = expM (π′), for every transaction atom p where p 6∈ Pe. 2. Event Case:M,π |= e iff e ∈ Pe, ∃π′ prefix of π s.t.M,π′ |=T R o(e) and π = expM (π′). 3. Negation: M,π |= ¬φ iff it is not the case that M,π |= φ 4. Disjunction: M,π |= φ ∨ ψ iff M,π |= φ or M,π |= ψ. 5. Serial Conjunction: M,π |= φ ⊗ ψ iff ∃π′ prefix of π and some split π1 ◦ π2 of π′ such\nthat M,π1 |= φ and M,π2 |= ψ and π = expM (π′). 6. Executional Possibility: M,π |= ♦φ iff π is a 1-path of the form 〈D〉 for some state D and M,π′ |= φ for some path π′ that begins at D.\nAn interpretation M is a model of a transaction formula (resp. event formula) φ iff for every path π, M,π |= φ (resp. M,π |=T R φ). M is a model of a program P (denoted M |= P ) iff it is a model of every (transaction and complex event) rule in P .\nexpM (π) is a function that, given a path with possibly unanswered events, expands it with the result of responding to those events. Its definition must perforce have some procedural nature: it must start by detecting which are the unanswered events; pick one of them, according to a given choice function; then expand the path with the response of the chosen event. The response to this event, computed by operatorRM defined below, may, in turn, generate the occurrence of further events. So,RM must be iterated until no more unanswered events exist.\nDefinition 8 (Expansion of a Path) For a path π1 and an interpretation M , the response operatorRM (π1) is defined as follows:\nRM (π1) = { π1 ◦ π2 if choice(M,π1) = e and M,π2 |= r(e) π1 if choice(M,π1) =\nThe expansion of a path π is expM (π) =↑ RM (π).\nIn general it may not be possible to address all events in a finite path, and thus, RM may not have a fixed-point. In fact, non-termination is a known problem of reactive systems, and is often undecidable for the general case (Bailey et al. 2004). However, if termination is possible, then a fixed-point exists and each iteration ofRM is an approximation of the expansion operator expM .\nThis definition leaves open the choice function, that is taken as a further parameter of T Rev , and specifies how to choose the next unanswered event to respond to. For its instantiation one needs to decide: 1) in which order should events be responded and 2) how should an event be responded. The former defines the handling order of events in case of conflict, e.g. based on when events have occurred (temporal order), on a priority list, or any other criteria. The latter defines the response policy of an ECA-language, i.e. when is an event considered to be responded. E.g., if an event occurs more than once before the system can respond to it, this specifies if such response should be issued only once or equally to the amount of occurrences. Choosing the appropriate operational semantics depends on the application in mind. In the following definition we exemplify how this choice function can be instantiated, for a case when events are responded in the (temporal) order in which they occurred, and events for which there was already a response are not responded again.\nDefinition 9 (Temporal choice function) Let M be an interpretation and π be a path. The temporal choice function is choice(M,π) = firstUnans(M,π, order(M,π)) where:\n• order(M,π) = 〈e1, . . . , en〉 iff ∀ei 1 ≤ i ≤ n, ∃πi subpath of π where M,π |=T R o(ei) and ∀ej s.t. i < j then ej occurs after ei • e2 occurs after e1 w.r.t. π and M iff there exists π1, π2 subpaths of π such that π1 = 〈Di Oi→ . . .Oj−1→Dj〉, π2 = 〈DnOn→ . . .Om−1→Dm〉, M,π1 |= o(e1), M,π2 |= o(e2) and Dj ≤ Dm w.r.t. the ordering in π. • firstUnans(M,π, 〈e1, . . . , en〉) = ei iff ei is the first event in 〈e1, . . . , en〉 where given π′ subpath of π and M,π′ |=T R o(e) then ¬∃π′′ s.t. π′′ is also a subpath of π, π′′ is after π′ and M,π′′ |= r(e).\nWe continue by exemplifying the semantics in examples.\nExample 2 p← a.ins r(e1)← c.ins\n(P3) p← a.ins r(e1)← c.ins o(e1)← o(a.ins)\n(P4)\nConsider the programs2 P3 and P4. In P3, p holds in the path 〈{}o(a.ins)→{a}〉. This is true since all interpretations must comply with the oracles and thus ∀M : a.ins ∈ M(〈{}o(a.ins)→{a}〉)\n2 For brevity, in this and the following examples we assume the rule r(p)← true to appear in every program for every primitive action p defined in the signature of the oracles, unless when stated otherwise. I.e., we assume the responses of events inferred from primitive actions to hold trivially whenever their rules do not appear explicitly in the program.\nimplying M, 〈{}o(a.ins)→{a}〉 |= a.ins. Assuming that M is a model of P3, then it satisfies the rule p← a.ins, which means that p ∈M(〈{}o(a.ins)→{a}〉) and M, 〈{}o(a.ins)→{a}〉 |= p.\nHowever, since o(e1) ← o(a.ins) ∈ P4 and ∀M.o(a.ins) ∈ M(〈{}o(a.ins)→{a}〉), for M to be a model of P4, then o(e1) ∈ M(〈{}o(a.ins)→{a}〉). Since e1 has a response defined, then in path 〈{}o(a.ins)→{a}〉 the occurrence e1 is unanswered and both the transactions p and a.ins cannot succeed in that path. Namely, o(e1) constrains the execution of every transaction in the path 〈{}o(a.ins)→{a}〉 and, for transaction formulas to succeed, such path needs to be expanded with e1’s response. Since, expM (〈{} a.ins→{a}〉) = 〈{} o(a.ins)→{a} o(c.ins)→{a, c}〉 then, both transactions p and a.ins succeed in the longer path 〈{}o(a.ins)→{a}o(c.ins)→{a, c}〉, i.e. for an M model of P4: M, 〈{} o(a.ins)→ {a} o(c.ins)→ {a, c}〉 |= p and M, 〈{} o(a.ins)→ {a} o(c.ins)→{a, c}〉 |= a.ins. Notice the non-monotonicity of T Rev , viz. that adding a new event rule to P3 falsifies the transaction formulas p and a.ins in paths where they were previously true.\nAs in T R, in T Rev every formula that is meant to be executed, is meant to be executed as a transaction. As such, the primitive a.ins in example P4 cannot succeed in the path 〈{} o(a.ins)→{a}〉 since there are unanswered events in that path. However, note that a.ins belongs to every interpretation M of that path (due to the restrictions in Def. 1). Thus the primitive a.ins is true in 〈{}o(a.ins)→{a}〉 although the transaction a.ins is not.\nExample 3\np← a.ins q ← b.ins r(ex)← p⊗ q r(e1)← d.ins r(a.ins)← c.ins o(e1)← o(a.ins)⊗ o(b.ins)\n{a}\np\n{a, c}\nr(e1)\n{} {a, b, c} {a, b, c, d}\nq\no(e1)\no(a.ins) o(c.ins) o(b.ins)\nr(a.ins)\no(d.ins)\na.ins\nc.ins b.ins\nd.ins\nex\no(ex)\np⌦ q\n{} The right-hand side figure illustrates a satisfaction of the external event ex. The occurrence of ex forces the satisfaction of the transaction p⊗q, which is true if both its “subformulas” (p and q) are satisfied over smaller paths. Note that, by definition of the relation |=, all occurrences detected over the independent paths that satisfy p and q are already responded in those paths. Thus, we need only to cater for the events triggered due to the serial conjunction. Here, for a model M of the program, M, 〈{}o(a.ins)→{a}o(c.ins)→{a, c}〉 |= p and M, 〈{a, c}o(b.ins)→{a, b, c}〉 |= q. Further, the rule o(e1) ← o(a.ins) ⊗ o(b.ins) defines one pattern for the occurrence of e1 which constrains the execution of transaction p ⊗ q and forces the expansion of the path to satisfy r(e1). Consequently, M, 〈{} o(a.ins)→ {a} o(c.ins)→ {a, c} o(b.ins)→ {a, b, c} o(d.ins)→ {a, b, c, d}〉 |= p ⊗ q, and M, 〈{} o(ex)→ {} o(a.ins)→ {a} o(c.ins)→ {a, c} o(b.ins)→ {a, b, c} o(d.ins)→{a, b, c, d}〉 |= ex"
    }, {
      "heading" : "3.2 Entailment and Properties",
      "text" : "The logical entailment defined in Def. 4 can be used to reason about properties of transaction and event formulas that hold for every possible path of execution. In T Rev , similarly to T R, we further define executional entailment, to talk about properties of a particular execution path. But, to reason about the execution of transactions over a specific path, care must be taken since, as described above, the satisfaction of a new occurrence in a path may invalidate transaction formulas that were previously true.\nTo deal with a similar behavior, non-monotonic logics rely on the concept of minimal or preferred models: instead of considering all possible models, non-monotonic theories restrict to the most skeptical ones. Likewise, T Rev uses the minimal models of a program to define entailment, whenever talking about a particular execution of a formula. As usual, minimality is defined by set inclusion on the amount of predicates that an interpretation satisfies, and a minimal model is a model that minimizes the set of formulas that an interpretation satisfies in a path.\nDefinition 10 (Minimal Model) Let M1 and M2 be interpretations. Then M1 ≤M2 if ∀π: M2(π) = > ∨M1(π) ⊆M2(π) Let φ be a T Rev formula, and P a program. M is a minimal model of φ (resp. P ) if M is a model of φ (resp. P ) and M ≤M ′ for every model M ′ of φ (resp. P ).\nThus, to know if a formula succeeds in a particular path, we need only to consider the event occurrences supported by that path, either because they appear as occurrences in the transition of states, or because they are a necessary consequence of the program’s rules given that path. Because of this, executional entailment in T Rev is defined w.r.t. minimal models (cf. Def. 5).\nDefinition 11 (T Rev Executional Entailment) Let P be a program, φ a transaction formula and D1 O0→ . . . On→ Dn a path. Then P, (D1 O0→ . . .On→Dn) |= φ (?) iff for every minimal model M of P , M, 〈D1O0→ . . .On→Dn〉 |= φ. P,D1– |= φ is said to be true, if there is a path D1O0→ . . .On→Dn that makes (?) true.\nInterestingly, as in logic programs, formulas satisfied by this entailment have some support.\nLemma 1 (Support) Let P be a program, π a path, φ a transaction atom. Then, if P, π |= φ one of the following holds:\n1. φ is an elementary action and either φ ∈ Od(π) or φ ∈ Ot(π); 2. φ is the head of a transaction rule in P (φ← body) and P, π |= body;\nAs expected, T Rev extends T R. Precisely, if a program P has no complex event rules, and for every elementary action a defined by the oracles the only rule for r(a) in P is r(a)← true, then executional entailment in T Rev can be recast in T R if, T R executional entailment is also restricted to minimal models. It is worth noting that, for a large class of T R theories, and namely for the so-called serial-Horn theories, executional entailment in general coincides with that only using minimal models (cf. (Bonner and Kifer 1993)). As an immediate corollary, it follows that if P is event-free and serial-Horn, then executional entailment in T Rev and in T R coincide."
    }, {
      "heading" : "4 Discussion and Related Work",
      "text" : "Several solutions exist to reason about complex events. Complex event processing (CEP) systems as (Adaikkalavan and Chakravarthy 2004; Wu et al. 2006) can reason efficiently with large streams of data and detect (complex) events. These support a rich specification of events based on event pattern rules combining atomic events with some temporal constructs. As shown in Theorem 1, T R and T Rev can express most event patterns of SNOOP and, ETALIS (Anicic et al. 2012) CEP system even uses T R’s syntax and connectives, although abandoning T R’s model theory and providing a different satisfaction definition. However, in contrast to T Rev , CEP systems do not deal with the execution of actions in reaction to the events detected.\nExtensions of Situation Calculus, Event Calculus, Action Languages, etc. exist with the ability to react to events, and have some transactional properties (Baral et al. 1997; Bertossi et al. 1998).\nHowever, as in database triggers, these events are restricted to detect simple actions like “on insert/delete” and thus have a very limited expressivity that fails to encode complex events, as defined in CEP systems and in T Rev . To simultaneously reason about actions and complex events, ECA (following the syntax “on event if condition do action”) languages (Alferes et al. 2011; Bry et al. 2006; Chomicki et al. 2003) and logic programming based languages (Kowalski and Sadri 2012; Costantini and Gasperis 2012) exist. These languages normally do not allow the action component of the language to be defined as a transaction, and when they do, they lack from a declarative semantics as (Papamarkos et al. 2006); or they are based on active databases and can only detect atomic events defined as insertions/deletes (Zaniolo 1995; Lausen et al. 1998).\nIn contrast, T Rev can deal with arbitrary atomic and complex events, and make these events trigger transactions. This is done by a logic-programming like declarative language. We have also defined a procedure to execute these reactive transactions, which is built upon the complex event detection algorithm of ETALIS and the execution algorithm of T R, but is omitted for lack of space."
    } ],
    "references" : [ {
      "title" : "Formalization and detection of events over a sliding window in active databases using interval-based semantics",
      "author" : [ "R. ADAIKKALAVAN", "S. CHAKRAVARTHY" ],
      "venue" : "ADBIS",
      "citeRegEx" : "ADAIKKALAVAN and CHAKRAVARTHY,? \\Q2004\\E",
      "shortCiteRegEx" : "ADAIKKALAVAN and CHAKRAVARTHY",
      "year" : 2004
    }, {
      "title" : "Snoopib: Interval-based event specification and detection for active databases",
      "author" : [ "R. ADAIKKALAVAN", "S. CHAKRAVARTHY" ],
      "venue" : "Data Knowl. Eng. 59,",
      "citeRegEx" : "ADAIKKALAVAN and CHAKRAVARTHY,? \\Q2006\\E",
      "shortCiteRegEx" : "ADAIKKALAVAN and CHAKRAVARTHY",
      "year" : 2006
    }, {
      "title" : "Evolving reactive logic programs",
      "author" : [ "J.J. ALFERES", "F. BANTI", "A. BROGI" ],
      "venue" : "Intelligenza Artificiale",
      "citeRegEx" : "ALFERES et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "ALFERES et al\\.",
      "year" : 2011
    }, {
      "title" : "Stream reasoning and complex event processing in etalis",
      "author" : [ "D. ANICIC", "S. RUDOLPH", "P. FODOR", "N. STOJANOVIC" ],
      "venue" : "Semantic Web",
      "citeRegEx" : "ANICIC et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "ANICIC et al\\.",
      "year" : 2012
    }, {
      "title" : "On the decidability of the termination problem of active database systems",
      "author" : [ "J. BAILEY", "G. DONG", "K. RAMAMOHANARAO" ],
      "venue" : "Theor. Comput. Sci. 311,",
      "citeRegEx" : "BAILEY et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "BAILEY et al\\.",
      "year" : 2004
    }, {
      "title" : "Formal characterizations of active databases: Part ii",
      "author" : [ "C. BARAL", "J. LOBO", "G. TRAJCEVSKI" ],
      "venue" : "In DOOD. LNCS,",
      "citeRegEx" : "BARAL et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "BARAL et al\\.",
      "year" : 1997
    }, {
      "title" : "Specifying active databases in the situation calculus",
      "author" : [ "L.E. BERTOSSI", "J. PINTO", "R. VALDIVIA" ],
      "venue" : "In SCCC. IEEE Computer Society,",
      "citeRegEx" : "BERTOSSI et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "BERTOSSI et al\\.",
      "year" : 1998
    }, {
      "title" : "Transaction logic programming",
      "author" : [ "A.J. BONNER", "M. KIFER" ],
      "venue" : "In ICLP",
      "citeRegEx" : "BONNER and KIFER,? \\Q1993\\E",
      "shortCiteRegEx" : "BONNER and KIFER",
      "year" : 1993
    }, {
      "title" : "Results on reasoning about updates in transaction logic",
      "author" : [ "A.J. BONNER", "M. KIFER" ],
      "venue" : "In Transactions and Change in Logic Databases",
      "citeRegEx" : "BONNER and KIFER,? \\Q1998\\E",
      "shortCiteRegEx" : "BONNER and KIFER",
      "year" : 1998
    }, {
      "title" : "Database programming in transaction logic",
      "author" : [ "A.J. BONNER", "M. KIFER", "M.P. CONSENS" ],
      "venue" : "In DBPL",
      "citeRegEx" : "BONNER et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "BONNER et al\\.",
      "year" : 1993
    }, {
      "title" : "Reactivity on the web: Paradigms and applications of the language xchange",
      "author" : [ "F. BRY", "M. ECKERT", "PATRANJAN", "P.-L" ],
      "venue" : "J. Web Eng",
      "citeRegEx" : "BRY et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "BRY et al\\.",
      "year" : 2006
    }, {
      "title" : "Conflict resolution using logic programming",
      "author" : [ "J. CHOMICKI", "J. LOBO", "S.A. NAQVI" ],
      "venue" : "IEEE Trans. Knowl. Data Eng",
      "citeRegEx" : "CHOMICKI et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "CHOMICKI et al\\.",
      "year" : 2003
    }, {
      "title" : "Complex reactivity with preferences in rule-based agents",
      "author" : [ "S. COSTANTINI", "G.D. GASPERIS" ],
      "venue" : "In RuleML",
      "citeRegEx" : "COSTANTINI and GASPERIS,? \\Q2012\\E",
      "shortCiteRegEx" : "COSTANTINI and GASPERIS",
      "year" : 2012
    }, {
      "title" : "A logic-based framework for reactive systems",
      "author" : [ "R.A. KOWALSKI", "F. SADRI" ],
      "venue" : "In RuleML",
      "citeRegEx" : "KOWALSKI and SADRI,? \\Q2012\\E",
      "shortCiteRegEx" : "KOWALSKI and SADRI",
      "year" : 2012
    }, {
      "title" : "On active deductive databases: The statelog approach",
      "author" : [ "G. LAUSEN", "B. LUDÄSCHER", "MAY" ],
      "venue" : "In Transactions and Change in Logic Databases",
      "citeRegEx" : "LAUSEN et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "LAUSEN et al\\.",
      "year" : 1998
    }, {
      "title" : "Event-condition-action rules on rdf metadata in p2p environments",
      "author" : [ "G. PAPAMARKOS", "A. POULOVASSILIS", "P.T. WOOD" ],
      "venue" : "Comp. Networks",
      "citeRegEx" : "PAPAMARKOS et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "PAPAMARKOS et al\\.",
      "year" : 2006
    }, {
      "title" : "High-performance complex event processing over streams",
      "author" : [ "E. WU", "Y. DIAO", "S. RIZVI" ],
      "venue" : "In SIGMOD Conference",
      "citeRegEx" : "WU et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "WU et al\\.",
      "year" : 2006
    }, {
      "title" : "Active database rules with transaction-conscious stable-model semantics. In DOOD",
      "author" : [ "Ana Sofia Gomes", "C. José Júlio Alferes ZANIOLO" ],
      "venue" : null,
      "citeRegEx" : "Gomes and ZANIOLO,? \\Q1995\\E",
      "shortCiteRegEx" : "Gomes and ZANIOLO",
      "year" : 1995
    } ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "This work deals with the problem of combining reactive features, such as the ability to respond to events and define complex events, with the execution of transactions over general Knowledge Bases (KBs). With this as goal, we build on Transaction Logic (T R), a logic precisely designed to model and execute transactions in KBs defined by arbitrary logic theories. In it, transactions are written in a logic-programming style, by combining primitive update operations over a general KB, with the usual logic programming connectives and some additional connectives e.g. to express sequence of actions. While T R is a natural choice to deal with transactions, it remains the question whether T R can be used to express complex events, but also to deal simultaneously with the detection of complex events and the execution of transactions. In this paper we show that the former is possible while the latter is not. For that, we start by illustrating how T R can express complex events, and in particular, how SNOOP event expressions can be translated in the logic. Afterwards, we show why T R fails to deal with the two issues together, and to solve the intended problem propose Transaction Logic with Events, its syntax, model theory and executional semantics. The achieved solution is a non-monotonic extension of T R, which guarantees that every complex event detected in a transaction is necessarily responded. To appear in Theory and Practice of Logic Programming (TPLP)",
    "creator" : "LaTeX with hyperref package"
  }
}