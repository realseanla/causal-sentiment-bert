{
  "name" : "1701.04113.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Near Optimal Behavior via Approximate State Abstraction",
    "authors" : [ "David Abel", "D. Ellis Hershkowitz", "Michael L. Littman" ],
    "emails" : [ "abel@brown.edu", "dhershko@cs.cmu.edu", "mlittman@cs.brown.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Abstraction plays a fundamental role in learning. Through abstraction, intelligent agents may reason about only the salient features of their environment while ignoring what is irrelevant. Consequently, agents are able to solve considerably more complex problems than they would be able to without the use of abstraction. However, exact abstractions, which treat only fully-identical situations as equivalent, require complete knowledge that is computationally intractable to obtain. Furthermore, often no two situations are identical, so exact abstractions are often ineffective. To overcome these issues, we investigate approximate abstractions that enable agents to treat sufficiently similar situations as identical. This work characterizes the impact of equating “sufficiently similar” states in the context of planning and RL in Markov Decision Processes (MDPs). The remainder of our introduction contextualizes these intuitions in MDPs.\nRL\nSolution to Abstracted Problem, MA\nBounded Error\n(MG)\nTrue Problem, MG Abstracted Problem, MA\nAbstraction,\nSt ar\nt G\noa l\nG oa l St ar t\nFigure 1: We investigate families of approximate state abstraction functions that induce abstract MDP’s whose optimal policies have bounded value in the original MDP.\nA previous version of this paper was published in the Proceedings of the 33rd International Conference on Machine Learning, New York, NY, USA, 2016. JMLR: W&CP volume 48. Copyright 2016 by the author(s). †The first two authors contributed equally.\nar X\niv :1\n70 1.\n04 11\n3v 1\n[ cs\n.L G\n] 1\n5 Ja\nn 20\n17\nSolving for optimal behavior in MDPs in a planning setting is known to be P-Complete in the size of the state space [28, 25]. Similarly, many RL algorithms for solving MDPs are known to require a number of samples polynomial in the size of the state space [31]. Although polynomial runtime or sample complexity may seem like a reasonable constraint, the size of the state space of an MDP grows super-polynomially with the number of variables that characterize the domain - a result of Bellman’s curse of dimensionality. Thus, solutions polynomial in state space size are often ineffective for sufficiently complex tasks. For instance, a robot involved in a pick-and-place task might be able to employ planning algorithms to solve for how to manipulate some objects into a desired configuration in time polynomial in the number of states, but the number of states it must consider grows exponentially with the number of objects with which it is working [1].\nThus, a key research agenda for planning and RL is leveraging abstraction to reduce large state spaces [2, 21, 10, 12, 6]. This agenda has given rise to methods that reduce ground MDPs with large state spaces to abstract MDPs with smaller state spaces by aggregating states according to some notion of equality or similarity. In the context of MDPs, we understand exact abstractions as those that aggregate states with equal values of particular quantities, for example, optimal Q-values. Existing work has characterized how exact abstractions can fully maintain optimality in MDPs [24, 8].\nThe thesis of this work is that performing approximate abstraction in MDPs by relaxing the state aggregation criteria from equality to similarity achieves polynomially bounded error in the resulting behavior while offering three benefits. First, approximate abstractions employ the sort of knowledge that we expect a planning or learning algorithm to compute without fully solving the MDP. In contrast, exact abstractions often require solving for optimal behavior, thereby defeating the purpose of abstraction. Second, because of their relaxed criteria, approximate abstractions can achieve greater degrees of compression than exact abstractions. This difference is particularly important in environments where no two states are identical. Third, because the state aggregation criteria are relaxed to near equality, approximate abstractions are able to tune the aggressiveness of abstraction by adjusting what they consider sufficiently similar states.\nWe support this thesis by describing four different types of approximate abstraction functions that preserve near-optimal behavior by aggregating states on different criteria: φ̃Q∗,ε, on similar optimal Q-values, φ̃model,ε, on similarity of rewards and transitions, φ̃bolt,ε, on similarity of a Boltzmann distribution over optimal Q-values, and φ̃mult,ε, on similarity of a multinomial distribution over optimal Q-values. Furthermore, we empirically demonstrate the relationship between the degree of compression and error incurred on a variety of MDPs.\nThis paper is organized as follows. In the next section, we introduce the necessary terminology and background of MDPs and state abstraction. Section 3 surveys existing work on state abstraction applied to sequential decision making. Section 5 introduces our primary result; bounds on the error guaranteed by four classes of approximate state abstraction. The following two sections introduce simulated domains used in experiments (Section 6), and a discussion of experiments in which we apply one class of approximate abstraction to a variety of different tasks to empirically illustrate the relationship between degree of compression and error incurred (Section 7)."
    }, {
      "heading" : "2 MDPs and Sequential Decision Making",
      "text" : "An MDP is a problem representation for sequential decision making agents, represented by a five-tuple: 〈S,A, T ,R, γ〉. Here, S is a finite state space; A is a finite set of actions available to the agent; T denotes T (s, a, s′), the probability of an agent transitioning to state s′ ∈ S after applying action a ∈ A in state s ∈ S; R(s, a) denotes the reward received by the agent for executing action a in state s; γ ∈ [0, 1] is a discount factor that determines how much the agent prefers future rewards over immediate rewards. We assume without loss of generality that the range of all reward functions is normalized to [0, 1]. The solution to an MDP is called a policy, denoted π : S 7→ A.\nThe objective of an agent is to solve for the policy that maximizes its expected discounted reward from any state, denoted π∗. We denote the expected discounted reward for following policy π from state s as the value of the state under that policy, V π(s). We similarly denote the expected discounted reward for taking\naction a ∈ A and then following policy π from state s forever after as Qπ(s, a), defined by the Bellman Equation as:\nQπ(s, a) = R(s, a) + γ ∑ s′ T (s, a, s′)Qπ(s′, π(s′)). (1)\nWe let RMax denote the maximum reward (which is 1), and QMax denote the maximum Q value, which is RMax1−γ . The value function, V , defined under a given policy, denoted V π(s), is defined as:\nV π(s) = Qπ(s, π(s)). (2)\nLastly, we denote the value and Q functions under the optimal policy as V ∗ or V π ∗ and Q∗ or Qπ ∗ , respectively. For further background, see Kaelbling et al. [22]."
    }, {
      "heading" : "3 Related Work",
      "text" : "Several other projects have addressed similar topics."
    }, {
      "heading" : "3.1 Approximate State Abstraction",
      "text" : "Dean et al. [9] leverage the notion of bisimulation to investigate partitioning an MDP’s state space into clusters of states whose transition model and reward function are within ε of each other. They develop an algorithm called Interval Value Iteration (IVI) that converges to the correct bounds on a family of abstract MDPs called Bounded MDPs.\nSeveral approaches build on Dean et al. [9]. Ferns et al. [14, 15] investigated state similarity metrics for MDPs; they bounded the value difference of ground states and abstract states for several bisimulation metrics that induce an abstract MDP. This differs from our work which develops a theory of abstraction that bounds the suboptimality of applying the optimal policy of an abstract MDP to its ground MDP, covering four types of state abstraction, one of which closely parallels bisimulation. Even-Dar and Mansour [13] analyzed different distance metrics used in identifying state space partitions subject to ε-similarity, also providing value bounds (their Lemma 4) for ε-homogeneity subject to the L∞ norm, which parallels our Claim 2. Ortner [27] developed an algorithm for learning partitions in an online setting by taking advantage of the confidence bounds for T and R provided by UCRL [3].\nHutter [18, 17] investigates state aggregation beyond the MDP setting. Hutter presents a variety of results for aggregation functions in reinforcement learning. Most relevant to our investigation is Hutter’s Theorem 8, which illustrates properties of aggregating states based on similar Q values. Hutter’s Theorem part (a) parallels our Claim: both bound the value difference between ground and abstraction states, and part (b) is analogous to our Lemma 1: both bound the value difference of applying the optimal abstraction policy in the ground, and part (c) is a repetition of the comment given by Li et al. [24] that Q∗ abstractions preserve the optimal value function. For Lemma 1, our proof strategies differ from Hutter’s, but the result is the same.\nApproximate state abstraction has also been applied to the planning problem, in which the agent is given a model of its environment and must compute a plan that satisfies some goal. Hostetler et al. [16] apply state abstraction to Monte Carlo Tree Search and expectimax search, giving value bounds of applying the optimal abstract action in the ground tree(s), similarly to our setting. Dearden and Boutilier [10] also formalize stateabstraction for planning, focusing on abstractions that are quickly computed and offer bounded value. Their primary analysis is on abstractions that remove negligible literals from the planning domain description, yielding value bounds for these abstractions and a means of incrementally improving abstract solutions to planning problems. Jiang et al. [20] analyze a similar setting, applying abstractions to the Upper Confidence Bound applied to Trees algorithm adapted for planning, introduced by Kocsis and Szepesvári [23].\nMandel et al. [26] advance Bayesian aggregation in RL to define Thompson Clustering for Reinforcement Learning (TCRL), an extension of which achieves near-optimal Bayesian regret bounds. Jiang [19] analyze the problem of choosing between two candidate abstractions. They develop an algorithm based on statistical\ntests that trades of the approximation error with the estimation error of the two abstractions, yielding a loss bound on the quality of the chosen policy."
    }, {
      "heading" : "3.2 Specific Abstraction Algorithms",
      "text" : "Many previous works have targeted the creation of algorithms that enable state abstraction for MDPs. Andre and Russell [2] investigated a method for state abstraction in hierarchical reinforcement learning leveraging a programming language called ALISP that promotes the notion of safe state abstraction. Agents programmed using ALISP can ignore irrelevant parts of the state, achieving abstractions that maintain optimality. Dietterich [12] developed MAXQ, a framework for composing tasks into an abstracted hierarchy where state aggregation can be applied. Bakker and Schmidhuber [4] also target hierarchical abstraction, focusing on subgoal discovery. Jong and Stone [21] introduced a method called policy-irrelevance in which agents identify (online) which state variables may be safely abstracted away in a factored-state MDP. Dayan and Hinton [7] develop “Feudal Reinforcement Learning” which presents an early form of hierarchical RL that restructures Q-Learning to manage the decomposition of a task into subtasks. For a more complete survey of algorithms that leverage state abstraction in past reinforcement-learning papers, see Li et al. [24], and for a survey of early works on hierarchical reinforcement learning, see Barto and Mahadevan [5]."
    }, {
      "heading" : "3.3 Exact Abstraction Framework",
      "text" : "Li et al. [24] developed a framework for exact state abstraction in MDPs. In particular, the authors defined five types of state aggregation functions, inspired by existing methods for state aggregation in MDPs. We generalize two of these five types, φQ∗ and φmodel, to the approximate abstraction case. Our generalizations are equivalent to theirs when exact criteria are used (i.e. ε = 0). Additionally, when exact criteria are used our bounds indicate that no value is lost, which is one of core results of Li et al. [24]. Walsh et al. [34] build on the framework they previously developed by showing empirically how to transfer abstractions between structurally related MDPs."
    }, {
      "heading" : "4 Abstraction Notation",
      "text" : "We build upon the notation used by Li et al. [24], who introduced a unifying theoretical framework for state abstraction in MDPs.\nDefinition 1 (MG, MA): We understand an abstraction as a mapping from the state space of a ground MDP, MG, to that of an abstract MDP, MA, using a state aggregation scheme. Consequently, this mapping induces an abstract MDP. Let MG = 〈SG,A, TG,RG, γ〉 and MA = 〈SA,A, TA,RA, γ〉.\nDefinition 2 (SA, φ): The states in the abstract MDP are constructed by applying a state aggregation function, φ, to the states in the ground MDP, SA. More specifically, φ maps a state in the ground MDP to a state in the abstract MDP:\nSA = {φ(s) | s ∈ SG}. (3)\nDefinition 3 (G): Given a φ, each ground state has associated with it the ground states with which it is aggregated. Similarly, each abstract state has its constituent ground states. We let G be the function that retrieves these states:\nG(s) = { {g ∈ SG | φ(g) = φ(s)}, if s ∈ SG, {g ∈ SG | φ(g) = s}, if s ∈ SA.\n(4)\nThe abstract reward function and abstract transition dynamics for each abstract state are a weighted combination of the rewards and transitions for each ground state in the abstract state.\nDefinition 4 (ω(s)): We refer to the weight associated with a ground state, s ∈ SG by ω(s). The only restriction placed on the weighting scheme is that it induces a probability distribution on the ground states of each abstract state:\n∀s ∈ SG  ∑ s∈G(s) ω(s)  = 1 AND ω(s) ∈ [0, 1]. (5) Definition 5 (RA): The abstract reward function RA : SA ×A 7→ [0, 1] is a weighted sum of the rewards of each of the ground states that map to the same abstract state:\nRA(s, a) = ∑\ng∈G(s)\nRG(g, a)ω(g). (6)\nDefinition 6 (TA): The abstract transition function TA : SA × A × SA 7→ [0, 1] is a weighted sum of the transitions of each of the ground states that map to the same abstract state:\nTA(s, a, s′) = ∑\ng∈G(s) ∑ g′∈G(s′) TG(g, a, g′)ω(g). (7)"
    }, {
      "heading" : "5 Approximate State Abstraction",
      "text" : "Here, we introduce our formal analysis of approximate state abstraction, including results bounding the error associated with these abstraction methods. In particular, we demonstrate that abstractions based on approximate Q∗ similarity (5.2), approximate model similarity (5.3), and approximate similarity between distributions over Q∗, for both Boltzmann (5.4) and multinomial (5.5) distributions induce abstract MDPs for which the optimal policy has bounded error in the ground MDP.\nWe first introduce some additional notation.\nDefinition 7 (π∗A, π ∗ G): We let π ∗ A : SA → A and π∗G : SG → A stand for the optimal policies in the abstract and ground MDPs, respectively.\nWe are interested in how the optimal policy in the abstract MDP performs in the ground MDP. As such, we formally define the policy in the ground MDP derived from optimal behavior in the abstract MDP:\nDefinition 8 (πGA): Given a state s ∈ SG and a state aggregation function, φ,\nπGA(s) = π ∗ A(φ(s)). (8)\nWe now define types of abstraction based on functions of state–action pairs.\nDefinition 9 (φ̃f,ε): Given a function f : SG ×A → R and a fixed non-negative ε ∈ R, we define φ̃f,ε as a type of approximate state aggregation function that satisfies the following for any two ground states s1, s2:\nφ̃f,ε(s1) = φ̃f,ε(s2)→ ∀a |f(s1, a)− f(s2, a)| ≤ ε. (9)\nThat is, when φ̃f,ε aggregates states, all aggregated states have values of f within ε of each other for all actions.\nFinally, we estliabsh notation to distinguish between the ground and abstract value (V ) and action value (Q) functions. Definition 10 (QG, VG): Let QG = Q π∗G : SG ×A → R and VG = V π ∗ G : SG → R denote the optimal Q and optimal value functions in the ground MDP. Definition 11 (QA, VA): Let QA = Q π∗A : SA ×A → R and VA = V π ∗ A : SA → R stand for the optimal Q and optimal value functions in the abstract MDP."
    }, {
      "heading" : "5.1 Main Result",
      "text" : "We now introduce the main result of the paper.\nTheorem 1. There exist at least four types of approximate state aggregation functions, φ̃Q∗,ε, φ̃model,ε, φ̃bolt,ε and φ̃mult,ε, for which the optimal policy in the abstract MDP, applied to the ground MDP, has suboptimality bounded polynomially in ε:\n∀s∈SGV π∗G G (s)− V πGA G (s) ≤ 2εηf (10)\nWhere ηf differs between abstraction function families:\nηQ∗ = 1\n(1− γ)2\nηmodel = 1 + γ (|SG| − 1)\n(1− γ)3\nηbolt =\n( |A| 1−γ + εkbolt + kbolt ) (1− γ)2\nηmult =\n( |A| 1−γ + kmult ) (1− γ)2\nFor ηbolt and ηmult, we also assume that the difference in the normalizing terms of each distribution is bounded by some non-negative constant, kmult, kbolt ∈ R, of ε:∣∣∣∣∣∣ ∑ i QG(s1, ai)− ∑ j QG(s2, aj) ∣∣∣∣∣∣ ≤ kmult × ε∣∣∣∣∣∣ ∑ i eQG(s1,ai) − ∑ j eQG(s2,aj)\n∣∣∣∣∣∣ ≤ kbolt × ε Naturally, the value bound of Equation 10 is meaningless for 2εηf ≥ RMax1−γ = 1 1−γ , since this is the maximum possible value in any MDP (and we assumed the range of R is [0, 1]). In light of this, observe that for ε = 0, all of the above bounds are exactly 0. Any value of ε interpolated between these two points achieves different degrees of abstraction, with different degrees of bounded loss.\nWe now introduce each approximate aggregation family and prove the theorem by proving the specific value bound for each function type."
    }, {
      "heading" : "5.2 Optimal Q Function: φ̃Q∗,ε",
      "text" : "We consider an approximate version of Li et al. [24]’s φQ∗ . In our abstraction, states are aggregated together when their optimal Q-values are within ε.\nDefinition 12 (φ̃Q∗,ε): An approximate Q function abstraction has the same form as Equation 9:\nφ̃Q∗,ε(s1) = φ̃Q∗,ε(s2)→ ∀a |QG(s1, a)−QG(s2, a)| ≤ ε. (11)\nLemma 1. When a φ̃Q∗,ε type abstraction is used to create the abstract MDP:\n∀s∈SGV π∗G G (s)− V πGA G (s) ≤\n2ε\n(1− γ)2 . (12)\nProof of Lemma 1: We first demonstrate that Q-values in the abstract MDP are close to Q-values in the ground MDP (Claim 1). We next leverage Claim 1 to demonstrate that the optimal action in the abstract MDP is nearly optimal in the ground MDP (Claim 2). Lastly, we use Claim 2 to conclude Lemma 1 (Claim 3).\nClaim 1. Optimal Q-values in the abstract MDP closely resemble optimal Q-values in the ground MDP:\n∀sG∈SG,a|QG(sG, a)−QA(φ̃Q∗,ε(sG), a)| ≤ ε\n1− γ . (13)\nConsider a non-Markovian decision process of the same form as an MDP, MT = 〈ST ,AG,RT , TT , γ〉, parameterized by integer an T , such that for the first T time steps the reward function, transition dynamics and state space are those of the abstract MDP, MA, and after T time steps the reward function, transition dynamics and state spaces are those of MG. Thus,\nST = { SG if T = 0 SA o/w\nRT (s, a) = { RG(s, a) if T = 0 RA(s, a) o/w\nTT (s, a, s′) =  TG(s, a, s′) if T = 0∑ g∈G(s) [TG(g, a, s′)ω(g)] if T = 1\nTA(s, a, s′) o/w\nThe Q-value of state s in ST for action a is:\nQT (s, a) =  QG(s, a) if T = 0∑ g∈G(s) [QG(g, a)ω(g)] if T = 1\nRA(s, a) + σT−1(s, a) o/w\n(14)\nwhere: σT−1(s, a) = γ ∑ sA′∈SA TA(s, a, sA′) max a′ QT−1(sA ′, a′).\nWe proceed by induction on T to show that:\n∀T,sG∈SG,a|QT (sT , a)−QG(sG, a)| ≤ T−1∑ t=0 εγt, (15)\nwhere sT = sG if T = 0 and sT = φ̃Q∗,ε(sG) otherwise.\nBase Case: T = 0\nWhen T = 0, QT = QG, so this base case trivially follows.\nBase Case: T = 1\nBy definition of QT , we have that Q1 is Q1(s, a) = ∑\ng∈G(s)\n[QG(g, a)ω(g)] .\nSince all co-aggregated states have Q-values within ε of one another and ω(g) induces a convex combination,\nQ1(sT , a) ≤ εγt + ε+QG(sG, a)\n∴ |Q1(sT , a)−QG(sG, a)| ≤ 1∑ t=0 εγt.\nInductive Case: T > 1\nWe assume as our inductive hypothesis that:\n∀sG∈SG,a|QT−1(sT , a)−QG(sG, a)| ≤ T−2∑ t=0 εγt.\nConsider a fixed but arbitrary state, sG ∈ SG, and fixed but arbitrary action a. Since T > 1, sT is φ̃Q∗,ε(sG). By definition of QT (sT , a), RA, TA:\nQT (sT , a) = ∑\ng∈G(sT )\nω(g) × RG(g, a) + γ ∑ g′∈SG TG(g, a, g′) max a′ QT−1(g ′, a′)  . Applying our inductive hypothesis yields:\nQT (sT , a) ≤ ∑\ng∈G(sT )\nω(g)× [ RG(g, a) + γ ∑ g′∈SG TG(g, a, g ′) max a′ (QG(g ′, a′) + T−2∑ t=0 εγt) ] .\nSince all aggregated states have Q-values within ε of one another:\nQT (sT , a) ≤ γ T−2∑ t=0 εγt + ε+QG(sG, a).\nSince sG is arbitrary we conclude Equation 15. As T →∞, ∑T−1 t=0 εγ\nt → ε1−γ by the sum of infinite geometric series and QT → QA. Thus, Equation 15 yields Claim 1.\nClaim 2. Consider a fixed but arbitrary state, sG ∈ SG and its corresponding abstract state sA = φ̃Q∗,ε(sG). Let a∗G stand for the optimal action in sG, and a ∗ A stand for the optimal action in sA:\na∗G = arg max a QG(sG, a), a ∗ A = arg max a QA(sA, a).\nThe optimal action in the abstract MDP has a Q-value in the ground MDP that is nearly optimal:\nVG(sG) ≤ QG(sG, a∗A) + 2ε\n1− γ . (16)\nBy Claim 1,\nVG(sG) = QG(sG, a ∗ G) ≤ QA(sA, a∗G) +\nε\n1− γ . (17)\nBy the definition of a∗A, we know that\nQA(sA, a ∗ G) +\nε\n1− γ ≤ QA(sA, a∗A) +\nε\n1− γ . (18)\nLastly, again by Claim 1, we know\nQA(sA, a ∗ A) +\nε\n1− γ ≤ QG(sg, a∗A) +\n2ε\n1− γ . (19)\nTherefore, Equation 16 follows.\nClaim 3. Lemma 1 follows from Claim 2.\nConsider the policy for MG of following the optimal abstract policy π ∗ A for t steps and then following the optimal ground policy π∗G in MG:\nπA,t(s) =\n{ π∗G(s) if t = 0\nπGA(s) if t > 0 (20)\nFor t > 0, the value of this policy for sG ∈ SG in the ground MDP is:\nV πA,t G (sG) = RG(s, πA,t(sG)) + γ ∑ sG′∈SG TG(sG, a, sG′)V πA,t−1 G (sG ′).\nFor t = 0, V πA,t G (sG) is simply VG(sG). We now show by induction on t that\n∀t,sG∈SgVG(sG) ≤ V πA,t G (sG) + t∑ i=0 γi 2ε 1− γ . (21)\nBase Case: t = 0\nBy definition, when t = 0, V πA,t G = VG, so our bound trivially holds in this case.\nInductive Case: t > 0\nConsider a fixed but arbitrary state sG ∈ SG. We assume for our inductive hypothesis that\nVG(sG) ≤ V πA,t−1 G (sG) + t−1∑ i=0 γi 2ε 1− γ . (22)\nBy definition,\nV πA,t G (sG) = RG(s, πA,t(sG)) + γ ∑ g′ TG(sG, a, sG′)V πA,t−1 G (sG ′).\nApplying our inductive hypothesis yields:\nV πA,t G (sG) ≥ RG(sG, πA,t(sG)) + γ ∑ sG′ TG(sG, πA,t(sG), sG′)\n( VG(sG\n′)− t−1∑ i=0 γi 2ε 1− γ\n) .\nTherefore,\nV πA,t G (sG) ≥ −γ t−1∑ i=0 γi 2ε 1− γ +QG(sG, πA,t(sG)).\nApplying Claim 2 yields:\nV πA,t G (sG) ≥ −γ t−1∑ i=0 γi 2ε 1− γ − 2ε 1− γ + VG(sG)\n∴ VG(sG) ≤ V πA,t G (sG) + t∑ i=0 γi 2ε 1− γ .\nSince sG was arbitrary, we conclude that our bound holds for all states in SG for the inductive case. Thus, from our base case and induction, we conclude that\n∀t,sG∈SgV π∗G G (sG) ≤ V πA,t G (sG) + t∑ i=0 γi 2ε 1− γ . (23)\nNote that as t→∞, ∑t i=0 γ i 2ε 1−γ → 2ε (1−γ)2 by the sum of infinite geometric series and πA,t(s)→ πGA. Thus, we conclude Lemma 1."
    }, {
      "heading" : "5.3 Model Similarity: φ̃model,ε",
      "text" : "Now, consider an approximate version of Li et al. [24]’s φmodel, where states are aggregated together when their rewards and transitions are within ε.\nDefinition 13 (φ̃model,ε): We let φ̃model,ε define a type of abstraction that, for fixed ε, satisfies:\nφ̃model,ε(s1) = φ̃model,ε(s2)→\n∀a |RG(s1, a)−RG(s2, a)| ≤ ε AND ∀sA∈SA ∣∣∣∣∣∣ ∑\nsG′∈G(sA)\n[TG(s1, a, sG′)− TG(s2, a, sG′)] ∣∣∣∣∣∣ ≤ ε. (24) Lemma 2. When SA is created using a φ̃model,ε type:\n∀s∈SGV π∗G G (s)− V πGA G (s) ≤ 2ε+ 2γε (|SG| − 1) (1− γ)3 . (25)\nProof of Lemma 2:\nLet B be the maximum Q-value difference between any pair of ground states in the same abstract state for φ̃model,ε:\nB = max s1,s2,a\n|QG(s1, a)−QG(s2, a)|,\nwhere s1, s2 ∈ G(sA). First, we expand:\nB = max s1,s2,a ∣∣∣∣RG(s1, a)−RG(s2, a) + γ ∑ sG′∈SG [ (TG(s1, a, sG′)− TG(s2, a, sG′)) max a′ QG(sG ′, a′) ]∣∣∣∣ (26) Since difference of rewards is bounded by ε:\nB ≤ ε+ γ ∑\nsA∈SA ∑ sG′∈G(sA) [ (TG(s1, a, sG ′) − TG(s2, a, sG′)) max a′ QG(sG ′, a′) ] . (27)\nBy similarity of transitions under φ̃model,ε: B ≤ ε+ γQMax ∑\nsA∈SA\nε ≤ ε+ γ|SG|εQMax.\nRecall that QMax = RMax1−γ , and we defined RMax = 1:\nB ≤ ε+ γ(|SG| − 1)ε 1− γ .\nSince the Q-values of ground states grouped under φ̃model,ε are strictly less than B, we can understand φ̃model,ε as a type of φ̃Q∗,B . Applying Lemma 1 yields Lemma 2."
    }, {
      "heading" : "5.4 Boltzmann over Optimal Q: φ̃bolt,ε",
      "text" : "Here, we introduce φ̃bolt,ε, which aggregates states with similar Boltzmann distributions on Q-values. This type of abstractions is appealing as Boltzmman distributions balance exploration and exploitation [32]. We\nfind this type particularly interesting for abstraction purposes as, unlike φ̃Q∗,ε, it allows for aggregation when Q-value ratios are similar but their magnitudes are different.\nDefinition 14 (φ̃bolt,ε): We let φ̃bolt,ε define a type of abstractions that, for fixed ε, satisfies:\nφ̃bolt,ε(s1) = φ̃bolt,ε(s2)→ ∀a ∣∣∣∣ eQG(s1,a)∑\nb e QG(s1,b) − e QG(s2,a)∑ b e QG(s2,b) ∣∣∣∣ ≤ ε. (28) We also assume that the difference in normalizing terms is bounded by some non-negative constant, kbolt ∈ R, of ε: ∣∣∣∣∣∑\nb eQG(s1,b) − ∑ b eQG(s2,b) ∣∣∣∣∣ ≤ kbolt × ε. (29) Lemma 3. When SA is created using a function of the φ̃bolt,ε type, for some non-negative constant k ∈ R:\n∀s∈SGV π∗G G (s)− V πGA G (s) ≤\n2ε ( |A| 1−γ + εkbolt + kbolt ) (1− γ)2 . (30)\nWe use the approximation for ex, with δ error:\nex = 1 + x+ δ ≈ 1 + x. (31)\nWe let δ1 denote the error in approximating e QG(s1,a) and δ2 denote the error in approximating e QG(s2,a).\nProof of Lemma 3:\nBy the approximation in Equation 31 and the assumption in Equation 29:∣∣∣∣∣∣∣∣∣ 1 +QG(s1, a) + δ1∑ j e QG(s1,aj) − 1 +QG(s2, a) + δ2∑ j e QG(s1,aj)±kε︸︷︷︸\na ∣∣∣∣∣∣∣∣∣ ≤ ε (32) Either term a is positive or negative. First suppose the former. It follows by algebra that:\n− ε ≤ 1 +QG(s1, a) + δ1∑ j e QG(s1,aj) − 1 +QG(s2, a) + δ2∑ j e QG(s1,aj) + εkbolt ≤ ε (33)\nMoving terms:\n− ε kε+∑ j eQG(s1,aj) − δ1 + δ2 ≤ εkbolt ( 1 +QG(s1, a) + δ1∑\nj e QG(s1,aj)\n) +QG(s1, a)−QG(s2, a) ≤\nε εkbolt +∑ j eQG(s1,aj) − δ1 + δ2 (34) When a is the negative case, it follows that:\n− ε ≤ 1 +QG(s1, a) + δ1∑ j e QG(s1,aj) − 1 +QG(s2, a) + δ2∑ j e QG(s1,aj) − εkbolt ≤ ε (35)\nBy similar algebra that yielded Equation 34:\n− ε −εkbolt +∑ j eQG(s1,aj) − δ1 + δ2 ≤ − kε ( 1 +QG(s1, a) + δ1∑\nj e QG(s1,aj)\n) +QG(s1, a)−QG(s2, a) ≤\nε εkbolt +∑ j eQG(s1,aj) − δ1 + δ2 (36) Combining Equation 34 and Equation 36 results in:\n|QG(s1, a)−QG(s2, a)| ≤ ε ( |A|\n1− γ + εkbolt + kbolt\n) . (37)\nConsequently, we can consider φ̃bolt,ε as a special case of the φ̃Q∗,B type, where B = ε ( |A| 1−γ + εkbolt + kbolt ) . Lemma 3 then follows from Lemma 1."
    }, {
      "heading" : "5.5 Multinomial over Optimal Q: φ̃mult,ε",
      "text" : "We consider approximate abstractions derived from a multinomial distribution over Q∗ for similar reasons to the Boltzmann distribution. Additionally, the multinomial distribution is appealing for its simplicity.\nDefinition 15 (φ̃mult,ε): We let φ̃mult,ε define a type of abstraction that, for fixed ε, satisfies φ̃mult,ε(s1) = φ̃mult,ε(s2)→ ∀a ∣∣∣∣ QG(s1, a)∑\nbQG(s1, b) − QG(s1, a)∑ bQG(s1, b) ∣∣∣∣ ≤ ε. (38) We also assume that the difference in normalizing terms is bounded by some non-negative constant, kmult ∈ R, of ε: ∣∣∣∣∣∣ ∑ i QG(s1, ai)− ∑ j QG(s2, aj)\n∣∣∣∣∣∣ ≤ kmult × ε. (39) Lemma 4. When SA is created using a function of the φ̃mult,ε type, for some non-negative constant kmult ∈ R:\n∀s∈SMV π∗G G (s)− V πGA G (s) ≤\n2ε ( |A| 1−γ + kmult ) (1− γ)2\n(40) Proof of Lemma 4\nThe proof follows an identical strategy to that of Lemma 3, but without the approximation ex ≈ 1 + x."
    }, {
      "heading" : "6 Example Domains",
      "text" : "We apply approximate abstraction to five example domains—NChain, Upworld, Taxi, Minefield and Random. These domains were selected for their diversity—NChain is relatively simple, Upworld is particularly illustrative of the power of abstraction, Taxi is goal-based and hierarchical in nature, Minefield is stochastic, and Random MDP has many near-optimal policies.\nOur code base1 provides implementations for abstracting arbitrary MDPs as well as visualizing and evaluating the resulting abstract MDPs. We use the graph-visualization library GraphStream [29] and the planning and RL library, BURLAP2. For all experiments, we set γ to 0.95.\n1https://github.com/david-abel/state_abstraction 2http://burlap.cs.brown.edu/"
    }, {
      "heading" : "6.1 Visualizations",
      "text" : "We provide visuals of both the ground MDP and resulting abstract MDP for each domain. A grey circle indicates a state and colored arrows indicate transitions. The thickness of the arrow indicates how much reward is associated with that transition. In the ground MDPs, states are labeled with a number. In the abstract MDPs, we indicate which ground states were collapsed to each abstract state by labelling the abstract states with their ground states."
    }, {
      "heading" : "6.1.1 NChain",
      "text" : "NChain is a simple MDP investigated in the Bayesian RL literature due to the interesting exploration problem it poses [11]. In our implementation, we set N = 10, normalized rewards between 0 and 1, and used a slip probability of 0.2. An NChain instance (N = 10) and its abstraction are visualized in Figure6.1.2.\nIn all states, the agent has two actions available: advance down the chain, or return to state 0. The agent receives .2 reward for returning to state 0, and no reward for advancing down the chain. The exception is that when the agent transitions to the last state in the chain, it receives 1.0 reward. Transitions also have small slip probability ρ, such that the applied action results in the opposite dynamics. In our implementation, we set N = 10 and ρ = 0.2."
    }, {
      "heading" : "6.1.2 Upworld",
      "text" : "The Upworld task is an N ×M grid in which the agent starts in the lower left corner. The agent may move left, right, and up. The agent receives positive reward for transitioning to any state at the top of the grid, where moving up in the top cells self transitions. the agent receives 0 reward for all other transitions. Consequently, moving up is always the optimal action, since moving left and right does not change the agent’s manhattan distance to positive reward. During experimentation, we set N = 10, M = 4. An Upworld instance (N = 10, M = 4) and its abstraction are visualized in Figure6.1.2.\nUpworld illustrates a compelling property with respect to state abstraction: the optimal exact Q∗ abstraction function (when ε = 0) can always construct an abstract MDP with |SA| = N , the height of the grid, with no change in the value of the optimal policy. Consequently, letting M be arbitrarily large, Upworld offers an arbitrary reduction in the size of the MDP through abstraction, at no cost to the value of the optimal policy. This is a result of the property that all states in the same row have the same Q values:\nRemark: The optimal exact abstraction, φQ∗,0, induces an abstract MDP with an optimal policy of equal value to the true optimal policy, and reduces the size of the state space from N×M (ground) to N (abstract)."
    }, {
      "heading" : "6.1.3 Taxi",
      "text" : "Taxi has long been studied by the hierarchical RL literature [12]. The agent, operating in a Grid World style domain [30], may move left, right, up, and down, as well as pick up a passenger and drop off a passenger. The goal is achieved when the agent has taken all passengers to their destinations.\nWe visualize the compression on a simple 626 Taxi instance in Figure 3. As stated above, we visualize the original Taxi problem into a graph representation so that we may visualize both the ground MDP and abstract MDP in the same format, despite the unnatural appearance."
    }, {
      "heading" : "6.1.4 Minefield",
      "text" : "Minefield is a test problem we are introducing that uses the Grid World dynamics of Russell and Norvig [30] with slip probability of x. The reward function is such that moving up in the top row of the grid receives 1.0 reward; all other transitions receive 0.2 reward, except for transitions to a random set of κ mine-states (which may include the top row) that receive 0 reward. We set N = 10,M = 4, ε = 0.5, κ = 5, x = 0.01."
    }, {
      "heading" : "6.1.5 Random MDP",
      "text" : "In the Random MDP domain we consider, there are 100 states and 3 actions. For each state, each action transitions to one of two randomly selected states with probability 0.5. The Random MDP and its compression are visualized in Figure 4."
    }, {
      "heading" : "7 Empirical Results",
      "text" : "We ran experiments on the φ̃Q∗,ε type aggregation functions. We provide results for only φ̃Q∗,ε because, as our proofs in Section 5 demonstrate, the other three functions are reducible to particular φ̃Q∗,ε functions. For the purpose of illustrating what kinds of approximations are possible we built each abstraction by first solving the MDP, then greedily aggregating ground states into abstract states that satisfied the φ̃Q∗,ε criteria. Since this approach represents an order-dependent approximation to the maximum amount of abstraction possible, we randomized the order in which states were considered across trials. Every ground state is equally weighted in its abstract state.\nFor each domain, we report two quantities as a function of epsilon with 95% confidence bars. First, we compare the number of states in the abstract MDP for different values of ε, shown in the left column of Figure 5 and Figure 6. The smaller the number of abstract states, the smaller the state space of the MDP that the agent must plan over. Second, we report the value under the abstract policy of the initial ground state, also shown in the right column of Figure 5 and Figure 6. In the Taxi and Random domains, 200 trials were run for each data point, whereas 20 trials were sufficient in Upworld, Minefield, and NChain.\nOur empirical results corroborate our thesis—approximate state abstractions can decrease state space size while retaining bounded error. In both NChain and Minefield, we observe that, as ε increases from 0, the number of states that must be planned over is reduced, and optimal behavior is either fully maintained (NChain) or very nearly maintained (Minefield). Similarly for Taxi, when ε is between .02 and .025, we observe a reduction in the number of states in the abstract MDP while value is fully maintained. After .025, increased reduction in state space size comes at a cost of value. Lastly, as ε is increased in the Random domain, there is a smooth reduction in the number of abstract states with a corresponding cost in the value of the derived policy. When ε = 0, there is no reduction in state space size whatsoever (the ground MDP has 100 states), because no two states have identical optimal Q-values.\nOur experimental results also highlight a noteworthy characteristic of approximate state abstraction in goal-based MDPs. Taxi exhibits relative stability in state space size and behavior for ε up to .02, at which point both fall off dramatically. We attribute the sudden fall off of these quantities to the goal-based nature of the domain; once information critical for achieving optimal behavior is lost in the state aggregation,\nsolving the goal—and so acquiring any reward—is impossible. Conversely, in the Random domain, a great deal of near optimal policies are available to the agent. Thus, even as the information for optimal behavior is lost, there are many near optimal policies available to the agent that remain available."
    }, {
      "heading" : "8 Conclusion",
      "text" : "Approximate abstraction in MDPs offers considerable advantages over exact abstraction. First, approximate abstraction relies on criteria that we imagine a planning or learning algorithm to be able to learn without solving the full MDP. Second, approximate abstractions can achieve greater degrees of compression due to their relaxed criteria of equality. Third, methods that employ approximate aggregation techniques are able to tune the aggressiveness of abstraction all the while incurring bounded error. In this work, we proved bounds for the value lost when behaving according to the optimal policy of the abstract MDP, and empirically demonstrate that approximate abstractions can reduce state space size with minor loss in the quality of the behavior. We provide a code base that provides implementations to abstract, visualize, and evaluate an arbitrary MDP to promote further investigation into approximate abstraction.\nThere are many directions for future work. First, we are interested in extending the approach of Ortner [27] by learning the approximate abstraction functions introduced in this paper online in the planning or RL setting, particularly when the agent must solve a collection of related MDPs. Additionally, while\nour work presents several sufficient conditions for achieving bounded error of learned behavior with approximate abstractions, we hope to investigate what conditions are strictly necessary for an approximate abstraction to achieve bounded error. Further, we are interested in characterizing the relationship between temporal abstractions, such as options [33] and approximate state abstractions. Lastly, we are interested in understanding the relationship between various approximate abstractions and the information theoretical limitations on the degree of abstraction achievable in MDPs."
    } ],
    "references" : [ {
      "title" : "Goal-based action priors",
      "author" : [ "David Abel", "David Ellis Hershkowitz", "Gabriel Barth-Maron", "Stephen Brawner", "Kevin O’Farrell", "James MacGlashan", "Stefanie Tellex" ],
      "venue" : "In ICAPS,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2015
    }, {
      "title" : "State abstraction for programmable reinforcement learning agents",
      "author" : [ "David Andre", "Stuart J Russell" ],
      "venue" : "In AAAI/IAAI,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2002
    }, {
      "title" : "Near-optimal regret bounds for reinforcement learning",
      "author" : [ "Peter Auer", "Thomas Jaksch", "Ronald Ortner" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "Hierarchical reinforcement learning based on subgoal discovery and subpolicy specialization",
      "author" : [ "Bram Bakker", "Jürgen Schmidhuber" ],
      "venue" : "In Proc. of the 8-th Conf. on Intelligent Autonomous Systems,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2004
    }, {
      "title" : "Recent advances in hierarchical reinforcement learning",
      "author" : [ "Andrew G Barto", "Sridhar Mahadevan" ],
      "venue" : "Discrete Event Dynamic Systems,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2003
    }, {
      "title" : "Dynamic programming aggregation",
      "author" : [ "James C Bean", "John R Birge", "Robert L Smith" ],
      "venue" : "Operations Research,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2011
    }, {
      "title" : "Feudal Reinforcement Learning",
      "author" : [ "Peter Dayan", "Geoffrey Hinton" ],
      "venue" : "Advances in neural information processing systems,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1993
    }, {
      "title" : "Model minimization in markov decision processes",
      "author" : [ "Thomas Dean", "Robert Givan" ],
      "venue" : "In AAAI/IAAI,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1997
    }, {
      "title" : "Model reduction techniques for computing approximately optimal solutions for markov decision processes",
      "author" : [ "Thomas Dean", "Robert Givan", "Sonia Leach" ],
      "venue" : "In Proceedings of the Thirteenth Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1997
    }, {
      "title" : "Abstraction and approximate decision-theoretic planning",
      "author" : [ "Richard Dearden", "Craig Boutilier" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1997
    }, {
      "title" : "Bayesian Q-learning",
      "author" : [ "Richard Dearden", "Nir Friedman", "Stuart Russell" ],
      "venue" : "In AAAI/IAAI,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1998
    }, {
      "title" : "Hierarchical reinforcement learning with the MAXQ value function decomposition",
      "author" : [ "Thomas G Dietterich" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2000
    }, {
      "title" : "Approximate equivalence of Markov decision processes",
      "author" : [ "Eyal Even-Dar", "Yishay Mansour" ],
      "venue" : "In Learning Theory and Kernel Machines,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2003
    }, {
      "title" : "Metrics for finite markov decision processes",
      "author" : [ "Norm Ferns", "Prakash Panangaden", "Doina Precup" ],
      "venue" : "In Proceedings of the 20th conference on Uncertainty in artificial intelligence,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2004
    }, {
      "title" : "Methods for computing state similarity in markov decision processes",
      "author" : [ "Norman Ferns", "Pablo Samuel Castro", "Doina Precup", "Prakash Panangaden" ],
      "venue" : "Proceedings of the 22nd conference on Uncertainty in artificial intelligence,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2006
    }, {
      "title" : "State Aggregation in Monte Carlo Tree Search",
      "author" : [ "Jesse Hostetler", "Alan Fern", "Tom Dietterich" ],
      "venue" : "Aaai 2014,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2014
    }, {
      "title" : "Extreme state aggregation beyond mdps",
      "author" : [ "Marcus Hutter" ],
      "venue" : "In International Conference on Algorithmic Learning Theory,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2014
    }, {
      "title" : "Extreme state aggregation beyond markov decision processes",
      "author" : [ "Marcus Hutter" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2016
    }, {
      "title" : "Abstraction Selection in Model-Based Reinforcement Learning",
      "author" : [ "Nan Jiang" ],
      "venue" : "icml,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Improving uct planning via approximate homomorphisms",
      "author" : [ "Nan Jiang", "Satinder Singh", "Richard Lewis" ],
      "venue" : "In Proceedings of the 2014 international conference on Autonomous agents and multi-agent systems,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2014
    }, {
      "title" : "State abstraction discovery from irrelevant state variables",
      "author" : [ "Nicholas K Jong", "Peter Stone" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2005
    }, {
      "title" : "Reinforcement learning: A survey",
      "author" : [ "Leslie Pack Kaelbling", "Michael L Littman", "Andrew W Moore" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1996
    }, {
      "title" : "Bandit based monte-carlo planning",
      "author" : [ "Levente Kocsis", "Csaba Szepesvári" ],
      "venue" : "In European conference on machine learning,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2006
    }, {
      "title" : "Towards a unified theory of state abstraction for mdps",
      "author" : [ "Lihong Li", "Thomas J Walsh", "Michael L Littman" ],
      "venue" : "In ISAIM,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2006
    }, {
      "title" : "On the complexity of solving Markov decision problems",
      "author" : [ "Michael L Littman", "Thomas L Dean", "Leslie Pack Kaelbling" ],
      "venue" : "In Proceedings of the Eleventh Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1995
    }, {
      "title" : "Efficient bayesian clustering for reinforcement learning",
      "author" : [ "Travis Mandel", "Yun-En Liu", "Emma Brunskill", "Zoran Popovic" ],
      "venue" : null,
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2016
    }, {
      "title" : "Adaptive aggregation for reinforcement learning in average reward Markov decision processes",
      "author" : [ "Ronald Ortner" ],
      "venue" : "Annals of Operations Research,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2013
    }, {
      "title" : "The complexity of Markov decision processes",
      "author" : [ "Christos H Papadimitriou", "John N Tsitsiklis" ],
      "venue" : "Mathematics of Operations Research,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1987
    }, {
      "title" : "Graphstream: A tool for bridging the gap between complex systems and dynamic graphs",
      "author" : [ "Yoann Pigné", "Antoine Dutot", "Frédéric Guinand", "Damien Olivier" ],
      "venue" : null,
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2008
    }, {
      "title" : "Artificial Intelligence A Modern Approach",
      "author" : [ "Stuart Russell", "Peter Norvig" ],
      "venue" : "Prentice-Hall, Englewood Cliffs,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 1995
    }, {
      "title" : "Reinforcement Learning in Finite MDPs : PAC Analysis",
      "author" : [ "Alexander L. Strehl", "Lihong Li", "Michael L. Littman" ],
      "venue" : "Journal of Machine Learning Research,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2009
    }, {
      "title" : "Reinforcement Learning: An Introduction",
      "author" : [ "Richard S Sutton", "Andrew G Barto" ],
      "venue" : null,
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 1998
    }, {
      "title" : "Between MDPs and semi-MDPs: A framework for temporal abstraction in reinforcement learning",
      "author" : [ "Richard S Sutton", "Doina Precup", "Satinder Singh" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1999
    }, {
      "title" : "Transferring state abstractions between mdps",
      "author" : [ "Thomas J Walsh", "Lihong Li", "Michael L Littman" ],
      "venue" : "In ICML Workshop on Structural Knowledge Transfer for Machine Learning,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 27,
      "context" : "Solving for optimal behavior in MDPs in a planning setting is known to be P-Complete in the size of the state space [28, 25].",
      "startOffset" : 116,
      "endOffset" : 124
    }, {
      "referenceID" : 24,
      "context" : "Solving for optimal behavior in MDPs in a planning setting is known to be P-Complete in the size of the state space [28, 25].",
      "startOffset" : 116,
      "endOffset" : 124
    }, {
      "referenceID" : 30,
      "context" : "Similarly, many RL algorithms for solving MDPs are known to require a number of samples polynomial in the size of the state space [31].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 0,
      "context" : "For instance, a robot involved in a pick-and-place task might be able to employ planning algorithms to solve for how to manipulate some objects into a desired configuration in time polynomial in the number of states, but the number of states it must consider grows exponentially with the number of objects with which it is working [1].",
      "startOffset" : 331,
      "endOffset" : 334
    }, {
      "referenceID" : 1,
      "context" : "Thus, a key research agenda for planning and RL is leveraging abstraction to reduce large state spaces [2, 21, 10, 12, 6].",
      "startOffset" : 103,
      "endOffset" : 121
    }, {
      "referenceID" : 20,
      "context" : "Thus, a key research agenda for planning and RL is leveraging abstraction to reduce large state spaces [2, 21, 10, 12, 6].",
      "startOffset" : 103,
      "endOffset" : 121
    }, {
      "referenceID" : 9,
      "context" : "Thus, a key research agenda for planning and RL is leveraging abstraction to reduce large state spaces [2, 21, 10, 12, 6].",
      "startOffset" : 103,
      "endOffset" : 121
    }, {
      "referenceID" : 11,
      "context" : "Thus, a key research agenda for planning and RL is leveraging abstraction to reduce large state spaces [2, 21, 10, 12, 6].",
      "startOffset" : 103,
      "endOffset" : 121
    }, {
      "referenceID" : 5,
      "context" : "Thus, a key research agenda for planning and RL is leveraging abstraction to reduce large state spaces [2, 21, 10, 12, 6].",
      "startOffset" : 103,
      "endOffset" : 121
    }, {
      "referenceID" : 23,
      "context" : "Existing work has characterized how exact abstractions can fully maintain optimality in MDPs [24, 8].",
      "startOffset" : 93,
      "endOffset" : 100
    }, {
      "referenceID" : 7,
      "context" : "Existing work has characterized how exact abstractions can fully maintain optimality in MDPs [24, 8].",
      "startOffset" : 93,
      "endOffset" : 100
    }, {
      "referenceID" : 0,
      "context" : "Here, S is a finite state space; A is a finite set of actions available to the agent; T denotes T (s, a, s′), the probability of an agent transitioning to state s′ ∈ S after applying action a ∈ A in state s ∈ S; R(s, a) denotes the reward received by the agent for executing action a in state s; γ ∈ [0, 1] is a discount factor that determines how much the agent prefers future rewards over immediate rewards.",
      "startOffset" : 300,
      "endOffset" : 306
    }, {
      "referenceID" : 0,
      "context" : "We assume without loss of generality that the range of all reward functions is normalized to [0, 1].",
      "startOffset" : 93,
      "endOffset" : 99
    }, {
      "referenceID" : 21,
      "context" : "[22].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : "[9] leverage the notion of bisimulation to investigate partitioning an MDP’s state space into clusters of states whose transition model and reward function are within ε of each other.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 8,
      "context" : "[9].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 13,
      "context" : "[14, 15] investigated state similarity metrics for MDPs; they bounded the value difference of ground states and abstract states for several bisimulation metrics that induce an abstract MDP.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 14,
      "context" : "[14, 15] investigated state similarity metrics for MDPs; they bounded the value difference of ground states and abstract states for several bisimulation metrics that induce an abstract MDP.",
      "startOffset" : 0,
      "endOffset" : 8
    }, {
      "referenceID" : 12,
      "context" : "Even-Dar and Mansour [13] analyzed different distance metrics used in identifying state space partitions subject to ε-similarity, also providing value bounds (their Lemma 4) for ε-homogeneity subject to the L∞ norm, which parallels our Claim 2.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 26,
      "context" : "Ortner [27] developed an algorithm for learning partitions in an online setting by taking advantage of the confidence bounds for T and R provided by UCRL [3].",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 2,
      "context" : "Ortner [27] developed an algorithm for learning partitions in an online setting by taking advantage of the confidence bounds for T and R provided by UCRL [3].",
      "startOffset" : 154,
      "endOffset" : 157
    }, {
      "referenceID" : 17,
      "context" : "Hutter [18, 17] investigates state aggregation beyond the MDP setting.",
      "startOffset" : 7,
      "endOffset" : 15
    }, {
      "referenceID" : 16,
      "context" : "Hutter [18, 17] investigates state aggregation beyond the MDP setting.",
      "startOffset" : 7,
      "endOffset" : 15
    }, {
      "referenceID" : 23,
      "context" : "[24] that Q∗ abstractions preserve the optimal value function.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "[16] apply state abstraction to Monte Carlo Tree Search and expectimax search, giving value bounds of applying the optimal abstract action in the ground tree(s), similarly to our setting.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 9,
      "context" : "Dearden and Boutilier [10] also formalize stateabstraction for planning, focusing on abstractions that are quickly computed and offer bounded value.",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 19,
      "context" : "[20] analyze a similar setting, applying abstractions to the Upper Confidence Bound applied to Trees algorithm adapted for planning, introduced by Kocsis and Szepesvári [23].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "[20] analyze a similar setting, applying abstractions to the Upper Confidence Bound applied to Trees algorithm adapted for planning, introduced by Kocsis and Szepesvári [23].",
      "startOffset" : 169,
      "endOffset" : 173
    }, {
      "referenceID" : 25,
      "context" : "[26] advance Bayesian aggregation in RL to define Thompson Clustering for Reinforcement Learning (TCRL), an extension of which achieves near-optimal Bayesian regret bounds.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "Jiang [19] analyze the problem of choosing between two candidate abstractions.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 1,
      "context" : "Andre and Russell [2] investigated a method for state abstraction in hierarchical reinforcement learning leveraging a programming language called ALISP that promotes the notion of safe state abstraction.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 11,
      "context" : "Dietterich [12] developed MAXQ, a framework for composing tasks into an abstracted hierarchy where state aggregation can be applied.",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 3,
      "context" : "Bakker and Schmidhuber [4] also target hierarchical abstraction, focusing on subgoal discovery.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 20,
      "context" : "Jong and Stone [21] introduced a method called policy-irrelevance in which agents identify (online) which state variables may be safely abstracted away in a factored-state MDP.",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 6,
      "context" : "Dayan and Hinton [7] develop “Feudal Reinforcement Learning” which presents an early form of hierarchical RL that restructures Q-Learning to manage the decomposition of a task into subtasks.",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 23,
      "context" : "[24], and for a survey of early works on hierarchical reinforcement learning, see Barto and Mahadevan [5].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 4,
      "context" : "[24], and for a survey of early works on hierarchical reinforcement learning, see Barto and Mahadevan [5].",
      "startOffset" : 102,
      "endOffset" : 105
    }, {
      "referenceID" : 23,
      "context" : "[24] developed a framework for exact state abstraction in MDPs.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[24].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 33,
      "context" : "[34] build on the framework they previously developed by showing empirically how to transfer abstractions between structurally related MDPs.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[24], who introduced a unifying theoretical framework for state abstraction in MDPs.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "The only restriction placed on the weighting scheme is that it induces a probability distribution on the ground states of each abstract state: ∀s ∈ SG  ∑ s∈G(s) ω(s)  = 1 AND ω(s) ∈ [0, 1].",
      "startOffset" : 186,
      "endOffset" : 192
    }, {
      "referenceID" : 0,
      "context" : "Definition 5 (RA): The abstract reward function RA : SA ×A 7→ [0, 1] is a weighted sum of the rewards of each of the ground states that map to the same abstract state: RA(s, a) = ∑ g∈G(s) RG(g, a)ω(g).",
      "startOffset" : 62,
      "endOffset" : 68
    }, {
      "referenceID" : 0,
      "context" : "Definition 6 (TA): The abstract transition function TA : SA × A × SA 7→ [0, 1] is a weighted sum of the transitions of each of the ground states that map to the same abstract state: TA(s, a, s′) = ∑ g∈G(s) ∑ g′∈G(s′) TG(g, a, g′)ω(g).",
      "startOffset" : 72,
      "endOffset" : 78
    }, {
      "referenceID" : 0,
      "context" : "j eG2j ∣∣∣∣∣ ≤ kbolt × ε Naturally, the value bound of Equation 10 is meaningless for 2εηf ≥ RMax 1−γ = 1 1−γ , since this is the maximum possible value in any MDP (and we assumed the range of R is [0, 1]).",
      "startOffset" : 198,
      "endOffset" : 204
    }, {
      "referenceID" : 23,
      "context" : "[24]’s φQ∗ .",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[24]’s φmodel, where states are aggregated together when their rewards and transitions are within ε.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 31,
      "context" : "This type of abstractions is appealing as Boltzmman distributions balance exploration and exploitation [32].",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 28,
      "context" : "We use the graph-visualization library GraphStream [29] and the planning and RL library, BURLAP.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 10,
      "context" : "1 NChain NChain is a simple MDP investigated in the Bayesian RL literature due to the interesting exploration problem it poses [11].",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 11,
      "context" : "3 Taxi Taxi has long been studied by the hierarchical RL literature [12].",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 29,
      "context" : "The agent, operating in a Grid World style domain [30], may move left, right, up, and down, as well as pick up a passenger and drop off a passenger.",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 29,
      "context" : "4 Minefield Minefield is a test problem we are introducing that uses the Grid World dynamics of Russell and Norvig [30] with slip probability of x.",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 26,
      "context" : "First, we are interested in extending the approach of Ortner [27] by learning the approximate abstraction functions introduced in this paper online in the planning or RL setting, particularly when the agent must solve a collection of related MDPs.",
      "startOffset" : 61,
      "endOffset" : 65
    } ],
    "year" : 2017,
    "abstractText" : "The combinatorial explosion that plagues planning and reinforcement learning (RL) algorithms can be moderated using state abstraction. Prohibitively large task representations can be condensed such that essential information is preserved, and consequently, solutions are tractably computable. However, exact abstractions, which treat only fully-identical situations as equivalent, fail to present opportunities for abstraction in environments where no two situations are exactly alike. In this work, we investigate approximate state abstractions, which treat nearly-identical situations as equivalent. We present theoretical guarantees of the quality of behaviors derived from four types of approximate abstractions. Additionally, we empirically demonstrate that approximate abstractions lead to reduction in task complexity and bounded loss of optimality of behavior in a variety of environments.",
    "creator" : "LaTeX with hyperref package"
  }
}