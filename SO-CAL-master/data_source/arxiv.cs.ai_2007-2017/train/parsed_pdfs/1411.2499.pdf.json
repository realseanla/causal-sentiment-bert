{
  "name" : "1411.2499.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Radhakrishnan Delhibabu" ],
    "emails" : [ "delhibabu@kbsg.rwth-aachen.de" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n41 1.\n24 99\nv1 [\ncs .A\nI] 1\n0 N\nov 2\nKeyword: AGM, Belief Revision, Knowledge Base Dynamics, Kernel Change, Abduction, Hyber Tableaux, Magic Set, View update, Update Propagation."
    }, {
      "heading" : "1 Introduction",
      "text" : "Modeling intelligent agents’ reasoning requires designing knowledge bases for the purpose of performing symbolic reasoning. Among the different types of knowledge representations in the domain of artificial intelligence, logical representations stem from classical logic. However, this is not suitable for representing or treating items of information containing vagueness, incompleteness or uncertainty, or knowledge base evolution that leads the agent to change his beliefs about the world.\nWhen a new item of information is added to a knowledge base, it may become inconsistent. In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework. Revision means modifying the knowledge base in order to maintain consistency [81], while keeping the new information and removing (contraction) or not removing the least possible previous information. In our case, update means revision and contraction, that is insertion and deletion in database perspective. Previous work [6,7] makes connections with contraction from knowledge base dynamics.\n⋆ This paper extends work from Delhibabu [34] and Mayol [83]\nOur knowledge base dynamics is defined in two parts: an immutable part (formulae) and updatable part (literals) (for definition and properties see works of Nebel [88] and Segerberg [98]). Knowledge bases have a set of integrity constraints (see the definitions in later section). In the case of finite knowledge bases, it is sometimes hard to see how the update relations should be modified to accomplish certain knowledge base updates.\nExample 1. Consider a database with an (immutable) rule that a staff member is a person who is currently working in a research group under a chair. Additional (updatable) facts are that matthias and gerhard are group chairs, and delhibabu and aravindan are staff members in group info1. Our first integrity constraint (IC) is that each research group has only one chair ie. ∀x, y, z (y=x)← group chair(x,y) ∧ group chair(x,z). Second integrity constraint is that a person can be a chair for only one research group ie. ∀x, y, z (y=z)← group chair(y,x) ∧ group chair(z,x).\nImmutable part: staff chair(X,Y)← staff group(X,Z),group chair(Z,Y).\nUpdatable part: group chair(infor1,matthias)← group chair(infor2,gerhard)← staff group(delhibabu,infor1)← staff group(aravindan,infor1)←\nSuppose we want to update this database with the information, staff chair(aravindan,gerhard); From the immutable part, we can deduce that this can be achieved by asserting staff group(aravindan,Z) ∧ group chair(Z,gerhard)\nIf we are restricted to definite clauses, there are three plausible ways to do this: first case is, aravindan and gerhard belong to infor1, i.e, staff group(aravindan,info1) ∧\ngroup chair(info1,gerhard). We need to delete both base facts group chair(infor1,matthias)← and group chair(infor2,gerhard)←, because our first IC as well as second IC would be violated otherwise. In order to change the view, we need to insert group chair(infor1,gerhard)← as a base fact. Assume that we have an algorithm that deletes the base facts staff group(delhibabu,infor1)← from the database. But, no rational person will agree with such an algorithm, because the fact staff group(delhibabu,infor1)← is not ”relevant” to the view atom.\nSecond case, aravindan and gerhard belong to infor2, that is staff group(aravindan,info2) ∧\ngroup chair(info2,gerhard). Simply, insert the new fact staff group(aravindan,infor2)← to change the view. Suppose an algorithm deletes the base facts staff group(aravindan,infor1)← from the database, then it can not be ”rational” since these facts are not ”relevant” to the view atom.\nThird case, aravindan and gerhard belong to infor3 (free assignment of the group value), that is staff group(aravindan,info3) ∧\ngroup chair(info3,gerhard). Suppose, we insert new base fact group chair(info3,gerhard) ←, our second IC does not follow. Suppose an algorithm inserts the new base fact staff group(aravindan,infor2)← or staff group(aravindan,infor1)← is deleted, then it can not be ”rational”.\nThe above example highlights the need for some kind of ”relevance policy” to be adopted when a view atom is to be inserted to a deductive database. How many such axioms and policies do we need to characterize a ”good” view update? When are we sure that our algorithm for view update is ”rational”? Clearly, there is a need for an axiomatic characterization of view updates. By axiomatic characterization, we mean explicitly listing all the rationality axioms that are to be satisfied by any algorithm for view update.\nWhen dealing with the revision of a knowledge base (both insertions and deletions), there are other ways to change a knowledge base and it has to be performed automatically also. Considering the information, change is precious and must be preserved as much as possible. The principle of minimal change [58,97] can provide a reasonable strategy. On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of Carlos Alchourrón, Peter Gärdenfors, and David Makinson (AGM) [2]; what result has to be chosen [66,72,86]; and finally, according to a practical point of view, what computational model to support for knowledge base revision has to be provided?\nThe basic idea in [11,8] is to employ the model generation property of hyper tableaux and magic set to generate models, and read off diagnosis from them. One specific feature of this diagnosis algorithm is the use of semantics (by transforming the system description and the observation using an initial model of the correctly working system) in guiding the search for a diagnosis. This semantical guidance by program transformation turns out to be useful for database updates as well. More specifically we use a (least) Herbrand model of the given database to transform it along with the update request into a disjunctive logic program in such a way that the models of this transformed program stand for possible updates. This paper aims at studying the view update algorithms in relational databases. First, we define a framework for highlighting the basic theory of minimal change. Thus, we present a generalized revision algorithm based on abductive explanation for knowledge base revision and main view update method.\nThe rest of paper is organized as follows: First we start with preliminaries in Section 2. In Section 3, we introduce knowledge base dynamics along with the concept of generalized revision, and revision operator for knowledge base. Section 4 studies the relationship between knowledge base dynamics and abduction. We discuss an important application of knowledge base dynamics in providing an axiomatic characterization for updating view literal to databases. We briefly discuss hyper tableaux calculus and magic set in Section 5. We present two variants of our rational and efficient algorithm for view update in Section 6. In Section 7, we discuses six basic dimensions in the process of view updating and comparative study of view update algorithms in rational approach is presented. In Section 7, we give brief overview. In Section 8 we draw conclusions with a summary of our contribution and indicate future directions of our investigation. All proofs can be found in the Appendix."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We consider a propositional language LP defined from a finite set of propositional variables P and the standard connectives. We use lower case Roman letters a, b, x, y, ... to range over elementary letters and Greek letters ϕ, φ, ψ, ... for propositional formulae. Sets of formulae are denoted by upper case Roman letters A,B, F,K, ..... A literal is an atom (positive literal), or a negation of an atom (negative literal).\nFor any formula ϕ, we write E(ϕ) to mean the set of the elementary letters that occur in ϕ. The same notation also applies to a set of formulae. For any set F of formulae, L(F ) represents the sub-language generated by E(F ), i.e., the set of all formulae ϕ with E(ϕ) ⊆ E(F ).\nHorn formulae are defined [37] as follows:\n1. Every a ∈ Φ where Φ ∈ LP ∪ {⊥} , a and ¬a are Horn clauses. 2. a← a1 ∧a2 ∧ ...∧an is a Horn clause, where n ≥ 0 and a, ai ∈ Φ (1 ≤ i ≤ n). 3. Every Horn clause is a Horn formula, a is called head and ai is body of the\nHorn formula. 4. If ϕ and ψ are Horn formulae, so is ϕ ∧ ψ.\nA definite Horn clause is a finite set of literals (atoms) that contains exactly one positive literal which is called the head of the clause. The set of negative literals of this definite Horn clause is called the body of the clause. A Horn clause is non-recursive, if the head literal does not occur in its body. We usually denote a Horn clause as head←body. Let LH be the set of all Horn formulae with respect to LP . A formula φ is a syntactic consequence within LP of a set Γ of formulas if there is a formal proof in LP of φ from the set Γ is Γ ⊢LP φ.\nA immutable part is a function-free clause of the form a← a1 ∧ a2 ∧ ...∧ an, with n ≥ 1 where a is an atom denoting the immutable part’s head and a1 ∧ a2 ∧ ... ∧ an are literals. i.e., positive or negative atoms, representing the body of the Horn clauses.\nFormally, a finite Horn knowledge baseKB is defined as a finite set of formulae from language LH, and divided into three parts: an immutable theory KBI is a Horn formula (head←body), which is the fixed part of the knowledge; updatable theory KBU is a Horn clause (head←); and integrity constraint KBIC representing a set of clauses (←body).\nDefinition 1 (Horn Knowledge Base). A Horn knowledge base, KB is a finite set of Horn formulae from language LH, s.t KB = KBI ∪KBU ∪KBIC, KBI ∩KBU = ∅ and KBU ∩KBIC = ∅.\nIn the AGM framework, a belief set is represented by a deductively closed set of propositional formulae. While such sets are infinite, they can always be finitely representable. However, working with deductively closed, infinite belief sets is not very attractive from a computational point of view. The AGM approach to belief dynamics is very attractive in its capturing the rationality of change, but it is not always easy to implement either Horn formula based partial meet revision. In\nreal application from artificial intelligence and databases, what is required is to represent the knowledge using a finite Horn knowledge base. Further, a certain part of the knowledge is treated as immutable and should not be changed.\nKnowledge base change deals with situations in which an agent has to modify its beliefs about the world, usually due to new or previously unknown incoming information, also represented as formulae of the language. Common operations of interest in Horn knowledge base change are the expansion of an agent’s current Horn knowledge base KB by a given Horn clause ϕ (usually denoted as KB+ϕ), where the basic idea is to add regardless of the consequences, and the revision of its current beliefs by ϕ (denoted as KB * ϕ), where the intuition is to incorporate ϕ into the current beliefs in some way while ensuring consistency of the resulting theory at the same time. Perhaps the most basic operation in Horn knowledge base change, like belief change, is that of contraction (AGM [2]), which is intended to represent situations in which an agent has to give up ϕ from its current stock of beliefs (denoted as KB-ϕ).\nDefinition 2 (AGM Contraction). Let KB be a Horn knowledge base, and α a belief that is present in KB. Then contraction of KB by α, denoted as KB−α, is a consistent belief set that excludes α\nDefinition 3 (Levi Identity). Let - be an AGM contraction operator for KB. A way to define a revision is by using Generalized Levi Identity:\nKB ∗ α = (KB − ¬α) ∪ α\nThen, the revision can be trivially achieved by expansion, and the axiomatic characterization could be straightforwardly obtained from the corresponding characterizations of the traditional models [45]. The aim of our work is not to define revision from contraction, but rather to construct and axiomatically characterize revision operators in a direct way."
    }, {
      "heading" : "3 Knowledge base dynamics",
      "text" : "AGM [2] proposed a formal framework in which revision(contraction) is interpreted as belief change. Focusing on the logical structure of beliefs, they formulate eight postulates which a revision knowledge base (contraction knowledge base was discussed in [7]) has to verify.\nIn the AGM approach, a belief is represented by a sentence over a suitable language LH, and a belief KB is represented by a set of sentence that are close wrt the logical closure operator Cn. It is assumed that LH, is closed under application of the boolean operators negation, conjunction, disjunction, and implication.\nDefinition 4. Let KB be a knowledge base with an immutable part KBI . Let α and β be any two clauses from LH. Then, α and β are said to be KB-equivalent iff the following condition is satisfied: ∀ set of Horn clauses E ⊆ LH: KBI ∪E ⊢ α iff KBI ∪ E ⊢ β.\nThese postulates stem from three main principles: the new item of information has to appear in the revised knowledge base, the revised base has to be consistent and revision operation has to change the least possible beliefs. Now we consider the revision of a Horn clause α wrt KB, written as KB ∗ α. The rationality postulates for revising α from KB can be formulated as follows:\nDefinition 5 (Rationality postulates for knowledge base revision).\n(KB*1) Closure: KB ∗ α is a knowledge base. (KB*2) Weak Success: if α is consistent with KBI ∪KBIC then α ⊆ KB ∗ α. (KB*3.1) Inclusion: KB ∗ α ⊆ Cn(KB ∪ α). (KB*3.2) Immutable-inclusion: KBI ⊆ Cn(KB ∗ α). (KB*4.1) Vacuity 1: if α is inconsistent with KBI ∪KBIC then KB ∗α = KB. (KB*4.2) Vacuity 2: if KB ∪ α 0⊥ then KB ∗ α = KB ∪ α. (KB*5) Consistency: if α is consistent with KBI ∪ KBIC then KB ∗ α is\nconsistent with KBI ∪KBIC . (KB*6) Preservation: If α and β are KB-equivalent, then KB ∗ α↔ KB ∗ β. (KB*7.1) Strong relevance: KB ∗ α ⊢ α If KBI 0 ¬α (KB*7.2) Relevance: If β ∈ KB\\KB ∗ α, then there is a set KB′ such that\nKB ∗ α ⊆ KB′ ⊆ KB ∪ α, KB′ is consistent KBI ∪ KBIC with α, but KB′ ∪ {β} is inconsistent KBI ∪KBIC with α. (KB*7.3) Weak relevance: If β ∈ KB\\KB ∗α, then there is a set KB′ such that KB′ ⊆ KB ∪ α, KB′ is consistent KBI ∪KBIC with α, but KB′ ∪ {β} is inconsistent KBI ∪KBIC with α.\nTo revise α from KB, only those information that are relevant to α in some sense can be added (as the example from the introduction illustrates). (KB∗7.1) is a very strong axiom allowing only minimum changes, and certain rational revisions can not be carried out. So, relaxing this condition (example with more details can be found in [7]) allows for weakening strong relevance to relevance only. The relevance policy (KB ∗ 7.2), however, still does not permit rational revisions, so we need to go one step further. With (KB ∗ 7.3) the relevance axiom is further weakened and the resulting conditions are referred to as ”coreretainment”."
    }, {
      "heading" : "3.1 Relationship with Abductive Logic Grammars",
      "text" : "The relationship between Horn knowledge base dynamics and abduction was introduced by the philosopher Pierce (see [4]). We show how abduction grammar could be used to realize revision with immutability condition. A special subset of literal (atoms) of language LH, abducibles Ab, are designated for abductive reasoning. Our work is based on atoms, so we combine Christiansen and Dahl [29] grammars method to our theory.\nDefinition 6 (Abductive grammar). An abductive grammar Γ is a 6-tuple 〈N,T, IC,KB,R, S〉 where\n- N are nonterminal symbols in immutable part (KBI).\n- T is a set of terminal symbols in updatable part (KBU). - IC is the integrity constraint to Horn knowledge base (KBIC). - KB is the Horn knowledge base which consists of KB = KBI∪KBU∪KBIC. - R is a set of rules, R ⊆ KB. - S is the revision of literals (atoms), called the start symbol.\nDefinition 7 (Constraint system). A constraint system for a abduction is a pair 〈KBAb,KBBG〉, where KBAb(∆) is a set of propositions (abducibles) and KBBG background Horn knowledge base.\nNotations: From grammar point, KBBG is set all Horn formulae from R and KBAb is set of abducibles from T.\nDefinition 8 (Minimal abductive explanation). Let KB be a Horn knowledge base and α an observation to be explained. Then, for a set of abducibles (KBAb), ∆ is said to be an abductive explanation wrt KBBG iff KBBG∪∆ ⊢ α. ∆ is said to be minimal wrt KBBG iff no proper subset of ∆ is an abductive explanation for α, i.e. ∄∆ ′ s.t. KBBG ∪∆ ′ ⊢ α.\nSince an incision function is adding and removing only updatable elements from each member of the kernel set, to compute a generalized revision of α from KB, we need to compute only the abduction in every α-kernel of KB. So, it is now necessary to characterize precisely the abducibles present in every α-kernel of KB. The notion of minimal abductive explanation is not enough to capture this, and we introduce locally minimal and KB-closed abductive explanations.\nDefinition 9 (Local minimal abductive explanations). Let KBBG ′\nbe a smallest subset of KBBG, s.t ∆ is a minimal abductive explanation of α wrt KBBG ′ (for some ∆). Then ∆ is called local minimal for α wrt KBBG.\nDefinition 10 (Constraint abduction system). A constrained abductive grammar is a pair 〈Γ,C〉, where Γ is an abductive grammar and C a constraint system for abduction, Γ=〈N,T,R, S〉 and C=〈KBBG,KBAb, IC〉.\nGiven a constrained abductive grammar 〈Γ,C〉 as above, the constrained abductive recognition problem for τ ∈ T ∗ is the problem of finding an admissible and denial knowledge base from KBAb and such that τ ∈ LP (ΓKBAb) where LP (ΓKBAb) is propositional language over abducibles in Γ , where ΓKBAb = 〈N,T,KBBG ∪KBAb, R, S〉. In this case, KBAb is called a constrained (abductive) system of τ . Such that KBAb is minimal whenever no proper subset of it is an in τ given 〈Γ,C〉.\nLet KBAb ∈ ({∆+, ∆−}). Here ∆+ refers to admission Horn knowledge base (positive atoms) and ∆− refers to denial Horn knowledge base(negative atoms) wrt given α. Then problem of abduction is to explain∆ with abducibles (KBAb), s.t. KBBG ∪∆+ ∪∆− ⊢ α and KBBG ∪∆+ |= α∪∆− are both consistent with IC.\nTheorem 1. Consider a constrained abductive grammar AG = 〈Γ,C〉 with Γ = 〈N,T,KB,R, S〉 and C = 〈KBBG,KBAb, IC〉. Construct a abductive grammar ∆(AG) =〈N,T,KBBG, R, S〉 by having, for any (∆+) (or(∆−) from KBAb, the set of acceptable results for accommodate(α,KBBG ∈ ∆+) being of the form (KBAb\\∆+) where (∆+ ∈ KBAb ′\n). ∆+ is a locally minimal set of atoms (literals) KBBG ∪ ∆+ and KBBG ∪ ∆+ |= α is consistent with IC; if no such (∆−) exists (like denial (∆−) being of the form (KBAb\\∆−). ∆− is a locally minimal set of atoms (literals) KBBG ∪ ∆− and KBBG ∪ ∆− |= α is consistent with IC), otherwise accommodate (α,KBBG ∈ ∆−) is not possible.\nNow, we need to connect the grammar system Γ to the Horn knowledge base KB, such that KBI ∪KBU ∪ KBIC = KBBG ∪KBAb ∪ IC holds. The connection between locally minimal abductive explanation for α wrt KBI and α-kernel of KB, which is shown by the following lemma immediately follows from their respective definitions.\nLemma 1.\n1. Let KB be a Horn knowledge base and α a Horn clause s.t. 0 ¬α. Let ∆+ and ∆− be a KB-closed locally minimal abductive explanation for α wrt KBI. Then, there exists a α-kernel X of KB s.t. X ∩KBU = ∆+ ∪∆−. 2. Let KB be a Horn knowledge base and α a Horn clause s.t. 0 ¬α. Let X be a α-kernel of KB and ∆+ ∪ ∆− = X ∩ KBU . Then, ∆+ and ∆− are KB -locally minimal abductive explanations for α wrt KBI.\nAn immediate consequence of the above lemma 4.1 is that it is enough to compute all the KB-locally minimal abductive explanations for α wrt KBI in order to revise α from KB. Thus, a well-known abductive procedure to compute an abductive explanation for α wrt KBI could be used."
    }, {
      "heading" : "3.2 Generalized revision algorithm",
      "text" : "The problem of knowledge base revision is concerned with determining how a request to change can be appropriately translated into one or more atoms or literals. In this section we develop a new generalized revision algorithm. Note that it is enough to compute all the KB-locally minimal abduction explanations for α wrt KBI ∪KBU ∪KBIC . If α is consistent with KB then a well-known abductive procedure for compute an abductive explanation for α wrt KBI could be used to compute kernel revision.\nTheorem 2. Let KB be a Horn knowledge base and α is formula.\n1. If Algorithm 1 produced KB’as a result of revising α from KB, then KB’ satisfies all the rationality postulates (KB*1) to (KB*6) and (KB*7.3). 2. Suppose KB′′ satisfies all these rationality postulates for revising α from KB, then KB′′ can be produced by Algorithm 1.\nAlgorithm 1 Generalized revision algorithm Input : A Horn knowledge base KB = KBI ∪KBU ∪KBIC\nand a Horn clause α to be revised. Output: A new Horn knowledge base KB′ = KBI ∪KB∗U ∪KBIC ,\ns.t. KB′is a generalized revision α to KB. Procedure KB(KB,α)\nbegin 1. Let V:= {c ∈ KBIC | KBI ∪KBIC inconsistent with α wrt c}\nP := N := ∅ and KB′ = KB 2. While (V , ∅)\nselect a subset V ′ ⊆ V For each v ∈ V ′, select a literal to be\nremove (add to N) or a literal to be added (add to P) wrt KB Let KB := KR(KB,P,N)\nLet V:= {c ∈ KBIC | KBI inconsistent with α wrt c} return\n3. Produce a new Horn knowledge base KB′\nend.\nAlgorithm 2 Procedure KR(KB,∆+, ∆−)\nbegin 1. Let P := {e ∈ ∆+| KBI 6|= e} and N := {e ∈ ∆\n−| KBI |= e} 2. While (P , ∅) or (N , ∅)\nselect a subset P ′ ⊆ P or N ′ ⊆ N Construct a set S1 = {X | X is a KB-closed locally minimal abductive explanation wrt P} Construct a set S2 = {X | X is a KB-closed locally\nminimal abductive explanation wrt N } Determine hitting set σ(S1) and σ(S2)\nIf ((N ′ = ∅) and (P ′ , ∅)) Produce KB′ = KBI ∪ {(KBU ∪ σ(S1)}\nelse Produce KB′ = KBI ∪ {(KBU\\σ(S2) ∪ σ(S1)}\nend if If ((N ′ , ∅) and (P ′ = ∅))\nProduce KB′ = KBI ∪ {(KBU\\σ(S2)} else Produce KB′ = KBI ∪ {(KBU\\σ(S2) ∪ σ(S1)} end if Let P := {e ∈ ∆+| KBI 6|= e} and N := {e ∈ ∆−| KBI |= e}\n3. return KB′\nend."
    }, {
      "heading" : "4 Deductive database",
      "text" : "A Deductive database DDB consists of three parts: an intensional database IDB (KBI), a set of definite program clauses, extensional database EDB (KBU ), a set of ground facts; and integrity constraints IC. The intuitive meaning of DDB is provided by the Least Herbrand model semantics and all the inferences are carried out through SLD-derivation. All the predicates that are defined in IDB are referred to as view predicates and those defined in EDB are referred to as base predicates. Extending this notion, an atom with a view predicate is said to be a view atom,and similarly an atom with base predicate is a base atom. Further we assume that IDB does not contain any unit clauses and no predicate defined in a given DDB is both view and base.\nTwo kinds of view updates can be carried out on a DDB: An atom, that does not currently follow from DDB, can be inserted, or an atom, that currently follows from DDB can be deleted. When an atom A is to be updated, the view update problem is to insert or delete only some relevant EDB facts, so that the modified EDB together with IDB will satisfy the updating of A to DDB.\nNote that a DDB can be considered as a knowledge base to be revised. The IDB is the immutable part of the knowledge base, while the EDB forms the updatable part. In general, it is assumed that the language underlying a DDB is fixed and the semantics of DDB is the least Herbrand model over this fixed language. We assume that there are no function symbols implying that the Herbrand Base is finite. Therefore, the IDB is practically a shorthand of its ground instantiation1 written as IDBG. In the sequel, technically we mean IDBG when we refer simply to IDB. Thus, a DDB represents a knowledge base where the immutable part is given by IDBG and updatable part is the EDB. Hence, the rationality postulates (KB*1)-(KB*6) and (KB*7.3) provide an axiomatic characterization for update (insert and delete) a view atom A from a definite database DDB.\nLogic provides a conceptual level for understanding the meaning of relational databases. Hence, the rationality postulates (KB*1)-(KB*6) and (KB*7.3) can provide an axiomatic characterization for view updates in relational databases too. A relational database together with its view definitions can be represented by a deductive database (EDB representing tuples in the database and IDB representing the view definitions), and so the same algorithm can be used to delete view extensions from relational deductive databases.\nAn update request U = B, where B is a set of base facts, is not true in KB. Then, we need to find a transaction T = Tins ∪ Tdel, where Tins(∆i) (resp. Tdel(∆j)) is the set of facts, such that U is true in DDB\n′ = ((EDB − Tdel ∪ Tins)∪ IDB ∪ IC). Since we consider stratifiable (definite) deductive databases, SLD-tree can be used to compute the required abductive explanations. The idea is to get all EDB facts used in a SLD-derivation of A wrt DDB, and construct that as an abductive explanation for A wrt IDBG.\n1 a ground instantiation of a definite program P is the set of clauses obtained by substituting terms in the Herbrand Universe for variables in P in all possible ways\nAll solutions translate [85] a view update request into a transaction combining insertions and deletions of base relations for satisfying the request. Further, a stratifiable (definite) deductive database can be considered as a knowledge base, and thus rationality postulates and insertion algorithm of the previous section can be applied for view updates in database."
    }, {
      "heading" : "5 View update method",
      "text" : "View updating [11] aims at determining one or more base relation updates such that all given update requests with respect to derived relations are satisfied after the base updates have been successfully applied.\nDefinition 11 (View update). Let DDB = 〈IDB,EDB, IC〉 be a stratifiable (definite) deductive database DDB(D). A VU request νD is a pair 〈ν + D, ν −\nD〉 where ν+D and ν −\nD are sets of ground atoms representing the facts to be inserted into D or deleted from D, resp., such that pred(ν+D ∪ ν − D) ⊆ pred(IDB), ν + D ∩ ν −\nD = ∅, ν+D ∩ PMD = ∅ and ν − D ⊆ PMD.\nNote that we consider again true view updates only, i.e., ground atoms which are presently not derivable for atoms to be inserted, or are derivable for atoms to be deleted, respectively. A method for view updating determines sets of alternative updates satisfying a given request. A set of updates leaving the given database consistent after its execution is called VU realization.\nDefinition 12 (Induced update). Let DDB = 〈IDB,EDB, IC〉 be a stratifiable (definite) deductive database and DDB = νD a VU request. A VU realization is a base update uD which leads to an induced update uD→D′ from D to D′ such that ν+D ⊆ PMD′ and ν − D ∩ PMD′ = ∅.\nThere may be infinitely many realizations and even realizations of infinite size which satisfy a given VU request. A breadth-first search (BFS) is employed for determining a set of minimal realizations τD = {u1D, . . . , u i D}. Any u i D is minimal in the sense that none of its updates can be removed without losing the property of being a realization for νD.\nIn [9,8] a variant of clausal normal form tableaux called ”hyper tableaux” is introduced. Since the hyper tableaux calculus constitutes the basis for our view update algorithm, Clauses, i.e., multisets of literals, are usually written as the disjunction A1 ∨A2 ∨ · · · ∨Am ∨ not B1 ∨ not B2 · · · ∨ not Bn (M ≥ 0, n ≥ 0). The literals A1, A2, . . . Am (resp. B1, B2, . . . , Bn) are called the head (resp. body) of a clause. With L we denote the complement of a literal L. Two literals L and K are complementary if L = K\nFrom now onD always denotes a finite ground clause set, also called database, and Σ denotes its signature, i.e., the set of all predicate symbols occurring in it. We consider finite ordered trees T where the nodes, except the root node, are labeled with literals. In the following we will represent a branch b in T by the sequence b = L1, L2, . . . , Ln (n ≥ 0) of its literal labels, where L1 labels an\nimmediate successor of the root node, and Ln labels the leaf of b. The branch b is called regular iff Li , Lj for 1 ≤ i, j ≤ n and i , j, otherwise it is called irregular. The tree T is regular iff every of its branches is regular, otherwise it is irregular. The set of branch literals of b is lit(b) = {L1, L2, . . . , Ln}. For brevity, we will write expressions like A ∈ b instead of A ∈ lit(b). In order to memorize the fact that a branch contains a contradiction, we allow to label a branch as either open or closed. A tableau is closed if each of its branches is closed, otherwise it is open.\nDefinition 13 (Hyper Tableau). A literal set is called inconsistent iff it contains a pair of complementary literals, otherwise it is called consistent. Hyper tableaux for D are inductively defined as follows:\nInitialization step: The empty tree, consisting of the root node only, is a hyper tableau for D. Its single branch is marked as ”open”.\nHyper extension step: If (1) T is an open hyper tableau for D with open branch b, and (2) C = A1∨A2∨· · ·∨Am ← B1∧B2 · · ·∧Bn is a clause fromD (n ≥ 0,m ≥ 0), called extending clause in this context, and (3) {B1, B2, . . . , Bn} ⊆ b (equivalently, we say that C is applicable to b)then the tree T is a hyper tableau for D, where T is obtained from T by extension of b by C: replace b in T by the new branches\n(b, A1), (b, A2), . . . , (b, Am), (b,¬B1), (b,¬B2), . . . , (b,¬Bn)\nand then mark every inconsistent new branch as ”closed”, and the other new branches as ”open”.\nThe applicability condition of an extension expresses that all body literals have to be satisfied by the branch to be extended. From now on, we consider only regular hyper tableaux. This restriction guarantees that for finite clause sets no branch can be extended infinitely often. Hence, in particular, no open finished branch can be extended any further. This fact will be made use of below occasionally. Notice as an immediate consequence of the above definition that open branches never contain negative literals."
    }, {
      "heading" : "5.1 View update algorithm",
      "text" : "The key idea of the algorithm presented in this paper is to transform the given database along with the view update request into a disjunctive logic program and apply known disjunctive techniques to solve the original view update problem. The intuition behind the transformation is to obtain a disjunctive logic program in such a way that each (minimal) model of this transformed program represent a way to update the given view atom. We present two variants of our algorithm. The one that is discussed in this section employs a trivial transformation procedure but has to look for minimal models; and another performs a costly transformation, but dispenses with the requirement of computing the minimal models."
    }, {
      "heading" : "5.2 Minimality test",
      "text" : "We start presenting an algorithm for stratifiable (definite) deductive databases by first defining precisely how the given database is transformed into a disjunctive logic program for the view deletion process [8] (successful branch - see in Algorithms 3 and 4 via Hyper Tableau).\nDefinition 14 (IDB Transformation). Given an IDB and a set of ground atoms S, the transformation of IDB wrt S is obtained by translating each clause C ∈ IDB as follows: Every atom A in the body (resp. head) of C that is also in S is moved to the head (resp. body) as ¬A.\nNote 1. If IDB is a stratifiable deductive database then the transformation introduced above is not necessary.\nDefinition 15 (IDB∗ Transformation). Let IDB∪EDB be a given database. Let S0 = EDB ∪{A | A is a ground IDB atom}. Then, IDB∗ is defined as the transformation of IDB wrt S0.\nNote 2. Note that IDB∗ is in general a disjunctive logic program. The negative literals (¬A) appearing in the clauses are intuitively interpreted as deletion of the corresponding atom (A) from the database. Technically, a literal ¬A is to be read as a positive atom, by taking the ¬-sign as part of the predicate symbol. To be more precise, we treat ¬A as an atom wrt IDB∗, but as a negative literal wrt IDB.\nNote that there are no facts in IDB∗. So when we add a delete request such as ¬A to this, the added request is the only fact and any bottom-up reasoning strategy is fully focused on the goal (here the delete request)\nDefinition 16 (Update Tableaux Hitting Set). An update tableau for a database IDB ∪ EDB and delete request ¬A is a hyper tableau T for IDB∗ ∪ {¬A←} such that every open branch is finished. For every open finished branch b in T we define the hitting set (of b in T ) as HS(b) = {A ∈ EDB|¬A ∈ b}.\nDefinition 17 (Minimality test). Let T be an update tableau for IDB∪EDB and delete request ¬A. We say that open finished branch b in T satisfies the strong minimality test iff ∀s ∈ HS(b) : IDB ∪ EDB\\HS(b) ∪ {s} ⊢ A.\nDefinition 18 (Update Tableau satisfying strong minimality). An update tableau for given IDB ∪ EDB and delete request ¬A is transformed into an update tableau satisfying strong minimality by marking every open finished branch as closed which does not satisfy strong minimality.\nNext step is view insertion process [11] (For unsuccessful branches - see in Algorithms 3 and 4 via magic set).\nDefinition 19 (IDB∗∗ Transformation). Let IDB∪EDB be a given database. Let S1 = EDB ∪ {A | A is a ground IDB atom}. Then, IDB\n∗∗ is defined as the transformation of IDB wrt S1.\nNote 3. Note that IDB is in general a (stratifiable) disjunctive logic program. The positive literals (A) appearing in the clauses are intuitively interpreted as an insertion of the corresponding atom (A) from the database.\nDefinition 20 (Update magic Hitting Set). An update magic set rule for a database IDB ∪ EDB and insertion request A is a magic set rule M for IDB∗ ∪ {A←} such that every close branch is finished. For every close finished branch b in M we define the magic set rule (of b in M) as HS(b) = {A ∈ EDB|A ∈ b}.\nDefinition 21 (Minimality test). Let M be an update magic set rule for IDB ∪ EDB and insert request A. We say that close finished branch b in M satisfies the strong minimality test iff ∀s ∈ HS(b) : IDB ∪EDB\\HS(b)∪ {s} ⊢ ¬A.\nDefinition 22 (Update magic set rule satisfying strong minimality). An update magic set rule for given IDB∪EDB and insert request A is transformed into an update magic set rule satisfying strong minimality by marking every close finished branch as open which does not satisfy strong minimality.\nThis means that every minimal model (minimal wrt the base atoms) of IDB∗ ∪ {¬A} provides a minimal hitting set for deleting the ground view atom A. Similarly, IDB∗∪{A} provides a minimal hitting set for inserting the ground view atom A. Now we are in a position to formally present our algorithm. Given a database and a view atom to be updated, we first transform the database into a definite disjunctive logic program and use hyper tableaux calculus to generate models of this transformed program for deletion of an atom. Second, magic set rule is used to generate models of this transformed program for insertion of an atom. Models that do not represent rational update are filtered out using the strong minimality test. This is formalized in Algorithm 3.\nTo show the rationality of this approach, we study how this is related to the previous approach presented in the last section, i.e. generating explanations and computing hitting sets of these explanations. To better understand the relationship it is imperative to study where the explanations are in the hyper tableau approach and magic set rule. We first define the notion of EDB -cut and then view update seeds.\nDefinition 23 (EDB-Cut). Let T be update tableau with open branches b1, b2, . . . , bn. A set S = {A1, A2, . . . , An} ⊆ EDB is said to be EDB-cut of T iff ¬Ai ∈ bi (Ai ∈ bi), for 1 ≤ i ≤ n.\nDefinition 24 (EDB seeds). Let M be an update seeds with close branches b1, b2, . . . , bn. A set S = {A1, A2, . . . , An} ⊆ EDB is said to be a EDB-seeds of M iff EDB seeds vu seeds(νD) with respect to νD is defined as follows:\nvu seeds(νD) := { ∇πp (c1, . . . , cn)|p(c1, . . . , cn) ∈ ν π D and π ∈ {+,−} } .\nAlgorithm 3 View update algorithm based on minimality test Input : A stratifiable (definite) deductive database DDB = IDB ∪ EDB ∪ IC\nan literals A Output: A new stratifiable (definite) database IDB ∪ EDB′ ∪ IC begin\n1. Let V := {c ∈ IC | IDB ∪ IC inconsistent with A wrt c } While (V , ∅) 2. Construct a complete SLD-tree for ← A wrt DDB. 3. For every successful branch i:construct ∆i = {D | D ∈ EDB}\nand D is used as an input clause in branch i. Construct a branch i of an update tableau satisfying minimality\nfor IDB ∪ EDB and delete request ¬A. Produce IDB ∪ EDB\\HS(i) as a result\n4. For every unsuccessful branch j:construct ∆j = {D | D ∈ EDB} and D is used as an input clause in branch j.\nConstruct a branch j of an update magic set rule satisfying minimality for IDB ∪ EDB and insert request A.\nProduce IDB ∪EDB\\HS(j) as a result Let V := {c ∈ IC | IDB ∪ IC inconsistent with A wrt c }\nreturn 5. Produce DDB as the result.\nend.\nLemma 2. Let T be an update tableau for IDB ∪EDB and update request A. Similarly, for M be an update magic set rule. Let S be the set of all EDBclosed minimal abductive explanations for A wrt. IDB. Let S′ be the set of all EDB-cuts of T and EDB-seeds of M . Then the following hold\n• S ⊆ S′.\n• ∀∆′ ∈ S′ : ∃∆ ∈ Ss.t.∆ ⊆ ∆′.\nThe above lemma precisely characterizes what explanations are generated by an update tableau. It is obvious then that a branch cuts through all the explanations and constitutes a hitting set for all the generated explanations. This is formalized below.\nLemma 3. Let S and S′ be sets of sets s.t. S ⊆ S′ and every member of S′\\S contains an element of S. Then, a set H is a minimal hitting set for S iff it is a minimal hitting set for S′.\nLemma 4. Let T be an update tableau for IDB ∪ EDB and update request A that satisfies the strong minimality test. Similarly, for M be an update magic set rule. Then, for every open (close) finished branch b in T , HS(b) (M , HS(b)) is a minimal hitting set of all the abductive explanations of A.\nSo, Algorithms 3 generate a minimal hitting set (in polynomial space) of all EDB-closed locally minimal abductive explanations of the view atom to be deleted. From the belief dynamics results recalled in section 3, it immediately follows that Algorithms 5 and 6 are rational, and satisfy the strong relevance postulate (KB-7.1).\nTheorem 3. Algorithms 3 is a rational, in the sense that they satisfy all the rationality postulates (KB*1)-(KB*6) and the strong relevance postulate (KB*7.1). Further, any update that satisfies these postulates can be computed by these algorithms."
    }, {
      "heading" : "5.3 Materialized view",
      "text" : "In many cases, the view to be updates is materialized, i.e., the least Herbrand Model is computed and kept, for efficient query answering. In such a situation, rational hitting sets can be computed without performing any minimality test. The idea is to transform the given IDB wrt the materialized view.\nDefinition 25 (IDB+ Transformation). Let IDB∪EDB be a given database. Let S be the Least Herbrand Model of this database. Then, IDB+ is defined as the transformation of IDB wrt S.\nNote 4. If IDB is a stratifiable deductive database then the transformation introduced above is not necessary.\nDefinition 26 (Update Tableau based on Materialized view). An update tableau based on materialized view for a database IDB∪EDB and delete request ¬A is a hyper tableau T for IDB+ ∪ {¬A ←} such that every open branch is finished.\nDefinition 27 (IDB− Transformation). Let IDB∪EDB be a given database. Let S1 be the Least Herbrand Model of this database. Then, IDB\n− is defined as the transformation of IDB wrt S1.\nDefinition 28 (Update magic set rule based on Materialized view). An update magic set rule based on materialized view for a database IDB ∪ EDB and insert request A is a magic set M for IDB+ ∪ {A←} such that every close branch is finished.\nNow the claim is that every model of IDB+ ∪ {¬A ←} (A ←) constitutes a rational hitting set for the deletion and insertion of the ground view atom A. So, the algorithm works as follows: Given a database and a view update request, we first transform the database wrt its Least Herbrand Model (computation of the Least Herbrand Model can be done as a offline preprocessing step. Note that it serves as materialized view for efficient query answering). Then the hyper tableaux calculus (magic set rule) is used to compute models of this transformed program. Each model represents a rational way of accomplishing the given view update request. This is formalized in Algorithms 4.\nThis approach for view update may not satisfy (KB*7.1) in general. But, as shown in the sequel, conformation to(KB*6.3) is guaranteed and thus this approach results in rational update.\nAlgorithm 4 View update algorithm based on Materialized view Input : A stratifiable (definite) deductive database DDB = IDB ∪ EDB ∪ IC\nan literals A Output: A new stratifiable (definite) database IDB ∪ EDB′ ∪ IC begin\n1. Let V := {c ∈ IC | IDB ∪ IC inconsistent with A wrt c } While (V , ∅) 2. Construct a complete SLD-tree for ← A wrt DDB. 3. For every successful branch i:construct ∆i = {D | D ∈ EDB}\nand D is used as an input clause in branch i. Construct a branch i of an update tableau based on view\nfor IDB ∪ EDB and delete request ¬A. Produce IDB ∪ EDB\\HS(i) as a result\n4. For every unsuccessful branch j:construct ∆j = {D | D ∈ EDB} and D is used as an input clause in branch j.\nConstruct a branch j of an update magic set rule based on view for IDB ∪ EDB and insert request A.\nProduce IDB ∪EDB\\HS(j) as a result Let V := {c ∈ IC | IDB ∪ IC inconsistent with A wrt c }\nreturn 5. Produce DDB as the result.\nend.\nLemma 5. Let T be an update tableau based on materialized view for IDB ∪ EDB and delete request ¬A (A), Similarly, for M be an update magic set rule. Let S be the set of all EDB-closed locally minimal abductive explanations for A wrt IDB. Let S′ be the set of all EDB-cuts of T and EDB-seeds of M . Then, the following hold:\n• S ⊆ S′. • ∀∆′ ∈ S′ : ∃∆ ∈ S s.t. ∆ ⊆ ∆′. • ∀∆′ ∈ S′ : ∆′ ⊆ ⋃ S.\nLemma 6. Let S and S′ be sets of sets s.t. S ∈ S′ and for every member X of S′\\S: X contains a member of S and X is contained in ⋃\nS. Then, a set H is a hitting set for S iff it is a hitting set for S′.\nLemma 7. Let T and M be defined as in Lemma 5. Then HS(b) is a rational hitting set for A, for every open finished branch b in T (close finished branch b in M).\nTheorem 4. Algorithms 4 is a rational, in the sense that they satisfy all the rationality postulates (KB*1) to (KB*6) and (KB*7.3)."
    }, {
      "heading" : "6 A Comparative Study of Integrity Constraints and View Update",
      "text" : "During the process of updating a database, two interrelated problems could arise. On one hand, when an update is applied to the database, integrity constraints could become inconsistent with request, then stop the process. On the other hand, when an update request consist on updating some derived predicate, a view updating mechanism must be applied to translate the update request into correct updates on the underlying base facts. Our work is not focusing on the integrity constraint maintenance approach. In this section, we extend Mayol and Teniente’s [83] survey for view updating and integrity constraint.\nThe main aspects that must be taken into account during the process of view updating and integrity constraint [48] enforcement are the following: the problem addressed, the considered database schema, the allowed update requests, the used technique, update change and the obtained solutions. These six aspects provide the basic dimensions to be taken into account. We explain each dimension in this section.\nProblem Addressed\n(Type) - What kind of program to be used (stratified(S), Horn clause(H), Disjunctive database(D), Normal Logic program(N) and Other (O)). (View Update) - Whether they are able to deal with view updating or not (indicated by Yes or No in the second column of Table 1). (integrity-constraint Enforcement) - Whether they incorporate an integrity constraint checking or an integrity constraint maintenance approach (indicated by check or maintain in the third column). (Run/Comp) - Whether the method follows a run-time(transaction) or a compiletime approach (indicated by Run or Compile in the fourth column).\nDatabase Schema Considered\n(Definition Language) - The language mostly used is logic, although some methods use a relational language and also uses an object-oriented. (The DB Schema Contains Views) - All methods that deal with view updating need views to be defined in the database schema. Some of other method allow to define views. (Restrictions Imposed on the Integrity Constraints) - Some proposals impose certain restrictions on the kind of integrity constraints that can be defined and, thus, handled by their methods. (Static vs Dynamic Integrity Constraints) - Integrity constraints may be either static, and impose restrictions involving only a certain state of the database, or dynamic.\nUpdate Request Allowed\n(Multiple Update Request) - An update request is multiple if it contains several updates to be applied together to the database.\n(Update Operators) - Traditionally, three different basic update operators are distinguished: insertion (ι), deletion (δ) and modification (χ). Modification can always be simulated by a deletion followed by an insertion.\nUpdate Processing Mechanism\n(Applied Technique) - The techniques applied by these methods can be classified according to four different kinds of procedures, unfolding, SLD, active and predefined programs, respectively. (Taking Base Facts into Account - Base facts can either be taken into account or not during update processing. (User Participation) - User participation during update processing or not.\nUpdate Changing Mechanism\n(Type of modification) - Changing table by singleton like atom (S), sets of each types of modification(SS) and group of changes(G). (Changing Base Fact) - Base fact can be changed either using principle of minimal change or complete change (maximal change). (Changing View Definition) - Whether update process view definition is changed or not.\nObtained Solution\n(Our Axiom follow) - When update process done, we are comparing our axiomatized method and which relevance policy holds ((KB*1) to (KB*6),(KB*7.1),(KB*7.2) and (KB*7.3) is enumerated 1 to 9) (Soundness) - A method is correct if it only obtains solutions that satisfy the requested update. (Completeness) - A method is complete if it is able to obtain all solutions that satisfy a given update request.\nResults of each method according to these features are summarized in Appendix Table 1."
    }, {
      "heading" : "7 Related Works",
      "text" : "We begin by recalling previous work on view deletion. Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson’s [54] belief change. Similar to our approach, he focused on set of formulae or sentences in knowledge base revision for view update wrt. insertion and deletion and formulae are considered at the same level. Chandrabose proposed different ways to change knowledge base via only database deletion, devising particular postulate which is shown to be necessary and sufficient for such an update process.\nOur Horn knowledge base consists of two parts, immutable part and updatable part , but focus is on principle of minimal change. There are more related works on that topic. Eiter [42], Langlois[67], and Delgrande [37] are focusing\non Horn revision with different perspectives like prime implication, logical closure and belief level. Segerberg [98] defined new modeling for belief revision in terms of irrevocability on prioritized revision. Hansson [54], constructed five types of non-prioritized belief revision. Makinson [77] developed dialogue form of revision AGM. Papini[89] defined a new version of knowledge base revision. Here, we consider immutable part as a Horn clause and updatable part as an atom(literals).\nWe are bridging gap between philosophical work, paying little attention to computational aspects of database work. In such a case, Hansson’s[54] kernel change is related with abductive method. Aliseda’s [4] book on abductive reasoning is one of the motivation keys. Christiansen’s [29] work on dynamics of abductive logic grammars exactly fits our minimal change (insertion and deletion). Wrobel’s [102] definition of first order theory revision was helpful to frame our algorithm.\nOn other hand, we are dealing with view update problem. Keller’s [62] thesis is motivation for view update problem. There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]). More similar to our work is paper presented by Bessant et al. [16] , local search-based heuristic technique that empirically proves to be often viable, even in the context of very large propositional applications. Laurent et al.[68] parented updating deductive databases in which every insertion or deletion of a fact can be performed in a deterministic way.\nFurthermore, and at a first sight more related to our work, some work has been done on ontology systems and description logics (Qi and Yang [90], and Kogalovsky [63]). Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese’s [20], and Cong [31]).\nThe significance of our work can be summarized in the following:\n- We have defined new way of insertion and deletion of an atom(literals) as per norm of principle of minimal change. - We have proposed new generalized revision algorithm for knowledge base dynamics, interesting connections with kernel change and abduction procedure. - We have written new view update algorithm for DDB, and we provided stratifiable (definite) deductive database, using our axiomatic method based on Hyper tableaux and magic sets. - Finally, we presented current Comparative Study of view update algorithms."
    }, {
      "heading" : "8 Conclusion and remarks",
      "text" : "The main contribution of this research is to provide a link between theory of belief dynamics and concrete applications such as view updates in databases. We argued for generalization of belief dynamics theory in two respects: to handle certain part of knowledge as immutable; and dropping the requirement that belief state be deductively closed. The intended generalization was achieved by\nintroducing the concept of knowledge base dynamics and generalized contraction for the same. Further, we also studied the relationship between knowledge base dynamics and abduction resulting in a generalized algorithm for revision based on abductive procedures. We also successfully demonstrated how knowledge base dynamics can provide an axiomatic characterization for updating an atom(literals) to a stratifiable (definite) deductive database.\nIn bridging the gap between belief dynamics and view updates, we have observed that a balance has to be achieved between computational efficiency and rationality. While rationally attractive notions of generalized revision prove to be computationally inefficient, the rationality behind efficient algorithms based on incomplete trees is not clear at all. From the belief dynamics point of view, we may have to sacrifice some postulates, vacuity for example, to gain computational efficiency. Further weakening of relevance has to be explored, to provide declarative semantics for algorithms based on incomplete trees.\nOn the other hand, from the database side, we should explore various ways of optimizing the algorithms that would comply with the proposed declarative semantics. We believe that partial deduction and loop detection techniques, will play an important role in optimizing algorithms of the previous section. Note that, loop detection could be carried out during partial deduction, and complete SLD-trees can be effectively constructed wrt a partial deduction (with loop check) of a database, rather than wrt database itself. Moreover, we would anyway need a partial deduction for optimization of query evaluation.\nWe have presented two variants of an algorithm for updating a view atom to a definite database. The key idea of this approach is to transform the given database into a disjunctive logic program in such a way that updates can be read off from the models of this transformed program. One variant based on materialized views is of polynomial time complexity. Moreover, we have also shown that this algorithm is rational in the sense that it satisfies the rationality postulates that are justified from philosophical angle.\nIn the second variant, where materialized view is used for the transformation, after generating a hitting set and removing corresponding EDB atoms, we easily move to the new materialized view. An obvious way is to recompute the view from scratch using the new EDB (i.e. compute the Least Herbrand Model of the new updated database from scratch) but it is certainly interesting to look for more efficient methods. In the end, we plan to redefined the model to Horn Logic with stratified Negation [60] and Argumentative Inference [46,57].\nThough we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [19] and [18]). It would also be interesting to study how results using soft stratification [11] with belief dynamics, especially the relational approach, could be applied in real world problems. Still, a lot of developments are possible, for improving existing operators or for defining new classes of change operators. As immediate extension, question raises: is there any real life application for AGM in 25 year theory? [47]. The revision and update are more challenging in logical view update prob-\nlem(database theory), so we can extend the theory to combine results similar to Konieczny’s [64] and Nayak’s [87].\nAppendix\nProof of Theorem 1. Sound and Completeness are trivially to shown from the definition.\nProof of Lemma 1.\n1. The fact that 0 ¬α and there exists a KB - closed locally minimal abductive explanation for α wrt KBI , it is clear that there exists at least one αkernel of KB. Suppose ∆ (∆ ∈ ∆+ ∪∆−) is empty (i.e., KBI ⊢ ¬α), then the required result follows immediately. If not, since ∆ is a locally minimal abductive explanation, there exists a minimal subset KB′I ⊆ KBI , s.t. ∆ is minimal abductive explanation of α wrt KB′I . Since, ∆ is KB-closed, it is not difficult to see that KB′I ∪∆\n+ ∪∆− is a α - kernel of KB. 2. Since X is a α - kernel of KB and ∆ is the set of all abducibles in X, it follows\nthat ∆+ ∪ ∆− is a minimal abductive explanation of ∆ wrt X\\∆− ∪ ∆+. It is obvious that ∆+ ∪∆− is KB- closed, and so ∆ is a KB-closed locally minimal abductive explanation for α wrt KBI .\nProof of Theorem 2. Sound and Completeness are trivially to shown from the Algorithm 1.\nProof of Lemma 2 and 5.\n1. Consider a ∆(∆ ∈ ∆i ∪∆j) ∈ S. We need to show that ∆ is generated by algorithm 3 at step 2. From lemma 1, it is clear that there exists a A-kernel X of DDBG s.t. X ∩ EDB = ∆j and X ∪ EDB = ∆i. Since X ⊢ A, there must exist a successful derivation for A using only the elements ofX as input clauses and similarly X 0 A. Consequently ∆ must have been constructed at step 2. 2. Consider a ∆′((∆′ ∈ ∆i ∪∆j) ∈ S′. Let ∆′ be constructed from a successful(unsuccessful) branch i via ∆i(∆j). Let X be the set of all input clauses used in the refutation i. Clearly X ⊢ A(X 0 A). Further, there exists a minimal (wrt set-inclusion) subset Y of X that derives A (i.e. no proper subset of Y derives A). Let ∆ = Y ∩EDB (Y ∪EDB). Since IDB does not(does) have any unit clauses, Y must contain some EDB facts, and so ∆ is not empty (empty) and obviously ∆ ⊆ ∆′. But, Y need not (need) be a A-kernel for IDBG since Y is not ground in general. But it stands for several A-kernels with the same (different) EDB facts ∆ in them. Thus, from lemma 1, ∆ is a DDB-closed locally minimal abductive explanation for A wrt IDBG and is contained in ∆′. 3. Since this proof easy to see materialized view update with minimal.\nProof of Lemma 3 and 6.\n1. (Only if part) Suppose H is a minimal hitting set for S. Since S ⊆ S′ , it follows that H ⊆ ⋃\nS′ . Further, H hits every element of S′ , which is evident from the fact that every element of S′ contains an element of S. Hence H is a hitting set for S′ . By the same arguments, it is not difficult to see that H is minimal for S′ too.\n(If part) Given that H is a minimal hitting set for S′ , we have to show that it is a minimal hitting set for S too. Assume that there is an element E ∈ H that is not in ⋃\nS. This means that E is selected from some Y ∈ S′\\S. But Y contains an element of S, say X . Since X is also a member of S′ , one member of X must appear in H . This implies that two elements have been selected from Y and hence H is not minimal. This is a contradiction and hence H ⊆ ⋃\nS. Since S ⊆ S′ , it is clear that H hits every element in S, and so H is a hitting set for S. It remains to be shown that H is minimal. Assume the contrary, that a proper subset H ′ of H is a hitting set for S. Then from the proof of the only if part, it follows that H ′ is a hitting set for S′ too, and contradicts the fact that H is a minimal hitting set for S′ . Hence, H must be a minimal hitting set for S.\n2. (If part) Given that H is a hitting set for S′ , we have to show that it is a hitting set for S too. First of all, observe that ⋃ S = ⋃\nS′ , and so H ⊆ ⋃\nS. Moreover, by definition, for every non-empty member X of S′ , H∩X is not empty. Since S ⊆ S′ , it follows that H is a hitting set for S too.\n(Only if part) Suppose H is a hitting set for S. As observed above, H ⊆ ⋃\nS′ . By definition, for every non-empty member X ∈ S, X ∩ H is not empty. Since every member of S′ contains a member of S, it is clear that H hits every member of S′ , and hence a hitting set for S′ .\nProof of Lemma 4 and 7. Follows from the lemma 3,4 (minimal test) and 6,7 (materialized view) of [11]\nProof of Theorem 3. Follows from Lemma 3 and Theorem 2.\nProof of Theorem 4. Follows from Lemma 6 and Theorem 2."
    }, {
      "heading" : "Acknowledgement",
      "text" : "The author acknowledges the support of RWTH Aachen, where he is visiting scholar with an Erasmus Mundus External Cooperation Window India4EU by the European Commission when the paper was written. I would like to thanks Chandrabose Aravindan and Gerhard Lakemeyer both my Indian and Germany PhD supervisor, give encourage to write the paper.\nMethod Problem Database schema Update req. Mechanism Update Change Solutions\nType View IC Run/ Def.\nView IC Kind of Mul. Update Tech- Base User Type Base View\nAxiom Sound. Complete. Update Enforce. Comp. Lang. def. IC Operat. nique Facts Part. facts def.\n[50] N Yes Check Run Logic Yes Yes Static No ι δ SLDNF No No S Yes No 1-6,9 No Not proved\n[61] N Yes Maintain Run Logic Yes Yes Static Yes ι δ SLDNF No No S Yes No — No No\n[65] S Yes Check Run Logic Yes Yes Static Yes ι δ — Yes No SS Yes Yes 1-6,7 Not Not proved proved [84] N No Maintain Run Logic Yes Yes Static Yes ι δ — Yes No S Yes No 1-6,7 No No proved proved [51] S Yes Check Comp. Relation. No No Static Yes ι δ χ predef.\nYes No G Yes No — No No Maintain Run Logic Programs\n[39] N Yes Check Run Logic Yes No Static Yes ι δ predef\nYes No S Yes No 1-6,7 Not\nNo Programs Proved\n[101] S Yes Check\nRun Logic Yes Yes Static Yes ι δ χ SLDNF No No SS Yes No 1-6,7 Yes No Maintain\n[52] N Yes Maintain Run Logic Yes No Static Yes ι δ Unfold Yes No SS Yes No 1-6,9 Yes Yes\n[82] N Yes Maintain Comp. Logic Yes Yes Static\nYes ι δ χ SLDNF Yes No S Yes No 1-6,9 Not Not\nRun Dynamic proved proved\n[103] S Yes Maintain Run Logic Yes Yes Static Yes ι δ Unfold. No Yes S Yes No 1-6,7 Not\nNo proved\n[6] H Yes Check Run Logic Yes Yes Static Yes ι δ SLD Yes No S Yes No 1-6,9 Yes Yes\n[22] N No Maintain Comp Relation\nYes Limited Static Yes ι δ χ Active Yes Yes S Yes No — No No Run Logic\n[49] N No Maintain Comp Relation No Flat Static\nYes ι δ χ Active Yes Yes S Yes No — No No Run Logic Limited Dynamic\n[25] H Yes Check Comp. O-O Class\nLimited Static Yes ι δ Active Yes No SS Yes No 1-6,9 No Yes Maintain Run Att.\n[32] N Yes Maintain Run Logic Yes Flat\nStatic Yes ι δ Unfold. Yes No S Yes No 1-6,9 Not\nYes Limited proved\n[74] N Yes Maintain Run Logic Yes Limited Static No ι δ Active Yes No SS Yes No 1-6,7 Yes Not proved [100] N Yes Maintain Comp Logic Yes Yes Static\nYes ι δ SLDNF Yes No S Yes No 1-6,9 Yes Yes Run Dynamic\n[94] S Yes Maintain Comp Logic No Flat\nStatic Yes ι δ predef\n— Yes G No Yes — No Not\nLimited Programs proved\nTab. 1. Summary of view-update and integrity constraint with our axiomatic methodAppendix B\nMethod Problem Database schema Update req. Mechanism Update Change Solutions\nType View IC Run/ Def.\nView IC Kind of Mul. Update Tech- Base User Type Base View\nAxiom Sound. Complete. Update Enforce. Comp. Lang. def. IC Operat. nique Facts Part. facts def.\n[99] N No Maintain Comp Logic Yes Limited Static Yes ι δ χ Predef\nYes No S Yes No 1-6,7 Yes No Program\n[8] H Yes Check Run Logic Yes Limited Static Yes ι δ SLD Yes No S Yes No 1-6,9 Yes Yes\n[33] N Yes Maintain Run Logic Yes Yes Static Yes ι δ SLDNF No No S Yes No 1-6,7 No Not Proved [72] N Yes Maintain Run Logic Yes Flat Static Yes ι δ Unfold No Yes G Yes No 1-6,7 Not\nNo Limited proved\n[104] H No Maintain Comp. Relation Yes Limited Static\nYes ι δ χ Unfold Yes No S Yes No 1-6,7 Not Not\nRun Dynamic proved proved\n[76] N No Maintain Comp Logic No Flat Static\nYes ι δ Active Yes No G No No — No No Restore Run Limited Dynamic\n[95] N No Maintain Comp Relation No Flat\nStatic Yes ι δ Active Yes No S No No — No No Run Limited\n[75] N Yes Check Run Logic Yes Limited Static Yes ι δ SLD Yes No S Yes No 1-6,9 Yes Yes\n[1] O No Maintain Run Logic Yes Limited Static Yes ι δ — Yes No S Yes No — No No\n[96] N No Maintain Comp Relation No Limited Static Yes ι δ Predef\nNo No G No No — No No Program\n[53] N No Maintain Comp Logic Yes Limited Static Yes ι δ — No No S No No — No No\n[26] N No Maintain Comp. Relation Yes Limited Static\nYes ι δ — Yes No S Yes No — Not Not\nRun Dynamic proved proved\n[40] H Yes Check Run Logic Yes Yes Static Yes ι δ Predef\nYes No S Yes No 1-6,7 Yes Not\nPrograms proved\n[55] O Yes Check Run Relation Yes Limited Static No ι δ Unfold Yes No S Yes No 1-6,9 Yes Yes\n[10] O Yes Check Run Relation Yes Limited Static No ι δ Unfold Yes No S Yes No 1-6,9 Yes Yes\n[43] N Yes Check Run Logic Yes Yes Static Yes ι δ SLDNF Yes No S Yes No 1-6,9 Yes Yes\n[91] N No Maintain Run Logic Yes Limited Static Yes ι δ Predef Yes No S Yes No 1-6,7 Yes Not\nPrograms proved\n[59] O No Maintain Comp Relation Yes Limited Static Yes ι δ — Yes No S Yes No — No No\nMethod Problem Database schema Update req. Mechanism Update Change Solutions\nType View IC Run/ Def.\nView IC Kind of Mul. Update Tech- Base User Type Base View\nAxiom Sound. Complete. Update Enforce. Comp. Lang. def. IC Operat. nique Facts Part. facts def.\n[92] N Yes Check Run Logic No Limited Static Yes ι δ SLDNF Yes No S Yes No 1-6,9 Yes Yes\n[44] N Yes Check Run Logic Yes Yes Static No ι δ SLDNF No No S Yes No 1-6,9 Not\nNo proved\n[80] N Yes Check\nRun Logic Yes Yes Static No ι δ χ SLD Yes No S Yes No — No No Maintain\n[17] N Yes Check Run\nLogic Yes Yes Static No ι δ χ SLD Yes No SS Yes No 1-6,7 Yes Not Maintain Comp proved\n[27] N Yes Check Run Logic Yes Yes Static\nYes ι δ χ Predef Yes No S Yes No 1-6,9 Yes Yes Maintain Dynamic Program\n[21] N Yes Check Comp Logic Yes Yes Dynamic Yes ι δ Predef Yes No S Yes No — Not\nNo Programs Proved proved\n[28] N Yes Check Run Logic Yes Yes Static\nYes ι δ χ Predef Yes No S Yes No 1-6,9 Yes Yes Maintain Dynamic Program\n[30] N No Maintain Comp Logic Yes No — Yes ι δ — Yes No S Yes No — No No\n[106] N No Maintain Run Relation Yes No — Yes ι δ χ Unfold Yes No SS No No — Not Not proved proved [56] O No Maintain Comp. Logic Yes No — Yes ι δ —- Yes No G No No — Yes Not\nRun proved\n[11] S Yes Check Run Logic Yes Flat\nStatic Yes ι δ SLDNF Yes No S Yes No 1-6,9 Yes Not\nLimited proved\n[41] N Yes Check Run Logic Yes Yes Static Yes ι δ — Yes No S Yes No — No No\n[23] O No Maintain Run Relation Yes No Static Yes ι δ SLD Yes Yes G No No — Not Not proved proved\n[12] O No Maintain Comp Relation Yes No Static Yes ι δ χ — Yes No SS Yes No — No No\n[3] O No Maintain Comp. Relation No Limited Static\nYes ι δ — Yes No G Yes No — No No Run Dynamic\n[78] N No Maintain Comp Relation No Yes Static Yes ι δ χ Unfold No Yes SS No No — No No\n[93] N No Check Comp Logic No Yes Static Yes ι δ Active Yes No G Yes No — No No\n[36] N Yes Check Run Logic Yes Yes Static Yes ι δ SLD Yes No S Yes No 1-6,9 Yes Yes"
    } ],
    "references" : [ {
      "title" : "Automated selection of materialized views and indexes in SQL databases, Intl",
      "author" : [ "S Agrawal" ],
      "venue" : "Conference on Very Large Data Bases (VLDB),",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2008
    }, {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "C.E. Alchourron" ],
      "venue" : "Journal of Symbolic Logic 50,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1985
    }, {
      "title" : "Filtering XML content for publication and presentation on the web, ICDIM, 85-89",
      "author" : [ "L. Alexandre", "J. Coelho" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2011
    }, {
      "title" : "Abductive Resoning Logic Investigations into Discovery and Explanation",
      "author" : [ "A. Aliseda" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2006
    }, {
      "title" : "A new approach for preference-based argumentation frameworks",
      "author" : [ "L. Amgoud", "S. Vesic" ],
      "venue" : "Ann. Math. Artif. Intell.,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Belief Dynamics, Abduction, and Database",
      "author" : [ "C. Aravindan", "Dung", "P.M" ],
      "venue" : "JELIA,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1994
    }, {
      "title" : "Dynamics of Belief: Epistmology, Abduction and Database Update",
      "author" : [ "Aravindan C" ],
      "venue" : "Phd Thesis,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1995
    }, {
      "title" : "A Rational and Efficient Algorithm for View Deletion in Databases",
      "author" : [ "C. Aravindan", "P. Baumgartner" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1997
    }, {
      "title" : "Semantically Guided Theorem Proving for Diagnosis Applications",
      "author" : [ "P Baumgartner" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1997
    }, {
      "title" : "On solving the view selection problem in distributed data warehouse architectures",
      "author" : [ "A. Bauer", "W. Lehne" ],
      "venue" : null,
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2003
    }, {
      "title" : "A Transformation-Based Approach to View Updating in Stratifiable Deductive Databases",
      "author" : [ "A. Behrend", "R. Manthey" ],
      "venue" : null,
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2008
    }, {
      "title" : "A cooperative approach to view selection and placement in P2P systems",
      "author" : [ "Z Bellahsene" ],
      "venue" : null,
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2010
    }, {
      "title" : "Agent-based communities of web services: an argumentation-driven approach",
      "author" : [ "J Bentahar" ],
      "venue" : "Service Oriented Computing and Applications,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Using argumentation to model and deploy agent-based B2B applications",
      "author" : [ "J Bentahar" ],
      "venue" : "Knowl.-Based Syst.,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2010
    }, {
      "title" : "A taxonomy of argumentation models used for knowledge representation, Artif",
      "author" : [ "J Bentahar" ],
      "venue" : "Intell. Rev,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2010
    }, {
      "title" : "Combining Nonmonotonic Reasoning and Belief Revision: A Practical Approach",
      "author" : [ "B. Bessant" ],
      "venue" : "AIMSA,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1998
    }, {
      "title" : "Efficient Integrity Checking over XML Documents",
      "author" : [ "D Braga" ],
      "venue" : "EDBT Workshops,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2006
    }, {
      "title" : "Inference-usability confinement by maintaining inference-proof views of an information system. IJCSE",
      "author" : [ "J. Biskup" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2012
    }, {
      "title" : "The View-Update Problem for Indefinite Databases. JELIA",
      "author" : [ "L. Caroprese" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2012
    }, {
      "title" : "View-based query answering in Description Logics Semantics and complexity",
      "author" : [ "D Calvanese" ],
      "venue" : "J. Comput. Syst. Sci",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2012
    }, {
      "title" : "Automatic Generation of Production Rules for Integrity Maintenance",
      "author" : [ "S Ceri" ],
      "venue" : "ACM Transactions on Database Systems",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1994
    }, {
      "title" : "Towards materialized view selection for distributed databases",
      "author" : [ "Chaves", "L.W.F" ],
      "venue" : null,
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2009
    }, {
      "title" : "A Comparative Study of View Update Problem",
      "author" : [ "H. Chen", "H. Liao" ],
      "venue" : "DSDE,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2010
    }, {
      "title" : "An Execution Model for Limited Ambiguity Rules and Its Application to Derived Data Update",
      "author" : [ "Chen", "I.A" ],
      "venue" : "ACM Transactions on Database Systems",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1995
    }, {
      "title" : "The view-selection problem has an exponential-time lower bound for conjunctive queries and views",
      "author" : [ "R. Chirkova" ],
      "venue" : "ACM Symposium on Principles of Database Systems (PODS),",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2002
    }, {
      "title" : "On Simplification of Database Integrity Constraints",
      "author" : [ "H. Christiansen", "D. Martinenghi" ],
      "venue" : "Fundam. Inform",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2006
    }, {
      "title" : "Integrity Checking and Maintenance with Active Rules in XML Databases",
      "author" : [ "H. Christiansen", "M. Rekouts" ],
      "venue" : "BNCOD Workshops,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2007
    }, {
      "title" : "Type-Based Static and Dynamic Website Verification, ICIW",
      "author" : [ "J. Coelho", "M. Florido" ],
      "venue" : null,
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2007
    }, {
      "title" : "On the Complexity of View Update Analysis and Its Application to Annotation Propagation",
      "author" : [ "G Cong" ],
      "venue" : "IEEE Trans. Knowl. Data",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2012
    }, {
      "title" : "The Role of Abduction in Database View Updating",
      "author" : [ "L Console" ],
      "venue" : "Journal of Intelligent Information Systems",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 1995
    }, {
      "title" : "One Abductive Logic Programming Procedure for two kind of Updates",
      "author" : [ "H. Decker" ],
      "venue" : "Proc. Workshop DINAMICS’97 at Int. Logic Programming Symposium",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1997
    }, {
      "title" : "A Rational and Efficient Algorithm for View Revision in Databases",
      "author" : [ "R. Delhibabu", "G. Lakemeyer" ],
      "venue" : "Applied Mathematics & Information Sciences",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2013
    }, {
      "title" : "An Abductive Framework for Knowledge Base Dynamics",
      "author" : [ "R. Delhibabu" ],
      "venue" : "Applied Mathematics & Information Sciences (accepted)",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2014
    }, {
      "title" : "A New Rational Algorithm for View Updating in Relational Databases",
      "author" : [ "R. Delhibabu", "A. Behrend" ],
      "venue" : "Applied Intelligence (accepted)",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2014
    }, {
      "title" : "Materialized View Selection in Data Warehousing: A Survey",
      "author" : [ "C.A. Dhote", "M.S. Ali" ],
      "venue" : "Journal of Applied Sciences,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2009
    }, {
      "title" : "Incremental evaluation of datalog queries",
      "author" : [ "G. Dong", "R.W. Topor" ],
      "venue" : "In Database Theory - ICDT,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 1992
    }, {
      "title" : "Integrity Constraint Enforcement by Means of Trigger Templates",
      "author" : [ "E Domı́nguez" ],
      "venue" : "ADVIS,",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2002
    }, {
      "title" : "Model-Driven, View-Based Evolution of Relational Databases, DEXA, 822-836",
      "author" : [ "E Domı́nguez" ],
      "venue" : null,
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2008
    }, {
      "title" : "On computing all abductive explanations from a propositional Horn theory",
      "author" : [ "T. Eiter", "K. Makino" ],
      "venue" : "J. ACM",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2007
    }, {
      "title" : "Handling Existential Derived Predicates in View Updating",
      "author" : [ "C Farré" ],
      "venue" : null,
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2003
    }, {
      "title" : "A New Approach for Checking Schema Validation Properties",
      "author" : [ "C Farré" ],
      "venue" : null,
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2004
    }, {
      "title" : "Prioritized and Non-prioritized",
      "author" : [ "M.A. Falappa" ],
      "venue" : "Multiple Change on Belief Bases. J. Philosophical Logic",
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 2012
    }, {
      "title" : "Stratified Belief Bases Revision with Argumentative Inference",
      "author" : [ "M Falappa" ],
      "venue" : "J. Philosophical Logic,",
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 2013
    }, {
      "title" : "AGM 25 Years - Twenty-Five Years of Research in Belief Change",
      "author" : [ "E.L. Ferme", "S.O. Hansson" ],
      "venue" : "J. Philosophical Logic",
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 2011
    }, {
      "title" : "A Review of Repairing Techniques for Integrity Maintenance, RIDS",
      "author" : [ "P. Fraternali", "S. Paraboschi" ],
      "venue" : null,
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 1993
    }, {
      "title" : "Specifying Reactive Integrity Control for Active Databases, RIDE, 62-70",
      "author" : [ "M. Gertz" ],
      "venue" : null,
      "citeRegEx" : "49",
      "shortCiteRegEx" : "49",
      "year" : 1994
    }, {
      "title" : "Updating Knowledge Bases, New Generation",
      "author" : [ "A. Guessoum", "J.W. Lloyd" ],
      "venue" : "Computing Vol,",
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 1990
    }, {
      "title" : "Counting solutions to the view maintenance problem",
      "author" : [ "A Gupta" ],
      "venue" : "In Workshop on Deductive Databases,",
      "citeRegEx" : "51",
      "shortCiteRegEx" : "51",
      "year" : 1992
    }, {
      "title" : "Maintaining views incrementally",
      "author" : [ "A Gupta" ],
      "venue" : "ACM SIGMOD,",
      "citeRegEx" : "52",
      "shortCiteRegEx" : "52",
      "year" : 1993
    }, {
      "title" : "Answering queries using views: A survey",
      "author" : [ "A.Y. Halevy" ],
      "venue" : null,
      "citeRegEx" : "53",
      "shortCiteRegEx" : "53",
      "year" : 2001
    }, {
      "title" : "Textbook of Belief Dynamics",
      "author" : [ "S.O. Hansson" ],
      "venue" : null,
      "citeRegEx" : "54",
      "shortCiteRegEx" : "54",
      "year" : 1997
    }, {
      "title" : "Uniqueness of Update Strategies for Database Views",
      "author" : [ "S.J. Hegner" ],
      "venue" : "FoIKS,",
      "citeRegEx" : "55",
      "shortCiteRegEx" : "55",
      "year" : 2002
    }, {
      "title" : "A Model of Database Components and their Interconnection Based upon Communicating Views",
      "author" : [ "S.J. Hegner" ],
      "venue" : "EJC,",
      "citeRegEx" : "56",
      "shortCiteRegEx" : "56",
      "year" : 2007
    }, {
      "title" : "Research opportunities for argumentation in social networks",
      "author" : [ "S Heras" ],
      "venue" : "Artif. Intell. Rev.,",
      "citeRegEx" : "57",
      "shortCiteRegEx" : "57",
      "year" : 2013
    }, {
      "title" : "Propositional Belief Base Update and Minimal Change",
      "author" : [ "A. Herzig", "O. Rifi" ],
      "venue" : "Artif. Intell",
      "citeRegEx" : "58",
      "shortCiteRegEx" : "58",
      "year" : 1999
    }, {
      "title" : "Applying evolutionary algorithms to materialized view selection in a data warehouse",
      "author" : [ "Horng", "J. T" ],
      "venue" : "Soft Comput,",
      "citeRegEx" : "59",
      "shortCiteRegEx" : "59",
      "year" : 2003
    }, {
      "title" : "Model Generation for Horn Logic with Stratified Negation. FORTE",
      "author" : [ "E.K. Jackson", "W. Schulte" ],
      "venue" : null,
      "citeRegEx" : "60",
      "shortCiteRegEx" : "60",
      "year" : 2008
    }, {
      "title" : "Database Updates Through Abduction",
      "author" : [ "A.C. Kakas", "P. Mancarella" ],
      "venue" : "VLDB Conference,",
      "citeRegEx" : "61",
      "shortCiteRegEx" : "61",
      "year" : 1990
    }, {
      "title" : "Relational Databases Through Views",
      "author" : [ "A. Keller" ],
      "venue" : "Phd Thesis",
      "citeRegEx" : "62",
      "shortCiteRegEx" : "62",
      "year" : 1985
    }, {
      "title" : "Ontology-based data access systems",
      "author" : [ "M.R. Kogalovsky" ],
      "venue" : "Programming and Computer Software",
      "citeRegEx" : "63",
      "shortCiteRegEx" : "63",
      "year" : 2012
    }, {
      "title" : "Dynamics of Beliefs",
      "author" : [ "S. Konieczny" ],
      "venue" : null,
      "citeRegEx" : "64",
      "shortCiteRegEx" : "64",
      "year" : 2011
    }, {
      "title" : "Horn Complements: Towards Horn-to-Horn Belief Revision",
      "author" : [ "M Langlois" ],
      "venue" : null,
      "citeRegEx" : "67",
      "shortCiteRegEx" : "67",
      "year" : 2008
    }, {
      "title" : "Updating Intensional Predicates in Deductive Databases",
      "author" : [ "D Laurent" ],
      "venue" : "Data Knowl. Eng",
      "citeRegEx" : "68",
      "shortCiteRegEx" : "68",
      "year" : 1998
    }, {
      "title" : "Speeding up materialized view selection in data warehouses using a randomized algorithm",
      "author" : [ "M. Lee", "J. Hammer" ],
      "venue" : "Int. J. Cooperative Inf. Syst.,",
      "citeRegEx" : "69",
      "shortCiteRegEx" : "69",
      "year" : 2001
    }, {
      "title" : "The Complexity of Belief Update (Extended in 2003)",
      "author" : [ "P. Liberatore" ],
      "venue" : "IJCAI vol",
      "citeRegEx" : "70",
      "shortCiteRegEx" : "70",
      "year" : 1997
    }, {
      "title" : "The Compactness of Belief Revision and Update Operators",
      "author" : [ "P. Liberatore", "M. Schaerf" ],
      "venue" : "Fundam. Inform",
      "citeRegEx" : "71",
      "shortCiteRegEx" : "71",
      "year" : 2004
    }, {
      "title" : "Minimal and Consistent Evolution of Knowledge Bases",
      "author" : [ "J. Lobo", "G. Trajcevski" ],
      "venue" : "Journal of Applied Non-Classical Logics",
      "citeRegEx" : "72",
      "shortCiteRegEx" : "72",
      "year" : 1997
    }, {
      "title" : "Materialized View Selection: A Survey, IGI book chapter, View Management Techniques and Their Application to Data Stream Management, DOI: 10.4018/978-1-60566-816-1.ch005",
      "author" : [ "X. Li" ],
      "venue" : null,
      "citeRegEx" : "73",
      "shortCiteRegEx" : "73",
      "year" : 2010
    }, {
      "title" : "Efficient maintenance of materialized mediated",
      "author" : [ "J Lu" ],
      "venue" : "views. ACM SIGMOD,",
      "citeRegEx" : "74",
      "shortCiteRegEx" : "74",
      "year" : 1995
    }, {
      "title" : "View Updates in Disjunctive Deductive Databases Based on SLDResolution",
      "author" : [ "W. Lu" ],
      "venue" : "KRDB,",
      "citeRegEx" : "75",
      "shortCiteRegEx" : "75",
      "year" : 1999
    }, {
      "title" : "Maintaining and Restoring Database Consistency with Update Rules, Workshop DYNAMICS, JICSLP",
      "author" : [ "S. Maabout" ],
      "venue" : null,
      "citeRegEx" : "76",
      "shortCiteRegEx" : "76",
      "year" : 1998
    }, {
      "title" : "Modeling view selection as a constraint satisfaction",
      "author" : [ "I Mami" ],
      "venue" : "problem. DEXA,",
      "citeRegEx" : "78",
      "shortCiteRegEx" : "78",
      "year" : 2011
    }, {
      "title" : "A survey of view selection methods",
      "author" : [ "I. Mami", "Bellahsene. Z" ],
      "venue" : "SIGMOD Record",
      "citeRegEx" : "79",
      "shortCiteRegEx" : "79",
      "year" : 2012
    }, {
      "title" : "Efficient Integrity Checking for Databases with",
      "author" : [ "D. Martinenghi", "H. Christiansen" ],
      "venue" : "Recursive Views. ADBIS,",
      "citeRegEx" : "80",
      "shortCiteRegEx" : "80",
      "year" : 2005
    }, {
      "title" : "A General Framework for Reasoning On Inconsistency",
      "author" : [ "M Martinez" ],
      "venue" : "Springer Briefs in Computer Science,",
      "citeRegEx" : "81",
      "shortCiteRegEx" : "81",
      "year" : 2013
    }, {
      "title" : "Incorporating Modification Requests in Updating Consistent Knowledge Bases",
      "author" : [ "E. Mayol", "E. Teniente" ],
      "venue" : "Fourth Int. Works. on the Deductive Approach to Information Systems and Databases,",
      "citeRegEx" : "82",
      "shortCiteRegEx" : "82",
      "year" : 1993
    }, {
      "title" : "A Survey of Current Methods for Integrity Constraint Maintenance and View Updating",
      "author" : [ "E. Mayol", "E. Teniente" ],
      "venue" : "ER (Workshops),",
      "citeRegEx" : "83",
      "shortCiteRegEx" : "83",
      "year" : 1999
    }, {
      "title" : "Reactive Consistency Control in Deductive Databases",
      "author" : [ "G. Moerkotte", "Lockemann", "P.C" ],
      "venue" : "ACM Transactions on Database Systems,",
      "citeRegEx" : "84",
      "shortCiteRegEx" : "84",
      "year" : 1991
    }, {
      "title" : "Transaction Trees for Knowledge Revision",
      "author" : [ "L Mota-Herranz" ],
      "venue" : "FQAS,",
      "citeRegEx" : "85",
      "shortCiteRegEx" : "85",
      "year" : 2000
    }, {
      "title" : "Forgetting and Knowledge Update",
      "author" : [ "A Nayak" ],
      "venue" : "Australian Conference on Artificial Intelligence,",
      "citeRegEx" : "86",
      "shortCiteRegEx" : "86",
      "year" : 2006
    }, {
      "title" : "Is Revision a Special Kind of Update",
      "author" : [ "A. Nayak" ],
      "venue" : "Australasian Conference on Artificial Intelligence,",
      "citeRegEx" : "87",
      "shortCiteRegEx" : "87",
      "year" : 2011
    }, {
      "title" : "How Hard is it to Revise a Belief Base",
      "author" : [ "B. Nebel" ],
      "venue" : "Handbook of Defeasible Reasoning and Uncertainty Management Systems,",
      "citeRegEx" : "88",
      "shortCiteRegEx" : "88",
      "year" : 1998
    }, {
      "title" : "Knowledge-base revision. The Knowledge Engineering",
      "author" : [ "Papini" ],
      "venue" : "Review 15(4),",
      "citeRegEx" : "89",
      "shortCiteRegEx" : "89",
      "year" : 2000
    }, {
      "title" : "A Survey of Revision Approaches in Description Logics. Description Logics",
      "author" : [ "G. Qi", "F. Yang" ],
      "venue" : null,
      "citeRegEx" : "90",
      "shortCiteRegEx" : "90",
      "year" : 2008
    }, {
      "title" : "Incremental Evaluation of Tabled Logic Programs",
      "author" : [ "D. Saha", "C.R. Ramakrishnan" ],
      "venue" : null,
      "citeRegEx" : "91",
      "shortCiteRegEx" : "91",
      "year" : 2003
    }, {
      "title" : "An abductive framework for computing knowledge base updates",
      "author" : [ "C. Sakama", "K. Inoue" ],
      "venue" : "TPLP",
      "citeRegEx" : "92",
      "shortCiteRegEx" : "92",
      "year" : 2003
    }, {
      "title" : "Database Integrity Mechanism between OLTP and Offline Data, ACIIDS",
      "author" : [ "M Salman" ],
      "venue" : null,
      "citeRegEx" : "93",
      "shortCiteRegEx" : "93",
      "year" : 2012
    }, {
      "title" : "Tailoring Consistent Specializations as a Natural Approach to Consistency Enforcement, 6th Int. Workshop on Foundations of Models and Languages for Data and Objects: Integrity in Databases",
      "author" : [ "K.D. Schewe" ],
      "venue" : null,
      "citeRegEx" : "94",
      "shortCiteRegEx" : "94",
      "year" : 1996
    }, {
      "title" : "Consistency Enforcement in Entity-Relationship and Object Oriented Models, Data & Knowledge Eng 28(1),121-140",
      "author" : [ "K.D. Schewe" ],
      "venue" : null,
      "citeRegEx" : "95",
      "shortCiteRegEx" : "95",
      "year" : 1998
    }, {
      "title" : "Minimal Belief Change and Pareto-Optimality",
      "author" : [ "O. Schulte" ],
      "venue" : "Australian Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "97",
      "shortCiteRegEx" : "97",
      "year" : 1999
    }, {
      "title" : "Irrevocable Belief Revision in Dynamic Doxastic Logic",
      "author" : [ "K. Segerberg" ],
      "venue" : "Notre Dame Journal of Formal Logic",
      "citeRegEx" : "98",
      "shortCiteRegEx" : "98",
      "year" : 1998
    }, {
      "title" : "Incremental maintenance of externally materialized views",
      "author" : [ "M. Staudt", "Jarke. M" ],
      "venue" : "VLDB Journal,",
      "citeRegEx" : "99",
      "shortCiteRegEx" : "99",
      "year" : 1996
    }, {
      "title" : "Updating Knowledge Bases while Maintaining their Consistency",
      "author" : [ "E. Teniente", "A. Olive" ],
      "venue" : "The VLDB Journal,",
      "citeRegEx" : "100",
      "shortCiteRegEx" : "100",
      "year" : 1995
    }, {
      "title" : "A method for change computation in deductive databases. VLDB, 225ï£·1ï£·77",
      "author" : [ "Urṕı", "A. Olivé" ],
      "venue" : null,
      "citeRegEx" : "101",
      "shortCiteRegEx" : "101",
      "year" : 1992
    }, {
      "title" : "First order Theory Refinement",
      "author" : [ "S. Wrobel" ],
      "venue" : "IOS Frontier in AI and Application Series",
      "citeRegEx" : "102",
      "shortCiteRegEx" : "102",
      "year" : 1995
    }, {
      "title" : "On Updates and Inconsistency",
      "author" : [ "B. Wüthrich" ],
      "venue" : "Repairing in Knowledge Bases,",
      "citeRegEx" : "103",
      "shortCiteRegEx" : "103",
      "year" : 1993
    }, {
      "title" : "Algorithms for materialized view design in data warehousing environment",
      "author" : [ "J Yang" ],
      "venue" : null,
      "citeRegEx" : "104",
      "shortCiteRegEx" : "104",
      "year" : 1997
    }, {
      "title" : "Genetic algorithm for materialized view selection in data warehouse",
      "author" : [ "C. Zhang", "Y. Yang" ],
      "venue" : "environments, DaWaK,",
      "citeRegEx" : "105",
      "shortCiteRegEx" : "105",
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework.",
      "startOffset" : 70,
      "endOffset" : 82
    }, {
      "referenceID" : 12,
      "context" : "In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework.",
      "startOffset" : 70,
      "endOffset" : 82
    }, {
      "referenceID" : 13,
      "context" : "In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework.",
      "startOffset" : 70,
      "endOffset" : 82
    }, {
      "referenceID" : 14,
      "context" : "In the argumentation theory people trying to solve the same principle [5,13,14,15] in different framework.",
      "startOffset" : 70,
      "endOffset" : 82
    }, {
      "referenceID" : 74,
      "context" : "Revision means modifying the knowledge base in order to maintain consistency [81], while keeping the new information and removing (contraction) or not removing the least possible previous information.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 5,
      "context" : "Previous work [6,7] makes connections with contraction from knowledge base dynamics.",
      "startOffset" : 14,
      "endOffset" : 19
    }, {
      "referenceID" : 6,
      "context" : "Previous work [6,7] makes connections with contraction from knowledge base dynamics.",
      "startOffset" : 14,
      "endOffset" : 19
    }, {
      "referenceID" : 31,
      "context" : "⋆ This paper extends work from Delhibabu [34] and Mayol [83]",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 76,
      "context" : "⋆ This paper extends work from Delhibabu [34] and Mayol [83]",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 81,
      "context" : "Our knowledge base dynamics is defined in two parts: an immutable part (formulae) and updatable part (literals) (for definition and properties see works of Nebel [88] and Segerberg [98]).",
      "startOffset" : 162,
      "endOffset" : 166
    }, {
      "referenceID" : 90,
      "context" : "Our knowledge base dynamics is defined in two parts: an immutable part (formulae) and updatable part (literals) (for definition and properties see works of Nebel [88] and Segerberg [98]).",
      "startOffset" : 181,
      "endOffset" : 185
    }, {
      "referenceID" : 54,
      "context" : "The principle of minimal change [58,97] can provide a reasonable strategy.",
      "startOffset" : 32,
      "endOffset" : 39
    }, {
      "referenceID" : 89,
      "context" : "The principle of minimal change [58,97] can provide a reasonable strategy.",
      "startOffset" : 32,
      "endOffset" : 39
    }, {
      "referenceID" : 1,
      "context" : "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of Carlos Alchourrón, Peter Gärdenfors, and David Makinson (AGM) [2]; what result has to be chosen [66,72,86]; and finally, according to a practical point of view, what computational model to support for knowledge base revision has to be provided?",
      "startOffset" : 252,
      "endOffset" : 255
    }, {
      "referenceID" : 66,
      "context" : "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of Carlos Alchourrón, Peter Gärdenfors, and David Makinson (AGM) [2]; what result has to be chosen [66,72,86]; and finally, according to a practical point of view, what computational model to support for knowledge base revision has to be provided?",
      "startOffset" : 286,
      "endOffset" : 296
    }, {
      "referenceID" : 79,
      "context" : "On the other hand, practical implementations have to handle contradictory, uncertain, or imprecise information, so several problems can arise: how to define efficient change in the style of Carlos Alchourrón, Peter Gärdenfors, and David Makinson (AGM) [2]; what result has to be chosen [66,72,86]; and finally, according to a practical point of view, what computational model to support for knowledge base revision has to be provided?",
      "startOffset" : 286,
      "endOffset" : 296
    }, {
      "referenceID" : 10,
      "context" : "The basic idea in [11,8] is to employ the model generation property of hyper tableaux and magic set to generate models, and read off diagnosis from them.",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 7,
      "context" : "The basic idea in [11,8] is to employ the model generation property of hyper tableaux and magic set to generate models, and read off diagnosis from them.",
      "startOffset" : 18,
      "endOffset" : 24
    }, {
      "referenceID" : 1,
      "context" : "Perhaps the most basic operation in Horn knowledge base change, like belief change, is that of contraction (AGM [2]), which is intended to represent situations in which an agent has to give up φ from its current stock of beliefs (denoted as KB-φ).",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 41,
      "context" : "Then, the revision can be trivially achieved by expansion, and the axiomatic characterization could be straightforwardly obtained from the corresponding characterizations of the traditional models [45].",
      "startOffset" : 197,
      "endOffset" : 201
    }, {
      "referenceID" : 1,
      "context" : "AGM [2] proposed a formal framework in which revision(contraction) is interpreted as belief change.",
      "startOffset" : 4,
      "endOffset" : 7
    }, {
      "referenceID" : 6,
      "context" : "Focusing on the logical structure of beliefs, they formulate eight postulates which a revision knowledge base (contraction knowledge base was discussed in [7]) has to verify.",
      "startOffset" : 155,
      "endOffset" : 158
    }, {
      "referenceID" : 6,
      "context" : "So, relaxing this condition (example with more details can be found in [7]) allows for weakening strong relevance to relevance only.",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 3,
      "context" : "The relationship between Horn knowledge base dynamics and abduction was introduced by the philosopher Pierce (see [4]).",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 78,
      "context" : "All solutions translate [85] a view update request into a transaction combining insertions and deletions of base relations for satisfying the request.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 10,
      "context" : "View updating [11] aims at determining one or more base relation updates such that all given update requests with respect to derived relations are satisfied after the base updates have been successfully applied.",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 8,
      "context" : "In [9,8] a variant of clausal normal form tableaux called ”hyper tableaux” is introduced.",
      "startOffset" : 3,
      "endOffset" : 8
    }, {
      "referenceID" : 7,
      "context" : "In [9,8] a variant of clausal normal form tableaux called ”hyper tableaux” is introduced.",
      "startOffset" : 3,
      "endOffset" : 8
    }, {
      "referenceID" : 7,
      "context" : "We start presenting an algorithm for stratifiable (definite) deductive databases by first defining precisely how the given database is transformed into a disjunctive logic program for the view deletion process [8] (successful branch - see in Algorithms 3 and 4 via Hyper Tableau).",
      "startOffset" : 210,
      "endOffset" : 213
    }, {
      "referenceID" : 10,
      "context" : "Next step is view insertion process [11] (For unsuccessful branches - see in Algorithms 3 and 4 via magic set).",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 76,
      "context" : "In this section, we extend Mayol and Teniente’s [83] survey for view updating and integrity constraint.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 44,
      "context" : "The main aspects that must be taken into account during the process of view updating and integrity constraint [48] enforcement are the following: the problem addressed, the considered database schema, the allowed update requests, the used technique, update change and the obtained solutions.",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 5,
      "context" : "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson’s [54] belief change.",
      "startOffset" : 12,
      "endOffset" : 17
    }, {
      "referenceID" : 6,
      "context" : "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson’s [54] belief change.",
      "startOffset" : 12,
      "endOffset" : 17
    }, {
      "referenceID" : 31,
      "context" : "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson’s [54] belief change.",
      "startOffset" : 32,
      "endOffset" : 42
    }, {
      "referenceID" : 32,
      "context" : "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson’s [54] belief change.",
      "startOffset" : 32,
      "endOffset" : 42
    }, {
      "referenceID" : 33,
      "context" : "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson’s [54] belief change.",
      "startOffset" : 32,
      "endOffset" : 42
    }, {
      "referenceID" : 50,
      "context" : "Chandrabose [6,7] and Delhibabu [34,35,36], defines a contraction and revision operator in view deletion with respect to a set of formulae or sentences using Hansson’s [54] belief change.",
      "startOffset" : 168,
      "endOffset" : 172
    }, {
      "referenceID" : 38,
      "context" : "Eiter [42], Langlois[67], and Delgrande [37] are focusing",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 61,
      "context" : "Eiter [42], Langlois[67], and Delgrande [37] are focusing",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 90,
      "context" : "Segerberg [98] defined new modeling for belief revision in terms of irrevocability on prioritized revision.",
      "startOffset" : 10,
      "endOffset" : 14
    }, {
      "referenceID" : 50,
      "context" : "Hansson [54], constructed five types of non-prioritized belief revision.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 82,
      "context" : "Papini[89] defined a new version of knowledge base revision.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 50,
      "context" : "In such a case, Hansson’s[54] kernel change is related with abductive method.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 3,
      "context" : "Aliseda’s [4] book on abductive reasoning is one of the motivation keys.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 94,
      "context" : "Wrobel’s [102] definition of first order theory revision was helpful to frame our algorithm.",
      "startOffset" : 9,
      "endOffset" : 14
    }, {
      "referenceID" : 58,
      "context" : "Keller’s [62] thesis is motivation for view update problem.",
      "startOffset" : 9,
      "endOffset" : 13
    }, {
      "referenceID" : 22,
      "context" : "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 76,
      "context" : "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).",
      "startOffset" : 172,
      "endOffset" : 176
    }, {
      "referenceID" : 34,
      "context" : "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).",
      "startOffset" : 221,
      "endOffset" : 241
    }, {
      "referenceID" : 49,
      "context" : "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).",
      "startOffset" : 221,
      "endOffset" : 241
    }, {
      "referenceID" : 67,
      "context" : "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).",
      "startOffset" : 221,
      "endOffset" : 241
    }, {
      "referenceID" : 63,
      "context" : "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).",
      "startOffset" : 221,
      "endOffset" : 241
    }, {
      "referenceID" : 72,
      "context" : "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).",
      "startOffset" : 221,
      "endOffset" : 241
    }, {
      "referenceID" : 97,
      "context" : "There is a lot of papers on view update problem (for example, recent survey paper on view update by Chen and Liao[24], survey paper on view algorithm by Mayol and Teniente [83] and current survey paper on view selection ([38,53,73,69,79,105]).",
      "startOffset" : 221,
      "endOffset" : 241
    }, {
      "referenceID" : 15,
      "context" : "[16] , local search-based heuristic technique that empirically proves to be often viable, even in the context of very large propositional applications.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 62,
      "context" : "[68] parented updating deductive databases in which every insertion or deletion of a fact can be performed in a deterministic way.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 83,
      "context" : "Furthermore, and at a first sight more related to our work, some work has been done on ontology systems and description logics (Qi and Yang [90], and Kogalovsky [63]).",
      "startOffset" : 140,
      "endOffset" : 144
    }, {
      "referenceID" : 59,
      "context" : "Furthermore, and at a first sight more related to our work, some work has been done on ontology systems and description logics (Qi and Yang [90], and Kogalovsky [63]).",
      "startOffset" : 161,
      "endOffset" : 165
    }, {
      "referenceID" : 64,
      "context" : "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese’s [20], and Cong [31]).",
      "startOffset" : 146,
      "endOffset" : 153
    }, {
      "referenceID" : 65,
      "context" : "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese’s [20], and Cong [31]).",
      "startOffset" : 146,
      "endOffset" : 153
    }, {
      "referenceID" : 18,
      "context" : "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese’s [20], and Cong [31]).",
      "startOffset" : 165,
      "endOffset" : 169
    }, {
      "referenceID" : 19,
      "context" : "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese’s [20], and Cong [31]).",
      "startOffset" : 183,
      "endOffset" : 187
    }, {
      "referenceID" : 28,
      "context" : "Finally, when we presented connection between belief update versus database update, we did not talk about complexity (see the works of Liberatore [70,71], Caroprese [19], Calvanese’s [20], and Cong [31]).",
      "startOffset" : 198,
      "endOffset" : 202
    }, {
      "referenceID" : 56,
      "context" : "In the end, we plan to redefined the model to Horn Logic with stratified Negation [60] and Argumentative Inference [46,57].",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 42,
      "context" : "In the end, we plan to redefined the model to Horn Logic with stratified Negation [60] and Argumentative Inference [46,57].",
      "startOffset" : 115,
      "endOffset" : 122
    }, {
      "referenceID" : 53,
      "context" : "In the end, we plan to redefined the model to Horn Logic with stratified Negation [60] and Argumentative Inference [46,57].",
      "startOffset" : 115,
      "endOffset" : 122
    }, {
      "referenceID" : 18,
      "context" : "Though we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [19] and [18]).",
      "startOffset" : 214,
      "endOffset" : 218
    }, {
      "referenceID" : 17,
      "context" : "Though we have discussed only about view updates, we believe that knowledge base dynamics can also be applied to other applications such as view maintenance, diagnosis, and we plan to explore it further (see works [19] and [18]).",
      "startOffset" : 223,
      "endOffset" : 227
    }, {
      "referenceID" : 10,
      "context" : "It would also be interesting to study how results using soft stratification [11] with belief dynamics, especially the relational approach, could be applied in real world problems.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 43,
      "context" : "As immediate extension, question raises: is there any real life application for AGM in 25 year theory? [47].",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 60,
      "context" : "lem(database theory), so we can extend the theory to combine results similar to Konieczny’s [64] and Nayak’s [87].",
      "startOffset" : 92,
      "endOffset" : 96
    }, {
      "referenceID" : 80,
      "context" : "lem(database theory), so we can extend the theory to combine results similar to Konieczny’s [64] and Nayak’s [87].",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 10,
      "context" : "Follows from the lemma 3,4 (minimal test) and 6,7 (materialized view) of [11]",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 46,
      "context" : "[50] N Yes Check Run Logic Yes Yes Static No ι δ SLDNF No No S Yes No 1-6,9 No Not proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 57,
      "context" : "[61] N Yes Maintain Run Logic Yes Yes Static Yes ι δ SLDNF No No S Yes No — No No",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 77,
      "context" : "[84] N No Maintain Run Logic Yes Yes Static Yes ι δ — Yes No S Yes No 1-6,7 No No proved proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 47,
      "context" : "[51] S Yes Check Comp.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 35,
      "context" : "[39] N Yes Check Run Logic Yes No Static Yes ι δ predef Yes No S Yes No 1-6,7 Not No Programs Proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 93,
      "context" : "[101] S Yes Check Run Logic Yes Yes Static Yes ι δ χ SLDNF No No SS Yes No 1-6,7 Yes No Maintain",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 48,
      "context" : "[52] N Yes Maintain Run Logic Yes No Static Yes ι δ Unfold Yes No SS Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 75,
      "context" : "[82] N Yes Maintain Comp.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 95,
      "context" : "[103] S Yes Maintain Run Logic Yes Yes Static Yes ι δ Unfold.",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 5,
      "context" : "[6] H Yes Check Run Logic Yes Yes Static Yes ι δ SLD Yes No S Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 20,
      "context" : "[22] N No Maintain Comp Relation Yes Limited Static Yes ι δ χ Active Yes Yes S Yes No — No No Run Logic",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 45,
      "context" : "[49] N No Maintain Comp Relation No Flat Static Yes ι δ χ Active Yes Yes S Yes No — No No Run Logic Limited Dynamic",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[25] H Yes Check Comp.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 29,
      "context" : "[32] N Yes Maintain Run Logic Yes Flat Static Yes ι δ Unfold.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 68,
      "context" : "[74] N Yes Maintain Run Logic Yes Limited Static No ι δ Active Yes No SS Yes No 1-6,7 Yes Not proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 92,
      "context" : "[100] N Yes Maintain Comp Logic Yes Yes Static Yes ι δ SLDNF Yes No S Yes No 1-6,9 Yes Yes Run Dynamic",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 87,
      "context" : "[94] S Yes Maintain Comp Logic No Flat Static Yes ι δ predef — Yes G No Yes — No Not Limited Programs proved Tab.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 91,
      "context" : "[99] N No Maintain Comp Logic Yes Limited Static Yes ι δ χ Predef Yes No S Yes No 1-6,7 Yes No Program",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "[8] H Yes Check Run Logic Yes Limited Static Yes ι δ SLD Yes No S Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 30,
      "context" : "[33] N Yes Maintain Run Logic Yes Yes Static Yes ι δ SLDNF No No S Yes No 1-6,7 No Not Proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 66,
      "context" : "[72] N Yes Maintain Run Logic Yes Flat Static Yes ι δ Unfold No Yes G Yes No 1-6,7 Not No Limited proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 96,
      "context" : "[104] H No Maintain Comp.",
      "startOffset" : 0,
      "endOffset" : 5
    }, {
      "referenceID" : 70,
      "context" : "[76] N No Maintain Comp Logic No Flat Static Yes ι δ Active Yes No G No No — No No Restore Run Limited Dynamic",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 88,
      "context" : "[95] N No Maintain Comp Relation No Flat Static Yes ι δ Active Yes No S No No — No No Run Limited",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 69,
      "context" : "[75] N Yes Check Run Logic Yes Limited Static Yes ι δ SLD Yes No S Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "[1] O No Maintain Run Logic Yes Limited Static Yes ι δ — Yes No S Yes No — No No",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 49,
      "context" : "[53] N No Maintain Comp Logic Yes Limited Static Yes ι δ — No No S No No — No No",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "[26] N No Maintain Comp.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 36,
      "context" : "[40] H Yes Check Run Logic Yes Yes Static Yes ι δ Predef Yes No S Yes No 1-6,7 Yes Not Programs proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 51,
      "context" : "[55] O Yes Check Run Relation Yes Limited Static No ι δ Unfold Yes No S Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 9,
      "context" : "[10] O Yes Check Run Relation Yes Limited Static No ι δ Unfold Yes No S Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 39,
      "context" : "[43] N Yes Check Run Logic Yes Yes Static Yes ι δ SLDNF Yes No S Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 84,
      "context" : "[91] N No Maintain Run Logic Yes Limited Static Yes ι δ Predef Yes No S Yes No 1-6,7 Yes Not Programs proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 55,
      "context" : "[59] O No Maintain Comp Relation Yes Limited Static Yes ι δ — Yes No S Yes No — No No",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 85,
      "context" : "[92] N Yes Check Run Logic No Limited Static Yes ι δ SLDNF Yes No S Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 40,
      "context" : "[44] N Yes Check Run Logic Yes Yes Static No ι δ SLDNF No No S Yes No 1-6,9 Not No proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 73,
      "context" : "[80] N Yes Check Run Logic Yes Yes Static No ι δ χ SLD Yes No S Yes No — No No Maintain",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "[17] N Yes Check Run Logic Yes Yes Static No ι δ χ SLD Yes No SS Yes No 1-6,7 Yes Not Maintain Comp proved",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "[27] N Yes Check Run Logic Yes Yes Static Yes ι δ χ Predef Yes No S Yes No 1-6,9 Yes Yes Maintain Dynamic Program",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 26,
      "context" : "[28] N Yes Check Run Logic Yes Yes Static Yes ι δ χ Predef Yes No S Yes No 1-6,9 Yes Yes Maintain Dynamic Program",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "[30] N No Maintain Comp Logic Yes No — Yes ι δ — Yes No S Yes No — No No",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 52,
      "context" : "[56] O No Maintain Comp.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11] S Yes Check Run Logic Yes Flat Static Yes ι δ SLDNF Yes No S Yes No 1-6,9 Yes Not",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 37,
      "context" : "[41] N Yes Check Run Logic Yes Yes Static Yes ι δ — Yes No S Yes No — No No",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "[23] O No Maintain Run Relation Yes No Static Yes ι δ SLD Yes Yes G No No — Not Not",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[12] O No Maintain Comp Relation Yes No Static Yes ι δ χ — Yes No SS Yes No — No No",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : "[3] O No Maintain Comp.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 71,
      "context" : "[78] N No Maintain Comp Relation No Yes Static Yes ι δ χ Unfold No Yes SS No No — No No",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 86,
      "context" : "[93] N No Check Comp Logic No Yes Static Yes ι δ Active Yes No G Yes No — No No",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 33,
      "context" : "[36] N Yes Check Run Logic Yes Yes Static Yes ι δ SLD Yes No S Yes No 1-6,9 Yes Yes",
      "startOffset" : 0,
      "endOffset" : 4
    } ],
    "year" : 2014,
    "abstractText" : "The dynamics of belief and knowledge is one of the major components of any autonomous system that should be able to incorporate new pieces of information. We show that knowledge base dynamics has interesting connection with kernel change via hitting set and abduction. The approach extends and integrates standard techniques for efficient query answering and integrity checking. The generation of hitting set is carried out through a hyper tableaux calculus and magic set that is focused on the goal of minimality. Many different view update algorithms have been proposed in the literature to address this problem. The present paper provides a comparative study of view update algorithms in rational approach. Keyword: AGM, Belief Revision, Knowledge Base Dynamics, Kernel Change, Abduction, Hyber Tableaux, Magic Set, View update, Update Propagation.",
    "creator" : "LaTeX with hyperref package"
  }
}