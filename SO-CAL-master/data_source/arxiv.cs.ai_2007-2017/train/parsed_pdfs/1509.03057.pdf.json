{
  "name" : "1509.03057.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The World of Combinatorial Fuzzy Problems and the Efficiency of Fuzzy Approximation Algorithms",
    "authors" : [ "Tomoyuki Yamakami" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 9.\n03 05\n7v 1\n[ cs\n.A I]\n1 0\nSe p\n20 15\nsearch, counting, optimization, and decision problems. We are focused only on those fuzzy problems\nthat take series of fuzzy input objects and produce fuzzy values. To solve such problems efficiently, we\ndesign fast fuzzy algorithms, which are modeled by polynomial-time deterministic fuzzy Turing machines\nequipped with read-only auxiliary tapes and write-only output tapes and also modeled by polynomial-\nsize fuzzy circuits composed of fuzzy gates. We also introduce fuzzy proof verification systems to model\nthe fuzzification of nondeterminism. Those models help us identify four complexity classes: Fuzzy-FPA\nof fuzzy functions, Fuzzy-PA and Fuzzy-NPA of fuzzy decision problems, and Fuzzy-NPAO of fuzzy\noptimization problems. Based on a relative approximation scheme targeting fuzzy membership degree,\nwe formulate two notions of “reducibility” in order to compare the computational complexity of two\nfuzzy problems. These reducibility notions make it possible to locate the most difficult fuzzy problems\nin Fuzzy-NPA and in Fuzzy-NPAO."
    }, {
      "heading" : "1 Background and Results",
      "text" : "Our purpose is to (1) make a theoretical groundwork necessary to carry out practical analyses of “generalized” fuzzy problems that have naturally arisen in industrial applications and (2) lay out a theoretical framework for “generalized” fuzzy algorithms that efficiently solve those “generalized” fuzzy problems."
    }, {
      "heading" : "1.1 Practical Realm of Fuzzy Problems",
      "text" : "In real-life situations, many objects naturally embody certain degrees of fuzziness, which can be in general expressed in terms of the uncertainty, ambiguity, vagueness, or imprecision of the objects. Based on a nonstandard logic, Zadeh [13] tried to capture this fuzziness mathematically by formulating a basic concept of fuzzy set. In his theory, an ordinary object without any fuzziness is distinctly called as a “crisp” object, whereas a fuzzy object is a combination of crisp object and its membership degree (or certainty degree) that indicates intuitively how likely the crisp object actually exists. Since its introduction, fuzzy theory has found numerous applications from digital image processing to voice recognition, to telecommunication, further to a field of medicine and agriculture (see, e.g., [1, 7]). To handle a wide variety of practical fuzzy problems, we still need to lay out a groundwork in developing a general, coherent theory of fuzzy problems and fuzzy algorithms that efficiently solve them.\nIn the rest of this paper, we wish to limit our interest within combinatorial problems, which include search, counting, optimization, and decision problems. Let us first recall that, in an ordinary theory, those problems are viewed as functions that map every input instance to its desirable solution (or solutions). In the past literature, there have been numerous ways to fuzzificate ordinary combinatorial problems and those fuzzification methods significantly vary, depending on target areas of interests. We wish to re-examine a fuzzification of those problems to develop our general framework.\nIn many abstract treatments of fuzzy problems, input instances are merely pairs of crisp objects and their membership degrees, instead of more general “fuzzy objects.” To expand a scape of fuzzy-logic applications, it is more desirable to deal with the case where an input instance is a series of admissible fuzzy objects (or fuzzy data) and an output could be a desired “fuzzy object” as a solution derived from the given input. Formally, we define our “fuzzy problem” as a mapping from each series of fuzzy objects to another fuzzy object; thus, the term “fuzzy problem” becomes a synonym of “fuzzy functions.” To describe those fuzzy problems, we need to specify two items: fuzzy (input) instance and fuzzy output. For technical reason, we assume that the support of any fuzzy instance is finite, where the support of a fuzzy object over universe U is an ordinary set of elements in U having positive membership degrees. To distinguish our fuzzy problems\n∗This extended abstract appeared in the Proceedings of the Joint 7th International Conference on Soft Computing and Intelligent Systems (SCIS 2014) and 15th International Symposium on Advanced Intelligent Systems (ISIS 2014), December 3–6, 2014, Institute of Electrical and Electronics Engineers (IEEE), pp. 29–35, 2014.\n†Present Affiliation: Department of Information Science, University of Fukui, 3-9-1 Bunkyo, Fukui 910-8507, Japan\nfrom the aforementioned conventional fuzzy problems, we sometimes emphasize the generosity of our fuzzy problems by calling them generic fuzzy problems.\n(Generic) Fuzzy Problem P :\n• Fuzzy instance: a series (s1, s2, . . . , sk) of admissible fuzzy objects having finite supports. • Fuzzy output: an admissible fuzzy object as a solution to this input (s1, s2, . . . , sk).\nDue to the page limit, we will discuss in later sections only two kinds of (generic) fuzzy problems: fuzzy decision problems and fuzzy optimization problems. Fuzzy decision problems are treated as a special case of the fuzzy problems whose outputs are limited to fuzzy subsets of {0, 1}. This gives rise to a new realm of fuzzy languages, each of which indicates input’s “acceptance” and “rejection” with separate precision degrees, whereas conventional “fuzzy languages” are defined simply as fuzzy subsets of Σ∗ for underlying alphabet Σ.\nFuzzy optimization problems are also a variant of (generic) fuzzy problems, which in general have the form (I, SOL,m, goal), where I is a finite set of fuzzy (admissible) input instances, SOL is a fuzzy function listing all fuzzy solutions, m is a fuzzy measure (or objective) function from I ◦ SOL to natural numbers, and goal ∈ {max,min}. Here I ◦ SOL means the set {(s, t) | s ∈ I, t ∈ SOL(s)}. Let m∗(x) denote the optimal value m(x, y) over all solutions y ∈ SOL(x)."
    }, {
      "heading" : "1.2 Practical Realm of Fuzzy Algorithms",
      "text" : "In Section 1.1, we have discussed our (generic) fuzzy problems. To solve those problems efficiently, we need to clarify how we model efficient fuzzy algorithms so that we can explore computational complexity issues of the fuzzy problems in a wider, generic framework.\nWe intend to model fuzzy algorithms by extending the existing realms of “sequential computation” and “parallel computation.” Firstly, we will model our fuzzy algorithms by refining the existing notion of fuzzy Turing machines, which were considered by Zadeh [14], Lee and Zadeh [10], and Santos [12] as a fuzzification of ordinary nondeterministic Turing machines (or NTMs, in short) . In their formulations, deterministic fuzzy computation inherently embodies ordinary nondeterminism, and therefore it is not surprising to know that, under a certain suitable fuzzification of ordinary instances, fuzzy algorithms solve NP-complete problems in polynomial time (cf. Proposition 6.2).\nTo cope with a wide range of practical fuzzy problems, Doostfatemeh and Kremer [4] suggested how to expand the then-existing models of fuzzy algorithms by supplementing extra “safe” auxiliary operators to tune up the behaviors of those algorithms. Based on their spirit, we give a new formulation of deterministic fuzzy Turing machines (or DFTMs).\nAnother natural model that can represent fuzzy algorithms is fuzzy (logic) circuits (e.g., [6, 8]). In particular, we consider fuzzy circuits in which fuzzy gates are layered level by level. Such a fuzzy circuit takes a series of fuzzy input bits and proceeds by applying fuzzy gates at each level. This mechanism can realize fuzzified “parallel computation.” We prove that families of polynomial-size fuzzy circuits are equivalent in computational power to polynomial-time DFTMs.\nThe minimum amount of computational resources necessary to solve given problems is of great concern from a practical viewpoint. As in ordinary computational complexity theory, we are also interested in fuzzy algorithms running in polynomial time. For the purpose of solving a wider scope of fuzzy problems, we look for an approximation of the outcomes of fuzzy algorithms. We therefore define Fuzzy-FPA(γ) as the class of fuzzy functions (or equivalently, fuzzy problems having output values) computed approximately with relative closeness of γ by DFTMs in polynomial time. Restricted to fuzzy decision problems, we also obtain Fuzzy-PA(γ) as a natural fuzzification of the complexity class P.\nNondeterminism has been modeled as a proof-verification process, in which, for positive instances, there exists a “proof” (i.e., necessary key information) for which a “verifier” can easily confirm its validity and, for negative instances, the verifier refutes any proof provided to him as invalid. We recognize a naturallyinduced class Fuzzy-NPA(γ) of fuzzy decision problems that are solved approximately with relative closeness γ by such fuzzy proof verification systems (or FPVS’s, in short) in polynomial-time.\nTo discuss the computational complexity of fuzzy problems, we introduce a fundamental notion of polynomial-time approximate fuzzy reducibility (abbreviated as AF-reducibility) between two fuzzy problems. Such a reducibility notion among fuzzy decision problems makes it possible to designate “complete” problems, which indicate the most difficult problems in a given class of problems to solve in polynomial time, as for the notion of NP-complete problems (see [5]). We prove the existence of complete problems in Fuzzy-NPA(1) under AF-reductions.\nFor fuzzy optimization problems, similarly to Fuzzy-NPA(γ), we define Fuzzy-NPAO(γ), which is composed of all fuzzy optimization problems characterized by fuzzy functions in Fuzzy-FPA(γ). Between two fuzzy optimization problems, we also introduce a notion of polynomial-time approximation-preserving fuzzy reducibility (or APF-reducibility) and prove that Fuzzy-NPAO(1) contains complete problems under APFreductions.\nAll omitted or abridged proofs will appear in a complete version of this extended abstract."
    }, {
      "heading" : "2 Basic Notions and Notations",
      "text" : "The notation Z (resp., Q, R) denotes the set of all integers (resp., rational numbers, real numbers). We use N to denote the set of all natural numbers (i.e., non-negative integers) and we set N+ = N− {0}. For two integers n,m with n ≤ m, [n,m]Z stands for the integer interval {n, n+ 1, n+ 2, . . . ,m}. For simplicity, we write [n] to denote the interval [1, n]Z whenever n ≥ 1. The notation [0, 1]\n∗ (resp., [0, 1]+) denotes the union of [0, 1]k for any constant k ∈ N (resp., k ∈ N+). Given any propositional formula F , we set [F ] to be 1 if F is true, and 0 otherwise. For example, [x = y] equals 1 if and only if x = y. For any set A, P(A) denotes the power set of A.\nAn alphabet Σ is a finite nonempty set of “symbols” and a string over Σ is a finite sequence of symbols taken from Σ; in particular, the empty string is always denoted λ. Let Σ∗ denote the set of all strings over Σ. For any logical proposition (or logical statement) P , the notation [P ] denotes 1 if P is true, and 0 otherwise. For example, we have [x = y] = 1 if x equals y, and [x = y] = 0 if x is different from y.\nDue to the page limit, we assume that the reader is familiar with basic concepts of fuzzy sets. Although a fuzzy (sub)set A of universe U is a map from U to [0, 1], it is also viewed as an ordinary set that is composed of pairs of the form (x, γ), where x ∈ U and γ ∈ [0, 1]; that is, (x, γ) ∈ A iff γ = A(x). To simplify the descriptions of fuzzy sets in the rest of the paper, we will take those two different viewpoints interchangeably. For convenience, we write F(U) for the collection of all fuzzy subsets of U . Moreover, we use the notations core(s) for the core of fuzzy set s and Supp(s) for the support of s.\nDefinition 2.1 (fuzzy function) Given two universes U1 and U2, let A ⊆ F(U1) and B ⊆ F(U2). A (generic) fuzzy function f from A to B, written as f : A → B, satisfies that, for every s ∈ A, f(s) is a fuzzy subset of U2 in B.\nRemark: It may be possible to expand our definition of fuzzy sets by replacing the unit interval [0, 1] with an arbitrary complete lattice and expand our results further. However, we leave such a challenging task to the interested reader."
    }, {
      "heading" : "3 Combinatorial Fuzzy Problems",
      "text" : "In pursuit of simplicity, we limit our attention within “combinatorial problems” that inherently embody fuzziness. Now, we want to explain what “fuzzy problems” are. As described in Section 1.1, fuzzy problems with which we deal in this paper take series of fuzzy instances (such as fuzzy graphs, fuzzy numbers, fuzzy functions, etc.) as inputs and produce certain fuzzy objects as outputs. We treat such a problem as a mapping from a set of fuzzy objects (or fuzzy instances) to another fuzzy object.\nAs customarily in ordinary computational complexity theory, we will deal only with discrete objects as our input instances. For a general treatment of such discrete fuzzy instances, it is useful to assume a suitable encoding of those instances to a certain fixed object. In a way similar to defining “strings over alphabet” in ordinary language theory, we will introduce an exquisite notion of “fuzzy string,” which expresses a certain degree of imprecision, uncertainty, or incompleteness of string information. Our definition of fuzzy string is inspired by the notion of LR-shape fuzzy numbers (see, e.g., [7]) and is closely related to “discretized” fuzzy numbers.\nA fuzzy string quantity s over Σ is an element of F(Σ∗), namely, a fuzzy subset of Σ∗. We call each value s(x) a precision degree of x instead of “membership degree.” A fuzzy string over Σ (with respect to a suitably chosen distance measure d, e.g., the Hamming distance between two crisp strings) is a fuzzy string quantity s over Σ that satisfies the following condition: there exist a crisp string x0 ∈ Σ\n∗ and a crisp function η : [0, 1] → [0, 1] (which may depend on x0) such that (1) Supp(s) is a finite set, (2) η is strictly decreasing function with η(0) = 1 and η(1) = 0, and (3) Cutγ(s) ⊆ Balld(x0, η(γ)) holds for any real number γ ∈ [0, 1], where Balld(x, γ) = {z ∈ Σ ∗ | d(x, z) ≤ γ}. This special string x0 is called a target of the fuzzy string s.\nLet FΣ∗ denote a collection of all (possible) fuzzy strings over Σ. It holds that core(s) = x0 by Conditions (2) and (4). Note that a fuzzy string is a convex fuzzy set. As usual in fuzzy theory, a fuzzy string s can be seen as the set {(x, s(x)) | x ∈ Σ∗}. We also follow a standard convention that, when a fuzzy string s is crisp with a target x0 (i.e., s(x0) = 1 and s(x) = 0 for any x ∈ Σ\n∗ − {x0}), we identify s with x0. This helps us treat all crisp strings as a special case of fuzzy strings.\nHenceforth, we will focus our attention only on any subset FΘ of FΣ∗ for a certain alphabet Σ and a certain distance measure d. A (generic) fuzzy problem stated in Section 1.1 is now rephrased as follows. Fix our alphabet Σ1,Σ2 and consider two sets FΘ1 ⊆ FΣ ∗ 1 and FΘ2 ⊆ FΣ ∗ 2.\n(Generic) Fuzzy Problem L w.r.t. (FΘ1, FΘ2):\n• Fuzzy instance: a series (s1, s2, . . . , sk) of fuzzy strings in FΘ1. • Fuzzy Output: a fuzzy string in FΘ2.\nIn particular, we will study two types of fuzzy problems: fuzzy decision problems and fuzzy optimization problems, defined in Section 1.1."
    }, {
      "heading" : "4 Models for Efficient Fuzzy Algorithms",
      "text" : "To solve the fuzzy problems described in Section 3, we want to design efficient fuzzy algorithms."
    }, {
      "heading" : "4.1 Auxiliary Operators for Practical Algorithms",
      "text" : "The existing formulation of fuzzy Turing machine seems too restrictive to apply to many real-life fuzzy problems. For a wider range of practical applications of fuzzy machines, Doostfatemeh and Kremer [4] proposed a rigorous use of “auxiliary functions” to a design of fuzzy algorithms (actually, fuzzy finite automata in their case). For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (µ1, µ2, µ3, ξ), where µ1 : [0, 1] 2 → [0, 1], µ2 : [0, 1] + → [0, 1], µ3 : [0, 1]\n+ → [0, 1], and ξ : [0, 1]∗ → [0, 1]. The use of them will be clarified in Section 4.2.\nA tuple (µ1, µ2, µ3, ξ) of auxiliary operators is said to be safe if those functions satisfy the following conditions: for any finite nonempty ordered set A and any finite ordered set B, (1) µ1(α, α) = α for any α ∈ [0, 1], (2) µ2({αr}r∈A) = α if αr = α for all r ∈ A, (3) µ3({αr}r∈A) = α if αr = α for all r ∈ A, and (4) ξ(Ø) = 0 and ξ({αr}r∈B) = α if αr = α for r ∈ B. As a concrete example, we present a standard safe tuple Ξ = (µ1, µ2, µ3, ξ), which we will use later. Let ∧ and ∨ be any t-norms. We set µ1(α, β) = α ∧ β. For any finite nonempty ordered set A, let µ2({αr}r∈A) = ∨ r∈A αr and µ3({αr}r∈A) = ∨ r∈A αr. Moreover, for any finite ordered set B, let ξ(Ø) = 0\nand ξ({αr}r∈B) = ∨ r∈B αr."
    }, {
      "heading" : "4.2 Deterministic Fuzzy Turing Machines",
      "text" : "In order to describe a fuzzified “sequential computation” within our framework, we use a mathematical model of deterministic fuzzy Turing machines equipped with read-only auxiliary-input tapes, rewritable input/work tapes, and write-only output tapes supported by safe tuples of auxiliary operators. This model is considered as an extension of ordinary nondeterministic Turing machines.\nLet ∆ and Γ be an input alphabet and an output alphabet including a designated blank symbol #. To operate a machine, we need two more tape alphabets Σ1 (with |c, $,# ∈ Σ1) and Σ2 (= {|c, $, 1,#}) for the machine’s internal use. We fix FΘ1 ⊆ F(∆ ∗) and FΘ2 ⊆ F(Γ ∗) and also fix a safe tuple Ξ = (µ1, µ2, µ3, ξ) of auxiliary operators. A deterministic fuzzy Turing machine with a write-only output tape (abbreviated as DFTM) is a triplet 〈M,Ξ, I〉, where M is of the form (Q,∆,Σ1,Σ2,Γ, δ, q0, F ) and I is a target set pair (FΘ1, FΘ2). Moreover, Q is a finite nonempty set of the machine’s (inner) states and δ is a fuzzy transition function mapping from (Q− F )×Σ1 ×Σ2 to F(Q×Σ1 × Γ×D1 ×D2) with Di = {0,±1}, q0 (∈ Q) is the initial state, and F (⊆ Q) is a set of halting states. Whenever M enters a halting state, since δ is no longer applicable, M is considered to halt.\nSince Ξ and I are fixed, we often refer to M as a DFTM as long as it is clear from the context. Graphically speaking, M works as follows. A fuzzy input instance s to M is a fuzzy object in FΘ1. Let ℓ(s) = maxx∈Supp(s){|x|} be the length of s. The DFTM M takes s and eventually produces another fuzzy subset M(s) of FΘ2 as its output. In an initial setup process, M receives s, it automatically generates in\nparallel all crisp strings x ∈ Supp(s), and writes down each x, surrounded by two endmarkers |c and $, on the input/work tape and the other tape cells initially hold the blank symbol #. Moreover, M generates |c1ℓ(s)$ on the read-only auxiliary input tape. All tape cells are indexed by integers and all tape heads are initially positioned at the 0th cell (where |c must be written on the first two tapes). An inner state of M is q0.\nAssume that, at an arbitrary moment, the tape head of M scans symbol σ1 on the input/work tape and σ2 on the read-only input tape in inner state q and the third tape head is situated at the first (i.e., the leftmost) blank cell. When δ is applied, M overwrites σ1 with τ , enters state p, move the first two tape heads in directions d1 and d2, and writes symbol η on the output tape, together with possibility degree δ(q, σ1, σ2)(p, τ, η, d1, d2). If η 6= λ, then the output tape head must move to the right; otherwise, it stays still.\nLet us explain how a DFTM generates a “fuzzy computation,” composed of a set of fuzzy computation paths (i.e., series of configurations). A (global) configuration is a string of the form uqv♮r♮w with u, v ∈ Σ∗1, q ∈ Q, r ∈ [0, ℓ(s)]Z, and w ∈ Γ\n∗, where ♮ is a designated separator, and uqv♮r♮w indicates that an input/work tape content is uv, the second tape head scans cell r, an output tape content is w, an inner state is q, and the first and third tape heads are respectively scanning the leftmost symbol of v and the first blank symbol to the right of w. Let CONFM denote the set of all (possible) configurations of M , namely, {uqv♮r♮w | u, v ∈ Σ∗1, q ∈ Q, r ∈ [0, ℓ(s)]Z, w ∈ Γ\n∗}. A final configuration is a configuration of the form uqv♮r♮w with q ∈ F in CONFM . Each element of F(CONFM ) is called a fuzzy instance description or a fuzzy configuration.\nLet us describe how a “time evolution” of fuzzy configurations takes place. To express a fuzzy configuration at time i, we inductively introduce a fuzzy set confi (i ∈ N) as follows. Let conf0 be a fuzzy configuration at time 0 defined as\nconf0(upv♮r♮w) = ∑\nx∈Supp(s)\ns(x) · [upv♮r♮w = q0|cx$♮0♮λ]\nfor any configuration upv♮r♮w of M . Next, confi+1 is a fuzzy configuration at time i + 1 whose possibility degree confi+1(u\n′pv′♮r♮w′) is defined as follows. Taking pre-determined orderings on (Q − F ) × Σ1 × Σ2 and D1 × D2 and also assuming that u\n′pv′♮w′ has the form uτ1pτ2τ3v♮r♮wη with p ∈ Q − F and , let confi+1(u ′pv′♮r♮w′) be\nµ2({ℓd1,d2(q, σ1, σ2)}(d1,d2)∈D1×D2,(q,σ1,σ2)∈(Q−F )×Σ1×Σ2),\nwhere ℓd1,d2(q, σ1, σ2) represents the following values. For example, when (d1, d2) = (+1,−1), ℓ+1,−1(q, σ1, σ2) equals\nµ1(confi(uqστ2τ3v♮(r + 1)♮w), δ(q, σ1, σ2)(p, τ1, η,+1,−1)),\nwhere σ2 is the symbol at cell r+1. Notice that each value ℓd1,d2(q, σ1, σ2) is always defined. If either p ∈ F or u′pv′♮r♮w′ has a wrong form, then we set confi+1(u\n′pv′♮r♮w′) = 0. A fuzzy computation of M on fuzzy input s is a series (conf0, conf1, . . .) of fuzzy configurations defined\nabove. Let finalM be an element of F(N× CONFM ) defined as\nfinalM(t, uqv♮r♮w) = [q ∈ F ] · µ3({confi(uqv♮r♮w)}i∈[0,t]Z )\nfor any uqv♮r♮w in CONFM . This value finalM (t, uqv♮r♮w) is called the possibility degree of the (final) configuration uqv♮r♮w at time t. Let FINM (t, s) be the set of all pairs (uqv, r) with q ∈ F , u, v ∈ Σ\n∗, |uv| ≤ t, and r ∈ [0, ℓ(s)]Z. Obviously, FINM (t, s) is a finite set.\nSince we are interested in time-bounded computation, we define the (absolute) running time of M on input s to be a unique number t ∈ N for which (i) there exists a final configuration u′q′v′♮r♮w′ satisfying finalM(t, u\n′q′v′♮r♮w′) > 0 and (ii) finalM(i, uqv♮r♮w) = 0 holds for all configurations uqv♮r♮w and all i > t. For convenience, we say that M (absolutely) halts on input s in time t if t is at least the running time of M on s.\nNow, let t be the running time of M on s. If b is a fuzzy subset of Γ∗ satisfying\nb(w) = ξ({finalM(t, uqv♮r♮w)}(uqv,r)∈FINM (t,s))\nfor every w ∈ Γ∗, then we say that M outputs b on input s in time t. For convenience, we write M(s) to denote this particular fuzzy object b. Obviously, if M outputs b in time t, then |Supp(b)| ≤ |Γ|t holds, and thus b has a finite support.\nWe say that a fuzzy problem L admits a DFTM M (or M solves L) if M(s) = L(s) holds for any s ∈ FΘ1. In this case, the problem L is succinctly denoted by L(M)."
    }, {
      "heading" : "4.3 Fuzzy Gates and Fuzzy Circuits",
      "text" : "In an ordinary setting, uniform families of Boolean circuits composed of Boolean gates have been used to model efficient algorithms. Likewise, we will consider a fuzzification of those circuits to model our intended fuzzy algorithms. In what follows, we fix a safe tuple Ξ′ = (µ1, µ ′ 2, µ3, ξ) of auxiliary operators. A fuzzy gate is specified by a finite set of input variables attached with distinguished labels and another finite set of output variables having specific labels. A fuzzy gate with m inputs and k outputs simply represents a function mapping {0, 1}m to F({0, 1}k). For a physical implementation of fuzzy circuits, it may be desirable to restrict the usable types of fuzzy gates but, meanwhile, we allow any types of fuzzy gates.\nIn our fuzzy circuit model, a finite number of fuzzy gates are layered by “levels.” At each middle level, no two fuzzy gates must share output variables with the same label; however, fuzzy gates are allowed to share input variables with the same labels. Nevertheless, all input variables at level 0 have distinct labels. We also permit the use of “fuzzy constants” (i.e., elements in F({0, 1}ℓ) for a fixed ℓ) as part of inputs.\nLet us explain how a fuzzy circuit operates on a given set of inputs. Let (x1, x2, . . . , xn) be a series of all input variables used for a given fuzzy circuit. We define a global configuration conft at level t as follows. At level 0, let conf0(x1x2 . . . xn) = s(x1x2 · · ·xn). For t ≥ 0, let G1, G2, . . . , Gm be all fuzzy gates aligned at level t+1 and let each fuzzy gate Gk have input variables ~vk = (vi1 , vi2 , . . . , via k ) as well as output variables ~wk = (wj1 , wj2 , . . . , wjb k ). Let ~v = (v1, v2, . . . , vc) be the series of all input variables of G1, G2, . . . , Gm and let (w1, w2, . . . , wd) be the series of all output variables of them. Now, we define\n• ℓ (k) ~v′ (~v ′ k, ~w ′ k) = µ1(conft(v ′ 1, . . . , v ′ c), Gk(~v ′ k)(~w ′ k)), and • g(v′1, . . . , v ′ c)(w ′ 1, . . . , w ′ d) = µ ′ 1({ℓ (k) ~v′ (~v ′ k, ~w ′ k)}k∈[m]),\nwhere, given a variable a, a′ means its arbitrary value. Finally, we define conft+1(w ′ 1, . . . , w ′ d) to be\nµ3({g(v ′ 1, . . . , v ′ c)(w ′ 1, . . . , w ′ d)}(v′1,...,v′c)∈Supp(conft)).\nAn output (or outcome) of C on input s is conft when t is the number of levels in C and we write C(s) to denote the outcome of C on s. Moreover, the size of C is the total number of fuzzy gates plus the number of all wires between variables and gates used in C.\nNow, we consider the aforementioned standard safe tuple of auxiliary operators together with µ′2({αr}r∈B) = ∧ r∈B αr.\nTheorem 4.1 Let f be any fuzzy function from FΘ1 to FΘ2. (1) If there is a DFTM computing f in polynomial time, then there exists a uniform family of fuzzy circuits of polynomial size that computes f . (2) If there is a uniform family of polynomial-size fuzzy circuits computing f , then there exists a DFTM M that computes f in polynomial time.\nProof Sketch. We prove only (1). Let M = (Q,∆,Σ1,Σ2,Γ, δ, q0, F ) be a DFTM computing f in polynomial time. We want to construct a uniform family {Cn}n∈N of fuzzy circuits that “simulates” M , and thus computes f . For each fuzzy gate gk at level t, we prepare variables {vt,σ,k, v ′ t,q,k}t,σ,q,k, where t ∈ N, q ∈ ∆ ∪ {|c, $}, q ∈ Q, and k ∈ Z, used for inputs and outputs. Intuitively, vt,σ,k = v ′ t,q,k = 1, for example, means that M in state q is scanning σ on cell k at time t. We assume a natural and efficient ordering of those variables. It is easy to design a fuzzy gate that “mimics” the behavior of δ(q, σ1, σ2). Since M halts in time polynomial in the length ℓ(s) of s, the size of Cn is also upper-bounded by a certain polynomial in ℓ(s). However, gk−1, gk, gk+1 may share the same output variables. To avoid this situation, it is enough to distinguish them by slightly modifying their labels. ✷"
    }, {
      "heading" : "4.4 Fuzzy Proof Verification Systems",
      "text" : "Nondeterminism has played a significant role in the development of the theory of NP-completeness. In the past literature, the notion of polynomial time-bounded nondeterminism has been characterized in various ways. Among them, we are interested in a particular characterization of NP problems, using proof verification processes; namely, NP problems are decision problems that have efficiently verifiable solutions (or proofs). Likewise, we will introduce a model of fuzzy proof verification system, in which a verifier tries to check the validity (or correctness) of a given proof, because we believe that this model is more suitable for practical use.\nLet us recall the definition of DFTM from Section 4.2 and expand it significantly by adding a mechanism of handling proofs (or certificates). To store such a proof during a verification process, we use an extra read-only infinite tape, called a proof tape. A fuzzy proof verification system (or an FPVS, in short) is a tuple 〈N,FΘ,Ξ, I〉, where FΘ is a set of all possible fuzzy proofs with FΘ ⊆ F(∆∗2) and N = (Q,∆1,∆2,Σ1,Σ2,Σ3,Γ, δ, q0, F ) is a 4-tape DFTM whose first and second tapes are the same as before, whose third tape is a read-only proof tape, and whose fourth one is a write-only output tape. Here, a fuzzy transition function δ is a map from δ : (Q−F )×Σ1 ×Σ2×Σ3 to F(Q×Σ1×Σ2×Γ×D1×D2×D3), where the ith tape uses a tape alphabet Σi and its tape head moves in directions specified as Di (= {0,±1}) for each index i ∈ [3]. A configuration is now of the form upv♮r♮y1hy2♮w, where y = y1y2 particularly represents the content of the proof tape and y1hy2 indicates that its tape head is at the leftmost symbol of y2. On input s with proof φ, a fuzzy configuration confi at time i is defined as follows. Let conf0(upv♮r♮y1hy2♮w) denote\ns(x) · φ(y) · [upv♮r♮y1hy2♮w = q0|cx$♮0♮hy♮λ].\nAt time i + 1, we assume that u′pv′♮r♮y′1hy ′ 2♮w ′ is of the form uτ1pτ2τ3♮r♮y1ξ1hξ2ξ3y2♮wη. Let confi+1(u ′pv′♮r♮y′1hy ′ 2♮w ′) denote\nµ2({ℓd1,d2,d3(q, σ1, σ2, σ3)}(q,σ1,σ2,σ3),(d1,d2,d3)),\nwhere (q, σ1, σ2, σ3) ∈ (Q − F ) × Σ1 × Σ2 × Σ3, d1, d2, d3 ∈ {0,±1}, each ℓd1,d2,d3(q, σ1, σ2, σ3) is defined similarly to ℓd1,d2(q, σ1, σ2) in Section 4.2; for example, ℓ+1,−1,+1(q, σ1, σ2, σ3) equals\nµ1(confi(u ′♮r′♮y′♮w, δ(q, σ1, σ2, σ3)(p, τ1, η,+1,−1,+1)),\nwhere r′ = r + 1 and u′♮r′♮y′♮w expresses the string uqσ1τ2τ3v♮r ′♮y1hξ1ξ2ξ3♮w.\nLet FINN (t, s, φ) be the set of all (uqv, r, y1hy2) with u, v ∈ Σ ∗ 1, y1y2 ∈ Supp(φ), q ∈ F , |uv| ≤ t, and r ∈ [0, ℓ(s)]Z. As in Section 4.2, finalN and the running time t of N are similarly defined. Write N(s, φ) to denote an output (i.e., a fuzzy subset of {0, 1}) b of N on input s with proof φ, where b(w) is defined as\nξ({finalN(t, uqv♮r♮y1hy2♮w)}(uqv,r,y1hy2)∈FINN (t,s,φ)).\nAn outcome N(s) of the FPVS N on input s is defined as • N(s)(1) = supφ∈FΘ{N(s, φ)(1)} and • N(s)(0) = infφ∈FΘ{N(s, φ)(0)}.\nWe say that L admits N (or N solves L) if N(s) = L(s) for all s ∈ FΘ1. The notation L(N) expresses the fuzzy decision problem solved by N .\nAs a concrete example of fuzzy decision problems admitting FPVS’s, we present the Fuzzy Circuit Satisfiability Problem (abbreviated as Fuzzy-Circuit-SAT).\nFuzzy-Circuit-SAT (w.r.t. FΘ) • Fuzzy Instance: a (description of) fuzzy circuit C that takes inputs from FΘ. • Fuzzy Output: output a fuzzy set b ∈ F({0, 1}), where b(1) = sups∈FΘ{C(s)(1)} and b(0) = infs∈FΘ{C(s)(0)}.\nTo solve this Fuzzy-Circuit-SAT, it is possible to construct an FPVS using Theorem 4.1. Hence, we obtain the following.\nLemma 4.2 There exists an FPVS that solves Fuzzy-Circuit-SAT in polynomial time."
    }, {
      "heading" : "5 Reductions among Fuzzy Problems",
      "text" : "The notion of reducibility is a basis to NP-completeness and numerous forms of the reducibility have been proposed. Here, we will consider only its simple fuzzification. Firstly, we will define an important fuzzy function class Fuzzy-FPA(γ) of polynomial-time approximately computable fuzzy functions. Using functions in Fuzzy-FPA(γ), we will introduce AF- and APF-reducibilities, which are viewed as natural fuzzifications of Krentel’s metric reducibility [9] and AP-reducibility [2]."
    }, {
      "heading" : "5.1 Relative Approximation of Membership Degree",
      "text" : "In Section 4.2, we have introduced a DFTM model to capture the notion of fuzzy algorithm. However, the exact use of DFTM’s seems too restrictive to solve a wide range of practical fuzzy problems. It is thus desirable to allow the DFTM’s to “approximate” the outcomes of the fuzzy problems.\nTo describe this “approximation,” let γ : N → [1,∞) be any crisp function, called an imprecision tolerance parameter. Let FΘ ⊆ F∆∗ for alphabet ∆ as before. For any two fuzzy subsets F and G of the universe FΘ, we say that F is a γ-approximation of G if F (x)/γ(|x|) ≤ G(x) ≤ γ(|x|)F (x) for any element x in FΘ.\nDefinition 5.1 (approximate solving) Let M be either an DFTM or an FPVS. We say that M γapproximately solves fuzzy problem L if, for any admissible fuzzy input s, M takes s as an input and produces a certain fuzzy solution M(s) that is a γ-approximation of L(s).\nIn ordinary computational complexity theory, FP denotes the set of all crisp functions on crisp strings computable in polynomial time. We introduce an analogous “fuzzy” function class denoted by Fuzzy-FPA(γ) using the γ-approximability.\nDefinition 5.2 (Fuzzy-FPA(γ)) Let γ : N → [1,∞) be any imprecision tolerance parameter and fix a safe tuple Ξ. For convenience, we define Fuzzy-FPAΞ(γ) to be the set of all (combinatorial generic) fuzzy problems, each of which can be γ-approximately solved by a certain polynomial-time DFTM. The “PA” stands for “polynomial-time approximate.” When Ξ is clear from the context, we drop Ξ and write Fuzzy-FPA(γ).\nLet us introduce four classes of fuzzy functions. The notation const expresses the set of all constant functions (which we usually identify with “constants”), poly does the set of all polynomials, and exp does the set of all exponential functions. We then obtain the following chain of containments: Fuzzy-FPA(1) ⊆ Fuzzy-FPA(const) ⊆ Fuzzy-FPA(poly) ⊆ Fuzzy-FPA(exp).\nWe can show that FP is a crisp part of Fuzzy-FPA if we take the following method of fuzzifying crisp objects. For each crisp string x in ∆∗, the notation x̂ denotes its specific fuzzified object {(x, 1)} ∪ {(y, 0) | y ∈ ∆∗ − {x}} in F(∆∗).\nLemma 5.3 For any crisp function f : ∆∗ → Γ∗ in FP, there exists a fuzzy function g ∈ Fuzzy-FPA(1) such that, for every (x, y) ∈ ∆∗ × Γ∗, f(x) = y if and only if g(x̂) = ŷ.\nLemma 5.4 Let F ∈ {1, const, poly, exp}. Fuzzy-FPA(F) is closed under functional composition; namely, for any two elements f, g ∈ Fuzzy-FPA(F), the function h defined as h(s) = g(f(s)) for every s is also in Fuzzy-FPA(F)."
    }, {
      "heading" : "5.2 Approximate Fuzzy Reductions",
      "text" : "To compare the computational complexities of two (generic) fuzzy problems, we need to devise a notion of “fuzzy reducibility,” which is a mechanism (similar to the metric reducibility in [9]) of transforming instances of one decision problem to instances of another decision problem so that corresponding outputs of those instances are close enough.\nDefinition 5.5 (AF-reducibility) Let F be any fuzzy function mapping FΘ1 to FΘ2 and let G be any fuzzy function from FΘ3 to FΘ4. We say that F is polynomial-time γ-approximately fuzzy reducible (or AF(γ)-reducible, in short) to G if there exist two functions f, g in Fuzzy-FPA(F) with f : FΘ1 → FΘ3 and g : FΘ1×FΘ4 → FΘ2 and a function γ ∈ F such that, for any s ∈ FΘ1, g(s,G(f(s))) is a γ-approximation of F (s). In this case, we write F ≤ (F) AF G. This triplet (f, g, γ) is called an AF(F)-reduction of F to G.\nThe next lemma establishes the reflexivity and the transitivity of the AF-reducibility. Thus, the AF(F)reducibility forms a partial order in the set of all fuzzy problems.\nLemma 5.6 Let F ∈ {1, const, poly, exp}. For any three fuzzy problems A,B,C having the same range, it holds that (1) A ≤ (F) AF A and (2) A ≤ (F) AF B and B ≤ (F) AF C imply A ≤ (F) AF C.\nReducibility between two fuzzy optimization problems, in contrast, requires a more delicate treatment. As a natural fuzzification of the ordinary AP-reducibility (see, e.g., [2]), we introduce the following APF-\nreducibility. Let R(s, t) = max{|m(s, u)/m∗(s)| , |m∗(s)/m(s, u)|} for a given fuzzy measure function m. We set Q>1 = {r ∈ Q | r > 1}.\nDefinition 5.7 (APF-reducibility) For any two fuzzy optimization problems A = (I1, SOL1,m1, goal) and B = (I2, SOL2,m2, goal), we say that A is polynomial-time approximation-preserving fuzzy (APF) reducible to B with respect to F , denoted by A ≤ (F) APF B, if the following condition holds: there exist a pair (f, g) of fuzzy functions and a constant c > 0 such that (1) f(s, r) ∈ I2 for any s ∈ I1 and r ∈ Q\n>1; (2) SOL1(s) 6= Ø implies SOL2(f(s, r)) 6= Ø; (3) u ∈ SOL2(f(s, r)) implies g(s, u, r) ∈ SOL1(s); (4) f, g ∈ Fuzzy-FPA(F) for each fixed r ∈ Q>1; (5) R2(f(s, r), u) ≤ r → R1(s, g(s, u, r)) ≤ 1 + c(r − 1)."
    }, {
      "heading" : "6 Fuzzy Decision Problems",
      "text" : "In ordinary complexity theory, decision problems are identified with sets of words (or strings) and they are also called languages. The fundamental complexity classes of languages are P and NP. Analogously, we recognize two special classes of fuzzy decision problems.\nDefinition 6.1 (Fuzzy-PA(γ), Fuzzy-NPA(γ)) Let Fuzzy-PA(γ) be a subclass of Fuzzy-FPA(γ), which consists only of fuzzy decision problems. Moreover, Fuzzy-NPA(γ) denotes the set of all fuzzy decision problems that can be γ-approximately solved by polynomial-time FPVS’s.\nSince DFTMs are a special case of FPVS’s, it immediately follows that Fuzzy-PA(γ) ⊆ Fuzzy-NPA(γ) for any γ. As in Section 5.1, we write Fuzzy-PA (resp., Fuzzy-NPA) for Fuzzy-PA(const) (resp., Fuzzy-NPA(const)).\nNotice that DFTMs are in fact an extension of ordinary NTMs. Therefore, it is not surprising to show that all NP sets can be solved by DFTMs in polynomial time if we use an appropriate fuzzification (i.e., if we assign appropriately-chosen possibility degrees). Recall from Section 5.1 the fuzzification x̂ of crisp string x. If a fuzzification L̂ of crisp language L is defined to satisfy that L̂(x̂) = {(0, 0), (1, 1)} if x ∈ L and L̂(x̂) = {(0, 1), (1, 0)} otherwise, we can show that, for any language L ∈ NP, L̂ belongs to Fuzzy-PA(1).\nProposition 6.2 For every set A ∈ NP over alphabet ∆, there exists a fuzzy decision problem B ∈ Fuzzy-PA(1) such that A = {x ∈ ∆∗ | B(x̂)(1) = 1} and A = {x ∈ ∆∗ | B(x̂)(1) = 0}.\nHereafter, we assume that F ∈ {1, const, poly, exp}.\nLemma 6.3 The fuzzy complexity class Fuzzy-PA(F) is closed under AF(F)-reductions.\nProof Sketch. It suffices to show that, for any two fuzzy problems A and B, if A is AP-reducible to B and B is in Fuzzy-PA, then A is also in Fuzzy-PA(F). Since A ≤ (F) AF B, take a reduction (f, g, γ) with f, g ∈ Fuzzy-FPA(F) that reduces A to B. Since B ∈ Fuzzy-PA(F), take a DFTM M that solves B. It suffices to consider the following DFTM G: on input s, generate all x ∈ Supp(s) in parallel, compute Mf on them, starts the simulation of N , and compute Mg. ✷\nNow, we introduce a key concept of “completeness.”\nDefinition 6.4 (completeness) We say that a fuzzy decision problem A is complete for Fuzzy-NPA(F) (or simply, Fuzzy-NPA(F)-complete) if (i) A is in Fuzzy-NPA(F) and (ii) for every fuzzy decision problem B in Fuzzy-NPA(F), A is AF(F)-reducible to B.\nLemma 6.5 Let A be a fuzzy decision problem complete for Fuzzy-NPA(F). If A is in Fuzzy-PA(F), then Fuzzy-PA(F) = Fuzzy-NPA(F) holds.\nProof Sketch. The containment Fuzzy-PA ⊆ Fuzzy-NPA is obvious. Next, we will show the other containment. Take any fuzzy problem B in Fuzzy-NPA. By the definition of “completeness,” B is APreducible to A. Assume that A is in Fuzzy-PA. By Lemma 6.3, it follows that B is also in Fuzzy-PA. Thus,\nFuzzy-NPA ⊆ Fuzzy-PA. ✷\nFinally, we will demonstrate the existence of complete problems for Fuzzy-NPA(1). Our choice of such problem is Fuzzy-Circuit-SAT, defined in Section 4.4.\nTheorem 6.6 The fuzzy problem Fuzzy-Circuit-SAT is complete for Fuzzy-NPA(1).\nProof Sketch. Recall from Lemma 4.2 that Fuzzy-Circuit-SAT is in Fuzzy-NPA(1). What remains to show is that any problem, say, A in Fuzzy-NPA(1) is AF-reducible to Fuzzy-Circuit-SAT . Given such A, take an FPVS N for A. By Theorem 4.1(1), we can choose a family of fuzzy circuits that “simulates” N when input s and proof φ are initially given. It thus suffices to define an AF-reduction pair (f, g) as follows. Let f(s) be a circuit obtained from C by incorporating it with s (treating φ as only a true input). The function g is defined as the identity function. ✷"
    }, {
      "heading" : "7 Fuzzy Optimization Problems",
      "text" : "Briefly, we will discuss the computational complexity of fuzzy optimization problems. The theory of NP optimization problems has made a huge success in classifying “complete” problems in NPO (the class of NP optimization problems). We will pay our attention to “fuzzy NPA” optimization problems.\nDefinition 7.1 (Fuzzy-NPO(γ)) A fuzzy NPA(γ) optimization problem (or a fuzzy NPAO(γ) problem) P is a fuzzy optimization problem (I, SOL,m, goal) as defined in Section 3 such that I ◦SOL is in Fuzzy-PA(γ) and m is in Fuzzy-FPA(γ). We write Fuzzy-NPAO(γ) for the class of all fuzzy NPAO(γ) problems.\nSimilar to Fuzzy-NPA(1), Fuzzy-NPAO(1) has complete problems under AFP(1)-reductions.\nTheorem 7.2 There exists a fuzzy optimization problem that is complete for Fuzzy-NPAO(1) under APF(1)reductions."
    } ],
    "references" : [ {
      "title" : "D",
      "author" : [ "M.F. Abbod" ],
      "venue" : "G. von Keyserlingk, D. A. Linkens, and M. Mahfouf. Survey of utilisation of fuzzy technology in medicine and healthcare. Fuzzy Sets and Systems 120, 331–349",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "V",
      "author" : [ "G. Ausiello", "P. Crescenzi", "G. Gambosi" ],
      "venue" : "Kann, Marchetti-Spaccamela, and M. Protasi. Complexity and Approximation: Combinatorial Optimization Problems and Their Approximability Properties, Springer",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Unified approach to fuzzy graph problems",
      "author" : [ "M. Blue", "B. Bush", "J. Puckett" ],
      "venue" : "Fuzzy Sets and Systems, 125, 355–368",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "New directions in fuzzy automata",
      "author" : [ "M. Doostfatemeh", "S. Kremer" ],
      "venue" : "Int. J. Approx. Reason., 38, 175–214",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Computers and Intractability: Guide to the Theory of NP- Completeness",
      "author" : [ "M.R. Garey", "D.S. Johnson" ],
      "venue" : "W. H. Freeman and Company",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1979
    }, {
      "title" : "and W",
      "author" : [ "R. Goetschel Jr" ],
      "venue" : "Voxman. Fuzzy circuits. Fuzzy Sets and Systems, 32, 35-43",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Applied Fuzzy Arithmetic: An Introduction with Engineering Applications",
      "author" : [ "M. Hanss" ],
      "venue" : "Springer",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Fundamentals of fuzzy logical circuits",
      "author" : [ "K. Hirota" ],
      "venue" : "Proc. of IJCAI ’91 Workshops on Fuzzy Logic and Fuzzy Control, Lecture Notes in Computer Science, vol. 833, pp. 143–157",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "The complexity of optimization problems",
      "author" : [ "M.W. Krentel" ],
      "venue" : "J. Comput. Syst., 36, 490–509",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Note on fuzzy languages",
      "author" : [ "E.T. Lee", "L.A. Zadeh" ],
      "venue" : "Inform. Sci., 4, 421–434",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1969
    }, {
      "title" : "Fuzzy models for single-period inventory problem",
      "author" : [ "L. Li", "S.N. Kabadi", "K.P.K. Nair" ],
      "venue" : "Fuzzy Sets and Systems 132, 273–289",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Fuzzy algorithms",
      "author" : [ "E.S. Santos" ],
      "venue" : "Inform. Control, 17, 326–339",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1970
    }, {
      "title" : "Fuzzy sets",
      "author" : [ "L.A. Zadeh" ],
      "venue" : "Inform. Control 8, 338–353",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1965
    }, {
      "title" : "Fuzzy algorithms",
      "author" : [ "L.A. Zadeh" ],
      "venue" : "Inform. Control, 12, 94–102",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1968
    } ],
    "referenceMentions" : [ {
      "referenceID" : 12,
      "context" : "Based on a nonstandard logic, Zadeh [13] tried to capture this fuzziness mathematically by formulating a basic concept of fuzzy set.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 0,
      "context" : ", [1, 7]).",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 6,
      "context" : ", [1, 7]).",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 13,
      "context" : "” Firstly, we will model our fuzzy algorithms by refining the existing notion of fuzzy Turing machines, which were considered by Zadeh [14], Lee and Zadeh [10], and Santos [12] as a fuzzification of ordinary nondeterministic Turing machines (or NTMs, in short) .",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 9,
      "context" : "” Firstly, we will model our fuzzy algorithms by refining the existing notion of fuzzy Turing machines, which were considered by Zadeh [14], Lee and Zadeh [10], and Santos [12] as a fuzzification of ordinary nondeterministic Turing machines (or NTMs, in short) .",
      "startOffset" : 155,
      "endOffset" : 159
    }, {
      "referenceID" : 11,
      "context" : "” Firstly, we will model our fuzzy algorithms by refining the existing notion of fuzzy Turing machines, which were considered by Zadeh [14], Lee and Zadeh [10], and Santos [12] as a fuzzification of ordinary nondeterministic Turing machines (or NTMs, in short) .",
      "startOffset" : 172,
      "endOffset" : 176
    }, {
      "referenceID" : 3,
      "context" : "To cope with a wide range of practical fuzzy problems, Doostfatemeh and Kremer [4] suggested how to expand the then-existing models of fuzzy algorithms by supplementing extra “safe” auxiliary operators to tune up the behaviors of those algorithms.",
      "startOffset" : 79,
      "endOffset" : 82
    }, {
      "referenceID" : 5,
      "context" : ", [6, 8]).",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 7,
      "context" : ", [6, 8]).",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 4,
      "context" : "Such a reducibility notion among fuzzy decision problems makes it possible to designate “complete” problems, which indicate the most difficult problems in a given class of problems to solve in polynomial time, as for the notion of NP-complete problems (see [5]).",
      "startOffset" : 257,
      "endOffset" : 260
    }, {
      "referenceID" : 0,
      "context" : "The notation [0, 1] ∗ (resp.",
      "startOffset" : 13,
      "endOffset" : 19
    }, {
      "referenceID" : 0,
      "context" : ", [0, 1]) denotes the union of [0, 1] for any constant k ∈ N (resp.",
      "startOffset" : 2,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : ", [0, 1]) denotes the union of [0, 1] for any constant k ∈ N (resp.",
      "startOffset" : 31,
      "endOffset" : 37
    }, {
      "referenceID" : 0,
      "context" : "Although a fuzzy (sub)set A of universe U is a map from U to [0, 1], it is also viewed as an ordinary set that is composed of pairs of the form (x, γ), where x ∈ U and γ ∈ [0, 1]; that is, (x, γ) ∈ A iff γ = A(x).",
      "startOffset" : 61,
      "endOffset" : 67
    }, {
      "referenceID" : 0,
      "context" : "Although a fuzzy (sub)set A of universe U is a map from U to [0, 1], it is also viewed as an ordinary set that is composed of pairs of the form (x, γ), where x ∈ U and γ ∈ [0, 1]; that is, (x, γ) ∈ A iff γ = A(x).",
      "startOffset" : 172,
      "endOffset" : 178
    }, {
      "referenceID" : 0,
      "context" : "Remark: It may be possible to expand our definition of fuzzy sets by replacing the unit interval [0, 1] with an arbitrary complete lattice and expand our results further.",
      "startOffset" : 97,
      "endOffset" : 103
    }, {
      "referenceID" : 6,
      "context" : ", [7]) and is closely related to “discretized” fuzzy numbers.",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 0,
      "context" : ", the Hamming distance between two crisp strings) is a fuzzy string quantity s over Σ that satisfies the following condition: there exist a crisp string x0 ∈ Σ ∗ and a crisp function η : [0, 1] → [0, 1] (which may depend on x0) such that (1) Supp(s) is a finite set, (2) η is strictly decreasing function with η(0) = 1 and η(1) = 0, and (3) Cutγ(s) ⊆ Balld(x0, η(γ)) holds for any real number γ ∈ [0, 1], where Balld(x, γ) = {z ∈ Σ ∗ | d(x, z) ≤ γ}.",
      "startOffset" : 187,
      "endOffset" : 193
    }, {
      "referenceID" : 0,
      "context" : ", the Hamming distance between two crisp strings) is a fuzzy string quantity s over Σ that satisfies the following condition: there exist a crisp string x0 ∈ Σ ∗ and a crisp function η : [0, 1] → [0, 1] (which may depend on x0) such that (1) Supp(s) is a finite set, (2) η is strictly decreasing function with η(0) = 1 and η(1) = 0, and (3) Cutγ(s) ⊆ Balld(x0, η(γ)) holds for any real number γ ∈ [0, 1], where Balld(x, γ) = {z ∈ Σ ∗ | d(x, z) ≤ γ}.",
      "startOffset" : 196,
      "endOffset" : 202
    }, {
      "referenceID" : 0,
      "context" : ", the Hamming distance between two crisp strings) is a fuzzy string quantity s over Σ that satisfies the following condition: there exist a crisp string x0 ∈ Σ ∗ and a crisp function η : [0, 1] → [0, 1] (which may depend on x0) such that (1) Supp(s) is a finite set, (2) η is strictly decreasing function with η(0) = 1 and η(1) = 0, and (3) Cutγ(s) ⊆ Balld(x0, η(γ)) holds for any real number γ ∈ [0, 1], where Balld(x, γ) = {z ∈ Σ ∗ | d(x, z) ≤ γ}.",
      "startOffset" : 397,
      "endOffset" : 403
    }, {
      "referenceID" : 3,
      "context" : "For a wider range of practical applications of fuzzy machines, Doostfatemeh and Kremer [4] proposed a rigorous use of “auxiliary functions” to a design of fuzzy algorithms (actually, fuzzy finite automata in their case).",
      "startOffset" : 87,
      "endOffset" : 90
    }, {
      "referenceID" : 0,
      "context" : "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (μ1, μ2, μ3, ξ), where μ1 : [0, 1] 2 → [0, 1], μ2 : [0, 1] + → [0, 1], μ3 : [0, 1] + → [0, 1], and ξ : [0, 1] → [0, 1].",
      "startOffset" : 139,
      "endOffset" : 145
    }, {
      "referenceID" : 0,
      "context" : "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (μ1, μ2, μ3, ξ), where μ1 : [0, 1] 2 → [0, 1], μ2 : [0, 1] + → [0, 1], μ3 : [0, 1] + → [0, 1], and ξ : [0, 1] → [0, 1].",
      "startOffset" : 150,
      "endOffset" : 156
    }, {
      "referenceID" : 0,
      "context" : "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (μ1, μ2, μ3, ξ), where μ1 : [0, 1] 2 → [0, 1], μ2 : [0, 1] + → [0, 1], μ3 : [0, 1] + → [0, 1], and ξ : [0, 1] → [0, 1].",
      "startOffset" : 163,
      "endOffset" : 169
    }, {
      "referenceID" : 0,
      "context" : "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (μ1, μ2, μ3, ξ), where μ1 : [0, 1] 2 → [0, 1], μ2 : [0, 1] + → [0, 1], μ3 : [0, 1] + → [0, 1], and ξ : [0, 1] → [0, 1].",
      "startOffset" : 174,
      "endOffset" : 180
    }, {
      "referenceID" : 0,
      "context" : "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (μ1, μ2, μ3, ξ), where μ1 : [0, 1] 2 → [0, 1], μ2 : [0, 1] + → [0, 1], μ3 : [0, 1] + → [0, 1], and ξ : [0, 1] → [0, 1].",
      "startOffset" : 187,
      "endOffset" : 193
    }, {
      "referenceID" : 0,
      "context" : "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (μ1, μ2, μ3, ξ), where μ1 : [0, 1] 2 → [0, 1], μ2 : [0, 1] + → [0, 1], μ3 : [0, 1] + → [0, 1], and ξ : [0, 1] → [0, 1].",
      "startOffset" : 198,
      "endOffset" : 204
    }, {
      "referenceID" : 0,
      "context" : "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (μ1, μ2, μ3, ξ), where μ1 : [0, 1] 2 → [0, 1], μ2 : [0, 1] + → [0, 1], μ3 : [0, 1] + → [0, 1], and ξ : [0, 1] → [0, 1].",
      "startOffset" : 214,
      "endOffset" : 220
    }, {
      "referenceID" : 0,
      "context" : "For the purpose of intended practical applications, we adopt their idea and introduce four auxiliary operators (μ1, μ2, μ3, ξ), where μ1 : [0, 1] 2 → [0, 1], μ2 : [0, 1] + → [0, 1], μ3 : [0, 1] + → [0, 1], and ξ : [0, 1] → [0, 1].",
      "startOffset" : 223,
      "endOffset" : 229
    }, {
      "referenceID" : 0,
      "context" : "A tuple (μ1, μ2, μ3, ξ) of auxiliary operators is said to be safe if those functions satisfy the following conditions: for any finite nonempty ordered set A and any finite ordered set B, (1) μ1(α, α) = α for any α ∈ [0, 1], (2) μ2({αr}r∈A) = α if αr = α for all r ∈ A, (3) μ3({αr}r∈A) = α if αr = α for all r ∈ A, and (4) ξ(Ø) = 0 and ξ({αr}r∈B) = α if αr = α for r ∈ B.",
      "startOffset" : 216,
      "endOffset" : 222
    }, {
      "referenceID" : 2,
      "context" : "Here, a fuzzy transition function δ is a map from δ : (Q−F )×Σ1 ×Σ2×Σ3 to F(Q×Σ1×Σ2×Γ×D1×D2×D3), where the ith tape uses a tape alphabet Σi and its tape head moves in directions specified as Di (= {0,±1}) for each index i ∈ [3].",
      "startOffset" : 224,
      "endOffset" : 227
    }, {
      "referenceID" : 8,
      "context" : "Using functions in Fuzzy-FPA(γ), we will introduce AF- and APF-reducibilities, which are viewed as natural fuzzifications of Krentel’s metric reducibility [9] and AP-reducibility [2].",
      "startOffset" : 155,
      "endOffset" : 158
    }, {
      "referenceID" : 1,
      "context" : "Using functions in Fuzzy-FPA(γ), we will introduce AF- and APF-reducibilities, which are viewed as natural fuzzifications of Krentel’s metric reducibility [9] and AP-reducibility [2].",
      "startOffset" : 179,
      "endOffset" : 182
    }, {
      "referenceID" : 8,
      "context" : "To compare the computational complexities of two (generic) fuzzy problems, we need to devise a notion of “fuzzy reducibility,” which is a mechanism (similar to the metric reducibility in [9]) of transforming instances of one decision problem to instances of another decision problem so that corresponding outputs of those instances are close enough.",
      "startOffset" : 187,
      "endOffset" : 190
    }, {
      "referenceID" : 1,
      "context" : ", [2]), we introduce the following APF-",
      "startOffset" : 2,
      "endOffset" : 5
    } ],
    "year" : 2015,
    "abstractText" : "We re-examine a practical aspect of combinatorial fuzzy problems of various types, including search, counting, optimization, and decision problems. We are focused only on those fuzzy problems that take series of fuzzy input objects and produce fuzzy values. To solve such problems efficiently, we design fast fuzzy algorithms, which are modeled by polynomial-time deterministic fuzzy Turing machines equipped with read-only auxiliary tapes and write-only output tapes and also modeled by polynomialsize fuzzy circuits composed of fuzzy gates. We also introduce fuzzy proof verification systems to model the fuzzification of nondeterminism. Those models help us identify four complexity classes: Fuzzy-FPA of fuzzy functions, Fuzzy-PA and Fuzzy-NPA of fuzzy decision problems, and Fuzzy-NPAO of fuzzy optimization problems. Based on a relative approximation scheme targeting fuzzy membership degree, we formulate two notions of “reducibility” in order to compare the computational complexity of two fuzzy problems. These reducibility notions make it possible to locate the most difficult fuzzy problems in Fuzzy-NPA and in Fuzzy-NPAO. 1 Background and Results Our purpose is to (1) make a theoretical groundwork necessary to carry out practical analyses of “generalized” fuzzy problems that have naturally arisen in industrial applications and (2) lay out a theoretical framework for “generalized” fuzzy algorithms that efficiently solve those “generalized” fuzzy problems. 1.1 Practical Realm of Fuzzy Problems In real-life situations, many objects naturally embody certain degrees of fuzziness, which can be in general expressed in terms of the uncertainty, ambiguity, vagueness, or imprecision of the objects. Based on a nonstandard logic, Zadeh [13] tried to capture this fuzziness mathematically by formulating a basic concept of fuzzy set. In his theory, an ordinary object without any fuzziness is distinctly called as a “crisp” object, whereas a fuzzy object is a combination of crisp object and its membership degree (or certainty degree) that indicates intuitively how likely the crisp object actually exists. Since its introduction, fuzzy theory has found numerous applications from digital image processing to voice recognition, to telecommunication, further to a field of medicine and agriculture (see, e.g., [1, 7]). To handle a wide variety of practical fuzzy problems, we still need to lay out a groundwork in developing a general, coherent theory of fuzzy problems and fuzzy algorithms that efficiently solve them. In the rest of this paper, we wish to limit our interest within combinatorial problems, which include search, counting, optimization, and decision problems. Let us first recall that, in an ordinary theory, those problems are viewed as functions that map every input instance to its desirable solution (or solutions). In the past literature, there have been numerous ways to fuzzificate ordinary combinatorial problems and those fuzzification methods significantly vary, depending on target areas of interests. We wish to re-examine a fuzzification of those problems to develop our general framework. In many abstract treatments of fuzzy problems, input instances are merely pairs of crisp objects and their membership degrees, instead of more general “fuzzy objects.” To expand a scape of fuzzy-logic applications, it is more desirable to deal with the case where an input instance is a series of admissible fuzzy objects (or fuzzy data) and an output could be a desired “fuzzy object” as a solution derived from the given input. Formally, we define our “fuzzy problem” as a mapping from each series of fuzzy objects to another fuzzy object; thus, the term “fuzzy problem” becomes a synonym of “fuzzy functions.” To describe those fuzzy problems, we need to specify two items: fuzzy (input) instance and fuzzy output. For technical reason, we assume that the support of any fuzzy instance is finite, where the support of a fuzzy object over universe U is an ordinary set of elements in U having positive membership degrees. To distinguish our fuzzy problems This extended abstract appeared in the Proceedings of the Joint 7th International Conference on Soft Computing and Intelligent Systems (SCIS 2014) and 15th International Symposium on Advanced Intelligent Systems (ISIS 2014), December 3–6, 2014, Institute of Electrical and Electronics Engineers (IEEE), pp. 29–35, 2014. Present Affiliation: Department of Information Science, University of Fukui, 3-9-1 Bunkyo, Fukui 910-8507, Japan",
    "creator" : "LaTeX with hyperref package"
  }
}