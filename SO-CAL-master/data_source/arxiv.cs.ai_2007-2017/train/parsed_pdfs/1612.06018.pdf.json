{
  "name" : "1612.06018.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Self-Correcting Models for Model-Based Reinforcement Learning",
    "authors" : [ "Erik Talvitie" ],
    "emails" : [ "erik.talvitie@fandm.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "In model-based reinforcement learning (MBRL) the agent learns a predictive model of its environment and uses it to make decisions. The overall MBRL approach is intuitively appealing and there are many anticipated benefits to learning a model, most notably sample efficiency (Szita and Szepesvári 2010). Despite this, with few exceptions (e.g. Abbeel et al. 2006), model-free methods have been far more successful in large-scale problems. Even as modellearning methods demonstrate increasing prediction accuracy in high-dimensional domains (e.g. Bellemare et al. 2014, Oh et al. 2015) this rarely corresponds to improvements in control performance.\nOne key reason for this disparity is that model-free methods are generally robust to representational limitations that prevent convergence to optimal behavior. In contrast, when the model representation is insufficient to perfectly capture the environment’s dynamics (even in seemingly innocuous ways), or when the planner produces suboptimal plans, MBRL methods can fail catastrophically. If the benefits of MBRL are to be gained in large-scale problems, it is vital to understand how MBRL can be effective even when the model and planner are fundamentally flawed.\nRecently there has been growing awareness that the standard measure of model quality, one-step prediction accu-\nCopyright c© 2017, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nracy, is an inadequate proxy for MBRL performance. For instance, Sorg et al. (2010) and Joseph et al. (2013) both pointed out that the most accurate model by this measure is not necessarily the best for planning. Both proposed optimizing model parameters for control performance using policy gradient methods. Though appealing in its directness, this approach arguably discards some of the benefits of learning a model in the first place.\nTalvitie (2014) pointed out that one-step prediction accuracy does not account for how the model behaves when composed with itself and introduced the Hallucinated Replay meta-algorithm to address this. As illustrated in Figure 1, this approach rolls out the model and environment in parallel, training the model to predict the correct environment state (s4) even when its input is an incorrect sampled state (z3). This effectively causes the model to “self-correct” its rollouts. Hallucinated Replay was shown to enable meaningful planning with flawed models in examples where the standard approach failed. However, it offers no theoretical guarantees. Venkatraman et al. (2015) and Oh et al. (2015) used similar approaches to improve models’ long-range predictions, though not in the MBRL setting.\nThis paper presents novel error bounds that reveal the theoretical principles that underlie the empirical success of Hallucinated Replay. It presents negative results that identify settings where hallucinated training would be ineffec-\nar X\niv :1\n61 2.\n06 01\n8v 2\n[ cs\n.L G\n] 2\n6 Ju\nl 2 01\n7\ntive (Section 2.3) and identifies a case where it yields a tighter performance bound than standard training (Section 2.4). This result allows the derivation of a novel MBRL algorithm with theoretical performance guarantees that are robust to model class limitations (Section 3). The analysis also highlights a previously underexplored practical concern with this approach, which is examined empirically (Section 4.1)."
    }, {
      "heading" : "1.1 Notation and background",
      "text" : "We focus on Markov decision processes (MDP). The environment’s initial state s1 is drawn from a distribution µ. At each step t the environment is in a state st. The agent selects an action at which causes the environment to transition to a new state sampled from the transition distribution: st+1 ∼ P atst . The environment also emits a reward, R(st, at). For simplicity, assume that the reward function is known and is bounded within [0,M ].\nA policy π specifies a way to behave in the MDP. Let π(a | s) = πs(a) be the probability that π chooses action a in state s. For a sequence of actions a1:t let P (s′ | s, a1:t) = P a1:ts (s\n′) be the probability of reaching s′ by starting in s and taking the actions in the sequence. For any state s, action a, and policy π, let Dts,a,π be the state-action distribution obtained after t steps, starting with state s and action a and thereafter following policy π. For a state action distribution ξ, let Dtξ,π = E(s,a)∼ξD t s,a,π . For a state distribution µ let Dtµ,π = Es∼µ,a∼πs D t s,a,π . For some discount factor γ ∈\n[0, 1), let Dµ,π = (1 − γ) ∑∞ t=1 γ\nt−1Dtµ,π be the infinitehorizon discounted state-action distribution under policy π.\nThe T -step state-action value of a policy, QπT (s, a) represents the expected discounted sum of rewards obtained by taking action a in state s and executing π for an additional T − 1 steps: QπT (s, a) =∑T t=1 γ t−1 E(s′,a′)∼Dts,a,π R(s ′, a′). Let the T -step state value V πT (s) = Ea∼πs [Q π T (s, a)]. For infinite horizons we write Qπ = Qπ∞, and V π = V π∞. The agent’s goal will be to learn a policy π that maximizes Es∼µ[V π(s)]. The MBRL approach is to learn a model P̂ , approximating P , and then to use the model to produce a policy via a planning algorithm. We let D̂, Q̂, and V̂ represent the corresponding quantities using the learned model. Let C represent the model class, the set of models the learning algorithm could possibly produce. Critically, in this paper, it is not assumed that C contains a perfectly accurate model."
    }, {
      "heading" : "2 Bounding value error",
      "text" : "We consider an MBRL architecture that uses the simple oneply Monte Carlo planning algorithm (one-ply MC), which has its roots in the “rollout algorithm” (Tesauro and Galperin 1996). For every state-action pair (s, a), the planner executes N T -step “rollouts” in P̂ , starting at s, taking action a, and then following a rollout policy ρ. Let Q̄(s, a) be the average discounted return of the rollouts. For largeN , Q̄will closely approximate Q̂ρT (Kakade 2003). The agent will select its actions greedily with respect to Q̄. Talvitie (2015) bounds the performance of one-ply MC in terms of model quality.\nFor a policy π and state-action distribution ξ, let ξ,π,Tval = E(s,a)∼ξ [ |QπT (s, a) − Q̂πT (s, a)| ] be the error in the T -step state-action values the model assigns to the policy under the given distribution. Then the following result can be straightforwardly adapted from one provided by Talvitie (2015). Lemma 1. Let Q̄ be the state-action value function returned by applying one-ply Monte Carlo to the model P̂ with rollout policy ρ and rollout depth T . Let π̂ be greedy w.r.t. Q̄. For any policy π and state-distribution µ,\nE s∼µ\n[ V π(s)− V π̂(s) ] ≤ 4\n1− γ ξ,ρ,Tval + mc,\nwhere we let ξ(s, a) = 12Dµ,π̂(s, a) + 1 4Dµ,π(s, a) + 1 4 ( (1− γ)µ(s)π̂s(a) + γ ∑ z,bDµ,π(z, b)P b z (s)π̂s(a) ) and mc = 41−γ ‖Q̄ − Q̂ ρ T ‖∞ + 2 1−γ ‖BV ρ T − V ρ T ‖∞ (here"
    }, {
      "heading" : "B is the Bellman operator).",
      "text" : "The mc term represents error due to limitations of the planning algorithm: error due to the sample average Q̄ and the sub-optimality of the T -step value function with respect to ρ. The ξ,ρ,Tval term represents error due to the model parameters. The key factor in the model’s usefulness for planning is the accuracy of the value it assigns to the rollout policy in state-actions visited by π and π̂. Our goal in the next sections is to bound ξ,ρ,Tval in terms of measures of model accuracy, ultimately deriving insight into how to train models that will be effective for MBRL. Proofs may be found in the appendix."
    }, {
      "heading" : "2.1 One-step prediction error",
      "text" : "Intuitively, the value of a policy should be accurate if the model is accurate in states that the policy would visit. We can adapt a bound from Ross and Bagnell (2012). Lemma 2. For any policy π and state-action distribution ξ,\nξ,π,Tval ≤ M\n1− γ T−1∑ t=1 (γt − γT ) E (s,a)∼Dtξ,π [ ‖P as − P̂ as ‖1 ] .\nCombining Lemmas 1 and 2 yields an overall bound on control performance in terms of the model’s prediction error. This result matches common MBRL practice; it recommends minimizing the model’s one-step prediction error. It acknowledges that the model may be imperfect by allowing it to have one-step error in unimportant (i.e. unvisited) states. However, if limitations of the model class prevent the model from achieving low error in important states, this bound can be quite loose, as the following example illustrates.\nConsider the “Shooter” domain introduced by Talvitie (2015), pictured in Figure 2a. The agent moves a spaceship left and right at the bottom of the screen. It can fire bullets upward, but each one has a cost (-1 reward). If a bullet hits one of the three targets, the agent receives 10 reward. Each target has a “bullseye” (the white dots). If a bullet hits the same column as a bullseye, the agent receives an additional 10 reward. Though the control problem is simple, the state/observation space is high-dimensional due to the many possible configurations of objects on the screen.\nIn the original Shooter the bullseyes remained still but here they move back and forth across the targets. As such, the problem is second-order Markov; when the bullseye is in the center, one cannot predict its next position without knowing its previous position. The agent, however, will use a factored Markov model, predicting each pixel conditioned on the current image. It cannot accurately predict the bullseyes’ movement, though it can predict everything else perfectly.\nOne might imagine that this limitation would be fairly minor; the agent can still obtain reward even if it cannot reliably hit the bullseyes. However, consider the sample rollout pictured in Figure 2b. Here each image is sampled from a model’s one-step predictions, and is then given as input for the next predictions. This model has the lowest possible onestep prediction error. Still, as anticipated, it does not correctly predict the movement of the bullseyes in the second image. Because of the resulting errors, the sampled image is unlike any the environment would generate, and therefore unlike any the model has trained on. The model’s uninformed predictions based on this unfamiliar image cause more errors in the third image, and so on. Ultimately this model assigns low probability to a target persisting more than a few steps, making it essentially useless for planning.\nNote, however, that there are models within this model class that are useful for planning. Consider the sample rollout pictured in Figure 2c. The model that generated this rollout makes the same one-step errors as the previous model when given an environment state. However, when it encounters an unreasonable sampled state it still makes reasonable predictions, effectively “self-correcting.” Talvitie (2014) presents several similar examples involving various model deficiencies. These examples illustrate the inadequacy of Lemma 2 when the model class is limited. Models with similar one-step prediction error can vary wildly in their usefulness for planning. The true distinguisher is the accuracy of predictions far into the future."
    }, {
      "heading" : "2.2 Multi-step prediction error",
      "text" : "Since QπT (s, a) = ∑T t=1 γ t−1 E(s′,a′)∼Dts,a,π R(s ′, a′), it is straightforward to bound ξ,π,Tval in terms of multi-step error.\nLemma 3. For any policy π and state-action distribution ξ,\nξ,π,Tval ≤M T∑ t=1 γt−1 E (s,a)∼ξ [ ‖Dts,a,π − D̂ts,a,π‖1 ] .\nThe bound in Lemma 2 has dependence on 11−γ because it effectively assumes the worst possible loss in value if the model samples an “incorrect” state. In contrast, Lemma 3 accounts for the model’s ability to recover after an error, only penalizing it for individual incorrect transitions. Unfortunately, it is difficult to directly optimize for multi-step prediction accuracy. Nevertheless, this bound suggests that algorithms that account for a model’s multi-step error will yield more robust MBRL performance."
    }, {
      "heading" : "2.3 Hallucinated one-step prediction error",
      "text" : "We now seek to formally analyze the practice of hallucinated training, described in Section 1. Venkatraman et al. (2015) provide some analysis but in the uncontrolled time series prediction setting. Here we focus on its impact on control performance in MBRL. As a first step, we derive a bound based on a model’s ability to predict the next environment state, given a state sampled from the model’s own predictions, i.e. to self-correct. For a policy π and state-action distribution ξ let J tξ,π represent the joint distribution over environment and model state-action pairs if π is executed in both simultaneously. Specifically, let\nJ tξ,π(s, a, z, b) = E(s′,a′)∼ξ[D t s′,a′,π(s, a)D̂ t s′,a′,π(z, b)].\nLemma 4. For any policy π and state-action distribution ξ,\nξ,π,Tval ≤M T−1∑ t=1 γt E (s,a,z,b)∼Jtξ,π [ ‖P as − P̂ bz ‖1 ] .\nInspired by “Hallucinated Replay” (Talvitie 2014), we call the quantity on the right the hallucinated one-step error. Hallucinated one-step error is intended as a proxy for multi-step error, but having formalized it we may now see that in some cases it is a poor proxy. Note that, regardless of the policy, the multi-step and one-step error of a perfect model is 0. This is not always so for hallucinated error. Proposition 5. The hallucinated one-step error of a perfect model may be non-zero.\nProof. Consider a simple MDP with three states {s0, sh, st} and a single action a. In the initial state s0, a fair coin is flipped, transitioning to sh or st with equal probability, where it stays forever. Consider a perfect model P̂ = P . Then J1s0,a(sh, a, st, a) = P a s0(sh)P a s0(st) = 0.25. However, |P ash(sh) − P a st(sh)| = 1 − 0 = 1. Thus, the hallucinated one-step error of a perfect model is non-zero.\nHere the environment samples heads and the model samples tails. Given its own state, the model rightly predicts tails, but incurs error nevertheless since the environment’s next state is heads. Because the model and environment dynamics are uncoupled, one cannot distinguish between model error and legitimately different stochastic outcomes.\nAs such, the hallucinated error is misleading when the true dynamics are stochastic. This corroborates the conjecture that Hallucinated Replay may be problematic in stochastic environments (Talvitie 2014). Note that this observation applies not just to hallucinated training, but to any method that attempts to improve multi-step predictions by comparing sample rollouts from the model and the environment.\nWhile it may seem limiting to restrict our attention to deterministic environments, this is still a large, rich class of problems. For instance, Oh et al. (2015) learned models of Atari 2600 games, which are fully deterministic (Hausknecht et al. 2014); human players often perceive them as stochastic due to their complexity. Similarly, in synthetic RL domains stochasticity is often added to simulate complex, deterministic phenomena (e.g. robot wheels slipping on debris), not necessarily to capture inherently stochastic effects in the world. As in these examples, we shall assume that the environment is deterministic but complex, so a limited agent will learn an imperfect, stochastic model.\nThat said, even specialized to deterministic environments, the bound in Lemma 4 is loose for arbitrary policies.\nProposition 6. The hallucinated one-step error of a perfect model may be non-zero, even in a deterministic MDP.\nProof. Alter the coin MDP, giving the agent two actions which fully determine the coin’s orientation. The original dynamics can be recovered via a stochastic policy that randomly selects sh or st and then leaves the coin alone.\nOh et al. (2015) tied action selection to the environment state only (rather than independently selecting actions in the environment and model). This prevents stochastic decoupling but may fail to train the model on state-action pairs that the policy would reach under the model’s dynamics."
    }, {
      "heading" : "2.4 A Tighter Bound",
      "text" : "In the remainder of the paper we assume that the environment is deterministic. Let σa1:ts be the unique state that results from starting in state s and taking the action sequence a1:t. The agent’s model will still be stochastic.\nRecall that our goal is to bound the value error under the one-ply MC rollout policy. Proposition 6 shows that hallucinated error gives a loose bound under arbitrary policies. We now focus on blind policies (Bowling et al. 2006). A blind policy depends only on the action history, i.e. π(at | st, a1:t−1) = π(at | a1:t−1). This class of policies ranges from stateless policies to open-loop action sequences. It includes the uniform random policy, a common rollout policy.\nFor any blind policy π and state-action distribution ξ, let Htξ,π be the distribution over environment state, model state, and action if a single action sequence is sampled from π and then executed in both the model and the environment. So,\nH1ξ,π(s1, z1, a1) = ξ(s1, a1) when z1 = s1 (0 otherwise);\nH2ξ,π(s2, z2, a2) = E(s1,a1)∼ξ[π(a2 | a1)P a1 s1 (s2)P̂ a1 s1 (zs)];\nand for t > 2, Htξ,π(st, zt, at) = E(s1,a1)∼ξ [∑ a2:t−1 π(a2:t | a1)P a1:t−1s1 (st)P̂ a1:t−1 s1 (zt) ] .\nLemma 7. If P is deterministic, then for any blind policy π and any state-action distribution ξ,\nξ,π,Tval ≤ 2M T−1∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] .\nWe can also show that, in the deterministic setting, Lemma 7 gives an upper bound for multi-step error (Lemma 3) and a lower bound for one-step error (Lemma 2). Theorem 8. If P is deterministic, then for any blind policy π and any state-action distribution ξ,\nξ,π,Tval ≤ M T∑ t=1 γt−1 E (s,a)∼ξ [ ‖Dts,a,π − D̂ts,a,π‖1 ] ≤ 2M\nT−1∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] ≤ 2M\n1− γ T−1∑ t=1 (γt − γT ) E (s,a)∼Dtξ,π [ 1− P̂ as (σas ) ] .\nThus, with a deterministic environment and a blind rollout policy, the hallucinated one-step error of the model is more tightly related to MBRL performance than the standard onestep error. This is the theoretical reason for the empirical success of Hallucinated Replay (Talvitie 2014), which trains the model to predict the next environment state, given its own samples as input. We now exploit this fact to develop a novel MBRL algorithm that similarly uses hallucinated training to mitigate the impact of model class limitations and that offers strong theoretical guarantees."
    }, {
      "heading" : "3 Hallucinated DAgger-MC",
      "text" : "The “Data Aggregator” (DAgger) algorithm (Ross and Bagnell 2012) was the first practically implementable MBRL algorithm with performance guarantees agnostic to the model class. It did, however, require that the planner be near optimal. DAgger-MC (Talvitie 2015) relaxed this assumption, accounting for the limitations of the planner that uses the model (one-ply MC). This section augments DAgger-MC to use hallucinated training, resulting in the Hallucinated DAgger-MC algorithm1, or H-DAgger-MC (Algorithm 1).\nIn addition to assuming a particular form for the planner (one-ply MC with a blind rollout policy), H-DAgger-MC assumes that the model will be “unrolled” (similar to, e.g. Abbeel et al. 2006). Rather than learning a single model P̂ , H-DAgger-MC learns a set of models {P̂ 1, . . . , P̂T−1} ⊆ C, where model P̂ i is responsible for predicting the outcome of step i of a rollout, given the state sampled from P̂ i−1 as input. The importance of learning an unrolled model will be discussed more deeply in Section 4.1. 1“Is this a dagger which I see before me, The handle toward my hand? Come, let me clutch thee. I have thee not, and yet I see thee still. Art thou not, fatal vision, sensible To feeling as to sight? Or art thou but A dagger of the mind, a false creation, Proceeding from the heat-oppress’d brain?” [Macbeth 2.1.33–39]\nAlgorithm 1 Hallucinated DAgger-MC Require: Exploration distribution ν, ONLINE-LEARNER,\nMC-PLANNER (blind rollout policy ρ, rollout depth T ), num. iterations N , num. rollouts per iteration K\n1: Get initial datasets D1:T−11 (maybe using ν) 2: Initialize P̂ 1:T−11 ← ONLINE-LEARNER(D 1:T−1 1 ). 3: Initialize π̂1 ← MC-PLANNER(P̂ 1:T−11 ). 4: for n← 2 . . . N do 5: for k ← 1 . . .K do 6: With probability... . Sample (x, b) ∼ ξn... 7: 1/2: Sample (x, b) ∼ Dπ̂n−1µ 8: 1/4: Reset to (x, b) ∼ ν. 9: (1−γ)/4: Sample x ∼ µ, b ∼ π̂n−1(· | x). 10: γ/4: 11: Reset to (y, c) ∼ ν 12: Sample x ∼ P (· | y, c), b ∼ π̂n−1(· | x) 13: Let s← x, z ← x, a← b. 14: for t← 1 . . . T − 1 do . Sample from Htn... 15: Sample s′ ∼ P (· | s, a). 16: Add 〈z, a, s′〉 to Dtn. . Hallucinated training . (DAgger-MC adds 〈s, a, s′〉 instead). 17: Sample z′ ∼ P̂ tn−1(· | z, a). 18: Let s← s′, z ← z′, and sample a ∼ ρ. 19: P̂ 1:T−1n ← ONLINE-LEARNER(P̂ 1:T−1n−1 , D1:T−1n ) 20: π̂n ← MC-PLANNER(P̂ 1:T−1n ). 21: return the sequence π̂1:N\nMuch of the H-DAgger-MC algorithm is identical to DAgger-MC. The main difference lies in lines 14-18, in which ρ is executed in both the environment and the model to generate hallucinated examples. This trains the model to self-correct during rollouts. Like DAgger and DAgger-MC, H-DAgger-MC requires the ability to reset to the initial state distribution µ and also the ability to reset to an “exploration distribution” ν. The exploration distribution ideally ensures that the agent will encounter states that would be visited by a good policy, otherwise no agent could promise good performance. The performance bound for H-DAgger-MC will depend in part on the quality of the selected ν.\nWe now analyze H-DAgger-MC, adapting Ross and Bagnell (2012)’s DAgger analysis. Let Htn be the distribution from which H-DAgger-MC samples a training triple at depth t (lines 6-13 to pick an initial state-action pair, lines 14-18 to roll out). Define the error of the model at depth t to be ̄tprd = 1 N ∑N n=1 E(s,z,a)∼Htn [1− P̂ t n(σ a s | z, a)].\nFor a policy π, let cπν = sups,a Dµ,π(s,a) ν(s,a) represent the mismatch between the discounted state-action distribution under π and the exploration distribution ν. Now, consider the sequence of policies π̂1:N generated by H-DAgger-MC. Let π̄ be the uniform mixture over all policies in the sequence. Let ̄mc = 1N 4 1−γ ∑N n=1(‖Q̄n − Q̂ ρ T,n‖∞ + 2 1−γ ‖BV ρ T − V ρT ‖∞ be the error induced by the choice of planning algorithm, averaged over all iterations.\nLemma 9. In H-DAgger-MC, the policies π̂1:N are such\nthat for any policy π,\nE s∼µ\n[ V π(s)− V π̄(s) ] ≤ 8M\n1− γ cπν T−1∑ t=1 ̄tprd + ̄mc.\nNote that this result holds for any comparison policy π. Thus, if ̄mc is small and the learned models have low hallucinated one-step prediction error, then if ν is similar to the state-action distribution under some good policy, π̄ will compare favorably to it. Like the original DAgger and DAgger-MC results, Lemma 9 has limitations. It uses the L1 loss, which is not always a practical learning objective. It also assumes that the expected loss at each iteration can be computed exactly (i.e. that there are infinitely many samples per iteration). It also applies to the average policy π̄, rather than the last policy in the sequence. Ross and Bagnell (2012) discuss extensions that address more practical loss functions, finite sample bounds, and results for π̂N .\nThe next question is, of course, when will the learned models be accurate? Following Ross and Bagnell (2012) note that ̄tprd can be interpreted as the average loss of an online learner on the problem defined by the aggregated datasets at each iteration. In that case, for each horizon depth t let ̄tmdl be the error of the best model in C under the training distribution at that depth, in retrospect. Specifically, ̄tmdl = infP ′∈C 1 N ∑N n=1 E(s,z,a)∼Htn [1 − P\n′(σas | z, a)]. Then the average regret for the model at depth t is ̄trgt = ̄ t prd − ̄tmdl. For a no-regret online learning algorithm, ̄trgt → 0 as N →∞. This gives the following bound on H-DAgger-MC’s performance in terms of model regret. Theorem 10. In H-DAgger-MC, the policies π̂1:N are such that for any policy π,\nE s∼µ\n[ V π(s)− V π̄(s) ] ≤ 8M\n1− γ cπν T−1∑ t=1 (̄tmdl + ̄ t rgt) + ̄mc,\nand if the model learning algorithm is no-regret then ̄trgt → 0 as N →∞ for each 1 ≤ t ≤ T − 1.\nTheorem 10 says that if C contains a low-error model for each rollout depth then low error models will be learned. Then, as discussed above, if ̄mc is small and ν visits important states, the resulting policy will yield good performance. Notably, even with hallucinated training, if C contains a perfect model, H-DAgger-MC will learn a perfect model.\nIt is important to note that this result does not promise that H-DAgger-MC will eventually achieve the performance of the best performing set of models in the class. The model at each rollout depth is trained to minimize prediction error given the input distribution provided by the shallower models. Note, however, that changing the parameters of a model at one depth alters the training distribution for deeper models. It is possible that better overall error could be achieved by increasing the prediction error at one depth in exchange for a favorable state distribution for deeper models. This effect is not taken into account by H-DAgger-MC."
    }, {
      "heading" : "4 Empirical Illustration",
      "text" : "In this section we illustrate the practical impact of optimizing hallucinated error by comparing DAgger, DAgger-MC,\nand H-DAgger-MC in the Shooter example described in Section 2.12. The experimental setup matches that of Talvitie (2015) for comparison’s sake, though the qualitative comparison presented here is robust to the parameter settings.\nIn all cases one-ply MC was used with 50 uniformly random rollouts of depth 15 at every step. The exploration distribution was generated by following the optimal policy with (1−γ) probability of termination at each step. The model for each pixel was learned using Context Tree Switching (Veness et al. 2012), similar to the FAC-CTW algorithm (Veness et al. 2011), and used a 7× 7 neighborhood around the pixel in the previous timestep as input. Data was shared across all positions. The discount factor was γ = 0.9. In each iteration 500 training rollouts were generated and the resulting policy was evaluated in an episode of length 30. The discounted return obtained by the policy in each iteration is reported, averaged over 50 trials.\nThe results can be seen in Figure 3a and 3b. The shaded regions represent 95% confidence intervals for the mean performance. The benchmark lines labeled “Random” and “Perfect Model” represent the average performance of the uniform random policy and one-ply Monte Carlo using a perfect model, respectively. In Figure 3a the bullseyes move, simulating the typical practical reality that C does not contain a perfect model. In Figure 3b the bullseyes have fixed positions, so C does contain a perfect model.\nAs observed by Talvitie (2015), DAgger performs poorly in both versions, due to the suboptimal planner. DAgger-MC is able to perform well with fixed bullseyes (Figure 3b), but with moving bullseyes the model suffers from compounding errors and is not useful for planning (Figure 3a). This holds for a single model and for an “unrolled” model.\nIn these experiments one practically-minded alteration was made to the H-DAgger-MC algorithm. In early training the model is highly inaccurate, and thus deep rollouts produce incoherent samples. Training with these samples is counter-productive (also, the large number of distinct, nonsensical contexts renders CTS impractical). For these experiments, training rollouts in iteration i were truncated at depth bi/10c. Planning rollouts in these early iterations use the models that have been trained so far and then repeatedly apply the deepest model in order to complete the rollout. Talvitie (2014), Venkatraman et al. (2015), and Oh et al. (2015) all similarly discarded noisy examples early in training. This transient modification does not impact H-DAggerMC’s asymptotic guarantees.\nIn Figure 3a it is clear that H-DAgger-MC obtains a good policy despite the limitations of the model class. Hallucinated training has made MBRL possible with both a flawed model and a flawed planner while the standard approach has failed entirely. In the case that C contains a perfect model (rare in problems of genuine interest) H-DAgger-MC is outperformed by DAgger-MC. Despite the adjustment to training, deep models still receive noisy inputs. Theoretically the model should become perfectly accurate in the limit, though in practice it may do so very slowly.\n2Source code for these experiments may be found at github. com/etalvitie/hdaggermc."
    }, {
      "heading" : "4.1 Impact of the unrolled model",
      "text" : "Recall that the H-DAgger-MC algorithm assumes the model will be “unrolled,” with a separate model responsible for sampling each step in a rollout. This has clear practical disadvantages, but it is important theoretically. When one model is used across all time-steps, convergence to a perfect model cannot be guaranteed, even if one exists in C.\nIn Figure 3c, H-DAgger-MC has been trained using a single model in Shooter with fixed bullseyes. The temporary truncation schedule described above is employed, but the training rollouts have been permanently limited to various depths. First consider the learning curve marked “Depth 15”, where training rollouts are permitted to reach the maximum depth. While the rollouts are temporarily truncated the model does well, but performance degrades as longer rollouts are permitted even though C contains a perfect model!\nRecall from Section 3 that changing the model parameters impacts both prediction error and the future training distribution. Furthermore, training examples generated by deep rollouts may contain highly flawed samples as inputs. Sometimes attempting to “correct” a large error (i.e. reduce prediction error) causes additional, even worse errors in the next iteration (i.e. harms the training distribution). For instance consider a hallucinated training example with the 4th screen from Figure 2b as input and the 5th screen from Figure 2a as the target. The model would effectively learn that targets can appear out of nowhere, an error that would be even harder to correct in future iterations. With a single model across timesteps, a feedback loop can emerge: the model parameters change to attempt to correct large errors, thereby causing larger errors, and so on. This feedback loop causes the observed performance crash. With an unrolled model the parameters of each sub-model cannot impact that sub-model’s own training distribution, ensuring stability.\nNote that none of Talvitie (2014), Venkatraman et al. (2015), or Oh et al. (2015) used an unrolled model. As such, all of their approaches are subject to this concern. Notably, all three limited the depth of training rollouts, presumably to prevent overly noisy samples. Figure 3c shows that in this experiment, the shorter the training rollouts, the better the performance. These results show that it may be possible in practice to avoid unrolling the model by truncating training rollouts, though for now there is no performance guarantee or principled choice of rollout depth."
    }, {
      "heading" : "5 Conclusions and future work",
      "text" : "The primary contribution of this work is a deeper theoretical understanding of how to perform effective MBRL in the face of model class limitations. Specifically we have examined a novel measure of model quality that, under some assumptions, is more tightly related to MBRL performance than standard one-step prediction error. Using this insight, we have also analyzed a MBRL algorithm that achieves good control performance despite flaws in the model and planner and provides strong theoretical performance guarantees.\nWe have also seen negative results indicating that hallucinated one-step error may not be an effective optimization criterion in the most general setting. This poses the\nopen challenge of relaxing the assumptions of deterministic dynamics and blind policies, or of developing alternative approaches for improving multi-step error in more general settings. We have further observed that hallucinated training can cause stability issues, since model parameters affect both prediction error and the training distribution itself. It would be valuable to develop techniques that account for both of these effects when adapting model parameters.\nSpecializing to the one-ply MC planning algorithm may seem restrictive, but then again, the choice of planning algorithm cannot make up for a poor model. When the model class is limited, H-DAgger-MC is likely still a good choice over DAgger, even with a more sophisticated planner. Still, it would be valuable to investigate whether these principles can be applied to more sophisticated planning algorithms.\nThough this work has assumed that the reward function is known, the results presented here can be straightforwardly extended to account for reward error. However, this also raises the interesting point that sampling an “incorrect” state has little negative impact if the sampled state’s rewards and transitions are similar to the “correct” state. It may be possible to exploit this to obtain still tighter bounds, and more effective guidance for model learning in MBRL architectures."
    }, {
      "heading" : "Acknowledgements",
      "text" : "This work was supported in part by NSF grant IIS-1552533. Many thanks to Marc Bellemare whose feedback has positively influenced the work, both in substance and presentation. Thanks to Drew Bagnell and Arun Venkatraman for their valuable insights. Thanks also to Joel Veness for his freely available FAC-CTW and CTS implementations (http://jveness.info/software/)."
    }, {
      "heading" : "Appendix: Proofs",
      "text" : "Lemma 2. For any policy π and state-action distribution ξ,\nξ,π,Tval ≤ M\n1− γ T−1∑ t=1 (γt − γT ) E (s,a)∼Dtξ,π [ ‖P as − P̂ as ‖1 ] .\nProof. First note that\nξ,π,Tval = E (s1,a1)∼ξ\n[ |Q̂πT (s1, a1)−QπT (s1, a1)| ] = γ E\n(s1,a1)∼ξ [ | E s∼P̂a1s1 [V̂ πT−1(s)]− E s∼Pa1s1 [V πT−1(s)]| ]\n= γ E (s1,a1)∼ξ [∣∣ E s∼P̂a1s1 [V̂ πT−1(s)]− E s∼Pa1s1 [V̂ πT−1(s)]\n+ E s∼Pa1s1 [V̂ πT−1(s)]− E s∼Pa1s1\n[V πT−1(s)] ∣∣]\n≤ γ E (s1,a1)∼ξ [∣∣ E s∼P̂a1s1 a∼πs [Q̂πT−1(s, a)]− E s∼Pa1s1 a∼πs [Q̂πT−1(s, a)] ∣∣]\n+ γ E (s,a)∼D2ξ,π\n[ |Q̂πT−1(s, a)−QπT−1(s, a)])| ] .\nRolling out the recurrence gives\nξ,π,Tval = E (s1,a1)∼ξ\n[ |Q̂πT (s1, a1)−QπT (s1, a1)| ] ≤ T−1∑ t=1 γt E (s,a)∼Dtξ,π [∣∣ E s′∼P̂as a′∼πs′ [Q̂πT−t(s ′, a′)]\n− E s′∼Pas a′∼πs′ [Q̂πT−t(s ′, a′)]\n∣∣]\n≤ T−1∑ t=1 γt ∑ s′,a′ πs′(a ′)Q̂πT−t(s ′, a′)\nE (s,a)∼Dtξ,π\n[ |P̂ as (s′)− P as (s′)| ] ≤ T−1∑ t=1 γt M(1− γT−t) 1− γ E (s,a)∼Dtξ,π [ ‖P̂ as − P as ‖1\n] = M\n1− γ T−1∑ t=1 (γt − γT ) E (s,a)∼Dtξ,π [ ‖P̂ as − P as ‖1 ] .\nLemma 3. For any policy π and state-action distribution ξ,\nξ,π,Tval ≤M T∑ t=1 γt−1 E (s,a)∼ξ [ ‖Dts,a,π − D̂ts,a,π‖1 ] .\nProof. This follows straightforwardly from the definition.\nξ,π,Tval = E (s,a)∼ξ\n[ |QπT (s, a)− Q̂πT (s, a)| ] = E\n(s,a)∼ξ [∣∣∣∣ T∑ t=1 γt−1 ∑ (s′,a′) (Dts,a,π(s ′, a′)\n− D̂ts,a,π(s′, a′))R(s′, a′) ∣∣∣∣ ]\n≤ T∑ t=1 γt−1 E (s,a)∼ξ [ ∑ (s′,a′) ∣∣(Dts,a,π(s′, a′) − D̂ts,a,π(s′, a′))R(s′, a′)\n∣∣] ≤M\nT∑ t=1 γt−1 E (s,a)∼ξ [ ∑ (s′,a′) ∣∣Dts,a,π(s′, a′) − D̂ts,a,π(s′, a′)\n∣∣] = M\nT∑ t=1 γt−1 E (s,a)∼ξ [ ‖Dts,a,π − D̂ts,a,π‖1 ] .\nLemma 4. For any policy π and state-action distribution ξ,\nξ,π,Tval ≤M T−1∑ t=1 γt E (s,a,z,b)∼Jtξ,π [ ‖P as − P̂ bz ‖1 ] .\nProof. First note that for any s1, a1, s′, a′ and for t > 1,\nDts1,a1,π(s ′, a′)− D̂ts1,a1,π(s ′, a′) = ∑ s,a Dt−1s1,a1,π(s, a)P a s (s ′)πs′(a ′)\n− ∑ z,b D̂t−1s1,a1,π(z, b)P̂ b z (s ′)πs′(a ′)\n= πs′(a ′) (∑ s,a Dt−1s1,a1,π(s, a)P a s (s ′) ∑ z,b D̂t−1s1,a1,π(z, b)\n− ∑ z,b D̂t−1s1,a1,π(z, b)P̂ b z (s ′) ∑ s,a Dt−1s1,a1,π(s, a)\n)\n= πs′(a ′) ( ∑ s,a,z,b Dt−1s1,a1,π(s, a)D̂ t−1 s1,a1,π(z, b)\n(P as (s ′)− P̂ bz (s′))\n) .\nFurther note that for any s, a, π, D1s,a,π = D̂ 1 s,a,π . Com-\nbining these facts with Lemma 3 we see that\nξ,π,Tval = E (s,a)∼ξ\n[ |QπT (s, a)− Q̂πT (s, a)| ] ≤M\nT∑ t=1 γt−1 E (s,a)∼ξ [ ‖Dts,a,π − D̂ts,a,π‖1 ] = M\nT∑ t=2 γt−1 E (s1,a1)∼ξ [∑ s′,a′ ∣∣∣Dts1,a1,π(s′, a′) − D̂ts1,a1,π(s ′, a′) ∣∣∣]\n= M T−1∑ t=1 γt E (s1,a1)∼ξ [∑ s′,a′ ∣∣∣Dt+1s1,a1,π(s′, a′) − D̂t+1s1,a1,π(s ′, a′) ∣∣∣]\n≤M T−1∑ t=1 γt E (s1,a1)∼ξ [ ∑ s,a,z,b Dts1,a1,π(s, a)D̂ t s1,a1,π(z, b)\n∑ s′ ∣∣∣P as (s′)− P̂ bz (s′)∣∣∣]\n= M T−1∑ t=1 γt ∑ s,a,z,b ‖P as − P̂ bz ‖1\nE (s1,a1)∼ξ\n[ Dts1,a1,π(s, a)D̂ t s1,a1,π(z, b) ] = M\nT−1∑ t=1 γt E (s,a,z,b)∼Jtξ,π [ ‖P as − P̂ bz ‖1 ] .\nLemma 7. If P is deterministic, then for any blind policy π and any state-action distribution ξ,\nξ,π,Tval ≤ 2M T−1∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] .\nProof. As in the proof of Lemma 4 note that for any s1, a1, π,D1s1,a1,π = D̂ 1 s1,a1,π . Further note that under these assumptions, for any s1, a1, ‖D2s1,a1,π − D̂ 2 s1,a1,π ∥∥ 1\n= ∑ s,a π(a) ∣∣P a1s1 (s)− P̂ a1s1 (s)∣∣ = ∑ s ∣∣P a1s1 (s)− P̂ a1s1 (s)∣∣. For t > 2, ‖Dts1,a1,π − D̂ t s1,a1,π‖1\n= ∑ st ∣∣∣∣∑ a2:t π(a2:t | a1) (∑ s P a1:t−2s1 (s)P at−1 s (st)\n− ∑ z P̂ a1:t−2s1 (z)P̂ at−1 z (st) )∣∣∣∣ = ∑ st ∣∣∣∣ ∑ a2:t−1\nπ(a2:t−1 | a1)(∑ s P a1:t−2s1 (s)P at−1 s (st) ∑ z P̂ a1:t−2s1 (z)\n− ∑ z P̂ a1:t−2s1 (z)P̂ at−1 z (st) ∑ s P a1:t−2s1 (s) )∣∣∣∣ = ∑ st ∣∣∣∣ ∑ a2:t−1 π(a2:t−1 | a1) ∑ s,z\nP a1:t−2s1 (s)P̂ a1:t−2 s1 (z)(\nP at−1s (st)− P̂ at−1z (st) )∣∣∣∣\n= ∑ st ∣∣∣∣ ∑ a2:t−1 π(a2:t−1 | a1) ∑ s,z\nP a1:t−2s1 (s)P̂ a1:t−2 s1 (z)(\nP at−1s (st)− P̂ at−1z (st) )∣∣∣∣\n≤ ∑ a2:t−1 π(a2:t−1) ∑ s,z\nP a1:t−2s1 (s)P̂ a1:t−2 s1 (z)∑\nst\n∣∣∣P at−1s (st)− P̂ at−1z (st)∣∣∣.\nNow, for any s, z, a, ∑ st ∣∣∣P as (st)− P̂ az (st)∣∣∣ = ( 1− P̂ az (σas )\n) + ∑ st 6=σas ∣∣− P̂ az (st)∣∣ = 2 ( 1− P̂ az (σas ) ) .\nCombining these facts with Lemma 3,\nξ,π,Tval = E (s,a)∼ξ\n[ |QπT (s, a)− Q̂πT (s, a)| ] ≤M\nT∑ t=1 γt−1 E (s,a)∼ξ [ ‖Dts,a,π − D̂ts,a,π‖1 ] = M\nT∑ t=2 γt−1 E (s1,a1)∼ξ [ ‖Dts1,a1,π − D̂ t s1,a1,π‖1 ] = Mγ E\n(s1,a1)∼ξ\n[ ‖D2s1,a1,π − D̂ 2 s1,a1,π‖1 ] +M\nT∑ t=3 γt−1 E (s1,a1)∼ξ [ ‖Dts1,a1,π − D̂ t s1,a1,π‖1 ] = Mγ E\n(s1,a1)∼ξ\n[ ‖D2s1,a1,π − D̂ 2 s1,a1,π‖1 ] +M\nT−1∑ t=2 γt E (s1,a1)∼ξ [∑ s′,a′ ‖Dt+1s1,a1,π − D̂ t+1 s1,a1,π‖1 ] ≤ 2Mγ E\n(s1,a1)∼ξ\n[ 1− P̂ a1s1 (σ a1 s1 ) ]\n+ 2M T−1∑ t=2 γt E (s1,a1)∼ξ [∑ a2:t π(a2:t | a1)\n∑ s,z P a1:t−1s1 (s)P̂ a1:t−1 s1 (z) ( 1− P̂ atz (σats ) )] = 2Mγ E\n(s1,a1)∼ξ\n[ 1− P̂ a1s1 (σ a1 s1 ) ]\n+ 2Mγ2 ∑\ns2,z2,a2\n( 1− P̂ a2z2 (σ a2 s2 ) )\nE (s1,a1)∼ξ\n[ π(a2 | a1)P a1s1 (s2)P̂ a1 s1 (z2) ] + 2M\nT−1∑ t=3 γt ∑ st,zt,at ( 1− P̂ atzt (σ at st ) )\nE (s1,a1)∼ξ [ ∑ a2:t−1 π(a2:t | a1)P a1:t−1s1 (st)P̂ a1:t−1 s1 (zt) ] = 2Mγ E\n(s,z,a)∼H1ξ,π\n[ 1− P̂ az (σas ) ] + 2Mγ2 E\n(s,z,a)∼H2ξ,π\n[ 1− P̂ az (σas ) ] + 2M\nT−1∑ t=3 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ]\n= 2M T−1∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ (σas | z, a) ] .\nTheorem 8. If P is deterministic, then for any blind policy π and any state-action distribution ξ,\nξ,π,Tval ≤ M T∑ t=1 γt−1 E (s,a)∼ξ [ ‖Dts,a,π − D̂ts,a,π‖1 ] ≤ 2M\nT−1∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] ≤ 2M\n1− γ T−1∑ t=1 (γt − γT ) E (s,a)∼Dtξ,π [ 1− P̂ as (σas ) ] .\nProof. The first inequality was proven in Lemma 3. The proof of Lemma 7 also proves the second inequality. Thus, we shall focus on the third inequality. First note that\nT−1∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] = ∑ s,a T−1∑ t=1 γtHtξ,π(s, s, a) [ 1− P̂ as (σas )\n] +\n∑ s,z 6=s,a T−1∑ t=1 γtHtξ,π(s, z, a) [ 1− P̂ az (σas ) ] .\nThis expression has two terms; the first captures prediction error when the model and environment are in the same state, the second when the environment and world state differ. Consider the first term.∑ s,a T−1∑ t=1 γtHtξ,π(s, s, a) [ 1− P̂ as (σas )\n] = ∑ s,a ( 1− P̂ as (σas )\n) ( γξ(s, a) + γ2 E\n(s1,a1)∼ξ π(a | a1)P a1s1 (s)P̂ a1 s1 (s) ) +\nT−1∑ t=3 γt ∑ st,at ( 1− P̂ atst (σ at st ) )\nE (s1,a1)∼ξ [ ∑ a2:t−1 π(a2:t | a1)P a1:t−1s1 (st)P̂ a1:t−1 s1 (st) ] = ∑ s,a ( 1− P̂ as (σas )\n) ( γξ(s, a) + γ2 E\n(s1,a1)∼ξ π(a | a1)P a1s1 (s) ) +\nT−1∑ t=3 γt ∑ st,at ( 1− P̂ atst (σ at st ) )\nE (s1,a1)∼ξ [ ∑ a2:t−1 π(a2:t | a1)P a1:t−1s1 (st) ]\n= T−1∑ t=1 γt E (s,a)∼Dtξ,π [ 1− P̂ as (σas ) ] .\nNow consider the second term. Note that for any a and s 6= z, H1ξ,π(s, z, a) = 0. So,∑ s,z 6=s,a T−1∑ t=1 γtHtξ,π(s, z, a) [ 1− P̂ az (σas )\n] =\n∑ s,z 6=s,a T−1∑ t=2 γtHtξ,π(s, z, a) [ 1− P̂ az (σas ) ] =\n∑ s,z 6=s,a T−2∑ t=1 γt+1Ht+1ξ,π (s, z, a) [ 1− P̂ az (σas ) ] ≤\n∑ s,z 6=s,a T−2∑ t=1 γt+1Ht+1ξ,π (s, z, a)\n= γ ∑\ns′,z′,a′ ( ∑ s,z 6=s P a ′ s′ (s)P̂ a′ z′ (z) ) T−2∑ t=1 γtHtξ,π(s ′, z′, a′)\n= γ ∑\ns′,z′,a′\n( 1− P̂ a ′ z′ (σ a′ s′ ) ) T−2∑ t=1 γtHtξ,π(s ′, z′, a′)\n= γ T−2∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] .\nCombining the two reveals a recurrence relation. T−1∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] ≤ T−1∑ t=1 γt E (s,a)∼Dtξ,π [ 1− P̂ as (σas )\n] + γ\nT−2∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] .\nUnrolling the recurrence, we see that T−1∑ t=1 γt E (s,z,a)∼Htξ,π [ 1− P̂ az (σas ) ] ≤ T−1∑ j=1 γj−1 T−j∑ t=1 γt E (s,a)∼Dtξ,π [ 1− P̂ as (σas ) ] .\nNow note that T−1∑ j=1 γj−1 T−j∑ t=1 γt E (s,a)∼Dtξ,π [ 1− P̂ as (σas ) ] =\nT−1∑ t=1 T−t∑ j=1 γj−1γt E (s,a)∼Dtξ,π [ 1− P̂ as (σas ) ] =\nT−1∑ t=1 γt E (s,a)∼Dtξ,π [ 1− P̂ as (σas ) ] T−t∑ j=1 γj−1\n= T−1∑ t=1 γt E (s,a)∼Dtξ,π [ 1− P̂ as (σas ) ]1− γT−t 1− γ\n= 1\n1− γ T−1∑ t=1 (γt − γT ) E (s,a)∼Dtξ,π [ 1− P̂ as (σas )) ] .\nLemma 9. In H-DAgger-MC, the policies π̂1:N are such that for any policy π,\nE s∼µ\n[ V π(s)− V π̄(s) ] ≤ 8M\n1− γ cπν T−1∑ t=1 ̄tprd + ̄mc.\nProof. Recall that\nE s∼µ\n[ V π(s)− V π̄(s) ] = 1\nN N∑ n=1 E s∼µ [ V π(s)− V π̂n(s) ] .\nand by Lemma 1 for any n ≥ 1,\nE s∼µ\n[ V π(s)− V π̂n(s) ] ≤\n4\n1− γ E (s,a)∼ξπ,π̂nµ [|Q̂ρT,n(s, a)−Q ρ T (s, a)|] + ̄mc,\nwhere\nξπ,π̂nµ (s, a) = 1\n2 Dµ,π̂n(s, a) +\n1 4 Dµ,π(s, a)\n+ 1\n4\n( (1− γ)µ(s)π̂n(a | s)\n+ γ ∑ z,b Dµ,π(z, b)P b z (s)π̂n(a | s) ) .\nCombining this with Lemma 7,\n1\nN N∑ n=1 4 1− γ E (s,a)∼ξπ,π̂nµ [|Q̂ρT,n(s, a)−Q ρ T (s, a)|] + ̄mc\n≤ 1 N N∑ n=1 8M 1− γ T−1∑ t=1 γt\nE (s,z,a)∼Ht,n\nξ π,π̂n µ ,ρ\n[ 1− P̂ tn(σas | z, a) ] + ̄mc\n≤ 8M 1− γ 1 N N∑ n=1 T−1∑ t=1\nE (s,z,a)∼Ht,n\nξ π,π̂n µ ,ρ\n[ 1− P̂ tn(σas | z, a) ] + ̄mc.\nNow note that for any t and any n,\nE (s,z,a)∼Ht,n\nξ π,π̂n µ ,ρ\n[ 1− P̂ tn(σas | z, a) ] = 1\n2 ∑ s′,a′ Dµ,π̂n(s ′, a′) E (s,z,a)∼Ht,n s′,a′,ρ [ 1− P̂ tn(σas | z, a) ] + 1\n4 ∑ s′,a′ Dµ,π(s ′, a′) E (s,z,a)∼Ht,n s′,a′,ρ [ 1− P̂ tn(σas | z, a) ] + γ\n4 ∑ s′,a′ ∑ s′′,a′′ Dµ,π(s ′′, a′′)P a ′′ s′′ (s ′)π̂n(a ′ | s′)\nE (s,z,a)∼Ht,n\ns′,a′,ρ\n[ 1− P̂ tn(σas | z, a) ] +\n1− γ 4 ∑ s′,a′ µ(s′)π̂n(a ′ | s′)\nE (s,z,a)∼Ht,n\ns′,a′,ρ\n[ 1− P̂ tn(σas | z, a) ] ≤ 1\n2 ∑ s′,a′ Dµ,π̂n(s ′, a′) E (s,z,a)∼Ht,n s′,a′,ρ [ 1− P̂ tn(σas | z, a) ] + 1\n4 cπν ∑ s′,a′ ν(s′, a′) E (s,z,a)∼Ht,n s′,a′,ρ [ 1− P̂ tn(σas | z, a) ] + γ\n4 cπν ∑ s′,a′ ∑ s′′,a′′ ν(s′′, a′′)P a ′′ s′′ (s ′)π̂n(a ′ | s′)\nE (s,z,a)∼Ht,n\ns′,a′,ρ\n[ 1− P̂ tn(σas | z, a) ] +\n1− γ 4 ∑ s′,a′ µ(s′)π̂n(a ′ | s′)\nE (s,z,a)∼Ht,n\ns′,a′,ρ\n[ 1− P̂ tn(σas | z, a) ] ≤ cπν ( 1\n2 ∑ s′,a′ Dµ,π̂n(s ′, a′)\nE (s,z,a)∼Ht,n\ns′,a′,ρ\n[ 1− P̂ tn(σas | z, a) ] + 1\n4 ∑ s′,a′ ν(s′, a′) E (s,z,a)∼Ht,n s′,a′,ρ [ 1− P̂ tn(σas | z, a) ] + γ\n4 ∑ s′,a′ ∑ s′′,a′′ ν(s′′, a′′)P a ′′ s′′ (s ′)π̂n(a ′ | s′)\nE (s,z,a)∼Ht,n\ns′,a′,ρ\n[ 1− P̂ tn(σas | z, a) ] +\n1− γ 4 ∑ s′,a′ µ(s′)π̂n(a ′ | s′)\nE (s,z,a)∼Ht,n\ns′,a′,ρ\n[ 1− P̂ tn(σas | z, a) ]) = cπν E\n(s,z,a)∼Ht,nξn,ρ\n[ 1− P̂ tn(σas | z, a) ] .\nWhen t = 1, E(s,z,a)∼Ht,nξn,ρ [ 1 − P̂ tn(σas | z, a) ] =\nE(s,a)∼ξn(s,a) [ 1− P̂ tn(σas | s, a) ] . When t > 1,\nE (s,z,a)∼Ht,nξn,ρ\n[ 1− P̂ tn(σas | z, a) ] =\n∑ st,zt,at E (s1,a1)∼ξn [ ∑ a1:t−1 ρ(a2:t | a1)\nP a0:t−1s1 (st | s1, a0:t−1)P̂ 1:t−1 n (zt | s1, a0:t−1) ] ( 1− P̂ tn(σatst | zt, at)\n) = E\n(s,z,a)∼Htn\n[ 1− P̂ tn(σas | z, a) ] .\nThus, putting it all together, we have shown that\nE s∼µ\n[ V π(s)− V π̄(s) ] ≤ 8M\n1− γ cπν\n1\nN N∑ n=1 T−1∑ t=1 E (s,z,a)∼Htn [ 1− P̂ tn(σas | z, a) ] + ̄mc\n= 8M\n1− γ cπν T−1∑ t=1 ̄tprd + ̄mc."
    } ],
    "references" : [ {
      "title" : "Using inaccurate models in reinforcement learning",
      "author" : [ "P. Abbeel", "M. Quigley", "A.Y. Ng" ],
      "venue" : "In Proceedings of the 23rd International Conference on Machine Learning,",
      "citeRegEx" : "Abbeel et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Abbeel et al\\.",
      "year" : 2006
    }, {
      "title" : "Skip context tree switching",
      "author" : [ "M.G. Bellemare", "J. Veness", "E. Talvitie" ],
      "venue" : "In Proceedings of the 31st International Conference on Machine Learning,",
      "citeRegEx" : "Bellemare et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Bellemare et al\\.",
      "year" : 2014
    }, {
      "title" : "A neuroevolution approach to general atari game playing",
      "author" : [ "M. Hausknecht", "J. Lehman", "R. Miikkulainen", "P. Stone" ],
      "venue" : "IEEE Transactions on Computational Intelligence and AI in Games,",
      "citeRegEx" : "Hausknecht et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Hausknecht et al\\.",
      "year" : 2014
    }, {
      "title" : "Reinforcement learning with misspecified model classes",
      "author" : [ "J. Joseph", "A. Geramifard", "J.W. Roberts", "J.P. How", "N. Roy" ],
      "venue" : "IEEE International Conference on Robotics and Automation,",
      "citeRegEx" : "Joseph et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Joseph et al\\.",
      "year" : 2013
    }, {
      "title" : "On the sample complexity of reinforcement learning",
      "author" : [ "S.M. Kakade" ],
      "venue" : "PhD thesis, University of London,",
      "citeRegEx" : "Kakade.,? \\Q2003\\E",
      "shortCiteRegEx" : "Kakade.",
      "year" : 2003
    }, {
      "title" : "Actionconditional video prediction using deep networks in atari games",
      "author" : [ "J. Oh", "X. Guo", "H. Lee", "R.L. Lewis", "S. Singh" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Oh et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Oh et al\\.",
      "year" : 2015
    }, {
      "title" : "Agnostic system identification for modelbased reinforcement learning",
      "author" : [ "S. Ross", "D. Bagnell" ],
      "venue" : "In Proceedings of the 29th International Conference on Machine Learning,",
      "citeRegEx" : "Ross and Bagnell.,? \\Q2012\\E",
      "shortCiteRegEx" : "Ross and Bagnell.",
      "year" : 2012
    }, {
      "title" : "Reward design via online gradient ascent",
      "author" : [ "J. Sorg", "R.L. Lewis", "S. Singh" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Sorg et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Sorg et al\\.",
      "year" : 2010
    }, {
      "title" : "Model-based reinforcement learning with nearly tight exploration complexity bounds",
      "author" : [ "I. Szita", "C. Szepesvári" ],
      "venue" : "In Proceedings of the 27th International Conference on Machine Learning,",
      "citeRegEx" : "Szita and Szepesvári.,? \\Q2010\\E",
      "shortCiteRegEx" : "Szita and Szepesvári.",
      "year" : 2010
    }, {
      "title" : "Model regularization for stable sample rollouts",
      "author" : [ "E. Talvitie" ],
      "venue" : "In Proceedings of the 30th Conference on Uncertainty in Artificial Intelligence,",
      "citeRegEx" : "Talvitie.,? \\Q2014\\E",
      "shortCiteRegEx" : "Talvitie.",
      "year" : 2014
    }, {
      "title" : "Agnostic system identification for monte carlo planning",
      "author" : [ "E. Talvitie" ],
      "venue" : "In Proceedings of the 29th AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Talvitie.,? \\Q2015\\E",
      "shortCiteRegEx" : "Talvitie.",
      "year" : 2015
    }, {
      "title" : "On-line policy improvement using monte-carlo search",
      "author" : [ "G. Tesauro", "G.R. Galperin" ],
      "venue" : "In Advances in Neural Information Processing Systems",
      "citeRegEx" : "Tesauro and Galperin.,? \\Q1996\\E",
      "shortCiteRegEx" : "Tesauro and Galperin.",
      "year" : 1996
    }, {
      "title" : "A Monte-Carlo AIXI Approximation",
      "author" : [ "J. Veness", "K.S. Ng", "M. Hutter", "W.T.B. Uther", "D. Silver" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Veness et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Veness et al\\.",
      "year" : 2011
    }, {
      "title" : "Context tree switching",
      "author" : [ "J. Veness", "K.S. Ng", "M. Hutter", "M. Bowling" ],
      "venue" : "In Proceedings of the 2012 Data Compression Conference,",
      "citeRegEx" : "Veness et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Veness et al\\.",
      "year" : 2012
    }, {
      "title" : "Improving multistep prediction of learned time series models",
      "author" : [ "A. Venkatraman", "M. Hebert", "J.A. Bagnell" ],
      "venue" : "In Proceedings of the 29th AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "Venkatraman et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Venkatraman et al\\.",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "For instance, Sorg et al. (2010) and Joseph et al.",
      "startOffset" : 14,
      "endOffset" : 33
    }, {
      "referenceID" : 3,
      "context" : "(2010) and Joseph et al. (2013) both pointed out that the most accurate model by this measure is not necessarily the best for planning.",
      "startOffset" : 11,
      "endOffset" : 32
    }, {
      "referenceID" : 3,
      "context" : "(2010) and Joseph et al. (2013) both pointed out that the most accurate model by this measure is not necessarily the best for planning. Both proposed optimizing model parameters for control performance using policy gradient methods. Though appealing in its directness, this approach arguably discards some of the benefits of learning a model in the first place. Talvitie (2014) pointed out that one-step prediction accuracy does not account for how the model behaves when composed with itself and introduced the Hallucinated Replay meta-algorithm to address this.",
      "startOffset" : 11,
      "endOffset" : 378
    }, {
      "referenceID" : 3,
      "context" : "(2010) and Joseph et al. (2013) both pointed out that the most accurate model by this measure is not necessarily the best for planning. Both proposed optimizing model parameters for control performance using policy gradient methods. Though appealing in its directness, this approach arguably discards some of the benefits of learning a model in the first place. Talvitie (2014) pointed out that one-step prediction accuracy does not account for how the model behaves when composed with itself and introduced the Hallucinated Replay meta-algorithm to address this. As illustrated in Figure 1, this approach rolls out the model and environment in parallel, training the model to predict the correct environment state (s4) even when its input is an incorrect sampled state (z3). This effectively causes the model to “self-correct” its rollouts. Hallucinated Replay was shown to enable meaningful planning with flawed models in examples where the standard approach failed. However, it offers no theoretical guarantees. Venkatraman et al. (2015) and Oh et al.",
      "startOffset" : 11,
      "endOffset" : 1041
    }, {
      "referenceID" : 3,
      "context" : "(2010) and Joseph et al. (2013) both pointed out that the most accurate model by this measure is not necessarily the best for planning. Both proposed optimizing model parameters for control performance using policy gradient methods. Though appealing in its directness, this approach arguably discards some of the benefits of learning a model in the first place. Talvitie (2014) pointed out that one-step prediction accuracy does not account for how the model behaves when composed with itself and introduced the Hallucinated Replay meta-algorithm to address this. As illustrated in Figure 1, this approach rolls out the model and environment in parallel, training the model to predict the correct environment state (s4) even when its input is an incorrect sampled state (z3). This effectively causes the model to “self-correct” its rollouts. Hallucinated Replay was shown to enable meaningful planning with flawed models in examples where the standard approach failed. However, it offers no theoretical guarantees. Venkatraman et al. (2015) and Oh et al. (2015) used similar approaches to improve models’ long-range predictions, though not in the MBRL setting.",
      "startOffset" : 11,
      "endOffset" : 1062
    }, {
      "referenceID" : 4,
      "context" : "For largeN , Q̄will closely approximate Q̂ρT (Kakade 2003). The agent will select its actions greedily with respect to Q̄. Talvitie (2015) bounds the performance of one-ply MC in terms of model quality.",
      "startOffset" : 46,
      "endOffset" : 139
    }, {
      "referenceID" : 4,
      "context" : "For largeN , Q̄will closely approximate Q̂ρT (Kakade 2003). The agent will select its actions greedily with respect to Q̄. Talvitie (2015) bounds the performance of one-ply MC in terms of model quality. For a policy π and state-action distribution ξ, let ξ,π,T val = E(s,a)∼ξ [ |QT (s, a) − Q̂T (s, a)| ] be the error in the T -step state-action values the model assigns to the policy under the given distribution. Then the following result can be straightforwardly adapted from one provided by Talvitie (2015). Lemma 1.",
      "startOffset" : 46,
      "endOffset" : 511
    }, {
      "referenceID" : 4,
      "context" : "For largeN , Q̄will closely approximate Q̂ρT (Kakade 2003). The agent will select its actions greedily with respect to Q̄. Talvitie (2015) bounds the performance of one-ply MC in terms of model quality. For a policy π and state-action distribution ξ, let ξ,π,T val = E(s,a)∼ξ [ |QT (s, a) − Q̂T (s, a)| ] be the error in the T -step state-action values the model assigns to the policy under the given distribution. Then the following result can be straightforwardly adapted from one provided by Talvitie (2015). Lemma 1. Let Q̄ be the state-action value function returned by applying one-ply Monte Carlo to the model P̂ with rollout policy ρ and rollout depth T . Let π̂ be greedy w.r.t. Q̄. For any policy π and state-distribution μ, E s∼μ [ V (s)− V (s) ] ≤ 4 1− γ ξ,ρ,T val + mc, where we let ξ(s, a) = 1 2Dμ,π̂(s, a) + 1 4Dμ,π(s, a) + 1 4 ( (1− γ)μ(s)π̂s(a) + γ ∑ z,bDμ,π(z, b)P b z (s)π̂s(a) ) and mc = 4 1−γ ‖Q̄ − Q̂ ρ T ‖∞ + 2 1−γ ‖BV ρ T − V ρ T ‖∞ (here B is the Bellman operator). The mc term represents error due to limitations of the planning algorithm: error due to the sample average Q̄ and the sub-optimality of the T -step value function with respect to ρ. The ξ,ρ,T val term represents error due to the model parameters. The key factor in the model’s usefulness for planning is the accuracy of the value it assigns to the rollout policy in state-actions visited by π and π̂. Our goal in the next sections is to bound ξ,ρ,T val in terms of measures of model accuracy, ultimately deriving insight into how to train models that will be effective for MBRL. Proofs may be found in the appendix. 2.1 One-step prediction error Intuitively, the value of a policy should be accurate if the model is accurate in states that the policy would visit. We can adapt a bound from Ross and Bagnell (2012). Lemma 2.",
      "startOffset" : 46,
      "endOffset" : 1805
    }, {
      "referenceID" : 9,
      "context" : "Consider the “Shooter” domain introduced by Talvitie (2015), pictured in Figure 2a.",
      "startOffset" : 44,
      "endOffset" : 60
    }, {
      "referenceID" : 9,
      "context" : "” Talvitie (2014) presents several similar examples involving various model deficiencies.",
      "startOffset" : 2,
      "endOffset" : 18
    }, {
      "referenceID" : 14,
      "context" : "Venkatraman et al. (2015) provide some analysis but in the uncontrolled time series prediction setting.",
      "startOffset" : 0,
      "endOffset" : 26
    }, {
      "referenceID" : 2,
      "context" : "(2015) learned models of Atari 2600 games, which are fully deterministic (Hausknecht et al. 2014); human players often perceive them as stochastic due to their complexity.",
      "startOffset" : 73,
      "endOffset" : 97
    }, {
      "referenceID" : 4,
      "context" : "For instance, Oh et al. (2015) learned models of Atari 2600 games, which are fully deterministic (Hausknecht et al.",
      "startOffset" : 14,
      "endOffset" : 31
    }, {
      "referenceID" : 2,
      "context" : "(2015) learned models of Atari 2600 games, which are fully deterministic (Hausknecht et al. 2014); human players often perceive them as stochastic due to their complexity. Similarly, in synthetic RL domains stochasticity is often added to simulate complex, deterministic phenomena (e.g. robot wheels slipping on debris), not necessarily to capture inherently stochastic effects in the world. As in these examples, we shall assume that the environment is deterministic but complex, so a limited agent will learn an imperfect, stochastic model. That said, even specialized to deterministic environments, the bound in Lemma 4 is loose for arbitrary policies. Proposition 6. The hallucinated one-step error of a perfect model may be non-zero, even in a deterministic MDP. Proof. Alter the coin MDP, giving the agent two actions which fully determine the coin’s orientation. The original dynamics can be recovered via a stochastic policy that randomly selects sh or st and then leaves the coin alone. Oh et al. (2015) tied action selection to the environment state only (rather than independently selecting actions in the environment and model).",
      "startOffset" : 74,
      "endOffset" : 1013
    }, {
      "referenceID" : 6,
      "context" : "We now analyze H-DAgger-MC, adapting Ross and Bagnell (2012)’s DAgger analysis.",
      "startOffset" : 37,
      "endOffset" : 61
    }, {
      "referenceID" : 6,
      "context" : "Ross and Bagnell (2012) discuss extensions that address more practical loss functions, finite sample bounds, and results for π̂N .",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 6,
      "context" : "Ross and Bagnell (2012) discuss extensions that address more practical loss functions, finite sample bounds, and results for π̂N . The next question is, of course, when will the learned models be accurate? Following Ross and Bagnell (2012) note that ̄prd can be interpreted as the average loss of an online learner on the problem defined by the aggregated datasets at each iteration.",
      "startOffset" : 0,
      "endOffset" : 240
    }, {
      "referenceID" : 13,
      "context" : "The model for each pixel was learned using Context Tree Switching (Veness et al. 2012), similar to the FAC-CTW algorithm (Veness et al.",
      "startOffset" : 66,
      "endOffset" : 86
    }, {
      "referenceID" : 12,
      "context" : "2012), similar to the FAC-CTW algorithm (Veness et al. 2011), and used a 7× 7 neighborhood around the pixel in the previous timestep as input.",
      "startOffset" : 40,
      "endOffset" : 60
    }, {
      "referenceID" : 8,
      "context" : "The experimental setup matches that of Talvitie (2015) for comparison’s sake, though the qualitative comparison presented here is robust to the parameter settings.",
      "startOffset" : 39,
      "endOffset" : 55
    }, {
      "referenceID" : 8,
      "context" : "The experimental setup matches that of Talvitie (2015) for comparison’s sake, though the qualitative comparison presented here is robust to the parameter settings. In all cases one-ply MC was used with 50 uniformly random rollouts of depth 15 at every step. The exploration distribution was generated by following the optimal policy with (1−γ) probability of termination at each step. The model for each pixel was learned using Context Tree Switching (Veness et al. 2012), similar to the FAC-CTW algorithm (Veness et al. 2011), and used a 7× 7 neighborhood around the pixel in the previous timestep as input. Data was shared across all positions. The discount factor was γ = 0.9. In each iteration 500 training rollouts were generated and the resulting policy was evaluated in an episode of length 30. The discounted return obtained by the policy in each iteration is reported, averaged over 50 trials. The results can be seen in Figure 3a and 3b. The shaded regions represent 95% confidence intervals for the mean performance. The benchmark lines labeled “Random” and “Perfect Model” represent the average performance of the uniform random policy and one-ply Monte Carlo using a perfect model, respectively. In Figure 3a the bullseyes move, simulating the typical practical reality that C does not contain a perfect model. In Figure 3b the bullseyes have fixed positions, so C does contain a perfect model. As observed by Talvitie (2015), DAgger performs poorly in both versions, due to the suboptimal planner.",
      "startOffset" : 39,
      "endOffset" : 1439
    }, {
      "referenceID" : 8,
      "context" : "The experimental setup matches that of Talvitie (2015) for comparison’s sake, though the qualitative comparison presented here is robust to the parameter settings. In all cases one-ply MC was used with 50 uniformly random rollouts of depth 15 at every step. The exploration distribution was generated by following the optimal policy with (1−γ) probability of termination at each step. The model for each pixel was learned using Context Tree Switching (Veness et al. 2012), similar to the FAC-CTW algorithm (Veness et al. 2011), and used a 7× 7 neighborhood around the pixel in the previous timestep as input. Data was shared across all positions. The discount factor was γ = 0.9. In each iteration 500 training rollouts were generated and the resulting policy was evaluated in an episode of length 30. The discounted return obtained by the policy in each iteration is reported, averaged over 50 trials. The results can be seen in Figure 3a and 3b. The shaded regions represent 95% confidence intervals for the mean performance. The benchmark lines labeled “Random” and “Perfect Model” represent the average performance of the uniform random policy and one-ply Monte Carlo using a perfect model, respectively. In Figure 3a the bullseyes move, simulating the typical practical reality that C does not contain a perfect model. In Figure 3b the bullseyes have fixed positions, so C does contain a perfect model. As observed by Talvitie (2015), DAgger performs poorly in both versions, due to the suboptimal planner. DAgger-MC is able to perform well with fixed bullseyes (Figure 3b), but with moving bullseyes the model suffers from compounding errors and is not useful for planning (Figure 3a). This holds for a single model and for an “unrolled” model. In these experiments one practically-minded alteration was made to the H-DAgger-MC algorithm. In early training the model is highly inaccurate, and thus deep rollouts produce incoherent samples. Training with these samples is counter-productive (also, the large number of distinct, nonsensical contexts renders CTS impractical). For these experiments, training rollouts in iteration i were truncated at depth bi/10c. Planning rollouts in these early iterations use the models that have been trained so far and then repeatedly apply the deepest model in order to complete the rollout. Talvitie (2014), Venkatraman et al.",
      "startOffset" : 39,
      "endOffset" : 2351
    }, {
      "referenceID" : 8,
      "context" : "The experimental setup matches that of Talvitie (2015) for comparison’s sake, though the qualitative comparison presented here is robust to the parameter settings. In all cases one-ply MC was used with 50 uniformly random rollouts of depth 15 at every step. The exploration distribution was generated by following the optimal policy with (1−γ) probability of termination at each step. The model for each pixel was learned using Context Tree Switching (Veness et al. 2012), similar to the FAC-CTW algorithm (Veness et al. 2011), and used a 7× 7 neighborhood around the pixel in the previous timestep as input. Data was shared across all positions. The discount factor was γ = 0.9. In each iteration 500 training rollouts were generated and the resulting policy was evaluated in an episode of length 30. The discounted return obtained by the policy in each iteration is reported, averaged over 50 trials. The results can be seen in Figure 3a and 3b. The shaded regions represent 95% confidence intervals for the mean performance. The benchmark lines labeled “Random” and “Perfect Model” represent the average performance of the uniform random policy and one-ply Monte Carlo using a perfect model, respectively. In Figure 3a the bullseyes move, simulating the typical practical reality that C does not contain a perfect model. In Figure 3b the bullseyes have fixed positions, so C does contain a perfect model. As observed by Talvitie (2015), DAgger performs poorly in both versions, due to the suboptimal planner. DAgger-MC is able to perform well with fixed bullseyes (Figure 3b), but with moving bullseyes the model suffers from compounding errors and is not useful for planning (Figure 3a). This holds for a single model and for an “unrolled” model. In these experiments one practically-minded alteration was made to the H-DAgger-MC algorithm. In early training the model is highly inaccurate, and thus deep rollouts produce incoherent samples. Training with these samples is counter-productive (also, the large number of distinct, nonsensical contexts renders CTS impractical). For these experiments, training rollouts in iteration i were truncated at depth bi/10c. Planning rollouts in these early iterations use the models that have been trained so far and then repeatedly apply the deepest model in order to complete the rollout. Talvitie (2014), Venkatraman et al. (2015), and Oh et al.",
      "startOffset" : 39,
      "endOffset" : 2378
    }, {
      "referenceID" : 5,
      "context" : "(2015), and Oh et al. (2015) all similarly discarded noisy examples early in training.",
      "startOffset" : 12,
      "endOffset" : 29
    }, {
      "referenceID" : 5,
      "context" : "(2015), and Oh et al. (2015) all similarly discarded noisy examples early in training. This transient modification does not impact H-DAggerMC’s asymptotic guarantees. In Figure 3a it is clear that H-DAgger-MC obtains a good policy despite the limitations of the model class. Hallucinated training has made MBRL possible with both a flawed model and a flawed planner while the standard approach has failed entirely. In the case that C contains a perfect model (rare in problems of genuine interest) H-DAgger-MC is outperformed by DAgger-MC. Despite the adjustment to training, deep models still receive noisy inputs. Theoretically the model should become perfectly accurate in the limit, though in practice it may do so very slowly. Source code for these experiments may be found at github. com/etalvitie/hdaggermc. 4.1 Impact of the unrolled model Recall that the H-DAgger-MC algorithm assumes the model will be “unrolled,” with a separate model responsible for sampling each step in a rollout. This has clear practical disadvantages, but it is important theoretically. When one model is used across all time-steps, convergence to a perfect model cannot be guaranteed, even if one exists in C. In Figure 3c, H-DAgger-MC has been trained using a single model in Shooter with fixed bullseyes. The temporary truncation schedule described above is employed, but the training rollouts have been permanently limited to various depths. First consider the learning curve marked “Depth 15”, where training rollouts are permitted to reach the maximum depth. While the rollouts are temporarily truncated the model does well, but performance degrades as longer rollouts are permitted even though C contains a perfect model! Recall from Section 3 that changing the model parameters impacts both prediction error and the future training distribution. Furthermore, training examples generated by deep rollouts may contain highly flawed samples as inputs. Sometimes attempting to “correct” a large error (i.e. reduce prediction error) causes additional, even worse errors in the next iteration (i.e. harms the training distribution). For instance consider a hallucinated training example with the 4th screen from Figure 2b as input and the 5th screen from Figure 2a as the target. The model would effectively learn that targets can appear out of nowhere, an error that would be even harder to correct in future iterations. With a single model across timesteps, a feedback loop can emerge: the model parameters change to attempt to correct large errors, thereby causing larger errors, and so on. This feedback loop causes the observed performance crash. With an unrolled model the parameters of each sub-model cannot impact that sub-model’s own training distribution, ensuring stability. Note that none of Talvitie (2014), Venkatraman et al.",
      "startOffset" : 12,
      "endOffset" : 2805
    }, {
      "referenceID" : 5,
      "context" : "(2015), and Oh et al. (2015) all similarly discarded noisy examples early in training. This transient modification does not impact H-DAggerMC’s asymptotic guarantees. In Figure 3a it is clear that H-DAgger-MC obtains a good policy despite the limitations of the model class. Hallucinated training has made MBRL possible with both a flawed model and a flawed planner while the standard approach has failed entirely. In the case that C contains a perfect model (rare in problems of genuine interest) H-DAgger-MC is outperformed by DAgger-MC. Despite the adjustment to training, deep models still receive noisy inputs. Theoretically the model should become perfectly accurate in the limit, though in practice it may do so very slowly. Source code for these experiments may be found at github. com/etalvitie/hdaggermc. 4.1 Impact of the unrolled model Recall that the H-DAgger-MC algorithm assumes the model will be “unrolled,” with a separate model responsible for sampling each step in a rollout. This has clear practical disadvantages, but it is important theoretically. When one model is used across all time-steps, convergence to a perfect model cannot be guaranteed, even if one exists in C. In Figure 3c, H-DAgger-MC has been trained using a single model in Shooter with fixed bullseyes. The temporary truncation schedule described above is employed, but the training rollouts have been permanently limited to various depths. First consider the learning curve marked “Depth 15”, where training rollouts are permitted to reach the maximum depth. While the rollouts are temporarily truncated the model does well, but performance degrades as longer rollouts are permitted even though C contains a perfect model! Recall from Section 3 that changing the model parameters impacts both prediction error and the future training distribution. Furthermore, training examples generated by deep rollouts may contain highly flawed samples as inputs. Sometimes attempting to “correct” a large error (i.e. reduce prediction error) causes additional, even worse errors in the next iteration (i.e. harms the training distribution). For instance consider a hallucinated training example with the 4th screen from Figure 2b as input and the 5th screen from Figure 2a as the target. The model would effectively learn that targets can appear out of nowhere, an error that would be even harder to correct in future iterations. With a single model across timesteps, a feedback loop can emerge: the model parameters change to attempt to correct large errors, thereby causing larger errors, and so on. This feedback loop causes the observed performance crash. With an unrolled model the parameters of each sub-model cannot impact that sub-model’s own training distribution, ensuring stability. Note that none of Talvitie (2014), Venkatraman et al. (2015), or Oh et al.",
      "startOffset" : 12,
      "endOffset" : 2832
    }, {
      "referenceID" : 5,
      "context" : "(2015), and Oh et al. (2015) all similarly discarded noisy examples early in training. This transient modification does not impact H-DAggerMC’s asymptotic guarantees. In Figure 3a it is clear that H-DAgger-MC obtains a good policy despite the limitations of the model class. Hallucinated training has made MBRL possible with both a flawed model and a flawed planner while the standard approach has failed entirely. In the case that C contains a perfect model (rare in problems of genuine interest) H-DAgger-MC is outperformed by DAgger-MC. Despite the adjustment to training, deep models still receive noisy inputs. Theoretically the model should become perfectly accurate in the limit, though in practice it may do so very slowly. Source code for these experiments may be found at github. com/etalvitie/hdaggermc. 4.1 Impact of the unrolled model Recall that the H-DAgger-MC algorithm assumes the model will be “unrolled,” with a separate model responsible for sampling each step in a rollout. This has clear practical disadvantages, but it is important theoretically. When one model is used across all time-steps, convergence to a perfect model cannot be guaranteed, even if one exists in C. In Figure 3c, H-DAgger-MC has been trained using a single model in Shooter with fixed bullseyes. The temporary truncation schedule described above is employed, but the training rollouts have been permanently limited to various depths. First consider the learning curve marked “Depth 15”, where training rollouts are permitted to reach the maximum depth. While the rollouts are temporarily truncated the model does well, but performance degrades as longer rollouts are permitted even though C contains a perfect model! Recall from Section 3 that changing the model parameters impacts both prediction error and the future training distribution. Furthermore, training examples generated by deep rollouts may contain highly flawed samples as inputs. Sometimes attempting to “correct” a large error (i.e. reduce prediction error) causes additional, even worse errors in the next iteration (i.e. harms the training distribution). For instance consider a hallucinated training example with the 4th screen from Figure 2b as input and the 5th screen from Figure 2a as the target. The model would effectively learn that targets can appear out of nowhere, an error that would be even harder to correct in future iterations. With a single model across timesteps, a feedback loop can emerge: the model parameters change to attempt to correct large errors, thereby causing larger errors, and so on. This feedback loop causes the observed performance crash. With an unrolled model the parameters of each sub-model cannot impact that sub-model’s own training distribution, ensuring stability. Note that none of Talvitie (2014), Venkatraman et al. (2015), or Oh et al. (2015) used an unrolled model.",
      "startOffset" : 12,
      "endOffset" : 2853
    } ],
    "year" : 2017,
    "abstractText" : "When an agent cannot represent a perfectly accurate model of its environment’s dynamics, model-based reinforcement learning (MBRL) can fail catastrophically. Planning involves composing the predictions of the model; when flawed predictions are composed, even minor errors can compound and render the model useless for planning. Hallucinated Replay (Talvitie 2014) trains the model to “correct” itself when it produces errors, substantially improving MBRL with flawed models. This paper theoretically analyzes this approach, illuminates settings in which it is likely to be effective or ineffective, and presents a novel error bound, showing that a model’s ability to self-correct is more tightly related to MBRL performance than one-step prediction error. These results inspire an MBRL algorithm for deterministic MDPs with performance guarantees that are robust to model class limitations.",
    "creator" : "LaTeX with hyperref package"
  }
}