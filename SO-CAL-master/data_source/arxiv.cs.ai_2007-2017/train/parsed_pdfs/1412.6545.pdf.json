{
  "name" : "1412.6545.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "KF metamodel formalization",
    "authors" : [ "Pablo Rubén Fillottrani", "Maria Keet" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Interoperability of conceptual data modelling languages has become a necessity with ever complex software systems, be this through integration of ‘legacy’ systems or de novo development. In such cases, typically, one would use various conceptual models, such as ORM for usability with domain experts and interaction between requirements and data analysis, perhaps an EER model for the back-end database, and UML for any application layer software, which requires the system analyst to link entities across models represented in different conceptual modelling languages. To aid this endeavour, we have developed an ontology-driven unifying metamodel of UML v2.4.1, ER, EER, ORM and ORM2, whose static, structural entities have been presented in [Keet and Fillottrani, 2013], and an extended version also covering constraint in [Keet and Fillottrani, 2014]. More specifically, this concerned UML Class diagrams as specified in the UML Superstructure specification v2.4.1 [Object Management Group, 2012], typical ORM as described in [Committee Members, 2012, Halpin and Morgan, 2008], and both the original ash the encyclopaedic entries for ER and EER [Chen, 1976, Song and Chen, 2009, Thalheim, 2009].\nThis was modelled in UML Class Diagram notation with textual constraints for purpose of facilitating communication. Here we present the FOL formalisation of that metamodel to ensure precision of meaning and as a first step toward its computational use, including its necessity for designing efficient algorithms to computationally verify an inter-model assertion is correct (see also [Fillottrani and Keet, 2014]). Secondly, we have formalised it also in OWL 2 [Motik et al., 2009], for there are many tools that can process OWL files, hence opening up other avenues of the use of the metamodel, such as for categorising entities in extant models.\nThe remainder of this technical report presents first the FOL formalisation in Section 2 and subsequently discusses the modelling decisions for the OWL 2 DL version in Section 3. We close in Section 4.\nar X\niv :1\n41 2.\n65 45\nv1 [\ncs .A\nI] 1\n9 D\nec 2\n01 4"
    }, {
      "heading" : "2 FOL Formalization",
      "text" : "The FOL formalization is organised along the subfigures of the metamodel, where we first present a brief overview (Section 2.1), and subsequently the relationships and attributes and the constraints among those entities. From Section 2.4 onwards, the model constraints are presented, starting with simple mandatory up to ORM’s join constraints. Each subfigure of the metamodel is introduced first, which is followed by a brief description of the element in the figure and its formalisation. We use function-free FOL with equality, with a model-theoretic semantics; for a good overview of the language, see, e.g., [Hedman, 2004]. For notational convenience, we also use counting quantifiers ∃≤c, ∃≥c, and ∃=c for all c > 0 which do not add expressive power to FOL but facilitates the interpretation of formula. See [Baader et al., 2008] for their translation into traditional FOL."
    }, {
      "heading" : "2.1 Overview of the Static Entities",
      "text" : "Figures 1 and 2 present the static entities of the metamodel, noting that it has been extended cf. [Keet and Fillottrani, 2013] with, notably, UML’s qualifier, qualified association, and qualified identification. As before, we also use these two figures to communicate the overlap among the selected conceptual modelling languages, where a dark colour indicates all three families have that entity, classes filled with crossed lines are entities that appear in two of the three, a single line in only one, and an non-filled (white) class icon denotes an entity that appears in neither, but is used only in the metamodel to unify the other entities.\nFormalization of Static Entities The formalization is described based on each UML class diagram element in the corresponding figure, from top to bottom and left to right, and after that the textual constraints. For example, in figure 1 we have 10 isa relations and one textual constraint.\n• isa (disjoint and complete)\n∀(x)(Relationship(x) → Entity(x)) ∀(x)(Role(x) → Entity(x)) ∀(x)(EntityType(x) → Entity(x)) ∀(x)(Constraint(x) → Entity(x)) ∀(x)(¬(Relationship(x) ∧ Role(x))) ∀(x)(¬(Relationship(x) ∧ EntityType(x))) ∀(x)(¬(Relationship(x) ∧ Constraint(x))) ∀(x)(¬(Role(x) ∧ EntityType(x))) ∀(x)(¬(Role(x) ∧ Constraint(x))) ∀(x)(¬(EntityType(x) ∧ Constraint(x))) ∀(x)(Entity(x) → (Relationship(x) ∨ Role(x) ∨ EntityType(x) ∨ Constraint(x)))\n• isa ∀(x)(QualifiedRelationship(x) → Relationship(x))\n• isa (disjoint) ∀(x)(PartWhole(x) → Relationship(x)) ∀(x)(AttributiveProperty(x) → Relationship(x)) ∀(x)(Subsumption(x) → Relationship(x)) ∀(x)(¬(PartWhole(x) ∧ AttributiveProperty(x))) ∀(x)(¬(PartWhole(x) ∧ Subsumption(x))) ∀(x)(¬(AttributiveProperty(x) ∧ Subsumption(x)))\n• isa ∀(x)(SharedAggregate(x) → PartWhole(x))\n• isa ∀(x)(CompositeAggregate(x) → SharedAggregate(x))\n• isa (disjoint, complete) ∀(x)(Attribute(x) → AttributiveProperty(x)) ∀(x)(CompositeAttribute(x) → AttributiveProperty(x)) ∀(x)(DimensionalAttribute(x) → AttributiveProperty(x)) ∀(x)(¬(Attribute(x) ∧ CompositeAttribute(x))) ∀(x)(¬(Attribute(x) ∧ DimensionalAttribute(x))) ∀(x)(¬(CompositeAttribute(x) ∧ DimensionalAttribute(x))) ∀(x)(AttributiveProperty(x) → (Attribute(x) ∨ CompositeAttribute(x)∨\nDimensionalAttribute(x)))\n• isa (disjoint) ∀(x)(MultivaluedAttribute(x) → Attribute(x)) ∀(x)(MappedTo(x) → Attribute(x)) ∀(x)(¬(MultivaluedAttribute(x) ∧ MappedTo(x)))\n• isa (disjoint, complete)\n∀(x)(ValueProperty(x) → EntityType(x)) ∀(x)(DataType(x) → EntityType(x)) ∀(x)(ObjectType(x) → EntityType(x)) ∀(x)(Qualifier(x) → EntityType(x)) ∀(x)(¬(ValueProperty(x) ∧ DataType(x))) ∀(x)(¬(ValueProperty(x) ∧ ObjectType(x))) ∀(x)(¬(ValueProperty(x) ∧ Qualifier(x))) ∀(x)(¬(DataType(x) ∧ ObjectType(x))) ∀(x)(¬(DataType(x) ∧ Qualifier(x))) ∀(x)(¬(ObjectType(x) ∧ Qualifier(x))) ∀(x)(EntityType(x) → (ValueProperty(x)∨DataType(x)∨ObjectType(x)∨Qualifier(x)))\n• isa (disjoint,complete) ∀(x)(ValueType(x) → ValueProperty(x)) ∀(x)(DimensionalValueType(x) → ValueProperty(x)) ∀(x)(¬(ValueType(x) ∧ DimensionalValueType(x))) ∀(x)(ValueProperty(x) → (ValueType(x) ∨ DimensionalValueType(x)))\n• isa ∀(x)(WeakObjectType(x) → ObjectType(x)) ∀(x)(NestedObjectType(x) → ObjectType(x)) ∀(x)(AssociativeObjectType(x) → ObjectType(x))\n• disjointness (first textual constraint) ∀(x)(¬(QualifiedRelationship(x) ∧ AttributiveProperty(x))) ∀(x)(¬(QualifiedRelationship(x) ∧ Subsumption(x))) ∀(x)(¬(AttributiveProperty(x) ∧ Subsumption(x)))"
    }, {
      "heading" : "2.2 Overview of the Constraints",
      "text" : "There are several types of constraints in modelling languages, and this is reflected in the number of nodes in the graph in figure 2. The main is relation in the figue does not show all the siblings at the same level due to space limitations. In this section we only show the different types of constraints. In later sections, each constraint type is analyzed in detail together with related static entities.\nFormalization of Constraint types\n• isa ∀(x)(CardinalityConstraint(x) → Constraint(x)) ∀(x)(SubsetConstraint(x) → Constraint(x)) ∀(x)(JoinConstraint(x) → Constraint(x)) ∀(x)(UniquenessConstraint(x) → Constraint(x)) ∀(x)(RelationshipConstraint(x) → Constraint(x)) ∀(x)(DisjointnessConstraint(x) → Constraint(x)) ∀(x)(EqualityConstraint(x) → Constraint(x)) ∀(x)(ValueConstraint(x) → Constraint(x)) ∀(x)(CompletenessConstraint(x) → Constraint(x)) ∀(x)(ValueComparisonConstraint(x) → Constraint(x)) ∀(x)(IdentificationConstraint(x) → Constraint(x)) ∀(x)(MandatoryConstraint(x) → Constraint(x))\n• isa (disjoint, complete) ∀(x)(CompoundCardinalityConstraint(x) → CardinalityConstraint(x)) ∀(x)(AttributivePropertyCardinality(x) → CardinalityConstraint(x)) ∀(x)(ObjectTypeCardinality(x) → CardinalityConstraint(x)) ∀(x)(¬(CompoundCardinalityConstraint(x) ∧ AttributivePropertyCardinality(x))) ∀(x)(¬(CompoundCardinalityConstraint(x) ∧ ObjectTypeCardinality(x))) ∀(x)(¬(AttributivePropertyCardinality(x) ∧ ObjectTypeCardinality(x))) ∀(x)(CardinalityConstraint(x) → (CompoundCardinalityConstraint(x)∨\nAttributivePropertyCardinality(x) ∨ ObjectTypeCardinality(x)))\n• isa (disjoint) ∀(x)(JoinSubsetConstraint(x) → JoinConstraint(x)) ∀(x)(JoinEqualityConstraint(x) → JoinConstraint(x)) ∀(x)(JoinDisjointnessConstraint(x) → JoinConstraint(x)) ∀(x)(¬(JoinSubsetConstraint(x) ∧ JoinEqualityConstraint(x))) ∀(x)(¬(JoinSubsetConstraint(x) ∧ JoinDisjointnessConstraint(x))) ∀(x)(¬(JoinEqualityConstraint(x) ∧ JoinDisjointnessConstraint(x)))\n• isa (disjoint, complete)\n∀(x)(InternalUniquenessConstraint(x) → UniquenessConstraint(x)) ∀(x)(ExternalUniquenessConstraint(x) → UniquenessConstraint(x)) ∀(x)(¬(InternalUniquenessConstraint(x) ∧ ExternalUniquenessConstraint(x))) ∀(x)(UniquenessConstraint(x) → (InternalUniquenessConstraint(x)∨\nExternalUniquenessConstraint(x)))\n• isa (complete) ∀(x)(Transitivity(x) → RelationshipConstraint(x)) ∀(x)(Antisymmetry(x) → RelationshipConstraint(x)) ∀(x)(Irreflexivity(x) → RelationshipConstraint(x)) ∀(x)(LocalReflexivity(x) → RelationshipConstraint(x)) ∀(x)(Symmetry(x) → RelationshipConstraint(x)) ∀(x)(RelationshipConstraint(x) → (Transitivity(x) ∨ Antisymmetry(x)∨\nIrreflexivity(x) ∨ LocalReflexivity ∨ Symmetry(x)))\n• isa ∀(x)(Asymmetry(x) → Antisymmetry(x))\n• isa ∀(x)(Asymmetry(x) → Irreflexivity(x))\n• isa ∀(x)(Acyclicity(x) → Asymmetry(x))\n• isa ∀(x)(Intransitivity(x) → Irreflexivity(x))\n• isa ∀(x)(StronglyIntransitivity(x) → Intransitivity(x))\n• isa ∀(x)(GlobalReflexivity(x) → LocalReflexivity(x))\n• isa ∀(x)(PurelyReflexivity(x) → LocalReflexivity(x))\n• isa (disjoint, complete) ∀(x)(DisjointRoles(x) → DisjointnessConstraint(x)) ∀(x)(DisjointRelationships(x) → DisjointnessConstraint(x)) ∀(x)(DisjointObjectTypes(x) → DisjointnessConstraint(x)) ∀(x)(¬(DisjointRoles(x) ∧ DisjointObjectTypes(x))) ∀(x)(¬(DisjointRoles(x) ∧ DisjointRelationships(x))) ∀(x)(¬(DisjointRelationships(x) ∧ DisjointObjectTypes(x))) ∀(x)(DisjointnessConstraint(x) → (DisjointRoles(x)∨\nDisjointObjectTypes(x) ∨ DisjointRelationships(x)))\n• isa ∀(x)(JoinDisjointnessConstraint(x) → DisjointRoles(x))\n• isa (disjoint, complete) ∀(x)(RoleEquality(x) → EqualityConstraint(x)) ∀(x)(RelationshipEquality(x) → EqualityConstraint(x)) ∀(x)(¬(RoleEquality(x) ∧ RelationshipEquality(x))) ∀(x)(EqualityConstraint(x) → (RoleEquality(x) ∨ RelationshipEquality(x)))\n• isa ∀(x)(JoinEqualityConstraint(x) → RoleEquality(x))\n• isa (disjoint, complete) ∀(x)(ValueTypeConstraint(x) → ValueConstraint(x)) ∀(x)(RoleValueConstraint(x) → ValueConstraint(x)) ∀(x)(AttributeValueConstraint(x) → ValueConstraint(x)) ∀(x)(¬(ValueTypeConstraint(x) ∧ RoleValueConstraint(x))) ∀(x)(¬(ValueTypeConstraint(x) ∧ AttributeValueConstraint(x))) ∀(x)(¬(RoleValueConstraint(x) ∧ AttributeValueConstraint(x))) ∀(x)(ValueConstraint(x) → (ValueTypeConstraint(x)∨\nRoleValueConstraint(x) ∨ AttributeValueConstraint(x)))\n• isa (disjoint, complete) ∀(x)(ExternalIdentification(x) → IdentificationConstraint(x)) ∀(x)(InternalIdentification(x) → IdentificationConstraint(x)) ∀(x)(¬(ExternalIdentification(x) ∧ InternalIdentification(x))) ∀(x)(IdentificationConstraint(x) → (ExternalIdentification(x)∨\nInternalIdentification(x)))\n• isa (disjoint) ∀(x)(QualifiedIdentification(x) → ExternalIdentification(x)) ∀(x)(WeakIdentification(x) → ExternalIdentification(x)) ∀(x)(¬(QualifiedIdentification(x) ∧ WeakIdentification(x)))\n• isa ∀(x)(SingleIdentification(x) → InternalIdentification(x))\n• isa (disjoint) ∀(x)(Mandatory(x) → MandatoryConstraint(x)) ∀(x)(DisjunctiveMandatory(x) → MandatoryConstraint(x)) ∀(x)(¬(MandatoryConstraint(x) ∧ DisjunctiveMandatory(x)))\n• isa ∀(x)(InclusiveMandatory(x) → DisjunctiveMandatory(x))"
    }, {
      "heading" : "2.3 Relationships between Relationship, Role and Entity type",
      "text" : "This section goes into detail on relationships and roles in general, and subsequently subsumption and aggregation, and attributes and value types. The main entities and constraints pertaining to relationships are depicted in Figure 3.\nFormalization of Relationship, Role, EntityType and related constraints\n• composition (1, 2..∗) ∀(x, y)(Contains(x, y) → Relationship(x) ∧ Role(y)) ∀(x)∃≥2y(Contains(x, y)) ∀(x)(Role(x) → ∃=1(y)(Contains(y, x)))\nWe do not need to add asymmetric and irreflexive axioms to the formalization because they are both implicit after the disjointness between Relationship and Role. Also, transitivity is not included since we are dealing with a “direct parthood” relationship.\nRoleRelationship Entity typerole playing 0..* playslinked to 1..*\n0..*of\n2..*1 contains\nObject type\nNested object type\n1\n0..1 reified as\nobjectifies\nCardinality constraint MinimumCardinality:Integer MaximumCardinality:Integer"
    }, {
      "heading" : "2.3.1 Subsumption and Aggregation",
      "text" : "The metamodel fragment dealing with subsumption and aggregation is depicted in Figure 4 and has the following logic-based reconstruction."
    }, {
      "heading" : "Formalization of Subsumption and Aggregation",
      "text" : "• relation (0..∗, 2), subset and union constraints\n∀(x, y)(Participant(x, y) → ((Relationship(x) ∧ Entity(y))∨ (ValueComparisonConstraint(x) ∧ Role(y))∨ (RelationshipConstraint(x) ∧ Role(y)))) ∀(x)(Relationship(x) → ∃=2(y)(Participant(x, y))) ∀(x, y)((Participant(x, y) ∧ Relationship(x)) ↔ (Sub(x, y)∨\nSuper(x, y) ∨ Part(x, y) ∨ Whole(x, y)))\n• relation (1, 0..∗), third textual constraint ∀(x, y)(Sub(x, y) → (Subsumption(x) ∧ Entity(y)∧\n¬QualifiedRelationship(y) ∧ ¬AttributiveProperty(y)∧ ¬Subsumption(y) ∧ ¬Qualifier(y) ∧ ¬Constraint(y)))\n∀(x)(Subsumption(x) → ∃=1(y)(Sub(x, y)))\n• relation (1, 0..∗), third textual constraint ∀(x, y)(Super(x, y) → (Subsumption(x) ∧ Entity(y)∧\n¬QualifiedRelationship(y) ∧ ¬AttributiveProperty(y)∧ ¬Subsumption(y) ∧ ¬Qualifier(y) ∧ ¬Constraint(y)))\n∀(x)(Subsumption(x) → ∃=1(y)(Super(x, y)))\n• disjunctive exclusion (not in figure) ∀(x, y)((Subsumption(x) ∧ Sub(x, y) ∧ Φ(y)) → ∃(z)(Φ(z) ∧ Super(x, z)))∗\n∀(x, y)((Subsumption(x) ∧ Super(x, y) ∧ Φ(y)) → ∃(z)(Φ(z) ∧ Sub(x, z)))∗\nFor all Φ ∈ {SharedAggregate, CompositeAggregate, Role, DataType, Relationship ∧ ¬PartWhole, ObjectType}.\n• isa ∀(x, y)(Part(x) → PartWhole(x))\n• relation (0..∗, 1)\n∀(x, y)(Part(x, y) → ((Part(x) ∧ AttributiveProperty(y))∨ (SharedAggregate(x) ∧ DataType(y))∨ (SharedAggregate(x) ∧ ObjectType(y)))) ∀(x)(Part(x) → ∃=1(y)(Part(x, y) ∧ AttributiveProperty(y)))\n• relation (2..∗, 1) ∀(x, y)(Whole(x, y) → ((Part(x) ∧ CompositeAttribute(y))∨\n(SharedAggregate(x) ∧ DataType(y))∨ (SharedAggregate(x) ∧ ObjectType(y))))\n∀(x)(Part(x) → ∃=1(y)(Whole(x, y) ∧ CompositeAttribute(y))) ∀(x)(CompositeAttribute(x) → ∃≥2(y)(Part(y) ∧ Whole(y, x)))\n• relation (0..∗, 0..1), xor, second textual constraint ∀(x)(SharedAggregate(x) → ∃≤1(y)((DataType(y) ∨ ObjectType(y)) ∧ Part(x, y))) ∀(x)(SharedAggregate(x) → (∃≥1(y)(Part(x, y)) ∧ ∃≥1(y)(Whole(x, y))))\n• relation (0..∗, 0..1), xor ∀(x)(SharedAggregate(x) → ∃≤1(y)((DataType(y) ∨ ObjectType(y)) ∧ Whole(x, y)))\nThe last two set of formula only show the disjunction of the xor. The exclusion between DataType and ObjectType is inherited from the disjoint isa in figure 1.\n• and relationships ∀(x, y)((SharedAggregate(x) ∧ DataType(y) ∧ Part(x, y)) →\n∃(z)(DataType(z) ∧ Whole(x, z)))∗\n∀(x, y)((SharedAggregate(x) ∧ DataType(y) ∧ Whole(x, y)) → ∃(z)(DataType(z) ∧ Part(x, z)))∗ ∀(x, y)((SharedAggregate(x) ∧ ObjectType(y) ∧ Part(x, y)) → ∃(z)(ObjectType(z) ∧ Whole(x, z)))∗ ∀(x, y)((SharedAggregate(x) ∧ ObjectType(y) ∧ Whole(x, y)) → ∃(z)(ObjectType(z) ∧ Part(x, z)))∗\n• irreflexivity, asymmetry (not in figure) ∀(x, y, z)((PartWhole(x) ∧ Part(x, y) ∧ Whole(x, z)) → ¬(y = z))∗\n∀(x, y, z)((PartWhole(x) ∧ Part(x, y) ∧ Whole(x, z)) → ¬∃(v)(PartWhole(v) ∧ Part(v, z) ∧ Whole(v, y)))∗\n• relation (0..1, 1) ∀(x, y)((Part(x, y) ∧ CompositeAggregate(x)) → ObjectType(y)) ∀(x)(CompositeAggregate(x) → ∃=1(y)(Part(x, y))) ∀(x)(CompositeAggregate(x) → ∃≤1(y)(Part(y, x)))\n• relation (0..∗, 1) ∀(x, y)((CompositeAggregate(x) ∧ Whole(x, y)) → ObjectType(y)) ∀(x)(CompositeAggregate(x) → ∃=1(y)(Whole(x, y)))\n• first textual constraint\n∀(x, y)(Compatible(x, y) → ((ValueProperty(x) ∧ ValueProperty(y))∨ (DataType(x) ∧ DataType(y))∨ (ObjectType(x) ∧ ObjectType(y))∨ (Role(x) ∧ Role(y))∨ (Relationship(x) ∧ Relationship(y)))) ∀(x, y)((Compatible(x, y) ∧ Role(x)) → ∃(v, w, s, t)(RolePlaying(x, v, w)∧ RolePlaying(y, s, t) ∧ Compatible(w, t)))∗ ∀(x, y)((Compatible(x, y) ∧ Relationship(x)) → ((∃=n(z)(Contains(x, z)) ↔ ∃=n(z)(Contains(y, z)))∧ (∃(z, v)(Contains(x, z) ∧ Contains(y, w) ∧ Compatible(z, w)))))∗ ∀(x, y, z)((Subsumption(x) ∧ Sub(x, y) ∧ Super(x, z)) → Compatible(y, z))∗\nHere n is any natural number from 2 up to the maximum arity of a relationship in the model. Therefore the formula is not second order."
    }, {
      "heading" : "2.3.2 Attributes and Value Types",
      "text" : "The metamodel fragment concerning attributes and ORM’s counterpart, value types, is shown Figure 5 and has the following logic-based reconstruction."
    }, {
      "heading" : "Formalization of Attributes and Value Types",
      "text" : "• relation (0..1, 1), relation (1..2, 1), xor\n∀(x, y)(DeclaredOn(x, y) → ((Qualifier(x) ∧ Role(y))∨ (Qualifier(x) ∧ QualifiedRelationship(y))∨ (MandatoryConstraint(x) ∧ Role(y))∨ (InternalUniquenessConstraint(x) ∧ Role(y))∨ (ExternalIdentification(x) ∧ Relationship(y))∨ (IdentificationConstraint(x) ∧ ValueProperty(y))∨ (IdentificationConstraint(x) ∧ AttributiveProperty(y))∨ (RelationshipEquality(x) ∧ Relationship(y))∨ (DisjointRelationships(x) ∧ Relationship(y))∨ (RoleEquality(x) ∧ Role(y))∨ (DisjointRoles(x) ∧ Role(y))∨ (DisjointEntities(x) ∧ Subsumption(y))∨ (ObjectTypeEquality(x) ∧ ObjectType(y))∨ (CompletenessConstraint(x) ∧ Subsumption(y)))) ∀(x)(Qualifier(x) → ∃=1(y)(DeclaredOn(x, y) ∧ (Role(y) ∨ QualifiedRelationship(y)))) ∀(x)(Role(x) → ∃≤1(y)(Qualifier(y) ∧ DeclaredOn(y, x))) ∀(x)(QualifiedRelationship(x) → (∃≥1(y)(Qualifier(y) ∧ DeclaredOn(y, x))∧ ∃≤2(y)(Qualifier(y) ∧ DeclaredOn(y, x)))) ∀(x, y, z)((DeclaredOn(x, y) ∧ DeclaredOn(x, z) ∧ Qualifier(x) ∧ Role(y)) → Role(z)))∗ ∀(x, y, z)((DeclaredOn(x, y) ∧ DeclaredOn(x, z) ∧ Qualifier(x)∧ QualifiedRelationship(y)) → QualifiedRelationship(z)))∗\n• composition (0..∗, 1..∗), or ∀(x, y)(HasComponent(x, y) → (Qualifier(x)∧(DimensionalAttribute(y)∨Attribute(y)))) ∀(x)(Qualifier(x) → ∃≥1(y)(HasComponent(x, y)))\n• relation (0..∗, 0..∗) ∀(x, y)(Domain(x, y) → ((AttributiveProperty(x) ∧ Relationship(y))∨\n(AttributiveProperty(x) ∧ ObjectType(y)) ∨ (MappedTo(x) ∧ ValueType(y))∨ (ValueProperty(x) ∧ ObjectType(y))))\n• relation (0..∗, 1) ∀(x, y)(Range(x, y) → ((AttributiveProperty(x) ∧ DataType(y))∨\n(MappedTo(x) ∧ DataType(y)))) ∀(x)(AttributiveProperty(x) → ∃=1(y)(DataType(y) ∧ Range(x, y)))\n• relation (0..∗, 1..∗) ∀(x)(ValueProperty(x) → ∃≥1(y)(Domain(x, y) ∧ ObjectType(y)))\n• relation (0..∗, 1) ∀(x)(MappedTo(x) → ∃=1(y)(DataType(y) ∧ Range(x, y)))\n• ternary relation (0..∗, 0..∗, 0..∗), or ∀(x, y, z)(DimensionalAttribution(x, y, z) → (Dimension(x) ∧ DataType(y)∧\n(ObjectType(z) ∨ Relationship(z))))\nAlthough this formula has three variables, it can be replaced by an equivalent set of several formula in two variables, thus it is not starred. This translation is similar to the process of reification described in Section 3, and it is applied to all ternary relations.\n• ternary relation (0..∗, 0..∗, 1) ∀(x, y, z)(DimensionalValueTyping(x, y, z) → (Dimension(x)∧\nDataType(y) ∧ DimensionalValueType(z))) ∀(x)(DimensionalValueType(x) → ∃=1(y, z)(DimensionalValueTyping(y, z, x)))"
    }, {
      "heading" : "2.4 Mandatory Constraints",
      "text" : "Form this section onwards, we turn our focus to constraints that can be represented on the selected conceptual modelling languages. The first one is about the different mandatory constraints, as shown in Figure 6."
    }, {
      "heading" : "Formalization of Mandatory Constraints",
      "text" : "• relation (0..∗, 1..∗) ∀(x)(MandatoryConstraint(x) → ∃≥1(y)(Role(y) ∧ DeclaredOn(x, y)))\n• relation (0..∗, 2..∗) ∀(x)(DisjunctiveMandatory(x) → ∃≥2(y)(Role(y) ∧ DeclaredOn(x, y)))\n• relation (0..1, 1) ∀(x)(Mandatory(x) → ∃=1(y)(Role(y) ∧ DeclaredOn(x, y))) ∀(x)(Role(x) → ∃≤1(y)(DeclaredOn(y, x) ∧ Mandatory(y)))\n• constraint on relationships containing roles with the same mandatory constraint, not in diagram\n∀(x, y, z, v, w)((DeclaredOn(x, y) ∧ DeclaredOn(x, z) ∧ MandatoryConstraint(x)∧ Role(y) ∧ Role(z) ∧ Contains(w, y) ∧ Contains(v, z)∧ Relationship(v) ∧ Relationship(w)) → ¬(w = v))∗"
    }, {
      "heading" : "2.5 Uniqueness Constraints",
      "text" : "The second core constraints in the languages is uniqueness, as shown in Figure 7, which is formalised as follows."
    }, {
      "heading" : "Formalization of Uniqueness Constraints",
      "text" : "• relation (0..∗, 1..∗) ∀(x)(InternalUniquenessConstraint(x) → ∃≥1(y)(Role(y) ∧ DeclaredOn(x, y)))\n• ternary relation (1, 0; 2..∗, 0; 2..∗), third textual constraint ∀(x, y, z)(ExtUnique(x, y, z) → (ExternalUniquenessConstraint(x)∧\nRole(y) ∧ Relationship(z) ∧ Contains(z, y)))∗\n∀(x)(ExternalUniquenessConstraint(x) → ∃=1(y, z)(ExtUnique(x, y, z))) ∀(x)(Role(x) → (∃=0(y, z)(ExternalUnique(y, x, z))∨ ∃≥2(y, z)(ExternalUnique(y, x, z)))) ∀(x)(Relationship(x) → (∃=0(y, z)(ExternalUnique(y, z, x))∨\n∃≥2(y, z)(ExternalUnique(y, z, x))))\n• first textual constraint ∀(x, y, z)((InternalUniquenessConstraint(x) ∧ Role(y) ∧ DeclaredOn(x, y)∧\nRelationship(z) ∧ Contains(z, y)) → (∃=n(w)(Contains(z, w)) ↔ ∃≤n(v)(DeclaredOn(x, v))))∗\nThis is necessary first order since n is any natural number up to the maximum arity of any relationships in the model.\n• second textual constraint ∀(x)(ExternalUniquenessConstraint(x) → (∃=n(y)∃(z)(ExternalUnique(x, y, z)\n↔ ∃=n(z)∃(y)ExternalUnique(x, y, z))))∗\nThis is necessary first order since n is any natural number up to the maximum arity of a relationships in the model."
    }, {
      "heading" : "2.6 Identification Constraints",
      "text" : "The metamodel fragment concerning identifiers (Figure 8), while comprehensive in its treatment, does not deal with definitions of identity (see [Keet, 2011] for a brief discussion on this topic). How identification is dealt with in the languages is formalised as follows."
    }, {
      "heading" : "Formalization of Identification Constraints",
      "text" : "• relation (0..∗, 1) ∀(x, y)(PartiallyIdentifies(x, y) →\n(QualifiedIdentification(x) ∧ QualifiedRelationship(y))) ∀(x)(QualifiedIdentification(x) → ∃=1(y)(PartiallyIdentifies(x, y)))\n• relation (0..∗, 1..∗) ∀(x)(ExternalIdentification(x) → ∃≥1(y)(DeclaredOn(x, y))\n• relation (1..∗, 1) ∀(x, y)(Identifies(x, y) → (IdentificationConstraint(x) ∧ ObjectType(y))) ∀(x)(IdentificationConstraint(x) → ∃=1(y)(Identifies(x, y))) ∀(x)(ObjectType(x) → ∃≥1(y)(Identifies(y, x)))\n• relation (0..∗, 0..∗), xor, mandatory (not in diagram)\n∀(x, y, z)((DeclaredOn(x, y) ∧ DeclaredOn(x, z)∧ IdentificationConstraint(x) ∧ ValueProperty(y)) → ValueProperty(z))∗ ∀(x, y, z)((DeclaredOn(x, y) ∧ DeclaredOn(x, z)∧ IdentificationConstraint(x) ∧ AttributiveProperty(y)) → AttributiveProperty(z))∗ ∀(x)(IdentificationConstraint(x) → ∃(y)(DeclaredOn(x, y)))\n• relation (0..1, 1) ∀(x, y)((DeclaredOn(x, y) ∧ SingleIdentification(x)) → (Attribute(y) ∨ ValueType(y))) ∀(x)(SingleIdentification(x) → ∃=1(y)(DeclaredOn(x, y)) ∀(x)((Attribute(x) ∨ ValueType(x)) → ∃≤1(y)(DeclaredOn(y, x)∧\nSingleIdentification(y)))\nXor is inherited from previous set of formula.\n• relation (1..∗, 1) ∀(x, y)((Identifies(x, y) ∧ WeakIdentification(x)) → WeakObjectType(y)) ∀(x)(WeakIdentification(x) → ∃=1(y)(Identifies(x, y))) ∀(x)(WeakObjectType(x) → ∃≥1(y)(WeakIdentification(y)∧\nIdentifies(y, x)))\n• relation (0..∗, 1) ∀(x, y)(HasStrong(x, y) → (WeakObjectType(x) ∧ ObjectType(y))) ∀(x)(WeakObjectType(x) → ∃=1(y)(HasStrong(x, y)))\n• first textual constraint\n∀(x, y, z)((WeakIdentification(x) ∧ Identifies(x, y) ∧ DeclaredOn(x, z)) → ((AttributiveProperty(z) ∧ Domain(z, y))∨ ∃=1(v, w, s)(IdentificationConstraint(v) ∧ Identifies(v, w)∧ Relationship(s)∧DeclaredOn(v, z)∧Participant(s, w)∧Participant(s, y))))∗ ∀(x, y, z, v, w, s, t)((WeakIdentification(x) ∧ Identifies(x, y) ∧ DeclaredOn(x, s)∧ IdentificationConstraint(v, w) ∧ Identifies(v, t)∧ DeclaredOn(v, s)) → ¬(y = t))∗\n• second textual constraint ∀(x, y, z)((SingleIdentification(x) ∧ Identifies(x, y) ∧ DeclaredOn(x, z)) →\n∃(v)(CardO(z, y, v) ∧ MinimumCardinality(v, 1) ∧ MaximumCardinality(v, 1)))∗\n• third textual constraint ∀(x, y)((QualifiedIdentification(x) ∧ DeclaredOn(x, y)) → AttributiveProperty(y)) ∀(x, y)((ExternalIdentification(x) ∧ DeclaredOn(x, y)) → AttributiveProperty(y))\n• fourth textual constraint ∀(x, y)(PartiallyIdentifies(x, y) → ∃(z, v, w)(RolePlaying(z, v, w)∧\nContains(y, z) ∧ MinimumCardinality(v, 1) ∧ MaximumCardinality(v, 1)))∗"
    }, {
      "heading" : "2.7 Cardinality Constraints",
      "text" : "The fourth important constraint of the languages are the cardinality constraints; see Figure 9, which is formalised below."
    }, {
      "heading" : "Formalization of Cardinality Constraints",
      "text" : "• ternary relationship (0..∗, 0..∗, 0..∗) ∀(x, y, z)(CardR(x, y, z) → (AttributiveProperty(x) ∧ Relationship(y)∧\nCardinalityConstraint(z)))\n• ternay relation (0..∗, 0..∗, 0..∗) ∀(x, y, z)(CardO(x, y, z) → (AttributiveProperty(x) ∧ ObjectType(y)∧\nCardinalityConstraint(z)))\n• ternary relation (0..∗, 0; 2..∗, 1) ∀(x, y, z)(Frequency(x, y, z) → (Relationship(x) ∧ Role(y)∧\nCompoundCardinalityConstraint(z)))\n∀(x)(CompoundCardinalityConstraint(x) → ∃=1(y, z)(Frequency(y, z, x)) ∀(x)(Role(x) → (∃=0(y, z)(Frequency(y, x, z))∨\n∃≥2(y, z)(Frequency(y, x, z))))\n• first and second textual constraint ∀(x)(CardinalityConstraint(x) → ∃(y)(MaximumCardinality(x, y)∨\nMinimumCardinality(x, y)))\nThe other part of these constraints are implicit from the formalization of attributes. The second constraint is implicit from the inheritance.\n• isa, third textual constraint ∀(x)(CompoundCardinalityConstraint(x) → CardinalityConstraint(x)) ∀(x, y, z, v, w)((Frequency(x, y, z) ∧ Frequency(v, w, z)) →\n((x = v) ∧ Contains(x, y) ∧ Contains(v, w) ∧ ¬(y = w)))∗"
    }, {
      "heading" : "2.8 Value type, Role and Attribute Value constraints",
      "text" : "The formalisation of value types and role and attribute constraints is rather elegant compared to the difficulty of drawing that metamodel fragment (Figure 10), for there are repeating components to it that can be more easily captured in FOL."
    }, {
      "heading" : "Formalization of Value type, Role and Attribute Value Constraints",
      "text" : "• ternary relations (1, 0..∗, 0..∗), xor\n∀(x,w, z)(ConstrainingValues(x, y, z) → (((ValueTypeConstraint(x)∧ ValueProperty(y)) ∨ (RoleValueConstraint(x) ∧ Role(y))∨ (AttributeValueConstraint(x) ∧ Attribute(y)))∧ (ValueEnumeration(z) ∨ ValueRange(z)))) ∀(x)(ValueTypeConstraint(x) → ∃=1(y, z)(ConstrainingValues(x, y, z))) ∀(x)(RoleValueConstraint(x) → ∃=1(y, z)(ConstrainingValues(x, y, z))) ∀(x)(AttributeValueConstraint(x) → ∃=1(y, z)(ConstrainingValues(x, y, z))) ∀(x)(ValueEnumeration(x) → ¬ValueRange(x)) ∀(x)(ValueRange(x) → ¬ValueEnumeration(x))\n• relation (0..∗, 1) ∀(x, y)(HasType(x, y) → (ValueRange(x) ∧ DataType(y))) ∀(x)(ValueRange(x) → ∃=1(y)(HasType(x, y)))\n• attributes ∀(x, y)((ValueRange(x) ∧ MinimumValue(x, y)) → Literal(y)) ∀(x, y)((ValueRange(x) ∧ MaximumValue(x, y)) → Literal(y)) ∀(x)(ValueRange(x) → ∃=1(y)(MinimumValue(x, y))) ∀(x)(ValueRange(x) → ∃=1(y)(MaximumValue(x, y)))\nIn this figure we assign cardinalities [1..1] to both attributes. The type Literal is a data type covering all textual representations of values from simple data types in the model."
    }, {
      "heading" : "2.9 Value comparison constraints",
      "text" : "The metamodel fragment for value comparison constraints is depicted in Figure 11. Note that in the formalisation below, a textual representation is chosen for the comparison operators.\n• relation (0..∗, 2) role subset, first textual constraint\n∀(x)(ValueComparisonConstraint(x) → ∃=2(y)(Participant(x, y))) ∀(x, y)(First(x, y) → ((ValueComparisonConstraint(x) ∧ Role(y))∨ (RelationshipConstraint(x) ∧ Role(y)))) ∀(x, y)(Second(x, y) → ((ValueComparisonConstraint(x) ∧ Role(y))∨ (RelationshipConstraint(x) ∧ Role(y)))) ∀(x, y)(First(x, y) → Participant(x, y)) ∀(x, y)(Second(x, y) → Participant(x, y)) ∀(x, y)((Participant(x, y) ∧ ValueComparisonConstraint(x)) → (First(x, y) ∨ Second(x, y))) ∀(x, y)(¬(First(x, y) ∧ Second(x, y) ∧ ValueComparisonConstraint(x))) ∀(x)(ValueComparisonConstraint(x) → ∃=1(y)(First(x, y))) ∀(x)(ValueComparisonConstraint(x) → ∃=1(y)(Second(x, y)))\n• nominals ∀(x, y)(ComparisonOperatorOf(x, y) → (ValueComparisonConstraint(x) ∧ Operator(y))) ∀(x)(ValueComparisonConstraint(x) → ∃=1(y)(ComparisonOperatorOf(x, y))) ∀(x)(Operator(x) → ((x = Less) ∨ (x = Leq) ∨ (x = Eq)∨\n(x = Neq) ∨ (x = Geq) ∨ (x = Greater))) ∀(x)((x = Less) → (Operator(x) ∧ ¬(x = Leq) ∧ ¬(x = Eq)∧ ¬(x = Neq) ∧ ¬(x = Geq) ∧ ¬(x = Greater))) ∀(x)((x = Leq) → (Operator(x) ∧ ¬(x = Less) ∧ ¬(x = Eq)∧ ¬(x = Neq) ∧ ¬(x = Geq) ∧ ¬(x = Greater))) ∀(x)((x = Eq) → (Operator(x) ∧ ¬(x = Less) ∧ ¬(x = Leq)∧ ¬(x = Neq) ∧ ¬(x = Geq) ∧ ¬(x = Greater))) ∀(x)((x = Neq) → (Operator(x) ∧ ¬(x = Less) ∧ ¬(x = Leq)∧ ¬(x = Eq) ∧ ¬(x = Geq) ∧ ¬(x = Greater))) ∀(x)((x = Geq) → (Operator(x) ∧ ¬(x = Less) ∧ ¬(x = Leq)∧ ¬(x = Eq) ∧ ¬(x = Neq) ∧ ¬(x = Greater))) ∀(x)((x = Greater) → (Operator(x) ∧ ¬(x = Less) ∧ ¬(x = Leq)∧\n¬(x = Eq) ∧ ¬(x = Neq) ∧ ¬(x = Geq)))\nOperator is the name assigned to the concept associated with the nominals in Figure 11. These nominals are the only operators allowed, and they are all different.\n• relation (1, 0..∗) ∀(x, y)(OnValueOfType(x, y) → (ValueComparisonConstraint(x) ∧ DataType(y))) ∀(x)(ValueComparisonConstraint(x) → ∃=1(y)(OnValueOfType(x, y)))\n• second textual constraint ∀(x, y, z)((ValueComparisonConstraint(x) ∧ First(x, y) ∧ Second(x, z)) →\n∃(u, v, w)(RolePlaying(y, u, v) ∧ RolePlaying(z, w, v) ∧ DataType(v)))∗"
    }, {
      "heading" : "2.10 Role and Relationship constraints",
      "text" : "Constraints among roles and relationship are shown in Figure 12, and it, with its repetitive list of similar textual constraints are formalised afterward in this section. The Relationship constraints (reflexivity etc.) are presented afterward in Figure 13 and its formalisation. This section closes with the metamodel fragment for ORM’s join constraints, depicted in Figure 14 and formalised at the end of this section, therewith completing the metamodel and its FOL formalisation.\nFormalization of Equality and Disjointness Constraints\n• four relations DeclaredOn (0..∗, 2..∗) ∀(x)(RelationshipEquality(x) → ∃≥2(y)(DeclaredOn(x, y))) ∀(x)(DisjointRelationships(x) → ∃≥2(y)(DeclaredOn(x, y))) ∀(x)(RoleEquality(x) → ∃≥2(y)(DeclaredOn(x, y))) ∀(x)(DisjointRoles(x) → ∃≥2(y)(DeclaredOn(x, y)))\n• two relations DeclaredOn (0..∗, 1) ∀(x)(CompletenessConstraint(x) → ∃=1(y)(DeclaredOn(x, y))) ∀(x)(DisjointEntities(x) → ∃=1(y)(DeclaredOn(x, y)))\n• two relations hasParticipant (0..∗, 2..∗) ∀(x, y)(HasParticipant(x, y) → ((CompletenessConstraint(x) ∨ DisjointEntities(x))∧\nEntity(y) ∧ ¬QualifiedRelationship(y) ∧ ¬Subsumption(y)∧ ¬AttributiveProperty(y) ∧ ¬Qualifier(y) ∧ ¬Constraint(y)))\n∀(x)(CompletenessConstraint(x) → ∃≥2(y)(HasParticipant(x, y))) ∀(x)(DisjointEntities(x) → ∃≥2(y)(HasParticipant(x, y)))\n• textual constraints\n∀(x, y)((DisjointEntities(x) ∧ HasParticipant(x, y)) → ∃(z)(DeclaredOn(x, z) ∧ Subsumption(z) ∧ Sub(z, y)))∗ ∀(x, y, z)((DisjointEntities(x) ∧ DeclaredOn(x, y) ∧ Sub(y, z)) → HasParticipant(x, z))∗ ∀(x, y)((CompletenessConstraint(x) ∧ HasParticipant(x, y)) → ∃(z)(DeclaredOn(x, z) ∧ Subsumption(z) ∧ Sub(z, y)))∗ ∀(x, y, z)((CompletenessConstraint(x) ∧ DeclaredOn(x, y) ∧ Sub(y, z)) → HasParticipant(x, z))∗ ∀(x, y)(Compatible(x, y) → ((ValueProperty(x) ∧ ValueProperty(y))∨ (DataType(x) ∧ DataType(y))∨ (ObjectType(x) ∧ ObjectType(y))∨ (Role(x) ∧ Role(y))∨ (Relationship(x) ∧ Relationship(y)))) ∀(x, y)((Compatible(x, y) ∧ Role(x)) → ∃(v, w, s, t)(RolePlaying(x, v, w) ∧ RolePlaying(y, s, t) ∧ Compatible(w, t)))∗ ∀(x, y)((Compatible(x, y) ∧ Relationship(x)) → ((∃=n(z)(Contains(x, z)) ↔ ∃=n(z)(Contains(y, z)))∧ (∃(z, v)(Contains(x, z) ∧ Contains(y, w) ∧ Compatible(z, w)))))∗ ∀(x, y, z)((DisjointRelationships(x) ∧ DeclaredOn(x, y) ∧ DeclaredOn(x, z)) → Compatible(y, z))∗ ∀(x, y, z)((DisjointRoles(x) ∧ DeclaredOn(x, y) ∧ DeclaredOn(x, z)) → (Compatible(y, z)∧ ∀(v, w)((Contains(v, y) ∧ Contains(w, z)) → ¬(y = z))))∗ ∀(x, y, z)((RoleEquality(x) ∧ DeclaredOn(x, y) ∧ DeclaredOn(x, z)) → (Compatible(y, z)∧ ∀(v, w)((Contains(v, y) ∧ Contains(w, z)) → ¬(y = z))))∗ ∀(x, y, z)((RelationshipEquality(x) ∧ DeclaredOn(x, y) ∧ DeclaredOn(x, z)) → Compatible(y, z))∗\nThis is necessary first order since n is any natural number up to the maximum arity of a relationships in the model."
    }, {
      "heading" : "Formalization of Relationship Constraints",
      "text" : "• relation (0..4, 2) ∀(x)(RelationshipConstraint(x) → ∃=2(y)(Participant(x, y))) ∀(x)(Role(x) → ∃≤4(y)(Participant(y, x)))\n• two relations (0..∗, 1), subset, union ∀(x, y)((Participant(x, y) ∧ RelationshipConstraint(x)) → (First(x, y) ∨ Second(x, y))) ∀(x, y)(¬(First(x, y) ∧ Second(x, y) ∧ RelationshipConstraint(x))) ∀(x)(RelationshipConstraint(x) → ∃=1(y)(First(x, y))) ∀(x)(RelationshipConstraint(x) → ∃=1(y)(Second(x, y)))\n• textual constraint ∀(x, y, z)((RelationshipConstraint(x, y) ∧ RelationshipConstraint(x, z)∧\nFirst(x, y) ∧ Second(x, z)) → (Compatible(y, z)∧ ∃(w)(Contains(w, y) ∧ Contains(w, z))))∗"
    }, {
      "heading" : "Formalization of Join Constraints",
      "text" : "• ternary relation (0..∗, 1, 0..∗) ∀(x, y, z)(Joining(x, y, z) → (Relationship(x) ∧ Role(z) ∧ JoinConstraint(y))) ∀(x)(JoinConstraint(x) → ∃=1(y, z)(Joining(y, x, z)))\n• relation (3..4, 0..∗) and relation (4, 0..∗) ∀(x, y)(ParticipatesIn(x, y) → (JoinConstraint(y) ∧ (Relationship(x) ∨ Role(x)))) ∀(x)(JoinConstraint(x) → (∃=3(y)(Relationship(y) ∧ ParticipatesIn(y, x))∨\n∃=4(y)(Relationship(y) ∧ ParticipatesIn(x, y)))) ∀(x)(JoinConstraint(x) → ∃=4(y)(Role(y) ∧ ParticipatesIn(y, x)))\n• first textual constraint ∀(x, y)((JoinConstraint(x) ∧ Role(y) ∧ ParticipatesIn(y, x)) →\n∃(z)(Relationship(z) ∧ Contains(z, y) ∧ ParticipatesIn(z, x)))∗"
    }, {
      "heading" : "2.11 On the complexity of the FOL formalization",
      "text" : "The complete FOL formalization of the metamodel is probably undecidable. We have complex formula in five variables, counting quantifiers, and ternary predicates. Even if we reify ternary relations, the complexity of deciding if a given formula follows from some instantiated metamodel is similar to that of the general satisfiability problem. Problematic formula belong though to textual constraints of the figures; they are not originated from the graphical language of UML class diagrams. So if we remove from the metamodel all formula labeled with a “∗”, then we obtain a lighter formalization described in C2, the fragment of function-free FOL with only two variables and counting quantifiers. This fragment is not only decidable, but also in NEXPTIME, as shown in [Pratt-Hartmann, 2005]. Most description logics are also subsets of C2.\nThis lighter version of the metamodel is the basis for the OWL 2 version described in next section."
    }, {
      "heading" : "3 OWL 2 version of the metamodel",
      "text" : "Considering that the complete formalisation of the metamodel requires full FOL, hence, using an undecidable language, we also look at representing a subset in a decidable language to facilitate the metamodel’s use in various applications. A relevant and popular logic language in this\ncontext is OWL, so that, thanks to the tools that can process it, we also can have some form of verification that our model is consistent (at least for what is representable in OWL 2 DL). This OWL version of the metamodel (v1.2) is available at http://www.meteck.org/files/ ontologies/metamodelCDML.owl.\nThe OWL version is larger than the number of entities in the diagrams of the preceding section, and has 99 classes, 61 object properties, 2 data properties, and overall 657 axioms, and the language used is SHIQ(D) (data from Protégé v4.3’s “ontology metrics” page), i.e., using features of OWL 2 DL [Motik et al., 2009] and in particular the qualified cardinality. Because the diagrams were made in Omnigraffle1, no UML-in-Omnigraffle to OWL tool exists, there are textual constraints in our metamodel that can be captured formally, and other UML-to-OWL tools are partial, we formalised the metamodel manually. Further, due to the limitations of OWL on the one hand, and the greater expressiveness regarding other features, there is no exact match between the metamodel and the OWL file. We describe the main changes and design decisions in the remainder of this section.\nMissing information. The first thing to note is that the ternary and quaternary associations of the metamodel could not be represented in OWL, and thus had to be approximated. We used the following procedure for this, which is similar to procedures mentioned elsewhere (e.g., the ontology design pattern in [Presutti et al., 2008]):\n1. Add new class ReifiedNAry, 2. If the n-ary was not reified already then add it as subclass of ReifiedNAry and append it\nwith an R, if present already then add a subsumption to ReifiedNAry. 3. Add n binaries between said class and the others, where the binaries have a naming scheme\nof the name of the n-ary appended with a number (1, 2 etc.) to distinguish them from real object properties, and add domain and range classes. 4. These numbered object properties are not to be used as real object properties elsewhere in the OWL file. 5. Add an exactly 1 (or other cardinality constraint, depending on the constraint in the model) from the ReifiedNAryR to the participating class. Note that several ternary relations in the metamodel are already reified, since one of their participant has cardinality constraint 1..1. For these relations, the above procedure can be simplified.\nOther information missing from the OWL file are the textual constraints whose formula are marked with “∗” in the FOL formalisations, because these constraints cannot be expressed in OWL. Also, a few other complex constraints, such as the “The Single identification has a Mandatory constraint on the participating Role and the Relationship that Role is contained in has a 1:1 Cardinality constraint declared on it.” (see second textual constraint in Figure 8), are not included due to OWL’s expressiveness limitations.\nOther modelling artefacts. Some other representation choices had to be made. We note them here for information and documentation; their rationale is outside the scope of this technical report.\nThere are several entities that were not subsumed by anything in particular, such as MaximumCardinality, MinimumCardinality, Dimension, and ValueRange, which have now been made an OWL subclass of Abstract. This also meant that the four attributes in the metamodel have been ‘flattened’ on the OWL file, i.e., instead of one binary from class to data type with OWL’s data property, it uses a separate part relation and then a hasCValue and hasValue, respectively, to the values.\nThe participation of IdentificationConstraint is twice 0..* in the figure, but that is translated into OWL as “some (ValueProperty or AttributiveProperty)”, because the constraint has to be\n1https://www.omnigroup.com/omnigraffle; last accessed 5-12-2014.\ndeclared on something. The comparison operators of Figure 11 are written out in text and represented as subclasses of Comparison and is made the disjoint union of its subclasses, and the ValueComparisonConstraint is given exactly 1 Comparison.\nIt has been shown that using OWL 2’s new feature of inverse object properties results in better reasoner performance [Keet et al., 2014]. Therefore, we chose not to use object properties ‘in both directions’, but use that instead. For instance constrainedWith has not been used in the OWL file, but instead, in Protégé notation, inverse(declaredOn).\nWe have added partOf, properPartOf, and hasPart.\nSatisfiability and consistency checking. We checked the OWL-ized metamodel with the automated reasoner HerMiT v1.3.8 that is shipped with Protégé v4.3. The sole useful inference was the detection of an inconsistency of Asymmetry in the hierarchy of constraints in an earlier version of the metamodel: the {disjoint, complete} on the object subtypes of Relationship constraint in [Keet and Fillottrani, 2013] had to be changed into {complete} in Figure 2 due to the multiple inheritance of Asymmetry that was overlooked. This has been corrected in this version of the metamodel.\nNon-logician readability/rendering. One may expect a reader who made it this far to be familiar with at least logic or UML notation and thus have a general understanding of the contents of the metamodel and its formalisation. However, as can be observed from the previous paragraphs about the OWL version of it, there are some finer details of that logic reconstruction. Also, the FOL version of the metamodel is rather light on annotations. To facilitate readability, we have generated an online controlled natural language version (verbalization) of the OWL file, which was made with SWAT Natural Language tools [Third et al., 2011]. This easily navigable HTML document is available online at www.meteck.org/files/ontologies/ metamodelNL.html and a section of it is shown in Figure 15."
    }, {
      "heading" : "4 Final remarks",
      "text" : "We have presented the FOL formalisation of the KF metamodel that serves as a unifying metamodel for the static structural entities of UML Class Diagrams (v2.4.1), ER, EER, ORM, and ORM2. It has to be noted that this indeed requires FOL. Notwithstanding, and with an eye on implementations, we also have created an OWL 2 DL version of it, noting some modelling decisions, such as a pattern for representing n-aries.\nInitial use of the formalisation has been demonstrated in [Fillottrani and Keet, 2014], where the constraints represented among the entities induce validation checking of inter-model assertions and model transformations."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work is based upon research supported by the National Research Foundation of South Africa (Project UID90041) and the Argentinean Ministry of Science and Technology. Any opinion, findings and conclusions or recommendations expressed in this material are those of the author and therefore the NRF does not accept any liability in regard thereto."
    } ],
    "references" : [ {
      "title" : "Reasoning over extended ER models",
      "author" : [ "Artale et al", "A. 2007] Artale", "D. Calvanese", "R. Kontchakov", "V. Ryzhikov", "M. Zakharyaschev" ],
      "venue" : "Proceedings of the 26th International Conference on Conceptual Modeling (ER’07),",
      "citeRegEx" : "al. et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2007
    }, {
      "title" : "The Description Logics Handbook – Theory and Applications",
      "author" : [ "Baader et al", "F. 2008] Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. PatelSchneider" ],
      "venue" : null,
      "citeRegEx" : "al. et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2008
    }, {
      "title" : "The entity-relationship model—toward a unified view of data",
      "author" : [ "Chen", "P.P. 1976] Chen" ],
      "venue" : "ACM Transactions on Database Systems,",
      "citeRegEx" : "Chen and Chen,? \\Q1976\\E",
      "shortCiteRegEx" : "Chen and Chen",
      "year" : 1976
    }, {
      "title" : "Conceptual model interoperability: a metamodel-driven approach",
      "author" : [ "Fillottrani", "Keet", "P. 2014] Fillottrani", "C. Keet" ],
      "venue" : "Proceedings of the 8th International Web Rule Symposium (RuleML’14),",
      "citeRegEx" : "Fillottrani et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Fillottrani et al\\.",
      "year" : 2014
    }, {
      "title" : "Information modeling and relational databases",
      "author" : [ "Halpin", "Morgan", "T. 2008] Halpin", "T. Morgan" ],
      "venue" : null,
      "citeRegEx" : "Halpin et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Halpin et al\\.",
      "year" : 2008
    }, {
      "title" : "Exploring reasoning with the DMOP ontology",
      "author" : [ "Keet et al", "C. 2014] Keet", "C. d’Amato", "Z. Khan", "A. Lawrynowicz" ],
      "venue" : "Workshop on Ontology Reasoner Evaluation (ORE’14),",
      "citeRegEx" : "al. et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2014
    }, {
      "title" : "Enhancing identification mechanisms in UML class diagrams with meaningful keys",
      "author" : [ "C.M. Keet" ],
      "venue" : "[Keet,",
      "citeRegEx" : "Keet,? \\Q2011\\E",
      "shortCiteRegEx" : "Keet",
      "year" : 2011
    }, {
      "title" : "Toward an ontologydriven unifying metamodel for UML class diagrams, EER, and ORM2",
      "author" : [ "Keet", "Fillottrani", "C.M. 2013] Keet", "P.R. Fillottrani" ],
      "venue" : "32nd International Conference on Conceptual Modeling (ER’13),",
      "citeRegEx" : "Keet et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Keet et al\\.",
      "year" : 2013
    }, {
      "title" : "An ontology-driven unifying metamodel of UML Class Diagrams, EER, and ORM2",
      "author" : [ "Keet", "Fillottrani", "C.M. 2014] Keet", "P.R. Fillottrani" ],
      "venue" : "Data & Knowledge Engineering,",
      "citeRegEx" : "Keet et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Keet et al\\.",
      "year" : 2014
    }, {
      "title" : "OWL 2 web ontology language structural specification and functional-style syntax",
      "author" : [ "Motik et al", "B. 2009] Motik", "P.F. Patel-Schneider", "B. Parsia" ],
      "venue" : "W3c recommendation,",
      "citeRegEx" : "al. et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2009
    }, {
      "title" : "A library of ontology design patterns: reusable solutions for collaborative design of networked ontologies. NeOn deliverable D2.5.1",
      "author" : [ "Presutti et al", "V. 2008] Presutti", "A. Gangemi", "S. David", "G.A. de Cea", "M.C. Surez-Figueroa", "E. Montiel-Ponsoda", "M. Poveda" ],
      "venue" : "NeOn Project,",
      "citeRegEx" : "al. et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2008
    }, {
      "title" : "Entity relationship model",
      "author" : [ "Song", "Chen", "2009] Song", "I.-Y", "P.P. Chen" ],
      "venue" : "Encyclopedia of Database Systems,",
      "citeRegEx" : "Song et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Song et al\\.",
      "year" : 2009
    }, {
      "title" : "OWL to English: a tool for generating organised easily-navigated hypertexts from ontologies",
      "author" : [ "Third et al", "A. 2011] Third", "S. Williams", "R. Power" ],
      "venue" : "poster/demo paper, Open Unversity UK. 10th International Semantic Web Conference",
      "citeRegEx" : "al. et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "al. et al\\.",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "The metamodel fragment concerning identifiers (Figure 8), while comprehensive in its treatment, does not deal with definitions of identity (see [Keet, 2011] for a brief discussion on this topic).",
      "startOffset" : 144,
      "endOffset" : 156
    }, {
      "referenceID" : 8,
      "context" : "It has been shown that using OWL 2’s new feature of inverse object properties results in better reasoner performance [Keet et al., 2014].",
      "startOffset" : 117,
      "endOffset" : 136
    } ],
    "year" : 2014,
    "abstractText" : "The KF metamodel [Keet and Fillottrani, 2013, Keet and Fillottrani, 2014] is a comprehensive unifying metamodel covering the static structural entities and constraints of UML Class Diagrams (v2.4.1), ER, EER, ORM, and ORM2, and intended to boost interoperability of common conceptual data modelling languages. It was originally designed in UML with textual constraints, and in this report we present its formalisations in FOL and OWL, which accompanies the paper that describes, discusses, and analyses the KF metamodel in detail. These new formalizations contribute to give a precise meaning to the metamodel, to understand its complexity properties and to provide a basis for future implementations.",
    "creator" : "LaTeX with hyperref package"
  }
}