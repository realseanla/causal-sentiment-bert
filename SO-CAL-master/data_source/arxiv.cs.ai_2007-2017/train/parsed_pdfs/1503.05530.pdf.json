{
  "name" : "1503.05530.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Exploration de la scalabilité de LocFaults",
    "authors" : [ "Mohammed Bekkouche" ],
    "emails" : [ "Mohammed.Bekkouche@unice.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "A model checker can produce a trace of counterexample, for a erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each MCD found. We present the times of our approach on programs with While-loops unfolded b times, and a number of diverted conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraintbased and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire\nLes erreurs dans un programme sont inévitables, elles peuvent nuire à son bon fonctionnement et avoir des conséquences financières extrêmement graves et présenter une menace pour le bien-être humain [8]. Le lien suivant [7] cite des histoires récentes de bugs logiciels. Conséquemment, le processus de débogage (la détection, la localisation et la correction d’erreurs) est essentiel. La localisation d’erreurs est l’étape qui coûte le plus. Elle consiste à identifier l’emplacement exact des instructions suspectes [6] afin d’aider l’utilisateur à comprendre pourquoi le programme a échoué, ce qui lui facilite la tâche de la correction des erreurs. En effet, quand un programme P est non conforme vis-à-vis de sa spécification (P contient des erreurs), un vérificateur de modèle peut produire une trace d’un contre-exemple, qui est souvent longue et difficile à comprendre même pour les programmeurs expérimentés. Pour résoudre ce problème, nous avons proposé une approche [4] (nommée LocFaults) à base de contraintes qui explore les chemins du CFG(Control Flow Graph) du programme à partir du contre-exemple, pour calculer les sous-ensembles minimaux permettant de restaurer la conformité du programme vis-à-vis de sa postcondition. Assurer que notre méthode soit hautement scalable pour faire face à l’énorme complexité des systèmes logiciels est un critère important pour sa qualité [1].\nDans ce papier, nous explorons le passage à l’échelle de LocFaults sur des programmes avec boucles While dépliées b fois, et un nombre de conditions déviées allant de 0 à 3.\nL’idée de notre approche est de réduire le problème\nde la localisation d’erreurs vers celui qui consiste à calculer un ensemble minimal qui explique pourquoi un CSP (Constraint Satisfaction Problem) est infaisable. Le CSP représente l’union des contraintes du contre-exemple, du programme et de l’assertion violée. L’ensemble calculé peut être un MCS (Minimal Correction Subset) ou MUS (Minimal Unsatisfiable Subset). En général, tester la faisabilité d’un CSP sur un domaine fini est un problème NP-Complet (intraitable) 1, la classe des problèmes les plus difficiles de la classe NP. Cela veut dire, expliquer l’infaisabilité dans un CSP est aussi dur, voire plus (on peut classer le problème comme NP-Difficile). BugAssist [9] [10] est une méthode de localisation d’erreurs qui utilise un solveur Max-SAT pour calculer la fusion des MCSs de la formule Booléenne du programme en entier avec le contre-exemple. Elle devient inefficace pour les programmes de grande taille. LocFaults travaille aussi à partir d’un contre-exemple pour calculer les MCSs. La contribution de notre approche par rapport à BugAssist peut se résumer dans les points suivants : * Nous ne transformons pas la totalité du programme en un système de contraintes, mais nous utilisons le CFG du programme pour collecter les contraintes du chemin du contre-exemple et des chemins dérivés de ce dernier, en supposant qu’au plus k instructions conditionnelles sont susceptibles de contenir les erreurs. Nous calculons les MCSs uniquement sur le chemin du contre-exemple et les chemins qui corrigent le programme ;\n* Nous ne traduisons pas les instructions du programme en une formule SAT, mais plutôt en contraintes numériques qui vont être manipulées par des solveurs de contraintes ; * Nous n’utilisons pas des solveurs MaxSAT comme bôıtes noires, mais plutôt un algorithme générique pour calculer les MCSs par l’usage d’un solveur de contraintes ; * Nous bornons la taille des MCSs générés et le nombre de conditions déviées ; * Nous pouvons faire collaborer plusieurs solveurs durant le processus de localisation et prendre celui le plus performant selon la catégorie du CSP construit. Exemple, si le CSP du chemin détecté est du type linéaire sur les entiers, nous faisons appel à un solveur MIP (Mixed Integer Programming) ; s’il est non linéaire, nous utilisons un solveur CP (Constraint Programming) ou aussi MINLP (Mixed Integer Nonlinear Programming).\nNotre expérience pratique a montré que toutes ces restrictions et distinctions ont permis à LocFaults\n1. Si ce problème pouvait être résolu en temps polynomial, alors tous les problèmes NP-Complet le seraient aussi.\nd’être plus rapide et plus expressif.\nLe papier est organisé comme suit. La section 2 introduit la définition d’un MUS et MCS. Dans la section 3, nous définirons le problème ≤ k-DCM. Nous expliquons une contribution du papier pour le traitement des boucles erronées, notamment le bug Off-by-one, dans la section 4. Une brève description de notre algorithme LocFaults est fournie dans la section 5. L’évaluation expérimentale est présentée dans la section 6. La section 7 parle de la conclusion et de nos travaux futurs.\n2 Définitions\nDans cette section, nous introduirons la définition d’un IIS/MUS et MCS.\nCSP Un CSP (Constraint Satisfaction Problem) P est un triplet < X,D,C > tel que : * X un ensemble de n variables x1, x2, ..., xn. * D le n-uplet < Dx1 , Dx2 , ..., Dxn >. L’ensemble Dxi contient les valeurs de la variable xi.\n* C={c1, c2, ..., cn} est l’ensemble des contraintes. Une solution pour P est une instanciation des variables I ∈ D qui satisfait toutes les contraintes dans C. P est infaisable s’il ne dispose pas de solutions. Un sous-ensemble de contraintes C′ dans C est dit aussi infaisable pour la même raison sauf qu’ici on se limite à l’ensemble des contraintes dans C′. On note par : – Sol(< X,C′, D >) = ∅, pour spécifier que C′ n’a pas de solutions, et donc il est infaisable.\n– Sol(< X,C′, D >) 6= ∅, pour spécifier que C′ dispose d’au moins une solution, et donc il est faisable.\nOn dit que P est en forme linéaire et on note LP(Linear Program) ssi toutes les contraintes dans C sont des équations/inégalités linéaires, il est continu si le domaine de toutes les variables est celui des réels. Si au moins une des variables dans X est du type entier ou binaire (cas spécial d’un entier), et les contraintes sont linéaires, P est dit un programme linéaire mixte MIP(Mixed-integer linear program). Si les contraintes sont non-linéaires, on dit que P est un programme non linéaire NLP(NonLinear Program).\nSoit P =< X,D,C > un CSP infaisable, on définit pour P :\nIS Un IS(Inconsistent Set) est un sous-ensemble de contraintes infaisable dans l’ensemble de contraintes infaisable C. C′ est un IS ssi : * C′ ⊆ C.\n* Sol(< X,C′, D >) = ∅.\nIIS ou MUS Un IIS(Irreducible Inconsistent Set) ou MUS (Minimal Unsatisfiable Subset) est un sousensemble de contraintes infaisable de C, et tous ses sous-ensembles stricts sont faisables. C′ est un IIS ssi : * C′ est un IS. * ∀ C′′ ⊂ C′.Sol(< X,C′′, D >) 6= ∅, (chacune de ses parties contribue à l’infaisabilité), C′ est dit irréductible.\nMCS C′ est un MCS(Minimal Correction Set) ssi : * C′ ⊆ C. * Sol(< X,C\\C′, D >) 6= ∅. * ∄ C′′ ⊂ C′ tel que Sol(< X,C\\C′′, D >) 6= ∅.\n3 Le problème ≤ k-DCM\nÉtant donné un programme erroné modélisé en un CFG 2 G = (C,A,E) : C est l’ensemble des nœuds conditionnels ; A est l’ensemble des blocs d’affectation ; E est l’ensemble des arcs, et un contre-exemple. Une DCM (Déviation de Correction Minimale) est un ensemble D ⊆ C telle que la propagation du contreexemple sur l’ensemble des instructions de G à partir de la racine, tout en ayant nié chaque condition 3 dans D, permet en sortie de satisfaire la postcondition. Elle est dite minimale (ou irréductible) dans le sens où aucun élément ne peut être retiré de D sans que celle-ci ne perde cette propriété. En d’autres termes,D est une correction minimale du programme dans l’ensemble des conditions. La taille d’une déviation minimale est son cardinal. Le problème ≤ k-DCM consiste à trouver toutes les DCMs de taille inférieure ou égale à k.\nExemple, le CFG du programme AbsMinus (voir fig. 2) possède une déviation minimale de taille 1 pour le contre-exemple {i = 0, j = 1}. Certes, la déviation {i0 ≤ j0,k1 = 1 ∧ i0 6= j0} permet de corriger le programme, mais elle n’est pas minimale ; la seule déviation minimale pour ce programme est {k1 = 1 ∧ i0 6= j0}.\nLe tableau ci-dessous récapitule le déroulement de LocFaults pour le programme AbsMinus, avec au plus 2 conditions déviées à partir du contre-exemple suivant {i = 0, j = 1}.\n2. Nous utilisons la transformation en forme DSA [5] qui assure que chaque variable est affectée une seule fois sur chaque chemin du CFG.\n3. On nie la condition afin de prendre la branche opposée à celle où on devait aller.\n1 c l a s s AbsMinus { 2 /∗@ ensure s 3 @ (( i<j )==>(\\ r e s u l t==j− i ) )&& 4 @ (( i>=j )==>(\\ r e s u l t==i −j ) ) ; ∗/ 5 i n t AbsMinus ( in t i , i n t j ){ 6 i n t r e s u l t ; 7 i n t k = 0 ; 8 i f ( i <= j ) { 9 k = k+2;// e r r o r :\nshould be k=k+1 10 } 11 i f (k == 1 && i != j ) { 12 r e su l t = j−i ; 13 } 14 e l s e { 15 r e su l t = i−j ; 16 } 17 } 18 }\nFigure 1 – Le programme AbsMinus\nk0 = 0\ni0 ≤ j0\nk1 = k0 + 2 Error k1 = k0\nk1 = 1 ∧ i0! = j0\nr1 = j0 − i0 r1 = i0 − j0\nPOST :{r1 == |i − j|}\nIf Else\nIf Else\nFigure 2 – Le CFG DSA de AbsMinus\n{(i0 == 0) ∧ (j0 == 1)}\nk0 = 0\ni0 ≤ j0\nk1 = k0 + 2 k1 = k0\nk1 = 1 ∧ i0! = j0\nr1 = j0 − i0 r1 = i0 − j0\n{r1 == |i − j|}\nIf Else\nIf Else\nFigure 3 – Le chemin du contre-exemple\n{(i0 == 0) ∧ (j0 == 1)}\nk0 = 0\ni0 ≤ j0\nk1 = k0 + 2 k1 = k0\nk1 = 1 ∧ i0! = j0\nr1 = j0 − i0 r1 = i0 − j0\n{r1 == |i − j|} is UNSAT\nIf Else\nIf Else\nFigure 4 – Le chemin obtenu en déviant la condition i0 ≤ j0\nConditions déviées DCM MCS Figure\n∅ / {r1 = i0 − j0 : 15} fig. 3 {i0 ≤ j0 : 8} Non / fig. 4 {k1 = 1 ∧ i0! = j0 : 11} Oui {k0 = 0 : 7}, fig. 5\n{k1 = k0 + 2 : 9}\n{i0 ≤ j0 : 8, Non / fig. 6 k1 = 1 ∧ i0! = j0 : 11}\nNous avons affiché les conditions déviées, si elles constituent une déviation minimale ou non, les MCSs calculés à partir du système construit : voir respectivement les colonnes 1, 2 et 3. La colonne 4 indique la figure qui illustre le chemin exploré pour chaque déviation. Sur la première et la troisième colonne, nous avons affiché en plus de l’instruction sa\nligne dans le programme. Exemple, la première ligne dans le tableau montre qu’il y a un seul MCS trouvé ({r1 = i0 − j0 : 15}) sur le chemin du contre-exemple.\n4 Traitement des boucles\nDans le cadre du Bounded Model Checking (BMC) pour les programmes, le dépliage peut être appliqué au programme en entier comme il peut être appliqué aux boucles séparément [1]. Notre approche de localisation d’erreurs, LocFaults [3] [4], se place dans la deuxième démarche ; c’est-à-dire, nous utilisons une borne b pour déplier les boucles en les remplaçant par des imbrications de conditionnelles de profondeur b. Considérons le programme Minimum (voir fig. 7) contenant une seule boucle, qui calcule le minimum dans un tableau d’entiers. L’effet sur le graphe de flot de contrôle du programme Minimum avant et après le dépliage est illustré sur les figures respectivement 7 et 8 : la boucle While est dépliée 3 fois, tel que 3 est le nombre d’itérations nécessaires à la boucle pour calculer la valeur minimum dans un tableau de taille 4 dans le pire des cas.\nLocFaults prend en entrée le CFG du programme erroné, CE un contre-exemple, bdcm : une borne sur le nombre de conditions déviées, bmcs : une borne sur la taille des MCSs calculés. Il permet d’explorer le CFG en profondeur en déviant au plus bdcm conditions par rapport au comportement du contre-exemple : * Il propage le contre-exemple jusqu’à la postcondition. Ensuite, il calcule les MCSs sur le CSP du chemin généré pour localiser les erreurs sur le chemin du contre-exemple.\n* Il cherche à énumérer les ensembles ≤ bdcm-DCM. Pour chaque DCM trouvée, il calcule les MCSs dans le chemin qui arrive à la dernière condition déviée et qui permet de prendre le chemin de la déviation.\nParmi les erreurs les plus courantes associées aux boucles selon [2], le bug Off-by-one, c’est-à-dire, des boucles qui s’itèrent une fois de trop ou de moins. Cela peut être dû à une mauvaise initialisation des variables de contrôle de la boucle, ou à une condition incorrecte de la boucle. Le programme Minimum présente un cas de ce type d’erreur. Il est erroné à cause de sa boucle While, l’instruction falsifiée se situe sur la condition de la boucle (ligne 9) : la condition correcte doit être (i < tab.length) (tab.length est le nombre d’éléments\ndu tableau tab). À partir du contre-exemple suivant : {tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, nous avons illustré sur la figure 8 le chemin fautif initial (voir le chemin coloré en rouge), ainsi que la déviation pour laquelle la postcondition est satisfaisable (la dé-\nviation ainsi que le chemin au-dessus de la condition déviée sont illustrés en vert).\nNous affichons dans le tableau ci-dessous les chemins erronés générés (la colonne PATH) ainsi que les MCSs calculés (la colonne MCSs) pour au plus 1 condition déviée par rapport au comportement du contreexemple. La première ligne correspond au chemin du contre-exemple ; la deuxième correspond au chemin obtenu en déviant la condition {i2 ≤ tab0.length− 1}.\nPATH MCSs\n{CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1\n{min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1,\nmin1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2,\nPOST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]}\n{CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1},∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1},min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1}i2 = i1 + 1,[¬(i2 ≤ tab0.length − 1)]\nLocFaults a permis d’identifier un seul MCS sur le chemin du contre-exemple qui contient la contrainte min2 = tab0[i1], l’instruction de la ligne 11 dans la deuxième itération de la boucle dépliée. Avec une condition déviée, l’algorithme suspecte la troisième condition de la boucle dépliée, i2 < tab0.length − 1 ; en d’autres termes, il faut une nouvelle itération pour satisfaire la postcondition.\nCet exemple montre un cas d’un programme avec une boucle erronée : l’erreur est sur le critère d’arrêt, elle ne permet pas en effet au programme d’itérer jusqu’au dernier élément du tableau en entrée. LocFaults avec son mécanisme de déviation arrive à supporter ce type d’erreur avec précision. Il fournit à l’utilisateur non seulement les instructions suspectes dans la boucle non dépliée du programme original, mais aussi des informations sur les itérations où elles se situent\nconcrètement en dépliant la boucle. Ces informations pourraient être très utiles pour le programmeur pour mieux comprendre les erreurs dans la boucle.\n5 Algorithme amélioré\nNotre but consiste à trouver les DCMs de taille inférieure à une borne k ; en d’autres termes, on cherche à donner une solution au problème posé ci-dessus (≤ k-DCM). Pour cela, notre algorithme (nommé LocFaults) parcourt en profondeur le CFG et génère les chemins où au plus k conditions sont déviées par rapport au comportement du contre-exemple.\nPour améliorer l’efficacité, notre solution heuristique procède de façon incrémentale. Elle dévie successivement de 0 à k conditions et elle recherche les MCSs pour les chemins correspondants. Toutefois, si à l’étape k LocFaults a dévié une condition ci et que cela a cor-\nrigé le programme, elle n’explorera pas à l’étape k′ avec k′ > k les chemins qui impliquent une déviation de la condition ci. Pour cela, nous ajoutons la cardinalité de la déviation minimale trouvée (k) comme information sur le nœud de ci.\nNous allons sur un exemple illustrer le déroulement de notre approche, voir le graphe sur la figure 9. Chaque cercle dans le graphe représente un nœud conditionnel visité par l’algorithme. L’exemple ne montre pas les blocs d’affectations, car nous voulons illustrer uniquement comment nous trouverons les déviations de correction minimales d’une taille bornée de la manière citée ci-dessus. Un arc reliant une condition c1 à une autre c2 illustre que c2 est atteinte par l’algorithme. Il y a deux façons, par rapport au comportement du contre-exemple, par lesquelles LocFaults arrive à la condition c2 :\n1. en suivant la branche normale induite par la condition c1 ;\n2. en suivant la branche opposée.\nLa valeur de l’étiquette des arcs pour le cas (1) (resp. (2)) est ”next” (resp. ”devie”).\n– À l’étape k = 5, notre algorithme a identifié deux déviations minimales de taille égale à 5 :\n1. D1 = {1, 2, 3, 4, 7}, le nœud ”7” est marqué par la valeur 5 ;\n2. D2 = {8, 9, 11, 12, 7}, elle a été autorisée, car la valeur de la marque du nœud ”7” est égale à la cardinalité de D2.\n– À l’étape k = 6, l’algorithme a suspendu la déviation suivante D3 = {8, 13, 14, 15, 16, 7}, car la cardinalité de D3 est supérieure strictement à la valeur de l’étiquette du nœud ”7”.\n6 Expérience pratique\nPour évaluer la scalabilité de notre méthode, nous avons comparé ses performances avec celles de BugAssist 4 sur deux ensembles de benchmarks 5. * Le premier benchmark est illustratif, il contient un ensemble de programmes sans boucles ;\n* Le deuxième benchmark inclut 19, 49 et 91 variations pour respectivement les programmes BubbleSort, Sum et SquareRoot. Ces programmes contiennent des boucles pour étudier le passage à l’échelle de notre approche par rapport à BugAssist. Pour augmenter la complexité d’un programme, nous augmentons le nombre d’itérations dans les boucles à l’exécution de chaque outil ; nous utilisons la même borne de dépliage des boucles pour LocFaults et BugAssist.\nPour générer le CFG et le contre-exemple, nous utilisons l’outil CPBPV [11] (Constraint-Programming Framework for Bounded Program Verification). LocFaults et BugAssist travaillent respectivement sur des programmes Java et C. Pour que la comparaison soit juste, nous avons construit pour chaque programme deux versions équivalentes : * une version en Java annotée par une spécification JML ;\n* une version en ANSI-C annotée par la même spécification mais en ACSL. Les deux versions ont les mêmes numéros de lignes d’instructions, notamment des erreurs. La précondition spécifie le contre-exemple employé pour le programme.\nPour calculer les MCSs, nous avons utilisé les solveurs IBM ILOG MIP 6 et CP 7 de CPLEX. Nous\n4. L’outil BugAssist est disponible à l’adresse : http:// bugassist.mpi-sws.org/\n5. Le code source de l’ensemble de programmes est disponible à l’adresse : http://www.i3s.unice.fr/~bekkouch/ Benchs_Mohammed.html\n6. Disponible à l’adresse http ://www01.ibm.com/software/commerce/optimization/cplexoptimizer/\n7. Disponible à l’adresse http ://www01.ibm.com/software/commerce/optimization/cplex-cp-\navons adapté et implémenté l’algorithme de Liffiton et Sakallah [12], voir alg. 1. Cette implémentation prend en entrée l’ensemble de contraintes infaisable qui correspond au chemin identifié (C), et bmcs : la borne sur la taille des MCSs calculés. Chaque contrainte ci dans le système construit C est augmentée par un indicateur yi pour donner yi → ci dans le nouveau système de contraintes C′. Affecter à yi la valeur V rai implique la contrainte ci ; en revanche, affecter à yi la valeur Faux implique la suppression de la contrainte ci. Un MCS est obtenu en cherchant une affectation qui satisfait le système de contraintes avec un ensemble minimal d’indicateurs de contraintes affectés avec Faux. Pour limiter le nombre de variables indicateurs de contraintes qui peuvent être assignées à Faux, on utilise la contrainte AtMost(¬y1,¬y2, ...,¬yn, k) (voir la ligne 5), le système créé est noté dans l’algorithme C′k (ligne 5). Chaque itération de la boucle While (lignes 6 − 19) permet de trouver tous les MCSs de taille k, k est incrémenté de 1 après chaque itération. Après chaque MCS trouvé (lignes 8− 13), une contrainte de blocage est ajoutée à C′k et C\n′ pour empêcher de trouver ce nouveau MCS dans les prochaines itérations (lignes 15 − 16). La première boucle (lignes 4 − 19) s’itère jusqu’à ce que tous les MCSs de C soient générés (C′ devient infaisable) ; elle peut s’arrêter aussi si les MCSs de taille inférieure ou égale bmcs sont obtenus (k > bmcs).\n1 Fonction MCS(C,bmcs ) Entrées: C : Ensemble de contraintes infaisable, bmcs : Entier Sorties: MCS : Liste de MCSs de C de cardinalité inférieure à bmcs 2 début 3 C′ ← AddYVars(C) ; MCS ← ∅ ; k ← 1 ; 4 tant que SAT(C′) ∧ k ≤ bmcs faire 5 C′ k ← C′ ∧ AtMost({¬y1,¬y2, ...,¬yn},k) 6 tant que SAT(C′ k ) faire 7 newMCS ← ∅ 8 pour chaque indicateur yi faire 9 % yi est l’indicateur de la contrainte ci ∈ C, et val(yi) la\nvaleur de yi dans la solution calculée de C ′ k .\n10 si val(yi) = 0 alors 11 newMCS ← newMCS ∪ {ci}. 12 fin 13 fin 14 MCS.add(newMCS). 15 C′ k ← C′ k ∧ BlockingClause(newMCS) 16 C′ ← C′ ∧ BlockingClause(newMCS) 17 fin 18 k ← k + 1 19 fin 20 retourner MCS 21 fin\nAlgorithm 1: Algorithme de Liffiton et Sakallah\nBugAssist utilise l’outil CBMC [13] pour générer la trace erronée et les données d’entrée. Pour le solveur Max-SAT, nous avons utilisé MSUnCore2 [14].\nLes expérimentations ont été effectuées avec un processeur Intel Core i7-3720QM 2.60 GHz avec 8 GO de RAM.\noptimizer/\n6.1 Le benchmark sans boucles\nCette partie sert à illustrer l’amélioration apportée à LocFaults pour réduire le nombre d’ensembles suspects fournis à l’utilisateur : à une étape donnée de l’algorithme, le nœud dans le CFG du programme qui permet de détecter une DCM sera marqué par le cardinal de cette dernière ; ainsi aux prochaines étapes, l’algorithme n’autorisera pas le balayage d’une liste d’adjacence de ce nœud.\nNos résultats 8 montrent que LocFaults rate les erreurs uniquement pour TritypeKO6. Or, BugAssist rate l’erreur pour AbsMinusKO2, AbsMinusKO3, AbsMinusV2KO2, TritypeKO, TriPerimetreKO, TriMultPerimetreKO et une des deux erreurs dans TritypeKO5. Les temps 9 de notre outil sont meilleurs par rapport à BugAssist pour les programmes avec calcul numérique ; ils sont proches pour le reste des programmes.\nPrenons trois exemples parmi ces programmes au hasard. Et considérons l’implémentation de deux versions de notre algorithme, sans et avec marquage des nœuds nommées respectivement LocFaultsV1 et LocFaultsV2.\n– Les tables 1 et 2 montrent respectivement les ensembles suspects et les temps de LocFaultsV1 ; – Les tables 3 et 4 montrent respectivement les ensembles suspects et les temps de LocFaultsV2.\nDans les tables 1 et 3, nous avons affiché la liste des MCSs et DCMs calculés. Le numéro de la ligne correspondant à la condition est souligné. Les tables 2 et 4 donnent les temps de calcul : P est le temps de prétraitement qui inclut la traduction du programme Java en un arbre syntaxique abstrait avec l’outil JDT (Eclipse Java devlopment tools), ainsi que la construction du CFG ; L est le temps de l’exploration du CFG et de calcul des MCSs.\nLocFaultsV2 a permis de réduire considérablement les déviations générées ainsi que les temps sommant l’exploration du CFG et le calcul des MCSs de LocFaultsV1, et cela sans perdre l’erreur ; les localisations fournies par LocFaultsV2 sont plus pertinentes. Les lignes éliminées de la table 3 sont colorées en bleu dans la table 1. Les temps améliorés sont affichés en gras dans la table 4. Par exemple, pour le programme TritypeKO2, à l’étape 1 de l’algorithme,\n8. Le tableau qui donne les MCSs calculés par LocFaults pour les programmes sans boucles est disponible à l’adresse http://www.i3s.unice.fr/~bekkouch/Bench_ Mohammed.html#rsb\n9. Les tableaux qui donnent les temps de LocFaults et BugAssist pour les programmes sans boucles sont disponibles à l’adresse http://www.i3s.unice.fr/~bekkouch/Bench_ Mohammed.html#rsba\nLocFaultsV2marque le nœud de la condition 26, 35 et 53 (à partir du contre-exemple, le programme devient correct en déviant chacune de ces trois conditions). Cela permet, à l’étape 2, d’annuler les déviations suivantes : {26, 29}, {26, 35}, {29, 35}, {32, 35}. Toujours à l’étape 2, LocFaultsV2 détecte deux déviations minimales en plus : {29, 57}, {32, 44}, les nœuds 57 et 44 vont donc être marqués (la valeur de la marque est\n2). À l’étape 3, aucune déviation n’est sélectionnée ; à titre d’exemple, {29, 32, 44} n’est pas considérée parce que son cardinal est supérieur strictement à la valeur de la marque du nœud 44.\n6.2 Les benchmarks avec boucles\nCes benchmarks servent à mesurer l’extensibilité de LocFaults par rapport à BugAssist pour des programmes avec boucles, en fonction de l’augmentation du nombre de dépliage b. Nous avons pris trois programmes avec boucles : BubbleSort, Sum et SquareRoot. Nous avons provoqué le bug Off-by-one dans chacun. Le benchmark, pour chaque programme, est créé en faisant augmenter le nombre de dépliage b. b est égal au nombre d’itérations effectuées par la boucle dans le pire des cas. Nous faisons aussi varier le nombre de conditions déviées pour LocFaults de 0 à 3.\nNous avons utilisé le solveur MIP de CPLEX pour BubbleSort. Pour Sum et SquareRoot, nous avons fait collaborer les deux solveurs de CPLEX (CP et MIP) lors du processus de la localisation. En effet, lors de la collecte des contraintes, nous utilisons une variable pour garder l’information sur le type du CSP construit. Quand LocFaults détecte un chemin erroné 10 et avant de procéder au calcul des MCSs, il prend le bon solveur selon le type du CSP qui correspond à ce chemin : s’il est non linéaire, il utilise le\n10. Un chemin erroné est celui sur lequel nous identifions les MCSs.\nsolveur CP OPTIMIZER; sinon, il utilise le solveur MIP.\nPour chaque benchmark, nous avons présenté un extrait de la table contenant les temps de calcul (les colonnes P et L affichent respectivement les temps de prétraitement et de calcul des MCSs), ainsi que le graphe qui correspond au temps de calcul des MCSs.\n6.2.1 Le benchmark BubbleSort\nBubbleSort est une implémentation de l’algorithme de tri à bulles. Ce programme contient deux boucles imbriquées ; sa complexité en moyenne est d’ordre n2, où n est la taille du tableau : le tri à bulles est considéré parmi les mauvais algorithmes de tri. L’instruction erronée dans ce programme entrâıne le programme à trier le tableau en entrée en considérant seulement ses n − 1 premiers éléments. Le mauvais fonctionnement du BubbleSort est dû au nombre d’itérations insuffisant effectué par la boucle. Cela est dû à l’initialisation fautive de la variable i : i = tab.length - 1 ; l’instruction devait être i = tab.length.\nLes temps de LocFaults et BugAssist pour le benchmark BubbleSort sont présentés dans la table 5. Le graphe qui illustre l’augmentation des temps des différentes versions de LocFaults et de BugAssist en fonction du nombre de dépliages est donné dans la figure 10.\nLa durée d’exécution de LocFaults et de BugAssist crôıt exponentiellement avec le nombre de dépliages ; les temps de BugAssist sont toujours les plus grands. On peut considérer que BugAssist est inefficace pour ce benchmark. Les différentes versions de LocFaults (avec au plus 3, 2, 1 et 0 conditions déviées) restent utilisables jusqu’à un certain dépliage. Le nombre de dépliage au-delà de lequel la croissance des temps de BugAssist devient rédhibitoire est inférieur à celui de LocFaults, celui de LocFaults avec au plus 3 conditions déviées est inférieur à celui de LocFaults avec au plus 2 conditions déviées qui est inférieur lui aussi à\ncelui de LocFaults avec au plus 1 conditions déviées. Les temps de LocFaults avec au plus 1 et 0 condition déviée sont presque les mêmes.\n6.2.2 Les benchmarks SquareRoot et Sum\nLe programme SquareRoot (voir fig. 11) permet de trouver la partie entière de la racine carrée du nombre entier 50. Une erreur est injectée à la ligne 13, qui entrâıne de retourner la valeur 8 ; or le programme doit retourner 7. Ce programme a été utilisé dans le papier décrivant l’approche BugAssist, il contient un calcul numérique linéaire dans sa boucle et non linéaire dans sa postcondition.\n1 c l a s s SquareRoot{ 2 /∗@ ensu res ( ( r e s ∗ res<=val ) && ( re s +1)∗( r e s+1)>val ) ; ∗/ 3 i n t SquareRoot ( ) 4 { 5 in t va l = 50 ; 6 in t i = 1; 7 in t v = 0; 8 in t r e s = 0 ; 9 whi l e (v < val ){\n10 v = v + 2∗ i + 1 ; 11 i= i + 1 ; 12 } 13 re s = i ; /∗ e r ro r : the i n s t r u c t i o n should be r e s = i − 1∗/ 14 return re s ; 15 } 16 }\nFigure 11 – Le programme SquareRoot\nAvec un dépliage égal à 50, BugAssist calcule pour ce programme les instructions suspectes suivantes : {9, 10, 11, 13}. Le temps de la localisation est 36, 16s et le temps de prétraitement est 0, 12s.\nLocFaults présente une instruction suspecte en indiquant à la fois son emplacement dans le programme (la ligne d’instruction), ainsi que la ligne de la condition et l’itération de chaque boucle menant à cette instruction. Par exemple, 9 : 2.11 correspond à l’instruction qui se trouve à la ligne 11 dans le programme, cette dernière est dans une boucle dont la ligne de la condition d’arrêt est 9 et le numéro d’itération est 2. Les ensembles suspectés par LocFaults sont fournis dans le tableau suivant. DCMs MCSs\n∅ {5},{6},{9 : 1.11}, {9 : 2.11},{9 : 3.11}, {9 : 4.11},{9 : 5.11},{9 : 6.11},{9 : 7.11},{13}\n{9 : 7} {5},{6},{7},{9 : 1.10},{9 : 2.10},{9 : 3.10}, {9 : 4.10},{9 : 5.10}, {9 : 6.10},{9 : 1.11},\n{9 : 2.11},{9 : 3.11},{9 : 4.11},{9 : 5.11}, {9 : 6.11}\nLe temps de prétraitement est 0, 769s. Le temps écoulé lors de l’exploration du CFG et le calcul des MCS est 1, 299s. Nous avons étudié le temps de LocFaults et BugAssist des valeurs de val allant de 10 à 100 (le nombre de dépliage b employé est égal à val), pour étudier le comportement combinatoire de chaque outil pour ce programme.\nLe programme Sum prend un entier positif n de l’utilisateur, et il permet de calculer la valeur de∑n\ni=1 i. La postcondition spécifie cette somme. L’erreur dans Sum est dans la condition de sa boucle. Elle cause de calculer la somme ∑n−1 i=1 i au lieu de ∑n i=1 i. Ce programme contient des instructions numériques linéaires dans le cœur de la boucle, et une postcondition non linéaire.\nLes résultats en temps pour les benchmarks SquareRoot et Sum sont présentés dans les tables respectivement 6 et 7. Nous avons dessiné aussi le graphe qui correspond au résultat de chaque benchmark, voir respectivement le graphe de la figure 12 et 13. Le temps d’exécution de BugAssist crôıt rapidement ; les temps\nde LocFaults sont presque constants. Les temps de LocFaults avec au plus 0, 1 et 2 conditions déviées sont proches de ceux de LocFaults avec au plus 3 conditions déviées.\n7 Conclusion\nLa méthode LocFaults détecte les sous-ensembles suspects en analysant les chemins du CFG pour trouver les DCMs et les MCSs à partir de chaque DCM ; elle utilise des solveurs de contraintes. La méthode BugAssit calcule la fusion des MCSs du programme en transformant le programme complet en une formule booléenne ; elle utilise des solveurs Max-SAT. Les deux\nméthodes travaillent en partant d’un contre-exemple. Dans ce papier, nous avons présenté une exploration de la scalabilité de LocFaults, particulièrement sur le traitement des boucles avec le bug Off-by-one. Les premiers résultats montrent que LocFaults est plus efficace que BugAssist sur des programmes avec boucles. Les temps de BugAssist croissent rapidement en fonction du nombre de dépliages.\nDans le cadre de nos travaux futurs, nous envisageons de confirmer nos résultats sur des programmes avec boucles plus complexes. Nous développons une version interactive de notre outil qui fournit les sousensembles suspects l’un après l’autre : nous voulons tirer profit des connaissances de l’utilisateur pour sélectionner les conditions qui doivent être déviées. Nous réfléchissons également sur comment étendre notre méthode pour supporter les instructions numériques avec calcul sur les flottants.\nRemerciements. Nous remercions Bertrand Neveu pour sa lecture attentive et ses commentaires utiles sur ce papier. Merci également à Michel Rueher et Hélène Collavizza pour leurs remarques intéressantes.\nRéférences\n[1] D’silva, Vijay, Daniel Kroening, and Georg Weissenbacher. ”A survey of automated techniques for formal software verification.” Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 27.7 (2008) : 1165-1178.\n[2] Kok-Ming Leung. ”Debugging Loops.” In http://cis. poly.edu/~mleung/CS1114/s08/ch02/debug.htm\n[3] Bekkouche, Mohammed, Hélène Collavizza, and Michel Rueher. ”Une approche CSP pour l’aide à la localisation d’erreurs.” arXiv preprint arXiv :1404.6567 (2014).\n[4] Bekkouche, Mohammed, Hélène Collavizza, and Michel Rueher. ”LocFaults : A new flow-driven and constraint-based error localization approach*.” ACM. SAC’15, SVT track, Apr 2015, Salamanca, Spain. <10.1145/2695664.2695822>. <hal-01094227>\n[5] Barnett, Mike, and K. Rustan M. Leino. ”Weakestprecondition of unstructured programs.” ACM SIGSOFT Software Engineering Notes. Vol. 31. No. 1. ACM, 2005.\n[6] Wong, W. Eric, and Vidroha Debroy. ”A survey of software fault localization.” Department of Computer Science, University of Texas at Dallas, Tech. Rep. UTDCS-45-09 (2009).\n[7] Bekkouche, Mohammed. ”Bug stories.” In http://www. i3s.unice.fr/~bekkouch/Bug_stories.html\n[8] Wikipedia. ”List of software bugs — Wikipedia, The Free Encyclopedia.” In http: //en.wikipedia.org/w/index.php?title=List_\nof_software_bugs&oldid=648559652\n[9] Jose, Manu, and Rupak Majumdar. ”Cause clue clauses : error localization using maximum satisfiability.” ACM SIGPLAN Notices 46.6 (2011) : 437-446.\n[10] Jose, Manu, and Rupak Majumdar. ”Bug-Assist : assisting fault localization in ANSI-C programs.” Computer Aided Verification. Springer Berlin Heidelberg, 2011.\n[11] Collavizza, Hélène, Michel Rueher, and Pascal Van Hentenryck. ”CPBPV : a constraint-programming framework for bounded program verification.”Constraints 15.2 (2010) : 238-264.\n[12] Liffiton, Mark H., and Karem A. Sakallah. ”Algorithms for computing minimal unsatisfiable subsets of constraints.” Journal of Automated Reasoning 40.1 (2008) : 1-33.\n[13] Clarke, Edmund, Daniel Kroening, and Flavio Lerda. ”A tool for checking ANSI-C programs.” Tools and Algorithms for the Construction and Analysis of Systems. Springer Berlin Heidelberg, 2004. 168-176.\n[14] Marques-Silva, Joao. ”The msuncore maxsat solver.” SAT 2009 competitive events booklet : preliminary version (2009) : 151."
    } ],
    "references" : [ {
      "title" : "A survey of automated techniques for formal software verification.",
      "author" : [ "D’silva", "Vijay", "Daniel Kroening", "Georg Weissenbacher" ],
      "venue" : "Computer-Aided Design of Integrated Circuits and Systems, IEEE Transactions on 27.7",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2008
    }, {
      "title" : "Une approche CSP pour l’aide à la localisation d’erreurs.",
      "author" : [ "Bekkouche", "Mohammed", "Hélène Collavizza", "Michel Rueher" ],
      "venue" : "arXiv preprint arXiv",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2014
    }, {
      "title" : "LocFaults : A new flow-driven and constraint-based error localization approach*.",
      "author" : [ "Bekkouche", "Mohammed", "Hélène Collavizza", "Michel Rueher" ],
      "venue" : "ACM. SAC’15, SVT track,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "Weakestprecondition of unstructured programs.",
      "author" : [ "Barnett", "Mike", "K. Rustan M. Leino" ],
      "venue" : "ACM SIG- SOFT Software Engineering Notes",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2005
    }, {
      "title" : "A survey of software fault localization.",
      "author" : [ "Wong", "W. Eric", "Vidroha Debroy" ],
      "venue" : "Department of Computer Science, University of Texas at Dallas, Tech. Rep. UTDCS-45-09",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2009
    }, {
      "title" : "Cause clue clauses : error localization using maximum satisfiability.",
      "author" : [ "Jose", "Manu", "Rupak Majumdar" ],
      "venue" : "ACM SIGPLAN Notices",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Bug-Assist : assisting fault localization in ANSI-C programs.",
      "author" : [ "Jose", "Manu", "Rupak Majumdar" ],
      "venue" : "Computer Aided Verification",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2011
    }, {
      "title" : "CPBPV : a constraint-programming framework for bounded program verification.”Constraints",
      "author" : [ "Collavizza", "Hélène", "Michel Rueher", "Pascal Van Hentenryck" ],
      "venue" : null,
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "Algorithms for computing minimal unsatisfiable subsets of constraints.",
      "author" : [ "Liffiton", "Mark H", "Karem A. Sakallah" ],
      "venue" : "Journal of Automated Reasoning",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2008
    }, {
      "title" : "A tool for checking ANSI-C programs.” Tools and Algorithms for the Construction and Analysis of Systems",
      "author" : [ "Clarke", "Edmund", "Daniel Kroening", "Flavio Lerda" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2004
    }, {
      "title" : "The msuncore maxsat solver.",
      "author" : [ "Marques-Silva", "Joao" ],
      "venue" : "SAT 2009 competitive events booklet : preliminary version",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "Elle consiste à identifier l’emplacement exact des instructions suspectes [6] afin d’aider l’utilisateur à comprendre pourquoi le programme a échoué, ce qui lui facilite la tâche de la correction des erreurs.",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 2,
      "context" : "Pour résoudre ce problème, nous avons proposé une approche [4] (nommée LocFaults) à base de contraintes qui explore les chemins du CFG(Control Flow Graph) du programme à partir du contre-exemple, pour calculer les sous-ensembles minimaux permettant de restaurer la conformité du programme vis-à-vis de sa postcondition.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 0,
      "context" : "Assurer que notre méthode soit hautement scalable pour faire face à l’énorme complexité des systèmes logiciels est un critère important pour sa qualité [1].",
      "startOffset" : 152,
      "endOffset" : 155
    }, {
      "referenceID" : 5,
      "context" : "BugAssist [9] [10] est une méthode de localisation d’erreurs qui utilise un solveur Max-SAT pour calculer la fusion des MCSs de la formule Booléenne du programme en entier avec le contre-exemple.",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 6,
      "context" : "BugAssist [9] [10] est une méthode de localisation d’erreurs qui utilise un solveur Max-SAT pour calculer la fusion des MCSs de la formule Booléenne du programme en entier avec le contre-exemple.",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 3,
      "context" : "Nous utilisons la transformation en forme DSA [5] qui assure que chaque variable est affectée une seule fois sur chaque chemin du CFG.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 0,
      "context" : "Dans le cadre du Bounded Model Checking (BMC) pour les programmes, le dépliage peut être appliqué au programme en entier comme il peut être appliqué aux boucles séparément [1].",
      "startOffset" : 172,
      "endOffset" : 175
    }, {
      "referenceID" : 1,
      "context" : "Notre approche de localisation d’erreurs, LocFaults [3] [4], se place dans la deuxième démarche ; c’est-à-dire, nous utilisons une borne b pour déplier les boucles en les remplaçant par des imbrications de conditionnelles de profondeur b.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 2,
      "context" : "Notre approche de localisation d’erreurs, LocFaults [3] [4], se place dans la deuxième démarche ; c’est-à-dire, nous utilisons une borne b pour déplier les boucles en les remplaçant par des imbrications de conditionnelles de profondeur b.",
      "startOffset" : 56,
      "endOffset" : 59
    }, {
      "referenceID" : 0,
      "context" : "À partir du contre-exemple suivant : {tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, nous avons illustré sur la figure 8 le chemin fautif initial (voir le chemin coloré en rouge), ainsi que la déviation pour laquelle la postcondition est satisfaisable (la déviation ainsi que le chemin au-dessus de la condition déviée sont illustrés en vert).",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "À partir du contre-exemple suivant : {tab[0] = 3, tab[1] = 2, tab[2] = 1, tab[3] = 0}, nous avons illustré sur la figure 8 le chemin fautif initial (voir le chemin coloré en rouge), ainsi que la déviation pour laquelle la postcondition est satisfaisable (la déviation ainsi que le chemin au-dessus de la condition déviée sont illustrés en vert).",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 0,
      "context" : "PATH MCSs {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 35,
      "endOffset" : 38
    }, {
      "referenceID" : 1,
      "context" : "PATH MCSs {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 0,
      "context" : "PATH MCSs {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 224,
      "endOffset" : 227
    }, {
      "referenceID" : 1,
      "context" : "PATH MCSs {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 259,
      "endOffset" : 262
    }, {
      "referenceID" : 0,
      "context" : "PATH MCSs {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 298,
      "endOffset" : 301
    }, {
      "referenceID" : 1,
      "context" : "PATH MCSs {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {min2 = tab0[i1]} ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], i2 = i1 + 1,min3 = min2, i3 = i2, POST : [(tab[0] ≥ min3) ∧ (tab[1] ≥ min3) ∧(tab[2] ≥ min3) ∧ (tab[3] ≥ min3)]} {CE : [tab0[0] = 3 ∧ tab0[1] = 2 ∧ tab0[2] = 1 {i0 = 1}, ∧tab0[3] == 0], min0 = tab0[0], i0 = 1, {i1 = i0 + 1}, min1 = tab0[i0],i1 = i0 + 1,min2 = tab0[i1], {i2 = i1 + 1} i2 = i1 + 1,[¬(i2 ≤ tab0.",
      "startOffset" : 335,
      "endOffset" : 338
    }, {
      "referenceID" : 0,
      "context" : "CE :{tab0[0] == 3 ∧ tab0[1] == 2 ∧ tab0[2] == 1 ∧ tab0[3] == 0}",
      "startOffset" : 24,
      "endOffset" : 27
    }, {
      "referenceID" : 1,
      "context" : "CE :{tab0[0] == 3 ∧ tab0[1] == 2 ∧ tab0[2] == 1 ∧ tab0[3] == 0}",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 7,
      "context" : "Pour générer le CFG et le contre-exemple, nous utilisons l’outil CPBPV [11] (Constraint-Programming Framework for Bounded Program Verification).",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 8,
      "context" : "com/software/commerce/optimization/cplex-cpavons adapté et implémenté l’algorithme de Liffiton et Sakallah [12], voir alg.",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 9,
      "context" : "BugAssist utilise l’outil CBMC [13] pour générer la trace erronée et les données d’entrée.",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 10,
      "context" : "Pour le solveur Max-SAT, nous avons utilisé MSUnCore2 [14].",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 0,
      "context" : "[1] D’silva, Vijay, Daniel Kroening, and Georg Weissenbacher.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[3] Bekkouche, Mohammed, Hélène Collavizza, and Michel Rueher.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "[4] Bekkouche, Mohammed, Hélène Collavizza, and Michel Rueher.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 3,
      "context" : "[5] Barnett, Mike, and K.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 4,
      "context" : "[6] Wong, W.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[9] Jose, Manu, and Rupak Majumdar.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 6,
      "context" : "[10] Jose, Manu, and Rupak Majumdar.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "[11] Collavizza, Hélène, Michel Rueher, and Pascal Van Hentenryck.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : "[12] Liffiton, Mark H.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 9,
      "context" : "[13] Clarke, Edmund, Daniel Kroening, and Flavio Lerda.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[14] Marques-Silva, Joao.",
      "startOffset" : 0,
      "endOffset" : 4
    } ],
    "year" : 2015,
    "abstractText" : "A model checker can produce a trace of counterexample, for a erroneous program, which is often long and difficult to understand. In general, the part about the loops is the largest among the instructions in this trace. This makes the location of errors in loops critical, to analyze errors in the overall program. In this paper, we explore the scalability capabilities of LocFaults, our error localization approach exploiting paths of CFG(Control Flow Graph) from a counterexample to calculate the MCDs (Minimal Correction Deviations), and MCSs (Minimal Correction Subsets) from each MCD found. We present the times of our approach on programs with While-loops unfolded b times, and a number of diverted conditions ranging from 0 to n. Our preliminary results show that the times of our approach, constraintbased and flow-driven, are better compared to BugAssist which is based on SAT and transforms the entire program to a Boolean formula, although the information provided by LocFaults is more expressive for the user.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}