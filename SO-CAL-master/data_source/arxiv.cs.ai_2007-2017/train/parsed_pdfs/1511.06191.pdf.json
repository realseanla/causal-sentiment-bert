{
  "name" : "1511.06191.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Abstract Attribute Exploration with Partial Object Descriptions",
    "authors" : [ "Daniel Borchmann", "Bernhard Ganter" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 1.\n06 19\n1v 1\n[ cs\n.A I]\n1 9\nN ov\n2 01\n5\nwith Partial Object Descriptions\nDaniel Borchmann Bernhard Ganter\nNovember 20, 2015\nAttribute exploration has been investigated in several studies, with particular emphasis on the algorithmic aspects of this knowledge acquisition method. In its basic version the method itself is rather simple and transparent. But when background knowledge and partially described counterexamples are admitted, it gets more difficult. Here we discuss this case in an abstract, somewhat “axiomatic” setting, providing a terminology that clarifies the abstract strategy of the method rather than its algorithmic implementation."
    }, {
      "heading" : "1 Introduction",
      "text" : "Attribute Exploration is a fairly well-known andwell-tried knowledge acquisition technique based on Formal Concept Analysis [6]. It is similar to Query Learning, as described in [1]. Though quite simple in its basic idea, it can become rather intricate in its many extensions and modifications (see Ganter & Obiedkov (in preparation) for an overview). Readers who are unfamiliar with this method may find motivating examples in the literature.\nThe aim of this paper is not to add yet another generalization, but to present an abstract version of one of the more basic variants, namely attribute exploration with partial object descriptions [3]. For this we shall make use of the formalization of a domain expert, as developed by the first author [4]. We thereby hope to make the method more transparent. It is our impression that such a strictly formal setting might eventually be more practical. In general, the purpose of an attribute exploration is to classify, by querying an expert, all admissible attribute combinations of a given attribute set. A typical query consists of a logical proposition, usually an implication, that is presented to the domain expert. The expert has to decide if that proposition holds for all admissible sets. In case that it does not, the expert is asked to provide a counter-example, i.e., an admissible set that is not a model of the proposition. In the version discussed here we allow for partially specified counter-examples.\nThe set of models of an arbitrary set of implications is closed under intersections. Therefore, if only implications are used, admissible sets can only be classified up to intersections."
    }, {
      "heading" : "2 The parts of the exploration method",
      "text" : "The attribute exploration method consists of four modules which have the following purposes:\nThe exploration schema specifies the framework of an exploration. It defines the universe which is to be explored.\nThe exploration base contains the current status of an exploration.\nThe domain expert is the reliable information source for an exploration.\nThe exploration engine consists of the algorithmic machinery for the communication between domain expert and exploration base.\nThese four parts will now be described more precisely. Before doing so, we shortly sketch the nature of these four modules. The exploration schema specifies the set of all attribute combinations under investigation (admissible or not). We call this the universe of the respective exploration. Moreover, the schema may contain additional background knowledge. The exploration base has three parts. One contains the counter-examples that have already been accepted or inferred. The second contains the implications which have been validated or inferred. Both lists can be modified by the domain expert and by the exploration engine. A journal file, being the third part of the base, records all such modification. The domain expert receives questions in the form of implications. Each asked implication is either validated or disproved by giving a (partially specified) counter-example. The exploration engine examines at any point of an exploration the current exploration base if there exists an implication that holds for all collected counter-examples, but which cannot be inferred from the validated implications. If so, then such an implication is presented to the domain expert. Otherwise, the exploration terminates. The exploration engine also modifies the exploration base according to (valid) inference rules."
    }, {
      "heading" : "3 The exploration schema",
      "text" : "A (finite) set M of attributes under investigation is specified. The universe is the power set (P(M),Ď). The set to be determined by the exploration is some subset E Ď P(M), which however is not directly accessible, but only through questioning some “domain expert”. The\nsubsets which are elements of E are called admissible sets or, synonymously, counterexamples. The questions to the domain expert are formulated as implications R Ñ S, where R and S are subsets of M. A set X Ď M respects (or is a model of) an implication R Ñ S, if S Ď X or R Ę X. Otherwise, if R Ď X and S Ę X. then X refutes the implication R Ñ S. By validating an implication R Ñ S the domain expert states that this implication is respected by all admissible sets. In other words, if an admissible set contains all elements of R, then it also must contain all elements of S. If an implication R Ñ S is not confirmed, then the expert provides a counter-example, i.e., some set E P E that refutes the implication R Ñ S. We allow, however, that the domain expert does not specify such a counter-example precisely. Instead, a partial description may be given in form of a pair (U,V) of sets U Ď V Ď M such that R Ď U and S Ę V. By providing such a pair (U,V) the domain expert expresses that there is some admissible set E with U Ď E Ď V (which then necessarily refutes the implication R Ñ S). Such an E is called an admissible completion of the partial counter-example (U,V). Some background knowledge may be present that rules out parts of the universe as non-admissible, so that only some subset K Ď P(M) of the power set needs to be investigated. Such background knowledge usually is given in the form of propositional formulas over M. It excludes all subsets that are not models of these formulas. One possible data type for such background formulae is that of set families (A, B1, B2, . . . , Bk), representing cumulated clauses\nľ A Ñ k ł\ni=1\nľ\nBi,\nwhere A as well as B1, . . . , Bk are subsets of M. The condition expressed by such a formula is that any admissible set which contains all the attributes from A must also contain all attributes from Bi, for at least one i. There are algorithms for the exploration engine that use such cumulated clauses. If the background knowledge excludes the top element M, i.e., if the combination of all attributes is not admissible, then we must allow for indefinite implications. In this case, the top element is denoted as K, and A Ñ K indicates that A is not contained in any admissible set. We present here what we call the set-based exploration schema. More abstract versions are under discussion, but have not yet been worked out."
    }, {
      "heading" : "4 The exploration base",
      "text" : "An exploration base consists of three parts: a journal file, the collection of accepted counter-examples, and the collection of validated implications. These sets may be empty in the beginning of an exploration. Both collections are subsets of the order relation Ď, which means that each entry of these collections is a pair (R, S) of elements fromP(M)with R Ď S. How do such pairs represent counter-examples and implications?\nA pair (R, S) of subsets represents the implication R Ñ S, which is considered to hold true iff R Ď A implies S Ď A for all admissible sets A Ď M. W.l.o.g. we may assume that R Ď S, because R Ñ S is logically equivalent to R Ñ RY S, since both implications are respected by the same sets. A partial counter-example is a pair (U,V) of subsets with U Ď V Ď M. It refutes the implication R Ñ S iff"
    }, {
      "heading" : "R Ď U and S Ę V.",
      "text" : "It is assumed that the domain expert only provides partial counter-examples which have an admissible completion. That implies that throughout each exploration process the exploration base remains consistent in the sense that it has at least one realizer, i.e., that all partial examples can be completed in such a way that they respect all validated implications and are not excluded by the background knowledge. We shall prove later that an exploration base can be checked for consistency without knowing what the admissible sets are. We warn the reader that for an exploration base to be consistent, it is not sufficient that no counter-example refutes a validated implication. We write L for the list of implications and C for the list of partial counter-examples in the base. We ignore the journal file for the time being and abbreviate the exploration base as (L, C). Such a base may have more than one realizer, but it has –if consistent– always a largest one. That consists of all L-closed sets which are compatible with the background knowledge. Our expectation is that during an exploration process the exploration base gets enriched so that it eventually converges to a specific realizer, representing the domain that is explored. To make this more precise, consider two exploration bases (L1, C1) and (L2, C2) for the same schema. We say that (L1, C1) is more (or equally) expressive than (L2, C2), if every realizer of (L1, C1) also is a realizer of (L2, C2). Easier to check is the following condition: We call (L1, C1) is better (or equally) focused than (L2, C2), if the following two conditions are fulfilled:\n1. For each implication A Ñ B in L2 there is an implication C Ñ D in L1 with\nC Ď A Ď B Ď D.\n2. For each partial counter-example (U,V) in C2 there is a partial counter-example (X,Y) in C1 with\nU Ď X Ď Y Ď V.\nIt is easy to see that a better focused base automatically is more or equally expressive. The exploration base is modified by the domain expert and by the exploration engine. In a later stage of an exploration procedure it might not at all be obvious why a certain entry in the base is present. We therefore find it advisable to keep track of all modifications. That is what the journal file is for."
    }, {
      "heading" : "5 The domain expert",
      "text" : "The domain expert is the unique information source for the exploration. If this expert is a human, a group, or an algorithm, does not really matter for our considerations. Essential is the (probably unrealistic) assumption that the expert is consistent in the sense that the given answers are compatible with a realizer. This is now formalized. Consider a mapping p that maps implications to counter-examples or to a symbol indication that the implication is true. Recall that both implications and counter-examples are comparable pairs of subsets of M, and recall that the subset-order relation formally is the set of all comparable pairs,\nĎ = t(A, B) | A, B P P(M), A Ď Bu.\nThus such a mapping is of the form\np : Ď Ñ Ď Y tJu, where J R Ď .\nFor better readability we shall write R Ñ S for implications and (U,V) for partially specified counter-examples. We call p(Ď)ztJu the set of partial counter-examples of p and Th(p) := p´1(J) the theory of p.\n5.1 Definition A mapping p : Ď Ñ Ď Y tJu is called a domain expert (on the universe (P(M),Ď), with background knowledge K Ď P(M)) iff it satisfies the following conditions:\ni. p gives partial counter-examples to false implications: if p(X Ñ Y) = (T,U) ‰ J, then (T,U) is a partial counter-example for X Ñ Y, i.e., X Ď T and Y Ę U.\nii. p does not give partial counter-examples to valid implications: if X Ñ Y,V Ñ W are such that\np(X Ñ Y) = J and p(V Ñ W) = (T,U),\nthen (T,U) is not a partial counterexample for X Ñ Y, i.e., X Ď T implies Y Ď U.\niii. p is consistent with the background knowledge: Each counter-example (T,U) of p has an compatible completion, by which we mean an element D P K with T Ď D Ď U, that respects all implications R Ñ S with p(R Ñ S) = J. ♦\nDomain experts are meant to “represent domains”. What wemean by this is formalized in the following definition.\n5.2 Definition Let p be a domain expert on (P(M),Ď) with background knowledge K Ď P(M). A domain for p is a set D Ď S such that we have\n• p(X Ñ Y) = J ðñ all D P D respect X Ñ Y, and\n• each partial counter-example (T,U) of p has a compatible completion D P D.\nWe say that p represents a domain if there is a domain for p. ♦\n5.3 Proposition Let p be a domain expert on (P(M),Ď) with background knowledge K Ď P(M). Then p represents a domain.\nProof For each partial counter-example (T,U) of p let D(T,U) P K be a compatible completion. Such completions exist because p is consistent with the background knowledge K. Define\nD := tD(T,U) | (T,U) a partial counter-example of p u.\nObviously, D fulfills the second condition of Definition 5.2. It remains to verify the first condition. So let X Ñ Y be an implication which is respected by all D P D. In order to show that p(X Ñ Y) = J, we assume the contrary, that p(X Ñ Y) = (T,U) for some partial counter-example (T,U). If X Ď T, then Y Ď D(T,U) Ď U, since D(T,U) respects X Ñ Y. But that contradicts the first condition of Definition 5.1, and proves that p(X Ñ Y) = J. Finally, assume that p(X Ñ Y) = J, and let D P D. We must show that D respects X Ñ Y. But that is immediate from the fact that D = D(T,U) is a compatible completion of some counter-example (T,U). l\nConversely, when we are given a set D Ď S, then we can easily obtain a domain expert pD that represents the domain D. We can do this by defining\npD(X Ñ Y) :=\n#\nJ if all elements of D respect X Ñ Y,\n(X,D) otherwise,\nwhere D is some element of D that does not respect X Ñ Y.\nProposition 5.3 sheds some light on the difference between “admissible” and “compatible” completions. According to this proposition the requirements of Definition 5.2 describe the behavior of a domain expert for some domain, but not necessarily for the system E of admissible sets that we plan to explore. Proposition 5.3 also shows that the exploration base remains consistent as long as its implications and partial examples come from a domain expert p. Obviously a domain for p is a realizer, even if the exploration is still incomplete. If p is a domain expert and X Ď P(M) is arbitrary, then there is always a largest subset Y of M such that p(X,Y) = J. This can be seen as follows: letD be a domain for p and let\ncp(X) := ľ tD P D | X Ď Du.\nThe implication X Ñ cp(X) is respected by all D P D, but for any larger element Z Ę cp(X) there is some D P D with X Ď N and Z Ę D, refuting the implication X Ñ Z. Note that cp(X) is not necessarily admissible. If tD P D | X ď Du is empty, then cp(X) is M.\nTechnically, the condition that domain experts do not give counter-examples to valid implications is not necessary. Suppose that we are given a mapping p as above that gives counter-examples to false implications and is consistent with the background knowledge. We can define a domain expert q on (P(M),Ď) such that Th(p) = Th(q) as follows:\nq(X Ñ Y) :=\n#\nJ if p(X Ñ Y) = J,\n(Th(p)(T),U) if p(X Ñ Y) = (T,U).\nThen Th(p) = Th(q). Each partial counter-example (T,U) of p for X Ñ Y has a compatible completion D satisfying\nT ď Th(p)(T) ď D ď U.\nTherefore also (Th(p)(T),U) is a counter-example toX Ñ Y. Additionally (Th(p)(T),U) cannot be a counterexample to any implication in Th(q) = Th(p), and q is consistent with K. Thus q is a domain expert on (P(M),Ď) such that Th(p) = Th(q).\nOn the other hand, the condition that a domain expert does not give counterexamples to valid implications is very intuitive and we shall keep it for this reason.\nCondition iii of Definition 5.1 seems more problematic, because it is hard to verify, actually is infeasible. This is because checking for a pair (T,U) of subsets T Ď U Ď M whether there exists a model N of the background knowledge between T and U is NP-complete: when choosing T = H and U = M, solving this problem amounts to deciding whether the background knowledge is satisfiable. From a practical point of view, however, this observation does not necessarily mean much of a problem, for two reasons:\n1. We may rely on the efficiency of modern high-performance SAT-solvers. Condition iii can easily be transformed into a propositional satisfiability problem, at least if the background knowledge is given in propositional form. What must be checked is if the background knowledge together with all validated implications has a model between T and U.\n2. In practice, the formulae for the background knowledge are usually quite simple. This is due to the fact that often they describe relations between the attributes as a result of conceptual scaling. It has been shown that a complexity measure for background knowledge can be introduced such that testing Condition iii for background knowledge of bounded complexity can be solved in polynomial time.\n5.4 Corollary For every domain expert p the set Th(p) is closed under inference.\nProof By Proposition 5.3, the expert p represents some domain D. Then\np(X Ñ Y) = J ðñ D |ù (X Ñ Y).\nLet LY tX Ñ Y u Ď Imp(M) such that L |ù (X Ñ Y) and L Ď Th(p). Then D |ù L and therefore D |ù (X Ñ Y). This means p(X Ñ Y) = J and thus (X Ñ Y) P Th(p) as required. l"
    }, {
      "heading" : "6 The exploration engine",
      "text" : "Once again, this has several parts. One is the query engine. It checks if the exploration base is complete in the sense that all implications which are not refuted by some counter-example can be inferred from the validated implications. If not, it generates a question which the domain expert is asked. Such a question always is an implication which is not refuted by any of the accepted counter-examples. However, it may happen that an implication is asked which would make the exploration base inconsistent when added. In such a case, the domain expert is forced to provide a counter-example. (To keep things simple, we do not discuss here the possibility of postponing questions.) How the query engine works is easier to explain for the case that the exploration base is normalized. The normalization engine attempts to simplify the counter-examples of the exploration base without changing the information they contain.\n• Whenever in the base there are a partial counter-example (U,V) and an implication R Ñ S such that R Ď U, then the partial counter-example is replaced by (U Y S,V).\n(Note that U Y S Ď V is implied by the consistency of the exploration base.)\n• Whenever in the base there are a partial counter-example (U,V), an element v P VzU, and an implication U Y tvu Ñ S, where S Ę V, then the example (U,V) is replaced by (U,Vztvu).\n• Whenever in the base there are counter-examples (U1,V1) and (U2,V2) such that U1 Ď U2 Ď V2 Ď V1, then (U1,V1) is removed from the base.\nObserve that for all three modifications a partial counter-example (U1,V1) is replaced by a tighter one (U2,V2), i.e., one with U1 Ď U2 Ď V2 Ď V1. And this is done in a way that necessarily each compatible completion lies in the tighter interval. Therefore normalization may make the base better focused, but does not change its expressiveness. There also is the inference engine which decides, for any suggested implication A Ñ B, if it follows from the implications in the exploration base together with the background knowledge. The inference rules are the standard ones of propositional logic. The inference engine also can compute, for any given set A Ď M, the largest set L(A) such that the implication A Ñ L(A) follows. Moreover, the inference engine may be used to streamline the implicational part of the exploration base by removing redundant implications. Again, the expressiveness of the base remains invariant. Some complexity considerations are advisable here, since implication inference under arbitrary propositional background knowledge is again an NP -complete problem. Solutions similar to the ones discussed in the previous section are possible, but a simple alternative is to disregard the background knowledge when computing the implication inference (which then is very easy). This does not produce false implications, but may fail to find certain valid ones. As a result, questions may be asked to the domain expert\nwhich in principle could be answered by the algorithm. This strategy may be limited to time-critical situations. On the other hand, if the size of background knowledge that is formulated as cumulated clauses is rather small, then implicational inference is again easy: let L = N YH be a set of clauses such that N consists of all cumulated clauses in L and H consists of all of implications in L. Then assuming N is fixed, deciding whether an implication follows from L can be done in O(|H| ¨ |M|2) steps [5]. We come back to the query engine, now for a normalized exploration base. For any set A Ď M, define\nA+? := č tV | (U,V) is a counter-example in the base such that A Ď Uu.\nNote that A+? is the largest set for which the implication\nA Ñ A+?\nis not refuted by any partial counter-example from the base. The query engine searches for a set A Ď M such that\nA = L(A) ‰ A+?.\nIf such a set is found (preferably a simple one), then the question\nA Ñ A+?\nis proposed to the domain expert. If no such set exists, then the exploration is complete. This is stated in the following theorem.\n6.1 Theorem If A = A+? holds for all sets that satisfy A = L(A), then the implications which are not refuted by partial counter-examples are precisely those that follow from implications validated by the domain expert.\nProof The implications in the exploration base, togetherwith their logical consequences, are precisely those that follow from the ones validated by the expert, since all modifications were made according to valid inferences. So we must show that these are the ones which are not refuted by any partial counter-example. Since the exploration base remains consistent during an exploration process, all such implications are respected by all partial counter-examples. Could there be an implication A Ñ B which is respected by all partial counter-examples, but which does not follow from the ones in the base? Since A Ñ L(A) follows from the base, this requires B ‰ L(A), and we may assume A = L(A), because L(A) Ñ B must also be respected by all partial counter-examples. Moreover we have B Ď A+?, since A+? is the largest set for which the implication A Ñ A+? is not refuted by any partial counter-example from the base. Putting the pieces together yields A = L(A) ‰ B Ď A+?, and therefore A = L(A) ‰ A+?. l\ndefine explore(S , p , C ) assert S is an exploration schema assert p is a domain expert for schema S assert C is a set of counter-examples for schema S"
    }, {
      "heading" : "7 Attribute exploration",
      "text" : "An attribute exploration starts with specifying an exploration schema and an initial exploration base. The latter may be empty. Then the query engine computes a question, which the domain expert answers. The answer is added to the exploration base, which then is normalized. This question-answer process is repeated until the query engine finds that the exploration base is complete. Figure 1 show a pseudo-code implementation of this algorithm. The following claim is now obvious.\n7.1 Theorem Let S be an exploration schema on some attribute set M with background knowledge K. Let p be a domain expert on M, C be a set of models of Th(p), and K Ď Th(p). Then\nL := explore(S, p, C)\nis a base of Th(p) for background knowledgeK, i.e.,\nCn(LYK) = Th(p).\nFor the special case that the background knowledge itself consists of implications (including the case of empty background knowledge) it is known that the implications validated by the domain expert constitute the so-called canonical base, and that this base is of minimal possible size. The domain expert thus has to validate as few implications as possible. It is also known that no similar result hold for the number of (partial) counterexamples: later examples may make previously given ones dispensable. Indeed, the normalization procedure for the base includes canceling partial counter-examples that contain tighter ones. An optimality result for the number of counter-examples thus is not to be expected. However, there is a unique minimal realizer, consisting of the Ş\n- irreducible models of Th(p) YK. Therefore we get the exact number of indispensable counter-examples a posteriori. We know of no strategy for the domain expert that would lead to irreducible counter-examples only."
    }, {
      "heading" : "8 Outlook",
      "text" : "The abstract formulation of attribute exploration as we have presented it in this work does not capture all properties of the classical algorithm. The main example, namely that classical attribute exploration computes the canonical base in the presence of implicational background knowledge, was briefly mentioned in the the previous section. As expert interaction can be assumed to be expensive, minimizing the number of questions asked to the expert seems inevitable for the practicability of exploration itself. One of the logical next steps in the investigation of an abstract formulation of attribute exploration is thus to examine properties of the exploration engine and the domain expert which are required to minimize the number of expert interactions. The classical algorithm already gives a possibility to implement the exploration engine such that expert interaction is minimized. In this implementation, the implications returned by the engine are enumerated in a Ď-extending order. One could now ask whether this condition is really necessary, or even sufficient for minimal expert interaction. Recent results on the parallelizability of the computation of the canonical base seem to suggest that, under some additional mild assumptions, the latter might indeed be true [7]. Another interesting perspective for future research is the comparison of attribute exploration with the query learning algorithm for propositional Horn logic from [1]. It is not completely obvious that those two algorithm indeed accomplish the same. However, it is known that the algorithm from [1] computes the canonical base not matter what the form of the particular choice of the examples given by the involved oracles [2]. This is very similar to the classical attribute exploration algorithm with complete counterexamples, where the particular choice of the counterexamples given by the expert does not have an impact on the form of the computed base. This suggest that there\nmight be a deeper connection between attribute exploration and query learning, and it may be worth discovering this connection for the benefit of both approaches."
    } ],
    "references" : [ {
      "title" : "Learning Conjunctions of Horn Clauses",
      "author" : [ "Dana Angluin", "Michael Frazier", "Leonard Pitt" ],
      "venue" : "In:Machine Learning",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1992
    }, {
      "title" : "Construction and learnability of canonical Horn formulas",
      "author" : [ "Marta Arias", "José L. Balcázar" ],
      "venue" : "In:Machine Learning",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2011
    }, {
      "title" : "Completing Description Logic Knowledge Bases Using Formal Concept Analysis",
      "author" : [ "Franz Baader" ],
      "venue" : "(Hyderabad, India)",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2007
    }, {
      "title" : "Exploring Faulty Data",
      "author" : [ "Daniel Borchmann" ],
      "venue" : "ICFCA",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "Pseudo-models and propositional Horn inference",
      "author" : [ "Bernhard Ganter", "Rüdiger Krauße" ],
      "venue" : "Discrete Applied Mathematics",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2005
    }, {
      "title" : "Formal Concept Analysis: Mathematical Foundations",
      "author" : [ "Bernhard Ganter", "Rudolf Wille" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1999
    }, {
      "title" : "NextClosures: Parallel Computation of the Canonical Base",
      "author" : [ "Francesco Kriegel", "Daniel Borchmann" ],
      "venue" : "Proceedings of the 12th International Conference on Concept Lattices and their Applications (CLA",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "Attribute Exploration is a fairly well-known andwell-tried knowledge acquisition technique based on Formal Concept Analysis [6].",
      "startOffset" : 124,
      "endOffset" : 127
    }, {
      "referenceID" : 0,
      "context" : "It is similar to Query Learning, as described in [1].",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 2,
      "context" : "The aim of this paper is not to add yet another generalization, but to present an abstract version of one of the more basic variants, namely attribute exploration with partial object descriptions [3].",
      "startOffset" : 196,
      "endOffset" : 199
    }, {
      "referenceID" : 3,
      "context" : "For this we shall make use of the formalization of a domain expert, as developed by the first author [4].",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 4,
      "context" : "Then assuming N is fixed, deciding whether an implication follows from L can be done in O(|H|  ̈ |M|) steps [5].",
      "startOffset" : 108,
      "endOffset" : 111
    }, {
      "referenceID" : 6,
      "context" : "Recent results on the parallelizability of the computation of the canonical base seem to suggest that, under some additional mild assumptions, the latter might indeed be true [7].",
      "startOffset" : 175,
      "endOffset" : 178
    }, {
      "referenceID" : 0,
      "context" : "Another interesting perspective for future research is the comparison of attribute exploration with the query learning algorithm for propositional Horn logic from [1].",
      "startOffset" : 163,
      "endOffset" : 166
    }, {
      "referenceID" : 0,
      "context" : "However, it is known that the algorithm from [1] computes the canonical base not matter what the form of the particular choice of the examples given by the involved oracles [2].",
      "startOffset" : 45,
      "endOffset" : 48
    }, {
      "referenceID" : 1,
      "context" : "However, it is known that the algorithm from [1] computes the canonical base not matter what the form of the particular choice of the examples given by the involved oracles [2].",
      "startOffset" : 173,
      "endOffset" : 176
    } ],
    "year" : 2015,
    "abstractText" : "Attribute exploration has been investigated in several studies, with particular emphasis on the algorithmic aspects of this knowledge acquisition method. In its basic version the method itself is rather simple and transparent. But when background knowledge and partially described counterexamples are admitted, it gets more difficult. Here we discuss this case in an abstract, somewhat “axiomatic” setting, providing a terminology that clarifies the abstract strategy of the method rather than its algorithmic implementation.",
    "creator" : "LaTeX with hyperref package"
  }
}