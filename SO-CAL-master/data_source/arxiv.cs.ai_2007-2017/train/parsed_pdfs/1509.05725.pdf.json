{
  "name" : "1509.05725.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Backdoors into Heterogeneous Classes of SAT and CSP",
    "authors" : [ "Serge Gaspers", "Neeldhara Misra", "Sebastian Ordyniak", "Stefan Szeider" ],
    "emails" : [ "(sergeg@cse.unsw.edu.au)", "(mail@neeldhara.com)", "(sordyniak@gmail.com,", "stefan@szeider.net)", "(standa.zivny@cs.ox.ac.uk)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 9.\n05 72\n5v 1\n[ cs\n.A I]\n1 8\nSe p"
    }, {
      "heading" : "1 Introduction",
      "text" : "Backdoors are small sets of variables of a SAT or CSP instance that represent “clever reasoning shortcuts” through the search space. Backdoor sets were originally introduced by Williams, Gomes, and Selman ([28, 29]) as a tool for the analysis of decision heuristics in propositional satisfiability. Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19]. A backdoor set is defined with respect to some fixed base class for which the computational problem under consideration is polynomial-time tractable (alternatively, it can be defined with respect to a polynomial-time subsolver). The size of the backdoor set can be seen as a distance measure that indicates how far the instance is from the target class. One distinguishes between strong and weak backdoor sets; the latter applies only to satisfiable instances. Once a strong backdoor set of size k is identified, one can decide the satisfiability of the instance by deciding the satisfiability of at most dk “easy” instances that belong to the tractable base class, where d denotes the size of the domain for the variables; for SAT we have d = 2. Each of the easy instances is obtained by one of the dk possible instantiations of the k variables in the backdoor set. Hence, the satisfiability check is fixed-parameter tractable for the combined parameter backdoor size and domain size (k + d). A similar approach works for weak backdoor sets, where the computation of a certificate for satisfiability (i.e., a satisfying assignment) is fixed-parameter tractable for the combined parameter (k + d).\nThe fixed-parameter tractability of using the backdoor set for deciding satisfiability or the computation of a certificate for satisfiability triggers the question of whether finding a backdoor set of size at most k is also fixed-parameter tractable. In particular, for every base class C one can ask whether the detection of a strong or weak backdoor set into C of size at most k is fixed-parameter tractable for parameter k (possibly in combination with restrictions on the input or other parameters). A systematic study of the parameterized complexity of backdoor set detection was initiated by Nishimura et al. [21] for SAT, who showed that the detection of strong backdoor sets into the classes HORN and 2CNF is fixed-parameter tractable, but the detection of weak backdoor sets into any of these two classes is W[2]-hard (and hence unlikely to be fixed-parameter tractable). Since then, the parameterized complexity of backdoor set detection has become an active research topic as outlined in a survey [12].\nIn this work, we provide two significant extensions to the exciting research on fixed-parameter tractable backdoor set detection. First, we introduce heterogeneous base classes, which can be composed of several homogeneous base classes. We show that heterogeneous base classes are particularly well-suited for strong backdoor sets, since they allow that different instantiations of the backdoor variables result in instances that belong to different base classes, which leads to arbitrary reductions in the size of a strong backdoor set even compared to the smallest strong backdoor set for each individual homogeneous base class. This is in contrast to weak backdoor sets, where the size of a weak backdoor set into a heterogeneous base class is equal to the size of the smallest backdoor set into any of the individual base classes. Here we show that also the complexity of weak backdoor set detection into heterogeneous base classes is tight to its complexity on the individual base classes. Second, we extend the scope of backdoor set detection from SAT to CSP, considering target classes that are defined by tractable constraint languages in terms of certain closure properties under polymorphisms.\nHeterogeneous Base Classes Consider the following SAT instance Fn = {C,D1, . . . , Dn} where C = (x ∨ ¬a1 ∨ · · · ∨ ¬an) and Di = (¬x ∨ bi ∨ ci). It is easy to see that any strong backdoor set into HORN needs to contain at least one of the variables bi or ci from each clause Di, hence such a backdoor set must be of size Ω(n); on the other hand, any strong backdoor set into 2CNF must contain at least (n − 2) variables from the clause C; hence such a backdoor must be of size at Ω(n) as well. However, Fn[x = false] is Horn, and Fn[x = true] is a 2CNF, hence the singleton {x} constitutes a strong backdoor set into the “heterogeneous” base class HORN∪2CNF. This example shows that by considering heterogeneous base classes we can access structural properties of instances that are not accessible by backdoor sets into homogeneous base classes. Identifying a base class with a class of instances that are solvable by a particular polynomial-time subsolver, one can consider a heterogeneous base class as a “portfolio subsolver,” where for each instance the best suitable subsolver from the portfolio is chosen.\nSAT Backdoor Sets A natural question at this point is whether the fixed-parameter tractability results for the detection of strong backdoor sets into individual base classes can be extended to more powerful heterogeneous base classes. In this work, we completely characterize the complexity landscape for heterogeneous base classes obtained arbitrary combinations of the well-known Schaefer classes [26], in the following denoted by HORN (for Horn formulas), HORN− (for Anti-Horn formulas), 2CNF (for 2-CNF formulas), 0-VAL (for zero valid formulas), and 1-VAL (for one valid formulas). To state the classification, we briefly introduce some terminology. We say that a pair (C, C′) of Schaefer classes is a bad pair if C ∈ {HORN, 0-VAL} and C′ ∈ {HORN−, 1-VAL}.\nLet C be a class of CNF-formulas such that C = ⋃\ns∈S s for some subset S of the Schaefer classes. Our main result for SAT backdoor sets (Theorem 5) is that Strong C-Backdoor Detection is fixed parameter tractable if and only if S does not contain a bad pair of Schaefer classes, otherwise it is W[2]-hard. On the other hand, detecting weak backdoors is always W[2]-hard for any choice of C, and we show this by building on the known hardness results for when C is a singleton set (Theorem 7).\nWe also show that Strong C-Backdoor Detection as well as Weak C-Backdoor Detection are fixed-parameter tractable for the combined parameter k and the maximum length r of a clause of the input formula (Theorem 6 and 8). These FPT algorithms formalize the intuition that all the hardness results in the previous classification result exploit clauses of unbounded length.\nCSP Backdoor Sets The identification of tractable classes of CSP instances has been subject of extensive studies. A prominent line of research, initiated by Schaefer [26] in his seminal paper on Boolean CSP, is to identify tractable classes by restricting the relations that may appear in constraints to a prescribed set, a constraint language. Today, many constraint languages have been identified that give rise to tractable classes of CSPs [2, 4, 14]; typically such languages are defined in terms of certain closure properties, which ensure that the relations are closed under pointwise application of certain polymorphisms of the domain. For instance, consider a CSP instance whose relations are closed under a constant function f(x) = d for some d ∈ D (such a function is a polymorphism of the relations in the instance). Then note that every relation is either empty or forced to contain the tuple 〈d, d, . . . , d〉. Thus, given a particular instance, we may either declare it unsatisfiable (if it contains a constraint\nover the empty relation), or satisfy it trivially by setting every variable to d. Further examples of polymorphisms for which closure properties yield tractable CSP are min, max, majority, affine, and Mal’cev polymorphisms [1, 15].\nWe study the problem of finding strong and weak backdoor sets into tractable classes of CSP instances defined by certain polymorphisms. Our main result for CSP backdoors (Theorem 9) establishes fixedparameter tractability for a wide range of such base classes. In particular, we show that the detection of strong and weak backdoor sets is fixed-parameter tractable for the combined parameter backdoor size, domain size, and the maximum arity of constraints. In fact, this result entails heterogeneous base classes, as different instantiations of the backdoor variables can lead to reduced instances that are closed under different polymorphisms (even polymorphisms of different type). We complement our main result with hardness results that show that we loose fixed-parameter tractability when we omit either domain size or the maximum arity of constraints from the parameter (Theorems 11 and 12). Hence, Theorem 9 is tight in a certain sense.\nRelated Work Recently, two papers dealing with strong backdoor set detection for the constraint satisfaction problem have appeared [5, 11], which nicely supplement (however are mostly orthogonal to) the results in this paper. Carbonnel et al. [5] show W[2]-hardness for strong backdoor set detection parameterized by the size of the backdoor set even for CSP-instances with only one constraint (however with unbounded domain and unbounded arity). They also give a fixed-parameter algorithm for strong backdoor set detection parameterized by the size of the backdoor set and the maximum arity of any constraint, if the base class is “h-Helly” for any fixed integer h and under the additional assumption that the domain is a finite subset of the natural numbers, which comes with a fixed ordering. However, as is also mentioned in Carbonnel and Cooper [6], the “h-Helly” property is rather restrictive and orthogonal to our approach of considering the domain as an additional parameter.\nGanian et al. [11] show fixed-parameter tractability of strong backdoor detection parameterized by the size of the backdoor to a very general family of heterogeneous base classes, i.e., base classes defined as all CSP-instances obtained from the disjoint union of tractable, finite, and semi-conservative constraint languages. These base classes are orthogonal to the base classes considered in this paper. They are more general in the sense that their allow for the CSP-instance to consists of the disjoint union of different tractable classes, and they are more specific in the sense that they only consider finite and semi-conservative constraint languages, which also restricts the CSP-instances to bounded domain and bounded arity."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "SAT A literal is a propositional variable x or a negated variable ¬x. We also use the notation x = x1 and ¬x = x0. A clause is a finite set of literals that does not contain a complementary pair x and ¬x. A propositional formula in conjunctive normal form, or CNF formula for short, is a set of clauses. For a clause C we write var(C) = { x : x ∈ C or ¬x ∈ C }, and for a CNF formula F we write var(F ) = ⋃\nC∈F var(C). For a set X of propositional variables we denote by X → {0, 1} the set of all mappings from X to {0, 1}, the truth assignments on X . We denote by X the set of literals corresponding to the negated variables of X . For τ : X → {0, 1} we let true(τ) = { xτ(x) : x ∈ X } and false(τ) = { x1−τ(x) : x ∈ X } be the sets of literals set by τ to 1 and 0, respectively. Given a CNF formula F and a truth assignment τ : X → {0, 1} we define F [τ ] = {C \\ false(τ) : C ∈ F, C ∩ true(τ) = ∅ }. If τ : {x} → {0, 1} and ǫ = τ(x), we simply write F [x = ǫ] instead of F [τ ].\nA CNF formula F is satisfiable if there is some τ : var(F ) → {0, 1} with F [τ ] = ∅, otherwise F is unsatisfiable.\nCSP Let D be a set and n and n′ be natural numbers. An n-ary relation on D is a subset of Dn. For a tuple t ∈ Dn, we denote by t[i], the i-th entry of t, where 1 ≤ i ≤ n. For two tuples t ∈ Dn and t′ ∈ Dn ′ , we denote by t ◦ t′, the concatenation of t and t′.\nAn instance of a constraint satisfaction problem (CSP) I is a triple 〈V,D,C〉, where V is a finite set of variables over a finite set (domain) D, and C is a set of constraints. A constraint c ∈ C consists of a scope, denoted by V (c), which is an ordered list of a subset of V , and a relation, denoted by R(c), which is a |V (c)|-ary relation on D. To simplify notation, we sometimes treat ordered lists without repetitions, such as the scope of a constraint, like sets. For a variable v ∈ V (c) and a tuple t ∈ R(c), we denote by t[v], the i-th entry of t, where i is the position of v in V (c). For a CSP instance I = 〈V,D,C〉 we sometimes denote by V (I), D(I), C(I), and δ(I), its set of variables V , its domain D, its set of constraints C, and the maximum arity of any constraint of I, respectively.\nLet V ′ ⊆ V and τ : V ′ → D. For a constraint c ∈ C, we denote by c[τ ], the constraint whose scope is V (c) \\ V ′ and whose relation contains all |V (c[τ ])|-ary tuples t such that there is a |V (c)|-ary tuple t′ ∈ R(c) with t[v] = t′[v] for every v ∈ V (c[τ ]) and t′[v] = τ(v) for every v ∈ V ′. We denote by I[τ ] the CSP instance with variables V \\ V ′, domain D, and constraints C[τ ], where C[τ ] contains a constraint c[τ ] for every c ∈ C.\nA solution to a CSP instance I is a mapping τ : V → D such that 〈τ [v1], . . . , τ [v|V (c)|]〉 ∈ R(c) for every c ∈ C with V (c) = 〈v1, . . . , v|V (c)|〉.\nBackdoors Backdoors are defined relative to some fixed class C of instances of the problem under consideration (i.e., SAT or CSP). One usually assumes that the problem is tractable for instances from C, as well as that the recognition of C is tractable.\nIn the context of SAT, we define a strong C-backdoor set of a CNF formula F to be a set B of variables such that F [τ ] ∈ C for each τ : B → {0, 1}. A weak C-backdoor set of F is a set B of variables such that F [τ ] is satisfiable and F [τ ] ∈ C holds for some τ : B → {0, 1}. If we know a strong C-backdoor set of F , we can decide the satisfiability of F by checking the satisfiability of 2k “easy” formulas F [τ ] that belong to C. Thus SAT decision is fixed-parameter tractable in the size k of the backdoor. Similarly, in the context of CSP, we define a strong C-backdoor set of a CSP instance I = 〈V,D,C〉 as a set B of variables such that I[τ ] ∈ C for every τ : B → D. We also call a strong C-backdoor a strong backdoor set into C. A weak C-backdoor set of I is a set B of variables such that I[τ ] is satisfiable and I[τ ] ∈ C holds for some τ : B → D. If we know a strong C-backdoor set of I of size k, we can reduce the satisfiability of I to the satisfiability of dk CSP instances in C where d = |D|. Thus deciding the satisfiability of a CSP instance is fixed-parameter tractable in the combined parameter d+ k.\nThe challenging problem is—for SAT and for CSP—to find a strong, or weak C-backdoor set of size at most k if one exists.\nFor each class C of SAT or CSP instances, we define the following problem.\nStrong C-Backdoor Detection Input: A SAT or CSP instance I and a nonnegative integer k. Question: Does I have a strong C-backdoor set of size at most k?\nThe problem Weak C-Backdoor Detection is defined similarly.\nParameterized Complexity We provide basic definitions of parameterized complexity; for an indepth treatment we refer to the recent monograph [9]. A problem is parameterized if each problem instance I is associated with a nonnegative integer k, the parameter. A parameterized problem is fixed-parameter tractable (or FPT, for short) if there is an algorithm, A, a constant c, and a computable function f , such that A solves instances of input size n and parameter k in time f(k)nc. Fixed-parameter tractability extends the conventional notion of polynomial-time tractability, the latter being the special case where f is a polynomial. The so-called Weft-hierarchy W[1] ⊆ W[2] ⊆ . . . contains classes of parameterized decision problems that are presumed to be larger than FPT. It is believed that problems that are hard for any of the classes in the Weft-hierarchy are not fixed-parameter tractable. The classes are closed under fpt-reductions that are fixed-parameter tractable many-one reductions, which map an instance x with parameter k of one problem to a decision-equivalent instance x′ with parameter k′ of another problem, where k′ ≤ f(k) for some computable function f .\nFor instance, the following problem is well-known to be W[2]-complete [9].\nHitting Set Parameter: k Input: A set system F over a family U , and a positive integer k Question: Is there a subset of the universe, X ⊆ U , with |X | ≤ k such that every set S ∈ F contains at least one element from X?"
    }, {
      "heading" : "3 Backdoor Detection for SAT",
      "text" : "Schaefer’s base classes [26] give rise to classes of CNF formulas defined in terms of syntactical properties of clauses.1\nA clause is\n• Horn if it contains at most one positive literal,\n• Anti-Horn if it contains at most one negative literal,\n• 2CNF if it contains at most two literals,2\n• 0-valid if it contains at least one negative literal, and\n• 1-valid if it contains at least one positive literal.\nA CNF formula is Horn, Anti-Horn, etc. if it contains only Horn, Anti-Horn, etc. clauses. We denote the respective classes of CNF formulas by HORN, HORN−, 2CNF, 0-VAL, and 1-VAL."
    }, {
      "heading" : "3.1 Strong Backdoor Sets",
      "text" : "Strong C-Backdoor Detection is polynomial for 0-VAL and 1-VAL, and FPT for the remaining Schaefer classes [12, 21]. These FPT algorithms are based on constant-size obstruction sets. For a clause c, we say that a set X of variables is a C-obstruction for c if {(X∪X)∩c} /∈ C and {(X∪X)∩c\\{l}} ∈ C for all literals l ∈ c. A HORN-obstruction contains two variables occurring positively in the clause, a HORN−-obstruction contains two variables occurring negatively in the clause, and a 2CNF-obstruction contains three variables occurring positively or negatively in the clause. It is well-known that, for C ∈ {HORN,HORN−, 2CNF}, every strong C-backdoor set contains a variable from each C-obstruction for each clause in the formula [12, 21]. In this section, we focus on algorithms for finding strong backdoors into heterogeneous base classes. These algorithms also use these obstruction sets for branching, but the heterogeneity of the base class makes it significantly more challenging to design the FPT algorithms.\nThe results in this subsection are as follows. First, in Theorem 1, we show that if C ∈ Schaefer, Strong 2CNF∪C-Backdoor Detection is fixed-parameter tractable for parameter k. In Theorem 2, we show that Strong HORN∪ 0-VAL-Backdoor Detection and Strong HORN− ∪ 1-VAL-Backdoor Detection are fixed-parameter tractable for parameter k. Finally, in Theorem 3, we show that Strong 2CNF∪HORN∪0-VAL-Backdoor Detection and Strong 2CNF∪HORN−∪1-VAL-Backdoor Detection are fixed-parameter tractable for parameter k. In contrast, Theorem 4 captures a condition for hardness of the strong backdoor detection problem, which is complementary to all the cases in the first three results. Together, and combined with known results in the literature, these theorems give us a complete complexity classification, which is summarized in Theorem 5.\nOur hardness results rely on the fact that the clauses have unbounded length. Theorem 6 shows that if we consider the maximum length of any clause as an additional parameter, then the problem of finding a strong heterogeneous backdoor becomes fixed-parameter tractable for any combination of the Schaefer classes.\nOur first tractability result is for Strong 2CNF ∪ C-Backdoor Detection, where C ∈ Schaefer. Before formally stating the algorithm, we provide a brief intuition for the branching rules. Typically, we branch on an obstructing clause (or a pair of obstructing clauses), a situation that occurs in one of two flavors:\n1Affine Boolean formulas considered by Schaefer do not correspond naturally to a class of CNF formulas, hence we do not consider them here. However, we do consider the affine case in the context of Boolean CSPs; cf. Theorem 11.\n2A clause containing exactly two literals is also known as a Krom clause [16].\n(1) Either there is a clause C that is not in 2CNF ∪ C, or,\n(2) there is a pair of clauses C and C′, where C ∈ 2CNF \\ C and C′ ∈ C \\ 2CNF.\nConsider the case when C = 0-VAL. In scenario (1), the formula has a clause C of length at least three with only positive literals. If this clause has more than k + 2 literals, then there is no strong backdoor of size k to 0-VAL ∪ 2CNF. Otherwise, the clause has at most k + 2 literals on which we can branch exhaustively. In scenario (2), we know that C has at most two literals and any strong backdoor set that does not contain a variable form C must reduce C′ to a clause with at most two literals. Hence, we can branch on the variables in C and any subset of three variables in C′.\nConsider the case when C = HORN. In scenario (1) above, the formula has a clause C of length at least three with at least two positive literals, say x and y. Let ℓ be any other literal in C. It is clear that any strong backdoor set must contain one of x, y or ℓ, and we branch accordingly. In scenario (2), we know that C has at most two literals and C′ contains at least two positive literals. Because every strong backdoor set that does not contain a variable form C must reduce C′ to a clause with at most two literals, we can branch on the variables in C and any subset of three variables in C′.\nThe intuitive explanations for 1-VAL and HORN− are analogous. Note that the criteria described above need to be refined further at internal nodes of the branching process. We now turn to a formal description of the algorithm, proof of correctness, and running time.\nTheorem 1. Let C ∈ Schaefer. Then, Strong (2CNF∪C)-Backdoor Detection is fixed-parameter tractable for parameter k.\nProof. The algorithm uses a depth-bounded search tree approach to find a strong 2CNF ∪ C-backdoor set of size at most k. Let F be any CNF-formula with variables V .\nWe construct a search tree T , for which every node is labeled by a set B of at most k variables of V . Additionally, every leaf node has a second label, which is either Yes or No. T is defined inductively as follows. The root of T is labeled by the empty set. Furthermore, if t is a node of T , whose first label is B, then the children of t in T are obtained as follows. If for every assignment τ : B → {0, 1}, F [τ ] ∈ 2CNF ∪ C, then B is a strong 2CNF ∪ C-backdoor set of size at most k, and hence t becomes a leaf node, whose second label is Yes. Otherwise, i.e., if there is an assignment τ : B → {0, 1} such that F [τ ] /∈ 2CNF ∪ C, we consider two cases:\n1. |B| = k, then t becomes a leaf node, whose second label is No,\n2. otherwise, i.e., if |B| < k, then we again distinguish two cases:\n(a) there is a clause C ∈ F [τ ] with C /∈ 2CNF ∪ C, then we again distinguish two cases:\ni. if C ∈ {HORN,HORN−}, then let O be a subset of C with |O| = 3 and O /∈ C. Then, for every v in var(O), t has a child whose first label is B ∪ {v}.\nii. if C ∈ {1-VAL, 0-VAL}, then we again distinguish two cases:\nA. |B|+ |C| − 2 > k, then t becomes a leaf node, whose second label is No,\nB. otherwise, i.e., if |B|+ |C| − 2 ≤ k, then for every two element subset O of C, t has a child whose first label is B ∪ var(C \\O).\n(b) otherwise, there is a clause C in F [τ ] with C ∈ 2CNF \\ C and a clause C′ in F [τ ] with C′ ∈ C \\ 2CNF. Let O be the set of variables containing the (at most) two variables from C plus any three element subset of variables from C′. Then, for every v in O, t has a child whose first label is B ∪ {v}.\nIf T has a leaf node, whose second label is Yes, then the algorithm returns the first label of that leaf node. Otherwise the algorithm returns No. This completes the description of the algorithm.\nWe now show the correctness of the algorithm. First, suppose the search tree T built by the algorithm has a leaf node t whose second label is Yes. Here, the algorithm returns the first label, say B of t. By definition of T , we obtain that |B| ≤ k and for every assignment τ : B → {0, 1}, it holds that F [τ ] ∈ 2CNF ∪ C, as required.\nNow consider the case where the algorithm returns No. We need to show that there is no set B of at most k variables of F such that F [τ ] ∈ 2CNF∪C for every assignment τ of the variables of B. Assume, for the sake of contradiction that such a set B exists.\nObserve that if T has a leaf node t whose first label is a set B′ with B′ ⊆ B, then the second label of t must be Yes. Assume for a contradiction that this is not the case, then either case (1) or case (2.a.ii.A) applied for t. In the former case B′ is not a strong 2CNF ∪ C-backdoor set for F and |B′| = k. Hence, B = B′ contradicting our assumption that B is a strong 2CNF ∪ C-backdoor set for F . In the later case, we obtain that there is an assignment τ : B′ → {0, 1} and a clause C ∈ F [τ ] such that (1) C /∈ 2CNF ∪ C, (2) C ∈ {0-VAL, 1-VAL} and (3) |B′| + |C| − 2 > k. It follows from (3) that B misses at least 3 literals from C. Hence, there is an assignment τ ′ that is compatible with τ such that F [τ ′] contains a clause C′ ⊆ C with |C′| > 2. Hence, C′ /∈ 2CNF and because C′ ⊆ C, we obtain from (1) and (2) that C′ /∈ C. Hence, C′ /∈ 2CNF ∪ C, contradicting our assumption that B is a strong 2CNF ∪ C-backdoor set for F .\nIt hence remains to show that T has a leaf node whose first label is a set B′ with B′ ⊆ B. This will complete the proof about the correctness of the algorithm. We will show a slightly stronger statement, namely, that for every natural number ℓ, either T has a leaf whose first label is contained in B or T has an inner node of distance exactly ℓ from the root whose first label is contained in B. We show the latter by induction on ℓ.\nThe claim obviously holds for ℓ = 0. So assume that T contains a node t at distance ℓ from the root of T whose first label, say B′, is a subset of B. If t is a leaf node of T , then the claim is shown. Otherwise, there is an assignment τ : B′ → {0, 1} such that F [τ ] /∈ 2CNF ∪ C and one of the cases (2.a.i), (2.a.ii.B), and (2.b) applies to t.\n(2.a.i) In this case there is a clause C ∈ F [τ ] with C /∈ 2CNF ∪ C, C ∈ {HORN,HORN−} and a set of three literals O ⊆ C with O /∈ C such that t has one child whose first label is B′ ∪ {v} for every v ∈ var(O). It remains to show that B ∩ var(O) 6= ∅. Assume not, and let τ∗ : B → {0, 1} be an assignment compatible with τ that does not satisfy any literal of C. Then, F [τ∗] contains a superset of O as a clause and hence F [τ∗] /∈ 2CNF ∪ C.\n(2.a.ii.B) In this case there is a clause C ∈ F [τ ] with C /∈ 2CNF ∪ C, C ∈ {1-VAL, 1-VAL} and t has one child whose first label is B′cupvar(C \\O) for every two element subset O of C. It remains to show that |var(C) \\ B| ≤ 2. Assume not, and let τ∗ : B → {0, 1} be an assignment compatible with τ that does not satisfy any literal of C. Then, C[τ∗] ∈ F [τ∗] and because |C[τ∗]| > 2 and C[τ∗] /∈ C, also F [τ∗] /∈ 2CNF ∪ C.\n2.b In this case there is a clause C in F [τ ] with C ∈ 2CNF\\C and a clause C′ in F [τ ] with C ∈ C\\2CNF and a set O of variables containing all variables from C a subset of variables of C′ such that t has one child whose first label is B′ ∪ {v} for every v ∈ O. It remains to show that B ∩ var(O) 6= ∅. Assume not, and let τ∗ : B → {0, 1} be an assignment compatible with τ that does not satisfy any literal of C′. Then, F [τ∗] contains the clause C together with a subclause C′′ of C′ containing at least three literals. Because C /∈ C and C′′ /∈ 2CNF, we obtain that F [τ∗] /∈ 2CNF ∪ C.\nThis concludes our proof concerning the correctness of the algorithm. The running time of the algorithm is obtained as follows. Let T be a search tree obtained by the algorithm. Then the running time of the depth-bounded search tree algorithm is O(|V (T )|) times the maximum time that is spend on any node of T . According to the three branching rules given in (2.a.i), (2.a.ii.B), and (2.b) we obtain that |V (T )| can be bounded by the maximum of the following recurrence relations: (1) T (k) = 3T (k − 1) (2.a.i), (2) T (k) = r2T (k − (r − 2)) for any r > 2 (2.a.ii.B), and (3) T (k) = 5T (k − 1) (2.b). In case of (1) T (k) is at most 3k, in case of (2) the maximum of 9k is obtained for T (k) by setting r = 3, and in case of (3) T (k) is at most 5k. It follows that |V (T )| ≤ 9k. Furthermore, the time required for any node t of T is at most O(2k|F |). Putting everything together, we obtain O(9k2k|F |) = O(18k|F |), as the total running time of the algorithm. This shows that Strong 2CNF ∪ HORN-Backdoor Detection is fixed-parameter tractable parameterized by k.\nWe now turn to the case when the base classes are either HORN ∪ 0-VAL or HORN− ∪ 1-VAL.\nAs before, in scenario (1), the length of an obstructing clause must be bounded in a Yes-instance. Indeed, consider a clause C that is not in HORN ∪ 0-VAL. Such a clause has only positive literals, and any strong backdoor must contain all these literals but one. Therefore, if the clause has more than k + 1 literals, we reject the instance, otherwise the clause length is bounded, allowing for a bounded branching strategy.\nIn scenario (2), on the other hand, we have a pair of obstructing clauses, say C ∈ HORN \\ 0-VAL, and C′ ∈ 0-VAL\\HORN. Now, note that C can have only one literal by definition. Let O be any subset of two positive literals from C′. Note that any strong backdoor must intersect either O or the unique literal in C, which again leads us to a feasible branching step. We now turn to a formal description of the algorithm.\nTheorem 2. Strong HORN∪0-VAL-Backdoor Detection and Strong HORN−∪1-VAL-Backdoor Detection are fixed-parameter tractable for parameter k.\nProof. We only give the proof for the class HORN∪ 0-VAL, as the proof for the class HORN− ∪ 1-VAL is analogous. The algorithm uses a depth-bounded search tree approach to find a strong 2CNF∪0-VALbackdoor set of size at most k. Let F be any CNF-formula with variables V .\nWe construct a search tree T , for which every node is labeled by a set B of at most k variables of V . Additionally, every leaf node has a second label, which is either Yes or No. T is defined inductively as follows. The root of T is labeled by the empty set. Furthermore, if t is a node of T , whose first label is B, then the children of t in T are obtained as follows. If for every assignment τ : B → {0, 1}, F [τ ] ∈ HORN ∪ 0-VAL, then B is a strong HORN ∪ 0-VAL-backdoor set of size at most k, and hence t becomes a leaf node, whose second label is Yes. Otherwise, i.e., if there is an assignment τ : B → {0, 1} such that F [τ ] /∈ HORN ∪ 0-VAL, we consider two cases:\n1. |B| = k, then t becomes a leaf node, whose second label is No,\n2. otherwise, i.e., if |B| < k, then we again distinguish two cases:\n(a) there is a clause C ∈ F [τ ] with C /∈ HORN ∪ 0-VAL, then we again distinguish two cases:\ni. |B|+ |C| − 1 > k, then t becomes a leaf node, whose second label is No,\nii. otherwise, i.e., if |B| + |C| − 1 ≤ k, then for every variable v of C, t has a child whose first label is B ∪ (var(C) \\ {v}).\n(b) otherwise, there is a clause C in F [τ ] with C ∈ HORN \\ 0-VAL and a clause C′ in F [τ ] with C ∈ 0-VAL \\ HORN. Let O be the set of variables containing the one variable from C plus any two variables corresponding to two positive literals from C′. Then, for every v in O, t has a child whose first label is B ∪ {v}.\nIf T has a leaf node, whose second label is Yes, then the algorithm returns the first label of that leaf node. Otherwise the algorithm returns No. This completes the description of the algorithm.\nWe now show the correctness of the algorithm. First, suppose the search tree T built by the algorithm has a leaf node t whose second label is Yes. Here, the algorithm returns the first label, say B of t. By definition of T , we obtain that |B| ≤ k and for every assignment τ : B → {0, 1}, it holds that F [τ ] ∈ HORN ∪ 0-VAL, as required.\nNow consider the case where the algorithm returns No. We need to show that there is no set B of at most k variables of F such that F [τ ] ∈ HORN ∪ 0-VAL for every assignment τ of the variables of B. Assume, for the sake of contradiction that such a set B exists.\nObserve that if T has a leaf node t whose first label is a set B′ with B′ ⊆ B, then the second label of t must be Yes. Assume for a contradiction that this is not the case, then either case (1) or case (2.a.i) applied for t. In the former case |B′| = k and hence B = B′ and B′ is not a strong HORN ∪ 0-VALbackdoor set for F , contradicting our assumption that B is a strong HORN ∪ 0-VAL-backdoor set for F . In the later case, we obtain that there is an assignment τ : B′ → {0, 1} and a clause C ∈ F [τ ] with C /∈ HORN ∪ 0-VAL such that |B′| + |C| − 1 > k. Hence, B misses at least 2 literals from C. Consequently, for any assignment τ ′ : B → {0, 1} that is compatible with τ and does not satisfy any literal from C, F [τ ′] contains a subclause of C that contains at least 2 literals. It follows that\nF [τ ′] /∈ HORN∪ 0-VAL, contradicting our assumption that B is a strong HORN ∪ 0-VAL-backdoor set for F .\nIt hence remains to show that T has a leaf node whose first label is a set B′ with B′ ⊆ B. This will complete the proof about the correctness of the algorithm. We will show a slightly stronger statement, namely, that for every natural number ℓ, either T has a leaf whose first label is contained in B or T has an inner node of distance exactly ℓ from the root whose first label is contained in B. We show the latter by induction on ℓ.\nThe claim obviously holds for ℓ = 0. So assume that T contains a node t at distance ℓ from the root of T whose first label, say B′, is a subset of B. If t is a leaf node of T , then the claim is shown. Otherwise, there is an assignment τ : B′ → {0, 1} such that F [τ ] /∈ HORN∪ 0-VAL and one of the cases (2.a.ii) and (2.b) applies to t.\n(2.a.ii) In this case there is a clause C ∈ F [τ ] with C /∈ HORN∪0-VAL and t has one child whose first label isB′∪(var(C)\\{v}) for every variable v ∈ var(C). It remains to show that |var(C)\\B| ≤ 1. Assume not, and let τ∗ : B → {0, 1} be an assignment compatible with τ that does not satisfy any literal of C. Then, C[τ∗] ∈ F [τ∗] and because |C[τ∗]| > 1 and C[τ∗] /∈ 0-VAL, also F [τ∗] /∈ HORN∪0-VAL.\n(2.b) In this case there is a clause C in F [τ ] with C ∈ HORN \\ 0-VAL and a clause C′ in F [τ ] with C ∈ 0-VAL \\ HORN and a set O of variables containing all variables from C and a subset of two variables from C′ that correspond to two positive literals such that t has one child whose first label is B′ ∪ {v} for every v ∈ O. It remains to show that B ∩ O 6= ∅. Assume not, and let τ∗ : B → {0, 1} be an assignment compatible with τ that does not satisfy any literal of C′. Then, F [τ∗] contains the clause C together with a subclause C′′ of C′ containing at least two positive literals. Because C /∈ 0-VAL and C′′ /∈ HORN, we obtain that F [τ∗] /∈ 2CNF ∪ C.\nThis concludes our proof concerning the correctness of the algorithm. The running time of the algorithm is obtained as follows. Let T be a search tree obtained by the algorithm. Then the running time of the depth-bounded search tree algorithm is O(|V (T )|) times the maximum time that is spend on any node of T . According to the two branching rules given in (2.a.ii) and (2.b) we obtain that |V (T )| can be bounded by the maximum of the following recurrence relations: (1) T (k) = rT (k − (r − 1)) for any r ≥ 2 (2.a.ii) and (2) T (k) = 3T (k − 1) (2.b). In case of (1) the maximum of 2k is obtained for T (k) by setting r = 2, and in case of (2) T (k) is at most 3k. It follows that |V (T )| ≤ 3k. Furthermore, the time required for any node t of T is at most O(2k|F |). Putting everything together, we obtain O(3k2k|F |) = O(6k|F |), as the total running time of the algorithm. This shows that Strong HORN∪0-VAL-Backdoor Detection is fixed-parameter tractable parameterized by k.\nIn our next result, we consider heterogeneous base classes comprised of three Schaefer’s classes, namely 2CNF ∪HORN ∪ 0-VAL and 2CNF ∪HORN− ∪ 1-VAL. We refer the reader to Figure 1 for an overview of the branching strategies employed here.\nTheorem 3. Strong 2CNF∪HORN∪0-VAL-Backdoor Detection and Strong 2CNF∪HORN−∪ 1-VAL-Backdoor Detection are fixed-parameter tractable for parameter k.\nProof. We only give the proof for the class 2CNF ∪ HORN ∪ 0-VAL, since the proof for the class 2CNF ∪ HORN− ∪ 1-VAL is analogous. The algorithm uses a depth-bounded search tree approach to find a strong 2CNF ∪HORN ∪ 0-VAL-backdoor set of size at most k. Let F be any CNF-formula with variables V .\nWe construct a search tree T , for which every node is labeled by a set B of at most k variables of V . Additionally, every leaf node has a second label, which is either Yes or No. T is defined inductively as follows. The root of T is labeled by the empty set. Furthermore, if t is a node of T , whose first label is B, then the children of t in T are obtained as follows. If for every assignment τ : B → {0, 1}, F [τ ] ∈ 2CNF∪HORN∪0-VAL, then B is a strong 2CNF∪HORN∪0-VAL-backdoor set of size at most k, and hence t becomes a leaf node, whose second label is Yes. Otherwise, i.e., if there is an assignment τ : B → {0, 1} such that F [τ ] /∈ 2CNF ∪HORN ∪ 0-VAL, we consider two cases:\n1. |B| = k, then t becomes a leaf node, whose second label is No,\n2. otherwise, i.e., if |B| < k, then we again distinguish two cases:\n(a) there is a clause C ∈ F [τ ] with C /∈ 2CNF ∪ HORN ∪ 0-VAL, then we again distinguish two cases:\ni. |B|+ |C| − 2 > k, then t becomes a leaf node, whose second label is No,\nii. otherwise, i.e., if |B| + |C| − 2 ≤ k, , then for every two element subset O of C, t has a child whose first label is B ∪ var(C \\O).\n(b) there is a clause C ∈ F [τ ] with C ∈ 2CNF and C /∈ 0-VAL, we again distinguish two cases:\ni. there is a clause C′ ∈ F [τ ] with C′ /∈ 2CNF ∪ HORN (note that C′ ∈ 0-VAL). Let O be a set of variables containing all variables of C (at most two) plus three variables of C′\nof which two correspond to positive literals in C′. Then, for every v in O, t has a child whose first label is B ∪ {v}.\nii. otherwise, there are clauses C2CNF, CHORN ∈ F [τ ] with C2CNF ∈ 2CNF \\ HORN and CHORN ∈ HORN \\ 2CNF. Let O be a set of variables containing all variables of C2CNF (at most two) and three variables of CHORN. Then, for every v in O, t has a child whose first label is B ∪ {v}.\n(c) there is a clause C ∈ F [τ ] with C ∈ 2CNF and C /∈ HORN. In this case also C /∈ 0-VAL and hence the case is covered by case (2.b).\n(d) The cases (2.a), (2.b), and (2.c) completely cover all possible cases, because if none of these cases apply then F [τ ] ∈ 0-VAL, which contradicts the choice of τ . To see this assume there is a clause C ∈ F [τ ] with C /∈ 0-VAL. Because of the cases (2.b) and (2.c), we obtain that C /∈ 2CNF. Furthermore, because of case (2.a), we obtain that C ∈ HORN. Hence, C ∈ HORN \\ (0-VAL ∪ 2CNF) but such a clause cannot exist.\nIf T has a leaf node, whose second label is Yes, then the algorithm returns the first label of that leaf node. Otherwise the algorithm returns No. This completes the description of the algorithm.\nWe now show the correctness of the algorithm. First, suppose the search tree T built by the algorithm has a leaf node t whose second label is Yes. Here, the algorithm returns the first label, say B of t. By\ndefinition of T , we obtain that |B| ≤ k and B is a strong 2CNF∪HORN∪ 0-VAL-backdoor set of F , as required.\nNow consider the case where the algorithm returns No. We need to show that there is no set B of at most k variables of F such that F [τ ] ∈ 2CNF ∪HORN ∪ 0-VAL for every assignment τ of the variables of B. Assume, for the sake of contradiction that such a set B exists.\nObserve that if T has a leaf node t whose first label is a set B′ with B′ ⊆ B, then the second label of t must be Yes. Assume for a contradiction that this is not the case, then either case (1) or case (2.a.i) applied for t. In the former case B′ is not a strong 2CNF ∪ HORN ∪ 0-VAL-backdoor set for F and |B′| = k. Hence, B = B′ contradicting our assumption that B is a strong 2CNF∪HORN∪ 0-VALbackdoor set for F . In the later case, we obtain that there is an assignment τ : B′ → {0, 1} and a clause C ∈ F [τ ] such that C /∈ 2CNF∪HORN∪0-VAL and |B′|+ |C|− 2 > k. Consequently, B misses at least three literals from C. Hence, there is an assignment τ ′ : B → {0, 1} that is compatible with τ such that F [τ ′] contains a clause C′ ⊆ C with |C′| > 2. Clearly, C′ /∈ 2CNF ∪ 0-VAL and because C contained only positive literals (because C /∈ 0-VAL)) also C′ /∈ HORN. Hence, C′ /∈ 2CNF ∪ HORN ∪ 0-VAL contradicting our assumption that B is a strong 2CNF ∪ C-backdoor set for F .\nIt hence remains to show that T has a leaf node whose first label is a set B′ with B′ ⊆ B. This will complete the proof about the correctness of the algorithm. We will show a slightly stronger statement, namely, that for every natural number ℓ, either T has a leaf whose first label is contained in B or T has an inner node of distance exactly ℓ from the root whose first label is contained in B. We show the latter by induction on ℓ.\nThe claim obviously holds for ℓ = 0. So assume that T contains a node t at distance ℓ from the root of T whose first label, say B′, is a subset of B. If t is a leaf node of T , then the claim is shown. Otherwise, there is an assignment τ : B′ → {0, 1} such that F [τ ] /∈ 2CNF ∪HORN ∪ 0-VAL and one of the cases (2.a.ii), (2.b.i), and (2.b.ii) applies to t.\n(2.a.ii) In this case there is a clause C ∈ F [τ ] with C /∈ 2CNF ∪ HORN ∪ 0-VAL and t has one child whose first label is B′cupvar(C \\O) for every two element subset O of C. It remains to show that |var(C) \\ B| ≤ 2. Assume not, and let τ∗ : B → {0, 1} be an assignment compatible with τ that does not satisfy any literal of C. Then, C[τ∗] ∈ F [τ∗] and because |C[τ∗]| > 2 and C[τ∗] contains only positive literals, also F [τ∗] /∈ 2CNF ∪ HORN ∪ 0-VAL.\n(2.b.i) In this case there are clauses C,C′ ∈ F [τ ] with C ∈ 2CNF \\ 0-VAL and C′ ∈ 0-VAL \\ (2CNF ∪ HORN), and t has a child whose first label is B′ ∪ {v} for every variable in O, where O is the set of variables containing all variables of C and three variables of C′ of which two correspond to positive literals of C′. It remains to show that B ∩ O 6= ∅. Assume not and let τ∗ : B → {0, 1} be an assignment compatible with τ , which does not satisfy any literal of C′. Then, F [τ∗] contains C as well as a subclause C′′ of C′ of length at least three, which contains at least two positive literals. Then, C′′ /∈ HORN ∪ KROM and because C /∈ 0-VAL, we obtain that F [τ∗] /∈ 2CNF ∪ HORN ∪ 0-VAL, as required.\n(2.b.ii) In this case there are clauses C2CNF, CHORN ∈ F [tau] C2CNF ∈ 2CNF \\ HORN and CHORN ∈ HORN \\ 2CNF, and t has a child whose first label is B′ ∪ {v} for every variable in O, where O is the set of variables containing all variables of C2CNF and three variables of CHORN. It remains to show that B ∩ O 6= ∅. Assume not and let τ∗ : B → {0, 1} be an assignment compatible with τ , which does not satisfy any literal of CHORN. Then, F [τ\n∗] contains C2CNF as well as a subclause C′ of CHORN of length at least three. Because C2CNF ∈ 2CNF \\ HORN it follows that C2CNF /∈ 0-VAL. Because also C′ /∈ 2CNF, we obtain that F [τ∗] /∈ 2CNF ∪ HORN ∪ 0-VAL, as required.\nThis concludes our proof concerning the correctness of the algorithm. The running time of the algorithm is obtained as follows. Let T be a search tree obtained by the algorithm. Then the running time of the depth-bounded search tree algorithm is O(|V (T )|) times the maximum time that is spend on any node of T . According to the three branching rules given in (2.a.ii), (2.b.i), and (2.b.ii) we obtain that |V (T )| can be bounded by the maximum of the following recurrence relations: (1) T (k) = r2T (k − (r − 2)) for any r > 2 (2.a.ii), (2) T (k) = 5T (k − 1) (2.b.i), and (3)\nT (k) = 5T (k − 1) (2.b.ii). In case of (2) and (3) T (k) is at most 5k and in case of (1) the maximum of 9k is obtained for T (k) by setting r = 3. It follows that |V (T )| ≤ 9k. Furthermore, the time required for any node t of T is at most O(2k|F |). Putting everything together, we obtain O(9k2k|F |) = O(18k|F |), as the total running time of the algorithm. This shows that Strong 2CNF∪HORN∪ 0-VAL-Backdoor Detection is fixed-parameter tractable parameterized by k.\nWe say that a pair (C, C′) of Schaefer classes is a bad pair if C ∈ {HORN, 0-VAL} and C′ ∈ {HORN−, 1-VAL}. Our next result establishes hardness for the case when the base class contains a bad pair.\nTheorem 4. For every S ⊆ Schaefer that contains at least one bad pair of Schaefer classes, it holds that Strong C-Backdoor Detection is W[2]-hard, where C = ⋃\ns∈S s.\nProof. We give a parameterized reduction from the W[2]-complete Hitting Set problem. Given an instance (F , U, k) for Hitting Set, construct a formula F as follows. The variables of F are U ∪ { d1F , . . . , d |U\\F | F : F ∈ F }. For each set F ∈ F , there is one clause cF = F ∪ { d 1 F , . . . , d |U\\F | F }. There is also one clause cU = {¬u : u ∈ U}. This completes the description of the reduction. We claim that F has a hitting set of size at most k if and only if the formula F has a strong Cbackdoor set of size at most k. Suppose X ⊆ U , |X | ≤ k, is a hitting set. To show that X is also a strong C-backdoor set, consider any assignment τ : X → {0, 1}. If τ(x) = 0 for some x ∈ X , then τ satisfies the clause cU . Thus, F [τ ] ∈ C since each clause in F [τ ] contains no negative literal and at least one positive literal and is hence in 1-VAL ∩ HORN−. If τ(x) = 1 for all x ∈ X , then all clauses cF , F ∈ F , are satisfied by τ since X is a hitting set. The only remaining clause is HORN and 0-VAL since it has no positive literal and at least one negative literal.\nFor the other direction, suppose that X is a strong C-backdoor set of size at most k. Obtain X ′ from X by replacing each diF ∈ X for any i with 1 ≤ i ≤ |U \\ F | by some variable from F .\nThe setX ′ is also a strong C-backdoor set of size at most k. Therefore, the assignment τ : X ′ → {0, 1} with τ(x) = 1 for all x ∈ X ′ must satisfy all clauses cF , F ∈ F . Otherwise, F [τ ] contains both a long clause containing only positive and a long clause containing only negative literals and hence F [τ ] /∈ ⋃\ns∈S s. Thus, X ′ is a hitting set for F of size at most k.\nWe now summarize our results in the following theorem.\nTheorem 5. Let S ⊆ Schaefer and C = ⋃\ns∈S s. Then, Strong C-Backdoor Detection is fixed parameter tractable if and only if S does not contain a bad pair of Schaefer classes, otherwise it is W[2]-hard.\nProof. If S contains a bad pair then the result follows from Theorem 4. So assume that S does not contain a bad pair, we distinguish the following cases:\n• if |S| = 1, then the theorem follows from known results, see, for example, [12, 21].\n• if |S| = 2, then either 2CNF ∈ S in which case the result follows from Theorem 1, or S = {HORN, 0-VAL} or S = {HORN−, 1-VAL} in which case the result follows from Theorem 2.\n• if |S| = 3, then either 2CNF ∈ S and hence S = {2CNF,HORN, 0-VAL} or S = {2CNF,HORN−, 1-VAL} in which case the result follows from Theorem 3, or 2CNF /∈ S in which case S contains at least one bad pair, and the result follows from Theorem 4.\n• if |S| > 3, then S contains at least one bad pair, and the result follows from Theorem 4.\nIt is crucial for these hardness proofs that clauses have unbounded length. Indeed, if clause-lengths are bounded or if we add the maximum clause length to the parameter, then strong backdoor detection becomes FPT for any combination of Schaefer classes.\nTheorem 6. Let C be a class of CNF-formulas such that C = ⋃\ns∈S s for some S ⊆ Schaefer. Then, Strong C-Backdoor Detection is fixed-parameter tractable for the combined parameter k and the maximum length r of a clause of the input formula.\nProof. The algorithm uses a depth-bounded search tree approach to find a strong C-backdoor set of size at most k. Let F be any CNF-formula with variables V and let r be the maximum length of any clause of F .\nWe construct a search tree T , for which every node is labeled by a set B of at most k variables of V . Additionally, every leaf node has a second label, which is either Yes or No. T is defined inductively as follows. The root of T is labeled by the empty set. Furthermore, if t is a node of T , whose first label is B, the children of t in T are obtained as follows.\nIf for every assignment τ : B → {0, 1}, it holds that F [τ ] ∈ C, then B is a strong C-backdoor set of size at most k, and hence t becomes a leaf node, whose second label is Yes. Otherwise, i.e., if there is an assignment τ : B → {0, 1} such that F [τ ] /∈ C, we consider two cases: (1) if |B| = k, then t becomes a leaf node, whose second label is No, and (2) if |B| < k, then for every s ∈ S and every variable v that occurs in some clause C /∈ s, t has a child whose first label is B ∪ {v}.\nIf T has a leaf node, whose second label is Yes, then the algorithm returns the first label of that leaf node. Otherwise the algorithm returns No. This completes the description of the algorithm.\nWe now show the correctness of the algorithm. First, suppose the search tree T built by the algorithm has a leaf node t whose second label is Yes. Here, the algorithm returns the first label, say B of t. By definition of T , we obtain that |B| ≤ k and the set B is a strong C-backdoor set of F , as required.\nNow consider the case where the algorithm returns No. We need to show that there is no strong C-backdoor set of size at most k for F . Assume, for the sake of contradiction that such a set B exists.\nObserve that if T has a leaf node t whose first label is a set B′ with B′ ⊆ B, then the second label of t must be Yes. This is because, either |B′| < k in which case the second label of t must be Yes, or |B′| = k in which case B′ = B and by the definition of B it follows that the second label of t must be Yes.\nIt hence remains to show that T has a leaf node whose first label is a set B′ with B′ ⊆ B. This will complete the proof about the correctness of the algorithm. We will show a slightly stronger statement, namely, that for every natural number ℓ, either T has a leaf whose first label is contained in B or T has an inner node of distance exactly ℓ from the root whose first label is contained in B. We show the latter by induction on ℓ.\nThe claim obviously holds for ℓ = 0. So assume that T contains a node t at distance ℓ from the root of T whose first label, say B′, is a subset of B. If t is a leaf node of T , then the claim is shown. Otherwise, there is an assignment τ : B′ → {0, 1} such that F [τ ] /∈ C. Let τ∗ : B → {0, 1} be any assignment of the variables in B that agrees with τ on the variables in B′ and let s ∈ S be such that F [τ∗] ∈ s. Because B is a strong C-backdoor set, s clearly exists. By definition of the search tree T , t has a child t′ for every variable v contained in some clause C ∈ F [τ ] with C /∈ s. We claim that var(C) ∩B 6= ∅ and hence t has a child, whose first label is a subset of B, as required. Indeed, suppose not. Then C ∈ F [τ∗] a contradiction to our assumption that F [τ∗] ∈ s. This concludes our proof concerning the correctness of the algorithm.\nThe running time of the algorithm is obtained as follows. Let T be a search tree obtained by the algorithm. Then the running time of the depth-bounded search tree algorithm is O(|V (T )|) times the maximum time that is spend on any node of T . Since the number of children of any node of T is bounded by |S|r (recall that r denotes the maximum length of any clause of F ) and the longest path from the root of T to some leaf of T is bounded by k + 1, we obtain that |V (T )| ≤ O((|S|r)k+1). Furthermore, the time required for any node t of T is at most O(2k|F |). Putting everything together, we obtain O((|S|r)k+12k|F |), as the total running time of the algorithm. This shows that Strong C-Backdoor Detection is fixed-parameter tractable parameterized by k, r."
    }, {
      "heading" : "3.2 Weak Backdoor Sets",
      "text" : "It turns out that the complexity of finding weak backdoors into heterogeneous classes is tightly tied into the complexity of finding weak backdoors into the individual base classes. Let us briefly consider the\nintuition for this scenario before stating the result. Suppose we are given algorithms for finding weak backdoors into base classes C1 and C2. Observe that a CNF-formula has a weak backdoor of size at most k into (C1 ∪ C2) if, and only if, it has a weak backdoor of size at most k into at least one of C1 or C2. Thus, if we have a positive algorithmic result for the weak backdoor question with respect to the individual base classes, then these algorithms can be easily combined to obtain an algorithm for finding weak backdoors into the corresponding heterogeneous base class. On the other hand, a hardness result for even one of the involved classes can usually be leveraged to obtain a hardness result for the entire heterogeneous problem, by adding gadgets that isolate the issue to only one of the base classes, typically the one that was hard to begin with. In particular, we obtain the following result.\nTheorem 7. Let S ⊆ Schaefer and C = ⋃\ns∈S s. Then, Weak C-Backdoor Detection is W[2]-hard.\nBefore we proceed further, we introduce the notion of an obstruction which we will use in the proof. Specifically, for S, S′ ∈ Schaefer, we say that a clause C is an S-obstruction to S′ if C ∈ S and C /∈ S′. For any pair of Schaefer classes S and S′, it is easy to construct examples of S-obstructions to S′. In particular, we have:\n1. (¬x,¬y,¬z) is an HORN obstruction to 2CNF, and also a 0-valid obstruction to 2CNF.\n2. (x, y, z) is an Anti-HORN obstruction to 2CNF, and also a 1-valid obstruction to 2CNF.\n3. (x, y,¬z) is a 0-valid obstruction to HORN.\n4. (x, y) is an X-obstruction to HORN for all X ∈ { 2CNF, Anti-HORN, 1-valid }.\n5. (¬x,¬y, z) is a 1-valid obstruction to Anti-HORN.\n6. (¬x,¬y) is an X-obstruction to Anti-HORN for all X ∈ { 2CNF, HORN, 0-valid }.\n7. (x) is an X-obstruction to 0-valid for all X ∈ { 2CNF, 1-valid, HORN, Anti-HORN }.\n8. (¬x) is an X-obstruction to 1-valid for all X ∈ { 2CNF, 0-valid, HORN, Anti-HORN }.\nWe are now ready to describe our reduction towards Theorem 7.\nProof. If |S| = 1, then the result follows directly from [12, Proposition 1]. Otherwise, let S ∈ C. We reduce an instance (F, k) of Weak S-Backdoor Detection to Weak C-Backdoor Detection. To this end, for all S′ ∈ C such that S 6= S′, introduce (k+1) variable-disjoint copies of a S-obstruction to S′ (using fresh variables for each obstruction, and in particular, disjoint from var(F ). We use F ′ to denote the formula obtained from F after adding these obstructions to F , and the reduced instance is given by (F ′, k).\nIn the forward direction, if X is a weak backdoor to S for F , and if τ : X → {0, 1} is such that F [τ ] ∈ S, then observe that F ′[τ ] ∈ S, since all the added obstructions (which are unaffected by τ) were in S by definition. It is also easy to see that any satisfying assignment for var(F ) \\ X can be easily extended to an assignment involving the new variables that satisfy all the obstructions (recall that the obstructions were variable disjoint, and therefore can be easily satisfied independently).\nOn the other hand, let X be a weak backdoor to C for F ′. Since X has at most k variables, for any τ : X → {0, 1}, F ′[τ ] contains at least one S′-obstructing clause for each S′ ∈ C such that S′ 6= S. Therefore, F ′[τ ] must necessarily belong to S, and therefore X ∩ var(F ) is easily checked to be a weak backdoor to S for F , as desired.\nOn the other hand, as with the strong backdoors, we do obtain tractability when we have bounded clause lengths. We establish this formally below.\nTheorem 8. Let C be a class of CNF-formulas such that C = ⋃\ns∈S s for some S ⊆ Schaefer. Then, Weak C-Backdoor Detection is fixed-parameter tractable for the combined parameter k and the maximum length r of a clause of the input formula.\nProof. The algorithm uses a depth-bounded search tree approach to find a weak C-backdoor set of size at most k. Let F be any CNF-formula with variables V and let r be the maximum length of any clause of F .\nWe construct a search tree T , for which every node is labeled by a set B of at most k variables of V . Additionally, every leaf node has a second label, which is either Yes or No. T is defined inductively as follows. The root of T is labeled by the empty set. Furthermore, if t is a node of T , whose first label is B, the children of t in T are obtained as follows.\nIf there is an assignment τ : B → {0, 1}, such that F [τ ] ∈ C and F [τ ] is satisfiable, then B is a weak C-backdoor set of size at most k, and hence t becomes a leaf node, whose second label is Yes. Otherwise, i.e., for every assignment τ : B → {0, 1} either F [τ ] /∈ C or F [τ ] ∈ C but F [τ ] is not satisfiable, we consider two cases: (1) |B| = k, then t becomes a leaf node, whose second label is No, and (2) |B| < k, then for every assignment τ : B → {0, 1} such that F [τ ] /∈ C, for every s ∈ S, and every variable v that occurs in some clause C /∈ s, t has a child whose first label is B ∪ {v}.\nIf T has a leaf node, whose second label is Yes, then the algorithm returns the first label of that leaf node. Otherwise the algorithm returns No. This completes the description of the algorithm.\nWe now show the correctness of the algorithm. First, suppose the search tree T built by the algorithm has a leaf node t whose second label is Yes. Here, the algorithm returns the first label, say B of t. By definition of T , we obtain that |B| ≤ k and the set B is a weak C-backdoor set of F , as required.\nNow consider the case where the algorithm returns No. We need to show that there is no weak C-backdoor set of size at most k for F . Assume, for the sake of contradiction that such a set B exists.\nObserve that if T has a leaf node t whose first label is a set B′ with B′ ⊆ B, then the second label of t must be Yes. This is because, either |B′| < k in which case the second label of t must be Yes, or |B′| = k in which case B′ = B and by the definition of B it follows that the second label of t must be Yes.\nIt hence remains to show that T has a leaf node whose first label is a set B′ with B′ ⊆ B. This will complete the proof about the correctness of the algorithm. We will show a slightly stronger statement, namely, that for every natural number ℓ, either T has a leaf whose first label is contained in B or T has an inner node of distance exactly ℓ from the root whose first label is contained in B. We show the latter by induction on ℓ.\nThe claim obviously holds for ℓ = 0. So assume that T contains a node t at distance ℓ from the root of T whose first label, say B′, is a subset of B. If t is a leaf node of T , then the claim is shown. Because B is a weak C-backdoor set for F , there is an assignment τ∗ : B → {0, 1} such that F [τ∗] ∈ C and F [τ∗] is satisfiable. In particular, there is some s ∈ S such that F [τ∗] ∈ s. Let τ : B′ → {0, 1} be the assignment that agrees with τ∗ on the variables of B′. Because t is not a leaf node, there is a clause C ∈ F [τ ] with C /∈ s such that t has a child t′ for every v ∈ var(C). We claim that var(C) ∩B 6= ∅ and hence t has a child, whose first label is a subset of B, as required. Indeed, suppose not. Then C ∈ F [τ∗] a contradiction to our assumption that F [τ∗] ∈ s. This concludes our proof concerning the correctness of the algorithm.\nThe running time of the algorithm is obtained as follows. Let T be a search tree obtained by the algorithm. Then the running time of the depth-bounded search tree algorithm is O(|V (T )|) times the maximum time that is spend on any node of T . Since the number of children of any node of T is bounded by 2k|S|r (recall that r denotes the maximum length of any clause of F ) and the longest path from the root of T to some leaf of T is bounded by k + 1, we obtain that |V (T )| ≤ O((2k|S|r) k+1\n). Furthermore, the time required for any node t of T is at most O(2k|F |). Putting everything together, we obtain O((2k|S|r)k+12k|F |), as the total running time of the algorithm. This shows that Weak C-Backdoor Detection is fixed-parameter tractable parameterized by k, r.\nWe close this section by noting that backdoor sets with empty clause detection, as proposed by [7] can be considered as backdoor sets into the heterogeneous base class obtained by the union of a homogeneous base class C and the class of all formulas that contain the empty clause. The detection of strong backdoor sets with empty clause detection is not fixed-parameter tractable for many natural base classes, including Horn and 2CNF [27]."
    }, {
      "heading" : "4 Base Classes via Closure Properties",
      "text" : "In this section we provide a very general framework that will give rise to a wide range of heterogeneous base classes for CSP.\nGiven a k-ary relation R over some domain D and a function φ : Dn → D, we say that R is closed under φ, if for all collections of n tuples t1, . . . , tn fromR, the tuple 〈φ(t1[1], . . . , tn[1]), . . . , φ(t1[k], . . . , tn[k])〉 belongs to R. The function φ is also said to be a polymorphism of R. We denote by Pol(R) the set of all functions φ such that R is closed under φ.\nLet I = 〈V,D,C〉 be a CSP instance and c ∈ C. We write Pol(c) for the set Pol(R(c)) and we write Pol(I) for the set ⋂\nc∈C Pol(c). We say that I is closed under a polymorphism φ if φ ∈ Pol(I).\n• A polymorphism φ : D → D is constant if there is a d ∈ D such that for every d′ ∈ D, it holds that φ(d′) = d;\n• A polymorphism φ : Dn → D is idempotent if for every d ∈ D it holds that φ(d, . . . , d) = d;\n• A polymorphism φ : Dn → D is conservative if for every d1, . . . , dn ∈ D it holds that φ(d1, . . . , dn) ∈ {d1, . . . , dn};\n• A polymorphism φ : D2 → D is a min/max polymorphism if there is an ordering of the elements of D such that for every d, d′ ∈ D, it holds that φ(d, d′) = φ(d′, d) = min{d, d′} or φ(d, d′) = φ(d′, d) = max{d, d′}, respectively;\n• A polymorphism φ : D3 → D is a majority polymorphism if for every d, d′ ∈ D it holds that φ(d, d, d′) = φ(d, d′, d) = φ(d′, d, d) = d;\n• A polymorphism φ : D3 → D is an minority polymorphism if for every d, d′ ∈ D it holds that φ(d, d, d′) = φ(d, d′, d) = φ(d′, d, d) = d′;\n• A polymorphism φ : D3 → D is a Mal’cev polymorphism if for every d, d′ ∈ D it holds that φ(d, d, d′) = φ(d′, d, d) = d′.\nWe say a polymorphism φ is tractable if every CSP instance closed under φ can be solved in polynomial time. It is known that every constant, min/max, majority, minority, and Mal’cev polymorphism is tractable [4, 15]. We denote by VAL, MIN, MAX, MAJ, MIN, and MAL the class of CSP instances I for which Pol(I) contains a constant, a min, a max, a majority, a minority, or a Mal’cev polymorphism, respectively.\nLet P(φ) be a predicate for the polymorphism φ. We call P(φ) a nice polymorphism property if the following conditions hold.\n• There is a constant cP such that for all finite domainsD, all polymorphisms φ overD with property P are of arity at most cP.\n• Given a polymorphism φ and a domain D, one can check in polynomial time whether P(φ) holds on all of the at most DcP tuples over D,\n• Every polymorphism with property P is tractable.\nEvery nice polymorphism property P gives rise to a natural base class CP consisting of all CSPinstances I such that Pol(I) contains some polymorphism φ with P(φ). Thus VAL, MIN, MAX, MAJ, MIN, andMAL are the classes CP for P ∈ {constant, min, max, majority, minority, Mal’cev}, respectively.\nIn terms of the above definitions we can state the results of [15] and [4] as follows.\nProposition 1. Constant, min, max, majority, minority, and Mal’cev are nice polymorphism properties.\nIn the next sections we will study the problems Strong CP-Backdoor Detection for nice polymorphism properties P."
    }, {
      "heading" : "5 Tractability of Backdoor Detection for CSP",
      "text" : "In this section we will show that both Strong CP-Backdoor Detection and Weak CP-Backdoor Detection parameterized by the size of the backdoor set, the size of the domain, and the maximum arity of the CSP instance are fixed-parameter tractable for any nice property P. We start by giving the tractability results for strong backdoor sets.\nTheorem 9. Let P be a nice polymorphism property. Then Strong CP-Backdoor Detection is fixed-parameter tractable for the combined parameter size of the backdoor set, size of the domain, and the maximum arity of the given CSP instance.\nProof. Let P be a nice property, and let 〈I, k〉 with I = 〈V,D,C〉 be an instance of Strong CP-Backdoor Detection. Let P be the set of all polymorphisms on D that have property P. Then, P can be constructed in fpt-time with respect to the size of the domain , because there are at most |D||D|\ncP cP-ary polymorphisms on D and for each of them we can test in polynomial time, |D|O(cP), whether it satisfies property P. The algorithm uses a depth-bounded search tree approach to find a strong CP-backdoor set of size at most k.\nWe construct a search tree T , for which every node is labeled by a set B of at most k variables of V . Additionally, every leaf node has a second label, which is either Yes or No. T is defined inductively as follows. The root of T is labeled by the empty set. Furthermore, if t is a node of T , whose first label is B, then the children of t in T are obtained as follows. If for every assignment τ : B → D there is a polymorphism φ ∈ P such that I[τ ] is closed under φ, then B is a strong P -backdoor set of size at most k, and hence t becomes a leaf node, whose second label is Yes. Otherwise, i.e., if there is an assignment τ : B → D such that I[τ ] is not closed under any polymorphism φ ∈ P , we consider two cases: (1) |B| = k, then t becomes a leaf node, whose second label is No, and (2) |B| < k, then for every polymorphism φ ∈ P and every variable v in the scope of some constraint c ∈ C[τ ] that is not closed under φ, t has a child whose first label is B ∪ {v}.\nIf T has a leaf node, whose second label is Yes, then the algorithm returns the first label of that leaf node. Otherwise the algorithm return No. This completes the description of the algorithm.\nWe now show the correctness of the algorithm. First, suppose the search tree T built by the algorithm has a leaf node t whose second label is Yes. Here, the algorithm returns the first label, say B of t. By definition, we obtain that |B| ≤ k and for every assignment τ : B → D, it holds that I[τ ] is closed under some polymorphism in P , as required.\nNow consider the case where the algorithm returns No. We need to show that there is no set B of at most k variables of I such that Pol(I[τ ]) ∩ P 6= ∅ for every assignment τ of the variables of B. Assume, for the sake of contradiction that such a set B exists.\nObserve that if T has a leaf node t whose first label is a set B′ with B′ ⊆ B, then the second label of t must be Yes. This is because, either |B′| < k in which case the second label of t must be Yes, or |B′| = k in which case B′ = B and by the definition of B it follows that the second label of t must be Yes.\nIt hence remains to show that T has a leaf node whose first label is a set B′ with B′ ⊆ B. This will complete the proof about the correctness of the algorithm. We will show a slightly stronger statement, namely, that for every natural number ℓ, either T has a leaf whose first label is contained in B or T has an inner node of distance exactly ℓ from the root whose first label is contained in B. We show the latter by induction on ℓ.\nThe claim obviously holds for ℓ = 0. So assume that T contains a node t at distance ℓ from the root of T whose first label, say B′, is a subset of B. If t is a leaf node of T , then the claim is shown. Otherwise, there is an assignment τ : B′ → D such that I[τ ] is not closed under any polymorphism from P . Let τ∗ : B → D be any assignment of the variables in B that agrees with τ on the variables in B′ and let φ ∈ P be such that I[τ∗] is closed under φ. Because B is a strong P -backdoor set, the polymorphism φ clearly exists. By definition of the search tree T , t has a child t′ for every variable v in the scope of some constraint c ∈ C[τ ] that is not closed under φ. We claim that V (c) ∩ B 6= ∅ and hence t has a child, whose first label is a subset of B, as required. Indeed, suppose not. Then c ∈ C[τ∗] a contradiction to our assumption that I[τ∗] is closed under φ. This concludes our proof concerning the correctness of the algorithm.\nThe running time of the algorithm is obtained as follows. Let T be a search tree obtained by the algorithm. Then the running time of the depth-bounded search tree algorithm is O(|V (T )|) times the maximum time that is spend on any node of T . Since the number of children of any node of T is bounded by |P |δ(I) (recall that δ(I) denotes the maximum arity of any constraint of I) and the longest path from the root of T to some leaf of T is bounded by k+1, we obtain that |V (T )| ≤ O((|P |δ(I))k+1). Furthermore, the time required for any node t of T is at mostO(|D|kcomp rest(I, τ)|C(I[τ ])||P |check poly(c, φ)), where comp rest(I, τ) is the time required to compute I[τ ] for some assignment τ of at most k variables and check poly(c, φ) is the time required to check whether a constraint c of I[τ ] preserves the polymorphism φ ∈ P . Observe that comp rest(I, τ) and |C(I[τ ])| are polynomial in the input size. The same holds for check poly(c, φ), because φ is a cP-ary polymorphism. Now, the total running time required by the algorithm is the time required to compute the set P plus the time required to compute T . Putting everything together, we obtain O((|P |δ(I))k+1 |D|k|P |nO(1)) = O((|P |δ(I)|D|)k+2nO(1)) = O((|D||D| cP\nδ(I)|D|)k+2nO(1)), r as the total running time of the algorithm, where n denotes the input size of the CSP instance. This shows that Strong CP-Backdoor Detection is fixed-parameter tractable parameterized by k, δ(I), and |D|.\nBecause of Proposition 1, we obtain.\nCorollary 1. Let C be a base class consisting of the union of some of the classes MIN, MAX, MAJ, MIN, and MAL. Then Strong C-Backdoor Detection is fixed-parameter tractable for the combined parameter size of the backdoor set, size of the domain, and the maximum arity of the given CSP instance.\nWe are now ready to provide analogous results for weak backdoor sets. The proof is very similar to the case of strong backdoor sets, however, it becomes slightly simpler, because we do not need to consider different polymorphisms for different assignments (since there is only one assignment, required for a weak backdoor set). We can hence branch on the possible polymorphisms before we start the depth-bounded search tree procedure, which also results in a slight improvement in the running time of the algorithm.\nTheorem 10. Let P be a nice polymorphism property. Then Weak CP-Backdoor Detection is fixed-parameter tractable for the combined parameter size of the backdoor set, size of the domain, and the maximum arity of the given CSP instance.\nProof. Let P be a nice property, and let 〈I, k〉 with I = 〈V,D,C〉 be an instance of Weak CP-Backdoor Detection. Let P be the set of all polymorphisms on D that have property P. Then, P can be constructed in fpt-time with respect to the size of the domain , because there are at most |D||D|\ncP cP-ary polymorphisms on D and for each of them we can test in polynomial time, |D|O(cP), whether it satisfies property P. The algorithm uses a depth-bounded search tree approach to find a weak {φ}-backdoor set of size at most k for every φ ∈ P .\nThe algorithm works by constructing a search tree Tφ for every polymorphism φ ∈ P . In Tφ every node is labeled by a set B of at most k variables of V . Additionally, every leaf node has a second label, which is either Yes or No. Tφ is defined inductively as follows. The root of Tφ is labeled by the empty set. Furthermore, if t is a node of Tφ, whose first label is B, then the children of t in Tφ are obtained as follows. If there is an assignment τ : B → D such that I[τ ] is closed under φ and I[τ ] has a solution , then B is a weak P -backdoor set of size at most k, and hence t becomes a leaf node, whose second label is Yes. Otherwise, i.e., for every assignment τ : B → D either I[τ ] is not closed under φ or I[τ ] has no solution, we consider two cases: (1) |B| = k, then t becomes a leaf node, whose second label is No, and (2) |B| < k, then for every assignment τ : B → D t has the following children: for every every variable v in the scope of some constraint c ∈ I[τ ] that is not closed under φ, t has a child whose first label is B ∪ {v}.\nIf there is a φ ∈ P such Tφ has a leaf node, whose second label is Yes, then the algorithm returns the first label of that leaf node. Otherwise the algorithm return No. This completes the description of the algorithm.\nWe now show the correctness of the algorithm. First, suppose there is a φ ∈ P such that the search tree Tφ built by the algorithm has a leaf node t whose second label is Yes. Here, the algorithm returns\nthe first label, say B of t. By the construction of Tφ, we obtain that |B| ≤ k and there is an assignment τ : B → D such that I[τ ] is closed φ and I[τ ] has a solution, as required.\nNow consider the case where the algorithm returns No. We need to show that there is no weak P -backdoor set of size at most k for I. Assume, for the sake of contradiction that such a set B exists. Because B is a weak P -backdoor set for I there must exists a polymorphism φ ∈ P and an assignment τ : B → D such that I[τ ] is closed under φ and I[τ has a solution.\nObserve that if Tφ has a leaf node t whose first label is a set B ′ with B′ ⊆ B, then the second label of t must be Yes. This is because, either |B′| < k in which case the second label of t must be Yes, or |B′| = k in which case B′ = B and by the definition of B it follows that the second label of t must be Yes.\nIt hence remains to show that Tφ has a leaf node whose first label is a set B ′ with B′ ⊆ B. This will complete the proof about the correctness of the algorithm. We will show a slightly stronger statement, namely, that for every natural number ℓ, either Tφ has a leaf whose first label is contained in B or Tφ has an inner node of distance exactly ℓ from the root whose first label is contained in B. We show the latter by induction on ℓ.\nThe claim obviously holds for ℓ = 0. So assume that Tφ contains a node t at distance ℓ from the root of Tφ whose first label, say B\n′, is a subset of B. If t is a leaf node of Tφ, then the claim is shown. Otherwise, for every assignment τ : B′ → D either I[τ ] is not closed under φ or I[τ ] has no solution. Let τ ′ : B′ → D be the restriction of τ to B′. Because I[τ ] and hence also I[τ ′] has a solution, we obtain that I[τ ′] is not closed under the polymorphism φ. By the definition of the search tree Tφ, it holds that t has a child t′ whose first label is B′ ∪{v}, for every variable v in the scope of some constraint c ∈ I[τ ′] that is not closed under φ. We claim that V (c) ∩ B 6= ∅ and hence t has a child, whose first label is a subset of B, as required. Indeed, suppose not. Then c ∈ I[τ ] a contradiction to our assumption that I[τ ] is closed under φ. This concludes our proof concerning the correctness of the algorithm.\nThe running time of the algorithm is obtained as follows. Let Tφ be a search tree obtained by the algorithm. Then the running time of the depth-bounded search tree algorithm is O(|V (Tφ)|) times the maximum time that is spend on any node of Tφ. Since the number of children of any node of Tφ is bounded by |D|\nkδ(I) (recall that δ(I) denotes the maximum arity of any constraint of I) and the longest path from the root of Tφ to some leaf of Tφ is bounded by k + 1, we obtain that |V (Tφ)| ≤ O((|D| kδ(I)) k+1 ). Furthermore, the time required for any node t of T is at most O(|D|kcomp rest(I, τ)|C(I[τ ])|check poly(c, φ)check sol(I[τ ], φ)), where comp rest(I, τ) is the time required to compute I[τ ] for some assignment τ of at most k variables, check poly(c, φ) is the time required to check whether a constraint c of I[τ ] preserves the polymorphism φ, and check sol(I[τ ], φ) is the time required to solve I[τ ] given that it is closed under the polymorphism φ. Observe that comp rest(I, τ) and |C(I[τ ])| are polynomial in the input size. The same holds for check poly(c, φ) and check sol(I[τ ], φ), because φ is a cP-ary tractable polymorphism. Now, the total running time required by the algorithm is the time required to compute the set P plus the time required to compute Tφ for every φ ∈ P . Putting everything together, we obtain O(|P |(|D|kδ(I))k+1|D|knO(1)) = O(|P |(|D|kδ(I))k+1nO(1)) = O(|D||D| cP\n(|D|kδ(I))k+2nO(1)), as the total running time of the algorithm, where n denotes the input size of the CSP instance. This shows that Weak CP-Backdoor Detection is fixed-parameter tractable parameterized by k, δ(I), and |D|.\nBecause of Proposition 1, we obtain.\nCorollary 2. Let C be a base class consisting of the union of some of the classes MIN, MAX, MAJ, MIN, and MAL. Then Weak C-Backdoor Detection is fixed-parameter tractable for the combined parameter size of the backdoor set, size of the domain, and the maximum arity of the given CSP instance."
    }, {
      "heading" : "6 Hardness of Backdoor Detection for CSP",
      "text" : "In this section we show our parameterized hardness results for Strong CP-Backdoor Detection and Weak CP-Backdoor Detection. In particular, we show that Strong CP-Backdoor Detection and Weak CP-Backdoor Detection are W[2]-hard parameterized by the size of the backdoor set\neven for CSP instances of Boolean domain and for CSP instances with arity two. We start by showing hardness for CSP instances with Boolean domain.\nLet φ : Dn → D be an n-ary polymorphism over D and r a natural number. We say a sequence of rary tuples 〈t1, . . . , tn〉 is an obstruction for φ if φ(t1, . . . , tn) /∈ {t1, . . . , tn}. We say that a polymorphism is obstructable if it has an obstruction. Observe that all tractable polymorphisms are also obstructable because every CSP instance is closed under any polymorphism that is not obstructable. For a sequence S of tuples, we denote by D(S), the set of pairwise distinct tuples in S. We call an obstruction 〈t1, . . . , tn〉 of φ minimal if |D(〈t1, . . . , tn〉)| is minimal over all obstructions of φ. For a polymorphism φ, we denote by O(φ) a minimal obstruction of φ and by r(φ) the arity of the tuples in the minimal obstruction O(φ).\nTheorem 11. Let P be a nice polymorphism property such that all polymorphisms φ with P(φ) are idempotent. Then, Strong CP-Backdoor Detection and Weak CP-Backdoor Detection are W[2]-hard parameterized by the size of the backdoor set, even for CSP instances over the Boolean domain.\nProof. We show the theorem via an fpt-reduction from Hitting Set. Let H = 〈U ,F , k〉 be an instance of Hitting Set. We construct a CSP instance I = 〈V, {0, 1}, C〉 such that H has a hitting set of size at most k if and only if I has a strong CP-backdoor set of size at most k. Let P be the set of all polymorphisms on {0, 1} that have property P. Then, P can be constructed in polynomial time, because there are at most 22\ncP cP-ary polymorphisms on {0, 1} and for each of them we can test in polynomial time, whether it satisfies property P. The variables of I are { xu : u ∈ U } ∪ { o1(φ, F ), . . . , or(φ)(φ, F ) : φ ∈ P and F ∈ F }. Furthermore, for every polymorphism φ ∈ P with D(O(φ)) = 〈t1, . . . , tn〉, for some natural number n, and F ∈ F with F = {u1, . . . , u|F |}, C contains a constraint R(φ, F ) with scope 〈o1(φ, F ), . . . , or(φ)(φ, F ), xu1 , . . . , xu|F |〉 whose relation contains the row\nti[1], . . . , ti[r(φ)], 〈i mod 2, . . . , i mod 2〉 ︸ ︷︷ ︸\n|F |times\nfor every i in 1 ≤ i ≤ n. This completes the construction of I. Observe that I is satisfiable, because the first rows of every constraint of I are pairwise compatible. In particular, set all the variables of the form {xu : u ∈ U} to zero, and set all remaining variables according to their first-row constraints — note that these rows are the same for different F 6= F ′ associated with the same polymorphism φ, while on the other hand, for different polymorphisms φ 6= φ′, the associated variables are different and there is no cause for conflict. Suppose that H has a hitting set B of size at most k. We claim that Bu = { xu : u ∈ B } is a strong CP-backdoor set of I. We start by showing that Bu is a strong P -backdoor set of I. Let τ : Bu → D be an assignment of the variables in B and φ ∈ P be a polymorphism that maximizes |D(O(φ))| over all polymorphisms in P . We claim that I[τ ] is closed under φ and hence Bu is a strong CP-backdoor set of I. Because B is a hitting set of H , it follows that every relation of I[τ ] contains at most half of the tuples of the corresponding relation in I. Furthermore, because φ is idempotent (and hence every tuple is mapped to itself), it holds that |D(O(φ))| > 1. It follows that every relation of I[τ ] contains at least 1 tuple less than the corresponding relation in I. Because of the choice of φ, we obtain that every constraint c ∈ C[τ ] contains less than |D(O(φ))| tuples, and hence I[τ ] is closed under φ. Hence, Bu = { xu : u ∈ B } is a strong CP-backdoor set of I, as required. Towards showing that Bu is also a weak P -backdoor set of C consider the assignment τ : Bu → {0}. It follows from the above argumentation that C[τ ] is closed under the polymorphism φ. Furthermore, I[τ ] is satisfiable, because the first row of every constraint of C is also contained in every constraint of I[τ ] and these rows are pairwise compatible.\nFor the reverse direction, suppose that I has a strong CP-backdoor set B of size at most k. Because for every F ∈ F it holds that the set of constraints {R(φ, F ) : φ ∈ P } is not closed under any polymorphism in P , we obtain that B has to contain at least 1 variable from ⋃\nφ∈P V (R(φ, F )) for every F ∈ F . Since the only variables that are shared between ⋃\nφ∈P V (R(φ, F )) and ⋃ φ∈P V (R(φ, F ′)) for\ndistinct F, F ′ ∈ F are the variables in { xu : u ∈ U }, it follows that H has a hitting set of size at most |B| ≤ k, as required.\nBecause all min, max, majority, affine and Mal’cev polymorphisms can be defined via nice properties and are idempotent, we obtain.\nCorollary 3. For every C ∈ {MIN, MAX, MAJ, MIN, MAL}, Strong C-Backdoor Detection and Weak C-Backdoor Detection are W[2]-hard parameterized by the size of the backdoor set, even for CSP instances over the Boolean domain.\nIn the following we show that hardness also holds if we drop the restriction on the domain of the CSP instance but instead consider only CSP instances of arity 2. To do so we need the following lemma.\nLemma 1. For every C ∈ {MIN,MAX,MAJ,MIN,MAL} and every k ≥ 3, there is a 2-ary CSP instance I(C, k) with k constraints, each containing the all 0 tuple, such that I(C, k) /∈ C but for every assignment τ of at least one variable of I(C, k), it holds that I(C, k)[τ ] ∈ C.\nProof. The proof of this lemma is inspired by the proof of [3, Lemma 3]. For every C as in the statement of the lemma, I(C, k) has variables v1, . . . , v2k and contains a constraint ci with scope 〈v2i−1, v2i〉 for every 1 ≤ i ≤ k.\nIf C = MAJ, the domain of I(C, k) is {1, . . . , 3k − 4}, and for every 1 ≤ i ≤ k the relations R(ci) are defined as follows: R(c1) = {(0, 0), (1, 3), (1, 4), (2, 5)}, R(c2) = {(0, 0), (1, 3), (2, 4), (1, 5)}, R(c3) = {(0, 0), (2, 3(k − 2)), (1, 3(k − 2) + 1), (2, 3(k − 2) + 2)}, and for every 3 < i ≤ k, R(ci) = {(0, 0), (3(i− 3), 3(i− 2)), (3(i − 3) + 1, 3(i− 2) + 1), (3(i− 3) + 2, 3(i− 2) + 2)}. Clearly, the instance is binary and every relation contains the all 0 tuple. We first show that I(C, k) is not closed under any majority polymorphism φ. From R(c1) and R(c2), we obtain φ(3, 4, 5) = 3 and from R(c3), we obtain φ(3(k−2), 3(k−2)+1, 3(k−2)+2) ∈ {3(k−2)+1, 3(k−2)+2}. Finally, from R(ci) with 3 < i ≤ k, we obtain φ(3(i−2), 3(i−2)+1, 3(i−2)+2) = j if and only if φ(3(i−1), 3(i−1)+1, 3(i−1)+2) = j+3. This chain implies f(3, 4, 5) ∈ {4, 5} in contradiction to f(3, 4, 5) = 3. On the other hand, for any assignment τ that sets at least 1 variable of I(C, k), it holds that at least one relation of I(C, k)[τ ] contains at most 2 tuples. This relation is then closed under any majority polymorphism and breaks the above chain of implications.\nIf C = MAX, the domain of I(C, k) is {1, . . . , k + 1}, and for every 1 ≤ i ≤ k the relations R(ci) are defined as follows: Ri = {(0, 0), (i, i + 1), (i + 1, i), (i + 1, i + 1)} for every 1 ≤ i < k and Rk = {(0, 0), (1, k + 1), (k + 1, 1), (1, 1)}. Clearly, the instance is binary and every relation contains the all 0 tuple. Let φ be a max polymorphism. Then, for every 1 ≤ i < k, the relation Ri implies i < i+ 1, but the relation Rk implies 1 > k+1, a contradiction. Hence, the set of all relations R1, . . . , Rk is not closed under any max polymorphism. On the other hand, for any assignment τ that sets at least 1 variable of I(C, k), it holds that at least one relation of I(C, k)[τ ] contains at most 2 tuples that agree on (at least) one coordinate. This relation is then closed under any max polymorphism and breaks the above chain of implications. If C = MIN, we can use the same set of relations.\nIf C = MIN, the domain of I(C, k) is {1, . . . , 3k + 2}, and for every 1 ≤ i ≤ k the relations R(ci) are defined as follows: R1 = {(0, 0), (1, 3), (1, 4), (2, 5)}, Ri = {(0, 0), (3(i−1), 3i), (3(i−1)+1, 3i+1), (3(i− 1)+2, 3i+2)} for every 1 < i < k, and Rk = {(0, 0), (1, 3(k−1)), (2, 3(k−1)+1), (1, 3(k−1)+1)}. Clearly, the instance is binary and every relation contains the all 0 tuple. Let φ be a minority polymorphism. Then, R1 implies f(3, 4, 5) = 5, which together with the relations Ri, for every 1 < i < k implies f(3i, 3i+1, 3i+2) = 3i+2. In particular, we obtain f(3(k− 1), 3(k− 1)+1, 3(k− 1)+2) = 3(k− 1)+2, which contradicts relation Rk. Hence, the set of all relations R1, . . . , Rk is not closed under any minority polymorphism. On the other hand, for any assignment τ that sets at least 1 variable of I(C, k), it holds that at least one relation of I(C, k)[τ ] contains at most 2 tuples. This relation is then closed under any minority polymorphism and breaks the above chain of implications. If C = MAL, we can use the same set of relations.\nTheorem 12. For every C ∈ {MIN, MAX, MAJ, MIN, MAL}, Strong C-Backdoor Detection and Weak C-Backdoor Detection are W[2]-hard even for CSP instances with arity 2.\nProof. The proof of the theorem is inspired by the proof of [3, Theorem 6]. We show the theorem via a fpt-reduction from Hitting Set. Let H = 〈U ,F , k〉 be an instance of Hitting Set.\nWe construct a CSP instance I = 〈V,D,C〉 of arity 2 such that H has a hitting set of size at most k if and only if I has a strong C-backdoor set of size at most k. The variables of I are { xu : u ∈ U } ∪ { yiF : F ∈ F and 1 ≤ i ≤ |F | }. Furthermore, for every F ∈ F with F = {u1, . . . , u|F |}, let I(F )\nbe the CSP instance obtained from I(C, |F |) (see Lemma 1), where for every i with 1 ≤ i ≤ |F |, we replace the scope of the constraint ci with 〈xui , y i F 〉 and adapt I(C, |F |) in such a way that for distinct F, F ′ ∈ F , I(C, |F |) and I(C, |F ′|) have no common domain value. Then, the constraints of I is the union of the constraints of I(F ) over every F ∈ F . This completes the construction of I. Clearly, I has arity 2 and is satisfiable, e.g., by the all 0 assignment.\nSuppose that H has a hitting set B of size at most k. We claim that Bu = { xu : u ∈ B } is a strong C-backdoor set of I. We start by showing that Bu is a strong C-backdoor set of I. Let τ : Bu → D be an assignment of the variables in B. Then, it follows from Lemma 1 that the constraints of I(F )[τ ] are in C. In particular, there is a polymorphism φ (which is either min, max, majority, minority or Mal’cev, depending on C) such that the constraints of I(F )[τ ] are closed under φ. Because for every distinct F, F ′ ∈ F , I(F )[τ ] and I(F ′)[τ ] do not have a common domain value, it follows that there is a polymorphism (which is a combination of the polymorphisms for each I(F )[τ ])) such that I[τ ] is closed under φ and φ is a min, max, majority, minority, or Mal’cev polymorphism (depending on C). Hence, I[τ ] ∈ C, as required. Towards showing that Bu is also a weak C-backdoor set of C consider the assignment τ : Bu → {0}. It follows from the above argumentation that I[τ ] ∈ C. Furthermore, I[τ ] is satisfiable, because every constraint of I[τ ] still contains the all 0 tuple.\nFor the reverse direction, suppose that I has a strong C-backdoor set B of size at most k. Because for every F ∈ F it holds that the set of constraints of I(F ) is not in C, we obtain that B has to contain at least 1 variable from V (I(F )) for every F ∈ F . Since the only variables that are shared between V (I(F )) and V (I(F ′)) for distinct F, F ′ ∈ F are the variables in { xu : u ∈ U }, it follows that H has a hitting set of size at most |B| ≤ k, as required."
    }, {
      "heading" : "7 Comparison to Partition-Backdoors",
      "text" : "In this section we draw a comparison between our notion of backdoor sets, and the approach recently introduced by Bessiere et al. (2013), which we will call the partition backdoor set approach. The main difference is that the partition backdoor set approach considers a backdoor with respect to a subset of constraints that is tractable (because it is closed under some tractable polymorphism). In particular, Bessiere et al. (2013) define partition backdoor sets as follows.\nDefinition 1. Let P be a nice polymorphism property. A P-partition backdoor of a CSP instance I = 〈V,D,C〉 is a set B of variables, such that there is a partition of C into C1 and C2 for which the following holds:\n• 〈V,D,C2〉 ∈ CP , and\n• If P is characterized using only idempotent polymorphisms, then B is the set of all variables in the scope of the constraints of C2, while if P is characterized using only conservative polymorphisms, then the variables of B are a vertex cover of the primal graph of C1.\nNote that the primal graph of a set C of constraints is the graph, whose vertices are all the variables appearing in the scope of the constraints in C and that has an edge between two variables if and only if they appear together in the scope of at least one constraint in C.\nThey show that given a CSP instance and a partition (C1, C2) as defined above, then the detection and evaluation of P-partition backdoor sets are fixed-parameter tractable\n• in the size of the domain and the number of variables in C1, if P is characterized using only idempotent polymorphisms;\n• in the size of the domain and the vertex cover of the primal graph of C1, if P is characterized using only conservative polymorphisms.\nObserve that the above tractability results only hold when the partition (C1, C2) is given as a part of the input, if it is not then the detection of partition backdoors is shown to be fixed-parameter intractable (for most combinations of parameters).\nApart from the complexity of detecting and evaluating backdoors it is also important that the backdoor sets are as small as possible over a wide variety of CSP instances. In the following we will observe that our backdoor sets are always at most as large as partition backdoors and we exhibit CSP instances where our backdoors have size one but the size of a smallest partition backdoor set grows with the number of variables of the CSP instance.\nProposition 2. Let P be a nice polymorphism property. Then, for every CSP instance I the size of a smallest strong P-backdoor set of I is at most the size of a smallest P-partition backdoor set of I.\nProof. This follows from the observation that any P-partition backdoor set is also a strong P-backdoor set.\nProposition 3. For any nice property P and any natural number n , there is a CSP instance that has a strong/weak CP-backdoor set of size one, but the size of a smallest P-partition backdoor set is Ω(n).\nProof. Let P be a nice property and let I = 〈V,D,C〉 be a CSP instance such that:\n• no constraint of I is closed under a polymorphism with property P;\n• all constraints of I share a common variable, say x, such that for any assignment τ of x, the CSP instance I[τ ] is closed under some polymorphisms with property P.\nIt is straightforward to check that for any number of variables n, such a CSP instance using n variables can be easily constructed for every nice property P that contains at least one polymorphism. Furthermore, the variable x is a strong CP-backdoor set of I. However, because no constraint of I is closed under any polymorphism from P it follows that every partition backdoor has to contain at least all but 1 variable from every constraint of I."
    }, {
      "heading" : "8 Summary",
      "text" : "We have introduced heterogeneous base classes and have shown that strong backdoor sets into such classes can be considerably smaller than strong backdoor sets into homogeneous base classes; nevertheless, the detection of strong backdoor sets into homogeneous base classes is still fixed-parameter tractable in many natural cases. Hence, our results push the tractability boundary considerably further. Our theoretical evaluation entails hardness results that establish the limits for tractability.\nOur main result in the context of SAT (Theorem 5) provides a complete complexity classification for strong backdoor set detection to heterogeneous base classes composed of the well-known Schaefer classes. We observe that the hardness results rely on clauses of unbounded length. In a follow-up result, we also show that strong as well as weak backdoor set detection into any combination of the Schaefer classes is fixed-parameter tractable for the combined parameter backdoor set size and the maximum length of the clauses (Theorem 6).\nOur main result for CSP backdoors (Theorem 9) establishes fixed-parameter tractability for a wide range of heterogeneous base classes composed of possibly infinitely many tractable polymorphisms. In particular, we show that the detection of strong as well as weak backdoor sets is fixed-parameter tractable for the combined parameter backdoor size, domain size, and the maximum arity of constraints. In fact, this result entails heterogeneous base classes, as different instantiations of the backdoor variables can lead to reduced instances that are closed under different polymorphisms (even polymorphisms of different type). We complement our main result with hardness results that show that we loose fixed-parameter tractability when we omit either domain size or the maximum arity of constraints from the parameter (Theorems 11 and 12).\nIt would be interesting to extend our line of research to the study of backdoor sets into heterogeneous base classes composed of homogeneous classes defined by global properties, in contrast to the Schaefer classes for SAT, and polymorphism-based classes for CSP."
    }, {
      "heading" : "Acknowledgments",
      "text" : "Gaspers is the recipient of an Australian Research Council Discovery Early Career Researcher Award (project number DE120101761). NICTA is funded by the Australian Government as represented by the Department of Broadband, Communications and the Digital Economy and the Australian Research Council through the ICT Centre of Excellence program. Misra is supported by the INSPIRE Faculty Scheme, DST India (project DSTO-1209). Ordyniak acknowledges support from the Employment of Newly Graduated Doctors of Science for Scientific Excellence (CZ.1.07/2.3.00/30.0009). Ordyniak and Szeider were supported by the European Research Council, grant reference 239962 (COMPLEX REASON) and the Austrian Science Funds (FWF), project I836-N23 (Algorithms and Complexity of Constraint Languages) and project P26696 (Exploiting New Types of Structure for Fixed Parameter Tractability). Živný is supported by a Royal Society University Research Fellowship."
    } ],
    "references" : [ {
      "title" : "Constraint satisfaction problem and universal algebra",
      "author" : [ "Libor Barto" ],
      "venue" : "ACM SIGLOG News,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2014
    }, {
      "title" : "Constraint Satisfaction Problems Solvable by Local Consistency Methods",
      "author" : [ "Libor Barto", "Marcin Kozik" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2014
    }, {
      "title" : "Detecting and exploiting subproblem tractability",
      "author" : [ "Christian Bessiere", "Clément Carbonnel", "Emmanuel Hebrard", "George Katsirelos", "Toby Walsh" ],
      "venue" : "IJCAI 2013, Proceedings of the 23rd International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2013
    }, {
      "title" : "A simple algorithm for mal’tsev constraints",
      "author" : [ "Andrei A. Bulatov", "Vı́ctor Dalmau" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2006
    }, {
      "title" : "On backdoors to tractable constraint languages",
      "author" : [ "Clément Carbonnel", "Martin C. Cooper", "Emmanuel Hebrard" ],
      "venue" : "Principles and Practice of Constraint Programming - 20th International Conference,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2014
    }, {
      "title" : "Tractability in constraint satisfaction problems: a survey",
      "author" : [ "Clment Carbonnel", "MartinC. Cooper" ],
      "venue" : "Constraints, pages",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2015
    }, {
      "title" : "Tradeoffs in the complexity of backdoor detection",
      "author" : [ "Bistra N. Dilkina", "Carla P. Gomes", "Ashish Sabharwal" ],
      "venue" : "In Principles and Practice of Constraint Programming - CP 2007, 13th International Conference,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2007
    }, {
      "title" : "Backdoors in the context of learning",
      "author" : [ "Bistra N. Dilkina", "Carla P. Gomes", "Ashish Sabharwal" ],
      "venue" : "In Oliver Kullmann, editor, Theory and Applications of Satisfiability Testing - SAT 2009, 12th International Conference,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Fundamentals of Parameterized Complexity",
      "author" : [ "Rodney G. Downey", "Michael R. Fellows" ],
      "venue" : "Texts in Computer Science. Springer Verlag,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2013
    }, {
      "title" : "Augmenting tractable fragments of abstract argumentation",
      "author" : [ "Wolfgang Dvorák", "Sebastian Ordyniak", "Stefan Szeider" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2012
    }, {
      "title" : "Discovering archipelagos of tractability for constraint satisfaction and counting",
      "author" : [ "Robert Ganian", "M.S. Ramanujan", "Stefan Szeider" ],
      "venue" : "Accepted at SODA 2016, the ACM-SIAM Symposium on Discrete Algorithms,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2016
    }, {
      "title" : "Backdoors to satisfaction",
      "author" : [ "Serge Gaspers", "Stefan Szeider" ],
      "venue" : "Essays Dedicated to Michael R. Fellows on the Occasion of His 60th Birthday,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2012
    }, {
      "title" : "Strong backdoors to bounded treewidth SAT",
      "author" : [ "Serge Gaspers", "Stefan Szeider" ],
      "venue" : "In 54th Annual IEEE Symposium on Foundations of Computer Science,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2013
    }, {
      "title" : "Tractability and learnability arising from algebras with few subpowers",
      "author" : [ "Pawel M. Idziak", "Petar Markovic", "Ralph McKenzie", "Matthew Valeriote", "Ross Willard" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2010
    }, {
      "title" : "Closure properties of constraints",
      "author" : [ "Peter Jeavons", "David Cohen", "Marc Gyssens" ],
      "venue" : "J. of the ACM,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1997
    }, {
      "title" : "The Art of Computer Programming, Volume IVa: Combinatorial Algorithms",
      "author" : [ "Donald E. Knuth" ],
      "venue" : "Part 1. Addison-Wesley,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2011
    }, {
      "title" : "A new bound for an NP-hard subclass of 3-SAT using backdoors",
      "author" : [ "Stephan Kottler", "Michael Kaufmann", "Carsten Sinz" ],
      "venue" : "Theory and Applications of Satisfiability Testing - SAT 2008, 11th International Conference,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2008
    }, {
      "title" : "Backdoors to planning",
      "author" : [ "Martin Kronegger", "Sebastian Ordyniak", "Andreas Pfandler" ],
      "venue" : "Proceedings of the Twenty-Eighth AAAI Conference on Artificial Intelligence, July",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Variable-deletion backdoors to planning",
      "author" : [ "Martin Kronegger", "Sebastian Ordyniak", "Andreas Pfandler" ],
      "venue" : "In Proceedings of the Twenty-Ninth AAAI Conference on Artificial Intelligence, January",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Crowdsourcing backdoor identification for combinatorial optimization",
      "author" : [ "Ronan LeBras", "Richard Bernstein", "Carla P. Gomes", "Bart Selman", "R. Bruce van Dover" ],
      "venue" : "IJCAI 2013, Proceedings of the 23rd International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2013
    }, {
      "title" : "Detecting backdoor sets with respect to Horn and binary clauses",
      "author" : [ "Naomi Nishimura", "Prabhakar Ragde", "Stefan Szeider" ],
      "venue" : "In Proceedings of SAT 2004 (Seventh International Conference on Theory and Applications of Satisfiability Testing,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2004
    }, {
      "title" : "Backdoors to abduction",
      "author" : [ "Andreas Pfandler", "Stefan Rümmele", "Stefan Szeider" ],
      "venue" : "In Proceedings of IJCAI 2013, the 23th International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2013
    }, {
      "title" : "The backdoor key: A path to understanding problem hardness",
      "author" : [ "Yongshao Ruan", "Henry A. Kautz", "Eric Horvitz" ],
      "venue" : "Proceedings of the 19th National Conference on Artificial Intelligence, 16th Conference on Innovative Applications of Artificial Intelligence,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2004
    }, {
      "title" : "Fixed-parameter tractability",
      "author" : [ "Marko Samer", "Stefan Szeider" ],
      "venue" : "Handbook of Satisfiability,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2009
    }, {
      "title" : "Backdoor sets of quantified Boolean formulas",
      "author" : [ "Marko Samer", "Stefan Szeider" ],
      "venue" : "Journal of Automated Reasoning,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2009
    }, {
      "title" : "The complexity of satisfiability problems",
      "author" : [ "Thomas J. Schaefer" ],
      "venue" : "In Conference Record of the Tenth Annual ACM Symposium on Theory of Computing (San Diego, Calif.,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1978
    }, {
      "title" : "Matched formulas and backdoor sets",
      "author" : [ "Stefan Szeider" ],
      "venue" : "J on Satisfiability, Boolean Modeling and Computation,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2008
    }, {
      "title" : "Backdoors to typical case complexity",
      "author" : [ "Ryan Williams", "Carla Gomes", "Bart Selman" ],
      "venue" : "Proceedings of the Eighteenth International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2003
    }, {
      "title" : "On the connections between backdoors, restarts, and heavy-tailedness in combinatorial search",
      "author" : [ "Ryan Williams", "Carla Gomes", "Bart Selman" ],
      "venue" : "In Informal Proc. of the Sixth International Conference on Theory and Applications of Satisfiability Testing, S. Margherita Ligure - Portofino,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 27,
      "context" : "Backdoor sets were originally introduced by Williams, Gomes, and Selman ([28, 29]) as a tool for the analysis of decision heuristics in propositional satisfiability.",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 28,
      "context" : "Backdoor sets were originally introduced by Williams, Gomes, and Selman ([28, 29]) as a tool for the analysis of decision heuristics in propositional satisfiability.",
      "startOffset" : 73,
      "endOffset" : 81
    }, {
      "referenceID" : 6,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 93,
      "endOffset" : 119
    }, {
      "referenceID" : 7,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 93,
      "endOffset" : 119
    }, {
      "referenceID" : 12,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 93,
      "endOffset" : 119
    }, {
      "referenceID" : 16,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 93,
      "endOffset" : 119
    }, {
      "referenceID" : 22,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 93,
      "endOffset" : 119
    }, {
      "referenceID" : 23,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 93,
      "endOffset" : 119
    }, {
      "referenceID" : 27,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 93,
      "endOffset" : 119
    }, {
      "referenceID" : 19,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 153,
      "endOffset" : 157
    }, {
      "referenceID" : 21,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 9,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 24,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 233,
      "endOffset" : 237
    }, {
      "referenceID" : 17,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 252,
      "endOffset" : 260
    }, {
      "referenceID" : 18,
      "context" : "Since then, backdoor sets have been widely used in the areas of propositional satisfiability [7, 8, 13, 17, 23, 24, 28], and also for material discovery [20], abductive reasoning [22], argumentation [10], quantified Boolean formulas [25], and planning [18, 19].",
      "startOffset" : 252,
      "endOffset" : 260
    }, {
      "referenceID" : 20,
      "context" : "[21] for SAT, who showed that the detection of strong backdoor sets into the classes HORN and 2CNF is fixed-parameter tractable, but the detection of weak backdoor sets into any of these two classes is W[2]-hard (and hence unlikely to be fixed-parameter tractable).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 1,
      "context" : "[21] for SAT, who showed that the detection of strong backdoor sets into the classes HORN and 2CNF is fixed-parameter tractable, but the detection of weak backdoor sets into any of these two classes is W[2]-hard (and hence unlikely to be fixed-parameter tractable).",
      "startOffset" : 203,
      "endOffset" : 206
    }, {
      "referenceID" : 11,
      "context" : "Since then, the parameterized complexity of backdoor set detection has become an active research topic as outlined in a survey [12].",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 25,
      "context" : "In this work, we completely characterize the complexity landscape for heterogeneous base classes obtained arbitrary combinations of the well-known Schaefer classes [26], in the following denoted by HORN (for Horn formulas), HORN (for Anti-Horn formulas), 2CNF (for 2-CNF formulas), 0-VAL (for zero valid formulas), and 1-VAL (for one valid formulas).",
      "startOffset" : 164,
      "endOffset" : 168
    }, {
      "referenceID" : 1,
      "context" : "Our main result for SAT backdoor sets (Theorem 5) is that Strong C-Backdoor Detection is fixed parameter tractable if and only if S does not contain a bad pair of Schaefer classes, otherwise it is W[2]-hard.",
      "startOffset" : 198,
      "endOffset" : 201
    }, {
      "referenceID" : 1,
      "context" : "On the other hand, detecting weak backdoors is always W[2]-hard for any choice of C, and we show this by building on the known hardness results for when C is a singleton set (Theorem 7).",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 25,
      "context" : "A prominent line of research, initiated by Schaefer [26] in his seminal paper on Boolean CSP, is to identify tractable classes by restricting the relations that may appear in constraints to a prescribed set, a constraint language.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "Today, many constraint languages have been identified that give rise to tractable classes of CSPs [2, 4, 14]; typically such languages are defined in terms of certain closure properties, which ensure that the relations are closed under pointwise application of certain polymorphisms of the domain.",
      "startOffset" : 98,
      "endOffset" : 108
    }, {
      "referenceID" : 3,
      "context" : "Today, many constraint languages have been identified that give rise to tractable classes of CSPs [2, 4, 14]; typically such languages are defined in terms of certain closure properties, which ensure that the relations are closed under pointwise application of certain polymorphisms of the domain.",
      "startOffset" : 98,
      "endOffset" : 108
    }, {
      "referenceID" : 13,
      "context" : "Today, many constraint languages have been identified that give rise to tractable classes of CSPs [2, 4, 14]; typically such languages are defined in terms of certain closure properties, which ensure that the relations are closed under pointwise application of certain polymorphisms of the domain.",
      "startOffset" : 98,
      "endOffset" : 108
    }, {
      "referenceID" : 0,
      "context" : "Further examples of polymorphisms for which closure properties yield tractable CSP are min, max, majority, affine, and Mal’cev polymorphisms [1, 15].",
      "startOffset" : 141,
      "endOffset" : 148
    }, {
      "referenceID" : 14,
      "context" : "Further examples of polymorphisms for which closure properties yield tractable CSP are min, max, majority, affine, and Mal’cev polymorphisms [1, 15].",
      "startOffset" : 141,
      "endOffset" : 148
    }, {
      "referenceID" : 4,
      "context" : "Related Work Recently, two papers dealing with strong backdoor set detection for the constraint satisfaction problem have appeared [5, 11], which nicely supplement (however are mostly orthogonal to) the results in this paper.",
      "startOffset" : 131,
      "endOffset" : 138
    }, {
      "referenceID" : 10,
      "context" : "Related Work Recently, two papers dealing with strong backdoor set detection for the constraint satisfaction problem have appeared [5, 11], which nicely supplement (however are mostly orthogonal to) the results in this paper.",
      "startOffset" : 131,
      "endOffset" : 138
    }, {
      "referenceID" : 4,
      "context" : "[5] show W[2]-hardness for strong backdoor set detection parameterized by the size of the backdoor set even for CSP-instances with only one constraint (however with unbounded domain and unbounded arity).",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "[5] show W[2]-hardness for strong backdoor set detection parameterized by the size of the backdoor set even for CSP-instances with only one constraint (however with unbounded domain and unbounded arity).",
      "startOffset" : 10,
      "endOffset" : 13
    }, {
      "referenceID" : 5,
      "context" : "However, as is also mentioned in Carbonnel and Cooper [6], the “h-Helly” property is rather restrictive and orthogonal to our approach of considering the domain as an additional parameter.",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 10,
      "context" : "[11] show fixed-parameter tractability of strong backdoor detection parameterized by the size of the backdoor to a very general family of heterogeneous base classes, i.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 8,
      "context" : "Parameterized Complexity We provide basic definitions of parameterized complexity; for an indepth treatment we refer to the recent monograph [9].",
      "startOffset" : 141,
      "endOffset" : 144
    }, {
      "referenceID" : 0,
      "context" : "The so-called Weft-hierarchy W[1] ⊆ W[2] ⊆ .",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 1,
      "context" : "The so-called Weft-hierarchy W[1] ⊆ W[2] ⊆ .",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 1,
      "context" : "For instance, the following problem is well-known to be W[2]-complete [9].",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 8,
      "context" : "For instance, the following problem is well-known to be W[2]-complete [9].",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 25,
      "context" : "Schaefer’s base classes [26] give rise to classes of CNF formulas defined in terms of syntactical properties of clauses.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 11,
      "context" : "Strong C-Backdoor Detection is polynomial for 0-VAL and 1-VAL, and FPT for the remaining Schaefer classes [12, 21].",
      "startOffset" : 106,
      "endOffset" : 114
    }, {
      "referenceID" : 20,
      "context" : "Strong C-Backdoor Detection is polynomial for 0-VAL and 1-VAL, and FPT for the remaining Schaefer classes [12, 21].",
      "startOffset" : 106,
      "endOffset" : 114
    }, {
      "referenceID" : 11,
      "context" : "It is well-known that, for C ∈ {HORN,HORN, 2CNF}, every strong C-backdoor set contains a variable from each C-obstruction for each clause in the formula [12, 21].",
      "startOffset" : 153,
      "endOffset" : 161
    }, {
      "referenceID" : 20,
      "context" : "It is well-known that, for C ∈ {HORN,HORN, 2CNF}, every strong C-backdoor set contains a variable from each C-obstruction for each clause in the formula [12, 21].",
      "startOffset" : 153,
      "endOffset" : 161
    }, {
      "referenceID" : 15,
      "context" : "A clause containing exactly two literals is also known as a Krom clause [16].",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 1,
      "context" : "For every S ⊆ Schaefer that contains at least one bad pair of Schaefer classes, it holds that Strong C-Backdoor Detection is W[2]-hard, where C = ⋃ s∈S s.",
      "startOffset" : 126,
      "endOffset" : 129
    }, {
      "referenceID" : 1,
      "context" : "We give a parameterized reduction from the W[2]-complete Hitting Set problem.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 1,
      "context" : "Then, Strong C-Backdoor Detection is fixed parameter tractable if and only if S does not contain a bad pair of Schaefer classes, otherwise it is W[2]-hard.",
      "startOffset" : 146,
      "endOffset" : 149
    }, {
      "referenceID" : 11,
      "context" : "• if |S| = 1, then the theorem follows from known results, see, for example, [12, 21].",
      "startOffset" : 77,
      "endOffset" : 85
    }, {
      "referenceID" : 20,
      "context" : "• if |S| = 1, then the theorem follows from known results, see, for example, [12, 21].",
      "startOffset" : 77,
      "endOffset" : 85
    }, {
      "referenceID" : 1,
      "context" : "Then, Weak C-Backdoor Detection is W[2]-hard.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 6,
      "context" : "We close this section by noting that backdoor sets with empty clause detection, as proposed by [7] can be considered as backdoor sets into the heterogeneous base class obtained by the union of a homogeneous base class C and the class of all formulas that contain the empty clause.",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 26,
      "context" : "The detection of strong backdoor sets with empty clause detection is not fixed-parameter tractable for many natural base classes, including Horn and 2CNF [27].",
      "startOffset" : 154,
      "endOffset" : 158
    }, {
      "referenceID" : 0,
      "context" : ", tn fromR, the tuple 〈φ(t1[1], .",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : ", tn[1]), .",
      "startOffset" : 4,
      "endOffset" : 7
    }, {
      "referenceID" : 3,
      "context" : "It is known that every constant, min/max, majority, minority, and Mal’cev polymorphism is tractable [4, 15].",
      "startOffset" : 100,
      "endOffset" : 107
    }, {
      "referenceID" : 14,
      "context" : "It is known that every constant, min/max, majority, minority, and Mal’cev polymorphism is tractable [4, 15].",
      "startOffset" : 100,
      "endOffset" : 107
    }, {
      "referenceID" : 14,
      "context" : "In terms of the above definitions we can state the results of [15] and [4] as follows.",
      "startOffset" : 62,
      "endOffset" : 66
    }, {
      "referenceID" : 3,
      "context" : "In terms of the above definitions we can state the results of [15] and [4] as follows.",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 1,
      "context" : "In particular, we show that Strong CP-Backdoor Detection and Weak CP-Backdoor Detection are W[2]-hard parameterized by the size of the backdoor set",
      "startOffset" : 93,
      "endOffset" : 96
    }, {
      "referenceID" : 1,
      "context" : "Then, Strong CP-Backdoor Detection and Weak CP-Backdoor Detection are W[2]-hard parameterized by the size of the backdoor set, even for CSP instances over the Boolean domain.",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 0,
      "context" : "ti[1], .",
      "startOffset" : 2,
      "endOffset" : 5
    }, {
      "referenceID" : 1,
      "context" : "For every C ∈ {MIN, MAX, MAJ, MIN, MAL}, Strong C-Backdoor Detection and Weak C-Backdoor Detection are W[2]-hard parameterized by the size of the backdoor set, even for CSP instances over the Boolean domain.",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 1,
      "context" : "For every C ∈ {MIN, MAX, MAJ, MIN, MAL}, Strong C-Backdoor Detection and Weak C-Backdoor Detection are W[2]-hard even for CSP instances with arity 2.",
      "startOffset" : 104,
      "endOffset" : 107
    } ],
    "year" : 2017,
    "abstractText" : "In this paper we extend the classical notion of strong and weak backdoor sets by allowing that different instantiations of the backdoor variables result in instances that belong to different base classes; the union of the base classes forms a heterogeneous base class. Backdoor sets to heterogeneous base classes can be much smaller than backdoor sets to homogeneous ones, hence they are much more desirable but possibly harder to find. We draw a detailed complexity landscape for the problem of detecting strong and weak backdoor sets into heterogeneous base classes for SAT",
    "creator" : "LaTeX with hyperref package"
  }
}