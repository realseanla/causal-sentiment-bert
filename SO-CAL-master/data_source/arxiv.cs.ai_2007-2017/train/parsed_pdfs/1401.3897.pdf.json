{
  "name" : "1401.3897.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Interpolable Formulas in Equilibrium Logic and Answer Set Programming",
    "authors" : [ "Dov Gabbay", "David Pearce" ],
    "emails" : [ "dov.gabbay@kcl.ac.uk", "david.pearce@upm.es", "valverde@ctima.uma.es" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "The interpolation property is an important and much discussed topic in logical systems, both classical and non-classical (Gabbay & Maksimova, 2005). Its importance in computer science is also becoming recognised nowadays. The interpolation property has been applied in various areas of computer science, for example in software specification (Diaconescu, Goguen, & Stefaneas, 1993; Bicarregui, Dimitrakos, Gabbay, & Maibaum, 2001), in the construction of formal ontologies (Kontchakov, Wolter, & Zakharyaschev, 2008) and in model checking and related subareas (McMillan, 2005). In the first two areas interpolation is important as a metatheoretical property, in particular it may provide a basis for the modular composition and decomposition of theories; for instance, for Kontchakov et al. (2008) it plays a key role in the study of the modular decomposition of ontologies. In other cases, interpolants themselves play a role as special formulas applied in automated deduction (McMillan, 2005).\nTo date interpolation has received much less attention in systems of non-monotonic reasoning and logic programming, despite their importance in AI and computer science. In this note we study the interpolation property for the system of nonmonotonic reasoning known as equilibrium logic (Pearce, 2006). Since this in turn can be regarded as a logical foundation for stable model reasoning and answer set programming (ASP), our results transfer immediately to the sphere of ASP. We shall focus here mainly on interpolation as a\nc©2011 AI Access Foundation. All rights reserved.\nmetatheoretical property and our primary interest is in establishing this property for certain cases of interest. Although in Section 8 we consider a case where an interpolant (actually a uniform interpolant) is explicitly constructed, we are mainly concerned here with pure existence theorems. Discussion of complexity issues as well as possible applications of the interpolation property in ASP are left to future work. However, it seems likely that, as in the case of studies involving formal ontologies (Konev, Walther, & Wolter, 2009), interpolation may be a useful property for applications of ASP in knowledge representation. In a previous paper (Pearce & Valverde, 2012), the interpolation and Beth properties of the underlying, monotonic logic of ASP were used to characterise strong kinds of intertheory relations. To capture weaker kinds of intertheory relations it may be important to be able to rely on interpolation holding in the extended, non-monotonic logic. We plan to explore this avenue in the future.\nTo introduce the property of interpolation, let us start with some notation and terminology. Let us assume the syntax of first-order logic with formulas denoted by lower case Greek letters and predicates by lower case Latin letters.\nLet ⊢ be a monotonic inference relation and suppose that α ⊢ β. An interpolant for (α, β) is a formula γ such that\nα ⊢ γ & γ ⊢ β (1)\nwhere γ contains only predicate and constant symbols that belong to both α and β. A logic L with inference relation ⊢L is said to have the interpolation property if an interpolant exists for every pair of formulas (α, β) such that α ⊢L β. As is well-known, classical logic as well as many non-classical logics possess interpolation.\nSuppose now we deal with a non-monotonic logical system with an inference relation |∼. To express the idea that a formula is an interpolant it will not generally suffice simply to replace ⊢ by |∼ in (1). One problem is that, since |∼ is non-monotonic, it is in general not transitive. Instead, following the idea of Gabbay and Maksimova (2005), we can modify condition (1) and proceed in a two-stage fashion. We make use of the fact that nonmonotonic consequence can be defined in terms of minimal models in some monotonic logical system, say that the consequence relation |∼ is appropriately captured by means of minimal models in a logic L with consequence relation |=L. Now suppose that α |∼β. Then as an interpolant for (α, β) we look for a formula γ such that\nα |∼ γ & γ |=L β (2)\nwhere all predicate and constant symbols of γ occur in both α and β. Since |∼ is to be defined via a subclass of minimal L-models, we already assume that |=L⊆ |∼. Moreover we should assume too that L is a well-behaved sublogic in the sense that L-equivalent formulas have the same |∼-consequences and that the L-consequences of |∼-consequences are themselves |∼-consequences (so e.g. from (2) we can derive α |∼ β). In non-monotonic reasoning these last two properties are known as left and right absorption, respectively. Given these conditions, it follows at once from (2) that any formula in the language of γ that is L-equivalent to γ will also be an interpolant for (α, β). Likewise if γ is an interpolant for (α, β) and β |=L δ then α |∼ δ and γ is an interpolant for (α, δ).\nNow, to find an interpolant for (α, β) satisfying (2), or to prove that one always exists, we can proceed as follows. We look for an L-formula α′ say, that precisely L-defines the\nminimal models of α. Since α |∼ β it follows that α′ |=L β. Now, if L has the interpolation property as defined earlier, we apply this theorem to obtain or infer the existence of an L-interpolant γ in the sense of (1) for (α′, β). Hence (2) follows.\nNotice that this two-stage procedure relies on three key features: (i) that we can identify a suitable monotonic sublogic L for |∼, (ii) that a formula’s minimal models are L-definable, and (iii) that L has the interpolation property. These conditions are prima facie independent. As we shall see, we may have (i) and (iii) but lack (ii). The situation with respect to equilibrium logic is as follows. In the propositional case all three conditions are met, so we can establish the interpolation property in the general case. The situation for quantified equilibrium logic is more complicated. In the general case, we lack condition (ii). More precisely, we have an appropriate monotonic sublogic L and this logic has the interpolation property, but the equilibrium models of a formula need not be first-order definable in L. So the procedure outlined does not yield interpolants in all cases. However some recent results on a generalised concept of (first-order) stable model imply that there are interesting classes of interpolable formulas: we shall consider in more detail one such class, that of safe formulas. In particular, if α is a safe formula and α |∼ β, then there exists an interpolant γ such that (2) holds. Other classes of interpolable formulas are so-called tight formulas, and formulas possessing a finite, complete set of what are called loops.\nSafety, tightness and loop formulas have been studied at some length in answer set programming (ASP). The implications of these results for ASP can be summarised as follows. In the case of (finite) ground programs the interpolation property holds. In the first-order or non-ground case, interpolation holds for finite, safe programs without function symbols, and hence practically for all finite programs currently admitted by answer set solvers. Moreover, since safety is now defined for arbitrary formulas in a function-free language, the class of safe formulas in this sense goes beyond the class of expressions normally admitted in ASP, even if auxiliary concepts like weight constraints and aggregates are included."
    }, {
      "heading" : "2. Logical Preliminaries",
      "text" : "We work with standard propositional and predicate languages, where the latter may in the general case contain constant and function symbols. Propositional languages are based on a set V of propositional variables, and formulas are built-up in the usual way using the logical constants ∧, ∨, →, ¬, standing respectively for conjunction, disjunction, implication and negation. If ϕ is a propositional formula, we denote by V (ϕ) the set of propositional variables appearing in ϕ.\nA first-order language L = 〈C,F, P 〉 consists of a set of constants C, function symbols F and predicate symbols P ; each function symbol f in F and predicate symbol p ∈ P has an assigned arity. Moreover, we assume a fixed countably infinite set of variables, the symbols ‘→’, ‘∨’, ‘∧’, ‘¬’, ‘∃’, ‘∀’, and auxiliary parentheses ‘(’, ‘)’. Atoms, terms and formulas are constructed as usual; closed formulas, or sentences, are those where each variable is bound by some quantifier. If ϕ is a (first-order) formula, L(ϕ) denotes the language associated with ϕ, i.e. the set of constants, function and predicate symbols occuring in it.\nWe make use of the following notation and terminology. Boldface x stands for a tuple of variables, x = (x1, . . . , xn), while ϕ(x) = ϕ(x1, . . . , xn) is a formula whose free variables\nare x1,. . . , xn, and ∀x = ∀x1 . . . ∀xn. If ti are terms, then t = (t1, . . . , tn) denotes a vector of terms. A theory Π is a set of sentences. Variable-free terms, atoms, formulas, or theories are also called ground.\nAs usual the symbols ⊢ and |=, possibly with subscripts, are used to denote logical inference and consequence relations, respectively. A logic L is said to be monotonic if its inference relation ⊢L satisfies the monotonicity property:\nΠ ⊢L ϕ & Π ⊆ Π ′ ⇒ Π′ ⊢L ϕ\nTo distinguish non-monotonic from monotonic inference relations, we use |∼ to symbolise the former. In most cases a non-monotonic logic can be understood in terms of an inference relation that extends a suitable monotonic logic. When this extension is well-behaved we say that the monotonic logic forms a deductive base1 (Pearce, 2006) for it. This can be made precise as follows.\nDefinition 1 Let |∼ be any nonmonotonic inference relation. We say that a logic L with monotonic inference relation ⊢L is a deductive base for |∼ iff (i) ⊢L⊆ |∼; (ii) If Π1 ≡L Π2 then Π1 ≈ Π2; (iii) If Π |∼ ϕ and ϕ ⊢L ψ, then Π |∼ ψ.\nHere ≡L denotes ordinary logical equivalence in L, while ≈ denotes non-monotonic equivalence, i.e. Π1 ≈ Π2 means that Π1 and Π2 have the same non-monotonic consequences. Furthermore, we say that a deductive base is strong if it satisfies the additional condition:\nΠ1 6≡L Π2 ⇒ there exists Γ such that Π1 ∪ Γ 6≈ Π2 ∪ Γ.\nIn terms of nonmonotonic consequence operations, (ii) and (iii) correspond to conditions known as left absorption and right absorption respectively (Makinson, 1994)."
    }, {
      "heading" : "2.1 Interpolation",
      "text" : "We now turn to the interpolation property.\nDefinition 2 A logic L with inference relation ⊢L is said to have the interpolation property if whenever\n⊢L ϕ→ ψ\nthere exists a sentence ξ (the interpolant) such that\n⊢L ϕ→ ξ & ⊢L ξ → ψ\nwhere all predicate, function and constant symbols of ξ are contained in both ϕ and ψ, i.e. L(ξ) ⊆ L(ϕ) ∩ L(ψ). In the case of propositional logic, the requirement is that V (ξ) ⊆ V (ϕ) ∩ V (ψ).\nAs explained in the introduction, for non-monotonic logics we can consider two forms of interpolation, one weaker one stronger. The stronger form makes use of an underlying monotonic logic.\n1. It is close to the concept of fully absorbing inferential frame used by Dietrich (1994).\nDefinition 3 Suppose that α |∼β. A (|∼,⊢L) interpolant for (α, β) is a formula γ such that\nα |∼ γ & γ ⊢L β (3)\nwhere L is a deductive base for |∼ and γ contains only predicate, function and constant symbols that belong to both α and β. A non-monotonic logic with inference relation |∼ is said to have the (|∼,⊢) interpolation property if for a suitable deductive base logic L an (|∼,⊢L) interpolant exists for every pair of formulas (α, β) such that α |∼ β.\nThe requirement that L form a deductive base ensures that some desirable properties of interpolation are met.\nProposition 1 Let γ be a (|∼,⊢L) interpolant for (α, β). (a) For any ψ such that ψ ≡L γ, ψ is a (|∼,⊢L) interpolant for (α, β). (b) For any α′ such that α ≡L α ′, and any β′ such that β ⊢L β ′, γ is a (|∼,⊢L) interpolant for (α′, β′).\nThe property of deductive base also guarantees that the (|∼,⊢L) relation is transitive in the sense that if (3) holds for any α, β, γ, then also α |∼β. This last property will not necessarily hold for the second, weaker form of interpolation that we call (|∼, |∼) interpolation.\nDefinition 4 Suppose that α |∼β. A (|∼, |∼) interpolant for (α, β) is a formula γ such that\nα |∼ γ & γ |∼ β (4)\nwhere γ contains only predicate, function and constant symbols that belong to both α and β. In the case of propositional logic, the requirement is that V (ξ) ⊆ V (ϕ) ∩ V (ψ).\nAnalogous to the previous case, we say that a non-monotonic logic with inference relation |∼ has the (|∼, |∼) interpolation property if a (|∼, |∼) interpolant exists for every pair of formulas (α, β) such that α |∼ β. Notice that (|∼,⊢) is the stronger form of interpolation because if a logic has (|∼,⊢) interpolation it must also have (|∼, |∼) interpolation, again as a consequence of the deductive base requirement (first clause).\nEvidently the properties expressed in Proposition 1 are not directly applicable to the second form of interpolation that does not refer to any underlying base logic. Nevertheless an important feature of the interpolation properties we shall establish below is that we can formulate and prove analogous properties even for (|∼, |∼) interpolation.\nWe can also consider restricted variants of interpolation when the property holds for certain types of formulas, in other words, when there is an interpolant for (α, β) given α |∼ β whenever α and β belong to specific syntactic classes. In such cases we can refer to interpolable formulas. Later on we shall consider both kinds of restrictions, where α belongs to a specific class or alternatively when β does."
    }, {
      "heading" : "2.2 Review of the Logic of Here-and-There",
      "text" : "Equilibrium logic is based on the nonclassical logic of here-and-there, which we denote by HT in the propositional case. In the quantified or first-order case we denote the logic by QHT, with subscripts/superscripts to denote specific variants.\nIn both propositional and quantified cases the logic is based on the axioms and rules of intuitionistic logic and is captured by the usual Kripke semantics for intuitionistic logic (van Dalen, 1997). However the additional axioms of HT and QHT mean that we can use very simple kinds of Kripke structures. In the first-order case we regard these structures as sets of atoms built over arbitrary non-empty domains D; we denote by At(D,F, P ) the set of atomic sentences of 〈D,F, P 〉 (if D = C, we obtain the set of atomic sentence of the language L = 〈C,F, P 〉);2 and we denote by T (D,F ) the set of ground terms of 〈D,F, P 〉. If L = 〈C,F, P 〉 and L′ = 〈C ′, F ′, P ′〉, we write L ⊆ L′ if C ⊆ C ′, F ⊆ F ′ and P ⊆ P ′.\nBy an L-interpretation over a set D we mean a subset of At(D,F, P ). A classical Lstructure can be regarded as a tuple I = 〈(D, I), I∗〉 where I∗ is an L-interpretation over D and I : T (C ∪D,F ) → D, called the assignment, verifies that I(d) = d for all d ∈ D and is recursively defined.3 If D = T (C,F ) and I = id, I is known as an Herbrand structure. On the other hand, a here-and-there L-structure with static domains, or QHTs(L)-structure, is a tuple I = 〈(D, I), Ih, It〉 where 〈(D, I), Ih〉 and 〈(D, I), It〉 are classical L-structures such that Ih ⊆ It.\nThus we can think of a here-and-there structure I as similar to a first-order classical model, but having two parts, or components, h and t that correspond to two different points or “worlds”, ‘here’ and ‘there’, in the sense of Kripke semantics for intuitionistic logic, where the worlds are ordered by h ≤ t. At each world w ∈ {h, t} one verifies a set of atoms Iw in the expanded language for the domain D. We call the model static, since, in contrast to say intuitionistic logic, the same domain serves each of the worlds. Since h < t, whatever is verified at h remains true at t. The satisfaction relation for I is defined so as to reflect the two different components, so we write I, w |= ϕ to denote that ϕ is true in I with respect to the w component. Although we only need to define the satisfaction relation in L = 〈C,P 〉, the recursive definition forces us to consider formulas from 〈C ∪ D,F, P 〉. In particular, if p(t1, . . . , tn) ∈ At(C ∪ D,F, P ) then I, w |= p(t1, . . . , tn) iff p(I(t1), . . . , I(tn)) ∈ I\nw for every t1, . . . , tn ∈ T (C ∪D,F ). Then |= is extended recursively as follows 4:\n• I, w |= ϕ ∧ ψ iff I, w |= ϕ and I, w |= ψ.\n• I, w |= ϕ ∨ ψ iff I, w |= ϕ or I, w |= ψ.\n• I, t |= ϕ→ ψ iff I, t 6|= ϕ or I, t |= ψ.\n• I, h |= ϕ→ ψ iff I, t |= ϕ→ ψ and I, h 6|= ϕ or I, h |= ψ.\n• I, w |= ¬ϕ iff I, t 6|= ϕ.\n• I, t |= ∀xϕ(x) iff I, t |= ϕ(d) for all d ∈ D.\n• I, h |= ∀xϕ(x) iff I, t |= ∀xϕ(x) and I, h |= ϕ(d) for all d ∈ D.\n• I, w |= ∃xϕ(x) iff I, w |= ϕ(d) for some d ∈ D.\n2. We can think of the objects in D as additional constants; this approach allow us to use a simplified notation where the objects are not distinguished from their names. 3. That is, for every a ∈ C, I(a) ∈ D and for every f ∈ F with arity n, a mapping fI : Dn → D is defined; so the recursive definition is given by I(f(t1, . . . , tn)) = f\nI(I(t1), . . . , I(tn)). 4. The following corresponds to the usual Kripke semantics for intuitionistic logic given our assumptions\nabout the two worlds h and t and the single domain D,\nTruth of a sentence in a model is defined as follows: I |= ϕ iff I, w |= ϕ for each w ∈ {h, t}. A sentence ϕ is valid if it is true in all models, denoted by |= ϕ. A sentence ϕ is a consequence of a set of sentences Π, denoted Π |= ϕ, if every model of Π is a model of ϕ.\nThe resulting logic is called Quantified Here-and-There Logic with static domains (Lifschitz, Pearce, & Valverde, 2007) denoted by QHTs. In terms of satisfiability and validity this logic is equivalent to the logic introduced by Pearce and Valverde (2005).\nA complete axiomatisation of QHTs can be obtained as follows (Lifschitz et al., 2007). We take the axioms and rules of first-order intuitionistic logic and add the axiom of Hosoi\nα ∨ (¬β ∨ (α→ β)) (5)\nwhich determines 2-element here-and-there models in the propositional case, together with the axiom:\n∃x(α(x) → ∀xα(x)).\nWe also consider the equality predicate, . = 6∈ P , interpreted by the following condition for every w ∈ {h, t}\n• I, w |= t1 . = t2 iff I(t1) = I(t2).\nTo obtain a complete axiomatisation, we then need to add the axiom of “decidible equality”\n∀x∀y(x . = y ∨ x 6 . = y).\nWe denote the resulting logic by QHTs= (Lifschitz et al., 2007) and its inference relation by ⊢. By compactness a strong form of completeness can be established such that Π |= ϕ if and only if Π ⊢ ϕ.\nIn the context of logic programs, the following assumptions often play a role. In the case of both classical and QHTs= models, we say that the parameter names assumption (PNA) applies in case I|T (C,F ) is surjective, i.e. there are no unnamed individuals in D; the unique names assumption (UNA) applies in case I|T (C,F ) is injective; in case both the PNA and UNA apply, the standard names assumption (SNA) applies, i.e. I|T (C,F ) is a bijection.\nAs usual in first order logic, satisfiability and validity are independent of the signature. If I = 〈(D, I), Ih, It〉 is an L′-structure and L′ ⊃ L, we denote by I|L the restriction of I to the sublanguage L:\nI|L = 〈(D, I|L), I h|L, I t|L〉\nProposition 2 Suppose that L′ ⊃ L, Π is a theory in L and M is an L′-model of Π. Then M|L is a L-model of Π.\nProposition 3 Suppose that L′ ⊃ L and ϕ ∈ L. Then ϕ is valid (resp. satisfiable) in QHTs=(L) if and only if is valid (resp. satisfiable) in QHT s =(L ′).\nThis proposition allows us to omit reference to the signature in the logic so it can be denoted simply by QHTs=.\nTo simplify notation we also symbolise a QHTs= structure I = 〈(D, I), I h, It〉 by 〈U,H, T 〉, where U = (D, I) is the universe, and H, T respectively are the sets of atoms Ih, It. In the case of propositional HT logic, Kripke structures can be regarded as pairs 〈H,T 〉 of set of atoms in the obvious way. A (strongly) complete axiomatisation for HT is obtained from intuitionistic logic by adding just the Hosoi axiom (5)."
    }, {
      "heading" : "2.3 Interpolation in the Logic of Here-and-There",
      "text" : "An important and useful property of HT is the fact that it is the strongest propositional intermediate logic (i.e. strengthening of intuitionistic logic) that is properly contained in classical logic. Moreover it in turn properly contains all other such intermediate logics. In addition HT is one of precisely seven superintuitionistic propositional logics possessing the interpolation property (Maksimova, 1977; Gabbay & Maksimova, 2005).\nFor languages without function symbols Ono showed that interpolation holds in the logic QHTs of quantified here-and-there with constant domains (Ono, 1983).5 In addition, Maksimova (1997, 1998) showed that adding pure equality axioms, e.g. the decidible equality axiom, to any superintuitionistic logic preserves the interpolation property (Gabbay & Maksimova, 2005). We conclude therefore\nProposition 4 The logic QHTs= possesses the interpolation property.\nNote that by the strong completeness theorem for QHTs= we can work equivalently with ⊢ or with |=.\nHere we can make the further observation that interpolation continues to hold for languages that include function symbols. This can be established using the following property.\nProposition 5 For every formula ϕ, it is possible to build a formula ψ, such that ϕ ≡ ψ, and the atoms of ψ are of one of the following types:\n• x . = a for some a ∈ C,\n• f(x1, . . . xn) . = y for some f ∈ F (where every xi and y are variables),\n• p(t1, . . . , tm) (where every xi and y are variables).\nTheorem 1 Let L be a language containing function symbols. Then QHTs=(L) has the interpolation property.\nProof sketch: Let us assume that ⊢ ϕ→ ψ; from the previous proposition, we can assume, without loss of generality, that the function symbols in ϕ and ψ are in atoms of type f(x1, . . . xn) . = y. Now, we consider a language L′ obtained from L by replacing every function symbol f by a fresh predicate symbol, Pf , such that the Arity(Pf ) = 1+Arity(f). Let ϕ′ and ψ′ be formulas in L′ build from ϕ and ψ respectivelly, by replacing every atom f(x1, . . . xn) . = y by Pf (x1, . . . xn, y). Trivially, ⊢ ϕ\n′ → ψ′ and, for the interpolation property of QHTs=(L\n′), there exists an interpolant β′: ⊢ ϕ′ → β′, ⊢ β′ → ψ′. If we replace in β′ the predicates Pf (t1, . . . , tn, tn+1) by atoms f(t1, . . . tn) . = tn+1 we obtain the interpolant β for the initial pair of formulas.\n5. Ono’s axiomatisation of QHTs uses the constant domains axiom ∀x(α(x)∨β) → (∀xα(x)∨β), as well as alternative axioms for propositional here-and-there, viz. p∨ (p → (q∨¬q)) and (p → q)∨ (q → p)∨ (p ↔ ¬q). However, the axioms given here are equivalent to Ono’s."
    }, {
      "heading" : "2.4 Equilibrium Logic",
      "text" : "Equilibrium logic is a non-monotonic logic based on certain kinds of minimal models in QHTs= or HT. We give the definition for QHT s =; the propositional version is easily obtained from it.\nDefinition 5 Among quantified here-and-there structures we define the order E as follows:\n〈(D, I), Ih, It〉E 〈(D′, J), Jh, J t〉 if D = D′, I = J, It = J t, Ih ⊆ Jh.\nIf the subset relation holds strictly, we write ‘⊳’.\nDefinition 6 (Equilibrium model) Let Π be a theory and I = 〈(D, I), Ih, It〉 a model of Π.\n1. I is said to be total if Ih = It.\n2. I is said to be an equilibrium model of Π (or short, we say: “I is in equilibrium”) if it is minimal under E among models of Π, and it is total.\nIn other words, equilibrium models are total models for which there is no ‘smaller’ non-total model. Evidently a total QHTs= model of a theory Γ can be equivalently regarded as a classical first order model of Γ; and in what follows we make tacit use of this equivalence. In the propositional case, equilibrium models are defined in the same way, where now the ordering is between propositional HT models. In the usual way a formula or theory is said to be consistent if it has a QHTs= model and additionally we say that it is coherent if it has an equilibrium model.\nThe following definition give a preliminary notion of equilibrium entailment, which agrees with standard versions of equilibrium logic (Pearce, 2006).\nDefinition 7 The relation |∼, called equilibrium entailment, is defined as follows. Let Π be a set of formulas.\n1. If Π is non-empty and coherent (has equilibrium models), then Π |∼ϕ if every equilibrium model of Π is a model of ϕ in QHTs= (respectively HT).\n2. If either Π is empty or has no equilibrium models, then Π |∼ ϕ if Π ⊢ ϕ.\nNotice that unless we need to distinguish propositional from first-order reasoning we use the symbols ‘|∼’, ‘⊢’ and ‘|=’ for either version.\nA few words may help to explain the concept of equilibrium entailment. First, we define the basic notion of entailment as truth in every intended (equilibrium) model. In nonmonotonic reasoning this is a common approach and sometimes called a skeptical or cautious notion of entailment or inference; its counterpart brave reasoning being defined via truth in some intended model. Since equilibrium logic is intended to provide a logical foundation for the answer set semantics of logic programs, the cautious variant of entailment is the natural one to choose: the standard consequence relation associated with answer sets is given by truth in all answer sets of a program. Note however that in ASP as a programming paradigm each answer set may correspond to a particular solution of the problem being modelled and is therefore of interest in its own right.\nSecondly, it is useful to have a nonmonotonic consequence or entailment relation that is non-trivially defined for all consistent theories. As we shall see below, however, not all such theories possess equilibrium models. For such cases it is natural to use monotonic consequence as the entailment relation. In particular in the propositional case HT is a maximal logic with the property that logically equivalent theories have the same equilibrium models. Evidently situation 2 also handles correctly the cases that Π is empty or inconsistent.\nDespite these qualifications, there remains an ambiguity in the concept of equilibrium entailment that we now need to settle. Suppose that L′ ⊃ L, Π is a theory in L and ϕ is a sentence in L′ (i.e. L′ = L(ϕ)). How should we understand the expression ‘Π |∼ ϕ’?\nEvidently, if we fix a language in advance, say as the language L′, then we can simply consider the equilibrium models of Π in L′. But if Π represents a knowledge base or a logic program, for instance, we may also take the view that L(Π) is the appropriate signature to work with. In that case, the query ϕ is as such not fully interpreted as it contains some terms not in the theory language L(Π).\nFor any language L and theory Π whose language is contained in L, let EML(Π) be the collection of all equilibrium models of Π in QHTs=(L). Now consider the following two variants of entailment.\nDefinition 8 (Equilibrium entailment) Assume Π is a theory in L, is non-empty and has equilibrium models, then: (i) Let us write Π|∼cwϕ if and only if M |= ϕ for each M ∈ EML′(Π), where L ′ = L∪L(ϕ): (ii) let us write Π |∼ow ϕ if and only if M |= ϕ for each M ∈ EML(Π) ↾ L(ϕ), where in general EML(Π) ↾ L′ denotes the collection of all expansions of elements of EML(Π) to models in L ∪ L′, i.e. where the vocabulary of L′ \\ L is interpreted arbitrarily. (iii) If either Π is empty or has no equilibrium models, then Π |∼cw ϕ iff Π |∼ow ϕ iff Π ⊢ ϕ.\nA simple example will illustrate the difference between |∼cw and |∼ow. Let ψ be an L-sentence and let q(x) be a predicate not in L. Let a be a constant in L and let L′ be the language L ∪ {q}. By the first method we have ψ |∼cw ψ ∧ (q(a) ∨ ¬q(a)). In fact we have the stronger entailment ψ |∼cw ψ ∧¬q(a). The reason is that when we form the equilibrium models of ψ in L′, q(a) will be false in each as an effect of taking minimal models. On the other hand, if we expand equilibrium models of ψ in QHTs=(L) to QHT s =(L\n′), the new predicate q receives an arbitrary interpretation in QHTs=(L\n′). Since this logic is 3-valued we do not obtain Π |∼ow q(a) ∨ ¬q(a).\nFor standard, monotonic logics, there is no difference between these two forms of entailment. If in Definition 8 we replace everywhere equilibrium model by simply model (in QHTs=), variants (i) and (ii) give the same result.\nIn the context of logic programming and deductive databases the more orthodox view is that reasoning is based on a closed world assumption (CWA). Accordingly a ground atomic query like q(a)?, where the predicate q does not belong to the language of the program or database, would simply be assigned the value false. This is also the case with the first kind of equilibrium entailment and we use the label |∼cw since this variant appears closer to a closed world form of reasoning. On the other hand, there may be legitimate cases where we do not want to apply the CWA and where unknown values should be assigned to an atom that is not expressed in the theory language. Then the second form of entailment, |∼ow,\nnearer to open world reasoning, may be more appropriate. For present purposes, however, the suffices ‘cw’ and ‘ow’ should be thought of merely as mnemonic labels.\nA thorough analysis of closed world versus open world reasoning in this context would lead us to consider assumptions such as UNA or SNA and is outside the scope of this paper. However, it has been observed in logic programming that the use of CWA can lead to certain apparent anomalies. Notably this occurs with programs that are unsafe (see Section 5 below), such as the following, formulated in traditional notation for logic programs:6\nq(x, y) : − not p(x, y). p(x, x).\nGiven restrictions such as SNA or Herbrand models, the query ?− q(a, z). yields no answer for z because it cannot be satisfied in models with only a single domain element a, while the query\n?− q(a, b). is satisfiable, given the new constant b. In logic programming, where these restrictions are usually assumed, different solutions to this problem have been proposed (Gelder, Ross, & Schlipf, 1991; Kunen, 1987; Maher, 1988). Here we would like to point out that for equilibrium logic generally speaking this kind of program or theory does not create any special difficulties. Neither the query\n?− q(a, z). which is understood as ∃zq(a, z), nor the query\n?− q(a, b). is true in all equilibrium models. In particular, in an equilibrium model whose domain is a singleton element, even q(a, b) need not be true; evidently in the general case that UNA for instance does not apply. On the other hand in answer set programming, where UNA is often assumed, it is also typically assumed that programs are safe. By the safety condition the above program is excluded because variables appearing in the head of a rule do not appear in its positive body and this makes answer sets sensitive to the set of constants appearing in the language or those that are used for grounding the program. In this paper, where the application of interpolation in ASP is concerned, we restrict attention to safe programs and theories complying with a generalised form of safety (Section 5 below)."
    }, {
      "heading" : "3. Interpolation in Propositional Equilibrium Logic",
      "text" : "In this section we deal with interpolation in propositional equilibrium logic. It is clear that by its semantic construction propositional equilibrium logic has HT as a deductive base. This base is actually maximal.\nProposition 6 HT is a strong and maximal deductive base for (propositional) equilibrium entailment.\nThe first property is precisely the strong equivalence theorem of Lifschitz, Pearce and Valverde (2001). Maximality follows from the fact that any logic strictly stronger than HT would have to contain classical logic which is easily seen not to be a deductive base, e.g. violating condition (ii) of Definition 1. We have:\n6. We are grateful to an anonymous referee for raising this point and the example.\nLemma 1 Let α be a coherent HT-formula and EM(α) its set of equilibrium models. Then there is formula α′ of HT in v(α) that defines EM(α) in the sense that M ∈ EM(α) if and only if M |= α′.\nProof. Suppose that α is coherent. and let\nM1 = 〈T1, T1〉, M2 = 〈T2, T2〉, . . . , Mn = 〈Tn, Tn〉\nbe an enumeration of its equilibrium models. We show how to define EM(α). Suppose each Ti, has ki elements and denote them by A i 1, . . . , A i j , . . . , A i ki . Let Ti be the complement of Ti; then we can list its members as A i k1+1 , . . . Ail . . . , A i |v(α)|. Set\nδi = ∧\nj=1,...,ki\nAij ∧ ¬( ∨\nl=ki+1,...,|v(α)|\nAil), and α ′ =\n∨\ni=1,...,n\nδi\nWe claim that M |= α′ if and only if M = Mi for some i = 1, . . . , n, i.e. the models of α ′ are precisely M1, . . . ,Mn. To verify this claim, note that each Mi |= δ i and so Mi |= α\n′. Conversely, suppose that M |= α′. From the semantics of HT it is clear that M |= ϕ∨ψ iff M |= ϕ orM |= ψ, so in particular M |= α′ implies M |= δi for some i = 1, . . . , n. However, each δi defines a complete theory whose models are total. It follows that if M |= δi, then M = Mi. This establishes the claim.\nAlthough we shall now demonstrate interpolation in the (|∼, |∼) form for the relation |∼cw, we actually establish a stronger result. One consequence of this is that if we are concerned with |∼ow entailment then the (|∼,⊢) form of interpolation actually holds.\nProposition 7 (|∼, |∼-Interpolation) Let α, β be formulas and set v = v(α) ∪ v(β) and v′ = v(β) \\ v(α) and suppose that B1, . . . Bn is an enumeration of v\n′. If α |∼cw β, there is a formula γ such that v(γ) ⊆ v(α) ∩ v(β), α |∼ γ, and γ ∧ ¬B1 ∧ . . . ∧ ¬Bn |= β. Hence in particular γ |∼cw β.\nProof. Let α, β and v, v′ be as in the statement of the proposition, and suppose that α|∼cwβ. Then β holds in all equilibrium models of α in the language v. Case (i): suppose that α is coherent and form its set of equilibrium models, EMv(α).\nBy the equilibrium construction it is easy to see that in each model M ∈ EMv(α) each atom Bi is false, for i = 1, n. Construct the formulas δi and the formula α\n′ exactly as in the proof of Lemma 1. Now consider the formula (¬B1 ∧ . . . ∧ ¬Bn) ∧ α\n′. Clearly this formula defines the set of equilibrium models of α inHT(v). Consequently, (¬B1∧. . .∧¬Bn)∧α\n′ |= β and so α′ ⊢ (¬B1 ∧ . . . ∧ ¬Bn) → β. We can now apply the interpolation theorem for HT to infer that there is a formula γ such that α′ ⊢ γ and γ ⊢ (¬B1 ∧ . . . ∧ ¬Bn) → β, where v(γ) ⊆ v(α′) ∩ v(β) and hence v(γ) ⊆ v(α) ∩ v(β). Since HT is a deductive base, we conclude that\nα |∼ γ & γ ∧ ¬B1 ∧ . . . ∧ ¬Bn ⊢ β.\nNow, since v(γ) ⊆ v(α) ∩ v(β), Bi 6∈ v(γ) for i = 1, n. It follows that in HT(v(β)), each Bi is false in every equilibrium model of γ. So each such model M satisfies (¬B1∧ . . .∧¬Bn). 7 Since each also satisfies β, we have γ |∼cw β.\n7. Notice that in this case adding to γ the sentence (¬B1∧ . . .∧¬Bn) does not change its set of equilibrium models.\nCase (ii). If α has no equilibrium models then the hypothesis is that α ⊢ β. In that case we simply choose an interpolant γ for (α, β).\nCorollary 1 (|∼,⊢-Interpolation) Let α, β be formulas such that α |∼cw β and v(β) ⊆ v(α). There is a formula γ such that v(γ) ⊆ v(α) ∩ v(β) and α |∼cw γ and γ ⊢ β.\nProof. Immediate from Proposition 7 by the fact that v(β) \\ v(α) = ∅.\nProposition 8 (|∼,⊢-Interpolation) Let α, β be formulas and set v = v(α) ∪ v(β) and v′ = v(β) \\ v(α). If α |∼ow β, there is a formula γ such that v(γ) ⊆ v(α) ∩ v(β), α |∼ γ, and γ ⊢ β.\nProof. Let α, β and v, v′ be as in the statement of the proposition and suppose that α |∼owβ. Then β holds in all expansions of elements of EMv(α)(α) to the language v. Case (i): suppose that α is coherent and consider EMv(α)(α).\nAgain construct the formulas δi and the formula α ′ exactly as in the proof of Lemma 1. Now consider α′ which defines the set EMv(α)(α). Then β holds in all expansions of models of α′ to v. Hence α′ |= β and therefore α′ ⊢ β We can now apply the interpolation theorem for HT to infer that there is a formula γ such that α′ ⊢ γ and γ ⊢ β, where v(γ) ⊆ v(α′) ∩ v(β) and hence v(γ) ⊆ v(α) ∩ v(β). Since α |∼ow α\n′ and HT is a deductive base we conclude that\nα |∼ow γ & γ ⊢ β.\nCase (ii). If α has no equilibrium models, choose γ as an interpolant for (α, β)."
    }, {
      "heading" : "4. Interpolation in Quantified Equilibrium Logic",
      "text" : "We now turn to first-order logic. Given inferences of the form α |∼ β, a key element in the proofs of Propositions 7 and 8 is the existence of a formula α′ that defines the collection EMv(α)(α) of equilibrium models. In the propositional case we have seen how the existence of such an α′ can be established. In the first-order case, on the other hand, such an α′ need not exist. In other words, EML(α)(α) need not be first-order definable for arbitrary α. This fact is not hard to show. As Ferraris et al. (2007) have pointed out, in the general form of answer set programming where first-order formulas are allowed, and a fortiori in quantified equilibrium logic, the property of transitive closure is expressible. Yet this property is not definable in classical first-order logic and therefore it also cannot be defined in QHTs=.\nIn the usual way we say that a collection K of QHTs=(L) models is (QHT s =) definable if there is an L-sentence, ϕ, such that M ∈ K ⇔ M |= ϕ. It is easy to see that whenever the class EML(α)(α) is first-order definable in QHT s = we do obtain first-order analogs of Propositions 7 and 8. The method of proof is essentially the same as before. For completeness we outline the main steps for the case of (|∼, |∼)-interpolation.\nProposition 9 (|∼, |∼-Interpolation) Let α, β be formulas such that the collection of equilibrium models of α is QHTs=- definable. Set L = L(α) ∪ L(β) and L\n′ = L(β) \\ L(α). Let {pi : i = 1, n} be the (finite, possibly empty) set of predicates in L ′ and suppose for each i\nthat pi is of arity ki. If α |∼cw β, there is a formula γ such that L(γ) ⊆ L(α)∩L(β), α |∼ γ, and\nγ ∧ ∧\ni=1,n\n∀x¬pi(x) |= β\nHence in particular γ |∼cw β.\nProof. Assume the hypotheses. Then β holds in all equilibrium models of α in the language L. We treat just the case where α is coherent and has a non-empty collection of equilibrium models, EML(α)(α). By assumption this collection is definable by aQHT s =(L(α))-sentence, α′, say. Now consider the equilibrium models of α in the expanded language L, i.e. the collection EML(α). By the equilibrium construction we claim that EML(α) |= ∀x¬pi(x), for all i = 1, n. Since we are now working with the first-order semantics, let us rehearse briefly the argument for this. If it were not true there would be a model 〈U, T, T 〉 ∈ EML(α), a predicate symbol pi ∈ L\n′ and some tuple a of elements in the domain of 〈U, T, T 〉, such that 〈U, T, T 〉 |= pi(a), ie pi(a) ∈ T . However, since α does not refer to the relation pi, the structure 〈U,H, T 〉 with H = T \\ pi(a) must also be a model of α, contradicting that 〈U, T, T 〉 is in equilibrium. So EML(α) |= α ′ ∧ ∧ i=1,n ∀x¬pi(x) and since α ′ defines EML(α)(α) clearly α ′ ∧ ∧ i=1,n ∀x¬pi(x) defines EML(α).\nNow we proceed as in the propositional case. α′ ∧ ∧\ni=1,n ∀x¬pi(x) ⊢ β, so\nα′ ⊢ ∧\ni=1,n\n∀x¬pi(x) → β.\nBy the interpolation theorem for QHTs= there is a formula γ such that L(γ) ⊆ L(α)∩L(β), α′ ⊢ γ and γ ⊢ ∧ i=1,n ∀x¬pi(x) → β. Consequently we also have\nα |∼ γ & γ ∧ ∧\ni=1,n\n∀x¬pi(x) ⊢ β\nBy the same token as in the propositional case, we infer that γ |∼cw β. The case of (|∼,⊢)-interpolation for |∼ow is analogous and we state the main property without proof.\nProposition 10 (|∼,⊢-Interpolation) Let α, β be formulas such that the collection of equilibrium models of α is QHTs=- definable. If α |∼ow β, there is a formula γ such that L(γ) ⊆ L(α) ∩ L(β), α |∼ γ and γ ⊢ β."
    }, {
      "heading" : "5. An Illustration: Interpolation for Safe Formulas",
      "text" : "How restrictive is the definability assumption? Is it often met in practice? Actually in mainstream answer set programming, whose language equilibrium logic captures and extends (see the next section), non-definable classes of answers sets play no significant role. The reason is that for query answering existing solvers rely on grounders that instantiate all or parts of a program before computing the intended models or solutions. The grounding process essentially eliminates variables and reduces the original program to propositional form. In such practical cases, then, the collection of stable or equilibrium models will be definable.\nFor this computational approach to work in general, syntactic restrictions need to be imposed on admissible programs or theories. The most common form of restriction is called safety. For standard types of logic programs based on rules one regards a rule as safe if every variable appearing in rule’s head also appears in its body. For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas and by Bria, Faber and Leone (2008) for a more restricted syntactic class. More recently Cabalar, Pearce and Valverde (2009) have generalised both these approaches and suggested a safety concept for arbitrary function-free formulas in equilibrium logic. Since this new concept of safety defines a quite broad class of interpolable formulas, let us review here its main features. In the following section we will mention some other kinds of interpolable formulas that may arise in answer set programming."
    }, {
      "heading" : "5.1 General Concept of Safety",
      "text" : "For the remainder of this section we assume that all languages are function-free. As usual a sentence is said to be in prenex form if it has the following shape, for some n ≥ 0:\nQ1x1 . . . Qnxnα\nwhere Qi is ∀ or ∃ and α is quantifier-free. A sentence is said to be universal if it is in prenex form and all quantifiers are universal. A universal theory is a set of universal sentences. The safety concept is defined for prenex formulas which provide a normal form for QHTs= (Pearce & Valverde, 2005).\nWe first introduce a concept called semi-safety. The main property of semi-safety formulas will be that their equilibrium models only refer to objects from their language. Note that for the remainder of this section we use the fact that negation can be treated as a defined operator, by ¬ϕ ≡ ϕ → ⊥, and do not consider additional semantic clauses for negation.\nDefinition 9 (Semi-safety) A quantifier free formula ϕ is semi-safe it is has not nonsemi-safe variable; that is, NSS(ϕ) = ∅, where the NSS operator is recursively defined as follows:\n• If ϕ is an atom, NSS(ϕ) is the set of variables in ϕ;\n• NSS(ϕ1 ∧ ϕ2) = NSS(ϕ1) ∪NSS(ϕ2);\n• NSS(ϕ1 ∨ ϕ2) = NSS(ϕ1) ∪NSS(ϕ2);\n• NSS(ϕ1 → ϕ2) = NSS(ϕ2)r RV(ϕ1),\nwhere operator RV computes the restricted variables as follows:\n• For atomic ϕ, if ϕ is an equality between two variables then RV(ϕ) = ∅; otherwise, RV(ϕ) is the set of all variables occurring in ϕ;\n• RV(⊥) = ∅;\n• RV(ϕ1 ∧ ϕ2) = RV(ϕ1) ∪ RV(ϕ2);\n• RV(ϕ1 ∨ ϕ2) = RV(ϕ1) ∩ RV(ϕ2);\n• RV(ϕ1 → ϕ2) = ∅.\nThis definition of semi-safe formulas was introduced by Cabalar, Pearce and Valverde (2009) and generalises the former definition of Lee, Lifschitz and Palla (2008b). In short, a variable x is semi-safe in ϕ if every occurrence is inside some subformula α → β such that, either x ∈ RV(α) or x is semi-safe in β.\nSome examples of semi-safe formulas are, for instance:\n¬p(x) → (q(x) → r(x))\np(x) ∨ q → ¬r(x) (6)\nNote how in (6), x is not restricted in p(x) ∨ q but the consequent ¬r(x) is semi-safe and thus the formula itself. On the contrary, the following formulas are not semi-safe:\np(x) ∨ q → r(x)\n¬¬p(x) ∧ ¬r(x) → q(x)\nThe following results set the previously referred property for semi-safe formulas: their equilibrium models only include objects from the language.\nProposition 11 (Cabalar et al., 2009) If ϕ is function free, semi-safe, and 〈(D, I), T, T 〉 |= ϕ, then 〈(D, I), T |C , T 〉 |= ϕ.\nTheorem 2 (Cabalar et al., 2009) If ϕ is function free, semi-safe, and 〈(D, I), T, T 〉 is an equilibrium model of ϕ, then T |C = T .\nThe equilibrium models of semi-safe formulas only refer to objects from the language, however a model could be or not in equilibrium depending of the considered domain. To guarantee the independence from the domain, we need an additional property to the semisafety. Specifically, we need to analyse whether the unnamed elements could modify an interpretation of the formula. To do that, we use the assignments of the Kleene’s threevalued logic; the three-valued interpretation ν : At → {0, 1/2, 1}, are extended to evaluate arbitrary formulas ν(ϕ) as follows:\nν(ϕ ∧ ψ) = min(ν(ϕ), ν(ψ)) ν(⊥) = 0 ν(ϕ ∨ ψ) = max(ν(ϕ), ν(ψ)) ν(ϕ→ ψ) = max(1− ν(ϕ), ν(ψ))\nFor every variable x, we are going to use the Kleene’s interpretations νx, defined as follows: νx(α) = 0 if x occurs in the atom α and νx(α) = 1/2 otherwise. Intuitively, νx(ϕ) fixes all atoms containing the variable x to 0 (falsity) leaving all the rest undefined and then evaluates ϕ using Kleene’s three-valued operators, that is nothing else but exploiting the defined values 1 (true) and 0 (false) as much as possible.\nAn occurrence of a variable x in Qx ϕ is weakly-restricted if it occurs in a subformula ψ of ϕ such that:\n• Q = ∀, ψ is positive8 and νx(ψ) = 1\n• Q = ∀, ψ is negative and νx(ψ) = 0\n• Q = ∃, ψ is positive and νx(ψ) = 0\n• Q = ∃, ψ is negative and νx(ψ) = 1\nIn all cases, we further say that ψ makes the ocurrence weakly restricted in ϕ. This property is added to the semi-safety condition to complete the definition of safety.\nDefinition 10 A semi-safe sentence is said to be safe if all its positive occurrences of universally quantified variables, and all its negative occurrences of existentially quantified variables are weakly restricted.\nFor instance, the formula ϕ = ∀x(¬q(x) → (r ∨ ¬p(x))) is safe: the occurrence of x in p(x) is negative, whereas the occurrence in q(x) is inside a positive subformula, ϕ itself, for which x is weakly-restricted, since νx(ϕ) = ¬0 → (1/2∨¬0) = 1. Another example of a safe formula is ∀x((¬¬p(x) ∧ q(x)) → r).\nProposition 12 (Cabalar et al., 2009) If ϕ is function free, safe, and prenex formula, then: 〈(D, I), T, T 〉 is an equilibrium model of ϕ if and only if it is an equilibrium model of GrC(ϕ) (the grounding of ϕ over C)."
    }, {
      "heading" : "5.2 Interpolation",
      "text" : "On the basis of Proposition 12 we could already establish interpolation theorems for safe formulas in prenex form, essentially by replacing such formulas by their ground versions and working in propositional logic. However, we can also apply Propositions 9 and 10 directly by noting the property shown by Cabalar et al. (2009) that safe prenex formulas have definable classes of equilibrium models.\nTheorem 3 (interpolation for safe formulas) Safe formulas in prenex form have QHTs=-definable classes of equilibrium models. Therefore for such formulas (|∼, |∼)-interpolation for |∼cw inference holds as in Proposition 9 and (|∼,⊢)-interpolation holds for |∼ow inference as in Proposition 10."
    }, {
      "heading" : "6. Interpolation in Answer Set Semantics",
      "text" : "Answer set programming (ASP) has become an established form of declarative, logic-based programming and its basic ideas are now well-known. For a textbook treatment the reader is referred to Baral’s book (2003). As is also well-known, the origins of ASP lie in the stable model and answer set semantics for logic programs introduced by Gelfond and Lifschitz (1988, 1990, 1991). This semantics made use of a fixpoint condition involving a certain ‘reduct’ operator. Subsequent extensions of the concept to cover more general kinds of rules\n8. Recall that a subexpression of a formula is said to be positive in it if the number of implications that contain that subexpression in the antecedent is even, and negative if it is odd. Here we also consider that ¬ϕ is defined as ϕ → ⊥.\nalso relied on a reduct operator of similar sort. For the original definitions, the reader is referred to the various papers cited.\nThe correspondence between answer set semantics and equilibrium logic is also wellestablished and has been discussed in many publications, beginning with Pearce (1997), who first showed how the answer sets of disjunctive programs can be regarded as equilibrium models (Lifschitz et al., 2001, 2007; Ferraris et al., 2007; Pearce & Valverde, 2005, 2006, 2008). For our purposes it will suffice to recall just two important syntactic classes of programs and the main features of the correspondence with equilibrium logic.\nAt one extreme we have ground, disjunctive logic programs; we treat them here without strong negation, so their answer sets are simply collections of atoms. These programs consist of sets of ground rules of the form\nK1 ∨ . . . ∨Kk ← L1, . . . Lm, notLm+1, . . . , notLn (7)\nwhere the Li and Kj are atoms. The ‘translation’ from the syntax of programs to HT propositional formulas is the trivial one, viz. (7) corresponds to the HT sentence\nL1 ∧ . . . ∧ Lm ∧ ¬Lm+1 ∧ . . . ∧ ¬Ln → K1 ∨ . . . ∨Kk (8)\nUnder this translation the correspondence between the answer sets and the equilibrium models of ground disjunctive programs is also the direct one:\nProposition 13 Let Π be a disjunctive logic program. Then 〈T, T 〉 is an equilibrium model of Π if and only if T is an answer set of Π.\nThis was first shown by Pearce (1997) but the basic equivalence was later shown to hold for more general classes of programs by Pearce, P. de Guzman and Valverde (2000).\nIt is also common to treat non-ground rules of form (7) where variables may appear. These variables are thought of as being universally quantified, so the corresponding translation into a logical formula would simply be the universal closure of formula (8).\nAt the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of stable model for arbitrary first-order formulas. In this case the property of being a stable model is defined syntactically via a second-order condition that resembles parallel circumscription. However they also showed that the new notion of stable model is equivalent to that of equilibrium model as defined here for first-order languages. In a sequel to this paper, Lee, Lifschitz and Palla (2008a) have applied the new definition and made the following refinements. The stable models of a formula are defined as Ferraris et al. (2007) were, while the answer sets of a formula are those Herbrand models of the formula that are stable in the sense of Ferraris et al. Using this new terminology, it follows that in general stable models and equilibrium models coincide, while answer sets are equivalent to SNA-QHT models that are equilibrium models.\nIn between these two extremes many syntactically different kinds of programs have been considered and several variations in the concept of answer set have been proposed. However all the main varieties display a similar correspondence to equilibrium logic. It is merely necessary in some cases to restrict attention to specific kinds of equilibrium models, e.g. Herbrand models, UNA-models or SNA-models. It is important to notice also that this correspondence extends to many of the additional constructs that have been introduced\nin ASP, such as cardinality and weight constraints and even general forms of aggregates (Lee & Meng, 2009). All these can be accommodated in equilibrium logic by translation into logical formulas.\nIn ASP the main emphasis is on finding answer sets and this is what most answer set solvers compute. Less attention is placed on implementing a non-monotonic inference relation or a query answering mechanism. However there is a standard, skeptical concept of inference or entailment associated with answer set semantics. This notion of entailment or consequence for programs under the answer set semantics is that a query Q is entailed by a program Π if Q is true in all answer sets of Π (Balduccini, Gelfond, & Nogueira, 2000). Let us denote this entailment or consequence relation by |∼AS . Evidently atoms are true in an answer set if and only if they belong to it. Conjunctions and disjunctions are handled in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000). Sometimes, queries of the form not a, or in logical notation ¬a, are not explicitly dealt with (Balduccini et al., 2000). However it seems to be in keeping with the semantics to regard a formula of form not α or ¬α to be true in an answer set if and only if α is not true. Another way to express this would be to say that an answer set satisfies ¬α if it does not violate the constraint {← α}, understanding constraint violation as Lifschitz, Tang and Turner (1999).9 In this way we would say that Π |∼AS ¬A if no answer set of Π contains A. Similarly, the interpretation of queries containing quantifiers in answer set semantics should also conform to that of equilibrium logic, taking account of any specific restrictions, such as Herbrand models, that might be imposed.\nWe can therefore transfer interpolation properties from equilibrium logic to answer set semantics and ASP. It remains to consider whether |∼AS is best identified with the closed world version of inference, |∼cw, or the more open world version, |∼ow. Again, since ASP solvers do not generally implement inference engines, the difference is largely a theoretical one. In traditional logic programming, however, a query that does not belong to the language of the program is usually answered false. It also seems quite natural in an ASP context that, given a program Π and a query Q, one should consider the stable models of Π in the language L(Π)∪L(Q) even if this is a proper extension of the language of Π.10 So in general |∼cw seems a natural choice for answer set inference. On the other hand, there are contexts where answer set semantics is used in a more open world setting, for example in the setting of hybrid knowledge bases (Rosati, 2005) where non-monotonic rules are combined with ontologies formalised in description logics. For such systems a semantics in terms of equilibrium logic was provided by de Bruijn, Pearce, Polleres and Valverde (2007). Here an entailment relation in the style of |∼ow might sometimes be more appropriate.\nIn general answer set semantics is defined only for coherent programs or theories. For these, by identifying |∼AS with |∼cw, we can apply Proposition 9 directly:\nCorollary 2 For coherent formulas α, (|∼, |∼)-interpolation in the form of Proposition 9 holds for entailment |∼AS in answer set semantics.\n9. In logical terms this constraint would be written α → ⊥. 10. Notice that by Proposition 12 if a program consists of safe formulas, an atomic query q(a) is automatically\nfalse if a does not belong to the language of the program (even if q does), simply because grounding with the program constants is sufficient to generate all answer sets."
    }, {
      "heading" : "7. An Application of Interpolation",
      "text" : "The Interpolation property has been applied in various areas of computer science, notably in software specification (Bicarregui et al., 2001) and in the construction of formal ontologies (Lutz & Wolter, 2010). In both areas it is relevant to modularity issues. Here we discuss a simple application related to a concept described by Lutz and Wolter that we can adapt to the case of nonmonotonic logic programs.\nOne way to compare two theories is via their nonmonotonic consequence relations. When two theories produce the same answers for a given query language, we can call them inseparable; this term is used in mathematical logic and also in the study of formal ontologies (Lutz & Wolter, 2010).\nLet us say therefore that Π1 and Π2 are L-inseparable if for any ϕ such that V (ϕ) ⊆ L, Π1 |∼ ϕ⇔ Π2 |∼ ϕ.\nProposition 14 Let Π1 and Π2 be L-inseparable theories such that V (Π1) = V (Π2) = V , say. Then for any L′ ⊃ L such that V ∩ L′ ⊆ L, Π1 and Π2 are L ′-inseparable.\nProof. Assume that Π1 and Π2 are L-inseparable and that L ′ is an extension of L such that V ∩ L′ ⊆ L. Suppose Π1 |∼ ϕ, where V (ϕ) = L ′. Suppose L′ \\ V = {B1, . . . Bn}. By Proposition 7 there is an interpolant γ for (Π1, ϕ) such that γ |= ¬B1∧. . .∧¬Bn → ϕ. Since Π1 |∼ γ and V (γ) ⊆ L, by L-inseparability we have Π2 |∼ γ. By right absorption therefore Π2 |∼ ¬B1 ∧ . . . ∧ ¬Bn → ϕ. However it is clear that B1, . . . Bn are false in all equilibrium models of Π2, so Π2 |∼ϕ. Repeating this argument with Π1 and Π2 interchanged shows that the theories are L′-inseparable.\nThe above proof is similar to the argument given by Lutz and Wolter (2010) for Theorem 7 of that paper, applied to TBoxes in description logics. The property described is called there robustness under signature extensions. Notice however that, since |∼ is not in general transitive we cannot immediately infer from Π2 |∼ γ and γ |∼ ϕ that also Π2 |∼ ϕ. This highlights the added strength of using explicitly the set {B1, . . . Bn} and the property that HT forms a deductive basis for |∼.\nIn the study of modularity and logical relations between programs in ASP, it is more common to compare their sets of answer sets rather than their consequence classes. However it turns out that the notion of inseparability is very close to a concept that has already been studied in ASP. Two theories or programs are said to be projectively equivalent if the projections of their answer sets onto a common sublanguage agree (Eiter, Tompits, & Woltran, 2005). Formally, let Π1,Π2 be theories and L be a signature such that L ⊆ V (Π1) ∩ V (Π2). Then Π1 and Π2 are said to be projectively equivalent relative to L if E(Π1)↾L = E(Π2)↾L, where for any class of models K, K↾L = {M↾L : M ∈ K}.\nProposition 15 Let Π1,Π2 be theories and L a signature such that L ⊆ V (Π1) ∩ V (Π2). Π1 and Π2 are projectively equivalent relative to L if and only if they are L-inseparable.\nIn other words these two concepts agree whenever L is a common sublanguage of Π1,Π2. The main advantage of L-inseparability is that it seems the more natural one to use if we want to consider signatures that extend the language of either program or theory."
    }, {
      "heading" : "8. Uniform Interpolation and Forgetting",
      "text" : "A stronger form of interpolation known as uniform interpolation is also important for certain applications in computer science (Konev et al., 2009). As usual, given α, β with α ⊢ β, we are interested in interpolants γ such that\nα ⊢ γ & γ ⊢ β (9)\nwhere γ contains only predicate and constant symbols that belong to both α and β. The difference now is that γ is said to be a uniform interpolant if (9) holds for any β in the same signature such that α ⊢ β. A logic is said to have the uniform interpolation property if such uniform interpolants exist for all α, β.\nIn classical propositional logic, the uniform interpolation holds, however it fails in first order classical logic and in many non-classical logics. It may hold when certain restrictions are placed on the theory language in which α is formulated and on the query language containing β. For example it has been shown to hold for some description logics (Kontchakov et al., 2008) where such syntactic restrictions apply. Even in ASP it turns out that a form of uniform interpolation holds for a very restricted query language, essentially one that allows just instance retrieval. We can show this by using some known results in ASP about the concept of forgetting (Eiter & Wang, 2008) that is quite closely related to interpolation.\nVariable forgetting, as studied by Eiter and Wang (2008), is concerned with the following problem. Given a disjunctive logic program Π and a certain atom a occurring in Π, construct a new program, to be denoted by forget(Π, a), that does not contain a but whose answer sets are in other respects as close as possible to those of Π. For the precise notion of closeness the reader is referred to paper of Eiter and Wang, however some consequences will be evident shortly. Eiter and Wang define forget(Π, a) (as a generic term), show that such programs exist whenever Π is coherent, and provide different algorithms to compute such programs.\nGiven coherent Π and a in Π, the results forget(Π, a), of forgetting about a in Π may be different but are always answer set equivalent. Moreover for our purposes they satisfy the following key property, where Π is coherent, a, b are distinct atoms in Π and as usual |∼ denotes nonmonotonic consequence,\nΠ |∼ b ⇔ forget(Π, a) |∼ b. (10)\nshowing that indeed the answer sets of Π and forget(Π, a) are closely related. To establish a version of uniform interpolation for the case of disjunctive programs and simple, atomic queries, we need to show that we can always find a Π′ = forget(Π, a) such that Π |∼Π′. For this we can examine the first algorithm of Eiter and Wang for computing forget(Π, a); this is also the simplest of the three algorithms presented. Let Π be a coherent program with rules of form (7) that we write as formulas of form (8) and let a be an atom in Π. The method for constructing a Π′ = forget(Π, a) is as follows.\n1. Compute the equilibrium models E(Π).\n2. Let E′ be the result of removing a from each M ∈ E(Π).\n3. Remove from E′ any model that is non-minimal to form E′′(= {A1, . . . , Am}, say).\n4. Construct a program Π′ whose answer sets are precisely {A1, . . . , Am} as follows:\n• for each Ai, set Πi = {¬Ai → a ′ : a′ ∈ Ai}, where Ai = V (Π) \\ Ai. • Set Π′ = Π1 ∪ . . . ∪Πm.\nWe can now verify the desired property. Let L be the simple query language composed of conjunctions of literals.\nProposition 16 In equilibrium logic (or answer set programming) uniform interpolation holds for (coherent) disjunctive programs and queries in L(V (Π)).\nProof. To prove the claim we shall show the following. Let Π be a coherent disjunctive program and let L = L(V ) for some V ⊆ V (Π). Then there is a program Π′ such that V (Π′) = V and for any ϕ ∈ L,\nΠ |∼ ϕ⇒ (Π |∼Π′ & Π′ |∼ ϕ)\nTo begin, let Π and ϕ be as above with Π |∼ϕ. Let X = {a1, . . . , an} = V (Π) \\V . Then we choose Π′ to be the result of forgetting about X in Π, defined by Eiter and Wang (2008) as follows:\nforget(Π,X) := forget(forget(forget(Π, a1), a2), . . . , an),\nand it is shown there that the order of the atoms in X does not matter. Now we know by (10) that for any atom a ∈ V and any i = 1, n,\nΠ |∼ a⇔ forget(Π, ai) |∼ a, (11)\ntherefore Π |∼ a⇒ forget(Π,X) |∼ a. (12)\nLet Π′ be forget(Π,X) as determined by algorithm 1 of Eiter and Wang (2008) described above. It is easy to see by (11) and the semantics of |∼ that (12) continues to hold where a is replaced by a negated atom ¬b and therefore also by any conjunction of literals since a conjunction is entailed only if each element holds in every equilibrium model.11 So it remains to show that Π |∼ Π′. Again, it will suffice to show this entailment for one member of the sequence forget(Π, ai) and since the order is irrelevant wlog we can choose the first element forget(Π, a1) and show that Π |∼ forget(Π, a1). We compute the programs Π1, . . . ,Πm as in the algorithm. Then we need to check that Π |∼ Πi for any i = 1, n, i.e. that for each M ∈ E(Π), M |= {¬Ai → a\n′ : a′ ∈ Ai}. Consider M ∈ E(Π) where M = 〈T, T 〉. We distinguish two cases. (i) Ai ⊆ T . Then M |= a′ for each a′ ∈ Ai. It follows that M |= ¬Ai → a ′ for each a′ ∈ Ai and so M |= {¬Ai → a ′ : a′ ∈ Ai}. Case (ii) Ai 6⊆ T . Then T and Ai are incomparable. In particular we cannot have T ⊂ Ai by the minimality property of Ai obtained in step 3. Hence T ∩Ai 6= ∅. Choose a ′′ ∈ T ∩Ai. Then M |= a ′′, so M 6|= ¬a′′ and hence M 6|= ¬Ai. Consequently, for any a′, M |= ¬Ai → a ′ and so M |= {¬Ai → a\n′ : a′ ∈ Ai}. It follows that for any i, Π |∼Πi and so by construction Π |∼Π ′, which establishes the proposition.\n11. As Eiter and Wang (2008) point out, if an atom b is true in some answer set of forget(Π, a), then it must also be true in some answer set of Π, showing that (12) holds for literals."
    }, {
      "heading" : "8.1 Extending the Query Language",
      "text" : "If we establish uniform interpolation in ASP using the method of forgetting, as defined by Eiter and Wang (2008), it seems clear that we cannot extend in a non-trivial way the expressive power of the query language L. Since the method of forgetting a in Π removes non-minimal sets from E(Π) (once a has been removed), an atom b might be true in some equilibrium model of Π but not in any equilibrium model of forget(Π, a). Hence we might have a disjunction, say a ∨ b, derivable from Π but not from forget(Π, a). Likewise, if we consider programs with variables in a first-order setting, we cannot in general extend L to include existential queries.\nOn the other hand, the property of uniform interpolation certainly holds for any L(V ) even without the condition that V ⊆ V (Π). Suppose that Π |∼ ϕ where V (ϕ) \\ V (Π) 6= ∅, say V (ϕ) \\ V (Π) = {b1, . . . , bk}. Then b1, . . . , bk are false in all equilibrium models of Π. Trivially, if b is not in V (Π) we can regard the result of forgetting about b in Π as just Π. So we can repeat the proof of Proposition 16, but now setting X = {V (Π) \\ V } ∪ {V \\ V (Π)}. All the relevant properties will continue to hold.\nAn interesting open question is whether we can extend the theory language to include more general kinds of program rules such as those allowing negation in the head. Accommodating these kinds of formulas would constitute an important generalisation since they amount to a normal form in equilibrium logic. However, the answer sets of such programs do not satisfy the minimality property that holds for the answer sets of disjunctive programs, so it is clear that the definition of forgetting would need to be appropriately modified - a task that we do not attempt here."
    }, {
      "heading" : "9. Literature and Related Work",
      "text" : "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Schütte (1962). Maksimova (1977) characterised the super-intuitionistic propositional logics possessing interpolation. A modern, comprehensive treatment of interpolation in modal and intuitionistic logics can be found in the monograph of Gabbay and Maksimova (2005).\nIn non-monotonic logics, interpolation has received little attention. A notable exception is an article (Amir, 2002) establishing some interpolation properties for circumscription and default logic. By the well-known relation between the answer sets of disjunctive programs and the extensions of corresponding default theories, he also derives a form of interpolation for ASP. With regard to answer set semantics, the approach of Amir is quite different from ours. Since it is founded on an analysis of default logic, it uses classical logic as an underlying base. So Amir’s version of interpolation is a form of (3) where L is classical logic; there is no requirement that ⊢L form a well-behaved sublogic of |∼, e.g. a deductive base. As Amir remarks, one cannot deduce in general from property (4) that α|∼β. However if L is classical logic one cannot even deduce α |∼ β from (3). More generally, there is no counterpart to our Proposition 1 in this case. Another difference with respect to our approach is that Amir does not discuss the nature of the |∼ relation for ASP in detail, in particular how to understand Π |∼ ϕ in case ϕ contains atoms not present in the program Π. In fact, if we interpret |∼AS as in Section 6 above, it is easy to refute (|∼,⊢L)-interpolation where L is classical logic. Let Π be the program B ← ¬A and q the query B ∧ ¬C. Then clearly\nΠ |∼AS q, but there is no formula in the vocabulary B that would classically entail ¬C. Under any interpretation of answer set inference such that atoms not in the program are regarded as false, (|∼,⊢L)-interpolation would be refuted."
    }, {
      "heading" : "10. Conclusions",
      "text" : "We have discussed two kinds of interpolation properties for non-monotonic inference relations and shown that these properties hold in turn for the two different inference relations that we can associate with propositional equilibrium logic. In each case we use the fact that the collection of equilibrium models is definable in the logic HT of here-and-there and that this logic possesses the usual form of interpolation. One of the forms of inference studied seems to be in many cases an appropriate concept to associate with answer set programming, although in general ASP systems are not tailored to query answering or deduction. Using results of Eiter and Wang (2008) about variable forgetting in ASP, we could also show how the property of uniform interpolation holds for disjunctive programs and a restricted query language.\nWe have also discussed the interpolation property for first-order equilibrium logic based on a quantified version QHT of the logic of here-and-there, obtaining analogous results as for the propositional case whenever the collection of equilibrium models is definable. These positive results transfer to answer set programming under the assumption usually made in ASP systems that programs are safe and therefore have definable collections of answer sets. As we saw, the notion of safety can be quite generally defined for theories and is not limited to normal or disjunctive programs."
    }, {
      "heading" : "Acknowledgments",
      "text" : "David Pearce is partially supported by MEC projects TIN2009-14562-C05-02 and CSD200700022. Agust́ın Valverde is partially supported by MEC project TIN2009-14562-C05-01, and Junta de Andalucia projects P09-FQM-05233 and TIC-115. The authors are grateful to the anonymous referees for helpful comments."
    } ],
    "references" : [ {
      "title" : "Interpolation theorems for nonmonotonic reasoning systems",
      "author" : [ "E. Amir" ],
      "venue" : "In Proceedings of NMR’02,",
      "citeRegEx" : "Amir,? \\Q2002\\E",
      "shortCiteRegEx" : "Amir",
      "year" : 2002
    }, {
      "title" : "A-prolog as a tool for declarative programming",
      "author" : [ "M. Balduccini", "M. Gelfond", "M. Nogueira" ],
      "venue" : "In Proc. of SEKE",
      "citeRegEx" : "Balduccini et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Balduccini et al\\.",
      "year" : 2000
    }, {
      "title" : "Knowledge Representation, Reasoning and Declarative Problem Solving",
      "author" : [ "C. Baral" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Baral,? 2003",
      "shortCiteRegEx" : "Baral",
      "year" : 2003
    }, {
      "title" : "Interpolation in practical formal development",
      "author" : [ "J. Bicarregui", "T. Dimitrakos", "D.M. Gabbay", "T.S.E. Maibaum" ],
      "venue" : "Logic Journal of the IGPL,",
      "citeRegEx" : "Bicarregui et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Bicarregui et al\\.",
      "year" : 2001
    }, {
      "title" : "Normal form nested programs",
      "author" : [ "A. Bria", "W. Faber", "N. Leone" ],
      "venue" : "Proc. of JELIA’08,",
      "citeRegEx" : "Bria et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Bria et al\\.",
      "year" : 2008
    }, {
      "title" : "A revised concept of safety for general answer set programs",
      "author" : [ "P. Cabalar", "D. Pearce", "A. Valverde" ],
      "venue" : "Proc. of LPNMR’09,",
      "citeRegEx" : "Cabalar et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Cabalar et al\\.",
      "year" : 2009
    }, {
      "title" : "Linear reasoning",
      "author" : [ "W. Craig" ],
      "venue" : "a new form of the herbrand-gentzen theorem.. J. Symb. Logic, 22, 250–268.",
      "citeRegEx" : "Craig,? 1957",
      "shortCiteRegEx" : "Craig",
      "year" : 1957
    }, {
      "title" : "Quantified equilibrium logic and hybrid rules",
      "author" : [ "J. de Bruijn", "D. Pearce", "A. Polleres", "A. Valverde" ],
      "venue" : "Proc. of RR’07,",
      "citeRegEx" : "Bruijn et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Bruijn et al\\.",
      "year" : 2007
    }, {
      "title" : "Logical support for modularisation",
      "author" : [ "R. Diaconescu", "J. Goguen", "P. Stefaneas" ],
      "venue" : "In Logical Environments,",
      "citeRegEx" : "Diaconescu et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Diaconescu et al\\.",
      "year" : 1993
    }, {
      "title" : "Deductive bases of nonmonononic inference operations",
      "author" : [ "J. Dietrich" ],
      "venue" : "Ntz report, University of Leipzig.",
      "citeRegEx" : "Dietrich,? 1994",
      "shortCiteRegEx" : "Dietrich",
      "year" : 1994
    }, {
      "title" : "On solution correspondences in answer-set programming",
      "author" : [ "T. Eiter", "H. Tompits", "S. Woltran" ],
      "venue" : "Proc. of IJCAI’05,",
      "citeRegEx" : "Eiter et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2005
    }, {
      "title" : "Semantic forgetting in answer set programming",
      "author" : [ "T. Eiter", "K. Wang" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Eiter and Wang,? \\Q2008\\E",
      "shortCiteRegEx" : "Eiter and Wang",
      "year" : 2008
    }, {
      "title" : "Logic programs with propositional connectives and aggregates",
      "author" : [ "P. Ferraris" ],
      "venue" : "CoRR, abs/0812.1462.",
      "citeRegEx" : "Ferraris,? 2008",
      "shortCiteRegEx" : "Ferraris",
      "year" : 2008
    }, {
      "title" : "A new perspective on stable models",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Proc. of IJCAI’07,",
      "citeRegEx" : "Ferraris et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Ferraris et al\\.",
      "year" : 2007
    }, {
      "title" : "Interpolation and Definability: Modal and Intuitionistic Logic",
      "author" : [ "D.M. Gabbay", "L. Maksimova" ],
      "venue" : null,
      "citeRegEx" : "Gabbay and Maksimova,? \\Q2005\\E",
      "shortCiteRegEx" : "Gabbay and Maksimova",
      "year" : 2005
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A.V. Gelder", "K.A. Ross", "J.S. Schlipf" ],
      "venue" : "Journal of ACM,",
      "citeRegEx" : "Gelder et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Gelder et al\\.",
      "year" : 1991
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proc. of ICLP’88,",
      "citeRegEx" : "Gelfond and Lifschitz,? \\Q1988\\E",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Logic programs with classical negation",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proc. of ICLP’90,",
      "citeRegEx" : "Gelfond and Lifschitz,? \\Q1990\\E",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1990
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing,",
      "citeRegEx" : "Gelfond and Lifschitz,? \\Q1991\\E",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "Forgetting and uniform interpolation in largescale description logic terminologies",
      "author" : [ "B. Konev", "D. Walther", "F. Wolter" ],
      "venue" : "Proc. of IJCAI’09,",
      "citeRegEx" : "Konev et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2009
    }, {
      "title" : "Can you tell the difference between dl-lite ontologies",
      "author" : [ "R. Kontchakov", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "Principles of Knowledge Representation and Reasoning: Proc. of KR’08,",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2008
    }, {
      "title" : "Negation in logic programming",
      "author" : [ "K. Kunen" ],
      "venue" : "Journal of Logic Programming, 4 (4), 289–308.",
      "citeRegEx" : "Kunen,? 1987",
      "shortCiteRegEx" : "Kunen",
      "year" : 1987
    }, {
      "title" : "A reductive semantics for counting and choice in answer set programming",
      "author" : [ "J. Lee", "V. Lifschitz", "R. Palla" ],
      "venue" : "Proc. of AAAI’08,",
      "citeRegEx" : "Lee et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2008
    }, {
      "title" : "Safe formulas in the general theory of stable models (preliminary report)",
      "author" : [ "J. Lee", "V. Lifschitz", "R. Palla" ],
      "venue" : "Proc. of ICLP’08,",
      "citeRegEx" : "Lee et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2008
    }, {
      "title" : "On reductive semantics of aggregates in answer set programming",
      "author" : [ "J. Lee", "Y. Meng" ],
      "venue" : "Proc. of LPNMR’09,",
      "citeRegEx" : "Lee and Meng,? \\Q2009\\E",
      "shortCiteRegEx" : "Lee and Meng",
      "year" : 2009
    }, {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "V. Lifschitz", "D. Pearce", "A. Valverde" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "Lifschitz et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 2001
    }, {
      "title" : "A characterization of strong equivalence for logic programs with variables",
      "author" : [ "V. Lifschitz", "D. Pearce", "A. Valverde" ],
      "venue" : "Proc. of LPNMR’07,",
      "citeRegEx" : "Lifschitz et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 2007
    }, {
      "title" : "Nested expressions in logic programs",
      "author" : [ "V. Lifschitz", "L.R. Tang", "H. Turner" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Lifschitz et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 1999
    }, {
      "title" : "Deciding inseparability and conservative extensions in the description logic el",
      "author" : [ "C. Lutz", "F. Wolter" ],
      "venue" : "Journal of Symbolic Computation,",
      "citeRegEx" : "Lutz and Wolter,? \\Q2010\\E",
      "shortCiteRegEx" : "Lutz and Wolter",
      "year" : 2010
    }, {
      "title" : "Equivalences of logic programs",
      "author" : [ "M.J. Maher" ],
      "venue" : "Foundations of Deductive Databases and Logic Programming., pp. 627–658. Morgan Kaufmann.",
      "citeRegEx" : "Maher,? 1988",
      "shortCiteRegEx" : "Maher",
      "year" : 1988
    }, {
      "title" : "General patterns in nonmonotonic reasoning, pp",
      "author" : [ "D. Makinson" ],
      "venue" : "35–110. Oxford University Press, Inc.",
      "citeRegEx" : "Makinson,? 1994",
      "shortCiteRegEx" : "Makinson",
      "year" : 1994
    }, {
      "title" : "Interpolation in superintuitionistic predicate logics with equality",
      "author" : [ "L. Maksimova" ],
      "venue" : "Algebra and Logic, 36, 543–561.",
      "citeRegEx" : "Maksimova,? 1997",
      "shortCiteRegEx" : "Maksimova",
      "year" : 1997
    }, {
      "title" : "Interpolation in superintuitionistic and modal predicate logics with equality",
      "author" : [ "L. Maksimova" ],
      "venue" : "M.Kracht, de Rijke, M., Wansing, H., & Zakharyaschev, M. (Eds.), Advances in Modal Logic, Vol. I, pp. 133–141. CSLI Publications.",
      "citeRegEx" : "Maksimova,? 1998",
      "shortCiteRegEx" : "Maksimova",
      "year" : 1998
    }, {
      "title" : "Craig’s interpolation theorem and amalgamable varieties",
      "author" : [ "L. Maksimova" ],
      "venue" : "Doklady Akademii Nauk SSSR, 237 (6), 1281–1284.",
      "citeRegEx" : "Maksimova,? 1977",
      "shortCiteRegEx" : "Maksimova",
      "year" : 1977
    }, {
      "title" : "Applications of craig interpolants in model checking",
      "author" : [ "K.L. McMillan" ],
      "venue" : "Halbwachs, N., & Zuck, L. D. (Eds.), Proc. of TACAS’05, Vol. 3440 of LNCS, pp. 1–12. Springer.",
      "citeRegEx" : "McMillan,? 2005",
      "shortCiteRegEx" : "McMillan",
      "year" : 2005
    }, {
      "title" : "Model extension theorem and craig’s interpolation theorem for intermediate predicate logics",
      "author" : [ "H. Ono" ],
      "venue" : "Reports on Mathematical Logic, 15, 41–58.",
      "citeRegEx" : "Ono,? 1983",
      "shortCiteRegEx" : "Ono",
      "year" : 1983
    }, {
      "title" : "A new logical characterization of stable models and answer sets",
      "author" : [ "D. Pearce" ],
      "venue" : "Dix, J., Pereira, L. M., & Przymusinski, T. C. (Eds.), Proc. of NMELP’96, Vol. 1216 of LNCS, pp. 57–70. Springer.",
      "citeRegEx" : "Pearce,? 1997",
      "shortCiteRegEx" : "Pearce",
      "year" : 1997
    }, {
      "title" : "Equilibrium logic",
      "author" : [ "D. Pearce" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence, 47 (1-2), 3–41.",
      "citeRegEx" : "Pearce,? 2006",
      "shortCiteRegEx" : "Pearce",
      "year" : 2006
    }, {
      "title" : "Computing equilibrium models using signed formulas",
      "author" : [ "D. Pearce", "I.P. de Guzmán", "A. Valverde" ],
      "venue" : "In Proc. of CL2000,",
      "citeRegEx" : "Pearce et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Pearce et al\\.",
      "year" : 2000
    }, {
      "title" : "A first order nonmonotonic extension of constructive logic",
      "author" : [ "D. Pearce", "A. Valverde" ],
      "venue" : "Studia Logica,",
      "citeRegEx" : "Pearce and Valverde,? \\Q2005\\E",
      "shortCiteRegEx" : "Pearce and Valverde",
      "year" : 2005
    }, {
      "title" : "Quantified equilibrium logic",
      "author" : [ "D. Pearce", "A. Valverde" ],
      "venue" : "Technical report, Universidad Rey Juan Carlos. (http://www.matap.uma.es/investigacion/tr/ma06_02. pdf)",
      "citeRegEx" : "Pearce and Valverde,? \\Q2006\\E",
      "shortCiteRegEx" : "Pearce and Valverde",
      "year" : 2006
    }, {
      "title" : "Quantified equilibrium logic and foundations for answer set programs",
      "author" : [ "D. Pearce", "A. Valverde" ],
      "venue" : "Proc. of ICLP’08,",
      "citeRegEx" : "Pearce and Valverde,? \\Q2008\\E",
      "shortCiteRegEx" : "Pearce and Valverde",
      "year" : 2008
    }, {
      "title" : "Synonymous theories and knowledge representations in answer set programming",
      "author" : [ "D. Pearce", "A. Valverde" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "Pearce and Valverde,? \\Q2012\\E",
      "shortCiteRegEx" : "Pearce and Valverde",
      "year" : 2012
    }, {
      "title" : "Semantic and computational advantages of the safe integration of ontologies and rules",
      "author" : [ "R. Rosati" ],
      "venue" : "Fages, F., & Soliman, S. (Eds.), Proc. of PPSWR’05, Vol. 3703 of LNCS, pp. 50–64. Springer.",
      "citeRegEx" : "Rosati,? 2005",
      "shortCiteRegEx" : "Rosati",
      "year" : 2005
    }, {
      "title" : "Der interpolationsatz der intuitionistischen prädikatenlogik",
      "author" : [ "K. Schütte" ],
      "venue" : "Math. Ann.,",
      "citeRegEx" : "Schütte,? \\Q1962\\E",
      "shortCiteRegEx" : "Schütte",
      "year" : 1962
    }, {
      "title" : "Logic and Structure (3th",
      "author" : [ "D. van Dalen" ],
      "venue" : null,
      "citeRegEx" : "Dalen,? \\Q1997\\E",
      "shortCiteRegEx" : "Dalen",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 34,
      "context" : "The interpolation property has been applied in various areas of computer science, for example in software specification (Diaconescu, Goguen, & Stefaneas, 1993; Bicarregui, Dimitrakos, Gabbay, & Maibaum, 2001), in the construction of formal ontologies (Kontchakov, Wolter, & Zakharyaschev, 2008) and in model checking and related subareas (McMillan, 2005).",
      "startOffset" : 338,
      "endOffset" : 354
    }, {
      "referenceID" : 34,
      "context" : "In other cases, interpolants themselves play a role as special formulas applied in automated deduction (McMillan, 2005).",
      "startOffset" : 103,
      "endOffset" : 119
    }, {
      "referenceID" : 37,
      "context" : "In this note we study the interpolation property for the system of nonmonotonic reasoning known as equilibrium logic (Pearce, 2006).",
      "startOffset" : 117,
      "endOffset" : 131
    }, {
      "referenceID" : 20,
      "context" : "In the first two areas interpolation is important as a metatheoretical property, in particular it may provide a basis for the modular composition and decomposition of theories; for instance, for Kontchakov et al. (2008) it plays a key role in the study of the modular decomposition of ontologies.",
      "startOffset" : 195,
      "endOffset" : 220
    }, {
      "referenceID" : 14,
      "context" : "Instead, following the idea of Gabbay and Maksimova (2005), we can modify condition (1) and proceed in a two-stage fashion.",
      "startOffset" : 31,
      "endOffset" : 59
    }, {
      "referenceID" : 37,
      "context" : "When this extension is well-behaved we say that the monotonic logic forms a deductive base1 (Pearce, 2006) for it.",
      "startOffset" : 92,
      "endOffset" : 106
    }, {
      "referenceID" : 30,
      "context" : "In terms of nonmonotonic consequence operations, (ii) and (iii) correspond to conditions known as left absorption and right absorption respectively (Makinson, 1994).",
      "startOffset" : 148,
      "endOffset" : 164
    }, {
      "referenceID" : 9,
      "context" : "It is close to the concept of fully absorbing inferential frame used by Dietrich (1994).",
      "startOffset" : 72,
      "endOffset" : 88
    }, {
      "referenceID" : 26,
      "context" : "A complete axiomatisation of QHT can be obtained as follows (Lifschitz et al., 2007).",
      "startOffset" : 60,
      "endOffset" : 84
    }, {
      "referenceID" : 33,
      "context" : "The resulting logic is called Quantified Here-and-There Logic with static domains (Lifschitz, Pearce, & Valverde, 2007) denoted by QHT. In terms of satisfiability and validity this logic is equivalent to the logic introduced by Pearce and Valverde (2005). A complete axiomatisation of QHT can be obtained as follows (Lifschitz et al.",
      "startOffset" : 94,
      "endOffset" : 255
    }, {
      "referenceID" : 26,
      "context" : "We denote the resulting logic by QHT= (Lifschitz et al., 2007) and its inference relation by ⊢.",
      "startOffset" : 38,
      "endOffset" : 62
    }, {
      "referenceID" : 33,
      "context" : "In addition HT is one of precisely seven superintuitionistic propositional logics possessing the interpolation property (Maksimova, 1977; Gabbay & Maksimova, 2005).",
      "startOffset" : 120,
      "endOffset" : 163
    }, {
      "referenceID" : 35,
      "context" : "For languages without function symbols Ono showed that interpolation holds in the logic QHT of quantified here-and-there with constant domains (Ono, 1983).",
      "startOffset" : 143,
      "endOffset" : 154
    }, {
      "referenceID" : 37,
      "context" : "The following definition give a preliminary notion of equilibrium entailment, which agrees with standard versions of equilibrium logic (Pearce, 2006).",
      "startOffset" : 135,
      "endOffset" : 149
    }, {
      "referenceID" : 21,
      "context" : "In logic programming, where these restrictions are usually assumed, different solutions to this problem have been proposed (Gelder, Ross, & Schlipf, 1991; Kunen, 1987; Maher, 1988).",
      "startOffset" : 123,
      "endOffset" : 180
    }, {
      "referenceID" : 29,
      "context" : "In logic programming, where these restrictions are usually assumed, different solutions to this problem have been proposed (Gelder, Ross, & Schlipf, 1991; Kunen, 1987; Maher, 1988).",
      "startOffset" : 123,
      "endOffset" : 180
    }, {
      "referenceID" : 36,
      "context" : "The first property is precisely the strong equivalence theorem of Lifschitz, Pearce and Valverde (2001). Maximality follows from the fact that any logic strictly stronger than HT would have to contain classical logic which is easily seen not to be a deductive base, e.",
      "startOffset" : 77,
      "endOffset" : 104
    }, {
      "referenceID" : 12,
      "context" : "As Ferraris et al. (2007) have pointed out, in the general form of answer set programming where first-order formulas are allowed, and a fortiori in quantified equilibrium logic, the property of transitive closure is expressible.",
      "startOffset" : 3,
      "endOffset" : 26
    }, {
      "referenceID" : 13,
      "context" : "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised.",
      "startOffset" : 103,
      "endOffset" : 142
    }, {
      "referenceID" : 12,
      "context" : "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised.",
      "startOffset" : 103,
      "endOffset" : 142
    }, {
      "referenceID" : 12,
      "context" : "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas and by Bria, Faber and Leone (2008) for a more restricted syntactic class.",
      "startOffset" : 104,
      "endOffset" : 272
    }, {
      "referenceID" : 12,
      "context" : "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas and by Bria, Faber and Leone (2008) for a more restricted syntactic class.",
      "startOffset" : 104,
      "endOffset" : 341
    }, {
      "referenceID" : 12,
      "context" : "For the more complex formulas admitted by equilibrium logic and by the general approach to answer sets (Ferraris et al., 2007; Ferraris, 2008), new concepts of safety need to be devised. Proposals for suitable safety concepts were made by Lee, Lifschitz and Palla (2008b) for general first-order formulas and by Bria, Faber and Leone (2008) for a more restricted syntactic class. More recently Cabalar, Pearce and Valverde (2009) have generalised both these approaches and suggested a safety concept for arbitrary function-free formulas in equilibrium logic.",
      "startOffset" : 104,
      "endOffset" : 430
    }, {
      "referenceID" : 36,
      "context" : "This definition of semi-safe formulas was introduced by Cabalar, Pearce and Valverde (2009) and generalises the former definition of Lee, Lifschitz and Palla (2008b).",
      "startOffset" : 65,
      "endOffset" : 92
    }, {
      "referenceID" : 36,
      "context" : "This definition of semi-safe formulas was introduced by Cabalar, Pearce and Valverde (2009) and generalises the former definition of Lee, Lifschitz and Palla (2008b). In short, a variable x is semi-safe in φ if every occurrence is inside some subformula α → β such that, either x ∈ RV(α) or x is semi-safe in β.",
      "startOffset" : 65,
      "endOffset" : 166
    }, {
      "referenceID" : 5,
      "context" : "Proposition 11 (Cabalar et al., 2009) If φ is function free, semi-safe, and 〈(D, I), T, T 〉 |= φ, then 〈(D, I), T |C , T 〉 |= φ.",
      "startOffset" : 15,
      "endOffset" : 37
    }, {
      "referenceID" : 5,
      "context" : "Theorem 2 (Cabalar et al., 2009) If φ is function free, semi-safe, and 〈(D, I), T, T 〉 is an equilibrium model of φ, then T |C = T .",
      "startOffset" : 10,
      "endOffset" : 32
    }, {
      "referenceID" : 5,
      "context" : "Proposition 12 (Cabalar et al., 2009) If φ is function free, safe, and prenex formula, then: 〈(D, I), T, T 〉 is an equilibrium model of φ if and only if it is an equilibrium model of GrC(φ) (the grounding of φ over C).",
      "startOffset" : 15,
      "endOffset" : 37
    }, {
      "referenceID" : 5,
      "context" : "However, we can also apply Propositions 9 and 10 directly by noting the property shown by Cabalar et al. (2009) that safe prenex formulas have definable classes of equilibrium models.",
      "startOffset" : 90,
      "endOffset" : 112
    }, {
      "referenceID" : 2,
      "context" : "For a textbook treatment the reader is referred to Baral’s book (2003). As is also well-known, the origins of ASP lie in the stable model and answer set semantics for logic programs introduced by Gelfond and Lifschitz (1988, 1990, 1991).",
      "startOffset" : 51,
      "endOffset" : 71
    }, {
      "referenceID" : 13,
      "context" : "The correspondence between answer set semantics and equilibrium logic is also wellestablished and has been discussed in many publications, beginning with Pearce (1997), who first showed how the answer sets of disjunctive programs can be regarded as equilibrium models (Lifschitz et al., 2001, 2007; Ferraris et al., 2007; Pearce & Valverde, 2005, 2006, 2008).",
      "startOffset" : 268,
      "endOffset" : 358
    }, {
      "referenceID" : 31,
      "context" : "The correspondence between answer set semantics and equilibrium logic is also wellestablished and has been discussed in many publications, beginning with Pearce (1997), who first showed how the answer sets of disjunctive programs can be regarded as equilibrium models (Lifschitz et al.",
      "startOffset" : 154,
      "endOffset" : 168
    }, {
      "referenceID" : 34,
      "context" : "This was first shown by Pearce (1997) but the basic equivalence was later shown to hold for more general classes of programs by Pearce, P.",
      "startOffset" : 24,
      "endOffset" : 38
    }, {
      "referenceID" : 34,
      "context" : "This was first shown by Pearce (1997) but the basic equivalence was later shown to hold for more general classes of programs by Pearce, P. de Guzman and Valverde (2000). It is also common to treat non-ground rules of form (7) where variables may appear.",
      "startOffset" : 24,
      "endOffset" : 169
    }, {
      "referenceID" : 12,
      "context" : "At the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of stable model for arbitrary first-order formulas.",
      "startOffset" : 22,
      "endOffset" : 57
    }, {
      "referenceID" : 12,
      "context" : "At the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of stable model for arbitrary first-order formulas. In this case the property of being a stable model is defined syntactically via a second-order condition that resembles parallel circumscription. However they also showed that the new notion of stable model is equivalent to that of equilibrium model as defined here for first-order languages. In a sequel to this paper, Lee, Lifschitz and Palla (2008a) have applied the new definition and made the following refinements.",
      "startOffset" : 22,
      "endOffset" : 487
    }, {
      "referenceID" : 12,
      "context" : "At the other extreme, Ferraris, Lee and Lifschitz (2007) provided a new definition of stable model for arbitrary first-order formulas. In this case the property of being a stable model is defined syntactically via a second-order condition that resembles parallel circumscription. However they also showed that the new notion of stable model is equivalent to that of equilibrium model as defined here for first-order languages. In a sequel to this paper, Lee, Lifschitz and Palla (2008a) have applied the new definition and made the following refinements. The stable models of a formula are defined as Ferraris et al. (2007) were, while the answer sets of a formula are those Herbrand models of the formula that are stable in the sense of Ferraris et al.",
      "startOffset" : 22,
      "endOffset" : 624
    }, {
      "referenceID" : 1,
      "context" : "Conjunctions and disjunctions are handled in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000).",
      "startOffset" : 61,
      "endOffset" : 119
    }, {
      "referenceID" : 1,
      "context" : "Sometimes, queries of the form not a, or in logical notation ¬a, are not explicitly dealt with (Balduccini et al., 2000).",
      "startOffset" : 95,
      "endOffset" : 120
    }, {
      "referenceID" : 43,
      "context" : "On the other hand, there are contexts where answer set semantics is used in a more open world setting, for example in the setting of hybrid knowledge bases (Rosati, 2005) where non-monotonic rules are combined with ontologies formalised in description logics.",
      "startOffset" : 156,
      "endOffset" : 170
    }, {
      "referenceID" : 1,
      "context" : "Conjunctions and disjunctions are handled in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000). Sometimes, queries of the form not a, or in logical notation ¬a, are not explicitly dealt with (Balduccini et al., 2000). However it seems to be in keeping with the semantics to regard a formula of form not α or ¬α to be true in an answer set if and only if α is not true. Another way to express this would be to say that an answer set satisfies ¬α if it does not violate the constraint {← α}, understanding constraint violation as Lifschitz, Tang and Turner (1999).9 In this way we would say that Π |∼AS ¬A if no answer set of Π contains A.",
      "startOffset" : 95,
      "endOffset" : 587
    }, {
      "referenceID" : 1,
      "context" : "Conjunctions and disjunctions are handled in the obvious way (Lifschitz, Tang, & Turner, 1999; Balduccini et al., 2000). Sometimes, queries of the form not a, or in logical notation ¬a, are not explicitly dealt with (Balduccini et al., 2000). However it seems to be in keeping with the semantics to regard a formula of form not α or ¬α to be true in an answer set if and only if α is not true. Another way to express this would be to say that an answer set satisfies ¬α if it does not violate the constraint {← α}, understanding constraint violation as Lifschitz, Tang and Turner (1999).9 In this way we would say that Π |∼AS ¬A if no answer set of Π contains A. Similarly, the interpretation of queries containing quantifiers in answer set semantics should also conform to that of equilibrium logic, taking account of any specific restrictions, such as Herbrand models, that might be imposed. We can therefore transfer interpolation properties from equilibrium logic to answer set semantics and ASP. It remains to consider whether |∼AS is best identified with the closed world version of inference, |∼cw, or the more open world version, |∼ow. Again, since ASP solvers do not generally implement inference engines, the difference is largely a theoretical one. In traditional logic programming, however, a query that does not belong to the language of the program is usually answered false. It also seems quite natural in an ASP context that, given a program Π and a query Q, one should consider the stable models of Π in the language L(Π)∪L(Q) even if this is a proper extension of the language of Π.10 So in general |∼cw seems a natural choice for answer set inference. On the other hand, there are contexts where answer set semantics is used in a more open world setting, for example in the setting of hybrid knowledge bases (Rosati, 2005) where non-monotonic rules are combined with ontologies formalised in description logics. For such systems a semantics in terms of equilibrium logic was provided by de Bruijn, Pearce, Polleres and Valverde (2007). Here an entailment relation in the style of |∼ow might sometimes be more appropriate.",
      "startOffset" : 95,
      "endOffset" : 2054
    }, {
      "referenceID" : 3,
      "context" : "The Interpolation property has been applied in various areas of computer science, notably in software specification (Bicarregui et al., 2001) and in the construction of formal ontologies (Lutz & Wolter, 2010).",
      "startOffset" : 116,
      "endOffset" : 141
    }, {
      "referenceID" : 28,
      "context" : "The above proof is similar to the argument given by Lutz and Wolter (2010) for Theorem 7 of that paper, applied to TBoxes in description logics.",
      "startOffset" : 52,
      "endOffset" : 75
    }, {
      "referenceID" : 19,
      "context" : "A stronger form of interpolation known as uniform interpolation is also important for certain applications in computer science (Konev et al., 2009).",
      "startOffset" : 127,
      "endOffset" : 147
    }, {
      "referenceID" : 20,
      "context" : "For example it has been shown to hold for some description logics (Kontchakov et al., 2008) where such syntactic restrictions apply.",
      "startOffset" : 66,
      "endOffset" : 91
    }, {
      "referenceID" : 11,
      "context" : "Variable forgetting, as studied by Eiter and Wang (2008), is concerned with the following problem.",
      "startOffset" : 35,
      "endOffset" : 57
    }, {
      "referenceID" : 11,
      "context" : "Then we choose Π′ to be the result of forgetting about X in Π, defined by Eiter and Wang (2008) as follows: forget(Π,X) := forget(forget(forget(Π, a1), a2), .",
      "startOffset" : 74,
      "endOffset" : 96
    }, {
      "referenceID" : 11,
      "context" : "(12) Let Π′ be forget(Π,X) as determined by algorithm 1 of Eiter and Wang (2008) described above.",
      "startOffset" : 59,
      "endOffset" : 81
    }, {
      "referenceID" : 11,
      "context" : "As Eiter and Wang (2008) point out, if an atom b is true in some answer set of forget(Π, a), then it must also be true in some answer set of Π, showing that (12) holds for literals.",
      "startOffset" : 3,
      "endOffset" : 25
    }, {
      "referenceID" : 11,
      "context" : "If we establish uniform interpolation in ASP using the method of forgetting, as defined by Eiter and Wang (2008), it seems clear that we cannot extend in a non-trivial way the expressive power of the query language L.",
      "startOffset" : 91,
      "endOffset" : 113
    }, {
      "referenceID" : 0,
      "context" : "A notable exception is an article (Amir, 2002) establishing some interpolation properties for circumscription and default logic.",
      "startOffset" : 34,
      "endOffset" : 46
    }, {
      "referenceID" : 5,
      "context" : "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Schütte (1962).",
      "startOffset" : 56,
      "endOffset" : 69
    }, {
      "referenceID" : 5,
      "context" : "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Schütte (1962). Maksimova (1977) characterised the super-intuitionistic propositional logics possessing interpolation.",
      "startOffset" : 56,
      "endOffset" : 127
    }, {
      "referenceID" : 5,
      "context" : "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Schütte (1962). Maksimova (1977) characterised the super-intuitionistic propositional logics possessing interpolation.",
      "startOffset" : 56,
      "endOffset" : 145
    }, {
      "referenceID" : 5,
      "context" : "The interpolation theorem for classical logic is due to Craig (1957); it was extended to intutionistic logic by Schütte (1962). Maksimova (1977) characterised the super-intuitionistic propositional logics possessing interpolation. A modern, comprehensive treatment of interpolation in modal and intuitionistic logics can be found in the monograph of Gabbay and Maksimova (2005). In non-monotonic logics, interpolation has received little attention.",
      "startOffset" : 56,
      "endOffset" : 378
    }, {
      "referenceID" : 11,
      "context" : "Using results of Eiter and Wang (2008) about variable forgetting in ASP, we could also show how the property of uniform interpolation holds for disjunctive programs and a restricted query language.",
      "startOffset" : 17,
      "endOffset" : 39
    } ],
    "year" : 2011,
    "abstractText" : "Interpolation is an important property of classical and many non-classical logics that has been shown to have interesting applications in computer science and AI. Here we study the Interpolation Property for the the non-monotonic system of equilibrium logic, establishing weaker or stronger forms of interpolation depending on the precise interpretation of the inference relation. These results also yield a form of interpolation for ground logic programs under the answer sets semantics. For disjunctive logic programs we also study the property of uniform interpolation that is closely related to the concept of variable forgetting. The first-order version of equilibrium logic has analogous Interpolation properties whenever the collection of equilibrium models is (first-order) definable. Since this is the case for so-called safe programs and theories, it applies to the usual situations that arise in practical answer set programming.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}