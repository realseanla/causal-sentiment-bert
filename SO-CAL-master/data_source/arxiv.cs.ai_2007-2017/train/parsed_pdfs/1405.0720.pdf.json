{
  "name" : "1405.0720.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Alessandra Mileo" ],
    "emails" : [ "matthias.nickles@deri.org", "alessandra.mileo@deri.org" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 5.\n07 20\nv1 [\ncs .A\nI] 4\nM ay\n2 01\nKeywords: Uncertainty Reasoning, Answer Set Programming, Probabilistic Inductive Logic Programming, Statistical Relational Learning, SAT"
    }, {
      "heading" : "1 Introduction",
      "text" : "Reasoning in the presence of uncertainty and relational structures (such as social networks and Linked Data) is an important aspect of knowledge discovery and representation for the Web, the Internet Of Things, and other potentially heterogeneous and complex domains. Probabilistic logic programing, and the ability to learn probabilistic logic programs from data, can provide an attractive approach to uncertainty reasoning and statistical relational learning, since it combines the deduction power and declarative nature of logic programming with probabilistic inference abilities traditionally known from less expressive graphical models such as Bayesian and Markov networks. A very successful type of logic programming for nonmonotonic domains is Answer Set Programming (ASP) (Lifschitz 2002; Gelfond and Lifschitz 1988). Since statistical-relational approaches to probabilistic reasoning often rely heavily on the\n∗This work is an extended and revised version of A. Mileo, M. Nickles: Probabilistic Inductive Answer Set Programming by Model Sampling and Counting. First International Workshop on Learning and Nonmonotonic Reasoning (LNMR 2013), Corunna, Spain, 2013.\npropositionalization of first-order or other relational information, ASP appears to be an ideal basis for probabilistic logic programming, given its expressiveness and the existence of highly optimized grounders and solvers. However, despite the successful employment of conceptually related approaches in the area of SAT for probabilistic inference tasks, only a small number of approaches to probabilistic knowledge representation or probabilistic inductive logic programming under the stable model semantics exist so far, of which some are rather restrictive wrt. expressiveness and parameter estimation techniques. We build upon these and other existing approaches in the area of probabilistic (inductive) logic programming in order to provide a new ASPbased probabilistic logic programming language (with firstorder as well as ASP basic syntax) for the representation of probabilistic knowledge. Weights which directly represent probabilities can be attached to arbitrary formulas, and we show how this can be used to perform probabilistic inference and how weights of hypotheses can be inductively learned from given relational examples. To the best of our knowledge, this is the first ASP-based approach to probabilistic (inductive) logic programming which does not impose restrictions on the annotation of ASP-rules and facts as well as FOL-style formulas with probabilities.\nThe remainder of this paper is organized as follows: the next section presents relevant related approaches. Section 3 introduces syntax and semantics of our new language. Section 4 presents our approach to probabilistic inference (including examples), and Section 5 shows how formula weights can be learned from data. Section 6 concludes."
    }, {
      "heading" : "2 Related Work",
      "text" : "Being one of the early approaches to the logic-based representation of uncertainty sparked by Nilsson’s seminal work (Nilsson 1986), (Halpern 1990) presents three different probabilistic first-order languages, and compares them with a related approach by Bacchus (Bacchus 1990). One language has a domain-frequency (or statistical) semantics, one has a possible worlds semantics (like our approach), and one bridges both types of semantics. While those languages as such are mainly of theoretical relevance, their types of semantics still form the backbone of most practically relevant contemporary approaches. Many newer approaches, including Markov Logic Net-\nworks (see below), require a possibly expensive grounding (propositionalization) of first-order theories over finite domains. A recent approach which does not fall into this category but employs the principle of maximum entropy in favor of performing extensive groundings is (Thimm and Kern-Isberner 2012). However, since ASP is predestined for efficient grounding, we do not see grounding necessarily as a shortcoming. Stochastic Logic Programs (SLPs) (Muggleton 2000) are an influential approach where sets of rules in form of range-restricted clauses can be labeled with probabilities. Parameter learning for SLPs is approached in (Cussens 2000) using the EM-algorithm. Approaches which combine concepts from Bayesian network theory with relational modeling and learning are, e.g., (Friedman et al. 1999; Kersting and Raedt 2000; Laskey and Costa 2005). Probabilistic Relational Models (PRM) (Friedman et al. 1999) can be seen as relational counterparts to Bayesian networks In contrast to these, our approach does not directly relate to graphical models such as Bayesian or Markov Networks but works on arbitrary possible worlds which are generated by ASP solvers. ProbLog (Raedt, Kimmig, and Toivonen 2007) allows for probabilistic facts and definite clauses, and approaches to probabilistic rule and parameter learning (from interpretations) also exist for ProbLog. Inference is based on weighted model counting, which is similarly to our approach, but uses Boolean satisfiability instead of stable model search. ProbLog builds upon the very influential Distribution Semantics introduced for PRISM (Sato and Kameya 1997), which is also used by other approaches, such as Independent Choice Logic (ICL) (Poole 1997). Another important approach outside the area of ASP are Markov Logic Networks (MLN) (Richardson and Domingos 2006), which are related to ours. A MLN consists of first-order formulas annotated with weights (which are not probabilities). MLNs are used as “templates” from which Markov networks are constructed, i.e., graphical models for the joint distribution of a set of random variables. The (ground) Markov network generated from the MLN then determines a probability distribution over possible worlds. MLNs are syntactically similar to the logic programs in our framework (in our framework, weighted formulas can also be seen as soft or hard constraints for possible worlds), however, in contrast to MLN, we allow for probabilities as formula weights. Our initial approach to weight learning is closely related to certain approaches to MLN parameter learning (e.g., (Lowd and Domingos 2007)), as described in Section 5. Located in the field of nonmonotonic logic programming, our approach is also influenced by P-log (Baral, Gelfond, and Rushton 2009) and abduction-based rule learning in probabilistic nonmonotonic domains (Corapi et al. 2011). With P-log, our approaches shares the view that answer sets can be seen as possible worlds in the sense of (Nilsson 1986). However, the syntax of P-log is quite different from our language, by restricting probabilistic annotations to certain syntactical forms and by the concept of independent experiments, which simplifies the implementation of their framework. In distinction from P-log, there is no particular coverage for causality modeling\nin our framework. (Corapi et al. 2011) allows to associate probabilities with abducibles and to learn both rules and probabilistic weights from given data (in form of literals). In contrast, our present approach does not comprise rule learning. However, our weight learning algorithm allows for learning from any kind of formulas and for the specification of virtually any sort of hypothesis as learning target, not only sets of abducibles. Both (Corapi et al. 2011) and our approach employ gradient descent for weight learning. Other approaches to probabilistic logic programming based on the stable model semantics for the logic aspects include (Saad and Pontelli 2005) and (Ng and Subrahmanian 1994). (Saad and Pontelli 2005) appears to be a powerful approach, but restricts probabilistic weighting to certain types of formulas, in order to achieve a low computational reasoning complexity. Its probabilistic annotation scheme is similar to that proposed in (Ng and Subrahmanian 1994). (Ng and Subrahmanian 1994) provides both a language and an in-depth investigation of the stable model semantics (in particular the semantics of non-monotonic negation) of probabilistic deductive databases. Our approach (and ASP in general) is closely related to SAT solving, #SAT and constraint solving. ASP formulas in our language are constraints for possible worlds (legitimate models). As (Sang, Beame, and Kautz 2005) shows, Bayesian networks can be “translated” into a weighted model counting problem over propositional formulas, which is related to our approach to probabilistic inference, although details are quite different. Also, the XOR constraining approach (Gomes, Sabharwal, and Selman 2006) employed for sampling of answer sets (Section 4) has originally been invented for the sampling of propositional truth assignments."
    }, {
      "heading" : "3 Probabilistic Answer Set Programming with PrASP",
      "text" : "Before we turn to probabilistic inference and parameter estimation, we introduce our new language for probabilistic non-monotonic logic programming, called Probabilistic Answer Set Programming (PrASP ).\nSyntax: Just add probabilities To remove unnecessary syntax restrictions and because we will later require certain syntactic modifications of given programs which are easier to express in FirstOrder Logic (FOL) notation, we allow for FOL statements in our logic programs, using the F2LP conversion tool (Lee and Palla 2009). More precisely, a PrASP program consists of ground or non-ground formulas in unrestricted first-order syntax annotated with numerical weights (provided by some domain expert or learned from data). Weights directly represent probabilities. If the weights are removed, and provided finite variable domains, any such program can be converted into an equivalent answer set program by means of the transformation described in (Lee and Palla 2009).\nLet Φ be a set of function, predicate and object symbols andL(Φ) a first-order language overΦ and the usual connec-\ntives (including both strong negation “-” and default negation “not”) and first-order quantifiers. Formally, a PrASP program is a non-empty finite set {([p], fi)} of PrASP formulas where each formula fi ∈ L(Φ) is annotated with a weight [p]. A weight directly represents a probability (provided it is probabilistically sound). If the weight is omitted for some formula of the program, weight [1] is assumed. The weight p of [p] f is denoted as w(f). Weighted formulas can intuitively seen as constraints which specify which possible worlds are indeed possible, and with which probability. Let Λ− denote PrASP program Λ stripped of all weights. Weights need to be probabilistically sound, in the sense that the system of inequalities (1) - (4) in Section 3 must have at least one solution (however, in practice this does not need to be strictly the case, since the constraint solver employed for finding a probability distribution over possible worlds can find approximate solutions often even if the given weights are inconsistent).\nIn order to translate conjunctions of unweighted formulas in first-order syntax into disjunctive programs with a stable model semantics, we further define transformation lp : L(Φ) ∪ dLp(Φ) → dLp(Φ), where dLp(Φ) is the set of all disjunctive programs over Φ. The details of this transformation can be found in (Lee and Palla 2009)1. Applied to rules and facts in ASP syntax, lp simply returns these. This allows to make use of the wide range of advanced possibilities offered by contemporary ASP grounders in addition to FOL syntax (such as aggregates), although when defining the semantics of programs, we consider only formulas in FOL syntax.\nSemantics\nThe probabilities attached to formulas in a PrASP program induce a probability distribution over answer sets of an ordinary answer set program which we call the spanning program associated with that PrASP program. Informally, the idea is to transform a PrASP program into an answer set program whose answer sets reflect the nondeterminism introduced by the probabilistic weights: each annotated formula might hold as well as not hold (unless its weight is [0] or [1]). Of course, this transformation is lossy, so we need to memorize the weights for the later computation of a probability distribution over possible worlds. The important aspect of the spanning program is that it programmatically generates a set of possible worlds in form of answer sets. Technically, the spanning program ρ(Λ) of PrASP program Λ is a disjunctive program obtained by transformation lp(Λ′). We generate Λ′ from Λ by removing all weights and transforming each formerly weighted formula f into a disjunction f |not f , where not stands for default negation and | stands for the disjunction in ASP (so probabilities are “default probabilities” in our framework). Note that\n1The use of the translation into ASP syntax requires either an ASP solver which can deal directly with disjunctive logic programs (such as claspD) or a grounder which is able to shift disjunctions from the head of the respective rules into the bodies, such as gringo (Gebser, Kaufmann, and Schaub 2012).\nf |not f doesn’t guarantee that answer sets are generated for weighted formula f . By using ASP choice constructs such as aggregates and disjunctions, the user can basically generate as many answer sets (possible worlds) as desired.\nFormulas do not need to be ground - as defined in Section 3, they can contain existentially as well as universally quantified variables in the FOL sense (although restricted to finite domains). As an example, consider the following simple ground PrASP program (examples for PrASP programs with variables and first-order style quantifiers are presented in the next sections):\n[ 0 . 7 ] q <− p . [ 0 . 3 ] p . [ 0 . 2 ] −p & r .\nThe set of answer sets (which we take as possible worlds) of the spanning program of this PrASP program is {{p, q}, {−p, r}, {}, {p}}.\nThe semantics of a PrASP program Λ and single PrASP formulas is defined in terms of a probability distribution over a set of possible worlds (in form of answer sets of ρ(Λ)) in connection with the stable model semantics. This is analogously to the use of Type 2 probability structures (Halpern 1990) for first-order probabilistic logics with probabilities, but restricted to finite domains of discourse.\nLet M = (D,Θ, π, µ) be a probability structure where D is a finite discrete domain of objects, Θ is a non-empty set of possible worlds, π a function which assigns to the symbols in Φ (see Section 3) predicates, functions and objects over/from D, and µ a discrete probability function over Θ. Each possible world is a Herbrand interpretation over Φ. Since we will use answer sets as possible worlds, defining Γ(a) to be the set of all answer sets of answer set program a will become handy. For example, given ρ(Λ) as (uncertain) knowledge, the set of worlds deemed possible according to existing belief ρ(Λ) is Γ(ρ(Λ)) in our framework.\nWe define a (non-probabilistic) satisfaction relation of possible worlds and unannotated programs as follows: let Λ− be is an unannotated program. Then (M, θ) Θ Λ− iff θ ∈ Γ(lp(Λ−)) and θ ∈ Θ (from this it follows that Θ induces its own closed world assumption - any answer set which is not in Θ is not satisfiable wrt. Θ). The probability µ({θ}) of a possible world θ is denoted as Pr(θ) and sometimes called “weight” of θ. For a disjunctive program ψ, we analogously define (M, θ) Θ ψ iff θ ∈ Γ(ψ) and θ ∈ Θ.\nTo do groundwork for the computation of a probability distribution over possible worlds Θ which are “generated” and weighted by some given background knowledge in form of a PrASP program, we define a (non-probabilistic) satisfaction relation of possible worlds and unannotated formulas: let φ be a PrASP formula (without weight) and θ be a possible world. Then (M, θ) Λ φ iff (M, θ) Θ ρ(Λ)∪ lp(φ) and Θ = Γ(ρ(Λ)) (we say formula φ is true in possible world θ). Sometimes we will just write θ |=Λ φ if M is given by the context. A notable property of this definition is that it does not restrict us to single ground formulas. Essentially, an unannotated formula φ can be any answer set program specified in FOL syntax, even if its grounding\nconsists of multiple sentences. Observe that Θ restricts Λ to answer sets of ρ(Λ). For convenience, we will abbreviate (M, θ) Λ φ as θ Λ φ. Pr(φ) denotes the probability of a formula φ, with Pr(φ) = µ({θ ∈ Θ : (M, θ) Λ φ}). Note that this holds both for annotated and unannotated formulas: even if it has a weight attached, the probability of a PrASP formula is defined by means of µ and only indirectly by its manually assigned weight (weights are used below as constraints for the computation of a probabilistically consistent µ). Further observe that there is no particular treatment for conditional probabilities in our framework;Pr(a|b) is simply calculated as Pr(a ∧ b)/Pr(b). While our framework so far is general enough to account for probabilistic inference using unrestricted programs and query formulas (provided we are given a probability distribution over the possible answer sets), this generality also means a relatively high complexity in terms of computability for inference-heavy tasks which rely on the repeated application of operator Λ, even if we would avoid the transformation lp and restrict ourselves to the use of ASP syntax.\nThe obvious question now, addressed before for other probabilistic logics, is how to compute µ, i.e., how to obtain a probability distribution over possible worlds (which tells us for each possible world the probability with which this possible world is the actual world) from a given annotated programΛ in a sound and computationally inexpensive way. Generally, we can express the search for probability distributions in form of a number of constraints which constitute a system of linear inequalities (which reduce to linear equalities for point probabilities as weights). This system typically has multiple or even infinitely many solutions (even though we do not allow for probability intervals) and computation can be costly, depending on the number of possible worlds according to ρ(Λ). We define the parameterized probability distribution µ(Λ,Θ) over a set Θ of answer sets as the solution (for all Pr(θi)) of the following system of linear equations and an inequality (if precisely one solution exists) or as the solution with maximum entropy (Thimm and Kern-Isberner 2012), in case multiple solutions exist 2. We require that the given weights in a PrASP program are chosen such that the following constraint system has at least one solution.\n∑\nθi∈Θ:θi Λf1\nPr(θi) = w(f1) (1)\n· · · ∑\nθi∈Θ:θi Λfn\nPr(θi) = w(fn) (2)\n∑\nθi∈Θ\nθi = 1 (3)\n∀θi ∈ Θ : 0 ≤ Pr(θi) ≤ 1 (4)\n2Since in this case the number of solutions of the system of linear equations is infinite, de facto we need to choose the maximum entropy solution of some finite subset. In the current prototype implementation, we generate a user-defined number of random solutions derived from a solution computed using a constrained variant of Singular Value Decomposition and the null space of the coefficient matrix of the system of linear equations (1)-(3).\nAt this, Λ = {f1, ..., fn} is a PrASP program. The canonical probability distribution µ(Λ) of Λ is defined as µ(Λ,Γ(ρ(Λ))). In the rest of the paper, we refer to µ(Λ) when we refer to the probability distribution over the answer sets of the spanning program of a given PrASP program Λ."
    }, {
      "heading" : "4 Inference",
      "text" : "Given possible world weights (µ(Λ)), probabilistic inference becomes a model counting task where each model has a weight: we can compute the probability of any query formula φ by summing up the probabilities (weights) of those possible worlds (models) where φ is true. To make this viable even for larger sets of possible worlds, we optionally restrict the calculation of µ(Λ) to a number of answer sets sampled near-uniformly at random from the total set of answer sets of the spanning program, as described in Section 4.\nAdding a sampling step and computing probabilities All tasks described so far (solving the system of (in)equalities, counting of weighted answer sets) become intractable for very large sets of possible worlds. To tackle this issue, we want to restrict the application of these tasks to a sampled subset of all possible worlds. Concretely, we want to find a way to sample (near-)uniformly from the total set of answer sets without computing a very large number of answer sets. While this way the set of answer sets cannot be computed using only a single call of the ASP solver but requires a number of separate calls (each with different sampling constraints), the required solver calls can be performed in parallel. However, a shortcoming of the sampling approach is that there is currently no way to pre-compute the size of the minimally required set of samples.\nGuaranteeing near-uniformity in answer set sampling looks like a highly non-trivial task, since any set of answers obtained from ASP solvers as a subset of the total set of answer sets is typically not uniformly distributed but strongly biased in hardly foreseeable ways (due to various interplaying heuristics applied by modern solvers), so we could not simply request any single answer set from the solver.\nHowever, we can make use of so-called XOR constraints (a form of streamlining constraints in the area of SAT solving) for near-uniform sampling (Gomes, Sabharwal, and Selman 2006) to obtain samples from the space of all answer sets, within arbitrarily narrow probabilistic bounds, using any off-the-shelf ASP solver. Compared to approaches which use Markov Chain Monte Carlo (MCMC) methods to sample from some given distribution, this method has the advantage that the sampling process is typically faster and that it requires only an off-the-shelf ASP solver (which is in the ideal case employed only once per sample, in order to obtain a single answer set). However, a shortcoming is that we are not doing Importance Sampling this way - the probability of a possible world is not taken into account but computed later\nfrom the samples. Counting answer sets could also be achieved using XOR constraints, however, this is not covered in this paper, since it does not comprise weighted counting, and we could normally not use an unweighted counting approach directly.\nXOR constraints were originally defined over a set of propositional variables, which we identify with a set of ground atoms V = {a1, ..., an}. Each XOR constraint is represented by a subset D of V ∪ {true}. D is satisfied by some model if an odd number of elements of D are satisfied by this model (i.e., the constraint acts like a parity of D). In ASP syntax, an XOR constraint can be represented for example as :- #even{ a1, ..., an } (Gebser et al. 2011). In our approach, XOR constraints are independently at random drawn from a probability distribution X(|V |, 0.5) over the set V of all possible XOR constraints over all ground atoms of the ground answer set program resulting from ρ(Λ). X(|V |, 0.5) is defined such that each XOR constraint is drawn from this distribution independently at random with probability 0.5 and includes true with probability 0.5. In effect, any given XOR constraint is drawn with probability 2−(|V |+1|) (see (Gomes, Sabharwal, and Selman 2006) for details). Since adding an XOR constraint to an answer set program eliminates any given answer set with probability 0.5, it cuts the set of answer sets in half in expectation. Iteratively adding a small number of XOR constraints to an answer set program therefore reduces the number of answer sets to a small number also. If this process results in a single answer set, the remaining answer set is drawn near-uniformly from the original set of answer sets, as shown in (Gomes, Sabharwal, and Selman 2006). Since for answer set programs the costs of repeating the addition of constraints until precisely a single answer set remains appears to be higher than the costs of computing somewhat too many models, we just estimate the number of required constraints and choose randomly from the resulting set of answer sets. The following way of answer set sampling using XOR constraints has been used before in Xorro (a tool which is part of the Potassco set of ASP tools (Gebser et al. 2011)) in a very similar way.\nFunction sample: ψ 7→ γ Given any disjunctive programψ, the following procedure computes a random sample γ from the set of all answer sets of ψ: ψg ← ground(ψ) ga ← atoms(ψg) xors ← XOR constraints {xor1, ..., xorn} over ga, drawn from X(|V |, 0.5) ψ′ ← ψ ∪ xors γ ← an answer set selected randomly from Γ(ψ′)\nAt this, the number of constraints n is set to a value large enough to produce one or a very low number of answer sets (log2(|ga|) in our experiments).\nWe can now compute µ(Λ,Θ′) (i.e., Pr(θ) for each θ ∈\nΘ′) for a set of samples Θ′ obtained by multiple (ideally parallel) calls of sample from the spanning program ρ(Λ) of PrASP program Λ, and subsequently sum up the weights of those samples (possible worlds) where the respective query formula (whose marginal probability we want to compute) is true. Precisely, we approximate Pr(φ) for a (ground or non-ground) query formula φ using:\nPr(φ) ≈ ∑\n{θ′∈Θ′:θ′|=Λφ}\nPr(θ′) (5)\nfor a sufficiently large set Θ′ of samples. Conditional probabilities Pr(a|b) can simply be computed as Pr(a ∧ b)/Pr(b).\nIf sampling is not useful (i.e., if the total number of answer sets Θ is moderate), inference is done in the same way, we just set Θ′ = Θ. Sampling using XOR constraints costs time too (mainly because of repeated calls of the ASP solver), and making this approach more efficient is an important aspect of future work (see Section 6).\nAs an example for inference using our current implementation, consider the following PrASP formalization of a simple coin game: coin(1..3). [0.6] coin_out(1,heads). [[0.5]] coin_out(N,heads) :- coin(N), N != 1. 1{coin_out(N,heads), coin_out(N,tails)}1 :- coin(N). n_win :- coin_out(N,tails), coin(N). win :- not n_win.\nAt this, the line starting with [[0.5]]... is syntactic sugar for a set of weighted rules where variable N is instantiated with all its possible values (i.e., [0.5] coin_out(2,heads) :- coin(2), 2 != 1 and [0.5] coin_out(3,heads) :- coin(3), 3 != 1). It would also be possible to use [0.5] as annotation of this rule, in which case the weight 0.5 would specify the probability of the whole non-ground formula instead. Our prototypical implementation accepts query formulas in format [?] a (computes the marginal probability of a) and [?|b] a (computes the conditional probability Pr(a|b)). E.g., [?] coin_out(1,tails). [?] coin_out(1,heads) | coin_out(1,tails). [?] coin_out(1,heads) & coin_out(2,heads) & coin_out(3,heads). [?] win. [?|coin_out(1,heads) & coin_out(2,heads)\ncoin_out(3,heads)] win.\n...yields the following result [0.3999999999999999] coin_out(1,tails). [1] coin_out(1,heads) | coin_out(1,tails). [0.15] coin_out(1,heads) & coin_out(2,heads) & coin_out(3,heads). [0.15] win. [1|coin_out(1,heads) & coin_out(2,heads)\n& coin_out(3,heads)] win.\nIn this example, use of sampling does not make any difference due to its small size. An example where a difference can be observed is presented in Section 5. This example also\ndemonstrates that FOL and logic programming / ASP syntax can be freely mixed in background knowledge and queries. Another simple example shows the use of FOL-style variables and quantifiers mixed with ASP-style variables:\np(1). p(2). p(3). #domain p(X). [0.5] v(1). [0.5] v(2). [0.5] v(3). [0.1] v(X).\nWith this, the following query:\n[?] v(X). #domain p(Z). [?] ![Z]: v(Z). [?] ?[Z]: v(Z).\n...results in:\n[0.1] ![Z]: v(Z). [0.8499999999999989] ?[Z]: v(Z).\nThe result of query [?] ![Z]: v(Z) with universal quantifier ![Z] is Pr(∀z.v(z)) = 0.1, which is also the result of the equivalent queries [?] v(1) & v(2) & v(3) and [?] v(X). In our example, this marginal probability was directly given as weight in the background knowledge. In contrast to X, variable Z is a variable in the sense of first-order logic (over a finite domain). The result of ?[Z]: v(Z) is Pr(∃z.v(z)) (i.e., ?[Z]: represents the existential quantifier) and could likewise be calculated manually using the inclusion-exclusion principle as Pr(v(1) ∨ v(2) ∨ v(3)) = Pr(v(1)) + Pr(v(2)) + Pr(v(3))−Pr(v(1)∧v(2))−Pr(v(1)∧v(3))−Pr(v(2)∧ v(3)) + Pr(v(1) ∧ v(2) ∧ v(3)) = 0.85. Of course, existential or universal quantifiers can also be used as sub-formulas and in PrASP programs."
    }, {
      "heading" : "An alternative approach: conversion into an equivalent non-probabilistic answer set program",
      "text" : "An alternative approach to probabilistic inference without computing µ and without counting of weighted possible worlds, would be to find an unannotated first-order program Λ′ which reflects the desired probabilistic nondeterminism (choice) of a given PrASP program Λ. Instead of defining probabilities of possible worlds, Λ′ has answers sets whose frequency (number of occurrences within the total set of answer sets) reflects the given probabilities in the original (annotated) program. To make this idea more intuitive, imagine that each possible world corresponds to a room. Instead of encountering a certain room with a certain frequency, we create further rooms which have all, from the viewpoint of the observer, the same look, size and furniture. The number of these rooms reflects the probability of this type of room. E.g., to ensure probability 13 of some literal p, Λ\n′ is created in a way such that p holds in one third of all answer sets of Λ′. This task can be considered as an elaborate variant of the generation of the (much simpler) spanning program ρ(Λ).\nFinding Λ′ could be formulated as an (intractable) rule search problem (plus subsequently the conversion into ASP\nsyntax and a simple unweighted model counting task): find a non-probabilistic program Λ′ such that for each annotated formula [p]f in the original program the following holds (under the provision that the given weights are probabilistically sound):\n|{m : m ∈ Γ(Λ′),m |= f}|\n|Γ(Λ′)| = p. (6)\nUnfortunately, the direct search approach to this would be obviously intractable.\nHowever, in the special case of mutually independent formulas we can omit the rule learning task by conditioning each formula in Λ by a nondeterministic choice amongst the truth conditions of a number of “helper atoms” hi (which will later be ignored when we count the resulting answer sets), in order to “emulate” the respective probability specified by the weight. If (and only if) the formulas are mutually independent, the obtained Λ′ is isomorphic to the original probabilistic program. In detail, conditioning means to replace each formula [w] f by formulas 1{h1, ..., hn}1, f ← h1|...|hm and not f ← not (h1|...|hm), where the hi are new names (the aforementioned “helper atoms”), m n = w and m < n (remember that we allow for weight constraints as well as FOL syntax).\nIn case the transformation accurately reflects the original uncertain program, we could now calculate marginal probabilities simply by determining the percentage of those answer sets in which the respective query formula is true (ignoring any helper atoms introduced in the conversion step), with no need for computing µ(Λ). As an example, consider the following program: coin(1..10). [0.6] coin_out(1,heads). [[0.5]] coin_out(N,heads) :- coin(N), N != 1.\n1{coin_out(N,heads), coin_out(N,tails)}1 :- coin(N). n_win :- coin_out(N,tails), coin(N). win :- not n_win.\nSince coin tosses are mutually independent, we can transform it into the following equivalent un-annotated form (the hpatomn are the “helper atoms”. Rules are written as disjunctions):\ncoin(1..10). 1{hpatom1,hpatom2,hpatom3,hpatom4,hpatom5}1. (coin_out(1,heads)) | -(hpatom1|hpatom2|hpatom3). not (coin_out(1,heads)) | (hpatom1|hpatom2|hpatom3). 1{hpatom6,hpatom7}1. (coin_out(10,heads)) | -(hpatom6). not (coin_out(10,heads)) | (hpatom6). 1{hpatom8,hpatom9}1. (coin_out(9,heads)) | -(hpatom8). not (coin_out(9,heads)) | (hpatom8). 1{hpatom10,hpatom11}1. (coin_out(8,heads)) | -(hpatom10). not (coin_out(8,heads)) | (hpatom10). 1{hpatom12,hpatom13}1. (coin_out(7,heads)) | -(hpatom12).\nnot (coin_out(7,heads)) | (hpatom12). 1{hpatom14,hpatom15}1. (coin_out(6,heads)) | -(hpatom14). not (coin_out(6,heads)) | (hpatom14). 1{hpatom16,hpatom17}1. (coin_out(5,heads)) | -(hpatom16). not (coin_out(5,heads)) | (hpatom16). 1{hpatom18,hpatom19}1. (coin_out(4,heads)) | -(hpatom18). not (coin_out(4,heads)) | (hpatom18). 1{hpatom20,hpatom21}1. (coin_out(3,heads)) | -(hpatom20). not (coin_out(3,heads)) | (hpatom20). 1{hpatom22,hpatom23}1. (coin_out(2,heads)) | -(hpatom22). not (coin_out(2,heads)) | (hpatom22). 1{coin_out(N,heads), coin_out(N,tails)}1\n:- coin(N). n_win :- coin_out(N,tails), coin(N). win :- not n_win.\nExemplary query results: [0.001171875] win. [0.998828125] not win. [0.6] coin_out(1,heads). [0.5] coin_out(2,heads).\nWhat is remarkable here is that no equation solving task (computation of µ(Λ)) is required to compute these results. However, this does not normally lead to improved inference speed, due to the larger amount of time required for the computation of models."
    }, {
      "heading" : "5 Weight Learning",
      "text" : "Generally, the task of parameter learning in probabilistic inductive logic programming is to find probabilistic parameters (weights) of logical formulas which maximize the likelihood given some data (learning examples) (Raedt and Kersting 2008). In our case, the hypothesis H (a set of formulas without weights) is provided by an expert, optionally together with some PrASP program as background knowledge B. The goal is then to discover weights w of the formulas H such that Pr(E|Hw∪B) is maximized given example formulas E = e1, e2, .... Formally, we want to compute argmaxw(Pr(E|Hw ∪B)) = argmaxw( ∏\nei∈E\nPr(ei|Hw ∪B))\n(7)\n(Making the usual i.i.d. assumption regarding the individual examples in E. Hw denotes the hypothesis weighted with weight vector w.)\nThis results in an optimization task which is related but not identical to weight learning for, e.g., MLNs and (Corapi et al. 2011). In MLNs, typically a database (possible world) is given whose likelihood should be maximized, e.g. using a generative approach (Lowd and Domingos 2007) by gradient descent. Another related approach distinguishes a priori between evidence atoms X and query atoms Y and seeks to maximize the likelihood Pr(Y |X), again using gradient descent (Huynh and Mooney 2008). At this, costheavy inference is avoided as far as possible, e.g., by optimization of the pseudo-(log-)likelihood instead ot the (log)likelihood or by approximations of costly counts of true\nformula groundings in a certain possible world (the basic computation in MLN inference). In contrast, the current implementation of PrASP learns weights from any formulas and not just literals (or, more precisely as for MLNs: atoms, where negation is implicit using a closed-world assumption). Furthermore, the maximization targets are different (Pr(possible world) or Pr(Y |X)) vs. Pr(E|Hw ∪B)).\nRegarding the need to reduce inference when learning, PrASP parameter estimation should in principle make no exception, since inference can still be costly even when probabilities are inferred only approximately by use of sampling. However, in our preliminary experiments we found that at least in relatively simple scenarios, there is no need to resort to inference-free approximations such as pseudo-(log)likelihood. The pseudo-(log-)likelihood approach presented in early works on MLNs (Richardson and Domingos 2006) would also require a probabilistic ground formula independence analysis in our case, since in PrASP there is no obvious equivalent to Markov blankets. Note that we assume that the example data is nonprobabilistic and fully observable.\nLet H = {f1, ..., fn} be a given set of formulas and a vector w = (w1, ..., wn) of (unknown) weights of these formulas. Using the Barzilai and Borwein method (Barzilai and Borwein 1988) (a variant of the gradient descent approach with possibly superlinear convergence), we seek to find w such that Pr(E|Hw ∪B) is maximized (Hw denotes the formulas in H with the weights w such that each fi is weighted with wi). Any existing weights of formulas in the background knowledge ar not touched, which can significantly reduce learning complexity if H is comparatively small. Probabilistic or unobservable examples are not considered.\nThe learning algorithm (Barzilai and Borwein 1988) is as follows:\nRepeat for k = 0, 1, ... until convergence: Set sk = 1αk▽(Pr(E|Hwk ∪B)) Set wk+1 = wk + sk Set yk = ▽(Pr(E|Hwk+1 ∪B))− ▽(Pr(E|Hwk ∪B))\nSet αk+1 = sT k yk\nsT k sk\nAt this, the initial gradient ascent step size α0 and the initial weight vectorw0 can be chosen freely.Pr(E|Hw∪B) denotes\n∏ ei∈E\nPr(ei|Hw ∪ B) inferred using vector w as weights for the hypothesis formulas, and\n▽(Pr(E|Hw ∪ B)) = (8)\n( ∂\n∂w1 Pr(E|Hw ∪B), ...,\n∂\n∂wn Pr(E|Hw ∪B)) (9)\nSince we usually cannot practically express Pr(E|Hw ∪ B) in dependency of w in closed form, at a first glance, the above formalization appears to be not very helpful. However, we can still resort to numerical differentiation and ap-\nproximate\n▽(Pr(E|Hw ∪B)) = (10)\n( lim h→0\nPr(E|H(w1+h,...,wn) ∪B)− Pr(E|H(w1,...,wn) ∪B)\nh ,\n(11) ...,\nlim h→0\nPr(E|H(w1,...,wn+h) ∪ B)− Pr(E|H(w1,...,wn) ∪B)\nh )\n(12)\nby computing the above vector (dropping the limit operator) for a sufficiently small h (in our prototypical implementation, h = √ ǫwi is used, where ǫ is an upper bound to the rounding error using the machine’s double-precision floating point arithmetic). This approach has the benefit of allowing in principle for any maximization target (not just E). In particular, any unweighted formulas (unnegated and negated facts as well as rules) can be used as (positive) examples.\nAs a small example both for inference and weight learning using our preliminary implementation, consider the following fragment of a an nonmonotonic indoor localization scenario, which consists of estimating the position of a person, and determining how this person moves a certain number of steps around the environment until a safe position is reached:\n[0.6] moved(1). [0.2] moved(2). point(1..100). 1{atpoint(X):point(X)}1. distance(1) :- moved(1). distance(2) :- moved(2). atpoint(29) | atpoint(30) | atpoint(31)\n| atpoint(32) | atpoint(33) | atpoint(34) | atpoint(35) | atpoint(36) | atpoint(37) -> selected.\nsafe :- selected, not exception. exception :- distance(1).\nThe spanning program of this example has 400 answer sets. Inference of Pr(safe |distance(2)) and Pr(safe |distance(1)) without sampling requires ca. 2250 ms using our current unoptimized prototype implementation. If we increase the number of points to 1000, inference is tractable only by use of sampling (see Section 4). To demonstrate how the probability of a certain hypothesis can be learned in this simple scenario, we remove [0.6] moved(1) from the program above (with 100 points) and turn this formula (without the weight annotation) into a hypothesis. Given example data safe, parameter estimation results in Pr(moved(1)) ≈ 0, learned in ca. 3170 ms using our current prototype implementation."
    }, {
      "heading" : "6 Conclusions",
      "text" : "With this introductory paper, we have presented a novel framework for uncertainty reasoning and parameter estimation based on Answer Set Programming, with support\nfor probabilistically weighted formulas in background knowledge, hypotheses and queries. While our current framework certainly leaves room for future improvements, we believe that we have already pointed out a new venue towards more practicable probabilistic inductive answer set programming with a high degree of expressiveness. Ongoing work is focusing on performance improvements, theoretical analysis (in particular regarding minimum number of samples wrt. inference accuracy), empirical evaluation and on the investigation of viable approaches to PrASP structure learning."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work is supported by the EU FP7 CityPulse Project under grant No. 603095. http://www.ict-citypulse.eu"
    } ],
    "references" : [ {
      "title" : "Probabilistic reasoning with answer sets",
      "author" : [ "Gelfond Baral", "C. Rushton 2009] Baral", "M. Gelfond", "N. Rushton" ],
      "venue" : "Theory Pract. Log. Program",
      "citeRegEx" : "Baral et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Baral et al\\.",
      "year" : 2009
    }, {
      "title" : "J",
      "author" : [ "J. Barzilai", "Borwein" ],
      "venue" : "M.",
      "citeRegEx" : "Barzilai and Borwein 1988",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Probabilistic rule learning in nonmonotonic domains",
      "author" : [ "Corapi" ],
      "venue" : "In Proceedings of the 12th international conference on Computational logic in multi-agent systems,",
      "citeRegEx" : "Corapi,? \\Q2011\\E",
      "shortCiteRegEx" : "Corapi",
      "year" : 2011
    }, {
      "title" : "J",
      "author" : [ "Cussens" ],
      "venue" : "2000. Parameter estimation in stochastic logic programs. In Machine Learning,",
      "citeRegEx" : "Cussens 2000",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Learning probabilistic relational models",
      "author" : [ "Friedman" ],
      "venue" : null,
      "citeRegEx" : "Friedman,? \\Q1999\\E",
      "shortCiteRegEx" : "Friedman",
      "year" : 1999
    }, {
      "title" : "Potassco: The potsdam answer set solving collection",
      "author" : [ "Gebser" ],
      "venue" : "AI Commun",
      "citeRegEx" : "Gebser,? \\Q2011\\E",
      "shortCiteRegEx" : "Gebser",
      "year" : 2011
    }, {
      "title" : "Conflict-driven answer set solving: From theory to practice",
      "author" : [ "Kaufmann Gebser", "M. Schaub 2012] Gebser", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Gebser et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2012
    }, {
      "title" : "and Lifschitz",
      "author" : [ "M. Gelfond" ],
      "venue" : "V.",
      "citeRegEx" : "Gelfond and Lifschitz 1988",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "C",
      "author" : [ "Gomes" ],
      "venue" : "P.; Sabharwal, A.; and Selman, B.",
      "citeRegEx" : "Gomes. Sabharwal. and Selman 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "J",
      "author" : [ "Halpern" ],
      "venue" : "Y.",
      "citeRegEx" : "Halpern 1990",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "L",
      "author" : [ "K. Kersting", "Raedt" ],
      "venue" : "D.",
      "citeRegEx" : "Kersting and Raedt 2000",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "P",
      "author" : [ "K.B. Laskey", "Costa" ],
      "venue" : "C.",
      "citeRegEx" : "Laskey and Costa 2005",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "and Palla",
      "author" : [ "J. Lee" ],
      "venue" : "R.",
      "citeRegEx" : "Lee and Palla 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "and Domingos",
      "author" : [ "D. Lowd" ],
      "venue" : "P.",
      "citeRegEx" : "Lowd and Domingos 2007",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "V",
      "author" : [ "R.T. Ng", "Subrahmanian" ],
      "venue" : "S.",
      "citeRegEx" : "Ng and Subrahmanian 1994",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "N",
      "author" : [ "Nilsson" ],
      "venue" : "J.",
      "citeRegEx" : "Nilsson 1986",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "and Kersting",
      "author" : [ "L.D. Raedt" ],
      "venue" : "K.",
      "citeRegEx" : "Raedt and Kersting 2008",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "L",
      "author" : [ "Raedt" ],
      "venue" : "D.; Kimmig, A.; and Toivonen, H.",
      "citeRegEx" : "Raedt. Kimmig. and Toivonen 2007",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "and Domingos",
      "author" : [ "M. Richardson" ],
      "venue" : "P.",
      "citeRegEx" : "Richardson and Domingos 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "and Pontelli",
      "author" : [ "E. Saad" ],
      "venue" : "E.",
      "citeRegEx" : "Saad and Pontelli 2005",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "H",
      "author" : [ "T. Sang", "P. Beame", "Kautz" ],
      "venue" : "A.",
      "citeRegEx" : "Sang. Beame. and Kautz 2005",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "and Kameya",
      "author" : [ "T. Sato" ],
      "venue" : "Y.",
      "citeRegEx" : "Sato and Kameya 1997",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "and KernIsberner",
      "author" : [ "M. Thimm" ],
      "venue" : "G.",
      "citeRegEx" : "Thimm and Kern.Isberner 2012",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "We propose a new formal language for the expressive representation of probabilistic knowledge based on Answer Set Programming (ASP). It allows for the annotation of first-order formulas as well as ASP rules and facts with probabilities and for learning of such weights from data (parameter estimation). Weighted formulas are given a semantics in terms of soft and hard constraints which determine a probability distribution over answer sets. In contrast to related approaches, we approach inference by optionally utilizing so-called streamlining XOR constraints, in order to reduce the number of computed answer sets. Our approach is prototypically implemented. Examples illustrate the introduced concepts and point at issues and topics for future research.",
    "creator" : "LaTeX with hyperref package"
  }
}