{
  "name" : "1611.08696.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Optimizing Expectation with Guarantees in POMDPs (Technical Report)",
    "authors" : [ "Krishnendu Chatterjee", "Petr Novotný", "Guillermo A. Pérez", "Jean-François Raskin" ],
    "emails" : [ "krishnendu.chatterjee@ist.ac.at,", "pnovotny@ist.ac.at", "jraskin@ulb.ac.be,", "gperezme@ulb.ac.be", "dz277@cam.ac.uk" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The de facto model for decision making under uncertainty are partially-observable Markov decision processes (POMDPs) [Lit96, PT87], and they have been applied in diverse applications ranging from planning [RN10], to reinforcement learning [KLM96], to robotics [KGFP09, KLC98]. One of the classical and fundamental payoff function for POMDPs is the discounted-sum payoff that aggregates the rewards of the transitions as a discounted sum. The traditional objective in POMDPs has been to obtain policies that maximize the expected discounted-sum payoff.\nOne crucial drawback of the traditional objective (that asks for expectation maximization) is that it allows for undesirable events that can happen with low probability. For example, consider a policy σ1 that with probability 1/2 achieves payoff 100 and with probability 1/2 achieves payoff 0, and a different policy σ2 that achieves payoff 20 with probability 1. If payoff values below 10 are undesirable, then the first policy, though better for expected payoff, allows undesirable events with significant probability, and hence the second policy is preferable. Hence, there has been a recent interest to study objectives where, instead of maximizing the expected payoff [HYV16], the goal is to maximize the probability that the payoff is above a threshold.\n∗Author supported by an F.R.S.-FNRS Aspirant fellowship.\nar X\niv :1\n61 1.\n08 69\n6v 1\n[ cs\n.A I]\nA drawback of the approach to maximize the probability that the payoff exceeds a threshold is that it ignores the optimization aspect of maximizing the expectation. In this work we consider an objective for POMDPs where both aspects are present. More precisely, we consider a “guaranteed payoff optimization (GPO)” problem for POMDPs, where given a threshold t, the goal is to maximize the expectation while ensuring that the payoff is at least t.\nAs a concrete motivation for the GPO problem, consider planning under uncertainty (e.g., self-driving cars) where certain events are catastrophic (e.g., crashes), and in the model they are assigned low payoffs. Such catastrophic events must be avoided even at the expense of expected payoff. That is, policies must maximize the expected payoff, ensuring the avoidance of catastrophic events. Hence, for planning in safety-critical applications the GPO problem is natural.\nIn this work, our main contributions are as follows: 1. We study the GPO problem for POMDPs, and present a practical solution approach for the problem.\nIn particular, given a POMDP with the GPO problem, we present a transformation to a different POMDP where it suffices to solve the traditional expectation objective. Our solution approach first constructs a representation of all strategies that satisfies item a) of the GPO problem, and then we extend the partially-observable Monte Carlo planning (POMCP) approach to obtain optimal policies w.r.t. expectation among the above strategies. 2. We present experimental results on several classical POMDP examples from the literature to show how our approach can efficiently solve the GPO problem for POMDPs.\nRelated Works. Works studying POMDPs with discounted sum range from theoretical results (see, e.g., [PT87, Lit96]) to practical tools (e.g. [KHL08, SV10]). Recent works focus on extracting policies which ensure that, with a given probability bound, the obtained discounted-sum payoff is above a threshold (see, e.g., [HYV16]). The problem of ensuring the payoff is above a given threshold while optimizing the expectation has been considered for fully-observable MDPs and the long-run average and stochastic shortest path objectives [BFRR14, RRS15]; and also with probabilistic thresholds for long-run average payoff [CKK15]. As for POMDPs, we mention constrained POMDPs [UH10, PMP+15], where the aim is to maximize the expected payoff while ensuring that the expectation of some other quantity is bounded. In contrast, our constraints are hard, i.e. they must hold always, not just on average. The work probably closest to ours is [STW16] that also considers maximizing expected payoff among all policies satisfying a given constraint, but there are two key differences from our work: they consider finite horizon POMDPs, while we consider infinite horizon ones, and more importantly, their constraints are state-based, i.e. their policy must ensure that the execution of the POMDP does not go through certain “violating” states. In contrast, our “threshold constraint” is execution-based : whether a execution yields payoff at least t cannot be determined solely by looking at the set of states appearing in the execution, but the whole infinite execution has to be considered. This requires very different techniques. To our best knowledge, the GPO problem has never been considered for POMDPs with discounted sum."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "Throughout this work, we follow standard (PO)MDP notations from [Put05, Lit96]."
    }, {
      "heading" : "2.1 POMDPs",
      "text" : "We denote by D(X) the set of all probability distributions on a finite set X, i.e. all functions f ∶ X → [0,1] such that ∑x∈X f(x) = 1. For f ∈ D(X) we denote by Supp(f) the support of f , i.e. the set {x ∈X ∣ f(x) > 0}.\nDefinition 1. POMDPs. A POMDP is defined as a tuple P = (S,A, δ, r,Z,O, λ) where S is a finite set of states, A is a finite alphabet of actions, δ ∶ S ×A → D(S) is a probabilistic transition function that given a state s and an action a ∈ A gives the probability distribution over the successor states, r ∶ S ×A → R is a reward function, Z is a finite set of observations, O ∶ S → D(Z) is a probabilistic observation function that maps every state to a distribution over observations, and λ ∈ D(S) is the initial belief. We abbreviate δ(s, a)(s′) by δ(s′∣s, a),\nRemark 1 (Deterministic observation function). Deterministic observation functions of type O ∶ S → Z are sufficient in POMDPs (see Remark 1 in [CCGK14]). Informally, the probabilistic aspect of the observation function can be encoded into the transition function and, by letting the product of the states and observations be the new state-space, we obtain a deterministic observation function. Thus, without loss of generality, we will always consider observation functions of type O ∶ S → Z, which greatly simplifies the notation.\nPlays & Histories. A play (or an infinite path) in a POMDP is an infinite sequence ρ = s0a0s1a1s2a2 . . . of states and actions such that s0 ∈ Supp(λ) and for all i ≥ 0 we have δ(si, ai)(si+1) > 0. We write Ω for the set of all plays. A finite path (or just path) is a finite prefix of a play ending with a state, i.e. a sequence from (S ⋅A)∗ ⋅ S. A history is a finite sequence of actions and observations h = a0o1 . . . ai−1oi ∈ (A ⋅Z)∗ such that there is a path w = s0a0s1 . . . ai−1si with oj = O(sj) for each 1 ≤ j ≤ i. We write h = H(w) to indicate that history h corresponds to a path w. The length of a path (or history) w, denoted by len(w), is the number of actions in w, and the length of a play ρ is len(ρ) =∞.\nBeliefs. A belief is a distribution on states (i.e. an element of D(S)) indicating the probability of being in each particular state given the current history. The initial belief λ is given as part of the POMDP. Then, in each step, when the history observed so far is h, the current belief is bh, an action a ∈ A is played and an observation z ∈ Z is received, the updated belief bh′ for history h′ = hao can be computed by a standard formula [Cas98].\nInfinite-horizon Discounted Payoff. Given a play ρ = s0a0s1a1s2a2 . . . and a discount factor 0 ≤ γ < 1, the infinite-horizon discounted payoff Discγ of ρ is:\nDiscγ(ρ) = ∑∞i=0 γir(si, ai).\nWe also define a discounted payoff of a finite path w as Discγ(w) = ∑len(w)−1i=0 γir(si, ai).\nPolicies. A policy is a blueprint for selecting actions based on the past history of observations and actions. Formally, it is a function σ which assigns to a history a probability distribution over the actions, i.e. σ(h)(a) is the probability of selecting action a after observing history h (we often abbreviate σ(h)(a) to σ(a ∣ h)).\nConsistent Plays. A play or a path w is consistent with a policy σ if it can be obtained by extending its finite prefixes using σ. Formally, w = s0a0s1a1 . . . is consistent with σ if for each 0 ≤ i ≤ len(w) there is action a such that σ(a ∣H(s0a0 . . . ai−1si)) > 0 and δ(si+1 ∣ si, a) > 0. A history h is consistent with σ if there is a path w consistent with σ such that h =H(w).\nExpected Value eValP of Policies. Given a POMDP P , a policy σ, a discount factor γ, and an initial belief λ, the expected value of σ from λ is the expected value of the infinite-horizon discounted sum under policy σ when starting in a state sampled from λ: eValP (σ) = Eσλ[Discγ]. This definition can be formalized by a standard construction of a probability measure induced by σ over the set of all plays, which also gives rise to the expectation operator Eσλ (see, e.g., [Put05]).\nWorst-Case Value wValP of Policies. The worst-case value of a policy σ from belief λ is wValP (σ) = infρDiscγ(ρ), where the infimum is taken over the set of all plays that are consistent with σ and start in a state sampled from λ.\nExample 1. Figure 1 shows a toy POMDP: A mining robot has to mine ore, which can be of two types (states t1 and t2). The exact type is unknown, but t1 is more likely to occur (initial belief λ). The goal is to reach the “ore mined” (mnd) state, in which a lump-sum reward is received. The robot can use several mining modes: safe mode (action ms), which succeeds with probability 0.6 and does not do anything if it fails, or type-specific mining modes (m1 and m2) which succeed if applied on the correct type but result in a catastrophic failure if used on a wrong type. It can also use a sensor to accurately determine the type (after which a type-specific action can be safely used), at a cost of a one-step delay.\nAn exhaustive analysis of possible policies reveals that the expected value is maximized by any policy σ which selects m1 in the first step (we then have eVal\nP (σ) = 45). However, the worst-case value of such a policy is 0, as it can result in entering fail after the first step. On the other hand, a policy σ′ which plays sense in the first step has eValP (σ) = wValP (σ) = 25.\nMain Computational Questions. The standard POMDP planning problem asks to compute (or approximate) the policy maximizing the expected value. In online POMDP planning, instead of computing the whole policy we have to compute, in each time step, the best action in the current situation. In other words, we must compute a good local approximation of a (near-)optimal policy. [RPPCd08]. In contrast, in the threshold planning problem we are asked to compute a policy maximizing the worst-case value and thus provide strict guarantees on the performance of the system [ZP96]. In this paper, we combine these two approaches and study the guaranteed payoff optimization (GPO) problem, where we are given a POMDP P and a threshold t ∈ R and we have to compute a policy σ such that a) σ satisfies a threshold constraint : wValP (σ) is at least t. b) Let gValP (t) denote the best expected value obtainable while ensuring a worst-case payoff of at least t,\ni.e. gValP (t) ∶= sup{eVal(π) ∣ wValP (π) ≥ t}. Among all policies that satisfy item a), σ has ε-maximal expected value, i.e. eValP (σ) ≥ gValP (t) − ε. To efficiently tackle the GPO problem we aim to compute, in an online fashion, a local approximation of policy σ above. However, we do not relax requirement a). Approximations notwithstanding, the online planning algorithm we seek is such that given t, the discounted payoff of every single play that can be produced by the algorithm is at least t.\nExample 2. Take the POMDP in Figure 1 and a threshold t = 5. As shown in Example 1, a policy σ′ playing sense in the first step satisfies wValP (σ′) ≥ t. However, there are better (w.r.t. the expected value) policies satisfying this constraint. The best such policy is a policy σ′′ which twice plays ms and then plays sense. This policy satisfies eValP (σ′′) = 37 and wValP (σ′′) = 6.25. (Also note that the optimal policy to maximize the expected payoff plays m1 at the very start. However, with non-zero probability, this strategy violates the worst-case threshold t = 5.)"
    }, {
      "heading" : "3 Policies for GPO Problem",
      "text" : "We first show the GPO problem is different from the classical expectation maximization.\nExample 3 (Beliefs are not sufficient for GPO.). It is known that beliefs form a sufficient statistic of history for achieving the optimal expected value, i.e. there is always a deterministic belief-based policy σ — that is, a policy such that for each history h the distribution σ(h) is Dirac and determined solely by the belief after observing h — with optimal expected value [Son71]. However, beliefs are not a sufficient statistic for the GPO problem, as witnessed by Example 2: suppose that we use policy σ′′ and consider\nhistories h = (ms, o,ms, o) and h̄ = (ms, o), where o is the observation received in t1 and t2. The beliefs bh and bh̄ are identical, and yet σ ′′(h) ≠ σ′′(h̄), i.e. σ′′ is not belief-based.\nOverview of Policy Representation. We show (in Corollary 1) that a sufficient statistic for solving the GPO problem is a tuple (bh, remtγ(h)), where bh is the belief after history h and remtγ(h) is the “remaining” distance to the threshold which we need to accumulate in the future. Formally,\nremtγ(h) = (t −min{Discγ(w) ∣H(w) = h}) /γlen(h).\nThis is similar to other (PO)MDP planning problems that work with thresholds [Whi93, HYV16]. However, we prove more: we obtain a precise local characterization of policies that satisfy the threshold constraint. More precisely, we show that for each history h, there is a set of allowed actions Allow tγ(h) such that a policy σ satisfies wValP (σ) ≥ t if and only if for each history h it holds Supp(σ(h)) ⊆ Allow tγ(h). We show that the function Allow tγ can be finitely represented and, for any history h, its value can be computed algorithmically. This permits us to split the solution of the GPO problem into two separate parts: 1.) We compute the function Allow tγ , and 2.) we use it to restrict a standard online planning algorithm so that it always returns an action allowed for the current history.\nAllowed Actions Allow tγ. Intuitively, an action a should be allowed after some history h only if the payoff we are guaranteed to accumulate using a in the current step (i.e. mins∈Supp(bh) r(s, a)) plus the best payoff which we can guarantee from the next step onward is at least remtγ(h). To formalize the “best payoff guaranteed from the next step on” we define the future value of any history h as\nfVal(h) = supσ wValP [bh](σ),\nwhere P [bh] is a POMDP identical to P except for having initial belief bh and the supremum is taken over all policies in P [bh].\nBelief Supports Suffice for the Worst Case. The crucial observation is that the future value of a history h is determined only by the support of bh.\nLemma 1. If histories h,h′ in a POMDP P are such that Supp(bh) = Supp(bh′), then fVal(h) = fVal(h′).\nIntuitively, this is because the worst-case value of a policy (and thus also a future value of a history) does not depend on any transition probabilities. In a slight abuse of notation, we sometimes treat fVal as a function from 2S to R, i.e. fVal(B), for B ⊆ S, is equal to fVal(h) for all histories h such that Supp(bh) = B.\nΨ as an Approximation of fVal . Since computing fVal(B) exactly can be inefficient in practice, we often need to work with approximations of fVal(B), without relaxing the threshold constraint. We thus introduce a notion of a Ψ-allowed action. Let Ψ∶2S → R be a function assigning numbers to belief supports. We say that an action a is Ψ-allowed for t ∈ R after history h, and write it a ∈ Ψ-Allow tγ(h), if for all states s ∈ Supp(bh) and all observations o ∈ Z such that hao is a history it holds that\nr(s, a) + γ ⋅Ψ(Supp(bhao)) ≥ remtγ(h). (1)\nIf Ψ is the function fVal , we write simply a ∈ Allow tγ(h). We typically aim at computing a lower bound on fVal , i.e. a function Ψ such that Ψ(B) ≤ fVal(B) for each B ∈ 2S . Then, as shown below, playing Ψ-allowed actions still guarantees that the threshold t is eventually surpassed.\nCorrectness of the Approximation. The correctness of the definition is summarized in the following proposition. We say that a policy σ is Ψ-safe for t ∈ R if for each history h consistent with σ it holds that Supp(σ(h)) ⊆ Ψ-Allow tγ(h).\nProposition 1. Let Ψ∶2S → R be a function such that Ψ(B) ≤ fVal(B) for each B ∈ 2S. Then any policy σ that is Ψ-safe for t satisfies wValP (σ) ≥ t. Moreover a policy π is fVal-safe for t if and only if wValP (π) ≥ t.\nCorollary 1. Assume that there is a policy σ with wValP (σ) ≥ t. Then there is also a policy π such that wValP (π) ≥ t and eValP (π) = gValP (t), and moreover, π is belief-and-payoff, based, i.e. for all histories h,h′ such that (bh, remtγ(h)) = (bh′ , remtγ(h′)) it holds π(h) = π(h′).\nFrom (1) we see that to compute Allow tγ(h) we have to keep track of remtγ(h) (which can be easily done online) and to compute fVal(Supp(bh)) (or a suitable under-approximation thereof). In the next section we show how to do the latter.\nExample 4. Consider the POMDP from Figure 1 with a threshold t = 6.25. Then fVal({fin}) = fVal({fail}) = 0, fVal({t1, t2}) = 25, fVal({t′1}) = fVal({t′2}) = 50, and fVal({mnd}) = 100. Initially, for the empty history, we have rem6.250.5 (⋅) = 6.25 and therefore the only allowed actions are ms and sense because for all i ∈ {1, 2} we have r(ti,m3−i) + γfVal({fail}) < rem6.250.5 (⋅). Suppose that ms is played and that the next observation witnessed is O(t1) = O(t2) (thus, the belief is the same as before). We have rem6.250.5 (msO(t1)) = 12.5. In this case, the only allowed action is sense because for all i ∈ {1,2} r(ti,ms) + γfVal({t1, t2}) < rem6.250.5 (msO(t1)) and m1 and m2 are still not allowed (since we have not accumulated any payoff and have the same belief as before). Hence, sense is played and consequently we obtain a payoff of 25 (because of discounting). We remark that 25 is, as required, above the threshold t = 6.25."
    }, {
      "heading" : "4 Computing Future Values",
      "text" : "The threshold constraint in the GPO problem is global, i.e. it talks about all runs compatible with a policy. Hence, solving the GPO problem is unlikely to be amenable to purely online methods, which compute only local approximations of policies. In this section we show how to compute future values in an offline pre-processing step. Although this requires a global analysis of a POMDP, the pre-processing step can be done efficiently since computation of future values only requires working with belief supports rather than beliefs.\nBelief Supports & Valid Belief Supports VBelSup. A belief support B ⊆ 2S is valid if either B = Supp(λ) or there is a history h such that B = Supp(bh). Only valid supports can be encountered during the planning process and thus we only need to compute future values thereof. We denote by VBelSup(P ) the set of valid belief supports of POMDP P ; the set can be computed by a simple iterative procedure.\nObsevable Rewards. We present efficient computation of future values under the assumption that rewards are observable. This holds for many real-world applications, see, e.g. examples in [HYV16, CCGK15]. Formally, POMDP P has observable rewards if r(s, a) = r(s′, a) whenever O(s) = O(s′). From a theoretical point of view, observability of rewards is necessary since without it, the computation of future values is at least as hard as solving a long-standing open problem in algebraic number theory. More precisely, if the rewards of a given POMDP are not observable, the computation of future values is at least as hard as solving the target discounted sum problem, a long-standing open problem in automata theory related to other open problems in algebra [BHO15]. However, for POMDPs with unobservable rewards we can at least obtain an under-approximation Ψ of fVal , and hence our framework is also applicable to them.\nLemma 2. If rewards in P are observable, then for each B ∈ VBelSup(P ) and each s, s′ ∈ B,a ∈ A it holds r(s, a) = r(s′, a).\nWe thus define r(B,a) as r(s, a) for some s ∈ B.\nFuture Value Characterization. We start by providing a characterization of future values. A successor of a belief support B under action a and observation o is a belief support ∆(B,a, o) = o ∩ ⋃s∈B Supp(δ(s, a)). Consider the following system of max-min equations with variables xB, B ∈ VBelSup(P ):\nxB = max a∈A min o∈Z\n∆(B,a,o)≠∅\nr(B,a) + γ ⋅ x∆(B,a,o). (2)\n(Each B ∈ VBelSup(P ) appears on the LHS of exactly one equation in the system.)\nProposition 2. The system (2) has a unique solution {x̃B}B∈VBelSup(P ), and it satisfies x̃B = fVal(B).\nGame Perspective for the Worst Case. Hence, it suffices to find a solution to system (2). But the form of the system is identical to the one characterizing optimal values in 2-player zero-sum discounted games [ZP96]. These games can be imagined as fully-observable MDPs in which the outcomes of actions are not resolved by a random choice but by a malicious adversary. The system (2) per se corresponds to a game where elements of VBelSup(P ) are the states, actions are the same as in P , and possible effects of actions are given by the function ∆.\nAlgorithms to Compute Future Values. Hence, to compute future values in practice we can employ one of several efficient algorithms for solving discounted-sum games (e.g. [Bre16]). A simple yet efficient approach is to use the standard value iteration for games: we compute a sequence f (0)f (1)f (2) . . . of functions of type VBelSup(P )→ R such that f (0)(B) = 0 for each B, and for i ≥ 1 we inductively define\nf (i)(B) = max a∈A min o∈Z\n∆(B,a,o)≠∅\nr(B,a) + γ ⋅ f (i−1)(∆(B,a, o)).\nFrom [ZP96] it follows there is always j such that for all B ∈ VBelSup(P ) we have f j(B) = f j−1(B), i.e. f j(B) is the solution to (2), and moreover j ≤ 3 + log2(max(s,a)∈S×A ∣r(s, a)∣) + 12 ⋅ (∣S∣ + 3) 2 ⋅ log2(den(γ)) 1−γ , where den(γ) is a denominator of γ in its reduced form. Hence, the value iteration converges in at most exponentially many steps.1\nTheorem 1. Future values of all valid belief supports in P can be computed in time exponential in the size of P .\nAlthough the theoretical bound is exponential, there are several reasons for the method to work well in practice: (1.) In a concrete instance, the number of valid supports can be significantly smaller than exponential. (2.) Reaching the fixed-point of the value iteration may also require significantly smaller number of steps than the theoretical upper bound suggests. (3.) One can show that for each i ≥ 0, f (i) ≤ fVal . Hence, even if reaching the fixed point takes too much time, we can set up a suitable timeout after which the value iteration is stopped, say at iteration i. Then, by Proposition 1 any policy that is f (i)-safe for t has worst-case value ≥ t. (4.) Value iteration is a simple and standard algorithm for which efficient implementations exist (see, e.g., [LDK95, SV05]).\nImportant note on Ψ: generally, Ψ ≤ fVal does not guarantee that a Ψ-safe policy exists, which is necessary to apply Proposition 1. The following lemma resolves this.\nLemma 3. For any i ≥ 0 the following holds for the functions f (i) produced by game value iteration: if f (i)(Supp(λ)) ≥ t, then there exists a policy σ which is f (i)-safe for t.\nIn particular, if fVal(Supp(λ)) ≥ t then a fVal -safe policy for t exists, irrespective of the way in which fVal is computed."
    }, {
      "heading" : "5 Solving the GPO problem",
      "text" : "We solve the GPO problem by modifying the partially-observable Monte Carlo planning (POMCP) algorithm [SV10].\nPOMCP. POMCP is an online planning method which in each decision epoch aims to select the best action given the current history h. In each epoch, POMCP performs a number of finite-horizon simulations starting from belief bh in order to compute a local approximation of the optimal expected value function: each simulation extends history h by selecting actions according to certain rules until the horizon is reached. The payoff of the produced path is then evaluated, and the result is used to update the optimal value approximation. After all the simulations proceed, the best action according to the estimated values is played, a new observation is received, and the process continues as above.\n1Since the number 1 1−γ can be exponential in the bitsize of γ.\nPOMCP data-structure. POMCP stores the information gained in past simulations in a search tree, in which each node corresponds to some history h′ and contains belief bh′ , the number Nh′ of times the history has been observed in previous simulations, and an approximation of the optimal expected value from bh′ . The search tree is used to guide simulations: each step in which the current history corresponds to an internal node of the tree is treated as a multi-armed bandit with parameters determined by numbers stored in children of this node, which balances exploration of new branches and exploitation of previous simulations (akin to the UCT algorithm for MDPs [KS06]). Once the simulation runs out of the scope of the search tree, it enters a rollout phase, where a fixed policy (e.g. selecting actions at random) is used to extend paths.\nG-POMCP: Adapting POMCP for GPO. We propose an augmentation of POMCP, which we call G-POMCP (guaranteed POMCP), specified as follows: First we enrich the nodes of the search tree so that a node corresponding to a history h additionally includes the set Bh = Supp(bh) and the number Rh = remγt (h). When adding a new node to a search tree by extending history h with action a and observation o, these attributes for the new node are updated as follows: Bhao = ∆(Bh, a, o) and Rhao = (remγt (h) − r(Bh, a))/γ. Note that updating Bh to Bhao requires just discrete set operations; as a matter of fact, the function ∆ is computed already during the off-line computation of future values, after which it can be stored and used to efficiently update Bh during G-POMCP execution. In particular, updating Bh is independent of updating bh, which is important so as not to compromise the threshold constraints with issues of belief precision and particle deprivation.\nG-POMCP: playing safe. The execution of G-POMCP then proceeds in almost the same way as in POMCP, with a crucial exception: Whenever G-POMCP is to select a (real or simulated) action it selects only among those in Allow tγ(h), where h is the current history. Note that checking whether an action is allowed is easy for histories within the search tree, since the necessary information (Bh and Rh) is stored in nodes of the tree. Out of the scope of the search tree, we need to update the current belief support and remaining payoff online, as the simulation proceeds. While this somewhat increases the complexity of rollouts, as current belief supports must be kept updated (POMCP only keeps track of the current state and of payoff won so far), as noted above, updating belief supports is easier than updating beliefs. Moreover, this increase in complexity is only an issue in the initial steps of the algorithm, where rollout steps dominate over tree traversal. Previous sections yield the following result:\nTheorem 2. For each threshold t ≤ fVal(Supp(λ)) the following holds: for each play ρ = s0a0s1a1 . . . resulting from using G-POMCP on P ad infinitum it holds Discγ(ρ) ≥ t. This holds independently of how precisely the algorithm approximates beliefs.\nSo unless it is impossible to satisfy the threshold constraint at all, it can be surely satisfied by using G-POMCP.\nConvergence. Another question is the one of convergence. An algorithm is said to be convergent in the limit if, assuming precise belief representation, the local approximation of optimal value converges to true optimal value (in our case to gValP (t)) as the number of simulations and their depth increases. The limit convergence of G-POMCP can be proved by a straightforward adaptation of the limit convergence proof of POMCP [SV10]: we map executions of G-POMCP on POMDP P to the executions of UCT on a tree-shaped MDP P ′, whose states are histories of P (with the empty history as root) and where finite paths correspond to extending histories in P by playing allowed actions."
    }, {
      "heading" : "6 Experiments",
      "text" : "We tested our algorithm on two classical sets of benchmarks. The first, Hallway, was introduced in [LCK95]. In a hallway POMDP, a robot navigates a gridworld with walls and traps. We have considered variants in which traps cause non-recoverable damage and another in which they just “spin” the robot — making him more uncertain about his current location in the grid. Additionally, we have run our algorithm on RockSample POMDPs. The latter corresponds to the classical scenario described first in [SS04]. (We use a slight adaptation with a single imprecise sensing action.) Our experimental results are summarized in Figure 2 and Table 1.\nTest Environment Specifications: (1.) CPU: 6-Core Intel Zeon, 3.33 GHz, 6 cores; (2.) Memory: 256 KB of L2 Cache, 12 MB of L3 Cache, 32 GB; (3.) OS: Mac OS X 10.7.5.\nWorst-Case vs. Expected Payoff. In Figure 2 we have plotted the results of running our G-POMCP algorithm on several benchmarks. In all three graphics, the trade-off between worst-case guarantees and expected payoff is clearly visible: In the left figure, the expected payoff stays around 15.7 for worst-case thresholds between 0 and 6; then drops to 11.3 for threshold values above 6.5. In the center figure, the expected payoff is ∼44.7 when the worst-case threshold is 0; stays around 36 for thresholds between 1 and 12 (with a slightly negative slope); then drops to 25 for threshold values above 12.5. Finally, in the right figure, the expected payoff steadily decreases for increasing worst-case threshold values. In particular, for threshold 0 the expected payoff is ∼7137 while for threshold 5150 it is ∼6161.\nLatency. In Table 1 we show the latency — the amount of time it takes to determine, at each epoch, which action to play next — of G-POMCP on three of the benchmarks we considered. (Though we have run the tool on several others, these are the biggest.) Observe that, even for relatively big POMDPs, the average latency is in the order of seconds. Also, note that the pre-processing step is not too costly.\nTool Availability. Our implementation of the G-POMCP algorithm can be fetched from https://github.com/gaperez64/GPOMCP."
    }, {
      "heading" : "7 Discussion",
      "text" : "In this work we have given a practical solution for the GPO problem. Our algorithm, G-POMCP, allows to obtain a policy which ensures a worst-case discounted-sum payoff value while optimizing the expected payoff. We have implemented G-POMCP and evaluated its performance on classical families of benchmarks. Our experiments show that our approach is efficient despite the exact GPO problem being fundamentally more complicated."
    }, {
      "heading" : "Acknowledgements",
      "text" : "The research leading to these results was supported by the Austrian Science Fund (FWF) NFN Grant no. S11407-N23 (RiSE/SHiNE); two ERC Starting grants (279307: Graph Games, 279499: inVEST); the Vienna Science and Technology Fund (WWTF) through project ICT15-003; and the People Programme (Marie Curie Actions) of the European Union’s Seventh Framework Programme (FP7/2007-2013) under REA grant agreement no. [291734]."
    }, {
      "heading" : "A Examples of Section 2",
      "text" : "Here is presented a detailed analysis of all possible policies, and the best policy in terms of optimized expected payoff. Firstly observe that a policy is uniquely determined if the first performed action is in the set {m1 ,m2 , sense}. The remaining case is to perform action ms n times for some n ∈ N (if we successfully make transition to mnd before performing all n actions ms , policy is still uniquely determined), and then perform some action in the set {m1 ,m2 , sense}. Alternatively, it is possible to just perform ms until mnd is successfully reached. Below are computed expected payoffs for each of the cases listed above.\n• σ1: m1 performed first\neValP (σ1) = 0.9 ⋅ [1 ⋅ 0 + γ ⋅ 100] = 45.\n• σ2: m2 performed first\neValP (σ2) = 0.1 ⋅ [1 ⋅ 0 + γ ⋅ 100] = 5.\n• σsense : sense performed first\neValP (σsense) = 0 + γ ⋅ 0 + γ2 ⋅ 100 = 25.\n• σms : ms performed until transition to mnd is successful\neValP (σms) = ∞ ∑ k=0 (2 5 )k ⋅ 3 5 ⋅ γk+1 ⋅ 100 = 37.5.\n• σn1 : ms performed n times, then m1\neValP (σn1 ) = n−1 ∑ k=0 (2 5 )k ⋅ 3 5 ⋅ γk+1 ⋅ 100\n+ (2 5 )n ⋅ [0.9 ⋅ γn+1 ⋅ 100 + 0.1 ⋅ 0] = 37.5 + 7.5 5n .\n• σn2 : ms performed n times, then m2\neValP (σn2 ) = n−1 ∑ k=0 (2 5 )k ⋅ 3 5 ⋅ γk+1 ⋅ 100\n+ (2 5 )n ⋅ [0.1 ⋅ γn+1 ⋅ 100 + 0.9 ⋅ 0] = 37.5 − 32.5 5n .\n• σnsense : ms performed n times, then msense\neValP (σnsense) = n−1 ∑ k=0 (2 5 )k ⋅ 3 5 ⋅ γk+1 ⋅ 100\n+ (2 5 )n ⋅ γn+2 ⋅ 100 = 37.5 − 12.5 5n .\nIt is hence clear that in Example 1 the expected payoff is optimized for σ = σ1. In Example 2 though, if we introduce a threshold t = 5, this policy does not work as if the initial state is t2, payoff is 0. Looking above at possible policies, σ1, σ2, σ n 1 and σ n 2 do not satisfy the imposed worst-case condition as we may have payoff 0. If ms returns us to the initial state for at least three times, total payoff is at most 100/25 = 3.125 < 5, so σms and σnsense also do not satisfy the condition for n ≥ 3. Hence, policies satisfying the worst case condition are σsense and σ n sense for n ∈ {1, 2}. It is easily verified from above that σ′′ = σ2sense optimizes expected payoff with eValP (σ2sense) = 37, and the worst case is achieved if both ms fail with wValP (σ2sense) = 6.25."
    }, {
      "heading" : "B On the assumption of observable rewards (Section 4)",
      "text" : "If the rewards of a given POMDP are not observable, the computation of future values is at least as hard as solving the target discounted sum problem, a long-standing open problem in automata theory related to other open problems in algebra [BHO15].\nUnder-approximation of fVal . For POMDPs with non-observable rewards, there is a straightforward way of obtaining an under-approximation Ψ of fVal . Following the value iteration algorithm for discountedsum games outlined in Section 4 and detailed in [HM15], it is possible to obtain the exact future values. Furthermore, it is easy to see that the functions f (i) generated by the algorithm get ever closer to the actual future values. Hence, stopping the iteration at any i ≥ 0 yields the desired under-approximation. (Note that for this argument to be valid, the reward function must assign to every transition a non-negative value. However, this assumption is no loss of generality since, for any given POMDP, the threshold and the rewards of all the transitions can be “shifted and scaled” so that the assumption holds.)"
    }, {
      "heading" : "C Formal Proof of Lemma 1 and Theorem 1",
      "text" : "In this section we argue that, for POMDPs with observable rewards, we can reduce the computation of a policy with worst-case value above a given threshold to the computation of a policy, with the same property, in a full-observation discounted-sum game. This will give us access to the theoretical tools developed for that kind of game by the formal verification community. The idea is simple: we will construct a weighted arena in which states correspond to subsets of states from the POMDP with the same observation, and the new transitions model transitions with non-zero probability in the POMDP. This subset construction captures the fact that in a POMDP, after any history, any one from a set of possible states with the same observation could be the actual state of the system. The assumption that the POMDP has observable rewards will then allow us to weight the transitions of the arena without losing information about the original POMDP.\nWe observe that this reduction, and the fact that the policy we are looking for in the original POMDP can be directly obtained from the constructed discounted-sum game, imply that the probabilities of the POMDP do not really matter when considering the worst-case value. Thus, Lemma 1 follows.\nGiven a POMDP P = (S,A, δ, r,Z,O, λ) with observable rewards, we construct the weighted arena ΓP = (Q, I,A,∆,w) where:\n• Q = {T ⊆ S ∣ T ≠ ∅ and O(s) = O(s′) for all s, s′ ∈ T} is a finite set of states;\n• I = {q ∈ Q ∣ Supp(λ) ∩ q = q} is the set of initial states;\n• ∆ ⊆ Q×A×Q includes transitions of the form (q, a, q′) if q, q′ ∈ Q and ⋃s∈q Supp(δ(s, a))∩O(s′) = q′ for any s′ ∈ q′;\n• w is a weight function of the form ∆→ R determined by r as follows: w(q, a, q′) = r(s, a) for any s ∈ q.\nA play or infinite path in a weighted arena is a sequence π = q0a0 . . .) of states and actions s.t. q0 ∈ I and for all i ≥ 0 we have qiaiqi+1 ∈ ∆. We denote by Π the set of all plays. A (finite) path is a finite prefix of a play ending in a state. Since the game has full observation, a history in a weighted arena is simply a path. The discounted sum of a play is defined as for POMDPs but using the weight function w instead of r. The definitions for policy and worst-case value are then identical. (For clarity, we write wVal ′ instead of wVal when referring to the worst-case value in ΓP .)\nFrom histories of the POMDP to histories in the game. We now define a mapping µ from observation-action sequences to state-action sequences in the constructed weighted arena. For a history h = a0o0 . . . from P we let µ(h) = q0a0 . . . where q0 = Supp(λ) and for all i ≥ 0 we have qi+1 = ⋃s∈qi Supp(δ(s, a)) ∩ oi+1.\nClaim 1. The function µ is a bijective function from histories in P to paths in ΓP .\nProof. Clearly µ is injective. We will argue that it is also bijective. Consider a path π = q0a0 . . . qn from ΓP . We have that µ\n−1(π) = a0 . . . on where oi = O(si) for any si ∈ qi and for all 0 < i ≤ n. It remains to show that there is a path ρ = s0a0 . . . sn in P s.t. H(ρ) = µ−1(π), to conclude that µ−1(π) is a valid history in P . By construction of ΓP we have that, for all 0 < i ≤ n, for all states s′ ∈ qi there is s ∈ qi−1 s.t. δ(s′∣s, a) > 0. The result follows by induction.\nIt follows that there are bijective mappings from policies in P to policies in ΓP , and from plays in P to plays in ΓP . For a policy σ in P , let us denote by µ(σ) the corresponding policy in ΓP ; for a play ρ in P , µ(ρ) for the play in ΓP .\nLemma 4. For any policy σ in P and for any policy σ′ in ΓP , if µ(σ) = σ′ then wVal(σ) = wVal ′(σ′).\nProof. First, note that since P has observable rewards, then for all histories h = a0 . . . on we have that for any two paths ρ = s0a0 . . . sn, ρ′ = s′0a0 . . . s′n s.t. H(ρ) =H(ρ′) = h the following holds:\nn−1 ∑ i=0 γir(si, ai) = n−1 ∑ i=0 γir(s′i, ai).\nFurthermore, by construction of ΓP we also have that\nn−1 ∑ i=0 γiw(qi, ai, qi+1) = n−1 ∑ i=0 γir(si, ai).\nThus, for the result to follow, it suffices for us to show that for any policy σ in P and corresponding σ′ in ΓP , if µ(σ) = σ′ then µ is also bijective when restricted to plays consistent with σ and σ′ in the respective structures. We proceed by induction. Note that for any history h in P with only one observation and consistent with σ we have that µ(h) is consistent with σ′ = µ(σ) since no choice has been made by the policies. Conversely, for any path π in ΓP with only one element, and consistent with σ\n′, µ−1(π) is consistent with σ = µ−1(π) for the same reason. Hence, for some `, µ is a bijective function from histories in P to paths in ΓP , all of length at most `. Consider a history h = a0 . . . a`−1o` in P consistent with σ and let us write µ(h) = q0 . . . q`. By induction hypothesis, we know µ(a0 . . . o`−1) = q0 . . . q`−1 = π is consistent with σ′. Observe that:\n• σ′(π) = σ(µ−1(π)) = σ(a0 . . . o`−1) and therefore a` ∈ Supp(σ′(π)) since h is consistent with σ;\n• by definition of a history, there is some path χ = s0a0 . . . s`−1a`−1s`) in P with H(χ) = h; and\n• by construction of ΓP and definition of µ we have that s`−1 ∈ q`−1 and (q`−1, a`−1, q`) ∈ ∆.\nIt follows that µ(h) is also consistent with σ′. To show the other direction, we now take a path π = q0a0 . . . a`−1q` in ΓP consistent with σ′ and write µ−1(π) = . . . o`. It follows from inductive hypothesis that µ−1(q0 . . . q`−1) = . . . o`−1 = h is consistent with σ. Since σ(h) = σ′(µ−1(h)), we have that Supp(σ(h)) ∋ a`−1. Also, for any s ∈ q` we have o` = O(s). Hence the claim holds and the result follows by induction.\nIt follows from the above arguments that computing the worst-case value can be done in exponential time for POMDPs with discounted sum and observable rewards. This is, in fact, a tight complexity result. Indeed, safety and reachability games with partial observation are EXP-hard [CD10] even if the objective is observable. One can easily reduce either of them to a discounted-sum objective in a POMDP by placing rewards or costs on target (or unsafe) transitions (depending of the game we reduce from) and asking for non-negative worst-case value. Therefore, deciding a threshold problem for the worst-case value in POMDPs with discounted sum is EXP-complete.\nTheorem 3. The worst-case threshold problem for POMDPs with discounted sum and observable rewards is EXP-complete."
    }, {
      "heading" : "D Formal Proof of Proposition 1",
      "text" : "Assume we are given a POMDP P = (S,A, δ, r,Z,O, λ) with observable rewards and we have constructed the corresponding weighted arena ΓP = (Q, I,A,∆,w).\nRecall the statement says: Let Ψ∶2S → R be a function s.t. Ψ(B) ≤ fVal(B) for each B ∈ 2S .\n(i) Then any policy σ that is Ψ-safe for t satisfies wValP (σ) ≥ t.\n(ii) Moreover a policy π is fVal -safe for t if and only if wValP (π) ≥ t.\nItem (i) can easily be shown to hold by induction on the definition of a strategy being Ψ-safe. For Item (ii) we refer the reader to [BMR14], in which the authors show that, in discounted-sum games, playing fVal -safe for t is sufficient and necessary to obtain at least t. The result then follows from the reduction from worst-case value in POMDPs with discounted sum to discounted-sum games."
    }, {
      "heading" : "E Open Theoretical Problems",
      "text" : "The worst-case planning problem is open for general POMDPs. A lower bound for the computational complexity of that problem would entail a lower bound for universality of discounted sum automata, which is open [CDH10]. In the other direction, an upper bound (that is, an algorithm or any kind of decidability result) would translate into an upper bound for the target discounted sum problem [BHO15]. The latter was shown to be more general than some important open problems in mathematics and computer science.\nThe exact GPO problem (i.e., not the -approximation we achieve in this work) is also open, even for fully-observable MDPs. Remark that if the worst-case value threshold given is in fact the future value of the initial state, then we could construct a sub-graph of choices which satisfy the equation from system (2) and be sure that it is a complete representation of the set of all policies achieving the optimal worst-case value. Hence, we could optimize the expected value in that graph only and solve the GPO problem. If the worst-case threshold is strictly lower, then this idea does not work. Indeed, sub-optimal early choices might force later turns in the game to be played optimally and vice versa as well."
    } ],
    "references" : [ {
      "title" : "pages 750–761",
      "author" : [ "U. Boker", "T.A. Henzinger", "J. Otop. The Target Discounted-Sum Problem. In LICS" ],
      "venue" : "July",
      "citeRegEx" : "BHO15",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "In CSL-LICS",
      "author" : [ "Véronique Bruyère", "Noémie Meunier", "Jean-François Raskin. Secure equilibria in weighted games" ],
      "venue" : "pages 26:1–26:26,",
      "citeRegEx" : "BMR14",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "pages 1–14",
      "author" : [ "Krishnendu Chatterjee", "Laurent Doyen. The complexity of partial-observation parity games. In LPAR" ],
      "venue" : "Springer,",
      "citeRegEx" : "CD10",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "ACM Transactions on Computational Logic",
      "author" : [ "Krishnendu Chatterjee", "Laurent Doyen", "Thomas A. Henzinger. Quantitative languages" ],
      "venue" : "11(4),",
      "citeRegEx" : "CDH10",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Technical note",
      "author" : [ "Axel Haddad", "Benjamin Monmege. Why Value Iteration Runs in Pseudo-Polynomial Time for Discounted-Payoff Games" ],
      "venue" : "Université libre de Bruxelles,",
      "citeRegEx" : "HM15",
      "shortCiteRegEx" : null,
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "More precisely, if the rewards of a given POMDP are not observable, the computation of future values is at least as hard as solving the target discounted sum problem, a long-standing open problem in automata theory related to other open problems in algebra [BHO15].",
      "startOffset" : 257,
      "endOffset" : 264
    } ],
    "year" : 2017,
    "abstractText" : "A standard objective in partially-observable Markov decision processes (POMDPs) is to find a policy that maximizes the expected discounted-sum payoff. However, such policies may still permit unlikely but highly undesirable outcomes, which is problematic especially in safety-critical applications. Recently, there has been a surge of interest in POMDPs where the goal is to maximize the probability to ensure that the payoff is at least a given threshold, but these approaches do not consider any optimization beyond satisfying this threshold constraint. In this work we go beyond both the “expectation” and “threshold” approaches and consider a “guaranteed payoff optimization (GPO)” problem for POMDPs, where we are given a threshold t and the objective is to find a policy σ such that a) each possible outcome of σ yields a discounted-sum payoff of at least t, and b) the expected discounted-sum payoff of σ is optimal (or near-optimal) among all policies satisfying a). We present a practical approach to tackle the GPO problem and evaluate it on standard POMDP benchmarks.",
    "creator" : "TeX"
  }
}