{
  "name" : "1705.03392.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 5.\n03 39\n2v 2\n[ cs\n.A I]\n1 3\nM ay\n2 01\n7\nAsynchronous Announcements\nHans van Ditmarsch, LORIA – CNRS / University of Lorraine\nMay 16, 2017"
    }, {
      "heading" : "1 Introduction",
      "text" : "Public announcement logic [7] is a well-known modal logic to model change of information. Given a group A of agents that is uncertain about a set of propositional variables P , including higher-order uncertainty (agent a does not know p but considers it possible that agent b knows p), they are simultaneously informed by an outsider of new information. The assumption is that the information is true (reliable) and that it is common knowledge among the agents that all agents receive the information.\nWe consider a version of truthful public announcement logic where announcements are still truthful and (in some sense) public, but where they may not be received instantly by the agents. Let us illustrate this by an example. Consider two agents Anne (a) and Bill (b), and two propositional variables p and q. Anne knows the truth about p and Bill knows the truth about q, and this is common knowledge between them. In fact, p and q are both true. A truthful public announcement of p∨q is now made. The model encoding the uncertainty of Anne and Bill and the model transition resulting from the announcement are as follows— we represent Anne’s uncertainty by a-labelled links (representing indistinguishable states) and Bill’s uncertainty by b-labelled links; the actual state is framed. States have been given mnemonic names reflecting the valuation of atoms in that state, e.g., pq is the state where p is false and q is true.\npq\npq\npq\npq\nb\nb\na\na\np∨q ⇒\npq\npq\npqb\na\nAfter the announcement of p ∨ q, Bill does not know that p is true but Anne considers it possible that he knows, [p ∨ q](¬Kbp ∧ K̂aKbp), where [p ∨ q] is a dynamic modality standing for ‘after the announcement of p ∨ q, it holds that’, Kb is a static (epistemic)\nmodality standing for ‘Bill knows that’, and K̂a is the diamond version of such an epistemic modality.\nA different way to view the model transformation induced by the public announcement is as an internal step in a larger model, known as the protocol-generated forest [8, 9]. (For announcements, that are functional, it is a bamboo forest, but this does not matter.) Such are also known as history-based structures [6], as we do not discard the state of information before the announcement/message. This forest is the perspective we need to continue our story. It can be visualized as follows — a dotted, directed, link transforms a state preserved in the transition. (We could also have labelled these with the announcement.)\npq\npq\npq\npq\nb\nb\na\na\np∨q ⇒\npq\npq\npq\npq\nb\nb\na\na pq\npq\npq b\na\nIn [5], Panangaden and Taylor presented a system wherein agents/processes can receive messages at different times, in order to model asynchronous communication. All messages will be received eventually by all agents, but it is not known when. This implies that when an agent receives a message, she does not know when other agents have received that message. We may then make further assumptions, such that the messages will be received by each agent in the order in which they are sent. But these assumptions may also be relaxed. Panangaden and Taylor investigate what knowledge agents can eventually obtain under such asynchronous and concurrent conditions.\nFor events such as public announcements we can also assume that they are not necessarily received by all agents at the same time, but that they are still broadcast to all agents. This leads to novel forms of uncertainty. For example, Anne may have received the information p ∨ q but Bill may not yet have received it. (Other observations than hearing speech seem now more intuitive to describe events. Anne having already heard it but Bill not yet, when both are being spoken to, does not seem to make much sense.)\nWe can refine our visualization to express this. Below, the announcement of p ∨ q now only means that this information is broadcast to Anne and Bill. Anne and Bill have not received it yet. Therefore, the designated point of the structure does not yet move along (as above). Anne receiving that information is a separate event, as is Bill receiving that information. Below we visualize that Anne received this information. This is the action +a. We indicate this visually by Anne’s perspective, the a-labelled frame, moving along. Bill’s perspective, the b-labelled frame, remains the same.\npq\npq\npq\npq ab\nb\nb\na\na\np∨q ⇒\n(novel)\npq\npq\npq\npq ab\nb\nb\na\na pq\npq\npq b\na\n+a ⇒\npq\npq\npq\npq b\nb\nb\na\na pq\npq\npq a\nb\na\nIn the right-hand structure:\n1. Anne considers it possible that Bill now knows that p is true — namely if the actual state is pq and if the announcement has been received by Bill;\n2. Anne also considers it possible that Bill does not know that p is true — namely if the actual state is pq and if the announcement has been received by Bill;\n3. Anne also considers it possible for another reason that Bill does not know that p is true — namely if the actual state is pq but the announcement has not been received by Bill.\nAnne’s uncertainty in cases 2. and 3. is of a different nature. The first corresponds to her inability to distinguish two state descriptions at the same time, the second corresponds to her inability to distinguish the same state description at different moments in time. Instead of the usual notion of knowledge, we need to define a notion of asynchronous knowledge.\nA further +b action would lead to Anne and Bill both knowing that p ∨ q. However, unlike in public announcement logic, they do not know that the other knows: there is no common knowledge between them of p ∨ q. Our framework is then more alike [5] (we will discuss this later).\nIf messages need not be received simultaneously, Anne also considers it possible that Bill has received more announcements than herself. This is problematic, as Anne does not yet know what these announcements will be. If Anne and Bill are executing a commonly known protocol, such uncertainty over the future is bounded, but otherwise, it amounts to quantifying over all future announcements (any further modally definable restrictions of the current model and that contain the actual state). Such scenarios are considered in arbitrary public announcement logic [1], although, there, not with asynchronicity in mind. If we allow reasoning over future announcements a very weak notion of knowledge would result: agents then cannot know that other agents are ignorant (unless this ignorance was initially distributed knowledge). In this work we assume that agents only speculate over the past. Differently said, we do not consider epistemic planning (and the agents have no goals for their reasoning anyway), but only learning from all the available information received so far, including uncertainty over when others receive the same information.\nWe make the following modelling assumptions towards formalizing asynchronous knowledge resulting from announcements:\n• The agents have common knowledge of the initial uncertainty\n• Messages (announcements) are received by the agents in the order in which they are sent.\n• Agents receive announcements independently from one another.\n• Whether an agent receives an announcement does not depend on the state (therefore agents know if they have received announcements).\n• Agents reason about the past, not about the future.\nBefore we plunge into the syntax and semantics, let us point out two salient features of asynchronous announcements and asynchronous knowledge: (i) announcements may result in partial synchronization, and (ii) knowledge is no longer truthful. For the first, consider a slightly different scenario wherein the first announcement is p and wherein the second announcement is Kbp (overlooking the, so far, absent definition of asynchronous knowledge — in this case it corresponds to usual knowledge). If Anne has received both announcements, she should consider it possible that Bill has also received both announcements or only the first announcement. But she should not consider it possible that Bill has not received the first announcement. Because the second announcement, of Kbp, can only be truthfully made after Bill has received the first announcement, of p. The second announcement therefore enforces a restricted kind of synchronization between Anne and Bill.\nA list stating which announcements have been received by which agents we call, following [5], a cut. If Anne received two announcements and Bill none, this is cut 20. Also following [5], we can call this an inconsistent cut; whereas 21 is a a consistent cut. Below we visualize the announcement of p, followed by Bill receiving this, followed by the announcement of Kbp (cut 01). We cannot visualize the announcement of p followed by the announcement of Kbp without b first receiving it, as the announcement of Kbp can then not be truthfully made. In our framework, an inconsistent cut corresponds to a sequence of sending and receiving announcements that cannot be executed.\npq\npq\npq\npq ab\nb\nb\na\na p ⇒\npq\npq\npq\npq ab\nb\nb\na\na\npq\npq\na\n+b ⇒\npq\npq\npq\npq a\nb\nb\na\na\npq\npq b\na\nKbp ⇒\npq\npq\npq\npq a\nb\nb\na\na\npq\npq b\na\npq\npq\na\nThe other mentioned feature of our semantics is that knowledge is no longer truthful. We can illustrate this by the model above. The cut is 01: Bill received p, but Anne did not receive p yet. According to the semantics, we will then get that Kbp ∧Ka¬Kbp is true in this model. Bill knows that p is true because he just heard so. Simultaneously Anne knows (or rather, thinks to know) that Bill does not know that p is true because she has not heard p yet. Anne’s knowledge is incorrect. The notion of asynchronous knowledge that we will propose satisfies the properties of consistent belief (KD45). But it is a rather special kind\nof (possibly false) belief: eventually, after all agents have received all messages, beliefs are correct and thus knowledge.\nAsynchronous announcements are not public in the usual sense. But they are also not private, or semi-private or semi-public: the agents assume that in due time all others will receive the message: it is a broadcast. So what is it? After the announcement of p, and after Anne and Bill have both have received the announcement, they both know p — Kap ∧ Kbp, for which we can write Eabp (everybody knows p) — but they do not know that the other knows p. After the announcement of Eabp and both receiving it we obtain E2abp: everybody knows that everybody knows p. And so on. Anne and Bill never obtain common knowledge of p. (And no growth of common knowledge will ever occur, unlike in public announcement logic.) But they gradually construct common knowledge: it is the concurrent common knowledge of [5]. For the Pandora box opened by such phenomena, see also the delightful [2].\nWe now implement these ideas into a logic of asynchronous announcements."
    }, {
      "heading" : "2 Language and Semantics",
      "text" : "We introduce the language and semantics of asynchronous announcement logic.\nDefinition 1 (Language) Given are a finite set of agents A and a countable set of propositional variables P . Let a ∈ A and p ∈ P :\nLAA ∋ ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | Kaϕ | [ϕ]ϕ | Xaϕ ⊣\nOther propositional connectives and the constants ⊤ (‘true’) and ⊥ (‘false’) are defined by the usual abbreviations. For arbitrary formulas we write ϕ, ψ, ... Formula Kaϕ stands for ‘agent a asynchronously knows ϕ,’ [ϕ]ψ stands for ‘after sending announcement ϕ, ψ (is true),’ and Xaψ stands for ‘after agent a receives the next announcement, ψ (is true).’\nThe language without construct Xaϕ is called LPAL (the language of public announcement logic. The language without constructs Xaϕ and [ϕ]ϕ is LEL (multi-agent epistemic logic).\nWe now simultaneously define the structures (Def. 2), namely the asynchronous model, and the semantics (Def. 3) of asynchronous announcement logic AA. The reason for simultaneity is that asynchronous models incorporate histories of prior truthful asynchronous announcements. To determine if an announcement is truthful (i.e., true) when constructing a model, we need the semantics; whereas to determine the meaning of truthful announcements in the semantics, we need the asynchronous epistemic models.\nDefinition 2 (Asynchronous Model) An asynchronous pre-model over A and P is a sextuple (S,∼, V, s, ~ϕ, f) where S is a (nonempty) domain of states, ∼ : A → P(S × S) is an accessibility function such that for each\nagent a ∈ A, ∼(a), for which we write ∼a, is an accessibility relation for agent a, that is an equivalence relation, valuation V : P → P(S) assigns primitive propositions to the set of states in which they are true, s ∈ S is the actual state, protocol ~ϕ is a finite sequence of formulas of L, and function f : A → {0, . . . , |~ϕ|} is a |~ϕ|-cut (or simply, cut).\nAn asynchronous model is an asynchronous pre-model that satisfies the following inductively defined dependencies between the parameters of the pre-model.\n1. If (S,∼, V, s, ǫ, f0) is an asynchronous pre-model, then (S,∼, V, s, ǫ, f0) is (also) an asynchronous model, called an initial asynchronous model; where ǫ is the empty sequence of announcements and f0 : A → {0} assigns 0 to all agents.\n2. If (S,∼, V, s, ~ϕ, f) is an asynchronous model and (S,∼, V, s, ~ϕ, f) |= ϕ, then (S,∼, V, s, ~ϕ.ϕ, f ′) is an asynchronous model; where ~ϕ.ϕ is the concatenation of ~ϕ and ϕ and where for all agents a, f ′(a) = f(a).\n3. If (S,∼, V, s, ~ϕ, f) is an asynchronous model, and f(a) < |~ϕ|, then (S,∼, V, s, ~ϕ, f+a) is an asynchronous model, where f+a is defined as: f+a(a) = f(a) + 1, and f+a(b) = f(b) for all b 6= a. ⊣\nIn clause 2. above, note that f is a |~ϕ|-cut whereas f ′ is a (|~ϕ|+1)-cut. They define the same function, because value |~ϕ|+1 does not occur in f ′. In clause 3., note that the function f+a is not defined if f(a) = |~ϕ|. Although, given (S,∼, V, s, ~ϕ, f), we call s the actual state, one could more properly consider the entire part (s, ~ϕ, f) as the, structured, ‘actual state’. In particular, not just any s ∈ S can be actual state (as in an asynchronous pre-model), but only those (s, ~ϕ, f) such that (S,∼, V, s, ~ϕ, f) is an asynchronous model — this entails that the announcements in ~ϕ, given the cuts at the moment of the announcements, can all be truthfully executed in s: these are the surviving states in the restricted domain, so to speak.\nDefinition 3 (Semantics) Let (S,∼, V, s, ~ϕ, f) be an asynchronous model and ϕ ∈ L.\n(S,∼, V, s, ~ϕ, f) |= p iff s ∈ V (p) (S,∼, V, s, ~ϕ, f) |= ϕ ∧ ψ iff (S,∼, V, s, ~ϕ, f) |= ϕ and (S,∼, V, s, ~ϕ, f) |= ψ (S,∼, V, s, ~ϕ, f) |= ¬ϕ iff (S,∼, V, s, ~ϕ, f) 6|= ϕ (S,∼, V, s, ~ϕ, f) |= Kaϕ iff (S,∼, V, t, ~ϕ, g) |= ϕ for all t ∼a s, g ≤a f such that (S,∼, V, t, ~ϕ, g) is an asynchronous model (S,∼, V, s, ~ϕ, f) |= [ψ]ϕ iff (S,∼, V, s, ~ϕ, f) |= ψ implies (S,∼, V, s, ~ϕ.ψ, f) |= ϕ (S,∼, V, s, ~ϕ, f) |= Xaϕ iff f(a) < |ϕ| implies (S,∼, V, s, ~ϕ, f +a) |= ϕ\nIn clause Kaϕ, the relation ≤a between cuts is defined as:\ng ≤a f iff g(a) = f(a), and for all b 6= a, g(b) ≤ f(a).\nValidity on a model, and validity, are defined as usual. The set of validities is called AA. Additionally, we consider validity of a formula ϕ on the class of initial asynchronous models, for which we write |=ǫ ϕ. ⊣\nAlso in clause Kaϕ, in the definiens, note that we quantify over t ∈ S and |~ϕ|-cuts g. Additionally to ≤a we define ≤ between |~ϕ|-cuts g and f as: g ≤ f iff for all a ∈ A, g(a) ≤ f(a) (note that g ≤ f does not imply g ≤a f).\nInstead of ‘for all t ∼a s, g ≤a f such that (S,∼, V, t, ~ϕ, g) is an asynchronous model’ we will say ‘for all good t ∼a s, g ≤a f ’, and instead of ‘(S,∼, V, t, ~ϕ, g) is an asynchronous model’ we say ‘(S,∼, V, t, ~ϕ, g) is good.’ We may then even write (s, ~ϕ, f) →a (t, ~ϕ, g), for: ‘given (s, ~ϕ, f), agent a considers (t, ~ϕ, g) possible.’ This notation emphasizes that ‘actual states’ are structured. In other words:\n(S,∼, V, s, ~ϕ, f) |= Kaϕ iff (S,∼, V, t, ~ϕ, g) |= ϕ for all good t ∼a s, g ≤a f or iff (S,∼, V, t, ~ϕ, g) |= ϕ for all (t, ~ϕ, g) s.t. (s, ~ϕ, f) →a (t, ~ϕ, g)"
    }, {
      "heading" : "3 Examples",
      "text" : "We illustrate the language of asynchronous announcement logic and its semantics in a series of successively more complex examples.\nExample 4 (Asynchronous knowledge after asynchronous announcement) Consider the initial asynchronous model from the introductory section wherein Anne knows whether p and Bill knows whether q. After the asynchronous announcement of p ∨ q, and Anne hearing it (+a), we claimed that: (item 1.) Anne considers it possible that Bill knows that p is true, formally [p∨q]XaK̂aKbp, and that (items 2. and 3) Anne considers it possible that Bill does not know that p is true, formally [p∨q]XaK̂a¬Kbp, for two different reasons. We can now indeed compute that. Let S = {pq, pq, pq, pq}, ∼a and ∼b as visually indicated (e.g., ∼a consists of two classes {pq, pq} and {pq, pq}), and the valuation as suggested by the names of the states (e.g., V (p) = {pq, pq}). For notational clarity we write cuts f as lists f(a1)f(a2). . .f(an), for example, for two agents the zero-cut f0 is written as 00, etc.\n1. (S,∼, V, pq, ǫ, 00) |= [p ∨ q]XaK̂aKbp because (S,∼, V, pq, (p ∨ q), 00) |= XaK̂aKbp because (S,∼, V, pq, (p ∨ q), 10) |= K̂aKbp because pq ∼a pq, 11 ≤a 10, and (S,∼, V, pq, (p ∨ q), 11) |= Kbp.\nGiven (pq, (p∨q), 11), Kbp is indeed true, because triples (t, (p∨q), g) then considered possible by Bill are (pq, (p∨q), 11) and (pq, (p∨q), 01). We have that (S,∼, V, pq, (p∨ q), 11) |= p as well as (S,∼, V, pq, (p ∨ q), 01) |= p.\n2. (S,∼, V, pq, ǫ, 00) |= [p ∨ q]XaK̂a¬Kbp because (S,∼, V, pq, (p ∨ q), 10) |= K̂a¬Kbp because pq ∼a pq, 11 ≤a 10, and (S,∼, V, pq, (p ∨ q), 11) |= ¬Kbp.\nThe conclusion (S,∼, V, pq, (p ∨ q), 11) |= ¬Kbp follows from: pq ∼b pq, 11 ≤b 11, and (S,∼, V, pq, (p ∨ q), 11) |= ¬p.\n3. (S,∼, V, pq, ǫ, 00) |= [p ∨ q]XaK̂a¬Kbp because (S,∼, V, pq, (p ∨ q), 10) |= K̂a¬Kbp because (alternatively) pq ∼a pq, 10 ≤a 10, and (S,∼, V, pq, (p ∨ q), 10) |= ¬Kbp.\nIn this (alternative) case, (S,∼, V, pq, (p∨q), 10) |= ¬Kbp because pq ∼b pq, 00 ≤b 10, and (S,∼, V, pq, (p ∨ q), 00) |= ¬p. ⊣\nExample 5 (Synchronization by elimination of inconsistent cuts) Now consider the other example in the introductory section, wherein given the same initial asynchronous model, announcement p is followed by b hearing this, then followed by announcement Kbp (as all pictured), and subsequently followed by a successively hearing both announcements (not pictured). The result is asynchronous model (S,∼, V, pq, (p,Kbp), 21). The second announcement of Kbp is truthful:\nIt is the case that (S,∼, V, pq, (p), 01) |= Kbp, because for all (t, (p), g) such that (pq, (p), 01) →b (t, (p), g) we have that (S,∼, V, t, (p), g) |= p. Note that pq ∼b pq, 11 ≤b 01 and 01 ≤b 01. We therefore only have (pq, (p), 01) →b (pq, (p), 01) and (pq, (p), 01) →b (pq, (p), 11). Both (S,∼, V, pq, (p), 01) |= p and (S,∼, V, pq, (p), 11) |= p.\nWe now continue the computation.\n(S,∼, V, pq, (p,Kbp), 21) |= KaKbp because (S,∼, V, pq, (p,Kbp), 21) |= Kbp and (S,∼, V, pq, (p,Kbp), 22) |= Kbp.\nIntuitively, asynchronous pre-model (S,∼, V, pq, (p,Kbp), 20) is not considered possible by Anne, as the announcement of Kbp cannot be truthfully made before Bill has received the first announcement. Formally, given 21, although 22 ≤a 21, 21 ≤a 21, 20 ≤a 21, pre-model (S,∼, V, pq, (p,Kbp), 20) is not an asynchronous model, and therefore only (pq, (p,Kbp), 21) →a (pq, (p,Kbp), 21) and (pq, (p,Kbp), 21) →a (pq, (p,Kbp), 22). String 20 is an inconsistent cut. ⊣\nExample 6 (Knowledge may become incorrect) Given the previous example with only the first announcement (see also the introductory section), we can observe that:\n(S,∼, V, pq, (p), 01) |= Ka¬Kbp (S,∼, V, pq, (p), 01) |= Kbp\nAnne’s knowledge is incorrect! The computations are straightforward. This also means that Ka¬Kbp∧Kbp would be a truthful (true) announcement in asynchronous model (S,∼, V, pq, (p), 01). After later receiving that announcement, Anne and\nBill can deduce that they had not received the same number of messages at some previous stage. ⊣\nExample 7 (Concurrent common knowledge) Consider again that Anne knows whether p and Bill knows whether q, but there now also is a third agent, Cath, who knows whether p and who also knows whether q (her accessibility relation ∼c is the identity on domain {pq, pq, pq, pq}. There are three announcements, of p, q, and Eabc(p∧ q) (where Eabcϕ := Kaϕ∧Kbϕ∧Kcϕ), and the reception is such that after each announcement all agents ‘immediately’ hear it — we will show later that a property of the semantics is that the order then does not matter. So the sequence of events is:\np,+a,+b,+c, q,+a,+b,+c, Eabc(p ∧ q),+a,+b,+c\nNote that the third annoucement is truthful. The resulting asynchronous model is\n(S,∼, V, pq, (p, q, Eabc(p ∧ q)), 333).\nThe cuts that are consistent from Cath’s perspective are\n{333, 233, 323, 223, 213, 313}.\nSo, Cath considers it possible that Bill has only received the first announcement and considers it possible that Anne has only received the first two announcement. Anything upwards from cut 213 is considered possible by Cath.\nOne can show that\n(S,∼, V, pq, (p, q, Eabc(p ∧ q)), 333) |= E 2 abc(p ∧ q)\n(S,∼, V, pq, (p, q, Eabc(p ∧ q), E 2 abc(p ∧ q)), 444) |= E 3 abc(p ∧ q)\nand so on (where En+1ϕ := EEnϕ and E1ϕ := Eϕ). Anne, Bill and Cath cannot achieve common knowledge of p ∧ q with asynchronous announcements, but they can achieve any finite approximation of it [5]. ⊣"
    }, {
      "heading" : "4 Validities",
      "text" : "Typical schemata that are not valid in asynchronous announcement logic but that are valid in the standard public announcement logic are the following:\n6|= Kaϕ → ϕ\nThis is not valid as the knowledge of agent a may not be updated yet with the most recent announcement (as in Example 6).\n6|= [ϕ][ψ]η ↔ [ϕ ∧ [ϕ]ψ]η\nThis is not valid as in asynchronous announcement logic the number of messages is the number of announcements. Making two announcements into one reduces the number of messages, and thus the meaning of formulas. For example, in an initial asynchronous model [p][q]XaXa⊥ is false whereas [p ∧ [p]q]XaXa⊥ is true.\nAsynchronous knowledge has the properties of consistent belief. Knowledge may be incorrect, as other agents may have received more announcements than yourself (see the first item: it may be false that f ≥a f).\nProposition 8 The following valid schemata describe the properties of asynchronous knowledge.\n1. |= Kaϕ → K̂aϕ\n2. |= Kaϕ → KaKaϕ\n3. |= ¬Kaϕ → Ka¬Kaϕ ⊣\nProof Let (S,∼, V, s, ~ϕ, f) be an asynchronous model.\n1. Assume (S,∼, V, s, ~ϕ, f) |= Kaϕ. Let g be the cut defined as g(b) = f(a) for all b ∈ A. As s ∼a s and g ≤a f , the required now follows, because from the semantics of Kaϕ we then get (S,∼, V, s, ~ϕ, g) |= ϕ. (If there is a b such that f(b) > f(a), we do not have that f ≤a f . The knowledge of a may then be incorrect.)\n2. We show the dual K̂aK̂aϕ → K̂aϕ. Let u ∼a t and t ∼a s, and h ≤a g as well as g ≤a f . (So that (S,∼, V, u, ~ϕ, h) |= ϕ.) As ∼a is an equivalence relation, s ∼a u. From f(a) = g(a) and g(a) = h(a) we get f(a) = h(a). And from h(b) ≤ g(a) and g(a) = f(a) we get h(b) ≤ f(a). Thus, h ≥a f . Therefore, (S,∼, V, s, ~ϕ, f) |= K̂aϕ.\n3. Assume t ∼a s and g ≤a f . Now consider any u and h such that u ∼a s and h ≤a f . Relation ∼a is euclidean, so u ∼a t. From h(a) = f(a) and g(b) ≤ f(a) follows g(b) ≥ h(a); thus g ≤a h. (The winding up is elementary.)\nThe following validities describe the interaction between announcements and other connectives except next.\nProposition 9 • |= [ϕ]p ↔ (ϕ → p)\n• |= [ϕ]¬ψ ↔ (ϕ → ¬[ϕ]χ)\n• |= [ϕ](ψ ∧ χ) ↔ ([ϕ]ψ ∧ [ϕ]χ)\n• |= [ϕ]Kaψ ↔ (ϕ → Kaψ) ⊣\nProof Straightforward. For the last equivalence, note that:\n(S,∼, V, s, ~ϕ, f) |= [ϕ]Kaψ ⇔ semantics of announcement (S,∼, V, s, ~ϕ, f) |= ϕ implies (S,∼, V, s, ~ϕ.ϕ, f) |= Kaψ ⇔ a |~ϕ|-cut is also a (|~ϕ|+ 1)-cut (S,∼, V, s, ~ϕ, f) |= ϕ implies (S,∼, V, s, ~ϕ, f) |= Kaψ ⇔ (S,∼, V, s, ~ϕ, f) |= ϕ → Kaψ\nThe principle for knowledge after (sending) announcement is different from the well-known principle in standard public announcement logic for knowledge after (sending and receiving) announcement: [ϕ]Kaψ ↔ (ϕ → Ka[ϕ]ψ). This is because in AA sending an announcement is independent from an agent receiving that announcement. The semantics of knowledge only depends on how many announcements have already been received by that agent. It does not matter if yet more announcements have been made/sent.\nAs a corollary, for formulas without Xa operators (but not for formulas with Xa operators), public announcement is like a PDL-test [3] — and thus every formula with dynamic announcement modalities is equivalent to a multi-agent epistemic logic formula without announcements.\nCorollary 10 Let ϕ ∈ LAA and ψ ∈ LPAL. Then |= [ϕ]ψ ↔ (ϕ → ψ). ⊣\nWe continue with validities involving the next operator, where it matters whether an agent can still receive an announcement (¬Xa⊥ is true) or has received all announcements (Xa⊥ is true).\nProposition 11 |= Xa⊥ → (Xaϕ ↔ ⊤) ⊣\nProof Obvious.\nCorollary 12 Let ϕ ∈ LAA. Then |=ǫ Xaϕ ↔ ⊤. ⊣\nProposition 13 |= [ϕ]¬Xa⊥ ⊣\nProof Obvious.\nProposition 14 • Xap ↔ (¬Xa⊥ → p)\n• Xa¬ψ ↔ (¬Xa⊥ → ¬Xaψ)\n• Xa(ψ ∧ χ) ↔ (Xaψ ∧Xaχ)\n• XaXbϕ ↔ (¬Xa⊥ → XbXaϕ)\n• XaKbϕ ↔ (¬Xa⊥ → KbXaϕ) where b 6= a\n• Xa[ψ]ϕ ↔ (¬Xa⊥ → [ψ]Xaϕ) ⊣\nProof Obvious. (Note the absence of a reduction for XaKaϕ!)\nCorollary 15 |= (¬Xa⊥ ∧ ¬Xb⊥) → (XaXbϕ ↔ XbXaϕ) ⊣\nCorollary 16 Let ϕ ∈ LAA such that Ka does not occur in ϕ. Then |= ¬Xa⊥ → (Xaϕ ↔ ϕ). ⊣\nProposition 17 (Substitution of equivalents) |= ψ ↔ η implies |= ϕ[p/ψ] ↔ ϕ[p/η]. ⊣\nProof Standard, by induction on ϕ.\nAlthough knowledge is not affected by sending an announcement, as formulated in Proposition 9, it is affected by the combination of sending and receiving an announcement, as we will now prove in Proposition 18. This is our most important semantic result. It is not at all obvious, as the interaction involves asynchronous knowledge that quantifies over all possibilities for other agents to receive announcements. We will use the following abbreviation: let B ⊆ A, B = {b1, . . . , bn}, then XXB := Xb1. . .Xbnϕ — in whatever order, see also Corollary 15.\nProposition 18 |= ( ∧ b∈AXb⊥) → ([ϕ]XaKaψ ↔ (ϕ → ∧ B⊆A,a∈B Ka[ϕ]XXBψ)). ⊣\nProof W.l.o.g. we give the proof for A = {a, b}, and to suit the intuition we give the equivalence in dual diamond-form, such that (with ψ = ¬ψ) the validity becomes\n|= ( ∧\nb∈A\nXb⊥) → (〈ϕ〉X̂aK̂aψ ↔ (ϕ ∧ (K̂a〈ϕ〉X̂aψ ∨ K̂a〈ϕ〉X̂aX̂bψ)).\nGiven (S,∼, V, s, ~ϕ, f), f(a) = f(b) = |~ϕ| so that (S,∼, V, s, ~ϕ, f) |= Xa⊥ ∧Xb⊥. Then:\n(S,∼, V, s, ~ϕ, f) |= 〈ϕ〉X̂aK̂aψ ⇔ semantics of announcement (S,∼, V, s, ~ϕ, f) |= ϕ and (S,∼, V, s, ~ϕ.ϕ, f) |= X̂aK̂aψ ⇔ semantics of next (S,∼, V, s, ~ϕ, f) |= ϕ and (S,∼, V, s, ~ϕ.ϕ, f+a) |= K̂aψ ⇔ semantics of knowledge (S,∼, V, s, ~ϕ, f) |= ϕ and ∃t′ ∼a s, ∃g ′ ≤a f +a, good, such that (S,∼, V, t′, ~ϕ.ϕ, g′) |= ψ\n⇔ (∗∗) (S,∼, V, s, ~ϕ, f) |= ϕ and ∃t ∼a s, ∃g ≤a f, good, such that (S,∼, V, t, ~ϕ, g) |= ϕ, and (S,∼, V, t, ~ϕ.ϕ, g+a) |= ψ or (S,∼, V, t, ~ϕ.ϕ, g+ab) |= ψ ⇔ write g+ab for (g+a)+b (S,∼, V, s, ~ϕ, f) |= ϕ and ∃t ∼a s, ∃g ≤a f, good, such that (S,∼, V, t, ~ϕ, g) |= ϕ, and (S,∼, V, t, ~ϕ.ϕ, g) |= X̂aψ or (S,∼, V, t, ~ϕ.ϕ, g) |= X̂aX̂bψ ⇔ (S,∼, V, s, ~ϕ, f) |= ϕ and ∃t ∼a s, ∃g ≤a f, good, such that (S,∼, V, t, ~ϕ, g) |= 〈ϕ〉X̂aψ or (S,∼, V, t, ~ϕ, g) |= 〈ϕ〉X̂aX̂bψ ⇔ (. . . ) (S,∼, V, s, ~ϕ, f) |= ϕ and (S,∼, V, s, ~ϕ, f) |= K̂a〈ϕ〉X̂aψ ∨ K̂a〈ϕ〉X̂aX̂bψ ⇔ (S,∼, V, s, ~ϕ, f) |= ϕ ∧ (K̂a〈ϕ〉X̂aψ ∨ K̂a〈ϕ〉X̂aX̂bψ)\nThe crucial step (**) in the proof is justified as follows. First observe that g ≤a f iff g+a ≤a f\n+a (for any |~ϕ|-cuts f, g, so that f+a, g+a are defined as (|~ϕ|+ 1)-cuts). (⇒) Let (S,∼, V, s, ~ϕ, f) |= ϕ and take t′ ∼a s, g ′ ≤a f +a, good, such that (S,∼, V, t′, ~ϕ.ϕ, g′) |= ψ, and such that (importantly) g′(b) ≥ f(a). (This choice can be made because we use our initial assumption that ¬Xb⊥ ∧ ¬Xa⊥. Without that assumption there is no proof.) We now distinguish the case where g′(b) = |~ϕ|+1 from the case where g′(b) = |~ϕ|. In the first case, define h as: h(b) = g′(b) and h(a) = g′(a)−1. This is a |~ϕ|-cut, and h+a = g′. Thus, from g′ ≤a f +a follows h ≤a f . We now take t = t ′, g = h, and using the assumption we obtain the required (S,∼, V, t′, ~ϕ.ϕ, h+a) |= ψ (and thus its weakening in a disjunction). In the second case, define h′ as: h′(b) = g′(b)− 1 and h′(a) = g′(a)− 1. We now get that h′ is a |~ϕ|-cut and that h+ab = g′. Similarly, we obtain (S,∼, V, t′, ~ϕ.ϕ, (h′)+ab) |= ψ (and thus its weakening, using the other disjunct).\n(⇐) Let (S,∼, V, t, ~ϕ, g) |= ϕ and take t ∼a s, g ≤a f , good, such that (S,∼, V, t, ~ϕ, g) |= ϕ and also (S,∼, V, t, ~ϕ.ϕ, g+a) |= ψ or (S,∼, V, t, ~ϕ.ϕ, g+ab) |= ψ. Note that g+a ≤a f +a but also g+ab ≤a f +a (as g+ab(b) = f+a(b)). Either way, take t′ = t, and g′ = g+a or g′ = g+ab, and we are done.\nThere are two differences with the interaction between announcement and knowledge in standard public announcement logic ([ϕ]Kaψ ↔ (ϕ → Ka[ϕ]ψ)). In the first place, we have to rule out that Xa means that agent a receives an announcement sent prior to [ϕ]. This is guaranteed by requiring ∧ b∈A Xb⊥. In the second place, in AA we describe the effects of agent a receiving the announcement while all other agents have not received it yet. This means that the receiving agent remains uncertain about any other number of agents also having received the message. Thus the part ∧ B⊆A,a∈B Ka[ϕ]XXBψ that quantifies over this. But, as said, even when all agents received the message, they do not know that from each other: given uncertainty about p with two agents a and b, then after the announcement of p is sent and received by agent a and agent b, agent a knows that p and agent b knows that p, but agent a considers it possible that agent b does not know p and vice versa.\nTheorem 19 Let ϕ ∈ LAA. Then there is a ϕ ′ ∈ LEL such that |=ǫ ϕ ↔ ϕ ′. ⊣\nProof (Sketch) To each Xa operator in a given formula we associate a weight corresponding to the number of unreceived announcements binding it. For example, in Xar → [p][Xaq]XbXaXa(r ∨ Xap) the weights of the successive Xa operators are: 0, 1, 2, 1, 0 and the weight of Xb is 1. Clearly, if the weight is 0 then Xa⊥ is true at that stage, and if larger, then ¬Xa⊥ is true. These weights only make sense when evaluating formulas in an initial asynchronous model (or when all agents have received all formulas), which is what we do.\nBy a combined inside-out and outside-in reduction we rewrite every formula of asynchronous announcement logic to a formula in multi-agent epistemic logic. The proof is by induction of the number of announcement modalities in a given formula (just as for public announcement logic, but in this case rather more complex), with a subinduction on the Xa operators bound by such announcements. That inside-out reductions preserve validity is guaranteed by Proposition 17.\nLet ϕ ∈ LAA be given. For the base case, if the formula contains no announcements, by an outside-in reduction, we can replace every subformula of shape Xaϕ ′ by ⊤ (Corollary 12). It does not have to be outside-in, but this is computationally preferable over inside-out. Note these Xa all have weight 0 (we can see it as a subinduction on the number of such operators in ϕ.)\nFor the inductive case, take an innermost subformula of ϕ of shape [ϕ′]ψ. If ψ contains no Xa modalities, we can reduce the announcement with Corollary 10 of Proposition 9 stating that [ϕ′]ψ ↔ (ϕ′ → ψ). Then, use induction (on the number of announcements in ϕ). Again, we are done. But, of course, there are other cases.\nIf ψ contains subformulas of shape Xaξ but no such ξ contains Ka modalities (so ψ may contain Ka modalities, but only if they are not bound by Xa), then the weight of Xa determines what to do. If the weight of Xa is 0 (if at that stage of evaluation, Xa⊥ is true), then replace Xaξ by ⊤ (Proposition 11). If the weight of Xa is at positive (if at that stage ¬Xa⊥), then replace Xaξ by ξ (Corollary 16), and reduce the weight of all Xa operators in ξ by 1.\nDo this for all such Xa operators bound by [ϕ ′] (i.e., treat them depending on whether they are 0 or positive). Thus we reduce the formula [ϕ′]ψ to an equivalent formula [ϕ′]ψ′ with ψ′ ∈ LEL. We then again use Corollary 10 to get an equivalent formula ψ ′′ ∈ LEL that is equivalent to [ϕ]ψ′. Then, we use induction (on the number of announcements in ϕ), and we are done.\nThe final, most complex, case is when ϕ has an innermost announcement subformula [ϕ′]ψ such that ψ has a subformula of shape Xaψ ′ and ψ′ has a subformula of shape Kaψ ′′. If Xa has weight 0, replace Xaψ ′ by ⊤, as above. If Xa has weight 2 or more, by rewriting we can get Xa to bind [ϕ ′] instead and we continue treatment (using a previous case, or again this case). (Incidentally, an outside-in reduction for Xaψ ′ subformulas may again be preferred here, as this guarantees that the weight of Xa is positive, avoiding this case.) If Xa has weight 1, then by rewriting (using that Xa commutes with Kb for any b 6= a ∈ A\nand that Xa commutes with any Xb, Proposition 14) we get a formula of shape [ϕ ′]XaKaξ ′. We then use Proposition 18 to ‘push’ the [ϕ′]Xa part jointly beyond the Ka operator. We end up with an innermost [ϕ′]XXBξ\n′ where a ∈ B. (Recalculate all the weights in ξ′.) Now this may introduce a lot of additional Xb operators for b 6= a, but this does not matter: if ξ′ contains no (other) Ka operator, and contains no Kb operator, we continue rewriting, as before, and get a ξ′′ ∈ LEL equivalent to [ϕ ′]XXBξ ′, and we use induction on the number of remaining announcements again. Otherwise, also similar to above, we may get again a formula of shape [ϕ′]XbKbη and repeat the application of Proposition 18, but now for agent b. As the set of agents is finite, this process will terminate. Beyond that, subformula ξ′ of the formula [ϕ]XaKaξ ′ that we obtained in this case may contain further Ka operators, leading to further [ϕ]XaKaξ ′′′-reducable patterns (we can see this as a subinduction on the number of Ka modalities in the subinduction on the number of Xa modalities in the main induction on the number of ϕ modalities). Finally, we end up eliminating [ϕ], we use induction on the number of announcements, and we are done.\nAn explicit algorithm, or a complexity measure on formulas shown to decrease by every equivalence transformation (while other transformations, such as swapping XbXa by XbXa, should not change the complexity), would be clearer than this proof sketch, but we think that the sketch is clear enough to count as proof.\nAs initial asynchronous models correspond to multi-agent models where all accessibility relations are equivalence relations (epistemic models), and logic S5 is decidable, it follows from Theorem 19 that: Corollary 20 Asynchronous announcement logic is decidable on the class of epistemic models. ⊣"
    }, {
      "heading" : "5 Comparison and Further Research",
      "text" : "We proposed a logic of asynchronous announcements, where truthful announcements are publicly sent but individually received by agents. Additional to epistemic modalities, the logic therefore contains two types of dynamic modalities, for sending messages and for receiving messages. The semantics defines truth relative to the current state of reception of messages for all agents. This means that knowledge need not be truthful, because some messages may not have been received by the knowing agent. Messages that are announcements may also result in partial synchronization, namely when an agent learns from receiving an announcement that other announcements must already have been received by other agents. We give detailed examples of the semantics, and prove several semantic results, including that: after an announcement an agent knows that a proposition is true, if and only if on condition of the truth of that announcement, the agent knows that after that announcement and after any number of other agents also receiving it, the proposition is true. We show that on multi-agent epistemic models, each formula in asynchronous announcement logic is equivalent to a formula in epistemic logic.\nOur proposal was inspired by [5] and it shares with that original source the notion of the consistent and inconsistent cut. However, in our case the messages are formulas that\nare announcements and not mere identifiers, and are not sent between agents but from an outside, trusted, source, to the agents.\nIn [4] the authors provide an analysis of asynchronous announcements that is different from ours in the following features: it does not consider models with equivalence relations but arbitrary relations (and tree models), the knowledge of agents is not only with respect to announcements prior to those they have already received but also speculates over future announcements that may still come, and the dynamic modalities are not interpreted as model transformations, dynamic epistemic logic style, but as inductively defined transformations of rooted trees.\nA somewhat curious aspect of our semantics is that KaXa⊥ ∨ Ka¬Xa⊥ is valid: if the agent received all announcements she knows that, and if not, she knows that too. (This can be easily shown.) Also, if the agent has received two of five sent announcements she knows that she will receive in due time three more announcements — but she does not know what the announcements will be: we then have that KaXaXaXaXa⊥ and, if ϕ is the next announcement, we have 〈ϕ〉⊤ and therefore K̂a〈ϕ〉⊤ but we do not have Ka〈ϕ〉⊤, as the agent does not know what the actual state is. This is of course a far shot from the ideal asynchronicity of [2] wherein asynchronous knowledge is interpreted over arbitrarily long finite sequences. But it may be useful in certain security or communication protocols of commonly known finite length. It then means that you know when you are done. There, our decidability result might come in handy (unlike the, typically, semantics for asynchronous behaviour with undecidable features).\nFor further research, we wish to prove the decidability of the logic AA (i.e., for all models, beyond the obtained result for initial asynchronous models), determine the complexity of model checking and of satisfiability of the logic, and determine the axiomatization. A number of further generalizations are also conceivable. Asynchronous versions of non-public dynamic epistemic logics such as action model logic should, we think, be straightforward extensions. Beyond that, instead of individually received messages one can think of messages received by (synchronized) groups of agents, such that the message received by all (synchronized) is the standard public announcement. Finally, as in [5], one can also model agents sending each other truthful announcements instead of receiving them from a trusted outside source.\nAcknowledgements Hans van Ditmarsch is also affiliated to IMSc (Institute of Mathematical Sciences), Chennai. This research has been carried out supported by ERC (European Research Council) project EPS 313360.\nI have been hosted in Chennai some ten years now. Always, from my first visit onward until now, Ramanujam engaged me in discussions on how to model asynchronous messaging and distributed computing in dynamic epistemic logic. I owe him much and I hope this work is a start and not a finish. Sophia Knight introduced me to the work of Prakash Panangaden that directly inspired asynchronous announcements, and later Bastien Maubert and Fraņois Schwarzentruber also became involved in this pursuit. Then, our ways parted and their work took the direction of [4]. Clearly, without this past collaboration the underlying\ncould not have resulted and I thank them for all the interaction (and music) that we had together.\nFinally, I thank Philippe Balbiani and Ramanujam for discussing this work with me."
    } ],
    "references" : [ {
      "title" : "Knowable’ as ‘known after an announcement",
      "author" : [ "P. Balbiani", "A. Baltag", "H. van Ditmarsch", "A. Herzig", "T. Hoshi", "T. De Lima" ],
      "venue" : "Review of Symbolic Logic,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2008
    }, {
      "title" : "Knowledge and common knowledge in a distributed environment",
      "author" : [ "J.Y. Halpern", "Y. Moses" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1990
    }, {
      "title" : "Dynamic Logic",
      "author" : [ "D. Harel", "D. Kozen", "J. Tiuryn" ],
      "venue" : "Foundations of Computing Series",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2000
    }, {
      "title" : "Asynchronous announcements in a public channel",
      "author" : [ "S. Knight", "B. Maubert", "F. Schwarzentruber" ],
      "venue" : "In Proc. of 12th ICTAC, pages 272–289,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "Concurrent common knowledge: Defining agreement for asynchronous systems",
      "author" : [ "P. Panangaden", "K. Taylor" ],
      "venue" : "Distributed Computing,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1992
    }, {
      "title" : "A knowledge based semantics of messages",
      "author" : [ "R. Parikh", "R. Ramanujam" ],
      "venue" : "Journal of Logic, Language and Information,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2003
    }, {
      "title" : "Logics of public communications",
      "author" : [ "J.A. Plaza" ],
      "venue" : "In Proc. of the 4th ISMIS,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1989
    }, {
      "title" : "Merging frameworks for interaction",
      "author" : [ "J. van Benthem", "J.D. Gerbrandy", "T. Hoshi", "E. Pacuit" ],
      "venue" : "Journal of Philosophical Logic,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Connecting dynamic epistemic and temporal epistemic logics",
      "author" : [ "H. van Ditmarsch", "J. Ruan", "W. van der Hoek" ],
      "venue" : "Logic journal of the IGPL,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "Public announcement logic [7] is a well-known modal logic to model change of information.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 7,
      "context" : "A different way to view the model transformation induced by the public announcement is as an internal step in a larger model, known as the protocol-generated forest [8, 9].",
      "startOffset" : 165,
      "endOffset" : 171
    }, {
      "referenceID" : 8,
      "context" : "A different way to view the model transformation induced by the public announcement is as an internal step in a larger model, known as the protocol-generated forest [8, 9].",
      "startOffset" : 165,
      "endOffset" : 171
    }, {
      "referenceID" : 5,
      "context" : ") Such are also known as history-based structures [6], as we do not discard the state of information before the announcement/message.",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 4,
      "context" : "In [5], Panangaden and Taylor presented a system wherein agents/processes can receive messages at different times, in order to model asynchronous communication.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "Our framework is then more alike [5] (we will discuss this later).",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 0,
      "context" : "Such scenarios are considered in arbitrary public announcement logic [1], although, there, not with asynchronicity in mind.",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 4,
      "context" : "A list stating which announcements have been received by which agents we call, following [5], a cut.",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 4,
      "context" : "Also following [5], we can call this an inconsistent cut; whereas 21 is a a consistent cut.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 4,
      "context" : ") But they gradually construct common knowledge: it is the concurrent common knowledge of [5].",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 1,
      "context" : "For the Pandora box opened by such phenomena, see also the delightful [2].",
      "startOffset" : 70,
      "endOffset" : 73
    }, {
      "referenceID" : 4,
      "context" : "Anne, Bill and Cath cannot achieve common knowledge of p ∧ q with asynchronous announcements, but they can achieve any finite approximation of it [5].",
      "startOffset" : 146,
      "endOffset" : 149
    }, {
      "referenceID" : 2,
      "context" : "As a corollary, for formulas without Xa operators (but not for formulas with Xa operators), public announcement is like a PDL-test [3] — and thus every formula with dynamic announcement modalities is equivalent to a multi-agent epistemic logic formula without announcements.",
      "startOffset" : 131,
      "endOffset" : 134
    }, {
      "referenceID" : 4,
      "context" : "Our proposal was inspired by [5] and it shares with that original source the notion of the consistent and inconsistent cut.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 3,
      "context" : "In [4] the authors provide an analysis of asynchronous announcements that is different from ours in the following features: it does not consider models with equivalence relations but arbitrary relations (and tree models), the knowledge of agents is not only with respect to announcements prior to those they have already received but also speculates over future announcements that may still come, and the dynamic modalities are not interpreted as model transformations, dynamic epistemic logic style, but as inductively defined transformations of rooted trees.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "This is of course a far shot from the ideal asynchronicity of [2] wherein asynchronous knowledge is interpreted over arbitrarily long finite sequences.",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 4,
      "context" : "Finally, as in [5], one can also model agents sending each other truthful announcements instead of receiving them from a trusted outside source.",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 3,
      "context" : "Then, our ways parted and their work took the direction of [4].",
      "startOffset" : 59,
      "endOffset" : 62
    } ],
    "year" : 2017,
    "abstractText" : "Public announcement logic [7] is a well-known modal logic to model change of information. Given a group A of agents that is uncertain about a set of propositional variables P , including higher-order uncertainty (agent a does not know p but considers it possible that agent b knows p), they are simultaneously informed by an outsider of new information. The assumption is that the information is true (reliable) and that it is common knowledge among the agents that all agents receive the information. We consider a version of truthful public announcement logic where announcements are still truthful and (in some sense) public, but where they may not be received instantly by the agents. Let us illustrate this by an example. Consider two agents Anne (a) and Bill (b), and two propositional variables p and q. Anne knows the truth about p and Bill knows the truth about q, and this is common knowledge between them. In fact, p and q are both true. A truthful public announcement of p∨q is now made. The model encoding the uncertainty of Anne and Bill and the model transition resulting from the announcement are as follows— we represent Anne’s uncertainty by a-labelled links (representing indistinguishable states) and Bill’s uncertainty by b-labelled links; the actual state is framed. States have been given mnemonic names reflecting the valuation of atoms in that state, e.g., pq is the state where p is false and q is true.",
    "creator" : "LaTeX with hyperref package"
  }
}