{
  "name" : "1406.2161.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Tableaux for Dynamic Logic of Propositional Assignments",
    "authors" : [ "Tiago de Lima", "Andreas Herzig" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 6.\n21 61\nv1 [\ncs .L\nO ]\n9 J\nun 2\nKeywords: Modal Logic; Propositional Dynamic Logic; Dynamic Logic of Propositional Assignments; analytic tableaux."
    }, {
      "heading" : "1 Introduction",
      "text" : "Dynamic Logic of Propositional Assignments, abbreviated DL-PA, has recently been studied in [10,2] as an interesting alternative to Propositional Dynamic Logic (PDL) [7]. In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4]. While, in PDL, one can write formulas of the form [a]ϕ, meaning “after every possible execution of the abstract atomic program a, formula ϕ is true”, in DL-PA, one can write formulas of the form [+p]ϕ, meaning “after assigning the truth value of p to true, formula ϕ is true”. The atomic program +p is an assignment that maps the propositional variable p to true. In fact, the atomic programs of DL-PA are sets of such assignments, that are viewed as partial functions from the set of propositional variables to {⊤,⊥}. From these atomic programs, complex programs are built just as in PDL. For example, one can write in DL-PA the formula [¬p?;+p]p, which means “if p is false then p is true after its truth value be assigned to true”.\nWhile the models of PDL are transition systems, the models of DL-PA are much smaller: valuations of classical propositional logic, i.e., nothing but sets of propositional variables. Due to that, DL-PA enjoys some interesting meta-logical properties that PDL lacks, such as eliminability of the Kleene star, compactness and interpolation.\nThe complexity of the satisfiability problem in DL-PA is the same as in PDL: it is in EXPTIME for the full language and PSPACE complete for the star-free fragment. EXPTIME membership of the full language is proved by a polynomial embedding of DL-PA into PDL, and PSPACE membership of the star-free fragment of DL-PA is\nproved via NPSPACE membership of its model checking problem, exploiting the fact that NPSPACE = PSPACE. However, these reductions lead to suboptimal theorem proving methods. Our aim in this paper is to define tableaux theorem proving procedures for DL-PA that are both direct and more efficient.\nThe paper is organized as follows. We start by recalling DL-PA (Section 2). Then, we provide a tableaux method for its star-free fragment (Section 3) and show an algorithm implementing it that works in polynomial space (Section 4). After that, we extend the tableaux method to the full language of DL-PA (Section 5) and then show an algorithm implementing it and that works in time exponential (Section 6). Section 7 discusses some issues and concludes the paper.3"
    }, {
      "heading" : "2 Dynamic Logic of Propositional Assignments",
      "text" : ""
    }, {
      "heading" : "2.1 Syntax",
      "text" : "The vocabulary of DL-PA contains a countable set P of propositional variables. From this set, we build the setA of propositional assignments, which are the atomic programs of the language. Each propositional assignment is a non-empty finite partial function from P to {⊥,⊤}.4\nThe language L of DL-PA is the the set of formulas ϕ defined by the BNF:\nϕF p | ¬ϕ | ϕ ∧ ϕ | [π]ϕ\nπF α | π; π | π ∪ π | π∗ | ϕ?\nwhere p ranges over P and α ranges over A. To ease notation and readability of programs, we write +p for (p,⊤) and −p for (p,⊥). Moreover, we sometimes “forget” some parentheses and curly braces when writing propositional assignments. As a result, the formula [{(p,⊤), (q,⊥)}]ϕ is rather noted [+p,−q]ϕ. In some places, we use the expression ±p to talk economically about +p and −p at the same time.\nThe complex programs of DL-PA are constructed as in Dynamic Propositional Logic (PDL) [8]. As well as in PDL, formulas of the form [π]ϕ are read “after every possible execution of π, ϕ is true”.\nWe also use the common abbreviations for the connectives ⊤, ⊥, ∨, → and ↔. The formula 〈π〉ϕ abbreviates ¬[π]¬ϕ. The star-free fragment of L is the fragment without the Kleene star operator ∗ and is noted L−∗.\nThe length of a formula or a program, given by the function len, is the number of atoms and connectives in the formula or the program. Table 1 defines it formally.\nThe closure of ϕ is the set cl(ϕ) defined in Table 2. This is almost the same as the Fisher-Ladner closure [5], which is used to show decidability and complexity results for PDL. But since the atomic programs of DL-PA are sets of assignments, there is a difference here in the definition of cl ([α]ϕ). It takes into account the assignments by adding the domain of the atomic program α.\n3 Proofs of the important theorems are in the appendix. 4 We note that the original language in [2] is slightly more restrictive: α only assigns a single\npropositional variable. But, as shown in this paper, it does not change the known decidability and complexity results.\nThe extended closure of ϕ is the set cl+(ϕ) containing cl(ϕ) and the negations of its formulas, i.e., cl+(ϕ) = cl(ϕ)∪ {¬ψ : ψ ∈ cl(ϕ)}. To ease notation, we sometimes use Pϕ to denote the set of propositional variables occurring in ϕ, i.e. Pϕ = P ∩ cl(ϕ).\nThe lemma below can be proved with an easy induction on the length of formulas and programs.\nLemma 1.\n1. card(cl ([π]ϕ)) ≤ len([π]ϕ) 2. card(cl(ϕ)) ≤ len(ϕ). 3. card(cl+(ϕ)) ≤ 2 len(ϕ).\nIntuitively, the set of execution traces of π is the set exe(π) of sequences of assignments that corresponds to all possible executions of program π. The set exe(ϕ) corresponds to all possible executions of all programs in ϕ. These are defined by a mutual recursion, as displayed in Table 3. We use the symbol ‘()’ to denote the empty sequence.\nThe length of execution traces, also given by the function len, is just the number of atomic programs in it. That is: len(()) = 0, len(α) = 1 and len(σα) = len(σ) + len(α).\nThe lemma below can also be proved with an easy induction on the length of programs and formulas:\nLemma 2.\n1. If π does not contain the Kleene star then len(σ) ≤ len(π), for all σ ∈ exe(π). 2. If ϕ ∈ L−∗ then len(σ) ≤ len(ϕ), for all σ ∈ exe(ϕ).\nNote, however, that each σ ∈ exe(π∗) is infinite."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "A DL-PA model is a set V ⊆ P of propositional variables. When p ∈ V then p is true, and when p < V then p is false.\nThe interpretation of an assignment α is in terms of a model update. The update of a model V by an assignment α is the new model Vα such that:\nVα = {p : V |= α(p)}\nwhere we suppose that when p is not in the domain of α then α(p) equals p. In particular, for the assignment +p we have V+p = V ∪ {p}. Given a sequence of assignments α1 . . . αn, for the sake of readability, we sometimes write Vα1 ···αn instead of (· · · (Vα1 ) · · · )αn .\nFormulas ϕ are interpreted as sets of models ||ϕ||, while programs π are interpreted by means of a (unique) relation between valuations ||π||. Just as in PDL, the formal definition is by a mutual recursion. It is given in Table 4.\nAs usual, we also write V |= ϕ to mean that V ∈ ||ϕ||. Moreover, given a formula ϕ, we say that ϕ is DL-PA valid (noted |= ϕ) if and only if ||ϕ|| = 2P, and we say that ϕ is DL-PA satisfiable if and only if ||ϕ|| , ∅.\nFor example, the formulas [+p]⊤, [+p]ϕ↔ ¬[+p]¬ϕ, [π]⊤, [+p]p and [−p]¬p are all DL-PA valid."
    }, {
      "heading" : "2.3 Existing Proof Methods",
      "text" : "We now recall the existing methods for both model checking and satisfiability checking in DL-PA. They either use a non-elementary reduction to propositional logic or a quadratic embedding into PDL. We then provide a linear reduction of satisfiability checking to model checking. This justifies our focus on a tableaux method for model checking in the rest of the paper. But first, let us recall some valid principles in DL-PA.\nProposition 1 ([10]). The following principles are valid in DL-PA:\n1. [α]p ↔ α(p) 2. [ψ?]ϕ↔ (ψ→ ϕ) 3. [π]¬ϕ↔ ¬[π]ϕ 4. [π](ϕ ∧ ψ) ↔ ([π]ϕ ∧ [π]ψ) 5. [π1; π2]ϕ↔ [π1][π2]ϕ 6. [π1 ∪ π2]ϕ↔ ([π1]ϕ ∧ [π2]ϕ) 7. [π∗]ϕ↔ (ϕ ∧ [π][π∗]ϕ) 8. From ψ→ (ϕ ∧ [π∗]ψ) infer ψ→ [π∗]ϕ\nIt follows from Proposition 1.1–1.6 plus the rule of substitution of valid equivalences that the star-free fragment of DL-PA is reducible to propositional logic. This however fails to provide an efficient theorem proving method because the reduced formula might be exponentially longer than the original formula. In [2], it is also shown that the Kleene star can be eliminated in DL-PA, i.e., there is an algorithm that translates every formula in L to an equivalent formula in L−∗. Such translation, however, also leads to much longer formulas. In fact, this is a non-elementary reduction because it starts from the innermost Kleene star operator.\nSatisfiability checking in DL-PA is shown to be in EXPTIME in [2]. The proof is given via a translation to satisfiability checking in PDL. For every DL-PA formula ϕ, the translation tr returns a PDL formula which is obtained by just replacing each assignment ±p by an abstract PDL program a±p. To guarantee that the abstract programs behave the same way as the original assignment, the following set of formulas Γϕ is also used:\nΓϕ = {[a+p]p : p ∈ Pϕ} ∪\n{[a−p]¬p : p ∈ Pϕ} ∪\n{〈a±p〉⊤ : ±p ∈ Pϕ} ∪\n{q → [a±p]q : p, q ∈ Pϕ, p , q} ∪\n{¬q → [a±p]¬q : p, q ∈ Pϕ, p , q}\nProposition 2 ([2]). Let Uϕ be the PDL program ( ⋃ p∈Pϕ (a+p∪a−p)) ∗. For every DL-PA formula ϕ, ϕ is DL-PA satisfiable if and only if\ntr(ϕ) ∧ [Uϕ] ( ∧ Γϕ )\nis PDL satisfiable.\nNote that, even though this reduction is polynomial, a quadratically longer formula is produced. Precisely, the size of Γϕ is bounded by 5 len(ϕ)2. Moreover, if we consider the star-free fragment of DL-PA, this transformation is sub-optimal, because of the Kleene star operator in Uϕ.5\nIf follows from the next result that satisfiability checking in DL-PA can be linearly reduced to model checking in DL-PA.\nProposition 3. Let a formula ϕ ∈ L be given. Let Pϕ = {p1, . . . , pn}. and let Mϕ be the DL-PA program (+p1 ∪ −p1); . . . ; (+pn ∪ −pn). Formula ϕ is satisfiable if and only if V |= 〈Mϕ〉ϕ for any model V.\nProof. It suffices to see that the interpretation of the program Mϕ relates all possible valuations in the vocabulary of ϕ, while leaving the other variables unchanged. ⊓⊔\nThe operation [Mϕ] works as a master modality and thus 〈Mϕ〉 works as its dual. Because it does not contain the Kleene star operator, the length of 〈Mϕ〉ϕ is bounded by 3 len(ϕ). Also note that, in particular, ϕ is satisfiable if and only if V = ∅ satisfies 〈Mϕ〉ϕ. This means that the input (V, 〈Mϕ〉ϕ) for the model checking problem is also linear on the length of ϕ. Therefore, in order to perform satisfiability checking in DL-PA, one could take advantage of an efficient algorithm for model checking in DL-PA. This motivates the tableaux methods presented in the next section.\nBefore concluding this section, let us recall that, in DL-PA, model checking has the same computational complexity as satisfiability checking. This follows from Proposition 3 above and Proposition 4 below.\nProposition 4 ([2]). For every valuation V and formula ϕ, V ∈ ||ϕ|| if and only if the formula\nϕ ∧\n         ∧\np∈Pϕ∩V\np\n         ∧          ∧\np∈Pϕ\\V\n¬p\n        \nis DL-PA satisfiable."
    }, {
      "heading" : "3 A Tableaux Method for Star-Free DL-PA",
      "text" : "In this section, we define a model checking procedure for the star-free fragment of DL-PA using analytic tableaux. We start with some useful definitions.\nA labeled formula is a pair λ = 〈σ, ϕ〉, where σ = α1 . . . αn is a (possibly empty) sequence of propositional assignments and ϕ ∈ L. A branch is a set of labelled formulas.\nDefinition 1 (Tableau). Let V ⊆ P and ϕ0 ∈ L−∗. The initial branch for (V, ϕ0) is the the set b0 = {〈(), p〉 : p ∈ Pϕ0 ∩ V} ∪ {〈(),¬p〉 : p ∈ Pϕ0 \\ V} ∪ {〈(), ϕ0〉}. A tableau for (V, ϕ0) is a set of branches T that satisfies one of the following two conditions:\n1. T = {b0}, which is called the initial tableau for (V, ϕ0).\n5 For the star-free fragment, a transformation without the Kleene star operator is also possible. In this case, the program ⋃\np∈Pϕ(a+p ∪ a−p) must be iterated up to len(ϕ), but this leads to an even longer formula.\n2. T = (T ′ \\ {b}) ∪ B, where T ′ is a tableau for (V, ϕ0) containing the branch b and B is a set of k branches {b ∪ b1, . . . , b ∪ bk} generated by one of the following tableau rules below:6\n(R¬) 〈σ,¬¬ϕ〉 ∈ b implies k = 1 and b1 = {〈σ, ϕ〉}. (R∧) 〈σ, ϕ ∧ ψ〉 ∈ b implies k = 1 and b1 = {〈σ, ϕ〉, 〈σ, ψ〉}. (R∨) 〈σ,¬(ϕ ∧ ψ)〉 ∈ b implies k = 2, b1 = {〈σ,¬ϕ〉} and b2 = {〈σ,¬ψ〉}. (R[α]) 〈σ, [α]ϕ〉 ∈ b implies k = 1 and\nb1 = {〈σα, ϕ〉} ∪ {〈σα, p〉 : α(p) = ⊤} ∪ {〈σα,¬p〉 : α(p) = ⊥}. (R〈α〉) 〈σ,¬[α]ϕ〉 ∈ b implies k = 1 and\nb1 = {〈σα,¬ϕ〉} ∪ {〈σα, p〉 : α(p) = ⊤} ∪ {〈σα,¬p〉 : α(p) = ⊥}. (R[?]) 〈σ, [ψ?]ϕ〉 ∈ b implies k = 2, b1 = {〈σ,¬ψ〉} and b2 = {〈σ, ϕ〉}. (R〈?〉) 〈σ,¬[ψ?]ϕ〉 ∈ b implies k = 1 and b1 = {〈σ, ψ〉, 〈σ,¬ϕ〉}. (R[;]) 〈σ, [π1; π2]ϕ〉 ∈ b implies k = 1 and b1 = {〈σ, [π1][π2]ϕ〉}. (R〈;〉) 〈σ,¬[π1; π2]ϕ〉 ∈ b implies k = 1 and b1 = {〈σ,¬[π1][π2]ϕ〉}. (R[∪]) 〈σ, [π1 ∪ π2]ϕ〉 implies k = 1 and b1 = {〈σ, [π1]ϕ〉, 〈σ, [π2]ϕ〉}. (R〈∪〉) 〈σ,¬[π1∪π2]ϕ〉 ∈ b implies k = 2, b1 = {〈σ,¬[π1]ϕ〉} and b2 = {〈σ,¬[π2]ϕ〉}. (RP1) {〈σ, p〉, 〈σα, ψ〉} ⊆ b for some ψ and p < dom(α) implies k = 1 and b1 = {〈σα, p〉}. (RP2) {〈σ,¬p〉, 〈σα, ψ〉} ⊆ b for some ψ and p < dom(α) implies k = 1 and\nb1 = {〈σα,¬p〉}.\nThe initial tableau corresponds to the input of the problem in the tableau. Rules R¬, R∧ and R∨ are the standard tableaux rules for Boolean connectives. RP1 and RP2 (propagation rules) propagate literals whose the truth value is not changed by assignments: if the model updated by σ satisfies p and α does not change the truth value of p then the model updated by σα also satisfies p. The other rules just reflect the semantic definition of the corresponding programs. For instance, for the rule R[α], if the model updated by the sequence of assignments σ satisfies [α]ϕ then the model updated by the sequence σα satisfies ϕ. Note that they also correspond to the validities 1–6 in Proposition 1.\nA branch b is blatantly inconsistent if and only if b contains both 〈σ, ϕ〉 and 〈σ,¬ϕ〉, for some σ and ϕ. A branch b is closed if and only if it is blatantly inconsistent. A tableau is closed if and only if all its branches are closed. A tableau is open if and only if it is not closed.\nThe idea is that, if there is a closed tableau for the input (V, ϕ0) then V 6|= ϕ0. On the other hand, if there is no closed tableau for (V, ϕ0) then V |= ϕ0.\nExample 1. Table 5 shows how the method can be used to prove that the model V = {p, q} does not satisfy the formulaϕ0 = ¬[+p∪−p]q. In the table, lines 1–3 consist of the initial tableau for the input (V, ϕ0). Rule applications are indicated between parentheses on the left of each line. Line 4 is generated by the application of R[∪] to line 3. This generates two different branches. The rule applications continue until both branches are closed.\n6 Some of these rules are also presented in the more traditional numerator-denominator form in Table 10 of the Appendix.\nExample 2. Table 6 shows how the method can be used to prove that the model V = ∅ satisfy the formula ϕ0 = [¬p?;+p]p. Note that RP2 is not applicable to the labelled formulas in lines 1 and 5 because p ∈ dom(+p). Thus, the branch on the right remains open, which means that V |= ϕ0.\nIn the sequel, we show the soundness of the method. The idea is to show that, if V |= ϕ0, then successive rule applications can never close the tableau. But first, a useful definition and a lemma are presented.\nDefinition 2 (Consistent Branch). A branch b is consistent if and only if Vσ |= ϕ for every 〈σ, ϕ〉 ∈ b.\nLemma 3 (Consistency Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a consistent branch.\nTheorem 1 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0).\nWe now address the completeness of the method. The idea is to show that, if the tableau remains open after all possible applications of the tableau rules, then V |= ϕ0. But first, some useful definitions are presented.\nDefinition 3 (Witness). A witness to rule ρ in branch b is a labelled formula 〈σ, ϕ〉 ∈ b allowing the application of ρ.\nFor example, 〈(),¬¬p〉 is a witness to R¬, and 〈β,¬[+p,−q]p〉 is a witness to R〈α〉. Moreover, the formula 〈σ, p〉 is a witness to RP1 in b if there is a formula 〈σα, ψ〉 ∈ b and p < dom(α).\nDefinition 4 (Saturated Tableau). The label σ in the branch b is saturated under the tableau rule ρ if and only if for each witness 〈σ, ϕ〉 to ρ in b, b contains some bi generated by the application of ρ to b. The branch b is saturated under the tableau rule ρ if and only if all its labels are saturated. A branch is saturated if and only if it is saturated under all tableau rules. A tableau is saturated if and only if all its branches are saturated.\nTheorem 2 (Completeness). If there is no closed tableau for (V, ϕ0) then V |= ϕ0."
    }, {
      "heading" : "4 An Optimal Procedure for Star-Free DL-PA",
      "text" : "In this section we define an algorithm to check whether V |= ϕ0, for ϕ0 ∈ L−∗. Such an algorithm is displayed in Table 7. It implements the tableaux method using the recursive function mcTableau. It takes as argument a tableau branch b and returns whether b is consistent. When called with the initial tableau for (V, ϕ0) it returns whether V |= ϕ0. The execution of mcTableau explores in a depth-first manner a tree whose nodes are tableau branches and each child is generated by the application of a tableau rule to its parent.\nThe rules are applied in a specific order and, after the application of a rule, the witness is marked ‘non-applicable’, thus avoiding an infinite loop. Lines 8–21 perform what is called ‘local saturation’. That is, only rules that do not create labelled formulas with different labels than that of the witness are applied. Its first part (lines 8–11) applies rules that do not create more than one branch in the tableau. Its second part (lines 12– 21) apples rules that create more than one branch in the tableau. At the end of the local saturation, only witnesses to rules R[α], R〈α〉 remain. Note that no new label is created in the local saturation part, which means that there can be no witnesses to rules RP1 and RP2. Then, in lines 22–38 the algorithm performs what is called ‘successor creation’. First (line 22), it tests whether there is a successor to be created, i.e., if there is a witness λ to R[α] or R〈α〉. It creates the successor (line 23) and then marks the witness as ‘non-applicable’ (line 24). After that (lines 25–34), it propagates the suitable formulas to the successor, as follows: assume that the witness is λ = 〈σ, [α]ψ〉. Then, for every labelled formula 〈σ, [α]ψ′〉 and 〈σ, 〈α〉ψ′〉 there must be a labelled formula 〈σα, ψ′〉 in the successor. This is done in lines 25–29. And also, every labelled formula 〈σ, p〉 (resp. 〈σ,¬p〉) must be propagated, i.e., there must be a labelled formula 〈σα, p〉 (resp. 〈σα,¬p〉) in the successor b1. This is done in lines 30–34. The last part (lines 35– 37) makes a recursive call to mcTableau with the b1. The current branch is considered satisfiable if all recursive calls return true.\nThis algorithm has two important features. First, its successor creation part guarantees that each time mcTableau is called with branch b as argument, all the labelled formulas in b have the same label. Second, the first feature implies that the list of successors created during successive recursive calls of mcTableau corresponds to one execution trace from input formula ϕ0. These are the key arguments used in the proof of complexity result below.\nTheorem 3 (Termination). The algorithm in Table 7 halts for every input (V, ϕ0).\nTheorem 4 (Complexity). The amount of memory used by the algorithm in Table 7 is a polynomial function of the length of the input (V, ϕ0).\nTherefore, the algorithm in Table 7 works in space polynomial in the length of the input. This is an optimal algorithm, given that the satisfiability problem in star-free DL-PA is PSPACE-complete [10]."
    }, {
      "heading" : "5 A Tableaux Method for Full DL-PA",
      "text" : "In this section, we define an extension of the tableaux method that also takes into account the Kleene star operator.\nDefinition 5 (Tableau). Let (V, ϕ0) be the input under concern (thus, the initial tableau is the same as in Definition 1). The tableau rules for full DL-PA are those of Definition 1 plus the following ones:\n(R[∗]) 〈σ, [π∗]ϕ〉 ∈ b implies k = 1 and b1 = {〈σ, ϕ〉, 〈σ, [π][π∗]ϕ〉}. (R〈∗〉) 〈σ,¬[π∗]ϕ〉 ∈ b implies k = 2, b1 = {〈σ,¬ϕ〉} and b2 = {〈σ, ϕ〉, 〈σ,¬[π][π∗]ϕ〉}.\nThe two rules above reflect the fix point property of Proposition 1.7. For instance, if the model Vσ |= [π∗]ϕ then Vσ |= ϕ and also Vσ |= [π][π∗]ϕ.\nDefinition 6 (Fulfillment). An eventuality 〈σ,¬[π∗]ϕ〉) is fulfilled in a tableau branch b if and only if there is a (possibly empty) execution trace σ′ ∈ exe(π) such that 〈σσ′,¬ϕ〉 ∈ b.\nDefinition 7 (Closed Branch). A branch b is closed if and only if (1) b is blatantly inconsistent or (2) b is saturated and contains an unfulfilled eventuality.\nExample 3. Table 8 shows how the method can be used to prove that model V = {p, q} does not satisfy the formula ϕ0 = ¬[(+p∪−p)∗]q. The leftmost branch is closed because it is blatantly inconsistent. In the branch of the middle, the same pattern will be repeated indefinitely. Thus, it is an infinite brunch, but it is saturated. Since the eventuality in line 3 is not fulfilled, it is also closed. The right-most branch is analogous to the one in the middle.\nIf the input formula contains a sub-formula of the form ¬[π∗]ϕ, the method invariably creates tableaux with infinite branches that repeat the same pattern over and over again, as in Example 3. The repetition can be detected and it is possible to provide a terminating algorithm. This is presented in Section 6. Here, we show the correctness of the method presented so far.\nLemma 4 (Consistency Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a consistent branch.\nTheorem 5 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0).\nTheorem 6 (Completeness). If there is no closed tableau for (V, ϕ0) then V |= ϕ0."
    }, {
      "heading" : "6 An EXPTIME Procedure for Full DL-PA",
      "text" : "In this section, we define a procedure to model check formulas in L. As before, we define an algorithm. Here, it must detect the aforementioned repetitions of the applications of R〈∗〉 in the tableau. This is done by performing equality tests. A label σ1 is said to be equal to a label σ2 if and only if the set of formulas labelled by σ1 and σ2 are the same. More formally we have:\nDefinition 8 (Equality). Let σ1 and σ2 be two labels in the tableau T . Label σ1 is equal to label σ2 (noted σ1 = σ2) if and only if there are two branches b1, b2 ∈ T such that {ϕ : 〈σ1, ϕ〉 ∈ b1} = {ϕ : 〈σ2, ϕ〉 ∈ b2}.\nAn equality test between labels can prevent the tableau to enter in an infinite loop. Then one can try to provide an algorithm that is similar to the one in Section 4, by first adding rules R[∗] and R〈∗〉 in their suitable places and the equality test just before the exploration of a new successor. Such an algorithm works, but is not optimal. For instance, the application of the method to the formula [(+p1∪−p1∪· · ·∪+pn∪−pn)∗]p creates 2n different successors from a single tableau branch. Then such a method may explore a tree whose the number of nodes is bounded by 22\nlen(ϕ0) . However, satisfiability in DL-PA is proven to be in EXPTIME.\nA different technique than that in Section 4 must be employed in order to obtain a more efficient method for full DL-PA. Such a technique is implemented in the algorithm of Table 9. It is somewhat similar to the algorithm in Section 4, but there are some important differences. The most important ones are the addition of the equality test in lines 17–19 and the fact that this algorithm now maintains the entire tableau T in memory. It does not uses a recursive function anymore, for it now uses the tableau T as the search tree. Once the initial tableau for (V, ϕ0) is created in line 4, it enters a loop that finishes when T is closed or saturated (recall that a branch is also considered to be closed if it is saturated and contains an unfulfilled eventuality). As before, there is a ‘local saturation’ part (lines 9–16) and a ‘successor creation’ part (lines 20–33). In lines 36–40, the algorithm tests whether T is still open to return the right answer.\nTheorem 7 (Termination). The algorithm in Table 9 halts for every input (V, ϕ0).\nTheorem 8 (Complexity). The amount of time used by the algorithm in Table 9 is an exponential function of the length of the input (V, ϕ0).\nThus, the algorithm in Table 9 works in time exponential on len(ϕ0). This is as expected, given that the model checking problem in full DL-PA is in EXPTIME [10]."
    }, {
      "heading" : "7 Discussion and Conclusion",
      "text" : "In this paper, we have defined a linear reduction of satisfiability checking into model checking in DL-PA. We also define analytic tableaux methods for model checking formulas in the star-free fragment and in full DL-PA. The complexity of these methods match the complexity class of their respective problems. In the sequel, we compare such methods to similar approaches and discuss possible improvements and extensions.\nComparisons. The methods presented in this paper have been inspired by others already proposed in the literature. For instance, De Giacomo and Massacci [3] (see also [12]) inspired the technique for the Kleene star. As already mentioned, the naive strategy would generate tableau branches with size exponential in the length of the input formula. The idea of keeping the tree in memory and perform equality tests comes from that work.\nAssignments of Propositional Variables to Formulas. DL-PA can be extended with assignments α to formulas in L, instead of the simpler {⊤,⊥}. The corresponding tableau rule R[α] would be as follows:\nσ : [α]ϕ σ : ψ1 σ : ψ2 ... σ : ψn σα : p1 σα : p2 ... σα : pn σα : ϕ σ : ¬ψ1 σ : ψ2 ... σα : ψn σα : ¬p1 σα : p2 ... σα : pn σα : ϕ . . . σ : ¬ψ1 σ : ¬ψ2 ... σ : ¬ψn σα : ¬p1 σα : ¬p2 ... σα : ¬pn σα : ϕ\nwhere we assume that the domain of α is {p1, . . . , pn} and let α(pi) = ψi. In spite of the apparent complexity of this tableau rule, we believe that the complexity of the method is not affected in the star-free fragment. For the full language, we have to include a cut rule that ranges over all sub-formulas of the input formula ϕ0. The reason is to permit the equality test to work also with all formulas ψi that are included in the tableau when the new rule R[α] is applied. Again, we believe that the complexity remains the same.\nOther PDL Connectives. The integration of converse, complement, intersection and other PDL program connectives is also on our agenda. For instance, we believe that we can apply techniques similar to the ones in [13,6,1] for the converse. In this case though, it is not clear whether complexity (or even decidability) results remain the same. This is subject of future work."
    }, {
      "heading" : "A Rules in Numerator-Denominator Form",
      "text" : "For the comfort of the reader we present here the tableau rules in the more traditional numerator-denominator form."
    }, {
      "heading" : "B Proofs",
      "text" : "Lemma 3 (Consistency Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a consistent branch.\nProof. The proofs for the rules R¬, R∧ and R∨ are easy and left to the reader. For rule R[α], note that, because b is consistent, we have Vσ |= [α]ϕ. Then Vσα |= ϕ by the truth condition for [α]. Moreover, by the definition of updates we have:\n– Vσα |= p for all p ∈ dom(α) such that α(p) = ⊤, and\n– Vσα |= ¬p for all p ∈ dom(α) such that α(p) = ⊥.\nFor the remaining tableau rules, namely R〈α〉, R[;], R〈;〉, R[∪], and R〈∪〉, RP1 and RP2, the reasoning is similar and left to the reader. ⊓⊔\nTheorem 1 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0).\nProof. Assume that V |= ϕ0. Then the initial tableau for (V, ϕ0) is consistent. It follows from Lemma 3 that all tableaux for ϕ0 have at least one consistent branch b. Now, towards a contradiction, assume that b is closed. Then b contains both 〈σ, ψ〉 and 〈σ,¬ψ〉, for some σ and ψ. However, since b is consistent, Vσ |= ψ and Vσ |= ¬ψ, which is a contradiction. Therefore, b is not closed neither is the tableau containing it. ⊓⊔\nTheorem 2 (Completeness). If there is no closed tableau for (V, ϕ0) then V |= ϕ0.\nProof. Suppose there is no closed tableau for (V, ϕ0). Let b be an open and saturated branch of a tableau for (V, ϕ0). We prove that, for every pair 〈σ, ψ〉 ∈ b, we have Vσ |= ψ. The proof is done by induction on len(σ) + len(ψ) and, in particular, establishes that V |= ϕ0, since 〈(), ϕ0〉 ∈ b.\nInduction base: We consider two cases:\n– Let σ = () and ψ = p ∈ P. Then V |= p, otherwise b would be closed since b0 ⊆ b. – Let σ = () and ψ = ¬p. Then V |= ¬p, otherwise b would be closed since b0 ⊆ b.\nInduction Hypothesis: For every 〈σ, ψ〉 ∈ b, if len(σ) + len(ψ) ≤ n, then Vσ |= ψ.\nInduction step: Let len(σ)+ len(ψ) = n+1. We only give some of all possible cases:\n– Let σ = σ1α and ψ = p ∈ P. We consider two sub-cases: • Let p < dom(α). We have 〈σ1,¬p〉 < b, otherwise b would be closed, because\nit is saturated under RP2. Then we have 〈σ1, p〉 ∈ b, because the branch is saturated under RP1 and b0 ⊆ b. By induction hypothesis, we have Vσ1 |= p. Since p < dom(α), we also have Vσ1α |= p. • Let p ∈ dom(α). We then must have α(p) = ⊤: otherwise b would not only contain 〈σ1α, p〉, but also 〈σ1α,¬p〉 (by the application of rule R[α]) and b would therefore be closed. Hence, by the definition of updates p ∈ Vσ1α. The latter means that Vσ1α |= p. – Let σ = σ1α and ψ = ¬p. Again, we consider two sub-cases: • Let p < dom(α). We have 〈σ1, p〉 < b: otherwise, b would be closed, since\nit is saturated under RP1. Then we have 〈σ1,¬p〉 ∈ b, because the branch is saturated under RP2 and b0 ∈ b. Then p < Vσ1 (by the induction hypothesis) and thus p < Vσ1α. Then Vσ1α |= ¬p. • Let p ∈ dom(α). Note that we have α(p) = ⊥: otherwise b would be closed, because it would contain 〈σ1α, p〉 and 〈σ1α,¬p〉, since it is saturated under R[α]. Then p < Vσ1α (by its definition) Then Vσ1α |= ¬p. – Let ψ = ¬¬ψ1. If 〈σ,¬¬ψ1〉 ∈ b then 〈σ, ψ1〉 ∈ b (because b is saturated under R¬). By Induction Hypothesis we have Vσ |= ψ1. Therefore Vσ |= ¬¬ψ1 by the truth condition for negation.\n– Let ψ = ψ1 ∧ψ2. If 〈σ, ψ1 ∧ψ2〉 ∈ b then 〈σ, ψ1〉, 〈σ, ψ2〉 ∈ b (because b is saturated under R∧). By Induction Hypothesis we have Vσ |= ψ1 and Vσ |= ψ2. Therefore Vσ |= ψ1 ∧ ψ2 by the truth condition for conjunction. – Let ψ = ¬(ψ1 ∧ ψ2). If 〈σ,¬(ψ1 ∧ ψ2)〉 ∈ b then 〈σ,¬ψ1〉 ∈ b or 〈σ,¬ψ2〉 ∈ b (because b is saturated under R∨). By Induction Hypothesis we have Vσ |= ¬ψ1 or Vσ |= ¬ψ2. Therefore Vσ |= ¬(ψ1 ∧ ψ2) by the truth conditions for negation and conjunction. – Let ψ = [α]ψ1. If 〈σ, [α]ψ1〉 ∈ b then 〈σα, ψ1〉 ∈ b (because b is saturated under R[α]). Then, Vσα |= ψ1 (by Induction Hypothesis, because len(σ) + len(α) + len(ψ1) < len(σ)+len([α]ψ1) = len(σ)+1+len(α)+len(ψ1)). Therefore, Vσ |= [α]ψ1 (by definition). – Let ψ = [ψ1?]ψ2. If 〈σ, [ψ1?]ψ2〉 ∈ b then, because b is saturated under rule R[?], we consider two sub-cases. Either (1) 〈σ,¬ψ1〉 ∈ b or (2) 〈σ, ψ2〉 ∈ b. In both subcases, we have Vσ |= ψ1 implies Vσ |= ψ2 (by Induction Hypothesis). Therefore, Vσ |= [ψ2?]ψ2 (by definition). – Let ψ = [π1; π2]ψ1. If 〈σ, [π1; π2]ψ1〉 ∈ b then 〈σ, [π1][π2]ψ2〉 ∈ b (because b is saturated under rule R[;]). Then it is easy to see that 〈σσ1, [π2]ψ1〉 ∈ b, for all execution traces σ1 ∈ exe(π1) Then Vσσ1 |= [π2]ψ1 (by Induction Hypothesis, since len(σ) + len(σ1) + 1 + len(π2) + len(ψ1) = len(σσ1) + len([π2]ψ1) < len(σ) + len([π1; π2]ψ1) = len(σ)+ 1+ len(π1)+ 1+ len(π2)+ len(ψ1)). The latter means that Vσ |= [π1; π2]ψ1. – Let ψ = [π1∪π2]ψ1. If 〈σ, [π1∪π2]ψ1〉 ∈ b then 〈σ, [π1]ψ1〉, 〈σ, [π2]ψ1〉 ∈ b (because b is saturated under rule R[∪]). Then, Vσ |= [π1]ψ1 and Vσ |= [π2]ψ1 (by Induction Hypothesis). Therefore, Vσ |= [π1 ∪ π2]ψ1 (by definition). – The cases where ψ = ¬[π]ψ1 are analogous to the last ones. ⊓⊔\nTheorem 3 (Termination). The algorithm in Table 7 halts for every input (V, ϕ0).\nProof. It is enough to show that function mcTableau is eventually called with an argument b which is either a closed or a saturated branch. Assume that, during the execution, branch b is passed as argument to a call of function mcTableau. Assume that b contains a witness λ to one of the tableau rules. Then the function will be called recursively with a new branch b1 wherein λ is marked ‘non-applicable’, so it will never be a witness again. Moreover, b1 differs from b by some additional labelled formulas that are shorter than λ. Therefore, by an easy induction on the length of labelled formulas, we show that function mcTableau will eventually generate a branch b1 which is either closed or saturated. The details are omitted. ⊓⊔\nTheorem 4 (Complexity). The amount of memory used by the algorithm in Table 7 is a polynomial function of the length of the input (V, ϕ0).\nProof. Each call of function mcTableau generates a new tableau branch. This branch remains in memory during the recursive calls and is released once the present call of the function finishes its execution returning true or false. Therefore, to prove our claim, it is enough to show that the amount of memory used by each tableau branch is a polynomial function of len(ϕ0) and that the number of successive recursive calls to mcTableau is a polynomial function of len(ϕ0) as well.\nFirst, we observe that the initial branch b0 contains only formulas from cl+(ϕ0). Second, each time mcTableau is called with branch b as argument, all the labelled formulas in b have the same label. Since the amount of memory used by a branch is bounded by the number of different labelled formulas it contains, it then follows from Lemma 1 that the number of different labelled formulas in b is bounded by 2 len(ϕ0).\nThird, the number of successive recursive calls during the local saturation of the tableau is bounded by the number of different labelled formulas a successor may contain. This number is 2 len(ϕ0), again by Lemma 1. Now, recall that the list of successors created by the algorithm during successive recursive calls of mcTableau corresponds to one execution trace from input formula ϕ0. The length of each execution trace is bounded by len(ϕ0), by Lemma 2. Then the number of successive recursive calls that create new successors is bounded by len(ϕ0). Finally, the total number of successive recursive calls to mcTableau is bounded by 2 len(ϕ0)2.\nWe then conclude that the amount of memory used by the algorithm is proportional to 4 len(ϕ0)3. ⊓⊔\nLemma 4 (Satisfiability Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a consistent branch.\nProof. For the rules that are already part of in the method for star-free DL-PA the proof is the same as in the proof of Lemma 3. For the other cases, we have:\n– Rule R[∗]: If Vσ |= [π∗]ϕ then, by Proposition 1, Vσ |= ϕ and Vσ |= [π][π∗]ϕ. – Rule R〈∗〉: If Vσ |= ¬[π∗]ϕ then Vσ 6|= [π∗]ϕ, and the latter is the case iff Vσ |= ¬ϕ\nor Vσ |= ¬[π][π∗]ϕ, again due to Proposition 1. ⊓⊔\nTheorem 5 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0).\nProof. Assume that V |= ϕ0. Then, the initial tableau for (V, ϕ0) is consistent. It follows from Lemma 4 that all tableaux for (V, ϕ0) have at least one consistent branch b. Now, towards a contradiction, assume that b is closed. Then, either (1) b contains both 〈σ, ϕ〉 and 〈σ,¬ϕ〉, for some σ and ϕ; or (2) b is saturated and contains an unfulfilled eventuality 〈σ,¬[π∗]ϕ〉. In the first case, (because b is consistent) Vσ |= ϕ and Vσ |= ¬ϕ, which is a contradiction. In the second case, (again because b is consistent) Vσ |= ¬[π∗]ϕ. Moreover, b contains 〈σσ′, ϕ〉, for all execution traces σ′ ∈ exe(π∗), by the saturation of R〈∗〉 and because the eventuality is not fulfilled. Then, Vσσ ′\n|= ϕ, for all execution traces σ′ ∈ exe(π∗) (because the branch is consistent). Then, Vσ |= [πn]ϕ, for all n ≥ 0. The latter implies Vσ |= [π∗]ϕ, which contradicts the hypothesis. So b is not closed, and therefore the tableau containing b cannot be closed. ⊓⊔\nTheorem 6 (Completeness). If there is no closed tableau for (V, ϕ0) then V |= ϕ0.\nProof. The proof is essentially the same as for Theorem 2. We only add the induction step case for the Kleene star operator here:\n- Let ψ = [π∗]ψ1. If 〈σ, [π∗]ψ1〉 ∈ b then 〈σσ′, ψ1〉 ∈ b, for all execution traces σ′ ∈ exe(π∗) (because b is saturated, in particular, under rule R[∗]). Then, Vσσ ′\n|= ψ, for all execution traces σ′ ∈ exe(π∗) (by Induction Hypothesis), iff Vσ |= [πn]ψ, for all n ∈ N0, iff Vσ |= [π∗]ψ.\nFor the case where ψ = ¬[π∗]ψ we use the fact that the branch b is not closed, which means that the eventuality is fulfilled in b, by definition. ⊓⊔\nTheorem 7 (Termination). The algorithm in Table 9 halts for every input (V, ϕ0).\nProof. It is enough to show that the algorithm eventually generates a tableau such that all its branches are either closed or saturated. The algorithm has two parts: local saturation and successor creation.\nFirst, assume that the latest generated tableau T contains an open and unsaturated branch b with a witness λ to one of the tableau rules of the local saturation part. Then the algorithm updates T by marking λ as ‘non-applicable’, so it will never be a witness again. Moreover, the new branches of the updated tableau T differ from the old ones by somme additional labelled formulas that are either shorter than λ or (in the case of rules R[∗] and R〈∗〉) that can no longer be witnesses to these rules any more. Therefore, by an easy induction on the length of labelled formulas, we show that the algorithm will eventually generate a tableau such that all its branches are either closed or saturated for these rules. The details are omitted.\nSecond, assume that the latest generated tableau T contains an open and unsaturated branch b with a witness λ to one of the tableau rules R[α] and R〈α〉. Then it marks λ as ‘non-applicable’ and the updated T contains new branches with somme additional labelled formulas 〈σ, ψ〉, where σ is a new label and ψ ∈ cl+(ϕ0). Since cl+(ϕ0) is finite, there cannot be an infinite number of different labelled formulas whose labels different from another label of the tableau. Thus, the equality test will eventually succeeds and new successors won’t be created indefinitely. ⊓⊔\nTheorem 8 (Complexity). The amount of time used by the algorithm in Table 9 is an exponential function of the length of the input (V, ϕ0).\nProof. The amount of time used by the algorithm in Table 9 is bounded by the number of rule applications during the execution and the time spent on the equality tests.\nFirst, for each successor, the local saturation part performs at most 2 len(ϕ0) rule applications, because it is the maximum size of cl+(ϕ0) (by Lemma 1). Second, there can be at most 22 len(ϕ0) different labels in the entire tableau T , because it is the maximum size of P(cl+(ϕ0)). Then the successor creation part can generate at most 22 len(ϕ0) different labels until the equality test succeeds. Moreover, the equality test itself takes time proportional to 22 len(ϕ0), by the same reasons.\nOverall, the amount of time used by the algorithm is bounded by 2 len(ϕ0)×22 len(ϕ0)× 22 len(ϕ0) equals to 24 len(ϕ0)+1 len(ϕ0), which is an exponential function of the length of the input formula ϕ0. ⊓⊔"
    } ],
    "references" : [ {
      "title" : "An on-the-fly tableau-based decision procedure for PDL-satisfiability",
      "author" : [ "Pietro Abate", "Rajeev Goré", "Florian Widmann" ],
      "venue" : "Electr. Notes Theor. Comput. Sci.,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2009
    }, {
      "title" : "Dynamic logic of propositional assignments: a well-behaved variant of PDL",
      "author" : [ "Philippe Balbiani", "Andreas Herzig", "Nicolas Troquard" ],
      "venue" : "In Orna Kupferman, editor, Logic in Computer Science (LICS),",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2013
    }, {
      "title" : "Combining deduction and model checking into tableaux and algorithms for converse-PDL",
      "author" : [ "Giuseppe De Giacomo", "Fabio Massacci" ],
      "venue" : "Information and Computation,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2000
    }, {
      "title" : "A dynamic logic framework for abstract argumentation",
      "author" : [ "Sylvie Doutre", "Andreas Herzig", "Laurent Perrussel" ],
      "venue" : "Proc. KR",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2014
    }, {
      "title" : "Propositional dynamic logic of regular programs",
      "author" : [ "Michael J. Fischer", "Richard E. Ladner" ],
      "venue" : "J. Comput. Syst. Sci.,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1979
    }, {
      "title" : "Optimal and cut-free tableaux for propositional dynamic logic with converse",
      "author" : [ "Rajeev Goré", "Florian Widmann" ],
      "venue" : "In Automated Reasoning,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2010
    }, {
      "title" : "Belief change operations: a short history of nearly everything, told in dynamic logic of propositional assignments",
      "author" : [ "Andreas Herzig" ],
      "venue" : "In Chitta Baral and Giuseppe De Giacomo,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2014
    }, {
      "title" : "A dynamic logic of normative systems",
      "author" : [ "Andreas Herzig", "Emiliano Lorini", "Frédéric Moisan", "Nicolas Troquard" ],
      "venue" : "editor, International Joint Conference on Artificial Intelligence (IJCAI), Barcelona,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2011
    }, {
      "title" : "Belief merging in Dynamic Logic of Propositional Assignments",
      "author" : [ "Andreas Herzig", "Pilar Pozos Parra", "François Schwarzentruber" ],
      "venue" : "editors, International Symposium on Foundations of Information and Knowledge Systems (FoIKS) (FolKS), Bordeaux. Springer,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2014
    }, {
      "title" : "A comparison of solvers for propositional dynamic logic",
      "author" : [ "Ullrich Hustadt", "Renate A. Schmidt" ],
      "venue" : "EPiC Series,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Dynamic Logic of Propositional Assignments, abbreviated DL-PA, has recently been studied in [10,2] as an interesting alternative to Propositional Dynamic Logic (PDL) [7].",
      "startOffset" : 92,
      "endOffset" : 98
    }, {
      "referenceID" : 1,
      "context" : "Dynamic Logic of Propositional Assignments, abbreviated DL-PA, has recently been studied in [10,2] as an interesting alternative to Propositional Dynamic Logic (PDL) [7].",
      "startOffset" : 92,
      "endOffset" : 98
    }, {
      "referenceID" : 7,
      "context" : "In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 8,
      "context" : "In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4].",
      "startOffset" : 158,
      "endOffset" : 162
    }, {
      "referenceID" : 6,
      "context" : "In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4].",
      "startOffset" : 194,
      "endOffset" : 197
    }, {
      "referenceID" : 3,
      "context" : "In a series of papers, it was shown that DL-PA is a useful tool to analyse various kinds of dynamic systems, such as normative systems [10], fusion operators [11], update and revision operators [9], or the evolution of argumentation frameworks [4].",
      "startOffset" : 244,
      "endOffset" : 247
    }, {
      "referenceID" : 4,
      "context" : "This is almost the same as the Fisher-Ladner closure [5], which is used to show decidability and complexity results for PDL.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "4 We note that the original language in [2] is slightly more restrictive: α only assigns a single propositional variable.",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 7,
      "context" : "Proposition 1 ([10]).",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 1,
      "context" : "In [2], it is also shown that the Kleene star can be eliminated in DL-PA, i.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "Satisfiability checking in DL-PA is shown to be in EXPTIME in [2].",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 1,
      "context" : "Proposition 2 ([2]).",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 1,
      "context" : "Proposition 4 ([2]).",
      "startOffset" : 15,
      "endOffset" : 18
    }, {
      "referenceID" : 7,
      "context" : "This is an optimal algorithm, given that the satisfiability problem in star-free DL-PA is PSPACE-complete [10].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 7,
      "context" : "This is as expected, given that the model checking problem in full DL-PA is in EXPTIME [10].",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 2,
      "context" : "For instance, De Giacomo and Massacci [3] (see also [12]) inspired the technique for the Kleene star.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 9,
      "context" : "For instance, De Giacomo and Massacci [3] (see also [12]) inspired the technique for the Kleene star.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 5,
      "context" : "For instance, we believe that we can apply techniques similar to the ones in [13,6,1] for the converse.",
      "startOffset" : 77,
      "endOffset" : 85
    }, {
      "referenceID" : 0,
      "context" : "For instance, we believe that we can apply techniques similar to the ones in [13,6,1] for the converse.",
      "startOffset" : 77,
      "endOffset" : 85
    } ],
    "year" : 2014,
    "abstractText" : "The Dynamic Logic for Propositional Assignments (DL-PA) has recently been studied as an alternative to Propositional Dynamic Logic (PDL). In DL-PA, the abstract atomic programs of PDL are replaced by assignments of propositional variables to truth values. This makes DL-PA enjoy some interesting meta-logical properties that PDL does not, such as eliminability of the Kleene star, compactness and interpolation. We define and analytic tableaux calculus for DL-PA and show that it matches the known complexity results.",
    "creator" : "LaTeX with hyperref package"
  }
}