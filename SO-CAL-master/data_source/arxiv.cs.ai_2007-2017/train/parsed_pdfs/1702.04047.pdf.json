{
  "name" : "1702.04047.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Constraint Answer Set Solver EZCSP and Why Integration Schemas Matter",
    "authors" : [ "MARCELLO BALDUCCINI", "YULIYA LIERLER" ],
    "emails" : [ "marcello.balduccini@gmail.com)", "ylierler@unomaha.edu)" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Knowledge representation and automated reasoning are areas of Artificial Intelligence dedicated to understanding and automating various aspects of reasoning. Such traditionally separate fields of AI as answer set programming (ASP) (Niemelä, 1999; Marek and Truszczyński, 1999; Brewka et al., 2011), propositional satisfiability (SAT) (Gomes et al., 2008), constraint (logic) programming (CSP/CLP) (Rossi et al., 2008; Jaffar and Maher, 1994) are all representatives of distinct directions of research in automated reasoning. The algorithmic techniques developed in subfields of automated reasoning are often suitable for distinct reasoning tasks. For example, ASP proved to be an effective tool for formaliz-\nar X\niv :1\n70 2.\n04 04\n7v 2\n[ cs\ning elaborate planning tasks, whereas CSP/CLP is efficient in solving difficult scheduling problems. However, when solving complex practical problems, such as scheduling problems involving elements of planning or defeasible statements, methods that go beyond traditional ASP and CSP are sometimes desirable. By allowing one to leverage specialized algorithms for solving different parts of the problem at hand, these methods may yield better performance than the traditional ones. Additionally, by allowing the use of constructs that more closely fit each sub-problem, they may yield solutions that conform better to the knowledge representation principles of flexibility, modularity, and elaboration tolerance. This has led, in recent years, to the development of a plethora of hybrid approaches that combine algorithms and systems from different AI subfields. Constraint logic programming (Jaffar and Maher, 1994), satisfiability modulo theories (SMT) (Nieuwenhuis et al., 2006), HEX-programs (Eiter et al., 2005), and VI-programs (Calimeri et al., 2007) are all examples of this current. Various projects have focused on the intersection of ASP and CSP/CLP, which resulted in the development of a new field of study, often called constraint answer set programming (CASP) (Elkabani et al., 2004; Mellarkod et al., 2008; Gebser et al., 2009; Balduccini, 2009; Drescher and Walsh, 2011; Lierler, 2014).\nConstraint answer set programming allows one to combine the best of two different automated reasoning worlds: (1) the non-monotonic modeling capabilities and SAT-like solving technology of ASP and (2) constraint processing techniques for effective reasoning over non-Boolean constructs. This new area has already demonstrated promising results, including the development of CASP solvers ACSOLVER (Mellarkod et al., 2008), CLINGCON (Gebser et al., 2009), EZCSP (Balduccini, 2009), IDP (Wittocx et al., 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al., 2011), MINGO (Liu et al., 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016). CASP opens new horizons for declarative programming applications. For instance, research by Balduccini (2011) on the design of CASP language EZCSP and on the corresponding solver, which is nowadays one of the mainstream representatives of CASP systems, yielded an elegant, declarative solution to a complex industrial scheduling problem.\nUnfortunately, achieving the level of integration of CASP languages and systems requires nontrivial expertise in multiple areas, such as SAT, ASP and CSP. The crucial message transpiring from the developments in the CASP research area is the need for standardized techniques to integrate computational methods spanning these multiple research areas. We argue for undertaking an effort to mitigate the difficulties of designing hybrid reasoning systems by identifying general principles for their development and studying the implications of various design choices. Our work constitutes a step in this direction. Specifically, the main contributions of our work are:\n1. The paper provides the first comprehensive account of the constraint answer set solver EZCSP (Balduccini, 2009), a long-time representative of the CASP subfield. We define the language of EZCSP and illustrate its use on several examples. We also account for algorithmic and implementation details behind EZCSP.\n2. To present the EZCSP algorithm and prove formal claims about the system, we develop an extension of the transition systems proposed by Nieuwenhuis et al. (2006) for capturing SAT/SMT algorithms. This extension is well-suited for formalizing the behavior of the EZCSP solver.\n3. We also conduct a case study exploring a crucial aspect in building hybrid systems – the integration schemas of participating solving methods. This allows us to shed light on the costs and benefits of this key design choice in hybrid systems. For the case study, we use EZCSP as a research tool and study its performance with three integration schemas: “black-box”, “grey-box”, and “clear-box”. One of the main conclusions of the study is that there is no single choice of integration schema that achieves best performance in all cases. As such, the choice of integration schema should be made as easily configurable as it is the choice of particular branching heuristics in SAT or ASP solvers. The work on analytical and architectural aspects described in this paper shows how this can be achieved.\nWe begin this paper with a review of the ASP and CASP formalisms. In Section 3 we present the EZCSP language. In Section 4 we provide a broader context to our study by drawing a parallel between CASP and SMT solving. Then we review the integration schemas used in the design of hybrid solvers focusing on the schemas implemented in EZCSP. Section 5 provides a comprehensive account of algorithmic aspects of EZCSP. Section 6 introduces the details of the “integration schema” case study. In particular, it provides details on the application domains considered, namely, Weighted Sequence, Incremental Scheduling, and Reverse Folding. The section also discusses the variants of the encodings we compared. Experimental results and their analysis form Section 7. Section 8 provides a brief overview of CASP solvers. The conclusions are stated in Section 9.\nParts of this paper have been earlier presented at ASPOCP 2009 (Balduccini, 2009) and at PADL 2012 (Balduccini and Lierler, 2012)."
    }, {
      "heading" : "2 Preliminaries",
      "text" : ""
    }, {
      "heading" : "2.1 Regular Programs",
      "text" : "A regular (logic) program is a finite set of rules of the form\na0 ← a1, . . . , al ,not al+1, . . . ,not am ,not not am+1, . . . ,not not an , (1)\nwhere a0 is ⊥ (false) or an atom, and each ai (1 ≤ i ≤ n) is an atom so that ai 6= aj (1 ≤ i < j ≤ l ), ai 6= aj (l + 1 ≤ i < j ≤ m), and ai 6= aj (m + 1 ≤ i < j ≤ n). This is a special case of programs with nested expressions (Lifschitz et al., 1999). The expression a0 is the head of a rule (1). If a0 = ⊥, we often omit ⊥ from the notation. We call such rules denials. We call the right hand side of the arrow in (1) the body. If a body of a rule is empty, we call such rule a fact and omit the ← symbol. We also ignore the order of the elements in the rule. For example, rule a ← b, c is considered identical to a ← c, b. If B denotes the body of (1), we write Bpos for the elements occurring in the positive part of the body, i.e., Bpos = {a1, . . . , al}. We frequently identify the body of (1) with the conjunction of its elements (in which not not is dropped and not is replaced with the classical negation connective ¬):\na1 ∧ . . . ∧ al ∧ ¬al+1 ∧ . . . ∧ ¬am ∧ am+1 ∧ . . . ∧ an · (2)\nSimilarly, we often interpret a rule (1) as a clause\na0 ∨ ¬a1 ∨ . . . ∨ ¬al ∨ al+1 ∨ . . . ∨ am ∨ ¬am+1 ∨ . . . ∨ ¬an (3)\nIn the case when a0 = ⊥ in (1), a0 is absent in (3). Given a program Π, we write Πcl for the set of clauses of the form (3) corresponding to the rules in Π.\nAnswer sets An alphabet is a set of atoms. The semantics of logic programs relies on the notion of answer sets, which are sets of atoms. A literal is an atom a or its negation ¬a . We say that a set M of literals is complete over alphabet σ if, for any atom a in σ, either a ∈ M or ¬a ∈ M . It is easy to see how a set X of atoms over some alphabet σ can be identified with a complete and consistent set of literals over σ (an interpretation):\n{a | a ∈ X } ∪ {¬a | a ∈ σ \\X }·\nWe now restate the definition of an answer set due to Lifschitz et al. (1999) in a form convenient for our purposes. By At(Π) we denote the set of all atoms that occur in Π. The reduct ΠX of a regular program Π with respect to set X of atoms over At(Π) is obtained from Π by deleting each rule (1) such that X does not satisfy its body (recall that we identify its body with (2)), and replacing each remaining rule (1) by a0 ← Bpos . A set X of atoms is an answer set of a regular program Π if it is subset minimal among the sets of atoms satisfying (ΠX )cl . For example, consider a program consisting of a single rule\na ← not not a·\nThis program has two answer sets: set ∅ and set {a}. Indeed, (Π∅)cl is an empty set of clauses so that ∅ is subset minimal among the sets of atoms that satisfies (Π∅)cl . On the other hand, (Π{a})cl consists of a single clause a . Set {a} is subset minimal among the sets of atoms that satisfies (Π{a})cl .\nA choice rule construct {a} ← B (Niemelä and Simons, 2000) of the LPARSE language can be seen as an abbreviation for a rule a ← not not a,B (Ferraris and Lifschitz, 2005). We adopt this abbreviation in the rest of the paper.\nExample 1 Consider the regular program\n{switch}· lightOn ← switch,not am· ← not lightOn· {am}·\n(4)\nIntuitively, the rules of the program state the following:\n• action switch is exogenous, • light is on only if an action switch occurs during the non-am hours, • it is impossible that light is not on (in other words, light must be on). • it is either the case that these are am hours or not,\nThis program’s only answer set is {switch, lightOn}.\nWe now state an important result that summarizes the effect of adding denials to a program. For a set M of literals, by M + we denote the set of positive literals in M . For instance, {a, c,¬b}+ = {a, c}.\nTheorem 1 (Proposition 2 from (Lifschitz et al., 1999)) For a program Π, a set Γ of denials, and a consistent and complete set M of literals over At(Π), M + is an answer set of Π ∪ Γ if and only if M + is an answer set of Π and M is a model of Γcl .\nUnfounded sets For a literal l , by l we denote its complement. For a conjunction (disjunction) B of literals, B stands for a disjunction (conjunction) of the complements of literals. For instance, a ∧ ¬b = ¬a ∨ b. We sometimes associate disjunctions and conjunctions of literals with the sets containing these literals. For example, conjunction ¬a ∧ b and disjunction ¬a∨b are associated with the set {¬a, b} of literals. By Bodies(Π, a) we denote the set of the bodies of all rules of program Π with the head a (including the empty body that can be seen as >).\nA set U of atoms occurring in a program Π is unfounded (Van Gelder et al., 1991; Lee, 2005) on a consistent set M of literals with respect to Π if for every a ∈ U and every B ∈ Bodies(Π, a), M ∩ B 6= ∅ or U ∩ Bpos 6= ∅. We say that a consistent and complete set M of literals over At(Π) is a model of Π if it is a model of Πcl .\nWe now state a result that can be seen as an alternative way to characterize answer sets of a program.\nTheorem 2 (Theorem on Unfounded Sets from (Lee, 2005)) For a program Π and a consistent and complete set M of literals over At(Π), M + is an answer set of Π if and only if M is a model of Π and M contains no non-empty subsets unfounded on M with respect to Π.\nTheorem 2 is essential in understanding key features of modern answer set solvers. It provides a description of properties of answer sets that are utilized by so called “propagators” of solvers. Section 5 relies on these properties."
    }, {
      "heading" : "2.2 Logic Programs with Constraint Atoms",
      "text" : "A constraint satisfaction problem (CSP) is defined as a triple 〈X ,D ,C 〉, where X is a set of variables, D is a domain – a (possibly infinite) set of values – and C is a set of constraints. Every constraint is a pair 〈t ,R〉, where t is an n-tuple of variables and R is an n-ary relation on D . When arithmetic constraints are considered, it is common to replace explicit representations of relations as collections of tuples by arithmetic expressions. For instance, for a domain of three values {1, 2, 3} and binary-relation R consisting of ordered pairs (1, 1), (2, 2), and (3, 3), we can abbreviate the constraint 〈x , y ,R〉 by the expression x = y . We follow this convention in the rest of the paper.\nAn evaluation of the variables is a function from the set of variables to the domain of values, ν : X → D . An evaluation ν satisfies a constraint 〈(x1, . . . , xn),R〉 if (v(x1), . . . , v(xn)) ∈ R. A solution is an evaluation that satisfies all constraints.\nFor a constraint c = 〈t ,R〉, where D is the domain of its variables and k is the arity of t , we call the constraint c = 〈t ,Dk \\R〉 the complement of c. Obviously, an evaluation of variables in t satisfies c if and only if it does not satisfy c.\nFor a set M of literals and alphabet B, by M|B we denote the set of literals over alphabet B in M . For example, {¬a, b, c}|{a,b} = {¬a, b}.\nA logic program with constraint atoms (CA program) is a quadruple\n〈Π, C, γ,D〉,\nwhere\n• C is an alphabet, • Π is a regular logic program such that (i) a0 6∈ C for every rule (1) in Π and (ii) C ⊆ At(Π), • γ is a function from C to constraints, and • D is a domain.\nWe refer to the elements of alphabet C as constraint atoms. We call all atoms occurring in Π but not in C regular. To distinguish constraint atoms from the constraints to which these atoms are mapped, we use bars to denote that an expression is a constraint atom. For instance, |x < 12| and |x ≥ 12| denote constraint atoms. Consider alphabet C1 that consists of these two constraint atoms and a function γ1 that maps atoms in C1 to constraints as follows: γ1(|x < 12|) maps to an inequality x < 12, whereas γ1(|x ≥ 12|) maps to an inequality x ≥ 12. Clearly, γ1(|x < 12|) maps into an inequality x ≥ 12; similarly γ1(|x ≥ 12|) maps into an inequality x < 12.\nExample 2 Here we present a sample CA program\nP1 = 〈Π1, C1, γ1,D1〉, (5)\nwhere D1 is a range of integers from 0 to 23 and Π1 is a regular program\n{switch}· lightOn ← switch,not am· ← not lightOn· {am}· ← not am, |x < 12|· ← am, |x ≥ 12|·\n(6)\nThe first four rules of Π1 follow the lines of (4). The last two rules intuitively state that\n• it is impossible that these are not am hours while variable x has a value less than 12, • it is impossible that these are am hours while variable x has a value greater or equal\nto 12.\nNote how x represents specific hours of a day. Also worth noting is the fact that x has a global scope. This is different from the traditional treatment of variables in CLP, Prolog, and ASP.\nLet P = 〈Π, C, γ,D〉 be a CA program. By VP we denote the set of variables occurring in the constraints {γ(c) | c ∈ C}. For instance, VP1 = {x}. By Π[C] we denote Π extended with choice rules {c} for each constraint atom c ∈ C. We call program Π[C] an asp-abstraction of P . For example, an asp-abstraction Π1[C1] of any CA program whose\nfirst two elements of its quadruple are Π1 and C1 consists of rules (6) and the following choice rules\n{|x < 12|} {|x ≥ 12|}·\nLet M be a consistent set of literals over At(Π). By KP,M we denote the following constraint satisfaction problem\n〈V, D , {γ(c)|c ∈ M|C , c ∈ C} ∪ {γ(c)|¬c ∈ M|C , c ∈ C}〉,\nwhere V is the set of variables occurring in the constraints of the last element of the triple above. We call this constraint satisfaction problem a csp-abstraction of P with respect to M . For instance, a csp-abstraction of P1 w.r.t. {|x ≥ 12|, ¬|x < 12|, lightOn}, or KP1,{|x≥12|, ¬|x<12|, lightOn}, is\n〈{x},D1, {x ≥ 12}〉· (7)\nIt is easy to see that VP consists of the variables that occur in a csp-abstractions of P w.r.t. any consistent sets of literals over At(Π).\nLet P = 〈Π, C, γ,D〉 be a CA program and M be a consistent and complete set of literals over At(Π). We say that M is an answer set of P if\n(a1) M + is an answer set of Π[C] and (a2) the constraint satisfaction problem KP,M has a solution.\nLet α be an evaluation from the set VP of variables to the set D of values. We say that a pair 〈M , α〉 is an extended answer set of P if M is an answer set of P and α is a solution to KP,M .\nExample 3 Consider sample CA program P1 = 〈Π1, C1, γ1,D1〉 given in (5). Consistent and complete set\nM1 = {switch, lightOn,¬am,¬|x < 12|, |x ≥ 12|}\nof literals over At(Π1) is such that M +1 is the answer set of Π1[C1]. The constraint satisfaction problem KP1,M1 is presented in (7). Pairs\n〈M1, x = 12〉\nand\n〈M1, x = 23〉 are two among twelve extended answer sets of program (5)."
    }, {
      "heading" : "2.3 CA Programs and Weak Answer Sets",
      "text" : "In the previous section we introduced CA programs that capture programs that a CASP solver such as CLINGCON processes. The EZCSP solver interprets similar programs slightly differently. To illustrate the difference we introduce the notion of a weak answer set for a CA program and discuss the differences with earlier definition.\nLet P = 〈Π, C, γ,D〉 be a CA program and X be a set of atoms over At(Π). We say that X is a weak answer set of P if\n(w1) X is an answer set of Π[C] and (w2) the constraint satisfaction problem\n〈VP , D , {γ(c)|c ∈ X|C}〉, (8)\nhas a solution.\nLet α be an evaluation from the set VP of variables to the set D of values. We say that a pair 〈X , α〉 is an extended weak answer set of P if X is an answer set of P and α is a solution to (8).\nThe key difference between the definition of an answer set and a weak answer set of a CA program lies in their conditions (a2) and (w2). (It is obvious that we can always identify a complete and consistent set of literals with the set of its atoms.) When constraint atoms occur only in denials there is a one-to-one correspondence between answer sets and weak answer sets of the CA programs. Yet, when constraint atoms appear in rules that are not denials, the non-weak semantics seems to provide a more viable option for interpreting CA programs. To illustrate the difference between the two semantics, consider simple CA program:\nnight ← |x < 6|· am ← |x < 12|·\nThis program has three answer sets and four weak answer sets that we present in the following table.\nAnswer Sets: Weak Answer Sets: {night , am, |x < 6|, |x < 12|} {night , am, |x < 6|, |x < 12|} {¬night , am,¬|x < 6|, |x < 12|} {am, |x < 12|} {¬night ,¬am,¬|x < 6|,¬|x < 12|} ∅\n{night , |x < 6|}\nNote how the last weak answer set listed yields an unexpected solution, as it suggests that it is currently night but not am hours.\nAdopting the concept of a weak answer set within the EZCSP system was driven by implementation choices and by the belief that such semantics allows for a more flexible integration of solvers. The fact that for programs, where constraint atoms appear in nondenials, this semantics may provide counterintuitive outcomes explains why the EZCSP language is restricted to CA programs whose constraint atoms appear only in denials. In contrast, systems that adopt non-weak semantics, such as CLINGCON, allow for the constraint atoms to occur in arbitrary rules."
    }, {
      "heading" : "3 The EZCSP Language",
      "text" : "The origins of the constraint answer set solver EZCSP and of its language go back to the development of an approach for integrating ASP and constraint programming, in which ASP is viewed as a specification language for constraint satisfaction problems (Balduccini, 2009). In this approach, (i) ASP programs are written in such a way that some of their rules, and corresponding atoms found in their answer sets, encode the desired constraint satisfaction problems; (ii) both the answer sets and the solutions to the constraint problems\nare computed with arbitrary off-the-shelf solvers. This is achieved by an architecture that treats the underlying solvers as black boxes and relies on translation procedures for linking the ASP solver to constraint solver. The translation procedures extract from an answer set of an ASP program the constraints that must be satisfied and translate them into a constraint problem in the input language of the corresponding constraint solver. At the core of the EZCSP specification language is relation required , which is used to define the atoms that encode the constraints of the constraint satisfaction problem.\nWe start this section by defining the notion of propositional ez-programs and introducing their semantics via a simple mapping into CA programs under weak answer set semantics. Then, we move to describing the full language available to CASP practitioners in the EZCSP system. The tight relation between ez-programs and CA programs makes the following evident: although the origins of EZCSP are rooted in providing a simple, yet effective framework for modeling constraint satisfaction problems, the EZCSP language developed into a full-fledged constraint answer set programming formalism. This also yields another interesting observation: constraint answer set programming can be seen as a declarative modeling framework utilizing constraint satisfaction solving technology. The MiniZinc language (Marriott et al., 2008) is another remarkable effort toward a declarative modeling framework supported by the constraint satisfaction technology. It goes beyond the scope of this paper comparing the expressiveness of the constraint answer set programming and MiniZinc.\nSyntax An ez-atom is an expression of the form\nrequired(β),\nwhere β is an atom. Given an alphabet C, the corresponding alphabet of ez-atoms CEZ is obtained in a straightforward way. For instance, from an alphabet C1 = {|x < 12|, |x ≥ 12|} we obtain CEZ1 = {required(|x < 12|), required(|x ≥ 12|)}.\nA (propositional) ez-program is a tuple\n〈E ,A, C, γ,D〉,\nwhere\n• A and C are alphabets so that A, C, CEZ do not share the elements, • E is a regular logic program so that At(E ) = A ∪ CEZ and atoms from CEZ only\noccur in the head of its rules, • γ is a function from C to constraints, and • D is a domain.\nSemantics We define the semantics of ez-programs via a mapping to CA programs under weak answer set semantics. Let E = 〈E ,A, C, γ,D〉 be an ez-program. By PE we denote the CA program\n〈Π, C, γ,D〉,\nwhere Π extends E by a denial\n← required(β), not β (9)\nfor every ez-atom required(β) occurring in E . For a set X of atoms over At(E ) ∪ C and an evaluation α from the set VPE of variables to the set D of values, we say that\n• X is an answer set of E if X is a weak answer set of PE ; • a pair 〈X , α〉 is an extended answer set of E if 〈M , α〉 is an extended weak answer\nset of PE .\nExample 4 We now illustrate the concept of an ez-program on our running example of the “light domain”. Let A1 denote the alphabet {switch, lightOn, am}. Let E1 be a collection of rules\n{switch}· lightOn ← switch,not am· ← not lightOn· {am}· required(|x ≥ 12|)← not am· required(|x < 12|)← am·\n(10)\nwhere Cez1 forms an alphabet of ez-atoms. Let E1 be an ez-program\n〈E1,A1, C1, γ1,D1〉· (11)\nThe first member of the quadruple PE is composed of the rules from (10) and of the denials\n← required(|x ≥ 12|), not |x ≥ 12|· ← required(|x < 12|), not |x < 12|· (12)\nEz-program E1 has one answer set\nN1 = {switch, lightOn, required(|x ≥ 12|), |x ≥ 12|)}\nPairs\n〈N1, x = 12〉 (13)\nand 〈N1, x = 23〉 are two among twelve extended answer sets of ez-program E1.\nAt the core of the EZCSP system is its solver algorithm (described in Section 5), which takes as an input a propositional ez-program and computes its answer sets. In order to allow for more compact specifications, the EZCSP system supports an extension of the language of propositional ez-programs, which we call EZ. The language is described by means of examples next. Its definition can be found in Appendix A. Also, the part of formalization of the Weighted Sequence domain presented in Section 6 illustrates the use of the so called reified constraints, which form an important modeling tool of the EZ language.\nExample 5\nIn the EZ language, the ez-program E1 introduced in Example 4 is specified as follows:\ncspdomain(fd)· cspvar(x , 0, 23)· {switch}· lightOn ← switch,not am· ← not lightOn· {am}· required(x ≥ 12)← not am· required(x < 12)← am·\nThe first rule specifies domain of possible csp-abstractions, which in this case is that of finite-domains. The second rule states that x is a variable over this domain ranging between 0 and 23. The rest of the program follows the lines of (10) almost verbatim.\nIt is easy to see that denial (9) poses the restriction on the form of the answer sets of ez-programs so that an atom of the form required(β) appears in an answer set if and only if an atom of the form β appears in it. Thus, when the EZCSP system computes answer sets for the EZ programs, it omits β atoms. For instance, for the program of this example EZCSP will output:\n{cspdomain(fd), cspvar(x , 0, 23), required(x ≥ 12), switch, lightOn, x = 12}\nto encode extended answer set (13).\nExample 6\nThe EZ language includes support for a number of commonly-used global constraints, such as all different and cumulative (more details in Appendix A). For example, a possible encoding of the classical “Send+More=Money” problem is:\ncspdomain(fd).\ncspvar(s, 0, 9). cspvar(e, 0, 9). . . . cspvar(y , 0, 9). required(s ∗ 1000 + e ∗ 100 + n ∗ 10 + d+ m ∗ 1000 + o ∗ 100 + r ∗ 10 + e = m ∗ 10000 + o ∗ 1000 + n ∗ 100 + e ∗ 10 + y). required(s 6= 0). required(m 6= 0). required(all different([s, e,n, d ,m, o, r , y ])).\nAs before, the first rule specifies the domain of possible csp-abstractions. The next set of rules specifies the variables and their ranges. The remaining rules state the main constraints of the problem. Of those, the final rule encodes an all different constraint, which informally requires all of the listed variables to have distinct values. The argument of the constraint is an extensional list of the variables of the CSP. An extensional list is a list that explicitly enumerates all of its elements.\nA simple renaming of the variables of the problem allows us to demonstrate the intensional specification of lists:\ncspdomain(fd).\ncspvar(v(s), 0, 9). cspvar(v(e), 0, 9). . . . cspvar(v(y), 0, 9). required(v(s) ∗ 1000 + v(e) ∗ 100 + v(n) ∗ 10 + v(d)+ v(m) ∗ 1000 + v(o) ∗ 100 + v(r) ∗ 10 + v(e) = v(m) ∗ 10000 + v(o) ∗ 1000 + v(n) ∗ 100 + v(e) ∗ 10 + v(y)). required(v(s) 6= 0). required(v(m) 6= 0). required(all different([v/1])).\nThe argument of the global constraint in the last rule is intensional list [v/1], which is a shorthand for the extensional list, [v(d), v(e), v(m), v(n), . . .], of all variables of the form v(·).\nExample 7 Consider a riddle:\nThere are either 2 or 3 brothers in the Smith family. There is a 3 year difference between one brother and the next (in order of age) for all pairs of brothers. The age of the eldest brother is twice the age of the youngest. The youngest is at least 6 years old.\nFigure 1 presents the EZ program that captures the riddle1. We refer to this program as P1. Note how this program contains non-constraint variables B , N , B1, B2, BE , and BY . As explained in Appendix A, the grounding process that occurs in the EZCSP system transforms these rules into propositional (ground) rules using the same approach commonly applied to ASP programs. For instance, the last rule of program P1 results in three ground rules\nrequired(age(1) ≥ 6)← index (1), youngest brother(1)· required(age(2) ≥ 6)← index (2), youngest brother(2)· required(age(3) ≥ 6)← index (3), youngest brother(3)·\nThe ez-program that corresponds to P1 has a unique extended answer set\n〈{num brothers(3), cspvar(age(1), 1, 80), . . . , cspvar(age(3), 1, 80), . . .}, {(age(1) = 12, age(2) = 9, age(3) = 6}〉·\nThe extended answer set states that there are 3 brothers, of age 12, 9, and 6 respectively."
    }, {
      "heading" : "4 Satisfiability Modulo Theories and its Integration Schemas",
      "text" : "We are now ready to draw a parallel between constraint answer set programming and satisfiability modulo theories. To do so, we first define the SMT problem by following the lines of (Nieuwenhuis et al., 2006, Section 3.1). A theory T is a set of closed first-order\n1 The reader may notice that the program features the use of arithmetic connectives both within terms and as full-fledged relations. Although, strictly speaking, separate connectives should be introduced for each type of usage, we abuse notation slightly and use context to distinguish between the two cases.\nformulas. A CNF formula F (a set of clauses) over a fixed finite set of ground (variablefree) first-order atoms is T -satisfiable if there exists an interpretation, in first-order sense, that satisfies every formula in set F ∪T . Otherwise, it is called T -unsatisfiable. Let M be a set of ground literals. We say that M is a T -model of F if\n(m1) M is a model of F and (m2) M , seen as a conjunction of its elements, is T -satisfiable.\nThe SMT problem for a theory T is the problem of determining, given a formula F , whether F has a T -model. It is easy to see that in the CASP problem, Π[C] in condition (a1) plays the role of F in (m1) in the SMT problem. At the same time, condition (a2) is similar to condition (m2).\nGiven this tight conceptual relation between the SMT and CASP formalisms, it is not surprising that solvers stemming from these different research areas share several design traits even though these areas have been developing to a large degree independently (CASP being a younger field). We now review major integration schemas/methods in SMT solvers by following (Nieuwenhuis et al., 2006, Section 3.2). During the review, we discuss how different CASP solvers account for one or another method. This discussion allows us to systematize design patterns of solvers present both in SMT and CASP so that their relation becomes clearer. Such a transparent view on architectures of solvers immediately translates findings in one area to the other. Thus, although the case study conducted as part of our research uses CASP technology only, we expect similar results to hold for SMT, and for the construction of hybrid automated reasoning methods in general. To the best of our\nknowledge there was no analogous effort – thorough evaluation of effect of integration schemas on performance of systems – in the SMT community.\nIn every approach discussed, a formula F is treated as a satisfiability formula, where each atom is considered as a propositional symbol, forgetting about the theory T . Such a view naturally invites an idea of lazy integration: the formula F is given to a SAT solver, if the solver determines that F is unsatisfiable then F has no T -model. Otherwise, a propositional model M of F found by the SAT solver is checked by a specialized T -solver, which determines whether M is T -satisfiable. If so, then it is also a T -model of F , otherwise M is used to build a clause C that precludes this assignment, i.e., M 6|= C while F ∪ C has a T -model if and only if F has a T -model. The SAT solver is invoked on an augmented formula F ∪C . This process is repeated until the procedure finds a T -model or returns unsatisfiable. Note how in this approach two automated reasoning systems – a SAT solver and a specialized T -solver – interleave: a SAT solver generates “candidate models” whereas a T -solver tests whether these models are in accordance with requirements specified by theory T . We find that it is convenient to introduce the following terminology for the future discussion: a base solver and a theory solver, where the base solver is responsible for generating candidate models and the theory solver is responsible for any additional testing required for stating whether a candidate model is indeed a solution. In this paper we refer to lazy evaluation as black-box to be consistent with the terminology often used in CASP.\nIt is easy to see how the black-box integration policy translates to the realm of CASP. Given a CA program P , an answer set solver serves the role of base solver by generating answer sets of the asp-abstraction of P (that are “candidate answer sets” for P) and then uses a CLP/CSP solver as a theory solver to verify whether condition (a2) is satisfied on these candidate answer sets. Originally, constraint answer set solver EZCSP embraced the black-box integration approach in its design.2 To solve a CASP problem via blackbox approach, EZCSP offers a user various options for base and theory solvers. Table 1 shows some of the currently available solvers. The variety of possible configurations of EZCSP illustrates how black-box integration provides great flexibility in choosing underlying base and theory solving technology in addressing problems of interest. In principle, this approach allows for a simple integration of constraint programming systems that use MiniZinc and FlatZinc3 as their front-end description languages. Implementing support for this interface is a topic of future research.\n2 (Balduccini, 2009) refers to black-box integration of EZCSP as lightweight integration of ASP and constraint programming. 3 http://www.minizinc.org/.\nThe Davis-Putnam-Logemann-Loveland (DPLL) procedure (Davis et al., 1962) is a backtracking-based search algorithm for deciding the satisfiability of a propositional CNF formula. DPLL-like procedures form the basis for most modern SAT solvers as well as answer set solvers. If a DPLL-like procedure underlies a base solver in the SMT and CASP tasks then it opens a door to several refinements of black-box integration. We now describe these refinements.\nIn the black-box integration approach a base solver is invoked iteratively. Consider the SMT task: a CNF formula Fi+1 of the i + 1th iteration to a SAT solver consists of a CNF formula Fi of the i th iteration and an additional clause (or a set of clauses). Modern DPLLlike solvers commonly implement such technique as incremental solving. For instance, incremental SAT-solving allows the user to solve several SAT problems F1, . . . ,Fn one after another (using a single invocation of the solver), if Fi+1 results from Fi by adding clauses. In turn, the solution to Fi+1 may benefit from the knowledge obtained during solving F1, . . . ,Fi . Various modern SAT-solvers, including MINISAT (Eén and Biere, 2005; Eén and Sörensson, 2003), implement interfaces for incremental SAT solving. Similarly, the answer set solver CMODELS implements an interface that allows the user to solve several ASP problems Π1, . . . ,Πn one after another, if Πi+1 results from Πi by adding a set of denials. It is natural to utilize incremental DPLL-like procedures for enhancing the black-box integration protocol: we call this refinement grey-box integration. In this approach, rather than invoking a base solver from scratch, an incremental interface provided by a solver is used to implement the iterative process. CASP solver EZCSP implements grey-box integration using the above mentioned incremental interface by CMODELS.\nNieuwenhuis et al. (2006) also review such integration techniques used in SMT as online SAT solver and theory propagation. We refer to on-line SAT solver integration as clearbox here. In this approach, the T -satisfiability of the “partial” assignment is checked, while the assignment is being built by the DPLL-like procedure. This can be done fully eagerly as soon as a change in the partial assignment occurs, or with a certain frequency, for instance at some regular intervals. Once the inconsistency is detected, the SAT solver is instructed to backtrack. The theory propagation approach extends the clear-box technique by allowing a theory solver not only to verify that a current partial assignment is “T -consistent“ but also to detect literals in a CNF formula that must hold given the current partial assignment.\nThe CASP solver CLINGCON exemplifies the implementation of the theory propagation integration schema in CASP. It utilizes answer set solver CLASP as the base solver and constraint processing system GECODE (Schulte and Stuckey, 2008) as the theory solver. The ACSOLVER and IDP systems are other CASP solvers that implement the theory propagation integration schema. In the scope of this work, the CASP solver EZCSP was extended to implement the clear-box integration schema using CMODELS. It is worth noting that all of the above approaches consider the theory solver as a black box, disregarding its internal structure and only accessing it through its external API. To the best of our knowledge, no systematic investigation exists of integration schemas that also take advantage of the internal structure of the theory solver.\nAn important point is due here. Some key details about the grey-box and clear-box integration schemas have been omitted in the presentation above for simplicity. To make these integration schemas perform efficiently, learning – a sophisticated solving technique stemming from SAT (Zhang et al., 2001) – is used to capture the information (explanation)\nretrieved due to necessity to backtrack upon theory solving. This information is used by the base solver to avoid similar conflicts. Section 5.2 presents the details on the integration schemas formally and points at the key role of learning."
    }, {
      "heading" : "5 The EZCSP Solver",
      "text" : "In this section, we describe an algorithm for computing answer sets of CA programs. A specialization of this algorithm to ez-programs is used in the EZCSP system. For this reason, we begin by giving an overview of the architecture of the EZCSP system. We then describe the solving algorithm.\n5.1 Architecture"
    }, {
      "heading" : "Pre-processor Grounder EZCSP Solver",
      "text" : "Figure 2 depicts the architecture of the system, while the narrative below elaborates on the essential details. Both are focused on the functioning of the EZCSP system while employing the black-box integration schema.\nThe first step of the execution of EZCSP (corresponding to the Pre-processor component in the figure) consists in running a pre-processor, which translates an input EZ program into a syntactically legal ASP program. This is accomplished by replacing the occurrences of arithmetic functions and operators in required(β) atoms by auxiliary function symbols. For example, an atom required(v > 2) is replaced by required(gt(v , 2)). A similar process is also applied to the notation for the specification of lists. For instance, an atom required(all different([x , y ])) is translated into required(all different(list(x , y))). The Grounder component of the architecture transforms the resulting program into its propositional equivalent, a regular program, using an off-the-shelf grounder such as GRINGO (Gebser et al., 2007). This regular program is then passed to the EZCSP Solver component.\nThe EZCSP Solver component iterates ASP and constraint programming computations by invoking the corresponding components of the architecture. Specifically, the ASP Solver component computes an answer set of the regular program using an off-the-shelf ASP solver, such as CMODELS or CLASP.4 If an answer set is found, the EZCSP solver runs the CLP Translator component, which maps the csp-abstraction corresponding to the computed answer set to a Prolog program. The program is then passed to the CP Solver component, which uses the CLP solver embedded in a Prolog interpreter, e.g. SICStus or BPROLOG,5 to solve the CSP instance. For example, for the sample program presented in Example 5, the EZCSP system produces the answer set6:\n{cspdomain(fd), cspvar(x , 0, 23), required(x ≥ 12), switch, lightOn}·\nThe csp-abstraction of the program with respect to this answer set is translated into a Prolog rule:\nsolve([x ,Vx ]) : − Vx ≥ 0, Vx ≤ 23, Vx ≥ 12, labeling([Vx ])·\nIn this case, the CLP solver embedded in the Prolog interpreter will find feasible assignments for variable Vx . The head of the rule is designed to return a complete solution and to ensure that the variable names used in the EZ program are associated with the corresponding values. The interested reader can refer to (Balduccini, 2009) for a complete description of the translation process.\nFinally, the EZCSP Solver component gathers the solutions to the respective cspabstraction and combines them with the answer set obtained earlier to form extended answer sets. Additional extended answer sets are computed iteratively by finding other answer sets and the solutions to the corresponding csp-abstractions."
    }, {
      "heading" : "5.2 Solving Algorithm",
      "text" : "We are now ready to present our algorithm for computing answer sets of CA programs. In earlier work, Lierler (2014) demonstrated how the CASP language CLINGCON (Gebser et al., 2009) as well as the essential subset of the CASP language AC of ACSOLVER (Mellarkod et al., 2008) are captured by CA programs. Based on those results, the algorithm described in this section can be immediately used as an alternative to the procedures implemented in systems CLINGCON and ACSOLVER.\nUsually, software systems are described by means of pseudocode. The fact that EZCSP system follows an “all-solvers-in-one” philosophy combined with a variety of integration schemas complicates the task of describing it in this way. For example, one configuration of EZCSP may invoke answer set solver CLASP via black-box integration for enumerating answer sets of an asp-abstraction of CA program, whereas another may invoke CMODELS via grey-box integration for the same task. Thus, rather than committing ourselves to a pseudocode description, we follow a path pioneered by Nieuwenhuis et al. (2006). In\n4 The ASP solver to be used can be specified by command-line options. 5 The Prolog interpreter is also selectable by command-line options. 6 For illustrative purposes, we show the EZ atom required(x ≥ 12) in place of the ASP atom obtained from\nthe pre-processing phase.\ntheir work, the authors devised a graph-based abstract framework for describing backtrack search procedures for Satisfiability and SMT. Lierler (2014) designed a similar abstract framework that captures the EZCSP algorithm in two cases: (a) when EZCSP invokes answer set solver SMODELS via black-box integration for enumerating answer sets of aspabstraction program, and (b) when EZCSP invokes answer set solver CLASP via black-box integration.\nIn the present paper we introduce a graph-based abstract framework that is well suited for capturing the similarities and differences of the various configurations of EZCSP stemming from different integration schemas. The graph-based representation also allows us to speak of termination and correctness of procedures supporting these configurations. In this framework, nodes of a graph representing a solver capture its possible “states of computation”, while edges describe the possible transitions from one state to another. It should be noted that the graph representation is too high-level to capture some specific features of answer set solvers or constraint programming tools used within different EZCSP configurations. For example, the graph incorporates no information on the heuristic used to select a literal upon which a decision needs to be made. This is not an issue, however: stand alone answer set solvers have been analyzed and compared theoretically in the literature (Anger et al., 2006), (Giunchiglia et al., 2008) (Lierler and Truszczyński, 2011) as well as empirically in biennial answer set programming competitions (Gebser et al., 2007), (Denecker et al., 2009), (Calimeri et al., 2011). At the same time, EZCSP treats constraint programming tools as “black-boxes” in all of its configurations.\n5.2.1 Abstract EZCSP\nBefore introducing the transition system (graph) capable of capturing a variety of EZCSP procedures, we start by developing some required terminology. To make this section more self-contained we also restate some notation and definitions from earlier sections. Recall that for a set M of literals, by M + we denote the set of positive literals in M . For a CA program P = 〈Π, C, γ,D〉, a consistent and complete set M of literals over At(Π) is an answer set of P if\n(a1) M + is an answer set of Π[C] and (a2) the constraint satisfaction problem KP,M has a solution.\nAs noted in Section 2.1 we can view denials as clauses. Given a denial G , by Gcl we will denote a clause that corresponds to G , e.g., (← not pm)cl denotes a clause pm . We may sometime abuse the notation and refer to a clause as if it were a denial. For instance, a clause pm may denote a denial← not pm .\nWe now introduce notions for CA programs that parallel ”entailment” for the case of classical logic formulas. Let P = 〈Π, C, γ,D〉 be a CA program. We say that P asp-entails a denial G overAt(Π) when for every complete and consistent set M of literals overAt(Π) such that M + is an answer set of Π[C], M satisfies Gcl . In other words, a denial is aspentailed if any set of literals that satisfies the condition (a1) of the answer set definition is such that it satisfies this denial. CA program P cp-entails a denial G over At(Π) when (i) for every answer set M of P , M satisfies Gcl and (ii) there is a complete and consistent set N of literals over At(Π) such that N + is an answer set of Π[C] and N does not satisfy G .\nNotice that if a denial G is such that a CA program P cp-entails G , then P does not aspentail G . We say that P entails a denial G when P either asp-entails or cp-entails G . For a consistent set N of literals over At(Π) and a literal l , we say that P asp-entails l with respect to N , if for every complete and consistent set M of literals over At(Π) such that M + is an answer set of Π[C] and N ⊆ M , l ∈ M .\nExample 8 Recall program P1 = 〈Π1, C1, γ1,D1〉 from Example 2. It is easy to check that denial ← not lightOn· (or, in other words clause lightOn) is asp-entailed by P1. Also, P1 aspentails literals switch and ¬am with respect to set {lightOn} (and also with respect to ∅).\nLet regular program Π2 extend program Π1 from Example 2 by rules\n{pm}· ← not pm, |x ≥ 12|· ← |x < 12|·\nConsider a CA program P2 that differs from P1 only by substituting its first member Π1 of quadruple 〈Π1, C1, γ1,D1〉 by Π2. Denial← not pm (or clause pm) is cp-entailed by P2. Indeed, the only answer set of this program is {pm,¬|x < 12|, |x ≥ 12|}. This set satisfies (← not pm)cl , in other words, clause pm . Consider set {¬pm,¬|x < 12|, |x ≥ 12|} that does not satisfy clause pm . Set of atoms {¬pm,¬|x < 12|, |x ≥ 12|}+ = {|x ≥ 12|} is an answer set of Π2[C1].\nFor a CA program P = 〈Π, C, γ,D〉 and a set Γ of denials, by P[Γ] we denote the CA program 〈Π∪Γ, C, γ,D〉. The following propositions capture important properties underlying the introduced entailment notions.\nProposition 1 For a CA program P = 〈Π, C, γ,D〉 and a set Γ of denials over At(Π) if P asp-entails every denial in Γ then (i) programs Π[C] and (Π∪Γ)[C] have the same answer sets; (ii) CA programs P and P[Γ] have the same answer sets."
    }, {
      "heading" : "Proof",
      "text" : "We first show that condition (i) holds. From Theorem 1 and the fact that P asp-entails every denial in Γ it follows that programs Π[C] and (Π ∪ Γ)[C] have the same answer sets. Condition (ii) follows from (i) and the fact that KP,M = KP[Γ],M for any answer set M of Π[C] (and, consequently, for (Π ∪ Γ)[C]).\nProposition 2 For a CA program P = 〈Π, C, γ,D〉 and a set Γ of denials over At(Π) if P cp-entails every denial in Γ then CA programs P and P[Γ] have the same answer sets."
    }, {
      "heading" : "Proof",
      "text" : "Let P be a CA program 〈Π, C, γ,D〉. It is easy to see that (a) Π[C] ∪ Γ = (Π ∪ Γ)[C] and (b) KP,M = KP[Γ],M .\nRight-to-left: Take M to be an answer set of P . By the definition of an answer set, (i) M + is an answer set of Π[C] and (ii) the constraint satisfaction problem KP,M has a solution. Since P cp-entails every denial in Γ, we conclude that M is a model of Γcl . By\nTheorem 1, M + is an answer set of Π[C] ∪ Γ. From (a) and (b) we derive that M is an answer set of P[Γ].\nLeft-to-right: Take M to be an answer set of P[Γ]. By the definition of an answer set, (i) M + is an answer set of (Π∪ Γ)[C] and (ii) the constraint satisfaction problem KP[Γ],M has a solution. From (i) and (a) it follows that M + is an answer set of Π[C] ∪ Γ. By Theorem 1, M + is an answer set of Π[C]. By (b) and (ii) we derive that, M is an answer set of P .\nProposition 3 For a CA program P = 〈Π, C, γ,D〉 and a set Γ of denials over At(Π) if P entails every denial in Γ then (i) every answer set of (Π ∪ Γ)[C] is also an answer set of Π[C]; (ii) CA programs P and P[Γ] have the same answer sets."
    }, {
      "heading" : "Proof",
      "text" : "Condition (i) follows from Theorem 1 and the fact that (Π)[C] and (Π ∪ Γ)[C] only differ in denials.\nWe now show that condition (ii) holds. Set Γ is composed of two disjoint sets Γ1 and Γ2 (i.e., Γ = Γ1 ∪ Γ2), where Γ1 is the set of all denials that are asp-entailed by P and Γ2 is the set of all denials that are cp-entailed by P . By Proposition 1 (ii), CA programs P and P[Γ1] have the same answer sets. By Proposition 2, CA programs P[Γ1] and P[Γ1 ∪ Γ2] have the same answer sets. It immediately follows that CA programs P and P[Γ1 ∪ Γ2] have the same answer sets.\nFor an alphabet σ, a record relative to σ is a sequence M composed of distinct literals over σ or symbol ⊥, some literals are possibly annotated by the symbol ∆, which marks them as decision literals such that:\n1. the set of literals in M is consistent or M = M ′l , where the set of literals in M ′ is consistent and contains l , 2. if M = M ′l∆M ′′, then neither l nor its dual l is in M ′, and 3. if ⊥ occurs in M , then M = M ′⊥ and M ′ does not contain ⊥.\nWe often identify records with the set of its members disregarding annotations. For a CA program P = 〈Π, C, γ,D〉, a state relative to P is either a distinguished state Failstate or a triple M ||Γ||Λ where M is a record relative to At(Π); Γ and Λ are each a set of denials that are entailed by P . Given a state M ||Γ||Λ if neither a literal l nor l occurs in M , then l is unassigned by the state; if ⊥ does not occur in M as well as for any atom a it is not the case that both a and ¬a occur in M , then this state is consistent. For a state M ||Γ||Λ, we call M , Γ, and Λ the atomic, permanent, and temporal parts of the state, respectively. The role of the atomic part of the state is to track decisions (choices) as well as inferences that the solver has made. The permanent and temporal parts are responsible for assisting the solver in accumulating additional information – entailed denials by a given program – that becomes apparent during the search process.\nWe now define a graph EZP for a CA program P . Its nodes are the states relative to P . These nodes intuitively correspond to states of computation. The edges of the graph EZP are specified by nine transition rules presented in Figure 3. These rules correspond to possible operations by the EZCSP system that bring it from one state of computation to another.\nA path in the graph EZP is a description of a process of search for an answer set of P . The process is captured via applications of transition rules. Theorem 3 introduced later in this section makes this statement precise.\nExample 9 Recall CA program P1 = 〈Π1, C1, γ1,D1〉 introduced in Example 2. Figure 4 presents a\nsample path in EZP1 with every edge annotated by the name of a transition rule that justifies the presence of this edge in the graph.\nNow we turn our attention to an informal discussion of the role of each of the transition rules in EZP ."
    }, {
      "heading" : "5.2.2 Informal account on transition rules",
      "text" : "We refer to the transition rules Decide, Fail, Backtrack, ASP-Propagate, CP-Propagate of the graph EZP as basic.\nThe unique feature of basic rules is that they only concern the atomic part of a state. Consider a state S = M ||Γ||Λ. An application of any basic rule results in a state whose permanent and temporal parts remain unchanged, i.e., Γ and Λ respectively (unless it is the case of Fail).\nDecide An application of the transition rule Decide to S results in a state whose atomic part has the form M l∆. Intuitively this rule allows us to pursue evaluation of assignments that assume value of literal l to be true. The fact that this literal is marked by ∆ suggests that we can still reevaluate this assumption in the future, in other words to backtrack on this decision.\nFail The transition rule Fail specifies the conditions on atomic part M of state S suggesting that Failstate is reachable from M . Intuitively, if our computation brought us to such a state transition to Failstate confirms that there is no solution to the problem.\nBacktrack The transition rule Backtrack specifies the conditions on atomic part of the state suggesting when it is time to backtrack and what the new atomic part of the state is after backtracking. Rules Fail and Backtrack share one property: they are applicable only when states are inconsistent.\nASP-Propagate The transition rule ASP-Propagate specifies the condition under which a new literal l (without a decision annotation) is added to an atomic part. Such rules are commonly called propagators. Note that the condition of ASP-Propagate\nP[Γ ∪ Λ] asp-entails l with respect to M (14)\nis defined over a program extended by permanent and temporal part. This fact illustrates the role of these entities. They carry extra information aquired/learnt during the computation. Also condition (14) is semantic. It refers to the notion of asp-entailment, which is defined by a reference to the semantics of a program. Propagators used by software systems typically use syntactic conditions, which are easy to check by inspecting syntactic properties of a program. Later in this section we present instances of such propagators, in particular, propagators that are used within the EZCSP solver.\nCP-Propagate The transition rule CP-Propagate specifies the condition under which symbol ⊥ is added to an atomic part. Thus it leads to a state that is inconsistent suggesting that\nthe search process is either ready to fail or to backtrack. The condition of CP-Propagate\nKP,M has no solution\nrepresents a decision procedure that establishes whether the CSP problem KP,M has solutions or not.\nWe now turn our attention to non-basic rules that concern permanent and temporal parts of the states of computation.\nLearn Recall the definition of the transition rule Learn"
    }, {
      "heading" : "M ||Γ||Λ ⇒ M ||Γ ∪ {R}||Λ if P[Γ ∪ Λ] entails denial R and R 6∈ Γ ∪ Λ",
      "text" : "An application of this rule to a state M ||Γ||Λ, results in a state whose atomic and temporal parts stay unchanged. The permanent part is extended by a denial R. Intuitively the effect of this rule is such that from this point of computation the “permanent” denial becomes effectively a part of the program being solved. This is essential for two reasons. First, if the learnt denial R is cp-entailed then Π ∪ Γ ∪ Λ and Π ∪ Γ ∪ Λ ∪ {R} are programs with different answer sets. In turn, the rule ASP-Propagate may be applicable to some state N ||Γ ∪ {R}||Λ and not to N ||Γ||Λ. Similarly, due to the fact that only “syntactic” instances of ASP-Propagate are implemented in solvers, the previous statement also holds for the case when R is asp-entailed.\nLearnt The role of the transition rule Learnt is similar to that of Learn, but the learnt denials by this rule are not meant to be preserved permanently in the computation.\nRestart and Restartt The transition rule Restart allows the computation to start from “scratch” with respect to atomic part of the state. The transition rule Restartt forces the computation to start from “scratch” with respect to not only atomic part of the state but also all temporally learnt denials. These restart rules are essential in understanding the key differences between various integration strategies that are of focus in this paper.\n5.2.3 Formal properties of EZP\nWe call the state ∅||∅||∅— initial. We say that a node in the graph is semi-terminal if no rule other than Learn, Learnt , Restart, Restartt is applicable to it (or, in other words, if no single basic rule is applicable to it). We say that a path in EZP is restart-safe when, prior to any edge e due to an application of Restart or Restartt on this path, there is an edge e ′ due to an application of Learn such that: (i) edge e ′ precedes e; (ii) e ′ does not precede any other edge e ′′ 6= e due to Restart or Restartt . We say that a restart-safe path t is maximal if (i) the first state in t is an initial state, and (ii) t is not a subpath of any restart-safe path t ′ 6= t .\nExample 10 Recall CA program P1 = 〈Π1, C1, γ1,D1〉 introduced in Example 2. Trivially a sample\npath in EZP1 in Figure 4 is a restart-safe path. A nontrivial example of restart-safe path in EZP1 follows\n∅||∅||∅ Learn⇒\n∅||{← not switch}||∅ ASP-Propagate ⇒\nlightOn||{← not switch}||∅ Restart⇒\n∅||{← not switch}||∅·\n(15)\nSimilarly, a path that extends the path above as follows\nLearn⇒\n∅||{← not switch, ← am}||∅ ASP-Propagate ⇒\nlightOn||{← not switch, ← am}||∅ Restart⇒\n∅||{← not switch, ← am}||∅\nis restart-safe. A simple path in EZP1 that is not restart-safe\n∅||∅||∅ ASP-Propagate ⇒ lightOn||∅||∅ Restart⇒ ∅||∅||∅·\nIndeed, condition (i) of the restart-safe definition does not hold. Another example of a not restart-safe path is a path that extends path (15) as follows\nASP-Propagate ⇒\nlightOn||{← not switch}||∅ Restart⇒\n∅||{← not switch}||∅·\nIndeed, condition (ii) of the restart-safe definition does not hold for the second occurrence of the Restart edge.\nThe following theorem captures key properties of the graph EZP . They suggest that the graph can be used for deciding whether a program with constraint atoms has an answer set.\nTheorem 3 For any CA program P:\n(a) every restart-safe path in EZP is finite, and any maximal restart-safe path ends with a state that is semi-terminal,\n(b) for any semi-terminal state M ||Γ||Λ of EZP reachable from initial state, M is an answer set of P , (c) state Failstate is reachable from initial state in EZP by a restart-safe path if and only if P has no answer set.\nOn the one hand, part (a) of Theorem 3 asserts that, if we construct a restart-safe path from initial state, then some semi-terminal state is eventually reached. On the other hand, parts (b) and (c) assert that, as soon as a semi-terminal state is reached by following any restart-safe path, the problem of deciding whether CA programP has answer sets is solved. Section 5.3 describes the varying configurations of the EZCSP system.\nExample 11 Recall Example 9. Since the last state in the sample path presented in Figure (4) is semiterminal, Theorem 3 asserts that the set of literals composed of the elements of this semiterminal state forms the answer set of CA program P1. Indeed, this set coincides with the answer set M1 of P1 presented in Example 3.\nIn our discussion of the transition rule ASP-Propagate we mentioned how the EZCSP solver accounts only for some transitions due to this rule. Let P = 〈Π, C, γ,D〉 be a CA program. By EZSMP we denote an edge-induced subgraph of EZP , where we drop the edges that correspond to the application of transition rules ASP-Propagate not accounted by the following two transition rules (propagators) Unit Propagate and Unfounded:\nUnit Propagate: M ||Γ||Λ ⇒ M l ||Γ||Λ  C ∨ l ∈ (Π[C] ∪ Γ ∪ Λ)cl , M is consistent, M |= C\nUnfounded: M ||Γ||Λ ⇒ M l ||Γ||Λ  M is consistent, and there is literal l so that l ∈ U for a set U , which is unfounded on M w.r.t. Π[C] ∪ Γ ∪ Λ\nThese two propagators rely on properties that can be checked by efficient procedures. The conditions of these transition rules are such that they are satisfied only if P[Γ ∪ Λ] aspentails l w.r.t. M . In other words, the transition rules Unit Propagate or Unfounded are applicable only in states where ASP-Propagate is applicable. The other direction is not true. Theorem 3 holds if we replace EZP by EZSMP in its statement. The proof of this theorem relies on the statement of Theorem 2, and is given at the end of this subsection. Graph EZSMP is only one of the possible subgraphs of the generic graph EZP that share its key properties stated in Theorem 3. These properties show that graph EZSMP gives rise to a class of correct algorithms for computing answer sets of programs with constraints. It provides a proof of correctness of every CASP solver in this class and a proof of termination under the assumption that restart-safe paths are considered by a solver. Note how much weaker propagators, such as Unit Propagate and Unfounded, than ASP-Propagate are sufficient to ensure the correctness of respective solving procedures. We picked the graph EZSMP for illustration as it captures the essential propagators present in modern (constraint) answer set solvers and allows a more concrete view on the EZP framework. Yet the goal of this work is not to detail the variety of possible propagators of (constraint)\nanswer set solvers but master the understanding of hybrid procedures that include this technology. Therefore in the rest of this section we turn our attention back to the EZP graph and use this graph to formulate black-box, grey-box, and clear-box configurations of the CASP solver EZCSP.\nThe rest of this subsection presents a proof of Theorem 3 as well as a proof of the similar theorem for the graph EZSMP ."
    }, {
      "heading" : "Proof of Theorem 3",
      "text" : "(a) Let P be a CA program 〈Π, C, γ,D〉.\nWe first show that any path in EZP that does not contain Restartt or Restart edges is finite. We name this statement Statement 1.\nConsider any path t in EZP that does not contain Restartt or Restart edges. For any list N of literals, by |N | we denote the length of N . Any state M ||Γ||Λ has the form M0 l∆1 M1 . . . l ∆ p Mp ||Γ||Λ, where l∆1 . . . l∆p are all decision literals of M ; we define α(M ||Γ||Λ) as the sequence of nonnegative integers |M0|, |M1|, . . . , |Mp |, and α(Failstate) =∞. For any two states, S and S ′, of EZP , we understand α(S ) < α(S ′) as the lexicographical order. We note that, for any state M ||Γ||Λ, the value of α is based only on the first component, M , of the state. Second, there is a finite number of distinct values of α for the states of EZP due to the fact that there is a finite number of distinct M ’s over P . We now define relation smaller over the states of EZP . We say that state M ||Γ||Λ is smaller than state M ′||Γ′||Λ′ when either\n1. Γ ⊂ Γ′, or 2. Γ = Γ′, and Λ ⊂ Λ′, or 3. Γ = Γ′, Λ = Λ′, and α(M ||Γ||Λ) < α(M ′||Γ′||Λ′).\nIt is easy to see that this relation is anti-symmetric and transitive. By the definition of the transition rules of EZP , if there is an edge from M ||Γ||Λ to M ′||Γ′||Λ′ in EZP formed by any basic transition rule or rules Learn or Learnt , then M ||Γ||Λ is smaller than state M ′||Γ′||Λ′. Observe that (i) there is a finite number of distinct values of α, and (ii) there is a finite number of distinct denials entailed by P . Then, it follows that there is only a finite number of edges in t , and, thus, Statement 1 holds.\nWe call a subpath from state S to state S ′ of some path in EZP restarting when (i) an edge that follows S is due to the application of rule Learn, (ii) an edge leading to S ′ is due to the application of rule Restartt or Restart, and (iii) on this subpath, there are no other edges due to applications of Learn, Restartt , or Restart, but the ones mentioned above. Using Statement 1, it follows that any restarting subpath is finite.\nConsider any restart-safe path r in EZP . We construct a path r ′ by dropping some finite fragments from r . This is accomplished by replacing each restarting subpath of r from state S to state S ′ by an edge from S to S ′ that we call Artificial. It is easy to see that an edge in r ′ due to Artificial leads from a state of the form M ||Γ||Λ to a state ∅||Γ ∪ {C}||Λ′, where C is a denial. Indeed, within a restarting subpath an edge due to rule Learn occurred introducing denial C . State M ||Γ||Λ is smaller than the state ∅||Γ ∪ {C}||Λ′. At the same time, r ′ contains no edges due to applications of Restartt or Restart. Indeed, we eliminated these edges in favor of edges called Artificial. Thus by the same argument as in the proof of Statement 1, r ′ contains a finite number of edges. We can now conclude that r is finite.\nIt is easy to see that maximal restart-safe path ends with a state that is semi-terminal. Indeed, assume the opposite: there is a maximal restart-safe path t , which ends in a non semi-terminal state S . Then, some basic rule applies to state S . Consider path t ′ consisting of path t and a transition due to a basic rule applicable to S . Note that t ′ is also a restart-safe path, and that t is a subpath of t ′. This contradicts the definition of maximal.\n(b) Let M ||Γ||Λ be a semi-terminal state so that none of the Basic rules are applicable. From the fact that Decide is not applicable, we conclude that M assigns all literals or M is inconsistent.\nWe now show that M is consistent. Proof by contradiction. Assume that M is inconsistent. Then, since Fail is not applicable, M contains a decision literal. Consequently, M ||Γ||Λ is a state in which Backtrack is applicable. This contradicts our assumption that M ||Γ||Λ is semi-terminal.\nAlso, M + is an answer set of Π[C]. Proof by contradiction. Assume that M + is not an answer set of Π[C]. It follows that that M is not an answer set of P . By Proposition 3, it follows that M is not an answer set of P[Γ∪Λ] and M + is not an answer of Π[C]∪Γ∪Λ. Recall that P[Γ ∪ Λ] asp-entails a literal l with respect to M if for every complete and consistent set M ′ of literals over At(Π) such that M ′+ is an answer set of Π[C] ∪ Γ ∪ Λ and M ⊆ M ′, l ∈ M ′. Since M is complete and consistent set of literals over At(Π) it follows that there is no complete and consistent set M ′ of literals over At(Π) such that M ⊆ M ′ and M ′+ is an answer set of Π[C] ∪ Γ ∪ Λ. We conclude that P[Γ ∪ Λ] aspentails any literal l . Take l to be a complement of some literal occurring in M . It follows that ASP-Propagate is applicable in state M ||Γ||Λ allowing a transition to state M l ||Γ||Λ. This contradicts our assumption that M ||Γ||Λ is semi-terminal.\nCSP KP,M has a solution. This immediately follows from the application condition of the transition rule CP-Propagate and the fact that the state M ||Γ||Λ is semi-terminal.\nFrom the conclusions that M + is an answer set of Π[C] and KP,M has a solution we derive that M is an answer set of P .\n(c) We start by proving an auxiliary statement:\nStatement 2: For any CA program P , and a path from an initial state to l1 . . . ln ||Γ||Λ in EZP , every answer set X for P satisfies li if it satisfies all decision literals l∆j with j ≤ i . By induction on the length of a path. Since the property trivially holds in the initial state, we only need to prove that all transition rules of EZP preserve it.\nConsider an edge M ||Γ||Λ ⇒ S where S is either a fail state or state of the form M ′||Γ′||Λ′, M is a sequence l1 . . . lk such that every answer set X of P satisfies li if it satisfies all decision literals l∆j with j ≤ i .\nDecide, Fail, CP-Propagate Learn, Learnt , Restart, Restartt : Obvious. ASP-Propagate: M ′||Γ′||Λ′ is M lk+1||Γ||Λ. Take any answer set X of P such that X satisfies all decision literals l∆j with j ≤ k + 1. From the inductive hypothesis it follows that X satisfies M . Consequently, M ⊆ X since X is a consistent and complete set of literals. From the definition of ASP-Propagate, P asp-entails lk+1 with respect to M . We also know that X + is an answer set of Π[C]. Thus, lk+1 ∈ X .\nBacktrack: M has the form P l∆i Q where Q contains no decision literals. M ′||Γ′||Λ′ has the form P li ||Γ||Λ. Take any answer set X of P such that X satisfies all decision literals l∆j with j ≤ i . We need to show that X |= li . By contradiction. Assume that\nX |= li . By the inductive hypothesis, since Q does not contain decision literals, it follows that X satisfies P l∆i Q , that is, M . This is impossible because M is inconsistent. Hence, X |= li .\nLeft-to-right: Since Failstate is reachable from the initial state by a restart-safe path, there is an inconsistent state M ||Γ||Λ without decision literals such that there exists a path from the initial state to M ||Γ||Λ. By Statement 2, any answer set ofP satisfies M . Since M is inconsistent we conclude that P has no answer sets.\nRight-to-left: From (a) it follows that any maximal restart-safe path is a path from initial state to some semi-terminal state S . By (b), this state S cannot be different from Failstate, because P has no answer sets.\nTheorem 4 For any CA program P ,\n(a) every restart-safe path in EZSMP is finite, and any maximal restart-safe path ends with a state that is semi-terminal, (b) for any semi-terminal state M ||Γ||Λ of EZSMP reachable from initial state, M is an answer set of P , (c) state Failstate is reachable from initial state in EZSMP by a restart-safe path if and only if P has no answer sets."
    }, {
      "heading" : "Proof",
      "text" : "Let P be a CA program 〈Π, C, γ,D〉.\n(a) This part is proved as part (a) in proof of Theorem 3.\n(b) Let M ||Γ||Λ be a semi-terminal state so that none of the basic rules are applicable (Unit Propagate and Unfounded are basic rules). As in proof of part (b) in Theorem 3 we conclude that M assigns all literals and is consistent. Also, CSP KP,M has a solution.\nWe now illustrate that, M + is an answer set of Π[C]. Proof by contradiction. Assume that M + is not an answer set of Π[C]. It follows that that M is not an answer set of P . By Proposition 3, it follows that M is not an answer set of P[Γ∪Λ] and M + is not an answer of Π[C] ∪ Γ ∪ Λ. By Theorem 2, it follows that either M is not a model of Π[C] ∪ Γ ∪ Λ or M contains a non-empty subset unfounded on M w.r.t. Π[C]∪Γ∪Λ. In case the former holds we derive that the rule Unit Propagate is applicable in the state M ||Γ||Λ. In case the later holds we derive that the rule Unfounded is applicable in the state M ||Γ||Λ. This contradicts our assumption that M ||Γ||Λ is semi-terminal.\nFrom the conclusions that M + is an answer set of Π[C] and KP,M has a solution we derive that M is an answer set of P . (c) Left-to-right part of the proof follows from Theorem 3 (c, left-to-right) and the fact that EZSMP is a subgraph of EZP .\nRight-to-left part of the proof follow the lines of Theorem 3 (c, right-to-left).\n5.3 Integration Configurations of EZCSP\nWe can characterize the algorithm of a specific solver that utilizes the transition rules of the graph EZP by describing a strategy for choosing a path in this graph.\nblack-box: A configuration of EZCSP that invokes an answer set solver via black-box integration for enumerating answer sets of an asp-abstraction program is captured by the following strategy in navigating the graph EZP\n1. Restart never applies, 2. rule CP-Propagate never applies to the states where one of these rules are applicable:\nDecide, Backtrack, Fail, ASP-Propagate, 3. Learnt may apply anytime with the restriction that the denial R learnt by the appli-\ncation of this rule is such that P asp-entails R, 4. single application of Learn follows immediately after an application of the rule\nCP-Propagate. Furthermore, the denial R learnt by the application of this rule is such that P cp-entails R, 5. Restartt follows immediately after an application of the rule Learn. Restartt does not apply under any other condition.\nIt is easy to see that the specifications of the strategy above forms a subgraph of the graph EZP . Let us denote this subgraph by EZbP . Theorem 3 holds if we replace EZP by EZbP in its statement:\nTheorem 5 For any CA program P ,\n(a) every restart-safe path in EZbP is finite, and any maximal restart-safe path ends with a state that is semi-terminal, (b) for any semi-terminal state M ||Γ||Λ of EZbP reachable from initial state, M is an answer set of P , (c) state Failstate is reachable from initial state in EZbP by a restart-safe path if and only if P has no answer sets."
    }, {
      "heading" : "Proof",
      "text" : "Let P be a CA program 〈Π, C, γ,D〉. (a) This part is proved as part (a) in proof of Theorem 3.\n(b) Graph EZbP is the subgraph of EZP . At the same time it is easy to see that any non semiterminal state in EZP is also a non semi-terminal state in EZbP . Thus, claim (b) follows from Theorem 3 (b).\n(c) Left-to-right part of the proof follows from Theorem 3 (c, left-to-right) and the fact that EZbP is a subgraph of EZP .\nRight-to-left part of the proof follows the lines of Theorem 3 (c, right-to-left).\ngrey-box: A configuration of EZCSP that invokes an answer set solver via grey-box integration for enumerating answer sets of asp-abstraction program is captured by the strategy in navigating the graph EZP that differs from the strategy of black-box in rules 1 and 5 only. Below we present only these rules.\n1. Restartt never applies, 5. Restart follows immediately after an application of the rule Learn. Restart does not\napply under any other condition.\nclear-box: A configuration of EZCSP that invokes an answer set solver via clear-box integration for enumerating answer sets of asp-abstraction program is captured by the following strategy in navigating the graph EZP\n• Restartt and Restart never apply.\nSimilar to the black-box case, the specifications of the grey-box and clear-box strategies form subgraphs of the graph EZP . Theorem 3 holds if we replace EZP by these subgraphs. We avoid stating formal proofs as they follow the lines of proof for Theorem 5.\nWe note that the outlined strategies provide only a skeleton of the algorithms implemented in these systems. Generally, any particular configurations of EZCSP can be captured by some subgraph of EZP . The provided specifications of black-box, grey-box, and clearbox scenarios allow more freedom than specific configurations of EZCSP do. For example, in any setting of EZCSP it will never follow an edge due to the transition Decide when the transition ASP-Propagate is available. Indeed, this is a design choice of all available answer set solvers that EZCSP is based upon. The provided skeleton is meant to highlight the essence of key differences between the variants of integration approaches. For instance, it is apparent that any application of Restartt forces us to restart the search process by forgetting about atomic part of a current state as well as some previously learnt clauses. The black-box integration architecture is the only one allowing this transition.\nAs discussed earlier, the schematic rule ASP-Propagate is more informative than any real propagator implemented in any answer set solver. These solvers are only able to identify some literals that are asp-entailed by a program with respect to a state. Thus if a program is extended with additional denials a specific propagator may find additional literals that are asp-entailed. This observation is important in understanding the benefit that Restart provides in comparison to Restartt . Note that applications of these rules highlight the difference between black-box and grey-box."
    }, {
      "heading" : "6 Application Domains",
      "text" : "In this work we compare and contrast different integration schemas of hybrid solvers on three application domains that stem from various subareas of computer science: weightedsequence (Lierler et al., 2012), incremental scheduling (Balduccini, 2011), reverse folding. The weighted-sequence domain is a handcrafted benchmark, whose key features are inspired by the important industrial problem of finding an optimal join order by cost-based query optimizers in database systems. The problem is not only practically relevant but proved to be hard for current ASP and CASP technology as illustrated in (Lierler et al., 2012). The incremental scheduling domain stems from a problem occurring in commercial printing. CASP offers an elegant solution to it. The reverse folding problem is inspired by VLSI design – the process of creating an integrated circuit by combining thousands of transistors into a single chip.\nThis section provides a brief overview of these applications. All benchmark domains are from the Third Answer Set Programming Competition – 2011 (ASPCOMP) (Calimeri et al., 2011), in particular, the Model and Solve track. We chose these domains for our investigation for several reasons. First, these problems touch on applications relevant to various industries. Thus, studying different possibilities to model and solve these problems is of\nvalue. Second, each one of them displays features that benefit from the synergy of computational methods in ASP and CSP. Each considered problem contains variables ranging over a large integer domain thus making grounding required in pure ASP a bottleneck. Yet, the modeling capabilities of ASP and availability of such sophisticated solving techniques such as learning makes ASP attractive for designing solutions to these domains. As a result, CASP languages and solvers become a natural choice for these benchmarks making them ideal for our investigation.\nThree Kinds of CASP Encodings: Hybrid languages such as CASP combine constructs and processing techniques stemming from different formalisms. As a result, depending on how the encodings are crafted, one underlying solver may be used more heavily than the other. For example, any ASP encoding of a problem is also a CASP formalization of it. Therefore, the computation for such encoding relies entirely on the base solver and the features and performance of the theory solver are irrelevant to it. We call this a pure-ASP encoding. At the other end of the spectrum are pure-CSP encodings: encodings that consist entirely of ez-atoms. From a computational perspective, such an encoding exercises only the theory solver. (From a specification perspective, the use of CASP is still meaningful, as it allows for a convenient, declarative, and at the same time executable specification of the constraints.) In the middle of the spectrum are true-CASP encodings, which, typically, are non-stratified and include collections of ez-atoms expressing constraints whose solution is non-trivial.\nAn analysis of these varying kinds of encodings in CASP gives us a better perspective on how different integration schemas are affected by the design choices made during the encoding of a problem. At the same time considering the encoding variety allows us to verify our intuition that true-CASP is an appropriate modeling and solving choice for the explored domains. We conducted experiments on encodings falling in each category for all benchmarks considered.\nThe weighted-sequence (WSEQ) domain is a handcrafted benchmark problem. Its key features are inspired by the important industrial problem of finding an optimal join order by cost-based query optimizers in database systems. Lierler et al. (2012) provides a complete description of the problem itself as well as the formalization named SEQ++ that became the encoding used in the present paper.\nIn the weighted-sequence problem we are given a set of leaves (nodes) and an integer m – maximum cost. Each leaf is a pair (weight, cardinality) where weight and cardinality are integers. Every sequence (permutation) of leaves is such that all leaves but the first are assigned a color that, in turn, associates a leaf with a cost (via a cost formula). A colored sequence is associated with the cost that is a sum of leaves costs. The task is to find a colored sequence with cost at most m . We refer the reader to (Lierler et al., 2012) for the details of pure-ASP encoding SEQ++. The same paper also contains the details on a true-CASP variant of SEQ++ in the language of CLINGCON. We further adapted that encoding to the EZ language by means of simple syntactic transformations. Here we provide a review of details of the SEQ++ formalizations using pure-ASP and the EZ language that we find most relevant to this presentation. The reader can refer to Appendix A for details on the syntax used. The non-domain predicates of the pure-ASP encoding are leafPos, posColor , posCost . Intuitively, leafPos is responsible for assigning a position to a leaf, posColor\nis responsible for assigning a color to each position, posCost carries information on costs associated with each leaf. Some rules used to define these relations are given in Figure 5.\nThe first two rules in Figure 5 assign a distinct location to each leaf. The next rule is part of the color assignment. The following two rules are part of the cost determination. The final two rules ensure that the total cost is within the specified limit.\nThe main difference between the pure-ASP and true-CASP encodings is in the treatment of the cost values of the leaves. We first note that cost predicate posCost in the pure-ASP encoding is “functional”. In other words, when this predicate occurs in an answer set, its first argument uniquely determines its second argument. Often, such functional predicates in ASP encodings can be replaced by ez-atoms7 in CASP encodings. Indeed, this is the case in the weighted-sequence problem. Thus in the true-CASP encoding, the definition of posCost is replaced by suitable ez-atoms, making it possible to evaluate cost values by\n7 We abuse the term ez-atom and refer to “non-ground” atoms of the EZ language that result in ez-atoms by the same name.\nCSP techniques. This approach is expected to benefit performance especially when the cost values are large. Some of the corresponding rules follow:\n% posCost for first coloredPos required(posCost(1) = W )← posColor(1, green), leafPos(L, 1), leafWeightCardinality(L,WR,CR),W = WR + CR· required(posCost(1) = W )← not posColor(1, green),\nleafPos(L1, 0), leafPos(L2, 1),\nleafWeightCardinality(L1,WL,CL), leafCost(L2,WR), W = WL + WR·\n% Acceptable solutions required(sum([posCost/1],≤,MV ))← max total weight(MV )·\nThe first two rules are rather straightforward translations of the ASP equivalents. The last rule uses a global constraint to ensure acceptability of the total cost.\nThe pure-CSP encoding is obtained from the true-CASP encoding by replacing the definitions of leafPos and posColor predicates by constraint atoms. The replacement is based on the observation that leafPos and posColor are functional.\n% green if (weight(right) + card(right)) < (weight(left) + leafCost(right)) is green(1,L1,L2)← leafWeightCardinality(L1,WL,CL),\nleafWeightCardinality(L2,WR,CR),\nleafCost(L2,W 3),\nW 1 = WR + CR, W 2 = WL + W 3,\nW 1 < W 2· required(posColor(1) = green ← (leafPos(L1) = 0 ∧ leafPos(L2) = 1))←\nleaf (L1), leaf (L2), is green(1,L1,L2)·\nAs shown by the last rule, color assignment requires the use of reified constraints. It is important to note that symbol← within the scope of required stands for material implication. Color names are mapped to integers by introducing additional variables. For example, variable green is associated with value 1 by a variable declaration cspvar(green, 1, 1). Interestingly, no ez-atoms are needed for the definition of leafPos . The role of the choice rule above is implicitly played by the variable declaration\ncspvar(leafPos(L), 0,N − 1)← leaf (L), location(N )·\nThe incremental scheduling (IS) domain stems from a problem occurring in commercial printing. In this domain, a schedule is maintained up-to-date with respect to jobs being added and equipment going offline. A problem description includes a set of devices, each with predefined number of instances (slots for jobs), and a set of jobs to be produced. The penalty for a job being late is computed as td · imp, where td is the job’s tardiness and imp is a positive integer denoting the job’s importance. The total penalty of a schedule is the sum of the penalties of the jobs. The task is to find a schedule whose total penalty is no larger than the value specified in a problem instance. We direct the reader to (Balduccini, 2011) for more details on this domain. We start by describing the pure-CSP encoding and then illustrate how it relates to the true-CASP encoding.\nThe pure-CSP encoding used in our experiments is the official competition encoding submitted to ASPCOMP by the EZCSP team. In that encoding, constraint atoms are used for (i) assigning start times to jobs, (ii) selecting which device instance will perform a job, and (iii) calculating tardiness and penalties. Core rules of the encoding are shown in Figure 6.\nThe ez-atom of the first rule uses a global constraint to specify that the start times must be assigned in such a way as to ensure that no more than nd jobs are executed at any time, where nd is the number of instances of a given device d . The ez-atom of the second rule uses reified constraints with the ∨ connective (disjunction) to guarantee that at most one job is executed on a device instance at every time. The ez-atom of the third rule uses a global constraint to define total penalty. The last rule restricts total penalty to be within the allowed maximum value.\nThe true-CASP encoding was obtained from the pure-CSP encoding by introducing a new relation on instance(j , i), stating that job j runs on device-instance i . The rules formalizing the assignment of device instances in the pure-CSP encoding were replaced by ez-atoms. For example, the second rule from Figure 6 was replaced by:\n1{on instance(J , I ) : instance of (D , I )}1← job device(J ,D)·\nrequired((st(D , J 2) ≥ st(D , J 1) + Len1) ∨ (st(D , J 1) ≥ st(D , J 2) + Len2))←\non instance(J 1, I ), on instance(J 2, I ),\ninstances(D ,N ),N > 1, job device(J 1,D), job device(J 2,D), J 1 6= J 2, job len(J 1,Len1), job len(J 2,Len2)·\nThe main difference with respect to the ez-atom of the pure-CSP encoding is the introduction of a choice rule to select an instance I for a job J . The constraint that each instance processes at most one job at a time is still encoded using an ez-atom.\nFinally, the pure-ASP encoding was obtained from the true-CASP encoding by introducing suitable new relations, such as start(j , s) and penalty(j , p), to replace all remaining ez-atoms. The rules that replace the first rule in Figure 6 follow:\n1{start(J ,S ) : time(S )}1← job(J )·\n← on instance(J 1, I ), on instance(J 2, I ), J 1 6= J 2, job device(J 1,D), job device(J 2,D),\nstart(J 1,S1), job len(J 1,L1), start(J 2,S2), S1 ≤ S2,S2 < S1 + L1·\nThe last two rules in Figure 6 are replaced by the rules in the pure-ASP encoding:\ntot penalty(TP)← TP [ penalty(J ,P) = P ] TP · ← not [penalty(J ,P) = P ]Max ,max total penalty(Max )·\nIn the reverse folding (RF) domain, one manipulates a sequence of n pairwise connected segments located on a 2D plane in order to take the sequence from an initial configuration to a goal configuration. The sequence is manipulated by pivot moves: rotations of a segment around its starting point by 90 degree in either direction. A pivot move on a segment causes the segments that follow to rotate around the same center. Concurrent pivot moves are prohibited. At the end of each move, the segments in the sequence must not intersect. A problem instance specifies the number of segments, the goal configuration, and required number of moves denoted by t . The task is to find a sequence of exactly t pivot moves that produces the goal configuration.\nThe true-CASP encoding used for our experiments is from the official ASPCOMP 2011 submission package of the EZCSP team. In this encoding, relation pivot(s, i , d) states that at step s the i th segment is rotated in direction d . The effects of pivot moves are described by ez-atoms, which allows us to carry out the corresponding calculations with CSP techniques.\npivot(1, I ,D)← first(I ), requiredMove(I ,D)· pivot(N 1, I 1,D1)← pivot(N 2, I 2,D2),N 1 = N 2 + 1,\nrequiredMove(I 1,D1), requiredMove(I 2,D2), next(I 1, I 2)·\n% Effect of pivot(t,i,d) required(tfoldy(S2, I ) = tfoldx (S1,P)− tfoldx (S1, I ) + tfoldy(S1,P))←\nstep(S1), step(S2),S2 = S1 + 1,\npivot(S1,P , clock),\nindex (I ), I ≥ P · required(tfoldy(S2, I ) = tfoldx (S1, I )− tfoldx (S1,P) + tfoldy(S1,P))←\nstep(S1), step(S2),S2 = S1 + 1,\npivot(S1,P , anticlock), index (I ), I ≥ P ·\nThe first two rules are some of the rules used for determining the pivot rotations. The determination is based on the technique described in (Balduccini and Lierler, 2012). The\nlast two rules are part of the calculation of the effects of pivot moves. Note that tfoldx (s, i) and tfoldy(s, i) denote the x and y coordinates of the start of segment i at step s .\nThe pure-ASP encoding was obtained from the true-CASP encoding by adopting an ASP-based formalization of the effects of pivot moves. This was accomplished by introducing two new relations, tfoldx (s, i , x ) and tfoldy(s, i , y), stating that the new start of segment i at step s is 〈x , y〉. The definition of the relations is provided by suitable ASP rules, such as:\ntfoldy(S + 1, I ,Y 2)← tfoldx (S , I ,X 1), pivot(S ,P ,D), I ≥ P , tfoldx (S ,P ,XP), tfoldy(S ,P ,YP),X 0 = X 1−XP , rotatedx (D ,X 0,Y 0),Y 2 = Y 0 + YP · rotatedx (clock ,X ,−X )← xcoord(X )· xcoord(−2 ∗N · ·2 ∗N )← length(N )·\nDifferently from the previous domains, for RF we were unable to formulate a pure-CSP variant of the true-CASP encoding. Thus, we resorted to the encoding described in (Dovier et al., 2011). This encoding leverages a mapping from action language B (Gelfond and Lifschitz, 1998) statements to numerical constraints, which are then solved by a CLP system."
    }, {
      "heading" : "7 Experimental Results",
      "text" : "The experimental comparison of the integration schemas was conducted on a computer with an Intel Core i7 processor at 3GHz and running Fedora Core 16. The memory limit for each process and the timeout were set to 1 GB RAM8 and 6, 000 seconds respectively. A single processor core was used for every experiment.\n8 The instances that resulted in an out-of-memory were also tested with 4 GB RAM, with no change in the outcome.\nThe version of EZCSP used in the experiments was 1.6.20b49. This version implements the black-box, grey-box, and clear-box integration schemas, when suitable API interfaces are available in the base solver. One answer set solver that provides such interfaces is CMODELS, which for this reason was chosen as base solver for the experiments. It is worth noting that the development of the API in CMODELS was greatly facilitated by the API provided by MINISAT v. 1.12b supporting non-clausal constraints (Eén and Sörensson, 2003) (MINISAT forms the main inference mechanism of CMODELS). In the experiments, we used CMODELS version 3.83 as the base solver and BPROLOG 7.4 as the theory solver.9 Answer set solver CMODELS 3.83 (with the inference mechanism of MINISAT v. 1.12b) was also used for the experiments with the pure-ASP encodings. Unless otherwise specified, for all solvers we used their default configurations.\nThe executables used in the experiments and the encodings can be downloaded, respectively, from\n• http://www.mbal.tk/ezcsp/int_schemas/ezcsp-binaries.tgz, and • http://www.mbal.tk/ezcsp/int_schemas/experiments.tgz.\nIn order to provide a frame of reference with respect to the state of the art in CASP, the results also include performance information for CLINGCON 2.0.3 on the true-CASP encodings adapted to the language of CLINGCON. We conjecture that the choice of constraint solver by CLINGCON (namely, GECODE) together with theory propagation is the reason\n9 We note that BPROLOG is the default theory solver of EZCSP. Command-line option --solver cmodels-3.83 instructs EZCSP to invoke CMODELS 3.83 using the black-box integration schema. Command-line options --cmodels-incremental and --cmodels-feedback instruct EZCSP to use, respectively, the grey-box and clear-box integration schema. In these two cases, CMODELS 3.83 is automatically selected as the base solver.\nfor CLINGCON’s better performance in a number of the experiments. Yet, in the context of our experiments, the performance of CLINGCON w.r.t. EZCSP is irrelevant. Our work is a comparative study of the impact of the different integration schemas for a fixed selection of a base and theory solver pair. System EZCSP provides us with essential means to perform this study.\nIn all figures presented: CASP Black, CASP Grey, CASP Clear denote EZCSP implementing respectively black-box, grey-box and clear-box, and running a true-CASP encoding; Pure-CSP denotes EZCSP implementing black-box running a pure-CSP encoding (note that for pure-CSP encodings there is no difference in performance between the integration schemas); ASP denotes CMODELS running a pure-ASP encoding; Clingcon denotes CLINGCON running a true-CASP encoding. Each configuration is associated with the same color in all figures. A pattern is applied to the filling of the bars whenever the bar goes offchart. The numbers in the overlaid boxes report the time in seconds and, in parentheses, the total number of timeouts and out-of-memory.\nWe begin our analysis with WSEQ (Figures 7 and 8). The total times across all the instances for all solvers/encodings pairs considered are shown in Figure 7. Because of the large difference between best and worst performance, a logarithmic scale is used. For uniformity of presentation, in the charts out-of-memory conditions and timeouts are both rendered as out-of-time results. The instances used in the experiments are the 30 instances available via ASPCOMP. Interestingly, answer set solver CMODELS on the pure-ASP encoding has excellent performance, comparable to the best performance obtained with CASP encodings by EZCSP. Of the CASP encodings, the true-CASP encoding running in blackbox times out on every instance. Figure 8 thus focuses on the cumulative run times of clear-box and grey-box (on the true-CASP encoding). The numbers on the horizontal axis identify the instances, while the vertical axis is for the cumulative run time, that is, the value for instance n is the sum of the run times for instances 1 . . .n . Cumulative times were chosen for the per-instance figures because they make for a more readable chart when there is large variation between the run times for the individual instances. As shown in Figure 8, the true-CASP encoding running in clear-box performs substantially better than grey-box. This demonstrates that, for this domain, the tight integration schema has an advantage.\nIn case of the IS domain we considered two sets of experiments. In the first one (Figures 9 and 10), we used the 50 official instances from ASPCOMP. We refer to these instances as easy, since the corresponding run times are rather small. Figure 9 provides a comparison of the total times. Judging by the total times, tight integration schemas appear to have an advantage, allowing the true-CASP encoding to outperform the pure-CSP encoding. As one might expect, the best performance for the true-CASP encoding is from the clear-box integration schema. In this case the early pruning of the search space made possible by the clear-box architecture seems to yield substantial benefits. As expected, grey-box is also faster than black-box, while CMODELS on the pure-ASP encoding runs out of memory in all the instances.\nThe second set of experiments for the IS domain (Figures 11 and 12) consists of 30 instances that we generated to be substantially more complex than the ones from ASPCOMP, and that are thus called hard. As discussed below, this second set of experiments reveals a remarkable change in the behavior of solver/encodings pairs when the instances require more computational effort. The process we followed to generate the 30 hard instances con-\nsisted in (1) generating randomly 500 fresh instances; (2) running the true-CASP encoding with the grey-box integration schema on them with a timeout of 300 seconds; (3) selecting randomly, from those, 15 instances that resulted in timeout and 15 instances that were solved in 25 seconds or more. The numerical parameters used in the process were selected with the purpose of identifying more challenging instances than those from the easy set and were based on the results on that set. The execution times reported in Figure 11 clearly indicate the level of difficulty of the selected instances (once again, CMODELS runs out of memory). Remarkably, these more difficult instances are solved more efficiently by the\npure-CSP encoding that relies only on the CSP solver. In fact, the pure-CSP encoding outperforms every other method of computation (including CLINGCON on true-CASP encoding). More specifically, solving the instances with the true-CASP encoding takes between 30% and 50% longer than with the pure-CSP encoding. This was not the isolated effect of a few instances, but rather a constant pattern throughout the experiment. A possible explanation for this phenomenon is that domain IS is overall best suited to the CSP solving procedures. It seems natural for the difference in performance to become more evident as the problem instances become more challenging, when other factors such as overhead play\nless of a role. This conjecture is compatible with the difference in performance observed earlier on the easy instances.\nAnother remarkable aspect highlighted by Figure 12 is that clear-box is outperformed by grey-box. This is the opposite of what was observed on the easy instances and highlights the fact that there is no single-best integration schema, even when one focuses on trueCASP encodings. We hypothesize this to be due to the nature of the underlying scheduling problem, which is hard to solve, but whose relaxations (obtained by dropping one or more constraints) are relatively easy. Under these conditions, the calls executed by clear-box to the theory solver are ineffective at pruning the search space and incur a non-negligible overhead. (The performance of CLINGCON is likely affected by the same behavior.) In grey-box, on the other hand, no time is wasted trying to prune the search space of the base solver, and all the time spent in the theory solver is dedicated to solving the final CSP. The performance of black-box is likely due to the minor efficiency of its integration schema compared to grey-box.\nThe final experiment focuses on the RF domain (Figures 13 and 14). The instances used in this experiment are the 50 official instances from ASPCOMP. The total execution times are presented in Figure 13. Although the instances for this domain are comparatively easy, as suggested by the black-box and grey-box times, some of the configurations have high total execution times. The clear-box encoding is also off-chart, due to timeouts on 19 instances. This is a substantial difference in performance compared to the other true-CASP configurations, upon which we expand later in this section. Surprisingly, the total time of CLINGCON is also close to off-chart. Upon closer inspection, we have found this to be due to 3 instances for which CLINGCON runs out of memory. This is an interesting instance of the trade-off between speed of execution and performance stability, considering that on the\nother instances CLINGCON is very fast. The per-instance execution times for grey-box and black-box are detailed in Figure 14. The figure highlights the very similar performance of the two schemas, with black-box losing only in the final 10% of the instances in spite of its higher overhead. This is likely due to the simplicity of the RF problem: most extended answer sets can be found with little backtracking between base and theory solver, and thus the difference between the two schemas has little bearing on the execution times. Similarly to the hard instances of the IS domain, the better performance of black-box and grey-box in comparison to clear-box can be explained by the fact that, in this domain, frequent checks with the theory solver add overhead but are overall ineffective at pruning the search."
    }, {
      "heading" : "8 A Brief Account on Related Systems",
      "text" : "In the introduction we mentioned solvers ACSOLVER (Mellarkod et al., 2008), CLINGCON (Gebser et al., 2009), IDP (Wittocx et al., 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al., 2011), MINGO (Liu et al., 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016). In this section we briefly remark on this variety of CASP systems. This is not intended as a detailed comparison between the systems, but as a quick summary.\nAt a high-level abstraction, one may easily relate the architectures of the CLINGCON, ACSOLVER, IDP, and INCA to that of EZCSP. Given a CASP program, all of these systems first utilize an answer set solver to compute a part of an answer set for an asp-abstraction and then utilize a constraint programming system to solve a resulting csp-abstraction. All of these systems implement the clear-box integration schema. Table 2 provides a summary of base solvers and theory solvers utilized by them.\nA few remarks are due. Unlike its peers, ACSOLVER does not implement learning as its base solver SMODELS does not support this technique. The fact that system INCA imple-\nments its own CP solver, or, in other words, a set of its in house CP-based propagators allows this system to take advantage of some sophisticated techniques stemming from CP. In particular, it implements so called “lazy nogood generation”. This technique allows one to transfer some of the information stemming from CP-based propagations into a propositional logic program extending the original input to a base solver. We also note that the latest version of CLINGCON, as well, bypasses the use of GECODE by implementing its own CP-based propagators. All of the above systems are focused on finite domain integer linear constraints. Some of them allow for global constraints.\nSystem DINGO translates CA programs into SMT modulo difference logic formulas and applies the SMT solver Z3 (De Moura and Bjørner, 2008) to find their models. Rather than arbitrary integer linear constraints, the system only handles those that fall into the class of difference logic. On the other hand, the system does not pose the restriction of finite domain. The EZSMT (Susman and Lierler, 2016) solver and the ASPMT2SMT (Bartholomew and Lee, 2014) solvers utilize SMT solvers to process CA programs. Both of these systems may only deal with tight programs. They allow for arbitrary integer linear constraints. None of the SMT-based CASP solvers allow for global constraints in their programs due to the underlying solving technology.\nLast but not least, the solver MINGO translates CA programs into mixed integer programming expressions and then utilizes IBM ILOG CPLEX10 system to find solutions.\nSusman and Lierler (2016) provide an experimental analysis of systems from all of the families mentioned."
    }, {
      "heading" : "9 Conclusions",
      "text" : "In this paper, we have addressed in a principled way the integration of answer set solving techniques and constraint solving techniques in CASP solvers and, in particular, in the realm of the constraint answer set solver EZCSP. To begin, we defined logic programs with constraint atoms (CA programs). To bridge the ASP and the constraint programming aspects of such programs, we introduced the notions of asp-abstractions and csp-abstractions, which allow for a simple and yet elegant way of defining the extended answer sets of CA programs.\nNext, we described the syntax of the CASP language used by the constraint answer set solver EZCSP, which we call EZ. It is worth noting that this paper contains the first detailed and principled account of the syntax of the EZ language. We relate programs written in the EZCSP language and CA programs. The tight relation between EZ programs and CA\n10 http://www.ibm.com/software/commerce/optimization/cplex-optimizer/\nprograms makes it evident that the EZ language is a full-fledged constraint answer set programming formalism. Recall that the EZCSP system originated as an attempt to provide a simple, flexible framework for modeling constraint satisfaction problems. This yields an interesting observation: constraint answer set programming can be seen as a declarative modeling framework utilizing constraint satisfaction solving technology.\nIn this paper we also drew a parallel between CASP and SMT. We used this connection to introduce three important kinds of integration of CASP solvers: black-box integration, grey-box integration, and clear-box integration. We introduced a graph-based abstract framework suitable for describing the EZCSP solving algorithm. The idea of using graphbased representations for backtrack-search procedures was pioneered by the SAT community. Compared to the use of pseudocode for describing algorithms, such a framework allows for simpler descriptions of search algorithms, and is well-suited for capturing the similarities and differences of the various configurations of EZCSP stemming from different integration schemas.\nFinally, we presented an experimental comparison of the various integration schemas, using the implementation of EZCSP as a testbed. For the comparison, we used three challenging benchmark problems from the Third Answer Set Programming Competition – 2011 (Calimeri et al., 2011). The experimental analysis takes into account how differences in the encoding of the solutions may influence overall performance by exploiting the components of the solver in different ways. The case study that we conducted clearly illustrates the influence that integration methods have on the behavior of hybrid systems. The main attractive feature of the black-box integration schema is the ease of inception of a new system. In realm of CASP, one may take existing off-the-shelf ASP and CSP tools and connect them together by simple intermediate translation functions. This facilitates fast implementation of a prototypical CASP solver. One can then move towards a grey-box or clear-box architecture in the hope of increased performance when a prototype system proves to be promising. Yet, our experiments demonstrate that different integration schemas may be of use and importance for different domain, and that, when it comes to performance, there is no single-best integration schema. Thus, systematic means ought to be found for facilitating building hybrid systems supporting various coupling mechanisms. Just as the choice of a particular heuristic for selecting decision literals is often configurable in SAT or ASP solvers via command line parameters, the choice of integration schema in hybrid systems should be configurable. Experimental results also indicate a strong need for theory propagation. Standard interfaces in both base and theory systems are required in order to easily build hybrid systems to support this feature.\nBuilding clear and flexible APIs allowing for various types of interactions between the solvers seems a necessary step towards making the development of hybrid solvers effective. This work provides evidence for the need of an effort towards this goal. Many SAT solvers and SMT solvers already come with APIs that aim at facilitating extensions of these complex software systems. We argue for this practice to be adopted by other automated reasoning communities.\nFinally, our study was performed in the realm of CASP technology, but it translates to SMT as well, given the discussed links between the two technologies. Incidentally, this also brings to the surface the importance of establishing means of effective communication between the two communities of constraint answer set programming and SMT solving."
    }, {
      "heading" : "CALIMERI, F., IANNI, G., RICCA, F., ALVIANO, M., BRIA, A., CATALANO, G., COZZA,",
      "text" : ""
    }, {
      "heading" : "S., FABER, W., FEBBRARO, O., LEONE, N., MANNA, M., MARTELLO, A., PANETTA, C., PERRI, S., REALE, K., SANTORO, M. C., SIRIANNI, M., TERRACINA, G., AND",
      "text" : "VELTRI, P. 2011. The third answer set programming competition: Preliminary report of the system competition track. In Proceedings of the International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR). Springer-Verlag, Berlin, Heidelberg, 388–403.\nCARLSSON, M. AND MILDNER, P. 2012. SICStus Prolog-the first 25 years. Theory Pract. Log. Program. 12, 1-2 (Jan.), 35–66.\nCAT, B. D., BOGAERTS, B., AND DENECKER, M. 2014. MiniSAT(ID) for satisfiability checking and constraint solving. In ALP newsletter feautured article.\nDAVIS, M., LOGEMANN, G., AND LOVELAND, D. 1962. A machine program for theorem proving. Communications of the ACM 5(7), 394–397.\nDE MOURA, L. AND BJØRNER, N. 2008. Z3: An efficient SMT solver. In Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems. 337–340."
    }, {
      "heading" : "DENECKER, M., VENNEKENS, J., BOND, S., GEBSER, M., AND TRUSZCZYŃSKI, M.",
      "text" : "2009. The second answer set programming system competition. In Proceedings of the International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), E. Erdem, F. Lin, and T. Schaub, Eds. Lecture Notes in Artificial Intelligence (LNCS), vol. 5753. Springer Berlin Heidelberg, Berlin, Heidelberg.\nDOVIER, A., FORMISANO, A., AND PONTELLI, E. 2011. Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning: Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday. Lecture Notes in Artificial Intelligence (LNCS). Springer Verlag, Berlin, Chapter Perspectives on Logic-based Approaches for Reasoning, 259–279.\nDRESCHER, C. AND WALSH, T. 2011. A translational approach to constraint answer set solving. Theory and Practice of Logic programming (TPLP) 10, 4-6, 465–480.\nEÉN, N. AND BIERE, A. 2005. Effective preprocessing in SAT through variable and clause elimination. In SAT.\nEÉN, N. AND SÖRENSSON, N. 2003. An extensible SAT-solver. In SAT. EITER, T., IANNI, G., SCHINDLAUER, R., AND TOMPITS, H. 2005. A uniform integra-\ntion of higher-order reasoning and external evaluations in answer set programming. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). Professional Book Center, 90–96.\nELKABANI, I., PONTELLI, E., AND SON, T. C. 2004. Smodels with CLP and its applications: A simple and effective approach to aggregates in ASP. In ICLP, B. Demoen and V. Lifschitz, Eds. Lecture Notes in Computer Science, vol. 3132. Springer, 73–89.\nFERRARIS, P. AND LIFSCHITZ, V. 2005. Weight constraints as nested expressions. Theory and Practice of Logic Programming 5, 45–74.\nGEBSER, M., KAUFMANN, B., NEUMANN, A., AND SCHAUB, T. 2007. Conflict-driven answer set solving. In Proceedings of 20th International Joint Conference on Artificial Intelligence (IJCAI’07). MIT Press, 386–392."
    }, {
      "heading" : "GEBSER, M., LIU, L., NAMASIVAYAM, G., NEUMANN, A., SCHAUB, T., AND",
      "text" : "TRUSZCZYŃSKI, M. 2007. The first answer set programming system competition. In Proceedings of the International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), C. Baral, G. Brewka, and J. Schlipf, Eds. Lecture Notes in Artificial Intelligence (LNCS), vol. 4483. Springer Berlin Heidelberg, Berlin, Heidelberg, 3–17.\nGEBSER, M., OSTROWSKI, M., AND SCHAUB, T. 2009. Constraint answer set solving. In Proceedings of 25th International Conference on Logic Programming (ICLP), P. M. Hill and D. S. Warren, Eds. Lecture Notes in Artificial Intelligence (LNCS), vol. 5649. Springer Berlin Heidelberg, Berlin, Heidelberg, 235–249.\nGEBSER, M., SCHAUB, T., AND THIELE, S. 2007. Gringo: A new grounder for answer set programming. In Logic Programming and Nonmonotonic Reasoning, C. Baral, G. Brewka, and J. Schlipf, Eds. Lecture Notes in Computer Science, vol. 4483. Springer Berlin Heidelberg, 266–271.\nGELFOND, M. AND LIFSCHITZ, V. 1998. Action languages11. Electronic Transactions on Artificial Intelligence 3, 195–210. GIUNCHIGLIA, E., LEONE, N., AND MARATEA, M. 2008. On the relation among answer set solvers. Ann. Math. Artif. Intell. 53, 1-4, 169–204. GIUNCHIGLIA, E., LIERLER, Y., AND MARATEA, M. 2006. Answer set programming based on propositional satisfiability. Journal of Automated Reasoning 36, 345–377. GOMES, C. P., KAUTZ, H., SABHARWAL, A., AND SELMAN, B. 2008. Satisfiability solvers. In Handbook of Knowledge Representation, F. van Harmelen, V. Lifschitz, and B. Porter, Eds. Elsevier, 89–134. JAFFAR, J. AND MAHER, M. J. 1994. Constraint logic programming: a survey. The Journal of Logic Programming 1920, Supplement 1, 0, 503 – 581. Special Issue: Ten Years of Logic Programming. JANHUNEN, T., LIU, G., AND NIEMEL, I. 2011. Tight integration of non-ground answer set programming and satisfiability modulo theories. In Working notes of the 1st Workshop on Grounding and Transformations for Theories with Variables. LEE, J. 2005. A model-theoretic counterpart of loop formulas. In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). Professional Book Center, 503–508. LIERLER, Y. 2014. Relating constraint answer set programming languages and algorithms. Artificial Intelligence 207C, 1–22. LIERLER, Y., SMITH, S., TRUSZCZYŃSKI, M., AND WESTLUND, A. 2012. Weightedsequence problem: ASP vs CASP and declarative vs problem oriented solving. In Proceedings of the 14th International Symposium on Practical Aspects of Declarative Languages (PADL), C. V. Russo and N.-F. Zhou, Eds. Lecture Notes in Computer Science, vol. 7149. Springer Verlag, Berlin. LIERLER, Y. AND TRUSZCZYŃSKI, M. 2011. Transition systems for model generators — a unifying approach. Theory and Practice of Logic Programming, 27th Int’l. Conference on Logic Programming (ICLP’11) Special Issue 11, 4-5, 629–646. LIFSCHITZ, V., TANG, L. R., AND TURNER, H. 1999. Nested expressions in logic programs. Annals of Mathematics and Artificial Intelligence 25, 369–389. LIU, G., JANHUNEN, T., AND NIEMELÄ, I. 2012. Answer set programming via mixed integer programming. In Principles of Knowledge Representation and Reasoning: Proceedings of the 13th International Conference. AAAI Press, 32–42. MAREK, V. AND TRUSZCZYŃSKI, M. 1999. Stable models and an alternative logic programming paradigm. In The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375–398."
    }, {
      "heading" : "MARRIOTT, K., NETHERCOTE, N., RAFEH, R., STUCKEY, P. J., GARCIA DE",
      "text" : "LA BANDA, M., AND WALLACE, M. 2008. The design of the Zinc modelling language. Constraints 13, 3 (Sept.), 229–267. MELLARKOD, V. S., GELFOND, M., AND ZHANG, Y. 2008. Integrating answer set programming and constraint logic programming. Annals of Mathematics and Artificial Intelligence 53, 1-4, 251–287.\n11 http://www.ep.liu.se/ea/cis/1998/016/\nNIEMELÄ, I. 1999. Logic programs with stable model semantics as a constraint programming paradigm. Annals of Mathematics and Artificial Intelligence 25, 241–273. NIEMELÄ, I. AND SIMONS, P. 2000. Extending the Smodels system with cardinality and weight constraints. In Logic-Based Artificial Intelligence, J. Minker, Ed. Kluwer, 491–521. NIEUWENHUIS, R., OLIVERAS, A., AND TINELLI, C. 2006. Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T). Journal of the ACM 53(6), 937–977. ROSSI, F., VAN BEEK, P., AND WALSH, T. 2008. Constraint programming. In Handbook of Knowledge Representation, F. van Harmelen, V. Lifschitz, and B. Porter, Eds. Elsevier, 181–212. SCHULTE, C. AND STUCKEY, P. J. 2008. Efficient constraint propagation engines. Transactions on Programming Languages and Systems . SIMONS, P., NIEMELÄ, I., AND SOININEN, T. 2002. Extending and implementing the stable model semantics. Artificial Intelligence 138, 181–234. SUSMAN, B. AND LIERLER, Y. 2016. SMT-based constraint answer set solver EZSMT (system description). In International Conference on Logic Programming (ICLP). VAN GELDER, A., ROSS, K., AND SCHLIPF, J. 1991. The well-founded semantics for general logic programs. Journal of ACM 38, 3, 620–650. WITTOCX, J., MARIËN, M., AND DENECKER, M. 2008. The IDP system: a model expansion system for an extension of classical logic. In Proceedings of Workshop on Logic and Search, Computation of Structures from Declarative Descriptions (LaSh). electronic, 153–165. available at https://lirias.kuleuven.be/bitstream/ 123456789/229814/1/lash08.pdf. ZHANG, L., MADIGAN, C. F., MOSKEWICZ, M. W., AND MALIK, S. 2001. Efficient conflict driven learning in a Boolean satisfiability solver. In Proceedings ICCAD-01. 279–285. ZHOU, N.-F. 2012. The language features and architecture of B-Prolog. Journal of Theory and Practice of Logic Programming (TPLP) 12, 1–2 (Jan), 189–218."
    }, {
      "heading" : "Appendix A EZ – The Language of EZCSP",
      "text" : "The EZ language is aimed at a convenient specification of a propositional ez-program E = 〈E ,A, C, γ,D〉. To achieve this, the language supports an explicit specification of domains and variables, the use of non-ground rules, and a compact representation of lists in constraints. We begin by describing the syntax of the language. Next, we define a mapping from EZ programs to propositional ez-programs.\nLet ΣEZ = 〈CEZ,VEZ,FEZ,REZ〉 be a signature, where CEZ,VEZ,FEZ, and REZ denote pairwise disjoint sets of constant symbols, non-constraint variable symbols, function symbols, and relation symbols respectively. Set CEZ includes symbols for integers and predefined constants (fd , q , r ), denoting CSP domains. We use common convention in logic programming and denote non-constraint variable symbols in VEZ by means of upper case letters. Function and relation symbols are associated with a non-negative integer called arity. The arity of function symbols is always greater than 0. Set FEZ includes pre-defined\nsymbols that intuitively correspond to arithmetic operators (e.g., +), reified arithmetic connectives (e.g.,<, =), reified logical connectives (see Table A 1), list delimiters ([ and ]) and names of global constraints (discussed later in this section). Set REZ contains pre-defined symbols cspdomain , cspvar , required .\nThe notions of terms, atoms, literals, and rules are defined over ΣEZ similarly to ASP, although the notion of term is slightly expanded. Specifically, a term over signature ΣEZ = 〈CEZ,VEZ,FEZ,REZ〉 is defined as:\n1. a constant symbol from CEZ. 2. a variable symbol from VEZ. 3. an expression of the form\nf (t1, . . . , tk ), (A1)\nwhere f is a function symbol in FEZ of arity k and 〈t1, . . . , tk 〉 are terms from cases 1–3 (If a function symbol is a pre-defined arithmetic operator, arithmetic connective, or logical connective, then common infix notation is used.) 4. an extensional list, i.e., an expression of the form [t1, t2, . . . , tk ] where ti ’s are terms from cases 1–3. 5. an intensional list, i.e., an expression of the form [g/k ] where g ∈ FEZ or (with slight abuse of notation) g ∈ REZ and k is an integer. 6. a global constraint, i.e., an expression of the form f (λ1, λ2, . . . , λk ), where f ∈ FEZ and each λi is a list.12\nConnective Constraint Domain\n∨ Disjunction ∧ Conjunction \\ Exclusive disjunction ← or→ Implication ↔ Equivalence ! Negation\nTable A 1. EZ Logical Connectives\nPre-defined arithmetic and logical connectives from FEZ are dedicated to the specification of constraints. The connectives are reified to enable their use within atoms of the form required(β). Furthermore, the logical connectives enable the specification of so called “reified constraints” such as:\nx ≥ 12 ∨ y < 3, (A2)\n12 In constraint satisfaction, global constraints are applied to lists of terms of arbitrary length, while local constraints, such as x > y , apply to a fixed number of arguments. For simplicity, in the definition of the language we disregard special cases of global constraints, whose arguments are not lists.\nwhich specifies that either constraint x ≥ 12 or constraint y < 3 should be satisfied by a solution to a problem containing reified constraint (A2).\nAn EZ program is a pair 〈ΣEZ,Π〉, where Π is a set of rules over signature ΣEZ. Every EZ program is required to contain exactly one fact, whose head is cspdomain(fd), cspdomain(q), or cspdomain(r). Following common practice, we denote a program simply by the set of its rules, and let the signature be implicitly defined.\nSimilarly to ASP, a non-ground rule is a rule containing one or more non-constraint variables. A non-ground rule is interpreted as a shorthand for the set of propositional (ground) rules obtained by replacing every non-constraint variable in the rule by suitable terms not containing non-constraint variables. The process of replacing non-ground rules by their propositional counterparts is called grounding and is well understood in ASP (Gebser et al., 2007; Calimeri et al., 2008). For this reason, in the rest of this section we focus on ground EZ programs.\nWe now define a mapping from a (ground) EZ program Π to a propositional ez-program E = 〈E ,A, C, γ,D〉. We assume that γ, a function from C to constraints, is defined along the lines of Section 2.2 and given. Recall that only one fact formed from relation cspdomain is allowed in a program Π. The fact’s head is mapped to the constraint domain D by mapping µD :\nµD(Π) =  FD (finite domains) if cspdomain(fd)· ∈ Π\nQ if cspdomain(q)· ∈ Π R if cspdomain(r)· ∈ Π\nAtoms formed from relation cspvar specify the set VPE of variables (recall that VPE is the set of constraint variables that appear in csp-abstractions corresponding to E). The corresponding atoms take two forms, cspvar(v) and cspvar(v , l , u), where v is a term from ΣEZ and l , u belong to CEZ ∩ D . The latter form allows one to provide a range for the variable. Specifically, set VPE is obtained from facts containing the above atoms as follows:\nVPE = {v | cspvar(v)· ∈ Π or cspvar(v , l , u)· ∈ Π}·\nThe constraints that specify the range of the variables are generated by mapping µV :\nµV (Π) = {required(v ≥ l) · | cspvar(v , l , u)· ∈ Π} ∪ {required(v ≤ u) · | cspvar(v , l , u)· ∈ Π}·\nNext, we address the specification of lists. Let us begin by introducing some needed terminology. If a term is of the form (A1) then we refer to f as a functor and to 〈t1, . . . , tk 〉 as its arguments. For an atom of the form r(t1, . . . , tk ) we say that r is its relation and 〈t1, . . . , tk 〉 are its arguments. The expression terms(f , k , 〈t1, t2, . . . tm)) (with 0 ≤ m ≤ k ) denotes the set of terms from ΣEZ formed by functor f that have arity k and whose arguments have prefix 〈t1, t2, . . . , tm〉. The expression atoms(r , k , 〈t1, . . . , tk 〉) denotes the set of atoms formed by relation r that have arity k and whose arguments have prefix 〈t1, t2, . . . , tm〉. The expression facts(Π) denotes the facts in Π. Finally, given a set S , lexord(S ) denotes a list [e1, e2, . . . , en ] enumerating the elements of S in such a way that\nei ≤ ei+1 (where ≤ denotes lexicographic ordering13). We can now define mappings λv and λr from the two forms of intensional lists to corresponding extensional lists:\n• Given an expression of the form [f (t1, t2, . . . , tm)/k ], where f ∈ FEZ, k is an integer from CEZ, ti ’s are terms, and 0 ≤ m ≤ k , its extensional representation is the list:\nλv ([f (t1, t2, . . . , tm)/k ]) = lexord(terms(f , k , 〈t1, t2, . . . , tm〉) ∩ VPE )\nof all variables with functor f , arity k , and whose arguments have prefix 〈t1, t2, . . . , tm〉. For example, given a set of variables\nX1 = {v(1), v(2), v(3),w(a, 1),w(a, 2),w(b, 1)},\nthe expression [w(a)/2] denotes the list λv (w , 2, 〈a〉) = [w(a, 1),w(a, 2)]. When m = 0, the expression is abbreviated [f /k ]. For instance, given set X1 as above, the expression [v/1] denotes [v(1), v(2), v(3)]. • Consider an expression [r(t1, t2, . . . , tm)/k ], where r is not a pre-defined relation from REZ and 0 ≤ m ≤ k . Let [a1, a2, . . . , an ] denote list lexord(facts(Π) ∩ atoms(r , k , 〈t1, . . . , tm〉)) and let αki denote the k th argument of ai . Then, the extensional representation, λr ([r(t1, t2, . . . , tm)/k ]), of [r(t1, t2, . . . , tm)/k ] is:\nλr ([r(t1, t2, . . . , tm)/k ]) = [α k 1 , α k 2 , . . . , α k n ]·\nFor example, given a relation r ′ defined by facts r ′(a, 1, 3), r ′(a, 2, 1), r ′(b, 5, 7), the expression [r ′(a)/3] denotes the list [3, 1] and the expression [r ′(a, 2)/3] denotes [1]. Similarly to the previous case, when the list of arguments is empty, the expression can be abbreviated as [r/k ]· For instance, given a relation r ′′ for which we are given facts r ′′(a, 3), r ′′(b, 1), r ′′(c, 2), the expression [r ′′/2] denotes 〈3, 1, 2〉.\nAs a practical example of the use of intensional lists, suppose that, above, relation r ′′ denotes the amount of resources required for a job and suppose that we are given facts d(a, 1), d(b, 1), d(c, 1), specifying that jobs a , b, c have duration 1. Additionally, variables st(a), st(b), st(c) represent the start time of the jobs. A cumulative constraint14 for this scenario can be written as\nrequired(cumulative([st/1], [d/2], [r ′′/2], 4)),\nwhich is an abbreviation of15\nrequired(cumulative([st(a), st(b), st(c)], [1, 1, 1], [3, 2, 1], 4))·\nand means that values should be assigned to variables st(a), st(b), st(c) so that each job, of duration 1 and requiring amounts of resources 3, 2, 1 respectively, can be executed on a machine that can provide at most 4 resources at any given time.\nNext, let µR be a function that maps an atom of the form required(β) to an atom required(β′) by:\n13 The choice of a particular order is due to the fact that global constraints that accept multiple lists typically expect the elements in the same position throughout the lists to be in a certain relation. More sophisticated techniques for the specification of lists are possible, but in our experience, this method gives satisfactory results. 14 A.1 gives information on cumulative and other global constraints. 15 Note that the first argument is of the type [f (t1, t2, . . . , tm )/k ] while the other two are of type\n[r(t1, t2, . . . , tm )/k ], hence the different expansions.\n• Replacing every occurrence of [f (t1, . . . , tm)/k ] in β by λv ([f (t1, . . . , tm)/k ]); • Replacing every occurrence of [r(t1, . . . , tm)/k ] in β by λr ([f (t1, . . . , tm)/k ]).\nThe mapping is easily extended to rules and to programs as follows: µR(a ← B . ) = { µ(a)← B . if a is of the form required(β) a ← B . otherwise\nwhere B denotes the body of a rule. µR(Π) = ⋃ r∈Π µR(r)\nFinally, let µA(Π) and µC(Π) denote mappings from Π to alphabets A and C, which are straightforward given the above construction. Thus, given an EZ program Π, the corresponding propositional ez-program is:\nE(Π) = 〈 µV (Π) ∪ µR(Π), µA(Π), µC(Π), γ, µD(Π) 〉·"
    }, {
      "heading" : "A.1 Global Constraints in Language EZ",
      "text" : "The global constraints supported by the EZ language include:\n• all different(V ), where V is a list of variables. This constraint, available only in the fd domain, ensures that all the variables in V are assigned unique values. Typically16, the implementation of the corresponding algorithm found in constraint solvers is incomplete. Global constraint all distinct(V ), which provides a complete implementation of the algorithm, is also supported. • assignment(X ,Y ), where X and Y are lists of n variables whose domain is 1 · ·n .\nThe constraint is satisfied if, for every i , j , Xi = j if and only if Yj = i . • circuit(V ), where V is a list of n variables whose domain is 1 · ·n . The constraint\nis satisfied by an assignment V1 = v1, V2 = v2, . . ., Vn = vn if the directed graph with nodes 1 . . .n and arcs 〈1, v1〉, 〈2, v2〉, . . ., 〈n, vn〉 forms a Hamiltonian cycle. • count(M ,V , ◦,E ), where M is an integer or variable, V a list of variables, ◦ an arithmetic comparison operator, and E an integer or variable. This constraint is satisfied if the number, c, of elements of V that equal M is such that c ◦ E . • cumulative(S ,D ,R,L), where S is a list of variables, D and R are lists of nonnegative integers matching the length of S , and L is an integer or a variable. This constraint, which is only available in the fd domain, is typically used in scheduling problems. In that context, S represent the start times of a set of jobs, D provides the duration of those jobs, and R the resources they require. L is the amount of resources available at any time step. Intuitively, the constraint assigns start times to the jobs so that, at any time, no more than an amount L of resources is used. • disjoint2(X ,W ,Y ,H ), where X ,Y are lists of variables and W ,H are lists of integers defining the coordinates and dimensions of rectangles. For example, if X = [x1, . . .], Y = [y1, . . .], W = [w1, . . .], H = [h1, . . .], one of the rectangles they describe has top-left vertex 〈x1, y1〉 and bottom-right vertex 〈x1 + w1, y1 + h1〉. This\n16 See for example http://sicstus.sics.se/sicstus/docs/3.7.1/html/sicstus_33.html\nconstraint is only available in the fd domain, and assigns values to the variables so that the corresponding rectangles do not overlap. • element(I ,V ,E ), where I is an integer or variable, V a list of variables, and E an\ninteger or variable. This constraint is satisfied if the I th element of V is E . • minimum(M ,V ) and maximum(M ,V ), where M is a variable or integer and V\nis a list of variables. These constraints are satisfied if minimum or maximum of V equals M . • scalar product(C ,X , ◦,E ), where C is a list of integers, X is a list of variables, ◦\nis an arithmetic comparison operator, and E is an integer or variable. The intuitive meaning of this constraint is that the scalar product, p, of the elements of C and X must be such that p ◦ E . • serialized(S ,D), where S is a list of variables and D is a list of integers, intuitively\ndenoting start time and duration of jobs. The constraint assigns start times to the jobs so that their execution does not overlap, and can be viewed as a special case of cumulative. • sum(V , ◦,E ), where V is a list of variables, ◦ an arithmetic comparison operator, and E is an integer or a variable. This constraint assigns value to the variables so that ( ∑ v∈V v) ◦ E is satisfied."
    } ],
    "references" : [ {
      "title" : "What’s a head without a body? In Proceedings of the European Conference on Artificial Intelligence (ECAI’06)",
      "author" : [ "C. ANGER", "M. GEBSER", "T. JANHUNEN", "T. SCHAUB" ],
      "venue" : "769–770.",
      "citeRegEx" : "ANGER et al\\.,? 2006",
      "shortCiteRegEx" : "ANGER et al\\.",
      "year" : 2006
    }, {
      "title" : "Representing constraint satisfaction problems in answer set programming",
      "author" : [ "M. BALDUCCINI" ],
      "venue" : "ICLP09 Workshop on Answer Set Programming and Other Computing Paradigms (ASPOCP09).",
      "citeRegEx" : "BALDUCCINI,? 2009",
      "shortCiteRegEx" : "BALDUCCINI",
      "year" : 2009
    }, {
      "title" : "Industrial-size scheduling with ASP+CP",
      "author" : [ "M. BALDUCCINI" ],
      "venue" : "11th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR11), J. P. Delgrande and W. Faber, Eds. Lecture Notes in Artificial Intelligence (LNCS), vol. 6645. Springer Verlag, Berlin, 284–296.",
      "citeRegEx" : "BALDUCCINI,? 2011",
      "shortCiteRegEx" : "BALDUCCINI",
      "year" : 2011
    }, {
      "title" : "Practical and methodological aspects of the use of cutting-edge ASP tools",
      "author" : [ "M. BALDUCCINI", "Y. LIERLER" ],
      "venue" : "Fourteenth International Symposium on Practical Aspects of Declarative Languages (PADL 2012), C. Russo and N.-F. Zhou, Eds. Number 7149 in Lecture Notes in Artificial Intelligence (LNCS). Springer Verlag, Berlin, 78–92.",
      "citeRegEx" : "BALDUCCINI and LIERLER,? 2012",
      "shortCiteRegEx" : "BALDUCCINI and LIERLER",
      "year" : 2012
    }, {
      "title" : "System aspmt2smt: Computing ASPMT theories by SMT solvers",
      "author" : [ "M. BARTHOLOMEW", "J. LEE" ],
      "venue" : "European Conference on Logics in Artificial Intelligence, JELIA. Springer, 529–542.",
      "citeRegEx" : "BARTHOLOMEW and LEE,? 2014",
      "shortCiteRegEx" : "BARTHOLOMEW and LEE",
      "year" : 2014
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "G. BREWKA", "T. EITER", "M. TRUSZCZYŃSKI" ],
      "venue" : "Communications of the ACM 54(12), 92–103.",
      "citeRegEx" : "BREWKA et al\\.,? 2011",
      "shortCiteRegEx" : "BREWKA et al\\.",
      "year" : 2011
    }, {
      "title" : "External sources of knowledge and value invention in logic programming",
      "author" : [ "F. CALIMERI", "S. COZZA", "G. IANNI" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 50, 3-4, 333–361.",
      "citeRegEx" : "CALIMERI et al\\.,? 2007",
      "shortCiteRegEx" : "CALIMERI et al\\.",
      "year" : 2007
    }, {
      "title" : "Computable functions in ASP: theory and implementation",
      "author" : [ "F. CALIMERI", "S. COZZA", "G. IANNI", "N. LEONE" ],
      "venue" : "Proceedings of International Conference on Logic Programming (ICLP). 407–424.",
      "citeRegEx" : "CALIMERI et al\\.,? 2008",
      "shortCiteRegEx" : "CALIMERI et al\\.",
      "year" : 2008
    }, {
      "title" : "The third answer set programming competition: Preliminary report of the system competition track",
      "author" : [ "F. CALIMERI", "G. IANNI", "F. RICCA", "M. ALVIANO", "A. BRIA", "G. CATALANO", "S. COZZA", "W. FABER", "O. FEBBRARO", "N. LEONE", "M. MANNA", "A. MARTELLO", "C. PANETTA", "S. PERRI", "K. REALE", "M.C. SANTORO", "M. SIRIANNI", "G. TERRACINA", "P. VELTRI" ],
      "venue" : "Proceedings of the International Conference on",
      "citeRegEx" : "CALIMERI et al\\.,? 2011",
      "shortCiteRegEx" : "CALIMERI et al\\.",
      "year" : 2011
    }, {
      "title" : "SICStus Prolog-the first 25 years",
      "author" : [ "M. CARLSSON", "P. MILDNER" ],
      "venue" : "Theory Pract. Log. Program. 12, 1-2 (Jan.), 35–66.",
      "citeRegEx" : "CARLSSON and MILDNER,? 2012",
      "shortCiteRegEx" : "CARLSSON and MILDNER",
      "year" : 2012
    }, {
      "title" : "MiniSAT(ID) for satisfiability checking and constraint solving",
      "author" : [ "B.D. CAT", "B. BOGAERTS", "M. DENECKER" ],
      "venue" : "ALP newsletter feautured article.",
      "citeRegEx" : "CAT et al\\.,? 2014",
      "shortCiteRegEx" : "CAT et al\\.",
      "year" : 2014
    }, {
      "title" : "A machine program for theorem proving",
      "author" : [ "M. DAVIS", "G. LOGEMANN", "D. LOVELAND" ],
      "venue" : "Communications of the ACM 5(7), 394–397.",
      "citeRegEx" : "DAVIS et al\\.,? 1962",
      "shortCiteRegEx" : "DAVIS et al\\.",
      "year" : 1962
    }, {
      "title" : "Z3: An efficient SMT solver",
      "author" : [ "L. DE MOURA", "N. BJØRNER" ],
      "venue" : "Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems. 337–340.",
      "citeRegEx" : "MOURA and BJØRNER,? 2008",
      "shortCiteRegEx" : "MOURA and BJØRNER",
      "year" : 2008
    }, {
      "title" : "The second answer set programming system competition",
      "author" : [ "M. DENECKER", "J. VENNEKENS", "S. BOND", "M. GEBSER", "M. TRUSZCZYŃSKI" ],
      "venue" : "Proceedings of the International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), E. Erdem, F. Lin, and T. Schaub, Eds. Lecture Notes in Artificial Intelligence (LNCS), vol. 5753. Springer Berlin Heidelberg, Berlin, Heidelberg.",
      "citeRegEx" : "DENECKER et al\\.,? 2009",
      "shortCiteRegEx" : "DENECKER et al\\.",
      "year" : 2009
    }, {
      "title" : "Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning: Essays Dedicated to Michael Gelfond on the Occasion of His 65th Birthday",
      "author" : [ "A. DOVIER", "A. FORMISANO", "E. PONTELLI" ],
      "venue" : "Lecture Notes in Artificial Intelligence (LNCS). Springer Verlag, Berlin, Chapter Perspectives on Logic-based Approaches for Reasoning, 259–279.",
      "citeRegEx" : "DOVIER et al\\.,? 2011",
      "shortCiteRegEx" : "DOVIER et al\\.",
      "year" : 2011
    }, {
      "title" : "A translational approach to constraint answer set solving",
      "author" : [ "C. DRESCHER", "T. WALSH" ],
      "venue" : "Theory and Practice of Logic programming (TPLP) 10, 4-6, 465–480.",
      "citeRegEx" : "DRESCHER and WALSH,? 2011",
      "shortCiteRegEx" : "DRESCHER and WALSH",
      "year" : 2011
    }, {
      "title" : "Effective preprocessing in SAT through variable and clause elimination",
      "author" : [ "N. EÉN", "A. BIERE" ],
      "venue" : "SAT.",
      "citeRegEx" : "EÉN and BIERE,? 2005",
      "shortCiteRegEx" : "EÉN and BIERE",
      "year" : 2005
    }, {
      "title" : "An extensible SAT-solver",
      "author" : [ "N. EÉN", "N. SÖRENSSON" ],
      "venue" : "SAT.",
      "citeRegEx" : "EÉN and SÖRENSSON,? 2003",
      "shortCiteRegEx" : "EÉN and SÖRENSSON",
      "year" : 2003
    }, {
      "title" : "A uniform integration of higher-order reasoning and external evaluations in answer set programming",
      "author" : [ "T. EITER", "G. IANNI", "R. SCHINDLAUER", "H. TOMPITS" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). Professional Book Center, 90–96.",
      "citeRegEx" : "EITER et al\\.,? 2005",
      "shortCiteRegEx" : "EITER et al\\.",
      "year" : 2005
    }, {
      "title" : "Smodels with CLP and its applications: A simple and effective approach to aggregates in ASP",
      "author" : [ "I. ELKABANI", "E. PONTELLI", "SON", "T.C." ],
      "venue" : "ICLP, B. Demoen and V. Lifschitz, Eds. Lecture Notes in Computer Science, vol. 3132. Springer, 73–89.",
      "citeRegEx" : "ELKABANI et al\\.,? 2004",
      "shortCiteRegEx" : "ELKABANI et al\\.",
      "year" : 2004
    }, {
      "title" : "Weight constraints as nested expressions",
      "author" : [ "P. FERRARIS", "V. LIFSCHITZ" ],
      "venue" : "Theory and Practice of Logic Programming 5, 45–74.",
      "citeRegEx" : "FERRARIS and LIFSCHITZ,? 2005",
      "shortCiteRegEx" : "FERRARIS and LIFSCHITZ",
      "year" : 2005
    }, {
      "title" : "Conflict-driven answer set solving",
      "author" : [ "M. GEBSER", "B. KAUFMANN", "A. NEUMANN", "T. SCHAUB" ],
      "venue" : "Proceedings of 20th International Joint Conference on Artificial Intelligence (IJCAI’07). MIT Press, 386–392.",
      "citeRegEx" : "GEBSER et al\\.,? 2007",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2007
    }, {
      "title" : "The first answer set programming system competition",
      "author" : [ "M. GEBSER", "L. LIU", "G. NAMASIVAYAM", "A. NEUMANN", "T. SCHAUB", "M. TRUSZCZYŃSKI" ],
      "venue" : "Proceedings of the International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR), C. Baral, G. Brewka, and J. Schlipf, Eds. Lecture Notes in Artificial Intelligence (LNCS), vol. 4483. Springer Berlin Heidelberg, Berlin, Heidelberg,",
      "citeRegEx" : "GEBSER et al\\.,? 2007",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2007
    }, {
      "title" : "Constraint answer set solving",
      "author" : [ "M. GEBSER", "M. OSTROWSKI", "T. SCHAUB" ],
      "venue" : "Proceedings of 25th International Conference on Logic Programming (ICLP), P. M. Hill and D. S. Warren, Eds. Lecture Notes in Artificial Intelligence (LNCS), vol. 5649. Springer Berlin Heidelberg, Berlin, Heidelberg, 235–249.",
      "citeRegEx" : "GEBSER et al\\.,? 2009",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2009
    }, {
      "title" : "Gringo: A new grounder for answer set programming",
      "author" : [ "M. GEBSER", "T. SCHAUB", "S. THIELE" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning, C. Baral, G. Brewka, and J. Schlipf, Eds. Lecture Notes in Computer Science, vol. 4483. Springer Berlin Heidelberg, 266–271.",
      "citeRegEx" : "GEBSER et al\\.,? 2007",
      "shortCiteRegEx" : "GEBSER et al\\.",
      "year" : 2007
    }, {
      "title" : "Action languages",
      "author" : [ "M. GELFOND", "V. LIFSCHITZ" ],
      "venue" : "Electronic Transactions on Artificial Intelligence 3, 195–210.",
      "citeRegEx" : "GELFOND and LIFSCHITZ,? 1998",
      "shortCiteRegEx" : "GELFOND and LIFSCHITZ",
      "year" : 1998
    }, {
      "title" : "On the relation among answer set solvers",
      "author" : [ "E. GIUNCHIGLIA", "N. LEONE", "M. MARATEA" ],
      "venue" : "Ann. Math. Artif. Intell. 53, 1-4, 169–204.",
      "citeRegEx" : "GIUNCHIGLIA et al\\.,? 2008",
      "shortCiteRegEx" : "GIUNCHIGLIA et al\\.",
      "year" : 2008
    }, {
      "title" : "Answer set programming based on propositional satisfiability",
      "author" : [ "E. GIUNCHIGLIA", "Y. LIERLER", "M. MARATEA" ],
      "venue" : "Journal of Automated Reasoning 36, 345–377.",
      "citeRegEx" : "GIUNCHIGLIA et al\\.,? 2006",
      "shortCiteRegEx" : "GIUNCHIGLIA et al\\.",
      "year" : 2006
    }, {
      "title" : "Satisfiability solvers",
      "author" : [ "C.P. GOMES", "H. KAUTZ", "A. SABHARWAL", "B. SELMAN" ],
      "venue" : "Handbook of Knowledge Representation, F. van Harmelen, V. Lifschitz, and B. Porter, Eds. Elsevier, 89–134.",
      "citeRegEx" : "GOMES et al\\.,? 2008",
      "shortCiteRegEx" : "GOMES et al\\.",
      "year" : 2008
    }, {
      "title" : "Constraint logic programming: a survey",
      "author" : [ "J. JAFFAR", "M.J. MAHER" ],
      "venue" : "The Journal of Logic Programming 1920, Supplement 1, 0, 503 – 581. Special Issue: Ten Years of Logic Programming.",
      "citeRegEx" : "JAFFAR and MAHER,? 1994",
      "shortCiteRegEx" : "JAFFAR and MAHER",
      "year" : 1994
    }, {
      "title" : "Tight integration of non-ground answer set programming and satisfiability modulo theories",
      "author" : [ "T. JANHUNEN", "G. LIU", "I. NIEMEL" ],
      "venue" : "Working notes of the 1st Workshop on Grounding and Transformations for Theories with Variables.",
      "citeRegEx" : "JANHUNEN et al\\.,? 2011",
      "shortCiteRegEx" : "JANHUNEN et al\\.",
      "year" : 2011
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "LEE J." ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). Professional Book Center, 503–508.",
      "citeRegEx" : "J.,? 2005",
      "shortCiteRegEx" : "J.",
      "year" : 2005
    }, {
      "title" : "Relating constraint answer set programming languages and algorithms",
      "author" : [ "Y. LIERLER" ],
      "venue" : "Artificial Intelligence 207C, 1–22.",
      "citeRegEx" : "LIERLER,? 2014",
      "shortCiteRegEx" : "LIERLER",
      "year" : 2014
    }, {
      "title" : "Weightedsequence problem: ASP vs CASP and declarative vs problem oriented solving",
      "author" : [ "Y. LIERLER", "S. SMITH", "M. TRUSZCZYŃSKI", "A. WESTLUND" ],
      "venue" : "Proceedings of the 14th International Symposium on Practical Aspects of Declarative Languages (PADL), C. V. Russo and N.-F. Zhou, Eds. Lecture Notes in Computer Science, vol. 7149. Springer Verlag, Berlin.",
      "citeRegEx" : "LIERLER et al\\.,? 2012",
      "shortCiteRegEx" : "LIERLER et al\\.",
      "year" : 2012
    }, {
      "title" : "Transition systems for model generators — a unifying approach",
      "author" : [ "Y. LIERLER", "M. TRUSZCZYŃSKI" ],
      "venue" : "Theory and Practice of Logic Programming, 27th Int’l. Conference on Logic Programming (ICLP’11) Special Issue 11, 4-5, 629–646.",
      "citeRegEx" : "LIERLER and TRUSZCZYŃSKI,? 2011",
      "shortCiteRegEx" : "LIERLER and TRUSZCZYŃSKI",
      "year" : 2011
    }, {
      "title" : "Nested expressions in logic programs",
      "author" : [ "V. LIFSCHITZ", "L.R. TANG", "H. TURNER" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 369–389.",
      "citeRegEx" : "LIFSCHITZ et al\\.,? 1999",
      "shortCiteRegEx" : "LIFSCHITZ et al\\.",
      "year" : 1999
    }, {
      "title" : "Answer set programming via mixed integer programming",
      "author" : [ "G. LIU", "T. JANHUNEN", "I. NIEMELÄ" ],
      "venue" : "Principles of Knowledge Representation and Reasoning: Proceedings of the 13th International Conference. AAAI Press, 32–42.",
      "citeRegEx" : "LIU et al\\.,? 2012",
      "shortCiteRegEx" : "LIU et al\\.",
      "year" : 2012
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V. MAREK", "M. TRUSZCZYŃSKI" ],
      "venue" : "The Logic Programming Paradigm: a 25-Year Perspective. Springer Verlag, 375–398.",
      "citeRegEx" : "MAREK and TRUSZCZYŃSKI,? 1999",
      "shortCiteRegEx" : "MAREK and TRUSZCZYŃSKI",
      "year" : 1999
    }, {
      "title" : "The design of the Zinc modelling language",
      "author" : [ "K. MARRIOTT", "N. NETHERCOTE", "R. RAFEH", "P.J. STUCKEY", "M. GARCIA DE LA BANDA", "M. WALLACE" ],
      "venue" : "Constraints 13, 3 (Sept.), 229–267.",
      "citeRegEx" : "MARRIOTT et al\\.,? 2008",
      "shortCiteRegEx" : "MARRIOTT et al\\.",
      "year" : 2008
    }, {
      "title" : "Integrating answer set programming and constraint logic programming",
      "author" : [ "V.S. MELLARKOD", "M. GELFOND", "Y. ZHANG" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 53, 1-4, 251–287.",
      "citeRegEx" : "MELLARKOD et al\\.,? 2008",
      "shortCiteRegEx" : "MELLARKOD et al\\.",
      "year" : 2008
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. NIEMELÄ" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 241–273.",
      "citeRegEx" : "NIEMELÄ,? 1999",
      "shortCiteRegEx" : "NIEMELÄ",
      "year" : 1999
    }, {
      "title" : "Extending the Smodels system with cardinality and weight constraints",
      "author" : [ "I. NIEMELÄ", "P. SIMONS" ],
      "venue" : "Logic-Based Artificial Intelligence, J. Minker, Ed. Kluwer, 491–521.",
      "citeRegEx" : "NIEMELÄ and SIMONS,? 2000",
      "shortCiteRegEx" : "NIEMELÄ and SIMONS",
      "year" : 2000
    }, {
      "title" : "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)",
      "author" : [ "R. NIEUWENHUIS", "A. OLIVERAS", "C. TINELLI" ],
      "venue" : "Journal of the ACM 53(6), 937–977.",
      "citeRegEx" : "NIEUWENHUIS et al\\.,? 2006",
      "shortCiteRegEx" : "NIEUWENHUIS et al\\.",
      "year" : 2006
    }, {
      "title" : "Constraint programming",
      "author" : [ "F. ROSSI", "P. VAN BEEK", "T. WALSH" ],
      "venue" : "Handbook of Knowledge Representation, F. van Harmelen, V. Lifschitz, and B. Porter, Eds. Elsevier, 181–212.",
      "citeRegEx" : "ROSSI et al\\.,? 2008",
      "shortCiteRegEx" : "ROSSI et al\\.",
      "year" : 2008
    }, {
      "title" : "Efficient constraint propagation engines",
      "author" : [ "C. SCHULTE", "P.J. STUCKEY" ],
      "venue" : "Transactions on Programming Languages and Systems .",
      "citeRegEx" : "SCHULTE and STUCKEY,? 2008",
      "shortCiteRegEx" : "SCHULTE and STUCKEY",
      "year" : 2008
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. SIMONS", "I. NIEMELÄ", "T. SOININEN" ],
      "venue" : "Artificial Intelligence 138, 181–234.",
      "citeRegEx" : "SIMONS et al\\.,? 2002",
      "shortCiteRegEx" : "SIMONS et al\\.",
      "year" : 2002
    }, {
      "title" : "SMT-based constraint answer set solver EZSMT (system description)",
      "author" : [ "B. SUSMAN", "Y. LIERLER" ],
      "venue" : "International Conference on Logic Programming (ICLP).",
      "citeRegEx" : "SUSMAN and LIERLER,? 2016",
      "shortCiteRegEx" : "SUSMAN and LIERLER",
      "year" : 2016
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A. VAN GELDER", "K. ROSS", "J. SCHLIPF" ],
      "venue" : "Journal of ACM 38, 3, 620–650.",
      "citeRegEx" : "GELDER et al\\.,? 1991",
      "shortCiteRegEx" : "GELDER et al\\.",
      "year" : 1991
    }, {
      "title" : "The IDP system: a model expansion system for an extension of classical logic",
      "author" : [ "J. WITTOCX", "M. MARIËN", "M. DENECKER" ],
      "venue" : "Proceedings of Workshop on Logic and Search, Computation of Structures from Declarative Descriptions (LaSh). electronic, 153–165. available at https://lirias.kuleuven.be/bitstream/ 123456789/229814/1/lash08.pdf.",
      "citeRegEx" : "WITTOCX et al\\.,? 2008",
      "shortCiteRegEx" : "WITTOCX et al\\.",
      "year" : 2008
    }, {
      "title" : "Efficient conflict driven learning in a Boolean satisfiability solver",
      "author" : [ "L. ZHANG", "C.F. MADIGAN", "M.W. MOSKEWICZ", "S. MALIK" ],
      "venue" : "Proceedings ICCAD-01. 279–285.",
      "citeRegEx" : "ZHANG et al\\.,? 2001",
      "shortCiteRegEx" : "ZHANG et al\\.",
      "year" : 2001
    }, {
      "title" : "The language features and architecture of B-Prolog",
      "author" : [ "ZHOU", "N.-F." ],
      "venue" : "Journal of Theory and Practice of Logic Programming (TPLP) 12, 1–2 (Jan), 189–218. Appendix A EZ – The Language of EZCSP",
      "citeRegEx" : "ZHOU and N..F.,? 2012",
      "shortCiteRegEx" : "ZHOU and N..F.",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "Such traditionally separate fields of AI as answer set programming (ASP) (Niemelä, 1999; Marek and Truszczyński, 1999; Brewka et al., 2011), propositional satisfiability (SAT) (Gomes et al.",
      "startOffset" : 73,
      "endOffset" : 139
    }, {
      "referenceID" : 28,
      "context" : ", 2011), propositional satisfiability (SAT) (Gomes et al., 2008), constraint (logic) programming (CSP/CLP) (Rossi et al.",
      "startOffset" : 44,
      "endOffset" : 64
    }, {
      "referenceID" : 43,
      "context" : ", 2008), constraint (logic) programming (CSP/CLP) (Rossi et al., 2008; Jaffar and Maher, 1994) are all representatives of distinct directions of research in automated reasoning.",
      "startOffset" : 50,
      "endOffset" : 94
    }, {
      "referenceID" : 29,
      "context" : ", 2008), constraint (logic) programming (CSP/CLP) (Rossi et al., 2008; Jaffar and Maher, 1994) are all representatives of distinct directions of research in automated reasoning.",
      "startOffset" : 50,
      "endOffset" : 94
    }, {
      "referenceID" : 29,
      "context" : "Constraint logic programming (Jaffar and Maher, 1994), satisfiability modulo theories (SMT) (Nieuwenhuis et al.",
      "startOffset" : 29,
      "endOffset" : 53
    }, {
      "referenceID" : 42,
      "context" : "Constraint logic programming (Jaffar and Maher, 1994), satisfiability modulo theories (SMT) (Nieuwenhuis et al., 2006), HEX-programs (Eiter et al.",
      "startOffset" : 92,
      "endOffset" : 118
    }, {
      "referenceID" : 18,
      "context" : ", 2006), HEX-programs (Eiter et al., 2005), and VI-programs (Calimeri et al.",
      "startOffset" : 22,
      "endOffset" : 42
    }, {
      "referenceID" : 6,
      "context" : ", 2005), and VI-programs (Calimeri et al., 2007) are all examples of this current.",
      "startOffset" : 25,
      "endOffset" : 48
    }, {
      "referenceID" : 19,
      "context" : "Various projects have focused on the intersection of ASP and CSP/CLP, which resulted in the development of a new field of study, often called constraint answer set programming (CASP) (Elkabani et al., 2004; Mellarkod et al., 2008; Gebser et al., 2009; Balduccini, 2009; Drescher and Walsh, 2011; Lierler, 2014).",
      "startOffset" : 183,
      "endOffset" : 310
    }, {
      "referenceID" : 39,
      "context" : "Various projects have focused on the intersection of ASP and CSP/CLP, which resulted in the development of a new field of study, often called constraint answer set programming (CASP) (Elkabani et al., 2004; Mellarkod et al., 2008; Gebser et al., 2009; Balduccini, 2009; Drescher and Walsh, 2011; Lierler, 2014).",
      "startOffset" : 183,
      "endOffset" : 310
    }, {
      "referenceID" : 23,
      "context" : "Various projects have focused on the intersection of ASP and CSP/CLP, which resulted in the development of a new field of study, often called constraint answer set programming (CASP) (Elkabani et al., 2004; Mellarkod et al., 2008; Gebser et al., 2009; Balduccini, 2009; Drescher and Walsh, 2011; Lierler, 2014).",
      "startOffset" : 183,
      "endOffset" : 310
    }, {
      "referenceID" : 1,
      "context" : "Various projects have focused on the intersection of ASP and CSP/CLP, which resulted in the development of a new field of study, often called constraint answer set programming (CASP) (Elkabani et al., 2004; Mellarkod et al., 2008; Gebser et al., 2009; Balduccini, 2009; Drescher and Walsh, 2011; Lierler, 2014).",
      "startOffset" : 183,
      "endOffset" : 310
    }, {
      "referenceID" : 15,
      "context" : "Various projects have focused on the intersection of ASP and CSP/CLP, which resulted in the development of a new field of study, often called constraint answer set programming (CASP) (Elkabani et al., 2004; Mellarkod et al., 2008; Gebser et al., 2009; Balduccini, 2009; Drescher and Walsh, 2011; Lierler, 2014).",
      "startOffset" : 183,
      "endOffset" : 310
    }, {
      "referenceID" : 32,
      "context" : "Various projects have focused on the intersection of ASP and CSP/CLP, which resulted in the development of a new field of study, often called constraint answer set programming (CASP) (Elkabani et al., 2004; Mellarkod et al., 2008; Gebser et al., 2009; Balduccini, 2009; Drescher and Walsh, 2011; Lierler, 2014).",
      "startOffset" : 183,
      "endOffset" : 310
    }, {
      "referenceID" : 39,
      "context" : "This new area has already demonstrated promising results, including the development of CASP solvers ACSOLVER (Mellarkod et al., 2008), CLINGCON (Gebser et al.",
      "startOffset" : 109,
      "endOffset" : 133
    }, {
      "referenceID" : 23,
      "context" : ", 2008), CLINGCON (Gebser et al., 2009), EZCSP (Balduccini, 2009), IDP (Wittocx et al.",
      "startOffset" : 18,
      "endOffset" : 39
    }, {
      "referenceID" : 1,
      "context" : ", 2009), EZCSP (Balduccini, 2009), IDP (Wittocx et al.",
      "startOffset" : 15,
      "endOffset" : 33
    }, {
      "referenceID" : 48,
      "context" : ", 2009), EZCSP (Balduccini, 2009), IDP (Wittocx et al., 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al.",
      "startOffset" : 39,
      "endOffset" : 61
    }, {
      "referenceID" : 15,
      "context" : ", 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al.",
      "startOffset" : 14,
      "endOffset" : 40
    }, {
      "referenceID" : 30,
      "context" : ", 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al., 2011), MINGO (Liu et al.",
      "startOffset" : 48,
      "endOffset" : 71
    }, {
      "referenceID" : 36,
      "context" : ", 2011), MINGO (Liu et al., 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016).",
      "startOffset" : 15,
      "endOffset" : 33
    }, {
      "referenceID" : 4,
      "context" : ", 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016).",
      "startOffset" : 19,
      "endOffset" : 46
    }, {
      "referenceID" : 46,
      "context" : ", 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016).",
      "startOffset" : 58,
      "endOffset" : 84
    }, {
      "referenceID" : 1,
      "context" : ", 2009; Balduccini, 2009; Drescher and Walsh, 2011; Lierler, 2014). Constraint answer set programming allows one to combine the best of two different automated reasoning worlds: (1) the non-monotonic modeling capabilities and SAT-like solving technology of ASP and (2) constraint processing techniques for effective reasoning over non-Boolean constructs. This new area has already demonstrated promising results, including the development of CASP solvers ACSOLVER (Mellarkod et al., 2008), CLINGCON (Gebser et al., 2009), EZCSP (Balduccini, 2009), IDP (Wittocx et al., 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al., 2011), MINGO (Liu et al., 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016). CASP opens new horizons for declarative programming applications. For instance, research by Balduccini (2011) on the design of CASP language EZCSP and on the corresponding solver, which is nowadays one of the mainstream representatives of CASP systems, yielded an elegant, declarative solution to a complex industrial scheduling problem.",
      "startOffset" : 8,
      "endOffset" : 853
    }, {
      "referenceID" : 1,
      "context" : "The paper provides the first comprehensive account of the constraint answer set solver EZCSP (Balduccini, 2009), a long-time representative of the CASP subfield.",
      "startOffset" : 93,
      "endOffset" : 111
    }, {
      "referenceID" : 1,
      "context" : "The paper provides the first comprehensive account of the constraint answer set solver EZCSP (Balduccini, 2009), a long-time representative of the CASP subfield. We define the language of EZCSP and illustrate its use on several examples. We also account for algorithmic and implementation details behind EZCSP. 2. To present the EZCSP algorithm and prove formal claims about the system, we develop an extension of the transition systems proposed by Nieuwenhuis et al. (2006) for capturing SAT/SMT algorithms.",
      "startOffset" : 94,
      "endOffset" : 475
    }, {
      "referenceID" : 1,
      "context" : "Parts of this paper have been earlier presented at ASPOCP 2009 (Balduccini, 2009) and at PADL 2012 (Balduccini and Lierler, 2012).",
      "startOffset" : 63,
      "endOffset" : 81
    }, {
      "referenceID" : 3,
      "context" : "Parts of this paper have been earlier presented at ASPOCP 2009 (Balduccini, 2009) and at PADL 2012 (Balduccini and Lierler, 2012).",
      "startOffset" : 99,
      "endOffset" : 129
    }, {
      "referenceID" : 35,
      "context" : "This is a special case of programs with nested expressions (Lifschitz et al., 1999).",
      "startOffset" : 59,
      "endOffset" : 83
    }, {
      "referenceID" : 35,
      "context" : "We now restate the definition of an answer set due to Lifschitz et al. (1999) in a form convenient for our purposes.",
      "startOffset" : 54,
      "endOffset" : 78
    }, {
      "referenceID" : 20,
      "context" : "A choice rule construct {a} ← B (Niemelä and Simons, 2000) of the LPARSE language can be seen as an abbreviation for a rule a ← not not a,B (Ferraris and Lifschitz, 2005).",
      "startOffset" : 140,
      "endOffset" : 170
    }, {
      "referenceID" : 35,
      "context" : "Theorem 1 (Proposition 2 from (Lifschitz et al., 1999)) For a program Π, a set Γ of denials, and a consistent and complete set M of literals over At(Π), M + is an answer set of Π ∪ Γ if and only if M + is an answer set of Π and M is a model of Γ .",
      "startOffset" : 30,
      "endOffset" : 54
    }, {
      "referenceID" : 1,
      "context" : "The origins of the constraint answer set solver EZCSP and of its language go back to the development of an approach for integrating ASP and constraint programming, in which ASP is viewed as a specification language for constraint satisfaction problems (Balduccini, 2009).",
      "startOffset" : 252,
      "endOffset" : 270
    }, {
      "referenceID" : 38,
      "context" : "The MiniZinc language (Marriott et al., 2008) is another remarkable effort toward a declarative modeling framework supported by the constraint satisfaction technology.",
      "startOffset" : 22,
      "endOffset" : 45
    }, {
      "referenceID" : 45,
      "context" : "SMODELS (Simons et al., 2002) SICSTUS PROLOG (Carlsson and Mildner, 2012) CLASP (Gebser et al.",
      "startOffset" : 8,
      "endOffset" : 29
    }, {
      "referenceID" : 9,
      "context" : ", 2002) SICSTUS PROLOG (Carlsson and Mildner, 2012) CLASP (Gebser et al.",
      "startOffset" : 23,
      "endOffset" : 51
    }, {
      "referenceID" : 21,
      "context" : ", 2002) SICSTUS PROLOG (Carlsson and Mildner, 2012) CLASP (Gebser et al., 2007) BPROLOG (Zhou, 2012) CMODELS (Giunchiglia et al.",
      "startOffset" : 58,
      "endOffset" : 79
    }, {
      "referenceID" : 27,
      "context" : ", 2007) BPROLOG (Zhou, 2012) CMODELS (Giunchiglia et al., 2006)",
      "startOffset" : 37,
      "endOffset" : 63
    }, {
      "referenceID" : 1,
      "context" : "2 (Balduccini, 2009) refers to black-box integration of EZCSP as lightweight integration of ASP and constraint programming.",
      "startOffset" : 2,
      "endOffset" : 20
    }, {
      "referenceID" : 11,
      "context" : "The Davis-Putnam-Logemann-Loveland (DPLL) procedure (Davis et al., 1962) is a backtracking-based search algorithm for deciding the satisfiability of a propositional CNF formula.",
      "startOffset" : 52,
      "endOffset" : 72
    }, {
      "referenceID" : 44,
      "context" : "It utilizes answer set solver CLASP as the base solver and constraint processing system GECODE (Schulte and Stuckey, 2008) as the theory solver.",
      "startOffset" : 95,
      "endOffset" : 122
    }, {
      "referenceID" : 49,
      "context" : "To make these integration schemas perform efficiently, learning – a sophisticated solving technique stemming from SAT (Zhang et al., 2001) – is used to capture the information (explanation)",
      "startOffset" : 118,
      "endOffset" : 138
    }, {
      "referenceID" : 11,
      "context" : "The Davis-Putnam-Logemann-Loveland (DPLL) procedure (Davis et al., 1962) is a backtracking-based search algorithm for deciding the satisfiability of a propositional CNF formula. DPLL-like procedures form the basis for most modern SAT solvers as well as answer set solvers. If a DPLL-like procedure underlies a base solver in the SMT and CASP tasks then it opens a door to several refinements of black-box integration. We now describe these refinements. In the black-box integration approach a base solver is invoked iteratively. Consider the SMT task: a CNF formula Fi+1 of the i + 1th iteration to a SAT solver consists of a CNF formula Fi of the i th iteration and an additional clause (or a set of clauses). Modern DPLLlike solvers commonly implement such technique as incremental solving. For instance, incremental SAT-solving allows the user to solve several SAT problems F1, . . . ,Fn one after another (using a single invocation of the solver), if Fi+1 results from Fi by adding clauses. In turn, the solution to Fi+1 may benefit from the knowledge obtained during solving F1, . . . ,Fi . Various modern SAT-solvers, including MINISAT (Eén and Biere, 2005; Eén and Sörensson, 2003), implement interfaces for incremental SAT solving. Similarly, the answer set solver CMODELS implements an interface that allows the user to solve several ASP problems Π1, . . . ,Πn one after another, if Πi+1 results from Πi by adding a set of denials. It is natural to utilize incremental DPLL-like procedures for enhancing the black-box integration protocol: we call this refinement grey-box integration. In this approach, rather than invoking a base solver from scratch, an incremental interface provided by a solver is used to implement the iterative process. CASP solver EZCSP implements grey-box integration using the above mentioned incremental interface by CMODELS. Nieuwenhuis et al. (2006) also review such integration techniques used in SMT as online SAT solver and theory propagation.",
      "startOffset" : 53,
      "endOffset" : 1888
    }, {
      "referenceID" : 21,
      "context" : "The Grounder component of the architecture transforms the resulting program into its propositional equivalent, a regular program, using an off-the-shelf grounder such as GRINGO (Gebser et al., 2007).",
      "startOffset" : 177,
      "endOffset" : 198
    }, {
      "referenceID" : 1,
      "context" : "The interested reader can refer to (Balduccini, 2009) for a complete description of the translation process.",
      "startOffset" : 35,
      "endOffset" : 53
    }, {
      "referenceID" : 23,
      "context" : "In earlier work, Lierler (2014) demonstrated how the CASP language CLINGCON (Gebser et al., 2009) as well as the essential subset of the CASP language AC of ACSOLVER (Mellarkod et al.",
      "startOffset" : 76,
      "endOffset" : 97
    }, {
      "referenceID" : 39,
      "context" : ", 2009) as well as the essential subset of the CASP language AC of ACSOLVER (Mellarkod et al., 2008) are captured by CA programs.",
      "startOffset" : 76,
      "endOffset" : 100
    }, {
      "referenceID" : 28,
      "context" : "In earlier work, Lierler (2014) demonstrated how the CASP language CLINGCON (Gebser et al.",
      "startOffset" : 17,
      "endOffset" : 32
    }, {
      "referenceID" : 21,
      "context" : "In earlier work, Lierler (2014) demonstrated how the CASP language CLINGCON (Gebser et al., 2009) as well as the essential subset of the CASP language AC of ACSOLVER (Mellarkod et al., 2008) are captured by CA programs. Based on those results, the algorithm described in this section can be immediately used as an alternative to the procedures implemented in systems CLINGCON and ACSOLVER. Usually, software systems are described by means of pseudocode. The fact that EZCSP system follows an “all-solvers-in-one” philosophy combined with a variety of integration schemas complicates the task of describing it in this way. For example, one configuration of EZCSP may invoke answer set solver CLASP via black-box integration for enumerating answer sets of an asp-abstraction of CA program, whereas another may invoke CMODELS via grey-box integration for the same task. Thus, rather than committing ourselves to a pseudocode description, we follow a path pioneered by Nieuwenhuis et al. (2006). In",
      "startOffset" : 77,
      "endOffset" : 991
    }, {
      "referenceID" : 0,
      "context" : "This is not an issue, however: stand alone answer set solvers have been analyzed and compared theoretically in the literature (Anger et al., 2006), (Giunchiglia et al.",
      "startOffset" : 126,
      "endOffset" : 146
    }, {
      "referenceID" : 26,
      "context" : ", 2006), (Giunchiglia et al., 2008) (Lierler and Truszczyński, 2011) as well as empirically in biennial answer set programming competitions (Gebser et al.",
      "startOffset" : 9,
      "endOffset" : 35
    }, {
      "referenceID" : 21,
      "context" : ", 2008) (Lierler and Truszczyński, 2011) as well as empirically in biennial answer set programming competitions (Gebser et al., 2007), (Denecker et al.",
      "startOffset" : 112,
      "endOffset" : 133
    }, {
      "referenceID" : 13,
      "context" : ", 2007), (Denecker et al., 2009), (Calimeri et al.",
      "startOffset" : 9,
      "endOffset" : 32
    }, {
      "referenceID" : 8,
      "context" : ", 2009), (Calimeri et al., 2011).",
      "startOffset" : 9,
      "endOffset" : 32
    }, {
      "referenceID" : 21,
      "context" : "Lierler (2014) designed a similar abstract framework that captures the EZCSP algorithm in two cases: (a) when EZCSP invokes answer set solver SMODELS via black-box integration for enumerating answer sets of aspabstraction program, and (b) when EZCSP invokes answer set solver CLASP via black-box integration.",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 33,
      "context" : "In this work we compare and contrast different integration schemas of hybrid solvers on three application domains that stem from various subareas of computer science: weightedsequence (Lierler et al., 2012), incremental scheduling (Balduccini, 2011), reverse folding.",
      "startOffset" : 184,
      "endOffset" : 206
    }, {
      "referenceID" : 2,
      "context" : ", 2012), incremental scheduling (Balduccini, 2011), reverse folding.",
      "startOffset" : 32,
      "endOffset" : 50
    }, {
      "referenceID" : 33,
      "context" : "The problem is not only practically relevant but proved to be hard for current ASP and CASP technology as illustrated in (Lierler et al., 2012).",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 8,
      "context" : "All benchmark domains are from the Third Answer Set Programming Competition – 2011 (ASPCOMP) (Calimeri et al., 2011), in particular, the Model and Solve track.",
      "startOffset" : 93,
      "endOffset" : 116
    }, {
      "referenceID" : 33,
      "context" : "We refer the reader to (Lierler et al., 2012) for the details of pure-ASP encoding SEQ++.",
      "startOffset" : 23,
      "endOffset" : 45
    }, {
      "referenceID" : 31,
      "context" : "Its key features are inspired by the important industrial problem of finding an optimal join order by cost-based query optimizers in database systems. Lierler et al. (2012) provides a complete description of the problem itself as well as the formalization named SEQ++ that became the encoding used in the present paper.",
      "startOffset" : 88,
      "endOffset" : 173
    }, {
      "referenceID" : 2,
      "context" : "We direct the reader to (Balduccini, 2011) for more details on this domain.",
      "startOffset" : 24,
      "endOffset" : 42
    }, {
      "referenceID" : 3,
      "context" : "The determination is based on the technique described in (Balduccini and Lierler, 2012).",
      "startOffset" : 57,
      "endOffset" : 87
    }, {
      "referenceID" : 14,
      "context" : "Thus, we resorted to the encoding described in (Dovier et al., 2011).",
      "startOffset" : 47,
      "endOffset" : 68
    }, {
      "referenceID" : 25,
      "context" : "This encoding leverages a mapping from action language B (Gelfond and Lifschitz, 1998) statements to numerical constraints, which are then solved by a CLP system.",
      "startOffset" : 57,
      "endOffset" : 86
    }, {
      "referenceID" : 39,
      "context" : "In the introduction we mentioned solvers ACSOLVER (Mellarkod et al., 2008), CLINGCON (Gebser et al.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 23,
      "context" : ", 2008), CLINGCON (Gebser et al., 2009), IDP (Wittocx et al.",
      "startOffset" : 18,
      "endOffset" : 39
    }, {
      "referenceID" : 48,
      "context" : ", 2009), IDP (Wittocx et al., 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al.",
      "startOffset" : 13,
      "endOffset" : 35
    }, {
      "referenceID" : 15,
      "context" : ", 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al.",
      "startOffset" : 14,
      "endOffset" : 40
    }, {
      "referenceID" : 30,
      "context" : ", 2008), INCA (Drescher and Walsh, 2011), DINGO (Janhunen et al., 2011), MINGO (Liu et al.",
      "startOffset" : 48,
      "endOffset" : 71
    }, {
      "referenceID" : 36,
      "context" : ", 2011), MINGO (Liu et al., 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016).",
      "startOffset" : 15,
      "endOffset" : 33
    }, {
      "referenceID" : 4,
      "context" : ", 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016).",
      "startOffset" : 19,
      "endOffset" : 46
    }, {
      "referenceID" : 46,
      "context" : ", 2012), ASPMT2SMT (Bartholomew and Lee, 2014), and EZSMT (Susman and Lierler, 2016).",
      "startOffset" : 58,
      "endOffset" : 84
    }, {
      "referenceID" : 45,
      "context" : "ACSOLVER SMODELS (Simons et al., 2002) constraint logic programming systems CLINGCON CLASP (Gebser et al.",
      "startOffset" : 17,
      "endOffset" : 38
    }, {
      "referenceID" : 21,
      "context" : ", 2002) constraint logic programming systems CLINGCON CLASP (Gebser et al., 2007) GECODE (Schulte and Stuckey, 2008)",
      "startOffset" : 60,
      "endOffset" : 81
    }, {
      "referenceID" : 44,
      "context" : ", 2007) GECODE (Schulte and Stuckey, 2008)",
      "startOffset" : 15,
      "endOffset" : 42
    }, {
      "referenceID" : 10,
      "context" : "IDP MINISAT(ID) (Cat et al., 2014) GECODE (Schulte and Stuckey, 2008)",
      "startOffset" : 16,
      "endOffset" : 34
    }, {
      "referenceID" : 44,
      "context" : ", 2014) GECODE (Schulte and Stuckey, 2008)",
      "startOffset" : 15,
      "endOffset" : 42
    }, {
      "referenceID" : 21,
      "context" : "INCA CLASP (Gebser et al., 2007) its own CP solver",
      "startOffset" : 11,
      "endOffset" : 32
    }, {
      "referenceID" : 46,
      "context" : "The EZSMT (Susman and Lierler, 2016) solver and the ASPMT2SMT (Bartholomew and Lee, 2014) solvers utilize SMT solvers to process CA programs.",
      "startOffset" : 10,
      "endOffset" : 36
    }, {
      "referenceID" : 4,
      "context" : "The EZSMT (Susman and Lierler, 2016) solver and the ASPMT2SMT (Bartholomew and Lee, 2014) solvers utilize SMT solvers to process CA programs.",
      "startOffset" : 62,
      "endOffset" : 89
    }, {
      "referenceID" : 4,
      "context" : "The EZSMT (Susman and Lierler, 2016) solver and the ASPMT2SMT (Bartholomew and Lee, 2014) solvers utilize SMT solvers to process CA programs. Both of these systems may only deal with tight programs. They allow for arbitrary integer linear constraints. None of the SMT-based CASP solvers allow for global constraints in their programs due to the underlying solving technology. Last but not least, the solver MINGO translates CA programs into mixed integer programming expressions and then utilizes IBM ILOG CPLEX system to find solutions. Susman and Lierler (2016) provide an experimental analysis of systems from all of the families mentioned.",
      "startOffset" : 63,
      "endOffset" : 564
    }, {
      "referenceID" : 8,
      "context" : "For the comparison, we used three challenging benchmark problems from the Third Answer Set Programming Competition – 2011 (Calimeri et al., 2011).",
      "startOffset" : 122,
      "endOffset" : 145
    } ],
    "year" : 2017,
    "abstractText" : "Researchers in answer set programming and constraint programming have spent significant efforts in the development of hybrid languages and solving algorithms combining the strengths of these traditionally separate fields. These efforts resulted in a new research area: constraint answer set programming. Constraint answer set programming languages and systems proved to be successful at providing declarative, yet efficient solutions to problems involving hybrid reasoning tasks. One of the main contributions of this paper is the first comprehensive account of the constraint answer set language and solver EZCSP, a mainstream representative of this research area that has been used in various successful applications. We also develop an extension of the transition systems proposed by Nieuwenhuis et al. in 2006 to capture Boolean satisfiability solvers. We use this extension to describe the EZCSP algorithm and prove formal claims about it. The design and algorithmic details behind EZCSP clearly demonstrate that the development of the hybrid systems of this kind is challenging. Many questions arise when one faces various design choices in an attempt to maximize system’s benefits. One of the key decisions that a developer of a hybrid solver makes is settling on a particular integration schema within its implementation. Thus, another important contribution of this paper is a thorough case study based on EZCSP, focused on the various integration schemas that it provides. Under consideration in Theory and Practice of Logic Programming (TPLP).",
    "creator" : "LaTeX with hyperref package"
  }
}