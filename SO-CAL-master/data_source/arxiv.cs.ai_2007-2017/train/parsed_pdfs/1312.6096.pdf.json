{
  "name" : "1312.6096.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Properties of Answer Set Programming with Convex Generalized Atoms",
    "authors" : [ "Mario Alviano", "Wolfgang Faber" ],
    "emails" : [ "alviano@mat.unical.it", "faber@mat.unical.it" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Various extensions of the basic Answer Set Programming language have been proposed by allowing more general atoms in rule bodies, for example aggregate atoms, HEX atoms, dl-atoms, generalized quantifiers, or abstract constraints. A number of semantics have been proposed for such programs, most notably the FLP semantics [7] and a number of coinciding semantics that we will collectively refer to as PSP semantics (from Pelov, Son, and Pontelli) [13,17]. All of these semantics coincide with traditional ASP semantics when no generalized atoms are present. Moreover, they coincide on programs that have atomic rule heads and contain only monotonic generalized atoms. In [9] it is furthermore hinted that the semantics also coincide on programs that have atomic rule heads and contain only convex generalized atoms. However, no formal proof is available for this claim, and the informal explanation given in [9] is not as general as it could be, as we will show.\nIn this paper, we undertake a deeper investigation on the similarities and differences between the FLP and PSP semantics. In order to do this, we consider a simplified, yet expressive propositional language: sets of rules with atomic heads and bodies that are formed of a single “structure,” which are functions mapping interpretations to Boolean values1. Clearly, structures encompass atoms, literals, and conjunctions thereof, but can\n1 Note that (apart from the name) there is no connection to structures in first-order logic.\nar X\niv :1\n31 2.\n60 96\nv1 [\ncs .A\nI] 2\n0 D\nec 2\nrepresent any propositional formula, generalized atom, or conjunctions of generalized atoms. Each structure has an associated domain, which is the set of propositional atoms on which the structure’s truth valuation depends. We can then classify the structures by their semantic properties, in particular, we will focus on the class of convex structures, which have single contiguous areas of truth in the lattice of interpretations. Convex structures include atoms and literals, and they are closed under conjunction (but not under negation or disjunction).\nWe first formally prove the claim that the FLP and PSP semantics coincide on programs with convex structures, as originally reported in [9]. We will then move on to the main focus of this paper, trying to understand whether there is any larger class for which the semantics coincide. It is known that for programs with general structures all PSP answer sets are FLP answer sets, but not all FLP answer sets are PSP answer sets. The precise boundary for exhibiting the semantic difference is instead unknown.\nWe will approach this question using complexity arguments. Recently, we could show that convex structures form the precise boundary for a complexity jump in the polynomial hierarchy on cautious reasoning (but most other decision problems as well) for the FLP semantics. Cautious reasoning isΠP2 -complete for the FLP semantics when allowing any non-convex structure and its variants (renaming atoms) in the input program, but it is coNP -complete for convex structures. When considering the PSP semantics, cautious reasoning is also ΠP2 -complete when allowing any kind of structures in the input. This follows from a result in [13], and we provide an alternative proof in this paper. Analyzing this proof, it becomes clear that there is a different source of complexity for PSP than for FLP.\nWe then show that this different source of complexity also yields a different shape of the boundary for the complexity jump in PSP. Indeed, we first show that for a simple non-convex structure, cautious reasoning is still in coNP for the PSP semantics, while the problem is ΠP2 -hard in the presence of this structure for the FLP semantics. It turns out that the same argument works for many non-convex structures, in particular, for all structures with a domain size bounded by a constant. The domain size therefore serves as a parameter that simplifies the complexity of the problem for the PSP semantics (unless the polynomial hierarchy collapses to its first level). This also means that the complexity boundary for PSP has a non-uniform shape, in the sense that an infinite number of different non-convex structures must be available for obtainingΠP2 -hardness for cautious reasoning. This is in contrast to the FLP semantics, where the presence of a single non-convex structure is sufficient."
    }, {
      "heading" : "2 Syntax and Semantics",
      "text" : "In this section we first introduce the syntax used in the paper. This is mainly based on the notion of structures, i.e., functions mapping interpretations into Boolean truth values. Then, we introduce few semantic notions and in particular we characterize structures in terms of monotonicity. Finally, we define the two semantics analyzed in this paper, namely FLP and PSP."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "Let U be a fixed, countable set of propositional atoms. An interpretation I is a subset of U . A structure S on U is a mapping of interpretations into Boolean truth values. Each structure S has an associated, finite domain DS ⊂ U , indicating those atoms that are relevant to the structure.\nExample 1. A structure S1 modeling a conjunction a1, . . . , an (n ≥ 0) of propositional atoms is such that DS1 = {a1, . . . , an} and, for every interpretation I , S1 maps I to true if and only if DS1 ⊆ I .\nA structure S2 modeling a conjunction a1, . . . , am, not am+1, . . . , not an (n ≥ m ≥ 0) of literals, where a1, . . . , an are propositional atoms and not denotes negation as failure, is such that DS2 = {a1, . . . , an} and, for every interpretation I , S2 maps I to true if and only if {a1, . . . , am} ⊆ I and {am+1, . . . , an} ∩ I = ∅.\nA structure S3 modeling an aggregate COUNT ({a1, . . . , an}) 6= k (n ≥ k ≥ 0), where a1, . . . , an are propositional atoms, is such that DS3 = {a1, . . . , an} and, for every interpretation I , S3 maps I to true if and only if |DS3 ∩ I| 6= k.\nA general rule r is of the following form:\nH(r)← B(r) (1)\nwhere H(r) is a propositional atom in U referred as the head of r, and B(r) is a structure on U called the body of r. A general program P is a set of general rules.\nExample 2. Let S4 map to true any interpretation I such that I ∩ {a, b} 6= {b}, and let S5 map to true any interpretation I such that I ∩ {a, b} 6= {a}. Hence, program P1 = {a← S4; b← S5} is equivalent to the following program with aggregates:\na← SUM ({a = 1, b = −1}) ≥ 0 b← SUM ({a = −1, b = 1}) ≥ 0\nNote that no particular assumption is made on the syntax of rule bodies; in the case of normal propositional logic programs these structures are conjunctions of literals. We assume that structures are closed under propositional variants, that is, if S is a structure, for any bijection σ : U → U , also Sσ is a structure, and the associated domain is DSσ = {σ(a) | a ∈ DS}.\nExample 3. Consider S4 and S5 from Example 2, and a bijection σ1 such that σ1(a) = b. Hence, S5 = S4σ1, that is, S5 is a variant of S4.\nGiven a set of structures S, by datalogS we refer to the class of programs that may contain only the following rule bodies: structures corresponding to conjunctions of atoms, any structure S ∈ S, or any of its variants Sσ.\nExample 4. For every n ≥ m ≥ 0, let Sm,n denote the structure S2 from Example 1. The class of normal datalog programs is datalog{S m,n|n≥m≥0}.\nNote that this syntax does not explicitly allow for negated structures. One can, however, choose the complementary structure for simulating negation. This would be akin to the “negation as complement” interpretation of negated aggregates that is prevalent in the literature."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "Let I ⊆ U be an interpretation. I is a model for a structure S, denoted I |= S, if S maps I to true. Otherwise, if S maps I to false, I is not a model of S, denoted I 6|= S. We require that atoms outside the domain of S are irrelevant for modelhood, that is, for any interpretation I and X ⊆ U \\ DS it holds that I |= S if and only if I ∪ X |= S. Moreover, for any bijection σ : U → U , let Iσ = {σ(a) | a ∈ I}, and we require that Iσ |= Sσ if and only if I |= S. I is a model of a rule r of the form (1), denoted I |= r, if H(r) ∈ I whenever I |= B(r). I is a model of a program P , denoted I |= P , if I |= r for every rule r ∈ P .\nExample 5. Consider program P1 from Example 2. It can be observed that ∅ 6|= P1 and {a, b} 6|= P1 (both rules have true bodies but false heads), while {a} |= P1 and {b} |= P1.\nStructures can be characterized in terms of monotonicity as follows.\nDefinition 1 (Monotone Structures). A structure S is monotonic if for all pairs X,Y of interpretations such that X ⊂ Y , X |= S implies Y |= S.\nDefinition 2 (Antimonotone Structures). A structure S is antimonotonic if for all pairs Y, Z of interpretations such that Y ⊂ Z, Z |= S implies Y |= S.\nDefinition 3 (Convex Structures). A structure S is convex if for all triples X,Y, Z of interpretations such that X ⊂ Y ⊂ Z, X |= S and Z |= S implies Y |= S.\nNote that monotonic and antimonotonic structures are convex. Moreover, note that convex structures are closed under conjunction (but not under disjunction or negation).\nExample 6. Structure Sm,n from Example 4 is convex in general; it is monotonic if m = n, and antimonotonic if m = 0. Structure S3 from Example 1, instead, is nonconvex if n > k > 0; it is monotonic if k = 0, and antimonotonic if n = k.\nWe first describe a reduct-based semantics, usually referred to as FLP, which has been described and analyzed in [6,7].\nDefinition 4 (FLP Reduct). The FLP reduct P I of a program P with respect to I is defined as the set {r ∈ P | I |= B(r)}.\nDefinition 5 (FLP Answer Sets). I is an FLP answer set of P if I |= P I and for each J ⊂ I it holds that J 6|= P I .\nExample 7. Consider program P1 from Example 2 and the interpretation {a}. The reduct P {a}1 is {a ← S4}. Since {a} is a minimal model of the reduct, {a} is an FLP answer set of P1. Similarly, it can be observed that {b} is another FLP answer set. Actually, these are the only FLP answer sets of the program.\nWe will next describe a different semantics, using the definition of [17], called “fixpoint answer set” in that paper. Theorem 3 in [17] shows that it is actually equivalent to the two-valued fix-point of ultimate approximations of generalized atoms in [13]2, and therefore with stable models for ultimate approximations of aggregates as defined in [14]. We will refer to it as PSP to abbreviate Pelov/Son/Pontelli, the names most frequently associated with this semantics.\nDefinition 6 (Conditional Satisfaction). A structure S on U is conditionally satisfied by a pair of interpretations (I,M), denoted (I,M) |= S, if J |= S for each J such that I ⊆ J ⊆M .\nDefinition 7 (PSP Answer Sets). An interpretation M is a PSP answer set if M is the least fixpoint of the following operator:\nKPM (I) = {H(r) | r ∈ P ∧ (I,M) |= B(r)}. (2)\nExample 8. Consider program P1 from Example 2 and the interpretation {a}. The least fixpoint of KP1{a} is {a}. In fact, ∅ |= S4 and {a} |= S4, hence (∅, {a}) |= S4, while {a} 6|= S5 and thus (∅, {a}) 6|= S5 and ({a}, {a}) 6|= S5. Therefore, {a} is a PSP answer set. Also {b} is a PSP answer set.\nOn programs considered in this paper, PSP answer sets also coincide with “answer sets” defined in [18] (by virtue of Proposition 10 in [18]) and “well-justified FLP answer sets” of [15] (by virtue of Theorem 5 in [15]). The latter is particularly interesting, as it is defined by first forming the FLP reduct. Indeed, as shown in [15], the operator KPM can be equivalently defined as follows:\nKPM (I) = {H(r) | r ∈ PM ∧ (I,M) |= B(r)}. (3)\nThere are several other semantic definitions on programs that have some restrictions on the admissible structures, which also coincide with the PSP semantics on programs as defined in this paper with the respective structure restriction. Examples are [12] for monotonic structures (that are also allowed to occur in rule heads in that paper), or [16] that allows for structures corresponding to cardinality and weight constraints and largely coincide with the PSP semantics (see [13] for a discussion on structures on which the semantics coincides).\nIn this paper we are mainly interested in cautious reasoning, defined next.\nDefinition 8 (Cautious Reasoning). A propositional atom a is a cautious consequence of a program P under FLP (resp. PSP) semantics, denoted P |=FLPc a (resp. P |=PSPc a), if a belongs to all FLP (resp. PSP) answer set of P .\nExample 9. Consider program P1 from Example 2. We have P1 6|=FLPc a and P1 6|=FLPc b, and similar for PSP semantics. If we add a← b and b← a to the program, then there is only one FLP answer set, namely {a, b}, and no PSP answer sets. In this case a and b are cautious consequences of the program (under both semantics).\n2 There is an even closer relationship, as the operator KPM (I) of [17] coincides with φaggr,1P (I,M) defined in [13], as shown in the appendix of [17]"
    }, {
      "heading" : "3 Exploring the Relationship between the FLP and PSP Semantics",
      "text" : "In this section, we examine in detail how the FLP and PSP semantics relate. We shall proceed in three steps. First, we formally prove that FLP and PSP semantics coincide on programs with convex structures in Section 3.1. Next, we turn towards complexity as a tool to understand whether there can be any larger class of coinciding programs. We start in Section 3.2 with a result that shows that programs without restrictions exhibit the same complexity under both FLP and PSP semantics. However, it is known that the semantics do not coincide for programs without restrictions, and we examine the complexity proofs to highlight the different complexity sources. These findings are then applied in Section 3.3 in order to identify programs with bounded non-convex structures, on which the complexities for FLP and PSP semantics differ. Under usual complexity assumptions, this also implies that programs with convex aggregates is the largest class of programs on which FLP and PSP coincide."
    }, {
      "heading" : "3.1 Unison: Convex Structures",
      "text" : "In this section we show that for programs with convex aggregates the FLP and PSP semantics coincide. In [9] it is stated that many semantics (and in particular, FLP and PSP) “agree on [...] programs with convex aggregates” because “they can be regarded as special programs with monotone constraints.” However, the comment on regarding convex aggregates as monotone constraints relies on a transformation described in [10] that transforms convex structures into conjunctions of positive and negated monotone constraints. Since our language does not explicitly allow negation, and in particular since convex structures are not closed under negation, we next prove in a more direct manner that the FLP and PSP semantics coincide on convex structures.\nOne direction of the proof relies on the well-known more general fact that each PSP answer set is also an FLP answer set. This has been stated as Theorem 2 in [17] and Proposition 8.1 in [14].\nTheorem 1. Let P be program whose body structures are convex, and let M be an interpretation. M is an FLP answer set of P if and only if M is an PSP answer set of P .\nProof. The left implication follows from Theorem 2 in [17]. For the right implication, let M be an FLP answer set of P . Let K0 := ∅, Ki+1 := KPM (Ki) for i ≥ 0, and let K be the fixpoint of this sequence. Since M is a minimal model of PM by definition of FLP answer set, we can prove the claim by showing (i) K |= PM and (ii) K ⊆M .\n(i) Consider a rule r ∈ PM such that K |= B(r). We have to show H(r) ∈ K. Since r ∈ PM , M |= B(r) holds. Thus, (K,M) |= B(r) and therefore H(r) ∈ K.\n(ii) We prove Ki ⊆ M for each i ≥ 0. We use induction on i. The base case is trivially true as K0 = ∅ ⊆ M . Suppose Ki ⊆ M for some i ≥ 0 in order to prove Ki+1 ⊆ M . By definition of KPM , for each a ∈ Ki+1 there is r ∈ PM such that H(r) = a and (Ki,M) |= B(r). Thus, M |= B(r), which implies a ∈M . ut\nTherefore, programs with convex structures form a class of programs for which the FLP and PSP semantics coincide. In the following, we will show that it is likely also the largest class for which this holds."
    }, {
      "heading" : "3.2 Consonance: Complexity of Unrestricted Structures",
      "text" : "In this section we will examine the computational impact of allowing non-convex structures. We will limit ourselves to structures for which the truth value with respect to an interpretation can be determined in polynomial time. Moreover, we will focus on cautious reasoning, but similar considerations apply also to related problems such as brave reasoning, answer set existence, or answer set checking.\nIt is known that cautious reasoning over programs with arbitrary structures under the FLP semantics is ΠP2 -complete in general, as shown in [7]. Pelov has shown Σ P 2 - completeness for deciding the existence of PSP answer sets in [13], from which ΠP2 - completeness for cautious reasoning under the PSP semantics can be derived. We formally state this result now and provide a different proof than Pelov’s that will more directly lead to the subsequent considerations.\nTheorem 2. Cautious reasoning under PSP semantics is ΠP2 -complete.\nProof. Membership follows by Corollary 1 of [17]. For the hardness, we provide a reduction from 2-QBF∀. Let Ψ = ∀x1 · · · ∀xm∃y1 · · · ∃yn E, where E is in 3CNF. Formula Ψ is equivalent to ¬Ψ ′, where Ψ ′ = ∃x1 · · · ∃xm∀y1 · · · ∀yn E′, and E′ is a 3DNF equivalent to ¬E and obtained by applying De Morgan’s laws. To prove the claim we construct a program PΨ such that PΨ |=PSPc w (w a fresh atom) if and only if Ψ is valid, i.e., iff Ψ ′ is invalid.\nLet E′ = (l1,1 ∧ l1,2 ∧ l1,3)∨ · · · ∨ (lk,1 ∧ lk,2 ∧ lk,3), for some k ≥ 1. Program PΨ is the following:\nxTi ← not xFi xFi ← not xTi i ∈ {1, . . . ,m} (4) yTi ← not yFi yFi ← not yTi i ∈ {1, . . . , n} (5) yTi ← sat yFi ← sat i ∈ {1, . . . , n} (6) sat ← µ(E′) (7) w ← not sat (8)\nwhere µ is defined recursively as follows:\n– µ(E′) := (µ(l1,1) ∧ µ(l1,2) ∧ µ(l1,3)) ∨ · · · ∨ (µ(lk,1) ∧ µ(lk,2) ∧ µ(lk,3)); – µ(xi) := xTi and µ(¬ xi) := xFi for all i = 1, . . . ,m; – µ(yi) := yTi and µ(¬ yi) := yFi for all i = 1, . . . , n.\nNote that structure µ(E′) can also be encoded by means of a sum aggregate as shown in [1].\nRules (4)–(5) force each PSP answer set of PΨ to contain at least one of xTi , x F i (i ∈ {1, . . . ,m}), and one of yTj , yFj (j ∈ {1, . . . ,m}), respectively, encoding an assignment of the propositional variables in Ψ ′. Rules (6) are used to simulate universality of the y variables, as described later. Having an assignment, rule (7) derives sat if the assignment satisfies some disjunct of E′ (and hence also E′ itself). Finally, rule (8) derives w if sat is false.\nWe first show that Ψ not valid implies PΨ 6|=PSPc w. If Ψ is not valid, Ψ ′ is valid. Hence, there is an assignment ν for x1, . . . , xm such that no extension to y1, . . . , yn satisfiesE, i.e., all these extensions satisfyE′. Let us consider the following interpretation\n(which is also a model of PΨ ):\nM = {xTi | ν(xi) = 1, i = 1, . . . ,m} ∪ {xFi | ν(xi) = 0, i = 1, . . . ,m} ∪ {yTi , yFi | i = 1, . . . , n} ∪ {sat}\nWe claim that M is a PSP answer set of PΨ . In fact, KPΨM (∅) ⊇ {xTi | ν(xi) = 1, i = 1, . . . ,m} ∪ {xFi | ν(xi) = 0, i = 1, . . . ,m} because of rules (4) in PMΨ . Since any assignment for the ys satisfies at least a disjunct of E′, from rule (7) we derive sat ∈ KPΨM (K PΨ M (∅)). Hence, rules (6) force all y atoms to belong to K PΨ M (K PΨ M (K PΨ M (∅))), which is thus the least fixpoint of KPΨM and coincides with M . Now we show that PΨ 6|=PSPc w implies that Ψ is not valid. To this end, let M be a PSP answer set of PΨ such that w /∈ M . Hence, by rule (8) we have that M |= sat . From sat ∈ M and rules (6), we have yTi , yFi ∈ M for all i = 1, . . . , n. And M contains either xTi or x F i for i = 1, . . . ,m because of rules (4). Suppose by contradiction that Ψ is valid. Thus, for all assignments of x1, . . . , xm, there is an assignment for y1, . . . , yn such that E is true, i.e., E′ is false. We can show that the least fixpoint of KPΨM is K PΨ M (∅) = {xTi | ν(xi) = 1, i = 1, . . . ,m} ∪ {xFi | ν(xi) = 0, i = 1, . . . ,m}. In fact, sat cannot be derived because KPΨM (∅) 6|= µ(E′). We thus have a contradiction with the assumption that M is a PSP answer set of PΨ . ut\nIt is also known that the complexity drops to coNP if structures in body rules are constrained to be convex. This appears to be “folklore” knowledge and can be argued to follow from results in [10]. An easy way to see membership in coNP is that all convex structures can be decomposed into a conjunction of a monotonic and an antimonotonic structure, for which membership in coNP has been shown in [7].\nIt is instructive to note a crucial difference between the ΠP2 -hardness proofs in [7] (and a similar one in [8]) and the proofs for Theorem 2 and the ΣP2 result for PSP in [13].\nThe fundamental tool in the FLP hardness proofs is the availability of structures S1, S2 that allow for encoding “need to have either atom xT or xF , or both of them, but the latter only upon forcing the truth of both atoms.” S1, S2 have domains DS1 = DS2 = {xT , xF } and the following satisfaction patterns:\n∅ |= S1 {xT } |= S1 {xF } 6|= S1 {xT , xF } |= S1 ∅ |= S2 {xT } 6|= S2 {xF } |= S2 {xT , xF } |= S2\nThe reductions then use these structures in a similar way than disjunction is used in the classic ΣP2 -hardness proofs in [3]. In particular, the same structures are used for all instances to be reduced.\nOn the other hand, in the PSP hardness proofs, one dedicated structure is used for each instance of the problem reduced from (2QBF in Theorem 2). Indeed, a construction using structures S1, S2 as described earlier is not feasible for PSP, because (∅, {xT , xF }) 6|= S1 and (∅, {xT , xF }) 6|= S2. This is because there is one satisfaction “hole” between ∅ and {xT , xF } for both S1 and S2. In the next section, we will exploit this difference."
    }, {
      "heading" : "3.3 Dissonance: Complexity of Non-convex Structures with Bounded Domains",
      "text" : "In this section, we look more carefully at programs with non-convex structures and identify computational differences between the FLP and PSP semantics. In [2] it has been shown that any non-convex structure (plus all of its variants) can be used in order to implement S1 and S2. This result makes it clear that the presence of any non-convex structure that is closed under variants causes a complexity increase for the FLP semantics (unless the polynomial hierarchy collapses). From the above considerations, it is immediately clear that the same construction is not feasible for PSP. It turns out that also no alternative way exists to obtain a similar result, and that the difference in the ΠP2 -hardness proofs for FLP and PSP is intrinsic.\nWe start by considering a simple non-convex structure Å with DÅ = {x, y} and I |= Å if and only if |I ∩ DÅ| 6= 1. Therefore, Å behaves like a cardinality constraint COUNT ({x, y}) 6= 1.\nProposition 1. Deciding whether an interpretationM is a PSP answer set of a datalog{Å} program P is feasible in polynomial time, in particular DTIME(m2), where m is the number of rules in P .\nProof. For any interpretation, testing whether (I,M) |= Åσ (for a variant Åσ of Å) can be done by examining |I ∩DÅσ| = i and |M ∩DÅσ| = j and returning false if either one of i, j is 1, or if i = 0 and j = 2. Alternatively, in a less syntax dependent way, one can test whether M |= Åσ and (I ∪ J) |= Åσ for each J ⊆ (M ∩DÅσ) \\ (I ∩DÅσ). Since there are at most 4 different J for each I , either method is feasible in constant time.\nFor determining whether M is a PSP answer set of P , we can check whether it is the least fixpoint of KPM . Computing the least fixpoint takes at most m applications of KPM (where m is the number of rules in P ). Each application of K P M involves in turn at most m tests for (I,M) |= Åσ. ut\nGiven Proposition 1 it follows that cautious reasoning is still in coNP for datalog{Å}\nprograms under the PSP semantics.\nProposition 2. Given a datalog{Å} program P and an atom a, deciding P |=PSPc a is in coNP .\nProof. The complement has an immediate nondeterministic polynomial time algorithm: guess an interpretation M and verify in polynomial time that a 6∈ M and that M is a PSP answer set of P (by virtue of Proposition 1). ut\nIt follows that for datalog{Å} cautious reasoning (and also answer set existence and brave reasoning) is more complex for the FLP semantics than for the PSP semantics (unless the polynomial hierarchy collapses to its first level).\nExamining this result and its proof carefully, we can see that it depends on the fact that each DÅσ contains 2 elements and therefore at most 4 satisfaction tests are needed to determine (I,M) |= Åσ. Indeed, we can apply similar reasoning whenever the domains of involved structures are smaller than a given bound.\nTheorem 3. Let P be a program. If k is an upper bound for the domain size of any structure occurring in P , then checking whether a given interpretation M is a PSP answer set of P is decidable in DTIME(2km2p(n)), where m is the number of rules in P and p(n) is the polynomial function (in terms of the input size n) bounding determining satisfaction of any aggregate in P .\nProof. We show that the least fixpoint of KPM can be computed in time O(2 km2p(n)). In the worst case, each application of the operator derives at most one new atom, and thus the fixpoint is reached after at mostm applications of the operator. Each application requires at most the evaluation of all rules of P , and thus at most m2 rule evaluations are sufficient. To evaluate a rule, the truth of the body has to be checked w.r.t. at most 2k interpretations (similar to Proposition 1, in which k = 2), each requiring p(n) time. We thus obtain the bound O(2km2p(n)). ut\nThis means that actually most languages with non-convex structures exhibit a complexity gap between the FLP and PSP semantics. There is a uniformity issue here, which we informally noted earlier when examining the ΠP2 -hardness proof for cautious reasoning under PSP. We can now formalize this, as it follows from Theorem 3 that we need an infinite number of inherently different non-convex structures in order to obtain ΠP2 hardness.\nCorollary 1. Let S be any finite set of structures, possibly including non-convex structures. Cautious reasoning over datalogS is in coNP under the PSP semantics.\nThis means that there is also a clear difference in uniformity between the complexity boundary of the FLP and the PSP semantics, respectively. It also means that it is impossible to simulate the FLP semantics in a compact way using the PSP semantics on the class of programs with bounded domain structures, unless the polynomial hierarchy collapses to its first level. The general picture of our complexity results is shown in Figure 1. We can see that the complexity transition from coNP to ΠP2 is different for the FLP and PSP semantics, respectively. The solid line between convex and non-convex structures denotes a crisp transition for FLP, while the dashed line between bounded non-convex and unbounded non-convex structures is a rougher transition."
    }, {
      "heading" : "4 Discussion",
      "text" : "Looking at Figure 1, the transition from coNP to ΠP2 appears somewhat irregular for PSP, as the availability of single non-convex structures does not cause the transition, but only their union. However, in practice the availability of an infinite number of different structures is not unusual: indeed, if aggregates are considered, the presence of one aggregate function and suitable comparison relations usually gives rise to such an infinite repertoire of structures.\nExample 10. Consider the availability of COUNT over any set of atoms and the comparison relation 6=. The structures generated by aggregates of the form COUNT (S) 6= i do not have a bound on the domains of non-convex aggregates. Indeed, for any structure COUNT ({a1, . . . , ak}) 6= 1, which is non-convex and for which the domain size is k,\none can formulate also COUNT ({a1, . . . , ak+1}) 6= 1, which is also non-convex and has a larger domain.\nHowever, as noted earlier, for expressing ΠP2 -hard problems, one needs a nonuniform approach for PSP, in the sense that a dedicated aggregate has to be formulated for each problem instance, whereas for FLP one can re-use the same aggregates for all problem instances.\nIn practical terms, our results imply that for programs containing only convex structures, techniques as those presented in [1] for FLP can be used for computing answer sets also for PSP, and techniques presented for PSP can be used for FLP in turn. It also means that this is the largest class for which this can be done with currently available methods in an efficient way. There are several examples for convex structures that are easy to identify syntactically: count aggregates with equality guards, sum aggregates with positive summands and equality guards, dl-atoms that do not involve ∩− and rely on a tractable Description Logic [4]. However many others are in general not convex, for example sum aggregates that involve both positive and negative summands, times aggregates that involve the factor 0, average aggregates, dl-atoms with∩−, and so on. It is still possible to find special cases of such structures that are convex, but that requires deeper analyses.\nThe results also immediately imply impossibility and possibility results for rewritability: unless the polynomial hierarchy collapses to its first level, it is not possible in the FLP semantics to rewrite a program with non-convex structures into one containing only convex structures (for example, a program not containing any generalized atoms), unless disjunction or similar constructs are allowed in rule heads. On the other hand, such rewritings are possible for the PSP semantics if the non-convex structures are guaranteed to have bounded domains. This seems to be most important for dl-programs, where such rewritings are sought after.\nThe semantics considered in this paper encompass several approaches suggested for programs that couple answer set programming with description logics. The approaches presented in [5] and [11] directly employ the FLP semantics, while the approach of [15]\nis shown to be equivalent to the PSP semantics. There are other proposals, such as [4], which appears to be different from both FLP and PSP already on convex structure. In future work we plan to relate also these other semantics with FLP and PSP and attempt to identify the largest coinciding classes of programs."
    } ],
    "references" : [ {
      "title" : "Unfounded Sets and Well-Founded Semantics of Answer Set Programs with Aggregates",
      "author" : [ "M. Alviano", "F. Calimeri", "W. Faber", "N. Leone", "S. Perri" ],
      "venue" : "Journal of Artificial Intelligence Research 42, 487–527",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The complexity boundary of answer set programming with generalized atoms under the flp semantics",
      "author" : [ "M. Alviano", "W. Faber" ],
      "venue" : "Cabalar, P., Tran, S.C. (eds.) Logic Programming and Nonmonotonic Reasoning — 12th International Conference",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "On the Computational Cost of Disjunctive Logic Programming: Propositional Case",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 15(3/4), 289–323",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Combining answer set programming with description logics for the semantic web",
      "author" : [ "T. Eiter", "G. Ianni", "T. Lukasiewicz", "R. Schindlauer", "H. Tompits" ],
      "venue" : "Artif. Intell. 172(12–13), 1495– 1539",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer Set Programming",
      "author" : [ "T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits" ],
      "venue" : "International Joint Conference on Artificial Intelligence (IJCAI) 2005. pp. 90–96. Edinburgh, UK",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Recursive aggregates in disjunctive logic programs: Semantics and complexity",
      "author" : [ "W. Faber", "N. Leone", "G. Pfeifer" ],
      "venue" : "Alferes, J.J., Leite, J. (eds.) Proceedings of the 9th European Conference on Artificial Intelligence (JELIA 2004). Lecture Notes in AI (LNAI), vol. 3229, pp. 200–212. Springer Verlag",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Semantics and complexity of recursive aggregates in answer set programming",
      "author" : [ "W. Faber", "N. Leone", "G. Pfeifer" ],
      "venue" : "Artificial Intelligence 175(1),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2011
    }, {
      "title" : "Answer Sets for Propositional Theories",
      "author" : [ "P. Ferraris" ],
      "venue" : "Baral, C., Greco, G., Leone, N., Terracina, G. (eds.) Logic Programming and Nonmonotonic Reasoning — 8th International Conference, LPNMR’05, Diamante, Italy, September 2005, Proceedings. Lecture Notes in Computer Science, vol. 3662, pp. 119–131. Springer Verlag",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Logic programs with abstract constraint atoms: The role of computations",
      "author" : [ "L. Liu", "E. Pontelli", "T.C. Son", "M. Truszczyński" ],
      "venue" : "Artificial Intelligence 174(3–4), 295–315",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Properties and applications of programs with monotone and convex constraints",
      "author" : [ "L. Liu", "M. Truszczyński" ],
      "venue" : "Journal of Artificial Intelligence Research 27, 299–334",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "A novel combination of answer set programming with description logics for the semantic web",
      "author" : [ "T. Lukasiewicz" ],
      "venue" : "IEEE Transactions on Knowledge and Data Engineering 22(11), 1577– 1592",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Logic Programming with Monotone Cardinality Atom",
      "author" : [ "V.W. Marek", "I. Niemelä", "M. Truszczyński" ],
      "venue" : "Lifschitz, V., Niemelä, I. (eds.) Proceedings of the 7th International Conference on Logic Programming and Non-Monotonic Reasoning (LPNMR-7). LNAI, vol. 2923, pp. 154–166. Springer",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Semantics of Logic Programs with Aggregates",
      "author" : [ "N. Pelov" ],
      "venue" : "Ph.D. thesis, Katholieke Universiteit Leuven, Leuven, Belgium",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Well-founded and Stable Semantics of Logic Programs with Aggregates",
      "author" : [ "N. Pelov", "M. Denecker", "M. Bruynooghe" ],
      "venue" : "Theory and Practice of Logic Programming 7(3), 301–353",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "FLP semantics without circular justifications for general logic programs",
      "author" : [ "Y.D. Shen", "K. Wang" ],
      "venue" : "Hoffmann, J., Selman, B. (eds.) Proceedings of the 26th AAAI Conference on Artificial Intelligence (AAAI-12)",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Extending and Implementing the Stable Model Semantics",
      "author" : [ "P. Simons", "I. Niemelä", "T. Soininen" ],
      "venue" : "Artificial Intelligence 138, 181–234",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "A Constructive Semantic Characterization of Aggregates in ASP",
      "author" : [ "T.C. Son", "E. Pontelli" ],
      "venue" : "Theory and Practice of Logic Programming 7, 355–375",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Answer Sets for Logic Programs with Arbitrary Abstract Constraint Atoms",
      "author" : [ "T.C. Son", "E. Pontelli", "P.H. Tu" ],
      "venue" : "Journal of Artificial Intelligence Research 29, 353–389",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2007
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "In this paper, we analyze the class of programs that have convex generalized atoms (originally proposed by Liu and Truszczyński in [10]) in rule bodies and show that for this class many of the proposed semantics coincide.",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 6,
      "context" : "A number of semantics have been proposed for such programs, most notably the FLP semantics [7] and a number of coinciding semantics that we will collectively refer to as PSP semantics (from Pelov, Son, and Pontelli) [13,17].",
      "startOffset" : 91,
      "endOffset" : 94
    }, {
      "referenceID" : 12,
      "context" : "A number of semantics have been proposed for such programs, most notably the FLP semantics [7] and a number of coinciding semantics that we will collectively refer to as PSP semantics (from Pelov, Son, and Pontelli) [13,17].",
      "startOffset" : 216,
      "endOffset" : 223
    }, {
      "referenceID" : 16,
      "context" : "A number of semantics have been proposed for such programs, most notably the FLP semantics [7] and a number of coinciding semantics that we will collectively refer to as PSP semantics (from Pelov, Son, and Pontelli) [13,17].",
      "startOffset" : 216,
      "endOffset" : 223
    }, {
      "referenceID" : 8,
      "context" : "In [9] it is furthermore hinted that the semantics also coincide on programs that have atomic rule heads and contain only convex generalized atoms.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 8,
      "context" : "However, no formal proof is available for this claim, and the informal explanation given in [9] is not as general as it could be, as we will show.",
      "startOffset" : 92,
      "endOffset" : 95
    }, {
      "referenceID" : 8,
      "context" : "We first formally prove the claim that the FLP and PSP semantics coincide on programs with convex structures, as originally reported in [9].",
      "startOffset" : 136,
      "endOffset" : 139
    }, {
      "referenceID" : 12,
      "context" : "This follows from a result in [13], and we provide an alternative proof in this paper.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 5,
      "context" : "We first describe a reduct-based semantics, usually referred to as FLP, which has been described and analyzed in [6,7].",
      "startOffset" : 113,
      "endOffset" : 118
    }, {
      "referenceID" : 6,
      "context" : "We first describe a reduct-based semantics, usually referred to as FLP, which has been described and analyzed in [6,7].",
      "startOffset" : 113,
      "endOffset" : 118
    }, {
      "referenceID" : 16,
      "context" : "We will next describe a different semantics, using the definition of [17], called “fixpoint answer set” in that paper.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 16,
      "context" : "Theorem 3 in [17] shows that it is actually equivalent to the two-valued fix-point of ultimate approximations of generalized atoms in [13]2, and therefore with stable models for ultimate approximations of aggregates as defined in [14].",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 12,
      "context" : "Theorem 3 in [17] shows that it is actually equivalent to the two-valued fix-point of ultimate approximations of generalized atoms in [13]2, and therefore with stable models for ultimate approximations of aggregates as defined in [14].",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 13,
      "context" : "Theorem 3 in [17] shows that it is actually equivalent to the two-valued fix-point of ultimate approximations of generalized atoms in [13]2, and therefore with stable models for ultimate approximations of aggregates as defined in [14].",
      "startOffset" : 230,
      "endOffset" : 234
    }, {
      "referenceID" : 17,
      "context" : "On programs considered in this paper, PSP answer sets also coincide with “answer sets” defined in [18] (by virtue of Proposition 10 in [18]) and “well-justified FLP answer sets” of [15] (by virtue of Theorem 5 in [15]).",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 17,
      "context" : "On programs considered in this paper, PSP answer sets also coincide with “answer sets” defined in [18] (by virtue of Proposition 10 in [18]) and “well-justified FLP answer sets” of [15] (by virtue of Theorem 5 in [15]).",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 14,
      "context" : "On programs considered in this paper, PSP answer sets also coincide with “answer sets” defined in [18] (by virtue of Proposition 10 in [18]) and “well-justified FLP answer sets” of [15] (by virtue of Theorem 5 in [15]).",
      "startOffset" : 181,
      "endOffset" : 185
    }, {
      "referenceID" : 14,
      "context" : "On programs considered in this paper, PSP answer sets also coincide with “answer sets” defined in [18] (by virtue of Proposition 10 in [18]) and “well-justified FLP answer sets” of [15] (by virtue of Theorem 5 in [15]).",
      "startOffset" : 213,
      "endOffset" : 217
    }, {
      "referenceID" : 14,
      "context" : "Indeed, as shown in [15], the operator K M can be equivalently defined as follows:",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 11,
      "context" : "Examples are [12] for monotonic structures (that are also allowed to occur in rule heads in that paper), or [16] that allows for structures corresponding to cardinality and weight constraints and largely coincide with the PSP semantics (see [13] for a discussion on structures on which the semantics coincides).",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 15,
      "context" : "Examples are [12] for monotonic structures (that are also allowed to occur in rule heads in that paper), or [16] that allows for structures corresponding to cardinality and weight constraints and largely coincide with the PSP semantics (see [13] for a discussion on structures on which the semantics coincides).",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 12,
      "context" : "Examples are [12] for monotonic structures (that are also allowed to occur in rule heads in that paper), or [16] that allows for structures corresponding to cardinality and weight constraints and largely coincide with the PSP semantics (see [13] for a discussion on structures on which the semantics coincides).",
      "startOffset" : 241,
      "endOffset" : 245
    }, {
      "referenceID" : 16,
      "context" : "2 There is an even closer relationship, as the operator K M (I) of [17] coincides with φ P (I,M) defined in [13], as shown in the appendix of [17]",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 12,
      "context" : "2 There is an even closer relationship, as the operator K M (I) of [17] coincides with φ P (I,M) defined in [13], as shown in the appendix of [17]",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 16,
      "context" : "2 There is an even closer relationship, as the operator K M (I) of [17] coincides with φ P (I,M) defined in [13], as shown in the appendix of [17]",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 8,
      "context" : "In [9] it is stated that many semantics (and in particular, FLP and PSP) “agree on [.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 9,
      "context" : "” However, the comment on regarding convex aggregates as monotone constraints relies on a transformation described in [10] that transforms convex structures into conjunctions of positive and negated monotone constraints.",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 16,
      "context" : "This has been stated as Theorem 2 in [17] and Proposition 8.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 13,
      "context" : "1 in [14].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 16,
      "context" : "The left implication follows from Theorem 2 in [17].",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 6,
      "context" : "It is known that cautious reasoning over programs with arbitrary structures under the FLP semantics is Π 2 -complete in general, as shown in [7].",
      "startOffset" : 141,
      "endOffset" : 144
    }, {
      "referenceID" : 12,
      "context" : "Pelov has shown Σ P 2 completeness for deciding the existence of PSP answer sets in [13], from which Π 2 completeness for cautious reasoning under the PSP semantics can be derived.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 16,
      "context" : "Membership follows by Corollary 1 of [17].",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 0,
      "context" : "Note that structure μ(E′) can also be encoded by means of a sum aggregate as shown in [1].",
      "startOffset" : 86,
      "endOffset" : 89
    }, {
      "referenceID" : 9,
      "context" : "This appears to be “folklore” knowledge and can be argued to follow from results in [10].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 6,
      "context" : "An easy way to see membership in coNP is that all convex structures can be decomposed into a conjunction of a monotonic and an antimonotonic structure, for which membership in coNP has been shown in [7].",
      "startOffset" : 199,
      "endOffset" : 202
    }, {
      "referenceID" : 6,
      "context" : "It is instructive to note a crucial difference between the Π 2 -hardness proofs in [7] (and a similar one in [8]) and the proofs for Theorem 2 and the Σ 2 result for PSP in [13].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 7,
      "context" : "It is instructive to note a crucial difference between the Π 2 -hardness proofs in [7] (and a similar one in [8]) and the proofs for Theorem 2 and the Σ 2 result for PSP in [13].",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 12,
      "context" : "It is instructive to note a crucial difference between the Π 2 -hardness proofs in [7] (and a similar one in [8]) and the proofs for Theorem 2 and the Σ 2 result for PSP in [13].",
      "startOffset" : 173,
      "endOffset" : 177
    }, {
      "referenceID" : 2,
      "context" : "The reductions then use these structures in a similar way than disjunction is used in the classic Σ 2 -hardness proofs in [3].",
      "startOffset" : 122,
      "endOffset" : 125
    }, {
      "referenceID" : 1,
      "context" : "In [2] it has been shown that any non-convex structure (plus all of its variants) can be used in order to implement S1 and S2.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 0,
      "context" : "In practical terms, our results imply that for programs containing only convex structures, techniques as those presented in [1] for FLP can be used for computing answer sets also for PSP, and techniques presented for PSP can be used for FLP in turn.",
      "startOffset" : 124,
      "endOffset" : 127
    }, {
      "referenceID" : 3,
      "context" : "There are several examples for convex structures that are easy to identify syntactically: count aggregates with equality guards, sum aggregates with positive summands and equality guards, dl-atoms that do not involve ∩− and rely on a tractable Description Logic [4].",
      "startOffset" : 262,
      "endOffset" : 265
    }, {
      "referenceID" : 4,
      "context" : "The approaches presented in [5] and [11] directly employ the FLP semantics, while the approach of [15]",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 10,
      "context" : "The approaches presented in [5] and [11] directly employ the FLP semantics, while the approach of [15]",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 14,
      "context" : "The approaches presented in [5] and [11] directly employ the FLP semantics, while the approach of [15]",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 3,
      "context" : "There are other proposals, such as [4], which appears to be different from both FLP and PSP already on convex structure.",
      "startOffset" : 35,
      "endOffset" : 38
    } ],
    "year" : 2013,
    "abstractText" : "In recent years, Answer Set Programming (ASP), logic programming under the stable model or answer set semantics, has seen several extensions by generalizing the notion of an atom in these programs: be it aggregate atoms, HEX atoms, generalized quantifiers, or abstract constraints, the idea is to have more complicated satisfaction patterns in the lattice of Herbrand interpretations than traditional, simple atoms. In this paper we refer to any of these constructs as generalized atoms. Several semantics with differing characteristics have been proposed for these extensions, rendering the big picture somewhat blurry. In this paper, we analyze the class of programs that have convex generalized atoms (originally proposed by Liu and Truszczyński in [10]) in rule bodies and show that for this class many of the proposed semantics coincide. This is an interesting result, since recently it has been shown that this class is the precise complexity boundary for the FLP semantics. We investigate whether similar results also hold for other semantics, and discuss the implications of our findings.",
    "creator" : "LaTeX with hyperref package"
  }
}