{
  "name" : "1412.0773.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Expressiveness of Logic Programs under General Stable Model Semantics",
    "authors" : [ "Heng Zhang", "Yan Zhang" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n41 2.\n07 73\nv1 [\ncs .A"
    }, {
      "heading" : "Introduction",
      "text" : "Logic programming with default negation is an elegant and efficient formalism for knowledge representation, which incorporates the abilities of classical logic, inductive definition and commonsense reasoning. Nowadays, the most popular semantics for this formalism is the stable model semantics proposed by [16]. Logic programming based on this semantics, which is known as answer-set programming, has then emerged as a flourishing paradigm for declarative programming in the last fifteen years.\nThe original stable model semantics focuses only on Herbrand structures in which the unique name assumption is made. For a certain class of applications, this assumption will simplify the representation. However, there are many applications where the\nknowledge can be more naturally represented over non-Herbrand structures, including arithmetical structures and other metafinite structures. To overcome this limit, the general stable model semantics, which generalizes the original semantics to arbitrary structures, was then proposed by [14] via second-order logic, by [23] via circumscription, and by [25] via Gödel’s 3-valued logic, which provides us a unified framework for answer set programming, armed with powerful tools from classical logic.\nThe main goal of this work is to identify the expressiveness of logic programs, which is one of the central topics in knowledge representation and reasoning. We will focus on two important classes of logic programs – normal programs and disjunctive programs. Over Herbrand structures, the expressiveness of logic programs under the query equivalence has been thoroughly studied in the last three decades. An excellent survey for these works can be found in [5]. Our task is quite different. On the one hand, we will work on the general stable model semantics so that non-Herbrand structures will be considered. On the other hand, instead of considering query equivalence, the expressiveness in our work will be based on model equivalence. This setting is important since answer set solvers are usually used to generate models. The model equivalence implies the query equivalence, but the converse is in general not true.\nWe also hope this work contributing to the effective implementation of answer set solvers. Translating logic programs into classical logics is a usual approach to implement answer set solvers, e.g., [22, 21]. In this work, we are interested in translating normal programs to first-order sentences so that the state-of-the-art SMT solvers can be used for answer set solving. As the arity of auxiliary symbol is the most important factor to introduce nondeterminism [18], we will try to find translations with small arities of auxiliary symbols.\nOur contribution in this paper is fourfold. Firstly, we show that, over infinite structures, every disjunctive program can be equivalently translated to a normal one. Secondly, we prove that, if finite structures are focused, for each integer n greater than 1 there is a disjunctive program with intensional predicates of arities less than n that cannot be equivalently translated to any normal program with auxiliary predicates of arities less than 2n. Thirdly, we show that disjunctive and normal programs are of the same expressiveness over arbitrary structures if and only if they are of the same expressiveness over finite structures, if and only if the complexity class NP is closed under complement. Lastly, to understand the exact expressiveness of logic programs, we also prove that the intertranslatability holds between some classes of logic programs and some fragments of second-order logic."
    }, {
      "heading" : "Preliminaries",
      "text" : "Vocabularies are assumed to be sets of predicate constants and function constants. Logical symbols are as usual, including a countable set of predicate variables and a countable set of function variables. Every constant or variable is equipped with a natural number, its arity. Nullary function constants and variables are called individual constants and variables respectively. Nullary predicate constants are called propositions. Sometimes, we do not distinguish between constants and variables, and simply call them predicates or functions if no confusion occurs. Atoms, formulas, sentences\nand theories of a vocabulary υ (or shortly, υ-atoms, υ-formulas, υ-sentences and υtheories) are built from υ, equality, variables, connectives and quantifiers in a standard way. Every positive clause of υ is a finite disjunction of υ-atoms. Given a sentence ϕ and a theory Σ, let υ(ϕ) and υ(Σ) denote the sets of constants occurring in ϕ and Σ respectively.\nAssuming Q to be ∀ or ∃, let Qτ and Qx̄ denote the quantifier blocks QX1 · · ·QXn and Qx1 · · ·Qxm respectively if τ is the finite set {X1, . . . , Xn}, x̄ = x1 · · ·xm, Xi and xi are predicate/function and individual variables respectively. Let Σ1Fn,k be the class of sentences of form Q1τ1 · · ·Qnτnϕ, where Qi is ∃ if i is odd, otherwise it is ∀; τi is a finite set of variables of arities ≤ k; and no second-order quantifier appears in ϕ. Let Σ1n,k denote the class defined as the same as Σ 1F n,k except no function variable allowed in any τi. Let Σ1Fn (respectively, Σ1n) be the union of Σ1Fn,k (respectively, Σ 1 n,k) for all k ≥ 0. Given a class Σ defined as above, let Σ[∀∗∃∗] (respectively, Σ[∀∗]) be the class of sentences in Σ with first-order part of form ∀x̄∃ȳϑ (respectively, ∀x̄ϑ), where x̄ and ȳ are tuples of individual variables, and ϑ quantifier-free.\nEvery structure A of υ (or shortly, υ-structure A) is accompanied by a nonempty set A, the domain of A, and interprets each n-ary predicate constant P in υ as an nary relation PA on A, and interprets each n-ary function constant f in υ as an n-ary function fA on A. A structure is finite if its domain is finite; otherwise it is infinite. Let FIN denote the class of finite structures, and let INF denote the class of infinite structures. A restriction of a structure A to a vocabulary σ is the structure obtained from A by discarding all interpretations for constants not in σ. Given a vocabulary υ ⊃ σ and a σ-structure B, every υ-expansion of B is a structure A of υ such that B is a restriction of A to σ. Given a structure A and a set τ of predicates, let INS(A, τ) be the set of ground atoms P (ā) for all ā ∈ PA and all P in τ .\nEvery assignment in a structureA is a function that maps each individual variable to an element of A and maps each predicate (respectively, function) variable to a relation (respectively, function) on A of the same arity. Given a formula ϕ and an assignment α in A, write A |= ϕ[α] if α satisfies ϕ in A in the standard way. In particular, if ϕ is a sentence, simply write A |= ϕ, and say A is a model of ϕ, or in other words, ϕ is true in A. Given formulas ϕ, ψ and a class C of structures, we say ϕ is equivalent to ψ over C, or write ϕ ≡C ψ for short, if for every A in C and every assignment α in A, α satisfies ϕ in A if and only if α satisfies ψ in A. Given a quantifier-free formula ϕ and an assignment α in A, let ϕ[α] denote the ground formula obtained from ϕ by substituting a for t whenever a = α(t) and t is a term.\nA class of structures is also called a property. Let C and D be two properties. We say D is defined by a sentence ϕ over C, or equivalently, ϕ defines D over C, if each structure of C is in D if and only if it is a model of ϕ; D is definable in a class Σ of sentences over C if there is a sentence in Σ that defines D over C. Given two classes Σ,Λ of sentences, we write Σ ≤C Λ if each property definable in Σ over C is also definable in Λ over C; we write Σ ≃C Λ if both Σ ≤C Λ and Λ ≤C Σ hold. In particular, if C is the class of arbitrary structures, the subscript C can be dropped."
    }, {
      "heading" : "Logic Programs and Stable Models",
      "text" : "Every disjunctive program is a set of rules of the form\nζ1 ∧ · · · ∧ ζm → ζm+1 ∨ · · · ∨ ζn (1)\nwhere 0 ≤ m ≤ n and n > 0; ζi is an atom not involving the equality if m < i ≤ n; ζj is a literal, i.e. an atom or the negation of an atom, if 1 ≤ j ≤ m. Given a rule, the disjunctive part is called its head, and the conjunctive part is called its body. Given a disjunctive program Π, a predicate is called intensional (w.r.t. Π) if it appears in the head of some rule in Π; a formula is called intensional (w.r.t. Π) if it does not involve any non-intensional predicate. Let υ(Π) be the set of predicates and functions appearing in Π.\nLet Π be a disjunctive program. Then Π is called normal if the head of each rule contains at most one atom, Π is plain if the negation of any intensional atom does not appear in the body of any rule, Π is propositional if it does not involve any predicate of positive arity, and Π is finite if it contains only a finite set of rules. In particular, unless mentioned otherwise, a disjunctive program is always assumed to be finite.\nGiven any disjunctive program Π, let SM(Π) denote the second-order sentence ϕ∧ ∀τ∗(τ∗ < τ → ¬ϕ∗), where τ is the set of intensional predicates; τ∗ is the set of predicate variables P ∗ for all predicates P in τ ; τ∗ < τ is the formula ∧P∈τ∀x̄(P ∗(x̄) → P (x̄))∧¬∧P∈τ ∀x̄(P (x̄) → P ∗(x̄)); ϕ is the conjunction of all the sentences γ∀ such that γ is a rule in Π and γ∀ is the first-order universal closure of γ; ϕ∗ is the formula obtained from ϕ by substituting P ∗ for all positive occurrences of P in the head or in the body of each rule if P is in τ . (So, all negations in intensional literals are default negations.) A structure A is called a stable model of Π if it satisfies SM(Π). For more details about this transformation, please refer to [14].\nGiven two properties C and D, we say D is defined by a disjunctive program Π over C via the set τ of auxiliary constants if the formula ∃τSM(Π) defines D over C, where τ is a set of predicates and functions occurring in Π. Given n ≥ 0, let DLPn (respectively, DLPFn) be the class of sentences ∃τSM(Π) for all disjunctive programs Π and all finite sets τ of predicate (respectively, predicate and function) constants of arities ≤ n. Let DLP (respectively,DLPF) be the union of DLPn (respectively,DLP F n) for all n ≥ 0. In above definitions, if Π is restricted to be normal, we then obtain the notations NLPn,NLP F n,NLP and NLP\nF respectively. Given a rule γ, let γ−B be the set of conjuncts in the body of γ in which no intensional predicate positively occurs, and let γ+ be the rule obtained from γ by removing all literals in γ−B . Given a disjunctive program Π and a structure A, let Π\nA be the set of rules γ+[α] for all assignments α in A and all rules γ in Π such that α satisfies γ−B in A. Now, ΠA can be regarded as a propositional program where each ground atom as a proposition. This procedure is called the first-order Gelfond-Lifschitz reduction due to the following result:\nProposition 1 ([28], Proposition 4). Let Π be a disjunctive program and τ the set of intensional predicates. Then an υ(Π)-structure A is a stable model of Π iff INS(A, τ) is a minimal (w.r.t. the set inclusion) model of ΠA."
    }, {
      "heading" : "Progression Semantics",
      "text" : "In this subsection, we review a progression semantics proposed by [28], which generalizes the fixed point semantics of [24] to logic programming with default negation over arbitrary structures. For convenience, two positive clauses consisting of the same set of atoms will be regarded as the same.\nLet Π be a propositional, possibly infinite and plain disjunctive program. Let PC(υ(Π)) denote the set of positive clauses of υ(Π) and let Λ ⊆ PC(υ(Π)). Define ΓΠ(Λ) to be\n\n   \n   \nH ∨ C1 ∨ · · · ∨ Ck\n∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ ∣ k ≥ 0 & H,C1, . . . , Ck ∈ PC(υ(Π)) & ∃p1, . . . , pk ∈ υ(Π) s.t. [ p1 ∧ · · · ∧ pk → H ∈ Π &\nC1 ∨ p1, . . . , Ck ∨ pk ∈ Λ\n]\n\n   \n   \n.\nIt is clear that ΓΠ is a monotone operator on PC(υ(Π)). Now, a progression operator for first-order programs can then be defined via the first-order Gelfond-Lifschitz reduction. Given a disjunctive program Π and an υ(Π)structure A, define ΓAΠ to be the operator ΓΠA ; let Γ A\nΠ ↑0 denote the empty set, and let ΓAΠ ↑n denote Γ A Π(Γ A Π ↑n−1) for all n > 0; finally, let Γ A Π ↑ω be the union of Γ A\nΠ ↑n for all n ≥ 0. To illustrate the definitions, a simple example is given as follows.\nExample 1. Let Π be the logic program consisting of rules\nS(x) ∨ T (x) and T (x) ∧E(x, y) → T (y).\nLet υ be {E} and A a structure of υ. Then, for n > 0, ΓAΠ ↑n is the set of clauses S(a) ∨ T (b) such that a, b ∈ A and there exists a path from a to b via E of length less than n.\nThe following proposition shows that the general stable model semantics can be defined by the progression operator.\nProposition 2 ([28], Theorem 1). Let Π be a disjunctive program, τ the set of intensional predicates of Π, and A a structure of υ(Π). Then A is a stable model of Π iff INS(A, τ) is a minimal model of ΓAΠ ↑ω.\nRemark 1. In Proposition 2, it is clear that, if Π is normal, A is a stable model of Π if and only if INS(A, τ) = ΓAΠ ↑ω."
    }, {
      "heading" : "Infinite Structures",
      "text" : "This section will focus on the expressiveness of logic programs over infinite structures. We first propose a translation that reduces each disjunctive program to a normal program over infinite structures. The main idea is to encode grounded positive clauses by elements in the intended domain. With the encoding, we then simulate the progression of the given disjunctive program by the progression of a normal program.\nWe first show how to encode a positive clause by an element. Let A be an infinite set. Each encoding function on A is defined to be an injective function from A×A into A. Let enc be an encoding function on A and c an element in A such that enc(a, b) 6= c for all elements a, b ∈ A. To simplify the statement, let enc(a1, . . . , ak; c) denote the expression\nenc((· · · (enc(c, a1), a2), · · · ), ak) (2)\nfor any k ≥ 0 and any set of elements a1, . . . , ak ∈ A. In the above expression, the special element c is used as a flag to indicate that the encoded tuple will be started after c, and is then called the encoding flag of this encoding.\nLet A∗ denote the set of finite tuples of elements in A and enc[A, c] the set of elements enc(ā; c) for all tuples ā in A∗. The merging function mrg on A related to enc and c is the function from enc[A, c]× enc[A, c] into enc[A, c] such that\nmrg(enc(ā; c), enc(b̄; c)) = enc(ā, b̄; c) (3)\nfor all tuples ā and b̄ in A∗. Again, to simplify the statement, we let mrg(a1, . . . , ak) be short for the expression\nmrg((· · · (mrg(a1, a2), a3), · · · ), ak) (4)\nif all encoding flags of a1, . . . , ak are the same. It is clear that the merging function is unique if enc and c are fixed.\nExample 2. Let Z+, the set of all positive integers, be the domain that we will focus, and let P1, P2, P3 be three predicates of arities 2, 3, 1 respectively. Next, we show how to encode ground positive clauses by integers in Z+.\nLet e be a function from Z+ × Z+ into Z+ such that\ne(m,n) = 2m + 3n for all m,n ∈ Z+. (5)\nIt is easy to check that e is an encoding function on Z+, and integers 1, 2, 3, 4 are not in the range of e. For 1 ≤ i ≤ 3, let i be the encoding flag for the encodings of atoms built from Pi. Then the grounded atom P2(1, 3, 5) can be encoded by\ne(1, 3, 5; 2) = e(e(e(2, 1), 3), 5) = 2155 + 35. (6)\nLet 4 be the encoding flag for encodings of positive clauses. Then the positive clause P2(1, 3, 5) ∨ P3(2) ∨ P1(2, 4) can be encoded by e(e(1, 3, 5; 2), e(2; 3), e(2, 4; 1); 4).\nIn classical logic, two positive clauses are equivalent if and only if they contain the same set of atoms. Assume that c is the encoding flag for encodings of positive clauses and enc is the encoding function. To capture the equivalence between two positive clauses, some encoding predicates related to enc and c are needed. We define them as follows:\nin = {(enc(ā; c), b) | ā ∈ A∗ ∧ b ∈ [ā]}, (7)\nsubc = {(enc(ā; c), enc(b̄; c)) | ā, b̄ ∈ A∗ ∧ [ā] ⊆ [b̄]}, (8)\nequ = {(enc(ā; c), enc(b̄; c)) | ā, b̄ ∈ A∗ ∧ [ā] = [b̄]}, (9)\nwhere [ā], [b̄] are the sets of elements in ā, b̄ respectively. Intuitively, in(a, b) expresses that the atom encoded by b appears in the positive clause encoded by a; subc(a, b) expresses that the positive clause encoded by a is a subclause of that encoded by b; and equ(a, b) expresses that the positive clauses encoded by a and b respectively are equivalent.\nWith the above method for encoding, we can then define a translation. Let Π be a disjunctive program. We first construct a class of normal programs related to Π as follows:\n1. Let CΠ denote the set consisting of an individual constant cP for each predicate constant P that occurs in Π, and of an individual constant cǫ, where cǫ will be interpreted as the encoding flag for positive clauses, and cP as the encoding flag for atoms built from P . Let Π1 consist of the rule\nENC(x, y, c) → ⊥ (10)\nfor each individual constant c ∈ CΠ, and the following rules:\n¬ENC(x, y, z) → ENC(x, y, z) (11)\n¬ENC(x, y, z) → ENC(x, y, z) (12)\nENC(x, y, z) ∧ ENC(u, v, z) ∧ ¬x = u → ⊥ (13)\nENC(x, y, z) ∧ ENC(u, v, z) ∧ ¬y = v → ⊥ (14)\nENC(x, y, z) → OKe(x, y) (15)\n¬OKe(x, y) → OKe(x, y) (16)\nENC(x, y, z) ∧ ENC(x, y, u) ∧ ¬z = u → ⊥ (17)\nInformally, rules (15)–(17) describe that ENC is the graph of a function; rules (13)–(14) describe that ENC is injective. Thus, ENC should be the graph of an encoding function. In addition, rule (10) assures that c is not in the range of ENC.\n2. Let Π2 be the program consisting of the following rules:\ny = cǫ → MRG(x, y, x) (18) [\nMRG(x, u, v) ∧ ENC(u,w, y)\n∧ ENC(v, w, z)\n]\n→ MRG(x, y, z) (19)\nENC(x, u, y) → IN(u, y) (20)\nENC(x, z, y) ∧ IN(u, x) → IN(u, y) (21)\nx = cǫ → SUBC(x, y) (22)\nSUBC(u, y) ∧ ENC(u, v, x) ∧ IN(v, y) → SUBC(x, y) (23)\nSUBC(x, y) ∧ SUBC(y, x) → EQU(x, y) (24)\nInformally, rules (18)–(19) describe that MRG is the graph of the merging function related to ENC and cǫ; rules (20)–(21) are an inductive version of (7); rules (22)–(23) are an inductive version of (8); all rules (20)–(24) then assert that EQU is the equivalence between positive clauses.\n3. Let Π3 be the logic program consisting of the rule\nTRUE(x) ∧ EQU(x, y) → TRUE(y) (25)\nand the rule \n \nTRUE(x1) ∧ · · · ∧ TRUE(xk)∧\nENC(y1, ⌈ϑ1⌉, x1) ∧ · · · ∧ ENC(yk, ⌈ϑk⌉, xk)\n∧ MRG(⌈γH⌉, y1, . . . , yk, z) ∧ γB\n\n  → TRUE(z) (26)\nfor each rule γ in Π, where ϑ1, . . . , ϑk list all the intensional atoms that have strictly positive occurrences in the body of γ for some k ≥ 0; γH is the head of γ, γ − B is the conjunction of literals occurring in the body of γ but not in ϑ1, . . . , ϑk; ENC(t1, ⌈ϑ⌉, t2) denotes the following conjunction\nui0 = cP ∧ ENC(u i 0, t1, u i 1) ∧ · · ·\n∧ ENC(uim−1, tm, u i m) ∧ ENC(t1, u i m, t2)\nfor some new variables uij if t1, t2 are terms and ϑ an atom of form P (t1, . . . , tm); MRG(⌈γH⌉, y1, . . . , yk, z) denotes\nENC(v0,⌈ζ1⌉, v1) ∧ · · · ∧ ENC(vn−1, ⌈ζn⌉, vn)\n∧ MRG(w0, y1, w1) ∧ · · · ∧ MRG(wk−1, yk, wk)\n∧ v0 = cǫ ∧ w0 = vn ∧ z = wk\nif γH = ζ1 ∨ · · · ∨ ζn for some atoms ζ1, . . . , ζn and n ≥ 0. Intuitively, rule (25) assures that the progression is closed under the equivalence of positive clauses; rule (26) then simulates the progression operator for the original program. As each positive clause is encoded by an element in the intended domain, the processes of decoding and encoding should be carried out before and after the simulation respectively.\nExample 3. Let γ = P (v) ∧ ¬Q(v) → R(v) ∨ S(v) be a rule such that P,Q,R, S are intensional. Then the following rule, defined by (26) with a slight simplification, simulates γ:\n\n \nTRUE(x1) ∧ ENC(cP ,v,u1) ∧ ENC(y1,u1,x1)∧\nENC(cR,v,u2) ∧ ENC(cǫ,u2,w1) ∧ ENC(cS ,v,u3)∧\nENC(w1,u3,w2) ∧ MRG(w2,y1,z) ∧ ¬Q(v)\n\n  → TRUE(z).\n4. Let Π4 be the program consisting of the rule\nx = cǫ → FALSE(x) (27)\nand the rule\nFALSE(x) ∧ ENC(x, ⌈ϑ⌉, y) ∧ ¬ϑ → FALSE(y) (28)\nfor every intensional atom ϑ of the form P (z̄P ), where z̄P denotes a tuple of distinct individual variables z1 · · · zkP that are different from x and y, and kP is the arity of P .\nThis program is intended to define the predicate FALSE as follows: FALSE(a) holds in the intended structure if and only if a encodes a positive clause that is false in the structure.\n5. Let Π5 be the logic program consisting of the rule\nTRUE(cǫ) → ⊥ (29)\nand the following rule\nTRUE(x) ∧ ENC(y, ⌈ϑ⌉, x) ∧ FALSE(y) → ϑ (30)\nfor each atom ϑ of the form same as that in Π4. Informally, this program asserts that a ground atom is true in the intended structure if and only if there is a positive clause containing this atom such that the clause in true and all the other atoms in this clause are false in the structure.\nNow, we let Π⋄ denote the union of Π1, . . . ,Π5. This then completes the definition of the translation. The soundness of this translation is assured by the following theorem.\nTheorem 1. Let Π be a disjunctive program. Then over infinite structures, SM(Π) is equivalent to ∃πSM(Π⋄), where π denotes the set of constants occurring in Π⋄ but not in Π.\nTo prove this result, some notations and lemmas are needed. Let υi and τ be the sets of intensional predicates of Πi and Π respectively. Let σ = υ1 ∪ υ2 ∪ υ(Π). Given a structure A of υ(Π), each encoding expansion of A is defined to be a σ-expansion B of A satisfying both of the following:\n1. ENC is interpreted as the graph of an encoding function enc on A such that no element among cBǫ and cBP (for all P ∈ τ ) belongs to the range of enc, ENC as the complement of the graph of enc, and OKBe= A×A;\n2. MRG is interpreted as the graph of the merging function related to enc and cBǫ , and IN, SUBC, EQU as the encoding predicates in, subc, equ related to enc and cBǫ respectively.\nLet A be a structure of υ(Π) with an encoding expansion B. Let enc be the encoding function with graph ENCB. Let\n[[P (a1, . . . , ak)]] B = enc(a1, . . . , ak; cBP ), (31)\n[[ϑ1 ∨ · · · ∨ ϑn]] B = enc([[ϑ1]]B, . . . , [[ϑn]]B; cBǫ ). (32)\nIf the encoding expansion B is clear from the context, we simply write [[·]]B as [[·]]. Given a set Σ of ground positive clauses, let [[Σ]] be the set of elements [[C]] for all C ∈ Σ. Let ∆n(B) be the set of elements a with TRUE(a) ∈ ΓBΠ3↑n.\nLemma 1. Let A be a structure of υ(Π) with an encoding expansion B. Then [[ΓAΠ↑ω ]] = ∪n≥0∆ n(B).\nNext, given a structure A of υ(Π), an υ(Π⋄)-expansion C of A is called a progression expansion of A if the restriction of C to σ, denoted by B, is an encoding expansion of A; C interprets TRUE as [[ΓAΠ↑ω]]B, and interprets FALSE as\n{ [[C]]B | C ∈ GPC(τ, A) & INS(A, τ) |= ¬C }\n(33)\nwhere GPC(τ, A) denotes the set of ground positive clauses built from predicates in τ and elements in A.\nLemma 2. Let A be a structure of υ(Π) with a progression expansionC. Then INS(A, τ) is a minimal model of ΓAΠ↑ω iff INS(C, τ) is a minimal model of Π C 5 .\nDue to the limit of space, we will omit the proofs of Lemmas 1 and 2 here. To show Lemma 1, it is sufficient to show both [[ΓAΠ↑n]] ⊆ ∆2n(B) and [[ΓAΠ↑n]] ⊇ ∆n(B), and each of them can be done by an induction. For Lemma 2, roughly speaking, the soundness is assured by the result that every head-cycle-free disjunctive program is equivalent to the normal program obtained by shifting [4]. Please note that every set of positive clauses is head-cycle-free, and Π4 and Π5 are designed for the simulation of shifting. With these lemmas, we can then prove Theorem 1:\nProof of Theorem 1. By the splitting lemma in [15] and the second-order transformation, it suffices to show that SM(Π) is equivalent to the following formula\n∃π[SM(Π1) ∧ · · · ∧ SM(Π5)] (34)\nover infinite structures. Now we prove it as follows. “=⇒”: Let A be an infinite model of SM(Π). Let B be an encoding expansion ofA. The existence of such an expansion is clearly assured by the infiniteness of A. It is easy to check that B is a stable model of bothΠ1 andΠ2. Let C be the progression expansion of A that is also an expansion of B. By Proposition 2, INS(B, τ) = INS(A, τ) should be a minimal model of ΓAΠ↑ω. By Lemma 1 and definition, INS(B, τ) is also a minimal model of ΓBΠ3↑ω. By Proposition 2 again, B is then a stable model of Π3, which implies that so is C. It is also easy to check that C is a stable model of Π4. On the other hand, since INS(A, τ) is a minimal model of ΓAΠ ↑ω, by Lemma 2, INS(C, τ) should be a minimal model of ΠC5 , which means that C is a stable model of Π5 by Proposition 1. Thus, A is a model of formula (34).\n“⇐=”: Let A be an infinite model of formula (34). Then there exists an υ(Π⋄)expansion C of A such that C satisfies SM(Πi) for all i : 1 ≤ i ≤ 5. Let B be the restrictions of C to σ. Then, by a routine check, it is easy to show that B is an encoding expansion of A. As C is a stable model of Π3, by Proposition 2, INS(C, υ3) is then a minimal model of ΓCΠ3 ↑ω = Γ B Π3 ↑ω. Furthermore, by Lemma 1 and the conclusion that C satisfies SM(Π4), we then have that C is a progression expansion of A. On the other hand, since C is also a stable model of Π5, by Proposition 1 we can conclude that INS(C, τ) is a minimal model of ΠC5 . Thus, by Lemma 2 we immediately have that INS(A, τ) is a minimal model of ΓAΠ ↑ω. By Proposition 2, A is then a stable model of Π.\nRemark 2. Note that, given any finite domain A, there is no injective function from A × A into A. Therefore, we can not expect that the above translation works on finite structures.\nCorollary 1. DLP ≃INF NLP.\nNow, let us focus on the relationship between logic programs and second-order logic. The following proposition says that, over infinite structures, normal programs are more expressive than the existential second-order logic, which then strengthens a result in [3] where such a separation over arbitrary structures was obtained.\nProposition 3. NLP 6≤INF Σ11.\nTo show this, our main idea is to define a property that can be defined by a normal program but not by any existential second-order sentence. The property is defined as follows. Let υR be the vocabulary consisting of a binary predicate E and two individual constants s and t. Let REACHi be the class of infinite υR-structures in each of which there is a finite path from s to t via edges in E. Now, we show the result.\nProof of Proposition 3. First show that REACHi is definable in NLP over infinite structures. Let Π be the normal program\n{ P (s) , P (x) ∧ E(x, y) → P (y), ¬P (t) → ⊥ } . (35)\nBy a simple check, we can show that the formula ∃PSM(Π) defines the desired property over infinite structures.\nNext, we prove that REACHi is undefinable in Σ11 over infinite structures. Towards a contradiction, assume that there is a first-order sentence ϕ and a finite set τ of predicates such that ∃τϕ is in Σ11 and defines REACHi over infinite structures. Let R be a binary predicate not in τ . Let ψ denote\n∀x∃yR(x, y) ∧ ∀x¬R(x, x)∧\n∀x∀y∀z[R(x, y) ∧R(y, z) → R(x, z)]. (36)\nIntuitively, it asserts that the relation R is both transitive and irreflexive, and each element in the domain has a successor w.r.t. this relation. It is obvious that such a relation exists if and only if the domain is infinite. Therefore, the formula ∃τϕ ∧ ∃Rψ defines REACHi over arbitrary structures.\nMoreover, let γ0(x, y) be x = y; for all n > 0 let γn(x, y) denote ∃zn(γn−1(x, zn)∧ E(zn, y)), where each γn(x, y) asserts that there is a path of length n from x to y. Let Λ be the set of sentences ¬γn(s, t) for all n ≥ 0. Now we claim:\nClaim. Λ ∪ {∃τϕ, ∃Rψ} is satisfiable.\nTo show this, it suffices to show that the first-order theory Λ∪{ϕ, ψ} is satisfiable. Let Φ be a finite subset of Λ, and let n = max{m | ¬γm(s, t) ∈ Φ}. Let A be an infinite model of ψ with vocabulary υ(ϕ) ∪ υ(ψ) in which the minimal length of paths from s to t via edge E is an integer > n. Then A is clearly a model of Φ∪{ϕ, ψ}. Due to the arbitrariness of Φ, by the compactness we then have the desired claim.\nLet A be any model of Λ ∪ {∃τϕ, ∃Rψ}. Then according to ∃Rψ, A should be infinite, and by Λ, there is no path from s to t via E in A. However, according to ∃τϕ, every infinite model of it should be s-to-t reachable, a contradiction. Thus, the property REACHi is then undefinable in Σ11 over infinite structures. This completes the proof immediately.\nThe following separation immediately follows from the proof of Theorem 4.1 in [10]. Although their statement refers to arbitrary structures, the proof still works if only infinite structures are focused.\nProposition 4. Σ12 6≤INF DLP."
    }, {
      "heading" : "Finite Structures",
      "text" : "This section will focus on the expressiveness of logic programs over finite structures. We first consider the relationship between disjunctive and normal programs. Unfortunately, in the general case, we have the following result:\nProposition 5. DLP ≃FIN NLP iff NP = coNP.1\nProof. By Fagin’s Theorem [13] and Stockmeyer’s logical characterization of the polynomial hierarchy [27],2 we have that Σ12 ≃FIN Σ 1 1 iff Σ p 2 = NP. By a routine complexity theoretical argument, it is also true that Σp2 = NP iff NP = coNP. On the other hand, according to the proof of Theorem 6.3 in [11], or by Proposition 7 in this section, Leivant’s normal form [20] and the definition of SM, we can conclude DLP ≃FIN Σ12; by Proposition 6 in this section, it holds that NLP ≃FIN Σ11. Combining these conclusions, we then have the desired proposition.\nThis result shows us how difficult it is to separate normal programs from disjunctive programs over finite structures. To know more about the relationship, we will try to prove a weaker separation between these two classes. Before doing this, we need to study the relationship between logic programs and second-order logic. For the class of normal programs, we have the following characterization:\nProposition 6. NLPFn ≃FIN Σ 1F 1,n[∀ ∗] for all n > 1.\nTo prove the above characterization, we have to develop a translation that turns normal programs to first-order sentences. The main idea is to extend the Clark completion by a progression simulation, so it is an improved version of the ordered completion proposed by [3].\nNow, we define the translation. Let Π be a normal program and n the maximal arity of intensional predicates of Π. Without loss of generality, assume the head of every rule in Π is of form P (x̄), where P is a k-ary predicate for some k ≥ 0, and x̄ is the tuple of distinct individual variables x1, . . . , xk . Let ≺ be a new binary predicate and ̟ a\n1A similar result for traditional logic programs under the query equivalence can be obtained by the expressiveness results proved by [26, 11].\n2In their characterizations of complexity classes, no function constant of positive arity is allowed. However, this restriction can be removed as functions can be easily simulated by predicates.\nuniversal first-order sentence asserting that ≺ is a strict partial order. Given two tuple s̄, t̄ of terms of the same length, let s̄ ≺ t̄ be a quantifier-free formula asserting that s̄ is less than t̄ w.r.t. the lexicographic order extended from ≺ naturally.\nLet τ be the set of intensional predicates of Π. Let c be the least integer ≥ log2 |τ |+ n. Fix P to be a k-ary predicate in τ and let λ = P (x1, . . . , xk). Suppose γ1, . . . , γl list all the rules in Π whose heads are λ, and suppose γi is of form\nζi ∧ ϑi1 ∧ · · · ∧ ϑ i mi → λ (37)\nwhere ϑi1, . . . , ϑimi list all the positive intensional conjuncts in the body of γi, ζ i is the conjunction of other conjuncts that occurs in the body of γi, mi ≥ 0, and ȳi is the tuple of all individual variables occurring in γi but not in λ.\nNext, we let ϕP denote the conjunction of rules γi for all i : 1 ≤ i ≤ l, and let ψP denote the formula\nλ → l ∨\ni=1\n∃ȳi\n ζi ∧ mi ∧\nj=1\n(\nϑij ∧ LESSD(ϑ i j , λ)\n)\n\n (38)\nwhere, for every intensional atomsϑ andϑ0, ord(ϑ) denotes the tuple (ocQ(t̄), · · · , o 1 Q(t̄)) if ϑ of form Q(t̄), each osQ is a new function whose arity is the same as that of Q, and LESSD(ϑ, ϑ0) denotes formula ord(ϑ) ≺ ord(ϑ0).\nDefine ϕΠ as the universal closure of conjunction of the formula ̟ and formulas ϕP ∧ψP for all P ∈ τ . Let σ be the set of functions osQ for all Q ∈ τ and s : 1≤ s≤ c. Clearly, ∃σϕΠ is equivalent to a sentence in Σ1F1,n[∀∗] by introducing Skolem functions if n > 1. Now we show the soundness:\nLemma 3. Given any finite structure A of υ(Π) with at least two elements in the domain, A |= SM(Π) iff A |= ∃σϕΠ.\nProof. Due to the limit of space, we only show the right-to-left direction. Let B be a finite model of ϕΠ. By formula ̟, B must interpret predicate ≺ as a strict partial order on B. Let A be the restriction of B to υ(Π). To show that A is a stable model of Π, by Proposition 2 it suffices to show that INS(A, τ) = ΓAΠ ↑ω. We first claim that ΓAΠ ↑m ⊆ INS(A, τ) for all m ≥ 0. This can be shown by an induction on m. The case of m = 0 is trivial. Let m > 0 and assume ΓAΠ ↑m−1⊆ INS(A, τ). Our task is to show ΓAΠ ↑m ⊆ INS(A, τ). Let p be a ground atom in ΓAΠ ↑m. By definition, there must exist a rule γi of form (37) in Π and an assignment α in A such that λ[α] = p, α satisfies ζi in A (so equivalently, in B), and for each atom ϑij , ϑij [α] ∈ ΓAΠ ↑m−1. By the inductive assumption, each ϑij[α] ∈ INS(A, τ), or in other words, α satisfies each ϑij in A (so equivalently, in B). As α clearly satisfies the rule γi in B, we can conclude that α satisfies λ in B, which implies p = λ[α] ∈ INS(B, τ) = INS(A, τ). So, the claim is true. From it, we have ΓAΠ ↑ω⊆ INS(A, τ).\nNow, it remains to prove INS(A, τ) ⊆ ΓAΠ ↑ω. Towards a contradiction, assume this is not true. Then we must have ΓAΠ ↑ω ( INS(A, τ) by the previous conclusion. Given two ground intensional atoms p1 and p2 in INS(A, τ), we define p1 < p2 if LESSD(p1, p2) is true in B. Let p be a <-minimal atom in INS(A, τ) − ΓAΠ ↑ω and suppose p = P (ā) for some P ∈ τ . Let α be an assignment in B such that α(x̄) = ā.\nBy definition, α should satisfy ψP (in which λ[α] = p) in B. So, there exist an integer i : 1 ≤ i ≤ l and an assignment α0 in B such that (i) α0(x̄) = ā, (ii) ζi[α0] is true in B, and (iii) for all j, qj ∈ INS(B, τ) = INS(A, τ) and qj < λ[α0], where qj denotes ϑij[α0]. As λ[α0] = λ[α] = p and p is <-minimal in INS(A, τ) − ΓAΠ ↑ω, we can conclude qj ∈ ΓAΠ ↑ω for all j. According to the definition of ψP , the rule γi (of form (37)) is in Π, which implies q1 ∧ · · · ∧ qmi → p = γ + i [α0] ∈ Π A. By definition, we then have p ∈ ΓAΠ ↑ω, a contradiction.\nRemark 3. Let m and n be the number and the maximal arity of intensional predicates respectively. The maximal arity of auxiliary constants in our translation is only n (that of the ordered completion in [3] is 2n), which is optimal if Conjecture 13 in [6] is true. Moreover, the number of auxiliary constants in our translation is m · (⌈log2 m⌉ + n), while that of the ordered completion is m2. (Note that n is normally very small.)\nRemark 4. Similar to the work in [3], we can develop an answer set solver by calling some SMT solver. By the comparison in the above remark, this approach is rather promising. In addition, as a strict partial order is available in almost all the SMT solvers (e.g., built-in arithmetic relations), our translation can be easily optimized.\nNow we are in the position to prove Proposition 6.\nProof of Proposition 6. “≥FIN”: Let ϕ be any sentence in Σ1F1,n[∀∗]. It is obvious that ϕ can be written as an equivalent sentence of form ∃τ∀x̄(γ1 ∧ · · · ∧ γk) for some k ≥ 0, where each γi is a disjunction of atoms or negated atoms, and τ a finite set of functions or predicates of arity ≤ n. Let Π be a logic program consisting of the rule γ̃i → ⊥ for each i : 1 ≤ i ≤ k, where γ̃i is obtained from γi by substituting ϑ for each negated atom ¬ϑ, followed by substituting ¬ϑ for each atom ϑ, and followed by substituting ∧ for ∨. It is easy to check that ∃τSM(Π) is in NLPFn and equivalent to ϕ.\n“≤FIN”: Let C=1 (respectively, C>1) be the class of finite structures with exactly one (respectively, at least two) element(s) in the domain. Let Π be a normal program and τ a finite set of predicates and functions such that ∃τSM(Π) is in NLPFn. It is trivial to construct a sentence, say ζ, in Σ1F1,n[∀∗] such that ∃τSM(Π) is equivalent to ζ over C=1. (Please note that, if the domain is a singleton, a first-order logic program will regress to a propositional one.) By Lemma 3, there is also a sentence ψ in Σ1F1,n[∀∗] such that ∃τSM(Π) is equivalent to ψ over C>1. Let ϕ be the following sentence:\n[∃x∀y(x = y) ∧ ζ] ∨ [∃x∃z(¬x = z) ∧ ψ]. (39)\nInformally, this formula first test whether or not the domain is a singleton. If it is true, let ζ work; otherwise let ψ work. Thus, it is easy to show that ∃τSM(Π) is equivalent to ϕ over finite structures. It is also clear that ϕ can be written to be an equivalent sentence in Σ1F1,n[∀∗]. (Please note that every first-order quantifier can be regarded as a second-order quantifier over a function variable of arity 0.)\nRemark 5. Assuming Conjecture 1 in [6], by the results of [17], NLPFk then exactly captures the class of languages computable in O(nk)-time (where n is the size of input)\n3It implies ESOFn[∀∗] ≃FIN ESO F n[∀ n], where the latter is the class of sentences in ESOFn[∀∗] with at most n individual variables.\nin Nondeterministic Random Access Machines (NRAMs), and whether an extensional database can be expanded to a stable model of a disjunctive program is decidable in O(nk)-time in NRAMs.\nBy Proposition 6 and the fact that auxiliary functions can be simulated by auxiliary predicates in both logic programs and second-order logic, we have the following result:\nCorollary 2. NLP ≃FIN Σ11.\nNext, let us focus on the translatability from a fragment of second-order logic to disjunctive programs. For convenience, in the rest of this paper, we fix SUCC to be a binary predicate, fix FIRST and LAST to be two unary predicates, and fix υS to be the set consisting of these predicates. In particular, unless mentioned otherwise, a logic program or a formula is always assumed to contains no predicate in υS.\nA structure A is called a successor structure if:\n1. its vocabulary contains all the predicates in υS, and\n2. SUCCA is a binary relation R on A such that the transitive closure of R is a strict total order and for all a ∈ A, both |{b | (a, b) ∈ R}| ≤ 1 and |{b | (b, a) ∈ R}| ≤ 1 hold, and\n3. FIRSTA (respectively, LASTA) consists of the least element (respectively, the largest element) in A w.r.t. SUCCA.\nBy this definition, given a successor structure, both the least and largest elements must exist, so it is then finite. Now, we let SUC denote the class of successor structures.\nLet Σ12,n[∀n∃∗] be the class of sentences in Σ12,n[∀∗∃∗] that involve at most n universal quantifiers. Now we can show:\nLemma 4. Σ12,n[∀ n∃∗] ≤SUC DLPn for all n > 0.\nProof. (Sketch) Let ∃τ∀σϕ be any sentence in Σ12,n[∀ n∃∗] where τ, σ are finite sets of predicates of arities ≤ n. Without loss of generality, supposeϕ = ∀x̄∃ȳ(ϑ1∨· · ·∨ϑm), where x̄ is of length n; each ϑi is a finite conjunction of literals. Next, we want to construct a disjunctive program which defines the property expressed by the sentence ∃τ∀σϕ.\nBefore constructing the program, we need to define some notations. Let ū and v̄ be any two tuples of individual variablesu1 · · ·uk and v1 · · · vk respectively. Let FIRST(ū) denote the conjunction of FIRST(ui) for all i : 1 ≤ i ≤ k, and let LAST(ū) denote the conjunction of LAST(ui) for all i : 1 ≤ i ≤ k. Moreover, let SUCCi(ū, v̄) be the formula\n\n \nu1 = v1 ∧ · · · ∧ ui−1 = vi−1\n∧ SUCC(ui, vi) ∧ LAST(ui+1)\n∧ FIRST(vi+1) ∧ · · · ∧ LAST(uk) ∧ FIRST(vk)\n\n  (40)\nfor each i : 1 ≤ i ≤ k.\nNow let us construct the translation. First we define:\n∆1 = { X(z̄) ∨X c(z̄) | X ∈ σ ∪ τ } , ∆2 = { LAST(x̄) ∧D(x̄) → Xc(z̄) | X ∈ σ } ,\n∆3 = { LAST(x̄) ∧D(x̄) → X(z̄) | X ∈ σ } , ∆4 = { FIRST(x̄) ∧ ϑci (x̄, ȳ) → D(x̄) | 1 ≤ i ≤ m } ,\n∆5 =\n{\nSUCCj(v̄, x̄) ∧D(v̄)∧\nϑci (x̄, ȳ) → D(x̄)\n∣ ∣ ∣ ∣ ∣ 1 ≤ i ≤ m 1 ≤ j ≤ n } ,\n∆6 = { LAST(x̄) ∧ ¬D(x̄) → ⊥ } ,\nwhere, for each X ∈ σ ∪ τ , Xc is a new predicate of the same arity; ϑci is the formula obtained from ϑi by substituting Xc for ¬X whenever X ∈ σ ∪ τ ; D is an n-ary new predicate.\nLet Π be the union of ∆1, . . . ,∆6 and π the set of new predicates introduced in the translation. Clearly, ∃πSM(Π) is in DLPn. By a similar (slightly more complicated) argument to that in Theorem 6.3 of [11], we can show that ∃π∃τ∃σSM(Π) ≡SUC ∃τ∀σϕ.\nNext, we show that this result can be generalized to finite structures. To do this, we need a program to define the class of successor structures. Now we define it as follows.\nLet ΠS be the program consisting of the following rules.\n¬LESS(x, y) → LESS(x, y) (41)\n¬LESS(x, y) → LESS(x, y) (42)\nLESS(x, y) ∧ LESS(y, z) → LESS(x, z) (43)\nLESS(x, y) ∧ LESS(y, x) → ⊥ (44)\n¬LESS(x, y) ∧ ¬LESS(y, x) ∧ ¬x = y → ⊥ (45)\nLESS(x, y) → FIRST(y) (46)\n¬FIRST(x) → FIRST(x) (47)\nLESS(x, y) → LAST(x) (48)\n¬LAST(x) → LAST(x) (49)\nLESS(x, y) ∧ LESS(y, z) → SUCC(x, z) (50)\n¬SUCC(x, y) ∧ LESS(x, y) → SUCC(x, y) (51)\nInformally, rules (41)–(42) are choice rules to guess a binary relation LESS; rule (43), (44) and (45) restrict LESS to be transitive, antisymmetric and total respectively so that it is a strict total order; rules (46)–(47) and rules assert that FIRST and LAST consist of the least and the last elements respectively if they exist; the last two rules then assert that SUCC defines the relation for direct successors. The following simple lemma shows that ΠS is the desired program.\nLemma 5. Given a vocabulary σ ⊇ υS and a structure A of σ, A is a successor structure iff it is finite and is a model of ∃τSM(ΠS), where τ denotes υ(ΠS)− υS.\nNow we can then prove the following result:\nProposition 7. Σ12,n[∀ n∃∗] ≤FIN DLPn for all n > 1.\nProof. Let n > 1 and ϕ a sentence in Σ12,n[∀ n∃∗]. Let Π0 be the disjunctive program constructed in the proof of Lemma 4 related to ϕ, and let σ be the set of predicates appearing in Π0 but neither in υS nor in υ(ϕ). Let Π = Π0 ∪ ΠS and let τ be the set of predicates appearing in ΠS but not in υS. Next we show that ϕ is equivalent to ∃τ∃σSM(Π) over finite structures. By definition and the splitting lemma in [15], it suffices to show that ϕ is equivalent to\n∃υS(∃τSM(ΠS) ∧ ∃σSM(Π0)) (52)\nover finite structures. Let υ denote the union of υ(ϕ) and υS. Now we prove the new statement as follows.\n“=⇒”: Let A be a finite model of ϕ. Clearly, there must exist at least one υexpansion, say B, of A such that B is a successor structure. By Lemma 5, B should be a model of ∃τSM(ΠS), and by the proof of Lemma 4, B is also a model of ∃σSM(Π0). Hence, A is a model of formula (52).\n“⇐=”: Let A be a finite model of formula (52). Then there is an υ-expansion, say B, of A such that B satisfies both ∃τSM(ΠS) and ∃σSM(Π0). By Lemma 5, B is a successor structure, and then by the proof of Lemma 4, B must be a model of ϕ. This means that A is a model of ϕ.\nWith these results, we can prove a weaker separation:\nTheorem 2. DLPn 6≤FIN NLP F 2n−1 for all n > 1.\nProof. Let υn be the vocabulary consisting of only an n-ary predicate Pn. Define PARITYn to be the class of finite υn-structures in each of which Pn is interpreted as a set consisting of an even number of n-tuples. Fix n > 1. Now, let us show that PARITY2n is definable in DLPn over FIN.\nWe first show that, over successor structures, PARITY2n is definable in Σ12,n[∀n∃∗]. Let FIRST, LAST and SUCCi be the same as those in the proof of Lemma 4, and let SUCC(s̄, t̄) denote the conjunction of SUCCi(s̄, t̄) for all i : 1 ≤ i ≤ n if s̄ and t̄ are n-tuples of terms. Let X and Y be two predicate variables of arity n. We define ϕ1 to be the formula\n[\n∀z̄(FIRST(z̄) → [Y (z̄) ↔ P2n(x̄, z̄)])∧\n∀ȳz̄(SUCC(ȳ, z̄) → [P2n(x̄, z̄) ↔ Y (ȳ)⊕ Y (z̄)])\n]\n→ ∃z̄(LAST(z̄) ∧ [X(x̄) ↔ Y (z̄)]),\nwhere ψ ⊕ χ denotes the formula (ψ ↔ ¬χ). Informally, ϕ1 is intended to define “X(ā) is true if and only if the cardinality of {b̄ | P (ā, b̄)} is odd”. Define ϕ2 to be the formula\n[\n∀z̄(FIRST(z̄) → [X(z̄) ↔ Y (z̄)])∧\n∀ȳz̄(SUCC(ȳ, z̄) → [X(z̄) ↔ Y (ȳ)⊕ Y (z̄)])\n]\n→ ∃z̄[LAST(z̄) ∧ ¬Y (z̄)].\nIntuitively,ϕ2 asserts “X consists of an even number of n-tuples on the domain”. Now, let ϕ = ∃X∀Y ∀x̄(ϕ1 ∧ ϕ2). Obviously, ϕ can be written as an equivalent sentence in Σ12,n[∀\nn∃∗]. By a careful check, it is not difficult to show that, given any successor structure A of υ(ϕ), the restriction of A to υ2n is in PARITY2n if and only if A is a model of ϕ.\nAccording to the proof of Lemma 4, there exist a disjunctive program Π0 and a finite set τ of predicates of arities ≤ n such that ∃τSM(Π0) is equivalent to ϕ over successor structures and no predicate in υS is intensional w.r.t. Π0. Let Π be the union of ΠS and Π0. Let σ be the set of predicates in υ(Π)− υ2n. It is easy to show that, over finite structures, PARITY2n is defined by ∃σSM(Π), so definable in DLPn.\nNext, we show that PARITY2n is undefinable in NLPF2n−1 over finite structures. If this is true, we then obtain the desired proposition immediately. By Proposition 6, it is sufficient to prove that PARITY2n is not definable in Σ1F1,2n−1 over finite structures. Towards a contradiction, assume that it is not true. By a similar argument to that in Theorem 3.1 of [7], we have:\nClaim. Let m ≥ 1. Then PARITY2m is definable in Σ1F1,2m−2 over FIN if PARITYm is definable in Σ1F1,m−1 over FIN.\nWith this claim, we can then infer that PARITY4n is definable in Σ1F1,4n−2 over finite structures. As every function variable of arity k ≥ 0 can always be simulated by a predicate variable of arity k + 1, PARITY4n should be definable in Σ11,4n−1 over finite structures, which contradicts with Theorem 2.1 in [1]. This completes the proof."
    }, {
      "heading" : "Arbitrary Structures",
      "text" : "Based on the results presented in the previous two sections, we can then compare the expressiveness of disjunctive programs and normal programs over arbitrary structures.\nTheorem 3. DLP ≃ NLP iff DLP ≃FIN NLP.\nProof. The left-to-right direction is trivial. Now let us show the converse. Assume DLP ≃FIN NLP, and let Π be a disjunctive program. Then there must exist a normal program Π◦ such that SM(Π) ≡FIN ∃σSM(Π◦), where σ is the set of predicates occurring in Π◦ but not in Π. By Theorem 1, there is a normal program Π⋄ such that SM(Π) ≡INF ∃τSM(Π⋄). Without loss of generality, let us assume σ ∩ τ = ∅. To show DLP ≃ NLP, our idea is to design a normal program testing whether or not the intended structure is finite. If that is true, we let Π◦ work; otherwise, let Π⋄ work. To do this, we introduce a new predicate FINITE of arity 0, and let ΠT be the union of ΠS and the following logic program:\n\n \n \nFIRST(x) → NUM(x),\nNUM(x) ∧ SUCC(x, y) → NUM(y),\nNUM(x) ∧ LAST(x) → FINITE\n\n \n \n. (53)\nLet π = υ(ΠT)− {FINITE}. We then have the following:\nClaim. If A |=∃πSM(ΠT), then A is finite iff A |= FINITE.\nThe left-to-right direction follows from Lemma 5. We only show the converse. Let us assume that A satisfies both FINITE and ∃πSM(ΠT). Let υ0 be the union of υ(ΠT) and the vocabulary of A. Then, there must exist an υ0-expansion B of A such that B is a stable model of ΠT. So, LESSB should be a strict total order on A; the element in FIRSTB (respectively, LASTB), if it exists, should be the least (respectively, largest) element in A w.r.t. LESSB; and SUCCB should be the relation defining the direct successors w.r.t. LESSB. As FINITE is true in A, there must exist an integer n ≥ 0 and n elements a1, . . . , an in A such that FIRST(a1), LAST(an) and each SUCC(ai, ai+1) are true in B. We assert that every element in A should be ai for some i. If not, let b be one of such elements. As LESSB is a strict total order, there must exist i : 1≤ i < n such that both LESS(ai, b) and LESS(b, ai+1) are true in B. But this is impossible since SUCC(ai, ai+1) is true in B. So, we must have A = {a1, . . . , an}. This implies that A is finite, and then we obtain the claim.\nNext, let us construct the desired program. Let Π◦0 (respectively Π ⋄ 0) denote the normal program obtained from Π◦ (respectively, Π⋄) by adding FINITE (respectively, ¬FINITE) to the body of each rule as a conjunct. Let Π† be the union of Π◦0, Π ⋄ 0 and ΠT. Let ν = υ(Π†) − υ(Π). Now, we show that ∃νSM(Π†) is equivalent to SM(Π) over arbitrary structures. By definition and the splitting lemma in [15], it suffices to show that SM(Π) is equivalent to\n∃FINITE[∃σSM(Π◦0) ∧ ∃τSM(Π ⋄ 0) ∧ ∃πSM(ΠT)]. (54)\nLet A be a structure of υ(Π). As a strict partial order always exists on domain A, we can construct an υ(Π) ∪ υ(ΠT)-expansion B of A such that B is a stable model of ΠT. By the claim, B |= FINITE if and only if A is finite. First assume that A is finite. By definition, it is clear that ∃σSM(Π◦0) is satisfied by B if and only if ∃σSM(Π\n◦) is satisfied by A, and ∃σSM(Π⋄0) is always true in B. This means that ∃νSM(Π\n†) is equivalent to SM(Π) over finite structures. By a symmetrical argument, we can show that the equivalence also holds over infinite structures. This then completes the proof.\nRemark 6. In classical logic, it is well-known that separating languages over arbitrary structures is usually easier than that over finite structures [8]. In logic programming, it also seems that arbitrary structures are better-behaved than finite structures. For example, there are some preservation theorems that work on arbitrary structures, but not on finite structures [2]. Thus, it might be possible to develop techniques on arbitrary structures for some stronger separations of DLP from NLP.\nCorollary 3. DLP ≃ NLP iff NP = coNP.\nNext, we give a characterization for disjunctive programs.\nProposition 8. DLP ≃ Σ12[∀ ∗∃∗].\nProof. (Sketch) The direction “≤” trivially follows from the second-order definition of stable model semantics. So, it remains to show the converse. Let ϕ be a sentence in Σ12[∀ ∗∃∗]. Without loss of generality, assume that ϕ is of the form\n∃τ∀σ∀x̄∃ȳ[ϑ1(x̄, ȳ) ∨ · · · ∨ ϑk(x̄, ȳ)] (55)\nwhere τ and σ are two finite sets of predicates; x̄ and ȳ two finite tuples of individual variables; each ϑi is a conjunction of atoms or negated atoms. Let n be the length of x̄.\nNow, we construct a translation. Firstly, let us define\nΛ1 = {TX(x̄, z̄) ∨ FX(x̄, z̄) | X ∈ σ ∪ τ },\nΛ2 = { D(x̄) → FX(x̄, z̄) | X ∈ σ },\nΛ3 = { D(x̄) → TX(x̄, z̄) | X ∈ σ }, Λ4 = { ϑ ⋄ i (x̄, ȳ) → D(x̄) | 1 ≤ i ≤ k },\nΛ5 = { ¬D(x̄) → ⊥ },\n(56)\nwhere, for each X ∈ σ∪τ , TX and FX are two distinct new predicates of arity (m+n) if m is the arity of X ; each ϑ⋄i is the formula obtained from ϑi by substituting FX(x̄, t̄) for ¬X(t̄) and followed by substituting TX(x̄, t̄) for X(t̄) whenever X ∈ σ ∪ τ and t̄ is a tuple of terms of the corresponding length; and D is an n-ary new predicate.\nLet Π be the union of Λ1, . . . ,Λ5. Clearly, Π is a disjunctive program. Let π be the set of new predicates introduced in the translation. By a similar argument to that in Lemma 4, we can show that ϕ is equivalent to ∃πSM(Π)."
    }, {
      "heading" : "Conclusion and Related Work",
      "text" : "Combining the results proved in previous sections with some existing results, we then obtain an almost complete picture for the expressiveness of logic programs and some related fragments of second-order logic. As shown in Figure 1, the expressiveness hierarchy in each subfigure is related to a structure class. In each subfigure, the syntactical classes in a same block are proved to be of the same expressiveness over the related structure class. A block is closer to the top, the classes in the block are then more expressive. In addition, a dashed line means that the corresponding separation is true if and only if NP is not closed under complement.\nWithout involving the well-known complexity conjecture, we established the intranslatability from disjunctive to normal programs over finite structures if the arities of auxiliary constants are bounded in a certain sense. This can be regarded as evidence\nthat disjunctive programs are more expressive than normal programs over finite structures. As a byproduct, we also developed a succinct translation from normal programs to first-order sentences. This then improved the ordered completion proposed by [3].\nThere are several existing works contributing to Figure 1, which are listed as follows. The translatability from Σ11 to Σ1F1 [∀∗] follows from the well-known Skolem normal form. The translatability from Σ12 to Σ 1 2[∀\n∗∃∗] over finite structures is due to [20]. The separation of Σ12 from Σ12[∀∗∃∗] (on both arbitrary and infinite structures) is due to [10]. From NLP to Σ11, both the intranslatability over arbitrary structures and the translatability over finite structures are due to [3].\nThe (in)translatability between first-order theories and logic programs were also considered in [29]. But first-order theories there are based on non-monotonic semantics. Over Herbrand structures, [26, 9] proved that normal programs, disjunctive programs and universal second-order logic are of the same expressiveness under the query equivalence. Their proofs employ an approach from recursion theory. However, this approach seems difficult to be applied to general infinite structures. In the propositional case, there have been a lot of works on the translatability and expressiveness of logic programs, e.g., [12, 19]. It should be noted that the picture of expressiveness and translatability in there is quite different from that in the first-order case."
    } ],
    "references" : [ {
      "title" : "Σ11-formulae on finite structures",
      "author" : [ "M. Ajtai" ],
      "venue" : "Annals of Pure and Applied Logic 24 ",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1983
    }, {
      "title" : "Datalog vs first-order logic",
      "author" : [ "M. Ajtai", "Y. Gurevich" ],
      "venue" : "Journal of Computer and System Sciences 49 ",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Ordered completion for first-order logic programs on finite structures",
      "author" : [ "V. Asuncion", "F. Lin", "Y. Zhang", "Y. Zhou" ],
      "venue" : "Artificial Intelligence 177–179 ",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Propositional semantics for disjunctive logic programs",
      "author" : [ "R. Ben-Eliyahu", "R. Dechter" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 12 ",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov" ],
      "venue" : "ACM Computing Surveys 33 ",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "New results on arity vs",
      "author" : [ "A. Durand", "E. Grandjean", "F. Olive" ],
      "venue" : "number of variables, Research report 20–2004, LIF, Marseille, France ",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Subclasses of binary NP",
      "author" : [ "A. Durand", "C. Lautemann", "T. Schwentick" ],
      "venue" : "Journal of Logic and Computation 8 ",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Finite model theory",
      "author" : [ "H.-D. Ebbinghaus", "J. Flum" ],
      "venue" : "2 ed., Springer-Verlag, New York",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Expressiveness of stable model semantics for disjunctive logic programs with functions",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "The Journal of Logic Programming 33 ",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Normal forms for second-order logic over finite structures",
      "author" : [ "T. Eiter", "G. Gottlob", "Y. Gurevich" ],
      "venue" : "and classication of NP optimization problems, Annals of Pure and Applied Logic 78 ",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Disjunctive datalog",
      "author" : [ "T. Eiter", "G. Gottlob", "H. Mannila" ],
      "venue" : "ACM Transactions on Database Systems 22 ",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "On eliminating disjunctions in stable logic programming",
      "author" : [ "Thomas Eiter", "Michael Fink", "Hans Tompits", "Stefan Woltran" ],
      "venue" : "Proceedings of KR,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2004
    }, {
      "title" : "Generalized first-order spectra and polynomial-time recognizable sets",
      "author" : [ "R. Fagin" ],
      "venue" : "Complexity of Computation, SIAM-AMS Proceedings, vol. 7",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1974
    }, {
      "title" : "Stable models and circumscription",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Artificial Intelligence 175 ",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Symmetric splitting in the general theory of stable models",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz", "R. Palla" ],
      "venue" : "Proceedings of IJCAI",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of ICLP/SLP",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Universal quantifiers and time complexity of random access machines",
      "author" : [ "Etienne Grandjean" ],
      "venue" : "Mathematical Systems Theory",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1985
    }, {
      "title" : "Descriptive complexity, Graduate texts in computer",
      "author" : [ "Neil Immerman" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1999
    }, {
      "title" : "Some (in)translatability results for normal logic programs and propositional theories",
      "author" : [ "Tomi Janhunen" ],
      "venue" : "Journal of Applied Non-Classical Logics",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2006
    }, {
      "title" : "Descriptive characterizations of computational complexity",
      "author" : [ "D. Leivant" ],
      "venue" : "Journal of Computer and System Sciences 39 ",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Cmodels-2: SAT-based answer set solver enhanced to non-tight programs",
      "author" : [ "Yuliya Lierler", "Marco Maratea" ],
      "venue" : "Proceedings of LPNMR,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2004
    }, {
      "title" : "Assat: computing answer sets of a logic program by sat solvers",
      "author" : [ "F. Lin", "Y. Zhao" ],
      "venue" : "Artificial Intelligence 157 ",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "From answer set logic programming to circumscription via logic of GK",
      "author" : [ "F. Lin", "Y. Zhou" ],
      "venue" : "Artificial Intelligence 175 ",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Foundations of disjunctive logic programming",
      "author" : [ "J. Lobo", "J. Minker", "A. Rajasekar" ],
      "venue" : "The MIT Press, Cambridge",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "A first order nonmonotonic extension of constructive logic",
      "author" : [ "David Pearce", "Agustłn Valverde" ],
      "venue" : "Studia Logica",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2005
    }, {
      "title" : "The expressive powers of the logic programming semantics",
      "author" : [ "J.S. Schlipf" ],
      "venue" : "Journal of Computer and System Sciences 51 ",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "The polynomial-time hierarchy",
      "author" : [ "L.J. Stockmeyer" ],
      "venue" : "Theoretical Computer Science 3 ",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "First-order expressibility and boundedness of disjunctive logic programs",
      "author" : [ "Heng Zhang", "Yan Zhang" ],
      "venue" : "Proceedings of IJCAI,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "Nowadays, the most popular semantics for this formalism is the stable model semantics proposed by [16].",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 13,
      "context" : "To overcome this limit, the general stable model semantics, which generalizes the original semantics to arbitrary structures, was then proposed by [14] via second-order logic, by [23] via circumscription, and by [25] via Gödel’s 3-valued logic, which provides us a unified framework for answer set programming, armed with powerful tools from classical logic.",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 22,
      "context" : "To overcome this limit, the general stable model semantics, which generalizes the original semantics to arbitrary structures, was then proposed by [14] via second-order logic, by [23] via circumscription, and by [25] via Gödel’s 3-valued logic, which provides us a unified framework for answer set programming, armed with powerful tools from classical logic.",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 24,
      "context" : "To overcome this limit, the general stable model semantics, which generalizes the original semantics to arbitrary structures, was then proposed by [14] via second-order logic, by [23] via circumscription, and by [25] via Gödel’s 3-valued logic, which provides us a unified framework for answer set programming, armed with powerful tools from classical logic.",
      "startOffset" : 212,
      "endOffset" : 216
    }, {
      "referenceID" : 4,
      "context" : "An excellent survey for these works can be found in [5].",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 21,
      "context" : ", [22, 21].",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 20,
      "context" : ", [22, 21].",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 17,
      "context" : "As the arity of auxiliary symbol is the most important factor to introduce nondeterminism [18], we will try to find translations with small arities of auxiliary symbols.",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 13,
      "context" : "For more details about this transformation, please refer to [14].",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 27,
      "context" : "This procedure is called the first-order Gelfond-Lifschitz reduction due to the following result: Proposition 1 ([28], Proposition 4).",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 27,
      "context" : "Progression Semantics In this subsection, we review a progression semantics proposed by [28], which generalizes the fixed point semantics of [24] to logic programming with default negation over arbitrary structures.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 23,
      "context" : "Progression Semantics In this subsection, we review a progression semantics proposed by [28], which generalizes the fixed point semantics of [24] to logic programming with default negation over arbitrary structures.",
      "startOffset" : 141,
      "endOffset" : 145
    }, {
      "referenceID" : 27,
      "context" : "Proposition 2 ([28], Theorem 1).",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 3,
      "context" : "For Lemma 2, roughly speaking, the soundness is assured by the result that every head-cycle-free disjunctive program is equivalent to the normal program obtained by shifting [4].",
      "startOffset" : 174,
      "endOffset" : 177
    }, {
      "referenceID" : 14,
      "context" : "By the splitting lemma in [15] and the second-order transformation, it suffices to show that SM(Π) is equivalent to the following formula",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 2,
      "context" : "The following proposition says that, over infinite structures, normal programs are more expressive than the existential second-order logic, which then strengthens a result in [3] where such a separation over arbitrary structures was obtained.",
      "startOffset" : 175,
      "endOffset" : 178
    }, {
      "referenceID" : 9,
      "context" : "1 in [10].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 12,
      "context" : "By Fagin’s Theorem [13] and Stockmeyer’s logical characterization of the polynomial hierarchy [27],2 we have that Σ12 ≃FIN Σ 1 1 iff Σ p 2 = NP.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 26,
      "context" : "By Fagin’s Theorem [13] and Stockmeyer’s logical characterization of the polynomial hierarchy [27],2 we have that Σ12 ≃FIN Σ 1 1 iff Σ p 2 = NP.",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 10,
      "context" : "3 in [11], or by Proposition 7 in this section, Leivant’s normal form [20] and the definition of SM, we can conclude DLP ≃FIN Σ12; by Proposition 6 in this section, it holds that NLP ≃FIN Σ11.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 19,
      "context" : "3 in [11], or by Proposition 7 in this section, Leivant’s normal form [20] and the definition of SM, we can conclude DLP ≃FIN Σ12; by Proposition 6 in this section, it holds that NLP ≃FIN Σ11.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 2,
      "context" : "The main idea is to extend the Clark completion by a progression simulation, so it is an improved version of the ordered completion proposed by [3].",
      "startOffset" : 144,
      "endOffset" : 147
    }, {
      "referenceID" : 25,
      "context" : "Let ≺ be a new binary predicate and ̟ a 1A similar result for traditional logic programs under the query equivalence can be obtained by the expressiveness results proved by [26, 11].",
      "startOffset" : 173,
      "endOffset" : 181
    }, {
      "referenceID" : 10,
      "context" : "Let ≺ be a new binary predicate and ̟ a 1A similar result for traditional logic programs under the query equivalence can be obtained by the expressiveness results proved by [26, 11].",
      "startOffset" : 173,
      "endOffset" : 181
    }, {
      "referenceID" : 2,
      "context" : "The maximal arity of auxiliary constants in our translation is only n (that of the ordered completion in [3] is 2n), which is optimal if Conjecture 13 in [6] is true.",
      "startOffset" : 105,
      "endOffset" : 108
    }, {
      "referenceID" : 5,
      "context" : "The maximal arity of auxiliary constants in our translation is only n (that of the ordered completion in [3] is 2n), which is optimal if Conjecture 13 in [6] is true.",
      "startOffset" : 154,
      "endOffset" : 157
    }, {
      "referenceID" : 2,
      "context" : "Similar to the work in [3], we can develop an answer set solver by calling some SMT solver.",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 5,
      "context" : "Assuming Conjecture 1 in [6], by the results of [17], NLP k then exactly captures the class of languages computable in O(n)-time (where n is the size of input) 3It implies ESO n[∀∗] ≃FIN ESO F n[∀ ], where the latter is the class of sentences in ESO n[∀∗] with at most n individual variables.",
      "startOffset" : 25,
      "endOffset" : 28
    }, {
      "referenceID" : 16,
      "context" : "Assuming Conjecture 1 in [6], by the results of [17], NLP k then exactly captures the class of languages computable in O(n)-time (where n is the size of input) 3It implies ESO n[∀∗] ≃FIN ESO F n[∀ ], where the latter is the class of sentences in ESO n[∀∗] with at most n individual variables.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 10,
      "context" : "3 of [11], we can show that ∃π∃τ∃σSM(Π) ≡SUC ∃τ∀σφ.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 14,
      "context" : "By definition and the splitting lemma in [15], it suffices to show that φ is equivalent to",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 6,
      "context" : "1 of [7], we have: Claim.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : "1 in [1].",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 14,
      "context" : "By definition and the splitting lemma in [15], it suffices to show that SM(Π) is equivalent to ∃FINITE[∃σSM(Π◦0) ∧ ∃τSM(Π ⋄ 0) ∧ ∃πSM(ΠT)].",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 7,
      "context" : "In classical logic, it is well-known that separating languages over arbitrary structures is usually easier than that over finite structures [8].",
      "startOffset" : 140,
      "endOffset" : 143
    }, {
      "referenceID" : 1,
      "context" : "For example, there are some preservation theorems that work on arbitrary structures, but not on finite structures [2].",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 2,
      "context" : "This then improved the ordered completion proposed by [3].",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 19,
      "context" : "The translatability from Σ12 to Σ 1 2[∀ ∃] over finite structures is due to [20].",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 9,
      "context" : "The separation of Σ12 from Σ2[∀∃] (on both arbitrary and infinite structures) is due to [10].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 2,
      "context" : "From NLP to Σ11, both the intranslatability over arbitrary structures and the translatability over finite structures are due to [3].",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 25,
      "context" : "Over Herbrand structures, [26, 9] proved that normal programs, disjunctive programs and universal second-order logic are of the same expressiveness under the query equivalence.",
      "startOffset" : 26,
      "endOffset" : 33
    }, {
      "referenceID" : 8,
      "context" : "Over Herbrand structures, [26, 9] proved that normal programs, disjunctive programs and universal second-order logic are of the same expressiveness under the query equivalence.",
      "startOffset" : 26,
      "endOffset" : 33
    }, {
      "referenceID" : 11,
      "context" : ", [12, 19].",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 18,
      "context" : ", [12, 19].",
      "startOffset" : 2,
      "endOffset" : 10
    } ],
    "year" : 2014,
    "abstractText" : "The stable model semantics had been recently generalized to nonHerbrand structures by several works, which provides a unified framework and solid logical foundations for answer set programming. This paper focuses on the expressiveness of normal and disjunctive programs under the general stable model semantics. A translation from disjunctive programs to normal programs is proposed for infinite structures. Over finite structures, some disjunctive programs are proved to be intranslatable to normal programs if the arities of auxiliary predicates and functions are bounded in a certain way. The equivalence of the expressiveness of normal programs and disjunctive programs over arbitrary structures is also shown to coincide with that over finite structures, and coincide with whether NP is closed under complement. Moreover, to capture the exact expressiveness, some intertranslatability results between logic program classes and fragments of secondorder logic are obtained.",
    "creator" : "LaTeX with hyperref package"
  }
}