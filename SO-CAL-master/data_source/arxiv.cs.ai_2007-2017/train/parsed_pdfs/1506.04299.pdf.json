{
  "name" : "1506.04299.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Query-Answer Causality in Databases: Abductive Diagnosis and View-Updates",
    "authors" : [ "Babak Salimi" ],
    "emails" : [ "bsalimi@scs.carleton.ca", "bertossi@scs.carleton.ca" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 6.\n04 29\n9v 5\n[ cs\n.D B\n] 2\n0 Se\nCausality is an important notion that appears at the foundations of many scientific disciplines, in the practice of technology, and also in our everyday life. Causality is unavoidable to understand and manage uncertainty in data, information, knowledge, and theories. In data management in particular, there is a need to represent, characterize and compute the causes that explain why certain query results are obtained or not, or why natural semantic conditions, such as integrity constraints, are not satisfied. Causality can also be used to explain the contents of a view, i.e. of a predicate with virtual contents that is defined in terms of other physical, materialized relations (tables).\nIn this work we concentrate on causality as defined forand applied to relational databases. Most of the work on causality has been developed in the context of knowledge representation, and little has been said about causality in data management. Furthermore, in a world of big uncertain data, the necessity to understand the data beyond simple query answering, introducing explanations in different forms, has become particularly relevant.\nThe notion of causality-based explanation for a query result was introduced in (Meliou et al., 2010a), on the basis of the deeper concept of actual causation.1 Intuitively, a\n1In contrast with general causal claims, such as “smoking\ntuple (of constants) t is an actual cause for an answer ā to a conjunctive query Q from a relational database instance D if there is a “contingent” subset of tuples Γ, accompanying t, such that, after removing Γ from D, removing t from D r Γ causes ā to switch from being an answer to being a non-answer (i.e. not being an answer). Usually, actual causes and contingent tuples are restricted to be among a pre-specified set of endogenous tuples, which are admissible, possible candidates for causes, as opposed to exogenous tuples.\nA cause t may have different associated contingency sets Γ. Intuitively, the smaller they are the strongest is t as a cause (it need less company to undermine the query answer). So, some causes may be stronger than others. This idea is formally captured through the notion of causal responsibility, and introduced in (Meliou et al., 2010a). It reflects the relative degree of actual causality. In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities (Meliou et al., 2010b,a).\nFurthermore, view-conditioned causality was proposed in (Meliou et al., 2010b, 2011) as a restricted form of query causality, to determine causes for a set of unexpected query results, but conditioned to the correctness of prior knowledge about some other set of results.\nActual causation, as used in (Meliou et al., 2010a,b, 2011), can be traced back to (Halpern & Pearl, 2001, 2005), which provides a model-based account of causation on the basis of counterfactual dependence.2 Causal responsibility was introduced in Chockler & Halpern (2004), to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.\nModel-based diagnosis (Struss, 2008, sec. 10.3), an area of\ncauses cancer”, which refer some sort of related events, actual causation specifies a particular instantiation of a causal relationship, e.g., “Joe’s smoking is a cause for his cancer”.\n2As discussed in (Salimi & Bertossi, 2015), some objections to the Halpern-Pearl model of causality and the corresponding changes (Halpern, 2014, 2015) do not affect results in the context of databases.\nknowledge representation, addresses the problem of, given the specification of a system in some logical formalism and a usually unexpected observation about the system, obtaining explanations for the observation, in the form of a diagnosis for the unintended behavior. Since this and causality are related to explanations, a first connection between causality and consistency-based diagnosis (Reiter, 1987), a form of model-based diagnosis, was established in (Salimi & Bertossi, 2014, 2015): Causality and the responsibility problem can be formulated as consistency-based diagnosis problems, which allowed to extend the results in (Meliou et al., 2010a). However, no precise connection has been established so far between causality and abductive diagnosis (Console et al., 1991; Eiter & Gottlob, 1995), another form of model-based diagnosis.\nThe definition of causality for query answers applies to monotone queries (Meliou et al., 2010a,b). However, all complexity and algorithmic results in (Meliou et al., 2010a; Salimi & Bertossi, 2015) have been restricted to first-order (FO) monotone queries. Other important classes of monotone queries, such as Datalog queries (Ceri et al., 1989; Abiteboul et al., 1995), possibly with recursion, require further investigation.\nIn (Salimi & Bertossi, 2015) connections were established between query causality, database repairs (Bertossi, 2011), and consistency-based diagnosis. In particular, complexity results for several causality problems were obtained from the repair connection. In the line of this kind of research, in this work we unveil natural connections between actual causation and abductive diagnosis, and also the viewupdate problem in databases (more on this latter connection later in the section).\nAs opposed to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly performed under a logic programming (LP) approach (in the general sense of LP) to knowledge representation (Denecker & Kakas, 2002; Eiter et al., 1997; Gottlob et al., 2010b). Since Datalog can be seen as a form of LP, we manage to extend and formulate the notion of query-answer causality to Datalog queries via the abductive diagnosis connection, in this way extending causality to a new class of queries, e.g. recursive queries, and obtaining complexity results on causality for them.\nAbductive reasoning/diagnosis has been applied to the view update problem in databases (Kakas & Mancarella, 1990; Console et al., 1995), which is about characterizing and computing updates of physical database relations that give an account of (or have as result) the intended updates on views. The idea is that abductive diagnosis provides (abduces) the reasons for the desired view updates, and they are given as changes on base tables.\nIn this work we also explore fruitful connections of causality with this view-update problem (Abiteboul et al., 1995),\ni.e. about updating a database through views. An important aspect of the problem is that one wants the base, source database, i.e. the base relations, to change in a minimally way while still producing the view updates. Put in different terms, it is an update propagation problem, from views to base relations. This classical and important problem in databases.\nThe delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views. If the views are defined by monotone queries, only database deletions can give an account of view deletions. So, in this case, a minimal set (in some sense) of deletions from the base relations is expected to be performed. This is “minimal source-sideeffect” case. It is also possible to consider minimizing the side-effect on the view, which also requires that other tuples in the (virtual) view contents are not affected (deleted) (Buneman et al., 2002).\nIn this work we provide a precise connection between different variants of the delete-propagation problem and query causality. In particular, we show that the minimal source-side-effect problem is related to the mostresponsible cause problem, which was formulated and investigated in (Salimi & Bertossi, 2015); and also that the “minimal view side-effect problem” is related to viewconditioned causality we already mentioned above.\nThe established connections between abductive diagnoses, query causality and delete-propagation problems allow us to adopt (and possibly adapt) established results for some of them for application to the others. In this way we obtain some new complexity results.\nMore precisely, our main results are as follows:3\n1. We establish precise connections between causality for Datalog queries and abductive diagnosis. More precisely, we establish mutual characterizations of each in terms of the other, and computational reductions, between actual causes for Datalog queries and abductive diagnosis from Datalog specifications.\nWe profit from these connections to obtain new algorithmic and complexity results for each of the two problems separately.\n(a) We characterize and obtain causes in terms ofand from abductive diagnoses.\n(b) We show that deciding tuple causality for Datalog queries, possibly recursive, is NP-complete in data.\n(c) We identify a class of Datalog queries for which\n3The possible connections between the areas and problems in this paper were suggested in (Bertossi & Salimi, 2014), but no precise results were formulated there.\n2\ndeciding causality is tractable in combined complexity.\n2. We establish and profit from precise connections between delete-propagation and causality. More precisely, we show that:\n(a) Most-responsible causes and view-conditioned causes can be obtained from solutions to different variants of the delete-propagation problem and vice-versa.\n(b) Computing the size of the solution to a minimum source-side-effect problem is hard for FPNP(log(n)).\n(c) Deciding weather an answer has a viewconditioned cause is NP-complete.\n(d) We can identify some new classes of queries for which computing minimum source-side-effect delete-propagation is tractable."
    }, {
      "heading" : "1 PRELIMINARIES AND CAUSALITY DECISION PROBLEMS",
      "text" : "We consider relational database schemas of the form S = (U,P), where U is the possibly infinite database domain and P is a finite set of database predicates4 of fixed arities. A database instance D compatible with S can be seen as a finite set of ground atomic formulas (in databases aka. atoms or tuples), of the form P (c1, ..., cn), where P ∈ P has arity n, and the constants c1, . . . , cn ∈ U .\nA conjunctive query (CQ) is a formula Q(x̄) of the firstorder (FO) language L(S) associated to S of the form ∃ȳ(P1(s̄1) ∧ · · · ∧ Pm(s̄m)), where the Pi(s̄i) are atomic formulas, i.e. Pi ∈ P , and the s̄i are sequences of terms, i.e. variables or constants of U . The x̄ in Q(x̄) shows all the free variables in the formula, i.e. those not appearing in ȳ. A sequence c̄ of constants is an answer to query Q(x̄) if D |= Q[c̄], i.e. the query becomes true in D when the variables are replaced by the corresponding constants in c̄. We denote the set of all answers to an open conjunctive query Q(x̄) with Q(D).\nA conjunctive query is boolean (a BCQ), if x̄ is empty, i.e. the query is a sentence, in which case, it is true or false in D, denoted by D |= Q and D 6|= Q, respectively. When Q is a BCQ, or contains no free variables, Q(D) = {yes} if Q is true, and Q(D) = ∅, otherwise.\nA query Q is monotone if for every two instances D1 ⊆ D2, Q(D1) ⊆ Q(D2), i.e. the set of answers grows monotonically with the instance. For example, CQs and unions of CQ (UCQs) are monotone queries. Datalog queries (Ceri et al., 1989; Abiteboul et al., 1995), although not FO, are also monotone (cf. Section 1.1 for more details).\n4As opposed to built-in predicates (e.g. 6=) that we assume do not appear, unless explicitly stated otherwise."
    }, {
      "heading" : "1.1 CAUSALITY AND RESPONSIBILITY",
      "text" : "In the rest of this work, unless otherwise stated, we will assume that a database instance D is split in two disjoint sets, D = Dn ∪ Dx, where Dn and Dx denote the sets of endogenous and exogenous tuples, respectively; and Q is a monotone query.\nDefinition 1.1. A tuple τ ∈ Dn is a counterfactual cause for an answer ā to Q in D if D |= Q(ā) and D r {τ} 6|= Q(ā). A tuple τ ∈ Dn is an actual cause for ā if there exists Γ ⊆ Dn, called a contingency set, such that τ is a counterfactual cause for ā in D r Γ. Causes(D,Q(ā)) denotes the set of actual causes for ā. This set is non-empty on the assumption that Q(ā) is true in D. When the query Q is boolean, Causes(D,Q) contains the causes for the answer yes in D.\nThe definition of query-answer causality can be applied without any conceptual changes to Datalog queries. In the case of a Datalog, the query Q(x̄) is a whole program Π that accesses an underlying extensional database E that is not part of the query. Program Π contains a rule that defines a top answer-collecting predicate Ans(x̄). Now, ā is an answer to query Π on E when Π ∪ E |= Ans(ā). Here, entailment (|=) means that the RHS belongs to the minimal model of the LHS. A Datalog query is boolean if the top answer-predicate is propositional, say ans . In the case of Datalog, we sometimes use the notation Causes(E,Π(ā)) or Causes(E,Π), depending on whether Π has a Ans(x̄) or ans as answer predicate, resp.\nGiven a τ ∈ Causes(D,Q(ā)), we collect all subsetminimal contingency sets associated with τ :\nCont(D,Q(ā), τ ) := {Λ ⊆ Dn | D r Λ |= Q(ā), D r (Λ ∪ {τ}) 6|= Q(ā), and\n∀Λ′ $ Λ, D r (Λ′ ∪ {τ}) |= Q(ā)}.\nThe responsibility of actual cause τ for answer ā, denoted ρ Q(ā)\n(τ), is 1(|Γ|+1) , where |Γ| is the size of the smallest contingency set for τ . Responsibility can be extend to all tuples in Dn by setting their value to 0, and they are not actual causes for Q.\nExample 1.1. Consider a database D with relations Author(Name,Journal) and Journal(JName,Topic,#Paper), and contents as below:\nAuthor Name JName Joe TKDE\nJohn TKDE Tom TKDE John TODS\nJournal JName Topic #Paper TKDE XML 30 TKDE CUBE 31 TODS XML 32\nConsider the conjunctive query:\nQ(Name, Topic) :∃Journal JName #Paper(Author(Name,JName)\n∧ Journal(JName,Topic,#Paper), (1)\nwhich has the following answers: Q(D) Name Topic Joe XML Joe CUBE Tom XML Tom CUBE John XML John CUBE3\nAssume 〈John, XML〉 is an unexpected answer to Q, and we want to compute its causes assuming that all tuples are endogenous.\nIt turns out that Author(John, TODS) is an actual cause, with contingency sets Γ1 = {Author(John, TKDE)} and Γ2={Journal(TKDE, XML, 32)}, because Author(John, TODS) is a counterfactual cause for answer 〈 John, XML〉 in both of D r Γ1 and D r Γ2. Therefore, the responsibility of Author(John, TODS) is 12 .\nLikewise, Journal(TKDE, XML, 32), Author(John, TKDE), Journal(TODS,XML, 32) are actual causes for 〈John, XML〉 with responsibility 12 .\nNow, under the assumption that the tuples in Journal are the endogenous tuples, the only actual causes for answer 〈John, XML〉 are Author(John, TKDE) and Author(John, TODS).\nA Datalog query Q(x̄) is a whole program Π consisting of positive rules that accesses an underlying extensional database E that is not part of the query. Program Π contains a rule that defines a top answer-collecting predicate Ans(x̄), by means of a rule of the form Ans(x̄) ← P1(s̄1), . . . , Pm(s̄m). Now, ā is an answer to query Π on E when Π ∪ E |= Ans(ā). Here, entailment (|=) means that the RHS belongs to the minimal model of the LHS. So, the extension Ans(D) of Ans in the minimal model of the program contains the answers to the query.\nA Datalog query is boolean if the top answer-predicate is propositional, say ans , i.e. defined by a rule of the form ans ← P1(s̄1), . . . , Pm(s̄m). In this case, the query is true if Π∪D |= ans , equivalently, if ans belongs to the minimal model of Π ∪E (Ceri et al., 1989; Abiteboul et al., 1995).\nCQs can be expressed as Datalog queries, e.g. (1) becomes:\nAnsQ(Name, Topic) ←− Author(Name,JName),\nJournal(JName,Topic,#Paper).\nThe definition of query-answer causality can be applied without any conceptual changes to Datalog queries. In the case of Datalog, we sometimes use the notation Causes(E,Π(ā)) or Causes(E,Π), depending on whether Π has a Ans(x̄) or ans as answer predicate, resp.\nIn (Meliou et al., 2010a), causality for non-query answers is defined on basis of sets of potentially missing tuples that account for the missing answer. Computing actual causes and their responsibilities for non-answers becomes a rather simple variation of causes for answers. In this work we focus on causality for query answers.\nThe complexity of the computational and decision problems that arise in query causality have been investigated in (Meliou et al., 2010a; Salimi & Bertossi, 2015). Here we\npresent some problems and results that we use throughout this paper. The first is the causality problem, about deciding whether a tuple is an actual cause for a query answer.\nDefinition 1.2. For a boolean monotone query Q, the causality decision problem (CDP) is (deciding about membership of):\nCDP(Q) := {(D, τ) | τ ∈ Dn, and τ ∈\nCauses(D,Q)}.\nThis problem is tractable for UCQs (Salimi & Bertossi, 2015). The next is the responsibility problem, about deciding responsibility (above a given bound) of a tuple for a query result.\nDefinition 1.3. For a boolean monotone query Q, the responsibility decision problem (RDP) is (deciding about membership of): RDP(Q) = {(D, τ, v) | τ ∈ Dn, v ∈ {0} ∪\n{ 1 k | k ∈ N+}, D |= Q and ρ Q (τ) > v}.\nThis problem is NP-complete for UCQs (Salimi & Bertossi, 2015), but tractable for linear CQs (Meliou et al., 2010a). Roughly speaking, a CQ is linear if its atoms can be ordered in a way that every variable appears in a continuous sequence of atoms that does not contain a self-join (i.e. a join involving the same predicate), e.g. ∃xvyu(A(x)∧S1(x, v)∧S2(v, y)∧R(y, u)∧S3(y, z)) is linear, but not ∃xyz(A(x)∧B(y)∧C(z)∧W (x, y, z)), for which RDP is NP-complete. The class of CQs for which RDP is tractable can be extended to weakly linear.5\nThe functional, non-decision version of RDP, about computing the responsibility, i.e. an optimization problem, is complete for FPNP(log(n)) for UCQs (Salimi & Bertossi, 2015).\nFinally, we have the problem of deciding weather a tuple is a most responsible cause:\nDefinition 1.4. For a boolean monotone query Q, the most responsible cause decision problem (MRDP) is: MRCD(Q) = {(D, τ) | τ ∈ Dn and\n0 < ρQ(τ) is a maximum for D}.\nFor UCQs this problem is complete for PNP(log(n)) (Salimi & Bertossi, 2015)."
    }, {
      "heading" : "1.2 VIEW-CONDITIONED CAUSALITY",
      "text" : "A form of conditional causality was informally introduced in (Meliou et al., 2010b), to characterize causes for a query answer that are conditioned by the other answers to the query. The notion was made precise in (Meliou et al., 2011), in a more general, non-relational setting that in particular includes the case of several queries. In them the notion of view-conditioned causality was used, and we adapt\n5Computing sizes of minimum contingency sets is reduced to the max-flow/min-cut problem in a network.\n4\nit in the following to the case of a single query, possibly with several answers.\nConsider an instance D = Dn ∪ Dx, and a monotone query Q with Q(D) = {ā1, . . . ān}. Fix an answer, say āk ∈ Q(D), while the other answers will be used as a condition on āk’s causality. Intuitively, āk is somehow unexpected, and we look for causes, by considering the other answers as “correct”. The latter assumption has, in technical terms, the effect of reducing the spectrum of contingency sets, by keeping Q(D)’s extension fixed, as a view, modulo the answer āk at hand. Definition 1.5. (a) A tuple τ ∈ Dn is called a viewconditioned counterfactual cause (VCC-cause) for answer āk to Q if D r {τ} 6|= Q(āk) and D r {τ} |= Q(āi), for i ∈ {1, . . . , n}r {k}.\n(b) A tuple τ ∈ Dn is an view-conditioned actual cause (VC-cause) for āk if there exists a contingency set, Γ ⊆ Dn, such τ is a VCC-cause for āk in D r Γ.\n(c) vc-Causes(D,Q(āk)) denotes the set of all VC causes for āk.\nIntuitively, a tuple τ is a VC-cause for āk if there is a contingent state of the database that entails all the answers to Q and τ is a counterfactual cause for āk, but not for the rest of the answers. Obviously, VC-causes for āk are also actual causes, but not necessarily the other way around: vc-Causes(D,Q(ak)) ⊆ Causes(D,Q(ak)).\nExample 1.2. (ex. 1.1 cont.) Consider the same instance D, query Q, and the answer 〈John, XML〉, which does not have any VC-cause. To see this, take for example, the tuple Author(John, TODS) that is an actual cause for 〈John, XML〉, with two contingency sets, Γ1 and Γ2. It is easy to verify that none of these contingency sets satisfies the condition in Definition 1.5, e.g. the original answer 〈John, CUBE〉 is not such anymore from D r Γ1. The same argument can be applied to all actual causes for 〈John, XML〉.\nThis example shows that it makes sense to study the complexity of deciding whether a query answer has a VC-actual cause or not.\nDefinition 1.6. For a monotone query Q, the viewconditioned cause problem is (deciding about membership of): VCP(Q) = {(D, ā) | ā ∈ Q(D) and\nvc-Causes(D,Q(ā)) 6= ∅ }."
    }, {
      "heading" : "2 CAUSALITY AND ABDUCTION",
      "text" : "In general logical terms, an abductive explanation of an observation is a formula that, together with the background logical theory, entails the observation. So, one could see an abductive explanation as a cause for the observation. However, it has been argued that causes and abductive explanations are not necessarily the same (Psillos, 1996; Denecker & Kakas, 2002).\nUnder the abductive approach to diagnosis (Console et al., 1991; Eiter & Gottlob, 1995; Poole, 1992, 1994), it is common that the system specification rather explicitly describes causality information, specially in action theories where the effects of actions are directly represented by Horn formulas. By restricting the explanation formulas to the predicates describing primitive causes (action executions), an explanation formula which entails an observation gives also a cause for the observation (Denecker & Kakas, 2002). In this case, and is some sense, causality information is imposed by the system specifier (Poole, 1992).\nIn database causality we do not have, at least not initially, a system description,6 but just a set of tuples. It is when we pose a query that we create something like a description, and the causal relationships between tuples are captured by the combination of atoms in the query. If the query is a Datalog query (in particular, a CQ), then we have a Horn specification too.\nIn this section we will establish connections between abductive diagnosis and database causality.7 For that, we have to be more precise about the kind of abduction problems we will consider."
    }, {
      "heading" : "2.1 BACKGROUND ON DATALOG ABDUCTIVE DIAGNOSIS",
      "text" : "A Datalog abduction problem (Eiter et al., 1997) is of the form AP = 〈Π, E,Hyp,Obs〉, where: (a) Π is a set of Datalog rules, (b) E is a set of ground atoms (the extensional database), whose predicates do not appear in heads of rules in Π, (c) Hyp, the hypothesis, is a finite set of ground atoms, the abducible atoms in this case,8 and (d) Obs , the observation, is a finite conjunction of ground atoms. As it is common, we will start with the assumption that Π ∪ E ∪ Hyp |= Obs.\nThe abduction problem is about computing a minimal ∆ ⊆ Hyp (under certain minimality criterion), such that Π∪E∪ ∆ |= Obs . More specifically:\nDefinition 2.1. Consider a Datalog abduction problem AP = 〈Π, E,Hyp,Obs〉\n(a) An abductive diagnosis (or simply, a solution) for AP is a subset-minimal ∆ ⊆ Hyp, such that Π∪E ∪∆ |= Obs . This requires that no proper subset of ∆ has this\n6Having integrity constraints would go in that direction, but we are not considering their presence in this work. However, see (Salimi & Bertossi, 2015, sec. 5) for a consistency-based diagnosis connection.\n7In (Salimi & Bertossi, 2015) we established such a connection between another form of model-based diagnosis (Struss, 2008), namely consistency-based diagnosis (Reiter, 1987). For relationships and comparisons between consistency-based and abductive diagnosis see (Console et al., 1991).\n8It is common to accept as hypothesis all the possible ground instantiations of abducible predicates. We assume abducible predicates do not appear in rule heads.\n5\nproperty. Sol(AP) denotes the set of abductive diagnoses for problem AP .\n(b) A hypothesis h ∈ Hyp is relevant for AP if h contained in at least one diagnosis of AP . Rel(AP) collects all relevant hypothesis for AP .\nWe are interested in deciding, for a fixed Datalog program, if an hypothesis is relevant or not, with all the data as input.\nMore precisely, we consider the following decision problem.\nDefinition 2.2. Given a Datalog program Π, the relevance decision problem (RLDP) for Π is (deciding about the membership of): RLDP(Π) = {(E ,Hyp,Obs , h) | h ∈ Rel(AP), with\nAP = 〈Π, E,Hyp,Obs〉 and h ∈ Hyp}.\nAs it is common, we will assume that |Obs |, i.e. the number of atoms in the conjunction, is bounded above by a numerical parameter p. It is common that p = 1 (a single atomic observation).\nDefinition 2.2 suggests that we are interested in the data complexity of the relevance problem for Datalog abduction. That is, the Datalog program is fixed and hypotheses and input structure may change and maybe regarded as data. In contrast, under combined complexity the program is also part of the input, and the complexity is measured also in terms of the program size.\nThe following result is obtained by showing that the NPcomplete combined complexity of the relevance problem for Propositional Datalog Abduction (PDA) (established in (Friedrich et al., 1990)), coincides with the data complexity of the relevance problem for (non-propositional) Datalog Abduction. For this, techniques developed in (Eiter et al., 1997) can be used.\nProposition 2.1. For every Datalog program Π, RLDP(Π) ∈ NP , and there are programs Π′ for which RLDP(Π′) is NP-hard.\nIt is clear from this result that the combined complexity of deciding relevance for Datalog abduction is also intractable. However, a tractable case of combined complexity is identified in (Gottlob et al., 2010b), on the basis of the notions of tree-decomposition and bounded tree-width, which we now briefly present.\nLet H = 〈V,H〉 be a hypergraph. V is the set of vertices, and H the set of hyperedges, i.e. of subsets of V . A treedecomposition T of H is a pair (T , λ), where T = 〈N,E〉 is a tree and λ is a labeling function that assigns to each node n ∈ N , a subset λ(n) of V (λ(n) is aka. bag), i.e. λ(n) ⊆ V , such that, for every node n ∈ N , the following hold: (a) For every v ∈ V , there exists n ∈ N with v ∈ λ(n). (b) For every h ∈ H , there exists a node n ∈ N\nwith h ⊆ λ(n). (c) For every v ∈ V , the set of nodes {n | v ∈ λ(n)} induces a connected subtree of T .\nThe width of a tree decomposition (T , λ) of H = 〈V,H〉, with T = 〈N,E〉, is defined as max{|λ(n)|−1 : n ∈ N}. The tree-width tw(H) of H is the minimum width over all its tree decompositions.\nIntuitively, the tree-width of a hypergraph H is a measure of the “tree-likeness” of H. A set of vertices that form a cycle in H are put into a same bag, which becomes (the bag of a) node in the corresponding treedecomposition. If the tree-width of the hypergraph under consideration is bounded by a fixed constant, then many otherwise intractable problems become tractable (Gottlob et al., 2010a).\nIt is possible to associate an hypergraph to any finite structure D (think of a relational database): If its universe (the active domain in the case of a relational database) is V , define the hypergraph H(D) = (V,H), with H = { {a1, . . . , an} | D contains a ground atom P (a1 . . . an) for some predicate symbol P}.\nExample 2.1. Consider instance D in Example 1.1. The hypergraph H(D) associated to D is shown in Figure 1(a). Its vertices are the elements of adom(D) = {John, Jone,Tom,TODS ,TKDE ,XML,Cube, 30 , 31 , 32}, the active domain of D. For example, since Journal(TKDE ,XML, 30 ) ∈ D, {TKDE ,XML, 30} is one of the hyperedges.\nThe dashed ovals show four sets of vertices, i.e. hyperedges, that together form a cycle. Their elements are put into the same bag of the tree-decomposition. Figure 1(b) shows a possible tree-decomposition of H(D). In it, the maximum |λ(n)|− 1 is 6− 1, corresponding to the top box bag of the tree. So, tw(H(D)) ≤ 5.\nThe following is a fixed-parameter tractability result for the relevance decision problem for Datalog abduction problems with a program Π that is guarded, which means that in every rule body there is an atom that contains (guards) all the variables appearing in that body.\nTheorem 2.2. (Gottlob et al., 2010b) Let k be an integer. For Datalog abduction problems AP = 〈Π, E,Hyp,Obs〉 where Π is guarded, and tw(H(E)) ≤ k, rele-6\nvance can be decided in polynomial time in |AP|.9 More precisely, the decision problem: RLDP = {(〈Π,E ,Hyp,Obs〉, h) | h ∈ Rel(〈Π,E ,Hyp,Obs〉), h ∈ Hyp,Π is guarded, and tw(H(E)) ≤ k} is tractable.\nThis is a case of tractable combined complexity with a fixed parameter that is the tree-width of the extensional database."
    }, {
      "heading" : "2.2 QUERY CAUSALITY FROM ABDUCTIVE DIAGNOSIS",
      "text" : "In this section we first show that, for the class of Datalog theories (system specifications), abductive inference corresponds to actual causation for monotone queries. That is, abductive diagnoses for an observation essentially contain actual causes for the observation.\nAssume that Π is a boolean, possibly recursive Datalog query. Consider the relational instance D = Dx ∪ Dn. Also assume that Π ∪D |= ans . So, the decision problem in Definition 1.2 takes the form CDP(Π) := {(D, τ) | τ ∈ Dn, and τ ∈ Causes(D,Π)}.\nWe now show that actual causes for ans can be obtained from abductive diagnoses of the associated causal Datalog abduction problem (CDAP): APc := 〈Π, Dx, Dn, ans〉, where Dx is the extensional database for Π (and then Π ∪ Dx becomes the background theory), Dn becomes the set of hypothesis, and atom ans is the observation.\nProposition 2.3. t ∈ Dn is an actual cause for ans iff t ∈ Rel(APc).\nExample 2.2. Consider the instance D with relations R and S as below, and the query Π : ans ← R(x, y), S(y), which is true in D. Assume all tuples are endogenous.\nR X Y a1 a4 a2 a1 a3 a3\nS X a1 a2 a3\nAPc = 〈Π, ∅, D, ans〉 has two (subset-minimal) abductive diagnoses: ∆1 = {S(a1), R(a2, a1)} and ∆2 = {S(a3), R(a3, a3)}. Then, Rel(AP\nc) = {S(a3), R(a3, a3), S(a1), R(a2, a1)}. It is easy to see that the relevant hypothesis are actual causes for ans .\nWe are interested in obtaining responsibilities of actual causes for ans .\nDefinition 2.3. Given a CDAP, APc = 〈Π, Dx, Dn, ans〉, with Sol(APc) 6= ∅, N ⊆ Dn is a necessary-hypothesis set if N is subset-minimal such that Sol(APcN ) = ∅, with APcN := 〈Π, D x, Dn rN, ans〉. Proposition 2.4. The responsibility of a tuple t for ans is 1 |N | , where N is a necessary-hypothesis set with minimum cardinality for APc and t ∈ N .\n9This is Theorem 7.9 in (Gottlob et al., 2010b).\nIn order to represent Datalog abduction in terms of queryanswer causality, we show that abductive diagnoses from Datalog programs are formed essentially by actual causes for the observation.\nMore precisely, consider a Datalog abduction problem AP = 〈Π, E,Hyp,Obs〉, whereE is the underlying extensional database, and Obs is a conjunction of ground atoms.\nNow we construct a query-causality setting: D := Dx ∪ Dn, Dx := E, and Dn := Hyp. Consider the program Π′ := Π ∪ {ans ← Obs} (with ans a fresh propositional atom). So, Π′ is seen as a monotone query on D.\nProposition 2.5. A hypothesis h is relevant for AP , i.e. h ∈ Rel(AP), iff h is an actual cause for ans wrt. Π′, D.\nNow we will use the results obtained so far in this section to obtain new complexity results for Datalog query causality. Actually, the following result is obtained from Propositions 2.1 and 2.3:\nProposition 2.6. For boolean Datalog queries Π, CDP(Π) is NP-complete (in data).\nThis result should be contrasted with the tractability of same problem for UCQs (Salimi & Bertossi, 2015).\nWe now introduce a fixed-parameter tractable case of this problem. For this we take advantage of the tractable case of Datalog abduction presented in Section 2.1. The following is a consequence of Theorem 2.2 and Proposition 2.3.\nProposition 2.7. For guarded Datalog queries Π and a extensional instances D = Dx ∪ Dn, with Dx of bounded tree-width, CDP is fixed-parameter tractable in combined complexity, with the parameter being the tree-width bound."
    }, {
      "heading" : "3 VIEW-UPDATES AND QUERY CAUSALITY",
      "text" : "There is a close relationship between query causality and the view-update problem in the form of deletepropagation, which was first suggested in (Kimelfeld, 2012; Kimelfeld et al., 2012) (see also (Buneman et al., 2002)). We start by formalizing some specific computational problems related to the general delete-propagation problem."
    }, {
      "heading" : "3.1 DELETE-PROPAGATION PROBLEMS",
      "text" : "Given a monotone query Q, we can think of it as defining a view with virtual contents Q(D). If ā ∈ Q(D), which may not be intended, we may try to delete some tuples from D, so that ā disappears from Q(D). This is a common case of the problem of database updates through views (Abiteboul et al., 1995). In this work we consider some variations of this problem, in both their functional and the decision versions.\n7\nDefinition 3.1. For an instance D, and a monotone query Q:\n(a) For ā ∈ Q(D), the minimal source-side-effect problem is about computing a subset-minimal Λ ⊆ D, such that ā /∈ Q(D r Λ).\n(b) The minimal source-side-effect decision problem is (deciding about the membership of):\nMSSEPs(Q) = {(D,D′, ā) | ā ∈ Q(D), D′ ⊆ D, ā 6∈ Q(D′), and D′ is subset-maximal}.\n(The superscript s stands for subset-minimal.)\n(c) For ā ∈ Q(D), the minimum source side-effect problem is about computing a minimum-cardinality Λ ⊆ D, such that ā /∈ Q(D r Λ).\n(d) The minimum source side-effect decision problem is (deciding about the membership of):\nMSSEPc(Q) = {(D,D′, ā) | ā ∈ Q(D), D′ ⊆ D, ā /∈ Q(D′), and D′ has maximum cardinality}.\n(Here c stands for minimum cardinality.)\nDefinition 3.2. (Buneman et al., 2002) For an instance D, and a monotone query Q:\n(a) For ā ∈ Q(D), the view side-effect-free problem is about computing a Λ ⊆ D, such that Q(D) r {ā} = Q(D r Λ). (b) The view side-effect-free decision problem is (deciding about the membership of):\nVSEFP(Q) = {(D, ā) | ā ∈ Q(D), and exists D′ ⊆ D with Q(D)r {ā} = Q(D′)}."
    }, {
      "heading" : "3.2 VIEW DELETIONS VS. CAUSES",
      "text" : "In this section we first establish mutual reductions between the different variants of the delete propagation problem and both query and view-conditioned causality. On this basis, we obtain next some complexity results for viewconditioned causality and the minimum source-side-effect problem.\nIn this section all tuples in the instances involved are assumed to be endogenous. Consider a relational database D, a view V defined by a monotone query Q. So, the virtual view extension, V(D), is Q(D).\nFor a tuple ā ∈ V(D), the delete-propagation problem, in its most general form, is the task of deleting a set of tuples from D, and so obtaining a subinstance D′ of D, such that ā /∈ V(D′). It is natural to expect that the deletion of ā from the view can be achieved through deletions from D of the causes for ā to be in the view extension. However, to obtain solutions to the different variants of this problem introduced in Section 3.1, different sets of actual causes must be considered.\nFirst, we show that an actual cause for ā to be in V(D) forms, with any of its contingency sets, a solution to the minimal source-side-effect problem (cf. Definition 3.1).\nProposition 3.1. Consider an instance D, a view V defined by a monotone query Q, and ā ∈ V(D): D′ ⊆ D is a solution to the minimal source-side-effect problem, i.e. (D,D′, ā) ∈ MSSEPs(Q), iff there is a t ∈ D r D′, such that t ∈ Causes(D,Q(ā)) and D r (D′ ∪ {t}) ∈ Cont(D,Q(ā), t).\nNow we show that, in order to minimize the side-effect on the source (cf. Definition 3.1(c)), it is good enough to pick a most responsible cause for ā with any of its minimumcardinality contingency sets.\nProposition 3.2. Consider an instance D, a view V defined by a monotone query Q, and ā ∈ V(D): D′ ⊆ D is a solution to the minimum source-side-effect problem, i.e. (D,D′, ā) ∈ MSSEPc(Q), iff there is a t ∈ D r D′, such that t ∈ MRC(D,Q(ā)), Λ := D r (D′ ∪ {t}) ∈ Cont(D,Q(ā), t), and there is no Λ′ ∈ Cont(D,Q(ā), t) with |Λ′| < |Λ|.\nNext, we show that in order to check if there exists a solution to the view side-effect-free problem for ā ∈ V(D) (cf. Definition 3.2), it is good enough to check if ā has a view-conditioned cause.10\nProposition 3.3. Consider an instance D, a view V defined by a monotone queryQ, and ā ∈ V(D): There is a solution to the view side-effect-free problem for ā, i.e. (D, ā) ∈ VSEFP(Q), iff vc-Causes(D,Q(ā)) 6= ∅.\nExample 3.1. (ex. 1.1 cont.) Consider the same instance D, query Q, and answer 〈 John, XML〉.\nConsider the following sets of tuples:\nS1={ Author(John, TKDE), Journal(TODS, XML, 32)},\nS2={ Author(John, TODS), Journal(TKDE, XML, 30)},\nS3={ Journal(TODS, XML, 30), Journal(TKDE, XML, 30)},\nS4={ Author(John, TODS), Author(John, TKDE)}.\nEach of the subinstances D r Si, i = 1, . . . , 4, is a solution to both the minimum and minimal source-side-effect problems. These solutions essentially contain the actual causes for answer 〈 John, XML〉, as computed in Example 1.1. Moreover, there is no solution to the view sideeffect-free problem associated to this answer, which coincides with the result obtained in Example 1.2, and confirms Proposition 3.3.\nNow we show, the other way around, that actual causes, most responsible causes, and VC causes can be obtained from solutions to different variants of the deletepropagation problem.\nFirst, we show that actual causes for a query answer can be obtained from the solutions to the corresponding minimal source-side-effect problem.\n10Since this proposition does not involve contingency sets, the existential problem in Definition 3.2(b) is the right one to consider.\n8\nProposition 3.4. Consider an instance D, a view V defined by a monotone query Q, and ā ∈ V(D): Tuple t is an actual cause for ā iff there is a D′ ⊆ D with t ∈ (D r D′) ⊆ Dn and (D,D′, ā) ∈ MSSEPs(Q).\nSimilarly, most-responsible causes for a query answer can be obtained from solutions to the corresponding minimum source-side-effect problem.\nProposition 3.5. Consider an instance D, a view V defined by a monotone query Q, and ā ∈ V(D): Tuple t is a most responsible actual cause for ā iff there is a D′ ⊆ D with t ∈ (D rD′) ⊆ Dn and (D,D′, ā) ∈ MSSEPc(Q).\nFinally, VC-causes for an answer can be obtained from solutions to the view side-effect-free problem.\nProposition 3.6. Consider an instance D, a view V defined by a monotone query Q, and ā ∈ V(D): Tuple t is a VCcause for ā iff there is a D′ ⊆ D with t ∈ (DrD′) ⊆ Dn and D′ is a solution to the view side-effect-free problem associated to ā.\nThe partition of a database into endogenous and exogenous tuples used in causality may also be of interest in the context of delete propagation. It makes sense to consider endogenous delete-propagation that are obtained through deletions on endogenous tuples only. Actually, given an instance D = Dn ∪ Dx, a view V defined by a monotone query Q, and ā ∈ V(D), endogenous delete-propagations for ā (in all of its flavors) can be obtained from actual causes for ā from the partitioned instance.\nExample 3.2. (ex. 3.1 cont.) Consider again that tuple 〈 John, XML〉 must be deleted from the query result; and assume now the data in Journal is reliable. Therefore, only deletions from Author make sense. This can be captured by considering Journal-tuples as exogenous and Author-tuples as endogenous. With this partitioning, only Author(John, TODS) and Author(John, TKDE) are actual causes for 〈 John, XML〉, and each of them forms a singleton and unique contingency set of the other as a cause (See Exampleex:cfex1). Therefore, D r {Author(John, TODS), Author(John, TKDE)} is a solution to the associated minimal- and minimum endogenous deletepropagation of 〈 John, XML〉.\nWe now investigate the complexity of the view-conditioned causality problem (cf. Definition 1.6). For this, we take advantage of the connection between VC-causality and the view side-effect-free problem. Actually, the following result is obtained from the NP-completeness of view sideeffect-free problem (Buneman et al., 2002) and Proposition 3.3.\nProposition 3.7. For CQs, the view-conditioned causality decision problem, VCP , is NP-complete.\nActually, this result also holds for UCQs. The next result is obtained from the FPNP(log(n))-completeness of computing the responsibility of the most responsible causes (obtained in (Salimi & Bertossi, 2015)) and Proposition 3.2.\nProposition 3.8. Computing the size of a solution to the minimum source-side-effect problem is FPNP(log(n))hard.\nAs mentioned in Section 1.1, responsibility computation (more precisely the RDP problem in Definition 1.3) is tractable for weakly linear queries. We can take advantage of this result and obtain, via Proposition 3.2, a new tractability result for the minimum source-side-effect problem, which has been shown to be NP-hard for general CQs in (Buneman et al., 2002).\nProposition 3.9. For weakly linear queries, the minimum source-side-effect decision problem is tractable.\nThe class of weakly linear queries generalizes that of linear queries (cf. Section 1.1). So, Proposition 3.9 also holds for linear queries.\nIn (Buneman et al., 2002) it has been shown that the minimum source-side-effect decision problem is tractable for the class of project-join queries with chain joins. Now, a join on k atoms with different predicates, say R1, ..., Rk, is a chain join if there are no attributes (variables) shared by any two atoms Ri and Rj with j > i + 1. That is, only consecutive relations may share attributes. For example, ∃xvyu(A(x)∧S1(x, v)∧S2(v, y)∧R(y, u)∧S3(y, z)) is a project-join query with chain joins.\nWe observe that project-join queries with chain joins correspond linear queries. Actually, the tractability results for these classes of queries are both obtained via a reduction to maximum flow problem (Meliou et al., 2010a; Buneman et al., 2002). As a consequence, the result in Proposition 3.9 extends that in (Buneman et al., 2002), from linear queries to weakly-linear queries. For example, ∃xyz(R(x, y)∧S(y, z)∧T (z, x)∧V (x)) is not linear (then, nor with chain joins), but it is weakly linear (Meliou et al., 2010a)."
    }, {
      "heading" : "4 CONCLUSIONS",
      "text" : "We have related query causality to abductive diagnosis and the view-update problem. Some connections between the last two have been established before. More precisely, the view-update problem has been treated from the point of view of abductive reasoning (Kakas & Mancarella, 1990; Console et al., 1995). The idea is to “abduce” the presence of tuples in the base tables that explain the presence of those tuples in the view extension that one would like, e.g. to get rid of.\nIn combination with the results reported in (Salimi & Bertossi, 2015), we can see that there are deeper and multiple connections between the areas of query causality, abductive and consistency-based diagnosis, view updates, and database repairs. Results for any of these areas can be profitably applied to the others.11\n11Connections between consistency-based and abductive diag9\nWe point out that database repairs are related to the viewupdate problem. Actually, answer set programs (ASPs) (Brewka et al., 2011) for database repairs (Bertossi, 2011) implicity repair the database by updating conjunctive combinations of intentional, annotated predicates. Those logical combinations -views after all- capture violations of integrity constraints in the original database or along the (implicitly iterative) repair process (a reason for the use of annotations).\nEven more, in (Bertossi & Li, 2013), in order to protect sensitive information, databases are explicitly and virtually “repaired” through secrecy views that specify the information that has to be kept secret. In order to protect information, a user is allowed to interact only with the virtually repaired versions of the original database that result from making those views empty or contain only null values. Repairs are specified and computed using ASP, and an explicit connection to prioritized attribute-based repairs (Bertossi, 2011) is made (Bertossi & Li, 2013).\nFinally, we should note that abduction has also been explicitly applied to database repairs (Arieli et al., 2004). The idea, again, is to “abduce” possible repair updates that bring the database to a consistent state.\nAcknowledgments: Research funded by NSERC Discovery, and the NSERC Strategic Network on Business Intelligence (BIN)."
    } ],
    "references" : [ {
      "title" : "Coherent Integration of Databases by Abductive Logic Programming",
      "author" : [ "O. Arieli", "M. Denecker", "B. Van Nuffelen", "M. Bruynooghe" ],
      "venue" : "J. Artif. Intell. Res.,",
      "citeRegEx" : "Arieli et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Arieli et al\\.",
      "year" : 2004
    }, {
      "title" : "Achieving Data Privacy through Secrecy Views and Null-Based Virtual Updates",
      "author" : [ "L. Bertossi", "L. Li" ],
      "venue" : "IEEE Transaction on Knowledge and Data Engineering,",
      "citeRegEx" : "Bertossi and Li,? \\Q2013\\E",
      "shortCiteRegEx" : "Bertossi and Li",
      "year" : 2013
    }, {
      "title" : "Database Repairing and Consistent Query Answering",
      "author" : [ "L. Bertossi" ],
      "venue" : "Morgan & Claypool, Synthesis Lectures on Data Management,",
      "citeRegEx" : "Bertossi,? \\Q2011\\E",
      "shortCiteRegEx" : "Bertossi",
      "year" : 2011
    }, {
      "title" : "Unifying Causality, Diagnosis, Repairs and View-Updates in Databases",
      "author" : [ "L. Bertossi", "B. Salimi" ],
      "venue" : "First International PODS-Workshop on Big Uncertain Data (BUDA",
      "citeRegEx" : "Bertossi and Salimi,? \\Q2014\\E",
      "shortCiteRegEx" : "Bertossi and Salimi",
      "year" : 2014
    }, {
      "title" : "Answer Set Programming at a Glance",
      "author" : [ "G. Brewka", "Eiter", "Th", "M. Truszczynski" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "Brewka et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Brewka et al\\.",
      "year" : 2011
    }, {
      "title" : "On Propagation of Deletions and Annotations Through Views",
      "author" : [ "P. Buneman", "S. Khanna", "W.C. Tan" ],
      "venue" : "Proc. PODS,",
      "citeRegEx" : "Buneman et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Buneman et al\\.",
      "year" : 2002
    }, {
      "title" : "Responsibility and Blame: A Structural-Model Approach",
      "author" : [ "H. Chockler", "J.Y. Halpern" ],
      "venue" : "J. Artif. Intell. Res.,",
      "citeRegEx" : "Chockler and Halpern,? \\Q2004\\E",
      "shortCiteRegEx" : "Chockler and Halpern",
      "year" : 2004
    }, {
      "title" : "A Spectrum of Logical Definitions of Model-Based Diagnosis",
      "author" : [ "L. Console", "P. Torasso" ],
      "venue" : "Comput. Intell.,",
      "citeRegEx" : "Console et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Console et al\\.",
      "year" : 1991
    }, {
      "title" : "On the Relationship between Abduction and Deduction",
      "author" : [ "L. Console", "D. Theseider-Dupre", "P. Torasso" ],
      "venue" : "J. Log. Comput.,",
      "citeRegEx" : "Console et al\\.,? \\Q1991\\E",
      "shortCiteRegEx" : "Console et al\\.",
      "year" : 1991
    }, {
      "title" : "The Role of Abduction in Database View Updating",
      "author" : [ "L. Console", "Sapino M. L", "D. Theseider-Dupre" ],
      "venue" : "J. Intell. Inf. Syst.,",
      "citeRegEx" : "Console et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Console et al\\.",
      "year" : 1995
    }, {
      "title" : "Abduction in Logic Programming",
      "author" : [ "M. Denecker", "Kakas A. C" ],
      "venue" : "In Computational Logic: Logic Programming and Beyond,",
      "citeRegEx" : "Denecker and C.,? \\Q2002\\E",
      "shortCiteRegEx" : "Denecker and C.",
      "year" : 2002
    }, {
      "title" : "The Complexity of Logic-Based Abduction",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "J. ACM ,",
      "citeRegEx" : "Eiter and Gottlob,? \\Q1995\\E",
      "shortCiteRegEx" : "Eiter and Gottlob",
      "year" : 1995
    }, {
      "title" : "Abduction from Logic Programs: Semantics and Complexity",
      "author" : [ "T. Eiter", "G. Gottlob", "N. Leone" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "Eiter et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 1997
    }, {
      "title" : "Hypothesis Classification, Abductive Diagnosis and Therapy",
      "author" : [ "G. Friedrich", "Gottlob. G", "W. Nejdl" ],
      "venue" : "Proc. Internat. Workshop on Expert Systems in Engineering,",
      "citeRegEx" : "Friedrich et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Friedrich et al\\.",
      "year" : 1990
    }, {
      "title" : "Bounded Treewidth as a Key to Tractability of Knowledge Representation And Reasoning",
      "author" : [ "G. Gottlob", "R. Pichler", "F. Wei" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Gottlob et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Gottlob et al\\.",
      "year" : 2010
    }, {
      "title" : "Tractable Database Design and Datalog Abduction through Bounded Treewidth",
      "author" : [ "G. Gottlob", "R. Pichler", "F. Wei" ],
      "venue" : "Inf. Syst.,",
      "citeRegEx" : "Gottlob et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Gottlob et al\\.",
      "year" : 2010
    }, {
      "title" : "Causes and Explanations: A StructuralModel Approach: Part 1",
      "author" : [ "J. Halpern", "J. Pearl" ],
      "venue" : "Proc. UAI,",
      "citeRegEx" : "Halpern and Pearl,? \\Q2001\\E",
      "shortCiteRegEx" : "Halpern and Pearl",
      "year" : 2001
    }, {
      "title" : "Causes and Explanations: A StructuralModel Approach: Part 1",
      "author" : [ "Y.J. Halpern", "J. Pearl" ],
      "venue" : "British J. Philosophy of Science,",
      "citeRegEx" : "Halpern and Pearl,? \\Q2005\\E",
      "shortCiteRegEx" : "Halpern and Pearl",
      "year" : 2005
    }, {
      "title" : "A Modification of Halpern-Pearl Definition of Causality",
      "author" : [ "J. Halpern" ],
      "venue" : "To appear in Proc. IJCAI,",
      "citeRegEx" : "Halpern,? \\Q2015\\E",
      "shortCiteRegEx" : "Halpern",
      "year" : 2015
    }, {
      "title" : "Appropriate Causal Models and Stability of Causation",
      "author" : [ "J. Halpern" ],
      "venue" : "Proc. KR,",
      "citeRegEx" : "Halpern,? \\Q2014\\E",
      "shortCiteRegEx" : "Halpern",
      "year" : 2014
    }, {
      "title" : "Database Updates through Abduction",
      "author" : [ "Kakas A. C", "P. Mancarella" ],
      "venue" : "Proc. VLDB,",
      "citeRegEx" : "C. and Mancarella,? \\Q1990\\E",
      "shortCiteRegEx" : "C. and Mancarella",
      "year" : 1990
    }, {
      "title" : "A Dichotomy in the Complexity of Deletion Propagation with Functional Dependencies",
      "author" : [ "B. Kimelfeld" ],
      "venue" : "Proc. PODS,",
      "citeRegEx" : "Kimelfeld,? \\Q2012\\E",
      "shortCiteRegEx" : "Kimelfeld",
      "year" : 2012
    }, {
      "title" : "Maximizing Conjunctive Views in Deletion Propagation",
      "author" : [ "B. Kimelfeld", "J. Vondrak", "R. Williams" ],
      "venue" : "ACM TODS,",
      "citeRegEx" : "Kimelfeld et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Kimelfeld et al\\.",
      "year" : 2012
    }, {
      "title" : "The Complexity of Causality and Responsibility for Query Answers and Non-Answers",
      "author" : [ "A. Meliou", "Gatterbauer", "K.F.W. Moore", "D. Suciu" ],
      "venue" : "Proc. VLDB,",
      "citeRegEx" : "Meliou et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Meliou et al\\.",
      "year" : 2010
    }, {
      "title" : "Causality in Databases",
      "author" : [ "A. Meliou", "Gatterbauer. W", "J.Y. Halpern", "C. Koch", "Moore K. F", "D. Suciu" ],
      "venue" : "IEEE Data Eng. Bull,",
      "citeRegEx" : "Meliou et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Meliou et al\\.",
      "year" : 2010
    }, {
      "title" : "Tracing Data Errors with View-Conditioned Causality",
      "author" : [ "A. Meliou", "Gatterbauer", "S. Nath", "D. Suciu" ],
      "venue" : "Proc. SIGMOD,",
      "citeRegEx" : "Meliou et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Meliou et al\\.",
      "year" : 2011
    }, {
      "title" : "Ampliative Reasoning: Induction or Abduction",
      "author" : [ "A. Psillos" ],
      "venue" : "Proc. ECAI’96 Workshop on Abductive and Inductive Reasoning,",
      "citeRegEx" : "Psillos.,? \\Q1996\\E",
      "shortCiteRegEx" : "Psillos.",
      "year" : 1996
    }, {
      "title" : "Logic Programming, Abduction and Probability",
      "author" : [ "D. Poole" ],
      "venue" : "Proc. FGCS,",
      "citeRegEx" : "Poole,? \\Q1992\\E",
      "shortCiteRegEx" : "Poole",
      "year" : 1992
    }, {
      "title" : "Representing Diagnosis Knowledge",
      "author" : [ "D. Poole" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Poole,? \\Q1994\\E",
      "shortCiteRegEx" : "Poole",
      "year" : 1994
    }, {
      "title" : "A Theory of Diagnosis from First Principles",
      "author" : [ "R. Reiter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Reiter,? \\Q1987\\E",
      "shortCiteRegEx" : "Reiter",
      "year" : 1987
    }, {
      "title" : "Causality in Databases: The Diagnosis and Repair Connections",
      "author" : [ "B. Salimi", "L. Bertossi" ],
      "venue" : "Proc. 15th International Workshop on Non-Monotonic Reasoning (NMR",
      "citeRegEx" : "Salimi and Bertossi,? \\Q2014\\E",
      "shortCiteRegEx" : "Salimi and Bertossi",
      "year" : 2014
    }, {
      "title" : "From Causes for Database Queries to Repairs and Model-Based Diagnosis and Back",
      "author" : [ "B. Salimi", "L. Bertossi" ],
      "venue" : "Proc. ICDT,",
      "citeRegEx" : "Salimi and Bertossi,? \\Q2015\\E",
      "shortCiteRegEx" : "Salimi and Bertossi",
      "year" : 2015
    }, {
      "title" : "Model-based Problem Solving",
      "author" : [ "P. Struss" ],
      "venue" : "In Handbook of Knowledge Representation, chap. 10. Elsevier,",
      "citeRegEx" : "Struss,? \\Q2008\\E",
      "shortCiteRegEx" : "Struss",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : ", 2010a,b, 2011), can be traced back to (Halpern & Pearl, 2001, 2005), which provides a model-based account of causation on the basis of counterfactual dependence.2 Causal responsibility was introduced in Chockler & Halpern (2004), to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.",
      "startOffset" : 41,
      "endOffset" : 231
    }, {
      "referenceID" : 29,
      "context" : "Since this and causality are related to explanations, a first connection between causality and consistency-based diagnosis (Reiter, 1987), a form of model-based diagnosis, was established in (Salimi & Bertossi, 2014, 2015): Causality and the responsibility problem can be formulated as consistency-based diagnosis problems, which allowed to extend the results in (Meliou et al.",
      "startOffset" : 123,
      "endOffset" : 137
    }, {
      "referenceID" : 7,
      "context" : "However, no precise connection has been established so far between causality and abductive diagnosis (Console et al., 1991; Eiter & Gottlob, 1995), another form of model-based diagnosis.",
      "startOffset" : 101,
      "endOffset" : 146
    }, {
      "referenceID" : 2,
      "context" : "In (Salimi & Bertossi, 2015) connections were established between query causality, database repairs (Bertossi, 2011), and consistency-based diagnosis.",
      "startOffset" : 100,
      "endOffset" : 116
    }, {
      "referenceID" : 12,
      "context" : "As opposed to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly performed under a logic programming (LP) approach (in the general sense of LP) to knowledge representation (Denecker & Kakas, 2002; Eiter et al., 1997; Gottlob et al., 2010b).",
      "startOffset" : 233,
      "endOffset" : 300
    }, {
      "referenceID" : 9,
      "context" : "Abductive reasoning/diagnosis has been applied to the view update problem in databases (Kakas & Mancarella, 1990; Console et al., 1995), which is about characterizing and computing updates of physical database relations that give an account of (or have as result) the intended updates on views.",
      "startOffset" : 87,
      "endOffset" : 135
    }, {
      "referenceID" : 5,
      "context" : "The delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views.",
      "startOffset" : 31,
      "endOffset" : 94
    }, {
      "referenceID" : 21,
      "context" : "The delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views.",
      "startOffset" : 31,
      "endOffset" : 94
    }, {
      "referenceID" : 22,
      "context" : "The delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views.",
      "startOffset" : 31,
      "endOffset" : 94
    }, {
      "referenceID" : 5,
      "context" : "It is also possible to consider minimizing the side-effect on the view, which also requires that other tuples in the (virtual) view contents are not affected (deleted) (Buneman et al., 2002).",
      "startOffset" : 168,
      "endOffset" : 190
    }, {
      "referenceID" : 25,
      "context" : "The notion was made precise in (Meliou et al., 2011), in a more general, non-relational setting that in particular includes the case of several queries.",
      "startOffset" : 31,
      "endOffset" : 52
    }, {
      "referenceID" : 26,
      "context" : "However, it has been argued that causes and abductive explanations are not necessarily the same (Psillos, 1996; Denecker & Kakas, 2002).",
      "startOffset" : 96,
      "endOffset" : 135
    }, {
      "referenceID" : 7,
      "context" : "Under the abductive approach to diagnosis (Console et al., 1991; Eiter & Gottlob, 1995; Poole, 1992, 1994), it is common that the system specification rather explicitly describes causality information, specially in action theories where the effects of actions are directly represented by Horn formulas.",
      "startOffset" : 42,
      "endOffset" : 106
    }, {
      "referenceID" : 27,
      "context" : "In this case, and is some sense, causality information is imposed by the system specifier (Poole, 1992).",
      "startOffset" : 90,
      "endOffset" : 103
    }, {
      "referenceID" : 12,
      "context" : "A Datalog abduction problem (Eiter et al., 1997) is of the form AP = 〈Π, E,Hyp,Obs〉, where: (a) Π is a set of Datalog rules, (b) E is a set of ground atoms (the extensional database), whose predicates do not appear in heads of rules in Π, (c) Hyp, the hypothesis, is a finite set of ground atoms, the abducible atoms in this case,8 and (d) Obs , the observation, is a finite conjunction of ground atoms.",
      "startOffset" : 28,
      "endOffset" : 48
    }, {
      "referenceID" : 32,
      "context" : "In (Salimi & Bertossi, 2015) we established such a connection between another form of model-based diagnosis (Struss, 2008), namely consistency-based diagnosis (Reiter, 1987).",
      "startOffset" : 108,
      "endOffset" : 122
    }, {
      "referenceID" : 29,
      "context" : "In (Salimi & Bertossi, 2015) we established such a connection between another form of model-based diagnosis (Struss, 2008), namely consistency-based diagnosis (Reiter, 1987).",
      "startOffset" : 159,
      "endOffset" : 173
    }, {
      "referenceID" : 7,
      "context" : "For relationships and comparisons between consistency-based and abductive diagnosis see (Console et al., 1991).",
      "startOffset" : 88,
      "endOffset" : 110
    }, {
      "referenceID" : 13,
      "context" : "The following result is obtained by showing that the NPcomplete combined complexity of the relevance problem for Propositional Datalog Abduction (PDA) (established in (Friedrich et al., 1990)), coincides with the data complexity of the relevance problem for (non-propositional) Datalog Abduction.",
      "startOffset" : 167,
      "endOffset" : 191
    }, {
      "referenceID" : 12,
      "context" : "For this, techniques developed in (Eiter et al., 1997) can be used.",
      "startOffset" : 34,
      "endOffset" : 54
    }, {
      "referenceID" : 21,
      "context" : "There is a close relationship between query causality and the view-update problem in the form of deletepropagation, which was first suggested in (Kimelfeld, 2012; Kimelfeld et al., 2012) (see also (Buneman et al.",
      "startOffset" : 145,
      "endOffset" : 186
    }, {
      "referenceID" : 22,
      "context" : "There is a close relationship between query causality and the view-update problem in the form of deletepropagation, which was first suggested in (Kimelfeld, 2012; Kimelfeld et al., 2012) (see also (Buneman et al.",
      "startOffset" : 145,
      "endOffset" : 186
    }, {
      "referenceID" : 5,
      "context" : ", 2012) (see also (Buneman et al., 2002)).",
      "startOffset" : 18,
      "endOffset" : 40
    }, {
      "referenceID" : 5,
      "context" : "(Buneman et al., 2002) For an instance D, and a monotone query Q:",
      "startOffset" : 0,
      "endOffset" : 22
    }, {
      "referenceID" : 5,
      "context" : "Actually, the following result is obtained from the NP-completeness of view sideeffect-free problem (Buneman et al., 2002) and Proposition 3.",
      "startOffset" : 100,
      "endOffset" : 122
    }, {
      "referenceID" : 5,
      "context" : "2, a new tractability result for the minimum source-side-effect problem, which has been shown to be NP-hard for general CQs in (Buneman et al., 2002).",
      "startOffset" : 127,
      "endOffset" : 149
    }, {
      "referenceID" : 5,
      "context" : "In (Buneman et al., 2002) it has been shown that the minimum source-side-effect decision problem is tractable for the class of project-join queries with chain joins.",
      "startOffset" : 3,
      "endOffset" : 25
    }, {
      "referenceID" : 5,
      "context" : "Actually, the tractability results for these classes of queries are both obtained via a reduction to maximum flow problem (Meliou et al., 2010a; Buneman et al., 2002).",
      "startOffset" : 122,
      "endOffset" : 166
    }, {
      "referenceID" : 5,
      "context" : "9 extends that in (Buneman et al., 2002), from linear queries to weakly-linear queries.",
      "startOffset" : 18,
      "endOffset" : 40
    }, {
      "referenceID" : 9,
      "context" : "More precisely, the view-update problem has been treated from the point of view of abductive reasoning (Kakas & Mancarella, 1990; Console et al., 1995).",
      "startOffset" : 103,
      "endOffset" : 151
    }, {
      "referenceID" : 4,
      "context" : "Actually, answer set programs (ASPs) (Brewka et al., 2011) for database repairs (Bertossi, 2011) implicity repair the database by updating conjunctive combinations of intentional, annotated predicates.",
      "startOffset" : 37,
      "endOffset" : 58
    }, {
      "referenceID" : 2,
      "context" : ", 2011) for database repairs (Bertossi, 2011) implicity repair the database by updating conjunctive combinations of intentional, annotated predicates.",
      "startOffset" : 29,
      "endOffset" : 45
    }, {
      "referenceID" : 2,
      "context" : "Repairs are specified and computed using ASP, and an explicit connection to prioritized attribute-based repairs (Bertossi, 2011) is made (Bertossi & Li, 2013).",
      "startOffset" : 112,
      "endOffset" : 128
    }, {
      "referenceID" : 0,
      "context" : "Finally, we should note that abduction has also been explicitly applied to database repairs (Arieli et al., 2004).",
      "startOffset" : 92,
      "endOffset" : 113
    } ],
    "year" : 2015,
    "abstractText" : "Causality has been recently introduced in databases, to model, characterize and possibly compute causes for query results (answers). Connections between query causality and consistency-based diagnosis and database repairs (wrt. integrity constrain violations) have been established in the literature. In this work we establish connections between query causality and abductive diagnosis and the view-update problem. The unveiled relationships allow us to obtain new complexity results for query causality -the main focus of our workand also for the two other areas. Causality is an important notion that appears at the foundations of many scientific disciplines, in the practice of technology, and also in our everyday life. Causality is unavoidable to understand and manage uncertainty in data, information, knowledge, and theories. In data management in particular, there is a need to represent, characterize and compute the causes that explain why certain query results are obtained or not, or why natural semantic conditions, such as integrity constraints, are not satisfied. Causality can also be used to explain the contents of a view, i.e. of a predicate with virtual contents that is defined in terms of other physical, materialized relations (tables). In this work we concentrate on causality as defined forand applied to relational databases. Most of the work on causality has been developed in the context of knowledge representation, and little has been said about causality in data management. Furthermore, in a world of big uncertain data, the necessity to understand the data beyond simple query answering, introducing explanations in different forms, has become particularly relevant. The notion of causality-based explanation for a query result was introduced in (Meliou et al., 2010a), on the basis of the deeper concept of actual causation.1 Intuitively, a In contrast with general causal claims, such as “smoking tuple (of constants) t is an actual cause for an answer ā to a conjunctive query Q from a relational database instance D if there is a “contingent” subset of tuples Γ, accompanying t, such that, after removing Γ from D, removing t from D r Γ causes ā to switch from being an answer to being a non-answer (i.e. not being an answer). Usually, actual causes and contingent tuples are restricted to be among a pre-specified set of endogenous tuples, which are admissible, possible candidates for causes, as opposed to exogenous tuples. A cause t may have different associated contingency sets Γ. Intuitively, the smaller they are the strongest is t as a cause (it need less company to undermine the query answer). So, some causes may be stronger than others. This idea is formally captured through the notion of causal responsibility, and introduced in (Meliou et al., 2010a). It reflects the relative degree of actual causality. In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities (Meliou et al., 2010b,a). Furthermore, view-conditioned causality was proposed in (Meliou et al., 2010b, 2011) as a restricted form of query causality, to determine causes for a set of unexpected query results, but conditioned to the correctness of prior knowledge about some other set of results. Actual causation, as used in (Meliou et al., 2010a,b, 2011), can be traced back to (Halpern & Pearl, 2001, 2005), which provides a model-based account of causation on the basis of counterfactual dependence.2 Causal responsibility was introduced in Chockler & Halpern (2004), to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome. Model-based diagnosis (Struss, 2008, sec. 10.3), an area of causes cancer”, which refer some sort of related events, actual causation specifies a particular instantiation of a causal relationship, e.g., “Joe’s smoking is a cause for his cancer”. As discussed in (Salimi & Bertossi, 2015), some objections to the Halpern-Pearl model of causality and the corresponding changes (Halpern, 2014, 2015) do not affect results in the context of databases. knowledge representation, addresses the problem of, given the specification of a system in some logical formalism and a usually unexpected observation about the system, obtaining explanations for the observation, in the form of a diagnosis for the unintended behavior. Since this and causality are related to explanations, a first connection between causality and consistency-based diagnosis (Reiter, 1987), a form of model-based diagnosis, was established in (Salimi & Bertossi, 2014, 2015): Causality and the responsibility problem can be formulated as consistency-based diagnosis problems, which allowed to extend the results in (Meliou et al., 2010a). However, no precise connection has been established so far between causality and abductive diagnosis (Console et al., 1991; Eiter & Gottlob, 1995), another form of model-based diagnosis. The definition of causality for query answers applies to monotone queries (Meliou et al., 2010a,b). However, all complexity and algorithmic results in (Meliou et al., 2010a; Salimi & Bertossi, 2015) have been restricted to first-order (FO) monotone queries. Other important classes of monotone queries, such as Datalog queries (Ceri et al., 1989; Abiteboul et al., 1995), possibly with recursion, require further investigation. In (Salimi & Bertossi, 2015) connections were established between query causality, database repairs (Bertossi, 2011), and consistency-based diagnosis. In particular, complexity results for several causality problems were obtained from the repair connection. In the line of this kind of research, in this work we unveil natural connections between actual causation and abductive diagnosis, and also the viewupdate problem in databases (more on this latter connection later in the section). As opposed to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly performed under a logic programming (LP) approach (in the general sense of LP) to knowledge representation (Denecker & Kakas, 2002; Eiter et al., 1997; Gottlob et al., 2010b). Since Datalog can be seen as a form of LP, we manage to extend and formulate the notion of query-answer causality to Datalog queries via the abductive diagnosis connection, in this way extending causality to a new class of queries, e.g. recursive queries, and obtaining complexity results on causality for them. Abductive reasoning/diagnosis has been applied to the view update problem in databases (Kakas & Mancarella, 1990; Console et al., 1995), which is about characterizing and computing updates of physical database relations that give an account of (or have as result) the intended updates on views. The idea is that abductive diagnosis provides (abduces) the reasons for the desired view updates, and they are given as changes on base tables. In this work we also explore fruitful connections of causality with this view-update problem (Abiteboul et al., 1995), i.e. about updating a database through views. An important aspect of the problem is that one wants the base, source database, i.e. the base relations, to change in a minimally way while still producing the view updates. Put in different terms, it is an update propagation problem, from views to base relations. This classical and important problem in databases. The delete-propagation problem (Buneman et al., 2002; Kimelfeld, 2012; Kimelfeld et al., 2012) is a particular case of the view-update problem where only tuple deletions are allowed on/from the views. If the views are defined by monotone queries, only database deletions can give an account of view deletions. So, in this case, a minimal set (in some sense) of deletions from the base relations is expected to be performed. This is “minimal source-sideeffect” case. It is also possible to consider minimizing the side-effect on the view, which also requires that other tuples in the (virtual) view contents are not affected (deleted) (Buneman et al., 2002). In this work we provide a precise connection between different variants of the delete-propagation problem and query causality. In particular, we show that the minimal source-side-effect problem is related to the mostresponsible cause problem, which was formulated and investigated in (Salimi & Bertossi, 2015); and also that the “minimal view side-effect problem” is related to viewconditioned causality we already mentioned above. The established connections between abductive diagnoses, query causality and delete-propagation problems allow us to adopt (and possibly adapt) established results for some of them for application to the others. In this way we obtain some new complexity results. More precisely, our main results are as follows:3 1. We establish precise connections between causality for Datalog queries and abductive diagnosis. More precisely, we establish mutual characterizations of each in terms of the other, and computational reductions, between actual causes for Datalog queries and abductive diagnosis from Datalog specifications. We profit from these connections to obtain new algorithmic and complexity results for each of the two problems separately. (a) We characterize and obtain causes in terms ofand from abductive diagnoses. (b) We show that deciding tuple causality for Datalog queries, possibly recursive, is NP-complete in data. (c) We identify a class of Datalog queries for which The possible connections between the areas and problems in this paper were suggested in (Bertossi & Salimi, 2014), but no precise results were formulated there. 2 deciding causality is tractable in combined complexity. 2. We establish and profit from precise connections between delete-propagation and causality. More precisely, we show that: (a) Most-responsible causes and view-conditioned causes can be obtained from solutions to different variants of the delete-propagation problem and vice-versa. (b) Computing the size of the solution to a minimum source-side-effect problem is hard for FP. (c) Deciding weather an answer has a viewconditioned cause is NP-complete. (d) We can identify some new classes of queries for which computing minimum source-side-effect delete-propagation is tractable. 1 PRELIMINARIES AND CAUSALITY DECISION PROBLEMS We consider relational database schemas of the form S = (U,P), where U is the possibly infinite database domain and P is a finite set of database predicates4 of fixed arities. A database instance D compatible with S can be seen as a finite set of ground atomic formulas (in databases aka. atoms or tuples), of the form P (c1, ..., cn), where P ∈ P has arity n, and the constants c1, . . . , cn ∈ U . A conjunctive query (CQ) is a formula Q(x̄) of the firstorder (FO) language L(S) associated to S of the form ∃ȳ(P1(s̄1) ∧ · · · ∧ Pm(s̄m)), where the Pi(s̄i) are atomic formulas, i.e. Pi ∈ P , and the s̄i are sequences of terms, i.e. variables or constants of U . The x̄ in Q(x̄) shows all the free variables in the formula, i.e. those not appearing in ȳ. A sequence c̄ of constants is an answer to query Q(x̄) if D |= Q[c̄], i.e. the query becomes true in D when the variables are replaced by the corresponding constants in c̄. We denote the set of all answers to an open conjunctive query Q(x̄) with Q(D). A conjunctive query is boolean (a BCQ), if x̄ is empty, i.e. the query is a sentence, in which case, it is true or false in D, denoted by D |= Q and D 6|= Q, respectively. When Q is a BCQ, or contains no free variables, Q(D) = {yes} if Q is true, and Q(D) = ∅, otherwise. A query Q is monotone if for every two instances D1 ⊆ D2, Q(D1) ⊆ Q(D2), i.e. the set of answers grows monotonically with the instance. For example, CQs and unions of CQ (UCQs) are monotone queries. Datalog queries (Ceri et al., 1989; Abiteboul et al., 1995), although not FO, are also monotone (cf. Section 1.1 for more details). As opposed to built-in predicates (e.g. 6=) that we assume do not appear, unless explicitly stated otherwise. 1.1 CAUSALITY AND RESPONSIBILITY In the rest of this work, unless otherwise stated, we will assume that a database instance D is split in two disjoint sets, D = D ∪ D, where D and D denote the sets of endogenous and exogenous tuples, respectively; and Q is a monotone query. Definition 1.1. A tuple τ ∈ D is a counterfactual cause for an answer ā to Q in D if D |= Q(ā) and D r {τ} 6|= Q(ā). A tuple τ ∈ D is an actual cause for ā if there exists Γ ⊆ D, called a contingency set, such that τ is a counterfactual cause for ā in D r Γ. Causes(D,Q(ā)) denotes the set of actual causes for ā. This set is non-empty on the assumption that Q(ā) is true in D. When the query Q is boolean, Causes(D,Q) contains the causes for the answer yes in D. The definition of query-answer causality can be applied without any conceptual changes to Datalog queries. In the case of a Datalog, the query Q(x̄) is a whole program Π that accesses an underlying extensional database E that is not part of the query. Program Π contains a rule that defines a top answer-collecting predicate Ans(x̄). Now, ā is an answer to query Π on E when Π ∪ E |= Ans(ā). Here, entailment (|=) means that the RHS belongs to the minimal model of the LHS. A Datalog query is boolean if the top answer-predicate is propositional, say ans . In the case of Datalog, we sometimes use the notation Causes(E,Π(ā)) or Causes(E,Π), depending on whether Π has a Ans(x̄) or ans as answer predicate, resp. Given a τ ∈ Causes(D,Q(ā)), we collect all subsetminimal contingency sets associated with τ : Cont(D,Q(ā), τ ) := {Λ ⊆ Dn | D r Λ |= Q(ā), D r (Λ ∪ {τ}) 6|= Q(ā), and ∀Λ $ Λ, D r (Λ ∪ {τ}) |= Q(ā)}. The responsibility of actual cause τ for answer ā, denoted ρ Q(ā) (τ), is 1 (|Γ|+1) , where |Γ| is the size of the smallest contingency set for τ . Responsibility can be extend to all tuples in D by setting their value to 0, and they are not actual causes for Q. Example 1.1. Consider a database D with relations Author(Name,Journal) and Journal(JName,Topic,#Paper), and contents as below: Author Name JName Joe TKDE John TKDE Tom TKDE John TODS Journal JName Topic #Paper TKDE XML 30 TKDE CUBE 31 TODS XML 32 Consider the conjunctive query: Q(Name, Topic) :∃Journal JName #Paper(Author(Name,JName) ∧ Journal(JName,Topic,#Paper), (1) which has the following answers: Q(D) Name Topic Joe XML Joe CUBE Tom XML Tom CUBE John XML John CUBE 3 Assume 〈John, XML〉 is an unexpected answer to Q, and we want to compute its causes assuming that all tuples are endogenous. It turns out that Author(John, TODS) is an actual cause, with contingency sets Γ1 = {Author(John, TKDE)} and Γ2={Journal(TKDE, XML, 32)}, because Author(John, TODS) is a counterfactual cause for answer 〈 John, XML〉 in both of D r Γ1 and D r Γ2. Therefore, the responsibility of Author(John, TODS) is 12 . Likewise, Journal(TKDE, XML, 32), Author(John, TKDE), Journal(TODS,XML, 32) are actual causes for 〈John, XML〉 with responsibility 12 . Now, under the assumption that the tuples in Journal are the endogenous tuples, the only actual causes for answer 〈John, XML〉 are Author(John, TKDE) and Author(John, TODS). A Datalog query Q(x̄) is a whole program Π consisting of positive rules that accesses an underlying extensional database E that is not part of the query. Program Π contains a rule that defines a top answer-collecting predicate Ans(x̄), by means of a rule of the form Ans(x̄) ← P1(s̄1), . . . , Pm(s̄m). Now, ā is an answer to query Π on E when Π ∪ E |= Ans(ā). Here, entailment (|=) means that the RHS belongs to the minimal model of the LHS. So, the extension Ans(D) of Ans in the minimal model of the program contains the answers to the query. A Datalog query is boolean if the top answer-predicate is propositional, say ans , i.e. defined by a rule of the form ans ← P1(s̄1), . . . , Pm(s̄m). In this case, the query is true if Π∪D |= ans , equivalently, if ans belongs to the minimal model of Π ∪E (Ceri et al., 1989; Abiteboul et al., 1995). CQs can be expressed as Datalog queries, e.g. (1) becomes: AnsQ(Name, Topic) ←− Author(Name,JName), Journal(JName,Topic,#Paper). The definition of query-answer causality can be applied without any conceptual changes to Datalog queries. In the case of Datalog, we sometimes use the notation Causes(E,Π(ā)) or Causes(E,Π), depending on whether Π has a Ans(x̄) or ans as answer predicate, resp. In (Meliou et al., 2010a), causality for non-query answers is defined on basis of sets of potentially missing tuples that account for the missing answer. Computing actual causes and their responsibilities for non-answers becomes a rather simple variation of causes for answers. In this work we focus on causality for query answers. The complexity of the computational and decision problems that arise in query causality have been investigated in (Meliou et al., 2010a; Salimi & Bertossi, 2015). Here we present some problems and results that we use throughout this paper. The first is the causality problem, about deciding whether a tuple is an actual cause for a query answer. Definition 1.2. For a boolean monotone query Q, the causality decision problem (CDP) is (deciding about membership of): CDP(Q) := {(D, τ) | τ ∈ D, and τ ∈",
    "creator" : "LaTeX with hyperref package"
  }
}