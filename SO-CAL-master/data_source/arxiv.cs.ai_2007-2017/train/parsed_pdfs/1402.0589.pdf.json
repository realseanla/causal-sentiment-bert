{
  "name" : "1402.0589.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Protecting Privacy through Distributed Computation in Multi-agent Decision Making Online Appendix 3: Unique ID Generation Algorithm",
    "authors" : [ "Thomas Léauté", "Boi Faltings" ],
    "emails" : [ "thomas.leaute@a3.epfl.ch", "boi.faltings@epfl.ch" ],
    "sections" : [ {
      "heading" : "Protecting Privacy through Distributed Computation",
      "text" : "in Multi-agent Decision Making\nOnline Appendix 3: Unique ID Generation Algorithm\nThomas Léauté thomas.leaute@a3.epfl.ch Boi Faltings boi.faltings@epfl.ch\nThe assignment of unique IDs to n variables is an instance of the well-known renaming problem, for which multiple algorithms have been proposed in the literature on distributed algorithms. However, to our knowledge, all these algorithms focus on robustness to failures, and ignore the issue of privacy. On the contrary, in this paper we do not consider agent failures, and we rather need an algorithm that protects agent and topology privacy. To this purpose, we propose Algorithm 1, which is a modification of the pseudo-tree generation algorithm in Online Appendix 2, and is an improved version of the algorithm proposed by Léauté and Faltings (2009). Each variable x is assigned a unique number idx that corresponds to the order in which it is first visited during the distributed traversal of the constraint graph (or, more precisely, an upper bound thereon). This is done by appending to each CHILD message the number id of variables visited so far (lines 8, 29 and 31). Each variable adds a random number to id so as not to leak any useful upper bound on its number of neighbors (lines 5 and 15). At the end of this algorithm, the root variable discovers an upper bound n+ on the total number of variables, and reveals it to everyone (lines 35 and 22 to 24).\nTheorem 1. The unique variable ID assignment algorithm guarantees full agent privacy, and partial topology privacy. The minor leaks of topology privacy lie in the fact that a variable might be able to discover:\n• upper and lower bounds on the total number of variables;\n• that there exists another branch in the constraint graph that it is not involved in.\nProof. This is a modification of the depth-first traversal of the constraint graph in Online Appendix 2, which was shown to guarantee full agent privacy and full topology privacy. One difference is that the messages now also carry an integer id that is an upper bound on the number of variables visited so far, which cannot be used to make inferences about the identities of agents, but is a source of (minor) topology privacy leaks, as described below.\n• When receiving a CHILD message from its parent, variable x discovers that there exist at most id other variables in the problem that have already been visited. These variables are either ancestors of its parent, or descendants of its parent in another branch of the pseudo-tree. To make sure this bound is loose and uninformative, each variable adds a random number in [incrmin . . . 2incrmin] to its id, where incrmin is a free parameter of the algorithm. In particular, this prevents the case id = 1, which\n©2013 AI Access Foundation. All rights reserved.\nAlgorithm 1 Pseudo-tree and unique ID generation algorithm for variable x\nRequire: a root variable 1: if x has at least one neighbor then 2: openx ← ∅ 3: if x has been elected as the root then 4: idx ← 0 5: id+x ← idx + rand(incrmin . . . 2incrmin) 6: openx ← all neighbors of x 7: Remove a random neighbor y0 from openx and add it to childrenx 8: Send the message (CHILD, id+x + 1) to y0 9: loop 10: Wait for an incoming message (type, id) from a neighbor yi\n11: if openx = ∅ then // first time x is visited 12: openx ← all neighbors of x except yi 13: parentx ← yi 14: idx ← id 15: id+x ← idx + rand(incrmin . . . 2incrmin) 16: else if type = CHILD and yi ∈ openx then 17: Remove yi from openx and add it to pseudo childrenx 18: Send message (PSEUDO, id) to yi 19: next\n20: else if type = PSEUDO then 21: Remove yi from childrenx and add it to pseudo parentsx\n22: else if type = NBRVARS then 23: n+ ← id // upper bound on the true number of variables n 24: break\n25: // Forward the CHILD message to the next open neighbor: 26: Choose a random yj ∈ openx 27: if there exists such a yj then 28: Remove yi from openx and add it to childrenx 29: Send the message (CHILD, max(id, id+x + 1)) to yj 30: else if x is not the elected root then // backtrack 31: Send message (CHILD, max(id, id+x + 1)) to parentx 32: else 33: n+ ← id // upper bound on the true number of variables n 34: break 35: Send message (NBRVARS, n+) to all children of x\nwould allow x to infer that its parent is the root of the pseudo-tree, and that x is its first child. Variable x also discovers that there exist at least bid/(2incrmin)c alreadyvisited variables. Notice that these two bounds are not informative about the topology\nof the constraint graph, since the P3/2-DPOP(+) and P2-DPOP(+) algorithms leak the total number of variables anyway.\n• When receiving a CHILD message from a child y, variable x can compare the id it contains with the id it previously sent to y. The difference ∆id ≥ incrmin is an upper bound on the number of y’s descendants; the parameter incrmin can be chosen as large as necessary to make this bound as loose as desired. Variable x also discovers that b∆id/(2incrmin)c is a lower bound on the number of y’s descendants.\n• The id contained in a PSEUDO message does not provide any information, as it is equal to the id in the CHILD message to which the PSEUDO message is a response. In fact, id could be removed from the PSEUDO message; it has only be left in Algorithm 1 for the sake of conciseness of the pseudo-code.\nOnce all variables have been assigned unique IDs, the last such ID is revealed to all variables (and is recorded as n+). This reveals an upper bound on the total number of variables, which is useless since the exact total number of variables is later revealed anyway by the P3/2DPOP(+) and P2-DPOP(+) algorithms. However, it also reveals to each variable whether it is the last visited variable, i.e. the last leaf of the pseudo-tree. This is another, minor leak of topology privacy, since the leaves of the pseudo-tree that are not the last leaf discover that there exists at least one other branch in the pseudo-tree (and therefore in the constraint graph) that they are not involved in."
    } ],
    "references" : [ {
      "title" : "Privacy-preserving multi-agent constraint satisfaction",
      "author" : [ "T. Léauté", "B. Faltings" ],
      "venue" : "In Proceedings of the 2009 IEEE International Conference on PrivAcy, Security, riSk And Trust (PASSAT’09),",
      "citeRegEx" : "Léauté and Faltings,? \\Q2009\\E",
      "shortCiteRegEx" : "Léauté and Faltings",
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "To this purpose, we propose Algorithm 1, which is a modification of the pseudo-tree generation algorithm in Online Appendix 2, and is an improved version of the algorithm proposed by Léauté and Faltings (2009). Each variable x is assigned a unique number idx that corresponds to the order in which it is first visited during the distributed traversal of the constraint graph (or, more precisely, an upper bound thereon).",
      "startOffset" : 183,
      "endOffset" : 210
    } ],
    "year" : 2013,
    "abstractText" : "The assignment of unique IDs to n variables is an instance of the well-known renaming problem, for which multiple algorithms have been proposed in the literature on distributed algorithms. However, to our knowledge, all these algorithms focus on robustness to failures, and ignore the issue of privacy. On the contrary, in this paper we do not consider agent failures, and we rather need an algorithm that protects agent and topology privacy. To this purpose, we propose Algorithm 1, which is a modification of the pseudo-tree generation algorithm in Online Appendix 2, and is an improved version of the algorithm proposed by Léauté and Faltings (2009). Each variable x is assigned a unique number idx that corresponds to the order in which it is first visited during the distributed traversal of the constraint graph (or, more precisely, an upper bound thereon). This is done by appending to each CHILD message the number id of variables visited so far (lines 8, 29 and 31). Each variable adds a random number to id so as not to leak any useful upper bound on its number of neighbors (lines 5 and 15). At the end of this algorithm, the root variable discovers an upper bound n+ on the total number of variables, and reveals it to everyone (lines 35 and 22 to 24).",
    "creator" : "TeX"
  }
}