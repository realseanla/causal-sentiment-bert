{
  "name" : "1706.00585.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Exception-Based Knowledge Updates",
    "authors" : [ "Martin Slota", "João Leite" ],
    "emails" : [ "martin.slota@gmail.com", "jleite@fct.unl.pt" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Existing methods for dealing with knowledge updates differ greatly depending on the underlying knowledge representation formalism. When Classical Logic is used, updates are typically performed by manipulating the knowledge base on the model-theoretic level. On the opposite side of the spectrum stand the semantics for updating Answer-Set Programs that need to rely on rule syntax. Yet, a unifying perspective that could embrace both these branches of research is of great importance as it enables a deeper understanding of all involved methods and principles and creates room for their cross-fertilisation, ripening and further development. Furthermore, from a more pragmatic viewpoint, such a unification is a necessary step in addressing updates of hybrid knowledge bases consisting of both a classical and a rule component.\nThis paper bridges the seemingly irreconcilable approaches to updates. It introduces a novel monotonic characterisation of rules, dubbed RE-models, and shows it to be a more suitable semantic foundation for rule updates than SE-models. Then it proposes a generic scheme for specifying semantic rule update operators, based on the idea of viewing a program as the set of sets of RE-models of its rules; updates are performed by introducing additional interpretations – exceptions – to the sets of RE-models of rules in the original program. The introduced scheme is then used to define particular rule update operators that are closely related to both classical update principles and traditional approaches to rules updates, enjoying a range of plausible syntactic as well as semantic properties. In addition, these operators serve as a basis for a solution to the long-standing problem of state condensing for two of the foundational rule update semantics, showing how they can be equivalently defined as binary operators on some class of logic programs.\nFinally, the essence of these ideas is extracted to define an abstract framework for exception-based update operators, viewing a knowledge base as the set of sets of models of its elements. It is shown that the framework can capture a wide range of both model- and formula-based classical update operators, and thus serves as the first firm formal ground connecting classical and rule updates."
    }, {
      "heading" : "1. Introduction",
      "text" : "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively. This has fostered a large number of ontologies and\nIThis is a revised and extended version of the material presented in [66–68]. ∗Corresponding author. Email addresses: martin.slota@gmail.com (Martin Slota), jleite@fct.unl.pt (João Leite) 1http://www.w3.org/TR/owl-overview/ 2http://www.w3.org/2005/rules/wiki/RIF_Working_Group\nPreprint submitted to Elsevier June 5, 2017\nar X\niv :1\n70 6.\n00 58\n5v 1\n[ cs\n.A I]\n2 J\nun 2\n01 7\nrule bases with different levels of complexity and scale. Whereas ontologies provide the logical underpinning of intelligent access and information integration, rules are widely used to represent business policies, regulations and declarative guidelines about information.\nSince both ontologies and rules offer important features for knowledge representation, considerable effort has been invested in identifying a unified hybrid knowledge framework where expressivity of both formalisms could be seamlessly combined. Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54]. While such formalisms make it possible to seamlessly combine rules and ontologies in a single unified framework, they do not take into account the dynamic character of application areas where they are to be used. More particularly, the essential support for keeping a hybrid knowledge base up to date, by incorporating new and possibly conflicting information, is still missing. Nonetheless, this topic has been extensively addressed in the context of both Description Logics and Logic Programs, when taken separately.\nOntology Updates The area of research called ontology change encompasses a number of strongly related though distin-\nguishable subareas, such as ontology matching, ontology integration and merging, or ontology translation [26]. The purest type of change, concerned with modifications to a single ontology, is generally referred to as ontology evolution. Approaches to ontology evolution with a firm semantic underpinning, thus amenable to a formal analysis of their behaviour and properties, are based on research in the area of belief change, initiated by the seminal work of Alchourrón, Gärdenfors and Makinson (AGM) [1] who proposed a set of desirable properties of change operators on monotonic logics, now referred to as the AGM postulates.\nSubsequently, revision and update were distinguished as two very related but ultimately different belief change operations [41, 42, 73]. While revision deals with incorporating new information about a static world into a knowledge base, update takes place when a knowledge base needs to be brought up to date when the modelled world changes. While AGM postulates were deemed appropriate for describing revision, Katsuno and Mendelzon suggested a different set of postulates for updates: the KM postulates for belief update [41].\nUpdate operators respecting the KM postulates, usually referred to as model-based, are based on the idea that the models of a knowledge base correspond to possible states of the represented world. When a change in the world needs to be recorded, inertia is applied to each of these possible states, making only the smallest necessary modifications to reflect the change, and arriving at a new collection of possible states that represent the world after the update. Since the updates are specified on the semantic level, they are naturally syntax-independent. These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).\nOn the other hand, model-based operators are considered inappropriate for updating ontological axioms that define the terminology (the TBox) [13, 64]. Their antipole, formula-based operators, which manipulate the knowledge base at a syntactic level and are strongly related to base revision operators, were adopted for performing TBox updates instead [13], and they also inspired a recent approach to ABox updates [49].\nRule Updates When updates started to be investigated in the context of Logic Programming, it was only natural to\nadapt belief update principles and operators to this purpose [2, 53]. However, such approaches proved insufficiently expressive, principally because the model-based approach fails to capture the essential relationships between literals encoded in rules [48], and the formula-based approach is too crude as it does not\nallow rules to be reactivated when reasons for their suppression disappear [75]. Although state-of-the-art approaches to rule updates are guided by the same basic intuitions and aspirations as belief updates, they build upon fundamentally different principles and methods.\nMany of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule. This essentially means that inertia and minimal change is applied to rules instead of to the state, as with model-based belief updates. Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable. Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].\nDespite the variety of techniques used in these approaches, certain properties are common to all of them. First, the stable models assigned to a program after one or more updates are always supported: for each true atom p there exists a rule in either the original program or its updates that has p in the head and whose body is satisfied. Second, all mentioned rule update semantics coincide when it comes to updating sets of facts by newer facts. We conjecture that any reasonable rule update semantics should indeed be in line with the basic intuitions regarding support and fact update. Another common characteristic of all these approaches is that they need to refer to the syntactic structure of a logic program: the individual rules and, in most cases, also the literals in their heads and bodies. This renders them seemingly irreconcilable with ontology updates since ontology axioms simply have no heads and bodies.\nTowards Hybrid Updates\nA unifying framework that could embrace both belief and rule updates is of great importance as it enables a deeper understanding of all involved methods and principles and creates room for their crossfertilisation, ripening and further development. It is also important for the development of update semantics for hybrid knowledge bases – in [64, 70] we provided partial solutions to this problem but the inherent differences between the distinct approaches to updates have prevented us from suggesting a universal hybrid update semantics.\nMoreover, we argue that syntax-independence, central to model-based belief updates, is essential and should be pursued at large in order to encourage a logical underpinning of all update operators and so facilitate analysis of their semantic properties. When equivalence with respect to classical models is inappropriate, as is the case with rules, syntax-independence should be retained by finding an appropriate notion of equivalence, specific to the underlying formalism and its use.\nWith these standpoints in mind, we proceed with our previous work addressing the logical foundations of rule updates. In [69] we have shown that strong equivalence is not a suitable basis for syntax-independent rule update operators because such operators cannot respect both support and fact update. This can be demonstrated on programs P = { p., q. } and Q = { p., q ← p. } which are strongly equivalent, so, due to syntax independence, an update asserting that p is now false ought to lead in both cases to the same stable models. Due to fact update, such an update on P should naturally lead to a stable model where q is true. But in case of Q such a stable model would be unsupported.\nThis led us to the study of stronger notions of program equivalence. In [65] we proposed to view a program as the set of sets of models of its rules in order to acknowledge rules as the atomic pieces of knowledge and, at the same time, abstract away from unimportant differences between their syntactic forms, focusing on their semantic content. In this paper we develop these ideas further and arrive at a unifying perspective on both classical and rule updates. More particularly, our main contributions are as follows:\n• We introduce a novel monotonic characterisation of rules, RE-models, and show that they form a more suitable semantic foundation for rule updates than SE-models;\n• We propose a generic scheme for defining semantic rule update operators: a program, viewed as the set of sets of RE-models of its rules, is updated by introducing additional interpretations to those sets of RE-models;\n• We identify instances of the framework that bridge classical update principles with traditional rule update semantics: they combine syntax-independence with support and fact update and have other desirable syntactic as well as semantic properties.\n• We solve the enduring problem of state condensing for two foundational rule update semantics by showing how they can be equivalently defined as binary operators on some class of logic programs;\n• We define abstract exception-based operators for any knowledge representation formalism with a model-theoretic semantics;\n• We show that exception-based operators capture a wide range of model- and formula-based belief update operators.\nThis paper is organised as follows: We introduce the necessary theoretical background in Section 2 and in Section 3 we define RE-models and associated notions of equivalence. Section 4 introduces the generic scheme for specifying exception-based rule update operators as well as its particular instances and analyses their theoretical properties. Section 5 is devoted to the problem of state condensing and introduces operators for condensing an update sequence into a single program for foundational rule update semantics. Sections 6 and 7 introduce abstract exception-based operators and show how they are able to characterise belief updates. We discuss our findings in a broader context and conclude in Section 8. Proofs of all formal results can be found in the appendices.\n2. Background\n2.1. Propositional Logic We consider a propositional language over a finite set of propositional variables A and the usual set of\npropositional connectives to form propositional formulas. A knowledge base is a finite set of formulas. A (two-valued) interpretation is any I ⊆ A and the set of all interpretations is denoted by I. The set of models of a knowledge base B is defined in the standard way and denoted by [[B ]]. Given an interpretation I , we sometimes write I |= B or I(B) = T if I is a model of B, and I 6|= B or I(B) = F if I is not a model of B. A knowledge base B is consistent if [[B ]] is non-empty; complete if [[B ]] is a singleton set. Given two knowledge bases B, C, we say that B entails C, denoted by B |= C, if [[B ]] ⊆ [[C ]], and that B is equivalent to C, denoted by B ≡ C, if [[B ]] = [[C ]]. The models, set of models, consistency, completeness, entailment and equivalence are generalised to formulas by treating every formula φ as the knowledge base {φ }.\n2.2. Logic Programs The basic syntactic building blocks of rules are also propositional atoms from A. A default literal is an atom preceded by ∼ denoting default negation. The set of all literals L consists of all atoms and default literals. The complementary literal to a literal L is denoted by L and defined as follows: for any atom p, p = ∼ p and ∼ p = p. Given a set of literals S, we introduce the following notation: S+ = { p ∈ A | p ∈ S }, S− = { p ∈ A | ∼ p ∈ S }, S = { L ∣∣ L ∈ S }.\nA rule is a pair of sets of literals π = (Hπ,Bπ). We say that Hπ is the head of π and Bπ is the body of π. Usually, for convenience, we write π as ( H+π ; H − π ← B+π ,B−π . ) . A rule is called non-disjunctive if its head contains at most one literal; a fact if its head contains exactly one literal and its body is empty. A program is any set of rules. A program is non-disjunctive if all its rules are; acyclic if it satisfies the conditions set out in [6]. We also introduce the following non-standard notion that is needed throughout the rest of the paper:\nDefinition 1 (Canonical Tautology). Let pτ ∈ A be fixed. The canonical tautology τ is the rule (pτ ← pτ .).\nTurning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program. We start by generalizing the set of (classical) models to literals, rules and programs. Given an atom p, a set of literals S, a rule π and a program P, we define the following:\n[[∼ p ]] = I \\ [[p ]] , [[S ]] = ⋂ L∈S [[L ]] ,\n[[π ]] = { J ∈ I | J /∈ [[Bπ ]] ∨ ∃L ∈ Hπ : J ∈ [[L ]] } , [[P ]] = ⋂ π∈P[[π ]] .\nFor a set of literals S, we also write J |= S whenever J ∈ [[S ]]. A program P is consistent if [[P ]] 6= ∅. The stable and SE-models are defined in terms of reducts. Given a rule π and an interpretation J , the reduct of π w.r.t. J , denoted by πJ , is the rule (H+π ← B+π .) if J |= B−π and J |= H−π ; otherwise it is the canonical tautology τ .3 The reduct of a program P w.r.t. J is defined as PJ = { πJ ∣∣ π ∈ P }.\nAn interpretation J is a stable model of a program P if J is a subset-minimal model of PJ . The set of all stable models of P is denoted by [[P ]]SM.\nSE-models are semantic structures that can be seen as three-valued interpretations. In particular, we call a pair of interpretations X = (I, J) such that I ⊆ J a three-valued interpretation. Each atom p is assigned one of three truth values in X: X(p) = T if p ∈ I; X(p) = U if p ∈ J \\ I; X(p) = F if p ∈ A \\ J . The set of all three-valued interpretations is denoted by X. A three-valued interpretation (I, J) is an SE-model of a rule π if J is a model of π and I is a model of πJ . The set of all SE-models of a rule π is denoted by [[π ]]SE and for any program P, [[P ]]SE = ⋂ π∈P[[π ]]SE. Note that J is a stable model of P if and only if (J, J) ∈ [[P ]]SE and for all I ( J , (I, J) /∈ [[P ]]SE. Also, J ∈ [[P ]] if and only if (J, J) ∈ [[P ]]SE. We say that a rule π is (SE-)tautological if [[π ]]SE = X. Note that the canonical tautology (c.f. Definition 1) is tautological.\n2.3. Belief Updates\nIn this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].\nWe liberally define a belief update operator as any function that takes the original knowledge base and its update as inputs and returns the updated knowledge base.\nDefinition 2 (Update Operator). A belief update operator is a binary function over the set of all knowledge bases. Any belief update operator is inductively generalised to finite sequences of knowledge bases 〈Bi〉i<n as follows: 3〈〉 = ∅ and 3〈Bi〉i<n+1 = (3〈Bi〉i<n) Bn.\n3In other words, if J satisfies all default literals in the body of the rule and none of the default literals in its head, then the reduct is obtained from the original rule by removing all default literals from its head and body. In other cases, J is certainly a model of the rule, so the reduct is defined as the canonical tautology.\nThe fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state. Given this perspective, it is natural to perform an update with U by modifying each of the possible states independently of the others, making it consistent with U , and thus obtaining a new set of interpretations – the models of the updated knowledge base. Formally this is captured by the equation\n[[B U ]] = ⋃\nI∈[[B ]]\nincorporate([[U ]], I) , (1)\nwhere incorporate(M, I) returns the members of M closer to I so that the original information in I is preserved as much as possible. For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I . From a more general perspective, Katsuno and Mendelzon have shown [41] that if each knowledge base is represented by a single formula and incorporate(M, I) is bound to return those members ofM that are minimal w.r.t. a closeness relation ≤I assigned to I ,4 then the class of operators which satisfy (1) coincides with the class of operators which satisfy the declarative postulates (B1) – (B8) listed in Table 1. Note that (B1) – (B6) can be immediately generalised to deal with arbitrary knowledge bases but (B7) and (B8) require disjunction of knowledge bases to be defined.\nSome of these postulates, and especially (B4) which guarantees syntax-independence of an update operator, continue to be seen as fundamental cornerstones of belief updates [34]. The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34]. Note also that (B2) entails the weaker\n4Technically, the closeness relation is simply a partial order on I such that I is the least interpretation w.r.t. ≤I .\nprinciples (B2.>), (B2.1) and (B2.2). The first two are uncontroversial as they are satisfied by all update operators. In addition, in the presence of (B4), the latter two are together powerful enough to entail (B2), so the controversial part of (B2) is (B2.2) [34].\nEarlier approaches to updates, dubbed formula-based [73], operate on the syntax of a knowledge base and, as a consequence, are not syntax-independent. Nevertheless, they have recently been considered for performing ontology updates [13, 49]. Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30]. We define only the latter two as the Set-Of-Theories operator produces a collection of knowledge bases as its result instead of a single knowledge base, and is equivalent to the Cross-Product operator which compiles these knowledge bases into one.\nThe central notion in these operators is that of a possible remainder which is a maximal set of formulas from the original knowledge base that is consistent with the update. Formally, given knowledge bases B and U , the set of possible remainders rem(B,U) is the set of maximal subsets B′ of B such that B′ ∪ U is consistent. The distinct formula-based operators differ in how they deal with the case when there is more than one possible remainder. While Cross-Product compiles the different remainders into a single formula, WIDTIO takes the safer path – it keeps exactly those formulas that belong to the intersection of all remainders and throws away the rest. Additionally, in [13] the new formula-based operator Bold was suggested for performing TBox updates. The Bold operator solves the problem of multiple remainders by using a selection function to choose one and commit to it. Formally, a remainder selection function is a function s that assigns to every set of remainders R a remainder s(R) ∈ R. Given such a selection function s, the Cross-Product operator ◦cp, WIDTIO operator ◦widtio and Bold operator ◦sbold are defined for all knowledge bases B, U as follows:\nB ◦cp U = U ∪ {∨ B′∈rem(B,U) ∧ B′ } , B ◦widtio U = U ∪ ⋂ rem(B,U), B ◦sbold U = U ∪ s(rem(B,U)).\n2.4. Rule Updates Rule update semantics assign stable models to pairs or sequences of programs where each component\nrepresents an update of the preceding ones. In the following, we formalise some of the intuitions behind these semantics and define two foundational rule update semantics.\nWe start with the basic concepts. A dynamic logic program (DLP) is a finite sequence of non-disjunctive programs. Given a DLP P , we use all(P ) to denote the set of all rules belonging to the programs in P .5\nWe say that P is acyclic if all(P ) is acyclic. A rule update semantics S assigns a set of S-stable models [[P ]]S to every DLP P .\nAs indicated in the introduction, rule update semantics implicitly follow certain basic intuitions. Particularly, they produce supported models and their behaviour coincides when it comes to updating sets of facts by newer facts. We formalise these two properties w.r.t. rule update semantics for DLPs, calling them syntactic because their formulation requires that we refer to the syntax of the respective DLP.\nIn the static setting, support [7, 21] is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy. Its generalisation to the dynamic case is straightforward.\nSyntactic Property 1 (Support). Let P be a program, p an atom and J an interpretation. We say that P supports p in J if p ∈ Hπ and J |= Bπ for some rule π ∈ P.\n5In order to avoid issues with rules that are repeated in multiple components of a DLP, we assume throughout this paper that every rule is uniquely identified in all set-theoretic operations. This can be formalised by assigning a unique name to each rule and performing operations on names instead of the rules themselves. However, for the sake of simplicity, we leave the technical realisation to the reader.\nA rule update semantics S respects support if for every DLP P and every S-stable model J of P the following condition is satisfied: Every atom p ∈ J is supported by all(P ) in J .\nThus, if a rule update semantics S respects support, then there is at least some justification for every atom in an assigned S-stable model.\nThe second syntactic property that is generally adhered to is the usual expectation regarding how facts are to be updated by newer facts. It enforces a limited notion of state inertia but only for the case when both the initial program and its updates are consistent sets of facts.\nSyntactic Property 2 (Fact Update). A rule update semantics S respects fact update if for every finite sequence of consistent sets of facts P = 〈Pi〉i<n, the unique S-stable model of P is the interpretation\n{ p | ∃i < n : (p.) ∈ Pi ∧ (∀j : i < j < n⇒ (∼ p.) /∈ Pj) } .\nWe also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55]. The first one states the principle itself, under the assumption that a conflict between rules occurs if and only if the rules have complementary heads.\nSyntactic Property 3 (Causal Rejection). A rule update semantics S respects causal rejection if for every DLP P = 〈Pi〉i<n, every S-stable model J of P , all i < n and all rules π ∈ Pi, if J is not a model of π, then there exists a rule σ ∈ Pj with j > i such that Hσ = Hπ and J |= Bσ.\nIntuitively, the principle requires that all rejected rules, i.e. rules that are not satisfied in an S-stable model J , must be in conflict with a more recent rule whose body is satisfied in J . This rule then provides a cause for the rejection.\nThe final syntactic property stems from the fact that all rule update semantics based on causal rejection coincide on acyclic DLPs [5, 36]. Thus, the behaviour of any rule update semantics on acyclic DLPs can be used as a way to compare it to all these semantics simultaneously. Before formalising the property, we define two foundational rule update semantics based on causal rejection: the JU-semantics [48] and the UA-semantics [24].\nDefinition 3 (JU-Semantics [48] and UA-Semantics [24]). Let P = 〈Pi〉i<n be a DLP and J an interpretation. The sets of rejected rules rejJU(P , J) and rejUA(P , J) are defined as follows:\nrejJU(P , J) = { π ∈ Pi ∣∣ ∃j ∃σ ∈ Pj : i < j < n ∧ Hσ = Hπ ∧ J |= Bσ } , rejUA(P , J) = { π ∈ Pi\n∣∣ ∃j ∃σ ∈ Pj \\ rejUA(P , J) : i < j < n ∧ Hσ = Hπ ∧ J |= Bσ } .6 The set [[P ]]JU of JU-models of a DLP P consists of all interpretations J such that J is a stable model of the program all(P ) \\ rejJU(P , J). Similarly, the set [[P ]]UA of UA-models of a DLP P consists of all interpretations J such that J is a stable model of the program all(P ) \\ rejUA(P , J).\nUnder the JU-semantics, a rule π is rejected if a more recent rule σ is in conflict with π and the body of σ is satisfied in the stable model candidate J . The only difference in the UA-semantics [24] is that rejected rules are prevented from rejecting other rules. Perhaps surprisingly, this renders the UA-semantics more sensitive to tautological updates, which cannot indicate any change in the modelled world, than the JU-semantics. For example, the DLP\nP 1 = 〈{ p. } , {∼ p. } , { p← p. }〉 (2)\nhas only one JU-model, ∅, but the UA-semantics admits the additional undesired model { p }. Nevertheless, there are also situations in which the JU-semantics assigns additional models only due to the presence of tautological rules. This is discussed in more detail in Section 8.\nThe final syntactic property can now be stated as follows:\nSyntactic Property 4 (Acyclic Justified Update). A rule update semantics S respects acyclic justified update if for every acyclic DLP P , the set of S-stable models of P is [[P ]]JU.\n2.5. Program Equivalence While in propositional logic equivalence under classical models is the equivalence, there is no such\nsingle notion of program equivalence. When considering Answer-Set Programs, the first choice is stable equivalence (or SM-equivalence) that compares programs based on their sets of stable models.\nIn many cases, however, SM-equivalence is not strong enough because programs with the same stable models, when augmented with the same additional rules, may end up having completely different stable models. This gives rise to the notion of strong equivalence [50] which requires that stable models stay the same even in the presence of additional rules. It is a well-known fact that programs are strongly equivalent if and only if they have the same set of SE-models [71]. Thus, we refer to strong equivalence as SE-equivalence.\nBut even SE-equivalence is not satisfactory when used as a basis for syntax-independent rule update operators because such operators cannot respect both support and fact update [69]. So in order to arrive at syntax-independent rule update operators that satisfy the basic intuitions underlying rule updates, we need to search for a notion of program equivalence that is stronger than SE-equivalence. One candidate is the strong update equivalence (or SU-equivalence) [39], which requires that under both additions and removals of rules, stable models of the two programs in question remain the same. It has been shown in [39] that this notion of equivalence is very strong – programs are SU-equivalent only if they contain exactly the same non-tautological rules, and in addition, each of them may contain some tautological ones. Thus, this notion of program equivalence seems perhaps too strong as it is not difficult to find rules such as (∼ p ← p.) and (← p.) that are syntactically different but carry the same meaning.\nThis observation resulted in the definition of strong rule equivalence (or SR-equivalence) and strong minimal rule equivalence (or SMR-equivalence) in [65] that, in terms of strength, fall between SE-equivalence and SU-equivalence. It is based on the idea of viewing a program P as the set of sets of SE-models of its rules 〈〈P〉〉SE = { [[π ]]SE | π ∈ P }.\nThe five mentioned notions of program equivalence are defined as follows:\nDefinition 4 (Program Equivalence). Let P,Q be programs, Pτ = P ∪ { τ }, Qτ = Q ∪ { τ }, let minS denote the subset-minimal elements of any set of sets S and ÷ denote set-theoretic symmetric difference. We write\nP ≡SM Q whenever [[P ]]SM = [[Q ]]SM ; P ≡SMR Q whenever min〈〈Pτ 〉〉SE = min〈〈Qτ 〉〉SE ; P ≡SE Q whenever [[P ]]SE = [[Q ]]SE ; P ≡SR Q whenever 〈〈Pτ 〉〉SE = 〈〈Qτ 〉〉SE ; P ≡SU Q whenever [[P ÷Q ]]SE = X .\nWe say that P is X-equivalent to Q if P ≡X Q.\nSo two programs are SR-equivalent if they contain the same rules, modulo SE-models; τ is added to both programs so that presence or absence of tautological rules in a program does not influence program equivalence. In the case of SMR-equivalence, only the subset-minimal sets of SE-models are compared,\nthe motivation being that programs such as P = { p← q. } and Q = { p., p← q. }, when updated, should behave the same way since the extra rule inQ is just a weakened version of the rule in P. Though P andQ are not SR-equivalent, they are SMR-equivalent.\nTo formally capture the comparison of strength between these notions of program equivalence, we write ≡X ≡Y if P ≡Y Q implies P ≡X Q and ≡X≺≡Y if ≡X ≡Y but not ≡Y ≡X. Then:\nProposition 5 ([65]). ≡SM≺≡SE≺≡SMR≺≡SR≺≡SU."
    }, {
      "heading" : "3. Robust Equivalence Models",
      "text" : "In [65] we studied the expressivity of SE-models with respect to a single rule. On the one hand, SE-models turned out to be a useful means of stripping away irrelevant syntactic details. On the other hand, a rule with a default literal in its head is indistinguishable from an integrity constraint [12, 38, 40]. For example, the rules\n← p, q. ∼ p← q. ∼ q ← p. (3)\nhave the same set of SE-models. In a static setting, these rules indeed carry essentially the same meaning: “it must not be the case that p and q are both true”. But in a dynamic context, the latter two rules may, in addition, express that the truth of one atom gives a reason for the other atom to cease being true. For example, an update of the program { p., q. } by {∼ p← q. } leads to the stable model { q } while an update by {∼ q ← p. } to the stable model { p }. This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.\nIn order to be able to semantically characterise causal rejection-based rule update semantics, we need to distinguish between constraints and rules with default literals in their heads. These classes can be formally captured as follows:\nDefinition 6 (Constraint and Abolishing Rule). A rule π is a constraint if Hπ = ∅ and B+π is disjoint with B−π . 7 A rule π is abolishing if H+π = ∅, H−π 6= ∅ and the sets H−π , B+π and B−π are pairwise disjoint.\nSo what we are looking for is a semantic characterisation of rules that\n1) can distinguish constraints from related abolishing rules;\n2) discards irrelevant syntactic details (akin to SE-models);\n3) has a clear link to stable models (akin to SE-models).\nIn the following we introduce a novel monotonic semantics that exactly meets these criteria. We show that it possesses the desired properties and use it to introduce a notion of program equivalence that is strong enough as a basis for syntax-independent rule update operators.\nWithout further ado, robust equivalence models, or RE-models for short, are defined as follows:\nDefinition 7 (RE-Model). Let π be a rule. A three-valued interpretation (I, J) ∈ X is an RE-model of π if I |= πJ . The set of all RE-models of a rule π is denoted by [[π ]]RE and for any program P, [[P ]]RE =⋂ π∈P[[π ]]RE.\nWe say that a rule π is RE-tautological if [[π ]]RE = X. Rules π, σ are RE-equivalent if [[π ]]RE = [[σ ]]RE.\n7The latter condition guarantees that a constraint is not tautological.\nThus, unlike with SE-models, it is not required that J |= π in order for (I, J) to be an RE-model of π. As a consequence, RE-models can distinguish between rules in (3): while both ({ q } , { p, q }) and ({ p } , { p, q }) are RE-models of the constraint, the former is not an RE-model of the first abolishing rule and the latter is not an RE-model of the second abolishing rule. This property holds in general, establishing requirement 1):\nProposition 8. If π, σ are two different abolishing rules or an abolishing rule and a constraint, then π, σ are not RE-equivalent.\nProof. See Appendix A, page 34.\nAs for requirement 2), we first note that RE-equivalence is a refinement of SE-equivalence – there are no rules that are RE-equivalent but not SE-equivalent. The following result also shows that it is only the ability to distinguish between constraints and abolishing rules that is introduced by RE-models – rules that are not RE-equivalent to abolishing rules are distinguishable by RE-models if and only if they are distinguishable by SE-models. Furthermore, the classes of SE-tautological and RE-tautological rules coincide, so we can simply use the word tautological without ambiguity.\nProposition 9 (RE-Equivalence vs. SE-Equivalence). • If two rules are RE-equivalent, then they are SE-equivalent. • If two rules, neither of which is RE-equivalent to an abolishing rule, are SE-equivalent, then they are\nRE-equivalent.\n• A rule is RE-tautological if and only if it is SE-tautological.\nProof. See Appendix A, page 35.\nThe affinity between SE-models and stable models is fully retained by RE-models, which establishes requirement 3).\nProposition 10 (RE-Models vs. Stable Models). An interpretation J is a stable model of a program P if and only if (J, J) ∈ [[P ]]RE and for all I ( J , (I, J) /∈ [[P ]]RE.\nProof. See Appendix A, page 35.\nAlso worth noting is that any set of three-valued interpretations can be expressed by a program using RE-models. This is not the case with SE-models since only well-defined sets of three-valued interpretations have corresponding programs.\nProposition 11. For anyM⊆ X there exists a program P such that [[P ]]RE =M.\nProof. See Appendix A, page 35.\nFurther properties of RE-models, analogous to those established in [65] for SE-models, can be found in Appendix A starting on page 31.\nSince RE-models are able to distinguish constraints from abolishing rules while keeping the essential properties of SE-models, we henceforth adopt them as the basis for defining syntax-independent rule update operators. We denote the set of sets of RE-models of rules inside a program P by 〈〈P〉〉RE = { [[π ]]RE | π ∈ P }. We also introduce three additional notions of program equivalence: RE-, RR- and RMR-equivalence that are analogous to SE-, SR- and SMR-equivalence.\nDefinition 12 (Program Equivalence Using RE-Models). Let P,Q be programs, Pτ = P ∪ { τ }, Qτ = Q∪ { τ }. We write\nP ≡RE Q whenever [[P ]]RE = [[Q ]]RE ; P ≡RMR Q whenever min〈〈Pτ 〉〉RE = min〈〈Qτ 〉〉RE ; P ≡RR Q whenever 〈〈Pτ 〉〉RE = 〈〈Qτ 〉〉RE .\nIn order to consider belief update principles in the context of rule updates, we also need to establish notions of program entailment which are in line with the above defined program equivalence relations. This task is troublesome in case of SM-equivalence because the usage of entailment in belief update postulates is clearly a monotonic one while stable models are non-monotonic. For instance, a reformulation of (B1) would require that P ⊕ U |= U , though there is no reason for P ⊕ U to have less stable models than (or the same as) U . Due to these issues, we refrain from defining SM-entailment. The remaining entailment relations are defined as follows:\nDefinition 13 (Program Entailment). Let P,Q be programs, Pτ = P∪{ τ } andQτ = Q∪{ τ }. We write\nP |=SE Q whenever [[P ]]SE ⊆ [[Q ]]SE ; P |=SMR Q whenever ∀σ ∈ Qτ ∃π ∈ Pτ : [[π ]]SE ⊆ [[σ ]]SE ; P |=RE Q whenever [[P ]]RE ⊆ [[Q ]]RE ; P |=RMR Q whenever ∀σ ∈ Qτ ∃π ∈ Pτ : [[π ]]RE ⊆ [[σ ]]RE ; P |=SU Q whenever [[Q \\ P ]]SE = X ; P |=SR Q whenever ∀σ ∈ Qτ ∃π ∈ Pτ : [[π ]]SE = [[σ ]]SE ;\nP |=RR Q whenever ∀σ ∈ Qτ ∃π ∈ Pτ : [[π ]]RE = [[σ ]]RE .\nWe say that P X-entails Q if P |=X Q.\nAs the following proposition shows, the defined entailment relations are fully in line with the corresponding equivalence relations.\nProposition 14. Let X be one of SE, RE, SMR, RMR, SR, RR, SU and P, Q be programs. Then, P ≡X Q if and only if P |=X Q and Q |=X P.\nProof. See Appendix A, page 35.\nNote that it follows directly from the previous considerations that RR-equivalence is stronger than SR-equivalence, RMR-equivalence is stronger than SMR-equivalence and RE-equivalence is stronger than SE-equivalence. Figure 1 illustrates the strength comparison of all eight notions of program equivalence which are formally stated in Proposition 5 and in the following result:\nProposition 15. The following holds:\n(1) ≡SM≺≡SE≺≡RE≺≡RMR≺≡RR≺≡SU and |=SE≺ |=RE≺ |=RMR≺ |=RR≺ |=SU ; (2) ≡SE≺≡SMR≺≡SR≺≡RR and |=SE≺ |=SMR≺ |=SR≺ |=RR ; (3) ≡SMR≺≡RMR and |=SMR≺ |=RMR ; (4) ≡RE ≡SMR and ≡SMR ≡RE and |=RE |=SMR and |=SMR |=RE ; (5) ≡RE ≡SR and ≡SR ≡RE and |=RE |=SR and |=SR |=RE ; (6) ≡RMR ≡SR and ≡SR ≡RMR and |=RMR |=SR and |=SR |=RMR .\nProof. See Appendix A, page 36."
    }, {
      "heading" : "4. Exception-Based Rule Update Operators",
      "text" : "In this section we propose a generic scheme for specifying semantic rule update operators. We define instances of the scheme and show that they enjoy a number of plausible properties, ranging from the respect for support and fact update to syntax-independence and other semantic properties.\nAs suggested already, a program is semantically characterised by the set of sets of RE-models of its rules. Our update framework is based on a simple yet novel idea of introducing additional interpretations – exceptions – to the sets of RE-models of rules in the original program. The formalisation of this idea is straightforward: an exception-based update operator is characterised by an exception function ε that takes three inputs: the set of RE-models [[π ]]RE of a rule π ∈ P and the semantic characterisations 〈〈P〉〉RE, 〈〈U〉〉RE of the original and updating programs. Then it returns the interpretations that are to be introduced as exceptions to π, so the characterisation of the updated program contains the augmented set of RE-models\n[[π ]]RE ∪ ε ([[π ]]RE, 〈〈P〉〉RE, 〈〈U〉〉RE) . (4)\nHence, the semantic characterisation of P updated by U is\n{ [[π ]]RE ∪ ε ([[π ]]RE, 〈〈P〉〉RE, 〈〈U〉〉RE) | π ∈ P } ∪ 〈〈U〉〉RE . (5)\nIn other words, rules from P are augmented with the respective exceptions and rules in U remain untouched. From the syntactic viewpoint, we want a rule update operator ⊕ to return a program P ⊕ U with the\nsemantic characterisation (5). This brings us to the following issue: What if no rule exists whose set of RE-models is equal to (4)? In that case, no rule corresponds to the augmented set of RE-models of a rule π ∈ P, so the program P ⊕ U cannot be constructed. Moreover, such situations may occur quite frequently since a single rule has very limited expressivity. For instance, updating the fact (p.) by the rule (∼ p ← q, r.) may easily result in a set of RE-models expressible by the program { p← ∼ q., p← ∼ r. } but not expressible by any single rule. To keep a firm link to operations on syntactic objects, we henceforth deal with this problem by allowing the inputs and output of rule update operators to be sets of rules and programs, which we dub rule bases.8 In other words, the result of updating a rule, i.e. introducing exceptions to it, may be a set of rules, so the result of updating a program may be a rule base. Technically, a rule base can capture any possible result of an exception-based update due to Proposition 11.\nFormally, a rule base is any set of rules and programs. Given a rule baseR, an interpretation J is a model of R, denoted by J |= R, if J |= Π for all Π ∈ R; RJ = { ΠJ ∣∣ Π ∈ R }; the set of stable models of R\n8We allow for individual rules in a rule base out of convenience only. A single rule π in a rule base R is treated exactly the same way as ifR contained the singleton program {π }.\nconsists of all interpretations J such that J is a subset-minimal model ofRJ ; 〈〈R〉〉SE = { [[Π]]SE | Π ∈ R } and [[R ]]SE = ⋂ 〈〈R〉〉SE; 〈〈R〉〉RE = { [[Π]]RE | Π ∈ R } and [[R ]]RE = ⋂ 〈〈R〉〉RE. All notions of program equivalence and entailment are naturally extended to rule bases and any rule update operator⊕ is generalised to sequences of rule bases 〈Ri〉i<n as follows: ⊕ 〈〉 = ∅ and ⊕ 〈Ri〉i<n+1 = ( ⊕ 〈Ri〉i<n)⊕Rn.\nNote that a program is a special case of a rule base. Each element Π of a rule base, be it a rule or a program, represents an atomic piece of information and exception-based update operators view and manipulate Π only through its set of RE-models [[Π]]RE. Due to this, we refer to all such elements Π as rules, even if formally they may actually be programs.\nHaving resolved this issue, we can proceed to the definition of an exception-based rule update operator.\nDefinition 16 (Exception-Based Rule Update Operator). Given an exception function ε, a rule update operator ⊕ is ε-based if for all rule basesR, U , 〈〈R ⊕ U〉〉RE is equal to (5). Also, ⊕ is exception-based if it is ε-based for some exception function ε.\nNote that for each exception function ε there is a whole class of ε-based rule update operators that differ in the syntactic representations of the sets of RE-models in (5). For instance, when working over the set of propositional symbols A = { p, q } and considering some exception-based operator ⊕, the exception function may specify that for some programs P, U , the program P ⊕ U contains a rule or program representing the set of RE-modelsM = { (∅, ∅), (∅, p), (p, p), (∅, q), (∅, pq), (p, pq), (pq, pq) }.9 This set can be represented by the rule π = (p ← q.) or, alternatively, by the rule σ = (p;∼ q ← q.), or even by the program Q = { (p← q.), (p← p,∼ q.) }, and the exception function does not specify which syntactic representation of the set should be used in P ⊕ U .\n4.1. Simple Exception Functions and Their Syntactic Properties\nGeneral exception functions, as introduced above, have as inputs the entire semantic characterisations of the original as well as updating programs (〈〈P〉〉RE and 〈〈U〉〉RE, respectively) when determining exceptions to any single rule. As it turns out, all this information is not strictly necessary in order to capture rule update operators enjoying a range of plausible syntactic as well as semantic properties.\nThus, further study of general exception functions is left for future research and in this paper we concentrate on a simpler, constrained class of exception functions that is nevertheless powerful enough to serve as a basis for well-behaved semantic rule update operators. Not only does this lead to simpler definitions, but the study of restricted classes of exception functions is essential in order to understand their expressivity, i.e. the types of update operators they are able to capture.\nMore particularly, we study exception functions that produce exceptions based on conflicts between pairs of rules, one from the original and one from the updating program, while ignoring the context in which these rules are situated. Formally, an exception function ε is simple if for allM⊆ X and S, T ⊆ 2X,\nε(M,S, T ) = ⋃ N∈T δ(M,N )\nwhere δ : 2X × 2X → 2X is a local exception function. If ⊕ is an ε-based rule update operator, then we also say that ⊕ is δ-based and that ⊕ is simple.\nAs we shall see, in spite of their local nature, particular simple exception functions generate rule update operators that satisfy the syntactic properties laid out in Section 2 and are closely related to the JU- and UA-semantics for DLPs.\n9Sometimes we omit the usual set notation when we write interpretations, e.g. instead of { p, q } we may simply write pq.\nThe inspiration for defining concrete local exception functions δ comes from rule update semantics based on causal rejection. But since the relevant concepts, such as that of a conflict or rule rejection, rely on rule syntax to which an exception function has no direct access, our first objective is to find similar concepts on the semantic level. In particular, we need to define conditions under which two sets of RE-models are in conflict. But first we introduce two preparatory concepts.\nWe define a truth value substitution as follows: Given an interpretation J , an atom p and a truth value V ∈ {T,U,F }, by J [V/p] we denote the three-valued interpretation X such that X(p) = V and X(q) = J(q) for all atoms q 6= p.\nThis enables us to introduce the main concept needed for defining a conflict between two sets of threevalued interpretations. Given a set of three-valued interpretations M, an atom p, a truth value V0 and a two-valued interpretation J , we say that M forces p to have the truth value V0 w.r.t. J , denoted by MJ(p) = V0, if\nJ [V/p] ∈M if and only if V = V0 .\nIn other words, the three-valued interpretation J [V0/p] must be the unique member ofM that either coincides with J or differs from it only in the truth value of p. Note thatMJ(p) stays undefined in case no V0 with the above property exists.\nTwo sets of three-valued interpretationsM, N are in conflict on atom p w.r.t. J , denoted byM 1Jp N , if bothMJ(p) and N J(p) are defined andMJ(p) 6= N J(p). The following example illustrates all these concepts.\nExample 17. Consider rules π = (p.), σ = (∼ p← ∼ q.) with the respective sets of RE-models\nM = { (p, p), (p, pq), (pq, pq) } and N = { (∅, ∅), (∅, q), (q, q), (∅, pq), (p, pq), (q, pq), (pq, pq) } .\nIntuitively, M forces p to T w.r.t. all interpretations and N forces p to F w.r.t. interpretations in which q is false. Formally it follows that M∅(p) = T because (p, p) belongs to M and neither (∅, p) nor (∅, ∅) belongs toM. Similarly, it follows that N ∅(p) = F. HenceM 1∅p N . Using similar arguments we can conclude thatM 1pp N . However, it does not hold thatM 1pqp N because N pq(p) is undefined.\nIn order to define a particular local exception function based on causal rejection, it only remains to decide which three-valued interpretations become exceptions when a conflict w.r.t. an interpretation J occurs. One intuition we can draw on is the relationship between RE-models and stable models (c.f. Proposition 10): J is a stable model of a program if and only if (J, J) is the unique RE-model of the program whose second component is J . So given an original rule π with M = [[π ]]RE and an updating rule σ with N = [[σ ]]RE where a conflict occurs between M and N w.r.t. J , π needs to be weakened so that it cannot influence whether J becomes a stable model of the updated program or not. In other words, we need to introduce all three-valued interpretations whose second component is J as exceptions to that rule. Formally:\nDefinition 18 (Exception Function δa). The local exception function δa is for allM,N ⊆ X defined by:\nδa(M,N ) = { (I, J) ∈ X ∣∣ ∃p :M 1Jp N } .\nTheorem 19 (Syntactic Properties of δa). Every δa-based rule update operator respects support and fact update and it also respects causal rejection and acyclic justified update w.r.t. DLPs of length at most two.\nProof. See Appendix B, page 43.\nThis means that δa-based rule update operators enjoy a combination of desirable syntactic properties that operators based on SE-models cannot [69]. However, these operators diverge from causal rejection, even on acyclic DLPs, when more than one update is performed.\nExample 20. Consider again the rules π, σ and their sets of RE-modelsM,N from Example 17 and some δa-based rule update operator ⊕. Then 〈〈{π } ⊕ {σ }〉〉RE will contain two elements, M′ and N , where M′ =M∪ δa(M,N ) =M∪{ (∅, ∅), (∅, p), (p, p) }. An additional update by the fact { q. } then leads to the characterisation 〈〈 ⊕ 〈{π } , {σ } , { q. }〉〉〉RE which contains three elements: M′′, N and [[q. ]]RE where M′′ = M′ ∪ { (∅, q), (q, q) }. Furthermore, due to Proposition 10, J = { q } is a stable model of the program ⊕ 〈{π } , {σ } , { q. }〉 because (q, q) belongs to [[ ⊕ 〈{π } , {σ } , { q. }〉 ]]RE and (∅, q) does not. However, J does not respect causal rejection and it is neither a JU- nor a UA-model of 〈{π } , {σ } , { q. }〉.\nThis shortcoming of δa largely stems from the asymmetry of its definition – when a conflict occurs w.r.t. J , atoms that are true in J may become undefined in an exception (I, J) but atoms that are false must remain false. Eliminating this asymmetry, by allowing for exceptions (I,K) with I ⊆ J ⊆ K, and choosing the introduced exceptions more carefully, leads to more well-behaved exception functions, defined as follows:\nDefinition 21 (Exception Functions δb, δc, δd and δe). The local exception functions δb, δc, δd and δe are for allM,N ⊆ X defined by:\nδb(M,N ) = { (I,K) ∈ X | ∃J ∃p :M 1Jp N ∧ I ⊆ J ⊆ K ∧ (p ∈ K \\ I ⇒ K = J) } ,\nδc(M,N ) = { (I,K) ∈ X | ∃J ∃p :M 1Jp N ∧ I ⊆ J ⊆ K ∧ (p ∈ K \\ I ⇒ K = J ∧ (J, J) /∈M) } ,\nδd(M,N ) = { X ifM = N ; δb(M,N ) otherwise ,\nδe(M,N ) = { X ifM = N ; δc(M,N ) otherwise .\nThe functions δb and δd introduce more exceptions than δa while δc and δe eliminate some of those returned by δa and add some additional ones. The difference between δb and δd, and similarly also between δc and δe, is in that δd additionally “wipes out” rules from the original program that are repeated in the update by introducing all interpretations as exceptions to them, rendering them tautological. This will turn out to be significant later when we examine semantic properties of simple exception-based rule update operators. In all four functions, a conflict on p w.r.t. J leads to the introduction of interpretations in which atoms either maintain the truth value they had in J , or they become undefined. Additionally, extra conditions are imposed on the case when p becomes undefined. Interestingly, this leads to operators that satisfy all syntactic properties.\nTheorem 22 (Syntactic Properties of δb, δc, δd and δe). Let ⊕ be a δb-, δc-, δd- or δe-based rule update operator. Then ⊕ respects support, fact update, causal rejection and acyclic justified update.\nProof. See Appendix B, page 47.\nFurthermore, it is worth noting that even on programs with cycles, δb- and δd-based operators are very closely related to the JU-semantics and, similarly, δc- and δe-based operators to the UA-semantics. They diverge from the syntax-based semantics only on rules with an appearance of the same atom in both the head and body. Formally, we say that a rule is a local cycle if (H+π ∪ H−π ) ∩ (B+π ∪ B−π ) 6= ∅.\nTheorem 23 (Characterisation of JU- and UA-Semantics Using Exception Functions). Let P be a DLP, J an interpretation,⊕1 a δb- or δd-based rule update operator and⊕2 a δc- or δe-based rule update operator. Then,\n• [[ ⊕ 1 P ]]SM ⊆ [[P ]]JU and [[ ⊕ 2 P ]]SM ⊆ [[P ]]UA;\n• if all(P ) contains no local cycles, then [[P ]]JU ⊆ [[ ⊕ 1 P ]]SM and [[P ]]UA ⊆ [[ ⊕ 2 P ]]SM.\nProof. See Appendix B, page 47.\nThis means that up to the marginal case of local cycles, δb and δd can be seen as semantic characterisations of the JU-semantics and, similarly, δc and δe characterise the UA-semantics. The exceptional cases when less stable models are found than using the traditional semantics occur when the DLP contains tautological rules or rules with the negation of their head in the body. The former can be seen as a strict improvement as it introduces immunity to tautologies. The latter is an unavoidable consequence of the fact that exception-based operators only manipulate RE-models which are unable to distinguish between a constraint (← p.) and a rule (∼ p← p.) The traditional approaches do distinguish between them in that the former rule can never be rejected while the latter can.\nThis tight relationship also sheds new light on the problem of state condensing, discussed in more detail in Section 5.\n4.2. Semantic Properties We proceed by examining further properties of rule update operators – of those based on simple excep-\ntion functions in general, and of the δa-, δb-, δc-, δd- and δe-based ones in particular. The properties we consider in this section are semantic in that they put conditions on the models of a result of an update and do not need to refer to the syntax of the original and updating programs. Our results are summarised in Table 2 and in the following we explain and discuss them. The interested reader may find all the proofs in Appendix B.5 starting on page 48.\nTraditional Semantic Properties of Rule Updates The properties in the upper part of Table 2 were introduced in [5, 20, 24]. We formalise all of them for rule basesR, S, U , V and a rule update operator ⊕ and each can actually be seen as a meta-property that is instantiated once we adopt a particular notion of program equivalence. Therefore, each row of Table 2 has eight cells that stand for particular instantiations of the property. This provides a more complete picture of how simple rule update operators, properties and program equivalence are interrelated.\nUnless stated otherwise (in a footnote), each tick (3) signifies that the property in question holds for all simple rule update operators. A missing tick signifies that the property does not generally hold for simple rule update operators, and in particular there are δa-, δb-, δc-, δd- and δe-based operators for which it is violated. A tick is smaller if it is a direct consequence of a preceding larger tick in the same row and of the interrelations between the program equivalence and entailment relations (c.f. Figure 1).\nAt a first glance, it is obvious that none of the semantic properties is satisfied under SU-equivalence. This is because the conditions placed on a rule update operator by an exception function are at the semantic level, while SU-equivalence effectively compares programs syntactically. For instance, an exception-based operator ⊕, for any exception function ε, may behave as follows: ∅ ⊕ {∼ p← p. } = {← p. }. This is because the rules before and after update are RE-equivalent. However, due to the fact that the programs {∼ p← p. } and {← p. } are considered different under SU-equivalence, ⊕ cannot satisfy (Initialisation) w.r.t. SU-equivalence. The situation with all other properties is analogous.\nAs for the other notions of equivalence, we separately discuss each group of related properties:\n(Initialisation) and (Disjointness): These properties are satisfied “by construction”, regardless of which simple rule update operator we consider and of which notion of equivalence we pick.\n18\n(Tautology) and (Immunity to Tautologies): These are naturally satisfied by all simple update operators that do not introduce exceptions merely due to the presence of a tautological rule in the updating program. In particular, both properties are satisfied by δa-, δb-, δc-, δd- and δe-based operators. Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].\n(Non-interference): This property is satisfied by δa-, δb-, δc-, δd- and δe-based rule update operators. However, this is only the case when non-disjunctive programs are considered, pointing towards one of the important open problems faced by state-of-the-art research on rule updates: examples, desirable properties and methods for updating disjunctive programs. Insights in this direction should shed light on whether (Non-interference) is desirable in the disjunctive case.\n(Idempotence), (Absorption) and (Augmentation): These are the only properties that reveal differences amongst the different exception functions. They are not satisfied by δa-, δb- and δc-based operators under SR- and RR-equivalence because a program updated by its subset may contain weakened versions of the original rules. Since such rules are not part of the original program, the programs before and after update are considered to be different under SR- and RR-equivalence. This problem is dodged in δd and δe by completely obliterating original rules that appear in the update.\nThis also indicates that SR- and RR-equivalence are slightly too strong for characterising updates because programs such as { p. } and { p., p← q. } are not considered equivalent even though we expect the same behaviour from them when they are updated. We speculated in Section 3 that it might be possible to address this issue by adopting the weaker SMR- or RMR-equivalence. However, it turns out that due to the monotonic nature of SE- and RE-models, these equivalence relations are too weak: programs such as { p. } and { p., q ← ∼ p. } are SMR- and RMR-equivalent but, when updated by {∼ p. }, any rule update operator respecting fact update and causal rejection must provide the stable model ∅ in the former case, which violates causal rejection in the latter case. Moreover, δa-based operators fail to satisfy (Absorption) and (Augmentation). Along with Example 20, this indicates that δa does not correctly handle iterated updates.\n(Associativity): This is one of the few properties that is not satisfied by any of the defined classes of operators. It is closely related to the question of whether rejected rules are allowed to reject. (Associativity) can be seen as postulating that an update operator must behave the same way regardless of whether rejected rules are allowed to reject or not. As witnessed by the JU- and UA-semantics (c.f. equation 2), rule update semantics tend to generate unwanted models when rejected rules are not allowed to reject.\nBelief Update Postulates Reformulated The lower part of Table 2 contains a reformulation of the belief update postulates (B1) – (B6) for rule\nbases. We omit the last two postulates as they require program disjunction and it is not clear how to obtain it appropriately. Note also that (B7) has been heavily criticised in the literature as being mainly a means to achieve formal results instead of an intuitive principle [34] and though (B8) reflects the basic intuition behind belief update – that of updating each model independently of the others – such a point of view is hardly transferable to knowledge represented using rules because a single model, be it a classical, stable, SE- or RE-model, fails to encode the interdependencies between literals expressed in rules that are necessary for properties such as support.\nSince we did not define SM-entailment, postulates that refer to it have the SM column marked as “n/a”. Now we turn to the individual postulates.\n(P1) and (P2.>): Similarly as (Initialisation) and (Disjointness), these postulates are satisfied by any simple rule update operator and under all notions of equivalence.\n(P2.1) and (P5): Postulate (P2.1) is not satisfied under SR- and RR-equivalence for the same reasons, described above, that prevent δa- and δb-based operators from satisfying (Idempotence). The situation with (P5) is the same since it implies (P2.1) in the presence of (P2.>) [34].\n(P2.2) and (P6): Postulate (P2.2) requires that { p.,∼ p. } ⊕ {∼ p. } |= p which, in the presence of (P1), amounts to postulating that one can never recover from an inconsistent state, contrary to most existing rule update semantics which do allow for recovery from such states. The case of (P6) is the same since it implies (P2.2) in the presence of (P1) and (P2.>) [34].\n(P3): This postulate relies on a function that returns the set of models of a rule base. Thus, [[ · ]]SM, [[ · ]]SE and [[ · ]]RE can be used for this purpose and the other columns in the corresponding row in Table 2 make little sense, so they are marked as “n/a”. Furthermore, this postulate is not satisfied by any of the defined classes of exception-based operators. It is also one of the principles that most existing approaches to rule update chronically fail to satisfy. In order to satisfy it, a context-aware exception function would have to be used because conflicts may arise in a set of more than two rules that are pairwise consistent. For instance, when updating { p. } by { q ← p.,∼ q ← p. }, one would somehow need to detect and resolve the joint conflict between these three rules. This is however impossible with a simple exception function because it only considers conflicts between pairs of rules, one from the original program and one from the update.\n(P4): This postulate requires update operators to be syntax-independent. In this context it is useful to consider the following weaker principles:\n(P4.1) If P ≡ Q, then P U ≡ Q U . (P4.2) If U ≡ V , then P U ≡ P V .\nThe failure to satisfy (P4.1) under SM-, SE-, RE-, SMR- and RMR-equivalence is inevitable if properties such as support, fact update and causal rejection are to be respected (c.f. [69] and the above discussion of (Idempotence), (Absorption) and (Augmentation)). Furthermore, (P4.1) is also violated under SR-equivalence due to the fact that a constraint such as (← p.) cannot be weakened by the introduced exception functions while the fact (∼ p.) can, although it is strongly equivalent to the constraint.\nSimilar arguments can be used to show that the principle (P4.2) is not satisfied under SM-, SE-, RE, SMR- and RMR-equivalence. We only need to observe that any δa-, δb-, δc-, δd- or δe-based operator ⊕ satisfies ∅ ⊕ P ≡RR P, so each example used to show that (P4.1) is not desirable, involving two updates P1 ⊕ U and P2 ⊕ U , can be reused to show the same for (P4.2) by instead considering the updates ∅⊕P1⊕U and ∅⊕P1⊕U . Additionally, (P4.2) is not satisfied under SR-equivalence due to the fact that updates such as {∼ p← q. }, {∼ q ← p. } and {← p, q. } have different effects on the program { p., q. }. These observations indicate that (P4.1) and (P4.2), and thus also (P4), are too strong under SM-, SE-, RE-, SMR- and RMR-equivalence. Under SR-equivalence, they are incompatible with operators that solve conflicts based on the heads of rules. On the other hand, due to the semantic underpinning of simple rule update operators, (P4) is satisfied by most of them, including all δa-, δb-, δc-, δd- and δe-based ones, under RR-equivalence.\nSummary The results in Table 2 indicate that simple rule update operators satisfy a number of essential semantic\nproperties by design. This is especially important for properties such as (Tautology), (Immunity to Tautolo-\ngies) and (P2.>), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].\nSome of the semantic properties, namely (Idempotence), (Absorption) and (Augmentation), outline the main differences between the particular local exception functions that we have defined. Although δais the function with the simplest definition, it does not satisfy any of these properties, indicating that it cannot deal well with iterated updates.\nOur results also show that a number of KM postulates are not satisfied by the defined rule update operators. Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].\nPerhaps most importantly, Table 2 introduces a novel way of viewing the various semantic properties, where each property is parametrised by a particular notion of program equivalence and/or entailment. This richer view should prove useful in further research on rule update operators and their semantic properties."
    }, {
      "heading" : "5. State Condensing",
      "text" : "Our results about semantic rule update operators bring along a new point of view on traditional approaches to rule updates. Particularly interesting is the fact that a semantic rule update operator, following the belief update tradition, is a binary function on the set of programs over the same alphabet. This guarantees that after an update, the original program is replaced by a new program which continues to be used in its place, and the process can be easily iterated if the need arises. Even though this perspective is very natural, even fundamental, it has been largely neglected in the ample body of work on rule updates. Existing semantics typically proceed by characterising the models of the update and, at most, either describe a set of answer-set programs that could represent the update, instead of only one, or produce an answer-set program written in a language extended with a considerable amount of new atoms, making it difficult to understand and to further update.\nFor instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture. Consequently, they must resort to the introduction of additional meta-level atoms in order to construct a single program whose stable models correspond to the models assigned to the sequence, leading to difficulties with iterating the update process. Producing a program from a more expressive class of logic programs would result in the inability to perform another update as well because the update semantics are not defined for such programs.\nA different approach in [60] deals with program updates by borrowing ideas from literature on belief revision and utilising an abductive framework to accomplish such updates. In this case, multiple alternative programs can be the result of an update and no mechanism is provided to choose among them.\nA somewhat similar situation occurs with the approach of [75] where intricate syntactic transformations are combined with a semantics for prioritised logic programs that ultimately leads to a set of logic programs. Since all of these programs together represent the result of the update, it is once again unclear how to construct a single program that combines all of them.\nThe rule update semantics suggested in [20] are also based on syntactic transformations into a logic program with preferences among rules, but in contrast with [75], the semantics of such programs is defined by directly specifying their preferred stable models and not by translation into an ordinary program (or a set thereof). Thus, although an actual syntactic object is constructed that represents the update, it needs to be interpreted in a richer formalism to take into account preferences among rules.\nFinally, frameworks that specify program updates by manipulating dependencies on default assumptions induced by rules [46, 61, 62] are mainly concerned with identifying the effects of irrelevant updates and\nother theoretical properties of the stable models assigned to a pair or sequence of programs. They do not consider representing the result of an update by a single program.\nIn this section, we unravel the true potential of specifying updates as binary operators on some class of programs. Despite the fact that existing program update semantics do not seem compatible with this point of view, we show that at least the foundational JU- and UA-semantics can be viewed in this manner.\nTheorem 23 already provides part of the solution as it shows that any DLP can be condensed into a single rule base over the same alphabet that behaves just as the original DLP when further updates are performed on it. Formally, this can be stated as follows:\nCorollary 24 (State Condensing into a Rule Base). There exist rule update operators ⊕1 and ⊕2 such that for every DLP P = 〈Pi〉i<n without local cycles and all j < n there exist rule basesR1 andR2 with\n[[P ]]JU = [[ ⊕ 1〈R1,Pj+1, . . . ,Pn−1〉 ]]SM and [[P ]]UA = [[ ⊕ 2〈R2,Pj+1, . . . ,Pn−1〉 ]]SM .\nProof. See Appendix B, page 47.\nHowever, this result is not completely satisfactory since it relies on rule bases instead of standard classes of logic programs, does not provide explicit definitions of operators⊕1 and⊕2, and does not apply to DLPs with local cycles.\nIn the following, we address all these issues by defining specific rule update operators that faithfully characterise the JU- and UA-semantics – when applied to an arbitrary DLP P , they produce a program whose stable models coincide with JU- and UA-models of P , respectively. In this way, the new operators provide a way to condense any DLP into a single program that includes all relevant information about the DLP, not only to identify its stable models, but also for the purpose of performing further updates. Thereby, we solve the long-standing problem known as state condensing from the literature on causal rejection semantics for rule updates.\nTo achieve this, our operators must deal with a more general class of programs than non-disjunctive ones. First we define simple and elegant operators on subclasses of nested logic programs [71] with the required property. Subsequently, we show that the full expressivity of nested programs is not necessary for this purpose by defining an additional pair of operators that produce disjunctive logic programs and still maintain the same properties w.r.t. JU- and UA-semantics.\nThroughout this section we assume that all programs are finite. We also assume that all non-disjunctive rules π, originating in some DLP, have exactly one literal L in their heads. This latter assumption does not remove any significant expressivity from DLPs under the JU- and UA-semantics since each constraint (← Bπ.) can be equivalently encoded as the rule (p⊥ ← ∼ p⊥,Bπ.) where p⊥ is a fresh atom designated for this purpose.\n5.1. Programs with Nested Expressions\nWe adopt the syntax and stable model semantics of logic programs with nested expressions [71]. A nested rule is an expression π of the form (Hπ ← Bπ.) where Hπ and Bπ, called the head and body of π, are expressions built inductively from the propositional atoms in A and the 0-place connectives ⊥ and > using the unary connective ∼ (default negation) and the binary connectives ∧ and ∨.10 A nested rule of the form (Hπ ← >.) is usually identified with the formula Hπ. A nested program is a finite set of nested rules.\n10Within this section, we refer to such expressions simply as formulas even though they are different from the propositional formulas introduced in Section 2.\nEach disjunctive program P and DLP P = 〈Pi〉i<n, as defined in Section 2, is translated, respectively, to a nested program and a sequence thereof as follows:\nP} = {∨ Hπ ← ∧ Bπ. ∣∣∣ π ∈ P } and P} = 〈P}i 〉i<n .\nSatisfaction of a formula φ in an interpretation J , denoted by J |= φ, is defined in the usual way. Furthermore, J satisfies a nested rule π, denoted by J |= π, if J |= Bπ implies J |= Hπ, and J satisfies a nested program P, denoted by J |= P, if J |= π for all π ∈ P. The reduct of a formula φ relative to J , denoted by φJ , is obtained by replacing, in φ, every maximal occurrence of a formula of the form ∼ψ with ⊥ if J |= ψ and with > otherwise. The reducts of a nested rule π and of a nested program P are, respectively, πJ = (HJπ ← BJπ .) and PJ = {πJ | π ∈ P }. Finally, an interpretation J is a stable model of a nested program P if it is subset-minimal among the interpretations that satisfy PJ .\n5.2. Condensing into a Nested Program\nNow we can proceed with the definition of condensing operators ⊕JU and ⊕UA for the JU- and UA-semantics. The property that these operators must fulfill is that for any DLP P , the stable models of the nested program resulting from applying the operators to P are exactly the JU- and UA-models of P , respectively.\nBoth ⊕JU and ⊕UA are defined by utilising the concept of an activation formula which captures the condition under which a literal L is derived by some rule in a nested program U . Formally, the activation formula for L in U is defined as follows:\nαU (L) = ∨{∧ Bπ ∣∣∣ π ∈ U ∧ Hπ = L } .11\nThe operator ⊕JU is based on the following simple idea: When updating a program P by a program U , each rule π from P with literal L in its head must be disabled when some rule from U for the literal complementary to L is activated. This can be achieved by augmenting the body of π with the additional condition ∼αU ( L ) . Formally:\nDefinition 25 (Condensing Operator ⊕JU). A JU-rule is a nested rule with a single literal in its head and a JU-program is a nested program that consists of JU-rules.\nThe binary operator ⊕JU on the set of all JU-programs is defined as follows: Given two JU-programs P and U , the JU-program P ⊕JU U consists of the following rules:\n1. for all π ∈ P, the nested rule ( Hπ ← Bπ ∧ ∼αU ( Hπ ) . ) ;\n2. all nested rules from U .\nIn case of the UA-semantics, additional choice rules are needed. Particularly, for every nested rule π ∈ all(P )} whose head is an atom, the update operator needs to include the nested rule (Hπ ∨ Hπ ← Bπ.) in the resulting program. Intuitively, these additional rules account for the differences in the definition of rejJU(P , J) and rejUA(P , J) by making sure that no rule is ever completely eliminated, but stays partially in effect by generating alternative worlds for the atom in its head: one where it is satisfied and one where it is not. Essentially, this means that whenever the original body of the rule is satisfied, its head atom cannot be assumed false by default and is interpreted “classically” instead.\n11Note that ∨ ∅ is simply ⊥.\nDefinition 26 (Condensing Operator ⊕UA). A UA-rule is a nested rule with either a single literal or a disjunction of two literals L and L in its head, and a UA-program is a nested program that consists of UA-rules.\nThe binary operator ⊕UA on the set of all UA-programs is defined as follows: Given two UA-programs P and U , the UA-program P ⊕UA U consists of the following rules:\n1. for all π ∈ P with Hπ ∈ L, the nested rule ( Hπ ← Bπ ∧ ∼αU ( Hπ ) . ) ;\n2. all π ∈ P such that Hπ is of the form L ∨ L; 3. for all π ∈ U with Hπ ∈ A, the nested rule ( Hπ ∨ Hπ ← Bπ. ) ;\n4. all nested rules from U .\nThe following example illustrates the relationship between the JU- and UA-semantics and the condensing operators ⊕JU and ⊕UA, while the subsequent theorem establishes it in general.\nExample 27. Suppose that programs P, U and V , written as nested programs, are as follows:\nP} : p← >. U} : ∼ p← ∼ q ∧ ∼ r. V} : p← s. q ← p. ∼ p← s. r ← r. r ← >. ∼ r ← >. s← >.\nIn addition to the rules from U}, the program ⊕\nJU 〈P},U}〉 contains the following three nested rules:\np← >∧∼((∼ q ∧ ∼ r) ∨ s). q ← p ∧ ∼⊥. r ← >∧∼>. (6) Also, the program ⊕\nUA 〈P},U}〉 consists of the rules in ⊕ JU 〈P},U}〉 and of three additional choice rules.\nNote that these rules are not part of the program P} ⊕UA U}. They belong to the program ∅ ⊕UA P}, and, consequently, also to (∅ ⊕UA P})⊕UA U} = ⊕ UA 〈P},U}〉. They are as follows:\np ∨ ∼ p← >. q ∨ ∼ q ← p. r ∨ ∼ r ← >. (7) Furthermore, both ⊕\nJU 〈P},U}〉 and ⊕ UA 〈P},U}〉 have the stable models ∅ and { p, q } which coincide\nwith the JU- and UA-models of the DLP 〈P,U〉. The situation is more interesting after V} is added to the update sequence. In addition to the rules from\nV}, the program ⊕\nJU 〈P},U},V}〉 contains the following rules:\np← >∧∼((∼ q ∧ ∼ r) ∨ s) ∧ ∼⊥. q ← p ∧ ∼⊥ ∧ ∼⊥. r ← >∧∼> ∧∼⊥. ∼ p← ∼ q ∧ ∼ r ∧ ∼ s. ∼ p← s ∧ ∼ s. ∼ r ← >∧∼ r.\nAlso, the program ⊕\nUA 〈P},U},V}〉 consists of the rules in ⊕ JU 〈P},U},V}〉, the three choice rules\nlisted in (7) and, additionally, the following three choice rules rules originating in V}:\np ∨ ∼ p← s. r ∨ ∼ r ← r. s ∨ ∼ s← >.\nNote that some body conjuncts, such as ∼⊥, and even whole rules, for instance (∼ p ← s ∧ ∼ s.), can can be eliminated from the resulting programs without affecting their stable models or the stable models resulting from further updates. Slightly less elegant definitions of ⊕JU and ⊕UA could be used to perform such simplifications automatically. For illustration, Figure 2 lists the simplified versions of the nested programs ⊕ JU 〈P},U},V}〉 and ⊕ UA 〈P},U},V}〉. It is also not difficult to verify that the unique stable model of the former program is { p, q, s }, which coincides with the unique JU-model of 〈P,U ,V〉. On the other hand, due to the rule (r ∨ ∼ r ← >.), the latter program has the additional stable model { p, q, r, s }, which coincides with the additional UA-model of the DLP 〈P,U ,V〉.\np← ∼((∼ q ∧ ∼ r) ∨ s). q ← p. ∼ p← ∼ q ∧ ∼ r ∧ ∼ s. p← s. s← >.\np← ∼((∼ q ∧ ∼ r) ∨ s). q ← p. ∼ p← ∼ q ∧ ∼ r ∧ ∼ s. p← s. s← >.\np ∨ ∼ p← >. q ∨ ∼ q ← p. r ∨ ∼ r ← >. s ∨ ∼ s← >.\nFigure 2: Nested programs\n⊕\nJU 〈P},U},V}〉 (left) and ⊕ UA 〈P},U},V}〉 (right) without irrelevant rules and body conjuncts.\nTheorem 28 (State Condensing Using ⊕JU and ⊕UA). Let P be a DLP. An interpretation J is a (i) JU-model of P if and only if it is a stable model of ⊕ JU P};\n(ii) UA-model of P if and only if it is a stable model of ⊕\nUA P}.\nProof. See Appendix C, page 55.\nThe significance of this theorem is in that it demonstrates that the operators ⊕JU and ⊕UA provide a full characterisation of the JU- and UA-semantics: They condense any DLP P into a single nested program P such that the stable models of P coincide with the JU- and UA-models of P , respectively, and any further updates of P can be equivalently performed directly on P using the operators.\nNote that since the operators manipulate rules on the syntactic level, they are completely faithful to JU- and UA-semantics, even when the DLP contains local cycles (see also Theorem 23 where local cycles form a special case due to the fact that exception functions manipulate rules on the semantic level).\nInterestingly, an operator very similar to ⊕JU has been studied by Osorio and Cuevas [55]. They have proven that it characterises the UA-semantics for the case of a single update but did not consider the possibility of performing iterated updates. Their result is also a consequence of Theorem 28 and of the fact that the JU- and UA-semantics provide the same result when only a single update is performed.\n5.3. Condensing into a Disjunctive Program The condensing operators defined in the previous section can be further refined in order to produce a\nprogram that meets additional requirements. In the present section we show that nested expressions can be completely eliminated from the resulting program while still preserving the same tight relationship with the original rule update semantics. Thus, we introduce an additional pair of operators, ⊕∨JU and ⊕∨UA, that operate on disjunctive programs with default negation in heads of rules. Note that due to the non-minimality of JU- and UA-models for certain DLPs, disjunctive programs without default negation in heads of rules would already be insufficient for this purpose.\nThe ideas underlying the new operators are fairly straightforward. Essentially, nested expressions are introduced into the resulting programs only by the negations of activation formulas in their bodies, so these are the parts of rules that need to be translated into conjunctions in bodies and disjunctions in heads of rules. In particular, by utilising De Morgan’s law and distributivity of conjunction over disjunction, we can obtain a new formula, a disjunction of conjunctions of default literals and double-negated atoms, that is strongly equivalent to the original formula. For instance, in case of the first rule in (6), we can equivalently write the condition ∼((∼ q ∧ ∼ r) ∨ s) as (∼∼ q ∧ ∼ s) ∨ (∼∼ r ∧ ∼ s). Then it suffices to break up the resulting rule into multiple rules, each with one of the disjuncts of this formula in the body, and remove one of the negations from each double-negated literals and “move” it into the head of the newly constructed rule. In case of the first rule in (6), the result would be the disjunctive rules\np ∨ ∼ q ← ∼ s. and p ∨ ∼ r ← ∼ s. (8)\nWe call each set of literals, without double negation, within each of the disjuncts described above a blocking set. Formally, if the activation formula αU}(L) contains > as one of its disjuncts, then there is no blocking set for L in U . Otherwise, suppose that αU}(L) = (L11 ∧ · · · ∧ L1k1) ∨ · · · ∨ (L n 1 ∧ · · · ∧ Lnkn). A\nblocking set for L in U is any set of literals { L1i1 , . . . , L n in } where 1 ≤ ij ≤ kj for every j with 1 ≤ j ≤ n. We denote the set of all blocking sets for L in U by βU (L). Each nested rule ( Hπ ← Bπ ∧ ∼αU} ( Hπ ) . )\ncan thus be replaced by the set of disjunctive rules{ Hπ;S+ ← Bπ, S−. ∣∣∣ S ∈ βU(Hπ) } . Furthermore, when Hπ is a default literal, it is more convenient to move the new default literals from the head into the body since this operation preserves stable models [38] and makes it easier to pinpoint the original head literal in the rule. This leads us to the following definition of ⊕∨JU:\nDefinition 29 (Condensing Operator ⊕∨JU). Given a disjunctive rule π, a literal L is the original head of π if either L ∈ A and Hπ ∩A = {L }, or L /∈ A and Hπ = {L }.\nThe binary operator ⊕∨JU on the set of all disjunctive programs is defined as follows: Given two disjunctive programs P and U , the disjunctive program P ⊕∨JU U consists of the following rules:\n1. for all π ∈ P with original head L ∈ A and all S ∈ βU (L), the rule ( Hπ;S+ ← Bπ, S−. ) ;\n2. for all π ∈ P with original head L /∈ A and all S ∈ βU (L), the rule ( Hπ ← Bπ, S+, S−. ) ;\n3. all rules from U .\nAs for the UA-semantics, similar modifications can be applied in the definition of ⊕UA to obtain an operator that produces a disjunctive program. Furthermore, due to the additional choice rules included in the result, the rules can be further simplified, when compared to the rules produced by ⊕∨JU. In particular, the first group of rules can be treated the same way as the second, leading to the following definition of⊕∨UA:\nDefinition 30 (Condensing Operator ⊕∨UA). The binary operator ⊕∨UA on the set of all disjunctive programs is defined as follows: Given two disjunctive programs P and U , the disjunctive program P ⊕∨UA U consists of the following rules:\n1. for all π ∈ P with Hπ = {L } and all S ∈ βU ( L ) , the rule ( Hπ ← Bπ, S+, S−. ) ;\n2. all π ∈ P such that Hπ is of the form { p,∼ p } for some p ∈ A; 3. for all π ∈ U with Hπ = { p } for some p ∈ A, the rule (p;∼ p← Bπ.); 4. all rules from U .\nIf we consider the programs P, U and V from Example 27, the two main differences between the disjunctive program ⊕∨ JU 〈P,U ,V〉 and its nested counterpart ⊕ JU 〈P,U ,V〉, besides their different syntax, are as follows: 1) the nested rule is turned into the two disjunctive rules listed in (8), and 2) the rule r ← > ∧ ∼> ∧ ∼⊥ has no counterpart in the disjunctive program as there is no blocking set for ∼ r in U . The differences between ⊕∨ UA 〈P,U ,V〉 and ⊕ UA 〈P,U ,V〉 are analogical and in Figure 3 we list the disjunctive programs simplified in the same way as their nested counterparts in Figure 2. From a general perspective, the operators ⊕∨JU and ⊕∨UA preserve the main property of ⊕JU and ⊕UA.\nTheorem 31 (State Condensing Using ⊕∨JU and ⊕∨UA). Let P be a DLP. An interpretation J is a (i) JU-model of P if and only if it is a stable model of ⊕∨ JU P ;\np;∼ q ← ∼ s. q ← p. p;∼ r ← ∼ s. ∼ p← ∼ q,∼ r,∼ s. p← s. s.\np← q,∼ s. q ← p. p← r,∼ s. ∼ p← ∼ q,∼ r,∼ s. p← s. s.\np;∼ p. q;∼ q ← p. r;∼ r. s;∼ s.\nFigure 3: Disjunctive programs\n⊕∨\nJU 〈P,U ,V〉 (left) and ⊕∨ UA 〈P,U ,V〉 (right) without irrelevant rules.\n(ii) UA-model of P if and only if it is a stable model of ⊕∨\nUA P .\nProof. See Appendix C, page 58.\nAlthough operators ⊕∨JU and ⊕∨UA eliminate the necessity for using nested rules to condense a DLP into a single program, this comes at a cost. Namely, the size of the nested program resulting from applying operators ⊕JU and ⊕UA is always linear in size of the argument programs, while in case of ⊕∨JU and ⊕∨UA, the resulting program can be exponentially larger. Furthermore, Figures 2 and 3 suggest that the representations produced by⊕∨JU and⊕∨UA will be less faithful to the form of the rules in the original programs, and thus less readable. This indicates that the nested program is more suitable as a way to store the condensed program, both in terms of space and readability. Additionally, in order to find its stable models, a more efficient translation can be used that utilises additional meta-level atoms to prevent the exponential explosion (see [24, 48] for further details). However, such a translation will no longer be equivalent to the original program sequence w.r.t. performing further updates."
    }, {
      "heading" : "6. Abstract Exception-Based Operators",
      "text" : "In this section we generalise exception-based operators to arbitrary knowledge representation formalisms with monotonic model-theoretic semantics.\nThus, we assume to be using some knowledge representation formalism in which a knowledge base is a subset of the set of all knowledge atoms Ω and Z denotes the set of all semantic structures among which the models of knowledge atoms are chosen. The set of models of a knowledge atom α is denoted by [[α ]]. The semantic characterisation of a knowledge base K is the set of sets of models of its knowledge atoms: 〈〈K〉〉 = { [[α ]] | α ∈ K }. The models of K are the models of all its elements, i.e. [[K ]] = ⋂ 〈〈K〉〉.\nAn abstract exception-based update operator is characterised by an exception function that, given the set of models of a knowledge atom α and the semantic characterisations of the original and updating knowledge base, returns the semantic structures that are to be introduced as exceptions to α.\nDefinition 32 (Exception Function). An exception function is any function ε : 2Z × 22Z × 22Z → 2Z .\nGiven such an exception function and knowledge bases K and U , it naturally follows that the semantic characterisation resulting from updating K by U should consist of sets of models of each knowledge atom α from K, each augmented with the respective exceptions, and also the unmodified sets of models of knowledge atoms from U . In other words, we obtain the set of sets of models\n{ [[α ]] ∪ ε([[α ]], 〈〈K〉〉, 〈〈U〉〉) | α ∈ K } ∪ 〈〈U〉〉 . (9)\nTurning to the syntactic side, an update operator is binary function over 2Ω that takes the original knowledge base and its update as inputs and returns the updated knowledge base. An exception-based update operator is then formalised as follows:\nDefinition 33 (Abstract Exception-Based Update Operator). Given an exception function ε, an update operator ⊕ is ε-based if for all K, U ⊆ Ω, 〈〈K ⊕ U〉〉RE is equal to (9). Also, ⊕ is exception-based if it is ε-based for some exception function ε."
    }, {
      "heading" : "7. Belief Updates Using Exception-Based Operators",
      "text" : "Concrete exception-based operators for propositional knowledge bases are obtained from the abstract framework presented in the previous section by identifying the set of knowledge atoms Ω with the set of all propositional formulas and the set of semantic structures Z with propositional interpretations.\nThis setup allows us to immediately prove that most conceivable model-based operators can be faithfully modelled as exception-based ones. Particularly, this is possible for any update operator satisfying the uncontroversial postulates (B1), (B2.1) and (B4) [34].\nTheorem 34 (Model-Based Updates Using Exception-Based Operators). If is a belief update operator that satisfies (B1), (B2.1) and (B4), then there exists an exception function ε such that for every ε-based update operator ⊕ and all finite sequences of knowledge bases D, [[3D ]] = [[ ⊕ D ]].\nProof. See Appendix E, page 59.\nAn interesting point regarding this result is that the principles (B1), (B2.1) and (B4) are not specific to update operators, they are also satisfied by AGM revision operators. These operators are developed for the case of revising a belief set which is a set of formulas closed w.r.t. a logical consequence operator Cn . A revision operator ? takes an original belief set T and a formula µ representing its revision and produces the revised belief set T ? µ. The typical properties satisfied by AGM revision operators include success, inclusion and extensionality [33], formalised, respectively, as\nµ ∈ T ? µ , T ? µ ⊆ Cn(T ∪ {µ }) , If µ ≡ ν, then T ? µ = T ? ν.\nThese three properties directly imply that (B1), (B2.1) and (B4) are satisfied by AGM revision operators. Hence, Theorem 34 directly applies to AGM revision operators as well. Note also that the operator adopted for ABox updates in [49], inspired by WIDTIO, performs a deductive closure of the ABox before updating it, so it corresponds to the standard full meet AGM revision operator.\nTurning to formula-based belief update operators, we can achieve similar results by introducing the following principles satisfied by many formula-based operators. Here, for any knowledge base B, 〈〈B〉〉I denotes the set 〈〈B〉〉 ∪ { I }. The principles are as follows:\n(F1) 〈〈B ◦ U〉〉 ⊇ 〈〈U〉〉. (F2.1) 〈〈B ∪ U〉〉 ⊇ 〈〈B ◦ U〉〉. (F4) If 〈〈B〉〉I = 〈〈C〉〉I and 〈〈U〉〉I = 〈〈V〉〉I, then 〈〈B ◦ U〉〉I = 〈〈C ◦ V〉〉I.\nWe can see that (F1) and (F2.1) are stronger versions of (B1), and (B2.1), respectively. While (F1) requires that the sets of models of formulas in U be retained in the semantic characterisation of B ◦ U , (F2.1) states that every formula in B ◦ U be equivalent to some formula in B ∪ U . Intuitively, this means that B ◦ U is obtained from B ∪U by deleting some of its elements, modulo equivalence. Finally, (F4) is a reformulation of (B4) that is satisfied by formula-based operators – it can be seen as syntax-independence w.r.t. the set of\nsets of models of a knowledge base, modulo the presence of tautologies, instead of the overall set of models as in (B4). In some ways it is weaker than (B4) as its antecedent is much stronger.\nThe WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations. More formally:\nDefinition 35 (Regular Bold Operator). For any set of remaindersR we define ((R))I = { 〈〈B〉〉I | B ∈ R}. We say that the Bold operator ◦sbold is regular if for all sets of remaindersR1,R2 such that ((R1))I = ((R2))I it holds that 〈〈s(R1)〉〉I = 〈〈s(R2)〉〉I.\nThe regularity condition guarantees a certain degree of independence of syntax, e.g. given the sets of remainders R1 = { { p } , { q } } and R2 = { { p ∧ p } , { q ∨ q } }, a regular Bold operator either selects { p } from R1 and { p ∧ p } from R2, or it selects { q } from R1 and { q ∨ q } from R2. A non-regular one might select, say, { p } from R1 and { q ∨ q } from R2. Thus the regularity condition ensures that the operator is independent of the syntax of individual formulas in the knowledge base.\nThe Cross-Product operator [30] satisfies (F1) (thus also (B1)), (B2.1) and (F4), but not (F2.1).\nProposition 36 (Properties of Formula-Based Updates). The WIDTIO and regular Bold operators satisfy (F1), (F2.1) and (F4). The Cross-Product operator satisfies (F1), (B2.1) and (F4) but does not satisfy (F2.1).\nProof. See Appendix E, page 62.\nThe following result establishes that formula-based operators such as WIDTIO and regular Bold can be fully captured by exception-based operators. In addition, operators such as Cross-Product can be captured for the case of a single update.\nTheorem 37 (Formula-Based Updates Using Exception-Based Operators). If ◦ is an update operator that satisfies (F1), (F2.1) and (F4), then there exists an exception function ε such that for every ε-based update operator ⊕ and all finite sequences of knowledge bases D, [[©D ]] = [[ ⊕ D ]].\nIf ◦ is an update operator that satisfies (B1), (B2.1) and (F4), then there exists an exception function ε such that for every ε-based update operator ⊕ and all knowledge bases B, U , [[B ◦ U ]] = [[B ⊕ U ]].\nProof. See Appendix E, page 63.\nSimilarly as with principles of model-based update operators, principles (F1), (F2.1) and (F4) are closely related with the properties of base revision operators [27, 33]. In particular, two types of base revision are identified in [33], the internal and external base revision. Both of them satisfy base revision counterparts of success and inclusion and, in addition, internal revision operators satisfy a property called uniformity. These three principles together entail that internal revision operators satisfy (F1), (F2.1) and one half of (F4); the other half can be achieved by putting additional constraints on the two-place selection function that generates the revision operator, similar to the regularity condition we imposed on the Bold operator above. Such regular internal revision operators are thus directly subject to Theorem 37. The same however does not hold for regular external revision operators as they need not satisfy uniformity. Note also that the WIDTIO and Bold operators coincide with internal full meet base revision and internal maxichoice base revision operators, respectively."
    }, {
      "heading" : "8. Conclusion",
      "text" : "Throughout this paper we developed a novel perspective on knowledge updates and demonstrated that it offers the first unifying ground for characterising rule update semantics as well as both model- and formulabased classical update operators.\nMore particularly, we defined a new monotonic characterisation of rules, the RE-models, and introduced a generic method for specifying semantic rule update operators in which a logic program is viewed as the set of sets of RE-models of its rules and updates are performed by introducing additional interpretations to the sets of RE-models of rules in the original program. This framework allowed us to define concrete semantic rule update operators that enjoy an interesting combination of syntactic as well as semantic properties that had never been reconciled before. Furthermore, it turned out that these operators can faithfully characterise the foundational JU- and UA-semantics for rule updates.\nThese insights also allowed us to address the long enduring problem of state condensing, i.e. transforming a sequence of answer-set programs – interpreted as updates – into a single answer-set program written in the same alphabet. Partly, this problem emerges because some rule update semantics employ complex mechanisms such as preferences or other minimality criteria that make it impossible to encode the result in a single answer-set program. Others have model-theoretic characterisations that assign non-minimal models to certain update sequences, and it is well known that stable models of non-disjunctive answer-set programs are minimal. By resorting to more expressive classes of answer-set programs, namely nested and disjunctive, we solved this problem for both JU- and UA-semantics. In all four cases, two for each semantics using both classes of answer-set programs, the resulting program is written with the same alphabet and is ready to be further updated. We have illustrated with some examples that the resulting programs written using nested answer-set programming are perhaps more readable than those written using disjunctive answer-set programs, in the sense that they more closely match the intuitions underlying the semantics for updates that we consider.\nFurthermore, we defined abstract exception-based operators that can be used in any knowledge representation formalism with a monotonic model-theoretic semantics. Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett’s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51]. The Cross-Product operator can be captured when a single update is performed and the same can be said about the Set-Of-Theories operator since for a single update it is equivalent to the Cross-Product operator [73]. Nevertheless, neither of these two operators offers a viable alternative for updating ontologies – Cross-Product requires that disjunctions of ontology axioms be performed, which is typically not supported in DLs, and Set-Of-Theories produces a disjunctive ontology which is impractical and deviates from mainstream DL research.\nOverall, exception functions and exception-based operators can capture both traditional syntax-based approaches to rule updates as well as a wide range of model- and formula-based belief update operators. Thus, they offer a uniform framework that bridges two very distinct approaches to updates, previously considered irreconcilable. These findings are essential to better understand their interrelations. In addition, they open up new possibilities for addressing updates of Hybrid Knowledge Bases consisting of both an ontology and a rule component since the different methods used for dealing with ABox, TBox and rule updates can be viewed uniformly by looking at their associated exception functions. When coupled with a counterpart of SE- or RE-models in the context of hybrid knowledge bases, this can lead to universal hybrid update semantics which, in turn, can further improve our understanding of the distinct update paradigms.\nOur investigation also directly points to challenges that need to be tackled next. First, semantic characterisations of additional rule update semantics need to be investigated. This poses a number of challenges\ndue to the need to detect non-tautological irrelevant updates [5, 61, 62]. For instance, the simple functions examined in this paper, as well as the original JU- and UA-semantics, cannot distinguish an update of { p. } by U = {∼ p← ∼ q.,∼ q ← ∼ p. }, where it is plausible to introduce the exception (∅, ∅) (and the stable model ∅ along with it), from an update of { p., q. } by U , where such an exception should not be introduced due to the cyclic dependency of justifications to reject (p.) and (q.). In such situations, context-aware functions need to be used. Such functions have the potential of satisfying properties such as (P3) and (Associativity). They would facilitate the search for condensing operators for other rule update semantics and perhaps shed some light on the problem of updating disjunctive programs which has received very little attention up until now.\nAnother challenge is to find additional logical characterisations of rules, namely a notion of program equivalence that is weaker than RR-equivalence but stronger than RE-equivalence so that both (P4) and properties such as (P2.1) can be achieved under a single notion of program equivalence. In this context, the close relationship between RE-models and T-models [74], used in the context of forgetting in logic programs, asks for more attention as well.\nComputational properties of different classes of exception-based update operators should also be investigated and it might be interesting to look for constrained classes of exception functions that satisfy syntax-independence w.r.t. SR-equivalence. Such functions, however, will not be able to respect causal rejection because SE-models cannot distinguish abolishing rules.\nOur discussion of the expressivity of exception-based operators w.r.t. revision operators, on both belief sets and belief bases, can be used to tackle and unify approaches to ontology revision [32, 57, 58]. This seems relevant even in the context of ontology updates since it has been argued in the literature that the strict distinction between revision and update is not suitable in the context of ontologies [13]."
    }, {
      "heading" : "Acknowledgements",
      "text" : "J. Leite was partially supported by Fundação para a Ciência e a Tecnologia (FCT) under project NOVA LINCS (UID/CEC/04516/2013)."
    }, {
      "heading" : "Appendix A. Proofs: Robust Equivalence Models",
      "text" : "In this section we prove formal properties of RE-models (c.f. Definition 7). We begin by defining a set of representatives of rule equivalence classes induced by SE-models, as it was introduced in [65] since it is needed in our proofs.\nDefinition 38 (Transformation into an SE-Canonical Rule [65]). Given a rule π, we define the SE-canonical rule canSE(π) as follows:\n(i) If any of the sets H+π ∩ B+π , H−π ∩ B−π and B+π ∩ B−π is non-empty, then canSE(π) = τ . (ii) If (i) does not apply and H+π \\ B−π 6= ∅, then canSE(π) = ( (H+π \\ B−π ); (H−π \\ B+π )← B+π ,B−π . ) .\n(iii) If (i) does not apply and H+π \\ B−π = ∅, then canSE(π) is the constraint ( ← (B+π ∪ H−π ),B−π . ) .\nProposition 39 ([65]). Every rule π is SE-equivalent to the SE-canonical rule canSE(π).\nCorollary 40 ([65]). No two different SE-canonical rules are SE-equivalent.\nThe following presentation follows a similar pattern as the one used in [65] for SE-models. In particular, we introduce a set of representatives of rule equivalence classes induced by RE-models and show how to reconstruct a representative from the set of its RE-models. Then we prove the properties of RE-models that have been formulated in Section 3.\nRemark 41. We use the following additional notation: For any rule π, π+ denotes the rule (H+π ← B+π .) and π− denotes the rule ( H−π ← B−π . ) . Note that the definition of an RE-model (c.f. Definition 7) implies that (I, J) ∈ [[π ]]RE if and only if I |= π+ or J |= π−. This fact is used implicitly in the following proofs.\nLemma 42. Rules of the following forms are RE-tautological:\np;H ← p,B. H;∼ p← B,∼ p. H ← B, p,∼ p.\nProof. First assume that a rule π is of the first form and take some (I, J) ∈ X. We need to show that (I, J) is an RE-model of π, so it suffices to show that I |= π+. This follows from the fact that p belongs to both H+π and B + π .\nNow suppose that π is of the second form. Given some (I, J) ∈ X, we see that the atom p belongs to both H−π and B − π , so J |= π−. Hence, (I, J) is an RE-model of π.\nFinally, suppose that π takes the third form and take some (I, J) ∈ X. If J |= π−, then (I, J) is an RE-model of π. On the other hand, if J 6|= π−, then J |= ∼ p and, consequently, I 6|= p because I is a subset of J . This implies that I |= π+, so we can once again conclude that (I, J) is an RE-model of π.\nLemma 43. The following pairs of rules are RE-equivalent: (1) (p;H ← B,∼ p.) and (H ← B,∼ p.); (2) (H;∼ p← p,B.) and (H ← p,B.).\nProof.\n(1) Let the first rule be denoted by π1, the second by π2 and take some (I, J) ∈ X. We need to show that (I, J) is an RE-model of π1 if and only if it is an RE-model of π2. Thus, it suffices to prove the following:\nI |= π+1 ∨ J |= π − 1 if and only if I |= π + 2 ∨ J |= π − 2 . (A.1)\nFirst note that π−1 = π − 2 , so J |= π − 1 holds if and only if J |= π − 2 . So if J |= π − 1 , then J |= π − 2 and we can conclude that (A.1) holds. On the other hand, if J 6|= π−1 , then J 6|= π − 2 and (A.1) reduces to proving that I |= π+1 holds if and only if I |= π + 2 . Now it suffices to observe that J 6|= π − 1 implies J |= ∼ p and since I is a subset of J , we can conclude that I 6|= p. Since π+1 differs from π + 2 only in the head atom p, our claim follows.\n(2) Let the first rule be denoted by π1, the second by π2 and take some (I, J) ∈ X. We need to show that (I, J) is an RE-model of π1 if and only if it is an RE-model of π2. Thus, it suffices to prove the following:\nI |= π+1 ∨ J |= π − 1 if and only if I |= π + 2 ∨ J |= π − 2 . (A.2)\nFirst note that π+1 = π + 2 , so I |= π + 1 holds if and only if I |= π + 2 . So if I |= π + 1 , then I |= π + 2 and we can conclude that (A.2) holds. On the other hand, if I 6|= π+1 , then I 6|= π + 2 and (A.2) reduces to proving that J |= π−1 holds if and only if J |= π − 2 . Now it suffices to observe that I 6|= π + 1 implies I |= p and since I is a subset of J , we can conclude that J 6|= ∼ p. Since π−1 differs from π − 2 only in the head literal ∼ p, our claim follows.\nDefinition 44 (RE-Canonical Rule). We say that a rule π is RE-canonical if either it is τ , or the sets H+π ∪H−π , B+π and B − π are pairwise disjoint.\nDefinition 45 (Transformation into an RE-Canonical Rule). Given a rule π, we define the RE-canonical rule canRE(π) as follows:\n(i) If any of the sets H+π ∩ B+π , H−π ∩ B−π and B+π ∩ B−π is non-empty, then canRE(π) = τ . (ii) If (i) does not apply, then canRE(π) is the rule ( (H+π \\ B−π ); (H−π \\ B+π )← B+π ,B−π . ) .\nProposition 46. For every rule π, [[π ]]RE = [[canRE(π)]]RE.\nProof. This can be shown by a careful iterative application of Lemmas 42 and 43. First observe that if canRE(π) = τ , then Lemma 42 implies that π is RE-tautological, thus indeed RE-equivalent to τ .\nIn the principal case we can use Lemma 43(1) on all atoms from H+π ∩ B−π and remove them one by one from H+π while preserving RE-models. A similar situation occurs with atoms from H − π ∩ B+π which can be, according to Lemma 43(2), removed from H−π without affecting RE-models. After these steps are performed, the resulting rule coincides with canRE(π).\nLemma 47. For any rule π and (I, J) ∈ X, (I, J) /∈ [[π ]]RE if and only if B+π ⊆ I ⊆ A \\ H+π and H−π ⊆ J ⊆ A \\ B−π .\nProof. Note that (I, J) /∈ [[π ]]RE if and only if both I 6|= π+ and J 6|= π−. It can be easily verified that the former is equivalent to B+π ⊆ I ⊆ A \\ H+π and the latter to H−π ⊆ J ⊆ A \\ B−π .\nCorollary 48. Let π be an RE-canonical rule different from τ , put I = B+π , J = H−π ∪B+π and J ′ = A\\B−π , and let p be an atom. Then the following holds:\n(1) (I, J ∪ { p }) ∈ [[π ]]RE if and only if p ∈ B−π . (2) (I ∪ { p } , J ∪ { p }) ∈ [[π ]]RE if and only if p ∈ H+π ∪ B−π . (3) (I \\ { p } , J ′) ∈ [[π ]]RE if and only if p ∈ B+π . (4) (I, J) /∈ [[π ]]RE.\nProof. Follows from Lemma 47 and the disjointness properties satisfied by RE-canonical rules.\nLemma 49. Let π be an RE-canonical rule different from τ and p an atom. Then the following holds: (1) p ∈ B−π if and only if for all (I, J) ∈ X, p ∈ J implies (I, J) ∈ [[π ]]RE; (2) p ∈ H+π if and only if p /∈ B−π and for all (I, J) ∈ X, p ∈ I implies (I, J) ∈ [[π ]]RE; (3) p ∈ B+π if and only if for all (I, J) ∈ X, p /∈ I implies (I, J) ∈ [[π ]]RE; (4) p ∈ H−π if and only if p /∈ B+π and for all (I, J) ∈ X, p /∈ J implies (I, J) ∈ [[π ]]RE.\nProof.\n(1) Suppose that p ∈ B−π and take some (I, J) ∈ X with p ∈ J . Then J 6|= ∼ p, so it follows that J |= π−. Consequently (I, J) ∈ [[π ]]RE. To prove the converse implication, let I = B+π and J = H − π ∪B+π . It follows that (I, J∪{ p }) ∈ [[π ]]RE,\nso by Corollary 48(1) we conclude that p ∈ B−π .\n(2) Suppose that p ∈ H+π and take some (I, J) ∈ X with p ∈ I . Then I |= p, so it follows that I |= π+. Consequently (I, J) ∈ [[π ]]RE. To prove the converse implication, let I = B+π and J = H − π ∪B+π . It follows that (I∪{ p } , J∪{ p }) ∈\n[[π ]]RE, so by Corollary 48(2) we conclude that p belongs to H+π ∪ B−π . Moreover, by the assumption we know that p /∈ B−π , so p ∈ H+π . (3) Suppose that p ∈ B+π and take some (I, J) ∈ X with p /∈ I . Then I 6|= p, so it follows that I |= π+. Consequently, (I, J) ∈ [[π ]]RE. To prove the converse implication, let I = B+π and J\n′ = A\\B−π . It follows that (I\\{ p } , J ′) ∈ [[π ]]RE, so by Corollary 48(3) we conclude that p ∈ B+π . (4) Suppose that p ∈ H−π and take some (I, J) ∈ X with p /∈ J . Then J |= ∼ p, so it follows that J |= π−. Consequently, (I, J) ∈ [[π ]]RE. To prove the converse implication, let I = B+π and J = H − π ∪ B+π . Corollary 48(4) guarantees\nthat (I, J) /∈ [[π ]]RE. Furthermore, by the assumption it follows that (I \\ { p } , J \\ { p }) ∈ [[π ]]RE. Consequently, J must differ from J\\{ p }, which implies that p ∈ J . Furthermore, since J = H−π ∪B+π and p /∈ B+π by assumption, we conclude that p ∈ H−π .\nDefinition 50 (Rule RE-Induced by a Set of Interpretations). Let M ⊆ X. The rule RE-induced by M, denoted by ‖M‖RE, is defined as follows: IfM = X, then ‖M‖RE = τ ; otherwise, ‖M‖RE is of the form (HRE(M)+;HRE(M)− ← BRE(M)+, BRE(M)−.) where\nBRE(M)− = { p ∈ A | ∀(I, J) ∈ X : p ∈ J ⇒ (I, J) ∈M } , HRE(M)+ = { p ∈ A | ∀(I, J) ∈ X : p ∈ I ⇒ (I, J) ∈M } \\BRE(M)− , BRE(M)+ = { p ∈ A | ∀(I, J) ∈ X : p /∈ I ⇒ (I, J) ∈M } , HRE(M)− = { p ∈ A | ∀(I, J) ∈ X : p /∈ J ⇒ (I, J) ∈M } \\BRE(M)+ .\nProposition 51. For every RE-canonical rule π, ‖[[π ]]RE‖RE = π.\nProof. If π = τ , then [[π ]]RE = X and, by Definition 50, ‖X‖RE = τ = π, so the identity is satisfied. In the principal case, π is an RE-canonical rule different from τ . LetM = [[π ]]RE. It follows from Definition 50 and Lemma 49 that π = ‖M‖RE.\nCorollary 52. No two different RE-canonical rules are RE-equivalent.\nProof. Follows directly from Proposition 51.\nProof of Proposition 8. Follows from Corollary 52 since every abolishing rule and every constraint is RE-canonical.\nLemma 53. For every rule π, canSE(π) = canSE(canRE(π)).\nProof. Follows directly from Definitions 38 and 45.\nLemma 54. If π is not RE-equivalent to any abolishing rule, then canRE(π) = canSE(π).\nProof. Follows directly from Definitions 38 and 45.\nProof of Proposition 9. Suppose that π and σ are RE-equivalent. Then canRE(π) = canRE(σ) by Proposition 46 and Corollary 52. By Lemma 53 it follows that canSE(π) = canSE(canRE(π)) = canSE(canRE(σ)) = canSE(σ), so by Proposition 39 we can conclude that π, σ are SE-equivalent.\nNow suppose that neither π nor σ is RE-equivalent to an abolishing rule and π is RE-equivalent to σ. Then, by Proposition 46, canRE(π) is RE-equivalent to canRE(σ) and by Corollary 52, canRE(π) = canRE(σ). It follows from Lemma 54 that canSE(π) = canSE(σ) and by Proposition 39, π is SE-equivalent to σ.\nFinally, by Corollary 52, a rule π is RE-tautological if and only if canRE(π) = τ which holds if and only if canSE(π) = τ which, by Corollary 40, holds if and only if π is SE-tautological.\nProof of Proposition 10. Suppose that J is a stable model of P. Then J is a subset-minimal model of PJ . Thus, (J, J) is an RE-model of P. Now suppose that (I, J) is an RE-model of P for some I ⊆ J . Then I |= PJ and by the minimality of J we obtain I = J .\nSuppose that (J, J) is an RE-model of P and for all I ( J , (I, J) is not an RE-model of P. Then J |= PJ and J is also a subset-minimal model of PJ . Consequently, J is a stable model of P.\nProof of Proposition 11. Let P contain the rule π(I,J) = ( (A \\ I); J ← I, (A \\ J). )\nfor each (I, J) ∈ X \\M. It is an immediate consequence of Lemma 47 that [[π(I,J) ]]RE = X \\ { (I, J) }. Thus,\n[[P ]]RE = ⋂\n(I,J)∈X\\M\nX \\ { (I, J) } = X \\ ⋃\n(I,J)∈X\\M\n{ (I, J) } = X \\ (X \\M) =M .\nDefinition 55. A program entailment relation is a preorder on the set of all programs. A program equivalence relation is an equivalence relation on the set of all programs.\nGiven a program entailment relation |= and a program equivalence relation ≡, we say that |= is associated with ≡ if for all programs P, Q, P ≡ Q holds if and only if P |= Q and Q |= P.\nProof of Proposition 14. If X is SE, RE or SU, then the property follows immediately from the definitions of |=X and ≡X.\nIf X is either SR or RR, then it follows from the definition of |=X that P |=X Q is equivalent to 〈〈Pτ 〉〉X ⊇ 〈〈Qτ 〉〉X. Thus, P |=X Q together with Q |=X P is equivalent to 〈〈Pτ 〉〉X = 〈〈Qτ 〉〉X, which is the definition of P ≡X Q.\nIt remains to consider the case when X is SMR or RMR. Let Y be SE or RE, respectively. First suppose that P ≡X Q. By the definition of ≡X we obtain that min〈〈Pτ 〉〉Y = min〈〈Qτ 〉〉Y. Our goal is to prove that P |=X Q and Q |=X P. We only show the former; the proof of the latter is analogous. Take some σ ∈ Q. Our goal is find some π ∈ Pτ such that [[π ]]Y ⊆ [[σ ]]Y. Take some subset-minimalM ∈ 〈〈Qτ 〉〉Y such that M ⊆ [[σ ]]Y. It follows from our assumption thatM belongs to 〈〈Pτ 〉〉Y. In other words, there exists some π ∈ Pτ such that [[π ]]Y =M⊆ [[σ ]]Y.\nNow suppose that both P |=X Q and Q |=X P. We need to prove that P ≡X Q, i.e. that min〈〈Pτ 〉〉Y = min〈〈Qτ 〉〉Y. We only show that min〈〈Pτ 〉〉Y ⊆ min〈〈Qτ 〉〉Y; the proof of the other inclusion is analogical. Take some π ∈ Pτ such that\n[[π ]]Y ∈ min〈〈Pτ 〉〉Y . (A.3)\nSince Q |=X P, there exists some σ ∈ Qτ such that [[σ ]]Y ⊆ [[π ]]Y Let σ′ ∈ Qτ be such that [[σ′ ]]Y ∈ min〈〈Qτ 〉〉Y and [[σ′ ]]Y ⊆ [[σ ]]Y. Since P |=X Q, there exists some π′ ∈ Pτ such that [[π′ ]]Y ⊆ [[σ′ ]]Y. In other words, we know that [[π′ ]]Y ⊆ [[σ′ ]]Y ⊆ [[σ ]]Y ⊆ [[π ]]Y. Thus, due to (A.3) we can conclude that [[π′ ]]Y = [[σ ′ ]]Y = [[σ ]]Y = [[π ]]Y, and it follows from the choice of σ′ that [[π ]]Y ∈ min〈〈Qτ 〉〉Y.\nLemma 56. Let |=X, |=Y be program entailment relations and ≡X, ≡Y program equivalence relations such that |=X is associated with ≡X and |=Y is associated with ≡Y. Then |=X |=Y implies ≡X ≡Y.\nProof. Suppose that |=X |=Y and take some programs P, Q such that P ≡Y Q. We need to show that P ≡X Q. Since |=Y is associated with ≡Y, we can conclude that P |=Y Q and Q |=Y P. Furthermore, from |=X |=Y it follows that P |=X Q and Q |=X P, and the assumption that |=X is associated with ≡X implies P ≡X Q.\nCorollary 57. Let |=X, |=Y be program entailment relations and ≡X, ≡Y program equivalence relations such that |=X is associated with ≡X and |=Y is associated with ≡Y. Then:\n≡X≺≡Y and |=X≺ |=Y if and only if |=X |=Y and ≡Y ≡X .\nProof. By the definition, ≡X≺≡Y and |=X≺ |=Y hold if and only if ≡X ≡Y, ≡Y ≡X, |=X |=Y and |=Y |=X. By Lemma 56, |=X |=Y implies ≡X ≡Y and ≡Y ≡X implies |=Y ≡X, so the condition can be simplified as desired.\nLemma 58. Let π be a rule and J an interpretation. Then:\nJ |= π if and only if J |= πJ if and only if (J, J) ∈ [[π ]]RE .\nProof. Follows by the definition of πJ and of RE-models.\nLemma 59. Let Π, Σ be rules or programs. Then [[Π]]RE ⊆ [[Σ]]RE implies [[Π]]SE ⊆ [[Σ]]SE.\nProof. Assume that [[Π]]RE ⊆ [[Σ]]RE. Then for all (I, J) ∈ X, I |= ΠJ implies I |= ΣJ and together with Lemma 58 this implies that for all interpretations J ,\nJ |= Π implies J |= ΠJ implies J |= ΣJ implies J |= Σ . (A.4)\nIn order to show that [[Π]]SE ⊆ [[Σ]]SE, take some (I, J) ∈ [[Π]]SE. By the definition of SE-models, J |= Π and I |= ΠJ , so by (A.4) and our assumption we can conclude that J |= Σ and I |= ΣJ . Thus, by the definition of SE-models, (I, J) ∈ [[Σ]]SE.\nProof of Proposition 15. (1) First we show that ≡SM≺≡SE, i.e. that ≡SM ≡SE and ≡SE ≡SM. To verify the former, suppose\nthat P, Q are programs with P ≡SE Q. Then P ∪ ∅ has the same stable models as Q ∪ ∅. Consequently, P ≡SM Q. To see that ≡SE ≡SM, observe that the programs P = ∅, Q = { p← q. } are SM-equivalent but not SE-equivalent. Turning to the remaining relationships, it follows from Corollary 57 that we can instead prove that\n|=SE |=RE |=RMR |=RR |=SU and ≡SU ≡RR ≡RMR ≡RE ≡SE . (A.5)\nWe first concentrate on the left-hand side of (A.5). In order to show that |=SE |=RE, suppose that P, Q are programs such that P |=RE Q. Then [[P ]]RE ⊆ [[Q ]]RE and it follows from Lemma 59 that [[P ]]SE ⊆ [[Q ]]SE. Consequently, P |=SE Q. We also need to prove that |=RE |=RMR. Take some programs P, Q with P |=RMR Q and put Pτ = P ∪ { τ }. It follows that\n∀σ ∈ Q∃πσ ∈ Pτ : [[πσ ]]RE ⊆ [[σ ]]RE . (A.6)\nWe need to prove that [[P ]]RE ⊆ [[Q ]]RE. Suppose that X ∈ [[P ]]RE and take some σ ∈ Q, our goal is to show that X ∈ [[σ ]]RE. By (A.6) there exists some πσ ∈ Pτ such that [[πσ ]]RE ⊆ [[σ ]]RE. If πσ = τ , then it immediately follows that X ∈ X = [[τ ]]RE ⊆ [[σ ]]RE. If πσ ∈ P, then X ∈ [[πσ ]]RE by the choice of X , so X ∈ [[σ ]]RE. Our next goal is to show that |=RMR |=RR. This follows directly by the definitions of |=RMR and |=RR. To prove the final part of the left-hand side of (A.5), suppose that P |=SU Q. Then [[Q\\P ]]SE = X. We need to prove that P |=RR Q, i.e. that for every σ ∈ Q there is some π ∈ Pτ such that [[π ]]RE = [[σ ]]RE. Pick some σ ∈ Q and note that Q = (Q ∩ P) ∪ (Q \\ P). If σ ∈ Q ∩ P, then σ ∈ P and we can put π = σ to finish the proof. In the remaining case, σ ∈ Q \\ P and it follows from our assumption that [[σ ]]SE = X. Thus, putting π = τ finishes the proof. As for the right-hand side of (A.5), we can see that≡SU ≡RR because the programsP = {∼ p← p. } and Q = {← p. } are RR-equivalent but not SU-equivalent. Similarly, programs P = { p. } and Q = { p., p← q. } are RMR-equivalent but not RR-equivalent, so it follows that ≡RR ≡RMR. Next, to verify that ≡RMR ≡RE it suffices to observe that the programs P = { p., q. } and Q = { p., q ← p. } are RE-equivalent but not RMR-equivalent. Finally, programs P = {∼ p. } and Q = {← p. } are SE-equivalent but not RE-equivalent, proving that ≡RE ≡SE.\n(2) It follows from Corollary 57 that we can instead prove that\n|=SE |=SMR |=SR |=RR and ≡RR ≡SR ≡SMR ≡SE . (A.7)\nWe first concentrate on the left-hand side of (A.7). To prove that |=SE |=SMR, take some programs P, Q with P |=SMR Q and put Pτ = P ∪ { τ }. It follows that\n∀σ ∈ Q∃πσ ∈ Pτ : [[πσ ]]SE ⊆ [[σ ]]SE . (A.8)\nWe need to prove that [[P ]]SE ⊆ [[Q ]]SE. Suppose that X ∈ [[P ]]SE and take some σ ∈ Q, our goal is to show that X ∈ [[σ ]]SE. By (A.8) there exists some πσ ∈ Pτ such that [[πσ ]]SE ⊆ [[σ ]]SE. If πσ = τ , then it immediately follows that X ∈ X = [[τ ]]SE ⊆ [[σ ]]SE. If πσ ∈ P, then X ∈ [[πσ ]]SE by the choice of X , so X ∈ [[σ ]]SE. Our next goal is to show that |=SMR |=SR. This follows directly by the definitions of |=SMR and |=SR. To finish the proof of the left-hand side of (A.5), suppose that P |=RR Q. Then ∀σ ∈ Q∃π ∈ P : [[π ]]RE = [[σ ]]RE and, due to Lemma 59, ∀σ ∈ Q∃π ∈ P : [[π ]]SE = [[σ ]]SE. Consequently, P |=SR Q. As for the right-hand side of (A.5), we can see that ≡RR ≡SR because the programs P = {∼ p. } and Q = {← p. } are SR-equivalent but not RR-equivalent. Similarly, programs P = { p. } andQ = { p., p← q. } are SMR-equivalent but not SR-equivalent, so it follows that ≡SR ≡SMR. Finally, to verify that ≡SMR ≡SE it suffices to observe that the programs P = { p., q. } and Q = { p., q ← p. } are SE-equivalent but not SMR-equivalent.\n(3) It follows from Corollary 57 that we can instead prove that |=SMR |=RMR and ≡RMR ≡SMR. To show the former, take some programs P,Q such that P |=RMR Q. It follows that ∀σ ∈ Q∃π ∈ P : [[π ]]RE ⊆ [[σ ]]RE and, due to Lemma 59, ∀σ ∈ Q∃π ∈ P : [[π ]]SE ⊆ [[σ ]]SE. Consequently, P |=SMR Q. As for the latter, it suffices to observe that the programs P = {∼ p. } and Q = {← p. } are SMR-equivalent but not RMR-equivalent.\n(4) According to Lemma 56, it suffices to show that ≡RE ≡SMR and ≡SMR ≡RE. The former follows from the fact that the programs P = {∼ p. } and Q = {← p. } are SMR-equivalent but not\nRE-equivalent. The latter can be verified by observing that though the programs P = { p., q. } and Q = { p., q ← p. } are RE-equivalent, they are not SMR-equivalent.\n(5) According to Lemma 56, it suffices to show that ≡RE ≡SR and ≡SR ≡RE. The former follows from the fact that the programs P = {∼ p. } and Q = {← p. } are SR-equivalent but not RE-equivalent. The latter can be verified by observing that though the programsP = { p., q. } andQ = { p., q ← p. } are RE-equivalent, they are not SR-equivalent.\n(6) According to Lemma 56, it suffices to show that ≡RMR ≡SR and ≡SR ≡RMR. The former follows from the fact that the programs P = {∼ p. } and Q = {← p. } are SR-equivalent but not RMR-equivalent. The latter can be verified by observing that though the programs P = { p. } and Q = { p., p← q. } are RMR-equivalent, they are not SR-equivalent."
    }, {
      "heading" : "Appendix B. Proofs: Exception-Based Rule Update Operators",
      "text" : "Appendix B.1. Conflicts Between Sets of RE-Models\nDefinition 60 (Additional Notation). Let X ∈ X. Given an atom p, we say that X is an RE-model of p if X(p) = T. We say that X is an RE-model of ∼ p if X(p) = F. We denote the set of all RE-models of a literal L by [[L ]]RE. Given a set of literals S, we say that X is an RE-model of S if X is an RE-model of all literals in S. We denote the set of all RE-models of S by [[S ]]RE. Given a sequence of rule bases R = 〈Ri〉i<n, we define 〈〈R〉〉RE = 〈〈〈Ri〉〉RE〉i<n.\nProposition 61. Let π be a rule, p an atom and X = (I, J) ∈ X. Then (I \\ { p } , J ∪ { p }) is not an RE-model of π if and only if the following holds:\n1. Neither p nor ∼ p belongs to Bπ; 2. X is an RE-model of Bπ;\n3. X is not an RE-model of any literal from Hπ \\ { p,∼ p }.\nProof. We prove the direct implication first. From the assumption it follows that πJ∪{ p } is different from τ . This has two consequences. First, H−π is included in J ∪ { p }, so all atoms from H−π , except possibly p, belong to J , and thusX is not an RE-model of any default literal from Hπ\\{∼ p }. The second consequence is that B−π ∩ (J ∪ { p }) is empty. Hence, ∼ p does not belong to Bπ. Furthermore, B−π ∩ J must also be empty, so we can conclude that X is an RE-model of all default literals from Bπ. It also follows from the assumption that I \\ { p } contains B+π but does not contain any atom from H+π . As a consequence, p does not belong to Bπ and we can also conclude that X is an RE-model of all atoms from Bπ and X is not an RE-model of any atom from Hπ \\ { p }. Thus, X is an RE-model of Bπ and it is not an RE-model of any literal from Hπ \\ { p,∼ p }.\nAs for the converse implication, we need to prove that I \\ { p } is not a model of πJ∪{ p }. We first need to show that πJ∪{ p } is equal to the rule H+π ← B+π . This holds if H−π is included in J ∪ { p } and B−π is disjoint with J ∪ { p }. Since X is an RE-model of Bπ, we can conclude that the set B−π is disjoint with J which, together with the assumption that ∼ p does not belong to Bπ, implies that B−π is disjoint with J ∪ { p }. We also know that X is not an RE-model of any literal from Hπ \\ { p,∼ p }, so we can conclude that H−π \\ { p } is included in J . Thus, H−π is included in J ∪ { p } and we proved that πJ∪{ p } is equal to the rule H+π ← B+π . It remains to show that I \\ { p } includes B+π and that it does not contain any atom from H+π . We know that X is an RE-model of Bπ, so I includes B + π . Also, since p does not belong to Bπ, I \\ { p } also includes B+π . Finally, we know that X is not an RE-model of any atom from H + π \\ { p }, so I does not contain any atom from H+π \\ { p }. This implies that I \\ { p } does not contain any atom from H+π .\nCorollary 62. Let π be a rule, p an atom and J an interpretation with p ∈ J . If (J, J) is an RE-model of π but (J \\ { p } , J) is not, then p ∈ Hπ and J |= Bπ.\nProof. It follows immediately from Proposition 61 that J |= Bπ. Furthermore, by the definition of RE-model, J is a model of πJ while J \\ { p } is not. Hence, J contains some atom from Hπ that is not contained in J \\ { p }. This atom can only be p.\nProposition 63. Let π be a rule,M = [[π ]]RE, p an atom, J an interpretation and V a truth value. Then MJ(p) = V if and only if the following holds:\n1. Neither p nor ∼ p belongs to Bπ; 2. J is a model of Bπ;\n3. J is not a model of any literal from Hπ \\ { p,∼ p }; 4. One of the following conditions holds:\n(a) V is T and Hπ ∩ { p,∼ p } = { p }, or (b) V is F and Hπ ∩ { p,∼ p } = {∼ p }.\nProof. We focus on the direct implication first. Assume that V = T. Then (J ∪ { p } , J ∪ { p }) is an RE-model of π although both (J \\ { p } , J ∪ { p }) and (J \\ { p } , J \\ { p }) are not. By Proposition 61 and Lemma 58 we can conclude that the first three of the properties that we need to prove are satisfied. It remains to show that Hπ ∩ { p,∼ p } = { p }, i.e. that p belongs to H+π but it does not belong to H−π . To see that the former holds, note that J \\ { p } is not a model of πJ∪{ p }, so J \\ { p } includes B+π and it does not contain any atom from H+π . Since we know that J ∪ { p } is a model of πJ∪{ p }, it must be the case that J ∪ { p } contains an atom from H+π . This atom can only be p. Finally, if p were a member of H−π , then πJ\\{ p } would coincide with τ , so (J \\ { p } , J \\ { p }) would be an RE-model of π, contrary to the assumption.\nNow assume that V = F. Then (J\\{ p } , J\\{ p }) is an RE-model of π although both (J\\{ p } , J∪{ p }) and (J ∪ { p } , J ∪ { p }) are not. By Proposition 61 and Lemma 58 we can conclude that the first three of the properties that we need to prove are satisfied. It remains to show that Hπ ∩ { p,∼ p } = {∼ p }, i.e. that p belongs to H−π but it does not belong to H + π . To see that the former holds, note that by the assumption J \\ { p } is a model of πJ\\{ p } while it is not a model of πJ∪{ p }. Hence, πJ\\{ p } must be equal to τ . We know that B−π is disjoint with J ∪{ p }, so it must also be disjoint with J \\{ p }. Thus, there must exist some atom from H−π that is not contained in J \\ { p } while it was contained in J ∪{ p }. This atom can only be p. Finally, if p were a member of H+π , then J ∪ { p } would contain an atom from H+π , so (J ∪ { p } , J ∪ { p }) would be an RE-model of π, contrary to the assumption.\nFinally, we show by contradiction that V cannot be equal to U. Suppose that V = U. It follows that (J ∪ { p }) 6|= πJ∪{ p }, (J \\ { p }) |= πJ∪{ p } and (J \\ { p }) 6|= πJ\\{ p }. Thus, since both πJ\\{ p } and πJ∪{ p } are different from τ , they must be identical and this is in conflict with our latter two conclusions.\nAs for the converse implication, let XT = (J ∪ { p } , J ∪ { p }), XU = (J \\ { p } , J ∪ { p }) and XF = (J \\ { p } , J \\ { p }) First suppose that V is T and Hπ ∩ { p,∼ p } = { p }. We need to show that XT is an RE-model of π while both XU and XF are not. The first property follows directly from the fact that p belongs to H+π and X\nT is an RE-model of p. The second property follows from Proposition 61 and Lemma 58. To show that the third is also satisfied, note that since XU is not an RE-model of π, the rule πJ∪{ p } coincides with the rule H+π ← B+π . This implies that B−π is disjoint with J ∪{ p } and H−π is included in J ∪{ p }. As a consequence, B−π is also disjoint with J \\{ p }. Moreover, from our assumptions we know that Hπ ∩ { p,∼ p } = { p }, which means that p does not belong to H−π . Thus, H−π is included in J \\ { p }.\nAs a consequence, the rule πJ\\{ p } also coincides with the rule H+π ← B+π . Furthermore, since XU is not an RE-model of π, J \\ { p } is not a model of πJ∪{ p }. Since πJ∪{ p } = πJ\\{ p }, we obtain that J \\ { p } is not a model of πJ\\{ p }. Hence XF is not an RE-model of π.\nNext, suppose that V is F and Hπ ∩ { p,∼ p } = {∼ p }. We need to show that XF is an RE-model of π while both XU and XT are not. The first property follows directly from the fact that p belongs to H−π but does not belong to J \\ { p } because in this case πJ\\{ p } coincides with τ . The second property follows from Proposition 61 and Lemma 58. To show that the third is also satisfied, note that since XU is not an RE-model of π, the rule πJ∪{ p } coincides with the rule H+π ← B+π and J \\ { p } is not a model of πJ∪{ p }, i.e. J \\ { p } includes B+π but does not contain any atom from H+π . Thus, J ∪ { p } also includes B+π and from our assumption that Hπ ∩ { p,∼ p } = {∼ p } we can conclude that p does not belong to H+π . Thus, J ∪ { p } does not contain any atom from H+π and, consequently, XT is not an RE-model of π.\nProposition 64. Let π and σ be non-disjunctive rules,M = [[π ]]RE, N = [[σ ]]RE, and J an interpretation. ThenM 1Jp N if and only if for some L ∈ { p,∼ p }, Hπ = {L }, Hσ = {L }, J is a model of both Bπ and Bσ, and Bπ, Bσ do not contain p nor ∼ p.\nProof. Follows directly from Proposition 63.\nAppendix B.2. Syntactic Properties of δa-Based Operators\nDefinition 65. Let δ be a local exception function, M ⊆ X and S ⊆ 2X. We define augδ(M,S) = M∪ ⋃ N∈S δ(M,N ) and extend this definition to sequences of sets of sets of three-valued interpretations inductively as follows: augδ(M, 〈〉) =M and augδ(M, 〈Si〉i<n+1) = augδ(augδ(M, 〈Si〉i<n),Sn).\nProposition 66. Let R = 〈Ri〉i<n be a sequence of rule bases, Si = 〈〈Ri〉〉RE for all i < n, and⊕ a δ-based rule update operator. Then, 〈〈 ⊕ R〉〉RE = { augδ(M, 〈Sj〉i<j<n) | i < n ∧M ∈ Si }.\nProof. Follows by induction on n.\nLemma 67. LetM⊆ X, S = 〈Si〉i<n where Si ⊆ 2X for all i < n, J an interpretation and p an atom. If (J, J) belongs to augδa(M,S), but (J \\ { p } , J) does not, then (J, J) belongs toM.\nProof. Follows by induction on n.\nProposition 68. Every δa-based rule update operator respects support.\nProof. Let ⊕ be some δa-based rule update operator, pick some DLP P = 〈Pi〉i<n, suppose that J is a stable model of ⊕ P and take some p ∈ J . We need to show that for some rule π ∈ all(P ), p ∈ Hπ and\nJ |= Bπ. Since J is a stable model of ⊕ P , we know that (J, J) belongs to [[ ⊕\nP ]]RE and for all I ( J , (I, J) does not belong to [[ ⊕ P ]]RE. In particular, (J\\{ p } , J) does not belong to [[ ⊕ P ]]RE. Consequently,\nthere is someN ∈ 〈〈 ⊕\nP 〉〉RE such that (J \\{ p } , J) does not belong toN although (J, J) does. According to Proposition 66, N = augδ (M, 〈〈〈Pj〉〉RE〉i<j<n) whereM ∈ 〈〈Pi〉〉RE for some i < n. Let π be a rule from Pi such that [[π ]]RE =M. Since (J \\ { p } , J) does not belong to N , it cannot belong toM sinceM is a subset ofN . Also, by Lemma 67, (J, J) belongs toM. Thus, it follows from Corollary 62 that p ∈ Hπ and J |= Bπ.\nLemma 69. Let P be a finite sequence of sets of facts and L a literal. Then,\naugδa([[L. ]]RE, 〈〈P 〉〉RE) = { X (L.) ∈ all(P ) ; [[L. ]]RE otherwise .\nProof. Follows using Proposition 64 by induction on the length of P .\nCorollary 70. Let P = 〈Pi〉i<n be a finite sequence of sets of facts and⊕ a δa-based rule update operator. Then, 〈〈 ⊕ P 〉〉RE ∪ {X } = { [[L. ]]RE | ∃i < n : (L.) ∈ Pi ∧ (∀j : i < j < n⇒ (L.) /∈ Pj) } ∪ {X }.\nProof. By Proposition 66, 〈〈P 〉〉RE = { augδ([[π ]]RE, 〈〈〈Pj〉〉RE〉i<j<n) | i < n ∧ π ∈ Pi }, which can also be written as { augδ([[L. ]]RE, 〈〈〈Pj〉〉RE〉i<j<n) | i < n ∧ (L.) ∈ Pi }. Furthermore, due to Lemma 69, we can equivalently write this as{\nX ∣∣ ∃i, j, L : i < j < n ∧ (L.) ∈ Pi ∧ (L.) ∈ Pj }\n∪ { [[L. ]]RE ∣∣ ∃i < n : (L.) ∈ Pi ∧ (∀j : i < j < n⇒ (L.) /∈ Pj) } .\nThis directly implies the desired conclusion.\nProposition 71. Every δa-based rule update operator respects fact update.\nProof. Let P = 〈Pi〉i<n be a finite sequence of consistent sets of facts, J the interpretation\n{ p | ∃i < n : (p.) ∈ Pi ∧ (∀j : i < j < n⇒ (∼ p.) /∈ Pj) }\nand ⊕ a δa-based rule update operator. We need to show that J is the unique stable model of ⊕\nP . We start by proving that (J, J) belongs to [[ ⊕ P ]]RE. Pick someM ∈ 〈〈 ⊕ P 〉〉RE. By Corollary 70 we\nknow thatM is either X, or it is equal to [[L. ]]RE where\n∃i < n : (L.) ∈ Pi ∧ (∀j : i < j < n⇒ (L.) /∈ Pj) .\nIn the former case it trivially holds that (J, J) belongs toM = X. Now suppose that L is an atom p. Then, by its definition, J contains p, so (J, J) belongs to [[p. ]]RE =M. On the other hand, if L is a default literal ∼ p, then the fact (p.) does not belong to Pi because Pi is consistent, and it also does not belong to Pj for any j with i < j < n. So p does not belong to J and, hence, (J, J) belongs to [[∼ p. ]]RE =M.\nNow suppose that (I, J) belongs to [[ ⊕ P ]]RE and take some p ∈ J . Then,\n∃i < n : (p.) ∈ Pi ∧ (∀j : i < j < n⇒ (∼ p.) /∈ Pj) ,\nso, by Corollary 70, [[p. ]]RE belongs to 〈〈 ⊕ P 〉〉RE. Since (I, J) belongs to [[ ⊕\nP ]]RE, it must also belong to [[p. ]]RE. Thus, p belongs to I and as the choice of p ∈ J was arbitrary, we can conclude that I = J . As a consequence, J is indeed a stable model of ⊕ P .\nIt remains to prove that J is the only stable model of ⊕ P . Suppose that J ′ is a stable model of ⊕\nP and take some p ∈ J . We will show that p belongs to J ′. We know that\n∃i < n : (p.) ∈ Pi ∧ (∀j : i < j < n⇒ (∼ p.) /∈ Pj) ,\nso, by Corollary 70, [[p. ]]RE belongs to 〈〈 ⊕ P 〉〉RE. Since J ′ is a stable model of ⊕\nP , (J ′, J ′) belongs to [[ ⊕\nP ]]RE and, consequently, also to [[p. ]]RE. Thus, p must belong to J ′. Now take some atom p that does not belong to J . We will show that p does not belong to J ′ either. There are two cases to consider:\na) If (p.) does not belong to Pi for all i < n, then it can be seen that (J ′ \\ { p } , J ′) belongs to all elements of 〈〈 ⊕ P 〉〉RE. Thus, since J ′ is a stable model of ⊕ P , J ′ \\ { p } = J ′ and, consequently,\np does not belong to J ′.\nb) If (p.) belongs to Pi0 for some i0 < n and whenever (p.) belongs to Pi for some i, there is some j with i < j < n such that (∼ p.) belongs to Pj , then there must exist some i1 such that (∼ p.) belongs to Pi1 and for all j with i1 < j < n, (p.) does not belong to Pj . Consequently, [[∼ p. ]]RE belongs to 〈〈 ⊕ P 〉〉RE. Thus, since (J ′, J ′) belongs to [[ ⊕ P ]]RE, it follows that p cannot belong to J ′.\nProposition 72. Let P = 〈P,U〉 be a dynamic logic program, ⊕ a δa-based rule update operator and J an interpretation. If J is a stable model of ⊕ P , then J is a JU-model of P .\nProof. From the assumption we can conclude that (J, J) is an RE-model of P ⊕ U and for every I ( J , (I, J) is not an RE-model of P ⊕ U .\nWe need to show that J is a minimal model of the program Q = [all(P ) \\ rej(P , J)]J . First we prove that J is a model of Q. Take some rule π′ ∈ Q and let π be a rule from [all(P ) \\ rej(P , J)] such that π′ = πJ . We consider two cases:\na) If π belongs to U , then since (J, J) belongs to [[P⊕U ]]RE and 〈〈P⊕U〉〉RE contains [[π ]]RE, (J, J) must also belong to [[π ]]RE. Thus, J is a model of π and consequently also a model of π′ = πJ .\nb) If π belongs to P \\ rej(P , J), then since (J, J) belongs to [[P ⊕ U ]]RE and 〈〈P ⊕ U〉〉RE contains [[π ]]RE∪ ⋃ σ∈U δa([[π ]]RE, [[σ ]]RE), (J, J) must also belong to [[π ]]RE∪ ⋃ σ∈U δa([[π ]]RE, [[σ ]]RE). Suppose\nfirst that for some rule σ ∈ U , (J, J) belongs to the set δa([[π ]]RE, [[σ ]]RE). This implies that [[π ]]RE 1Jp [[σ ]]RE for some atom p and by Proposition 64 we can conclude that π belongs to rej(P , J), contrary to the assumption. Thus, (J, J) does not belong to the set ⋃ σ∈U δa([[π ]]RE, [[σ ]]RE) and, consequently, it belongs to [[π ]]RE. Hence, J is a model of π and, consequently, it is also a model of π′ = πJ .\nIt remains to prove that J is a minimal model of Q. Take some model I of Q such that I is a subset of J . We need to show that I = J . In the following we will show that (I, J) is a member of the set [[P⊕U ]]RE which, together with the assumption that J is a stable model of P ⊕ U , implies that I = J .\nSo in order to finish the proof, take some setM from 〈〈P ⊕ U〉〉RE. We need to show that (I, J) belongs toM. Recall that 〈〈P ⊕ U〉〉RE = { [[π ]]RE ∪ ⋃ σ∈U δa([[π ]]RE, [[σ ]]RE) | π ∈ P } ∪ 〈〈U〉〉RE. IfM belongs to 〈〈U〉〉RE, then there is some rule π ∈ U such thatM = [[π ]]RE. Moreover, πJ belongs to Q, so I is a model of πJ . It then follows that (I, J) is an RE-model of π, i.e. that (I, J) belongs toM, as we wanted to show.\nThe remaining case is when for some π ∈ P, M = [[π ]]RE ∪ ⋃ σ∈U δa([[π ]]RE, [[σ ]]RE). Suppose that (I, J) does not belong to [[π ]]RE. Then I is not a model of πJ . Since I is a subset of J , we can conclude from this that\nJ |= Bπ . (B.1)\nFurthermore, from our assumption that I is a model of Q it then follows that πJ does not belong to Q and, consequently, π belongs to rej(P , J). So there must be some rule σ ∈ U such that Hσ = Hπ and J |= Bσ. Since we know from the previous part of the proof that J is a model of Q, we can conclude that J |= Hσ, so J 6|= Hπ.\nThus, it follows from (B.1) that J is not a model of π, so (J, J) is not an RE-model of π. But since J is a stable model of P⊕U , (J, J) must belong to δa([[π ]]RE, [[σ′ ]]RE) for some σ′ ∈ U and from the definition of δa(·, ·) we obtain that (I, J) also belongs to δa([[π ]]RE, [[σ′ ]]RE). This implies that (I, J) belongs toM.\nProposition 73. Let P = 〈P,U〉 be a DLP free of local cycles, ⊕ a δa-based rule update operator and J an interpretation. If J is a JU-model of P , then J is a stable model of ⊕ P.\nProof. Suppose that J is a justified update model of 〈P,U〉. Then it is a minimal model of the program Q = [all(P ) \\ rej(P , J)]J . We need to prove that (J, J) is an RE-model of P ⊕ U and for every I ( J , (I, J) is not an RE-model of P ⊕ U . In order to show that (J, J) is an RE-model of P ⊕ U , recall that\n〈〈P⊕U〉〉RE = { [[π ]]RE ∪ ⋃ σ∈U δa([[π ]]RE, [[σ ]]RE) ∣∣ π ∈ P }∪〈〈U〉〉RE and take some setM from 〈〈P⊕U〉〉RE. IfM belongs to 〈〈U〉〉RE, then there is a rule π ∈ U such thatM = [[π ]]RE. Also, πJ belongs to Q, so J is a model of πJ . Consequently, (J, J) belongs toM.\nNow suppose that for some π from P,M = [[π ]]RE ∪ ⋃ σ∈Q δa([[π ]]RE, [[σ ]]RE). If (J, J) does not belong to [[π ]]RE, then J is not a model of πJ , so π belongs to rej(P , J). So there exists a rule σ from U such that Hσ = Hπ and J |= Bσ. The previous conclusions, together with the fact that π and σ are not local cycles, allow us to use Proposition 64 and conclude that [[π ]]RE 1Jp [[σ ]]RE holds for some atom p. Hence, (J, J) belongs to δa([[π ]]RE, [[σ ]]RE), and consequently also toM.\nNow suppose that (I, J) belongs to [[π ]]RE. We will show that I is a model of Q, which implies that I = J because J is by assumption a minimal model of Q. Take some rule π′ from Q and suppose that π′ = πJ for some π ∈ [all(P ) \\ rej(P , J)]. If π belongs to U , then [[π ]]RE belongs to 〈〈P ⊕ U〉〉RE. Consequently, (I, J) belongs to [[π ]]RE, so I is a model of π′.\nThe final case to consider is when π belongs to P. We will prove by contradiction that I is a model of π′. So suppose that I is not a model of π′. Then (I, J) is not an RE-model of π. However, since by assumption (I, J) belongs to [[P ⊕ U ]]RE, it must also belong to the set [[π ]]RE ∪ ⋃ σ∈U δa([[π ]]RE, [[σ ]]RE). We have already shown that it is not a member of [[π ]]RE, so there must exist some σ ∈ U such that (I, J) belongs to δa([[π ]]RE, [[σ ]]RE). Thus, [[π ]]RE 1Jp [[σ ]]RE holds for some atom p. We can use Proposition 64 to conclude that Hσ = Hπ and J |= Bσ. Hence, π belongs to rej(P , J), contrary to our assumption.\nProof of Theorem 19. Follows from Propositions 68, 71, 72, 73 and the fact that the JU-semantics has these properties.\nAppendix B.3. Syntactic Properties of δb- and δc-Based Operators\nDefinition 74. We say thatM⊆ X is RE-rule-expressible if there exists a rule π such thatM = [[π ]]RE.\nLemma 75. LetM ⊆ X be RE-rule-expressible, S a set of RE-rule-expressible sets of three-valued interpretations, J an interpretation, p an atom, V0 a truth value and δ ∈ { δb, δc }. If augδ(M,S)J(p) = V0, thenMJ(p) = V0.\nProof. Suppose that augδ(M,S)J(p) = V0. By the definition we then obtain that for all truth values V,\nJ [V/p] ∈ augδ(M,S) if and only if V = V0 . (B.2)\nIf the interpretation J [V0/p] belongs toM, then we can use (B.2) together with the fact thatM is a subset of augδ(M,S) to conclude thatMJ(p) = V0 and our proof ends.\nSo suppose that J [V0/p] does not belong toM. Then it follows from (B.2) and from the fact thatM is a subset of augδ(M,S) that the interpretations J [T/p], J [U/p] and J [F/p] do not belong toM. Thus, since J [V0/p] belongs to augδ(M,S), there must exist some N ∈ S such that J [V0/p] = (I,K) belongs to δ(M,N ). In other words, there exists an atom q and an interpretation J ′ such that I ⊆ J ′ ⊆ K and MJ ′(q) 6= N J ′(q). Note that J \\ { p } ⊆ I ⊆ J ′ ⊆ K ⊆ J ∪ { p }. Thus, (J ′, J ′) = J [V1/p] for some V1 ∈ {T,F }. We distinguish two cases:\na) If p 6= q, then by the definition of δb and δc we obtain that J [V1/p], J [U/p] ∈ δ(M,N ). b) If p = q, let V2 = T is V1 = F and V2 = F if V1 = T. It follows thatMJ [V2/p](p) 6= N J [V2/p](p)\nand by the definition of δb and δc we obtain that J [V1/p], J [V2/p] ∈ δ(M,N ). In either case, it is not possible fo augδ(M,S)J(p) to be defined, a conflict with our assumption.\nProposition 76 (Exception Independence for Rules). LetM⊆ X be RE-rule-expressible by a non-disjunctive rule, S , T be sets of RE-rule-expressible sets of three-valued interpretations and δ ∈ { δb, δc }. Then, augδ(augδ(M,S), T ) = augδ(M,S ∪ T ).\nProof. By applying the definition of augδ(·, ·) we can see that our goal is to show that the set augδ(M,S) ∪ ⋃ N∈T δ(augδ(M,S),N ) (B.3)\nis equal to the setM∪ ⋃ N∈S∪T δ(M,N ) which can also be written as\naugδ(M,S) ∪ ⋃ N∈T δ(M,N ) . (B.4)\nFirst suppose that some X ∈ X belongs to (B.3). If X belongs to augδ(M,S), then it directly follows that X also belongs to (B.4). So suppose that X belongs to δ(augδ(M,S),N ) for some N ∈ T . By the definition of δb and δc we obtain that there exists some atom p and some interpretation J with certain properties relative to X such that augδ(M,S)J(p) 6= N J(p). By Lemma 75 we then conclude that augδ(M,S)J(p) =MJ(p). Thus, X also belongs to δ(M,N ) and, consequently, also to the set (B.4).\nNow suppose that someX = (I,K) ∈ X belongs to (B.4). The case whenX belongs to augδ(M,S) is trivial, so we assume that X belongs to δ(M,N ) for some N ∈ T . This implies that there exists an atom p and some interpretation J such that I ⊆ J ⊆ K andMJ(p) 6= N J(p). Suppose thatMJ(p) = V0. If it also holds that augδ(M,S)J(p) = V0, then it can be seen that X belongs to (B.3). Otherwise it follows from the fact that M is a subset of augδ(M,S) that augδ(M,S)J(p) is undefined and it contains both J [V0/p] and J [V1/p] = (I ′,K ′) for some V1 6= V0. Thus, for some N ′ ∈ S it holds that (I ′,K ′) belongs to δ(M,N ′). In other words, there exists an atom q and an interpretation J ′ such that I ′ ⊆ J ′ ⊆ K ′ andMJ ′(q) 6= N ′J ′(q). SinceM is expressible by a non-disjunctive rule, it follows from Proposition 63 that q = p. Also, J and J ′ may only differ in the valuation of p, so we obtain that MJ(p) 6= N ′J(p). Consequently, X belongs to δ(M,N ′), so it also belongs to (B.3).\nDefinition 77. Let P = 〈Pi〉i<n be a DLP. We define afteri(P ) = ⋃ i<j<n Pj .\nProposition 78 (Exception Independence for Programs). Let P = 〈Pi〉i<n be a DLP, δ ∈ { δb, δc } and ⊕ a δ-based rule update operator. Then, 〈〈 ⊕ P 〉〉RE = { augδ(M, 〈〈afteri(P )〉〉RE) | i < n ∧M ∈ 〈〈Pi〉〉RE }.\nProof. By Proposition 66, 〈〈 ⊕\nP 〉〉RE = { augδ(M, 〈〈〈Pj〉〉RE〉i<j<n) | i < n ∧M ∈ 〈〈Pi〉〉RE }. The claim follows by induction on n using Proposition 76.\nProposition 79. Let P be a DLP and J an interpretation. The following holds: (i) If ⊕ is a δb-based rule update operator and J is a stable model of ⊕ P , then J is a JU-model of P .\n(ii) If ⊕ is a δc-based rule update operator and J is a stable model of ⊕ P , then J is a UA-model of P .\nProof. Let P = 〈Pi〉i<n. Also, put rej(·, ·) = rejJU(·, ·) if δ = δb and rej(·, ·) = rejUA(·, ·) if δ = δc. From the assumption we can conclude that (J, J) belongs to [[ ⊕ P ]]RE and for every I ( J , (I, J) does not\nbelong to [[ ⊕\nP ]]RE. We need to show that J is a minimal model of the program P′ = [all(P )\\ rej(P , J)]J . First we prove that J is a model ofP′. Take some rule π′ ∈ P′ and let π be a rule from all(P )\\rej(P , J) such that π′ = πJ . Then there is some i < n such that π belongs to Pi. LetM = [[π ]]RE. Since π belongs to Pi, we can use Proposition 78 to conclude that 〈〈 ⊕ P 〉〉RE contains the set\naugδ(M, 〈〈afteri(P )〉〉RE) =M∪ ⋃\nN∈〈〈afteri(P )〉〉RE\nδ(M,N ) . (B.5)\nFurthermore, since (J, J) belongs to [[ ⊕\nP ]]RE, it must also belong to (B.5). If (J, J) ∈ M, then J |= π and thus also J |= π′ as desired. So suppose that (J, J) /∈M. Then for some j with i < j < n there exists some N ∈ 〈〈Pj〉〉RE such that (J, J) ∈ δ(M,N ). Thus, for some atom p,M 1Jp N , and by Proposition 64 we conclude that there is a rule σ ∈ Pj with [[σ ]]RE = N , Hσ = Hπ and J |= Bσ. We consider two cases:\na) If δ = δb, then the assumption π /∈ rejJU(P , J) is in direct conflict with the existence of σ. b) If δ = δc, then it follows from π /∈ rejUA(P , J) that σ ∈ rejUA(P , J). Thus, there is some rule\nρ ∈ (Pk \\ rejUA(P , J)) with j < k < n such that Hρ = Hσ = Hπ and J |= Bρ. It follows from ρ /∈ rejUA(P , J) that no rule from afterk(P ) has the head Hρ and a body satisfied in J . Thus, the definition of δc and Proposition 64 imply that the set δc([[ρ ]]RE,N ) is empty for all N ∈ 〈〈afterk(P )〉〉RE. But since (J, J) belongs to [[ ⊕ P ]]RE by assumption, it must also belong to\nthe set [[ρ ]]RE ∪ ⋃ N∈〈afterk(P )〉RE δc([[ρ ]]RE,N ) and we conclude that (J, J) ∈ [[ρ ]]RE. Consequently, J |= ρ and from J |= Bρ we conclude J |= Hρ. Since Hπ = Hρ, we have shown that J |= π and thus also J |= π′, as desired.\nIt remains to prove that J is a minimal model of P′. Take some I ⊆ J such that I |= P′, we need to show that I = J . In the following we will show that (I, J) ∈ [[ ⊕ P ]]RE which, together with the\nassumption that J is a stable model of ⊕ P , implies that I = J . So take some set\naugδ(M, 〈〈afteri(P )〉〉RE) =M∪ ⋃\nN∈〈〈afteri(P )〉〉RE\nδ(M,N ) . (B.6)\nfrom 〈〈 ⊕\nP 〉〉RE with M = [[π ]]RE and π ∈ Pi. We need to show that (I, J) belongs to (B.6). This obviously holds if (I, J) ∈ M, so suppose that (I, J) /∈ M. Then, I 6|= πJ . Thus, πJ is different from τ and, consequently, J |= B−π . Also, B+π ⊆ I but H+π ∩ I = ∅ and since I ⊆ J , this implies that\nJ |= Bπ . (B.7)\nMoreover, since I |= P′, it follows that πJ /∈ P′, so π ∈ rej(P , J). Thus, there exists a rule σ ∈ Pj for some j with i < j < n such that for some atom p and literal L ∈ { p,∼ p },\nHπ = {L } and Hσ = {L } and J |= Bσ . (B.8)\nLet N = [[σ ]]RE. We consider the following five cases: a) If L ∈ Bπ, then π is tautological and we arrive at a conflict with the assumption (I, J) /∈ [[π ]]RE. b) If L ∈ Bπ, then it follows from (B.7) and (B.8) that (J, J) /∈ [[π ]]RE. At the same time, δ(M,N )\nis empty for all N because for all interpretations J ′ and atoms q, it is impossible forMJ ′(q) to be defined. Thus, we obtain a conflict with the assumption that (J, J) ∈ [[ ⊕ P ]]RE. c) If L ∈ Bσ, then it follows from (B.8) that (J, J) /∈ [[σ ]]RE. At the same time, δ(N ,N ′) is empty for all N ′ because for all interpretations J ′ and atoms q, it is impossible for N J ′(q) to be defined. Thus, we obtain a conflict with the assumption that (J, J) ∈ [[ ⊕ P ]]RE.\nd) If L ∈ Bσ, then it follows from (B.8) that J |= L and together with (B.7) we obtain that J 6|= π. Thus, (J, J) /∈ [[π ]]RE and since (J, J) ∈ [[ ⊕ P ]]RE, there must exist some N ′ ∈ 〈〈afteri(P )〉〉RE such\nthat (J, J) ∈ δ(M,N ′). It follows from the definitions of δb and δc that (I, J) ∈ δ(M,N ′), and thus also (I, J) ∈ augδ(M, 〈〈afteri(P )〉〉RE).\ne) In the remaining case, Bπ and Bσ do not contain L nor L. Thus, we can use Proposition 64 to conclude that M 1Jp N . Note that if δ = δc, then the definition of rejUA(·, ·) implies that σ /∈\nrejUA(P , J), so J |= σ. Using (B.8) and (B.7) we can conclude that J 6|= π, so (J, J) /∈ M. Consequently, by the definitions of δb and δc it follows that (I, J) ∈ δ(M,N ), and thus also (I, J) ∈ augδ(M, 〈〈afteri(P )〉〉RE).\nProposition 80. Let P be a DLP free of local cycles and J an interpretation. The following holds: (i) If ⊕ is a δb-based rule update operator and J is a JU-model of P , then J is a stable model of ⊕ P .\n(ii) If ⊕ is a δc-based rule update operator and J is a UA-model of P , then J is a stable model of ⊕ P .\nProof. Let P = 〈Pi〉i<n. Also, put rej(·, ·) = rejJU(·, ·) if δ = δb and rej(·, ·) = rejUA(·, ·) if δ = δc. From the assumption we can conclude that J is a minimal model of the program P′ = [all(P ) \\ rej(P , J)]J . We need to prove that (J, J) ∈ [[ ⊕ P ]]RE and for every I ( J , (I, J) /∈ [[ ⊕ P ]]RE.\nIn order to show that (J, J) ∈ [[ ⊕ P ]]RE, take some set\naugδ(M, 〈〈afteri(P )〉〉RE) =M∪ ⋃\nN∈〈〈afteri(P )〉〉RE\nδ(M,N ) (B.9)\nfrom 〈〈 ⊕\nP 〉〉RE whereM = [[π ]]RE for some π ∈ Pi. If (J, J) belongs toM, then it obviously belongs to (B.9). So assume that (J, J) /∈M. Then J 6|= π, so\nJ |= Bπ , (B.10)\nand we can also conclude that π belongs to rej(P , J). As a consequence, there exists a rule σ from Pj for some j with i < j < n such that for some atom p and literal L ∈ { p,∼ p },\nHπ = {L } and Hσ = {L } and J |= Bσ . (B.11)\nLet N = [[σ ]]RE. It can be verified that (B.10) and (B.11), together with the assumption that π and σ are not local cycles, allow us to use Proposition 64 and conclude that for some atom p,M 1Jp N . Thus, (J, J) belongs to δ(M,N ), and consequently also to (B.9).\nNow suppose that (I, J) ∈ [[ ⊕\nP ]]RE. We will show that I |= P′, which implies that I = J because J is by assumption a minimal model of P′. Take some π′ ∈ P′. Then there is a rule π from all(P )\\ rej(P , J) such that π′ = πJ . Suppose that π ∈ Pi. We will prove by contradiction that I |= π′. So suppose that I 6|= π′. Then πJ is different from τ and, consequently, J |= B−π . Also, B+π is included in I , so since I is a subset of J , B+π is included in J as well. Hence,\nJ |= Bπ . (B.12) Also, (I, J) /∈ [[π ]]RE. By our assumption, (I, J) ∈ M ∪ ⋃ N∈〈〈afteri(P )〉〉RE δ(M,N ) whereM = [[π ]]RE. We have already shown that (I, J) /∈ M, so there must be a rule σ ∈ Pj for some j with i < j < n such that (I, J) ∈ δ(M,N ) where N = [[σ ]]RE. Thus, there exists some interpretation K and an atom p such that I ⊆ K ⊆ J , M 1Kp N and if p ∈ J \\ I , then J = K. By Proposition 64, there is a literal L ∈ { p,∼ p } such that Hπ = {L } and Hσ = {L }. We consider three cases:\na) If p /∈ J \\ I , then I(p) = J(p). Furthermore, J |= π because J |= P′ and from (B.12) we obtain that J |= Hπ. Thus, I |= πJ , a conflict with the assumption that I 6|= π′.\nb) If p ∈ J \\ I and δ = δb, then it follows from the definition of δb that J = K, soM 1Jp N . Thus, by Proposition 64 we conclude that π ∈ rej(P , J), contrary to the way π was picked.\nc) If p ∈ J \\ I and δ = δc, then the definition of δc implies that (J, J) /∈ [[π ]]RE, contrary to the assumption that J |= P′.\nAppendix B.4. Syntactic Properties of δd- and δe-Based Operators\nLemma 81. Let P be a DLP, ⊕b, ⊕c, ⊕d and ⊕e be δb-, δc-, δd- and δe-based rule update operators, respectively. Then the following holds:\n(i) IfM∈ 〈〈 ⊕ dP 〉〉RE, then eitherM = X orM∈ 〈〈 ⊕\nbP 〉〉RE; (ii) IfM∈ 〈〈 ⊕ eP 〉〉RE, then eitherM = X orM∈ 〈〈 ⊕ cP 〉〉RE.\nProof. Follows by induction on the length of P .\nLemma 82. Let P be a DLP, ⊕b, ⊕c, ⊕d and ⊕e be δb-, δc-, δd- and δe-based rule update operators, respectively. Then the following holds:\n(i) IfM∈ 〈〈 ⊕ bP 〉〉RE, then for some N ∈ 〈〈 ⊕\ndP 〉〉RE, N ⊆M; (ii) IfM∈ 〈〈 ⊕ cP 〉〉RE, then for some N ∈ 〈〈 ⊕ eP 〉〉RE, N ⊆M.\nProof. The following two stronger statements follow by induction on the length of P using Proposition 76: (i) IfM ∈ 〈〈 ⊕\nbP 〉〉RE, then for some set of RE-rule-expressible sets of three-valued interpretations S and some N ∈ 〈〈 ⊕ dP 〉〉RE,M = augδb(N ,S).\n(ii) IfM ∈ 〈〈 ⊕\ncP 〉〉RE, then for some set of RE-rule-expressible sets of three-valued interpretations S and some N ∈ 〈〈 ⊕ eP 〉〉RE,M = augδb(N ,S).\nProposition 83. Let P be a DLP, ⊕b, ⊕c, ⊕d and ⊕e be δb-, δc-, δd- and δe-based rule update operators, respectively. Then [[ ⊕ bP ]]SM = [[ ⊕ dP ]]SM and [[ ⊕ cP ]]SM = [[ ⊕ eP ]]SM.\nProof. By Lemma 81, 〈〈 ⊕ bP 〉〉RE ∪ {X } ⊇ 〈〈 ⊕ dP 〉〉RE and 〈〈 ⊕ cP 〉〉RE ∪ {X } ⊇ 〈〈 ⊕ eP 〉〉RE, so\n[[ ⊕ bP ]]RE = ⋂ 〈〈 ⊕ bP 〉〉RE = ⋂ (〈〈 ⊕ bP 〉〉RE ∪ {X }) ⊆ ⋂ 〈〈 ⊕ dP 〉〉RE = [[ ⊕ dP ]]RE ,\n[[ ⊕ cP ]]RE = ⋂ 〈〈 ⊕ cP 〉〉RE = ⋂ (〈〈 ⊕ cP 〉〉RE ∪ {X }) ⊆ ⋂ 〈〈 ⊕ eP 〉〉RE = [[ ⊕ eP ]]RE .\nFurthermore, by Lemma 82,\n[[ ⊕ bP ]]RE = ⋂ 〈〈 ⊕ bP 〉〉RE = ⋂\nM∈〈⊕bP 〉RE\nM⊇ ⋂\nN∈〈⊕dP 〉RE\nN = ⋂ 〈〈 ⊕ dP 〉〉RE = [[ ⊕ dP ]]RE ,\n[[ ⊕ cP ]]RE = ⋂ 〈〈 ⊕ cP 〉〉RE = ⋂\nM∈〈⊕cP 〉RE\nM⊇ ⋂\nN∈〈⊕eP 〉RE\nN = ⋂ 〈〈 ⊕ eP 〉〉RE = [[ ⊕ eP ]]RE .\nThus, [[ ⊕ bP ]]RE = [[ ⊕ dP ]]RE and [[ ⊕ cP ]]RE = [[ ⊕ eP ]]RE, and the rest follows from Proposition 15.\nProof of Theorem 23. Follows from Propositions 79, 80 and 83.\nProof of Theorem 22. Follows from Theorem 23 and from the fact that the JU- and UA-models satisfy all of these properties.\nProof of Corollary 24. It suffices to putR = ⊕ 〈Pi〉i≤j and apply Theorem 23.\nAppendix B.5. Semantic Properties\nProposition 84. Let ⊕ be a δ-based rule update operator. Then ⊕ satisfies (Initialisation), (Disjointness), (P1) and (P2.>) with respect to RR, SR, RMR, SMR, RE, SE and SM (where applicable).\nProof. We prove these properties with respect to RR-equivalence; their satisfaction with respect to the other notions of program equivalence follows from Proposition 15. To verify that (Initialisation) holds, it suffices to observe that\n〈〈∅ ⊕ U〉〉RE = { augδ(M, 〈〈U〉〉RE) | M ∈ ∅ } ∪ 〈〈U〉〉RE = 〈〈U〉〉RE .\nThus, ∅ ⊕ U is RR-equivalent to U . As for (Disjointness), it suffices to observe that 〈〈(R ∪ S) ⊕ U〉〉RE coincides with\n{ augδ (M, 〈〈U〉〉RE) | M ∈ R ∪ S } ∪ 〈〈U〉〉RE = ({ augδ (M, 〈〈U〉〉RE) | M ∈ R } ∪ 〈〈U〉〉RE) ∪ ({ augδ (M, 〈〈U〉〉RE) | M ∈ S } ∪ 〈〈U〉〉RE) = 〈〈R ⊕ U〉〉RE ∪ 〈〈S ⊕ U〉〉RE = 〈〈(R⊕ U) ∪ (S ⊕ U)〉〉RE .\nIn order to prove that (P1) holds, consider that 〈〈U〉〉RE is a subset of 〈〈R⊕U〉〉RE. Consequently,R⊕U |=RR U . Finally, (P2.>) follows from the fact that augδ(M, ∅) =M for allM⊆ X.\nLemma 85. Let P, Q be programs over disjoint alphabets and δ ∈ { δa, δb, δc, δd, δe }. Then for all M∈ 〈〈P〉〉RE, either augδ(M, 〈〈Q〉〉RE) =M or augδ(M, 〈〈Q〉〉RE) = X.\nProof. Follows from Proposition 63 and the definitions of δa, δb, δc, δd, and δe.\nLemma 86. Let M ⊆ X be RE-rule-expressible, U a program, p an atom and V0 a truth value. If augδa(M, 〈〈U〉〉RE) J(p) = V0, then eitherMJ(p) = V0, or p occurs in U .\nProof. Suppose that augδa(M, 〈〈U〉〉RE) J(p) = V0 and MJ(p) 6= V0. Thus, augδa(M, 〈〈U〉〉RE) contains J [V/p] if and only if V = V0. SinceM is a subset of augδa(M, 〈〈U〉〉RE), it follows thatM does not contain J [T/p], J [U/p] nor J [F/p]. Let π be some rule such that [[π ]]RE = M. We can conclude that p does not occur in π. Furthermore, if V0 = T, then by the definition of δa we obtain a conflict with the fact that J [U/p] does not belong to augδa(M, 〈〈U〉〉RE). Consequently, V0 = F. Furthermore, since J [T/p] does not belong to augδa(M, 〈〈U〉〉RE) but J [F/p] does, there exists some N ∈ 〈〈U〉〉RE and some atom q such that M 1J [F/p]q N but it is not the case thatM 1J [T/p]q N . Since p does not occur in π, this is only possible if p occurs in U .\nProposition 87. Let ⊕ be a δa-, δb-, δc, δdor δe-based rule update operator. Then ⊕ satisfies (Noninterference) for non-disjunctive programs with respect to RR, SR, RMR, SMR, RE, SE and SM.\nProof. We prove this property with respect to RR-equivalence; its satisfaction with respect to the other notions of program equivalence follows from Proposition 15. Suppose that P, U and V are non-disjunctive programs, δ ∈ { δa, δb, δc, δd, δe } and ⊕ is a δ-based rule update operator. Take someM0 ∈ 〈〈(P ⊕ U) ⊕ V〉〉RE. We will show thatM0 either belongs to 〈〈(P ⊕ V)⊕ U〉〉RE orM0 = X. Note that 〈〈(P ⊕ U)⊕ V〉〉RE coincides with { augδ (M, 〈〈V〉〉RE) | M ∈ 〈〈P ⊕ U〉〉RE } ∪ 〈〈V〉〉RE. We consider three cases:\na) Suppose that M0 ∈ 〈〈V〉〉RE. Then M0 ∈ 〈〈P ⊕ V〉〉RE and since 〈〈(P ⊕ V) ⊕ U〉〉RE coincides with { augδ(M, 〈〈U〉〉RE) | M ∈ 〈〈P ⊕ V〉〉RE }∪〈〈U〉〉RE, it must contain the set augδ(M0, 〈〈U〉〉RE). Furthermore, since U and V are over disjoint alphabets, it follows from Lemma 85 that augδ(M0, 〈〈U〉〉RE) is eitherM0 or X, as desired.\nb) Suppose that M0 = augδ(M, 〈〈V〉〉RE) and M ∈ 〈〈U〉〉RE. As in the previous case, since U and V are over disjoint alphabets, it follows from Lemma 85 that augδ(M, 〈〈V〉〉RE) is eitherM or X. If the former is true, thenM0 ∈ 〈〈U〉〉RE, soM0 ∈ 〈〈(P ⊕ V)⊕ U〉〉RE.\nc) Suppose thatM0 = augδ (augδ (M, 〈〈U〉〉RE) , 〈〈V〉〉RE) for someM∈ 〈〈P〉〉RE. If δ ∈ { δb, δc }, then it follows directly from Proposition 76 that\nM0 = augδ (M, 〈〈U〉〉RE ∪ 〈〈V〉〉RE) = augδ (augδ (M, 〈〈V〉〉RE) , 〈〈U〉〉RE) .\nConsequently,M0 ∈ 〈〈(P ⊕ V)⊕ U〉〉RE. If δ ∈ { δd, δe }, then eitherM0 = X orM0 = augδb ( augδb (M, 〈〈U〉〉RE) , 〈〈V〉〉RE ) . The rest follows by the previous paragraph. Finally, if δ = δa, then we consider two subcases:\n(i) If augδa(M, 〈〈U〉〉RE) =M, thenM0 = augδa(M, 〈〈V〉〉RE), soM0 belongs to 〈〈P⊕V〉〉RE. Take some N ∈ 〈〈U〉〉RE and suppose that M0 1pJ N . Then, by Lemma 86, either MJ(p) = V0 for some truth value V0, or p occurs in V . In the former case we obtain a conflict with the assumption that augδa(M, 〈〈U〉〉RE) =M while the latter case is in conflict with the assumption that U and V are over disjoint alphabets. Thus, no suchN exists and augδa(M0, 〈〈U〉〉RE) =M0. Consequently,M0 belongs to 〈〈(P ⊕ V)⊕ U〉〉RE. (ii) If augδa(M, 〈〈U〉〉RE) 6= M, then there is some N ∈ 〈〈U〉〉RE such that M 1 p J N for some\natom p and interpretation J . Thus since U and V are over disjoint alphabets, it follows from Proposition 64 that augδa(M, 〈〈V〉〉RE) =M, so augδa(M, 〈〈U〉〉RE) belongs to 〈〈(P⊕V)⊕U〉〉RE. It remains to show thatM0 = augδa(M, 〈〈U〉〉RE). PutM1 = augδa(M, 〈〈U〉〉RE) and suppose that for some N ′ ∈ 〈〈V〉〉RE, some atom q and some interpretation K, M1 1Kq N ′. Then, by Lemma 86, eitherMK(q) = V0 for some truth value V0, or q occurs in U . In the former case, p = q by Proposition 64 and we obtain a conflict with the fact that U and V are over disjoint alphabets. In the latter case, q occurs in both U and V , so the same conflict follows. Consequently, no such N ′ exists and M0 = augδa ( augδa (M, 〈〈U〉〉RE) , 〈〈V〉〉RE ) = augδa (M1, 〈〈V〉〉RE) =\naugδa (M, 〈〈U〉〉RE). The proof of the other inclusion is symmetric.\nRemark 88 ((Non-interference) for Disjunctive Programs). The following programs form a counterexample to (Non-interference) for δb-, δc-, δd- and δe-based operators under SM-equivalence (and thus under all stronger notions of equivalence as well):\nP : p; q; r. U : ∼ p← ∼ r. V : ∼ q. p← r. r ← p.\nAs for δa-based operators, the singleton programsP′ = { p; q. }, U ′ = {∼ p← ∼ r. } and V ′ = {∼ q ← s. } form a counterexample to (Non-interference) under SE-equivalence and all stronger notions of equivalence.\nProposition 89. Let ⊕ be a δ-based rule update operator where δ(M,X) ⊆ M for allM ⊆ X. Then ⊕ satisfies (Tautology) and (Immunity to Tautologies) with respect to RR, SR, RMR, SMR, RE, SE and SM.\nProof. For RR-equivalence this can be verified in a straight-forward manner. For the remaining notions of program equivalence this follows from Proposition 15.\nProposition 90. Let ⊕ be a δ-based rule update operator. Then ⊕ satisfies (Idempotence) with respect to RMR, SMR, RE, SE and SM. Moreover, if ⊕ is δd- or δe-based, then it also satisfies (Idempotence) with respect to RR and SR.\nProof. (Idempotence) states the following: R⊕R ≡ R. We will show that this is true under RMR-equivalence which, together with Proposition 15, implies that it holds under SMR-, RE-, SE- and SM-equivalence.\nFirst take some M ∈ min〈〈(R ⊕ R) ∪ { τ }〉〉RE. If M = X, then R ⊕ R is tautological and since 〈〈R〉〉RE is a subset of 〈〈R ⊕ R〉〉RE, R is itself tautological. Thus, X also belongs to min〈〈R ∪ { τ }〉〉RE. In the principal case, eitherM ∈ 〈〈R〉〉RE, orM = augδ(M0, 〈〈R〉〉RE) for someM0 ∈ 〈〈R〉〉RE. In the latter case we have thatM0 is a subset ofM and sinceM0 belongs to 〈〈R ⊕R〉〉RE, by the minimality ofM we obtain thatM =M0, soM belongs to 〈〈R〉〉RE. Now it follows thatM is minimal 〈〈R〉〉RE because 〈〈R〉〉RE is a subset of 〈〈R ⊕R〉〉RE andM is minimal in the latter set.\nNow take some M ∈ min〈〈R ∪ { τ }〉〉RE. If M = X, then R is tautological and it follows by the properties of⊕ thatR⊕R is also tautological. Thus, X also belongs to 〈〈(R⊕R)∪{ τ }〉〉RE. In the principal case,M ∈ 〈〈R〉〉RE. Take some N ∈ 〈〈R ⊕ R〉〉RE such that N is a subset ofM. If N belongs to 〈〈R〉〉RE, then it follows by minimality ofM thatM = N . On the other hand, if N is of the form augδ(N0, 〈〈R〉〉RE) for someN0 from 〈〈R〉〉RE, thenN0 ⊆ N ⊆M, so by the minimality ofM,N0 = N =M. Thus, in either case,M = N , which proves that it is minimal within 〈〈R ⊕R〉〉RE.\nNow consider some δd- or δe-based rule update operator ⊕. Then, 〈〈R ⊕ R〉〉RE ⊆ 〈〈R〉〉RE ∪ {X }, so obviously 〈〈(R⊕R) ∪ { τ }〉〉RE = 〈〈R ∪ { τ }〉〉RE.\nRemark 91 ((Idempotence) under ≡SR and ≡RR). The rule base R = { (p← ∼ q.), (∼ p← r.) } forms a counterexample to (Idempotence) for δa-, δb- and δc-based operators with respect to SR and RR.\nLemma 92. LetM ⊆ X be RE-rule-expressible, S a set of RE-rule-expressible sets of three-valued interpretations. The following holds:\n(i) If δ ∈ { δb, δc }, then augδ(augδ(M,S),S) = augδ(M,S). (ii) If δ ∈ { δd, δe }, then either augδ(augδ(M,S),S) = augδ(M,S), or both augδ(augδ(M,S),S) =\nX and augδ(M,S) ∈ S.\nProof. Let δ ∈ { δb, δc }, putM′ = augδ(M,S) and take someN ∈ S such thatM′ 1 p J N for some atom p and some interpretation J . ThenM′J(p) = V0 for some truth value V0, so it follows from Lemma 75 that MJ(p) = V0. But this impliesM 1pJ N , so both (J \\ { p } , J \\ { p }) and (J ∪ { p } , J ∪ { p }) belong toM′, a conflict with the assumption thatM′J(p) is defined. As a consequence, no such N ∈ S exists, so augδ(M′,S) =M′ = augδ(M,S).\nOn the other hand, if δ ∈ { δd, δe }, then we can observe that either the previous case applies, or both augδ(augδ(M,S),S) = X and augδ(M,S) ∈ S.\nProposition 93. Let ⊕ be a δb-, δc-, δd- or δe-based rule update operator. Then ⊕ satisfies (Absorption) with respect to RMR, SMR, RE, SE and SM. Moreover, if ⊕ is δd- or δe-based, then it satisfies (Absorption) with respect to RR and SR.\nProof. (Absorption) states the following: (R ⊕ U) ⊕ U ≡ R ⊕ U . We will show that this is true under RMR-equivalence which, together with Proposition 15, implies that it holds under SMR-, RE-, SE- and SM-equivalence.\nSo suppose that ⊕ is δb-, δc-, δd- or δe-based. By Lemma 92, 〈〈((R⊕ U)⊕ U) ∪ { τ }〉〉RE is a superset of 〈〈(R⊕U)∪ { τ }〉〉RE. Thus, wheneverM is minimal in 〈〈((R⊕U)⊕U)∪ { τ }〉〉RE, it is also minimal in\n〈〈(R⊕U)∪{ τ }〉〉RE. Furthermore, the extra elements of 〈〈((R⊕U)⊕U)∪{ τ }〉〉RE are never smaller than the elements of 〈〈(R⊕U)∪{ τ }〉〉RE because they are of the form augδ(N , 〈〈U〉〉RE) for someN ∈ 〈〈U〉〉RE ⊆ 〈〈(R ⊕ U) ∪ { τ }〉〉RE. Thus, wheneverM is minimal in 〈〈(R ⊕ U) ∪ { τ }〉〉RE, it must also be minimal in 〈〈((R⊕ U)⊕ U) ∪ { τ }〉〉RE.\nFurthermore, if ⊕ is δd- or δe-based, then it additionally holds that 〈〈((R ⊕ U) ⊕ U) ∪ { τ }〉〉RE = 〈〈(R⊕ U) ∪ { τ }〉〉RE.\nProposition 94. Let ⊕ be a δb-, δc-, δd- or δe-based rule update operator. Then ⊕ satisfies (Augmentation) for non-disjunctive programs with respect to RMR, SMR, RE, SE and SM. Moreover, if⊕ is δd- or δe-based, then it satisfies (Augmentation) for non-disjunctive programs with respect to RR and SR.\nProof. The proof for RMR-equivalence follows from Proposition 76 and Lemma 81 and from the fact that the extra elements of 〈〈((R⊕U)⊕V)∪{ τ }〉〉RE, as compared to 〈〈(R⊕V)∪{ τ }〉〉RE, are non-minimal in the latter set. If ⊕ is δd- or δe-based, then there are no extra elements and the rest follows from Proposition 76 and Lemma 81.\nRemark 95 ((Absorption) and (Augmentation) violated by δa). The rule bases R = { p. } and U = V = {∼ p← ∼ q., q. } form counterexamples to (Absorption) and (Augmentation) for δa-based operators with respect SM-equivalence and any stronger notion of equivalence.\nRemark 96 ((Augmentation) for Disjunctive Programs). The following programs form a counterexample to (Augmentation) for δb-, δc-, δd- and δe-based operators under SM-equivalence (and thus under all stronger notions of equivalence as well):\nP : p; q; r. U : ∼ p← ∼ r. V : ∼ p← ∼ r. p← r. p← r. r ← p. r ← p.\n∼ q.\nRemark 97 ((Associativity) and δa, δb, δc, δd, δe). The rule π = (∼ p.), when updated by σ = (p ← q.), must be weakened, anticipating the potential conflict. In the case of δa-, δb-, δc, δd and δe-based operators, the resulting rule is π′ = (∼ p← ∼ q.) (or another RE-equivalent rule). Consider the following rule bases:"
    }, {
      "heading" : "R = { p. } , U = {∼ p. } , V = { p← q., q ← p. } .",
      "text" : "Note that (Associativity) states the following: R⊕ (U ⊕V) ≡ (R⊕U)⊕V . However, while in (R⊕U)⊕V the fact from R is completely annihilated (i.e. transformed into a tautological rule) due to the negative fact π in U , this does not happen in R ⊕ (U ⊕ V) because the π is first weakened into π′. As a consequence, R⊕(U⊕V) has one extra stable model comparing to (R⊕U)⊕V: { p, q }. This implies that (Associativity) does not hold for δa-, δb-, δc-, δd- and δe-based rule update operators under SM-equivalence, nor under any stronger equivalence.\nProposition 98. Let ⊕ be a δ-based rule update operator. Then ⊕ satisfies (P2.1) and (P5) with respect to RMR, SMR, RE and SE.\nProof. Under RMR-entailment (P2.1) follows from the fact that M is a subset of augδ(M,S) and (P5) follows from the fact that augδ(M,S) is a subset of augδ(M,S ∪ T ). For the remaining notions of program entailment this follows from Proposition 15.\nRemark 99 ((P2.1) under |=SR and |=RR). Consider again the rules π, σ from Remark 97 and rule bases R = {π }, U = {σ }. Note that (P2.1) states the following: R ∪ U |= R⊕ U . However, if ⊕ is δa-, δb-, δc-, δd- or δe-based, R⊕ U will contain π′ (or another RE-equivalent rule or program) which results from weakening of π by σ. Consequently, when SR- or RR-entailment is used,R∪U cannot entailR⊕U simply because π′ (or another RE-equivalent rule or program) does not belong toR∪ U .\nRemark 100 ((P2.2) and Rule Updates). Consider R = { p. } and U = {∼ p. } and note that (P2.2) states the following: (R∪ U)⊕ U |= R. In other words, it requires that\n{ p.,∼ p. } ⊕ {∼ p. } |= p .\nIn the presence of (P1) this amounts to postulating that one can never recover from an inconsistent state. Such a requirement is out of line with the way these situations are treated in state-of-the-art approaches to rule updates which allow for recovery from an inconsistent state if all involved conflicts are resolved by the update. Note that, though for different reasons, (B2.2) has also been subject of harsh criticism in belief update literature [34].\nProposition 101. Let ⊕ be a δ-based rule update operator where δ(M,X) ⊆ M for allM ⊆ X. Then ⊕ satisfies (P4), (P4.1) and (P4.2) with respect to RR.\nProof. Principle (P4) can be verified straightforwardly and (P4.1) as well as (P4.2) are its consequences. The condition on δ is necessary to ensure that augδ(M, 〈〈U〉〉RE) =M whenever U is tautological, to keep it in line with the case when U = ∅."
    }, {
      "heading" : "Appendix C. Proofs: Condensing into a Nested Program",
      "text" : "Lemma 102. For any DLP P = 〈Pi〉i<n, ⊕ JU P} consists of the following rules:\n1. for all π ∈ P}i with i < n− 1, the nested rule ( Hπ ← Bπ ∧ ∧ i<j<n∼αP}j ( Hπ ) . ) ; 2. all nested rules in P}n−1.\nProof. Follows by induction on n.\nProposition 103. Let I , J be interpretations and P a DLP. Then,\nI |= (all(P ) \\ rejJU(P , J)) J if and only if I |= (⊕ JU P} )J .\nProof. First suppose that I |= (all(P ) \\ rejJU(P , J))J and take some rule σJ ∈ ( ⊕ JU P})J . We need to prove that I |= σJ . It follows from Lemma 102 that one of the following cases occurs: a) If σ ∈ P}n−1, then it immediately follows that σ ∈ (all(P ) \\ rejJU(P , J))}. Consequently, since I |= (all(P ) \\ rejJU(P , J)) J , it follows that I |= σJ .\nb) Otherwise, σ = ( Hπ ← Bπ ∧ ∧ i<j<n∼αP}j ( Hπ ) . )\nfor some π ∈ P}i with i < n− 1. Suppose that I |= BJσ . Then I |= BJπ and it also follows that for all j with i < j < n, J 6|= αP}j (Hπ). Consequently, π ∈ (all(P ) \\ rejJU(P , J))} and by the assumption we conclude that I |= πJ . Hence, from I |= BJπ it follows that I |= HJπ , implying that I |= σJ .\nFor the converse implication, suppose that I |= ( ⊕\nJU P})J and take some π ∈ (all(P ) \\ rejJU(P , J)) }. We need to show that I |= πJ . If π ∈ P}n−1, then it follows by Lemma 102 that π ∈ ( ⊕ JU P}) and since\nI |= (⊕ JU P} )J by assumption, we can immediately conclude that I |= πJ .\nIn the principal case, π ∈ P}i for some i < n − 1. Consequently, by Lemma 102, ⊕ JU P} contains\na rule σ = ( Hπ ← Bπ ∧ ∧ i<j<n∼αP}j ( Hπ ) . ) . Since π is not part of the set of rejected rules, we can conclude that for all j with i < j < n, J 6|= αP}j (Hπ). Hence, B J σ = B J π ∧ ∧ i<j<n>. It follows that if I |= BJπ , then I |= BJσ and using our assumption we conclude that I |= HJσ . Since Hπ = Hσ, we demonstrated that I |= πJ .\nLemma 104. For any DLP P = 〈Pi〉i<n, ⊕ UA P} consists of the following rules:\n1. for all π ∈ P}i with i < n− 1, the nested rule ( Hπ ← Bπ ∧ ∧ i<j<n∼αP}j ( Hπ ) . ) ;\n2. for all π ∈ P}i with Hπ ∈ A and i < n, the nested rule ( Hπ ∨ Hπ ← Bπ. ) ; 3. all nested rules in P}n−1.\nProof. Follows by induction on n.\nProposition 105. Let P be a DLP and J an interpretation. If J is a UA-model of P , then it is a stable model of ⊕ UA P}.\nProof. In order to show that J is a stable model of ⊕\nUA P}, we first establish that J satisfies ( ⊕ UA\nP})J . Take some rule σ from ⊕ UA P}. We need to prove that J |= σJ . Due to Lemma 104, we need to consider the following cases:\n1) In the first case, σ = ( Hπ ← Bπ ∧ ∧ i<j<n∼αP}j ( Hπ ) . )\nwhere π ∈ P}i and i < n − 1. Suppose that J |= BJσ . Then J |= BJπ and for all j such that i < j < n, J 6|= αP}j (Hπ). Thus, we can conclude that π ∈ (all(P ) \\ rejUA(P , J))}, by the assumption, J |= πJ . So since J |= BJπ , it also holds that J |= HJπ and since Hπ = Hσ, we conclude that J |= σJ .\n2) In the second case, σ = ( Hπ ∨ Hπ ← Bπ. ) for some π ∈ P}i with Hπ ∈ A and i < n. If J |= Hπ,\nthen it easily follows that J |= σJ . On the other hand, if J 6|= Hπ, then the head of σJ contains > as the second disjunct and, once again, it follows that J |= σJ .\n3) In the third case, σ ∈ P}n−1. It immediately follows that σ ∈ (all(P ) \\ rejUA(P , J)) }. Thus, our\nassumption implies that J |= σJ . It remains to verify that J is also subset-minimal among interpretations that satisfy ( ⊕ UA P})J . To\nshow that this is the case, take an interpretation I with I ⊆ J that satisfies ( ⊕\nUA P})J . In the following we\nwill prove that I |= (all(P ) \\ rejUA(P , J)) J . Since J is subset-minimal among interpretations satisfying this program, it will follow that I = J as desired. Take some rule π ∈ (all(P ) \\ rejUA(P , J))\n}, our goal is to prove that I |= πJ . We consider the following cases:\n1) In case π ∈ P}i with i < n − 1 and there is no rule π′ ∈ Pj with i < j < n such that π′ 1 π and J |= Bπ′ , we can use Lemma 104 to conclude that ⊕ UA P} contains a rule σ =(\nHπ ← Bπ ∧ ∧ i<j<n∼αP}j ( Hπ ) . )\n. It also follows that for all j with i < j < n, J 6|= αP}j (Hπ), so that BJσ = B J π∧ ∧ i<j<n>. Thus, if I |= BJπ , then I |= BJσ and by the assumption that I |= ( ⊕ UA P})J we obtain I |= HJσ , so it also follows that I |= πJ .\n2) In case π ∈ P}i with i < n − 1 and there is a rule π′ ∈ Pj with i < j < n such that π′ 1 π and J |= Bπ′ , it follows that since π is unrejected, π′ is itself rejected. Consequently, there is also an unrejected rule π′′ ∈ Pk with j < k < n such that π′′ 1 π′ and J |= Bπ′′ . Furthermore, Hπ′′ = Hπ and by the assumption we know that J satisfies the rule π′′, so we can conclude that J |= Hπ. If Hπ is a default literal, then it follows that (Hπ)J = >, so trivially I |= πJ . If Hπ is an atom, then, by Lemma 104, ⊕ UA P} contains a rule σ = ( Hπ ∨ Hπ ← Bπ. ) . Note that\nHJσ = Hπ ∨ ⊥. Thus, if I |= BJπ , then I |= BJσ and it follows from our assumption that I |= HJσ , so that I |= HJπ . Hence, I |= πJ .\n3) In case π ∈ P}n−1, it immediately follows from Lemma 104 that π ∈ (⊕ UA P} ) . Thus, by the\nassumption that I |= ( ⊕\nUA P})J we obtain I |= πJ .\nProposition 106. Let P be a DLP and J an interpretation. If J is a stable model of ⊕\nUA P}, then it is a\nUA-model of P .\nProof. To show that J is a UA-model of P , we first establish that J satisfies P = (all(P ) \\ rejUA(P , J)) J . Take some rule π ∈ (all(P ) \\ rejUA(P , J)) }, our goal is to prove that J |= πJ . We consider the following cases:\n1) In case π ∈ P}i with i < n − 1 and there is no rule π′ ∈ Pj with i < j < n such that π′ 1 π and J |= Bπ′ , we can use Lemma 104 to conclude that ⊕ UA P} contains a rule σ =(\nHπ ← Bπ ∧ ∧ i<j<n∼αP}j ( Hπ ) . )\n. It also follows that for all j with i < j < n, J 6|= αP}j (Hπ), so that BJσ = B J π ∧ ∧ i<j<n>. Thus, if J |= BJπ , then J |= BJσ and by the assumption that\nJ |= ( ⊕\nUA P})J we obtain J |= HJσ , so it follows that J |= πJ .\n2) In case π ∈ P}i with i < n − 1 and there is a rule π′ ∈ Pj with i < j < n such that π′ 1 π and J |= Bπ′ , it follows that since π is unrejected, π′ is itself rejected. Take the maximal index k such that Pk contains a rule π′′ with π′′ 1 π′ and J |= Hπ′′ . It follows that π′′ satisfies the condition of the previous case, and thus J |= HJπ′′ . Since Hπ = Hπ′′ , we conclude that J |= πJ .\n3) In case π ∈ P}n−1, it immediately follows from Lemma 104 that π ∈ (⊕ UA P} ) . Thus, by the\nassumption that J |= ( ⊕\nUA P})J we obtain that J |= πJ .\nIt remains to verify that J is also subset-minimal among interpretations that satisfy P. To show that this is the case, take an interpretation I with I ⊆ J that satisfies P. In the following we will prove that I also satisfies the program ( ⊕ UA P})J . Since J is subset-minimal among interpretations satisfying this program, it will follow that I = J as desired. So take some σ ∈ ( ⊕ UA P}), our goal is to prove that I |= σJ . Due to Lemma 104, we need to consider the following cases:\n1) In the first case, σ = ( Hπ ← Bπ ∧ ∧ i<j<n∼αP}j ( Hπ ) . )\nwhere π ∈ P}i and i < n − 1. Suppose that I |= BJσ . Then I |= BJπ and for all j such that i < j < n, J 6|= αP}j (Hπ). Thus, we can conclude that π ∈ (all(P ) \\ rejUA(P , J))\n}. Furthermore, from I |= BJπ and the assumption that I |= P, it follows that I |= HJπ . Consequently, since Hπ = Hσ, I |= σJ . 2) In the second case, σ = (Hπ ∨ Hπ ← Bπ.) for some π ∈ P}i with Hπ ∈ A and i < n. If π is not rejected, then it follows from our assumption that I |= πJ . In the principal case, there exists a rule π′ ∈ Pj with i < j < n such that π′ 1 π and J |= Bπ′ . Furthermore, π′ itself is not rejected, so due to our previous considerations we can conclude that J |= Hπ′ . Note that since Hπ is an atom, Hπ′ is a default literal, so the rule σJ has > as one of the disjuncts in its head. Thus, I trivially satisfies σJ .\n3) In the third case, σ ∈ P}n−1. It immediately follows that σ ∈ (all(P ) \\ rejUA(P , J)) }. Thus, our\nassumption implies that I |= σJ .\nProof of Theorem 28. Follows from Propositions 103, 105 and 106."
    }, {
      "heading" : "Appendix D. Proofs: Condensing into a Disjunctive Program",
      "text" : "Remark 107. Throughout the following proofs we abuse notation by ignoring differences between formulas that can be eliminated by regrouping and reordering conjuncts and disjuncts within them. That is, when a formula can be obtained from another formula only by using the commutative and associative laws for conjunction and disjunction, we consider the two formulas identical. We can afford to do this because the order and grouping of conjuncts and disjuncts has no effect on the resulting semantics.\nDefinition 108 (Strong Equivalence [50]). Let P, Q be programs. We say that P is strongly equivalent to Q if for every program R, the stable models of P ∪ R coincide with the stable models of Q ∪ R. Strong equivalence is extended to rules by treating each rule π as the program {π }.\nProposition 109 ([50, 71]). Let P, Q be programs and π a rule. If for all interpretations I , J with I ⊆ J , J |= P ∧ I |= PJ if and only if J |= Q∧ I |= QJ , then P is strongly equivalent to Q.\nProof. Take some program R and some interpretation J . J is a stable model of P ∪ R if and only if J |= (P ∪ R)J and ∀I ( J : I 6|= (P ∪ R)J . Due to the definition of reduct and the assumption, this is equivalent to J |= (Q∪R)J and ∀I ( J : I 6|= (Q∪R)J . In other words, J is a stable model of P ∪R if and only if it is a stable model of Q∪R.\nCorollary 110. Let P, Q be programs and π a rule. If for all interpretations I , J , I |= PJ if and only if I |= QJ , then P is strongly equivalent to Q.\nProof. Follows from Proposition 109 and the fact that for every interpretation K and program R, K |= R if and only if K |= RK .\nCorollary 111. Let φ, ψ be formulas and π a rule. If for all interpretations I , J , I |= φJ if and only if I |= ψJ , then the rules (Hπ ← Bπ ∧ φ.) and (Hπ ← Bπ ∧ ψ.) are strongly equivalent.\nProof. Follows from the definition of rule reduct and from Corollary 110.\nDefinition 112. Given a set of formulas S, we define ∼S = { ∼φ | φ ∈ S }.\nLemma 113. Let P be a program, L a literal, S be a set of formulas and I , J interpretations. Then, (i) I |= ( ∧ ∼S)J if and only if I |= (∼ ∨ S)J ;\n(ii) I |= (∼αP}(L))J if and only if I |= (∨ S∈βP(L) ∧ ∼∼S+ ∧ ∧ ∼S− )J .\nProof. (i) By the definition of reduct, I |= ( ∧ ∼S)J if and only if for all φ ∈ S it holds that J 6|= φ. This in\nturn holds if and only if J 6|= ∨ S, which is the case if and only if I |= (∼ ∨ S)J .\n(ii) Suppose that αP}(L) is the formula (L11 ∧ · · · ∧ L1k1) ∨ · · · ∨ (L n 1 ∧ · · · ∧ Lnkn). By the definition\nof reduct, I |= (∼αP}(L))J if and only if J 6|= αP}(L). Equivalently, for every j with 1 ≤ j ≤ n there exists some ij with 1 ≤ ij ≤ kj such that J 6|= Ljij . By the definition of blocking sets, this is equivalent to J |= S for some S ∈ βP(L). Equivalently, for some S ∈ βP(L),\n∀L ∈ ∼S+ : J 6|= L and ∀L ∈ S− : J 6|= L ,\nor in other words, ( ∧ ∼∼S+ ∧ ∧ ∼S−)J = ∧ L∈S >. Equivalently, we can also write I |=(∨\nS∈βP(L) ∧ ∼∼S+ ∧ ∧ ∼S− )J .\nLemma 114. Let π be a rule and S a set of formulas. Then the rule (Hπ ← Bπ∧ ∨ S.) is strongly equivalent to the program { Hπ ← Bπ ∧ φ | φ ∈ S }.\nProof. Let σ denote the rule and P the program. According to Corollary 110, it suffices to prove that for all interpretations I , J , it holds that I |= σJ if and only if it holds that I |= PJ . This easily follows from the fact that I |= σJ if and only if I |= BJσ implies I |= HJσ , or, equivalently, for all φ ∈ S, I |= BJπ ∧ φJ implies I |= HJπ , which is another way of writing I |= PJ .\nLemma 115. Let π be a rule and φ a formula. Then the rules (Hπ ← Bπ ∧∼∼φ.) and (Hπ ∨∼φ← Bπ.) are strongly equivalent.\nProof. Let σ1 denote the first rule and σ2 the second. By Corollary 110, it suffices to prove that for all interpretations I , J , it holds that I |= σJ1 if and only if it holds that I |= σJ2 . If J |= φ, then σJ1 = (HJπ ← BJπ ∧ >) and σJ2 = (HJπ ∨ ⊥ ← BJπ), so it follows that I |= σJ1 holds if and only if I |= σJ2 .\nOn the other hand, if J 6|= φ, then σJ1 = (Hπ ← Bπ ∧ ⊥) σJ2 = (Hπ ∨ > ← Bπ) and trivially both I |= σJ1 and I |= σJ2 hold.\nLemma 116. Let π be a rule such that Hπ is a default literal and Bπ is a conjunction of literals and doublenegated atoms. For any atom p, the rules (Hπ ← Bπ ∧ ∼∼ p.) and (Hπ ← Bπ ∧ p.) are are strongly equivalent.\nProof. Let Hπ = ∼ q, where q is an atom. Also, let σ1 denote the first rule and σ2 the second. By Proposition 109, it suffices to prove that for all interpretations I , J with I ⊆ J ,"
    }, {
      "heading" : "J |= σ1 ∧ I |= σJ1 if and only if J |= σ2 ∧ I |= σJ2 ,",
      "text" : "First suppose that J |= σ1 and I |= σJ1 . Then clearly J |= σ2 and it remains to prove that I |= σJ2 . Suppose that I |= BJσ2 . Then I |= B J π and from I ⊆ J we conclude that J |= p, so I |= (∼∼ p)J . Consequently, I |= BJσ1 and from the assumption that I |= σ J 1 we conclude that I |= HJπ as desired.\nNow suppose that J |= σ2 and I |= σJ2 . Then clearly J |= σ1 and it remains to prove that I |= σJ1 . Suppose that I |= BJσ1 . Then I |= B J π , so it follows from I ⊆ J that J |= Bπ. Furthermore, from I |= (∼∼ p)J it follows that J |= p. Thus, J |= Bσ2 and from J |= σ2 we conclude that J |= Hπ. This implies that HJπ = (∼ q)J = > and, thus, I |= HJπ as desired.\nLemma 117. Let π be a rule and φ a formula such that Hπ is an atom and both Bπ and φ are conjunctions of literals and double-negated atoms. For any atom p, the programs { Hπ ∨ Hπ ← Bπ; Hπ ← Bπ ∧ φ ∧ ∼∼ p } and { Hπ ∨ Hπ ← Bπ; Hπ ← Bπ ∧ φ ∧ p } are strongly equivalent.\nProof. Let P1 denote the first program and P2 the second one. Also, let σ denote the rule (Hπ ∨Hπ ← Bπ), σ1 the rule (Hπ ← Bπ ∧ φ ∧ ∼∼ p) and σ2 the rule (Hπ ← Bπ ∧ φ ∧ p). Thus, P1 = {σ, σ1 } and P2 = {σ, σ2 }.\nAccording to Proposition 109, it suffices to prove that for all interpretations I , J with I ⊆ J ,\nJ |= P1 ∧ I |= PJ1 if and only if J |= P2 ∧ I |= PJ2 ,\nFirst assume that J |= P1 and I |= PJ1 . Clearly, it follows that J |= P2 and I |= σJ , so it remains to verify that I |= σJ2 . Suppose that I |= BJσ2 . Then, since I ⊆ J , it follows that J |= p and so (∼∼ p)\nJ = >. Consequently, I |= BJσ1 and from the assumption that I |= P J 1 we can conclude that I |= HJπ as desired.\nFor the converse implication, assume that J |= P2 and I |= PJ2 . It immediately follows that J |= P1 and I |= σJ , so it remains to verify that I |= σJ1 . Suppose that I |= BJσ1 . From I ⊆ J and the assumption that both Bπ and φ are conjunctions of literals and double-negated atoms, we conclude that J |= Bσ1 , so it follows that J |= Hπ. Consequently, (Hπ)J = ⊥ and since I |= σJ , I |= BJπ implies that I |= HJπ as desired.\nLemma 118. Let P, Q be programs and L a literal. Then,\nβP∪Q(L) = { S ∪ T | S ∈ βP(L) ∧ T ∈ βQ(L) } .\nProof. Suppose that αP}(L), αQ}(L) and α(P∪Q)}(L) are, respectively, of the forms\n(L11 ∧ · · · ∧ L1k1) ∨ · · · ∨ (L m 1 ∧ · · · ∧ Lmkm) ,\n(Lm+11 ∧ · · · ∧ L m+1 km+1 ) ∨ · · · ∨ (Ln1 ∧ · · · ∧ Lnkn) ,\n(L11 ∧ · · · ∧ L1k1) ∨ · · · ∨ (L n 1 ∧ · · · ∧ Lnkn) .\nBy the definition, S ∈ βP(L) and T ∈ βQ(L) if and only if S = { L1i1 , . . . , L m im } and T = { Lm+1im+1 , . . . , L n in } where 1 ≤ ij ≤ kj for every j with 1 ≤ j ≤ n. This is equivalent to S∪T being a member of βP∪Q(L).\nLemma 119. Let P = 〈Pi〉i<n be a DLP. Then ⊕∨ JU P consists of the following rules:\n1. for all π ∈ Pi with i < n− 1 such that Hπ = { p } for some p ∈ A, and all S ∈ β⋃ i<j<n Pj (∼ p), the\nrule ( Hπ;S+ ← Bπ, S−. ) ;\n2. for all π ∈ Pi with i < n− 1 such that Hπ = {∼ p } for some p ∈ A, and all S ∈ β⋃ i<j<n Pj (p), the\nrule ( Hπ ← Bπ, S+, S−. ) ;;\n3. all rules in Pn−1.\nProof. Follows by induction on n using Lemma 118. Lemma 120. Let P = 〈Pi〉i<n be a DLP. Then ⊕∨ UA P consists of the following rules:\n1. for all π ∈ Pi with i < n− 1 and all S ∈ β⋃ i<j<n Pj ( Hπ ) , the rule ( Hπ ← Bπ, S+, S−. ) ;\n2. for all π ∈ Pi with i < n such that Hπ = { p } for some p ∈ A, the rule (p;∼ p← Bπ.); 3. all rules in Pn−1.\nProof. Follows by induction on n using Lemma 118.\nProof of Theorem 31. (i) Due to Theorem 28, it suffices to show that the programs ⊕ JU P} and ⊕∨ JU P have the same sta-\nble models. To see that this is indeed the case, consider the contents of these programs, as established in Lemmas 102 and 119. For all π ∈ P}i with i < n − 1, ⊕ JU P} contains the nested rule(\nHπ ← Bπ ∧ ∧ i<j<n∼αP}j (Hπ). ) . By Lemma 113(i) and Corollary 111, this rule is strongly equiv-\nalent to the rule ( Hπ ← Bπ ∧ ∼ ∨ i<j<n αP}j (Hπ). ) which, by the definition of activation condition,\ncan also be written as (\nHπ ← Bπ ∧ ∼α⋃ i<j<n P } j (Hπ). )\n. Furthermore, due to Lemma 113(ii) and Corollary 111, the latter rule is strongly equivalent to the rule\nHπ ← Bπ ∧ ∨\nS∈β⋃ i<j<n Pj (Hπ)\n∧ ∼∼S+ ∧ ∧ ∼S−.\nand by using Lemma 114 we obtain the strongly equivalent program that contains, for each S ∈ β⋃\ni<j<n Pj (Hπ), the rule\nHπ ← Bπ ∧ ∧ ∼∼S+ ∧ ∧ ∼S−.\nDouble-negated atoms from the bodies of these rules can be eliminated using Lemmas 115 and 116, obtaining (Hπ ∨ ∨ ∼S+ ← Bπ ∧ ∧ ∼S−.) if Hπ is an atom and (Hπ ← Bπ ∧ ∧ S+ ∧ ∧ ∼S−.) if Hπ is a default literal. In this way, the original nested rules can be converted, one at a time, into a strongly equivalent disjunctive program. After this process is finished, the nested syntax can be converted to the syntax of disjunctive programs and the result coincides with the disjunctive program⊕∨\nJU P . (ii) Due to Theorem 28, it suffices to show that the programs ⊕\nUA P} and ⊕∨ UA P have the same sta-\nble models. To see that this is indeed the case, consider the contents of these programs, as established in Lemmas 104 and 120. For all π ∈ P}i with i < n − 1, ⊕ UA\nP contains the nested rule( Hπ ← Bπ ∧ ∧ i<j<n∼αP}j (Hπ). ) . By Lemma 113(i) and Corollary 111, this rule is strongly equiv-\nalent to the rule ( Hπ ← Bπ ∧ ∼ ∨ i<j<n αP}j (Hπ). ) which, by the definition of activation condition,\ncan also be written as (\nHπ ← Bπ ∧ ∼α⋃ i<j<n P } j (Hπ). )\n. Furthermore, due to Lemma 113(ii) and Corollary 111, the latter rule is strongly equivalent to the rule\nHπ ← Bπ ∧ ∨\nS∈β⋃ i<j<n Pj (Hπ)\n∧ ∼∼S+ ∧ ∧ ∼S−.\nand by using Lemma 114 we obtain the strongly equivalent program that contains, for each S ∈ β⋃\ni<j<n Pj (Hπ), the rule\nHπ ← Bπ ∧ ∧ ∼∼S+ ∧ ∧ ∼S−.\nFinally, double-negated atoms from the bodies of these rules can be eliminated using Lemmas 117 and 116, obtaining (Hπ ← Bπ ∧ ∧ S+ ∧ ∧ ∼S−.) In this way, the original nested rules can be converted, one at a time, into a strongly equivalent disjunctive program. After this process is finished, the nested syntax can be converted to the syntax of disjunctive programs and the result coincides with the disjunctive program ⊕∨ UA P ."
    }, {
      "heading" : "Appendix E. Proofs: Belief Updates Using Exception-Based Operators",
      "text" : "Appendix E.1. Model-Based Update Operators\nTheorem 34. If is an update operator that satisfies (B1), (B2.1) and (B4), then there exists an exception function ε such that for every ε-based update operator ⊕ and all finite sequences of knowledge bases D, [[3D ]] = [[ ⊕ D ]].\nProof. Let the exception function ε be defined for all sets of interpretationsM ⊆ I and all sets of sets of interpretations S, T ⊆ 2I as\nε(M,S, T ) = [[B U ]] (E.1) where B, U are some knowledge bases such that [[B ]] = ⋂ S and [[U ]] = ⋂ T . Note that this definition is unambiguous since the existence of such B and U is guaranteed and regardless of which pair of knowledge bases with these properties we choose, we obtain the same result due to the assumption that satisfies (B4). Take some ε-based operator ⊕. We proceed by induction on the length n of D = 〈Bi〉i<n.\n1◦ If n = 0, then it immediately follows that [[3D ]] = [[3〈B0〉 ]] = [[B0 ]] = [[ ⊕ 〈B0〉 ]] = [[ ⊕ D ]].\n2◦ Suppose that the claim holds for n, i.e. for D = 〈Bi〉i<n we have [[3D ]] = [[ ⊕ D ]]. Our goal is to\nshow that it also holds for n+ 1, i.e. for D′ = 〈Bi〉i<n+1. It follows that\n〈〈 ⊕ D′〉〉 = 〈〈 ⊕ D ⊕ Bn〉〉 = { [[φ ]] ∪ ε([[φ ]], 〈〈 ⊕ D〉〉, 〈〈Bn〉〉) | φ ∈ ⊕ D } ∪ 〈〈Bn〉〉 .\nBy (E.1) and the inductive assumption, ε([[φ ]], 〈〈 ⊕ D〉〉, 〈〈Bn〉〉) = [[3D Bn ]] = [[3D′ ]]. Consequently, [[ ⊕ D′ ]] = ⋂ 〈〈 ⊕ D′〉〉 = ⋂({ [[φ ]] ∪ [[3D′ ]]\n∣∣ φ ∈⊕D } ∪ 〈〈Bn〉〉) . This can also be written as ([[3D′ ]] ∪ ⋂ 〈〈 ⊕ D〉〉) ∩ ⋂ 〈〈Bn〉〉. Substituting [[3D ]] for ⋂ 〈〈 ⊕ D〉〉 and distributing ∩ over ∪ yields ([[3D′ ]] ∩ [[Bn ]]) ∪ ([[3D ]] ∩ [[Bn ]]). Finally, using (B1) and (B2.1) we can write this as\n([[3D Bn ]] ∩ [[Bn ]]) ∪ [[(3D) ∪ Bn ]] = [[3D Bn ]] ∪ [[(3D) ∪ Bn ]] = [[3D Bn ]] = [[3D′ ]] .\nAppendix E.2. Formula-Based Update Operators\nThe set of possible remainders has a number of important properties from which properties of specific formula-based operators follow. We start with two auxiliary results which make it possible to construct a subset of a knowledge base with important properties on the semantic level.\nLemma 121. Let B, U be knowledge bases. Then U is consistent if and only if rem(B,U) is non-empty.\nProof. First suppose that U is consistent and let R be the set of all subsets B′ of B such that B′ ∪ U is consistent. R must be non-empty because ∅ clearly belongs to R. So take some subset-maximal element B∗ ofR. It is easy to see that B∗ belongs to rem(B,U).\nOn the other hand, if rem(B,U) is non-empty, then it contains some set B′ such that B′∪U is consistent. Thus it follows directly that U is also consistent.\nLemma 122. Let B, C be knowledge bases with 〈〈B〉〉I = 〈〈C〉〉I, B′ ⊆ B and C′ = { φ ∈ C ∣∣ [[φ ]] ∈ 〈〈B′〉〉I }. Then 〈〈B′〉〉I = 〈〈C′〉〉I.\nProof. Suppose first thatM belongs to 〈〈B′〉〉I. Then it also belongs to 〈〈B〉〉I, so by our assumption either M = I orM belongs to 〈〈C〉〉. In the former caseM belongs to 〈〈C′〉〉I and we are finished. In the latter case there is a formula φ ∈ C such that [[φ ]] =M and φ belongs to C′ by its definition. Consequently,M belongs to 〈〈C′〉〉I.\nAs for the other inclusion, ifM belongs to 〈〈C′〉〉I, then eitherM = I or for some formula φ ∈ C′ we haveM = [[φ ]]. Therefore,M belongs to 〈〈B′〉〉I by the definition of C′.\nLemma 123. Let B, C, U , V be knowledge bases such that 〈〈B〉〉I = 〈〈C〉〉I and 〈〈U〉〉I = 〈〈V〉〉I, B′ ⊆ B such that B′ ∪ U is consistent and C′ = { φ ∈ C ∣∣ [[φ ]] ∈ 〈〈B′〉〉I }. Then C′ ∪ V is consistent. Proof. To verify that C′ ∪ V is consistent, we only need to use Lemma 122 and observe that\n[[C′ ∪ V ]] = ⋂ 〈〈C′ ∪ V〉〉 = ⋂ (〈〈C′〉〉 ∪ 〈〈V〉〉) = ⋂ (〈〈C′〉〉I ∪ 〈〈V〉〉)\n= ⋂ (〈〈B′〉〉I ∪ 〈〈U〉〉) = ⋂ (〈〈B′〉〉 ∪ 〈〈U〉〉) = ⋂ 〈〈B′ ∪ U〉〉 = [[B′ ∪ U ]] .\nProposition 124 (Syntax-Independence of Remainders). Let B, C, U , V be knowledge bases such that 〈〈B〉〉I = 〈〈C〉〉I and 〈〈U〉〉I = 〈〈V〉〉I. Then ((rem(B,U)))I = ((rem(C,V)))I.\nProof. We prove that ((rem(B,U)))I ⊆ ((rem(C,V)))I, the other inclusion follows by the same arguments since the formulation of the proposition is symmetric.\nTake some B′ from rem(B,U) and put C′ = { φ ∈ C ∣∣ [[φ ]] ∈ 〈〈B′〉〉I }. We need to show that 〈〈B′〉〉I belongs to ((rem(C,V)))I. Due to Lemma 122, 〈〈B′〉〉I = 〈〈C′〉〉I, so it suffices to prove that C′ belongs to rem(C,V). First, note that C′ is clearly a subset of C and, by Lemma 123, C′ ∪ V is consistent. We prove that C′ is subset-maximal with these properties by contradiction. Suppose that C∗ is such that C′ ( C∗ ⊆ C and C∗ ∪ V is consistent and let B∗ = { φ ∈ B\n∣∣ [[φ ]] ∈ 〈〈C∗〉〉I }. Clearly, B∗ is a subset of B and, by Lemma 123, B∗ ∪ U is consistent. To reach a conflict, we need to show that B′ is a proper subset of B∗. First note that 〈〈C′〉〉I cannot be equal to 〈〈C∗〉〉I – if it were, then for every formula φ ∈ C∗ it would hold that φ belongs to C and [[φ ]] belongs to 〈〈B′〉〉I, so φ belongs to C′ by its definition, contrary to the assumption that C′ is a proper subset of C∗. This, together with Lemma 122, implies that\n〈〈B′〉〉I = 〈〈C′〉〉I ( 〈〈C∗〉〉I = 〈〈B∗〉〉I . (E.2)\nIt immediately follows that B′ 6= B∗. Furthermore, for any formula φ from B′, φ belongs to B and it follows from (E.2) that [[φ ]] belongs to 〈〈C∗〉〉I, so φ belongs to B∗ by its definition. This means that B′ is a proper subset of B∗, contrary to the assumption that B′ belongs to rem(B,U).\nLemma 125 (Equivalent Formulas in Remainders). Let B, U be knowledge bases, φ, ψ ∈ B formulas such that [[φ ]] = [[ψ ]] and B′ ∈ rem(B,U) a possible remainder. Then φ ∈ B′ if and only if ψ ∈ B′.\nProof. Without loss of generality, assume that φ belongs to B′ but ψ does not. Then B′ ∪ {ψ } is a subset of B that is consistent with U . This is in conflict with the maximality of B′. Corollary 126. Let B, U be knowledge bases and R ⊆ rem(B,U) a set of possible remainders. Then⋂ ((R)) = 〈〈 ⋂ R〉〉.\nProof. First suppose thatM belongs to ⋂\n((R)) and take some B′ ∈ R and some formula φ ∈ B′ such that [[φ ]] =M. Now take an arbitrary B∗ ∈ R. SinceM belongs to 〈〈B∗〉〉, there must exist a formula ψ ∈ B∗ such that [[ψ ]] = M. Consequently, [[φ ]] = [[ψ ]] and by Lemma 125 we obtain that φ also belongs to B∗. Thus, φ belongs to ⋂ R andM belongs to 〈〈 ⋂ R〉〉.\nOn the other hand, if M belongs to 〈〈 ⋂ R〉〉, then there is a formula φ ∈ ⋂ R such that [[φ ]] = M.\nConsequently,M belongs to all members of ((R)), thus also belongs to their intersection.\nCorollary 127. Let B, U be knowledge bases, R ⊆ rem(B,U) a set of possible remainders. Then,⋂ ((R))I = 〈〈 ⋂ R〉〉I.\nProof. Follows from Corollary 126 and from the fact that I belongs to both sides of the equation.\nProposition 128 (Properties of the WIDTIO Operator). The WIDTIO operator satisfies (F1), (F2.1) and (F4).\nProof. By definition U ⊆ B ◦widtio U and (F1) is obtained by applying 〈〈·〉〉 to both sides of this inclusion. In order to verify that (F2.1) holds, suppose thatM belongs to 〈〈B ◦widtioU〉〉. Then there is some formula\nφ from U ∪ ⋂ rem(B,U) such that [[φ ]] = M. If φ belongs to U , then it immediately follows that M belongs to 〈〈U〉〉, and consequently also to 〈〈B ∪ U〉〉. If φ belongs to B′ for all B′ ∈ rem(B,U), then φ also belongs to B. Thus,M is a member of 〈〈B〉〉, and consequently also of 〈〈B ∪ U〉〉.\nFinally, to verify (F4), suppose that 〈〈B〉〉I = 〈〈C〉〉I and 〈〈U〉〉I = 〈〈V〉〉I. The following follows from the definition of the WIDTIO operator, Corollary 127 and Proposition 124.\n〈〈B ◦widtio U〉〉I = 〈〈 U ∪ ⋂ rem(B,U) 〉〉I = 〈〈U〉〉I ∪ 〈〈⋂ rem(B,U) 〉〉I = 〈〈U〉〉I ∪ ⋂ ((rem(B,U)))I = 〈〈V〉〉I ∪ ⋂ ((rem(C,V)))I\n= 〈〈V〉〉I ∪ 〈〈⋂ rem(C,V) 〉〉I = 〈〈 V ∪ ⋂ rem(C,V) 〉〉I = 〈〈C ◦widtio V〉〉I .\nProposition 129 (Properties of Regular Bold Operators). Regular Bold operators satisfy (F1), (F2.1) and (F4).\nProof. By definition U ⊆ B ◦sbold U and (F1) is obtained by applying 〈〈·〉〉 to both sides of this inclusion. In order to verify that (F2.1) holds, suppose thatM belongs to 〈〈B ◦sbold U〉〉. Then there is some formula φ from U ∪ s(rem(B,U)) such that [[φ ]] = M. If φ belongs to U , then it immediately follows that M belongs to 〈〈U〉〉, and consequently also to 〈〈B∪U〉〉. If φ belongs to B′ = s(rem(B,U)), then φ also belongs to B. Thus,M is a member of 〈〈B〉〉, and consequently also of 〈〈B ∪ U〉〉.\nFinally, to verify (F4), suppose that 〈〈B〉〉I = 〈〈C〉〉I and 〈〈U〉〉I = 〈〈V〉〉I. The following follows from the definition of the WIDTIO operator, Proposition 124 and the regularity property of ◦sbold.\n〈〈B ◦sbold U〉〉I = 〈〈U ∪ s(rem(B,U))〉〉I = 〈〈U〉〉I ∪ 〈〈s(rem(B,U))〉〉I\n= 〈〈V〉〉I ∪ 〈〈s(rem(C,V))〉〉I = 〈〈V ∪ s(rem(C,V))〉〉I = 〈〈C ◦sbold V〉〉I .\nProposition 130 (Properties of the Cross-Product Operator). The Cross-Product operator satisfies (F1), (B2.1) and (F4) but does not satisfy (F2.1).\nProof. By definition U ⊆ B ◦cp U and (F1) is obtained by applying 〈〈·〉〉 to both sides of this inclusion. To see that ◦cp does not satisfy (F2.1), note that { p, q }◦cp {¬p ∨ ¬q } = { p ∨ q,¬p ∨ ¬q } and [[p∨ q ]] does not belong to 〈〈{ p, q,¬p ∨ ¬q }〉〉. In order to verify (B2.1), take some I from [[B ∪ U ]]. We need to show that I is a model of B ◦cp U . Obviously, I is a model of U , so it remains to prove that I is a model of the formula\nψ = ∨\nB′∈rem(B,U) ∧ φ∈B′ φ .\nSince I is a model of U , we conclude that U is consistent, so according to Lemma 121, rem(B,U) is nonempty. Take some B∗ from rem(B,U). We obtain the following: [[ψ ]] = ⋃ B′∈rem(B,U)[[B′ ]] ⊇ [[B∗ ]] ⊇ [[B ]]. Hence, since I belongs to [[B ]], it also belongs to [[ψ ]]. Finally, to verify (F4), suppose that 〈〈B〉〉I = 〈〈C〉〉I and 〈〈U〉〉I = 〈〈V〉〉I and take someM from 〈〈B◦cpU〉〉I. In the trivial case when M = I it immediately follows that M belongs to 〈〈C ◦cp V〉〉I. Otherwise, there is a formula φ from U ∪ {ψ } such that [[φ ]] = M. If φ belongs to U , then M belongs to 〈〈U〉〉 and by assumption also to 〈〈V〉〉I. By (F1) we then obtain thatM belongs to 〈〈C ◦cp V〉〉I. On the other hand, if φ is ψ, then due to Proposition 124, ((rem(B,U)))I = ((rem(C,V)))I, so\n[[φ ]] = [[ψ ]] = ⋃\nB′∈rem(B,U)\n[[B′ ]] = ⋃\nC′∈rem(C,V)\n[[C′ ]] = [[ψ′ ]]\nwhere C ◦cp V = V ∪ {ψ′ }. Therefore, [[φ ]] belongs to 〈〈C ◦cp V〉〉I. The proof of the other inclusion is symmetric.\nProof of Proposition 36. Follows from Propositions 128, 129 and 130.\nProposition 131. If ◦ is an update operator that satisfies (F1), (F2.1) and (F4), then there exists an exception function ε such that for every ε-based update operator ⊕ and all finite sequences of knowledge bases D, 〈〈©D〉〉I = 〈〈 ⊕ D〉〉I.\nProof. Let the exception function ε be defined for all sets of interpretations M and all sets of sets of interpretations S, T as\nε(M,S, T ) = { ∅ M ∈ 〈〈B ◦ U〉〉I ; I M /∈ 〈〈B ◦ U〉〉I ,\nwhere B, U are some knowledge bases such that 〈〈B〉〉I = S ∪ { I } and 〈〈U〉〉I = T ∪ { I }. Note that this definition is unambiguous since the existence of such B and U is guaranteed and regardless of which pair of knowledge bases with these properties we choose, we obtain the same result due to the assumption that ◦ satisfies (F4). Take some ε-based operator ⊕. We proceed by induction on the length n of D = 〈Bi〉i<n.\n1◦ If n = 0, then it immediately follows that 〈〈3D〉〉 = 〈〈3〈B0〉〉〉 = 〈〈B0〉〉 = 〈〈 ⊕ 〈B0〉〉〉 = 〈〈 ⊕ D〉〉.\n2◦ Suppose that the claim holds for n, i.e. for D = 〈Bi〉i<n we have 〈〈3D〉〉I = 〈〈 ⊕ D〉〉I. Our goal is to\nshow that it also holds for n+ 1, i.e. for D′ = 〈Bi〉i<n+1. It follows that 〈〈 ⊕ D′〉〉 = 〈〈 ⊕ D ⊕ Bn〉〉 = { [[φ ]] ∪ ε([[φ ]], 〈〈 ⊕ D〉〉, 〈〈Bn〉〉) | φ ∈ ⊕ D } ∪ 〈〈Bn〉〉 .\nThus, 〈〈 ⊕ D′〉〉I = { [[φ ]] ∪ ε([[φ ]], 〈〈 ⊕ D〉〉, 〈〈Bn〉〉) | φ ∈ ⊕ D }∪ 〈〈Bn〉〉 ∪ { I } which in turn can be written as{ M ∣∣∣M∈ 〈〈⊕D〉〉 ∩ 〈〈⊕D ◦ Bn〉〉I } ∪ { I ∣∣∣M∈ 〈〈⊕D〉〉 \\ 〈〈⊕D ◦ Bn〉〉I } ∪ 〈〈Bn〉〉 ∪ { I }\nand simplified into ( 〈〈 ⊕ D〉〉I ∩ 〈〈 ⊕ D ◦ Bn〉〉I ) ∪ 〈〈Bn〉〉I. Since ◦ satisfies (F4), it follows from the\ninductive assumption that 〈〈 ⊕ D ◦ Bn〉〉I = 〈〈©D ◦ Bn〉〉I. Thus, we obtain the set( 〈〈©D〉〉I ∩ 〈〈©D ◦ Bn〉〉I ) ∪ 〈〈Bn〉〉I\nand by distributing ∪ over ∩ and using (F1) and (F2.1) we obtain( 〈〈©D〉〉I ∪ 〈〈Bn〉〉I ) ∩ ( 〈〈©D ◦ Bn〉〉I ∪ 〈〈Bn〉〉I ) = 〈〈©D ∪ Bn〉〉I ∩ 〈〈©D ◦ Bn〉〉I\n= 〈〈©D ◦ Bn〉〉I = 〈〈©D′〉〉I .\nProposition 132. If ◦ an update operator that satisfies (F1), (B2.1) and (F4), then there exists an exception function ε such that for every ε-based update operator⊕ and all knowledge bases B, U , [[B◦U ]] = [[B⊕U ]].\nProof. Let the exception function ε be defined for all sets of interpretations M and all sets of sets of interpretations S, T as\nε(M,S, T ) = [[B ◦ U ]] ,\nwhere B, U are some knowledge bases such that 〈〈B〉〉I = S ∪ { I } and 〈〈U〉〉I = T ∪ { I }. Note that this definition is unambiguous since the existence of such B and U is guaranteed and regardless of which pair of knowledge bases with these properties we choose, we obtain the same result due to the assumption that ◦ satisfies (F4).\nTake some ε-based operator ⊕. Then [[B ⊕ U ]] = ⋂\n({ [[φ ]] ∪ ε([[φ ]], 〈〈B〉〉, 〈〈U〉〉) | φ ∈ B } ∪ 〈〈U〉〉), which can be written as ⋂ { [[φ ]] ∪ [[B ◦ U ]] | φ ∈ B }∩ ⋂ 〈〈U〉〉 and simplified into ([[B ◦U ]]∪ [[B ]])∩ [[U ]].\nFurthermore, due to (B1) and (B2.1),\n([[B ◦ U ]] ∪ [[B ]]) ∩ [[U ]] = ([[B ◦ U ]] ∩ [[U ]]) ∪ ([[B ]] ∩ [[U ]]) = [[B ◦ U ]] ∪ [[B ∪ U ]] = [[B ◦ U ]] .\nProof of Theorem 37. Follows from Propositions 131 and 132."
    } ],
    "references" : [ {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "C.E. Alchourrón", "P. Gärdenfors", "D. Makinson" ],
      "venue" : "Journal of Symbolic Logic, 50(2):510–530",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "Update-programs can update programs",
      "author" : [ "J.J. Alferes", "L.M. Pereira" ],
      "venue" : "Selected Papers,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1996
    }, {
      "title" : "Dynamic updates of non-monotonic knowledge bases",
      "author" : [ "J.J. Alferes", "J.A. Leite", "L.M. Pereira", "H. Przymusinska", "T.C. Przymusinski" ],
      "venue" : "The Journal of Logic Programming,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2000
    }, {
      "title" : "An evolvable rule-based e-mail agent",
      "author" : [ "J.J. Alferes", "A. Brogi", "J.A. Leite", "L.M. Pereira" ],
      "venue" : "F. Moura-Pires and S. Abreu, editors, Proceedings of the 11th Portuguese Conference Artificial Intelligence ",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "The refined extension principle for semantics of dynamic logic programming",
      "author" : [ "J.J. Alferes", "F. Banti", "A. Brogi", "J.A. Leite" ],
      "venue" : "Studia Logica, 79(1):7–32",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Acyclic programs",
      "author" : [ "K.R. Apt", "M. Bezem" ],
      "venue" : "New Generation Computing, 9(3/4):335–364",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Towards a theory of declarative knowledge",
      "author" : [ "K.R. Apt", "H.A. Blair", "A. Walker" ],
      "venue" : "J. Minker, editor, Foundations of Deductive Databases and Logic Programming, pages 89–148. Morgan Kaufmann, San Francisco, CA, USA",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "editors",
      "author" : [ "F. Baader", "D. Calvanese", "D.L. McGuinness", "D. Nardi", "P.F. Patel-Schneider" ],
      "venue" : "The Description Logic Handbook: Theory, Implementation, and Applications. Cambridge University Press, 2nd edition",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "The description logic ABox update problem revisited",
      "author" : [ "Y. Bong" ],
      "venue" : "Master’s thesis, Dresden University of Technology,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2007
    }, {
      "title" : "Generalized update: Belief change in dynamic settings",
      "author" : [ "C. Boutilier" ],
      "venue" : "In Proceedings of the 14th International Joint Conference on Artificial Intelligence (IJCAI",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1995
    }, {
      "title" : "How to do things with worlds: On formalizing actions and plans",
      "author" : [ "G. Brewka", "J. Hertzberg" ],
      "venue" : "Journal of Logic and Computation, 3(5):517–532",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Minimal logic programs",
      "author" : [ "P. Cabalar", "D. Pearce", "A. Valverde" ],
      "venue" : "V. Dahl and I. Niemelä, editors, Proceedings of the 23rd International Conference on Logic Programming ",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Evolution of DL-Lite knowledge bases",
      "author" : [ "D. Calvanese", "E. Kharlamov", "W. Nutt", "D. Zheleznyakov" ],
      "venue" : "editors, International Semantic Web Conference (1),",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2010
    }, {
      "title" : "Un systéme de communication homme-machine en français",
      "author" : [ "A. Colmerauer", "H. Kanoui", "P. Roussel", "R. Pasero" ],
      "venue" : "Technical report, Groupe de Recherche en Intelligence Artificielle, Université d’Aix-Marseille II",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1973
    }, {
      "title" : "A semantical framework for hybrid knowledge bases",
      "author" : [ "J. de Bruijn", "D. Pearce", "A. Polleres", "A. Valverde" ],
      "venue" : "Journal of Knowledge and Information Systems,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2010
    }, {
      "title" : "Embedding nonground logic programs into autoepistemic logic for knowledge-base combination",
      "author" : [ "J. de Bruijn", "T. Eiter", "A. Polleres", "H. Tompits" ],
      "venue" : "ACM Transactions on Computational Logic (TOCL),",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2011
    }, {
      "title" : "On the update of description logic ontologies at the instance level",
      "author" : [ "G. De Giacomo", "M. Lenzerini", "A. Poggi", "R. Rosati" ],
      "venue" : "In Proceedings of the 21st National Conference on Artificial Intelligence and the 18th Innovative Applications of Artificial Intelligence Conference,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2006
    }, {
      "title" : "On the approximation of instance level update and erasure in description logics",
      "author" : [ "G. De Giacomo", "M. Lenzerini", "A. Poggi", "R. Rosati" ],
      "venue" : "Proceedings of the 22nd AAAI Conference on Artificial Intelligence ",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "On instance-level update and erasure in description logic ontologies",
      "author" : [ "G. De Giacomo", "M. Lenzerini", "A. Poggi", "R. Rosati" ],
      "venue" : "Journal of Logic and Computation, 19(5):745–770",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "A preference-based framework for updating logic programs",
      "author" : [ "J.P. Delgrande", "T. Schaub", "H. Tompits" ],
      "venue" : "C. Baral, G. Brewka, and J. S. Schlipf, editors, Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning ",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A classification theory of semantics of normal logic programs: II",
      "author" : [ "J. Dix" ],
      "venue" : "Weak properties. Fundamenta Informaticae, 22(3): 257–288",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "The PMA and relativizing minimal change for action update",
      "author" : [ "P. Doherty", "W. Lukaszewicz", "E. Madalinska-Bugaj" ],
      "venue" : "Proceedings of the 6th International Conference on Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1998
    }, {
      "title" : "Putting ABox updates into action",
      "author" : [ "C. Drescher", "H. Liu", "F. Baader", "P. Steinke", "M. Thielscher" ],
      "venue" : "Proceedings of the 8th IJCAI International Workshop on Nonmontonic Reasoning, Action and Change (NRAC-09)",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "On properties of update sequences based on causal rejection",
      "author" : [ "T. Eiter", "M. Fink", "G. Sabbatini", "H. Tompits" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP), 2(6):721–777",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "On the semantics of updates in databases",
      "author" : [ "R. Fagin", "J.D. Ullman", "M.Y. Vardi" ],
      "venue" : "Proceedings of the 2nd ACM SIGACT- SIGMOD Symposium on Principles of Database Systems ",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Ontology change: classification and survey",
      "author" : [ "G. Flouris", "D. Makanatas", "H. Kondylakis", "D. Plexousakis", "G. Antoniou" ],
      "venue" : "The Knowledge Engineering Review, 23(2):117–152",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Belief Revision",
      "author" : [ "P. Gärdenfors" ],
      "venue" : "chapter Belief Revision: An Introduction, pages 1–28. Cambridge University Press",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "R. A. Kowalski and K. A. Bowen, editors, Proceedings of the 5th International Conference and Symposium on Logic Programming ",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing, 9 (3-4):365–385",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Counterfactuals",
      "author" : [ "M.L. Ginsberg" ],
      "venue" : "Artificial Intelligence, 30(1):35–79",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Reasoning about action i: A possible worlds approach",
      "author" : [ "M.L. Ginsberg", "D.E. Smith" ],
      "venue" : "Artificial Intelligence, 35(2): 165–195",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Belief base revision for expressive description logics",
      "author" : [ "C. Halaschek-Wiener", "Y. Katz" ],
      "venue" : "Proceedings of the OWLED*06 Workshop on OWL: Experiences and Directions,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2006
    }, {
      "title" : "Reversing the Levi identity",
      "author" : [ "S.O. Hansson" ],
      "venue" : "Journal of Philosophical Logic,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1993
    }, {
      "title" : "Propositional belief base update and minimal change",
      "author" : [ "A. Herzig", "O. Rifi" ],
      "venue" : "Artificial Intelligence, 115(1):107–138",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Ontologies and rules",
      "author" : [ "P. Hitzler", "B. Parsia" ],
      "venue" : "S. Staab and R. Studer, editors, Handbook on Ontologies, International Handbooks on Information Systems, pages 111–132. Springer, Berlin, second edition",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Dynamic logic programming: Various semantics are equal on acyclic programs",
      "author" : [ "M. Homola" ],
      "venue" : "Proceedings of the 5th International Workshop on Computational Logic in Multi-Agent Systems (CLIMA V),",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2004
    }, {
      "title" : "Explicit dynamic user profiles for a collaborative filtering recommender system",
      "author" : [ "M. Ilic", "J. Leite", "M. Slota" ],
      "venue" : "H. Geffner, R. Prada, I. M. Alexandre, and N. David, editors, Proceedings of the 11th Ibero-American Conference on Artificial Intelligence (IBERAMIA’08), volume LNAI 5290, pages 352–361. Springer-Verlag",
      "citeRegEx" : "37",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Negation as failure in the head",
      "author" : [ "K. Inoue", "C. Sakama" ],
      "venue" : "Journal of Logic Programming, 35(1):39–78",
      "citeRegEx" : "38",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Equivalence of logic programs under updates",
      "author" : [ "K. Inoue", "C. Sakama" ],
      "venue" : "J. J. Alferes and J. A. Leite, editors, Proceedings of the 9th European Conference on Logics in Artificial Intelligence ",
      "citeRegEx" : "39",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "On the effect of default negation on the expressiveness of disjunctive rules",
      "author" : [ "T. Janhunen" ],
      "venue" : "T. Eiter, W. Faber, and M. Truszczynski, editors, Proceedings of the 6th International Conference on Logic Programming and Nonmonotonic Reasoning ",
      "citeRegEx" : "40",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "On the difference between updating a knowledge base and revising it",
      "author" : [ "H. Katsuno", "A.O. Mendelzon" ],
      "venue" : "Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 1991
    }, {
      "title" : "On the use of an extended relational model to handle changing incomplete information",
      "author" : [ "A.M. Keller", "M. Winslett" ],
      "venue" : "IEEE Transactions on Software Engineering, 11(7):620–633",
      "citeRegEx" : "42",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "Capturing model-based ontology evolution at the instance level: The case of dl-lite",
      "author" : [ "E. Kharlamov", "D. Zheleznyakov", "D. Calvanese" ],
      "venue" : "Journal of Computer and System Sciences, 79(6):835–872",
      "citeRegEx" : "43",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Local closed world reasoning with description logics under the well-founded semantics",
      "author" : [ "M. Knorr", "J.J. Alferes", "P. Hitzler" ],
      "venue" : "Artificial Intelligence, 175(9-10):1528–1554",
      "citeRegEx" : "44",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Predicate logic as programming language",
      "author" : [ "R.A. Kowalski" ],
      "venue" : "IFIP Congress, pages 569–574",
      "citeRegEx" : "45",
      "shortCiteRegEx" : null,
      "year" : 1974
    }, {
      "title" : "Dependency semantics for sequences of extended logic programs",
      "author" : [ "P. Krümpelmann" ],
      "venue" : "Logic Journal of the IGPL, 20(5): 943–966",
      "citeRegEx" : "46",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "On belief dynamics of dependency relations for extended logic programs",
      "author" : [ "P. Krümpelmann", "G. Kern-Isberner" ],
      "venue" : "In Proceedings of the 13th International Workshop on Non-Monotonic Reasoning,",
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 2010
    }, {
      "title" : "Generalizing updates: From models to programs",
      "author" : [ "J.A. Leite", "L.M. Pereira" ],
      "venue" : "J. Dix, L. M. Pereira, and T. C. Przymusinski, editors, Proceedings of the 3rd International Workshop on Logic Programming and Knowledge Representation (LPKR ’97), October 17",
      "citeRegEx" : "48",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "On the evolution of the instance level of DL-Lite knowledge bases",
      "author" : [ "M. Lenzerini", "D.F. Savo" ],
      "venue" : "R. Rosati, S. Rudolph, and M. Zakharyaschev, editors, Proceedings of the 24th International Workshop on Description Logics ",
      "citeRegEx" : "49",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "V. Lifschitz", "D. Pearce", "A. Valverde" ],
      "venue" : "ACM Transactions on Computational Logic (TOCL), 2(4):526–541",
      "citeRegEx" : "50",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Updating description logic ABoxes",
      "author" : [ "H. Liu", "C. Lutz", "M. Miličić", "F. Wolter" ],
      "venue" : "Proceedings of the 10th International Conference on Principles of Knowledge Representation and Reasoning (KR’06),",
      "citeRegEx" : "51",
      "shortCiteRegEx" : "51",
      "year" : 2006
    }, {
      "title" : "Foundations of Logic Programming",
      "author" : [ "J.W. Lloyd" ],
      "venue" : "Springer, 2nd edition",
      "citeRegEx" : "52",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Revision programming",
      "author" : [ "V.W. Marek", "M. Truszczynski" ],
      "venue" : "Theoretical Computer Science, 190(2):241–277",
      "citeRegEx" : "53",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Reconciling description logics and rules",
      "author" : [ "B. Motik", "R. Rosati" ],
      "venue" : "Journal of the ACM, 57(5):93–154",
      "citeRegEx" : "54",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Updates in answer set programming: An approach based on basic structural properties",
      "author" : [ "M. Osorio", "V. Cuevas" ],
      "venue" : "Theory and Practice of Logic Programming, 7(4):451–479",
      "citeRegEx" : "55",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A new logical characterisation of stable models and answer sets",
      "author" : [ "D. Pearce" ],
      "venue" : "Proceedings of the 6th Workshop on Non-Monotonic Extensions of Logic Programming (NMELP ’96),",
      "citeRegEx" : "56",
      "shortCiteRegEx" : "56",
      "year" : 1997
    }, {
      "title" : "A survey of revision approaches in description logics",
      "author" : [ "G. Qi", "F. Yang" ],
      "venue" : "Proceedings of the 2nd International Conference on Web Reasoning and Rule Systems (RR’08),",
      "citeRegEx" : "57",
      "shortCiteRegEx" : "57",
      "year" : 2008
    }, {
      "title" : "Base revision in description logics - preliminary results",
      "author" : [ "M.M. Ribeiro", "R. Wassermann" ],
      "venue" : "Proceedings of the International Workshop on Ontology Dynamics (IWOD-07), pages 69–82",
      "citeRegEx" : "58",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A methodology to create legal ontologies in a logic programming based web information retrieval system",
      "author" : [ "J. Saias", "P. Quaresma" ],
      "venue" : "Artificial Intelligence and Law, 12(4):397–417",
      "citeRegEx" : "59",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "An abductive framework for computing knowledge base updates",
      "author" : [ "C. Sakama", "K. Inoue" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP), 3(6):671–713",
      "citeRegEx" : "60",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Irrelevant updates and nonmonotonic assumptions",
      "author" : [ "J. Šefránek" ],
      "venue" : "M. Fisher, W. van der Hoek, B. Konev, and A. Lisitsa, editors, Proceedings of the 10th European Conference on Logics in Artificial Intelligence ",
      "citeRegEx" : "61",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Static and dynamic semantics: Preliminary report",
      "author" : [ "J. Šefránek" ],
      "venue" : "Mexican International Conference on Artificial Intelligence, 65  pages 36–42",
      "citeRegEx" : "62",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Dynamic logic programming and world state evaluation in computer games",
      "author" : [ "J. Siska" ],
      "venue" : "Proceedings of the 20th Workshop on Logic Programming,",
      "citeRegEx" : "63",
      "shortCiteRegEx" : "63",
      "year" : 2006
    }, {
      "title" : "Towards Closed World Reasoning in Dynamic Open Worlds. Theory and Practice of Logic Programming, 26th Int’l",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "Conference on Logic Programming (ICLP’10) Special Issue,",
      "citeRegEx" : "64",
      "shortCiteRegEx" : "64",
      "year" : 2010
    }, {
      "title" : "Back and forth between rules and SE-models",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "Proceedings of the 11th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-11),",
      "citeRegEx" : "65",
      "shortCiteRegEx" : "65",
      "year" : 2011
    }, {
      "title" : "Robust equivalence models for semantic updates of answer-set programs",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "G. Brewka, T. Eiter, and S. A. McIlraith, editors, Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning ",
      "citeRegEx" : "66",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A unifying perspective on knowledge updates",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "L. F. del Cerro, A. Herzig, and J. Mengin, editors, Proceedings of the 13th European Conference on Logics in Artificial Intelligence ",
      "citeRegEx" : "67",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "On condensing a sequence of updates in answer-set programming",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "Proceedings of the 23rd International Joint Conference on Artificial Intelligence (IJCAI’13). AAAI Press",
      "citeRegEx" : "68",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "The rise and fall of semantic rule updates based on SE-models",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP)",
      "citeRegEx" : "69",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Splitting and updating hybrid knowledge bases",
      "author" : [ "M. Slota", "J. Leite", "T. Swift" ],
      "venue" : "Theory and Practice of Logic Programming, 27th Int’l. Conference on Logic Programming (ICLP’11) Special Issue, 11(4-5):801–819",
      "citeRegEx" : "70",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Strong equivalence made easy: nested expressions and weight constraints",
      "author" : [ "H. Turner" ],
      "venue" : "Theory and Practice of Logic Programming (TPLP), 3(4-5):609–622",
      "citeRegEx" : "71",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Reasoning about action using a possible models approach",
      "author" : [ "M. Winslett" ],
      "venue" : "Proceedings of the 7th National Conference on Artificial Intelligence ",
      "citeRegEx" : "72",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Updating Logical Databases",
      "author" : [ "M. Winslett" ],
      "venue" : "Cambridge University Press, New York, USA",
      "citeRegEx" : "73",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "A stronger notion of equivalence for logic programs",
      "author" : [ "K.-S. Wong" ],
      "venue" : "V. Dahl and I. Niemelä, editors, Proceedings of the 23rd International Conference on Logic Programming ",
      "citeRegEx" : "74",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Logic program-based updates",
      "author" : [ "Y. Zhang" ],
      "venue" : "ACM Transactions on Computational Logic, 7(3):421–472",
      "citeRegEx" : "75",
      "shortCiteRegEx" : null,
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 7,
      "context" : "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.",
      "startOffset" : 200,
      "endOffset" : 203
    }, {
      "referenceID" : 13,
      "context" : "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.",
      "startOffset" : 226,
      "endOffset" : 242
    }, {
      "referenceID" : 27,
      "context" : "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.",
      "startOffset" : 226,
      "endOffset" : 242
    }, {
      "referenceID" : 44,
      "context" : "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.",
      "startOffset" : 226,
      "endOffset" : 242
    }, {
      "referenceID" : 51,
      "context" : "Recent standardisation efforts gave rise to widely accepted knowledge representation languages such as the Web Ontology Language (OWL)1 and Rule Interchange Format (RIF),2 based on Description Logics [8] and Logic Programming [14, 28, 45, 52], respectively.",
      "startOffset" : 226,
      "endOffset" : 242
    }, {
      "referenceID" : 65,
      "context" : "This is a revised and extended version of the material presented in [66–68].",
      "startOffset" : 68,
      "endOffset" : 75
    }, {
      "referenceID" : 66,
      "context" : "This is a revised and extended version of the material presented in [66–68].",
      "startOffset" : 68,
      "endOffset" : 75
    }, {
      "referenceID" : 67,
      "context" : "This is a revised and extended version of the material presented in [66–68].",
      "startOffset" : 68,
      "endOffset" : 75
    }, {
      "referenceID" : 14,
      "context" : "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].",
      "startOffset" : 160,
      "endOffset" : 180
    }, {
      "referenceID" : 15,
      "context" : "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].",
      "startOffset" : 160,
      "endOffset" : 180
    }, {
      "referenceID" : 34,
      "context" : "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].",
      "startOffset" : 160,
      "endOffset" : 180
    }, {
      "referenceID" : 43,
      "context" : "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].",
      "startOffset" : 160,
      "endOffset" : 180
    }, {
      "referenceID" : 53,
      "context" : "Over the years, work on hybrid knowledge bases has matured significantly and fundamental semantic as well as computational problems were addressed successfully [15, 16, 35, 44, 54].",
      "startOffset" : 160,
      "endOffset" : 180
    }, {
      "referenceID" : 25,
      "context" : "Ontology Updates The area of research called ontology change encompasses a number of strongly related though distinguishable subareas, such as ontology matching, ontology integration and merging, or ontology translation [26].",
      "startOffset" : 220,
      "endOffset" : 224
    }, {
      "referenceID" : 0,
      "context" : "Approaches to ontology evolution with a firm semantic underpinning, thus amenable to a formal analysis of their behaviour and properties, are based on research in the area of belief change, initiated by the seminal work of Alchourrón, Gärdenfors and Makinson (AGM) [1] who proposed a set of desirable properties of change operators on monotonic logics, now referred to as the AGM postulates.",
      "startOffset" : 265,
      "endOffset" : 268
    }, {
      "referenceID" : 40,
      "context" : "Subsequently, revision and update were distinguished as two very related but ultimately different belief change operations [41, 42, 73].",
      "startOffset" : 123,
      "endOffset" : 135
    }, {
      "referenceID" : 41,
      "context" : "Subsequently, revision and update were distinguished as two very related but ultimately different belief change operations [41, 42, 73].",
      "startOffset" : 123,
      "endOffset" : 135
    }, {
      "referenceID" : 72,
      "context" : "Subsequently, revision and update were distinguished as two very related but ultimately different belief change operations [41, 42, 73].",
      "startOffset" : 123,
      "endOffset" : 135
    }, {
      "referenceID" : 40,
      "context" : "While AGM postulates were deemed appropriate for describing revision, Katsuno and Mendelzon suggested a different set of postulates for updates: the KM postulates for belief update [41].",
      "startOffset" : 181,
      "endOffset" : 185
    }, {
      "referenceID" : 41,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 71,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 8,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 16,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 17,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 18,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 22,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 42,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 50,
      "context" : "These ideas, and particularly Winslett’s update operator [42, 72], were later used to partially address ontology updates [9, 17–19, 23, 43, 51], namely to update the part of the ontology with assertions about individuals (the ABox).",
      "startOffset" : 121,
      "endOffset" : 143
    }, {
      "referenceID" : 12,
      "context" : "On the other hand, model-based operators are considered inappropriate for updating ontological axioms that define the terminology (the TBox) [13, 64].",
      "startOffset" : 141,
      "endOffset" : 149
    }, {
      "referenceID" : 63,
      "context" : "On the other hand, model-based operators are considered inappropriate for updating ontological axioms that define the terminology (the TBox) [13, 64].",
      "startOffset" : 141,
      "endOffset" : 149
    }, {
      "referenceID" : 12,
      "context" : "Their antipole, formula-based operators, which manipulate the knowledge base at a syntactic level and are strongly related to base revision operators, were adopted for performing TBox updates instead [13], and they also inspired a recent approach to ABox updates [49].",
      "startOffset" : 200,
      "endOffset" : 204
    }, {
      "referenceID" : 48,
      "context" : "Their antipole, formula-based operators, which manipulate the knowledge base at a syntactic level and are strongly related to base revision operators, were adopted for performing TBox updates instead [13], and they also inspired a recent approach to ABox updates [49].",
      "startOffset" : 263,
      "endOffset" : 267
    }, {
      "referenceID" : 1,
      "context" : "Rule Updates When updates started to be investigated in the context of Logic Programming, it was only natural to adapt belief update principles and operators to this purpose [2, 53].",
      "startOffset" : 174,
      "endOffset" : 181
    }, {
      "referenceID" : 52,
      "context" : "Rule Updates When updates started to be investigated in the context of Logic Programming, it was only natural to adapt belief update principles and operators to this purpose [2, 53].",
      "startOffset" : 174,
      "endOffset" : 181
    }, {
      "referenceID" : 47,
      "context" : "However, such approaches proved insufficiently expressive, principally because the model-based approach fails to capture the essential relationships between literals encoded in rules [48], and the formula-based approach is too crude as it does not",
      "startOffset" : 183,
      "endOffset" : 187
    }, {
      "referenceID" : 74,
      "context" : "allow rules to be reactivated when reasons for their suppression disappear [75].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 2,
      "context" : "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.",
      "startOffset" : 57,
      "endOffset" : 75
    }, {
      "referenceID" : 4,
      "context" : "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.",
      "startOffset" : 57,
      "endOffset" : 75
    }, {
      "referenceID" : 23,
      "context" : "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.",
      "startOffset" : 57,
      "endOffset" : 75
    }, {
      "referenceID" : 47,
      "context" : "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.",
      "startOffset" : 57,
      "endOffset" : 75
    }, {
      "referenceID" : 54,
      "context" : "Many of them are based on the causal rejection principle [3, 5, 24, 48, 55], which states that a rule is rejected only if it is directly contradicted by a more recent rule.",
      "startOffset" : 57,
      "endOffset" : 75
    }, {
      "referenceID" : 3,
      "context" : "Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable.",
      "startOffset" : 73,
      "endOffset" : 88
    }, {
      "referenceID" : 36,
      "context" : "Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable.",
      "startOffset" : 73,
      "endOffset" : 88
    }, {
      "referenceID" : 58,
      "context" : "Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable.",
      "startOffset" : 73,
      "endOffset" : 88
    }, {
      "referenceID" : 62,
      "context" : "Causal rejection semantics are useful in a number of practical scenarios [4, 37, 59, 63] and their behaviour is intuitively predictable.",
      "startOffset" : 73,
      "endOffset" : 88
    }, {
      "referenceID" : 59,
      "context" : "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 19,
      "context" : "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].",
      "startOffset" : 146,
      "endOffset" : 154
    }, {
      "referenceID" : 74,
      "context" : "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].",
      "startOffset" : 146,
      "endOffset" : 154
    }, {
      "referenceID" : 46,
      "context" : "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].",
      "startOffset" : 195,
      "endOffset" : 203
    }, {
      "referenceID" : 61,
      "context" : "Alternative approaches to rule updates employ syntactic transformations and other methods, such as abduction [60], prioritisation and preferences [20, 75], or dependencies on default assumptions [47, 62].",
      "startOffset" : 195,
      "endOffset" : 203
    }, {
      "referenceID" : 63,
      "context" : "It is also important for the development of update semantics for hybrid knowledge bases – in [64, 70] we provided partial solutions to this problem but the inherent differences between the distinct approaches to updates have prevented us from suggesting a universal hybrid update semantics.",
      "startOffset" : 93,
      "endOffset" : 101
    }, {
      "referenceID" : 69,
      "context" : "It is also important for the development of update semantics for hybrid knowledge bases – in [64, 70] we provided partial solutions to this problem but the inherent differences between the distinct approaches to updates have prevented us from suggesting a universal hybrid update semantics.",
      "startOffset" : 93,
      "endOffset" : 101
    }, {
      "referenceID" : 68,
      "context" : "In [69] we have shown that strong equivalence is not a suitable basis for syntax-independent rule update operators because such operators cannot respect both support and fact update.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 64,
      "context" : "In [65] we proposed to view a program as the set of sets of models of its rules in order to acknowledge rules as the atomic pieces of knowledge and, at the same time, abstract away from unimportant differences between their syntactic forms, focusing on their semantic content.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 5,
      "context" : "A program is non-disjunctive if all its rules are; acyclic if it satisfies the conditions set out in [6].",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 27,
      "context" : "Turning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program.",
      "startOffset" : 58,
      "endOffset" : 66
    }, {
      "referenceID" : 28,
      "context" : "Turning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program.",
      "startOffset" : 58,
      "endOffset" : 66
    }, {
      "referenceID" : 55,
      "context" : "Turning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program.",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 70,
      "context" : "Turning to the semantics, we need to define stable models [28, 29] and SE-models [56, 71] of a logic program.",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 8,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 12,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 16,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 17,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 18,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 22,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 42,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 48,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 50,
      "context" : "In this section we briefly introduce model-based as well as formula-based belief update operators which form the basis of formal approaches to ontology updates [9, 13, 17–19, 23, 43, 49, 51].",
      "startOffset" : 160,
      "endOffset" : 190
    }, {
      "referenceID" : 40,
      "context" : "The fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state.",
      "startOffset" : 61,
      "endOffset" : 77
    }, {
      "referenceID" : 41,
      "context" : "The fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state.",
      "startOffset" : 61,
      "endOffset" : 77
    }, {
      "referenceID" : 71,
      "context" : "The fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state.",
      "startOffset" : 61,
      "endOffset" : 77
    }, {
      "referenceID" : 72,
      "context" : "The fundamental idea underlying model-based update operators [41, 42, 72, 73] is that models of the original knowledge base are viewed as possible or admissible states of the modelled domain, only one of which is the actual state.",
      "startOffset" : 61,
      "endOffset" : 77
    }, {
      "referenceID" : 41,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 144,
      "endOffset" : 152
    }, {
      "referenceID" : 71,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 144,
      "endOffset" : 152
    }, {
      "referenceID" : 8,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 201,
      "endOffset" : 223
    }, {
      "referenceID" : 16,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 201,
      "endOffset" : 223
    }, {
      "referenceID" : 17,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 201,
      "endOffset" : 223
    }, {
      "referenceID" : 18,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 201,
      "endOffset" : 223
    }, {
      "referenceID" : 22,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 201,
      "endOffset" : 223
    }, {
      "referenceID" : 42,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 201,
      "endOffset" : 223
    }, {
      "referenceID" : 50,
      "context" : "For instance, Winslett’s operator, first introduced to deal with change in action theories and relational databases with incomplete information [42, 72], and used extensively to study ontology updates [9, 17–19, 23, 43, 51], is characterised by equation (1) where incorporate(M, I) is the set of models fromM that interpret a minimal set of atoms differently than I .",
      "startOffset" : 201,
      "endOffset" : 223
    }, {
      "referenceID" : 40,
      "context" : "From a more general perspective, Katsuno and Mendelzon have shown [41] that if each knowledge base is represented by a single formula and incorporate(M, I) is bound to return those members ofM that are minimal w.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 33,
      "context" : "Some of these postulates, and especially (B4) which guarantees syntax-independence of an update operator, continue to be seen as fundamental cornerstones of belief updates [34].",
      "startOffset" : 172,
      "endOffset" : 176
    }, {
      "referenceID" : 9,
      "context" : "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].",
      "startOffset" : 55,
      "endOffset" : 71
    }, {
      "referenceID" : 10,
      "context" : "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].",
      "startOffset" : 55,
      "endOffset" : 71
    }, {
      "referenceID" : 21,
      "context" : "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].",
      "startOffset" : 55,
      "endOffset" : 71
    }, {
      "referenceID" : 33,
      "context" : "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].",
      "startOffset" : 55,
      "endOffset" : 71
    }, {
      "referenceID" : 33,
      "context" : "The desirability of others has been questioned by many [10, 11, 22, 34], and particularly (B2), (B5), (B6) and (B7) are deemed controversial: the first three sometimes lead to undesirable behaviour while the last one is hard to explain intuitively and is satisfied only by a minority of existing update operators [34].",
      "startOffset" : 313,
      "endOffset" : 317
    }, {
      "referenceID" : 33,
      "context" : "2) [34].",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 72,
      "context" : "Earlier approaches to updates, dubbed formula-based [73], operate on the syntax of a knowledge base and, as a consequence, are not syntax-independent.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 12,
      "context" : "Nevertheless, they have recently been considered for performing ontology updates [13, 49].",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 48,
      "context" : "Nevertheless, they have recently been considered for performing ontology updates [13, 49].",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 24,
      "context" : "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 29,
      "context" : "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].",
      "startOffset" : 106,
      "endOffset" : 118
    }, {
      "referenceID" : 30,
      "context" : "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].",
      "startOffset" : 106,
      "endOffset" : 118
    }, {
      "referenceID" : 72,
      "context" : "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].",
      "startOffset" : 106,
      "endOffset" : 118
    }, {
      "referenceID" : 29,
      "context" : "Traditional formula-based update operators are Set-Of-Theories [25], WIDTIO (When In Doubt, Throw It Out) [30, 31, 73] and Cross-Product [30].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 12,
      "context" : "Additionally, in [13] the new formula-based operator Bold was suggested for performing TBox updates.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 6,
      "context" : "In the static setting, support [7, 21] is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy.",
      "startOffset" : 31,
      "endOffset" : 38
    }, {
      "referenceID" : 20,
      "context" : "In the static setting, support [7, 21] is one of the basic conditions that Logic Programming semantics are intuitively designed to satisfy.",
      "startOffset" : 31,
      "endOffset" : 38
    }, {
      "referenceID" : 2,
      "context" : "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].",
      "startOffset" : 133,
      "endOffset" : 151
    }, {
      "referenceID" : 4,
      "context" : "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].",
      "startOffset" : 133,
      "endOffset" : 151
    }, {
      "referenceID" : 23,
      "context" : "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].",
      "startOffset" : 133,
      "endOffset" : 151
    }, {
      "referenceID" : 47,
      "context" : "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].",
      "startOffset" : 133,
      "endOffset" : 151
    }, {
      "referenceID" : 54,
      "context" : "We also introduce two further syntactic properties that are more tightly bound to approaches based on the causal rejection principle [3, 5, 24, 48, 55].",
      "startOffset" : 133,
      "endOffset" : 151
    }, {
      "referenceID" : 4,
      "context" : "The final syntactic property stems from the fact that all rule update semantics based on causal rejection coincide on acyclic DLPs [5, 36].",
      "startOffset" : 131,
      "endOffset" : 138
    }, {
      "referenceID" : 35,
      "context" : "The final syntactic property stems from the fact that all rule update semantics based on causal rejection coincide on acyclic DLPs [5, 36].",
      "startOffset" : 131,
      "endOffset" : 138
    }, {
      "referenceID" : 47,
      "context" : "Before formalising the property, we define two foundational rule update semantics based on causal rejection: the JU-semantics [48] and the UA-semantics [24].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 23,
      "context" : "Before formalising the property, we define two foundational rule update semantics based on causal rejection: the JU-semantics [48] and the UA-semantics [24].",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 47,
      "context" : "Definition 3 (JU-Semantics [48] and UA-Semantics [24]).",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 23,
      "context" : "Definition 3 (JU-Semantics [48] and UA-Semantics [24]).",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 23,
      "context" : "The only difference in the UA-semantics [24] is that rejected rules are prevented from rejecting other rules.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 49,
      "context" : "This gives rise to the notion of strong equivalence [50] which requires that stable models stay the same even in the presence of additional rules.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 70,
      "context" : "It is a well-known fact that programs are strongly equivalent if and only if they have the same set of SE-models [71].",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 68,
      "context" : "But even SE-equivalence is not satisfactory when used as a basis for syntax-independent rule update operators because such operators cannot respect both support and fact update [69].",
      "startOffset" : 177,
      "endOffset" : 181
    }, {
      "referenceID" : 38,
      "context" : "One candidate is the strong update equivalence (or SU-equivalence) [39], which requires that under both additions and removals of rules, stable models of the two programs in question remain the same.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 38,
      "context" : "It has been shown in [39] that this notion of equivalence is very strong – programs are SU-equivalent only if they contain exactly the same non-tautological rules, and in addition, each of them may contain some tautological ones.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 64,
      "context" : "This observation resulted in the definition of strong rule equivalence (or SR-equivalence) and strong minimal rule equivalence (or SMR-equivalence) in [65] that, in terms of strength, fall between SE-equivalence and SU-equivalence.",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 64,
      "context" : "Proposition 5 ([65]).",
      "startOffset" : 15,
      "endOffset" : 19
    }, {
      "referenceID" : 64,
      "context" : "In [65] we studied the expressivity of SE-models with respect to a single rule.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 11,
      "context" : "On the other hand, a rule with a default literal in its head is indistinguishable from an integrity constraint [12, 38, 40].",
      "startOffset" : 111,
      "endOffset" : 123
    }, {
      "referenceID" : 37,
      "context" : "On the other hand, a rule with a default literal in its head is indistinguishable from an integrity constraint [12, 38, 40].",
      "startOffset" : 111,
      "endOffset" : 123
    }, {
      "referenceID" : 39,
      "context" : "On the other hand, a rule with a default literal in its head is indistinguishable from an integrity constraint [12, 38, 40].",
      "startOffset" : 111,
      "endOffset" : 123
    }, {
      "referenceID" : 2,
      "context" : "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.",
      "startOffset" : 75,
      "endOffset" : 93
    }, {
      "referenceID" : 4,
      "context" : "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.",
      "startOffset" : 75,
      "endOffset" : 93
    }, {
      "referenceID" : 23,
      "context" : "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.",
      "startOffset" : 75,
      "endOffset" : 93
    }, {
      "referenceID" : 47,
      "context" : "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.",
      "startOffset" : 75,
      "endOffset" : 93
    }, {
      "referenceID" : 54,
      "context" : "This convention is adopted by causal rejection-based rule update semantics [3, 5, 24, 48, 55] which constitute one of the most mature approaches to rule updates.",
      "startOffset" : 75,
      "endOffset" : 93
    }, {
      "referenceID" : 64,
      "context" : "Further properties of RE-models, analogous to those established in [65] for SE-models, can be found in Appendix A starting on page 31.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 68,
      "context" : "This means that δa-based rule update operators enjoy a combination of desirable syntactic properties that operators based on SE-models cannot [69].",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 4,
      "context" : "Traditional Semantic Properties of Rule Updates The properties in the upper part of Table 2 were introduced in [5, 20, 24].",
      "startOffset" : 111,
      "endOffset" : 122
    }, {
      "referenceID" : 19,
      "context" : "Traditional Semantic Properties of Rule Updates The properties in the upper part of Table 2 were introduced in [5, 20, 24].",
      "startOffset" : 111,
      "endOffset" : 122
    }, {
      "referenceID" : 23,
      "context" : "Traditional Semantic Properties of Rule Updates The properties in the upper part of Table 2 were introduced in [5, 20, 24].",
      "startOffset" : 111,
      "endOffset" : 122
    }, {
      "referenceID" : 2,
      "context" : "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 142,
      "endOffset" : 169
    }, {
      "referenceID" : 19,
      "context" : "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 142,
      "endOffset" : 169
    }, {
      "referenceID" : 23,
      "context" : "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 142,
      "endOffset" : 169
    }, {
      "referenceID" : 47,
      "context" : "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 142,
      "endOffset" : 169
    }, {
      "referenceID" : 54,
      "context" : "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 142,
      "endOffset" : 169
    }, {
      "referenceID" : 59,
      "context" : "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 142,
      "endOffset" : 169
    }, {
      "referenceID" : 74,
      "context" : "Note that these properties are generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 142,
      "endOffset" : 169
    }, {
      "referenceID" : 33,
      "context" : "Note also that (B7) has been heavily criticised in the literature as being mainly a means to achieve formal results instead of an intuitive principle [34] and though (B8) reflects the basic intuition behind belief update – that of updating each model independently of the others – such a point of view is hardly transferable to knowledge represented using rules because a single model, be it a classical, stable, SE- or RE-model, fails to encode the interdependencies between literals expressed in rules that are necessary for properties such as support.",
      "startOffset" : 150,
      "endOffset" : 154
    }, {
      "referenceID" : 33,
      "context" : ">) [34].",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 33,
      "context" : ">) [34].",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 68,
      "context" : "[69] and the above discussion of (Idempotence), (Absorption) and (Augmentation)).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 115,
      "endOffset" : 142
    }, {
      "referenceID" : 19,
      "context" : ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 115,
      "endOffset" : 142
    }, {
      "referenceID" : 23,
      "context" : ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 115,
      "endOffset" : 142
    }, {
      "referenceID" : 47,
      "context" : ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 115,
      "endOffset" : 142
    }, {
      "referenceID" : 54,
      "context" : ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 115,
      "endOffset" : 142
    }, {
      "referenceID" : 59,
      "context" : ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 115,
      "endOffset" : 142
    }, {
      "referenceID" : 74,
      "context" : ">), generally acknowledged as very desirable although most existing rule update semantics fail to comply with them [3, 20, 24, 48, 55, 60, 75].",
      "startOffset" : 115,
      "endOffset" : 142
    }, {
      "referenceID" : 9,
      "context" : "Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].",
      "startOffset" : 142,
      "endOffset" : 158
    }, {
      "referenceID" : 10,
      "context" : "Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].",
      "startOffset" : 142,
      "endOffset" : 158
    }, {
      "referenceID" : 21,
      "context" : "Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].",
      "startOffset" : 142,
      "endOffset" : 158
    }, {
      "referenceID" : 33,
      "context" : "Coincidentally, with the exception of (B3), the violated postulates are the ones that are deemed controversial in the belief update community [10, 11, 22, 34].",
      "startOffset" : 142,
      "endOffset" : 158
    }, {
      "referenceID" : 2,
      "context" : "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.",
      "startOffset" : 50,
      "endOffset" : 68
    }, {
      "referenceID" : 4,
      "context" : "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.",
      "startOffset" : 50,
      "endOffset" : 68
    }, {
      "referenceID" : 23,
      "context" : "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.",
      "startOffset" : 50,
      "endOffset" : 68
    }, {
      "referenceID" : 47,
      "context" : "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.",
      "startOffset" : 50,
      "endOffset" : 68
    }, {
      "referenceID" : 54,
      "context" : "For instance, semantics based on causal rejection [3, 5, 24, 48, 55], such as the JU- and UA-semantics, assign models to sequences of non-disjunctive programs and sometimes admit non-minimal models which no non-disjunctive program can capture.",
      "startOffset" : 50,
      "endOffset" : 68
    }, {
      "referenceID" : 59,
      "context" : "A different approach in [60] deals with program updates by borrowing ideas from literature on belief revision and utilising an abductive framework to accomplish such updates.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 74,
      "context" : "A somewhat similar situation occurs with the approach of [75] where intricate syntactic transformations are combined with a semantics for prioritised logic programs that ultimately leads to a set of logic programs.",
      "startOffset" : 57,
      "endOffset" : 61
    }, {
      "referenceID" : 19,
      "context" : "The rule update semantics suggested in [20] are also based on syntactic transformations into a logic program with preferences among rules, but in contrast with [75], the semantics of such programs is defined by directly specifying their preferred stable models and not by translation into an ordinary program (or a set thereof).",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 74,
      "context" : "The rule update semantics suggested in [20] are also based on syntactic transformations into a logic program with preferences among rules, but in contrast with [75], the semantics of such programs is defined by directly specifying their preferred stable models and not by translation into an ordinary program (or a set thereof).",
      "startOffset" : 160,
      "endOffset" : 164
    }, {
      "referenceID" : 45,
      "context" : "Finally, frameworks that specify program updates by manipulating dependencies on default assumptions induced by rules [46, 61, 62] are mainly concerned with identifying the effects of irrelevant updates and",
      "startOffset" : 118,
      "endOffset" : 130
    }, {
      "referenceID" : 60,
      "context" : "Finally, frameworks that specify program updates by manipulating dependencies on default assumptions induced by rules [46, 61, 62] are mainly concerned with identifying the effects of irrelevant updates and",
      "startOffset" : 118,
      "endOffset" : 130
    }, {
      "referenceID" : 61,
      "context" : "Finally, frameworks that specify program updates by manipulating dependencies on default assumptions induced by rules [46, 61, 62] are mainly concerned with identifying the effects of irrelevant updates and",
      "startOffset" : 118,
      "endOffset" : 130
    }, {
      "referenceID" : 70,
      "context" : "First we define simple and elegant operators on subclasses of nested logic programs [71] with the required property.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 70,
      "context" : "We adopt the syntax and stable model semantics of logic programs with nested expressions [71].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 54,
      "context" : "Interestingly, an operator very similar to ⊕JU has been studied by Osorio and Cuevas [55].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 37,
      "context" : "Furthermore, when Hπ is a default literal, it is more convenient to move the new default literals from the head into the body since this operation preserves stable models [38] and makes it easier to pinpoint the original head literal in the rule.",
      "startOffset" : 171,
      "endOffset" : 175
    }, {
      "referenceID" : 23,
      "context" : "Additionally, in order to find its stable models, a more efficient translation can be used that utilises additional meta-level atoms to prevent the exponential explosion (see [24, 48] for further details).",
      "startOffset" : 175,
      "endOffset" : 183
    }, {
      "referenceID" : 47,
      "context" : "Additionally, in order to find its stable models, a more efficient translation can be used that utilises additional meta-level atoms to prevent the exponential explosion (see [24, 48] for further details).",
      "startOffset" : 175,
      "endOffset" : 183
    }, {
      "referenceID" : 33,
      "context" : "1) and (B4) [34].",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 32,
      "context" : "The typical properties satisfied by AGM revision operators include success, inclusion and extensionality [33], formalised, respectively, as",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 48,
      "context" : "Note also that the operator adopted for ABox updates in [49], inspired by WIDTIO, performs a deductive closure of the ABox before updating it, so it corresponds to the standard full meet AGM revision operator.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 29,
      "context" : "The WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations.",
      "startOffset" : 20,
      "endOffset" : 32
    }, {
      "referenceID" : 30,
      "context" : "The WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations.",
      "startOffset" : 20,
      "endOffset" : 32
    }, {
      "referenceID" : 72,
      "context" : "The WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations.",
      "startOffset" : 20,
      "endOffset" : 32
    }, {
      "referenceID" : 12,
      "context" : "The WIDTIO operator [30, 31, 73] satisfies all of these principles, and so does the Bold operator [13] if it is based on a remainder selection function that selects remainders with the same semantic characterisation when given sets of remainders with the same sets of semantic characterisations.",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 29,
      "context" : "The Cross-Product operator [30] satisfies (F1) (thus also (B1)), (B2.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 26,
      "context" : "1) and (F4) are closely related with the properties of base revision operators [27, 33].",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 32,
      "context" : "1) and (F4) are closely related with the properties of base revision operators [27, 33].",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 32,
      "context" : "In particular, two types of base revision are identified in [33], the internal and external base revision.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 12,
      "context" : "Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett’s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51].",
      "startOffset" : 248,
      "endOffset" : 264
    }, {
      "referenceID" : 18,
      "context" : "Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett’s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51].",
      "startOffset" : 248,
      "endOffset" : 264
    }, {
      "referenceID" : 48,
      "context" : "Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett’s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51].",
      "startOffset" : 248,
      "endOffset" : 264
    }, {
      "referenceID" : 50,
      "context" : "Then we showed that exception-based operators for propositional knowledge bases can fully capture update operators that form the basis of ontology updates, such as the model-based Winslett’s operator, or the formula-based WIDTIO and Bold operators [13, 19, 49, 51].",
      "startOffset" : 248,
      "endOffset" : 264
    }, {
      "referenceID" : 72,
      "context" : "The Cross-Product operator can be captured when a single update is performed and the same can be said about the Set-Of-Theories operator since for a single update it is equivalent to the Cross-Product operator [73].",
      "startOffset" : 210,
      "endOffset" : 214
    }, {
      "referenceID" : 4,
      "context" : "due to the need to detect non-tautological irrelevant updates [5, 61, 62].",
      "startOffset" : 62,
      "endOffset" : 73
    }, {
      "referenceID" : 60,
      "context" : "due to the need to detect non-tautological irrelevant updates [5, 61, 62].",
      "startOffset" : 62,
      "endOffset" : 73
    }, {
      "referenceID" : 61,
      "context" : "due to the need to detect non-tautological irrelevant updates [5, 61, 62].",
      "startOffset" : 62,
      "endOffset" : 73
    }, {
      "referenceID" : 73,
      "context" : "In this context, the close relationship between RE-models and T-models [74], used in the context of forgetting in logic programs, asks for more attention as well.",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 31,
      "context" : "revision operators, on both belief sets and belief bases, can be used to tackle and unify approaches to ontology revision [32, 57, 58].",
      "startOffset" : 122,
      "endOffset" : 134
    }, {
      "referenceID" : 56,
      "context" : "revision operators, on both belief sets and belief bases, can be used to tackle and unify approaches to ontology revision [32, 57, 58].",
      "startOffset" : 122,
      "endOffset" : 134
    }, {
      "referenceID" : 57,
      "context" : "revision operators, on both belief sets and belief bases, can be used to tackle and unify approaches to ontology revision [32, 57, 58].",
      "startOffset" : 122,
      "endOffset" : 134
    }, {
      "referenceID" : 12,
      "context" : "This seems relevant even in the context of ontology updates since it has been argued in the literature that the strict distinction between revision and update is not suitable in the context of ontologies [13].",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 64,
      "context" : "We begin by defining a set of representatives of rule equivalence classes induced by SE-models, as it was introduced in [65] since it is needed in our proofs.",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 64,
      "context" : "Definition 38 (Transformation into an SE-Canonical Rule [65]).",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 64,
      "context" : "Proposition 39 ([65]).",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 64,
      "context" : "Corollary 40 ([65]).",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 64,
      "context" : "The following presentation follows a similar pattern as the one used in [65] for SE-models.",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 33,
      "context" : "2) has also been subject of harsh criticism in belief update literature [34].",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 49,
      "context" : "Definition 108 (Strong Equivalence [50]).",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 49,
      "context" : "Proposition 109 ([50, 71]).",
      "startOffset" : 17,
      "endOffset" : 25
    }, {
      "referenceID" : 70,
      "context" : "Proposition 109 ([50, 71]).",
      "startOffset" : 17,
      "endOffset" : 25
    } ],
    "year" : 2017,
    "abstractText" : "Existing methods for dealing with knowledge updates differ greatly depending on the underlying knowledge representation formalism. When Classical Logic is used, updates are typically performed by manipulating the knowledge base on the model-theoretic level. On the opposite side of the spectrum stand the semantics for updating Answer-Set Programs that need to rely on rule syntax. Yet, a unifying perspective that could embrace both these branches of research is of great importance as it enables a deeper understanding of all involved methods and principles and creates room for their cross-fertilisation, ripening and further development. Furthermore, from a more pragmatic viewpoint, such a unification is a necessary step in addressing updates of hybrid knowledge bases consisting of both a classical and a rule component. This paper bridges the seemingly irreconcilable approaches to updates. It introduces a novel monotonic characterisation of rules, dubbed RE-models, and shows it to be a more suitable semantic foundation for rule updates than SE-models. Then it proposes a generic scheme for specifying semantic rule update operators, based on the idea of viewing a program as the set of sets of RE-models of its rules; updates are performed by introducing additional interpretations – exceptions – to the sets of RE-models of rules in the original program. The introduced scheme is then used to define particular rule update operators that are closely related to both classical update principles and traditional approaches to rules updates, enjoying a range of plausible syntactic as well as semantic properties. In addition, these operators serve as a basis for a solution to the long-standing problem of state condensing for two of the foundational rule update semantics, showing how they can be equivalently defined as binary operators on some class of logic programs. Finally, the essence of these ideas is extracted to define an abstract framework for exception-based update operators, viewing a knowledge base as the set of sets of models of its elements. It is shown that the framework can capture a wide range of both modeland formula-based classical update operators, and thus serves as the first firm formal ground connecting classical and rule updates.",
    "creator" : "LaTeX with hyperref package"
  }
}