{
  "name" : "1602.02706.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Decoy Bandits Dueling on a Poset",
    "authors" : [ "Julien Audiffren", "Liva Ralaivola" ],
    "emails" : [ "audiffren@cmla.ens-cachan.fr", "liva.ralaivola@lif.univ-mrs.fr" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Chasing the optimal set for cold-start recommendation. Today’s recommendation systems heavily rely on machine learning. Dedicated techniques may indeed be designed to extract statistical regularities from a set of collected behaviors and provide users with relevant recommendations. One of the main challenges a recommendation system has to deal with is cold-start, i.e. the situation where recommendations must be computed for a user for whom no information has been collected. A common strategy to get around this problem is to have at hand a set of default items to recommend to any new customer. The design of such a set is then paramount to the user experience with the recommendation system and to his willingness to rely on it for future movie suggestions. A natural goal is therefore to try to form a set of best movies. Identifying the best movies is a task that requires a proper handling of two features: a) the variety of existing film genres (documentary, drama, comedy. . . ) and b) the uncertainty with which one film may be considered better than another. The variety of genres induces the issue of incomparability: there are pairs of movies —comparison of pairs is evidently at the core of the best movie selection process— that cannot be compared such as, e.g., a documentary and a horror movie. This means that movies are only partially ordered and it suggests that the set of best movies must contain incomparable movies. Said otherwise, each movie from the set is the best in its category. The uncertainty issue mentioned above then arises within a single genre as it might be complex to assert that a film is better than another. A way to bypass this difficulty is to rely on a committee of critics and to aggregate the (noisy) opinions of its members on pairs of comparable movies. This might be implemented as follows: for each pair of films, committee members are chosen at random and asked which of the two movies is the better, and the movie that wins the most among the random probes is decided to be the best. This introduction provides a practical motivation for the present paper where we study the question of deriving strategies for dueling bandits defined on partially ordered sets, or posets. We are in particular interested in being able to find the set of best arms among all the (possibly incomparable) arms at hand.\nDueling Bandits on Posets. Dueling bandits were introduced by Yue et al. [2012]. The setting, pertaining to the K-armed bandit framework, assumes there is no direct access to the reward provided\nar X\niv :1\n60 2.\n02 70\n6v 2\n[ cs\n.L G\n] 9\nJ un\n2 01\nby any single arm and the only information that can be gained is through the simultaneous pull of two arms: when such a pull is performed the agent gets access to the winner of the two arms, thus the name of dueling bandits. Here, we extend the framework of dueling bandits to the situation where there exist pairs of arms that are not comparable, that is, we study the case where there might be no natural order that could help decide the winner of a duel between two arms. A problem induced by such a framework is then to identify among the set of all available K arms the set of maximal incomparable arms, or the Pareto front, through a minimal number of pairwise pulls. To carry out our study, we propose to make use of tools from the theory of posets and we take inspiration from works dedicated to selection and sorting on posets Daskalakis et al. [2011].\nKeys: Indistinguishability and Decoys. We make the assumption that the underlying poset or, more precisely, the incomparability structure, is not known. A pivotal issue that we have to face in this case is that of indistinguishability. In the bandit setting we assume, the draw of two arms that are comparable and that have close values —and hence a probability for either arm to win a duel close to 0.5— is essentially driven by the same random process, i.e. an unbiased coin flip, as the draw of two arms that are not comparable. Hence, if we denote by ε the distances between those two processes, we can have ε arbitrary small, and thus this pairs of arms cannot be distinguished from an incomparable pair of arm on the sole basis of pulls and a well-thought strategy. Such pair of arm will be referred as ε-indistinguishable. This problem has led us to make use of decoy arms. The idea of decoy originates from social psychology, and was originally intended to ’force’ an agent (e.g., a customer) towards a specific good/action (e.g. a product) by presenting her a choice between the targetted good and a degraded version of it. Here, we use decoys to help solve the problem of indistinguishability\nContributions. Our main contribution, the UnchainedBandits algorithm, implements a strategy based on decoys and a peeling approach that finds the Pareto front1 of a poset S with probability at least 1−δ after at most T ≤ O ( K width(S)∆2 log(NK 2/δ) )\npairwise pulls, while incurring a regret upper bounded by\nR ≤ 2K γ2 log\n( 2NK2\nδ ) K∑ i=1 1 ∆i Cα,γ(Ni) +Kwidth(S) log ( 2NK2 δ ) ∑ i,∆i<εN−1,i/∈P 1 ∆i ,\nwhere ∆ is the parameter of the decoys, ∆i the regret associated with arm i, K is the size of the poset, width(S) its width, N is the number of peeling iterations, γ is the peeling rate, εN−1 is the maximum peeling and Cα,γ(Ni) ≤ 1 defined in Section 3 encodes the complexity of the poset with respect to arm i.\nThe paper is organized as follows. Section 2 presents the setting of dueling bandits on posets and formally states the problem we address. In Section 3, we formally introduce the notion of decoys and show how they can be constructed, both mathematically and practically, we then present our algorithm, UnchainedBandits, which relies on decoys, to find the exact Pareto front of the poset and we provide theoretical guarantees on their performances. In Section 4, we discuss how the present work relates to recent papers from the dueling bandits literature. Section 5 reports results on the empirical performances of our algorithm in different settings."
    }, {
      "heading" : "2 Problem Statement: Dueling Bandits on Posets",
      "text" : ""
    }, {
      "heading" : "2.1 Reminders on Posets",
      "text" : "We here recall base notions and properties about posets that are relevant to the present contribution. Definition 2.1 (Poset). Let S be a set of elements. (S,<) is a partially ordered or poset if < is a reflexive, antisymmetric and transitive binary relation on S: ∀a, b, c ∈ S\n• a < a (reflexivity);\n• if a < b and b < a then a = b (antisymmetry); 1 We discuss in the supplementary material the easier setting where the incomparability information is known and we provide a dedicated algorithm, SlicingBandits, that takes advantage of this addiditional information.\n• if a < b and b < c then a < c (transitivity). Remark 2.2. In the following, we will use S to denote indifferently the set S or the poset (S,<), the distinction being clear from the context. We make use of the additional notation: ∀a, b ∈ S\n• a ‖ b if a and b are incomparable (i.e. neither a < b nor b < a);\n• a b if a < b and a 6= b;\nThroughout, we limit our study to finite posets, i.e., posets such that |S| < +∞. Definition 2.3 (Maximal element and Pareto front). An element a ∈ S is said to be a maximal element of S if ∀b ∈ S, a < b or a ‖ b. We denote by\nP(S) .= {a : a < b or a ‖ b,∀b ∈ S},\nthe set of maximal elements or Pareto front of the poset.\nSince there is no intrinsic reason to favor a particular maximal element, throughout this work we chose to focus on the task of finding the entire Pareto front P(S) or P , for short. To this end, the notions of chain and antichain are key.\nDefinition 2.4 (Chain and antichain). C ⊂ S is a chain (resp. an antichain) if ∀a, b ∈ C, a < b or a < b (resp. a ‖ b). C is said to be maximal if ∀a ∈ S \\ C, C ∨ a is not a chain (resp. an antichain).\nNote that P is by definition a maximal antichain. Finally, the notion of width and height of a poset are important to characterize (the complexity of) a poset.\nDefinition 2.5 (Width and height). The width (resp. height) of a poset S is the size of its longest antichain (resp. chain)."
    }, {
      "heading" : "2.2 Dueling Bandits on Posets",
      "text" : "K-armed Dueling Bandit. The K-armed dueling bandit problem [Yue et al., 2012] assumes the existence of K2 parameters {γij}1≤i,j≤K , with γij ∈ (−1/2, 1/2) and the following sampling procedure. At each time step, the agent pulls a pair of arms (i, j) and she gets in return the value of an independent realization of Bij , a Bernouilli random variable with expectation E(Bij) = 1/2 + γij where Bij = 1 means that i is the winner of the duel between i and j and, conversely, Bij = 0 means that j is the winner. The objective of the agent is to find the Condorcet winner c—the arm such that γcj > 0, ∀j 6= c— among the K arms, whose existence is assumed, while minimizing the accumulated regret, defined for a sequence ((i1, j1), . . . , (iT , jT )) of T pairs of pulls by 1 2 ∑T t=1(γcit + γcjt). Remark 2.6. Note that: ∀i, j, Bji = 1−Bij and, thus, γji = −γij and γii = 0.\nThe implicit assumption of traditional dueling bandits is that the set S = {1, . . . ,K} of arms is totally ordered: for any pair i, j ∈ S of arms, i and j must be comparable and γij unequivocally says which of the two is better.\nIssues induced by working on posets. Now consider a dueling bandit problem defined on a poset S. Compared to the usual setting where a total order on the arms exists, there are two main differences which arise when S is a poset: first, the situation where the agent pulls a pair of arms that are not comparable has to be handled with care and, second, there might be multiple maximal elements.\nWorking on bandits with a poset S = {1, . . . ,K} of arms might be formalized as follows. For all chains {i1, . . . , im} of m arms there exist a family {γipiq}1≤p,q≤m of parameters such that γij ∈ (−1/2, 1/2); the pull of a pair of arms (ip, iq) from the same chain provides the realization of a Bernoulli random variable Bipiq with expectation E(Bipiq ) = 1/2 + γipiq . Regarding the incomparability, i.e. the situation where the pair of arms (ip, iq) selected by the agent correspond to arms such that ip ‖ iq , then there are two frameworks we propose to consider: one the one hand, the fully observable posets, where the draw from an incomparable pair of arms provides the agent with the information regarding the comparability of the arms2. On the other hand, that of partially\n2This easier setting is analysed in depth in the supplementary materials.\nobservable posets, where such a draw is modeled as the toss of an unbiased coin flip—as we shall discuss, this framework poses the problem of indistinguishability mentioned in the introduction.\nRegret on posets. In order to extend the notion of regret associated to an arm i, ∆i, in the poset setting, we use the notion of distance to the Pareto front, noted d(i,P) defined as follows :\n∆i = d(i,P) = min{γij ,∀j ∈ P such that j < i}.\nWe then define the regret occurred by comparing two arms i and j by d(i,P) + d(j,P). It is important to remark that the regret of a comparison is zero if and only if the agent is comparing two element of the Pareto front.\nProblem statement. Given the issues induced by working on a poset S of arms, we may state that the problem that we want to tackle is to identify the Pareto front P(S) of S as efficiently as possible. More precisely, we want to devise pulling strategies for both poset observability frameworks such that for any given δ ∈ (0, 1), we are ensured that the agent is capable, with probability 1 − δ to identify P(S) with controlled number of pulls and regret. Assumption 1 (Order Compatibility).\n∀i, j ∈ S, (i j) if and only if γij > 0.\nWe will not require any further hypothesis on how the γij relate to each other and, therefore, no assumption on strong stochastic transitivity [Yue et al., 2012] is required."
    }, {
      "heading" : "2.3 Poset Observability",
      "text" : "We consider the following setting, where the uncomparability information is not accessible.\nPartially observable posets. A K-armed Dueling bandits on a partially observable poset S = {1, . . . ,K} is a dueling bandit problem such that if i ‖ j, then γij = 0. This property is referred as Partial Observability.\nThis property reflects the fact that neither of the two incomparable arms has a distinct advantage over the other: when the agent asks to compare two intrinsically incomparable arms, the results will only depend upon circumstances independent from the arms (like luck or personal tastes). Our encoding of such framework makes us assume that when considered over many pulls, the effects of those circumstances cancel out, so that no specific arm is favored, whence γij = 0.\nConsequences of partial observability. Note that partial observability entails the problem of indistinguishability evoked previously. Indeed, given two arms i and j, regardless of the number of comparisons, an agent may never be sure if either the two arms are very close to each other (γij ≈ 0 and i and j are comparable) or if they are not comparable (γij = 0). Since all the elements of the Pareto set must be incomparable with each other, this renders the problem of identifying P intractable as well if no additional information is provided.\nThis problem motivates the following definition, which quantifies the notion of indistinguishability : Definition 2.7 (ε−indistinguishability). Let a, b ∈ S and ε > 0. a and b are said to be εindistinguishable, noted a ‖ε b, if |γab| ≤ ε.\nAs the notation ‖ε implies, the ε−indistinguishability of two arms can be seen as a weaker form of incomparability, and note that as ε-decreases, previously indistinguishable pairs of arms become distinguishable, and the only 0−indistinguishable pair of arms are the incomparable pairs. The classical notions of a poset related to incomparability can easily be extended to fit the ε−indistinguishability : Definition 2.8 (ε-antichain, ε-width and ε-approximation of P). Let ε > 0. C ⊂ S is called an ε-antichain if ∀a 6= b ∈ C, we have a ‖ε b. Additionally, P ′ ⊂ S is called an ε−approximation of P if P ⊂ P ′ and P ′ is an ε-antichain. Finally we denote by widthε(S) the size of the largest ε− antichain of S.\nInterestingly, to find a ε−approximation of P , it is only needed to remove the elements of S which are ε−distinguishable fromP . Thus, whileP cannot be recovered in the partially observable setting,\nAlgorithm 1 Direct comparison Given (S, ) a poset, δ, ε > 0, a, b ∈ S Initialisation Maintains pab the average number of victory of a over b and Iab its 1 − δ confidence interval, Direct comparison: while 0.5 + ε ∈ I or 0.5− ε ∈ I do\nCompare a and b, Update pab and I . If 0.5 /∈ Iab and pab > 0.5, Return a b; Else If 0.5 /∈ Iab and pab < 0.5, Return b a.\nend while Return a ‖ε b\na ε−approximation of P can be obtained. Consequently, if the agent knows the minimum distance of any arm to the Pareto set, defined as d(P) = min{γij ,∀i ∈ P, j ∈ S \\ P, such that i j}, she can recover the Pareto front, since for any ε < d(P), the unique ε−approximation of P is P itself. This information is however unavailable in practice and we choose not to rely on external information to solve the problem at hand. In the case where an ε approximation of the Pareto front is not enough, and the exact Pareto front is required, we devise an alternative strategy which rests on the idea of decoys, already mentioned in the introduction and fully developed in Section 3."
    }, {
      "heading" : "3 Contributions",
      "text" : "Here, we introduce our algorithm, UnchainedBandits, that solves the problem of dueling bandits on partially observable posets, and we provide theoretical performance guarantees."
    }, {
      "heading" : "3.1 Decoys and Posets",
      "text" : "As said in Section 2, deciding if two arms are incomparable or very close is intractable in the partially observable poset, and so is that of finding the exact Pareto front.\nStill, without any additional device, the agent is able to find if two arms a and b, are εindistinguishable. using the direct comparison process provided by Algorithm 1. Yet, as previously discussed, this only produces an ε-approximation of the Pareto front, of whom P is only guaranteed to be a subset. To evade this shortcoming, we introduce a new tool, decoys, inspired by works from social psychology [Huber et al., 1982]. We formally define decoys for posets, and we prove that it is a sufficient tool to solve the incomparability problem (Algorithm 2). We also present methods for building those decoys, both for the purely formal model of posets and for real-life problems.\nDefinition 3.1 (∆-decoy). Let a ∈ S. Then b ∈ S is said to be a ∆-decoy of a if :\n1. a < b and γa,b ≥ ∆\n2. ∀c ∈ S, a ‖ c implies b ‖ c\n3. ∀c ∈ S such that c < a, γc,b ≥ ∆\nInterestingly, when S satisfies the strong stochastic transitivity hypothesis, the third point of the previous definition in an immediate consequence of the first. The following proposition illustrates how decoys can be used to determine the incomparability of two arms.\nProposition 3.2 (Decoys and incomparability). Let a and b ∈ S . Let a′ (resp. b′) be a ∆-decoy of a (resp. b). Then a and b are comparable if and only if max(γb,a′ , γa,b′) ≥ ∆.\nProof. Let us assume than a < b. The transitivity of < implies that a < b′, and the third point of Definition 3.1 implies that γa,b′ ≥ ∆. The rest follows from point 2 of Definition 3.1.\nAlgorithm 2 is derived from this result. The next proposition, an immediate consequence of Proposition 3.2, gives a theoretical guarantee on its performances.\nAlgorithm 2 Decoy comparison Given (S, ) a poset, δ, ε > 0, a, b ∈ S Initialisation Create a′, b′ the respective ε- decoy of a, b. Maintains pab the average number of victory of a over b and Iab its 1− δ/2 confidence interval, Decoy comparisons: while 0.5 + ε ∈ I do\nCompare a and b′, b and a′, Update p, and I . If 0.5 /∈ Iab′ and pab′ > 0.5, Return a b. Else If 0.5 /∈ Iba′ and pba′ > 0.5, Return b a.\nend while Return a ‖ b\nProposition 3.3. Algorithm 2 returns the correct incomparability result with probability at least 1− δ after at most n comparisons, where n = 4log(4/δ)/∆2.\nAdding decoys to a poset. A poset S may not contain all the necessary decoys. To alleviate this, the following proposition states that it is always possible to add relevant decoys to a poset. Proposition 3.4 (Extending a poset with a decoy.). Let (S,<, γ) be a dueling bandit problem on a partially observable poset, and a ∈ S. Define a′, S′, ′, γ′ as follows:\n• S ′ = S ∪ {a′}\n• ∀b, c ∈ S, b < c i.f.f. b <′ c,, and γ′b,c = γb,c\n• ∀b ∈ S, if b < a then b < a′ and γ′b,a′ = max(γb,a,∆). Otherwise, b ‖ a′.\nThen (S′,<′) is a poset and (S ′,<′, γ′) defines a dueling bandit problem on a partially observable poset, γ′|S = γ, and a ′ is a ∆-decoy of a.\nProof. The result naturally follows from the definition of a poset and Definition 3.1.\nDecoys in real-life problems. The intended goal of a decoy a′ of a is to have at hand an arm that is known to be lesser than a. Creating such a decoy in real-life can be done by using a degraded version of a: for the case of a movie, a decoy can be obtain by e.g. decreasing the resolution of a film. Note that while for large values of the ∆ parameter of the decoys Algorithm 2 requires less comparisons (see Proposition 3.3), in real-life problems, the second point of Definition 3.1 tends to becomes false: the new option is actually so worse than the original that the decoy becomes comparable (and inferior) to all the other arms, including previously non comparable arms (example: the decoy of a film for a very large ∆ > 0 could be in very low resolution such as 32 × 24; this film cannot be actually seen and is clearly worse than all the others, regardless of the genre). In that case, the use of decoys of arbitrarily large ∆ can lead to erroneous conclusions about the Pareto front and should be avoided.\n3.2 UnchainedBandits\nWe now present our algorithm, UnchainedBandits, that uses decoys to efficiently find the Pareto front of S. UnchainedBandits is inspired by the ideas developed by Daskalakis et al. [2011], who address the problem of sorting a poset in a noiseless environment.\nBy Proposition 3.3, Algorithm 2 can be used to establish the exact relation between two arms. But this process can be very costly, as the number of required comparison is proportional to 1/∆2, even for strongly suboptimal arms. To avoid this possibility, UnchainedBandits implements a peeling technique: given N > 0 and a decreasing sequence (εi) N−1 i=1 it computes and refines an εi-approximation of the Pareto front P̂i, using a subroutine (Algorithm 4), which considers εiindistinguishable arms as incomparable. Then, at the N -th epoch, it uses Algorithm 4 one final time where it uses Algorithm 2 with ∆-decoys for comparisons, and then returns the Pareto front.\nAlgorithm subroutine. Algorithm 4 called on Ŝ with parameter ε > 0, δ > 0 and A works as follows. It chooses a single initial pivot—an arm to which other arms are compared—and successively\nAlgorithm 3 UnchainedBandits Given S = {s1, . . . , sK} a poset, δ > 0, ∆ > 0, N > 0, (εi)N−1i=1 ∈ RN+ Initialisation Set S1 = S, εN = ∆. Peel P̂ for t = 1 to N − 1 do St+1 = UBS Routine (St, εt, δ/N,A = Algorithm 3). end for Use decoys P̂ = UBS Routine (SN ,∆, δ/N,A = Algorithm 2). RETURN P̂\nAlgorithm 4 UBS Routine Given St a poset, εt > 0 a precision criterion, δ′ an error parameter, A a comparison algorithm Initialisation Choose p ∈ St at random. Define P̂ = {p} the set of pivots. Construct P̂ for c ∈ St \\ {p} do\nfor c′ ∈ P̂ do Compare c and c′ using A(δ = δ′/|St|2, ε = εt). If c c′, Then remove c′ from P̂ . end for If ∀c′ ∈ P̂ , c ‖ c′, Then add c to P̂\nend for Return P̂\nexamines all the elements of Ŝ. Each of the examined element p is compared to all the pivots. Each pivot that is dominated by p is removed from the pivot set. Then if after being compared to all the pivots, p was dominated by none, it is added to the pivot set. At the end, the set of remaining pivot is returned. During the first N − 1 epochs, the comparisons are done with Algorithm 1. In the last epoch, the agent uses Algorithm 2 to get exact information on the relations between the remaining arms.\nReuse of informations. To optimize the efficiency of the peeling process, UnchainedBandits reuses previous comparison results. At the beginning of each direct comparison process between arms a and b, the empirical estimate pab and its confidence interval Iab are initialized using the results of the previous direct comparisons of a and b. However, no information can be reused in the last epoch for the remaining arms, as the indirect comparison algorithm does not compare a to b directly.\nThe following theorem gives a high probability bound on the performances of UnchainedBandits. Theorem 1. The UnchainedBandits algorithm applied on S with parameters δ,∆,N and with a decreasing sequence (εi)N−1i=1 lower bounded by ∆ √ K\nwidth(S) , returns the Pareto front P of S with probability at least 1− δ after at most T comparisons, with\nT ≤ O ( Kwidth(S)log(NK2/δ)/∆2 ) (1)\nThis is a consequence of the following intermediate result, whose proof can be found in the supplementary materials. Proposition 3.5. Algorithm 4 called on St with parameter εt > 0, δ′ > 0 and A = Algorithm 2 returns the Pareto front of St with probability at least 1− δ′ after at most\nT ≤ 4|St|width(St)log(4|St|2/δ′)/∆2\ncomparisons. Alternatively, when Algorithm 4 uses A = Algorithm 1, it returns an εt−approximation of the Pareto front of St with probability at least 1− δ′ after at most\nT ≤ 2|St|widthεt(St)log(2|St|2/δ′) ( 1\nε2t − 1t>1\n1\nε2t−1 ) additional comparisons, where 1 is the indicator function.\nProof of Theorem 1. Note that ∀S ′ ⊂ S such that P ⊂ S ′, P(S ′) = P . The result is obtained by summing the upper bound in Proposition 3.5 over the different epochs, rearranging the sum and using the fact that |St|widthεt(St)log(N |St|2/δ) is decreasing in t while 1/ε2t is increasing in t. The detailed proof can be found in the supplementary materials.\nPeeling rate. Note that even if width(S) is unknown, it suffices to choose\nεN−1 ≥ ∆ √ K (2)\nto satisfy the hypotheses of Theorem 1. Although the previous result is valid for any decreasing sequence of (εt) satisfying (2), we focus on geometrically decreasing sequences, i.e. ∃γ > 0 such that εt = γtε0. For the sake of simplicity, we set ε0 = 0.5 but all the following results can easily be extended for any ε0 > 0.\nBefore we present our regret upper bound, we need to introduce a few notations. In order to characterise the efficiency of the peeling approach associated to γ, we define α(γ, ε0, N) ∈]0, 1], or α for short, as follows :\nα = inf { a ∈ [0, 1], s.t. ∀1 ≤ t ≤ N, ∀St ⊂ S an ε0γt-approximation of P, |St| ≤ at|S| } . (3)\nIt is important to note that the previous inequality is always true for a = 1, so α is always defined. α characterise how efficient is the peeling for the chosen parameters by quantifying the reduction in size between the successive St. We can now introduce the following Theorem which gives an upper bound on the regret incurred by Unchained Bandit. Theorem 2. LetR0 (resp. R1) be the regret generated by Algorithm 3 applied on S with parameters δ,∆,N and with a decreasing sequence (εi)N−1i=1 such that εN−1 ≤ ∆ √ K during the peeling phase (resp. the decoy phase). Let α as defined by (3). Then R = R0 +R1 and with probability at least 1− δ,\nR0 ≤ 2K\nγ2 log(\n2NK2\nδ ) K∑ i=1 1 ∆i Cα,γ(Ni) (4)\nR1 ≤ Kwidth(S) log( 2NK2\nδ ) ∑ i,∆i<εN−1,i/∈P 1 ∆i , (5)\nwhere\nNi = min\n( d log(∆i)\nlog(γ) e, N − 1\n) and Cα,γ(n) =  nαn−1 if α = γ,\nγ2n(1− α) + αn(γ2 − 1) γ2 − α otherwise.\nIn the previous theorem, Ni represent the number of peeling step where the arm i is present, while Cα,γ(Ni) represent the cost of doing the peeling for arm i. It is worth noting that Cα,γ(n) ≤ 1 and is increasing in α. This reflect the fact that small α are representative of an efficient pruning (many arms removed at each step).\nOpposite constraints on ε. Theorem 1 is an upper bound on the number of comparisons required to find the Pareto front. This bound is tight in the (worst-case) scenario where all the arms are ∆- indistinguishable, i.e. peeling cannot eliminate any arm. In that case, any comparison done during the peeling is actually wasted, and the lower bound on εt (2) allows to upper bound the number of comparisons made during the peeling step to recover a Kwidth(S) dependency in the upper bound, instead of K2. On the other hand, a significant amount of peeling is required to obtain a reasonable upper bound on the incurred regret: the number of comparisons using decoys is very high (≈ 1/∆2) and is the same for every arm, regardless of its regret. So it is important that only near-optimal arms remain during the decoy step, hence the upper bound on εt. In order to satisfy both constraints, εN must be chosen in [√ K/width(S)∆, √ K∆ ] ."
    }, {
      "heading" : "4 Related Works",
      "text" : "There is an actual connection between our work and studies from social psychology. In particular, Tversky and Kahneman [1981] issued one of the reference papers on the choice problem— which pertains to comparisons, in our framework— for real-life problems; they introduced the idea that alternatives may influence the perceived value of items. This idea had been taken one step further by Huber et al. [1982], who introduced and formalized the idea of decoys. They specifically argued that introducing dominated alternatives, i.e. decoys, may increase the probability of\nthe original item to be selected: if A,B and A′ are alternatives, then P (select A among A,B) < P (select A among A,A′, B). This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields.\nFrom the computer science literature, we must mention the work of Daskalakis et al. [2011], which addresses the problem on selection and sorting on posets and provides relevant data structures and accompanying analyses for computing on posets. Their results come down to classical results when totally ordered sets are used. Also, there might be yet other connections to draw between our work and that of Feige et al. [1994] who tackle the problem of sorting with noisy comparisons; note however that they assume there is a total order on the items they work on and the connection to be made with the present work would be to identify how this assumption may be weakened, if not removed.\nFinally, we must discuss how our contribution separates from papers on dueling bandits. If the seminal paper of Yue et al. [2012] promotes algorithms, namely the Interleaved Filter algorithms, that exhibit optimal information-theoretic regret bounds, the authors assume the existence of a total order between the arms together as strong stochastic transitivity and (relaxed) stochastic triangle inequality. Since then, numerous methods have been proposed to relax those additional assumptions, including [Yue and Joachims, 2011, Ailon et al., 2014, Zoghi et al., 2014, 2015b]. Other approaches exist that do not assume the existence of a Condorcet winner, such as [Urvoy et al., 2013, BusaFekete et al., 2013, Zoghi et al., 2015a] but, to the best of our knowledge, we provide the first contribution that studies the framework where arms may be incomparable."
    }, {
      "heading" : "5 Numerical Simulations",
      "text" : "In this section we experimentally evaluate UnchainedBandits. We did not compare our algorithm to dueling bandits algorithms from the literature, as a) they fail to consider the incomparability information and b) they are generally designed to return only one best element. Instead, we studied the performances of UnchainedBandits on simulated data (Section 5.1), and we applied it to an existing film rating database (Section 5.2)."
    }, {
      "heading" : "5.1 Simulated Poset",
      "text" : "First we confront UnchainedBandits with randomly generated posets, with different sizes, widths and heights. In order to give a baseline value, we use a simple algorithm, UniformSampling inspired from the successive elimination algorithm Even-Dar et al. [2006], which simultaneously compares all possible pairs of arms until one of the arms appears suboptimal, at which point it is removed from the set of selected arms. When only ∆-indistinguishable elements remain, it uses ∆-decoys.\nGiven the size p > 0 of the Pareto front, the desired width w ≥ p and the height h > 0, the posets are generated as follows: first, a Pareto front of size p is created. Then w chains of length h−1 with no common elements are added. Finally, the top of the chains are connected to a random number of elements of the Pareto front. This creates the structure of the poset (i.e. the partial order ). Finally, the exact values of the γij’s are obtained from a uniform distribution, conditioned to satisfy\nthe partially (or fully) observable framework. When needed, ∆-decoys are created according to Proposition 3.4. For each experiment reported on Figure 1, we changed the value of one parameter, and left the other to their default values (p = 5, w = 2p, h = 10). The results are averaged over ten runs. By default, we use δ = 1/1000 and ∆ = 1/100. We also set γ = 0.9, ε0 = 0.5 and εN = √ K∆.\nWe note that for partially observable posets, UnchainedBandits produces much better results than UniformSampling and its advantage increases with the complexity of the problem."
    }, {
      "heading" : "5.2 MovieLens Dataset",
      "text" : "To illustrate the example of the films recommendation system developed in the introduction, we chose to apply UnchainedBandits to the 20 millions items MovieLens dataset (Harper and Konstan [2015]).\nTo simulate a dueling bandit on a poset we proceed as follows: we remove all films with less than 50000 evaluations, thus obtaining 159 films, represented as arms. Then, when comparing two arms, we picke at random a user which has evaluated both films, and compare those evaluations (ties are broken with an unbiased coin toss). Since the decoy tool cannot be used in an already existing dataset, we restrict ourselves to finding an ε-approximation of the Pareto front, with ε = 0.05. Then, UnchainedBandits is run with parameters γ = 0.9, ε0 = 0.5, εN = ε, δ = 0.001.\nThere is no known ground truth for this experiments, so no regret estimation can be provided. Instead, the resulting Pareto front, which contains 5 films, is listed in Table 5.2, and compared to the five films among the original 159 with the highest average score. It is interesting to note that three films are present in both list, which reflects the fact that the best films in term of average score have a high chance of being in the Pareto Front. On the other hand, the films contained in the Pareto front are more diverse in term of genre, which is expected of a Pareto front. For instance, the sequel of the film ”The Godfather” (hence very close to the original regarding genre) has been replaced by a a film of a totally different genre. It is important to remember that UnchainedBandits does not have access to any information about the genre of a film and its results are based solely on the pairwise evaluation of the user, and thus this result illustrates the effectiveness of our approach for the learning of the hidden poset."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We studied an extension of the dueling bandit problem to the poset framework, which raised the problem of ε-indistinguishability. We presented a new algorithm, UnchainedBandits, which tackles the partially observable settings, and we provided theoretical performance guarantee for its ability to identify the Pareto front. Future work might include the study of the influence of additional hypothesis on the structure of the poset, such as when the poset is actually a lattice or upper semilattice. In this case, different strategies of sampling might lead to even more efficient algorithms."
    }, {
      "heading" : "B Additional Numerical Simulations",
      "text" : "The following experiments evaluate the relative efficiency of SlicingBandits and UnchainedBandits, we confront them with randomly generated posets, with different sizes, widths and heights.\nGiven the size p > 0 of the Pareto front, the desired width w ≥ p and the height h > 0, the posets are generated as follows: first, a Pareto front of size p is created. Then w chains of length h−1 with\nno common elements are added. Finally, the top of the chains are connected to a random number of elements of the Pareto front. This creates the structure of the poset (i.e. the partial order ). Finally, the exact values of the γij’s are obtained from a uniform distribution, conditioned to satisfy the partially (or fully) observable framework. When needed, ∆-decoys are created according to Proposition 3.4.\nFor each experiment reported on Figure B, we changed the value of one parameter, and left the other to their default values (p = 5, w = 2p, h = 10). The results are averaged over ten runs. By default, we use δ = 1/1000 and ∆ = 1/100. The (εt)t are generated following the procedure presented in Section 3 with ∆0 = 0.25.\nWe did not compare our algorithms to dueling bandits algorithms from the literature, as a) they fail to consider the incomparability information and b) they are generally designed to return only one best element. Instead, we use a baseline algorithm, UniformSampling inspired from the successive elimination algorithm Even-Dar et al. [2006], which simultaneously compares all possible pairs of arms until one of the arms appears suboptimal, at which point it is removed from the set of selected arms. When only ∆-indistinguishable elements remain, it uses ∆-decoys.\nWe note that SlicingBandits clearly outperforms the other algorithms by a wide margin, thanks to the access to the comparability information and the careful management of chains. For partially observable posets, UnchainedBandits produces much better results than UniformSampling and its advantage increases with the complexity of the problem."
    }, {
      "heading" : "C Appendix : Extended Proofs",
      "text" : ""
    }, {
      "heading" : "Proof of Lemma 3.1",
      "text" : "Existence: Since C is a finite totally ordered set, it admits an unique maximal element. Let c ∈ C be the maximal element of C. We use reductio ad absurdum. Suppose that c is not a maximal element of S. By definition of maximal element, ∃c′ ∈ S such that c′ c. But ∀c′′ ∈ C, we have c < c′′, then by transitivity c′ c′′. Hence C ∨ {c′} is a chain which strictly contains C, which contradicts the fact the C is a maximal chain. Uniqueness: let c, c′ ∈ C be two maximal element of S. Since C is a chain, c and c′ are comparable. Since c is a maximal element, we have c < c′. The same is true for c′, hence the conclusion."
    }, {
      "heading" : "Proof of Theorem 1",
      "text" : "Let E1 be the event where during the execution of Algorithm 1, each call to A(C, δ/K) return the correct answer (the maximal element of C). The proof is divided into two steps : First, we are going to prove that on E1, Theorem 1 is correct. Then, using an upper bound of the number of call to A done on the event E1, we will prove that P(EC1 ) ≤ δ, hence the conclusion. On E1,consider the following invariant : Invariant : At the beginning of each iteration of the while loop, we have\nP̂ ⊂ P (7)\n∀p ∈ P̂, ∀q ∈ Ŝ, p ‖ q (8)\nP ⊂ P̂ ∪ Ŝ (9)\nIt is easy to see that the invariant is true at the beginning of the algorithm, because at the initialisation,"
    }, {
      "heading" : "P̂ = ∅ and Ŝ = S.",
      "text" : "Assume that the invariant is true at the beginning of the loop t+ 1, and denote by Ŝt,P̂t the value of Ŝ, P̂ at the end of loop t.\nSince the algorithm has not stopped, Ŝt is not empty. By definition, the subset C constructed by the algorithm is a maximal chain of Ŝ. Since C is a non empty finite totally ordered set, it admits an unique maximum element c.\nWe prove that c ∈ P (10)\nwith reductio ad absurdum (RAA for short). Assume that c /∈ P . Then ∃c′ ∈ P such that c′ c. Since C is a maximal chain of Ŝ, it implies that c′ /∈ Ŝ. Hence (9) implies that c′ ∈ P̂ . But then c′ c contradicts (8), which concludes the RAA. Note that (10) and (8) implies\nc ∈ P \\ P̂. (11)\nThen, on E1, A(C, δ/K) = c, and\nP̂t P̂t ∪ {c} = P̂t+1 ⊂ P. (12)\nNow by construction we have\nŜt+1 = {p ∈ Ŝt, p c or p ‖ c} = {p ∈ Ŝt, p ‖ c}\nsince c ∈ P. Then (8) implies that\n∀p ∈ P̂t+1, ∀q ∈ Ŝt+1, p ‖ q. (13)\nFinally, we prove with RAA that P ⊂ P̂t+1 ∪ Ŝt+1 (14)\nLet p ∈ P such that p /∈ P̂t+1 ∪ Ŝt+1. (9) implies that p ∈ P̂t ∪ Ŝt. Since P̂t+1 ⊃ P̂t, we have p ∈ Ŝt+1 \\ Ŝt. Then, by definition of Ŝt+1, we have c p, which contradicts p ∈ P and conclude the RAA.\nFinally, (12)(13) and (14) implies that the invariant is true at the beginning of the loop t+ 2.\nWhen the algorithm stops, we have Ŝ = ∅, hence (7) and (9) implies that\nP̂ ⊂ P ⊂ P̂ ∪ ∅ = P̂\nthat is to say P̂ = P . Hence on E1, Algorithm 5 reaches the correct conclusion.\nA consequence of (11) is that P̂t increases by exactly one element at each iteration of of the while loop, and thus the A is called exactly |P| times. Hence, if we denote by Ct the chain constructed at the loop t,\nP(EC1 ) ≤ |P|∑ t=1 P ({A(Ct, δ/K) failed })\n≤ ∑ c∈P δ/K ≤ δ,\nAdditionally, the number of additional comparisons required to build all the chains is upper bounded by K2, as all pair of elements have to be compared at most once. Hence, the upper bound of T is derived from the fact due to (11), at each iteration, a chain with a different element of c ∈ P is considered."
    }, {
      "heading" : "Proof of Corollary 3.1",
      "text" : "Let Ct be the chain considered by Algorithm 1 during the loop t, and we denote by ct the maximal element of Ct, which is the unique element of P ∩ Ct (consequence of (11)). Theorem 2 from\n[Yue et al., 2012] implies that in this case, T (A (Ct, δ/K)) ≤ O ( |Ct|\nlog(|Ct|2K/δ) (minc′∈Ct γctc′) 2 ) ≤ O ( |Ct| log(K3/δ)\n(minc∈P,c′∈S,c c′ γcc′)2\n) .\nUsing that by construction, ∀t < t′, Ct ∩ C′t = ∅, and ⋃ t Ct = S, we have\n|P|∑ t=1 T (A (Ct, δ/K)) ≤ O  |P|∑ t=1 |Ct| log(K3/δ) (minc∈P,c′∈S,c c′ γcc′)2  ≤ O ( K log(K3/δ)\n(minc∈P,c′∈S,c c′ γcc′)2 ) Hence the conclusion."
    }, {
      "heading" : "Proof of Proposition 3.7",
      "text" : ""
    }, {
      "heading" : "Case A = Algorithm 3",
      "text" : "In this setting, the arms are compared using decoys.\nWe are going to proceed as in the proof of Theorem 1.\nLet E1 be the event where during the execution of Algorithm 5, each call to Algorithm 3 returns the correct answer. We are going to prove the following invariant for the principal loop of the Algorithm on E1.\nInvariant: At the iteration n, Let Snt the set of element of St already considered, P̂n the current set of pivot. Then\n∀c′ ∈ Snt ∃c ∈ P̂n, c < c′ (15) ∀c, c′ ∈ P̂t, c ‖ c′ (16)\nIt is easy to see that the invariant is true at the beginning of the algorithm because S0t = P̂0 and |P̂0| = 1. Suppose that the invariant is true at the n-th iteration. Let p be the new element considered, i.e. Sn+1t = Snt ∪ {p}, and define Γ p − . = {q ∈ P̂n, p q}\n1. Case 1. ∃q ∈ P̂n s.t. q p. In this case, P̂n+1 = P̂n \\ Γp−, hence (16) at iteration n immediatly implies (16) at iteration n+ 1. Since q p, we have ∀q′ ∈ Γp−, we have q q′ by transitivity.Hence (15) at iteration n implies (15) at iteration n+1.\n2. Case 2. ∀q ∈ P̂n, p q or p ‖ q. Then\nP̂n+1 = {p} ∪ P̂n \\ Γp−, and is it easy to see that (15) is still true iteration n + 1. Now we are going to prove that (16) is still true by RAA. Assume that ∃q ∈ P̂n+1 s.t. q is comparable to p. By definition of Γp−, it implies that q p, which contradicts the initial assumption of the case.\nAfter the last iteration n, we have Sn+1t = St, since all the elements have been examined. We now prove by RAA that the invariant implies that P̂n+1 = P. We drop the n+ 1 in P̂n+1 for the sake of alleviating the notations.\nSuppose that P̂ 6⊂ P and let p ∈ P̂ \\ P . Since p /∈ P,∃q ∈ P s.t. q p. If q ∈ P̂ , (16) is contracted. Then q /∈ P̂. Hence q p contradicts (15). So P̂ ⊂ P .\nNow assume that P 6⊂ P̂ and let p ∈ P \\P̂ . Since p /∈ P̂, (15) implies that ∃q ∈ P̂ s.t. q < p. Since p /∈ P̂ and q ∈ P̂ , q 6= p hence q p, which contradicts p ∈ P . So P ⊂ P̂. Hence P̂ = P.\nA consequence of (16) is that at each step, P̂n is an antichain. Since during the execution of the algorithm all the elements of St are compared to all the element of the current P̂ , the algorithm do at most\n|St|max n |P̂n| ≤ |St|width(St)\ncomparisons, and as a consequence\nP(EC1 ) ≤ |St|width(St) δ\n|St|2 ≤ δ.\nThe upper bound on the number of comparisons results with the same remark combined with Proposition 3.5."
    }, {
      "heading" : "Case A = Algorithm 2.",
      "text" : "During the epochs t < N , the arms are compared directly to each other, i.e. Algorithm 2 is used for comparisons purpose. We first tackle the case t = 1, i.e. the first epoch, since in this case, there is no previous observations, and thus no negative term in the upper bound. Case t = 1. The proof for t = 1 unfolds similarly to the previous case, with a different invariant.\nLet E1 be the event where during the execution of Algorithm 5, each call to Algorithm 2 returns the correct answer e.g. i j (resp j i) if and only if γij > ε (resp γji > ε). We are going to prove the following invariant for the principal loop of the Algorithm on E1.\nInvariant: At the iteration n, Let Snt the subset of element of St already considered, P̂n the current set of pivot. Then\n∀c′ ∈ Snt ∃c ∈ P̂n, c < c′ (17) ∀c, c′ ∈ P̂t, c ‖ε c′ (18)\nIt is easy to see that the invariant is true at the beginning of the algorithm because S0t = P̂0 and |P̂0| = 1. Suppose that the invariant is true at the n-th iteration. Let p be the new element considered, i.e. Sn+1t = Snt ∪ {p}.\n1. Case 1. ∃q ∈ P̂n s.t. q p and γqp > ε. In this case, P̂n+1 = P̂n \\ Γp−, hence (18) at iteration n immediatly implies (18) at iteration n+ 1. Since q p, we have ∀q′ ∈ Γp−, we have q q′ by transitivity. Hence (17) at iteration n implies (17) at iteration n+ 1.\n2. Case 2. ∀q ∈ P̂n, (p q and γpq > ε ) or |γpq| < ε. Then\nP̂n+1 = {p} ∪ P̂n \\ Γp−, and is it easy to see that (15) is still true iteration n + 1. Now we are going to prove that (16) is still true by RAA. Assume that ∃q ∈ P̂n+1 s.t. q is comparable to p and |γqp| > ε. By definition of Γp−, it implies that q p, and the order compatibility of the poset implies that γqp > ε which contradicts the initial assumption of the case.\nAfter the last iteration n, we have Sn+1t = St, since all the elements have been examined. We now prove by RAA that the invariant implies that P̂n+1 is an ε-approximation of P . We drop the n + 1 in P̂n+1 for the sake of alleviating the notations.\nNow assume that P 6⊂ P̂ and let p ∈ P \\P̂ . Since p /∈ P̂, (15) implies that ∃q ∈ P̂ s.t. q < p. Since p /∈ P̂ and q ∈ P̂ , q 6= p hence q p, which contradicts p ∈ P . So P ⊂ P̂.\nNow suppose that ∃q ∈ P̂ such that ∃p ∈ P s.t. p q and γpq > ε. Since P ⊂ P̂ , we have p ∈ P̂ and thus γpq > ε. contradicts (18). Hence P̂ is a ε-approximation of P.\nA consequence of (18) is that at each step, P̂n is an ε-antichain. Since during the execution of the algorithm all the elements of St are compared to all the element of the current P̂ , the algorithm do at most\n|St|max n |P̂n| ≤ |St|widthε(St)\ncomparisons, and as a consequence\nP(EC1 ) ≤ |St|widthε(St) δ\n|St|2 ≤ δ.\nThe upper bound on the number of comparisons results with the same remark combined with the fact that Algorithm 2 uses Hoeffding inequality.\nCase 1 < t < N . To conclude, we only need to lower bound the number of previous comparisons that can be reused. Once again, consider the event E1 be the event where during the execution of Algorithm 5, each call to Algorithm 2 returns the correct answer e.g. i j (resp j i) if and only if γij > ε (resp γji > ε). Let i and j ∈ St such that i and j are compared at epoch t (i.e. during the call number t of Algorithm 3). Note that St = P̂nt−1 and let assume without any loss of generality that i was added before j into P̂nt−1. Since i is a pivot at the end of the epoch t − 1, it was compared to all the arm considered after i, including j.\nSince both i and j are pivots at the end of epoch t − 1, it implies that i ‖ j or γij < εt−1. In both cases, Algorithm the algorithm does exactly log(K\n2/δ′) ε2t−1\ncomparisons to reach this conclusion. The result follows from the reuse of information."
    }, {
      "heading" : "Proof of Theorem 2.",
      "text" : "First note that if P ′ is a ε- approximation of P , then P ⊂ P ′. Additionally, it is easy to see that if S is a poset and P is its Pareto set, then ∀S ′ ⊂ S such that P ⊂ S ′, the Pareto front of S ′ is P. Hence, Proposition 3.7 implies that with probability at least 1−Nδ/N = 1−δ, Algorithm 4 returns the pareto front of S. in at most T comparisons, where T ≤ 2 N−1∑ t=1 |St|widthεt(St)log(2N |St|2/δ) ( 1 ε2t − 1t>1 1 ε2t−1 ) + 4|SN |width(SN ) log(4N |SN |2/δ) ∆2\n≤ 2 N−2∑ t=1 1 ε2t ( |St|widthεt(St)log(2N |St|2/δ)− |St+1|widthεt+1(St+1)log(2N |St+1|2/δ) ) + 2\nε2N−1 |SN−1|widthεN−1(SN−1)log(2N |SN−1|2/δ) + 4|SN |width(SN ) log(4N |SN |2/δ) ∆2\nwhere the second inequality is obtained by rearranging the sum. Now, by hypothesis we have\nεt > εN−1 ≥ ∆\n√ |S|\nwidth(S)\nHence, since the |St|widthεt(St)log(N |St|2/δ) is decreasing in t we have\nT ≤ 2 N−2∑ t=1 width(S) |S|∆2 ( |St|widthεt(St)log(2N |St|2/δ)− |St+1|widthεt+1(St+1)log(2N |St+1|2/δ) ) +\n2width(S) |S|∆2 |SN−1|widthεN−1(SN−1)log(2N |SN−1|2/δ) + 4|SN |width(SN ) log(N |SN |2/δ) ∆2\n≤ 2 ∆2 |S|widthε1(S) |S| width(S)log(2N |S|2/δ) + 4|SN |width(SN ) log(4N |SN |2/δ) ∆2\n≤ O ( Kwidth(S) log(NK 2/δ)\n∆2\n)"
    }, {
      "heading" : "Proof of Theorem 3.",
      "text" : "We know from Proposition 3.5, with probability at least 1 − δ, the algorithm does not reach an incorrect result the comparison. For the rest of the proof, we restrict ourselves to this event.\nFirst we consider the regretR0 induced by the peeling process. Let i be an arm, and Ni be the last peeling step before ip is eliminated. If i is not eliminated at the end of the peeling, then we set Ni = N − 1. In other words,\nNi = max{1 ≤ t ≤ N − 1, i ∈ P̂t}\n= min ( d log(∆i)\nlog(γ) e, N − 1\n) .\nLet j ≤ Ni. During the j-th phase of peeling, the arm i is compared to at most |Sj − 1| other arms. Hence, with the same argument as in Proposition 3.5, we have\nR0 ≤ 2 K∑ i=1 ∆i Ni∑ t=1 |St|log(2N |St|2/δ) ( 1 ε2t − 1t>1 1 ε2t−1 ) .\nNow since εt < εt−1, and by hypothesis, |St| ≤ αt−1K, we have\nR0 ≤ 2K log( 2NK2\nδ ) K∑ i=1 ∆i Ni∑ t=1 αt−1 ( 1 ε2t − 1t>1 1 ε2t−1 )\n≤ 2K log(2NK 2\nδ ) K∑ i=1 ∆i ( Ni−1∑ t=1 αt−1 ε2t (1− α) + α Ni−1 ε2Ni ) .\nSince by construction, we have εt+1 = γεt, then\nR0 ≤ 2K log( 2NK2\nδ ) K∑ i=1 ∆i ε2Ni ( Ni−1∑ t=1 γ2(Ni−t)αt−1 (1− α) + αNi−1 )\n≤ 2K log(2NK 2\nδ ) K∑ i=1 ∆i ε2Ni\n( γ2(Ni−1)\nNi−1∑ t=1 ( α γ2 )t−1 (1− α) + αNi−1\n)\n≤ 2K γ2 log( 2NK2 δ ) K∑ i=1 1 ∆i\n( γ2(Ni−1)\nNi−1∑ t=1 ( α γ2 )t−1 (1− α) + αNi−1\n) ,\nsince by definition of Ni, we have ∆i < εNi−1 = γεNi . Now we have to consider two cases.\nCase γ2 6= α:\nR0 ≤ 2K\nγ2 log(\n2NK2\nδ ) K∑ i=1 1 ∆i ( γ2(Ni−1) (1− α) 1− (α/γ 2)Ni−1 1− (α/γ2) + αNi−1 )\n≤ 2K γ2 log( 2NK2 δ ) K∑ i=1 1 ∆i γ2Ni(1− α) + αNi(γ2 − 1) γ2 − α\n≤ 2K γ2 log( 2NK2 δ ) K∑ i=1 1 ∆i Cα,γ(Ni),\nand\nCase γ2 = α:\nR0 ≤ 2K\nγ2 log(\n2NK2\nδ ) K∑ i=1 1 ∆i ( αNi−1 (1− α) (Ni − 1) + αNi−1 ) ≤ 2K\nγ2 log(\n2NK2\nδ ) K∑ i=1 1 ∆i αNi−1Ni\n≤ 2K γ2 log( 2NK2 δ ) K∑ i=1 1 ∆i Cα,γ(Ni),\nhence the conclusion.\nNow letR1 be the regret generated by the decoy step. To reach this step, an arm i must be such that ∆i < εN−1. If i ∈ P , then pulling the arm i produces no regret. Otherwise, it is easy to see that the arm is compared to at most width(S) other arms before being eliminated.\nR1 ≤ width(S) log( 2NK2\nδ ) ∑ i,∆i<εN−1,i/∈P ∆i ∆2\n≤ (εN−1 ∆ )2width(S) log( 2NK2 δ ) ∑ i,∆i<εN−1,i/∈P 1 ∆i\n≤ Kwidth(S) log(2NK 2\nδ ) ∑ i,∆i<εN−1,i/∈P 1 ∆i ."
    } ],
    "references" : [ {
      "title" : "Reducing dueling bandits to cardinal bandits",
      "author" : [ "Nir Ailon", "Zohar Karnin", "Thorsten Joachims" ],
      "venue" : "In Proceedings of The 31st International Conference on Machine Learning,",
      "citeRegEx" : "Ailon et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Ailon et al\\.",
      "year" : 2014
    }, {
      "title" : "Seeking subjective dominance in multidimensional space: An explanation of the asymmetric dominance effect",
      "author" : [ "Dan Ariely", "Thomas S Wallsten" ],
      "venue" : "Organizational Behavior and Human Decision Processes,",
      "citeRegEx" : "Ariely and Wallsten.,? \\Q1995\\E",
      "shortCiteRegEx" : "Ariely and Wallsten.",
      "year" : 1995
    }, {
      "title" : "Top-k selection based on adaptive sampling of noisy preferences",
      "author" : [ "Róbert Busa-Fekete", "Balazs Szorenyi", "Weiwei Cheng", "Paul Weng", "Eyke Hüllermeier" ],
      "venue" : "In Proceedings of The 30th International Conference on Machine Learning,",
      "citeRegEx" : "Busa.Fekete et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Busa.Fekete et al\\.",
      "year" : 2013
    }, {
      "title" : "Sorting and selection in posets",
      "author" : [ "Constantinos Daskalakis", "Richard M Karp", "Elchanan Mossel", "Samantha J Riesenfeld", "Elad Verbin" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "Daskalakis et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Daskalakis et al\\.",
      "year" : 2011
    }, {
      "title" : "Action elimination and stopping conditions for the multi-armed bandit and reinforcement learning problems",
      "author" : [ "Eyal Even-Dar", "Shie Mannor", "Yishay Mansour" ],
      "venue" : "The Journal of Machine Learning Research,",
      "citeRegEx" : "Even.Dar et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Even.Dar et al\\.",
      "year" : 2006
    }, {
      "title" : "Computing with noisy information",
      "author" : [ "Uriel Feige", "Prabhakar Raghavan", "David Peleg", "Eli Upfal" ],
      "venue" : "SIAM Journal on Computing,",
      "citeRegEx" : "Feige et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Feige et al\\.",
      "year" : 1994
    }, {
      "title" : "The movielens datasets: History and context",
      "author" : [ "F Maxwell Harper", "Joseph A Konstan" ],
      "venue" : "ACM Transactions on Interactive Intelligent Systems (TiiS),",
      "citeRegEx" : "Harper and Konstan.,? \\Q2015\\E",
      "shortCiteRegEx" : "Harper and Konstan.",
      "year" : 2015
    }, {
      "title" : "Adding asymmetrically dominated alternatives: Violations of regularity and the similarity hypothesis",
      "author" : [ "Joel Huber", "John W Payne", "Christopher Puto" ],
      "venue" : "Journal of consumer research,",
      "citeRegEx" : "Huber et al\\.,? \\Q1982\\E",
      "shortCiteRegEx" : "Huber et al\\.",
      "year" : 1982
    }, {
      "title" : "Contextual and procedural determinants of partner selection: Of asymmetric dominance and prominence",
      "author" : [ "Constantine Sedikides", "Dan Ariely", "Nils Olsen" ],
      "venue" : "Social Cognition,",
      "citeRegEx" : "Sedikides et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Sedikides et al\\.",
      "year" : 1999
    }, {
      "title" : "Generic exploration and karmed voting bandits",
      "author" : [ "Tanguy Urvoy", "Fabrice Clerot", "Raphael Féraud", "Sami Naamane" ],
      "venue" : "In Proceedings of the 30th International Conference on Machine Learning",
      "citeRegEx" : "Urvoy et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Urvoy et al\\.",
      "year" : 2013
    }, {
      "title" : "Beat the mean bandit",
      "author" : [ "Yisong Yue", "Thorsten Joachims" ],
      "venue" : "In Proceedings of the 28th International Conference on Machine Learning",
      "citeRegEx" : "Yue and Joachims.,? \\Q2011\\E",
      "shortCiteRegEx" : "Yue and Joachims.",
      "year" : 2011
    }, {
      "title" : "The k-armed dueling bandits problem",
      "author" : [ "Yisong Yue", "Josef Broder", "Robert Kleinberg", "Thorsten Joachims" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "Yue et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Yue et al\\.",
      "year" : 2012
    }, {
      "title" : "Relative upper confidence bound for the k-armed dueling bandit problem",
      "author" : [ "Masrour Zoghi", "Shimon Whiteson", "Remi Munos", "Maarten D Rijke" ],
      "venue" : "In Proceedings of the 31st International Conference on Machine Learning",
      "citeRegEx" : "Zoghi et al\\.,? \\Q2014\\E",
      "shortCiteRegEx" : "Zoghi et al\\.",
      "year" : 2014
    }, {
      "title" : "Copeland dueling bandits",
      "author" : [ "Masrour Zoghi", "Zohar S Karnin", "Shimon Whiteson", "Maarten de Rijke" ],
      "venue" : "In Advances in Neural Information Processing Systems,",
      "citeRegEx" : "Zoghi et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Zoghi et al\\.",
      "year" : 2015
    }, {
      "title" : "Mergerucb: A method for large-scale online ranker evaluation",
      "author" : [ "Masrour Zoghi", "Shimon Whiteson", "Maarten de Rijke" ],
      "venue" : "In Proceedings of the Eighth ACM International Conference on Web Search and Data Mining,",
      "citeRegEx" : "Zoghi et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Zoghi et al\\.",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : "Dueling bandits were introduced by Yue et al. [2012]. The setting, pertaining to the K-armed bandit framework, assumes there is no direct access to the reward provided",
      "startOffset" : 35,
      "endOffset" : 53
    }, {
      "referenceID" : 3,
      "context" : "To carry out our study, we propose to make use of tools from the theory of posets and we take inspiration from works dedicated to selection and sorting on posets Daskalakis et al. [2011]. Keys: Indistinguishability and Decoys.",
      "startOffset" : 162,
      "endOffset" : 187
    }, {
      "referenceID" : 11,
      "context" : "The K-armed dueling bandit problem [Yue et al., 2012] assumes the existence of K parameters {γij}1≤i,j≤K , with γij ∈ (−1/2, 1/2) and the following sampling procedure.",
      "startOffset" : 35,
      "endOffset" : 53
    }, {
      "referenceID" : 11,
      "context" : "We will not require any further hypothesis on how the γij relate to each other and, therefore, no assumption on strong stochastic transitivity [Yue et al., 2012] is required.",
      "startOffset" : 143,
      "endOffset" : 161
    }, {
      "referenceID" : 7,
      "context" : "To evade this shortcoming, we introduce a new tool, decoys, inspired by works from social psychology [Huber et al., 1982].",
      "startOffset" : 101,
      "endOffset" : 121
    }, {
      "referenceID" : 3,
      "context" : "UnchainedBandits is inspired by the ideas developed by Daskalakis et al. [2011], who address the problem of sorting a poset in a noiseless environment.",
      "startOffset" : 55,
      "endOffset" : 80
    }, {
      "referenceID" : 7,
      "context" : "This idea had been taken one step further by Huber et al. [1982], who introduced and formalized the idea of decoys.",
      "startOffset" : 45,
      "endOffset" : 65
    }, {
      "referenceID" : 0,
      "context" : "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al.",
      "startOffset" : 43,
      "endOffset" : 70
    }, {
      "referenceID" : 0,
      "context" : "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields.",
      "startOffset" : 43,
      "endOffset" : 95
    }, {
      "referenceID" : 0,
      "context" : "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields. From the computer science literature, we must mention the work of Daskalakis et al. [2011], which addresses the problem on selection and sorting on posets and provides relevant data structures and accompanying analyses for computing on posets.",
      "startOffset" : 43,
      "endOffset" : 287
    }, {
      "referenceID" : 0,
      "context" : "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields. From the computer science literature, we must mention the work of Daskalakis et al. [2011], which addresses the problem on selection and sorting on posets and provides relevant data structures and accompanying analyses for computing on posets. Their results come down to classical results when totally ordered sets are used. Also, there might be yet other connections to draw between our work and that of Feige et al. [1994] who tackle the problem of sorting with noisy comparisons; note however that they assume there is a total order on the items they work on and the connection to be made with the present work would be to identify how this assumption may be weakened, if not removed.",
      "startOffset" : 43,
      "endOffset" : 621
    }, {
      "referenceID" : 0,
      "context" : "This generated an abundant literature (see Ariely and Wallsten [1995], Sedikides et al. [1999] and references therein) on works that studied the effect of decoys and their uses in various fields. From the computer science literature, we must mention the work of Daskalakis et al. [2011], which addresses the problem on selection and sorting on posets and provides relevant data structures and accompanying analyses for computing on posets. Their results come down to classical results when totally ordered sets are used. Also, there might be yet other connections to draw between our work and that of Feige et al. [1994] who tackle the problem of sorting with noisy comparisons; note however that they assume there is a total order on the items they work on and the connection to be made with the present work would be to identify how this assumption may be weakened, if not removed. Finally, we must discuss how our contribution separates from papers on dueling bandits. If the seminal paper of Yue et al. [2012] promotes algorithms, namely the Interleaved Filter algorithms, that exhibit optimal information-theoretic regret bounds, the authors assume the existence of a total order between the arms together as strong stochastic transitivity and (relaxed) stochastic triangle inequality.",
      "startOffset" : 43,
      "endOffset" : 1014
    }, {
      "referenceID" : 4,
      "context" : "In order to give a baseline value, we use a simple algorithm, UniformSampling inspired from the successive elimination algorithm Even-Dar et al. [2006], which simultaneously compares all possible pairs of arms until one of the arms appears suboptimal, at which point it is removed from the set of selected arms.",
      "startOffset" : 129,
      "endOffset" : 152
    }, {
      "referenceID" : 6,
      "context" : "To illustrate the example of the films recommendation system developed in the introduction, we chose to apply UnchainedBandits to the 20 millions items MovieLens dataset (Harper and Konstan [2015]).",
      "startOffset" : 171,
      "endOffset" : 197
    } ],
    "year" : 2016,
    "abstractText" : "We adress the problem of dueling bandits defined on partially ordered sets, or posets. In this setting, arms may not be comparable, and there may be several (incomparable) optimal arms. We propose an algorithm, UnchainedBandits, that efficiently finds the set of optimal arms of any poset even when pairs of comparable arms cannot be distinguished from pairs of incomparable arms, with a set of minimal assumptions. This algorithm relies on the concept of decoys, which stems from social psychology. For the easier case where the incomparability information may be accessible, we propose a second algorithm, SlicingBandits, which takes advantage of this information and achieves a very significant gain of performance compared to UnchainedBandits. We provide theoretical guarantees and experimental evaluation for both algorithms.",
    "creator" : "LaTeX with hyperref package"
  }
}