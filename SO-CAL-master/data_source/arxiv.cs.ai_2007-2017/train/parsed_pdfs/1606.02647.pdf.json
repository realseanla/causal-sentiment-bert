{
  "name" : "1606.02647.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Safe and efficient off-policy reinforcement learning",
    "authors" : [ "Rémi Munos", "Tom Stepleton", "Anna Harutyunyan", "Marc G. Bellemare" ],
    "emails" : [ "munos@google.com", "stepleton@google.com", "anna.harutyunyan@vub.ac.be", "bellemare@google.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "One fundamental trade-off in reinforcement learning lies in the definition of the update target: should one estimate Monte Carlo returns or bootstrap from an existing Q-function? Return-based methods (where return refers to the sum of discounted rewards ∑ t γ\ntrt) offer some advantages over value bootstrap methods: they are better behaved when combined with function approximation, and quickly propagate the fruits of exploration (Sutton, 1996). On the other hand, value bootstrap methods are more readily applied to off-policy data, a common use case. In this paper we show that learning from returns need not be at cross-purposes with off-policy learning.\nWe start from the recent work of Harutyunyan et al. (2016), who show that naive off-policy policy evaluation, without correcting for the “off-policyness” of a trajectory, still converges to the desired Qπ value function provided the behavior µ and target π policies are not too far apart (the maximum allowed distance depends on the λ parameter). Their Qπ(λ) algorithm learns from trajectories generated by µ simply by summing discounted off-policy corrected rewards at each time step. Unfortunately, the assumption that µ and π are close is restrictive, as well as difficult to uphold in the control case, where the target policy is always greedy with respect to the current Q-function. In that sense this algorithm is not safe: it does not handle the case of arbitrary “off-policyness”.\nAlternatively, the Tree-backup (TB) (λ) algorithm (Precup et al., 2000) tolerates arbitrary target/behavior discrepancies by scaling information (here called traces) from future temporal differences by the product of target policy probabilities. TB(λ) is not efficient in the “near on-policy” case (similar µ and π), though, as traces may be cut prematurely, blocking learning from full returns.\nIn this work, we express several off-policy, return-based algorithms in a common form. From this we derive an improved algorithm, Retrace(λ), which is both safe and efficient, enjoying convergence guarantees for off-policy policy evaluation and – more importantly – for the control setting.\nRetrace(λ) can learn from full returns retrieved from past policy data, as in the context of experience replay (Lin, 1993), which has returned to favour with advances in deep reinforcement learning (Mnih\nar X\niv :1\n60 6.\n02 64\n7v 1\n[ cs\n.L G\n] 8\nJ un\net al., 2015; Schaul et al., 2016). Off-policy learning is also desirable for exploration, since it allows the agent to deviate from the target policy currently under evaluation.\nTo the best of our knowledge, this is the first online return-based off-policy control algorithm which does not require the GLIE (Greedy in the Limit with Infinite Exploration) assumption (Singh et al., 2000). In addition, we provide as a corollary the first proof of convergence of Watkins’ Q(λ) (see, e.g., Watkins, 1989; Sutton and Barto, 1998).\nFinally, we illustrate the significance of Retrace(λ) in a deep learning setting by applying it to the suite of Atari 2600 games provided by the Arcade Learning Environment (Bellemare et al., 2013)."
    }, {
      "heading" : "1 Notation",
      "text" : "We consider an agent interacting with a Markov Decision Process (X ,A, γ, P, r). X is a finite state space, A the action space, γ ∈ [0, 1) the discount factor, P the transition function mapping stateaction pairs (x, a) ∈ X ×A to distributions over X , and r : X ×A → [−RMAX, RMAX] is the reward function. For notational simplicity we will consider a finite action space, but the case of infinite – possibly continuous – action space can be handled by the Retrace(λ) algorithm as well. A policy π is a mapping from X to a distribution over A. A Q-function Q maps each state-action pair (x, a) to a value in R; in particular, the reward r is a Q-function. For a policy π we define the operator Pπ:\n(PπQ)(x, a) := ∑ x′∈X ∑ a′∈A P (x′ |x, a)π(a′ |x′)Q(x′, a′).\nThe value function for a policy π, Qπ , describes the expected discounted sum of rewards associated with following π from a given state-action pair. Using operator notation, we write this as\nQπ := ∑ t≥0 γt(Pπ)tr. (1)\nThe Bellman operator T π is T πQ := r + γPπQ (2)\nand its fixed point is Qπ , i.e. T πQπ = Qπ = (I − γPπ)−1r. The Bellman optimality operator introduces a maximization over the set of policies:\nT Q := r + γmax π PπQ. (3)\nIts fixed point is Q∗, the unique optimal value function (Puterman, 1994). It is this quantity that we will seek to obtain when we talk about the “control setting”.\nReturn-based Operators: The λ-return extension (Sutton, 1988) of both (2) and (3) considers exponentially weighted sums of n-step returns:\nT πλ Q := (1− λ) ∑ n≥0 λn [(T π)nQ] = Q+ (I − λγPπ)−1(T πQ−Q),\nwhere T πQ − Q is the Bellman residual of Q for policy π, with T Q − Q replacing T π − Q for (3). Examination of the above shows that Qπ is also the fixed point of T πλ . At one extreme (λ = 0) we have the Bellman operator T πλ=0Q = T πQ, while at the other (λ = 1) we have the policy evaluation operator T πλ=1Q = Qπ which can be estimated using Monte Carlo methods (Sutton and Barto, 1998). Intermediate values of λ trade off estimation bias with sample variance (Kearns and Singh, 2000).\nWe seek to evaluate a target policy π using trajectories drawn from a behaviour policy µ. If π = µ, we are on-policy; otherwise, we are off-policy. We will consider trajectories of the form:\nx0 = x, a0 = a, r0, x1, a1, r1, x2, a2, r2, . . .\nwith at ∼ µ(·|xt), rt = r(xt, at) and xt+1 ∼ P (·|xt, at). We denote by Ft this sequence up to time t, and write Eµ the expectation with respect to both µ and the MDP transition probabilities. Throughout, we write ‖ · ‖ for supremum norm."
    }, {
      "heading" : "2 Off-Policy Algorithms",
      "text" : "We are interested in two related off-policy learning problems. In the policy evaluation setting, we are given a fixed policy π whose value Qπ we wish to estimate from sample trajectories drawn from a behaviour policy µ. In the control setting, we consider a sequence of policies that depend on our own sequence of Q-functions (such as ε-greedy policies), and seek to approximate Q∗.\nThe general form that we consider for comparing several return-based off-policy algorithms is:\nRQ(x, a) := Q(x, a) + Eµ ∑ t≥0 γt ( t∏ s=1 cs )( rt + γEπQ(xt+1, ·)−Q(xt, at) ) , (4) for some non-negative coefficients (cs), where we write EπQ(x, ·) := ∑ a π(a|x)Q(x, a) and write\n( ∏t s=1 cs) = 1 when t = 0. By extension of the idea of eligibility traces (Sutton and Barto, 1998), we informally call the coefficients (cs) the traces of the operator.\nImportance sampling (IS): cs = π(as|xs)µ(as|xs) . Importance sampling is the simplest way to correct for the discrepancy between µ and π when learning from off-policy returns (Precup et al., 2000, 2001; Geist and Scherrer, 2014). The off-policy correction uses the product of the likelihood ratios between π and µ. Notice that the RQ operator (4) defined with this choice of (cs) yields Qπ for any Q. For Q = 0 we recover the basic IS estimate ∑ t≥0 γ t (∏t s=1 cs ) rt, thus (4) can be seen as a variance reduction technique (with a baseline Q). It is well known that IS estimates can suffer from large – even possibly infinite – variance (mainly due to the variance of the product π(a1|x1) µ(a1|x1) · · · π(at|xt) µ(at|xt) ), which has motivated further variance reduction techniques such as (Mahmood and Sutton, 2015; Mahmood et al., 2015; Hallak et al., 2015).\nOff-policy Qπ(λ) and Q∗(λ): cs = λ. A recent alternative proposed by Harutyunyan et al. (2016) introduces an off-policy correction based on a Q-baseline (instead of correcting the probability of the sample path like in IS). This approach, called Qπ(λ) and Q∗(λ) for policy evaluation and control, respectively, corresponds to the choice cs = λ. It offers the advantage of avoiding the blow-up of the variance of the product of ratios encountered with IS. Interestingly, this operator contracts around Qπ provided that µ and π are sufficiently close to each other. Defining ε := maxx ‖π(·|x)−µ(·|x)‖1 the amount of “off-policyness”, the authors prove that the operator defined by (4) with cs = λ is a contraction mapping around Qπ for λ < 1−γγε , and around Q\n∗ for the worst case of λ < 1−γ2γ . Unfortunately, Qπ(λ) requires knowledge of ε, and the condition for Q∗(λ) is very conservative. Neither Qπ(λ), nor Q∗(λ) are safe as they do not guarantee convergence for arbitrary π and µ.\nTree-backup (TB) (λ): cs = λπ(as|xs). The TB(λ) algorithm of Precup et al. (2000) corrects for the target/behaviour discrepancy by multiplying each term of the sum by the product of target policy probabilities. The corresponding operator defines a contraction mapping (not only in expectation but also for any sample trajectory) for any policies π and µ, which makes it a safe algorithm. However, this algorithm is not efficient in the near on-policy case (where µ and π are similar) as it unnecessarily cuts the traces, preventing it to make use of full returns: we need not discount stochastic on-policy transitions (as shown by Harutyunyan et al.’s results about Qπ).\nRetrace(λ): cs = λmin (\n1, π(as|xs)µ(as|xs)\n) . Our contribution is an algorithm – Retrace(λ) – that takes\nthe best of the three previous algorithms. Retrace(λ) uses the importance sampling ratio truncated at 1. Compared to IS, it does not suffer from the variance explosion of the product of importance sampling ratios. Now, similarly to Qπ(λ) and unlike TB(λ), it does not cut the traces in the onpolicy case, making it possible to benefit from the full returns. In the off-policy case, the traces are safely cut, similarly to TB(λ). In particular, min ( 1, π(as|xs)µ(as|xs) ) ≥ π(as|xs): Retrace(λ) does not cut the traces as much as TB(λ).\nIn the subsequent sections, we will show the following:\n• The Retrace(λ) operator is a γ-contraction around Qπ , for arbitrary policies µ and π, • Taking cs to be no greater than the ratio π/µ is sufficient to guarantee this property, • Under mild assumptions, the control version of Retrace(λ), where π is replaced by a se-\nquence of increasingly greedy policies, is also a contraction, and\n• The online Retrace(λ) algorithm converges a.s. to Q∗ in the control case. In the control case, convergence does not require the GLIE assumption.\n• As a corollary, we prove the convergence of Watkins’s Q(λ) to Q∗."
    }, {
      "heading" : "3 Analysis of Retrace(λ)",
      "text" : "We will in turn analyse both off-policy policy evaluation and control settings. We will show that R is a contraction mapping in both settings (under a mild additional assumption for the control case)."
    }, {
      "heading" : "3.1 Policy Evaluation",
      "text" : "Consider a fixed target policy π. For ease of exposition we consider a fixed behaviour policy µ, noting that our result extends to the setting of sequences of behaviour policies (µk : k ∈ N). Our first result states the γ-contraction of the operator (4) defined by any set of non-negative coefficients cs = cs(as,Fs) (in order to emphasize that cs can be a function of the whole history Fs) under the assumption that cs ≤ π(as|xs)µ(as|xs) .\nTheorem 1. The operator R defined by (4) has a unique fixed point Qπ . Furthermore, if for each as ∈ A and each history Fs we have cs = cs(as,Fs) ∈ [ 0, π(as|xs)µ(as|xs) ] , then for any Q-function Q\n‖RQ−Qπ‖ ≤ γ‖Q−Qπ‖.\nThe following lemma will be useful in proving Theorem 1 (proof in the appendix).\nLemma 1. The difference betweenRQ and its fixed point Qπ is\nRQ(x, a)−Qπ(x, a) = Eµ [ ∑ t≥1 γt ( t−1∏ i=1 ci )([ Eπ[(Q−Qπ)(xt, ·)]− ct(Q−Qπ)(xt, at) ])] .\nProof (Theorem 1). The fact that Qπ is the fixed point of the operator R is obvious from (4) since Ext+1∼P (·|xt,at) [ rt + γEπQπ(xx+1, ·) − Qπ(xt, at) ] = (T πQπ − Qπ)(xt, at) = 0, since Qπ is the fixed point of T π . Now, from Lemma 1, and defining ∆Q := Q−Qπ , we have RQ(x, a)−Qπ(x, a) = ∑ t≥1 γtEx1:t,a1:t [( t−1∏ i=1 ci )([ Eπ∆Q(xt, ·)− ct∆Q(xt, at) ])]\n= ∑ t≥1 γtEx1:t,a1:t−1 [( t−1∏ i=1 ci )([ Eπ∆Q(xt, ·)− Eat [ct(at,Ft)∆Q(xt, at)|Ft] ])] = ∑ t≥1 γtEx1:t,a1:t−1 [( t−1∏ i=1 ci )∑ b ( π(b|xt)− µ(b|xt)ct(b,Ft) ) ∆Q(xt, b) ] .\nNow since π(a|xt) − µ(a|xt)ct(b,Ft) ≥ 0, we have that RQ(x, a) − Qπ(x, a) =∑ y,b wy,b∆Q(y, b), i.e. a linear combination of ∆Q(y, b) weighted by non-negative coefficients:\nwy,b := ∑ t≥1 γtEx1:t,a1:t−1 [( t−1∏ i=1 ci )( π(b|xt)− µ(b|xt)ct(b,Ft) ) I{xt = y} ] .\nThe sum of those coefficients is:∑ y,b wy,b = ∑ t≥1 γtEx1:t,a1:t−1 [( t−1∏ i=1 ci )∑ b ( π(b|xt)− µ(b|xt)ct(b,Ft) )]\n= ∑ t≥1 γtEx1:t,a1:t−1 [( t−1∏ i=1 ci ) Eat [1− ct(at,Ft)|Ft] ] = ∑ t≥1 γtEx1:t,a1:t [( t−1∏ i=1 ci ) (1− ct) ]\n= Eµ [∑ t≥1 γt ( t−1∏ i=1 ci ) − ∑ t≥1 γt ( t∏ i=1 ci )] = γC − (C − 1),\nwhere C := Eµ [∑ t≥0 γ t (∏t i=1 ci )] . Since C ≥ 1, we have that ∑ y,b wy,b ≤ γ. Thus RQ(x, a) − Qπ(x, a) is a sub-convex combination of ∆Q(y, b) weighted by non-negative coefficients wy,b which sum to (at most) γ, thusR is a γ-contraction mapping around Qπ .\nRemark 1. Notice that the coefficient C in the proof of Theorem 1 depends on (x, a). If we let η(x, a) := 1− (1− γ)Eµ [∑ t≥0 γ t( ∏t s=1 cs) ] , then we have shown that\n|RQ(x, a)−Qπ(x, a)| ≤ η(x, a)‖Q−Qπ‖. Thus η(x, a) ∈ [0, γ] is a (x, a)-specific contraction coefficient, which is γ when c1 = 0 (the trace is cut immediately) and can be close to zero when learning from full returns (ct ≈ 1 for all t)."
    }, {
      "heading" : "3.2 Control",
      "text" : "In the control setting, the single target policy π is replaced by a sequence of policies which depend on Qk. While most prior work has focused on strictly greedy policies, here we consider the larger class of increasingly greedy sequences. We now make this notion precise. Definition 1. We say that a sequence of policies (πk : k ∈ N) is increasingly greedy w.r.t. a sequence (Qk : k ∈ N) of Q-functions if the following property holds for all k:\nPπk+1Qk+1 ≥ PπkQk+1.\nIntuitively, this means that each πk+1 is at least as greedy as the previous policy πk for Qk+1. Many natural sequences of policies are increasingly greedy, including εk-greedy policies (with nonincreasing εk) and softmax policies (with non-increasing temperature). See proofs in the appendix.\nWe will assume that cs = cs(as,Fs) = c(as, xs) is Markovian, in the sense that it depends on xs, as (as well as the policies π and µ) only but not on the full past history. This allows us to define the (sub)-probability transition operator\n(P cµQ)(x, a) := ∑ x′ ∑ a′ p(x′|x, a)µ(a′|x′)c(a′, x′)Q(x′, a′).\nFinally, an additional requirement to the convergence in the control case, we assume thatQ0 satisfies T π0Q0 ≥ Q0 (this can be achieved by a pessimistic initialization Q0 = −RMAX/(1− γ)). Theorem 2. Consider an arbitrary sequence of behaviour policies (µk) (which may depend on (Qk)) and a sequence of target policies (πk) that are increasingly greedy w.r.t. the sequence (Qk):\nQk+1 = RkQk, where the return operator Rk is defined by (4) for πk and µk and a Markovian cs = c(as, xs) ∈ [0, π(as|xs)µ(as|xs) ]. Assume the target policies πk are εk-away from the greeedy policies w.r.t. Qk, in the sense that T πkQk ≥ T Qk − εk‖Qk‖e, where e is the vector with 1-components. Further suppose that T π0Q0 ≥ Q0. Then for any k ≥ 0, ‖Qk+1 −Q∗‖ ≤ γ‖Qk −Q∗‖+ εk‖Qk‖. In consequence, if εk → 0 then Qk → Q∗.\nSketch of Proof (The full proof is in the appendix). Using P cµk , the Retrace(λ) operator rewrites RkQ = Q+ ∑ t≥0 γt(P cµk)t(T πkQ−Q) = Q+ (I − γP cµk)−1(T πkQ−Q).\nWe now lower- and upper-bound the term Qk+1 −Q∗. Upper bound on Qk+1 − Q∗. We prove that Qk+1 − Q∗ ≤ Ak(Qk − Q∗) with Ak := γ(I − γP cµk)−1 [ Pπk − P cµk ] . Since ct ∈ [0, π(at|xt)µ(at|xt) ] we deduce that Ak has non-negative elements, whose sum over each row, is at most γ. Thus\nQk+1 −Q∗ ≤ γ‖Qk −Q∗‖e. (5)\nLower bound on Qk+1 −Q∗. Using the fact that T πkQk ≥ T π ∗ Qk − εk‖Qk‖e we have\nQk+1 −Q∗ ≥ Qk+1 − T πkQk + γPπ ∗ (Qk −Q∗)− γεk‖Qk‖e\n= γP cµk(I − γP cµk)−1(T πkQk −Qk) + γPπ ∗ (Qk −Q∗)− εk‖Qk‖e. (6)\nLower bound on T πkQk −Qk. Since (πk) is increasingly greedy, we have\nT πk+1Qk+1 −Qk+1 ≥ T πkQk+1 −Qk+1 = r + (γPπk − I)RQk = Bk(T πkQk −Qk), (7)\nwhereBk := γ[Pπk−P cµk ](I−γP cµk)−1. Since Pπk−P cµk and (I−γP cµk)−1 are non-negative matrices, so is Bk. Thus\nT πkQk −Qk ≥ Bk−1Bk−2 . . . B0(T π0Q0 −Q0) ≥ 0,\nsince we assumed Tπ0Q0 −Q0 ≥ 0. Thus, (6) implies that\nQk+1 −Q∗ ≥ γPπ ∗ (Qk −Q∗)− εk‖Qk‖e.\nand combining the above with (5) we deduce ‖Qk+1 − Q∗‖ ≤ γ‖Qk − Q∗‖ + εk‖Qk‖. When ε→ 0, we further deduce that Qk are bounded, thus Qk → Q∗."
    }, {
      "heading" : "3.3 Online algorithms",
      "text" : "So far we have analysed the contraction properties of the expected R operators. We now describe online algorithms which can learn from sample trajectories. We analyze the algorithms in the every visit form (Sutton and Barto, 1998), which is the more practical generalization of the first-visit form. In this section, we will only consider the Retrace(λ) algorithm defined with the coefficient c = λmin(1, π/µ). For that c, let us rewrite the operator P cµ as λPπ∧µ, where Pπ∧µQ(x, a) := ∑ y ∑ b min(π(b|y), µ(b|y))Q(y, b), and write the Retrace operator RQ = Q + (I − λγPπ∧µ)−1(T πQ − Q). We focus on the control case, noting that a similar (and more general) result can be derived for policy evaluation.\nTheorem 3. Consider a sequence of sample trajectories, with the kth trajectory x0, a0, r0, x1, a1, r1, . . . generated by following µk: at ∼ µk(·|xt). For each (x, a) along this trajectory, with s the time of first occurrence of (x, a), update\nQk+1(x, a)← Qk(x, a) + αk ∑ t≥s δπkt t∑ j=s γt−j ( t∏ i=j+1 ci ) I{xj , aj = x, a}, (8)\nwhere δπkt := rt + γEπkQk(xt+1, ·) − Qk(xt, at), αk = αk(xs, as). We consider the Retrace(λ) algorithm where ci = λmin ( 1, π(ai|xi)µ(ai|xi) ) . Assume that (πk) are increasingly greedy w.r.t. (Qk) and are each εk-away from the greedy policies (πQk), i.e. maxx ‖πk(·|x)−πQk(·|x)‖1 ≤ εk, with εk → 0. Assume that Pπk and Pπk∧µk asymptotically commute: limk ‖PπkPπk∧µk −Pπk∧µkPπk‖ = 0. Assume further that (1) all states and actions are visited infinitely often: ∑ t≥0 P{xt, at = x, a} ≥ D > 0, (2) the sample trajectories are finite in terms of the second moment of their lengths Tk: EµkT 2k <∞, (3) the stepsizes obey the usual Robbins-Munro conditions. Then Qk → Q∗ a.s.\nThe proof extends similar convergence proofs of TD(λ) by Bertsekas and Tsitsiklis (1996) and of optimistic policy iteration by Tsitsiklis (2003), and is provided in the appendix. Notice that compared to Theorem 2 we do not assume that T π0Q0−Q0 ≥ 0 here. However, we make the additional (rather technical) assumption that Pπk and Pπk∧µk commute at the limit. This is satisfied for example when the probability assigned by the behavior policy µk(·|x) to the greedy action πQk(x) is independent of x. Examples include ε-greedy policies, or more generally mixtures between the greedy policy πQk and an arbitrary distribution µ (see Lemma 5 in the appendix for the proof):\nµk(a|x) = ε µ(a|x)\n1− µ(πQk(x)|x) I{a 6= πQk(x)}+ (1− ε)I{a = πQk(x)}. (9)\nNotice that the mixture coefficient ε needs not go to 0."
    }, {
      "heading" : "4 Discussion of the results",
      "text" : ""
    }, {
      "heading" : "4.1 Choice of the trace coefficients cs",
      "text" : "Theorems 1 and 2 ensure convergence to Qπ and Q∗ for any trace coefficient cs ∈ [0, π(as|xs)µ(as|xs) ]. However, to make the best choice of cs, we need to consider the speed of convergence, which depends on both (1) the variance of the online estimate, which indicates how many online updates are required in a single iteration ofR, and (2) the contraction coefficient ofR. Variance The variance of the estimate strongly depends on the variance of the product trace (c1 . . . ct), which is not an easy quantity to control in general, as the (cs) are usually not independent. However, assuming independence and stationarity of (cs), we have that V (∑ t γ tc1 . . . ct )\nis at least ∑ t γ\n2tV(c)t, which is finite only if V(c) < 1/γ2. Thus, an important requirement for a numerically stable algorithm is for V(c) to be as small as possible, and certainly no more than 1/γ2. This rules out importance sampling (for which c ∝ π(a|x)µ(a|x) , and V(c|x) ∝ ∑ a µ(a|x) (π(a|x) µ(a|x)−1 )2 =∑\na π(at|xt)2 µ(at|xt) −1, which may be larger than 1/γ 2 for some π and µ), and is the reason we take cs ≤ 1.\nContraction speed The contraction coefficient η ∈ [0, γ] of R (see Remark 1) depends on how much the traces have been cut, and should be as small as possible (since it takes log(1/ε)/ log(1/η) iterations of R to obtain an ε-approximation). It is smallest when the traces are not cut at all (i.e. if cs = 1 for all s, R is the policy evaluation operator which produces Qπ in a single iteration). Indeed, when the traces are cut, we do not benefit from learning from full returns (in the extreme, c1 = 0 and R reduces to the Bellman operator with η = γ). Although (cs) should be as large as possible, they probably should not be larger than 1, or the update rule would consider the future to be more important than the present. A reasonable trade-off between low variance (when cs are small) and high contraction speed (when cs are large) is given by Retrace(λ), for which we provde the convergence of the online algorithm.\nIf we relax the assumption that the trace is Markovian (in which case only the result for policy evaluation has been proven so far) we could trade off a low trace at some time for a possibly largerthan-1 trace at another time, as long as their product is less than 1. A possible choice could be\nct = λmin ( 1 c1 . . . ct−1 , π(at|xt) µ(at|xt) ) . (10)"
    }, {
      "heading" : "4.2 Other topics of discussion",
      "text" : "No GLIE assumption. The crucial point of Theorem 2 is that convergence to Q∗ occurs for arbitrary behaviour policies. Thus the online result in Theorem 3 does not require the behaviour policies to become greedy in the limit of infinite exploration (i.e. GLIE assumption, Singh et al., 2000). We believe Theorem 3 provides the first convergence result to Q∗ for a λ-return (with λ > 0) algorithm that does not require this (hard to satisfy) assumption.\nProof of Watkins’ Q(λ). As a corollary of Theorem 3 when selecting our target policies πk to be greedy w.r.t. Qk (i.e. εk = 0), we deduce that Watkins’ Q(λ) (e.g., Watkins, 1989; Sutton and Barto, 1998) converges a.s. to Q∗ (under the assumption that µk commutes asymptotically with the greedy policies, which is satisfied for e.g. µk defined by (9)). We believe this is the first such proof.\nIncreasingly greedy policies The assumption that the sequence of target policies (πk) is increasingly greedy w.r.t. the sequence of (Qk) is more general that just considering greedy policies w.r.t. (Qk) (which is Watkins’s Q(λ)), and may be more efficient as well. Indeed, using non-greedy target policies πk can speed up convergence as the traces will not be cut as frequently. Of course, in order to converge to Q∗, we eventually need the target policies (and not the behaviour policies, as mentioned above) to become greedy in the limit (i.e. εk → 0 as defined in Theorem 2). Comparison to Qπ(λ). Unlike Retrace(λ), Qπ does not need to know the behaviour policy µ. However, it fails to converge when µ is far from π. Retrace(λ) uses its knowledge of µ (for the chosen actions) to cut the traces and safely handle arbitrary policies π and µ.\nComparison to TB(λ). Similarly to Qπ , TB(λ) does not need the knowledge of the behaviour policy µ. But as a consequence, TB(λ) is not able to benefit from possible near on-policy situations, cutting traces unnecessarily when π and µ are close.\nContinuous action space. Let us mention that Theorems 1 and 2 extend to the case of (measurable) continuous or infinite action spaces. The trace coefficients will make use of the densities min(1, dπ/dµ) instead of the probabilities min(1, π/µ). This would not be possible with TB(λ).\nOpen questions include: (1) Removing the technical assumption that Pπk and Pπk∧µk asymptotically commute, (2) Relaxing the Markov assumption in the control case in order to allow trace coefficients ct of the form (10)."
    }, {
      "heading" : "5 Experimental Results",
      "text" : "To validate our theoretical results, we employ Retrace(λ) in an experience replay (Lin, 1993) setting, where sample transitions are stored within a large but bounded replay memory and subsequently replayed as if they were new experience. Naturally, older data in the memory is usually drawn from a policy which differs from the current policy, offering an excellent point of comparison for the algorithms presented in Section 2.\nOur agent adapts the DQN architecture of Mnih et al. (2015) to replay short sequences from the memory (details in Appendix F) instead of single transitions. The Q-function target for a sample sequence xt, at, rt, · · · , xt+k is\n∆Q(xt, at) = k−1∑ s=t γs−t ( s∏ i=t+1 ci )[ r(xs, as) + γEπQ(xs+1, ·)−Q(xs, as) ] .\nWe compare our algorithms’ performance on 60 different Atari 2600 games in the Arcade Learning Environment (Bellemare et al., 2013) using Bellemare et al.’s inter-algorithm score distribution. Inter-algorithm scores are normalized so that 0 and 1 respectively correspond to the worst and best score for a particular game, within the set of algorithms under comparison. If g ∈ {1, . . . , 60} is a game and zg,a the inter-algorithm score on g for algorithm a, then the score distribution function is f(x) := |{g : zg,a ≥ x}|/60. Roughly, a strictly higher curve corresponds to a better algorithm. Across values of λ, λ = 1 performs best, save for Q∗ where λ = 0.5 obtains slightly superior performance. However, Q∗ diverges for larger λ values (see Figure 1, left), and yields poor performance for smaller ones. Both Retrace and TB(λ) achieve dramatically higher performance than\nQ-Learning early on and maintain their advantage throughout. Compared to TB(λ), Retrace(λ) offers a narrower but still marked advantage, being the best performer on 30 games; TB(λ) claims 15 of the remainder. Per-game performance details appear in Table 2 in Appendix F."
    }, {
      "heading" : "A Proof of Lemma 1",
      "text" : "Proof (Lemma 1). Let ∆Q := Q−Qπ . We begin by rewriting (4):\nRQ(x, a) = ∑ t≥0 γtEµ [( t∏ s=1 cs )( rt + γ [ EπQ(xt+1, ·)− ct+1Q(xt+1, at+1) )]] .\nSince Qπ is the fixed point ofR, we have Qπ(x, a) = RQπ(x, a) = ∑ t≥0 γtEµ [( t∏ s=1 cs )( rt + γ [ EπQπ(xt+1, ·)− ct+1Qπ(xt+1, at+1) )]] ,\nfrom which we deduce that\nRQ(x, a)−Qπ(x, a) = ∑ t≥0 γtEµ [( t∏ s=1 cs )( γ [ Eπ∆Q(xt+1, ·)− ct+1∆Q(xt+1, at+1) ])]\n= ∑ t≥1 γtEµ [( t−1∏ s=1 cs )([ Eπ∆Q(xt, ·)− ct∆Q(xt, at) ])] .\nB Increasingly greedy policies\nRecall the definition of an increasingly greedy sequence of policies. Definition 2. We say that a sequence of policies (πk) is increasingly greedy w.r.t. a sequence of functions (Qk) if the following property holds for all k:\nPπk+1Qk+1 ≥ PπkQk+1.\nIt is obvious to see that this property holds if all policies πk are greedy w.r.t. Qk. Indeed in such case, T πk+1Qk+1 = T Qk+1 ≥ T πQk+1 for any π. We now prove that this property holds for εk-greedy policies (with non-increasing (εk)) as well as soft-max policies (with non-decreasing (βk)), as stated in the two lemmas below.\nOf course not all policies satisfy this property (a counter-example being πk(a|x) := arg mina′ Qk(x, a\n′)). Lemma 2. Let (εk) be a non-increasing sequence. Then the sequence of policies (πk) which are εk-greedy w.r.t. the sequence of functions (Qk) is increasingly greedy w.r.t. that sequence.\nProof. From the definition of an ε-greedy policy we have: Pπk+1Qk+1(x, a) = ∑ y p(y|x, a) [ (1− εk+1) max b Qk+1(y, b) + εk+1 1 A ∑ b Qk+1(y, b) ]\n≥ ∑ y p(y|x, a) [ (1− εk) max b Qk+1(y, b) + εk 1 A ∑ b Qk+1(y, b) ]\n≥ ∑ y p(y|x, a) [ (1− εk)Qk+1(y, arg max b Qk(y, b)) + ε 1 A ∑ b Qk+1(y, b) ] = PπkQk+1,\nwhere we used the fact that εk+1 ≤ εk.\nLemma 3. Let (βk) be a non-decreasing sequence of soft-max parameters. Then the sequence of policies (πk) which are soft-max (with parameter βk) w.r.t. the sequence of functions (Qk) is increasingly greedy w.r.t. that sequence.\nProof. For any Q and y, define πβ(b) = e βQ(y,b)∑\nb′ e βQ(y,b′) and f(β) =\n∑ b πβ(b)Q(y, b). Then we have\nf ′(β) = ∑ b [ πβ(b)Q(y, b)− πβ(b) ∑ b′ πβ(b ′)Q(y, b′) ] Q(y, b)\n= ∑ b πβ(b)Q(y, b) 2 − (∑ b πβ(b)Q(y, b) )2\n= Vb∼πβ [ Q(y, b) ] ≥ 0.\nThus β 7→ f(β) is a non-decreasing function, and since βk+1 ≥ βk, we have\nPπk+1Qk+1(x, a) = ∑ y p(y|x, a) ∑ b eβk+1Qk+1(y,b)∑ b′ e βk+1Qk+1(y,b′) Qk+1(y, b)\n≥ ∑ y p(y|x, a) ∑ b eβkQk+1(y,b)∑ b′ e βkQk+1(y,b′) Qk+1(y, b)\n= PπkQk+1(x, a)."
    }, {
      "heading" : "C Proof of Theorem 2",
      "text" : "As mentioned in the main text, since cs is Markovian, we can define the (sub)-probability transition operator\n(P cµQ)(x, a) := ∑ x′ ∑ a′ p(x′|x, a)µ(a′|x′)c(a′, x′)Q(x′, a′).\nThe Retrace(λ) operator then writes RkQ = Q+ ∑ t≥0 γt(P cµk)t(T πkQ−Q) = Q+ (I − γP cµk)−1(T πkQ−Q).\nProof. We now lower- and upper-bound the term Qk+1 −Q∗.\nUpper bound on Qk+1 −Q∗. Since Qk+1 = RkQk, we have\nQk+1 −Q∗ = Qk −Q∗ + (I − γP cµk)−1 [ T πkQk −Qk ] = (I − γP cµk)−1 [ T πkQk −Qk + (I − γP cµk)(Qk −Q∗)]\n= (I − γP cµk)−1 [ T πkQk −Q∗ − γP cµk(Qk −Q∗)]\n= (I − γP cµk)−1 [ T πkQk − T Q∗ − γP cµk(Qk −Q∗)]\n≤ (I − γP cµk)−1 [ γPπk(Qk −Q∗)− γP cµk(Qk −Q∗)]\n= γ(I − γP cµk)−1 [ Pπk − P cµk ] (Qk −Q∗), = Ak(Qk −Q∗), (11)\nwhere Ak := γ(I − γP cµk)−1 [ Pπk − P cµk ] .\nNow let us prove that Ak has non-negative elements, whose sum over each row is at most γ. Let e be the vector with 1-components. By rewriting Ak as γ ∑ t≥0 γ\nt(P cµk)t(Pπk −P cµk) and noticing that\n(Pπk − P cµk)e(x, a) = ∑ x′ ∑ a′ p(x′|x, a)[πk(a′|x′)− c(a′, x′)µk(a′|x′)] ≥ 0, (12)\nit is clear that all elements of Ak are non-negative. We have Ake = γ ∑ t≥0 γt(P cµk)t [ Pπk − P cµk ] e\n= γ ∑ t≥0 γt(P cµk)te− ∑ t≥0 γt+1(P cµk)t+1e\n= e− (1− γ) ∑ t≥0 γt(P cµk)te\n≤ γe, (13) (since ∑ t≥0 γ\nt(P cµk)te ≥ e). Thus Ak has non-negative elements, whose sum over each row, is at most γ. We deduce from (11) that Qk+1 − Q∗ is upper-bounded by a sub-convex combination of components of Qk −Q∗; the sum of their coefficients is at most γ. Thus\nQk+1 −Q∗ ≤ γ‖Qk −Q∗‖e. (14)\nLower bound on Qk+1 −Q∗. We have Qk+1 = Qk + (I − γP cµk)−1(T πkQk −Qk)\n= Qk + ∑ i≥0 γi(P cµk)i(T πkQk −Qk)\n= T πkQk + ∑ i≥1 γi(P cµk)i(T πkQk −Qk)\n= T πkQk + γP cµk(I − γP cµk)−1(T πkQk −Qk). (15)\nNow, from the definition of εk we have T πkQk ≥ T Qk − εk‖Qk‖ ≥ T π ∗ Qk − εk‖Qk‖, thus\nQk+1 −Q∗ = Qk+1 − T πkQk + T πkQk − T π ∗ Qk + T π ∗ Qk − T π ∗ Q∗\n≥ Qk+1 − T πkQk + γPπ ∗ (Qk −Q∗)− εk‖Qk‖e\nUsing (15) we derive the lower bound:\nQk+1 −Q∗ ≥ γP cµk(I − γP cµk)−1(T πkQk −Qk) + γPπ ∗ (Qk −Q∗)− εk‖Qk‖. (16)\nLower bound on T πkQk −Qk. By hypothesis, (πk) is increasingly greedy w.r.t. (Qk), thus T πk+1Qk+1 −Qk+1 ≥ T πkQk+1 −Qk+1\n= T πkRQk −RQk = r + (γPπk − I)RQk = r + (γPπk − I) [ Qk + (I − γP cµk)−1(T πkQk −Qk)\n] = T πkQk −Qk + (γPπk − I)(I − γP cµk)−1(T πkQk −Qk) = γ [ Pπk − P cµk ] (I − γP cµk)−1(T πkQk −Qk)\n= Bk(T πkQk −Qk), (17) where Bk := γ[Pπk − P cµk ](I − γP cµk)−1. Since Pπk − P cµk has non-negative elements (as proven in (12)) as well as (I − γP cµk)−1, then Bk has non-negative elements as well. Thus T πkQk −Qk ≥ Bk−1Bk−2 . . . B0(T π0Q0 −Q0) ≥ 0, since we assumed Tπ0Q0 −Q0 ≥ 0. Thus (16) implies that\nQk+1 −Q∗ ≥ γPπ ∗ (Qk −Q∗)− εk‖Qk‖.\nand combining the above with (14) we deduce ‖Qk+1 −Q∗‖ ≤ γ‖Qk −Q∗‖+ εk‖Qk‖.\nNow assume that εk → 0. We first deduce that Qk is bounded. Indeed as soon as εk < (1 − γ)/2, we have\n‖Qk+1‖ ≤ ‖Q∗‖+ γ‖Qk −Q∗‖+ 1− γ\n2 ‖Qk‖ ≤ (1 + γ)‖Q∗‖+\n1 + γ\n2 ‖Qk‖.\nThus lim sup ‖Qk‖ ≤ 1+γ1−(1+γ)/2‖Q ∗‖. Since Qk is bounded, we deduce that lim supQk = Q∗."
    }, {
      "heading" : "D Proof of Theorem 3",
      "text" : "We first prove convergence of the general online algorithm. Theorem 4. Consider the algorithm\nQk+1(x, a) = (1− αk(x, a))Qk(x, a) + αk(x, a)(RkQk(x, a) + ωk(x, a) + υk(x, a)), (18) and assume that (1) ωk is a centered, Fk-measurable noise term of bounded variance, and (2) υk is bounded from above by θk(‖Qk‖+ 1), where (θk) is a random sequence that converges to 0 a.s. Then, under the same assumptions as in Theorem 3, we have that Qk → Q∗ almost surely.\nProof. We writeR forRk. Let us prove the result in three steps. Upper bound onRQk −Q∗. The first part of the proof is similar to the proof of (14), so we have\nRQk −Q∗ ≤ γ‖Qk −Q∗‖e. (19)\nLower bound onRQk −Q∗. Again, similarly to (16) we have RQk −Q∗ ≥ γλPπk∧µk(I − γλPπk∧µk)−1(T πkQk −Qk)\n+γPπ ∗ (Qk −Q∗)− εk‖Qk‖. (20)\nLower-bound on T πkQk − Qk. Since the sequence of policies (πk) is increasingly greedy w.r.t. (Qk), we have\nT πk+1Qk+1 −Qk+1 ≥ T πkQk+1 −Qk+1 = (1− αk)T πkQk + αkT πk(RQk + ωk + υk)−Qk+1 = (1− αk)(T πkQk −Qk) + αk [ T πkRQk −RQk + ω′k + υ′k ] ,(21)\nwhere ω′k := (γP πk − I)ωk and υ′k := (γPπk − I)υk. It is easy to see that both ω′k and υ′k continue to satisfy the assumptions on ωk, and υk. Now, from the definition of theR operator, we have T πkRQk −RQk = r + (γPπk − I)RQk\n= r + (γPπk − I) [ Qk + (I − γλPπk∧µk)−1(T πkQk −Qk) ] = T πkQk −Qk + (γPπk − I)(I − γλPπk∧µk)−1(T πkQk −Qk) = γ(Pπk − λPπk∧µk)(I − γλPπk∧µk)−1(T πkQk −Qk).\nUsing this equality into (21) and writing ξk := T πkQk −Qk, we have ξk+1 ≥ (1− αk)ξk + αk [ Bkξk + ω ′ k + υ ′ k ] , (22)\nwhere Bk := γ(Pπk − λPπk∧µk)(I − γλPπk∧µk)−1. The matrix Bk is non-negative but may not be a contraction mapping (the sum of its components per row may be larger than 1). Thus we cannot directly apply Proposition 4.5 of Bertsekas and Tsitsiklis (1996). However, as we have seen in the proof of Theorem 2, the matrix Ak := γ(I − γλPπk∧µk)−1(Pπk − λPπk∧µk) is a γ-contraction mapping. So now we relate Bk to Ak using our assumption that Pπk and Pπk∧µk commute asymptotically, i.e. ‖PπkPπk∧µk − Pπk∧µkPπk‖ = ηk with ηk → 0. For any (sub)transition matrices U and V , we have\nU(I − λγV )−1 = ∑ t≥0 (λγ)tUV t\n= ∑ t≥0 (λγ)t [ t−1∑ s=0 V s(UV − V U)V t−s−1 + V tU ] = (I − λγV )−1U + ∑ t≥0 (λγ)t t−1∑ s=0 V s(UV − V U)V t−s−1.\nReplacing U by Pπk and V by Pπk∧µk , we deduce\n‖Bk −Ak‖ ≤ γ ∑ t≥0 t(λγ)tηk = γ 1 (1− λγ)2 ηk.\nThus, from (22), ξk+1 ≥ (1− αk)ξk + αk [ Akξk + ω ′ k + υ ′′ k ] , (23)\nwhere υ′′k := υ ′ k+γ ∑ t≥0 t(λγ) tηk‖ξk‖ continues to satisfy the assumptions on υk (since ηk → 0).\nNow, let us define another sequence ξ′k as follows: ξ ′ 0 = ξ0 and\nξ′k+1 = (1− αk)ξ′k + αk(Akξ′k + ω′k + υ′′k ).\nWe can now apply Proposition 4.5 of Bertsekas and Tsitsiklis (1996) to the sequence (ξ′k). The matrices Ak are non-negative, and the sum of their coefficients per row is bounded by γ, see (13), thus Ak are γ-contraction mappings and have the same fixed point which is 0. The noise ω′k is centered and Fk-measurable and satisfies the bounded variance assumption, and υ′′k is bounded above by (1 + γ)θ′k(‖Qk‖+ 1) for some θ′k → 0. Thus limk ξ′k = 0 almost surely. Now, it is straightforward to see that ξk ≥ ξ′k for all k ≥ 0. Indeed by induction, let us assume that ξk ≥ ξ′k. Then\nξk+1 ≥ (1− αk)ξk + αk(Akξk + ω′k + υ′′k ) ≥ (1− αk)ξ′k + αk(Akξ′k + ω′k + υ′′k ) = ξ′k+1,\nsince all elements of the matrix Ak are non-negative. Thus we deduce that\nlim inf k→∞ ξk ≥ lim k→∞ ξ′k = 0 (24)\nConclusion. Using (24) in (20) we deduce the lower bound:\nlim inf k→∞ RQk −Q∗ ≥ lim inf k→∞ γPπ ∗ (Qk −Q∗), (25)\nalmost surely. Now combining with the upper bound (19) we deduce that\n‖RQk −Q∗‖ ≤ γ‖Qk −Q∗‖+O(εk‖Qk‖) +O(ξk).\nThe last two terms can be incorporated to the υk(x, a) and ωk(x, a) terms, respectively; we thus again apply Proposition 4.5 of Bertsekas and Tsitsiklis (1996) to the sequence (Qk) defined by (18) and deduce that Qk → Q∗ almost surely.\nIt remains to rewrite the update (8) in the form of (18), in order to apply Theorem 4.\nLet zks,t denote the accumulating trace (Sutton and Barto, 1998):\nzks,t := t∑ j=s γt−j ( t∏ i=j+1 ci ) I{(xj , aj) = (xs, as)}.\nLet us write Qok+1(xs, as) to emphasize the online setting. Then (8) can be written as Qok+1(xs, as)← Qok(xs, as) + αk(xs, as) ∑ t≥s δπkt z k s,t, (26)\nδπkt := rt + γEπkQok(xt+1, ·)−Qok(xt, at),\nUsing our assumptions on finite trajectories, and ci ≤ 1, we can show that: E [∑ t≥s zks,t|Fk ] < E [ T 2k |Fk ] <∞ (27)\nwhere Tk denotes trajectory length. Now, let Dk := Dk(xs, as) := ∑ t≥s P{(xt, at) = (xs, as)}. Then, using (27), we can show that the total update is bounded, and rewrite\nEµk [∑ t≥s δπkt z k s,t ] = Dk(xs, as) ( RkQk(xs, as)−Q(xs, as) ) .\nFinally, using the above, and writing αk = αk(xs, as), (26) can be rewritten in the desired form: Qok+1(xs, as)← (1− α̃k)Qok(xs, as) + α̃k ( RkQok(xs, as) + ωk(xs, as) + υk(xs, as) ) , (28)\nωk(xs, as) := (Dk) −1 ∑ t≥s δπkt z k s,t − Eµk ∑ t≥s δπkt z k s,t  , υk(xs, as) := (α̃k)\n−1(Qok+1(xs, as)−Qk+1(xs, as)), α̃k := αkDk.\nIt can be shown that the variance of the noise term ωk is bounded, using (27) and the fact that the reward function is bounded. It follows from Assumptions 1-3 that the modified stepsize sequence (α̃k) satisfies the conditions of Assumption 1. The second noise term υk(xs, as) measures the difference between online iterates and the corresponding offline values, and can be shown to satisfy the required assumption analogously to the argument in the proof of Prop. 5.2 in Bertsekas and Tsitsiklis (1996). The proof relies on the eligibility coefficients (27) and rewards being bounded, the trajectories being finite, and the conditions on the stepsizes being satisfied.\nWe can thus apply Theorem 4 to (28), and conclude that the iterates Qok → Q∗ as k →∞, w.p. 1."
    }, {
      "heading" : "E Asymptotic commutativity of P πk and P πk∧µk",
      "text" : "Lemma 4. Let (πk) and (µk) two sequences of policies. If there exists α such that for all x, a,\nmin(πk(a|x), µk(a|x)) = απk(a|x) + o(1), (29) then the transition matrices Pπk and Pπk∧µk asymptotically commute: ‖PπkPπk∧µk − Pπk∧µkPπk‖ = o(1).\nProof. For any Q, we have (PπkPπk∧µk)Q(x, a) = ∑ y p(y|x, a) ∑ b πk(b|y) ∑ z p(z|y, b) ∑ c (πk ∧ µk)(c|z)Q(z, c)\n= α ∑ y p(y|x, a) ∑ b πk(b|y) ∑ z p(z|y, b) ∑ c πk(c|z)Q(z, c) + ‖Q‖o(1)\n= ∑ y p(y|x, a) ∑ b (πk ∧ µk)(b|y) ∑ z p(z|y, b) ∑ c πk(c|z)Q(z, c) + ‖Q‖o(1)\n= (Pπk∧µkPπk)Q(x, a) + ‖Q‖o(1). Lemma 5. Let (πQk) a sequence of (deterministic) greedy policies w.r.t. a sequence (Qk). Let (πk) a sequence of policies that are εk away from (πQk), in the sense that, for all x,\n‖πk(·|x)− πQk(x)‖1 := 1− πk(πQk(x)|x) + ∑\na 6=πQk (x)\nπk(a|x) ≤ εk.\nLet (µk) a sequence of policies defined by:\nµk(a|x) = αµ(a|x)\n1− µ(πQk(x)|x) I{a 6= πQk(x)}+ (1− α)I{a = πQk(x)}, (30)\nfor some arbitrary policy µ and α ∈ [0, 1]. Assume εk → 0. Then the transition matrices Pπk and Pπk∧µk asymptotically commute.\nProof. The intuition is that asymptotically πk gets very close to the deterministic policy πQk . In that case, the minimum distribution (πk ∧ µk)(·|x) puts a mass close to 1− α on the greedy action πQk(x), and no mass on other actions, thus (πk ∧ µk) gets very close to (1 − α)πk, and Lemma 4 applies (with multiplicative constant 1− α). Indeed, from our assumption that πk is ε-away from πQk we have:\nπk(πQk(x)|x) ≥ 1− εk, and πk(a 6= πQk(x)|x) ≤ εk.\nWe deduce that\n(πk ∧ µk)(πQk(x)|x) = min(πk(πQk(x)|x), 1− α) = 1− α+O(εk) = (1− α)πk(πQk(x)|x) +O(εk),\nand\n(πk ∧ µk)(a 6= πQk(x)|x) = O(εk) = (1− α)πk(a|x) +O(εk).\nThus Lemma 4 applies (with a multiplicative constant 1 − α) and Pπk and Pπk∧µk asymptotically commute."
    }, {
      "heading" : "F Experimental Methods",
      "text" : "Although our experiments’ learning problem closely matches the DQN setting used by Mnih et al. (2015) (i.e. single-thread off-policy learning with large replay memory), we conducted our trials in the multi-threaded, CPU-based framework of Mnih et al. (2016), obtaining ample result data from affordable CPU resources. Key differences from the DQN are as follows. Sixteen threads with private environment instances train simultaneously; each infers with and finds gradients w.r.t. a local copy of the network parameters; gradients then update a “master” parameter set and local copies are refreshed. Target network parameters are simply shared globally. Each thread has private replay memory holding 62,500 transitions (1/16th of DQN’s total replay capacity). The optimiser is unchanged from (Mnih et al., 2016): “Shared RMSprop” with step size annealing to 0 over 3× 108 environment frames (summed over threads). Exploration parameter (ε) behaviour differs slightly: every 50,000 frames, threads switch randomly (probability 0.3, 0.4, and 0.3 respectively) between three schedules (anneal ε from 1 to 0.5, 0.1, or 0.01 over 250,000 frames), starting new schedules at the intermediate positions where they left old ones.1\nOur experiments comprise 60 Atari 2600 games in ALE (Bellemare et al., 2013), with “life” loss treated as episode termination. The control, minibatched (64 transitions/minibatch) one-step Qlearning as in (Mnih et al., 2015), shows performance comparable to DQN in our multi-threaded setup. Retrace, TB, and Q* runs use minibatches of four 16-step sequences (again 64 transitions/minibatch) and the current exploration policy as the target policy π. All trials clamp rewards into [−1, 1]. In the control, Q-function targets are clamped into [−1, 1] prior to gradient calculation; analogous quantities in the multi-step algorithms are clamped into [−1, 1], then scaled (divided by) the sequence length. Coarse, then fine logarithmic parameter sweeps on the games Asterix, Breakout, Enduro, Freeway, H.E.R.O, Pong, Q*bert, and Seaquest yielded step sizes of 0.0000439 and 0.0000912, and RMSprop regularisation parameters of 0.001 and 0.0000368, for control and multistep algorithms respectively. Reported performance averages over four trials with different random seeds for each experimental configuration.\n1We evaluated a DQN-style single schedule for ε, but our multi-schedule method, similar to the one used by Mnih et al., yielded improved performance in our multi-threaded setting."
    } ],
    "references" : [ {
      "title" : "The Arcade Learning Environment: An evaluation platform for general agents",
      "author" : [ "M.G. Bellemare", "Y. Naddaf", "J. Veness", "M. Bowling" ],
      "venue" : "Journal of Artificial Intelligence Research, 47:253–279.",
      "citeRegEx" : "Bellemare et al\\.,? 2013",
      "shortCiteRegEx" : "Bellemare et al\\.",
      "year" : 2013
    }, {
      "title" : "Neuro-Dynamic Programming",
      "author" : [ "D.P. Bertsekas", "J.N. Tsitsiklis" ],
      "venue" : "Athena Scientific.",
      "citeRegEx" : "Bertsekas and Tsitsiklis,? 1996",
      "shortCiteRegEx" : "Bertsekas and Tsitsiklis",
      "year" : 1996
    }, {
      "title" : "Off-policy learning with eligibility traces: A survey",
      "author" : [ "M. Geist", "B. Scherrer" ],
      "venue" : "The Journal of Machine Learning Research, 15(1):289–333.",
      "citeRegEx" : "Geist and Scherrer,? 2014",
      "shortCiteRegEx" : "Geist and Scherrer",
      "year" : 2014
    }, {
      "title" : "Generalized emphatic temporal difference learning: Bias-variance analysis",
      "author" : [ "A. Hallak", "A. Tamar", "R. Munos", "S. Mannor" ],
      "venue" : "arXiv:1509.05172.",
      "citeRegEx" : "Hallak et al\\.,? 2015",
      "shortCiteRegEx" : "Hallak et al\\.",
      "year" : 2015
    }, {
      "title" : "Q(λ) with off-policy corrections",
      "author" : [ "A. Harutyunyan", "M.G. Bellemare", "T. Stepleton", "R. Munos" ],
      "venue" : "arXiv:1602.04951.",
      "citeRegEx" : "Harutyunyan et al\\.,? 2016",
      "shortCiteRegEx" : "Harutyunyan et al\\.",
      "year" : 2016
    }, {
      "title" : "Bias-variance error bounds for temporal difference updates",
      "author" : [ "M.J. Kearns", "S.P. Singh" ],
      "venue" : "Conference on Computational Learning Theory, pages 142–147.",
      "citeRegEx" : "Kearns and Singh,? 2000",
      "shortCiteRegEx" : "Kearns and Singh",
      "year" : 2000
    }, {
      "title" : "Scaling up reinforcement learning for robot control",
      "author" : [ "L. Lin" ],
      "venue" : "Machine Learning: Proceedings of the Tenth International Conference, pages 182–189.",
      "citeRegEx" : "Lin,? 1993",
      "shortCiteRegEx" : "Lin",
      "year" : 1993
    }, {
      "title" : "Off-policy learning based on weighted importance sampling with linear computational complexity",
      "author" : [ "A.R. Mahmood", "R.S. Sutton" ],
      "venue" : "Conference on Uncertainty in Artificial Intelligence.",
      "citeRegEx" : "Mahmood and Sutton,? 2015",
      "shortCiteRegEx" : "Mahmood and Sutton",
      "year" : 2015
    }, {
      "title" : "Emphatic temporal-difference learning",
      "author" : [ "A.R. Mahmood", "H. Yu", "M. White", "R.S. Sutton" ],
      "venue" : "arXiv:1507.01569.",
      "citeRegEx" : "Mahmood et al\\.,? 2015",
      "shortCiteRegEx" : "Mahmood et al\\.",
      "year" : 2015
    }, {
      "title" : "Asynchronous methods for deep reinforcement learning",
      "author" : [ "V. Mnih", "A.P. Badia", "M. Mirza", "A. Graves", "T.P. Lillicrap", "T. Harley", "D. Silver", "K. Kavukcuoglu" ],
      "venue" : "arXiv:1602.01783.",
      "citeRegEx" : "Mnih et al\\.,? 2016",
      "shortCiteRegEx" : "Mnih et al\\.",
      "year" : 2016
    }, {
      "title" : "Human-level control through deep reinforcement learning",
      "author" : [ "V. Mnih", "K. Kavukcuoglu", "D. Silver", "A.A. Rusu", "J. Veness", "M.G. Bellemare", "A. Graves", "M. Riedmiller", "A.K. Fidjeland", "G Ostrovski" ],
      "venue" : null,
      "citeRegEx" : "Mnih et al\\.,? \\Q2015\\E",
      "shortCiteRegEx" : "Mnih et al\\.",
      "year" : 2015
    }, {
      "title" : "Off-policy temporal-difference learning with function approximation",
      "author" : [ "D. Precup", "R.S. Sutton", "S. Dasgupta" ],
      "venue" : "International Conference on Machine Laerning, pages 417–424.",
      "citeRegEx" : "Precup et al\\.,? 2001",
      "shortCiteRegEx" : "Precup et al\\.",
      "year" : 2001
    }, {
      "title" : "Eligibility traces for off-policy policy evaluation",
      "author" : [ "D. Precup", "R.S. Sutton", "S. Singh" ],
      "venue" : "Proceedings of the Seventeenth International Conference on Machine Learning.",
      "citeRegEx" : "Precup et al\\.,? 2000",
      "shortCiteRegEx" : "Precup et al\\.",
      "year" : 2000
    }, {
      "title" : "Markov Decision Processes: Discrete Stochastic Dynamic Programming",
      "author" : [ "M.L. Puterman" ],
      "venue" : "John Wiley & Sons, Inc., New York, NY, USA, 1st edition.",
      "citeRegEx" : "Puterman,? 1994",
      "shortCiteRegEx" : "Puterman",
      "year" : 1994
    }, {
      "title" : "Prioritized experience replay",
      "author" : [ "T. Schaul", "J. Quan", "I. Antonoglou", "D. Silver" ],
      "venue" : "International Conference on Learning Representations.",
      "citeRegEx" : "Schaul et al\\.,? 2016",
      "shortCiteRegEx" : "Schaul et al\\.",
      "year" : 2016
    }, {
      "title" : "Convergence results for singlestep on-policy reinforcement-learning algorithms",
      "author" : [ "S. Singh", "T. Jaakkola", "M.L. Littman", "C. Szepesvári" ],
      "venue" : "Machine Learning, 38(3):287–308.",
      "citeRegEx" : "Singh et al\\.,? 2000",
      "shortCiteRegEx" : "Singh et al\\.",
      "year" : 2000
    }, {
      "title" : "Reinforcement learning: An introduction, volume 116",
      "author" : [ "R. Sutton", "A. Barto" ],
      "venue" : "Cambridge Univ Press.",
      "citeRegEx" : "Sutton and Barto,? 1998",
      "shortCiteRegEx" : "Sutton and Barto",
      "year" : 1998
    }, {
      "title" : "Learning to predict by the methods of temporal differences",
      "author" : [ "R.S. Sutton" ],
      "venue" : "Machine learning, 3(1):9–44.",
      "citeRegEx" : "Sutton,? 1988",
      "shortCiteRegEx" : "Sutton",
      "year" : 1988
    }, {
      "title" : "Generalization in reinforcement learning: Successful examples using sparse coarse coding",
      "author" : [ "R.S. Sutton" ],
      "venue" : "Advances in Neural Information Processing Systems 8.",
      "citeRegEx" : "Sutton,? 1996",
      "shortCiteRegEx" : "Sutton",
      "year" : 1996
    }, {
      "title" : "On the convergence of optimistic policy iteration",
      "author" : [ "J.N. Tsitsiklis" ],
      "venue" : "Journal of Machine",
      "citeRegEx" : "Tsitsiklis,? 2003",
      "shortCiteRegEx" : "Tsitsiklis",
      "year" : 2003
    }, {
      "title" : "Learning from Delayed Rewards",
      "author" : [ "Watkins", "C.J.C. H" ],
      "venue" : "Learning Research,",
      "citeRegEx" : "Watkins and H.,? \\Q1989\\E",
      "shortCiteRegEx" : "Watkins and H.",
      "year" : 1989
    } ],
    "referenceMentions" : [ {
      "referenceID" : 18,
      "context" : "One fundamental trade-off in reinforcement learning lies in the definition of the update target: should one estimate Monte Carlo returns or bootstrap from an existing Q-function? Return-based methods (where return refers to the sum of discounted rewards ∑ t γ rt) offer some advantages over value bootstrap methods: they are better behaved when combined with function approximation, and quickly propagate the fruits of exploration (Sutton, 1996).",
      "startOffset" : 431,
      "endOffset" : 445
    }, {
      "referenceID" : 12,
      "context" : "Alternatively, the Tree-backup (TB) (λ) algorithm (Precup et al., 2000) tolerates arbitrary target/behavior discrepancies by scaling information (here called traces) from future temporal differences by the product of target policy probabilities.",
      "startOffset" : 50,
      "endOffset" : 71
    }, {
      "referenceID" : 6,
      "context" : "Retrace(λ) can learn from full returns retrieved from past policy data, as in the context of experience replay (Lin, 1993), which has returned to favour with advances in deep reinforcement learning (Mnih ar X iv :1 60 6.",
      "startOffset" : 111,
      "endOffset" : 122
    }, {
      "referenceID" : 4,
      "context" : "We start from the recent work of Harutyunyan et al. (2016), who show that naive off-policy policy evaluation, without correcting for the “off-policyness” of a trajectory, still converges to the desired Q value function provided the behavior μ and target π policies are not too far apart (the maximum allowed distance depends on the λ parameter).",
      "startOffset" : 33,
      "endOffset" : 59
    }, {
      "referenceID" : 15,
      "context" : "To the best of our knowledge, this is the first online return-based off-policy control algorithm which does not require the GLIE (Greedy in the Limit with Infinite Exploration) assumption (Singh et al., 2000).",
      "startOffset" : 188,
      "endOffset" : 208
    }, {
      "referenceID" : 16,
      "context" : "In addition, we provide as a corollary the first proof of convergence of Watkins’ Q(λ) (see, e.g., Watkins, 1989; Sutton and Barto, 1998).",
      "startOffset" : 87,
      "endOffset" : 137
    }, {
      "referenceID" : 0,
      "context" : "Finally, we illustrate the significance of Retrace(λ) in a deep learning setting by applying it to the suite of Atari 2600 games provided by the Arcade Learning Environment (Bellemare et al., 2013).",
      "startOffset" : 173,
      "endOffset" : 197
    }, {
      "referenceID" : 13,
      "context" : "(3) Its fixed point is Q∗, the unique optimal value function (Puterman, 1994).",
      "startOffset" : 61,
      "endOffset" : 77
    }, {
      "referenceID" : 17,
      "context" : "Return-based Operators: The λ-return extension (Sutton, 1988) of both (2) and (3) considers exponentially weighted sums of n-step returns: T π λ Q := (1− λ) ∑",
      "startOffset" : 47,
      "endOffset" : 61
    }, {
      "referenceID" : 16,
      "context" : "At one extreme (λ = 0) we have the Bellman operator T π λ=0Q = T Q, while at the other (λ = 1) we have the policy evaluation operator T π λ=1Q = Q which can be estimated using Monte Carlo methods (Sutton and Barto, 1998).",
      "startOffset" : 196,
      "endOffset" : 220
    }, {
      "referenceID" : 5,
      "context" : "Intermediate values of λ trade off estimation bias with sample variance (Kearns and Singh, 2000).",
      "startOffset" : 72,
      "endOffset" : 96
    }, {
      "referenceID" : 16,
      "context" : "By extension of the idea of eligibility traces (Sutton and Barto, 1998), we informally call the coefficients (cs) the traces of the operator.",
      "startOffset" : 47,
      "endOffset" : 71
    }, {
      "referenceID" : 2,
      "context" : "Importance sampling is the simplest way to correct for the discrepancy between μ and π when learning from off-policy returns (Precup et al., 2000, 2001; Geist and Scherrer, 2014).",
      "startOffset" : 125,
      "endOffset" : 178
    }, {
      "referenceID" : 7,
      "context" : "It is well known that IS estimates can suffer from large – even possibly infinite – variance (mainly due to the variance of the product π(a1|x1) μ(a1|x1) · · · π(at|xt) μ(at|xt) ), which has motivated further variance reduction techniques such as (Mahmood and Sutton, 2015; Mahmood et al., 2015; Hallak et al., 2015).",
      "startOffset" : 247,
      "endOffset" : 316
    }, {
      "referenceID" : 8,
      "context" : "It is well known that IS estimates can suffer from large – even possibly infinite – variance (mainly due to the variance of the product π(a1|x1) μ(a1|x1) · · · π(at|xt) μ(at|xt) ), which has motivated further variance reduction techniques such as (Mahmood and Sutton, 2015; Mahmood et al., 2015; Hallak et al., 2015).",
      "startOffset" : 247,
      "endOffset" : 316
    }, {
      "referenceID" : 3,
      "context" : "It is well known that IS estimates can suffer from large – even possibly infinite – variance (mainly due to the variance of the product π(a1|x1) μ(a1|x1) · · · π(at|xt) μ(at|xt) ), which has motivated further variance reduction techniques such as (Mahmood and Sutton, 2015; Mahmood et al., 2015; Hallak et al., 2015).",
      "startOffset" : 247,
      "endOffset" : 316
    }, {
      "referenceID" : 2,
      "context" : ", 2000, 2001; Geist and Scherrer, 2014). The off-policy correction uses the product of the likelihood ratios between π and μ. Notice that the RQ operator (4) defined with this choice of (cs) yields Q for any Q. For Q = 0 we recover the basic IS estimate ∑ t≥0 γ t (∏t s=1 cs ) rt, thus (4) can be seen as a variance reduction technique (with a baseline Q). It is well known that IS estimates can suffer from large – even possibly infinite – variance (mainly due to the variance of the product π(a1|x1) μ(a1|x1) · · · π(at|xt) μ(at|xt) ), which has motivated further variance reduction techniques such as (Mahmood and Sutton, 2015; Mahmood et al., 2015; Hallak et al., 2015). Off-policy Q(λ) and Q∗(λ): cs = λ. A recent alternative proposed by Harutyunyan et al. (2016) introduces an off-policy correction based on a Q-baseline (instead of correcting the probability of the sample path like in IS).",
      "startOffset" : 14,
      "endOffset" : 769
    }, {
      "referenceID" : 2,
      "context" : ", 2000, 2001; Geist and Scherrer, 2014). The off-policy correction uses the product of the likelihood ratios between π and μ. Notice that the RQ operator (4) defined with this choice of (cs) yields Q for any Q. For Q = 0 we recover the basic IS estimate ∑ t≥0 γ t (∏t s=1 cs ) rt, thus (4) can be seen as a variance reduction technique (with a baseline Q). It is well known that IS estimates can suffer from large – even possibly infinite – variance (mainly due to the variance of the product π(a1|x1) μ(a1|x1) · · · π(at|xt) μ(at|xt) ), which has motivated further variance reduction techniques such as (Mahmood and Sutton, 2015; Mahmood et al., 2015; Hallak et al., 2015). Off-policy Q(λ) and Q∗(λ): cs = λ. A recent alternative proposed by Harutyunyan et al. (2016) introduces an off-policy correction based on a Q-baseline (instead of correcting the probability of the sample path like in IS). This approach, called Q(λ) and Q∗(λ) for policy evaluation and control, respectively, corresponds to the choice cs = λ. It offers the advantage of avoiding the blow-up of the variance of the product of ratios encountered with IS. Interestingly, this operator contracts around Q provided that μ and π are sufficiently close to each other. Defining ε := maxx ‖π(·|x)−μ(·|x)‖1 the amount of “off-policyness”, the authors prove that the operator defined by (4) with cs = λ is a contraction mapping around Q for λ < 1−γ γε , and around Q ∗ for the worst case of λ < 1−γ 2γ . Unfortunately, Q(λ) requires knowledge of ε, and the condition for Q∗(λ) is very conservative. Neither Q(λ), nor Q∗(λ) are safe as they do not guarantee convergence for arbitrary π and μ. Tree-backup (TB) (λ): cs = λπ(as|xs). The TB(λ) algorithm of Precup et al. (2000) corrects for the target/behaviour discrepancy by multiplying each term of the sum by the product of target policy probabilities.",
      "startOffset" : 14,
      "endOffset" : 1738
    }, {
      "referenceID" : 16,
      "context" : "We analyze the algorithms in the every visit form (Sutton and Barto, 1998), which is the more practical generalization of the first-visit form.",
      "startOffset" : 50,
      "endOffset" : 74
    }, {
      "referenceID" : 1,
      "context" : "The proof extends similar convergence proofs of TD(λ) by Bertsekas and Tsitsiklis (1996) and of optimistic policy iteration by Tsitsiklis (2003), and is provided in the appendix.",
      "startOffset" : 57,
      "endOffset" : 89
    }, {
      "referenceID" : 1,
      "context" : "The proof extends similar convergence proofs of TD(λ) by Bertsekas and Tsitsiklis (1996) and of optimistic policy iteration by Tsitsiklis (2003), and is provided in the appendix.",
      "startOffset" : 57,
      "endOffset" : 145
    }, {
      "referenceID" : 16,
      "context" : "εk = 0), we deduce that Watkins’ Q(λ) (e.g., Watkins, 1989; Sutton and Barto, 1998) converges a.",
      "startOffset" : 38,
      "endOffset" : 83
    }, {
      "referenceID" : 6,
      "context" : "To validate our theoretical results, we employ Retrace(λ) in an experience replay (Lin, 1993) setting, where sample transitions are stored within a large but bounded replay memory and subsequently replayed as if they were new experience.",
      "startOffset" : 82,
      "endOffset" : 93
    }, {
      "referenceID" : 6,
      "context" : "To validate our theoretical results, we employ Retrace(λ) in an experience replay (Lin, 1993) setting, where sample transitions are stored within a large but bounded replay memory and subsequently replayed as if they were new experience. Naturally, older data in the memory is usually drawn from a policy which differs from the current policy, offering an excellent point of comparison for the algorithms presented in Section 2. Our agent adapts the DQN architecture of Mnih et al. (2015) to replay short sequences from the memory (details in Appendix F) instead of single transitions.",
      "startOffset" : 83,
      "endOffset" : 489
    }, {
      "referenceID" : 0,
      "context" : "We compare our algorithms’ performance on 60 different Atari 2600 games in the Arcade Learning Environment (Bellemare et al., 2013) using Bellemare et al.",
      "startOffset" : 107,
      "endOffset" : 131
    } ],
    "year" : 2016,
    "abstractText" : "In this work, we take a fresh look at some old and new algorithms for off-policy, return-based reinforcement learning. Expressing these in a common form, we derive a novel algorithm, Retrace(λ), with three desired properties: (1) low variance; (2) safety, as it safely uses samples collected from any behaviour policy, whatever its degree of “off-policyness”; and (3) efficiency, as it makes the best use of samples collected from near on-policy behaviour policies. We analyse the contractive nature of the related operator under both off-policy policy evaluation and control settings and derive online sample-based algorithms. To our knowledge, this is the first return-based off-policy control algorithm converging a.s. to Q∗ without the GLIE assumption (Greedy in the Limit with Infinite Exploration). As a corollary, we prove the convergence of Watkins’ Q(λ), which was still an open problem. We illustrate the benefits of Retrace(λ) on a standard suite of Atari 2600 games. One fundamental trade-off in reinforcement learning lies in the definition of the update target: should one estimate Monte Carlo returns or bootstrap from an existing Q-function? Return-based methods (where return refers to the sum of discounted rewards ∑ t γ rt) offer some advantages over value bootstrap methods: they are better behaved when combined with function approximation, and quickly propagate the fruits of exploration (Sutton, 1996). On the other hand, value bootstrap methods are more readily applied to off-policy data, a common use case. In this paper we show that learning from returns need not be at cross-purposes with off-policy learning. We start from the recent work of Harutyunyan et al. (2016), who show that naive off-policy policy evaluation, without correcting for the “off-policyness” of a trajectory, still converges to the desired Q value function provided the behavior μ and target π policies are not too far apart (the maximum allowed distance depends on the λ parameter). Their Q(λ) algorithm learns from trajectories generated by μ simply by summing discounted off-policy corrected rewards at each time step. Unfortunately, the assumption that μ and π are close is restrictive, as well as difficult to uphold in the control case, where the target policy is always greedy with respect to the current Q-function. In that sense this algorithm is not safe: it does not handle the case of arbitrary “off-policyness”. Alternatively, the Tree-backup (TB) (λ) algorithm (Precup et al., 2000) tolerates arbitrary target/behavior discrepancies by scaling information (here called traces) from future temporal differences by the product of target policy probabilities. TB(λ) is not efficient in the “near on-policy” case (similar μ and π), though, as traces may be cut prematurely, blocking learning from full returns. In this work, we express several off-policy, return-based algorithms in a common form. From this we derive an improved algorithm, Retrace(λ), which is both safe and efficient, enjoying convergence guarantees for off-policy policy evaluation and – more importantly – for the control setting. Retrace(λ) can learn from full returns retrieved from past policy data, as in the context of experience replay (Lin, 1993), which has returned to favour with advances in deep reinforcement learning (Mnih ar X iv :1 60 6. 02 64 7v 1 [ cs .L G ] 8 J un 2 01 6 et al., 2015; Schaul et al., 2016). Off-policy learning is also desirable for exploration, since it allows the agent to deviate from the target policy currently under evaluation. To the best of our knowledge, this is the first online return-based off-policy control algorithm which does not require the GLIE (Greedy in the Limit with Infinite Exploration) assumption (Singh et al., 2000). In addition, we provide as a corollary the first proof of convergence of Watkins’ Q(λ) (see, e.g., Watkins, 1989; Sutton and Barto, 1998). Finally, we illustrate the significance of Retrace(λ) in a deep learning setting by applying it to the suite of Atari 2600 games provided by the Arcade Learning Environment (Bellemare et al., 2013). 1 Notation We consider an agent interacting with a Markov Decision Process (X ,A, γ, P, r). X is a finite state space, A the action space, γ ∈ [0, 1) the discount factor, P the transition function mapping stateaction pairs (x, a) ∈ X ×A to distributions over X , and r : X ×A → [−RMAX, RMAX] is the reward function. For notational simplicity we will consider a finite action space, but the case of infinite – possibly continuous – action space can be handled by the Retrace(λ) algorithm as well. A policy π is a mapping from X to a distribution over A. A Q-function Q maps each state-action pair (x, a) to a value in R; in particular, the reward r is a Q-function. For a policy π we define the operator P: (PQ)(x, a) := ∑",
    "creator" : "TeX"
  }
}