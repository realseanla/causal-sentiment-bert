{
  "name" : "1401.3431.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Compositional Belief Update",
    "authors" : [ "James Delgrande", "Yi Jin", "Francis Jeffry Pelletier" ],
    "emails" : [ "jim@cs.sfu.ca", "yij@cs.sfu.ca", "jeffpell@sfu.ca" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "A knowledge base is typically not a static entity, but rather evolves over time. New information may be added, and old or out-of-date information may be removed. A fundamental issue concerns how such change should be managed. A major body of research addresses this question via the specification of rationality postulates, or standards that a change operator should satisfy. These postulates describe belief change at the knowledge level, independent of how beliefs are represented and manipulated. There are various rationales for motivating a change in an evolving knowledge base, and these differing rationales have been seen as calling for differences in the background knowledge-level postulates. For example, one may think that some alteration in the world has occurred, with the result that we should update the knowledge base’s representation of the world in some appropriate way. Or, we may think that our previous sources of information were fallible or incomplete and that we now have better, more accurate information about the world. So, in this case we should revise our beliefs. Another motivation might be to merge already-existing stores of beliefs,\nc©2008 AI Access Foundation. All rights reserved.\nwithout giving any a priori preference to one or the other of the belief sets, but aiming to achieve a balanced resolution of conflicts. Such a merging might be used to combine the belief states of different agents, so as to come up with a joint course of action based on some sort of “all things considered” assimilation of the knowledge and preferences of the agents that are involved. And we can also imagine a linguistic reform, so that a concept (or rather, the associated word) was no longer to be used. In such a case one might say that the users forgot about this concept/word.\nThese differences in motivation have led to specific differences in the sorts of postulates that are associated with the different motivations. Initially, in the AGM approach (Alchourrón, Gärdenfors, & Makinson, 1985; Gärdenfors, 1988), standards for belief revision and contraction functions were given, wherein it was assumed that a knowledge base is receiving information concerning a static1 domain, and that it is the increased amount or accuracy of information that is responsible for the changes in the knowledge base. Subsequently, Katsuno and Mendelzon (1992) explored a distinct notion of belief change, with functions for belief update and erasure, wherein an agent changes its beliefs in response to what it perceives as changes in the environment. The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a “merged” knowledge base that best represents the information in a set of other knowledge bases. One use for this was thought to be a way of determining a course of action that best represents the “desires” and “goals” of a divergent set of knowledge bases, thereby forming a group-level, all-things-considered knowledge base. The formal properties of merging have been discussed in previous works (e.g., see Lin & Mendelzon, 1998; Konieczny & Pino Pérez, 1998; Everaere, Konieczny, & Marquis, 2007).\nThe distinctions between the formal properties of the different types of change were brought out in each of the papers after the initial AGM publications; for instance, Katsuno and Mendelzon (1992) compared update with revision; Konieczny and Pino Pérez (1998) compared merging with revision; Nayak et al. (2006) compared forgetting with update. Some of the postulates suggested by the initial authors of these different conceptions of belief change have been challenged by other writers. And since our own approach towards update conflicts with some of Katsuno and Mendelzon’s postulates, we wish to show that\n1. Note that “static” does not imply “with no mention of time”. For example, one could have information in a knowledge base about the state of the world at different points in time, and revise information at these points in time. Thus, belief revision is also applicable to the situation where an agent investigates a past event and tries to reason about what was the real state of the world when this event took place. Further considerations on how revision and update are interrelated are in the work of Lang (2006). 2. Nayak, Chen, and Lin (2006) described this difference thus: “While belief erasure purports to answer the question ‘What should I believe if I can no longer support the belief that the cook killed Cock Robin?’, forgetting purports to answer the question ‘What should I believe if Killing was a concept not afforded in my language?’.”\nthis is not, by itself, a reason to reject our theory — every theory has met with objurgation concerning its foundational postulates.\nAlthough our focus in this paper is with update — and hence with the postulates given by Katsuno and Mendelzon (1992) and the objections related to these postulates — we believe that considerations similar to the ones we bring forward in this arena would hold with respect to the other sorts of belief change postulates. That is, we think that the rationale we have for imposing a compositionality constraint on belief update should be brought to bear on the cases of belief revision, belief merging, and forgetting.\nThe knowledge level specifications of these types of belief change allow for different ways to implement any of them. Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al., 2006). These approaches are formulated in terms of the distance between models of the knowledge base and models of a sentence for revision or update. In general there has been less work dealing with systems that may be readily implementable (but see, e.g., Williams, 1996; Delgrande & Schaub, 2003).\nIn this paper we develop a specific update operator where the operator is intended to be compositional, in that an update ψ ⋄µ can be expressed recursively in terms of the syntactic structure of µ. Thus, if a knowledge base is to be updated by a disjunction µ = a ∨ b, the idea is that this update will be a function of the update by a in a certain combination with the update by b. The update of the knowledge base by a conjunction µ = a ∧ b will also be a function (a different one) of the update by a in combination with the update by b. The goal is to arrive at an operator whose results are intuitive, in that its definition is based on a recursive decomposition of a formula; hence the (generally abstract) notion of update will be anchored in part in a more familiar computational setting. Second, the hope is that these operators will be efficiently implementable, at least in some cases, by exploiting restrictions to the syntactic form of the formula. The focus here is on the form of the formula for update; presumably the approach described may be combined with one in which the knowledge base is itself divided into relevant and irrelevant parts for an update (Parikh, 1999).\nThese goals are generally realised. First, the operators have reasonable properties: many of the Katsuno and Mendelzon benchmark properties are satisfied, including those deemed essential by Herzig and Rifi (1999). While we don’t obtain full irrelevance of syntax, we do obtain weaker results in this regard; as well we show how irrelevance of syntax can be obtained by restricting the syntactic form of the sentence for update. The approach is also related to other approaches in the literature, and hence serves to establish some links between approaches. In fact, the family of compositional update operators obtained by imposing various syntactic restrictions can be regarded as constituting a family of operators of which Winslett’s standard semantics makes up the most basic nontrivial approach. As well, the general approach to update presented here can capture the forget operator (Lin & Reiter, 1994; Lang et al., 2003; Nayak et al., 2006), and so in a certain sense can be regarded as generalizing forget. We also define a revision operator using the obvious definition for such an operator; it proves to be the case that this operator corresponds with the revision operator in the work of Satoh (1988).\nThe approach leads to a straightforward algorithm for implementing these operators. This algorithm is efficient, compared to the model-based definition of this and other distancebased operators. For a knowledge base in disjunctive normal form, the size of the knowledge base contributes only a linear factor to the overall complexity. As well, further efficiency is obtained when the size of the input sentence is bounded by a constant.\nThe next section reviews belief revision, update, forgetting, and merging, and describes two specific approaches to update. The section following describes our approach, after which, in the next section, we give a discussion and analysis. The last section contains concluding remarks; proofs of theorems are given in an Appendix."
    }, {
      "heading" : "2. Background",
      "text" : "As described, our goal is to introduce a compositional method of carrying out belief change. But since part of our overall goal also is to examine the place of a compositional belief change operation in all the various arenas where this can take place, we start by outlining some of the details for each of these different conceptions that motivate belief change, along with some motivational considerations and some areas where the different types of belief change part ways. These operators were introduced implicitly, by means of a set of postulates that any legitimate such operator was required to obey. However, in all these areas there has been some dispute concerning the correctness of the various postulates, and we mention some of these as we proceed, since our own approach in the case of update does not obey all the standard postulates for update. We start with the historically earlier case of revision before moving to our central concern of update. These are followed by short expositions concerning forgetting and merging."
    }, {
      "heading" : "2.1 Formal Preliminaries",
      "text" : "We consider a propositional language L, over a finite set of atoms, that is, propositional letters, P = {⊤, a, b, c, . . . }, and truth-functional connectives ¬, ∧, and ∨. Where convenient, ⊃ and ≡ are also used, and are considered as being introduced by definition. We use ↔ for logical equivalence; that is, α ↔ β is an abbreviation for ⊢ (α ≡ β). Lits is the set of literals P ∪ {¬l | l ∈ P}. In particular, ¬⊤ is also denoted as ⊥. A set of literals Γ is consistent just if ⊥ 6∈ Γ and for no atom p ∈ P do we have p,¬p ∈ Γ. For a literal l, we use l to denote ¬l if l ∈ P, or l′ ∈ P if ¬l′ = l. Similarly, for a set of literals Γ, we use Γ to denote the set {l | l ∈ Γ}. The expression atom(µ) denotes the set of atoms in formula µ. An interpretation ω of L is a maximal consistent set of literals, i.e., ⊤ ∈ ω and for every other p ∈ P precisely one of p ∈ ω, ¬p ∈ ω holds. A model of a sentence µ is an interpretation that makes µ true, according to the usual definition of truth. Mod(µ) denotes the set of models of sentence µ. We also make use of the notation ModL(µ) to denote the set of models of sentence µ over the language of µ (that is to say, over the language atom(µ).) For interpretation ω we write ω |= µ to mean µ is true in ω. For interpretation ω and set of literals Γ, we define ω ↓ Γ = ω \\ (Γ ∪ Γ). That is, ω ↓ Γ is the set of literals in ω but containing neither l nor l for each l ∈ Γ. For example, if ω = {a,¬b,¬c} then ω ↓ {b,¬c} = {a}.\nWe denote the negation-normal form (in which negation applies to atoms only) of a sentence µ by nnf (µ). Similarly, we denote the conjunctive normal form and the disjunctive\nnormal form of µ by cnf (µ) and dnf (µ) respectively.3 For a set of sentences Γ (which will always be finite), we use ∨ Γ to denote the disjunction and ∧\nΓ the conjunction of the sentences in Γ. Proofs will often be based on the structure of a formula, specifically on the depth of a formula; for formula µ, the depth of µ, depth(µ) is the maximum nesting of connectives in µ. Hence depth(¬a ∨ (b ∧ ¬c)) = 3.\nLater we make use of the notion of the prime implicants of a sentence. A consistent set of literals Γ is a prime implicant of µ iff: Γ ⊢ µ and for any Γ′ ⊂ Γ we have Γ′ 6⊢ µ.4 In the limiting case where ⊢ µ, we take the (sole) prime implicant of µ to be {⊤}."
    }, {
      "heading" : "2.2 Belief Revision and Contraction",
      "text" : "In the seminal approach of AGM (Alchourrón et al., 1985), postulates are proposed to constrain belief revision. In this approach, a knowledge base K is assumed to be a belief set, a set of sentences closed under logical consequence. The revision of a belief set by a formula, K ∗φ, is a new belief set in which the formula φ is believed. The interesting case is that in which ¬φ is initially believed, and so to attain a consistent belief set (assuming that φ is satisfiable), some beliefs have to be dropped. Exactly which beliefs must be dropped is not stipulated in the AGM approach; however, constraints in the form of postulates that govern what are seen as legitimate revision operators are given. In contrast, in their development of belief update Katsuno and Mendelzon (1992) represented the knowledge base by a formula in some language L. Hence, in this paper we also express things in terms of postulates phrased in terms of formulas, rather than belief sets.\nThe following R-postulates comprise Katsuno and Mendelzon’s reformulation of the AGM revision postulates, where ∗ is a function from L× L to L.\n(R1) ψ ∗ µ ⊢ µ.\n(R2) If ψ ∧ µ is satisfiable, then ψ ∗ µ↔ ψ ∧ µ.\n(R3) If µ is satisfiable then ψ ∗ µ is also satisfiable.\n(R4) If ψ1 ↔ ψ2 and µ1 ↔ µ2 then ψ1 ∗ µ1 ↔ ψ2 ∗ µ2.\n(R5) (ψ ∗ µ) ∧ φ ⊢ ψ ∗ (µ ∧ φ).\n(R6) If (ψ ∗ µ) ∧ φ is satisfiable then ψ ∗ (µ ∧ φ) ⊢ (ψ ∗ µ) ∧ φ.\nA dual operation, called contraction is also defined, in which a formula is deleted from the knowledge base. This operation can be seen as governed by the C-postulates, again using a Katsuno and Mendelzon formulation in terms of a function from L× L to L.\n3. Of course for formula µ, there are many different but logically equivalent ways to express cnf (µ) and dnf (µ). We assume a fixed procedure for converting to cnf (or dnf), by converting to negation normal form, and then distributing disjunctions over conjunctions (or vice versa for dnf), hence justifying the use of the term the conjunctive (disjunctive) normal form of a formula, rather than a (disjunctive) normal form. 4. The notion of prime implicant should not be confused with the dual notion of a prime implicate. A prime implicate of a formula µ is a clause, or disjunction of literals, ρ, such that µ ⊢ ρ but for any proper subclause ρ′ of ρ, we have µ 6⊢ ρ′.\n(C1) ψ ⊢ ψ − µ.\n(C2) If ψ 6⊢ µ then ψ − µ↔ ψ.\n(C3) If 6⊢ µ then ψ − µ 6⊢ µ.\n(C4) If ψ1 ↔ ψ2 and µ1 ↔ µ2 then ψ1 − µ1 ↔ ψ2 − µ2.\n(C5) (ψ − µ) ∧ µ ⊢ ψ.\nRevision and contraction are related in the AGM approach by what have come to be known as the Levi and Harper identities. They may be expressed as follows (using formulas rather than belief sets):\nψ ∗ µ ↔ (ψ − ¬µ) ∧ µ (1)\nψ − µ ↔ ψ ∨ (ψ ∗ ¬µ). (2)\nThe first case asserts that revising ψ by µ corresponds to the contraction of ψ by ¬µ conjoined with µ. The second asserts that contracting µ from ψ corresponds to the disjunction of ψ with the result of ψ updated by ¬µ.\nAlthough this makes a nice picture, there have been various objections to some of the presuppositions of the AGM model (e.g., the representation of belief states by theories, that is, by infinite sets of formulas) and to some of the postulates that are said to govern the operations of revision and contraction (especially (C5), the postulate of “recovery”). Issues involved with (C5) have been discussed by Fuhrmann, 1991; Tennant, 1997; Hansson & Rott, 1998; Rott & Pagnucco, 1999, and others."
    }, {
      "heading" : "2.3 Belief Update and Erasure",
      "text" : "The account of revision and contraction described in the preceding subsection is usually seen as applying most straightforwardly to the case where one has a store of information about “an unchanging, static world” but where new information about that world is received by the agent, thereby forcing a change in the representation of this “unchanging, static world.” But a different picture was put forward by Katsuno and Mendelzon (1992), where there was a “changing, dynamic world”. In such a conception, the new information that is gathered by the agent reflects the idea that the world is different than it was when the knowledge base was previously constructed. The sorts of changes to the knowledge base that are required by this type of new information are seen as different from the sorts envisaged when it is thought that changes to the knowledge base are only going to make its contents successively more accurate. Although this simplistic distinction is not all there is to the differences between the two pictures (as we mentioned in Footnote 1), it has led to a large body of work that does point to a different conception. Distinct operations that change knowledge bases have been proposed: update, which makes changes to the knowledge base given information concerning a change in the state of the world, and erasure, for removing out-of-date information.\nA formula is said to be complete just if it implies the truth or falsity of every other formula. In the approach of (Katsuno & Mendelzon, 1992), update is a function ⋄ from L× L to L satisfying the following U-postulates.\n(U1) ψ ⋄ µ ⊢ µ.\n(U2) If ψ ⊢ µ then (ψ ⋄ µ) ↔ ψ.\n(U3) If µ and ψ are satisfiable then so is ψ ⋄ µ.\n(U4) If ψ1 ↔ ψ2 and µ1 ↔ µ2 then (ψ1 ⋄ µ1) ↔ (ψ2 ⋄ µ2).\n(U5) (ψ ⋄ µ) ∧ φ ⊢ ψ ⋄ (µ ∧ φ).\n(U6) If ψ ⋄ µ1 ⊢ µ2 and ψ ⋄ µ2 ⊢ µ1 then (ψ ⋄ µ1) ↔ (ψ ⋄ µ2).\n(U7) If ψ is complete then (ψ ⋄ µ1) ∧ (ψ ⋄ µ2) ⊢ ψ ⋄ (µ1 ∨ µ2).\n(U8) (ψ1 ∨ ψ2) ⋄ µ↔ (ψ1 ⋄ µ) ∨ (ψ2 ⋄ µ)\nThese postulates are not, however, uncontentious. Herzig and Rifi (1999) discussed the plausibility of the postulates given; they assert that U2, U5, and U6 are undesirable, while U7 is unimportant. This leaves (according to the authors) U1, U3, U4, and U8 as being desirable.\nErasure is also defined, in a manner analogous to the way we described how contraction was related to belief revision. In both cases, some specified formula is not believed in the result. The erasure of µ from ψ is denoted ψ µ, and the formula µ is not believed in the resulting state. As with all our other operations, there is a set of postulates characterizing erasure (given in Katsuno & Mendelzon, 1992). Update and erasure are also interdefinable by means of identities, analogous to the Levi and Harper identities, which related revision and contraction:\nψ ⋄ µ ↔ (ψ ¬µ) ∧ µ (3)\nψ µ ↔ ψ ∨ (ψ ⋄ ¬µ). (4)\nThe first case asserts that update by µ corresponds to erasing ¬µ along with the conjunction with µ. The second asserts that erasing µ from ψ corresponds to disjoining ψ with the result of ψ updated by ¬µ.\nThere have been various specific update (and revision) operators proposed based on the distance between interpretations. We focus on two update operators, both due to Winslett. The first, the Possible Models Approach (PMA) of (Winslett, 1988) is a well-known example of an update operator satisfying the Katsuno and Mendelzon update postulates. The second, the standard semantics of (Winslett, 1990) is a weak (in fact, arguably the weakest reasonable) approach to update. We denote these operators by ⋄pma and ⋄ss respectively.\nFor ψ ⋄pma µ, we have that, for each interpretation w of ψ, ⋄pma selects from the interpretations of µ those that are “closest” to w. The update is determined by the set of these closest interpretations. The notion of “closeness” between two interpretations w1 and w2 is the Hamming distance, given as follows:\nDefinition 1 diff (w1, w2) = The set of all propositional letters on which w1 and w2 differ.\nInterpretation w1 is not less close to w than w2, w1 ≤w w2, just if diff (w,w1) ⊆ diff (w,w2). It follows that ≤w is a partial order on interpretations. The ≤w-minimal set with respect to µ is designated Min(Mod(µ), w). ¿From this we can specify the PMA update operator:\nMod(ψ ⋄pma µ) = ⋃\nw∈Mod(ψ)\nMin(Mod(µ), w).\nThe update operator ψ ⋄ss µ is defined so that for each model of ψ, those models of µ that retain the truth values of atoms not in µ are chosen. That is:\nMod(ψ ⋄ss µ) = ⋃\nw1∈Mod(ψ)\n{w2 ∈Mod(µ) | diff (w1, w2) ⊆ atom(µ)}\nThe operator ψ ⋄ss µ is the weakest “reasonable” update operator in the following sense (Winslett, 1990): First, for an update ψ ⋄ss µ, µ is true in every model of ψ ⋄ss µ. Second, every model of ψ over the language excluding atoms in µ is a model of ψ ⋄ss µ (again over this restricted language). Moreover, ψ ⋄ss µ consists of the maximal set of interpretations that satisfies the preceding two properties. Hence in the update of ψ by µ, the truth values of atoms in ψ but not in µ are unaffected by the update.\nExample 1 (Katsuno & Mendelzon, 1992) Let L = {b,m} be the language of discourse. Let ψ = (b∧¬m)∨ (¬b∧m), and µ = b. The interpretations of ψ are w1 = (¬b,m), w2 = (b,¬m); and the interpretations of µ are: w ′ 1 = (b,m), w ′ 2 = (b,¬m). Thus diff (w1, w ′ 1) = {b} and diff (w1, w ′ 2) = {b,m}, hence w ′ 1 ≤w1 w ′ 2 and w ′ 2 6≤w1 w ′ 1, so Min(Mod(µ), w1) = {w ′ 1}. Similarly, Min(Mod(µ), w2) = {w ′ 2}. Hence, (ψ ⋄pma µ) ↔ b. The same result obtains for ⋄ss.\nFor concreteness, take b to mean “the book is on the floor”, and m to mean “the magazine is on the floor”. So ψ means that either the book or the magazine is on the floor, but not both. A robot is ordered to put the book on the floor. Intuitively, at the end of this action the book will be on the floor, and the location of the magazine will be unknown. Both operators give this result.\nExample 2 Let ψ = (¬b ∧ ¬m) and µ = (b ∨m). Then (ψ ⋄pma µ) ↔ (b ≡ ¬m), whereas (ψ ⋄ss µ) ↔ (b ∨m).\nHere, neither the book nor the magazine is on the floor. The robot is ordered to put at least one of them on the floor. According to the ⋄pma operator, exactly one will be on the floor after this action, while according to the ⋄ss operator, at least one will be on the floor."
    }, {
      "heading" : "2.4 Forget",
      "text" : "While our focus is on a specific approach to update and erasure, we also relate our approach to that of the forget operator. The notion of forgetting goes back to George Boole (1854), though it has received more recent attention in Artificial Intelligence by, e.g., Lin & Reiter, 1994; Lin, 2001; Lang et al., 2003; Nayak et al., 2006. In a propositional context, to forget an atom, or set of atoms, is to remove all information concerning the atom or set of atoms.\nIt has been suggested (in Nayak et al., 2006) that forgetting corresponds to the removal of literals or atoms from the language of discourse in the case of propositional forgetting (i.e., 0-place predicate forgetting). In the more general case, it is seen as removing a predicate or relation from the language, and hence removing any further consequences that might have been due to this predicate’s presence.\nLet ψ[p/q] denote the formula ψ where all occurrences of atom p are replaced by q. Then the usual definition for forgetting (again, going back to Boole) atom p in ψ is given by ψ[p/⊤] ∨ ψ[p/⊥]. In order to forget a set of atoms Γ, one takes the disjunction of the substitution of all 2|Γ| combinations of ⊤, ⊥ for elements of Γ.\nWe have the following definitions. For single atoms we basically follow Nayak et al. (2006); for sets of atoms we use the definition from (Lin & Reiter, 1994). To begin, the p-dual of an interpretation ω is the interpretation like ω but where the truth value assigned to p is changed to its negation. A set of interpretations is closed under p-duals just if, for any interpretation ω in the set, the p-dual of ω is also in the set.\nDefinition 2 Given a set of interpretations Ω and atom p, the operator ⊎\n(Ω, p) yields the least set of interpretations containing Ω and closed under p-duals.\nGiven this, we can define forget for an atom and set of atoms, where the latter is defined recursively in terms of the former:\nDefinition 3 Basis Case: Let ψ be a formula and p an atom. Then forget of p with respect to ψ is given by:\nMod(ψ ⊙ p) = ⊎ (Mod(ψ), p)\n= Mod(ψ[p/⊤] ∨ ψ[p/⊥]).\nInductive Case: Let ψ be a formula and Γ = {p1, . . . , pn} a set of atoms. Then forget of Γ with respect to ψ is given by:\nψ ⊙ Γ = (ψ ⊙ (Γ \\ {pn}))⊙ pn.\nFor example, a ∧ (b ∨ c)⊙ a↔ ¬a ∧ (b ∨ c)⊙ a↔ b ∨ c. (Given a knowledge base that has stored that Alberta is in Canada and also that either Vancouver is in British Columbia or Charlottetown is in Ontario, forgetting that Alberta is in Canada would yield that either Vancouver is in British Columbia or Charlottetown is in Ontario. This would be the same result if the initial knowledge base had that Alberta was not in Canada, but that either Vancouver is in British Columbia or Charlottetown is in Ontario.) For another example, (a ∨ b) ⊙ a ↔ ⊤. This last example illustrates that forget is distinct from erasure, since a property of erasure is that if ψ does not imply µ then (ψ µ) ↔ ψ (Katsuno & Mendelzon, 1992)."
    }, {
      "heading" : "2.5 Belief Merging",
      "text" : "Merging differs formally from the preceding three pictures of how knowledge bases are changed. The preceding operators had a knowledge base and a sentence that may need to occasion a change in the knowledge base. If one rephrases this in terms of agents, these\nother types of change postulate an agent, with a store of beliefs, who is now faced with a new belief that needs to be accommodated. In the case of merging, however, we start with many belief sets that need all to be dealt with in some way that yields “the best, overall” single belief state. In terms of agents, again, we have here a number of agents, each with a belief set, and we are trying to construct that belief set which best represents the total beliefs of the community of agents. So, rather than being a function that maps a belief set and a sentence onto a belief set, it is instead a function that maps a number of belief sets into a single one. Following our earlier practice of representing belief sets by a single formula (in the manner of Katsuno & Mendelzon, 1992), we can see that the earlier rationales for belief change envision it as a function L × L → L, whereas merging envisions a function L×L× . . .×L→ L. Note that the general case allows for some of the knowledge bases on this list to be identical to one another, thus the list is actually a multi-set (bag).\nThe goal in merging, then, is to construct, from a finite list of knowledge bases E, some appropriate, single “merged” knowledge base. Despite this formal difference from the earlier three types of belief change, we nevertheless include a discussion here because of the conceptual similarities that hold between merging and any of the other versions of belief change. Indeed, it seems plausible to suggest that merging might be definable in terms of the others, or maybe that it is some sort of generalization of the others. In these cases, our considerations about compositionality of belief change operators may be relevant.\nDefinition 4 A knowledge set is a multi-set (bag) of knowledge bases.\nDefinition 5 If E is a knowledge set, then ∧\nE is the conjunction of the formulas representing all the knowledge bases that are in E.\nKonieczny and Pino Pérez (1998, 2002) proposed the following M-principles to govern all merging operators. A merge function △ is a function from a knowledge set E to a knowledge base △(E) satisfying the following postulates, where ⊔ is multiset union.5\n(M1) △(E) is consistent\n(M2) If ∧ E is consistent then △(E) = ∧ E.\n(M3) If E1 and E2 are knowledge sets such that E1 ↔ E2, then △(E1) ↔ △(E2)\n(M4) If K1 and K2 are knowledge bases that are not mutually consistent, then △(K1 ⊔ K2) 6⊢ K1\n(M5) △(E1) ∧△(E2) ⊢ △(E1 ⊔ E2)\n(M6) If △(E1) ∧△(E2) is consistent, then △(E1 ⊔ E2) ⊢ △(E1) ∧△(E2)\nSome of these merging postulates have been contested: For example, Meyer (2000) argued that M4 and M6 should be rejected. (He argues this on the grounds that there are many plausible merging operations that do not obey these postulates).\n5. For simplicity, we list the postulates of (Konieczny & Pino Pérez, 1998), which do not include integrity constraints.\nA natural method for determining whether a formula φ should be in the merged knowledge base is to determine whether it appears in the majority of the members of the knowledge set that is being merged (“the merged knowledge base should allow the opinion of the majority to prevail”). Liberatore and Schaerf (1998) introduced the method of arbitration, whereby the goal is to adopt as many different opinions as possible from the members of the knowledge set (“try to take as many differing opinions as possible into account”). Konieczny and Pino Pérez (1998) proved that there is no arbitration operator (at least, not of the sort that they characterize) that obeys M1 – M6.6 The interplay between various merging operations and the ability of an agent to hide, lie, or otherwise camouflage its preferences from other agents as they try to construct a merged knowledge base has been surveyed in Everaere et al. (2007)."
    }, {
      "heading" : "3. The Approach",
      "text" : "This section discusses our approach. Following intuitions and motivation of the formal approach, we introduce compositional update and, subsequently, erasure. We also consider the notion of compositional belief revision, but conclude that, at least with respect to our specific approach, there is no separate, distinct, notion of compositional revision. Analysis of properties of these operators is covered in the next section."
    }, {
      "heading" : "3.1 Intuitions",
      "text" : "Our goal is to define update operators in a compositional fashion so that, for updating by formula µ, update is defined in terms of the syntactic components of µ. The general idea behind update is that for ψ ⋄ µ, each model of ψ is replaced by the “closest” model(s) in µ (Katsuno & Mendelzon, 1992). In our approach, the notion of “close” for each model of ψ is determined in part by the syntactic structure of µ. That is, µ is recursively decomposed; the resulting (base case) literals are used to determine models of the update by sets of literals; and the results are combined depending on the connective(s) in µ.\nConsider how this may be carried out. We are given a knowledge base ψ and a sentence µ, and we wish to determine a new knowledge base where µ is believed. For a base case, µ = l is a literal, and we wish to update the knowledge base ψ by literal l. If ψ implies l then we need do nothing. If ψ does not imply l, then we wish to arrive at a knowledge base in which l is believed. That is, we want to change the knowledge base only enough so that it entails l. Clearly, we can do this by replacing each model ω of ψ by the interpretation ω′ = (ω ↓ {l}) ∪ {l}.7 Thus, we would have that every resulting interpretation entails l.\nConsider next updating a knowledge base ψ by a conjunction of literals µ = l1 ∧ l2. A knowledge base in which l1∧l2 is believed will, obviously, be one in which every model of the knowledge base entails both l1 and l2. We carry this out by replacing each interpretation ω ∈ Mod(ψ) with an interpretation ω′ = (ω ↓ {l1, l2}) ∪ {l1, l2}. There is a limiting case that needs to be taken care of, where l1 is l2. In this situation, there is no interpretation in which l1, l2 are true, and in this case ω\n′ does not exist, reflecting an attempt to update by an inconsistent formula.\n6. This forms a part of the rationale for Meyer (2000, 2001) to deny M4 and M6. 7. To be clear, if ω |= l then ω′ = ω; and if ω 6|= l then ω′ is like ω but with l replacing its complement.\nTo update a knowledge base ψ by a disjunction of literals µ = l1 ∨ l2, we want to modify models of ψ so that at least one of l1 or l2 is true. Consider ω ∈Mod(ψ) such that ω 6|= l1 ∨ l2. Then ω1 = (ω ↓ {l1}) ∪ {l1} is an interpretation that involves the least change to ω in which l1 is true, while ω2 = (ω ↓ {l2})∪ {l2} does the same for l2. Arguably then ω should be replaced by ω1 and ω2.\nLast, we generalize the above considerations to deal with arbitrary formulas. So to update by a disjunction of formulas, we recursively determine the update given by the individual disjuncts and return the union of the resulting sets of interpretations."
    }, {
      "heading" : "3.2 A Compositional Update Operator",
      "text" : "Based on the preceding intuitions, we define an update operator ⋄c. We begin with some preliminary definitions. In the following, UL is a function from an interpretation ω and finite set of formulas Γ to a set of interpretations. Informally, ω is a model of the knowledge base and Γ is a set of formulas resulting from the partial decomposition of a formula for update. The value of UL is the set of interpretations closest to ω, according to Γ. To ease notation, in the case of a single formula we sometimes write UL(ω, µ) for UL(ω, {µ}).\nDefinition 6 For interpretation ω and finite Γ ⊆ L, define UL(ω,Γ) as follows:\n1. If Γ ⊆ Lits then\nUL(ω,Γ) =\n{\n{(ω ↓ Γ) ∪ Γ} if Γ 6⊢ ⊥ ∅ otherwise\n2. If Γ = {α ∧ β} ∪ Γ′ then UL(ω,Γ) = UL(ω, {α, β} ∪ Γ′)\n3. If Γ = {α ∨ β} ∪ Γ′ then UL(ω,Γ) = UL(ω, {α} ∪ Γ′) ∪ UL(ω, {β} ∪ Γ′)\n4. If Γ = {¬(α ∨ β)} ∪ Γ′ then UL(ω,Γ) = UL(ω, {¬α,¬β} ∪ Γ′)\n5. If Γ = {¬(α ∧ β)} ∪ Γ′ then UL(ω,Γ) = UL(ω, {¬α} ∪ Γ′) ∪ UL(ω, {¬β} ∪ Γ′)\n6. If Γ = {¬¬α} ∪ Γ′ then UL(ω,Γ) = UL(ω, {α} ∪ Γ′)\nIt is worth noting that the recursion steps of the above definition resemble closely the procedure which we use to convert a formula to its disjunctive normal form. Before defining update in terms of this operator, we first investigate some of its properties. Foremost, we need to show that UL is well-defined. That is, in specifying UL(ω,Γ), the definition is phrased in terms of some member of Γ; it needs to be shown that the order in which elements are “selected” in the recursion does not affect the result.\nTheorem 1 UL is well-defined.\nThe next two results reflect the influence of the structure of a formula on the recursive decomposition in the definition of UL.\nTheorem 2 UL(ω,Γ) = UL(ω,nnf ( ∧ Γ)).\nTheorem 3 UL(ω,Γ) = UL(ω, dnf ( ∧ Γ)).\nNote that a similar result does not extend to conjunctive normal form. A counterexample is given by the following:\nUL(ω, {a ∨ (b ∧ c)}) = UL(ω, {a}) ∪ UL(ω, {b, c})\n6= UL(ω, {a}) ∪ UL(ω, {a, c}) ∪ UL(ω, {b, a}) ∪ UL(ω, {b, c})\n= UL(ω, {a, a ∨ c}) ∪ UL(ω, {b, a ∨ c})\n= UL(ω, {(a ∨ b), (a ∨ c)})\n= UL(ω, {(a ∨ b) ∧ (a ∨ c)}).\nWe consider next a couple of fundamental properties of UL:\nTheorem 4 For every µ ∈ Γ and w′ ∈ UL(ω,Γ) we have w′ |= µ.\nTheorem 5 UL(ω,Γ) = ∅ iff Γ ⊢ ⊥.\nWe next define our update operator directly in terms of UL.\nDefinition 7\nMod(ψ ⋄c µ) = {ω ′ | ω′ ∈ UL(ω, {µ}), ω ∈Mod(ψ)}.\nRecall Example 1 in which µ = b and ψ = (b∧¬m)∨ (¬b∧m). We have that Mod(ψ ⋄c µ) = {ω′ | ω′ ∈ UL(ω, {µ}), ω ∈ Mod(ψ)} = {(ω ↓ {b}) ∪ {b} | ω ∈ Mod(ψ)}. Thus, Mod(ψ ⋄c µ) = {{b,¬m}, {b,m}}, and so (ψ ⋄c µ) ↔ b. This is the same result as we obtain with both Winslett’s approaches.8\nFor Example 2, where ψ = ¬b ∧ ¬m and µ = (b ∨ m), we obtain Mod(ψ ⋄c µ) = {{b,¬m}, {¬b,m}}. In this case, our update operator behaves the same as ⋄pma, but differently from ⋄ss.\nWe can similarly define an erasure operator via UL. To erase µ from ψ, and in analogy to the Harper Identity, one can update by ¬µ and add the result to ψ. Thus:\nDefinition 8\nMod(ψ cµ) =Mod(ψ) ∪ {ω ′ | ω′ ∈ UL(ω, {¬µ}), ω ∈Mod(ψ)}.\nWe get the results:\nTheorem 6\nψ ⋄c µ ↔ (ψ c¬µ) ∧ µ\nψ cµ ↔ ψ ∨ (ψ ⋄c ¬µ).\n8. We note however that these approaches differ. Specifically, the PMA update operator satisfies all of the KM postulates, whereas our operator does not; see Section 4 for details."
    }, {
      "heading" : "3.3 Erasure",
      "text" : "In Definition 8 we defined a dual to update, called erasure, directly in terms of UL. We can equally well define a function analogous to UL, call it EL, to directly define an erasure operator from first principles. We do this now, toward such a definition of erasure. Briefly, our motivation is: if we want to erase µ as a consequence of ψ, then semantically we want to add interpretations to the models of ψ. If µ corresponds to a single literal, then for each model of ψ we would want to add an interpretation in which l was replaced by l̄. If µ corresponds to a conjunction, then µ can be erased by erasing either of the conjuncts; if µ corresponds to a disjunction, then to erase µ both disjuncts must be erased. By continuing in this fashion we obtain the following definition:\nDefinition 9 For interpretation ω and finite Γ ⊆ L, define EL(ω,Γ) as follows:\n1. If Γ ⊆ Lits then\nEL(ω,Γ) =\n{\n{(ω ↓ Γ) ∪ Γ} if ∨\nΓ 6⊢ ⊤ ∅ otherwise\n2. If Γ = {α ∧ β} ∪ Γ′ then EL(ω,Γ) = EL(ω, {α} ∪ Γ′) ∪ EL(ω, {β} ∪ Γ′)\n3. If Γ = {α ∨ β} ∪ Γ′ then EL(ω,Γ) = EL(ω, {α, β} ∪ Γ′)\n4. If Γ = {¬(α ∨ β)} ∪ Γ′ then EL(ω,Γ) = EL(ω, {¬α} ∪ Γ′) ∪ EL(ω, {¬β} ∪ Γ′)\n5. If Γ = {¬(α ∧ β)} ∪ Γ′ then EL(ω,Γ) = EL(ω, {¬α,¬β} ∪ Γ′)\n6. If Γ = {¬¬α} ∪ Γ′ then EL(ω,Γ) = EL(ω, {α} ∪ Γ′)\nThe following results are analogous to Theorems 2 and 3; note the occurrence of cnf in Theorem 8, in contrast to dnf in Theorem 3.\nTheorem 7 EL(ω,Γ) = EL(ω,nnf ( ∧ Γ)).\nTheorem 8 EL(ω,Γ) = EL(ω, cnf ( ∧ Γ)).\nWe can now directly define an erasure operator ′c in terms of EL:\nDefinition 10 Mod(ψ ′c µ) =Mod(ψ) ∪ {ω ′ | ω′ ∈ EL(ω, {µ}), ω ∈Mod(ψ)}\nUnsurprisingly, this notion of erasure and that given in Definition 8 are equivalent. We show this by first establishing the following result:\nLemma 1 For interpretation ω and Γ ⊆ L, we have EL(ω,Γ) = UL(ω, {¬ ∧ Γ})\n¿From this, it follows that our notions of erasure as given via the Harper Identity, and by direct definition via Definition 9 coincide:\nTheorem 9 ψ cµ↔ ψ ′ c µ.\nHence we just use the symbol c for erasure. As a corollary, Theorem 9 also establishes the well-definedness of ′c . 9\n9. That is, since UL is well-defined (Theorem 1), so is c (Definition 8) and hence so is ′ c by the above\nequivalence."
    }, {
      "heading" : "3.4 Revision",
      "text" : "In this section we consider extending the compositional approach to belief revision. To begin, it might be pointed out that there is nothing about the underlying motivation that makes ⋄c an update operator, and this point suggests that ⋄c might also be regarded as a revision operator, albeit with weak properties. However, regardless of intuitions, the recursive decomposition implicit in Definition 6 yields an operator with update-like properties, in that for sentence for update µ, one effectively deals with the models of the disjuncts in dnf (µ). For revision, in contrast, the intuition is that one deals with models of µ that are (in some sense) closest to those of the knowledge base ψ. Hence, the operator ⋄c is not really appropriate as a revision operator.\nThis suggests a possibly-feasible approach to defining compositional revision: To define a revision ψ∗µ, one first uses the operator ⋄c to find a candidate set of models of µ, and then employs some distance function to determine the subset of these models that are closest to models of ψ as a whole. That is, for formulas ψ, µ, an update of ψ by µ is defined (in one fashion or another) with respect to all the models of ψ. For revision in contrast, a definition of the revision of ψ by µ makes reference to only a subset of the models of ψ, those that are closest (in some sense) to the models of µ. In this sense then, update is a logically weaker operator than revision. Thus a revision operator can be defined with respect to ψ and µ by first applying some (compositional) update operator to get a candidate set of models of µ. This set can then be “filtered”, by removing those models that are not of minimal distance to the closest models of ψ. So depending on the notion of distance employed, one might expect to obtain different revision operators for a given compositional update operator.\nThere are two common notions of distance that are used for model-based belief change, one based on set containment and the other on cardinality. In the first case, for formulas α, β, define\n∆min(α, β) = min⊆({M1∆M2 |M1 ∈Mod(α),M2 ∈Mod(β)}),\nwhere for sets A and B, A∆B is the symmetric difference of A and B. Satoh’s (1988) revision operator ψ ∗S µ is defined as follows.\nDefinition 11\nMod(ψ ∗S µ) = {w ′ ∈Mod(µ) | ∃w ∈Mod(ψ), w∆w′ ∈ ∆min(ψ, µ)}.\nFor example, let ψ = a∧b∧c and let µ = ¬a∨(¬b∧¬c). Then ψ∗Sµ = (¬a∧b∧c)∨(a∧¬b∧¬c).\nWe can define a corresponding compositional revision operator as follows:\nDefinition 12\nMod(ψ ∗ µ) = {w′ | w′ ∈ UL(w, {µ}), where w ∈Mod(ψ), w∆w′ ∈ ∆min(ψ, µ)}.\nHowever, it turns out that this revision operator in fact coincides the Satoh revision operator:\nTheorem 10 ψ ∗ µ ↔ ψ ∗S µ.\nIt follows as a straightforward corollary that if we use a distance metric based on the number of differing propositional symbols between two interpretations, we obtain the revision operator of (Dalal, 1988).10 So in the obvious approaches to compositional revision, we do not obtain new revision operators; which is to say, the recursive decomposition in the definition of UL does not serve to select among models of µ in any interesting sense with respect to revision.\nHowever, these considerations do lead to one interesting result, and that is they point the way to algorithms that may more efficiently compute the Satoh or Dalal revision: To compute the Satoh revision for example, one can use Definition 6 to determine a relevant subset of models of µ, and then use ∆min(ψ, µ) to determine the closest subset of these models to the set of models of ψ. As we discuss in Section 5, this initial filtering of models of µ may be done efficiently in certain syntactically-restricted cases."
    }, {
      "heading" : "4. Analysis of Compositional Update and Erasure",
      "text" : "To start, we consider which of the Katsuno-Mendelzon update postulates our operator satisfies. We do not consider the set of corresponding compositional erasure postulates, since the results are analogous to those of the update postulates, and so are of limited additional interest. After considering the update postulates, we further explore the update and erasure operators, including properties resulting from the restriction of the syntactic form of the formula for update, and a comparison to related approaches.\nTheorem 11 ⋄c satisfies U1, U3, U5, U7, U8.\nFor a counterexample to U2, consider the first example given above, illustrating the approaches of Winslett, where for ψ ⋄c µ we have ψ = (b ∧ ¬m) ∨ (¬b ∧m) and µ = b ∨m. In our approach, for the update (as given in Definition 7) the first disjunct of µ viz., b, yields interpretations {b,¬m} and {b,m} and the update by the second disjunct, m, gives interpretations {b,m} and {¬b,m}. Hence ψ⋄c(b∨m) is characterized by the interpretations {b,m}, {b,¬m}, and {¬b,m} and so we get ψ ⋄c (b ∨ m) ↔ (b ∨ m). U2 would dictate that the result be ψ; however, the above example suggests that U2 is problematic in the context of update. To borrow an example from other works (Herzig & Rifi, 1999; Brewka & Herzberg, 1993), suppose an agent believes p (that a certain coin shows heads). Now the world changes because of a toss of this coin (where the agent does not see the result). Letting ¬p be that the coin shows tails, we note that the agent should believe (p∨¬p). Yet note that p ⊢ (p∨¬p); so U2 would stipulate that p⋄(p∨¬p) should be p, contrary to what we want. The operator ⋄c, on the other hand, includes an additional model. This appears to make sense, because by updating by b ∨m we are really telling the knowledge base that the world has changed so that one of b ∧m or b ∧ ¬m or ¬b ∧m is true. Thus, in this case the update operator behaves like the Gricean belief change operator of Delgrande, Nayak, and Pagnucco (2005), where the goal is to incorporate all and only the new information.\n10. That is, for fixed formulas, any model of the Dalal revision is a model of the Satoh revision. Rephrasing Definitions 11 and 12 for cardinality-based distance gives a result analogous to Theorem 10 for Dalal revision. We omit the details.\nWe note that we can modify our ⋄c operator in a simple fashion to satisfy U2 as follows: 11\nψ ⋄′c µ =\n{\nψ if ψ ⊢ µ ψ ⋄c µ otherwise\nBut for our purposes, although U2 is indeed now satisfied, this modification sheds no light on our original goal of investigating ramifications of developing a compositional update operator, and so we do not further pursue this modification.\nWe next consider a counterexample for U4. Although ((¬a ∧ b) ∨ b) ↔ b, nonetheless Mod(a⋄c((¬a∧b)∨b)) = {{¬a, b}, {a, b}} whileMod(a⋄cb) = {{a, b}}. SoU4 is not satisfied since in our compositional approach parts of a sentence may provide implicit results not explicit in the sentence. Consider (¬a∨b)∧(¬b∨c) to further illustrate this point. Updating by this sentence is effected by updating by the individual components, viz., (¬a ∨ b) and (¬b ∨ c). However, implicit in these parts is the fact that (¬a ∨ c) is also true, and the addition of this (implied) sentence would affect the result of the update. We consider this behaviour further below.\nA counterexample for U6 is given by the following. Let\nψ = a ∨ b\nµ1 = (a ∨ ¬a)\nµ2 = ⊤\nWe have that\nMod((a ∨ b) ⋄c (a ∨ ¬a)) = Mod(⊤)\nBut we also have:\nMod((a ∨ b) ⋄c ⊤) = Mod(a ∨ b)\nSo we have a case where ψ ⋄c µ1 ⊢ µ2 and also ψ ⋄c µ2 ⊢ µ1. Thus the antecedent conditions of U6 are satisfied, but not ψ ⋄c µ1 ↔ ψ ⋄c µ2.\nWhile ⋄c does not satisfy U4 (substitution of logical equivalents) in general, it does satisfy some weaker conditions. First, our update obviously satisfies substitution of logical equivalents in the first argument of ⋄c. As well, in light of Theorems 2 and 3, if µ1 and µ2 share the same negation normal form or disjunctive normal form, then they may be substituted one for the other as a formula for update. We summarize these results as follows:\nObservation 1\n1. If ψ1 ↔ ψ2 then (ψ1 ⋄c µ) ↔ (ψ2 ⋄c µ).\n2. If nnf (µ1) = nnf (µ2) then (ψ ⋄c µ1) ↔ (ψ ⋄c µ2).\n3. If dnf (µ1) = dnf (µ2) then (ψ ⋄c µ1) ↔ (ψ ⋄c µ2).\n11. Borgida (1985) employed a similar definition with respect to a revision operator.\nDespite failing to satisfy some postulates (which, it can be noted, overlap with the postulates that Herzig & Rifi, 1999, think are undesirable), ⋄c does exhibit a nice property, reflecting the compositional nature of our operator, but which operators appearing in the literature and satisfying the Katsuno and Mendelzon postulates fail to satisfy. The following version of the disjunction property holds.\nTheorem 12 ψ ⋄c (µ1 ∨ µ2) ↔ (ψ ⋄c µ1) ∨ (ψ ⋄c µ2)\nCorollary 1 (ψ ⋄c µ1) ∧ (ψ ⋄c µ2) implies ψ ⋄c (µ1 ∨ µ2).\nThe corollary can be observed to be a strengthening of U7. Our update operator satisfies those postulates deemed desirable by Herzig and Rifi (1999), with the exception of U4. As discussed above, U4 is not satisfied due to the interaction of parts of a sentence. It would seem that if we could “compile out” the implicit information in a sentence then we would obtain the full substitution of equivalents, as expressed in U4. So, one way to satisfy U4 is to redefine ⋄c so that we first get this information implicit in the interaction of the compositionally distinct parts of the update sentence. We do this by defining operators that consider the set of prime implicants of a sentence. We call this modified operator ⋄pic . Let PI(µ) be the set of prime implicants of µ.\nDefinition 13 ψ ⋄pic µ = ψ ⋄c ∨ PI(µ)\nTheorem 13 ⋄pic satisfies U4\nAlthough ⋄pic satisfies U4, we now lose U7. A counter-example for U7 is given by\nψ = a ∧ b ∧ c ∧ d\nµ1 = (a ∧ d) ∨ (¬c ∧ d)\nµ2 = (¬a ∧ d) ∨ (¬c ∧ d).\nWe have that\nMod(ψ ⋄pic µ1) = {{a, b, c, d}, {a, b,¬c, d}} and Mod(ψ ⋄pic µ2) = {{¬a, b, c, d}, {a, b,¬c, d}}\nHence Mod(ψ ⋄pic µ1) ∩Mod(ψ ⋄ pi c µ2) = {{a, b,¬c, d}}. On the other hand\nMod(ψ ⋄pic (µ1 ∨ µ2)) = Mod(ψ ⋄ pi c ((a ∧ d) ∨ (¬c ∧ d) ∨ (¬a ∧ d) ∨ (¬c ∧ d)))\n= Mod(ψ ⋄pic d) = {{a, b, c, d}}.\nConversion to prime implicants in effect removes irrelevant or redundant syntactic information, as illustrated in the preceding example where µ1 ∨ µ2 was in fact equivalent to the atom d. We can further pursue this line of inquiry by considering, for a formula for update µ, a syntactic representation of the proposition expressed by µ over the language of µ. For a given formula µ, recall that ModL(µ) is the set of models of µ, over the language of µ. The formula ∨∧\nModL(µ) then would be this formula expressed in disjunctive normal form; for example ModL((a ∨ b) ∧ c) would be expressed as (a ∧ b ∧ c) ∨ (a ∧ ¬b ∧ c) ∨ (¬a ∧ b ∧ c).\nWe define an update operator as follows:\nDefinition 14 Mod(ψ ⋄ssc µ) =Mod(ψ ⋄c ( ∨∧ ModL(µ))).\nWe obtain that this update operator is in fact the same as that of Winslett’s standard semantics:\nTheorem 14 ψ ⋄ssc µ↔ ψ ⋄ss µ.\nWe can pursue this direction one step further, and define an update operator where the update formula µ is characterized by its models expressed in dnf. That is we can define:\nMod(ψ ⋄trivc µ) =Mod(ψ ⋄c ( ∨∧ Mod(µ))).\nThis is the same as Definition 14, except over models of µ, rather than models of µ in the language of µ. However it is easily shown that this is not an interesting operator, since it removes all old information and we have:\nObservation 2 (ψ ⋄trivc µ) ↔ µ.\nWe next proceed in a slightly different direction and compare our update operator with the forget operator. Recall that forgetting a set of atoms from a formula ψ basically removes all information having to do with this set of atoms; in a sense forgetting is analogous to decreasing the language by this set of atoms.\nTo begin with, it can be noted that our update operator can have contraction-like properties similar to forget. For example, (a∧b)⋄c (a∨¬a) is readily shown to be equivalent to b. So again, in a sense, this update can be read as updating by precisely a ∨ ¬a, which in this case would indicate tautologous information concerning a. In fact, we have the following result (recall that we use ⊙ to denote forget):\nTheorem 15 Let ψ ∈ L and let Γ ⊆ P. Then\nψ ⊙ Γ = ψ ⋄c\n\n\n∧\np∈Γ\n(p ∨ ¬p).\n\n\nHence forgetting a set of atoms is a special case of our update operator. (Given Theorem 6, forget is of course also expressible via erasure in an analogous fashion.) Last, we establish a result between the forget operator and Winslett’s standard semantics. While in hindsight obvious, this result does not appear to have been previously noted.\nTheorem 16 For formula ψ and Γ ⊆ P, let µ = ∧\nl∈Γ(l ∨ ¬l). Then\nψ ⊙ Γ = ψ ⋄ssc µ.\nIn summary, it can be observed from the above discussion that we have obtained a hierarchy of operators, based on the extent to which information in µ is made explicit. For the most basic case, we have ψ ⋄trivc µ, where the update formula µ is a syntactic representation of all models of the language; a trivial update operator results. The most basic interesting operator is given by ψ ⋄ssc µ, which is the same as Winslett’s standard semantics, followed by ψ ⋄pic µ and ψ ⋄c µ. As well, by introducing tautologies, we also capture the notion of forgetting of atoms.\nWe have already noted that our update operator ⋄c is distinct from the Winslett PMA approach. To the best of our knowledge it is also distinct from all other specific approaches appearing in the literature, including those surveyed in (Herzig & Rifi, 1999)."
    }, {
      "heading" : "5. Algorithms and Complexity",
      "text" : "In this section we present a syntactic characterization as well as an algorithm for computing compositional update. We also analyze the complexity of this algorithm under a variety of assumptions. Specifically, we analyze the complexity of the algorithm when applied to any propositional sentences in general, to any sentences in disjunctive normal form, and to any sentences whose sizes are bounded by some specified constant.\nWe start with some background notions. Recall that ψ[p/q] denotes the formula ψ where all occurrences of atom p are replaced by q. We write ∃ p.ψ to denote the formula ψ[p/⊤] ∨ ψ[p/⊥]. If P = {p1, · · · , pn} is a set of atoms then ∃P.ψ, called an eliminant of P in ψ, stands for ∃ p1.(· · · ∃ (pn.ψ)) (Brown, 1990). Intuitively, an eliminant of P in ψ can be viewed as a formula representing the same knowledge of ψ that is not concerned with atoms in P . We have eliminated information about members of P by replacing them by their two possible values, ⊤ and ⊥, thus leaving only the other information in ψ.\nIt has been shown that Winslett’s standard semantics can be syntactically captured based on the notion of eliminant (Doherty, Lukaszewicz, & Madalińska-Bugaj, 1998). Let P = atom(µ), then\nψ ⋄ss µ↔ (∃P.ψ) ∧ µ (5)"
    }, {
      "heading" : "5.1 Syntactic Characterization and Algorithms",
      "text" : "We are now ready to provide a syntactical characterization of compositional update. The idea is quite similar to that of (Doherty et al., 1998). However, our approach first converts the update formula to disjunctive normal form, then deals with each disjunct.\nUpdate(ψ, µ) = ∨ {(∃P.ψ) ∧ t | t ∈ dnf (µ), P = atom(t)}\nThe following results establish the correspondence between the semantical definition and syntactic characterizations of compositional update.\nLemma 2 Suppose t is a term (a conjunction of literals) and P = atom(t). Then\nMod((∃P.ψ) ∧ t) = {w′ | w′ ∈ UL(w, t), w ∈Mod(ψ)}\nTheorem 17 Mod(ψ ⋄c µ) =Mod(Update(ψ, µ)).\nCorollary 2 ψ ⋄c µ↔ Update(ψ, µ)\nAll we need to compute compositional update, therefore, is the ability to compute eliminants. As proposed by Brown (1990), an eliminant ∃P.ψ can be constructed as follows.\n1. Convert ψ to dnf t1 ∨ · · · ∨ tn (each ti is a conjunction of literals)\n2. Replace each ti by ti ↓ P .\nNow we are ready to provide the algorithms for compositional update. We will assume that dnf (µ) refers to the disjunctive normal form of µ represented in clause form, in which a formula is represented by sets of sets of literals. In this case, the members of dnf (µ) are implicitly disjoined, while a set of literals making up a member of dnf (µ) is implicitly conjoined.\nIn the following algorithms, let ψ, µ ∈ L and P be a set of atoms:\nAlgorithm Eliminant(P,ψ) 1. ψ′ ← ⊥ 2. for each term t ∈ dnf (ψ) 3. t′ ← ⊤ 4. for each literal l ∈ t 5. if l /∈ P and l /∈ P 6. t′ ← t′ ∧ l 7. ψ′ ← ψ′ ∨ t′ 8. return ψ′\nAlgorithm Update(ψ, µ) 1. ψ′ ← ⊥ 2. for each term t ∈ dnf (µ) 3. P = atom(t) 4. ψ′ ← ψ′ ∨ (Eliminant(P,ψ) ∧ t) 5. return ψ′\nLet’s consider again Example 1 in which µ = b and ψ = (b ∧ ¬m) ∨ (¬b ∧ m). We have that Update(ψ, µ) = ⊥ ∨ (Eliminant({b}, ψ) ∧ b). Since Eliminant({b}, ψ) = ⊥ ∨ (⊤ ∧ ¬m) ∨ (⊤ ∧ m), which is equivalent to ⊤, we obtain that Update(ψ, µ) ↔ b. Thus, Update(ψ, µ) ↔ ψ ⋄c µ, as we have already shown that ψ ⋄c µ↔ b.\nFor Example 2, where ψ = ¬b ∧ ¬m and µ = (b ∨ m), we obtain Update(ψ, µ) = (b ∧ ¬m) ∨ (¬b ∧m). Again, this result is same as what we obtain with ⋄c."
    }, {
      "heading" : "5.2 Complexity",
      "text" : "In the sequel, we analyze the space complexity of the update algorithm; that is, we are interested in how large the updated knowledge base could be. Unfortunately, when applied to arbitrary formulas, the algorithm Update may cause exponential space blowup, as the disjunctive normal form of a formula could be exponentially large.\nTheorem 18 The space complexity of Update(ψ, µ) is O(2(|ψ|+|µ|)) for ψ, µ ∈ L;\nHowever, we are able to show that such exponential space blowup is inevitable for any algorithm of compositional update. To this end, we need to introduce so-called advice-taking Turing machine (TM) and non-uniform complexity class, see (Johnson, 1990).\nAn advice-taking TM is a TM with an advice oracle, which can be considered as a function a from positive integers to strings. On input x, the machine loads string a(|x|) and then continues as usual based on two inputs x and a(|x|). Note that the oracle string a(|x|) only depends on the size of the input x. We call an advice oracle a polynomial iff |a(n)| < p(n) for some fixed polynomial p and all positive integers n. If X is a usual complexity class defined in terms of resource-bounded machines (e.g., P or NP) then X/poly is the class of the problem that can be decided on machines with the same resource bound augmented by polynomial advice oracles. Any class X/poly is also known as the non-uniform X; in particular, P/poly appears to be much more powerful than P. However, it has been shown very unlikely that NP ⊆ P/poly, otherwise the polynomial hierarchy would collapse\nat Σp2 (Karp & Lipton, 1980). This result is used to show that it is unlikely that there exists an algorithm for compositional update with a polynomial space bound.\nTheorem 19 Assume there exist a polynomial p and an algorithm Update of compositional update such that Update(ψ, µ) ↔ ψ ⋄c µ and |Update(ψ, µ)| ≤ p(|ψ| + |µ|), for any belief base ψ and formula µ. Then NP ⊆ P/poly.\nWe can pursue the above result one step further, and show that algorithms for any sensible update operators will cause exponential blowup. Formally, we say an update operator ⋄ is sensible iff for any consistent set of literals Γ:\nMod(ψ ⋄ ∧ Γ) = {ω′ | ω′ ∈ (w ↓ Γ) ∪ Γ, ω ∈Mod(ψ)}\nArguably, the above condition is very intuitive and natural (cf. discussions in Section 3). In fact, almost all update operators in the literature are sensible.\nTheorem 20 If there exists a polynomially space bounded algorithm for any sensible update operator, then NP ⊆ P/poly.\nWe remark that the above result also proves Winslett’s conjecture stating that there does not exist a polynomially space bounded algorithm for her standard semantics (see Winslett, 1990).\nThe algorithm becomes tractably better when applied to formulas in disjunctive normal form, and to update formulas whose sizes are bounded.\nTheorem 21 The space complexity of Update(ψ, µ) is:\n1. O(|ψ| × |µ|) for ψ, µ in dnf; and\n2. O(|ψ|) for ψ in dnf and |µ| < k for some constant k.\nArguably, in practice, the update formula µ (representing the changes of the world) will be relatively small. Therefore, it is relatively easy to convert µ to dnf, and it is also reasonable to assume the size of µ is bounded. As we usually do not restrict the size of the belief base ψ, converting ψ to dnf could be computationally much more expensive. Fortunately, we only need to compile (off-line) the original belief base once into dnf, and the output of Update algorithm is automatically the dnf of the updated belief base. This will considerably facilitate the further update of the belief base."
    }, {
      "heading" : "6. Conclusion",
      "text" : "We have presented belief change operators for updating a knowledge base where the definition of these operators is compositional with respect to the sentence to be added. The intent is to provide operators with transparent definitions, based on the structure of the formula for belief change. As a result we lose some of the standard postulates for update, although we do satisfy a core group of the standard postulate set. We achieve full irrelevance of syntax if the sentence for update is replaced by the disjunction of its prime implicants.\nThe approach is interesting because first, it is founded on differing intuitions than other operators, in that it is based on a decomposition of the formula rather than on the models of the formula, and second, it allows a straightforward and (under reasonable assumptions) efficient implementation. While distinct from previous update operators that have appeared in the literature, we can capture Winslett’s standard semantics approach to update in a restriction of our approach. In fact, the update operator, under different syntactic restrictions, may be regarded as constituting a family of update operators of which Winslett’s standard semantics is the weakest interesting approach. When we turn from update to revision, we discover there is no new, interesting compositional revision operator; nevertheless, our results indicate that by first computing the compositional update, one can implement the Satoh or Dalal revision operator more efficiently, because we consider only a subset of the models of the formula of revision, and in certain cases this will have a significant speedup over a naive algorithm.\nAn open question concerns combining this approach with one that is designed to exploit the structure of the knowledge base (such as discussed in Parikh, 1999 and characterized in terms of PMA updates in Peppas, Chopra, & Foo, 2004). A second, technical question that is not fully explored concerns the behaviour of ⋄c as an erasure operator. For example, let ψ = (a ∨ b) ∧ (¬a ∨ ¬b). Then, we get that ψ ⋄c (a ∨ b) ↔ a ∨ b. So, in updating the knowledge base with a formula already implied by the knowledge base, we have actually removed information. This, as discussed earlier, is quite reasonable if one considers that an update (in contrast to a revision) by a ∨ b asserts that the world has changed so that one of {a, b}, {¬a, b}, {a,¬b} is now true. Finally, it would be of interest to apply the compositional approach to the merging of knowledge bases."
    }, {
      "heading" : "Acknowledgments",
      "text" : "An early precursor of this paper was presented at FLAIRS 2007 (Delgrande, Pelletier, & Suderman, 2007). We are grateful to that audience for comments; and we have also benefited from the perceptive comments of three JAIR referees. Delgrande and Pelletier also acknowledge the support of the Canadian NSERC granting agency."
    }, {
      "heading" : "Appendix A. Proof of Theorems",
      "text" : "Proof 1.\nObserve that UL is associative and commutative with respect to top-level conjunctions and top-level disjunctions. That is, for example\nUL(ω, {α ∧ (β ∧ γ)} ∪ Γ′) = UL(ω, {(α ∧ β) ∧ γ} ∪ Γ′).\nA similar observation can be made about negations of such top-level conjunctions and disjunctions; for example we have\nUL(ω, {¬(α ∧ (β ∧ γ))} ∪ Γ′) = UL(ω, {¬((α ∧ β) ∧ γ)} ∪ Γ′).\nWe use such basic facts without comment in the sequel.\nThe above means in particular that for showing the order-independence of UL with respect to its second argument, we just need consider the general case of UL(ω,Γ) where Γ = {µ1} ∪ {µ2}, since we have that UL(ω, {α1, . . . , αn}) = UL(ω, {α1, ∧n i=2 αi}).\nGiven this preamble, what we need to show is that for formulas µ1 and µ2, that UL(ω, {µ1} ∪ {µ2}) is independent of whether the initial recursion is in terms of µ1 or µ2.\nThe proof is on the depth of a formula.\nBASE:\nAssume that depth(µ1) ≤ 1 and depth(µ2) ≤ 1:\n1. If depth(µ1) = depth(µ2) = 0 then µ1, µ2 are atoms and the result follows trivially.\n2. If the only connective for µ1, µ2 is negation then µ1, µ2 are literals and again the result follows trivially.\n3. If the connectives for µ1, µ2 are from {¬,∧}, then µ1, µ2 reduce to sets of literals, and the previous case applies.\n4. µ1 is a1 ∨ a2, and µ1 is a literal, then only Step 3 of the definition applies, and our result obtains easily. The converse where µ2 is a1 ∨ a2, and µ2 is a literal of course yields the same result.\n5. If µ1 is a1 ∧ a2 and µ2 is b1 ∨ b2, then we have\nUL(ω, {a1 ∧ a2} ∪ {µ2}) = UL(ω, {a1, a2} ∪ {µ2})\n= UL(ω, {a1, a2} ∪ {b1 ∨ b2})\n= UL(ω, {b1 ∨ b2} ∪ {a1, a2})\n= UL(ω, {b1} ∪ {a1, a2}) ∪ UL(ω, {b2} ∪ {a1, a2})\n= UL(ω, {b1} ∪ {a1 ∧ a2}) ∪ UL(ω, {b2} ∪ {a1 ∧ a2})\n= UL(ω, {b1 ∨ b2} ∪ {a1 ∧ a2})\n= UL(ω, {b1 ∨ b2} ∪ {µ1})\n6. If µ1 is a1 ∨ a2 and µ2 is b1 ∨ b2, then we have\nUL(ω, {a1 ∨ a2} ∪ {µ2}) = UL(ω, {a1} ∪ {µ2}) ∪ UL(ω, {a2} ∪ {µ2})\n= UL(ω, {a1} ∪ {b1 ∨ b2}) ∪ UL(ω, {a2} ∪ {b1 ∨ b2})\n= UL(ω, {b1 ∨ b2} ∪ {a1}) ∪ UL(ω, {b1 ∨ b2} ∪ {a2})\n= (UL(ω, {b1} ∪ {a1}) ∪ UL(ω, {b2} ∪ {a1})) ∪\n(UL(ω, {b1} ∪ {a2}) ∪ UL(ω, {b2} ∪ {a2}))\n= UL(ω, {b1, a1}) ∪ UL(ω, {b2, a1}) ∪\nUL(ω, {b1, a2}) ∪ UL(ω, {b2, a2})\nAnalogous manipulations show that UL(ω, {b1 ∨ b2} ∪ {µ1}) yields the same result.\nSTEP: For the induction hypothesis, assume that our result holds for depth(µ1) ≤ n and depth(µ2) ≤ n. We show that the desired result obtains for depth(µ1) ≤ (n + 1) and depth(µ2) ≤ (n+ 1). A: Consider first where depth(µ1) ≤ n and depth(µ2) = n+ 1.\n1. µ2 is of the form ¬¬α:\nUL(ω, {µ1} ∪ {µ2}) is the same as UL(ω, {µ1} ∪ {α}), and our result follows by the induction hypothesis.\n2. µ2 is α ∧ β:\nUL(ω, {µ1} ∪ {µ2}) = UL(ω, {µ1} ∪ {α ∧ β}) = UL(ω, {µ1, α, β}) = UL(ω, {α ∧ β} ∪ {µ1}).\n3. µ2 is α ∨ β:\nUL(ω, {µ1} ∪ {µ2}) = UL(ω, {µ1} ∪ {α ∨ β}) = UL(ω, {µ1, α}) ∪ UL(ω, {µ1, β}) while UL(ω, {µ2} ∪ {µ1}) = UL(ω, {α ∨ β} ∪ {µ1}) = UL(ω, {µ1, α}) ∪ UL(ω, {µ1, β}).\n4. µ2 is ¬(α ∧ β) or µ2 is ¬(α ∨ β):\nThis is handled the same as α ∨ β or α ∧ β respectively.\nB: Consider next where depth(µ1) = n+ 1 and depth(µ2) = n+ 1.\n1. µ1 or µ2 is ¬¬α:\nThis is the same as µ1 or µ2 being α, from which our result holds via the induction hypothesis.\n2. µ1 or µ2 is α1 ∧ β1:\nAssume without loss of generality that µ1 is α1 ∧ β1.\n(a) µ2 is α2 ∧ β2:\nUL(ω, {µ1} ∪ {µ2}) = UL(ω, {α1 ∧ β1} ∪ {α2 ∧ β2}) = UL(ω, {α1, β1, α2, β2}) = UL(ω, {µ2} ∪ {µ1}).\n(b) µ2 is α2 ∨ β2:\nThis case is handled the same as in the base case, where α1, β1, α2, β2 are atoms.\n(c) µ2 is ¬(α2 ∧ β2) or µ2 is ¬(α2 ∨ β2):\nThis is handled the same as α2 ∨ β2 or α2 ∧ β2 respectively.\n3. µ1 or µ2 is α ∨ β:\nThe proof here is the same as in the base case, where α, β are atoms.\n4. µ1 (µ2) is ¬(α ∧ β) or µ1 (µ2) is ¬(α ∨ β):\nThis is handled the same as α ∨ β or α ∧ β respectively.\nSince this covers all cases, our result follows by induction.\nProof 2.\nThe proof follows straightforwardly from the observations that for arbitrary ω, Γ, we have:\nUL(ω, {¬¬α} ∪ Γ) = UL(ω, {α} ∪ Γ)\nUL(ω, {¬(α ∧ β)} ∪ Γ) = UL(ω, {¬α ∨ ¬β} ∪ Γ)\nUL(ω, {¬(α ∨ β)} ∪ Γ) = UL(ω, {¬α ∧ ¬β} ∪ Γ)\nAn induction argument establishes that the value of UL doesn’t change under conversion of elements of its second argument to negation normal form.\nProof 3.\nThis result follows from the preceding, plus the fact that for arbitrary ω, Γ we have that: UL(ω, {α ∧ (β ∨ γ)} ∪ Γ) = UL(ω, {(α ∧ β) ∨ (α ∧ γ)} ∪ Γ); that is, UL is invariant under distribution of conjunction over disjunction.\nProof 4.\nProof is by induction on the maximum depth of a formula in Γ.\nIf the maximum depth is 0, then all members of Γ are literals, and the result is immediate from Definition 6. Otherwise the induction hypothesis is that the result holds where the maximum depth of a formula in Γ is n, and the step is easily shown by appeal to truth conditions in classical propositional logic.\nProof 5. Right-to-left: This is a corollary of Theorem 4.\nLeft-to-right:\nFor arbitrary Γ we have by Theorem 3 that UL(ω,Γ) = UL(ω, dnf (Γ)). Let dnf (Γ) = γ1 ∨ · · · ∨ γn where each γi is a conjunction of literals. Via Definition 6 we have that UL(ω, dnf (Γ)) = UL(ω, {γ1}) ∪ · · · ∪ UL(ω, {γn}). For each γi, if γi contains a complementary pair of literals then UL(ω, {γi}) = ∅; otherwise UL(ω, {γi}) 6= ∅.\nIf we assume that Γ 6⊢ ⊥, then there is some γi with no complementary literals, consequently UL(ω, {γi}) 6= ∅ and so ∅ 6= UL(ω, dnf (Γ)) = UL(ω,Γ).\nThus Γ 6⊢ ⊥ implies UL(ω,Γ) 6|= ⊥, which was to be shown.\nLemma 3 ψ ∧ µ ⊢ ψ ⋄c µ.\nProof of Lemma 3. If ψ ∧ µ ⊢ ⊥ then the result is immediate.\nConsequently assume that ψ ∧ µ is satisfiable, and let ω ∈ Mod(ψ ∧ µ). We show that ω ∈Mod(ψ ⋄c µ). Given Definition 7, and since we already have ω ∈Mod(ψ), we just need to show that ω ∈ UL(ω, {µ}).\nWe have by assumption that ω ∈ Mod(µ), whence (Theorem 3) ω ∈ Mod(dnf (µ)). Since Mod(dnf (µ)) = Mod(dnf (µ1)) ∪ · · · ∪Mod(dnf (µn)) for dnf (µ) = µ1 ∨ · · · ∨ µn we get ω ∈Mod(dnf (µi)) for some disjunct µi of dnf (µ).\nSince ω ∈Mod(dnf (µi)) it follows from the definition of UL that ω = UL(ω, {µi}); hence ω ∈Mod(dnf (µ)) and so ω ∈ UL(ω, {µ}), which was to be shown.\nProof 6. The second part of the theorem follows immediately from Definitions 7 and 8.\nFor the first part: Since ψ ∧ µ ⊢ ψ ⋄c µ (Lemma 3), we have\nψ ⋄c µ ↔ (ψ ∧ µ) ∨ (ψ ⋄c µ)\n↔ (ψ ∧ µ) ∨ ((ψ ⋄c µ) ∧ µ)\n↔ (ψ ∨ (ψ ⋄c µ)) ∧ µ\n↔ (ψ c¬µ) ∧ µ\nThe last step applies the other part of the theorem, established above.\nProof 7.\nThe proof is the same as that for Theorem 2 with minor modifications.\nProof 8.\nThe proof is analogous to that of Theorem 3, and is omitted.\nProof of Lemma 1.\nThe proof is straightforward, except setting up the induction is a bit fiddly. The induction is based on the maximum depth of a formula in Γ. For Γ ⊆ L, let depth(Γ) = maxµ∈Γ depth(µ). We then stipulate that Γ precedes Γ\n′ in the ordering for the induction if depth(Γ) < depth(Γ′), or if depth(Γ) = depth(Γ′) = n and the number of formulas in Γ of depth n is less than that in Γ′.\nBASE:\nLet Γ be a set of literals. If ∨ Γ ⊢ ⊤ then EL(ω,Γ) = ∅ = UL(ω, {¬ ∧ Γ}).\nIf ∨ Γ 6⊢ ⊤ then:\nEL(ω,Γ) = (ω ↓ Γ) ∪ Γ\n= (ω ↓ Γ) ∪ Γ\n= UL(ω,Γ) = UL ( ω, { ¬ ∧ Γ })\nSTEP: Assume that the result holds for the first n sets of formulas in the ordering, and let µ be a formula of maximum depth in Γ. Let Γ′ = Γ \\ {µ}. If µ = α ∧ β, then\nEL(ω,Γ) = EL(ω, {α ∧ β} ∪ Γ′)\n= EL(ω, {α} ∪ Γ′) ∪ EL(ω, {β} ∪ Γ′) = EL(ω, {∧({α} ∪ Γ′)}) ∪ EL(ω, {∧({β} ∪ Γ′)}) = UL(ω, {¬ ∧ ({α} ∪ Γ′)}) ∪ UL(ω, {¬ ∧ ({β} ∪ Γ′)}) = UL(ω, {¬α ∨ (¬ ∧ Γ′)}) ∪ UL(ω, {¬β ∨ (¬ ∧ Γ′)}) = UL(ω, {¬α ∨ (¬ ∧ Γ′) ∨ ¬β ∨ (¬ ∧ Γ′)}) = UL(ω, {¬α ∨ ¬β ∨ (¬ ∧ Γ′)}) = UL(ω, {¬(α ∧ β ∧ (∧Γ′))})\n= UL(ω, {¬(∧Γ)}).\nThe change from EL to UL above is justified by the induction hypothesis; otherwise all steps are by definition of UL or EL, or simple manipulation.\nIf µ = α ∨ β, then\nEL(ω,Γ) = EL(ω, {α ∨ β} ∪ Γ′)\n= EL(ω, {α, β} ∪ Γ′) = UL(ω, {¬ ∧ ({α, β} ∪ Γ′)})\n= UL(ω, {¬(∧Γ)}).\nAgain, the change from EL to UL above is justified by the induction hypothesis. Other cases are handled analogously; their proofs are omitted. Hence our result follows by induction.\nProof 9.\nMod(ψ cµ) = Mod(ψ) ∪ {ω ′ | ω′ ∈ UL(ω, {¬µ}), ω ∈Mod(ψ)}\n= Mod(ψ) ∪ {ω′ | ω′ ∈ EL(ω, {µ}), ω ∈Mod(ψ)} = Mod(ψ ′c µ)\nThe first and last steps above are justified by Definitions 8 and 10 respectively; the middle step follows from Lemma 1.\nProof 10. It follows immediately from Definitions 11 and 12 thatMod(ψ∗µ) ⊆Mod(ψ∗S µ).\nTo show the converse, we let w′ ∈Mod(ψ ∗S µ) and show that w ′ ∈Mod(ψ ∗ µ).\nGiven that the Satoh revision operator satisfies irrelevance of syntax (R4), we can assume without loss of generality that µ is in dnf; i.e. µ = µ1 ∨ · · · ∨ µn where each µi is a conjunction of literals.\nWe have by assumption that w′ ∈Mod(ψ ∗S µ); hence ∃w ∈Mod(ψ) such that w∆w ′ ∈\n∆min(ψ, µ).\nSince w′ ∈Mod(ψ ∗S µ), we have that w ′ ∈ Mod(µ) = Mod(µ1 ∨ · · · ∨ µn). Thus there is a clause from µ, µi, such that w ′ ∈ Mod(µi). Assume without loss of generality that µi is subset-minimal among the sets of literals making up the disjuncts of µ.\nIf we can show w′ ∈ UL(w, {µi}) then we will have shown that w ′ satisfies the conditions to be a member of Mod(ψ ∗ µ). We show this as follows. Let Ui be the set of literals in µi. We have that for l 6∈ Ui that l ∈ w iff l ∈ w\n′ (since otherwise this would contradict w∆w′ ∈ ∆min(ψ, µ)).\nIt follows that (w ↓ Ui) ∪ Ui = w ′. But this means that w′ ∈ UL(w,Ui), or w ′ ∈ UL(w, {ui}) and so w\n′ ∈ UL(w, {µ}). Hence w′ ∈Mod(ψ ∗ µ), which was to be shown.\nProof 11.\nU1: By Theorem 4 , UL(ω, {µ}) |= µ for every ω ∈Mod(ψ), whenceMod(ψ⋄cµ) ⊆Mod(µ) or ψ ⋄c µ ⊢ µ.\nU3: By assumption ψ 6⊢ ⊥, and so Mod(ψ) 6= ∅. Our result then follows immediately from Theorem 5 and Definition 7.\nU5: If Mod(ψ ⋄c µ) ∩Mod(φ) = ∅ then our result follows vacuously.\nOtherwise, let ω ∈Mod(ψ ⋄c µ) ∩Mod(φ).\nSince ω ∈ Mod(ψ ⋄c µ) then, by Theorem 3, there exists ω ′ ∈ Mod(ψ) and Γ ⊆ Lits such that ∧ Γ is a disjunct of dnf (µ) where ω = (ω′ ↓ Γ) ∪ Γ.\nBecause ω ∈Mod(φ) there is a set of literals Γ′ such that ∧ Γ′ is a disjunct of dnf (φ) such that Γ′ ⊆ ω.\nBy definition, ∧ Γ∪Γ′ is a clause in dnf (µ∧φ). We note that ω = (ω′ ↓ (Γ∪Γ′))∪(Γ∪Γ′) so by Definition 7 we have ω ∈Mod(ψ ⋄c (µ ∧ φ)).\nU7:\nMod(ψ ⋄c µ1) ∩Mod(ψ ⋄c µ2)\n⊆ Mod(ψ ⋄c µ1) ∪Mod(ψ ⋄c µ2)\n⊆ Mod(ψ ⋄c (µ1 ∨ µ2))\nThe last step follows from Theorem 3, using the fact that dnf (α∨β) = dnf (α)∨dnf (β).\nHence (ψ ⋄c µ1) ∧ (ψ ⋄c µ2) implies ψ ⋄c (µ1 ∨ µ2).\nU8:\nMod((ψ1 ∨ ψ2) ⋄c µ) = {ω ′ | ω′ ∈ UL(ω, {µ}), ω ∈Mod(ψ1 ∨ ψ2)}\n= {ω′ | ω′ ∈ UL(ω, {µ}), ω ∈Mod(ψ1) ∪Mod(ψ2)} = {ω′ | ω′ ∈ UL(ω, {µ}), ω ∈Mod(ψ1)}\n∪ {ω′ ∈ UL(ω, {µ}), ω ∈Mod(ψ2)}\n= Mod(ψ1 ⋄c µ) ∪Mod(ψ2 ⋄c µ).\nFromMod((ψ1∨ψ2)⋄cµ) =Mod(ψ1⋄cµ)∪Mod(ψ2⋄cµ) it follows that ((ψ1∨ψ2)⋄cµ) ↔ (ψ1 ⋄c µ) ∨ (ψ2 ⋄c µ).\nProof 12.\nMod(ψ ⋄c (µ1 ∨ µ2)) = {ω ′ | ω′ ∈ UL(ω, {µ1 ∨ µ2}), ω ∈Mod(ψ)}\n= {ω′ | ω′ ∈ UL(ω, {µ1}), ω ∈Mod(ψ)} ∪\n{ω′ | ω′ ∈ UL(ω, {µ2}), ω ∈Mod(ψ)}\n= Mod(ψ ⋄c µ1) ∪Mod(ψ ⋄c µ2)\n= Mod((ψ ⋄c µ1) ∨ (ψ ⋄c µ2))\nProof 13. We need to show that if ψ1 ↔ ψ2 and µ1 ↔ µ2 then we have that (ψ1 ⋄cµ1) ↔ (ψ2 ⋄cµ1). Since µ1 ↔ µ2 by assumption, we have that PI(µ1) = PI(µ2). 12 Since (ψ1 ⋄c ∨\nPI(µ1)) ↔ (ψ2 ⋄c ∨ PI(µ1)) and (ψ2 ⋄c ∨ PI(µ1)) ↔ (ψ2 ⋄c ∨ PI(µ2)), we have (ψ1 ⋄c ∨\nPI(µ1)) ↔ (ψ2 ⋄c ∨ PI(µ2)), whence (ψ ⋄ pi c µ1) ↔ (ψ ⋄ pi c µ2).\nProof 14. We have that Mod(ψ ⋄ssc µ) = Mod(ψ ⋄c ( ∨ ( ∧\nModL(µ)))). Using Definition 7, the right hand side is equal to {ω′ | ω′ ∈ UL(ω, { ∨ ( ∧\nModL(µ))}), ω ∈ Mod(ψ)}. Hence, each ω ∈ Mod(ψ) is replaced by a set of interpretations Ω where Ω = {(ω ↓ ω′′) ∪ ω′′ | ω′′ ∈ ModL(µ)}. Which is to say, ω ∈ Mod(ψ) is replaced by a set of interpretations Ω where ω′′ ∈ Ω just if ω and ω′′ differ only over the language of µ. But this is just the definition for Mod(ψ ⋄ssc µ).\nProof 15. Let Γ = {p1, . . . , pn}.\nψ ⊙ Γ = ψ ⊙ {p1 ∧ · · · ∧ pn}\n= [(ψ ⊙ {p1 ∧ · · · ∧ pn}) ⋄c pn] ∨ [(ψ ⊙ {p1 ∧ · · · ∧ pn}) ⋄c ¬pn]\n12. Equality isn’t quite right here. Rather we have equality modulo associativity and commutativity, which is all that we need for our result.\nThe second step above is just Definition 3 for forget expressed in terms of update. Definition 3 can be successively reapplied to eventually terminate with a disjunction with 2n disjuncts, where each disjunct is a sequence of n updates of literals from Γ. Moreover, every maximum consistent set of literals from Γ appears in some disjunct.\nWe have the easy result, that we state without proof, that for disjoint sets of literals Γ1, Γ2, that (ψ ⋄c (∧Γ1)) ⋄c (∧Γ2) = (ψ ⋄c ∧(Γ1 ∪ Γ2)).\nHence we get finally that\nψ ⊙ Γ = ∧\nΛ⊆Γ\nψ ⋄c ((∧Λ) ∧ ¬ ∧ (Γ \\ Λ))\n= ψ ⋄c\n\n\n∧\np∈Γ\n(p ∨ ¬p).\n\n\nProof 16.\n¿From Theorem 15 we have that\nψ ⊙ Γ = ψ ⋄c\n(\n∧\na∈Γ\n(a ∨ ¬a).\n)\n= ψ ⋄c µ.\n¿From Observation 1 we get that ψ ⋄c µ = ψ ⋄c dnf (µ). An easy argument shows that dnf (µ) = ∨∧\nModL(µ), and so Definition 14 yields ψ ⋄c dnf (µ) = ψ ⋄ ss c µ. Theorem 14 is\nψ ⋄ssc µ = ψ ⋄ss µ. Putting this all together we get ψ ⊙ ∧(Γ) = ψ ⋄ ss c µ.\nProof of Lemma 2.\nEquation (5) implies that Mod((∃P.ψ) ∧ t) = Mod(ψ ⋄ss t). According to Theorem 14 and Definition 14, we then have Mod(ψ ⋄ss t) =Mod(ψ ⋄c ( ∨ ( ∧\nModL(t)))) =Mod(ψ ⋄c t). From Definition 7, it follows that Mod((∃P.ψ) ∧ t) = {w′ | w′ ∈ UL(w, t), w ∈Mod(ψ)}.\nProof 17.\nAccording to Definition 7,Mod(ψ⋄cµ) = {w ′ | w′ ∈ UL(w, {µ}), w ∈Mod(ψ)}. By Theorem 3, we have {w′ | w′ ∈ UL(w, {µ}), w ∈ Mod(ψ)} = {w′ | w′ ∈ UL(w, {dnf (µ)}), w ∈ Mod(ψ)}. From Definition 6, it follows that Mod(ψ ⋄c µ) = {w\n′ | w′ ∈ UL(w, t), t ∈ dnf (µ), w ∈Mod(ψ)}. According to Lemma 2, thus Mod(ψ ⋄c µ) =Mod(Update(ψ, µ)).\nProof 18.\nThe size of dnf (ψ) is O(2|ψ|). Hence, the size of Eliminant(P,ψ) is also O(2|ψ|). Similarly, the size of dnf (µ) is O(2|µ|). Therefore, |Update(ψ, µ)| = O(2|µ| × 2|ψ|) = O(2|ψ|+|µ|).\nProof 19.\nThis proof is inspired by the ideas in (Cadoli, Donini, Liberatore, & Schaerf, 1995), where it was shown that many revision operators cause exponential blowup. We show that\nif there exists a polynomially space bounded algorithm of compositional update, then 3SAT is in P/poly.13 The proof consists of two steps.\nSTEP 1:\nFor any integer n, we first construct a belief base ψn and a formula µn, whose sizes are polynomial wrt. n. Let X = {x1, · · · , xn} and Y = {y1, · · · , yn} be two disjoint set of atoms and let C be a set of new atoms for each 3-literal clause over X, i.e., C = {ci | γi is a 3-literal clause of X}. We obtain ψn and µn as follows:\nψn = {γi ∨ ¬ci | γi is a 3-literal clause of X} µn = ∧n i=1(¬x1 ∧ ¬yi)\nIt is easy to see that |ψn| ∈ O(n 3) and |µn| ∈ O(n).\nThen we show that for any 3CNF β of size n, there exists an interpretation ωβ (on atoms X ∪ Y ∪ C) such that ωβ |= ψn ⋄c µn iff β is satisfiable. We assume, without loss of generality, that atom(β) ⊆ X; or otherwise, we can always substitute atoms of β respectively by elements of X to obtain a new sentence βX such that β is satisfiable iff βX is satisfiable. Then wβ can be obtained as follows:\nwβ = {ci ∈ C | γi is a clause of β} ∪ {¬ci ∈ C | γi is not a clause of β} ∪X ∪ Y\nWe now show that β is satisfiable iff ωβ |= ψn ⋄c µn.\n⇒ Assume β is satisfiable. Let ω be a model of β. We construct another interpretation ω′ = UL(ω, {¬ci ∈ C | γi is not a clause of β}). It is easy to see that ω\n′ |= ψn and ωβ = UL(ω ′, {¬xi,¬yi | 1 ≤ i ≤ n}). It follows that ωβ |= ψn ⋄c µn.\n⇐ Assume ωβ |= ψn ⋄c µn. Then there exists an interpretation ω such that ω |= ψn and ωβ = UL(ω, {¬xi,¬yi | 1 ≤ i ≤ n}). We claim that ω |= β. Assume ω 6|= β. Then there exists a 3-literal clause γi of β such that ω 6|= γi. From ωβ = UL(ω, {¬xi,¬yi | 1 ≤ i ≤ n}) and ci ∈ ωβ, if follows that ci ∈ ω. This implies ω 6|= γi ∨ ¬ci, which contradicts ω |= ψn. Thus, β is indeed satisfiable.\nSTEP 2:\nSuppose Update is a polynomial space bounded algorithm of compositional update. Then 3SAT can be solved by an advice taking TM as follows: Given an arbitrary 3CNF β of size n, the machine first loads the advice string Update(ψn, µn) and computes (in polynomial time) ωβ ; then it verifies ωβ |= Update(ψn, µn). Since |ψn| ∈ O(n\n3), |µn| ∈ O(n), and |Update(ψn, µn)| ≤ p(|ψn| + |µn|), we can do the verification in polynomial time. Since Update(ψn, µn) ↔ ψn ⋄c µn, we have ωβ |= ψn ⋄c µn iff ωβ |= Update(ψn, µn). Therefore, β is satisfiable iff ωβ |= Update(ψn, µn). This shows that 3SAT ∈ P/poly. As 3SAT is NP-complete, we have NP ⊆ P/poly.\nProof 20.\n13. A 3-literal clause is clause consists of precisely 3 literals and a 3CNF is a conjunction of 3-literal clauses. 3SAT is the satisfiability problem for 3CNFs, which has been shown NP-complete.\nThis proof is exactly same as that of Theorem 19, as the update formula µn used there is a consistent conjunction of literals.\nProof 21. Since ψ, µ are in dnf, |ψ| = |dnf (ψ)| and |µ| = dnf (µ). Thus |Eliminant(P,ψ)| = O|ψ|. Therefore |Update(ψ, µ)| = O(|ψ| × |µ|).\nIn case |µ| < k, we have |Update(ψ, µ)| = O(|ψ| × k) = O(ψ)."
    } ],
    "references" : [ {
      "title" : "On the logic of theory change: Partial meet functions for contraction and revision",
      "author" : [ "C. Alchourrón", "P. Gärdenfors", "D. Makinson" ],
      "venue" : "Journal of Symbolic Logic,",
      "citeRegEx" : "Alchourrón et al\\.,? \\Q1985\\E",
      "shortCiteRegEx" : "Alchourrón et al\\.",
      "year" : 1985
    }, {
      "title" : "An Investigation of the Laws of Thought",
      "author" : [ "G. Boole" ],
      "venue" : "Walton, London. (Reprinted by Dover Books, New York, 1954).",
      "citeRegEx" : "Boole,? 1854",
      "shortCiteRegEx" : "Boole",
      "year" : 1854
    }, {
      "title" : "Language features for flexible handling of exceptions in information systems",
      "author" : [ "A. Borgida" ],
      "venue" : "ACM Transactions on Database Systems, 10.",
      "citeRegEx" : "Borgida,? 1985",
      "shortCiteRegEx" : "Borgida",
      "year" : 1985
    }, {
      "title" : "How to do things with worlds: On formalizing actions and plans",
      "author" : [ "G. Brewka", "J. Herzberg" ],
      "venue" : "J. Logic Computation,",
      "citeRegEx" : "Brewka and Herzberg,? \\Q1993\\E",
      "shortCiteRegEx" : "Brewka and Herzberg",
      "year" : 1993
    }, {
      "title" : "A taxonomy and current issues in multidatabase systems",
      "author" : [ "M. Bright", "A. Hurson", "S. Pakzad" ],
      "venue" : null,
      "citeRegEx" : "Bright et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Bright et al\\.",
      "year" : 1992
    }, {
      "title" : "Boolean Reasoning",
      "author" : [ "F. Brown" ],
      "venue" : "Kluwer Academic Publishers.",
      "citeRegEx" : "Brown,? 1990",
      "shortCiteRegEx" : "Brown",
      "year" : 1990
    }, {
      "title" : "The size of a revised knowledge base",
      "author" : [ "M. Cadoli", "F.M. Donini", "P. Liberatore", "M. Schaerf" ],
      "venue" : "Proceedings of the fourteenth ACM SIGACT-SIGMODSIGART symposium on Principles of database systems,",
      "citeRegEx" : "Cadoli et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Cadoli et al\\.",
      "year" : 1995
    }, {
      "title" : "Investigations into theory of knowledge base revision",
      "author" : [ "M. Dalal" ],
      "venue" : "In Proceedings of the AAAI National Conference on Artificial Intelligence,",
      "citeRegEx" : "Dalal,? \\Q1988\\E",
      "shortCiteRegEx" : "Dalal",
      "year" : 1988
    }, {
      "title" : "Gricean belief change",
      "author" : [ "J. Delgrande", "A. Nayak", "M. Pagnucco" ],
      "venue" : "Studia Logica,",
      "citeRegEx" : "Delgrande et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2005
    }, {
      "title" : "A consistency-based approach for belief change",
      "author" : [ "J. Delgrande", "T. Schaub" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Delgrande and Schaub,? \\Q2003\\E",
      "shortCiteRegEx" : "Delgrande and Schaub",
      "year" : 2003
    }, {
      "title" : "Compositional belief update",
      "author" : [ "J. Delgrande", "F. Pelletier", "M. Suderman" ],
      "venue" : "In Proceedings of FLAIRS-20,",
      "citeRegEx" : "Delgrande et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2007
    }, {
      "title" : "The PMA and relativizing change for action update",
      "author" : [ "P. Doherty", "W. Lukaszewicz", "E. Madalińska-Bugaj" ],
      "venue" : "Proceedings of the International Conference on the Principles of Knowledge Representation and Reasoning,",
      "citeRegEx" : "Doherty et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Doherty et al\\.",
      "year" : 1998
    }, {
      "title" : "Quota and Gmin merging operators",
      "author" : [ "P. Everaere", "S. Konieczny", "P. Marquis" ],
      "venue" : "In Proceedings of the International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Everaere et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Everaere et al\\.",
      "year" : 2005
    }, {
      "title" : "The strategy-proofness landscape of merging",
      "author" : [ "P. Everaere", "S. Konieczny", "P. Marquis" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Everaere et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Everaere et al\\.",
      "year" : 2007
    }, {
      "title" : "Introducing actions into qualitative simulation",
      "author" : [ "K. Forbus" ],
      "venue" : "Proceedings of the International Joint Conference on Artificial Intelligence, pp. 1273–1278.",
      "citeRegEx" : "Forbus,? 1989",
      "shortCiteRegEx" : "Forbus",
      "year" : 1989
    }, {
      "title" : "Theory contraction through base contraction",
      "author" : [ "A. Fuhrmann" ],
      "venue" : "Journal of Philosophical Logic, 20, 175–203.",
      "citeRegEx" : "Fuhrmann,? 1991",
      "shortCiteRegEx" : "Fuhrmann",
      "year" : 1991
    }, {
      "title" : "Knowledge in Flux: Modelling the Dynamics of Epistemic States",
      "author" : [ "P. Gärdenfors" ],
      "venue" : "The MIT Press, Cambridge, MA.",
      "citeRegEx" : "Gärdenfors,? 1988",
      "shortCiteRegEx" : "Gärdenfors",
      "year" : 1988
    }, {
      "title" : "Propositional belief update and minimal change",
      "author" : [ "A. Herzig", "O. Rifi" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Herzig and Rifi,? \\Q1999\\E",
      "shortCiteRegEx" : "Herzig and Rifi",
      "year" : 1999
    }, {
      "title" : "A catalog of complexity classes",
      "author" : [ "D. Johnson" ],
      "venue" : "van Leeuwen, J. (Ed.), Handbook of Theoretical Computer Science: Volume A: Algorithms and Complexity, pp. 67–161. Elsevier, Amsterdam.",
      "citeRegEx" : "Johnson,? 1990",
      "shortCiteRegEx" : "Johnson",
      "year" : 1990
    }, {
      "title" : "Some connections between non-uniform and uniform complexity classes",
      "author" : [ "R.M. Karp", "R.J. Lipton" ],
      "venue" : "In Proc. of the 12th ACM sym. on Theory of Computing",
      "citeRegEx" : "Karp and Lipton,? \\Q1980\\E",
      "shortCiteRegEx" : "Karp and Lipton",
      "year" : 1980
    }, {
      "title" : "On the difference between updating a knowledge base and revising it",
      "author" : [ "H. Katsuno", "A. Mendelzon" ],
      "venue" : "Belief Revision,",
      "citeRegEx" : "Katsuno and Mendelzon,? \\Q1992\\E",
      "shortCiteRegEx" : "Katsuno and Mendelzon",
      "year" : 1992
    }, {
      "title" : "Merging information under constraints: A logical framework",
      "author" : [ "S. Konieczny", "R. Pino Pérez" ],
      "venue" : "Journal of Logic and Computation,",
      "citeRegEx" : "Konieczny and Pérez,? \\Q2002\\E",
      "shortCiteRegEx" : "Konieczny and Pérez",
      "year" : 2002
    }, {
      "title" : "On the difference between merging knowledge bases and combining them",
      "author" : [ "S. Konieczny" ],
      "venue" : "Cohn, A. G., Giunchiglia, F., & Selman, B. (Eds.), KR2000: Principles of Knowledge Representation and Reasoning, pp. 135–144, San Francisco. Morgan Kaufmann.",
      "citeRegEx" : "Konieczny,? 2000",
      "shortCiteRegEx" : "Konieczny",
      "year" : 2000
    }, {
      "title" : "On the logic of merging",
      "author" : [ "S. Konieczny", "R. Pino Pérez" ],
      "venue" : null,
      "citeRegEx" : "Konieczny and Pérez,? \\Q1998\\E",
      "shortCiteRegEx" : "Konieczny and Pérez",
      "year" : 1998
    }, {
      "title" : "About time, revision, and update",
      "author" : [ "J. Lang" ],
      "venue" : "Dix, J., & Hunter, A. (Eds.), Proceedings of the Eleventh International Workshop on Non-Monotonic Reasoning (NMR 2006).",
      "citeRegEx" : "Lang,? 2006",
      "shortCiteRegEx" : "Lang",
      "year" : 2006
    }, {
      "title" : "Propositional independence : Formulavariable independence and forgetting",
      "author" : [ "J. Lang", "P. Liberatore", "P. Marquis" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Lang et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Lang et al\\.",
      "year" : 2003
    }, {
      "title" : "Arbitration (or how to merge knowledge bases)",
      "author" : [ "P. Liberatore", "M. Schaerf" ],
      "venue" : "IEEE Transactions on Knowledge and Data Engineering,",
      "citeRegEx" : "Liberatore and Schaerf,? \\Q1998\\E",
      "shortCiteRegEx" : "Liberatore and Schaerf",
      "year" : 1998
    }, {
      "title" : "Forget it",
      "author" : [ "F. Lin", "R. Reiter" ],
      "venue" : "In AAAI Fall Symposium on Relevance,",
      "citeRegEx" : "Lin and Reiter,? \\Q1994\\E",
      "shortCiteRegEx" : "Lin and Reiter",
      "year" : 1994
    }, {
      "title" : "On strongest neccessary and weakest sufficient conditions",
      "author" : [ "F. Lin" ],
      "venue" : "Artificial Intelligence, 128 (1-2), 143–159.",
      "citeRegEx" : "Lin,? 2001",
      "shortCiteRegEx" : "Lin",
      "year" : 2001
    }, {
      "title" : "Merging databases under constraints",
      "author" : [ "J. Lin", "A.O. Mendelzon" ],
      "venue" : "International Journal of Cooperative Information Systems,",
      "citeRegEx" : "Lin and Mendelzon,? \\Q1998\\E",
      "shortCiteRegEx" : "Lin and Mendelzon",
      "year" : 1998
    }, {
      "title" : "Merging epistemic states",
      "author" : [ "T. Meyer" ],
      "venue" : "Pacific Rim International Conference on Artificial Intelligence, pp. 286–296.",
      "citeRegEx" : "Meyer,? 2000",
      "shortCiteRegEx" : "Meyer",
      "year" : 2000
    }, {
      "title" : "On the semantics of combination operations",
      "author" : [ "T. Meyer" ],
      "venue" : "Journal of Applied NonClassical Logics, 11 (1-2), 59–84.",
      "citeRegEx" : "Meyer,? 2001",
      "shortCiteRegEx" : "Meyer",
      "year" : 2001
    }, {
      "title" : "Forgetting and knowledge update",
      "author" : [ "A. Nayak", "Y. Chen", "F. Lin" ],
      "venue" : "Proceedings of the Nineteenth Australian Joint Conference of Artificial Intelligence (AI-06),",
      "citeRegEx" : "Nayak et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Nayak et al\\.",
      "year" : 2006
    }, {
      "title" : "Beliefs, belief revision, and splitting languages",
      "author" : [ "R. Parikh" ],
      "venue" : "Moss, L., Ginzburg, J., & de Rijke, M. (Eds.), Logic, Language and Computation, Vol 2, pp. 266–278. CSLI Publications.",
      "citeRegEx" : "Parikh,? 1999",
      "shortCiteRegEx" : "Parikh",
      "year" : 1999
    }, {
      "title" : "Distance semantics for relevance-sensitive belief revision. In KR2004: Principles of Knowledge Representation and Reasoning, San Francisco",
      "author" : [ "P. Peppas", "S. Chopra", "N. Foo" ],
      "venue" : null,
      "citeRegEx" : "Peppas et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Peppas et al\\.",
      "year" : 2004
    }, {
      "title" : "On the semantics of theory change: Arbitration between old and new information",
      "author" : [ "P. Revesz" ],
      "venue" : "Beeri, C. (Ed.), Proceedings of the Twelth ACM Symposium on Principles of Database Systems, pp. 71–82, Washington D.C.",
      "citeRegEx" : "Revesz,? 1993",
      "shortCiteRegEx" : "Revesz",
      "year" : 1993
    }, {
      "title" : "Severe withdrawal (and recovery)",
      "author" : [ "H. Rott", "M. Pagnucco" ],
      "venue" : "Journal of Philosophical Logic,",
      "citeRegEx" : "Rott and Pagnucco,? \\Q1999\\E",
      "shortCiteRegEx" : "Rott and Pagnucco",
      "year" : 1999
    }, {
      "title" : "Nonmonotonic reasoning by minimal belief revision",
      "author" : [ "K. Satoh" ],
      "venue" : "Proceedings of the International Conference on Fifth Generation Computer Systems, pp. 455–462, Tokyo.",
      "citeRegEx" : "Satoh,? 1988",
      "shortCiteRegEx" : "Satoh",
      "year" : 1988
    }, {
      "title" : "Amalgamating knowledge bases",
      "author" : [ "S. Subrahmanian" ],
      "venue" : "ACM Transactions on Database Systems, 19, 291–331.",
      "citeRegEx" : "Subrahmanian,? 1994",
      "shortCiteRegEx" : "Subrahmanian",
      "year" : 1994
    }, {
      "title" : "On having bad contractions or: No room for recovery",
      "author" : [ "N. Tennant" ],
      "venue" : "Journal of Applied Non-Classical Logic, 7, 241–266.",
      "citeRegEx" : "Tennant,? 1997",
      "shortCiteRegEx" : "Tennant",
      "year" : 1997
    }, {
      "title" : "Updating propositional formulas",
      "author" : [ "A. Weber" ],
      "venue" : "Proc. First Conference on Expert Database Systems, pp. 487–500.",
      "citeRegEx" : "Weber,? 1986",
      "shortCiteRegEx" : "Weber",
      "year" : 1986
    }, {
      "title" : "Towards a practical approach to belief revision: Reason-based change",
      "author" : [ "Williams", "M.-A." ],
      "venue" : "Aiello, L., Doyle, J., & Shapiro, S. (Eds.), Proceedings of the Fifth International Conference on the Principles of Knowledge Representation and Reasoning, pp. 412–421, Cambridge, MA.",
      "citeRegEx" : "Williams and M..A.,? 1996",
      "shortCiteRegEx" : "Williams and M..A.",
      "year" : 1996
    }, {
      "title" : "Reasoning about action using a possible models approach",
      "author" : [ "M. Winslett" ],
      "venue" : "Proceedings of the AAAI National Conference on Artificial Intelligence, pp. 89–93, St. Paul, Minnesota.",
      "citeRegEx" : "Winslett,? 1988",
      "shortCiteRegEx" : "Winslett",
      "year" : 1988
    }, {
      "title" : "Updating Logical Databases",
      "author" : [ "M. Winslett" ],
      "venue" : "Cambridge University Press, Cambridge.",
      "citeRegEx" : "Winslett,? 1990",
      "shortCiteRegEx" : "Winslett",
      "year" : 1990
    } ],
    "referenceMentions" : [ {
      "referenceID" : 16,
      "context" : "Initially, in the AGM approach (Alchourrón, Gärdenfors, & Makinson, 1985; Gärdenfors, 1988), standards for belief revision and contraction functions were given, wherein it was assumed that a knowledge base is receiving information concerning a static1 domain, and that it is the increased amount or accuracy of information that is responsible for the changes in the knowledge base.",
      "startOffset" : 31,
      "endOffset" : 91
    }, {
      "referenceID" : 15,
      "context" : "Initially, in the AGM approach (Alchourrón, Gärdenfors, & Makinson, 1985; Gärdenfors, 1988), standards for belief revision and contraction functions were given, wherein it was assumed that a knowledge base is receiving information concerning a static1 domain, and that it is the increased amount or accuracy of information that is responsible for the changes in the knowledge base. Subsequently, Katsuno and Mendelzon (1992) explored a distinct notion of belief change, with functions for belief update and erasure, wherein an agent changes its beliefs in response to what it perceives as changes in the environment.",
      "startOffset" : 44,
      "endOffset" : 425
    }, {
      "referenceID" : 1,
      "context" : "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions.",
      "startOffset" : 42,
      "endOffset" : 55
    }, {
      "referenceID" : 1,
      "context" : "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions.",
      "startOffset" : 42,
      "endOffset" : 114
    }, {
      "referenceID" : 1,
      "context" : "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions.",
      "startOffset" : 42,
      "endOffset" : 129
    }, {
      "referenceID" : 1,
      "context" : "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a “merged” knowledge base that best represents the information in a set of other knowledge bases.",
      "startOffset" : 42,
      "endOffset" : 753
    }, {
      "referenceID" : 1,
      "context" : "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a “merged” knowledge base that best represents the information in a set of other knowledge bases. One use for this was thought to be a way of determining a course of action that best represents the “desires” and “goals” of a divergent set of knowledge bases, thereby forming a group-level, all-things-considered knowledge base. The formal properties of merging have been discussed in previous works (e.g., see Lin & Mendelzon, 1998; Konieczny & Pino Pérez, 1998; Everaere, Konieczny, & Marquis, 2007). The distinctions between the formal properties of the different types of change were brought out in each of the papers after the initial AGM publications; for instance, Katsuno and Mendelzon (1992) compared update with revision; Konieczny and Pino Pérez (1998) compared merging with revision; Nayak et al.",
      "startOffset" : 42,
      "endOffset" : 1493
    }, {
      "referenceID" : 1,
      "context" : "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a “merged” knowledge base that best represents the information in a set of other knowledge bases. One use for this was thought to be a way of determining a course of action that best represents the “desires” and “goals” of a divergent set of knowledge bases, thereby forming a group-level, all-things-considered knowledge base. The formal properties of merging have been discussed in previous works (e.g., see Lin & Mendelzon, 1998; Konieczny & Pino Pérez, 1998; Everaere, Konieczny, & Marquis, 2007). The distinctions between the formal properties of the different types of change were brought out in each of the papers after the initial AGM publications; for instance, Katsuno and Mendelzon (1992) compared update with revision; Konieczny and Pino Pérez (1998) compared merging with revision; Nayak et al.",
      "startOffset" : 42,
      "endOffset" : 1556
    }, {
      "referenceID" : 1,
      "context" : "The concept of forget goes back to George Boole (1854), but was reintroduced in the work of Lin and Reiter (1994) and Lin (2001) as a way to characterize how an agent may bring its knowledge base up-to-date, by forgetting about facts that are no longer relevant and in such a way as to not affect any possible future actions. This approach is syntactic in nature: it deals with the issue of removing facts by removing the ability to describe the facts.2 Finally, the notion of knowledge base merging was introduced as a generalization of the long-standing problem of information sharing between databases, where different databases might contain conflicting information (see Bright, Hurson, & Pakzad, 1992, for a survey). With the work of Revesz (1993), there came an interest in constructing a “merged” knowledge base that best represents the information in a set of other knowledge bases. One use for this was thought to be a way of determining a course of action that best represents the “desires” and “goals” of a divergent set of knowledge bases, thereby forming a group-level, all-things-considered knowledge base. The formal properties of merging have been discussed in previous works (e.g., see Lin & Mendelzon, 1998; Konieczny & Pino Pérez, 1998; Everaere, Konieczny, & Marquis, 2007). The distinctions between the formal properties of the different types of change were brought out in each of the papers after the initial AGM publications; for instance, Katsuno and Mendelzon (1992) compared update with revision; Konieczny and Pino Pérez (1998) compared merging with revision; Nayak et al. (2006) compared forgetting with update.",
      "startOffset" : 42,
      "endOffset" : 1608
    }, {
      "referenceID" : 24,
      "context" : "Further considerations on how revision and update are interrelated are in the work of Lang (2006). 2.",
      "startOffset" : 86,
      "endOffset" : 98
    }, {
      "referenceID" : 24,
      "context" : "Further considerations on how revision and update are interrelated are in the work of Lang (2006). 2. Nayak, Chen, and Lin (2006) described this difference thus: “While belief erasure purports to answer the question ‘What should I believe if I can no longer support the belief that the cook killed Cock Robin?’, forgetting purports to answer the question ‘What should I believe if Killing was a concept not afforded in my language?’.",
      "startOffset" : 86,
      "endOffset" : 130
    }, {
      "referenceID" : 2,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.",
      "startOffset" : 80,
      "endOffset" : 121
    }, {
      "referenceID" : 7,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.",
      "startOffset" : 80,
      "endOffset" : 121
    }, {
      "referenceID" : 37,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.",
      "startOffset" : 80,
      "endOffset" : 121
    }, {
      "referenceID" : 14,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.",
      "startOffset" : 137,
      "endOffset" : 180
    }, {
      "referenceID" : 40,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.",
      "startOffset" : 137,
      "endOffset" : 180
    }, {
      "referenceID" : 42,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.",
      "startOffset" : 137,
      "endOffset" : 180
    }, {
      "referenceID" : 38,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.",
      "startOffset" : 197,
      "endOffset" : 272
    }, {
      "referenceID" : 22,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al.",
      "startOffset" : 197,
      "endOffset" : 272
    }, {
      "referenceID" : 32,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al., 2006).",
      "startOffset" : 289,
      "endOffset" : 344
    }, {
      "referenceID" : 33,
      "context" : "The focus here is on the form of the formula for update; presumably the approach described may be combined with one in which the knowledge base is itself divided into relevant and irrelevant parts for an update (Parikh, 1999).",
      "startOffset" : 211,
      "endOffset" : 225
    }, {
      "referenceID" : 25,
      "context" : "As well, the general approach to update presented here can capture the forget operator (Lin & Reiter, 1994; Lang et al., 2003; Nayak et al., 2006), and so in a certain sense can be regarded as generalizing forget.",
      "startOffset" : 87,
      "endOffset" : 146
    }, {
      "referenceID" : 32,
      "context" : "As well, the general approach to update presented here can capture the forget operator (Lin & Reiter, 1994; Lang et al., 2003; Nayak et al., 2006), and so in a certain sense can be regarded as generalizing forget.",
      "startOffset" : 87,
      "endOffset" : 146
    }, {
      "referenceID" : 16,
      "context" : "Although our focus in this paper is with update — and hence with the postulates given by Katsuno and Mendelzon (1992) and the objections related to these postulates — we believe that considerations similar to the ones we bring forward in this arena would hold with respect to the other sorts of belief change postulates.",
      "startOffset" : 89,
      "endOffset" : 118
    }, {
      "referenceID" : 2,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al., 2006). These approaches are formulated in terms of the distance between models of the knowledge base and models of a sentence for revision or update. In general there has been less work dealing with systems that may be readily implementable (but see, e.g., Williams, 1996; Delgrande & Schaub, 2003). In this paper we develop a specific update operator where the operator is intended to be compositional, in that an update ψ ⋄μ can be expressed recursively in terms of the syntactic structure of μ. Thus, if a knowledge base is to be updated by a disjunction μ = a ∨ b, the idea is that this update will be a function of the update by a in a certain combination with the update by b. The update of the knowledge base by a conjunction μ = a ∧ b will also be a function (a different one) of the update by a in combination with the update by b. The goal is to arrive at an operator whose results are intuitive, in that its definition is based on a recursive decomposition of a formula; hence the (generally abstract) notion of update will be anchored in part in a more familiar computational setting. Second, the hope is that these operators will be efficiently implementable, at least in some cases, by exploiting restrictions to the syntactic form of the formula. The focus here is on the form of the formula for update; presumably the approach described may be combined with one in which the knowledge base is itself divided into relevant and irrelevant parts for an update (Parikh, 1999). These goals are generally realised. First, the operators have reasonable properties: many of the Katsuno and Mendelzon benchmark properties are satisfied, including those deemed essential by Herzig and Rifi (1999). While we don’t obtain full irrelevance of syntax, we do obtain weaker results in this regard; as well we show how irrelevance of syntax can be obtained by restricting the syntactic form of the sentence for update.",
      "startOffset" : 81,
      "endOffset" : 2042
    }, {
      "referenceID" : 2,
      "context" : "Various researchers have proposed specific change operators for belief revision (Borgida, 1985; Dalal, 1988; Satoh, 1988), belief update (Forbus, 1989; Weber, 1986; Winslett, 1988), belief merging (Subrahmanian, 1994; Konieczny, 2000; Everaere, Konieczny, & Marquis, 2005), and forgetting (Lang, Liberatore, & Marquis, 2003; Nayak et al., 2006). These approaches are formulated in terms of the distance between models of the knowledge base and models of a sentence for revision or update. In general there has been less work dealing with systems that may be readily implementable (but see, e.g., Williams, 1996; Delgrande & Schaub, 2003). In this paper we develop a specific update operator where the operator is intended to be compositional, in that an update ψ ⋄μ can be expressed recursively in terms of the syntactic structure of μ. Thus, if a knowledge base is to be updated by a disjunction μ = a ∨ b, the idea is that this update will be a function of the update by a in a certain combination with the update by b. The update of the knowledge base by a conjunction μ = a ∧ b will also be a function (a different one) of the update by a in combination with the update by b. The goal is to arrive at an operator whose results are intuitive, in that its definition is based on a recursive decomposition of a formula; hence the (generally abstract) notion of update will be anchored in part in a more familiar computational setting. Second, the hope is that these operators will be efficiently implementable, at least in some cases, by exploiting restrictions to the syntactic form of the formula. The focus here is on the form of the formula for update; presumably the approach described may be combined with one in which the knowledge base is itself divided into relevant and irrelevant parts for an update (Parikh, 1999). These goals are generally realised. First, the operators have reasonable properties: many of the Katsuno and Mendelzon benchmark properties are satisfied, including those deemed essential by Herzig and Rifi (1999). While we don’t obtain full irrelevance of syntax, we do obtain weaker results in this regard; as well we show how irrelevance of syntax can be obtained by restricting the syntactic form of the sentence for update. The approach is also related to other approaches in the literature, and hence serves to establish some links between approaches. In fact, the family of compositional update operators obtained by imposing various syntactic restrictions can be regarded as constituting a family of operators of which Winslett’s standard semantics makes up the most basic nontrivial approach. As well, the general approach to update presented here can capture the forget operator (Lin & Reiter, 1994; Lang et al., 2003; Nayak et al., 2006), and so in a certain sense can be regarded as generalizing forget. We also define a revision operator using the obvious definition for such an operator; it proves to be the case that this operator corresponds with the revision operator in the work of Satoh (1988).",
      "startOffset" : 81,
      "endOffset" : 3041
    }, {
      "referenceID" : 0,
      "context" : "2 Belief Revision and Contraction In the seminal approach of AGM (Alchourrón et al., 1985), postulates are proposed to constrain belief revision.",
      "startOffset" : 65,
      "endOffset" : 90
    }, {
      "referenceID" : 0,
      "context" : "2 Belief Revision and Contraction In the seminal approach of AGM (Alchourrón et al., 1985), postulates are proposed to constrain belief revision. In this approach, a knowledge base K is assumed to be a belief set, a set of sentences closed under logical consequence. The revision of a belief set by a formula, K ∗φ, is a new belief set in which the formula φ is believed. The interesting case is that in which ¬φ is initially believed, and so to attain a consistent belief set (assuming that φ is satisfiable), some beliefs have to be dropped. Exactly which beliefs must be dropped is not stipulated in the AGM approach; however, constraints in the form of postulates that govern what are seen as legitimate revision operators are given. In contrast, in their development of belief update Katsuno and Mendelzon (1992) represented the knowledge base by a formula in some language L.",
      "startOffset" : 66,
      "endOffset" : 818
    }, {
      "referenceID" : 20,
      "context" : "” But a different picture was put forward by Katsuno and Mendelzon (1992), where there was a “changing, dynamic world”.",
      "startOffset" : 45,
      "endOffset" : 74
    }, {
      "referenceID" : 17,
      "context" : "Herzig and Rifi (1999) discussed the plausibility of the postulates given; they assert that U2, U5, and U6 are undesirable, while U7 is unimportant.",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 42,
      "context" : "The first, the Possible Models Approach (PMA) of (Winslett, 1988) is a well-known example of an update operator satisfying the Katsuno and Mendelzon update postulates.",
      "startOffset" : 49,
      "endOffset" : 65
    }, {
      "referenceID" : 43,
      "context" : "The second, the standard semantics of (Winslett, 1990) is a weak (in fact, arguably the weakest reasonable) approach to update.",
      "startOffset" : 38,
      "endOffset" : 54
    }, {
      "referenceID" : 43,
      "context" : "The operator ψ ⋄ss μ is the weakest “reasonable” update operator in the following sense (Winslett, 1990): First, for an update ψ ⋄ss μ, μ is true in every model of ψ ⋄ss μ.",
      "startOffset" : 88,
      "endOffset" : 104
    }, {
      "referenceID" : 1,
      "context" : "The notion of forgetting goes back to George Boole (1854), though it has received more recent attention in Artificial Intelligence by, e.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 1,
      "context" : "Then the usual definition for forgetting (again, going back to Boole) atom p in ψ is given by ψ[p/⊤] ∨ ψ[p/⊥]. In order to forget a set of atoms Γ, one takes the disjunction of the substitution of all 2|Γ| combinations of ⊤, ⊥ for elements of Γ. We have the following definitions. For single atoms we basically follow Nayak et al. (2006); for sets of atoms we use the definition from (Lin & Reiter, 1994).",
      "startOffset" : 63,
      "endOffset" : 338
    }, {
      "referenceID" : 30,
      "context" : "(M3) If E1 and E2 are knowledge sets such that E1 ↔ E2, then △(E1) ↔ △(E2) (M4) If K1 and K2 are knowledge bases that are not mutually consistent, then △(K1 ⊔ K2) 6⊢ K1 (M5) △(E1) ∧△(E2) ⊢ △(E1 ⊔ E2) (M6) If △(E1) ∧△(E2) is consistent, then △(E1 ⊔ E2) ⊢ △(E1) ∧△(E2) Some of these merging postulates have been contested: For example, Meyer (2000) argued that M4 and M6 should be rejected.",
      "startOffset" : 334,
      "endOffset" : 347
    }, {
      "referenceID" : 23,
      "context" : "Liberatore and Schaerf (1998) introduced the method of arbitration, whereby the goal is to adopt as many different opinions as possible from the members of the knowledge set (“try to take as many differing opinions as possible into account”).",
      "startOffset" : 0,
      "endOffset" : 30
    }, {
      "referenceID" : 20,
      "context" : "Konieczny and Pino Pérez (1998) proved that there is no arbitration operator (at least, not of the sort that they characterize) that obeys M1 – M6.",
      "startOffset" : 0,
      "endOffset" : 32
    }, {
      "referenceID" : 12,
      "context" : "6 The interplay between various merging operations and the ability of an agent to hide, lie, or otherwise camouflage its preferences from other agents as they try to construct a merged knowledge base has been surveyed in Everaere et al. (2007).",
      "startOffset" : 221,
      "endOffset" : 244
    }, {
      "referenceID" : 37,
      "context" : "Satoh’s (1988) revision operator ψ ∗S μ is defined as follows.",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 7,
      "context" : "It follows as a straightforward corollary that if we use a distance metric based on the number of differing propositional symbols between two interpretations, we obtain the revision operator of (Dalal, 1988).",
      "startOffset" : 194,
      "endOffset" : 207
    }, {
      "referenceID" : 28,
      "context" : "This appears to make sense, because by updating by b ∨m we are really telling the knowledge base that the world has changed so that one of b ∧m or b ∧ ¬m or ¬b ∧m is true. Thus, in this case the update operator behaves like the Gricean belief change operator of Delgrande, Nayak, and Pagnucco (2005), where the goal is to incorporate all and only the new information.",
      "startOffset" : 73,
      "endOffset" : 300
    }, {
      "referenceID" : 2,
      "context" : "Borgida (1985) employed a similar definition with respect to a revision operator.",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 17,
      "context" : "Our update operator satisfies those postulates deemed desirable by Herzig and Rifi (1999), with the exception of U4.",
      "startOffset" : 67,
      "endOffset" : 90
    }, {
      "referenceID" : 5,
      "context" : "ψ)) (Brown, 1990).",
      "startOffset" : 4,
      "endOffset" : 17
    }, {
      "referenceID" : 11,
      "context" : "The idea is quite similar to that of (Doherty et al., 1998).",
      "startOffset" : 37,
      "endOffset" : 59
    }, {
      "referenceID" : 5,
      "context" : "As proposed by Brown (1990), an eliminant ∃P.",
      "startOffset" : 15,
      "endOffset" : 28
    }, {
      "referenceID" : 18,
      "context" : "To this end, we need to introduce so-called advice-taking Turing machine (TM) and non-uniform complexity class, see (Johnson, 1990).",
      "startOffset" : 116,
      "endOffset" : 131
    } ],
    "year" : 2008,
    "abstractText" : "In this paper we explore a class of belief update operators, in which the definition of the operator is compositional with respect to the sentence to be added. The goal is to provide an update operator that is intuitive, in that its definition is based on a recursive decomposition of the update sentence’s structure, and that may be reasonably implemented. In addressing update, we first provide a definition phrased in terms of the models of a knowledge base. While this operator satisfies a core group of the benchmark Katsuno-Mendelzon update postulates, not all of the postulates are satisfied. Other Katsuno-Mendelzon postulates can be obtained by suitably restricting the syntactic form of the sentence for update, as we show. In restricting the syntactic form of the sentence for update, we also obtain a hierarchy of update operators with Winslett’s standard semantics as the most basic interesting approach captured. We subsequently give an algorithm which captures this approach; in the general case the algorithm is exponential, but with some not-unreasonable assumptions we obtain an algorithm that is linear in the size of the knowledge base. Hence the resulting approach has much better complexity characteristics than other operators in some situations. We also explore other compositional belief change operators: erasure is developed as a dual operator to update; we show that a forget operator is definable in terms of update; and we give a definition of the compositional revision operator. We obtain that compositional revision, under the most natural definition, yields the Satoh revision operator.",
    "creator" : "dvips(k) 5.96 Copyright 2005 Radical Eye Software"
  }
}