{
  "name" : "1406.5301.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Low-Autocorrelation Binary Sequences: on the Performance of Memetic-Tabu and Self-Avoiding Walk Solvers∗",
    "authors" : [ "Borko Bošković", "Franc Brglez", "Janez Brest" ],
    "emails" : [ "borko.boskovic@uni-mb.si", "brglez@ncsu.edu", "janez.brest@uni-mb.si" ],
    "sections" : [ {
      "heading" : null,
      "text" : "To mitigate the computational constraints of the labs problem, we consider solvers that accept odd values of L and return solutions for skew-symmetric binary sequences only – with the consequence that not all best solutions under this constraint will also be optimal for each value of L. Specifically, we have instrumented three such solvers for extensive average-case asymptotic performance experiments. Two solvers are based on the version from 2009; both differ only in one respect: the 2009 solver uses an evolutionary algorithm to initialize the tabu search, the modified solver initializes the tabu search with a random binary sequence. What has not been expected is that the asymptotic average-case performance of the first and the second solver are statistically equivalent: for the range 71 <= L <= 127 we observe 150.49 ∗ 1.1646L for the memetic-tabu version versus 156.34 ∗ 1.1646L for the random-tabu version. Thus, for the labs problem, the evolutionary component of this solver is not effective.\nOur solver relies on a single contiguous self-avoiding walk until memory constraints induce random restarts. Under random restarts, the solver reaches the target value with a number of independent contiguous self-avoiding walk segments. Under the fixed walk segment compromise and random restarts, we observe 650.07 ∗ 1.1435L for the range 71 ≤ L ≤ 127. We show that the solver with the best average-case asymptotic performance has the best chance of finding new solutions that significantly improve, as L increases, figures of merit reported to date.\nI. Introduction\nThe aperiodic low-autocorrelation binary sequence (labs) problem has a simple formulation: take a binary sequence of length L, S = s1s2 . . . sL, si ∈ {+1,−1}, the autocorrelation function Ck(S) = ∑L−k i=1 sisi+k, and minimize the energy function:\nE(S) = L−1∑ k=1 C2k(S) (1)\nor alternatively, maximize the merit factor F: [1, 2, 3]:\nF (S) = L2/(2E(S)). (2)\nFinding a binary sequence with best merit factor has important applications in communication engineering. To physicists, the optimum solution of the labs problem\ncorresponds to the ground state of a generalized onedimensional Ising spin system with long range 4-spin interactions [4], also known as the Bernasconi model with aperiodic autocorrelation.\nThe asymptotic value for the maximum merit factor F , introduced in [2], has been re-derived using arguments from statistical mechanics [4]:\nas L→∞, then F → 12.3248 (3)\nThe publication of the asymptotic value in (3) is providing an on-going challenge since no published solutions can yet claim to converge to this value as the length of the sequence increases.\nFinding the optimum sequence is NP-hard or worse, unlike the special cases of the Ising spin-glass problems\n∗Borko Bošković and Janez Brest have been supported, in part, by the Slovenian Research Agency under the Program P2-0041, Computer Systems, Methodologies, and Intelligent Services.\nar X\niv :1\n40 6.\n53 01\nv1 [\ncs .D\nS] 2\n0 Ju\nn 20\n14\nwith limited interaction and periodic boundary conditions, for example [7]. While effective methods have been presented to solve the special cases up to L = 400 [7], the best merit factors that has also been proven optimal for the problem as formulated in (2) are presently known for values of L ≤ 60 only [8]. A web page of labs best merit factors and solutions, up to the sequence length of L = 304, has been compiled by Joshua Knauer in 2002. This page is no longer accessible and has now been restored at two mirroring sites [6] next to additional and comprehensive tables of best-value solutions. These tables contain not only updates on the best known figures of merit but also on the number of unique solutions in canonic form and the solutions themselves. To visualize the differences between the optimum value, the best known energy values, and the projected values, we use the deviation-vs-length plot introduced in [5]. The reference values in this plot and the regression line in Figure 1 have been calculated from the energy values of best results posted under [6]. The approaches to solving the labs problem also include exhaustive enumeration, for both even and odd sequences or only for skew-symmetric sequences which are odd by definition [1, 2, 3, 9]. Exact solutions were also pursued by branch and bound solvers: for both even and odd sequences [8] and for skew-symmetric sequences only [10]. On the other hand, stochastic solvers, both for even and odd values of L or just for sequences under skewsymmetry, can scale to larger values than branch-andbound counterparts. Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19]. Experimental results obtained with our stochastic solver lssOrel are compared to the instrumented versions of two solvers in [19], referred to as 2009 solvers in the abstract, and named as\nlMAts and lssMAts in this paper1. In contrast, the body of literature in theory on the merit factor problem for binary sequences is considerable. However, merit factors obtained by approaches in theory [20, 21] are reported at values less than 7 – so the challenge of finding long sequences that would approach the asymptotic value for the maximum merit factor F = 12.3248 in Eq. 3 remains open for experimentalists as well as theoreticians.\nThe paper is organized as follows. Section II introduces notation, definitions, and examples that motivate the approach taken in this paper. Section III highlights details about three labs solvers as they are instrumented for comparative performance experiments to measure, in a platform-independent manner, solver’s asymptotic performance as the size of the labs problem increases. Section IV summarizes results of extensive experiments with these solvers, including bounds and projections for computational resources needed to increase the likelihood of finding better solutions of the labs problem for sizes L > 141. The paper concludes with a section that outlines directions for future work.\nII. Notation and Definitions\nThis section follows notation, definitions, and metaphors introduced in [22] and [23]. The first paper defines Hasse graphs and relates them to average-case performance of combinatorial optimization algorithms, the second paper demonstrates merits of long and entirely contiguous self-avoding walks which are searching, under concatenation of binary and ternary coordinates, for the maximum number of bonds in the 2D protein folding problem. Combined, these papers also support a simple and intuitive introduction of the self-avoding walk segments as the key component of an effective strategy which we apply to finding best solution to instances of the labs problem in this paper. There are two illustrations of such walks: a small one in Figure 2 at the end of this section, and a larger instance in Section III where, in Figure 5, we compare a self-avoiding walk induced by our solver lssOrel with a walk based on tabu search induced by the solver lssMAts [19]. We proceed with a brief reprise of notation and definitions, some of them extended to specifics of the labs problem.\nSolution as a coordinate-value pair. While the energy of the autocorrelation function as defined in Eq. 1 may be simple to interpret in terms of binary symbols si ∈ {+1,−1}, we define, for the remainder of the paper,\nany solution of Eq. 1 as a coordinate-value pair in the form ς : Θ(ς) (4) where ς is a binary string of length L, also denoted as the coordinate from [0, 1]L, and Θ(ς) is the value associated with this coordinate.\nExamples of coordinate-value pairs are shown in Table 1. Specifically, for instance sizes of L = 8, 9, 13, these pairs represent two quadrants from the complete sets of optimal solutions, listed in lexicographical order, under coordinate prefixes of ‘00’ and ‘01’, as the coordBest and valueBest pairs ς∗ : Θ(ς∗) (5) We could extend the solutions to more quadrants, under coordinate prefixes of ‘11’ and ‘10’, by simply taking a binary complement of the solutions shown in Table 1. Coordinate distance. The distance between two binary coordinates a and b is defined as the Hamming distance:\nd(a, b) = L∑\ni=1 ai ⊕ bi (6)\nCoordinate symmetries. There are four coordinate transformations that reveal the symmetries of the labs problem function as formulated in Eq. 1:\ncomplementation: For example, the complement of 0000011001010 is 1111100110101 reversal: For example, the reversal of 0000011001010 is 0101001100000 symmetry: For example, for L even, the value of sym = 1 in Table 1 implies that 011110 is symmetric compared to L/2 without coordinate complementation. However, the value of sym = 2 in Table 1 implies that 001011 is symmetric compared to L/2 with coordinate complementation and reversal. skew-symmetry: Skew-symmetry is defined for odd values of L only and the solution of the labs problem can be expressed with coordinates that are significantly reduced in size:\nL′ = (L+ 1)/2− λ\nwhere λ = 0, 1, 2, ... and λ = 2 implies the size of the coordinate prefix such as ‘00’ or ‘01’. For example, the value of ssym = 1 in Table 1 implies that 0000011001010 is skewsymmetric since (L− 1)/2 left-most coordinates and (L− 1)/2 right-most coordinates\n1The generosity of authors to provide the source code for these two solvers is greatly appreciated. The robust performance of the solvers has revealed additional insights about the labs problem, also included as new data points in our summary of results.\n(†) The value of L denotes not only the instance size of the labs problem but also the size of the binary coordinate. A binary coordinate of size L has L immediate neighbors or adjacent coordinates, with distance of 1 from each neighbor. The neighborhood size for a set mL coordinates that represent the number of global minima in a quadrant is computed as L×mL − r where r is the number of replicated coordinates produced while generating neighborhood coordinates. When evaluating neighborhoods of L = 8 and L = 9, there are 4 and 7 replicated neighborhood coordinates, thus values of neighbSize are 28 and 47, respectively.\nare skew-symmetric under coordinate reversal. However, the value of ssym = 2 in Table 1 implies that 0001101 is skew-symmetric since (L−1)/2 left-most coordinates and (L−1)/2 right-most coordinates are skew-symmetric without coordinate reversal.\nSkew-symmetry. Formally, skew-symmetry has been introduced in [1]. Here, we paraphrase the skew-symmetry definition in terms of binary coordinate components bk and their complements bk:\nbL′+i = { bL′−i if i = 1, 3, 5, ... bL′−i if i = 2, 4, 6, ...\n(7)\nFor example, a coordinate 0000011 of length L′ = 7 under skew-symmetry represents a labs problem coordinate 0000011001010 of length L = 13 – here the right-most 6 bits have been computed using Eq. 7. Not every optimal solution for odd values of L is also skew-symmetric, a fact revealed also in Table 5.\nThe introduction of skew-symmetry significantly reduces the computational complexity of the labs problem. Only recently, a branch-and-bound solver [10] extended known optimal solutions for skew-symmetric sequences from length 73 to 89. However, even under skewsymmetry, only stochastic solvers have demonstrated the\npotential to find improved, if not optimal solutions, as L increases to 201 and beyond. Canonic solutions and best upper bounds. The symmetries of the labs problem partition the solution space into 4 quadrants with coordinate prefixes of 00, 01, 10, and 11. Without loss of generality, we transform the coordinates of all optimal or best value solutions found in quadrants 01, 10, 11 to the quadrant 00 and denote the set of unique optimal coordinate:value solution pairs in the quadrant 00 as the canonic solutions set. For a given L, only the coordinates in this set are unique; the optimum or the best known value, also denoted as the best upper bound ΘubL , is the same for each coordinate in this set. We say that mL is the cardinality of canonic solutions set and that ΘubL is the best upper bound we associate with the labs instance of size L. Distance=1 neighborhood. The distance=1 neighborhood of a coordinate ςj is a set of coordinates\nN (ςj) = { ς i j | d(ςj , ς i j) = 1, i = 1, 2, . . . ,L } (8)\nInformally, a binary coordinate ςj of size L, also called a pivot coordinate, has L neighbors, each a distance of 1 from the pivot coordinate. In Table 1, instances with L = 7 and L = 13 have a single solution in each quadrant, and hence also neighborhoods of size 7 and 13, respectively. For instances were the cardinality of canonic solutions\nmL > 1, some of the neighborhood coordinates may be replicated, so adjustments are needed when computing the size such neighborhoods:\nL×mL − r\nwhere r is the number of replicated coordinates produced while generating neighborhood coordinates. For examples of such computations, see Table 1. Contiguous walks and pivot coordinates. Let the coordinate ς0 be the initial coordinate from which the walk takes the first step. Then the sequence\n{ς0, ς1, ς2, . . . , ςj , . . . , ςω} (9)\nis called a walk list or a walk of length ω, the coordinates ςj are denoted as pivot coordinates and Θ(ςj) are denoted as pivot values. Given an instance of size L and its best upper bound ΘubL , we say that the walk reaches its target value (and stops) when Θ(ςω) ≤ Θ ub L .\nWe say that the walk is contiguous if the distance between adjacent pivots is 1; i.e., given Eq. 6, we find\nd(ςj , ςj−1) = 1, j = 1, 2, ...,ω (10)\nSelf-avoiding walks (SAWs). We say that the walk is self-avoiding if all pivots in Eq. 10 are unique. We say that the walk is composed of two or more walk segments if the initial pivot of each walk segment has been induced by a well-defined heuristic such as random restarts, a heuristic associated also with all solvers described in this paper. Walk segments can be of different lengths and if viewed independently of other walks, may be self-avoiding or not. A walk composed of two or more self-avoiding walk segments may no longer be a self-avoiding walk, since some of the pivots may overlap and also form cycles. Also, a walk composed of two or more self-avoiding walk segments is almost certainly no longer a contiguous walk – this illustrated after we define the Hasse graph below. Hasse graph. Hasse graph has been defined in [22, 23] as a model of hyperhedron (or informally, a dice) based on an extension of the Hasse diagram. In the case of the labs problem, Hasse graph has is an undirected labeled graph with 2L vertices and L× 2L−1 edges; the degree of each vertex is L and the label is the pair ς : Θ(ς) as defined in Eq. 4. By projecting this graph with its labeled vertices onto a plane, we can not only illustrate concepts of coordinate/pivot neighborhoods but also specific walks as a combinatorial search heuristics.\nFigure 2 illustrates not only two Hasse graphs, with each vertex displaying a coordinate:value; it also illustrates that the target value can be reached either by a\nsequence of three shorter SAW segments (each segment represents a contiguous SAW) or by a single contiguous SAW. The three contiguous self-avoiding walk segments in Figure 2-a have lengths of 7, 7, and 4 , covering a total of 19 vertices in 18+2=20 steps. We add two steps since the second and the third walk segment are induced by two restarts. Just as the pivot ς0 is the initial pivot for the first step in the first walk, pivots ς7 and ς15 are taken as initial pivots for the first step in the second walk and the first step in the third walk, respectively. Here is a linear depiction of the 19 vertices and three walk segments.\n• • • • • • • •︸ ︷︷ ︸ 7 • • • • • • •︸ ︷︷ ︸ 7 • • • •︸ ︷︷ ︸ 4\nTo keep the Hasse graph less cluttered, the steps of the walk that are induced by two restarts are not shown with additional edges. We denote such steps as jump steps since the distance between pivots may exceeds 1. For example, d(ς8, ς7) = d(10100, 01111) = 4 and d(ς16, ς15) = d(11010, 11011) = 1.\nA more formal description of SAW as a general purpose combinatorial search algorithm is given in Section III. A summary of results in Section IV demonstrates that in the asymptotic sense (as L increases), a contiguous SAW always has walklengths that are on the average shorter than walklengths achieved under heuristic which limits the length of each SAW and then with repeated random restarts, assembles the shorter SAWs into a single long walk which in general is no longer contiguous as illustrated in Figure 2-a. On origins of self-avoiding walks. The notion of self-avoiding walks (SAWs) was first introduced by the chemist Paul Flory in order to model the real-life behavior of chain-like entities such as solvents and polymers, whose physical volume prohibits multiple occupation of the same spatial point [24]. In mathematics, a SAW lives in the n-dimensional lattice Zn which consists of the points in Rn whose components are all integers [25, 26]. The challenge of finding the longest self-avoiding walk in multi-dimensional lattices efficiently has been and also continues to be of considerable interest in physics [27].\nIII. Solvers and Instrumentation\nWe have instrumented a total of four solvers to conduct experiments which are summarized in the section that follows. Two solvers, lMAts and lssMAts, as described in [19] implement a memetic-tabu search strategy. The solver lMAts returns solutions for both even and odd sequences, without special consideration of skew-symmetry – a consideration which is applied in the implementation of\nlssMAts. The third solver, lssRRts, is a special case of lssMAts. Our solver, lssOrel, implements a self-avoiding walk strategy for odd sequences under skew-symmetry, thus results of performance experiments with lssOrel can be directly compared with lssMAts and lssRRts.\nThe section begins with solver instrumentation, defines hit ratio and asymptotic solvability, follows up with psedo-code descriptions of the solvers, and concludes with highlights on differences between lssMAts amd lssOrel.\nSolver instrumentation. We argue that in order to design better combinatorial solver one also needs to devise an environment and a methodology that supports reproducible and statistically significant computational experiments. In our case, this environment continues to evolve under the working name of xBed [28]. A generic and standardized notation is an important part of this environment; Table 2 summarizes the notation and description of principal variables in our solver instrumentation which we also use in our pseudo code descriptions. Some of these variables have already been defined in Section II.\nFor example, reporting the runtime t is not the only performance variable of importance. The most important variable is the variable named as cntProbe τ : a variable that counts how many times the solver evaluated the objective function before completing the run. By keeping\ntrack of this variable, we can compare two solvers regardless of the platform on which experiments have been performed, and regardless whether the solver represents a much slower scripted implementation of an early prototype or the faster compiled-code implementation. In our experiments, the correlation coefficient between runtime and cntProbe consistently exceeds 0.999.\nThe nine most critical performance variables, also monitored during performance experiments under xBed, are: runtimeLmt tlmt, coordBest ς∗, valueBest Θ(ς∗), valueTarget ΘubL , targetReached, isCensored, sampleSize N , hitRatio H(sid, ΘubL ), and asymptotic solvability S(sid, ΘubL , p). Here, sid denotes solverId and sampleSize N denotes the number of solver runs for a given instance of size L; each under a different random seed.\nThe status variable targetReached assumes three values: 0 if valueBest > valueTarget, 1 if valueBest = valueTarget, and 2 if valueBest < valueTarget. Whenever solver returns a solution with targetReached = 2, we reset valueTarget to the new upper bound and repeat the experiments with the new bound. The stopping criterion for each solver is the same: either the solver reaches valueTarget before reaching runtimeLmt, returning targetReached = 1 and isCensored = 0, or the solver reaches runtimeLmt before reaching valueTarget, returning targetReached = 0 and isCensored = 1.\nTable 2: Summary of notation: symbols, names, and descriptions.\nsymbol short name brief description L coordDim instance size λ laevusNumber coord. prefix size L′ coordDim’ instance size under\nskew-symmetry and coord. prefix size: (L+ 1)/2− λ\nσ0 seedInit initial seed integer ς0 coordInit initial coordinate Θ(ς0) valueInit initial value ςj coordPivot pivot coordinate\nΘ(ςj) valuePivot pivot value ςij coordNeighb pivot neighbor coord.\nN (ςj) coordNeighbSet full neighborhood set of pivot coordinate\nNsaw(ςj) sawNeighbSet SAW neighborhood set\nωc wlCoef walkLength factor\nωlmt = ωc ×L′ wlSegment walk segment length Walkω =\n= {ς0, . . . , ςω} walkList walk list after ω steps\nsymbol short name brief description t runtime CPU runtime tlmt runtimeLmt solver timeout value τ cntProbe # of function probes ρ cntRestart # of walk restarts β cntTrapped # of trapped solutions ς∗ coordBest best coordinate Θ(ς∗) valueBest best value\nΘubL valueTarget best upper bound\nisCensored solution status: 1 if t >= tlmt; 0 otherwise targetReached solution status: 0 if Θ(ς∗) > ΘubL , 1 if Θ(ς∗) = ΘubL , 2 if Θ(ς∗) < ΘubL\nN sampleSize # of instances and initial seeds in the experiment\nH(sid, ΘubL ) hitRatio # of uncensored solutions under targetReached = 1 divided by sampleSize N S(sid, ΘubL , p) asymptotic predicted waiting time to solvability satisfy H(...) = 1 with\nsolver sid, probability p\nUncensored random variables such as runtime or cntProbe have near-exponential or near-geometric distribution, also confirmed by performance experiments summarized in the next section; i.e. we observe s ≈ m where s denotes the sample standard deviation and m denotes the sample mean. Under such distributions, a reliable rule-of-thumb estimate of the 95% confidence interval on value of the sample mean m, given a sample size of N = 100, a standard value in our experiments, is thus\n≈ [0.8×m, 1.2×m] (11)\nWhen censured, the confidence interval can increase significantly beyond the one in Eq. 11. We argue that reliable estimates of confidence bounds on the mean values of runtime or cntProbe returned by combinatorial solvers under censoring are a subject best left to statisticians [29]. Hit ratio and asymptotic solvability. We define hit ratio H(sid, ΘubL ) as\nH(sid, ΘubL ) = |S1,0| N\n(12)\nwhere sid, N denote solverId and sampleSize. For a given ΘubL , |S1,0| is the number of solver solutions with status variable values of targetReached = 1 and isCensored = 0.\nWe define asymptotic solvability S(sid, ΘubL , p) as\nS(sid, ΘubL , p) = qgamma(p,N , 1/m) (13)\nwhere p is the probability of reaching the hitRatio of 100% in units of time defined by the sample mean m; qgamma the incomplete gamma function readily accessible in R [30]. This definition relies on the theorem that the sum of variates with exponential distribution has gamma distribution [31]. There are a number of well-defined relationships between Poisson’s processes, exponential distributions, and gamma distributions. Our definitions of solvability can also be interpreted as the waiting time to find N uncensored solutions, and thus the hitRatio of 1.0 with probability of p, say p = 0.99. However, there are a number of different definitions and contexts for waiting time, mostly from queueing theory. The solvability as defined in this paper relates directly to combinatorial solvers and hitRatio; it also represents a generalization of the solvability function already defined in [32]. We justify our notion of asymptotic solvability since, in Section IV, we rely on asymptotic performance experiments to predict the runtime or cntProbe mean m, and hence also to predict an estimate of solvability as per Eq. 13.\nIn other words, given ΘubL and the mean time-to-solve\na given instance is m = 1 hour, then the solvability (i.e. waiting time in our context) to achieve a hit ratio of 100% with sample size of N = 100 and the probability of 0.99 is at least dqgamma(0.99, 100, 1))e = 125 hours. Of course, the reported solvability is under the assumption that the solver is invoked serially on a single CPU. Table 3 presents values of incomplete gamma function in the range of most practical interest for our purposes. Note that for N = 100, pgamma(125,100,1) = 0.9906 and that for N = 1, pgamma(q,1,1) is equivalent to the commulative distribution of the exponential function. We shall return to significance of hit ratio and asymptotic solvability in Section IV, starting with Figure 6.\nSolver lssOrel. A self-avoiding walk strategy implemented by lssOrel follows a few simple rules: (1) initialize a coordinate ς and mark it as the ‘initial pivot’; (2) probe all unmarked adjacent coordinates, then select and mark the coordinate with the ’best value’ as the new pivot; (3) continue the walk until either Θ(ς∗) ≤ ΘubL or the walk is blocked by adjacent coordinates that are already pivots; (4) if the walk is blocked or its length exceeds a threshold, initialize a new coordinate ςi as a ‘new initial pivot’ and restart a new walk segment; (5) manage the memory constraints with an efficient data structure such as a hash table. For examples of contiguous and non-contiguous self-avoiding walks, see Figure 2.\nIn Figure 3 we present the fully instrumented pseudo code of solver lssOrel. The main procedure lssOrel invokes walk.saw which in turn invokes newPivot.saw. Depending on initial parameters, the procedure lssOrel returns the best solution from a single contiguous selfavoiding walk or a sequence of contiguous self-avoiding walk segments. The procedure walk.saw makes a contiguous self-avoiding walk segment as a sequence of best pivot coordinates, an arrangement formalized in Eq. 10. The procedure newPivot.saw searches the distance=1 neighborhood as defined in Eq. 8 for the best new pivot under the self-avoiding walk restrictions.\nSince procedure newPivot.saw is the computationally most critical part of the solver, we provide additional details. The neighborhood search proceeds in randomized order (Step 3) to avoid inducing bias in the order of best pivot selection. The Step 5 eliminates all adjacent coordinates that may have been used as pivots already and returns a neighborhood subset Nsaw(ςω−1). To manage this search efficiently in current implementation, we use a hash table to store pivot coordinates Walkω. If the neighborhood subset is not empty, the procedure bestNeighbor in Step 7 probes all coordinates in the subset and returns the new pivot, updates the walk list to Walkω in Step 8, and exits on Step 16. An empty neighborhood implies that the self-avoiding walk is trapped, i.e. the selection of the pivot for the next step is blocked by adjacent coordinates that are already pivots. While this phenomenon is yet to be observed for the labs problem, we complete the procedure with Steps 11, 12, 13.\nSolvers lMAts, lssMAts and lssRRts. Both solvers in Figure 4, lMAts and lssMAts, are instrumented versions of the labs solver named as MAT S in [19]. These solvers, their pseudo code, and associated experiments and results, are described in [19]. Setting of control parameters in our experiments are identical to ones used in [19]; a consise reprise of these setting is shown in the top-right part of Figure 4. The added instrumentation has been highlighted in gray. We also added the cntProbe variable which is not shown.\nThe solver lssRRts is a derivative of lssMAts; we devised it as a separate solver so we could investigate the performance of the tabu search, as implemented in lssMAts, without its evolutionary component.\nDifferences in lssMAts and lssOrel. Comprehensive series of asymptotic performance experiments discussed in the next section reveals significant difference between some of the solvers. Comparisons of most interest are the ones between lssMAts and lssOrel. We conclude this section with an illustrative example which provides a modicum of explanation why such differences impact the asymptotic performance of both solvers.\nConsider an instance of a labs problem for L = 21 where we take advantage of skew-symmetry to reduce the problem size to L′ = 0.5 ∗ (L+ 1) = 11. The corresponding Hasse graph now has 211 = 2048 vertices and is too large to plot and trace edges from each vertex to 11 of its neighbor vertices and their labels directly. However, when walk lengths are on the order of 30–50 steps, we can project vertices and labels that have been visited in the underlying Hasse graph onto a uniform grid. In Figure 5 we display two instances of such projections, based on two different walks returned by two solvers, lssMAts\n1: procedure lssOrel(σ0, ΘubL , tlmt,ωlmt) 2: ς0 : Θ(ς0)← coordInit(σ0) . initial solution 3: τ ← 1 . initialize cntProbe 4: ς∗ : Θ(ς∗)← ς0 : Θ(ς0) . initial best solution 5: isCens← 0 . initialize isCensored 6: tgReached← 0 . initialize targetReached 7: β ← 0 . initialize cntTrapped 8: ωtot ← 0 . initialize total number of steps 9: while true do 10: ω : ς∗ : Θ(ς∗)← walk.saw(ς0 : Θ(ς0),ωlmt) . return a completed walk segment 11: ωtot ← ωtot + ω . update total number of steps 12: if Θ(ς∗) ≤ ΘubL then 13: if Θ(ς∗) = ΘubL then 14: tgReached = 1 . upper-bound is reached 15: else 16: tgReached = 2 . upper-bound is improved 17: end if 18: break 19: end if 20: if t ≥ tlmt then 21: isCens← 1 . return solution as “censored” 22: break 23: end if 24: ς0 : Θ(ς0)← coordInit() . initialize a new walk segment 25: τ ← τ + 1 . update cntProbe 26: ωtot ← ωtot + 1 . update total number of steps 27: end while 28: Table← (σ0, ς∗, Θ(ς∗),ωtot, τ , t, isCens, tgReached) 29: end procedure\n1: procedure walk.saw(ς0 : Θ(ς0),ωlmt) 2: if Θ(ς0) ≤ Θ(ς\n∗) then 3: ς∗ : Θ(ς∗)← ς0 : Θ(ς0) . new best solution 4: end if 5: ω ← 0 6: Walk0 ← {ς0} . new walk segment 7: while Θ(ς∗) > ΘubL and ω < ωlmt do 8: if t ≥ tlmt then . timeout 9: break 10: end if 11: ω = ω+ 1 . a new step! 12: Walkω : ςω : Θ(ςω)← 13: ← newPivot.saw(ςω−1,Walkω−1) 14: if Θ(ςω) ≤ Θ(ς\n∗) then 15: ς∗ : Θ(ς∗)← ςω : Θ(ςω) 16: end if 17: end while 18: return ω : ς∗ : Θ(ς∗) 19: end procedure\n1: procedure newPivot.saw(ςω−1,Walkω−1) 2: Z← i = 1, 2, . . . ,L 3: Zp ← permute(Z) 4: N (ςω−1)← {ς i ω−1|d(ςω−1, ς i ω−1) = 1, i ∈ Zp} 5: Nsaw(ςω−1)← {N (ςω−1)|ς i ω−1 6∈Walkω−1} 6: if Nsaw(ςω−1) 6= ∅ then 7: ςω : Θ(ςω)← bestNeighbor(Nsaw(ςω−1)) 8: Walkω ←Walkω−1 ∪ {ςω} 9: τ ← τ + | Nsaw(ςω−1) | . update cntProbe 10: else . deal with a trapped pivot 11: β = β + 1 12: ςω : Θ(ςω)← coordInit() . re-initialize 13: Walkω ← {ςω} 14: τ ← τ + 1 . update cntProbe 15: end if 16: return Walkω : ςω : Θ(ςω) 17: end procedure\nFigure 3: A fully instrumented version of solver lssOrel and two supporting procedures: walk.saw and newPivot.saw. Procedure lssOrel: as a single contiguous self-avoiding walk or as a sequence of contiguous self-avoiding walk segments. Procedure walk.saw: Self-avoiding walk with a sequence of best pivot coordinates. Procedure newPivot.saw: Searching for the best new pivot under restrictions of SAW.\n.\n1: procedure lssMAts(ΘubL , tlmt) 2: for i← 1 to popsize do 3: popi ← RandomBinarySequence(L) 4: Evaluate(popi) 5: end for 6: Θ(ς∗)← ValueBest(pop)\n7: while t < tlmt and Θ(ς∗)> ΘubL do 8: for i = 1 to offsize do 9: if recombination is performed (pX) then\n10: parent1 ←Select(pop) 11: parent2 ←Select(pop) 12: offspringi ←Recombine(parent1, parent2) 13: else 14: offspringi ←Select(pop) 15: end if 16: if mutation is performed (pm) then 17: offspringi ←Mutate(offspringi) 18: end if 19: offspringi ←TabuSearch(offspringi) 20: Evaluate(offspringi) 21: end for 22: pop←Replace(pop, offspring) 23: Θ(ς∗)← ValueBest(pop) 24: end while 25: end procedure\n(a) lssMAts solver, based on MAT S in [19].\nThe procedure lssMAts on the left is an instrumented versions of the labs solver named as MAT S in [19]. Settings of all parameters, used also in our experiments, are described in [19]. See a concise reprise below.\nsetting value population size: 100 mutation probability: 2/(L+ 1) crossover probability: 0.9 tournament selection size: 2 crossover: uniform tabu search walk length: a random choice\nfrom the range [L2 , 3L 2 ]\n1: procedure lssRRts(ΘubL , tlmt) 2: pop1 ← RandomBinarySequence(L) 3: Evaluate(pop1) 4: Θ(ς∗)← ValueBest(pop)\n5: while t < tlmt and Θ(ς∗)> ΘubL do 6: pop1 ←RandomBinarySequence(L) 7: pop1 ←TabuSearch(pop1 ) 8: Evaluate(pop1 ) 9: Θ(ς∗)← ValueBest(pop)\n10: end while 11: end procedure\n(b) lssRRts solver, based on reduction of lssMAts.\nFigure 4: We illustrate two instrumented versions of the labs solver named as MAT S in [19] under the caption “Pseudo code of the memetic algorithm”, Figure 5. The instrumentation, highlighted with gray background, uses variable names defined in Table 2 and fits unobtrusively within the context of the original pseudo code: it is designed to control solver termination not only with a runtime limit but also by monitoring the solution quality in terms of a pre-specified upper bound. The procedure lssMAts on the left describes the actual solver in our experiments, adapted to solve instances of the labs problem only for odd values of L under skew-symmetry. A more general labs solver, for both even/odd values of L and also described by the same pseudo code, has been named lMAts.\nThe procedure lssRRts on the right describes an alternative solver to lssMAts – it is also the name of the solver used in our experiments. While the solver on the left relies on an established evolutionary algorithm to initialize the tabu search, the modified solver uses randomly generated coordinates to initialize the tabu search. This set-up allows us to investigate the performance of the tabu search alone.\nand lssOrel: one walk terminates without finding the optimum solution, the other terminates upon finding the optimum solution, the pair 01101010110:26.\nBoth solvers start the respective walks from the same initial coordinate 11101011100, a substring of length L′ = 11, which under rules of skew-symmetry expands into the full initial coordinate 111010111001101111101 of length L = 21 and labs energy value of 130. The labels associated with the initial vertex for each walk are given as the pair substring:value, starting with 11101011100:130. Both walks are shown in two grids: each grid represents a projection of vertices and vertex labels, selected dynam-\nically during the walk, from the underlying Hasse graph. The length of the walk is prescribed by the solver.\nUnder Case (a), lssMAts selects the walk length randomly from the range [L/2, 3L/2] = [b(L′ − 0.5)c, b(3L′ − 1.5)c] = [10, 31], and for the instance shown, the value of 27 has been selected. Under Case (b), lssOrel walk is limited only by the upper bound 2L′ − 1. For this instance, lssMAts terminates the walk after step 27 without finding the solution target value and therefore needs to repeat the search from another coordinate. Moreover, the walk in lssMAts uses a tabu search strategy and is not self-avoiding in this instance: six vertices form a\nFigure 4: Local search walks for lssOrel and lssMAts algorithms. Problem size is 21 and initial solution coordinate is 11101011100.\n15\ncycle 10010010000:74, 10010010001:82, 10010010101:42,\n10110010101:66, 10110010100:90, 10110010000:82, and 10010010000:74. On the other hand, the self-avoiding walk in lssOrel continues for 35 steps and stops only upon finding the solution target value: 01101010110:26.\nIn each case, the walk length depends not only on the initial coordinate but also on the initial randomly selected seed. With lssMAts and the initial coordinate 11101011100, runs with 32 random seeds return walks of lengths in the range of [10, 31] where only 14 walks terminate at the target solution value of 26. With lssOrel and the initial coordinate 11101011100, runs with 32 random seeds return walks of lengths in the range of [4, 226] where all 32 walks terminate at the target solution value of 26.\nAdditional experiments can determine the more likely walk length means of each solver, with each reaching the same target value. Given one thousand randomly selected initial coordinates and random seeds for L = 21, the mean value of total walk length returned by lssMAts is 232.6 with the 95% confidence interval [214.1, 251.1]. This statistics has considerable bias since lssMAts has an advantage by relying on population of 100 randomly initialized solutions before proceeding with the search proper, thereby finding 167 solutions that reach the target value of 26 with walk length of 0 and 833 solutions that reach the target value with walk length > 0. Now, the mean value of total walk length returned by lssMAts based on 833 runs with walk length > 0 and under multiple restarts, is 279.2 with the 95% confidence interval [258.4, 300.1].\nIn comparison, when the same tests are applied to\nsolver lssOrel, each of the one thousand walks terminate\nat the target value of 26 without a single restart: the mean value of walk length is 97.3 with the 95% confidence interval [93.6, 100.9]. This mean value is significantly better than the mean value of the Hamiltonian (self-avoiding) walk. Given that this instance has 4 minima, the mean value of the Hamiltonian walk is (1/8)211 = 256. In conclusion, experiments with the instance shown in Figure 5 demonstrate that the solver which reduces the repetition of coordinates during the stochastic search more effectively also achieves a better average case performance.\nIV. Summary of Experiments\nWe use the asymptotic performance experiment – as defined with a simulated experiment in Figure 6 – to reliably compare the performance of two labs solvers. By generating the asymptotic model for each solver, we not only readily compare the two solvers, we use the model also to predict computional requirements for maintaining uncensored experiments as the instances size increases – using also the metrics such as hitRatio (Eq. 12) and asymptotic solvability (Eq. 13). We follow this methodology consistently, under the given computational resources and time constraints [28].\nWe arrange our experiments into several groups. Given that the hardest-to-solve instances have only 4 minima – or equivalently a single canonic solution – when L is odd, we restrict the asymptotic performance experiments to this subset of L only. If during the experiment we find out that an instance has more than 4 minima, we exclude it\nfrom the test set. Similarly, when L is even, the hardestto-solve instances have only two canonic solutions; we restrict the asymptotic performance experiments to this subset of L only. After we demonstrate that solver performance does scale with the available resources without exploiting skew-symmetry of the labs function, we focus on solvers under skew-symmetry only and the hardest-tosolve instances.\nWhen measuring runtime precisely is important, we perform experiments either on a PC or on a cluster of 22 processors [33], running under linux. In particular, we run the solver lMAts on the cluster where we control the processor load by running each solver instance serially – while also scheduling the runs on 22 processors in parallel. However, experiments with solvers lssMAts, lssRRts, and lssOrel on largest instances are scheduled in parallel and automatically on the grid with 100 processors, each solving an instance size of L under different random seeds and a runtimeLmt of 96 hours (4 days) for each instance. The PC has an Intel processor i7, clock speed of 2.93 GHz, cache of 8 MB, and main memory of 8 GB. The grid is a configuration of AMD Opteron processors 6272, clock speed of 2.1 GHz, cache of 2 MB, and main memory of 128 GB assigned to 64 cores [34]. When scheduled\non the grid, processors run under variable load factors and direct comparisons of solver runtime are no longer possible. However, by instrumenting each solver with the counter such as cntProbe, solver performance comparisons remain platform-independent.\nThis sections continues with summaries of following experiments: (1) solver lMAts for Lodd and Leven, (2) best upper bounds of Lodd without skew-symmetry, (3) solver lssOrel_U (each solution is based on a single segment contiguous walk), (4) solver lssOrel with limited walk length, (5) solver lssOrel_U versus lssOrel_8, (6) solver lssMAts versus lssRRts, (7) solver lssOrel_8 versus lssMAts, including asymptotic predictions and hit ratios, and (8) solver lssOrel_8 versus best known merit factors in the literature and new best-value solutions of the labs problem.\n(1) Experiments with lMAts. Experiments with solver lMAts have been designed to illustrate its asymptotic performance; we summarize it in Figure 7 and in Table 4. We consider two specific subsets of sequence lengths L:\nLodd = {13, 21, 27, 41, 43, 45, 51, 57, 71, 77, 83, 87} (14)\n10 20 30 40 50 60\n1e +\n02 1e\n+ 04\n1e +\n06 1e\n+ 08\n1e +\n10\nSequence length L\ncn tP\nro be\nlMAts−odd = 320.360 × 1.3421L lMAts−even = 114.515 × 1.3464L\n(a) The sample mean asymptotic model for cntProbe.\n10 20 30 40 50 60\n1e −\n04 1e\n− 02\n1e +\n00 1e\n+ 02\n1e +\n04\nSequence length L\nru nt\nim e\n[s ec\non ds\n]\nlMAts−odd = 6.59695e−05 × 1.3421L lMAts−even = 2.40145e−05 × 1.3464L\n(b) The sample mean asymptotic model for runtime.\n● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ● ●\n●\n●\n●\n●\n●\n●\n●\n● ●\n20 40 60 80\n0 20\n40 60\n80 10\n0\nSequence length L\nH it\nra tio\n[% ]\n● lMAts−odd lMAts−even\n(c) For runtimLmt=10 hours and L ≤ 64, hitRatio=100. Sequence length L\ncn tP\nro be\n13 21 27 41 45 51 57\n1e +\n02 1e\n+ 04\n1e +\n06 1e\n+ 08\n1e +\n10 lMAts−odd = 320.36 × 1.3421L ES = 5.76855 × 1.5097L\nKL = 50.9714 × 1.4072L\n(d) Asymptotic comparisons to earlier solvers [15, 16].\nFigure 7: The asymptotic performance of solver lMAts for sequence lengths L from the subsets Lodd and Leven. As expected, instances from Lodd take significantly more time to solve than instances from Leven. The sample mean asymptotic models are based on sample size N = 516 and rely only on runtime samples of L where runtime is not censored, i.e. for hitRatio = 100%. For consistency with observed hitRatio in Table 4, the plot of hitRatio in this Figure also relies on the sample size of 100. Finally, the solver lMAts significantly outperforms the two earlier stochastic solvers, ES and KL from [15, 16]. Here, the performance is measured not in runtime but the observed values of cntProbe which are platform-independent and as such, still relevant 11 years after the initial experiments.\nLeven = {20, 24, 28, 32, 34, 36, 38, 40, 42, 44, 48, 52, 54, 58, 60, 62, 64, 66, 68, 74, (15) 76, 78, 80, 82, 84, 86}\nFor values of L in the subset Lodd there are only four optimal solutions, which reduce to a single canonic solution\n– making these instances hardest-to-solve. For values of L in the subset Leven there are only eight optimal solutions, which reduce to a canonic solution pair – making these instances hardest-to-solve for even values of L. There are four plots in Figure 7:\n(a) Predictor models for observed sample mean of cntProbe\ncntProbe(lMAts)odd = 320.360 ∗ 1.3421 L (16)\ncntProbe(lMAts)even = 114.515 ∗ 1.3464 L\n(b) Predictor models for observed sample mean of runtime (converted from seconds in the figure to hours here)\nruntime(lMAts)odd = 1.832 ∗ 10 −8 ∗ 1.3421L (17)\nruntime(lMAts)even = 6.671 ∗ 10 −5 ∗ 1.3464L\n(c) Observed hitRatio as defined in Eq. 12. For runtimeLmt = 10 hours, we can maintain hitRatio of 100% up to L = 57 for odd values of L and up to L = 64 for even values of L. This implies that under current runtimeLmt we can not reliably measure average-case performance of solver lMAts for larger values of L. (d) The solver lMAts significantly outperforms the two earlier stochastic solvers, ES and KL [15, 16]. While we can no longer relate the runtime performance of these two solvers today, the observed values of cntProbe, which are platform-independent, are still relevant 11 years after the initial experiments: cntProbe(ES)odd = 5.76855 ∗ 1.5097L and cntProbe(KL)odd = 50.9714 ∗ 1.4072L. Our current\nestimates of asymptotic performance are more accurate, since we process observations not as single ensemble but as two ensembles, one for odd and the other for even values of L. More about Figure 7. Predictor models for cntProbe and runtime are based on a sample size of 516. The model mean is only an approximate predictor of the the observed sample mean – it can underestimate as well as overestimate. For L = 57, the observed runtimes range from 2 seconds to slightly more than 2 hours, with the sample mean of 1340.4 seconds. However, when we report on sample means over five consecutive intervals, with 100 samples in each interval, sample means range from 1155.3 seconds to 1624.9 seconds – as anticipated in Eq. 11.\nFor this series of experiments we had access to a cluster of 22 unloaded processors and could schedule executions in parallel while still measuring runtimes that would be consistent with runtimes we would observe serially on a single unloaded processor. Since runtime measurements under 1 seconds are not precise even for an unloaded processor, we rely on near 100% correlation with cntProbe and compute runtime indirectly for all values of L. Predictions and observations in Table 4. Here we relate\nobservations from experiments with lMAts to hitRatio, asymptotic solvability, and predictor models as defined by Eqs. 12, 13, and 18. In particular, the rapid decline in hitRatio, under the constraint of runtimeLmt of 10 hours for each of the selected values of L can also be predicted as observerved both in this table as well in Figure 7-c.\nExperiments with solver lMAts define the methodology we shall use for the rest of the paper, now focusing on the performance of solvers lssOrel and lssMAts under skew-symmetry. Again, we first define several groups for Lodd to better arrange the sequence of our experiments.\n(2) Best upper bounds pairs for Lodd. The experiments with lMAts show the importance of (a) separating instances for Lodd from instances for Leven, and (b), separating instances in both Lodd and Leven into additional groups: a group with single canonic solution for Lodd, a group with a single pair canonic solutions for Leven. and groups with more canonic solutions. For experiments that follow for Lodd, we again define the hardest-to-solve instances as having a single canonic solution, and divide them into two groups, primary and secondary:\nLprim = {5, 7, 11, 13, 21, 27, 41, 43, 45, 51, 57, 71 77, 83, 91, 95, 97, 99, 101, 103, 105} (18)\nLsecd = {71, 77, 83, 91, 95, 97, 99, 101, 103, 105, 107, 109, 111, 115, 117, 119, 121, 123, 125, 127} (19)\nThe instance Lprim = 105 is the largest instance where the solver lssOrel does not exceed the maximum memory limit of 8 GB on our PC and completes as uncensored a self-avoiding walk without a single restart from each randomly assigned initial coordinate. We observe a single canonic solution for each value of L in this group, so we can formulate an asymptotic predictor model based on sample means, similarly to Eqs. 17 and 18. The instance Lsecd = 127 is the largest instance where the solver lssOrel completes 100 uncensored performance evaluations (initialized with 100 random seeds) within 2 days ( ∑100\ni=1 runtimei < 2 days) on our PC; i.e. achieving a hitRatio = 100% and returning a mean value for the sample size of 100. Again, we observe a single canonic solution for each value of L in this group, so again we can formulate an asymptotic predictor model based on sample means.\nFor the remainder, we consider the tertiary group,\nwith all experiments performed on the grid [34].\nLtert = {141, 151, 161, 181, 201, 215, 221, 241, 249, 259, 261, 271, 281, 283, 301, 303, 341, 381, 401} (20)\nWe place Ltert = 141 into the tertiary group since the number of observered canonical solutions is greater than 1. The instance Ltert = 151 is the smallest instance where the solver lssOrel no longer achives hitRatio = 100% with runtimeLmt = 4 days. With exception of Ltert = 141, solutions in this group associate with a distribution of merit factors rather than a single best value; see Table 6 and Figure 14 later in this section. For these instances, we can only report the best figure of merit; the probability that that the associated sequence is either optimal or near-optimal is almost 0 as the instance size increases.\nSee Table 5 for a summary of best known upper bound values on labs energies for given subsets of Lodd. Up to L = 99, these energies are listed as pairs: the first number represents the best value achieved under coordinates with skew-symmetry, the adjacent number in brackets gives the number of canonic solutions under skew-symmetry. The second number represents the best value achieved with coordinates that are not skew-symmetric; the adjacent number in brackets gives the number of canonic solutions that are not skew-symmetric. In 2002, Knauer posted the ‘best-value solutions’ for L > 101 without the restriction of skew-symmetry [6]; results in Table 5 show that our skew-symmetry solver lssOrel consistently returns improved skew-symmetric solutions vis-à-vis Knauer’s solutions without skew-symmetry, and then a few more. (3) Experiments with lssOrel_U. The letter U in the name of this solver is a parameter that stands for unlimited length of the self-avoiding walk segment in contrast to lssOrel_8 where 8 stands for the value of walk length factor ωc that determines the maximum length of the selfavoiding walk segment ωlmt = ωc ∗ L+12 , already defined in Table 2; lssOrel_8 is discussed in more details later.\nUnder the walk length factor value of U, solver lssOrel invokes the procedure walk.saw in Figure 3 only once; the walk is contiguous and terminates as a single segment only upon reaching the upper bound ΘubL . For L = 105, the largest instance reported in this group of experiments, we have Θub105 = 620. In our experiments with L = 105 we record instances of 100 distinct single-segment contiguous walks, each starting at a different randomly selected coordinate and random seed, with each walk terminating at one of the four solution coordinates with the best-known value of 620. We have not observered a single instance of a trapped pivot that would induce a restart of another walk segment. The runtime, cntProbe and and memory\nfootprint range from 0.04 to 278.87 seconds, 218.66 to 231.21 probes and 2.2 MB to 1.97 GB, respectively. The averages for runtime, cntProbe, walkLength, and memory footprint are 72.48 seconds, 229.28 probes, 223.59 steps, and 0.516 GB, respectively. The attempts to run instances of size L = 107 without a single restart were unsuccessful due the 8 GB memory limit of our PC.\nIn lattices, with grid structures that are different and\nrelatively simpler when compared to our Hasse graphs, physicists continue to push the envelope on the maximum length of self-avoiding walks: experiments with longest walks under 64 GB of memory are reported as having maximum lengths of 228 − 1 in a 3D lattice and 225 − 1 in a 4D lattice [27].\nFigure 8 summarizes experiments with lssOrel_U for 14 hardest-to-solve instances, ranging from L = 41 to\nL = 105. Note the high correlation of cntProbe versus runtime and walkLength versus cntProbe: this correlation remains at about 99% throughout our experiments – for all values of L.\nThe predictor models for observed sample means of cntProbe and runtime (in seconds) are\ncntProbe(lssOrel_U) = 73.05 ∗ 1.1668L (21) runtime(lssOrel_U) = 1.8 ∗ 10−6 ∗ 1.1846L (22)\nOf these two models, only the predictor for cntProbe is platform independent, the predictor for runtime (in seconds) is valid for the specified PC only. Similarly to Eq. 18, we compute coefficients in runtime(lssOrel_U) indirectly by taking advantage of the high correlation between cntProbe versus runtime.\nResults obtained with lssOrel_U provide the baseline\nfor all experiments that follow.\n(4) Solver lssOrel under limited walk length. The length of the self-avoiding walk segment is controlled by the walk length coefficient ωc: ωlmt = ωc ∗ L+12 , see Table 2. The value of ωc extends the name of the solver lssOrel, for example lssOrel_8 can be interpreted, in the case of L = 105 as limiting the contiguous walk length to a maximum of ωlmt = 8 ∗ 53 = 424 steps.\nUnder the limited walk length, solver lssOrel invokes the procedure walk.saw in Figure 3 with a randomly selected initial coordinate a number of times, creating the walk as a sequence of contiguous self-avoiding walk segments. However, since each walk segment is independent, there is no need to store the previous walk segments. Thus, the walk length factor determines not only the maximum walk length of the contiguous self-avoiding walk segment but also the amount of memory needed to store the current segment.\nTo find out the effect of the limited walk length on solver, we ran experiments with the secondary group of the hardest-to-solve instances (Eq. 19, see also Table 5) with walk length factor values set to ωc = 1, 2, 4, 8, and 16 – see Figure 9. Results in Figure 9 show that solver lssOrel_8 exhibits the best average-case asymptotic performance with cntProbe of 650.07 ∗ 1.1435L. The\nsecond and third best results are achieved with ωc = 16 and 4 while the worst results are achieved with ωc = 1. For example, consider the case of L = 127: by changing ωc = 1 to ωc = 8, the mean value of cntProbe decreases from 234.64 to 233.83, a decrease by a factor of 1.76.\nSince experiments show that the effectiveness of lssOrel is best for the walk length factor value of ωc = 8, we shall use lssOrel_8 as the reference solver for comparisons with all other solver configurations in the remainder of this paper.\n(5) Comparisons of lssOrel_U and lssOrel_8. The main difference between lssOrel_U and lssOrel_8 is the walk segment length and consequently, the memory usage. We ran experiments with 14 hardest-to-solve instances, ranging from L = 41 to L = 105 – see Figure 10. Results in Figure 10 show cntProbe (a), runtime (b), speed (c), and memory usage (d). The speed of the solver is defined as the number of function evaluations (probes) per second. For L < 71 runtime is close to 0 and the speed cannot estimated acurately, hence results are shown for L ≥ 71 only. The memory usage in Figure 10d is not an average value, it is the maximum memory usage observed for one of the 100 samples.\nWhen observing cntProbe alone, the solver lssOrel_U has a slight advantage over lssOrel_8 – which we would\nexpect. However, as L increases, this advantage decreases for runtime – due to the increased reduction in speed observed for lssOrel_U. A significant factor in this speed reduction for lssOrel_U is the increasing memory requirement for lssOrel_U, inducing an increased probability of a hash collision to maintain a self-avoiding walk under a fixed memory limit. As shown in the graph, the memory required by lssOrel_U increases with the instance size L\nwhile lssOrel_8 requires a constant amount of memory, about 1.8 MB in our case.\nWhat we learned from these experiments is that the solver such as lssOrel_U cannot deliver solutions under a single self-avoiding walk segment when the required walk length exceeds the available memory constraints of the solver – a compromise solver such as lssOrel_8 is needed for solving larger instance sizes.\n(6) Comparisons of lssMAts and lssRRts. The solver lssRRts is a derivative of lssMAts; asymptotic comparison of the two solvers is expected to reveal whether or not the initialization of tabu search by the evolutionary component of within lssMAts significantly improves the solver performance in comparison with lssRRts where tabu search is initialized with a random binary sequence.\nWe ran experiments with the secondary group of the hardest-to-solve instances (Eq. 19, see also Table 5). The settings of lssMAts are the same as described in [19] and also shown in Figure 4. The solver lssRRts has only one control parameter: the tabu search walk length, set in the same way as lssMAts.\nResults of experiments are shown in Figure 11. We conclude that the asymptotic average-case performance of these two solvers are statistically equivalent. For the range 71 ≤ L ≤ 127 we find cntProbe as 150.49 ∗ 1.1646L for lssMAts and 156.34 ∗ 1.1646L for lssRRts. Thus, for\nthe labs problem, the evolutionary component within lssMAts is not effective.\n(7) Comparisons of lssOrel_8 and lssMAts. We ran two sets of experiments to compare the two solvers. With the first set, we measure the average-case asymptotic performance, with hardest-to-solve instances from the secondary group in Eq. 19. For the second set, we select 7 instances that belong to the tertiary list in Eq. 20 and analyze solvabilities and hit ratios observed and predicted for the two solvers.\nResults from first set are shown in Figures 12 and 13. Figure 12 is divided into four plots. The average values of cntProbe required by each solver to reach the best-known upper bound, are shown in Figures 12a and 12b. We can conclude by inspection that the solver lssOrel_8 dominates lssMAts in terms of cntProbe. Notably, for L > 107, the gap in average values of cntProbe between lssOrel_8 and lssMAts is statistically significant and also continues to increase with increasing value of L.\nIn Figure 12c we also observe a statistically significant and increasing gap in average values of runtime between the two solvers. However, in Figure 12d the observed speed of lssOrel_8 is below the observed speed of lssMAts – with the gap slowly reducing as L increases. Apparently, solver lssOrel_8 overcomes its speed disadvantage by significantly better cntProbe performance. For\nexample, in the case of L = 109, the difference between mean values of runtime is 74 seconds and for L = 127, this difference increases to 1555 seconds.\nA meticulous reader may notice that performance differences between the two solvers can also be atributed to differences in walk length segments between random\nrestarts. Solver lssMAts selects the walk segment length ωlmt randomly from the interval [L2 , 3L 2 ] whereas for lssOrel_8 ωlmt = 8 ∗ L+12 .\nNow, consider results in Figure 13 where we compare the performance of lssMAts with three versions of lssOrel using parameter values of ωc = 1, 2, 8. We\nobserve significantly better average-case performance of lssOrel in terms of cntProbe for all values ωc = 1, 2, 8. Moreover, even the solver version of lssOrel_1 with its ωlmt = L+1 2 , performs better than lssMAts, where on the average, ωlmt is larger than L+12 .\n●\n●\n●\n●\n●\n●\nResults from the second set of experiments, based on seven instances from the tertiary list in Eq. 20, are shown in Table 6. Here we compare asymptotic predictions for cntProbe, calculated under the first set of experiments in Figure 12 versus the observed mean and observed solvability (defined as the sum of total of cntProbe, exhibiting a gamma distribution). There are a number of important observations that can be inferred from this set of experiments: (1) as long as the hit ratio stays at 100% (for all instance sizes up to L=141), the value differences between the model mean and the observed mean (and the asymptotic solvability and the observed solvability) are relatively small for both solvers, the differences increases significantly as the hit ratio reduces to 6% and 1% respectively; (2) for each instance, the asymptotic predictions represent the upper bound on the observed values (in this set of experiments); (3) for each instance, lssOrel_8 significantly outperforms lssMAts.\n(8) Comparisons with best known merit factors. We conclude this section by comparing the best-obtained merit factors obtained with lssOrel_8 and the bestknown merit factors reported in the literature – see Figure 14a. Notably, lssOrel_8 always finds a solution that has\nequal or better merit factor than those reported earlier. The new best-known merit factors were obtained for all tertiary group instances that are greater than 160 and their coordinates are shown in Table 7.\nIn Figure 14a, the merit factors where the best-known solutions were not skew-symmetric are marked with *. All these solutions were improved by lssOrel_8 and all the best-known solutions for odd instance sizes greater than 100 are now skew-symmetric. This is not unexpected; skew-symmetry significantly reduces the problem size and the solver has a better chance of finding new and better solutions for larger instances.\nWe use a large instance of L = 241 to demonstrate the variability in the quality of reported solutions: see the runtime scatter plot and the histogram of best merit factors based on the sample size of 100 in Figures 14b and 14c, respectively. In this experiment, the only stopping criterion is the runtime limit of 4 days.\nThe best-known merit factor for L = 241 is 7.2747 [6]; this value is represented with the blue line in Figure 14b. The two observations of most intererest in this figure include: (1) the point on the extreme left, where the merit factor of 7.2 is reached near the very start of the experiment and is not improved in 4 days, and (2) the point on the extreme right, where the new best-known merit factor of 8.0668 is reached just before the end of the 4 day experiment. Overall, lssOrel_8 found 69 solutions with a merit factor better than 7.2747.\nThe histogram in Figure 14c shows that with the sample size of 100, there is only 1 solution with the best merit factor of 8.0668, and that there are now a total of 24 unique merit factor values that exceed the value 7.2747, currently reported as the best known value [6].\nMore runtime, better solvers, or both is required to reach solutions with merit factor that will exceed 8.0668 for L = 241.\nV. Conclusions And Future Work\nDespite the relatively high cost of running a branch-andbound solver, the merits of finding exact solutions returned by solvers such as [8] and [10] should not be underestimated. The publication of optimal figures of merit for a subset of labs instances in [8] motivated not only the formulation of the stopping criterion for the stochastic labs solvers in [15, 16], it also initiated methodology and solver instrumentation that is now being refined and extended in this paper.\nState-of-the-art solutions to the labs problem provided by the two stochastic solvers, lMAts and lssMAts [19] represent a significant challenge for any new approach\nto solving the labs problem more effectively and efficiently. Both solvers have been highly optimized for speed, i.e. the number probes per second. Compared to evolutionary methods, significant advantage in speed is gained by implementing efficient incremental probing of coordinates adjacent to the pivot coordinate, such as the data structures documented in Figures 1 and 2 in [19]. Notably, these structures are specific for the labs problem and during the search, about 90% of runtime is spent by lssMAts evaluating these structures.\nThe speeds of solvers lKL and lMAts are comparable (both make use of efficient incremental probing structures), therefore the reason for the significant advantage of lMAts over lKL lies elsewhere. By measuring the number of probes (cntProbe), we demonstrate in Figure 7d that the main factor is the KL-based neighborhood search strategy – as L increases, KL looses its advantage rapidly.\nThere are three factors that support our quest for improved solutions as reported in this paper: (1) the introduction of the self-avoding walk paradigm as an effective stochastic search strategy, (2) solver instrumentation that goes beyond simple runtime measurements, (3) a methodology that supports reproducible and statistically significant computational experiments, with the well-defined average-case asymptotic performance experiment as its core. Without both (2) and (3) in place, we could not have detected sufficient merit for the solver based on the self-avoding walk paradigm.\nExperimental results with our solver lssOrel provide\nnot only new and improved solutions to larger instances of labs problem, they also explain why a solver based on a self-avoiding walk paradigm performs better than a solver based on a tabu search, at least when solving the labs problem, and why the deployment of evolutionary methods is not effective either.\nIn our future work, we expect to find new and improved solutions for larger labs instances. Approaches we are planning include:\nCoordinate weight and runs bounds. Upon examination of binary coordinates that represent best value solutions, we find a significant overlap in both relative weights as well as relative runs associated with these coordinates. Weights are computed by counting the number of 1’s in the coordinate, runs are computed by counting the number of 0/1 transitions; both are divided by the coordinate length. By restricting the search, under skew-symmetry, to the coordinates within specific range of relative weights and relative runs, we also reduce the search space.\nIntelligent restarts. Under a random restart, the walk continues on a new segment from a randomly selected pivot coordinate. Under the intelligent restart strategy, we not only mark the entire walk segment, we also maintain a dynamic list of best pivots. When a restart is mandated due to memory considerations, the initial pivot coordinate in the new walk segment is no longer random: we select it from the list of\nbest pivots; the walk now branches from an earlier pivot. The selection of the new initial pivot must also significantly reduce the chance that the new walk segment will have an overlap with the previous walk segment. This requires an intelligent synchronization with the memory management structure outlined next.\nIntelligent memory management. The current version of lssOrel uses a single hash table strategy to store pivot coordinates. As part of the future work, we shall investigate alternative memory management structures, including a chain of two or more hash tables, synchronized with the intelligent restart strategies.\nAn “almost surely” convergence. The new branchand-bound solver, now limited to odd values of L under skew-symmetry, reports optimum solutions for\nvalues of L ≤ 89 [10]. Its computational complexity, extrapolated from published results, is O(1.3370L). As shown in Figure 15a, stochastic solvers can find the same optimum solutions with siginificantly less computational effort, even when comparing a single run with the branch and bound solver with the runtime for 100 repeated runs of two stochastic solvers, lssOrel_8 and lssMAts. None of the 100 runs of the stochastic solver are to be censored, i.e. for each run, each gets as much runtime as needed to reach the best known target value.\nWe plan to pursue the conjecture that the best value which is repeatedly returned by the stochastic solver almost surely converges to its optimum value. For the context and definition of almost surely, see [35]. For support of this conjecture, consider the following observations: (1) solutions reported by the\n●\n●\n●\n●\n●\n●\n●\n●\n75 80 85 90\n5e +\n03 1e\n+ 04\n2e +\n04 5e\n+ 04\n1e +\n05 2e\n+ 05\nSequence length L\nru nt\nim e\n[s ec\non ds\n]\n● runtime = 1.55311e−06 × 1.3370L\n(a)\nL runtime [years] 100 * runtime [years] BB ratio† lssOrel_8 lssMAts\n75 1.1590e-04 3.1194e+03 3.7154e-06∗ 3.3649e-06+ 77 2.8983e-04 5.7999e+03 4.9971e-06 4.7695e-06 79 5.6726e-04 8.7172e+03 6.5074e-06∗ 6.3574e-06+ 81 8.9805e-04 1.0428e+04 8.6120e-06∗ 8.7384e-06+ 83 1.1310e-03 2.8420e+03 3.9795e-05 8.5217e-06 85 2.3780e-03 1.5766e+04 1.5083e-05∗ 1.6510e-05+ 87 4.5392e-03 2.2739e+04 1.9962e-05∗ 2.2693e-05+ 89 9.0476e-03 3.4249e+04 2.6418e-05∗ 3.1192e-05+ 115 1.5758e+01∗ 1.7756e+06 8.8751e-04 1.8324e-03 121 9.0011e+01∗ 4.2144e+06 2.1358e-03 4.2444e-03 127 5.1414e+02∗ 1.0145e+07 5.0680e-03 1.0521e-02 141 2.9986e+04∗ 7.7784e+07 3.8551e-02 1.2189e-01 151 5.4732e+05∗ 3.4972e+08 1.5650e-01∗ 5.9805e-01+ 161 9.9897e+06∗ 1.5723e+09 6.3534e-01∗ 2.9342e+00+ 181 3.3280e+09∗ 3.1783e+10 1.0471e+01∗ 7.0634e+01+ 201 1.1087e+12∗ 6.4245e+11 1.7257e+02∗ 1.7003e+03+\n† runtime(BB)/runtime(lssOrel_8) ∗ lssOrel_8 = 100 ∗ (0.000032 ∗ 1.1504L/(3600 ∗ 24 ∗ 366)) + lssMAts = 100 ∗ (0.000007 ∗ 1.1724L/(3600 ∗ 24 ∗ 366))\n(b)\nFigure 15: A contrast in the observed and projected asymptotic performance of state-of-the-art branch-and-bound labs solver under skew-symmetry [10] versus the observed and projected runtime of two stochastic solvers under skew-symmetry: lssOrel_8 and lssMAts. The respective formulas for each solver are rescaled versions of runtime predictions posted in Figure 12c. The average runtime for stochastic solvers has been multiplied by 100 under the assumption that each of the 100 instances will have returned an uncensored solution after reaching the best-known bound.\nlatest branch-and-bound solvers for L ≤ 89 have been found independently either by a large number of different stochastic solvers or have been found repeatedly by the same stochastic solver under a different initial seed; (2) the same best solutions for many odd values of 91 ≤ L ≤ 141 have been found at least 100 times by lssOrel_8 and at least 100 times by lssMAts, so those best-value solution are likely optimal; (3) as seen from the Table 6 for L = 151 and L = 161, the same best-value solutions have been found 95- and 76-times by lssOrel_8 and 80- and 44-times by lssMAts, so these best-value solutions may be optimal as well – a conjecture we plan to resolve with the new generation of a labs solver.\nAcknowledgments\nWe gratefully acknowledge the cooperation of José E. Gallardo, Carlos Cotta and Antonio J. Fernández in providing the source code of solvers lMAts and lssMAts.\nSource code release\nRelease of relevant solvers and a subset of xBed statistical testing environment, customized for the labs problem, is in progress. For an early release, contact the authors directly. For links to updated best known solutions of the labs problem, see [6].\nReferences\n[1] M. J. E. Golay. Sieves for low autocorrelation binary sequences. IEEE: Transactions on Information Theory, 23:43–51, 1977.\n[2] M. J. E. Golay. The merit factor of long low autocorrelation binary sequences. IEEE: Transactions on Information Theory, 28:543–549, 1982.\n[3] Marcel J E Golay and D.B. Harris. A new search for skewsymmetric binary sequences with optimal merit factors. Information Theory, IEEE Transactions on, 36(5):1163–1166, 1990.\n[4] J. Bernasconi. Low autocorrelation binary sequences: statistical mechanics and configuration space analysis. J. Phys., 48:559–567, April 1987.\n[5] Abhisek Ukil. Low autocorrelation binary sequences: Number theory-based analysis for minimum energy level, Barker codes. Digit. Signal Process., 20(2):483– 495, March 2010.\n[6] Franc Brglez, Janez Brest, and Borko Bošković. Home Page of the LABS Problem Performance Experiments and Solutions. Posted under two mirrroring sites: http://cbl.ncsu.edu/xBed/xProj/B.labs/ and http://labraj.uni-mb.si/labs, 2014.\n[7] Martin Pelikan and David E. Goldberg. Hierarchical boa solves ising spin glasses and maxsat. In Proceedings of the 2003 international conference on Genetic and evolutionary computation: PartII, GECCO’03, pages 1271–1282, Berlin, Heidelberg, 2003. SpringerVerlag.\n[8] S. Mertens. Exhaustive search for lowautocorrelation binary sequences. Journal of Physics A: Mathematical and General, 29:473–481, 1996. The sequences for 48 < L <= 60 have been found with an improved implementation due to Heiko Bauke. All values are available at http://www-e.unimagdeburg.de/mertens/research/labs/open.dat.\n[9] G.F.M. Beenker T.A.C.M. Claasen P.W.C. Hermens. Binary sequences with a maximally flat amplitude spectrum. Philips J. Res., vol. 40:289–304, 1985.\n[10] Steven D. Prestwich. Improved Branch-andBound for Low Autocorrelation Binary Sequences. http://arxiv.org/abs/1305.6187, abs/1305.6187, 2013.\n[11] deGroot C., Wurtz D., and Hoffmann K. H. Low autocorrelation binary sequences: exact enumeration and optimization by evolutionary strategies. Optimization, 23:369–384, 1992.\n[12] A. Reinholz. Ein paralleler genetischer Algorithmus zur Optimierung der binaren AutokorrelationsFunktion. Master’s thesis, Diplom Thesis, Universitaet Bonn, October 1993.\n[13] F.-M. Dittes. Optimization on rugged landscape: A new general purpose monte carlo approach. Physical Review Letters, 76:4651–4655, 1996.\n[14] B. Militzer, M. Zamparelli, and D. Beule. Evolutionary search for low autocorrelated binary sequences.\nIEEE Transactions on Evolutionary Computation, 2(1):34–39, April 1998.\n[15] F. Brglez, X. Y. Li, M. Stallmann, and B. Militzer. Reliable Cost Predictions for Finding Optimal Solutions to LABS Problem: Evolutionary and Alternative Algorithms. In Proc. of The Fifth Int. Workshop on Frontiers in Evolutionary Algorithms (FEA2003), Cary, NC, USA, September 2003. Also available at http://militzer.berkeley.edu/papers/2003-FEA-Brglez-posted.pdf.\n[16] F. Brglez, X. Y. Li, M. Stallmann, and B. Militzer. Evolutionary and Alternative Algorithms: Reliable Cost Predictions for Finding Optimal Solutions to the LABS Problem. Information Sciences, 2004. InPress. Also available at http://militzer.berkeley.edu/papers/2003-InfoSciences-accp-FB.pdf.\n[17] Steven D. Prestwich. Exploiting relaxation in local search for LABS. Annals of Operations Research, 156(1):129–141, 2007.\n[18] Steven Halim, Roland H. Yap, and Felix Halim. Engineering stochastic local search for the low autocorrelation binary sequence problem. In Proceedings of the 14th international conference on Principles and Practice of Constraint Programming, CP ’08, pages 640–645, Berlin, Heidelberg, 2008. Springer-Verlag.\n[19] José E. Gallardo, Carlos Cotta, and Antonio J. Fernández. Finding low autocorrelation binary sequences with memetic algorithms. Appl. Soft Comput., 9(4):1252–1262, September 2009.\n[20] Kai-Uwe Schmidt, Jonathan Jedwab, and Matthew G. Parker. Two Binary Sequence Families with Large Merit Factor. Advances in Mathematics of Communications, 3(2):135—156, 2009.\n[21] Jonathan Jedwab, Daniel J. Katz, and Kai-Uwe Schmidt. Advances in the Merit Factor Problem for Binary Sequences. J. Comb. Theory Ser. A, 120(4):882–906, May 2013.\n[22] Franc Brglez. Of n-dimensional Dice, Combinatorial Optimization, and Reproducible Research: An Introduction. Eletrotehnîski Vestnik 78(4) 2011: pp. 181–192, English Edition, http://ev.fe.uni-lj.si/42011/Brglez.pdf ; An invited talk at 2011-ERK, Portoroz, Slovenia, Sept. 2011 , 78(4):181–192, 2011.\n[23] Franc Brglez. Self-Avoiding Walks across nDimensional Dice and Combinatorial Optimization: An Introduction. Informacije MIDEM,\n44 (1) (2014), pp. 53-68, English Edition http://www.midem-drustvo.si/journal/ ; also at http://arxiv.org/abs/1309.7508 ; An invited talk at 2013-MIDEM, Sept. 2013, Kranjska Gora, Slovenia , 44(1):53–68, 2014.\n[24] Self-avoiding walk. Wikipedia, under http://http://en.wikipedia.org/wiki/Selfavoiding_walk, 2014.\n[25] Gordon Slade. The self-avoiding walk: A brief survey. In Jochen Blath, Peter Imkeller, and Sylvie Rœlly, editors, Surveys in Stochastic Processes, pages 181–199. European Mathematical Society, 2011.\n[26] Neal Madras and Gordon Slade. The Self-Avoiding Walk. Birkhauser Applied Probability and Statistics, 2013.\n[27] Nathan Clisby. Efficient Implementation of the Pivot Algorithm for Self-avoiding Walks. Journal of Statistical Physics, 140:349–392, July 2010.\n[28] Franc Brglez, Janez Brest, and Borko Bošković. xBed: An Open Source Environment for Design of Combinatorial Solvers and Reproducible Performance Experiments. Draft in progress, http://www.cbl.ncsu.edu/xBed/xProj/xBed/, 2014.\n[29] Pranab Kumar Sen. Censoring in Theory and Practice: Statistical Perspectives and Controversies. Institute of Mathematical Statistics, Analysis of Censored Data, 27:177–192, 1995.\n[30] The R Project for Statistical Computing. http://www.r-project.org/, Nov 2011.\n[31] I. Olkin and L. J. Gleser and C. Derman. Probability, Models, and Applications. Macmillan Publishing Co., Inc., 1980.\n[32] F. Brglez, X. Y. Li, and M. F. M. Stallmann. On SAT instance classes and a method for reliable performance experiments with SAT solvers. Ann. Math. Art. Intell.,, 43(1):1–34, 2005.\n[33] A dedicated ’sam cluster’ of 22 processors. NCSU High Performance Computing Services. See also http://www.ncsu.edu/itd/hpc/ for an overview, 2013.\n[34] SLING - Slovenian Initiative for National Grid. See http://www.sling.si/sling/ for an overview, 2014.\n[35] R. M. Dudley. Real Analysis and Probability. Cambridge University Press, 2004."
    } ],
    "references" : [ {
      "title" : "Sieves for low autocorrelation binary sequences",
      "author" : [ "M.J.E. Golay" ],
      "venue" : "IEEE: Transactions on Information Theory,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1977
    }, {
      "title" : "The merit factor of long low autocorrelation binary sequences",
      "author" : [ "M.J.E. Golay" ],
      "venue" : "IEEE: Transactions on Information Theory,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1982
    }, {
      "title" : "A new search for skewsymmetric binary sequences with optimal merit factors",
      "author" : [ "Marcel J E Golay", "D.B. Harris" ],
      "venue" : "Information Theory, IEEE Transactions on,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1990
    }, {
      "title" : "Low autocorrelation binary sequences: statistical mechanics and configuration space analysis",
      "author" : [ "J. Bernasconi" ],
      "venue" : "J. Phys.,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1987
    }, {
      "title" : "Low autocorrelation binary sequences: Number theory-based analysis for minimum energy level, Barker codes",
      "author" : [ "Abhisek Ukil" ],
      "venue" : "Digit. Signal Process.,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2010
    }, {
      "title" : "Home Page of the LABS Problem Performance Experiments and Solutions. Posted under two mirrroring sites: http://cbl.ncsu.edu/xBed/xProj/B.labs/ and http://labraj.uni-mb.si/labs",
      "author" : [ "Franc Brglez", "Janez Brest", "Borko Bošković" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2014
    }, {
      "title" : "Hierarchical boa solves ising spin glasses and maxsat",
      "author" : [ "Martin Pelikan", "David E. Goldberg" ],
      "venue" : "In Proceedings of the 2003 international conference on Genetic and evolutionary computation: PartII,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2003
    }, {
      "title" : "Exhaustive search for lowautocorrelation binary sequences",
      "author" : [ "S. Mertens" ],
      "venue" : "Journal of Physics A: Mathematical and General,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1996
    }, {
      "title" : "Binary sequences with a maximally flat amplitude spectrum",
      "author" : [ ],
      "venue" : "Philips J. Res.,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 1985
    }, {
      "title" : "Improved Branch-and- Bound for Low Autocorrelation",
      "author" : [ "Steven D. Prestwich" ],
      "venue" : "Binary Sequences. http://arxiv.org/abs/1305.6187,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2013
    }, {
      "title" : "Low autocorrelation binary sequences: exact enumeration and optimization by evolutionary strategies",
      "author" : [ "C. deGroot", "D. Wurtz", "H. Hoffmann K" ],
      "venue" : "Optimization, 23:369–384,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1992
    }, {
      "title" : "Ein paralleler genetischer Algorithmus zur Optimierung der binaren Autokorrelations- Funktion",
      "author" : [ "A. Reinholz" ],
      "venue" : "Master’s thesis, Diplom Thesis,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1993
    }, {
      "title" : "Optimization on rugged landscape: A new general purpose monte carlo approach",
      "author" : [ "F.-M. Dittes" ],
      "venue" : "Physical Review Letters,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1996
    }, {
      "title" : "Evolutionary search for low autocorrelated binary sequences",
      "author" : [ "B. Militzer", "M. Zamparelli", "D. Beule" ],
      "venue" : "IEEE Transactions on Evolutionary Computation,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1998
    }, {
      "title" : "Reliable Cost Predictions for Finding Optimal Solutions to LABS Problem: Evolutionary and Alternative Algorithms",
      "author" : [ "F. Brglez", "X.Y. Li", "M. Stallmann", "B. Militzer" ],
      "venue" : "In Proc. of The Fifth Int. Workshop on Frontiers in Evolutionary Algorithms",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2003
    }, {
      "title" : "Evolutionary and Alternative Algorithms: Reliable Cost Predictions for Finding Optimal Solutions to the LABS Problem",
      "author" : [ "F. Brglez", "X.Y. Li", "M. Stallmann", "B. Militzer" ],
      "venue" : "Information Sciences,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2004
    }, {
      "title" : "Exploiting relaxation in local search for LABS",
      "author" : [ "Steven D. Prestwich" ],
      "venue" : "Annals of Operations Research,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2007
    }, {
      "title" : "Engineering stochastic local search for the low autocorrelation binary sequence problem",
      "author" : [ "Steven Halim", "Roland H. Yap", "Felix Halim" ],
      "venue" : "In Proceedings of the 14th international conference on Principles and Practice of Constraint Programming, CP",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2008
    }, {
      "title" : "Finding low autocorrelation binary sequences with memetic algorithms",
      "author" : [ "José E. Gallardo", "Carlos Cotta", "Antonio J. Fernández" ],
      "venue" : "Appl. Soft Comput.,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2009
    }, {
      "title" : "Two Binary Sequence Families with Large Merit Factor",
      "author" : [ "Kai-Uwe Schmidt", "Jonathan Jedwab", "Matthew G. Parker" ],
      "venue" : "Advances in Mathematics of Communications,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2009
    }, {
      "title" : "Advances in the Merit Factor Problem for Binary Sequences",
      "author" : [ "Jonathan Jedwab", "Daniel J. Katz", "Kai-Uwe Schmidt" ],
      "venue" : "J. Comb. Theory Ser. A,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2013
    }, {
      "title" : "Of n-dimensional Dice, Combinatorial Optimization, and Reproducible Research: An Introduction",
      "author" : [ "Franc Brglez" ],
      "venue" : "Eletrotehnîski Vestnik",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2011
    }, {
      "title" : "Self-Avoiding Walks across n- Dimensional Dice and Combinatorial Optimization: An Introduction. Informacije MIDEM, 27  Low-Autocorrelation Binary Sequences: on .",
      "author" : [ "Franc Brglez" ],
      "venue" : "English Edition http://www.midem-drustvo.si/journal/",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2014
    }, {
      "title" : "The self-avoiding walk: A brief survey",
      "author" : [ "Gordon Slade" ],
      "venue" : "Surveys in Stochastic Processes,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2011
    }, {
      "title" : "The Self-Avoiding Walk",
      "author" : [ "Neal Madras", "Gordon Slade" ],
      "venue" : "Birkhauser Applied Probability and Statistics,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2013
    }, {
      "title" : "Efficient Implementation of the Pivot Algorithm for Self-avoiding Walks",
      "author" : [ "Nathan Clisby" ],
      "venue" : "Journal of Statistical Physics,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2010
    }, {
      "title" : "xBed: An Open Source Environment for Design of Combinatorial Solvers and Reproducible Performance Experiments",
      "author" : [ "Franc Brglez", "Janez Brest", "Borko Bošković" ],
      "venue" : "Draft in progress, http://www.cbl.ncsu.edu/xBed/xProj/xBed/,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2014
    }, {
      "title" : "Censoring in Theory and Practice: Statistical Perspectives and Controversies",
      "author" : [ "Pranab Kumar Sen" ],
      "venue" : "Institute of Mathematical Statistics, Analysis of Censored Data,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 1995
    }, {
      "title" : "Probability, Models, and Applications",
      "author" : [ "I. Olkin", "L.J. Gleser", "C. Derman" ],
      "venue" : "Macmillan Publishing Co., Inc.,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 1980
    }, {
      "title" : "On SAT instance classes and a method for reliable performance experiments with SAT solvers",
      "author" : [ "F. Brglez", "X.Y. Li", "M.F.M. Stallmann" ],
      "venue" : "Ann. Math. Art. Intell.,,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2005
    }, {
      "title" : "Real Analysis and Probability",
      "author" : [ "R.M. Dudley" ],
      "venue" : null,
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2004
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "sL, si ∈ {+1,−1}, the autocorrelation function Ck(S) = ∑L−k i=1 sisi+k, and minimize the energy function: E(S) = L−1 ∑ k=1 C2 k(S) (1) or alternatively, maximize the merit factor F: [1, 2, 3]: F (S) = L2/(2E(S)).",
      "startOffset" : 182,
      "endOffset" : 191
    }, {
      "referenceID" : 1,
      "context" : "sL, si ∈ {+1,−1}, the autocorrelation function Ck(S) = ∑L−k i=1 sisi+k, and minimize the energy function: E(S) = L−1 ∑ k=1 C2 k(S) (1) or alternatively, maximize the merit factor F: [1, 2, 3]: F (S) = L2/(2E(S)).",
      "startOffset" : 182,
      "endOffset" : 191
    }, {
      "referenceID" : 2,
      "context" : "sL, si ∈ {+1,−1}, the autocorrelation function Ck(S) = ∑L−k i=1 sisi+k, and minimize the energy function: E(S) = L−1 ∑ k=1 C2 k(S) (1) or alternatively, maximize the merit factor F: [1, 2, 3]: F (S) = L2/(2E(S)).",
      "startOffset" : 182,
      "endOffset" : 191
    }, {
      "referenceID" : 3,
      "context" : "To physicists, the optimum solution of the labs problem corresponds to the ground state of a generalized onedimensional Ising spin system with long range 4-spin interactions [4], also known as the Bernasconi model with aperiodic autocorrelation.",
      "startOffset" : 174,
      "endOffset" : 177
    }, {
      "referenceID" : 1,
      "context" : "The asymptotic value for the maximum merit factor F , introduced in [2], has been re-derived using arguments from statistical mechanics [4]: as L→∞, then F → 12.",
      "startOffset" : 68,
      "endOffset" : 71
    }, {
      "referenceID" : 3,
      "context" : "The asymptotic value for the maximum merit factor F , introduced in [2], has been re-derived using arguments from statistical mechanics [4]: as L→∞, then F → 12.",
      "startOffset" : 136,
      "endOffset" : 139
    }, {
      "referenceID" : 4,
      "context" : "Sequence length D ev ia tio n 0 50 100 150 200 250 300 350 400 _ ● 2nd order polynomial extrapolation Knauer’s aggregation solver lssOrel Figure 1: A deviation-vs-length plot, introduced in [5], fits deviations from known optimal solutions for L ≤ 60 to a secondorder polynomial (the dotted line).",
      "startOffset" : 190,
      "endOffset" : 193
    }, {
      "referenceID" : 5,
      "context" : "The solutions aggregated in Joshua Knauer, now under [6], are shown as ’circles’ for sequences 5 < L ≤ 304.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 6,
      "context" : "with limited interaction and periodic boundary conditions, for example [7].",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 6,
      "context" : "While effective methods have been presented to solve the special cases up to L = 400 [7], the best merit factors that has also been proven optimal for the problem as formulated in (2) are presently known for values of L ≤ 60 only [8].",
      "startOffset" : 85,
      "endOffset" : 88
    }, {
      "referenceID" : 7,
      "context" : "While effective methods have been presented to solve the special cases up to L = 400 [7], the best merit factors that has also been proven optimal for the problem as formulated in (2) are presently known for values of L ≤ 60 only [8].",
      "startOffset" : 230,
      "endOffset" : 233
    }, {
      "referenceID" : 5,
      "context" : "This page is no longer accessible and has now been restored at two mirroring sites [6] next to additional and comprehensive tables of best-value solutions.",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 4,
      "context" : "To visualize the differences between the optimum value, the best known energy values, and the projected values, we use the deviation-vs-length plot introduced in [5].",
      "startOffset" : 162,
      "endOffset" : 165
    }, {
      "referenceID" : 5,
      "context" : "The reference values in this plot and the regression line in Figure 1 have been calculated from the energy values of best results posted under [6].",
      "startOffset" : 143,
      "endOffset" : 146
    }, {
      "referenceID" : 0,
      "context" : "The approaches to solving the labs problem also include exhaustive enumeration, for both even and odd sequences or only for skew-symmetric sequences which are odd by definition [1, 2, 3, 9].",
      "startOffset" : 177,
      "endOffset" : 189
    }, {
      "referenceID" : 1,
      "context" : "The approaches to solving the labs problem also include exhaustive enumeration, for both even and odd sequences or only for skew-symmetric sequences which are odd by definition [1, 2, 3, 9].",
      "startOffset" : 177,
      "endOffset" : 189
    }, {
      "referenceID" : 2,
      "context" : "The approaches to solving the labs problem also include exhaustive enumeration, for both even and odd sequences or only for skew-symmetric sequences which are odd by definition [1, 2, 3, 9].",
      "startOffset" : 177,
      "endOffset" : 189
    }, {
      "referenceID" : 8,
      "context" : "The approaches to solving the labs problem also include exhaustive enumeration, for both even and odd sequences or only for skew-symmetric sequences which are odd by definition [1, 2, 3, 9].",
      "startOffset" : 177,
      "endOffset" : 189
    }, {
      "referenceID" : 7,
      "context" : "Exact solutions were also pursued by branch and bound solvers: for both even and odd sequences [8] and for skew-symmetric sequences only [10].",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "Exact solutions were also pursued by branch and bound solvers: for both even and odd sequences [8] and for skew-symmetric sequences only [10].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 3,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 10,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 11,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 12,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 13,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 14,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 15,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 16,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 17,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 18,
      "context" : "Since such solvers cannot prove optimality, they can only be compared on the basis of the best-value solutions, and to a limited extent, also on the average runtime needed to find such solutions under a sufficiently large number of repeated trials [4, 11, 12, 13, 14, 15, 16, 17, 18, 19].",
      "startOffset" : 248,
      "endOffset" : 287
    }, {
      "referenceID" : 18,
      "context" : "Experimental results obtained with our stochastic solver lssOrel are compared to the instrumented versions of two solvers in [19], referred to as 2009 solvers in the abstract, and named as 2",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 19,
      "context" : "However, merit factors obtained by approaches in theory [20, 21] are reported at values less than 7 – so the challenge of finding long sequences that would approach the asymptotic value for the maximum merit factor F = 12.",
      "startOffset" : 56,
      "endOffset" : 64
    }, {
      "referenceID" : 20,
      "context" : "However, merit factors obtained by approaches in theory [20, 21] are reported at values less than 7 – so the challenge of finding long sequences that would approach the asymptotic value for the maximum merit factor F = 12.",
      "startOffset" : 56,
      "endOffset" : 64
    }, {
      "referenceID" : 21,
      "context" : "Notation and Definitions This section follows notation, definitions, and metaphors introduced in [22] and [23].",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 22,
      "context" : "Notation and Definitions This section follows notation, definitions, and metaphors introduced in [22] and [23].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 18,
      "context" : "There are two illustrations of such walks: a small one in Figure 2 at the end of this section, and a larger instance in Section III where, in Figure 5, we compare a self-avoiding walk induced by our solver lssOrel with a walk based on tabu search induced by the solver lssMAts [19].",
      "startOffset" : 277,
      "endOffset" : 281
    }, {
      "referenceID" : 0,
      "context" : "1 as a coordinate-value pair in the form ς : Θ(ς) (4) where ς is a binary string of length L, also denoted as the coordinate from [0, 1]L, and Θ(ς) is the value associated with this coordinate.",
      "startOffset" : 130,
      "endOffset" : 136
    }, {
      "referenceID" : 0,
      "context" : "Formally, skew-symmetry has been introduced in [1].",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 9,
      "context" : "Only recently, a branch-and-bound solver [10] extended known optimal solutions for skew-symmetric sequences from length 73 to 89.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 21,
      "context" : "Hasse graph has been defined in [22, 23] as a model of hyperhedron (or informally, a dice) based on an extension of the Hasse diagram.",
      "startOffset" : 32,
      "endOffset" : 40
    }, {
      "referenceID" : 22,
      "context" : "Hasse graph has been defined in [22, 23] as a model of hyperhedron (or informally, a dice) based on an extension of the Hasse diagram.",
      "startOffset" : 32,
      "endOffset" : 40
    }, {
      "referenceID" : 23,
      "context" : "In mathematics, a SAW lives in the n-dimensional lattice Zn which consists of the points in Rn whose components are all integers [25, 26].",
      "startOffset" : 129,
      "endOffset" : 137
    }, {
      "referenceID" : 24,
      "context" : "In mathematics, a SAW lives in the n-dimensional lattice Zn which consists of the points in Rn whose components are all integers [25, 26].",
      "startOffset" : 129,
      "endOffset" : 137
    }, {
      "referenceID" : 25,
      "context" : "The challenge of finding the longest self-avoiding walk in multi-dimensional lattices efficiently has been and also continues to be of considerable interest in physics [27].",
      "startOffset" : 168,
      "endOffset" : 172
    }, {
      "referenceID" : 18,
      "context" : "Two solvers, lMAts and lssMAts, as described in [19] implement a memetic-tabu search strategy.",
      "startOffset" : 48,
      "endOffset" : 52
    }, {
      "referenceID" : 26,
      "context" : "In our case, this environment continues to evolve under the working name of xBed [28].",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 27,
      "context" : "We argue that reliable estimates of confidence bounds on the mean values of runtime or cntProbe returned by combinatorial solvers under censoring are a subject best left to statisticians [29].",
      "startOffset" : 187,
      "endOffset" : 191
    }, {
      "referenceID" : 28,
      "context" : "This definition relies on the theorem that the sum of variates with exponential distribution has gamma distribution [31].",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 29,
      "context" : "The solvability as defined in this paper relates directly to combinatorial solvers and hitRatio; it also represents a generalization of the solvability function already defined in [32].",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 18,
      "context" : "Both solvers in Figure 4, lMAts and lssMAts, are instrumented versions of the labs solver named as MAT S in [19].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 18,
      "context" : "These solvers, their pseudo code, and associated experiments and results, are described in [19].",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 18,
      "context" : "Setting of control parameters in our experiments are identical to ones used in [19]; a consise reprise of these setting is shown in the top-right part of Figure 4.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 18,
      "context" : "org and for journal review 1: procedure lssMAts(Θub L , tlmt) 2: for i← 1 to popsize do 3: popi ← RandomBinarySequence(L) 4: Evaluate(popi) 5: end for 6: Θ(ς∗)← ValueBest(pop) 7: while t < tlmt and Θ(ς∗)> Θub L do 8: for i = 1 to offsize do 9: if recombination is performed (pX) then 10: parent1 ←Select(pop) 11: parent2 ←Select(pop) 12: offspringi ←Recombine(parent1, parent2) 13: else 14: offspringi ←Select(pop) 15: end if 16: if mutation is performed (pm) then 17: offspringi ←Mutate(offspringi) 18: end if 19: offspringi ←TabuSearch(offspringi) 20: Evaluate(offspringi) 21: end for 22: pop←Replace(pop, offspring) 23: Θ(ς∗)← ValueBest(pop) 24: end while 25: end procedure (a) lssMAts solver, based on MAT S in [19].",
      "startOffset" : 715,
      "endOffset" : 719
    }, {
      "referenceID" : 18,
      "context" : "The procedure lssMAts on the left is an instrumented versions of the labs solver named as MAT S in [19].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 18,
      "context" : "Settings of all parameters, used also in our experiments, are described in [19].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 18,
      "context" : "Figure 4: We illustrate two instrumented versions of the labs solver named as MAT S in [19] under the caption “Pseudo code of the memetic algorithm”, Figure 5.",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 9,
      "context" : "5)c] = [10, 31], and for the instance shown, the value of 27 has been selected.",
      "startOffset" : 7,
      "endOffset" : 15
    }, {
      "referenceID" : 28,
      "context" : "5)c] = [10, 31], and for the instance shown, the value of 27 has been selected.",
      "startOffset" : 7,
      "endOffset" : 15
    }, {
      "referenceID" : 9,
      "context" : "With lssMAts and the initial coordinate 11101011100, runs with 32 random seeds return walks of lengths in the range of [10, 31] where only 14 walks terminate at the target solution value of 26.",
      "startOffset" : 119,
      "endOffset" : 127
    }, {
      "referenceID" : 28,
      "context" : "With lssMAts and the initial coordinate 11101011100, runs with 32 random seeds return walks of lengths in the range of [10, 31] where only 14 walks terminate at the target solution value of 26.",
      "startOffset" : 119,
      "endOffset" : 127
    }, {
      "referenceID" : 3,
      "context" : "With lssOrel and the initial coordinate 11101011100, runs with 32 random seeds return walks of lengths in the range of [4, 226] where all 32 walks terminate at the target solution value of 26.",
      "startOffset" : 119,
      "endOffset" : 127
    }, {
      "referenceID" : 26,
      "context" : "We follow this methodology consistently, under the given computational resources and time constraints [28].",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 14,
      "context" : "4072 (d) Asymptotic comparisons to earlier solvers [15, 16].",
      "startOffset" : 51,
      "endOffset" : 59
    }, {
      "referenceID" : 15,
      "context" : "4072 (d) Asymptotic comparisons to earlier solvers [15, 16].",
      "startOffset" : 51,
      "endOffset" : 59
    }, {
      "referenceID" : 14,
      "context" : "Finally, the solver lMAts significantly outperforms the two earlier stochastic solvers, ES and KL from [15, 16].",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 15,
      "context" : "Finally, the solver lMAts significantly outperforms the two earlier stochastic solvers, ES and KL from [15, 16].",
      "startOffset" : 103,
      "endOffset" : 111
    }, {
      "referenceID" : 14,
      "context" : "(d) The solver lMAts significantly outperforms the two earlier stochastic solvers, ES and KL [15, 16].",
      "startOffset" : 93,
      "endOffset" : 101
    }, {
      "referenceID" : 15,
      "context" : "(d) The solver lMAts significantly outperforms the two earlier stochastic solvers, ES and KL [15, 16].",
      "startOffset" : 93,
      "endOffset" : 101
    }, {
      "referenceID" : 5,
      "context" : "In 2002, Knauer posted the ‘best-value solutions’ for L > 101 without the restriction of skew-symmetry [6]; results in Table 5 show that our skew-symmetry solver lssOrel consistently returns improved skew-symmetric solutions vis-à-vis Knauer’s solutions without skew-symmetry, and then a few more.",
      "startOffset" : 103,
      "endOffset" : 106
    }, {
      "referenceID" : 5,
      "context" : "Values marked with * are an improvement on values posted by Knauer in 2002, now accessible under [6].",
      "startOffset" : 97,
      "endOffset" : 100
    }, {
      "referenceID" : 5,
      "context" : "We make no attempt to find new and improved solutions for all values of L in [6], except to show that solver lssOrel consistently returns improved skew-symmetric solutions vis-à-vis Knauer’s solutions without skew-symmetry.",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 25,
      "context" : "In lattices, with grid structures that are different and relatively simpler when compared to our Hasse graphs, physicists continue to push the envelope on the maximum length of self-avoiding walks: experiments with longest walks under 64 GB of memory are reported as having maximum lengths of 228 − 1 in a 3D lattice and 225 − 1 in a 4D lattice [27].",
      "startOffset" : 345,
      "endOffset" : 349
    }, {
      "referenceID" : 18,
      "context" : "The settings of lssMAts are the same as described in [19] and also shown in Figure 4.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 5,
      "context" : "2747 [6]; this value is represented with the blue line in Figure 14b.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 5,
      "context" : "2747, currently reported as the best known value [6].",
      "startOffset" : 49,
      "endOffset" : 52
    }, {
      "referenceID" : 7,
      "context" : "Conclusions And Future Work Despite the relatively high cost of running a branch-andbound solver, the merits of finding exact solutions returned by solvers such as [8] and [10] should not be underestimated.",
      "startOffset" : 164,
      "endOffset" : 167
    }, {
      "referenceID" : 9,
      "context" : "Conclusions And Future Work Despite the relatively high cost of running a branch-andbound solver, the merits of finding exact solutions returned by solvers such as [8] and [10] should not be underestimated.",
      "startOffset" : 172,
      "endOffset" : 176
    }, {
      "referenceID" : 7,
      "context" : "The publication of optimal figures of merit for a subset of labs instances in [8] motivated not only the formulation of the stopping criterion for the stochastic labs solvers in [15, 16], it also initiated methodology and solver instrumentation that is now being refined and extended in this paper.",
      "startOffset" : 78,
      "endOffset" : 81
    }, {
      "referenceID" : 14,
      "context" : "The publication of optimal figures of merit for a subset of labs instances in [8] motivated not only the formulation of the stopping criterion for the stochastic labs solvers in [15, 16], it also initiated methodology and solver instrumentation that is now being refined and extended in this paper.",
      "startOffset" : 178,
      "endOffset" : 186
    }, {
      "referenceID" : 15,
      "context" : "The publication of optimal figures of merit for a subset of labs instances in [8] motivated not only the formulation of the stopping criterion for the stochastic labs solvers in [15, 16], it also initiated methodology and solver instrumentation that is now being refined and extended in this paper.",
      "startOffset" : 178,
      "endOffset" : 186
    }, {
      "referenceID" : 18,
      "context" : "State-of-the-art solutions to the labs problem provided by the two stochastic solvers, lMAts and lssMAts [19] represent a significant challenge for any new approach 22",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 8,
      "context" : "org and for journal review L [9] [3] [12] [17] [14] [6] [19] lssOrel_8 107 6.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 2,
      "context" : "org and for journal review L [9] [3] [12] [17] [14] [6] [19] lssOrel_8 107 6.",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 11,
      "context" : "org and for journal review L [9] [3] [12] [17] [14] [6] [19] lssOrel_8 107 6.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 16,
      "context" : "org and for journal review L [9] [3] [12] [17] [14] [6] [19] lssOrel_8 107 6.",
      "startOffset" : 42,
      "endOffset" : 46
    }, {
      "referenceID" : 13,
      "context" : "org and for journal review L [9] [3] [12] [17] [14] [6] [19] lssOrel_8 107 6.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 5,
      "context" : "org and for journal review L [9] [3] [12] [17] [14] [6] [19] lssOrel_8 107 6.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 18,
      "context" : "org and for journal review L [9] [3] [12] [17] [14] [6] [19] lssOrel_8 107 6.",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 18,
      "context" : "Compared to evolutionary methods, significant advantage in speed is gained by implementing efficient incremental probing of coordinates adjacent to the pivot coordinate, such as the data structures documented in Figures 1 and 2 in [19].",
      "startOffset" : 231,
      "endOffset" : 235
    }, {
      "referenceID" : 9,
      "context" : "The new branchand-bound solver, now limited to odd values of L under skew-symmetry, reports optimum solutions for values of L ≤ 89 [10].",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 30,
      "context" : "For the context and definition of almost surely, see [35].",
      "startOffset" : 53,
      "endOffset" : 57
    } ],
    "year" : 2017,
    "abstractText" : "Search for binary sequences with a high figure of merit, also known as the low autocorrelation binary sequence (labs) problem, represents a formidable computational challenge. By 2002, a branch-and-bound solver presented optimal solutions for even and odd sequences up to length L = 60 and reported computational complexity of O(1.85). In 2003, two stochastic solvers replicated these solutions, reaching the same figures of merit, and reported computational complexity of O(1.423) and O(1.370), refined to O(1.5097) and O(1.4072) for L odd in this paper. New experiments, with the solver from 2009 and also reported in this paper, demonstrate (a) the average-case asymptotic performance of 114.515 ∗ 1.3464 for even-only values, and (b) the average-case asymptotic performance of 320.360 ∗ 1.3421 for odd-only values. To mitigate the computational constraints of the labs problem, we consider solvers that accept odd values of L and return solutions for skew-symmetric binary sequences only – with the consequence that not all best solutions under this constraint will also be optimal for each value of L. Specifically, we have instrumented three such solvers for extensive average-case asymptotic performance experiments. Two solvers are based on the version from 2009; both differ only in one respect: the 2009 solver uses an evolutionary algorithm to initialize the tabu search, the modified solver initializes the tabu search with a random binary sequence. What has not been expected is that the asymptotic average-case performance of the first and the second solver are statistically equivalent: for the range 71 <= L <= 127 we observe 150.49 ∗ 1.1646 for the memetic-tabu version versus 156.34 ∗ 1.1646 for the random-tabu version. Thus, for the labs problem, the evolutionary component of this solver is not effective. Our solver relies on a single contiguous self-avoiding walk until memory constraints induce random restarts. Under random restarts, the solver reaches the target value with a number of independent contiguous self-avoiding walk segments. Under the fixed walk segment compromise and random restarts, we observe 650.07 ∗ 1.1435 for the range 71 ≤ L ≤ 127. We show that the solver with the best average-case asymptotic performance has the best chance of finding new solutions that significantly improve, as L increases, figures of merit reported to date.",
    "creator" : "LaTeX with hyperref package"
  }
}