{
  "name" : "1512.07430.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 2.\n07 43\n0v 1\n[ cs\n.D B\n] 2\n3 D\nec 2\n01 5\nKeywords: entity, attribute, relationship, schema, universe, structure.\nTable of Contents\nThe ERA of FOLE: Foundation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Robert E. Kent 1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 2 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 3 ERA Data Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n3.1 Attributes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 3.2 Entities. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7 3.3 Relations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 4 FOLE Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 4.1 Schema. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9 4.2 Universe. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 4.3 Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 4.4 Interpretation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17 5 Connections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 5.1 Analogy. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19 5.2 Linearization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 6 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 A The Fibered Context of Structures. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\nA.1 An Exemplar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25 A.2 Schema Orientation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 A.3 Universe Orientation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28"
    }, {
      "heading" : "1 Introduction",
      "text" : "The first-order logical environment FOLE (Kent [8]) is a framework for defining the semantics and formalism of logic and databases in an integrated and coherent fashion. Institutions in general, and logical environments in particular, give equivalent heterogeneous and homogeneous representations for logical systems. FOLE is an institution, since “satisfaction is invariant under change of notation”. FOLE is a logical environment, since “satisfaction respects structure linkage”. As an institution, the architecture of FOLE consists of languages as indexing components, structures to represent semantic content, specifications to represent formal content, and logics to combine formalism with semantics. FOLE structures are interpreted as relational/logical databases. This is the first of three papers, which are concerned with the presentation of FOLE: (1) the FOLE foundation, (2) the FOLE superstructure (Kent [9]), and (3) the FOLE interpretation (Kent [10]).\nThis paper, which is concerned with the FOLE foundation, is illustrated in Fig. 7 and is centered on the mathematical context of structures. 1 In § 3 and § 4 we show how the ERA data model is represented in FOLE by connecting elements of the ERA data model to components of the FOLE structure concept. § 3 discusses the direct lower-level connection between the ERA elements (attributes, entities, relations) and the FOLE components (type domains and entity classifications). 2 § 4 discusses the abstract higher-level representation of the ERA data model within the FOLE architecture. In addition, we give a rudimentary description of the interpretation of FOLE structures in § 4.4. In § 5 we connect FOLE to Sowa’s knowledge representation hierarchy (Sowa [11]) and through linearization to the Olog data model (Spivak and Kent [12]).\nThe FOLE superstructure, which is concern with the formalism and semantics of first-order logic, and the FOLE interpretation, which is concerned with database interpretation, are presented in the two papers that follow this one. Two further papers are pending on the integration of federated systems of knowledge: one discusses integration over a fixed type domain and the other discusses integration over a fixed universe.\nFig. 1 : ERA Data Model in FOLE Fig. 2 : Example Fig. 3 : Structure Fig. 4 : Interpreted Structure Fig. 5 : Structure Morphism Fig. 6 : Interpreted Structure Morphism Fig. 7 : FOLE Foundation Fig. 8 : Analogy\nTbl. 1 : FOLE-ERA Correspondence Tbl. 2 : Matrix of six central categories\nFigures and Tables\n1 Following the original discussion of FOLE (Kent [8]), we use “mathematical context” (Goguen [4]) for the mathematical term “category”, “passage” for the term “functor”, and “bridge” for the term “natural transformation”. 2 The theory of classifications and infomorphisms is discussed in the book Information Flow by Barwise and Seligman [1]."
    }, {
      "heading" : "2 Overview",
      "text" : "A conceptual model for a community represents the information needed by the community — the content, relationships and constraints necessary to describe the community. The content consists of things of significance to the community (entities), and characteristics of those things (attributes). The relationships are associations between those things. The entities are the core concepts that are used for representing the semantics of the community. Entities are described by attributes, which are the various properties, characteristics, modifiers, aspects or features of entities. Hence, the entity-relationship-attribute (ERA) formalism is a ternary representation for knowledge, since it uses three kinds for representation: entities, attributes and relations. In contrast, the first-order logical environment FOLE (Kent [8]) followed the knowledge representation approach of traditional many-sorted first-order logic (MSFOL). Both the original FOLE formalism and the MSFOL formalism are binary representations for knowledge, since they use two kinds for representation: entities and relations.\nRevised FOLE Terminology. However, the first-order logical environment FOLE can very naturally represent the ERA data model. The idea is that the original FOLE relation represented a nexus of roles, where the roles were played by the original FOLE entities. In order to represent the ERA data model, we think of the original FOLE relations as the new FOLE entities described by a nexus of features or aspects, where the aspects are represented by the new FOLE attributes, which replace the original FOLE entities. In the FOLE representation of the ERA data model, entities and their attributes are primary notions, whereas relationships are secondary notions that are subsumed by other constructs. Some relations (foreign keys, subtypes, sums, ...) have a special representation in FOLE; whereas, other relations can be resolved into concepts (entities) with a nexus of roles.\nTbl. 1 shows the terminological correspondence between the basic components of (old/new) FOLE and ERA. For example, the original FOLE entity type is renamed the new FOLE attribute type (sort), and this corresponds to the ERA attribute type (data type); and the original FOLE relation instance is renamed the new FOLE entity instance (key), and this corresponds to the ERA entity.\nPhilosophy: the ERA of FOLE. As commonly observed, an entity is a thing capable of an independent existence that can be uniquely identified. In natural language, an entity corresponds to a noun. A relationship links entities, and corresponds to\na verb in natural language. Entities and relationships can both have attributes. In natural language, a relational attribute corresponds to a role or case. Inclusion and subtype relationships are special kinds of relationships. A data model can be visualized in terms of entities, relationships and attributes. But in general, relationships can be conceptualized by being converted to entities.\nHence, a data model is more simply conceptualized in terms of entities and attributes. When doing so, there is an implied boundary around the visualization, which converts an entity’s collection of attributes into a list (possibly infinite in size or arity); a signature is the list of attribute types (sorts) associated with an entity type, whereas a tuple is the list of attribute instances (values) associated with an entity instance (key). Entity types can be mapped to the associated signature, and entity instances (primary keys) identify and can be mapped to the associated tuple (horizontal dimension of Fig. 1). In general, types classify instances. Hence, entity types classify keys and sorts classify values (vertical dimension of Fig. 1). Implicit from the ERA data model is an entity type system and multi-sorted logic, which uses boolean operators and quantification, and is defined in terms of signature-based fibers of formulas (queries) in Kent [9].\nIn review, the simplest way to handle things is first to distinguish types from instances along the FOLE classification dimension in Fig. 1, and second to view things (either types or instances) as participating in Whitehead’s fundamental prehension relationship (Sowa [11]) along the FOLE hypergraph dimension in Fig. 1, which links a prehending thing called an entity to a prehended thing called an attribute: “an entity has an attribute”. The ERA data model of FOLE uses an inclusive prehension for things; hence, it is a mixed data model; some entities are not attributes, some attributes are not entities, and some are both. For any type in the overlap E∩A, any instance of that type is also in the overlap. Foreign keys are examples of things that are both entities and attributes, things in the overlap.\nE : entities A : attributes ✧✦ ★✥ ✧✦ ★✥\nE A E ∩A = ∅\n✧✦ ★✥ ✧✦ ★✥ E A\nE ∩A 6= ∅\n✧✦ ★✥ E =A\nDisjoint Model Mixed Model Unified Model\n3 ERA Data Model"
    }, {
      "heading" : "3.1 Attributes.",
      "text" : "In the ERA data model, attributes are represented by a typed domain consisting of a collection of data types. In FOLE, a typed domain is represented by an attribute classification A = 〈X,Y, |=A〉 consisting of a set of attribute types (sorts) X , a set of attribute instances (data values) Y and an attribute classification relation |=A ⊆X×Y . For each sort (attribute type) x ∈ X , the data domain of that type is the A-extent Ax = extA(x) = {y ∈ Y | y |=A x}. The passage X extA−−−→ ℘Y maps a sort x∈X to its data domain (A-extent) Ax ⊆ Y .\nAn X-signature (header) is a sort list 〈I, s〉, where I s −→ X is a map from an indexing set (arity) I to the set of sorts X . A more visual representation for this signature is (· · · si · · · | i∈ I). The mathematical context of X-signatures is List(X). 3 4 A Y -tuple (row) is an list of data values 〈J, t〉, where J t −→ Y is a map from an indexing set (arity) J to the set of data values Y . A more visual representation for this tuple is (· · · tj · · · | j ∈ J). The mathematical context of Y -tuples is List(Y ). The attribute list classification List(A) = 〈List(X),List(Y ), |=List(A)〉 hasX-signatures as types and Y -tuples as instances, with classification by common arity and universal A-classification: a Y -tuple 〈J, t〉 is classified by an X-signature 〈I, s〉 when J = I and tk |=A sk for all k ∈ J = I."
    }, {
      "heading" : "3.2 Entities.",
      "text" : "We distinguish between an entity instance and an entity type. An entity type is a category of existence; entity types classify entity instances. There might be many instances of an entity type, and an entity instance can be classified by many types. An entity instance (entity, for short) is also called an object. Every entity is uniquely identified by a key. In FOLE, entities and their types are collected together locally in an entity classification E = 〈R,K, |=E〉 consisting of a set of entity types R, a set of entity instances (keys) K and an entity classification relation |=E ⊆R×K. In the database interpretation in §4.4, each entity type r ∈ R is regarded to be the name for a relation (or table) in the database: for each entity type (relation name) r ∈ R, the set of primary keys for that type is the E-extent Er = extE(r) = {k ∈ K | k |=E r}.\n3 List(X) is the comma context List(X) = (Set ↓X) of X-signatures, where an\nobject 〈I, s〉 is an X-signature and a morphism 〈I ′, s′〉 h −→ 〈I, s〉 is an arity function I ′ h −→ I that preserves signatures h · s = s′; visually, (· · · s′i′ · · · | i\n′ ∈ I ′) = (· · · sh(i′) · · · | i\n′ ∈ I ′). 4 The header for a database table is a signature (list of sorts) 〈I, s〉 ∈ List(X). Pairs (i : si) from a signature 〈I, s〉 are called attributes (see § 4.1). Examples of attributes are ‘(name : Str)’, ‘(age : Natno)’."
    }, {
      "heading" : "3.3 Relations.",
      "text" : "Here we discuss how the relational aspect of the ERA data model is handled in FOLE. Some relations are special. One example is subtyping, which specifies that one category of existence is more general than another. This arises when representing the taxonomic aspect of ontologies. Subtyping is handled by the binary sequents 5 in FOLE specifications (discussed further in the (Kent [9])). Some many-to-one relationships can be represented as attributes. But in general, many-to-many relationships are represented in FOLE as entities, whose attributes, each of which plays a thematic role for the relationship, may be other entities. 6\nConsider the example (Fig. 2) of a simple entity-relationship-attribute diagram. Here we have three entities (represented by rectangles), two relationships (represented by diamonds) and numerous attributes (represented by ovals). The works on relationship is many-to-many, and so we can represent this in FOLE as an entity type Activity with four attributes: entry date of sort Date, job descr of sort String, employee of sort Employee, and project of sort Project. Note that attributes employee and project are foreign keys of the Activity entity. 7 Since the works for relationship is many-to-one without any attributes of its own, we can represent this as an attribute called dept of sort Department. This is a foreign key of the Employee entity.\n5 A sequent ϕ ⊢ ψ expresses interpretation widening between formulas. 6 As an example, the “marriage” binary relation can be represented as a Marriage entity with wife and husband attributes that are themselves Person entities. 7 The Employee type, which plays the employee thematic role for the works on relationship, is both an entity type and an attribute type (sort); any value in the Employee data domain is a key of the Employee entity and a foreign key of the Activity entity.\n4 FOLE Components"
    }, {
      "heading" : "4.1 Schema.",
      "text" : "The type aspect of the ERA data model is gathered together into a schema. A schema S = 〈R, σ,X〉 consists of a set of sorts (attribute types) X , a set of entity types R and a signature map R σ −→ List(X). Within the schema S, we think of each r ∈ R as being an entity type that is locally described by the associated X-signature σ(r) = 〈I, s〉 ∈ List(X). 8 A more visual representation for this signature mapping is r σ 7−→ (· · · si · · · | i∈ I). An ERA-style visualization might be r i\n−−→ ✞ ✝ ☎ ✆\nsi , where the box encloses the entity type r∈R, the oval encloses the attribute type si ∈X , and the arrow is labeled with the index i∈ I. For example, Person name −−−→\n✞ ✝ ☎ ✆String or Employee dept −−−→ ✞ ✝ ☎ ✆Department .\nThe entity type r in the ERA data model corresponds to the relation symbol r in FOLE/MSFOL. Either representation is a kind of nexus. A schema corresponds to a multi-sorted first-order logical language in the FOLE/MSFOL approach to knowledge representation. 9 In the database interpretation of FOLE (Kent [10]), we think of r as being a relation name with associated header σ(r) = 〈I, s〉.\nWe formally link schemas with morphisms. A schema morphism S2 = 〈R2, σ2, X2〉 〈r,f〉 =⇒ 〈R1, σ1, X1〉 = S1 from schema S2 to schema S1 consists of an sort function f : X2 → X1 and an entity type function r : R2 → R1, which preserve signatures by satisfying the condition r · σ1 = σ2 · ∑ f .\nr2 ∈ R2\n〈I, s〉 = (· · · si · · · | i∈ I) si ∈X2\nr(r2) ∈ R1\n(· · · f(si) · · · | i∈ I) = ∑\nf (I, s)\nf(si)∈X1\n− ↓σ2\n− ↓ σ1\nr 7−−→\n∑\nf 7−−→\nS2\n   \n  \n   \n  \nS2\nLet Sch denote the mathematical context of schemas and their morphisms.\n8 There is an associated arity function R α\n−−−−→ σ ◦ set\nSet : r σ 7−→ 〈I, s〉 set 7−−→ I .\n9 Formulas based on relation symbols can be inductively defined, thus forming extended schemas (Kent [9]). Terms composed of function symbols can be added as constraints between formulas."
    }, {
      "heading" : "4.2 Universe.",
      "text" : "The instance aspect of the ERA data model is gathered together into a universe. A universe U = 〈K, τ, Y 〉 consists of a set of values (attribute instances) Y , a set of keys (entity instances) K and a tuple map K τ −→ List(Y ). Within the universe U , we think of each key k ∈ K as being an identifier or name for an object that is locally described by the associated tuple of values τ(k) = 〈J, t〉 ∈ List(Y ). A more visual representation for this tuple mapping is k τ 7−→ (· · · tj · · · | j ∈J). Note that, no typing has been mentioned here and no typing restrictions are required. In a universe by itself, we do not require the data values tj to be members of any special data-types.\nAn element of a universe U = 〈K, τ, Y 〉 ∈ Univ is a key ( k τ 7−→ 〈J, t〉 ) with associated list. We can think of such universe elements as object descriptions without attached typing or as tuples untethered from a database table. They develop meaning by being classified by schema elements ( r σ 7−→ 〈I, s〉 ) in a structure (§ 4.3). 10 Hence, a FOLE universe is like the key−value·list store at the heart of Google’s Spanner database (Google [5]):\n“Spanner’s data model is not purely relational, in that rows must have names. More precisely, every table is required to have an ordered set of one or more primary-key columns. This requirement is where Spanner still looks like a keyvalue store: the primary keys form the name for a row, and each table defines a mapping from the primary-key columns to the non-primary-key columns.” 11\nWe semantically link universes with morphisms. A universe morphism U2 = 〈K2, τ2, Y2〉 〈k,g〉 ⇐=== 〈K1, τ1, Y1〉 = U1 consists of a value (attribute instance) function Y2 g ←− Y1 and a key (entity instance) function K2 k ←− K1, which preserve tuples (instance lists) by satisfying the condition k · τ2 = τ1 · ∑ g.\nk(k1) ∈ K2\n∑\ng (J, t) = (· · · g(tj) · · · | j ∈ J)\ng(tj)∈Y2\nk1 ∈ K1\n(· · · tj · · · | j ∈ J) = 〈J, t〉 tj ∈Y1\n− ↓τ2\n− ↓ τ1\nk ←− [\n∑\ng\n←− [\nU2\n  \n  \n  \n  \nU1\nLet Univ denote the mathematical context of universes and their morphisms.\n10 They are somewhat like genes (bits of DNA) without the genomic structure that provides interpretation. 11 When the universe U is the instance aspect of a FOLE structureM with typed domain A, in the database interpretation of that structure (§ 4.4 and Kent [10]), we think of the entity instance k as being a primary key that indexes a row τ (k) = 〈I, t〉 in the table associated with the relation symbol r ∈ R with associated header σ(r) = 〈I, s〉. A more visual representation for this tuple mapping is k\nτ 7−→ (· · · ti · · · | i∈ I, ti ∈Asi),\nwhere Asi is the data-type for sort si ∈X. Here, we do require the data values ti to be members of the special data-types Asi ."
    }, {
      "heading" : "4.3 Structure.",
      "text" : "The complete ERA data model is incorporated into the notion of a (modeltheoretic) structure in the FOLE representation of knowledge.\nStructures. A FOLE structure M = 〈E , σ, τ,A〉 is a hypergraph of classifications (Fig. 3) — a two-dimensional construct with the following components:\nattribute classification: typed domain A = attr(M) = 〈X,Y, |=A〉 entity classification: E = ent(M) = 〈R,K, |=E〉\ntype hypergraph: schema S = sch(M) = 〈R, σ,X〉 instance hypergraph: universe U = univ(M) = 〈K, τ, Y 〉\nand a list designation 〈σ, τ 〉 : E ⇒ List(A) with signature map R σ −→ List(X) and tuple map K τ −→ List(Y ), whose defining condition states that: if entity k ∈K is of type r∈R, then the description tuple τ(k) = 〈J, t〉 is the same “size” (J = I) as the signature σ(r) = 〈I, s〉 and each data value tn is of sort sn; or interpretively (§ 4.4 and Kent [10]), in a database table all rows are classified by the table header. A FOLE structure embodies the idea of an ERA data model\n(compare Fig. 3 with Fig. 1). Each community of discourse that incorporates the ERA data model will have its own local FOLE structure. 12\nThe entity and attribute-list classifications E and List(A) are equivalent 13\nto their extent diagrams R extE−−−→ Set and List(X) extList(A) −−−−−−→\ntupA Set, and the list\ndesignation is equivalent to its extent diagram morphism ext〈σ,τ〉 = 〈σ, τx〉 : 〈R, extE〉 → 〈List(X), extList(A)〉 consisting of the signature map R σ −→ List(X)\n12 In anticipation of the discussion in § 4.4, we illustrate the associated tabular interpretation (3) on the right side of Fig. 3. 13 Any classification A = 〈X,Y, |=A〉 is equivalent to its extent map X extA−−−→ ℘Y .\nand the bridge extE τx=⇒ σ ◦ extList(A), whose r th-component is the tuple function K(r) = extE(r) τr−→ extList(A)(σ(r)) = tupA(σ(r)) (see the tabular interpretation (3) in § 4.4). Hence, any structure M has the interpretive presentation in Fig. 4 (see the discussion on linearization § 5.2).\nIn the concept of a FOLE structure we have abstracted the (primary) keys from the tuples that they described. The key-embedding construction replaces keys into their tuples.\nDefinition 1. (key embedding) Any FOLE structure M = 〈E , σ, τ,A〉 with signature map R σ −→ List(X) : r 7→ 〈I, s〉 and tuple map K τ −→ List(Y ) : k 7→ 〈I, t〉 has a companion key embedding structure Ṁ = 〈E , σ̇, τ̇ , E+A〉 consisting of entity classification E, parallel sum typed domain E+A = 〈R+X,K+Y, |=E+A〉, 14 schema 〈R, σ̇, R+X〉 with signature map R σ̇ −→ List(R+X) : r 7→ 〈1, r〉+〈I, s〉, and universe 〈K, τ̇ ,K+Y 〉 with tuple map K τ̇ −→ List(K+ Y ) : k 7→ 〈1, k〉+〈I, t〉. The signature and tuple maps are injective.\n14 We can think of the entity classification E = 〈R,K, |=E〉 as a type domain. For each sort (attribute type) r ∈ R, the data domain of that type is the E-extent\nEr = extE(r) = {k ∈ K | k |=E r}. The passage R extE−−−→ ℘K maps a sort r∈R to its data domain (E-extent) Er ⊆ K.\nStructure Morphisms. In order to allow communities of discourse to interoperate, we define the notion of a morphism between two structures that respects the ERA data model. A structure morphism M2 〈r,k,f,g〉 −−−−−⇀↽ − M1 (Fig. 5) from source\nstructure M2 = 〈E2, 〈σ2, τ2〉,A2〉 to target structure M1 = 〈E1, 〈σ1, τ1〉,A1〉 is defined in terms of the hypergraph and classification morphisms between the source and target structure components (projections):\ntyped domain morphism A2 = attr(M2) 〈f,g〉 −−−⇀↽ − attr(M1) = A1\nentity infomorphism E2 = ent(M2) 〈r,k〉 −−−⇀↽ − ent(M1) = E1\nschema morphism S2 = sch(M2) 〈r,f〉 ===⇒ sch(M1) = S1 universe morphism U2 = univ(M2) 〈k,g〉 ⇐=== univ(M1) = U1\nsatisfying the conditions\ntyped domain morphism g(y1) |=A2 x2 iff y1 |=A1 f(x2)\nentity infomorphism k(k1) |=E2 r2 iff k1 |=E1 r(r2) .\nschema morphism r · σ1 = σ2 · ∑\nf\nuniverse morphism k · τ2 = τ1 · ∑\ng\nR2 R1\nK2 K1\nr\nk\n|=E2 |=E1\n✲\n✛ List(X2) List(X1)\nList(Y2) List(Y1)\n∑\nf\n∑\ng\n|=List(A2) |=List(A1)\n✲\n✛\nσ2 σ1\nτ2 τ1\n❆ ❆❯\n❆ ❆❯\n❆ ❆❆❯\n❆ ❆❆❯\nschema morphism\nsch(M2) 〈r,f〉\n====⇒ sch(M1) ︷ ︸︸ ︷\nE2 〈r,k〉 −−−⇀↽ − E1\nentity infomorphism\n    \n   \n    \n   \nList ( A2 〈f,g〉 −−−−⇀↽ − A1 )\ntyped domain morphism\n︸ ︷︷ ︸ univ(M2) 〈k,g〉\n⇐==== univ(M1) universe morphism\nFig. 5. Structure Morphism\nThe designation defining condition states that for any k1 ∈K1 and r2 ∈R2,\n( k(k1) |=E2 r2 iff k1 |=E1 r(r2) )\nimplies (\nτ2(k(k1)) = ∑ g(τ1(k1)) |=List(A2) σ2(r2) iff τ1(k1) |=List(A1) ∑ f (σ2(r2)) = σ1(r(r2)) ) .\nStructure morphisms compose component-wise. Let Struc denote the context of structures and structure morphisms. In the appendix § A, we develop Struc as a fibered mathematical context in two orientations: either as the Grothedieck construction of the schema indexed mathematical context of structures Schop struc −−−→ Cxt or as the Grothedieck construction of the universe indexed mathematical context of structures Univop struc −−−→ Cxt. The schema indexed mathematical context of structures is used in Kent [10] to establish the institutional aspect of FOLE.\nAny structure morphismM2 〈r,k,f,1Y 〉 −−−−−−⇀↽ − M1 with identity value map Y 1Y−−→ Y\nhas the interpretive presentation in Fig. 6. 15\n15 Any infomorphism A2 〈f,g〉 −−−⇀↽ − A1 has the equivalent condition f · extA1 = extA2 · g −1.\nDefinition 2. (key embedding) Any structure morphism M2 〈r,k,f,g〉 −−−−−⇀↽ − M1 has\na companion key embedding structure morphism\nṀ2 = 〈E2, σ̇2, τ̇2, E2+A2〉 〈r,k,f,f+g〉 −−−−−−−⇀↽ − 〈E1, σ̇1, τ̇1, E1+A1〉 = Ṁ1.\nwith the following components:\ntyped domain morphism E2+A2 〈r+f,k+g〉 −−−−−−−⇀↽ − E1+A1\nentity infomorphism E2 〈r,k〉 −−−⇀↽ − E1\nschema morphism Ṡ2 = 〈R2, σ̇2, R2+X2〉 〈r,r+f〉 ====⇒ 〈R1, σ̇1, R1+X1〉 = S1 universe morphism U2 = 〈K2, τ̇2,K2+Y2〉 〈k,k+g〉 ⇐===== 〈K1, τ̇1,K1+Y1〉 = U1\nProof. The following conditions must hold.\ntyped domain morphism k(k1) g(y1) |=E2+A2 r2 x2 iff k1 y1 |=E1+A1 r(r1) f(x2) )\nentity infomorphism k(k1) |=E2 r2 iff k1 |=E1 r(r2) .\nschema morphism r · σ̇1 = σ̇2 · ∑\nr+f\nuniverse morphism k · τ̇2 = τ̇1 · ∑\nk+g\nWe use the comparable conditions for the original structure morphismM2 〈r,k,f,g〉 −−−−−⇀↽ −\nM1. The entity infomorphism condition is given. The type domain morphism condition is straightforward. We show the schema morphism condition. The universe morphism condition is similar. The schema morphism condition for the original structure morphism is r · σ1 = σ2 · ∑\nf ; that is, for any r2 ∈R2, if σ2(r2) = 〈I2, s2〉 and σ1(r(r2)) = 〈I1, s1〉, then 〈I1, s1〉 = ∑\nf (I2, s2). Hence, the schema morphism condition for the key-embedding structure morphism holds, since σ̇1(r(r2)) = 〈1, r(r2)〉+〈I1, s1〉 = ∑ r(1, r2)+ ∑ f (I2, s2)\n= ∑\nr+f\n( 〈1, r2〉+〈I2, s2〉 ) = ∑ r+f (σ̇2(r2))\nIntegrity Constraints. Integrity constraints help preserve the validity and consistency of data. Here we briefly explain how various integrity constraints are represented in the ERA data model of FOLE.\nEntity: (primary key rule) Entity integrity states that every table must have a primary key and that the column or columns chosen to be the primary key should be unique and not null. In the ERA data model of FOLE, entity integrity asserts that the universe U = 〈K, τ, Y 〉 of a structure M is well-defined. Domain: Domain integrity specifies that all columns in a relational database must be declared upon a defined domain. In the ERA data model of FOLE, domain integrity asserts that the schema S = 〈R, σ,X〉 and the list designation 〈σ, τ 〉 : E ⇒ List(A) of a structure M are well-defined. Referential: (foreign key rule) Referential integrity states that the foreign-key value of a source table refers to a primary key value of a target table. In the ERA data model of FOLE, referential integrity asserts that the ERA data model of FOLE is a mixed data model.\nAlgebra. For simplicity of presentation, this paper and the paper on FOLE superstructure (Kent [9]) use a simplified form of FOLE, in contrast to the full form presented in Kent [8]. In this paper and Kent [9], schemas are used in place of (many-sorted) first-order logical languages. Schemas are simplified logical languages without function symbols. The main practical result is that signature morphisms 〈I ′, s′〉 h −→ 〈I, s〉 are replaced by term vectors 〈I ′, s′〉 t −⇁ 〈I, s〉 in the full version of FOLE. Signature morphisms are simplified term vectors without function symbols. In the full version of FOLE, equations can be defined between parallel pairs of term vectors 〈I ′, s′〉 t,t′\n−−⇁ 〈I, s〉, thus allowing the use of equational presentations and their congruences. 16 Also in the full version of FOLE, the tuple map along signature morphisms becomes the algebraic operation along term vectors; hence, formula flow (substitution/quantification) in Kent [9] is lifted from being along signature morphisms to being along term vectors. 17\n16 The tuple relational calculus is a query language for relational databases. In order to use the tuple calculus in the FOLE, we need to enrich with many-sorted constant declarations and equational presentations. Constant declarations are first-order logical languages with sorted nullary function symbols. A constant c of sort x is an x-sorted nullary function symbol x c −⇁ 〈∅, 0X〉. 17 Let FOLE-ARCH denote Fig. 1. in Kent [8]. FOLE-ARCH is the 3-dimensional visualization of the fibered architecture of FOLE. The upper right quadrant of Fig. 7 corresponds to the the 2-D prism below Rel in FOLE-ARCH. As indicated in FOLE-ARCH, to move from the simple version of the FOLE foundation used here (Fig. 7) to the full version in FOLE-ARCH, we lift from sort sets to algebraic languages and from typed domains to many-sorted algebras."
    }, {
      "heading" : "4.4 Interpretation.",
      "text" : "In the model theory for traditional many-sorted first-order logic, a (possible world, model) structure corresponds to an interpretation of relation symbols (entity types) in terms of relations in a typed domain. The FOLE approach to logic replaces n-tuples with lists, defines quantification/substitution along signature morphisms (Kent [9]) (or term vectors in the full version [8]), and following databases, incorporates identifiers (keys) for data value lists (tuples) (here and in Kent [10]). The FOLE approach modifies the idea of model-theoretic interpretation as follows. 18\nWe assume that the traditional many-sorted first-order logic language is represented by the schema S = 〈R, σ,X〉 and that the typed domain is represented by the attribute classification A = 〈X,Y, |=A〉. We further assume that these are components of a structure M = 〈E , 〈σ, τ 〉,A〉.\nTraditional: In the traditional approach, an entity type r ∈ R is interpreted as the set of descriptors of entities in the extent of r. For X-signature σ(r) = 〈I, s〉 ∈ List(X), this is the subset of Y -tuples IM(r) = ℘τ(extE(r)) ∈ ℘tupA(I, s) = ℘extList(A)(I, s), an element of the fiber relational order 〈RelA(I, s),⊆〉. 19 This defines the traditional interpretation function\nR IM−−−→ Rel(A) . (1)\nFor all r ∈ R, we have the relationships\n℘τ(extE(r)) = IM(r) extE(r) ⊆ τ−1(IM(r)) . (2)\nDefinition 3. The inequality extE(r) ⊆ τ −1(IM(r)) says that extE(r) is not the morphic closure of itself w.r.t. the tuple map K τ −→ List(Y ). A structure M is called extensive when the right hand expression in (2) is an equality: extE(r) = τ −1(IM(r)) for any entity type r ∈ R. 20\nAny structure M with an injective tuple map K τ −→ List(Y ) has an associated extensive structure. An example is the key-embedding structure Ṁ.\n18 Hence, the notions of (1) a many-sorted first-order logic interpretation, (2) a FOLE structure, and (3) an ERA data model are all equivalent; and each can be implemented as a relational database with associated logic (for more on this, see Kent [10]). 19 The fibered context Rel(A) is defined in the paper on FOLE interpretation (Kent [10]). An object of Rel(A), called an A-relation, is a pair 〈I, s, R〉 consisting of an indexing X-signature 〈I, s〉 and a subset of A-tuples R ∈ ℘tupA(I, s) = ℘extList(A)(I, s). 20 Philosophical note: In the knowledge resources for a community, the entities are of first importance. The tuples in List(Y ) are descriptors, which may or may not have an identity. An entity consists of an identifier k ∈ K and its descriptor τ (k) ∈ ℘τ (K). Tuples with identity are those in ℘τ (K) ⊆ List(Y ). Two entities that have the same descriptor are said to be “descriptor-equivalent”.\nTabular: In the database approach, an entity type r ∈ R is interpreted as a table with the entities (both the keys and their descriptors) being explicit. For X-signature σ(r) = 〈I, s〉 ∈ List(X), this is the 〈I, s〉-indexed A-table\nK(r) τr−−→ tupA(I, s)\nτr(k) = 〈I, t〉, I t −→ Y\nr\n〈I, s〉 ︷ ︸︸ ︷\nK(r)\n  \n \n· · · i :si · · ·\nk · · · ti · · ·\nTM(r) = 〈K(r), τr〉 (visualized above) consisting of the key set K(r) = extE(r) ∈ ℘K and the (descriptor) tuple function K(r) τr−→ tupA(I, s), a restriction of the tuple function K τ −→ List(Y ) for the universe U = 〈K, τ, Y 〉. The tuple function factors through the traditional interpretation τr : K(r) → IM(r) →֒ tupA(I, s). This defines the tabular interpretation function\nR TM−−−→ Tbl(A) . 21 (3)\nThe companion key-embedding structure Ṁ (Def. 1) is most easily understood from its interpretation tables (visualized below).\nK(r) τ̇r−−→ tupE+A(1+I, r+s)\nτ̇r(k) = 〈1+ I, k+t〉, 1 k −→ K, I t −→ Y\n〈1+I, r+s〉 ︷ ︸︸ ︷\nK(r)\n  \n \nr\nk\n· :r · · · i :si · · ·\nk · · · ti · · ·\n21 The fibered context Tbl(A) is defined in the paper on FOLE interpretation (Kent [10]). An object of Tbl(A), which is called an A-table, is a triple 〈I, s,K, t〉 consisting of an X-signature 〈I, s〉, a set of entities (keys) K, and a tuple function\nK t −→ tupA(I, s) mapping each entity in K to its descriptor A-tuple."
    }, {
      "heading" : "5 Connections",
      "text" : ""
    }, {
      "heading" : "5.1 Analogy.",
      "text" : "In the original paper (Kent [8]) explaining the first-order logical environment FOLE, there was an analogy between the top-level ontological categories discussed in (Sowa [11]) and the components of the first-order logical environment FOLE. We recast that here in terms of the FOLE approach to the ERA data model. The analogy between the Sowa hierarchy and FOLE is illustrated graphically in Fig. 8. The twelve categories displayed in the hierarchy (we do not concern ourselves here with the temporal dimension given by the continuent-occurent distinction) and the primitives from which they are generated are arranged in the matrix of Tbl. 2 with the corresponding FOLE terminology in parentheses.\nThe physical-abstract distinction, which corresponds to the Heraclitus distinction physis-logos, is represented by the FOLE classification dimension, a connection between FOLE schemas and FOLE universes. The abstract category corresponds to FOLE types, either entities or attributes. The physical category corresponds to FOLE instances, either entities or attributes. The independent-relativemediating triad is represented by the FOLE hypergraph dimension, a connection between FOLE entities and FOLE attributes. The independent category (firstness) corresponds to FOLE entities that are not attributes. The relative category (secondness) corresponds to FOLE attributes that are not entities. The mediating category (thirdness) corresponds to FOLE list maps between entities and attributes. The triads actuality-prehension-nexus and form-proposition-intention correspond to Whitehead’s categories of existence.\nHere we explain this in more detail. As discussed in § 4.3, a FOLE structure is a two-dimensional combination of a classification and a hypergraph. The entire hierarchy of the top-level ontological categories is represented by\na FOLE (model-theoretic) structure M = 〈E , 〈σ, τ 〉,A〉. This is appropriate, since a (model-theoretic) structure represents the knowledge in the local world of a community of discourse. The form-proposition-intention triad is represented by a FOLE schema S = 〈R, σ,X〉 with signature function R σ −→ List(X). The actualityprehension-nexus triad is represented by a FOLE universe U = 〈K, τ, Y 〉with tuple function K τ −→ List(Y ). The firstness subgraph of independent(actuality,form) is represented by a FOLE entity classification E = 〈R,K, |=E〉 between entity instances (keys) and entity types (or a classification between keys and logical formula, more generally; see Kent [9]). The secondness subgraph of relative(prehension,proposition) is represented by a FOLE attribute classification A = 〈X,Y, |=A〉 between attribute instances (data values) and attribute types (sorts). The thirdness subgraph of mediating(nexus,intention) is represented by a FOLE list designation 〈σ, τ 〉 : E ⇒ List(A). A FOLE entity type loosely corresponds to a form = independent∧ abstract. A FOLE entity (key) loosely corresponds to an actuality = independent∧ physical. A FOLE sort (attribute type), which is not necessariy linked from a FOLE entity, loosely corresponds to a proposition = relative∧ abstract. A FOLE data value (attribute instance) loosely corresponds to a prehension = relative∧ physical."
    }, {
      "heading" : "5.2 Linearization.",
      "text" : "The “ontology log” Olog formalism (Spivak and Kent [12]) is a category-theoretic model for knowledge representation. As we indicate below, there is a sense in which the FOLE representation subsumes the Olog representation (and viceversa). 22 Let M be a FOLE structure with schema S = 〈R, σ,X〉, universe U = 〈K, τ, Y 〉, type domain A = 〈X,Y, |=A〉, entity classification E = 〈R,K, |=E〉, and list designation 〈σ, τ 〉 : E ⇒ List(A).\n22 This section is closely related to the discussion of the sketch and interpretation associated with a unified relational database in § 4 of Kent [7]. FOLE structures are adjointly related to relational databases, as shown in the paper on FOLE interpretation (Kent [10]).\nBy using the extent operator (§ 4.3), the following classifications and sets are informationally equivalent.\nclassification set E ∐\nextE = {(r, k) | r ∈ R, k ∈ K, k |=E r}\nA ∐\nextA = {(x, y) | x ∈ X, y ∈ Y, y |=A x}\nList(A) ∐\nextList(A) = {(I, s, t) | (I, s) ∈ List(X), (I, t) ∈ List(Y ), (I, t) |=List(A) (I, s)}\nThe designation property defines a function ∐\nextE\n∐ ext〈σ,τ〉\n−−−−−−→ ∐\nextList(A), which is the sum of the extent diagrammorphism ext〈σ,τ〉 = 〈σ, τx〉 : 〈R, extE〉 → 〈List(X), extList(A)〉 (Fig. 4 of § 4.3). By flattening the resulting lists, for each (r, k)∈ ∐ extE , we know that (si, ti)∈ ∐ extA for each index i ∈ α(r) = I in the common arity. Hence, the following linearization set 23 is equivalent in information to the structure M:\nlin(M) = {\n〈(r, k) ︸ ︷︷ ︸ ent , i, (si, ti) ︸ ︷︷ ︸ attr\n〉 | (r, k)∈ ∐ extE , σ(r) = 〈I, s〉, τ (k) = 〈I, t〉, i∈ I } .\nThe FOLE representation is binary, since it has two kinds of type, sorts (attribute types) and entity types. The Olog representation is unary, since it has only one kind of type, the abstract concept. 24 However, the FOLE representation can be transformed to the Olog representation by the process of linearization. If we restrict FOLE to the unified model, identifying entities with attributes E = A, by separating the type/instance information in the linearization set lin(M) via the extent operator along the classification dimension (Fig. 1), we get the basis for the Olog data model, consisting of three notions: types, aspects, and facts. Types, which represent things, are depicted by nodes in Olog; aspects, which represent functional relationships between things, are depicted by edges in Olog; and facts, which represent assertions, are depicted by path equations in Olog.\nOlog types and aspects are covered by the linearization process discussed here. Olog facts correspond to the formalism discussed (indirectly) in the FOLE superstructure (Kent [9]) and (more directly) in the full form of FOLE (Kent [8]).\nr typ\n(r,i) −−−→ si\ntyp\n}\nS a schema context\n❄ ext\n❄ M an interpretation passage\nM (r) ext(r) M (i) −−−−−−−−→ τr · tup(πi) M (si) ext(si)\n}\nSet the context of sets\nk 7−−→ ti\n23 The linearization set lin(M) loosely corresponds to the following: (1) the table used in the entity-attribute-value (EAV) data model, where data is recorded in three columns: the entity component is a foreign key into an object information table, the attribute component is a foreign key into an attribute definition table, and the value component is the value of the attribute; and (2) the labelled directed graph used in the resource description framework (RDF) data model, where each subject-predicateobject triple is regarded as an edge in the graph. 24 See § 4.4 of [12] for further discussion of binary/unary knowledge representations.\nOlog Database Schema S: By projecting the type components out of the linearization set lin(M), define a graph G whose node set is R = X and whose edge set is ∐\nr∈R=X α(r). Picture the graph G as follows:\nG = { r (r,i) −−−→ si ∣ ∣ ∣ σ(r) = 〈I, s〉, i∈ I, with r, si ∈ R = X } .\nThe schema mathematical context S = G∗ is the path context of graph G. The graph G corresponds to a many-sorted unary algebraic language O = 〈X,Ω〉, where Ω is essentially the opposite of G: the collection of sets of function (operator) symbols Ω = {Ωsi,〈1,r〉 | sort si ∈ X, unary signature 〈1, r〉 ∈ List(X)} with each (r, i) ∈ Ωsi,〈1,r〉 being an si-sorted r = 〈1, r〉-ary function symbol si (r,i) −−−⇁ r = 〈1, r〉. 25 The opposite of the schema context is a subcontext (no cotupling) of the term context TermO inc ←−−֓ Sop. An Olog fact corresponds to a linear O-equation (t= t̂) : 〈1, s〉⇁ 〈1, s′〉.\nOlog Database Instance M : Using extent, define a passage S = G∗ M −→ Set\nwhich maps a node r in S to the extent M (r) = K(r) = ext(r) and maps an edge r (r,i) −−−→ si in S to the function M (r)\nM (r,i) −−−−−−−→ τr · tup(πi) M (si). 26 The\nfunctional language O = 〈X,Ω〉 mentioned above has an O-algebra 〈A, δ〉 consisting of the X-sorted collection of extents {Ax = ext(x) ⊆ Y | x ∈ X},\nwhere δ assigns the 〈1, r〉-ary si-sorted function M (r) = Ar = A 〈1,r〉 δ(r,i) −−−−→ M (r,i) Asi = M (si) to each function symbol si (r,i) −−−⇁ r = 〈1, r〉. 27 The interpretation passage TermopO A −→ Set inductively define by this O-algebra contains the database instance as a subfunctorM = incop◦ A. Any equation satisfied by the Olog database interpretation M is also satisfied by the interpretation passage A. 28\n25 Define 〈X,Ω〉-term 〈I, s〉 r −⇁ 〈1, r〉 = r as the cotupling of {si (r,i) −−−⇁ r = 〈1, r〉 | i∈ I},\nso that si (r,i) −−−⇁ r = 〈1, r〉 is the composite si πi−⇁ 〈I, s〉 r −⇁ 〈1, r〉 = r.\n26 A projection M (r) = ext(r) τr−→ tup(I, s) tup(πi)−−−−→ tup(1, si) = ext(si) = M (si) of the tabular interpretation in § 4.4. 27 δ assigns the table M (r) = ext(r) δr−→ τr tup(I, s) = ∏ i∈ I Asi = ∏ i∈ I M (si) (a\ntupling) to the cotupling 〈I, s〉 r −⇁ r.\n28 The interpretation passage satisfies an O-equation (t= t̂) : 〈I, s〉⇁ 〈I ′, s′〉 when the operations coincide A(t) = A(t̂) : A(I, s) ← A(I ′, s′) in Set (see Kent [8])."
    }, {
      "heading" : "6 Conclusion",
      "text" : "The ERA data model describes the conceptual model for a community of discourse, which can be used as the foundation for designing relational databases. The first-order logical environment FOLE provides a rigorous and principled approach to distributed inter-operable first-order information systems, which integrates ontologies and databases into a unified framework. In this paper, we have discussed in detail the representation of elements of the ERA data model with components of the FOLE logical environment, described interpretation basics, and illustrated the connections between FOLE and other data models in knowledge representation. In the near future, we will complete the presentation of the FOLE logical environment by discussing the formalism and semantics of many-sorted logic in the paper Kent [9] and database interpretation in the paper Kent [10]. After this, two papers are pending on the integration of federated systems of knowledge, either over a fixed type domain or over a fixed universe."
    }, {
      "heading" : "A The Fibered Context of Structures.",
      "text" : "In order to allow communities of discourse to interoperate, we define the notion of a morphism between two structures that respects the ERA data model. This describes the mathematical context of structures Struc as a fibered mathematical context in two orientations: the Grothedieck construction of the schema indexed mathematical context Schop strucf −−−−−→Cxt or the Grothedieck construction of the universe indexed mathematical context Univop strucg\n−−−−−→Cxt. The schema indexed mathematical context of structures is used in the paper [9] on FOLE superstructure to establish the institutional aspect of the FOLE. Each orientation is developed in three steps: the structure fiber context for a single indexing object, the structure fiber passage along an indexing morphism, the fibered mathematical context Struc of structures and structure morphisms as the Grothedieck construction for this orientation. This dual development of the mathematical context of structures Struc (Prop. 2) is based upon and mirrors a dual development of the mathematical context of classifications Cls (Prop. 1).\nA.1 An Exemplar.\nThe mathematical context of classifications Cls is a fibered mathematical context in two orientations: the Grothedieck construction of the type set indexed mathematical context Setop clsf −−−→Cxt or the Grothedieck construction of the instance set indexed mathematical context Setop clsg −−−→Cxt.\nProposition 1. Any infomorphism C2 = 〈X2, Y2, |=2〉 〈f,g〉 −−−⇀↽ − 〈X1, Y1, |=1〉 = C1\nin the mathematical context of classifications Cls, with type function projection X2 f −→ X1 and instance function projection Y2 g ←− Y1, has dual factorizations\nCls(X2) ︷ ︸︸ ︷\n︸ ︷︷ ︸\nCls(Y1)\nC2 cls f f (C1) = 〈X2, Y1, |=f 〉\nC1〈X2, Y1, |=g〉 = cls g g (C2)\ng 〈1X2 , g〉\nf\n〈f, 1Y1 〉\ng\n〈1X2 , g〉\nf 〈f, 1Y1 〉\n−−−⇀↽ −\n−−−⇀↽ −\n↿⇂↿⇂\nwhere clsff (C1) = f −1(C1) = 〈X2, Y1, |=f 〉 = 〈X2, Y1, |=g〉 = g −1(C2) = cls g g (C2).\nProof. y1 |=g x2 iff g(y1) |=C2 x2 iff y1 |=C1 f(x2) iff y1 |=f x2.\nThe top-right factorization consists of a Cls(X2)-morphism C2 g\n−−−−−⇀↽ − 〈1X2 ,g〉 clsff (C1)\nand the Cth1 component cls f f (C1) f\n−−−−⇀↽ − 〈f,1Y1〉 C1 of a bridge cls f\nf ◦ incX2 χ̀f ==⇒\nincX1 . This factors through theX2-classification cls f f (C1), which is the fiber passage image along the type function X2 f −→ X1 of the the X1-classification C1. The left-bottom factorization consists of the Cth2 component C2 g\n−−−−−⇀↽ − 〈1X2 ,g〉 clsgg (C2) of\na bridge clsgg ◦ incY1 χ́g ⇐== incY2 and a Cls(Y1)-morphism cls g g (C2) f\n−−−−⇀↽ − 〈f,1Y1 〉 C1.\nThis factors through the Y1-classification cls g g (C2), which is the fiber passage image along the instance function Y2 g ←− Y1 of the the Y2-classification C2.\nA.2 Schema Orientation.\nThe fibered mathematical context Struc of structures and structure morphisms can be developed as the Grothedieck construction of a schema indexed mathematical context. This approach using schema indexing corresponds to the use of type-set indexing in § A.1, and was the approach used in the paper (Kent [8]).\n1. For a fixed schema S, we define the structure fiber context Struc(S). 2. For a schema morphism S2 〈r,f〉 ===⇒ S1, we define the structure fiber passage\nStruc(S2) strucf〈r,f〉 ←−−−−−− Struc(S1).\n3. We define the fibered mathematical context Struc of structures and structure morphisms to be the Grothedieck construction of the schema indexed\nmathematical context Schop strucf −−−−→ Cxt.\nFixed Schema. Let S = 〈R, σ,X〉 ∈ Sch be a fixed schema. We define the notion of a morphism between two (fixed schema) S-structures that respects the ERA data model. In these morphisms, the schema remains fixed, but the attribute and entity instances (data values and keys) are formally linked by maps that respect universe tuple, typed domain extent and entity interpretation. An S-structure morphism M2 〈k,g〉 −−−⇀↽ − M1 over a fixed schema S = 〈R, σ,X〉 is a universe mor-\nphism univ(M2) 〈k,g〉 ⇐=== univ(M1), where attr(M2) 〈1X ,g〉 −−−−⇀↽ − attr(M1) is an\ninfomorphism in Cls(X) over the sort set X , and ent(M2) 〈1R,k〉 −−−−⇀↽ − ent(M1) is an infomorphism in Cls(R) over the entity type set R. 29 S-structure morphisms compose component-wise. Let Struc(S) denote the fiber context of structures over the fixed schema S.\nStructure Fiber Passage. We define the indexed context Schop strucf\n−−−−→ Cxt. Given a schema S, there is a fiber context of structures Struc(S) with that schema. Given a schema morphism S2 〈r,f〉 ===⇒ S1, there is a fiber passage of structures Struc(S2) strucf〈r,f〉 ←−−−−−− Struc(S1): a structure M1 = 〈E1, 〈σ1, τ1〉,A1〉 ∈ Struc(S1) is mapped to a structureM2 = struc f 〈r,f〉(M1) = 〈r −1(E1), 〈σ2, τ1〉, f −1(A1)〉 ∈ Struc(S2). M2 is called the reduct of M1 and M1 is called the expansion of\nM2. The two are linked struc f 〈r,f〉(M1) χ̀M1−−−⇀↽ − 〈r,f〉 M1 by a structure morphism,\nwhich is the Mth1 component of a bridge struc f 〈r,f〉 ◦ incS2 χ̀〈r,f〉 ====⇒ incS1 .\n29 Hence, the target type domain is the inverse image of the source type domain attr(M1) = g −1(attr(M2)) = cls g\ng (attr(M2)) and the target entity classification is the inverse image of the source entity classification ent(M1) = k−1(ent(M2)) = cls g\nk (ent(M2)). By combining entity/attribute inverse image classifications, the target structure M1 is the inverse image struc g 〈k,g〉(M2) = 〈k−1(ent(M2)), 〈σ, τ1〉, g −1(attr(M2))〉 of the source structure M2 (§ A.3). The two are bridged M2 〈k,g〉 −−−⇀↽ − struc g 〈k,g〉(M2) = M1 by the structure morphism.\nStruc(S2) Struc(S1)\nStruc\nstrucf〈r,f〉\nincS2 incS1\nχ̀〈r,f〉 ===⇒\n✛\n❏ ❏ ❏❏❫\n✡ ✡\n✡✡✢\nr−1(E1)\n∑−1 f (List(A1)) = List(f −1(A1))\n〈σ2, τ1〉\nE1\nList(A1)\n〈σ2, τ2〉\n〈r,1K1 〉−−−−−⇀↽ −\nList(f, 1Y1 )\n−⇀↽−\n︸ ︷︷ ︸\nstrucf〈r,f〉(M1) (χ̀〈r,f〉)M1−−−−−−−−−⇀↽ − 〈r,1K1 ,f,1Y1 〉 M1\nMultiple Universes. The Grothedieck construction of the schema indexed mathematical context Schop strucf\n−−−−→ Cxt is the fibered mathematical context Struc of structures and structure morphisms. A structure M is as described in § 4.3 (Fig. 3). A structure morphism M2 〈r,k,f,g〉 −−−−−⇀↽ − M1 from source structure M2 to\ntarget structure M1 consists of a schema morphism S2 〈r,f〉 ===⇒ S1 from source schema S2 to target structure S1 and a morphism\nM2 = 〈E2, 〈σ2, τ2〉,A2〉 〈k,g〉 −−−⇀↽ − 〈r −1(E1), 〈σ2, τ1〉, f −1(A1)〉 = struc f 〈r,f〉(M1)\nin the fiber mathematical context of structures Struc(S2). Hence, a structure morphism satisfies the following conditions.\nlist preservation\nr · σ1 = σ2 · ∑\nf\nk · τ2 = τ1 · ∑\ng\ninfomorphisms\nk1 |=E1 r(r2) iff k(k1) |=E2 r2 y1 |=A1 f(x2) iff g(y1) |=A2 x2\nThus, a structure morphism M2 〈r,k,f,g〉 −−−−−⇀↽ − M1 (Fig. 5 in § 4.3) from source\nstructure M2 = 〈E2, 〈σ2, τ2〉,A2〉 to target structure M1 = 〈E1, 〈σ1, τ1〉,A1〉 is defined in terms of the hypergraph and classification morphisms between the source and target structure components (projections):\nuniverse morphism U2 = univ(M2) 〈k,g〉 ===⇒ univ(M1) = U1\nschema morphism S2 = sch(M2) 〈r,f〉 ===⇒ sch(M1) = S1\ntyped domain morphism A2 = attr(M2) 〈f,g〉 −−−⇀↽ − attr(M1) = A1\nentity infomorphism E2 = ent(M2) 〈r,k〉 −−−⇀↽ − ent(M1) = E1\nStructure morphisms compose component-wise. Let Struc denote the context of structures and structure morphisms. (Fig. 7 in § 4.3)\nA.3 Universe Orientation.\nAs evident from the type-instance duality in Fig. 3 and Fig. 5 of § 4, the fibered mathematical context Struc of structures and structure morphisms can be developed from the dual standpoint — the Grothedieck construction of a universe indexed mathematical context. This approach using universe indexing corresponds to the use of instance-set indexing in § A.1.\n1. For a fixed universe U , we define the structure fiber context Struc(U). 2. For a universe morphism U2 〈k,g〉 ⇐=== U1, we define the structure fiber passage\nStruc(U2) strucg〈k,g〉 −−−−−−→ Struc(U1).\n3. We define the fibered mathematical context Struc of structures and structure morphisms to be the Grothedieck construction of the universe indexed\nmathematical context Univop strucg −−−−→ Cxt\nFixed Universe. Let U = 〈K, τ, Y 〉 ∈ Univ be a fixed universe. We define the notion of a morphism between two (fixed universe) U-structures that respects the ERA data model. In these morphisms, the universe remains fixed, but the attribute types (sorts) and entity types are formally linked by maps that respect schema signature, typed domain extent and entity interpretation. A U-structure morphism M2 〈r,f〉 −−−⇀↽ − M1 over a fixed universe U = 〈K, τ, Y 〉 is a schema mor-\nphism sch(M2) 〈r,f〉 ===⇒ sch(M1), where attr(M2) 〈f,1Y 〉 −−−−⇀↽ − attr(M1) is an in-\nfomorphism in Cls(Y ) over the value set Y , and ent(M2) 〈r,1K〉 −−−−⇀↽ − ent(M1) is an infomorphism in Cls(K) over the key set K. 30 Here, M2 is called the reduct of M1 and M1 is called the expansion of M2. The two are bridged\nM2 = struc f 〈r,f〉(M1) 〈r,f〉 −−−⇀↽ − M1 by the structure morphism. 31 U-structure morphisms compose component-wise. Let Struc(U) denote the fiber context of structures over the fixed universe U .\nStructure Fiber Passage. We define the indexed context Univop strucg\n−−−−→ Cxt. Given a universe U , there is a fiber context of structures Struc(U) with that universe. Given a universe morphism U2 〈k,g〉 ⇐=== U1, there is a fiber passage of structures Struc(U2) strucg〈k,g〉 −−−−−−→ Struc(U1): a structureM2 = 〈E2, 〈σ2, τ2〉,A2〉 ∈\n30 Hence, the source type domain is the inverse image of the target type domain attr(M2) = f −1(attr(M1)) = cls f\nf (attr(M1)) and the source entity classification is the inverse image of the target entity classification ent(M2) = r−1(ent(M1)) = cls f\nr (ent(M1)). By combining entity/attribute inverse image classifications, the source structure M2 is the inverse image struc f 〈r,f〉(M1) = 〈r−1(ent(M1)), 〈σ2, τ〉, f −1(attr(M1))〉 of the target structure M1 (§ A.2). 31 When this definition is extended to formulas, one gets the notion of an interpretation of first-order logic (extended to the many-sorted case) given in (Barwise and Selman [1]).\nStruc(U2) is mapped to a structureM1 = struc g 〈k,g〉(M2) = 〈k −1(E2), 〈σ2, τ1〉, g −1(A2)〉 ∈ Struc(U1). The two are linked M2 χ́M2 ↼−−−− ⇁ 〈k,g〉 strucg〈k,g〉(M2) by a structure morphism, which is theMth2 component of a bridge incU2 χ́〈k,g〉 ====⇒ strucg〈k,g〉 ◦ incU1 .\nStruc(U2) Struc(U1)\nStruc\nstrucg〈k,g〉\nincU2 incU1\nχ́〈k,g〉 ====⇒\n✲\n❏ ❏ ❏❏❫\n✡ ✡\n✡✡✢\nk−1(E2)\n∑−1 g (List(A2)) = List(g −1(A2))\n〈σ2, τ1〉\nE2\nList(A2)\n〈σ2, τ2〉\n〈1R2 ,k〉 ↼−−−−−− ⇁\nList(1X2 , g)\n⇌\n︸ ︷︷ ︸\nstrucg〈k,g〉(M2) (χ́〈k,g〉)M2\n↼−−−−−−−−−− ⇁ 〈1R2 ,k,1X2 ,g〉 M2\nMultiple Universes. The Grothedieck construction of the universe indexed mathematical context Univop strucg\n−−−−→ Cxt is the fibered mathematical context Struc of structures and structure morphisms. A structure M is as described in § 4.3 (Fig. 3). A structure morphism M2 〈r,k,f,g〉 −−−−−⇀↽ − M1 from source structure M2\nto target structure M1 consists of a universe morphism U2 〈k,g〉 ⇐=== U1 to target structure U2 from source structure U1 and a morphism\nstrucg〈k,g〉(M2) = 〈k −1(E2), 〈σ2, τ1〉, g −1(A2)〉 〈r,f〉 −−−⇀↽ − 〈E1, 〈σ1, τ1〉,A1〉 = M1\nin the fiber mathematical context of structures Struc(U1). Hence, a structure morphism satisfies the following conditions.\nlist preservation\nr · σ1 = σ2 · ∑\nf\nk · τ2 = τ1 · ∑\ng\ninfomorphisms\nk1 |=E1 r(r2) iff k(k1) |=E2 r2 y1 |=A1 f(x2) iff g(y1) |=A2 x2\nThus, a structure morphism M2 〈r,k,f,g〉 −−−−−⇀↽ − M1 (Fig. 5 in § 4.3) from source\nstructure M2 = 〈E2, 〈σ2, τ2〉,A2〉 to target structure M1 = 〈E1, 〈σ1, τ1〉,A1〉 is defined in terms of the hypergraph and classification morphisms between the source and target structure components (projections):\nuniverse morphism U2 = univ(M2) 〈k,g〉 ===⇒ univ(M1) = U1\nschema morphism S2 = sch(M2) 〈r,f〉 ===⇒ sch(M1) = S1\ntyped domain morphism A2 = attr(M2) 〈f,g〉 −−−⇀↽ − attr(M1) = A1\nentity infomorphism E2 = ent(M2) 〈r,k〉 −−−⇀↽ − ent(M1) = E1\nStructure morphisms compose component-wise. Let Struc denote the context of structures and structure morphisms. (Fig. 7 in § 4.3)\nProposition 2. (compare Prop. 1) Any structure morphism M2 〈r,k,f,g〉 −−−−−⇀↽ − M1,\nwith schema morphism projection S2 〈r,f〉 ===⇒ S1 and universe morphism projection U2 〈k,g〉 ⇐=== U1, has dual factorizations (see the diagram below).\nStruc(S2) ︷ ︸︸ ︷\n︸ ︷︷ ︸\nStruc(U1)\nM2 struc f 〈r,f〉(M1)\nM1struc g 〈k,g〉(M2)\n〈k, g〉\n〈r, f〉\n〈k, g〉\n〈r, f〉\n−−−⇀↽ −\n−−−⇀↽ −\n↿⇂↿⇂\nThe top-right factorization (corresponding to the schema orientation of § A.2) consists of a Struc(S2)-morphism M2 〈k,g〉 −−−⇀↽ − strucf〈r,f〉(M1) and the M th 1 component strucf〈r,f〉(M1) 〈r,f〉 −−−⇀↽ − M1 of a bridge struc f 〈r,f〉 ◦ incS2 χ̀〈r,f〉 ====⇒ incS1 . The left-bottom factorization (corresponding to the universe orientation of § A.3) consists of the Mth2 component M2 〈k,g〉 −−−⇀↽ − strucg〈k,g〉(M2) of a bridge incU2 χ́〈k,g〉 ====⇒\nstrucg〈k,g〉 ◦ incU1 and a Struc(U1)-morphism struc g 〈k,g〉(M2) 〈r,f〉 −−−⇀↽ − M1."
    } ],
    "references" : [ {
      "title" : "Information Flow: The Logic of Distributed Systems.+",
      "author" : [ "J. Barwise", "J. Seligman" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1997
    }, {
      "title" : "Formal Concept Analysis: Mathematical Foundations",
      "author" : [ "B. Ganter", "R. Wille" ],
      "venue" : "Springer, New York",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "A categorical manifesto",
      "author" : [ "J. Goguen" ],
      "venue" : "Mathematical Structures in Computer Science 1, 49–67",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Ling Liu and M",
      "author" : [ "Gruber", "T. “Ontology”. In" ],
      "venue" : "Tamer Özsu (eds.) The Encyclopedia of Database Systems, Springer-Verlag",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Database Semantics",
      "author" : [ "R.E. Kent" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2011
    }, {
      "title" : "The First-order Logical Environment",
      "author" : [ "R.E. Kent" ],
      "venue" : "Pfeiffer, H.D., Ignatov, D.I., Poelmans, J., and Nagarjuna G. (eds.) Conceptual Structures in Research and Education, LNCS vol. 7735, pp. 210–230. Springer, Heidelberg",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Knowledge Representation: Logical, Philosophical, and Computational Foundations",
      "author" : [ "J.F. Sowa" ],
      "venue" : "Brookes/Coles",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Ologs: a categorical framework for knowledge representation",
      "author" : [ "D.I. Spivak", "R.E. Kent" ],
      "venue" : "PLoS ONE 7(1): e24274. doi:10.1371/journal.pone.0024274.",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "This paper discusses the representation of ontologies in the first-order logical environment FOLE (Kent [8]).",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 3,
      "context" : "An ontology defines the primitives with which to model the knowledge resources for a community of discourse (Gruber [6]).",
      "startOffset" : 116,
      "endOffset" : 119
    }, {
      "referenceID" : 5,
      "context" : "The third paper (Kent [10]) defines an interpretation of FOLE in terms of the transformational passage, first described in Kent [8], from the classification form of first-order logic to an equivalent interpretation form, thereby defining the formalism and semantics of first-order logical/relational database systems (Kent [7]).",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 4,
      "context" : "The third paper (Kent [10]) defines an interpretation of FOLE in terms of the transformational passage, first described in Kent [8], from the classification form of first-order logic to an equivalent interpretation form, thereby defining the formalism and semantics of first-order logical/relational database systems (Kent [7]).",
      "startOffset" : 323,
      "endOffset" : 326
    }, {
      "referenceID" : 1,
      "context" : "The FOLE representation follows a conceptual structures approach, that is completely compatible with formal concept analysis (Ganter and Wille [3]) and information flow (Barwise and Seligman [1]).",
      "startOffset" : 143,
      "endOffset" : 146
    }, {
      "referenceID" : 0,
      "context" : "The FOLE representation follows a conceptual structures approach, that is completely compatible with formal concept analysis (Ganter and Wille [3]) and information flow (Barwise and Seligman [1]).",
      "startOffset" : 191,
      "endOffset" : 194
    }, {
      "referenceID" : 5,
      "context" : "The first-order logical environment FOLE (Kent [8]) is a framework for defining the semantics and formalism of logic and databases in an integrated and coherent fashion.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 6,
      "context" : "In § 5 we connect FOLE to Sowa’s knowledge representation hierarchy (Sowa [11]) and through linearization to the Olog data model (Spivak and Kent [12]).",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 7,
      "context" : "In § 5 we connect FOLE to Sowa’s knowledge representation hierarchy (Sowa [11]) and through linearization to the Olog data model (Spivak and Kent [12]).",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 5,
      "context" : "1 Following the original discussion of FOLE (Kent [8]), we use “mathematical context” (Goguen [4]) for the mathematical term “category”, “passage” for the term “functor”, and “bridge” for the term “natural transformation”.",
      "startOffset" : 50,
      "endOffset" : 53
    }, {
      "referenceID" : 2,
      "context" : "1 Following the original discussion of FOLE (Kent [8]), we use “mathematical context” (Goguen [4]) for the mathematical term “category”, “passage” for the term “functor”, and “bridge” for the term “natural transformation”.",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 0,
      "context" : "2 The theory of classifications and infomorphisms is discussed in the book Information Flow by Barwise and Seligman [1].",
      "startOffset" : 116,
      "endOffset" : 119
    }, {
      "referenceID" : 5,
      "context" : "In contrast, the first-order logical environment FOLE (Kent [8]) followed the knowledge representation approach of traditional many-sorted first-order logic (MSFOL).",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 6,
      "context" : "1, and second to view things (either types or instances) as participating in Whitehead’s fundamental prehension relationship (Sowa [11]) along the FOLE hypergraph dimension in Fig.",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 5,
      "context" : "For simplicity of presentation, this paper and the paper on FOLE superstructure (Kent [9]) use a simplified form of FOLE, in contrast to the full form presented in Kent [8].",
      "startOffset" : 169,
      "endOffset" : 172
    }, {
      "referenceID" : 5,
      "context" : "in Kent [8].",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 5,
      "context" : "The FOLE approach to logic replaces n-tuples with lists, defines quantification/substitution along signature morphisms (Kent [9]) (or term vectors in the full version [8]), and following databases, incorporates identifiers (keys) for data value lists (tuples) (here and in Kent [10]).",
      "startOffset" : 167,
      "endOffset" : 170
    }, {
      "referenceID" : 5,
      "context" : "In the original paper (Kent [8]) explaining the first-order logical environment FOLE, there was an analogy between the top-level ontological categories discussed in (Sowa [11]) and the components of the first-order logical environment FOLE.",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 6,
      "context" : "In the original paper (Kent [8]) explaining the first-order logical environment FOLE, there was an analogy between the top-level ontological categories discussed in (Sowa [11]) and the components of the first-order logical environment FOLE.",
      "startOffset" : 171,
      "endOffset" : 175
    }, {
      "referenceID" : 7,
      "context" : "The “ontology log” Olog formalism (Spivak and Kent [12]) is a category-theoretic model for knowledge representation.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 4,
      "context" : "22 This section is closely related to the discussion of the sketch and interpretation associated with a unified relational database in § 4 of Kent [7].",
      "startOffset" : 147,
      "endOffset" : 150
    }, {
      "referenceID" : 5,
      "context" : "Olog facts correspond to the formalism discussed (indirectly) in the FOLE superstructure (Kent [9]) and (more directly) in the full form of FOLE (Kent [8]).",
      "startOffset" : 151,
      "endOffset" : 154
    }, {
      "referenceID" : 7,
      "context" : "4 of [12] for further discussion of binary/unary knowledge representations.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 5,
      "context" : "28 The interpretation passage satisfies an O-equation (t= t̂) : 〈I, s〉⇁ 〈I , s〉 when the operations coincide A(t) = A(t̂) : A(I, s) ← A(I , s) in Set (see Kent [8]).",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 5,
      "context" : "1, and was the approach used in the paper (Kent [8]).",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 0,
      "context" : "31 When this definition is extended to formulas, one gets the notion of an interpretation of first-order logic (extended to the many-sorted case) given in (Barwise and Selman [1]).",
      "startOffset" : 175,
      "endOffset" : 178
    } ],
    "year" : 2015,
    "abstractText" : "This paper discusses the representation of ontologies in the first-order logical environment FOLE (Kent [8]). An ontology defines the primitives with which to model the knowledge resources for a community of discourse (Gruber [6]). These primitives, consisting of classes, relationships and properties, are represented by the entity-relationshipattribute ERA data model (Chen [2]). An ontology uses formal axioms to constrain the interpretation of these primitives. In short, an ontology specifies a logical theory. This paper is the first in a series of three papers that provide a rigorous mathematical representation for the ERA data model in particular, and ontologies in general, within the first-order logical environment FOLE. The first two papers show how FOLE represents the formalism and semantics of (many-sorted) first-order logic in a classification form corresponding to ideas discussed in the Information Flow Framework (IFF [13]). In particular, this first paper provides a foundation that connects elements of the ERA data model with components of the first-order logical environment FOLE, and the second paper (Kent [9]) provides a superstructure that extends FOLE to the formalisms of firstorder logic. The third paper (Kent [10]) defines an interpretation of FOLE in terms of the transformational passage, first described in Kent [8], from the classification form of first-order logic to an equivalent interpretation form, thereby defining the formalism and semantics of first-order logical/relational database systems (Kent [7]). The FOLE representation follows a conceptual structures approach, that is completely compatible with formal concept analysis (Ganter and Wille [3]) and information flow (Barwise and Seligman [1]).",
    "creator" : "LaTeX with hyperref package"
  }
}