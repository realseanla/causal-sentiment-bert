{
  "name" : "1312.6134.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "An Algebra of Causal Chains",
    "authors" : [ "Pedro Cabalar", "Jorge Fandinno" ],
    "emails" : [ "jorge.fandino}@udc.es" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "A frequent informal way of explaining the effect of default negation in an introductory class on semantics in logic programming (LP) is that a literal of the form ‘not p’ should be read as “there is no way to derive p.” Although this idea seems quite intuitive, it is actually using a concept outside the discourse of any of the existing LP semantics: the ways to derive p. To explore this idea, [1] introduced the so-called causal logic programs. The semantics was an extension of stable models [2] relying on the idea of “justification” or “proof”. Any true atom, in a standard (non-causal) stable model needs to be justified. In a causal stable model, the truth value of each true atom captures these possible justifications, called causes. Let us see an example to illustrate this.\nExample 1. Suppose we have a row boat with two rowers, one at each side of the boat, port and starboard. The boat moves forward fwd if both rowers strike at a time. On the other hand, if we have a following wind, the boat moves forward anyway.\n? This research was partially supported by Spanish MEC project TIN2009-14562-C05-04 and Xunta program INCITE 2011.\nar X\niv :1\n31 2.\n61 34\nv1 [\ncs .A\nI] 2\n0 D\nec 2\n01 3\nSuppose now that we have indeed that both rowers stroke at a time when we additionally had a following wind. A possible encoding for this example could be the set of rules Π1:\np : port s : starb w : fwind\nfwd← port ∧ starb fwd← fwind\nIn the only causal stable model of this program, atom fwd was justified by two alternative and independent causes. On the one hand, cause {p, s} representing the joint interaction of port and starb. On the other hand, cause {w} inherited from fwind. We label rules (in the above program only atoms) that we want to be reflected in causes. Unlabelled fwd rules are just ignored when reflecting causal information. For instance, if we decide to keep track of the application of these rules, we would handle instead a program Π2 obtained just by labelling these two rules in Π1 as follows:\na : fwd← port ∧ starb (1) b : fwd← fwind (2)\nThe two alternative justifications for atom fwd become the pair of causes {p, s} · a and {w} · b. The informal reading of {p, s} · a is that “the joint interaction of {p} and {s}, the cause {p, s}, is necessary to apply rule a.” From a graphical point of view, we can represent causes as proof trees.\nIn this paper, we show that causes can be embedded in an algebra with three internal operations: an addition ‘+’ representing alternative justifications for a formula, a commutative product ‘∗’ representing joint interaction of causes (in a similar spirit to the ‘+’ in [3]) and a non-commutative product ‘·’ acting as a concatenation or rule application. Using these operations, we can see that justification for fwd would correspond now to the value ((p ∗ s) · a) + (w · b) which means that fwd is justified by the two alternative causes, (p ∗ s) · a and (w · b). The former refers to the application of rule a to the join interaction of p and s. Similarly, the later refers to the application of rule b to w. From a graphical point of view, each cause corresponds to one of proof trees in the Figure 1, the right hand side operator of application corresponds to the head whereas the left hand side operator corresponds to the product of its children.\nThe rest of the paper is organised as follows. Section 2 describes the algebra with these three operations and a quite natural ordering relation on causes. The next section studies the semantics for positive logic programs and shows the correspondence between the syntactic proof tree of a standard (non-causal) logic program and the interpretation of each atom in a causal model. Section 4 introduces default negation and stable models. Finally, Section 5 concludes the paper."
    }, {
      "heading" : "2 Algebra of causal values",
      "text" : "As we have introduced, our set of causal values will constitute an algebra with three internal operations: addition ‘+’ representing alternative causes, product ‘∗’ representing joint interaction between causes and rule application ‘·’. We define now causal terms, the syntactic counterpart of (causal) values, just as combinations of these three operations over labels (events).\nDefinition 1 (Causal term). A causal term, t, over a set of labels Lb is recursively defined as one of the following expressions:\nt ::= l | ∏ ti∈S ti | ∑ ti∈S ti | t1 · t2\nwhere l is a label l ∈ Lb, t1, t2 are in their turn causal terms and S is a (possibly empty or possibly infinite) set of causal terms. The set of causal terms over Lb is denoted by TLb.\nAs we can see, infinite products and sums are allowed whereas a term may only contain a finite number of concatenation applications. Constants 0 and 1 will be shorthands for the empty sum ∑ t∈∅ t and the empty product ∏ t∈∅ t, respectively.\nWe adopt the following notation. To avoid an excessive use of parentheses, we assume that ‘·’ has the highest priority, followed by ‘∗’ and ‘+’ as usual, and we further note that the three operations will be associative. When clear from the context, we will sometimes remove ‘·’ so that, for instance, the term l1l2 stands for l1 · l2. As we will see, two (syntactically) different causal terms may correspond to the same causal value. However, we will impose Unique Names Assumption (UNA) for labels, that is, l 6= l′ for any two (syntactically) different labels l, l′ ∈ Lb, and similarly l 6= 0 and l 6= 1 for any label l.\nTo fix properties of our algebra we recall that addition ‘+’ represents a set of alternative causes and product ‘∗’ a set of causes that are jointly used. Thus, since both represent sets, they are associative, commutative and idempotent. Contrary, although associative, application ‘·’ is not commutative. Note that the right hand side operator represents the applied rule and left hand one represents a cause that is necessary to apply it, therefore they are clearly not interchangeable. We can note another interesting property: application ‘·’ distributes over both addition ‘+’ and product ‘∗’. To illustrate this idea, consider the following variation of our example. Suppose now that the boat also leaves a wake behind when it moves forward. Let Π3 be the set of rules Π1 plus the rule k : wake ← fwd reflecting this new assumption. As we saw, fwd is justified by p ∗ s + w and thus wake will be justified by applying rule k : wake ← fwd to it, i.e.the value (p ∗ s + w) · k. We can also see that there are two alternative causes justifying wake, graphically represented in the Figure 2. The term that corresponds which this graphical representation is (p ∗ s) · k + w · k = (p ∗ s + w) · k. Moreover, application ‘·’ also distributes over product ‘∗’ and (p ∗ s) · k + w · k is equivalent to (p ·k) ∗ (s ·k)+ (w ·k). Intuitively, if the joint iteration of p and s is necessary to apply k then both p and s are also necessary to apply it, and conversely. Note that each chain of applications , (p · k), (s · k) and (w · k) corresponds to a path in one of the trees in the Figure 2. Causes can be seen as sets (products) of paths (causal chains).\nDefinition 2 (Causal Chain). A causal chain x over a set of labels Lb is a sequence x = l1 · l2 · . . . · ln, or simply l1l2 . . . ln, with length |x| = n > 0 and li ∈ Lb.\nWe denote XLb to stand for the set of causal chains over Lb and will use letters x, y, z to denote elements from that set. It suffices to have a non-empty set of labels, say Lb = {a}, to get an infinite set of chains XLb = {a, aa, aaa, . . . }, although all of them have a finite length. It is easy to see that, by an exhaustive application of distributivity, we can “shift” inside all occurrences of the application operator so that it only occurs in the scope of other application operators. A causal term obtained in this way is a normal causal term.\nDefinition 3 (Normal causal term). A causal term, t, over a set of labels Lb is recursively defined as one of the following expressions:\nt ::= x | ∏ ti∈S ti | ∑ ti∈S ti\nwhere x ∈ XLb is a causal chain over Lb and S is a (possibly empty or possibly infinite) set of normal causal terms. The set of causal terms over Lb is denoted by ULb.\nProposition 1. Every causal term t can be normalized, i.e. written as an equivalent normal causal term u.\nIn the same way as application ‘·’ distributes over addition ‘+’ and product ‘∗’, the latter, in their turn, also distributes over addition ‘+’. Consider a new variation of our example to illustrate this fact. Suppose that we have now two port rowers that can strike, encoded as the set of rules Π4:\np1 : port1 p2 : port2 s : starb\nport← port1 port← port2 fwd← port ∧ starb\nWe can see that, in the only causal stable model of this program, atom portwas justified by two alternative, and independent causes, p1 and p2, and after applying unlabelled rules to them, the resulting value assigned to fwd is (p1 + p2) ∗ s. It is also clear that there are two alternative causes justifying fwd: the result from combining the starboard rower strike with each of the port rower strikes, p1 ∗ s and p2 ∗ s. That is, causal terms (p1 + p2) ∗ s and p1 ∗ s+ p2 ∗ s are equivalent.\nFurthermore, as we introduce above, causes can be ordered by a notion of “strength” of justification. For instance, in our example, fwd is justified by two independent\ncauses, p ∗ s + w while fwind is only justified by w. If we consider the program Π5 obtained by removing the fact w : fwind from Π1 then fwd keeps being justified by p ∗ s but fwind becomes false. That is, fwd is “more strongly justified” than fwind in Π1, written w ≤ p ∗ s + w. Similarly, p ∗ s ≤ p ∗ s + w. Note also that, in this program Π5, fwd needs the joint interaction of p and s to be justified but port and starb only need p and s, respectively. That is, p is “more strongly justified” than p ∗ s, written p ∗ s ≤ p. Similarly, p ∗ s ≤ s. We can also see that in program Π2 which labels rules for fwd, one of the alternative causes for fwd is w · b and this is “less strongly justified” than w, i.e. w · b ≤ w since, from a similar reasoning, w · b needs the application of b to w when w only requires itself. In general, we will see that a ·b ≤ a∗b ≤ X ≤ a+b whereX can be either a or b. We formalize this order relation starting for causal chains. Notice that a causal chain x = l1l2 . . . ln can be alternatively characterized as a partial function from naturals to labels x : N −→ Lb where x(i) = li for all i ≤ n and undefined for i > n. Using this characterisation, we can define the following partial order among causal chains:\nDefinition 4 (Chain subsumption). Given two causal chains x and y ∈ XLb, we say that y subsumes x, written x ≤ y, if and only if there exists a strictly increasing function δ : N −→ N such that for each i ∈ N with y(i) defined, x ( δ(i) ) = y(i).\nProposition 2. Given two finite causal chains x, y ∈ XLb, they are equivalent (i.e. both x ≤ y and y ≤ x) if and only if they are syntactically identical.\nInformally speaking, y subsumes x, when we can embed y into x, or alternatively when we can form y by removing (or skipping) some labels from x. For instance, take the causal chains x = abcde and y = ac. Clearly we can form y = ac = a · b · c · d · e by removing b, d and e from x. Formally, x ≤ y because we can take some strictly increasing function with δ(1) = 1 and δ(2) = 3 so that y(1) = x(δ(1)) = x(1) = a and y(2) = x(δ(2)) = x(3) = c.\nAlthough, at a first sight, it may seem counterintuitive the fact that x ≤ y implies |x| ≥ |y|, as we mentioned, a fact or formula is “more strongly justified” when we need to apply less rules to derive it (and so, causal chains contain less labels) respecting their ordering. In this way, chain ac is a “more strongly justification” than abcde.\nAs we saw above, a cause can be seen as a product of causal chains, that from a graphical point of view correspond to the set of paths in a proof tree. We notice now an interesting property relating causes and the “more strongly justified” order relation: a joint interaction of comparable causal chains should collapse to the weakest among them. Take, for instance, a set of rules Π6:\na : p b : q ← p r ← p ∧ q\nwhere, in the unique causal stable model, r corresponds to the value a∗a · b. Informally we can read this as “we need a and apply rule b to rule a to prove r”. Clearly, we are repeating that we need a. Term a is redundant and then a∗a·b is simply equivalent to a·b. This idea is quite related to the definition of order filter in order theory. An order filter F of a poset P is a special subset F ⊆ P satisfying1 that for any x ∈ F and y ∈ P , x ≤ y\n1 Order filter is a weaker notion than filter which further satisfies that any pair x, y ∈ F has a lower bound in F too.\nimplies y ∈ F . An order filter F is furthermore generated by an element x ∈ P iff x ≤ y for all elements y ∈ F , the order filter generated by x is written ||x||. Considering causes as the union of filters generated by their causal chains, the join interaction of causes just correspond to their union. For instance, if we consider the set of labels Lb = {a, b} and its corresponding set of causal chains XLb = {a, b, ab, ba, . . . }, then ||ab|| and ||a|| respectively correspond to the set of all chains grater than ab and a in the poset P = 〈XLb,≤〉. Those are, ||ab|| = {ab, a, b} and ||a|| = {a}. The term a ∗ ab corresponds just to the union of both sets ||a|| ∪ ||ab|| = ||ab||. We define a cause as follows:\nDefinition 5 (Cause). A cause for a set of labels Lb is any order filter for the poset of chains 〈XLb,≤〉. We will write CLb (or simply C when there is no ambiguity) to denote the set of all causes for Lb.\nThis definition captures the notion of cause, or syntactically a product of causal chains. To capture possible alternative causes, that is, additions of products of causal chains, we notice that addition obeys a similar behaviour with respect to redundant causes. Take, for instance, a set of rules Π7:\na : p b : p← p\nIt is clear, that the cause a is sufficient to justify p, but there are also infinitely many other alternative and redundant causes a · b, a · b · b, . . . that justify p, that is a+ a · b+ a · b · b+ . . . . To capture a set of alternative causes we define the idea of causal value, in its turn, as a filter of causes.\nDefinition 6 (Causal Value). Given a set of labels Lb, a causal value is any order filter for the poset 〈CLb,⊆〉.\nThe causal value ||||a||||, the filter generated by the cause ||a||, is the set containing ||a|| = {a, a+b} and all its supersets. That is, ||||a|||| = {||a||, ||a∗b||, ||a ·b||, . . . }. Futhermore, as we will se later, addition can be interpreted as the union of causal values for its respective operands. Thus, a+ a · b+ a · b · b+ . . . just corresponds to the union of the causal values generated by their addend causes, ||||a||||∪||||a · b||||∪||||a · b · b||||+. . . = ||||a||||.\nThe set of possible causal values formed with labels Lb is denoted as VLb. An element from VLb has the form of a set of sets of causal chains that, intuitively, corresponds to a set of alternative causes (sum of products of chains). From a graphical point of view, it corresponds to a set of alternative proof trees represented as their respective sets of paths. We define now the correspondence between syntactical causal terms and their semantic counterpart, causal values.\nDefinition 7 (Valuation of normal terms). The valuation of a normal term is a mapping : ULb −→ VLb defined as:\n(x) def = |||x||| with x ∈ XLb, (∑ t∈S t ) def = ⋃ t∈S (t), (∏ t∈S t ) def = ⋂ t∈S (t)\nNote that any causal term can be normalized and then this definition trivially extends to any causal term. Furthermore, a causal chain x is mapped just to the causal value generated by the cause, in their turn, generated by x, i.e. the set containing all causes which contain x. The aggregate union of an empty set of sets (causal values) corresponds to ∅. Therefore (0) = ⋃ t∈∅ (t) = ∅, i.e. 0 just corresponds to the absence of justification. Similarly, as causal values range over parts of C, the aggregate intersection of an empty set of causal values corresponds to C, and thus (1) = ⋂ t∈∅ (t) = C, i.e. 1 just corresponds to the “maximal” justification.\nTheorem 1 (From [4]). 〈VLb,∪,∩〉 is the free completely distributive lattice generated by 〈XLb,≤〉, and the restriction of to XLb is an injective homomorphism (or embedding).\nThe above theorem means that causal terms form a complete lattice. The order relation≤ between causal terms just corresponds to set inclusion between their corresponding causal values, i.e. x ≤ y iff (x) ⊆ (y). Furthermore, addition ‘+’ and product ‘∗’ just respectively correspond to the least upper bound and the greater lower bound of the associated lattice 〈TLb,≤〉 or 〈TLb,+, ∗〉 where:\nt ≤ u def= (t) ⊆ (u) (⇔ t ∗ u = t ⇔ t+ u = u )\nfor any normal term t and u. For instance, in our example Π2, fwd was associated with the causal term p · a ∗ s · a+w · b. Thus, the causal value associated with it corresponds to\n(p · a ∗ s · a+ w · b) = ||||p · a|||| ∩ ||||s · a|||| ∪ ||||w · b||||\nCausal values are, in general, infinite sets. For instance, as we saw before, simply with Lb = {a} we have the chains XLb = {a, aa, aaa, . . . } and (a) contains all possible causes in C that are supersets of {a}, that is, (a) = {{a}, {aa, a}, {aaa, aa, a}, . . . }. Obviously, writing causal values in this way is infeasible – it is more convenient to use a representative causal term instead. For this purpose, we define a function γ that acts as a right inverse morphism for selecting minimal causes, i.e., given a causal value V , it defines a normal term γ(V ) = t such that (t) = V and γ(V ) does not have redundant subterms. The function γ is defined as a mapping γ : VLb −→ ULb such that for any causal value V ∈ VLb, γ(V ) def = ∑ C∈V ∏ x∈C x where V = {C ∈ V |6 ∃D ∈ V,D ⊂ C} and C = {x ∈ C |6 ∃y ∈ C, y < x} respectively stand for ⊆-minimal causes of V and ≤-minimal chains of C. We will use γ(V ) to represent V .\nProposition 3. The mapping γ is a right inverse morphism of .\nGiven a term t we define its canonical form as γ( (t)). Canonical terms are of the form of sums of products of causal chains. As it can be imagined, not any term in that form is a canonical term. For instance, going back, we easily can check that terms a ∗ ab = ab and a+ ab+ abb+ · · · = a respectively correspond to the canonical terms γ( (ab ∗ a)) = γ( (ab)) = ab and γ( (a+ ab+ abb+ . . . )) = γ( (a)) = a. Figure 3 summarizes addition and product properties while Figure 4 is analogous for application properties.\nFor practical purposes, simplification of causal terms can be done by applying the algebraic properties shown in Figures 3 and 4. For instance, the examples from Π6 and Π7 containing redundant information can now be derived as follows:\na ∗ a · b = (a ∗ 1 · a · b) identity for ‘·’ = 1 · a · b absorption for ‘·’ = a · b identity for ‘·’\na+ a · b+ a · b · b+ . . . = a+ 1 · a · b+ a · b · b+ . . . identity for ‘·’ = a+ a · b · b+ . . . absorption for ‘·’ = a+ 1 · a · b · b+ . . . identity for ‘·’ . . . . . . = a absorption for ‘·’\nLet us see another example involving distributivity. The term ab ∗ c+ a can be derived as follows:\na · b ∗ c+ a = (a · b+ a) ∗ (c+ a) distributivity = (1 · a · b+ a) ∗ (c+ a) identity for ‘·’ = (a+ 1 · a · b) ∗ (c+ a) commutativity for ‘+’ = a ∗ (c+ a) absorption for ‘·’ = a absorption for ‘∗’"
    }, {
      "heading" : "3 Positive programs and minimal models",
      "text" : "Let us describe now how to use the causal algebra to evaluate causal logic programs. A signature is a pair 〈At, Lb〉 of sets that respectively represent the set of atoms (or propositions) and the set of labels. As usual, a literal is defined as an atom p (positive literal) or its negation ¬p (negative literal). In this paper, we will concentrate on programs without disjunction in the head, leaving the treatment of disjunction for a future study.\nDefinition 8 (Causal logic program). Given a signature 〈At, Lb〉 a (causal) logic program Π is a set of rules of the form:\nt : L0 ← L1 ∧ . . . ∧ Lm ∧ not Lm+1 ∧ . . . ∧ not Ln\nwhere t is a causal term over Lb, L0 is a literal or ⊥ (the head of the rule) and L1 ∧ . . .∧Lm ∧ not Lm+1 ∧ . . . not Ln is a conjunction of literals (the body of the rule). An empty body is represented as >.\nFor any rule φ of the form t : L0 ← L1∧. . .∧Lm∧not Lm+1∧. . . not Ln we define label(φ) = t. Most of the following definitions are standard in logic programming. We denote head(φ) = L0, B+ (resp. B−) to represent the conjunction of all positive (resp. negative) literals L1 ∧ . . . ∧ Ln (resp. not Lm+1 ∧ . . . ∧ not Ln) that occur in B. A logic program is positive if B− is empty for all rules (n = m), that is, if it contains no negations. Unlabelled rules are assumed to be labelled with the element 1 which, as we saw, is the identity for application ‘·’. > (resp. ⊥) represent truth (resp. falsity). If n = m = 0 then← can be dropped.\nGiven a signature 〈At, Lb〉 a causal interpretation is a mapping I : At −→ VLb assigning a causal value to each atom. Partial order ≤ is extended over interpretations so that given two interpretations I, J we define I ≤ J def= I(p) ≤ J(p) for each atom p ∈ At. There is a≤-bottom interpretation 0 (resp. a≤-top interpretation 1) that stands for the interpretation mapping each atom p to 0 (resp. 1). The set of interpretations I with the partial order ≤ forms a poset 〈I,≤〉 with supremum ‘+’ and infimum ‘∗’ that are respectively the sum and product of atom interpretations. As a result, 〈I,+, ∗〉 also forms a complete lattice.\nObservation 1 When Lb = ∅ the set of causal values becomes VLb = {0, 1} and interpretations collapse to classical propositional logic interpretations.\nDefinition 9 (Causal model). Given a positive causal logic program Π and a causal interpretation I over the signature 〈At, Lb〉, I is a causal model, written I |= Π , if and only if (\nI(L1) ∗ . . . ∗ I(Lm) ) · t ≤ I(L0)\nfor each rule ϕ ∈ Π of the form ϕ = L0 ← L1, . . . , Lm.\nFor instance, take rule (1) from Example 1 and let I be an interpretation such that I(port) = p and I(starb) = s. Then I will be a model of (1) when (p ∗ s) · a ≤\nI(fwd). In particular, this holds when I(fwd) = (p ∗ s) ·a+w · b which was the value we expected for program Π2. But it would also hold when, for instance, I(fwd) = a + b or I(fwd) = 1. Note that this is important if we had to accommodate other possible additional facts (a : fwd) or even (1 : fwd) in the program. The fact that any I(fwd) greater than (p ∗ s) · a + w · b is also a model clearly points out the need for selecting minimal models. In fact, as happens in the case of non-causal programs, positive programs have a least model (this time, with respect to≤ relation among causal interpretations) that can be computed by iterating an extension of the well-known direct consequences operator defined by [5].\nDefinition 10 (Direct consequences). Given a positive logic program Π for signature 〈At, Lb〉 and a causal interpretation I , the operator of direct consequences is a function TΠ : I −→ I such that, for any atom p ∈ At:\nTΠ(I)(L0) def = ∑{ ( I(L1) ∗ . . . ∗ I(Lm) ) · t | (t : L0 ← L1 ∧ . . . ∧ Lm) ∈ Π } In order to prove some properties of this operator, an important observation should be made: since the set of causal values forms now a lattice, causal logic programs can be translated to Generalized Annotated Logic Programming (GAP). GAP is a general a framework for multivalued logic programming where the set of truth values must to form an upper semilattice and rules (annotated clauses) have the following form:\nL0 : ρ← L1 : µ1 & . . . & Lm : µm (3)\nwhere L0, . . . , Lm are literals, ρ is an annotation (may be just a truth value, an annotation variable or a complex annotation) and µ1, . . . , µm are values or annotation variables. A complex annotation is the result to apply a total continuous function to a tuple of annotations. For instance ρ can be a complex annotation f(µ1, . . . , µm) that applies the function f to a m-tuple (µ1, . . . , µm) of annotation variables in the body of (3). Given a positive program Π , each rule ϕ ∈ Π of the form\nt : L0 ← L1 ∧ . . . ∧ Lm (4)\nis translated to an annotated clause GAP (ϕ) of the form of (3) where µ1, . . . , µm are annotation variables that capture the causal values of each body literal. The head complex annotation corresponds to the function ρ def= (µ1 ∗ . . . ∗µm) · t that forces the head to inherit the causal value obtained by applying the rule label t to the product of the interpretation of body literals µ1 ∗ . . . ∗ µm. The translation of a program Π is simply defined as:\nGAP (Π) def = {GAP (ϕ) | ϕ ∈ Π}\nA complete description of GAP restricted semantics, denoted as |=r, is out of the scope of this paper (the reader is referred to [6]). For our purposes, it suffices to observe that the following important property is satisfied.\nTheorem 2. A positive causal logic program Π can be translated to a general annotated logic program GAP (Π) s.t. a causal interpretation I |= Π if and only if I |=r GAP (Π). Furthermore, TΠ(I) = RGAP (Π)(I) for any interpretation I .\nCorollary 1. Given a positive logic program Π the following properties hold:\n1. Operator TΠ is monotonic. 2. Operator TΠ is continuous. 3. TΠ ↑ ω (0) = lfp(TΠ) is the least model of Π . 4. The iterative computation TΠ ↑ k (0) reaches the least fixpoint in n steps for some\npositive integer n.\nProof. Directly follows from Theorem 2 and Theorems 1, 2 and 3 in [6].\nThe existence of a least model for a positive program and its computation using TΠ is an interesting result, but it does not provide any information on the relation between the causal value it assigns to each atom with respect to its role in the program. As we will see, we can establish a direct relation between this causal value and the idea of proof in the positive program. Let us formalise next the idea of proof tree.\nDefinition 11 (Proof tree). Given a causal logic program Π , a proof tree is a directed acyclic graph T = 〈V,E〉, where vertices V ⊆ Π are rules from the program, and E ⊆ V × V satisfying:\n(i) There is at exactly one vertex without outgoing edges denoted as sink(T ). (ii) For each rule ϕ = (t : L0 ← B) ∈ V and for each atom Li ∈ B+ there is exactly\none ϕ′ with (ϕ′, ϕ) ∈ E and this rule satisfies head(ϕ′) = Li.\nNotice that condition (ii) forces us to include an incoming edge for each atom in the positive body of a vertex rule. As a result, source vertices must be rules with empty positive body, or just facts in the case of positive programs. Another interesting observation is that, proof tree do not require an unique parent for each vertex. For instance, in Example 1, if both port and starb were obtained as a consequence of some command made by the captain, we could get instead a proof tree, call it T1, of the form:\nc : command\nrr ,,\np : port← command ++\ns : starb← command ss\na : fwd← port ∧ starb\nDefinition 12 (Proof path). Given a proof tree T = 〈V,E〉 we define a proof path for T as a concatenation of terms t1 . . . tn satisfying:\n1. There exists a rule ϕ ∈ V with label(r) = t1 such that ϕ is a source, that is, there is no ϕ′ s.t. (ϕ′, ϕ) ∈ E.\n2. For each pair of consecutive terms ti, ti+1 in the sequence, there is some edge (ϕi, ϕi+1) ∈ E s.t. label(ϕi) = ti and label(ϕi+1) = ti+1. 3. label(sink(T )) = tn.\nLet us write Paths(T ) to stand for the set of all proof paths for a given proof tree T . We define the cause associated to any tree T = 〈V,E〉 as the causal term cause(T ) def = ∏ t∈Paths(T ) t. As an example, cause(T1) = (c · p · a) ∗ (c · s · a). Also (p · a) ∗ (s · a) and w · b correspond to each tree in Figure 1.\nTheorem 3. Let Π be a positive program and I be the least model of Π , then for each atom p:\nI(p) = ∑\nT∈PTp\ncause(T )\nwhere PTp = {T = 〈V,E〉 | head(sink(T )) = p} is a set of proof trees with nodes V ⊆ Π .\nFrom this result, it may seem that our semantics is just a direct translation of the syntactic idea of proof trees. However, the semantics is actually a more powerful notion that allows detecting redundancies, tautologies and inconsistencies. In fact, the expression∑ T∈PTp\ncause(T ) may contain redundancies and is not, in the general case, in normal form. As an example, recall the program Π6:\na : p b : q ← p r ← p ∧ q\nthat has only one proof tree for p whose cause would correspond to I(r) = a ∗ a · b. But, by absorption, this is equivalent to I(r) = a · b pointing out that the presence of p in rule r ← p ∧ q is redundant.\nA corollary of Theorem 3 is that we can replace a rule label by a different one, or by 1 (the identity for application ‘·’) and we get the same least model, modulo the same replacement in the causal values for all atoms.\nCorollary 2. Let Π be a positive program, I the least model of Π , l ∈ Lb be a label, m ∈ Lb ∪ {1} and Π lm (resp. I lm) be the program (resp. interpretation) obtained after replacing each occurrence of l by m in Π (resp. in the interpretation of each atom in I). Then I lm is the least model of Π l m.\nIn particular, replacing a label bym = 1 has the effect of removing it from the signature. Suppose we make this replacement for all atoms in Lb and call the resulting program and least model ΠLb1 and I Lb 1 respectively. Then Π Lb 1 is just the non-causal program resulting from Π after removing all labels and it is easy to see (Observation 1) that ILb1 coincides with the least classical model of this program2. Moreover, this means that for any positive program Π , if I is its least model, then the classical interpretation:\nI ′(p) def = { 1 if I(p) 6= 0 0 otherwise\nis the least classical model of Π ignoring its labels.\n2 Note that ILb is Boolean: if assigns either 0 or 1 to any atom in the signature."
    }, {
      "heading" : "4 Default negation and stable models",
      "text" : "Consider now the addition of negation, so that we deal with arbitrary programs. To illustrate this, we introduce a variation in Example 1 introducing the qualification problem from [7]: actions for moving the boat forward can be disqualified if an abnormal situation occurs (for instance, that the boat is anchored, any of the oars are broken, the sail is full of holes, etc.) . As usual this can be represented using default negation as shown in the set of rules Π8:\np : port s : starb\na : fwd← port ∧ starb ∧ not ab a ab a← anchored ab a← broken oar1 ab a← broken oar2\nw : fwind\nb : fwd← fwind ∧ not ab b ab b← anchored ab b← holed sail\n. . .\nThe causes that justify an atom should not be a list of not occurred abnormal situations. For instance, in program Π8 where no abnormal situation occurs, the causal value that justify atom fwd should be (p · a ∗ s · a) + (w · b) as in the program Π2 where abnormal situations are not included. References to the not occurred abnormal situations (not anchored, not broken oar1. . . ) are not mentioned. Default negation does not affect the causes justifying an atom when the default holds. Of course, when the default does not hold, for instance adding the fact anchored to the above program, fwd becomes false. Thus, we introduce the following straightforward rephrasing of the traditional program reduct [2].\nDefinition 13 (Program reduct). The reduct of a program Π with respect to an interpretation I , written ΠI is the result of the following transformations on Π:\n1. Removing all rules s.t. I(B−) = 0 2. Removing all negative literals from the rest of rules.\nA causal interpretation I is a causal stable model of a causal program Π if I is the least model of ΠI . This definition allows us to extend Theorem 3 to normal programs in a direct way:\nTheorem 4 (Main theorem). LetΠ be a causal program and I be causal stable model of Π , then for each atom p:\nI(p) = ∑\nT∈PTp\ncause(T ) where\nPTp = {T = 〈V,E〉 | head(sink(T )) = p and V ⊆ {(t : q ← B) ∈ Π | I(B−) 6= 0}}.\nThat is, the only difference now is that the set of proof trees PTp is formed with rules whose negative body is not false I(B−) 6= 0 (that is, they would generate rules in the reduct).\nCorollary 3. Let Π be a normal program, I a causal stable model of Π , l ∈ Lb be a label, m ∈ Lb∪ {1} and Π lm (resp. I lm) be the program (resp. interpretation) obtained after replacing every occurrence of l bym inΠ (resp. in the interpretation of each atom in I). Then I lm is a causal stable model of Π l m.\nAs in the case of positive programs, replacing a label by m = 1 has the effect of removing it from the signature. Then, for any normal program Π , if I is a causal stable model, then the classical interpretation:\nI ′(p) def = { 1 if I(p) 6= 0 0 otherwise\nis a classical stable model of Π ignoring its labels. It is easy to see that not only the above program Π8 has an unique causal stable model that corresponds to:\nI(port) = p I(starb) = s I(fwind) = w I(fwd) = (p · a ∗ s · a) + (w · b)\nI(ab f) = 0 I(anchored) = 0 I(broken oar1) = 0\n. . . = 0\nbut also the program obtained from it ignoring the labels has an unique standard stable model {port, starb, fwind, fwd} that corresponds to the atoms whose interpretations differ from 0 in the former."
    }, {
      "heading" : "5 Conclusions",
      "text" : "In this paper we have provided a multi-valued semantics for normal logic programs whose truth values form a lattice of causal chains. A causal chain is nothing else but a concatenation of rule labels that reflects some sequence of rule applications. In this way, a model assigns to each true atom a value that contains justifications for its derivation from existing rules. We have further provided three basic operations on the lattice: an addition, that stands for alternative, independent justifications; a product, that represents joint interaction of causes; and a concatenation that acts as a chain constructor. We have shown that this lattice is completely distributive and provided a detailed description of the algebraic properties of its three operations.\nA first important result is that, for positive programs, there exists a least model that coincides with the least fixpoint of a direct consequences operator, analogous to [5]. With this, we are able to prove a direct correspondence between the semantic values we obtain and the syntactic idea of proof tree. The main result of the paper generalises this correspondence for the case of stable models for normal programs.\nMany open topics remain for future study. For instance, ongoing work is currently focused on implementation, complexity assessment, extension to disjunctive programs or introduction of strong negation. Regarding expressivity, an interesting topic is the introduction of new syntactic operators for inspecting causal information like checking the influence of a particular event or label in a conclusion, expressing necessary or sufficient causes, or even dealing with counterfactuals. Another interesting topic is removing the syntactic reduct definition in favour of some full logical treatment of default\nnegation, as happens for (non-causal) stable models and their characterisation in terms of Equilibrium Logic [8]. This would surely simplify the quest for a necessary and sufficient condition for strong equivalence, following similar steps to [9]. It may also allow extending the definition of causal stable models to an arbitrary syntax and to the first order case, where the use of variables in labels may also introduce new interesting features.\nThere are also other areas whose relations deserve to be formally studied. For instance, the introduction of a strong negation operator will immediate lead to a connection to Paraconsistency approaches. In particular, one of the main problems in the area of Paraconsistency is deciding which parts of the theory do not propagate or depend on an inconsistency. This decision, we hope, will be easier in the presence of causal justifications for each derived conclusion. A related area for which similar connections can be exploited is Belief Revision. In this case, causal information can help to decide which relevant part of a revised theory must be withdrawn in the presence of new information that would lead to an inconsistency if no changes are made. A third obvious related area is Debugging in Answer Set Programming, where we try to explain discrepancies between an expected result and the obtained stable models. In this field, there exists a pair of relevant approaches [10,11] to whom we plan to compare. Finally, as potential applications, our main concern is designing a high level action language on top of causal logic programs with the purpose of modelling some typical scenarios from the literature on causality in Artificial Intelligence."
    } ],
    "references" : [ {
      "title" : "Causal logic programming",
      "author" : [ "P. Cabalar" ],
      "venue" : "In Erdem, E., Lee, J., Lierler, Y., Pearce, D., eds.: Correct Reasoning. Volume 7265 of Lecture Notes in Computer Science., Springer",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "In Kowalski, R.A., Bowen, K.A., eds.: Logic Programming: Proc. of the Fifth International Conference and Symposium (Volume 2). MIT Press, Cambridge, MA",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Explicit provability and constructive semantics",
      "author" : [ "S.N. Artëmov" ],
      "venue" : "Bulletin of Symbolic Logic 7(1)",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Free distributive completions of partial complete lattices",
      "author" : [ "G. Stumme" ],
      "venue" : "Order 14",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "The semantics of predicate logic as a programming language",
      "author" : [ "M.H. van Emden", "R.A. Kowalski" ],
      "venue" : "J. ACM 23(4)",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1976
    }, {
      "title" : "Theory of generalized annotated logic programming and its applications",
      "author" : [ "M. Kifer", "V.S. Subrahmanian" ],
      "venue" : "Journal of Logic Programming 12",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "Epistemological problems of artificial intelligence",
      "author" : [ "J. McCarthy" ],
      "venue" : "In Reddy, R., ed.: IJCAI, William Kaufmann",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "Equilibrium logic",
      "author" : [ "D. Pearce" ],
      "venue" : "Ann. Math. Artif. Intell. 47(1-2)",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "V. Lifschitz", "D. Pearce", "A. Valverde" ],
      "venue" : "ACM Trans. Comput. Log. 2(4)",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "A meta-programming technique for debugging answer-set programs",
      "author" : [ "M. Gebser", "J. Pührer", "T. Schaub", "H. Tompits" ],
      "venue" : "In Fox, D., Gomes, C.P., eds.: AAAI, AAAI Press",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Justifications for logic programs under answer set semantics",
      "author" : [ "E. Pontelli", "T.C. Son", "O. El-Khatib" ],
      "venue" : "TPLP 9(1)",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2009
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "To explore this idea, [1] introduced the so-called causal logic programs.",
      "startOffset" : 22,
      "endOffset" : 25
    }, {
      "referenceID" : 1,
      "context" : "The semantics was an extension of stable models [2] relying on the idea of “justification” or “proof”.",
      "startOffset" : 48,
      "endOffset" : 51
    }, {
      "referenceID" : 2,
      "context" : "In this paper, we show that causes can be embedded in an algebra with three internal operations: an addition ‘+’ representing alternative justifications for a formula, a commutative product ‘∗’ representing joint interaction of causes (in a similar spirit to the ‘+’ in [3]) and a non-commutative product ‘·’ acting as a concatenation or rule application.",
      "startOffset" : 270,
      "endOffset" : 273
    }, {
      "referenceID" : 3,
      "context" : "Theorem 1 (From [4]).",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 4,
      "context" : "In fact, as happens in the case of non-causal programs, positive programs have a least model (this time, with respect to≤ relation among causal interpretations) that can be computed by iterating an extension of the well-known direct consequences operator defined by [5].",
      "startOffset" : 266,
      "endOffset" : 269
    }, {
      "referenceID" : 5,
      "context" : "GAP (Π) def = {GAP (φ) | φ ∈ Π} A complete description of GAP restricted semantics, denoted as |=, is out of the scope of this paper (the reader is referred to [6]).",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 5,
      "context" : "Directly follows from Theorem 2 and Theorems 1, 2 and 3 in [6].",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 6,
      "context" : "To illustrate this, we introduce a variation in Example 1 introducing the qualification problem from [7]: actions for moving the boat forward can be disqualified if an abnormal situation occurs (for instance, that the boat is anchored, any of the oars are broken, the sail is full of holes, etc.",
      "startOffset" : 101,
      "endOffset" : 104
    }, {
      "referenceID" : 1,
      "context" : "Thus, we introduce the following straightforward rephrasing of the traditional program reduct [2].",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 4,
      "context" : "A first important result is that, for positive programs, there exists a least model that coincides with the least fixpoint of a direct consequences operator, analogous to [5].",
      "startOffset" : 171,
      "endOffset" : 174
    }, {
      "referenceID" : 7,
      "context" : "negation, as happens for (non-causal) stable models and their characterisation in terms of Equilibrium Logic [8].",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 8,
      "context" : "This would surely simplify the quest for a necessary and sufficient condition for strong equivalence, following similar steps to [9].",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 9,
      "context" : "In this field, there exists a pair of relevant approaches [10,11] to whom we plan to compare.",
      "startOffset" : 58,
      "endOffset" : 65
    }, {
      "referenceID" : 10,
      "context" : "In this field, there exists a pair of relevant approaches [10,11] to whom we plan to compare.",
      "startOffset" : 58,
      "endOffset" : 65
    } ],
    "year" : 2013,
    "abstractText" : "In this work we propose a multi-valued extension of logic programs under the stable models semantics where each true atom in a model is associated with a set of justifications, in a similar spirit than a set of proof trees. The main contribution of this paper is that we capture justifications into an algebra of truth values with three internal operations: an addition ‘+’ representing alternative justifications for a formula, a commutative product ‘∗’ representing joint interaction of causes and a non-commutative product ‘·’ acting as a concatenation or proof constructor. Using this multi-valued semantics, we obtain a one-to-one correspondence between the syntactic proof tree of a standard (non-causal) logic program and the interpretation of each true atom in a model. Furthermore, thanks to this algebraic characterization we can detect semantic properties like redundancy and relevance of the obtained justifications. We also identify a lattice-based characterization of this algebra, defining a direct consequences operator, proving its continuity and that its least fix point can be computed after a finite number of iterations. Finally, we define the concept of causal stable model by introducing an analogous transformation to Gelfond and Lifschitz’s program reduct.",
    "creator" : "LaTeX with hyperref package"
  }
}