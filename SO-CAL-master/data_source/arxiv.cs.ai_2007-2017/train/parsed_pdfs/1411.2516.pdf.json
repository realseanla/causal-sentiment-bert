{
  "name" : "1411.2516.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Answering Conjunctive Queries over EL Knowledge Bases with Transitive and Reflexive Roles",
    "authors" : [ "Giorgio Stefanoni", "Boris Motik" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 Introduction Description logics (DLs) (Baader et al. 2007) are a family of knowledge representation languages that logically underpin the Web Ontology Language (OWL 2) (Cuenca Grau et al. 2008). DL knowledge bases (KBs) provide modern information systems with a flexible graph-like data model, and answering conjunctive queries (CQs) over such KBs is a core reasoning service in various applications (Calvanese et al. 2011). Thus, the investigation of the computational properties of CQ answering, as well as the development of practicable algorithms, have received a lot of attention lately.\nFor expressive DLs, CQ answering is at least exponential in combined complexity (Glimm et al. 2008; Ortiz, Rudolph, and Simkus 2011)—that is, measured in the combined size of the query and the KB. The problem is easier for the DLLite (Calvanese et al. 2007) and the EL (Baader, Brandt, and Lutz 2005) families of DLs, which logically underpin the QL and the EL profiles of OWL 2, respectively, and worst-case optimal, yet practicable algorithms are known (Kontchakov et al. 2011; Rodriguez-Muro, Kontchakov, and\nCopyright c© 2017, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nZakharyaschev 2013; Eiter et al. 2012; Venetis, Stoilos, and Stamou 2014). One can reduce the complexity by restricting the query shape; for example, answering acyclic CQs (Yannakakis 1981) is tractable in relational databases. Bienvenu et al. (2013) have shown that answering acyclic CQs in DLLitecore and ELH is tractable, whereas Gottlob et al. (2014) have shown it to be NP-hard in DL-LiteR.\nIn this paper, we consider answering CQs over KBs in the EL family of languages. No existing practical approach for EL supports complex role inclusions—a prominent feature of OWL 2 EL that can express complex properties of roles, including role transitivity. The known upper bound for answering CQs over EL KBs with complex role inclusions (Krötzsch, Rudolph, and Hitzler 2007) runs in PSPACE and uses automata techniques that are not practicable due to extensive don’t-know nondeterminism. Moreover, this algorithm does not handle transitive roles specifically, but considers complex role inclusions. Hence, it is not clear whether the PSPACE upper bound is optimal in the presence of transitive roles only; this is interesting because role transitivity suffices to express simple graph properties such as reachability, and it is a known source of complexity of CQ answering (Eiter et al. 2009). Thus, to complete the landscape, we study the complexity of answering CQs over various extensions of EL and different classes of CQs. Our contributions can be summarised as follows.\nIn Section 3 we present a novel algorithm running in NP for answering CQs over ELHOs KBs—a logic containing all of OWL 2 EL, but with complex role inclusions restricted to role transitivity—and thus settle the open question of the complexity for transitive and (locally) reflexive roles. Our procedure generalises the combined approach with filtering (Lutz et al. 2013) for ELHO by Stefanoni, Motik, and Horrocks (2013). We capture certain consequences of an ELHOs KB by a datalog program; then, to answer a CQ, we evaluate the query over the datalog program to obtain candidate answers, and then we filter out unsound candidate answers. Transitive and reflexive roles, however, increase the complexity of the filtering step: unlike the filtering procedure for ELHO, our filtering procedure runs in nondeterministic polynomial time, and we prove that this is worstcase optimal—that is, checking whether a candidate answer is sound is an NP-hard problem. To obtain a goal-directed filtering procedure, we developed optimisations that reduce ar X\niv :1\n41 1.\n25 16\nv1 [\ncs .A\nI] 1\n0 N\nov 2\n01 4\nthe number of nondeterministic choices. Finally, our filtering procedure runs in NP only for candidate answers that depend on both the existential knowledge in the KB, and transitive or reflexive roles—that is, our algorithm exhibits payas-you-go behaviour. To evaluate the feasibility of our approach, we implemented a prototypical CQ answering system and we carried out a preliminary evaluation. Our results suggest that, although some queries may be challenging, our algorithm can be practicable in many cases.\nIn Section 4 we study the complexity of answering acyclic CQs over KBs expressed in various extensions of EL. We introduce a new class of arborescent queries—tree-shaped acyclic CQs in which all roles point towards the parent. We prove that answering arborescent queries over EL KBs with either a single transitive role or a single reflexive role is NPhard; this is interesting because Bienvenu et al. (2013) show that answering acyclic queries over ELH KBs is tractable, and it shows that our algorithm from Section 3 is optimal for arborescent (and thus also acyclic) queries. Moreover, we show that answering unrestricted acyclic CQs is NP-hard for ELHO, but it becomes tractable for arborescent queries.\nAll proofs of our results are provided in the appendix.\n2 Preliminaries We use the standard notions of constants, (ground) terms, atoms, and formulas of first-order logic with the equality predicate ≈ (Fitting 1996); we assume that > and ⊥ are unary predicates without any predefined meaning; and we often identify a conjunction with the set of its conjuncts. A substitution σ is a partial mapping of variables to terms; dom(σ) and rng(σ) are the domain and the range of σ, respectively; for convenience, we extend each σ to identity on ground terms; σ|S is the restriction of σ to a set of variables S; and, for α a term or a formula, σ(α) is the result of simultaneously replacing each free variable x occurring in α with σ(x). Finally, [i, j] is the set {i, i+ 1, . . . , j − 1, j}.\nRules and Conjunctive Queries An existential rule is a formula ∀~x ∀~y.ϕ(~x, ~y)→ ∃~z.ψ(~x, ~z) where ϕ and ψ are conjunctions of function-free atoms over variables ~x ∪ ~y and ~x ∪ ~z, respectively. An equality rule is a formula of the form ∀~x.ϕ(~x)→ s ≈ t where ϕ is a conjunction of function-free atoms over variables ~x, and s and t are function-free terms with variables in ~x. A rule base Σ is a finite set of rules and function-free ground atoms; Σ is a datalog program if ~z = ∅ for each existential rule in Σ. Please note that Σ is always satisfiable, as > and ⊥ are ordinary unary predicates. We typically omit universal quantifiers in rules.\nA conjunctive query (CQ) is a formula q = ∃~y.ψ(~x, ~y) where ψ is a conjunction of function-free atoms over variables ~x ∪ ~y. Variables ~x are the answer variables of q. Let NV (q) = ~x ∪ ~y and let NT (q) be the set of terms occurring in q. When ~x is empty, we call q a Boolean CQ.\nFor τ a substitution, let τ(q) = ∃~z.τ(ψ), where ~z is obtained from ~y by removing each variable y ∈ ~y such that τ(y) is a constant, and by replacing each variable y ∈ ~y such that τ(y) is a variable with σ(y).\nLet Σ be a rule base and let q = ∃~y.ψ(~x, ~y) be a CQ over the predicates in Σ. A substitution π is a certain answer to q\na 3\n4\nT,E\nT,D\nb\n5\n6T,D\nT,F\nR,T\nR,T R,T\na\nT,E\nT,D\nb\nT,F\nR,T\nR,T\nR,T\nR,T\nR,T\nR,T R,T\n1 S,C\nS\n2 T,D\nR,T S,C\nS\nR,T\nT,R\na\ny3\nb\ny2y1\nR,T\nR,T\nR,T\nR,T\nR,T\nR,T\nR,T\nR,T\nS S\nFigure 1: The models of ΞK and DK, and the skeleton for q\n3 Answering CQs over ELHOs KBs In this section, we present an algorithm for answering CQs over ELHOs KBs running in NP. In the rest of this section, we fix K = 〈T ,A〉 to be an arbitrary ELHOs KB.\nCertain answers to a CQ over ΞK can be computed by evaluating the CQ over a so-called canonical model that can be homomorphically embedded into all other models of ΞK. It is well known (Krötzsch, Rudolph, and Hitzler 2007) that such models can be seen as a family of directed trees whose roots are the individuals occurring in ΞK, and that contain three kinds edges: direct edges point from parents to children or to the individuals in ΞK; transitive edges introduce shortcuts between these trees; and self-edges introduce loops on tree nodes. We call non-root elements auxiliary. Moreover, each auxiliary element can be uniquely associated with a rule of the form A1(x)→ ∃z.R(x, z) ∧A(z) in ΞK that was used to generate it, and we cal R,A the element’s type. Example 1 illustrates these observations.\nExample 1. Let K = 〈T ,A〉 be an ELHOs KB whose T contains the following axioms and A = {A(a), B(b)}.\nA v ∃S.C E v ∃T.D G v {a} C v ∃S.Self B v ∃T.F D v ∃T.D C v ∃T.D F v ∃T.D T v R A v ∃T.E F v ∃T.G trans(T )\nThe left part of Figure 1 shows a canonical model I of ΞK. Each auxiliary element is represented as a number showing the element’s type. Transitive and self-edges are dashed, with the latter shown in grey. All other edges are solid, apart from the dotted edges that encode repetition of solid edges. Due to axiom D v ∃T.D, model I is infinite.\nA canonical model I of ΞK can be infinite, so a terminating CQ answering algorithm for ELHOs cannot materialise I and evaluate CQs in it. Instead, we first show how to translate K into a datalog program DK that finitely captures the canonical model I of ΞK; next, we present a CQ answering procedure that uses DK to answer CQs over ΞK."
    }, {
      "heading" : "Datalog Translation",
      "text" : "Krötzsch, Rudolph, and Hitzler (2008) translate K into datalog for the purposes of ontology classification, and Stefanoni, Motik, and Horrocks (2013) use this translation to answer CQs over ELHO KBs. Let oR,A be an auxiliary individual not occurring in NI and uniquely associated with each role R ∈ NR and each atomic concept A ∈ NC ∪ {>}\noccurring inK; intuitively, oR,A represent all auxiliary terms of type R,A in a canonical model I of ΞK. We extend this translation by uniquely associating with each role R a direct predicate dR to represent the direct edges in I .\nDefinition 1. For each axiom α ∈ T not of type 7, set DT contains the translation of α into a rule as shown in Table 1; moreover, for each axiom A1 v ∃R.A ∈ T , set DT contains rule A1(x)→ R(x, oR,A) ∧ dR(x, oR,A) ∧A(oR,A); finally, for each axiom S v R ∈ T , set DT contains rule dS(x, y)→ dR(x, y). Then, DK = DT ∪ clsK ∪ A is the datalog program for K. Example 2. The middle part of Figure 1 shows model J of the datalog program DK for the KB from Example 1. For clarity, auxiliary individuals oR,A are shown as R,A. Note that auxiliary individual oT,G is ‘merged’ in model J with individual a since DK |= oT,G ≈ a. We use the notation from Example 1 to distinguish various kinds of edges.\nThe following proposition shows how to use DK to test whether K is unsatisfiable. Proposition 2. K is unsatisfiable iff DK |= ∃y.⊥(y)."
    }, {
      "heading" : "The CQ Answering Algorithm",
      "text" : "Program DK can be seen as a strengthening of ΞK: all existential rules A1(x)→ ∃z.R(x, z)∧A(z) in ΞK are satisfied in a model J of DK using a single auxiliary individual oR,A. Therefore, evaluating a CQ q in J produces a set of candidate answers, which provides us with an upper bound on the set of certain answers to q over ΞK.\nDefinition 3. A substitution τ is a candidate answer to a CQ q = ∃~y.ψ(~x, ~y) over DK if dom(τ) = NV (q), each element of rng(τ) is an individual occurring in DK, and DK |= τ(q). Such a candidate answer τ is sound if ΞK |= τ |~x (q).\nStefanoni, Motik, and Horrocks (2013) presented a filtering step that removes unsound candidate answers; however, Example 3 shows that this step can be incomplete when the query contains roles that are not simple.\nExample 3. Let K be as in Example 1 and let\nq = ∃y.A(x1) ∧R(x1, y) ∧B(x2) ∧R(x2, y) ∧D(y).\nMoreover, let π be the substitution such that π(x1) = a and π(x2) = b, and let τ be such that π ⊆ τ and τ(y) = oT,D. Using models I and J from Figure 1, one can easily see that ΞK |= π(q) and DK |= τ(q). However, q contains a ‘fork’ R(x1, y) ∧R(x2, y), and τ maps y to an auxiliary individual, so this answer is wrongly filtered as unsound.\nAlgorithm 1 specifies a procedure isSound(q,DK, τ) that checks whether a candidate answer is sound. We discuss the intuitions using the KB from Example 1, and the query q and the candidate answer τ from Example 4.\nExample 4. Let q and τ be as follows. Using Figure 1, one can easily see that DK |= τ(q).\nq = ∃~y. S(x, y1) ∧ S(y1, y1) ∧R(x, y3) ∧D(y3) ∧ R(y2, y3) ∧ F (y2) ∧ T (y2, x)\nτ = {x 7→ a, y1 7→ oS,C , y2 7→ oT,F , y3 7→ oT,D}\nWe next show how isSound(q,DK, τ) decides that τ is sound—that is, that a substitution π mapping the variables in q to terms in I exists such that π(x) = a and π(q) ⊆ I . Substitution τ already provides us with some constraints on π: it must map variable y1 to 1 and variable y2 to 5, since these are the only elements of I of types S,C and T, F , respectively. In contrast, substitution π can map variable y3 to either one of 2, 4, and 6. Each such substitution π is guaranteed to satisfy all unary atoms of q, all binary atoms of q that τ maps to direct edges pointing towards (non-auxiliary) individuals fromNI , and all binary atoms of q that contain a single variable and that τ maps to the self-edge in J . Atoms T (y2, x) and S(y1, y1) in q satisfy these conditions, and so we call them good w.r.t. τ . To show that τ is sound, we must demonstrate that all other atoms of q are satisfied.\nStep 1 of Algorithm 1 implements the ‘fork’ and ‘auxacyclicity’ checks (Stefanoni, Motik, and Horrocks 2013). To guarantee completeness, we consider only those binary atoms in q that contain simple roles, and that τ maps onto direct edges in J pointing towards auxiliary elements. We call these atoms aux-simple as they can be mapped onto the direct edges in I pointing towards auxiliary elements. In step 1 we compute a new query q∼ by applying all constraints derived by the fork rule, and in the rest of the algorithm we consider q∼ instead of q. In our example, atom S(x, y1) is the only aux-simple atom, so q does not contain forks and q∼ = q. When all binary atoms occurring in q are good or aux-simple, step 1 guarantees that τ is sound. Query q from Example 4, however, contains binary atoms that are neither good nor aux-simple, so we proceed to step 3.\nNext, in step 3 we guess a renaming σ for the variables in q∼ to take into account that distinct variables in q∼ that τ maps to the same auxiliary individual can be mapped to the same auxiliary element of I , and so in the rest of Algorithm 1 we consider σ(q∼) instead of q∼. In our example, we guess σ to be identity, so σ(q∼) = q∼ = q.\nIn step 4, we guess a skeleton for σ(q∼), which is a finite structure that finitely describes the (possibly infinite) set of all substitutions π mapping the variables in σ(q∼) to distinct auxiliary elements of I . The right part of Figure 1 shows the skeleton S for our example query. The vertices of S are the (non-auxiliary) individuals from DK and the variables from σ(q∼) that τ maps to auxiliary individuals, and they are arranged into a forest rooted in NI . Such S represents those substitutions π that map variables y1 and y3 to auxiliary elements of I under individual a, and that map variable y2 to an auxiliary element of I under individual b.\nIn steps 5–15, our algorithm labels each edge 〈v′, v〉 ∈ S with a set of roles L(v′, v); after these steps, S represents those substitutions π that satisfy the following property (E):\nfor each role P ∈ L(v′, v), a path from τ(v′) to τ(v) in J exists that consists only of direct edges labelled by role P pointing to auxiliary individuals.\nWe next show how atoms of σ(q∼) that are not good contribute to the labelling of S. Atom S(x, y1) is used in step 6 to label edge 〈a, y1〉. For atom R(x, y3), in step 8 we let P = T and we label edge 〈a, y3〉 with P . Using Figure 1 and the axioms in Example 1, one can easily check that the\nconditions in steps 8 and 9 are satisfied. For atom R(y2, y3), variables y2 and y3 are not reachable in S, so we must split the path from y2 to y3. Thus, in step 8 we let P = T , and in step 13 we let at = a; hence, atom R(y2, y3) is split into atoms T (y2, a) and T (a, y3). The former is used in step 14 to check that a direct path exists in J connecting oT,F with a, and the latter is used to label edge 〈a, y2〉.\nAfter the for-loop in steps 7–15, skeleton S represents all substitutions satisfying (E). In step 17, function exist exploits the direct predicates from DK to find the required direct paths in J , thus checking whether at least one such substitution exists (see Definition 11). Using Figure 1, one can check that substitution π where π(y3) = 4 and that maps all other variables as stated above is the only substitution satisfying the constraints imposed by S; hence, isSound returns t, indicating that candidate answer τ is sound.\nWe now formalise the intuitions that we have just presented. Towards this goal, in the rest of this section we fix a CQ q′ and a candidate answer τ ′ to q′ over DK.\nDue to equality rules, auxiliary individuals in DK may be equal to individuals fromNI , thus not representing auxiliary elements of I . Hence, set auxDK in Definition 4 provides us with all auxiliary individuals that are not equal to an individual from NI . Moreover, to avoid dealing with equal individuals, we replace in query q′ all terms that τ ′ does not map to individuals in auxDK with a single canonical representative, and we do analogously for τ ′; this replacement produces CQ q and substitution τ . Since q and τ are obtained by replacing equals by equals, we have DK |= τ(q). Our filtering procedure uses q and τ to check whether τ ′ is sound. Definition 4. Let > be a total order on ground terms such that oR,A > a for all individuals oR,A and a ∈ NI from DK. Set auxDK contains each individual u from DK for which no individual a ∈ NI exists such that DK |= u ≈ a. For each individual u from DK, let u≈ = u if u ∈ auxDK ; otherwise, let u≈ be the smallest individual a ∈ NI in the ordering > such that DK |= u ≈ a. Set indDK contains a≈ for each individual a ∈ NI occurring in DK. Then query q is obtained from q′ by replacing each term t ∈ NT (q′) such that τ ′(t) 6∈ auxDK with τ ′(t)≈; substitution τ is obtained by restricting τ ′ to only those variables occurring in q.\nNext, we define good and aux-simple atoms w.r.t. τ . Definition 5. Let R(s, t) be an atom where τ(s) and τ(t) are defined. Then, R(s, t) is good if τ(t) ∈ NI , or s = t and DK |= SelfR(τ(s)). Furthermore, R(s, t) is aux-simple if s 6= t, R is a simple role, τ(t) ∈ auxDK , and τ(s) = τ(t) implies DK 6|= SelfR(τ(s)).\nNote that, if R(s, t) is not good, then t is a variable and τ(t) ∈ auxDK . Moreover, by the definition of DK, if atom R(s, t) is aux-simple, then DK |= dR(τ(s), τ(t)). The following definition introduces the query q∼ obtained by applying the fork rule by Stefanoni, Motik, and Horrocks (2013) to only those atoms that are aux-simple. Definition 6. Relation ∼ ⊆ NT (q)×NT (q) for q and τ is the smallest reflexive, symmetric, and transitive relation closed under the fork rule.\ns′ ∼ t′(fork) R(s, s ′) and P (t, t′) are aux-simple\natoms in q w.r.t. τs ∼ t\nQuery q∼ is obtained from query q by replacing each term t ∈ NT (q) with an arbitrary, but fixed representative of the equivalence class of ∼ that contains t.\nTo check whether q∼ is aux-acyclic, we next introduce the connection graph cg for q and τ that contains a set Es of edges 〈v′, v〉 for each aux-simple atom R(v′, v) ∈ q∼. In addition, cg also contains a set Et of edges 〈v′, v〉 that we later use to guess a skeleton for σ(q∼) more efficiently. By the definition of aux-simple atoms, we have Es ⊆ Et. Definition 7. The connection graph for q and τ is a triple cg = 〈V,Es, Et〉 where Es, Et ⊆ V × V are smallest sets satisfying the following conditions.\n• V = indDK ∪ {z ∈ NV (q∼) | τ(z) ∈ auxDK}. • Set Es contains 〈v′, v〉 for all v′, v ∈ V for which a role R exist such that R(v′, v) an aux-simple atom in q∼. • Set Et contains 〈v′, v〉 for all v′, v ∈ V such that individuals {u1, . . . , un} ⊆ auxDK and roles R1, . . . , Rn exist with n > 0, un = τ(v), and DK |= dRi(ui−1, ui) for each i ∈ [1, n] and u0 = τ(v′). Function isDSound(q,DK, τ) from Definition 8 ensures that τ satisfies the constraints in ∼, and that q∼ does not contain cycles consisting only of aux-simple atoms.\nDefinition 8. Function isDSound(q,DK, τ) returns t if and only if the two following conditions hold.\n1. For all s, t ∈ NT (q), if s ∼ t, then τ(s) = τ(t)."
    }, {
      "heading" : "2. 〈V,Es〉 is a directed acyclic graph.",
      "text" : "We next define the notions of a variable renaming for q and τ , and of a skeleton for q and σ.\nDefinition 9. A substitution σ with dom(σ) = V ∩NV (q) and rng(σ) ⊆ dom(σ) is a variable renaming for q and τ if 1. for each v ∈ dom(σ), we have τ(v) = τ(σ(v)), 2. for each v ∈ rng(σ), we have σ(v) = v, and"
    }, {
      "heading" : "3. directed graph 〈σ(V ), σ(Es)〉 is a forest.",
      "text" : "Definition 10. A skeleton for q and a variable renaming σ is a directed graph S = 〈V, E〉 where V = σ(V ), and E satisfies σ(Es) ⊆ E ⊆ σ(Et) and it is a forest whose roots are the individuals occurring in V .\nFinally, we present function exist that checks whether one can satisfy the constraints imposed by the roles L(v′, v) labelling a skeleton edge 〈v′, v〉 ∈ E . Definition 11. Given individuals u′ and u, and a set of roles L, function exist(u′, u, L) returns t if and only if individuals {u1, . . . , un} ⊆ auxDK with n > 0 and un = u exist where • if S ∈ L exists such that trans(S) 6∈ T , then n = 1; and • u0 = u′, and DK |= dR(ui−1, ui) for each R ∈ L and\neach i ∈ [1, n]. Candidate answer τ ′ for q′ over DK is sound, if the nondeterministic procedure isSound(q,DK, τ) from Algorithm 1 returns t, as shown by Theorem 12.\nTheorem 12. Let π′ be a substitution. Then ΞK |= π′(q′) iff K is unsatisfiable, or a candidate answer τ ′ to q′ over DK exists such that τ ′|~x = π′ and the following conditions hold:\nAlgorithm 1: isSound(q,DK, τ) 1 if isDSound(q,DK, τ) = f then return f 2 return t if each R(s, t) ∈ q∼ is good or aux-simple 3 guess a variable renaming σ for q and τ 4 guess a skeleton S = 〈V, E〉 for q, σ, and τ 5 for 〈v′, v〉 ∈ E , let L(v′, v) = ∅ 6 for aux-simple atom R(s, t) ∈ σ(q∼), add R to L(s, t) 7 for neither good nor aux-simple R(s, t) ∈ σ(q∼) do 8 guess role P s.t. DK |= P (τ(s), τ(t)) and P v∗T R 9 if 〈s, t〉 6∈ E and trans(P ) 6∈ T then return f\n10 if s reaches t in E then 11 let v0, . . . , vn be the path from s to t in E 12 else 13 let at be the root reaching t in E via v0, . . . , vn 14 if DK 6|= P (τ(s), at) then return f 15 for i ∈ [1, n], add P to L(vi−1, vi) 16 for 〈v′, v〉 ∈ E do 17 if exist(τ(v′), τ(v), L(v′, v)) = f then return f 18 return t\n1. for each x ∈ ~x, we have τ ′(x) ∈ NI , and"
    }, {
      "heading" : "2. a nondeterministic computation exists such that function",
      "text" : "isSound(q,DK, τ) returns t. The following results show that our function isSound runs\nin nondeterministic polynomial time. Theorem 13. Function isSound(q,DK, τ) can be implemented so that"
    }, {
      "heading" : "1. it runs in nondeterministic polynomial time,",
      "text" : ""
    }, {
      "heading" : "2. if each binary atom in q is either good or aux-simple w.r.t.",
      "text" : "τ , it runs in polynomial time, and"
    }, {
      "heading" : "3. if the TBox T and the query q are fixed, it runs in polynomial time in the size of the ABox A.",
      "text" : "Each rule in DK contains a fixed number of variables, so we can compute all consequences of DK using polynomial time. Thus, we can compute CQ q and substitution τ in polynomial time, and by Proposition 2, we can also check whether K is unsatisfiable using polynomial time; thus, by Theorem 13, we can check whether a certain answer to q′ over ΞK exists using nondeterministic polynomial time.\nThe filtering procedure by Stefanoni, Motik, and Horrocks (2013) is polynomial, whereas the one presented in this paper introduces a source of intractability. In Theorem 14 we show that checking whether a candidate answer is sound is an NP-hard problem; hence, this complexity increase is unavoidable. We prove our claim by reducing the NP-hard problem of checking satisfiability of a 3CNF formula ϕ (Garey and Johnson 1979). Towards this goal, we define an ELHOs KB Kϕ and a Boolean CQ qϕ such that ϕ is satisfiable if and only if ΞKϕ |= qϕ. Furthermore, we define a substitution τϕ, and we finally show that τϕ is a unique candidate answer to qϕ over DKϕ . Theorem 14. Checking whether a candidate answer is sound is NP-hard."
    }, {
      "heading" : "Preliminary Evaluation",
      "text" : "We implemented our algorithm in a prototypical system, and we conducted a preliminary evaluation with the goal of\nshowing that the number of consequences of DK is reasonably small, and that the nondeterminism of the filtering procedure is manageable. Our prototype uses the RDFox (Motik et al. 2014) system to materialise the consequences of DK. We ran our tests on a MacBook Pro with 4GB of RAM and a 2.4Ghz Intel Core 2 Duo processor.\nWe tested our system using the version of the LSTW benchmark (Lutz et al. 2013) by Stefanoni, Motik, and Horrocks (2013). The TBox of the latter is in ELHO, and we extended it to ELHOs by making the role subOganizationOf transitive and by adding an axiom of type 5 and an axiom of type 7. We used the data generator provided by LSTW to generate KBs U5, U10, and U20 of 5, 10, and 20 universities, respectively. Finally, only query ql3 from the LSTW benchmark uses transitive roles, so we have manually created four additional queries. Our system, the test data, and the queries are all available online.1 We evaluated the practicality of our approach using the following two experiments.\nFirst, we compared the size of the materialised consequences of DK with that of the input data. As the left-hand side of Table 2 shows, the ratio between the two is four, which, we believe, is acceptable in most practical scenarios.\nSecond, we measured the ‘practical hardness’ of our filtering step on our test queries. As the right-hand side of Table 2 shows, soundness of a candidate answer can typically be tested in as few as several milliseconds, and the test involves a manageable number of nondeterministic choices. Queries qt3 and q t 4 were designed to obtain a lot of candidate answers with auxiliary individuals, so they retrieve many unsound answers. However, apart from query qt3, the percentage of the candidate answers that turned out to be unsound does not change with the increase in the size of the ABox. Therefore, while some queries may be challenging, we believe that our algorithm can be practicable in many cases.\n4 Acyclic and Arborescent Queries In this section, we prove that answering a simple class of tree-shaped acyclic CQs—which we call arborescent—over ELHO KBs is tractable, whereas answering acyclic queries is NP-hard. In addition, we show that extending EL with transitive or reflexive roles makes answering arborescent queries NP-hard. This is in contrast with the recent result by Bienvenu et al. (2013), who show that answering acyclic CQs over ELH KBs is tractable. We start by introducing acyclic and arborescent queries.\nDefinition 15. For q a Boolean CQ, dgq = 〈NV (q), E〉 is a directed graph where 〈x, y〉 ∈ E for each R(x, y) ∈ q.\n1http://www.cs.ox.ac.uk/isg/tools/EOLO/\nQuery q is acyclic if the graph obtained from dgq by removing the orientation of edges is acyclic; q is arborescent if q contains no individuals and dgq is a rooted tree with all edges pointing towards the root.\nDefinition 16 and Theorem 17 show how to answer arborescent CQs over ELHO KBs in polynomial time. Intuitively, we apply the fork rule (cf. Definition 6) bottom-up, starting with the leaves of q and spread constraints upwards.\nDefinition 16. Let K be an ELHO KB, let DK be the datalog program for K, let indDK and auxDK be as specified in Definition 4, and let q be an arborescent query rooted in r ∈ NV (q). For each y ∈ NV (q) with y 6= r, and each V ⊆ NV (q), sets ry and PV are defined as follows.\nry = {R ∈ NR | R(y, x) ∈ q with x the parent of y in dgq} PV = {y ∈ NV (q) | ∃x ∈ V with x the parent of y in dgq}\nSet RT is the smallest set satisfying the following conditions.\n• {r} ∈ RT and the level of {r} is 0. • For each set V ∈ RT with level n, we have PV ∈ RT and\nthe level of PV is n+ 1. • For each set V ∈ RT with level n and each y ∈ PV , we\nhave {y} ∈ RT and the level of {y} is n+ 1. For each V ∈ RT, set cV contains each u ∈ auxDK ∪ indDK such that DK |= B(u) for each unary atom B(x) ∈ q with x ∈ V . By reverse-induction on the level of the sets in RT, each V ∈ RT is associated with a set AV ⊆ indDK ∪ auxDK . • For each set V ∈ RT of maximal level, let AV = cV . • For V ∈ RT a set of level n where AV is undefined but\nAW has been defined for each W ∈ RT of level n+ 1, let AV = cV ∩ (iV ∪ aV ), where iV and aV are as follows.\niV = {u ∈ indDK | ∀y ∈ PV ∃u ′ ∈ A{y}.DK |= ∧ R∈ry R(u′, u)}\naV = {u ∈ auxDK | ∃u ′ ∈ APV ∀y ∈ PV .DK |= ∧ R∈ry dR(u ′, u)}\nFunction entails(DK, q) returns t if and only if A{r} is nonempty.\nTheorem 17. For K a satisfiable ELHO KB and q an arborescent query, function entails(DK, q) returns t if and only if ΞK |= q. Furthermore, function entails(DK, q) runs in time polynomial in the input size.\nFinally, we show that (unless PTIME = NP), answering arbitrary acyclic queries over ELHO KBs is harder than answering arborescent queries, and we show that adding transitive or reflexive roles to the DL EL makes answering arborescent queries intractable.\nTheorem 18. For K = 〈T ,A〉 a KB and q a Boolean CQ, checking K |= q is NP-hard in each of the following cases. 1. The query q is acyclic and the TBox T is in ELHO."
    }, {
      "heading" : "2. The query q is arborescent and the TBox T consists only",
      "text" : "of axioms of type 1 and 7, and of one axiom of type 8."
    }, {
      "heading" : "3. The query q is arborescent and the TBox T consists only",
      "text" : "of axioms of type 1 and 7, and of one axiom of type 9.\n5 Outlook In future, we shall adapt our filtering procedure to detect unsound answers already during query evaluation. Moreover, we shall extend Algorithm 1 to handle complex role inclusions, thus obtaining a practicable approach for OWL 2 EL.\nAcknowledgements This work was supported by the Royal Society; AlcatelLucent; the EU FP7 project OPTIQUE; and the EPSRC projects ExODA, MASI3, and QueRe.\nReferences Abiteboul, S.; Hull, R.; and Vianu, V. 1995. Foundations of Databases. Addison-Wesley. Baader, F.; Calvanese, D.; McGuinness, D.; Nardi, D.; and Patel-Schneider, P. F., eds. 2007. The Description Logic Handbook: Theory, Implementation, and Applications. Cambridge University Press. Baader, F.; Brandt, S.; and Lutz, C. 2005. Pushing the EL envelope. In Kaelbling, L. P., and Saffiotti, A., eds., IJCAI 2005, 364–369. Bienvenu, M.; Ortiz, M.; Simkus, M.; and Xiao, G. 2013. Tractable queries for lightweight description logics. In IJCAI 2013. Calvanese, D.; De Giacomo, G.; Lembo, D.; Lenzerini, M.; and Rosati, R. 2007. Tractable reasoning and efficient query answering in description logics: The DL-Lite family. J. of Automated Reasoning 39(3):385–429. Calvanese, D.; De Giacomo, G.; Lembo, D.; Lenzerini, M.; Poggi, A.; Rodriguez-Muro, M.; Rosati, R.; Ruzzi, M.; and Savo, D. F. 2011. The Mastro system for ontology-based data access. Semantic Web Journal 2(1):43–53. Cormen, T. H.; Leiserson, C. E.; Rivest, R. L.; and Stein, C. 2009. Introduction to Algorithms (3. ed.). MIT Press. Cuenca Grau, B.; Horrocks, I.; Motik, B.; Parsia, B.; PatelSchneider, P.; and Sattler, U. 2008. OWL 2: The next step for OWL. Journal of Web Semantics 6(4):309–322. Dantsin, E.; Eiter, T.; Gottlob, G.; and Voronkov, A. 2001. Complexity and expressive power of logic programming. ACM Computing Surveys 33(3):374–425. Eiter, T.; Lutz, C.; Ortiz, M.; and Simkus, M. 2009. Query answering in description logics with transitive roles. In IJCAI 2009, 759–764. Eiter, T.; Ortiz, M.; Simkus, M.; Tran, T.-K.; and Xiao, G. 2012. Query rewriting for Horn-SHIQ plus rules. In AAAI 2012.\nFitting, M. 1996. First-order logic and automated theorem proving (2nd ed.). Springer-Verlag New York, Inc. Garey, M. R., and Johnson, D. S. 1979. Computers and Intractability: A Guide to the Theory of NP-Completeness. W. H. Freeman & Co. Glimm, B.; Horrocks, I.; Lutz, C.; and Sattler, U. 2008. Conjunctive query answering for the description logic SHIQ."
    }, {
      "heading" : "Journal of Artif. Intell. Res. 31:151–198.",
      "text" : "Gottlob, G.; Kikot, S.; Kontchakov, R.; Podolskii, V. V.; Schwentick, T.; and Zakharyaschev, M. 2014. The price of query rewriting in ontology-based data access. Artif. Intell. 213:42–59. Kontchakov, R.; Lutz, C.; Toman, D.; Wolter, F.; and Zakharyaschev, M. 2011. The combined approach to ontologybased data access. In Walsh, T., ed., IJCAI 2011, 2656–2661. Krötzsch, M.; Rudolph, S.; and Hitzler, P. 2007. Conjunctive queries for a tractable fragment of OWL 1.1. In ISWC 2007, 310–323. Krötzsch, M.; Rudolph, S.; and Hitzler, P. 2008. ELP: Tractable rules for OWL 2. In Sheth, A.; Staab, S.; Dean, M.; Paolucci, M.; Maynard, D.; Finin, T.; and Thirunarayan, K., eds., ISWC 2008, 649–664. Krötzsch, M. 2010. Efficient inferencing for OWL EL. In JELIA 2010, volume 6341, 234–246. Lutz, C.; Seylan, I.; Toman, D.; and Wolter, F. 2013. The combined approach to OBDA: Taming role hierarchies using filters. In ISWC 2013, volume 8218, 314–330. Marnette, B. 2009. Generalized schema-mappings: from termination to tractability. In PODS 2009, 13–22. Motik, B.; Nenov, Y.; Piro, R.; Horrocks, I.; and Olteanu, D. 2014. Parallel materialisation of datalog programs in centralised, main-memory RDF systems. In AAAI 2014, 129– 137. Motik, B.; Shearer, R.; and Horrocks, I. 2009. Hypertableau reasoning for description logics. Journal of Artif. Intell. Res. 36:165–228. Ortiz, M.; Rudolph, S.; and Simkus, M. 2011. Query answering in the Horn fragments of the description logics SHOIQ and SROIQ. In Walsh, T., ed., IJCAI 2011, 1039–1044. Rodriguez-Muro, M.; Kontchakov, R.; and Zakharyaschev, M. 2013. Ontology-based data access: Ontop of databases. In ISWC 2013, 558–573. Springer. Stefanoni, G.; Motik, B.; and Horrocks, I. 2013. Introducing nominals to the combined query answering approaches for EL. In AAAI 2013. Venetis, T.; Stoilos, G.; and Stamou, G. B. 2014. Query extensions and incremental query rewriting for OWL 2 QL ontologies. J. Data Semantics 3(1):1–23. Yannakakis, M. 1981. Algorithms for acyclic database schemes. In VLDB 1981, 82–94.\nA Skolem Chase and Universal Interpretations In this section, we present a special variant of Skolem chase (Marnette 2009). Our chase uses merging (Abiteboul, Hull, and Vianu 1995) and pruning (Motik, Shearer, and Horrocks 2009) to deal with equality rules and guarantee that on rule base ΞK the so-called universal interpretation it produces satisfies the structural properties described in Section 3. We next formally present our chase variant.\nLet Σ be a rule base and assume, w.l.o.g., that each variable occurring in Σ is quantified over exactly once in Σ; furthermore, let> be an arbitrary total order on ground terms. Next, we first define some auxiliary notions, after which we define our Skolem chase variant and universal interpretations of Σ.\nThe skolemisation of an existential rule ϕ(~x, ~y)→ ∃~z.ψ(~x, ~z) is the formula ψsk obtained from ψ by substituting fz(~x) for each z ∈ ~z with fz a fresh function symbol of arity |~x|. A chase instance is a set I = IΣ ∪ Ieq where IΣ is a set of ground atoms over the predicates in Σ, and Ieq is a set of assertions of the form w w′ with a fresh predicate. For each term w, let ‖w‖I = w, if no term w′ exists such that w w′ ∈ I; otherwise, let ‖w‖I = w′ where w′ is the smallest term in the ordering > for which terms w0, . . . , wn with w0 = w and wn = w′ exist such that wi−1 wi ∈ I for each i ∈ [1, n]. For a formula α, ‖α‖I is the result of uniformly substituting each term w occurring in α with ‖w‖I .\nAn existential rule ϕ(~x, ~y)→ ∃~z.ψ(~x, ~z) is applicable to a chase instance I = IΣ ∪ Ieq, if a substitution σ exists such that σ(ϕ) ⊆ I and ‖σ(ψsk)‖I 6⊆ I; the result of applying such a rule to I is obtained by adding ‖σ(ψsk)‖I to IΣ. An equality rule ϕ(~x)→ s ≈ t is applicable to a chase instance I = IΣ ∪ Ieq, if a substitution σ exists such that σ(ϕ) ⊆ I and ‖σ(s)‖I 6= ‖σ(t)‖I ; for {w,w′} = {‖σ(s)‖I , ‖σ(t)‖I} such that w > w′, the result of applying such a rule to I is the chase instance I ′Σ ∪ I ′eq where I ′eq is the result of adding w w′ to Ieq, and I ′Σ is obtained by removing all atoms occurring in IΣ that contain a term w2 with w a proper subterm of w2, and by replacing each occurrence of w in the resulting instance with w′.\nA chase for Σ w.r.t. > is a sequence of chase instances I0, I1, . . . where I0 contains each ground atom in Σ, and, for each i ≥ 1, chase instance Ii+1 is the result of an (arbitrarily chosen) rule in Σ applicable to Ii, and Ii+1 = Ii, if no rule is applicable to Ii. This sequence must be fair—that is, if a rule ϕ→ ψ in Σ is applicable to some Ii under a specific substitution σ and σ(ϕ) ⊆ Ij , for each j ≥ i, then k ≥ i exists such that Ik+1 is the result of ϕ→ ψ on Ik w.r.t. substitution σ. Set I = ⋃ i∈N ⋂ j≥i Ij is a universal interpretation of Σ (w.r.t. >) and its domain is the set ∆\nI containing ‖w‖I for each term w that occurs in I .\nPlease note that for each term w that occurs in I in at least one atom over a predicate from Σ, we have ‖w‖I = w and w ∈ ∆I . Also, owing to the fairness of the chase sequence, no rule in Σ is applicable to I . Furthermore, if Σ does not contain equality rules, then I is independent from the order in which rules are applied, and so it is the universal interpretation of Σ. Otherwise, if Σ contains equality rules, then I is homomorphically equivalent w.r.t. the predicates occurring in Σ to any other universal interpretation I ′ of Σ, although I and I ′ may disagree on the assertions over . Finally, it is well known (Marnette 2009) that I can be homomorphically embedded into any model of Σ; so I can be used to answer arbitrary CQs over Σ. Fact 19. For each CQ q and each substitution π, Σ |= π(q) if and only if a substitution π∗ with dom(π∗) = NV (q) exists such that π ⊆ π∗ and ‖π∗(q)‖I ⊆ I ."
    }, {
      "heading" : "A.1 Universal Interpretations of ΞK and DK",
      "text" : "Let K be an ELHOs knowledge base, and let ΞK and DK be the rule base and the datalog program associated with K, respectively. In the rest of this appendix, we shall make the two following assumptions. First, we associate to each rule A1(x)→ ∃z.R(x, z) ∧A(z) in ΞK a fresh unary function symbol fA1R,A, and we assume that the skolemisation of such a rule is given by R(x, fA1R,A(x)) ∧A(f A1 R,A(x)). Second, we assume that the chase for ΞK and for DK, respectively, is w.r.t. the total order > specified in Definition 4, and that fA1R,A(w) > a for each ground term w and each individual a.\nB Proof of Proposition 2 We fix an ELHOs knowledge baseK. Let ΞK and DK be the rule base and the datalog program associated withK, respectively; moreover, let I and J be universal interpretations of ΞK and DK, respectively.\nWe next define a function δ that maps each term w occurring in I to a term δ(w) as follows:\nδ(w) = { w if w ∈ NI , oR,A if w is of the form w = fA1R,A(w ′).\nThe following two Lemmas show that δ establishes a tight connection between I and J . The proofs of these results is given in Appendix C. Lemma 20. Mapping δ satisfies the following properties for all terms w1 and w2 occurring in I , each individual a ∈ NI , each role R ∈ NR, and each concept C ∈ NC ∪ {>,⊥}. H1. C(w1) ∈ I implies that C(δ(w1)) ∈ J. H2. R(w1, w2) ∈ I implies that R(δ(w1), δ(w2)) ∈ J.\nH3. R(w1, w2) ∈ I and w is of the form fA1P,A(w1) imply that dR(δ(w1), δ(w2)) ∈ J ."
    }, {
      "heading" : "H4. ‖w1‖I = a implies that ‖δ(w1)‖J = a.",
      "text" : "Lemma 21. Mapping δ satisfies the following properties for all terms w1 and w2 occurring in I , each individual a ∈ NI , each role R ∈ NR, and each concept C ∈ NC ∪ {>,⊥}. D1. C(δ(w1)) ∈ J implies that C(w1) ∈ I. D2. SelfR(δ(w1)) ∈ J implies that R(w1, w1) ∈ I. D3. R(δ(w1), δ(w2)) ∈ J and δ(w2) ∈ NI imply that R(w1, w2) ∈ I. D4. R(δ(w1), δ(w2)) ∈ J and δ(w2) is of the form oP,A imply that • a term w′1 ∈ ∆I exists such that R(w′1, w2) ∈ I, and • a term w′2 ∈ ∆I exists such that δ(w′2) = oP,A and R(w1, w′2) ∈ I. D5. dR(δ(w1), δ(w2)) ∈ J and δ(w2) is of the form oP,A imply that • a term w′3 ∈ ∆I of the form f A1 P,A(w1) exists such that P (w1, w ′ 3) ∈ I , and\n• P v∗T R. D6. ‖δ(w1)‖J = δ(a) implies that ‖w1‖I = a."
    }, {
      "heading" : "D7. For each individual u ∈ ∆J , term w ∈ ∆I exists such that δ(w) = u.",
      "text" : "We are now ready to show that DK can be used to check the satisfiability of K. Proposition 2. K is unsatisfiable iff DK |= ∃y.⊥(y).\nProof. By the definition of ELHOs semantics,K is unsatisfiable if and only if ΞK |= ∃x.⊥(x). By Lemmas 20 and 21, for each term w ∈ ∆I , we have ⊥(w) ∈ I if and only if ⊥(δ(w)) ∈ J . Consequently, K is unsatisfiable if and only if DK |= ∃x.⊥(x).\nC Proofs of Lemmas 20 and 21 We prove Lemmas 20 and 21 in various stages. To start, we next show that mapping δ satisfies a slightly relaxed version of properties H1–H4 from Lemma 20. Lemma 22. Mapping δ satisfies the following four properties for all terms w1 and w2 occurring in I , each individual a ∈ NI , each role R ∈ NR, and each concept C ∈ NC ∪ {>,⊥}.\n(i) C(w1) ∈ I implies that ‖C(δ(w1))‖J ∈ J. (ii) R(w1, w2) ∈ I implies that ‖R(δ(w1), δ(w2))‖J ∈ J.\n(iii) R(w1, w2) ∈ I and w is of the form fA1P,A(w1) imply that ‖dR(δ(w1), δ(w2))‖J ∈ J . (iv) w1 a ∈ I implies that ‖δ(w1)‖J = ‖a‖J .\nProof. Let I0, I1, . . . be the chase for ΞK w.r.t. > used to construct I . We show by induction on this sequence that each In satisfies the properties.\nBase case. Consider chase instance I0. By the definition, I0 contains only ground atoms constructed using the predicates in NC ∪ {>,⊥, ind} ∪NR and the individuals in NI . Therefore, for each term w occurring in I0, we have ‖w‖I0 = w and w ∈ NI , and so δ(w) = w. Consider an arbitrary atom φ ∈ I0. By the definition of DK, φ is an atom in DK. Since J satisfies all ground atoms in DK, we have ‖φ‖J ∈ J , so properties (i)–(iv) hold.\nInductive step. Consider an arbitrary n ∈ N and assume that In satisfies properties (i)–(iv). By considering each rule in ΞK, we assume that the rule is applicable to In, and we show that the properties hold for all fresh atoms in the resulting instance.\n(Datalog Rule) Consider a datalog rule ϕ(~x, ~y)→ ψ(~x) in ΞK, and assume that a substitution σ with dom(σ) = ~x ∪ ~y exists such that σ(ϕ) ⊆ In. Let σ′ be the substitution such that σ′(x) = δ(σ(x)) for each variable x ∈ ~x ∪ ~y. By the inductive hypothesis, we have ‖σ′(ψ)‖J ⊆ J . Since ϕ(~x, ~y)→ ψ(~x) ∈ DK and no rule is applicable to J , we have ‖σ′(ψ)‖J ⊆ J .\n(Existential Rule) Consider A1(x)→ ∃z.R(x, z) ∧A(z) in ΞK, assume that A1(w1) ∈ In, and let w2 = ‖fA1R,A(w1)‖In . By the inductive hypothesis, ‖A1(δ(w1))‖J ∈ J holds. Program DK containsA1(x)→ R(x, oR,A) ∧ dR(x, oR,A) ∧A(oR,A) and no rule is applicable to J , so ‖R(δ(w1), oR,A) ∧ dR(δ(w1), oR,A) ∧A(oR,A)‖J ⊆ J holds. We distinguish two cases.\n• w2 = fA1R,A(w1). Then, δ(w2) = oR,A, and so ‖oR,A‖J = ‖δ(w2)‖J . • w2 6= fA1R,A(w1). By the form of equality rules in ΞK and due to w2 = ‖f A1 R,A(w1)‖In , we have w2 ∈ NI . Then, terms\nu0, . . . , un with u0 = fA1R,A(w1) and un = w2 exist in In such that ui−1 ui ∈ In for each i ∈ [1, n]. By the inductive hypothesis, we have ‖δ(fA1R,A(w1))‖J = ‖δ(w2)‖J , and so ‖oR,A‖J = ‖δ(w2)‖J .\nAs stated above, we have ‖R(δ(w1), oR,A) ∧ dR(δ(w1), oR,A) ∧A(oR,A)‖J ⊆ J , so properties (i)–(iii) are satisfied. (Equality Rule) Consider a rule A(x)→ x ≈ a in ΞK and assume that A(w1) ∈ In. As w1 ∈ ∆In , we have ‖w1‖In = w1. Then let terms w and w′ be such that {w,w′} = {w1, ‖a‖In} and w > w′. By the inductive hypothesis, we either have ‖A(δ(w))‖J ∈ J and ‖δ(w′)‖J = ‖a‖J , or ‖A(δ(w′))‖J ∈ J and ‖δ(w)‖J = ‖a‖J . In either cases, since A(x)→ x ≈ a ∈ DK and no rule is applicable to J , we have ‖δ(w)‖J = ‖δ(w′)‖J , and property (iv) is satisfied. We next consider the atoms in In that get replaced by the application of this rule.\n• C(w) ∈ In. By the inductive hypothesis, we have ‖C(δ(w))‖J ∈ J ; thus ‖C(δ(w′))‖J ∈ J . • R(w,w) ∈ In. By the inductive hypothesis, we have ‖R(δ(w), δ(w))‖J ∈ J ; thus ‖R(δ(w′), δ(w′))‖J ∈ J . • R(w,w2) ∈ In. By the inductive hypothesis, we have ‖R(δ(w), δ(w2))‖J ∈ J ; thus ‖R(δ(w′), δ(w2))‖J ∈ J . • R(w2, w) ∈ In. By the inductive hypothesis, we have ‖R(δ(w2), δ(w))‖J ∈ J ; thus, ‖R(δ(w2), δ(w′))‖J ∈ J .\nWe next show that J satisfies a slightly relaxed version of properties D1–D7 from Lemma 21.\nLemma 23. Mapping δ satisfies the following properties for all terms w1 and w2 occurring in I , each individual a ∈ NI , each role R ∈ NR, and each concept C ∈ NC ∪ {>,⊥}. (a) C(δ(w1)) ∈ J implies that ‖C(w1)‖I ∈ I. (b) SelfR(δ(w1)) ∈ J implies that ‖R(w1, w1)‖I ∈ I. (c) R(δ(w1), δ(w2)) ∈ J and δ(w2) ∈ NI imply that ‖R(w1, w2)‖I ∈ I. (d) R(δ(w1), δ(w2)) ∈ J and δ(w2) is of the form oP,A imply that • a term w′1 from I exists such that ‖R(w′1, w2)‖I ∈ I, and • a term w′2 from I exists such that δ(w′2) = oP,A and ‖R(w1, w′2)‖I ∈ I. (e) dR(δ(w1), δ(w2)) ∈ J and δ(w2) is of the form oP,A imply that • a term w′3 from I of the form f A1 P,A(‖w1‖I) exists such that ‖P (w1, w′3)‖I ∈ I , and\n• P v∗T R. (f) δ(w1) a ∈ J implies that ‖w1‖I = ‖a‖I . (g) For each individual u occurring in J , a term w occurring in I exists such that δ(w) = u.\nProof. Let J0, J1, . . . be the chase for DK used to construct J . We prove by induction on this sequence that each Jn satisfies the properties.\nBase case. Consider J0. By the definition, J0 does not contain assertions over . Moreover, DK and ΞK contain the same ground atoms, all of which are constructed using the individuals fromNI and the predicates inNC ∪ {>,⊥, ind} ∪NR. Finally, I satisfies all the ground atoms in ΞK, so properties (a)–(g) are satisfied.\nInductive step. Consider an arbitrary n ∈ N and assume that Jn satisfies properties (a)–(g). By considering each rule in DK, we assume that the rule is applicable to Jn, and we show that the properties hold for all fresh atoms in the resulting instance.\nConsider a rule of the form SelfP (x) → SelfR(x) in DK and assume that SelfP (δ(w1)) ∈ Jn. By the inductive hypothesis, we have ‖SelfP (w1) ∧ P (w1, w1)‖I ⊆ I . By the definition of program DK and ΞK, we have P v R ∈ T , and so rules SelfP (x)→ SelfR(x) and P (x, y)→ R(x, y) are in ΞK. Since no rule is applicable to I , we have ‖SelfR(w1) ∧R(w1, w1)‖I ⊆ I .\nConsider a rule of the form ϕ(x) → B(x) in DK with ϕ a conjunction of unary atoms over variable x and B a concept. Let σ and σ′ be substitutions such that σ(x) = δ(w1) and σ′(x) = w1. Assume that σ(ϕ) ⊆ Jn. By the inductive hypothesis, we have ‖σ′(ϕ)‖I ⊆ I . Since no rule is applicable to I , we have ‖B(w1)‖I ∈ I .\nConsider a rule of the formA(x)→ x ≈ a and assume thatA(δ(w1)) ∈ Jn. As δ(w1) ∈ ∆Jn , we have ‖δ(w1)‖Jn = δ(w1). Let w and w′ be terms such that {δ(w), δ(w′)} = {δ(w1), ‖a‖Jn} and δ(w) > δ(w′). By the inductive hypothesis, we either have ‖A(w)‖I ∈ I and ‖w′‖I = ‖a‖I , or ‖A(w′)‖I ∈ I and ‖w‖I = ‖a‖I . In either cases, since no rule is applicable to I , we have ‖w‖I = ‖w′‖I . We next consider the atoms in Jn that get replaced by the application of this rule.\n• SelfR(δ(w)) ∈ Jn. By the inductive hypothesis, we have ‖SelfR(w) ∧R(w,w)‖I ⊆ I; so ‖SelfR(w′) ∧R(w′, w′)‖I ⊆ I . • C(δ(w)) ∈ Jn. By the inductive hypothesis, we have ‖C(w)‖I ∈ I , and so ‖C(w′)‖I ∈ I . • R(δ(w), δ(w)) ∈ Jn. We distinguish two cases.\n– δ(w) ∈ NI . By the inductive hypothesis, we have ‖R(w,w)‖I ∈ I , and so ‖R(w′, w′)‖I ∈ I . – δ(w) is of the form oP,A. By the inductive hypothesis, a term w′2 exists such that δ(w′2) = oP,A and ‖R(w,w′2)‖I ∈ I .\nSince δ(w′2) = δ(w), we have ‖w′2‖I = ‖w′‖I , and so ‖R(w′, w′)‖I ∈ I . • R(δ(w2), δ(w)) ∈ Jn. We distinguish two cases.\n– δ(w) ∈ NI . By the inductive hypothesis, we have ‖R(w2, w)‖I ∈ I , and so ‖R(w2, w′)‖I ∈ I .\n– δ(w) is of the form oP,A. By the inductive hypothesis, a term w′2 exists such that δ(w′2) = oP,A and ‖R(w2, w′2)‖I ∈ I . Since δ(w′2) = δ(w), we have ‖w′2‖I = ‖w′‖I , and so ‖R(w2, w′)‖I ∈ I . • R(δ(w), δ(w2)) ∈ Jn. We distinguish two cases. – δ(w2) ∈ NI . By the inductive hypothesis, ‖R(w,w2)‖I ∈ I , thus ‖R(w′, w2)‖I ∈ I . – δ(w2) is of the form oP,A. By the inductive hypothesis, a term w′2 with δ(w′2) = oP,A exists such that ‖R(w,w′2)‖I ∈ I ,\nand so ‖R(w′, w′2)‖I ∈ I . • dR(δ(w), δ(w2)) ∈ Jn and δ(w2) is of the form oP,A. Property (e) is satisfied by the inductive hypothesis.\nConsider a rule of the form R(x, y) ∧ A1(y) → A(x) in DK and assume that {R(δ(w1), δ(w2)), A1(δ(w2))} ⊆ Jn. We distinguish two cases.\n• δ(w2) ∈ NI . By the inductive hypothesis, we have ‖R(w1, w2)‖I ⊆ I . • δ(w2) = oP,A. By the inductive hypothesis, a term w′2 exists such that δ(w′2) = oP,A and ‖R(w1, w′2) ∧A(w′2)‖I ∈ I .\nIn either cases, since no rule is applicable to I , we have ‖A(w1)‖I ∈ I . Consider a rule T (x, y)→ R(x, y) in DK and assume that T (δ(w1), δ(w2)) ∈ Jn. We distinguish two cases.\n• δ(w2) ∈ NI . By the inductive hypothesis, ‖T (w1, w2)‖I ∈ I . As no rule is applicable to I , we have ‖R(w1, w2)‖I ∈ I . • δ(w2) is of the form oP,A. By the inductive hypothesis, terms w′1 and w′2 exist such that δ(w′2) = oP,A and ‖T (w1, w′2) ∧ T (w′1, w2)‖I ⊆ I . Since no rule is applicable to I , we have ‖R(w1, w′2) ∧R(w′1, w2)‖I ⊆ I .\nConsider a rule dT (x, y) → dR(x, y) in DK and assume that dT (δ(w1), δ(w2)) ∈ Jn and δ(w2) is of the form oP,A. By the inductive hypothesis, a term w3 of the form fA1P,A(‖w1‖I) exists such that ‖P (w1, w′3)‖I ∈ I and P v∗T T . By the definition of DK, we have T v R ∈ T . Consequently, we have P v∗T R ∈ T and property (e) holds.\nConsider a rule R(x, y)→ A(y) in DK, and assume that R(δ(w1), δ(w2)) ∈ Jn.\n• δ(w2) ∈ NI . By the inductive hypothesis, we have ‖R(w1, w2)‖I ⊆ I . • δ(w2) is of the form oP,A. By the inductive hypothesis, a term w′1 exists such that ‖R(w′1, w2)‖I ∈ I .\nIn either cases, since no rule is applicable to I , we have ‖A(w2)‖I ∈ I . Consider a ruleA1(x)→ R(x, oR,A)∧dR(x, oR,A)∧A(oR,A) in DK, and assume thatA(δ(w1)) ∈ Jn. Letw2 be a term such that δ(w2) = ‖oR,A‖Jn . By the inductive hypothesis, we have ‖A(w1)‖I ∈ I . By the definition of DK, rule base ΞK contains A1(x)→ ∃z.R(x, z) ∧A(z). Let w′3 = f A1 R,A(‖w1‖I). Since no rule is applicable to I , we have ‖R(w1, w′3) ∧A(w′3)‖I ⊆ I . We distinguish two cases.\n• δ(w2) 6= oR,A. By the form of equality rules occurring in DK, we have δ(w2) ∈ NI . Then individuals u0, . . . , un with u0 = oR,A and un = δ(w2) exist such that ui−1 ui ∈ Jn for each i ∈ [1, n]. Moreover, given that δ(w′3) = oR,A, by the inductive hypothesis, we have ‖w′3‖I = ‖w2‖I . Hence, we have ‖R(w1, w2) ∧A(w2)‖I ⊆ I . By the inductive hypothesis, property (g) is satisfied.\n• δ(w2) = oR,A. Then w2 is of the form fA2R,A(w′). Because such term can only be introduced in I by the application of a rule of the form A2(x)→ ∃z.R(x, z) ∧A(z), a term w′1 must exist such that ‖R(w′1, w2) ∧A(w2)‖I ⊆ I . As stated above, we also have ‖R(w1, w′3)‖I ∈ I . By the reflexivity of v∗T , we also have R v∗T R, so properties (d) and (e) are satisfied. As δ(w′3) = oR,A, property (g) is also satisfied.\nConsider a rule R(x, y) ∧R(y, z)→ R(x, z), and assume {R(δ(w1), δ(w2)), R(δ(w3), δ(w4))} ⊆ Jn and δ(w2) = δ(w3). It follows that R(δ(w2), δ(w4)) ∈ Jn. We distinguish four cases.\n• δ(w2) ∈ NI and δ(w4) ∈ NI . By the inductive hypothesis, we have ‖R(w1, w2) ∧R(w2, w4)‖I ∈ I . Since no rule is applicable to I , we have ‖R(w1, w4)‖I ∈ I . • δ(w2) is of the form oP,A and δ(w4) ∈ NI . By the inductive hypothesis, a term w′2 exists such that δ(w′2) = oP,A and ‖R(w1, w′2)‖I ∈ I . Due to δ(w′2) = δ(w2), we have ‖R(δ(w′2), δ(w4))‖Jn ∈ Jn. By the inductive hypothesis, we have ‖R(w′2, w4)‖I ∈ I . Since no rule is applicable to I , we have ‖R(w1, w4)‖I ∈ I . • δ(w2) ∈ NI and δ(w4) is of the form oR,B . By the inductive hypothesis, we have ‖R(w1, w2)‖I ∈ I and terms w′2 and w′4 exist such that δ(w′4) = oR,B and ‖R(w′2, w4) ∧R(w2, w′4)‖I ⊆ I . As no rule is applicable to I , we have ‖R(w1, w′4)‖I ∈ I . • δ(w2) is of the form oP,A and δ(w4) is of the form oR,B . By the inductive hypothesis, a termw′2 exists such that δ(w′2) = oP,A and ‖R(w1, w′2)‖I ∈ I . Due to δ(w′2) = δ(w2), we have ‖R(δ(w′2), δ(w4))‖Jn ∈ Jn. By the inductive hypothesis, terms u′2 and w ′ 4 exist such that δ(w ′ 4) = oR,B and ‖R(u′2, w4) ∧R(w′2, w′4)‖I ⊆ I . As no rule is applicable to I , we have\n‖R(w1, w′4)‖I ∈ I .\nConsider a rule A(x)→ R(x, x)∧ SelfR(x), assume A(δ(w1)) ∈ Jn, and let w2 be a term such that δ(w2) = δ(w1). By the inductive hypothesis, we have ‖A(w1)∧A(w2)‖I ⊆ I . Since no rule is applicable to I , we have ‖R(w1, w1) ∧ SelfR(w1)‖I ⊆ I and ‖R(w2, w2) ∧ SelfR(w2)‖I ⊆ I , so property (a) holds. We distinguish two cases.\n• δ(w2) ∈ NI . Then individuals u0, . . . , un with u0 = δ(w1) and un = δ(w2) exist such that ui−1 ui ∈ Jn for each i ∈ [1, n]. By the inductive hypothesis, we have, ‖w1‖I = ‖w2‖I ; thus ‖R(w1, w2)‖I ∈ I .\n• δ(w2) is of the form oP,A. Thus, δ(w1) = oP,A. As stated above, we have ‖R(w1, w1) ∧R(w2, w2)‖I ⊆ I .\nConsider a rule R(x, x) ∧ ind(x) → SelfR(x). Assume that {R(δ(w1), δ(w2)), ind(δ(w2))} ⊆ Jn and δ(w2) = δ(w1). By the definition of clsK and since no rule in DT derives atoms over ind, we have that δ(w2) ∈ NI . By the inductive hypothesis, we then have ‖R(w1, w2) ∧ ind(w2)‖I ⊆ I . Since δ is the identity on NI and δ(w1) = δ(w2), we have w1 = w2, and so ‖R(w1, w1) ∧R(w2, w2)‖I ⊆ I . As no rule is applicable to I , we have ‖SelfR(w1) ∧ SelfR(w2)‖I ⊆ I .\nLemmas 20 and 21 follow immediately from Lemmas 22 and 23, and the following result.\nLemma 24. For each term w occurring in I and each individual a ∈ NI , the following two properties hold."
    }, {
      "heading" : "E1. ‖w‖I = a if and only if ‖δ(w)‖J = a.",
      "text" : ""
    }, {
      "heading" : "E2. ‖w‖I = w if and only if ‖δ(w)‖J = δ(w).",
      "text" : "Proof. By the definition of ΞK and DK, each equality rule occurring in these rule bases is of the form A(x) → x ≈ a with a ∈ NI . Consequently, for all terms u and u′ such that u u′ ∈ I ∪ J , we have u′ ∈ NI . Let w be an arbitrary term occurring in I , and let a ∈ NI be an arbitrary individual.\nWe first prove E1. (⇒) Assume that ‖w‖I = a. Then terms w0, . . . , wn with w0 = w and wn = a exist such that for each i ∈ [1, n] we have wi ∈ NI and wi−1 wi ∈ I . By Lemma 22, we have ‖δ(w0)‖J = ‖δ(wn)‖J ; that is, ‖δ(w)‖J = ‖a‖J . We show that ‖a‖J = a. Assume the opposite; hence, an individual b exists such that a b ∈ J and a > b. By Lemma 23, we have ‖a‖I = ‖b‖I . Since a > b, we have ‖w‖I = b, which is a contradiction. (⇐) Assume that ‖δ(w)‖I = a. Then individuals u0, . . . , un with u0 = δ(w) and un = a exist such that for each i ∈ [1, n] we have ui ∈ NI and ui−1 ui ∈ I . By Lemma 23, we have ‖w‖I = ‖a‖I . We show that ‖a‖I = a. Assume the opposite; hence, an individual b exists such that a b ∈ I and a > b. By Lemma 22, we have ‖a‖J = ‖b‖J . Since a > b, we have ‖δ(w)‖I = b, which is a contradiction.\nNext, we prove property E2 by contraposition. (⇒) Assume that ‖δ(w)‖J 6= δ(w); hence, an individual b ∈ NI exists such that δ(w) 6= b and ‖δ(w)‖J = b. By the definition of δ, we have w 6= b. By property E1, we have ‖w‖I = b, as required. (⇐) Assume that ‖w‖I 6= w; hence, an individual b ∈ NI exists such that w 6= b and ‖w‖I = b. By the definition of δ, we have δ(w) 6= b. By property E1, we have ‖δ(w)‖I = b, as required.\nD Proof of Theorem 12 Let KB K = 〈T ,A〉 be a satisfiable ELHOs KB, let ΞK, and DK be the rule base and the datalog program associated with K, respectively; moreover, let I and J be universal interpretations of ΞK and DK, respectively. To prove Theorem 12, we first show that our function is sound, after which we show that it is also complete."
    }, {
      "heading" : "D.1 Soundness",
      "text" : "Let q′ = ∃~y. ψ(~x, ~y) be a CQ, let τ ′ be a candidate answer to q′ over DK, and let π′ = τ ′|~x. Assume that the two following conditions hold:\n1. for each x ∈ ~x, we have τ ′(x) ∈ NI , and 2. a nondeterministic computation exists such that function isSound(q,DK, τ) returns t.\nBy the definition of candidate answer, we have dom(τ ′) = NV (q′), each element of rng(τ ′) is an individual occurring in DK, and DK |= τ ′(q′). Since τ ′|~x ⊆ NI , we have that π′(x) ∈ NI for each x ∈ ~x. In the rest of this proof we show that ΞK |= π′(q′).\nLet CQ q and substitution τ be as specified in Definition 4; and let relation ∼, CQ q∼ and the connection graph cg = 〈V,Es, Et〉 be as determined by isSound. By the construction of q and τ , we have DK |= τ(q) and τ(q) ⊆ J . We next construct a substitution π with dom(π) = NV (q) such that π(q) ⊆ I and the following property holds. (1) For each term t ∈ NT (q), we have δ(π(t)) = τ(t). Later, we will show that property (1) and π(q) ⊆ I imply that ΞK |= π′(q′), thus proving the soundness claim.\nTo construct substitution π, we proceed in two steps: we first show how to construct π in case our algorithm returns t in step 2; after which we show how to construct π in case our algorithm returns t in step 18.\nCase 1: isSound returns t in step 2 Assume that isSound(q,DK, τ) returns t in step 2. By condition 2 in Definition 8, directed graph 〈V,Es〉 is acyclic; we next show that 〈V,Es〉 is a forest, after which we will show how to construct substitution π by structural induction on this forest.\nLemma 25. Directed graph 〈V,Es〉 is a forest.\nProof. Since directed graph 〈V,Es〉 is acyclic, we are left to show that for each v ∈ V , there exists at most one vertex v′ such that 〈v′, v〉 ∈ Es. Assume the opposite; hence, vertices v1, v2, and v exist in V such that v1 6= v2 and {〈v1, v〉, 〈v2, v〉} ⊆ Es. Then, roles R and P exist such that R(v1, v) and P (v2, v) are aux-simple atoms in q∼ and τ(v) ∈ auxDK . By the definition of ∼, we have v1 ∼ v2; and, by the construction of q∼, we have v1 = v2, which is a contradiction.\nWe next construct substitution π with dom(π) = NV (q) that will satisfy (1) and the two following properties:\n(2) for all terms s, t ∈ NT (q) such that s ∼ t, we have π(s) = π(t), and (3) for each 〈v′, v〉 ∈ Es with τ(v) of the form oP,A, we have P (π(v′), π(v)) ∈ I . By construction of V , we have that V = NT (q∼). Next, we define π by structural induction on the forest 〈V,Es〉 as follows.\nBase case. Consider a root v ∈ V . Fix an arbitrary term w ∈ ∆I such that δ(w) = τ(v). For each term s ∈ NT (q) with s ∼ v, let π(s) = w. By condition 1 in Definition 8, we have τ(s) = τ(v). Thus property (1) and (2) hold.\nInductive step. Consider an arbitrary 〈v′, v〉 ∈ Es with π(v′) defined and π(v) undefined. By the definition of Es, a role R ∈ NR exists such that R(v′, v) is an aux-simple atom in q∼. Hence, we have dR(τ(v′), τ(v)) ∈ J and τ(v) is of the form oP,A. Since by property (1) we have δ(π(v′)) = τ(v′), and due to property D5 in Lemma 21, a term w ∈ ∆I exists such that P (π(v′), w) ∈ I . Then, for each term s ∈ NT (q) with s ∼ v, let π(s) = w. Properties (2) and (3) immediately hold. By condition 2 in Definition 8, we have τ(s) = τ(v), and so property (1) holds.\nWe next show that substitution π is such that π(q) ⊆ I . Lemma 26. Substitution π satisfies π(q) ⊆ I .\nProof. Recall that τ(q) ⊆ J and isSound(q,DK, τ) returns t in step 2; we next show that π(q) ⊆ I . Consider an atom A(s) in q. By assumption, we have A(τ(s)) ∈ J . By Lemma 21, for each w ∈ ∆I with δ(w) = τ(s), we have A(w) ∈ I . By property (1) in the definition of π, we have A(π(s)) ∈ I . Consider an atom R(s′, t′) in q. By the definition of q∼, an atom R(s, t) occurs in q∼ such that s′ ∼ s and t′ ∼ t. By condition 1 in the definition of isDSound, we have τ(s′) = τ(s) and τ(t′) = τ(t). By assumption, we have R(τ(s′), τ(t′)) ∈ J and so R(τ(s), τ(t)) ∈ J . By property (2) in the definition of π, it suffices to show that R(π(s), π(t)) ∈ I . Given that our algorithm returns t in step 2, exactly one of the following holds. R(s, t) is such that τ(t) ∈ NI . By Lemma 21, for all terms w′, w ∈ ∆I with δ(w′) = τ(s) and δ(w) = τ(t), we have R(w′, w) ∈ I . By property (1) in the definition of π, we have R(π(s), π(t)) ∈ I . R(s, t) is such that s = t, τ(t) ∈ auxDK , and SelfR(τ(t)) ∈ J . By Lemma 21, for each term w ∈ ∆I with δ(w) = τ(t), we have R(w,w) ∈ I . By property (1) in the definition of π, we have R(π(t), π(t)) ∈ I . R(s, t) is aux-simple. It follows that τ(t) is of the form oP,A and dR(τ(s), τ(t)) ∈ J . By property D5 of Lemma 21, we have P v∗T R. By the definition of Es, we have 〈s, t〉 ∈ Es. By property (3) in the definition of π, we have P (π(s), π(t)) ∈ I . Since no rule is applicable to I and P v∗T R, we have R(π(s), π(t)) ∈ I .\nCase 2: isSound returns t in step 18 We are left to show that, if our function returns t in step 18, then a substitution π with dom(π) = NV (q) exists such that π(q) ⊆ I and property (1) is satisfied.\nAssume that isSound(q,DK, τ) returns t in step 18. Let variable renaming σ, skeleton S = 〈V, E〉, and function L be as determined by isSound. By the definition of a skeleton for q and σ, graph S is a forest rooted in V ∩ indDK . We next define substitution π that will satisfy property (1) as well as the following properties:\n(2) for all terms s, t ∈ NT (q) such that s ∼ t or σ(s) = t, we have π(s) = π(t), (3) for each 〈v′, v〉 ∈ E and each role P ∈ L(v′, v), we have P (π(v′), π(v)) ∈ I . By the definition of V , we have V = NT (σ(q∼)). Next, we define π by structural induction on the forest S as follows.\nBase case. Consider a root v ∈ V ∩ indDK . Given that each element in rng(σ) is a variable, no term s ∈ NT (q) exists such that σ(s) = v. Then, for each term s ∈ NT (q) with s ∼ v, let π(s) = v. By condition 1 in Definition 8, we have τ(s) = τ(v). Thus, properties (1) and (2) are satisfied.\nInductive step. Consider 〈v′, v〉 ∈ E such that π(v′) has been defined, but π(v) has not; and let u0 = τ(v′) and w0 = π(v′). By the definition of exist, individuals {u1, . . . , un} ⊆ auxDK with n > 0 and un = τ(v) exist such that for each i ∈ [1, n], we have ui is of the form oTi,Ai , and dPj (ui−1, ui) ∈ J for each Pj ∈ L(v′, v). Then, for each i ∈ [1, n], by property D5 of Lemma 21, a term wi of the form fBiTi,Ai(wi−1) exists in ∆ I such that Ti(wi−1, wi) ∈ I; moreover, Ti v∗T Pj for each role\nPj ∈ L(v′, v). Since no rule is applicable to I and Ti v∗T Pj , we have Pj(wi−1, wi) ∈ I . For each term s ∈ NT (q) such that s ∼ v or σ(s) = v, let π(s) = wn. Property (2) is clearly satisfied. Property (1) is also satisfied, since σ(s) = v implies that τ(s) = τ(v), by construction of σ, and s ∼ v implies that τ(s) = τ(v), by condition 1 in Definition 8. For property (3) we distinguish two cases.\n• A role P ∈ L(v′, v) exists such that trans(P ) 6∈ T . By the definition of function exist, we then have n = 1. Consequently, π(v′) = w0 and π(v) = w1; thus, Pj(π(v′), π(v)) ∈ I for each Pj ∈ L(v′, v).\n• For each Pj ∈ L(v′, v) we have trans(Pj) ∈ T . Since no rule is applicable and Pj(wi−1, wi) ∈ I for each i ∈ [1, n], we have Pj(w0, wn) ∈ I; that is, Pj(π(v′), π(v)) ∈ I .\nWe next show that substitution π is such that π(q) ⊆ I . Lemma 27. Substitution π satisfies π(q) ⊆ I .\nProof. We show that π(q) ⊆ I by considering the various atoms occurring in q. Consider an atom A(s) in q. By assumption, we have A(τ(s)) ∈ J . By Lemma 21, for each w ∈ ∆I with δ(w) = τ(s), we have A(w) ∈ I . By property (1) in the definition of π, we have A(π(s)) ∈ I . Consider an atom R(s′, t′) in q. By assumption, we have R(τ(s′), τ(t′)) ∈ J . By the definition of q∼, terms s′′ and t′′ occur in q∼ such that s′ ∼ s′′, t′ ∼ t′′, and R(s′′, t′′) is an atom in q∼. By condition 1 in the definition of isDSound, we have τ(s′) = τ(s′′) and τ(t′) = τ(t′′). Therefore, R(τ(s′′), τ(t′′)) ∈ J . By the definition of σ(q∼), terms s and t occur in σ(q∼) such that σ(s′′) = s, σ(t′′) = t, and R(s, t) is an atom in σ(q∼). By the definition of variable renaming, we have τ(t′′) = τ(t) and τ(s′′) = τ(s). Thus R(τ(s), τ(t)) ∈ J . By property (2) in the definition of π, it suffices to show that R(π(s), π(t)) ∈ I . Towards this goal, we consider four distinct cases.\nR(s, t) is such that τ(t) ∈ NI . By Lemmas 21, for all terms w′, w ∈ ∆I with δ(w′) = τ(s) and δ(w) = τ(t), we have R(w′, w) ∈ I . By property (1) in the definition of π, we have R(π(s), π(t)) ∈ I . R(s, t) is such that s = t, τ(t) ∈ auxDK , and SelfR(τ(t)) ∈ J . By Lemma 21, for each term w ∈ ∆I with δ(w) = τ(t) , we have ‖R(w,w)‖I ∈ I . By property (1) in the definition of π, we have R(π(t), π(t)) ∈ I . R(s, t) is aux-simple. By the definition of Es and E , we have 〈s, t〉 ∈ σ(Es)∩ E , and R ∈ L(s, t) by step 6. By property (3) in the definition of π, we have R(π(s), π(t)) ∈ I . R(s, t) is neither good nor aux-simple. Let P and v0, . . . , vn be as determined in steps 8–15 when Algorithm 1 considers atom R(s, t). Then by step 8 we have P v∗T R. Furthermore, for each i ∈ [1, n], we have P ∈ L(vi−1, vi) by step 15; but then, by property (3) we have P (π(vi−1), π(vi)) ∈ I . Next, we distinguish two cases.\n• s reaches t in E . If 〈s, t〉 ∈ E , then n = 1 and, by property (3) in the definition of π, we have P (π(s), π(t)) ∈ I . Otherwise, we have trans(P ) ∈ T and, since no rule is applicable to I , we have P (π(s), π(t)) ∈ I . • s does not reach t in E . Then, we have trans(P ) ∈ T , v0 = at, and P (τ(s), v0) ∈ J . As v0 ∈ NI and π(v0) = v0, by Lemma\n21, we have P (π(s), π(v0)) ∈ I . Due to trans(P ) ∈ T and no rule is applicable to I , we have ‖P (π(s), π(t))‖I ∈ I .\nSince P v∗T R and no rule is applicable to I we have R(π(s), π(t)) ∈ I .\nFinally, we prove the soundness claim.\nLemma 28. Substitution π′ satisfies ΞK |= π′(q′).\nProof. To prove the lemma, we show that a substitution π′∗ with dom(π ′ ∗) = NV (q ′) exists such that π′ ⊆ π′∗ and ‖π′∗(q′)‖I ⊆ I . By the construction of q and τ , we have DK |= τ(q) and τ(q) ⊆ J . Let π be the substitution specified just above Lemma 26, if isSound(q,DK, τ) returns t in step 2, otherwise, let π be the substitution specified just above Lemma 27. By Lemmas 26 and 27, we have π(q) ⊆ I; furthermore, π satisfies property (1). Let γ be the mapping from NT (q′) to NT (q) such that q is obtained by replacing each t ∈ NT (q′) with γ(t).\nLet π′∗ be the substitution such that for each z ∈ NV (q′), we have π′∗(z) = π(z), if γ(z) = z; otherwise, we define π′∗(z) as an arbitrary term w occurring in I such that δ(w) = τ ′(z). Since π satisfies property (1) and by construction π′∗, for each term t ∈ NT (q′), we have δ(π′∗(t)) = τ ′(t). Since τ ′(x) ∈ NI for each x ∈ ~x and given that δ is the identity on NI , we have π′ ⊆ π′∗. To prove that ‖π′∗(q′)‖I ⊆ I , we show that for each term t ∈ NT (q′), we have ‖π′∗(t)‖I = π(γ(t)). The property clearly holds for each term t ∈ NT (q′) such that γ(t) = t. Then consider an arbitrary term t ∈ NT (q′) such that γ(t) 6= t. By the definition of γ, we have γ(t) = ‖τ ′(t)‖J and γ(t) ∈ NI . By Lemma 24, for each term w occurring in I with δ(w) = τ ′(t), we have ‖w‖I = γ(t). By the definition of π′∗, we then have ‖π′∗(t)‖I = γ(t) = π(γ(t))."
    }, {
      "heading" : "D.2 Completeness",
      "text" : "To prove the completeness claim, we start by establishing two properties of the universal interpretation I . To this end, we start with a couple of definitions.\nLet ≺ be the smallest irreflexive and transitive relation on the set of terms occurring in I such that w ≺ fA1R,A(w) for each term occurring in I , each role R, and all concepts A,A1 ∈ {>} ∪NC . Furthermore, an atom R(w′, w) ∈ I is a self-loop if w′ = w and SelfR(w) ∈ I . Lemma 29. Interpretation I satisfies the following properties for each role R ∈ NR and all terms w′, w ∈ ∆I with w 6∈ NI ."
    }, {
      "heading" : "1. R(w′, w) ∈ I is not a self-loop and R is simple imply that w is of the form fA1T,A(w′).",
      "text" : "2. R(w′, w) ∈ I is not a self-loop implies that a role P ∈ NR and terms w0, . . . , wm from ∆I with wm = w exist where\n2a. if m > 1 or w′ 6≺ w, then trans(P ) ∈ T , 2b. P v∗T R, 2c. w0 = w′, if w′ ≺ w; otherwise, w0 is the unique individual a ∈ NI with a ≺ w, and P (w′, w0) ∈ I , and 2d. for each i ∈ [1,m], wi is of the form fBiSi,Ai(wi−1) and P (wi−1, wi) ∈ I .\nProof. Let I0, I1, . . . be the chase sequence used to construct I . Please observe that, by virtue of the pruning step in the application of equality rules, for each term w occurring in I of the form w = fA1T,A(w\n′) we either have ‖w‖I = a for some individual a ∈ NI , or ‖w′‖I = w′ and ‖w‖I = w. Then to prove the lemma, we show by induction on this sequence that each In satisfies the following properties for each role R ∈ NR and all terms w′ and w occurring in I such that w 6∈ NI .\nA. R(w′, w) ∈ In is not a self-loop and R is simple imply that w is of the form fA1T,A(w′). B. R(w′, w) ∈ In is not a self-loop implies that a role P ∈ NR and terms w0, . . . , wm from I with wm = w exist where\n(i) if m > 1 or w′ 6≺ w, then trans(P ) ∈ T , (ii) P v∗T R,\n(iii) w0 = w′, if w′ ≺ w; otherwise, w0 is the unique individual a ∈ NI with a ≺ w, and ‖P (w′, w0)‖I ∈ I , and (iv) for each i ∈ [1,m], wi is of the form fB1Si,Ai(wi−1) and ‖P (wi−1, wi)‖I ∈ I .\nBase case. Consider I0. All atoms in I0 are over the individuals in NI , so properties A and B hold vacuously. Inductive step. Consider an arbitrary n ∈ N and assume that In satisfies properties A and B. By considering each rule in ΞK that derives binary atoms, we assume that the rule is applicable to In, and we show that the properties hold for all fresh atoms in the resulting instance.\nConsider a rule A1(x) → ∃z.R(x, z) ∧ A(z), and assume that A1(w′) ∈ In. Furthermore, let w = fA1R,A(w′), and assume that w′ and w occur in I . Clearly, if ‖w‖In = a for some individual a ∈ NI , then the properties hold vacuously; hence we consider the case in which ‖w‖In = w. Please note that w′ ≺ w. Since w′ occurs in I , we have ‖A1(w′)‖I ∈ I . As no rule is applicable to I , we have ‖R(w′, w)‖I ∈ I . Property A holds, and property B is satisfied for role R and terms w0 = w′ and w1 = w.\nConsider a rule A(x) → x ≈ a, and assume that A(u) ∈ In. Let u′ and w′ be terms occurring in I such that {u′, w′} = {‖u‖In , ‖a‖In} and u′ > w′. By the definition of >, we have w′ ∈ NI . Since u occurs in I , we have ‖A(u)‖I ∈ I . Since no rule is applicable to I , we have ‖u′‖I = ‖w′‖I . We next show that the properties are preserved for all atoms in In that get replaced by the application of this rule. Please observe that the properties hold vacuously for each atom R(w, u′) ∈ In and each atom R(u′, b) ∈ In with b ∈ NI . Then consider an atom R(u′, w) ∈ In with w 6= u′ and w 6∈ NI . Then R(u′, w) ∈ In is not a self-loop. Since this atom is replaced, not removed, by the application of the rule, we must have that u′ 6≺ w. Let c ∈ NI be the unique individual such that c ≺ w. By the inductive hypothesis, a role P ∈ NR and terms w0, . . . , wm with w0 = c and wm = w exist satisfying properties (i)–(iv). Then ‖P (u′, w0)‖I ∈ I , trans(P ) ∈ T , and P v∗T R. Role R is not simple, thus property A holds. We next distinguish two cases.\n• w′ ≺ w. Since w′ ∈ NI , we have w′ = w0. Then role P and terms w0, . . . , wm satisfy properties (i)–(iv). • w′ 6≺ w. As stated above, we have trans(P ) ∈ T and ‖P (u′, w0)‖I ∈ I . Thus, ‖P (w′, w0)‖I ∈ I , and role P and terms w0, . . . , wm satisfy properties (i)–(iv).\nConsider a rule T (x, y) → R(x, y), and assume that T (w′, w) ∈ In is not a self-loop. For property A, assume that R is a simple role. Hence, T is a simple role as well, and property A follows from the inductive hypothesis. For property B, by the inductive hypothesis, a role P and terms w0, . . . , wm with wm = w exist satisfying (i)–(iv). By the definition of ΞK, we have T v R ∈ T . Since P v∗T T , we then have P v∗T R, and properties (i)–(iv) are satisfied.\nConsider a rule R(x, y) ∧ R(y, z) → R(x, z), and assume that {R(w′, w′′), R(w′′, w)} ⊆ In. Property A holds vacuously, as R is not simple. For property B, we distinguish four cases.\n• w′ ≺ w′′ and w′′ ≺ w. By the inductive hypothesis, a role P1 and terms w10, . . . , w1m1 with w 1 0 = w ′ and w1m1 = w ′′\nexist satisfying properties (i)–(iv); moreover, a role P2 and terms w20, . . . , w 2 m2 with w 2 0 = w ′′ and w2m2 = w exist satisfying properties (i)–(iv). Then, for j = 1, 2, we have Pj v∗T R. Furthermore, for each i ∈ [1,mj ], we have ‖Pj(wji−1, w j i )‖I ∈ I . As no rule is applicable to I , we have ‖R(w j i−1, w j i )‖I ∈ I . Then, property B is satisfied for role R and terms w10, . . . , w 1 m1 , w 2 1, . . . w 2 m2 .\n• w′ ≺ w′′ and w′′ 6≺ w. By the inductive hypothesis, a role P1 and terms w10, . . . , w1m1 with w 1 0 = w ′ and w1m1 = w ′′ exist\nsatisfying properties (i)–(iv). Let b ∈ NI be the unique individual such that b ≺ w. Sincew 6∈ NI , by the inductive hypothesis, a role P2 and terms w20, . . . , w 2 m2 with w 2 0 = b and w 2 m2 = w exist satisfying properties (i)–(iv). By property (iii), we have ‖P2(w1m1 , w 2 0)‖I ∈ I . Then, for j = 1, 2, we have Pj v∗T R. Moreover, for each i ∈ [1,mj ], we have ‖Pj(w j i−1, w j i )‖I ∈ I . As no rule is applicable to I , we have ‖R(wji−1, w j i )‖I ∈ I and ‖R(w1m1 , w 2 0)‖I ∈ I . Since trans(R) ∈ T and no rule is\napplicable to I , we have ‖R(w10, w20)‖I ∈ I . Property B is satisfied for role R and terms w20, . . . , w2m2 . • w′ 6≺ w′′ and w′′ ≺ w. By the inductive hypothesis, a role P2 and terms w20, . . . , w2m2 with w 2 0 = w\n′′ and w2m2 = w exist satisfying properties (i)–(iv). Then, we have P2 v∗T R. Furthermore, for each i ∈ [1,m2], we have ‖P2(w2i−1, w2i )‖I ∈ I . As no rule is applicable to I , we have ‖R(w2i−1, w2i )‖I ∈ I . We distinguish two cases. – w′′ ∈ NI . It follows that w20 = w′′. Then property B is satisfied for role R and terms w20, . . . , w2m2 . – w′′ 6∈ NI . Let a ∈ NI be the unique individual such that a ≺ w′′. By the inductive hypothesis, a role P1 and\nterms w10, . . . , w 1 m1 with w 1 0 = a and w 1 m1 = w ′′ exist satisfying properties (i)–(iv). Then, we have P1 v∗T R and ‖P1(w′, a)‖I ∈ I . Furthermore, for each i ∈ [1,m1], we have ‖P1(w1i−1, w1i )‖I ∈ I . As no rule is applicable to I , we have ‖R(w′, a)‖I ∈ I and ‖R(w1i−1, w1i )‖I ∈ I . Then the property is satisfied for role R and terms w20, . . . , w2m2 . • w′ 6≺ w′′ and w′′ 6≺ w. By assumption, we have w 6∈ NI . Let b ∈ NI be the unique individual such that b ≺ w. By the inductive hypothesis, a role P2 and terms w20, . . . , w 2 m2 with w 2 0 = b and w 2 m2 = w exist satisfying properties (i)–(iv). Then,\nwe have P2 v∗T R and ‖P2(w′′, w20)‖I ∈ I . Furthermore, for each i ∈ [1,m2], we have ‖P2(w2i−1, w2i )‖I ∈ I . As no rule is applicable to I , we have ‖R(w′′, w20)‖I ∈ I and ‖R(w2i−1, w2i )‖I ∈ I . We distinguish two cases. – w′′ ∈ NI . As stated above, we have ‖R(w′, w′′)‖I ∈ I and ‖R(w′′, w20)‖I ∈ I . Since trans(R) ∈ I and no rule is\napplicable to I , we have ‖R(w′, w20)‖I ∈ I . Then property B is satisfied for role R and terms w20, . . . , w2m2 . – w′′ 6∈ NI . Let a ∈ NI be the unique individual such that a ≺ w′′. By the inductive hypothesis, a role P1 and\nterms w10, . . . , w 1 m1 with w 1 0 = a and w 1 m1 = w ′′ exist satisfying properties (i)–(iv). Then, we have P1 v∗T R and ‖P1(w′, w10)‖I ∈ I . Furthermore, for each i ∈ [1,m1], we have ‖P1(w1i−1, w1i )‖I ∈ I . As no rule is applicable to I , we have ‖R(w′, w10)‖I ∈ I and ‖R(w1i−1, w1i )‖I ∈ I . Since trans(R) ∈ T and no rule is applicable to I , we have ‖R(w′, w20)‖I ∈ I . Property B is satisfied for role R and terms w20, . . . , w2m2 .\nLet q′ = ∃~y.ψ(~x, ~y) be a CQ and let π′ be a substitution such that dom(π′) = ~x and each element in rng(π′) is an individual from NI . Assume that ΞK |= π′(q′); we next show that a substitution τ ′ with dom(τ ′) = NV (q′) exists such that τ ′|~x = π′, each element in rng(τ ′) is an individual occurring in DK, and all of the following conditions hold:\n1. for each x ∈ ~x, we have τ ′(x) ∈ NI ,"
    }, {
      "heading" : "2. DK |= τ ′(q′), and",
      "text" : "3. a nondeterministic computation exists such that function isSound(q,DK, τ) returns t.\nSince ΞK |= π′(q), a substitution π′∗ with dom(π′∗) = NV (q′) exists such that π′ ⊆ π′∗ and ‖π′∗(q′)‖I ⊆ I . Let substitution τ ′ be such that, for each variable z ∈ NV (q′), we have τ ′(z) = δ(π′∗(z)). Since δ is the identity on NI and π′∗(x) ∈ NI for each x ∈ ~x, we have π′ ⊆ τ ′ and τ ′(x) ∈ NI . By Lemmas 20 and 24, we have ‖τ ′(q′)‖J ⊆ J , and so DK |= τ ′(q′). Hence, in the following, we show that property (3) holds.\nLet q and τ be as specified in Definition 4. Then, we have DK |= τ(q) and τ(q) ⊆ J . Let π∗ be the restriction of π′∗ to only those variables that occur in q. By the definition of τ and π∗, for each variable z ∈ NV (q), we have δ(π∗(z)) = τ(z). We next show that π∗(q) ⊆ I . Lemma 30. Substitution π∗ satisfies π∗(q) ⊆ I\nProof. Let π′∗ and π∗ be as specified above; furthermore, let γ be the mapping from NT (q ′) to NT (q) such that q is obtained by replacing each term t ∈ NT (q′) with γ(t). To prove that π∗(q) ⊆ I , we show that for each term t ∈ NT (q′), we have π∗(γ(t)) = ‖π′∗(t)‖I . We distinguish two cases.\n• Consider an arbitrary variable z ∈ NV (q′) such that τ ′(z) ∈ auxDK . Then γ(z) = z. By the definition of auxDK , for each individual u such that DK |= τ ′(z) ≈ u, we have u 6∈ NI and τ ′(z) = u; therefore, ‖τ ′(z)‖J = τ ′(z). But then, by the construction of τ ′ and by Lemma 24, we have ‖π′∗(z)‖I = π∗(z).\n• Consider an arbitrary term t ∈ NT (q′) such that τ ′(t) 6∈ auxDK . By the definition of q, we have γ(t) = ‖τ ′(t)‖J and γ(t) ∈ NI . By Lemma 24, for each term w occurring in I with δ(w) = τ ′(t), we have ‖w‖I = γ(t). By the definition of τ ′, we then have π(γ(t)) = γ(t) = ‖π′∗(t)‖I .\nLet relation ∼ and query q∼ be as specified in Definition 6; moreover, let connection graph cg = 〈V,Es, Et〉 be as specified in Definition 7. We next show that function isDSound(q,DK, τ) returns t.\nLemma 31. Function isDSound(q,DK, τ) returns t.\nProof. We next prove that isDSound(q,DK, τ) return t by showing that the two conditions of Definition 8 are satisfied. (Condition 1) We prove that, for each s ∼ t, we have τ(s) = τ(t) and π∗(s) = π∗(t). We proceed by induction on the number of steps required to derive s ∼ t. For the base case, the empty relation ∼ clearly satisfies the two properties. For the inductive step, consider an arbitrary relation ∼ obtained in n steps that satisfies these constraints; we show that the same holds for all constraints derivable from ∼. We focus on the (fork) rule, as the derivation of s ∼ t due to reflexivity, symmetry, or transitivity clearly preserves the required properties. Let s′1, s2, s ′ 2, and s2 be arbitrary terms inNT (q), and letR1 andR2 be arbitrary roles such that s′1 ∼ s′2 is obtained in n steps, atoms R1(s1, s′1) and R2(s2, s′2) occur in q and are aux-simple, and τ(s′2) ∈ auxDK . By the definition of τ , we have π(s′2) 6∈ NI . Moreover, by the definition of aux-simple atom, for i = 1, 2 we have si 6= s′i, role Ri is simple, and τ(si) = τ(s′i) implies that SelfRi(τ(s ′ i)) 6∈ J . By the inductive hypothesis, we have τ(s′1) = τ(s′2) and π∗(s ′ 1) = π∗(s ′ 2). By Lemma 20, atoms {R1(π∗(s1), π∗(s′1)), R2(π∗(s2), π∗(s′2))} ⊆ I are not self-loops. Moreover, since R1 and R2 are simple roles, by property 1 in Lemma 29, we have π∗(s1) = π∗(s2). Therefore, π′∗(s1) = π ′ ∗(s2). By the construction of τ ′, we have τ ′(s1) = τ ′(s2), and so τ(s1) = τ(s2). (Condition 2) We show that 〈V,Es〉 is a DAG. Assume the opposite; hence, vertices v0, . . . , vm ∈ V with vm = v0 exist such that m > 0 and 〈vi−1, vi〉 ∈ Es for each i ∈ [1,m]. By the definition of Es, we have Es ⊆ V × (V ∩NV (q)). Thus, for each i ∈ [0,m] we have vi 6∈ indDK , and so τ(vi) ∈ auxDK . Consider an arbitrary i ∈ [1,m] and the corresponding edge 〈vi−1, vi〉 ∈ Es. By the definition of Es, a role Ri exists such that Ri(vi−1, vi) is an aux-simple atom in q∼. By the definition of aux-simple atom, we have vi−1 6= vi, role Ri is simple, and τ(vi−1) = τ(vi) implies that SelfRi(τ(vi)) 6∈ J . By Lemma 20 and by the construction of τ , atom Ri(π∗(vi−1), π∗(vi)) ∈ I is not a self-loop. Since τ(vi) ∈ auxDK , we have π∗(vi) 6∈ NI . Then, by property 1 in Lemma 29, we have π∗(vi−1) ≺ π∗(vi). Thus, π∗(v0) ≺ π∗(vm) which contradicts vm = v0.\nWe are now ready to prove the completeness claim.\nLemma 32. A nondeterministic computation exists such that isSound(q,DK, τ) returns t.\nProof. Recall that π∗(q) ⊆ I and that τ(q) ⊆ J . By Lemma 31, the condition in step 1 in Algorithm 1 is not satisfied. If each binary atom R(s, t) occurring in q∼ is either good or aux-simple, then our algorithm returns t in step 2; hence, in the rest of this proof, we assume that this is not the case.\nFor the variable renaming σ in step 3, for each variable z ∈ V , let σ(z) be an arbitrary, but fixed, variable z′ ∈ V such that π∗(z) = π∗(z\n′). It is straightforward to see that π∗(σ(q∼)) ⊆ I . For the skeleton S = 〈V, E〉 in step 3, let V = σ(V ) and let E be the smallest set containing 〈v′, v〉 ∈ E for all v′, v ∈ V such that π∗(v′) ≺ π∗(v) and no vertex v′′ ∈ V exists such that π∗(v′) ≺ π∗(v′′) ≺ π∗(v). By the definition of ≺, graph 〈V, E〉 is a forest rooted in V ∩ indDK .\nWe next show that for each 〈v′, v〉 ∈ σ(Es), we have 〈v′, v〉 ∈ E . Consider an arbitrary edge 〈v′, v〉 ∈ σ(Es). Then vertices u′ and u exist in V such that 〈u′, u〉 ∈ Es, π∗(u′) = π∗(v′), and π∗(u) = π∗(v). By the definition of Es, role R exist such that R(u′, u) is an aux-simple atom in q∼. By the definition of aux-simple atom, we have τ(u) ∈ auxDK , u′ 6= u, role R is simple, and τ(u′) = τ(u) implies that SelfR(τ(u)) 6∈ J . By Lemma 20 and by the construction of τ , atom R(π∗(u), π∗(u)) ∈ I is not a self-loop. Since τ(u) ∈ auxDK , we have π∗(u) 6∈ NI . Then, by property 1 in Lemma 29, we have π∗(u) is of the form fBT,A(π∗(u\n′)). Thus, π(u′) ≺ π(u) and no vertex v′′ ∈ V exists such that π(u′) ≺ π(v′′) ≺ π(u). Since π∗(u) = π∗(v) and π∗(u′) = π∗(v′), we have 〈v′, v〉 ∈ E , as required. Therefore, σ(Es) ⊆ E . Please note that since 〈V, E〉 is a forest, so is 〈σ(V ), σ(Es)〉, as required by condition 3 in Definition 9.\nIt remains to show that each edge 〈v′, v〉 ∈ E occurs in σ(Et). Consider an arbitrary edge 〈v′, v〉 ∈ E . By the definition of E , we have π∗(v′) ≺ π∗(v), and so π∗(v) is a functional term. Then let w0, . . . , wk be terms such that w0 = π∗(v′), wk = π∗(v), and wi is of the form fBiTi,Ai(wi−1) for each i ∈ [1, k]. Note that these terms are uniquely defined by the edge, and that, by the construction of I , for each i ∈ [1, k], we have Ti(wi−1, wi) ∈ I . By Lemma 20, we have dTi(δ(wi−1), δ(wi)) ∈ J . By the definition of τ , we have δ(w0) = τ(v′) and δ(wk) = τ(v). Thus, 〈v′, v〉 ∈ σ(Et), as required by Definition 10.\nFinally, consider an edge 〈v′, v〉 ∈ E and let w0, . . . , wk be terms uniquely associated with this edge. Then a role R is compatible with 〈v, v′〉 if dR(δ(wi−1), δ(wi)) ∈ J for each i ∈ [1, k], and trans(R) 6∈ T implies that k = 1. In the rest of this proof we will show the following property.\n(♦) Each role R ∈ L(v′, v) is compatible with the edge 〈v′, v〉.\nBy the definition of function exist (Definition 11) and the above definition of compatibility, property (♦) implies that the condition in step 17 is not satisfied for edge 〈v′, v〉 ∈ E .\nFor the loop in step 6; let R(s, t) be an arbitrary aux-simple atom in σ(q∼). By the definition of aux-simple atom, we have τ(t) ∈ auxDK , role R is simple, and s 6= t. By the definition of σ, we have π∗(s) 6= π∗(t). Thus, R(π∗(s), π∗(t)) ∈ I is not a self-loop. Since R is simple, by property 1 in Lemma 29, π∗(t) is of the form fA1T,A(π∗(s)). By Lemma 20, we have dR(δ(π∗(s)), δ(π∗(t))) ∈ I . Letw0, . . . , wk be the terms associated with 〈s, t〉 ∈ E . By the form of π∗(t) and sincew0 = π∗(s) and wk = π∗(t), we have k = 1. Thus, property (♦) is satisfied.\nFor the loop in steps 7–15; let R(s, t) be an arbitrary atom in σ(q∼) that is neither good nor aux-simple. We next determine the nondeterministic choices that preserve (♦) in step 15, and that satisfy the conditions in steps 8, 9, and 14. By assumption, we have R(π∗(s), π∗(t)) ∈ I . Since R(s, t) is not good, we have τ(t) ∈ auxDK , and either s 6= t or SelfR(τ(t)) 6∈ J . By Lemma 20 and by the definition of τ , atom R(π∗(s), π∗(t)) ∈ I is not a self-loop. Hence, a role P and terms w0, . . . , wm with wm = π∗(t) exist in ∆I that satisfy property 2 in Lemma 29. Since P v∗T R and by properties (2c) and (2d), we have P (π∗(s), π∗(t)) ∈ I . By Lemma 20 and by the construction of τ , we have P (τ(s), τ(t)) ∈ J ; consequently, the conditions in step 8 are satisfied. Assume that trans(P ) 6∈ T . By property 2 in Lemma 29, we have m = 1 and π∗(v) ≺ π∗(t). Thus, π∗(t) is of the form fBT,A(π∗(s)). By the definition of skeleton S, we have 〈s, t〉 ∈ E ; thus, the condition in step 9 is not satisfied. Next, we consider two cases.\n• s reaches t in E . It follows that π∗(s) ≺ π∗(t). Let v0, . . . , vn be the unique path connecting s to t in S. Since π∗(s) ≺ π∗(t), we have w0 = π∗(v0) and wm = π∗(vn). Thus, for each i ∈ [1, n], a unique index `i exists such that π∗(vi) = w`i . By property (2d) in Lemma 29 and by Lemma 20, role P is compatible with 〈vi−1, vi〉 ∈ E .\n• s does not reach t in E . Hence, π∗(s) 6≺ π∗(t). Let at be the root of t in E , and let v0, . . . , vn be the unique path connecting at to t in E . Since π∗(s) 6≺ π∗(t), we have w0 = at, w0 ≺ wm, and wm = π∗(vn); moreover, trans(P ) ∈ T , and P (π∗(s), at) ∈ I . Thus, for each i ∈ [1, n], a unique index `i exists such that π∗(vi) = w`i . By Lemma 20, we have P (τ(s), at) ∈ J , so condition in step 17 is not satisfied. Then, by property (2d) in Lemma 29 and by Lemma 20, role P is compatible with 〈vi−1, vi〉 ∈ E .\nE Proof of Theorem 13 Let K = 〈T ,A〉 be a satisfiable ELHOs KB and let DK be the datalog program for K; furthermore, let q = ∃~y.ψ(~x, ~y) be a CQ, and let τ be a candidate answer for q and DK.\nTheorem 13. Function isSound(q,DK, τ) can be implemented so that"
    }, {
      "heading" : "1. it runs in nondeterministic polynomial time,",
      "text" : ""
    }, {
      "heading" : "2. if each binary atom in q is either good or aux-simple w.r.t. τ , it runs in polynomial time, and",
      "text" : ""
    }, {
      "heading" : "3. if the TBox T and the query q are fixed, it runs in polynomial time in the size of the ABox A.",
      "text" : "Proof. Please note that since the number of variables occurring in each rule in DK is fixed, we can compute the set of all consequences of DK in polynomial time (Dantsin et al. 2001). Thus all the following operations can be implemented to run in polynomial time:\n• computing sets auxDK and indDK , • computing the connection graph cg for q and τ , • given two individuals u′ and u and a set of role L, checking whether exist(u′, u, L) returns t, and • checking whether a binary atom is good or aux-simple w.r.t. τ .\nNext, we argue that we can compute relation ∼ in polynomial time. As stated above, we can evaluate in polynomial time the precondition of the (fork) rule. In addition, the size of relation ∼ is bounded by |NT (q)|2, the rules used to compute it are monotonic, and each inference can be applied in polynomial time, so the claim follows.\nAlso, we can check in linear time whether a directed graph is a acyclic by searching for a topological ordering of its vertices (Cormen et al. 2009). Therefore, condition 2 in Definition 8 can be checked in polynomial time. Therefore, steps 1 and 2 in Algorithm 1 run in time polynomial in the input size, and property 2 holds.\nSince steps 3–15 in Algorithm 1 can all clearly be implemented to run in nondeterministic polynomial time in the input size, property 1 also holds.\nFor property 3, assume that the TBox T and the query q are fixed. Then the set of all consequences of DK can be computed in time polynomial inA. Given that the number of variables occurring in q is fixed, the number of guessing steps required in steps 3 and 4 is fixed; also, the number of alternatives for these steps is linear in the size ofA. Thus, steps 3 and 4 require polynomial time. Moreover, the maximum number of iterations of the for-loop in steps 7-15 is fixed. The number of alternatives for the guessing steps in line 8 is fixed as well. Therefore, steps 7-15 require time polynomial in the size of A. All other steps can clearly be implemented in time polynomial in the size of A, thus isSound runs in time polynomial in the size of A.\nF Proof of Theorem 14 Theorem 14. Checking whether a candidate answer is sound is NP-hard.\nProof. The proof is by reduction from the NP-hard problem of checking the satisfiability of a 3CNF formula (Garey and Johnson 1979). Let ϕ = ∧m j=1 Cj be a 3CNF formula over variables {v1, . . . , vn}, where each Cj is a set of three literals Cj = {lj,1, lj,2, lj,3}. A sequence ν = lj1,k1 , . . . , lj`,k` of literals from ϕ is consistent if {vi,¬vi} 6⊆ ν for each i ∈ [1, n]. Such a ν is a truth assignment for ϕ if for each j ∈ [1,m], a literal l ∈ ν exists such that l = lj,k for some k ∈ [1, 3]. Then ϕ is satisfiable if and only if there exists a consistent truth assignment for ϕ.\nLet ϕ be a 3CNF formula. We next define an ELHOs KB Kϕ and a Boolean CQ qϕ such that Kϕ does not contain axioms of type 2, and Kϕ |= qϕ if and only if there exists a consistent truth assignment for ϕ. Let Dϕ be the translation of Kϕ into datalog. By Theorem 12 and since Kϕ does not contain axioms of type 2, we have Kϕ |= qϕ if and only if a candidate answer τ for qϕ and Dϕ exists such that isSound(qϕ,Dϕ, τ) returns t. Then, to prove the theorem, we show that there exists a unique candidate answer τϕ for qϕ and Dϕ. Thus, Kϕ |= qϕ if and only if isSound(qϕ,Dϕ, τϕ) returns t, hence, isSound(qϕ,Dϕ, τϕ) returns t if and only if ϕ is satisfiable.\nFor convenience, in the following we will specifyKϕ using its equivalent formalisation as a rule base Ξϕ. Moreover, rule base Ξϕ will not contain equality rules; consequently Ξϕ has a unique universal interpretation I . We will present our construction of Ξϕ in stages, and for each we will describe how it affects the universal interpretation I .\nOur encoding of Ξϕ uses a fresh individual a, fresh concepts A and G, fresh roles R and T , a fresh concept Lj,k and a fresh role Sj,k uniquely associated to each literal lj,k, a fresh concept Cj uniquely associated to each clause Cj , and fresh roles Pi, Ni, and Ti uniquely associated to each variable vi.\nBefore presenting Ξϕ, we need a couple of definitions. Given two terms w′ and w from I , and a word ρ = T1 · · ·T` over NR, we write ρ(w′, w) ∈ I , if terms w0, . . . , w` with w0 = w′ and wm = w exist such that Ti(wi−1, wi) ∈ I for each i ∈ [1, `]. In the following, we uniquely associate to each sequence ν = lj1,k1 , . . . , lj`,k` of literals from ϕ the word ρν = R · Sj1,k1 ·R · Sj2,k2 · · ·R · Sj`,k` ·R.\nWe next present Ξϕ which consists of four parts. The first part of rule base Ξϕ contains atom (3) and rules (4)–(7). Then for each sequence ν of literals from ϕ, a term wν\nexists in I such that ρν(a,wν) ∈ I and G(wν) ∈ I .\nA(a) (3) A(x)→∃z.R(x, z) ∧ Cj(z) ∀j ∈ [1,m] (4) A(x)→∃z.R(x, z) ∧G(z) (5) Cj(x)→∃z.Sj,k(x, z) ∧ Lj,k(z) ∀j ∈ [1,m] ∀k ∈ [1, 3] (6) Lj,k(x)→A(x) ∀j ∈ [1,m] ∀k ∈ [1, 3] (7)\nThe second part of rule base Ξϕ contains rules (8) and (9). Consider an arbitrary literal lj,k and arbitrary terms w′ and w in I such that Sj,k(w′, w) ∈ I . Then, for each variable vi, we have Pi(w′, w) ∈ I if and only if sequence vi, lj,k is consistent; and Ni(w ′, w) ∈ I if and only if sequence ¬vi, lj,k is consistent.\nSj,k(x, y)→ Pi(x, y) ∀j ∈ [1,m],∀k ∈ [1, 3],∀i ∈ [1, n] with lj,k = vi or lj,k is not over vi (8) Sj,k(x, y)→ Ni(x, y) ∀j ∈ [1,m],∀k ∈ [1, 3],∀i ∈ [1, n] with lj,k = ¬vi or lj,k is not over vi (9)\nThe third part of rule base Ξϕ contains rules (10)–(13). Then for each sequence ν of literals from ϕ with ρν(a,wν) ∈ I and each i ∈ [1, n], we have Pi(a,wν) ∈ I if and only if ν, vi is consistent; and Ni(a,wν) ∈ I if and only if ν,¬vi is consistent.\nR(x, y)→ Pi(x, y) ∀i ∈ [1, n] (10) R(x, y)→ Ni(x, y) ∀i ∈ [1, n] (11)\nPi(x, y) ∧ Pi(y, z)→ Pi(x, z) ∀i ∈ [1, n] (12) Ni(x, y) ∧Ni(y, z)→ Ni(x, y) ∀i ∈ [1, n] (13)\nThe fourth part of rule base Ξϕ contains rules (14)–(16). Then for each sequence ν of literals from ϕ with ρν(a,wν) ∈ I and each i ∈ [1, n], we have Ti(a,wν) ∈ I if and only if {vi,¬vi} 6⊆ ν; furthermore, for each clause Cj , a term wj exists such that T (wj , wν) ∈ I if and only if an index k ∈ [1, 3] exists such that lj,k ∈ ν.\nPi(x, y)→ Ti(x, y) ∀i ∈ [1, n] with i 6= k (14) Ni(x, y)→ Ti(x, y) ∀i ∈ [1, n] with i 6= k (15) Li(x, y)→ T (x, y) ∀i ∈ [1, n] (16)\nQuery qϕ is given in (17). Then Kϕ |= qϕ if and only if a sequence ν of literals from ϕ exists such that Ti(a,wρ) ∈ I for each i ∈ [1, n], and, for each j ∈ [1,m], a term wj exists such that Cj(wj) ∈ I and T (wj , wρ) ∈ I; hence, Kϕ |= qϕ if and only if\nthere exists a consistent truth assignment ν for ϕ.\nqϕ = ∃y∃z1, . . .∃zm. G(y) ∧ n∧ i=1 Ti(a, y) ∧ m∧ j=1 Cj(zj) ∧ T (zj , y) (17)\nProgram Dϕ contains all the atoms and the rules in Ξϕ apart from rules (4)–(6) which are replaced by rules (18)–(20).\nA(x)→ R(x, oR,Cj ) ∧ Cj(oR,Cj ) ∀j ∈ [1,m] (18) A(x)→ R(x, oR,G) ∧G(oR,G) (19) Cj(x)→ Sj,k(x, oSj,k,Lj,k) ∧ Lj,k(oSj,k,Lj,k) ∀j ∈ [1,m],∀k ∈ [1, 3] (20)\nWe next define substitution τϕ, and we show that Dϕ |= τϕ(qϕ). Substitution τϕ is given in (21). τ(y) = oR,G and τ(zj) = oR,Cj ∀j ∈ [1,m] (21)\nConsider an arbitrary i ∈ [1, n]; we show that Dϕ |= Ti(a, τ(y)). By atom (3), and by rule (19) we have Dϕ |= R(a, τ(y)). But then, by rules (10), (11), (14) (15), we immediately have Dϕ |= Ti(a, τ(y)), as required. Next, consider an arbitrary j ∈ [1,m]; we show that Dϕ |= T (τ(zj), τ(y)). Please note that by atom (3) and by rules (18), we have Dϕ |= Cj(τ(zj)). Consider an arbitrary literal lj,k in Cj . By rules (20) and (7), there exists an individual u such that Dϕ |= Sj,k(τ(zj), u) and Dϕ |= A(u). Then, by rule (19) we have Dϕ |= R(u, τ(y)). By rules (10)–(16), we have Dϕ |= T (τ(zj), τ(y)), as required.\nWe are left to show that τϕ is unique. Consider an arbitrary candidate answer ξ for qϕ and Dϕ. Since G(y) is an atom in q and only rule (19) derives assertions over G, we must have ξ(y) = oR,G. Consider an arbitrary j ∈ [1,m]. Due to atom Cj(zj) in q, and only rule (18) derives assertions over concept Cj , we must have ξ(y) = oR,Cj . Thus, ξ = τϕ, as required.\nG Proof of Theorem 17 Let K be a satisfiable ELHO KB, and let ΞK and DK be the rule base and the datalog program associated with K, respectively; furthermore, let indDK and auxDK be as specified in Definition 4, and let q be an arborescent query. We next show that function entails(DK, q) returns t if and only if ΞK |= q, and that entails(DK, q) runs in time polynomial in the input size.\nTo this end, we start with a couple of definitions. Let I and J be universal interpretations for ΞK and DK, respectively. Moreover, let δ be the mapping as specified at the beginning of Section B. For each set V ∈ RT, let qV be the arborescent query obtained from q by replacing each variable y ∈ V with a fresh variable yV , and by removing each variable z, and all the atoms involving z, in the resulting query such that z 6= yV and z is not a descendant of yV in dgq . Lemma 33. Function entails(DK, q) returns t if and only if ΞK |= q. Furthermore, entails(DK, q) runs in time polynomial in the input size.\nProof. Since q does not contain individuals, we have ΞK |= q if and only if a substitution π with dom(π) = NV (q) exists such that π(q) ⊆ I . In the following, we show that the latter is the case if and only if function entails(DK, q) returns t.\nLet RT be as specified in Definition 16. Let M be the largest n ∈ N for which a set V ∈ RT exists whose level is n. By the definition, M is the length of the longest path in dgq , and so it is linearly bounded by the size of q.\nNext, we argue that we can compute set RT in polynomial time. This follows from the fact that the rules used to compute it are monotonic, each rule can be applied at most M times, and each rule application introduces at most |q| sets in RT, and the size of each set is linearly bounded by |q|.\nBy Lemmas 20 and 21, and since each rule in DK contains a fixed number of variables, each set V ∈ RT satisfies the two following properties for each u ∈ indDK ∪ auxDK and each term w ∈ ∆I with δ(w) = u. A. u ∈ cV if and only if B(w) ∈ I for each concept B such that B(y) ∈ q for some y ∈ V . B. cV can be computed in time polynomial in the size of DK and q.\nTo prove the lemma, we next show that each set V ∈ RT satisfies the following properties for each term u ∈ indDK ∪ auxDK . 1. u ∈ AV if and only if a substitution π with dom(π) = NV (qV ) exists such that π(qV ) ⊆ I and δ(π(yV )) = u. 2. AV can be computed in time polynomial in the size of DK and q.\nThe proof goes by reverse-induction on the level of sets in RT. Base case. Consider an arbitrary set V ∈ RT of level M . By the definition of AV , we have AV = cV . Furthermore, an atom B(yV ) is in qV if and only if a variable y ∈ V exists such that B(y) in q. Properties 1 and 2 follow immediately from A and B. Inductive step. Consider an arbitrary n ∈ N. Let V ∈ RT be an arbitrary set of level n, and assume that properties 1 and 2 hold for each set W ∈ RT of level n+ 1; we show that the properties are satisfied by V . For property 1, let u be an arbitrary term in indDK ∪ auxDK . By the definition of AV we have AV = cV ∩ (iV ∪ aV ). By the definition of qV and from property A, it suffices to show that u ∈ (iV ∪ aV ) if and only if a substitution π exists such that π(qV ) ⊆ I and δ(π(yV )) = u. We consider the two directions of 1 separately.\n(⇒) Assume that u ∈ (iV ∪ aV ). We distinguish two cases.\n• u ∈ iV . Thus, u ∈ indDK and u ∈ NI . Consider an arbitrary variable y ∈ PV and an arbitrary role R ∈ ry . Then, an individual u′ ∈ indDK ∪ auxDK exists such that u′ ∈ A{y} andR(u′, u) ∈ J . By the inductive hypothesis, a substitution π{y} exists such that π{y}(q{y}) ⊆ I and δ(w′) = u′, where w′ = π{y}(y{y}). By Lemma 21, we have R(w′, u) ∈ I . Then let π be the substitution such that π(yV ) = u and π{y} ⊆ π for each y ∈ PV . Then π(qV ) ⊆ I , as required. • u ∈ aV . Thus, u ∈ auxDK and u is of the form oP,A. Consider an arbitrary role R such that R ∈ ry for some y ∈ PV . Then, an individual u′ ∈ indDK ∪ auxDK exists such that u′ ∈ APV and dR(u′, u) ∈ J . By the inductive hypothesis, a substitution πPV exists such that πPV (qPV ) ⊆ I and δ(w′) = u′, where w′ = πPV (yPV ). By Lemma 21, a term w ∈ ∆I exists such that δ(w) = oP,A and P (w′, w) ∈ I and P v∗T R. Since no rule is applicable to I , we have R(w′, w) ∈ I . Then let π be the substitution such that π(yV ) = w, πPV ⊆ π, and π(y) = w′ for each y ∈ PV . Then π(qV ) ⊆ I , as required.\n(⇐) Assume that a substitution π exists such that π(qV ) ⊆ I and δ(π(yV )) = u. We distinguish two cases. • π(yV ) ∈ NI . By Lemma 24, we have u ∈ indDK and u ∈ NI . Consider an arbitrary variable y ∈ PV and an arbitrary\nrole R ∈ ry . By the definition of qV , atom R(y, yV ) occurs in qV . Since R(π(y), π(yV )) ∈ I , by Lemma 20, we have R(δ(π(y)), δ(π(yV ))) ∈ J and δ(π(y)) ∈ indDK ∪ auxDK . Due to the construction of qV , q{y} is a subquery of qV ; thus, π(q{y}) ⊆ I . Hence, by the inductive hypothesis, we have δ(π(y)) ∈ A{y}. Due to δ(π(yV )) = u and u ∈ indDK , we have u ∈ iV , as required.\n• π(yV ) 6∈ NI . By Lemma 24, we have u ∈ auxDK . Consider an arbitrary variable y ∈ PV and an arbitrary role R ∈ ry . By the definition of qV , atom R(y, yV ) occurs in qV . By assumption, we have R(π(y), π(yV )) ∈ I . Since K is an ELHO knowledge base, role R is simple and SelfR(π(yV )) 6∈ I . By Lemma 29, term π(yV ) is of the form fBP,A(π(y)). Therefore, for each variable z ∈ PV , we have π(z) = π(y). Furthermore, by Lemma 20, we have dR(δ(π(y)), δ(π(yV ))) ∈ J and δ(π(y)) ∈ indDK ∪ auxDK . Let substitution πPV for qPV be obtained from π by setting πPV (yPV ) = π(y). Then, we have πPV (qPV ) ⊆ I . Hence, by the inductive hypothesis, we have δ(π(y)) ∈ APV . Due to δ(π(yV )) = u and u ∈ auxDK , we have u ∈ aV , as required. For property 2, we show that AV can be computed in time polynomial in the size of DK and q. By property B, set cV can be computed in time polynomial in q and DK, hence in the rest of this proof we focus on sets iV and aV .\n• iV . Please note that the number of variables in PV is bounded by the size of q. Then consider an arbitrary variable y ∈ PV . By the inductive hypothesis, set A{y} can be computed in time polynomial in q and DK. Then, since each rule in DK contains a constant number of variables, iV can also be computed in time polynomial in the size of q and DK.\n• aV . By the inductive hypothesis, set APV can be computed in time polynomial in the size of q and DK. Then, since each rule in DK contains a constant number of variables, aV can also be computed in time polynomial in the size of q and DK.\nH Proof of Theorem 18 In this section, we prove the lower bounds established in Theorem 18, all of which are proved by reducing the NP-hard problem of checking the satisfiability of a CNF formula ψ (Garey and Johnson 1979). For the rest of this section, we fix a CNF formula ψ = ∧m j=1 Cj where each Cj is a clause over variables {v1, . . . , vn}.\nFor convenience, we will assume that ELHO TBoxes can contain axioms of the form A1 v ∃R.{a} with A1 ∈ NC ∪ {>}, R a role, and {a} a nominal. The translation into rules for this type of axiom is given by A1(x) → R(x, a). Moreover, in the following we will specify DL knowledge bases using their equivalent formalisation as rule bases. Furthermore, all the rules from this section do not contain equality, and so each rule base has exactly one universal interpretation.\nThen to prove the theorem, we will first define a rule base Ξ0 containing only rules of types 1 and 7 from Table 1, and a Boolean CQ q0 over Ξ0, after which we will show that 1. a rule base Ξ1 and a query q1 exist such that Ξ1 is in ELHO, query q0 ∧ q1 is acyclic, and ψ is satisfiable if and only if\nΞ0 ∪ Ξ1 |= q0 ∧ q1, 2. a rule base Ξ2 and a query q2 exist such that Ξ2 contains a single rule of type 8, query q0 ∧ q2 is arborescent, and ψ is\nsatisfiable if and only if Ξ0 ∪ Ξ2 |= q0 ∧ q2, and 3. a rule base Ξ3 and a query q3 exist such that Ξ3 contains a single rule of type 9, query q0 ∧ q3 is arborescent, and ψ is\nsatisfiable if and only if Ξ0 ∪ Ξ3 |= q0 ∧ q3."
    }, {
      "heading" : "H.1 Construction of Ξ0 and q0",
      "text" : "Our encoding uses a fresh role R, a fresh concepts G, fresh concepts Ti, Fi, and Ai uniquely associated with each variable vi in ψ, and fresh concepts Cj uniquely associated to each clause Cj in ψ. Rule base Ξ0 contains a ground atom (22), and rules (23)–(29). Let I0 be the universal interpretation of Ξ0, we next describe how the rules in Ξ0 model the structure of I0. Atom (22) and rules (23)–(27) encode a binary tree of depth n+ 1 in I0 rooted in individual a in which edges are labelled by role R, each leaf node satisfies concept G, and each node w at depth 1 ≤ i ≤ n satisfies exactly one of Ti and Fi. Then node w represents a positive truth assignment to vi, if Ti(w) ∈ I0; otherwise, it represents a negative truth assignment to vi. Consequently, a path\nfrom a to a leaf node in the tree represents a truth assignment to the variables in ψ. Finally, rules (28) and (29) ensure that, for each node w at depth 1 ≤ i ≤ n in the tree, if the truth assignment to vi represented by w makes clause Cj evaluate to true, then Cj(w) ∈ I0.\nA0(a) (22) Ai−1(x)→∃z.R(x, z) ∧ Ti(z) ∀i ∈ [1, n] (23) Ai−1(x)→∃z.R(x, z) ∧ Fi(z) ∀i ∈ [1, n] (24) Ti(x)→Ai(x) ∀i ∈ [1, n] (25) Fi(x)→Ai(x) ∀i ∈ [1, n] (26) An(x)→∃z.R(x, z) ∧G(z) (27) Ti(x)→Cj(x) ∀i ∈ [1, n] ∀j ∈ [1,m] with vi ∈ Cj (28) Fi(x)→Cj(x) ∀i ∈ [1, n] ∀j ∈ [1,m] with ¬vi ∈ Cj (29)\nQuery q0 is given in (30). It should be clear that, for each substitution π with dom(π) = ~p such that π(q0) ⊆ I0, substitution π represents a truth assignment for ψ, π(p0) = a, and π(pn+1) is a leaf.\nq0 = ∃p0 . . . ∃pn+1. n∧ i=1 [Ai−1(pi−1) ∧R(pi−1, pi)] ∧G(pn+1) (30)"
    }, {
      "heading" : "H.2 Construction of Ξ1 and q1",
      "text" : "Our rule base Ξ2 uses fresh roles Sj and individuals cj uniquely associated to each clause Cj of ψ. Then rule base Ξ1 contains atoms (31), and rules (32) and (33). Let I1 be the universal interpretation of Ξ0 ∪ Ξ1, then we clearly have I0 ⊆ I1. We next describe how the rules and atoms in Ξ1 modify the tree encoded by Ξ0. Rule (32) ensure that, for each node w in the tree whose truth assignment makes clause Cj evaluate to true, there exists an edge labelled by Sj from w to individual cj . Atom (31) generates an edge labelled by R connecting cj to itself. Finally, rule (33) labels each edge in the tree and each looping edge with Sj .\nR(cj , cj) ∀j ∈ [1,m] (31) Cj(x)→Sj(x, cj) ∀j ∈ [1,m] (32) R(x, y)→Sj(x, y) ∀j ∈ [1,m] (33)\nOur encoding of query q1 uses variable pn+1 from query q0, as well as fresh variables x j 0, . . . , x j n, y j , yj0, . . . , y j n, and\nzj1, . . . , z j n+1 uniquely associated with each clause Cj . Next, we associate with each Cj a conjunction ϕ j as shown in (34). Then query q1 is the existential closure of ∧ j ϕ j .\nϕj = R(yj , x j 0) ∧ n∧ i=1 [ϕji ∧R(y j i−1, x j i )] ∧ ϕ j n+1 ∧R(yjn, pn+1) (34)\nϕji = R(x j i−1, z j i ) ∧ Sj(y j i−1, z j i ) (35)\nFigure 2 shows a graphical representation of query q0 ∧ q1 for n = 2 and an arbitrary j ∈ [1,m]. The black edges denote atoms over role R, and the dashed edges denote atoms over role Sj . It should be clear that query q0 ∧ q1 is acyclic, as required. Please note that q0 ∧ q1 is not arborescent: each variable yji in q0 ∧ q1 has two parent nodes.\nConsider an arbitrary substitution π such that π(q0) ⊆ I1. Intuitively, each conjunct ϕj in q1 ensures that the truth assignment represented by π makes clause Cj true. We next prove that our encoding is correct.\nLemma 34. ψ is satisfiable if and only if Ξ0 ∪ Ξ1 |= q0 ∧ q1.\nProof. (⇒) Assume that a truth assignment ν : {v1, . . . , vn} 7→ {t, f} exists such that ν(ψ) = t; we next show that a substitution π with dom(π) = NV (q0 ∧ q1) exists such that π(q0∧ q1) ⊆ I1. To this end, let π(p0) = a and, for each i ∈ [1, n], let π(pi) be the unique successor of π(pi−1) in I1 such that Ti(π(pi)) ∈ I1 if and only if ν(vi) = t. Consider an arbitrary clause Cj . Since ν(ψ) = t, a literal l ∈ Cj exists such that ν(l) = t. Let k ∈ [1, n] be the unique index such that literal l is over variable vk. Then, formulas Ψ j − and Ψ j + exist such that ϕ j is of the form ϕj = Ψj− ∧ϕ j k+1 ∧Ψ j +. Next, we extend substitution π as follows:\n• π maps each variable occurring in Ψj− to cj , • π(xjk) = cj , π(z j k+1) = cj , and π(y j k) = π(pk), and\n• for each ` ∈ [k + 1, n+ 1], π maps each variable with subscript ` occurring in Ψj+ to π(pk).\nPlease note that by rules (32) and (33), and by atoms (31), we have π(Ψj−) ∪ π(ϕ j k+1) ∪ π(Ψ j +) ⊆ I1.\n(⇐) Assume that a substitution π with dom(π) = NV (q0 ∧ q1) exists such that π(q0 ∧ q1) ⊆ I1; we next show that a truth assignment ν : {v1, . . . , vn} 7→ {t, f} exists such that ν(ψ) = t. Please note that π(p0) = a and, for each i ∈ [1, n], we have π(pi) is a successor of π(pi−1) in the binary tree encoded by Ξ0; moreover, for each j ∈ [1,m], due to atom R(yjn, pn+1) in (34), we have π(yjn) is the unique parent of π(pn+1) in the tree, and so π(y j n) = π(pn). Then, let ν be the truth assignment such that, for each i ∈ [1, n], we have ν(vi) = t if and only if Ti(π(pi)) ∈ I1. We next show that ν(ψ) = t; that is, for each clause Cj , we have ν(Cj) = t. Consider an arbitrary clause Cj . By rules (27) and (28), it suffices to find an index ` ∈ [1, n] such that Cj(π(p`)) ∈ I1. Towards this goal, we first show that substitution π satisfies the following property for each i ∈ [0, n].\n(♦) If for each ` ∈ [i, n] we have π(zj`+1) 6∈ NI , then π(y j i ) = π(pi) and π(x j i ) = π(pi).\nWe proceed by reverse induction on i ∈ [0, n]. Base case. Let i = n. Assume that π(zjn+1) 6∈ NI . As stated above, we have π(yjn) = π(pn). Due to atom Sj(yjn, z j n+1) in ϕjn+1, we have π(z j n+1) is a successor of π(pn). Due to atom R(x j n, z j n+1) in ϕ j n+1, we have π(x j n) is the parent of π(z j n+1), thus π(xjn) = π(pn), as required. Inductive step. Consider an arbitrary i ∈ [0, n− 1]. Assume that the property holds for i+ 1, and that π(zj`+1) 6∈ NI for each ` ∈ [i, n]. By the inductive hypothesis, we have π(yji+1) = π(pi+1) and π(x j i+1) = π(pi+1). Due to atom R(y j i , x j i+1) in (34), we have π(yji ) is the unique parent of π(pi+1) in the tree, and so π(y j i ) = π(pi). Due to atom Sj(y j i , z j i+1) in ϕ j i+1, we have π(zji+1) is a successor of π(pi). Finally, due to atom R(x j i , z j i+1) in ϕ j i+1, we have π(x j i ) = π(pi), as required.\nWe next show that an index i ∈ [0, n] exists such that π(zji+1) is mapped to an individual. Assume the opposite, hence, for each i ∈ [0, n], we have π(zji+1) 6∈ NI . By property (♦), we then have π(x j 0) = π(p0). Since atom S(y\nj , xj0) occurs in q1, π(xj0) = π(p0) = a, and a does not have incoming edges in I1, this is a contradiction.\nFinally, let ` ∈ [0, n] be the largest index such that π(zj`+1) ∈ NI . We show that π(y j ` ) = π(p`) by considering two cases.\n• ` = n. As stated above, we have π(yjn) = π(pn). • ` < n. By property (♦), we have π(xj`+1) = π(p`+1). Due to atom R(y j ` , x j `+1), we have π(y j ` ) = π(p`).\nIn either cases, we have π(yj` ) = π(p`). We next show that ` > 0. Assume the opposite, hence ` = 0. Since π maps π(zj1) ∈ NI and π(y j 0) = a, atom Sj(y j 0, z j 1) occurs in q1, and a is not connected to an individual in I1, we have Sj(π(y j 0), π(z j 1)) 6∈ I1, which is a contradiction.\nTherefore, we have π(yj` ) = π(p`) and ` > 1. By rules (32) and (33), and since atom Sj(y j ` , z j `+1) occurs in q1, we have\nπ(zj`+1) = cj and Cj(π(p`)) ∈ I1, as required."
    }, {
      "heading" : "H.3 Construction of Ξ2 and q2",
      "text" : "Rule base Ξ2 consists only of rule (36). Let I2 be the universal interpretation of Ξ0 ∪ Ξ2, then we clearly have I0 ⊆ I2. Note that rule (36) modifies the tree encoded by Ξ0 by connecting each node w in the tree via an R edge to all nodes that occur on the path connecting w to the root a.\nR(x, y) ∧R(y, z)→ R(x, z) (36)\nOur encoding of query q2 uses variable pn+1 from query q0, as well as a fresh variable xj uniquely associated to each clause Cj . Query q2 is given in (37).\n∃x1 . . . ∃xm m∧ i=1 Cj(xj) ∧R(xj , pn+1) (37)\nIt should be clear that q0 ∧ q2 is arborescent. Now, consider a substitution π such that π(q0 ∧ q2) ⊆ I2. By the definition of q2, for each j ∈ [1,m], a term wj exists such that wj occurs on the unique path connecting leaf π(pn+1) to the root of the tree a and Cj(wj) ∈ I2; therefore, an index `j ∈ [1, n] exists such that π(p`j ) = π(xj). By the definition of Ξ0 and q0, the truth assignment represented by π then makes Cj evaluate to true. Thus, the following holds. Lemma 35. ψ is satisfiable if and only if Ξ0 ∪ Ξ2 |= q0 ∧ q2."
    }, {
      "heading" : "H.4 Construction of Ξ3 and q3",
      "text" : "Rule base Ξ3 consists of rules (38). Let I3 be the universal interpretation of Ξ0 ∪ Ξ3, then we clearly have I0 ⊆ I3. Rules (38) modify the tree encoded by Ξ0 by generating an edge labelled by R connecting each node to itself.\n>(x)→ SelfR(x) ∧R(x, x) ∀j ∈ [1,m] (38)\nOur encoding of query q3 uses variable pn+1 from query q0, as well as fresh variables x j 0, . . . , x j n uniquely associated to each clause Cj . Furthermore, we associate to each clause Cj the formula ϕj in (39). Then q3 is the existential closure of ∧ j ϕ j .\nϕj = Cj(x j 0) ∧R(xj , x j 0) ∧ n∧ i=1 R(xji−1, x j i ) ∧R(x j n, pn+1) (39)\nIt should be clear that q0 ∧ q3 is arborescent. Consider an arbitrary substitution π such that π(q0 ∧ q3) ⊆ I3 and an arbitrary clause Cj . Then, formula ϕj ensures that a path of length n + 1 exists connecting leaf node π(pn+1) to one arbitrary node occurring in the unique path connecting π(pn+1) to root a. Since the tree has depth n+ 1 and the leaves and the root of the tree do no satisfy concept Cj , variable x j 0 must be mapped to some node at depth 1 ≤ i ≤ n. By the definition of Ξ0 and q0, the truth assignment represented by π then makes Cj evaluate to true. Thus, the following holds. Lemma 36. ψ is satisfiable if and only if Ξ0 ∪ Ξ3 |= q0 ∧ q3."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Answering conjunctive queries (CQs) over EL knowledge<lb>bases (KBs) with complex role inclusions is PSPACE-hard<lb>and in PSPACE in certain cases; however, if complex role<lb>inclusions are restricted to role transitivity, the upper com-<lb>plexity bound has so far been unknown. Furthermore, the ex-<lb>isting algorithms cannot handle reflexive roles, and they are<lb>not practicable. Finally, the problem is tractable for acyclic<lb>CQs and ELH, and NP-complete for unrestricted CQs and<lb>ELHO KBs. In this paper we complete the complexity land-<lb>scape of CQ answering for several important cases. In par-<lb>ticular, we present a practicable NP algorithm for answering<lb>CQs over ELHO KBs—a logic containing all of OWL 2<lb>EL, but with complex role inclusions restricted to role transi-<lb>tivity. Our preliminary evaluation suggests that the algorithm<lb>can be suitable for practical use. Moreover, we show that,<lb>even for a restricted class of so-called arborescent acyclic<lb>queries, CQ answering over EL KBs becomes NP-hard in<lb>the presence of either transitive or reflexive roles. Finally, we<lb>show that answering arborescent CQs over ELHO KBs is<lb>tractable, whereas answering acyclic CQs is NP-hard.",
    "creator" : "TeX"
  }
}