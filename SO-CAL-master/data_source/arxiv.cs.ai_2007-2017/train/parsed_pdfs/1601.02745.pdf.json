{
  "name" : "1601.02745.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Basic Reasoning with Tensor Product Representations",
    "authors" : [ "Paul Smolensky" ],
    "emails" : [ "smolensky@jhu.edu", "moontae@cs.cornell.edu", "deng}@microsoft.com" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Basic Reasoning with Tensor Product Representations\nPaul Smolensky* Department of Cognitive Science Johns Hopkins University Baltimore, MD 21218, USA smolensky@jhu.edu Moontae Lee Department of Computer Science Cornell University Ithaca, NY 14850, USA moontae@cs.cornell.edu Xiaodong He, Wen-tau Yih, Jianfeng Gao & Li Deng Microsoft Research Redmond, WA 98052, USA {xiaohe, scottyih, jfgao, deng}@microsoft.com\nIn this paper we present the initial development of a general theory for mapping inference in predicate logic to computation over Tensor Product Representations (TPRs; Smolensky (1990), Smolensky & Legendre (2006)). After an initial brief synopsis of TPRs (Section 0), we begin with particular examples of inference with TPRs in the ‘bAbI’ question-answering task of Weston et al. (2015) (Section 1). We then present a simplification of the general analysis that suffices for the bAbI task (Section 2). Finally, we lay out the general treatment of inference over TPRs (Section 3). We also show the simplification in Section 2 derives the inference methods described in Lee et al. (2016); this shows how the simple methods of Lee et al. (2016) can be formally extended to more general reasoning tasks.\n0 BRIEF SYNOPSIS OF TPR For present purposes, a tensor T(n) of order n over Rd can be taken to be an n-dimensional array of real numbers, each written Tγ1… γn, γk ∈ {1, 2, …, d} ≡ 1:d for all k ∈ 1:n. The two types of tensor operations we use are given in (1): the outer or tensor product (1a) is order-increasing, while contraction (1b) is orderdecreasing. Combining the two gives the inner product (1c). If we interpret an order-2 tensor M(2) as a matrix M, and order-1 tensors U(1), V(1) as vectors/column-matrices u, v, then the outer product u vT of matrix algebra corresponds to the tensor product u ⊗ v (1d) while the dot product u Ŋ v = uTv and the matrix-vector product Mu correspond to tensor inner products (1e).\n* This work was conducted while the first author was a Visiting Researcher, and the second author held a summer internship, at Microsoft Research, Redmond, WA.\n(1) Tensor operations\na. outer/tensor product U(n) ⊗ V(m) = T(n+m) Tγ1… γnγ ′1… γ ′m ≡ Uγ1… γnVγ ′1… γ ′m b. contraction Cjk U(n) = T(n−2) Tγ1… γj−1γj+1… γk−1γk+1… γn ≡ Σβ Tγ1… γj−1βγj+1… γk−1βγk+1… γn c. inner product [j < n < k] U(n) •jk V(m) = T(n+m−2) T ≡ Cjk U ⊗ V\n∴ Tγ1… γj−1γj+1… γk−1γk+1… γn+m = Σβ Uγ1… γj−1βγj+1… γnVγn+1… γk−1βγk+1… γn+m d. [U(1) ⊗ V(1)]γγ ′ = Uγ Vγ ′ ≅ uγvγ ′ = [uvT]γγ ′\ne. U(1) ⋅ V(1) ≡ U(1) •12 V(1) = Uβ Vβ ≅ uβvβ = u ⋅ v; [M(2) •23 U(1)]γ = MγβUβ ≅ Mγβuβ = [Mu]γ\nFollowing the customary practice, throughout the paper, except where explicitly stated otherwise, we assume an implicit summation over repeated indices in a single factor — the Einstein Summation Convention. Thus the explicit summation over β in (1b−c) would be omitted and left implicit, as in (1e).\nA particular TPR maps a space S of symbolic structures to a vector space RN. The type of a structure s ∈ S is determined by a set R = {rk} of structural roles that determines a filler/role decomposition b of S: each token structure s is uniquely characterized as a set of filler/role bindings b(s) = {fk/rk}, in which each role rk is bound to a particular filler fk ∈ F. As an illustration of one type of filler/role decomposition, positional roles, let S be the set of strings over the alphabet of symbols A ≡ {a, b, c} and let rk be the role of the kth symbol (from the left). The F = A and R = {r1, r2, …}. For the particular string acb, we have bpos(acb) = {a/r1, b/r3, c/r2}; note that the bindings constitute a set. To illustrate the other type of filler/role decomposition, contextual roles, for the same type of structure S, strings, let rx_y denote the role ‘preceded by symbol x and followed by symbol y ’. Then in this new decomposition bcon, acb has only one binding: bcon(acb) = {c/ra−b}. In this decomposition, a string is characterized by its trigrams.\nGiven a filler/role decomposition b for S, a TPR is defined by encoding each filler fk ∈ F by a filler tensor fk ∈ VF, and each role rk ∈ R by a role tensor rk ∈ VR. Role tensors are a principal innovation of TPR.\nThen the TPR of a structure s with bindings b(s) = {fk/rk} is the tensor s ≡ Σk fk ⊗ rk ∈ VS ≡ VF ⊗ VR ≡ {f ⊗ r | f ∈ VF, r ∈ VR}. Thus in TPR, binding is done via the tensor product. For the positional-role decomposition bpos, the TPR of s = acb is spos = a ⊗ r1 + b ⊗ r3 + c ⊗ r2. We use this type of positional-role TPR below in (18).\nNow consider the contextual-role decomposition bcon of S. Because bcon(acb) = {c/ra−b}, the TPR of s = acb is scon = c ⊗ ra_b. We need a tensor to encode each role rx_y. Such a role is itself a structure, which can be given a filler/role decomposition such that rx_y is the binding x/r—_y, giving rise to the encoding tensor rx_y ≡ x ⊗ r—_y. For the role tensor r—_y we can choose the filler vector y, so rx_y = x ⊗ y. Then the TPR for s = acb is scon = c ⊗ [a ⊗ b]. An isomorphic encoding is the more mnemonic scon = a ⊗ c ⊗ b. Thus here the role tensors in VR are of order 2, and the vector encoding a string is a tensor of order 3.\nOur primary interest is in vectorial encodings of propositions such as P(a, b, c). We will adopt a contextual TPR such that the encoding of this proposition is P ⊗ a ⊗ b ⊗ c. The corresponding TPR encoding of a set of propositions B = {Pk(ak, bk, ck)} is B = Σk Pk ⊗ ak ⊗ bk ⊗ ck. The space of such order-4 tensors B is a vector space of dimension 4d, assuming each symbol is encoded by an order-1 tensor over Rd, i.e., for each symbol a the components of its tensor encoding are [a]γ, γ ∈ 1:d.\nWe will assume that the order-1 tensors fk chosen to encode the symbols fk form an orthonormal set: fj ⋅ fk = δjk ≡ [1 IF j = k ELSE 0]. This assures that TPRs can be unbound with perfect accuracy, via the inner product, which ‘undoes’ the outer product binding. As an example, consider a set of propositions B = {Pk(ak, bk, ck)}, only one of which has the form P2(a2, b2, x). We can find the unique value of x (namely c2) such that P2(a2, b2, x) ∈ B from B’s TPR encoding B = Σk Pk ⊗ ak ⊗ bk ⊗ ck, by computing x = B •15,26,37 (P2 ⊗ a2 ⊗ b2), i.e.,\nxγ = Bπαβγ [P2]π[a2]α[b2]β = (Σk [Pk]π[ak]α[bk]β[ck]γ)[P2]π[a2]α[b2]β = Σk [Pk ⋅ P2][ak ⋅ a2][bk ⋅ b2][ck]γ = [c2]γ\nbecause for every value of k except k = 2, either Pk ≠ P2 or ak ≠ a2 or bk ≠ b2, so [Pk ⋅ P2][ak ⋅ a2][bk ⋅ b2] = 0.\nComment. While we assume for convenience throughout the paper that the tensors encoding symbols are orthonormal, there is no assumption that they are 1-hot vectors; we presume they are distributed vectors in which many elements are non-zero. Further, all results here would continue to hold if the tensors encoding symbols were merely linearly independent; unbinding would then be done with unbinding filler tensors fk+ replacing the filler tensors fk themselves. The unbinding example of the previous paragraph would become x = B •15,26,37 (P2+ ⊗ a2+ ⊗ b2+), where the unbinding tensors fk+ are defined so that fj ⋅ fk+ = δjk. Such vectors must exist if the filler tensors {fk} are linearly independent (essentially, fk+ is the kth row of the inverse of the matrix F which has fk as its kth column; F is invertible if the {fk} are linearly independent)."
    }, {
      "heading" : "1 BABI EXAMPLE",
      "text" : "Consider the example in (2). “@(a, b, t)” denotes “a is at b at time t” (or “a is co-located with b at time t”). (In Lee et al. (2016), the gloss is “a belongs to b” or “a is contained in b”.) ℺ is the information-question operator; assuming that the denotation of a question is the set of answers, ℺x.P(x) denotes “the x’s for which it the case that P(x)” = {x | P(x)}. The English question “where was the apple before the kitchen?” is assigned a Logical Form (LF) that can be glossed as “the location x for which it is the case that a [the apple] was at x at some time t and the apple was at k [the kitchen] at the time t′ immediately following t”.\n(2) An example of a type-3 question from the bAbI task:\na. John picked up an apple @(a, j, t1)\nb. John went to the office @(j, f, t2)\nc. John went to the kitchen @(j, k, t3)\nd. John dropped the apple ¬ @(a, j, t4)\ne. Where was the apple before the kitchen? → the office\n℺x.∃t,t′. @(a, x, t) & @(a, k, t′)\n& ≺(t, t′)\nHere we will assume given a [surface string → LF] semantic parser that generates the right column of (2) given the left column. We strive to separate issues of commonsense inference per se from issues of NLP narrowly construed, such as identifying: the semantic predicates corresponding to English words, the referents of referring expressions, the antecedents of anaphoric expressions, and the content of elided material. We thus assume given NLP procedures for performing such computations and focus exclusively on the problem of commonsense reasoning with distributed, vectorial representations.\nAll symbols in the predicate logic analysis are encoded in TPR as vectors, or order-1 tensors, in Rd. Thus @ is a vector encoding the symbol ‘@’, and @π ∈ R, π = 1:d, are its d real components. In general, the symbol-encoding vectors such as @ are distributed, in the sense that many components are non-zero (they are not in general 1-hot vectors). For convenience, here we assume these vectors are an orthonormal set (what is actually required is only that they be linearly independent).\nAt each time ti, the reasoning process is in a state B(ti) which we take to be the set of propositions constituting the knowledge base of facts concerning the problem situation; this grows monotonically with ti, as more information arrives: the LF form of the ith sentence, L(ti). “≺(t, t′)” denotes the proposition “the time t immediately precedes the time t′ ”. As illustrated in (2), we will often notate times as “ti”, i ∈ N, where ∀i. ≺(ti, ti+1). The times {ti} have TPRs {ti} ⊂ Rd that are linearly independent, so there is a linear operator T on Rd satisfying (3).\n(3) Time-increment operator T\nT ti = ti+1\nThe TPR of the time-ti knowledge base B(ti) is the tensor B(ti). This fourth-order tensor is the sum of the TPRs of propositions of the form @(x, y, t) or ≺(t, t′, ø); ø is a dummy symbol used for convenience to make ≺, like @, a predicate that takes 3 arguments. The propositions are given a contextual TPR:\n(4) TPR of propositions\na. @(x, y, t) @ ⊗ x ⊗ y ⊗ t\nb. ≺(t, t′, ø) ≺ ⊗ t ⊗ tʹ ⊗ ø\nThe four indices in Bπαβτ can be thought of as the proposition-, first-argument-, second-argument, and third-argument-indices. For a proposition with predicate @ such as @(j, k, t) (2c) or @(a, j, t′) (2a), α is the index of an actor- or object-vector, β is the index of a location- or actor-vector, and τ is the index of a timevector: the TPR of such proposition is bπαβτ = @π jα kβ tτ or @π aα jβ t′τ.\nThe reasoning in example (2) requires two rules of inference:\n(5) Transitivity Axiom for @\n∀x,y,z,t. @(x, y, t) & @(y, z, t) ⇒ @(x, z, t)\n(6) Persistence Axiom for @\n∀x,y,t,t′. @(x, y, t) & ≺(t,t′) ⇒ @(x, y, t′)\nIn the vectorial reasoning system we develop, the persistence axiom can be applied at every time t, deriving positions at the immediately following time t′. Expressions like (2d) “John dropped the apple” are interpreted as ¬@(a, j, t) “not: the apple is at John [at time t]”, and the tensor b encoding this proposition will be the negation of the vector encoding “the apple is at John”; b will simply cancel the vector for “the apple is at John” that was generated by the persistence axiom. Then at subsequent times there is no longer an encoded proposition @(a, j, t) that the persistence axiom can propagate forward.\nThe reasoning needed for (2) can be expressed as\nt1: the apple is at John\nt2: ⇒persistence the apple is at John, John is at the office ⇒transitivity the apple is at the office\nt3: ⇒persistence the apple is at John, John is at the kitchen ⇒transitivity the apple is at the kitchen\nt4: ⇒persistence the apple is at the kitchen, the apple is at John\nThe TP encodings of the inference rules (5)−(6) are given in (7)−(8); these encodings are derived by a general procedure that will be illustrated in Section 3.\n(7) TP encoding of the Transitivity Axiom for @\na. ∀x,y,z,t. @(x, z, t) ⇐ @(x, y, t) & @(y′, z, t) & [y = y′] b. [V(B(t))]π″αβ ′τ″ = @π″ tτ″ [B(t)]παβτ @πtτ [B(t)]π′α′β′τ′ @π′tτ′ δβα′ + [B(t)]π″αβ ′τ″ c. V(B(t)) = V[B(t), B(t); t] d. V = a multilinear tensor operation encoding inference from the Transitivity Axiom:\ni. ∀x,y,z,t;∀p ∈T . p(x, z, t) ⇐ p(x, y, t) & p(y, z, t)\nii. V[X, Y; t]π″αβ ′τ″ = Σp ∈T pπ″ (pπ[X]παβτtτ) (pπ′[Y]π′ββ′τ ′ tτ ′) tτ″ iii. (Modified) Penrose diagram (for one p ∈ T ):\nV[X, Y; t] = X Y | | | | | | | | | | | | p p t p t t | | p( x, z, t) ⇐ p( x, y, t) & p( y, z, t)\n(8) TP encoding of the Persistence Axiom for @ [note that ∀i. T ti−1 = ti, so ≺(t,t′) iff t’ = T t iff t = T−1 t′]\na. ∀x,y,t,t′. @(x, y, t′) ⇐ @(x, y, t) & ≺(t,t′)\nb. B(ti) = (1 + Σx,y [@ ⊗ x ⊗ y ⊗ ti][@ ⊗ x ⊗ y ⊗ T−1 ti]⊤) B(ti−1) c. B(ti) = (1 + P(ti)) B(ti−1) d. P(t) = matrix operating on B-tensors that encodes inference from the Persistence Axiom for @\ni. [P(ti) B(ti−1)]πξητ = P(t)πξητ, π′ξ′η′τ′ [B(ti−1)]π′ξ′η′τ′ ii. P(t)πξητ, π′ξ′η′τ′ = @π δξξ′ δηη′ tτ @π′ [T−1]τ′τ″ tτ″\niii. Penrose diagram: P(t) = @ δ δ t @ T−1 t\nHere and throughout the paper, except where explicitly stated otherwise, we deploy the Einstein Summation Convention, according to which repeated indices are implicitly summed over all their values; e.g., in (7b) there is an implicit sum over π, β, τ, π′, α′, and τ′. In (7b) and (8d.ii), δ is the Kronecker δ: δij ≡ [1 IF i=j ELSE 0].\nIn the general case (7d.ii), the encoding of inference using the Transitivity Axiom involves a sum over the set T of all transitive predicates; we will only be using the single transitive predicate @ here, and the other expressions in (7)−(8) deal only with that predicate, which is persistent as well as transitive.\nIn (modified) Penrose Tensor Diagrams such as (7d.iii) and (8d.iii), each box denotes a tensor and the nth line from the left that emanates from the box for tensor A denotes the nth index of A; there are m such lines if A is an mth-order tensor. When two lines are joined, the values of those two indices are set equal and there is sum over all values for the index, as explicitly shown for β in (7d.ii), the algebraic expression denoted by the Penrose Diagram (7d.iii). Penrose Diagrams enable complex tensor equations to be written precisely without any indices, thereby making the structure of the equations more transparent.\nThe correspondence between a predicate logic expression and a Penrose Tensor Diagram will be made explicit in Section 3, but the juxtaposition in (7d.iii) of the Penrose diagram and the corresponding predicate logic expression beneath it already suggests the nature of the correspondence visually, with colors of predicate logic symbols matching the colors of their corresponding tensors in the diagram as well as the colors of their corresponding indices in the algebraic expressions (7d.ii), (8d.i).\nIn (8b)−(8c), the identity matrix over tensors, 1, ensures that all the propositions encoded in B at time ti−1 (propositions about the problem situation at all times t ≤ ti−1) are carried over and also encoded in B at time ti.\nAn example of the use of the Transitive Inference procedure of (7) is given in (9). (Recall that the TPRs of all symbols form an orthonormal set.)\n(9) Example of Transitivity Inference using (7)\na. Let B(t2) = {@(a, j, t1), @(a, j, t2), @(j, k, t2)}; result of transitive inference: add @(a, k, t2)\nb. Then B(t2) = @ ⊗ a ⊗ j ⊗ t1 + @ ⊗ a ⊗ j ⊗ t2 + @ ⊗ j ⊗ k ⊗ t2\nc. B(t2) ⊗ B(t2) = @ ⊗ a ⊗ j ⊗ t1 ⊗ @ ⊗ j ⊗ k ⊗ t2 + @ ⊗ a ⊗ j ⊗ t2 ⊗ @ ⊗ j ⊗ k ⊗ t2 + ⋯\nd. [V(B(t2))]π″αβ ′τ″ = @π″ t2τ″ [B(t2)]παβτ @π t2τ [B(t2)]π′α′β′τ′ @π′t2τ′δβα′ + [B(t2)]π″αβ ′τ″\n= @π″ t2τ″[@ ⊗ a ⊗ j ⊗ t1 ⊗ @ ⊗ j ⊗ k ⊗ t2] παβτ π′α′β′τ′ @πt2τ@π′t2τ′δβα′\n+ @π″ t2τ″[@ ⊗ a ⊗ j ⊗ t2 ⊗ @ ⊗ j ⊗ k ⊗ t2] παβτ π′α′β′τ′ @πt2τ@π′t2τ′δβα′ + ⋯ + [B(t2)]π″αβ ′τ″\n= @π″ t2τ″[@π@π]aα[jβ jα′δβα′][t1τt2τ][@π′@π′]kβ′[t2τ′t2τ′]\n+ @π″ t2τ″[@π@π]aα[jβ jα′δβα′][t2τt2τ][@π′@π′]kβ′[t2τ′t2τ′] + ⋯ + [B(t2)]π″αβ ′τ″\n= @π″ t2τ″aα kβ′ + [B(t2)]π″αβ ′τ″ = [@ ⊗ a ⊗ k ⊗ t2]π″αβ ′τ″ + [B(t2)]π″αβ ′τ″\ne. i.e., V(B(t2)) is the TPR of: @(a, k, t2) ∪ B(t2)\nIn the evaluation of V(B(t2)) in (9d), because the TPRs of all symbols are orthogonal, all terms in B(t2) ⊗ B(t2) (with components [B(t2)]παβτ[B(t2)]π′α′β′τ′) are annihilated except the single term which is the TPR of the proposition pair 〈@(a, j, t2), @(j, k, t2)〉, because the inner product with @πt2τ@π′t2τ′δβα′ gives 0 for any pair 〈p(x, y, t), p′(z, w, t′)〉 unless p = @ = p′, y = z, and t = t2 = t′; e.g., the factor in red brackets [t1τt2τ] is 0 because t1 and t2 are orthogonal. (The factors [vµvµ] all equal 1 because the TPRs of all symbols are normalized to length 1.)\nAt each consecutive time ti we also have the following update rule (10) for the (immediate) Temporal Precedence relation ≺ (recall the definition of the time-increment operator T (3)).\n(10) Update rule for the symbolic Temporal Precedence relation T = ≺ and its TPR T\na. T (ti) = ≺(ti−1, ti) ∪ T (ti−1)\nb. T(ti) = ≺ ⊗ ti−1 ⊗ ti + T(ti−1) = ≺ ⊗ ti−1 ⊗ T ti−1 + T(ti−1)\nThe procedure for building the knowledge base B incrementally, as the sentence Si pertaining to each time ti is processed, is given in (11).\n(11) TP Reasoning Algorithm\na. Goal: knowledge base B {facts from story} ∪ {inferred facts} B = @ ⊗ ⊗ J⊗ t1 + ≺ ⊗ t1⊗ t2 ⊗ ø + ⋯ To construct B(ti) / B(ti), loop over sentences i in story: b. B(ti−1) given B(ti−1) already computed c. inferences from Persistence Axiom\n∀k,∀p ∈ P. p(a1, …, am; ti−1) ⇒ p(a1, …, am; tk)\nB(ti) ← B(ti−1) + P(ti) B(ti−1) P(tk) = Persistence matrix (over tensors)\nd. update ≺ add ≺(ti−1, ti)\nB(ti) ← B(ti) + Ti Ti = ≺ ⊗ ti−1 ⊗ T ti−1 T = time-update matrix; ti = T ti−1\ne. add L(ti) = LF of ith sentence e.g., John picked up an apple\nB(ti) ← B(ti) + L(ti) e.g. @ ⊗ A ⊗ J ⊗ t1 = L(t1)\nf. repeat until no change: g. inferences from Transitivity Axiom:\n∀x,y,z,t,p∈T. p(x, y, t) & p(y, z, t) ⇒ p(x, z, t)\nB(ti) ← B(ti) + V[B(ti), B(ti); ti] V = multilinear tensor operation of\nTransitive Inference This algorithm, processing the example (2), will produce (12).\n(12) Algorithm (11) processing example (2)\nSentence i LF: L(i) Inferences T update Explanation\na. John picked up an apple\n@(a, j, t1)\nb. John went to the office\n@(j, f, t2) @(a, j, t2) @(a, f, t2)\n≺(t1, t2) ∀x,y,t,t′. @(x, y, t) & ≺(t,t′) ⇒ @(x, y, t′) Persistence\n∀x,y,z,t. @(x, y, t) & @(y, z, t) ⇒ @(x, z, t) Transitivity\nc. John went to the kitchen\n@(j, k, t3) @(a, j, t3) @(a, k, t3)\n≺(t2, t3)\nd. John dropped the apple\n¬ @(a, j, t4) @(a, k, t4) ≺(t3, t4) contributes −@ ⊗ a ⊗ k ⊗ t4 which cancels inference from Persistence Axiom\ne. Where was the apple before the kitchen?\n→ the office\n℺x.∃t,t′. @(a, k, t′) & @(a, x, t) & ≺(t, t′)\nt′ = t2, t = t3 x = f\nTo answer the query, we construct its TP encoding†:\n(13) The query\nWhere was the apple before the kitchen?\n℺x.∃t′,t. @(a, k, t′) & @(a, x, t) & ≺(t, t′, ø)\nx = B B B | | | | | | | | | | | | | @ a k @ a ≺ ø\nPenrose Tensor Diagram\nx β\n2\n= B π\n1 α 1 β 1 γ 1\nB π\n2 α 2 β 2 γ 2\nB π\n3 α 3 β 3 γ 3\n@ π\n1\na α\n1\nk β\n1\n@ π\n2\na α\n2\n≺ π\n3\nø γ\n3\nδ γ\n1 β 3\nδ γ\n2 α 3\nComponentwise expression\n† This tensor equation is the TP encoding of the form of the query expression given in (13); an alternative that replaces one factor of B with a factor T is the TP encoding of an alternative form of the query: ℺x.∃ti. @(a, k, ti+1) & @(a, x, ti). Either form of the query is slightly simplified; the additional requirement “x ≠ k” is needed if @(a, k, t) persists across two consecutive times. In the TP encoding, this yields an additional factor, or a simple post-processing step, that projects onto the subspace orthogonal to k."
    }, {
      "heading" : "2 SIMPLIFICATION",
      "text" : ""
    }, {
      "heading" : "2.1 Deriving the simplification for two-place predicates",
      "text" : "The first simplification is to omit the vector encoding the relation “is at”, which we’ve written “@”. As shown in Lee et al. (2016), for most of the bAbI problem types, this is the only relation needed (they are “uni-relational”), so it is not necessary to encode it explicitly: all items have the same initial tensor factor @. This simplification is shown in the third column of table (14). The matrix-algebra expression xyT and the tensor expression x ⊗ y define exactly the same elements [xyT]jk = xjyk = [x ⊗ y]jk.\n(14) Simplification sufficient for the bAbI task: implicit is at predicate, implicit time stamps\nSymbolic Full TPR Simplification: 1 2 3 4\n{@(x, y, t1), @ ⊗ x ⊗ y ⊗ t1 xy⊤ ≅ x ⊗ y = x ⊗ y ⊗ 1 + y ⊗ z ⊗ 0 = x ⊗ y ⊗ t1 + y ⊗ z ⊗ t2 @(y, z, t2)} + @ ⊗ y ⊗ z ⊗ t2 yz⊤ y ⊗ z 0 1\nThe second simplification is to replace the time stamps with slots in a “memory”; in table (14), these slots are shown as a vertical queue in the “Simplification: 1” column. Rather than explicitly including a final tensor factor ti that encodes an explicit time stamp, we just locate the item for time ti in the ith position in the queue. If we think of these memory positions as locations in a vector, as shown in the “Simplification: 2” column, however, we can recognize the vector as a sum of two vectors, each the tensor product of the cell entry with a unit column vector, as spelled out in the “Simplification: 3” column. As indicated in the “Simplification: 4” column, this reduces to just the Full TPR representation (with the initial tensor factor @ omitted) — once we identify t1 = (1, 0), t2 = (0, 1). This analysis obviously trivially extends to any number of time steps.\nWith the two simplifications made above, the tensor implementation of inference from the Transitivity Axiom becomes:\n(15) Simplified Transitive Inference operation (predicate p and time t factors not made explicit)\na. Full form: V[X, Y; t]π″αβ ′γ″ = Σp ∈T pπ″ (pπ[X]παβγtγ) (pπ′[Y]π′ββ′γ ′ tγ ′) tγ″ b. Simplified form: V[X, Y]αβ ′ = [X]αβ[Y]ββ′ = [XY ]αβ ′, i.e., simple matrix multiplication\nThis is exactly the form that transitive inference takes in Lee et al. (2016); e.g., in the example type-2 question discussed there, X = fmT and Y = mgT — for @(football, mary, t) and @(mary, garden, t) — are combined by matrix multiplication to give XY = f (mT m) gT = fgT — for @(football, garden, t)."
    }, {
      "heading" : "2.2 Deriving the simplification for three-place predicates",
      "text" : "The analyses in Lee et al. (2016) of questions in categories 2, 3 and 5 involve the binding of 3 entities rather than 2. For example:\n(16) The representation of “Mary travelled to the garden [from the kitchen]” is\nm (g ∘ k)T, where g ∘ k ≡ U [g ; k]; U: R2d → Rd, U [g ; k] ≡ R0 g + R1 k; R0, R1: Rd → Rd\nLet all of the n relevant entities (actors, objects, locations, etc.) {el | l ∈ 1:n} be represented by unit vectors {êl} in Rd, and suppose d = 2m, m ∈ N, with m ≥ n. (These assumptions apply to the implementation discussed in Lee et al. (2016).) Assume the generic case in which the {êl} are linearly independent, and let the n-dimensional subspace of Rd that they span be E. Let the restrictions of R0, R1 to E be denoted R0 ≡ R0|E , R1 ≡ R1|E . Assume the generic case in which R0, R1 are non-singular, so that {R êl ≡ êl0} ⊂ Rd, {R êl ≡ êl1} ⊂ Rd are each linearly independent sets. In order that U be information-preserving, assume that these\ntwo sets are linearly independent of each other, i.e., that the union of these two sets is also a linearly independent set {êlβ | l ∈ 1:n, β ∈ 0:1} ⊂ Rd. This is possible because 2n ≤ 2m = d.\nBecause the Rβ are non-singular, there exist inverses R0−1, R1−1 respectively defined over span{êl0} ≡ S0, span{êl1} ≡ S1; these are linearly independent n-dimensional subspaces of Rd. There is an extension R0+ of R0−1 to S ≡ span(S0 ∪ S1) = range(U|E) such that R0+|S0 = R0−1 and R0+|S1 = 0 (namely R0+ (Σlβ ylβ êlβ) = Σl yl0 êl ; since R0: Σl xl êl ↦ Σl xl êl0, we get R0+R0 = 1|E ). Similarly there exists R1+ such that R1+|S1 = R1−1 and R1+|S0 = 0. Thus:\n(17) Inverting ∘\nR0+(a ∘ b) = a, R1+(a ∘ b) = b, for all a, b ∈ E\nThe binding in (16) can be identified as a Contracted TPR as follows. Recall that the matrix product is a kind of tensor inner product, that is, a contraction of a tensor (outer) product: [Mv]k ≡ Σj vjMkj ≡ [C13 v ⊗ M]k where v is the vector v considered as an order-1 tensor and M is the matrix M considered as an order-2 tensor. In particular, [R0 a]k = [C13 a ⊗ R0]k and [R1 a]k = [C13 a ⊗ R1]k . Thus:\n(18) The representation of “m 2 travelled Δ 3; Δ 3 = to g 0 from k 1” as a Contracted TPR\n[m (g ∘ k)T]jk = [m ⊗ Δ]jk “ m 2 travelled Δ 3”: contextual-binding of fillers m, Δ of slots 2, 3\nΔ = C13[g ⊗ R0 + k ⊗ R1] “ Δ 3 = to g 0 from k 1”: positional-binding of fillers g, k to roles 0, 1\nR0 and R1 are the tensors representing the roles 0, 1 in “to 0 from 1”.\nAlternatively, eliminating the displacement Δ, we have, for “ m 2 travelled to g 0 from k 1”:\n[m (g ∘ k)T]jk = C24[m ⊗ (g ⊗ R0 + k ⊗ R1)]jk\nUnbinding the actor a by left-multiplying by aT gives the displacement Δ of a that is represented:\n[aT m (g ∘ k)T]k = Σj [a]j [m (g ∘ k)T]jk = (Σj [a]j [m]j) (g ∘ k)Tk = (a ⋅ m) (g ∘ k)Tk = (a •12 C24[m ⊗ (g ⊗ R0 + k ⊗ R1)])k ≡ C12,35 [a ⊗ m ⊗ (g ⊗ R0 + k ⊗ R1)]k\n= (a •12 m) C13[g ⊗ R0 + k ⊗ R1]k\nThe factor (a •12 m) = a ⋅ m = 1 if a = m (entity vectors are normalized), while a ⋅ m is considerably less than 1 if the n entity vectors are generically distributed in a considerably larger space Rd, d ≥ 2n; indeed, we have been assuming that these n vectors have been chosen to be orthogonal, in which case we have exactly a ⋅ m = 0 when a ≠ m. When a = m the result is C13[g ⊗ R0 + k ⊗ R1], the Contracted TPR of the pair 〈g, k〉 = Δ: this tells us that the represented displacement of m was: to g from k. The entities g and k can be extracted from Δ via the inner products with the duals of the role tensors, as is standard for TPRs: g = Δ •13 R0+, k = Δ •13 R1+; these equations are the tensor counterparts of R0+(R0 g + R1k) = g , R1+(R0g + R1k) = k.\nIn Lee et al. (2016), questions in category 5 are treated with an operation * that functions identically to ∘, with d × 2d matrix V rather than U. The same analysis just given for ∘/U applies to show that the */V method amounts to a Contracted TPR."
    }, {
      "heading" : "2.3 Deriving the simplification for Path Finding (bAbI category 19)",
      "text" : "An example of a bAbI Category 19 problem is given in (19).\n(19) Path-Finding: example problem\nSentence i LF: L(i) Full TPR Model\na. The bedroom is south of the hallway. s(b, h) s ⊗ b ⊗ h b = Sh\nb. The bathroom is east of the office. e(a, o) e ⊗ a ⊗ o a = Eo\nc. The kitchen is west of the garden. w(k, g) w ⊗ k ⊗ g k = Wg\nd. The garden is south of the office. s(g, o) s ⊗ g ⊗ o g = So\ne. The office is south of the bedroom. s(o, b) s ⊗ o ⊗ b o = Sb\nf. How do you go from the garden to the bedroom? ℺P.P(g, b)\n→ P = p[n, n]\nThe expression “p[s,w]” denotes “the path consisting of west then south”. p accepts as an argument a list of directions, so that, in general, “p[dn, …, d1]” denotes the path consisting of d1 (∈ {n, s, e, w}) followed by d2 followed by … followed by dn.\nThe rules of inference needed to solve such Path-Finding problems are given in (20).\n(20) Axioms/rules of inference for Path-Finding problems: ∀x,y,z,d,d1,…,dn,d′1,…,d′n′ …\na. n(x, y) ⇒ s(y, x); s(x, y) ⇒ n(y, x); e(x, y) ⇒ w(y, x); w(x, y) ⇒ e(y, x)\nb. d(x, y) ⇒ p[d](x, y)\nc. p[dn, …, d1](z, y) & p[d′n′, …, d′1]( y, x) ⇒ p[dn, …, d1, d′n′, …, d′1](z, x)\nThe rules in (20a) express the inverse semantics within the pairs n ↔ s, e ↔ w. The rule (20b) states, for example, that if x is (one block) north of y (on a Manhattan-like grid of locations) — n(x, y) — then the path consisting of (a one-block step in the direction) north — p[n] — goes to x from y.\nFinally (20c) asserts that if p[dn, …, d1] — the path consisting of d1 (∈ {n, s, e, w}) followed by d2 followed by … followed by dn — leads to z from y, and the path p[d′n′, …, d′1] — consisting of d′1 followed by … followed by d′n′ — leads to y from x, then p[dn, …, d1, d′n′, …, d′1] leads to z from x. This rule resembles the transitivity rule p(z, y) & p( y, x) ⇒ p(z, x), but whereas transitivity involves only a single relation, the path-finding rule involves the productive combination of multiple relations. In this sense, Path Finding is a “multi-relational” problem, whereas all the simpler bAbI problem types, reducible to transitivity, are “uni-relational” — a main point of Lee et al. (2016).\nReasoning with the multi-relational axioms in (20) can be implemented in TPR as in the simpler case of transitive inference (5) above: (7), (11). The third column of table (19) shows the full TPR encoding of the statement of the example problem. The symbolic knowledge base B is a set of stated and inferred propositions {di(xi, yi)} ∪ {p[Pk](wk, zk)}, with Pk = dknk⋯d k 2dk1. The TPR of B, B, is the direct sum of tensors of the forms di ⊗ xi ⊗ yi and p ⊗ Pk ⊗ wk ⊗ zk, where Pk ≡ dknk ⊗ ⋯ ⊗ d k 2 ⊗ dk1. To reply to the query “How do you go from u to v?” we test possible paths P to see whether P leads to v from u; in the bAbI task, only paths up to length 2 need to be considered. To test whether p[P](v, u) ∈ B, we take the inner product of B with p ⊗ P ⊗ v ⊗ u; the result is 0 or 1, the truth value of p[P](v, u).\nThere is a simplification of the full TP analysis that relies on a vectorial ‘model’ of the axioms (20), in the sense of model theory in mathematical logic: a set of linear-algebraic objects which are inter-related in ways that satisfy the axioms. The final column of table (19) shows the corresponding representations in\nthis simpler implementation. In the full TP analysis, the vectors encoding locations and directions are arbitrary orthonormal vectors. In the simpler model, there are systematic relations between the encodings of locations and directions. Specifically, the directions north and east are encoded by d × d matrices N, E, where locations x are encoded by vectors x ∈ Rd. Rather than having inference relations such as (20a) implementing the inverse relationships among directions, the matrices encoding south and west are systematically related to those encoding north, east, by: S = N−1, W = E−1. (This requires that N, E be nonsingular.) And rather than adding to B an arbitrary fact-tensor n ⊗ x ⊗ y, the truth of n(x, y) is encoded in the relation among the encoding vectors and matrices themselves: x = Ny. These conditions ensure that the vectorial encodings of positions and directions provide a model for the axioms (20a): n(x, y), encoded as x = Ny, entails y = N−1x = Sx, the encoding of s(y, x).\nIf L is the set of all possible locations for the given problems, then {Ny | y ∈ L} and {Ey | y ∈ L} must be independent sets of vectors, i.e., we need the following condition: range(N|L) and range(E|L) are linearly independent, so 2|L| ≤ d. (This is reminiscent of the conditions on R0, R1 in (16).)\nFor paths, we let the encoding of p[dn, …, d1](z, y) be z = Dn⋯D1y. These encodings provide a model for the composition axiom, since the encodings of p[dn, …, d1](z, y) and p[d′n′, …, d′1]( y, x), z = Dn⋯D1y and y = D′n′ ⋯ D′1′ x, entail that z = Dn⋯D1D′n′ ⋯ D′1′ x, the encoding of p[dn, …, d1, d′n′, …, d′1](z, x). Also, the base case expressed by axiom (20b) is satisfied, since d(x, y) and p[d](x, y) have the same encoding, x = Dy.\nIn the simplified approach implemented in Lee et al. (2016), a set of position vectors and direction matrices encoding the statements given in the problem is generated. Then, to test whether p[P](v, u) for a given path P, to determine whether P answers the query “how do you go from u to v?”, the validity of the equation v = Pu is determined, where P = D or D2D1 in accord with P = p[d] or p[d2, d1]."
    }, {
      "heading" : "2.4 Performance of simplification on bAbI dataset",
      "text" : "The simplification of the full TPR reasoning analysis described above was implemented and the results reported in Lee et al. (2016) are briefly summarized in (21).\n(21) Performance of the simplification on the bAbI tasks\n100% in all question categories except:\nC5: 99.8%\nC16: 99.5%\nBecause the present analysis performs inference by programmed vector procedures rather than learned network computations, this performance cannot be directly compared to that of previous work addressing the bAbI task (including, notably, Peng et. al (2015)’s Neural Reasoner which achieved 66.4%/97.9% and 17.3%/87.0% on tasks 17 and 19, with 1k/10k training examples, respectively; these are the most difficult tasks, on which the previous best performance was 72% and 36%). (Previous best performance on C5/C16 were 99.3%/100%, by the strongly supervised Memory Network of Weston, Chopra & Bordes (2014).)"
    }, {
      "heading" : "3 GENERAL TREATMENT",
      "text" : "(22) General case of query construction\na.\nb.\nc.\nHow the particular example query (13) follows from the general case (22) is spelled out in (23).\n(23) Derivation of the query (13) from the general case (22)\na. ℺x.∃t′,t. @(a, k, t′) & @(a, x, t) & ≺(t, t′, ø)\nb. ℺x22.∃e31,e32. p1(c11, c21, e31) p1 = @; c11 = a, c21 = k, e31 = t′ & p2(c12, x 2 2, e 3 2) p2 = @; c 1 2 = a, v 2 2 = x, e 3 2 = t\n& p3(e13, e 2 3, c 3 3) p3 = ≺; e13 = t, e23 = t′, c33 = ø & [e31=e 2 3]&[e 3 2=e 1 3]\nc. ans γ22 = Bπ1 γ11 γ21 γ31 Bπ2 γ12 γ22 γ32 Bπ3 γ13 γ23 γ33 [c 1 1]γ11 [c 2 1]γ21 [c 1 2]γ12 [c 3 3]γ33 δγ31 γ23 δγ32 γ13\nd. xβ2 = Bπ1 α1 β1 γ1 Bπ2 α2 β2 γ2 Bπ3 α3 β3 γ3 aα1 kβ1 aα2 øγ3 δγ1β3 δγ2α3\nAnalogous methods allow general TP instantiation of rules of inference, from which the particular forms in (7)−(8) can similarly be derived.\nÓx kx(1) ix(1)!x kx(q) ix(q) ∃e ke (1) ie (1)!e ke (s) ie (s) k∈1:n Λpk(vk1 ,…,vkm) j∈1:E Λ[e ′ke ( j) ′ie ( j) = e ′′ke ( j) ′′ie ( j) ] v k i ∈{c k i ,x k i ,e k i }\nans γ\nkx (1) ix (1)!γ kx ( q )\nix ( q ) = B\nπkγ k 1!γ k\nm [ck i ]γ k\ni\ni ,k:vk i =ck\ni ∏ k∈1:n ∏ δ\nγ ′ke ( j ) ′ie ( j ) γ ′′ke ( j ) ′′ie ( j )\nj∈1:E ∏"
    } ],
    "references" : [ {
      "title" : "Reasoning in vector space: An exploratory study of question answering",
      "author" : [ "Lee", "Moontae", "He", "Xiaodong", "Yih", "Wen-tau", "Gao", "Jianfeng", "Deng", "Li", "Smolensky", "Paul" ],
      "venue" : "Under review for",
      "citeRegEx" : "Lee et al\\.,? \\Q2016\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2016
    }, {
      "title" : "Tensor product variable binding and the representation of symbolic structures in connectionist systems",
      "author" : [ "Smolensky", "Paul" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Smolensky and Paul.,? \\Q1990\\E",
      "shortCiteRegEx" : "Smolensky and Paul.",
      "year" : 1990
    }, {
      "title" : "The Harmonic Mind: From Neural Computation to OptimalityTheoretic Grammar. Volume I: Cognitive Architecture",
      "author" : [ "Smolensky", "Paul", "Legendre", "Géraldine" ],
      "venue" : null,
      "citeRegEx" : "Smolensky et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Smolensky et al\\.",
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "We also show the simplification in Section 2 derives the inference methods described in Lee et al. (2016); this shows how the simple methods of Lee et al.",
      "startOffset" : 88,
      "endOffset" : 106
    }, {
      "referenceID" : 0,
      "context" : "We also show the simplification in Section 2 derives the inference methods described in Lee et al. (2016); this shows how the simple methods of Lee et al. (2016) can be formally extended to more general reasoning tasks.",
      "startOffset" : 88,
      "endOffset" : 162
    }, {
      "referenceID" : 0,
      "context" : "(In Lee et al. (2016), the gloss is “a belongs to b” or “a is contained in b”.",
      "startOffset" : 4,
      "endOffset" : 22
    }, {
      "referenceID" : 0,
      "context" : "As shown in Lee et al. (2016), for most of the bAbI problem types, this is the only relation needed (they are “uni-relational”), so it is not necessary to encode it explicitly: all items have the same initial tensor factor @.",
      "startOffset" : 12,
      "endOffset" : 30
    }, {
      "referenceID" : 0,
      "context" : "This is exactly the form that transitive inference takes in Lee et al. (2016); e.",
      "startOffset" : 60,
      "endOffset" : 78
    }, {
      "referenceID" : 0,
      "context" : "The analyses in Lee et al. (2016) of questions in categories 2, 3 and 5 involve the binding of 3 entities rather than 2.",
      "startOffset" : 16,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "(These assumptions apply to the implementation discussed in Lee et al. (2016).) Assume the generic case in which the {êl} are linearly independent, and let the n-dimensional subspace of Rd that they span be E.",
      "startOffset" : 60,
      "endOffset" : 78
    }, {
      "referenceID" : 0,
      "context" : "In Lee et al. (2016), questions in category 5 are treated with an operation * that functions identically to ∘, with d × 2d matrix V rather than U.",
      "startOffset" : 3,
      "endOffset" : 21
    }, {
      "referenceID" : 0,
      "context" : "In this sense, Path Finding is a “multi-relational” problem, whereas all the simpler bAbI problem types, reducible to transitivity, are “uni-relational” — a main point of Lee et al. (2016).",
      "startOffset" : 171,
      "endOffset" : 189
    }, {
      "referenceID" : 0,
      "context" : "In the simplified approach implemented in Lee et al. (2016), a set of position vectors and direction matrices encoding the statements given in the problem is generated.",
      "startOffset" : 42,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "The simplification of the full TPR reasoning analysis described above was implemented and the results reported in Lee et al. (2016) are briefly summarized in (21).",
      "startOffset" : 114,
      "endOffset" : 132
    } ],
    "year" : 2016,
    "abstractText" : "In this paper we present the initial development of a general theory for mapping inference in predicate logic to computation over Tensor Product Representations (TPRs; Smolensky (1990), Smolensky & Legendre (2006)). After an initial brief synopsis of TPRs (Section 0), we begin with particular examples of inference with TPRs in the ‘bAbI’ question-answering task of Weston et al. (2015) (Section 1). We then present a simplification of the general analysis that suffices for the bAbI task (Section 2). Finally, we lay out the general treatment of inference over TPRs (Section 3). We also show the simplification in Section 2 derives the inference methods described in Lee et al. (2016); this shows how the simple methods of Lee et al. (2016) can be formally extended to more general reasoning tasks.",
    "creator" : "Word"
  }
}