{
  "name" : "1406.6605.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Jon Haël Brenas", "Rachid Echahed", "Martin Strecker" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 6.\n66 05\nv1 [\ncs .L\nO ]\n2 4\nJu n\n20 14\nSROIQσ is decidable\nJon Haël Brenas1 Rachid Echahed1 Martin Strecker2\n1 CNRS and University of Grenoble 2 Université de Toulouse / IRIT"
    }, {
      "heading" : "1 Introduction",
      "text" : "Description Logics [1] are logical formalisms for representing information about classes and objects. They are very often used as the basis of knowledge representation systems and have been used recently to develop OWL semantic web language, which can be viewed as an expressive Description Logic.\nThere is an impressive variety of Description Logics with diverse expressiveness and complexity, or even with or without decidability. Yet, all are tailored to describe an established and fixed ontology and reason about its properties.\nOur goal here is to consider properties over dynamic ontologies. We introduce the notion of substitutions to express changes of ontologies (e.g. addition or deletion of an element, respectively a pair of elements, of a concept, respectively of a role). We investigate the addition of such substitutions in the particular case of the logic SROIQσ, an extension of the logic SROIQ [2]. We mainly show that the problem of satisfiability in SROIQσ is still decidable.\nSect. 2 introduces SROIQσ, our version of SROIQ with substitutions. Sect. 3 defines the interpretations for that logic. Sect. 4 proves that SROIQσ is decidable by transforming formulae in SROIQσ to formulae in SROIQ. Sect. 5 illustrates such transformations. Finally, Sect. 6 concludes the paper."
    }, {
      "heading" : "2 Syntax",
      "text" : "Signature\nDefinition 1. Let C be a set of concept names including a subset N of nominals, R a set of role names including the universal role U and I a set of individuals. The set of roles is R ∪{R−|R ∈ R}, where a role R− is called the inverse role of R.\nTo avoid considering roles such as R−−, we define a function Inv such that Inv(R) = R− if R is a role name and Inv(R) = S if R = S−.\nRole axioms Role axioms state global properties of roles.\nDefinition 2. A strict partial order ≺ on a set A is an irreflexive and transitive relation on A. A strict partial order ≺ on the set of roles is called a regular order if ≺ satisfies, additionally, S ≺ R ⇔ S− ≺ R for all roles R and S.\nDefinition 3. A role inclusion axiom is an expression of the form w ⊆ R where R′ 6= U is a role names and w is either a role name, R− or RR. A role hierarchy Rh is a finite set of role inclusion axioms. A role inclusion axiom w ⊆ R′ is ≺-regular if w ≺ R′ or w = R− or w = RR. Finally, a role hierarchy Rh is regular if there exists a regular order ≺ such that each role inclusion axiom in Rh is ≺-regular.\nDefinition 4. Given a role hierarchy Rh, we define the relation ⊆∗ to be the transitive-reflexive closure of ⊆ over {R ⊆ S, Inv(R) ⊆ Inv(S)|R ⊆ S ∈ Rh}. A role R is called a sub-role (respectively a super-role) of a role S if R ⊆∗ S (respectively S ⊆∗ R).\nThe second possible kind of role axiom is the role assertion.\nDefinition 5. For roles R,S, we call the assertions Ref(R), Irr(R), Sym(R), Asy(R), Tra(R) and Dis(R,S) role assertions. They, respectively, mean that R is reflexive, irreflexive, symmetric, asymmetric, transitive and that R and S are disjoint.\nTra(R) is equivalent to RR ⊆ R and Sym(R) is equivalent to R− ⊆ R. One can thus assume that there are no such role assertions.\nConcepts\nDefinition 6. The set of concepts is defined as the smallest set containing: C ::= ⊥ (empty concept)\n| c (concept name) | ¬ C (negation) | C ⊓ D (conjunction) | C ⊔ D (disjunction) | (≥ n R C) (at least) | (< n R C) (no more than) | ∃R.C (exists) | ∀R.C (for all) | o (nominal) | ∃R.Self (local reflexivity) | Csubst (explicit substitution) where c is a concept name, R is a role, o is a nominal and C, D are concepts.\nSubstitutions, that appear in the last constructor, allow to modify roles and concepts by adding or removing individuals.\nDefinition 7. Given a role name R, a concept name C and individuals i and j, a substitution is: subst ::= ǫ (empty substitution)\n| [RS] (role substitution) | [CS] (concept substitution)\nA role substitution can be either: RS ::= R− (i, j) (deletion of relation instance)\n| R+ (i, j) (insertion of relation instance)\nwhile a concept substitution is either: CS ::= C − i (deletion of a concept instance)\n| C + i (insertion of a concept instance)\nComments SROIQσ doesn’t allow for complex role inclusion (that is role inclusion in which a string of roles is included in a role name) because it is not said that it would work well with the translation algorithm. Our version of SROIQ is thus extended in some aspects and reduced in others."
    }, {
      "heading" : "3 Interpretations and models",
      "text" : "Definition 8. As usual, an interpretation I = (∆I , .I) consists of a set ∆I, called the domain of I, and a valuation .I which associates to every concept name C a set CI such that CI ⊆ ∆I and to each role name R a binary relation RI such that RI ⊆ ∆I ×∆I. The valuation of a nominal o is a singleton and the valuation of the universal role U is the universal relation ∆I ×∆I . Finally, I ⊆ ∆I .\nAs usual, (R−)I = {(y, x)|(x, y) ∈ RI} and (RR)I = {(x, y)∃z ∈ ∆ such that (x, z) ∈ RI and (z, y) ∈ RI}.\nDefinition 9. An interpretation I satisfies a role inclusion axiom w ⊆ R, written I |= w ⊆ R′, if wI ⊆ RI . An interpretation is a model of a role hierarchy Rh if it satisfies all role inclusion axioms in Rh, written I |= Rh.\nAs for role assertion axioms, for each interpretation I and all x, y, z ∈ ∆I, we have: I |= Sym(R) iff (x,y) ∈ RI ⇒ (y,x) ∈ RI (role symmetry) I |= Asy(R) iff (x,y) ∈ RI ⇒ (y,x) 6∈ RI (role asymmetry) I |= Tra(R) iff (x,y) ∈ RI and (y,z) ∈ RI ⇒ (x,z) ∈ RI (role transitivity) I |= Ref(R) iff DiagI ⊆ RI (role reflexivity) I |= Irr(R) iff DiagI∩ RI = ∅ (role irefflexivity) I |= Dis(R,S) iff SI∩ RI = ∅ (role disjunction)\nwhere DiagI = {(x, x)|x ∈ ∆I}.\nDefinition 10. For each interpretation I, the valuations are defined as:\n– ⊥I = ∅ – (¬ C)I = ∆I\\CI – (C ⊓ D)I = CI ∩DI – (C ⊔ D)I = CI ∪DI – (≥ n R C)I = {x | card{y | (x, y) ∈ RI ∧ y ∈ CI} ≥ n} – (< n R C)I = {x | card{y | (x, y) ∈ RI ∧ y ∈ CI} < n} – (∃R.C)I = {x | ∃y.(x, y) ∈ RI ∧ y ∈ CI} – (∀R.C)I = {x | ∀y.(x, y) ∈ RI ⇒ y ∈ CI} – (∃R.Self)I = {x | (x, x) ∈ RI}\nThe valuation for concept name and nominal are not repeated as they have been previously defined.\nFor interpretations of substitutions, given c is a concept name and r is a role name:\n– (Cǫ)I = CI – (C[c := c+ i])I = CI where cI is replaced by cI ∪ i – (C[c := c− i])I = CI where cI is replaced by cI ∩ i – (C[r := r + (i, j)])I = CI where rI is replaced by rI ∪ {(i, j)} – (C[r := r − (i, j)])I = CI where rI is replaced by rI ∩ {(i, j)}\nTheorem 1 (Decidability). The satisfiability of an SROIQσ concept Φ0 w.r.t. Rh, a regular role hierarchy, and Ra, a finite set of role assertions, is decidable."
    }, {
      "heading" : "4 Proof of the decidability",
      "text" : "The proof of theorem Theorem 1 is done by transforming concepts with substitutions into concepts without substitutions, that is proving that SROIQσ is included in SROIQ."
    }, {
      "heading" : "4.1 Transformation",
      "text" : "Definition 11. We introduce transformations of the concepts with substitutions. As before, c and c′ are different concept names, C and D are concepts, R and R′ are different roles and o is a nominal. Additionnaly, σ is a substitution, oi is a nominal such that oIi = {i} and ⊲⊳ is either < or ≥.\n1. ⊥ σ ⊥ 2. c[R := R± (i, j)] c 3. c[c′ := c′ ± i] c 4. c[c := c+ i] c ⊔ oi 5. c[c := c− i] c ⊓ ¬oi 6. (¬C) σ ¬(C σ) 7. (C ⊔D) σ C σ ⊔D σ 8. (C ⊓D) σ C σ ⊓D σ 9. o σ o\n10. ∃R.Self [c := c± i] ∃R.Self 11. ∃R.Self [R′ := R′ ± (i, j)] ∃R.Self 12. ∃R.Self [R := R+ (i, j)] (oi ⊓ oj) ⊔ ∃R.Self 13. ∃R.Self [R := R− (i, j)] (¬oi ⊔ ¬oj) ⊓ ∃R.Self 14. (⊲⊳ n R C)[c := c± i] (⊲⊳ n R C[c := c± i]) 15. (⊲⊳ n R C)[R′ := R′ ± (i, j)] (⊲⊳ n R C[R′ := R′ ± (i, j)]) 16. (⊲⊳ n R C)[R := R + (i, j)]\n((oi ⊓ ∃U.(oj ⊓C[R := R+ (i, j)]) ⊓ ∀R.¬oj) ⇒ (⊲⊳ (n− 1) R C[R := R+ (i, j)])) ⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬C[R := R+ (i, j)]) ⊔ ∃R.oj) ⇒ (⊲⊳ n R C[R := R+ (i, j)]))\n17. (⊲⊳ n R C)[R := R − (i, j)] ((oi ⊓ ∃U.(oj ⊓C[R := R− (i, j)]) ⊓ ∃R.oj) ⇒ (⊲⊳ (n+ 1) R C[R := R− (i, j)])) ⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬C[R := R− (i, j)]) ⊔ ∀R.¬oj) ⇒ (⊲⊳ n R C[R := R− (i, j)]))\nLemma 1. The transformations defined in definition Def 11 preserve the valuations.\nProof.\n– (⊥ σ)I = ∅ = ⊥I as it does not depend on the valuation of any concept or role. – (c[R := R± (i, j)])I = cI as cI does not depend on the valuation of R. – (c[c′ := c′ ± i])I = cI as cI does not depend on the valuation of c′. – (c[c := c+ i])I = (c ⊔ oi)I . By definition of the valuation of a substitution,\n(c[c := c+ i])I = cI ∪ i = (c ⊔ oi)I . – (c[c := c− i])I = (c⊓¬oi)I . By definition of the valuation of a substitution,\n(c[c := c− i])I = cI ∩ i = (c ⊓ ¬oi)I . – By definition, ((¬C)[c := c+ i])I = (¬C)I where cI is replaced by cI ∪ i. As\n(¬C)I = ∆ ∩CI , ((¬C)[c := c+ i])I = ∆ ∩C′I with C′I = CI where cI is replaced by cI ∪ i. This is exactly the definition of (¬(C[c := c+ i]))I . The same can be done with the other substitutions. – By definition, ((C ⊔ D)[c := c + i])I = (C ⊔ D)I where cI is replaced by cI ∪ i. That is (C′ ⊔ D′)I with C′I = CI where cI is replaced by cI ∪ i and D′I = DI where cI is replaced by cI ∪ i. This is exactly the definition of (C[c := c + i] ⊔ D[c := c + i])I . The same can be done with the other substitutions. – By definition, ((C ⊓ D)[c := c + i])I = (C ⊓ D)I where cI is replaced by cI ∪ i. That is (C′ ⊓ D′)I with C′I = CI where cI is replaced by cI ∪ i and D′I = DI where cI is replaced by cI ∪ i. This is exactly the definition of (C[c := c + i] ⊓ D[c := c + i])I . The same can be done with the other substitutions.\n– As the valuation of a nominal is independent of the valuations of all roles and concepts, (o σ)I = oI . – (∃R.Self [c := c ± i])I = (∃R.Self)I as (∃R.Self)I is independent of the valuation of c. – (∃R.Self [R′ := R′ ± (i, j)])I = (∃R.Self)I is independent of the valuation of R′. – As (∃R.Self)I = {x|(x, x) ∈ RI}, (∃R.Self [R := R+ (i, j)])I = {x|(x, x) ∈ RI ∪ {(i, j)}} = (∃R.Self)I ∪ ({i} ∩ {j}) that is (∃R.Self [R := R+ (i, j)])I = ((oi ⊓ oj) ⊔ ∃R.Self)\nI. – As (∃R.Self)I = {x|(x, x) ∈ RI}, (∃R.Self [R := R− (i, j)])I =\n{x|(x, x) ∈ RI ∩ {(i, j)}} = (∃R.Self)I ∩ ({i} ∪ {j}) that is (∃R.Self [R := R− (i, j)])I = ((¬oi ⊔ ¬oj) ⊓ ∃R.Self)I.\n– As (⊲⊳ n R C)I = {x | card{y | (x, y) ∈ RI ∧ y ∈ CI} ⊲⊳ n}, ((⊲⊳ n R C)[c := c± i])I = {x | card{y | (x, y) ∈ RI ∧ y ∈ C[c := c± i]I} ⊲⊳ n}\nas RI is independent of the valuation of c. Thus ((⊲⊳ n R C)[c := c± i])I = (⊲⊳ n R C[c := c± i])I .\n– As (⊲⊳ n R C)I = {x | card{y | (x, y) ∈ RI ∧ y ∈ CI} ⊲⊳ n}, ((⊲⊳ n R C)[R′ := R′ ± (i, j)])I = {x | card{y | (x, y) ∈ RI ∧ y ∈ C[R′ := R′ ± (i, j)]I} ⊲⊳ n} as RI is independent of the valuation of R′. Thus ((⊲⊳ n R C)[R′ := R′ ± (i, j)])I = (⊲⊳ n R C[R := R± (i, j)])I . – As (⊲⊳ n R C)I = {x | card{y | (x, y) ∈ RI ∧ y ∈ CI} ⊲⊳ n}, ((⊲⊳ n R C)[R := R+ (i, j)])I = {x | card{y | (x, y) ∈ R[R := R+ (i, j)]I ∧ y ∈ C[R := R+ (i, j)]I} ⊲⊳ n} = {x | card{y | (x, y) ∈ RI ∪ {(i, j)} ∧ y ∈ C[R := R + (i, j)]I} ⊲⊳ n}. We consider {y | (x, y) ∈ RI ∪ {(i, j)} ∧ y ∈ C[R := R + (i, j)]I} and try the possible sets: • If x 6= i or j 6∈ C[R := R+ (i, j)]I or (i, j) ∈ RI , then {y | (x, y) ∈ RI ∪ {(i, j)} ∧ y ∈ C[R := R + (i, j)]I} = {y | (x, y) ∈ RI ∧ y ∈ C[R := R+ (i, j)]I},\n• else, x = i and j ∈ C[R := R + (i, j)]I and (i, j) 6∈ RI , and thus {y | (x, y) ∈ RI ∪ {(i, j)} ∧ y ∈ C[R := R + (i, j)]I} = {y | (x, y) ∈ RI∧y ∈ C[R := R+(i, j)]I}∪{(i, j)}. As {(i, j)} is disjoint from {y | (x, y) ∈ RI ∧ y ∈ C[R := R+ (i, j)]I}, the cardinality of {y | (x, y) ∈ RI ∪ {(i, j)} ∧ y ∈ C[R := R + (i, j)]I} is exactly the cardinality of {y | (x, y) ∈ RI ∧ y ∈ C[R := R+ (i, j)]I}+ 1.\n• Thus, {x | card{y | (x, y) ∈ R[R := R+ (i, j)]I ∧ y ∈ C[R := R+ (i, j)]I} ⊲⊳ n} = {x | (x 6= i ∨ j 6∈ C[R := R+ (i, j)]I ∨ (i, j) ∈ RI ⇒ card{y | (x, y) ∈ RI ∧ y ∈ C[R := R+ (i, j)]I} ⊲⊳ n) ∧(x = i ∧ j ∈ C[R := R+ (i, j)]I ∧ (i, j) 6∈ RI ⇒ card{y | (x, y) ∈ RI ∧ y ∈ C[R := R+ (i, j)]I} ⊲⊳ (n− 1))}\nThus, ((⊲⊳ n R C)[R := R+ (i, j)])I = (((oi ⊓ ∃U.(oj ⊓ C[R := R + (i, j)]) ⊓ ∀R.¬oj) ⇒ (⊲⊳ (n− 1) R C[R := R+ (i, j)])) ⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬C[R := R+ (i, j)]) ⊔ ∃R.oj) ⇒ (⊲⊳ n R C[R := R+ (i, j)])))I\n– As (⊲⊳ n R C)I = {x | card{y | (x, y) ∈ RI ∧ y ∈ CI} ⊲⊳ n}, ((⊲⊳ n R C)[R := R− (i, j)])I = {x | card{y | (x, y) ∈ R[R := R− (i, j)]I ∧ y ∈ C[R := R − (i, j)]I} ⊲⊳ n} = {x | card{y | (x, y) ∈ RI ∩ {(i, j)} ∧ y ∈ C[R := R − (i, j)]I} ⊲⊳ n}. We consider {y | (x, y) ∈ RI ∩ {(i, j)} ∧ y ∈ C[R := R + (i, j)]I} and try the possible sets: • If x 6= i or j 6∈ C[R := R− (i, j)]I or (i, j) 6∈ RI , then {y | (x, y) ∈ RI ∩ {(i, j)} ∧ y ∈ C[R := R − (i, j)]I} = {y | (x, y) ∈ RI ∧ y ∈ C[R := R− (i, j)]I},\n• else, x = i and j ∈ C[R := R − (i, j)]I and (i, j) ∈ RI , and thus {y | (x, y) ∈ RI ∩ {(i, j)} ∧ y ∈ C[R := R − (i, j)]I} = {y | (x, y) ∈ RI ∧ y ∈ C[R := R− (i, j)]I} ∩ {i, j}. As {(i, j)} ⊆\n{y | (x, y) ∈ RI ∧ y ∈ C[R := R− (i, j)]I}, the cardinality of {y | (x, y) ∈ RI ∩ {(i, j)} ∧ y ∈ C[R := R + (i, j)]I} is exactly the cardinality of {y | (x, y) ∈ RI ∧ y ∈ C[R := R− (i, j)]I} − 1.\n• Thus, {x | card{y | (x, y) ∈ R[R := R− (i, j)]I ∧ y ∈ C[R := R− (i, j)]I} ⊲⊳ n} = {x | (x 6= i ∨ j 6∈ C[R := R− (i, j)]I ∨ (i, j) 6∈ RI ⇒ card{y | (x, y) ∈ RI ∧ y ∈ C[R := R− (i, j)]I} ⊲⊳ n) ∧ (x = i ∧ j ∈ C[R := R− (i, j)]I ∧ (i, j) ∈ RI ⇒ card{y | (x, y) ∈ RI ∧ y ∈ C[R := R− (i, j)]I} ⊲⊳ (n+ 1))}\nThus, ((⊲⊳ n R C)[R := R− (i, j)])I = (((oi ⊓ ∃U.(oj ⊓ C[R := R − (i, j)]) ⊓ ∃R.oj) ⇒ (⊲⊳ (n+ 1) R C[R := R− (i, j)])) ⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬C[R := R− (i, j)]) ⊔ ∀R.¬oj) ⇒ (⊲⊳ n R C[R := R− (i, j)])))I\nWe have thus proven that the transformations preserve the valuations. We now have to prove that the transformations actually remove substitutions.\nLemma 2. An algorithm that applies the transformations of Def 11 as long as possible terminates and the final result is substitution-free.\nProof. The proof that the, potential, final result is substitution-free is straightforward. If there is still one substitution, one of the rules can be applied and thus, this is not the final result.\nTo prove the termination, we introduce a pre-ordering (M,M′) defined as:\n– M(⊥) = 0 – M(c) = 0 – M(¬ C) = M(C) – M(C ⊓ D) = max(M(C),M(D)) – M(C ⊔ D) = max(M(C),M(D)) – M((≥ n R C)) = M(C) + 2 – M((< n R C)) = M(C) + 2 – M(o) = 0 – M(∃R.Self) = 0 – M(Cσ) = M(C) + 1 – M′(⊥) = 0 – M′(c) = 0 – M′((¬ C)) = M′(C) – M′(C ⊓ D) = max(M′(C),M′(D)) – M′(C ⊔ D) = max(M′(C),M′(D)) – M′((≥ n R C)) = M′(C) – M′((< n R C)) = M′(C) – M′(o) = 0 – M′(∃R.Self) = 0\n– M′(⊥σ) = 0 – M′(cσ) = 0 – M′((¬ C)σ) = M′(Cσ) + 1 – M′((C ⊓ D)σ) = max(M′(Cσ),M′(Dσ)) + 1 – M′((C ⊔ D)σ) = max(M′(Cσ),M′(Dσ)) + 1 – M′((≥ n R C)σ) = M′(Cσ) + 1 – M′((< n R C)σ) = M′(Cσ) + 1 – M′(oσ) = 0 – M′((∃R.Self)σ) = 0\nFor every concept C, M(C) and M′(C) are positive. We now prove that the transformations either strictly decrease M or keep M constant and strictly decrease M′. We compute the results of the functions for the left- and the righthand side for each transformation.\n– Rule 1: M(⊥ σ) = M(⊥) + 1 = 1 M(⊥) = 0\n– Rule 2: M(c[R := R± (i, j)]) = M(c) + 1 = 1\nM(c) = 0 – Rule 3:\nM(c[c′ := c′ ± i]) = M(c) + 1 = 1 M(c) = 0\n– Rule 4: M(c[c := c+ i]) = M(c) + 1 = 1\nM(c ⊔ oi) = max(M(c),M(oi)) = 0 – Rule 5:\nM(c[c := c− i]) = M(c) + 1 = 1 M(c ⊓ ¬oi) = max(M(c),M(¬oi)) = 0\n– Rule 6: M((¬C) σ) = M(¬C) + 1 = M(C) + 1 M(¬(C σ)) = M(C σ) = M(C) + 1 M′((¬C) σ) = M′(Cσ) + 1 M′(¬(Cσ)) = M′(Cσ)\n– Rule 7: M((C ⊔D) σ) = max(M(C),M(D)) + 1 M(Cσ ⊔Dσ) = max(M(C) + 1,M(D) + 1) M′((C ⊔D) σ) = max(M′(Cσ),M′(Dσ)) + 1 M′(Cσ ⊔Dσ) = max(M′(Cσ),M′(Dσ))\n– Rule 8: M((C ⊓D) σ) = max(M(C),M(D)) + 1 M(Cσ ⊓Dσ) = max(M(C) + 1,M(D) + 1) M′((C ⊓D) σ) = max(M′(Cσ),M′(Dσ)) + 1 M′(Cσ ⊓Dσ) = max(M′(Cσ),M′(Dσ))\n– Rule 9: M(o σ) = M(o) + 1 = 1 M(o) = 0\n– Rule 10: M(∃R.Self [c := c± i]) = M(∃R.Self) + 1 = 1\nM(∃R.Self) = 0\n– Rule 11: M(∃R.Self [R′ := R′ ± (i, j)]) = M(∃R.Self) + 1 = 1\nM(∃R.Self) = 0\n– Rule 12: M(∃R.Self [R := R + (i, j)]) = M(∃R.Self) + 1 = 1\nM((oi ⊓ oj) ⊔ ∃R.Self) = 0\n– Rule 13: M(∃R.Self [R := R − (i, j)]) = M(∃R.Self) + 1 = 1 M((¬oi ⊔ ¬oj) ⊓ ∃R.Self) = 0\n– Rule 14: M((⊲⊳ n R C)[c := c± i]) = M((⊲⊳ n R C)) + 1 = M(C) + 3 M((⊲⊳ n R C[c := c± i])) = M(C[c := c± i]) + 2 = M(C) + 3 M′((⊲⊳ n R C)[c := c± i]) = M′(C[c := c± i]) + 1 M′((⊲⊳ n R C[c := c± i])) = M′(C[c := c± i])\n– Rule 15: M((⊲⊳ n R C)[R′ := R′ ± (i, j)]) = M((⊲⊳ n R C)) + 1 = M(C) + 3 M((⊲⊳ n R C[R′ := R′ ± (i, j)]) = M(C[R′ := R′ ± (i, j)]) + 2 = M(C) + 3 M′((⊲⊳ n R C)[R′ := R′ ± (i, j)]) = M′(C[R′ := R′ ± (i, j)]) + 1 M′((⊲⊳ n R C[R′ := R′ ± (i, j)])) = M′(C[R′ := R′ ± (i, j)])\n– Rule 16: M((⊲⊳ n R C)[R := R+ (i, j)]) = M((⊲⊳ n R C) + 1\n= M(C) + 3 M(c1,16) = max(M(oj),M(C[R := R+ (i, j)])) = M(C) + 1 M(c2,16) = max(M(¬oj),M(¬(C[R := R+ (i, j)]))) = M(C) + 1 M(b1,16) = M(oi) = 0 M(b2,16) = M(∃U.c1,16)\n= M(c1,16) + 2 = M(C) + 3\nM(b3,16) = M(∀R.¬oj) = M(¬oJ ) + 2 = 2\nM(b4,16) = M((⊲⊳ (n− 1) R C[R := R+ (i, j)])) = M(C[R := R + (i, j)]) + 2 = M(C) + 3\nM(b11,16) = M(¬oi) = 0\nM(b12,16) = M(∀U.c2,16) = M(c2,16) + 2 = M(C) + 3\nM(b13,16) = M(∃R.oj) = M(oJ ) + 2 = 2\nM(b14,16) = M((⊲⊳ n R C[R := R + (i, j)])) = M(C[R := R + (i, j)]) + 2 = M(C) + 3\nM(a1,16) = max(M(b1,16),M(b2,16),M(b3,16),M(b4,16) = M(C) + 3\nM(a2,16) = max(M(b11,16),M(b12,16),M(b13,16),M(b14,16) = M(C) + 3\nM(RHR16) = max(M(a1,16),M(a2,16)) = M(C) + 3\nM′((⊲⊳ n R C)[R := R+ (i, j)]) = M′(C[R := R+ (i, j)]) + 1 M′(c1,16) = max(M′(oj),M′(C[R := R+ (i, j)]))\n= M′(C[R := R+ (i, j)]) M′(c2,16) = max(M ′(¬oj),M ′(¬(C[R := R+ (i, j)]))) = M′(C[R := R+ (i, j)]) M′(b1,16) = M(oi) = 0 M′(b2,16) = M(∃U.c1,16)\n= M′(c1,16)\n= M′(C[R := R+ (i, j)]) M′(b3,16) = M(∀R.¬oj)\n= M′(¬oJ ) = 0\nM′(b4,16) = M((⊲⊳ (n− 1) R C[R := R+ (i, j)]) = M′(C[R := R+ (i, j)])\nM′(b11,16) = M′(¬oi) = 0 M′(b12,16) = M′(∀U.c2,16) = M′(c2,16) = M(C[R := R+ (i, j]) M′(b13,16) = M′(∃R.oj) = M′(oJ) = 0 M′(b14,16) = M′((⊲⊳ n R C[R := R+ (i, j)])) = M′(C[R := R+ (i, j)]) M′(a1,16) = max(M′(b1,16),M′(b2,16),M′(b3,16),M′(b4,16) = M′(C[R := R+ (i, j)]) M′(a2,16) = max(M′(b11,16),M′(b12,16),M′(b13,16),M′(b14,16) = M′(C[R := R+ (i, j)])\nM′(RHS16) = max(M ′(a1,16),M ′(a2,16)) = M(C[R := R+ (i, j)])\n– Rule 17: M((⊲⊳ n R C)[R := R− (i, j)]) = M((⊲⊳ n R C) + 1\n= M(C) + 3 M(c1,17) = max(M(oj),M(C[R := R− (i, j)])) = M(C) + 1 M(c2,17) = max(M(¬oj),M(¬(C[R := R− (i, j)]))) = M(C) + 1 M(b1,17) = M(oi) = 0 M(b2,17) = M(∃U.c1,17)\n= M(c1,17) + 2 = M(C) + 3\nM(b3,17) = M(∃R.oj) = M(¬oJ ) + 2 = 2\nM(b4,17) = M((⊲⊳ (n+ 1) R C[R := R− (i, j)])) = M(C[R := R − (i, j)]) + 2 = M(C) + 3\nM(b11,17) = M(¬oi) = 0\nM(b12,17) = M(∀U.c2,17) = M(c2,17) + 2 = M(C) + 3\nM(b13,17) = M(∀R.¬oj) = M(oJ ) + 2 = 2\nM(b14,17) = M((⊲⊳ n R C[R := R + (i, j)])) = M(C[R := R − (i, j)]) + 2 = M(C) + 3\nM(a1,17) = max(M(b1,17),M(b2,17),M(b3,17),M(b4,17) = M(C) + 3\nM(a2,17) = max(M(b11,17),M(b12,17),M(b13,17),M(b14,17) = M(C) + 3\nM(RHR17) = max(M(a1,17),M(a2,17)) = M(C) + 3\nM′((⊲⊳ n R C)[R := R− (i, j)]) = M′(C[R := R− (i, j)]) + 1 M′(c1,17) = max(M′(oj),M′(C[R := R− (i, j)]))\n= M′(C[R := R− (i, j)]) M′(c2,17) = max(M ′(¬oj),M ′(¬(C[R := R− (i, j)]))) = M′(C[R := R− (i, j)]) M′(b1,17) = M(oi) = 0 M′(b2,17) = M(∃U.c1,17)\n= M′(c1,17) = M′(C[R := R− (i, j)])\nM′(b3,17) = M(∀R.¬oj) = M′(¬oJ ) = 0 M′(b4,17) = M((⊲⊳ (n+ 1) R C[R := R− (i, j)]) = M′(C[R := R− (i, j)])\nM′(b11,17) = M′(¬oi) = 0 M′(b12,17) = M′(∀U.c2,17) = M′(c2,17) = M(C[R := R− (i, j]) M′(b13,17) = M′(∀R.¬oj) = M′(oJ) = 0 M′(b14,17) = M′((⊲⊳ n R C[R := R− (i, j)])) = M′(C[R := R− (i, j)]) M′(a1,17) = max(M′(b1,17),M′(b2,17),M′(b3,17),M′(b4,17) = M′(C[R := R− (i, j)]) M′(a2,17) = max(M′(b11,17),M′(b12,17),M′(b13,17),M′(b14,17) = M′(C[R := R− (i, j)])\nM′(RHS17) = max(M′(a1,17),M′(a2,17)) = M(C[R := R− (i, j)])\nwhere : RHS16 = ((oi ⊓ ∃U.(oj ⊓ C[R := R+ (i, j)]) ⊓ ∀R.¬oj) ⇒ (⊲⊳ (n− 1) R C[R := R+ (i, j)])) ⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬C[R := R+ (i, j)]) ⊔ ∃R.oj) ⇒ (⊲⊳ n R C[R := R+ (i, j)])) RHS17 = ((oi ⊓ ∃U.(oj ⊓ C[R := R− (i, j)]) ⊓ ∃R.oj) ⇒ (⊲⊳ (n+ 1) R C[R := R− (i, j)]))\n⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬C[R := R − (i, j)]) ⊔ ∀R.¬oj) ⇒ (⊲⊳ n R C[R := R− (i, j)])) a1,16 = (oi ⊓ ∃U.(oj ⊓ C[R := R+ (i, j)]) ⊓ ∀R.¬oj) ⇒ (⊲⊳ (n− 1) R C[R := R+ (i, j)]) a2,16 = (¬oi ⊔ ∀U.(¬oj ⊔ ¬C[R := R+ (i, j)]) ⊔ ∃R.oj) ⇒ (⊲⊳ n R C[R := R+ (i, j)]) a1,17 = (oi ⊓ ∃U.(oj ⊓ C[R := R − (i, j)]) ⊓ ∃R.oj) ⇒ (⊲⊳ (n+ 1) R C[R := R− (i, j)]) a2,17 = (¬oi ⊔ ∀U.(¬oj ⊔ ¬C[R := R− (i, j)]) ⊔ ∀R.¬oj) ⇒ (⊲⊳ n R C[R := R− (i, j)]) b1,16 = oi b2,16 = ∃U.(oj ⊓ C[R := R+ (i, j)]) b3,16 = ∀R.¬oj b4,16 = (⊲⊳ (n− 1) R C[R := R+ (i, j)])) b11,16 = ¬oi b12,16 = ∀U.(¬oj ⊔ ¬(C[R := R+ (i, j)])) b13,16 = ∃R.oj b14,16 = (⊲⊳ n R C[R := R+ (i, j)])) b1,17 = oi b2,17 = ∃U.(oj ⊓ C[R := R− (i, j)]) b3,17 = ∃R.oj b4,17 = (⊲⊳ (n+ 1) R C[R := R− (i, j)])) b11,17 = ¬oi b12,17 = ∀U.(¬oj ⊔ ¬(C[R := R− (i, j)])) b13,17 = ∀R.¬oj b14,17 = (⊲⊳ n R C[R := R− (i, j)])) c1,16 = (oj ⊓ C[R := R+ (i, j)]) c2,16 = (¬oj ⊔ ¬(C[R := R+ (i, j)])) c1,17 = (oj ⊓ C[R := R− (i, j)]) c2,17 = (¬oj ⊔ ¬(C[R := R− (i, j)]))\nProof.[Decidability] The transformations allow us to obtain SROIQ-concepts from SROIQσ-concepts. As the satisfiability of an SROIQ-concept is known to be decidable, so is the satisfiability of an SROIQσ-concept."
    }, {
      "heading" : "5 Example",
      "text" : "In order to illustrate the transformation, I will give a purely scholastic example. Given the graph on the left of Fig. 5, we want to prove that after adding the edge between i and j, i satisfies the property (< 3 S (< 3 S ⊤)) is still verified. That is we want to see if oi ⊓ (< 3 S (< 3 S ⊤))[S := S + (i, j)] ⊓ (< 3 S ⊤) ⊓ ∃S.oi ⊓ ∃S.ok ⊓ ∀S.¬oj ⊓ ∃U.(oj ⊓ (< 1 S ⊤)⊓¬oi)⊓ ∃U.(ok ⊓ (< 1 S ⊤)⊓¬oi) is satisfiable.\nBy applying rule 16, oi ⊓ (< 3 S (< 3 S ⊤))[S := S + (i, j)] ⊓ (< 3 S ⊤) ⊓ ∃S.oi ⊓ ∃S.ok ⊓ ∀S.¬oj ⊓ ∃U.(oj ⊓ (< 1 S ⊤)⊓¬oi)⊓ ∃U.(ok ⊓ (< 1 S ⊤)⊓¬oi) becomes oi ⊓ ((oi ⊓ ∃U.(oj ⊓ (< 3 S ⊤)[S := S + (i, j)]) ⊓ ∀S.¬oj) ⇒\n(< 2 S (< 3 S ⊤)[S := S + (i, j)])) ⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬(< 3 S ⊤)[S := S + (i, j)]) ⊔ ∃S.oj) ⇒ (< 3 S (< 3 S ⊤)[S := S + (i, j)])) ⊓ (< 3 S ⊤) ⊓ ∃S.oi ⊓ ∃S.ok ⊓ ∀S.¬oj ⊓ ∃U.(oj ⊓ (< 1 S ⊤) ⊓ ¬oi) ⊓ ∃U.(ok ⊓ (< 1 S ⊤) ⊓ ¬oi). By applying rule 16 to ∃U.(oj ⊓ (< 3 S ⊤)[S := S + (i, j)]), one gets ∃U.(oj ⊓ ((oi ⊓ ∃U.(oj ⊓ ⊤[S := S + (i, j)]) ⊓ ∀S.¬oj) ⇒ (< 2 S ⊤[S := S + (i, j)])) ⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬⊤[S := S + (i, j)]) ⊔ ∃S.oj) ⇒ (< 3 S ⊤[S := S + (i, j)])). As oj is a nominal, we can factor in ∃U.(oj ⊓ ¬oi) to replace ∃U.(oj ⊓ (< 3 S ⊤)[S := S + (i, j)]) with ∃U.(oj ⊓¬oi⊓ (< 3 S ⊤[S := S+(i, j)])). As, by application of rules 1 and 6, ⊤[S := S + (i, j)] is ⊤, we get oi ⊓ ((oi ⊓ ∃U.(oj ⊓ (< 3 S ⊤)) ⊓ ∀S.¬oj) ⇒ (< 2 S (< 3 S ⊤)[S := S + (i, j)])) ⊓ ((¬oi ⊔ ∀U.(¬oj ⊔ ¬(< 3 S ⊤)[S := S + (i, j)]) ⊔ ∃S.oj) ⇒ (< 3 S (< 3 S ⊤)[S := S + (i, j)])) ⊓ (< 3 S ⊤) ⊓ ∃S.oi ⊓ ∃S.ok ⊓ ∀S.¬oj ⊓ ∃U.(oj ⊓ (< 1 S ⊤) ⊓ ¬oi) ⊓ ∃U.(ok ⊓ (< 1 S ⊤) ⊓ ¬oi). By reordering the formula, we see that oi ⊓ ∃U.(oj ⊓ (< 3 S ⊤)) ⊓ ∀S.¬oj is the right choice and then we get oi ⊓ (< 2 S (< 3 S ⊤)[S := S + (i, j)])) ⊓ (< 3 S ⊤) ⊓ ∃S.oi ⊓ ∃S.ok ⊓ ∀S.¬oj ⊓ ∃U.(oj ⊓ (< 1 S ⊤) ⊓ ¬oi) ⊓ ∃U.(ok ⊓ (< 1 S ⊤) ⊓ ¬oi). We now have to apply rule 16, and 1 and 6 to remove the ⊤[S := S + (i, j)], once more to obtain the final result, oi ⊓ (< 2 S ((oi ⊓ ∃U.(oj ⊓ ⊤[S := S + (i, j)]) ⊓ ∀S.¬oj) ⇒ (< 2 S ⊤))⊓((¬oi⊔∀U.(¬oj⊔¬⊤)⊔∃S.oj) ⇒ (< 3 S ⊤)))⊓(< 3 S ⊤)⊓∃S.oi⊓ ∃S.ok⊓∀S.¬oj⊓∃U.(oj⊓(< 1 S ⊤)⊓¬oi)⊓∃U.(ok⊓(< 1 S ⊤)⊓¬oi). Despite its ugliness, this formula no longer contains substitutions and its satisfiability can be decided. One can easily check from the picture that it is indeed satisfiable."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We have introduced a new Description Logic named SROIQσ which is an extension of SROIQ with substitutions. We have proven that this logic is decidable by translating it to SROIQ.\nThe same method can likely be used for several other DLs. For instance, SHOIQ [3] is a restriction of SROIQ without role assertions and ∃R.Self . As none of the translation rules outside these constructs uses these constructs, they can be removed and SHOIQσ can be defined in the exact same way as SROIQσ.\nOn the other hand, Description Logics like ALC [4] that is restricted to concepts without counting quantifiers are not suited for such a translation. Existential and universal quantification would create couting quantifiers during translation that are outside the scope of the logic. Even extending ALC with counting quantifiers, which produces ALCQ, is not enough as nominals are used during translation."
    }, {
      "heading" : "3. Ian Horrocks and Ulrike Sattler. A tableaux decision procedure for shoiq. In In",
      "text" : "Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI, pages 448–453. Morgan, 2005."
    }, {
      "heading" : "4. Manfred Schmidt-Schaubß and Gert Smolka. Attributive concept descriptions with",
      "text" : "complements. Artif. Intell., 48(1):1–26, February 1991."
    } ],
    "references" : [ {
      "title" : "The Description Logic Handbook: Theory, Implementation, and Applications",
      "author" : [ "Franz Baader", "Diego Calvanese", "Deborah L. McGuinness", "Daniele Nardi", "Peter F. Patel-Schneider", "editors" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2003
    }, {
      "title" : "The even more irresistible sroiq",
      "author" : [ "I. Horrocks", "O. Kutz", "U. Sattler" ],
      "venue" : "In Proc. of the 10th Int. Conf. on Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2006
    }, {
      "title" : "A tableaux decision procedure for shoiq",
      "author" : [ "Ian Horrocks", "Ulrike Sattler" ],
      "venue" : "Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2005
    }, {
      "title" : "Attributive concept descriptions with complements",
      "author" : [ "Manfred Schmidt-Schaubß", "Gert Smolka" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1991
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Description Logics [1] are logical formalisms for representing information about",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 1,
      "context" : "We investigate the addition of such substitutions in the particular case of the logic SROIQ, an extension of the logic SROIQ [2].",
      "startOffset" : 125,
      "endOffset" : 128
    }, {
      "referenceID" : 2,
      "context" : "For instance, SHOIQ [3] is a restriction of SROIQ without role assertions and ∃R.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 3,
      "context" : "On the other hand, Description Logics like ALC [4] that is restricted to",
      "startOffset" : 47,
      "endOffset" : 50
    } ],
    "year" : 2017,
    "abstractText" : "Description Logics [1] are logical formalisms for representing information about classes and objects. They are very often used as the basis of knowledge representation systems and have been used recently to develop OWL semantic web language, which can be viewed as an expressive Description Logic. There is an impressive variety of Description Logics with diverse expressiveness and complexity, or even with or without decidability. Yet, all are tailored to describe an established and fixed ontology and reason about its properties. Our goal here is to consider properties over dynamic ontologies. We introduce the notion of substitutions to express changes of ontologies (e.g. addition or deletion of an element, respectively a pair of elements, of a concept, respectively of a role). We investigate the addition of such substitutions in the particular case of the logic SROIQ, an extension of the logic SROIQ [2]. We mainly show that the problem of satisfiability in SROIQ is still decidable. Sect. 2 introduces SROIQ, our version of SROIQ with substitutions. Sect. 3 defines the interpretations for that logic. Sect. 4 proves that SROIQ is decidable by transforming formulae in SROIQ to formulae in SROIQ. Sect. 5 illustrates such transformations. Finally, Sect. 6 concludes the paper.",
    "creator" : "LaTeX with hyperref package"
  }
}