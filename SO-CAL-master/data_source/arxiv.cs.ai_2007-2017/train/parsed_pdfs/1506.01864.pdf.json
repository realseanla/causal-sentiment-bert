{
  "name" : "1506.01864.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Grid-based angle-constrained path planning",
    "authors" : [ "Konstantin Yakovlev", "Egor Baskin", "Ivan Hramoin" ],
    "emails" : [ "hramoin}@isa.ru" ],
    "sections" : [ {
      "heading" : null,
      "text" : "adfa, p. 1, 2011. © Springer-Verlag Berlin Heidelberg 2011\nmodel an agent’s environment, and well known in Artificial Intelligence heuristic search algorithms (A*, JPS, Theta* etc.) are utilized for grid path planning. A lot of research in this area has been focused so far on finding the shortest paths while in many applications producing smooth paths is preferable. In our work, we study the problem of generating smooth grid paths and concentrate on angle constrained path planning. We put angle constrained path planning problem formally and present a new algorithm of solving it – LIAN. We examine LIAN both theoretically and empirically. On the theoretical side, we prove that LIAN is sound and complete (under well-defined restrictions). On the experimental side, we show that LIAN significantly outperforms competitors in ability to find solutions under tough resource constraints and in computational efficiency.\nKeywords: path planning, path finding, heuristic search, grid, grid world, angle constrained path, A*, Theta*, LIAN"
    }, {
      "heading" : "1 Introduction",
      "text" : "Path planning is one of the key abilities needed for an intelligent agent (robot, unmanned vehicle, computer game character etc.) to autonomously operate in real or virtual worlds. Typically, in Artificial Intelligence, agent’s environment is modeled with weighted graph which vertices correspond to positions (locations) the agent can occupy and edges correspond to trajectories the agent can traverse, e.g. line segments, curves of predefined shape and length, etc. Each edge is assigned a non-negative real number (weight, cost) by weighting function which is used to quantitatively express characteristics of the corresponding trajectory (such as length, potential risk of traversing, etc.). Thus to solve a path planning problem one needs a) to construct a graph (given the description of the environment) and b) to find a path (preferably – the shortest one) on this graph.\nAmong the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4]. The latter are the most widespread for several reasons. First, they appear naturally in many virtual environments (computer games are the most obvious example [5]), e.g. the agent’s spatial world description is the grid itself. This means that no methods for converting this description to graph model are needed to be applied. Even in real world scenarios, say in robotics, it is the grids that are commonly used as spatial models [6].\nSecond, even if the environment is described in some other way it is likely that forming a grid out of this description will be less burdensome than constructing other abovementioned models due to grid’s “primitive” structure.\nAfter the graph is constructed the search for a path on it can be carried out by the well known Dijkstra’s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few. Some of these algorithms are tailored to grid path finding (JPS, Theta*, HPA*), others are more universal and suitable for any graph models (with A* and Dijkstra being the most general ones). Many of them, in fact – almost all of them, overcome their predecessors in terms of computational efficiency (at least for a large class of tasks). Some algorithms are tailored to single-shot path planning while others demonstrate their supremacy on solving bunches of tasks. But only a few of them take the shape of the resultant path into account although it can be quite useful in many applications. For example, a wheeled robot or an unmanned aerial vehicle simply can not follow a path with sharp turns due to their dynamic constraints. The most common way to incorporate agent’s dynamic constraints into path planning process is to extend the graph model – see [14] for example – but this leads to tremendous growth of the search space (which now contains not only the spatial information) and thus finding a path becomes burdensome and computationally ineffective. So it can be beneficial to stay within “primitive”, spatial-only world model (e.g. grid based) but focus on searching the smooth paths, rather than the short ones, and thus indirectly guarantee the feasibility of that paths against agent’s dynamic constraints.\nWe find the idea of generating smooth paths very appealing and in our work we address the following angle constrained path planning problem. Given a square grid the task is to find a path as a sequence of grid sections (ordered pairs of grid elements) such that an angle of alteration between each two consecutive sections is less or equal than some predefined threshold (formal definitions are given in section 2). We present a new heuristic search algorithm – LIAN (from “limited angle”) – of solving it. We examine LIAN both theoretically, showing that it is sound and complete (under some constraints), and experimentally, testing LIAN’s applicability for urban outdoor navigation scenarios.\nTo the best of our knowledge, no direct competitors to LIAN are present nowadays, although there exist one or more implicit analogues – grid path planning methods that can be attributed to as taking the shape of the path into account. For example A*-PS [10] runs A*-search on a grid and after it is finished performs a preprocessing step to eliminate intermediate path elements. Thus the resultant path starts looking more realistic (due to the fact that “back and forth” heading changes are skipped) and at the same time it becomes shorter. Theta* (or more precise – Basic Theta*) [12] uses the same idea – intermediate grid elements skipping – but it performs the smoothing procedure online, e.g. on each step of the algorithm. In [15] a modification of Basic Theta* (also applicable to A*-PS) algorithm is presented which uses special angle-based heuristic to focus the search in order to construct more straightforward paths to the goal. In [16] another modification of Basic Theta* – weighted angular rate constrained Theta* (wARC-Theta*) - is described. wARC-Theta* uses special techniques to take into account agent’s angular rate (and other) constraints staying within grid model e.g. without\nextending the spatial model with agent’s orientation (heading) information but rather performing additional calculations (related to agent’ pose) online. wARC-Theta* with some minor adaptations can be used to solve the angle constrained path planning problem we are interested in. Unfortunately, the algorithm is incomplete, e.g. it fails to solve a wide range of path planning tasks although the solutions to these tasks do exist. With some modifications, explained further in the paper, the performance of wARC-Theta* can be improved and the number of successfully solved tasks can be increased. This improved version of wARC-Theta* is seen to be the only direct analogue of the proposed algorithm so we use it for comparative experimental study. Obtained results show that the newly proposed algorithm – LIAN – significantly outperforms wARC-Theta*: LIAN solves much more tasks and uses significantly less computational resources (processor time and memory).\nThe latter of the paper is organized as follows. In section 2 we express the angle constrained path planning problem formally. In section 3 the new algorithm of solving it – LIAN – is presented, as well as modified wARC-Theta* algorithm is described. In section 4 the results of the comparative experimental study are given."
    }, {
      "heading" : "2 Angle constrained path planning problem on square grid",
      "text" : "Two alternative types of square grid notations are widespread nowadays: center-based, when agent’s locations are tied to the centers of grid cells, and corner-based, when agent’s locations are tied to the corners, respectively (see figure 1).\nIn our work we adopt the center-based notation and consider a grid to be a finite set of cells A that can be represented as a matrix AMxN={aij}, where i, j – are cell position indexes (coordinates) and M, N – are grid dimensions. Each cell is labeled either traversable or un-traversable and the set of all traversable cells is denoted as A+. In case cell coordinates can be omitted, lower case Latin characters will be used: a, b, c etc.\nA line-of-sight function, los: A+A+ → {true, false}, is given and an agent is allowed to move from one traversable cell to the other if los returns true on them (or, saying in other words, if there exist a line-of-sight between them). In our work, as in many others, we use well-known in computer graphics Bresenham algorithm [17] to detect if lineof-sight between two cells exist or not. This algorithms draws a “discrete line section” (see figure 2) and if it contains only traversable cells than los is supposed to return true (otherwise los returns false).\nA metric function, dist: A+ → , is given to measure the distance between any two traversable cells. In our work we use Euclid distance, e.g dist(aij, alk)=√(\uD835\uDC59 − \uD835\uDC56)2 + (\uD835\uDC58 − \uD835\uDC57)2 as metric function.\nAn ordered pair of distinct grid cells is a section: e=aij, alk, and it is traversable iff los(aij, alk)=true. The length of section aij, alk equals dist(aij, alk). Two sections that have exactly a middle cell in common, e.g. e1=aij, alk, e2=alk, avw, are called adjacent.\nΔ-section is such section e=aij, alk that it’s endpoint, alk, belongs to CIRCLE(aij, Δ), where CIRCLE is the set of cells identified by the well-known in computer graphics Midpoint algorithm [18] (which is a modification of the abovementioned Brezenham’s algorithm intended for drawing “discrete circumferences”) – see figure 2.\nA path between two distinct traversable cells s (start cell) and g (goal cell) is the sequence of traversable adjacent sections such that the first section starts with s and the last ends with g: (s, g)=={e1, …, ev}, e1=s, a, ev=b, g. The length of the path len() is the sum of the lengths of the sections forming that path.\nGiven two adjacent sections e1=aij, alk, e2=alk, avw, an angle of alteration is the angle between the vectors \uD835\uDC4E\uD835\uDC56\uD835\uDC57\uD835\uDC4E\uD835\uDC59\uD835\uDC58⃗⃗ ⃗⃗ ⃗⃗ ⃗⃗ ⃗⃗  ⃗ and \uD835\uDC4E\uD835\uDC59\uD835\uDC58\uD835\uDC4E\uD835\uDC63\uD835\uDC64⃗⃗ ⃗⃗ ⃗⃗ ⃗⃗ ⃗⃗ ⃗⃗  ⃗ , which coordinates are (l - i, k - j) and (v - l, w - k) respectively (see figure 2). This angle is denoted as α(e1, e2) and it’s value is denoted as |α(e1, e2)|.\nGiven a path ={e1, …, ev} we call the value αm()=αm=max{|α(e1, e2)|, |α(e2, e3)|,\n…, |α(ev-1, ev)|} the path’s maximum angle of alteration.\nNow we are interested in solving angle constrained path planning problem which is formulated as following. Given two distinct traversable cells s (start cell) and g (goal cell) and the value αm: 0<αm<180, find a path (s, g) such that αm()≤αm (angle constrained path).\nShortest angle constrained path is considered to be the optimal solution. For the reasons explained further in the paper, we are also interested in a special class of solutions of the problem, called Δ-solutions. Δ-solution is an angle constrained path each section of which, except maybe the last one, is the Δ-section (the path depicted on the figure 2 is a Δ-path, Δ=5)."
    }, {
      "heading" : "3 Algorithms for the angle constrained path planning",
      "text" : ""
    }, {
      "heading" : "3.1 wTheta*-LA",
      "text" : "In [16] H. Kim et al. present a modification of Basic Theta* [12] algorithm tailored to solve grid path planning problem for an agent with angular rate constraints. Authors do not consider the maximum angle of alteration constraint – as described above – directly. Instead, they investigate the case when the speed and the turning radius of an agent are given and calculate angle constraints online, taking into account the length of the path sections involved. But if one replaces the original procedure of angle constraint calculation with the one which always returns αm, the algorithm becomes applicable to the angle constrained path problem we are interested in. We call such an algorithm Theta*LA (LA stands for “limited angle”).\nTheta*-LA is a pretty straightforward modification of Theta*. The only difference is that when Theta* tries to connect a cell to it’s grandparent (in order to skip the intermediate element, e.g. parent, from the path) it validates only the line-of-sight constraint (e.g. if line-of-sight exists between the cell and it’s grandparent the former is being connected to the latter), while Theta*-LA validates also angle constraint, and if an angle between the sections defined by the trio: grandparent-parent-cell is greater than the predefined threshold αm, than parent cell is not eliminated from the sequence. This straightforward technique leads to the following problem: if the angle constraint is less than 45 (which is likely to be a common, realistic scenario) the algorithm fails to circumnavigate large obstacles and thus fails to find an angle constrained path - see figure 3 for detailed explanation.\nThe main reason Theta*-LA fails to find a path in many cases is that it doesn’t store the intermediate path elements but rather tries to make path sections as long as possible. In the original work [16] H.Kim et. al give a hint how this problem can be partially solved but do not describe it in details – they suggest weighting the grid, e.g. assigning each grid cell a non-negative weight value and taking cells’ weights into account while calculation the length of the section. Using weights to penalize the cells residing close to the obstacles in such way that Theta*-LA first prefers processing cells residing at some distance of the obstacles potentially leads to another grandparent-parent-cell sequences and improves the overall performance of the algorithm (see figure 3).\nWe have implemented the grid weighting procedure that makes cells lying close to the obstacles less attractive to the algorithm and call such an algorithm wTheta*-LA. We use the following strategy: given two parameters – radius r and max weighting penalty p – discrete circumferences of radius r with the centers in the cells a lying on the boundaries of the obstacles are constructed (by the referred in section 1 Midpoint algorithm). Than the rays connecting a and each cell forming the circumference are traced and each ray cell, say a', is assigned the weight as follows: w(a')=p∙(1 + (1 – dist(a, a'))/r). During the search, a modified length calculation formula is used, e.g. len(a, b)=dist(a, b)∙(1+avgW), where avgW – is the average weight of the cells lying on Bresenham line in between a and b.\nExperimental analysis (see section 4) shows that weighting can significantly improve algorithm’s performance, but still vast variety of path planning tasks remains unsolved. One can suggest playing further with the weighting parameters values or modifying the weighting procedure itself, but we prefer to design a new algorithm that a) does not require any grid preprocessing at all and b) theoretically guarantees completeness (at least for a well defined class of tasks). Such an algorithm is described further."
    }, {
      "heading" : "3.2 LIAN",
      "text" : "LIAN (from “limited angle”) is a new heuristic search algorithm tailored to solve angle constrained path planning problem on square grids. LIAN relies on A* [8] state-space search strategy, uses line-of-sight checks as Theta* [12] and exploits the idea of multiple parents as R* [11].\nAs well as A* our algorithm explores the grid cells and calculates so called g-values, where g-value of a cell a, g(a), is the length of the path (angle constrained path in our case) from start cell s to a found so far. Along with the g-value each cell is obligatory characterized by the parent pointer (like Theta* but unlike A* where parent pointers are commonly used but are not obligatory) – bp(a), which points to the grid cell which is a predecessor of a. Any grid cell can have multiple parents (this makes LIAN similar to R*). Thus when we are talking about the search space of LIAN we are talking about the space consisting of nodes which are the triples: cell, g-value, parent pointer (which actually points to the node, not the cell). Nodes will be denoted as [a], and [a]=[a, g([a]), bp([a])]. So, [a] is a node and a is a corresponding cell. bp([a]) is a node (e.g. bp([a])=[a']) and bp(a) is a corresponding cell (bp(a)=a').\nAs well as any other A*-like heuristic search algorithm LIAN maintains two lists of nodes: OPEN and CLOSED. OPEN is the collection of nodes – potential candidates for further processing and it initially contains the only element [s, 0, ]. CLOSED is the collection of nodes that have already been processed. On each step of the algorithm the node [a] with minimal f-value, f([a]),is retrieved from OPEN, where f([a])=g([a])+h(a), and h(a) is a heuristic estimate (e.g. dist(a, g)) of the path length from a to the goal cell (exactly as in A*). Then the set of potential successors of [a] is formed: SUCC([a])=SUCC. In A* SUCC is comprised out of the cells which are adjacent to a. In LIAN potential successors correspond to the cells residing at the fixed distance ∆ (which is the input parameter of the algorithm) from a. To identify such cells Midpoint algorithm (referred above) is used: a discrete circumference of radius ∆ (see to figure 1) is drawn and the cells forming this circumference are added to SUCC. If the distance from a to the goal cell is less than ∆, then the node, corresponding the goal cell is also added to SUCC. To distinguish between the potential successor nodes and the corresponding cells we will use the records [succi] and succi respectively.\nAfter the set of potential successors is constructed it’s pruning is done. First nodes corresponding to un-traversable cells are eliminated. Second, the nodes that violate line-of-sight constraint are pruned. Third, the nodes that correspond to the cells that violate maximum angle of alteration constraints are discarded, e.g. the nodes [succi] that correspond to such cells succi: |α(bp(a), a, a, succi)|>αm (NB: if the start node is processed the angle constraints are ignored). Forth, the cells that have been visited before are pruned, e.g. if the CLOSED list contains a node with the same cell and parent pointer then such potential successor is discarded.\nAfter fixing the SUCC set, g-values of the successors are calculated: g([succi])=g([a])+d(a, succi) and corresponding nodes are added to OPEN. [a] is added to CLOSED.\nAlgorithm’s stop criterion is the same as used in A*: LIAN stops when a node corresponding to the goal cell is retrieved from OPEN (in that case the path can be reconstructed using goal node’s parent pointers). If the OPEN list becomes empty during the search algorithm reports failure to found a path.\nThe proposed algorithm has the following properties.\nProperty 1. LIAN always terminates. Sketch of proof. Algorithm is performing the search until the OPEN list is empty (or until the goal node is retrieved from it). OPEN contains only elements that refer to the grid cells the total number of which is finite. The number of potential parents of the cell is also finite. At the same time when a new node is generated LIAN checks whether this node (the node defined by the same cell and the same parent) has been processed before already (lines 24-26). And in case the answer is ‘yes’ it is pruned and not added to OPEN. Thus, the total number of elements potentially addable to OPEN is finite. Given the fact that on each step of the algorithm exactly one element is removed from OPEN (line 6) one can infer that sooner or later this list will contain no elements, or the goal node will be retrieved. In both cases (lines 4, 7) algorithm terminates.\nProperty 2. If only Δ-solutions are under investigation then LIAN is sound and complete, e.g. if Δ-solution to the angle constrained path planning task exists, LIAN finds it, if no Δ-solution exists, LIAN reports failure. Sketch of proof. LIAN’s parameter Δ well defines the set of potential successors for a cell being processed as the set of cells residing at the Δ-distance. All the (traversable) cells from that set that satisfy the maximum alteration angle constraint are being added to OPEN (except those that have been examined before). Thus, sooner or later all paths compromised of the sections being Δ-sections (except, maybe, the last section – lines 16-17) will be constructed and evaluated against angle deviation constraints and the sought path, if it exist, will be found. By construction this path is a Δ-solution of the given task. If LIAN reports failure it means that all the potential paths – candidates for the Δ-solution have been examined (otherwise OPEN list still contains some elements and LIAN continues the search), which in turn means no Δ-solution exists.\nProperty 3. If different Δ-solutions to the angle constrained path planning task exist LIAN returns the shortest one. Sketch of proof. LIAN uses the same OPEN prioritization strategy as A* which guarantees finding the shortest path if the admissible heuristic is used. LIAN uses Euclidian distance function dist, which is obviously admissible (and consistent as well) heuristic. Thus LIAN returns the shortest Δ-solution possible.\nWe would like to notice further that just like A* LIAN allows heuristic weighting, e.g. calculating f-values using the following formula f([a])=g([a])+w∙h(a), where w>1. Weighting the heuristic commonly makes it inadmissible thus the optimality of the solution can not be guaranteed any more. But at the same time, it’s known that in many\npractical applications, grid path planning inclusively, heuristic weighting radically improves algorithm’s performance while the quality of the solution decreases insignificantly."
    }, {
      "heading" : "3.3 D-LIAN",
      "text" : "LIAN algorithm as described above guarantees it’s soundness and completeness only in respect to it’s input parameter – Δ. Thus, in general there exist a possibility that some valid solutions can be missed in case Δ is initialized “in a wrong way”. Necessity to initialize LIAN with fixed Δ also leads to another obvious problem: which exact value to choose? In cluttered spaces setting Δ too high will likely make LIAN report failure because line-of-sight constraints will be continuingly violated resulting in exhausting of OPEN list (there simply will be no candidates to fill it up). At the same time setting Δ too low leads to the reduction of potential successors for any cell being processed (obviously – the lower the value Δ is the less cells form the discrete circumference of radius Δ which defines the SUCC) and thus OPEN list is likely to exhaust again.\nTo address abovementioned problems and make LIAN behavior more flexible and adaptable we suggest dynamically change Δ while performing the search. The modification of LIAN that uses this technique will be referred to as D-LIAN.\nD-LIAN works exactly the same as LIAN except the following case. If all the potential successors (of some node under investigation – [a]), that satisfy maximum angle of alteration constraint, are un-traversable then Δ is half-decreased and the search for the successors is repeated. If, again, no valid successors are found, Δ is half-decreased once again, and this continues up to the moment value of Δ reaches some predefined threshold Δmin (or some valid successor(s) is generated). If the threshold is reached and still not a single valid successor is generated D-LIAN exits the Expand() procedure (and no nodes are added to OPEN). If, at some point of time, when Δ=Δi, valid successors are generated, Δi is remembered and then the search from [a] continues using that exact value of Δ (we will refer to it as to Δ([a])). If next n successive elaborations of [a] are all characterized by successful generation of successors then Δ([a]) is half increased. The upper limit on Δ value, e.g. Δmax, is also set by the user.\nThus while performing the search D-LIAN dynamically adjusts Δ in order to generate as many successors of each node as it is needed to solve the task. One of the features of D-LIAN is that multiple Δ are potentially used during the search. Technically this is achieved by storage of Δ-value referenced to a node. Thus D-LIAN node becomes a quadruple: [a, g([a]), bp([a]), Δ([a])]. Input parameters of D-LIAN are: Δinit – initial value of Δ, Δmin – the lower threshold, Δmax – the upper threshold, n – the number of steps after which Δ is half-increased (if the increase is valid). In the experiments we use the following bindings: n=2, Δmin=Δinit/2, Δmax=Δinit."
    }, {
      "heading" : "4 Experimental analysis",
      "text" : "The experimental setup for the comparative study of the algorithms considered in the paper – LIAN, D-LIAN, Theta*-LA, wTheta*-LA – was the Windows7-operated PC, iCore2 quad 2.5GHz, 2Gb RAM. All the algorithms were coded in C++ using the same data structures and programming techniques.\nUrban outdoor navigation scenario was targeted and path finding for small un-\nmanned aerial vehicle (UAV) performing nap-of-the-earth flight was addressed.\nEach grid involved in the tests was constructed using OpenStreetMaps (OSM) data [19]: a 1347m x 1347m fragment of actual city environment was retrieved from OSM and discretized to a 501 x 501 grid (so one cell refers to 2,7m x 2,7m area). Cells corresponding to the areas occupied by buildings were marked un-traversable. Five different start-goal locations were chosen for each environment fragment residing more than 1350m one from the other (so dist(start, goal)≥500). In total, the testbed consisted of 405 various path planning tasks (81 grids, 5 start-goal locations per grid). Targeted angle constraints were: 20, 25 and 30. These figures were advised by the peers involved in UAV controllers design (using these angle constraints indirectly guarantees the feasibility of the path for a particular model of the UAV).\nThe following indicators were used to compare the algorithms: sm – success maps – number of the successfully accomplished angle constrained\npath planning tasks;\nsr – success rate – the same as above but measured as ratio: sm/n, where n is the\ntotal number of tasks (e.g. 400);\nt – time (in seconds) – time needed for the algorithm to produce solution; m – memory (in nodes) – number of elements stored in OPENCLOSED (the\nmemory consumption of the algorithm);\npl – path length (in meters) – the length of the resulting angle-constrained path.\nPreliminary tests had been conducted to roughly assess the algorithms’ performance. The following observations were made. First, LIAN in some cases (under some parameterizations while solving some tasks) terminates minutes after it has been invoked. So a 60-seconds time limit was suggested for further testing, e.g. if any algorithm did not terminate within 60 seconds the result of the test was considered to be failure. Second, using weighted heuristic radically improves LIAN’s computational performance while path length reduces insignificantly (around 1-2%). So in further tests LIAN was run with the heuristic weight equal to 2. Third, “the best” parameters for wTheta*-LA (p=0.1, r=12) were identified and these parameters were used further on.\nThe main series of tests involved the following algorithms: 4 instances of LIAN, each using it’s own Δ: 3, 5, 10, 20, referred, further as LIAN-3, LIAN-5, LIAN-10, LIAN-20; Theta*-LA and wTheta*-LA. Thus, 6*3*405=7290 experiments in total were conducted. Obtained results are shown on figure 5.\nFigures shown in the table (except sm and sr indicators) are the averaged values with failures not considered while averaging. Namely, for each algorithm t, m, pl values were averaged taking into account only it’s respective sm positive results.\nAs one can see Theta*-LA is totally inapplicable to angle-constrained path planning (when angle constraint is set to 20-30), as in this it fails to solve two thirds (or more) of tasks. Weighting a grid, e.g. using wTheta*-LA, significantly (up to several times) improves the performance. But still, wTheta*-LA successfully handles only 14%-55%- 73% of the tasks (for angle constraints 20, 25, 30 respectively), while the worst LIAN result, e.g. the result of LIAN-20 is 66%-72%-79% respectively. So, one can say, that in general even the “worst” LIAN is 1,5 times better (in terms of the number of successfully handled tasks) than “the best” wTheta*-LA.\nWorth mentioning are the results of LIAN-3. While it solves 99% of tasks when angle limit is 30, in case the latter is 20-25 only one third of tasks is solved. It indirectly confirms the hypothesis (see section 3.3) that lower values of Δ should be avoided in general. Setting Δ too high – 20 in our case – also degrades the algorithm performance.\nIf we now take a closer look at the results of best LIAN instances, e.g LIAN-5 and LIAN-10, and compare them to the best results achieved by limited angle Theta*, e.g. to wTheta*-LA results, and use normalization, we’ll get the following picture – see figure 6.\nAs one can see LIAN-5 and LIAN-10 both significantly (up to 5-10 times) outperform wTheta*-LA in terms of time and memory usage. At the same time, path produces by them are only 1% longer that wTheta*-LA paths.\nWhen the best algorithms of LIAN’s family, e.g. LIAN-5 and LIAN-10, were identified we conducted another experiment, tailored to answer the following question – can their performance be further improved by using dynamic Δ adjustment technique as described in section 3.3? So we repeated the tests but now only LIAN-5, LIAN-10 and their dynamic modifications D-LIAN-5, D-LIAN-10 were used (the latter were parameterized as it was suggested in section 3.3). The results are shown in figure 7.\nAs one can see dynamic adjustment of Δ increases the chances of finding a solution. It also decreases running time and memory usage in some cases (for example, when Δ=10, dynamic adjustment reduces the memory consumption on notable 10-15%). So D-LIAN proves to be a worthwhile modification of LIAN.\nSumming up all the results one can claim that LIAN (especially with dynamic Δ adjustment, and initial Δ values set to 5 or 10) is an effective algorithm of solving angle constrained path planning problems on square grids and it significantly outperforms it’s direct competitors, e.g. wTheta*-LA, in terms of computational efficiency and the ability to accomplish path finding tasks (at least when the urban outdoor navigation scenarios are under consideration)."
    }, {
      "heading" : "5 Conclusions and future work",
      "text" : "In this work we have investigated the angle constrained path planning problem for square grids and presented a new parameterized algorithm – LIAN (and it’s variation D-LIAN) – for solving it. We have proved that LIAN is sound and complete (with the respect to it’s input parameter – Δ). We have studied LIAN experimentally in various modeled outdoor navigation scenarios and showed that it significantly outperforms existing analogues: it solves more angle constrained path planning tasks than the competitors while using less memory and processing time.\nIn future we intend to develop more advanced techniques of dynamic Δ adjustment, aimed at further improvement of LIAN performance. Another appealing direction of research is evaluating LIAN in real environments, e.g. implementing LIAN as part of the intelligent control system that automates navigation of a mobile robot or unmanned aerial vehicle in real world.\nAcknowledgements. This work was partially supported by RFBR, research project No. 15-07-07483."
    } ],
    "references" : [ {
      "title" : "An algorithm for planning collision-free paths among polyhedral obstacles",
      "author" : [ "T. Lozano-Pérez", "M.A. Wesley" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1979
    }, {
      "title" : "Roadmap-based path planning-Using the Voronoi diagram for a clearance-based shortest path",
      "author" : [ "P. Bhattacharya", "M.L. Gavrilova" ],
      "venue" : "Robotics & Automation Magazine,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2008
    }, {
      "title" : "Navigation queries from triangular meshes",
      "author" : [ "M. Kallmann" ],
      "venue" : "In Motion in Games (pp",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2010
    }, {
      "title" : "Grid-based path-finding",
      "author" : [ "P. Yap" ],
      "venue" : "Proceedings of 15th Conference of the Canadian Society for Computational Studies of Intelligence,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2002
    }, {
      "title" : "Benchmarks for grid-based pathfinding",
      "author" : [ "N.R. Sturtevant" ],
      "venue" : "Computational Intelligence and AI in Games, IEEE Transactions on,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2012
    }, {
      "title" : "Using occupancy grids for mobile robot perception and navigation",
      "author" : [ "A. Elfes" ],
      "venue" : null,
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1989
    }, {
      "title" : "A note on two problems in connexion with graphs",
      "author" : [ "E.W. Dijkstra" ],
      "venue" : "Numerische mathematik,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 1959
    }, {
      "title" : "A formal basis for the heuristic determination of minimum cost paths",
      "author" : [ "P.E. Hart", "N.J. Nilsson", "B. Raphael" ],
      "venue" : "IEEE Transactions on Systems Science and Cybernetics,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 1968
    }, {
      "title" : "ARA*: Anytime A* with Provable Bounds on Sub-Optimality, Advances in Neural Information Processing Systems 16 (NIPS)",
      "author" : [ "M. Likhachev", "G. Gordon", "S. Thrun" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2004
    }, {
      "title" : "Near optimal hierarchical path finding",
      "author" : [ "A. Botea", "M. Muller", "J. Schaeffer" ],
      "venue" : "Journal of game development,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2004
    }, {
      "title" : "Any-Angle Path Planning on Grids",
      "author" : [ "A. Nash", "K. Daniel", "S. Koenig", "Felner", "A. 2007. Theta" ],
      "venue" : "In Proceedings of the National Conference on Artificial Intelligence",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1177
    }, {
      "title" : "Online graph pruning for pathfinding on grid maps",
      "author" : [ "D. Harabor", "A. Grastien" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2011
    }, {
      "title" : "Real-time motion planning with applications to autonomous urban driving",
      "author" : [ "Y. Kuwata", "S. Karaman", "J. Teo", "E. Frazzoli", "J.P. How", "G. Fiore" ],
      "venue" : "Control Systems Technology, IEEE Transactions on,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2009
    }, {
      "title" : "Improving efficiency in any-angle path-planning algorithms",
      "author" : [ "P. Munoz", "M. Rodriguez-Moreno" ],
      "venue" : "In Intelligent Systems (IS),",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "Angular rate-constrained path planning algorithm for unmanned surface vehicles",
      "author" : [ "H. Kim", "D. Kim", "J.U. Shin", "H. Myung" ],
      "venue" : "Ocean Engineering,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2014
    }, {
      "title" : "Algorithm for computer control of a digital plotter",
      "author" : [ "J.E. Bresenham" ],
      "venue" : "IBM Systems journal,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1965
    }, {
      "title" : "Algorithms of conic generation",
      "author" : [ "M.L.V. Pitteway" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1985
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Among the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4].",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 1,
      "context" : "Among the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4].",
      "startOffset" : 118,
      "endOffset" : 121
    }, {
      "referenceID" : 2,
      "context" : "Among the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4].",
      "startOffset" : 141,
      "endOffset" : 144
    }, {
      "referenceID" : 3,
      "context" : "Among the most commonly used (for 2D path planning) graph models one can name visibility graphs [1], Voronoi diagrams [2], navigation meshes [3], regular grids [4].",
      "startOffset" : 160,
      "endOffset" : 163
    }, {
      "referenceID" : 4,
      "context" : "First, they appear naturally in many virtual environments (computer games are the most obvious example [5]), e.",
      "startOffset" : 103,
      "endOffset" : 106
    }, {
      "referenceID" : 5,
      "context" : "Even in real world scenarios, say in robotics, it is the grids that are commonly used as spatial models [6].",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 6,
      "context" : "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra’s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.",
      "startOffset" : 117,
      "endOffset" : 120
    }, {
      "referenceID" : 7,
      "context" : "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra’s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.",
      "startOffset" : 137,
      "endOffset" : 140
    }, {
      "referenceID" : 8,
      "context" : "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra’s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.",
      "startOffset" : 226,
      "endOffset" : 229
    }, {
      "referenceID" : 9,
      "context" : "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra’s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.",
      "startOffset" : 236,
      "endOffset" : 240
    }, {
      "referenceID" : 10,
      "context" : "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra’s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.",
      "startOffset" : 258,
      "endOffset" : 262
    }, {
      "referenceID" : 11,
      "context" : "After the graph is constructed the search for a path on it can be carried out by the well known Dijkstra’s algorithm [7] or A* algorithm [8] (which is the heuristic modification of Dijkstra) or many of their derivatives: ARA* [9], HPA* [10], R* [11], Theta* [12], JPS [13] to name a few.",
      "startOffset" : 268,
      "endOffset" : 272
    }, {
      "referenceID" : 12,
      "context" : "The most common way to incorporate agent’s dynamic constraints into path planning process is to extend the graph model – see [14] for example – but this leads to tremendous growth of the search space (which now contains not only the spatial information) and thus finding a path becomes burdensome and computationally ineffective.",
      "startOffset" : 125,
      "endOffset" : 129
    }, {
      "referenceID" : 9,
      "context" : "For example A*-PS [10] runs A*-search on a grid and after it is finished performs a preprocessing step to eliminate intermediate path elements.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 10,
      "context" : "Theta* (or more precise – Basic Theta*) [12] uses the same idea – intermediate grid elements skipping – but it performs the smoothing procedure online, e.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 13,
      "context" : "In [15] a modification of Basic Theta* (also applicable to A*-PS) algorithm is presented which uses special angle-based heuristic to focus the search in order to construct more straightforward paths to the goal.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 14,
      "context" : "In [16] another modification of Basic Theta* – weighted angular rate constrained Theta* (wARC-Theta*) - is described.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 15,
      "context" : "In our work, as in many others, we use well-known in computer graphics Bresenham algorithm [17] to detect if lineof-sight between two cells exist or not.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 16,
      "context" : "Δ-section is such section e=aij, alk that it’s endpoint, alk, belongs to CIRCLE(aij, Δ), where CIRCLE is the set of cells identified by the well-known in computer graphics Midpoint algorithm [18] (which is a modification of the abovementioned Brezenham’s algorithm intended for drawing “discrete circumferences”) – see figure 2.",
      "startOffset" : 193,
      "endOffset" : 197
    }, {
      "referenceID" : 14,
      "context" : "In [16] H.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 10,
      "context" : "present a modification of Basic Theta* [12] algorithm tailored to solve grid path planning problem for an agent with angular rate constraints.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 14,
      "context" : "In the original work [16] H.",
      "startOffset" : 21,
      "endOffset" : 25
    }, {
      "referenceID" : 7,
      "context" : "LIAN relies on A* [8] state-space search strategy, uses line-of-sight checks as Theta* [12] and exploits the idea of multiple parents as R* [11].",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 10,
      "context" : "LIAN relies on A* [8] state-space search strategy, uses line-of-sight checks as Theta* [12] and exploits the idea of multiple parents as R* [11].",
      "startOffset" : 87,
      "endOffset" : 91
    } ],
    "year" : 2015,
    "abstractText" : "Square grids are commonly used in robotics and game development to model an agent’s environment, and well known in Artificial Intelligence heuristic search algorithms (A*, JPS, Theta* etc.) are utilized for grid path planning. A lot of research in this area has been focused so far on finding the shortest paths while in many applications producing smooth paths is preferable. In our work, we study the problem of generating smooth grid paths and concentrate on angle constrained path planning. We put angle constrained path planning problem formally and present a new algorithm of solving it – LIAN. We examine LIAN both theoretically and empirically. On the theoretical side, we prove that LIAN is sound and complete (under well-defined restrictions). On the experimental side, we show that LIAN significantly outperforms competitors in ability to find solutions under tough resource constraints and in computational efficiency.",
    "creator" : "Microsoft® Word 2013"
  }
}