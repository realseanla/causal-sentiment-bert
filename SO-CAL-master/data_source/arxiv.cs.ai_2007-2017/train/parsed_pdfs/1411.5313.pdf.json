{
  "name" : "1411.5313.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Ontology Module Extraction via Datalog Reasoning",
    "authors" : [ "Ana Armas Romero", "Mark Kaminski", "Ian Horrocks" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 Introduction Module extraction is the task of computing, given an ontology T and a signature of interest Σ, a (preferably small) subsetM of T (a module) that preserves all relevant entailments in T over the set of symbols Σ. Such anM is indistinguishable from T w.r.t. Σ, and T can be safely replaced withM in applications of T that use only the symbols in Σ.\nModule extraction has received a great deal of attention in recent years (Stuckenschmidt, Parent, and Spaccapietra 2009; Cuenca Grau et al. 2008; Seidenberg and Rector 2006; Kontchakov, Wolter, and Zakharyaschev 2010; Gatens, Konev, and Wolter 2014; Del Vescovo et al. 2011; Nortje, Britz, and Meyer 2013), and modules have found a wide range of applications, including ontology reuse (Cuenca Grau et al. 2008; Jiménez-Ruiz et al. 2008), matching (Jiménez-Ruiz and Cuenca Grau 2011), debugging (Suntisrivaraporn et al. 2008; Ludwig 2014) and classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al. 2010).\nThe preservation of relevant entailments is formalised via inseparability relations. The strongest notion is model inseparability, which requires that it must be possible to turn any model ofM into a model of T by (re-)interpreting only the symbols outside Σ; such an M preserves all second-order\nentailments of T w.r.t. Σ (Konev et al. 2013). A weaker and more flexible notion is deductive inseparability, which requires only that T and M entail the same Σ-formulas in a given query language. Unfortunately, the decision problems associated with module extraction are invariably of high complexity, and often undecidable. For model inseparability, checking whetherM is a Σ-module in T is undecidable even if T is restricted to be in the description logic (DL) EL, for which standard reasoning is tractable. For deductive inseparability, the problem is typically decidable for lightweight DLs and “reasonable” query languages, albeit of high worst-case complexity; e.g., the problem is already EXPTIME-hard for EL if we consider concept inclusions as the query language (Lutz and Wolter 2010). Practical algorithms that ensure minimality of the extracted modules are known only for acyclic ELI (Konev et al. 2013) and DLLite (Kontchakov, Wolter, and Zakharyaschev 2010).\nPractical module extraction techniques are typically based on sound approximations: they ensure that the extracted fragment M is a module (i.e., inseparable from T w.r.t. Σ), but they give no minimality guarantee. The most popular such techniques are based on a family of polynomially checkable conditions called syntactic locality (Cuenca Grau et al. 2007; 2008; Sattler, Schneider, and Zakharyaschev 2009); in particular, ⊥-locality and >⊥∗-locality. Each locality-based module M enjoys a number of desirable properties for applications: (i) it is model inseparable from T ; (ii) it is depleting, in the sense that T \\ M is inseparable from the empty ontology w.r.t. Σ; (iii) it contains all justifications (a.k.a. explanations) in T of every Σ-formula entailed by T ; and (iv) last but not least, it can be computed efficiently, even for very expressive ontology languages.\nLocality-based techniques are easy to implement, and surprisingly effective in practice. Their main drawback is that the extracted modules can be rather large, which limits their usefulness in some applications (Del Vescovo et al. 2013). One way to address this issue is to develop techniques that more closely approximate minimal modules while still preserving properties (i)–(iii). Efforts in this direction have confirmed that locality-based modules can be far from optimal in practice (Gatens, Konev, and Wolter 2014); however, these techniques apply only to rather restricted ontology languages and utilise algorithms with high worst-case complexity.\nar X\niv :1\n41 1.\n53 13\nv2 [\ncs .A\nI] 2\n0 N\nov 2\n01 4\nAnother approach to computing smaller modules is to weaken properties (i)–(iii), which are stronger than is required in many applications. In particular, model inseparability (property (i)) is a very strong condition, and deductive inseparability would usually suffice, with the query language determining which kinds of consequence are preserved; in modular classification, for example, only atomic concept inclusions need to be preserved. However, all practical module extraction techniques that are applicable to expressive ontology languages yield modules satisfying all three properties, and hence potentially much larger than they need to be.\nIn this paper, we propose a technique that reduces module extraction to a reasoning problem in datalog. The connection between module extraction and datalog was first observed in (Suntisrivaraporn 2008), where it was shown that locality ⊥-module extraction for EL ontologies could be reduced to propositional datalog reasoning. Our approach takes this connection much farther by generalising both locality-based and reachability-based (Nortje, Britz, and Meyer 2013) modules for expressive ontology languages in an elegant way. A key distinguishing feature of our technique is that it can extract deductively inseparable modules, with the query language tailored to the requirements of the application at hand, which allows us to relax Property (i) and extract significantly smaller modules. In all cases our modules preserve the nice features of locality: they are widely applicable (even beyond DLs), they can be efficiently computed, they are depleting (Property (ii)) and they preserve all justifications of relevant entailments (Property (iii)).\nWe have implemented our approach using the RDFox datalog engine (Motik et al. 2014). Our proof of concept evaluation shows that module size consistently decreases as we consider weaker inseparability relations, which could significantly improve the usefulness of modules in applications.\nAll our proofs are deferred to the appendix.\n2 Preliminaries Ontologies and Queries We use standard first-order logic and assume familiarity with description logics, ontology languages and theorem proving. A signature Σ is a set of predicates and Sig(F ) denotes the signature of a set of formulas F . It is assumed that the nullary falsehood predicate ⊥ belongs to every Σ. To capture a wide range of KR languages, we formalise ontology axioms as rules: function-free sentences of the form ∀x.[ϕ(x) → ∃y.[ ∨n i=1 ψi(x,y)]], where ϕ, ψi are conjunctions of distinct atoms. Formula ϕ is the rule body and ∃y.[ ∨n i=1 ψi(x,y)] is the head. Universal quantification is omitted for brevity. Rules are required to be safe (all variables in the head occur in the body) and we assume w.l.o.g. that > (resp. ⊥) does not occur in rule heads (resp. in rule bodies). A TBox T is a finite set of rules; TBoxes mentioning equality (≈) are extended with its standard axiomatisation. A fact γ is a function-free ground atom. An ABox A is a finite set of facts. A positive existential query (PEQ) is a formula q(x) = ∃y.ϕ(x,y), where ϕ is built from function-free atoms using only ∧ and ∨.\nDatalog A rule is datalog if its head has at most one atom and all variables are universally quantified. A datalog pro-\ngram P is a set of datalog rules. Given P and an ABox A, their materialisation is the set of facts entailed by P ∪ A, which can be computed by means of forward-chaining. A fact γ is a consequence of a datalog rule r = ∧n i=1 γ ′ i → δ and facts γ1, . . . , γn if γ = δσ with σ a most-general unifier (MGU) of γi, γ′i for each 1 ≤ i ≤ n. A (forward-chaining) proof of γ in P ∪A is a pair ρ = (T, λ) where T is a tree, λ is a mapping from nodes in T to facts, and from edges in T to rules in P , such that for each node v the following holds: 1. λ(v) = γ if v is the root of T ; 2. λ(v) ∈ A if v is a leaf; and 3. if v has children w1, . . . , wn then each edge from v to wi is labelled by the same rule r and λ(v) is a consequence of r and λ(w1), . . . , λ(wn). Forward-chaining is sound and complete: a fact γ is in the materialisation of P ∪A iff it has a proof in P ∪A. Finally, the support of γ is the set of rules occurring in some proof of γ in P ∪ A. Inseparability Relations & Modules We next recapitulate the most common inseparability relations studied in the literature. We say that TBoxes T and T ′ are • Σ-model inseparable (T ≡mΣ T ′), if for every model I of T (resp. of T ′) there exists a model J of T ′ (resp. of T ) with the same domain s.t. AI = AJ for each A ∈ Σ.\n• Σ-query inseparable (T ≡qΣ T ′) if for every Boolean PEQ q and Σ-ABoxAwe have T ∪A |= q iff T ′∪A |= q.\n• Σ-fact inseparable (T ≡fΣ T ′) if for every fact γ and ABox A over Σ we have T ∪ A |= γ iff T ′ ∪ A |= γ.\n• Σ-implication inseparable (T ≡iΣ T ′) if for each ϕ of the form A(x)→ B(x) with A,B ∈ Σ, T |= ϕ iff T ′ |= ϕ. These relations are naturally ordered from strongest to weakest: ≡mΣ ( ≡ q Σ ( ≡fΣ ( ≡iΣ for each non-trivial Σ.\nGiven an inseparability relation≡ for Σ, a subsetM⊆ T is a ≡-module of T if T ≡M. Furthermore,M is minimal if noM′ (M is a ≡-module of T .\n3 Module Extraction via Datalog Reasoning In this section, we present our approach to module extraction by reduction into a reasoning problem in datalog. Our approach builds on recent techniques that exploit datalog engines for ontology reasoning (Kontchakov et al. 2011; Stefanoni, Motik, and Horrocks 2013; Zhou et al. 2014). In what follows, we fix an arbitrary TBox T and signature Σ ⊆ Sig(T ). Unless otherwise stated, our definitions and theorems are parameterised by such T and Σ. We assume w.l.o.g. that rules in T do not share existentially quantified variables. For simplicity, we also assume that T contains no constants (all our results can be seamlessly extended)."
    }, {
      "heading" : "3.1 Overview and Main Intuitions",
      "text" : "Our overall strategy to extract a moduleM of T for an inseparability relation ≡zΣ, with z ∈ {m, q, f, i}, can be summarised by the following steps: 1. Pick a substitution θ mapping all existentially quantified\nvariables in T to constants, and transform T into a datalog program P by (i) Skolemising all rules in T using θ and (ii) turning disjunctions into conjunctions while splitting them into different rules, thus replacing each function-free\ndisjunctive rule of the form ϕ(x) → ∨n i=1 ψi(x) with\ndatalog rules ϕ(x)→ ψ1(x), . . . , ϕ(x)→ ψn(x). 2. Pick a Σ-ABox A0 and materialise P ∪ A0. 3. Pick a set Ar of “relevant facts” in the materialisation\nand compute the supporting rules in P for each such fact. 4. The moduleM consists of all rules in T that yield some\nsupporting rule in P . In this way,M is fully determined by the substitution θ and the ABoxes A0 and Ar.\nThe main intuition behind our module extraction approach is that we can pick θ, A0 and Ar (and henceM) such that each proof ρ of a Σ-consequence ϕ of T to be preserved can be embedded in a forward chaining proof ρ′ in P ∪ A0 of a relevant fact in Ar. Such an embedding satisfies the key property that, for each rule r involved in ρ, at least one corresponding datalog rule inP is involved in ρ′. In this way we ensure thatM contains the necessary rules to entail ϕ. This approach, however, does not ensure minimality ofM: since P is a strengthening of T there may be proofs of a relevant fact in P ∪A0 that do not correspond to a Σ-consequence of T , which may lead to unnecessary rules inM.\nTo illustrate how our strategy might work in practice, suppose that T is T ex in Fig. 1, Σ = {B,C,D,G}, and that we want a module M that is Σ-implication inseparable from T ex. This is a simple case since ϕ = D(x) → G(x) is the only non-trivial Σ-implication entailed by T ex; thus, forM to be a module we only require thatM |= ϕ.\nProving T ex |= ϕ amounts to proving T ex ∪ {D(a)} |= G(a) (with a a fresh constant). Figure 2(a) depicts a hyperresolution tree ρ showing how G(a) can be derived from the clauses corresponding to r4–r6 and D(a), with rule r4 transformed into clauses r′4 = D(x)→ S(x, f(x3)) r′′4 = D(x)→ E(f(x3)) HenceM = {r4–r6} is a Σ-implication inseparable module of T ex, and as G(a) cannot be derived from any subset of {r4–r6},M is also minimal.\nIn our approach, we pick A0 to contain the initial fact D(a),Ar to contain the fact to be proved G(a), and we make θ map variable y3 in r4 to a fresh constant c, in which case rule r4 corresponds to the following datalog rules in P:\nD(x)→ S(x, c) D(x)→ E(c) Figure 2(b) depicts a forward chaining proof ρ′ of G(a) in P ∪ {D(a)}. As shown in the figure, ρ can be embedded in ρ′ via θ by mapping functional terms over f to the fresh constant c. In this way, the rules involved in ρ are mapped to the datalog rules involved in ρ′ via θ. Consequently, we will extract the (minimal) moduleM = {r4–r6}."
    }, {
      "heading" : "3.2 The Notion of Module Setting",
      "text" : "The substitution θ and the ABoxes A0 and Ar, which determine the extracted module, can be chosen in different ways to ensure the preservation of different kinds of Σconsequences. The following notion of a module setting captures in a declarative way the main elements of our approach.\nDefinition 1. A module setting for T and Σ is a tuple χ = 〈θ,A0,Ar〉 with θ a substitution from existentially quantified variables in T to constants, A0 a Σ-ABox, Ar a Sig(T )-ABox, and s.t. no constant in χ occurs in T .\nThe program of χ is the smallest datalog program Pχ containing, for each r = ϕ(x) → ∃y.[ ∨n i=1 ψi(x,y)] in T , the rule ϕ → ⊥ if n = 0 and all rules ϕ → γθ for each 1 ≤ i ≤ n and each atom γ in ψi. The support of χ is the set of rules r ∈ Pχ that support a fact from Ar in Pχ ∪A0. The module Mχ of χ is the set of rules in T that have a corresponding datalog rule in the support of χ."
    }, {
      "heading" : "3.3 Modules for each Inseparability Relation",
      "text" : "We next consider each inseparability relation ≡zΣ, where z ∈ {m, q, f, i}, and formulate a specific setting χz which provably yields a ≡zΣ-module of T .\nImplication Inseparability The example in Section 3.1 suggests a natural setting χi = 〈θ,A0,Ar〉 that guarantees implication inseparability. As in our example, we pick θ to be as “general” as possible by Skolemising each existentially quantified variable to a fresh constant. For A and B predicates of the same arity n, proving that T entails a Σimplication ϕ = A(x1, . . . , xn)→ B(x1, . . . , xn), amounts to showing that T ∪ {A(a1, . . . , an)} |= B(a1, . . . , an) for fresh constants a1, . . . , an. Thus, following the ideas of our example, we initialiseA0 with a fact A(c1A, . . . , cnA) for each n-ary predicate A ∈ Σ, andAr with a fact B(c1A, . . . , cnA) for each pair of n-ary predicates {B,A} ⊆ Σ with B 6= A. Definition 2. For each existentially quantified variable yj in T , let cyj be a fresh constant. Furthermore, for each A ∈ Σ of arity n, let c1A, . . . , c n A be also fresh constants. The setting χi = 〈θi,Ai0,Air〉 is defined as follows: • θi = { yj 7→ cyj | yj existentially quantified in T }, • Ai0 = {A(c1A, . . . , cnA) | A n-ary predicate in Σ}, and • Air = {B(c1A, . . . , cnA) |A 6= B n-ary predicates in Σ}.\nThe setting χi is reminiscent of the datalog encodings typically used to check whether a concept A is subsumed by concept B w.r.t. a “lightweight” ontology T (Krötzsch, Rudolph, and Hitzler 2008; Stefanoni, Motik, and Horrocks 2013). There, variables in rules are Skolemised as fresh constants to produce a datalog program P and it is then checked whether P ∪ {A(a)} |= B(a). Theorem 3. Mχi ≡iΣ T .\nFact Inseparability The setting χi in Def. 2 cannot be used to ensure fact inseparability. Consider again T ex and Σ = {B,C,D,G}, for which Mχi = {r4, r5, r6}. For A = {B(a),C(a)}we have T ex∪A |= G(a) butMχi∪A 6|= G(a), and henceMχi is not fact inseparable from T ex.\nMore generally, Mχi is only guaranteed to preserve Σfact entailments T ∪ A |= γ where A is a singleton. However, for a module to be fact inseparable from T it must preserve all Σ-facts when coupled with any Σ-ABox. We achieve this by choosing A0 to be the critical ABox for Σ, which consists of all facts that can be constructed using Σ and a single fresh constant (Marnette 2009). Every Σ-ABox can be homomorphically mapped into the critical Σ-ABox. In this way, we can show that all proofs of a Σ-fact in T ∪A can be embedded in a proof of a relevant fact in Pχ ∪ A0. Definition 4. Let constants cyi be as in Def. 2, and let ∗ be a fresh constant. The setting χf = 〈θf ,Af0,Afr〉 is defined as follows: (i) θf = θi, (ii) Af0 = {A(∗, . . . , ∗) | A ∈ Σ }, and (iii) Afr = Af0\nThe datalog programs for χi and χf coincide and hence the only difference between the two settings is in the definition of their corresponding ABoxes. In our example, bothAf0 and Afr contain facts B(∗), C(∗), D(∗), and G(∗). Clearly, Pχf ∪ A0 |= G(∗) and the proof additionally involves rule r3. ThusMχf = {r3, r4, r5, r6}. Theorem 5. Mχf ≡fΣ T .\nQuery Inseparability Positive existential queries constitute a much richer query language than facts as they allow for existentially quantified variables. Thus, the query inseparability requirement invariably leads to larger modules.\nFor instance, let T = T ex and Σ = {A,B}. Given the Σ-ABox A = {A(a)} and Σ-query q = ∃y.B(y) we have that T ex∪A |= q (due to rule r1). The moduleMχf is, however, empty. Indeed, the materialisation ofPχf∪{A(∗)} consists of the additional facts R(∗, cy1) and B(cy1) and hence it does not contain any relevant fact mentioning only ∗. Thus, Mχf ∪ A 6|= q andMχf is not query inseparable from T ex.\nOur example suggests that, although the critical ABox is constrained enough to embed every Σ-ABox, we may need to consider additional relevant facts to capture all proofs of a Σ-query. In particular, rule r1 implies that B contains an instance whenever A does: a dependency that is then checked by q. This can be captured by considering fact B(cy1) as relevant, in which case rule r1 would be in the module.\nMore generally, we consider a module setting χ that differs from χf only in that all Σ-facts (and not just those over ∗) are considered as relevant.\nDefinition 6. Let constants cyi and ∗ be as in Def. 4. The setting χq = 〈θq,Aq0,Aqr〉 is as follows: (i) θq = θf , (ii) A q 0 = Af0, and (iii) Aqr consists of all Σ-facts A(a1, . . . , an) with each aj either a constant cyi or ∗.\nCorrectness is established by the following theorem:\nTheorem 7. Mχq ≡qΣ T .\nModel Inseparability The modules generated by χq may not be model inseparable from T . To see this, let T = T ex and Σ = {A,D,R}, in which case Mχq = {r1, r2}. The interpretation I where ∆I = {a, b}, AI = {a}, BI = CI = {b}, DI = ∅ and RI = {(a, b)} is a model of Mχq . This interpretation, however, cannot be extended to a model of r3 (and hence of T ) without reinterpreting A, R or D.\nThe main insight behind locality and reachability modules is to ensure that each model of the module can be extended to a model of T in a uniform way. Specifically, each model of a >⊥∗-locality or >⊥∗-reachability module can be extended to a model of T by interpreting all other predicates A as either ∅ or (∆I)n with n the arity of A. Thus,M = {r1, r2, r3} is a ≡mΣ-module of T ex since all its models can be extended by interpreting E, F and G as the domain, H as empty, and S as the Cartesian product of the domain. We can capture this idea in our framework by means of the following setting.\nDefinition 8. The setting χm = 〈θm,Am0 ,Amr 〉 is as follows: θm maps each existentially quantified variable to the fresh constant ∗ and Am0 = Amr = Af0.\nIn our example, Pχm ∪Am0 entails the relevant facts A(∗), R(∗, ∗) and D(∗), and henceMχm = {r1, r2, r3}.\nTo show that Mχm is a ≡mΣ-module we prove that all models I ofMχm can be extended to a model of T as follows: (i) predicates not occurring in the materialisation of Pχm ∪ Am0 are interpreted as empty; (ii) predicates in the support of χm (and hence occurring inMχm ) are interpreted as in I; and (iii) all other predicates A are interpreted as (∆I)n with n the arity of A.\nTheorem 9. Mχm ≡mΣ T ."
    }, {
      "heading" : "3.4 Modules for Ontology Classification",
      "text" : "Module extraction has been exploited for optimising ontology classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al. 2010). In this case, it is not only required that modules\nare implication inseparable from T , but also that they preserve all implications A(x)→ B(x) with A ∈ Σ but B /∈ Σ. This requirement can be captured as given next.\nDefinition 10. TBoxes T and T ′ are Σ-classification inseparable (T ≡cΣ T ′) if for each ϕ of the form A(x) → B(x) with A ∈ Σ, and B ∈ Sig(T ∪ T ′) we have T |= ϕ iff T ′ |= ϕ.\nClassification inseparability is a stronger requirement than implication inseparability. For T = {A(x) → B(x)} and Σ = {A}, M = ∅ is implication inseparable from T , whereas classification inseparability requires thatM = T .\nModular reasoners such as MORe and Chainsaw rely on locality ⊥-modules, which satisfy this requirement. Each model of a ⊥-module M can be extended to a model of T by interpreting all additional predicates as empty, which is not possible if A ∈ Σ and T entails A(x) → B(x) but M does not. We can cast ⊥-modules in our framework with the following setting, which extends χm in Def. 8 by also considering as relevant facts involving predicates not in Σ.\nDefinition 11. The setting χb = 〈θb,Ab0,Abr〉 is as follows: θb = θm,Ab0 = Am0 , andAr consists of all facts A(∗, . . . , ∗) where A ∈ Sig(T ).\nThe use of ⊥-modules is, however, stricter than is needed for ontology classification. For instance, if we consider T = T ex and Σ = {A} we have that Mχb contains all rules r1–r6, but since A does not have any subsumers in T ex the empty TBox is already classification inseparable from T ex.\nThe following module setting extends χi in Def. 2 to ensure classification inseparability. As in the case of χb in Def. 11 the only required modification is to also consider as relevant facts involving predicates outside Σ.\nDefinition 12. Setting χc = (θc,Ac0,Acr) is as follows: θc = θi, Ac0 = Ai0, and Acr consists of all facts B(c1A, . . . , cnA) s.t. A 6= B are n-ary predicates, A ∈ Σ and B ∈ Sig(T ).\nIndeed, if we consider again T = T ex and Σ = {A}, the module for χc is empty, as desired.\nTheorem 13. Mχc ≡cΣ T ."
    }, {
      "heading" : "3.5 Additional Properties of Modules",
      "text" : "Although the essential property of a moduleM is that it captures all relevant Σ-consequences of T , in some applications it is desirable that modules satisfy additional requirements.\nIn ontology reuse scenarios, it is sometimes desirable that a module M does not “leave any relevant information behind”, in the sense that T \\ M does not entail any relevant Σ-consequence—a property referred to as depletingness (Kontchakov, Wolter, and Zakharyaschev 2010).\nDefinition 14. Let ≡zΣ be an inseparability relation. A ≡zΣmoduleM of T is depleting if T \\M ≡zΣ ∅.\nNote that not all modules are depleting: for some relevant Σ-entailment ϕ it may be thatM |= ϕ (as required by the definition of module), but also that (T \\M) |= ϕ, in which caseM is not depleting. The following theorem establishes that all modules defined in Section 3.3 are depleting.\nTheorem 15. Mχz is depleting for each z ∈ {m, q, f, i, c}.\nAnother common application of modules is to optimise the computation of justifications: minimal subsets of a TBox that are sufficient to entail a given formula (Kalyanpur et al. 2007; Suntisrivaraporn et al. 2008). Definition 16. Let T |= ϕ. A justification for ϕ in T is a minimal subset T ′ ⊆ T such that T ′ |= ϕ.\nJustifications are displayed in ontology development platforms as explanations of why an entailment holds, and tools typically compute all of them. Extracting justifications is a computationally intensive task, and locality-based modules have been used to reduce the size of the problem: if T ′ is a justification of ϕ in T , then T ′ is contained in a locality module of T for Σ = Sig(ϕ). Our modules are also justification-preserving, and we can adjust our modules depending on what kind of first-order sentence ϕ is. Theorem 17. Let T ′ be a justification for a first-order sentence ϕ in T and let Sig(ϕ) ⊆ Σ. Then, T ′ ⊆ Mχm . Additionally, the following properties hold: (i) if ϕ is a rule, then T ′ ⊆ Mχq ; (ii) if ϕ is datalog, then T ′ ⊆ Mχf ; and (iii) if ϕ is of the form A(x) → B(x), then T ′ ⊆ Mχi; finally, if ϕ satisfies A ∈ Σ, B ∈ Sig(T ), then T ′ ⊆Mχc ."
    }, {
      "heading" : "3.6 Complexity of Module Extraction",
      "text" : "We conclude this section by showing that our modules can be efficiently computed in most practically relevant cases. Theorem 18. Letm be a non-negative integer and L a class of TBoxes s.t. each rule in a TBox from L has at most m distinct universally quantified variables. The following problem is tractable: given z ∈ {q, f, i, c}, T ∈ L, and r ∈ T , decide whether r ∈Mχz . The problem is solvable in polynomial time for arbitrary classes L of TBoxes if z = m.\nWe now provide a proof sketch for this result. Checking whether a datalog program P and an ABox A entail a fact is feasible in O(|P| · nv), with n the number of constants in P∪A and v the maximum number of variables in a rule from P (Dantsin et al. 2001). Thus, although datalog reasoning is exponential in the size of v (and hence of P), it is tractable if v is bounded by a constant.\nGiven arbitrary T and Σ, and for z ∈ {m, q, f, i, c}, the datalog program Pχz can be computed in linear time in the size of |T |. The number of constants n in χz (and hence in Pχz ∪ Az0) is linearly bounded in |T |, whereas the maximum number of variables v coincides with the maximum number of universally quantified variables in a rule from T . As shown in (Zhou et al. 2014), computing the support of a fact in a datalog program is no harder than fact entailment, and thus module extraction in our approach is feasible in O(|T |·nv), and thus tractable for ontology languages where rules have a bounded number of variables (as is the case for most DLs). Finally, if z = m the setting χm involves a single constant ∗ and module extraction boils down to reasoning in propositional datalog (a tractable problem regardless of T )."
    }, {
      "heading" : "3.7 Module Containment and Optimality",
      "text" : "Intuitively, the more expressive the language for which preservation of consequences is required the larger modules need to be. The following proposition shows that our modules are consistent with this intuition.\nProposition 19. Mχi ⊆ Mχf ⊆ Mχq ⊆ Mχm ⊆ Mχb andMχi ⊆Mχc ⊆Mχb\nAs already discussed, these containment relations are strict for many T and Σ.\nWe conclude this section by discussing whether each χz with z ∈ {q, f, i, c} is optimal for its inseparability relation in the sense that there is no setting that produces smaller modules. To make optimality statements precise we need to consider families of module settings, that is, functions that assign a module setting for each pair of T and Σ. Definition 20. A setting family is a function Ψ that maps a TBox T and signature Σ to a module setting for T and Σ. We say that Ψ is uniform if for every Σ and pair of TBoxes T , T ′ with the same number of existentially quantified variables Ψ(T ,Σ) = Ψ(T ′,Σ). Let z ∈ {i, f, q, c}; then, Ψ is z-admissible if, for each T and Σ,MΨ(T ,Σ) is a≡zΣ-module of T . Finally, Ψ is z-optimal ifMΨ(T ,Σ) ⊆ MΨ′(T ,Σ) for every T , Σ and every uniform Ψ′ that is z-admissible.\nUniformity ensures that settings do not depend on the specific shape of rules in T , but rather only on Σ and the number of existentially quantified variables in T . In turn, admissibility ensures that each setting yields a module. The (uniform and admissible) family Ψz corresponding to each setting χz in Sections 3.3 and 3.4 is defined in the obvious way: for each T and Σ, Ψz(T ,Σ) is the setting χz for T and Σ.\nThe next theorem shows that Ψz is optimal for implication and classification inseparability. Theorem 21. Ψz is z-optimal for z ∈ {i, c}.\nIn contrast, Ψq and Ψf are not optimal. To see this, let T = {A(x) → B(x),B(x) → A(x)} and Σ = {A}. The empty TBox is fact inseparable from T since the only Σconsequence of T is the tautology A(x) → A(x). However, Mχf = T since fact A(a) is in Afr and its support is included in the module. We can provide a family of settings that distinguishes tautological from non-tautological inferences (see appendix); however, this family yields settings of exponential size in |T |, which is undesirable in practice.\n4 Proof of Concept Evaluation We have implemented a prototype system for module extraction that uses RDFox for datalog materialisation (Motik et al. 2014). Additionally, the ontology reasoner PAGOdA (Zhou et al. 2014) provides functionality for computing the support of an entailed fact in datalog, which we have adapted for computing modules. We have evaluated our system on representative ontologies, including SNOMED (SCT), Fly Anatomy (FLY), the Gene Ontology (GO) and BioModels (BM).1 SCT is expressed in the EL profile of OWL 2, whereas FLY, GO and BM require expressive DLs (HornSRI, SHIQ and SRIQ, respectively). We have normalised all ontologies to make axioms equivalent to rules.\nWe compared the size of our modules with the localitybased modules computed using the OWL API. We have followed the experimental methodology from (Del Vescovo et\n1The ontologies used in our tests are available for download at http://www.cs.ox.ac.uk/isg/ontologies/UID/ under IDs 794 (FLY), 795 (SCT), 796 (GO) and 797 (BM).\nal. 2013) where two kinds of signatures are considered: genuine signatures corresponding to the signature of individual axioms, and random signatures with a given probability for a symbol to be included. For each type of signature and ontology, we took a sample of 400 runs and averaged module sizes. For random signatures we considered a probability of 1/1000. All experiments have been performed on a server with two Intel Xeon E5-2643 processors and 90GB of allocated RAM, running RDFox on 16 threads.\nTable 1 summarises our results. We compared⊥-modules with the modules for χc (Section 3.4) and >⊥∗-modules with those for χm, χq, χf , and χi (Section 3.3). We can see that module size consistently decreases as we consider weaker inseparability relations. In particular, the modules for χc can be 4 times smaller than ⊥-modules. The difference between >⊥∗-modules and χi modules is even bigger, especially in the case of FLY. In fact, χi modules are sometimes empty, which is not surprising since two predicates in a large ontology are unlikely to be in an implication relationship. Also note that our modules for semantic inseparability slightly improve on >⊥∗-modules. Finally, recall that our modules may not be minimal for their inseparability relation. Since techniques for extracting minimal modules are available only for model inseparability, and for restricted languages, we could not assess how close our modules are to minimal ones and hence the quality of our approximation.\nComputation times were comparable for all settings χz with times being slightly higher for χi and χc as they involved a larger number of constants. Furthermore, extraction times were comparable to locality-based modules for genuine signatures with average times of 0.5s for FLY, 0.9s for SCT, 4.2 for GO and 5s for BM.\n5 Conclusion and Future Work We have proposed a novel approach to module extraction by exploiting off-the-shelf datalog reasoners, which allows us to efficiently compute approximations of minimal modules for different inseparability relations. Our results open the door to significant improvements in common applications of modules, such as computation of justifications, modular and incremental reasoning and ontology reuse, which currently rely mostly on locality-based modules.\nOur approach is novel, and we see many interesting open problems. For example, the issue of optimality requires fur-\nther investigation. Furthermore, it would be interesting to integrate our extraction techniques in existing modular reasoners as well as in systems for justification extraction.\nAcknowledgements This work was supported by the Royal Society, the EPSRC projects MaSI3, Score! and DBOnto, and by the EU FP7 project OPTIQUE.\nReferences Armas Romero, A.; Cuenca Grau, B.; and Horrocks, I. 2012. MORe: Modular combination of OWL reasoners for ontology classification. In ISWC, 1–16. Cuenca Grau, B.; Horrocks, I.; Kazakov, Y.; and Sattler, U. 2007. Just the right amount: Extracting modules from ontologies. In WWW, 717–726. Cuenca Grau, B.; Horrocks, I.; Kazakov, Y.; and Sattler, U. 2008. Modular reuse of ontologies: Theory and practice. J. Artif. Intell. Res. 31:273–318. Cuenca Grau, B.; Halaschek-Wiener, C.; Kazakov, Y.; and Suntisrivaraporn, B. 2010. Incremental classification of description logics ontologies. J. Autom. Reason. 44(4):337– 369. Dantsin, E.; Eiter, T.; Gottlob, G.; and Voronkov, A. 2001. Complexity and expressive power of logic programming. ACM Comput. Surv. 33(3):374–425. Del Vescovo, C.; Parsia, B.; Sattler, U.; and Schneider, T. 2011. The modular structure of an ontology: Atomic decomposition. In IJCAI, 2232–2237. Del Vescovo, C.; Klinov, P.; Parsia, B.; Sattler, U.; Schneider, T.; and Tsarkov, D. 2013. Empirical study of logicbased modules: Cheap is cheerful. In DL, 144–155. Gatens, W.; Konev, B.; and Wolter, F. 2014. Lower and upper approximations for depleting modules of description logic ontologies. In ECAI, 345–350. Jiménez-Ruiz, E., and Cuenca Grau, B. 2011. LogMap: Logic-based and scalable ontology matching. In ISWC, 273– 288. Jiménez-Ruiz, E.; Cuenca Grau, B.; Sattler, U.; Schneider, T.; and Berlanga Llavori, R. 2008. Safe and economic re-use of ontologies: A logic-based methodology and tool support. In ESWC, 185–199. Kalyanpur, A.; Parsia, B.; Horridge, M.; and Sirin, E. 2007. Finding all justifications of OWL DL entailments. In ISWC, 267–280. Konev, B.; Lutz, C.; Walther, D.; and Wolter, F. 2013. Model-theoretic inseparability and modularity of description logic ontologies. Artif. Intell. 203:66–103. Kontchakov, R.; Lutz, C.; Toman, D.; Wolter, F.; and Zakharyaschev, M. 2011. The combined approach to ontologybased data access. In IJCAI, 2656–2661. Kontchakov, R.; Wolter, F.; and Zakharyaschev, M. 2010. Logic-based ontology comparison and module extraction, with an application to DL-Lite. Artif. Intell. 174(15):1093– 1141.\nKrötzsch, M.; Rudolph, S.; and Hitzler, P. 2008. ELP: Tractable rules for OWL 2. In ISWC, 649–664. Ludwig, M. 2014. Just: a tool for computing justifications w.r.t. ELH ontologies. In ORE, 1–7. Lutz, C., and Wolter, F. 2010. Deciding inseparability and conservative extensions in the description logic EL. J. Symb. Comput. 45(2):194–228. Marnette, B. 2009. Generalized schema-mappings: From termination to tractability. In PODS, 13–22. Motik, B.; Nenov, Y.; Piro, R.; Horrocks, I.; and Olteanu, D. 2014. Parallel materialisation of datalog programs in centralised, main-memory RDF systems. In AAAI, 129–137. Nortje, R.; Britz, K.; and Meyer, T. 2013. Reachability modules for the description logic SRIQ. In LPAR, 636–652. Sattler, U.; Schneider, T.; and Zakharyaschev, M. 2009. Which kind of module should I extract? In DL. Seidenberg, J., and Rector, A. L. 2006. Web ontology segmentation: Analysis, classification and use. In WWW, 13– 22. Stefanoni, G.; Motik, B.; and Horrocks, I. 2013. Introducing nominals to the combined query answering approaches for EL. In AAAI, 1177–1183. Stuckenschmidt, H.; Parent, C.; and Spaccapietra, S., eds. 2009. Modular Ontologies: Concepts, Theories and Techniques for Knowledge Modularization, volume 5445 of LNCS. Springer. Suntisrivaraporn, B.; Qi, G.; Ji, Q.; and Haase, P. 2008. A modularization-based approach to finding all justifications for OWL DL entailments. In ASWC, 1–15. Suntisrivaraporn, B. 2008. Module extraction and incremental classification: A pragmatic approach for ontologies. In ESWC, 230–244. Tsarkov, D., and Palmisano, I. 2012. Chainsaw: A metareasoner for large ontologies. In ORE. Zhou, Y.; Nenov, Y.; Cuenca Grau, B.; and Horrocks, I. 2014. Pay-as-you-go OWL query answering using a triple store. In AAAI, 1142–1148.\nA Inseparability Relations We start by giving an alternative characterization of Σ-query and Σ-fact inseparability that will allow us to prove our results in a more uniform and clear way.\nProposition 22. TBoxes T and T ′ are"
    }, {
      "heading" : "1. Σ-query inseparable iff T |= r ⇔ T ′ |= r holds for every rule r over Σ;",
      "text" : ""
    }, {
      "heading" : "2. Σ-fact inseparable iff T |= r ⇔ T ′ |= r holds for every datalog rule r over Σ.",
      "text" : "Proof. It suffices to observe that, for every TBox T and every rule r = ϕ → ψ over Σ, T |= r iff T ∪ { γσ | γ ∈ ϕ } |= ψσ, with σ a substitution mapping all free variables in r to fresh, pairwise distinct constants.\nProposition 23. ≡m ( ≡q ( ≡f ( ≡i.\nProof. The inclusion ≡q ⊆ ≡f is immediate by definition while ≡f ⊆ ≡i follows by Proposition 22. The inclusion ≡m ⊆ ≡q follows since rI = rI|Σ = rI ′|Σ = rI ′\nfor every rule r over Σ whenever I and I ′ coincide on Σ. To show strictness of the inclusions, we can w.l.o.g. restrict ourselves to the signature Σ = {Q,⊥} where Q is a unary predicate (if Σ contains more symbols, one can consider T such that Sig(T ) ∩ Σ ⊆ {Q}; adapting the argument to higher arities for Q is also straightforward; finally, the presence of ⊥ in Σ is not relevant for the proof).\nFor ≡m ( ≡q, suppose T = {>(x) → ∃y.[R(x, y) ∧ A(y)],>(x) → ∃y.[R(x, y) ∧ B(y)],A(x) ∧ B(x) → Q(x)}. Then T ≡a ∅. However, T 6≡m ∅ since, for any interpretation I with a singleton domain such that QI = ∅, I cannot be turned into a model of T without changing the interpretation of Q.\nFor ≡q ( ≡f , suppose T = {>(x) → ∃y.[R(x, y) ∧ Q(y)]}. Then T ≡f ∅ but T 6≡q ∅ since T |= ∃x.Q(x) while ∅ 6|= ∃x.Q(x).\nFor ≡f ( ≡i, suppose T = {r} where r = Q(a) ∧ Q(b)→ Q(c). Then T ≡i ∅ but T 6≡d ∅ since T |= r while ∅ 6|= r.\nB Deductive Inseparability Theorems 3, 5, 7, 13 are all shown by a similar argument, which we present next.\nHyperresolution Given r = ϕ(x)→ ∃y.[ ∨n i=1 ψ(x,y)] ∈ T we denote with sk(r) the result of applying standard Skolemisation to r—which replaces, for each y ∈ y, all occurrences of y in r by fy(x), where fy is a fresh function symbol unique for y. Given a substitution θ mapping existentially quantified variables in T to constants and a Skolemised formula ϕ, we write Γθ(ϕ) for the formula obtained from ϕ by replacing every occurrence of a functional term fy(t) by the constant yθ.\nBy distributing disjunctions over conjunctions in the head of sk(r) we obtain a rule of the form ϕ → ∧m j=1 ψ ′ j where each ψ′j is a disjunction of atoms. We denote with cnf(r) the set {ϕ→ ψ′j | 1 ≤ j ≤ m } and extend this notation in the natural way to cnf(T ) = ⋃ r∈T cnf(r). We call cnf(T ) a CNF TBox and each s ∈ cnf(T ) a CNF rule. Clearly, cnf(T ) |= T , and hence T ∪ A |= ϕ′ implies cnf(T ) ∪ A |= ϕ′ for every A and ϕ′. Let ϕ be a disjunction of facts, A an ABox, and s = ∧n i=1 γ ′ i → ψ ∈ cnf(T ). A formula ϕ is a hyperresolvent of s and\nground disjunctions γ1 ∨ ψ1, . . . , γn ∨ ψn (with each ψi potentially empty) if ϕ = ∨n i=1 ψi ∨ ψσ with σ a MGU of γi, γ′i for each 1 ≤ i ≤ n. Let C be a CNF TBox. A hyperresolution proof (or simply a proof ) of ϕ in C ∪ A is a pair ρ = (T, λ) where T is a tree, λ is a mapping from nodes in T to disjunctions of facts, and from edges in T to CNF rules in C, such that for every node v the following properties hold:\n1. λ(v) = ϕ if v is the root of T ;\n2. λ(v) ∈ A if v is a leaf in T ; and 3. if v has children w1, . . . , wn then each edge from v to wi is labelled by the same CNF rule s and λ(v) is a hyperresolvent of s and λ(w1), . . . , λ(wn).\nIf there exists a proof of ϕ in C ∪ A we write C ∪ A ` ϕ. The support of ϕ is the set of CNF rules occurring in some proof of ϕ in C ∪ A.\nHyperresolution is sound (if C ∪A ` ϕ then C ∪A |= ϕ) and complete in the following sense: if C ∪A |= ϕ then there exists ψ ⊆ ϕ such that C ∪ A ` ψ.\nGiven a module setting χ and r ∈ T , we denote with Ξχ(r) the set of datalog rules in Pχ corresponding to r, as described in Definition 1. The following auxiliary results provide the basis for correctness of our approach to module extraction.\nLemma 24. Let χ = 〈θ,A0,Ar〉 be a module setting. Let N be the set of constants mentioned in χ. Let A be a functionfree ABox that only mentions constants that are fresh w.r.t. T and N. Let ν be a mapping from constants in A to N such that Aν ⊆ A0. Let ϕ be a disjunction of facts and ρ = (T, λ) a proof of ϕ in cnf(T ) ∪ A. The following properties hold: 1. Pχ ∪ A0 ` Γθ(γν) for every γ ∈ ϕ.\n2. For every r ∈ T such that ρ mentions some s ∈ cnf(r) there exists γ ∈ ϕ ∪ {⊥} and a proof of Γθ(γν) in Pχ ∪ A0 that mentions some rule in Ξχ(r).\nProof. We reason by induction on the depth d of ρ.\nd = 0 In this case ϕ must be a fact in A. Since A is function-free by assumption we have Γθ(ϕν) = ϕν, and since Aν ⊆ A0 we have ϕν ∈ A0. Therefore, there exists a trivial proof of Γθ(ϕν) in Pχ ∪ A0 and property 1 is satisfied. Furthermore, if the depth of ρ is 0 then there cannot be any rules in its support, so property 2 is trivially satisfied as well.\nd > 0 Let v be the root of T and w1, . . . , wn the children of v. Then it must be – λ(wi) = δi ∨ ψi for each 1 ≤ i ≤ n; – λ(v, wi) = s for each 1 ≤ i ≤ n with s ∈ cnf(T ) of the form ∧n i=1 δ ′ i → ϕ′; and\n– ϕ = ∨n i=1 ψi ∨ ϕ′σ with σ a MGU of δi, δ′i for each 1 ≤ i ≤ n. Consider γ ∈ ϕ. To show property 1 we need to find a proof of Γθ(γν) in Pχ ∪ A0. If γ ∈ ψi then by i.h. we can find such a proof. If γ ∈ ϕ′σ then it must be γ = γ′σ for some γ′ ∈ ϕ′ and, by definition of Pχ, cnf(T ), and Γθ, s ∈ cnf(T ) implies ∧n i=1 δ ′ i → Γθ(γ′) ∈ Pχ. Since σ is a MGU of δi, δ′i (with δi = δ′iσ) for each 1 ≤ i ≤ n, σν must be a MGU of δiν, δ′i (with δiν = δ ′ iσν) for each 1 ≤ i ≤ n; furthermore, since δ′i is necessarily function-free, it is Γθ(δ′iσν) = δ′iσν, and thus Γθ(δiν) = δ′iσν and σν is also a MGU of Γθ(δiν), δ ′ i for each 1 ≤ i ≤ n. By i.h. we have a proof in Pχ ∪ A0 of\nΓθ(δiν) for each 1 ≤ i ≤ n; it is easy to see that Γθ(γ′)σν = Γθ(γ′σν) = Γθ(γν), so combining these proofs with rule∧n i=1 δ ′ i → Γθ(γ′) yields a proof of Γθ(γν) in Pχ ∪ A0. Now consider r ∈ T such that ρ mentions some s′ ∈ cnf(r). To show property 2 we need to find γ ∈ ϕ ∪ {⊥} and a proof of Γθ(γν) that mentions some rule in Ξχ(r). Assume first that s′ = s. If ϕ′ = ∅ then it must be cnf(r) = { ∧n i=1 δ ′ i → ⊥} ⊆ Ξχ(r) and, as before, we can combine this rule with proofs in Pχ ∪A0 of the Γθ(δiν) to obtain a proof of ⊥ in Pχ ∪A0. If ϕ′ 6= ∅ then it must be { ∧n i=1 δ ′ i → Γθ(γ′) | γ′ ∈ ϕ′ } ⊆ Ξχ(r). Since ϕ = ∨n i=1 ψi ∨ ϕ′σ, for each γ′ ∈ ϕ′ it is γ′σ ∈ ϕ\nand, as we just saw, we can construct a proof of Γθ(γ′σν) that mentions ∧n i=1 δ ′ i → Γθ(γ′). Finally, assume that s′ 6= s. Then there must be some i ∈ {1, . . . , n} such that s′ is mentioned by the proof ρi of δi ∨ ψi that is embedded in ρ. Since ρi is of depth < d, by i.h. there must be δ′′ ∈ δi ∨ ψi and a proof ρ′′ of Γθ(δ′′ν) in Pχ ∪A0 that mentions some rule in Ξχ(r). If δ′′ ∈ ψi then δ′′ ∈ ϕ already; if δ′′ = δi then, as before, for any γ ∈ ϕ we can construct a proof of Γθ(γν) in Pχ ∪ A0 such that ρ′′ is embedded in it.\nProposition 25. Let r = ϕ(x) → ψ(x) with ϕ a conjunction and ψ a disjunction of atoms. Let χ = 〈θ,A0,Ar〉 be a module setting satisfying {⊥} ⊆ Ar and such that for every substitution σ mapping all variables in r to pairwise distinct constants not in T there exists a mapping νσ with ϕσνσ ⊆ A0 and ψσνσ ⊆ Ar. Then 1. T |= r iffMχ |= r;"
    }, {
      "heading" : "2. if T ′ ⊆ T is a justification for r in T then T ′ ⊆Mχ;",
      "text" : ""
    }, {
      "heading" : "3. T \\Mχ |= r iff ∅ |= r.",
      "text" : "Proof.\n1. By monotonicity, it is immediate that T |= r ifMχ |= r. Suppose T |= r and let σ be a substitution mapping all variables in r to fresh, pairwise distinct constants. Then we have that T ∪ { γσ | γ ∈ ϕ } |= ψσ, which implies cnf(T ) ∪ { γσ | γ ∈ ϕ } |= ψσ and by completeness of hyperresolution cnf(T ) ∪ { γσ | γ ∈ ϕ } ` ψ′ for some ψ′ ⊆ ψσ. Since { γσνσ | γ ∈ ϕ } ⊆ A0, by Lemma 24 we have that for each s ∈ T such that some p ∈ cnf(s) supports ψ′ in cnf(T ) ∪ { γσ | γ ∈ ϕ } there exists γ ∈ Γθ(ψ′νσ) ∪ {⊥} that is supported in Pχ ∪A0 by some rule from Ξχ(s). By assumption, ⊥ ∈ Ar; also, ψ′ is function-free so Γθ(ψ′νσ) = ψ′νσ , and hence, since ψσνσ ⊆ Ar, we have that ψ′νσ ⊆ Ar and also γ ∈ Ar. In either case we have s ∈Mχ and consequentlyMχ |= r. 2. Let T ′ ⊆ T be a justification for r in T . As before, if σ is a ground substitution for r mapping variables in r to fresh, pairwise distinct constants, then cnf(T ′) ∪ { γσ | γ ∈ ϕ } ` ψ′ for some ψ′ ⊆ ψσ. In fact, by minimality of justifications, for each s ∈ T ′ some p ∈ cnf(s) must be in the support of some ψ′ ⊆ ψσ in cnf(T ′)∪{ γσ | γ ∈ ϕ }. As before, by Lemma 24, this implies s ∈Mχ.\n3. By monotonicity, it is immediate that T \\Mχ |= r if ∅ |= r. Suppose T \\Mχ |= r and let T ′ be a justification for r in T \\Mχ. Then T ′ is also a justification for r in T , and, as we just proved, T ′ ⊆Mχ. This implies that T ′ = ∅, and therefore ∅ |= r.\nProposition 26. Let r = ϕ(x)→ ∃y.[ ∨n i=1 ψi(x,y)] be a rule. Let χ = 〈θ,A0,Ar〉 be a module setting satisfying\n• {⊥} ⊆ Ar and also ψσ ⊆ Ar for every substitution σ mapping all variables in r to constants in χ;\n• for every substitution σ mapping all variables in r to pairwise distinct constants not in T there exists a mapping νσ such that ϕσνσ ⊆ A0.\nThen 1. T |= r iffMχ |= r; 2. if T ′ ⊆ T is a justification for r in T then T ′ ⊆Mχ;"
    }, {
      "heading" : "3. T \\Mχ |= r iff ∅ |= r.",
      "text" : "Proof.\n1. By monotonicity, it is immediate that T ∪ A |= r ifMχ ∪ A |= r. Let Q be a fresh predicate and Tψ→Q = {ψi(x,y)→ Q(x) | 1 ≤ i ≤ n }. Then\nT |= r iff T ∪ Tψ→Q |= ϕ(x)→ Q(x) and Mχ |= r iff Mχ ∪ Tψ→Q |= ϕ(x)→ Q(x) Consider T ′ = T ∪ Tψ→Q and Σ′ = Σ ∪ {Q}. Clearly, T ′ has the exact same existentially quantified variables as T . Therefore χ′ = 〈θ,A0,A′r〉 with A′r = {Q(x)σ | σ is a substitution mapping all variables in x to constants in χ } is a module setting for T ′ and Σ′ and by Proposition 25 we have that T ′ |= ϕ(x)→ Q(x) iffMχ′ |= ϕ(x)→ Q(x). If we show thatMχ′ \\ Tψ→Q ⊆Mχ then, by monotonicity, we will be able to conclude that\nMχ ′ |= ϕ(x)→ Q(x) impliesMχ ∪ Tψ→Q |= ϕ(x)→ Q(x)\nand thus that T |= r impliesMχ |= r. Let s ∈ Mχ′ \\ Tψ→Q. Some p ∈ Ξχ ′ (s) = Ξχ(s) must be in the support of some Q(x)σ ∈ A′r in Pχ\n′ ∪ A0. In particular, p must be mentioned in some proof ρ = (T, λ) of Q(x)σ in Pχ′ ∪ A0. Let v be the root of T and w1, . . . , wm its children nodes, there must be some ∧m j=1 γj(x,y) → Q(x) ∈ Tψ→Q and a MGU σ′ of γj , λ(wj) for each 1 ≤ j ≤ m. Since s /∈ Tψ→Q, there must exist j ∈ {1, . . . ,m} such that p is mentioned in the proof ρj of λ(wj) in Pχ ′ ∪A0 that is embedded in ρ. Furthermore, since Q does not occur in the body of any rule in Pχ′ = Pχ ∪ Tψ→Q, all rules mentioned in ρj must be in Pχ and thus ρj is a proof of γ in Pχ ∪ A0. Since by assumption λ(wj) = γjσ′ ∈ Ar, this implies s ∈Mχ. 2. Let T ′′ ⊆ T be a justification for r in T . As before, T ′′ |= r implies T ′′ ∪ Tψ→Q |= ϕ(x) → Q(x) and in particular for any substitution σ mapping variables in r to pairwise distinct constants we have T ′′ ∪ Tψ→Q ∪ { γσ | γ ∈ ϕ } |= Q(x)σ and therefore cnf(T ′′ ∪ Tψ→Q) ∪ { γσ | γ ∈ ϕ } ` Q(x)σ. By minimality of justifications, for each s ∈ T ′′ there must be some p ∈ cnf(s) in the support of Q(x)σ in cnf(T ′′ ∪ Tψ→Q) ∪ { γσ | γ ∈ ϕ }. It is easy to see that p must also be in the support of Q(x)σνσ in cnf(T ′′ ∪ Tψ→Q) ∪ { γσνσ | γ ∈ ϕ }. Since Q(x)σνσ ⊆ A′r and { γσνσ | γ ∈ ϕ } ⊆ A0, by Lemma 24 we have that s ∈Mχ′ . In particular, since s ∈ T ′′ ⊆ T , it must be s ∈Mχ′ \\ Tψ→Q ⊆Mχ. 3. Again by monotonicity, it is immediate that T \\Mχ∪A |= r ifA |= r. By a similar argument to the one given in Proposition 25, it follows from 2 that any justification for r in T \\Mχ must be empty and therefore if T \\Mχ |= r then ∅ |= r.\nTheorem 3. Mχi ≡iΣ T .\nProof. Consider an arbitrary rule of the form A(x) → B(x) with A,B ∈ Σ and A 6= B (if A = B the rule is tautological). Since x is implicitly universally quantified, we can assume w.l.o.g. that x = (x1, . . . , xn) with x1, . . . , xn pairwise distinct. Let σ be a substitution mapping x1, . . . , xn, respectively, to c1, . . . , cn, pairwise distinct constants not in T . Now consider a mapping νσ such that ciνσ = ciA. This mapping is well-defined because c1, . . . , cn are pairwise distinct. By definition of χi, we have A(x)σνσ ∈ Ai0 and B(x)σνσ ∈ Air, and therefore, by Proposition 25, we have T |= A(x) → B(x) iff Mχi |= A(x)→ B(x).\nTheorem 5. Mχf ≡fΣ T .\nProof. By Proposition 22 it suffices to show that for any datalog rule r = ϕ → ψ we have T |= r iffMχf |= r. Let σ be a substitution mapping all variables in r to pairwise distinct constants not in T . Consider a mapping ν∗ such that xσν∗ = ∗ for each x ∈ x. Clearly ϕσν∗ ⊆ Af0 and ψσν∗ ⊆ Afr, and therefore, by Proposition 25, we have T |= r iffMχf |= r.\nTheorem 7. Mχq ≡qΣ T .\nProof. By Proposition 22 it suffices to show that for any rule r = ϕ→ ψ we have T |= r iffMχq |= r. Let σ be a substitution mapping all variables in r to pairwise distinct constants not in T . Given a mapping ν∗ such that xσν∗ = ∗ for each x ∈ x it is clear that ϕσν∗ ⊆ Aq0. It is also immediate that ψσ′ ⊆ Aqr for every substitution σ′ mapping all variables in r to constants in χq. Therefore, by Proposition 26, we have T |= r iffMχq |= r.\nTheorem 13. Mχc ≡cΣ T .\nProof. Analogous to the proof of Theorem 3.\nC Model Inseparability Given an ABoxA and a datalog program P , let P(A) denote the materialisation of P ∪A. Furthermore, given a module setting χ, let supp(χ) denote the support of χ.\nTheorem 9. Mχm ≡mΣ T .\nProof. Let I be a model ofMχm . We assume w.l.o.g that I is defined over all of Sig(T ). Consider the interpretation J over Sig(T ) such that ∆J = ∆I and\nAJ =  A I if A ∈ (Σ ∪ Sig(supp(χ))) \\ {⊥}\nDarity(A) if A ∈ Sig(Pχm(Am0 )) \\ (Σ ∪ Sig(supp(χ))) ∅ otherwise\nConsider r : ϕ(x)→ ∃y.[ ∨m j=1 ψj(x,y)] ∈ T . We will show that J |= r.\nAssume first m = 0. Then Ξχm(r) = {ϕ → ⊥}. If r ∈ Mχm then in particular Sig(r) ⊆ Sig(supp(χm)), so I and J agree over Sig(r), and J |= r. If r /∈ Mχm then, since ⊥ ∈ Aχmr and the only constant mentioned in Pχm ∪ Am0 is ∗, there must be γ ∈ ϕ such that γ∗ /∈ Pχm(Am0 ) (where, in an abuse of notation, ∗ denotes the substitution that maps all variables to ∗), and in particular Sig(γ) 6⊆ Sig(Pχm(Am0 )). Since Σ∪ Sig(supp(χm)) ⊆ Sig(Pχm(Am0 )), this implies that for A ∈ Sig(γ) it is AJ = ∅ and therefore trivially J |= r.\nAssume now m > 0 and let σ be a substitution over all variables in r such that J |= ϕσ (if no such substitution exists then trivially J |= r). Since Σ ∪ Sig(supp(χ)) ⊆ Sig(Pχm(Am0 )), all predicates in ϕ must occur in Pχm(Am0 ). In particular it must be γ∗ ∈ Pχm(Am0 ) for every γ ∈ ϕ. This implies δ∗ ∈ Pχm(Am0 ) for every δ ∈ ⋃m j=1 ψj and therefore for every predicate\nA in Sig( ∨m j=1 ψj) we have that either A\nJ = AI or AJ = ∆arity(A)—in particular AI ⊆ AJ . If AJ = ∆arity(A) for every A ∈ Sig( ∨m j=1 ψj), then it is immediate that J |= r. Suppose there exists A ∈ Sig( ∨m j=1 ψj) such that A\nJ 6= ∆arity(A). Then A ∈ Σ ∪ Sig(supp(χm)). If A ∈ Σ then A(∗, . . . , ∗) ∈ Aχmr . Since A ∈ Sig( ∨m j=1 ψj) and γ∗ ∈ Pχm(Am0 ) for every γ ∈ ϕ, there is a proof ρA,r of A(∗, . . . , ∗) in Pχm ∪Am0 that mentions a rule in Ξχm(r). Therefore r ∈Mχm . If A ∈ Sig(supp(χm))\\Σ then some other γ′ ∈ Amr must be supported by a rule that has A in its signature. More specifically, there must be a proof of γ′ in Pχm ∪ Am0 that has a proof of A(∗, . . . , ∗) as a subproof. Replacing this subproof with ρA,r results in a proof of γ′ in Pχm ∪ Am0 that mentions a rule in Ξχm(r). Therefore in this case r ∈ Mχm too. Now, since all rules in Ξχm(r) have the same body as r, we have that Sig(ϕ) ⊆ supp(χm) \\ {⊥} and therefore I and J agree over Sig(ϕ). By assumption, J |= ϕσ, so also I |= ϕσ; furthermore I |= Mχm implies I |= ∨m j=1 ψjσ, which implies J |= ∨m j=1 ψjσ because A\nI ⊆ AJ for every predicate A ∈ Sig( ∨m j=1 ψj). Since σ is arbitrary, we conclude that J |= r.\nD Depletingness and Preservation of Justifications Theorem 15. Mχz is depleting for each z ∈ {m, q, f, i, c}.\nProof. For z ∈ {q, f, i, c} the statement follows from Propositions 22, 25 and 26 by the arguments already presented in the proofs for Theorems 3, 5 and 7.\nFor z = m, we will now show that T \\Mχm ≡m ∅. Let I be a model of ∅ and AI the ABox defined by I over Σ. Consider the datalog program P = ⋃ r∈T \\Mχm Ξχm(r), and the materialisation P(AI) of P w.r.t. AI . We show that P(AI) is a model of T \\M that coincides with I over Σ. For this, it suffices to show the following two properties:\n• All facts over Σ in P(AI) must already be in AI . Let γ ∈ P(AI) be a fact over Σ. If γ /∈ AI then there must exist a proof ρ of γ in P ∪ AI . Since AI only mentions predicates from Σ and P ⊆ Pχm , we can find a proof of γ∗ ∈ Amr in Pχm ∪Am0 that mentions the exact same rules as ρ. Let r be a rule mentioned in ρ, there must exist s ∈ T \\Mχm such that r ∈ Ξχm(s); however, because r is also mentioned in a proof of γ∗ in Pχm ∪ Am0 , it must also be s ∈Mχm . This is a contradiction, so γ ∈ AI .\n• ⊥ /∈ P(AI). Suppose⊥ ∈ P(AI). Then there must be a proof ρ of⊥ in P ∪AI . Again, we can find a proof of⊥ in Pχm ∪Am0 supported by the exact same rules as ρ. Following a similar argument as before, we conclude that ⊥ /∈ P(AI).\nTheorem 17. Let T ′ be a justification for a first-order sentence ϕ in T and let Sig(ϕ) ⊆ Σ. Then, T ′ ⊆Mχm . Additionally, the following properties hold: (i) if ϕ is a rule, then T ′ ⊆Mχq ; (ii) if ϕ is datalog, then T ′ ⊆Mχf ; and (iii) if ϕ is of the form A(x)→ B(x), then T ′ ⊆Mχi ; finally, if ϕ satisfies A ∈ Σ, B ∈ Sig(T ), then T ′ ⊆Mχc .\nProof. The claim follows from Propositions 22, 25 and 26 similarly to Theorems 3, 5 and 7.\nE Module Containment Definition 27. Let χ = 〈θ,A0,Ar〉 and χ′ = 〈θ′,A′0,A′r〉 and let N and N′ be the sets of constants mentioned in χ and χ′, respectively. A mapping µ : N → N′ is a homomorphism from χ to χ′ if the following conditions hold: (i) θ′ = θµ, (ii) A0µ ⊆ A′0; and (iii) Arµ ⊆ A′r. We write χ ↪→ χ′ if a homomorphism from χ to χ′ exists.\nTheorem 28. If χ, χ′ are s.t. χ ↪→ χ′, thenMχ ⊆Mχ′ .\nProof. Suppose χ = 〈θ,A0,Ar〉 and χ′ = 〈θ′,A′0,A′r〉with N and N′ the sets of constants mentioned in χ and χ′, respectively. Let µ be a homomorphism from χ to χ′ and let r ∈ Mχ. Some γ ∈ Ar must be supported in Pχ ∪ A0 by a rule in Ξχ(r). Since, by assumption, γµ ∈ A′r, it suffices for us to show that γµ is supported in Pχ ′ ∪ A′0 by a rule from Ξχ ′ (r).\nTo this end we will show that for any rule r ∈ T and any fact γ such that there exists a proof ρ = (T, λ) of γ in Pχ ∪ A0 mentioning s ∈ Ξχ(r), there exists a proof of γµ in Pχ′ ∪ A′0 mentioning Ξχ ′ (r). We will reason by induction on the depth d of ρ—which must be at least 1 since by assumption it uses s.\nd = 1 r must be of the form ∧ i=1n δ ′ i(x)→ ∃y.[ ∨m j=1 ψj(x,y)] so s must be\n– ∧ i=1n δ ′ i → γ′θ with γ′ ∈ ψj for some 1 ≤ j ≤ m if m > 0\nThe λ-images of the leaves of T must be δ1, . . . , δn ∈ A0 such that there exists a MGU σ of δi, δ′i for every 1 ≤ i ≤ n satisfying γ = γ′θσ. By assumption, we have δiµ ∈ A′0 for every 1 ≤ i ≤ n, and also s′ = ∧ i=1n δ ′ i → γ′θ′ ∈ Ξχ ′ (r) where θ′ = θµ. Consider σ′ = σµ. It is easy to see that µσµ = σµ since the domain of σ is disjoint with both the domain and the range of µ. Therefore (δiµ)σµ = δiσµ for every 1 ≤ i ≤ n. Furthermore, since σ is a MGU of δi, δ′i for every 1 ≤ i ≤ n, we have that σ′ is a MGU of δiµ, δ′i for every 1 ≤ i ≤ n. Finally, since θ′ = θµ, we have that γµ = γ′θσµ = γ′θµσµ = γ′θ′σ′ is a consequence of s′ and δ1µ, . . . , δnµ, and hence we have a proof of γµ in Pχ\n′ ∪A′0 supported by s′ ∈ Ξχ′(r).\n– ∧ i=1n δ ′ i → ⊥ if m = 0\nThen it must be γ = ⊥ and, as in the previous case, the λ-images of the leaves of T must be δ1, . . . , δn ∈ A0 such that there exists a MGU σ of δi, δ′i for every 1 ≤ i ≤ n. Also, δiµ ∈ A′0 for every 1 ≤ i ≤ n, s ∈ Ξχ ′ (r), and σ′ = σµ is a MGU of δiµ, δ′i for every 1 ≤ i ≤ n, so we have a proof of γµ = ⊥ in Pχ ′ ∪ A′0 supported by s ∈ Ξχ ′ (r).\nd > 1 Let v be the root of T , let δ1, . . . , δn ∈ A0 be the λ-images of the children of v and let r′ ∈ T be such that the λ-image of the edges connecting v with its children in T is a rule in Ξχ(r′). Either s ∈ Ξχ(r′) or it is mentioned in some subproof of ρ. Our induction hypothesis implies that for each each r′′ ∈ T , if some δi is supported in Pχ ∪ A0 by a rule in Ξχ(r′′), then also δiµ is supported in Pχ ′ ∪ A′0 by some rule in Ξχ ′ (r′′). Therefore, in either case, following an argument similar to case\nd = 1, we can construct a proof ρ′ of γµ in Pχ′ ∪ A′0 from a collection of proofs of δ1µ, . . . , δnµ in Pχ ′ ∪ A′0 and a rule in Ξχ ′ (r′) in such a way that ρ′ mentions a rule in Ξχ ′ (r).\nProposition 19. Mχi ⊆Mχf ⊆Mχq ⊆Mχm ⊆Mχb andMχi ⊆Mχc ⊆Mχb\nProof. This follows immediately from Theorem 28.\nF Optimality Definition 29. Let T be a TBox. Let Σ ⊆ Sig(T ) and Σ′ = Σ \\ {⊥}. For each existentially quantified variable y in T , let cy be a fresh constant. Let θ = { y 7→ cy | y existentially quantified in T }. Furthermore, for each pair 〈A,B〉 ∈ Σ′ × Sig(T ), let cA,B be a vector of fresh constants of size arity(A). We define Ψi0(T ,Σ) = 〈θ,A i0 0 ,Ai0r 〉 where\n• Ai00 = {A(cA,B) | A,B ∈ Σ′,A 6= B, arity(A) = arity(B) } ∪ {A(cA,⊥) | A ∈ Σ′ } • Ai0r = {B(cA,B) | A,B ∈ Σ′,A 6= B, arity(A) = arity(B) } ∪ {⊥} We define Ψc0(T ,Σ) = 〈θ,A c0 0 ,Ac0r 〉 where • Ac00 = {A(cA,B) | A ∈ Σ′,B ∈ Sig(T ) \\ {⊥},A 6= B, arity(A) = arity(B) } ∪ {A(cA,⊥) | A ∈ Σ′ } • Ac0r = {B(cA,B) | A ∈ Σ′,B ∈ Sig(T ) \\ {⊥},A 6= B, arity(A) = arity(B) } ∪ {⊥}\nFor each predicate B ∈ Σ and each v ∈ {1, . . . , arity(B)}arity(B), let ∗1B,v, . . . , ∗ arity(B)+1 B,v be fresh constants. We define Ψf0(T ,Σ) = 〈θ,A f0 0 ,Af0r 〉 where\n• Af00 = {A(d) | A ∈ Σ′,B ∈ Σ,v ∈ {1, . . . , arity(B)}arity(B),d ∈ {∗1B,v, . . . , ∗ arity(B)+1 B,v }arity(A),A(d) 6= B(∗vB,v) }\n• Af0r = {B(∗vB,v) | B ∈ Σ,v ∈ {1, . . . , arity(B)}arity(B) }\nProposition 30. Let z ∈ {i, c}. Then, for every T and Σ,MΨz(T ,Σ) =MΨz0(T ,Σ).\nProof. It is easy to see that Ψz0(T ,Σ) ↪→ Ψz(T ,Σ) for z ∈ {i, c}. By Theorem 28, we thus have thatMΨ z 0(T ,Σ) ⊆MΨz(T ,Σ).\nBefore we continue, note that for each z ∈ {i, c} the datalog programs PΨz(T ,Σ) and PΨz0(T ,Σ) coincide. For readability, we will denote this program with Pz .\nLet r ∈ MΨi(T ,Σ). Some fact γ ∈ Aχir must be supported by a rule in ΞΨ i(T ,Σ)(r) = ΞΨ i 0(T ,Σ)(r). The fact γ must be either ⊥ or B(cA) with A,B ∈ Σ′. It is easy to see how one can turn any proof of ⊥ (resp. B(cA)) in P i ∪ Ai0 into a proof of ⊥ (resp. B(cA,B)) in P i ∪ Ai00 that mentions the exact same rules. By construction of Ψi, both ⊥ and B(cA,B) are in Ai0r , so r ∈MΨi0(T ,Σ). ThereforeMΨi(T ,Σ) ⊆MΨi0(T ,Σ).\nThe argument for z = c is analogous.\nTheorem 21. Ψz is z-optimal for z ∈ {i, c}.\nProof. We show the claim for Ψi, the argument for Ψc is similar. Let Σ′ = Σ \\ {⊥}. For Ψi, suppose for contradiction there is a uniform, i-admissible Ψ and some T such thatMΨi(T ,Σ) 6⊆ MΨ(T ,Σ). Then, by Proposition 30,MΨi0(T ,Σ) 6⊆ MΨ(T ,Σ), and hence, by Theorem 28, Ψi0(T ,Σ) 6↪→ Ψ(T ,Σ). Let Ψ(T ,Σ) = 〈θ′,A′0,A′r〉. Since Ψi0(T ,Σ) 6↪→ Ψ(T ,Σ), by construction of Ψi0, there are two cases to consider: • There are some A,B ∈ Σ′ with arity(A) = arity(B) such that for every vector c of size arity(A) of constants mentioned in\nΨ, A(c) /∈ A′0 or B(c) /∈ A′r. Let\nT ′ = {A(x)→ B(x)} ∪ {→ ∃y.Qy(y) | y existentially quantified in T , Qy fresh for every y }\nThen Ψ(T ′,Σ) = Ψ(T ,Σ) (by uniformity), and henceMΨ(T ′,Σ) = ∅. Since ∅ 6|= A(x)→ B(x), we haveMΨ(T ′,Σ) 6≡i T ′. • We have ⊥ /∈ A′r. Let\nT ′ = {A(x)→ ⊥} ∪ {→ ∃y.Qy(y) | y existentially quantified in T , Qy fresh for every y }\nfor some A ∈ Σ′. Then Ψ(T ′,Σ) = Ψ(T ,Σ) (by uniformity), and henceMΨ(T ′,Σ) = ∅. Since ∅ 6|= A(x) → ⊥, we have MΨ(T ′,Σ) 6≡i T ′.\nIn both cases, we obtain a contradiction to Ψ being i-admissible.\nProposition 31. The family Ψf0 is f-admissible.\nProof. By Propositions 22 and 25, it suffices to show that, given a datalog rule r = ϕ → γ and a substitution σ mapping all variables in r to distinct constants, we can construct a mapping ν such that ϕσν ⊆ Af00 and γσν ∈ Af0r . W.l.o.g. we can assume γ /∈ ϕ (otherwise r is a tautology and hence trivially entailed byMΨf0(T ,Σ)) and therefore γσ /∈ ϕσ by injectivity of σ.\nLet γσ = B(c). We construct ν as follows. Let µ be an ordering of the constants in c. We define ν such that cν = ∗cµB,cµ if c ∈ c and cν = ∗arity(B)+1B,cµ otherwise. Since cµ ∈ {1, . . . , arity(B)}arity(B) we have B(c)ν ∈ Af0r . Moreover, every fact in ϕσ is mapped by ν to a fact A(d) where A ∈ Σ \\ {⊥}, d ∈ {∗1B,c, . . . , ∗ arity(B)+1 B,c }arity(A), and A(d) 6= B(c)ν since B(c) /∈ ϕσ. Thus ϕσν ⊆ Af0r , and the claim follows.\nProposition 32. The family Ψf is not f-optimal.\nProof. By Proposition 31, it suffices to show thatMΨf(T ,Σ) 6⊆ MΨf0(T ,Σ) for some T and Σ. Let T = {A(x) → A(x)} and Σ = {A}. ThenMΨf(T ,Σ) = T 6⊆ ∅ =MΨf0(T ,Σ)."
    } ],
    "references" : [ {
      "title" : "MORe: Modular combination of OWL reasoners for ontology classification",
      "author" : [ "A. Armas Romero", "B. Cuenca Grau", "I. Horrocks" ],
      "venue" : "ISWC, 1–16.",
      "citeRegEx" : "Romero et al\\.,? 2012",
      "shortCiteRegEx" : "Romero et al\\.",
      "year" : 2012
    }, {
      "title" : "Just the right amount: Extracting modules from ontologies",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler" ],
      "venue" : "WWW, 717–726.",
      "citeRegEx" : "Grau et al\\.,? 2007",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2007
    }, {
      "title" : "Modular reuse of ontologies: Theory and practice",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler" ],
      "venue" : "J. Artif. Intell. Res. 31:273–318.",
      "citeRegEx" : "Grau et al\\.,? 2008",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "Incremental classification of description logics ontologies",
      "author" : [ "B. Cuenca Grau", "C. Halaschek-Wiener", "Y. Kazakov", "B. Suntisrivaraporn" ],
      "venue" : "J. Autom. Reason. 44(4):337– 369.",
      "citeRegEx" : "Grau et al\\.,? 2010",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2010
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "E. Dantsin", "T. Eiter", "G. Gottlob", "A. Voronkov" ],
      "venue" : "ACM Comput. Surv. 33(3):374–425.",
      "citeRegEx" : "Dantsin et al\\.,? 2001",
      "shortCiteRegEx" : "Dantsin et al\\.",
      "year" : 2001
    }, {
      "title" : "The modular structure of an ontology: Atomic decomposition",
      "author" : [ "C. Del Vescovo", "B. Parsia", "U. Sattler", "T. Schneider" ],
      "venue" : "IJCAI, 2232–2237.",
      "citeRegEx" : "Vescovo et al\\.,? 2011",
      "shortCiteRegEx" : "Vescovo et al\\.",
      "year" : 2011
    }, {
      "title" : "Empirical study of logicbased modules: Cheap is cheerful",
      "author" : [ "C. Del Vescovo", "P. Klinov", "B. Parsia", "U. Sattler", "T. Schneider", "D. Tsarkov" ],
      "venue" : "DL, 144–155.",
      "citeRegEx" : "Vescovo et al\\.,? 2013",
      "shortCiteRegEx" : "Vescovo et al\\.",
      "year" : 2013
    }, {
      "title" : "Lower and upper approximations for depleting modules of description logic ontologies",
      "author" : [ "W. Gatens", "B. Konev", "F. Wolter" ],
      "venue" : "ECAI, 345–350.",
      "citeRegEx" : "Gatens et al\\.,? 2014",
      "shortCiteRegEx" : "Gatens et al\\.",
      "year" : 2014
    }, {
      "title" : "LogMap: Logic-based and scalable ontology matching",
      "author" : [ "E. Jiménez-Ruiz", "B. Cuenca Grau" ],
      "venue" : "ISWC, 273– 288.",
      "citeRegEx" : "Jiménez.Ruiz and Grau,? 2011",
      "shortCiteRegEx" : "Jiménez.Ruiz and Grau",
      "year" : 2011
    }, {
      "title" : "Safe and economic re-use of ontologies: A logic-based methodology and tool support",
      "author" : [ "E. Jiménez-Ruiz", "B. Cuenca Grau", "U. Sattler", "T. Schneider", "R. Berlanga Llavori" ],
      "venue" : "ESWC, 185–199.",
      "citeRegEx" : "Jiménez.Ruiz et al\\.,? 2008",
      "shortCiteRegEx" : "Jiménez.Ruiz et al\\.",
      "year" : 2008
    }, {
      "title" : "Finding all justifications of OWL DL entailments",
      "author" : [ "A. Kalyanpur", "B. Parsia", "M. Horridge", "E. Sirin" ],
      "venue" : "ISWC, 267–280.",
      "citeRegEx" : "Kalyanpur et al\\.,? 2007",
      "shortCiteRegEx" : "Kalyanpur et al\\.",
      "year" : 2007
    }, {
      "title" : "Model-theoretic inseparability and modularity of description logic ontologies",
      "author" : [ "B. Konev", "C. Lutz", "D. Walther", "F. Wolter" ],
      "venue" : "Artif. Intell. 203:66–103.",
      "citeRegEx" : "Konev et al\\.,? 2013",
      "shortCiteRegEx" : "Konev et al\\.",
      "year" : 2013
    }, {
      "title" : "The combined approach to ontologybased data access",
      "author" : [ "R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "IJCAI, 2656–2661.",
      "citeRegEx" : "Kontchakov et al\\.,? 2011",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2011
    }, {
      "title" : "Logic-based ontology comparison and module extraction, with an application to DL-Lite",
      "author" : [ "R. Kontchakov", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "Artif. Intell. 174(15):1093– 1141.",
      "citeRegEx" : "Kontchakov et al\\.,? 2010",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2010
    }, {
      "title" : "ELP: Tractable rules for OWL 2",
      "author" : [ "M. Krötzsch", "S. Rudolph", "P. Hitzler" ],
      "venue" : "ISWC, 649–664.",
      "citeRegEx" : "Krötzsch et al\\.,? 2008",
      "shortCiteRegEx" : "Krötzsch et al\\.",
      "year" : 2008
    }, {
      "title" : "Just: a tool for computing justifications w.r.t",
      "author" : [ "M. Ludwig" ],
      "venue" : "ELH ontologies. In ORE,",
      "citeRegEx" : "Ludwig,? \\Q2014\\E",
      "shortCiteRegEx" : "Ludwig",
      "year" : 2014
    }, {
      "title" : "Deciding inseparability and conservative extensions in the description logic EL",
      "author" : [ "C. Lutz", "F. Wolter" ],
      "venue" : "J. Symb. Comput. 45(2):194–228.",
      "citeRegEx" : "Lutz and Wolter,? 2010",
      "shortCiteRegEx" : "Lutz and Wolter",
      "year" : 2010
    }, {
      "title" : "Generalized schema-mappings: From termination to tractability",
      "author" : [ "B. Marnette" ],
      "venue" : "PODS, 13–22.",
      "citeRegEx" : "Marnette,? 2009",
      "shortCiteRegEx" : "Marnette",
      "year" : 2009
    }, {
      "title" : "Parallel materialisation of datalog programs in centralised, main-memory RDF systems",
      "author" : [ "B. Motik", "Y. Nenov", "R. Piro", "I. Horrocks", "D. Olteanu" ],
      "venue" : "AAAI, 129–137.",
      "citeRegEx" : "Motik et al\\.,? 2014",
      "shortCiteRegEx" : "Motik et al\\.",
      "year" : 2014
    }, {
      "title" : "Reachability modules for the description logic SRIQ",
      "author" : [ "R. Nortje", "K. Britz", "T. Meyer" ],
      "venue" : "LPAR, 636–652.",
      "citeRegEx" : "Nortje et al\\.,? 2013",
      "shortCiteRegEx" : "Nortje et al\\.",
      "year" : 2013
    }, {
      "title" : "Which kind of module should I extract",
      "author" : [ "U. Sattler", "T. Schneider", "M. Zakharyaschev" ],
      "venue" : "In DL",
      "citeRegEx" : "Sattler et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Sattler et al\\.",
      "year" : 2009
    }, {
      "title" : "Web ontology segmentation: Analysis, classification and use",
      "author" : [ "J. Seidenberg", "A.L. Rector" ],
      "venue" : "WWW, 13–",
      "citeRegEx" : "Seidenberg and Rector,? 2006",
      "shortCiteRegEx" : "Seidenberg and Rector",
      "year" : 2006
    }, {
      "title" : "Introducing nominals to the combined query answering approaches for EL",
      "author" : [ "G. Stefanoni", "B. Motik", "I. Horrocks" ],
      "venue" : "AAAI, 1177–1183.",
      "citeRegEx" : "Stefanoni et al\\.,? 2013",
      "shortCiteRegEx" : "Stefanoni et al\\.",
      "year" : 2013
    }, {
      "title" : "Modular Ontologies: Concepts, Theories and Techniques for Knowledge Modularization, volume",
      "author" : [ "H. Stuckenschmidt", "C. Parent", "Spaccapietra", "eds" ],
      "venue" : null,
      "citeRegEx" : "Stuckenschmidt et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Stuckenschmidt et al\\.",
      "year" : 2009
    }, {
      "title" : "A modularization-based approach to finding all justifications for OWL DL entailments",
      "author" : [ "B. Suntisrivaraporn", "G. Qi", "Q. Ji", "P. Haase" ],
      "venue" : "ASWC, 1–15.",
      "citeRegEx" : "Suntisrivaraporn et al\\.,? 2008",
      "shortCiteRegEx" : "Suntisrivaraporn et al\\.",
      "year" : 2008
    }, {
      "title" : "Module extraction and incremental classification: A pragmatic approach for ontologies",
      "author" : [ "B. Suntisrivaraporn" ],
      "venue" : "ESWC, 230–244.",
      "citeRegEx" : "Suntisrivaraporn,? 2008",
      "shortCiteRegEx" : "Suntisrivaraporn",
      "year" : 2008
    }, {
      "title" : "Chainsaw: A metareasoner for large ontologies",
      "author" : [ "D. Tsarkov", "I. Palmisano" ],
      "venue" : "ORE.",
      "citeRegEx" : "Tsarkov and Palmisano,? 2012",
      "shortCiteRegEx" : "Tsarkov and Palmisano",
      "year" : 2012
    }, {
      "title" : "Pay-as-you-go OWL query answering using a triple store",
      "author" : [ "Y. Zhou", "Y. Nenov", "B. Cuenca Grau", "I. Horrocks" ],
      "venue" : "AAAI, 1142–1148.",
      "citeRegEx" : "Zhou et al\\.,? 2014",
      "shortCiteRegEx" : "Zhou et al\\.",
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 21,
      "context" : "Module extraction has received a great deal of attention in recent years (Stuckenschmidt, Parent, and Spaccapietra 2009; Cuenca Grau et al. 2008; Seidenberg and Rector 2006; Kontchakov, Wolter, and Zakharyaschev 2010; Gatens, Konev, and Wolter 2014; Del Vescovo et al. 2011; Nortje, Britz, and Meyer 2013), and modules have found a wide range of applications, including ontology reuse (Cuenca Grau et al.",
      "startOffset" : 73,
      "endOffset" : 305
    }, {
      "referenceID" : 9,
      "context" : "2011; Nortje, Britz, and Meyer 2013), and modules have found a wide range of applications, including ontology reuse (Cuenca Grau et al. 2008; Jiménez-Ruiz et al. 2008), matching (Jiménez-Ruiz and Cuenca Grau 2011), debugging (Suntisrivaraporn et al.",
      "startOffset" : 116,
      "endOffset" : 167
    }, {
      "referenceID" : 24,
      "context" : "2008), matching (Jiménez-Ruiz and Cuenca Grau 2011), debugging (Suntisrivaraporn et al. 2008; Ludwig 2014) and classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al.",
      "startOffset" : 63,
      "endOffset" : 106
    }, {
      "referenceID" : 15,
      "context" : "2008), matching (Jiménez-Ruiz and Cuenca Grau 2011), debugging (Suntisrivaraporn et al. 2008; Ludwig 2014) and classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al.",
      "startOffset" : 63,
      "endOffset" : 106
    }, {
      "referenceID" : 26,
      "context" : "2008; Ludwig 2014) and classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al. 2010).",
      "startOffset" : 38,
      "endOffset" : 137
    }, {
      "referenceID" : 11,
      "context" : "Σ (Konev et al. 2013).",
      "startOffset" : 2,
      "endOffset" : 21
    }, {
      "referenceID" : 16,
      "context" : ", the problem is already EXPTIME-hard for EL if we consider concept inclusions as the query language (Lutz and Wolter 2010).",
      "startOffset" : 101,
      "endOffset" : 123
    }, {
      "referenceID" : 11,
      "context" : "Practical algorithms that ensure minimality of the extracted modules are known only for acyclic ELI (Konev et al. 2013) and DLLite (Kontchakov, Wolter, and Zakharyaschev 2010).",
      "startOffset" : 100,
      "endOffset" : 119
    }, {
      "referenceID" : 25,
      "context" : "The connection between module extraction and datalog was first observed in (Suntisrivaraporn 2008), where it was shown that locality ⊥-module extraction for EL ontologies could be reduced to propositional datalog reasoning.",
      "startOffset" : 75,
      "endOffset" : 98
    }, {
      "referenceID" : 18,
      "context" : "We have implemented our approach using the RDFox datalog engine (Motik et al. 2014).",
      "startOffset" : 64,
      "endOffset" : 83
    }, {
      "referenceID" : 12,
      "context" : "Our approach builds on recent techniques that exploit datalog engines for ontology reasoning (Kontchakov et al. 2011; Stefanoni, Motik, and Horrocks 2013; Zhou et al. 2014).",
      "startOffset" : 93,
      "endOffset" : 172
    }, {
      "referenceID" : 27,
      "context" : "Our approach builds on recent techniques that exploit datalog engines for ontology reasoning (Kontchakov et al. 2011; Stefanoni, Motik, and Horrocks 2013; Zhou et al. 2014).",
      "startOffset" : 93,
      "endOffset" : 172
    }, {
      "referenceID" : 17,
      "context" : "We achieve this by choosing A0 to be the critical ABox for Σ, which consists of all facts that can be constructed using Σ and a single fresh constant (Marnette 2009).",
      "startOffset" : 150,
      "endOffset" : 165
    }, {
      "referenceID" : 26,
      "context" : "Module extraction has been exploited for optimising ontology classification (Armas Romero, Cuenca Grau, and Horrocks 2012; Tsarkov and Palmisano 2012; Cuenca Grau et al. 2010).",
      "startOffset" : 76,
      "endOffset" : 175
    }, {
      "referenceID" : 10,
      "context" : "Another common application of modules is to optimise the computation of justifications: minimal subsets of a TBox that are sufficient to entail a given formula (Kalyanpur et al. 2007; Suntisrivaraporn et al. 2008).",
      "startOffset" : 160,
      "endOffset" : 213
    }, {
      "referenceID" : 24,
      "context" : "Another common application of modules is to optimise the computation of justifications: minimal subsets of a TBox that are sufficient to entail a given formula (Kalyanpur et al. 2007; Suntisrivaraporn et al. 2008).",
      "startOffset" : 160,
      "endOffset" : 213
    }, {
      "referenceID" : 4,
      "context" : "Checking whether a datalog program P and an ABox A entail a fact is feasible in O(|P| · n), with n the number of constants in P∪A and v the maximum number of variables in a rule from P (Dantsin et al. 2001).",
      "startOffset" : 185,
      "endOffset" : 206
    }, {
      "referenceID" : 27,
      "context" : "As shown in (Zhou et al. 2014), computing the support of a fact in a datalog program is no harder than fact entailment, and thus module extraction in our approach is feasible in O(|T |·n), and thus tractable for ontology languages where rules have a bounded number of variables (as is the case for most DLs).",
      "startOffset" : 12,
      "endOffset" : 30
    }, {
      "referenceID" : 18,
      "context" : "We have implemented a prototype system for module extraction that uses RDFox for datalog materialisation (Motik et al. 2014).",
      "startOffset" : 105,
      "endOffset" : 124
    }, {
      "referenceID" : 27,
      "context" : "Additionally, the ontology reasoner PAGOdA (Zhou et al. 2014) provides functionality for computing the support of an entailed fact in datalog, which we have adapted for computing modules.",
      "startOffset" : 43,
      "endOffset" : 61
    } ],
    "year" : 2014,
    "abstractText" : "Module extraction—the task of computing a (preferably small) fragment M of an ontology T that preserves entailments over a signature Σ—has found many applications in recent years. Extracting modules of minimal size is, however, computationally hard, and often algorithmically infeasible. Thus, practical techniques are based on approximations, where M provably captures the relevant entailments, but is not guaranteed to be minimal. Existing approximations, however, ensure that M preserves all second-order entailments of T w.r.t. Σ, which is stronger than is required in many applications, and may lead to large modules in practice. In this paper we propose a novel approach in which module extraction is reduced to a reasoning problem in datalog. Our approach not only generalises existing approximations in an elegant way, but it can also be tailored to preserve only specific kinds of entailments, which allows us to extract significantly smaller modules. An evaluation on widely-used ontologies has shown very encouraging results.",
    "creator" : "TeX"
  }
}