{
  "name" : "1606.03894.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Probabilistic-Based Model for Binary CSP",
    "authors" : [ "Amine Balafrej", "Xavier Lorca", "Charlotte Truchet" ],
    "emails" : [ "Amine.Balafrej@mines-nantes.fr", "Xavier.Lorca@mines-nantes.fr", "Charlotte.Truchet@univ-nantes.fr" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The core of constraint programming, i.e. its operational nature, depends on the propagation-research mechanism: the propagation part tries to infer new information from the current states of variables, while the search part, most of the time, consists of a depth-first exploration of the search space. Propagation and search must generally be intricated because of the NP-completeness of the CSPs. Thus, finding a fair balance between efficiency, in terms of calculation time, and effective performance in terms of filtering, has always been a major issue in the constraint programming community.\nThis paper goes one step further by reporting a probabilistic analysis of the constraint network associated with each constraint satisfaction problem (CSP). This leads to a probabilistic-based model for binary CSP that allows us to better understand both the macro-structure (i.e., interactions between variables through the constraints) and the micro-structure as defined in [1] (i.e., interactions between compatible values) of a binary CSP. The contribution of this paper consists on a theoretical analysis of the constraint networks from a probabilistic point of view:\n1. it is shown how to compute in a predictive way the probability for each value of a domain to be arc-inconsistent, under the hypothesis that a domain modification occurs in the CSP; 2. next, it is demonstrated how to aggregate this information for the whole domain and for the whole constraint network; 3. then, these results are approximated by lower bounds; 4. finally, a polytime algorithm is proposed to compute these probabilistic informa-\ntions.\nar X\niv :1\n60 6.\n03 89\n4v 1\n[ cs\n.A I]\n1 3\nJu n\n20 16"
    }, {
      "heading" : "2 Background material and notations",
      "text" : "We consider the classical definition of binary constraint networks. A binary constraint network N is a triplet < X ,D, C >, where X is a set of n variables, D the set of their finite domains, and C the binary constraints, which are assumed to be unique without loss of generality. We write: Cij the constraint between Xi and Xj , C(Xi) the set of constraints involving Xi, and Γ (Xi) = {Xj |∃Cij ∈ C}; Sij the set of solutions of Cij alone; Given a value w ∈ Di, Swij = {(w, vj)|(w, vj) ∈ Sij} the supports of w; S the set of solutions of the network, that is, the values in D1 × ... × Dn satisfying all the constraints; πi the i-th projection of Nn. Constraint propagation aims at detecting values in the domains that cannot satisfy at least one constraint. Propagation is based on the consistency property, for which there are several, more or less powerful, definitions.\nDefinition 1 (Arc-consistency or AC). A value vi ∈ Di is AC for Cij if and only if ∃vj ∈ Dj , s.t. vj ∈ πj(Sviij ). A domain Di is AC on Cij if and only if Di 6= ∅ and ∀vi ∈ Di, vi is AC onCij . A domainDi is AC if and only if it is AC on anyCij ∈ C(Xi). A constraint network N =< X ,D, C > is AC if and only if any Di ∈ D is AC.\nConsequently, a value w ∈ Di is arc-inconsistent on a constraint Cij if and only if πj(S w ij) = ∅. Such a value is written w̆."
    }, {
      "heading" : "3 A probabilistic-based model for CSP",
      "text" : "Constraint networks are difficult to analyze as a whole. Solving methods often focus on the state of one variable inside the network, which is called the microstructure. In addition, solving methods use criteria based on statistical information based on the past states of variable/constraint. However, such a point of view looses much information, since no information on the future state is considered and the global structure of the network is ignored. This section introduce an original probabilistic model for binary CSP that allows us to define criteria based on the future state of variables considering both the macrostructure and the microstructure of the constraint network.\nAssuming that a domain will be modified, we want to know which values will become more likely to be arc-inconsistent. We first introduce a probabilistic-based model of the network, which allows us to properly define the domain modifications as probabilistic events. Then, we give a calculation of the probability for a value to be arcinconsistent after a domain modification (here, removing a fixed number of values), considering the whole constraint network. Let N =< X ,D, C > a constraint network, we build a probabilized network Ñ , fromN by associating to each domainDi a random variable D̃i such that D̃i ⊂ Di. All these random variables are drawn independently, i.e., they are randomly and uniformly chosen as a fixed length subdomain of Di. In this network, we are interested in particular events: the domain modifications. We will consider what happens when a domain Di is reduced. Knowing that k values have been removed inDi, we randomize which k values have been removed fromDi. The number of such values is denoted rk(Di)."
    }, {
      "heading" : "3.1 Probabilistic model for arc-inconsistency",
      "text" : "First, we detail how to compute the probability for a value w of a given variable Xi to be arc-inconsistent on a constraint Cij given an event rk(Dj). Second, we go one step further by evaluating the expectation of the number of arc-inconsistent values, in a domain Di of a variable Xi, according to a potential event, rkj (Dj), occurring on the domain of a variable Xj in the neighborhood of Xi.\nConsider the example provided by Figure 1, it first depicts the supports Swij of a value w ∈ Di on a constraint Cij (Figure 1(a)). An interesting question to predict the importance of the value w could be its capacity to be arc-inconsistent. Then, a basic information has to be formalized: if it is assumed that at most 3 values could be removed from Dj (Figure 1(b)) then, there is no chances for value w to be arc-inconsistent on Cij (none of the possible combinations of k < 4 values in Dj could remove all the supports of w); Otherwise, if it is assumed that at least 4 values could be removed from Dj (Figure 1(c)) then, there is a chance for a value w to be arc-inconsistent on Cij and we want to evaluate this chance. From a probabilistic point of view, this information can be translated into the probability for w of being arc-inconsistent on Cij according to value(s) removal(s) in Dj . In the following the projection πj(Swij) will be denoted by πwj .\nProposition 1. For a value w ∈ Di, the probability of being arc-inconsistent on a constraint Cij in the probabilized constraint network Ñ , knowing that k values have been removed from Dj , is:\nPcij (w̆ | rk(Dj)) =  1, if |πwj | = 0 (a) |πwj |∏ `=1 k−|πwj |+` |Dj |−|πwj |+` , if k ≥ |πwj | > 0 (b)\n0, if |πwj | > k ≥ 0 (c)\nProof. We first recall that by definition we have |Dj | ≥ |πwj | and |Dj | ≥ k ≥ 0. For the cases (a) and (c) the proof is direct from Definition 1 (precisely arc-inconsistency for (a)). In order to build the proof for the case (b), we introduce, for a value w ∈ Di, the concept of k-Support which denotes any subset of k values of a given domain Dj containing all the support values for w on the constraint Cij . To choose a k-Support, you only need to choose (k − |πwj |) values outside the support values for w, hence the number of k-supports is:\n#k-Supports = (|Dj | − |πwj |\nk − |πwj | ) Then, for a value w ∈ Di, the probability of being arc-inconsistent on a constraint Cij knowing that k values have been removed from the domain Dj is the probability of removing one of the k-supports of w on Cij , thus\nPcij (w̆ | rk(Dj)) =\n(|Dj |−|πwj | k−|πwj | ) (|Dj | k\n) By developing the binomials, the fraction ( |Dj |−|π w j | k−|πw j | )\n(|Dj |k ) leads to k!(k−|πwj |)!×\n(|Dj |−|πwj |)! |Dj |!\nand consequently to |πwj |∏ `=1 k−|πwj |+` |Dj |−|πwj |+`\nut\nAn interesting information for the whole constraint network is the probability, for a value w ∈ Di, to be arc-inconsistent for any constraint involving Di. Figure 2 depicts an example of variable domain Di involved in three constraints with an event rkj (Dj) in the domain of each variable Xj ∈ Γ (Xi). For each event rkj (Dj), a value w ∈ Di\nhas a probability Pcij (w̆ | rkj (Dj)) of being arc-inconsistent on the constraint Cij . All these probabilities are aggregated and Proposition 2 provides the probability of being arc-inconsistent for a value w ∈ Di beyond the constraints themselves.\nProposition 2. For a value w ∈ Di, the probability of being arc-inconsistent in the probabilized constraint network Ñ , knowing that kj values have been removed from each Dj ∈ Γ (Xi), denoted PN (w̆ | ∀Xj ∈ Γ (Xi), rkj (Dj)), is equal to\n1− ( ∏\nXj∈Γ (Xi)\n(1− Pcij (w̆ | rkj (Dj)))) (1)\nProof. For a value w ∈ Di, the probability of being arc-consistent on a constraint Cij , knowing the event rk(Dj), is 1−Pcij (w̆ | rkj (Dj)). Then, the probability of being arc consistent knowing that kj values have been removed from each Dj ∈ Γ (Xi), is equal to: ∏\nXj∈Γ (Xi)\n(1− Pcij (w̆ | rkj (Dj)))\nAnd so, the probability of being arc-inconsistent is equal to\n1− ( ∏\nXj∈Γ (Xi)\n(1− Pcij (w̆ | rkj (Dj))))\nut\nOnce we are able to express the probability of being arc-inconsistent for a value w ∈ Di, we want to evaluate the number of arc-inconsistent values we expect found in Di. Propositions 3 express this expectation for a single domain and Propositions 4 generalises this result for the whole constraint network.\nProposition 3. The expected number of arc-inconsistent values in a domain Di knowing that kj values have been removed from each Dj ∈ Γ (Xi), denoted E(D̃i), is\nE(D̃i) = ∑ wi∈Di PN (w̆i ∈ Di | ∀Xj ∈ Γ (Xi), rkj (Dj)) (2)\nProof. For each value w ∈ Di, we define the random variable Yw s.t.\nYw = 1 if w is inconsistent after reduction of (Dj) for a Xj ∈ Γ (Xi) 0 otherwise\nNote that Yw can take value 1 with probability PN (w̆ | ∀Xj ∈ Γ (Xi), rkj (Dj)) and value 0 with probability 1− PN (w̆ | ∀Xj ∈ Γ (Xi), rkj (Dj)). Thus,\nE(Yw) = 1× PN (w̆ | .) + 0× (1− PN (w̆ | .)) = PN (w̆ | ∀Xj ∈ Γ (Xi), rkj (Dj))\nThe number of values in Di that are arc-inconsistent knowing that kj values have been removed from each Dj is ∑ w∈Di Yw:\nE(D̃i) = E( ∑ w∈Di Yw) = ∑ w∈Di E(Yw)\nConsequently:\nE(D̃i) = ∑ wi∈Di PN (w̆i ∈ Di | ∀Xj ∈ Γ (Xi), rkj (Dj)) (3)\nut\nProposition 4. The expectation of the number of arc-inconsistent values for the whole network, denoted E(Ñ), is:\nE(Ñ) = ∑ Di∈D ∑ wi∈Di PN (w̆i ∈ Di | ∀Xj ∈ Γ (Xi), rkj (Dj)) (4)\nProof. Similar to those of Proposition 3. ut\nNow we have a complete probabilistic-based model that allows us, given an event, to compute the probability of a value of being arc-inconsistent for a single constraint (Prop. 1) in addition to three interesting probabilistic indicator that are:\n– The probability for each value of being arc-inconsistent (Prop. 2). – The expected number of arc-inconsistent values for a given domain (Prop. 3). – The expected number of arc-inconsistent values for the whole constraint network\n(Prop. 4).\nThe following corollaries provide bounds for each of these three probabilistic indicators.\nCorollary 1 For w ∈ Di, the probability of being arc-inconsistent in Ñ , knowing that kj values have been removed from each domain Dj of each variable Xj ∈ Γ (Xi), is greater or equal than the maximum among the probabilities on each constraint:\nPN (w̆ | ∀Xj ∈ Γ (Xi), rkj (Dj)) ≥ max Xj∈Γ (Xi) {Pcij (w̆ | rkj (Dj))} (5)\nProof. Knowing that,\n∀Xj ∈ Γ (Xi), 0 ≤ Pcij (w̆ | rkj (Dj)) ≤ 1\nwe have ∏ Xj∈Γ (Xi) (1− Pcij (. | .)) ≤ 1− Pcij (. | .)\nConsidering the maximum value of Pcij (w̆ | rkj (Dj)):∏ Xj∈Γ (Xi) (1− Pcij (. | .)) ≤ 1− max Xj∈Γ (Xi) {Pcij (. | .)}\nPN (w̆ | ∀Xj ∈ Γ (Xi), rkj (Dj)) ≥ max Xj∈Γ (Xi) {Pcij (. | .)}\nut\nWe now can bound the expectation of the number of arc-inconsistent values in the domains, after a domain reduction.\nCorollary 2 For a domainDi associated with a variableXi, the expected valueE(D̃i) of arc-inconsistent values in Di knowing that kj values have been removed from the domain of the variables Xj ∈ Γ (Xi) is bounded by:\n|Di| ≥ E(D̃i) ≥ ∑ wi max Xj∈Γ (Xi) {Pcij (w̆i | rkj (Dj))} (6)\nProof. Straightforward from Prop. 3 and Cor. 1. ut\nCorollary 3 The expected value E(Ñ) of arc-inconsistent values in the constraint network N is greater or equal than:\nE(Ñ) ≥ ∑ Xi∈X ∑ wi∈Di max Xj∈Γ (Xi) {Pcij (w̆i ∈ Di | rkj (Dj))} (7)\nProof. Conclusion from Proposition 4 and Corollary 1 is straightforward. ut\nTo sum up, we now have a formula providing a bound for the number of values that are expected to be removed in the constraint network, under the hypothesis of a domain modification."
    }, {
      "heading" : "3.2 Propagation of the probabilistic information",
      "text" : "Given a constraint network N , Algorithm 1 details how to compute the probability for each value of each domain to be arc-inconsistent (Corollary 1), and the lower bound of the expected number of arc-inconsistent values for all the domains (Corollary2). Algorithm 1 is an adaptation of a coarse grained AC algorithm, AC3 [2].\nAt the initialization step, from Lines 7 to 16, Algorithm 1 is initialized. Two elements have to be noticed: First, Line 11 populates the set of variables to analyze (i.e., each variable for which it is assumed its domain has been modified), according to the table R[]; Second, Lines 9 and 14 respectively initialized the expected value of arcinconsistent values in Di and, the default probability of being arc-inconsistent for each pair variable/value. Next, the computation of the expected results is ensured as follows. Line 21 calls the function Pcij that computes the probability for a given value vj ∈ Dj to be arc-inconsistent for a constraint Cij according to the assumption that R[i] values\nAlgorithm 1 ProbAC(X[], D[], C[], R[], {S1[][], S2[][] . . . Sn[][]}) Require: 1: X[], D[], C[]: variables, domains and constraints associated with the CSP 2: R[]: table of integers - R[i] represents the number of values that we assume to be removed\n(hypothesis) from the domain D[i] of X[i] 3: Si[][]: matrix of integers associated to Xi ∈ X - Si[w][j] represents the number of supports\n(|πj(Swij)|) of w ∈ Di on the constraint Cij Ensure: 4: P[][]: P[i][j] represents a lower bound of the probability for the value j in the domain of X[i]\nto be arc-inconsistent . Corollary 1 5: E[]: E[i] represents a lower bound of the expected value of arc-inconsistent values in D[i] of\nX[i] . Corollary 2 6: EN represents a lower bound of the expected value of arc-inconsistent values in the constraint\nnetwork . Corollary 3\n7: Set of variables S← ∅ ; EN← 0 8: for all X[i] ∈ X[] do 9: E[i]← 0\n10: if R[i] > 0 then 11: S.add(X[i]) 12: end if 13: for all vi ∈ D[i] do 14: P[i][vi]← 0 15: end for 16: end for 17: while S 6= ∅ do 18: Variable xi ← S.remove() 19: for all xj ∈ Γ (xi) do 20: for all vj ∈ D[j] do 21: double tmp← Pcij (v̆j | R[i]) . Proposition 1 22: if tmp > P[j][vj ] then 23: EN← EN− P[j][vj ] + tmp . Corollary 3 24: E[j]← E[j]− P[j][vj ] + tmp . Corollary 2 25: P[j][vj ]← tmp . Corollary 1 26: end if 27: end for 28: if bE[j]c > R[j] then 29: R[j]← bE[j]c 30: S.add(X[j]) 31: end if 32: end for 33: end while\nare assumed to be removed from Di (Proposition 1). Lines 22 and 25 allow to aggregate the previous information by maintaining the maximum value in the neighborhood of the variable xj according to formula provided by Corollary 1. Next, Lines 22 and 24 compute a lower bound on the expected value of arc-inconsistent values in the whole domain Dj according to formula provided by Corollary 2. Next, Lines 22 and 23 ag-\ngregate the information of Line 22 to provide a lower bound of the total number of expected arc-inconsistent values for the whole network (Corollary 3). Finally, Lines 28 to 30 manages the propagation of the information, by observing the evolution of the expected value of arc-inconsistent values in the domain Dj .\nThe termination of Algorithm 1 is demonstrated from lemma 1 and line 17: it is ensured that S becomes empty and no variable enters S.\nLemma 1. A variable Xi enters the set S at most |Di| times.\nProof. Lines 28-30 of Algorithm 1 ensure that: a variableXi enters the set S if and only if the number of values R[i] assumed to be removed fromDi increases; for each variable Xi, the number of values R[i] assumed to be removed is monotonously increasing; for each variable Xi, |Di| is an upper bound for the number of values R[i] assumed to be removed. The last bullet has to be detailed. The number of values R[i] assumed to be removed from Di is computed as the integer portion bE[i]c of the expected value E[i]. That is, the expected value E[i] is an upper bound for R[i]. In addition, |Di| is an upper bound for E[i] (corollary 2). Thus, |Di| is an upper bound for R[i]. ut\nThe initialization step (lines 7 to 16), has a time complexity O(nd). Next, at each run of the main loop algorithm (lines 17 to 33), a variable Xi is removed from the set S then the Proposition 1 is evaluated for each Cij and each vj ∈ Dj .\nProposition 5. Algorithm 1 has a worst-case time complexity O(nmd3), where m = max i=1..n {|Γ (Xi)|}.\nProof. Each time a variable Xi enters S, the probability Pcij (v̆j | R[i]) is evaluated for each value vj in the domain Dj of each variable Xj ∈ Γ (Xi). In addition, a variable Xi enters S each time the lower bound R[i] of the expected value E(X̃i) increases. In the worst case, the lower bound R[i] increases each time by at most one. So, a variable Xi enters S at most d times. Therefore, For each of the n variables Xi in the constraint network, the probability Pcij (v̆j | R[i]) is evaluated at most mid2 times, where mi = |Γ (Xi)|. Furthermore, evaluate the probability has a worst case time complexity of O(d). Thus, algorithm 1 has a worst case time complexity of O(nmd3), where m = max\ni=1..n {mi}. ut"
    }, {
      "heading" : "4 Conclusion",
      "text" : "This work has presented a probabilistic-based model for classical binary CSPs. This is an original point of view which provides a fine grained analysis of the constraint network that allows us to better understand both the macro-structure (i.e., interactions between variables through the constraints) and the micro-structure (i.e., interactions between compatible values) of a binary CSP."
    } ],
    "references" : [ {
      "title" : "Decomposition of domains based on the micro-structure of finite constraintsatisfaction problems",
      "author" : [ "P. Jégou" ],
      "venue" : "Proceedings of the 11th National Conference on Artificial Intelligence. Washington, DC, USA, July 11-15, 1993. pp. 731–736",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Consistency in networks of relations",
      "author" : [ "A.K. Mackworth" ],
      "venue" : "Artificial Intelligence 8(1), 99 – 118",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1977
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : ", interactions between variables through the constraints) and the micro-structure as defined in [1] (i.",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 1,
      "context" : "Algorithm 1 is an adaptation of a coarse grained AC algorithm, AC3 [2].",
      "startOffset" : 67,
      "endOffset" : 70
    } ],
    "year" : 2016,
    "abstractText" : "This work introduces a probabilistic-based model for binary CSP that provides a fine grained analysis of its internal structure. Assuming that a domain modification could occur in the CSP, it shows how to express, in a predictive way, the probability that a domain value becomes inconsistent, then it express the expectation of the number of arc-inconsistent values in each domain of the constraint network. Thus, it express the expectation of the number of arc-inconsistent values for the whole constraint network. Next, it provides bounds for each of these three probabilistic indicators. Finally, a polytime algorithm, which propagates the probabilistic information, is presented.",
    "creator" : "LaTeX with hyperref package"
  }
}