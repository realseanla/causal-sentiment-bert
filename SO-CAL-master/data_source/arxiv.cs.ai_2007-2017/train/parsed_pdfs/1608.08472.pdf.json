{
  "name" : "1608.08472.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "ALLSAT compressed with wildcards. Part 1: Converting CNF’s to orthogonal DNF’s",
    "authors" : [ "Marcel Wild" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "solve the ALLSAT problem for arbitrary Boolean functions in CNF format. Specifically, it converts\na CNF into an orthogonal DNF, i.e. into an exclusive sum of products. Our method is enhanced\nby two ingredients: The use of a good SAT-solver and wildcards beyond the common don’t-care\nsymbol."
    }, {
      "heading" : "1 Introduction",
      "text" : "In his 1979 landmark paper [V] Leslie Valiant shifted attention from the SAT problem to the #SAT problem, i.e. to the task of calculating the exact cardinality of the model set Mod(ϕ) ⊆ {0, 1}w of a given Boolean function ϕ = ϕ(x1, · · · , xw). He showed that many #SAT problems are so-called #P -hard which implies they are at least as difficult as NP-hard problems. Even problems for which SAT is trivial can be #P-hard, such as #DNFSAT. Solving #SAT e.g. has applications for approximate reasoning as pointed out in [R].\nThe ALLSAT problem for ϕ, our article’s main topic, extends #SAT in so far that not just the number |Mod(ϕ)| is required but the models themselves. In the literature often the underlying Boolean function (or formula) ϕ is not pointed out explicitely. In fact one may be interested in a subset SpMod(ϕ) of “special” models which would be hard or impossible to capture by a Boolean formula. In the last fifty years a variety of such “enumeration problems” have been considered [Was]. The motivations for doing so (e.g. optimization beyond the scope of linear programming) are nicely laid out e.g. in Foreword 2 of [M]. We won’t dwell on that in the sequel, except briefly in 8.4. Rather the present article sticks to theory (algorithmics), and to a strictly Boolean function framework.\nSince |Mod(ϕ)| can be exponential in the length |ϕ| := w, one commonly regards the ALLSAT problem as solvable when the enumeration of Mod(ϕ) can be achieved in output-polynomial time. It turns out that many classes C of Boolean functions whose #SAT problem is #P-hard nevertheless have a solvable ALLSAT-problem, e.g. the class of all Boolean DNF’s. A sufficient condition for a solvable ALLSAT problem is formulated in the somewhat hidden Fact 7 of [V]. Our Corollary 2 with its hereditary classes C resembles Fact 7. Roughly speaking Corollary 2 states that tackling the ALLSAT problem for a hereditary class C scales proportional to the best SAT-solver available for C. In particular, a polynomial-time SAT-solver triggers a solvable ALLSAT problem for C. Unfortunately, from a practical point of view a one-by-one enumeration\nar X\niv :1\n60 8.\n08 47\n2v 1\n[ cs\n.A I]\n3 0\nA ug\n2 01\nof Mod(ϕ), output-polynomial or not, gets tiresome when |Mod(ϕ)| goes into the trillions. How we mend this state of affairs is surveyed in the remainder of the introduction. The detailed section break-up follows in 1.2.\n1.1 Enumerating a set of objects usually means that they are listed one-by-one. Thus, if the Boolean function ϕ0 : {0, 1}w → {0, 1} has w = 9 and is defined by ϕ0(x1, · · · , x9) = x2∨x6 then enumerating the model set Mod(ϕ0) in this strict sense forces us to list 384 length 9 bitstrings. Since it is more economic to write\n(1) Mod(ϕ0) = (2,1, 2, 2, 2,2, 2, 2, 2) ] (2,0, 2, 2, 2,0, 2, 2, 2),\nwe henceforth mean by an enumeration of Mod(ϕ) a partition of Mod(ϕ) into such disjoint 012-rows. Here comes some handy notation right away: zeros(r), ones(r), and twos(r) are the sets of positions i ∈ [w] := {1, 2, · · · , w} where the 0’s, 1’s, and the don’t-care symbols 2 occur. Thus zeros(r) = {2, 6} for the second 012-row r in (1). Intervals in the Boolean lattice {0, 1}w and 012-rows1 are the same thing. For instance the interval of all eight bitstrings u with (0, 1, 0, 0, 0) ≤ u ≤ (1, 1, 0, 1, 1) equals the 012-row (2, 1, 0, 2, 2). Bitstrings can either be viewed as singleton intervals or as 012-rows r with twos(r) = ∅.\nAs mentioned above, an enumeration of Mod(ϕ) (in the one-by-one sense) is commonly called the ALLSAT problem; we extend that concept by allowing disjoint 012-rows as well. It is evident that this wider concept of enumerating Mod(ϕ) amounts to find an orthogonal DNF of ϕ. At first we treat the ALLSAT problem in an abstract setting which e.g. comprises the usual variable-wise branching. The main thrust of the article however occurs in the second half which is dedicated to clause-wise branching, which often brings about better compression than variable-wise branching.\n1.2 Theorem 1 in Section 2 states that when ϕ is a Boolean function with a “row-splitting mechanism” then Mod(ϕ) can be enumerated in a natural way. Corollary 2 shows that (a) common variable-wise branching fits the framework of Theorem 1, and (b) that the existence of a good row-splitting mechanism for a class C of functions requires a good SAT-solver for C. We then go on to replace Mod(ϕ) by the set Mod(ϕ, k) of all cardinality k models. This leads to the enumeration of all k-hitting sets of a hypergraph, and to all k-models of a DNF. Restricted to Section 2 the concept of a row-splitting mechanism may seem a bit far-fetched but it will be appreciated in Section 5 as a common hat for two or (prospectively) more quite distinct ways of branching.\nThe brief Sections 3 and 4 can be viewed as intermezzos preparing for Section 7. Section 3 presents some tests for Boolean functions in CNF format. And Section 4 is dedicated to Binary Decision Diagrams (BDD’s), which serve two purposes. On the one hand they illustrate the inner workings of Theorem 1, on the other hand we prepare the reappearance of BDD’s later on.\nSection 5 starts by recalling a well known propositional tautology. Its 2-dimensional visualization looks like the Flag of Papua and accompanies us throughout the remainder of the article. The Flag of Papua underlies the clause-wise branching introduced in 5.1. We call our method the\n1In previous publications the clumsier name, “{0, 1, 2}-valued rows” was used. While intervals or subcubes or terms occur frequently in the Boolean logic literature, our equivalent concept of a 012-row goes the extra (half) mile to make things more visual. That will particularly benefit us in Sections 5 and 6.\nclause-wise ALLSAT 012-algorithm. Fed with a CNF ϕ it returns Mod(ϕ) as a disjoint union of 012-rows.\nIn Section 6 we add the e-wildcard which is surprisingly powerful notwithstanding its innocent definition: e · · · e means “at least one 1 here”. Correspondingly the clause-wise ALLSAT ealgorithm, when fed with a CNF ϕ, returns Mod(ϕ) as a disjoint union of 012e-rows. While 012-rows match familiar exclusive sums of products (ESOP), their enhancement to 012e-rows can be viewed as an “exclusive sum of fancy terms” (ESOFT). Some immediate relations among ESOP, ESOFT, CNF, DNNF (see [D]) and BDD are discussed in 6.1, 6.2. More technical details concerning ESOFT follow in 6.3 to 6.5.\nSection 7 features numerical experiments carried out with Mathematica implementations of several ALLSAT algorithms (be it variable-wise or clause-wise, be it 012-level or 012e-level). We also add BDD’s to the picture in the form of Mathematica’s hardwired command SatisfiabilityCount, and consider weighted Boolean functions.\nSection 8, with the title “History and envisaged future”, mainly focuses on the ALLSAT ealgorithm. As to history, we e.g. acknowledge the rôle of Redelinghuys and Geldenhuys [RG]. As to the future of the ALLSAT e-algorithm, its main “competitor” seems to be binary decision diagrams (BDDs). Specifically we compare ESOFT and BDD with respect to these criteria: Their ability to compress Mod(ϕ) (and also Mod(ϕ, k)), and their ability to settle the equivalence of two Boolean functions. In Subsection 8.4 we briefly review what specific CNF’s have already been tackled by the author with wildcards (e.g. Horn CNF’s), and try to forecast what the future has in store."
    }, {
      "heading" : "2 A comprehensive ALLSAT branching scheme",
      "text" : "Let ϕ : {0, 1}w → {0, 1} be any Boolean function. Call any 012-row r of length w feasible (with respect to ϕ) if r ∩ Mod(ϕ) 6= ∅. In other words, the partial variable assignment defined by zeros(r) and ones(r) extends to a model of ϕ. It will sometimes be useful to look at this condition from a slightly different angle. Namely, each 012-row r matches a unique term T (r) as follows: If say r = (2, 1, 2, 0, 0) then T (r) = x2 ∧ x4 ∧ x5. Conversely each term T matches a 012-row r(T ). The above condition r ∩Mod(ϕ) 6= ∅ thus amounts to say that the Boolean function T (r)∧ϕ is satisfiable. A feasibility test is a subroutine which, when fed with a 012-row r, produces an answer yes or no. The feasibility test is weak if (“no” ⇒ r is infeasible), and it is perfect2 if additionally (“yes” ⇒ r is feasible). It will be convenient to call a 012-row r final if r ⊆ Mod(ϕ).\nThroughout the article we tackle ALLSAT (independent of how ϕ is given) by constructing a search tree rooted at {0, 1}w = (2, 2, · · · , 2) in a preorder depth-first manner, such that all nodes are 012-rows and such that the union of leaves equals Mod(ϕ). Our search tree needs not be binary, thus a branching node (= non-leaf) may have more than two nodes.\n2.1 Specificially, a Boolean function ϕ : {0, 1}w → {0, 1} enjoys a row-splitting mechanism with 2For simplicity we disregard a third option “don’t know”. Consequently a “yes” of a weak feaiblity test must not be trusted. Of course, the better the test, the more likely “yes” is correct.\nrespect to positive integers h = h(ϕ), d = d(ϕ), s = s(ϕ) (the latter ≥ w for convenience) if the following takes place. First, coupled to each 012-row r (always of length w) is an integer deg(r) ∈ [0, h], called the degree of r. We postulate that deg(r) can be calculated in ≤ d time. Second, each feasible 012-row of degree h is final. Third, each feasible 012-row r of degree < h splits (whenever desired) in ≤ s time into τ many disjoint 012-rows (its sons). Here τ ≥ 1 and the sons can uniquely be classified as first (r1), second (r2), . . . , last (rτ ). Furthermore it holds that\n(2a) all sons ri are feasible and of length w;\n(2b) all sons ri have deg(ri) > deg(r);\n(2c) (r1 ] · · · ] rτ ) ∩Mod(ϕ) = r ∩Mod(ϕ).\nTheorem 1: There is an algorithm which for each satisfiable Boolean function ϕ with a row-splitting mechanism enumerates Mod(ϕ), using R many disjoint 012-rows, in time O(Rh(d+ s)).\nProof: Our search tree T has the root (2, 2, · · · , 2) which has degree 0. Its preorder depth-first construction is uniquely determined by the ordering of sons of splitting rows, and by declaring the degree h rows as leaves. More specifically, after each row splitting we update a labelling of the temporary leaves with their degrees, investing ≤ d(ϕ) time per updated labelling. Temporary leaves of degree h by assumption are final and need not be processed further. Due to (2a) the splitting mechanism can be continued on each temporary leaf of degree < h. It further follows from (2c) and induction that the union of all temporary leaves is always disjoint and contains Mod(ϕ). From (2b) follows that eventually all temporary leaves have degree h, i.e. are leaves of T . Because all leaves (having degree h) are contained in Mod(ϕ), the union of all leaves equals Mod(ϕ).\nAs to the cost analysis, since there are |T | − R many nonleaves, and they are bijective to the occured row splittings, the cost of the latter amounts to O((|T | − R)s) = O(|T |s). There is no other hidden cost such as pruning infeasible rows. Because the depth of T is ≤ h we get |T | ≤ Rh. By the above the total cost of calculating degrees is O(Rhd). Furthermore, stacking or outputting a (final) length w bitstring costs O(w). Hence, in view of w ≤ s, the overall cost is O(Rhd) +O(Rhs) +O(Rhw) = O(Rh(d+ s)).\nUnfortunately, all that can be proven about the number R of 012-rows is that R ≤ |Mod(ϕ)| due to the disjointness of rows. However, practise shows (Section 7) that R |Mod(ϕ)| occurs frequently. In our applications of Theorem 1 it will always be that r1]· · ·] rt in (2c) is actually a subset of r. Yet this is not required in the proof of Theorem 1. Subsection 2.2 gives some prerequisites for the first of five Corollaries stated in 2.3.\n2.2 Each set system F ⊆ P[w] invites two kinds of complementation. The global complement Fc := P[w] \\ F , and the member-wise complement Fc := {[w] \\ X : X ∈ F}. Each F equals Mod(ϕ) for a suitable (not unique) Boolean function ϕ : {0, 1}w → {0, 1}. Hence Fc = Mod(ϕc) for ϕc(x1, · · · , xn) := ϕ(x1, · · · , xn); and Fc = Mod(ϕc) for ϕc := ϕ(x1, · · · , xn). For instance, if ϕ = ϕ(x1, x2, x3) = x1∧(x2∨x3) then ϕc = x1 ∧ (x2 ∨ x3) = x1∨(x2∧x3) and ϕc = x1∧(x2∨x3).\nEvidently (ϕc)c = (ϕc)c = ϕ.\nConsider the enumeration Mod(ϕ) = r1]· · ·]rt. Defining ri by ones(ri) := zeros(ri), zeros(ri) := ones(ri), twos(ri) := twos(ri), evidently yields the enumeration Mod(ϕc) = r1 ] · · · ] rt. What about Mod(ϕc)? Getting the cardinality is easy:\n|Mod(ϕc)| = 2w − |Mod(ϕ)| = 2w − |r1| − |r2| − · · · − |rt|,\nyet finding an enumeration of Mod(ϕc) (even just one-by-one) is harder. Of course the naive approach to pick all U ∈ P[w] and check whether or not U ∈ Mod(ϕ), does not yield an outputpolynomial enumeration of Mod(ϕc). The issue will be tackled in Corollary 1 (with the rôles of ϕ and ϕc switched).\n2.3 Let us see how usual variable-wise branching for Boolean functions ϕ : {0, 1}w → {0, 1} (in arbitrary format) fits the bill of Theorem 1. Here h = w and the row-splitting mechanism works as follows. By definition the degree of a 012-row r is deg(r) := min(twos(r)) − 1. For instance r = (0, 1, 1, 0, 1, 2, 1, 0, 2, 1) has deg(r) = 5, and deg((2, 0, 2)) = 0. Thus d(ϕ) = O(w) and feasible 012-rows of degree w (i.e. bitstrings) are indeed final. Suppose r is feasible and q := deg(r) < w. Let ρ0 and ρ1 be the 012-rows arising from r by substituting the 2 at position q + 1 by 0 and 1 respectively. The fact that deg(ρ0) = deg(ρ1) > deg(r) is akin to (2b), and r = ρ0 ] ρ1 is akin to (2c). However, either ρ0 or ρ1 (but not both since r is feasible) may be infeasible, which would clash with (2a). We thus need3 a satisfiability subroutine which decides matters. If say only ρ0 is feasible then (2a) holds with τ = 1 and r1 := ρ0. Obviously r1 ∩Mod(ϕ) = r ∩Mod(ϕ), and so (2b) and (2c) hold as well.\nIf the branching is variable-wise and the definition of deg(r) as above then clearly only 012-rows of type (∗, · · · , ∗, 2, · · · , 2) with ∗ ∈ {0, 1} will ever be subject to row-splitting. Our first scenario to enumerate Mod(ϕ) occurs if an enumeration of Mod(ϕc) happens to be known. As to how this “happens”, if e.g. ϕ is a CNF then a DNF of ϕc is readily obtained using De Morgan’s laws. This DNF then needs to morph into an equivalent “disjoint sum of products”. (This is a well researched problem, see also Section 8.4.2.)\nCorollary 1: Suppose that for the Boolean function ϕ : {0, 1}w → {0, 1} an enumeration of Mod(ϕc) is known which uses t many disjoint 012-rows. Then Mod(ϕ) can be enumerated, using R many disjoint 012-rows, in time O(Rtwh).\nProof: In view of Theorem 1 it suffices to exhibit a row-splitting algorithm for ϕ of complexity s(ϕ) = O(wt) because then O(Rh(d + s)) = O(Rh(w + wt)) = O(Rhwt). Suppose that our given enumeration is Mod(ϕc) = r′1 ] · · · ] r′t. Recall that above we considered a feasible r and a decomposition r = ρ0 ] ρ1 induced by variable-wise branching. The feasiblity of ρ0 (similarly ρ1) is equivalent to ρ0∩Mod(ϕ) 6= ∅, which amounts to ρ0 6⊆ Mod(ϕc), which amounts to |ρ0 ∩ Mod(ϕc)| < |ρ0|. This inequality can be tested because we have |ρ0| = 2γ where γ := |twos(ρ0)|, and\nρ0 ∩Mod(ϕc) = (ρ0 ∩ r′1) ] (ρ0 ∩ r′2) ] · · · ] (ρ0 ∩ r′t). 3Whether the row-splitting mechanism is induced by variable-wise branching or something else, in order to fulfil (2a) one always needs a SAT-solver. More precisely, (2a) is essential for any theoretic cost analysis. In practise it may be affordable or even beneficial (see 7.2.1) to carry along infeasible rows for a while, they being detected at a later stage.\nIf zeros(ρ0)∩ones(r′i) 6= ∅ or ones(ρ0)∩zeros(r′i) 6= ∅ then ρ0∩r′i = ∅. Otherwise ρ0∩r′i can again be written as a 012-row. For instance (0, 1, 2, 2, 1, 2)∩ (2, 1, 2, 0, 2, 2) = (0, 1, 2, 0, 1, 2). It follows that |ρ0∩Mod(ϕc)| can be calculated in O(wt) time. A notable special case of ρ0 being feasible, i.e. satisfying |ρ0 ∩Mod(ϕc)| < |ρ0|, is that |ρ0 ∩Mod(ϕc)| = 0. This amounts to ρ0 ⊆ Mod(ϕ), i.e. to the finality of ρ0.\nAs we shall see in 4.1, Boolean functions ϕ given by a BDD provide another example where a row-splitting mechanism for ϕ is readily obtained.\n2.3.1 In the remainder of 2.3 we switch from individual ϕ’s to classes C of Boolean functions. Albeit things possibly generalize, we demand that each ψ ∈ C is given by a Boolean formula and not by some other gadget. Further we view ψ(x1, x2, x4) := (x1 → x2)∧ x4 as distinct from ψ0(x1, x2, x3, x4) := (x1 → x2)∧x4 because they are of type {0, 1}3 → {0, 1} and {0, 1}4 → {0, 1} respectively. Accordingly we have lengths |ψ| = 3 and |ψ0| = 4. We call a class C of Boolean functions hereditary if for each ϕ ∈ C the substitution4 of variables with 0 or 1 yields again a function from C.\nCorollary 2: Let C be a hereditary class of Boolean functions and suppose the satisfiability of each ψ ∈ C with |ψ| = w can be tested in time ≤ sat(w), where sat is a monotone function. Then for each ϕ ∈ C with |ϕ| = w one can use variable-wise branching to enumerate Mod(ϕ) in O(Rwsat(w)) time as a disjoint union of R many 012-rows.\nProof: In view of Theorem 1 and h = w and d + s = O(w + s) = O(s) it suffices to show that each ϕ ∈ C possesses a row-splitting mechanism with s(ϕ) = O(sat(w)). As seen above, splitting rows r amounts to checking the feasiblity of rows ρ, and this in turn reduces to the satisfiability of ϕ ∧ T (ρ). Since C is hereditary, ψ = ϕ ∧ T (ρ) belongs to C. Because of |ψ| ≤ |ϕ| = w its satisfiability is testable in time sat(w).\nIt is a false impression that only rows r with deg(r) = w (i.e. bitstrings) can be final; see the end of the proof of Corollary 1. Another scenario admitting “fat” final 012-rows occurs when the ϕ’s are CNF’s (Section 3). Generally speaking, a finality test is a subroutine which, when fed with a 012-row r, produces an answer yes or no. the finality test is weak if (“no” ⇒ r is not final), and it is perfect if additionally (“yes”⇒ r is final). Whatever the “normal” procedure for computing degrees of 012-rows, one can augment it by putting deg(r) := h whenever r is final. Hence finality testing merely inflates the parameter d(ϕ) in Theorem 1.\n2.3.2 Let us slightly alter the definition of a row-splitting mechanism by replacing (2c) with\n(2c′) (r1 ] · · · ] rτ ) ∩ SpMod(ϕ) = r ∩ SpMod(ϕ)\nwhere SpMod(ϕ) ⊆ Mod(ϕ) is some well defined subset of “special” models. From the proof of Theorem 1 it is clear that Theorem 1 still holds when Mod(ϕ) is replaced by SpMod(ϕ). In practise of course the row-splitting mechanism may get complicated. For instance, for any given hypergraph H ⊆ {0, 1}w it is easy to write down a Boolean formula ϕ such the Mod(ϕ)\n4For instance, take ϕ(x1, x2, x3, x4, x5) = (x2 ∨ x4) ∧ (x1 ∨ x4 ∨ x5) ∧ x3. Then (say) the substitution {x2 → 1, x5 → 0} yields the 3-variable function ψ(x1, x3, x4) = (x1 ∨ x4) ∧ x3. The substitution {x3 → 0} yields the 4-variable zero function ψ0(x1, x2, x4, x5) = 0.\ncontains exactly the hitting sets (= transversals) of H. For the subset SpMod(ϕ) of all exact hitting sets, an elegeant row-splitting mechanism can be designed based on Donald Knuth’s “Dancing links” algorithm. On a general level, often SpMod(ϕ ⊆ Mod(ϕ) arises by focusing on the inclusion-minimal (or maximal) models. In the sequel we content ourselves to consider SpMod(ϕ) = Mod(ϕ, k) := {u ∈ Mod(ϕ) : |u| = k}. Here the cardinality of a bitstring u ∈ {0, 1}w is the number of 1’s, thus |u| := |{i ∈ [w] : ui = 1}|. A Boolean function ϕ is ksatisfiable if Mod(ϕ, k) 6= ∅.\nCorollary 3: Let C be a hereditary class of Boolean functions and suppose the k-satisfiability of each ψ ∈ C can be tested in time sat(w, k). If sat is monotone in each component then for each ϕ ∈ C with |ϕ| = w and each fixed k > 0 one can enumerate Mod(ϕ, k) in O(Rwsat(w, k)) time where R = |Mod(ϕ, k)|.\nProof: A row ρ is k-feasible if ρ∩Mod(ϕ, k) 6= ∅. Fine-tuning the previous proof we need to show that checking the k-feasiblity of a 012-row ρ can be done in time sat(w, k). If κ := |ones(ρ)| is > k then ρ is not k-feasible. Otherwise consider ψ = ϕ ∧ T (ρ). Because (|ψ|, k − κ) ≤ (w, k) one can check in time sat(|ψ|, k − κ) ≤ sat(w, k) whether ψ is (k − κ)-satisfiable. If yes then ρ is k-feasible, otherwise not.\nAs opposed to r ⊆ Mod(ϕ) obviously r ⊆ Mod(ϕ, k) is only possible when twos(r) = ∅. Hence the enumeration in Corollary 3 is necessarily5 one-by-one, i.e. R = |Mod(ϕ, k)|. The same remark applies to Corollaries 4 and 5 (and to Corollary 1 where mutatis mutandis Mod(ϕ, k) can also be substituted for Mod(ϕ)).\nCorollary 4: Let k ≥ 0 be fixed. If ϕ : {0, 1}w → {0, 1} is given as DNF with t terms then Mod(ϕ, k) can be enumerated in O(Rtw2) time where R = |Mod(ϕ, k)|.\nProof: In view of Corollary 3 it suffices to show that for DNF’s ϕ the time sat(w, k) to test for r ∩ Mod(ϕ, k) = ∅ is O(tw). For starters, if {T1, · · · , Tt} is the set of terms of ϕ then Mod(ϕ) = r(T1)∪ · · · ∪ r(Tt). Hence r∩Mod(ϕ, k) 6= ∅ iff some set r∩ r(Ti) contains a bitstring u with |u| = k. Now r ∩ r(Ti) = ∅ iff ones(r) ∩ zeros(r(Ti)) 6= ∅ or zeros(r) ∩ ones(r(Ti)) 6= ∅. If r ∩ r(Ti) 6= ∅ then ρi := r ∩ r(Ti) can be written as 012-row (as seen in the proof of Corollary 1). Evidently ρi contains at least one u with |u| = k iff |ones(ρi)| ≤ k ≤ |ones(ρi)|+ |twos(ρi)|. It follows that sat(w, k) = O(tw).\nAs an application of Corollary 4 it follows at once that the k-faces of a simplicial complex given by its facets can be enumerated in output-polynomial time [W11].\nRecall that a k-hitting set of a hypergraph H is a k-element set X such that X ∩ Y 6= ∅ for all hyperedges Y ∈ H. A hypergraph is of rank d if |Y | ≤ d for all Y ∈ H.\n5Although we won’t dwell on it in the present article, the verdict “necessarily” is a bit too harsh: There is a way to compress Mod(ϕ, k) using suitable wildcards. This is particularly tempting [W10] when ϕ is given by a BDD. See also 8.3.3.\nCorollary 5: All R many k-hitting sets of a rank 3 hypergraph H ⊆ P[w] can be enumerated in time O(Rw(1.6316k + kw)).\nProof: Coupled to H ⊆ P[w] consider the Boolean function ϕ : {0, 1}w → {0, 1} in CNF whose h clauses match the edges of H. Thus the edge Y = {1, 3, 4} ∈ H matches the clause x1 ∨ x3 ∨ x4. The class C of all such (positive) CNF’s is hereditary, as is illustrated in footnote 4. According to [Wa] one can test in time sat(w, k) = O(1.6316k + kw) whether a rank 3 hypergraph H ⊆ P[w] has a k-hitting set. Since sat is monotone the claim follows from Corollary 3.\nIt is interesting to compare Corollary 5 with this fixed-parameter result which doesn’t use feasibility checks in its proof and which follows at once from Lemma 1.7 in [FG]: All R many k-hitting sets of a rank 3 hypergraph H can be enumerated in time O(3k · k · ||H||) where ||H|| := w + Σ{|X| : X ∈ H}. Notice that possibly R 3k.\nSome readers may wish to skip Section 3 and 4 (which are less important and only used in the experiments Section 7) at a first reading and turn right away to Section 5 where we switch from variable-wise to clause-wise branching."
    }, {
      "heading" : "3 One finality and two feasiblity tests for CNF’s",
      "text" : "The concepts of finality and feasibility apply to 012-rows r with respect to Boolean functions ϕ in arbitrary format. Here we specialize to the common CNF format: Subsection 3.1 is about a perfect finality test and some probabilistic analysis, and 3.2 presents two weak feasiblity tests.\n3.1 Say clause C is x3 ∨ x5 ∨ x6 ∨ x9. If r is a 012-row of length w ≥ 9 that either satisfies ones(r) ∩ {3, 5} 6= ∅ or zeros(r) ∩ {6, 9} 6= ∅ then r ⊆ Mod(C). Generally, if ϕ is a CNF with clause set {C1, · · · , Ch} such that the (index sets of) clauses Ci behave as C above then r ⊆ Mod(C1)∩· · ·∩Mod(Ch) = Mod(ϕ). Conversely, suppose some clause Cj , say x3∨x5∨x6∨x9, misbehaves in that ones(r) ∩ {3, 5} = ∅ = zeros(r) ∩ {6, 9} for some row r. To fix ideas, assume 3 ∈ zeros(r), 5 ∈ twos(r), 6 ∈ ones(r), 9 ∈ twos(r). Then there is u ∈ r with u5 = 0 and u9 = 1, which automatically violates Cj (since u3 ∨u5 ∨u6 ∨u9 = 0∨ 0∨ 0∨ 0 = 0). Hence r 6⊆ Mod(ϕ). To summarize, r ⊆ Mod(ϕ) if and only if all clauses of ϕ behave well in the sense defined above. This yields a perfect finality test of cost O(hw) per row.\n3.1.1 As to probability, let ϕ = ϕ(x1, · · · , xw) be a random CNF with h clauses of length λ. Given w and γ, for a random 012-row of length w with |twos(r)| = γ we denote by prob(w, γ, h, λ) the probability that r is final with respect to ϕ. In order to show\n(3) prob(w, γ, h, λ) = [1− (0.5) λ w (w−γ)]h\nfix an arbitrary clause C of ϕ. Then the probability that a random i ∈ [w] both belongs to [w] \\ twos(r), and is an index of a literal of C, is q = w−γw . λ w . (Clearly the two events are independent.) It follows that the expected overlap of C with ones(r) ∪ zeros(r) has length qw. So the probability that at least one bit satisfies C is p = 1− (0.5)qw. Hence ph is the probability that all clauses behave well, which (as seen before) is equivalent to r ⊆ Mod(ϕ).\n3.2 Consider the Boolean function ϕ : {0, 1}w → {0, 1} and some 012-row r of length w. When ϕ is given as a CNF with clauses C1, · · · , Ch then instead of labelling the positions of r with 1, 2, · · · , w it may at times be more convenient to label them with the variables x1, x2, · · · , xw. Thus if w = 7 and r = (2, 0, 0, 1, 1, 2, 0) it holds that {x2, x3} ⊆ zeros(r). As to the clauses, let us identify Ci with the set of literals appearing in it. More subtly, we write C + i for the set of positive literals occuring in Ci, and C − i for the set of negated negative literals occuring in Ci. Thus if Ci “was” x3 ∨ x5 ∨ x6 ∨ x9 then C+i = {x3, x5} and C − i = {x6, x9} (not {x6, x9}).\nSuppose now Ci and r are such that\n(4) C+i ⊆ zeros(r) and C − i ⊆ ones(r).\nThen obviously r is infeasible (with respect to ϕ). But r can be infeasible without there being a clause Ci (1 ≤ i ≤ h) satifying (4). We thus get a weak feasibility test, which we call Test 1. (It appears to be “very weak” but if always C−i = ∅ as in 6.4, it becomes perfect.)\nConsider now clauses Ci and Cj(i 6= j) such that xp ∈ C+i ∩ C − j and\n(5) (C+i \\ {xp}) ∪ C + j ⊆ zeros(r) and (C − j \\ {xp}) ∪ C − i ⊆ ones(r).\nThen each bitstring u ∈ r that wants to satisfy Ci must have 1 at position xp because by (5) no other literal in Ci can satisfy Ci. Likewise, if u wants to satisfy Cj then it needs to have 0 at position xp. It follows again that row r is infeasible. The ensuing weak feasibility test we call Test 2. Other weak feasibility tests along the same lines can be designed but for us Test 1 and (to lesser extent) Test 2 will suffice."
    }, {
      "heading" : "4 A brief look at BDD’s",
      "text" : "We assume a basic familiarity with binary decision diagrams (BDD’s), as e.g. provided by [K]. In this subsection BDDs serve to illustrate Theorem 1; but more importantly we prepare for the reoccurence of BDD’s in Sections 6 to 8. Consider thus the Boolean function ϕ1 : {0, 1}5 → {0, 1} that is defined by the BDD in Figure 1. Whether a bitstring u belongs to Mod(ϕ1) can be decided as follows. The dashed and solid lines descending from a node labelled xi are chosen according to whether the i-th component ui of u is 0 or 1. Thus, in order to decide whether u = (u1, u2, u3, u4, u5) = (0, 1, 0, 1, 0) belongs to Mod(ϕ1) we follow the dashed line from the root (= top node) x1 to the node x2 (since u1 = 0). Then from x2 with the solid line to x4 (since u2 = 1), then from x4 with the solid line to x5 (since u4 = 1), then from x5 with the dashed line to ⊥ (since u5 = 0). The value of u3 is irrelevant in all of this.\n4.1 Recall from 2.3 that with variable-wise branching only 012-rows of type r = (∗, · · · , ∗, 2, · · · , 2) with ∗ ∈ {0, 1} are ever subject to row-splitting, i.e. to a feasibility check of (∗, · · · , ∗,0, · · · , 2) and (∗, · · · , ∗,1, · · · , 2). How these feasibility checks are performed in the case of BDD’s is clear from the above. Hence Theorem 1 applies. Nevertheless, let us walk through the proof of Theorem 1 using the BDD of Figure 1.\nx1 3ê16\n3ê16 x2 x2 3ê16\n1ê8 x3 x3 1ê8\nx3 1ê4 x4 1ê4 x4 1ê4\nx5 1ê2\n¦ §\nFigure 1: Defining yHx1,...,x5L by a BDD\n22222\n02222 12222\n00222 01222\n00022 02112\n10222\n00012\n12 10122 11122\n01211 10102 11121\n10101\n11222\n00011\nFigure 2: Search tree for ModHyL\nSuppose we are at node 12222 := (1, 2, 2, 2, 2) in Figure 2. Thus in Figure 1 we find ourselves at the rightmost node x2. Setting this x2 to 0 or 1 delivers 10222 respectively 11222. Row 10222 is feasible because there is a path from the medium x3 node to > in Figure 1; and 11222 is feasible because there is a path from the rightmost x3 to >. Because of preorder we continue with 10222. Consulting the BDD shows that only its son 10122 (and not 10022) is feasible. And so it continues way down to the leaf (= model) 10101. Then one returns to 11222, and ends up with the leaf 11121. The fact that 11121 is a proper 012-row is due to the fact that there is a solid line from x3 to x5 in Figure 1, thus skipping x4. The leaves of the tree in Figure 2 show that |Mod(ϕ1)| = 6 because\n(6) Mod(ϕ1) = (0, 0, 0, 1, 1) ] (0, 1, 2, 1, 1) ] (1, 0, 1, 0, 1) ] (1, 1, 1, 2, 1)\nGenerally the degree of compression in the enumeration of Mod(ϕ), i.e. the number of don’t cares 2 in the 012-rows, depends on the index gaps j − i of directed edges xi → xj . In the worst case, when all index gaps are 1, there is no compression, i.e. all rows are bitstrings.\n4.2 As is well known, the two main advantages of the BDD format over other Boolean formats are fast equivalence testing (see 8.3.2) and fast calculation of |Mod(ϕ)|. As to the latter, there is a standard bottom-up way to calculate for each nonleaf node u the probability pu that a random bitstring fed to u (viewed as the root of an induced BDD) triggers a path to >. Namely, pu is simply the arithmetic mean of the probabilities attached to the sons of u. This is carried out in Figure 1. In particular pu = 3 16 for the root u = x1 implies that 3 16 · 2\n5 = 6 bitstrings from {0, 1}5 are models of ϕ1. This matches the number obtained in 4.1. Of course if only |Mod(ϕ)| as opposed to Mod(ϕ) is required, the method just shown is much faster. As to enumerating Mod(ϕ), there is a faster method than the row-splitting of Theorem 1 because it avoids the feasibility tests. Like the probability method it works bottom-up but in the end yields the same deomposition into disjoint 012-rows as Theorem 1; see [W10] for details."
    }, {
      "heading" : "5 CNF-ALLSAT using clause-wise branching",
      "text" : "There is an alternative to the variable-wise branching we applied so far. But it applies only to CNF-ALLSAT, i.e. the Boolean function ϕ = {0, 1}w → {0, 1} comes as CNF with h clauses Ci. Then we can build a search tree such that each node r (= 012-row) has its own particular “pending” clause Ci that needs to be “imposed”. The potentially more than two sons ρj of r are constructed in a way that they all satisfy Ci. This novel kind branching has been programmed by the author in various6 settings. One benefit of clause-wise branching is that it often delivers fat 012-leaves due to a gratuitous finality test: A node is final (i.e. a leaf) if and only if all constraints Ci have been imposed on it. All of this fits the hat of Theorem 1.\n5.1 It has previously been useful, and will be in 5.2, to split the model set of any single clause y1 ∨ y2 ∨ · · · ∨ ym as follows into a disjoint union of m many 012-rows (here m = 5):\nAs introduced in [W4, Sec.3], we shall refer to the pattern in Table 1 as the Flag of Papua with its three colors upon, below, and above the diagonal. It matches this familiar tautology (using concatenation instead of ∧):\n(7) y1 ∨ y2 ∨ y3 ∨ y4 ∨ y5 ↔ y1 ∨ y1y2 ∨ y1y2y3 ∨ y1y2y3y4 ∨ y1y2y3y4y5\n5.2 To develop the details of clause-wise branching, consider the CNF\n(8) ϕ2 := (x1∨x2∨x3)(x2∨x3∨x4)(x3∨x5)(x1∨x3∨x5)(x1∨x4∨x5)(x1∨x2∨x3)(x2∨x4∨x5).\nIt will pay to introduce some redundancy in that our 012-rows r are indexed by x1, x1, · · · , x5, x5 rather than just x1, · · · , x5 as in 3.2. Hence it suffices to speak of Ci (omitting C+i , C − i ), but it entails that when in r the xi-component is 1, its xi-component is 0, and vice versa. An entry 2 at the xi-component forces the xi-component to be 2 as well. Thus such entries are free to be 0 or 1, but in coordination.\nLet us denote by Cj the j-th clause in (8). We identify Cj with the set of its literals, thus C2 = {x2, x3, x4}. Let Modi be the set of all length 10 bitstrings that satisfy C1, C2, · · · , Ci, i.e. the simultaneous models of these clauses. Following the principle of exclusion (footnote 5), starting with Mod0 = {0, 1}10 we shall inductively sieve Modi+1 from Modi (thus exclude the duds from Modi) until we arrive at the model set Mod7 of ϕ2(x1, · · · , x5). We say a 012-row r satisfies a clause Ci if all bitstrings u ∈ r satisfy Ci, and r violates Ci if at least one u ∈ r violates Ci.\n6More details follow in Section 8.4 but we mention that in previous publications the author spoke of a “principle of exclusion” instead of the more telling clause-wise (or constraint-wise) branching.\nIn Table 2 below Mod0 is encoded by row r1, and Mod1 is displayed as the disjoint union of r2, r3, r4. The columns of the boldface Flag of Papua match the literals x1, x2, x3 of C1. The rows r2 to r4 constitute our working stack, of which always the top row will be treated\n7. To do so we keep track of which clause is pending for each row. For instance PC = 3 for r4 since besides C1 (by construction) r4 also happens to satisfy C2, and so the “pending clause” is C3. Next the top row r2 is split into three Flag of Papua candidate sons r5 to r7 according to clause C2. The new top row is r5 which in view of PC = 3 gives way to the candidate sons r8 and r9. Imposing C4 = {x1, x3, x5} upon r8 results in r10 = (0, 1, 1, 0, 0, 1, 2, 2, 1, 0), which has PC = 5. Imposing C5 = {x1, x4, x5} upon r10 yields r11 = {0, 1, 1, 0, 0, 1, 1, 0, 1, 0} which happens to be final, i.e. r11 also satisfies C6, C7. We thus remove r11, which condenses to (x1, x2, x3, x4, x5) = (0, 1, 0, 1, 1), from the working stack and continue in this manner until all leaves of the search tree have been pruned. The 012-rows matching the leaves partition Mod(ϕ2).\nThe reader may wish to carry on like this, though the enhancement in Section 6 will be more exciting. One can notice already that the indicated method begs for a SAT-solver (as in Section 2) in order to immediately get rid of infeasible 012-rows. We dub our procedure the clause-wise ALLSAT 012-algorithm, as opposed to the variable-wise ALLSAT 012-algorithm from 2.3.\n7That method amounts, as in Section 4, to a preorder depth-first search of a search tree (Fig.4). But for clause-wise (as opposed to variable-wise) branching the equivalent last-in-first-out (LIFO) stack framework is more appealing.\nProof: We first show that s(ϕ) = O(wsat(w)), and then that d(ϕ) = O(hw). In view of Theorem 1 the complexity then becomes O(Rh(d+ s)) = O(Rhw(h+ sat(w)) as claimed.\nAs to s(ϕ), the row-splitting mechanism illustrated above works in time s(ϕ) = O(w2 + wsat(w)) = O(wsat(w)). Indeed, imposing a clause of length τ ≤ w upon a 012-row r of length w (i.e. raising the Flag of Papua) costs O(wτ) = O(w2). Each of the τ many candidate sons ρ needs to be tested for feasibility. Testing the feasibility of ρ amounts to testing the satisfiability of ψ = ϕ ∧ T (ρ). Since C is hereditary, ψ belongs to C and whence its satisfiability\nis testable in time sat(|ψ|) ≤ sat(w). As to d(ϕ), the degree of a 012-row r is calculated by scanning the h clauses Ci until Ci ∩ ones(r) = ∅. Hence d(ψ) = O(hw).\nWe mention that for the class C of Horn CNF’s the bound in Theorem 2 reduces to O(Rh2w2). This is established in [W2], though in a framework more clumsy than Theorem 1 with its row-splitting mechanism. While one could also enumerate C in output-polynomial time using variable-wise branching, the high compression achieved by clause-wise branching would virtually disappear.\n6 Extension to 012e-rows\nWe now trim the clause-wise ALLSAT 012-algorithm of Section 5 by moving beyond the don’t care symbol 2. The basic idea is to replace any Flag of Papua, as in in Table 2, by the wildcard or e-bubble (e, e, e, e, e) which by definition means “at least one 1 here”. Let us jump into medias res and impose C1 to C7 of ϕ2 anew, starting with row r ′ 1 = (2, 2, · · · , 2) in Table 3. Imposing C1 upon r ′ 1 yields r ′ 2. Imposing C2 upon r ′ 2 yields r ′ 3 which features a new, disjoint e-bubble. The two are distinguished by subscripts. Generally any row featuring the symbols 0, 1, 2 and possibly e-bubbles will be called8 an 012e-row. In order to impose C3 upon r ′ 3 we first partition r′3 = r ′ 4 ] r′5 as indicated. Notice that the 0 in r′5 forces the 1 on its left. Furthermore the 0 in r′5 turns the (e2, e2, e2) in r ′ 3 to (e2, 0, e2), and the 1 in r ′ 5 turns the (e1, e1, e1) in r ′ 3 to (2, 2, 1). Similar remarks appy to r′4. The advantage of r ′ 4, r ′ 5 over r ′ 3 is that r ′ 4 satisfies C3 = {x3, x5} (whence PC = 4), and imposing C3 upon r ′ 5 immediately yields r ′ 6. Notice that r ′ 6 happens to satisfy C4, and so has PC = 5. Imposing C4 upon r ′ 4 yields r ′ 7.\n8This renames the “{0, 1, 2, e}-valued rows” in previous publications. Of course each 012-row is a 012e-row but not conversely.\nNow things get interesting. In order to impose C5 = (x1, x4, x5} upon r′7 we first partition r′7 = r ′ 8 ] r′9. Here r′8 must be deleted since it violates C6 = {x1, x2, x3}, whereas r′9 turns to r′10 upon imposing C5. Actually r ′ 10 happens to be final (i.e. satisfies C6, C7 as well) and thus is removed from the working stack. Imposing C5 upon r ′ 6 yields r ′ 11 which again happens to be final. Pinning x4 in r ′ 11 to 1 and 0 respectively shows that\n(9) r′11 = r ′ 12 ] r′13 = (2, 2, 1, 0, 1, 0,1, 0, 1, 0) ] (1, 0, 2, 2, 1, 0,0, 1, 1, 0).\nThe by construction mutually disjoint rows r′10, r ′ 12, r ′ 13, when shrunk back to length 5, yield\n(10) Mod(ϕ2) = (0, 2, 0, 1, 1) ] (2, 1, 1, 1, 1) ] (1, 2, 1, 0, 1)\nComparing (7) and (10) we see that Mod(ϕ1) = Mod(ϕ2), and so the BDD in Figure 1 yields the same Boolean function as the CNF in(8).\nThe illustrated method will be dubbed the ALLSAT e-algorithm, which sounds better than ALLSAT 012e-algorithm. The adjective “clause-wise” is superfluous since the e-formalism does not apply to variable-wise branching. Subsections 6.1 and 6.2 are straightforward whereas 6.3 to 6.5 are more technical in nature.\n6.1 Speaking of 012e-rows is good and well, but occasionally alternative terminology is helpful, e.g. for comparison with some standard formats of Boolean functions. Generalizing ordinary terms like x1 ∧ x2 ∧ x3 we hence introduce fancy terms like\n(11) (x1 ∨ x4) ∧ (x2 ∨ x4) ∧ x3 ∧ x5\nwhich by definition are (literal-wise) disjoint conjunctions of clauses of any length, except that complementary length 1 clauses xi and xi are forbidden. We shall see in 6.3 that each fancy term is satisfiable. The fancy term in (11) matches r′11 in Table 4. Further we call ψ an exclusive sum of fancy terms (ESOFT) if ψ = ψ1 ∨ · · · ∨ ψm is such that\n(a) all ψi’s are fancy terms;\n(b) Mod(ψi) ∩Mod(ψj) = ∅ for all 1 ≤ i < j ≤ m.\nFor instance, using (11) the ESOFT corresponding to r′10 ] r′11 in Table 3 is\n(12) ϕ3 = ϕ31 ∨ ϕ32 := (x1 ∧ x3 ∧ x4 ∧ x5) ∨ ((x1 ∨ x4) ∧ (x2 ∨ x4) ∧ x3 ∧ x5).\nHere the meet of the disjuncts is zero. We claim that the law ϕ2 ≡ ϕ3 holds in all Boolean algebras B. As is well known, it suffices to establish ϕ2 ≡ ϕ3 in the 2-element Boolean algebra. This is true because of ϕ2(u) = 1 ⇔ u ∈ Mod(ϕ2) ⇔ u ∈ Mod(ϕ3) ⇔ ϕ3(u) = 1, where the second ⇔ holds since\nMod(ϕ2) = r ′ 10 ∪ r′11 = Mod(ϕ31) ∪Mod(ϕ32) = Mod(ϕ3).\nFor instance if A1, · · · , A5 ∈ B = P[S] are any subsets of some set S then ϕ2 ≡ ϕ3 translates, upon putting Ai := S \\Ai, to:\n(13) (A1 ∪A2 ∪A3) ∩ (A2 ∪A3 ∪A4) ∩ (A3 ∪A5) ∩ (A1 ∪A3 ∪A5) ∩ (A1 ∪A4 ∪A5) ∩ (A1 ∪A2 ∪A3) ∩ (A2 ∪A4 ∪A5) = (A1 ∩A3 ∩A4 ∩A5) ] ((A1 ∪A4) ∩ (A2 ∪A4) ∩A3 ∩A5)\nFormula (13) and [SSK] may share some common ground but that needs further investigation.\n6.2 We saw that the ALLSAT e-algorithm turns each CNF into an ESOFT. Let us briefly relate ESOFT to ESOP, DNNF and BDD. First, ESOFT is a powerful generalization of ESOP (see also 6.5 and 7.2). Second, ESOFT is a special case of Decomposable Negation Normal Form (DNNF). That follows9 at once from the definition [D] of DNNF which postulates a disjointness property akin to the definition of “fancy term” in (a). In contrast ESOFT links to BDDs rather by the other disjointness property (b). Indeed, as seen in 4.1, BDDs induce a partition of Mod(ϕ) into a disjoint union of 012-rows, which hence is a special type of ESOFT. A more thorough discussion of ESOFT versus BDD follows in Section 8.3.\n6.3 In order to show that each fancy term (viewed as 012e-row) is satisfiable, we introduce some notation. Given a 012e-row we call a complementary pair {xi, xi} bad if it is covered by distinct\n9Actually ESOFT implies DNNF even if we dropped (but we won’t) the crucial property (b). Similar reasoning shows that DNF implies DNNF.\ne-bubbles; otherwise it is good. A 012e-row r′ is purified if all complementary pairs are good. Such rows r′ are nonempty since all e-bubbles can be put to 1 without conflict; indeed, e → 1 merely forces 2→ 0 for some 2 elsewhere. In order to show that each 012e-row r contains some purified row r′ and whence is satisfiable, it suffices by induction to show that r contains a row r′ with one less bad pair {xi, xi}. Therefore, say e1e1 · · · , e1 (its first e1) covers xi and e2e2 · · · e2 (its first e2) covers xi. Then r\n′ arises from r by substituting 12 · · · 2 for e1e1 · · · e1 and 0e2 · · · e2 for e2e2 · · · e2. The case that e2e2 is of length two however requires special attention.\nThen 0e2 · · · e2 boils down to 01. Suppose this 1 occupies xj and there is a bubble e3e3 that covers xj . Then e2e2 = 01 forces e3e3 = 01, and this pattern may further repeat. However, the number of length two bubbles being finite, one eventually reaches a state where the produced 0 falls upon a 2, or upon a bubble etet · · · et of length ≥ 3, which then becomes 0et · · · et. A concrete example of a 012e-row r which contains10 the purified row r′′ ⊆ r′ ⊆ r is shown in Table 4.\n6.3.1 For any purified 012e-valued row ρ it’s easy to calculate |Mod(ρ)|. If say\nthen |Mod(ρ)| = (22 − 1) · (24 − 1) · 22. Indeed, for all 24 − 1 legal (i.e. 6= (0, 0, 0, 0)) choices of (e2, e2, e2, e2) the coupled 2’s adapt accordingly. Thus if (e2, e2, e2, e2) = (x5, x6, x7, x8) = (0, 1, 1, 0) then (x5, x6, x7, x8) = (1, 0, 0, 1). The 2’s at x3 and x4 are free (only coupled to x3, x4) and thus can be chosen in 22 many ways. Generally, if ρ is a purified 012e-row with e-bubbles of length ε1, · · · , εs and t many free 2’s then\n(14) |ρ| = (2ε1 − 1)(2ε2 − 1) · · · (2εs − 1) · 2t\n6.3.2 In order for formula (14) to be useful we need to show how any 012e-row ρ can be written as a disjoint union of purified rows. An example will do. For ρ as in Table 6 we pick all t bad pairs, here {x1, x1}, {x2, x2}, and consider all 2t = 4 {0, 1}-instantiations ρ1, · · · , ρ4 of ρ. Obviously ρ = ρ1 ] ρ2 ] ρ3 ] ρ4, but some ρi (despite appearances) may be empty since an e-bubble falls into zeros(ρi); in our case ρ2 = ∅ since e2e2 falls into zeros(ρ2).\n10The boldface entries 10 indicate “actively diffused” bad pairs (going from left to right), whereas the other 0 and 1 in r′′ are consquences thereof.\nAs proven previously at least one of the 2t many instantiation of ρ will yield a nonempty purified 012e-row ρj . Getting these ρj ’s can be achieved in smarter ways than listing 2\nt rows and discarding the bad ones. But we won’t dwell on this here.\n6.4 The technicalities of the ALLSAT e-algorithm simplify if the CNF for ϕ features only positive literals. To start with, all arising 012e-rows are purified since all components indexed by negative literals carry don’t-care 2’s. In fact, we may consider in the first place short 012e-rows labelled only by the positive literals x1 to xw. The satisfiability test becomes straightforward in this scenario: Such a 012e-row r is feasible with respect to a CNF ϕ with clauses C1, C2, · · · , Ch if Ci 6⊆ zeros(r) for all 1 ≤ i ≤ h. Indeed, if this condition holds, let u be the length w bitstring defined by zeros(u) := zeros(r) and ones(u) := [w] \\ zeros(r). Then u ∈ r and ϕ(u) = 1. Thus the weak feasibility Test 1 from Section 3 becomes a perfect feasibility test when restricted to positive Boolean functions.\n6.4.1 As is well known, models of a positive Boolean function ϕ and transversals of a hypergraph are “the same thing”. That’s why the trimming of the ALLSAT e-algorithm in the case of positive Boolean functions was called transversal e-algorithm in [W5]. It is shown in detail in [W5, Sec.2] how the Flag of Papua (see Table 1) is lifted from the 012-level to the 012e-level in the transversal e-algorithm. The author is confident that the Flag of Papua further carries over to the ALLSAT e-algorithm but this has not yet been implemented into Mathematica. We expand further on the past and future of the ALLSAT e-alogithm in Section 8.\n6.4.2 We note in passing that for positive Boolean function the following compression advantage of ESOFT against ESOP can be proven. There are 3n many 012-rows of length n, but Be``(n+ 2)− Be``(n+ 1) many 012e-rows [W5]. Here the Be`` number Be``(n) gives the number of set partitions of [n]. For instance 310 = 59049 whereas Be``(12)− Be``(10) = 4097622.\n6.5 For later purpose consider the task to represent the intersection of two 012e-rows r and ρ. For simplicity we stick to the case of positive Boolean functions but the arguments readily carry over. One option is to take the row with the fewer and shorter e-bubbles, say it is ρ with e-bubbles of lengths ε1, · · · , εs, and to expand it into N := ε1, ε2 · · · εs many 012-rows ρi by “multiplying out” s many Flags of Papua. It then follows that\nr ∩ ρ = (r ∩ ρ1) ] (r ∩ ρ2) ] · · · ] (r ∩ ρN )\nwhere each r∩ρi is either empty (when 0’s clash wih 1’s) or can readily be written as a 012e-row (akin to the intersection of two 012-rows in the proof of Corollary 1). The crucial words above are “fewer and shorter”. Thus if ρ has e-bubbles of lengths ε1 = ε2 = · · · = ε6 = 10 then it induces N = 106 many 012-rows ρi! In such a case one is better off picking the row with the fewer e-bubbles, say again ρ, and impose them on the other row by virtue of the transversal\ne-algorithm. For illustration see Table 7 where the five 012e-rows below r have a disjoint union that equals r ∩ ρ. In particular |r ∩ ρ| = 63 + 12 + 6 + 42 + 18 = 141. If only the cardinality of r ∩ ρ is required (as in 8.3.4) one may be better off using inclusion-exclusion. Namely, consider the property p1 of a bitstring u ∈ r to satisfy eeee (thus |ones(u) ∩ {1, 2, 3, 4}| ≥ 1). Similarly p2 holds if e e e e is satisfied. If say N(p1) is defined as the number of u ∈ r not satisfying p1 we get\n|r ∩ ρ| = |r| −N(p1)−N(p2) +N(p1p2)\n= 3 · 7 · 7− |(0, 0, 0, 0, e1, e1, 1, 1)| − |(1, 1, e3e3, 0, 0, 0, 0)|+ 0\n= 147− 3− 3 + 0 = 141\nwhich matches the number obtained above."
    }, {
      "heading" : "7 Numerical experiments",
      "text" : "In brief, 7.1 compares the variable-wise ALLSAT 012-algorithm of Section 2 with the clause-wise ALLSAT 012-algorithm of Section 5. In 7.2 the clause-wise ALLSAT 012-algorithm is pitted against the (clause-wise) ALLSAT e-algorithm on positive Boolean functions. In 7.3 the clausewise ALLSAT 012-algorithm is pitted against BDD’s. Finally 7.4 adds weight functions to the picture.\n7.1 We pitted the variable-wise ALLSAT 012-algorithm against the clause-wise ALLSAT 012- algorithm on Boolean functions ϕ : {0, 1}w → {0, 1} with h random clauses, each of cardinality λ (for simplicity). For each triplet (w, h, λ) we only11 produced few ϕ’s. For ϕ we record |Mod(ϕ)| and the times in sec (unless stated otherwise) it took to enumerate Mod(ϕ) (with disjoint 012- rows) using the variable-wise, respectively clause-wise ALLSAT 012-algorithm. Furthermore, for both algorithm |twos(r)| gives the average number of 2’s per row. Thus the higher γ = |twos(r)| the better the compression. Finally for both algorithms we record prob = prob(w, γ, h, λ) as defined in Section 3.1. Hence prob is the probability that a random 012-row r (independent of any algorithm) with parameters (w, γ, h, λ) also happens to satisfy r ⊆ Mod(ϕ). We wrote ≈ 0 for probabilities < 10−6. The (25, 50, 10) and (100, 5, 30) and (500, 3300, 4) instances show\n11It turns out that random ϕ’s sharing the same parameters (w, h, k) behave very much alike.\nthat variable-wise badly trails behind clause-wise when |Mod(ϕ)| is large. Here “68/sec” means that during the first hour in the average 68 models were produced per second. When |Mod(ϕ)| is small then both algorithms finish in reasonable time due to the fact that the number R of 012-rows produced is ≤ |Mod(ϕ)|. As h gets very large the variable-wise approach slightly wins out as seen in the (25, 50000, 12) instance. As to the expression “reasonable time”, this should be seen in relation to the Mathematica-command SatisfiabilityCount which is based on BDD’s and which e.g. in the (100, 900, 4) instance was aborted after one hour.\n7.2 When comparing the (cut short) Table 2 with Table 3 it becomes plausible that introducing the e-symbol can speed up things further. While the clause-wise ALLSAT 012-algorithm has been programmed with MATHEMATICA, recall from 6.4 that this is pending for the ALLSAT e-algorithm. However, the two algorithms can be compared for the special case of positive Boolean functions. Specifically, as pointed out in 6.4, the ALLSAT e-algorithm, fed with a positive Boolean function ϕ, behaves exactly as the transversal e-algorithm when fed with ϕ.\nLet us hence compare the (clause-wise) transversal e-algorithm with the (clause-wise) transversal 012-algorithm. Without further mention, all ϕ’s in 7.2 are positive. For starters, when ϕ is given by h mutually disjoint clauses of lengths ε1, . . . , εh the difference in compression is dramatic: While just one 012e-row suffices to represent Mod(ϕ), it takes ε1ε2 · · · εh many 012-rows to achieve the same thing. Also for ϕ(x1, · · · , xw) with h random clauses, each of length k (for simplicity), the numerical evidence in favor of the transversal e-algorithm is compelling, as shown in Table 9. Here Te and T012 are the times in seconds needed by the transversal e-, respectively 012-algorithm. Similarly Re and R012 are the respective numbers of final 012e-rows and 012-rows.\n(w, h, k) |Mod(ϕ)| Re Te R012 T012 200 10 150 ≈ 2200 802 0.2 8× 105 61 60, 40, 30 ≈ 1018 134392 56 9× 106 563 60, 25, 7 ≈ 1018 841531 292 6× 109 106 20 10 4 650 024 37 0.03 218 0.05\n20 50 4 243 632 2036 1.4 11 669 1.8 20 100 4 129 206 4961 5.7 15909 3.8 20 3000 4 4717 2365 132 3220 18\n20 3000 15 1039831 3972 177 16879 6.3 40 50000 4 107957 - - 87833 10662\nTable 9: Transversal e-algorithm against transversal 012-algorithm (for positive functions)\nFor the (200, 10, 150), the (60, 40, 30) and the (60, 25, 7) instances one has Re R012 and whence Te T012. In fact for (60, 25, 7) the ALLSAT 012-algorithm was stopped after 21 hours and the values of T012 and R012 are only extrapolated. Letting h = 10, 50, 100, 3000 in the (20, h, 4) instances one still has Re < R012 but these gaps get proportionally smaller and are eventually time-wise more than compensated by the simpler row-splitting mechanism on the 012-level. Even more so in the (20, 3000, 15) and (40, 50000, 4) instances.\n7.2.1 If condition (2a) is not maintained by the row-splitting algorithm then some of the rows r in the working stack will be infeasible, and they may trigger infeasible sons. However, eventually infeasibility will be detected. To fix ideas, if say the clause x2 ∨ x4 ∨ x7 is to be imposed on the top row r, and {2, 4, 7} ⊆ zeros(r), then r is detected as infeasible and must be deleted. Such a deletion we call harmful (as opposed to the deletion of a feasible row when it is replaced by its sons). Recall that Test 1 in Section 3 becomes a perfect feasiblity test for positive Boolean functions. However, the extra time to run the test (and hence avoid harmful deletions of rows) doesn’t always pay off. In the instances above it only paid off for h ≥ 3000. Thus if we don’t use Test 1 for the (20, 3000, 4) instance then the transversal e-algorithm suffers 11384 harmful row deletions and the time jumps from 132 to 243 seconds. For h < 3000 we were better off with accepting harmful deletions.\n7.2.2 One may think that for small values w checking all u ∈ {0, 1}w individually may be faster than imposing a large number h of constraints. Thus we implemented this “naive way” to scan12 the modest size powerset {0, 1}20 and found that the (20, 3000, 15)-instance in Table 9 took a hefty 12830 sec. The problem is that a small powerset doesn’t help because, in view of k = 15, most u ∈ {0, 1}20 pass all 3000 intersection tests (ones[u] ∩ clause[i] ?=∅). We hence also ran the (20, 3000, 4)-instance in the naive way. Indeed the time boiled down to 344 sec since most u ∈ {0, 1}20 dropped out after few intersection tests. The joy is short: Increasing w to 40 (as in the (40, 50000, 4)-instance) puts a mere scanning of {0, 1}40 (without extra fuzz) out of question.\n7.3 Now we pit the clause-wise ALLSAT 012-algorithm against the MATHEMATICA command SatisfiabilityCount[ϕ]. The latter works by constructing the BDD of ϕ, which then yields |Mod(ϕ)| at once (see 4.2). Hence timing SatisfiabilityCount in effect means timing the construction of a BDD. Unfortunately this is only half the task we wish to time. Since the underlying BDD seems to be inaccessible to the user, we cannot13 assess getting an ESOP from the BDD, neither time-wise nor compression-wise. This constitutes on “unfair advantage” in the timing of SatisfiabilityCount. The other advantage is the fact that it is a “hardwired” MATHEMATICA command whereas the clausewise ALLSAT 012-algorithm is written in high-level MATHEMATICA code. As a perfect feasibility test we use the hardwired MATHEMATICA command SatisfiabilityInstances. It is based on a search tree (not DPLL) and either offers a model for any Boolean function ϕ or it returns the empty set, in which case ϕ is provably unsatisfiable. Different from 7.1 the groundset induced by our Boolean functions ϕ(x1, · · · , xw), which are conjunctions of h random clauses of cardinality k, is now {x1, x1, · · · , xw, xw}.\nIn Table 10 on the left TSC is the time for SatisfiabilityCount, T012 the time for the clausewise ALLSAT 012-algorithm, and R012 the number of final 012-rows it produces. If we compare the (60, 10, k) instances for k ∈ {3, 7}, SatisfiabilityCount is way ahead (keeping in mind\n12This is easily established with the Mathematica command Subsets[· · ·]. 13Mending this state of affairs is a major task of a planned follow-up paper.\nits unfair advantage). The time T012 is essentially proportional to the number R012 of final rows, which in turn depends on how often the “Flag of Papua gets raised”. If we push h = 10 to 50 then TSC = 78 sec, and for h = 80 we stopped SatisfiabilityCount after 50 fruitless hours. Admittedly, also T012 and R012 are astronomic for h = 50, 80, · · · but, different from SatisfiabilityCount, not forever! Namely, if say h = 4600 then this sheer number of clauses allows only for 143 models which the ALLSAT 012-algorithm found in 6191 seconds. Observe that SatisfiabilityInstances took 83 sec to find just one model, while the ALLSAT 012-algorithm required 6191/143 ≈ 43sec per model on average, despite the fact that SatisfiabilityInstances is an essential ingredient of it.\n7.3.1 A few words about the weak feasibility tests in Section 3 are in order. While Test 1 becomes a perfect feasibility test for positive Boolean functions, it performs poorly for arbitrary Boolean functions. Interestingly the conjunction (Test 1 + Test 2) yields a decent weak feasibility test, i.e. with few harmful deletions of intermediate 012-rows. Time-wise however (Test 1 + Test 2) couldn’t compete with SatisfiabilityInstances. Thus the former needed 4755 sec to find the two models of some (50, 490, 4) instance and suffered 431059 harmful deletions, while the latter did the job in 0.5 sec. Whether this state of affairs changes when other weak feasibility tests are added, or when the hardwire-advantage of SatisfiabilityInstances is taken into account, remains to be seen. As to SatsifiabilityCount, we aborted it after 16 hours.\n7.4 Consider now weight functions f : {0, 1}2w → Z+ induced by random functions [2w]→ [20]. While the whole BDD needs to be available in order to sieve all models of small weight (say ≤ b), this is not the case for the clause-wise ALLSAT 012-algorithm. Namely, along with the perfect feasibility test applied to an intermediate row r one can check fast whether r contains any bitstrings (thus possibly models) of weight ≤ b. If no, then r is deleted. Of course this idea beats first producing all models and then throwing most of them away (which essentially the BDD approach is doomed to do). For each instance (w, h, k) binary search quickly14 yields values b0 ∈ Z+ which are large enough to trigger a nonempty set Mod(ϕ, f, b0) of models of weight ≤ b0, yet small enough to keep |Mod(ϕ, f, b0)| at bay.\nIn this light of weight functions let us return to the (60, 50, 7) instance where TSC is a hefty 78 sec and both T021 and R012 are astronomic. Here the time to enumerate only all models of weight ≤ b0 was a mere T ′012 = 0.4 sec (see Table 10 on the right). For this particular b0 there where exactly R′012 = 8 final 012-rows which contained at least one small weight model. In the process del = 228 times an intermediate 012-row r was deleted because all u ∈ r had weight > b0. For h = 80 all of TSC , T012, R012 are astronomic yet for suitable small b0 one gets T ′012 = 0.2 and R ′ 012 = 4. Raising b0 a bit yields T ′ 012 = 81 and R ′ 012 = 4446. When R012 is small already, as in the (60, 4600, 7) instance, then T ′012 can’t be pushed much below T012.\n(w, h, k) |Mod(ϕ)| TSC T012 R012 T ′012 R′012 del 60 10 3 ≈ 3× 1017 0 7 6318 0.1 10 63 60 10 7 ≈ 1018 0 69 71470 0.7 52 313 60 50 7 ≈ 8× 1017 78 - - 0.4 8 228 60 80 7 ≈ 6× 1017 - - - 0.2 4 156 60 80 7 ≈ 6× 1017 - - - 81 4446 32953 60 4600 7 143 - 6191 139 6154 2 122\n14We didn’t time this preprocessing part.\nTable 10: SatisfiabilityCount (= BDD) against the clause-wise ALLSAT 012-algorithm"
    }, {
      "heading" : "8 History and envisaged future",
      "text" : "History and intended future of the ALLSAT e-algorithm will be addressed in 8.1 to 8.3. In particular, Subsection 8.3 dwells on BDD’s and draws part of its optimism from the computer experiments in Section 7. Subsection 8.4 is still about history and future but zooms away from the ALLSAT e-algorithm to specific types of ALLSAT problems susceptible to wildcards.\n8.1 In 2005 I gave a talk about the transversal e-algorithm [W5]. This inspired Gideon Redelinghuys and Jaco Geldenhuys [RG] to carry over the e-framework from positive to arbitrary Boolean CNF’s, in order to determine their satisfiability; they called their method SATEalgorithm. In the last 10 years I didn’t persue that road but turned to clause-wise15 branching in more specific scenarios as mentioned in 8.4. These experiences led to the conviction that clause-wise branching should not be abused to challenge taylor-made satisfiability tests. Rather the purpose of clause-wise branching should be ALLSAT. The reason is two-fold. First, as opposed to variable-wise branching a node in the clause-wise search tree can have more than two sons, which in itself makes branching more efficient. Second (Section 5), once all clauses are imposed on a multivalued row, it is automatically final and may pack a great many models. Here multivalued means that apart from 0,1 one has the don’t-care symbol 2 and possibly further wildcards such as (e, e, · · · , e) and others that proved to be useful.\n8.2 I recently returned to the SATE algorithm and now regard the extension of the e-symbolism from {x1, · · · , xw} to {x1, x1, · · · , xw, xw} as its crucial idea. However, the attempt to challenge Chaff, one of the leading SAT-solvers [MMZZM], is misguided as argued in 8.1. Not knowing any technical details16 of the C implementation of the SATE algorithm in [RG], I went back to the drawing board. After some deliberation I settled for the 012-level, thus programming the clausewise ALLSAT 012-algorithm in high-level Mathematica code. The comparison of the transversal 012-algorithm with the transversal e-algorithm in 7.2, as well as the comparison of Tables 2 and 3, strongly indicate that the ALLSAT e-algorithm, once programmed17, will exhibit a further leap in compression. Predictably ALLSAT-algorithms that output their models one-by-one will trail when the number of models gets large.\n8.3 Probably the main competitor of the ALLSAT e-algorithm is the BDD framework since, as seen in Section 4, a BDD for ϕ allows an enumeration of Mod(ϕ) by 012-rows (ESOP). But there are several issues that need to be investigated; in 8.3 we only glimpse at them.\n8.3.1 For starters, there is the conversion time from CNF to BDD. Then there is the often denied fact that the average size of the BDD of a Boolean function ϕ(x1, · · · , xn) is about 2n/n, thus a hefty 1n times the length of the full truth table of ϕ. True, changing the variable order 18\n15Perhaps “constraint-wise” would be a better word since some of the constraints (as in [W1]) cannot be recast as clauses of a Boolean CNF. However “constraint-wise” evokes unwanted proximity to Constraint Programming. The precise relation between the two remains to be unravelled.\n16Whatever they are, a glimpse at [RG] shows that e.g. the issue of purified rows has been glossed over. 17I leave that noble task to others. It would be nice if Chaff was used as satisfiability subroutine. If coded in Mathematica, SatisfiabilityInstances is a decent substitute. 18The order in which one feeds the clauses to the ALLSAT e-algorithm similarly influences the size of the resulting ESOFT but this has not been researched yet.\noften shrinks the BDD, but that costs time. On an aesthetic level, the construction algorithms for BDD’s are rather awkward. In contrast the ALLSAT e-algorithm is easier to understand. But then again this assessment may be due to the author’s misconception that nobody has yet topped Knuth’s lovely (though not on the discussed issue) introduction [K] to BDD’s.\n8.3.2 Assume we have (in whatever way obtained) a BDD and also an ESOFT of some Boolean function ϕ. Using the BDD calculating |Mod(ϕ)| is fast, and enumerating Mod(ϕ) is straightforward. Straightforward it may be, but if the index gaps (4.1) are small, many 012-rows may be bitstrings. Concerning the ESOFT, after “purification” as in 6.3.2, we have a representation of Mod(ϕ) as disjoint union of purified 012e-rows, which have more compression potential than 012-rows (see 6.4.1).\n8.3.3 What about fixed cardinality models? Calculating |Mod(ϕ, k)| from a purified ESOFT of ϕ is readily reduced to calculating the coefficient at xk of some associated polynomial p(x), exactly as in [W5. p.124]. Enumerating Mod(ϕ, k) from a purified ESOFT can be done with wildcards in a manner similar to [W11]. As to BDDs, calculating |Mod(ϕ, k)| from a BDD of ϕ is little known: A nice method of Knuth [K, Exercise 25] is reviewed (with slightly trimmed notation) in [W10]. The enumeration of Mod(ϕ, k) from a BDD of ϕ, as handled in [W10], seems to be new. As opposed to ESOFT it can actually be done in output-polynomial time (and again with wildcards). Output-polynomial or not, how ESOFT compares to BDD in practise remains to be seen.\n8.3.4 One major benefit of BDDs is equivalence testing: Given Boolean formulas ϕ and ψ it holds that ϕ↔ ψ if and only if the corresponding BDD’s are isomorphic. This fails for ESOFT since ϕ has many different ESOFTs. However things aren’t too bad. If ϕ and ψ are in purified ESOFT format then N(ϕ) := |Mod(ϕ)| and N(ψ) := |Mod(ψ)| are readily computed, and if N(ϕ) 6= N(ψ) then ϕ 6↔ ψ. Conversely, if N(ϕ) = N(ψ) then chances are high that ϕ ↔ ψ. Even more so if |Mod(ϕ, k)| = |Mod(ψ, k)| for all k (see 8.3.3).\nIn order to sketch a waterproof equivalence test, let Mod(ϕ) and Mod(ψ) be given as purified ESOFTs, say r1 ] · · · ] rs and r′1 ] · · · ] r′t respectively. Suppose we checked that N(ϕ) = N(ψ) and we managed to prove for all 1 ≤ i ≤ s that\n(15) Card(ri) = t∑ j=1 Card(ri ∩ r′j).\nThen (15) implies that all ri ⊆ r′1 ] · · · ] r′t, whence r1 ] · · · ] rs ⊆ r′1 ] · · · ] r′t, whence Mod(ϕ) = Mod(ψ) in view of N(ϕ) = N(ψ). Conversely, if (15) fails for some i ∈ [s] then Mod(ϕ) 6= Mod(ψ). As to calculating Card(ri ∩ r′j), we mention that the inclusion-exclusion method of 6.5 can be sped up (work in progress). Even so, the ensuing equivalence test is wanting when compared to the one provided by a BDD.\nThis suggests a hybrid method for checking whether ϕ ↔ ψ : If N(ϕ) 6= N(ψ) (as swiftly calculated with the ALLSAT e-algorithm), then ϕ 6↔ ψ. Otherwise invest calculating BDD’s of ϕ and ψ to settle the question. Of course, if the likelihood for ϕ↔ ψ somehow is high beforehand then use BDD’s right away.\n8.4 In the last ten years the author found compressed representations of specific types of set\nsystems by employing the don’t-care “2” and various wildcards apart from ee · · · e. Let us briefly take stock. Article [W2] enumerates the model set of a Horn formula ϕ as a disjoint union of 012n-rows. Here the wildcard nn · · ·n means (dually to ee · · · e) “at least one 0 here”. The method of [W2] can be fine-tuned for three special types of Horn formula. First, the noncover n-algorithm applies to negative Boolean functions and was successfullly applied to stack filters, i.e. tools used in nonlinear digital filtering [W3]. Second, pure Horn functions, aka known as implications A → B, enjoy many applications in Data Mining and elsewhere [W7], [W8]. Third, particularly pleasant implications are the ones with singleton premises A = {a}. The corresponding (a, b)-algorithm calculates all order ideals of a poset in a compressed fashion [W4]. Note that both for stack filters and for Coupon Collecting [W6] it is essential not merely to calcluate |Mod(ϕ)| but also |Mod(ϕ, k)| for all k ∈ [w]. Article [W1] was the wildcard pioneer. While wildcards are used during the algorithms, all final rows are bitstrings. This is not due to deficient programming but forced by the inherent structure of the models (= cycles). Hence “traditional” one-by-one algorithms become competitive, and actually have proven superior for chordless cycles. With hindsight it is clear that the employed wildcards could be used more efficiently if the target was optimization of models rather than their exhaustive enumeration. The compression of Mod(ϕ) for 2-CNF’s [W9] is a bit of an outsider in that it is achieved using variable-wise branching and nothing fancier than don’t-care 2’s. The fact that all mentioned Mod(ϕ) can be compressed in output-polynomial time is due to the fact that the corresponding formulas ϕ allow for a polynomial-time satisfiability test.\n8.4.1 The present article is conceived as a hinge between past and future. We just reviewed the past, and Theorem 1 is intended to be a hat for several future results. What is more, their inner and (more so) interdependent structure presumably will be, with the benefit of hindsight, a bit better organised than for [W1] to [W6]. Specifically the present article is Part 1 in a planned series “ALLSAT compressed with wildcards”. Part 1 tackled arbitrary Boolean functions, mainly CNF’s. In contrast, for DNF’s enumeration is easy (even cardinality-wise, Corollary 4) but making DNF’s orthogonal is hard. Solving19 this problem with a small number t of multivalued rows would have quite a few applications, e.g. in view of Corollary 1. The author’s ideas in this regard must stand back in favor of more thought-through topics appearing earlier in the planned mini-series. These topics concern set systems F whose matching Boolean functions ϕ (i.e. F = Mod(ϕ)) have, as in the past, polynomial-time satisfiability tests. Promising types of F include: All faces of a simplicial complex (given by its facets or otherwise); all shellings of a simplicial complex; all subgraphs of a graph (of various types such as all anticliques); all k-models of a BDD, all closed sets of a convex geometry."
    } ],
    "references" : [ {
      "title" : "Proc",
      "author" : [ "A. Darwiche", "New advances in compiling CNF to decomposable negation normal form" ],
      "venue" : "of the European Conference on Artificial Intelligence",
      "citeRegEx" : "D",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Parametrized Complexity Theory",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : "Springer",
      "citeRegEx" : "FG",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "the Art of Computer Programming",
      "author" : [ "D. Knuth" ],
      "venue" : "Volume 4 (Preprint), Section 7.14: Binary decision diagrams, Addison-Wesley",
      "citeRegEx" : "K",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Analysis and enumeration. Algorithms for biological graphs",
      "author" : [ "A. Marino" ],
      "venue" : "This pricewinning Thesis appeared als Vol.6 of Atlantis Studies in Computing",
      "citeRegEx" : "Marino,? \\Q2015\\E",
      "shortCiteRegEx" : "Marino",
      "year" : 2015
    }, {
      "title" : "Chaff: Engineering an efficient SAT Solver, 39th Design Automaton",
      "author" : [ "M.W. Moskewicz", "C.F. Madigan", "Y. Zhao", "L. Zhang", "S. Malik" ],
      "venue" : null,
      "citeRegEx" : "Moskewicz et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Moskewicz et al\\.",
      "year" : 2001
    }, {
      "title" : "On the hardness of approximate reasoning",
      "author" : [ "D. Roth" ],
      "venue" : "Art. Intelligence",
      "citeRegEx" : "Roth,? \\Q1996\\E",
      "shortCiteRegEx" : "Roth",
      "year" : 1996
    }, {
      "title" : "A new and complete refinement-based approach to Boolean satisfiability",
      "author" : [ "G. Redelinghuys", "J. Geldenhuys" ],
      "venue" : "unpublished manuscript",
      "citeRegEx" : "RG",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Sets with cardinality constraints in satisfiability modulo theories",
      "author" : [ "SSK] P. Suter", "R. Steiger", "V. Kuncak" ],
      "venue" : "LNCS 6538,",
      "citeRegEx" : "Suter et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Suter et al\\.",
      "year" : 2011
    }, {
      "title" : "The complexity of enumeration and reliability problems",
      "author" : [ "L.G. Valiant" ],
      "venue" : "SIAM J. Comput",
      "citeRegEx" : "Valiant,? \\Q1979\\E",
      "shortCiteRegEx" : "Valiant",
      "year" : 1979
    }, {
      "title" : "Exact algorithms for finding minimum transversals in rank 3 hypergraphs",
      "author" : [ "M. Wahlström" ],
      "venue" : "Journal of Algorithms",
      "citeRegEx" : "Wahlström,? \\Q2004\\E",
      "shortCiteRegEx" : "Wahlström",
      "year" : 2004
    }, {
      "title" : "Enumeration of Enumeration Algorithms",
      "author" : [ "K. Wasa" ],
      "venue" : "arXiv: 1605.05102vl",
      "citeRegEx" : "Was",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Generating all cycles, chordless cycles and Hamiltonian cycles with the principle of exclusion",
      "author" : [ "M. Wild" ],
      "venue" : "J. Discrete Algorithms",
      "citeRegEx" : "Wild,? \\Q2008\\E",
      "shortCiteRegEx" : "Wild",
      "year" : 2008
    }, {
      "title" : "Compactly generating all satisfying truth assignments of a Horn formula",
      "author" : [ "M. Wild" ],
      "venue" : "J. Satisf. Boolean Model. Comput",
      "citeRegEx" : "Wild,? \\Q2012\\E",
      "shortCiteRegEx" : "Wild",
      "year" : 2012
    }, {
      "title" : "Computing the output distribution and selection probabilities of a stack filter from the DNF of its positive Boolean function",
      "author" : [ "M. Wild" ],
      "venue" : "J. Math. Imaging Vision",
      "citeRegEx" : "Wild,? \\Q2013\\E",
      "shortCiteRegEx" : "Wild",
      "year" : 2013
    }, {
      "title" : "Output-polynomial enumeration of all fixed-cardinality ideals of a poset, respectively all fixed-cardinality subtrees of a tree. Order",
      "author" : [ "M. Wild" ],
      "venue" : null,
      "citeRegEx" : "Wild,? \\Q2014\\E",
      "shortCiteRegEx" : "Wild",
      "year" : 2014
    }, {
      "title" : "Counting or producing all fixed cardinality transversals",
      "author" : [ "M. Wild" ],
      "venue" : "Algorithmica",
      "citeRegEx" : "Wild,? \\Q2014\\E",
      "shortCiteRegEx" : "Wild",
      "year" : 2014
    }, {
      "title" : "Coupon collecting and transversals of hypergraphs",
      "author" : [ "M. Wild", "S. Janson", "S. Wagner", "D. Laurie" ],
      "venue" : "Discrete Math. Theor. Comput. Sci",
      "citeRegEx" : "Wild et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Wild et al\\.",
      "year" : 2013
    } ],
    "referenceMentions" : [ {
      "referenceID" : 10,
      "context" : "In the last fifty years a variety of such “enumeration problems” have been considered [Was].",
      "startOffset" : 86,
      "endOffset" : 91
    }, {
      "referenceID" : 0,
      "context" : "Some immediate relations among ESOP, ESOFT, CNF, DNNF (see [D]) and BDD are discussed in 6.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 6,
      "context" : "acknowledge the rôle of Redelinghuys and Geldenhuys [RG].",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "7 in [FG]: All R many k-hitting sets of a rank 3 hypergraph H can be enumerated in time O(3k · k · ||H||) where ||H|| := w + Σ{|X| : X ∈ H}.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 2,
      "context" : "provided by [K].",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 0,
      "context" : "That follows9 at once from the definition [D] of DNNF which postulates a disjointness property akin to the definition of “fancy term” in (a).",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 6,
      "context" : "This inspired Gideon Redelinghuys and Jaco Geldenhuys [RG] to carry over the e-framework from positive to arbitrary Boolean CNF’s, in order to determine their satisfiability; they called their method SATEalgorithm.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 6,
      "context" : "Not knowing any technical details16 of the C implementation of the SATE algorithm in [RG], I went back to the drawing board.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 6,
      "context" : "Whatever they are, a glimpse at [RG] shows that e.",
      "startOffset" : 32,
      "endOffset" : 36
    }, {
      "referenceID" : 2,
      "context" : "But then again this assessment may be due to the author’s misconception that nobody has yet topped Knuth’s lovely (though not on the discussed issue) introduction [K] to BDD’s.",
      "startOffset" : 163,
      "endOffset" : 166
    } ],
    "year" : 2016,
    "abstractText" : "For most branching algorithms in Boolean logic “branching” means “variable-wise branching”. We present the apparently novel technique of clause-wise branching, which is used to solve the ALLSAT problem for arbitrary Boolean functions in CNF format. Specifically, it converts a CNF into an orthogonal DNF, i.e. into an exclusive sum of products. Our method is enhanced by two ingredients: The use of a good SAT-solver and wildcards beyond the common don’t-care symbol.",
    "creator" : "LaTeX with hyperref package"
  }
}