{
  "name" : "1506.02188.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Risk-Sensitive and Robust Decision-Making: a CVaR Optimization Approach",
    "authors" : [ "Yinlam Chow", "Aviv Tamar", "Shie Mannor", "Marco Pavone" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Decision making within the Markov decision process (MDP) framework typically involves the minimization of a risk-neutral performance objective, namely the expected total discounted cost [3]. This approach, while very popular, natural, and attractive from a computational standpoint, neither takes into account the variability of the cost (i.e., fluctuations around the mean), nor its sensitivity to modeling errors, which may significantly affect overall performance [12]. Risk-sensitive MDPs [9] address the first aspect by replacing the risk-neutral expectation with a risk-measure of the total discounted cost, such as variance, Value-at-Risk (VaR), or Conditional-VaR (CVaR). Robust MDPs [15], on the other hand, address the second aspect by defining a set of plausible MDP parameters, and optimize decision with respect to the worst-case scenario.\nIn this work we consider risk-sensitive MDPs with a CVaR objective, referred to as CVaR MDPs. CVaR [1, 19] is a risk-measure that is rapidly gaining popularity in ∗Institute of Computational & Mathematical Engineering, Stanford University. Stanford CA, USA 94305 †Electrical Engineering Department, The Technion - Israel Institute of Technology, Haifa, Israel 32000 ‡Electrical Engineering Department, The Technion - Israel Institute of Technology, Haifa, Israel 32000 §Aeronautics and Astronautics Department, Stanford University, Stanford CA, USA 94305\nar X\niv :1\n50 6.\n02 18\n8v 1\n[ cs\n.A I]\n6 J\nun 2\nvarious engineering applications, e.g., finance, due to its favorable computational properties [1] and superior ability to safeguard a decision maker from the “outcomes that hurt the most” [21]. In this paper, by relating risk to robustness, we derive a novel result that further motivates the usage of a CVaR objective in a decision-making context. Specifically, we show that the CVaR of a discounted cost in an MDP is equivalent to the expected value of the same discounted cost in presence of worst-case perturbations of the MDP parameters (specifically, transition probabilities), provided that such perturbations are within a certain error budget. This result suggests CVaR MDP as a method for decision making under both cost variability and model uncertainty, motivating it as unified framework for planning under uncertainty.\nLiterature review: Risk-sensitive MDPs have been studied for over four decades, with earlier efforts focusing on exponential utility [9], mean-variance [23], and percentile risk criteria [7] . Recently, for the reasons explained above, several authors have investigated CVaR MDPs [19]. Specifically, in [4], the authors propose a dynamic programming algorithm for finite-horizon risk-constrained MDPs where risk is measured according to CVaR. The algorithm is proven to asymptotically converge to an optimal risk-constrained policy. However, the algorithm involves computing integrals over continuous variables (Algorithm 1 in [4]) and, in general, its implementation appears particularly difficult. In [2], the authors investigate the structure of CVaR optimal policies and show that a Markov policy is optimal on an augmented state space, where the additional (continuous) state variable is represented by the running cost. In [8], the authors leverage such result to design an algorithm for CVaR MDPs that relies on discretizing occupation measures in the augmented-state MDP. This approach, however, involves solving a non-convex program via a sequence of linear-programming approximations, which can only shown to converge asymptotically. A different approach is taken by [5] and [24], which consider a finite dimensional parameterization of control policies, and show that a CVaR MDP can be optimized to a local optimum using stochastic gradient descent (policy gradient). A recent result by Pflug and Pichler [17] showed that CVaR MDPs admit a dynamic programming formulation by using a state-augmentation procedure different from the one in [2]. The augmented state is also continuous, making the design of a solution algorithm challenging.\nContributions: The contribution of this paper is twofold. First, as discussed above, we provide a novel interpretation for CVaR MDPs in terms of robustness to modeling errors. This result is of independent interest and further motivates the usage of CVaR MDPs for decision making under uncertainty. Second, we provide a new optimization algorithm for CVaR MDPs, which leverages the state augmentation procedure introduced by Pflug and Pichler [17]. We overcome the aforementioned computational challenges (due to the continuous augmented state) by designing an algorithm that merges approximate value iteration [3] with linear interpolation. Remarkably, we are able to provide explicit error bounds and convergence rates based on contraction-style arguments. In comparison to the algorithms in [4, 8, 5, 24], our approach leads to finite-time error guarantees, with respect to the globally optimal policy. In addition, our algorithm is significantly simpler than previous methods, and calculates the optimal policy for all CVaR confidence intervals and initial states simultaneously. The practicality of our approach is demonstrated in numerical experiments involving planning a path on a grid with thousand of states. To the best of our knowledge, this is the\nfirst algorithm to compute globally-optimal policies for non-trivial CVaR MDPs. Organization: This paper is structured as follows. In Section 2 we provide background on CVaR and MDPs, we state the problem we wish to solve (i.e., CVaR MDPs), and motivate the CVaR MDP formulation by establishing a novel relation between CVaR and model perturbations. Section 3 provides the basis for our solution algorithm, based on a Bellman-style equation for the CVaR. Then, in Section 4 we present our algorithm and correctness analysis. in Section 5 we evaluate our approach via numerical experiments. Finally, in Section 6, we draw some conclusions and discuss directions for future work."
    }, {
      "heading" : "2 Preliminaries, Problem Formulation, and Motivation",
      "text" : ""
    }, {
      "heading" : "2.1 Conditional Value-at-Risk",
      "text" : "Let Z be a bounded-mean random variable, i.e., E[|Z|] < ∞, on a probability space (Ω,F ,P), with cumulative distribution function F (z) = P(Z ≤ z). In this paper we interpret Z as a cost. The value-at-risk (VaR) at confidence level α ∈ (0, 1) is the 1−α quantile of Z, i.e., VaRα(Z) = min { z | F (z) ≥ α } . The conditional value-at-risk (CVaR) at confidence level α ∈ (0, 1) is defined as [19]:\nCVaRα(Z) = min w∈R\n{ w + 1 α E [ (Z − w)+ ]} , (1)\nwhere (x)+ = max(x, 0) represents the positive part of x. If there is no probability atom at VaRα(Z), it is well known that CVaRα(Z) = E [ Z | Z ≥ VaRα(Z) ] . Therefore, CVaRα(Z) may be interpreted as the worst case expected value of Z, conditioned on the α-portion of the tail distribution. It is well known that CVaRα(Z) is decreasing in α, CVaR1(Z) equals to E(Z), and CVaRα(Z) tends to max(Z) as α ↓ 0. During the last decade, the CVaR risk-measure has gained popularity in financial applications, among others. It is especially useful for controlling rare, but potentially disastrous events, which occur below the 1− α quantile, and are neglected by the VaR [21]. Furthermore, CVaR enjoys desirable axiomatic properties, such as coherence [1]. We refer to [25] for further motivation about CVaR and a comparison with other risk measures such as VaR.\nA useful property of CVaR, which we exploit in this paper, is its alternative dual representation [1]:\nCVaRα(Z) = max ξ∈UCVaR(α,P) Eξ[Z], (2)\nwhere Eξ[Z] denotes the ξ-weighted expectation of Z, and the risk envelop UCVaR is given by UCVaR(α,P) = { ξ : ξ(ω) ∈ [ 0, 1α ] , ∫ ω∈Ω ξ(ω)P(ω)dω = 1 } . Thus, the\nCVaR of a random variable Z may be interpreted as the worst-case expectation of Z, under a perturbed distribution ξP.\nIn this paper, we are interested in the CVaR of the total discounted cost in a sequential decision-making setting, as discussed next."
    }, {
      "heading" : "2.2 Markov Decision Processes",
      "text" : "An MDP is a tuple M = (X ,A, C, P, x0, γ), where X and A are finite state and action spaces; C(x, a) ∈ [−Cmax, Cmax] is a bounded deterministic cost; P (·|x, a) is the transition probability distribution; γ ∈ [0, 1) is the discounting factor, and x0 is the initial state. (Our results easily generalize to random initial states and random costs.)\nLet the space of admissible histories up to time t beHt = Ht−1×X , for t ≥ 1, and H0 = X . A generic element ht ∈ Ht is of the form ht = (x0, a0, . . . , xt−1, at−1, xt). Let ΠH,t be the set of all deterministic history-dependent policies with the property that at each time t the control is a function of ht. In other words, ΠH,t := { µ0 : H0 →\nA, µ1 : H1 → A, . . . , µt : Ht → A}|µj(hj) ∈ A for all hj ∈ Hj , 1 ≤ j ≤ t }\n. We also let ΠH = limt→∞ΠH,t be the set of all history dependent policies."
    }, {
      "heading" : "2.3 Problem Formulation",
      "text" : "Let the sequence of random variables Zt denote the stage-wise costs observed along a state/control trajectory in the MDP model, and let C0,T = ∑T t=0 γ\ntZt denote the total discounted cost up to time T . The risk-sensitive discounted-cost problem we wish to address is as follows:\nmin µ∈ΠH\nCVaRα (\nlim T→∞\nC0,T ∣∣∣x0, µ) , (3)\nwhere µ = {µ0, µ1, . . .} is the policy sequence with actions at = µt(ht) for t ∈ {0, 1, . . .}. We refer to problem (3) as CVaR MDP. (One may also consider a related formulation combining mean and CVaR, the details of which are presented in the supplementary material.)\nThe problem formulation in (3) directly addresses the aspect of risk sensitivity, as demonstrated by the numerous applications of CVaR optimization in finance (see, e.g., [20, 11, 6]) and the recent approaches for CVaR optimization in MDPs [4, 8, 5, 24]. In the following, we show a new result providing additional motivation for CVaR MDPs, from the point of view of robustness to modeling errors."
    }, {
      "heading" : "2.4 Motivation - Robustness to Modeling Errors",
      "text" : "We show a new result relating the CVaR objective in (3) to the worst-case expected discounted-cost in presence of worst-case perturbations of the MDP parameters, where the perturbations are budgeted according to the “number of things that can go wrong.” Thus, by minimizing CVaR, the decision maker also guarantees robustness of the policy.\nConsider a trajectory (x0, . . . , xT ) in a finite-horizon MDP problem with transitions Pt(xt|xt−1). We explicitly denote the time index of the transition matrices for reasons that will become clear shortly. The total probability of the trajectory is P (x0, . . . , xT ) = P0(x0)P1(x1|x0) · · ·PT (xT |xT−1), and we let C0,T (x1, . . . , xT ) denote its discounted cost, as defined above.\nWe consider an adversarial setting, where an adversary is allowed to change the transition probabilities at each stage, under some budget constraints. We will show that, for a specific budget and perturbation structure, the expected cost under the worstcase perturbation is equivalent to the CVaR of the cost. Thus, we shall establish that,\nin this perspective, being risk sensitive is equivalent to being robust against model perturbations.\nFor each stage 1 ≤ t ≤ T , consider a perturbed transition matrix P̂t = Pt ◦ δt, where δt ∈ RX×X is a multiplicative probability perturbation and ◦ is the Hadamard product, under the condition that P̂t is a stochastic matrix. Let ∆t denote the set of perturbation matrices that satisfy this condition, and let ∆ = ∆1 × · · · ×∆T the set of all possible perturbations to the trajectory distribution.\nWe now impose a budget constraint on the perturbations as follows. For some budget η ≥ 1, we consider the constraint\nδ1(x1|x0)δ2(x2|x1) · · · δT (xT |xT−1) ≤ η, ∀x1, . . . , xT ∈ X , t = 0, . . . , T. (4)\nEssentially, the product in Eq. (4) states that the worst cannot happen at each time. Instead, the perturbation budget has to be split (multiplicatively) along the trajectory. We note that Eq. (4) is in fact a constraint on the perturbation matrices, and we denote by ∆η ⊂ ∆ the set of perturbations that satisfy this constraint with budget η. The following result shows an equivalence between the CVaR and the worst-case expected loss.\nProposition 1 (Interpretation of CVaR as a Robustness Measure) It holds\nCVaR 1 η (C0,T (x1, . . . , xT )) = sup (δ1,...,δT )∈∆η EP̂ [C0,T (x1, . . . , xT )] , (5)\nwhere EP̂ [·] denotes expectation with respect to a Markov chain with transitions P̂t.\nThe proof of Proposition 1 is in the supplementary material. It is instructive to compare Proposition 1 with the dual representation of CVaR in (2). Note, in particular, that the perturbation budget in Proposition 1 has a temporal structure, which constrains the adversary from choosing the worst perturbation at each time step.\nRemark 1 An equivalence between robustness and risk-sensitivity was previously suggested by Osogami [16]. In that study, the iterated (dynamic) coherent risk was shown to be equivalent to a robust MDP [10] with a rectangular uncertainty set. The iterated risk (and, correspondingly, the rectangular uncertainty set) is very conservative [26], in the sense that the worst can happen at each time step. In contrast, the perturbations considered here are much less conservative. In general, solving robust MDPs without the rectangularity assumption is NP-hard. Nevertheless, Mannor et. al. [13] showed that, for cases where the number of perturbations to the parameters along a trajectory is upper bounded (budget-constrained perturbation), the corresponding robust MDP problem is tractable. Analogous to the constraint set (1) in [13], the perturbation set in Proposition 1 limits the total number of log-perturbations along a trajectory. Accordingly, we shall later see that optimizing problem (3) with perturbation structure (4) is indeed also tractable.\nNext section provides the fundamental theoretical ideas behind our approach to the solution of (3)."
    }, {
      "heading" : "3 Bellman Equation for CVaR",
      "text" : "In this section, by leveraging a recent result from [17], we present a dynamic programming (DP) formulation for the CVaR MDP problem in (3). As we shall see, the value function in this formulation depends on both the state and the CVaR confidence level α. We then establish important properties of such DP formulation, which will later enable us to derive an efficient DP-based approximate solution algorithm and provide correctness guarantees on the approximation error. All proofs are presented in the supplementary material.\nOur starting point is a recursive decomposition of CVaR, whose proof is detailed in Theorem 10 of [17].\nTheorem 2 (CVaR Decomposition Theorem, [17]) For any t ≥ 0, denote by Z = (Zt+1, Zt+2, . . . ) the cost sequence from time t + 1 onwards. The conditional CVaR under policy µ, i.e., CVaRα(Z | Ht, µ), obeys the following decomposition:\nCVaRα(Z | Ht, µ) = max ξ∈UCVaR(α,P (·|xt,at)) E[ξ(xt+1)·CVaRαξ(xt+1)(Z | Ht+1, µ) | Ht, µ],\nwhere at is the action induced by policy µt(ht), and the expectation is with respect to xt+1. Theorem 2 concerns a fixed policy µ; we now extend it to a general DP formulation. Note that in the recursive decomposition in Theorem 2 the right-hand side involves CVaR terms with different confidence levels than that in the left-hand side. Accordingly, we augment the state space X with an additional continuous state Y = (0, 1], which corresponds to the confidence level. For any x ∈ X and y ∈ Y , the valuefunction V (x, y) for the augmented state (x, y) is defined as:\nV (x, y) = min µ∈ΠH\nCVaRy (\nlim T→∞\nC0,T | x0 = x, µ ) .\nSimilar to standard DP, it is convenient to work with operators defined on the space of value functions [3]. In our case, Theorem 2 leads to the following definition of CVaR Bellman operator T : X × Y → X × Y:\nT[V ](x, y) = min a∈A\n[ C(x, a) + γ max\nξ∈UCVaR(y,P (·|x,a)) ∑ x′∈X ξ(x′)V (x′, yξ(x′))P (x′|x, a)\n] .\n(6) We now establish several useful properties for the Bellman operator T[V ].\nLemma 3 (Properties of CVaR Bellman Operator) The Bellman operator T[V ] has the following properties:\n1. (Contraction.) ‖T[V1]−T[V2]‖∞ ≤ γ‖V1−V2‖∞,where ‖f‖∞=supx∈X ,y∈Y |f(x, y)|.\n2. (Concavity preserving in y.) For any x ∈ X , suppose yV (x, y) is concave in y ∈ Y . Then the maximization problem in (6) is concave. Furthermore, yT[V ](x, y) is concave in y.\nThe first property in Lemma 3 is similar to standard DP [3], and is instrumental to the design of a converging value-iteration approach. The second property is nonstandard and specific to our approach. It will be used to show that the computation of value-iteration updates involves concave, and therefore tractable optimization problems. Furthermore, it will be used to show that a linear-interpolation of V (x, y) in the augmented state y has a bounded error.\nEquipped with the results in Theorem 2 and Lemma 3, we can now show that the fixed point solution of T[V ](x, y) = V (x, y) is unique, and equals to the solution of the CVaR MDP problem (3) with x0 = x and α = y.\nTheorem 4 (Optimality Condition) For any x ∈ X and y ∈ (0, 1], the solution to T[V ](x, y) = V (x, y) is unique, and equals to V ∗(x, y) = minµ∈ΠH CVaRy (limT→∞ C0,T | x0 = x, µ). Next, we show that the optimal value of the CVaR MDP problem (3) can be attained by a stationary Markov policy, defined as a greedy policy with respect to the value function V ∗(x, y). Thus, while the original problem is defined over the intractable space of history-dependent policies, a stationary Markov policy (over the augmented state space) is optimal, and can be readily derived from V ∗(x, y). Furthermore, an optimal history-dependent policy can be readily obtained from an (augmented) optimal Markov policy according to the following theorem.\nTheorem 5 (Optimal Policies) Let π∗H = {µ0, µ1, . . .} ∈ ΠH be a history-dependent policy recursively defined as:\nµk(hk) = u ∗(xk, yk), ∀k ≥ 0, (7)\nwith initial conditions x0 and y0 = α, and state transitions\nxk ∼ P (· | xk−1, u∗(xk−1, yk−1)), yk = yk−1ξ∗xk−1,yk−1,u∗(xk),∀k ≥ 1, (8)\nwhere the stationary Markovian policy u∗(x, y) and risk factor ξ∗x,y,u∗(·) are solution to the min-max optimization problem in the CVaR Bellman operator T[V ∗](x, y). Then, π∗H is an optimal policy for problem (3) with initial state x0 and CVaR confidence level α.\nTheorems 4 and 5 suggest that a value-iteration DP method [3] can be used to solve the CVaR MDP problem (3). Let an initial value-function guess V0 : X × Y → R be chosen arbitrarily. Value iteration proceeds recursively as follows:\nVk+1(x, y) = T[Vk](x, y), ∀(x, y) ∈ X × Y, k ∈ {0, 1, . . . , }. (9)\nSpecifically, by combining the contraction property in Lemma 3 and uniqueness result of fixed point solutions from Theorem 4, one concludes that limk→∞ Vk(x, y) = V ∗(x, y). By selecting x = x0 and y = α, one immediately obtains V ∗(x0, α) = minµ∈ΠH CVaRα (limT→∞ C0,T | x0, µ). Furthermore, an optimal policy may be derived from V ∗(x, y) according to the policy construction procedure in Theorem 5.\nUnfortunately, while value iteration is conceptually appealing, its direct implementation in our setting is generally impractical since, e.g., the state y is continuous. In the following, we pursue an approximation to the value iteration algorithm (9), based on a linear interpolation scheme for y.\nAlgorithm 1 CVaR Value Iteration with Linear Interpolation"
    }, {
      "heading" : "1: Given:",
      "text" : "• N(x) interpolation points Y(x) = { y1, . . . , yN(x) } ∈ [0, 1]N(x) for every x ∈\nX with yi < yi+1, y1 = 0 and yN(x) = 1.\n• Initial value function V0(x, y) that satisfies Assumption 1."
    }, {
      "heading" : "2: For t = 1, 2, . . .",
      "text" : "• For each x ∈ X and each yi ∈ Y(x), update the value function estimate as follows:\nVt(x, yi) = TI [Vt−1](x, yi),\n3: Set the converged value iteration estimate as V̂ ∗(x, yi), for any x ∈ X , and yi ∈ Y(x)."
    }, {
      "heading" : "4 Value Iteration with Linear Interpolation",
      "text" : "In this section we present an approximate DP algorithm for solving CVaR MDPs, based on the theoretical results of Section 3. The value iteration algorithm in Eq. (9) presents two main implementation challenges. The first is due to the fact that the augmented state y is continuous. We handle this challenge by using interpolation, and exploit the concavity of yV (x, y) to bound the error introduced by this procedure. The second challenge stems from the the fact that applying T involves maximizing over ξ. Our strategy is to exploit the concavity of the maximization problem to guarantee that such optimization can indeed be performed effectively.\nAs discussed, our approach relies on the fact that the Bellman operator T preserves concavity as established in Lemma 3. Accordingly, we require the following assumption for the initial guess V0(x, y),\nAssumption 1 The guess for the initial value function V0(x, y) satisfies the following properties: 1) yV0(x, y) is concave in y ∈ Y and 2) V0(x, y) is continuous in y ∈ Y for any x ∈ X .\nAssumption 1 may easily be satisfied, for example, by choosing V0(x, y) = CVaRy(Z | x0 = x), where Z is any arbitrary bounded random variable. As stated earlier, a key difficulty in applying value iteration (9) is that, for each state x ∈ X , the Bellman operator has to be calculated for each y ∈ Y , and Y is continuous. As an approximation, we propose to calculate the Bellman operator only for a finite set of values y, and interpolate the value function in between such interpolation points.\nFormally, let N(x) denote the number of interpolation points. For every x ∈ X , denote by Y(x) = { y1, . . . , yN(x) } ∈ [0, 1]N(x) the set of interpolation points. We denote by Ix[V ](y) the linear interpolation of the function yV (x, y) on these points, i.e.,\nIx[V ](y) = yiV (x, yi) + yi+1V (x, yi+1)− yiV (x, yi)\nyi+1 − yi (y − yi),\nwhere yi = max {y′ ∈ Y(x) : y′ ≤ y}. The interpolation of yV (x, y) instead of V (x, y) is key to our approach. The motivation is twofold: first, it can be shown [19] that for a discrete random variable Z, yCVaRy(Z) is piecewise linear in y. Second, one can show that the Lipschitzness of y V (x, y) is preserved during value iteration, and exploit this fact to bound the linear interpolation error.\nWe now define the interpolated Bellman operator TI as follows:\nTI [V ](x, y) = min a∈A\n[ C(x, a) + γ max\nξ∈UCVaR(y,P (·|x,a)) ∑ x′∈X Ix′ [V ](yξ(x′)) y P (x′|x, a)\n] . (10)\nRemark 2 Notice that by L’Hospital’s rule one has limy→0 Ix[V ](yξ(x))/y = V (x, 0)ξ(x). This implies that at y = 0 the interpolated Bellman operator is equivalent to the original Bellman operator, i.e., T[V ](x, 0) = mina∈A { C(x, a) + γmaxx′∈X :P (x′|x,a)>0 V (x ′, 0) }\n= TI [V ](x, 0).\nAlgorithm 1 presents CVaR value iteration with linear interpolation. The only difference between this algorithm and standard value iteration (9) is the linear interpolation procedure described above. In the following, we show that Algorithm 1 converges, and bound the error due to interpolation. We begin by showing that the useful properties established in Lemma 3 for the Bellman operator T extend to the interpolated Bellman operator TI .\nLemma 6 (Properties of Interpolated Bellman Operator) TI [V ] has the same properties of T[V ] as in Lemma 3, namely 1) contraction and 2) concavity preservation.\nLemma 6 implies several important consequences for Algorithm 1. The first one is that the maximization problem in (10) is concave, and thus may be solved efficiently at each step. This guarantees that the algorithm is tractable. Second, the contraction property in Lemma 6 guarantees that Algorithm 1 converges, i.e., there exists a value function V̂ ∗ ∈ R|X |×|Y| such that limn→∞TnI [V0](x, yi) = V̂ ∗(x, yi). In addition, the convergence rate is geometric and equals to γ.\nThe following theorem provides an error bound between approximate value iteration and exact value iteration (3) in terms of the interpolation resolution.\nTheorem 7 (Convergence and Error Bound) Suppose the initial value function V0(x, y) satisfies Assumption 1 and let > 0 be an error tolerance parameter. For any state x ∈ X and step t ≥ 0, choose y2 > 0 such that Vt(x, y2)− Vt(x, 0) ≥ − and update the interpolation points according to the logarithmic rule: yi+1 = θyi, ∀i ≥ 2, with uniform constant θ ≥ 1. Then, Algorithm 1 has the following error bound:\n0 ≥ V̂ ∗(x0, α)− min µ∈ΠH\nCVaRα (\nlim T→∞\nC0,T | x0, µ ) ≥ −γ\n1− γO ((θ − 1) + ) ,\nand the following finite time convergence error bound:∣∣∣∣TnI [V0](x0, α)− minµ∈ΠH CVaRα ( lim T→∞ C0,T | x0, µ )∣∣∣∣ ≤ O ((θ − 1) + ) +O(γn)1− γ .\nTheorem 7 shows that 1) the interpolation-based value function is a conservative estimate for the optimal solution to problem (3); 2) the interpolation procedure is consistent, i.e., when the number of interpolation points is arbitrarily large (specifically, → 0 and yi+1/yi → 1), the approximation error tends to zero; and 3) the approximation error bound is O((θ−1)+ ), where log θ is the log-difference of the interpolation points, i.e., log θ = log yi+1 − log yi, ∀i.\nFor a pre-specified , the condition Vt(x, y2) − Vt(x, 0) ≥ − may be satisfied by a simple adaptive procedure for selecting the interpolation points Y(x). At each iteration t > 0, after calculating Vt(x, yi) in Algorithm 1, at each state x in which the condition does not hold, add a new interpolation point y′2 = y2 |Vt(x,y2)−Vt(x,0)| , and additional points between y′2 and y2 such that the condition log θ ≥ log yi+1 − log yi is maintained. Since all the additional points belong to the segment [y1, y2], the linearly interpolated Vt(x, yi) remains unchanged, and Algorithm 1 proceeds as is. For bounded costs and > 0, the number of additional points required is bounded.\nThe full proof of Theorem 7 is detailed in the supplementary material; we highlight the main ideas and challenges involved. In the first part of the proof we bound, for all t > 0, the Lipschitz constant of yVt(x, y) in y. The key to this result is to show that the Bellman operator T preserves the Lipschitz property for yVt(x, y). Using the Lipschitz bound and the concavity of yVt(x, y), we then bound the error Ix[Vt](y) y − Vt(x, y) for all y. The condition on y2 is required for this bound to hold when y → 0. Finally, we use this result to bound ‖TI [Vt](x, y)−T[Vt](x, y)‖∞. The results of Theorem 7 follow from contraction arguments, similar to approximate dynamic programming [3]."
    }, {
      "heading" : "5 Experiments",
      "text" : "We validate Algorithm 1 on a rectangular grid world, where states represent grid points on a 2D terrain map. An agent (e.g., a robotic vehicle) starts in a safe region and its objective is to travel to a given destination. At each time step the agent can move to any of its four neighboring states. Due to sensing and control noise, however, with probability δ a move to a random neighboring state occurs. The stage-wise cost of each move until reaching the destination is 1, to account for fuel usage. In between the starting point and the destination there are a number of obstacles that the agent should avoid. Hitting an obstacle costs M >> 1 and terminates the mission. The objective is to compute a safe (i.e., obstacle-free) path that is fuel efficient.\nFor our experiments, we choose a 64 × 53 grid-world (see Figure 1), for a total of 3,312 states. The destination is at position (60, 2), and there are 80 obstacles plotted in yellow. By leveraging Theorem 7, we use 21 log-spaced interpolation points for Algorithm 1 in order to achieve a small value function error. We choose δ = 0.05, and a discount factor γ = 0.95 for an effective horizon of 200 steps. Furthermore, we set the penalty cost equal to M = 2/(1 − γ)–such choice trades off high penalty for collisions and computational complexity (that increases as M increases).\nIn Figure 1 we plot the value function V (x, y) for three different values of the CVaR confidence parameter α, and the corresponding paths starting from the initial position (60, 50). The first three figures in Figure 1 show how by decreasing the confidence parameter α the average travel distance (and hence fuel consumption) slightly increases but the collision probability decreases, as expected. We next discuss robust-\nness to modeling errors. We conducted simulations in which with probability 0.5 each obstacle position is perturbed in a random direction to one of the neighboring grid cells. This emulates, for example, measurement errors in the terrain map. We then trained both the risk-averse (α = 0.11) and risk-neutral (α = 1) policies on the nominal (i.e., unperturbed) terrain map, and evaluated them on 400 perturbed scenarios (20 perturbed maps with 20 Monte Carlo evaluations each). While the risk-neutral policy finds a shorter route (with average cost equal to 18.137 on successful runs), it is vulnerable to perturbations and fails more often (with over 120 failed runs). In contrast, the risk-averse policy chooses slightly longer routes (with average cost equal to 18.878 on successful runs), but is much more robust to model perturbations (with only 5 failed runs).\nFor the computation of Algorithm 1 we represented the concave piecewise linear maximization problem in (10) as a linear program, and concatenated several problems to reduce repeated overhead stemming from the initialization of the CPLEX linear programming solver. This resulted in a computation time on the order of two hours. We believe there is ample room for improvement, for example by leveraging parallelization and sampling-based methods. Overall, we believe our proposed approach is currently the most practical method available for solving CVaR MDPs (as a comparison, the recently proposed method in [8] involves infinite dimensional optimization). The Matlab code used for the experiments is provided in the supplementary material."
    }, {
      "heading" : "6 Conclusion",
      "text" : "In this paper we presented an algorithm for CVaR MDPs, based on approximate valueiteration on an augmented state space. We established convergence of our algorithm, and derived finite-time error bounds. These bounds are useful to stop the algorithm at a desired error threshold.\nIn addition, we uncovered an interesting relationship between the CVaR of the total cost and the worst-case expected cost under adversarial model perturbations. In this formulation, the perturbations are correlated in time, and lead to a robustness framework significantly less conservative than the popular robust-MDP framework, where the uncertainty is temporally independent.\nCollectively, our work suggests CVaR MDPs as a unifying and practical framework for computing control policies that are robust with respect to both stochasticity\nand model perturbations. Future work should address extensions to large state-spaces. We conjecture that a sampling-based approximate DP approach [3] should be feasible since, as proven in this paper, the CVaR Bellman equation is contracting (as required by approximate DP methods)."
    }, {
      "heading" : "A Proofs of Theoretical Results",
      "text" : ""
    }, {
      "heading" : "A.1 Proof of Proposition 1",
      "text" : "By definition, we have that\nEP̂ [C(x1, . . . , xT )] = ∑\n(x1,...,xT )\nP1(x1)δ1(x1) · · ·PT (xT |xT−1)δT (xT |xT−1)C(x1, . . . , xT )\n= ∑\n(x1,...,xT )\nP (x1, . . . , xT )δ1(x1)δ2(x2|x1) · · · δT (xT |xT−1)C(x1, . . . , xT )\n. = ∑ (x1,...,xT ) P (x1, . . . , xT )δ(x1, . . . , xT )C(x1, . . . , xT ).\nNote that by definition of the set ∆, for any (δ1, . . . , δT ) ∈ ∆ we have thatP (x1, . . . , xT ) > 0→ δ(x1, . . . , xT ) ≥ 0, and\nE [δ(x1, . . . , xT )] . = ∑ (x1,...,xT ) P (x1, . . . , xT )δ(x1, . . . , xT ) = 1.\nThus,\nsup (δ1,...,δT )∈∆η EP̂ [C(x1, . . . , xT )] = sup 0≤δ(x1,...,xT )≤η, E[δ(x1,...,xT )]=1 ∑ (x1,...,xT ) P (x1, . . . , xT )δ(x1, . . . , xT )C(x1, . . . , xT )\n= CVaR 1 η (C(x1, . . . , xT )) ,\nwhere the last equality is by the representation theorem for CVaR [22]."
    }, {
      "heading" : "A.2 Proof of Lemma 3",
      "text" : "The proof of monotonicity and constant shift properties follow directly from the definitions of the Bellman operator, by noting that ξ(x′)P (x′|x, a) is non-negative and∑ x′∈X ξ(x\n′)P (x′|x, a)] = 1 for any ξ ∈ UCVaR(y, P (·|x, a)). For the contraction property, denote c = ‖V1 − V2‖∞. Since\nV2(x, y)− ‖V1 − V2‖∞ ≤ V1(x, y) ≤ V2(x, y) + ‖V1 − V2‖∞, ∀x ∈ X , y ∈ Y,\nby monotonicity and constant shift property,\nT[V2](x, y)−γ‖V1−V2‖∞ ≤ T[V1](x, y) ≤ T[V2](x, y)+γ‖V1−V2‖∞ ∀x ∈ X , y ∈ Y.\nThis further implies that\n|T[V1](x, y)−T[V2](x, y)| ≤ γ‖V1 − V2‖∞ ∀x ∈ X , y ∈ Y\nand the contraction property follows.\nNow, we prove the concavity preserving property. Assume that yV (x, y) is concave in y for any x ∈ X . Let y1, y2 ∈ Y , and λ ∈ [0, 1], and define yλ = (1− λ)y1 + λy2. We have\n(1− λ)y1T[V ](x, y1) + λy2T[V ](x, y2)\n=(1− λ)y1 min a1∈A\n[ C(x, a1) + γ max\nξ1∈UCVaR(y1,P (·|x,a1)) ∑ x′∈X ξ1(x ′)V (x′, y1ξ1(x ′))P (x′|x, a1)\n]\n+ λy2 min a2∈A\n[ C(x, a2) + γ max\nξ2∈UCVaR(y2,P (·|x,a2)) ∑ x′∈X ξ2(x ′)V (x′, y2ξ2(x ′))P (x′|x, a2)\n]\n= min a1∈A\n[ (1− λ)y1C(x, a1) + γ max\nξ1∈UCVaR(y1,P (·|x,a1)) ∑ x′∈X ξ1(x ′)V (x′, y1ξ1(x ′))P (x′|x, a1)(1− λ)y1\n]\n+ min a2∈A\n[ λy2C(x, a2) + γ max\nξ2∈UCVaR(y2,P (·|x,a2)) ∑ x′∈X ξ2(x ′)V (x′, y2ξ2(x ′))P (x′|x, a2)λy2\n]\n≤min a∈A yλC(x, a) + γ max ξ1∈UCVaR(y1,P (·|x,a)) ξ2∈UCVaR(y2,P (·|x,a)) ∑ x′∈X P (x′|x, a) ((1−λ)y1ξ1(x′)V (x′, y1ξ1(x′)) + λy2ξ2(x′)V (x′, y2ξ2(x′)))  ≤min a∈A yλC(x, a) + γ max ξ1∈UCVaR(y1,P (·|x,a)) ξ2∈UCVaR(y2,P (·|x,a)) ∑ x′∈X P (x′|x, a) ((1−λ)y1ξ1(x′)+λy2ξ2(x′))V (x′, ((1−λ)y1ξ1(x′) + λy2ξ2(x′)))\n where the first inequality is by concavity of the min, and the second is by the concavity assumption. Now, define ξ = (1−λ)y1ξ1+λy2ξ2yλ . When ξ1 ∈ UCVaR(y1, P (·|x, a)) and\nξ2 ∈ UCVaR(y2, P (·|x, a)), we have that ξ ∈ [ 0, 1yλ ] and ∑ x′∈X ξ(x\n′)P(x′|x, a) = 1. We thus have\n(1− λ)y1T[V ](x, y1) + λy2T[V ](x, y2)\n≤min a∈A\n[ yλC(x, a) + γ max\nξ∈UCVaR(yλ,P (·|x,a)) ∑ x′∈X P (x′|x, a)yλξ(x′)V (x′, yλξ(x′))\n]\n=yλ min a∈A\n[ C(x, a) + γ max\nξ∈UCVaR(yλ,P (·|x,a)) ∑ x′∈X P (x′|x, a)ξ(x′)V (x′, yλξ(x′))\n] = yλT[V ](x, yλ).\nFinally, to show that the inner problem in (6) is a concave maximization, we need to show that\nΛx,y,a(z) :=\n{ zV (x′, z)P (x′|x, a)/y if y 6= 0\n0 otherwise\nis a concave function in z ∈ R for any given x ∈ X , y ∈ Y and a ∈ A. Suppose zV (x, z) is a concave function in z. Immediately we can see that Λx,y,a(z) is concave in z when y = 0. Also notice that when y ∈ Y \\ {0}, since the transition probability\nP (x′|x, a) is non-negative, we have the result that Λx,y,a(z) is concave in z. This further implies∑\nx′∈X\nP (x′|x, a) y Λx,y,a(yξ(x ′)) = ∑ x′∈X ξ(x′)V (x′, yξ(x′))P (x′|x, a)\nis concave in ξ. Furthermore by combining the result with the fact that the feasible set of ξ is a polytope, we complete the proof of this claim."
    }, {
      "heading" : "A.3 Proof of Theorem 4",
      "text" : "The first part of the proof is to show that for any (x, y) ∈ X × Y ,\nVn(x, y) := T n[V0](x, y)= min µ∈ΠM CVaRy (C0,n + γnV0 | x0 = x, µ) , (11)\nby induction, where the initial condition is (x0, y0) = (x, y) and control action at is induced by µ(xt, yt). For n = 1, we have that V1(x, y) = T[V0](x, y) = minµ∈ΠM C(x0, a0)+ γCVaRy (C(x1, a1) + V0(x1) | x0 = x, µ) from definition. By induction hypothesis, assume the above expression holds at n = k. For n = k + 1,\nVk+1(x, y) := T k+1[V0](x, y) = T[Vk](x, y)\n= min a∈A C(x, a) + γ max ξ∈UCVaR(y,P (·|x,a)) ∑ x′∈X ξ(x′)Vk ( x′, yξ(x′)︸ ︷︷ ︸\ny′\n) P (x′|x, a)  = min a∈A [ C(x, a) + γ max\nξ∈UCVaR(y,P (·|x,a)) ∑ x′∈X ξ(x′)P (x′|x, a) min µ∈ΠM CVaRy′ ( C0,k + γkV0 | x0 = x′, µ\n) ]\n= min a∈A\n[ C(x, a) + max ξ∈UCVaR(y,P (·|x,a)) Eξ [ min µ∈ΠM CVaRy1 ( C1,k+1 + γk+1V0 | x1, µ ) ]] = min µ∈ΠM CVaRy ( C0,k+1 + γk+1V0 | x0 = x, µ ) ,\n(12)\nwhere the initial state condition is given by (x0, y0) = (x, y). Thus, the equality in (11) is proved by induction.\nThe second part of the proof is to show that V ∗(x0, y0)=minµ∈ΠM CVaRy0 (limn→∞ C0,n | x0, µ). Recall T[V ](x, y) = mina∈A C(x, a) + γmaxξ∈UCVaR(y,P (·|x,a)) Eξ[V |x, y, a]. Since T is a contraction and V0 is bounded, one obtains\nV ∗(x, y) = T[V ∗](x, y) = lim n→∞ Tn[V0](x, y) = lim n→∞ Vn(x, y)\nfor any (x, y) ∈ X × Y . The first and the second equality follow directly from Proposition 2.1 and Proposition 2.2 in [3] and the third equality follows from the definition of Vn. Furthermore since V0(x, y) is bounded for any (x, y) ∈ X × Y , the result in (12) implies\n− lim n→∞ γn‖V0‖∞ ≤ V ∗(x0, y0)− min µ∈ΠM\nCVaRy0 (\nlim n→∞ C0,n | x0, µ ) ≤ lim n→∞ γn‖V0‖∞.\nTherefore, by taking n → ∞, we have just shown that for any (x0, y0) ∈ X × Y , V ∗(x0, y0) = minµ∈ΠM CVaRy0 (limn→∞ C0,n | x0, µ).\nThe third part of the proof is to show that for the initial state x0 and confidence interval y0, we have that\nV ∗(x0, y0) = min µ∈ΠH\nCVaRy0 (\nlim n→∞\nC0,n | x0, µ ) .\nAt any (xt, yt) ∈ X × Y , we first define the tth tail-subproblem of problem (3) as follows:\nV(xt, yt)= min µ∈ΠH\nCVaRyt (\nlim n→∞\nCt,n | xt, µ )\nwhere the tail policy sequence is equal to µ = {µt, µt+1, . . .} and the action is given by aj = µj(hj) for j ≥ t. For any history depend policy µ̃ ∈ ΠH , we also define the µ̃−induced value function as CVaRyt (limn→∞ Ct,n | xt, µ̃) where µ̃ = {µ̃t, µ̃t+1, . . .} and aj = µ̃j(hj) for j ≥ t.\nNow let µ∗ be the optimal policy of the above tth tail-subproblem. Clearly, the truncated policy µ̃ = {µ∗t+1, µ∗t+2, . . .} is a feasible policy for the (t+ 1)th tail subproblem at any state xt+1 and confidence interval yt+1:\nmin µ∈ΠH\nCVaRyt+1 (\nlim n→∞\nCt+1,n | xt+1, µ ) .\nCollecting the above results, for any pair (xt, yt) ∈ X × Y and with at = µ∗t (xt) we can write\nV(xt, yt) =C(xt, at) + γ max ξ∈UCVaR(yt,P (·|xt,at)) E ξ(xt+1) · CVaRyt+1 ( limn→∞ Ct+1,n | xt+1, µ̃)︸ ︷︷ ︸ Vµ̃(xt+1,yt+1),yt+1=ytξ(xt+1)  ≥C(xt, at)+γ max\nξ∈UCVaR(yt,P (·|xt,at)) Eξ[V(xt+1, ytξ(xt+1)) |xt, yt, at]≥T[V](xt, yt).\nThe first equality follows from the definition of V(xt, yt) and the decomposition of CVaRs (Theorem 2). The first inequality uses the inequality: Vµ̃(x, y) ≥ V(x, y), ∀(x, y) ∈ X × Y . The second inequality follows from the definition of Bellman operator T.\nOn the other hand, starting at any state xt+1 and confidence interval yt+1, let µ∗ = {µ∗t+1, µ∗t+2, . . .} ∈ ΠH be an optimal policy for the tail subproblem:\nmin µ∈ΠH\nCVaRyt+1 (\nlim n→∞\nCt+1,n | xt+1, µ ) .\nFor a given pair of (xt, yt) ∈ X×Y , construct the “extended” policy µ̃ = {µ̃t, µ̃t+1, . . .} ∈ ΠH as follows:\nµ̃t(xt) = u ∗(xt, yt), and µ̃j(hj) = µ∗j (hj) for j ≥ t+ 1,\nwhere u∗(xt, yt) is the minimizer of the fixed point equation\nu∗(xt, yt) ∈ argmin a∈A C(xt, a)+γ max ξ∈UCVaR(yt,P (·|xt,a)) Eξ[V(xt+1, ytξ(xt+1)) |xt, yt, a],\nwith yt is the given confidence interval to the tth tail-subproblem and the transition from yt to yt+1 is given by yt+1 = ytξ∗(xt+1) where\nξ∗ ∈ arg max ξ∈UCVaR(yt,P (·|xt,a∗))\nE [ ξ(xt+1) · CVaRytξ(xt+1) ( lim n→∞ Ct+1,n | xt+1, µ̃ )]\nSince µ∗ is an optimal, and a fortiori feasible policy for the tail subproblem (from time t + 1), the policy µ̃ ∈ ΠH is a feasible policy for the tail subproblem (from time t): minµ∈ΠH CVaRyt (limn→∞ Ct,n | xt, µ). Hence, we can write\nV(xt, yt) ≤ C(xt, µ̃t(xt)) + γCVaRyt (\nlim n→∞\nCt+1,n | xt, µ̃ ) .\nHence from the definition of µ∗, one easily obtains:\nV(xt, yt)\n≤C(xt, u∗(xt, yt)) + γ max ξ∈UCVaR(yt,P (·|xt,u∗(xt,yt)))\nE [ ξ(xt+1) · CVaRytξ(xt+1) ( lim n→∞ Ct+1,n | xt+1, µ̃ ) |xt, yt, u∗(xt, yt) ] =C(xt, u\n∗(xt, yt)) + γ max ξ∈UCVaR(yt,P (·|xt,u∗(xt,yt))) Eξ[V(xt+1, ytξ(xt+1)) |xt, yt, u∗(xt, yt)]\n=T[V](xt, yt).\nCollecting the above results, we have shown that V is a fixed point solution to V (x, y) = T[V ](x, y) for any (x, y) ∈ X ×Y . Since the fixed point solution is unique, combining both of these arguments implies V ∗(x, y) = V(x, y) for any (x, y) ∈ X×Y . Therefore, it follows that with initial state (x, y), we have V ∗(x, y) = V(x, y) = minµ∈ΠH CVaRy (limT→∞ C0,T | x0 = x, µ).\nCombining the above three parts of the proof, the claims of this theorem follows."
    }, {
      "heading" : "A.4 Proof of Theorem 5",
      "text" : "Similar to the definition of the optimal Bellman operator T, for any augmented stationary Markovin policy u : X × Y → A, we define the policy induced Bellman operator Tu as\nTu[V ](x, y) = C(x, u(x, y))+γ max ξ∈UCVaR(y,P (·|x,u(x,y))) ∑ x′∈X ξ(x′)V (x′, yξ(x′))P (x′|x, u(x, y)).\nAnalogous to Theorem 4, we can easily show that the fixed point solution to Tu[V ](x, y) = V (x, y) is unique and the CVaR decomposition theorem (Theorem 2) further implies this solution equals to\nCVaRy (\nlim T→∞\nC0,T | x0 = x, uH ) ,\nwhere the history dependent policy πH = {µ0, µ1, . . .} is given by µk(hk) = u(xk, yk) for any k ≥ 0, with initial states x0, y0 = α, state transitions (8), but with augmented stationary Markovian policy u∗ replaced by u.\nTo complete the proof of this theorem, we need to show that the augmented stationary Markovian policy u∗ is optimal if and only if\nT[V ∗](x, y) = Tu∗ [V ∗](x, y), ∀x ∈ X , y ∈ Y, (13)\nwhere V ∗(x, y) is the unique fixed point solution of T[V ](x, y) = V (x, y). Here an augmented stationary Markovian policy u∗ is optimal if and only if the induced history dependent policy u∗H in (7) is optimal to problem (3).\nFirst suppose u∗ is an optimal augmented stationary Markvoian policy. Then using the definition of u∗ and the result from Theorem 4 that\nV ∗(x, y) = min µ∈ΠH\nCVaRy (\nlim T→∞\nC0,T | x0 = x, µ ) ,\nwe immediately show that V ∗(x, y) = Vu∗(x, y). By the fixed point equation T[V ∗](x, y) = V ∗(x, y) and Tu∗ [Vu∗ ](x, y) = Vu∗(x, y), this further implies (13) holds.\nSecond suppose u∗ satisfies the equality in (13). Then by the fixed point equality T[V ∗](x, y) = V ∗(x, y), we immediately obtain the equation V ∗(x, y) = Tu∗ [V ∗](x, y) for any x ∈ X and y ∈ Y . since the fixed point solution to Tu∗ [V ](x, y) = V (x, y) is unique, we further show that T[V ∗](x, y) = V ∗(x, y) = Vu∗(x, y) and Vu∗(x, y) = minµ∈ΠH CVaRy (limT→∞ C0,T | x0 = x, µ) from Theorem 4. By using the policy construction formula in (7) to obtain the history dependent policy u∗H and following the above arguments at which the augmented Markovian stationary policy u is replaced by u∗, this further implies\nmin µ∈ΠH\nCVaRy (\nlim T→∞\nC0,T | x0 = x, µ ) = CVaRy (\nlim T→∞\nC0,T | x0 = x, u∗H ) ,\ni.e., u∗ is an optimal augmented stationary Markovian policy."
    }, {
      "heading" : "A.5 Proof of Lemma 6",
      "text" : "We first proof the monotonicity property. Based on the definition of Ix[V ](y), if V1(x, y) ≥ V2(x, y) ∀x ∈ X and y ∈ Y , we have that\nIx[V1](y) = yi+1V1(x, yi+1)(y − yi) + yiV1(x, yi)(yi+1 − y)\nyi+1 − yi , if y ∈ Ii(x).\nSince yi, yi+1 ∈ Y and (yi+1 − y), (y − yi) ≥ 0 (because y ∈ Ii(x)), we can easily see that Ix[V1](y) ≥ Ix[V2](y). As y ∈ Y and ξ(·)P (·|x, a) ≥ 0 for any ξ ∈ UCVaR(y, P (·|x, a), this further implies TI [V1](x, y) ≥ TI [V2](x, y).\nNext we prove the constant shift property. Note from the definition of Ix[V ](y)\nthat\nIx[V +K](y)\n=yi(V (x, yi) +K) + yi+1(V (x, yi+1) +K)− yi(V (x, yi) +K)\nyi+1 − yi (y − yi), if y ∈ Ii(x),\n=yK + yiV (x, yi) + yi+1V (x, yi+1)− yiV (x, yi)\nyi+1 − yi (y − yi), if y ∈ Ii(x)\n=Ix[V ](y) + yK.\nTherefore by definition of TI [V ](x, y), the constant shift property: TI [V+K](x, y) = TI [V ](x, y) + γK for any x ∈ X , y ∈ Y , follows directly from the above arguments.\nEquipped with both properties in monotonicity and constant shift, the proof of contraction of TI directly follows from the analogous proof in Lemma 3.\nFinally we prove the concavity preserving property. Assume yV (x, y) is concave in y ∈ Y for any x ∈ X . Then for yi+2 > yi+1 > yi, ∀i ∈ {1, . . . , N(x) − 2} the following inequality immediately follows from the definition of a concave function:\ndIx[V ](y) dy ∣∣∣∣ y∈Ii+1(x) = yi+1V (x, yi+1)− yiV (x, yi) yi+1 − yi\n≥yi+2V (x, yi+2)− yi+1V (x, yi+1) yi+2 − yi+1 = dIx[V ](y) dy ∣∣∣∣ y∈Ii+2(x) .\n(14)\nWe then show that the following inequality in each of the following cases, whenever the slope exists:\nIx[V ](z1) ≤ Ix[V ](z2) + dIx[V ](y)\ndy\n∣∣∣∣ y=z2 (z1 − z2), ∀z1, z2 ∈ Y \\ {0}.\n(1) There exists i ∈ {1, . . . , N(x) − 1} such that z1, z2 ∈ Ii+1(x). In this case we have that\ndIx[V ](y) dy ∣∣∣∣ y=z1 = dIx[V ](y) dy ∣∣∣∣ y=z2 ,\nand this further implies\nIx[V ](z1) = Ix[V ](z2) + dIx[V ](y)\ndy\n∣∣∣∣ y=z2 (z1 − z2).\n(2) There exists i, j ∈ {1, . . . , N(x) − 2}, i + 1 < j such that z1 ∈ Ii+1(x) and z2 ∈ Ij(x). In this case, without loss of generality we assume j = i+ 1. The proof for case: j > i+ 2 is omitted for the sake of brevity, as it can be completed by iteratively applying the same arguments from case: j = i + 2. Since z1 ∈ Ii(x), z2 ∈ Ij(x), we have z2 − z1 ≥ 0 and\ndIx[V ](y) dy ∣∣∣∣ y=z1 ≥ dIx[V ](y) dy ∣∣∣∣ y=z2 .\nBased on the definition of the linear interpolation function, we have that\nIx[V ](yi+1) = yi+1V (x, yi+1) = Ix[V ](yi) + dIx[V ](y)\ndy\n∣∣∣∣ y∈Ii+1(x) (yi+1 − yi).\nFurthermore, combining previous arguments with the definitions of Ix[V ](z1), Ix[V ](z2) implies that for (z2 − yi+1) ≥ 0,\nIx[V ](z2) =Ix[V ](yi+1) + dIx[V ](y)\ndy\n∣∣∣∣ y=z2 (z2 − yi+1)\n≤Ix[V ](yi+1) + dIx[V ](y)\ndy\n∣∣∣∣ y=z1 (z2 − yi+1)\n=Ix[V ](yi) + dIx[V ](y)\ndy\n∣∣∣∣ y∈Ii+1(x) (z2 − yi)\n=Ix[V ](z1) + dIx[V ](y)\ndy\n∣∣∣∣ y=z1 (z2 − z1).\n(3) There exists i, j ∈ {1, . . . , N(x) − 2}, i + 1 < j such that z2 ∈ Ii+1(x) and z1 ∈ Ij(x). In this case, without loss of generality we assume j = i+ 1. The proof for case: j > i+ 2 is omitted for the sake of brevity, as it can be completed by iteratively applying the same arguments from case: j = i + 2. Since z2 ∈ Ii+1(x), z1 ∈ Ij(x), we have z1 − z2 ≥ 0 and\ndIx[V ](y) dy ∣∣∣∣ y=z1 ≤ dIx[V ](y) dy ∣∣∣∣ y=z2 .\nSimilar to the analysis in the previous case, we have that\nIx[V ](yi) = yiV (x, yi) = Ix[V ](yi+1) + dIx[V ](y)\ndy\n∣∣∣∣ y∈Ii+1(x) (yi − yi+1)\nFurthermore, combining previous arguments with the definitions of Ix[V ](z1), Ix[V ](z2) implies that for (z2 − z1) ≤ 0,\nIx[V ](z2) =Ix[V ](yi) + dIx[V ](y)\ndy\n∣∣∣∣ y=z2 (z2 − yi)\n=Ix[V ](yi+1) + dIx[V ](y)\ndy\n∣∣∣∣ y=z2 (z2 − yi+1)\n=Ix[V ](z1) + dIx[V ](y)\ndy\n∣∣∣∣ y=z2 (z2 − z1)\n≤Ix[V ](z1) + dIx[V ](y)\ndy\n∣∣∣∣ y=z1 (z2 − z1).\nThus we have just shown that the first order sufficient condition for concave functions, corresponding to Ix[V ](y), holds, i.e., Ix[V ](y) is concave in y ∈ Y \\ {0} for\nany given x ∈ X . Now since Ix[V ](y) is a continuous piecewise linear function in y ∈ Y and a concave function when the domain is restricted to Y \\ {0}. By continuity this immediately implies that Ix[V ](y) is concave in y ∈ Y as well. Then following the identical arguments in the proof of Lemma 3 for the concavity preserving property, we can thereby show that\nyTI [V ](x, y) = min a∈A\n{ yC(x, a) + max\nξ∈UCVaR(y,P (·|x,a)) ∑ x′∈X Ix′ [V ](yξ(x′))P (x′|x, a)\n}\nis concave in y ∈ Y for any given x ∈ X ."
    }, {
      "heading" : "A.6 Useful Intermediate Results",
      "text" : "Lemma 8 Let f(y) : [0, 1] → R be a concave function, differentiable almost everywhere, with Lipschitz constant M . Then the linear interpolation I[f ](y) is also concave, and with Lipschitz constant MI ≤M .\nProof For every segment [yj , yj+1] in the linear interpolation, f(y) is concave, and with Lipschitz constantM , and I[f ](y) is linear. Also, f(yj) = I[f ](yj), and f(yj+1) = I[f ](yj+1), by definition of the linear interpolation. Denote by cj the magnitude of the slope of I[f ](y) at y ∈ [yj , yj+1].\nAssume by contradiction that cj > maxy∈[yj ,yj+1] |f ′(y)| whenever f ′(y) exists. Consider the case when f(yj+1) ≥ f(yj). This implies cj is the slope of the interpolation function I[f ](y) at y ∈ [yj , yj+1]. Then by the fundamental theorem of calculus, we have\nf(yj+1)−f(yj) = ∫ yj+1 yj f ′(y)dy ≤ ∫ yj+1 yj |f ′(y)|dy < ∫ yj+1 yj cjdy = (I[f ](yj+1)−I[f ](yj)),\ncontradicting f(yj+1) = I[f ](yj+1) and f(yj) = I[f ](yj). On the other hand, consider the case when f(yj+1) ≤ f(yj). This implies −cj is the slope of the interpolation function I[f ](y) at y ∈ [yj , yj+1]. Again by fundamental theorem of calculus,\n0 ≤ f(yj+1)−f(yj) = ∫ yj+1 yj f ′(y)dy ≥ ∫ yj+1 yj −|f ′(y)|dy > ∫ yj+1 yj −cjdy = I[f ](yj)−I[f ](yj+1).\nSince f(yj+1) = I[f ](yj+1) and f(yj) = I[f ](yj), which implies I[f ](yj)−I[f ](yj+1) ≥ 0, the above expression clearly leads to a contradiction.\nWe finally have that maxy∈[yj ,yj+1] |f ′(y)| ≥ cj for segment j ∈ {1, . . . , N(x) − 1}. As this argument holds for each segment, by maximizing over j over {1, . . . , N(x)− 1}, we have that\nM ≥ max j∈{1,...,N(x)−1} max y∈[yj ,yj+1] |f ′(y)| ≥ max j∈{1,...,N(x)−1} cj = MI .\nThe concavity property (thus differentiability almost everywhere) are well-known results of linear interpolation [18].\nLemma 9 Let yV (x, y) be Lipschitz with constant M , concave, and differentiable almost everywhere, for every x ∈ X and y ∈ [0, 1]. Then yT[V ](x, y) is also Lipschitz with constant Cmax + γM .\nProof For any given state-action pair x ∈ X , and a ∈ A, let P (x′) = P (x′|x, a) be the transition kernel. Consider the function\nH(y) . = max ξ∈UCVaR(y,P (·)) ∑ x′∈X yξ(x′)V (x′, yξ(x′))P (x′).\nNote that, by definition of UCVaR, and a change of variables z(x′) = yξ(x′), we can write H(y) as follows:\nH(y) = max 0≤z(x′)≤1,∑ x′ P (x ′)z(x′)=y\n∑ x′∈X z(x′)V (x′, z(x′))P (x′). (15)\nThe Lagrangian of the above maximization problem is\nL(z, λ; y) = ∑ x′∈X z(x′)V (x′, z(x′))P (x′)− λ( ∑ x′ P (x′)z(x′)− y).\nSince yV (x, y) is concave, the maximum is attained. By first order optimality condition the following expression holds:\n∂L(z, λ; y)\n∂z(x′) = P (x′)\n∂ [z(x′)V (x′, z(x′))]\n∂z(x′) − λP (x′) = 0.\nSumming the last expression over x′, we obtain:∑ x′∈X P (x′) ∂ [z(x′)V (x′, z(x′))] ∂z(x′) = ∑ x′∈X λP (x′) = λ.\nNow, from the Lipschitz property of yV (x, y), we have∣∣∣∣∣∑ x′∈X λP (x′) ∣∣∣∣∣ ≤ ∑ x′∈X P (x′) ∣∣∣∣∂ [z(x′)V (x′, z(x′))]∂z(x′) ∣∣∣∣ ≤ ∑ x′∈X P (x′)M = M.\nThus,\n|λ| ≤ ∑ x′∈X P (x′) ∣∣∣∣∂ [z(x′)V (x′, z(x′))]∂z(x′) ∣∣∣∣ ≤M.\nNote that the objective in (15) does not depend on y. From the envelope theorem [14], it follows that\ndH(y)\ndy = λ,\ntherefore, H(y) is Lipschitz, with constant M .\nNow, by definition,\nyT[V ](x, y) = min a∈A\n[ yC(x, a) + γ max\nξ∈UCVaR(y,P (·|x,a)) ∑ x′∈X yξ(x′)V (x′, yξ(x′))P (x′|x, a)\n] .\nUsing our Lipschitz result for H(y), we have that for any a ∈ A, the function\nyC(x, a) + γ max ξ∈UCVaR(y,P (·|x,a)) ∑ x′∈X yξ(x′)V (x′, yξ(x′))P (x′|x, a)\nis Lipschitz in y, with constant C(x, a) +γM . Using again the envelope theorem [14], we obtain that yT[V ](x, y) is Lipschitz, with constant Cmax + γM .\nLemma 10 Consider Algorithm 1. Assume that for any x ∈ X , the initial value function satisfies that yV0(x, y) is Lipschitz (in y), with uniform constant M0. We have that for any t ∈ {0, 1, . . . , }, the function yVt(x, y) is Lipschitz in y for any x ∈ X , with Lipschitz constant\nMt = 1− γt\n1− γ Cmax + γ tM0 ≤ Cmax 1− γ +M0, ∀t.\nProof Let TI [V ] denote the application of the Bellman operator T to the linearlyinterpolated version of yV (x, y). We have, by definition, that\nV1(x, y) = TI [V0](x, y).\nUsing Lemma 8 and Lemma 9, we have that V1(x, y) is Lipschitz, with M1 ≤ Cmax + γM0.\nNote now, that V2(x, y) = TI [V1](x, y). Thus, by induction, we have\nMt ≤ 1− γt\n1− γ Cmax + γ\ntM0,\nand the result follows."
    }, {
      "heading" : "A.7 Proof of Theorem 7",
      "text" : "The proof of this theorem is split into three parts. In the first part, we bound the difference Ix[Vt](y)/y − Vt(x, y) at each state (x, y) ∈ X × Y using the previous technical lemmas and Lipschitz property.\nIn the second part, we bound the difference of TI [Vt](x, y)−T[Vt](x, y). In the third part we bound the interpolation error using contraction properties of Bellman recursions. First we analyze the bounds for Ix[Vt](y)/y−Vt(x, y) in the following four cases. Notice that from Lemma 10, we have that |dIx[Vt](y)/dy| ≤ M := Cmax/(1− γ) + M0.\n(1) When y = 0 (for which y ∈ I1(x)). Using previous analysis and L’Hospital’s rule we have that limy→0 Ix[Vt](y)/y = Vt(x, 0). This further implies limy→0 Ix[Vt](y)/y − Vt(x, 0) = 0. (2) When y ∈ Ii+1(x), 2 ≤ i < N(x)− 1. Similar to the inequality in (14), by concavity of yVt(x, y) in y ∈ Y , we have that\ndIx[Vt](y) dy ∣∣∣∣ y∈Ii+1(x) = yi+1Vt(x, yi+1)− yiVt(x, yi) yi+1 − yi ≤ yVt(x, y)− yiVt(x, yi) y − yi ,\nand\ndIx[Vt](y) dy ∣∣∣∣ y∈Ii+2(x) = yi+2Vt(x, yi+2)− yi+1Vt(x, yi+1) yi+2 − yi+1 ≤ yi+1Vt(x, yi+1)− yVt(x, y) yi+1 − y .\nFrom the first inequality, for each (x, y) ∈ X × Y we get,\nIx[Vt](y) y −Vt(x, y) ≤ 1 y\n( yiVt(x, yi) +\nyi+1Vt(x, yi+1)− yiVt(x, yi) yi+1 − yi\n(y − yi)− yVt(x, y) ) ≤ 0.\n(16) On the other hand, rearranging the second inequality gives\n1 y (Ix[Vt](y)− yVt(x, y))\n≥1 y\n( yiVt(x, yi) +\ndIx[Vt](y) dy ∣∣∣∣ y∈Ii+1(x) (y − yi)− yi+1Vt(x, yi+1)− dIx[Vt](y) dy ∣∣∣∣ y∈Ii+2(x) (y − yi+1) )\n=\n( dIx[Vt](y)\ndy\n∣∣∣∣ y∈Ii+1(x) − dIx[Vt](y) dy ∣∣∣∣ y∈Ii+2(x) ) y − yi+1 y ≥ −2M ( yi+1 y − 1 ) .\n(17)\nFurthermore by the Lipschitz property, we also have the following inequality as well:\n1 y (Ix[Vt](y)− yVt(x, y))\n= yi+1Vt(x, yi+1)(y − yi) + yiVt(x, yi)(yi+1 − y)\n(yi+1 − yi)y − Vt(x, y)\n≥yiVt(x, yi)(y − yi) + yiVt(x, yi)(yi+1 − y)−M(yi+1 − yi)(y − yi) (yi+1 − yi)y − Vt(x, y) = yiVt(x, yi)−M(y − yi)\ny − Vt(x, y) ≥ −2M\n( 1− yi\ny\n) .\n(18)\nCombining the inequalities (17) and (18), the following lower bound for Ix[Vt](y)/y− Vt(x, y) holds:\n1 y (Ix[Vt](y)−yVt(x, y)) ≥ δ := −2M min\n{ 1− yi y , yi+1 y − 1 } , ∀y ∈ Ii+1(x), i ≥ 2.\nFrom the above definition, when yi ≤ y ≤ (yi + yi+1)/2, the lower bound becomes δ = −2M(1 − yi/y) and when (yi + yi+1)/2 ≤ y ≤ yi+1, the corresponding lower bound is δ = −2M(yi+1/y−1). In both cases, δ is minimized when y = (yi+yi+1)/2. Therefore, the above analysis implies the following lower bound:\n1 y (Ix[Vt](y)− yVt(x, y)) ≥ −2M yi+1 − yi yi+1 + yi , ∀y ∈ Ii+1(x), i ≥ 2.\nWhen yi+1 = θyi for i ∈ {2, . . . , N(x) − 1} for some constant θ ≥ 1, this further implies that\n1 y (Ix[Vt](y)− yVt(x, y)) ≥ −2M θ − 1 θ + 1 ≥ −M(θ − 1), ∀y ∈ Y \\ [0, ].\nThen combining the results, here we get the following bound for Ix[Vt](y)/y−Vt(x, y):\n−M(θ − 1) ≤ Ix[Vt](y) y − Vt(x, y) ≤ 0, ∀y ∈ Ii+1(x), i ≥ 2.\n(3) When y ∈ IN(x)(x), i.e., y ∈ (yN(x)−1, 1]. Similar to the proof of case (2), we can show that for any x ∈ X and y ∈ IN(x)(x), the same lines of arguments in inequality (16) and (18) hold, which implies\n−2M ( 1− yN(x)−1 ) ≤ −2M ( 1− yN(x)−1\ny\n) ≤ 1 y (Ix[Vt](y)− yVt(x, y)) ≤ 0.\nWhen yN(x) = 1 = θyN(x)−1, this further shows that −2MyN(x)−1(θ − 1) = −2M ( yN(x) − yN(x)−1 ) ≤ 1 y (Ix[Vt](y)− yVt(x, y)) ≤ 0,\nand −2M(θ − 1) ≤ −2\nθ M(θ − 1) ≤ 1 y (Ix[Vt](y)− yVt(x, y)) ≤ 0.\n(4) When y ∈ I2(x), i.e., y ∈ (0, y2]. From inequality (16), the definition of Ix[Vt](y), we have that\n0 ≥ Ix[Vt](y)− yVt(x, y) y = y(Vt(x, y2)− Vt(x, y)) y = Vt(x, y2)−Vt(x, y) ≥ Vt(x, y2)−Vt(x, 0).\nThe first inequality is due to the fact that yVt(x, y) is concave in y ∈ Y for any x ∈ X , thus the first order condition implies\ny2Vn(x, y2)− y1Vn(x, y1) y2 − y1 ≤ yVn(x, y)− y1Vn(x, y1) y − y1 , ∀y ∈ I2(x),\nand the last inequality is due to the similar fact that\nVt(x,w) = wVt(x,w)− 0 · Vt(x, 0) w − 0 ≤ zVt(x, z)− 0 · Vt(x, 0) z − 0 = Vt(x, z), ∀z, w ∈ Y, z ≤ w.\nTherefore the condition of this theorem implies\n0 ≥ Ix[Vt](y)− yVt(x, y) y ≥ − , ∀t ≥ 0, x ∈ X , y ∈ Y.\nCombining the above four cases, we have that for each state (x, y) ∈ X × Y ,\n0 ≥ Ix[Vt](y) y − Vt(x, y) ≥ −2M(θ − 1)− , ∀t.\nSecond, we bound the difference of TI [Vt](x, y) − T[Vt](x, y). By recalling that ξ(·)P (·|x, a) is a probability distribution for any ξ ∈ UCVaR(y, P (·|x, a)), we then combine all previous arguments and show that at any t ∈ {0, 1, . . . , } and any x ∈ X , a ∈ A, y ∈ Y(x),\nmax ξ∈UCVaR(y,P (·|x,a)) ∑ x′∈X ,ξ(x′)6=0 ( Ix′ [Vt](yξ(x′)) yξ(x′) − Vt(x′, yξ(x′)) ) ξ(x′)P (x′|x, a) ≥ −2M(θ−1)− .\nThis further implies\nT[Vt](x, y)− γ(2M(θ − 1) + ) ≤ TI [Vt](x, y) ≤ T[Vt](x, y). (19)\nThird, we prove the error bound of interpolation based value iteration using the above properties. By putting t = 0 in (19), we have that\n−γ(2M(θ − 1) + ) ≤ TI [V0](x, y)−T[V0](x, y) ≤ 0.\nApplying the Bellman operator T on all sides of the above inequality and noting that T is a translational invariant mapping, the above expression implies\nT2[V0](x, y)−γ2(2M(θ−1)+ ) ≤ T[TI [V0]](x, y) = T[V1](x, y) ≤ T2[V0](x, y).\nBy adding the inequality: −γ(2M(θ − 1) + ) ≤ TI [V1](x, y) −T[V1](x, y) ≤ 0 to the above expression, this further implies the following expression:\nT2[V0](x, y)−γ(1+γ)(2M(θ−1)+ ) ≤ TI [V1](x, y) = T2I [V0](x, y) ≤ T2[V0](x, y).\nThen, by repeating this process, we can show that for any n ∈ N, the following inequality holds:\nTn[V0](x, y)− γ 1− γn\n1− γ (2M(θ − 1) + ) ≤ TnI [V0](x, y) ≤ Tn[V0](x, y).\nNote that when n → ∞, we have that γn converges to 0, Tn[V0](x, y) converges to minµ∈ΠH CVaRy (limT→∞ C0,T | x, µ) (follow from Theorem 4) and TnI [V0](x, y) converges to V̂ ∗(x, y) (follow from the contraction property in Lemma 6).\nFurthermore, from Proposition 1.6.4 in [3], the contraction property of Bellman operator T implies that for any x ∈ X , y ∈ Y , the following expression holds:\n|Tn[V0](x, y)− V ∗(x, y)| ≤ γn\n1− γ (Cmax + ‖Z‖∞)\nwhere Z is the bounded random variable of the initial value function V0(x, y) = CVaRy(Z | x0 = x) such that ‖V0‖∞ ≤ ‖Z‖∞, and V ∗(x, y) = minµ∈ΠH CVaRy (limT→∞ C0,T | x, µ). This further implies for any x ∈ X , y ∈ Y ,\n|TnI [V0](x, y)− V ∗(x, y)| ≤ γ 1− γn 1− γ (2M(θ − 1) + ) + γ n 1− γ (Cmax + ‖Z‖∞).\nThen, by combining all the above arguments, we prove the claim of this theorem."
    }, {
      "heading" : "B Trajectory Plots",
      "text" : "In Figure 2 we demonstrate simulated trajectories according to a policy that is greedy w.r.t. the value function, according to Theorem 5."
    }, {
      "heading" : "C Generalization to Mean-CVaR Optimization",
      "text" : "In this section we extend our approach to MDPs with a mean-CVaR objective of the form:\nmin µ∈ΠH\nλE (\nlim T→∞\nC0,T | x0, µ ) + (1− λ)CVaRα (\nlim T→∞\nC0,T | x0, µ ) , (20)\nwhere λ ∈ [0, 1]. Such an objective is common in practice [11], and is also useful for solving CVaR-constrained objectives using standard Lagrangian methods (see, e.g., [5]).\nNow for any α1, α2 ∈ [0, 1], define\nρᾱ(Z | Ht, µ) = λCVaRα1(Z | Ht, µ) + (1− λ)CVaRα2(Z | Ht, µ)\nand notice that ρᾱ(Z | Ht, µ) = λE (Z | Ht, µ) + (1 − λ)CVaRα (Z | Ht, µ) when the vector of CVaR confidence intervals is given by ᾱ = (1, α).\nTheorem 11 For any t ≥ 0, denote by Z .= (Zt+1, Zt+2, . . . ) the cost sequence from time t + 1 onwards. The conditional mean-CVaR risk metric under policy µ obeys the following decomposition:\nρᾱ(Z | Ht, µ) = max ξ∈U2CVaR(ᾱ,P (·|xt,at)) E[Sλ(ξ(xt+1)) · ρᾱSλ(ξ(xt+1))(Z | Ht+1) | Ht]\nwhere ᾱ = (α1, α2) is the vector of CVaR confidence intervals. The risk envelop is given by\nU2CVaR(ᾱ, P (·|xt, at))= ξ = (ξ1, ξ2) : ξi(xt+1)∈ [ 0, 1\nαi\n] , ∑\nxt+1∈X ξi(xt+1)P (xt+1|xt, at) = 1, ∀i  , Sλ(ξ) : R2 7→ R is a linear operator given by λξ1 + (1 − λ)ξ2 and at is the control input induced by policy µt(ht).\nNow we extend the above analysis to Bellman recursion. With the generic state space Y = [0, 1]2, we now define the optimal Bellman operator at any (x, y) ∈ X × Y ,\nT[V ](x, y) = min a∈A\n[ C(x, a) + γ max\nξ∈U2CVaR(y,P (·|x,a)) ∑ x′∈X Sλ(ξ(x ′))V (x′, ySλ(ξ(x ′)))P (x′|x, a)\n] .\n(21) Based on the decomposition result from Theorem 11, we now have the result on the convergence of Bellman recursion, analogous to Theorem 4 and 5, showing that the fixed point solution of T[V ](x, y) = V (x, y) is unique and equals to the solution of (20) with x0 = x and y0 = (1, α).\nTheorem 12 For any state x ∈ X and y = (y1, y2) ∈ [0, 1]2, the fixed point solution of T[V ](x, y) = V (x, y) is unique and is equal to V (x, y) := minµ∈ΠH λCVaRy1 (limT→∞ C0,T | x0, µ)+ (1− λ)CVaRy2 (limT→∞ C0,T | x0, µ). Furthermore, let µ∗ = {µ0, µ1, . . .} ∈ ΠH be a policy recursively defined as in (7) with two-dimensional augmented state {yj} and initial condition y0 = (1, α). Then µ∗ is an optimal policy for the mean-CVaR problem (20) with initial condition x0 and CVaR confidence level α.\nExtending the interpolation-based CVaR value iteration (Algorithm 1) for this case is straightforward, using a 2-D linear interpolation for yV (x, y)."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2015,
    "abstractText" : "<lb>In this paper we address the problem of decision making within a Markov de-<lb>cision process (MDP) framework where risk and modeling errors are taken into<lb>account. Our approach is to minimize a risk-sensitive conditional-value-at-risk<lb>(CVaR) objective, as opposed to a standard risk-neutral expectation. We refer to<lb>such problem as CVaR MDP. Our first contribution is to show that a CVaR objec-<lb>tive, besides capturing risk sensitivity, has an alternative interpretation as expected<lb>cost under worst-case modeling errors, for a given error budget. This result, which<lb>is of independent interest, motivates CVaR MDPs as a unifying framework for<lb>risk-sensitive and robust decision making. Our second contribution is to present<lb>an approximate value-iteration algorithm for CVaR MDPs and analyze its conver-<lb>gence rate. To our knowledge, this is the first solution algorithm for CVaR MDPs<lb>that enjoys error guarantees. Finally, we present results from numerical exper-<lb>iments that corroborate our theoretical findings and show the practicality of our<lb>approach.",
    "creator" : "LaTeX with hyperref package"
  }
}