{
  "name" : "1603.09465.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A New Approach for Revising Logic Programs",
    "authors" : [ "Zhiqiang Zhuang", "James Delgrande", "Abhaya Nayak", "Abdul Sattar" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 3.\n09 46\n5v 1\n[ cs\n.A I]\n3 1\nM ar\n2 01"
    }, {
      "heading" : "Introduction",
      "text" : "The ability to change one’s beliefs when presented with new information is crucial for any intelligent agent. In the area of belief change, substantial effort has been made towards the understanding and realisation of this process. Traditionally, it is assumed that the agent’s reasoning is governed by a monotonic logic. For this reason, traditional belief change is inapplicable when the agent’s reasoning is non-monotonic. Our goal in this research program is to extend belief base (Hansson 1999) approaches in belief revision to nonmonotonic setting. In this paper, we focus on disjunctive logic programs, as a well-studied and well-known approach to nonmonotonic reasoning that also has efficient implementations.\nMuch, if not most, of our day-to-day reasoning involves non-monotonic reasoning. To illustrate issues that may arise, consider the following example. In a university, professors generally teach, unless they have an administrative appointment. Assume we know that John is a professor. Since most faculty do not have an administrative appointment, and there is no evidence that John does, we conclude that he teaches. This reasoning is a classical form of non-monotonic reasoning, namely using the closed world assumption. It can be represented by the following logic program under the an-\nCopyright c© 2016, Association for the Advancement of Artificial Intelligence (www.aaai.org). All rights reserved.\nswer set semantics.\nTeach(X) ← Prof(X), not Admin(X). (1)\nProf(John) ← . (2)\nThe answer set {Prof(John), T each(John)} for this logic program corresponds exactly to the facts we can conclude.\nSuppose we receive information that John does not teach, which we can represent by the rule\n← Teach(John). (3)\nNow our beliefs about John are contradictory; and it is not surprising that the logic program consisting of rules (1) – (3) has no answer set. For us or any intelligent agent in this situation to function properly, we need a mechanism to resolve this inconsistency. This is a typical belief revision problem; however, the classical (AGM) approach can not be applied, as we are reasoning non-monotonically.\nIt is not hard to suggest possible causes of the inconsistency and to resolve it. It could be that some of our beliefs are wrong; perhaps professors with administrative duties may still need to do teaching or perhaps John is not a professor. Thus we can restore consistency by removing rule (1) or (2). Alternatively and perhaps more interestingly, it could be that assuming that John is not an administrative staff via the absence of evidence is too adventurous; that is he may indeed be an administrative staff member but we don’t know it. Thus we can also restore consistency by adding the missing evidence of John being an administrative staff member by\nAdmin(John) ← . (4)\nThe second alternative highlights the distinction for belief revision in monotonic and non-monotonic settings. In the monotonic setting, an inconsistent body of knowledge will remain inconsistent no matter how much extra information is supplied. On the other hand, in the non-monotonic setting, inconsistency can be resolved by either removing old information, or adding new information, or both. Therefore, belief revision functions in a non-monotonic setting should allow a mixture of removal and addition of information for inconsistency-resolution. In this paper, we will define one such revision functions for disjunctive logic programs under the answer set semantics.\nThe revision function is called slp-revision and is a belief base revision which takes syntactic information into account. In revising P by Q, an slp-revision function first obtains a logic program R that is consistent with Q and differs minimally from P , then combines R with Q. For example, if P = {(1), (2)} and Q = {(3)}, then R could be {(1)} (i.e., resolving inconsistency by removing (2)); {(2)} (i.e., resolving inconsistency by removing (1)); or {(1), (2), (4)} (i.e., resolving inconsistency by adding (4)).\nThe next section gives logical preliminaries. The following one develop our approach to slp-revision in which we provide postulates, a semantic construction, and a representation result. This is followed by a comparison to other work, and a brief conclusion."
    }, {
      "heading" : "Preliminary Considerations",
      "text" : "In this paper, we consider only fully grounded disjunctive logic programs. That is variables in program rules are replaced by the set of their ground instances. Thus a logic program (or program for short) here is a finite set of rules of the form:\na1; . . . ; am ← b1, . . . , bn, not c1, . . . , not co\nwhere m,n, o ≥ 0, m+n+ o > 0, and ai, bj , ck ∈ A for A a finite set of propositional atoms. Connective not is called default negation. We denote the set of all logic programs by P . For each rule r, let H(r) = {a1, . . . , an}, B+(r) = {b1, . . . , bm}, and B−(r) = {c1, . . . , co}. The letters P and Q are used to denote a logic program throughout the paper.\nAn interpretation is represented by the subset of atoms in A that are true in the interpretation. A classical model of a program P is an interpretation in which all rules of P are true according to the standard definition of truth in propositional logic, and where default negation is treated as classical negation. The set of classical models of P is denoted as Mod(P ). Given an interpretation Y , we write Y |= P to mean Y is a classical model of P . The reduct of a program P with respect to an interpretation Y , denoted P Y , is the set of rules:\n{H(r) ← B+(r) | r ∈ P,B−(r) ∩ Y = ∅}.\nAn answer set Y of P is a subset-minimal classical model of P Y . The set of all answer set of P is denoted as AS(P ).\nAn SE interpretation (Turner 2003) is a pair (X,Y ) of interpretations such that X ⊆ Y ⊆ A. The set of all SE interpretations (over A) is denoted SE . The letters M and N are used to denote a set of SE interpretations throughout the paper. An SE interpretation is an SE model of a programP if Y |= P and X |= P Y . The set of all SE models of P is denoted as SE(P ). SE models are proposed to capture strong equivalence (Lifschitz et al. 2001) between programs that is SE(P ) = SE(Q) iff P and Q are strongly equivalent, thus they contain more informations than answer sets.\nThe following two properties of SE models (Turner 2003) are crucial to this paper:\n1. Y ∈ AS(P ) iff (Y, Y ) ∈ SE(P ) and there is no (X,Y ) ∈ SE(P ) such that X ⊂ Y .\n2. (Y, Y ) ∈ SE(P ) iff Y ∈ Mod(P ).\nSo SE(P ) 6= ∅ iff Mod(P ) 6= ∅ but SE(P ) 6= ∅ does not imply AS(P ) 6= ∅. This gives rise to two notions of consistency.\nDefinition 1. P is consistent iff AS(P ) 6= ∅ and P is mconsistent1 iff SE(P ) 6= ∅.\nIt is clear from the SE model properties that consistency implies m-consistency; m-inconsistency implies inconsistency. In other words, a consistent program is m-consistent but not vice versa.\nIn subsequent sections, we will need to describe the difference between two logic programs. For this purpose, we use the symmetric difference operator ⊖ which is defined as\nX ⊖ Y = (X \\ Y ) ∪ (Y \\X)\nfor any sets X and Y ."
    }, {
      "heading" : "SLP-Revision Functions",
      "text" : "In this section, we give a syntax-based revision function ∗ : P × P 7→ P for revising one logic program by another. The function takes a logic program P called the original logic program and a logic program Q called the revising logic program, and returns another logic program P ∗ Q called the revised logic program. Following AGM belief revision, we want to have Q contained in P ∗Q (i.e., Q ⊆ P ∗Q), P ∗Q is consistent whenever possible, and that as much of P as consistently possible is contained in P ∗Q.\nClearly, a key issue in defining ∗ is to deal with the possible inconsistency between Q and P . As illustrated in the teaching example, one means of ensuring that P ∗Q is consistent is to remove a minimal set of beliefs from P so that adding Q to the result is consistent. Of course there may be more than one way to remove beliefs from P . Following this intuition, we obtain all maximal subsets of P that are consistent with Q, which we call the s-removal compatible programs of P with respect to Q.\nDefinition 2. The set of s-removal compatible programs of P with respect to Q, denotedP ↓ Q, is such that R ∈ P ↓ Q iff 1. R ⊆ P , 2. R ∪Q is consistent, and 3. if R ⊂ R′ ⊆ P , then R′ ∪Q is inconsistent.\nThe notion of s-removal compatible programs is not new, classical revision functions (Alchourrón et al. 1985; Hansson 1993) are based on more or less the same notion. The difference is that this notion alone is sufficient to capture the inconsistency-resolution strategy of classical belief revision, but there is more that one can do in non-monotonic belief revision.\nIn our non-monotonic setting, we are able to express assumptions (i.e., negation as failure) and to reason with them. Earlier, we assumed John is not an administrator, in the absence of evidence to the contrary. With this, we came to the conclusion that he has to teach. Consequently, if we learn\n1“m” stands for “monotonic” which indicates that the notion of m-consistency is based on a monotonic characterisation (i.e., SE models) for logic programs.\nthat John does not teach, as in our example, one way of resolving this inconsistency is by adding information so that our assumption does not hold. Following this intuition, we obtain all the minimal supersets of P that are consistent with Q, which we call the s-expansion compatible program of P with respect to Q.\nDefinition 3. The set of s-expansion compatible programs of P with respect to Q, denoted P ↑ Q, is such that R ∈"
    }, {
      "heading" : "P ↑ Q iff",
      "text" : "1. P ⊆ R, 2. R ∪Q is consistent, and 3. if P ⊆ R′ ⊂ R, then R′ ∪Q is inconsistent.\nSince the s-expansion and s-removal compatible programs are consistent with Q and are obtained by removing or adding minimal sets of rules from or to P , the union of Q with any of these sets is consistent and comprises a least change made to P in order to achieve consistency. These programs clearly should be candidates for forming the revised logic program P ∗ Q; however, they do not form the set of all candidates. In particular, we can obtain a program that differs the least from P and is consistent with Q by removing some beliefs of P and at the same time adding some new beliefs to P . Thus we consider all those logic programs that differ the least from P and are consistent with Q; these are called the s-compatible programs of P with respect to Q.\nDefinition 4. The set of s-compatible programs of P with respect to Q, denoted P l Q, is such that R ∈ P l Q iff 1. R ∪Q is consistent and 2. if P ⊖R′ ⊂ P ⊖R, then R′ ∪Q is inconsistent.\nFor example, let P = {a ← b, not c., b., e ← f, not g., f.} and Q = {← a.,← e.}. Then P ∪ Q is inconsistent since a and e can be concluded from P but they contradict the rules of Q. To resolve the inconsistency via making the least change to P , we could remove b ← from P (which eliminates the contradiction about a) and add g ← to P (which eliminates the contradiction about e). The program thus obtained (i.e., (P \\ {b.}) ∪ {g.}) is a s-compatible program in P l Q.\nIt is obvious, but worth noting that the notion of scompatible program subsumes those of s-removal and sexpansion compatible programs. In the above example, P l Q also contains P \\ {b., f.} and P ∪ {c., g.}, which are respectively an s-removal and an s-expansion compatible program of P with respect to Q.\nProposition 1. (P ↑ Q) ∪ (P ↓ Q) ⊆ P l Q.\nThere are cases in which we cannot resolve inconsistency by only adding new beliefs which means the set of s-expansion compatible programs is empty. For example, if P = {a.} and Q = {← a.}, then P ∪ Q is inconsistent and we cannot restore consistency without removing a ← from P . In these cases, the inconsistency is due to contradictory facts that can be concluded without using any reasoning power beyond that of classical logic. Clearly, the inconsistency is of a monotonic nature, that is, in our terminology, m-inconsistency.\nProposition 2. If P ∪Q is m-inconsistent, then P ↑ Q = ∅.\nSo far, we have identified the candidates for forming P ∗ Q. It remains to pick the “best” one. Such extralogical information is typically modelled by a selection function, which we do next.\nDefinition 5. A function γ is a selection function for P iff for any program Q, γ(P l Q) returns a single element of P l Q whenever P l Q is non-empty; otherwise it returns P .\nThe revised logic program P ∗Q is then formed by combining Q with the s-compatible program picked by the selection function for P . We call the function ∗ defined in this way a slp-revision function for P .\nDefinition 6. A function ∗ is a slp-revision function for P iff\nP ∗Q = γ(P l Q) ∪Q\nfor any program Q, where γ is a selection function for P .\nIn classical belief revision, multiple candidates maybe chosen by a selection function, and their intersection is combined with the new belief to form the revision result. There, a selection function that picks out a single element is called a maxichoice function (Alchourrón et al. 1985). In classical logic, maxichoice selection functions leads to undesirable properties for belief set revision but not for belief base revision. In our non-monotonic setting, picking multiple candidates does not make sense, as intersection of s-compatible programs may not be consistent with the revising program. For example, let P = {a ← not b, not c.} and Q = {← a.}. We can restore consistency of P with Q by, for instance, adding the rule b ← to P which corresponds to the scompatible program P ∪ {b.} or by adding the rule c ← which corresponds to the s-compatible program P ∪ {c.}. However, the intersection of the two s-compatible programs is inconsistent with Q.\nWe turn next to properties of slp-revision functions. Consider the following set of postulates where ∗ : P × P 7→ P is a function.\n(s∗s) Q ⊆ P ∗Q (s∗c) If Q is m-consistent, then P ∗Q is consistent (s∗f) If Q is m-inconsistent, then P ∗Q = P ∪Q (s∗rr) If R 6= ∅ and R ⊆ P \\ (P ∗Q), then (P ∗Q) ∪R is inconsistent (s∗er) If E 6= ∅ and E ⊆ (P ∗Q) \\ (P ∪Q), then (P ∗Q) \\ E is inconsistent (s∗mr) If R 6= ∅, R ⊆ P \\ (P ∗Q),\nE 6= ∅ and E ⊆ (P ∗Q) \\ (P ∪Q), then ((P ∗Q) ∪R) \\ E is inconsistent\n(s∗u) If P l Q = P l R, then P \\ (P ∗Q) = P \\ (P ∗R) and (P ∗Q) \\ (P ∪Q) = (P ∗R) \\ (P ∪R)\n(s∗s) (Success) states that a revision is always successful in incorporating the new beliefs. (s∗c) (Consistency) states that a revision ensures consistency of the revised logic program whenever possible. In the monotonic setting, a revision results in inconsistency only when the new beliefs are themselves inconsistent. This is not the case in the nonmonotonic setting. For example, consider the revision of P = {a.} by Q = {b ← not b}. Although Q is inconsistent, we have P ∪ {b.} as a s-compatible program of P\nwith respect to Q. Thus we can have P ∪ {b.} ∪ Q as the revised logic program, which contains Q and is consistent. Here, a revision results in inconsistency only when the revising logic program is m-inconsistent. In such a case, (s∗f) (Failure) states that the revision corresponds to the union of the original and revising logic program.\n(s∗rr) (Removal Relevance) states that if some rules are removed from the original logic program for the revision, then adding them to the revised logic program results in inconsistency. It captures the intuition that nothing is removed unless its removal contributes to making the revised logic program consistent. (s∗er) (Expansion Relevance) states that if some new rules other than those in the revising logic program are added to the original logic program for the revision, then removing them from the revised logic program causes inconsistency. It captures the intuition that nothing is added unless adding it contributes to making the revised logic program consistent. (s∗mr) (Mixed Relevance) states that if some rules are removed from the original logic program and some new rules other than those in the revising logic program are added to the original logic program for the revision, then adding back the removed ones and removing the added ones result in inconsistency of the revised logic program. Its intuition is a mixture of the two above. Note that putting (s∗rr) and (s∗er) together does not guarantee (s∗mr), nor the reverse. In summary, these three postulates express the necessity of adding and/or removing certain belief for resolving inconsistency and hence to accomplish a revision. In classical belief revision, inconsistency can only be resolved by removing old beliefs; the necessity of removing particular beliefs is captured by the Relevance postulate (Hansson 1993).2 The three postulates are the counterparts of Relevance in our non-monotonic setting, and we need all three of them to deal respectively with addition, removal, and a mixture of addition and removal.\nFinally, (s∗u) (Uniformity) states the condition under which two revising logic programsQ and R trigger the same changes to the original logic programP . That is the rules removed from P (i.e., P \\ (P ∗Q)) and the rules added to P (i.e., (P ∗Q) \\ (P ∪Q)) for accommodatingQ are identical to those for accommodatingR. Certainly havingQ and R be strongly equivalent (i.e., SE(Q) = SE(R)) is a sufficient condition. However, it is too strong a requirement. Suppose P = {← a.}, Q = {a.}, and R = {a ← b., b.}. Then the minimal change to P we have to made to accommodate Q and R are the same, that is we remove ← a. However Q and R are not strongly equivalent, even though they incur the same change to P . The essential point of this example is that instead of a global condition like strong equivalence, we need a condition that is local to the original logic program P . Unfortunately, it seems there is no existing notion in the logic programming literature that captures this local condition. Thus we use our newly defined notion of s-compatible programs and come up with the local but more appropriate condition in (s∗u).\n2If ψ ∈ K and ψ 6∈ K ∗ φ, then there is some K′ such that K ∗ φ ⊆ K′ ⊆ K ∪ {φ}, K′ is consistent but K′ ∪ {ψ} is inconsistent.\nWe can show that these postulates are sufficient to characterise all slp-revision functions.\nTheorem 1. A function ∗ is a slp-revision function iff it satisfies (s∗s), (s∗c), (s∗f), (s∗rr), (s∗er), (s∗mr), and (s∗u)."
    }, {
      "heading" : "Comparisons with Existing Approaches",
      "text" : "There has been much work on belief revision for logic programs. The seminal work of Delgrande et al (2013b) generalises Satoh’s (1988) and Dalal’s (1988) revision operators to logic programs. Significantly, they bring SE model into the picture. They do not work with answer sets as a basis for revision, but rather they base their definitions directly on SE models. The work has inspired several other SE model approaches. Schwind and Inoue (2013) provide a constructive characterisation for the revision operators in (Delgrande et al. 2013b). Delgrande et al (2013a) adapt the model-based revision of Katsuno and Mendelzon (1992) to logic programs and provide a representation theorem. Finally, Binnewies et al (2015) provide a variant of partial meet revision and contraction for logic programs.\nFirstly, the SE model approaches are essentially belief set revision whereas our slp-revision is a belief base one. Secondly and more importantly, these approaches assume a weaker notion of consistency, that is m-consistency. For this reason, some contradictions will not be dealt with in these approaches. For instance, the contradictory rule a ← not a is m-consistent thus is considered to be an acceptable state of belief. Also in our teaching example, as the program consisting of rules (1) – (3) is m-consistent, no attempt will be made to resolve the contradiction about John’s teaching duty by the SE model approaches. Therefore for application scenarios in which such contradictions can not be tolerant, our llp-revision function is clearly a better choice.\nApart from the SE model approaches, Krümpelmann and Kern-Isberner (2012) provide a revision function for logic programs that originates from Hansson’s semi-revision (Hansson 1997). Since they assume the same notion of consistency as ours, all the above mentioned contradictions will be resolved in their approach.\nAs we have noted, classical belief revision is defined for monotonic setting, not for non-monotonic ones. Inconsistency can be caused by wrong assumptions in the non-monotonic setting but not in the monotonic setting. Such causes are not considered in (Krümpelmann and Kern-Isberner 2012). Consequently, their approach only support one of the many possible inconsistency-resolution strategies we have developed. Specifically, in (Krümpelmann and Kern-Isberner 2012), inconsistency can be resolved only by removing old beliefs; this strategy is captured by a notion analogous to s-removal compatible programs. The inconsistency-resolution strategies captured by the notion of s-expansion compatible program and s-compatible program in general are not considered."
    }, {
      "heading" : "Conclusion and Future Work",
      "text" : "Depending on the application scenario, the logic governing an agent’s beliefs could be either monotonic or non-\nmonotonic. Traditional belief revision assumes that an agent reasons monotonically; therefore, by definition, it is applicable to such situations only. Here we have aimed to provide a belief revision framework for situations in which the agent reasons non-monotonically. To this end, we defined a belief revision function for disjunctive logic programs under the answer set semantics.\nInconsistency-resolution is an essential task for belief revision. However, the strategies used in traditional belief revision functions are limited to situations when the agent reasons monotonically. With a logic program we have the luxury of making assumptions via lack of contrary evidence, and we can deduce certain facts from such assumptions. Thus if a set of beliefs is inconsistent, then one possible cause is that we made the wrong assumption. In such cases, we can resolve the inconsistency by adding some new rules so that the assumption can no longer be made. Such a cause of inconsistency and the associated inconsistency-resolution strategy is beyond the scope of traditional belief revision, but is crucial for non-monotonic belief revision. We argue that this rationale, which is encoded in our belief revision function, captures the fundamental difference between monotonic and non-monotonic belief revision.\nThis paper then has explored belief base revision in the non-monotonic setting of disjunctive logic programs. Note that the characterising postulates of the base revision are formulated in terms of set-theoretic notions (e.g., subsets, set differences); the only logical notion required is consistency. Moreover the key idea, namely the notion of s-compatible programs, is also based on the same set-theoretic and logical notions. These notions are present in all non-monotonic settings. In future work we propose to extend the base revision to a general approach to belief revision in arbitrary non-monotonic settings."
    }, {
      "heading" : "Appendix: Proof of Results",
      "text" : "In this appendix, we give the proof for the main results."
    }, {
      "heading" : "Proof for Proposition 2",
      "text" : "Let P and Q are logic programs. Suppose P ∪ Q is minconsistent. We need to show P ↑ Q = ∅. Since P ∪ Q is m-inconsistent, we have SE(P ) ∩ SE(Q) = ∅. By the definition of s-expansion compatible program, any element in P ↑ Q has to be a superset of P and consistent with Q. However, for any superset R of P , we have SE(R) ⊆ SE(P ). Thus SE(R) ∩ SE(Q) = ∅ which implies R ∪Q is m-inconsistent."
    }, {
      "heading" : "Proof for Theorem 1",
      "text" : "For one direction, suppose ∗ is a slp-revision function for P and the associated selection function is γ. We need to show ∗ satisfies (s∗s), (s∗c), (s∗f), (s∗rr), (s∗er), (s∗mr), and (s∗u). (s∗s), (s∗c), and (s∗f) follow immediately from the definition of slp-revision functions and compatible programs.\n(s∗rr): Suppose there is a set R such that R 6= ∅ and R ⊆ P \\ (P ∗Q). By the definition of slp-revision, we have P ∗ Q = γ(P l Q) ∪Q, hence P \\ (γ(P l Q) ∪Q) 6= ∅ which\nimplies γ(P l Q) 6= P . Then it follows from the definition of selection function that P l Q 6= ∅ and γ(P l Q) ∈ P l Q. Let γ(P l Q) = X . Then (P ∗Q)∪R = X∪Q∪R. Since ∅ 6= R ⊆ P , we have ((X ∪ R) ⊖ P ) ⊂ (X ⊖ P ). By the definition of compatible program, X ∪R∪Q is inconsistent that is (P ∗Q) ∪R is inconsistent.\n(s∗er): Suppose there is a set E such that E 6= ∅ and E ⊆ (P ∗ Q) \\ (P ∪ Q). By the definition of slp-revision, we have P ∗ Q = γ(P l Q) ∪ Q, hence (γ(P l Q) ∪ Q) \\ (P ∪ Q) 6= ∅ which implies γ(P l Q) 6= P . Then it follows from the definition of selection function that P l Q 6= ∅ and γ(P l Q) ∈ P l Q. Let γ(P l Q) = X . Then (P ∗Q)\\E = (X∪Q)\\E. SinceE∩P = ∅ and ∅ 6= E ⊆ X , ((X \\E)⊖P ) ⊂ (X ⊖P ). By the definition of compatible program, (X \\E)∪Q is inconsistent. Then since E∩Q = ∅, we have (X \\E)∪Q = (X ∪Q) \\E = (P ∗Q) \\E. Thus (P ∗Q) \\ E is inconsistent.\n(s∗mr): Can be proved by combining the proving method for (s∗rr) and (s∗er).\n(s∗u): Suppose P l Q = P l R. Then γ(P l Q) = γ(P l R). If P l Q = P l R = ∅, then by the definition of slp-revision P ∗Q = P ∪ Q and P ∗ R = P ∪ R. Thus P \\ (P ∗Q) = P \\ (P ∗R) = ∅ and (P ∗Q) \\ (P ∪Q) = (P ∗ R) \\ (P ∪ R) = ∅. So suppose P l Q = P l R 6= ∅ and let X = γ(P l Q) = γ(P l R). By the definition of slp-revision, we have P \\ (P ∗Q) = P \\ (X ∪Q). Assume ∅ 6= P ∩Q 6⊆ X . Then since X ∪ (P ∩Q) is consistent with Q and (X ∪ (P ∩Q))⊖P ⊂ X ⊖P , X is not a compatible program, a contradiction! Thus P ∩ Q = ∅ or P ∩Q ⊆ X . In either case we have by set theory that P \\ (P ∗ Q) = P \\ (X ∪Q) = P \\X . It can be shown in the same manner that P \\(P ∗R) = P \\(X∪R) = P \\X . Thus P \\(P ∗Q) = P \\ (P ∗R). Again by the definition of slp-revision, we have (P ∗Q)\\ (P ∪Q) = (X ∪Q)\\ (P ∪Q) = X \\P . Similarly (P ∗ R) \\ (P ∪ R) = (X ∪ R) \\ (P ∪ R) = X \\ P . Thus (P ∗Q) \\ (P ∪Q) = (P ∗R) \\ (P ∪R).\nFor the other direction, suppose ∗ is a function that satisfies (s∗s), (s∗c), (s∗f), (s∗rr), (s∗er), (s∗mr), and (s∗u). We need to show ∗ is a slp-revision function.\nLet γ be defined as:\nγ(P l Q) = ((P ∗Q) ∩ P ) ∪ ((P ∗Q) \\Q)\nfor all Q. It suffices to show γ is a selection function for P and P ∗Q = γ(P l Q) ∪Q.\nPart 1: For γ to be a selection function, it must be a function. Suppose P l Q = P l R. Then (s∗u) implies"
    }, {
      "heading" : "P \\ (P ∗ Q) = P \\ (P ∗ R) and (P ∗ Q) \\ (P ∪ Q) =",
      "text" : "(P ∗R)\\(P∪R). Since P = (P \\(P ∗Q))∪((P ∗Q)∩P ) = (P \\(P ∗R))∪((P ∗R)∩P ), P \\(P ∗Q) = P \\(P ∗R) implies (P ∗Q)∩P = (P ∗R)∩P . Thus (P ∗Q)\\ (P ∪Q) = (P ∗ R) \\ (P ∪ R) implies ((P ∗ Q) ∩ P ) ∪ ((P ∗ Q) \\ (P ∪ Q)) = ((P ∗ R) ∩ P ) ∪ ((P ∗ R) \\ (P ∪ R)). Then by set theory, we have ((P ∗ Q) ∩ P ) ∪ ((P ∗ Q) \\ Q) = ((P ∗R) ∩ P ) ∪ ((P ∗R) \\R). Finally, it follows from the definition of γ that γ(P l Q) = γ(P l R).\nIf P l Q = ∅, then we have to show γ(P l Q) = P . P l Q = ∅ implies Q is m-inconsistent, hence it follows from (s∗f) that P ∗ Q = P ∪ Q. Then by the definition\nof γ, γ(P l Q) = ((P ∗ Q) ∩ P ) ∪ ((P ∗ Q) \\ Q) = ((P ∪Q) ∩ P ) ∪ ((P ∪Q) \\Q) = P .\nIf P l Q 6= ∅, then we have to show γ(P l Q) ∈ P l Q. Since P l Q 6= ∅, Q is m-consistent. Then (s∗c) implies P ∗Q is consistent. Since γ(P l Q)∪Q = ((P ∗Q)∩P )∪ ((P ∗ Q) \\ Q) ∪ Q = P ∗ Q, γ(P l Q) ∪ Q is consistent. Assume there is X s.t. X ∪ Q is consistent and X ⊖ P ⊂ γ(P l Q)⊖ P . Then we have three cases:\nCase 1, there is R s.t. ∅ 6= R ⊆ P \\ γ(P l Q), and X = γ(P l Q) ∪ R: If R ∩ Q = ∅, then since γ(P l Q)∪Q = P ∗Q, R∩(P ∗Q) = ∅. Then it follows from (s∗rr) that (P ∗Q)∪R is inconsistent. Since X∪Q = (P ∗Q)∪R, X ∪ Q is inconsistent, a contradiction! If R ∩ Q 6= ∅, then since R ⊆ P , R ∩ P ∩ Q 6= ∅. Since (s∗s) implies Q ⊆ P ∗ Q, we have Q ∩ P ⊆ (P ∗ Q) ∩ P , which implies R∩((P∗Q)∩P ) 6= ∅. Then since ((P∗Q)∩P ) ⊆ γ(P l Q), γ(P l Q) ∩ R 6= ∅, a contradiction! Thus R ∩ Q 6= ∅ is an impossible case.\nCase 2, there is E s.t. E ∩ P = ∅, ∅ 6= E ⊆ γ(P l Q), and X = γ(P l Q)\\E: Then E ⊆ γ(P l Q)∪Q = P ∗Q. If E∩Q = ∅, then (s∗er) implies (P ∗Q)\\E is inconsistent. Since X ∪Q = γ(P l Q) \\ E ∪Q = (P ∗Q) \\ E, X ∪Q is inconsistent, a contradiction! If E ∩ Q 6= ∅, then E 6⊆ (P ∗Q)\\Q. Since E∩P = ∅, we have E∩(P ∗Q)∩P = ∅. Thus E 6⊆ ((P ∗Q) ∩ P ) ∪ ((P ∗Q) \\Q) = γ(P l Q), a contradiction! Thus E ∩Q 6= ∅ is an impossible case.\nCase 3, there are R and E s.t. ∅ 6= R ⊆ P , R ∩ γ(P l Q) = ∅, E ∩ P = ∅, ∅ 6= E ⊆ γ(P l Q), and X = (γ(P l Q) ∪ R) \\ E: Then we can show as in Case 1 and 2 that R∩P ∗Q = ∅ and E ⊆ P ∗Q. If R∩Q = ∅ and E∩Q = ∅, then (s∗mr) implies ((P ∗Q)∪R) \\E is inconsistent. Thus X ∪Q = ((γ(P l Q)∪R)\\E)∪Q = ((P ∗Q)∪R)\\E is inconsistent, a contradiction! Also we can show as in Case 1 and 2 that that R ∩ Q = ∅ and E ∩ Q = ∅ are impossible cases.\nPart 2: By set theory, γ(P l Q) ∪Q = ((P ∗Q) ∩ P ) ∪ ((P ∗Q) \\Q) ∪Q = ((P ∗Q) ∩ P ) ∪ (P ∗Q) = P ∗Q."
    }, {
      "heading" : "455–462, 1988.",
      "text" : "[Schwind and Inoue 2013] Nicolas Schwind and Katsumi Inoue. Characterization theorems for revision of logic programs. In Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-2013), pages 485–498, 2013.\n[Turner 2003] Hudson Turner. Strong equivalence made easy: Nested expressions and weight constraints. Theory Pract. Log. Program., 3(4):609–622, 2003."
    } ],
    "references" : [ {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "Carlos E. Alchourrón", "Peter Gärdenfors", "David Makinson" ],
      "venue" : "The Journal of Symbolic Logic, 50(2):510–530,",
      "citeRegEx" : "Alchourrón et al. 1985",
      "shortCiteRegEx" : null,
      "year" : 1985
    }, {
      "title" : "Partial meet revision and contraction in logic programs",
      "author" : [ "Sebastian Binnewies", "Zhiqiang Zhuang", "Kewen Wang" ],
      "venue" : "Proceedings of the 29th AAAI Conference on Artificial Intelligence (AAAI-2015),",
      "citeRegEx" : "Binnewies et al. 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "In Proceedings of the 7th National Conference on Artificial Intelligence (AAAI-1988)",
      "author" : [ "Mukesh Dalal. Investigations into a theory of knowledge base revision" ],
      "venue" : "pages 475–479,",
      "citeRegEx" : "Dalal 1988",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Agm-style belief revision of logic programs under answer set semantics",
      "author" : [ "Delgrande" ],
      "venue" : "In Proceedings of the 12th International Conference on Logic Programming",
      "citeRegEx" : "Delgrande,? \\Q2013\\E",
      "shortCiteRegEx" : "Delgrande",
      "year" : 2013
    }, {
      "title" : "Comput",
      "author" : [ "James P. Delgrande", "Torsten Schaub", "Hans Tompits", "Stefan Woltran. A modeltheoretic approach to belief change in answer set programming. ACM Trans" ],
      "venue" : "Log., 14(2),",
      "citeRegEx" : "Delgrande et al. 2013b",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Journal of Philosophical Logic",
      "author" : [ "Sven Ove Hansson. Reversing the Levi Identity" ],
      "venue" : "22(6):637–669,",
      "citeRegEx" : "Hansson 1993",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Journal of Applied Non-Classical Logics",
      "author" : [ "Sven Ove Hansson. Semi-revision" ],
      "venue" : "7(1-2):151–175,",
      "citeRegEx" : "Hansson 1997",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "A Textbook of Belief Dynamics Theory Change and Database Updating",
      "author" : [ "Sven Ove Hansson" ],
      "venue" : "Kluwer,",
      "citeRegEx" : "Hansson 1999",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Artificial Intelligence",
      "author" : [ "Hirofumi Katsuno", "Alberto O. Mendelzon. Propositional knowledge base revision", "minimal change" ],
      "venue" : "52(3):263–294,",
      "citeRegEx" : "Katsuno and Mendelzon 1992",
      "shortCiteRegEx" : null,
      "year" : 1992
    }, {
      "title" : "In Logics in Artificial Intelligence - 13th European Conference",
      "author" : [ "Patrick Krümpelmann", "Gabriele Kern-Isberner. Belief base change operations for answer set programming" ],
      "venue" : "JELIA 2012, Toulouse, France, September 26-28,",
      "citeRegEx" : "Krümpelmann and Kern.Isberner 2012",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "and Agustı́n Valverde",
      "author" : [ "Vladimir Lifschitz", "David Pearce" ],
      "venue" : "Strongly equivalent logic programs. ACM Trans. Comput. Logic, 2(4):526–541,",
      "citeRegEx" : "Lifschitz et al. 2001",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "In Proceedings of the International Conference on Fifth Generation Computer Systems",
      "author" : [ "Ken Satoh. Nonmonotonic reasoning by minimal belief revision" ],
      "venue" : "pages 455–462,",
      "citeRegEx" : "Satoh 1988",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "In Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR-2013)",
      "author" : [ "Nicolas Schwind", "Katsumi Inoue. Characterization theorems for revision of logic programs" ],
      "venue" : "pages 485–498,",
      "citeRegEx" : "Schwind and Inoue 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Strong equivalence made easy: Nested expressions and weight constraints",
      "author" : [ "Hudson Turner" ],
      "venue" : "Theory Pract. Log. Program., 3(4):609–622,",
      "citeRegEx" : "Turner 2003",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Belief revision has been studied mainly with respect to background logics that are monotonic in character. In this paper we study belief revision when the underlying logic is nonmonotonic instead—an inherently interesting problem that is under explored. In particular, we will focus on the revision of a body of beliefs that is represented as a logic program under the answer set semantics, while the new information is also similarly represented as a logic program. Our approach is driven by the observation that unlike in a monotonic setting where, when necessary, consistency in a revised body of beliefs is maintained by jettisoning some old beliefs, in a nonmonotonic setting consistency can be restored by adding new beliefs as well. We will define a syntactic revision function and subsequently provide representation theorem for charac-",
    "creator" : "LaTeX with hyperref package"
  }
}