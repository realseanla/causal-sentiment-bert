{
  "name" : "1505.02405.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Exploiting Resolution-based Representations for MaxSAT Solving",
    "authors" : [ "Miguel Neves", "Ruben Martins", "Mikoláš Janota", "Inês Lynce", "Vasco Manquinho" ],
    "emails" : [ "neves@sat.inesc-id.pt", "mikolas@sat.inesc-id.pt", "ines@sat.inesc-id.pt", "vmm@sat.inesc-id.pt", "ruben.martins@cs.ox.ac.uk" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Many real-world problems in different areas such as fault localization in C programs, design debugging, upgradability of software systems, among other, can be solved using Maximum Satisfiability (MaxSAT) [2,9,11,14,24]. The increase usage of MaxSAT for problem solving results from the improvements of MaxSAT technology in recent years. In the last decade, several new techniques and algorithms have been proposed that improved on previous MaxSAT solvers by several orders of magnitude. Moreover, the developments in the underlying SAT technology, namely identification of unsatisfiable subformulas and incrementality have also been a factor in the improvements of MaxSAT solving.\nMaxSAT solvers for industrial instances are usually based on iterative calls to a SAT solver. Moreover, most of these MaxSAT algorithms take advantage of the ability of SAT solvers to identify unsatisfiable subformulas. However, in most cases, algorithms deal with the whole formula at each call of the SAT solver. As a result, unnecessarily large unsatisfiable subformulas can be returned at each SAT call, resulting in a slow down of the MaxSAT algorithm. In this work, we\nar X\niv :1\n50 5.\n02 40\n5v 1\n[ cs\n.A I]\n1 0\nM ay\ntry to avoid this behavior by partitioning the formula and taking advantage of structural information obtained from a formula’s graph representation.\nIn this paper, we improve on the current state of the art MaxSAT solving by proposing a new unsatisfiability-based algorithm for MaxSAT. The new algorithm integrates several new features, namely: (1) usage of resolution-based graphs to represent the MaxSAT formula, (2) partition of soft clauses in the MaxSAT formula using the referred representation, (3) usage of structural information obtained from the graph representation to drive the merge of partitions and, (4) integration of these features into a new fully incremental algorithm that improves on the best non-portfolio solver from the last MaxSAT Solver Evaluation on several industrial benchmark sets.\nThe paper is organized as follows. Section 2 formally defines MaxSAT and briefly reviews the MaxSAT algorithms more closely related to the proposed approach. In section 3, graph representations of CNF formulas are described. Moreover, the adaptation of resolution-based graphs is proposed. The new MaxSAT algorithm is proposed in section 4. Besides a detailed description, we show how to extract structural information from the graph representations and integrate it in the new algorithm. Section 5 presents the experimental results of the new MaxSAT solver on a large set of industrial benchmark sets used at MaxSAT evaluations. Finally, the paper concludes in section 6."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "A propositional formula in Conjunctive Normal Form (CNF), using n Boolean variables x1, x2, . . . , xn, is defined as a conjunction of clauses, where a clause is a disjunction of literals. A literal is either a variable xi or its complement x̄i. The Propositional Satisfiability (SAT) problem consists of deciding whether there exists a truth assignment to the variables such that the formula is satisfied.\nThe Maximum Satisfiability (MaxSAT) can be seen as an optimization version of the SAT problem. In MaxSAT, the objective is to find an assignment to the variables of a CNF formula that minimizes the number of unsatisfied clauses. Notice that minimizing the number of unsatisfied clauses is equivalent to maximizing the number of satisfied clauses.\nIn a partial MaxSAT formula ϕ = ϕh ∪ ϕs, some clauses are considered as hard (ϕh), while others are declared as soft (ϕs). The goal in partial MaxSAT is to find an assignment to the formula variables such that all hard clauses in ϕh are satisfied, while minimizing the number of unsatisfied soft clauses in ϕs. There are also weighted variants of MaxSAT where soft clauses are associated with weights greater than or equal to 1. In this case, the objective is to satisfy all hard clauses and minimize the total weight of unsatisfied soft clauses. In this paper, we focus solely on partial MaxSAT, but the proposed approach can be generalized to its weighted variants. Furthermore, in all algorithms we assume that the set of hard clauses ϕh is satisfiable. Otherwise, the MaxSAT formula does not have a solution. This can easily be checked through a SAT call on ϕh.\nAlgorithm 1: Linear Search Unsat-Sat Algorithm Input: ϕ = ϕh ∪ ϕs Output: satisfying assignment to ϕ\n1 (ϕW , VR, λ)← (ϕh, ∅, 0) 2 foreach ωi ∈ ϕs do 3 VR ← VR ∪ {ri} // ri is a new relaxation variable 4 ωR ← ωi ∪ {ri} 5 ϕW ← ϕW ∪ {ωR} 6 while true do 7 (st, ν, ϕC)← SAT(ϕW ∪ {CNF( ∑ ri∈VR\nri ≤ λ)}) 8 if st = SAT then 9 return ν // satisfying assignment to ϕ\n10 λ← λ+ 1\nThe most recent state of the art MaxSAT solvers are based on iterative calls to a SAT solver. One of the most classic approaches is the linear Sat-Unsat algorithm that performs a linear search on the number of unsatisfied clauses. In this case, a new relaxation variable is initially added to each soft clause and the resulting formula is given to a SAT solver. Whenever a solution is found, a new cardinality constraint on the number of relaxation variables is added, such that solutions where a higher or equal number of relaxation variables assigned the value 1 are excluded. The cardinality constraint is encoded into a set of propositional clauses, which are added to the working formula [3,12,16]. The algorithm stops when the SAT call is unsatisfiable. As a result, the last solution found is an optimal solution of the MaxSAT formula.\nA converse approach is the linear search Unsat-Sat presented in Algorithm 1. Here, a lower bound λ is maintained between iterations of the algorithm. Initially, λ is assigned value 0. In each iteration, while the working formula given to the SAT solver (line 7) is unsatisfiable, λ is incremented (line 10). Otherwise, an optimal solution to the MaxSAT formula has been found (line 9).\nObserve that a SAT solver call on a CNF formula ϕW returns a triple (st, ν, ϕC), where st denotes the status of the solver: satisfiable (SAT) or unsatisfiable (UNSAT). If ϕW is satisfiable, then ν stores the model found for ϕW . Otherwise, ϕC contains an unsatisfiable subformula that explains a reason for the unsatisfiability of ϕW .\nSeveral of the most effective algorithms for MaxSAT take advantage of the current SAT solvers being able to produce certificates of unsatisfiability. Since the SAT solver is able to identify unsatisfiable subformulas, several MaxSAT algorithms use it to delay the relaxation of soft clauses. An example is the MSU3 algorithm [15] presented in Algorithm 2. Observe that this algorithm also performs an Unsat-Sat linear search, but soft clauses are only relaxed when they appear in an unsatisfiable subformula.\nAlthough more sophisticated MaxSAT algorithms exist [19], an implementation of MSU3 algorithm on the Open-WBO framework was the best performing\nAlgorithm 2: MSU3 Algorithm Input: ϕ = ϕh ∪ ϕs Output: satisfying assignment to ϕ\n1 (ϕW , VR, λ)← (ϕ, ∅, 0) 2 while true do 3 (st, ν, ϕC)← SAT(ϕW ∪ {CNF( ∑ ri∈VR\nri ≤ λ)}) 4 if st = SAT then 5 return ν // satisfying assignment to ϕ 6 foreach ωi ∈ (ϕC ∩ ϕs) do 7 VR ← VR ∪ {ri} // ri is a new variable 8 ωR ← ωi ∪ {ri} // ωi was not previously relaxed 9 ϕW ← (ϕW \\ {ωi}) ∪ {ωR}\n10 λ← λ+ 1\nnon-portfolio algorithm at the MaxSAT Solver Evaluation in 20143. One of the crucial features for its success relies on the fact that only one SAT solver instance needs to be created [16]. Therefore, a proper implementation of MSU3 should take advantage of incrementality in SAT solver technology. In this paper, the MSU3 algorithm is further improved with structural information of the problem instance to solve."
    }, {
      "heading" : "3 Graph Representations",
      "text" : "In order to extract structural properties of CNF formulas, different graph-based models have been previously proposed. For instance, graph representations have been used to characterize industrial SAT instances [1] and to improve on the performance of MaxSAT algorithms [18]. In this section, we briefly review the Clause-Variable Incidence Graph (CVIG) and adapt the use of Resolution-based Graphs (RES) [26] to model relations in CNF formulas. Although other models exist [1,25,18], in the context of our algorithm for MaxSAT solving, these were found to be the best suited.\nIn the CVIG model, a weighted undirected graph G is built such that a vertex is added for each variable xj and for each clause ωi occurring in the CNF formula ϕ. Moreover, for each variable xj occurring in clause ωi (either as literal xj or x̄j), an edge (ωi, xj) is added to graph G. The edge weight w(ωi, xj) is defined as:\nw(ωi, xj) = I(xj)\n|ωi| (1)\nwhere |ωi| denotes the number of literals in clause ωi and I(xj) is defined as the incidence function of xj in soft clauses as:\nI(xj) = 1 + ∑\nxj∈ω ∧ ω∈ϕs\n1\n|ω| (2)\n3 Results available at http://www.maxsat.udl.cat/\nAs described in section 2, several MaxSAT solvers rely on the identification of unsatisfiable subformulas. In order to capture sets of clauses more closely related that would result in an unsatisfiable subformula, we propose to adapt Resolution Graphs (RES) to MaxSAT.\nIn the RES model, we have one vertex in graph G for each clause ωi ∈ ϕ. Let ωi and ωj denote two clauses such that xk ∈ ωi and x̄k ∈ ωj . Moreover, let ωresij be the resulting clause of applying the resolution operation on these clauses. In this case, if ωresij is not a tautology, then an edge (ωi, ωj) is added to G whose weight is defined as:\nw(ωi, ωj) = 1\n|ωresij | (3)\nNotice that in the RES model, clauses are related if the application of the resolution operation results in a non-trivial resolvent. Moreover, observe that the weight of edges between pairs of clauses is greater when the size of the resolvent is smaller. The goal is to make tighter the relations between clauses that produce smaller clauses when resolution is applied.\nConsider the following MaxSAT formula where ω1 : (x1 ∨ x2), ω2 : (x̄2 ∨ x3) and ω3 : (x̄1 ∨ x̄3) are hard clauses and ω4 : (x̄1), ω5 : (x̄3) are soft clauses. Figures 1(a) and 1(b) illustrate the structure of the graph representation of this formula when using the CVIG and RES models. The weights of edges are not represented for simplicity. Observe that if the clause ω6 : (x̄1 ∨ x̄2) was added to the formula, it would not connect to any other clause in the RES graph because the only clause containing x1 positively is ω1 = (x1 ∨ x2), but that does not connect to ω6 due to x2 appearing negatively and positively in ω6 and ω1, respectively. A similar type of analysis is done in blocked clause elimination [13,10] — a technique commonly used in formula preprocessing.\nAlthough resolution-based graphs are not novel [26] and have been used in other domains [25], in this paper we propose to enhance the resolution-based graph representation by adding weights to edges. Moreover, as far as we know, this representation has never been used for MaxSAT solving."
    }, {
      "heading" : "4 New Partition-based Algorithm for MaxSAT",
      "text" : "Despite its very good performance in industrial partial MaxSAT instances, the MSU3 algorithm (see Algorithm 2) may suffer from two issues: (1) identification of unnecessarily large unsatisfiable subformulas and, (2) a potentially large cardinality constraint to be maintained between iterations. In fact these issues are related. If an unsatisfiable subformula with an unnecessarily large number of soft clauses is encountered early, then an unnecessarily large cardinality constraint has to be dealt with through most of the algorithm’s iterations.\nOur approach to tackle these issues is to split the set of soft clauses. The goal is that, at each iteration, the algorithm should only consider part of the problem, instead of dealing with the whole problem instance in each iteration."
    }, {
      "heading" : "4.1 Algorithm Description",
      "text" : "Algorithm 3 presents our enhancement of MSU3 with partition of the soft clause set. The algorithm starts by partitioning ϕs into n disjoint sets of soft clauses γ1, γ2 . . . γn (line 1). Observe that several methods can be used to partition ϕs. Details of this procedure are discussed later.\nFor each set γi, we apply the MSU3 algorithm to the formula ϕh∪γi (lines 2- 11). As a result, we obtain a lower bound value λi associated with each set of soft clauses γi. If the partitioning procedure creates a single partition, then the algorithm terminates (line 13). Otherwise, it is necessary to build the solution of the MaxSAT instance by merging the different sets of soft clauses.\nThe merge process works as follows. At each iteration, two sets of soft clauses γi and γj are selected to be merged (line 15) and removed from γ. Let γk denote the union of γi and γj . Since γi and γj are disjoint, we necessarily have that λi + λj is a lower bound for γk. Hence, we can safely initialize λk = λi + λj (line 17). Next, the lower bound λk is refined by applying the MSU3 algorithm to ϕh ∪ γk (lines 18-25). When set γ becomes empty, then all soft clauses were merged and the last solution found is an optimal solution (line 27). Otherwise, there are still more sets to be merged and γk is added to γ (line 29)."
    }, {
      "heading" : "4.2 Partition and Merge of Soft Clauses",
      "text" : "Algorithm 3 can be configured differently depending on two procedures: (1) how the set of soft clauses is partitioned (line 1) and (2) how to merge two sets of soft clauses (line 15).\nIn the partition procedure, our algorithm starts by representing the CNF formula as a graph using one of the models described in section 3. Next, we apply a community-finding algorithm on the graph representation that maximizes a modularity measure [4] in order to obtain a graph partitioning.\nRecently, the use of modularity measures has become widespread when analyzing the structure of graphs, in particular for the identification of communities [7,23]. In fact, this has already been used in the analysis of SAT instances [1] and to improve the initial unsatisfiability-based approach proposed by Fu and\nAlgorithm 3: Extended MSU3 Algorithm Input: ϕ = ϕh ∪ ϕs Output: satisfying assignment to ϕ\n1 γ ← 〈γ1, . . . , γn〉 ← partitionSoft(ϕs, ϕh) 2 foreach γi ∈ γ do 3 (V iR, λi)← (∅, 0) 4 (st, ϕC , ν)← SAT(ϕh ∪ γi) 5 while st = UNSAT do 6 foreach ω ∈ (ϕC ∩ ϕs) do 7 V iR ← V iR ∪ {r} // r is a new variable 8 ωR ← ω ∪ {r} // ω was not previously relaxed 9 γi ← (γi \\ {ω}) ∪ {ωR}\n10 λi ← λi + 1 11 (st, ϕC , ν)← SAT(ϕh ∪ γi ∪ {CNF( ∑ r∈V i\nR r ≤ λi)})"
    }, {
      "heading" : "12 if |γ| = 1 then",
      "text" : "13 return ν // no partitions were identified 14 while true do 15 (γi, γj)← selectPartitions(γ) 16 γ ← γ \\ {γi, γj} 17 (γk, V k R , λk)← (γi ∪ γj , V iR ∪ V jR, λi + λj)\n18 (st, ϕC , ν)← SAT(ϕh ∪ γk ∪ {CNF( ∑\nr∈V k R r ≤ λk)})\n19 while st = UNSAT do 20 foreach ω ∈ (ϕC ∩ ϕs) do 21 V kR ← V kR ∪ {r} // r is a new variable 22 ωR ← ω ∪ {r} // ω was not previously relaxed 23 γk ← (γk \\ {ω}) ∪ {ωR} 24 λk ← λk + 1 25 (st, ϕC , ν)← SAT(ϕh ∪ γk ∪ {CNF( ∑ r∈V k\nR r ≤ λk)})"
    }, {
      "heading" : "26 if γ = ∅ then",
      "text" : ""
    }, {
      "heading" : "27 return ν",
      "text" : ""
    }, {
      "heading" : "28 else",
      "text" : "29 γ ← γ ∪ {γk}\nMalik [6,18]. The purpose of the modularity measure is to evaluate the quality of the partitions, where vertices inside a partition should be densely connected and vertices assigned to different partitions should be loosely connected. However, finding a set of partitions with an optimal modularity value is computationally hard [5]. In our implementation, we use the approximation algorithm proposed by Blondel et al. [4].\nAt each iteration in Algorithm 3, two partitions are selected to be merged. One can devise several different criteria to select and merge the partitions of soft clauses. In early attempts, the merge process was sequential [18]. Given n partitions γ1, γ2 . . . γn, at iteration i (i ≤ n) of the algorithm, the first i partitions γ1, γ2 . . . γi were merged sequentially.\nFigure 2(a) illustrates the sequential merging procedure. Observe that the sequential merging process is not balanced. This results in an early growth of the identified subformulas and, as a result, an early growth of the cardinality constraints to be maintained at each iteration of the algorithm.\nIn this paper, we propose a weighted balanced merge procedure that depends on the strength of the graph connections between partitions. The goal is to delay having to deal with a large number of soft clauses, until the latter iterations of the algorithm. Figure 2(b) illustrates the weighted balanced merging procedure.\nLet G = (V,E) denote an undirected weighted graph where V is the set of vertices and E the set of edges. Let w : E → R be a weight function for each edge in the graph. The community-finding algorithm identifies a set of communities C = {C1, C2, . . . , Cn} where every vertex u ∈ V is assigned to one and only one community in C. Hence, since in both CVIG and RES model there is a node for each propositional clause, one can build the partitions in a straightforward manner. For each community Ci with vertices representing soft clauses, there is a partition γi containing the respective soft clauses.\nBased on the graph representation, one can define the strength of the connection between partitions. Let dij denote the strength between partition γi and γj . One can define dij based on the weight between the vertices of their respective communities Ci and Cj in the graph. Hence, dij can be defined as follows:\ndij = ∑\nu∈Ci∧v∈Cj\nw(u, v) (4)\nConsidering that the graph is undirected, we necessarily have that dij = dji. Given an initial set γ of n partitions γ1, γ2 . . . , γn, our algorithm applies a greedy procedure that pairs all partitions γi and γj from γ to be merged, starting with the pair with largest dij . After pairing all partitions in the initial set, we perform the same procedure to the next n/2 partitions that result from the initial merging iterations. This is iteratively applied until we only have a single partition (see Figure 2(b)).\nObserve that if partitions γi and γj are merged into a new partition γk, then the connectivity strength dkl between γk to another partition γl is given by\ndkl = dil + djl. This follows from the fact that the communities in the graph are disjoint.\nFinally, we would like to reference other solvers that split the set of soft clauses by identifying disjoint unsatisfiable subformulas [8,21]. However, there are major differences with regard to our proposed approach. First, our solver takes advantage of an explicit formula representation to split the set of soft clauses, instead of using the unsatisfiable subformulas provided by the SAT solver. Moreover, in our solver, the merge process is also guided by the explicit representation of the formula.\nFurthermore, in solvers where disjoint unsatisfiable subformulas are identified [8,21], the split occurs on the cardinality constraints at each iteration. However, each SAT call still has to deal with the whole formula at each iteration. In Algorithm 3, the SAT solver does not have to deal with all soft clauses at each iteration, but only after the final merge step."
    }, {
      "heading" : "4.3 Algorithm Analysis",
      "text" : "In this section a proof sketch of the correctness Algorithm 3, as well as an analysis on the number of SAT calls is presented.\nProof. As mentioned in section 2, we assume the set of hard clauses ϕh is satisfiable. Otherwise, the MaxSAT formula is unsatisfiable. This can be verified by a single SAT call on ϕh before applying Algorithm 3.\nFor the proof we adopt the following notation. For some set γi processed in Algorithm 3, we write γRi ⊆ ϕs for the set of clauses that were relaxed in the algorithm (but clauses in γRi do not contain the relaxation variables). We will prove by induction the invariant that ϕh ∪ γRi cannot be satisfied unless at least λi clauses are removed from γRi . The induction hypothesis is satisfied trivially at the beginning of the algorithm as each λi is initialized to 0.\nConsider the case where λi is augmented by 1 when ϕh∪γi∪{ ∑\nr∈V iR r ≤ λi}\nis unsatisfiable. Let ϕC be the obtained unsatisfiable subformula from the SAT call, let ϕRC ⊆ ϕs be the soft clauses of ϕC that appear as relaxed in γi and let ϕNC = ϕs ∩ ϕC be the rest of the soft clauses in the unsatisfiable subformula (not yet relaxed). From induction hypothesis ϕh ∪ϕRC cannot be satisfied unless at least λi clauses are removed from ϕRC ⊆ γRi . Since ϕC is an unsatisfiable subformula, it is impossible to satisfy ϕh ∪ ϕRC ∪ ϕNC by removing λi clauses from ϕRC . Now we need to also show that it is impossible to satisfy ϕh∪γRi ∪ϕNC by removing λi clauses from γRi ∪ ϕNC (this is the new set of relaxed clauses).\nLet us assume for contradiction that it is possible to satisfy γRi ∪ ϕNC by removing some set of clauses ξ s.t. |ξ| = λi. To show the contradiction we consider two cases: (1) ξ ⊆ γi and (2) ξ * γi. Case (1) yields an immediate contradiction as we would have not obtained unsatisfiability in the SAT call as it would be possible to satisfy ϕh ∪ γRi by removing λi clauses from γRi . For case (2) consider that there is a clause ω ∈ ξ s.t. ω is not yet relaxed, i.e. ω /∈ γR. This means that ϕh∪γRi is satisfiable after removing less than λi clauses, which is a contradiction with the induction hypothesis.\nTo show that the invariant is preserved by the merge operation, we observe that any merged γi and γj are disjoint and therefore so are γRi and γRj . In order to satisfy ϕh∪ (γRi ∪γRj ), both ϕh∪γRi , ϕh∪γRj must be satisfied. Consequently, at least λi + λj clauses must be removed from (γRi ∪ γRj ).\nut\nFinally, we note that the number of SAT calls performed by Algorithm 3 is larger than the MSU3 algorithm. Observe that the number of unsatisfiable SAT calls is the same for both algorithms. Let λ be the number of unsatisfiable soft clauses at any optimal solution of the MaxSAT instance. In this case, both algorithms perform λ unsatisfiable SAT calls. However, while MSU3 performs only one satisfiable SAT call, Algorithm 3 performs 2n−1, where n is the number of identified partitions (line 1)."
    }, {
      "heading" : "5 Experimental Results",
      "text" : "In this section we compare different configurations of Algorithm 3 with the top 3 non-portfolio solvers of the MaxSAT 2014 Evaluation’s partial MaxSAT category. The top 3 were Open-WBO’s MSU3 incremental algorithm [17,16], Eva500a [22] and MSCG [20]. The new partition-based algorithm is also implemented using the Open-WBO framework4.\nThe algorithms were evaluated running on the power set of the partial MaxSAT industrial instances of the MaxSAT evaluations of 2012, 2013 and 2014. For each instance, algorithms were executed with a timeout of 1800 seconds and a memory limit of 4 GB. Similar resource limitations were used during the last MaxSAT Evaluation of 2014. These tests were conducted on a machine with 4 AMD Opteron 6376 (2.3 GHz) and 128 GB of RAM, running Debian jessie.\nTable 1 presents the number of instances solved by each algorithm, per instance set. Besides MSU3, Eva500a and MSCG, results for the best 4 configurations of the partition-based enhanced MSU3 algorithm are shown. S-CVIG applies the sequential merging of partitions using the CVIG graph model. SRES also applies sequential merging, but using the RES graph model. W-CVIG and W-RES apply the weighted balanced merging of partitions, using the CVIG and RES graph models, respectively. Note that all our implementations are fully incremental, i.e. only one instance of the SAT solver is created throughout the execution of the proposed algorithm. As with the MSU3 implementation on Open-WBO, we take advantage of assumptions usage at each SAT call and incremental encoding of cardinality constraints [16].\nResults from Table 1 show that all variants of the partition-based algorithm are competitive with the remaining state of the art algorithms. However, overall results clearly show that W-RES outperforms all remaining algorithms, since it is able to solve more instances in total. Moreover, results for the configurations of partition-based algorithm also show that weight-based balanced merging of partitions is preferable to sequential partitioning. 4 Available at http://sat.inesc-id.pt/open-wbo/\nConsidering that MSU3 is our base solver, most gains occur in instance sets bcp/msp, bcp/syn and des. While in the bcp/syn and des instance sets, all partition-based configurations perform better, in bcp/msp the resolution-based graph partitioning allowed a significant performance boost.\nFigures 3(a) and 3(b) compare the results of S-RES and W-RES on the des and bcp/msp instance sets. In the des instances, the run time of sequential merging is slightly better, despite solving the same number of instances. Nevertheless, in the bcp/msp instance set the weight-based balanced merging used in W-RES clearly outperforms the sequential merging approach used in S-RES.\nIn Figures 4(a) and 4(b) we compare MSU3 and W-RES on the same benchmark sets. It can be observed that W-RES performs much better in these instances. In the des instance set, there are some instances where W-RES is not as fast, since there is some time spent in finding partitions and additional SAT calls. We note that there is always some time spent in building the graph, applying the community finding algorithm and splitting the set of soft clauses. However, this partitioning step is usually not very time consuming. Nevertheless, W-RES is able to scale better and solve more instances. In the bcp/msp instances, the proposed techniques allow W-RES to be much better than MSU3, as well as all other algorithms tested.\nResolution-based graph models performed worst in the bcp/fir category. It was observed that the overall modularity values obtained for the resolutionbased graphs were low in this particular instance set. As a result, the partitioning obtained for S-RES and W-RES in bcp/fir instances is not as meaningful as for other instance sets. Hence, when this occurs, it can deteriorate the algorithm’s\nperformance, since the partition-based algorithm performs more SAT calls than MSU3.\nFinally, Figure 5 shows a cactus plot with the run times of all algorithms considered in the experimental evaluation. Here we can observe that S-RES is much slower than W-RES, clearly showing the effectiveness of the newly proposed weight-based merging. Overall, W-RES clearly outperforms the remaining algorithms, being able to solve 700 instances in 300 seconds or less."
    }, {
      "heading" : "6 Conclusions and Future Work",
      "text" : "In this paper we exploit resolution-based graph representations of CNF formulas in order to develop a new state of the art algorithm for MaxSAT. In the proposed approach, soft clauses are initially partitioned in disjoint sets by analyzing the formula structure. The partitioning process is attained by applying a communityfinding algorithm on weighted resolution-based graphs. Next, at each iteration of the algorithm, partitions are merged using structural information from the graph representation until an optimal solution is found.\nThe proposed approach is novel in many aspects. First, the use of a resolutionbased graph representation allows to better model the interaction between clauses. Furthermore, instead of applying a sequential merging process, the graph representation is also used in a weight-based balanced merging procedure. Moreover, since the algorithm does not have to deal with the whole formula at each iteration, smaller unsatisfiable cores are identified. As a result from this process, smaller cardinality constraints are encoded into CNF at each iteration, thus improving the algorithm’s performance.\nExperimental results obtained in industrial partial MaxSAT instances clearly show the effectiveness of the proposed algorithm. As a result, our solver improves upon the best non-portfolio solver from the 2014 MaxSAT solver evaluation.\nThe source code of the new solver will become available as part of the OpenWBO framework. This will allow the research community to build upon the current work to further improve MaxSAT solving.\nAs future work, we propose to extend the proposed approach for weighted MaxSAT solving. Moreover, different model representations of CNF formulas are to be tested, as well as new techniques for building and merging partitions of soft clauses in MaxSAT formulas. Furthermore, the proposed techniques are not exclusive to MSU3 and can also be integrated into other MaxSAT algorithms. Additionally, these techniques can also be applied to other extensions of SAT."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This work was partially supported by the ERC project 280053, FCT grant POLARIS (PTDC/EIA-CCO/123051/2010), FCT grant AMOS (CMUP-EPB/TIC/0049/2013), and INESC-ID’s multiannual PIDDAC funding PEst-OE/EEI/LA0021/2013."
    } ],
    "references" : [ {
      "title" : "The Community Structure of SAT Formulas",
      "author" : [ "C. Ansótegui", "J. Giráldez-Cru", "J. Levy" ],
      "venue" : "International Conference on Theory and Applications of Satisfiability Testing. LNCS, vol. 7317, pp. 410–423. Springer",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Curriculum-based course timetabling with SAT and MaxSAT",
      "author" : [ "R. Asín", "R. Nieuwenhuis" ],
      "venue" : "Annals of Operations Research 218(1), 71–91",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Efficient CNF Encoding of Boolean Cardinality Constraints",
      "author" : [ "O. Bailleux", "Y. Boufkhad" ],
      "venue" : "Principles and Practice of Constraint Programming. LNCS, vol. 2833, pp. 108–122. Springer",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Fast unfolding of communities in large networks",
      "author" : [ "V. Blondel", "J. Guillaume", "R. Lambiotte", "E. Lefebvre" ],
      "venue" : "Journal of Statistical Mechanics 2008(10), P10008",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Maximizing modularity is hard",
      "author" : [ "U. Brandes", "D. Delling", "M. Gaertler", "R. Goerke", "M. Hoefer", "Z. Nikoloski", "D. Wagner" ],
      "venue" : "arXiv: physics, 0608255",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "On Solving the Partial MAX-SAT Problem",
      "author" : [ "Z. Fu", "S. Malik" ],
      "venue" : "International Conference on Theory and Applications of Satisfiability Testing. LNCS, vol. 4121, pp. 252–265. Springer",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Community structure in social and biological networks",
      "author" : [ "M. Girvan", "M.E.J. Newman" ],
      "venue" : "Proceedings of the National Academy of Sciences 99(12), 7821–7826",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "Core-Guided Binary Search Algorithms for Maximum Satisfiability",
      "author" : [ "F. Heras", "A. Morgado", "J. Marques-Silva" ],
      "venue" : "Burgard, W., Roth, D. (eds.) AAAI Conference on Artificial Intelligence. AAAI Press",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "PackUp: Tools for Package Upgradability Solving",
      "author" : [ "M. Janota", "I. Lynce", "V. Manquinho", "J. Marques-Silva" ],
      "venue" : "Journal on Satisfiability, Boolean Modeling and Computation 8(1/2), 89–94",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Blocked clause elimination",
      "author" : [ "M. Järvisalo", "A. Biere", "M. Heule" ],
      "venue" : "Tools and Algorithms for the Construction and Analysis of Systems. LNCS, vol. 6015, pp. 129–144. Springer",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Cause clue clauses: error localization using maximum satisfiability",
      "author" : [ "M. Jose", "R. Majumdar" ],
      "venue" : "Programming Language Design and Implementation. pp. 437– 446. ACM",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "QMaxSAT: A Partial MaxSAT Solver",
      "author" : [ "M. Koshimura", "T. Zhang", "H. Fujita", "R. Hasegawa" ],
      "venue" : "Journal on Satisfiability, Boolean Modeling and Computation 8(1/2), 95–100",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "On a generalization of extended resolution",
      "author" : [ "O. Kullmann" ],
      "venue" : "Discrete Applied Mathematics 96-97, 149–176",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "On Using Unsatisfiability for Solving Maximum Satisfiability",
      "author" : [ "J. Marques-Silva", "J. Planes" ],
      "venue" : "CoRR",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Incremental Cardinality Constraints for MaxSAT",
      "author" : [ "R. Martins", "S. Joshi", "V. Manquinho", "I. Lynce" ],
      "venue" : "Principles and Practice of Constraint Programming. LNCS, vol. 8656, pp. 531–548. Springer",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Open-WBO: a Modular MaxSAT Solver",
      "author" : [ "R. Martins", "V. Manquinho", "I. Lynce" ],
      "venue" : "International Conference on Theory and Applications of Satisfiability Testing. LNCS, vol. 8561, pp. 438–445. Springer",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Community-based partitioning for maxsat solving",
      "author" : [ "R. Martins", "V.M. Manquinho", "I. Lynce" ],
      "venue" : "International Conference on Theory and Applications of Satisfiability Testing. LNCS, vol. 7962, pp. 182–191. Springer",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Iterative and core-guided MaxSAT solving: A survey and assessment",
      "author" : [ "A. Morgado", "F. Heras", "M. Liffiton", "J. Planes", "J. Marques-Silva" ],
      "venue" : "Constraints 18(4), 478–534",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Core-Guided MaxSAT with Soft Cardinality Constraints",
      "author" : [ "A. Morgado", "C. Dodaro", "J. Marques-Silva" ],
      "venue" : "Principles and Practice of Constraint Programming. LNCS, vol. 8656, pp. 564–573. Springer",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Improvements to Core-Guided Binary Search for MaxSAT",
      "author" : [ "A. Morgado", "F. Heras", "J. Marques-Silva" ],
      "venue" : "Cimatti, A., Sebastiani, R. (eds.) International Conference on Theory and Applications of Satisfiability Testing. LNCS, vol. 7317, pp. 284–297. Springer",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Maximum Satisfiability Using Core-Guided MaxSAT Resolution",
      "author" : [ "N. Narodytska", "F. Bacchus" ],
      "venue" : "AAAI Conference on Artificial Intelligence. pp. 2717–2723. AAAI Press",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Finding and evaluating community structure in networks",
      "author" : [ "M.E.J. Newman", "M. Girvan" ],
      "venue" : "Physical Review E 69(026113)",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Improved design debugging using maximum satisfiability",
      "author" : [ "S. Safarpour", "H. Mangassarian", "A.G. Veneris", "M.H. Liffiton", "K.A. Sakallah" ],
      "venue" : "Formal Methods in Computer-Aided Design. pp. 13–19. IEEE Computer Society",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Variable independence and resolution paths for quantified boolean formulas",
      "author" : [ "A. Van Gelder" ],
      "venue" : "Principles and Practice of Constraint Programming. LNCS, vol. 6876, pp. 789–803. Springer",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Resolution graphs",
      "author" : [ "R.A. Yates", "B. Raphael", "T.P. Hart" ],
      "venue" : "Artificial Intelligence 1(4), 257–289",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1970
    } ],
    "referenceMentions" : [ {
      "referenceID" : 1,
      "context" : "Many real-world problems in different areas such as fault localization in C programs, design debugging, upgradability of software systems, among other, can be solved using Maximum Satisfiability (MaxSAT) [2,9,11,14,24].",
      "startOffset" : 204,
      "endOffset" : 218
    }, {
      "referenceID" : 8,
      "context" : "Many real-world problems in different areas such as fault localization in C programs, design debugging, upgradability of software systems, among other, can be solved using Maximum Satisfiability (MaxSAT) [2,9,11,14,24].",
      "startOffset" : 204,
      "endOffset" : 218
    }, {
      "referenceID" : 10,
      "context" : "Many real-world problems in different areas such as fault localization in C programs, design debugging, upgradability of software systems, among other, can be solved using Maximum Satisfiability (MaxSAT) [2,9,11,14,24].",
      "startOffset" : 204,
      "endOffset" : 218
    }, {
      "referenceID" : 22,
      "context" : "Many real-world problems in different areas such as fault localization in C programs, design debugging, upgradability of software systems, among other, can be solved using Maximum Satisfiability (MaxSAT) [2,9,11,14,24].",
      "startOffset" : 204,
      "endOffset" : 218
    }, {
      "referenceID" : 2,
      "context" : "The cardinality constraint is encoded into a set of propositional clauses, which are added to the working formula [3,12,16].",
      "startOffset" : 114,
      "endOffset" : 123
    }, {
      "referenceID" : 11,
      "context" : "The cardinality constraint is encoded into a set of propositional clauses, which are added to the working formula [3,12,16].",
      "startOffset" : 114,
      "endOffset" : 123
    }, {
      "referenceID" : 14,
      "context" : "The cardinality constraint is encoded into a set of propositional clauses, which are added to the working formula [3,12,16].",
      "startOffset" : 114,
      "endOffset" : 123
    }, {
      "referenceID" : 13,
      "context" : "An example is the MSU3 algorithm [15] presented in Algorithm 2.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 17,
      "context" : "Although more sophisticated MaxSAT algorithms exist [19], an implementation of MSU3 algorithm on the Open-WBO framework was the best performing",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 14,
      "context" : "One of the crucial features for its success relies on the fact that only one SAT solver instance needs to be created [16].",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 0,
      "context" : "For instance, graph representations have been used to characterize industrial SAT instances [1] and to improve on the performance of MaxSAT algorithms [18].",
      "startOffset" : 92,
      "endOffset" : 95
    }, {
      "referenceID" : 16,
      "context" : "For instance, graph representations have been used to characterize industrial SAT instances [1] and to improve on the performance of MaxSAT algorithms [18].",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 24,
      "context" : "In this section, we briefly review the Clause-Variable Incidence Graph (CVIG) and adapt the use of Resolution-based Graphs (RES) [26] to model relations in CNF formulas.",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 0,
      "context" : "Although other models exist [1,25,18], in the context of our algorithm for MaxSAT solving, these were found to be the best suited.",
      "startOffset" : 28,
      "endOffset" : 37
    }, {
      "referenceID" : 23,
      "context" : "Although other models exist [1,25,18], in the context of our algorithm for MaxSAT solving, these were found to be the best suited.",
      "startOffset" : 28,
      "endOffset" : 37
    }, {
      "referenceID" : 16,
      "context" : "Although other models exist [1,25,18], in the context of our algorithm for MaxSAT solving, these were found to be the best suited.",
      "startOffset" : 28,
      "endOffset" : 37
    }, {
      "referenceID" : 12,
      "context" : "A similar type of analysis is done in blocked clause elimination [13,10] — a technique commonly used in formula preprocessing.",
      "startOffset" : 65,
      "endOffset" : 72
    }, {
      "referenceID" : 9,
      "context" : "A similar type of analysis is done in blocked clause elimination [13,10] — a technique commonly used in formula preprocessing.",
      "startOffset" : 65,
      "endOffset" : 72
    }, {
      "referenceID" : 24,
      "context" : "Although resolution-based graphs are not novel [26] and have been used in other domains [25], in this paper we propose to enhance the resolution-based graph representation by adding weights to edges.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 23,
      "context" : "Although resolution-based graphs are not novel [26] and have been used in other domains [25], in this paper we propose to enhance the resolution-based graph representation by adding weights to edges.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 3,
      "context" : "Next, we apply a community-finding algorithm on the graph representation that maximizes a modularity measure [4] in order to obtain a graph partitioning.",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 6,
      "context" : "Recently, the use of modularity measures has become widespread when analyzing the structure of graphs, in particular for the identification of communities [7,23].",
      "startOffset" : 155,
      "endOffset" : 161
    }, {
      "referenceID" : 21,
      "context" : "Recently, the use of modularity measures has become widespread when analyzing the structure of graphs, in particular for the identification of communities [7,23].",
      "startOffset" : 155,
      "endOffset" : 161
    }, {
      "referenceID" : 0,
      "context" : "In fact, this has already been used in the analysis of SAT instances [1] and to improve the initial unsatisfiability-based approach proposed by Fu and",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 5,
      "context" : "Malik [6,18].",
      "startOffset" : 6,
      "endOffset" : 12
    }, {
      "referenceID" : 16,
      "context" : "Malik [6,18].",
      "startOffset" : 6,
      "endOffset" : 12
    }, {
      "referenceID" : 4,
      "context" : "However, finding a set of partitions with an optimal modularity value is computationally hard [5].",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 3,
      "context" : "[4].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 16,
      "context" : "In early attempts, the merge process was sequential [18].",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 7,
      "context" : "Finally, we would like to reference other solvers that split the set of soft clauses by identifying disjoint unsatisfiable subformulas [8,21].",
      "startOffset" : 135,
      "endOffset" : 141
    }, {
      "referenceID" : 19,
      "context" : "Finally, we would like to reference other solvers that split the set of soft clauses by identifying disjoint unsatisfiable subformulas [8,21].",
      "startOffset" : 135,
      "endOffset" : 141
    }, {
      "referenceID" : 7,
      "context" : "Furthermore, in solvers where disjoint unsatisfiable subformulas are identified [8,21], the split occurs on the cardinality constraints at each iteration.",
      "startOffset" : 80,
      "endOffset" : 86
    }, {
      "referenceID" : 19,
      "context" : "Furthermore, in solvers where disjoint unsatisfiable subformulas are identified [8,21], the split occurs on the cardinality constraints at each iteration.",
      "startOffset" : 80,
      "endOffset" : 86
    }, {
      "referenceID" : 15,
      "context" : "The top 3 were Open-WBO’s MSU3 incremental algorithm [17,16], Eva500a [22] and MSCG [20].",
      "startOffset" : 53,
      "endOffset" : 60
    }, {
      "referenceID" : 14,
      "context" : "The top 3 were Open-WBO’s MSU3 incremental algorithm [17,16], Eva500a [22] and MSCG [20].",
      "startOffset" : 53,
      "endOffset" : 60
    }, {
      "referenceID" : 20,
      "context" : "The top 3 were Open-WBO’s MSU3 incremental algorithm [17,16], Eva500a [22] and MSCG [20].",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 18,
      "context" : "The top 3 were Open-WBO’s MSU3 incremental algorithm [17,16], Eva500a [22] and MSCG [20].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 14,
      "context" : "As with the MSU3 implementation on Open-WBO, we take advantage of assumptions usage at each SAT call and incremental encoding of cardinality constraints [16].",
      "startOffset" : 153,
      "endOffset" : 157
    } ],
    "year" : 2015,
    "abstractText" : "Most recent MaxSAT algorithms rely on a succession of calls to a SAT solver in order to find an optimal solution. In particular, several algorithms take advantage of the ability of SAT solvers to identify unsatisfiable subformulas. Usually, these MaxSAT algorithms perform better when small unsatisfiable subformulas are found early. However, this is not the case in many problem instances, since the whole formula is given to the SAT solver in each call. In this paper, we propose to partition the MaxSAT formula using a resolution-based graph representation. Partitions are then iteratively joined by using a proximity measure extracted from the graph representation of the formula. The algorithm ends when only one partition remains and the optimal solution is found. Experimental results show that this new approach further enhances a state of the art MaxSAT solver to optimally solve a larger set of industrial problem instances.",
    "creator" : "LaTeX with hyperref package"
  }
}