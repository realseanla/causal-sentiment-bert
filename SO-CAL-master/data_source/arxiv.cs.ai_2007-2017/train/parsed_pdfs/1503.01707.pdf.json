{
  "name" : "1503.01707.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Mapping-equivalence and oid-equivalence of single-function object-creating conjunctive queries",
    "authors" : [ "Angela Bonifati", "Werner Nutt", "Riccardo Torlone", "Jan Van den Bussche" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 3.\n01 70\n7v 2\n[ cs\n.D B\n] 1\nIn this paper, we focus on the class of single-function object-creating conjunctive queries, or sifo CQs for short. The single function symbol can be used only once in the head of the query. We give a new characterization for oid-equivalence of sifo CQs that is simpler than the one given by Hull and Yoshikawa and places the problem in the complexity class NP. Our characterization is based on Cohen’s equivalence notions for conjunctive queries with multiplicities. We also solve the logical entailment problem for sifo CQs, showing that also this problem belongs to NP. Results by Pichler et al. have shown that logical equivalence for more general classes of SO tgds is either undecidable or decidable with as yet unknown complexity upper bounds."
    }, {
      "heading" : "1 Introduction",
      "text" : "Conjunctive queries form a natural class of database queries, which can be defined by combinations of selection, renaming, natural join, and projection. Much of the research on database query processing is focused on conjunctive queries; moreover, these queries are amenable to advanced optimizations because containment of conjunctive queries is decidable (though NP-complete). In this paper, we are interested in conjunctive queries extended with a facility for object creation.\nObject creation, also called oid generation or value invention, has been repeatedly proposed and investigated as a feature of query languages. This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation\n[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18]. In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].\nIn the present paper, we consider conjunctive queries (CQs) extended with object creation through the use of a single Skolem function, which can be used only once in the head of the query. We refer to such a query as a ‘sifo CQ’ (for single-function object-creating). The following example of a sifo CQ uses a Skolem function f :\nQ : Family(c, f(x, y)) ← Mother (c, x),Father (c, y).\nThe query introduces a new oid f(x, y) for every pair (x, y) of a woman x and a man y who have at least one child together; all children c of x and y are linked to the new oid in the result of the query (a relation called Family). As an example, if Mother(beth, anne) and Father(beth, adam) are two facts in the underlying database, then the result of the query includes the fact Family(beth, f (anne, adam)), where f (anne, adam) is the newly created oid. This oid will be shared by all the children having anne and adam as parents.\nIn this paper, we first revisit the problem of checking oid-equivalence of sifo CQs. Oid-equivalence has its origins in the theory of object-creating queries introduced by Abiteboul and Kanellakis [3]; it is the natural generalization of query equivalence in the presence of object creation.\nConsider for instance the following sifo CQ:\nQ′ : Family(c, g(x, y, x)) ← Mother (c, x),Father (c, y).\nIt is not hard to see that the result of Q′ has the same structure as the result of the query Q above. The query Q′ links all children c of the parents x and y to the oid g(x, y, x) that depends exactly on x and y. That is, two children in the result of Q are connected to the same oid if and only if they are connected to same oid in Q′, although the oids will be syntactically different. Therefore, we can conclude that Q and Q′ are oid-equivalent, which means that their results are identical on any input up to a simple isomorphism mapping the oids in one result to those in the other.\nHull and Yoshikawa [23] studied oid-equivalence (they called it ‘obscured equivalence’) for nonrecursive ILOG programs; the decidability of this problem is a long-standing open question. Nevertheless, for the case of ‘isolated oid creation’, to which sifo CQs belong, they have given a decidable characterization.\nWe give a new result relating oid-equivalence to equivalence of classical conjunctive queries under ‘combined’ bag-set semantics [14], which models the evaluation of CQs when query results and relations may contain duplicates of tuples. As a corollary, we obtain that oid-equivalence for sifo CQs belongs to NP, which does not follow from the Hull-Yoshikawa test. Obviously, then, oid-equivalence for sifo CQs is NP-complete, since equivalence of classical CQs without object creation is already NP-complete.\nObject creation is receiving renewed interest in the context of schema mappings [8, 18], which are formalisms describing how data structured under a\nsource schema are to be transformed into data structured under a target schema. Hence, it is instructive to view sifo CQs as schema mappings, simply by interpreting them as implicational statements. As an example, we may view query Q above as an implicational statement that relates a query over relations Mother and Father in the source schema to the relation Family in the target schema.\nFor standard CQs without object creation, two queries are equivalent if and only if they are logically equivalent as schema mappings [17]. For sifo CQs, we show that oid-equivalence implies logical equivalence, while the converse is not true.\nSifo CQs viewed as schema mappings belong to the class of so-called ‘nested dependencies’ [8], which belong in turn to the class of formulas called secondorder tuple-generating dependencies (SO-tgds [18]). For instance, consider again the sifo CQ Q above: it can be rewritten into the following SO-tgd:\n∃f∀x∀y∀c(Mother (c, x) ∧ Father(c, y) → Family(c, f(x, y))),\nwhich is of second order because the function f is existentially quantified. Although logical equivalence of SO-tgds is undecidable [19], logical implication of nested dependencies has recently been shown to be decidable [26]. We give a novel and elegant characterization of logical implication for sifo CQs which is simpler than the general implication test for nested dependencies. It turns out that the problem belongs to NP. Hence, logical implication for sifo CQs has no worse complexity than containment for standard CQs without object creation.\nSummarizing, in this paper we provide the following contributions in the area of query languages with object creation:\n1. We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].\n2. We relate the problem of oid-equivalence for sifo CQs to the equivalence of classical conjunctive queries under combined bag-set semantics, which implies its NP-completeness.\n3. We show that when sifo CQs are interpreted as schema mappings, oidequivalence implies logical equivalence but not vice versa.\n4. We provide a new characterization of logical implication for sifo CQs as object-creating queries showing that this problem has the same complexity as deciding containment for classical CQs.\nThis paper is organized as follows. In Section 2 we review some practical applications of sifo CQs. In Section 3 we formally define object-creating conjunctive queries. Section 4 is devoted to the results on oid equivalence. Section 5 is devoted to the results on logical entailment. In Section 6 we conclude by discussing related work and topics for further research."
    }, {
      "heading" : "2 Applications of sifo CQs",
      "text" : "In this section, we discuss further applications of sifo CQs, which may constitute important components of many advanced database systems, spanning from information integration and schema mapping engines along with their benchmarks, to several Semantic Web tools. We believe this shows that the results in this article on equivalence and logical implication of sifo CQs are relevant and contribute to our understanding of how solutions for these applications can be optimized.\nGAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ. More precisely, a GAV mapping can be written as follows:\nT (x̄) ← B\nwhere we use a relation symbol T as the atomic head predicate. GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources. In both systems, source facts are related to facts over the global schema by means of queries.\nSifo CQs can naturally be seen as extensions of GAV mappings, when one of the attributes of the global schema carries newly created identifiers. For instance, the sifo CQ Q from Section 1 can express a mapping from a source schema containing two relations Mother and Father to one relation Family of a global schema, with created identifiers for families appearing in the tuples in the result of the mapping. Thus, we can also interpret Q as an extended GAV schema mapping.\nAnother important application of sifo CQs are schema mapping benchmarks allowing the users to compare and evaluate schema mapping systems. In particular, the flexibility of the arguments of the Skolem functions used for object creation has been advocated as one of the desirable features in recent benchmarks for schema mapping and information integration, such as STBenchmark [6] and iBench [9].\nMore precisely, in the mapping primitives of iBench [9], an extension of STBenchmark [6] that supports SO-tgds, the users can choose among two different skolemization strategies to fill the arguments of the Skolem functions: fixed, where the arguments of the function are pre-defined in a native mapping primitive, or variable, where one can further choose among the options All, Key, and Random, which generate mappings where all variables, the variables in the positions of the primary key, or a random set of variables, respectively, are used as arguments of the function.\nThese skolemization strategies can be captured by sifo CQs as follows. In the query below:\nT (x, y, f(x, y, z, w)) ← B(x, y, z, w)\nwe can observe that the Skolem term uses all the source variables in the body B (option All). If the attribute in the position of x is a primary key for B, then\nthe application of the option Key generates a mapping that can be expressed by the sifo CQ\nT (x, y, f(x)) ← B(x, y, z, w).\nAlternatively, choosing the option Random may lead the iBench to randomly select the attributes in the positions of x and z, and then to generate the mapping represented by\nT (x, y, f(x, z)) ← B(x, y, z, w).\nIt is also worth highlighting that three out of the seven mapping primitives in iBench that are novel with respect to STBenchmark, namely ADD (copy a relation and ADD new attributes), ADL (copy a relation, Add and DeLete attributes in tandem) and MA (Merge and Add new attributes) contain single Skolem functions. They correspond to the following sifo CQs, respectively:\nT (x, y, f(x, y)) ← B(x, y)\nT (x, f(x)) ← B(x, y)\nT (x, y, z, f(x, y, z)) ← B(x, y), T (y, z).\nA third significant application of sifo CQs is the Semantic Web, where sifo CQs can be envisioned in at least two scenarios, namely in systems for ontologybased data access (OBDA) and in direct mappings from the relational to the RDF data format, under development at W3C.1 Indeed, newly created identifiers in the head of a sifo CQ can serve as generated keys, or simply as newly invented values needed to fill an attribute of a relation in the global schema. As such, sifo CQs can be seen as examples of mapping assertions from source schemas to a global ontology in OBDA [31]. Typically, OBDA mapping assertions relate facts in relational source schemas to RDF triples in a global ontology. The newly generated IRIs2 in the RDF triples can be interpreted as skolemized values in the global ontology.\nA related application is the direct translation of a relational schema into OWL, which uses as an important building block the creation of IRIs [32]. In contrast to the previous application, this application handles relational schemas that are not known in advance. For each relation r in a database schema, Datalog-like rules can be used to generate an IRI for the relation r and an IRI for each attribute a in r. We take an example of a translation from a relational schema into OWL and we show that, actually, these Datalog-like rules can be viewed as sifo CQs, since they employ a single concatenation function to obtain such IRIs (exemplified as f). The corresponding sifo CQs are reported below:\nT1(r, f(b, r)) ← B1(r)\nT2(a, r, f(b, r, a)) ← B2(r, a),\n1http://www.w3.org/TR/rdb-direct-mapping/ 2IRIs stand for Internationalized Resource Identifiers and extend the syntax of URIs (Uniform Resource Identifiers) to a much wider repertoire of characters. They naturally embody global identifiers that refer to the same resource on the Web and can be used across different mapping assertions to refer to that resource.\nwhere B1 and B2 are conjunctive query bodies retrieving relation names r and attribute names a from the data dictionary of an underlying relational database, and where b is a string representing a given IRI base (e.g., the string ‘http://example.edu/db’) for the same database to be translated. Thus, the first query creates a new IRI for the relation r, by concatenating b with the relation symbol r, while the second query returns the set of IRIs of the attributes a of r, by concatenating b with the relation symbol r and its attribute symbols a."
    }, {
      "heading" : "3 Preliminaries",
      "text" : "In this section we introduce our formalism for dealing with conjunctive queries and introduce the notion of object-creating conjunctive query, adapted from the language ILOG [22]."
    }, {
      "heading" : "3.1 Databases and conjunctive queries",
      "text" : "From the outset we assume a supply of relation names, where each relation name R has an associated arity ar(R). We also assume an infinite domain dom of atomic data elements called constants. A fact is of the form R(a1, . . . , ak) where a1, . . . , ak are constants and R is a k-ary relation name. We call R the predicate of the fact.\nA database schema S is a finite set of relation names. An instance of S is a finite set of facts with predicates from S. The set of all constants appearing in an instance I is called the active domain of I and denoted by adom(I).\nWe further assume an infinite supply of variables, disjoint from dom. An atom is of the form R(x1, . . . , xk) where x1, . . . , xk are variables and R is a k-ary relation name. As with facts, we call R the predicate of the atom.\nWe can now recall the classical notion of conjunctive query (CQ) [2, 13]. Syntactically, a CQ over a database schema S is of the form\nH ← B,\nwhere B is a finite set of atoms with predicates from S, and H is an atom with a predicate not in S. The set B is called the body and H is called the head. It is required that every variable occurring in the head also occurs in the body. We denote the set of variables occurring in a set of atoms B (or a single atom A) by var(B) (or var(A)).\nThe semantics of CQs is defined in terms of valuations. A valuation is a mapping α : X → dom on some finite set of variables X . When A is an atom with var(A) ⊆ X , we can apply α to A simply by applying α to every variable in A. This results in a fact and is denoted by α(A). When B is a set of atoms and α is a valuation on var(B), we can apply α to B by applying α to every atom in B. Formally, α(B) is defined as the instance {α(A) | A ∈ B}.\nWhen I is an instance and α is a valuation on var(B) such that α(B) ⊆ I, we say that α is a matching of B in I, and denote this by α : B → I. Now when\nQ is a CQ H ← B and I is an instance, the result of Q on I is defined as\nQ(I) := {α(H) | α : B → I}."
    }, {
      "heading" : "3.2 Object-creating conjunctive queries",
      "text" : "Assume a finite vocabulary of function symbols of various arities. As with relation names, the arity of a function symbol f is denoted by ar(f).\nData terms are syntactical expressions built up from constants using function symbols. Formally, data terms are inductively defined as follows:\n1. Every constant is a data term;\n2. If f is a k-ary function symbol and d1, . . . , dk are data terms, then the expression f(d1, . . . , dk) is also a data term. 3\nAn extended fact is defined just like a fact, except that it may contain data terms rather than only constants. Formally, an extended fact is of the form R(d1, . . . , dk), where d1, . . . , dk are data terms and R is a k-ary relation name. The active domain of an extended fact e = R(d1, . . . , dk) is defined as\nadom(e) := {d1, . . . , dk}.\nAn extended instance is a finite set of extended facts. The active domain of an extended instance J is defined as\nadom(J) := ⋃\ne∈J\nadom(e).\nFormula terms are defined in the same way as data terms, but are built up from variables rather than constants. Extended atoms are defined like atoms, but can contain formula terms in addition to variables. If t is a formula term and α is a valuation defined on all variables occurring in t, we can apply α to every variable occurrence in t, obtaining a data term α(t). Likewise, we can apply a valuation to an extended atom, resulting in an extended fact.\nWe are now ready to define the syntax and semantics of object-creating conjunctive queries (oCQ). Like a classical CQ, an oCQ is of the form H ← B. The only difference with a classical CQ is that H can be an extended atom; in particular, B is still a finite set of “flat” atoms, not extended atoms. It is still required that var(H) ⊆ var(B). The result of an oCQ Q = H ← B on an instance I is now an extended instance, defined as\nQ(I) := {α(H) | α : B → I}.\n3Since constants are atomic data elements, no constant is allowed to be of the form f(d1, . . . , dk).\nExample 3.1. Recall the oCQ Q from the Introduction:\nFamily(c, f(x, y)) ← Mother (c, x),Father (c, y).\nIf I is the instance consisting of the Mother and Father facts listed in Table 1, then Q(I) is the extended instance consisting of the extended Family facts listed in the same table.\nExample 3.2. For a more abstract example, consider the following oCQ Q:\nT (x, f(y)) ← R(x, y, z).\nIf I is the instance consisting of the R-facts listed in Table 2, then Q(I) consists of the extended T -facts listed in the same table."
    }, {
      "heading" : "3.3 The single-function case",
      "text" : "In this paper, we focus on single-function oCQs (sifo CQs), that have exactly one occurrence of a function symbol in the head. Without loss of generality we always place the function term in the last position of the head.\nDefinition 3.3. A sifo CQ over a database schema S is an oCQ over S of the form\nT (x̄, f(z̄)) ← B,\nwhere\n• T is the head predicate;\n• f is a function symbol;\n• B is the body;\n• x̄ is a tuple of (not necessarily distinct) variables from var(B), called the distinguished variables ;\n• z̄ is a tuple of (not necessarily distinct) variables from var(B), called the creation variables ; some creation variables may be distinguished;\n• The elements of var(B) that are not distinguished are called the nondistinguished variables.\nExample 3.4. The queries in Examples 3.1 and 3.2 are both examples of sifo CQs."
    }, {
      "heading" : "3.4 Comparison with ILOG",
      "text" : "Object-creating CQs can be considered to be the conjunctive-query fragment of nonrecursive ILOG [22]; our syntax exposes the Skolem functions, which are normally obscured in the standard ILOG syntax, and our semantics corresponds to what is called the ‘exposed semantics’ by Hull and Yoshikawa. Nevertheless, in the following section, we will consider oid-equivalence of sifo CQs, which does correspond to what has been called ‘obscured equivalence’ [23]."
    }, {
      "heading" : "4 Characterization of oid-equivalence for sifo CQs",
      "text" : ""
    }, {
      "heading" : "4.1 Oid-equivalence of oCQs",
      "text" : "The result Q(I) of an oCQ Q applied to an instance I is an extended instance. The data terms in adom(Q(I)) that are not constants play the role of created oids (also called invented values). Intuitively it is clear that the actual form of the created oids does not matter.\nExample 4.1. Recall the query Q from Example 3.1:\nFamily(c, f(x, y)) ← Mother (c, x),Father (c, y).\nAs mentioned in the Introduction, we could have used equivalently the following query Q′:\nFamily(c, g(x, y, x)) ← Mother (c, x),Father (c, y).\nApplying the above query to the Mother and Father facts from Table 1 results in the instance shown in Table 3. Intuitively, this instance has exactly the same\nrelevant properties as the Family-instance from Table 1: beth and ben are linked to the same family-oid; eric is linked to another oid; and emma to still another one.\nWe formalize this intuition in the following definitions.\nDefinition 4.2. Let J be an extended instance.\n• The set adom(J)− dom is denoted by oids(J);\n• The set adom(J) ∩ dom is denoted by consts(J).\nDefinition 4.3. Let J be an extended instance and let ρ be a mapping from adom(J) to the set of data terms. For any extended fact e = R(d1, . . . , dk) in J , we define ρ(e) to be the extended fact R(ρ(d1), . . . , ρ(dk)). We then define ρ(J) := {ρ(e) | e ∈ J}.\nDefinition 4.4. Let J1 and J2 be extended instances. Then J1 and J2 are called oid-isomorphic if there exists a bijection ρ : adom(J1) → adom(J2) such that\n• ρ is the identity on consts(J1);\n• ρ maps oids(J1) to oids(J2);\n• ρ(J1) = J2.\nSuch a bijection ρ is called an oid-isomorphism from J1 to J2.\nThe above definition implies that oid-isomorphic instances have the same constants. Formally, if J1 and J2 are oid-isomorphic then consts(J1) = consts(J2).\nDefinition 4.5. Let Q and Q′ be two oCQs with the same head predicate, and over the same database schema S. Then Q and Q′ are called oid-equivalent if for every instance I over S, the results Q(I) and Q′(I) are oid-isomorphic.\nExample 4.6. The queries in Example 4.1 are oid-equivalent. For example, for the instance I of Table 1, the oid-isomorphism from Q(I) to Q′(I) is as follows:\nf(anne, adam) 7→ g(anne, adam, anne) f(claire, carl) 7→ g(claire, carl, claire) f(diane, carl) 7→ g(diane, carl, diane).\nExample 4.7. Recall the query Q from Example 3.2:\nT (x, f(y)) ← R(x, y, z)\nAlso consider the following variation Q′ of Q:\nT (x, f(x, y)) ← R(x, y, z)\nThen Q and Q′ are not oid-equivalent, as shown by the simple instances in Table 4. Indeed, there cannot be an oid-isomorphism fromQ(I) toQ′(I) because Q(I) contains only one distinct oid while Q′(I) contains two distinct oids.\nExample 4.8. As a variant of Example 4.7, consider the following two oCQs:\nQ = T (x, f(x)) ← R(x, y, z)\nQ′ = T (x, f(x, y, z)) ← R(x, y, z)\nAgain these two oCQs are not oid-equivalent, as shown by the counterexample instances in Table 5."
    }, {
      "heading" : "4.2 Homomorphisms and containment of conjunctive queries",
      "text" : "The characterizations we will give for oid-equivalence of sifo CQs depend on the classical notions of homomorphism and containment between conjunctive queries. Let us briefly recall these notions now [13, 2].\nA variable mapping is a mapping h from a finite set X of variables to another finite set Y of variables. If A is an atom with variables in X , then we can apply h to each variable occurrence in A to obtain an atom with variables in Y , which we denote by h(A). If B is a set of atoms with var(B) ⊆ X , then we naturally define h(B) := {h(A) | A ∈ B}.\nFor two sets B and B′ of atoms, a variable mapping h : var(B) → var(B′) is called a homomorphism from B to B′ if h(B) ⊆ B′. This is denoted by h : B → B′. The notion of homomorphism is extended to conjunctive queries Q = H ← B and Q′ = H ′ ← B′ as follows. A homomorphism from Q to Q′ is a homomorphism h : B → B′ such that h(H) = H ′. This is denoted by h : Q → Q′.\nA classical result relates homomorphisms between conjunctive queries to containment. Let Q and Q′ be two conjunctive queries over a common database schema S. We say that Q′ is contained in Q if for every instance I of S, we\nhave Q′(I) ⊆ Q(I). The classical result states that Q′ is contained in Q if and only if there exists a homomorphism h : Q → Q′.\nTwo queries Q and Q′ are equivalent if for every instance I of S, we have Q(I) = Q′(I). Since equivalence amounts to containment in both directions, two conjunctive queries are equivalent if and only if there exist homomorphisms between them in both directions."
    }, {
      "heading" : "4.3 A normal form for oid-equivalence problems",
      "text" : "In this subsection we consider two arbitrary sifo CQs Q, Q′ with the same head predicate:\nQ = T (x̄, f(z̄)) ← B\nQ′ = T (x̄′, f ′(z̄′)) ← B′.\nThen x̄ and x̄′ have equal length. Note that x̄ and z̄ as well as x̄′ and z̄′ may have variables in common.\nOur aim is to show that oid-equivalence between arbitrary sifo CQs Q and Q′ can be reduced to the case where the heads"
    }, {
      "heading" : "T (x̄, f(z̄)) and T (x̄′, f ′(z̄′))",
      "text" : "have identical arguments, that is, where x̄ = x̄′ and z̄ = z̄′. As a first lemma we state that rearranging the creation variables of a query does not affect oid-equivalence.\nLemma 4.9 (Rearranging creation variables). Let Q be a sifo CQ written as above. Let ū be a tuple with exactly the same variables as z̄, but possibly with different repetitions and a different ordering, and let g be a function symbol whose arity is equal to the length of ū. Then the sifo CQ P = T (x̄, g(ū)) ← B is oid-equivalent to Q.\nProof. Let I be an instance. We define an oid isomorphism from Q(I) to P (I) as follows. Any oid o in Q(I) is of the form f(α(z̄)) for some matching α : B → I; we define ρ(o) := g(α(ū)). This is well-defined, i.e., independent of the choice of α. Indeed, if the data terms f(α1(z̄)) and f(α2(z̄)) are equal, then the tuples α1(z̄) and α2(z̄) are equal, which implies that α1 and α2 agree on every variable appearing in z̄. Since exactly the same variables appear in ū, also the tuples α1(ū) and α2(ū) are equal, whence g(α1(ū)) = g(α2(ū)).\nThat ρ : oids(Q(I)) → oids(P (I)) is injective is shown by an analogous argument. The surjectivity of ρ, as well as the equality ρ(Q(I)) = P (I), are clear.\nBy the above lemma, we can remove all duplicates from z̄ and z̄′ in the heads of Q and Q′, respectively. So, from now on we may assume z̄ and z̄′ have no duplicates.\nIn the following, let Z equal the set of variables occurring in z̄, let X equal the set of variables occurring in x̄, and let Z ′ and X ′ be defined similarly.\nWe next show that two sifo CQs can only be oid-equivalent if they have identical patterns of distinguished variables, up to renaming.\nLemma 4.10 (Renaming distinguished variables). If Q and Q′ are oid-equivalent, then there exists a bijective variable mapping σ : X → X ′ such that σ(x̄) = x̄′.\nProof. Certainly, if Q and Q′ are oid-equivalent, then the conjunctive queries Q0 = T0(x̄) ← B and Q ′ 0 = T0(x̄\n′) ← B′, where T0 is a new predicate symbol, are equivalent. So, there are homomorphisms h : Q0 → Q ′ 0 and h\n′ : Q′0 → Q0. In particular, h(x̄) = x̄′ and h′(x̄′) = x̄. We define σ to be the restriction of h to X . The claim σ(x̄) = x̄′ and the surjectivity of σ are then clear. So it remains to show that σ is injective. Thereto, consider h′(σ(x̄)) = h′(h(x̄)) = h′(x̄′) = x̄. We see that h′ ◦ σ is the identity on X and thus injective. Hence, σ must be injective as well.\nBy the above lemma, if there does not exist a renaming σ as in the lemma, certainly Q and Q′ are not oid-equivalent. If there exists such a renaming, then by renaming the variables in one of the two queries, we can now assume without loss of generality that x̄ = x̄′ and in particular that X = X ′.\nThe next step is to show that oid-equivalent queries must have the same distinguished variables among the creation variables, that is, X ∩ Z = X ∩ Z ′.\nLemma 4.11 (Distinguished creation variables). If X ∩ Z 6= X ∩ Z ′, then Q and Q′ are not oid-equivalent.\nProof. Either there exists some x ∈ X ∩ Z but not in Z ′ or vice versa. By symmetry we may assume the first possibility.\nWe construct an instance I from B′. In doing this, to keep our notation simple, we consider the variables in B′ to be constants. The instance I is obtained from B′ by duplicating x to some new element x2. Formally, consider the mapping d on var(B′) that is the identity everywhere except that x is mapped to x2; then I = B\n′ ∪ d(B′). First, let us look at Q′(I). Using the identity matching that maps every variable to itself, we obtain the extended fact T (x̄, f ′(z̄′)) ∈ Q′(I). Using the matching d defined above, we obtain the extended fact T (x̄2, f\n′(d(z̄′))) in Q′(I). Here, x̄2 denotes d(x̄), i.e., x̄2 is obtained from x̄ by replacing x with x2. Since x does not belong to Z ′, we have d(z̄′) = z̄′, so T (x̄2, f\n′(z̄′)) ∈ Q′(I). On the other hand, inQ(I) consider any two extended facts T (α1(x̄), f(α1(z̄)))\nand T (α2(x̄), f(α2(z̄))), with matchings α1 : B → I and α2 : B → I, such that α1(x̄) = x̄ and α2(x̄) = x̄2. Then in particular α1(x) = x and α2(x) = x2. Since α1 and α2 differ on x, and x is in Z, also α1(z̄) and α2(z̄) are different. Hence, the two last components f(α1(z̄)) and f(α2(z̄)) are different. Thus, we see that in Q(I) it is impossible to have two extended atoms T (x̄, o) and T (x̄2, o) with the same oid o. But we have seen this is possible in Q′(I), so Q(I) and Q′(I) are not oid-isomorphic and Q and Q′ cannot be oid-equivalent.\nBy the above Lemma we now assume X ∩ Z = X ∩ Z ′. The last step is to show that Z −X and Z ′ −X , the sets of non-distinguished creation variables, need to have the same cardinality.\nLemma 4.12 (Non-distinguished creation variables). If Z−X and Z ′−X have different cardinality then Q and Q′ are not oid-equivalent.\nProof. As in the proof of Lemma 4.11, we consider B as an instance, viewing variables as constants.\nLet k and k′ be the cardinalities of Z − X and Z − X ′, respectively. By symmetry we may assume that k > k′. Now, for any natural number n, let In be the instance obtained from B by independently multiplying each variable z ∈ Z − X into n fresh copies z(1), . . . , z(n). Formally, for any function d : Z−X → {1, . . . , n}, let d̂ be the valuation on var(B) that maps each z ∈ Z−X to z(d(z)) and that is the identity on all other variables. Then\nIn = ⋃\nd:Z−X→{1,...,n}\nd̂(B).\nThere are nk different functions d : Z−X → {1, . . . , n}. Each corresponding\nvaluation d̂ is a matching of B in In; all these matchings are the identity on x̄ but are pairwise different on z̄. Thus there are at least nk different extended facts in Q(In) of the form T (x̄, o).\nOn the other hand, consider any set S of valuations from X∪Z ′ to adom(In) that are pairwise different on Z ′ −X but that all agree on X . The cardinality of Z ′ −X is k′. The cardinality of adom(In) is O(n) (although the cardinality of In itself is larger). Hence, such a set S can be of cardinality at most O(n\nk′ ). Consequently, since k > k′, for n large enough, Q′(In) cannot possibly contain nk different extended facts of the form T (x̄, o). But we saw that this is possible in Q(In). So, Q(In) and Q ′(In) are not oid-isomorphic and Q and Q ′ cannot be oid-equivalent.\nBy the above lemma, and after renaming the variables in Z ′−X and reordering the variables in z̄′, we may now indeed assume that z̄ and z̄′ are identical."
    }, {
      "heading" : "4.4 Characterization of oid-equivalence",
      "text" : "According to the results of the preceding subsection, we are now given two sifo CQs as follows:\nQ = T (x̄, f(z̄)) ← B (1)\nQ′ = T (x̄, f ′(z̄)) ← B′. (2)\nNote that Q and Q′ have identical tuples x̄ and z̄ of distinguished and creation variables; moreover, z̄ contains no variable more than once. As before, we denote the sets of distinguished and creation variables as X and Z, respectively.\nWe will show that Q and Q′ are oid-equivalent if and only if there are homomorphisms between B and B′ in both directions that (i) keep x̄ fixed and (ii) possibly permute the variables in z̄. To make this formal, we associate to each query a classical CQ without function symbols.\nDefinition 4.13. Fix a new relation symbol T̊ of arity the sum of the lengths of x̄ and z̄. The flattening of Q is the query Q̊ = T̊ (x̄, z̄) ← B. The query Q̊′ is defined similarly.\nLet π be a permutation of the set Z−X . We extend π to var(B) by defining it to be the identity outside Z − X . We now define Q̊π to be the conjunctive query obtained from Q̊ by permuting the variables in z̄, that is\nQ̊π = T̊ (x̄, π(z̄)) ← B.\nThis notion allows us to formulate the following natural sufficient condition for oid-equivalence.\nProposition 4.14. If there exists a permutation π of Z −X such that Q̊π and Q̊′ are equivalent, then Q and Q′ are oid-equivalent.\nProof. Let I be an instance. We define an oid isomorphism ρ from Q(I) to Q′(I) as follows. Any oid o in Q(I) is of the form f(α(z̄)) for some matching α : B → I; we define ρ(o) := f ′(α(π(z̄))). This is well-defined, i.e., independent of the choice of α. Indeed, if the data terms f(α1(z̄)) and f(α2(z̄)) are equal, then the tuples α1(z̄) and α2(z̄) are equal, and consequently the permuted tuples α1(π(z̄)) and α2(π(z̄)) are equal. Hence, f ′(α1(π(z̄))) = f ′(α2(π(z̄))).\nThe injectivity of ρ : oids(Q(I)) → oids(Q′(I)) is shown by an analogous argument. The surjectivity of ρ, and the equality ρ(Q(I)) = Q′(I), follow readily from the equality Q̊π(I) = Q̊′(I).\nWe next prove that the sufficient condition given by the above Proposition is actually also necessary for oid-equivalence. The key idea for proving this is to show that oid-equivalence of sifo CQs depends only on the number of oids generated for any binding of the distinguished variables.\nFormally, for any instance I and any tuple c̄ of elements from adom(I), we define\n#c̄(Q, I) := #{ o | T (c̄, o) ∈ Q(I) },\nthat is, #c̄(Q, I) denotes the number of distinct oids o that occur together with c̄ in Q(I). We will show that Q and Q′ are oid-equivalent if and only if #c̄(Q, I) = #c̄(Q\n′, I) for all instances I and tuples c̄. The only-if direction of this statement is obvious, but the if-direction is not so obvious.\nFor our proof, we rely on work by Cohen [14] who studied queries with multiset variables that are evaluated under so-called combined semantics, a semantics that combines set and multiset semantics. Cohen characterized equivalence of such queries in terms of homomorphisms.\nQueries with multiset variables (MV queries) have the form Q0,M where Q0 is a standard CQ and M is some set of variables of Q0 that do not appear in the head of Q0. The elements of M are called the multiset variables. Evaluating an MV query Q0,M on an instance I results in a multiset (bag) of facts, where the number of times a fact occurs is related to the number of different possible assignments of values to the multiset variables.\nLet us define the combined semantics formally. Let Q0 be of the form H0 ← B0 and let I be an input instance. Recall that Q0(I) according to the classical semantics equals\n{α(H0) | α : B0 → I}.\nLet W be the set of variables appearing in H0. Then the result of evaluating the MV query Q0,M on instance I is defined to be the multiset with ground set Q0(I), where for each fact e ∈ Q0(I), the multiplicity of e in the multiset is defined to be\n#{γ|M | γ : B0 → I and γ(H0) = e}.\nThat is, given a fact α(H0) ∈ Q0(I), there may be many different matchings γ that agree with α on H0. The multiplicity of α(H0) is defined to be not the total number of different such matchings γ, but rather the number of different restrictions one obtains when restricting these matchings γ to M .4\nTwo MV queries are equivalent if they evaluate to the same multiset on every input instance. Equivalence of MV queries can be characterized using the notion of multiset-homomorphism [14]. A multiset-homomorphism from MV query Q0,M to MV query Q ′ 0,M ′ is a homomorphism h : Q0 → Q ′ 0 such that h is injective on M and h(M) ⊆ M ′. Cohen showed the following:\nTheorem 4.15 ([14], Thm 5.3). Two MV queries are equivalent if and only if there are multiset homomorphisms between them in both directions.\nTo leverage this result on MV equivalence, we associate two MV queries to our given sifo CQs in the following way.\nDefinition 4.16. Fix a new relation symbol T0 of arity the length of x̄. The MV queries Q̃ and Q̃′ are defined as Q0, (Z −X) and Q ′ 0, (Z −X) respectively, where\nQ0 = T0(x̄) ← B Q′0 = T0(x̄) ← B ′\nThe following proposition now relates oid-equivalence to MV-equivalence:\nProposition 4.17. If Q and Q′ are oid-equivalent, then the MV queries Q̃ and Q̃′ are equivalent.\nProof. Let I be an instance. We must show that the multisets Q̃(I) and Q̃′(I) are equal. Since Q and Q′ are oid-equivalent, the ground sets Q0(I) and Q ′ 0(I) of Q̃(I) and Q̃′(I) are already equal. We must show that the element multiplicities are the same as well.\n4The motivation for MV queries was to model the semantics of positive SQL queries with nested EXISTS subqueries. While queries under standard SQL semantics return multisets of tuples, only the relations mentioned in the top level SQL block contribute to the multiplicities of answers, whereas relations mentioned in the subquery do not.\nLet T0(c̄) be an arbitrary element of Q0(I). By the semantics of oCQs, we have the following equalities:\n#c̄(Q, I) = #{γ|X∪Z | γ : B → I and γ(x̄) = c̄}\n#c̄(Q ′, I) = #{γ|X∪Z | γ : B ′ → I and γ(x̄) = c̄}\nSince Q(I) and Q′(I) are oid-isomorphic, the left-hand sides of the above two equalities are equal. Hence, the right-hand sides are equal as well. But these are precisely the multiplicities of T0(c̄) in Q̃(I) and Q̃ ′(I) respectively.\nThe following proposition further relates MV equivalence to equivalence of the flattenings up to permutation:\nProposition 4.18. If the MV queries Q̃ and Q̃′ are equivalent then there exists a permutation π of Z −X such that Q̊π and Q̊′ are equivalent.\nProof. By Theorem 4.15, there exist a multiset homomorphism h from Q̃ to Q̃′, and a multiset homomorphism h′ from Q̃′ to Q̃. Since Theorem 4.15 also implies that h is injective on Z −X and that h(Z −X) ⊆ Z −X , we can conclude that h acts as a permutation on Z −X . Moreover, h is the identity on X . The same two properties hold for h′.\nNow put π = (h|Z−X) −1. Then h : Q̊π → Q̊′. So it remains to find a homomorphism h′′ : Q̊′ → Q̊π. Thereto, note that h′h acts as a permutation on Z−X . Since Z−X is finite, there exists a nonzero natural number m such that (h′h)m is the identity on Z −X . Equivalently, (h′h)m−1h′ equals π on Z −X . We conclude that (h′h)m−1h′ is the desired homomorphism h′′.\nWe summarize the three preceding Propositions in the following.\nTheorem 4.19. Consider two sifo CQs\nQ = T (x̄, f(z̄)) ← B\nQ′ = T (x̄, f ′(z̄)) ← B′\nwhere Q and Q′ have identical tuples x̄ and z̄ of distinguished and creation variables, and where z̄ contains no variable more than once. Denote the sets of distinguished and creation variables by X and Z, respectively.\nThe following are equivalent:\n1. The sifo CQs Q and Q′ are oid-equivalent;\n2. The MV queries Q̃ and Q̃′ are equivalent;\n3. There is a permutation π of Z−X such that the classical CQs Q̊π and Q̊′\nare equivalent."
    }, {
      "heading" : "4.5 Computational complexity",
      "text" : "The results of this section imply the following:\nCorollary 4.20. Testing oid-equivalence of sifo CQs is NP-complete.\nProof. Assume given sifo CQs Q and Q′ with the same head predicate:\nQ = T (x̄, f(z̄)) ← B\nQ′ = T (x̄′, f ′(z̄′)) ← B′.\nLet X , X ′, Z and Z ′ denote the sets of variables occurring in x̄, x̄′, z̄ and z̄′, respectively.\nTo test oid-equivalence, we begin by removing duplicates in z̄ and z̄′, as justified by Lemma 4.9. Note that x̄ and x̄′ have the same length k, because of the fixed arity of T . So we can write x̄ = x1, . . . , xk and x̄ ′ = x′1, . . . , x ′ k. Consider the mapping σ = {(x1, x ′ 1), . . . , (xk, x ′ k)}. We test if σ is a bijection from X to X ′; if not, then Q and Q′ are not oid-equivalent by Lemma 4.10. If σ is a bijection, we can safely replace every variable x′ in X ′ by σ−1(x′), which yields a sifo CQ that is oid-equivalent to Q′. Hence, from now on we may assume that x̄ = x̄′ and in particular X = X ′.\nNext, we test whether X ∩Z = X ∩Z ′ and whether Z−X and Z ′−X have the same cardinality; if one of the two tests fails then Q and Q′ are not oidequivalent by Lemmas 4.11 and 4.12. Otherwise, we can rename the variables in Z ′ −X , so that we may assume that z̄ = z̄′.\nWe are now left in the situation where Q and Q′ are in the general forms (1) and (2) from Subsection 4.4, to which Theorem 4.19 applies. By the third statement of this theorem we can test oid-equivalence of Q and Q′ in NP by guessing a permutation π and two homomorphisms between Q̊π and Q̊′ in both directions.\nNP-hardness follows immediately because the problem has equivalence of classical CQs as a special case, which is well known to be NP-hard. Indeed, oid equivalence of sifo CQs Q and Q′ in the special case where the creation functions are nullary, amounts to classical equivalence when we ignore the function terms in the heads."
    }, {
      "heading" : "5 Logical entailment of sifo CQs interpreted as",
      "text" : "schema mappings\nObject-creating CQs, and sifo CQs in particular, can also be interpreted alternatively as schema mappings rather than as queries. Specifically, consider a sifo CQ Q of the general form T (x̄, f(z̄)) ← B over the database schema S. Let v̄ be the sequence of all variables used in B. Then we may view Q as a second-order implicational statement over the augmented schema S ∪ {T }, as follows:\n∃f∀v̄(B → H)\nHere, H is the head and B is conveniently used to stand for the conjunction of its elements. Note that this formula is second-order because it existentially quantifies a function f ; we denote the above formula by sotgd(Q). This formula belongs to the well-known class of second-order tuple-generating dependencies (SO-tgds). More specifically, it is a plain SO-tgd [7].\nSyntactically, the plain SO-tgds coming from sifo CQs in this manner form a restricted class of SO-tgds, defined by the following restrictions:\n• Plain SO-tgd may consist of multiple rules; sifo CQs consist of a single rule.\n• The head of a plain SO-tgd may consist of multiple atoms; the head of a sifo CQ consists of a single atom. (This is similar to GAV mappings [27, 12], although the classical notion of GAV mapping does not use function symbols.)\n• There is only one function symbol, which moreover can be applied only once in the head.\nWhen interpreting a sifo CQQ as an SO-tgd, the semantics becomes that of a schema mapping. Specifically, let I be an instance over S, considered as a source instance, and let J be an instance over {T }, considered as a target instance. Then (I, J) together form an instance over the augmented schema S ∪ {T }. Now we say that (I, J) satisfies Q, denoted by (I, J) |= Q, if the structure (adom(I) ∪ adom(J), I, J) satisfies sotgd(Q) under the standard semantics of second-order logic, using adom(I) ∪ adom(J) as the universe of the structure.\nThe following example and remark illustrate that the semantics of sifo CQs as SO-tgds is quite different from their semantics as object-creating queries.\nExample 5.1. Let us consider again our query from Example 1. As we have mentioned in the Introduction, we can now write it as an SO-tgd as follows:\n∃f∀x∀y∀c(Mother (c, x) ∧ Father (c, y) → Family(c, f(x, y)))\nTake the instance I consisting of the Mother and Father facts listed in Table 3.1, and take the instances J1 and J2 consisting of the Family facts listed in Table 6 left and right respectively. Then both pairs (I, J1) and (I, J2) satisfy the SO-tgd. For J1 this is witnessed by the following function f :\nx y f(x, y) anne adam jones claire carl simpson diana carl smith\nFor J2 this is witnessed by the function that simply maps everything to jones. In contrast, for J3 consisting of the Family facts listed in Table 7, the pair (I, J3) does not satisfy the SO-tgd. Indeed, suppose there would exist a function f witnessing the truth of the formula on (I, J3). Since beth has anne as mother and adam as father, the fact\nFamily(beth, f(anne, adam))\nmust belong to J3. The only Family-fact with beth in the first position is\nFamily(beth, jones),\nso we conclude f(anne, adam) = jones.\nFurthermore, since ben also has anne as mother and adam as father, the fact\nFamily(ben, f(anne, adam))\nmust be in J3. The only Family-fact with ben in the first position is\nFamily(ben,murphy),\nhowever, so we must conclude that\nf(anne, adam) = murphy,\nwhich is in contradiction with the previous conclusion.\nRemark 5.2. Note that, by the purely implicational nature of SO-tgds, if (I, J) satisfies an SO-tgd and J ⊆ J ′, then also (I, J ′) satisfies the SO-tgd. Hence, continuing the previous example, for any instance J ′ obtained by J1 or J2 by adding some more Family-facts, the pair (I, J ′) would still satisfy the SO-tgd from the example.\nThe above example and remark show that given a source instance I, there are in general multiple possible target instances J such that (I, J) |= Q. This is in contrast to the semantics of Q as an oCQ, where Q(I) is an extended instance that is uniquely defined. Still, there is a connection between the oCQ semantics and the SO-tgd semantics. Specifically, Q(I) can be viewed as a target instance in a canonical manner, using oid-to-constant assignments (oc-assignments for short) defined as follows.\nDefinition 5.3. Let I be a source instance and let J be an extended instance over {T } such that consts(J) ⊆ adom(I). An oc-assignment for J with respect to I is an injective mapping ρ : oids(J) → dom so that the image of ρ is disjoint from adom(I).\nThus, ρ assigns to each non-constant data term from J a different constant that is not in adom(I).\nWe now observe the following obvious property giving a connection between the oCQ semantics and the SO-tgd semantics:\nProposition 5.4. Let I be a source instance and let ρ be an oc-assignment for Q(I) with respect to I. Then (I, ρ(Q(I))) |= Q.\nIn fact, Q(I) corresponds to what Fagin et al. [18] call the chase of I with sotgd(Q)."
    }, {
      "heading" : "5.1 Nested dependencies",
      "text" : "We have introduced sifo CQs as a restricted class of plain SO-tgds. But actually, sifo CQs can also be considered as a restricted form of so-called nested tgds [8]. Thereto, consider again a sifo CQ of the general form T (x̄, f(z̄)) ← B. Let ū be the sequence of all variables from B, except for the creation variables (the variables from z̄). Furthermore, let w be a fresh variable not occurring in B, and let H ′ be the atom T (x̄, w). We can now associate to Q the following implicational statement, denoted by ntgd(Q):\n∀z̄∃w∀ū(B → H ′)\nNote that ntgd(Q) is now a first-order formula, but it is clear that ntgd(Q) is logically equivalent to sotgd(Q). Hence, the schema mappings arising from sifo CQs are not essentially second-order in nature."
    }, {
      "heading" : "5.2 Logical entailment",
      "text" : "In Section 4 we have shown that equivalence of sifo CQs as object-creating queries is decidable. Now that we have seen that sifo CQs can also be given a semantics as schema mappings, we may again ask if equivalence under this alternative semantics is decidable. The answer is affirmative; we have seen in the previous subsection that sifo CQ mappings belong to the class of nested dependencies, and logical implication of nested dependencies has recently been shown to be decidable [26]. When this general implication test for nested dependencies is applied specifically to sifo CQ schema mappings, it can be implemented in non-deterministic polynomial time. Hence, logical entailment (and also logical equivalence) of sifo CQ schema mappings is NP-complete.\nIn the present section, we present a specialized logical entailment test for sifo CQ schema mappings which is much simpler and more elegant, and provides more insight in the problem by relating it to testing implication of a join dependency by a conjunctive query (Theorem 5.10). Interestingly, there is a striking\ncorrespondence between the general implication test when applied to sifo CQs, and the strategy we use to prove our theorem. An in-depth comparison will be given in Section 6, after we have stated the Theorem formally and have seen its proof.\nFormally, given two schema mappings M and M′ from a source schema S to a target schema {T }, we say that M logically entails M′ if the following implication holds for every instance I over S and every instance J over {T }:\n(I, J) satisfies M ⇒ (I, J) satisfies M′.\nReferring to the view of sifo CQs as SO-tgds introduced above, we now define:\nDefinition 5.5. Let Q and Q′ be two sifo CQs with the same head predicate, and over the same database schema. We say that Q logically entails Q′ if sotgd(Q) logically entails sotgd(Q′).\nExample 5.6. Recall the sifo CQs Q and Q′ from Example 4.7:\nQ = T (x, f(y)) ← R(x, y, z)\nQ′ = T (x, f ′(x, y)) ← R(x, y, z)\nIt is clear that Q logically entails Q′. Indeed, if there exists a function f witnessing the truth of sotgd(Q), then we can easily define a function f ′ witnessing the truth of sotgd(Q′) by defining f ′(x, y) := f(y).\nConversely, however, Q′ does not logically entail Q. Indeed, Table 8 shows (I, J) where (I, J) |= Q′ but (I, J) 6|= Q.\nExample 5.7. Recall the sifo CQs Q and Q′ from Example 4.8:\nQ = T (x, f(x)) ← R(x, y, z)\nQ′ = T (x, f ′(x, y, z)) ← R(x, y, z)\nAlthough Q and Q′ are not oid-equivalent, they are logically equivalent: they logical entail each other. The logical entailment of Q′ by Q is again clear. To see the converse direction, assume f ′ witnesses the truth of sotgd(Q′). Then we define f(x) for any x as follows: if there exists a pair (y, z) such that R(x, y, z) holds, we fix one such pair (y, z) arbitrarily and define f(x) := f ′(x, y, z). If no such y and z exist, we may define f(x) arbitrarily. It is now clear that this f witnesses the truth of sotgd(Q).\nExample 5.8. Consider the sifo CQs:\nQ = T (x, f(z1)) ← R(z1, x), R(z1, z2)\nQ′ = T (x, f ′(z1, z2)) ← R(z1, x), R(z1, z2)\nAlso here, Q and Q′ logically entail each other. The logical entailment of Q′ by Q is again clear. To see the converse direction, we can use a reasoning similar to that used in Example 5.7. Assume f ′ witnesses the truth of sotgd(Q′). Then we define f(z1) for any z1 as follows: if there exists z2 such that R(z1, z2) holds, we fix one such z2 arbitrarily and define f(z1) := f\n′(z1, z2). If no such z2 exists, we may define f(z1) arbitrarily. The function f thus defined witnesses the truth of sotgd(Q).\nNote that the kind of reasoning used here and in Example 5.7 does not work in the case of Example 5.6. In Theorem 5.10 we will characterize formally when this kind of reasoning is correct.\nExample 5.7 shows that logical equivalence (logical entailment in both directions) does not imply oid-equivalence of sifo CQs. We will see in Theorem 5.12 that the other direction does hold."
    }, {
      "heading" : "5.3 Join dependencies and tableau queries",
      "text" : "In our characterization of sifo CQ logical entailment we use a number of concepts from classical relational database theory [2], which we recall here briefly.\nRecall that a relation scheme is a finite set of elements called attributes. It is customary to denote the union of two relation schemes X and Y by juxtaposition, thus writing XY for X ∪ Y .\nA tuple over a relation scheme U is a function from U to dom. A relation over U is a finite set of tuples over U .\nLet t be a tuple over U and let X ⊆ U . The restriction of t to X is denoted by t[X ]. The projection πX(r) of a relation r over U equals { t[X ] | t ∈ r }.\nWe now turn to tableau queries, which are an alternative formalization of conjunctive queries so that the result of a query is a set of tuples rather than a set of facts. Let S be a database schema, and let B be a finite set of atoms with predicates from S, as would be the body of a conjunctive query over S. Let V = var(B). For any U ⊆ V , the pair (B,U) is called a tableau query over S. When applied to an instance I over S, this tableau query returns a relation over U in the following manner. Let Mat(B, I) be the set of all matchings of B in I. Using variables for attributes, V can be viewed as a relation scheme. Under this view, every valuation on V is a tuple over V , and thus Mat(B, I) is a relation over V . We now define the result of (B,U) on input I to be πU (Mat(B, I)). This result is denoted by (B,U)(I).\nWe finally recall join dependencies. Let t1 and t2 be tuples over the relation schemes U1 and U2, respectively. If t1 and t2 agree on U1 ∩ U2, the union t1 ∪ t2 (where we take the union of two functions, viewed as sets of pairs) is a well-defined tuple over the relation scheme U1U2. The natural join r1 ⋊⋉ r2, for\nrelations r1 and r2 over U1 and U2, respectively, then equals\n{t1 ∪ t2 | t1 ∈ r1 & t2 ∈ r2 & t1[U1 ∩ U2] = t2[U1 ∩ U2]}.\nConsider now any relation r over some relation scheme U . Let U1 and U2 be subsets of U (not necessarily disjoint) such that U = U1U2. Then r satisfies the join dependency (JD) U1 ⋊⋉ U2 if r = πU1(r) ⋊⋉ πU2(r). Note that the containment from left to right is trivial, so one only needs to verify the containment πU1(r) ⋊⋉ πU2(r) ⊆ r.\nThe logical implication of JDs by tableau queries is well understood and can be solved by the chase procedure with NP complexity [25, 2]. Formally, a tableau query Q = (B,U) over S is said to imply a JD over U if for every instance I over S, the relation Q(I) satisfies this JD."
    }, {
      "heading" : "5.4 Decidability of sifo CQ logical entailment",
      "text" : "We consider two sifo CQs Q and Q′ with the same head predicate:\nQ = T (x̄, f(z̄)) ← B\nQ′ = T (x̄′, f ′(z̄′)) ← B′\nRemark 5.9. We assume Q and Q′ to have their function symbol in the same position in the head (here taken to be the last position). This is justified because otherwise Q could never logically entail Q′. In proof, suppose the function symbol in the head of Q′ would not be in the last position. Then we have a variable x′ from B′ in the last position. Now consider an instance I such that both Q(I) and Q′(I) are nonempty. (Such an instance could be constructed by taking the disjoint union of B and B′ and substituting constants for variables.) Let ρ by an oc-assignment for Q(I) with respect to I. By Proposition 5.4, we have (I, ρ(Q(I))) |= Q. In ρ(Q(I)), none of the elements in the last position of a T -fact belongs to adom(I). But then (I, ρ(Q(I))) cannot satisfy Q′. Indeed, since Q′(I) is nonempty, there is a matching α′ : B′ → I. In any J ′ such that (I, J ′) |= Q′, there needs to be a T -fact with α′(x′) in the last position, and α′(x′) ∈ adom(I). We conclude that Q does not logically entail Q′.\nIn what follows we use X , Z and Z ′ to denote the sets of variables appearing in the tuples x̄, z̄ and z̄′, respectively.\nWe establish:\nTheorem 5.10. Q logically entails Q′ if and only if there exists a homomorphism h : B → B′ satisfying the following conditions:\n1. h(x̄) = x̄′;\n2. h(X ∩ Z) ⊆ Z ′;\n3. Let Yh := h −1(Z ′), i.e., Yh = {y ∈ var(B) | h(y) ∈ Z ′}. Then the tableau query (B,XYhZ) implies the join dependency XYh ⋊⋉ YhZ.\nProof of sufficiency. Let (I, J) |= Q, witnessed by the function f . We must show (I, J) |= Q′. This means finding a function f ′ witnessing the truth of sotgd(Q′) in (I, J).\nCall any two matchings α1, α2 ∈ Mat(B, I) equivalent if they agree on Yh. This is denoted by α1 ≡ α2. Let ρ be any function from Mat(B, I) to Mat(B, I) with the two properties, first, that ρ(α) ≡ α and, second, that α1 ≡ α2 implies ρ(α1) = ρ(α2). Thus, ρ amounts to choosing a representative out of each equivalence class. We denote the application of ρ by subscripting, writing ρ(α) as ρα.\nLet us define f ′ as follows. Take any matching β : B′ → I. Then we put f ′(β(z̄′)) := f(ρβ◦h(z̄)). To see that this is well-defined, recall that h(Yh) ⊆ Z\n′. Hence, β1(z̄ ′) = β2(z̄ ′) implies that β1 ◦ h ≡ β2 ◦ h, so ρβ1◦h = ρβ2◦h.\nWe now show that this interpretation of f ′ satisfies the requirements. Specifically, let β : B′ → I be a matching. We must show that T (β(x̄′), f ′(β(z̄′))) ∈ J . Consider the valuations β1 = β ◦h and β2 = ρβ◦h, both belonging to Mat(B, I), and viewed as tuples over the relation scheme var(B). Since these two tuples agree on Yh, also the two restrictions β1[YhX ] and β2[YhZ] agree on Yh. Since X ∩ Z ⊆ Yh, the union β1[YhX ] ∪ β2[YhZ] is a well-defined tuple over XYhZ. Since πXYhZ(Mat(B, I)) satisfies the JD YhX ⋊⋉ YhZ, the union belongs to πXYhZ(Mat(B, I)). Hence, there exists a valuation γ ∈ Mat(B, I) that agrees with β ◦ h on X , and with ρβ◦h on Z. Since (I, J) |= Q, we have T (γ(x̄), f(γ(z̄))) ∈ J . By the preceding, γ(x̄) = β(h(x̄)) and γ(z̄) = ρβ◦h(z̄) = g(β(z̄′)). We conclude that T (β(x̄′), g(β(z̄′))) ∈ J as desired.\nProof of necessity. Let V ′ = var(B′), and let n be the arity of f . For each l ∈ {0, 1, . . . , n} and each u ∈ V ′ − Z ′ we introduce a fresh copy of u, denoted by ul. We say that this fresh copy is “colored” with color l. For each variable u ∈ Z ′, we simply define ul to be u itself. We say that the variables in Z ′ are “colored white”.\nFor any tuple of variables ū = (u1, . . . , up) in V ′, we denote the tuple\n(ul1, . . . , u l p) by ū l. In this tuple, all variables are colored l or white. We then define B′l = {R(ūl) | R(ū) ∈ B′ } and view it as an instance, i.e., the variables ul are considered to be constants.\nNow define the instance I = ⋃n\nl=0 B ′l, and construct the instance J = Q(I).\nBy Proposition 5.4, (I, J) |= Q, where we omit the oc-assignment for the sake of clarity. Since Q logically entails Q′, also (I, J) |= Q′. Hence, there exists a function f ′ such that for each color l, using the matching idl : B′ → I, u 7→ ul, the fact T (x̄′l, f ′(z̄′l)) = T (x̄′l, f ′(z̄′)) belongs to J .\nSince J = Q(I), we have f ′(z̄′) = f(w̄) for some tuple w̄ of colored variables in V ′. Since the arity of f is n and there are n + 1 distinct colors, some color does not appear in w̄. Without loss of generality we may assume that this is the color 0.\nLet us now focus on the fact T (x̄′0, f(w̄)) in J . Like any T -fact in J , this fact has been produced by some matching k : B → I such that T (x̄′0, f(w̄)) = k(T (x̄, f(z̄))), so\n(a) k(x̄) = x̄′0 and\n(b) k(z̄) = w̄.\nLet s denote the mapping that removes colors, i.e., s(ul) = u for every u ∈ V ′ and every l ∈ {0, 1, . . . , n}. Since s(I) ⊆ B′, we have a homomorphism s◦k : B → B′. We now define h := s◦k and show that it satisfies the conditions required by the Theorem. The first condition is clear since h(x̄) = s(k(x̄)) = s(x̄′0) = x̄′.\nFor the second condition, let x ∈ X ∩ Z. By (a), k(x) is colored 0 or white. By (b), k(x) is colored non-zero or white. Hence, k(x) is colored white, i.e., k(x) ∈ Z ′, so h(x) = s(k(x)) = k(x) ∈ Z ′ as desired.\nFinally, to show that (B,XYhZ) implies XYh ⋊⋉ YhZ we must establish the query containment\n(B,XYh) ⋊⋉ (B, YhZ) ⊆ (B,XYhZ).\nTreating tableau queries as conjunctive queries, and using the well-known containment criterion for conjunctive queries, this amounts to showing the existence of a certain homomorphism. More specifically, we express the query (B,XYh) ⋊⋉ (B, YhZ) by the conjunctive query with the body B2 = B0 ∪ B1 defined as follows. The body B0 is obtained from B by replacing each variable u not in Yh by a fresh copy u 0. For each u ∈ Yh we define u 0 simply as u itself. The body B1 is obtained from B by replacing each variable not in Yh by a fresh copy u1. Again, for each u ∈ Yh we define u\n1 simply as u itself. To show the containment, we now must find a homomorphism m from B to B2 such that each u ∈ X − Yh is mapped to u\n0; each u ∈ Yh is mapped to u; and each u ∈ Z − Yh is mapped to u\n1. Thereto, we define the following mapping m:\n• if k(u) is colored 0, then m(u) := u0;\n• if k(u) is colored l for some l > 0, then m(u) := u1;\n• if k(u) is colored white, then m(u) := u.\nLet us verify that m : B → B2 is a homomorphism. Consider an atom R(ū) in B; we must show R(m(ū)) ∈ B2. Since k : B → I, we know that R(k(ū)) ∈ I. By definition of I, this means that R(k(ū)) = R(v̄l) for some atom R(v̄) in B′ and some color l. So, for each variable u in ū, the color of k(u) is either l or white. We now distinguish two cases.\n• If k(u) is colored white, then h(u) = k(u) ∈ Z ′ so u ∈ Yh. Hence, in this case, m(u) = u = u0 = u1.\n• If k(u) is colored l, then by definition m(u) = u0 when l = 0, and m(u) = u1 when l > 0.\nWe conclude that R(m(ū)) = R(ū0) ∈ B0 when l = 0, and R(m(ū)) = R(ū 1) ∈ B1 when l > 0. Hence, since B2 = B0 ∪ B1, we always have R(m(ū)) ∈ B2 as desired.\nIt remains to verify that m maps the variables in XYhZ correctly. If u ∈ Yh, then h(u) = k(u) ∈ Z ′ so k(u) is colored white and m(u) = u as desired. If u ∈ X − Yh, then by (a), k(u) is colored 0 so m(u) = u\n0 as desired. Finally, if u ∈ Z − Yh, then by (b), k(u) is colored l > 0 so m(u) = u 1 as desired.\nAs a corollary, we obtain that the complexity of deciding logical entailment for sifo CQs is not worse than that of deciding containment for classical CQs:\nCorollary 5.11. Testing logical entailment of sifo CQs is NP-complete.\nProof. Membership in NP follows from Theorem 5.10; as a witness for logical entailment we can use a homomorphism h satisfying the first two conditions of the theorem, together with a homomorphism h0 from the query (B,XYhZ) to the query (B,XYh) ⋊⋉ (B, YhZ) witnessing the third condition of the theorem. NP-hardness follows because the problem has containment of classical CQs as a special case, which is well known to be NP-hard. Indeed, logical entailment of a sifo Q′ by a sifo Q, in the special case where the creation functions of Q and Q′ are nullary, amounts to classical containment of Q in Q′ when we ignore the function terms in the heads."
    }, {
      "heading" : "5.5 From oid-equivalence to logical entailment",
      "text" : "Let Q and Q′ be sifo CQs of the general forms (1) and (2) from Subsection 4.4. From our main Theorems 4.19 and 5.10, we can conclude the following.\nTheorem 5.12. If Q and Q′ are oid-equivalent, then Q logically entails Q′.\nProof. By Theorem 4.19, there exists a permutation π of Z −X such that Q̊π and Q̊′ are equivalent. Hence there is a homomorphism h : Q̊π → Q̊′. Clearly h : B → B′. We verify that h satisfies the conditions of Theorem 5.10, thus showing that Q logically entails Q′.\n1. Since h maps the head of Q̊π to the head of Q̊′, we have h(x̄) = x̄ and h(π(z̄)) = z̄. Since x̄′ = x̄, we have h(x̄) = x̄′ as desired.\n2. Since h is the identity on X , we have h(X ∩ Z) = X ∩ Z ⊆ Z = Z ′ as desired.\n3. Since h(π(z̄)) = z̄ and π(Z) = Z, we have h(Z) = Z = Z ′. Hence Z ⊆ Yh. But then the join dependency XYh ⋊⋉ YhZ becomes XYh ⋊⋉ Yh which trivially holds."
    }, {
      "heading" : "6 Discussion",
      "text" : "The results in this paper provide an understanding of the notions of oid-equivalence and logical entailment for sifo CQs. Sifo CQs, however, form a very simple subclass of oCQs. Moreover, oCQs themselves are rather limited, for example, they consist of a single rule and the rule can have only one atom in the head. Thus there are at least three natural directions for further research: (i) allowing more than one function in the head; (ii) allowing more than one atom in the head; (iii) allowing more than one rule.\nContainment Furthermore, in addition to oid equivalence of oCQs, it would be natural to also investigate a notion of oid-containment. There are actually at least two reasonable ways to define such a notion. The situation is similar to that in research on CQs with counting or bag semantics [15, 14]. Most of the known results are for equivalence only, with the extension to containment typically an open problem. Indeed, our characterization of oid-equivalence for sifo CQs relies on equivalence of CQs with bag semantics. An extension to oidcontainment will likely need a similar advance on containment of CQs with bag semantics.\nSifo CQs and ILOG In the introduction we mentioned that sifo CQs, and oCQs in general, are a fragment of ILOG without recursion [22]. Sifo CQs belong to the subclass of the class of recursion-free ILOG programs “with isolated oid creation” [23]. For this class, oid-equivalence was already known to be decidable. This was shown by checking all finite instances up to some exponential size. Hence, our NP-completeness result for oid-equivalence of sifo CQs does not follow from the previous work. More generally, the decidability of oid-equivalence for general recursion-free ILOG programs, or already of oCQs for that matter, is a long-standing open question. Various interesting examples showing the intricacies of this problem have already been given by Hull and Yoshikawa [23].\nSifo CQs and nested dependencies In Section 5.1 we also presented sifo CQs, now viewed as schema mappings, as a very simple subclass of nested tgds. The implication problem for general nested tgds was shown to be decidable by Kolaitis et al. [26] in work done independently from the present paper. Nevertheless our characterization of implication for sifo CQs, given by Theorem 5.10, does not follow from the general decision procedure for nested tgds. Instead, the general procedure, when applied to two sifo CQs, is strikingly similar to our proof of necessity of our Theorem. Using the notation from that proof, the general procedure applied to test implication of sifo CQ Q′ by sifo CQ Q would amount to testing for the existence of a homomorphism h from {T (x̄′l, f ′(z̄′)) | l = 0, . . . , n} to Q(I). Since Q(I) = {T (α(x̄), f(α(z̄))) | α : B → I}, this can be implemented by guessing h and n + 1 matchings αl : B → I such that (h(x̄′l), f ′(h(z̄′))) = (αl(x̄), f(αl(z̄))) for l = 0, . . . , n. In contrast, as explained\nin Corollary 5.11, our characterization involves guessing just two homomorphisms.\nSifo CQs and plain SO-tgds As described in Section 5, sifo CQs are a very simple subclass of plain SO-tgds. For plain SO-tgds, deciding logical equivalence is again an open problem. Also, the notion of oid-equivalence, defined in this paper for oCQs, can be readily extended to plain SO-tgds. We illustrate some difficulties involved in allowing multiple functions in the head, which is indeed allowed in plain SO-tgds. First, consider the oid-equivalence problem. For sifo CQs we have shown in Section 4.4 of this paper that, as far as oid-equivalence is concerned, only the counts of generated oids per tuple are important. Now consider the following pair of oCQs:\nQ = T (x, f(y), g(x, z)) ← R(x, y), R(x, z)\nQ′ = T (x, f(y), g(x, y)) ← R(x, y), R(x, z)\nBoth queries create the same number of new f -oids and g-oids per x-value, but now it also becomes important how these oids are paired. In Q more pairs are generated for each x, and the two queries are not oid-equivalent. So, in the case of multiple functions, also the interaction between the multiple terms needs to be taken into account in some way.\nA similar comment applies to the problem of logical equivalence. It is not immediately clear how the join dependency condition of Theorem 5.10 should be generalized in the presence of multiple functions. Consider, for example, the following:\nQ = T (x, f1(z1, y1), f2(z2, y2)) ← R(x, z1, z2), S(z1, y1), S(z2, y2) Q′ = T (x, g1(u), g2(u)) ← R(x, u, x), R(x, x, u), S(u, v1), S(x, v2)\nThe f1-part of Q (ignoring the third component in the head) logically entails the g1-part of Q\n′, and likewise the f2-part of Q (ignoring the second component in the head) logically entails the g2-part of Q\n′. Globally, however, Q does not logically entail Q′; this can be seen by the instances shown in Table 9, which satisfy Q but not Q′.\nA related interesting question then is whether Theorem 5.12, that oidequivalence implies logical entailment, still holds for plain SO-tgds. When we\nallow nested function terms in the head (which goes beyond plain SO-tgds) the implication breaks down, as shown by the following example [17, Example 3.8]:\nQ = T (x, f(x), g(f(x))) ← S(x)\nQ′ = T (x, f(x), g(x)) ← S(x)\nHere Q and Q′ are oid-equivalent, and Q logically entails Q′, but Q′ does not logically entail Q."
    }, {
      "heading" : "Acknowledgment",
      "text" : "We thank the anonymous referees for their careful comments which helped improve the presentation of the paper."
    } ],
    "references" : [ {
      "title" : "Data on the Web: From relations to semistructured data and XML",
      "author" : [ "S. Abiteboul", "P. Buneman", "D. Suciu" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2000
    }, {
      "title" : "Object identity as a query language primitive",
      "author" : [ "S. Abiteboul", "P. Kanellakis" ],
      "venue" : "J. ACM 45(5),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1998
    }, {
      "title" : "Procedural languages for database queries and updates",
      "author" : [ "S. Abiteboul", "V. Vianu" ],
      "venue" : "J. Comput. Syst. Sci",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1990
    }, {
      "title" : "Datalog extensions for database queries and updates",
      "author" : [ "S. Abiteboul", "V. Vianu" ],
      "venue" : "J. Comput. Syst. Sci",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1991
    }, {
      "title" : "STBenchmark: Towards a benchmark for mapping systems",
      "author" : [ "B. Alexe", "W.C. Tan", "Y. Velegrakis" ],
      "venue" : "PVLDB 1(1),",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2008
    }, {
      "title" : "The language of plain SOtgds: Composition, inversion and structural properties",
      "author" : [ "M. Arenas", "J. Pérez", "J. Reutter", "C. Riveros" ],
      "venue" : "J. Comput. Syst. Sci",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2013
    }, {
      "title" : "Value invention in data exchange",
      "author" : [ "P. Arocena", "B. Glavic", "R. Miller" ],
      "venue" : "Proceedings 2013 SIGMOD Conference,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2013
    }, {
      "title" : "Gain control over your integration evaluations",
      "author" : [ "P.C. Arocena", "R. Ciucanu", "B. Glavic", "R.J. Miller" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2015
    }, {
      "title" : "The expressive power of complex values in object-based data models",
      "author" : [ "J. Van den Bussche", "J. Paredaens" ],
      "venue" : "Information and Computation",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1995
    }, {
      "title" : "On the completeness of object-creating database transformation languages",
      "author" : [ "J. Van den Bussche", "D. Van Gucht", "M. Andries", "M. Gyssens" ],
      "venue" : "J. ACM 44(2),",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1997
    }, {
      "title" : "Structural characterizations of schema-mapping languages",
      "author" : [ "B. ten Cate", "P. Kolaitis" ],
      "venue" : "Commun. ACM 53(1),",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2010
    }, {
      "title" : "Optimal implementation of conjunctive queries in relational data bases",
      "author" : [ "A. Chandra", "P. Merlin" ],
      "venue" : "Proceedings 9th ACM Symposium on the Theory of Computing,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1977
    }, {
      "title" : "Equivalence of queries that are sensitive to multiplicities",
      "author" : [ "S. Cohen" ],
      "venue" : "The VLDB Journal",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2009
    }, {
      "title" : "Containment of aggregate queries",
      "author" : [ "S. Cohen", "W. Nutt", "Y. Sagiv" ],
      "venue" : "Database Theory—ICDT",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2003
    }, {
      "title" : "Clio: Schema mapping creation and data exchange",
      "author" : [ "R. Fagin", "L. Haas", "R.M.M. Hernández", "L. Popa", "Y. Velegrakis" ],
      "venue" : "Conceptual Modeling: Foundations and Applications, Lecture Notes in Computer Science,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2009
    }, {
      "title" : "Towards a theory of schemamapping optimization",
      "author" : [ "R. Fagin", "P. Kolaitis", "A. Nash", "L. Popa" ],
      "venue" : "Proceedings 27th ACM Symposium on Principles of Database Systems, pp",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2008
    }, {
      "title" : "Composing schema mappings: Secondorder dependencies to the rescue",
      "author" : [ "R. Fagin", "P. Kolaitis", "L. Popa" ],
      "venue" : "ACM Trans. Database Syst. 30(4),",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2005
    }, {
      "title" : "On the undecidability of the equivalence of second-order tuple generating dependencies",
      "author" : [ "I. Feinerer", "R. Pichler", "E. Sallinger", "V. Savenkov" ],
      "venue" : "Information Systems",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2015
    }, {
      "title" : "Navigational plans for data integration",
      "author" : [ "M. Friedman", "A.Y. Levy", "T.D. Millstein" ],
      "venue" : "In: AAAI/IAAI, pp",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1999
    }, {
      "title" : "The TSIMMIS approach to mediation: data models and languages",
      "author" : [ "H. Garcia-Molina", "Y. Papakonstantinou", "D. Quass", "A. Rajaraman", "Y. Sagiv", "J. Ullman", "V. Vassalos", "J. Widom" ],
      "venue" : "Journal of Intelligent Information Systems",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1997
    }, {
      "title" : "ILOG: Declarative creation and manipulation of object identifiers",
      "author" : [ "R. Hull", "M. Yoshikawa" ],
      "venue" : "Proceedings of the 16th International Conference on Very Large Data Bases,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1990
    }, {
      "title" : "On the equivalence of database restructurings involving object identifiers",
      "author" : [ "R. Hull", "M. Yoshikawa" ],
      "venue" : "Proceedings of the Tenth ACM Symposium on Principles of Database Systems,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1991
    }, {
      "title" : "A logic for programming with complex objects",
      "author" : [ "M. Kifer", "J. Wu" ],
      "venue" : "J. Comput. Syst. Sci",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1993
    }, {
      "title" : "Determining view dependencies using tableaux",
      "author" : [ "A. Klug", "R. Price" ],
      "venue" : "ACM Trans. Database Syst",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1982
    }, {
      "title" : "Nested dependencies: Structure and reasoning",
      "author" : [ "P. Kolaitis", "R. Pichler", "E. Sallinger", "V. Savenkov" ],
      "venue" : "Proceedings 33rd ACM Symposium on Principles of Database Systems",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2014
    }, {
      "title" : "Data integration: A theoretical perspective",
      "author" : [ "M. Lenzerini" ],
      "venue" : "Proceedings 21st ACM Symposium on Principles of Database Systems, pp",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2002
    }, {
      "title" : "Querying heterogeneous information sources using source descriptions",
      "author" : [ "A.Y. Levy", "A. Rajaraman", "J.J. Ordille" ],
      "venue" : "Proceedings 22nd International Conference on Very Large Data Bases,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1996
    }, {
      "title" : "A logic for objects",
      "author" : [ "D. Maier" ],
      "venue" : "Workshop on Foundations of Deductive Databases and Logic Programming,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 1986
    }, {
      "title" : "Object exchange across heterogeneous information sources",
      "author" : [ "Y. Papakonstantinou", "H. Garcia-Molina", "J. Widom" ],
      "venue" : "ICDE, pp",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 1995
    }, {
      "title" : "Linking data to ontologies",
      "author" : [ "A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "J. Data Semantics",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2008
    }, {
      "title" : "On directly mapping relational databases to RDF and OWL",
      "author" : [ "J.F. Sequeda", "M. Arenas", "D.P. Miranker" ],
      "venue" : "In: International Conference on World Wide Web (WWW), pp",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2012
    }, {
      "title" : "Information integration using logical views",
      "author" : [ "J.D. Ullman" ],
      "venue" : "Theor. Comput. Sci. 239(2),",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2000
    } ],
    "referenceMentions" : [ {
      "referenceID" : 2,
      "context" : "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation",
      "startOffset" : 59,
      "endOffset" : 69
    }, {
      "referenceID" : 3,
      "context" : "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation",
      "startOffset" : 59,
      "endOffset" : 69
    }, {
      "referenceID" : 9,
      "context" : "This has happened in several contexts: high expressiveness [4, 5, 11]; object orientation",
      "startOffset" : 59,
      "endOffset" : 69
    }, {
      "referenceID" : 1,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 8,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 20,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 22,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 27,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 0,
      "endOffset" : 19
    }, {
      "referenceID" : 19,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 38,
      "endOffset" : 42
    }, {
      "referenceID" : 0,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 73,
      "endOffset" : 76
    }, {
      "referenceID" : 6,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 96,
      "endOffset" : 107
    }, {
      "referenceID" : 14,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 96,
      "endOffset" : 107
    }, {
      "referenceID" : 16,
      "context" : "[3, 10, 22, 24, 29]; data integration [21]; semi-structured data and XML [1]; and data exchange [8, 16, 18].",
      "startOffset" : 96,
      "endOffset" : 107
    }, {
      "referenceID" : 20,
      "context" : "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].",
      "startOffset" : 101,
      "endOffset" : 113
    }, {
      "referenceID" : 22,
      "context" : "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].",
      "startOffset" : 101,
      "endOffset" : 113
    }, {
      "referenceID" : 27,
      "context" : "In a logic-based approach, object creation is typically achieved through the use of Skolem functions [22, 24, 29].",
      "startOffset" : 101,
      "endOffset" : 113
    }, {
      "referenceID" : 1,
      "context" : "Oid-equivalence has its origins in the theory of object-creating queries introduced by Abiteboul and Kanellakis [3]; it is the natural generalization of query equivalence in the presence of object creation.",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 21,
      "context" : "Hull and Yoshikawa [23] studied oid-equivalence (they called it ‘obscured equivalence’) for nonrecursive ILOG programs; the decidability of this problem is a long-standing open question.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 12,
      "context" : "We give a new result relating oid-equivalence to equivalence of classical conjunctive queries under ‘combined’ bag-set semantics [14], which models the evaluation of CQs when query results and relations may contain duplicates of tuples.",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 6,
      "context" : "Object creation is receiving renewed interest in the context of schema mappings [8, 18], which are formalisms describing how data structured under a",
      "startOffset" : 80,
      "endOffset" : 87
    }, {
      "referenceID" : 16,
      "context" : "Object creation is receiving renewed interest in the context of schema mappings [8, 18], which are formalisms describing how data structured under a",
      "startOffset" : 80,
      "endOffset" : 87
    }, {
      "referenceID" : 15,
      "context" : "For standard CQs without object creation, two queries are equivalent if and only if they are logically equivalent as schema mappings [17].",
      "startOffset" : 133,
      "endOffset" : 137
    }, {
      "referenceID" : 6,
      "context" : "Sifo CQs viewed as schema mappings belong to the class of so-called ‘nested dependencies’ [8], which belong in turn to the class of formulas called secondorder tuple-generating dependencies (SO-tgds [18]).",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 16,
      "context" : "Sifo CQs viewed as schema mappings belong to the class of so-called ‘nested dependencies’ [8], which belong in turn to the class of formulas called secondorder tuple-generating dependencies (SO-tgds [18]).",
      "startOffset" : 199,
      "endOffset" : 203
    }, {
      "referenceID" : 17,
      "context" : "Although logical equivalence of SO-tgds is undecidable [19], logical implication of nested dependencies has recently been shown to be decidable [26].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 24,
      "context" : "Although logical equivalence of SO-tgds is undecidable [19], logical implication of nested dependencies has recently been shown to be decidable [26].",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 20,
      "context" : "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 16,
      "context" : "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].",
      "startOffset" : 161,
      "endOffset" : 165
    }, {
      "referenceID" : 6,
      "context" : "We clarify the relationship between sifo CQs and other formalisms in the literature, notably, the language ILOG [22], second-order tuple-generating dependencies [18], and nested tuple-generating dependencies [8].",
      "startOffset" : 208,
      "endOffset" : 211
    }, {
      "referenceID" : 18,
      "context" : "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.",
      "startOffset" : 37,
      "endOffset" : 49
    }, {
      "referenceID" : 25,
      "context" : "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.",
      "startOffset" : 37,
      "endOffset" : 49
    }, {
      "referenceID" : 31,
      "context" : "GAV (global-as-view) schema mappings [20, 27, 33] relate a query over the source schema, represented by a body B of a CQ, to an atomic element of the global schema, represented by a head atom H of a CQ.",
      "startOffset" : 37,
      "endOffset" : 49
    }, {
      "referenceID" : 28,
      "context" : "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.",
      "startOffset" : 89,
      "endOffset" : 97
    }, {
      "referenceID" : 31,
      "context" : "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.",
      "startOffset" : 89,
      "endOffset" : 97
    }, {
      "referenceID" : 26,
      "context" : "GAV schema mappings have been used already in the 1990s in mediator systems like Tsimmis [30, 33] or Information Manifold [28] for the integration of heterogeneous data sources.",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 4,
      "context" : "In particular, the flexibility of the arguments of the Skolem functions used for object creation has been advocated as one of the desirable features in recent benchmarks for schema mapping and information integration, such as STBenchmark [6] and iBench [9].",
      "startOffset" : 238,
      "endOffset" : 241
    }, {
      "referenceID" : 7,
      "context" : "In particular, the flexibility of the arguments of the Skolem functions used for object creation has been advocated as one of the desirable features in recent benchmarks for schema mapping and information integration, such as STBenchmark [6] and iBench [9].",
      "startOffset" : 253,
      "endOffset" : 256
    }, {
      "referenceID" : 7,
      "context" : "More precisely, in the mapping primitives of iBench [9], an extension of STBenchmark [6] that supports SO-tgds, the users can choose among two different skolemization strategies to fill the arguments of the Skolem functions: fixed, where the arguments of the function are pre-defined in a native mapping primitive, or variable, where one can further choose among the options All, Key, and Random, which generate mappings where all variables, the variables in the positions of the primary key, or a random set of variables, respectively, are used as arguments of the function.",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 4,
      "context" : "More precisely, in the mapping primitives of iBench [9], an extension of STBenchmark [6] that supports SO-tgds, the users can choose among two different skolemization strategies to fill the arguments of the Skolem functions: fixed, where the arguments of the function are pre-defined in a native mapping primitive, or variable, where one can further choose among the options All, Key, and Random, which generate mappings where all variables, the variables in the positions of the primary key, or a random set of variables, respectively, are used as arguments of the function.",
      "startOffset" : 85,
      "endOffset" : 88
    }, {
      "referenceID" : 29,
      "context" : "As such, sifo CQs can be seen as examples of mapping assertions from source schemas to a global ontology in OBDA [31].",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 30,
      "context" : "A related application is the direct translation of a relational schema into OWL, which uses as an important building block the creation of IRIs [32].",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 20,
      "context" : "In this section we introduce our formalism for dealing with conjunctive queries and introduce the notion of object-creating conjunctive query, adapted from the language ILOG [22].",
      "startOffset" : 174,
      "endOffset" : 178
    }, {
      "referenceID" : 11,
      "context" : "We can now recall the classical notion of conjunctive query (CQ) [2, 13].",
      "startOffset" : 65,
      "endOffset" : 72
    }, {
      "referenceID" : 20,
      "context" : "Object-creating CQs can be considered to be the conjunctive-query fragment of nonrecursive ILOG [22]; our syntax exposes the Skolem functions, which are normally obscured in the standard ILOG syntax, and our semantics corresponds to what is called the ‘exposed semantics’ by Hull and Yoshikawa.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 21,
      "context" : "Nevertheless, in the following section, we will consider oid-equivalence of sifo CQs, which does correspond to what has been called ‘obscured equivalence’ [23].",
      "startOffset" : 155,
      "endOffset" : 159
    }, {
      "referenceID" : 11,
      "context" : "Let us briefly recall these notions now [13, 2].",
      "startOffset" : 40,
      "endOffset" : 47
    }, {
      "referenceID" : 12,
      "context" : "For our proof, we rely on work by Cohen [14] who studied queries with multiset variables that are evaluated under so-called combined semantics, a semantics that combines set and multiset semantics.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 12,
      "context" : "Equivalence of MV queries can be characterized using the notion of multiset-homomorphism [14].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 12,
      "context" : "15 ([14], Thm 5.",
      "startOffset" : 4,
      "endOffset" : 8
    }, {
      "referenceID" : 5,
      "context" : "More specifically, it is a plain SO-tgd [7].",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 25,
      "context" : "(This is similar to GAV mappings [27, 12], although the classical notion of GAV mapping does not use function symbols.",
      "startOffset" : 33,
      "endOffset" : 41
    }, {
      "referenceID" : 10,
      "context" : "(This is similar to GAV mappings [27, 12], although the classical notion of GAV mapping does not use function symbols.",
      "startOffset" : 33,
      "endOffset" : 41
    }, {
      "referenceID" : 16,
      "context" : "[18] call the chase of I with sotgd(Q).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 6,
      "context" : "But actually, sifo CQs can also be considered as a restricted form of so-called nested tgds [8].",
      "startOffset" : 92,
      "endOffset" : 95
    }, {
      "referenceID" : 24,
      "context" : "The answer is affirmative; we have seen in the previous subsection that sifo CQ mappings belong to the class of nested dependencies, and logical implication of nested dependencies has recently been shown to be decidable [26].",
      "startOffset" : 220,
      "endOffset" : 224
    }, {
      "referenceID" : 23,
      "context" : "The logical implication of JDs by tableau queries is well understood and can be solved by the chase procedure with NP complexity [25, 2].",
      "startOffset" : 129,
      "endOffset" : 136
    }, {
      "referenceID" : 13,
      "context" : "The situation is similar to that in research on CQs with counting or bag semantics [15, 14].",
      "startOffset" : 83,
      "endOffset" : 91
    }, {
      "referenceID" : 12,
      "context" : "The situation is similar to that in research on CQs with counting or bag semantics [15, 14].",
      "startOffset" : 83,
      "endOffset" : 91
    }, {
      "referenceID" : 20,
      "context" : "Sifo CQs and ILOG In the introduction we mentioned that sifo CQs, and oCQs in general, are a fragment of ILOG without recursion [22].",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 21,
      "context" : "Sifo CQs belong to the subclass of the class of recursion-free ILOG programs “with isolated oid creation” [23].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 21,
      "context" : "Various interesting examples showing the intricacies of this problem have already been given by Hull and Yoshikawa [23].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 24,
      "context" : "[26] in work done independently from the present paper.",
      "startOffset" : 0,
      "endOffset" : 4
    } ],
    "year" : 2016,
    "abstractText" : "Conjunctive database queries have been extended with a mechanism for object creation to capture important applications such as data exchange, data integration, and ontology-based data access. Object creation generates new object identifiers in the result, that do not belong to the set of constants in the source database. The new object identifiers can be also seen as Skolem terms. Hence, object-creating conjunctive queries can also be regarded as restricted second-order tuple-generating dependencies (SO tgds), considered in the data exchange literature. In this paper, we focus on the class of single-function object-creating conjunctive queries, or sifo CQs for short. The single function symbol can be used only once in the head of the query. We give a new characterization for oid-equivalence of sifo CQs that is simpler than the one given by Hull and Yoshikawa and places the problem in the complexity class NP. Our characterization is based on Cohen’s equivalence notions for conjunctive queries with multiplicities. We also solve the logical entailment problem for sifo CQs, showing that also this problem belongs to NP. Results by Pichler et al. have shown that logical equivalence for more general classes of SO tgds is either undecidable or decidable with as yet unknown complexity upper bounds.",
    "creator" : "LaTeX with hyperref package"
  }
}