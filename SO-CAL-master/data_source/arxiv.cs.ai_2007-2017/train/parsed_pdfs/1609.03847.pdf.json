{
  "name" : "1609.03847.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Instrumenting an SMT Solver to Solve Hybrid Network Reachability Problems",
    "authors" : [ "Daniel Bryce", "Sergiy Bogomolov", "Alexander Heinz", "Christian Schilling" ],
    "emails" : [ "dbryce@sift.net", "sergiy.bogomlov@ist.ac.at", "alexander.heinz@saturn.uni-freiburg.de", "schillic@informatik.uni-freiburg.de" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Instrumenting an SMT Solver to Solve Hybrid Network Reachability Problems\nDaniel Bryce SIFT, LLC.,\ndbryce@sift.net\nSergiy Bogomolov IST Austria,\nsergiy.bogomlov@ist.ac.at\nAlexander Heinz University of Freiburg,\nalexander.heinz@saturn.uni-freiburg.de\nChristian Schilling University of Freiburg,\nschillic@informatik.uni-freiburg.de\nAbstract—PDDL+ planning has its semantics rooted in hybrid automata (HA) and recent work has shown that it can be modeled as a network of HAs. Addressing the complexity of nonlinear PDDL+ planning as HAs requires both space and time efficient reasoning. Unfortunately, existing solvers either do not address nonlinear dynamics or do not natively support networks of automata.\nWe present a new algorithm, called HNSolve, which guides the variable selection of the dReal Satisfiability Modulo Theories (SMT) solver while reasoning about network encodings of nonlinear PDDL+ planning as HAs. HNSolve tightly integrates with dReal by solving a discrete abstraction of the HA network. HNSolve finds composite runs on the HA network that ignore continuous variables, but respect mode jumps and synchronization labels. HNSolve admissibly detects dead-ends in the discrete abstraction, and posts conflict clauses that prune the SMT solver’s search. We evaluate the benefits of our HNSolve algorithm on PDDL+ benchmark problems and demonstrate its performance with respect to prior work.\nI. INTRODUCTION\nRecent planners ( [7] and [6]) for PDDL+ [19] represent actions, processes, events, and state variables as a network of synchronized hybrid automata (HA), but there are no suitable algorithms for reasoning about nonlinear change in a network of automata. We address nonlinear PDDL+ problems by adapting the dReal Satisfiability Modulo Theories (SMT) solver [10], [22], which has been previously shown to address nonlinear PDDL+ as a single hybrid automaton. It is wellknown that reasoning about the explicit parallel composition of a network of automata as a single automaton is usually a poor choice because it grows exponentially in the size of the individual synchronized automata [2], [11], [14]. We base our HA network SMT encoding upon prior work [14] that represents each automaton independently and adds synchronization constraints. We show that a direct network encoding results in better scalability in the number of encoding steps than a single automaton encoding if it is also matched with an appropriate search strategy.\nWe extend and reinterpret the approach taken by Bryce et al. [10] within our proposed HNSolve algorithm. They guide dReal to systematically select variable assignments that correspond to discrete-feasible runs of a hybrid automaton (i.e., ignoring continuous variables). In this manner, they force dReal to perform a heuristic depth-first search that considers all runs through the hybrid automaton. This led to increased\nscalability because dReal did not consider variable assignments that correspond to discrete-infeasible runs. A similar technique is employed by the dReach [22] and BACH [12] algorithms, but these encode a different SMT instance for each discrete run and do not benefit from learned conflict clauses. HNSolve, like the work of Bryce et al. [10], guides dReal variable selection to construct discrete-feasible runs, but differs in two main aspects. First, HNSolve constructs composite runs for a network of HAs and not a single HA. Each composite run represents a feasible sequence of synchronized transitions within each automaton. HNSolve also performs a heuristic depth-first search over the possible composite runs. The second difference is that HNSolve also learns conflict clauses that it adds to the SMT encoding. While searching the space of discrete-feasible composite runs, HNSolve may be unable to find a run that extends the current partial run. dReal’s current variable assignment encodes a partial run prefix, and the conflict clause blames the current variable assignment encoding the prefix. We find that adding conflict clauses is a critical new aspect of our approach, and demonstrate that it improves solver scalability as the number of steps in the encodings increase. Developing problem-specific SMT solver algorithms was also recently explored in the context of program analysis [25]. We hope to advance the understanding of how problem-specific, and arguably invasive, modifications to SMT solvers can bring about improved performance.\nWe evaluate the HNSolve algorithm on several PDDL+ planning benchmarks encoded as networks of hybrid automata, as developed in prior work [7]. We compare flat, precompiled encodings of the networks to our direct encoding of the networks. We show that our encoding outperforms encodings based upon explicit parallel composition and is competitive with the state of the art in PDDL+. We also demonstrate the advantages of using the HNSolve algorithm to improve performance."
    }, {
      "heading" : "II. HYBRID AUTOMATA BACKGROUND",
      "text" : "We discuss how to represent HA networks in the LRF language and their semantics, as follows. First-order Theories of the Reals: The LRF language represents the first-order signature over the reals with the set F of computable real functions.\nDefinition 1 (LRF -Formulas). LRF -formulas are first-order formulas over real numbers, whose signature allows an arbi-\nar X\niv :1\n60 9.\n03 84\n7v 1\n[ cs\n.A I]\n1 3\nSe p\n20 16\ntrary collection F of Type 2 computable real functions [21]. The syntax is:\nt := c | x | f(t(~x)); ϕ := t(~x) > 0 | t(~x) ≥ 0 | ϕ ∧ ϕ | ϕ ∨ ϕ | ∃xiϕ | ∀xiϕ.\nA function is Type 2 computable if it can be algorithmically evaluated up to an arbitrary numerical accuracy. All common continuous real functions are Type 2 computable. Networks of Hybrid Automata: We solve HA network reachability problems by expressing the network in LRF and then unrolling it over k steps and associating a goal region goal(~xtk). The goal is also an LRF formula of the form modek ∧ϕ(~xtk) where modek defines the HA modes to reach and ϕ(~xtk) defines the variable values to reach.\nDefinition 2 (LRF -Representations of Hybrid Automata). A hybrid automaton in LRF -representation is a tuple\nH = 〈X,Q, flow, inv, jump, init, L〉\nwhere • X ⊆ Rn for some n ∈ N, • Q = {q1, . . . , qm} is a finite set of modes, • flow = {flowq(~x0, ~xt, t) : q ∈ Q} is the set of ODEs\ndescribing the flow for each mode, • inv = {invq(~x) : q ∈ Q} is a set of invariants for each\nmode, • jump = {jump\nq `−→q′(~x\nt, ~x0 ′ ) : q, q′ ∈ Q}, where each\nelement is a transition from mode q to q′ using the synchronization label set `. Each formula jump\nq `−→q′(~x\nt, ~x0 ′ )\nis of the form ϕ(~xt) ∧ ψ(~xt, ~x0′), where ϕ(~xt) is a conjunction specifying the guard, ψ(~xt, ~x0 ′ ) is a conjunction\nspecifying the discrete update, • init = {initq(~x) : q ∈ Q} is the set of initial states, and • L is a finite set of synchronized event labels.\nGao et al. [22] describe how to unroll this encoding for a single automaton. The important aspects of the unrolling are to time stamp each of the continuous variables to denote their value at the start (~x0i ) and end (~x t i) of the mode at step i, as well as the time ti spent in step i.\nDefinition 3. (HA Runs) Each run τ on H is a series of states\n(t0, q0, s(~x 0 0), s(~x t 0)), (t1, q1, s(~x 0 1), s(~x t 1)),\n. . . ,\n(tk, qk, s(~x 0 k), s(~x t k))\nwhere ti is the time spent in step i, qi is a mode, and s(~x0i ) and s(~xtii ) are respective valuations on ~x 0 i and ~x t i upon entering or leaving qi.\nThe init set defines what constitutes a legal initial mode q0 and state valuation s(~x00). The flow and inv sets define legal pairs of state valuations s(~x0i ) and s(~x t i) and occupancy times ti. The jump set defines legal pairs of modes qi and qi+1, state valuations s(~xti) and s(~x 0 i+1), and occupancy times ti.\nDefinition 4. (Hybrid Automaton Network) A network N = {H1, . . . ,Hn} of hybrid automata is a set of hybrid automata.\nDefinition 5. (HA Network Runs) Each run τ on N is a series of composite states\n(t0, ~q0, s(~x 0 0), s(~x t 0)),\nL0, (t1, ~q1, s(~x 0 1), s(~x t 1)),\nL1,\n. . . ,\nLk−1, (tk, ~qk, s(~x 0 k), s(~x t k))\ninterleaved with sets of synchronization labels Li, where each state includes a vector of modes ~qi and each ~x0i and ~x t i is a valuation on X = X1 ∪ . . . ∪Xn.\nIn order for a HA network run to be legal, it must be consistent with each of the init, flow, and inv sets of each individual HA. Each label set Li determines the legal constituent jumps that make up a composite jump. In a composite jump, each automaton either changes modes as defined by its jump set, or remains in the same mode. Let sync = ` ∩ L be the set of labels a jump must synchronize upon. If the composite label is Li, the automaton must take one of the jumps from the current mode where sync ⊆ Li. If no jump may be taken and L 6⊆ Li, then the automaton may remain in the same mode."
    }, {
      "heading" : "III. HYBRID NETWORK SOLVER",
      "text" : "We describe an extension called the hybrid network solver (HNSolve) to dReal’s SMT framework that customizes the problem solver for reachability checking in networks of hybrid automata. dReal: dReal checks whether an LRF formula is δ-satisfiable (a decidable problem) by combining a SAT solver [18] with an ICP solver.1 dReal employs the DPLL(T) framework [8] for SMT. It first solves the Boolean constraints to find a satisfying set of literals of the form (t(~x) ≥ 0) or ¬(t(~x) ≥ 0). This conjunctive set of literals imposes a set of numeric constraints that are solved using ICP. If successful, dReal finishes, and otherwise, the ICP solver returns a set of literals that explain inconsistency. The inconsistent literals become a conflict clause that can be used by the SAT solver. If the SAT solver cannot find a satisfying set of literals, then it returns with an unsatisfiability result.\nThe ICP solver uses the branch and prune [27] algorithm to refine a set of intervals over the continuous variables (called a box). Each branch splits the interval of a single continuous variable, creating two boxes. Pruning operators propagate the constraints to shrink the boxes. ICP continues to branch and prune boxes until it finds a box that is δ-satisfiable or establishes that no such box exists (i.e., the constraints are inconsistent). A box is δ-satisfiable when for any vector of\n1www.ibex-lib.org\nvalues ~x represented by the box, each constraint f(~x) ≥ −δ is satisfied. Hybrid Network Solver: HNSolve wraps the SAT solver and ICP solver by suggesting variable assignments and adding conflict clauses. Where dReal would normally make decisions without realizing it is solving a hybrid network reachability problem, HNSolve organizes its search around potentially viable runs on the network. To see this, consider a situation where dReal has made several variable assignments and decided that ~q0 and ~qk are the initial and final modes of a run satisfying the goal(xtk). For the sake of example, the first automaton H1 does not include jumps that connect q0 to qk. A simple shortest path algorithm can recognize that there is no path from q0 to qk, but dReal will continue to make assignments unnecessarily and eventually backtrack. HNSolve solves a discrete abstraction [1], [11] of the hybrid reachability problem and coordinates the SAT solver in making assignments corresponding to its solution. Its approach is to find a sequence of mode vectors and synchronization labels of the form\n~q0, L0, ~q1, L1, . . . , Lk−1, ~qk\nthat are consistent with the jump transitions and synchronize. HNSolve then extracts the literal assignments corresponding to this sequence and guides the SAT solver to realize this run. If the SAT or ICP solvers discover an inconsistency, then HNSolve rebuilds the run from the point to which the SAT solver backtracks. HNSolve interfaces with the SAT solver through three main methods: getTrail(), assertLit() and assertClause(). The getTrail() method returns the SAT solver’s assignment stack, including all premises, decision variable assignments, and inferred variable assignments. The assertLit() and assertClause() methods assert a literal or clause assignment, respectively, and return unsat , δ-sat , consistent , or backtrack. We note that there is no need for a corresponding retractLit() method because backtracking is handled by the SAT solver as part of the calls to assertLit() and assertClause(). HNSolve, Algorithm 1, first computes the cost (described below) to reach each mode in each automaton in line 2 and then encodes the problem in LRF in line 3. The algorithm works in two phases. In lines 5 - 14, the solver generates a run suffix P . Each run is represented by a set of literals of the form {mode10 = q10 ,mode 2 0 = q 2 0 , . . . , sync l 0, . . . ,mode 1 k = q1k,mode 2 k = q 2 k, . . .}, defining the modes of each automaton at each step and the synchronization labels of each transition. If the current run represented by the SAT solver’s trail cannot be extended, then genRun() returns a “nil” run. Lines 8 - 12 create a conflict clause from the decision variables on the SAT solver’s trail (i.e., negate the corresponding literals) and assert the new clause. The assertClause() method returns unsat when the SAT solver determines the new clause causes unsatisfiability; otherwise, the SAT solver will backtrack as part of assertClause() and we will find a new run on line 6.\nUpon finding a non-nil run, lines 15 - 26 assert each literal in the run from the beginning of the run to the end (i.e.,\nAlgorithm 1: HNSolve algorithm.\n1 HNSolve(N , G, k, M) input : A network of automata N , a reachability property G, and step and delay bound k and M . 2 cost← getRunCosts(N ); 3 encodeSMT(N , G, k, M ); 4 while true do 5 repeat 6 P ← genRun(N , getTrail(), cost, k); 7 if P = nil then 8 C ← ∨ l∈decisions(getTrail()) ¬l;\n9 res ← assertClause(C); 10 if res = unsat then 11 return unsat 12 end 13 end 14 until |P| 6= nil ; 15 for l from 0 upto |P| do 16 if l < |P| then 17 res ← assertLit(P[l]); 18 else 19 res ← assertLit(nil); 20 end 21 if res = δ-sat then 22 return δ-sat ; 23 else if res 6= consistent then 24 break; 25 end 26 end 27 end\nfollowing a run forward to one of the goal modes of each automaton). After successfully asserting each literal on the run, HNSolve asserts the nil literal, which signals the SAT solver to complete any remaining assignments. If the run leads to a δ-sat solution, then the algorithm returns; otherwise, if asserting a literal is not consistent (i.e., returns backtrack or unsat), then the solver attempts to find a new run on line 6.\nThe genRun() method (Algorithm 2) finds a run on the network that is consistent with the current SAT solver assignment T . It uses depth-first search (line 3 and Algorithm 3) to find a search stack S. The search stack S includes a transition for each automaton for each step 0 to k-1. From S, the genRun method extracts the literals needed to encode the run (lines 7-14). The literals include mode choices (line 10) and synchronization labels (lines 11-13).\nThe depth-first search (Algorithm 3) generates the search stack S corresponding to a run on the network. It selects an initial mode of H1 at depth 0, an initial mode of H2 at depth 1, and so on. It selects a jump from the initial mode of H1 (chosen at depth 0) at depth |N |, a jump for H2 at depth |N | + 1, and so on. Thus, the first N levels of the stack correspond to initial modes, the second |N | levels to the zeroth step, and similarly for later steps. Lines 8-18 generate the\nAlgorithm 2: genRun algorithm. 1 genRun(N , T , cost, k)\ninput : A network of automata N , a stack of literals T , a cost function cost, and the step bound k.\n2 P ← []; 3 S ← dfs(N , [], cost, k); 4 if S = fail then 5 return nil; 6 else 7 for j = 0 . . . |S| − 1 do 8 (qi\n`i−→ q′i)← S.get(j); 9 step← j/|N |;\n10 P .append((modeistep = q′i, >)); 11 for l ∈ ` do 12 P .append((synclstep, >)); 13 end 14 end 15 end 16 return P;\nsuccessors, line 19 filters the successors (described below), and lines 20-27 conduct the recursive step of the search.\nAlgorithm 4 removes successors that are either inconsistent with the SAT solver’s current assignment (lines 8-9) or do not synchronize with the “sibling” jumps previously chosen for the current step (lines 13-20). The synchronization check involves three cases. The first and second case are for when either the current automaton or the sibling will persist its mode (i.e., not synchronize). We require that for a mode qi to persist in automaton Hi, the automaton must not be compelled to synchronize with its siblings at the current time step. More formally, the mode persistence is allowed if the public labels Lj ∩`j for each chosen sibling jump qj\n`j−→ q′j do not intersect with the labels Li. The third case checks that two jumps agree on publicly communicated labels. The jumps in succ′ are those that are possible in the discrete sense, but may not be possible if we were to consider their continuous variables in the guards, updates, or mode invariants.\nAfter filtering the possible successors, the depth-first search will sort the jumps by increasing cost, where cost is defined by the successor mode’s value in cost. The cost of each mode is defined by the minimum number of steps from an initial mode:\ncost(q) =  0 : initq(~x) ∈ initiminjump q′ `−→q∈jumpi cost(q′) + 1 : otherwise\nIn the next section, we detail the LRF encoding that we use to express the network HA reachability problem. We follow with a section describing how we experiment with HNSolve by omitting it entirely (i.e., use dReal alone), omitting lines 6- 12 of Algorithm 1 to avoid learning conflict clauses, or using it in its entirety. We note that omitting conflict clauses results\nAlgorithm 3: Depth-First Search Algorithm. 1 dfs(N , S, cost, k)\ninput : A network of automata N , a search stack S, a mode cost function cost, and a step bound k.\n2 if |S| = |N |(k + 1) then 3 return S; 4 end 5 step← |S|/|N |; 6 i← |S|%|N |; 7 succ← {}; 8 if step = 0 then 9 for initq′(~x) ∈ initi do\n10 succ← succ ∪ (nil {}−→ q′); 11 end 12 else 13 (q′′\n`′−→ q)← S.get(|S| − |N |); 14 for jump\nq L−→q′(~x\nt, ~x0) ∈ jumpi do\n15 succ← succ ∪ (q `−→ q′); 16 end 17 succ← succ ∪ (q {}−→ q); 18 end 19 succ←sort(filter(succ, i, N , S, step), cost); 20 for q `−→ q′ ∈ succ do 21 S.push(q `−→ q′); 22 if dfs(N , S, k) 6= fail then 23 return S; 24 else 25 S.pop(); 26 end 27 end 28 return fail;\nin an algorithm similar to that described by Bryce et al. [10], aside from our generalization to a network of automata."
    }, {
      "heading" : "IV. NETWORK ENCODING",
      "text" : "We encode the parallel composition of a network of hybrid automata implicitly, as follows. We encode the mode at step i of each automaton with literals of the form mode1i = q1, . . . ,mode m i = qm. We constrain the possible composite jumps with synchronized jump constraints, and noops. With these constraints, we avoid pre-computing all possible O(2|jump|) parallel jumps per step. Instead, we encode O(|jump|m) synchronized jump constraints and O(|Q|m) noops. To determine which jumps must synchronize, we introduce literals for each label and constrain their values with the appropriate jumps. Noop (stutter) clauses encode cases where an automaton does not synchronize any of its transitions, and its mode persists.\nWe define the implicit parallel composition for a k-step M -delay reachability problem as the conjunction of clauses describing each individual automaton, and the goal:\nAlgorithm 4: Filter algorithm. 1 filter(succ, i, N , S, step)\ninput : A set of transitions succ, an index of the current automaton i, a network of automata N , a search stack S, and the current time step step.\n2 succ′ ← {}; 3 siblings← {}; 4 for j = 0 . . . |S|%|N | do 5 siblings← siblings ∪ S.get(|S| − (i− j)); 6 end 7 for (qi\n`i−→ q′i) ∈ succ do 8 if T .contains(modeistep = q′i, ⊥) or 9 ∃l ∈ `i. T .contains(synclstep, ⊥) then\n10 continue; 11 end 12 syncs← >; 13 for (qj\n`j−→ q′j) ∈ siblings do 14 if (`j = {} and qj = q′j and Li ∩ Lj ∩ `i 6= {}) or 15 (`i = {} and qi = q′i and Li ∩ Lj ∩ `j 6= {}) or 16 (Li ∩ Lj ∩ `i 6= Li ∩ Lj ∩ `j) then 17 syncs←⊥; 18 break; 19 end 20 end 21 if syncs then 22 succ′ ← succ′ ∪ (qi\n`i−→ q′i) 23 end 24 end 25 return succ′;\n∃X~x00 ∃X~xt0 . . . ∃X~x0k ∃X~xtk ∃[0,M ]t0 . . . ∃[0,M ]tk. n∧\nj=1\nautom(Hj , k)  ∧ goal(~xtk) ∧ (\nk−1∧ i=0 ∨ l∈L1∪...∪Ln syncli\n)\nThe ~x0i and ~x t i variables denote the values of continuous variables at the start and end of step i. The ti variables denote the duration of step i. The encoding ensures that each automaton behaves appropriately, the goal is satisfied, and at least one non-noop transition occurs in each step.\nThe autom(Hj , k) clauses define the behavior of each\nautomaton Hj as:\ninitj(~x 0 0) ∧ k∧ i=0 maintainj(i)∧\n[ k−1∧ i=0  ∨ q∈Qj noop(q, i) ∨ ∨\njump q `−→q′ (~x t i,~x 0 i+1)∈jumpj\ntransj(jump q `−→q′(~x t i, ~x 0 i+1), i)\n]\nwhich constrain the initial state, the continuous change in each mode at each step, and the transitions between steps.\nThe clause initj(~x00) constrains the initial values of the variables and the initial mode. It defines:∨\ninitq(~x)∈initj\ninitq(~x 0 0) ∧ (mode j 0 = q)\nto constrain the assignments to ~x00 and the initial mode. The maintainj(i) clause defines how the flows and invariants of the automaton Hj govern continuous change:\nflowj(~x 0 i , ~x t i, ti)∧ ∀[0,ti]t ∀X~xi (flowj(~x0i , ~xi, t)→ invj(~xi))\nwhere we note that the nested universal quantifiers ensure that the invariant holds for the entire time the mode is occupied. The nested quantifiers are a unique aspect of our encoding that enables us to reason about nonlinear change [23].\nThe flowj(~x0i , ~x t i, ti) clause defines∧\nq∈Qj\n(modeji = q)→ flowq(~x 0 i , ~x t i, ti)\nThe invj(~xi) clause enables the invariants of the active modes by defining: ∧\nq∈Qj\n(modeji = q)→ invq(~xi)\nNoop clauses noop(q, i) model asynchronous behavior where the automaton does not synchronize, and define:∧\nl∈Lj\n¬syncli  ∧ (modeji = q) ∧ (modeji+1 = q) Jump transition clauses transj(jump\nq `−→q′(~x\nt i, ~x 0 i+1), i) de-\nfine how each jump must synchronize and constrain the variables and modes:\n ∧ l∈`∩Lj syncli ∧ ∧ l∈Lj\\` ¬syncli  ∧ jump q `−→q′(~x t i, ~x 0 i+1)∧ (modeji = q) ∧ (mode j i+1 = q ′)"
    }, {
      "heading" : "V. EMPIRICAL EVALUATION",
      "text" : "Our evaluation studies the effectiveness of our network encoding and HNSolve algorithm. Specifically, we compare three configurations of our solver on several hybrid automaton encodings of PDDL+ problems. The configurations include an unmodified dReach/dReal solver, the addition of the HNSolve algorithm without clause learning, and HNSolve with clause learning. We evaluate the configurations on single automaton encodings [10], and networks of automata encodings based on that of Bogomolov et al. [7]. With the network encodings, we either take the parallel composition and encode a single automaton, or encode the network as described in the previous section.\nWe note that the encodings used in prior work differ in whether they include a “lock” for the actions. Bryce et al. [10] hand-encode a single automaton for each problem that ensures no two actions can occur at the same time. In a network of automata, where each action is represented by its own automaton, Bogomolov et al. [7] ensure that no two actions occur, start, or end simultaneously by introducing a lock automaton. The network of automata models each action so that it must acquire and release the lock when it occurs (atomic actions) or starts/ends (durative actions). This causes the network encoding to require twice the number of encoding steps than the single automaton encoding used by Bryce et al. [10]. We notice that the two step lock is only necessary when enforcing -separation of the actions. Since Bryce et al. [10] do not model -separation we can match their required number of encoding steps with the network of automata by using a\nsingle lock transition that synchronizes with each action. We also compare HNSolve with dReal and existing planners, including SpaceEx [3]–[5], [20], CoLin [15], and UPMurphi [17]. We reproduce previously published results [7] for the SpaceEx, CoLin, and UPMurphi approaches, but report runtimes for HNSolve and dReal from the same machine, a 2.6 GHz Intel Core i7 and 8GB RAM.\nOur approach inherits some of the limitations of using SpaceEx with the Bogomolov et al. [7] network representation of PDDL+. The encoding does not respect the “must” semantics of PDDL+ wherein processes and events must occur when enabled. However, this limitation is not realized in our chosen benchmarks because any use of a process or event is advantageous to the plan. We also note that dReal (and HNSolve as a result) find δ-satisfiable solutions to the LRF encoding. Owing to the undecidable nature of nonlinear hybrid systems, dReal cannot guarantee that a δ-satisfiable solution, which bounds the values of the continuous variables, contains a realizable plan. Defining an appropriately small value for δ minimizes this concern. We also note that dReal in itself is not a full planner. We report results for the minimum step length required to find a plan. A number of strategies for exploring different step lengths in parallel or in sequence have been studied in SAT based planning and can be applied here. We note that these considerations must be incorporated when comparing the results for our approach with that of the other planners. Domains: We use the Generator and Car domains from the literature [7] and the Dribble domain [10]. We compare on linear and nonlinear versions of Generator and Car, but only\na nonlinear version of Dribble. The Car domain includes only atomic actions and processes. The actions are to start or stop the Car, and accelerate or decelerate. The moving process models one-dimensional kinematics (distance as a function of velocity and velocity as a function of acceleration) and the wind-resistance process models the drag effect upon velocity. Additional actions for acceleration or deceleration increase the branching factor of the problem. As the problems scale, each instance i includes actions to accelerate and decelerate by 1, . . . , i units. The linear and nonlinear versions of the domain differ in whether they include the nonlinear wind-resistance process.\nThe Generator domain includes two durative actions: generate, and refuel. The generate action has a duration of 1000 time units and consumes fuel at a linear rate. Its at-end effect satisfies the goal. Its overall condition requires that the fuel level is non-negative. The instances scale in the number of tanks required to refuel the Generator so that its overall condition is satisfied. The refuel actions increase the fuel level in the Generator continuously, by a linear rate (in the linear version) or a nonlinear rate (in the nonlinear version). For example, the refuel action defines the effects linearly as\n(increase (fuel ?g) (* #t 2))\nor nonlinearly\n(increase (ptime ?t) (* #t 1)) (increase (fuel ?g)\n(* #t (* 0.1 (* (ptime ?t) (ptime ?t)))))\nThe Dribble domain involves a process that effects the position x of a ball. The position changes continuously based upon the ball velocity v. The velocity changes continuously due to gravity (−g) and drag (−0.1v2). The available actions are dribble(f ) which decrease velocity by f ∈ {0, 1, 2, 4}. The dribble actions have the precondition that velocity is zero (i.e., the ball is at the top of its arc). The bounce event assigns velocity to −0.9v and has the condition that the ball position x is zero. The initial state places the ball at x = 1 with velocity v = 0 and the goal is to reach 1.5 ≤ x ≤ 3.0. The problem, while it does not scale, can be solved for plan lengths greater than one. We find plans (using two-step locking) for steps k = 8, 12, 16, . . . , 40, which correspond respectively to 2, 3, 4, . . . , 10 dribble actions interleaved with the same number of bounce events. Results: Tables I and II list runtime results for dReal and HNSolve on the respective linear and nonlinear instances. The columns list the number of encoding steps k, domain,\ninstance, and run times in seconds for each encoding and solver configuration. The first three columns of results are denoted by “F” for a hand-coded flat encoding based upon the instances studied by Bryce et al. [10]. The second three columns of results are denoted by “C” for the automatically generated parallel composition of the network encoding into a single automaton. The last three columns denoted by “N” are the instances encoded with the network encoding. Within each group of columns, we denote by “F”, “C”, and “N” the results that do not use the new HNSolve layer. The columns with “+H” denote results for HNSolve without clause learning, and those with “+H+L”, for HNSolve with clause learning. Entries with “-” indicate a timeout of 20 minutes was reached.\nThe results in the Generator domain are listed in the tables with the number of encoding steps k for the twostep lock encoding used in the C and N columns, and the steps in parentheses for the F encodings. The F encodings model the generate action with three steps, and each refuel action with two steps. The C and N encodings model each action with four steps, but is able to achieve the goal before releasing the final lock. Thus, each C and N instance uses one generate action (3 steps), and a number of refuel actions equal to the instance number (4 steps each). The linear results show that all solver configurations have difficulty scaling on the F and C encodings, as reported by [10]. The critical factor is that the encoding grows very large with the size of the instances (see Figure 1). Despite the poor scalability due to the size of the encoding, HNSolve (C+H, C+H+L) can provide some modest improvement over dReal (C). The network encoding N performs significantly better because it uses a tighter encoding. We also see the same trends as for the F and C encodings when comparing the different solver options; HNSolve (N+H, N+H+L) outperforms dReal (N) considerably and clause learning (+L) has a large impact.\nThe Car1 instances use the one-step lock and the Car2 instances use the two-step lock encoding. The F+H results on Car1 are most similar to the results reported by [10]. Our results are somewhat different because they are based upon dReal3, where the prior work results were collected on dReal2. The major difference between these versions of dReal are its use of the IBEX interval constraint solver (dReal3),\nand the Realpaver solver (dReal2). We see that the Car1 instances heavily favor the F encodings, and the use of dReal over HNSolve. In all caes, we see an improvement over dReal (F, C, N) by using HNSolve (+H). We see less of an improvement, and sometimes worse performance when using clause learning (+L). This may be due to the overhead associated with storing the clauses or a reshaping of the search space that leads to more backtracking.\nThe Car2 instances favor the N encoding and HNSolve with clause learning (N+H+L). It appears that the difference is that the relatively shorter encoding lengths in Car1 do not impact the encoding size as in Car2. In Car2 where the encoding length is double that of Car1, the HNSolve is needed to explore the search space. This result is largely consistent with the trend demonstrated in the Generator domain, where HNSolve performs best as the number of encoding steps increases.\nLastly, the Dribble domain highlights how both HNSolve and the network encoding have a positive impact upon peformance. The F+H configuration and encoding is closest to that reported by Bryce et al. [10], and illustrates an improvement over previously published results that we attribute to a difference in dReal version.\nTable III compares HNSolve (N+H+L) with the results reported by [10] (denoted as dReal2, and similar to F+H) and the other planners on linear instances of the Generator and Car domains. As above, each instance scales the respective number of tanks to fill the Generator (where each tank is required) and levels of acceleration/deceleration. We see that HNSolve scales much better than dReal on the Generator domain."
    }, {
      "heading" : "VI. RELATED WORK",
      "text" : "While PDDL+ [19] has been an accepted language for planning with continuous change for nearly a decade, very few planners have been able to handle its expressivity. Planners either assume that all continuous change is linear [7], [15], [16], [26] or handle nonlinear change by discretization [17].\nLP-SAT [26] is very similar in spirit to our work because it uses a SAT solver to solve Boolean constraints and an LP solver to solve continuous (linear) constraints. The nature of the encodings is somewhat different in that our encoding makes use of the hybrid system semantics of PDDL+ in a very direct fashion. LP-SAT more closely resembles classical planning as SAT encodings. Unlike our work, LP-SAT does not incorporate heuristics.\nMore recent work [9], [13] has extended the LP-SAT approach by adapting its encoding for use in contemporary SMT solvers, including dReal and Z3 [24]. Unlike our work on HNSolve, these works focus solely on planning and not model checking hybrid systems. The advantage of focussing on planning encodings is that it is easier to implement the “must” semantics of PDDL+ and adapt existing techniques for SAT-based planning. Nevertheless, not all problems are best phrased as PDDL+, and approaches for reasoning about hybrid systems are necessary.\nBogomolov et al. [7] and Della Penna et al. [17], like our work, make use of the planning as model checking paradigm. Unlike our work, Bogomolov et al. [7] encode a network of linear hybrid automata and we can handle nonlinear automata. Bogomolov et al. [7] use the SpaceEx model checker [20], which performs a symbolic search over the hybrid automata.\nColes et al. [16] and [15] approach PDDL+ from the perspective of heuristic state space search. Coles et al. [16] exploit piecewise linear representations of continuous change to derive powerful pruning conditions for forward heuristic search."
    }, {
      "heading" : "VII. CONCLUSION",
      "text" : "We have described a new specialization of the dReal SMT solver called HNSolve and an associated network of hybrid automata encoding. The combination of HNSolve and the network encoding helps find PDDL+ plans as the number of encoding steps increases, especially with the use of a twostep lock encoding. We have shown that the approach scales up reasoning about PDDL+ planning and that it is competitive with the state of the art.\na) Acknowledgements: This work was supported under ONR contract N00014-13-1-0090."
    } ],
    "references" : [ {
      "title" : "Discrete abstractions of hybrid systems",
      "author" : [ "R. Alur", "T.A. Henzinger", "G. Lafferriere", "G.J. Pappas" ],
      "venue" : "Proceedings of the IEEE,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2000
    }, {
      "title" : "Partial order reductions for timed systems’, in CONCUR’98",
      "author" : [ "Johan Bengtsson", "Bengt Jonsson", "Johan Lilius", "Wang Yi" ],
      "venue" : "Concurrency Theory, 485–500,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1998
    }, {
      "title" : "A box-based distance between regions for guiding the reachability analysis of SpaceEx",
      "author" : [ "S. Bogomolov", "G. Frehse", "R. Grosu", "H. Ladan", "A. Podelski", "M. Wehrle" ],
      "venue" : "Proceedings of the 24th International Conference on Computer Aided Verification (CAV",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2012
    }, {
      "title" : "Guided search for hybrid systems based on coarse-grained space abstractions",
      "author" : [ "Sergiy Bogomolov", "Alexandre Donzé", "Goran Frehse", "Radu Grosu", "Taylor T. Johnson", "Hamed Ladan", "Andreas Podelski", "Martin Wehrle" ],
      "venue" : "International Journal on Software Tools for Technology Transfer,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2015
    }, {
      "title" : "PDDL+ planning with hybrid automata: Foundations of translating must behavior",
      "author" : [ "Sergiy Bogomolov", "Daniele Magazzeni", "Stefano Minopoli", "Martin Wehrle" ],
      "venue" : "Proceedings of the Twenty-Fifth International Conference on Automated Planning and Scheduling,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2015
    }, {
      "title" : "Planning as model checking in hybrid domains",
      "author" : [ "Sergiy Bogomolov", "Daniele Magazzeni", "Andreas Podelski", "Martin Wehrle" ],
      "venue" : "Proceedings of the Twenty-Eighth AAAI Conference on Artificial Intelligence, July",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2014
    }, {
      "title" : "A happening-based encoding for nonlinear pddl+ planning",
      "author" : [ "Daniel Bryce" ],
      "venue" : "AAAI Workshop on Planning for Hybrid Systems,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2016
    }, {
      "title" : "SMT-based nonlinear PDDL+ planning",
      "author" : [ "Daniel Bryce", "Sicun Gao", "David J. Musliner", "Robert P. Goldman" ],
      "venue" : "Proceedings of the Twenty- Ninth AAAI Conference on Artificial Intelligence, January 25-30,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2015
    }, {
      "title" : "Model checking of hybrid systems using shallow synchronization",
      "author" : [ "Lei Bu", "Alessandro Cimatti", "Xuandong Li", "Sergio Mover", "Stefano Tonetta" ],
      "venue" : "Formal Techniques for Distributed Systems,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "BACH : Bounded reachability checker for linear hybrid automata",
      "author" : [ "Lei Bu", "You Li", "Linzhang Wang", "Xuandong Li" ],
      "venue" : "Formal Methods in Computer-Aided Design,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2008
    }, {
      "title" : "SMT-based verification of hybrid systems",
      "author" : [ "Alessandro Cimatti", "Sergio Mover", "Stefano Tonetta" ],
      "venue" : "Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence, July 22-26,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2012
    }, {
      "title" : "PDDL+ planning with events and linear processes",
      "author" : [ "Amanda Jane Coles", "Andrew Ian Coles" ],
      "venue" : "Proceedings of the Twenty-Fourth International Conference on Automated Planning and Scheduling,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2014
    }, {
      "title" : "UPMurphi: A tool for universal planning on PDDL+ problems.",
      "author" : [ "Giuseppe Della Penna", "Daniele Magazzeni", "Fabio Mercorio", "Benedetto Intrigila" ],
      "venue" : "in ICAPS,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2009
    }, {
      "title" : "SpaceEx: Scalable verification of hybrid systems",
      "author" : [ "G. Frehse", "C. Le Guernic", "A. Donzé", "S. Cotton", "R. Ray", "O. Lebeltel", "R. Ripado", "A. Girard", "T. Dang", "O. Maler" ],
      "venue" : "Computer Aided Verification,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2011
    }, {
      "title" : "Delta-complete decision procedures for satisfiability over the reals’, in IJCAR",
      "author" : [ "Sicun Gao", "Jeremy Avigad", "Edmund M. Clarke" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2012
    }, {
      "title" : "dReal: An SMT solver for nonlinear theories over the reals’, in Automated Deduction",
      "author" : [ "Sicun Gao", "Soonho Kong", "Edmund M. Clarke" ],
      "venue" : "International Conference on Automated Deduction, Lake Placid, NY,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2013
    }, {
      "title" : "Satisfiability modulo odes",
      "author" : [ "Sicun Gao", "Soonho Kong", "Edmund M Clarke" ],
      "venue" : "Formal Methods in Computer-Aided Design,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2013
    }, {
      "title" : "Tools and Algorithms for the Construction and Analysis of Systems: 14th International Conference, TACAS 2008, Held as Part of the Joint European Conferences on Theory and Practice of Software",
      "author" : [ "Leonardo Moura", "Nikolaj Bjørner" ],
      "venue" : "ETAPS 2008, Budapest,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2008
    }, {
      "title" : "Conflict-directed graph coverage",
      "author" : [ "Daniel Schwartz-Narbonne", "Martin Schäf", "Dejan Jovanovic", "Philipp Rümmer", "Thomas Wies" ],
      "venue" : "NASA Formal Methods - 7th International Symposium,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2015
    }, {
      "title" : "Processes and continuous change in a SAT-based planner",
      "author" : [ "Ji-Ae Shin", "Ernest Davis" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2005
    }, {
      "title" : "Solving polynomial systems using a branch and prune approach",
      "author" : [ "Pascal Van Hentenryck", "David McAllester", "Deepak Kapur" ],
      "venue" : "SIAM Journal on Numerical Analysis,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 5,
      "context" : "Recent planners ( [7] and [6]) for PDDL+ [19] represent actions, processes, events, and state variables as a network of synchronized hybrid automata (HA), but there are no suitable algorithms for reasoning about nonlinear change in a network of automata.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 4,
      "context" : "Recent planners ( [7] and [6]) for PDDL+ [19] represent actions, processes, events, and state variables as a network of synchronized hybrid automata (HA), but there are no suitable algorithms for reasoning about nonlinear change in a network of automata.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 7,
      "context" : "We address nonlinear PDDL+ problems by adapting the dReal Satisfiability Modulo Theories (SMT) solver [10], [22], which has been previously shown to address nonlinear PDDL+ as a single hybrid automaton.",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 15,
      "context" : "We address nonlinear PDDL+ problems by adapting the dReal Satisfiability Modulo Theories (SMT) solver [10], [22], which has been previously shown to address nonlinear PDDL+ as a single hybrid automaton.",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 1,
      "context" : "known that reasoning about the explicit parallel composition of a network of automata as a single automaton is usually a poor choice because it grows exponentially in the size of the individual synchronized automata [2], [11], [14].",
      "startOffset" : 216,
      "endOffset" : 219
    }, {
      "referenceID" : 8,
      "context" : "known that reasoning about the explicit parallel composition of a network of automata as a single automaton is usually a poor choice because it grows exponentially in the size of the individual synchronized automata [2], [11], [14].",
      "startOffset" : 221,
      "endOffset" : 225
    }, {
      "referenceID" : 10,
      "context" : "known that reasoning about the explicit parallel composition of a network of automata as a single automaton is usually a poor choice because it grows exponentially in the size of the individual synchronized automata [2], [11], [14].",
      "startOffset" : 227,
      "endOffset" : 231
    }, {
      "referenceID" : 10,
      "context" : "We base our HA network SMT encoding upon prior work [14] that repre-",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 7,
      "context" : "[10] within our proposed HNSolve algorithm.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 15,
      "context" : "A similar technique is employed by the dReach [22] and BACH [12] algorithms, but these encode a different SMT instance for each discrete run and do not benefit from learned conflict clauses.",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 9,
      "context" : "A similar technique is employed by the dReach [22] and BACH [12] algorithms, but these encode a different SMT instance for each discrete run and do not benefit from learned conflict clauses.",
      "startOffset" : 60,
      "endOffset" : 64
    }, {
      "referenceID" : 7,
      "context" : "[10], guides dReal variable selection to construct discrete-feasible runs, but differs in two main aspects.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "Developing problem-specific SMT solver algorithms was also recently explored in the context of program analysis [25].",
      "startOffset" : 112,
      "endOffset" : 116
    }, {
      "referenceID" : 5,
      "context" : "We evaluate the HNSolve algorithm on several PDDL+ planning benchmarks encoded as networks of hybrid automata, as developed in prior work [7].",
      "startOffset" : 138,
      "endOffset" : 141
    }, {
      "referenceID" : 14,
      "context" : "trary collection F of Type 2 computable real functions [21].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 15,
      "context" : "[22] describe how to unroll this encoding for a single automaton.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "The ICP solver uses the branch and prune [27] algorithm to refine a set of intervals over the continuous variables (called a box).",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 0,
      "context" : "HNSolve solves a discrete abstraction [1], [11] of the hybrid reachability problem and coordinates the SAT solver in making assignments corresponding to its solution.",
      "startOffset" : 38,
      "endOffset" : 41
    }, {
      "referenceID" : 8,
      "context" : "HNSolve solves a discrete abstraction [1], [11] of the hybrid reachability problem and coordinates the SAT solver in making assignments corresponding to its solution.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 7,
      "context" : "[10], aside from our generalization to a network of automata.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "The nested quantifiers are a unique aspect of our encoding that enables us to reason about nonlinear change [23].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 7,
      "context" : "We evaluate the configurations on single automaton encodings [10], and networks of automata encodings based on that of Bogomolov et al.",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 5,
      "context" : "[7].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[10] hand-encode a single automaton for each problem that",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "[7] ensure that no two actions occur, start, or end simultaneously by introducing a lock automaton.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 7,
      "context" : "[10].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "[10] do",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : "We also compare HNSolve with dReal and existing planners, including SpaceEx [3]–[5], [20], CoLin [15], and UPMurphi [17].",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 13,
      "context" : "We also compare HNSolve with dReal and existing planners, including SpaceEx [3]–[5], [20], CoLin [15], and UPMurphi [17].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 12,
      "context" : "We also compare HNSolve with dReal and existing planners, including SpaceEx [3]–[5], [20], CoLin [15], and UPMurphi [17].",
      "startOffset" : 116,
      "endOffset" : 120
    }, {
      "referenceID" : 5,
      "context" : "We reproduce previously published results [7] for the SpaceEx, CoLin, and UPMurphi approaches, but report runtimes for HNSolve and dReal from the same machine, a 2.",
      "startOffset" : 42,
      "endOffset" : 45
    }, {
      "referenceID" : 5,
      "context" : "[7] network representation of PDDL+.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "Domains: We use the Generator and Car domains from the literature [7] and the Dribble domain [10].",
      "startOffset" : 66,
      "endOffset" : 69
    }, {
      "referenceID" : 7,
      "context" : "Domains: We use the Generator and Car domains from the literature [7] and the Dribble domain [10].",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 7,
      "context" : "[10].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "show that all solver configurations have difficulty scaling on the F and C encodings, as reported by [10].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 7,
      "context" : "The F+H results on Car1 are most similar to the results reported by [10].",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 7,
      "context" : "[10], and illustrates an improvement over previously published results that we attribute to a difference in dReal version.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 7,
      "context" : "Table III compares HNSolve (N+H+L) with the results reported by [10] (denoted as dReal2, and similar to F+H) and the other planners on linear instances of the Generator and Car domains.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 5,
      "context" : "Planners either assume that all continuous change is linear [7], [15], [16], [26] or handle nonlinear change by discretization [17].",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 11,
      "context" : "Planners either assume that all continuous change is linear [7], [15], [16], [26] or handle nonlinear change by discretization [17].",
      "startOffset" : 71,
      "endOffset" : 75
    }, {
      "referenceID" : 19,
      "context" : "Planners either assume that all continuous change is linear [7], [15], [16], [26] or handle nonlinear change by discretization [17].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 12,
      "context" : "Planners either assume that all continuous change is linear [7], [15], [16], [26] or handle nonlinear change by discretization [17].",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 19,
      "context" : "LP-SAT [26] is very similar in spirit to our work because it uses a SAT solver to solve Boolean constraints and an LP solver to solve continuous (linear) constraints.",
      "startOffset" : 7,
      "endOffset" : 11
    }, {
      "referenceID" : 6,
      "context" : "More recent work [9], [13] has extended the LP-SAT approach by adapting its encoding for use in contemporary SMT solvers, including dReal and Z3 [24].",
      "startOffset" : 17,
      "endOffset" : 20
    }, {
      "referenceID" : 17,
      "context" : "More recent work [9], [13] has extended the LP-SAT approach by adapting its encoding for use in contemporary SMT solvers, including dReal and Z3 [24].",
      "startOffset" : 145,
      "endOffset" : 149
    }, {
      "referenceID" : 5,
      "context" : "[7] and Della Penna et al.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 12,
      "context" : "[17], like our work, make use of the planning as model checking paradigm.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "[7] encode a network of linear hybrid automata and we can handle nonlinear automata.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 5,
      "context" : "[7] use the SpaceEx model checker [20], which performs a symbolic search over the hybrid automata.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 13,
      "context" : "[7] use the SpaceEx model checker [20], which performs a symbolic search over the hybrid automata.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 11,
      "context" : "[16] and [15] approach PDDL+ from the perspective of heuristic state space search.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "[16] exploit piecewise linear representations of continuous change to derive powerful pruning conditions for forward heuristic search.",
      "startOffset" : 0,
      "endOffset" : 4
    } ],
    "year" : 2016,
    "abstractText" : "PDDL+ planning has its semantics rooted in hybrid automata (HA) and recent work has shown that it can be modeled as a network of HAs. Addressing the complexity of nonlinear PDDL+ planning as HAs requires both space and time efficient reasoning. Unfortunately, existing solvers either do not address nonlinear dynamics or do not natively support networks of automata. We present a new algorithm, called HNSolve, which guides the variable selection of the dReal Satisfiability Modulo Theories (SMT) solver while reasoning about network encodings of nonlinear PDDL+ planning as HAs. HNSolve tightly integrates with dReal by solving a discrete abstraction of the HA network. HNSolve finds composite runs on the HA network that ignore continuous variables, but respect mode jumps and synchronization labels. HNSolve admissibly detects dead-ends in the discrete abstraction, and posts conflict clauses that prune the SMT solver’s search. We evaluate the benefits of our HNSolve algorithm on PDDL+ benchmark problems and demonstrate its performance with respect to prior work.",
    "creator" : "LaTeX with hyperref package"
  }
}