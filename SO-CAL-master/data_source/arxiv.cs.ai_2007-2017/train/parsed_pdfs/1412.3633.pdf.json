{
  "name" : "1412.3633.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Logic of temporal attribute implications",
    "authors" : [ "Jan Triska", "Vilem Vychodil" ],
    "emails" : [ "jan.triska@upol.cz," ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n41 2.\n36 33\nv2 [\ncs .L\nO ]\nWe study logic for reasoning with if-then formulas describing dependencies between attributes of objects which are observed in consecutive points in time. We introduce semantic entailment of the formulas, show its fixed-point characterization, investigate closure properties of model classes, present an axiomatization and prove its completeness, and investigate alternative axiomatizations and normalized proofs. We investigate decidability and complexity issues of the logic and prove that the entailment problem is NP-hard and belongs to EXPSPACE. We show that by restricting to predictive formulas, the entailment problem is decidable in pseudo-linear time.\nKeywords: attribute implication, complete axiomatization, entailment problem, fixed point, functional dependency, temporal semantics"
    }, {
      "heading" : "1 Introduction",
      "text" : "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications. In these disciplines, the rules often appear under different names (e.g., attribute implications, functional dependencies, or\n∗e-mail: jan.triska@upol.cz, phone: +420 585 634 715, fax: +420 585 411 643\nsimply “rules”) with semantics defined in various structures (e.g., transactional data, boolean matrices, or n-ary relations) but as it has been shown in [21], the rules may be seen as propositional formulas with the semantic entailment defined as in the propositional logic, possibly extended by additional measures of interestingness. The rules are popular because of their easy readability for non-expert users and tractability of the entailment problem which is decidable in linear time [6]. Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].\nIn this paper, we introduce if-then formulas which express presence of attributes relatively in time and the formulas are evaluated in data where the presence or absence of attributes changes in time. In our approach, we adopt the notion of a discrete time, i.e., the data are observed at distinct points in time. We consider a formula valid in data changing over time if the if-then dependency prescribed by the formula holds in all time points. We introduce the formulas as expressions\n{ yi11 , . . . , y im m } ⇒ { z j1 1 , . . . , z jn n } , (1)\nwhere y1, . . . , ym and z1, . . . , zn are attributes which may be viewed as propositional variables, and i1, . . . , im, j1, . . . , jn are integers annotating the attributes by relative time points with the following meaning: 0 denotes the present time point, 1 is its immediate successor, −1 is the immediate predecessor of 0, 2 is the immediate successor of 1, etc. With this interpretation of time points and considering, for instance, the unit of time “a day”, formula {x−1, y0} ⇒ {z1} prescribes the following dependency: “If x was present yesterday and y is present today, then z will be present tomorrow.” From our perspective, a classic if-then formula\n{ y1, . . . , ym } ⇒ { z1, . . . , zn } , (2)\nmay be seen as a particular case of (1), where all the relative time points\ni1, . . . , im, j1, . . . , jn are equal to 0, and the data in which the formula is evaluated is constant in all time points.\nWe provide answers to several questions which emerge with formulas like (1). First, we define the notion of semantic entailment of the formulas, investigate closure structures of models of theories consisting of such formulas, and show that the problem of checking whether a formula is semantically entailed by a set of formulas can be reduced to checking its validity in a single model. Second, we prove that the semantic entailment has a complete axiomatization. That is, we show a notion of provability of formulas like (1) and show that it coincides with the semantic entailment. We discuss several possible axiomatizations, including ones that can be used to consider proofs in particular normal forms. Third, based on our insight into the properties of the semantic entailment and provability, we derive results on decidability and complexity of the entailment problem. Fourth, we include notes on the relationship of the formulas to formulas appearing in modal logics [9] and triadic formal concept analysis [34]. Similar rules as we consider in this paper appeared as inter-transaction association rules [52] inferred from time-changing transactional data. Despite the popularity of the rules in data mining, a logical analysis of the entailment of the rules and related properties is missing—providing the logical foundations is a goal of our paper.\nOur paper is organized as follows. In Section 2 and Section 3, we present a survey of related work and short preliminaries. We introduce the formulas and present the results on their semantic entailment in Section 4. In Section 5 we give complete axiomatizations and in Section 6 we deal with the related computational issues. Finally, in Section 7, we present a conclusion."
    }, {
      "heading" : "2 Related Work",
      "text" : "In database systems and knowledge engineering, there appeared isolated approaches which propose temporal semantics of if-then rules. We present here a short survey of the approaches and highlight the differences between our ap-\nproach and the existing ones.\nFormulas called temporal functional dependencies emerged in databases with time granularities [7]. In this approach, a time granularity is a general partition of time like seconds, weeks, years, etc., and a time granularity is associated to each relational schema. In addition, each tuple in a relation is associated with a part (so-called granule) of granularity. In this setting, temporal functional dependencies are like the ordinary functional dependencies [21] with a time granularity as an additional component. The concept of validity of temporal functional dependencies is defined in much the same way as its classic counterpart and includes an additional condition that granules of tuples need to be covered by any granule from granularity of the temporal functional dependency. Thus, [7] uses an ordinary notion of validity of functional dependencies which is restricted to some time segments. This is conceptually very different from the problem we deal with in this paper.\nSeveral approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46]. In these approaches, the input data is in the form of transactions (i.e., subsets of items) where each transaction occurred at some point in time and the interest of the papers lies in extracting association rules from data which occur during a specified time cycle. For instance, one may be interested in extracting rules which are valid in “every spring month of a year”, “every Monday in every year”, etc. As in the case of the temporal functional dependencies, the temporal association rules may be understood as classic association rules occurring during specified time cycles.\nOther results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches. The papers propose algorithms to extract, given an input transactional data and a measure of interestingness (based on levels of minimal support and confidence), if-then rules which are preserved over a given period of time. From this point of view, the rules can be seen as formulas studied in this paper restricted to so-called predictive rules (see Definition 33 in Sec-\ntion 6) whose validity is considered with respect to the additional parameter of interestingness. As a consequence, the inter-transaction association rules are related to the rules in our approach in the same way as the ordinary association rules [1] are related to the ordinary attribute implications [26]. The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic. In contrast, the problems of entailment of rules are central to this paper and we show there is reasonably strong logic for reasoning with such rules. Our observations may stimulate further development in the field of inter-transaction association rules and similar formulas and their applications in various domains [23, 30].\nThe formulas studied in this paper are also related to particular program rules which appear in Datalog extensions dealing with flow of time and related phenomena [10, 11, 12] such as DatalognS (Datalog with n successors). The formulas we consider in our paper correspond to a fragment of rules which appear in such Datalog extensions. Despite the similar form of our formulas and the program rules, there does not seem to be a direct relationship (or a reduction) of the entailment problem of our formulas and the recognition problem of DatalognS programs."
    }, {
      "heading" : "3 Preliminaries",
      "text" : "In this section, we present the basic notions of closure systems (also known as Moore families) and closure operators which are used further in the paper. More details can be found in [8, 18].\nIf Y is a set, we denote by 2Y its power set. A closure operator on Y is a\nmap c : 2Y → 2Y such that\nA ⊆ c(A), (3)\nA ⊆ B implies c(A) ⊆ c(B), (4)\nc(c(A)) ⊆ c(A), (5)\nfor all A,B ⊆ Y . The conditions (3)–(5) are called the extensivity, monotony, and idempotency of c, respectively. Note that (3) and (5) yield c(A) = c(c(A)) for all A ⊆ Y . A closure operator c : 2Y → 2Y is called an algebraic closure operator whenever\nc(A) = ⋃ {c(B) |B ⊆ A and B is finite} (6)\nfor all A ⊆ Y . Moreover, A ⊆ Y is called a fixed point of c whenever c(A) = A.\nA system S ⊆ 2Y is called a closure system on Y if it is closed under arbitrary intersections, i.e., ⋂ A ∈ S for any A ⊆ S. In the paper we utilize the wellknown correspondence between closure systems and closure operators on Y . In particular, if c is an algebraic closure operator on Y , we call the closure system of all its fixed points the algebraic closure system induced by c."
    }, {
      "heading" : "4 Formulas, Models, and Semantic Entailment",
      "text" : "In this section, we present a formalization of the formulas, their interpretation, and semantic entailment. Let us assume that Y is a non-empty and finite set of symbols called attributes. Furthermore, we use integers in order to denote time points. We put\nTY = { yi | y ∈ Y and i ∈ Z } (7)\nand interpret each yi ∈ TY as “attribute y observed in time i” (technically, TY can be seen as the Cartesian product Y ×Z). Under this notation, we may now formalize rules like (1) as follows:\nDefinition 1. An attribute implication over Y annotated by time points in Z is a formula of the form A⇒ B, where A,B are finite subsets of TY .\nAs we have outlined in the introduction, the purpose of time points encoded by integers which appear in antecedents and consequents of the considered formulas is to express points in time relatively to a current time point. Hence, the intended meaning of (1) abbreviated by A ⇒ B is the following: “For all time\npoints t, if an object has all the attributes from A considering t as the current time point, then it must have all the attributes from B considering t as the current time point”. In what follows, we formalize the interpretation of A⇒ B in this sense.\nSince we wish to define formulas being true in all time points (we are interested in formulas preserved over time), we need to shift relative times expressed in antecedents and consequents in formulas with respect to a changing time point. For that purpose, for each M ⊆ TY and i ∈ Z, we may introduce a subset M + j of TY by\nM + j = { yi+j | yi ∈M } (8)\nand call it a time shift of M by j (shortly, a j-shift of M). In the paper, we utilize the following properties of time shifts.\nProposition 2. For all M,N ⊆ TY , {Nk ⊆ TY | k ∈ K}, and i, j ∈ Z, we get\nif M ⊆ N then M + i ⊆ N + i, (9)\n(M + i) + j =M + (i+ j), (10) ⋃\nk∈K(Nk + i) = ⋃ k∈K Nk + i, (11)\n⋂ k∈K(Nk + i) = ⋂ k∈K Nk + i. (12)\nProof. All (9)–(12) follow directly from (8).\nBased on (10), we may omit parentheses and write M + j + i instead of\n(M + i) + j. Also, we write M − i to denote M + (−i).\nAttribute implications annotated by time points are formulas, i.e., syntactic\nnotions for which we define their semantics (interpretation) as follows.\nDefinition 3. A formula A⇒ B is true in M ⊆ TY whenever, for each i ∈ Z,\nif A+ i ⊆M , then B + i ⊆M (13)\nand we denote the fact by M |= A⇒ B.\nRemark 1. (a) The value of i in the definition may be understood as a sliding time point. Moreover, A + i and B + i represent sets of attributes annotated by absolute time points considering i as the current time point. Note that using (8), the condition (13) can be equivalently restated as “A ⊆M − i implies B ⊆ M − i,” i.e., instead of shifting the antecedents and consequents of the formula, we may shift the set M .\n(b) Observe that A ⇒ B is trivially true in M whenever B ⊆ A because in that case (13) trivially holds for any i. By definition, A⇒ B is not true in M , written M 6|= A ⇒ B iff there is i such that A + i ⊆ M and B + i * M . In words, in the time point i, M has all the attributes of A but does not have an attribute in B, i.e., the time point i serves as a counterexample.\nExample 1. One particular example of a subsetM of TY can be a daily weather observation from an airport station. For instance, we can consider Y as\nY = {rn, rl, rm, tv, tc, tm, wl, wm, ws},\nwhere the attributes have the following meaning: “no rainfall” (denoted rn), “light rainfall” (denoted rl), “moderate rainfall” (denoted rm), “temperature\nis very cold”, (denoted tv), “temperature is cold”, (denoted tc) “temperate is mild”, (denoted tm) “light wind” (denoted wl), “moderate wind” (denoted wm), and “strong wind” (denoted ws). A subset of TY may be depicted as a two-dimensional table with rows corresponding to time points, columns corresponding to attributes in Y , and crosses and blanks in the table, indicating whether attributes annotated by time points belong to the subset. For instance, if M is given by the table in Figure 4, then rn15 ∈ M , rl15 6∈ M , etc1. In this case, we haveM |= {wl0, wm1} ⇒ {tc3}. On the other hand, M 6|= {wm0, wl1} ⇒ {tc3, rm3, tc4} because for i = 22, we have {wm0, wl1}+22 = {wm22, wl23} ⊆M and {tc3, rm3, tc4}+ 22 = {tc25, rm25, tc26} *M .\nWe consider the following notions of a theory and a model:\nDefinition 4. Let Σ be a set of formulas (called a theory). A subset M ⊆ TY is called a model of Σ if M |= A ⇒ B for all A ⇒ B ∈ Σ. The system of all models of Σ is denoted by Mod(Σ), i.e.,\nMod(Σ) = { M ⊆ TY |M |= A⇒ B for all A⇒ B ∈ Σ } . (14)\nIn general, Mod(Σ) is infinite and there may be theories that do not have\nany finite model. For instance, consider a theory containing ∅ ⇒ {y0}.\nWe now turn our attention to the structure of systems of all models of attribute implications annotated by time points. In case of the ordinary attribute implications, it is well known that systems of their models are exactly closure systems in Y . Interestingly, the systems of models in our case are exactly the algebraic closure systems which are closed under time shifts. This additional closure property is introduced by the following definition.\nDefinition 5. A system S ⊆ 2TY of subsets of TY is called closed under time shifts whenever M + i ∈ S for all M ∈ S and i ∈ Z.\nWe first show that Mod(Σ) is a closure system closed under time shifts:\n1The data is based on discretization of real meteorological information for Aug 14 which\ncan be found at http://www.bom.gov.au/climate/dwo/IDCJDW0100.shtml .\nTheorem 6. Let Σ be a theory. Then, Mod(Σ) is closed under arbitrary intersections and time shifts.\nProof. The fact that Mod(Σ) is closed under arbitrary intersections follows by analogous arguments as in the case of ordinary attribute implications taking into account that (13) must hold for all i ∈ Z. That is, for any M ⊆ Mod(Σ) and arbitrary A ⇒ B ∈ Σ, we reason as follows. If A + i ⊆ ⋂ M, then A + i ⊆ M for all M ∈ M and thus B + i ⊆ M for all M ∈ M because M ⊆ Mod(Σ). Therefore, B+ i ⊆ ⋂ M, proving ⋂ M |= A⇒ B which further gives ⋂ M ∈ Mod(Σ) since A⇒ B ∈ Σ was arbitrary.\nIn order to show that Mod(Σ) is closed under time shifts, takeM ∈ Mod(Σ) and j ∈ Z. It suffices to prove that M + j ∈ Mod(Σ). In order to see that, take A⇒ B ∈ Σ. If A+ i ⊆M + j, then A+ (i− j) ⊆M and thus B + (i− j) ⊆M because M ∈ Mod(Σ) and A ⇒ B ∈ Σ. Therefore, B + i ⊆ M + j, i.e., M + j |= A⇒ B for arbitrary A⇒ B ∈ Σ, showing M + j ∈ Mod(Σ).\nTaking into account Theorem 6, for each theory Σ, we may consider a closure operator induced by Mod(Σ) which maps each M ⊆ TY to the least model of Σ containing M .\nDefinition 7. Let Σ be a theory. For each M ⊆ TY , we put\n[M ]Σ = ⋂ {N ∈ Mod(Σ) |M ⊆ N} (15)\nand call [M ]Σ the semantic closure of M under Σ.\nUsing the well-known relationship between closure operators and closure systems, [· · ·]Σ defined by (15) is indeed a closure operator. Note that in general, [M ]Σ is infinite even if Y andM are finite. This is in contrast with the ordinary attribute implications using finite Y . Nevertheless, in our setting we can prove that even if [M ]Σ is infinite, it can be obtained as a union of finitely generated elements of Mod(Σ), showing that Mod(Σ) is in fact an algebraic closure system.\nTheorem 8. Let Σ be a theory. For each M ⊆ TY , we have\n[M ]Σ = ⋃ {[N ]Σ |N is finite subset of M}. (16)\nProof. Observe that the monotony of [· · ·]Σ yields [N ]Σ ⊆ [M ]Σ for any finite N ⊆M and thus the “⊇”-part of (16) is obvious.\nFor brevity, put M = {[N ]Σ |N is finite subset of M}. In order to prove the “⊆”-part of (16), it suffices to show that ⋃ M is a model of Σ which containsM because [M ]Σ is the least model of Σ containing M . For any y i ∈ M , we have [{yi}]Σ ∈ M and thus yi ∈ [{yi}]Σ ⊆ ⋃ M by the extensivity of [· · ·]Σ which proves M ⊆ ⋃ M.\nNow, take any A ⇒ B ∈ Σ and suppose that A + i ⊆ ⋃ M. Observe that for every yj ∈ A+ i there is [Nyj ]Σ ∈ M such that y j ∈ [Nyj ]Σ. Moreover, the fact that A+ i is finite yields that ⋃ {Nyj | y\nj ∈ A+ i} is finite and we thus have [⋃\n{Nyj | y j ∈ A+ i}\n]\nΣ ∈ M. Clearly, A+ i ⊆\n[⋃ {Nyj | y j ∈ A+ i} ]\nΣ and thus\nit follows that B + i ⊆ [⋃\n{Nyj | y j ∈ A + i}\n]\nΣ ⊆\n⋃ M because A ⇒ B ∈ Σ.\nAltogether, ⋃ M |= A⇒ B and so ⋃ M ∈ Mod(Σ).\nUsing Theorem 8, we may establish that each algebraic closure system closed under time shifts is a system of models of some theory consisting of attribute implications annotated by time points. Before we go to the proof, we show how the property of being closed under time shifts can be formulated in terms of closure operators.\nLemma 9. Let S be a closure system which is closed under arbitrary time shifts and let CS be the induced closure operator. For each M ⊆ TY and i ∈ Z,\nCS(M + i) = CS(M) + i. (17)\nProof. “⊆”: Since S is closed under time shifts, we get CS(M) + i ∈ S. In addition, M + i ⊆ CS(M) + i on account of the extensivity of CS and (9). Therefore, CS(M + i) ⊆ CS(M) + i by monotony and idempotency of CS .\n“⊇”: The extensivity of CS gives M + i ⊆ CS(M + i) and thus M ⊆ CS(M + i) − i. Moreover, CS(M + i) − i ∈ S because S is closed under time shifts and thus CS(M) ⊆ CS(M+i)−i which gives CS(M)+i ⊆ CS(M+i).\nLemma 10. Let C be a closure operator satisfying C(M + i) = C(M) + i for\neach M ⊆ TY and i ∈ Z. Then, the system SC of all fixed points of C is closed under arbitrary time shifts.\nProof. TakeM ∈ SC and any i ∈ Z, i.e.,M ⊆ TY such thatM = C(M). Clearly, M + i = C(M) + i and since C(M) + i = C(M + i), we get M + i = C(M + i), proving that M + i ∈ SC.\nThe previous two lemmas give the following consequence.\nCorollary 11. A closure system S is closed under arbitrary time shifts iff the corresponding closure operator CS satisfies (17).\nBased on our previous observations, we may now establish the connection between systems of models of attribute implications annotated by time points and algebraic closure systems closed under time shifts.\nTheorem 12. Let S ⊆ 2TY be an algebraic closure system which is closed under time shifts. Then, there is a theory Σ such that S = Mod(Σ).\nProof. Assume that CS is the closure operator induced by S and put\nΣ = {A⇒ B |A ⊆ TY , B ⊆ CS(A), and A,B are finite}.\nWe show that S = Mod(Σ) by proving that both inclusions hold.\n“⊆”: Take M ∈ S and a finite B ⊆ CS(A) for a finite A ⊆ TY . We now check thatM |= A⇒ B. Assume that A+ i ⊆M . Then, A ⊆M − i and by the monotony of CS and utilizing (17), we have CS(A) ⊆ CS(M−i) = CS(M)−i = M − i which yields that B ⊆M − i, i.e., B+ i ⊆M , showing M |= A⇒ B. As a consequence, S ⊆ Mod(Σ).\n“⊇”: We letM ∈ Mod(Σ) and prove thatM ∈ S which means to prove that CS(M) = M . Since S is an algebraic closure system, it suffices to check that CS(A) ⊆M for each finite A ⊆M . Assuming that A ⊆M and A is finite, take any finite B ⊆ CS(A). By definition, A ⇒ B ∈ Σ and since M ∈ Mod(Σ), we get that for i = 0, A+0 ⊆M implies B+0 ⊆M . Since A+0 = A and A ⊆M , we therefore obtain B = B + 0 ⊆M . Since B was an arbitrary finite subset of CS(A), we conclude that CS(A) ⊆M .\nWe now define semantic entailment of formulas and explore its properties. The notion is defined the usual way using the notion of a model introduced before.\nDefinition 13. Let Σ be a theory. Formula A⇒ B is semantically entailed by Σ if M |= A⇒ B for each M ∈ Mod(Σ).\nThe following lemma justifies the description of time points in attribute implications as relative time points. Namely, it states that each A⇒ B semantically entails all formulas resulting by shifting the antecedent and consequent of A⇒ B by a constant factor.\nLemma 14. {A⇒ B} |= A+ i⇒ B + i.\nProof. TakeM ∈ Mod({A⇒ B}) and let (A+ i)+j ⊆M . Then, A+ i ⊆M−j and by Theorem 6, we getM − j ∈ Mod({A⇒ B}) which yields B+ i ⊆M − j and thus (B + i) + j ⊆M , proving M |= A+ i⇒ B + i\nAnalogously as for the classic attribute implications, the semantic entailment of A ⇒ B by a theory Σ can be checked using the least model of Σ generated by A as it is shown in the following theorem.\nTheorem 15. For any Σ and A⇒ B, the following conditions are equivalent:\n(i) Σ |= A⇒ B,\n(ii) [A]Σ |= A⇒ B,\n(iii) B ⊆ [A]Σ.\nProof. Clearly, (i) implies (ii) since [A]Σ ∈ Mod(Σ); (ii) implies (iii) because A + 0 ⊆ [A]Σ. Assume that (iii) holds and take M ∈ Mod(Σ) and i ∈ Z such that A+ i ⊆ M . Then, A ⊆ M − i and thus B ⊆ [A]Σ ⊆ [M − i]Σ = [M ]Σ − i by (17) from which it follows that B + i ⊆ [M ]Σ =M , proving (i).\nWe conclude this section by notes on the propositional semantics of our formulas. The classic attribute implications on finite Y can be understood as\npropositional formulas. Namely, an attribute implication of the from (2) can be seen as a propositional formula\n( y1N · · ·N ym ) ⇒ ( z1 N · · ·N zn ) , (18)\nwhere N is the symbol for conjunction and y1, . . . , ym, z1, . . . , zn are propositional variables. Thus, (18) may be called a propositional counterpart of (2). Obviously, there are in general several propositional counterparts of (2) since formulas equivalent to (18) in sense of the propositional logic result, e.g., by rearranging the propositional variables y1, . . . , ym, z1, . . . , zn in a different order. We neglect this aspect and always consider a fixed propositional counterpart of each attribute implication. It can be shown that if one takes the propositional counterparts of attribute implications, then their semantic entailment in sense of the propositional logic coincides with the semantic entailment as it is defined for attribute implications. We now show that an analogous correspondence can also be established in our case.\nWe start by considering the following notation. For any finite A,B ⊆ TY\nand for any M ⊆ TY , we put M |=PL A ⇒ B whenever A * M or B ⊆ M . That is, M |=PL A⇒ B means that A⇒ B is true in M as a classical attribute implication. Clearly, M |=PL A⇒ B does not imply that M |= A⇒ B in sense of Definition 3. Moreover, we may introduce the set of models of Σ in the classic sense:\nModPL(Σ) = { M ⊆ TY |M |=PL A⇒ B for all A⇒ B ∈ Σ } (19)\nand put Σ |=PL A ⇒ B whenever M |=PL A ⇒ B for all M ∈ Mod PL(Σ). Therefore, |=PL denotes the semantic entailment of attribute implications in the classic sense. Again, |=PL is in general different from |= introduced in Definition 13 but we can establish the following characterization:\nTheorem 16. Let Σ be a theory and let\nΣPL = {A+ i⇒ B + i |A⇒ B ∈ Σ and i ∈ Z}. (20)\nThen Mod(Σ) = ModPL(ΣPL). As a consequence, for each A ⇒ B, we have Σ |= A⇒ B iff ΣPL |=PL A⇒ B.\nProof. The first part of the claim is easy to see. Indeed, for each A⇒ B we have M ∈ Mod({A⇒ B}) iff for each i ∈ Z, we have A+ i ⊆M implies B + i ⊆M which is true iff M ∈ ModPL({A + i ⇒ B + i | i ∈ Z}). Hence, it follows that Mod(Σ) = ModPL(ΣPL).\nNow, assume that Σ |= A ⇒ B and take M ∈ ModPL(ΣPL) such that A ⊆M . Then A+0 ⊆M and M ∈ Mod(Σ) and thus B = B+0 ⊆M , proving that ΣPL |=PL A ⇒ B. Conversely, let ΣPL |=PL A ⇒ B and A + i ⊆ M for M ∈ Mod(Σ). That is, we have A ⊆ M − i and, owing to Theorem 6, M − i ∈ Mod(Σ) = ModPL(ΣPL). As a consequence of M − i |=PL A ⇒ B, we get B ⊆ M − i and thus B + i ⊆ M , showing Σ |= A ⇒ B. Altogether, Σ |= A⇒ B iff ΣPL |=PL A⇒ B.\nNow, based on Theorem 16, we may argue that for each Σ there is a set of propositional formulas Σ′ such that the propositional counterpart of A⇒ B follows by Σ′ in sense of the propositional logic. Indeed, Σ′ can be taken as the set of propositional counterparts to all formulas in ΣPL: Owing to Theorem 16, A ⇒ B follows by ΣPL as a classic attribute implication over (a denumerable set of attributes) TY and thus the propositional counterpart of A ⇒ B follows by the propositional counterparts to all formulas in ΣPL."
    }, {
      "heading" : "5 Deduction Systems and Complete Axiomatizations",
      "text" : "In this section, we present a deduction system for our formulas and a related notion of provability which represents the syntactic entailment of formulas. The provability is based on an extension of the Armstrong axiomatic system [3] which is well known mainly in database systems [42]. The extension we propose accommodates the fact that time points in formulas are relative. The deductive system we use consists of the following deduction rules.\nDefinition 17. We introduce the following deduction rules :\n(Ax) infer A∪B ⇒ A,\n(Cut) from A⇒ B and B∪C ⇒ D infer A∪C ⇒ D,\n(Shf) from A⇒ B infer A+ i⇒ B + i,\nwhere i ∈ Z and A,B,C,D are arbitrary finite subsets of TY .\nRemark 2. (a) Note that there are several equivalent systems which are called the Armstrong systems [42]. In our presentation, the rule (Ax) can be seen as a nullary deduction rule which is an axiom scheme, i.e., each A∪B ⇒ A may be called an axiom. (Cut) and (Shf) are binary and unary deduction rules, respectively. In the classic case, (Ax) and (Cut) form a system which is equivalent to that from [3]. We call the additional rule (Shf) the rule of “time shifts.” Also note that in the database literature, (Cut) is also referred to as the rule of pseudo-transitivity [42].\n(b) The rules in Definition 17 can be written as fractions with hypotheses (formulas preceding “infer”) above the conclusion (formula following “infer”) as\nA∪B ⇒ A (Ax),\nA⇒ B, B∪C ⇒ D\nA∪C ⇒ D (Cut),\nA⇒ B\nA+ i⇒ B + i (Shf).\nAlthough we are going to use (Ax), (Cut), and (Shf) as the basic deduction rules in our system, we define the notion of provability relatively to a collection of deduction rules because we later investigate systems consisting of other rules. Thus, a general deduction system is a set R of n-ary rules of the form “from ϕ1, . . . , ϕn, infer ψ”.\nDefinition 18. Let R be a deduction system. An R-proof of A⇒ B by Σ is a finite sequence δ1, . . . , δn such that δn equals A ⇒ B and for each i = 1, . . . , n we have\n(i) δi ∈ Σ, or\n(ii) R contains a rule “from ϕ1, . . . , ϕn infer ψ” such that ψ is equal to δi and\nwe have {ϕ1, . . . , ϕn} ⊆ {δj | j < i}.\nWe say that A ⇒ B is R-provable by Σ, denoted Σ ⊢R A ⇒ B, if there is an R-proof of A⇒ B by Σ.\nIf R consists solely of (Ax), (Cut), and (Shf), we write just Σ ⊢ A⇒ B and call A ⇒ B provable by Σ. Analogously, we use the term “proof” instead of “R-proof”. In the paper, we use the following properties of provability.\nProposition 19. For every finite A,B,C,D ⊆ TY , we have\n(Ref) ⊢ A⇒ A,\n(Wea) {A⇒ C} ⊢ A∪B ⇒ C,\n(Acc) {A⇒ B∪C,C ⇒ D∪E} ⊢ A⇒ B∪C∪D,\n(Add) {A⇒ B,A⇒ C} ⊢ A⇒ B∪C,\n(Aug) {B ⇒ C} ⊢ A∪B ⇒ A∪C,\n(Pro) {A⇒ B∪C} ⊢ A⇒ B,\n(Tra) {A⇒ B,B ⇒ C} ⊢ A⇒ C.\nProof. The laws hold because our system is an extension of the Armstrong system in which the laws hold as well, see [3, 42].\nOur inference system is sound in the usual sense:\nTheorem 20 (soundness). If Σ ⊢ A⇒ B then Σ |= A⇒ B.\nProof. The proof goes by induction on the length of a proof, considering the facts that each axiom is true in all models, (Cut) is a sound deduction rule [42], and (Shf) is sound on account of Lemma 14. In a more detail, let δ1, . . . , δn be a proof by Σ and let Σ |= δi for all i < j. Then, if δj results by δi using (Shf) for some i < j, then Σ |= δi yields that M |= δi for all M ∈ Mod(Σ) and thus, using Lemma 14, M |= δj for all M ∈ Mod(Σ), showing Σ |= δj . The rest follows as in the classic case.\nIn the proof of completeness, we utilize the notion of a syntactic closure\nwhich is introduced as follows.\nDefinition 21. Let Σ be a theory. For each M ⊆ TY , we put\nM0Σ =M, (21)\nMn+1Σ =M n Σ ∪ ⋃{ F + i |E ⇒ F ∈ Σ and E + i ⊆MnΣ } , (22)\nMωΣ = ⋃∞ n=0M n Σ. (23)\nand call MωΣ the syntactic closure of M under Σ.\nBy the Tarski fixpoint theorem [51], the operator which maps M to MωΣ defined by (23) is indeed a closure operator, so the term “closure” in the name syntactic closure is appropriate. The following observation shows that the term “syntactic” is also appropriate since closures are directly related to provability.\nLemma 22. Let A,B ⊆ TY be finite. Then, B ⊆ AωΣ iff Σ ⊢ A⇒ B.\nProof. Suppose that B ⊆ AωΣ. Since B is finite, there is m such that B ⊆ A m Σ . Thus, in order to show that Σ ⊢ A⇒ B, it suffices to check that for every n and every finite D ⊆ AnΣ, we have Σ ⊢ A ⇒ D since then the claim readily follows for D = B and n = m. By induction, assume the claim holds for n and all finite D ⊆ AnΣ. Consider n+ 1 and take a finite D ⊆ A n+1 Σ . Now, consider a finite\nD′ = {〈E ⇒ F, i〉 |E ⇒ F ∈ Σ and E + i ⊆ AnΣ}\nsuch that\nD ⊆ AnΣ ∪ ⋃ {F + i | 〈E ⇒ F, i〉 ∈ D′} ⊆ An+1Σ .\nNotice that since we assume D finite, such finite D′ always exists. Now, by induction hypothesis, for each 〈E ⇒ F, i〉 ∈ D′, we have Σ ⊢ A ⇒ E + i owing to E + i ⊆ AnΣ ⊆ A ω Σ. Furthermore, for E ⇒ F ∈ Σ, we have Σ ⊢ E + i⇒ F + i using (Shf). Thus, (Tra) gives Σ ⊢ A ⇒ F + i for each 〈E ⇒ F, i〉 ∈ D′. In addition to that, D ∩ AnΣ ⊆ A n Σ and thus Σ ⊢ A ⇒ D ∩ A n Σ. Since D ′ is finite and D ⊆ (D ∩AnΣ)∪ ⋃ {F + i | 〈E ⇒ F, i〉 ∈ D′}, Σ ⊢ A⇒ D follows by finitely many applications of (Add) and (Pro). As a consequence, Σ ⊢ A⇒ B.\nConversely, assume that Σ ⊢ A ⇒ B. By Theorem 20, Σ |= A ⇒ B. We show that AωΣ ∈ Mod(Σ). Take E ⇒ F ∈ Σ, i ∈ Z and let E + i ⊆ A ω Σ. Since\nE+i is finite, there must be n such that E+i ⊆ AnΣ and thus F+i ⊆ A n+1 Σ ⊆ A ω Σ, proving that AωΣ ∈ Mod(Σ). Now, Σ |= A⇒ B and A+0 = A ⊆ A ω Σ yields that B + 0 = B ⊆ AωΣ.\nNote that Lemma 22 is in fact a syntactic counterpart of Theorem 15. Now,\nusing previous observations, we derive that our logic is complete:\nTheorem 23 (completeness). Σ ⊢ A⇒ B iff Σ |= A⇒ B.\nProof. If Σ 0 A⇒ B, we prove that there is M ∈ Mod(Σ) such that M 6|= A⇒ B. Indeed, we show that one can take AωΣ for M . By Lemma 22, Σ 0 A ⇒ B yields B * AωΣ. So, for i = 0, we have that A+i = A ⊆ A ω Σ and B+i = B * A ω Σ, i.e., AωΣ 6|= A⇒ B. In addition to that, if E+ i ⊆ A ω Σ for E ⇒ F ∈ Σ and i ∈ Z, then Σ ⊢ A⇒ E+ i by Lemma 22 and so Σ ⊢ A⇒ F + i using (Shf) and (Tra). Using Lemma 22 again, F + i ⊆ AωΣ which proves A ω Σ ∈ Mod(Σ). The rest is a consequence of Theorem 20.\nAs a corollary of the previous observations, we get the following assertion\nshowing that both the syntactic and semantic closures coincide.\nTheorem 24. For every M ⊆ TY , we have [M ]Σ =MωΣ .\nProof. We get [M ]Σ ⊆ M ω Σ since [M ]Σ is the least model of Σ containing M . Conversely, observe that for any N ∈ Mod(Σ) such that M ⊆ N , it follows that MωΣ ⊆ N ω Σ = N . Hence, for N being [M ]Σ, we get M ω Σ ⊆ [M ]Σ.\nRemark 3. Let us stress that the notions of semantic and syntactic entailment we have considered in our paper are different from their classic counterparts. Indeed, each attribute implication annotated by time points can also be seen as a classic attribute implication per se because the sets A and B in A ⇒ B are subsets of TY . Therefore, in addition to the semantic entailment from Definition 13, we may consider the ordinary one which disregards the special role of time points. The same applies to the provability—the classic notion is obtained by omitting the rule (Shf). For instance, Σ = {{x1} ⇒ {y2}, {y5} ⇒\n{z2}} proves {x4} ⇒ {y5} by (Shf) and thus {x4} ⇒ {z2} by (Tra). On the other hand, Σ does not prove {x4} ⇒ {z2} without (Shf).\nRemark 4. (a) We can show that our system of deduction rules consisting of (Ax), (Cut), and (Shf) is non-redundant, i.e., all the rules in the system are independent. Indeed, no formulas are provable by Σ = ∅ using only (Cut) and (Shf) and thus (Ax) is independent. Moreover, (Cut) is independent since all formulas provable by Σ = ∅ using only (Ax) and (Shf) are exactly all instances of (Ax). The independence of (Shf) follows by Remark 3.\n(b) Let us note that the deductive system in Definition 17 is not minimal in terms of the number of deduction rules. Indeed, we may replace (Cut) and (Shf) by a single deduction rule\nA⇒ B + i, B∪C ⇒ D\nA ∪ (C + i) ⇒ D + i (Cuti). (24)\nIndeed, observe that (Cut) is a particular case of (Cuti) for i = 0 and (Shf) results by (Cuti) and (Ax) for A = B = ∅. Conversely, {A ⇒ B + i, B∪C ⇒ D} ⊢ A∪(C + i) ⇒ D + i because using (11), the sequence\nA⇒ B + i, B∪C ⇒ D, (B + i)∪(C + i) ⇒ D + i, A∪(C + i) ⇒ D + i\nis a proof of A∪(C + i) ⇒ D + i using (Cut) and (Shf). As a consequence, the system consisting of (Ax), (Cut), and (Shf) is equivalent to (Ax) and (Cuti).\n(c) An alternative deduction system for our logic can be based on (Ref) instead of (Ax) and a single rule which is a modification of a simplification deduction rule [15]. First, it is easily seen that (Ax) and (Cut) may be equivalently replaced by the following rule and (Ref):\nA⇒ B, C ⇒ D\nA ∪ (C \\B) ⇒ D (Sim). (25)\nIndeed, (Sim) is a rule derivable by (Ax) and (Cut) because the sequence\nA⇒ B,B∪C ⇒ C,C ⇒ D,B∪C ⇒ D,A∪(C\\B) ⇒ D,\nis a proof of A∪(C\\B) ⇒ D by {A⇒ B,C ⇒ D} using (Ax) and (Cut); apply the rule twice and observe that B ∪ C = B ∪ (C \\B). Conversely, observe first that (Ax) is derivable by (Ref) and (Sim) because from B ⇒ B and A ⇒ A it follows that B∪(A\\B) ⇒ A that is, A∪B ⇒ A. Moreover, (Cut) is derivable by (Ref) and (Sim) because the following sequence\nC ⇒ C, ∅ ⇒ ∅, C ⇒ ∅, A⇒ B,B∪C ⇒ D,A∪((B∪C)\\B) ⇒ D,A∪C ⇒ D,\nis a proof of A∪C ⇒ D by {A ⇒ B,B∪C ⇒ D} in which we have used (Sim) three times and utilized the fact that C ∪ ((A ∪ ((B ∪ C) \\ B)) \\ ∅) = A∪C. Altogether, (Ax) and (Cut) can indeed be replaced by (Ref) and (Sim). Note that (Sim) may be perceived even more natural than (Cut) because it is applicable to any two input formulas. Note that a rule analogous to (Sim) with the inferred formula being A ∪ (C \\ B) ⇒ B ∪ D was first proposed by Darwen [16, page 140]. Now, we may consider an extension of (Sim) which involves time shifts:\nA⇒ B + i, C ⇒ D\nA ∪ ((C \\B) + i) ⇒ D + i (Simi). (26)\nAnalogously as in the case of (Cuti), (Sim) is a particular case of (Simi) for i = 0 and (Shf) results by (Simi) and (Ref) for A = B = ∅. Therefore, the deductive system in Definition 17 can be replaced by (Ref) and (Simi).\nWe now focus on the order in which the deduction rules may be applied in proofs. We show that each proof may be transformed into a normalized proof which involves applications of deduction rules in a special order. First, we show that (Shf) commutes with the other rules. Formally, we introduce the property for a general deduction rule R as follows:\nLet R be a deduction rule of the form “from ϕ1, . . . , ϕn infer ψ”. We say that (Shf) commutes with R if for any formula χ which results by ψ using (Shf) there are ϕ′1, . . . , ϕ ′ n which result by ϕ1, . . . , ϕn using (Shf), respectively, such that χ is provable by {ϕ′1, . . . , ϕ ′ n} using R.\nLemma 25. (Shf) commutes with (Ax), (Cut), and (Shf).\nProof. Clearly, (Shf) commutes with (Ax) because the result of application of (Shf) to an instance of (Ax) is again an instance of (Ax). Moreover, (Shf) commutes with itself since (A + i) + j equals A + (i + j) for any A ⊆ TY and i, j ∈ Z. Therefore, it remains to check that (Shf) commutes with (Cut). Consider formulas A ⇒ B and B∪C ⇒ D and the formula A∪C ⇒ D which results by (Cut) and formula (A∪C)+i⇒ D+i which results by (Shf). Clearly, if we apply (Shf) to A⇒ B and B∪C ⇒ D for i, we obtain A+ i⇒ B + i and (B∪C)+ i⇒ D+ i, respectively. The second formula equals (B+ i)∪(C + i) ⇒ D + i and thus we may apply (Cut) to obtain (A+ i) ∪ (C + i) ⇒ D + i which equals (A∪C) + i⇒ D + i, proving that (Shf) commutes with (Cut).\nTheorem 26. Σ ⊢ A⇒ B iff there is a finite Σ′ ⊆ ΣPL such that Σ′ ⊢R A⇒ B for R containing (Ax) and (Cut).\nProof. In order to see the only-if part, assume that Σ ⊢ A ⇒ B which means there is a proof of A⇒ B by Σ. The proofs contains only finitely many formulas in Σ and thus, we may consider a finite Σ′′ ⊆ Σ such that Σ′′ ⊢ A ⇒ B. Moreover, the proof contains only finitely many applications of (Shf) and, using Lemma 25, there is a proof of A ⇒ B by Σ′′ which starts by formulas in Σ′′, then continues with applications of (Shf), and terminates with formulas derived without using (Shf). Therefore, there is a finite Σ′ ⊆ (Σ′′)PL ⊆ ΣPL such that A⇒ B is provable by Σ′ using only (Ax) and (Cut). The if-part of the assertion is easy to see.\nThe previous observation allows us to introduce special derivation sequences which represent proofs in a normalized form in that all utilized deduction rules are applied in a particular order. The proofs are constructed using deduction rules (Ref), (Shf), (Acc), and (Pro), see Proposition 19.\nDefinition 27. A finite sequence of formulas ϕ1, . . . , ϕn is called a normalized derivation sequence of A⇒ B using formulas in Σ if the sequence\n(i) starts with finitely many formulas in Σ;\n(ii) continues by formulas obtained using (Shf) applied to formulas in (i);\n(iii) continues by A⇒ A;\n(iv) continues by formulas obtained using (Acc) whose first argument is the\npreceding formula and the second argument is a formula in (i) or (ii);\n(v) terminates with A⇒ B which results by the preceding formula by (Pro).\nNormalized derivation sequences are sufficient and adequate means for de-\ntermining provability of formulas:\nTheorem 28. Σ ⊢ A ⇒ B iff there is a normalized derivation sequence of A⇒ B using formulas in Σ.\nProof. The if-part follows directly by the fact that a normalized derivation sequence of A ⇒ B using formulas in Σ is a proof of A ⇒ B by Σ using (Ref), (Shf), (Acc), and (Pro). Since all of them are rules derivable by (Ax), (Cut), and (Shf), see Proposition 19, we get Σ ⊢ A⇒ B.\nConversely, by Theorem 26 we get that A ⇒ B is provable by a finite Σ′ ⊆ ΣPL using only (Ref) and (Cut). Therefore, we may form the (i) and (ii)parts of the derivation sequence using the formulas in Σ′ followed by A ⇒ A. Next, observe that there is a finite sequence A0, . . . , An of subsets of TY such that A0 = A, Ai = Ai−1 ∪ F for some E ⇒ F ∈ Σ′ satisfying E ⊆ Ai−1, and An ⊇ B. In order to see that, consider (22) and the fact that A⇒ B is provable by Σ′ without using (Shf). By moment’s reflection, we can see that the (iv)-part of the derivation sequence is formed of formulas A⇒ Ai (i = 0, . . . , n), and the sequence is terminated by a single application of (Pro) to obtain A⇒ B.\nWe conclude the section by showing further properties of provability. The\nnext assertion may be viewed as a type of a deduction theorem.\nTheorem 29. Let Σ be a theory and A,B ⊆ TY be finite. Then the following statements are equivalent:\n(i) Σ ∪ {∅ ⇒ A} ⊢ ∅ ⇒ B,\n(ii) there are i1, . . . , in ∈ Z such that Σ ⊢ ⋃n m=1(A+ im) ⇒ B.\nProof. “(i)⇒ (ii)”: Let A1 ⇒ B1, . . . , An ⇒ Bn be a proof of ∅ ⇒ B by Σ ∪ {∅ ⇒ A}. For each p = 1, . . . , n, we show that there are i1, . . . , ipn ∈ Z for which Σ ⊢ Ap ∪ ⋃pn m=1(A+ im) ⇒ Bp. The proof goes by induction on p. Thus, take p = 1, . . . , n and assume the claim holds for all q < p. We distinguish the following cases:\n– Ap ⇒ Bp is an instance of (Ax). Then, we let pn = 1, i1 = 0, and thus\nAp ∪ ⋃pn m=1(A+ im) equals Ap ∪A, i.e., Ap ∪A⇒ Bp follows using (Ax).\n– Ap ⇒ Bp ∈ Σ. As in the previous case, for pn = 1 and i1 = 0 using (Wea)\nwe infer Ap ∪ A⇒ Bp, showing Σ ⊢ Ap ∪ A⇒ Bp.\n– Let Ap ⇒ Bp result by Aq ⇒ Bq and Ar ⇒ Br using (Cut). In this\ncase, there is C such that Ar = Bq ∪ C, Bp = Br, and Ap = Aq ∪ C. By induction hypothesis, there are i1, . . . , iqn ∈ Z and i ′ 1, . . . , i ′ qr ∈ Z such that Σ ⊢ Aq∪ ⋃qn m=1(A+im) ⇒ Bq and Σ ⊢ Bq∪C∪ ⋃qr m=1(A+i ′ m) ⇒ Br. Therefore, using (Cut), Σ ⊢ Aq∪ ⋃qn m=1(A+im)∪C∪ ⋃qr m=1(A+i ′ m) ⇒ Bp. Hence, for i′′1 = i1, . . . , i ′′ qn = iqn , i ′′ qn+1 = i′1, . . . , i ′′ qn+qr = i ′ qr it follows that Σ ⊢ Aq ∪C ∪ ⋃qn+qr m=1 (A+ i ′′ m) ⇒ Bp, i.e., Σ ⊢ Ap ∪ ⋃qn+qr m=1 (A+ i ′′ m) ⇒ Bp.\n– Let Ap ⇒ Bp result by Aq ⇒ Bq using (Shf). Then, Ap = Aq + i and\nBp = Bq+ i for some i ∈ Z. By induction hypotheses, there are i1, . . . , iqn such that Σ ⊢ Aq ∪ ⋃qn m=1(A + im) ⇒ Bq. Using (Shf), we get Σ ⊢ ( Aq ∪ ⋃qn m=1(A+ im) ) + i⇒ Bq+ i. Now, observe that ( Aq ∪ ⋃qn m=1(A+ im) ) + i equals (Aq+ i)∪ ⋃qn m=1(A+ im+ i). Therefore, the claim holds for integers i1 + i, . . . , iqn + i.\nAs a special case for p = n, we get (ii) because An = ∅.\n“(ii)⇒ (i)”: Let Σ ⊢ ⋃n\nm=1(A + im) ⇒ B for some i1, . . . , in ∈ Z. From\nthe monotony of provability, we get that Σ ∪ {∅ ⇒ A} ⊢ ⋃n\nm=1(A + im) ⇒ B.\nMoreover, for each m = 1, . . . , n we get Σ∪ {∅ ⇒ A} ⊢ ∅ ⇒ A+ im using (Shf). Hence, Σ∪{∅ ⇒ A} ⊢ ∅ ⇒ ⋃n\nm=1A+ im by finitely many applications of (Add)\nand (Tra) gives Σ ∪ {∅ ⇒ A} ⊢ ∅ ⇒ B.\nExample 2. Let us observe that a direct counterpart of the classic deduction\ntheorem does not hold in our system. For instance, we may take a theory Σ = {∅ ⇒ {x1}}. Then, using (Shf) for i = 1, we easily see that Σ ⊢ ∅ ⇒ {x2}. On the other hand, we have 0 {x1} ⇒ {x2} and thus in general Σ∪ {∅ ⇒ A} ⊢ ∅ ⇒ B does not imply that Σ ⊢ A⇒ B which holds in the classic case.\nExample 3. One of the classic laws about provability that apply to attribute implications and can be formulated in terms of attribute implications as formulas with limited expressive power compared to general propositional formulas is the principle of the proof by cases. Formally, if R consists only of (Ax) and (Cut), then the following are equivalent:\n• Σ ⊢R A⇒ B;\n• Σ ∪ {C ⇒ D} ⊢R A⇒ B and Σ ∪ {D ⇒ C} ⊢R A⇒ B.\nThis follows immediately by the fact that in this case, ⊢R becomes the classic propositional provability. The law does not apply in our system where R contains the additional rule (Shf). For instance, consider the following theory\nΣ = {{x0} ⇒ {c1}, {x0} ⇒ {d2}, {c2} ⇒ {y0}, {d1} ⇒ {y0}}.\nObviously, we have Σ ∪ {{c0} ⇒ {d0}} ⊢ {x0} ⇒ {y0} using (Shf) and two applications of (Cut). Analogously, we get Σ ∪ {{d0} ⇒ {c0}} ⊢ {x0} ⇒ {y0}. On the other hand, we can show that Σ 0 {x0} ⇒ {y0}, i.e., the principle of the proof by cases does not hold. In order to see that Σ 0 {x0} ⇒ {y0}, observe that [{x0}]Σ = {y−1, x0, c1, y1, d2} for which [{x0}]Σ 6|= {x0} ⇒ {y0}. Thus, since our logic is sound and [{x0}]Σ ∈ Mod(Σ), we indeed have Σ 0 {x0} ⇒ {y0}.\nRemark 5. We may say that Σ′ is a completion of Σ if Σ ⊆ Σ′ and for any finite C,D ⊆ TY , we have either Σ′ ⊢ C ⇒ D or Σ′ ⊢ D ⇒ C. Let us note that analogous notions of completions play an important role in completeness proofs of various logics, cf. [29]. Namely, if a given theory does not prove a formula it is often desirable to find its completion which does not prove the formula as well. As a consequence of Example 3, we observe that this is not possible in our logic. Namely, the example shows a particular case where Σ 0 {x0} ⇒ {y0} and there\nis no completion Σ′ such that Σ′ 0 {x0} ⇒ {y0}. Indeed, each completion Σ′ proves either {c0} ⇒ {d0} or {d0} ⇒ {c0} and thus it also proves {x0} ⇒ {y0}. Nevertheless, we were able to prove Theorem 23 without having this property."
    }, {
      "heading" : "6 Computational Issues",
      "text" : "In this section, we show bounds on the computational complexity of deciding whether an attribute implication over attributes annotated by time points is provable by a finite set Σ of other attribute implications. Then, we focus on a subproblem which typically appears in applications. For the subproblem we provide a pseudo-polynomial time [27] decision algorithm.\nWe formalize the decision problem of entailment as a language of encodings\nof finitely many formulas, i.e., we put\nLENT = {〈Σ, A⇒ B〉 |Σ is a finite theory and Σ ⊢ A⇒ B}, (27)\nconsidering a fixed TY . In order to show the lower bound of the time complexity of LENT, we utilize a reduction of decision problems [45] which involves the unbounded subset sum problem. The decision variant of the unbounded subset sum problem is formulated as follows: An instance of the problem is given by n non-negative integers j1, . . . , jn and a target value z; the answer to the instance is “yes” iff there are non-negative integers c1, . . . , cn such that\n∑n i=1 ciji = z. (28)\nThe unbounded subset sum decision problem is NP-complete, see [32, Proposition A.4.1].\nLet us note that in the case of the ordinary attribute implications and functional dependencies, the problem of determining whether a given formula follows by a finite set of formulas is easy and there exist efficient linear time decision algorithms [6]. In contrast, the corresponding decision problem in our setting is hard:\nTheorem 30 (lower bound). LENT is NP-hard.\nProof. We prove the claim by showing that the unbounded subset sum problem (see Section 3) is polynomial time reducible to LENT. Consider an instance of the unbounded subset sum problem given by non-negative integers j1, . . . , jn and z. For the integers we consider\nΣ = { {y0} ⇒ {yji} | i = 1, . . . , n } (29)\nand put A = {y0}, B = {yz}. We now prove that ∑n\ni=1 ciji = z holds true\nfor some non-negative integers c1, . . . , cn iff Σ ⊢ {y0} ⇒ {yz} by proving both implications.\nIn order to prove the if-part, assume that Σ ⊢ {y0} ⇒ {yz}. Using Theorem 28, it follows there is a normalized derivation sequence ϕ1, . . . , ϕk of {y0} ⇒ {yz} using formulas in Σ. In the proof, we utilize a part of the sequence which results by applications of (Acc), see Definition 27 (iv). All formulas in this part of the sequence can be written as\n{y0} ⇒ Ai ︸ ︷︷ ︸\nϕi\n, {y0} ⇒ Ai+1 ︸ ︷︷ ︸\nϕi+1\n, . . . , {y0} ⇒ Ak−1 ︸ ︷︷ ︸\nϕk−1\n,\nwhere Ai, . . . , Ak−1 are finite subsets of TY , Ai = {y0}, and yz ∈ Ak−1 because ϕk results from ϕk−1 by (Pro), cf. Definition 27. By induction, we show for every Al (i ≤ l ≤ k − 1) that the following property is satisfied:\nIf yw ∈ Al, then there are non-negative integers c1, . . . , cn such that w = ∑n\ni=1 ciji.\nNotice the property is satisfied for l = i since in that case we have Al = Ai = {y0} and thus, we may put c1 = c2 = · · · = cn = 0. Assuming the claim holds for l, we prove it for l + 1 as follows. Inspecting Definition 27 (iv), it follows that {y0} ⇒ Al+1 results from {y0} ⇒ Al and {y0} + t ⇒ {yjm} + t using (Acc) where t ∈ Z and 1 ≤ m ≤ n. As a consequence {y0} + t ⊆ Al and thus, by induction hypothesis, there are non-negative integers d1, . . . , dn such that t = 0+ t = ∑n\ni=1 diji. Then, jm+ t = jm+ ∑n i=1 diji and so jm+ t = ∑n i=1 ciji\nfor non-negative integers c1, . . . , cn defined by\nci =\n \n\ndi + 1, if i = m, di, otherwise.\nNow, since we have Al+1 ⊆ Al ∪ {yjm+t}, the property holds for Al+1. As a particular case, for {yz} ⊆ Ak−1 we conclude there are non-negative integers c1, . . . , cn for which ∑n i=1 ciji = z which concludes the first part of the proof of Theorem 30.\nConversely, let ∑n\ni=1 ciji = z for some non-negative integers c1, . . . , cn. By\ninduction, we show that Σ ⊢ {y0} ⇒ {yzk} for every zk = ∑k i=1 ciji where k = 0, . . . , n. As a particular case for k = n, we obtain the desired fact that Σ ⊢ {y0} ⇒ {yz} because zn = z.\nObserve that for k = 0, the claim follows trivially by (Ax). Now, suppose the claim holds for k < n. By induction hypothesis, Σ ⊢ {y0} ⇒ {yzk}. Moreover, we have Σ ⊢ {y0} ⇒ {yjk+1} because {y0} ⇒ {yjk+1} ∈ Σ. Using (Shf), we also get Σ ⊢ {y0} + jk+1 ⇒ {yjk+1} + jk+1, i.e., using (Cut), it follows that Σ ⊢ {y0} ⇒ {y2jk+1}. Repeating the last argument ck+1-times, we obtain Σ ⊢ {y0} ⇒ {yck+1jk+1}. Now, using (Shf), we get Σ ⊢ {y0}+zk ⇒ {yck+1jk+1}+zk, i.e., Σ ⊢ {yzk} ⇒ {yck+1jk+1+zk}. Hence, Σ ⊢ {y0} ⇒ {yzk+1} follows by (Cut) using the fact that zk+1 = zk + ck+1jk+1, which finishes the proof.\nThe reduction involved in Theorem 30 is illustrated in the following example.\nExample 4. Let us show a particular instance of the unbounded subset sum problem and its reduction to LENT. We consider integers 5, 7, 11, and a target number 31 as an instance of the problem. The answer to this instance is “yes” because for numbers 4, 0, and 1, the sum 4 · 5+ 0 · 7+ 1 · 11 is equal to 31. The corresponding theory Σ, see the proof of Theorem 30, is\nΣ = {{y0} ⇒ {y5}, {y0} ⇒ {y7}, {y0} ⇒ {y11}}.\nIn this case, {y0} ⇒ {y31} is provable from Σ because we may chain four shifted instances of {y0} ⇒ {y5} and a single shifted instance of {y0} ⇒ {y11} by using\n(Cut). It corresponds with the sum 4 · 5 + 0 · 7 + 1 · 11. In a more detail, the corresponding proof of {y0} ⇒ {y31} by Σ is the following sequence of formulas:\n1. {y0} ⇒ {y5} formula in Σ\n2. {y0}+ 5 ⇒ {y5}+ 5 using (Shf) on 1.\n3. {y0} ⇒ {y10} using (Cut) on 1. and 2.\n4. {y0}+ 10 ⇒ {y5}+ 10 using (Shf) on 1.\n5. {y0} ⇒ {y15} using (Cut) on 3. and 4.\n6. {y0}+ 15 ⇒ {y5}+ 15 using (Shf) on 1.\n7. {y0} ⇒ {y20} using (Cut) on 5. and 6.\n8. {y0} ⇒ {y11} formula in Σ\n9. {y0}+ 20 ⇒ {y11}+ 20 using (Shf) on 8.\n10. {y0} ⇒ {y31} using (Cut) on 7. and 9.\nRemark 6. The entailment problem is closely related to the existence of nonnegative solutions of linear Diophantine equations. Indeed, for a theory Σ which consists of formulas of the form {y0} ⇒ {yji} for i = 1, . . . , n, by inspecting the proof of Theorem 30, we can see that Σ ⊢ {y0} ⇒ {yz} iff the linear Diophantine equation j1x1 + · · ·+ jnxn = z has a non-negative solution.\nOur observations on the upper bound of computational complexity involve additional classes of decision problems. In order to establish an upper bound, we utilize the fact that the satisfiability problem of temporal logic with “until” and “since” operators over a linear flow of time is decidable in polynomial space [47]. For the purpose of our proof, we use the linear temporal logic over 〈Z, <〉 with the unary temporal operators (always), ◦F (next time), and ◦P (previous time) because these operators are definable using operators “until” and “since”, see [4] for details.\nFrom now on, we consider Y (the set of attributes) as (a subset of) the set of propositional variables. Recall that formulas of the temporal logic with the above-mentioned operators are defined as follows: Each y ∈ Y is a formula; if ϕ\nand ψ are formulas, then ¬ϕ, ϕNψ, ϕ⇒ ψ, ϕ, ◦F ϕ, and ◦P ϕ are formulas. In order to interpret the formulas we consider a standard structureK = 〈W, e, r〉 where W = Z, r is the genuine ordering < on Z, and e is an evaluation such that e(w, y) ∈ {0, 1} for all w ∈ Z and y ∈ Y . Given K and w ∈ Z, we interpret the formulas as usual: We put\n(i) K, w |= y whenever e(w, y) = 1;\n(ii) K, w |= ¬ϕ whenever K, w 6|= ϕ;\n(iii) K, w |= ϕNψ whenever K, w |= ϕ and K, w |= ψ;\n(iv) K, w |= ϕ⇒ ψ whenever K, w 6|= ϕ or K, w |= ψ;\n(v) K, w |= ϕ whenever K, w′ |= ϕ for all w′ ∈ Z;\n(vi) K, w |= ◦F ϕ whenever K, w′ |= ϕ for w′ ∈ Z such that w < w′ and there\ndoes not exist z ∈ Z such that w < z < w′;\n(vii) K, w |= ◦P ϕ whenever K, w′ |= ϕ for w′ ∈ Z such that w′ < w and there\ndoes not exist z ∈ Z such that w′ < z < w.\nWe say that ϕ is true in K whenever K, w |= ϕ for all w ∈ Z. Moreover, we say that ϕ is satisfiable whenever there is a structure K such that K, 0 |= ϕ. Moreover for each formula of the form (1), we consider its counterpart in the considered temporal logic\n(( △i1y1 N · · ·N△ imym ) ⇒ ( △j1z1 N · · ·N△ jnzn )) , (30)\nwhere △i is defined as follows:\n△iy =\n \n\ny, if i = 0, ◦F△i−1y, if i > 0, ◦P△i+1y, if i < 0.\n(31)\nNote that the construction of △iy from yi requires space which is linear in (the absolute value of) i ∈ Z, i.e., it is exponential in the length of the encoding of i.\nTheorem 31. LENT is reducible in exponential space to the satisfiability problem of the linear temporal logic over 〈Z, <〉 with unary temporal operators “always”, “next time”, and “previous time”.\nProof. First, observe that for each subset of TY we may consider a corresponding structure which makes the same formulas true—any A⇒ B is true in the subset of TY iff its counterpart given by (30) is true in the corresponding structure. Namely, for M ⊆ TY , we may consider KM = 〈W, e, r〉, where e(w, y) = 1 if yw ∈M and e(w, y) = 0 otherwise. Conversely, for K = 〈W, e, r〉, we putMK = {yw | e(w, y) = 1}. Now, for any w ∈ W , it is easy to see that M |= A ⇒ B iff KM , w |= ϕ where ϕ is the counterpart to A⇒ B given by (30). From now on, we tacitly identify attribute implications with their counterparts. Furthermore, we have K, w |= A⇒ B iff MK |= A⇒ B.\nNow, for a given Σ = {A1 ⇒ B1, . . . , Am ⇒ Bm} and A ⇒ B we may\nconsider formula A1 ⇒ B1 N · · ·NAm ⇒ Bm N¬ ( A ⇒ B ) whose construction requires exponential space. From the previous observation, it is obvious that the formula is satisfiable iff Σ 6|= A⇒ B.\nCorollary 32 (upper bound). LENT belongs to EXPSPACE.\nProof. The decision procedure reduces the input of LENT to the satisfiability problem of linear temporal logic over 〈Z, <〉 with unary temporal operators “always”, “next time”, and “previous time” in exponential space, see Theorem 31. Then, the input is reduced to the satisfiability problem of the linear temporal logic over 〈Z, <〉 with binary temporal operators “until” and “since” in linear space [4] which we can decide in polynomial space [47]. Altogether, the decision procedure decides LENT in exponential space.\nRemark 7. Note that the results of Theorem 31 and Corollary 32 can also be interpreted so that LENT is decidable in a pseudo-polynomial space because we reduce an instance of LENT to an instance (of the satisfiability problem of the above-mentioned temporal logic) the length of which is bounded from above by the numeric value encoded in the original input. With respect to the new instance, the decision procedure works in polynomial space.\nWe now turn our attention to issues of entailment of formulas which typically appear in applications in prediction. The restriction on particular formulas\nallows us to improve the complexity of the entailment problem. Based on the time points present in antecedents and consequents of attribute implications, we may consider formulas which describe presence of attributes in future time points. That is, based on the presence of attributes in the past, the formulas indicate which attributes are present in future time points. Technically, such formulas can be seen as attribute implications where all the time points in the antecedents are smaller (i.e., denote earlier time points) than all the time points in the consequents which denote later time points. We call such formulas predictive and define the notion as follows.\nDefinition 33. An attribute implication A ⇒ B over Y annotated by time points in Z is called predictive whenever A 6= ∅, B 6= ∅, and for each xi ∈ A and yj ∈ B, we have i ≤ j. A theory Σ is called predictive whenever all its formulas are predictive.\nRemark 8. Note that the deduction rules (Shf) and (Cut) preserve the property of being predictive. That is, if A ⇒ B is provable by a predictive theory Σ without using (Ax), then A ⇒ B is predictive. General instances of (Ax) are not predictive formulas.\nIn the next assertion, we utilize lower and upper time bounds of finite non-\nempty subsets of TY : For a finite non-empty M ⊆ TY , put\nl(M) = min{i ∈ Z | yi ∈M}, (32)\nu(M) = max{i ∈ Z | yi ∈M}. (33)\nThus, l(M) and u(M) are the lowest and greatest time points which appear in M , respectively. Clearly, A ⇒ B is predictive iff both A and B are nonempty and u(A) ≤ l(B).\nTheorem 34. Let Σ and A⇒ B be predictive. Then, for\nΣBA = {E + i⇒ F + i |E ⇒ F ∈ Σ and l(A)− l(E) ≤ i ≤ u(B)− l(F )} (34)\nwe have Σ ⊢ A⇒ B iff ΣBA ⊢R A⇒ B for R containing (Ax) and (Cut).\nProof. Observe that the if-part of the claim is trivial. In order to prove the only-if part, assume that Σ ⊢ A⇒ B. That is, B ⊆ [A]Σ owing to Theorem 22 and Theorem 15. Note that ΣBA ⊢R A ⇒ B for R containing (Ax) and (Cut) means that A⇒ B is provable by ΣBA as an ordinary attribute implication. Let A◦ denote the least subset of TY with the following properties:\n(i) A ⊆ A◦, and\n(ii) for each E ⇒ F ∈ ΣBA : if E ⊆ A ◦ then F ⊆ A◦.\nSince A◦ is in fact the syntactic closure of A with respect to R, ΣBA ⊢R A⇒ B iff B ⊆ A◦. That is, in order to prove the desired claim, it suffices to show that A◦ ∩ T = [A]Σ ∩ T for\nT = {yi ∈ TY | l(A) ≤ i ≤ u(B)}.\nTrivially, we get that A◦∩T ⊆ [A]Σ∩T . In order to prove the converse inclusion, according to Theorem 24, it suffices to check that AnΣ ∩ T ⊆ A ◦ ∩ T for each non-negative integer n. By induction, assume that AnΣ ∩ T ⊆ A ◦ ∩ T and take yj ∈ (An+1Σ ∩ T ) \\ (A n Σ ∩ T ) = (A n+1 Σ \\ A n Σ) ∩ T . The fact y j ∈ An+1Σ \\ A n Σ yields there is E ⇒ F ∈ Σ and i ∈ Z such that E + i ⊆ AnΣ and y j ∈ F + i. It can be shown that E + i ⇒ F + i ∈ ΣBA . Indeed, since Σ is predictive, observe that l(E) + i = l(E + i) ≥ l(AnΣ) = l(A) and thus i ≥ l(A) − l(E). Moreover, yj ∈ F + i yields l(F + i) = l(F ) + i ≤ j and thus i ≤ j − l(F ) which gives i ≤ u(B) − l(F ) on account of j ≤ u(B) since yj ∈ T . As a consequence, E + i ⇒ F + i ∈ ΣBA . Furthermore, E + i ⊆ A n Σ and the fact that E ⇒ F is predictive give E+i = (E+i)∩T ⊆ AnΣ∩T . By induction hypothesis, E+i ⊆ A ◦ and thus F + i ⊆ A◦ by (ii). Hence, yj ∈ A◦ and so An+1Σ ∩ T ⊆ A ◦ ∩ T .\nLet LPRE be the language consisting of encodings of pairs of all finite pre-\ndictive theories and predictive formulas, i.e.,\nLPRE = {〈Σ, A⇒ B〉 |Σ is finite and Σ and A⇒ B are predictive}. (35)\nBased on Theorem 34, we establish the following observation on the time complexity of deciding whether a predictive formula is provable by a finite predictive\ntheory.\nTheorem 35. LENT ∩ LPRE is decidable in a pseudo-polynomial time.\nProof. Take a finite predictive Σ and a predictive formula A⇒ B. The theory ΣBA given by (34) is finite. According to Theorem 34, the problem of deciding Σ ⊢ A⇒ B is reducible to the problem of deciding whether ΣBA entails A⇒ B without using (Shf), i.e., in the sense of the entailment of ordinary attribute implications. Therefore, the problem is decidable in a time which is polynomial with respect to the size of ΣBA [6, 26, 42]. Now, observe that the size of (the encoding of) ΣBA may be bounded from above by the size of (the encoding of) Σ multiplied by\nn = max{max(0, u(B) + l(E)− l(A)− l(F ) + 1) |E ⇒ F ∈ Σ}, (36)\ni.e., the size of ΣBA is polynomial in the numeric value encoded in the input Σ and hence LENT ∩ LPRE is decidable in a pseudo-polynomial time.\nRemark 9. (a) By considering only LENT ∩LPRE, we have improved the upper bound since pseudo-polynomial time algorithms belong to EXPTIME [27] which is believed to be better than EXPSPACE. Observe that LENT ∩ LPRE is also NP-hard because we can use the same reduction as in Theorem 30.\n(b) Because of the complexity issues, in applications it is reasonable to consider attribute implications annotated by time points with small difference between lower and upper time bounds (maxspan [23]) since LENT ∩ LPRE is decidable in pseudo-linear time with respect to n given by (36).\nAn explicit procedure for deciding LENT ∩ LPRE in a pseudo-linear time is described in Algorithm 1. It is a generalization of LinClosure [6], cf. also [42], which incorporates applicable time shifts of formulas in Σ. The algorithm accepts three arguments:\n1. a finite predictive theory Σ,\n2. a finite A ⊆ TY , and\nAlgorithm 1: PseudoLinClosure (Σ, A,Max )\n1 forall the E ⇒ F ∈ Σ do 2 for i from l(A)− l(E) to Max − l(F ) do 3 set count [E ⇒ F, i] to |E|; 4 forall the yj ∈ E do 5 add 〈E ⇒ F, i〉 to list [yi+j ]; 6 end\n7 end\n8 end 9 set M to A;\n10 set update to A; 11 while update 6= ∅ do 12 choose yi from update; 13 set update to update \\{yi}; 14 forall the 〈E ⇒ F, j〉 ∈ list[yi] do 15 set count [E ⇒ F, j] to count [E ⇒ F, j]− 1; 16 if count[E ⇒ F, j] = 0 then 17 set new to F + j \\M ; 18 set M to M ∪ new ; 19 set update to update ∪new ;"
    }, {
      "heading" : "20 end",
      "text" : ""
    }, {
      "heading" : "21 end",
      "text" : ""
    }, {
      "heading" : "22 end",
      "text" : "23 return M\n3. a non-negative number Max ≥ u(A),\nand it returns a subset M ⊆ [A]Σ such that M ∩ T = [A]Σ ∩ T for\nT = {yi ∈ TY | l(A) ≤ i ≤ Max}. (37)\nThe soundness of the algorithm is justified by the following observation:\nTheorem 36. Let Σ and A ⇒ B be predictive and let Σ be finite. Then, Algorithm 1 executed with arguments Σ, A, and u(B), terminates after finitely many steps and for the returned value M we have Σ ⊢ A⇒ B iff B ⊆M .\nProof. The arguments are fully analogous to those in case of the classic LinClosure, so we present here comments on issues arising only in the context of attributes annotated by time points. Technical details can be found in [6]. Notice that Algorithm 1 uses auxiliary structure count and list to store information about formulas. The structure count can be seen as an associative array indexed by (pointers to) formulas in Σ and integers i representing time shifts. The value of count [E ⇒ F, i] is initially set to the number of attributes in the antecedent of E ⇒ F (shifted by i). During the computation, count [E ⇒ F, i] represents the number of remaining attributes in E + i which have not been “updated.” The structure list is an array indexed by attributes annotated by time points and the value of list [yi] is a list of records 〈E ⇒ F, j〉 representing (pointers to) formulas in Σ and their j-shifts such that yi appears in the antecedent of E ⇒ F shifted by j. An additional variable update is initialized at line 10 and maintains attributes annotated by time points which are waiting to be “updated.” An update of yi, see lines 13–21, consists in decrementing the counter of occurrences of attributes in shifted antecedents in all formulas where yi appears. All such formulas (and their j-shifts) are found in list [yi], see line 14. If count [E ⇒ F, j] reaches zero, see line 16, the antecedent of E + j ⇒ F + j is already contained inM , and all new attributes in F +j are prepared for update. Clearly, the procedure terminates after finitely many steps, and by Theorem 34, the attributes annotated by time points accumulated in M represent a subset\nof [A]Σ. In addition, if u(B) ≤ Max , then B ⊆ M iff B ⊆ [A]Σ iff Σ ⊢ A ⇒ B as a consequence of our previous observations.\nRemark 10. The procedure in Algorithm 1 is called PseudoLinClosure because for given parameters, Σ, A, and Max , it computes a subset of the closure of [A]Σ in a linear time with respect to the numeric value of the encoding of its input arguments, i.e., its time complexity is pseudo-linear. Indeed, this is a consequence of the fact that each yi where l(A) ≤ i ≤ Max is updated during the computation at most once.\nExample 5. Consider a set M given by the table in Figure 4. Since M can be regarded as transactional data over a set of items Y with a dimensional attribute d the domain of which is Z, we can utilize the algorithm proposed in [40]. The parameters for the algorithm are numbers maxspan, minsupport, and minconfidence for which we obtain a set Σ of all predictive A ⇒ B where u(A ∪ B) − l(A ∪ B) ≤ maxspan, minconfidence ≤ confidence(A ⇒ B), and minsupport ≤ support(A ⇒ B). For this particular example we consider maxspan = 5, minconfidence = 1 since we are interested in formulas true in M , and support = 5. In this setting, we obtain\nΣ = {{wm0} ⇒ {tc4}, {wl0} ⇒ {tc3},\n{wl0} ⇒ {wm1}, {wl0} ⇒ {wm1, tc3}, {wl0, wm1} ⇒ {tc3}, {rn0, wl2} ⇒ {tc3}, {rn0, rn3} ⇒ {tc3}, {tc0, rn5} ⇒ {tc5}, {tc0, tc3, rn5} ⇒ {tc5}, {rn0, tc0, rn3} ⇒ {tc3}, {rn0, tc0, wm2} ⇒ {tc3}}.\nNow, we may successively reduce the set Σ by removing formulas A ⇒ B such that Σ \\ {A ⇒ B} ⊢ A ⇒ B, i.e., without loss of information. Since Σ is\npredictive we may use PseudoLinClosure and obtain the following set:\nΣ′ = {{wm0} ⇒ {tc4}, {wl0} ⇒ {wm1, tc3},\n{rn0, rn3} ⇒ {tc3}, {rn0, wm2} ⇒ {tc3}, {tc0, rn5} ⇒ {tc5}},\ni.e., the equivalent non-redundant set contains less than half of the formulas in Σ. For maxspan = 5 and support = 2, the reduction is much more significant. From the total number of 34, 440 generated formulas, PseudoLinClosure can be used to produce an equivalent set consisting of only 81 formulas."
    }, {
      "heading" : "7 Conclusion",
      "text" : "We have presented logic for reasoning with if-then rules expressing dependencies between attributes changing in time. The logic extends the classic logic for dealing with if-then rules by considering discrete time points as an additional component. We have studied both the semantic entailment based on preserving validity in models in all time points and syntactic entailment represented by a provability relation. We have shown a characterization of the semantic entailment based on least models and syntactico-semantical completeness of the logic. We have shown the problem of entailment is NP-hard, decidable in exponential space, and its simplified variant which involves only predictive formulas is decidable in pseudo-linear time. Future research directions we consider interesting include utilization of generalized quantifiers [37, 43] to capture notions like “validity in all time points with possible exceptions”, connections to rules which may emerge in temporal databases [17], and further analysis of algorithms related to the entailment."
    }, {
      "heading" : "Acknowledgment",
      "text" : "Supported by grant no. P202/14-11585S of the Czech Science Foundation. J. Triska was also supported by internal student grant IGA PrF 2015 023 of Palacky University Olomouc."
    } ],
    "references" : [ {
      "title" : "Mining association rules between sets of items in large databases",
      "author" : [ "Rakesh Agrawal", "Tomasz Imieliński", "Arun Swami" ],
      "venue" : "Proceedings of the 1993 ACM SIGMOD International Conference on Management of Data (New York, NY, USA),",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1993
    }, {
      "title" : "An approach to discovering temporal association rules",
      "author" : [ "Juan M. Ale", "Gustavo H. Rossi" ],
      "venue" : "Proceedings of the 2000 ACM Symposium on Applied Computing (New York, NY, USA), SAC ’00,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2000
    }, {
      "title" : "Dependency structures of data base relationships, Information Processing",
      "author" : [ "William Ward Armstrong" ],
      "venue" : "Proceedings of IFIP Congress (Amsterdam)",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1974
    }, {
      "title" : "The complexity of clausal fragments of LTL",
      "author" : [ "Alessandro Artale", "Roman Kontchakov", "Vladislav Ryzhikov", "Michael Zakharyaschev" ],
      "venue" : "CoRR abs/1306.5088",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2013
    }, {
      "title" : "Characterizing functional dependencies in formal concept analysis with pattern structures",
      "author" : [ "Jaume Baixeries", "Mehdi Kaytoue", "Amedeo Napoli" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2014
    }, {
      "title" : "Computational problems related to the design of normal form relational schemas",
      "author" : [ "Catriel Beeri", "Philip A. Bernstein" ],
      "venue" : "ACM Trans. Database Syst",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1979
    }, {
      "title" : "Time granularities in databases, data mining, and temporal",
      "author" : [ "Claudio Bettini", "Sushil Jajodia", "Xiaoyang Sean Wang" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2000
    }, {
      "title" : "Imieliński, Temporal deductive databases and infinite objects",
      "author" : [ "Jan Chomicki", "Tomasz" ],
      "venue" : "Proceedings of the 7th ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems (New York, NY, USA), PODS ’88,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1988
    }, {
      "title" : "A relational model of data for large shared data",
      "author" : [ "Edgar F. Codd" ],
      "venue" : "banks, Commun. ACM",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1970
    }, {
      "title" : "Interval-based temporal functional dependencies: specification and verification",
      "author" : [ "Carlo Combi", "Pietro Sala" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2014
    }, {
      "title" : "Nondeterministic ideal operators: An adequate tool for formalization in data bases",
      "author" : [ "Pablo Cordero", "Ángel Mora", "Inmaculada Pérez de Guzmán", "Manuel Enciso" ],
      "venue" : "Discrete Applied Mathematics",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2008
    }, {
      "title" : "Relational Database Writings 1989–1991",
      "author" : [ "Chris J. Date", "Hugh Darwen" ],
      "venue" : "ch. The Role of Functional Dependence in Query Decomposition,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1992
    }, {
      "title" : "Time and relational theory: Temporal databases in the relational model and sql",
      "author" : [ "Chris J. Date", "Hugh Darwen", "Nikos A. Lorentzos" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2014
    }, {
      "title" : "Introduction to Lattices and Order",
      "author" : [ "Brian A. Davey", "Hilary A. Priestley" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1990
    }, {
      "title" : "Detection and exploitation of functional dependencies for model generation, Theory and Practice of Logic Programming",
      "author" : [ "Broes De Cat", "Maurice Bruynooghe" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2013
    }, {
      "title" : "Mining frequent conjunctive queries using functional and inclusion dependencies",
      "author" : [ "Cheikh Tidiane Dieng", "Tao-Yuan Jen", "Dominique Laurent", "Nicolas Spyratos" ],
      "venue" : "VLDB Journal",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2013
    }, {
      "title" : "Functional dependencies in a relational database and propositional logic, IBM",
      "author" : [ "Ronald Fagin" ],
      "venue" : "Journal of Research and Development",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1977
    }, {
      "title" : "Incremental detection of inconsistencies in distributed data",
      "author" : [ "Wenfei Fan", "Jianzhong Li", "Nan Tang", "Wenyuan Yu" ],
      "venue" : "IEEE Transactions on Knowledge and Data Engineering",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2014
    }, {
      "title" : "Inter-transactional association rules for multi-dimensional contexts for prediction and their application to studying meterological data, Data",
      "author" : [ "Ling Feng", "Tharam Dillon", "James Liu" ],
      "venue" : "Knowl. Eng",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2001
    }, {
      "title" : "A template model for multidimensional inter-transactional association rules",
      "author" : [ "Ling Feng", "Jeffrey Xu Yu", "Hongjun Lu", "Jiawei Han" ],
      "venue" : "The VLDB Journal",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2002
    }, {
      "title" : "Reasoning about functional and full hierarchical dependencies over partial relations",
      "author" : [ "Flavio Ferrarotti", "Sven Hartmann", "Sebastian Link" ],
      "venue" : "Information Sciences",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2013
    }, {
      "title" : "Formal concept analysis: Mathematical foundations",
      "author" : [ "Bernhard Ganter", "Rudolf Wille" ],
      "venue" : null,
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1997
    }, {
      "title" : "Computers and intractability: A guide to the theory of np-completeness",
      "author" : [ "Michael R. Garey", "David S. Johnson" ],
      "venue" : null,
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1979
    }, {
      "title" : "Familles minimales d’implications informatives resultant d’un tableau de données",
      "author" : [ "Jean-Louis Guigues", "Vincent Duquenne" ],
      "venue" : "binaires, Math. Sci. Humaines",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 1986
    }, {
      "title" : "Metamathematics of Fuzzy Logic, Kluwer Academic Publishers, Dordrecht",
      "author" : [ "Petr Hájek" ],
      "venue" : "The Netherlands,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 1998
    }, {
      "title" : "Efficient mining of salinity and temperature association rules from argo data",
      "author" : [ "Yo-Ping Huang", "Li-Jen Kao", "Frode-Eika Sandnes" ],
      "venue" : "Expert Syst. Appl",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2008
    }, {
      "title" : "On functional dependencies in q-horn theories",
      "author" : [ "Toshihide Ibaraki", "Alexander Kogan", "Kazuhisa Makino" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2001
    }, {
      "title" : "An efficient algorithm for mining closed inter-transaction itemsets",
      "author" : [ "Anthony J.T. Lee", "Chun-Sheng Wang", "Wan-Yu Weng", "Yi-An Chen", "Huei-Wen Wu" ],
      "venue" : "Data Knowl. Eng",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2008
    }, {
      "title" : "A triadic approach to formal concept analysis, Conceptual Structures: Applications, Implementation and Theory",
      "author" : [ "Fritz Lehmann", "Rudolf Wille" ],
      "venue" : "Lecture Notes in Computer Science,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 1995
    }, {
      "title" : "Effective pruning for the discovery of conditional functional dependencies",
      "author" : [ "Jiuyong Li", "Jixue Liu", "Hannu Toivonen", "Jianming Yong" ],
      "venue" : "Computer Journal",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2013
    }, {
      "title" : "Discovering calendarbased temporal association rules, Data and Knowledge Engineering",
      "author" : [ "Yingjiu Li", "Peng Ning", "Xiaoyang Sean Wang", "Sushil Jajodia" ],
      "venue" : null,
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2003
    }, {
      "title" : "First order predicate logic with generalized quantifiers",
      "author" : [ "Per Lindström" ],
      "venue" : "Theoria",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 1966
    }, {
      "title" : "On discovery of functional dependencies from data, Data ",
      "author" : [ "Jixue Liu", "Feiyue Ye", "Jiuyong Li", "Junhu Wang" ],
      "venue" : "Knowledge Engineering",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2013
    }, {
      "title" : "Beyond intratransaction association analysis: Mining multidimensional intertransaction association",
      "author" : [ "Hongjun Lu", "Ling Feng", "Jiawei Han" ],
      "venue" : "rules, ACM Trans. Inf. Syst",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2000
    }, {
      "title" : "Extending inclusion dependencies with conditions",
      "author" : [ "Shuai Ma", "Wenfei Fan", "Loreto Bravo" ],
      "venue" : "Theoretical Computer Science",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2014
    }, {
      "title" : "Theory of Relational Databases, Computer Science Pr",
      "author" : [ "David Maier" ],
      "venue" : "Rockville, MD,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 1983
    }, {
      "title" : "On a generalization of quantifiers",
      "author" : [ "Andrzej Mostowski" ],
      "venue" : "Fundamenta Mathematicae",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 1957
    }, {
      "title" : "A relation-algebraic approach to the “Hoare logic” of functional dependencies",
      "author" : [ "Jose N. Oliveira" ],
      "venue" : "Journal of Logical and Algebraic Methods in Programming",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2014
    }, {
      "title" : "Computational Complexity, Addison-Wesley Publishing Co., Inc",
      "author" : [ "Christos H. Papadimitriou" ],
      "venue" : null,
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 1994
    }, {
      "title" : "Adding temporal semantics to association rules, Principles of Data Mining and Knowledge Discovery",
      "author" : [ "Chris P. Rainsford", "John F. Roddick" ],
      "venue" : "(Jan M. Żytkow and Jan Rauch, eds.), Lecture Notes in Computer Science,",
      "citeRegEx" : "46",
      "shortCiteRegEx" : "46",
      "year" : 1999
    }, {
      "title" : "The complexity of decision problems for linear temporal logics",
      "author" : [ "Mark Reynolds" ],
      "venue" : "Journal of Studies in Logic",
      "citeRegEx" : "47",
      "shortCiteRegEx" : "47",
      "year" : 2010
    }, {
      "title" : "A machine-oriented logic based on the resolution principle",
      "author" : [ "John A. Robinson" ],
      "venue" : "J. ACM",
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 1965
    }, {
      "title" : "Efficient determination of distance thresholds for differential dependencies",
      "author" : [ "Shaoxu Song", "Lei Chen", "Hong Cheng" ],
      "venue" : "IEEE Transactions on Knowledge and Data Engineering",
      "citeRegEx" : "49",
      "shortCiteRegEx" : "49",
      "year" : 2014
    }, {
      "title" : "Functional dependencies on symbol strings generated by extended context free languages, Advances in Databases and Information Systems",
      "author" : [ "Gyula I. Szabo", "Andras Benczur" ],
      "venue" : "Advances in Intelligent Systems and Computing,",
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 2013
    }, {
      "title" : "Breaking the barrier of transactions: Mining inter-transaction association rules",
      "author" : [ "Anthony K.H. Tung", "Hongjun Lu", "Jiawei Han", "Ling Feng" ],
      "venue" : "Proceedings of the Fifth ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (New York, NY, USA), KDD ’99,",
      "citeRegEx" : "52",
      "shortCiteRegEx" : "52",
      "year" : 1999
    }, {
      "title" : "The implication problem for ‘closest node’ functional dependencies in complete XML documents",
      "author" : [ "Millist W. Vincent", "Jixue Liu", "Mukesh K. Mohania" ],
      "venue" : "Journal of Computer and System Sciences",
      "citeRegEx" : "53",
      "shortCiteRegEx" : "53",
      "year" : 2012
    }, {
      "title" : "Exploiting functional dependencies in qualitative probabilistic reasoning, CoRR abs/1304.1081",
      "author" : [ "Michael P. Wellman" ],
      "venue" : null,
      "citeRegEx" : "54",
      "shortCiteRegEx" : "54",
      "year" : 2013
    }, {
      "title" : "Mining non-redundant association rules, Data Mining and Knowledge Discovery",
      "author" : [ "Mohammed J. Zaki" ],
      "venue" : null,
      "citeRegEx" : "55",
      "shortCiteRegEx" : "55",
      "year" : 2004
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.",
      "startOffset" : 159,
      "endOffset" : 167
    }, {
      "referenceID" : 35,
      "context" : "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.",
      "startOffset" : 159,
      "endOffset" : 167
    }, {
      "referenceID" : 21,
      "context" : "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.",
      "startOffset" : 193,
      "endOffset" : 201
    }, {
      "referenceID" : 23,
      "context" : "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.",
      "startOffset" : 193,
      "endOffset" : 201
    }, {
      "referenceID" : 0,
      "context" : "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.",
      "startOffset" : 215,
      "endOffset" : 222
    }, {
      "referenceID" : 47,
      "context" : "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.",
      "startOffset" : 215,
      "endOffset" : 222
    }, {
      "referenceID" : 41,
      "context" : "Formulas describing if-then dependencies between attributes play fundamental role in reasoning about attributes in many disciplines including database systems [13, 42], formal concept analysis [26, 28], data mining [1, 55], logic programming [39, 48], and their applications.",
      "startOffset" : 242,
      "endOffset" : 250
    }, {
      "referenceID" : 16,
      "context" : ", transactional data, boolean matrices, or n-ary relations) but as it has been shown in [21], the rules may be seen as propositional formulas with the semantic entailment defined as in the propositional logic, possibly extended by additional measures of interestingness.",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 5,
      "context" : "The rules are popular because of their easy readability for non-expert users and tractability of the entailment problem which is decidable in linear time [6].",
      "startOffset" : 154,
      "endOffset" : 157
    }, {
      "referenceID" : 4,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 92,
      "endOffset" : 115
    }, {
      "referenceID" : 20,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 92,
      "endOffset" : 115
    }, {
      "referenceID" : 26,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 92,
      "endOffset" : 115
    }, {
      "referenceID" : 34,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 92,
      "endOffset" : 115
    }, {
      "referenceID" : 37,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 92,
      "endOffset" : 115
    }, {
      "referenceID" : 42,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 92,
      "endOffset" : 115
    }, {
      "referenceID" : 9,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 14,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 15,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 17,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 29,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 32,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 43,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 45,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 46,
      "context" : "Research on if-then rules is active and recent results include new theoretical observations [5, 25, 31, 41, 44, 49] on the rules and their generalizations as well as applications in data analysis, formal languages, and related areas [14, 19, 20, 22, 35, 38, 50, 53, 54].",
      "startOffset" : 233,
      "endOffset" : 269
    }, {
      "referenceID" : 28,
      "context" : "Fourth, we include notes on the relationship of the formulas to formulas appearing in modal logics [9] and triadic formal concept analysis [34].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 44,
      "context" : "Similar rules as we consider in this paper appeared as inter-transaction association rules [52] inferred from time-changing transactional data.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 6,
      "context" : "Formulas called temporal functional dependencies emerged in databases with time granularities [7].",
      "startOffset" : 94,
      "endOffset" : 97
    }, {
      "referenceID" : 16,
      "context" : "In this setting, temporal functional dependencies are like the ordinary functional dependencies [21] with a time granularity as an additional component.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 6,
      "context" : "Thus, [7] uses an ordinary notion of validity of functional dependencies which is restricted to some time segments.",
      "startOffset" : 6,
      "endOffset" : 9
    }, {
      "referenceID" : 6,
      "context" : "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 0,
      "context" : "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].",
      "startOffset" : 128,
      "endOffset" : 135
    }, {
      "referenceID" : 47,
      "context" : "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].",
      "startOffset" : 128,
      "endOffset" : 135
    }, {
      "referenceID" : 1,
      "context" : "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].",
      "startOffset" : 180,
      "endOffset" : 191
    }, {
      "referenceID" : 30,
      "context" : "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].",
      "startOffset" : 180,
      "endOffset" : 191
    }, {
      "referenceID" : 39,
      "context" : "Several approaches to temporal if-then rules, which are conceptually similar to [7], appeared in the field of association rules [1, 55] as the so-called temporal association rules [2, 36, 46].",
      "startOffset" : 180,
      "endOffset" : 191
    }, {
      "referenceID" : 18,
      "context" : "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.",
      "startOffset" : 126,
      "endOffset" : 142
    }, {
      "referenceID" : 19,
      "context" : "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.",
      "startOffset" : 126,
      "endOffset" : 142
    }, {
      "referenceID" : 27,
      "context" : "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.",
      "startOffset" : 126,
      "endOffset" : 142
    }, {
      "referenceID" : 44,
      "context" : "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.",
      "startOffset" : 126,
      "endOffset" : 142
    }, {
      "referenceID" : 33,
      "context" : "Other results motivated by temporal semantics of association rules includes the so-called inter-transaction association rules [23, 24, 33, 52], see [40] for a survey of approaches.",
      "startOffset" : 148,
      "endOffset" : 152
    }, {
      "referenceID" : 0,
      "context" : "As a consequence, the inter-transaction association rules are related to the rules in our approach in the same way as the ordinary association rules [1] are related to the ordinary attribute implications [26].",
      "startOffset" : 149,
      "endOffset" : 152
    }, {
      "referenceID" : 21,
      "context" : "As a consequence, the inter-transaction association rules are related to the rules in our approach in the same way as the ordinary association rules [1] are related to the ordinary attribute implications [26].",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 18,
      "context" : "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.",
      "startOffset" : 15,
      "endOffset" : 35
    }, {
      "referenceID" : 19,
      "context" : "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.",
      "startOffset" : 15,
      "endOffset" : 35
    }, {
      "referenceID" : 27,
      "context" : "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.",
      "startOffset" : 15,
      "endOffset" : 35
    }, {
      "referenceID" : 33,
      "context" : "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.",
      "startOffset" : 15,
      "endOffset" : 35
    }, {
      "referenceID" : 44,
      "context" : "The results in [23, 24, 33, 40, 52] are focused almost exclusively on algorithms for mining the inter-transaction association rules and are not concerned with problems of entailment of the rules and the underlying logic.",
      "startOffset" : 15,
      "endOffset" : 35
    }, {
      "referenceID" : 18,
      "context" : "Our observations may stimulate further development in the field of inter-transaction association rules and similar formulas and their applications in various domains [23, 30].",
      "startOffset" : 166,
      "endOffset" : 174
    }, {
      "referenceID" : 25,
      "context" : "Our observations may stimulate further development in the field of inter-transaction association rules and similar formulas and their applications in various domains [23, 30].",
      "startOffset" : 166,
      "endOffset" : 174
    }, {
      "referenceID" : 7,
      "context" : "The formulas studied in this paper are also related to particular program rules which appear in Datalog extensions dealing with flow of time and related phenomena [10, 11, 12] such as DatalognS (Datalog with n successors).",
      "startOffset" : 163,
      "endOffset" : 175
    }, {
      "referenceID" : 13,
      "context" : "More details can be found in [8, 18].",
      "startOffset" : 29,
      "endOffset" : 36
    }, {
      "referenceID" : 2,
      "context" : "The provability is based on an extension of the Armstrong axiomatic system [3] which is well known mainly in database systems [42].",
      "startOffset" : 75,
      "endOffset" : 78
    }, {
      "referenceID" : 35,
      "context" : "The provability is based on an extension of the Armstrong axiomatic system [3] which is well known mainly in database systems [42].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 35,
      "context" : "(a) Note that there are several equivalent systems which are called the Armstrong systems [42].",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 2,
      "context" : "In the classic case, (Ax) and (Cut) form a system which is equivalent to that from [3].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 35,
      "context" : "” Also note that in the database literature, (Cut) is also referred to as the rule of pseudo-transitivity [42].",
      "startOffset" : 106,
      "endOffset" : 110
    }, {
      "referenceID" : 2,
      "context" : "The laws hold because our system is an extension of the Armstrong system in which the laws hold as well, see [3, 42].",
      "startOffset" : 109,
      "endOffset" : 116
    }, {
      "referenceID" : 35,
      "context" : "The laws hold because our system is an extension of the Armstrong system in which the laws hold as well, see [3, 42].",
      "startOffset" : 109,
      "endOffset" : 116
    }, {
      "referenceID" : 35,
      "context" : "The proof goes by induction on the length of a proof, considering the facts that each axiom is true in all models, (Cut) is a sound deduction rule [42], and (Shf) is sound on account of Lemma 14.",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 10,
      "context" : "(c) An alternative deduction system for our logic can be based on (Ref) instead of (Ax) and a single rule which is a modification of a simplification deduction rule [15].",
      "startOffset" : 165,
      "endOffset" : 169
    }, {
      "referenceID" : 24,
      "context" : "[29].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "For the subproblem we provide a pseudo-polynomial time [27] decision algorithm.",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 38,
      "context" : "In order to show the lower bound of the time complexity of LENT, we utilize a reduction of decision problems [45] which involves the unbounded subset sum problem.",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 5,
      "context" : "Let us note that in the case of the ordinary attribute implications and functional dependencies, the problem of determining whether a given formula follows by a finite set of formulas is easy and there exist efficient linear time decision algorithms [6].",
      "startOffset" : 250,
      "endOffset" : 253
    }, {
      "referenceID" : 40,
      "context" : "In order to establish an upper bound, we utilize the fact that the satisfiability problem of temporal logic with “until” and “since” operators over a linear flow of time is decidable in polynomial space [47].",
      "startOffset" : 203,
      "endOffset" : 207
    }, {
      "referenceID" : 3,
      "context" : "For the purpose of our proof, we use the linear temporal logic over 〈Z, <〉 with the unary temporal operators (always), ◦F (next time), and ◦P (previous time) because these operators are definable using operators “until” and “since”, see [4] for details.",
      "startOffset" : 237,
      "endOffset" : 240
    }, {
      "referenceID" : 3,
      "context" : "Then, the input is reduced to the satisfiability problem of the linear temporal logic over 〈Z, <〉 with binary temporal operators “until” and “since” in linear space [4] which we can decide in polynomial space [47].",
      "startOffset" : 165,
      "endOffset" : 168
    }, {
      "referenceID" : 40,
      "context" : "Then, the input is reduced to the satisfiability problem of the linear temporal logic over 〈Z, <〉 with binary temporal operators “until” and “since” in linear space [4] which we can decide in polynomial space [47].",
      "startOffset" : 209,
      "endOffset" : 213
    }, {
      "referenceID" : 5,
      "context" : "Therefore, the problem is decidable in a time which is polynomial with respect to the size of Σ A [6, 26, 42].",
      "startOffset" : 98,
      "endOffset" : 109
    }, {
      "referenceID" : 21,
      "context" : "Therefore, the problem is decidable in a time which is polynomial with respect to the size of Σ A [6, 26, 42].",
      "startOffset" : 98,
      "endOffset" : 109
    }, {
      "referenceID" : 35,
      "context" : "Therefore, the problem is decidable in a time which is polynomial with respect to the size of Σ A [6, 26, 42].",
      "startOffset" : 98,
      "endOffset" : 109
    }, {
      "referenceID" : 22,
      "context" : "(a) By considering only LENT ∩LPRE, we have improved the upper bound since pseudo-polynomial time algorithms belong to EXPTIME [27] which is believed to be better than EXPSPACE.",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 18,
      "context" : "(b) Because of the complexity issues, in applications it is reasonable to consider attribute implications annotated by time points with small difference between lower and upper time bounds (maxspan [23]) since LENT ∩ LPRE is decidable in pseudo-linear time with respect to n given by (36).",
      "startOffset" : 198,
      "endOffset" : 202
    }, {
      "referenceID" : 5,
      "context" : "It is a generalization of LinClosure [6], cf.",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 35,
      "context" : "also [42], which incorporates applicable time shifts of formulas in Σ.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 5,
      "context" : "Technical details can be found in [6].",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 33,
      "context" : "Since M can be regarded as transactional data over a set of items Y with a dimensional attribute d the domain of which is Z, we can utilize the algorithm proposed in [40].",
      "startOffset" : 166,
      "endOffset" : 170
    }, {
      "referenceID" : 31,
      "context" : "Future research directions we consider interesting include utilization of generalized quantifiers [37, 43] to capture notions like “validity in all time points with possible exceptions”, connections to rules which may emerge in temporal databases [17], and further analysis of algorithms related to the entailment.",
      "startOffset" : 98,
      "endOffset" : 106
    }, {
      "referenceID" : 36,
      "context" : "Future research directions we consider interesting include utilization of generalized quantifiers [37, 43] to capture notions like “validity in all time points with possible exceptions”, connections to rules which may emerge in temporal databases [17], and further analysis of algorithms related to the entailment.",
      "startOffset" : 98,
      "endOffset" : 106
    }, {
      "referenceID" : 12,
      "context" : "Future research directions we consider interesting include utilization of generalized quantifiers [37, 43] to capture notions like “validity in all time points with possible exceptions”, connections to rules which may emerge in temporal databases [17], and further analysis of algorithms related to the entailment.",
      "startOffset" : 247,
      "endOffset" : 251
    } ],
    "year" : 2015,
    "abstractText" : "We study logic for reasoning with if-then formulas describing dependencies between attributes of objects which are observed in consecutive points in time. We introduce semantic entailment of the formulas, show its fixed-point characterization, investigate closure properties of model classes, present an axiomatization and prove its completeness, and investigate alternative axiomatizations and normalized proofs. We investigate decidability and complexity issues of the logic and prove that the entailment problem is NP-hard and belongs to EXPSPACE. We show that by restricting to predictive formulas, the entailment problem is decidable in pseudo-linear time.",
    "creator" : "LaTeX with hyperref package"
  }
}