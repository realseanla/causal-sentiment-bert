{
  "name" : "1702.07889.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Contractibility for Open Global Constraints",
    "authors" : [ "Michael J. Maher" ],
    "emails" : [ "michael.maher@reasoning.org.au" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 2.\n07 88\n9v 1\n[ cs\n.L O\n] 2\nUnder consideration in Theory and Practice of Logic Programming (TPLP).\nKEYWORDS: global constraints; open constraints; soft constraints"
    }, {
      "heading" : "1 Introduction",
      "text" : "Constraint Logic Programming (CLP) (Jaffar and Maher 1994) provides the ability to add variables and constraints to a constraint store during the course of an execution. In this it is not alone: linear and integer programming solvers and solvers presented as libraries for an underlying programming language also allow the introduction of new variables and constraints in an incremental way. In some problems it is natural for the presence of some variables to be contingent on the value of other variables. This is true of configuration problems and scheduling problems that involve process-dependent activities (Mittal and Falkenhainer 1990; Barták 2003). More generally, for difficult problems the intertwining of problem construction and problem solving provides a way to manage the complexity of a problem, and thus new variables and constraints may arise after solving has begun. Thus CLP is particularly well-suited for such problems, in contrast to compilation-based modelling languages such as MiniZinc (Nethercote et al. 2007) where all variables and constraints must be fixed at compilation time.\nCLP also supports global constraints, which have been an important part of the success of constraint programming. However, most implementations of global constraints adopt a non-incremental approach: the variables constrained by a global constraint are fixed when the constraint is imposed. Thus the collection of variables they constrain is closed, rather than open. This restricts the exploitation of incrementality that is available in CLP languages. Delaying the imposition of a global constraint until all variables it might involve have been generated can leave the filtering effect of the global constraint until too late\nin the execution, resulting in a large search space. Open global constraints remove this limitation by allowing variables to be added dynamically.\nA major difficulty in implementing open constraints is that a propagator for a closed constraint may be unsound for the corresponding open constraint. That is, the propagator may make an inference that turns out to be unjustified once the sequence of variables is extended. In this paper we focus on the issue of identifying constraints for which a closed propagator is sound as an open propagator. These constraints have a simple characterization, which we call contractibility, and which allows us to easily determine whether a given constraint has this property. This characterization is also convenient for finding the tightest contractible approximation of an uncontractible constraint, which can be the basis for an open propagator of the constraint. We illustrate our results with a wide variety of global constraints, including both hard and soft constraints.\nAs part of our treatment of soft constraints we formulate two very general classes of soft constraints based, respectively, on constraint decomposition and edit distance. These classes unify and generalize several different proposals in the literature. Using these formulations, we introduce general results and techniques for establishing that a constraint is contractible. It turns out that finding a tightest contractible approximation is more difficult for soft constraints than for hard constraints. In particular, while we can mathematically characterize the tightest approximation, and define some pragmatic generic non-tight approximations, we show that the tightest contractible approximation cannot always be represented in the edit-distance framework.\nThis paper is arranged as follows. After some preliminaries in Section 2 and a discussion of open constraints in Section 3, we introduce contractibility in Section 4. We show that it characterizes those constraints for which closed propagators remain sound when the constraint is open, and develop an algebra for constructing contractible constraints. We conclude Section 4 by characterizing contractibility in language-theoretic terms, and use that characterization to identify contractible constraints (Section 5) and tight approximations of uncontractible constraints (Section 6). We show that, with a tight approximation, a proposal of Barták for implementing open uncontractible constraints achieves an appropriate consistency. We then address the same issues for soft constraints (Sections 7 and 8).\nThis paper incorporates results announced in (Maher 2009c; Maher 2009b; Maher 2009d; Maher 2010). It includes unpublished proofs, strengthened results, new results and some additional discussion."
    }, {
      "heading" : "2 Background",
      "text" : "The reader is assumed to have a basic knowledge of constraint programming, CSPs, global constraints, and filtering, as might be found in (Dechter 2003; Rossi et al. 2006; Beldiceanu et al. 2005).\nFor the purposes of this paper, a global constraint is a relation over a single sequence of variables. Other arguments of a constraint are considered parameters and are assumed to be fixed before execution. Throughout this paper, a sequence of variables will be denoted, interchangeably, by ~X or [X1, . . . , Xn]. We make no a priori restriction on the variables that may participate in the sequence except that, in common with most work on global constraints, we assume that no variable appears more than once in a single constraint.\nThere are some specific global constraints that we define for completeness. These and other global constraints are discussed more completely in (Beldiceanu et al. 2005) and the references therein. As with variables, a sequence of values vi is expressed by ~v. The constraint AllDifferent([X1, . . . , Xn]) (Régin 1994) states that the variables X1, . . . , Xn take distinct values. The global cardinality constraint GCC(~v,~l, ~u, [X1, . . . , Xn]) (Régin 1996) states that, for every i, the value vi occurs be-\ntween li and ui times in the list of variables. The constraint NValue([X1, . . . , Xn], N) (Pachet and Roy 1999) states that there are exactly N distinct values in X1, . . . , Xn. The constraint Regular(A, [X1, . . . , Xn]) (Pesant 2004) states that the value of the list of variables, when considered as a word, is accepted by the automaton A. Similarly, the constraint CFG(G, [X1, . . . , Xn]) (Quimper and Walsh 2006; Sellmann 2006) (called Grammar in (Quimper and Walsh 2006)) states that the value of the list of variables, when considered as a word, is generated by the context-free grammar G.\nThe constraint Sequence(l, u, k, [X1, . . . , Xn], ~v) (Beldiceanu and Contejean 1994) states that any consecutive sequence of k variables Xj , . . . , Xj+k−1 contains between l and u occurrences of values from ~v. The constraint SlidingSum(l, u, k, [X1, . . . , Xn]) (Beldiceanu and Carlsson 2001) states that the sum of any consecutive sequence of k variables lies between l and u. The constraint Contiguity([X1, . . . , Xn]) (Maher 2002) states that the variables Xi take values from {0, 1} and the variables taking the value 1 are consecutive. The lexicographical ordering constraint [X1, . . . , Xn] ≤lex [Z1, . . . , Zn] (Frisch et al. 2002) states that the sequence of X variables is lexicographically less than or equal to the sequence of Z variables, where we assume some ordering on the underlying values. The precedence constraint s ≺ ~X t (Law and Lee 2004) states that if t appears in the sequence ~X then s appears at a lower index.\nFor some constraints, like AllDifferent, GCC and NValue, the order of variables is immaterial to the semantics of the constraint. We say a constraint C is order-free if\nC([X1, . . . , Xn]) ↔ C([Xπ(1), . . . , Xπ(n)])\nfor every permutation π of 1..n. The other constraints mentioned above are not order-free. We assume that the argument ~X of a use of a global constraint has a static type T that assigns, for every position i, a set of values. Thus every variable X in ~X has a static type T (X) of values that it may take. We will also view T as a unary predicate on the variables of ~X, where T (X) is true iff X takes a value from its static type. In addition, generally, each variable has an associated set S ⊆ T (X) of values, called its domain. We will view this simultaneously as: a function D : ~X → 2V alues where D(X) = S and V alues = ⋃ Xin ~X T (X), a unary relation D(X) which is satisfied only when the value of X is some s ∈ S, and the pointwise extension of D to sequences of variables. We formalize the semantics of a global constraint C as a formal language LC . A word d1d2 . . . dn appears in LC iff the constraint C([X1, X2, . . . , Xn]) has a solution X1 = d1, . . . Xn = dn. Thus, for example, the semantics of AllDifferent is {a1 . . . an | ∀i, j i 6= j → ai 6= aj , n ∈ N} and the semantics of Regular(A, ~X) is L(A), the language accepted by A. When it is convenient, we will describe languages with Kleene regular expressions (Hopcroft and Ullman 1979). For a given use of a constraint C( ~X), we write T ( ~X) for the language defined by the static type of C( ~X).\nThe following definitions will be important later. Let P (L) = {w | ∃u wu ∈ L} denote the set of prefixes of a language L, called the prefix-closure of L. We say L is prefix-closed if P (L) = L. We say two languages L and L′ are prefix-equivalent if P (L) = P (L′)."
    }, {
      "heading" : "3 Open Constraints",
      "text" : "There are many problems that are dynamic in nature but to which we would like to apply constraint techniques. (Barták 1999) describes a class of complex processing environments where there may be alternative processing routes, different production formulas and alternative raw materials. In addition to the core products of the processes, there may be by-products and co-products which require additional processing. Some instances of products may be re-processed or recycled. Because of storage limits and/or a necessity to work with the instances while they are still in an amenable state, such instances might need to be re-processed or recycled promptly. In such environments, process scheduling must be\ndynamic: additional tasks may arise from re-processing, and additional raw materials may arise.\nMany production processing environments have these characteristics. Consider, for example, sugar cane processing. Juice is extracted from the sugar cane and clarified before it is refined. Refining involves repeated crystallization and centrifuging processes, with molasses produced as a by-product. Usually three repetitions of these processes are performed but, through natural variation of the raw materials, an additional repetition may be needed. Such a need can be identified through monitoring the refinement process.\nNow consider a constraint-based approach to the problem of the on-going scheduling of these processes. We might use a Cumulative constraint to express the limited availability of centrifuges. When a batch requires an additional repetition, a new task must be added to that constraint and additional constraints concerning the task must be added to the problem. Thus we require that Cumulative be an open constraint – able to accept additional tasks.\nOpen constraints pre-suppose the existence of a meta-program that can impose constraints, close an open constraint, add variables to an open constraint, (possibly) create new variables, and interact with the execution of the constraint system, possibly controlling it. In this paper we will abstract away the details of the meta-program so that we can focus on the open constraints. We assume that the collection of variables forms a sequence, to which variables may be added at the right-hand end only.1 The scope of constraints changes during the execution, and we refer to the state of the constraint at some point in the execution as an occurrence of the constraint. In open global constraints C the length of the sequence of variables varies and consequently the semantics in terms of the language LC is particularly appropriate.\nThere are three models of open constraint that have been proposed.2 (Barták 2003) first formulated this issue and described a straightforward model: the constraint involves a sequence of variables to which variables may be added. Thus the arity and type of the constraint are unchanged, whether the constraint is open or closed. (Barták 2003) outlined a generic implementation technique to make open versions for the class ofmonotonic global constraints. Barták focussed on a specific implementation of the open AllDifferent constraint. This is an order-free constraint, and details of the model, such as where variables are added to the sequence, are left unspecified. The remaining models extend this model by incorporating more details about the possible extension of the sequence; for these models the constraint has a different arity or type.\nThe model of (van Hoeve and Régin 2006) only applies to order-free constraints expressed in the form C(S). It uses a set variable S describing a set of object variables, rather than a sequence, to represent the collection of variables in the constraint.3 The lower bound of S is the set of variables that are committed to appear in the constraint; the upper bound is the set of variables that are permitted to appear in the constraint. Thus there is a finite set of variables that might appear in the constraint, and these are fixed in advance. The authors refer to the constraint as open “in a closed world” since the set of variables that might be added to the constraint is closed. The model makes elegant use of existing implementations of set variables and their associated bounds. However,\n1 There is a brief discussion of the effect of alternatives in Section 9. 2 The terminology “open constraint satisfaction problem” was introduced by (Faltings and Macho-Gonzalez 2002; Faltings and Macho-Gonzalez 2005). However, that use refers to problems in which the set of variables is closed but the domains are open, that is, extra values can be added to variable domains. That work is not technically related to “open constraints” as used in this paper, but it shares with this paper an interest in constraint problems that may change over time. 3 A set variable S ranges over sets and is constrained by two fixed finite sets L and U which are a lower and upper bound on the value of the variable: L ⊆ S ⊆ U . See (Gervet 1997).\nthe use of a constraint in this model requires knowing all the variables that might appear before imposing the constraint. As a result, it cannot deal well with contingent variables. They create a similar problem to the one faced by closed constraints: the constraint may be imposed late in the execution, creating a larger search space.\nThe third model (Maher 2009b) is, in some ways, intermediate between that of (Barták 2003) and (van Hoeve and Régin 2006). Under this model, a constraint C( ~X,N) acts on both a sequence of variables ~X and an integer variable N representing the length of the sequence once it is closed. Variables can only be added at the right-hand end of the sequence. This is a more detailed model than Barták’s. In one sense, this model is an abstraction of the model of (van Hoeve and Régin 2006): if N is subject only to lower and upper bounds, then the bounds on N correspond to the cardinalities of the bounds of S. It does not have the weakness of that model that the variables that might appear are fixed in advance. On the other hand, the van Hoeve-Regin model has more information about how ~X might be extended, and so might be able to perform stronger propagation.\nThe model we employ here is Barták’s model where we specify that variables may be added only at the right-hand end of the sequence. It is equivalent to a weak form of the model of (Maher 2009b) where there are no restrictions on N . However, the notion of contractibility, to be introduced in the next section, is relevant for other models of open constraints. Some results are given in (Maher 2009b) for the model treated there. We will assume that the only operations that can be applied to an open constraint are adding a variable and designating the constraint closed, so that no more variables may be added.\nConstraint programming with open constraints is a special case of dynamic CSPs in the broad sense described in (Dechter and Dechter 1988). Work on dynamic CSPs has focussed on the addition and retraction of constraints (Hentenryck and Provost 1991; Bessière 1991; Georget et al. 1999; Debruyne et al. 2003). It does not directly address the addition of variables to a constraint, although that can be viewed as a combined retraction and addition of constraints. See (Verfaillie and Jussien 2005) for a survey on dynamic constraint solving. Work on conditional CSPs, initiated in (Mittal and Falkenhainer 1990), addresses contingent variables by explicitly embedding the contingent nature within a CSP, but that work does not address the addition of variables to constraints.\nOther forms of dynamism have been addressed in the context of constraints by allowing variable domains to be initially incomplete and expand over time (Faltings and Macho-Gonzalez 2005; Gavanelli et al. 2005), or by formulating constraints over a stream of values (Lallouet et al. 2011). That work is not technically related to the work in this paper.\nWe take filtering or propagation to refer to any algorithm f that reduces domains, that is, ∀X f(D)(X) ⊆ D(X). A filtering algorithm f for a constraint C is sound if every solution of C in D also appears in f(D). Some filtering algorithms are characterized by consistency conditions. For closed constraints, the strongest filtering/consistency condition that addresses each constraint separately is domain consistency. A closed constraint C(X1, X2, . . . , Xn) is domain consistent if for every i where 1 ≤ i ≤ n and every d ∈ D(Xi) there is a word d1 . . . dn in LC such that di = d and dj ∈ D(Xj) for j = 1, . . . , n.\nBecause some of the variables in an open constraint will be unspecified during part of the execution, we need to adapt the definition of consistency. The following is an appropriate form of domain consistency for Barták’s model.\nDefinition 1 Given a domain D, an occurrence of a constraint C( ~X) is open D-consistent if, for every Xi ∈ ~X and every d ∈ D(Xi), there is a word d1 . . . dm in LC such that di = d, | ~X| ≤ m, and dj ∈ D(Xj) for j = 1, . . . , | ~X |.\nWhen C is closed, the only words of interest in LC are those of length | ~X |. In that case open D-consistency reduces to domain consistency."
    }, {
      "heading" : "4 Contractibility",
      "text" : "Wewant to extend a constraint C([X1, . . . , Xn]) with an extra variable Y to C([X1, . . . , Xn, Y ]). We would like to do filtering on the smaller constraint without knowing whether it will be extended to Y , or further, and without creating a choicepoint. When we can do this, we have a kind of monotonicity property of C.\nDefinition 2 We say a constraint C([X1, . . . , Xn]) is contractible if, there is a number m such that for all n ≥ m we have\nC([X1, . . . , Xn, Y ]) → C([X1, . . . , Xn])\nThe least such m is called the contractibility threshold. For this paper we consider only constraints with a contractibility threshold of 0.\nThus C is contractible iff every solution of C([X1, . . . , Xn, Y ]), when restricted to X1, . . . , Xn where m ≤ n, is a solution of C([X1, . . . , Xn]). The property is akin to the “optimal substructure” property that is a pre-requisite for the use of dynamic programming in optimization problems (Cormen et al. 2001) which requires that optimal solutions of a problem also solve subproblems optimally. Here it is only satisfiability, and not optimality, that is involved.\nIt follows that any sound form of filtering (such as arc consistency or bounds consistency) on a contractible constraint C([X1, . . . , Xk]) is safe in the sense that any values deleted from domains in that process could also be deleted while filtering on C([X1, . . . , Xn]) for any n ≥ k. Recall that we use ~X and [X1, . . . , Xn] interchangeably.\nProposition 1 Let C be a contractible constraint. Suppose a sound filtering algorithm for C([X1, . . . , Xn]) reduces the domain D for ~X to D′. Then\nD( ~X) ∧ C([X1, . . . , Xn, Y ]) ↔ D ′( ~X) ∧ C([X1, . . . , Xn, Y ])\nFurthermore, if this property holds for all domains and all sound filterings then C must be contractible."
    }, {
      "heading" : "Proof",
      "text" : "Let σ be a solution of D( ~X) ∧ C([X1, . . . , Xn, Y ]). By contractibility of C, σ satisfies C([X1, . . . , Xn]). By the soundness of the filtering, σ satisfies D\n′( ~X). Hence, σ satisfies D′( ~X) ∧ C([X1, . . . , Xn, Y ]). Since σ is an arbitrary solution,\nD( ~X) ∧ C([X1, . . . , Xn, Y ]) → D ′( ~X) ∧ C([X1, . . . , Xn, Y ])\nSince D′ results from filtering D, D′( ~X) → D( ~X) and hence the reverse direction also holds.\nNow, suppose this property holds for all sound filterings D D′ but C is not contractible. Because C is not contractible, there must be a number n and a valuation σ that satisfies C([X1, . . . , Xn, Y ]) but not C([X1, . . . , Xn]). Let D be the domain that defines σ and D′ be the empty (unsatisfiable) domain. Then the reduction of D to D′ is sound for C([X1, . . . , Xn]) and so, by the previous supposition\nD( ~X) ∧ C([X1, . . . , Xn, Y ]) → D ′( ~X) ∧ C([X1, . . . , Xn, Y ])\nHowever, D( ~X)∧C([X1, . . . , Xn, Y ]) is satisfiable by σ, while D ′( ~X) is unsatisfiable, which contradicts this statement. This contradiction shows that C must be contractible.\nConsequently, for contractible constraints, filtering does not need to be undone if the list is lengthened. That is, algorithms for filtering a closed contractible constraint are valid also for the corresponding open constraint.\nConversely, any constraint that is not contractible might need to undo the effects of filtering if the list is lengthened. If σ is a solution of C([X1, . . . , Xn, Y ]), but not of C([X1, . . . , Xn]) then propagation on C([X1, . . . , Xn]) might eliminate σ. For example, a constraint ∑ i Xi = 5 would propagate X1 = 5 if the sequence\n~X contains just one variable, thus eliminating solutions such as X1 = 2, X2 = 3. When the second variable is added, all propagation that is a consequence of the inference X1 = 5 must be undone.\nThe second part of this proposition shows that contractibility exactly characterizes the guarantee that closed filtering is safe for open constraints. That is, it is exactly the contractible constraints for which it is always sound to interleave closed filtering and addition of new variables.\nFurthermore, the proof of the second part requires very little of the filtering algorithm. Hence, whether we maintain arc consistency or weaker consistencies like bounds consistency or forward checking, contractibility is necessary to soundly interleave closed filtering and the addition of new variables.\nWe say a domainD defines an assignment if ∀X |D(X)| = 1; in that case the assignment maps each X to the element of D(X). We say filtering performs complete checking if, whenever D defines an assignment, the result of filtering with a constraint C is D iff the assignment satisfies C. Complete checking can be considered a minimal requirement for filtering methods (Schulte and Tack 2009). Any filtering method that satisfies this minimal requirement requires contractibility to guarantee that closed filtering is sound for an open constraint.\nCorollary 2 Let C be a constraint, and consider a sound filtering method that performs complete checking. It is always sound to interleave filtering and the addition of new variables iff C is contractible.\nThe notion of contractibility is a variation of Barták’s monotonicity (Barták 2003) where we do not explicitly discuss variable domains. Before proceeding, we make this claim precise. We formulate Barták’s monotonicity as follows.\nDefinition 3 Let D be a domain. We say a constraint C is monotonic with respect to D if, for any pair of disjoint sequences of variables ~X and ~Y\n{ ~X | C( ~X~Y ) ∧D( ~X) ∧D(~Y )} ⊆ { ~X | C( ~X) ∧D( ~X)}\nContractibility differs from monotonicity in that the definition is based entirely on the constraint, independent of the domains of variables. Hence it is not tied to domain-based reasoning; it is equally compatible with the more general framework of (Maher 2009a). On the other hand, monotonicity is more flexible in reasoning about constraints that are only “partly contractible”. The close relationship between monotonicity and contractibility is clear.\nProposition 3 If C is contractible then for any domain D, C is monotonic with respect to D. Conversely, if C is monotonic with respect to every domain D then C is contractible."
    }, {
      "heading" : "Proof",
      "text" : "By repeated application of the definition of contractibility, we have that C([X1, . . . , Xn, ~Y ]) → C([X1, . . . , Xn]). It follows immediately that C is monotonic with respect to any particular D.\nIn the reverse direction, any valuation for ~X~Y can be represented by a domain D where each D(Xi) and D(Yi) is a singleton. Then monotonicity with respect to D implies C( ~X~Y ) → C( ~X) under that valuation. If C is monotonic with respect to every domain D then C( ~X~Y ) → C( ~X) holds under every valuation. That is, C is contractible.\nWe now turn to ways a constraint can be constructed to ensure it is contractible. As a trivial case, a constraint C of fixed arity k, when applied to a sequence of variables ~X, is assumed to be applied only to the initial segment X1, . . . , Xk, or not at all if ~X is shorter than k. With this definition, C is contractible.\nThe Slidej meta-constraint (Bessiere et al. 2008) can be used to define several constraints on a sequence of variables. We use a variant of Slidej that starts applying the constraint at the pth position, rather than the first. Slidepj (C, ~X) holds iff C(Xij+p, . . . , Xij+p+k−1) holds for i = 0, 1, . . . , ⌊n−p−k+1 j ⌋, where C has arity k. Slidej is equal to Slide 1 j .\nConstraints defined directly with Slidepj are contractible.\nProposition 4 Any constraint C defined by the Slidepj meta-constraint as C( ~X) ↔ Slidepj (C ′, ~X), for some fixed arity constraint C′, is contractible."
    }, {
      "heading" : "Proof",
      "text" : "Let k be the arity of C′. The relationship between C([X1, . . . , Xn, Y ]) and C([X1, . . . , Xn]) divides into cases, using the definition of C. If n− p− k + 2 is non-negative and divisible by j then\nC([X1, . . . , Xn, Y ]) ↔ C([X1, . . . , Xn]) ∧ C ′([Xn−k+2, . . . , Xn, Y ])\nIf n− p− k + 2 is negative or not divisible by j then there is no additional application of C′ and\nC([X1, . . . , Xn, Y ]) ↔ C([X1, . . . , Xn])\nThus, in both cases, C([X1, . . . , Xn, Y ]) → C([X1, . . . , Xn]) and hence C is contractible.\nSince the Sequence and SlidingSum constraints can each be defined as Slide1(C ′, ~X), for appropriate constraint C′, it follows that they are both contractible. For order-free constraints we can define a meta-constraint analogous to Slide, which we will call Splash. Like Slide, it takes a fixed arity constraint C′ and a sequence of variables ~X as arguments. Let C′ have arity k, and ~X have length n, and let Sk( ~X) = {[Xi1 , . . . , Xik ] | ij < ij+1 for j = 1, ..., k − 1} be the set of subsequences of ~X of length k. Then we define Splash(C′, ~X) ↔ ∧\n~Y ∈Sk( ~X) C\n′(~Y ). Splash(C′, ~X) applies C′ to every\nsubsequence of ~X of length k. For example, we can defineAllDifferent( ~X) as Splash( 6= , ~X) and InterDistance( ~X) as Splash(C′, ~X) where C′(Z1, Z2) ↔ |Z1 −Z2| ≥ p. Thus, by the following proposition, AllDifferent and InterDistance are contractible.\nProposition 5 Any constraint C defined by the Splash meta-constraint as C( ~X) ↔ Splash(C′, ~X), for some fixed arity constraint C′, is contractible."
    }, {
      "heading" : "Proof",
      "text" : "Let k be the arity of C′. It is straightforward to see that\nC([X1, . . . , Xn, Y ]) ↔ C([X1, . . . , Xn]) ∧ ∧\n~Z∈Sk−1( ~X)\nC′([Z1, . . . , Zk−1, Y ])\nIt follows immediately from the definition that C is contractible.\nOnce we have some contractible constraints, there are many ways to build other contractible constraints, as the following proposition demonstrates. These are expressed as logic operators, but they can also be viewed as operators on formal languages: ∧ and ∨ are intersection and union of languages, negation is complement, existential quantification projects out a variable, and universal quantification retains words that appear for all values of the relevant variable.\nProposition 6 Let C1( ~X) and C2( ~X) be contractible constraints on the same sequence of variables. Let C(X1, . . . , Xk) be a constraint of fixed arity. Then\n• C is contractible • C1 ∧ C2 is contractible • C1 ∨ C2 is contractible • ∃Xi C1 is contractible • ∀Xi C1 is contractible\nwhere Xi is a variable in ~X."
    }, {
      "heading" : "Proof",
      "text" : "We can view C as a constraint C′ on the sequence ~X where C′([X1, . . . , Xn]) ↔ true if n < k and C′([X1, . . . , Xn]) ↔ C(X1, . . . , Xk) if n ≥ k. Note that C(X1, . . . , Xk) → true and hence C′([X1, . . . , Xk−1, Y ]) → C\n′([X1, . . . , Xk−1]). When n 6= k − 1 we clearly have C′([X1, . . . , Xn, Y ]) ↔ C\n′([X1, . . . , Xn]). Suppose Ci([X1, . . . , Xn, Y ]) → Ci([X1, . . . , Xn]) for i = 1, 2. Then, by propositional\nlogic, ∧\ni\nCi([X1, . . . , Xn, Y ]) → ∧\ni\nCi([X1, . . . , Xn])\nand ∨\ni\nCi([X1, . . . , Xn, Y ]) → ∨\ni\nCi([X1, . . . , Xn])\nSimilarly, using standard arguments, for any i we can conclude\n∀Xi C1([X1, . . . , Xn, Y ]) → ∀Xi C1([X1, . . . , Xn])\nand\n∃Xi C1([X1, . . . , Xn, Y ]) → ∃Xi C1([X1, . . . , Xn])\nIn general, the negation of a contractible constraint and implication between two contractible constraints are not contractible. See Example 2, later.\nThe previous results give us an algebra for constructing complex contractible constraints, and can be used to demonstrate that some existing constraints are contractible. For example, Contiguity is implemented in (Maher 2002) essentially as\n∃~L, ~R SLIDE23(C ′, [L1, X1, R1, L2, . . . , Xn, Rn])\nwhere C′ has arity 7. Similarly, ( ~X ≤lex ~Y ) is encoded in (Bessiere et al. 2008) essentially as\n∃ ~B SLIDE3(C ′, [B1, X1, Y1, B2, . . . , Xn, Yn])\nwhere C′ has arity 4. By the previous propositions, Contiguity and ≤lex are contractible. Similarly, we can define a weak version of GCC where there are no lower bounds GCC(~v,~0, ~u, [X1, . . . , Xn]) as ∧\nvi∈~v Splash(C′i, ~X), where C ′ i has arity ui + 1 and states\nthat not all its arguments are equal to vi. By the previous propositions, this weak form of GCC is contractible.\nHowever, it is notable that the Regular constraint is not contractible, despite the implementation in terms of Slide outlined in (Bessiere et al. 2008).\nExample 1 Let A be an automaton that accepts the language a + b2. Then Regular(A, [X1]) → X1 = a but Regular(A, [X1, Y ]) → X1 = b. Thus Regular is not contractible.\nThe discrepancy arises because Regular is not constructed from the operations in the above propositions. Essentially, the implementation defines\nRegular(A, [X1, . . . , Xn]) ↔\n∃ ~Q Slide2(Transition, [Q0, X1, Q1, . . . , Xn, Qn]) ∧ Start(Q0) ∧ Final(Qn)\nwhere the 3-ary constraint Transition expresses the state transitions of A, Start defines the start state(s) and Final defines the final state(s). It is the constraint on the final variable Qn that leads to uncontractibility; the remainder is expressible within the algebra.\nWe now make a simple observation that provides a useful characterization of contractible constraints. IfA defines a prefix-closed language thenRegular(A, ~X) is contractible. This claim holds more generally.\nProposition 7 Let C( ~X) be a constraint over a sequence of variables. Then C is contractible iff LC is prefix-closed."
    }, {
      "heading" : "Proof",
      "text" : "Suppose C is contractible. If σ is a solution of C([X1, . . . , Xn, Y ]) then, by contractibility, the restriction of σ to X1 . . . Xn is a solution of C([X1, . . . , Xn]). Thus the set of solutions is prefix-closed.\nSuppose S is prefix-closed. For any solution σ of C([X1, . . . , Xn, Y ]) we know that the restriction of σ to X1 . . . Xn is a solution of C([X1, . . . , Xn]). Since this holds for any solution σ, we have C([X1, . . . , Xn, Y ]) → C([X1, . . . , Xn]), that is, C is contractible.\nThis result applies to constraints based on formal languages, such as Regular and CFG, but it also applies to constraints that are formulated differently. Thus, for example, the solutions of Sequence and AllDifferent are prefix-closed. Conversely, we see that constraining the final variable in a sequence, as in Final(Qn), is not contractible.\nThis characterization allows us to substantiate the claim, made earlier, that in general the negation or implication of contractible constraints is not contractible.\nExample 2 Suppose we have an alphabet {a, b}. If LC is a\n∗ then L¬C contains aab, but not its prefix aa. Hence ¬C is not contractible. Hence, also, C → false is not contractible that is, implication of contractible constraints is not, in general, contractible. To take another example, if LC1 is a ∗b∗a∗ and LC2 is a ∗b∗ then LC1→C2 contains bab (since bab /∈ LC1), but not its prefix ba (since ba ∈ LC1 but ba /∈ LC2). Hence C1 → C2 is not contractible.\nWe can use the prefix-closed characterization both to determine whether a constraint is contractible or not, and as the basis for approximations of uncontractible constraints. We explore these possibilities in the following sections."
    }, {
      "heading" : "5 Classifying Constraints",
      "text" : "It is not within the scope of this paper to determine the contractibility of every global constraint. Nevertheless, we can outline and demonstrate some principles that make it easy, in most cases, to classify a global constraint as contractible or not.\nIn general, constraints based on counting with a lower bound (or equality) are not contractible. We can see this by noting that any non-trivial lower bound on the number of things in a sequence (or satisfied by a sequence) may be violated by a prefix of the sequence. This was already touched upon in (Barták 2003), where the Sum constraint∑n\ni=1 Xi = N was shown to be non-monotonic, but the argument holds for a wide range of constraints.\nFor example, Peak counts the number of peaks in a sequence, but a prefix of the sequence may have fewer peaks. Similarly, Stretch places lower bounds on the span of stretches, so that 1122 might be a solution, while 112 is not. By a similar argument, constraints identifying properties of an extreme element in a sequence, such as HighestPeak, are not contractible. On the other hand NoPeak is contractible since, to the extent that there is counting, there is no lower bound – only an upper bound of 0.\nWe can generalize and formalize these observations. A function f is a non-decreasing accumulation function if it maps sequences of values to numbers such that, for every sequence ~X and value Y , f( ~XY ) ≥ f( ~X). We can similarly define the non-increasing functions. Among non-decreasing accumulation functions are counting the number of elements in a sequence with a fixed property, counting the number of different elements, identifying the highest peaks, and summing (some) non-negative elements of a sequence. Note that summing possibly negative elements of a sequence is not non-decreasing. The first part of the following proposition is an almost direct consequence of the definitions of contractibility and non-decreasing function.\nProposition 8 Let C be a global constraint.\n• Suppose C can be expressed as f( ~X) ≤ Z. Then C is contractible iff f is a nondecreasing accumulation function. • Suppose C can be expressed as f( ~X) ≥ Z. Then C is contractible iff f is a nonincreasing accumulation function. • Suppose C can be expressed as f( ~X) = Z. Then C is contractible iff f is a constant function."
    }, {
      "heading" : "Proof",
      "text" : "If f is a non-decreasing accumulation function, whenever f( ~XY ) ≤ Z we must have f( ~X) ≤ Z. Thus C( ~XY ) → C( ~X).\nIf f is a not a non-decreasing accumulation function, there is a sequence of values ~X and a value Y such that f( ~XY ) < f( ~X). Choose Z such that f( ~XY ) ≥ Z > f( ~X). Then C( ~XY ) holds but C( ~X) does not. Thus C is not contractible.\nThe proof of the second and third parts is similar. Thus the constraints ∑n i=1 Xi = N and ∑n\ni=1 |Xi| = N are not contractible. Similarly,∑n i=1 Xi ≥ N is not contractible while ∑n i=1 |Xi| ≤ N is contractible. This result can be used to establish that Peak, and HighestPeak are not contractible and that NoPeak is contractible, but it also applies to many other counting and summing constraints in (Beldiceanu et al. 2005).\nNotice that in constraints like Sequence and SlidingSum the use of a lower bound in the description of the constraint C′ to which Slide is applied does not prevent contractibility. Each lower bound applies only to a small part of the sequence. However, the RelaxedSlidingSum constraint, which weakens the SlidingSum constraint by putting bounds on the number of times the C′ constraint is satisfied, is not contractible, because counting is an accumulation function that is not non-increasing and the lower bound applies to the entire sequence.\nSome constraints can be recognised as contractible, based only on their informal semantics. For example, Diffn and Disjunctive enforce that objects represented by the variables are non-overlapping. Clearly, if ~XY forms a non-overlapping set, then so does ~X alone. Thus contractibility follows directly from Definition 2. Similarly, Cumulative4, BinPacking and Disjoint are contractible.\n4 Under the assumption that activities can only consume resources (and not produce resources).\nFor other constraints, their informal semantics lead easily to counterexamples to contractibility. Constraints that involve computing the minimum, maximum, mean/average, median, mode, standard deviation, etc of the sequence are not contractible. This is easily recognised since these statistics are not, in general, preserved after eliminating part of the sample set, and hence are not prefix-closed. Alternatively, we could recognise that these functions are not non-increasing, nor non-decreasing and apply Proposition 8.\nThe idea of contractibility is not useful for all global constraints. For example, it appears irrelevant to cyclic constraints like the cyclic Regular, cyclic Sequence and cyclic Stretch constraints. In these constraints the sequence of variables is representing a cycle or circular list and there is no natural end at which to add variables. Thus it is not surprising that these constraints are not contractible.\nThere is sometimes a fine line between contractible and uncontractible constraints. For example, while≤lex is contractible, <lex is not. To see the latter, observe that 111 <lex 112, but the corresponding prefixes are not strictly smaller – they are equal. If the precedence constraint s ≺ ~X t also required that t appear in\n~X , then the constraint would not be contractible (because rst satisfies this constraint, but rs does not). Finally, notice that the Sequence constraint is contractible, but it has the form Slide(C′, ~X) where C′ is essentially a fixed-arity Among constraint; however, the (variable-arity) Among constraint is not contractible.\nA quick survey of (Beldiceanu et al. 2005) suggests that most current global constraints are not contractible, although we have noted several useful constraints that are contractible. In the next section we address how to propagate uncontractible open constraints."
    }, {
      "heading" : "6 Approximating Constraints",
      "text" : "When a constraint is not contractible, the closed propagator for that constraint is unsound as a propagator for the open constraint. However, following a proposal of (Barták 2003), we can implement an uncontractible open constraint C( ~X) by executing a safe contractible approximation Capp of C until ~X is closed, and then replacing Capp by C for the remainder of the execution. To employ this approach we need to identify a contractible language containing the language of C, and a propagator Capp that implements it.\nA language L is an approximation of a constraint C if LC ⊆ L. An approximation L is contractible iff L is prefix-closed. A contractible approximation La to a language L is tight if for all contractible languages L′, if La ⊇ L\n′ ⊇ L then L′ = La. By Proposition 7, there is a unique contractible approximation that is tighter than all others: the prefix-closure of LC gives the tightest contractible approximation. 5\nThe prefix-closure P (L) of a language L often appears to be simpler than L. For ex-\nample, if L1 is {a n2 | n ∈ N} then P (L1) is a ∗. But in general the prefix-closure is no simpler than the original language. For example, if L2 is {a n2b | n ∈ N} then P (L2) is a∗ ∪ L2. In some cases it is easy to represent P (L) when given a representation of L. In particular, when L is defined by a finite automaton the automaton accepting P (L) is easily computed.\nProposition 9 Let A be a (possibly nondeterministic) finite state automaton, and let A′ be the finite state automaton obtained from A by making final all states on a path from the start state to a final state. Then L(A′) = P (L(A)). A′ can be computed in linear time.\n5 Consequently, tight and tightest contractible approximations are synonyms."
    }, {
      "heading" : "Proof",
      "text" : "Consider any prefix w of a word wu ∈ L(A). wu describes a path in A that ends at a final state. Hence w describes a path in A that ends at a state on a path to a final state. Hence w is accepted by A′. Thus L(A′) ⊇ P (L(A)).\nConversely, suppose w is accepted by A′. By the construction of A′, w describes a path in A that ends at a state Q on a path to a final state of A. Let u be a word corresponding to a path from Q to a final state. Then wu is accepted by A and hence w is a prefix of a word in L(A). Thus L(A′) ⊆ P (L(A)).\nWe can construct A′ as follows. Treat the automaton A as a directed graph with the states as vertices and where each transition from Q1 to Q2 is represented by an edge from Q1 to Q2. Perform depth-first search and mark all states reachable from the start state. Now consider the graph with the edges reversed. Perform depth-first search from the reachable final states, marking each visited reachable state as a final state. A′ is the automata A with these additional final states. The cost of the construction is O(V +E), where V is the number of states and E is the number of transitions. (Note that we could ignore reachability and define a variation of A′ that may have some unreachable final states.)\nSimilarly, we can use the structure of a context-free grammar to construct a grammar for its prefix-closure.\nProposition 10 Given a context-free grammar G defining a language L, a context-free grammar G′ for P (L) can be generated in quadratic time, and in linear time if G is in Chomsky normal form."
    }, {
      "heading" : "Proof",
      "text" : "(Sketch) We show only the construction when G is presented in Chomsky normal form, and leave the generalization to arbitrary grammars and the verification of its correctness to the reader.\nLet G = (N,T,R, S), where N is a set of nonterminal symbols, T is a set of terminal symbols, R is the set of production rules, and S is the start symbol. In Chomsky normal form, production rules have the form A → BC or A → a or S → ε where A, B, and C are nonterminal symbols, a is a terminal symbol, and ε is the empty word. We define G′ = (N ′, T, R′, S′), where N ′ = N ∪ {S′} ∪ {Ap | A ∈ N} and\nR′ = R ∪ {S′ → ε} ∪ {S′ → Sp} ∪ {Ap → a | (A → a) ∈ R} ∪ {Ap → Bp | (A → BC) ∈ R} ∪ {Ap → BCp | (A → BC) ∈ R}\nFor each nonterminal A ∈ N , Ap generates all non-empty prefixes of words generated by A, including the words generated by A. It is clear that G′ is larger than G by a factor of 3 or less. For an arbitrarily structured grammar, the size of G′ can grow quadratically.\nR′ is not in Chomsky normal form, but it is easily simplified to that form. Nonterminals Ap which are strongly connected by edges corresponding to productions of the form X → Y can be replaced by a single equivalent nonterminal, to give R′′. Remaining productions X → Y can be replaced by a set of productions {X → ψ | (Y → ψ) ∈ R′′}. In general, repeated replacements are necessary to eliminate all X → Y productions. A naive representation can increase the size of the grammar, but a more careful representation can share the right-hand side of productions so that the Chomsky normal form is not larger than G′.\nThus, the tightest contractible approximation of Regular(A, ~X,N) is implemented by Regular(A′, ~X,N), and the tightest contractible approximation of CFG(G, ~X,N) is implemented by CFG(G′, ~X,N).\nAs a corollary to Proposition 9, we can check in linear time whether a language defined by a deterministic finite automaton is prefix-closed: we simply check whether the construction of A′ in Proposition 9 made any new final states. This improves on a result of (Brzozowski et al. 2009). Unfortunately, recognising when a language defined by a nondeterministic finite automaton A is prefix-closed is not so simple; A need not have the property that all states on a path from start to final state are final. It is shown in (Brzozowski et al. 2009) that this problem is PSPACE-complete. The problem is undecidable for languages defined by context-free grammars (Brzozowski et al. 2009). However, the decision problem is much less important than the ability to construct (the representation of) the prefix-closure, so these negative results are not significant.\nRegular and CFG are complicated by flexible parameters, but approximations to simpler constraints are often correspondingly simpler to recognise. As discussed in (Barták 2003), a constraint ∑n i=1 Xi = N where the Xi’s must be non-negative is not monotonic but is\napproximated by the constraint ∑n\ni=1 Xi ≤ N . Using Proposition 8 we can recognise this as the tightest contractible approximation. Similarly, for a counting constraint such as Peak( ~X,N), which states that there are exactly N peaks in ~X , the tightest contractible approximation states that N is an upper bound on the number of peaks. In the same way, NValue( ~X,N) is best approximated by treating N only as an upper bound. The tightest approximation of the GCC is the weak form of GCC discussed in Section 4. In all these cases, since counting is a non-decreasing accumulation function, the tightest contractible approximation is to eliminate the lower bounds. In HighestPeak( ~X,Z), the height of the highest peak is a non-decreasing accumulation function and so the tightest approximation states that Z is an upper bound on the height of the highest peak.\nOn the other hand, for some constraints where the accumulation function is neither non-increasing nor non-decreasing there appear to be no non-trivial approximations. For example, consider a constraint Average( ~X,M) stating that M is the mean/average of the values of ~X . Given a fixed M , any sequence of values can be a prefix of a sequence with mean M . Hence the tightest contractible approximation of Average is the constraint that accepts any sequence, that is, the constraint true. For such a constraint there is no propagation until the constraint is closed.\nHowever, as the previous discussion shows, for many constraints the tightest contractible approximation is not only non-trivial, it has a clear and simple expression. For these constraints a propagator for the approximation Capp is almost ready-made, given a propagator for the original constraint C. Furthermore, the transition of propagator from Capp to C when the constraint closes can be smooth and simple because, in the cases above, the propagator for Capp is simply a weakened form of the propagator for C. Some more detailed analysis of this similarity of propagators for C and Capp, for several constraints C, appears in (Maher 2009c) and (for a slightly different model of open constraint) (Maher 2009b).\nIf we have domain consistent closed propagators and a tight contractible approximation, then we can obtain an open D-consistent propagator from Barták’s proposal. Recall that under Barták’s proposal (Barták 2003), a closed propagator for Capp is dynamised to handle extensions of the sequence of variables (possibly through his generic dynamisation). This propagator is then executed until the sequence of variables is closed, at which point the propagator is replaced by a closed propagator for C.\nTheorem 11 Let Capp be the tightest contractible approximation to C, and suppose we have closed propagators for Capp and C that maintain domain consistency for ~X. Then Barták’s proposal maintains open D-consistency for C."
    }, {
      "heading" : "Proof",
      "text" : "Since Capp is contractible, domain consistency of Capp for ~X is equivalent to open Dconsistency on C( ~X). This follows because Capp is the prefix-closure of C and so every\nsupport for domain consistency of Capp( ~X) for ~X corresponds to a longer word that is a support for D-consistency on C( ~X), and vice versa every support for open D-consistency on C( ~X) has a corresponding prefix that is a support for domain consistency of Capp( ~X) for ~X. Once ~X is closed, domain consistency for ~X is identical to D-consistency on C( ~X).\nWe can obtain similar results for consistency conditions other than domain consistency. All that is required is to define the appropriate corresponding open consistency. For example, consider bounds consistency. Let min(X) (max(X)) denote the smallest (largest) value in D(X). The appropriate form of bounds consistency for open constraints is open B-consistency.\nDefinition 4 Given a domain D, an occurrence of a constraint C( ~X) is open B-consistent if\nfor every Xi ∈ ~X , and for di = min(Xi) and di = max(Xi), there is a word d1 . . . dm in LC such that | ~X | ≤ m, and dj ∈ min(Xi)..max(Xi) for j = 1, . . . , | ~X|.\nWe can now express the corresponding result for bounds consistency. The proof is essentially the same as that for the previous theorem.\nCorollary 12 Let Capp be the tightest contractible approximation to C, and suppose we have closed propagators for Capp and C that maintain bounds consistency for ~X. Then Barták’s proposal maintains open B-consistency for C.\nNotice that we still require a tightest contractible approximation. Any weakening of this requirement can lose open B-consistency, as is clear from Corollary 2."
    }, {
      "heading" : "7 Contractibility of Soft Constraints",
      "text" : "We consider “soft” global constraints in the style of (Petit et al. 2001). In such constraints there is a violation measure6, which measures the degree to which an assignment to the variables violates the associated “hard” constraint, and solutions are assignments that satisfy an upper bound on the violation measure. Thus such soft constraints have the form m( ~X) ≤ Z, where m is the violation measure. We refer to the hard constraint as C( ~X) and the corresponding soft constraint as Cs( ~X,Z).\nAssessing the contractability of such constraints is made easier by Proposition 8, which says that a constraint m( ~X) ≤ Z is contractible iff m is non-decreasing. Given this characterization, we will refer to non-decreasing accumulation functions as contractible functions. To evaluate whether or not soft constraints are contractible we must consider the form of the violation measure, and whether it forms a contractible function.\nDefinition 5 A violation measure for a sublanguage L of a language L′ is a function m which maps L′ to the non-negative real numbers, such that if w ∈ L then m(w) = 0. m is proper for L if for all words w ∈ L′, m(w) = 0 iff w ∈ L. A violation measure for a constraint C( ~X) is a violation measure for LC as a sublanguage of the static type T ( ~X).\nFor example, a use of AllDifferent might give the set Z of integers as the static type of each variable. A violation measure might then be the number of disequalities Xi 6= Xj , i 6= j violated by a valuation for ~X, or the number of variables equal to another variable under the valuation, or the minimum absolute value of the sum over i of values\n6 Also called violation cost (Petit et al. 2001).\nci such that, for each i and j with i 6= j, Xi + ci 6= Xj + cj . 7 It is easy to see that each of these defines a violation measure. The third is not a proper violation measure because, for example, the word 11233 can have perturbations ci of 0,−1, 0, 0, 1. Thus m(11233) = 0 but 11233 6∈ LC . (Summing the absolute value of the ci, on the other hand, would lead to a proper measure.)\nProper violation measures for a language L are a refinement of the characteristic function of L.8 Most violation measures in the literature are proper for their intended language. Although any function from words to non-negative reals can be considered a proper violation measure by appropriate choice of language L, in practice the hard constraint determines L and the violation measure is then designed to be proper. A non-proper measure can be considered misleading because a word w that violates the language L can have a violation measure of 0. We admit non-proper violation measures mainly because contractible approximations considered in Section 8 can be non-proper. However, we make some effort in this section to identify proper violation measures.\nThere are three broad classes of violation measures (Maher 2009d): those based on constraint decomposition, edit distance, and graph properties. We address the first two classes in the following subsections. The richness of the graph property framework (Beldiceanu and Petit 2004) makes it difficult to obtain broad results on contractibility. A somewhat narrow sufficient condition for contractability of soft constraints defined by graph property-based violation measures is presented in (Maher 2009d). For each of the classes we consider, we will incorporate a weighting that adds greater flexibility and expressiveness to the class."
    }, {
      "heading" : "7.1 Decomposition-based Violation Measures",
      "text" : "Many hard constraints can be decomposed into elementary constraints, whether naturally (such as the decomposition of AllDifferent into disequalities) or by a construction, as in (Bessiere et al. 2009). Violation measures can be constructed by combining the violations of each elementary constraint. We define a general class of decompositionbased violation measures that includes as special cases: primal graph based violation costs (Petit et al. 2001), decomposition-based violation measures of (van Hoeve et al. 2006), the value-based violation measure for GCC (Petit et al. 2001; van Hoeve et al. 2006), the measures used for the soft Sequence constraint (Maher et al. 2008) and the soft Cumulative constraint (Petit and Poder 2009), the weighted measures for AllDifferent and GCC (Métivier et al. 2007; Métivier et al. 2009), and the class of decomposition-based measures discussed in (Maher 2009d). We begin with several definitions.\nA weighted set is a pair (S,w) where S is a set and w is a function mapping each element of S to a non-negative real number or ∞. Values not in S have weight 0. If these are the only values of weight 0 we say (S,w) is proper. A weighted set is a minor generalization of a multiset. A weighted set (S1, w1) is a sub-weighted set of weighted set (S2, w2) if, for every element s ∈ S1, w1(s) ≤ w2(s). Union of weighted sets is defined by (S1, w1) ∪ (S2, w2) = (S1 ∪ S2, w1 + w2) where (w1 + w2)(x) = w1(x) + w2(x). When a weighted set contains things with variables that are subject to substitution, the application of a substitution might unify elements of the set. Hence, (S,w)θ denotes (Sθ, w′) where w′(s) is the sum of w1(s\n′) over all s′ ∈ S such that s′θ ≡ s. We need to carefully formalize the notion of decomposition. The definition takes as a"
    }, {
      "heading" : "7 This latter measure expresses the smallest perturbation ~c of the values for the variables needed",
      "text" : "to satisfy the AllDifferent constraint. More formally, m( ~X) = min~c{| ∑n\ni=1 ci| | ∀j j 6= i → Xi + ci 6= Xj + cj}. 8 Indeed, for any proper violation measure m, the corresponding hard constraint can be recovered\nas m( ~X) ≤ 0.\nparameter a class of elementary constraints. Usually the constraints in such a class have bounded arity.\nDefinition 6 A decomposition is a function that maps a constraint C with a given type T and a sequence of variables ~X to a tuple ( ~X, ~U, T ′, S, w) where ~U is a collection of new variables, T ′ is an extension of T to ~U , and (S,w) is a proper weighted set of elementary constraints over ~X~U such that C( ~X) ↔ ∃~U T ′(~U) ∧ ∧ s∈S s.\nThe weights in this definition are used only to emphasize some constraints in a decomposition over others; in particular, the infinite weight allows us to specify elementary constraints that must not be violated. An unweighted decomposition is one where all constraints in S have the same, non-zero weight. In that case, we may omit w. We write decomp(C( ~X)) to express the weighted set (S,w), or simply S when the decomposition is unweighted.\nThis definition of decomposition is very broad, perhaps too broad, since it allows the set of elementary constraints and/or their weights to vary radically as the length of ~X changes. For example, it permits using the decomposition of AllDifferent( ~X) into disequalities when | ~X| is odd, and a decomposition from (Bessiere et al. 2009) (see Example 6) when | ~X| is even. However, we will see in Example 5 a constraint whose expression requires some of the flexibility offered by this broad definition.\nAn error function e maps an elementary constraint and a valuation to a non-negative real number, representing the amount of error (or violation) of the constraint by the valuation. We require that e(v, c) = 0 iff c is satisfied by v. We extend e to weighted sets of constraints by defining e(v, (S,w)) = (S′, w′) where S′ = {e(v, s) | s ∈ S} and w′(x) = ∑ s|v(s)=x w(s).\nA combining function maps a weighted set of numbers to a single number. A combining function comb is monotonic if, whenever (S1, w1) is a sub-weighted set of (S2, w2), comb(S1, w1) ≤ comb(S2, w2). The function comb is disjunctive if for all weighted sets of reals (S,w), comb(S,w) = 0 iff S = {0}. We say comb has unit 0 if, for every (S,w) and w′, comb((S,w) ∪ ({0}, w′)) = comb(S,w). Counting non-zero values, summation, sum of squares, and maximization are examples of monotonic, disjunctive combining functions with unit 0; product and minimization are neither monotonic nor disjunctive nor have unit 0.\nDefinition 7 A decomposition-based violation measure m for a constraint C( ~X) with type T is based on a decomposition ( ~X, ~U, T ′, S, w) of C( ~X), an error function e, and a combining function comb and is defined by, for each valuation v of ~X,\nm(v( ~X)) = min v′ comb(e(v′,decomp(C( ~X))))\nwhere we minimize over all extensions v′ of v to ~U that satisfy T ′.\nThis definition was inspired by the formulation of hierarchical constraints in (Borning et al. 1992; Borning et al. 1989). The violation counting decomposition measures of (Petit et al. 2001; van Hoeve et al. 2006) can be obtained when the error function e(v, c) returns 0 if v satisfies c and 1 otherwise, and the combining function is summation. The value-based measures of (Petit et al. 2001; van Hoeve et al. 2006; Maher et al. 2008; Petit and Poder 2009) also use summation as the combining function, but use an error function that returns the amount by which the constraint c is violated by the valuation v. If we use maximization or the sum of squares in place of summation we have new violation measures similar to the worst-case-better and least-squares-better comparators of (Borning et al. 1992; Borning et al. 1989). Clearly many violation measures are available for a constraint by making different choices for the decomposition and the error and combining functions.\nThere is a powerful sufficient condition for a decomposition-based violation measure to be proper.\nProposition 13 Let m be a decomposition-based violation measure for a constraint C, as defined in Definition 7 with combining function comb. m is proper for LC if comb is disjunctive."
    }, {
      "heading" : "Proof",
      "text" : "Let v be a valuation for ~X. Suppose comb is disjunctive. m(v( ~X)) = 0 iff minv′ comb(e(v\n′,decomp(C( ~X)))) = 0 iff for some v′ extending v, comb(e(v′,decomp(C( ~X)))) = 0 iff for some v′ extending v, and some w, e(v′,decomp(C( ~X))) = ({0}, w) iff for some v′ extending v, v′ satisfies every c ∈ decomp(C( ~X)) iff v satisfies C( ~X) iff v( ~X) ∈ LC .\nThus, for any valuation v, m(v( ~X)) = 0 iff v( ~X) ∈ LC . Hence, m is proper for LC .\nWe now turn to the problem of recognizing contractibility. We say that one formula ( ~X, ~U, T1, S1, w1) is covered by another formula ( ~W, ~V , T2, S2, w2) if there is a substitution θ that maps ~X into ~W and ~U into ~V ∪ ~W ∪ Σ, where Σ is a set of constants, such that T1( ~X) = T2( ~Xθ), (S1, w1)θ is a sub-weighted set of (S2, w2) and T2(~Uθ) ⊆ T1(~U). Covering has some similarity to characterizations of containment of conjunctive relational database queries (Chandra and Merlin 1977), (constraint) logic programming rule subsumption (Maher 1988; Maher 1993), and sufficient conditions for query containment under bag semantics (Chaudhuri and Vardi 1993; Ioannidis and Ramakrishnan 1995).\nExample 3 The decomposition of AllDifferent( ~X) into an unweighted set of disequalities is formalized as ( ~X, ∅, T, S, w) where S is the set of disequalities and w gives every disequality a weight of 1. It is clear that the decomposition of AllDifferent( ~X) is covered by that of AllDifferent( ~XY ) where the substitution is the identity.\nExample 4 Contiguity is implemented in (Maher 2002) essentially by the decomposition\nContiguity( ~X) ↔ ∃~L, ~R n−1∧\ni=2\nC′(Xi−1, Ri−1, Li, Xi, Ri, Li+1, Xi+1)\nfor a constraint C′. This decomposition is formalized as ( ~X, ~L~R, T, S,w) where T gives all variables a type of {0, 1}, S is the set of C′ constraints, and w gives every constraint a weight of 1. Alternatively, if contiguity is more important for variables nearer the right end of the sequence ~X , we might weight each C′ constraint by the largest index of a variable appearing in it. The decomposition of Contiguity( ~XY ) covers that of Contiguity( ~X) where the substitution is the identity on ~X , ~L, and ~R.\nWe can now provide a sufficient condition for a soft constraint with a decompositionbased violation measure to be contractible.\nProposition 14 Let Cs be a soft constraint with a decomposition-based violation measure defined using a monotonic combining function. Let ( ~X, ~U, T1, S1, w1) be the decomposition of C( ~X) and ( ~XY, ~V , T2, S2, w2) be the decomposition of C( ~XY ). If ( ~X, ~U, T1, S1, w1) is covered by ( ~XY, ~V , T2, S2, w2) via a substitution that is the identity on ~X then Cs is contractible."
    }, {
      "heading" : "Proof",
      "text" : "By the covering condition, there is a substitution θ that is the identity on ~X and maps ~U to ~V ∪ ~XY ∪Σ such that (S1, w1)θ is a sub-weighted set of (S2, w2). Consider any assignment v to ~XY ∪ ~V . Then v ◦ θ is an assignment9 to ~X ∪ ~U . Furthermore, v((S1, w1)θ) is a subweighted set of v(S2, w2) and hence e(v◦θ, (S1, w1)) = e(v, (S1, w1)θ) is a sub-weighted set of e(v, (S2, w2)). Consequently, since the combining function comb is monotonic, comb(e(v◦ θ, (S1, w1))) ≤ comb(e(v, (S2, w2))). It follows that m(v( ~X)) ≤ m(v( ~XY )). Thus, since v is arbitrary, m is non-decreasing and, by Proposition 8, Cs is contractible.\nIt follows that the constraints in Examples 3 and 4 are contractible. More generally, if an unweighted decomposition is defined via part of the algebra discussed in Section 4 (that is, using Slide or Splash meta-constraints, constraints on a fixed finite prefix of the variable sequence, conjunction and existential quantification) and a monotonic combining function then Proposition 14 is sufficient to establish contractibility. However, covering is not a necessary condition for contractibility, as the following example demonstrates.\nExample 5 Consider the definition of a rising sawtooth relation rs on variables ~X. In such a relation, the subsequence of values in even numbered positions forms a non-decreasing sequence, and every value in odd numbered positions is greater than or equal to its immediately adjacent neighbours. 10 This relation can be decomposed into elementary constraints as follows. The decomposition is defined recursively, but notably requires two recursive cases, corresponding to the distinction between odd and even length sequences.\ndecomp(rs([])) = true decomp(rs([X1])) = true decomp(rs([X1, X2])) = X1 ≥ X2 decomp(rs([X1, . . . , X2n, X2n+1])) = decomp(rs([X1, . . . , X2n])) ∧X2n+1 ≥ X2n decomp(rs([X1, . . . , X2n, X2n+1, X2n+2])) =\ndecomp(rs([X1, . . . , X2n])) ∧X2n+1 ≥ X2n+2 ∧X2n+2 ≥ X2n\nConsider the soft constraint derived from this decomposition by counting the number of violations. It is clear that the sufficient condition of Proposition 14 does not apply because there is no covering. Nevertheless, we can verify that a decomposition-based soft rs constraint is contractible. Note first that when ~X has even length decomp(rs( ~X)) ⊆ decomp(rs( ~XY )) and consequently the violation measure is non-decreasing in this case. When ~X has odd length the relationship is less obvious. However, we know that\n(X2n+1 ≥ X2n+2) ∧ (X2n+2 ≥ X2n) → (X2n+1 ≥ X2n)\nand its contrapositive\n¬(X2n+1 ≥ X2n) → ¬(X2n+1 ≥ X2n+2) ∨ ¬(X2n+2 ≥ X2n)\nHence, any valuation for the variables that gives rise to a violation ofX2n+1 ≥ X2n will also give rise to a violation of X2n+1 ≥ X2n+2, or X2n+2 ≥ X2n, or both. Thus the violation measure is non-decreasing in this case also. Since the violation measure is non-decreasing, the decomposition-based soft rs constraint is contractible.\nSimilarly, the violation measures derived from summing the amount of violation or taking the maximum amount of violation of any elementary constraint lead to contractible soft rs constraints.\n9 We define (v ◦ θ)(x) = v(xθ) for any term x. 10 This is an artificial constraint, designed to demonstrate the point. However, the pricing of\ngoods with volume discounts can have a similar rising sawtooth behaviour.\nThis example demonstrates a major limitation of the sufficient condition in Proposition 14: it addresses only the syntactic structure of the decomposition. However some constraints, such as rs, require reasoning about the semantics of the elementary constraints in order to recognise that the decomposition-based soft constraint is contractible. (For rs we exploited the knowledge that ≥ forms a total order.)\nA second example is given by a decomposition ofAllDifferent given in (Bessiere et al. 2009).\nExample 6 Consider the AllDifferent constraint with type T that maps each Xi to 1..d, which we denote by AllDifferentT . To define the decomposition we need to introduce variables Ailu of type {0, 1} and constraints as follows.\nFor 1 ≤ i ≤ n and 1 ≤ l ≤ u ≤ d we have the constraints\nAilu = 1 ↔ Xi ∈ [l, u] (1)\nn∑\ni=1\nAilu ≤ u− l + 1 (2)\nThis decomposition is formalized as ( ~X, ~A, T ′, S, w) where T ′ extends T to the Ailu variables, S consists of the constraints (1) and (2) and w gives all constraints the same weight. It is easy to establish that AllDifferentT ( ~X) ↔ ∃ ~A ∈ T\n′( ~A) (1) ∧ (2). When ~X is extended by Y , the decomposition contains extra variables A(n+1)lu, extra constraints of type (1) involving Y and the new variables, and replaces constraints (2) by\nn+1∑\ni=1\nAilu ≤ u− l + 1 (3)\nNow, for each l and u, (3)∧(0 ≤ A(n+1)lu ≤ 1) → (2). Thus, every valuation that violates (2) will also violate (3). It follows that the soft constraint based on counting violations in this decomposition of AllDifferent is contractible. Similarly, soft constraints based on summing violation amounts or taking the maximum are also contractible, because∑n+1\ni=1 Ailu ≥ ∑n i=1 Ailu.\nOn the other hand, the decomposition of AllDifferent( ~XY ) cannot be a covering of the decomposition of AllDifferent( ~X), because each constraint (2) is not covered by the corresponding constraint (3). Thus, again, the sufficient condition of Proposition 14 cannot be used.\nTo redress the weakness of covering in addressing Examples 5 and 6 we need to incorporate knowledge of the semantics of the elementary constraints and, more generally, the error function. We begin with some definitions.\nA division of a weighted set (S,w) is a collection of sub-weighted sets (Si, wi) such that ∪i (Si, wi) = (S,w). When all Si are singleton sets we refer to this as division into singletons. Given a weighted set (S,w), we write wθ to denote the weight function of (S,w)θ.\nDefinition 8 A semantic embedding of ( ~X, ~U, T1, S, w) in ( ~XY, ~V , T2, S ′, w′) is a pair 〈φ, θ〉, where φ is a function and θ is a substitution, such that\n• θ is the identity on ~X and maps ~U into ~XY ∪ ~V ∪Σ, where Σ is a set of constants, such that T2(~Uθ) ⊆ T1(~U); • φ is an injective function from (S,w)θ to a division of (S′, w′); and • for every valuation v and every elementary constraint c ∈ Sθ, e(v, ({c}, wθ)) ≤\ncomb(e(v, φ(c))).\nIn a semantic embedding, the substitution θ shows how variables local to the first decomposition are represented in the second and the function φ shows how elementary constraints in the first decomposition are represented in the second. The third condition requires that these representations respect the semantics expressed by the error function e.\nCovering is essentially a syntactic form of semantic embedding: a semantic embedding where (S′, w′) is divided into singletons and any constraint cθ in Sθ is mapped to cθ in S′.\nWe are now in a position to state a much broader sufficient condition for contractibility than Proposition 14.\nTheorem 15 Let Cs be a soft constraint with a decomposition-based violation measurem defined using a monotonic combining function comb. Let ( ~X, ~U, T1, S1, w1) be the decomposition of C( ~X) and ( ~XY, ~V , T2, S2, w2) be the decomposition of C( ~XY ). Suppose there is a semantic embedding of (S1, w1) in (S2, w2). Then Cs is contractible."
    }, {
      "heading" : "Proof",
      "text" : "Consider the extension of ~X to ~XY and a valuation v on ~XY ~V . Let 〈φ, θ〉 be the semantic embedding. Then, for every elementary constraint c ∈ S1θ, e(v, ({c}, w1θ)) ≤ comb(e(v, φ(c))). Hence e(v◦θ, (S1, w1)) = e(v, (S1, w1)θ) = comb( ⋃ c∈S1θ\ne(v, ({c}, w1θ))) ≤ comb( ⋃ c∈S1θ\ne(v, φ(c))) ≤ comb(e(v, (S2, w2))). Since comb is monotonic, comb(e(v ◦θ, (S1, w1))) ≤ comb(e(v, (S2, w2))). It follows that minv comb(e(v, (S1, w1))) ≤ minv comb(e(v, (S2, w2))), and hencem(C( ~X)) ≤ m(C( ~XY )). Thus Cs is contractible.\nFor (unweighted) violation counting measures, the third condition of semantic embedding reduces to D |= (T2(~V ) ∧ φ(c)) → cθ, where D expresses some properties of the elementary constraints. Thus, for these measures, we can reason about contractibility using conventional logic. In Example 5, θ can be the identity substitution, since no additional variables are used in the decomposition, and φ maps (X2n+1 ≥ X2n) to (X2n+1 ≥ X2n+2)∧ (X2n+2 ≥ X2n). We know that (X2n+1 ≥ X2n+2)∧ (X2n+2 ≥ X2n) → (X2n+1 ≥ X2n) so, applying the previous theorem, a violation counting soft constraint of rs is contractible. In Example 6, using the natural choice of φ and θ (which maps variables Ailu in decomp(C( ~X)) to variables of the same name in decomp(C( ~XY )), constraints (1) to themselves, and constraints (2) to (3)), the validity of (3) ∧ (0 ≤ A(n+1)lu ≤ 1) → (2), and the previous theorem, we establish that the violation counting soft version of AllDifferent based on this decomposition is contractible.\nThere are two possible generalizations of the notion of semantic embedding that might be used to create a broader sufficient condition for contractibility. The first is to change the domain of φ from (S,w)θ to an arbitrary division of (S,w)θ. The current definition essentially only applies to the division of (S,w)θ into singletons {c}. This generalization would allow the embedding to hold for some grouping of constraints in the first decomposition, even when the individual constraints cannot be embedded in the second. A second possible generalization is to employ multiple pairs 〈φ, θ〉 with a disjunctive condition. Such a generalization has been shown necessary to characterize conjunctive query containment/rule subsumption when queries/rules involve pre-defined relations (i.e. constraints) (Klug 1988; Maher 1993). These generalizations are left for future research."
    }, {
      "heading" : "7.2 Edit-based Violation Measures",
      "text" : "The edit-based violation measures use a notion of edit distance, which is the minimum number of edit operations required to transform a word into a word of LC . There are many\npossible edit operations but the common ones are: to substitute one letter for another, to insert a letter, to delete a letter, and to transpose two adjacent letters.11 This class includes the variable-based violation measures (Petit et al. 2001; van Hoeve et al. 2006), since such measures are simply edit distances where substitution is the only edit operation. The object-based measures of (Beldiceanu and Petit 2004) are edit distances where deletion is the only edit operation. In (van Hoeve et al. 2006), an edit-based measure involving substitution, insertion and deletion is used.\nTo address a wide range of edit-based measures, we generalize the measures. We allow non-negative weights α, β, γ, δ for the edit operations substitution, insertion, deletion and transposition, respectively, and let ns, ni, nd, nt be the number of the respective operations used in an edit. Then we definemL(w) = minedits αns+βni+γnd+δnt to be the minimum, over all edits that transform w to an element of P (L), of the weighted sum of the edit operations. We refer to all measures of this form as edit-based. Measures based on a subset of the four edit operation can be captured by giving effectively infinite weights to the other operations.\nThe edit-based violation measures used for closed constraints are not appropriate for open constraints, because they fail to take into account that the current sequence of variables may be extended with more variables.\nFor example, consider an open constraint C where LC = abc+defghi and an occurrence of the constraint C([X1, X2, X3]). If X1 = d, X2 = e and X3 = f then the unweighted edit distance of this instance to LC is 3, even though this instance is completely accurate if the sequence of variables is extended. Similarly, if LC = abc and we have an occurrence C([X1, X2]) with X1 = a and X2 = b then the unweighted edit distance is 1, even though there is no violation.\nTo take account of the possibility that a sequence of variables may be extended, we employ the edit distance to P (LC), the prefix-closure of LC . In Section 6 the prefix-closure was used to approximate a constraint so that constraint propagation is sound when the constraint is open. The use of the prefix closure here is somewhat different from its use in that section: rather than using P (LC) as an approximation to LC , P (LC) is used here to formulate what it means to be an (edit-based) open soft constraint.\nDefinition 9 An open edit-based violation measure for a language L is an edit-based violation measure mP (L) for P (L). An open edit-based violation measure m for L is proper if m(w) = 0 iff w ∈ P (L). Since, in this paper, we only consider open edit-based measures they will simply be referred to as edit-based violation measures, except in the statement of theorems.\nAs a result of this definition, prefix-equivalent languages have the same possible editbased (proper) violation measures. When L is clear from the context, we simply write m rather than mL.\nWe can characterize when an open edit-based violation measure is proper. Roughly, m is improper iff some edits have zero cost and these are able to edit some w ∈ L′\\P (L) to w′ ∈ P (L).\nProposition 16 Let m be an open edit-based violation measure for L where P (L) is a sublanguage of L′, with weights α, β, γ and δ.\nm is proper iff one of the following conditions holds:\n• min{α, β, γ, δ} > 0 • α = 0, min{β, γ} > 0 and L′ ∩ SameLength(P (L)) ⊆ P (L)\n11 Edit distance based on counting these operations is known as Damerau-Levenshtein distance. Other well-known edit distances are defined using a subset of these operations.\n• β = 0, min{α, γ, δ} > 0 and L′ ∩ SubSeq(P (L)) ⊆ P (L) • γ = 0 and L′ ⊆ P (L) • δ = 0, min{α, β, γ} > 0 and L′ ∩ Perm(P (L)) ⊆ P (L) • α = β = 0, γ > 0 and L′ ⊆ Shorter(P (L)) • β = δ = 0, min{α, γ} > 0 and L′ ∩ Subset(P (L)) ⊆ P (L)\nwhere, for any language L, SameLength(L) is the set of all words of the same length as a word of L, Shorter(L) is the set of all words the same length or shorter than a word of L, Perm(L) is the set of all permutations of words of L, SubSeq(L) is the set of all subsequences of a word of L, and Subset(L) is set of all words whose letters form a submultiset of the letters of a word of L."
    }, {
      "heading" : "Proof",
      "text" : "Looking at the different constraints on the weights it is easy to see that the conditions are mutually exclusive and they cover all possible combinations of weights. Thus to prove the characterization it is sufficient to show, in each case, that m is proper iff the remaining condition in the case holds.\nIf min{α, β, γ, δ} > 0 then m(w) = 0 iff no edits are required to transform w to a word of P (L) iff w ∈ P (L). Thus, in this case, m is proper.\nLet α = 0, and min{β, γ} > 0. Then, for any word w ∈ L′, m(w) = 0 iff w can be edited by substitutions (and possibly transpositions if δ = 0) to a word of P (L) iff w is the same length as a word of P (L). From the definition of proper, m is proper iff P (L) ∩ L′ = SameLength(P (L))∩ L′, that is L′ ∩ SameLength(P (L)) ⊆ P (L).\nLet β = 0 and min{α, γ, δ} > 0. Then, for any word w ∈ L′, m(w) = 0 iff w can be edited by insertions to a word of P (L) iff w is a subsequence of a word of P (L). Hence m is proper iff P (L) ∩ L′ = Subseq(P (L)) ∩ L′.\nIf γ = 0 then for every word w ∈ L′, m(w) = 0 because w can be edited by deletions to the empty word, which is in P (L). Hence m is proper iff L′ = P (L)∩L′, that is L′ ⊆ P (L).\nLet δ = 0 and min{α, β, γ} > 0. Then, for any word w ∈ L′, m(w) = 0 iff w can be edited by transpositions to a word of P (L) iff w is a permutation of a word of P (L). Hence m is proper iff P (L) ∩ L′ = Perm(P (L))∩ L′.\nLet α = β = 0 and γ > 0. Then, for any word w ∈ L′, m(w) = 0 iff w can be edited by insertions and substitutions to a word of P (L) iff w can be obtained by deletions and substitutions from a word of P (L) iff w is shorter than a word of P (L). Hence m is proper iff P (L) ∩ L′ = Shorter(P (L)) ∩ L′.\nLet β = δ = 0 and min{α, γ} > 0. Then, for any word w ∈ L′, m(w) = 0 iff w can be edited by insertions and transpositions to a word of P (L) iff w can be obtained by deletions and transpositions from a word of P (L) iff the letters of w form a submultiset of the letters of a word of P (L). Hence m is proper iff P (L) ∩ L′ = Subset(P (L)) ∩ L′.\nBefore presenting the main result on contractibility of edit-based soft constraints we need to introduce some preliminary results on weighted edit distance.\nWe say a sequence of edit operations is in normal form if the edit operations are grouped by type so that all deletions are performed before all transpositions, which are performed before all substitutions, before all insertions, and no letter is subject to two or more substitutions. It is not difficult to show that any edit sequence has a corresponding sequence in normal form that achieves the same result at lower or equal cost.\nLemma 17 Consider a weighted edit-distance and a word ~a. For any edit sequence that maps ~a to ~b, there is an edit sequence in normal form that also maps ~a to ~b with a shorter or equal weighted edit distance.\nIt is straightforward to see that, for any edit sequence not involving transposition and any weighted edit measure, there is an equivalent edit sequence where each letter is edited at most once. Provided the edit weights satisfy a simple property, this result extends to edit sequences involving transposition.\nProposition 18 Consider an edit-based violation measure where β + γ ≤ 2δ. Suppose we wish to edit a word ~a so that it appears in a language L. Then there is an edit of minimal cost where no letter is subject to more than one edit operation."
    }, {
      "heading" : "Proof",
      "text" : "Suppose β+ γ ≤ 2δ and consider any edit sequence that maps ~a to ~b ∈ L. We can assume (Lemma 17) that edit operations are grouped: deletions, then transpositions, substitutions, and finally insertions.\nSuppose a letter a that participates in a transposition also participates in another edit operation. Then the second operation is either another transposition or a substitution.\nIn the former case, consider all transposition operations that are applied to a. The effect of these edits is to move a from some position i to a position j. This sequence can be replaced by the deletion of a at position i and the insertion of a at position j. The revised edit sequence has a lower or equal cost because β + γ ≤ 2δ and we assumed that at least two transpositions are involved.\nIn the latter case, aa′ is edited to a′a and later a is changed to b, for some a′ and b. We can achieve the same effect by substituting a′ for a and b for a instead of the transposition and substitution. The revised edit sequence has lower or equal cost if α ≤ δ. Alternatively, we can replace the original edit operations by the deletion of a and the insertion of b on the right of a′. This revised edit sequence has lower or equal cost if δ ≤ α, because β + γ ≤ 2δ ≤ α + δ. Thus, independent of whether α ≤ δ or δ ≤ α, a lower cost edit sequence is obtained with fewer instances of a letter involved in two edit operations.\nThe remaining possibility is that a substitution operation is applied twice to a letter. It is clear that the first substitution operation can be omitted.\nRepeatedly applying normal form transformations and the edit modifications described above, all occurrences of a letter being edited twice can be removed.\nIn particular, this lemma holds when the edit operations are unweighted (that is, when α = β = γ = δ). The property that each letter is edited at most once is important for network flow implementations of propagators such as the propagators for soft Regular in (van Hoeve et al. 2006; Maher 2009d).\nEdit-based violation measures are monotonic with respect to both the weights and the language.\nLemma 19 Letm (m′) be edit-based violation measures with weights α, β, γ, δ (respectively α′, β′, γ′, δ′) for the same language. If α ≤ α′, β ≤ β′, γ ≤ γ′ and δ ≤ δ′ then, for all words w, m(w) ≤ m′(w)."
    }, {
      "heading" : "Proof",
      "text" : "For every word w, consider an edit that achieves the minimum violation m′(w). Let ns, ni, nd, nt be the number of the respective operations used in the edit. Then m\n′(w) = α′ns + β ′ni + γ ′nd + δ ′nt ≥ αns + βni + γnd + δnt ≥ m(w). Hence m(w) ≤ m ′(w).\nLemma 20 Let m1 and m2 be edit-based violation measures with the same weights, for languages L1 and L2 respectively. If L1 ⊆ L2 then for all words w, m1(w) ≥ m2(w)."
    }, {
      "heading" : "Proof",
      "text" : "For every word w, any edit to L1 is also an edit to L2. Since an edit-based violation measure minimizes over all edits, we must have m1(w) ≥ m2(w).\nIn many cases, edit-based violation measures lead to contractible soft constraints.\nTheorem 21 Let Cs be a soft constraint with an open edit-based violation measure, and suppose min{α, β, γ} ≤ δ.\nThen Cs is contractible."
    }, {
      "heading" : "Proof",
      "text" : "Consider the sequence of edits that transforms an instance ~aa′ of ~XY into an element ~b of P (LC) at minimum cost. By Lemma 17 we can assume that all deletions occur before any transpositions, and all insertions and substitutions occur after all transpositions. We now identify modifications of this sequence of edits that transform ~a into an element of P (LC) at lower (or equal) cost than the original sequence.\nIf a′ is deleted in the original sequence, then the sequence of edits omitting this deletion transforms ~a to ~b at lower or equal cost. Otherwise, if a′ is not involved in a transposition, then the subsequence of edits that do not involve a′ transforms ~a into a prefix of ~b (which is an element of P (LC)). The subsequence has a lower or equal cost, since it involves a subset of the edits.\nThe remaining possibility is that a′ is involved in a transposition. Let p be the position of a′ after all transpositions. The sequence of edits that omits all transpositions involving a′ and then inserts a′ at position p transforms ~a to ~b. These edits have a lower or equal cost if β ≤ δ.\nAlternatively, let the length of ~aa′ after all deletions be n+ 1 (so that a′ is in position n+1). Every transposition involving position n+1 in the original sequence can be replaced by a substitution that replaces the letter at position n by the letter at position n + 1 at the corresponding stage of the original transformation. This transforms ~a into a prefix of ~b at lower or equal cost if α ≤ δ.\nFinally, let ~a1a ′ ~a2 be the result of deletions and transpositions on ~aa ′. The length of ~a2 is a lower bound for number of transpositions involving a′ in editing ~a into ~b. The sequence of edits that deletes all letters of ~a2 and applies all substitutions and insertions that apply to ~a1 transforms ~a into a prefix of ~b. These edits have a lower or equal cost if γ ≤ δ since transpositions are replaced by deletions and some edits might now be omitted.\nIn each case, for all words ~aa′, we find that ~a has a smaller weighted edit distance to P (LC) than ~aa\n′. This demonstrates that the violation measure is non-decreasing and hence, by Proposition 8, Cs is contractible.\nExample 7 below shows that this theorem cannot be strengthened without imposing extra conditions on Cs.\nIt follows from the theorem that edit-based measures that only involve substitutions, insertions and deletions provide contractible constraints. Thus the variable-based measures (Petit et al. 2001; van Hoeve et al. 2006), the object-based measures (Beldiceanu and Petit 2004), and the edit-based measures of (van Hoeve et al. 2006) induce contractible soft constraints.\nFor order-free constraints, transposition is not needed in an edit and can be effectively given infinite weight. Thus, by Theorem 21, we have\nCorollary 22 If C is an order-free constraint and the corresponding soft constraint Cs is based on an open edit-based violation measure m, then Cs is contractible.\nWe also have the following curious result.\nCorollary 23\nLet Cs be a soft constraint based on an open edit-based violation measure m with weights α, β, γ, δ for the hard constraint C. If any of α, β, γ, or δ is 0 then Cs is contractible."
    }, {
      "heading" : "Proof",
      "text" : "If α, β or γ is 0 then the condition of Theorem 21 is satisfied and consequently Cs is contractible. If δ is 0 then transpositions can place the letters in a word in any order, at no cost. Let\nC′([X1, . . . , Xn]) ↔ ∨\nπ\nC([Xπ(1), . . . , Xπ(n)])\nwhere the disjunction is over all permutations π of 1..n. Then the violation measure m of C is equal to the violation measure m′ of C′, where m′ uses the same weights as m. C′ is order-free and, by Corollary 22, is contractible.\nFrom these results we see that soft constraints based on a wide range of edit-based measures are contractible. However, when transpositions are allowed and have a comparatively low cost, an edit-based violation measure can lead to a soft constraint that is not contractible.\nExample 7 Consider a constraint C with LC = (ab) ∗ + (ab)∗a, which is a prefix-closed language, and consider the corresponding soft constraint Cs that uses an edit-based violation measure. Suppose δ < min{α, β, γ}. The word abba has edit distance δ, by transposing the last two letters, but its prefix abb has edit distance min{α, β, γ}, since we could either substitute a for b, insert a before the second b, or delete a b. Thus the weighted edit-based violation measure is not non-decreasing and hence, by Proposition 8, Cs is not contractible.\nThis example reinforces a point made earlier: the introduction of P (LC) to the definition of edit-based violation measure plays a different role than its use for hard constraints; in this case, its use does not ensure contractibility."
    }, {
      "heading" : "8 Contractible Approximations of Soft Constraints",
      "text" : "Although we have identified powerful sufficient conditions for soft constraints to be contractible, we must also be able to support uncontractible soft constraints. As with hard constraints, when a soft constraint is uncontractible we can use a contractible approximation as the basis for filtering while the constraint is open.\nWe reformulate the notion of tight approximation for soft constraints of the form m( ~X) ≤ Z as follows. A violation measure m1 is an approximation of the violation measure m if, for all words ~a, m1(~a) ≤ m(~a). We order violation measures with the pointwise extension of the ordering on the reals: m1 ≤ m2 iff ∀~a m1(~a) ≤ m2(~a). A contractible approximation m1 to a violation measure m is tight if, for all contractible functions m2, if m1 ≤ m2 ≤ m then m2 = m1. Given two contractible approximations m1 and m2 to a violation measure m, we say m2 is tighter than m1 if m1 ≤ m2. We write m\n∗ to denote the tightest contractible approximation of m.\nWe can characterize the tightest contractible approximation of a violation measure, independent of how the violation measure is formulated.\nProposition 24\nLet m be a violation measure. The tightest contractible approximation to m is characterized by m∗(~a) = inf~b m(~a ~b), where the infimum is taken over all finite sequences ~b."
    }, {
      "heading" : "Proof",
      "text" : "By definition, m∗(~a) ≤ m(~a), so m∗ approximates m. Consider a sequence ~a and a letter c. m∗(~ac) = inf~b m(~ac ~b) ≥ infc~b m(~ac ~b) ≥ inf{m(~a), infc~b m(~ac ~b)} = m∗(~a). Thus m∗ is contractible. Suppose some function k is a strictly tighter contractible approximation than m∗. Then, for some ~a, k(~a) > m∗(~a), that is, k(~a) > inf~b m(~a ~b). Hence, there is a ~d such that k(~a) > m(~a~d). But, for any ~c, k(~a~c) ≥ k(~a). Thus we have m(~a~d) > m(~a~d). This contradiction shows that k cannot exist; m∗ is the tightest contractible approximation to m.\nThis proposition only provides a mathematical characterization; it does not suggest an implementation. Indeed, it appears very difficult to implement this tightest contractible approximation, in general, in contrast to the tightest contractible approximation of hard constraints. Nevertheless, we can identify some contractible approximations."
    }, {
      "heading" : "8.1 Decomposition-based Violation Measures",
      "text" : "One way to obtain a contractible approximation to a decomposition-based soft constraint is to ignore parts of a decomposition that cause incontractibility. A weakening of a decomposition of a constraint C( ~X) is a function that, for every sequence ~X, maps the decomposition ( ~X, ~U, T, S,w) to ( ~X, ~U, T, S′, w′) where (S′, w′) is a sub-weighted set of (S,w). For this weakened decomposition we can apply the sufficient condition of Theorem 15.\nProposition 25 Consider a decomposition-based violation measure m for a constraint C( ~X) and a weakening W of the decomposition. Suppose m is defined via a monotonic combining function. If, for every sequence ~X , the weakening of the decomposition of C( ~X) can be semantically embedded in the weakening of the decomposition of C( ~XY ) then the measure m′ defined by using the weakened decompositions is a contractible approximation of m."
    }, {
      "heading" : "Proof",
      "text" : "m′ is an approximation of m because the combining function is monotonic and the weakened decomposition employs a sub-weighted set of the original decomposition. m′ is contractible by application of Theorem 15.\nThis result shows an approach to finding a contractible approximation to Cs( ~X). However, there is no guarantee that it will find a good approximation; in the worst case it might provide only the trivial approximation, where all of C( ~X) is ignored. Nevertheless, it appears to be useful.\nThe next example presents an uncontractible decomposition-based soft constraint. It employs a decomposition of the global cardinality constraintGCC given in (Bessiere et al. 2009).\nExample 8 Consider the global cardinality constraint GCC( ~X,~l, ~u) with type T that maps each Xi to 1..d, which we denote by GCCT . This constraint expresses that, for each value t in 1..d, the number of occurrences of t in ~X lies between lt and ut (ut may be infinite). ~l and ~u are fixed. To define the decomposition of (Bessiere et al. 2009) we need to introduce variables Ailu of type {0, 1} and Nlu of type non-negative integers, and elementary constraints as follows. Let n = | ~X |.\nFor 1 ≤ i ≤ n, 1 ≤ l ≤ u ≤ d and 1 ≤ k < u we have the constraints\nAilu = 1 ↔ Xi ∈ [l, u] (4)\nNlu =\nn∑\ni=1\nAilu (5)\nN1u = N1k +N(k+1)u (6)\nu∑\nj=l\nlj ≤ Nlu ≤ u∑\nj=l\nuj (7)\nFormally, the decomposition of GCCT is ( ~X, ~A, ~N, T ′, S, w) where T ′ is the extension of T to ~A and ~N , S is the collection of (4), (5), (6), and (7), and w is a constant function. It is easy to establish that GCCT ( ~X,~l, ~u) ↔ ∃ ~A ∈ T ′( ~A) ∃ ~N ∈ T ′( ~N) S.\nWhen ~X is extended by Y , the decomposition contains extra variables A(n+1)lu, extra constraints of type (4) involving Y and the new variables, and replaces constraints (5) by\nNlu = n+1∑\ni=1\nAilu (8)\nConsider an occurrence of the constraint GCCT ([X1, X2], [0, 1, 0, 0], [2, 2, 2, 2]) where T (Xi) is 1..4. Consider a valuation v where X1 = 1, X2 = 1. For all extensions of v to ~A and ~N there will be an elementary constraint violated (fundamentally because the lower bound for occurrences of the domain value 2 has not been satisfied). If ~X is extended by X3 and v has X3 = 2 then v can be extended to ~A and ~N in the obvious way to satisfy all elementary constraints. Thus any proper violation measure for GCC based on this decomposition is not contractible.\nLet m be a proper violation measure that is defined with a combining function that is monotonic and has unit 0. If we weaken the decomposition by ignoring the lower bounds in (7) then we have a contractible approximation m′ of m. (This is essentially the same as for the tight contractible approximation of the hard GCC constraint, which is also obtained by ignoring lower bounds. This point is not so surprising when we recall that the hard constraint is a special case of the soft constraint.) We can see this using the natural semantic embedding (which maps all constraints to themselves, except that (5) is mapped to (8)) and Proposition 25.\nWe conjecture that the weakening of the soft GCC constraint in this example is its tightest contractible approximation. However, the many variables and constraints in the decomposition make it difficult to confirm this conjecture."
    }, {
      "heading" : "8.2 Edit-based Violation Measures",
      "text" : "Recall that an edit-based violation measure m is contractible if δ ≥ min{α, β, γ} (Theorem 21). If δ < min{α, β, γ} then m might be uncontractible and we must consider contractible approximations. We can provide generic contractible approximations for edit-based soft constraints by modifying the weights to accord with the sufficient conditions of Theorem 21 and Corollary 23.\nProposition 26 Let m be an open edit-based violation measure for a constraint C with weights α, β, γ, δ where δ < min{α, β, γ}. Then the following violation measures are contractible approximations of m for C.\n1. m1 based on weights δ, β, γ, δ (that is, α := δ) 2. m2 based on weights α, δ, γ, δ (that is, β := δ)\n3. m3 based on weights α, β, δ, δ (that is, γ := δ) 4. m4 based on weights α, β, γ, 0 (that is, δ := 0) 5. m5 defined by m5(w) = max{m1(w),m2(w),m3(w),m4(w)}"
    }, {
      "heading" : "Proof",
      "text" : "By Lemma 19, for any w, m1(w) ≤ m(w), m2(w) ≤ m(w), m3(w) ≤ m(w), and m4(w) ≤ m(w). It then follows from the definition of m5 that m5(w) ≤ m(w). Thus m1, m2, m3, m4 and m5 are approximations of m. By Theorem 21, m1, m2, and m3 are contractible and, by Corollary 23, m4 is contractible. For any word w and letter a,\nm5(wa) = max{m1(wa),m2(wa),m3(wa),m4(wa)} ≥ max{m1(w),m2(w),m3(w),m4(w)} = m5(w)\nusing the contractibility of m1, . . . ,m4. Thus m5 is contractible.\nNote that, by Lemma 19, other uses of Corollary 23 yield only measures that are not as tight as m1, m2, or m3. Clearly m5 is the tightest of these approximations. However, in general, this approximation is not tight, as the following example shows.\nExample 9 Let L = (abc)∗, so that P (L) = L ∪ La ∪ Lab. Let α = β = γ = 4 and δ = 1. Consider w = bbb(abc)3ca. Two kinds of edits are needed, addressing the initial b’s and the trailing ca. Then m(w) = 12 from substituting for the first and third b, and deleting the last c. m(wb) = 10 using the same substitutions and two transpositions on c. Thus m is not contractible.\nNotice that the initial b’s in w are too far from the end of w to be cheaply addressed by transpositions. For example, the cost of moving the third b to the trailing ca is 6, which is more expensive than addressing it by substitution. The other b’s are even more expensive to address by transposition. Thus the minimal cost of addressing the initial b’s is 8. The minimal cost of addressing the trailing ca arises when a b is appended to the end of w and c is transposed twice. This has a cost of 2, and it is easy to see that no word appended to w will allow ca to be addressed by a single transposition. Thus the tightest approximation to m has m∗(w) = 10.\nNow consider the approximations in Proposition 26. If we reduce α to 1 then m1(w) = 4 by applying four substitutions. If we reduce β to 1 then m2(w) = 8 by inserting a and c around each initial b and inserting ab before the last c. If we reduce γ to 1 then m3(w) = 4 by deleting the three b’s and the last c. If we reduce δ to 0 then m4(w) = 4 by applying transpositions to reorder w to (abc)4bb and then substituting a for b. Thus m5(w) = 8.\nThis shows that m5 is not the tightest contractible approximation to m, since m5(w) 6= m∗(w).\nThe question now arises: how to express m∗ in edit-based terms so that a closed propagator for m( ~X) ≤ Z might be adapted to implement m∗( ~X) ≤ Z, as was done for hard constraints in Section 6. Disappointingly, this turns out to be impossible, in general.\nWe first establish a straightforward lemma that gives a simple way of identifying the value of m∗(w) in some cases.\nLemma 27 Let m∗ be the tightest contractible approximation to an edit-based violation measure m. Let w be a word. If, for all words u, m(wu) ≥ m(w) then m∗(w) = m(w)."
    }, {
      "heading" : "Proof",
      "text" : "If, for all words u, m(wu) ≥ m(w) then infu m(wu) ≥ m(w). Thus m ∗(w) ≥ m(w). Since m∗ approximates m, m∗(w) ≤ m(w). Hence, m∗(w) = m(w).\nNow we show that, in general, the tightest contractible approximation m∗ to an editbased violation measure m cannot be expressed as a proper edit-based violation measure.\nTheorem 28 There is an open edit-based violation measure m for a language L such that its tightest contractible approximation cannot be expressed as a proper edit-based violation measure on any language."
    }, {
      "heading" : "Proof",
      "text" : "Consider the alphabet Σ = {a, b, c, d}. As in Example 9, let L = (abc)∗ (so P (L) = L∪La∪Lab), consider P (L) as a sublanguage of Σ∗, and let m be the edit-based violation measure for L where α = β = γ = 4 and δ = 1. As shown in Example 9, m is not contractible. Note that m is proper. Let m∗ be the tightest contractible approximation to m. Suppose m∗ can be expressed as a proper edit-based violation measure m′ on some language L′.\nSuppose there is some word w such that w ∈ L′\\P (L). Then m′(w) = 0. Hence m∗(w) = 0 and, from Proposition 24, there is a word u such that m(wu) = 0. Since m is proper, wu ∈ P (L) and hence w ∈ P (L). This contradiction shows that no such w exists and hence L′ ⊆ P (L).\nFor every w ∈ L, m(w) = 0. Hence m∗(w) = 0 and m′(w) = 0. Hence w ∈ L′, since m′ is proper. Hence L ⊆ L′. There are weights α′, β′, γ′, and δ′ used to define m′. We now consider different words w of Σ∗ and derive conditions on the weights of m′. We use the fact that every edit of w to P (L) must have cost greater than or equal to m∗(w). Because L′ ⊆ P (L), the conditions we derive about editing a word to P (L) also apply to L′.\nw = d. m(w) = 4 by deleting d and no word wu has a smaller violation measure because d must be deleted or substituted. Thus, by Lemma 27, m∗(w) = 4. w might be edited to L (and hence also L′) by deleting d or substituting a for d. This gives rise to the conditions γ′ ≥ 4 and α′ ≥ 4 since, for example, if γ′ = 3 then m′(w) = 3 6= m∗(w).\nw = bc(abc)3. m(w) = 4, by inserting a at the beginning of w. No word wu has a lower cost because the initial bc is too far from the end of w to use transposition from u at a lower cost. Thus m∗(w) = 4. From this we obtain the condition β′ ≥ 4, among others.\nw = ba. m(w) = 1 by transposition and we find that m∗(w) = 1. Because we know that α′ ≥ 4, β′ ≥ 4 and γ′ ≥ 4, we must have δ′ = 1.\n[We can now establish that L′ ⊆ (a+b+c)∗. For any word w involving d, m(w) ≥ 4, since the d must be deleted or substituted. That includes wu, for any u, and hence m∗(w) ≥ 4 for any word containing d. Consequently, also m′(w) ≥ 4 and, since m′ is proper, L′ does not contain a word involving d.]\nw = adc. m(w) = 4 = m∗(w). Given that δ′ = 1 and the small size of w, no word is edit distance 4 from w using transposition alone. But α′ ≥ 4, β′ ≥ 4 and γ′ ≥ 4, so the minimum cost edit from w to L′ does not involve transposition and the edit consists of a single operation. Since L′ does not contain words involving d, the only candidates are deletion or substitution of d. The deletion results in ac which is not in L′ since it is not in P (L). Hence the only edit that can achieve this cost is a substitution of b for d, and α′ = 4.\nw = d(abc)3.\nAs with w = d, m∗(w) = m(w) = 4. Given that α′ ≥ 4, only deletion of d can achieve this cost. Hence γ′ = 4.\nw = bc(abc)3, again. Given that α′ ≥ 4 and γ′ ≥ 4, the only edit that can achieve m∗(w) = 4 is an insertion. Hence β′ = 4.\nThus the weights for m′ are exactly the same as the weights for m. For every word w, m′(w) ≥ m(w), by Lemma 20. From the definition of m∗, m(w) ≥ m∗(w). But m′ = m∗, by assumption, and hence m∗ = m. But this is a contradiction, because by definition m∗ is contractible, while m is not. Thus the assumption that m∗ can be expressed as an edit-based violation measure is false.\nThe language and violation measure demonstrating this claim are those from Example 9. Given that the language is so simple, we can expect that many uncontractible editbased violation measures cannot be tightly approximated by a contractible edit-based violation measure. This contrasts markedly with our work on hard constraints in Section 6, where tight contractible approximations of several uncontractible hard constraints were formulated in terms of the original hard constraint.\nIt suggests some difficulties in implementing tight contractible approximations. It seems that the edit-based implementation of the closed constraint is not a suitable basis for implementing the tight approximation. At least we need a different framework if we are to have a comprehensive method to derive open D-consistent propagators for incontractible soft constraints.\nIt is demonstrated in (He et al. 2013) that using an approximation of the violation measure of a closed edit-based soft constraint can lead to incorrect answers to constraint problems. However, using a non-tight contractible approximation in an open constraint is less serious, assuming the correct violation measure is used for the closed constraint: the search may perform less-then-optimal pruning, leading to a greater search space than for a tight contractible approximation, but not to incorrect answers. Thus, Theorem 28 does not represent a failure of correctness, only a degree of inefficiency if a non-tight edit-based contractible approximation is used."
    }, {
      "heading" : "9 Discussion",
      "text" : "We have discussed open constraints where variables are added to the right-hand end of the sequence. This directly affects the characterization of contractibility and the definition of open D-consistency. If, instead, variables are added to the left-hand end then the appropriate characterization of contractibility is suffix-closure. If additions may be made at either end then contractibility requires both closures, which corresponds to closure under taking subwords.12 Constraints like Sequence and Contiguity are subword-closed. Of course, all order-free constraints are subword-closed. On the other hand, the lexicographic ordering constraint ≤lex and the precedence constraint s ≺ ~X t are prefix-closed but not suffix-closed, that is, they are contractible if variables are added on the right, but not if variables are added on the left.\nIf additional variables may be inserted anywhere within the sequence then contractibility corresponds to closure under taking subsequences.13 Apart from the order-free constraints, it is not clear whether there is any useful constraint that is closed under taking subsequences.\nIn (Maher 2009b) a dual notion to contractibility, called extensibility, is investigated.\n12 A word w is a subword of a1 . . . an if w is empty or has the form aiai+1 . . . aj for some 1 ≤ i ≤ j ≤ n. 13 A word w is a subsequence of a1 . . . an if w is empty or has the form ai1 . . . aik for some k ≤ n where 1 ≤ i1 < i2 < · · · < ik ≤ n.\nIn contrast to contractibility, in general there is no closure operation corresponding to extensibility and consequently no tightest extensible approximation.\nWe have seen some differences between contractibility for hard and soft constraints. For hard constraints contractibility depends on the relation whereas for soft constraints it depends on the violation measure. For example, the soft Regular constraint is contractible under the edit-based measure of (van Hoeve et al. 2006) but not under decompositionbased measures. We have also seen that many tight contractible approximations of hard constraints are similar to, though weaker than, the hard constraint. On the other hand, for many soft constraints it appears that the tight contractible approximations cannot be expressed in the same way as the soft constraint. This suggests that it may be difficult to formulate full open D-consistent propagators, for example, for uncontractible open soft constraints.\nThere are several similarities between violation measures and other treatments of soft constraints. For example, the Valued CSP (Schiex et al. 1995) and the Semi-Ring CSP (Bistarelli et al. 1997) frameworks define a soft constraint essentially as a function from valuations to an ordered set (the set may be partially ordered in the case of SCSPs) that might be considered a violation measure. Both frameworks use a combining function to extend this definition to a collection of constraints, and so they are, in many ways, like decomposition-based violation measures. However both frameworks consider only closed constraints and focus on finite relations defined extensionally.\nWeighted violation measures are used in (Métivier et al. 2007; Métivier et al. 2009). As noted earlier, the decomposition measures presented here generalize the weighted decomposition measures for Σ-AllDifferent and Σ-GCC (Métivier et al. 2007; Métivier et al. 2009). However, the edit-based violation measures presented here do not generalize the weighted edit distance for Σ-AllDifferent and Σ-Regular of (Métivier et al. 2007; Métivier et al. 2009). These measure use only substitution edits but they assign weights to each variable.\nViolation measures play a similar role to query measures (Maher and Stuckey 1989) that were used to specify preferences on query solutions in a CLP system. In this context, contractible violation measures are similar to pruning measures in (Maher and Stuckey 1989) in that both are non-decreasing functions, although over different domains, and both permit the safe pruning of search trees.\nContractible global soft constraints are amenable to a nested representation (Bessiere et al. 2014) in a distributed constraint optimization setting, which has significant performance gains over other representations (Bessiere et al. 2014).\nFinally, we note that the semantics of soft constraints are examples of quantitative languages, in the terminology of (Chatterjee et al. 2010). From this point of view, an approximation of a violation measure is a quantitative language inclusion. However, (Chatterjee et al. 2010) focuses on languages of infinite words defined via automata, so the results of (Chatterjee et al. 2010) do not seem to have application to the subject of this paper. In (Colcombet 2009) a notion of cost function on languages of finite words is used but this is only used to define equivalence classes and is not related to this paper."
    }, {
      "heading" : "10 Conclusions",
      "text" : "We have introduced the notion of contractibiliity of global constraints, which ensures that constraint propagation for closed constraints is safe for open constraints, and characterized it in language-theoretic terms. The concept of contractibility is remarkably robust. It is based only on the relation, or language, defining the constraint. Thus it is independent of the form of propagator used (monolithic or decomposed) and the consistency condition (if any) that characterizes the propagation.\nContractibility appears to be central to the re-use of closed constraint propagators for open propagation. When a constraint is contractible we only need to modify a closed\npropagator to support the addition of variables. When a constraint is incontractible we also need a contractible approximation of the propagator, for use while the constraint is open, in addition to the closed propagator. We showed that the use of a tight contractible approximation and domain consistent closed propagators achieves open D-consistency of the resulting open propagator. Furthermore, for many hard constraints (Regular, CFG, GCC, and many others) we showed that the tightest contractible approximation has a similar form to the original constraint, and hence can be propagated by the same techniques. This suggests that a close integration of the two propagation phases will be easy for these constraints.\nTo address soft constraints, we formulated two general classes of soft constraints that include most previous proposals of soft constraints. For the two classes – based on decomposition and edit-distance, respectively – we identified properties and developed mathematical tools for reasoning about them, which we used to demonstrate the contractibility of a wide range of soft constraints. We identified pragmatic contractible approximations of soft constraints in these classes. However, we also established that the tightest contractible approximation of an edit-based soft constraint is not expressible, in general, as an editbased constraint. This suggests difficulties in designing open D-consistency propagators in the general case but fortunately many edit-based soft constraints are contractible.\nThese results provide a good basis for adapting existing algorithms and implementations of global constraint propagators to open constraints."
    }, {
      "heading" : "Acknowledgements",
      "text" : "Thanks to the referees of this paper and previous conference papers, whose thorough reviews and detailed comments improved this paper. The work in this paper was mostly conducted while the author was employed by NICTA."
    }, {
      "heading" : "Optimization Problems, First International Conference, CPAIOR 2004, Nice, France,",
      "text" : "April 20-22, 2004, Proceedings. 80–95.\nBessière, C. 1991. Arc-consistency in dynamic constraint satisfaction problems. In Proceedings of the 9th National Conference on Artificial Intelligence, Anaheim, CA, USA, July 14-19, 1991, Volume 1. 221–226.\nBessiere, C., Brito, I., Gutierrez, P., and Meseguer, P. 2014. Global constraints in distributed constraint satisfaction and optimization. Comput. J. 57, 6, 906–923.\nBessiere, C., Hebrard, E., Hnich, B., Kiziltan, Z., and Walsh, T. 2008. SLIDE: A useful special case of the CARDPATH constraint. In ECAI 2008 - 18th European Conference on Artificial Intelligence, Patras, Greece, July 21-25, 2008, Proceedings. 475–479.\nBessiere, C., Katsirelos, G., Narodytska, N., Quimper, C., and Walsh, T. 2009. Decompositions of all different, global cardinality and related constraints. In IJCAI 2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence, Pasadena, California, USA, July 11-17, 2009. 419–424.\nBistarelli, S., Montanari, U., and Rossi, F. 1997. Semiring-based constraint satisfaction and optimization. J. ACM 44, 2, 201–236.\nBorning, A., Freeman-Benson, B. N., and Wilson, M. 1992. Constraint hierarchies. Lisp and Symbolic Computation 5, 3, 223–270.\nBorning, A., Maher, M. J., Martindale, A., and Wilson, M. 1989. Constraint hierarchies and logic programming. In Logic Programming, Proceedings of the Sixth International Conference, Lisbon, Portugal, June 19-23, 1989. 149–164.\nBrzozowski, J. A., Shallit, J., and Xu, Z. 2009. Decision problems for convex languages. In Language and Automata Theory and Applications, Third International Conference, LATA 2009, Tarragona, Spain, April 2-8, 2009. Proceedings. 247–258.\nChandra, A. K. and Merlin, P. M. 1977. Optimal implementation of conjunctive queries in relational data bases. In Proceedings of the 9th Annual ACM Symposium on Theory of Computing, May 4-6, 1977, Boulder, Colorado, USA. 77–90.\nChatterjee, K., Doyen, L., and Henzinger, T. A. 2010. Quantitative languages."
    }, {
      "heading" : "ACM Trans. Comput. Log. 11, 4.",
      "text" : "Chaudhuri, S. and Vardi, M. Y. 1993. Optimization of Real conjunctive queries. In Proceedings of the Twelfth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, May 25-28, 1993, Washington, DC, USA. 59–70.\nColcombet, T. 2009. The theory of stabilisation monoids and regular cost functions. In Automata, Languages and Programming, 36th Internatilonal Colloquium, ICALP 2009, Rhodes, Greece, July 5-12, 2009, Proceedings, Part II. 139–150.\nCormen, T. H., Leiserson, C. E., Rivest, R. L., and Stein, C. 2001. Introduction to Algorithms, Second Edition. The MIT Press and McGraw-Hill Book Company.\nDebruyne, R., Ferrand, G., Jussien, N., Lesaint, W., Ouis, S., and Tessier, A. 2003. Correctness of constraint retraction algorithms. In Proceedings of the Sixteenth International Florida Artificial Intelligence Research Society Conference, May 12-14, 2003, St. Augustine, Florida, USA. 172–176.\nDechter, R. 2003. Constraint processing. Elsevier Morgan Kaufmann.\nDechter, R. and Dechter, A. 1988. Belief maintenance in dynamic constraint networks. In Proceedings of the 7th National Conference on Artificial Intelligence. St. Paul, MN, August 21-26, 1988. 37–42.\nFaltings, B. and Macho-Gonzalez, S. 2002. Open constraint satisfaction. In Principles and Practice of Constraint Programming - CP 2002, 8th International Conference, CP 2002, Ithaca, NY, USA, September 9-13, 2002, Proceedings. 356–370.\nFaltings, B. and Macho-Gonzalez, S. 2005. Open constraint programming. Artif. Intell. 161, 1-2, 181–208.\nFrisch, A. M., Hnich, B., Kiziltan, Z., Miguel, I., and Walsh, T. 2002. Global constraints for lexicographic orderings. In Principles and Practice of Constraint Programming - CP 2002, 8th International Conference, CP 2002, Ithaca, NY, USA, September 9-13, 2002, Proceedings. 93–108.\nGavanelli, M., Lamma, E., Mello, P., and Milano, M. 2005. Dealing with incomplete\nknowledge on clp(FD) variable domains. ACM Trans. Program. Lang. Syst. 27, 2, 236– 263.\nGeorget, Y., Codognet, P., and Rossi, F. 1999. Constraint retraction in CLP(FD): formal framework and performance results. Constraints 4, 1, 5–42.\nGervet, C. 1997. Interval propagation to reason about sets: Definition and implementation of a practical language. Constraints 1, 3, 191–244.\nHe, J., Flener, P., and Pearson, J. 2013. Underestimating the cost of a soft constraint is dangerous: revisiting the edit-distance based soft regular constraint. J. Heuristics 19, 5, 729–756.\nHentenryck, P. V. and Provost, T. L. 1991. Incremental search in constraint logic programming. New Generation Comput. 9, 3/4, 257–276.\nHopcroft, J. and Ullman, J. 1979. Introduction to Automata Theory Languages and Computation. Addison-Wesley.\nIoannidis, Y. E. and Ramakrishnan, R. 1995. Containment of conjunctive queries: Beyond relations as sets. ACM Trans. Database Syst. 20, 3, 288–324.\nJaffar, J. and Maher, M. J. 1994. Constraint logic programming: A survey. J. Log. Program. 19/20, 503–581.\nKlug, A. C. 1988. On conjunctive queries containing inequalities. Journal of ACM 35, 1, 146–160.\nLallouet, A., Law, Y. C., Lee, J. H., and Siu, C. F. K. 2011. Constraint programming on infinite data streams. In IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence, Barcelona, Catalonia, Spain, July 16-22, 2011. 597–604.\nLaw, Y. C. and Lee, J. H. 2004. Global constraints for integer and set value precedence."
    }, {
      "heading" : "In Principles and Practice of Constraint Programming - CP 2004, 10th International",
      "text" : "Conference, CP 2004, Toronto, Canada, September 27 - October 1, 2004, Proceedings. 362–376.\nMaher, M. J. 1988. Equivalences of logic programs. In Foundations of Deductive Databases and Logic Programming. Morgan Kaufmann, 627–658.\nMaher, M. J. 1993. A logic programming view of CLP. In Logic Programming, Proceedings of the Tenth International Conference on Logic Programming, Budapest, Hungary, June 21-25, 1993. 737–753.\nMaher, M. J. 2002. Analysis of a global contiguity constraint. In Proc. Workshop on Rule-Based Constraint Reasoning and Programming.\nMaher, M. J. 2009a. Local consistency for extended CSPs. Theor. Comput. Sci. 410, 46, 4769–4783.\nMaher, M. J. 2009b. Open constraints in a boundable world. In Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems, 6th International Conference, CPAIOR 2009, Pittsburgh, PA, USA, May 27-31, 2009, Proceedings. 163–177.\nMaher, M. J. 2009c. Open contractible global constraints. In IJCAI 2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence, Pasadena, California, USA, July 11-17, 2009. 578–583.\nMaher, M. J. 2009d. SOGgy constraints: Soft open global constraints. In Principles and Practice of Constraint Programming - CP 2009, 15th International Conference, CP 2009, Lisbon, Portugal, September 20-24, 2009, Proceedings. 584–591.\nMaher, M. J. 2010. Contractibility and contractible approximations of soft global constraints. In Technical Communications of the 26th International Conference on Logic Programming, ICLP 2010, July 16-19, 2010, Edinburgh, Scotland, UK. 114–123.\nMaher, M. J., Narodytska, N., Quimper, C., and Walsh, T. 2008. Flow-based propagators for the SEQUENCE and related global constraints. In Principles and Practice of Constraint Programming, 14th International Conference, CP 2008, Sydney, Australia, September 14-18, 2008. Proceedings. 159–174.\nMaher, M. J. and Stuckey, P. J. 1989. Expanding query power in constraint logic programming languages. In Logic Programming, Proceedings of the North American Conference 1989, Cleveland, Ohio, USA, October 16-20, 1989. 2 Volumes. 20–36.\nMétivier, J., Boizumault, P., and Loudni, S. 2007. All different: Softening alldifferent in weighted csps. In 19th IEEE International Conference on Tools with Artificial Intelligence (ICTAI 2007), October 29-31, 2007, Patras, Greece, Volume 1. 223–230.\nMétivier, J., Boizumault, P., and Loudni, S. 2009. Softening gcc and regular with preferences. In Proceedings of the 2009 ACM Symposium on Applied Computing (SAC), Honolulu, Hawaii, USA, March 9-12, 2009. 1392–1396.\nMittal, S. and Falkenhainer, B. 1990. Dynamic constraint satisfaction problems. In Proceedings of the 8th National Conference on Artificial Intelligence. Boston, Massachusetts, July 29 - August 3, 1990, 2 Volumes. 25–32.\nNethercote, N., Stuckey, P. J., Becket, R., Brand, S., Duck, G. J., and Tack, G. 2007. Minizinc: Towards a standard CP modelling language. In Principles and Practice of Constraint Programming - CP 2007, 13th International Conference, CP 2007, Providence, RI, USA, September 23-27, 2007, Proceedings. 529–543.\nPachet, F. and Roy, P. 1999. Automatic generation of music programs. In Principles and Practice of Constraint Programming - CP’99, 5th International Conference, Alexandria, Virginia, USA, October 11-14, 1999, Proceedings. 331–345.\nPesant, G. 2004. A regular language membership constraint for finite sequences of variables. In Principles and Practice of Constraint Programming - CP 2004, 10th International Conference, CP 2004, Toronto, Canada, September 27 - October 1, 2004, Proceedings. 482–495.\nPetit, T. and Poder, E. 2009. The soft cumulative constraint. CoRR abs/0907.0939.\nPetit, T., Régin, J., and Bessière, C. 2001. Specific filtering algorithms for overconstrained problems. In Principles and Practice of Constraint Programming - CP 2001, 7th International Conference, CP 2001, Paphos, Cyprus, November 26 - December 1, 2001, Proceedings. 451–463.\nQuimper, C. and Walsh, T. 2006. Global grammar constraints. In Principles and Practice of Constraint Programming - CP 2006, 12th International Conference, CP 2006, Nantes, France, September 25-29, 2006, Proceedings. 751–755.\nRégin, J. 1994. A filtering algorithm for constraints of difference in csps. In Proceedings of the 12th National Conference on Artificial Intelligence, Seattle, WA, USA, July 31 - August 4, 1994, Volume 1. 362–367.\nRégin, J. 1996. Generalized arc consistency for global cardinality constraint. In Proceedings of the Thirteenth National Conference on Artificial Intelligence and Eighth Innovative Applications of Artificial Intelligence Conference, AAAI 96, IAAI 96, Portland, Oregon, August 4-8, 1996, Volume 1. 209–215.\nRossi, F., van Beek, P., and Walsh, T., Eds. 2006. Handbook of Constraint Programming. Foundations of Artificial Intelligence, vol. 2. Elsevier.\nSchiex, T., Fargier, H., and Verfaillie, G. 1995. Valued constraint satisfaction problems: Hard and easy problems. In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence, IJCAI 95, Montréal Québec, Canada, August 20- 25 1995, 2 Volumes. 631–639.\nSchulte, C. and Tack, G. 2009. Weakly monotonic propagators. In Principles and\nPractice of Constraint Programming - CP 2009, 15th International Conference, CP 2009, Lisbon, Portugal, September 20-24, 2009, Proceedings. 723–730.\nSellmann, M. 2006. The theory of grammar constraints. In Principles and Practice of Constraint Programming - CP 2006, 12th International Conference, CP 2006, Nantes, France, September 25-29, 2006, Proceedings. 530–544.\nvan Hoeve, W. J., Pesant, G., and Rousseau, L. 2006. On global warming: Flow-based soft global constraints. J. Heuristics 12, 4-5, 347–373.\nvan Hoeve, W. J. and Régin, J. 2006. Open constraints in a closed world. In Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization"
    }, {
      "heading" : "Problems, Third International Conference, CPAIOR 2006, Cork, Ireland, May 31 - June",
      "text" : "2, 2006, Proceedings. 244–257.\nVerfaillie, G. and Jussien, N. 2005. Constraint solving in uncertain and dynamic environments: A survey. Constraints 10, 3, 253–281."
    } ],
    "references" : [ {
      "title" : "Dynamic constraint models for planning and scheduling problems",
      "author" : [ "R. Barták" ],
      "venue" : "New Trends in Contraints. 237–255.",
      "citeRegEx" : "Barták,? 1999",
      "shortCiteRegEx" : "Barták",
      "year" : 1999
    }, {
      "title" : "Dynamic global constraints in backtracking based environments",
      "author" : [ "R. Barták" ],
      "venue" : "Annals OR 118, 1-4, 101–119.",
      "citeRegEx" : "Barták,? 2003",
      "shortCiteRegEx" : "Barták",
      "year" : 2003
    }, {
      "title" : "Revisiting the cardinality operator and introducing the cardinality-path constraint family",
      "author" : [ "N. Beldiceanu", "M. Carlsson" ],
      "venue" : "Logic Programming, 17th International Conference, ICLP 2001, Paphos, Cyprus, November 26 - December 1, 2001, Proceedings. 59–73.",
      "citeRegEx" : "Beldiceanu and Carlsson,? 2001",
      "shortCiteRegEx" : "Beldiceanu and Carlsson",
      "year" : 2001
    }, {
      "title" : "Global constraint catalog",
      "author" : [ "N. Beldiceanu", "M. Carlsson", "Rampon", "J.-X." ],
      "venue" : "Tech. Rep. T2005:08, SICS. Current version available at http://sofdem.github.io/gccat/.",
      "citeRegEx" : "Beldiceanu et al\\.,? 2005",
      "shortCiteRegEx" : "Beldiceanu et al\\.",
      "year" : 2005
    }, {
      "title" : "Introducing global constraints in CHIP",
      "author" : [ "N. Beldiceanu", "E. Contejean" ],
      "venue" : "Mathematical Computer Modelling 20, 12, 97–123.",
      "citeRegEx" : "Beldiceanu and Contejean,? 1994",
      "shortCiteRegEx" : "Beldiceanu and Contejean",
      "year" : 1994
    }, {
      "title" : "Cost evaluation of soft global constraints",
      "author" : [ "N. Beldiceanu", "T. Petit" ],
      "venue" : "Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems, First International Conference, CPAIOR 2004, Nice, France, April 20-22, 2004, Proceedings. 80–95.",
      "citeRegEx" : "Beldiceanu and Petit,? 2004",
      "shortCiteRegEx" : "Beldiceanu and Petit",
      "year" : 2004
    }, {
      "title" : "Arc-consistency in dynamic constraint satisfaction problems",
      "author" : [ "C. Bessière" ],
      "venue" : "Proceedings of the 9th National Conference on Artificial Intelligence, Anaheim, CA, USA, July 14-19, 1991, Volume 1. 221–226.",
      "citeRegEx" : "Bessière,? 1991",
      "shortCiteRegEx" : "Bessière",
      "year" : 1991
    }, {
      "title" : "Global constraints in distributed constraint satisfaction and optimization",
      "author" : [ "C. Bessiere", "I. Brito", "P. Gutierrez", "P. Meseguer" ],
      "venue" : "Comput. J. 57, 6, 906–923.",
      "citeRegEx" : "Bessiere et al\\.,? 2014",
      "shortCiteRegEx" : "Bessiere et al\\.",
      "year" : 2014
    }, {
      "title" : "SLIDE: A useful special case of the CARDPATH constraint",
      "author" : [ "C. Bessiere", "E. Hebrard", "B. Hnich", "Z. Kiziltan", "T. Walsh" ],
      "venue" : "ECAI 2008 - 18th European Conference on Artificial Intelligence, Patras, Greece, July 21-25, 2008, Proceedings. 475–479.",
      "citeRegEx" : "Bessiere et al\\.,? 2008",
      "shortCiteRegEx" : "Bessiere et al\\.",
      "year" : 2008
    }, {
      "title" : "Decompositions of all different, global cardinality and related constraints",
      "author" : [ "C. Bessiere", "G. Katsirelos", "N. Narodytska", "C. Quimper", "T. Walsh" ],
      "venue" : "IJCAI 2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence, Pasadena, California, USA, July 11-17, 2009. 419–424.",
      "citeRegEx" : "Bessiere et al\\.,? 2009",
      "shortCiteRegEx" : "Bessiere et al\\.",
      "year" : 2009
    }, {
      "title" : "Semiring-based constraint satisfaction and optimization",
      "author" : [ "S. Bistarelli", "U. Montanari", "F. Rossi" ],
      "venue" : "J. ACM 44, 2, 201–236.",
      "citeRegEx" : "Bistarelli et al\\.,? 1997",
      "shortCiteRegEx" : "Bistarelli et al\\.",
      "year" : 1997
    }, {
      "title" : "Constraint hierarchies",
      "author" : [ "A. Borning", "B.N. Freeman-Benson", "M. Wilson" ],
      "venue" : "Lisp and Symbolic Computation 5, 3, 223–270.",
      "citeRegEx" : "Borning et al\\.,? 1992",
      "shortCiteRegEx" : "Borning et al\\.",
      "year" : 1992
    }, {
      "title" : "Constraint hierarchies and logic programming",
      "author" : [ "A. Borning", "M.J. Maher", "A. Martindale", "M. Wilson" ],
      "venue" : "Logic Programming, Proceedings of the Sixth International Conference, Lisbon, Portugal, June 19-23, 1989. 149–164.",
      "citeRegEx" : "Borning et al\\.,? 1989",
      "shortCiteRegEx" : "Borning et al\\.",
      "year" : 1989
    }, {
      "title" : "Decision problems for convex languages",
      "author" : [ "J.A. Brzozowski", "J. Shallit", "Z. Xu" ],
      "venue" : "Language and Automata Theory and Applications, Third International Conference, LATA 2009, Tarragona, Spain, April 2-8, 2009. Proceedings. 247–258.",
      "citeRegEx" : "Brzozowski et al\\.,? 2009",
      "shortCiteRegEx" : "Brzozowski et al\\.",
      "year" : 2009
    }, {
      "title" : "Optimal implementation of conjunctive queries in relational data bases",
      "author" : [ "A.K. Chandra", "P.M. Merlin" ],
      "venue" : "Proceedings of the 9th Annual ACM Symposium on Theory of Computing, May 4-6, 1977, Boulder, Colorado, USA. 77–90.",
      "citeRegEx" : "Chandra and Merlin,? 1977",
      "shortCiteRegEx" : "Chandra and Merlin",
      "year" : 1977
    }, {
      "title" : "Quantitative languages",
      "author" : [ "K. Chatterjee", "L. Doyen", "T.A. Henzinger" ],
      "venue" : "ACM Trans. Comput. Log. 11, 4.",
      "citeRegEx" : "Chatterjee et al\\.,? 2010",
      "shortCiteRegEx" : "Chatterjee et al\\.",
      "year" : 2010
    }, {
      "title" : "Optimization of Real conjunctive queries",
      "author" : [ "S. Chaudhuri", "M.Y. Vardi" ],
      "venue" : "Proceedings of the Twelfth ACM SIGACT-SIGMOD-SIGART Symposium on Principles of Database Systems, May 25-28, 1993, Washington, DC, USA. 59–70.",
      "citeRegEx" : "Chaudhuri and Vardi,? 1993",
      "shortCiteRegEx" : "Chaudhuri and Vardi",
      "year" : 1993
    }, {
      "title" : "The theory of stabilisation monoids and regular cost functions",
      "author" : [ "T. Colcombet" ],
      "venue" : "Automata, Languages and Programming, 36th Internatilonal Colloquium, ICALP 2009, Rhodes, Greece, July 5-12, 2009, Proceedings, Part II. 139–150.",
      "citeRegEx" : "Colcombet,? 2009",
      "shortCiteRegEx" : "Colcombet",
      "year" : 2009
    }, {
      "title" : "Introduction to Algorithms, Second Edition",
      "author" : [ "T.H. Cormen", "C.E. Leiserson", "R.L. Rivest", "C. Stein" ],
      "venue" : "The MIT Press and McGraw-Hill Book Company.",
      "citeRegEx" : "Cormen et al\\.,? 2001",
      "shortCiteRegEx" : "Cormen et al\\.",
      "year" : 2001
    }, {
      "title" : "Correctness of constraint retraction algorithms",
      "author" : [ "R. Debruyne", "G. Ferrand", "N. Jussien", "W. Lesaint", "S. Ouis", "A. Tessier" ],
      "venue" : "Proceedings of the Sixteenth International Florida Artificial Intelligence Research Society Conference, May 12-14, 2003, St. Augustine, Florida, USA. 172–176.",
      "citeRegEx" : "Debruyne et al\\.,? 2003",
      "shortCiteRegEx" : "Debruyne et al\\.",
      "year" : 2003
    }, {
      "title" : "Constraint processing",
      "author" : [ "R. Dechter" ],
      "venue" : "Elsevier Morgan Kaufmann.",
      "citeRegEx" : "Dechter,? 2003",
      "shortCiteRegEx" : "Dechter",
      "year" : 2003
    }, {
      "title" : "Belief maintenance in dynamic constraint networks",
      "author" : [ "R. Dechter", "A. Dechter" ],
      "venue" : "Proceedings of the 7th National Conference on Artificial Intelligence. St. Paul, MN, August 21-26, 1988. 37–42.",
      "citeRegEx" : "Dechter and Dechter,? 1988",
      "shortCiteRegEx" : "Dechter and Dechter",
      "year" : 1988
    }, {
      "title" : "Open constraint satisfaction",
      "author" : [ "B. Faltings", "S. Macho-Gonzalez" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2002, 8th International Conference, CP 2002, Ithaca, NY, USA, September 9-13, 2002, Proceedings. 356–370.",
      "citeRegEx" : "Faltings and Macho.Gonzalez,? 2002",
      "shortCiteRegEx" : "Faltings and Macho.Gonzalez",
      "year" : 2002
    }, {
      "title" : "Open constraint programming",
      "author" : [ "B. Faltings", "S. Macho-Gonzalez" ],
      "venue" : "Artif. Intell. 161, 1-2, 181–208.",
      "citeRegEx" : "Faltings and Macho.Gonzalez,? 2005",
      "shortCiteRegEx" : "Faltings and Macho.Gonzalez",
      "year" : 2005
    }, {
      "title" : "Global constraints for lexicographic orderings",
      "author" : [ "A.M. Frisch", "B. Hnich", "Z. Kiziltan", "I. Miguel", "T. Walsh" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2002, 8th International Conference, CP 2002, Ithaca, NY, USA, September 9-13, 2002, Proceedings. 93–108.",
      "citeRegEx" : "Frisch et al\\.,? 2002",
      "shortCiteRegEx" : "Frisch et al\\.",
      "year" : 2002
    }, {
      "title" : "Dealing with incomplete",
      "author" : [ "M. Gavanelli", "E. Lamma", "P. Mello", "M. Milano" ],
      "venue" : null,
      "citeRegEx" : "Gavanelli et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Gavanelli et al\\.",
      "year" : 2005
    }, {
      "title" : "Constraint retraction in CLP(FD): formal framework and performance results",
      "author" : [ "Y. Georget", "P. Codognet", "F. Rossi" ],
      "venue" : "Constraints 4, 1, 5–42.",
      "citeRegEx" : "Georget et al\\.,? 1999",
      "shortCiteRegEx" : "Georget et al\\.",
      "year" : 1999
    }, {
      "title" : "Interval propagation to reason about sets: Definition and implementation of a practical language",
      "author" : [ "C. Gervet" ],
      "venue" : "Constraints 1, 3, 191–244.",
      "citeRegEx" : "Gervet,? 1997",
      "shortCiteRegEx" : "Gervet",
      "year" : 1997
    }, {
      "title" : "Underestimating the cost of a soft constraint is dangerous: revisiting the edit-distance based soft regular constraint",
      "author" : [ "J. He", "P. Flener", "J. Pearson" ],
      "venue" : "J. Heuristics 19, 5, 729–756.",
      "citeRegEx" : "He et al\\.,? 2013",
      "shortCiteRegEx" : "He et al\\.",
      "year" : 2013
    }, {
      "title" : "Incremental search in constraint logic programming",
      "author" : [ "P.V. Hentenryck", "T.L. Provost" ],
      "venue" : "New Generation Comput. 9, 3/4, 257–276.",
      "citeRegEx" : "Hentenryck and Provost,? 1991",
      "shortCiteRegEx" : "Hentenryck and Provost",
      "year" : 1991
    }, {
      "title" : "Introduction to Automata Theory Languages and Computation",
      "author" : [ "J. Hopcroft", "J. Ullman" ],
      "venue" : "Addison-Wesley.",
      "citeRegEx" : "Hopcroft and Ullman,? 1979",
      "shortCiteRegEx" : "Hopcroft and Ullman",
      "year" : 1979
    }, {
      "title" : "Containment of conjunctive queries: Beyond relations as sets",
      "author" : [ "Y.E. Ioannidis", "R. Ramakrishnan" ],
      "venue" : "ACM Trans. Database Syst. 20, 3, 288–324.",
      "citeRegEx" : "Ioannidis and Ramakrishnan,? 1995",
      "shortCiteRegEx" : "Ioannidis and Ramakrishnan",
      "year" : 1995
    }, {
      "title" : "Constraint logic programming: A survey",
      "author" : [ "J. Jaffar", "M.J. Maher" ],
      "venue" : "J. Log. Program. 19/20, 503–581.",
      "citeRegEx" : "Jaffar and Maher,? 1994",
      "shortCiteRegEx" : "Jaffar and Maher",
      "year" : 1994
    }, {
      "title" : "On conjunctive queries containing inequalities",
      "author" : [ "A.C. Klug" ],
      "venue" : "Journal of ACM 35, 1, 146–160.",
      "citeRegEx" : "Klug,? 1988",
      "shortCiteRegEx" : "Klug",
      "year" : 1988
    }, {
      "title" : "Constraint programming on infinite data streams",
      "author" : [ "A. Lallouet", "Y.C. Law", "J.H. Lee", "C.F.K. Siu" ],
      "venue" : "IJCAI 2011, Proceedings of the 22nd International Joint Conference on Artificial Intelligence, Barcelona, Catalonia, Spain, July 16-22, 2011. 597–604.",
      "citeRegEx" : "Lallouet et al\\.,? 2011",
      "shortCiteRegEx" : "Lallouet et al\\.",
      "year" : 2011
    }, {
      "title" : "Global constraints for integer and set value precedence",
      "author" : [ "Y.C. Law", "J.H. Lee" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2004, 10th International Conference, CP 2004, Toronto, Canada, September 27 - October 1, 2004, Proceedings. 362–376.",
      "citeRegEx" : "Law and Lee,? 2004",
      "shortCiteRegEx" : "Law and Lee",
      "year" : 2004
    }, {
      "title" : "Equivalences of logic programs",
      "author" : [ "M.J. Maher" ],
      "venue" : "Foundations of Deductive Databases and Logic Programming. Morgan Kaufmann, 627–658.",
      "citeRegEx" : "Maher,? 1988",
      "shortCiteRegEx" : "Maher",
      "year" : 1988
    }, {
      "title" : "A logic programming view of CLP",
      "author" : [ "M.J. Maher" ],
      "venue" : "Logic Programming, Proceedings of the Tenth International Conference on Logic Programming, Budapest, Hungary, June 21-25, 1993. 737–753.",
      "citeRegEx" : "Maher,? 1993",
      "shortCiteRegEx" : "Maher",
      "year" : 1993
    }, {
      "title" : "Analysis of a global contiguity constraint",
      "author" : [ "M.J. Maher" ],
      "venue" : "Proc. Workshop on Rule-Based Constraint Reasoning and Programming.",
      "citeRegEx" : "Maher,? 2002",
      "shortCiteRegEx" : "Maher",
      "year" : 2002
    }, {
      "title" : "Local consistency for extended CSPs",
      "author" : [ "M.J. Maher" ],
      "venue" : "Theor. Comput. Sci. 410, 46, 4769–4783.",
      "citeRegEx" : "Maher,? 2009a",
      "shortCiteRegEx" : "Maher",
      "year" : 2009
    }, {
      "title" : "Open constraints in a boundable world",
      "author" : [ "M.J. Maher" ],
      "venue" : "Integration of AI and OR Techniques in Constraint Programming for Combinatorial Optimization Problems, 6th International Conference, CPAIOR 2009, Pittsburgh, PA, USA, May 27-31, 2009, Proceedings. 163–177.",
      "citeRegEx" : "Maher,? 2009b",
      "shortCiteRegEx" : "Maher",
      "year" : 2009
    }, {
      "title" : "Open contractible global constraints",
      "author" : [ "M.J. Maher" ],
      "venue" : "IJCAI 2009, Proceedings of the 21st International Joint Conference on Artificial Intelligence, Pasadena, California, USA, July 11-17, 2009. 578–583.",
      "citeRegEx" : "Maher,? 2009c",
      "shortCiteRegEx" : "Maher",
      "year" : 2009
    }, {
      "title" : "SOGgy constraints: Soft open global constraints",
      "author" : [ "M.J. Maher" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2009, 15th International Conference, CP 2009, Lisbon, Portugal, September 20-24, 2009, Proceedings. 584–591.",
      "citeRegEx" : "Maher,? 2009d",
      "shortCiteRegEx" : "Maher",
      "year" : 2009
    }, {
      "title" : "Contractibility and contractible approximations of soft global constraints",
      "author" : [ "M.J. Maher" ],
      "venue" : "Technical Communications of the 26th International Conference on Logic Programming, ICLP 2010, July 16-19, 2010, Edinburgh, Scotland, UK. 114–123.",
      "citeRegEx" : "Maher,? 2010",
      "shortCiteRegEx" : "Maher",
      "year" : 2010
    }, {
      "title" : "Flow-based propagators for the SEQUENCE and related global constraints",
      "author" : [ "M.J. Maher", "N. Narodytska", "C. Quimper", "T. Walsh" ],
      "venue" : "Principles and Practice of Constraint Programming, 14th International Conference, CP 2008, Sydney, Australia, September 14-18, 2008. Proceedings. 159–174.",
      "citeRegEx" : "Maher et al\\.,? 2008",
      "shortCiteRegEx" : "Maher et al\\.",
      "year" : 2008
    }, {
      "title" : "Expanding query power in constraint logic programming languages",
      "author" : [ "M.J. Maher", "P.J. Stuckey" ],
      "venue" : "Logic Programming, Proceedings of the North American Conference 1989, Cleveland, Ohio, USA, October 16-20, 1989. 2 Volumes. 20–36.",
      "citeRegEx" : "Maher and Stuckey,? 1989",
      "shortCiteRegEx" : "Maher and Stuckey",
      "year" : 1989
    }, {
      "title" : "All different: Softening alldifferent in weighted csps",
      "author" : [ "J. Métivier", "P. Boizumault", "S. Loudni" ],
      "venue" : "19th IEEE International Conference on Tools with Artificial Intelligence (ICTAI 2007), October 29-31, 2007, Patras, Greece, Volume 1. 223–230.",
      "citeRegEx" : "Métivier et al\\.,? 2007",
      "shortCiteRegEx" : "Métivier et al\\.",
      "year" : 2007
    }, {
      "title" : "Softening gcc and regular with preferences",
      "author" : [ "J. Métivier", "P. Boizumault", "S. Loudni" ],
      "venue" : "Proceedings of the 2009 ACM Symposium on Applied Computing (SAC), Honolulu, Hawaii, USA, March 9-12, 2009. 1392–1396.",
      "citeRegEx" : "Métivier et al\\.,? 2009",
      "shortCiteRegEx" : "Métivier et al\\.",
      "year" : 2009
    }, {
      "title" : "Dynamic constraint satisfaction problems",
      "author" : [ "S. Mittal", "B. Falkenhainer" ],
      "venue" : "Proceedings of the 8th National Conference on Artificial Intelligence. Boston, Massachusetts, July 29 - August 3, 1990, 2 Volumes. 25–32.",
      "citeRegEx" : "Mittal and Falkenhainer,? 1990",
      "shortCiteRegEx" : "Mittal and Falkenhainer",
      "year" : 1990
    }, {
      "title" : "Minizinc: Towards a standard CP modelling language",
      "author" : [ "N. Nethercote", "P.J. Stuckey", "R. Becket", "S. Brand", "G.J. Duck", "G. Tack" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2007, 13th International Conference, CP 2007, Providence, RI, USA, September 23-27, 2007, Proceedings. 529–543.",
      "citeRegEx" : "Nethercote et al\\.,? 2007",
      "shortCiteRegEx" : "Nethercote et al\\.",
      "year" : 2007
    }, {
      "title" : "Automatic generation of music programs",
      "author" : [ "F. Pachet", "P. Roy" ],
      "venue" : "Principles and Practice of Constraint Programming - CP’99, 5th International Conference, Alexandria, Virginia, USA, October 11-14, 1999, Proceedings. 331–345.",
      "citeRegEx" : "Pachet and Roy,? 1999",
      "shortCiteRegEx" : "Pachet and Roy",
      "year" : 1999
    }, {
      "title" : "A regular language membership constraint for finite sequences of variables",
      "author" : [ "G. Pesant" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2004, 10th International Conference, CP 2004, Toronto, Canada, September 27 - October 1, 2004, Proceedings. 482–495.",
      "citeRegEx" : "Pesant,? 2004",
      "shortCiteRegEx" : "Pesant",
      "year" : 2004
    }, {
      "title" : "The soft cumulative constraint",
      "author" : [ "T. Petit", "E. Poder" ],
      "venue" : "CoRR abs/0907.0939.",
      "citeRegEx" : "Petit and Poder,? 2009",
      "shortCiteRegEx" : "Petit and Poder",
      "year" : 2009
    }, {
      "title" : "Specific filtering algorithms for overconstrained problems",
      "author" : [ "T. Petit", "J. Régin", "C. Bessière" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2001, 7th International Conference, CP 2001, Paphos, Cyprus, November 26 - December 1, 2001, Proceedings. 451–463.",
      "citeRegEx" : "Petit et al\\.,? 2001",
      "shortCiteRegEx" : "Petit et al\\.",
      "year" : 2001
    }, {
      "title" : "Global grammar constraints",
      "author" : [ "C. Quimper", "T. Walsh" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2006, 12th International Conference, CP 2006, Nantes, France, September 25-29, 2006, Proceedings. 751–755.",
      "citeRegEx" : "Quimper and Walsh,? 2006",
      "shortCiteRegEx" : "Quimper and Walsh",
      "year" : 2006
    }, {
      "title" : "A filtering algorithm for constraints of difference in csps",
      "author" : [ "J. Régin" ],
      "venue" : "Proceedings of the 12th National Conference on Artificial Intelligence, Seattle, WA, USA, July 31 August 4, 1994, Volume 1. 362–367.",
      "citeRegEx" : "Régin,? 1994",
      "shortCiteRegEx" : "Régin",
      "year" : 1994
    }, {
      "title" : "Generalized arc consistency for global cardinality constraint",
      "author" : [ "J. Régin" ],
      "venue" : "Proceedings of the Thirteenth National Conference on Artificial Intelligence and Eighth Innovative Applications of Artificial Intelligence Conference, AAAI 96, IAAI 96, Portland, Oregon, August 4-8, 1996, Volume 1. 209–215.",
      "citeRegEx" : "Régin,? 1996",
      "shortCiteRegEx" : "Régin",
      "year" : 1996
    }, {
      "title" : "Valued constraint satisfaction problems: Hard and easy problems",
      "author" : [ "T. Schiex", "H. Fargier", "G. Verfaillie" ],
      "venue" : "Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence, IJCAI 95, Montréal Québec, Canada, August 2025 1995, 2 Volumes. 631–639.",
      "citeRegEx" : "Schiex et al\\.,? 1995",
      "shortCiteRegEx" : "Schiex et al\\.",
      "year" : 1995
    }, {
      "title" : "Weakly monotonic propagators",
      "author" : [ "C. Schulte", "G. Tack" ],
      "venue" : "Principles and",
      "citeRegEx" : "Schulte and Tack,? 2009",
      "shortCiteRegEx" : "Schulte and Tack",
      "year" : 2009
    }, {
      "title" : "The theory of grammar constraints",
      "author" : [ "M. Sellmann" ],
      "venue" : "Principles and Practice of Constraint Programming - CP 2006, 12th International Conference, CP 2006, Nantes, France, September 25-29, 2006, Proceedings. 530–544.",
      "citeRegEx" : "Sellmann,? 2006",
      "shortCiteRegEx" : "Sellmann",
      "year" : 2006
    }, {
      "title" : "On global warming: Flow-based soft global constraints",
      "author" : [ "W.J. van Hoeve", "G. Pesant", "L. Rousseau" ],
      "venue" : "J. Heuristics",
      "citeRegEx" : "Hoeve et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Hoeve et al\\.",
      "year" : 2006
    }, {
      "title" : "Open constraints in a closed world",
      "author" : [ "W.J. van Hoeve", "J. Régin" ],
      "venue" : "Third International Conference,",
      "citeRegEx" : "Hoeve and Régin,? \\Q2006\\E",
      "shortCiteRegEx" : "Hoeve and Régin",
      "year" : 2006
    }, {
      "title" : "Constraint solving in uncertain and dynamic environments: A survey",
      "author" : [ "G. Verfaillie", "N. Jussien" ],
      "venue" : "Constraints 10, 3, 253–281.",
      "citeRegEx" : "Verfaillie and Jussien,? 2005",
      "shortCiteRegEx" : "Verfaillie and Jussien",
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 32,
      "context" : "Constraint Logic Programming (CLP) (Jaffar and Maher 1994) provides the ability to add variables and constraints to a constraint store during the course of an execution.",
      "startOffset" : 35,
      "endOffset" : 58
    }, {
      "referenceID" : 48,
      "context" : "This is true of configuration problems and scheduling problems that involve process-dependent activities (Mittal and Falkenhainer 1990; Barták 2003).",
      "startOffset" : 105,
      "endOffset" : 148
    }, {
      "referenceID" : 1,
      "context" : "This is true of configuration problems and scheduling problems that involve process-dependent activities (Mittal and Falkenhainer 1990; Barták 2003).",
      "startOffset" : 105,
      "endOffset" : 148
    }, {
      "referenceID" : 49,
      "context" : "Thus CLP is particularly well-suited for such problems, in contrast to compilation-based modelling languages such as MiniZinc (Nethercote et al. 2007) where all variables and constraints must be fixed at compilation time.",
      "startOffset" : 126,
      "endOffset" : 150
    }, {
      "referenceID" : 41,
      "context" : "This paper incorporates results announced in (Maher 2009c; Maher 2009b; Maher 2009d; Maher 2010).",
      "startOffset" : 45,
      "endOffset" : 96
    }, {
      "referenceID" : 40,
      "context" : "This paper incorporates results announced in (Maher 2009c; Maher 2009b; Maher 2009d; Maher 2010).",
      "startOffset" : 45,
      "endOffset" : 96
    }, {
      "referenceID" : 42,
      "context" : "This paper incorporates results announced in (Maher 2009c; Maher 2009b; Maher 2009d; Maher 2010).",
      "startOffset" : 45,
      "endOffset" : 96
    }, {
      "referenceID" : 43,
      "context" : "This paper incorporates results announced in (Maher 2009c; Maher 2009b; Maher 2009d; Maher 2010).",
      "startOffset" : 45,
      "endOffset" : 96
    }, {
      "referenceID" : 20,
      "context" : "The reader is assumed to have a basic knowledge of constraint programming, CSPs, global constraints, and filtering, as might be found in (Dechter 2003; Rossi et al. 2006; Beldiceanu et al. 2005).",
      "startOffset" : 137,
      "endOffset" : 194
    }, {
      "referenceID" : 3,
      "context" : "The reader is assumed to have a basic knowledge of constraint programming, CSPs, global constraints, and filtering, as might be found in (Dechter 2003; Rossi et al. 2006; Beldiceanu et al. 2005).",
      "startOffset" : 137,
      "endOffset" : 194
    }, {
      "referenceID" : 3,
      "context" : "These and other global constraints are discussed more completely in (Beldiceanu et al. 2005) and the references therein.",
      "startOffset" : 68,
      "endOffset" : 92
    }, {
      "referenceID" : 55,
      "context" : ", Xn]) (Régin 1994) states that the variables X1, .",
      "startOffset" : 7,
      "endOffset" : 19
    }, {
      "referenceID" : 56,
      "context" : ", Xn]) (Régin 1996) states that, for every i, the value vi occurs be-",
      "startOffset" : 7,
      "endOffset" : 19
    }, {
      "referenceID" : 50,
      "context" : ", Xn], N) (Pachet and Roy 1999) states that there are exactly N distinct values in X1, .",
      "startOffset" : 10,
      "endOffset" : 31
    }, {
      "referenceID" : 51,
      "context" : ", Xn]) (Pesant 2004) states that the value of the list of variables, when considered as a word, is accepted by the automaton A.",
      "startOffset" : 7,
      "endOffset" : 20
    }, {
      "referenceID" : 54,
      "context" : ", Xn]) (Quimper and Walsh 2006; Sellmann 2006) (called Grammar in (Quimper and Walsh 2006)) states that the value of the list of variables, when considered as a word, is generated by the context-free grammar G.",
      "startOffset" : 7,
      "endOffset" : 46
    }, {
      "referenceID" : 59,
      "context" : ", Xn]) (Quimper and Walsh 2006; Sellmann 2006) (called Grammar in (Quimper and Walsh 2006)) states that the value of the list of variables, when considered as a word, is generated by the context-free grammar G.",
      "startOffset" : 7,
      "endOffset" : 46
    }, {
      "referenceID" : 54,
      "context" : ", Xn]) (Quimper and Walsh 2006; Sellmann 2006) (called Grammar in (Quimper and Walsh 2006)) states that the value of the list of variables, when considered as a word, is generated by the context-free grammar G.",
      "startOffset" : 66,
      "endOffset" : 90
    }, {
      "referenceID" : 4,
      "context" : ", Xn], ~v) (Beldiceanu and Contejean 1994) states that any consecutive sequence of k variables Xj , .",
      "startOffset" : 11,
      "endOffset" : 42
    }, {
      "referenceID" : 2,
      "context" : ", Xn]) (Beldiceanu and Carlsson 2001) states that the sum of any consecutive sequence of k variables lies between l and u.",
      "startOffset" : 7,
      "endOffset" : 37
    }, {
      "referenceID" : 38,
      "context" : ", Xn]) (Maher 2002) states that the variables Xi take values from {0, 1} and the variables taking the value 1 are consecutive.",
      "startOffset" : 7,
      "endOffset" : 19
    }, {
      "referenceID" : 24,
      "context" : ", Zn] (Frisch et al. 2002) states that the sequence of X variables is lexicographically less than or equal to the sequence of Z variables, where we assume some ordering on the underlying values.",
      "startOffset" : 6,
      "endOffset" : 26
    }, {
      "referenceID" : 35,
      "context" : "The precedence constraint s ≺ ~ X t (Law and Lee 2004) states that if t appears in the sequence ~ X then s appears at a lower index.",
      "startOffset" : 36,
      "endOffset" : 54
    }, {
      "referenceID" : 30,
      "context" : "When it is convenient, we will describe languages with Kleene regular expressions (Hopcroft and Ullman 1979).",
      "startOffset" : 82,
      "endOffset" : 108
    }, {
      "referenceID" : 0,
      "context" : "(Barták 1999) describes a class of complex processing environments where there may be alternative processing routes, different production formulas and alternative raw materials.",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 1,
      "context" : "(Barták 2003) first formulated this issue and described a straightforward model: the constraint involves a sequence of variables to which variables may be added.",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 1,
      "context" : "(Barták 2003) outlined a generic implementation technique to make open versions for the class ofmonotonic global constraints.",
      "startOffset" : 0,
      "endOffset" : 13
    }, {
      "referenceID" : 22,
      "context" : "2 The terminology “open constraint satisfaction problem” was introduced by (Faltings and Macho-Gonzalez 2002; Faltings and Macho-Gonzalez 2005).",
      "startOffset" : 75,
      "endOffset" : 143
    }, {
      "referenceID" : 23,
      "context" : "2 The terminology “open constraint satisfaction problem” was introduced by (Faltings and Macho-Gonzalez 2002; Faltings and Macho-Gonzalez 2005).",
      "startOffset" : 75,
      "endOffset" : 143
    }, {
      "referenceID" : 27,
      "context" : "See (Gervet 1997).",
      "startOffset" : 4,
      "endOffset" : 17
    }, {
      "referenceID" : 40,
      "context" : "The third model (Maher 2009b) is, in some ways, intermediate between that of (Barták 2003) and (van Hoeve and Régin 2006).",
      "startOffset" : 16,
      "endOffset" : 29
    }, {
      "referenceID" : 1,
      "context" : "The third model (Maher 2009b) is, in some ways, intermediate between that of (Barták 2003) and (van Hoeve and Régin 2006).",
      "startOffset" : 77,
      "endOffset" : 90
    }, {
      "referenceID" : 40,
      "context" : "It is equivalent to a weak form of the model of (Maher 2009b) where there are no restrictions on N .",
      "startOffset" : 48,
      "endOffset" : 61
    }, {
      "referenceID" : 40,
      "context" : "Some results are given in (Maher 2009b) for the model treated there.",
      "startOffset" : 26,
      "endOffset" : 39
    }, {
      "referenceID" : 21,
      "context" : "Constraint programming with open constraints is a special case of dynamic CSPs in the broad sense described in (Dechter and Dechter 1988).",
      "startOffset" : 111,
      "endOffset" : 137
    }, {
      "referenceID" : 29,
      "context" : "Work on dynamic CSPs has focussed on the addition and retraction of constraints (Hentenryck and Provost 1991; Bessière 1991; Georget et al. 1999; Debruyne et al. 2003).",
      "startOffset" : 80,
      "endOffset" : 167
    }, {
      "referenceID" : 6,
      "context" : "Work on dynamic CSPs has focussed on the addition and retraction of constraints (Hentenryck and Provost 1991; Bessière 1991; Georget et al. 1999; Debruyne et al. 2003).",
      "startOffset" : 80,
      "endOffset" : 167
    }, {
      "referenceID" : 26,
      "context" : "Work on dynamic CSPs has focussed on the addition and retraction of constraints (Hentenryck and Provost 1991; Bessière 1991; Georget et al. 1999; Debruyne et al. 2003).",
      "startOffset" : 80,
      "endOffset" : 167
    }, {
      "referenceID" : 19,
      "context" : "Work on dynamic CSPs has focussed on the addition and retraction of constraints (Hentenryck and Provost 1991; Bessière 1991; Georget et al. 1999; Debruyne et al. 2003).",
      "startOffset" : 80,
      "endOffset" : 167
    }, {
      "referenceID" : 62,
      "context" : "See (Verfaillie and Jussien 2005) for a survey on dynamic constraint solving.",
      "startOffset" : 4,
      "endOffset" : 33
    }, {
      "referenceID" : 48,
      "context" : "Work on conditional CSPs, initiated in (Mittal and Falkenhainer 1990), addresses contingent variables by explicitly embedding the contingent nature within a CSP, but that work does not address the addition of variables to constraints.",
      "startOffset" : 39,
      "endOffset" : 69
    }, {
      "referenceID" : 23,
      "context" : "Other forms of dynamism have been addressed in the context of constraints by allowing variable domains to be initially incomplete and expand over time (Faltings and Macho-Gonzalez 2005; Gavanelli et al. 2005), or by formulating constraints over a stream of values (Lallouet et al.",
      "startOffset" : 151,
      "endOffset" : 208
    }, {
      "referenceID" : 25,
      "context" : "Other forms of dynamism have been addressed in the context of constraints by allowing variable domains to be initially incomplete and expand over time (Faltings and Macho-Gonzalez 2005; Gavanelli et al. 2005), or by formulating constraints over a stream of values (Lallouet et al.",
      "startOffset" : 151,
      "endOffset" : 208
    }, {
      "referenceID" : 34,
      "context" : "2005), or by formulating constraints over a stream of values (Lallouet et al. 2011).",
      "startOffset" : 61,
      "endOffset" : 83
    }, {
      "referenceID" : 18,
      "context" : "The property is akin to the “optimal substructure” property that is a pre-requisite for the use of dynamic programming in optimization problems (Cormen et al. 2001) which requires that optimal solutions of a problem also solve subproblems optimally.",
      "startOffset" : 144,
      "endOffset" : 164
    }, {
      "referenceID" : 58,
      "context" : "Complete checking can be considered a minimal requirement for filtering methods (Schulte and Tack 2009).",
      "startOffset" : 80,
      "endOffset" : 103
    }, {
      "referenceID" : 1,
      "context" : "The notion of contractibility is a variation of Barták’s monotonicity (Barták 2003) where we do not explicitly discuss variable domains.",
      "startOffset" : 70,
      "endOffset" : 83
    }, {
      "referenceID" : 39,
      "context" : "Hence it is not tied to domain-based reasoning; it is equally compatible with the more general framework of (Maher 2009a).",
      "startOffset" : 108,
      "endOffset" : 121
    }, {
      "referenceID" : 8,
      "context" : "The Slidej meta-constraint (Bessiere et al. 2008) can be used to define several constraints on a sequence of variables.",
      "startOffset" : 27,
      "endOffset" : 49
    }, {
      "referenceID" : 38,
      "context" : "For example, Contiguity is implemented in (Maher 2002) essentially as",
      "startOffset" : 42,
      "endOffset" : 54
    }, {
      "referenceID" : 8,
      "context" : "Similarly, ( ~ X ≤lex ~ Y ) is encoded in (Bessiere et al. 2008) essentially as",
      "startOffset" : 42,
      "endOffset" : 64
    }, {
      "referenceID" : 8,
      "context" : "However, it is notable that the Regular constraint is not contractible, despite the implementation in terms of Slide outlined in (Bessiere et al. 2008).",
      "startOffset" : 129,
      "endOffset" : 151
    }, {
      "referenceID" : 1,
      "context" : "This was already touched upon in (Barták 2003), where the Sum constraint ∑n i=1 Xi = N was shown to be non-monotonic, but the argument holds for a wide range of constraints.",
      "startOffset" : 33,
      "endOffset" : 46
    }, {
      "referenceID" : 3,
      "context" : "This result can be used to establish that Peak, and HighestPeak are not contractible and that NoPeak is contractible, but it also applies to many other counting and summing constraints in (Beldiceanu et al. 2005).",
      "startOffset" : 188,
      "endOffset" : 212
    }, {
      "referenceID" : 3,
      "context" : "A quick survey of (Beldiceanu et al. 2005) suggests that most current global constraints are not contractible, although we have noted several useful constraints that are contractible.",
      "startOffset" : 18,
      "endOffset" : 42
    }, {
      "referenceID" : 1,
      "context" : "However, following a proposal of (Barták 2003), we can implement an uncontractible open constraint C( ~ X) by executing a safe contractible approximation Capp of C until ~ X is closed, and then replacing Capp by C for the remainder of the execution.",
      "startOffset" : 33,
      "endOffset" : 46
    }, {
      "referenceID" : 13,
      "context" : "This improves on a result of (Brzozowski et al. 2009).",
      "startOffset" : 29,
      "endOffset" : 53
    }, {
      "referenceID" : 13,
      "context" : "It is shown in (Brzozowski et al. 2009) that this problem is PSPACE-complete.",
      "startOffset" : 15,
      "endOffset" : 39
    }, {
      "referenceID" : 13,
      "context" : "The problem is undecidable for languages defined by context-free grammars (Brzozowski et al. 2009).",
      "startOffset" : 74,
      "endOffset" : 98
    }, {
      "referenceID" : 1,
      "context" : "As discussed in (Barták 2003), a constraint ∑n i=1 Xi = N where the Xi’s must be non-negative is not monotonic but is approximated by the constraint ∑n i=1 Xi ≤ N .",
      "startOffset" : 16,
      "endOffset" : 29
    }, {
      "referenceID" : 41,
      "context" : "Some more detailed analysis of this similarity of propagators for C and Capp, for several constraints C, appears in (Maher 2009c) and (for a slightly different model of open constraint) (Maher 2009b).",
      "startOffset" : 116,
      "endOffset" : 129
    }, {
      "referenceID" : 40,
      "context" : "Some more detailed analysis of this similarity of propagators for C and Capp, for several constraints C, appears in (Maher 2009c) and (for a slightly different model of open constraint) (Maher 2009b).",
      "startOffset" : 186,
      "endOffset" : 199
    }, {
      "referenceID" : 1,
      "context" : "Recall that under Barták’s proposal (Barták 2003), a closed propagator for Capp is dynamised to handle extensions of the sequence of variables (possibly through his generic dynamisation).",
      "startOffset" : 36,
      "endOffset" : 49
    }, {
      "referenceID" : 53,
      "context" : "We consider “soft” global constraints in the style of (Petit et al. 2001).",
      "startOffset" : 54,
      "endOffset" : 73
    }, {
      "referenceID" : 53,
      "context" : "6 Also called violation cost (Petit et al. 2001).",
      "startOffset" : 29,
      "endOffset" : 48
    }, {
      "referenceID" : 42,
      "context" : "There are three broad classes of violation measures (Maher 2009d): those based on constraint decomposition, edit distance, and graph properties.",
      "startOffset" : 52,
      "endOffset" : 65
    }, {
      "referenceID" : 5,
      "context" : "The richness of the graph property framework (Beldiceanu and Petit 2004) makes it difficult to obtain broad results on contractibility.",
      "startOffset" : 45,
      "endOffset" : 72
    }, {
      "referenceID" : 42,
      "context" : "A somewhat narrow sufficient condition for contractability of soft constraints defined by graph property-based violation measures is presented in (Maher 2009d).",
      "startOffset" : 146,
      "endOffset" : 159
    }, {
      "referenceID" : 9,
      "context" : "Many hard constraints can be decomposed into elementary constraints, whether naturally (such as the decomposition of AllDifferent into disequalities) or by a construction, as in (Bessiere et al. 2009).",
      "startOffset" : 178,
      "endOffset" : 200
    }, {
      "referenceID" : 53,
      "context" : "We define a general class of decompositionbased violation measures that includes as special cases: primal graph based violation costs (Petit et al. 2001), decomposition-based violation measures of (van Hoeve et al.",
      "startOffset" : 134,
      "endOffset" : 153
    }, {
      "referenceID" : 53,
      "context" : "2006), the value-based violation measure for GCC (Petit et al. 2001; van Hoeve et al. 2006), the measures used for the soft Sequence constraint (Maher et al.",
      "startOffset" : 49,
      "endOffset" : 91
    }, {
      "referenceID" : 44,
      "context" : "2006), the measures used for the soft Sequence constraint (Maher et al. 2008) and the soft Cumulative constraint (Petit and Poder 2009), the weighted measures for AllDifferent and GCC (Métivier et al.",
      "startOffset" : 58,
      "endOffset" : 77
    }, {
      "referenceID" : 52,
      "context" : "2008) and the soft Cumulative constraint (Petit and Poder 2009), the weighted measures for AllDifferent and GCC (Métivier et al.",
      "startOffset" : 41,
      "endOffset" : 63
    }, {
      "referenceID" : 46,
      "context" : "2008) and the soft Cumulative constraint (Petit and Poder 2009), the weighted measures for AllDifferent and GCC (Métivier et al. 2007; Métivier et al. 2009), and the class of decomposition-based measures discussed in (Maher 2009d).",
      "startOffset" : 112,
      "endOffset" : 156
    }, {
      "referenceID" : 47,
      "context" : "2008) and the soft Cumulative constraint (Petit and Poder 2009), the weighted measures for AllDifferent and GCC (Métivier et al. 2007; Métivier et al. 2009), and the class of decomposition-based measures discussed in (Maher 2009d).",
      "startOffset" : 112,
      "endOffset" : 156
    }, {
      "referenceID" : 42,
      "context" : "2009), and the class of decomposition-based measures discussed in (Maher 2009d).",
      "startOffset" : 66,
      "endOffset" : 79
    }, {
      "referenceID" : 9,
      "context" : "For example, it permits using the decomposition of AllDifferent( ~ X) into disequalities when | ~ X| is odd, and a decomposition from (Bessiere et al. 2009) (see Example 6) when | ~ X| is even.",
      "startOffset" : 134,
      "endOffset" : 156
    }, {
      "referenceID" : 11,
      "context" : "This definition was inspired by the formulation of hierarchical constraints in (Borning et al. 1992; Borning et al. 1989).",
      "startOffset" : 79,
      "endOffset" : 121
    }, {
      "referenceID" : 12,
      "context" : "This definition was inspired by the formulation of hierarchical constraints in (Borning et al. 1992; Borning et al. 1989).",
      "startOffset" : 79,
      "endOffset" : 121
    }, {
      "referenceID" : 53,
      "context" : "The violation counting decomposition measures of (Petit et al. 2001; van Hoeve et al. 2006) can be obtained when the error function e(v, c) returns 0 if v satisfies c and 1 otherwise, and the combining function is summation.",
      "startOffset" : 49,
      "endOffset" : 91
    }, {
      "referenceID" : 53,
      "context" : "The value-based measures of (Petit et al. 2001; van Hoeve et al. 2006; Maher et al. 2008; Petit and Poder 2009) also use summation as the combining function, but use an error function that returns the amount by which the constraint c is violated by the valuation v.",
      "startOffset" : 28,
      "endOffset" : 111
    }, {
      "referenceID" : 44,
      "context" : "The value-based measures of (Petit et al. 2001; van Hoeve et al. 2006; Maher et al. 2008; Petit and Poder 2009) also use summation as the combining function, but use an error function that returns the amount by which the constraint c is violated by the valuation v.",
      "startOffset" : 28,
      "endOffset" : 111
    }, {
      "referenceID" : 52,
      "context" : "The value-based measures of (Petit et al. 2001; van Hoeve et al. 2006; Maher et al. 2008; Petit and Poder 2009) also use summation as the combining function, but use an error function that returns the amount by which the constraint c is violated by the valuation v.",
      "startOffset" : 28,
      "endOffset" : 111
    }, {
      "referenceID" : 11,
      "context" : "If we use maximization or the sum of squares in place of summation we have new violation measures similar to the worst-case-better and least-squares-better comparators of (Borning et al. 1992; Borning et al. 1989).",
      "startOffset" : 171,
      "endOffset" : 213
    }, {
      "referenceID" : 12,
      "context" : "If we use maximization or the sum of squares in place of summation we have new violation measures similar to the worst-case-better and least-squares-better comparators of (Borning et al. 1992; Borning et al. 1989).",
      "startOffset" : 171,
      "endOffset" : 213
    }, {
      "referenceID" : 14,
      "context" : "Covering has some similarity to characterizations of containment of conjunctive relational database queries (Chandra and Merlin 1977), (constraint) logic programming rule subsumption (Maher 1988; Maher 1993), and sufficient conditions for query containment under bag semantics (Chaudhuri and Vardi 1993; Ioannidis and Ramakrishnan 1995).",
      "startOffset" : 108,
      "endOffset" : 133
    }, {
      "referenceID" : 36,
      "context" : "Covering has some similarity to characterizations of containment of conjunctive relational database queries (Chandra and Merlin 1977), (constraint) logic programming rule subsumption (Maher 1988; Maher 1993), and sufficient conditions for query containment under bag semantics (Chaudhuri and Vardi 1993; Ioannidis and Ramakrishnan 1995).",
      "startOffset" : 183,
      "endOffset" : 207
    }, {
      "referenceID" : 37,
      "context" : "Covering has some similarity to characterizations of containment of conjunctive relational database queries (Chandra and Merlin 1977), (constraint) logic programming rule subsumption (Maher 1988; Maher 1993), and sufficient conditions for query containment under bag semantics (Chaudhuri and Vardi 1993; Ioannidis and Ramakrishnan 1995).",
      "startOffset" : 183,
      "endOffset" : 207
    }, {
      "referenceID" : 16,
      "context" : "Covering has some similarity to characterizations of containment of conjunctive relational database queries (Chandra and Merlin 1977), (constraint) logic programming rule subsumption (Maher 1988; Maher 1993), and sufficient conditions for query containment under bag semantics (Chaudhuri and Vardi 1993; Ioannidis and Ramakrishnan 1995).",
      "startOffset" : 277,
      "endOffset" : 336
    }, {
      "referenceID" : 31,
      "context" : "Covering has some similarity to characterizations of containment of conjunctive relational database queries (Chandra and Merlin 1977), (constraint) logic programming rule subsumption (Maher 1988; Maher 1993), and sufficient conditions for query containment under bag semantics (Chaudhuri and Vardi 1993; Ioannidis and Ramakrishnan 1995).",
      "startOffset" : 277,
      "endOffset" : 336
    }, {
      "referenceID" : 38,
      "context" : "Example 4 Contiguity is implemented in (Maher 2002) essentially by the decomposition",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 9,
      "context" : ") A second example is given by a decomposition ofAllDifferent given in (Bessiere et al. 2009).",
      "startOffset" : 71,
      "endOffset" : 93
    }, {
      "referenceID" : 33,
      "context" : "constraints) (Klug 1988; Maher 1993).",
      "startOffset" : 13,
      "endOffset" : 36
    }, {
      "referenceID" : 37,
      "context" : "constraints) (Klug 1988; Maher 1993).",
      "startOffset" : 13,
      "endOffset" : 36
    }, {
      "referenceID" : 53,
      "context" : "This class includes the variable-based violation measures (Petit et al. 2001; van Hoeve et al. 2006), since such measures are simply edit distances where substitution is the only edit operation.",
      "startOffset" : 58,
      "endOffset" : 100
    }, {
      "referenceID" : 5,
      "context" : "The object-based measures of (Beldiceanu and Petit 2004) are edit distances where deletion is the only edit operation.",
      "startOffset" : 29,
      "endOffset" : 56
    }, {
      "referenceID" : 42,
      "context" : "The property that each letter is edited at most once is important for network flow implementations of propagators such as the propagators for soft Regular in (van Hoeve et al. 2006; Maher 2009d).",
      "startOffset" : 158,
      "endOffset" : 194
    }, {
      "referenceID" : 53,
      "context" : "Thus the variable-based measures (Petit et al. 2001; van Hoeve et al. 2006), the object-based measures (Beldiceanu and Petit 2004), and the edit-based measures of (van Hoeve et al.",
      "startOffset" : 33,
      "endOffset" : 75
    }, {
      "referenceID" : 5,
      "context" : "2006), the object-based measures (Beldiceanu and Petit 2004), and the edit-based measures of (van Hoeve et al.",
      "startOffset" : 33,
      "endOffset" : 60
    }, {
      "referenceID" : 9,
      "context" : "It employs a decomposition of the global cardinality constraintGCC given in (Bessiere et al. 2009).",
      "startOffset" : 76,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "To define the decomposition of (Bessiere et al. 2009) we need to introduce variables Ailu of type {0, 1} and Nlu of type non-negative integers, and elementary constraints as follows.",
      "startOffset" : 31,
      "endOffset" : 53
    }, {
      "referenceID" : 28,
      "context" : "It is demonstrated in (He et al. 2013) that using an approximation of the violation measure of a closed edit-based soft constraint can lead to incorrect answers to constraint problems.",
      "startOffset" : 22,
      "endOffset" : 38
    }, {
      "referenceID" : 40,
      "context" : "In (Maher 2009b) a dual notion to contractibility, called extensibility, is investigated.",
      "startOffset" : 3,
      "endOffset" : 16
    }, {
      "referenceID" : 57,
      "context" : "For example, the Valued CSP (Schiex et al. 1995) and the Semi-Ring CSP (Bistarelli et al.",
      "startOffset" : 28,
      "endOffset" : 48
    }, {
      "referenceID" : 10,
      "context" : "1995) and the Semi-Ring CSP (Bistarelli et al. 1997) frameworks define a soft constraint essentially as a function from valuations to an ordered set (the set may be partially ordered in the case of SCSPs) that might be considered a violation measure.",
      "startOffset" : 28,
      "endOffset" : 52
    }, {
      "referenceID" : 46,
      "context" : "Weighted violation measures are used in (Métivier et al. 2007; Métivier et al. 2009).",
      "startOffset" : 40,
      "endOffset" : 84
    }, {
      "referenceID" : 47,
      "context" : "Weighted violation measures are used in (Métivier et al. 2007; Métivier et al. 2009).",
      "startOffset" : 40,
      "endOffset" : 84
    }, {
      "referenceID" : 46,
      "context" : "As noted earlier, the decomposition measures presented here generalize the weighted decomposition measures for Σ-AllDifferent and Σ-GCC (Métivier et al. 2007; Métivier et al. 2009).",
      "startOffset" : 136,
      "endOffset" : 180
    }, {
      "referenceID" : 47,
      "context" : "As noted earlier, the decomposition measures presented here generalize the weighted decomposition measures for Σ-AllDifferent and Σ-GCC (Métivier et al. 2007; Métivier et al. 2009).",
      "startOffset" : 136,
      "endOffset" : 180
    }, {
      "referenceID" : 46,
      "context" : "However, the edit-based violation measures presented here do not generalize the weighted edit distance for Σ-AllDifferent and Σ-Regular of (Métivier et al. 2007; Métivier et al. 2009).",
      "startOffset" : 139,
      "endOffset" : 183
    }, {
      "referenceID" : 47,
      "context" : "However, the edit-based violation measures presented here do not generalize the weighted edit distance for Σ-AllDifferent and Σ-Regular of (Métivier et al. 2007; Métivier et al. 2009).",
      "startOffset" : 139,
      "endOffset" : 183
    }, {
      "referenceID" : 45,
      "context" : "Violation measures play a similar role to query measures (Maher and Stuckey 1989) that were used to specify preferences on query solutions in a CLP system.",
      "startOffset" : 57,
      "endOffset" : 81
    }, {
      "referenceID" : 45,
      "context" : "In this context, contractible violation measures are similar to pruning measures in (Maher and Stuckey 1989) in that both are non-decreasing functions, although over different domains, and both permit the safe pruning of search trees.",
      "startOffset" : 84,
      "endOffset" : 108
    }, {
      "referenceID" : 7,
      "context" : "Contractible global soft constraints are amenable to a nested representation (Bessiere et al. 2014) in a distributed constraint optimization setting, which has significant performance gains over other representations (Bessiere et al.",
      "startOffset" : 77,
      "endOffset" : 99
    }, {
      "referenceID" : 7,
      "context" : "2014) in a distributed constraint optimization setting, which has significant performance gains over other representations (Bessiere et al. 2014).",
      "startOffset" : 123,
      "endOffset" : 145
    }, {
      "referenceID" : 15,
      "context" : "Finally, we note that the semantics of soft constraints are examples of quantitative languages, in the terminology of (Chatterjee et al. 2010).",
      "startOffset" : 118,
      "endOffset" : 142
    }, {
      "referenceID" : 15,
      "context" : "However, (Chatterjee et al. 2010) focuses on languages of infinite words defined via automata, so the results of (Chatterjee et al.",
      "startOffset" : 9,
      "endOffset" : 33
    }, {
      "referenceID" : 15,
      "context" : "2010) focuses on languages of infinite words defined via automata, so the results of (Chatterjee et al. 2010) do not seem to have application to the subject of this paper.",
      "startOffset" : 85,
      "endOffset" : 109
    }, {
      "referenceID" : 17,
      "context" : "In (Colcombet 2009) a notion of cost function on languages of finite words is used but this is only used to define equivalence classes and is not related to this paper.",
      "startOffset" : 3,
      "endOffset" : 19
    } ],
    "year" : 2017,
    "abstractText" : "Open forms of global constraints allow the addition of new variables to an argument during the execution of a constraint program. Such forms are needed for difficult constraint programming problems where problem construction and problem solving are interleaved, and fit naturally within constraint logic programming. However, in general, filtering that is sound for a global constraint can be unsound when the constraint is open. This paper provides a simple characterization, called contractibility, of the constraints where filtering remains sound when the constraint is open. With this characterization we can easily determine whether a constraint has this property or not. In the latter case, we can use it to derive a contractible approximation to the constraint. We demonstrate this work on both hard and soft constraints. In the process, we formulate two general classes of soft constraints. Under consideration in Theory and Practice of Logic Programming (TPLP).",
    "creator" : "LaTeX with hyperref package"
  }
}