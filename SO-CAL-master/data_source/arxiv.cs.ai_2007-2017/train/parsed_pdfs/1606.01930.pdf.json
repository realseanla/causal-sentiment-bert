{
  "name" : "1606.01930.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Consistency and Trust in Peer Data Exchange Systems",
    "authors" : [ "LEOPOLDO BERTOSSI", "LORETO BRAVO" ],
    "emails" : [ "bertossi@scs.carleton.ca", "bravo@udd.cl" ],
    "sections" : [ {
      "heading" : "To appear in Theory and Practice of Logic Programming (TPLP).",
      "text" : "KEYWORDS: Peer data exchange, answer set programs, disjunctive stable model semantics, metadata management, schema mappings, relational databases, integrity constraints, database repairs, consistency."
    }, {
      "heading" : "1 Introduction",
      "text" : "A peer data exchange system (PDES) (also known as a peer data management system) can be conceived as a finite set P = {P1, . . . , Pn} of peers, each of them owning a local relational schema and a database instance. When a peer P receives a query, in order to answer it, P’s data is completed or modified according to relevant data that other peers may have. For this to be possible, P has to be directly related to some neighbor peers Q through sets, Σ(P, Q), of logical mappings or data exchange\n∗ Contact author.\nar X\niv :1\n60 6.\n01 93\n0v 1\n[ cs\n.D B"
    }, {
      "heading" : "2 L. Bertossi, L. Bravo",
      "text" : "constraints (DECs), from P to Q. They are first-order sentences expressed in terms of the elements of the database schemas of P and Q. In their turn, P’s neighbors may have their own neighbors, who through their data may, transitively and eventually, have an impact on P’s data as well.\nDECs between two peers are expected to be satisfied by the combination of the two local instances. In this sense, DECs act as integrity constraints (ICs) on the combination of two schemas and their instances. However, they are not forced to be satisfied, and there is no mechanism in place for maintaining them. Actually, it is the inconsistency of a DEC that will enable the movement of data between peers, at query-answering time: When a peer P receives a query, it examines its DECs, on that basis poses queries to its neighbors, who return consistent data to P. P also queries its own database. If its DECs are not satisfied by the collected data, P, after a -possibly virtual- consistency repair process, composes a consistent answer to the original query. A peer’s answering of a query received from an external user or another peer triggers an iterative process of interleaved consistency checking of DECs with respect to the data at hand, and the repair of the latter if necessary.\nThis movement of data among peers is used for query answering, but not for updating the local physical instances with the purpose of having the DECs satisfied. Of course, this could be done by a peer who receives data from other peers, if it decides to do so. However, it is not the goal of data exchange in such a system to have all the instances synchronized and globally satisfying the DECs. Peers are autonomous, their instances are possibly being independently updated, and other peers are not expected to be aware of that. DECs constrain and trigger data exchange through their inconsistency, which is detected and resolved locally, by a single peer, namely the one who owns those DECs. We do not assume any kind of central or global coordination; nor that any two neighbors interact for DEC evaluation.\nA peer P that is answering a query may, at query-answering time, import data from its neighbors, to complement its data and/or ignore part of its own data. The way a peer uses the imported data of course depends on its DECs, but also on the trust relationships to its neighbors: A peer P may trust its data the same as or less than a neighbor’s data. As a consequence, in our PDESs, data exchange is driven by inconsistency and constrained by trust.\nExample 1.1 Peers P1 and P2 have relational schemas S(P1) = {R1(·, ·, ·),S 1(·)}, and S(P2) = {R2(·, ·),S 2(·, ·)}. Here, P1 is connected to peer P2 by P1’s set of DECs:\nΣ(P1, P2) = {∀x∀y(R2(x , y) ∧ S 2(y , z )→ R1(x , y , z )), ∀x (S 1(x )→ S 2(5, x ))}·\nThese DECs belong to P1; and P2 may not even be aware of them. Let’s assume that P1 trusts P2 more than itself. The existence of DECs from P1 to P2, and the trust relationship are indicated in Figure 1 by the labeled arrow from one instance to the other.\nWe can see that the DECs are not satisfied by the combined instance, which is\nperfectly acceptable; we do not have to do anything.\nFig. 1. A simple PDES\nP1 R1\nc 4 2 f 3 5 d 5 3\nS1\n3\nR2\nc 4 d 5\nS2\n4 2 5 3\nP2\nFig. 2. A neighborhood solution instance for P1\ndo not have to do anything. Now, a query is posed to P1, e.g. Q1(x) : ∃yzR1(x, y, z). In order to answer it, P1 has to adjust its own data, so that the DECs with P2 are satisfied. In order to do this, P1 will ask P2 for its data, issuing to P2 queries in P2’s language, namely Q121 : R2(x, y) and Q122 : S2(x, y). Although P1 does not need the whole extensions of P2’s tables, using this coarse queries will allow us to better illustrate the solution instances for each peer, are they are not defined by a particular query at hand. Notice that, at this stage and from the point of view of P2, the queries Q121 and Q122 can be considered as queries posed by an external user, as the queryQ1 received by P1.\nSince P2 has no DECs to other peers, it will return to P1 its physical data, without any modification, as query answers. In this case, P2’s current instance is its only solution instance. Now P1, confronted with a combined instance, can detect that the first DEC is not satisfied, because the tuple 〈d, 5, 3〉 is not in R1. Nor the second DEC, because the tuple 〈5, 7〉 is not in S2.\nSince P1 trusts P2’s data more than its own, the inconsistencies are locally solved by P1 by adding 〈d, 5, 3〉 to R1, and removing tuple 〈7〉 from S1. These changes can be only virtual and for query answering purposes. In this case, there is only one neighborhood solution (instance) centered around P1, i.e. for the combined schema of itself and its neighbors. It is shown in Fig. 2. The restriction of this neighborhood solution to P1’s schema is the solution instance for P1, and it is used to answer the initial query posed to P1. Thus, the answers to Q1 are 〈c〉, 〈f〉, 〈d〉. 2\nIt is not difficult to realize that in other situations, a peer P might have several neighborhood solutions, leading to also possibly several (local) solution instances. The answers returned by P (to an external user or another peer) will be the peer consistent answers, i.e. those that are shared (or returned) by all the different solution instances for P. That is, a cautions (a.k.a. skeptical or certain) semantics is applied to query answering.\nWe should also emphasize that, in the example above, the semantic conflicts related to the DECs were solved by performing a minimal set of virtual changes on the database relations. Without making specific commitments about the notion\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nFig. 2. A neighborhood solution instance for P1\nNow, assume that the qu ry Q(x ) : ∃yzR1(x , y , z ) is posed to P1. In order to\nanswer it, P1 notices through the DECs that P2’s schema is related to its predicate R1. Accordingly, P1 has to adjust its own data, so that the DECs with P2 are satisfied. In order to do this, P1 requests P2’s data, by issuing to P2 atomic queries in P2’s language, namely Q1(x , y) : R2(x , y) and Q2(x , y) : S 2(x , y).1 Notice that, at this stage and from the point of view of P2, the queries Q1 and Q2 can be considered as queries posed by an external user, so as query Q was posed to P1.\nSince P2 has neither DECs to other peers nor local ICs, it will return to P1 its physical data, without any modification, as query answers. Now P1, confronted with a combined instance, can detect that the first DEC is not satisfied, because the tuple R1(d , 5, 3) is not in R1. Nor the second DEC, because the tuple S 2(5, 7) is not in S 2.\nSince P1 trusts P2’s data more than its own, the inconsistencies are locally solved by P1 by inserting R1(d , 5, 3) into R1, and deleti g tuple S 1(7) from S 1. These changes c uld be only virtual, and for the purpose of answering the query at hand. In this case, P1 has a single neighborhood solution (instance), th t is, an instanc for the combined schema that satisfies the DECs, an in some sense, minimally departs from th (inconsistent) instance that had been formed at P1’ neighborhood. This neighborhood solution for P1 is shown in Figure 2. The restriction of this instance to P1’s schema is a solution (instance) for P1, and is used to answer the initial query posed to P1. Thus, the answers to Q are 〈c〉, 〈f 〉, 〈d〉. 2\nIn the example, for illustration purposes, we used a particular and well-known repair semantics, i.e. a particular way of restoring consistency on a database that does n t satisfy a given set of ICs,2 while still staying “as close as possible” to the given, inconsistent instance. In th s case, repairs minimize, under set inclusio , the set of tuples that are deleted or inserted (Arenas et al. 1999). Repair semantics come with their minimality criteria. (Cf. (Bertossi 2011) for a general discussion of\n1 Actually, P1 does not need the whole extensions of P2’s tables. However, asking for P2’s whole tables allow us to better illustrate our general approach. 2 We emphasize that DECs can be seen as ICs on combined schemas and instances."
    }, {
      "heading" : "4 L. Bertossi, L. Bravo",
      "text" : "repair semantics, and for references to different repair semantics.) In this work we will introduce, investigate and use a variation of the repair semantics used in the example.\nIn some cases, a peer P may have several neighborhood solutions, leading to also possibly several (local) solution instances. The answers returned by P (to an external user or another peer) will be the peer consistent answers, i.e. those that are shared (or returned) by all the different solution instances for P. That is, a cautious (also known as skeptical or certain) semantics is applied to query answering (Brewka et al. 2011; Leone et al. 2006). The same do P’s neighbors, who may have solutions of their own, when they hand over their data to P: They give away their own peer-consistent data.\nThe notion of solution instance for a peer is used as an auxiliary notion, to characterize the semantically correct answers from P’s point of view. When trying to correctly answer a query, we try to avoid, as much as possible, the generation of material solutions instances. Ideally, a peer would compute its peer consistent answers to a user query just by querying the already available local instances, and dealing with the involved DECs on-the-fly, at query answering time.\nIn this work we formalize these ideas, by first providing a general semantic framework for PDESs and their solution-semantics. It captures in abstract terms, and in this order, the notions of: (a) PDES, including a broad and useful syntactic class of DECs; (b) neighborhood solution for a peer, appealing to an abstract repairsemantics that involves trust relationships; (c) solution for a peer, a recursive concept due to a possible (always finite) chain of peers building each, one after another, neighborhood solutions; and (d) peer-consistent answer.\nThe result is a formal semantics for a system of peers who exchange data for query answering. It is a model-theoretic possible-world semantics that characterizes the class of intended instances for a peer, the above mentioned solutions. The expected answers from a peer are certain with respect to that class, i.e. true in all of them.\nNext, as a second main subject, we instantiate the general semantic framework, and introduce and investigate a specific repair (or solution) semantics for PDESs. We do so by making some specific commitments and assumptions: (a) Database instances may have null values as those used in SQL relational databases. (b) Those null values behave and are handled as in DBMSs that (at least partially) comply with the SQL Standard, in particular with respect to IC satisfaction and query answering. (c) The null-based solution semantics that we introduce heavily depends on the presence of nulls à la SQL, and on the use of nulls to restore consistency. (d) This null-based repair semantics comes with its own minimality criterion. (e) Query answering, and DEC and IC satisfaction follow a a logic in databases with null à la SQL that we formalize for conjunctive queries and a broad class of DECs and ICs.\nFor the gist, the null-based repair semantics we adopt does not allow, for example, to introduce a null value to satisfy a join, such as that with the existential z in the DEC ∀x∀y(R(x , y)→ ∃z (S (x , z ) ∧ T (z , y))). In this case, a tuple deletion from R will be preferred. However, a null can be used for variable z in a tuple inserted to satisfy the DEC ∀x∀y(R(x , y)→ ∃zS (x , z )) (a deletion from R is also possible).\nConsistency and Trust in Peer Data Exchange Systems 5\nOur decision to consider null values, as used in SQL relational database systems, for single database repairs and solutions in PDESs is based upon and motivated by the facts that: (a) In this way our research becomes close to database practice; (b) it can be made compatible with and applicable in that practice; (c) SQL DBMSs implicitly implement a sort of null-based repair semantics (when maintaining ICs); (d) that “repair semantics” deserves a theoretical investigation; and (e) at least a sizeable part of the SQL standard and practice can be be put on solid logical grounds. Actually, we are able to bring into this research essentially all the classes of integrity constraints and logical mappings that are used in both database practice and research, and to treat them according to the just mentioned null-based SQL semantics.\nWe emphasize, however, that our abstract framework is sufficiently modular and flexible to adopt alternative repair semantics for dealing with inconsistency and incompleteness of data.\nWe see our work also as a contribution to the subjects of repairs and consistent query answering for single relational databases. Repairs based on the use of nulls; actually a single one with a semantics in the style of SQL -which we also logically formalize in this work- had been presented in preliminary form in (Bravo and Bertossi 2006; Bravo 2007). Here, we provide an extended and definitive formulation, and we apply it to peer data exchange.\nWe also investigate complexity-theoretic and algorithmic issues related to the solution semantics. More specifically, we show that deciding if a neighborhood instance is a neighborhood solution for a peer is coNP -complete in data, and deciding if a tuple is a peer consistent answer to a local query is ΠP2 -complete in data. We investigate a particular, important and common case of the PDES semantics, where peers just import data from other peers to complete their own data set, without giving semantic priority to the latter. This leads to a reduction in data complexity for the solution checking problem.\nFinally, we show that the null-based, model-theoretic semantics for PDESs can be captured by means of disjunctive logic programs with stable model semantics (Gelfond and Lifschitz 1991), also known as answer set programs (ASPs) (Brewka et al. 2011). More specifically, we establish an explicit correspondence between the solutions for a peer and the stable models of the program, obtaining, in this way, a declarative semantics for PDESs that can also be made executable.\nIn relation to most immediately related work, the idea of peer consistent query answering resembles that of consistent query answering (CQA) in databases (Arenas et al. 1999): Consistent answers to a query posed to a database that may be inconsistent with respect to certain ICs are invariant under all repairs, i.e. the minimally repaired and consistent versions of the original instance. Furthermore, there are mechanisms for computing consistent answers that avoid or minimize the physical generation of repairs. Logic programs for specifying database repairs as their stable models have been proposed and investigated in (Arenas et al. 2003; Greco et al. 2003; Barcelo and Bertossi 2003; Caniupan and Bertossi 2010). Cf. (Bertossi 2011; Bertossi 2006; Chomicki 2007) for recent surveys of CQA.\nOur work can be classified among those on semantic and schema-based ap-"
    }, {
      "heading" : "6 L. Bertossi, L. Bravo",
      "text" : "proaches to peer-to-peer data management systems (Halevy et al. 2003; Halevy et al. 2004; Calvanese et al. 2004; Franconi et al. 2004; Bertossi and Bravo 2004b; Calvanese et al. 2005; Fuxman et al. 2006). The emphasis is on specifying the intended and legal database instances behind a system of peers who are connected with each other by means of schema mappings.\nDifferent notions and forms of trust have been considered in P2P information sharing systems (Demolombe 2011; Sabater and Sierra 2005; Artz and Gil 2007; Marti and Garcia-Molina 2006) (cf. the special issue (Boutaba and Marshall 2006)), but not much in the context of semantic PDESs, where the trust relationships between peers are used to essentially modulate or qualify the use of the data exchange constraints between peers. Our emphasis is on the integration of trust and data exchange constraints, with a notion of trust that is closer to the notion of relative reputation or reliability of a peer as a source of information, in relation to the quality of its data (Marti and Garcia-Molina 2006). In this work, trust relationships are given, and not computed or updated (Jøsang et al. 2006; Jøsang et al. 2012).\nThis paper is structured as follows. Section 2 provides technical preliminaries and basic elements of PDESs. Section 3 introduces a general semantic framework for PDESs. Section 4, in preparation for the introduction of what will be the official, concrete peer-solution semantics, discusses and formalizes database instances with null values as used in SQL. It also formulates query answering and integrity satisfaction in those databases. Section 5 instantiates the abstract semantic framework proposed in Section 3 by introducing a particular consistency restoration semantics based on the use of null values. This section also investigates the complexity of some computational problems. Section 6 captures the semantics of the previous section in terms of logic programs with stable model semantics. In Section 7 we discuss related work. In Section 8 some final conclusions are drawn. The electronic Appendix A discusses several additional and alternative approaches and issues with respect to the previously introduced general and specific semantics. The electronic Appendix B gives proofs of our main results. This work considerably extends and develops the semantics for PDESs first suggested in (Bertossi and Bravo 2004b), and further developed in (Bertossi and Bravo 2007)."
    }, {
      "heading" : "2 The Basic PDES Scenario",
      "text" : "Every peer in a PDES will have a local relational schema with a local relational instance. For this reason, we recall first some basic notions from relational databases. A relational schema S consists of a set of relational predicates. A relational predicate R ∈ S with arity n and attributes A1, · · ·,An , is commonly denoted with R(A1, . . . ,An), or sometimes simply R(·, . . . , ·). Each attribute A of (a predicate in) S has a possibly infinite data domain, Dom(A). In general, we will denote with U the union of the attribute domains, obtaining a single, possibly infinite data domain.\nIn addition to the database predicates in a relational schema S, we have a set B of built-in predicates (that have a fixed semantics), e.g. comparison predicates, such as =, 6=, <, etc. We assume that B contains the propositional predicate false\nConsistency and Trust in Peer Data Exchange Systems 7\nthat is always false. (Later on, we will introduce some additional, specific, built-in predicates.)\nThe predicates of the relational schema S plus those in B (that we leave implicit), and the constants in U determine a language L(S) of first-order predicate logic. The schema may also contain integrity constraints, that are sentences of L(S).\nAn instance D for a schema S is a finite set of a ground atoms of the form R(c̄), where R(A1, . . . ,An) ∈ S has some arity n, and c̄ = 〈c1, . . . , cn〉, with ci ∈ Dom(Ai). For each n-ary predicate R ∈ S, an instance D for S determines an extension for R that is a finite n-ary relation over the data domain. If t ∈ D we denote by t [Ā] the sequence of values in t̄ for attributes A ∈ Ā. Given an instance D , the active domain of D , denoted, Adom(D), is the finite subset of ⋃ ADom(A) that contains all the constants that appear in relations in D .\nIf S ′ is a subschema of S, i.e. contains some of the relational predicates in S, and D is an instance for S, then D S ′ denotes the restriction of D to S ′, i.e. D S ′ = {R(t̄) | R ∈ S ′ and R(t̄) ∈ D}.\nA database instance D for the schema S serves then as an interpretation for the language L(S). If D is an instance for S, and Ψ is a set of sentences of L(S), then D |= Ψ denotes that D satisfies (makes true) all the sentences in Ψ. If Ψ is the set of integrity constraints that comes with the schema S and D |= Ψ, we say that D is consistent. Otherwise, D is inconsistent.3\nA query Q(x̄ ) is a formula of a language L(S), where x̄ is the list of free variables. A sequence of constants c̄ is an answer to Q(x̄ ) in instance D for S if D |= Q[c̄], i.e. the formula becomes true in D when the variables in x̄ are replaced by the corresponding constants in c̄. When x̄ is empty, the query Q is a Boolean query, i.e. a sentence. In this case, the answer in D can be yes or no depending on whether it is true or not in D , denoted D |= Q, resp. D 6|= Q. Now we introduce some of the elements that will form a peer data exchange system (PDES). After introducing them we will give the formal definition of a PDES (cf. Definitions 2.1 and 2.2 below).\nA (PDES) contains a finite set P = {P1, . . . , Pn} of peers. Each peer P owns a relational database schema S(P), and a database instance D(P) for the schema S(P). We denote with S the set of all schemas of a PDES, that is, S = {S(P1), . . . ,S(Pn)}. We assume, to simplify the presentation and, without loss of generality, that the peers’ schemas are mutually disjoint, but share a common, possibly infinite database domain U . Each D(P) can be seen as a finite set of ground atoms over U , with predicates in S(P). It holds, Adom(D(P)) ⊆ U .\nThe peers’ schemas, or unions thereof, determine first-order languages, e.g. L(P), L(P, Q), which are L(S(P)) and L(S(P) ∪ S(Q)), resp. A data exchange constraint (DEC) between peers P, Q is an L(P, Q)-sentence. We will consider the following two syntactic classes of DECs:\n3 In this work, whenever we consider sets Σ of integrity constraints, we assume that Σ is logically consistent."
    }, {
      "heading" : "8 L. Bertossi, L. Bravo",
      "text" : "(a) A universal data exchange constraint (UDEC) between peers P, Q is an L(P, Q)sentence of the form:\n∀x̄ ( n∧\ni=1\nRi(x̄i) −→ l∧\nk=1\n(\nm∨\nj=1\nQkj (ȳkj ))), (1)\nwhere the Ri are predicates in S(P)∪S(Q), the Qkj are atomic formulas with predicates in S(P) ∪ S(Q) or atoms with predicates in B, x̄ = ⋃ni=1 x̄i , and ȳkj ⊆ x̄ .\n(b) A referential data exchange constraint (RDEC) between peers P, Q is an\nL(P, Q)-sentence of the form:\n∀x̄ ( n∧\ni=1\nRi(x̄i) −→ ∃ȳ( l∧\nk=1\nQk (x̄k , ȳk ) ∧ ϕk (x̄ ′k , ȳ ′k )) ∨ϕ(x̄ )), (2)\nwhere the Ri ,Qk are predicates in S(P) ∪ S(Q), ϕk and ϕ are a conjunction, resp. a disjunction, of atoms with predicates in B, and x̄i , x̄k ⊆ x̄ , x̄ ′k ⊆ x̄k , ȳ ′k ⊆ ȳk , and ȳ = ⋃l k=1 ȳk 6= ∅. The formulas ϕk (x̄ ′ k , ȳ ′ k )) are used to impose conditions on the existential values, and ϕ for conditions on the values for x̄ in the antecedent.\nThe classes of exchange constraints that we are considering are broad enough to capture all the relevant integrity constraints and logical mappings found in data exchange and virtual data integration that are usually considered in the theoretical, technical and applied literature on data management. In particular, UDECs can be used to express equality-generating dependencies (egds), and RDECs can express general tuple-generating dependencies (tgds) (Abiteboul et al. 1995).\nEach peer P of P has a possibly empty collection of sets of DECs, Σ(P, Q), between P and peers Q ∈ P, with at most one Σ(P, Q) for each peer Q. Each Σ(P, Q) is finite and logically consistent. Due to the local nature of PDESs systems, it is possible for Σ(P, Q) (which is owned by P) to be different from Σ(Q, P) (which is owned by Q). The DECs in Σ(P, P) are the integrity constraints for (instances of) peer P. We denote with Σ the class formed by of all non-empty sets Σ(P, Q) of a PDES.\nA PDES also has a relation Trust ⊆ P×{less, same}×P, with exactly one triple of the form (P, ·, Q) for each Σ(P, Q) ∈ Σ. The intended semantics of (P, less, Q) ∈ Trust is that peer P trusts itself less than Q; while (P, same, Q) ∈ Trust indicates that P trusts itself the same as Q.4 The trust relation is not necessarily symmetric, e.g. it could hold (P, less, Q), (Q, same, P) ∈ Trust. For a peer P, when Σ(P, P) 6= ∅, we assume (P, same, P) ∈ Trust.\nDefinition 2.1\n(a) The schema of a PDES P is a sequence 〈P,S,Σ, T rust〉, where P is a set of peers, S is a corresponding set of peer database schemas, Σ the set of DECs,\nand Trust the set of trust relationships.\n(b) An instance D of a PDES schema P = 〈P,S,Σ, T rust〉 is a set containing one database instance D(P) for the schema S (P) ∈ S, for each peer P ∈ P. 2\n4 We do not consider the case when a peer P trusts itself more than another peer, since the information of the latter should be irrelevant to P.\nConsistency and Trust in Peer Data Exchange Systems 9 Consistency and Trust in Peer Data Exchange Systems 9\nP1 P2 <\nP3 =\nP4<\n<\n(a) G(P)\nP1 P2 <\nP3 =\n(b) G(P1)\nP2\nP3 =\nP4<\n<\n(c) G(P4)\nFig. 3. Graphs for Example 2.1\nIntuitively, and due to the locality of peers, a peer P will be aware only of the sets Σ(P, Q) and elements of Trust whose first argument is P. More precisely, a peer stores its own database schema and instance, its DECs to other peers, and its trust relationships. Furthermore, for an instance D of schema P, the instances D(P) ∈ D are not required to (jointly) satisfy the DECs in Σ. Consistency and consistency restoration is a concern only when queries are posed to peers.\nDefinition 2.2 Given a PDES schema P = 〈P,S,Σ, T rust〉: (a) The schema of a peer P ∈ P is P(P) = 〈S(P),Σ(P), T rust(P)〉, where S(P) ∈\nS, Σ(P) = {ϕ | ϕ ∈ Σ(P, Q), Σ(P, Q) ∈ Σ, and Q ∈ P}; and Trust(P) = {(P, t , Q) | (P, t , Q) ∈ Trust, and Q ∈ P}. (We can safely identify a peer P with its schema P(P).) (b) The accessibility graph G(P) contains a vertex for each P ∈ P, and a directed edge from P to Q if P 6= Q and Σ(P, Q) 6= ∅. An edge from P to Q is labeled with “<” when (P, less, Q) ∈ Trust, and with “=” when (P, same, Q) ∈ Trust. (c) Peer P’ is accessible from P if there is a path in G(P) from P to P’ or if P’=P. AC(P) denotes the set of peers accessible from P. G(P) denotes the restriction of G(P) to the peers in AC(P) (i.e. it contains as vertices only the peers in AC(P), and the edges between them are those inherited from G(P)). (d) Peer P’ is a neighbor of P if there is an edge from P to P’ in G(P), or if P’ = P. We denote with N (P) the set of neighbors of P; and with S(N (P)) the union of their schemas, i.e. ⋃ Q∈N (P)S(Q). Furthermore, N ◦(P) := N (P) r {P}. 2\nExample 2.1 Consider P = 〈P,S,Σ, T rust〉 with P = {P1, P2, P3, P4}, S = {S(P1), S(P2), S(P3),S(P4)}, S(P1) = {R1(·, ·)}, S(P2) = {R2(·, ·), S 2(·, ·)}, S(P3) = {R3(·, ·)}, S(P4) = {R4(·, ·, ·)}. Furthermore, Trust={(P1, less, P2), (P2, same, P3), (P4, less, P2), (P4, less, P3)}, and Σ contains:\nΣ(P1, P2) = {∀xy(R2(x , y)→ R1(x , y))}, (3) Σ(P2, P2) = {∀x∀y(R2(x , y) ∧ S 2(x , y)→ false), (4) ∀x∀y∀z (R2(x , y) ∧ R2(x , z )→ y = z )} (5) Σ(P2, P3) = {∀xy(R2(x , y) ∧ R3(x , y)→ false)}, (6) Σ(P4, P2) = {∀xyz (R2(x , y) ∧ S 2(y , z )→ R4(x , y , z ))}, (7) Σ(P4, P3) = {∀xy(R3(x , y)→ ∃zR4(x , y , z ))}· (8)\nFig. 3. Graphs for Example 2.1\nIntuitively, and due to the locality of peers, a peer P will be aware only of the sets Σ(P, Q) and elements of Trust whose first argument is P. More precisely, a peer stores its own database schema and instance, its DECs to other peers, and its trust relationships. Furthermore, for an instance D of schema P, the instances D(P) ∈ D are not required to (jointly) satisfy the DECs in Σ. Consistency and consistency restoration is a concern only when queries are posed to peers.\nDefinition 2.2 Given a PDES schema P = 〈P,S,Σ, T rust〉: (a) The schema of a peer P ∈ P is P(P) = 〈S(P),Σ(P), T rust(P)〉, where S(P) ∈\nS, Σ(P) = {ϕ | ϕ ∈ Σ(P, Q), Σ(P, Q) ∈ Σ, and Q ∈ P}; and Trust(P) = {(P, t , Q) | (P, t , Q) ∈ Trust, and Q ∈ P}. (We can safely identify a peer P with its schema P(P).) (b) The accessibility graph G(P) contains a vertex for each P ∈ P, and a directed edge from P to Q if P 6= Q and Σ(P, Q) 6= ∅. An edge from P to Q is labeled with “<” when (P, less, Q) ∈ Trust, and with “=” when (P, same, Q) ∈ Trust. (c) Peer P’ is accessible from P if there is a path in G(P) from P to P’ or if P’=P. AC(P) denotes the set of peers accessible from P. G(P) denotes the restriction of G(P) to the peers in AC(P) (i.e. it contains as vertices only the peers in AC(P), and the edges between them are those inherited from G(P)). (d) Peer P’ is a neighbor of P if there is an edge from P to P’ in G(P), or if P’ = P. We denote with N (P) the set of neighbors of P; and with S(N (P)) the union of their schemas, i.e. ⋃ Q∈N (P)S(Q). Furthermore, N ◦(P) := N (P) r {P}. 2\nExample 2.1 Consider P = 〈P,S,Σ, T rust〉 with P = {P1, P2, P3, P4}, S = {S(P1), S(P2), S(P3),S(P4)}, S(P1) = {R1(·, ·)}, S(P2) = {R2(·, ·), S 2(·, ·)}, S(P3) = {R3(·, ·)}, S(P4) = {R4(·, ·, ·)}. Furthermore, Trust={(P1, less, P2), (P2, same, P3), (P4, less, P2), (P4, less, P3)}, and Σ contains:\nΣ(P1, P2) = {∀xy(R2(x , y)→ R1(x , y))}, (3) (P2, P2) {∀x∀y(R2(x , y) ∧ S 2(x , y)→ false), (4) ∀x∀y∀z (R2(x , y) ∧ R2(x , z )→ y = z )}, Σ(P2, P3) = {∀xy(R2(x , y) ∧ R3(x , y)→ false)}, (5) Σ(P4, P2) = {∀xyz (R2(x , y) ∧ S 2(y , z ) R4(x , y , z ))}, (6) Σ(P4, P3) = {∀xy(R3(x , y)→ ∃zR4(x , y , z ))}· (7)"
    }, {
      "heading" : "10 L. Bertossi, L. Bravo",
      "text" : "The built-in atom false in (4) and (5) is false in every instance. The DECs in Σ(P2, P2) are the local integrity constraints for P2, in this case a denial constraint (i.e. a prohibited join of positive atoms) and a functional dependency, requiring that (the values for) the first attribute functionally determines (determine the values for) the second one. Here, Σ(P4) = {∀xyz (R2(x , y) ∧ S 2(y , z ) → R4(x , y , z )), ∀xy(R3(x , y)→ ∃zR4(x , y , z ))}.\nThe DEC in (7) is an RDEC, and all the others are UDECs. Some of the accessibility graphs are shown in Figure 3. Notice that AC(P1) = {P1, P2, P3}, AC(P2) = {P2, P3}, AC(P3) = {P3}, AC(P4) = {P2, P3, P4}, N (P1) = {P1, P2}, N (P2) = {P2, P3}, N (P3) = {P3}, N (P4) = {P2, P3, P4}, N ◦(P1) = {P2}, N ◦(P2) = {P3}, N ◦(P3) = ∅, and N ◦(P4) = {P2, P3}.\nAs an example, peer P4 only knows its schema and database, the DECs from it to peers P2 and P3, and how much it trusts them. More precisely, P4 knows its schema P(P4) = 〈S(P4),Σ(P4), T rust(P4)〉, with Σ(P4) = {∀xyz (R2(x , y) ∧ S 2(y , z )→ R4(x , y , z )),∀xy(R3(x , y)→ ∃zR4(x , y , z ))}, and Trust(P4)={(P4, less, P2), (P4, less, P3)}. This peer also has its database instance D(P4).\nThe schema of P1 is P(P1) = 〈{R1(·, ·)}, {∀xy(R2(x , y)→ R1(x , y))}, {(P1, less, P2)}〉. As will be determined by the semantics later on, the combination of P1’s DEC in (3) and the trust relationship to P2, will make P1 import all the missing data from the extension of its neighbor’s R2 into the extension of its own R1. 2\nExample 2.2 (example 1.1 cont.) The PDES can be formalized through the schema P = 〈P,S,Σ, T rust〉, where P = {P1, P2}, S = {S(P1),S(P2)}, Σ = {Σ(P1, P2)}, Σ(P1, P2) = {∀xy(R2(x , y) ∧ S 2(y , z ) → R1(x , y , z )), ∀x (S 1(x ) → S 2(5, x ))}, and Trust = {(P1, less, P2)}.\nThe schema of P1 is P(P1) = 〈S(P1), Σ(P1, P2), {(P1, less, P2)}〉, and that of P2 is P(P2) = 〈S(P2), ∅, ∅〉. The instance for the PDES, D = {D(P1),D(P2)}, contains the two instances shown in Figure 1. 2\nRemark 2.1 From now on we assume that the graph G(P) is acyclic. As a consequence, for each particular peer P, G(P) is also acyclic. This is a global assumption, not local to any particular peer, that will be used to define the semantics of a PDES. (A discussion around this and related assumptions can be found in electronic Appendix A.) 2\nNotice that according to its definition, the accessibility graph has no self-loops. The finiteness of the set of peers and the acyclicity of the accessibility graph imply that there must be “sink” (or terminal) peers, without any outgoing edges. Also notice that we are not making the assumption that for a peer P its initial instance D(P) has to satisfy the local constraints in Σ(P, P). This applies in particular to sink peers in the accessibility graph. They can have local ICs, which may be violated."
    }, {
      "heading" : "3 A General Semantic Framework for a PDES",
      "text" : "Before presenting the formal semantics of PDESs, we describe the intended semantics in intuitive and operational terms.\nConsistency and Trust in Peer Data Exchange Systems 11\nA query Q ∈ L(P) is posed to a peer P by a certain user U, who may be an external user or another peer in P. Now P, depending on the query predicates, inspects the DECs in Σ(P) to identify data owned by other neighboring peers Q that may be related to its own data. If predicate RQ ∈ S(Q) appears in Σ(P), then P requests from Q the (contents of the) relation RQ. Q returns to P a possible modified version of its relation, because Q may have to take into account data from its own neighbors (in the same way P did when it received the user query), which could produce local inconsistencies at Q’s level, and they have to be repaired; and so on.\nFor the purpose of presenting the semantics of the system, that should be queryindependent, we will assume for the moment that P receives whole relation instances from its neighbors. We emphasize that, in their turn, P’s neighboring peers Q consider data from their own neighbors, and so on; data that may also be eventually used by P, by transitivity (cf. details below).\nThe data P receives from another peer Q is defined in a recursive manner, because Q may have connections to other peers who may contribute with data of their own. Eventually, after receiving the requested relation instances from its neighbors, P has now a database instance D for the expanded database schema S(N (P)), which extends the initial instance D(P) by adding predicates and data from its neighbors. D can be used to interpret the DECs in Σ(P). Most likely, D will not satisfy Σ(P).\nWhen this extended instance D is inconsistent with respect to Σ(P), different alternatives to restore consistency with respect to Σ(P) can be considered, but the (possibly virtual) updates performed on the extended instance D will have to both respect the trust relationships and make sure that the consistent alternative instances stay as close as possible to instance D (for which a form of distance has to be introduced, as we do later in this section). In this way, a collection of consistent, and possibly virtual, extended instances for P’s neighborhood emerges, the neighborhood instances. By restricting those instances to the schema of peer P, the solution instances for P are obtained.\nNow, we give the precise definition of neighborhood solution. In order to do so, we will assume that it is possible to compare arbitrary instances D1,D2 with respect to a fixed instance D by means of a preorder relation D (i.e. a reflexive and transitive binary relation). If D ,D1,D2 are database instances for the same schema, the intuition behind the relationship D1 D D2 is that D1 is at least as close to D as D2 (is to D). We can define D1 ≺D D2 iff D1 D D2, but not D2 D D1, with the intuition that D1 is closer to D than D2.\nIn our semantics, the participating instances will always be for a neighborhood schema S(N (P)) of a peer P. Even more, the preorder relation will also depend on Σ(P) (which has to be satisfied).\nAs a consequence, we will assume, for D a fixed instance for S(N (P)), the existence of a preorder relation Σ(P)D on instances for the schema S(N (P)).\nDefinition 3.1 Given a PDES schema P = 〈P,S,Σ, T rust〉, a peer P ∈ P, and an instance D̄ for the schema S(N (P)):"
    }, {
      "heading" : "12 L. Bertossi, L. Bravo",
      "text" : "(a) An instance D ′ for the schema S(N (P)) is a neighborhood solution for P and D̄ if:\n(i) D ′ |= Σ(P). (ii) There is no instance D ′′ satisfying (i), and D ′′ ≺Σ(P)\nD̄ D ′.\n(iii) D ′ {R} = D̄ {R} for every predicate R ∈ S(Q) with (P, less, Q) ∈ Trust. (b) NSP(P, D̄) denotes the set of neighborhood solutions for P and D̄ .\nWhen clear from the context, we will simply use NS(P, D̄). 2\nA neighborhood solution for P is a database for its whole neighborhood that satisfies P’s DECs (including its local constraints), and respects its trust relationships. A neighborhood solution also stays as close as possible to the original neighborhood instance, while staying the same for trustable peers. In operational and intuitive terms, a minimal data set with respect to Definition 3.1 is imported or given up to satisfy the DECs.\nNotice that Definition 3.1 introduces an abstract repair semantics, similar to those used to handle inconsistency in single databases (Bertossi 2011). For example, a well-studied repair semantics for single databases was introduced in (Arenas et al. 1999). It is based on insertions or deletions of whole tuples into/from the original inconsistent instance D , and the “distances” of two instances D1,D2 from D are compared using the symmetric differences: D1 ∆,Σ(P)D D2 :⇔ ∆(D ,D1) ⊆ ∆(D ,D2).5 For a peer P in isolation, i.e. with N ◦(P) = ∅, a neighborhood solution of its original instance D(P) will simply be an instance D ′ for its schema S(P), such that: (a) D ′ |= Σ(P, P) (i.e. P’s own integrity constraints); and (b) There is no instance D ′′ satisfying (a) and D ′′ ≺Σ(P,P)\nD(P) D ′. This defines a class of repairs of\ninstance D(P) with respect toΣ(P, P).6 Thus, this neighborhood-solution semantics for PDESs naturally extends the notion of repair to neighborhood solutions.\nExample 3.1 (examples 1.1 and 2.2 cont.) The elements of the PDES schema are all as before, in particular,\nΣ(P1, P2) = {∀xy(R2(x , y) ∧ S 2(y , z )→ R1(x , y , z )), ∀x (S 1(x )→ S 2(5, x ))}, (8)\nbut this time consider {(P1, same, P2)} ∈ Trust. Now assume, in this example, for illustration purposes, that the preorder relations are defined by D1 ∆,Σ(P)D D2 iff ∆(D ,D1) ⊆ ∆(D ,D2). If a query is posed to P1, it will have to compute (possibly virtually) its neighborhood solutions. Peer P1’s knowledge of the schema is limited to its own schema P(P1) = 〈S(P1),Σ(P1), T rust(P1)〉 where S(P1) = {R1(·, ·, ·),S 1(·)}, Σ(P1) = Σ(P1, P2), and Trust(P1) = {(P1, same, P2)}.\nIn order to enforce Σ(P1), P1 poses two atomic queries to peer P2: Q1(x , y): R2(x , y) and Q2(x , y): S 2(x , y). Since P2 is not related to any other peer, and has no local ICs, it will provide as answers the content of those relations in D(P2). In\n5 For sets S1 and S2, ∆(S1,S2) := (S1 r S2) ∪ (S2 r S1). 6 We are using abstract preorder relations to define repair semantics. It should also be possible to\nuse abstract “distance measures” to define repairs and repair semantics. Cf. (Arieli et al. 2003).\nConsistency and Trust in Peer Data Exchange Systems 13\nthis way, P1 has an extended instance D , shown in Figure 4, that corresponds to the union of the two instances in Figure 1, that is, D = D(P1) ∪ D(P2). Since D does not satisfy Σ(P1), D has to be repaired.\nSince (P1, same, P2), there are several neighborhood solutions for P1, which are obtained by virtually modifying both peers’ data. For example, the inconsistencies with respect to the first UDEC in (8) can be (minimally) solved by either removing R2(d , 5) from R2, or removing S 2(5, 3) from S 2, or inserting R1(d , 5, 3) into R1. If S 2(5, 3) were removed from S 2, a new inconsistency is created with respect to the second UDEC in (8). This one can be solved by removing S 1(3) from S 1. The inconsistencies with respect to the second DEC can be solved by either removing S 1(7) from S 1 or inserting S 2(5, 7) into S 2.\nFigure 5 shows the six neighborhood solutions in NSP(P1,D). All these neighborhood instances are repairs in the sense of (Arenas et al. 1999) of instance D with respect to P1’s DECs. If we are locally interested only in P1, we consider their restrictions to P1’ schema S(P1). 2\nAs the following example shows, trust relationships in combination with incon-\nsistent DECs may cause that neighborhood solutions do not exist.\nExample 3.2 Consider a PDES schema P = 〈P,S,Σ, T rust〉 with P = {P, Q, R}, and 1. S = {S(P),S(Q), S(R)}, S(P) = {P}, S(Q) = {Q}, S(R) = {R}."
    }, {
      "heading" : "14 L. Bertossi, L. Bravo",
      "text" : "2. Σ = {Σ(P, Q),Σ(P, R))}, Σ(P, Q) = {∀xy(Q(x , y) → P(x , y))}, Σ(P, R) = {∀xy(P(x , y)→ R(x , y))}. 3. Trust = {(P, less, Q), (P, less, R)}. 4. D = {D(P),D(Q),D(R)}, with D(P) = D(R) = ∅, and D(Q) = {Q(a, b)}.\nFor peer P and D = D(P) ∪ D(Q) ∪ D(R) = {Q(a, b)}, there is no neighborhood solution, i.e. NS(P,D(P) ∪ D(Q) ∪ D(R)) is empty. This is because P’s DEC with Q forces the insertion of P(a, b), but at the same time the interaction of P with R requires relation P to be empty. Since peer P trusts both peers more than itself, there is no neighborhood solution that satisfies the DECs and respect the trust relations.\nNotice that the DEC in Σ(P, R) acts as a restriction on tuples for its owner, P, rather than as a tuple generator for it. 2\nIn the previous example, the trust relationships impose unsolvable conditions on neighborhood solutions. However, if all the trust relationships are of the flexible form (P, same, Q), a peer always has solutions.\nProposition 3.1 Consider a PDES schema P = 〈P,S,Σ, T rust〉 and a peer P ∈ P whose trust relationships are all of the form (P, same, Q). Given an instance D̄ for S(N (P)), peer P always has a neighborhood solution for D̄ . 2\nHaving defined the notion of neighborhood solution for a peer, now we can define the notion of solution for a peer, which is a local instance but takes all the accessible peers into account. The data distributed across different peers has to be appropriately gathered to build solution instances for the peer. This definition of solution instance is recursive, and appeals to that of neighborhood solution. The intuition and idea are as follows: (a) Assume each neighbor Q of peer P has the class Sol(Q,D) of its solution instances (hence the recursion). Each of these Q passes to P the intersection ⋂ Sol(Q,D) of its solution set.7 With them and its own initial instance D(P), P builds an instance D for its neighborhood N (P). The solutions for P become the restrictions to P’s schema of the neighborhood solutions for P with respect to D , Σ(P), and P’s trust relationships.\nUnder this recursive definition, the solutions for the neighbors have to be determined, under the same semantics. Base cases of the recursion are peers with no DECs or with only local constraints, that is, when either Σ(P) = ∅ or Σ(P) = {Σ(P, P)} . These peers are sinks in the accessibility graph of P. In this regard, we recall that we made the assumption that the accessibility graphs are acyclic.\nDefinition 3.2 Given an instance D for the PDES schema P = 〈P,S,Σ, T rust〉, and a peer P, an instance D for the schema S(P) is a solution instance (or simply solution) for P, denoted D ∈ SolP(P,D) (or simply, Sol(P,D)), iff:\n7 When C is a class of sets, then we will usually denote with ⋂ C the intersection of its elements, i.e. ⋂ C := ⋂C∈C C .\nConsistency and Trust in Peer Data Exchange Systems 15\n(a) For Σ(P) = ∅: D = D(P) (P’s initial instance, the projection of D on S(P)). (b) For Σ(P) = {Σ(P,P)}: D ∈ NSP(P,D(P)). (c) For ∅ 6= Σ(P) 6= {Σ(P,P)}: D = D S(P), where D ∈ NSP(P,D(P) ∪⋃\nQ∈N◦(P) Core(Q,D)).\nHere, Core(Q,D) := ⋂ SolP(Q,D) when SolP(Q,D) 6= ∅; and Core(Q,D) := {incQ}, otherwise. The propositional built-in predicate incQ in S(Q) is true of an instance iff it is contained in the latter as an atom. 2\nThe base cases of the recursion are (a) and (b), where the solutions of a peer can be computed without data from other peers. Case (c) corresponds to the properly recursive case, where, before determining P’s solutions, there is an extended instance D around P formed by its local instance D(P) plus, for each neighbor Q, the intersection, Core(Q,D), of all its solutions. The combined database D is for the schema S(N (P)), and starting from D , neighborhood solutions for P can be determined; and their restrictions to P’s schema become P’s solutions.\nAlthough, in Definition 3.2, cases (a) and (b) are special cases of (c), we include them explicitly, for clarity. Notice that case (b) amounts to obtaining the repairs of a local instance with respect to a set of local integrity constraints.\nThe following is a immediate consequence of Proposition 3.1.\nCorollary 3.1 Consider a PDES schema P = 〈P,S,Σ, T rust〉 with trust relationships all of the form (R, same, Q), and a peer P ∈ P. Given an instance D for P, peer P always has a solution, that is, SolP(P,D) 6= ∅. 2\nRemark 3.1 As we have seen, even in the absence of cycles in G(P), a peer may have no neighborhood solutions (cf. Example 3.2), and then no solutions, i.e. Sol(P,D) = ∅. That is why, in this case, we make the convention in Definition 3.2 that Core(P,D) = {incP}. When Sol(P,D) = ∅, if another peer requests from P the intersection of its solutions, P returns the instance {incP}.\nThe idea is that when a peer becomes inconsistent, it makes another peer Q who requests its data notice its inconsistency by sending this special instance. In this case, Q is expected to ignore its mappings with P. This can be made precise and formally accommodated by modifying the DECs through the introduction of an extra conjunct in the antecedent. For example, the DEC Σ(Q, P) = {∀x (P(x ) → Q(x ))} would be replaced by {∀x (P(x ) ∧ ¬incP → Q(x ))}, which would become trivially satisfied. Alternatively, if we want to keep the built-ins in the consequent, we could replace Σ(Q, P) by {∀x (P(x )→ (Q(x ) ∨ incP))}. In order not to complicate the notation, we will refrain from explicitly introducing the incPs in the DECs. 2\nAccording to this convention about the treatment of peers without solutions, a peer that becomes intrinsically inconsistent, “irreparable”, is ignored by its neighbors when they receive the notification of inconsistency. However, this form of ignoring is put here on a solid logical foot, that is compatible and uniform with the"
    }, {
      "heading" : "16 L. Bertossi, L. Bravo",
      "text" : "treatment of other peers. As long as a peer declares itself as inconsistent, there is no much a neighbor can do. However, an inconsistent peer might decide to relax its own consistency requirements and send to other peers only “partially consistent” data, which would be transparent to those receiving peers.8\nThe peer consistent answers from a peer to a query are the semantically correct answers, which means that when answering the query, the peer consistently considers the data of its neighbors and the trust relationships with them.\nDefinition 3.3 Consider an instance D for the PDES schema P = 〈P,S,Σ, T rust〉, and a peer P ∈ P. Let Q(x̄ ) ∈ L(P) be a query, with x̄ a possibly empty list of free variables.\n1. If Sol(P,D) 6= ∅: (a) If x̄ 6= ∅, a finite sequence c̄ of constants in U of the same length as x̄\nis a peer consistent answer (PCA) to Q from P iff D |= Q[c̄] for every D ∈ Sol(P,D). (b) If Q is Boolean and D |= Q for every D ∈ Sol(P,D), then yes is the only PCA to Q. 2. If Sol(P,D) = ∅, then incP is the only PCA to Q(x̄ ). 2\nFor illustration, in Example 3.1, if P1 has to answer a query Q ∈ L(P1), it returns the answers that are simultaneously true in all its neighborhood solutions. For example, under this semantics, the answers to query Q(x ) : ∃yzR1(x , y , z ) posed to P1 will be 〈c〉, 〈f 〉, which are shared by all the six neighborhood solutions for P1 (or better, by their restrictions to P1’s schema). The answers to queries Q1 and Q2 posed by P1 to P2 are answered in the same way, taking into consideration the P2’s DECs.\nWe can see that the answers from a peer to a query are certain answers (Imielinski and Lipski 1984). This condition makes the data moved from one peer to a neighbor always certain. In particular, this allows us to treat external queries and inter-peer queries in a uniform manner. In particular, we will be in position to conceive and implement the passage of data from one peer to a neighbor as a query answering process.\nExample 3.3 Consider the PDES schema P and instance D represented in graph G(P) in Figure 6. Here, Σ = {Σ(P1, P2),Σ(P2, P3),Σ(P4, P3)}, and:\n- Σ(P1, P2)= {∀xyz (R2(x , y) ∧ S 2(y , z )→ R1(x , y , z )), ∀x (S 1(x )→ S 2(5, x ))}. - Σ(P2, P3)= {∀xy (S 2(x , y) → R3(x , y))}. - Σ(P4, P3)= {∀xyz (R3(x , y) → R4(x , y , 3))}.\nIn intuitive and procedural terms, if a query is posed to P1, it will send queries to P2, to check the satisfaction of the DECs in Σ(P1, P2). But, in order for P2 to answer those queries, it will send queries to peer P3 to check the DECs in Σ(P2,\n8 An alternative to this design choice could be, in the case a peer P trusts an inconsistent peer Q more than itself, that P becomes or declares itself inconsistent as well. This alternative may be worth exploring, but we do not pursue it here any further.\nConsistency and Trust in Peer Data Exchange Systems 1712 · L. Bertossi and L. Bravo R1\nc 4 2 f 3 5\nS1\n3 7\nP1 R2\nc 4 d 5\nS2\n4 2 5 3\nP2\n<\nR3\n5 7 5 3\nP3\n=\nR4\n5 3 3\nP4\n=\nFig. 5. PDES for Example 3.8\nturned by a peer who consistently considers the data of- and trust relationships with its neighbors.\nDefinition 3.7. Let Q(x̄) ∈ L(P) be a FO query. (a) When Sol(P) 6= ∅, a ground tuple t̄ is a peer consistent answer (PCA) to Q from P iff D |= Q(t̄) for every D ∈ Sol(P). If x̄ = ∅ and D |= Q for every D ∈ Sol(P), then yes is the PCA. (b) Otherwise, when Sol(P) = ∅, incP is the only PCA to Q(x̄). 2\nExample 3.8. (extension of example 1.1) The DECs are Σ(P1, P2)= {∀xyz (R2(x, y) ∧ S2(y, z) → R1(x, y, z)), ∀x (S1(x) → S2(5, x))}, Σ(P2, P3) = {∀xy (S2(x, y) → R3(x, y))}, and Σ(P4, P3)= {∀xyz (R3(x, y)→ R4(x, y, 3))}. Here, N (P1) = {P1, P2}. The trust relationships are as shown in Figure 5. In intuitive and procedural terms, if a query is posed to P1, it will send queries to P2, to check the satisfaction of the DECs in Σ(P1, P2). But, in order for P2 to answer those queries, it will send queries to peer P3 to check the DECs in Σ(P2, P3). Since P3 is not connected to any other peer, it will answer P2’s queries using its material instance D(P3). Thus, the solutions for P1 and its peer consistent answers will be affected by the peers in AC(P1) = {P1, P2, P3}.\nWe can make this precise by applying the recursive definition of solution instance. Since P3 has no DECs with other peers, its only neighborhood solution is its instance D(P3). This is sent back to P2, who needs to repair the extended instance D = {R2(c, 4), R2(d, 5), S2(4, 2), S2(5, 3), R3(5, 7), R3(5, 3)} with respect to Σ(P2, P3). As P2 trusts P3 the same as itself, it can modify its own data or the data it got from P3. Assuming -for illustration purposes for the moment- that the distance between instances is given in terms of the symmetric set-difference, P2 has two neighborhood solutions: {R2(c, 4), R2(d, 5), S2(5, 3), R3(5, 7), R3(5, 3)} and {R2(c, 4), R2(d, 5), S2(4, 2), S2(5, 3), R3(5, 7), R3(5, 3), R3(4, 2)}. They minimally depart from D, and their restrictions to P2’s schema lead to two solutions for P2: Sol(P2) = {{R2(c, 4), R2(d, 5), S2(5, 3)}, {R2(c, 4), R2(d, 5), S2(4, 2), S2(5, 3)}}.\nPeer P2 will send to P1 the intersection of its solutions, namely {R2(c, 4), R2(d, 5), S2(5, 3)}. Now, P1 has to repair {R1(c, 4, 2), R1(f, 3, 5), S1(3), S1(7), R2(c, 4), R2(d, 5), S2(5, 3)} with respect to Σ(P1, P2). Since P1 trusts P2 more, it will solve inconsistencies by modifying its own data, producing only one neighborhood solution: {R1(c, 4, 2), R1(f, 3, 5), R1(d, 5, 3), S1(3), R2(c, 4), R2(d, 5), S2(5, 3)}. Thus, Sol(P1) = {{ R1(c, 4, 2), R1(f, 3, 5), R1(d, 5, 3), S1(3)}}.\nIf P1 had received the query Q(x) : ∃yz(R1(x, y, z)∧S(y)), the only peer consistent answers would be 〈f〉, which is obtained from its only solution. 2 ACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\nFig. 6. PDES for Example 3.3\nP3). Since P3 is not connected to any other peer, it will answer P2’s queries using its initial material instance D(P3). Thus, the solutions for P1 and its peer consistent answers will be affected by the peers in AC(P1) = {P1, P2, P3}. More precisely, we can now apply the definitions of solution instance and peer consistent answer.\nSince P3 has neither DECs with other peers nor local integrity constraints, its only neighborhood solution is its instance D(P3) ∈ D, which is sent back to P2. Now, P2 has to repair the extended instance D = {R2(c, 4), R2(d , 5), S 2(4, 2), S 2(5, 3), R3(5, 7), R3(5, 3)} with respect to Σ(P2, P3), which is not satisfied due to the presence of tuple S 2(4, 2). As P2 trusts P3 the same as itself, it can modify its own data or the data it got from P3.\nAssuming -for illustration purposes for the moment- that the preorder relation on instances is given in terms of the symmetric set-difference, P2 has two neighborhood solutions: {R2(c, 4), R2(d , 5), S 2(5, 3), R3(5, 7), R3(5, 3)} and {R2(c, 4), R2(d , 5), S 2(4, 2), S 2(5, 3), R3(5, 7), R3(5, 3), R3(4, 2)}. They minimally depart from D , and their restrictions to P2’s schema lead to two solutions for P2: Sol(P2,D) = {{R2(c, 4),R2(d , 5),S 2(5, 3)}, {R2(c, 4), R2(d , 5), S 2(4, 2),S 2(5, 3)}}. Peer P2 will send to P1 the intersection of its solutions, namely Core(P2,D) =⋂ Sol(P2,D) = {R2(c, 4), R2(d , 5), S 2(5, 3)}. Now, P1 has to repair the extended instance {R1(c, 4, 2), R1(f , 3, 5), S 1(3), S 1(7), R2(c, 4), R2(d , 5), S 2(5, 3)} with respect to Σ(P1, P2), which is not satisfied.\nSince P1 trusts P2 more, it will solve inconsistencies by modifying its own data, in this case inserting tuples into R1 and deleting tuples from S 1. This produces only one neighborhood solution: {R1(c, 4, 2), R1(f , 3, 5), R1(d , 5, 3), S 1(3), R2(c, 4), R2(d , 5), S 2(5, 3)}. Thus, Sol(P1,D) = {{R1(c, 4, 2), R1(f , 3, 5), R1(d , 5, 3), S 1(3)}}.\nIf P1 had received the query Q(x ) : ∃yz (R1(x , y , z ) ∧ S 1(y)), the only peer consistent answer woul have been 〈f 〉, obtained from its only solution. 2\nNotice that when a peer Q passes its core, Core(Q, D̄), with D̄ a neighborhood instance, to a peer P, it is delivering the peers consistent answers to the atomic queries from P to Q of the form QR(x̄ ) : R(x̄ ), where R ∈ S(Q). However, when P computes its local PCAs to a query, it does not use its own core, ⋂ Sol(P,D), but the collection Sol(P,D) as a whole. The reason is that this core is unnecessarily restrictive for peer consistent query answering. For example, if the query is Q : ∃xP(x ), and P’s solutions are {P(a)} and {P(b)}, the PCA to this Boolean query would be no if evaluated on the empty core, but yes according to our definition."
    }, {
      "heading" : "18 L. Bertossi, L. Bravo",
      "text" : "Remark 3.2 Notice that the definitions of solution instance for a peer and of peer consistent answer are parameterized by: (a) The class of data exchange constraints. We have considered certain syntactic classes of FO-sentences, and we will also do so in the rest of this work. However, our presentation so far has been general enough to accommodate broader classes of FO sentences in the combined language of any two peers. The restriction on the classes of DECs has not been required or used yet. (b) A notion of satisfaction, D |= ϕ, where D is a database instance and ϕ is a FO sentence in the language of D ’s schema. Most commonly, D is a relational database considered as a FO structure, and classical logical satisfaction is used. However, if D contains uncertain information, then we may have to depart from FO logic, as we will see in Section 4, for a particular PDES semantics. (c) The preorder relations Σ(P)D between instances for the schema of an instance D . Different preorder relations can be considered. In the examples above we have considered, just to fix ideas, the common preorder based on the symmetric set difference between instances.\n(d) The repair semantics, i.e. by a characterization of the instances that minimally depart from a given one D in order to satisfy local ICs or DECs between two peers. The repair semantics is based on the preorders D ′′ Σ(P)D D ′, and the associated minimality conditions (what we did in Definition 3.1). 2"
    }, {
      "heading" : "4 Towards a Special PDES Semantics with NULL",
      "text" : "Considering the rather abstract nature and flexibility of the semantic framework introduced in Section 3, in this section, we make specific commitments about the semantic parameters discussed in Remark 3.2.\nIn the rest of this section, we consider a classical relational schema Σ = (U ,R,B), consisting of the data domain, a set of database predicates, and a set of built-in predicates.9 Now, we will introduce in the schema some extra elements related to the special constant, null, that we will use in the rest of this work.\nRemark 4.1 We assume from now on that every attribute domain, Adom(A), contains the constant null. In particular, null ∈ U . Furthermore, among the built-in predicates in B, we will also find IsNull(·), and IsNotNull(·). The first one is true only with constant null, and the second one, on any constant c other than null.10 Accordingly, null and these built-in predicates may appear in DECs as defined in (1) and (2), in particular, in integrity constraints, and also in queries. They all become sentences or formulas of the FO language L(Σnull) associated to Σnull = (U ,R,Bnull), with Bnull= B ∪ {IsNull, IsNotNull}. 2\n9 In the coming sections, where we will apply the semantics of this section, R will be the set of database predicates for a peer or a pair thereof. 10 Each is the negation of the other, but we will keep both in order to avoid using explicit negation.\nConsistency and Trust in Peer Data Exchange Systems 19\nThe special constant null in the data domain U is intended to behave and be used as the null value, NULL, in SQL relational databases. The new, unary, builtin predicates correspond to the SQL predicates IS NULL and IS NOT NULL, used to check null values. Constant null may appear in database tuples, and will be used to restore consistency with respect to DECs and ICs.\nUsing a single null, with its SQL semantics, is clearly different from using multiple labeled null values, as is done in data exchange for enforcing the satisfaction of existential quantifications (Kolaitis 2005). It is also different from using arbitrary elements of the underlying data domain for the same purpose (Cali et al. 2003). However, to a large extent, the semantics of this section could be developed without the specific restrictions imposed on the representation and use of null values, adopting other forms of handling incomplete and inconsistent data. Cf. Section 7 and electronic Appendix A for additional discussions of these issues.\nThe semantics of null we introduce next captures the way nulls are handled by relational DBMSs that follow the SQL standard. More precisely, our semantics provides a partial logical reconstruction in first-order predicate logic of the way nulls are handled in SQL databases. It refines and extend previous work presented in (Bravo and Bertossi 2006) on database repairs with and in the presence of NULL.\nThe SQL Standard leaves many issues around NULL unspecified, and different DBMSs depart from the standard in different ways. As a consequence, it is not possible to provide a full logical reconstruction of SQL databases with NULL. For this reason, Accordingly, our semantics concentrates on the notion of satisfaction of DECs and ICs, and query answering for a broad classes of queries. Furthermore, the proposed semantics extends the “classical” notion of DEC and IC satisfaction, and query answering in databases without NULL.11\nThe rest of this section continues as follows. In Section 4.1, we illustrate some of the elements of and issues around the notion of query answer as used in SQL databases with NULL. It serves a motivation for Section 4.2, where we formalize the semantics of query answering. In Section 4.3, we introduce a rewriting-based semantics for constraint satisfaction in the presence of NULL, leading to a fully classical semantics. Finally, in Section 4.4, we apply the rewriting methodology to the semantics of query answering under NULL.\n4.1 Query answering under NULL: motivation\nA tuple c̄ of elements of U is an answer to query Q(x̄ ), denoted D |=N Q(c̄), if the formula (that represents) Q is classically true when the quantifiers on its relevant variables (or attributes) run over (U r {null}); and those on the nonrelevant variables run over U . The free relevant variables, i.e. relevant among those in x̄ , cannot take the value null either. (Relevance is made precise in Section 4.2.)\n11 We reserve the use of constant NULL to illustrate issues in relation its use in SQL databases; and to emphasize this, also in subsection titles. Otherwise, we keep using only the constant null of the underlying data domain."
    }, {
      "heading" : "20 L. Bertossi, L. Bravo",
      "text" : "Example 4.1 Consider the instance D2 and the query below:\nR A B C S B 1 1 1 null 2 null null 1\nnull 3 3 3\nQ2(x ) : ∃y∃z (R(x , y , z ) ∧ S(y) ∧y > 2)· (9)\nA variable v (quantified or not) in a conjunctive query is relevant if it appears (non-trivially) twice in the formula after the quantifier prefix. Occurrences of the form v = null and v 6= null do not count though. In query (9), the only relevant quantified variable is y , because it participates in a join and a built-in in the quantifier-free matrix of (9). So, there are two reasons for y to be relevant. The only free variable is x , which is not relevant. As for query answers, the only candidate values for x are: null, 2, 1. In this case, null is a candidate value because x is a non-relevant variable.\nFirst, x = null is an answer to the query, because the formula ∃y∃z (R(x , y , z ) ∧ S (y)∧ y > 2) is true in D2, with a non-null witness value for y and a witness value for z that combined make the (non-quantified) formula true. Namely, y = 3, z = 3. So, it holds D2 |=N Q2[null]. Next, x = 2 is not an answer. For this value of x , because the candidate value for y , namely null that accompanies 2 in P , makes the formula (R(x , y , z )∧S (y)∧y > 2) false. Even if it were true, this value for y would not be allowed.\nFinally, x = 1 is not an answer, because the only candidate value for y , namely 1, makes the formula false. In consequence, null is the only answer. 2\nThe next example with SQL queries and NULL provides additional intuition and motivation for the formal semantics of Section 4.2. Notice the use in logical queries of the new unary predicates IsNull and IsNotNull.\nExample 4.2 Consider the schema S = {R(A,B),S (B ,C )} and the instance in the table below. In it NULL is the SQL null. If this instance is stored in an SQL database, we can observe the behavior of the following queries when they are directly translated into SQL and run on an SQL DB:\nR A B S B C a b b h a c NULL s d NULL l m d e u u v NULL v r\nNULL NULL\n(a) Q1(x , y) : R(x , y) ∧ y = null SQL: Select * from R where\nB = NULL; Result: No tuple\n(b) Q′1(x , y) : R(x , y) ∧ IsNull(y) SQL: Now uses IS NULL\nResult: 〈d, NULL〉, 〈v, NULL〉, 〈NULL, NULL〉\n(c) Q2(x , y) : R(x , y) ∧ y 6= null SQL: Select * from R where\nB <> NULL;\nResult: No tuple\n(d) Q′2(x , y) : R(x , y) ∧ IsNotNull(y) SQL: Now uses IS NOT NULL\nConsistency and Trust in Peer Data Exchange Systems 21\nAnswer: The five expected tuples\n(e) Q3(x , y) : R(x , y) ∧ x = y SQL: Select * from R where A = B;\nResult: 〈u,u〉\n(f) Q4(x , y) : R(x , y) ∧ x 6= y SQL: Select * from R where A <> B;\nResult: 〈a,b〉, 〈a, c〉, 〈d, e〉, 〈v, r〉\n(g) Q5(x , y , x , z ) : R(x , y) ∧ R(x , z ) ∧ y 6= z SQL: Select * from R r1, R r2 where r1.A = r2.A and r1.B <> r2.B;\nResult: 〈a,b, a, c〉, 〈a, c, a,b〉 (h) Q6(x , y , z , t) : R(x , y) ∧ S (z , t) ∧ y = z\nSQL: Select * from R r1, S s1 where r1.B = s1.B;\nResult: 〈a,b,b,h〉 (i) As in (h), but now SQL: Select * from R r1 join S s1 on r1.B = s1.B;\nResult:12 〈a,b,b,h〉 (j) Q7(x , y , z , t) : R(x , y) ∧ S (z , t) ∧ y 6= z . In SQL: Select R1.A, R1.B, S1.B, S1.C from R R1, S S1 where R1.B <> S1.B’; Result: 〈a, c,b,h〉, 〈d, e,b,h〉, 〈u,u,b,h〉, 〈v, r,b,h〉, 〈a,b, l,m〉, 〈a, c, l,m〉, 〈d, e, l,m〉, 〈u,u, l,m〉, 〈v, r, l,m〉 2\nWe need to introduce predicates IsNull and IsNotNull in our formal treatment of nulls, because, as shown in Example 4.2, in the presence of NULL, SQL treats IS NULL and IS NOT NULL differently from classical = and 6=, resp. For example, the queries\nQ(x ) : ∃y(R(x , y) ∧ IsNull(y)) and Q′(x ) : ∃y(R(x , y) ∧ y = null) (10)\nare both conjunctive queries, but in SQL databases, they have different semantics.\n4.2 Query answering under NULL: the semantics\nHere we introduce the semantics of FO conjunctive query answering in relational databases with null values. More precisely, in SQL relational databases with a single null value, null, that is handled like the SQL NULL. We will exclude from the “SQL-like” conjunctive queries those such as (a) and (c) in Example 4.2. We will concentrate only on conjunctive queries with built-ins.\nDefinition 4.1 (a) Conj(Σnull) denotes the class of conjunctive queries in L(Σnull) of the form\nQ(x̄ ) : ∃ȳ(A1(x̄1) ∧ · · · ∧An(x̄n)), (11)\nwhere ȳ ⊆ ⋃i x̄i , x̄ = ( ⋃\ni x̄i) r ȳ , and the Ai are atoms containing any of the predicates in R∪ Bnull plus terms, i.e. variables or constants in U . (b) Conjsql(Σnull) denotes the class of conjunctive queries as in (a) whose conjuncts are never of the form t = null, t 6= null, with t a term (null or not). 2\n12 The same result is obtained from DBMSs that do not require an explicitly equality together with the join."
    }, {
      "heading" : "22 L. Bertossi, L. Bravo",
      "text" : "For example, for the queries in (10), Q,Q′ ∈ Conj(Σnull), Q ∈ Conjsql(Σnull), but Q′ /∈ Conjsql(Σnull). Notice that Conjsql(Σnull), Conj(Σ) ⊆ Conj(Σnull). The idea is to force conjunctive queries à la SQL that explicitly mention the null value in (in)equalities, to use the built-ins InNull or IsNotNull.\nDefinition 4.2 Given a query in Conj(Σnull) of the form Q(x̄ ): ∃ȳψ(x̄ , ȳ), with ψ quantifier-free, a variable v is relevant for Q if it occurs at least twice in ψ, without considering the atoms IsNull(v), IsNotNull(v), v θnull, or nullθv , with θ ∈ B. RelV (Q) denotes the set of relevant variables for Q. 2\nFor example, for the queryQ(x ) : ∃y(P(x , y , z )∧Q(y)∧IsNull(y)),RelV (Q(x )) = {y}, because y is used twice in the subformula P(x , y , z ) ∧Q(y).\nAs usual in FO logic, we consider assignments from the set, V ar, of variables to the underlying database domain U (that contains constant null), i.e. σ : V ar → U . Such an assignment can be extended to terms, mapping variables x to σ(x ), and c ∈ U to c. For an assignment σ, a variable y and a constant c, σ yc denotes the assignment that coincides with σ everywhere, except possibly on y , that takes the value c. Given a formula ψ, ψ[σ] denotes the formula obtained from ψ by replacing its free variables by their values according to σ.\nNow, given a formula (query) χ and an assignment σ, we verify if instance D satisfies χ[σ] by assuming that the quantifiers on relevant variables range over (U r {null}), and those on non-relevant variables range over U .\nDefinition 4.3 Let χ ∈ Conj(Σnull), and σ be an assignment. Instance D with σ satisfies χ under the null-semantics, denoted D |=\nN χ[σ], exactly in the following cases: (below\nt , t1, . . . are terms; and x , x1, x2 variables) 1. (a) D |=N IsNull(t)[σ], with σ(t) = null. (b) D |=N IsNotNull(t)[σ], with σ(t) 6= null. 2. D |= N\n(t1 < t2)[σ], with σ(t1) 6= null 6= σ(t2), and σ(t1) < σ(t2).13 3. (a) D |=\nN (x = c)[σ], with σ(x ) = c ∈ (U r {null}). (or symmetrically)14\n(b) D |= N (x1 = x2)[σ], with σ(x1) = σ(x2) 6= null. (c) D |=\nN (c = c)[σ], with c ∈ (U r {null}).\n4. (a) D |= N (x 6= c)[σ], with null 6= σ(x ) 6= c ∈ (U r {null}). (or symmetrically) (b) D |=\nN (c1 6= c2)[σ], with c1 6= c2, and c1, c2 ∈ (U r {null}).\n5. D |= N R(t1, . . . , tn)[σ], with R ∈ R, and R(σ(t1), . . . , σ(tn)) ∈ D . 6. D |=\nN (α∧β)[σ], with α, β quantifier-free, σ(y) 6= null for every y ∈ RelV (α∧β), and D |=N α[σ] and D |=N β[σ]. 7. D |=N (∃y α)[σ] when: (a) if y ∈ RelV (α), there is c in (U r {null}) with\nD |= N α[σ yc ]; or (b) if y 6∈ RelV (α), there is c in U with D |=N α[σ y c ]. 2\nThis semantics also applies to Conjsql(Σnull).\n13 Of course, when there is an order relation on U . We could introduce “>” similarly. 14 Notice the use of the symbols = and 6= both at the object and the meta levels.\nConsistency and Trust in Peer Data Exchange Systems 23\nDefinition 4.4 Let Q(x̄ ) : ∃ȳψ(x̄ , ȳ) be in Conj(Σnull), with x̄ = x1, . . . , xn , and ψ quantifier-free. (a) A tuple 〈c1, . . . , cn〉 ∈ Un is an N -answer from D to Q, denoted D |=N Q[c1, . . . , cn ], iff there is an assignment σ such that σ(xi) = ci , for i = 1, . . . ,n; and D |=N (∃ȳψ)[σ]. (b) If Q is a sentence (a Boolean query), the N -answer is yes iff D |=\nN Q, and no,\notherwise. (c) QNsem(D) denotes the set of N -answers to Q from instance D . 2 Notice that D |=\nN (∃ȳψ)[σ] in (a) above requires, according to Definition 4.3, that\nthe relevant variables in the existential prefix ∃ȳ do not take the value null. The free variables, i.e. in x̄ , may take the value null only when they are not relevant in the query. For illustration, in Example 4.1, since the free variable x is not relevant, QNsem2 (D2) = {〈null〉}. Example 4.3 Consider the instance D and the conjunctive query below.\nR A B a b c d e null\nS B C b f d g\nnull j\nQ(x , z ) : ∃y(R(x , y) ∧ S (y , z )).\nHere, under the classical semantics, Q(D) = {〈a, f 〉, 〈c, g〉, 〈e, j 〉}, treating null as any other constant. However, QNsem(D) = {〈a, f 〉, 〈c, g〉} ⊆ Q(D). 2\nIt is easy to prove that, for queries in Conj(Σnull): QNsem(D) ⊆ Q(D). Furthermore, the N -query answering semantics coincides with classical FO query answering semantics in databases without null. More precisely, if null /∈ U (and then it does not appear in D or Q either): D |=\nN Q[t̄ ] iff D |= Q[t̄ ].\n4.3 Constraint satisfaction under NULL via FO rewriting\nThe notions of relevant attributes (or variables) and formula satisfaction under the null-semantics can be both extended to more complex formulas. In particular, they can be applied to constraint satisfaction under SQL NULL (Bravo and Bertossi 2006; Bravo 2007). As expected, the satisfaction of a constraint ψ by a database that may contain null depends upon the presence of null in the relevant attributes of ψ. The following is a generalization of Definition 4.2 to a larger class of formulas.\nDefinition 4.5 For ψ ∈ L(Σnull) in prenex normal form,15 a variable v is relevant if it occurs at least twice in ψ, without considering occurrences in quantifiers or atoms of the forms IsNull(v), IsNotNull(v), v θnull, or nullθv , where θ a built-in comparison predicate. RelV (ψ) denotes the set of relevant variables of ψ. 2\n15 That is, of the form Q̄χ, where Q̄ is a prefix of quantifiers, and χ is a quantifier-free formula. Actually, in this work all the formulas have a quantifier prefix of the form ∀̄∃̄."
    }, {
      "heading" : "24 L. Bertossi, L. Bravo",
      "text" : "The constraints we are considering in this work, particularly those of the form (2), may not be in prenex normal form, but can be easily transformed while keeping the same variables and their occurrences, so that relevant variables can be determined.\nExample 4.4 Consider the referential integrity constraint (RIC) on schema R = {P(A,B ,C ), R(A,B ,E )}: ψ : ∀x∀y∀z (P(x , y , z )→ ∃vR(x , y , v)); and the instance D :\nP A B C R A B E\na 5 d a 5 3 b null a a 3 7\nDBMSs implement the so-called “simple semantics” of the SQL Standard for satisfaction of ICs. According to it, the database D above satisfies the RIC. This is because, for every tuple t in P , if t [A] and t [B ] are different from null, there is a tuple t ′ in R with t [A,B ] = t ′[A,B ]. In this case, and informally, the attributes that are relevant for checking the satisfaction of the RIC (i.e. those we attempt to capture through the relevant variables) are A and B , in both P and R. If we try to insert tuple P(c, d , null) into P , the DBMS will reject the insertion, because none of the attributes that are relevant for checking the constraint are null, and there is no tuple R(c, d).\nMore precisely, the set of relevant variables for ψ is RelV (ψ) = {x , y}, because x and y appear twice in ψ. Accordingly, the values for attributes C and E are not relevant when checking the satisfaction of ψ, which makes sense. 2\nWe will now formalize constraint satisfaction under the null-semantics. In this direction, we consider a single class of constraints that includes those in (1) and (2), and can be handled in a uniform manner. It also includes all the common constraints used in data management. More precisely, we consider constraints that are sentences in L(Σnull) of the form:\n∀x̄ ( n∧\ni=1\nRi(x̄i) −→ m∨\nj=1\nCj ), (12)\nwhere m,n 6= 0, Ri is a predicate in R, Cj is a conjunctive formula of the form ∃ȳj ∧l k=1 Qjk (x̄\n′ jk , ȳjk ), where each Qjk is a predicate in R or a built-in,16 x̄ =⋃n\ni=1 x̄i , x̄ ′ jk ⊆ x̄ , and ȳj = ⋃l k=1 ȳjk . Without loss of generality, we assume that the existentially quantified variables (the ȳj ) do not appear in x̄ and are different for each conjunctive literal Cj . Notice that (12) allows formulas with only built-in atoms in the consequent. We also assume that they do not have any explicit occurrence of the constant null.17 Those formulas may contain the IsNull or IsNotNull, but as built-in predicates.\n16 Occurrences of variables in built-ins have to be safe, i.e. they also appear in x̄ or in database predicate in the same conjunction. 17 This is not an essential requirement, but will simplify the presentation. Furthermore, all reasonable DECs and local ICs do not require the explicit use of null as a constant. If we need to express a relational NOT-NULL-constraint, we can say, e.g. ∀x∀y(R(x , y)→ IsNotNull(x)).\nConsistency and Trust in Peer Data Exchange Systems 25\nIn order to define N -satisfaction of a constraint ψ ∈ L(Σnull) of the form (12), we first rewrite it into a new FO formula ψN , which makes explicit the role played by the relevant attributes in ψ (as in Definition 4.5) and the way nulls are handled in them. Next, satisfaction is defined in terms of the rewriting.\nDefinition 4.6 Let ψ ∈ L(Σnull) be a constraint of the form (12), i.e. ∀x̄ (∧ni=1 Ri(x̄i) −→ ∨m j=1 Cj ). (a) The N -rewriting of ψ is the L(Σnull)-sentence:\nψN : ∀x̄ ( n∧\ni=1\nRi(x̄i) → ( ∨\nv∈RelV (ψ)∩x̄ IsNull(v) ∨\nm∨\nj=1\nCNj )), (13)\nwith x̄ = ∪ni=1x̄i and\nCNj = ∃ȳj ( l∧\nk=1\nQjk (x̄ ′ jk , ȳjk ) ∧\n∧\nw∈((RelV (ψ)rx̄)∩ȳj ) IsNotNull(w)) · (14)\n(b) For an instance D , possibly containing null, ψ is N -satisfied by D , denoted D |=N ψ, iff D |= ψN . Here, D |= ψN refers to classical first-order satisfaction, with null treated as any other constant of the domain. 2\nWe can see from Definition 4.6 that there are basically two cases when a ground instantiation of ψ (obtained by assigning constants to the variables in x̄ ) is immediately satisfied due to the presence of null: (a) When null appears in any of the relevant attributes in the antecedent. (b) At least one of the conjunctive formulas Cj is true, considering that when they are checked according to equation (14), null is treated as any other constant, but the variables in existential joins do not take the value null (hence the condition based on w ∈ (RelV (ψ) r x̄ ) ∩ ȳj in (14)). The rewriting can be applied in particular to our UDECs and RDECs, as follows.\nFor a UDEC ψ of the form (1), ψN is:\n∀x̄ ( n∧\ni=1\nRi(x̄i) → ( ∨\nv∈RelV (ψ) IsNull(v) ∨\nl∧\nk=1\n(\nm∨\nj=1\nQkj (ȳj )))) · (15)\nFor an RDEC ψ of the form (2), ψN is:\n∀x̄ ( n∧\ni=1\nRi(x̄i) → ( ∨\nv∈(RelV (ψ)∩x̄) IsNull(v) ∨ ∃ȳ(\nl∧\nk=1\n(Qk (x̄k , ȳk ) ∧ ϕk (x̄ ′k , ȳ ′k )) ∧\n∧\nw∈(RelV (ψ)rx̄) IsNotNull(w)) ) )· (16)\nExample 4.5 (example 4.4 cont.) The rewriting ψN of the RIC ψ is, according to (16):\nψN : ∀x∀y∀z (P(x , y , z ) → IsNull(x ) ∨ IsNull(y) ∨ ∃wR(x , y ,w))·\nD classically satisfies ψN , treating null as any other constant. Then, D |=N ψ. 2"
    }, {
      "heading" : "26 L. Bertossi, L. Bravo",
      "text" : "Example 4.6 For ψ : ∀x (R(x )→ ∃y(T (x , y) ∧ S (y)), RelV (ψ) = {x , y}. From (16):\nψN : ∀x (R(x ) → IsNull(x ) ∨ ∃y(T (x , y) ∧ S (y) ∧ IsNotNull(y))·\n(a) For D = {R(a)}, D 6|= ψN ; and then, D 6|=N ψ. (b) For D = {R(a),T (a, null),S (null)}, D 6|= ψN ; and then, D 6|=N ψ. (c) For D = {R(a),T (a, b),S (b)}, D |= ψN ; and then, D |=N ψ. (d) For D = {R(null)}, D |= ψN ; and then, D |=N ψ. (e) For D = ∅, D |= ψN ; and then, D |=N ψ. 2\nExample 4.7 Consider the schema S = {R(A,B ,E )} with the primary key constraint (KC) R : AB → E , expressing that attributes A,B , together, functionally determine attribute E .18 An SQL database with the instance D = {R(a, 5, 3),R(a, 3, 7)}, which contains no nulls, would satisfy the KC.\nThe insertion of R(null, 4, 5) into D would be rejected since the KC would be violated: null is not allowed in a key attribute.The insertion of R(a, 5, null) would also be rejected, but now due to the potential occurrence of two R-tuples t1, t2 with t1[A] = t2[A] = a and t1[B ] = t2[B ] = 5, but being unknown whether t1[E ] = t2[E ].\nIn order to fully capture this KC in predicate logic and the intended semantics\nwe just described, we need the following sentences to represent the KC:\nψ1 : ∀x∀y∀z1∀z2(R(x , y , z1) ∧ R(x , y , z2)→ z1 = z2), (17) ψ2 : ∀x∀y∀z1∀z2(R(x , y , z1) ∧ R(x , y , z2) ∧ IsNull(z1)→ IsNull(z2)), (18) ψ3 : ∀x∀y∀z (R(x , y , z ) ∧ IsNull(x )→ false), (19) ψ4 : ∀x∀y∀z (R(x , y , z ) ∧ IsNull(y)→ false)· (20)\nThe first two constraints ensure that, if two tuples coincide in attributes A and B , then they have the same value in z or they are both null. The last two constraints ensure that the values in attributes A or B in relation R cannot be null.\nActually, (18) can be written as\n∀x∀y∀z1∀z2(R(x , y , z1) ∧ R(x , y , z2)→ ¬IsNull(z1) ∨ IsNull(z2)), or equivalently, as a UDEC of the form (1):\nψ′2 : ∀x∀y∀z1∀z2(R(x , y , z1) ∧ R(x , y , z2)→ IsNotNull(z1) ∨ IsNull(z2)), Similarly, (19) and (20) can be written as UDECs of the form (1):\nψ′3 : ∀x∀y∀z (R(x , y , z ) → IsNotNull(x )), ψ′4 : ∀x∀y∀z (R(x , y , z ) → IsNotNull(y))·\nSo, finally, the KC is represented by the UDECs ψ1, ψ ′ 2, ψ ′ 3, ψ ′ 4.\n18 A key constraint is a particular kind of functional dependency, where a set of attributes of a relational predicate functionally determines all the attributes of the predicate. Declaring a key constraint as primary in an SQL-based relational DBMS has in particular the effect that NULL is not accepted in key attributes.\nConsistency and Trust in Peer Data Exchange Systems 27\nFor illustration, considering that RelV (ψ1) = {x , y , z1, z2}, and RelV (ψ′3) = ∅, we obtain from (15):\nψN1 : ∀x∀y∀z1∀z2(R(x , y , z1) ∧ R(x , y , z2) → IsNull(x ) ∨ IsNull(y) ∨ IsNull(z1) ∨ IsNull(z2) ∨ z1 = z2), (21) (ψ′3) N : ∀x∀y∀z (R(x , y , z ) → IsNotNull(x ))· (22)\nFinally, observe that when the atom z1 = z2 in ψ N 1 is evaluated on the domain, the constant null is treated as any other constant, i.e. null = c is true only when constant c is null. 2\nWe have managed to reduce constraint satisfaction under NULL as handled by SQL databases to formula satisfaction in FO predicate logic, without assigning any special status to null, which is treated as an ordinary constant. We considered only constraints of the form (12), which include all our DECs and ICs for peers, in which case, the generic set of database predicates R will contain those for a single peer or a pair thereof. However, the semantics can be extended to more general FO formulas (Bravo 2007).\n4.4 Query answering under NULL via FO rewriting\nThe notion of query answer under NULL, that of N -answer given in Section 4.2, being interesting per se, allowed us to motivate the treatment of constraints via relevant variables. However, query answering in presence of null can also be treated via the rewriting in Definition 4.6. This is achieved by considering conjunctive queries as a special case of (12), without the ∀x̄ and empty antecedents; and obtaining their relevant variables through Definition 4.5.\nMore precisely, a conjunctive query Q(x̄ ) ∈ Conj(Σnull), i.e. of the form (11), is rewritten into a new conjunctive query as follows:\nQN (x̄ ) : ∃ȳ(A1(x̄1) ∧ · · · ∧An(x̄n) ∧ ∧\nv∈RelV (Q) v 6= null) · (23)\nIt holds: D |= N Q[c̄] iff D |= QN [c̄], where the latter is classic FO satisfaction, with null treated as an ordinary constant in the domain.\nThis transformation ensures that relevant variables range over (U r {null}). QN (x̄ ) ∈ Conj(Σnull), and may contain atoms of the form IsNull(t) or IsNotNull(t). However, they can be replaced by t = null or t 6= null, resp., leading to a query in Conj(Σ), but with the same answers as (23).\nExample 4.8 Consider the instance D below, and the query Q(x ) : ∃y(P(x , y)∧y > 5), for which RelV (Q) = {y}. In this case, the bound variable is the only relevant variable, and then ranges over non-null values when checking query satisfaction."
    }, {
      "heading" : "28 L. Bertossi, L. Bravo",
      "text" : "Accordingly, D |=N Q[f ] holds, because ∃y(P(f , y) ∧ y > 5) is true in D , with 7 as a non-null value for y that makes the formula true. This result is confirmed by the rewriting of Q(x ).\nP A B\nf 7 f 5 null 8\nb null\nFor QN (x ) : ∃y(P(x , y) ∧ y > 5 ∧ IsNotNull(y)), D |= QN [f ] holds, under classical satisfaction, with null treated as any other constant. Similarly, D |=N Q[null]. 2\nExample 4.9 (example 4.1 continued) The query in (9) can be rewritten as QN2 (x ) : ∃y∃z (R(x , y , z ) ∧ S (y) ∧ y > 2 ∧ y 6= null)· We had D 6|=\nN Q2[1]. Now, D 6|= ∃y∃z (R(1, y , z ) ∧ S (y) ∧ y > 2 ∧ y 6= null),\nclassically, with null treated as an ordinary constant. As expected, D 6|= QN2 [2] due to the new conjunct y 6= null.\nFinally, D |= QN2 [null] because D |= (R(null, 3, 3) ∧ S (3) ∧ 3 > 2 ∧ 3 6= null). Since null is treated as any other constant, we can compare it with 3. By the unique names assumption, 3 6= null holds. 2\nOur query answering N -semantics for Conj(Σnull) can be applied in particular\nany SQL-like conjunctive query, but first expressing it as a queryQ in Conjsql(Σnull), and then computing and classically evaluating QN .\nThe notions of constraint satisfaction and query answer in the presence of NULL à la SQL we introduced in this section coincide with the classic notions in databases without null.\nIn the rest of this work, the notion of formula satisfaction that we have denoted with |=N will be simply denoted with |=. When constraints are not satisfied in this sense, we will apply a particular repair semantics that captures the special role of null. It is introduced in the next section."
    }, {
      "heading" : "5 Solution Semantics with NULL",
      "text" : "In the preceding section, we introduced a notion of formula satisfaction with database instances that may contain null. We now use it for defining the semantics of a peer system where the data movement process relies on consistency restoration of peer instances with respect to DECs. The value null will be used to replace existentially quantified variables in consequents of referential DECs and local referential ICs as a possibility to consider for DEC and IC enforcement. Another possibility for the same task is tuple deletion.\nThe repair semantics that supports consistency restoration will have to capture and be sensitive to the (possibly multiple) presence of null in the database and its use for consistency enforcement. In particular, it has to give an account of the facts that:\nConsistency and Trust in Peer Data Exchange Systems 29\n1. When atoms are inserted into the database, an existential variable that ap-\npears in a join or in a built-in atom in an RDEC’s consequent (a so-called problematic existential variable) is never replaced by (or takes the value) null. 2. Arbitrary non-null constants from the domain are not used for these prob-\nlematic variables either. Actually, rather than introducing arbitrary values for existential variables of this kind, tuple deletions from antecedents in DECs will be privileged."
    }, {
      "heading" : "5.1 A restricted chase",
      "text" : "In order to achieve the just stated goals, we first introduce a restricted, ad hoc form of the chase (Abiteboul et al. 1995), as an auxiliary construct. It is applied only with the DECs and ICs at hand that do not have problematic existential variables in their consequents. The enforcement of this subset of the constraints introduces tuples with null for existential variables (that do not appear in joins though).\nIn the end, this chase will return a finite set of atoms that will be used as a possibly generous upper-bound for the admissible tuple insertions that create repairs and solutions on the basis of the whole sets of DECs at hand.\nAs any other form of chase, our restricted chase enforces the satisfaction of constraints, but in our case the notion of satisfaction corresponds to that introduced in Section 4.3.\nIn the rest of this subsection, we consider a database instance D and a set of DECs Σ = Σ1∪Σ2, with Σ1 a set of UDECs of the form (1) and Σ2 a set of RDECs of the form (2). We consider the subset, Σ−2 of Σ2 that contains all the RDECs except for those involving existentially quantified variables in joins or built-in atoms. Accordingly, we consider Σ− := Σ1 ∪ Σ−2 .\nDefinition 5.1 The restricted chase, r -Chasenull(D ,Σ−), with an instance D and Σ− = Σ1 ∪Σ−2 , is the instance D ′ obtained as a fix-point of the following iterative procedure:\n1. D ′0 := D . 2. Given instance D ′s , if D ′ s |= Σ− (relative to |=N ), then D ′s+1 := D ′s . 3. Given instance D ′s , if a ground instantiation, ϕ↓, of a constraint ϕ ∈ Σ1 (with constants or null) is not satisfied by D ′s (relative to |=N ), but its antecedent is, then D ′s+1 is obtained from D ′ s by adding the ground database atoms appearing\nin every disjunct of every conjunct in the consequent of ϕ↓ (but only when the built-ins in the conjunct are satisfied). Notice that this excludes the generation of atoms with any kind of built-ins, including the atom false. 4. Given instance D ′s , if a ground instantiation (obtained by replacing universal variables with constants or null, but keeping the existential quantifiers) of a\nconstraint in Σ−2 is not satisfied by D ′ s , but its antecedent is, then replace the existentially quantified variables by null, and build D ′s+1 by adding to D ′ s the corresponding ground atoms in the conjunct in the consequent (but only when the built-ins in it are satisfied). 2"
    }, {
      "heading" : "30 L. Bertossi, L. Bravo",
      "text" : "This procedure finitely terminates as we show below, but first some intuitions, explanations and examples. The chase procedure propagates and invents values due to the enforcement of RECs with non-problematic existential quantifiers and UDECs. As a result, the constants in the chase instance will be those already appearing in the initial instance D , those that appear explicitly in consequents of DECs, or null as a value invented for (non-problematic) existentially quantified variables.\nExample 5.1 Consider the following set of constraints, classified according to Definition 5.1:\nΣ1 = {∀x∀y(T (x , y)→ R(x , y)), (24) ∀x∀y∀z (R(x , y) ∧ S (y , z )→ Q(x , y , z ) ∨ T (x , z )), (25) ∀x∀y∀z (Q(x , y , z )→ S (x , y) ∧ R(y , z )), (26) ∀x∀y∀z (T (x , y) ∧ T (x , z )→ y = z ), (27) ∀x∀y(T (x , y) ∧ S (x , y)→ false), (28)\nΣ−2 = {∀x∀y(R(x , y)→ ∃z (Q(x , y , z ) ∧ x 6= y), (29) ∀x∀y∀z (Q(x , y , z )→ ∃w(R(x , z ) ∧ S (x ,w))}· (30)\nIndependently from the instance at hand (initial or not) at a chase step, constraints (27) and (28), will never be applied (or enforced).\nIf D contains T (a, null), then the ground instantiation T (a, null)→ R(a, null) of (24) is satisfied under |=N , even if D does not contain R(a, null). This is because both variables x , y in (24) are relevant (cf. Definition 4.5). So, R(a, null) is not generated. However, if T (a, b) ∈ D and R(a, b) /∈ D , the latter atom is generated. Now, the ground instantiation R(a, a) → ∃z (Q(a, a, z ) ∧ a 6= a) of (29) will not create new tuples because of the inequality a 6= a. However, if R(a, b) ∈ D , and the instantiation R(a, b) → ∃z (Q(a, b, z ) ∧ a 6= b) is not satisfied, the tuple Q(a, b, null) will be created.\nThe ground instantiation R(a, b) ∧ S (b, c) → Q(a, b, c) ∨ T (a, c) of (25), with R(a, b), S (b, c) ∈ D , will generate both Q(a, b, c) and T (a, c) (if it was not already satisfied).\nNotice that creation of Q(a, b, null) above, due to (29), feeds the antecedent of (26). However, its instantiation Q(a, b, null) → S (a, b) ∧ R(b, null)) is satisfied, because null appear for variable z that is relevant. So, R(b, null) is not generated.\n2\nRemark 5.1 (a) Notice that in the DEC (26) all variables, x , y , z , are relevant. As a consequence, any ground atom with predicate Q with null in it will not trigger the rule. We can see that, every time the chase introduces null in a predicate position that turns out to be relevant in another DEC, this latter DEC will not be triggered (because it will be automatically satisfied). This possibly very common situation will contribute to a fast termination of the chase.\n(b) We can assume that the chase applies in parallel all possible instantiations of\nConsistency and Trust in Peer Data Exchange Systems 31\nDECs in Σ−. It is clear that this restricted null-based chase always terminates, because only the elements of the initial active domain plus possibly null are used to fill arguments in database predicates, which leads to a saturation point in polynomialtime in the size of instance D and the schema. In particular, the resulting instance is of polynomial size in the size of D .\n(c) Instead of using the chase procedure (in case we wanted a more model-theoretic or declarative approach to the chase instance), we could replace each sentence in Σ1 by a collection of Datalog rules, one for each disjunct in the consequent; and each sentence in Σ−2 by a Datalog rule obtained replacing existential variables by null. The chase instance would coincide with the minimal model of the resulting Datalog program (Abiteboul et al. 1995). 2\nNotice that r -Chasenull(D ,Σ−) may not satisfy Σ, for the trivial reason that not all DECs in Σ are considered in the chase. Actually, r -Chasenull(D ,Σ−) may not even satisfy Σ−, because it ignores DECs with only built-ins in consequents. For illustration, in Example 5.1, the chase of D = {T (a, b),T (a, c)} will not satisfy (27), and the chase of D = {T (a, b),S (a, b)} will not satisfy (28).\nThe next step will be imposing r -Chasenull(D ,Σ−) as an upper bound on the extensions of possible repairs. With this we will discard candidate repairs that introduce arbitrary, non-mandatory, non-null constants. In other words, we will use the result of this chase to test candidate repairs (or solutions), demanding their inserted atoms to be contained in the chase applied with the subset Σ− of the set Σ of DECs at hand."
    }, {
      "heading" : "5.2 Repair semantics with NULL and solutions",
      "text" : "A repair semantics for single relational databases and sets of ICs that may include referential ICs is proposed in (Bravo and Bertossi 2006; Bravo 2007). It introduces null values of the kind described in Section 4.3. We will adopt and adapt this repair semantics in the context of PDESs, by taking into account the restrictions imposed by the chase we just introduced, and also the trust relationships.\nSo as repairs of an inconsistent instance with respect to a set of ICs, solutions for a peer in a PDES are expected to stay “close” to the original peer’s instance, while satisfying its DECs. In order to capture “closeness” in our null-based semantics, we need to compare instances and their tuples, which may contain constant null.\nDefinition 5.2 (Levene and Loizou 1997) For constants c, d ∈ U , c provides less or equal information than d , denoted c v d , iff c = null or c = d . For sequences s̄1 = 〈c1, . . . , cn〉 and s̄2 = 〈d1, . . . , dn〉, with ci , di ∈ U , s̄1 provides less or equal information than s̄2, denoted s̄1 v s̄2, iff ci v di for every i = 1, . . . ,n. Finally, s̄1 @ s̄2 means s̄1 v s̄2 and s̄1 6= s̄2. 2\nDefinition 5.3 Consider D ,D ′,D ′′ be database instances for the same schema, and a set Σ of DECs"
    }, {
      "heading" : "32 L. Bertossi, L. Bravo",
      "text" : "of the form (1) or (2) in the language of the schema. Let Σ− be the subset of Σ that excludes the DECs with problematic existential variables (cf. Section 5.1).\n(a) D ′ is at least as close to D as D ′′ (is to D), denoted D ′ ≤ΣD D ′′, iff one of the following holds:\n1. D ′′ 6⊆ r -Chasenull(D ,Σ−). 2. For every P(ā) ∈ ∆(D ,D ′), there exists P(ā ′) ∈ ∆(D ,D ′′), such that:\ni. ā v ā ′, and ii. if ā @ ā ′, then P(ā ′) 6∈ ∆(D ,D ′). (b) D ′ is closer to D than D ′′ (is to D), denoted D ′ <ΣD D\n′′, iff D ′ ≤ΣD D ′′, but not D ′′ ≤ΣD D ′. 2\nDefinition 5.4\nGiven an instance D and a set Σ of DECs of the forms (1) or (2), a null-based repair of D with respect to Σ is an instance D ′ such that D ′ |=N Σ, and there is no D ′′, such that D ′′ |=N Σ and D ′′ <ΣD D ′. 2\nThis definition ensures, in particular, that a database that, due to the enforcement of an RDEC with a non-problematic existential variable, inserts a tuple with null for that variable, is closer to D than another that adds some other, arbitrary constant. At the same time, the definition makes us prefer repairs obtained via tuple deletions instead of tuple insertions (with values null or not), when enforcing RDECs with problematic existential variables.\nThe null-based repair semantics, in particular Definition 5.4, is also of independent interest in the context of single inconsistent databases with respect to a set of ICs that are like the DECs we are considering in the PDES setting. Actually, this is the official and detailed formalization of the repair semantics first sketched and used in (Bravo and Bertossi 2006) for databases with referential ICs. The idea in that case is that inconsistencies are preferably repaired through the insertion of tuples with the special constant null, that is used as the null in SQL. When this is not possible, tuple deletions are preferred. This happens either because a constraint cannot be solved via tuple insertions at all (e.g. functional dependencies) or an inclusion dependency would have to be satisfied through the use of null for variables in a join. The next two examples show how this repair semantics would be used for repairing a single database.\nExample 5.2 (example 4.6 cont.) Consider Σ = {∀x (R(x ) → ∃y(T (x , y) ∧ S (y))}, and the instance D = {R(a)}.\nHere, Σ− = ∅, and r -Chasenull(D ,Σ−) = {R(a)}. Furthermore, D 6|= Σ (this is case (a) in Example 4.6).\ni. D ′1 = {R(a),T (a, null),S (null)} 6|= Σ (this is case (b) in Example 4.6). So, D ′1 is not a repair.\nii. D ′2 = ∅ |= Σ (this is case (e) in Example 4.6). D ′2 is a repair. Indeed, for any instance D ′′ that is not contained in r -Chasenull(D ,Σ−), D ′2 ≤ΣD D ′′ holds. So, the only possible improvement on D ′2 could be {R(a)}, which does not satisfy Σ.\nConsistency and Trust in Peer Data Exchange Systems 33\niii. D ′3 = {R(a),T (a, a),S (a)} |= Σ (as case (c) in Example 4.6), but it is not a repair.\nIndeed, first notice that D ′2 ≤ΣD D ′3, because D ′3 6⊆ r -Chasenull(D ,Σ−). Now, D ′3 6≤ΣD D ′2, because condition 2. of Definition 5.3 does not hold for S (a) (or T (a, a)). We have obtained that D ′2 < Σ D D ′ 3, i.e. the former, which is a repair, is strictly closer to D than the latter. The same holds for any instance of the form D ′4 = {R(a),T (a, b),S (b)} (and its supersets). 2\nExample 5.3 Consider Σ = {∀x∀y∀z (T (x , y) ∧ T (x , z ) → y = z ), ∀x∀y(T (x , y) ∧ S (x , y) → false)}, containing a functional dependency and a denial constraint. The instance D = {T (a, b),T (a, c),S (a, c)} is inconsistent with respect to Σ.\nHere, Σ− = Σ. However, the restricted chase does not apply any of the ICs, because they contain only built-ins in the consequent. So, r -Chasenull(D ,Σ−) = D . As a consequence, only repairs based on tuple deletions are acceptable. In this case, D ′ = {T (a, b),S (a, c)} is the only repair. 2\nSince the ≤ΣD relations can take the place of the generic relation Σ(P) D used in Section 3, ≤D determines, through the instantiation of Definition 3.1, a concrete repair semantics that determines null-based neighborhood solutions for a peer P, in which case the definition has to be applied with Σ(P). However, Definition 5.4 does not take into account the trust relationships in a neighborhood that are imposed in Definition 3.1. As a consequence, to have a null-based notion of neighborhood solution, we have to impose the additional requirement that certain database relations in a neighborhood instance have to stay untouched (they belong to a peer that is most trusted).\nHaving a specific notion of neighborhood solution, it is possible to obtain, following the developments in Section 3, also specific definitions of solution and core for a peer, and the notion of peer-consistent answer. In the rest of this section we provide some additional examples that show aspects of this specific semantics, and in the following subsections we investigate computational problems related to this semantics.\nExample 5.4 (example 5.2 continued) Consider a PDES instance D for the schema P with peers P1 and P2, with S(P1) = {R}, S(P2) = {T ,S}, and Trust = {(P1, same, P2)}. Assume the only DECs are those in Σ(P1, P2) = {∀x (R(x )→ ∃y(T (x , y) ∧ S (y))}. So, Σ−(P1, P2) = ∅.\nAssume that the instance of the neighborhood of P1 is D = {R(a)}. Here, D 6|= Σ(P1, P2). So, in order to obtain a neighborhood solution, we have to repair D with respect to Σ(P1, P2).\nSince P1 trusts P2 the same as itself, in principle we could insert tuples into P2’s relations or delete tuples from P1’s relation. However, in this case (cf. Example 5.2), since r -Chasenull(D ,Σ−(P1, P2)) = {R(a)}, the only neighborhood solution is the empty instance: ∅ |=N Σ(P1, P2), and ∅ <Σ(P1)D D ′, for any S(P1, P2)-instance D ′ that inserts tuples. 2"
    }, {
      "heading" : "34 L. Bertossi, L. Bravo",
      "text" : "Similarly, the generic Definition 3.2 of solution and core for peers, can be instantiated with the null-based solution semantics, i.e. on the basis of the ≤ΣD relations, obtaining specific versions of those definitions. Accordingly, we recall that, given an instance D = {D(Q) | Q ∈ P} for the schema P, the core of peer P is the intersection of its solutions: Core(P,D) := ⋂ Sol(P,D).\nExample 5.5 (example 2.1 continued) Consider the following peers’ instances: D(P1)={R1(a, 2)}, D(P2) = {R2(c, 4),R2(d , 5)}, D(P3) = {R3(c, 4)}, and D(P4) = {R4(d , 5, 1)}. So, the PDES instance is D = {D(P1),D(P2),D(P3),D(P4)}.\nIf we want the solutions for P4, we first need the solutions for P3 and P2, who also needs the solution for P3. Since P3 has no DECs with other peers, its only neighborhood solution is its local instance D(P3), which is sent back to P2 or P4 if request.\nPeer P2 needs to find the neighborhood solutions for {R2(c, 4),R2(d , 5),R3(c, 4)} with respect to Σ(P2, P3). Since P2 trusts P3 the same as itself, it can modify its own data or the data it got from P3. There are two neighborhood solutions for P2: {R2(c, 4),R2(d , 5)} and {R2(d , 5),R3(c, 4)}, that restricted to P2’s schema lead to two solutions for P2: Sol(P2,D)={{R2(c, 4),R2(d , 5)}, {R2(d , 5)}}. Peer P2 sends to P4 the intersection of its solutions: Core(P2,D) = {R2(d , 5)}.\nNeighborhood solutions for P4 are obtained by repairing {R4(d , 5, 1), R2(d , 5), R3(c, 4)} with respect to Σ(P4, P2), and Σ(P4, P3). The DECs in Σ(P4, P2) are already satisfied, but not those in Σ(P4, P3). Since P4 trusts the data in P3 more than its own, the only neighborhood solution for P4 is obtained by inserting a tuple with null into P4’s: {R4(d , 5, 1),R2(d , 5),R3(c, 4), R4(c, 4, null)}. Consequently, Sol(P4,D) = {{R4(d , 5, 1), R4(c, 4, null)}}. 2\nDue to a particular combination of DECs, trust relationships, and local instances, it is possible that a peer has not solution, which may happen with or without the null-based repair semantics. For illustration, Example 3.2, now with the null-based solution semantics, still does not have solutions."
    }, {
      "heading" : "5.3 Complexity of neighborhood solutions",
      "text" : "We now investigate the complexity of decision problems related to the general case of DECs of the form (12) (cf. Section 4), in combination with the null-based repair semantics we introduced in this section.\nWe concentrate mostly on the case that is directly relevant to our forthcoming answer-set programming (ASP) approach to specifying solutions for individual peers when they have already gathered their neighbors solutions. That is, we consider specifications and reasoning at the neighborhood level (cf. Section 6). Accordingly, we start by analyzing the complexity of deciding if an instance is a neighborhood solution (cf. Definition 3.1).\nDefinition 5.5 Consider a PDES schema P = 〈P,S,Σ, T rust〉 and a peer P ∈ P. Given an\nConsistency and Trust in Peer Data Exchange Systems 35\ninstance D̄ for the neighborhood schema S(N (P)) around P, and an instance J for the schema S(N (P)), the NeighborhoodSol decision problem is about determining if J is a neighborhood solution for P and D̄ , i.e. about membership of the set:\nNeighborhoodSol(P, P) = {(J , D̄) | J ∈ NS(P, D̄)}. 2\nThis decision problem is parameterized by peer schemas and selected peers. The\ninputs are database instances. Then, we are considering data complexity.\nProposition 5.1 NeighborhoodSol is coNP -complete in the size of J ∪ D̄ . 2\nNotice that Proposition 5.1 has to be interpreted as follows (and similarly those that follow in this section): For every peer schema P, NeighborhoodSol(P, P) is in coNP; and there is a peer schema P0 and a peer P0 in it, such that the associated problem NeighborhoodSol(P0, P0) is coNP-hard.\nProposition 5.1 holds already for PDES with a single peer with local integrity constraints; actually with (cyclic) sets of RDECs of the simple form ∀x̄ (R(x̄ ) −→ ∃ȳ Q(x̄ ′, ȳ)). The proof in this case is a bit more involved since tuple deletions and insertions are in principle possible, but the latter were blocked with the trust relationships. A proof can be found in (Bravo 2007).19 The proposition also holds in the case where D̄ = ⋃ Q∈N (P) JQ, but every JQ with Q ∈ N ◦(P) is fixed, i.e. only J and JP vary."
    }, {
      "heading" : "5.4 Complexity of the core and peer-consistent answers",
      "text" : "Definition 5.6 Consider a PDES schema P = 〈P,S,Σ, T rust〉 and a peer P in it. Given a neighborhood instance D̄ = ⋃ Q∈N (P) JQ for S(N (P)), the local core of P is the intersection of the neighborhood solutions for P and D̄ , but restricted to P’s schema S(P): localCore(P, D̄) := ( ⋂ NS(P, D̄)) S(P). 2\nIn this definition, JQ denotes an arbitrary instance for peer Q, which may be different from what we have called the initial instance D(Q) for Q (cf. Definition 3.2). Actually, JQ could be D(Q), but also a neighborhood solution for Q restricted to its schema, or the intersection of the latter, etc. In this regard, we recall that a neighborhood solution for P is defined in terms of its neighborhood schema, its local instance D(P) in D, and instances JQ for other peers Q in its neighborhood (cf. Definition 3.1). Each JQ for a neighboring peer Q is typically the restriction to S(Q) of the intersection of Q’s local neighborhood solutions, which may not necessarily be the same as the initial instance D(Q) ∈ D. We can see that the problems of defining and computing neighborhood solutions for a peer can be formulated with arbitrary instances for the neighbors, and do not require taking into consideration the recursive relations between peers. However,\n19 It is also possible to modify the proof just given by introducing auxiliary, dummy joins in the consequent of the RDEC in Σ(P1, P1), to make attributes relevant and avoid so the insertion of tuples with null, which has the effect of enforcing deletions."
    }, {
      "heading" : "36 L. Bertossi, L. Bravo",
      "text" : "the computation of the solutions of a peer is a global problem that does include recursion. In this case, we fix all the instances to be the initial ones for each peer.\nNotice from Definition 3.2, that when D̄ = D(P) ∪⋃Q∈N◦(P) Core(Q,D) in Definition 5.6, it holds localCore(P, D̄) = Core(P,D). In particular, Proposition 5.1 remains true if JQ = Core(Q,D), for Q ∈ N ◦(P), and JP = D(P).\nDefinition 5.7 Consider a PDES schema P = 〈P,S,Σ, T rust〉 and a peer P ∈ P, the InLocalCore decision problem is about membership of the set:\nInLocalCore(P, P) = {(R(t̄), D̄) |R(t̄) ∈ localCore(P, D̄) and D̄ is an instance for S(N (P))}. 2\nProposition 5.2 For a PDES schema P = 〈P,S,Σ, T rust〉 and a peer P ∈ P, InLocalCore(P, P) is ΠP2 -complete in the size of D̄ , the input neighborhood instance. 2\nDespite the assumption that the peer graphs G(P) are acyclic (cf. Remark 2.1), sets Σ of DECs may contain cycles through inclusion dependencies, in particular with existential quantifiers, i.e. RDECs.\nMore precisely, assume Σ is (or contains) a set of sentences ϕ of the form ∀x̄ (ψ(x̄ ) → ∃ȳχ(x̄ , ȳ)), of the form (12). When ȳ is not empty, ϕ is called existential. A directed graph can be associated to Σ. The nodes are the database predicates, and there is an edge from predicate P to predicate Q when P appears in the antecedent, and Q in the consequent of a ϕ ∈ Σ. The edge is marked if ϕ is existential. Σ is ref-acyclic if there no cycles with marked edges in the graph.20\nFor example, IC1 = {∀x (S (x ) → Q(x )), ∀x (Q(x ) → ∃y T (x , y))} and IC2 = {∀x (S (x ) → Q(x )), ∀x (Q(x ) → S (x ))} are ref-acyclic sets, whereas IC3 = IC1 ∪ {∀xy (T (x , y) → Q(y))} is not. This notion can be applied without changes to the sets Σ(P) in PDESs.\nExample 5.6 Given a PDES P = 〈P,S,Σ, T rust〉 with P = {P1, P2}, S = {S(P1),S(P1)}, S(P1) = {R1(·, ·)}, S(P2) = {R2(·, ·)}, Σ(P1, P2) = {∀x∀z (R1(x , z )→ ∃yR2(x , y)), ∀x∀z (R2(x , z )→ ∃yR1(x , y)}, Σ(P2, P1) = ∅; and Trust = {(P1, less, P2)}. In this case, the peer graph G(P) is acyclic. However, schema P is not ref-acyclic, because Σ(P1) = Σ(P1, P2) has a cycle through RDECs. 2\nIn some cases we will make the assumption that the sets of DECs at hand are ref-acyclic. For this reason, we make notice that the proof of Proposition 5.2 uses a ref-acyclic set of DECs. So, the proposition still holds for this class of DECs, which will become relevant in Section 6. (Cf. electronic Appendix A.1 for an additional discussion.)\n20 The condition of ref-acyclicity was already used in (Bravo and Bertossi 2006), as RIC-acyclicity, for sets of ICs on a single database schema.\nConsistency and Trust in Peer Data Exchange Systems 37\nCorollary 5.1 For a PDES schema P = 〈P,S,Σ, T rust〉 and a peer P ∈ P, with ref-acyclic sets of DECs, the InLocalCore(P, P) decision problem is ΠP2 -complete in the size of D̄ , the input neighborhood instance. 2\nWe can also apply the null-based solution semantics to Definition 3.3, obtaining a specific definition of peer consistent answer. More precisely, given a PDES schema P, an instance D for it, a peer P and a query Q(x̄ ) ∈ L(P), the set of peer consistent answers to Q from P is\nPCADP,P(Q) = {t | D |=N Q[t ], for all D ∈ Sol(P,D) }, (31)\nwith Sol(P,D) as defined in this section, on the basis of the ≤Σ(P)D relations. Proposition 5.2 and its Corollary 5.1 still hold when, for each Q ∈ N ◦(P), JQ = Core(Q,D), and JP = D(P). Therefore, the local computation of peer consistent answers to a conjunctive query -for which the cores of the neighboring peers are used- is also ΠP2 -complete.\nCorollary 5.2 For a PDES schema P = 〈P,S,Σ, T rust〉, an instance D for P, and a peer P ∈ P, deciding answers to a conjunctive query posed to P that are true in ⋂ NS(P, D̄), where D̄ = D(P) ∪⋃Q∈N◦(P) Core(Q,D), is ΠP2 -complete in the size of D̄ . This is also true for P with ref-acyclic sets of DECs. 2\nThe complexity of the decision and computational problems at the neighborhood level we have obtained so far are the most interesting, due to the modular and local manner solutions and peer-consistent answers are computed. These results will be useful in Section 6, where specification and computation of neighborhood solutions and PCAs are addressed.\nWe make only some final remarks in relation to global solutions and PCAs on their basis. Corollary 5.2 already tells us that deciding peer-consistent answers (which involves global solutions as opposed to neighborhood solutions) will be at least ΠP2 - hard. Actually, using Proposition 5.2 it is possible to provide a non-deterministic polynomial time algorithm (in data) with a ΠP2 -oracle to decide if an instance for a peer is a (global) solution for the peer. On this basis, one can obtain that PCA, as a decision problem, belongs to ΠP3 , in data (that includes those of all peers in the system)."
    }, {
      "heading" : "5.5 The import case",
      "text" : "In this section we consider a common situation, namely the import case, where we find Trust relationships are only of the form (P, less, Q) when P 6= Q; and the DECs are used for importing data from other peers.\nDefinition 5.8 Consider a PDES schema P = 〈P,S,Σ, T rust〉, and two different peers P and Q:"
    }, {
      "heading" : "38 L. Bertossi, L. Bravo",
      "text" : "(a) An import UDEC (IUDEC) to P from Q is a UDEC in L(P, Q) of the form:\n∀x̄ ( n∧\ni=1\nRi(x̄i) −→ (Q(x̄ ′) ∨ ϕ(x̄ ′′)), (32)\nwhere the Ri are predicates in S(Q), Q is a predicate in S(P), x̄ ′, x̄ ′′ ⊆ ∪x̄i = x̄ , and ϕ(x̄ ′′) is a disjunction of built-ins (representing a conjunction of built-ins on the variables in the antecedent).\n(b) An import RDEC (IRDEC) to P from Q is an RDEC in L(P, Q) of the form:\n∀x̄ ( n∧\ni=1\nRi(x̄i) −→ ∃z̄ (Q(ȳ , z̄ ) ∧ ϕ1(x̄ ′, z̄ ′)) ∨ ϕ2(x̄ ′′)), (33)\nwhere the Ri are predicates in S(Q), Q is a predicate in S(P), x̄ ′, x̄ ′′, ȳ ⊆ ∪i x̄i = x̄ , z̄ ′ ⊆ z̄ , and ϕ1 (ϕ2) is a conjunction (disjunction) of built-ins. Notice that ϕ1 basically imposes conditions with built-ins on the values for z̄ that, under the nullbased semantics, will be all null. (ϕ2(x̄ ′′) plays the same role on ϕ in (32).)\n(c) A PDES is of the import kind if, for every peer P, the DECs in Σ(P, Q) with\nany peer Q different from P, are import DECs to P from Q. Furthermore, if this set of DECs is non-empty, (P, less, Q) ∈ Trust. 2 Notice that this definition does not make any assumptions on the possible sets of local constraints, Σ(P, P).\nExample 5.7 Consider a PDES with P = {P1, P2, P3, P4}, S(P1) = {R1(·, ·)},S(P2) = {R2(·, ·), S 2(·, ·)}, S(P3) = {R3(·, ·)},S(P4) = {R4(·, ·, ·)}, and the following sets of DECs:\nΣ(P1, P2) = {∀x∀y(R2(x , y)→ (R1(x , y) ∨ x ≤ y))}, Σ(P4, P2) = {∀x∀y∀z (R2(x , y) ∧ S 2(y , z ) → R4(x , y , z ))}, Σ(P4, P3) = {∀x∀y(R3(x , y)→ ∃zR4(x , y , z ))} · Σ(P3, P2) = {∀x∀y(R3(x , y)→ R2(x , y))}·\nThe first three sets of DECs are formed by import DECs, but not the last one. 2"
    }, {
      "heading" : "5.5.1 The unrestricted case",
      "text" : "The unrestricted import case of PDES P as in Definition 5.8 occurs when, for every peer P ∈ P, Σ(P, P) = ∅. That is, in this case, a peer may have DECs of the forms (32) and (33) to neighboring peers, in whom it has more trust than in itself, but no local ICs.\nAs a consequence of an unrestricted local repair process, a peer will get data from its neighbors and will integrate them, at least virtually, into its own neighborhood instance. The data from a neighboring peer will be obtained by just posing it a conjunctive query, the one corresponding to the antecedent of the DEC.\nFor illustration, in Example 5.7, if P4 uses its import DEC from P2 (that in Σ(P4, P2)) to retrieve data from P2, then P4 sends to P2 the query: Q(x , y) : R2(x , y) ∧ S 2(y , z ).\nConsistency and Trust in Peer Data Exchange Systems 39\nIn the import case we can define a Datalog program for which its minimal model\nis the neighborhood solution of the peer.\nDefinition 5.9 Given an unrestricted import PDES schema P = 〈P,S,Σ, T rust〉, a peer P ∈ P and an instance D̄ for the neighborhood schema S(N (P)) around P, the import program I(P, D̄) is a Datalog program containing:\n1. The facts: R(ā), for every atom R(ā) ∈ D̄ . 2. For every IUDEC in Σ(P) of the form (32), the rule:\nQ(ȳ)← R1(x̄1), . . .Rn(x̄n),¬ϕ(x̄ ′′)· 3. For every import RDEC in Σ(P) of the form (33), the rule:\nQ(ȳ , null)← R1(x̄1), . . .Rn(x̄n), ¬ϕ2(x̄ ′′)· Here, ¬ϕ(x̄ ′′) and ¬ϕ2(x̄ ′′) become conjunctions of built-in literals, i.e. atomic formulas with a built-in or negations thereof; and null is a sequence of nulls for variables z̄ . According to the discussion of (33), conditions associated to ϕ1 become conditions on x̄ ′, which can all be made part of x̄ ′′. 2\nProposition 5.3 Given an unrestricted import PDES schema P = 〈P,S,Σ, T rust〉 and an instance D over it, every peer P ∈ P has a unique solution instance. Furthermore, there is an algorithm, that uses the import program I(P,D ′), and computes the solution for a peer P in polynomial time in the size of D S(AC(P)). 2\nThis uniqueness result relies on the fact that we are repairing IRDECs through the insertion of null values, as sanctioned by the official repair semantics. Otherwise, uniqueness would hold in general only for IUDECs."
    }, {
      "heading" : "5.5.2 The restricted case",
      "text" : "This case appears when, under all the import assumptions above, peers are allowed to have local constraints, that is, it may be that Σ(P, P) 6= ∅. In this case, a peer will import data without restrictions from its neighbors, but when building neighborhood solutions, also the local ICs will be taken into account. In this case, P may have none or several solutions.\nExample 5.8 Consider the PDES schema P = 〈P,S,Σ, T rust〉 corresponding to Figure 7. Here, P = {P1, P2, P3}, S = {S(P1), S(P2),S(P3)}, S(P1) = {R1(·, ·)}, S(P2) = {R2(·, ·)}, S(P3) = {R3(·, ·)}.\nThe local instances are: D(P1) = {}, D(P2) = {R2(a, b)}, D(P3) = {R3(a, c)}. The DECs are:\n1. Σ(P1, P2)= {∀x∀y(R2(x , y)→ R1(x , y))}, 2. Σ(P1, P3) = {∀x∀y(R3(x , y)→ R1(x , y))}, and 3. Σ(P1, P1) = {∀x∀y∀z (R1(x , y) ∧ R1(x , z )→ y = z )}.\nΣ(P1, P2) and Σ(P1, P3) contain import DECs. However, due to the local constraints in Σ(P1, P1), there are no solutions for P1. 2"
    }, {
      "heading" : "40 L. Bertossi, L. Bravo",
      "text" : "Example 5.9 Consider D(P) = {P(a, b),P(a, c)},D(Q) = {Q(a, d)}, and Trust = {(P, less, Q)}. Σ(P, Q) = {∀x∀y(Q(x , y)→ P(x , y)}, and Σ(P, P) = {∀x∀y∀z∀v(P(x , y)∧P(x , z )∧ P(x , v) → y = z ∨ z = v ∨ v = y)}. The local constraints in Σ(P, P) ensures that there are at most two tuples in P with the same first attribute. In this case, Σ(P, Q) is of the import kind and therefore P(a, d) will belong to all solutions. The local constraint in Σ(P, P) will force the removal of either P(a, b) or P(a, c), and therefore P has two solutions: {P(a, d),P(a, b)} and {P(a, d),P(a, c)}. 2"
    }, {
      "heading" : "6 Answer Set Programs and the Solutions for a Peer",
      "text" : "Continuing with the special PDES semantics based on the use of null introduced in Section 4, in this section we show how to specify neighborhood solutions for a peer (which is the central notion in this paper, upon which the recursive notion of global solution is defined) by means of disjunctive logic programs with stable model semantics (Gelfond and Lifschitz 1991; Eiter et al. 1997). As above, we assume that DECs and ICs have the forms (1) or (2).\nOur aim in this section is to show the gist of the approach, by considering in precise terms a particular but still interesting case, one where the RDECs have a limited syntactic form, without joins in the consequents. The general case, i.e. with arbitrary UDECs and RDECs as considered in this work so far, is possible and not difficult from the conceptual or technical point of view, but more difficult or lengthy to present.\nRemark 6.1 In this section we make the additional assumption that given a schema P = 〈P,S,Σ, T rust〉, for each P ∈ P, its set of DECs Σ(P) is ref-acyclic. In this case, we say that P is ref-acyclic. The formulation of the programs is independent from this assumption, but -as we will see later in this section- it ensures desirable properties of the program. 2\nNow we show how to specify the neighborhood solutions for a peer P as the stable models of a disjunctive logic program Π(P). The program can be used for this purpose under the assumption that P has already gathered, for each of its neighbors Q, the intersection of its solutions, i.e. Core(Q,D) (cf. Definition 5.6). However, the program works with arbitrary instances for the neighbors. Accordingly, the facts of the program come from the union D of the given instances for the peers in N (P), the neighborhood centered around peer P. As a consequence, Π(P) can be used to\nConsistency and Trust in Peer Data Exchange Systems 41\ncompute the restrictions to P’schema of P’s neighborhood solutions, on the basis of a neighborhood instance D. In Π(P), we find each predicate R ∈ S(N (P)) and also its copy R that has an extra argument (an augmented nickname). This argument is the last one and is used to place an annotation constant. Thus, if R has arity n, then R has arity n + 1. The possible annotation constants are: t, f , t?, f?, t??. Their occurrences in database tuples have the following intended semantics:\nAnnotation The tuple R(ā) ... R (ā, t) is made true in (inserted into) the database R (ā, f) is made false in (deleted from) the database R (ā, t?) was true or is made true R (ā, f?) was false or is made false R (ā, t??) was true or made true, and is not deleted\nThis intended semantics is formally captured in the program by means of appropriate rules. The (possibly virtual) insertions and deletions are made in order to satisfy P’s DECs. Actually, for each DEC ψ, a rule captures through its disjunctive head the alternative virtual updates that can be performed to satisfy ψ (cf. rules 2. and 3. in Definition 6.1 for UDECs, and 4. and 5. for RDECs). That is why we use annotations t or f in rule heads.\nThe annotations t?, f? are used to execute sequences of virtual updates, which may be necessary when there are interacting DECs. Finally, atoms annotated with t?? are those that become true in a solution. They are the relevant atoms, and are used to read off the database atoms in the solutions (rules 8. below).\nBefore presenting the logic program, let us recall that RelV (ψ) denotes the set of relevant variables of a constraint ψ, those where the occurrence of null is relevant for its satisfaction (see Definition 4.5). Those attributes/variables receive a special treatment in the program."
    }, {
      "heading" : "In the following, for a DEC ψ, A(ψ) and C (ψ) denote the set of database atoms",
      "text" : "(without built-ins) in the antecedent of, resp. the consequent, of ψ.\nA consequence of repairing using null, is that any RDEC with joins between existential quantifiers can only be repaired by deleting tuples and not by inserting tuples with null. Thus, the most relevant RDECs in this setting are of the form:\n∀x̄ (R(x̄ ) −→ ∃ȳ Q(x̄ ′, ȳ)), (34)\nFor this reason, and to simplify the presentation, the logic program that follows considers RDECs of this form only.\nDefinition 6.1 Consider a PDES schema P = 〈P,S,Σ, T rust〉 and a peer P ∈ P with local instance D(P) (for the schema S(P)). Let D̄ be an instance for the schema S(N (P)), i.e. for P’s neighborhood N (P), with D̄ S(P) = D(P). The solution program Π(P; D̄) for P contains:"
    }, {
      "heading" : "42 L. Bertossi, L. Bravo",
      "text" : "1. The following facts: dom(a), for every a ∈ Adom(D̄); dom(null), and R(ā), for every atom R(ā) ∈ D̄ .21 2. For every UDEC ψ ∈ Σ(P, Q) of the form (1), with Q ∈ N (P) and (P, less, Q) ∈ Trust, the rule: ∨{R (x̄i , f) | R(x̄i) ∈ A(ψ),R ∈ S(P)} ∨\n∨{Q (ȳj , t) | Q(ȳj ) ∈ C (ψ),Q ∈ S(P)} ← ∧ni=1 Ri (x̄i , t?), ∧m j=1Qj (ȳj , f ?), ∧\nxl∈RelV (ψ) xl 6= null· Here, when Qj ∈ B (i.e. a built-in), Qj (ȳj , f?) simply denotes the negated atom Qj (ȳj ), e.g. = becomes 6=, IsNull becomes, IsNotNull, etc., without annotations. Notice that the condition Q ∈ S(P) in the head of the rule discards built-in atoms (cf. Example 6.1 below). 3. For every UDEC ψ ∈ Σ(P, Q) of the form (1), with Q ∈ N (P) and (P, same, Q) ∈ Trust, the rule: ∨{R (x̄i , f) | R(x̄i) ∈ A(ψ)} ∨ ∨{Q (ȳj , t) | Q(ȳj ) ∈ C (ψ)} ← ∧n\ni=1 Ri (x̄i , t ?),∧m\nj=1Qj (ȳj , f ?), ∧\nxl∈RelV (ψ) xl 6= null. We apply the same convention as in 2. about the rule body. This case also covers UDECs in Σ(P, P), i.e. local universal ICs for P. 4. For every RDEC ψ ∈ Σ(P, Q) of the form (34), with Q ∈ N (P) and (P, same, Q) ∈ Trust, the rule:\nR (x̄ , f) ∨Q (x̄ ′, null, t)← R (x̄ , t?), not auxψ(x̄ ′), x̄ ′ 6= null· Here, auxψ is an auxiliary predicate used to obtain a safe rule (i.e. its variables in negated atoms also appear in a positive atom), whose body captures the violations of (34). In FO logic this would be done through: R(x̄ )∧¬∃ȳQ(x̄ ′, ȳ), which basically leads to the following rules that define the auxiliary predicate (taking into account the special semantics of null):\nFor every yi ∈ ȳ : auxψ(x̄\n′)← Q (x̄ ′, ȳ , t?), notQ (x̄ ′, ȳ , f), x̄ ′ 6= null, yi 6= null · (35) auxψ(x̄\n′)← Q(x̄ ′, null), notQ (x̄ ′, null, f), x̄ ′ 6= null · (36) This case covers the RDECs in Σ(P, P), i.e. local referential ICs for P. (Cf. Example 6.1 below.) Here, and in the rest of this work, atoms of the form Q (x̄ ′, null, . . .) associated to an atom in a DEC, have all the existential variables appearing in the latter and predicate Q replaced by null. Furthermore, for x̄ = x1, . . . , xn , x̄ 6= null abbreviates x1 6= null, . . . , xn 6= null. 5. For every RDEC ψ ∈ Σ(P, Q) of the form (34), with Q ∈ N (P) and (P, less, Q) ∈ Trust, the rules: (a) If R ∈ S(P): R (x̄ , f)← R (x̄ , t?), not auxψ(x̄ ′), x̄ ′ 6= null· (b) If Q ∈ S(P): Q (x̄ ′, null, t)← R (x̄ , t?), not auxψ(x̄ ′), x̄ ′ 6= null· Plus rules (36), (35). 6. For each predicate R ∈ S(N (P)), the annotation rules:\n21 We can also add IsNull(null), and IsNotNull(c), for every non-null constant in the active domain, but this is not necessary if these two predicates do not appear in the program.\nConsistency and Trust in Peer Data Exchange Systems 43\nR (x̄ , f?)← dom(x̄ ), notR(x̄ )· R (x̄ , f?)← R (x̄ , f)· R (x̄ , t?)← R(x̄ )· R (x̄ , t?)← R (x̄ , t)·\n7. For each predicate R ∈ S(N (P)), the program constraint: ← R (x̄ , t), R (x̄ , f)· 8. For each predicate R ∈ S(P), the interpretation rule: R (x̄ , t??) ← R (x̄ , t?), notR (x̄ , f)· 2\nExample 6.1 If the UDEC ψ is ∀x∀y(R(x ) → S (x , y)∨ IsNull(y)), then the corresponding rule according to (2) above is: R(x , f)← R(x , t?),S (x , y , f?), IsNotNull(y), x 6= null.\nNotice that RelV (ψ) = {x}. Since the program interprets null as any other constant in the domain, this rule can be replaced by R(x , f)← R(x , t?),S (x , y , f?), y 6= null, x 6= null.\nIf the RDEC ψ is ∀x (R(x )→ ∃yS (x , y)), then the corresponding rules according to 4. above are:\nR (x , f) ∨ S (x , null, t) ← R(x , t?), not aux(x ), x 6= null · aux(x ) ← S (x , null), notS (x , null, f), x 6= null · aux(x ) ← S (x , y , t?), notS (x , y , f), x 6= null, y 6= null·\nIn this case, the RDEC is “repaired”, as usual with referential ICs in databases, by either deleting the tuple from table R or inserting a tuple with a null value in table S , both cases equally acceptable. The two cases for item 5. in the program correspond each to only one of these possible choices. 2\nSince instance D̄ and its active domain are finite, the program has a finite number of facts in item (1) The most relevant part of the program corresponds to the rules (2)-(5). They capture through their bodies the violations of DECs; and through their heads, the (possibly alternative) virtual updates that are necessary on the peers’ instances to restore the satisfaction of DECs and local ICs. In the bodies of these rules associated to DECs or ICs ψ, the conditions of the form x 6= null, with x a variable appearing in a relevant attribute of ψ, are used to capture the special semantics of null values introduced in Section 4.\nThe fixed semantics of annotations is captured by the rules (6)-(8). They appear in every solution program. The program constraints in (7) discard models where an atom is both inserted and deleted.\nThe instances D̄ S(Q)) used in the program for P’s neighbors may not coincide with the initial, physical instances D(Q) in an instance D for the PDES P (except when Q is P). However, the idea is that P, given a global instance D, uses its program with D(P) and D̄ S(Q)) = Core(Q,D) for each Q ∈ N ◦(P). In this way, the program computes through its stable models the neighborhood solutions for P, whose restrictions to P’s schema will be the solutions for P. Notice that atoms annotated with t?? in a stable model of P’s program have predicates in S(P) only; and they define a database instance for P.\nThe adoption of the stable model semantics for the solution programs (Gelfond and Lifschitz 1991), plus the appropriate use of conditions with null in rules’ bodies,"
    }, {
      "heading" : "44 L. Bertossi, L. Bravo",
      "text" : "guarantee the minimal discrepancy between the generated and the original instances according to Definitions 3.1 and 5.3.\nExample 6.2 Consider P = {P1, P2}, with D(P1) = {R1(a, 2)}, D(P2) = {R2(d , 5)}, and neighborhood instance D̄ = D(P1)∪D(P2). Assume (P1, less, P2) ∈ Trust, and the only set of DECs in the system is Σ(P1, P2) = {∀xy(R2(x , y)→ R1(x , y))}.\nThe solution program Π(P1; D̄) contains: (we itemize in correspondence to Defi-\nnition 6.1)\n1. The facts dom(a), dom(d), dom(2), dom(5), dom(null),R1(a, 2),R2(d , 5)· 2. R1 (x , y , t)← R2 (x , y , t?), R1 (x , y , f?), x 6= null, y 6= null· 6. R1 (x , y , f?)← R1 (x , y , f)· R1 (x , y , f?)← dom(x ), dom(y), notR1(x , y)·\nR1 (x , y , t?)← R1 (x , y , t)· R1 (x , y , t?)← R1(x , y)· 7. ← R1 (x , y , t),R1 (x , y , f)· 8. R1 (x , y , t??)← R1 (x , y , t?), notR1 (x , y , f)·\nThe rule in 2. makes sure that a null-free R2-tuple that is not in R1, is also virtually inserted into R1 (if it had null, the DEC would be satisfied since all attributes are relevant). Since P1 trusts P2 more than itself, virtual changes affect only peer P1. According to Definition 6.1, we should also include rules similar to those in 6. and 7. for R2. However, they are not necessary because R2 does not change. If we decide to omit them, we have to replace the atom R2 (x , y , t?) in the body of rule in 2. by R2(x , y).\nNotice that since P2, which is a sink peer, does not have local ICs, its instance D(P2) is also its only solution, and the one passed over to P1, who uses it to build the facts of its program. 2\nExample 6.3 Consider P = {P1, P2}, with D(P1) = {R1(s, t), R1(a, null)}, D(P2) = {R2(c, d), R2(a, e)}, and Trust = {(P1, same, P2)}.\nAssume the only set of DECs are Σ(P1, P1) = {∀xyz (R1(x , y) ∧R1(x , z )→ y = z )}, and Σ(P1, P2) = {∀xy(R2(x , y) → ∃zR1(x , z ))}. The neighborhood instance is D̄ = D(P1) ∪D(P2) (the second disjunct is also P2’s only solution).\nThe solution program Π(P1; D̄) for P1 is as follows: (omitting rules 6. and 7.): 1. dom(a), . . . , dom(null),R1(a, null),R1(s, t),R2(c, d), R2(a, e)· 3. R1(x , y , f) ∨ R1(x , z , f)← R1(x , y , t?),R1(x , z , t?), x 6= null, y 6= null, z 6= null, y 6= z · 4. R2 (x , y , f) ∨ R1 (x , null, t)← R2 (x , y , t?), not aux(x ), x 6= null·\naux(x )← R1(x , null), notR1 (x , null, f)· aux(x )← R1(x , y , t?), notR1 (x , y , f), x 6= null, y 6= null·\n8. R1 (x , y , t??)← R1 (x , y , t?), notR1 (x , y , f)· Rule 3. takes care of P1’s the local functional dependency. In case of a violation, one of the two tuples in conflict has to be deleted. Rule 4. has the role of satisfying\nConsistency and Trust in Peer Data Exchange Systems 45\nthe RDEC. Since P1 trusts P2 the same as itself, consistency is restored by either deleting the tuple from R2 or introducing a null into R1.\nHere, only R1 -atoms become annotated with t??. These annotations are used to build solutions for P. In this example, we have two stable models, whose restrictions to t??-annotated atoms are: {R1 (a, null, t??),R1 (s, t , t??),R1 (c, null, t??)}, corresponding to the insertion of tuple R1(c, null); and {R1 (a, null, t??), R1 (s, t , t??)}, corresponding to the deletion of tuple R2(c, d). They correspond to the two solutions for P: {R1(a, null),R1(s, t),R1(c, null)} and {R1(a, null),R1(s, t)}. 2\nNotice that each peer P in a PDES has a solution program that, except for the facts in it, is fixed. It depends only on its DECS in Σ(P) and the trust relationships to its neighbors. The same program can be used with different initial neighborhood instances D̄ . On their basis, the program will compute stable models, whose doublestarred atoms will determine a local instance.\nDefinition 6.2 Consider a PDES P = 〈P,S,Σ, T rust〉, a peer P ∈ P, and a neighborhood instance D̄ for S(N (P)). Let M be a stable model of Π(P; D̄). The database instance for peer P (and schema S(P)) associated to M is DM = {R(ā) | R ∈ S(P) and R (ā, t??) ∈ M }. 2\nThe following result tells us that the instances for a peer obtained via the stable models of its program are all and only the solutions for the peer, under the assumption that its neighbors contribute with their own cores.\nProposition 6.1 Consider a PDES P = 〈P,S,Σ, T rust〉, with an instance D for P, and P ∈ P whose set of DECs Σ(P) is ref-acyclic. Given the neighborhood instance for S(N (P)): D̄ := D(P) ∪ ⋃Q∈N◦(P) Core(Q,D), it holds:\nSol(P,D) = {DM | M is a stable model of program Π(P, D̄)}. 2 This result generalizes one about the correctness of similar programs for nullbased repairs of the kind considered in this work, for single databases with respect to denial constraints and referential constraints and null values (Bravo and Bertossi 2006). The hypothesis of ref-acyclicity is necessary for the soundness of the program (every instance DM is a solution). Otherwise, only the completeness of the program can be guaranteed (every solution is a DM ) (Bravo and Bertossi 2006).\nUnder the assumption that we have already computed the (intersection of the) solution instances for P’s neighbors, the program for P allows us to compute its solution instances. This generates a recursive process that can be applied because G(P) is acyclic. Terminal peers P’ in G(P), i.e. without outgoing edges, become the base cases for the recursion. If their local instances D(P’) are (locally) consistent, they pass those instances to their neighbors. Otherwise, they first, using program Π(P’; D(P’)) compute local repairs for D(P’), and pass the intersection of them to their neighbors.\nSeveral optimizations can be applied to solution programs (Caniupan and Bertossi 2010). An important one has to do with the materialization of the closed-worldassumption, which results through the rule R1 (x , y , f?) ← dom(x ), dom(y),"
    }, {
      "heading" : "46 L. Bertossi, L. Bravo",
      "text" : "not R1(x , y) in 6. in Example 6.2. This is clearly undesirable and can be avoided. We do not provide optimized versions here, because they are more difficult to read.\nProposition 6.1 still holds if P, instead of collecting the intersection of the solutions of a neighbor Q, uses the intersection of the solutions for Q restricted to the subschema of Q that contains Q’s relations that appear in Σ(P, Q), which are those P needs to run its program.\nAs we expressed at the beginning of this section, our solution programs can be much more general. In particular, they can be modified to include rules for REDCs with existential quantifiers and joins in the consequents. For example, if the DEC is, say ∀xy(R(x , y)∧ S (y , z )→ ∃w(P(x ,w)∧Q(w , z ))), and the antecedent is true with null-free tuples,22 but not the consequent, one of the (satisfying) tuples in the antecedent has to be deleted. All we need to handle this DEC is a disjunctive, “deleting” rule. Built-in comparisons (with null) are used by the rule as well.\nRemark 6.2 For simplicity, the programs we introduced above do not consider inconsistent peers, i.e. a peer P whose instance is DP = {incP}. As the following example shows, it is easy to modify the rules to capture this situation. This change is compatible with the corresponding general DECs (cf. Remark 3.1). 2\nExample 6.4 (example 6.2 continued) The system is exactly as before, except that now DP2 =⋂ Sol(P2,D) = {incP2}, reflecting the fact that P2 has no solutions (due to its mappings and trust relationships to other peers, which we are not showing here). The general program that allows for inconsistent peers would now have, instead of 1. and 2.:\n1′ · dom(a), dom(2),R1(a, 2), incP2· 2’. R1 (x , y , t)← R2 (x , y , t?), R1 (x , y , f?), not incP2, x 6= null, y 6= null·\nIn this case, and as expected, the rule has no effect on P1. 2"
    }, {
      "heading" : "6.1 ASPs and PCAs",
      "text" : "With a solution program for P, PCAs to a query Q posed to P can be obtained by running a query program in combination with the solution program. First a query program Π(Q) has to be produced, which is rather standard, and next, Π(P)∪Π(Q) is run under the cautious stable model semantics, the one that declares as true what is simultaneously true in all the stable models. Of course, the same program Π(P) can be used with different queries.\nExample 6.5 (example 6.2 continued) In order to obtain P1’s PCAs to the query Q1(x , y) : R1(x , y), the rule Ans1(x , y) ← R1(x , y , t??) has to be added to Π(P; D(P1) ∪ D(P2)). The PCAs are the ground Ans1-atoms in the intersection of all stable\n22 If it is true via tuples with nulls, then due to the relevance of attributes, the DEC is immediately satisfied.\nConsistency and Trust in Peer Data Exchange Systems 47\nmodels of the combined program. For the query Q2(x ) : ∃yR1(x , y), the query rule is: Ans2(x )← R1(x , y , t??). 2\nIn general, given a conjunctive query Q (for which we want PCAs), first its rewriting QN is produced (as in Definition 4.6). Next, QN is rewritten in its turn as a query program with annotation t??. The query program is added to the peer’s solution program, and the combination is run under the skeptical semantics.\nDeciding the truth of ground atomic queries by means of the solution program for a peer under the skeptical semantics amounts to deciding membership of the local core, which, by Corollary 5.1, is ΠP2 -complete in data. This is exactly the data complexity of deciding skeptical entailment for atomic queries for disjunctive logic programs under the stable model semantics (Dantsin et al. 2001). So, the solution programs have the right expressive power for the problem at hand.\nUsing solution programs, our semantics could be naively implemented as follows. When P is posed a query, P has to run its program, for which it needs as facts those in the intersections of the solutions of its neighbors. So, P sends to each neighbor Q queries of the form Q : R(x̄ ), where R ∈ S(Q) and appears in Σ(P, Q). Peer P expects to receive from Q the PCAs to Q, because they corresponds to the extension of R in the intersection of solutions for Q.\nIn order to return to P the PCAs to its queries, each of its neighbors Q has to run its own program Π(Q). As before, they need PCAs from their own neighbors, etc. This recursion eventually reaches peers that have no DECs, and assuming its local ICs are satisfied, they return query answers to its neighbors directly from their original instances. This is the start of the backward propagation of PCAs process, which goes on until reaching P. Eventually, P gets all the facts to run its program and obtain the PCAs to the original query. If the local instance of a terminal peer is not consistent with respect to its local ICs, the local solution program can still be used to restore consistency with respect to the local ICs, as in consistent query answering. The data to be sent back to the neighbors comes from the intersection of the repairs, in the form of consistent query answers (Arenas et al. 1999).\nExample 6.6 (example 2.1 continued) Consider an instance D = {D(P1),D(P2),D(P3)} with D(P1) = {R1(a, 2)}, D(P2) = { R2(c, 4),R2(d , 5)}, and D(P3) = {R3(c, 4)}. A user poses the query Q0 : R1(x , y) to P1, expecting its PCAs.\nTo run its program, P1 needs the intersection of the solutions of peer P2. So, P1 sends to P2 the queries Q11 : R2(x , y) and Q12 : S 2(x , y) (actually, P1 does not need the latter, S 2 is not relevant to P1).\nIn order to peer-consistently answer these queries, P2 needs from P3 the PCAs to Q23 : R3(x , y). Since P3 has no neighbors, it returns to P2 the entire extension in its local database, i.e. D(P3) = {R3(c, 4)}. Now, P2 runs its program Π(P2; D(P2)∪D(3)). It contains, among others, the facts R2(c, 4),R2(d , 5),R3(c, 4); and (assuming Σ(P2, P2) = ∅) the main rule:\nR2 (x , y , f) ∨ R3 (x , y , f)← R2 (x , y , t?),R3 (x , y , t?), x 6= null, y 6= null· P2 has two solutions, {R2(d , 5)} and {R2(c, 4),R2(d , 5)}, whose intersection,\nCore(P2,D) = {R2(d , 5)}, is given to P1."
    }, {
      "heading" : "48 L. Bertossi, L. Bravo",
      "text" : "Finally, the program Π(P1; D(P1) ∪ Core(P2,D) (cf. Example 6.2) is run. It has only one solution, namely {R1(a, 2), R1(d , 5)}}; and the PCAs to Q0 are 〈a, 2〉 and 〈d , 5〉. 2"
    }, {
      "heading" : "6.2 The import case revisited",
      "text" : "We first consider the unrestricted case introduced in Section 5.5.1. Here, each peer P has a solution program Π−(P) as in Definition 6.1, with rules of the form:\n2. S (ȳj , t) ← ∧n i=1 Ri (x̄i , t ?), S (ȳj , f ?), ∧\nxl∈RelV (ψ) xl 6= null, ϕ̄· Here, S ∈ S(P) and the Ri ∈ S(Q), for Q ∈ N ◦(P). 5.(b) Q (x̄ ′, null, t)← R (x̄ , t?), not auxψ(x̄ ′), x̄ ′ 6= null· Here, Q ∈ S(P) and R ∈ S(Q), for Q ∈ N ◦(P). We also need the auxiliary rules (36), (35), and only for predicates in S(P) that\nappear in consequents of RDECs.\nNow, for a predicate Q ∈ S(P), a solution program like this never generates a tuple of the form Q(ā, t). In consequence, the negative literals can be eliminated from the bodies of both (36) and (35). The resulting program still contains negation, in rules 6. and 8. However, the solution program becomes a (non-disjunctive) stratified normal program (Abiteboul et al. 1995). In consequence, for every set of facts, it has only one stable model that can be computed in polynomial time in data. It corresponds to the only solution for peer P mentioned in Section 6.1.\nIf the query Q (or, better, its rewriting QN ) posed to P can also be represented as a stratified normal program Π(Q) (which is the case when Q is first-order, for example), then the combined program Π(P)∪Π(Q) is also normal and stratified. In consequence, computing PCAs can also be done in polynomial time. This is under the assumption that the peer has collected, for each of its neighbors, the intersection of its (local) solutions. We have obtained the following result.\nProposition 6.2 For an unrestricted import PDES schema P = 〈P,S,Σ, T rust〉, an instance D for P, and a peer P ∈ P, deciding answers to a conjunctive query posed to P that are true in ⋂ NS(P, D̄), where D̄ = D(P) ∪ ⋃Q∈N◦(P) Core(Q,D), can be done in polynomial time in the size of D̄ . 2\nIn the restricted import case of Section 5.5.2, we allowed peers to have local ICs. In this case, as illustrated in Examples 5.8 and 5.9 the situation may change: Due to the local ICs, the solution program may be disjunctive, and have none or several stable models, which is also reflected in the peers’ solutions.\nExample 6.7 (example 5.8 continued) In this case we have no solution. This is captured by the corresponding program through the program constraint ← R1 (x , y , t),R1 (x , y , f). In each of the two models of the program without the constraint, there will be the atoms R1(a, b, t),R1(a, c, t),R1(a, b, f) or the atoms R1(a, b, t),R1(a, c, t),R1(a, c, f). Both models will be discarded for violating the constraint. 2\nConsistency and Trust in Peer Data Exchange Systems 49\nExample 6.8\n(example 5.9 continued) The solution program for P has as main rules, the following:\nP (x , y , t) ← Q (x , y , t?),P (x , y , f?), x 6= null, y 6= null·\nP (x ,w1, f)∨P (x ,w2, f) ∨ P (x ,w3, f) ← P (x ,w1, t?),P (x ,w2, t?),P (x ,w3, t?),∧\ni 6=j wi 6= wj , x 6= null,w1 6= null,w2 6= null,w3 6= null·\nWe have a disjunctive solution program; actually one with two stable models, as expected according to Example 5.9. 2\nIn (Barcelo et al. 2003; Bravo and Bertossi 2006), in the context of consistent query answering, several classes of ICs have been identified for which the logic program becomes head-cycle free, in which case, it can be replaced by and equivalent nondisjunctive, i.e. normal, program (Dantsin et al. 2001). Cautious reasoning from normal logic programs is coNP-complete (Dantsin et al. 2001). In consequence, for those classes of ICs, peer consistent query answering is in coNP in data complexity.23 Among those constraints we find denial constraints, such as constraint (5) in Example 2.1. Even in the restricted import case with denial constraints as local constraints, peer consistent query answering is coNP-complete. (This can be obtained from CQA under denial constraints (Barcelo et al. 2003). Cf. (Bertossi 2011) for a survey of complexity results and references.)"
    }, {
      "heading" : "7 Related Work",
      "text" : "Our work can be placed among those on semantic peer data management systems, a research direction that was started, to the best of our knowledge, with (Halevy et al. 2003) (cf. also (Halevy et al. 2004)). Mappings relate two conjunctive queries that are expressed in terms of the schemas of two disjoint sets of peers. Already in those papers problematic cases of cyclic dependencies, which implicitly involve a cyclic accessibility graph, were identified. For example, we may have P = {P1, P2, P3}, with relations R1(·),R2(·),R3(·), resp., and DECs Σ(P1) = {∀x (R2(x )→ R1(x ))}, Σ(P2) = {∀x (R3(x ) → R2(x ))}, Σ(P3) = {∀x (R1(x ) → R3(x ))}, each of them satisfied only by importing data into the peer who owns the DEC, i.e. there is the implicit trust relation {(P1, less, P2), (P2, less, P3), (P3, less, P1)}. This is an unrestricted and cyclic import case. In the presence of cycles like this, peer consistent query answering becomes undecidable.\nIn (Halevy et al. 2003), mappings are represented and given a semantics using classical first-order logic (FOL). This choice requires consistency of peers (i.e. their data, local ICs and local mappings) with respect to the system as a whole. More precisely, certain answers from a peer are defined as those true in every global instance that is consistent with the local data and metadata, which is rigid. Some\n23 Again, under the assumption that the peer has collected, for each of its neighbors, the intersection of its (local) solutions.\nFig. 7. Integration systems as peers\nIn this case: ∀xy(R2(x, y, z) → ∃wR1(x, y, w)), ∀xy(R3(x, y, y) → ∃uvR3(u, x, v)). These DECS are used to pass data from the peer mentioned in the antecedent to the one mentioned in the consequent. This activity is based on a theory written in epistemic logic which is generated from the local and inter-peer mappings. More specifically, the following epistemic theory is used for query answering:\nK1(∀xyz(S1s (x, y, z)→ S1(x, y, z))) ∀xy(K2(R2(x, y, z))→ K1(∃wR1(x, y, w)))\n} Specification of P1\nK2(∀xyz(R2s(x, y) ∧R2s(y, z)→ R2(x, y, z))) ∀xy(K3(R3(x, y, y))→ K2(∃uvR3(u, x, v)))}\n} Specification of P2\nK3(∀xyz(R3s(x, y, z)→ R3(x, y, z))) } Specification of P3 Kiϕ is interpreted as ϕ is known by peer Pi. The idea behind using the epistemic theory is that data that is known (or certain) is passed from local sources to mediated schemas and from peers to other peers. A tuple t̄ is a peer consistent answer to a query Q posed to peer Pi if KiQ(t̄) is a logical consequence of the epistemic theory.\nAn advantage of this approach is that the semantics can be applied in the presence of cycles. However, possibly the whole epistemic theory has to be used by a peer Pi to do query answering, which requires not only data, but also the mappings and DECs; and this not only of its neighbors, but of all accessible peers.\nOur approach can be easily and uniformly adapted in order to make each peer a local data integration system. For this, the answer set programs that specify the legal instances of a virtual data integration introduced in [Bravo and Bertossi 2003; 2005; Bertossi and Bravo 2004a] can be used in combination with those presented here.\nThe treatment of local ICs differs from ours in two ways : (a) A peer that is inconsistent with respect to its local ICs is not considered for data exchange, while in our case such a peer may apply a repair semantics, as in CQA. (b) Atoms are imported into a peer by interaction with other peers only if this does not produce a local IC violation. In our case, under the same trust conditions, the data is accepted and the peer applies again a local repair semantics.\nIn order to answer a query [Calvanese et al. 2005], a peer traverses the network\nACM Transactions on Computational Logic, Vol. V, No. N, Month 20YY.\ncriticisms for the use of first-order logic as a basis for the semantics of PDESs were raised in (Calva ese et al. 2004), motivating a new research direction (cf. below).\nFor comparison, our approach is inconsistency tolerant, and does not provide a first-order semantics to the global system. Instead, we appeal to a non-monotonic semantics for only neighborhoods of peers. Our mappings are between two peers only, but in that case, more expressive than those considered in (Halevy et al. 2003).\nIt is worth noticing that all approaches adopting a FOL interpretation for PDESs, e.g. (Halevy et al. 2004; Halevy et al. 2003), do not consider peer mappings as constraints, but as logical implications from a peer to another. This in fact coincides with having trust relationships of he form (P, less, Q) for any mapping specified from P to Q.\nAmong the approaches to PDESs that are the closest to ours, we should mention (Calvanese et al. 2004; Calvanese et al. 2005; Calvanese et al. 2008; Franconi et al. 2004). The DECs are of the “import kind”, and there are no explicit trust relationships. For example, in (Calvan se et al. 2008), DECs are of the form CQi → CQj , where CQi , CQj are conjunctive queries over Pi and Pj’s schemas, resp. This kind of DECs keep the schemas separate, on different sides of the implication. The latter has to be int rpreted appropriately. Actually, the semantics of the system, in particular of the DECs, is given by an epistemic logic. Local ICs violations are avoided by ignoring a peer that is inconsistent with respect to its local ICs. New atoms are added into a peer by interaction with other eers only if this d es not produce a local IC violation. In consequence, a peer trust other peers more than itself, as long as no local inconsistencies a e produc d. There is not consi tency restoration process involved.\nAs shown in Figure 8, in (Calvanese et al. 2008) each peer is considered as a local virtual data integration system that follows the global-as-view approach (Lenzerini 2002). In this example, the three peers are locally defined by the GAV mappings ∀x∀y∀z (S 1s (x , y , z )→ S 1(x , y , z )), ∀x∀y∀z (R2s (x , y)∧S 2s (y , z )→ R2(x , y , z )), and ∀x∀y∀z (R3s (x , y , z ) → R3(x , y , z )), resp. The predicates of the form Ps correspond to local sources, and those of the form P i correspond to the mediated schema provided by peer Pi. In addition, the DECs establish mappings between the peers. In this case: ∀x∀y(R2(x , y , z ) → ∃wS 1(x , y ,w)), ∀x∀y(R3(x , y , y) → ∃u∃vR2(u, x , v)). These DECs are used to pass data from the peer mentioned in the antecedent to the one mentioned in the consequent. This activity is based on\nConsistency and Trust in Peer Data Exchange Systems 51\na theory written in epistemic logic which is generated from the local and interpeer mappings. More specifically, the following epistemic theory is used for query answering:\nK1(∀x∀y∀z (S 1s (x , y , z )→ S 1(x , y , z ))) ∀x∀y(K2(R2(x , y , z ))→ K1(∃wS 1(x , y ,w)))\n} Specification of P1\nK2(∀x∀y∀z (R2s (x , y) ∧ S 2s (y , z )→ R2(x , y , z ))) ∀x∀y(K3(R3(x , y , y))→ K2(∃u∃vR2(u, x , v)))}\n} Specification of P2\nK3(∀x∀y∀z (R3s (x , y , z )→ R3(x , y , z ))) } Specification of P3\nKiϕ is interpreted as ϕ is known by peer Pi. The idea behind using the epistemic theory is that data that is known (or certain) is passed from local sources to mediated schemas and from peers to other peers. A tuple t̄ is a peer consistent answer to a query Q posed to peer Pi if KiQ(t̄) is a logical consequence of the epistemic theory.\nAn advantage of this approach is that the semantics can be applied in the presence of cycles. However, possibly the whole epistemic theory has to be used by a peer Pi to do query answering, which requires not only data, but also the mappings and DECs; and this not only of its neighbors, but of all accessible peers. (This semantics is similar in spirit to the one called “send all” in Section A.4.)\nOur approach can be easily and uniformly adapted in order to make each peer a local data integration system. For this, the answer set programs that specify the legal instances of a virtual data integration introduced in (Bravo and Bertossi 2003; Bravo and Bertossi 2005; Bertossi and Bravo 2004a) can be used in combination with those presented here.\nThe epistemic theory has also been extended in (Calvanese et al. 2008) in order to make the PDES “inconsistency tolerant”. This is done by using additional modal operators and extending the epistemic theory, achieving that: (a) A peer whose local data is inconsistent with respect to its ICs, is not considered for data exchange, that is, the PDES behaves as if that peer didn’t exist. In our case, however, to such a peer, whenever possible, a repair semantics is applied. (b) Inconsistencies due to data imported from other peers, referred as P2P inconsistencies, are solved by removing a minimal amount of data imported from other peers in order to preserve consistency. In other words, atoms are imported into a peer by interaction with other peers only if this does not produce a violation of an integrity constraint of a peer. In our case, under the same or less trust conditions, the data is accepted and the peer applies again a local repair semantics.\nIn order to answer a query (Calvanese et al. 2005), a peer traverses the network eventually collecting at its site all DECs, ICs and data of other logically related peers. With these elements, the peer can construct its epistemic theory, that is used for query answering. An accessibility cycle can be detected by using request identifiers. The use of epistemic logic makes sure that certain data, the one a peer really knows, is passed to another peer. In our case, a peer collects only data from its neighbors; and certainty is achieved by using the PCAs of a peer, or more generally,"
    }, {
      "heading" : "52 L. Bertossi, L. Bravo",
      "text" : "the intersection of its solutions. A more detailed comparison can be found in (Bravo 2007).\nThe semantics in (Franconi et al. 2004; Franconi et al. 2004) coincides with the epistemic semantics in (Calvanese et al. 2004). The former also provide a distributed algorithm, where peers’ data is updated by instruction of a super peer. When a query is posed to a peer, it can answer the query right away with its data, because the PDES is already updated.\nThe data exchange problem among distributed independent sources has been investigated in (Caroprese et al. 2006; Caroprese and Zumpano 2008; Caroprese and Zumpano 2011). In (Caroprese et al. 2006) the authors define a declarative semantics for P2P systems that allows one to import, into each peer, maximal subsets of atoms that do not violate the local integrity constraints. The framework has been extended in (Caroprese and Zumpano 2008) with a mechanism to set different degrees of reliability for neighbor peers, and in (Caroprese and Zumpano 2011), where “dynamic” preferences can be used to import data in the case of conflicting sets of atoms, depending on the properties of the peers’ data. This extended framework allows one to model preferences like “in the case of conflicting information, it is preferable to import data from the neighbor peer that can provide the maximum number of tuples” or “in the case of conflicting information, it is preferable to import data from the neighbor peer such that the sum of the values of an attribute is minimum”, without having to select preferred peers a-priori. To enforce this preference mechanisms the P2P framework has been enriched with aggregate functions.\nIn (Fuxman et al. 2006), the case of two peers that belong to a PDES is analyzed. From a source peer, P, to a target peer, Q, there may be both source-to-target dependencies, as in data exchange (Kolaitis 2005), and also target-to-source dependencies. The former are used to transport data from P to Q, and the second, to filter the received data in Q. In addition, the target may have an instance and local constraints. The existence of solutions for the target peer is investigated. The semantics we have introduced, but using labeled nulls instead of null, could be adapted to a situation like this (cf. Section A.3). It is also possible to use the solution programs in the case of (Fuxman et al. 2006). In this scenario, the source-to-target dependencies would give rise to program rules that do the data exchange, and both target-to-source dependencies and target dependencies would become hard program constraints.\nMore material and references on peer data exchange systems can be found in (Aberer 2011). Consistency issues that appear in our PDES scenario may also appear in the context of ontologies, when they have to be aligned in the presence of bridges between them. When ontologies are merged, it becomes necessary to solve inconsistencies between them (Serafini et al. 2005). However, in relation to mappings, we go beyond the cases considered in that area. The mappings, or bridges, between ontologies are in general much simpler than the general case considered in our work.\nIn this work we have concentrated on null values that are handled as in SQL relational databases. Actually, in that case, there is a single null, namely the constant NULL. It can be interpreted in different ways in a database, e.g. as a representative\nConsistency and Trust in Peer Data Exchange Systems 53\nfor an existing but unknown value, as a missing or non-existent value, as a withheld or hidden value, etc. In our case, we do not make any ontological assumption about this constant. Our purpose consists in logically capturing the way it is handled in data management operations by an SQL database. More specifically, with respect to query answering, integrity checking and interaction with other data elements.\nMost of the work in database theory bypasses the issue of SQL null, mainly because it is considered to be an undesirable oddity that could be replaced by a logically cleaner solution. However, SQL NULL exists, is used, and will most like stay with us. It would be better to accept it, but trying to clarify its logical and operational status. This is our approach in this work. From this point of view, we accept that SQL NULL appears, not only in databases, but could also appear explicitly in data exchange constraints and integrity constraints, and in their semantics. For example, a referential constraint or data exchange constraint could be of the form ∀xy(S (x , y) → T (x , NULL)), i.e. requiring that T ’s second attribute should be filled with NULL.24\nA similar approach is adopted in (Franconi and Tessaris 2012), where an alternative reconstruction of SQL NULL is attempted. They propose a corresponding relational algebra that takes care of the special status of NULL, but in the end, after the reconstruction, this constant disappears from the data domain. We keep it, but rewrite queries and constraints in such a way that it can be treated as any other constant.\nThere is a large literature on nulls in relational databases (see, e.g. (Levene and Loizou 1999)). However, to the best of our knowledge those nulls are “ideal” nulls, and not the real SQL NULL. There are also some logical approaches, starting with Reiter’s treatment of nulls (Reiter 1984), which can be multiple, existential values not subject to the unique names assumption. They are also different from the SQL NULL. More recent work extending Reiter’s approach can be found in (Traylor and Gelfond 1994; Lifschitz et al. 2012). See also (Libkin 2014; Libkin 2016) for a recent work on incomplete information in relational databases."
    }, {
      "heading" : "8 Conclusions",
      "text" : "We have introduced a general framework for peer data exchange with trust relationships. The methodology is flexible and inconsistency tolerant in that each peer solves its data and semantic conflicts at query time, when querying its own and other peers’ data.\nThe general semantic framework can be specialized in several ways, and we presented some possibilities. In particular, we developed a specific semantics based on universal and referential data exchange constraints, and on the use on SQL null values to deal with incomplete information. In this scenario, logic programs can\n24 In our case, given our repair semantics of Section 5, even a constraint of the form ∀xy(S(x , y)→ ∃zT (x , z )) will be enforced by giving to z the value NULL (unless some other constraint prevents this)."
    }, {
      "heading" : "54 L. Bertossi, L. Bravo",
      "text" : "be used to specify the solution instances for a peer and to obtain peer consistent answers.\nTechniques for optimizing the logic programs and their execution could be applied for query answering. Among them we find the partial evaluation of programs and the solution instances they specify, since we are not interested in the solution per se, but in the PCAs. More specifically, techniques used in CQA, such as magic sets for stable model semantics (Faber et al. 2007), and identification of predicates that are relevant to queries and constraints, could also be used in this setting. In this way, the number of rules and the amount of data that are needed to run the program are reduced (Caniupan and Bertossi 2010; Eiter et al. 2008).\nThe problem of query evaluation from disjunctive programs is ΠP2 -complete in data (Dantsin et al. 2001), which matches the complexity of PCA, as we established here. In spite of this, we have also identified syntactic classes of PDESs for which peer consistent query answering has a lower complexity. For them, specifically tailored mechanisms to solve this problem could be developed, as for CQA.\nWe should emphasize that the DECs we can handle are more general that those\nfound in related work on peer data exchange.\nOur semantics allows for inconsistent peers and inconsistencies between peers, without unraveling logical reasoning or having to exclude peers whose data participate in inconsistencies. Actually, our semantics for peer data exchange systems smoothly extend the repair semantics for consistent query answering from inconsistent databases.\nAlong the way, and interesting on its own merits, we developed a semantics of conjunctive query answering and constraint satisfaction in terms of classical FO predicate logic. It puts on a solid ground the mechanisms implemented in SQL databases and specifications in the SQL Standard for handling null values.\nAcknowledgements: Research supported by NSERC DG (250279-2011) and a CITO/IBM-CAS Student Internship. Loreto Bravo is funded by CONICYT grant PSD-57. We appreciate valuable and detailed comments from the anonymous reviewers."
    }, {
      "heading" : "56 L. Bertossi, L. Bravo",
      "text" : "Caniupan, M. and Bertossi, L. 2010. The Consistency Extractor System: Answer Set Programs for Consistent Query Answering in Databases. Data & Knowledge Engineering 69, 6, 545–572.\nCaroprese, L., Greco, S., and Zumpano, E. 2006. A Logic Programming Approach to Querying and Integrating P2P Deductive Databases. In Proc. FLAIRS. 31–36.\nCaroprese, L. and Zumpano, E. 2008. Modeling Cooperation in P2P Data Management Systems. In Proc. ISMIS. 225–235.\nCaroprese, L. and Zumpano, E. 2011. Aggregates and Priorities in P2P Data Management Systems. In Proc. IDEAS. 1–7.\nChomicki, J. 2007. Consistent Query Answering: Five Easy Pieces. In Proc. International Conference on Database Theory. Springer, LNCS 4353, 1–17.\nDantsin, E., Eiter, T., Gottlob, G., and Voronkov, A. 2001. Complexity and Expressive Power of Logic Programming. ACM Computing Surveys 33, 3, 374–425.\nOn Reconciling Data Exchange, Data Integration, and Peer Data Management. In Proc. ACM Symposium on Principles of Database Systems. ACM Press, 133–142.\nDemolombe, R. 2011. Transitivity and Propagation of Trust in Information Sources: An Analysis in Modal Logic. In Proc. CLIMA XII, Springer LNAI 6814, 13–28.\nEiter, T., Fink, M., Greco, G., and Lembo, D. 2008. Repair Localization for Query Answering from Inconsistent Databases. ACM Transactions on Database Systems 33, 2.\nEiter, T., Gottlob, G., and Mannila, H. 1997. Disjunctive Datalog. ACM Transactions on Database Systems 22, 3, 364–418.\nFaber, W. and Woltran, S. 2011. Manifold Answer-Set Programs and Their Applications. In Gelfond Festschrift, M. Balduccini and T. C. Son, Eds. Springer LNAI 6565, 44–63.\nFranconi, E., Kuper, G., Lopatenko, A., and Serafini, L. 2004. A Robust Logical and Computational Characterisation of Peer-to-Peer Database Systems. In Proc. VLDB Workshop on Databases, Information Systems and P2P Computing. Springer, LNCS 2944, 64–76.\nFranconi, E., Kuper, G., Lopatenko, A., and Zaihrayeu, I. 2004. A Distributed Algorithm for Robust Data Sharing and Updates in P2P Database Networks. In Proc. EDBT Workshop on Peer-to-peer Computing and Databases. Springer, LNCS 3268, 446–455.\nFranconi, E. and Tessaris, S. 2012. On the Logic of SQL Nulls. In Proc. Alberto Mendelzon WS on Foundations of Data Management. Vol. 866. CEUR WS Proceedings.\nFuxman, A., Kolaitis, P., Miller, R., and Tan, W. 2006. Peer Data Exchange. ACM Transactions on Database Systems 31, 4, 1454–1498.\nGelfond, M. and Lifschitz, V. 1991. Classical Negation in Logic Programs and Disjunctive Databases. New Generation Computing 9, 365–385.\nGreco, G., Greco, S., and Zumpano, E. 2003. A Logical Framework for Querying and Repairing Inconsistent Databases. IEEE Transactions on Knowledge and Data Engineering 15, 6, 1389–1408.\nHalevy, A., Ives, Z., Madhavan, J., Mork, P., Suciu, D., and Tatarinov, I. 2004. The Piazza Peer Data Management System. IEEE Transactions on Knowledge and Data Engineering 16, 7, 787–798.\nHalevy, A., Ives, Z., Suciu, D., and Tatarinov, I. 2003. Schema Mediation in Peer Data Management Systems. In Proc. International Conference on Data Engineering. IEEE Computer Society, 505–518.\nImielinski, Th., and Lipski, W. 1984. Incomplete Information in Relational Databases. Journal of the ACM 31, 4: 761–791.\nConsistency and Trust in Peer Data Exchange Systems 57\nJøsang, A., Marsh, S., and Pope, S. 2006. Exploring Different Types of Trust Propagation. In Proc. iTrust. Springer, LNCS 3986, 179–192. Jøsang, A., Azderska, T. and Marsh, S. 2012. Trust Transitivity and Conditional Belief Reasoning. In Proc. IFIPTM 2012, IFIP AICT 374. Springer, 68–83. Kolaitis, P. 2005. Schema Mappings, Data Exchange, and Metadata Management. In Proc. ACM Symposium on Principles of Database Systems. ACM Press, 61–75. Lenzerini, M. 2002. Data Integration: A Theoretica Perspective. In Proc. ACM Symposium on Principles of Database Systems. ACM Press, 233–246. Leone, N., Pfeifer, G., Faber, W., Eiter, T., Gottlob, G., Perri, S., and Scarcello, F. 2006. The DLV System for Knowledge Representation and Reasoning. ACM Transactions on Computational Logic 7, 3, 499–562. Levene, M. and Loizou, G. 1997. Null Inclusion Dependencies in Relational Databases. Information and Computation 136, 2, 67–108. Levene, M. and Loizou, G. 1999. A Guided Tour of Relational Databases and Beyond. Springer. Libkin, L. 2014. Incomplete Data: What Went Wrong, and How to Fix It. In Proc. ACM Symposium on Principles of Database Systems. ACM Press, 1–13. Libkin, L. 2016. Certain Answers as Objects and Knowledge. Artificial Intelligence 232, 1, 1–19. Lifschitz, V., Pichotta, K., and Yang, F. 2012. Relational Theories with Null Values and Non-Herbrand Stable Models. In Proc. International Workshop on Non-Monotonic Reasoning. Marti, S. and Garcia-Molina, H. 2006. Taxonomy of Trust: Categorizing P2P Reputation Systems. Computer Networks 50, 4, 472–484. Papadimitriou, Ch. 1994. Computational Complexity. Addison-Wesley. Reiter, R. 1984. Towards a Logical Reconstruction of Relational Database Theory. In On Conceptual Modelling, M.Brodie, J.Mylopoulos, and J. Schmidt, Eds. Springer, 191–233. Sabater, J. and Sierra, C. 2005. Review on Computational Trust and Reputation Models. Artificial Intelligence Review 24, 1, 33–60. Serafini, L., Borgida, A., and Tamilin, A. 2005. Aspects of Distributed and Modular Ontology Reasoning. In Proc. International Joint Conference on Artificial Intelligence. Morgan Kaufmann, 570–575. Traylor, B. and Gelfond, M. 1994. Representing Null Values in Logic Programming. In Logical Foundations of Computer Science. Springer LNCS 813, 341–352."
    }, {
      "heading" : "58 L. Bertossi, L. Bravo",
      "text" : "ELECTRONIC APPENDIX"
    }, {
      "heading" : "Appendix A Discussion",
      "text" : "A.1 On cycles and their assumptions\nIn this section, unless stated otherwise, we refer to the special semantics introduced in Section 4.\nWe have assumed that G(P) is acyclic. However, the peers, not being aware of being in a cycle in G(P), could attempt to do data exchange as described above. In order to detect an infinite loop, for a query Q posed by a peer P, a unique identifier id(P,Q) can be created and kept in all the queries that have origin in Q. If an identifier comes back to a peer, it will realize that it is in a cycle and act accordingly.\nThe assumption of acyclicity of the accessibility graph is quite cautious, in the sense that it excludes cases where a reasonable semantics could still be given and the logic programs would work correctly. This is because the cycles in G(P) are not necessarily relevant.\nExample 1 Consider S(P1) = {R1(·),S 1(·)}, S(P2) = {R2(·), S 2(·)}, Σ(P1, P2) = {∀x (R2(x ) → R1(x ))}, Σ(P2, P1) = {∀x (S 1(x )→ S 2(x ))}, Trust = {(P1, less, P2), (P2, less, P1)}. If a query is posed to P1, it will request from P2 the PCAs to query R2(x ), but not those to query S 2(x ). Peer P2 can realize it does not need data from P1 and will simply return D(P2) {R2} to P1, who will run its solution program and answer the original query. Even though there is a cycle in G(P), there is no infinite loop in the query answering process. 2\nAs we mentioned before, if there are ref-cycles in Σ(P), the stable models of the solution program for P may correspond to a strict superset of the solutions. This is shown in the next example. In such a case, post-processing that deletes models corresponding to non-minimal “solutions” is necessary.\nExample 2 Consider D(P1) = {R1(a, b)}, D(P2) = {R2(a, c)}, Σ(P1, P2) = {∀x∀z (R1(x , z ) → ∃y R2(x , y)), ∀x∀z (R2(x , z )→∃y R1(x , y)}, which is ref-cyclic; Σ(P2) = Σ(P1, P1) = ∅; and (P1, same, P2) ∈ Trust. Here, P1 has only one solution, namely {R1(a, b)}.\nHowever, Π(P1) has two models. The most relevant part of the program consists\nof the facts R1(a, b), R2(a, c), and the following rules:\nConsistency and Trust in Peer Data Exchange Systems 59\nR1 (x , y , f) ∨ R2 (x , null, t) ← R1 (x , y , t?), not aux1(x ), x 6= null aux1(x ) ← R2(x , null), notR2 (x , null, f) aux1(x ) ← R2(x , y , t?), notR2 (x , y , f), x 6= null, y 6= null R2 (x , y , f) ∨ R1 (x , null, t) ← R2 (x , y , t?), not aux2(x ), x 6= null aux2(x ) ← R1(x , null), notR1 (x , null, f) aux2(x ) ← R1(x , y , t?), notR1 (x , y , f), x 6= null, y 6= null\nThe two models correspond to the neighborhood “solutions” {R1(a, b),R2(a, c)} and ∅, producing in their turn, the instances {R1(a, b)} and ∅, resp., for P1. Only the former is a solution instance. The second model is the result of cycles through weak negation (not). The cycle creates the self justification of facts as follows: (i) If we choose R2 (a, c, f) to be true, then by the second and third rules above, aux1(a) is false. (ii) Then, the first rule can be satisfied, by making R1 (a, b, f) true. (iii) By the fifth and sixth rules, aux2(a) is false. (iv) This justifies making R 2 (a, b, f) true, thus, closing the cycle. Notice, that in the whole justification the changes where not determined by inconsistencies. 2\nThere are also cases with an acyclic G(P), but with ref-cycles in the DECs, where the logic programming counterpart of the semantics is correct due to the role of the trust relationships.\nExample 3 (example 2 continued) If we replace (P1, same, P2) ∈ Trust by (P1, less, P2) ∈ Trust, the relevant part of Π(P1) now is: R1(a, b), R2(a, c), plus\nR1 (x , y , f) ← R1 (x , y , t?), not aux1(x ), x 6= null · aux1(x ) ← R2(x , null), notR2 (x , null, f) · aux1(x ) ← R2(x , y , t?), notR2 (x , y , f), x 6= null, y 6= null ·\nR1 (x , null, t) ← R2 (x , y , t?), not aux2(x ), x 6= null · aux2(x ) ← R1(x , null), notR1 (x , null, f) · aux2(x ) ← R1(x , y , t?), notR1 (x , y , f), x 6= null, y 6= null·\nSince P1 trusts more peer P2 than itself, it will modify only its own data. This program computes exactly the solutions for peer P1, i.e. {R1(a, b)}, even though the DECs exhibit ref-cycles. 2\nIt becomes clear that it is possible to find more relaxed conditions, both on the accessibility graph and ref-cycles, under which a sensible semantics for solutions and semantically corresponding logic programs can be given. Also, for cyclic accessibility graphs, super peers (Yang and Garcia-Molina 2003) could be used, to detect cycles and prune certain DECs, making the graph acyclic if necessary; and then our semantics could be applied."
    }, {
      "heading" : "60 L. Bertossi, L. Bravo",
      "text" : "A.2 Query sensitive query answering\nOur definition of the solution semantics and the peer consistent answers might suggest that, in order to answer a particular query Q, a peer P has to import the full intersection of the solutions of each of its neighbors, which in their turn have to do the same, etc. If we do this, most likely most of the data imported by P will be irrelevant for the query at hand, and is not needed.\nIt is possible to design query answering methodologies that are more sensitive to the query at hand, in the sense that only the relevant data is transitively imported into P before answering Q. A full treatment of this subject is beyond the scope of this paper. However, we can give some indications as to how to proceed.\nIn (Caniupan and Bertossi 2010), the dependency graph of database predicates with respect to a set of ICs was introduced and used to capture the notion of possibly transitive relevance of a predicate for another, which is useful in consistent query answering. Here we can use similar graphs for each peer in relationship with its neighbors through a set of DECs, also taking into account the local ICs. These graphs would give us a better upper bound on what to import from other peers (as opposed to bringing the full intersection of solutions).\nMore precisely, if a query Q to P contains S(P)-predicates P1, . . . ,Pn , with relevant S(Q)-predicates Q11 , . . . ,Q1m1 , . . . ,Qn1 , . . . ,Qnmn , resp., at a neighbor Q, then P will request from Q the PCAs to each of the constant-free, atomic queries Q ij (x̄ ). The corresponding sets of answers will form the (most likely smaller) instance provided by Q to P, who will prune its repair program by keeping only the relevant rules, i.e. those that are related to Q, the Pi and the Q ij . This idea can be illustrated by means of an example.\nExample 4 Consider a schema P = 〈P,S,Σ, T rust〉 with P = {P1, P2, P3}, S = {S(P1),S(P2), S(P3)}, S(P1) = {R1(·, ·), S 1(·, ·), T 1(·, ·)}, S(P2) = {R2(·, ·), S 2(·, ·),T 2(·, ·)}, S(P3) = {R3(·, ·),S 3(·, ·)}, Trust = {(P1, less, P2), (P2, same, P3)}. Let D be an arbitrary instance for the PDES.\nThe sets of DECs are: Σ(P1, P1) = {∀x∀y(R1(x , y) ∧ S 1(x , y) → false)}, Σ(P1, P2) = {∀x∀y(R2(x , y) → R1(x , y)), ∀x∀y(S 2(x , y) → S 1(x , y))}, and Σ(P2, P3) = {∀x∀y(R2(x , y) ∧ R3(x , y)→ false)}.\nIf P1 is posed the query Q1(x ) : ∃yR1(x , y), then the relevant predicates in S(P1) are R1,S 1 (due to the DEC in Σ(P1)). Then, through the DECs also, it follows that the predicates that are relevant to P1 are R2,S 2 at P2. So, P1 poses to P2 the queries R2(x , y),S 2(x , y). The only relevant predicate at P3 is S 3. So, P2 will pose to P3 the query S 3(x , y).\nIn this case, P3 will return D(P3) {R3} to P2, which, due to the UDEC in Σ(P2, P3), will subtract it from D(P2) {R2}, because (⋂Sol(P2,D)) {R2} = (D(P2) {R2} r D(P3) {R3}). Peer P2 will send this difference to P1 as it is the answer to query R2(x , y). Peer P2 will also return to P1 the entire D(P2) {S 2} as its answer to the query S 2(x , y).\nFinally, P1 will answer the original query with a solution program containing as\nConsistency and Trust in Peer Data Exchange Systems 61\nfacts the tuples in D(P1) {R1},D(P1) {S 1},D(P2) {S 2}, ((D(P2) {R2})r(D(P3) {R3})). The last set, as an extension for R2 in the program. 2 The methodology sketched in this example will be certainly more efficient than computing and shipping the full intersection of a peer’s solutions. It is natural to expect that additional optimizations can be developed.\nA particularly appealing, but provably less general, approach to peer-consistent query answering is first-order query rewriting, which we illustrate by means of an example.\nExample 5 Consider an instance D = {D(P1),D(P2),D(P3)} for the schema P = 〈P,S,Σ, T rust〉 with P = {P1, P2, P3}, S = {S(P1),S(P2), S(P3)}, S(Pi) = {Ri(·, ·)}, Trust = {(P1, less, P2), (P1, same, P3)}, D(P1) = {R1(a, b), R1(s, t)}, D(P2) = {R2(c, d), R2(a, e)}, D(P3) = {R3(a, f ), R3(s, u)} and the DECs:\nΣ(P1, P2) = {∀x∀y(R2(x , y)→ R1(x , y))}; Σ(P1, P3) = {∀x∀y∀z (R1(x , y) ∧ R3(x , z ) → y = z )}·\nWe are interested in P1’s solutions. Since P2, P3 are sink peers in the graph G(P), we have the extended instance D = {R1(a, b),R1(s, t),R2(c, d), R2(a, e), R3(a, f ), R3(s, u)}, from which we have to obtain the solutions for P1.\nThe solutions for P1 are obtained by first repairing D with respect to Σ(P1, P2), obtaining D1 = {R1(a, b),R1(s, t), R1(c, d),R1(a, e), R2(c, d),R2(a, e), R3(a, f ), R3(s, u)}. We have only one repair at this stage, which now has to be repaired in its turn with respect to Σ(P1, P3) (but keeping the relationship between P1 and P2 satisfied). There are two sets of tuples violating Σ(P1, P3) in D1: {R1(s, t),R3(s, u)} and {R1(a, b),R1(a, e), R3(a, f )}. The first violation can be repaired by deleting any, but only one, of the two tuples. The second one, by deleting tuple R3(a, f ) only (otherwise we would violate the relationship between P1 and P2).\nAs a consequence, we obtain two neighborhood solutions: D ′ = {R1(a, b),R1(s, t), R1(c, d), R1(a, e),R2(c, d),R2(a, e)}, and D ′′ = {R1(a, b),R1(c, d),R1(a, e), R2(c, d),R2(a, e), R3(s, u)}. The solutions for P1 are: D(P1)′ = {R1(a, b),R1(s, t), R1(c, d), R1(a, e)} and D(P1)′′ = {R1(a, b), R1(c, d), R1(a, e)}.\nIf the query Q : R1(x , y) is posed to P1, the PCAs are 〈a, b〉, 〈c, d〉, 〈a, e〉, because those are R1-tuples found in in the intersection of P1’s solutions.\nNow, let us try an alternative method for peer consistently answering the same query. We first rewrite the query using the DEC in Σ(P1, P2), obtaining Q′ : R1(x , y)∨R2(x , y), with the effect of bringing P2’s data into P1. Next, considering Σ(P1, P3), this query is rewritten as\nQ′′ : [R1(x , y) ∧ ∀z1((R3(x , z1) ∧ ¬∃z2R2(x , z2)) → z1 = y)] ∨ R2(x , y) · (A1) To answer this query, P1 first issues a query to P2 to retrieve the tuples in R2, since they will be essentially in R1 in all the solutions, due to Σ(P1, P2). Next, a query is issued to P3 to leave aside from the answers those tuples of R1 that have the same first but not the same second argument in R3. This filtering is performed as long as there is no tuple in R2 that “protects” the tuple in R1. For example, the tuple"
    }, {
      "heading" : "62 L. Bertossi, L. Bravo",
      "text" : "R1(a, b) is protected by R2(a, e) because, as R1(a, e) belongs to all the solutions, the only way to repair a violation with respect to Σ(P1, P3) is by deleting the tuple from R3. In this case, the R1-tuple will be in the answer.\nWe can see that answering query (A1) amounts to issuing from P1 queries to P2, P3 about the contents of their relations, R2 and R3, resp., which are answered by the latter by classical query evaluation over their local instances. After those data have been gathered by P1, it proceeds to evaluate (A1), which contains an implicit repair process.\nNow, the answers to (A1) are 〈a, b〉, 〈c, d〉, 〈a, e〉, precisely the PCAs we obtained above, considering all the explicit solutions for P1. 2\nThe FO rewriting methodology we just illustrated is bound to have limited applicability. If this was a general mechanism, PCAs to conjunctive queries could be obtained in polynomial time in data, i.e. in the size of the union of the instances of a peer and those of its neighbors (or the local intersections of their solutions). However, Corollary 5.2 tells us that the complexity is higher than this (if P 6= NP ).\nA.3 A semantics based on arbitrary data elements\nThe purpose of this section is twofold. First, we will present an alternative special semantics that fits into the general semantic framework of Section 3. Second, we will show that this general semantics (and also the one in Section 4) can handle data mappings that are more complex that those usually considered in the related work on peer data exchange. All this will be done on the basis of an extended example.\nConsider a PDES P = 〈P,S,Σ, T rust〉 with P = {P1, P2}, S = {S(P1),S(P2)}, S(P1) = {R1(·, ·), T 1(·, ·)}, S(P2) = {T 2(·, ·), S 2(·, ·)}, Trust = {(P1, less, P2)}, and Σ(P1, P2) consists of the following DEC:\n∀x∀y∀z (R1(x , y) ∧ T 2(z , y) → ∃w(T 1(x ,w) ∧ S 2(z ,w))) · (A2) This DEC, which falls within our general syntactic class of DECs, mixes tables of the two peers on each side of the implication. This kind of mapping is more general than those typically considered in virtual data integration (Lenzerini 2002) or data exchange (Kolaitis 2005).25\nIf (A2) is not satisfied by the data in P1 and P2, which happens when the join in the antecedent is satisfied, but not the one in the consequent, then solutions for P1 have to be found, keeping P2’s data fixed in the process, due to the trust relationship. Now, in this section we will depart from the solution semantics introduced in Section 4, by restoring consistency with respect to (A2) through the introduction of arbitrary elements of the data domain U .26 Those elements become witnesses for the existentially quantified variables in the DECs. That is, these values come\n25 Cf. (Bertossi and Bravo 2004b) for some connections between PDESs and virtual data integration under the local-as-view approach. Also (De Giacomo et al. 2007), for relationships between PDESs, virtual data integration, and data exchange. 26 This U could be a finite superset of the union of the active domains involved or infinite. The latter case is also covered by our semantics. The logic programming semantics is also perfectly defined in this case.\nConsistency and Trust in Peer Data Exchange Systems 63\nfrom the data domain, and are not replaced by null or by labeled nulls as in data exchange (Kolaitis 2005). Since we have alternative choices for them, we may obtain different solutions for a peer. However, by definition of solution, they have to stay as close as possible to the original instance. In this case, the general comparison relation D between neighborhood instances of Section 3 is given by: D1 ∆D D2 iff ∆(D ,D1) ⊆ ∆(D ,D2).\nWe will specify the solutions for this example directly in (or using) logic programs. We will also show the most relevant part of the program Π−(P1). Since we have to restore consistency with respect to (A2), the main rules are (A3)-(A6) below.\nR1 (x , y , f) ← R1 (x , y , t?),T 2(z , y), not aux1(x , z ), not aux2(z ) · (A3) aux1(x , z ) ← T 1 (x ,w , t?),S 2(z ,w) · (A4) aux2(z ) ← S 2(z ,w)· (A5)\nThat is, R1(x , y) is deleted if it participates in a violation of (A2) (what is captured by the first three literals in the body of (A3) plus rule (A4)), and there is no way to restore consistency by inserting a tuple into T 1, because there is no possible matching tuple in S 2 for the possibly new tuple in T 1 (what is captured by the last literal in the body of (A3) plus rule (A5)). In case there is such a tuple in S 2, we can either delete a tuple from R1 or insert a tuple into T 1:\nR1 (x , y , f) ∨ T 1 (x ,w , t) ← R1 (x , y , t?), T 2(z , y), not aux1(x , z ), S 2(z ,w), choice((x , z ),w)· (A6)\nThat is, in case of a violation of (A2), when there is tuple of the form S 2(a, t) in S 2 for the combination of values 〈d , a〉, then the choice operator (Giannotti et al. 1991) non-deterministically chooses a unique value for t , so that the tuple T 1(d , t) is inserted into T 1 as an alternative to deleting R1(d ,m) from R1. The choice predicate can be eliminated and replaced by another predicate that can be specified by means of extra but standard rules (Giannotti et al. 1991).\nIf, instead, we had Trust = {(P1, same, P2)}, P2’s relations would also be flexible when searching for solution instances. In this case, the program becomes more involved in terms of presentation (but not conceptually), in the sense that more relations can be updated, and corresponding repair rules have to be added.\nNotice that in this example, the values that are chosen as witnesses for the existential quantifier in the DEC are taken from the active domain of the database, namely from the set of values for the second attribute of relation S 2. In other cases, for example with a DEC of the form ∀x∀y(T 2(x , y) → ∃zR1(x , z )), we have to consider arbitrary values from an underlying domain dom when inserting tuples into R1. In this case, dom requires a specification as a finite predicate in the program.\nSome of the ideas presented above (such as the insertion of elements from the active domain and the use of the choice operator) have been fully developed and applied by the authors (Bertossi and Bravo 2004a; Bravo and Bertossi 2003; Bravo and Bertossi 2005) to inconsistency management in virtual data integration systems under the local-as-view approach (Lenzerini 2002)."
    }, {
      "heading" : "64 L. Bertossi, L. Bravo",
      "text" : "A.4 Data transport and semantics\nThe data distributed across different peers has to be appropriately gathered to build solution instances for a peer, and different semantics may emerge as candidates, depending on the granularity of the data sent between peers. In the context of the general semantic framework introduced in Section 3, we developed a particular semantics in Section 4, according to which a peer Q passes back to a neighbor P, who is building its solutions, this is (part of) its certain data. This is the one that holds in all of Q’s solutions.\nIn (Bravo 2007, chapter 7) also two other alternative semantics are fully developed and compared, in particular establishing some conditions under which they coincide or differ. Those other semantics assume that more detailed information, such as mappings and trust relationships, can be sent between peers. We briefly describe them.\n1. Send all. The first one assumes that data, DECs and trust relations can be sent between peers. So, we can think that we have a possibly large database instance that has to be virtually repaired in order to satisfy all the relevant DECs (obtained from the accessibility graph) and at the same time accommodating the trust relationships. In this case, the DECs are treated as traditional ICs on the integrated instance. This semantics is similar to the repair semantics for consistent query answering. Preferences imposed on repairs can be used to capture the trust relationships. In this case, it is not necessary to require the acyclicity of the accessibility graph.\n2. Send solutions. The second one assumes that only solutions can be send between neighboring peers. In this case, a peer P requests the solutions of the neighbors in order to calculate its own solutions. Here, the database consists of the data at P plus all the solutions of P’s neighbors; and the constraints are the DECs between P and its neighbors. As in Section 3, this is a recursive definition, and assumes an acyclic accessibility graph.\nWe think that the semantics we developed in Section 3, which could be called “send cores”, is more natural (a peer passes over what it is certain about), and also simplifies reasoning at the local level, i.e. at each peer’s site, because at most one instance peer neighbor has to be considered.\nNow, under our official semantics, if we want to use local solution programs, each neighbor of a peer P has to run its program, and then send the (relevant part of the) intersection of the stable models to P, who runs its local solution program. This means that different programs have to be fed externally.\nAt least under the “send solutions” and “send cores” semantics (which assumes an acyclic peer graph), we could imagine having a single program that does all this output/input concatenation, internally. Actually, it is possible to build a single program for a peer, say Πman(P), that acts as a combination of solution programs as given in Section 6. For each peer Q that is accessible from P, the program locally runs a solution program, produces Q’s solutions (its stable models), or the intersection\nConsistency and Trust in Peer Data Exchange Systems 65\nthereof; and, without leaving Πman(P), passes them to its preceding neighbors Q’, who uses them to locally compute its own solutions by means of its own, local solution program, etc., until reaching P. Such a program Πman(P) can be a manifold program (Faber and Woltran 2011).\nActually, within a manifold program (MP), a program can pass certain or possible query answers as an input to another program. Conceptually, MPs offer a nice logical solution, by means of a single program, to this form of program combination that, otherwise, would require external intervention (the efficient implementation of MPs is still an open problem).\nA.5 On trust\nWe introduced trust relationships in the process of peer data exchange already in (Bertossi and Bravo 2004b); and here we have further developed this idea, in a general semantic framework. However, the notion of trust we have in this work is still rather simple. Actually, it can be represented as an annotated binary relation between peers. It would be interesting to impose a more sophisticated and rich model of trust on top of the DECs-bases network of peers. Our concern is not about computing or updating trust in a P2P overlay network (Xiong and Liu 2004; Jøsang et al. 2006), but about logical specifications of trust. We envision a logicbased model of trust that can be integrated with/into the DECs. Such a model could express some higher level properties, e.g. symmetry or transitivity of trust relationships. A logic-based representation of trust could allow us to infer nonexplicit trust relationships whenever necessary.\nTrust modeling is an active and important area of research nowadays, most notably in the context of the semantic web. See (Sabater and Sierra 2005; Artz and Gil 2007) for surveys. The integration of trust models, including related notions, like reputation, provenance, etc., into peer data exchange is still an open area of research. This is specially the case for logic-based models of trust (Herzig et al. 2008). See (Hien Nguyen et al. 2008) and references therein for probabilistic approaches.\nIn Definition 6.1, the trust relationships between peers were implicitly and rigidly captured in the specifications of solutions by means of the disjunctive heads of the repair rules. Although this is a simpler way of presenting things, it has some drawbacks: (a) The approach is not modular in the sense that trust is built-in into the rules; (b) Changes in trust relationships requires changing heads of repair rules; and (c) In case no solution exists due to the rigid and conflicting trust relationships, no alternative, but possibly less desirable solution can be obtained as a stable model of the solution program.\nOne way of addressing these issues is through the use of preference programs, which are answer set programs that express different forms of preference, which essentially amounts to preferring and keeping only certain stable models of the program. For example, in a disjunctive rule of the form A ∨ B ← Body, one could prefer to make A true instead of B . If this is possible, only that stable model would be chosen. However, if that is not possible (due to the other rules and facts in the program), making B true is still good enough. More complex preferences could"
    }, {
      "heading" : "66 L. Bertossi, L. Bravo",
      "text" : "also be captured. Preferences can be explicitly and declaratively expressed, and the resulting programs can be compiled into usual answer set programs with their usual stable model semantics (cf. (Brewka 2004) and references therein).\nHere we briefly outline how weak program constraints (Buccafurri et al. 2000; Leone et al. 2006) declaratively capture the kind of preferences that address our needs. (Cf. (Brewka 2004) for connections between preferences in logic programs and weak constraints.).\nExample 6 Consider Example 6.2, where (P1, less, P2) ∈ Trust is captured by the non-disjunctive repair rule\nR1 (x , y , t)← R2 (x , y , t?),R1 (x , y , f?), x 6= null, y 6= null· The same effect, and more, could be obtained by uniformly using disjunctive rules followed by appropriate weak constraints. In this case,\nR1 (x , y , t) ∨ R2 (x , y , f) ← R2 (x , y , t?),R1 (x , y , f?), x 6= null, y 6= null · ⇐ R2 (x , y , f)· (A7)\nHere, the weak constraint (A7) expresses a preference for the stable models of the program that minimize the number of violations of the condition expressed its body, in this case, that, when restoring the satisfaction of the DEC ∀x∀y(R2(x , y) → R1(x , y)), the tuple R2(x , y) is not deleted. These weak constraints are used by a peer P to ensure that, if possible, the tuples in the peers that it trusts more than itself are not modified. 2\nIf the original solution program has solutions, then the new program would have the same solutions. However, the latter could have solutions when the former does not. This would make the semantics of the system more flexible with respect to unsatisfiable trust requirements. It is also clear that the weak constraints could be easily derived from the trust relationships and the DECs. The solution program with weak constraints can be run in the DLV system (Leone et al. 2006) to obtain the solutions and peer consistent answers of a peer.\nNotice that the new repair programs, except for the weak program constraints, are now of the same kind as those for specifying repairs of single databases with respect to local ICs (Bravo and Bertossi 2006). Actually, if in the new program the weak program constraints are replaced by (hard) program constraints, e.g. (A7) by ← R2 (x , y , f), the solutions coincide with those of the programs in Definition 6.1. We should mention that in (Arenas et al. 2003), weak constraints were used, as a part of a repair program, to specify the preference for cardinality repairs, i.e. repairs that minimize the number of tuples that are inserted or deleted to restore consistency, as opposed to minimality (with respect to subset-inclusion) of sets of inserted/deleted tuples."
    }, {
      "heading" : "Appendix B Proofs of Results",
      "text" : "Proof of Proposition 3.1:\nConsistency and Trust in Peer Data Exchange Systems 67\nLet D0 be an empty instance for the schema S(N (P)). By being empty, D0 satisfies ⋃ Q∈N (P) Σ(P, Q) (condition (i) for a neighborhood solution). Also, since all the trust relationships are of the “same” kind, condition (ii) on neighborhood solutions is satisfied by D0. Then, either D0 is a neighborhood solution, or there exists a neighborhood solution D ′′ such that D ′′ D̄ D0. 2\nProof of Corollary 3.1:\nAll we need is notice that the possibly inconsistent sink peers in the accessibility graph always have local repairs under the kind of DECS considered (ICs in that case). A solution for a peer P can then be obtained by recursively propagating back neighborhood solutions (that always exist by Proposition 3.1) for peers along the paths that contain P. 2\nProof of Proposition 5.1:\nMembership of coNP is established by directly appealing to Definition 3.1 of neighborhood solution. In fact, given neighborhood instance J , after having checked (in polynomial time) if J ⊆ r -Chasenull(D̄ ,Σ−(P)), a non-deterministic algorithm to test that J is not a neighborhood solution for P and the neighborhood instance D̄ checks if one of the following holds:\n1. J 6|= Σ(P). 2. J {R} 6= D̄ {R}, for some Q ∈ N (P) and predicate R ∈ S(Q) with\n(P, less, Q) ∈ Trust. 3. There is an instance J ′ for S(N (P)) (the non-deterministic choice) that sat-\nisfies conditions (i) and (ii) of Definition 3.1, but J ′ <Σ(P) D̄ J .\nThese conditions are the basis for a non-deterministic algorithm: First conditions 1. and 2. can be checked deterministically in polynomial time. If they are passed by J (i.e. the answer is negative), then an instance J ′ with size polynomially bounded by the size of J is guessed. Next, conditions 1.-2. are checked for J ′, and 3., for the pair (J , J ′). The three tests can be performed in polynomial time in |J | + |D̄ |. If the answer to any of the tests is yes, J is not a neighborhood solution.\nHardness can be proved by reduction of satisfiability of propositional formulas in CNF, which is coNP -complete. The reduction is a modification of that used in Theorem 4.4 of (Chomicki and Marcinkowski 2005) to prove that repairs obtained through deletions are coNP -complete. In our case we have to deal with trust relationships and the possible insertion of tuples with null. Actually, in our proof the former will be used to exclude the latter.\nWe now show that the satisfiability of a propositional formula ϕ : ϕ1 ∧ ϕ2 ∧ . . . ϕm in CNF (i.e. the ϕi are clauses) can be reduced to checking if a particular neighborhood instance is a neighborhood solution for a given peer.\nConsider the fixed PDES schema (it does not depend on ϕ): P = 〈P,S,Σ, T rust〉, with P = {P1, P2}, S = {S (P1),S (P2)}, S (P1) = {R1(·, ·, ·, ·)}, S (P2) = {R2(·, ·, ·, ·)}, Trust = {(P1, same, P1), (P1, less, P2)}, and Σ = {Σ(P1, P1),Σ(P1, P2)}, with:\nΣ(P1, P1) = {∀x1y1y2z1z2w1w2(R1(x1, y1, z1,w1) ∧ R1(x1, y2, z2,w2)→ y1 = y2),"
    }, {
      "heading" : "68 L. Bertossi, L. Bravo",
      "text" : "∀x1y1z1w1(R1(x1, y1, z1,w1)→ ∃x2y2z2R1(x2, y2, z2, z1))}. Σ(P1, P2) = {∀xyzw(R1(x , y , z ,w)→ R2(x , y , z ,w))}.\nNow, consider a propositional formula ϕ as above, on which the instances for the\npeer system will depend. Let Dϕ = {D(P1),D(P2)} be the instance for P, with:\nD(P1) = {R1(pj , 0, ϕi , ϕi+1) | pj occurs negatively in ϕi} ∪ {R1(pj , 1, ϕi , ϕi+1) | pj occurs positively in ϕi} · D(P2) = {R2(a, b, c, d) | R1(a, b, c, d) ∈ D(P1)}·\n(The addition i +1 is meant to be modulo the number m of clauses in φ.) Notice that tables R1 and R2 for peers P1 and P2, respectively, have the same rows. Intuitively, the UDEC in Σ(P1, P1) ensures that, for every proposition in the first attribute of R1, the truth assignment, if any, is unique; whereas the RDEC in it, ensures that there are assignments that make all clauses in the formula true.\nWe now show that the neighborhood instance D̄ , with the empty relation for R1 plus the original contents of D(P2), is the neighborhood solution for P1 with initial neighborhood instance D(P1)∪D(P2) if and only if ϕ is not satisfiable. In this case, D̄ would be obtained through the deletion of all tuples from R1 in D(P1). Notice that due to the trust relations and the DEC in Σ(P1, P2), only tuple deletions from peer P1’s instance are admissible updates.\nTo prove that D̄ being a neighborhood solution for P1 implies that ϕ is not satisfiable, assume by contradiction that ϕ is satisfiable. Then, there is an assignment σ that makes ϕ true.\nThe instance D̄ ′ := {R1(p, 0, ϕi , ϕi+1) ∈ D(P1) | σ(p) = 0} ∪ {R1(p, 1, ϕi , ϕi+1) ∈ D(P1) | σ(p) = 1} ∪ D(P2) is a subinstance of D(P1) ∪ D(P2), D̄ ′ S(P1) 6= ∅, satisfies the DECs, and does not modify the more trusted relations, i.e. D̄ ′ S(P2) = D(P2). Thus, D̄ cannot be a neighborhood solution since D̄ ′ <Σ(P1)\nD(P1)∪D(P2) D̄ .\nNow we show that if ϕ is not satisfiable, then D̄ is a neighborhood solution for P1 when starting with neighborhood instance D(P1) ∪ D(P2). Assume by contradiction that D̄ is not a neighborhood solution. Since D̄ satisfies all the DECs and respects the trust relationships, D̄ cannot be a neighborhood solution only if there is a neighborhood instance D̄ ′, such that: D̄ ′ |= Σ(P1); D̄ ′ S (P2) = D(P2), and D̄ ′ <Σ(P1)\nD(P1)∪D(P2) D̄ . Since D̄ ′ can be obtained only through tuple deletions, it holds:\nD̄ $ D ′ ⊆ D(P1) ∪ D(P2). Thus, there is at least one tuple R1(t̄) ∈ (D̄ ′ ∩ D(P1)). Due to the UDEC in Σ(P1, P2), we conclude that, for every i ∈ [1,m], there exists a p and v with R1(p, v , ϕi , ϕi+1) ∈ (D ′ ∩D(P1)). Using these tuples we can define the following assignment σ′:\nσ′(p) = { 1 if R1(p, 1, ϕi , ϕi+1) ∈ D ′ with i ∈ [1,m] 0 if R1(p, 0, ϕi , ϕi+1) ∈ D ′ with i ∈ [1,m]\nThe assignment is well defined, because the functional dependency in Σ(P1, P1) ensures that only one value exists for each proposition. By construction, σ′ is an assignment that satisfies ϕ. We have reached a contradiction, which completes the proof. 2\nConsistency and Trust in Peer Data Exchange Systems 69\nProof of Proposition 5.2:\nFirst we prove membership of ΠP2 . An atom R(t̄) ∈ localCore(P, D̄) if for every D ′ ∈ NS(P, D̄), D ′ |= R(t̄). Thus, a non-deterministic algorithm that checks if R(t̄) 6∈ localCore(P, D̄) guesses an instance J of S(N (P)), next checks if it is a neighborhood solution for P and D̄ , and finally, if R(t̄) 6∈ J . By Proposition 5.1, the first of these two tests is in coNP ; and the second one is in polynomial time. Thus, the problem is in ΠP2 .\nHardness holds by a reduction from satisfiability of a quantified propositional formulas (QBF) β of the form ∀p1 · · · ∀pk∃q1 · · · ∃qlψ, where ψ is a quantifier-free propositional formula in CNF, i.e. of the form ψ1 ∧ . . . ∧ ψm , where the ψi are clauses. This problem is ΠP2 -complete (Schaefer and Umans 2008; Papadimitriou 1994). (The reduction is adapted from that for Theorem 4.7 in (Chomicki and Marcinkowski 2005).)\nWe construct a PDES schema (independent from β) P0 = 〈P0,S0,Σ0, T rust0〉, with P0 = {P1, P2}, S0 = {S(P1),S(P1)}, S(P1) = {R(·, ·, ·),T (·)}, S(P2) = {Clause(·), V ar(·)}, Trust0 = {(P1, less, P2)}, and the DECs Σ0 = {Σ(P1, P2), Σ(P1, P1)} with: Σ(P1, P2) = {∀x (Clause(x )→ ∃yzR(y , z , x )),\n∀x (V ar(x )→ R(x , 1, a) ∨ R(x , 0, a))}, Σ(P1, P1) = {∀xy1y2z1z2(R(x , y1, z1) ∧ R(x , y2, z2))→ y1 = y2,\n∀xyzw(R(x , y , z ) ∧ T (w)→ w 6= sat ∨ IsNotNull(x ) ∨ IsNotNull(y))} ·\nNow, given a QBF β, we construct an instance D̄β for the neighborhood schema S(N (P1)) around P1, such that: T (sat) ∈ localCore(P1, D̄β) iff β is true. Now, for β = ∀p1 · · · ∀pk∃q1 · · · ∃ql(ψ1 ∧ . . . ∧ ψm), D̄β := Dβ(P1) ∪Dβ(P2), with:\nDβ(P1) := {R(varj , 1, ψi) | varj occurs positively in ψi} ∪ {R(varj , 0, ψi) | varj occurs negatively in ψi} ∪ {V ar(pi) | pi is universally quantified in ψ} ∪ {T (sat)} ·\nDβ(P2) := {Clause(ψ1), . . . , Clause(ψm)}· Intuitively, relation R(x , y , z ) is used to provide a truth value y to variable x in conjunct z . This truth value will be unique across ψ due to the integrity constraints on R contained in Σ(P1, P1). The first DEC in Σ(P1, P2) ensures that, for every clause ψi , there is, if possible, a literal which is true in it. If it is not possible (the formula is not true), it inserts a tuple of the form R(null, null, ψi). The second DEC ensures that all possible assignments for the universally quantifies variables are tested in different solutions. It uses a constant, a, which is different from all ψi . The first IC in Σ(P1, P1) enforces that, in each solution, each propositional variable takes a unique value. Finally, the second IC in Σ(P1, P1) ensures that if R(null, null, ψi) is true, then predicate T (sat) should not be part of the neighborhood solution. In this way, formula β is true if and only of T (sat) ∈ localCore(P1, D̄β). To conclude the proof, we illustrate the reduction with the following example.\nExample 7"
    }, {
      "heading" : "70 L. Bertossi, L. Bravo",
      "text" : "Fig. B 1. Instances for a peer system\nConsider the QBF ∀p1∃q1∃q2(ψ1 ∧ ψ2 ∧ ψ3), with ψ1 : (p1 ∨ q1), ψ2 : (p1 ∨ ¬q2), and ψ3 : q2. Instance D̄β is the union of the instances in Figure B 1.\nOn this basis, the neighborhood solutions for P1 and D̄β are:\nD1 ={R(p1, 1, a),R(p1, 1, ψ1),R(q1, 1, ψ1),R(p1, 1, ψ2),R(q2, 1, ψ3),T (sat)}∪D(P2), D2 ={R(p1, 0, a),R(q1, 1, ψ1),R(q2, 1, ψ3),R(null, null, ψ2)} ∪D(P2), and D3 ={R(p1, 0, a),R(q1, 1, ψ1),R(q2, 0, ψ2),R(null, null, ψ3)} ∪D(P2).\nSince T (sat) 6∈ localCore(P1, D̄β) := (D1 ∩D2 ∩D3) S(P1), the QBF formula is false.\n2\nProof of Corollary 5.2:\nMembership is established with a test similar to that in the proof of Proposition 5.2. Hardness follows from Proposition 5.2, because it is about a particular kind of conjunctive queries, namely atomic of the form Q(x̄ ) : R(x̄ ), where R is a predicate for a peer P. The peer consistent answers to this query are exactly the c̄s, such that R(c̄) is in the local core of P. 2\n1 Algorithm: ImportSolution 2 Input: An instance D for a PDES schema P = 〈P,S,Σ, T rust〉 and a peer P ∈ P 3 Output: The unique solution of P 4 if P has no outgoing edges then return D(P) else 5 foreach Q ∈ N ◦(P) do 6 Sol(Q,D)← ImportSolution(P, Q); 7 D ′ ← D(P) ∪ ⋃ Q∈N◦(P) Sol(Q,D); 8 NS ← minimal model of Datalog import program I(P,D ′) ; 9 return NS S(P);\nFig. B 2. Computing the solution for a peer in the import case\nProof of Proposition 5.3:\nThe existence and uniqueness is straightforward since there are no local restrictions (existence), and there is no non-determinism involved (uniqueness). The unique solution for a peer P can be computed by means of Algorithm ImportSolution shown in Figure B 2. It recursively computes the solutions for all the peers that are accessible\nConsistency and Trust in Peer Data Exchange Systems 71\nfrom P. The base case occurs when a peer Q has no DECs (line 4). In that case, its unique solution is its own database D(Q). Otherwise (lines 5-10), the algorithm recursively requests the solutions of its neighbors (lines 6-7) and uses them to construct instance D ′ (line 8). Then, the unique neighborhood solution for the peer consists of the minimal model of I(P,D ′) (line 9). By restricting P’s neighborhood solution to P’s schema we get P’s solution (line 10). 2\nProof of Proposition 6.1:\nWe will prove this result for the case where the central peer trusts its neighbors as much as itself, which is more general in some sense than that where it trusts neighbors’ data more, because more alternatives for repairs come up, using the full power of disjunctive programs. Below D is P’s neighborhood instance for which neighborhood solutions are specified by means of the program in Definition 6.1. C is the set of constraints, i.e. UDECs and RDECs, for the neighborhood.\nGiven the trust assumptions, the program takes a special form, as follows. For\nexchange constraints in C of the forms: (a) Universal constraint (UDEC):\n∀x̄ ( m∧\ni=1\nPi(x̄i) −→ n∨\nj=1\nQj (ȳj ) ∨ ϕ) · (B1)\n(b) Referential constraint: (RDEC)\n∀x̄ (P(x̄ ) −→ ∃ȳ Q(x̄ ′, ȳ)) · 27 (B2) the neighborhood solution program Π(P,D) becomes:\n1. dom(c) for every c ∈ Adom(D) r {null}. 2. The fact P(ā) for every atom P(ā) ∈ D. 3. For every UDEC ψ of the form (B1), the rule:∨n\ni=1 Pi (x̄i , f) ∨ ∨m j=1 Qj (ȳj , t) ←− ∧n i=1 Pi (x̄i , t ?), ∧m j=1 Qj (ȳj , f ?),∧\nxl∈RelV (ψ) dom(xl), ϕ̄· where RelV (ψ) is the set of relevant attributes for ψ, x̄ = ⋃n i=1 xi , and ϕ̄ is a conjunction of built-ins that is equivalent to the negation of ϕ.\n4. For every RDEC ψ of the form (B2), the rules:28\nP (x̄ , f) ∨Q (x̄ ′, null, t)← P (x̄ , t?), not auxψ(x̄ ′), dom(x̄ ′)· And for every yi ∈ ȳ : auxψ(x̄\n′)← Q (x̄ ′, ȳ , t?), not Q (x̄ ′, ȳ , f), dom(x̄ ′), dom(yi). auxψ(x̄\n′)← Q(x̄ ′, null), not Q (x̄ ′, null, f), dom(x̄ ′). 5. For every predicate P ∈ S(N (P)), the rules:\nP (x̄ , t?)← P(x̄ ) · P (x̄ , t?)← P (x̄ , t)· P (x̄ , f?)← P(x̄ , f) · P (x̄ , f?)← dom(x̄ ), not P(x̄ )·\n6. For every predicate P ∈ S(N (P)), the interpretation rules: P (x̄ , t??) ← P (x̄ , t) · P (x̄ , t??) ← P(x̄ ), not P (x̄ , f)· 7. For every predicate P ∈ S(N (P)), the coherence constraints: ← P (x̄ , t), P (x̄ , f)·\nThe claim is: IfM is a stable model of Π(P,D), then DM is a neighborhood solution\n28 Literal dom(x̄) denotes the conjunction of the atoms dom(xj ) for xj ∈ x̄ ."
    }, {
      "heading" : "72 L. Bertossi, L. Bravo",
      "text" : "repair of D. Furthermore, the neighborhood solutions obtained in this way are all the neighborhood solutions of D. We recall that for a stable model of Π(P,D),\nDM = {P(ā) | P ∈ S(N (P)) and P (ā, t??) ∈ M } · (B3)\nThe proof follows directly from Propositions 1 and 2 below, which require in their turn some lemmas and intermediate definitions. 2\nIn the following, for a disjunctive program Π and a set of ground atoms M , ΠM is the positive ground program obtained by the Gelfond-Lifschitz transformation (Gelfond and Lifschitz 1991):\nΠM = {H ← B | H ← B , notA1, . . . , notAm ∈ ground(Π), and A1, . . .Am /∈ M }·\nLemma 1 Given an instance D and a RDEC-acyclic set of UDECs and RDECs, if M is a stable model of Π(P,D), then exactly one of the following cases holds:\n1. P(ā), P (ā, t?) and P (ā, t??) belong to M , and no other P (ā, v), for v an\nannotation, belongs to M .\n2. P(ā), P (ā, t?) and P (ā, f) belong to M , and no other P (ā, v), for v an\nannotation, belongs to M .\n3. P(ā) 6∈ M , and P (ā, t), P (ā, t?), P (ā, t??) belong to M , and no other P (ā, v), for v an annotation, belongs to M . 4. P(ā) 6∈ M , and no P (ā, v), for v an annotation, belongs to M .\nProof: For an atom P(ā), there are two possibilities:\n(a) P(ā) ∈ M . Then, from rule 5., P (ā, t?) ∈ M . Two cases are possible now: P (ā, f) 6∈ M or P (ā, f) ∈ M . In the first case, since M is minimal, P (ā, t) 6∈ M and P (ā, t??) ∈ M . In the second case, due to rule 7., P (ā, t) 6∈ M . These cases cover the first two in the statement of the lemma. (b) P(ā) 6∈ M . Two cases are possible now: P (ā, t) ∈ M or P (ā, t) 6∈ M . In the first one, it also holds P (ā, t??), P (ā, t?) ∈ M , by rules 5. and 6.; and P (ā, f) 6∈ M by rule 7. In the second case, P (ā, t?) 6∈ M (because M is minimal), P (ā, f) 6∈ M (because P (ā, t?) 6∈ M , and M is minimal). These cases cover the last two in the statement of the lemma.\n2\nFrom two database instances we can define a structure.\nDefinition 1 For two database instances D1 and D2 over the same schema and domain and a set of constraints C, M ?C (D1, D2) is the Herbrand structure 〈U , IP , IB〉, where U is the underlying domain,29 and IP , IB are the interpretations for the database predicates (extended with annotation arguments), and the built-ins, respectively. IP is inductively defined as follows:\n29 In this case it can be restricted to the active domain of the neighborhood instance D (or the union of the active domains of D1,D2) plus the constant null.\nConsistency and Trust in Peer Data Exchange Systems 73\n1. If P(ā) ∈ D1 and P(ā) ∈ D2, then P(ā), P (ā, t?) and P (ā, t??) ∈ IP . 2. If P(ā) ∈ D1 and P(ā) 6∈ D2, then P(ā), P (ā, t?) and P (ā, f) ∈ IP . 3. If P(ā) 6∈ D1 and P(ā) 6∈ D2, then P (ā, v) 6∈ IP for every annotation v . 4. If P(ā) 6∈ D1 and P(ā) ∈ D2, then P (ā, t), P (ā, t?) and P (ā, t??) ∈ IP . 5. For every RDEC ψ ∈ C of the form ∀x̄ (P(x̄ )→ ∃ȳQ(x̄ ′, ȳ)): If P (ā, t??) ∈ IP\nand Q (ā ′, b̄, t??) ∈ IP , with ā 6= null and at least one b ∈ b̄, b 6= null, then auxψ(ā\n′) ∈ IP . The interpretation IB is defined as expected: if Q is a built-in, then Q(ā) ∈ IB iff Q(ā) is true in classical logic, and Q(ā) 6∈ IB iff Q(ā) is false. 2\nNotice that the database instance associated to M ?C (D1,D2) through (B3) corresponds exactly to D2, i.e. DM?C (D1,D2) = D2.\nLemma 2 Given an instance D and a set C of UDECs and RDECs, if D ′ |= N C, then there is a model M of the program Π(P,D)M with DM = D ′. Actually, M ?C (D ,D\n′) is such a model.\nProof: Since DM?C (D,D′) = D ′, we only need to show that M ?C (D ,D ′) satisfies all the rules of Π(P,D)M ? C (D,D ′). First, by construction, it is clear that rules 2., 5. and 6. are satisfied by M ?C (D ,D ′).\nFor every UDEC in C, the program has the rule in 3. If its body is satisfied, then the atoms Pi (āi , t\n?) ∈ M ?C (D ,D ′) and Qi (b̄i , f) ∈ M ?C (D ,D ′) or Qi(b̄i) 6∈ M ?C (D ,D\n′). Also, since the constraint is satisfied, at least one of the Pi(āi) is not in D ′ or one of the Qi(b̄i) is in D ′. By construction of M ?C (D ,D\n′), at least one of Pi (āi , f) or Qi (b̄i , t) is in M ? C (D ,D\n′). Therefore, the head of the rule is also satisfied.\nFor every RDEC in C, there are the rules 4. By construction of M ?C (D ,D ′), for every ψ ∈ C, those that define auxψ(x̄ ) are satisfied.\nIf the body of the first rule in 4 is true in M ?C (D ,D ′), it means that the constraint is not satisfied in the initial instance or at some point along the repair process. Since the constraint is satisfied by D ′, the satisfaction is restored by adding Q (x̄ , null) or by deleting P(x̄ ). This implies that Q (x̄ , null, t) ∈ M ?C (D ,D ′) or P (x̄ , f) ∈ M ?C (D ,D ′). As a consequence, the first (or second) rule is satisfied. Then, by construction of M ?C (D ,D\n′), P (ā, f) ∈ M ?C (D ,D ′), and the head of the rule is satisfied. 2\nThe next lemma shows that if M is a minimal model of the program Π(P,D)M , then DM satisfies the constraints.\nLemma 3 Given a database D and a set of constraints C, if M is a stable model of the program Π(P,D), then DM |=N C.\nProof: We want to show that DM |=N ψ, for every constraint ψ ∈ C. There are two cases to consider:"
    }, {
      "heading" : "74 L. Bertossi, L. Bravo",
      "text" : "A. IC ψ is a UDEC. Since M is a model of Π(P,D)M , M satisfies rules 3. of\nΠ(P,D). Then, at least one of the following cases holds:\n(a) Pi (ā, f) ∈ M . Then, Pi(ā, t??) /∈ M and P(ā) 6∈ DM (by Lemma 1). Hence, Pi(ā) /∈ DM . Since the analysis was done for an arbitrary value ā, DM |=N ∧n i=1 Pi(x̄i)→ ∨m j=1 Qj (ȳj ) ∨ ϕ holds. (b) Qj (ā, t) ∈ M . It is symmetric to the previous one. (c) It is not true that M |=\nN ϕ̄. Then M |= N ϕ. Hence, ϕ is true, and\nDM |=N ∧n i=1 Pi(x̄i)→ ∨m\nj=1 Qj (ȳj ) ∨ ϕ holds. (d) Pi (ā, t\n?) /∈ M . Given that M is minimal, just the last item in Lemma 1 holds. This means Pi(ā, t\n??) /∈ M , Pi(ā) 6∈ DM and Pi(ā) /∈ DM . Since the analysis was done for an arbitrary value ā, DM |=N\n∧n i=1 Pi(x̄i) →∨m\nj=1 Qj (ȳj ) ∨ ϕ holds. (e) Qj (ā, f) /∈ M or Qj (ā) ∈ M . Given that M is minimal, just the first\nitem in Lemma 1 holds. Then, Qj (ā, t ??) ∈ M , Qj (ā) ∈ DM and DM |=N Qj (ā). Since the analysis was done for an arbitrary value ā, DM |=N ∧n i=1 Pi(x̄i)→ ∨m j=1 Qj (ȳj ) ∨ ϕ holds.\nB. Formula ψ is a RDEC. Since M is a model of Π(P,D)M , M satisfies rules 4.\nof Π(P,D). Then, at least one of the following cases holds:\n(a) P (ā, f) ∈ M . Then, Pi (ā, t??) /∈ M and P(ā) 6∈ DM (by Lemma 1). Hence, Pi (ā) /∈ DM . Since the analysis was done for an arbitrary value ā, DM |=N (P(x̄ )→ Q(x̄ ′, y)) holds. (b) Q (ā ′, null, t) ∈ M . It is symmetric to the previous one. (c) P (ā, t?) /∈ M . Given that M is minimal, just the last item in Lemma\n1 holds. This means P (ā, t??) /∈ M , P(ā) 6∈ DM and P(ā) /∈ DM . Since the analysis was done for an arbitrary value ā, DM |=N (P(x̄ ) → Q(x̄ ′, y)) holds. (d) auxψ(ā ′) ∈ M . This means that P (ā, t?) ∈ M and there exists b̄ 6= null\nwith Q (ā ′, b̄, t?) ∈ M , Q (ā, f) 6∈ M , and then, that P(ā) ∈ DM and Q(ā, b̄) ∈ DM . Then, the constraint is satisfied.\n2\nLemma 4 Let D and D ′ be instances over the same schema and domain. If M is a minimal model of Π(P,D)M ? C (D,D\n′) with M $ M ?C (D ,D ′), then there exists M ′ that is a minimal model of Π(P,D)M ′ with DM ′ <D D ′.\nProof: Since M is a minimal model of Π(P,D)M ? C (D,D ′), P(ā) ∈ M iff P(ā) ∈ D . By definition of M ?C (D ,D\n′) and M $ M ?C (D ,D ′), the only two ways that both models can differ is that, for some P(ā) ∈ D , P (ā, f) ∈ M ?C (D ,D ′) and neither P(ā) nor P (ā, f) belong to M , or for some P(ā) 6∈ D , {P (ā, t), P(ā, t?), P (ā, t??)} ⊆ M ?C (D ,D ′) and none of P(ā), P (ā, t), P(ā, t?), P (ā, t??) belong to M . Now, we can use the interpretation rules over M to construct M ′ that is a minimal model of Π(P,D)M ′ , as follows:\n1. If P(ā) ∈ M and P (ā, f) 6∈ M , then P(ā),P (ā, t?) and P (ā, t??) ∈ M ′. 2. If P(ā) ∈ M and P (ā, f) ∈ M , then P(ā),P (ā, t?) and P (ā, f) ∈ M ′.\nConsistency and Trust in Peer Data Exchange Systems 75\n3. If P(ā) 6∈ M and P (ā, t) 6∈ M , then nothing is added to M ′. 4. If P(ā) 6∈ M and P (ā, t) ∈ M , then P (ā, t), P (ā, t?) and P (ā, t??) ∈ M ′. It is clear that M ′ satisfies the coherence constraints, and is a minimal model of\nΠ(P,D)M ′ .\nIt just rests to prove that DM ′ <D D ′. First, we prove that DM ′ ≤D D ′. Let us suppose P(ā) ∈ ∆(D ,DM ′). Then, either P(ā) ∈ D and P(ā) 6∈ DM ′ or P(ā) 6∈ D and P(ā) ∈ DM ′ . In the first case, P(ā), P (ā, t?) and P (ā, f) belong to M ′. These atoms are also in M and, given the only two ways in which M and M ?C (D ,D\n′) can differ, they are also in M ?C (D ,D\n′). Hence, P(ā) ∈ ∆(D ,D ′). In the second case, P (ā, t) and P (ā, t?) belong to M ′. These atoms are also in M and, given the only two ways in which M and M ?C (D ,D ′) can differ, they are also in M ?C (D ,D ′). Hence, P(ā) ∈ ∆(D ,D ′). We now prove that DM ′ <D D\n′. We know that, for some fact P(ā), P (ā, t) ∈ M ?C (D ,D\n′) and P (ā, t) 6∈ M , or P (ā, f) ∈ M ?C (D ,D ′) and P (ā, f) 6∈ M . If P (ā, f) is in M ?C (D ,D\n′) and not in M , then, P(ā) ∈ ∆(D ,D ′), but P(ā) 6∈ ∆(D ,DM ′). Alternatively, if P (ā, t) and P (ā, t?) belong to M ?C (D ,D\n′) but not to M , then P(ā) ∈ ∆(D ,D ′), but P(ā) 6∈ ∆(D ,DM ′). Therefore, DM ′ <D D ′. 2\nProposition 1 Given a neighborhood instance D and a set C of UDECs and RDECs, if D ′ is a neighborhood solution for D with respect to C, then there is a stable model M of the program Π(P,D)M with DM = D\n′. Furthermore, the model M corresponds to M ?C (D ,D ′). Proof: By Lemma 2, M ?C (D ,D ′) is a model of Π(P,D)M ? C (D,D ′). We now show that it is minimal. Assume, by contradiction, that there exists a model M of Π(P,D)M ? C (D,D\n′) with M $ M ?C (D ,D ′). We can assume, without loss of generality, that M is a minimal model. Since M $ M ?C (D ,D ′), the model M contains the atom P(ā) iff P(ā) ∈ D .\nBy Lemma 4, there exists model M ′ such that DM ′ <D D′ and M ′ is a minimal model of Π(P,D)M ′ . By Lemma 3, DM ′ |=N C. This contradicts that D ′ is a neighborhood solution. 2\nProposition 2 If M is a stable model of Π(P,D), then DM is a neighborhood solution for D with respect to C. Proof: From Lemma 3, it holds DM |=N C. We have to prove that it is ≤D - minimal. Let us suppose there is a neighborhood solution D ′ (that satisfies C) with D ′ <D DM . From Proposition 1, M ?C (D ,D\n′) is a stable model of Π(P,D) and DM?C (D,D′) = D\n′ (we denote it simple with M ? in the rest of the proof). If D ′ <D DM , there is an atom P(ā) ∈ ∆(D ,DM ), with P(ā) /∈ ∆(D ,D ′), or there is an atom P(ā, b̄) ∈ ∆(D ,DM ), with ā ′, b̄ 6= null, and an atom P(ā, null) ∈ ∆(D ,D ′). We analyze both cases:\n1. P(ā) ∈ ∆(D ,DM ) and P(ā) 6∈ ∆(D ,D ′): Since P(ā) ∈ ∆(D ,DM ), P (ā, t) or P (ā, f) belong to M . By Lemma 1, there are two cases:"
    }, {
      "heading" : "76 L. Bertossi, L. Bravo",
      "text" : "(a) P(ā), P (ā, t?) and P (ā, f) belong to M , and no other P (ā, v), for v\nan annotation, belongs to M . P(ā), P (ā, t?) and P (ā, t??) belong to\nM ?, and, for any other annotation v , P (ā, v) /∈ M ?. (b) P (ā, t), P (ā, t?) and P (ā, t??) belong to M , and no other P (ā, v),\nfor v an annotation, belongs to M . No P (ā, v), for v an annotation, belongs to M ?.\nIf an atom belongs to a model M1, e.g. P (ā, f), and there is another model M2 in which it is not present, then there must be in M2 an atom annotated with t or f in order to satisfy the rule that was satisfied in M1 by P (ā, f). This implies that M ? has an atom annotated with t or f that does not belong to M . This implies that there is an atom that belongs to ∆(D ,D ′) and that does not belong to ∆(D ,DM ). We have reached a contradiction, because ∆(D ,D\n′) is a proper subset of ∆(D ,DM ). 2. P(ā, b̄) ∈ ∆(D ,DM ) and P(ā, null) ∈ ∆(D ,D ′): If P(ā, b̄) /∈ M , then P (ā, b̄, t) ∈ M , P(ā, null) /∈ M , P (ā, null, t) /∈ M . Since P(ā, null) ∈ ∆(D ,D ′) and P(ā, null) /∈ M , P (ā, null, t) ∈ M ?. Since P (ā, null, t) ∈ M ?, there must be a rule representing a RDEC in Π(D, C) such that P (ā, null, t) is the only true atom in the head. For that rule to be also satisfied by M , there must be another atom in the head of that rule\nthat is true in M but not in M ?. This means that there is a P(b̄) ∈ ∆(D ,DM ) and P(b̄) 6∈ ∆(D ,D ′), which brings us back to case 1. above. Again we obtain a contradiction.\nTherefore, it is not possible to have D ′ <D DM ; and DM is a neighborhood solution for D . 2"
    } ],
    "references" : [ {
      "title" : "Complex Preferences for Answer Set Optimization",
      "author" : [ "G. Brewka" ],
      "venue" : "Proc. International conference on Principles of Knowledge Representation and Reasoning. AAAI Press, 213–223.",
      "citeRegEx" : "Brewka,? 2004",
      "shortCiteRegEx" : "Brewka",
      "year" : 2004
    }, {
      "title" : "Enhancing Disjunctive Datalog by Constraints",
      "author" : [ "F. Buccafurri", "N. Leone", "P. Rullo" ],
      "venue" : "IEEE Transactions on Knowledge and Data Engineering 12, 5, 845–860.",
      "citeRegEx" : "Buccafurri et al\\.,? 2000",
      "shortCiteRegEx" : "Buccafurri et al\\.",
      "year" : 2000
    }, {
      "title" : "Minimal-Change Integrity Maintenance using Tuple Deletions",
      "author" : [ "J. Chomicki", "J. Marcinkowski" ],
      "venue" : "Information and Computation 197, 1-2, 90–121.",
      "citeRegEx" : "Chomicki and Marcinkowski,? 2005",
      "shortCiteRegEx" : "Chomicki and Marcinkowski",
      "year" : 2005
    }, {
      "title" : "Magic Sets and their Application to Data Integration",
      "author" : [ "W. Faber", "G. Greco", "N. Leone" ],
      "venue" : "Journal of Computer and System Sciences 73, 4, 584–609.",
      "citeRegEx" : "Faber et al\\.,? 2007",
      "shortCiteRegEx" : "Faber et al\\.",
      "year" : 2007
    }, {
      "title" : "Non-Determinism in Deductive Databases",
      "author" : [ "F. Giannotti", "D. Pedreschi", "D. Sacca", "C. Zaniolo" ],
      "venue" : "Proc. International Conference on Deductive and ObjectOriented Databases. Springer, LNCS 566, 129–146.",
      "citeRegEx" : "Giannotti et al\\.,? 1991",
      "shortCiteRegEx" : "Giannotti et al\\.",
      "year" : 1991
    }, {
      "title" : "Prolegomena for a Logic of Trust and Reputation",
      "author" : [ "A. Herzig", "E. Lorini", "J. Hubner", "J. Ben-Naim", "C. Castelfranchi", "R. Demolombe", "D. Longin", "L. Vercouter" ],
      "venue" : "Proc. Third International Workshop on Normative Multiagent Systems. 143–157.",
      "citeRegEx" : "Herzig et al\\.,? 2008",
      "shortCiteRegEx" : "Herzig et al\\.",
      "year" : 2008
    }, {
      "title" : "A Probabilistic Trust Model for Semantic Peer-to-Peer Systems",
      "author" : [ "G. Hien Nguyen", "P. Chatalic", "Rousset", "M.-C." ],
      "venue" : "Proc. European Conference on Artificial Intelligence. IOS Press, 881–882.",
      "citeRegEx" : "Nguyen et al\\.,? 2008",
      "shortCiteRegEx" : "Nguyen et al\\.",
      "year" : 2008
    }, {
      "title" : "Completeness in the Polynomial-Time Hierarchy: A Compendium",
      "author" : [ "M. Schaefer", "Umans", "Ch." ],
      "venue" : "SIGACT News.",
      "citeRegEx" : "Schaefer et al\\.,? 2008",
      "shortCiteRegEx" : "Schaefer et al\\.",
      "year" : 2008
    }, {
      "title" : "PeerTrust: Supporting Reputation-Based Trust for Peerto-Peer Electronic Communities",
      "author" : [ "L. Xiong", "L. Liu" ],
      "venue" : "IEEE Transactions of Knowledge and Data Engineering 16, 7, 843–857.",
      "citeRegEx" : "Xiong and Liu,? 2004",
      "shortCiteRegEx" : "Xiong and Liu",
      "year" : 2004
    }, {
      "title" : "Designing a Super-Peer Network",
      "author" : [ "B. Yang", "H. Garcia-Molina" ],
      "venue" : "Proc. International Conference on Data Engineering. IEEE Computer Society, 49.",
      "citeRegEx" : "Yang and Garcia.Molina,? 2003",
      "shortCiteRegEx" : "Yang and Garcia.Molina",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 3,
      "context" : "More specifically, techniques used in CQA, such as magic sets for stable model semantics (Faber et al. 2007), and identification of predicates that are relevant to queries and constraints, could also be used in this setting.",
      "startOffset" : 89,
      "endOffset" : 108
    } ],
    "year" : 2016,
    "abstractText" : "We propose and investigate a semantics for peer data exchange systems where different peers are related by data exchange constraints and trust relationships. These two elements plus the data at the peers’ sites and their local integrity constraints are made compatible via a semantics that characterizes sets of solution instances for the peers. They are the intended -possibly virtualinstances for a peer that are obtained through a data repair semantics that we introduce and investigate. The semantically correct answers from a peer to a query, the so-called peer consistent answers, are defined as those answers that are invariant under all its different solution instances. We show that solution instances can be specified as the models of logic programs with a stable model semantics. The repair semantics is based on null values as used in SQL databases, and is also of independent interest for repairs of single databases with respect to integrity constraints. To appear in Theory and Practice of Logic Programming (TPLP).",
    "creator" : "LaTeX with hyperref package"
  }
}