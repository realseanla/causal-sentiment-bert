{
  "name" : "1606.00339.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Christian Straßer" ],
    "emails" : [ "mathieu.beirlaen@rub.de,", "christian.strasser@rub.de." ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 6.\n00 33\n9v 1\n[ cs\n.A I]\nWe present a general formal argumentation system for dealing with the detachment of conditional obligations. Given a set of facts, constraints, and conditional obligations, we answer the question whether an unconditional obligation is detachable by considering reasons for and against its detachment. For the evaluation of arguments in favor of detaching obligations we use a Dung-style argumentation-theoretical semantics. We illustrate the modularity of the general framework by considering some extensions, and we compare the framework to some related approaches from the literature.\nKeywords : formal argumentation, ASPIC+, conditional norms, conflicting norms, prioritized norms, factual detachment, deontic detachment."
    }, {
      "heading" : "1 Introduction",
      "text" : "We take an argumentative perspective on the problem of detaching conditional obligations relative to a set of facts and constraints. We allow for the construction of arguments the deontic conclusions of which are candidates for detachment. Next, we define a number of ways in which these arguments may attack one another, as when the conclusions of two arguments are conflicting. We borrow Dung’s semantics [6] for evaluating arguments relative to the attack relations that hold between them. Conclusions of arguments which are evaluated positively are safely detachable in our framework. They can be interpreted as all-things-considered obligations – following Ross [28] – or output obligations – following Makinson & van der Torre [18, 19].\n∗The research of both authors was supported by a Sofja Kovalevskaja award of the Alexander von Humboldt-Foundation, funded by the German Ministry for Education and Research.\nThe argumentative approach defended in this paper is both natural and precise. Norms which guide reasoning are naturally construed as conclusions of proof sequences. Objections raised against the derivation of certain obligations are naturally construed as argumentative attacks. Arguments are naturally evaluated in terms of the objections raised against them.\nIn Section 2 we introduce a basic argumentation system for evaluating arguments the conclusions of which can be interpreted as all-things-considered obligations. This generic, modular framework can be extended in various ways, as we illustrate in Section 3. We show how various mechanisms for conflictresolution can be implemented (Section 3.1), and how we can rule out obligations committing us to further violations or conflicts (Section 3.2). In Section 4 we compare our approach to related systems from the literature. We end by pointing to some further expansions of our framework, which we aim to present in a follow-up paper (Section 5)."
    }, {
      "heading" : "2 The basic framework",
      "text" : "We start by reviewing the basic concepts needed from Dung’s semantics (Section 2.1). Next we turn to the construction of deontic arguments (Section 2.2) and attack definitions (Section 2.3). We define a consequence relation for detaching all-things-considered obligations in deontic argumentation frameworks (Section 2.4), and present some of its meta-theoretical properties (Section 2.5)."
    }, {
      "heading" : "2.1 Abstract argumentation",
      "text" : "A Dung-style abstract argumentation framework (AF) is a pair (A,Att) where A is a set of arguments and Att ⊆ A×A is a binary relation of attack. Relative to an AF, Dung defines a number of extensions – subsets of A – on the basis of which we can evaluate the arguments in A.\nDefinition 1 (Complete and grounded extension). Let (A,Att) be an AF. For any a ∈ A, a is acceptable w.r.t. some S ⊆ A (or, S defends a) iff for all b such that (b, a) ∈ Att there is a c ∈ S for which (c, b) ∈ Att. If S ⊆ A is conflict-free, i.e. there are no a, b ∈ S for which (a, b) ∈ Att, then:\n• S is a complete extension iff a ∈ S whenever a is acceptable w.r.t. S;\n• S is the grounded extension iff it is the set inclusion minimal complete extension.\nDung [6] showed that for every AF there is a grounded extension, it is unique, and it can be constructed as follows.\nDefinition 2 (Defense). A set of arguments X defends an argument a iff every attacker of a is attacked by some b ∈ X .\nDefinition 3 (Construction of the grounded extension). The grounded extension G relative to an AF (A,Att) is defined as follows (where A is countable):\n• G0: the set of all arguments in A without attackers;\n• Gi+1: all arguments defended by Gi; • G = ⋃\ni≥0 Gi\nBesides the grounded extension, a number of further extensions (preferred, (semi-)stable, ideal etc.) have been defined in the literature. Due to space limitations, we focus exclusively on grounded extensions in the remainder.\nOn Dung’s abstract approach [6], arguments are basic units of analysis the internal structure of which is not represented. But nothing prevents us from instantiating such abstract arguments by conceptualizing them as proof trees for deriving a conclusion based on a set of premises and inference rules. Frameworks with instantiated arguments are called structured argumentation frameworks (for examples, see e.g. [1]).1 In the remainder of Section 2 we show how questions regarding obligation detachment in deontic logic can be addressed and answered within structured deontic argumentation frameworks."
    }, {
      "heading" : "2.2 Instantiating deontic arguments",
      "text" : "Our formal language L is defined as follows:\nP := {p, q, r, . . .} L⇒ := 〈LP 〉 ⇒ 〈LP 〉 LP := P | ⊤ | ⊥ | ¬〈LP 〉 | 〈LP 〉 ∨ 〈LP 〉 LO := O〈LP 〉 L := 〈LP 〉 | 〈LP 〉 | ¬〈L 〉 | 〈L 〉 ∨ 〈L 〉 L := LP | L | L⇒ | LO\nThe classical connectives ∧,⊃,≡ are defined in terms of ¬ and ∨. We represent facts as members of LP . Where A,B ∈ LP , conditional obligations are formulas of the form A ⇒ B, read ‘If A, then it – prima facie – ought to be that B’ or ‘If A, then B is prima facie obligatory’.2 Where A ∈ LP , a constraint A abbreviates that A is settled, i.e. that A holds unalterably.3 Formulas of the form OA (where A ∈ LP ) represent all-things-considered obligations.\nUnless specified otherwise, upper case letters A,B, . . . denote members of LP and upper case Greek letters Γ,∆, . . . denote subsets of LP ∪ L ∪ L⇒. Where Γ ⊆ L and † ∈ {P, ,⇒,O}, Γ† = Γ ∩ L†.\nCn CL (Γ) denotes the closure of Γ ⊆ LP under propositional classical logic, CL. Cn\nL (Γ) denotes the closure of Γ ⊆ L under L , which we use as a\n1Our approach is similar in spirit to the ASPIC+ framework for structured argumentation from e.g. [20]. We return to this point in Section 4.2.\n2Depending on the context of application, the following alternative readings are also fine: ‘If A is the case, then B is pro tanto obligatory’, ‘If A, then the agent ought (prima facie, pro tanto) to bring about B’. On the latter, agentive reading, we can think of ‘⇒’ as implicitly indexed by an agent.\n3If A holds, then the fact that A is deemed fixed, necessary, and unalterable. Obligations which contradict these facts are unalterably violated. Carmo & Jones cite three factors giving rise to such unalterable violations. The first is time, e.g. when you did not return a book you ought to have returned by its due date. The second is causal necessity, e.g. when you killed a person you ought not to have killed. The third is practical impossibility, e.g. when a dog owner stubbornly refuses to keep her dog against the house regulations, and nobody else dares to try and convince her to remove it [4, pp. 283-284].\ngeneric name for a modal logic for representing background constraints, e.g. T, S4, S5, etc. In our examples below, we will assume that L is normal and validates the axiom A ⊃ A.4\nArguments are ordered pairs 〈A : s〉 in which A is called the conclusion, and s a proof sequence for deriving A. We use lower case letters a, b, c, . . . as placeholders for arguments.\nDefinition 4. Given a premise set Γ, we allow the following rules for constructing arguments:\n(i) If A ∈ Cn L (Γ), then 〈 A : −−〉 is an argument; (where −− denotes the empty proof sequence)\n(ii) If A ⇒ B ∈ Γ⇒ and A ∈ Cn L (Γ), then 〈OB : A,A ⇒ B〉 is an argument;\n(iii) If A ⇒ B ∈ Γ⇒ and a = 〈OA : . . .〉 is an argument, then 〈OB : a,A ⇒ B〉 is an argument;\n(iv) If a = 〈OA : . . .〉 and b = 〈OB : . . .〉 are arguments, then 〈O(A ∧B) : a, b〉 is an argument.\n(v) If a = 〈OA : . . .〉 is an argument and (A ⊃ B) ∈ Cn L (Γ), then 〈OB : a, (A ⊃ B)〉 is an argument.\nArgument a is a deontic argument if a is of the form 〈OA : . . .〉. We use C(a) to denote the set of all formulas in L used in the construction of a, including its conclusion. E.g. where a = 〈Oq : p, p ⇒ q〉 and b = 〈Or : a, q ⇒ r〉, C(a) = {p, p ⇒ q,Oq} and C(b) = {p, p ⇒ q,Oq, q ⇒ r,Or}. Argument a is a sub-argument of argument b if C(a) ⊆ C(b); a is a proper sub-argument of argument b if C(a) ⊂ C(b); and b is a super-argument of argument a if a is a proper sub-argument of b.\n(ii)-(v) correspond to inference rules well-known from deontic logic. (ii) allows for the factual detachment of an all-things-considered obligation OB from a conditional prima facie obligation A ⇒ B and a fact A. (iii) is a deontic detachment principle. (iv) and (v) allow for obligation aggregation (or agglomeration), resp. inheritance (or weakening).\nExample 1 (Constructing arguments). Let Γ1 = { p,⊤ ⇒ ¬p,¬p ⇒ ¬q, p ⇒ q}. By Definition 4 we can construct – amongst others – the following arguments from Γ1:\na1: 〈 p : −−〉 a4: 〈Oq : p, p ⇒ q〉 a2: 〈O¬p : ⊤,⊤ ⇒ ¬p〉 a5: 〈O(¬q ∧ q) : a3, a4〉 a3: 〈O¬q : a2,¬p ⇒ ¬q〉 a6: 〈O(q ∨ r) : a4, (q ⊃ (q ∨ r))〉\nArgument a1 is constructed from p ∈ Γ1 in view of (i). Arguments a2 and a4 are constructed by means of (ii)\n5; a3 is constructed from a2 by means of (iii); a5 is constructed from a3 and a4 by (iv); and a6 is constructed from a4 by (v).\n4Moreover, where ∆⇒ ⊆ L⇒, we assume that Γ ⊢ L A iff Γ ∪∆⇒ ⊢ L A. 5Note that, in the construction of argument a4, the formula p follows from Γ1 by p and\nsince ⊢ L p ⊃ p.\nWe can interpret Γ1 as representing a classic contrary-to-duty (CTD) scenario (for the sake of readability, we omit the qualifier ‘prima facie’ in our reading of conditional obligations):6\n⊤ ⇒ ¬p There ought not be a dog. ¬p ⇒ ¬q If there is no dog, there ought not be a warning sign. p ⇒ q If there is a dog, there ought to be a warning sign. p It is settled that there is a dog.\nOf course, not all of the conclusions of arguments a2-a6 qualify as all-thingsconsidered obligations. Argument a5, for instance, is internally incoherent and should be filtered out when evaluating the arguments constructed from Γ1. Arguments are evaluated in terms of the attack relations which hold amongst them. Before we turn to the definition of these relations, we point out that rules (i)-(v) in Definition 4 allow for a version of the necessitation rule whenever L is a normal modal logic. For instance, given a premise set { p,⊤ ⇒ q}, we can construct the argument a1 = 〈Oq : ⊤,⊤ ⇒ q〉 by (ii). Since p ⊢L (q ⊃ p), we can construct the argument a2 = 〈Op : a1, (q ⊃ p)〉 by (v). If desired, the construction of a2 can be prevented by defining – in addition to ‘⊃’ – a weaker (non-material) implication connective in L on the basis of which to construct arguments in line with clause (v) in Definition 4."
    }, {
      "heading" : "2.3 Attacking deontic arguments",
      "text" : "In our basic framework, we define two ways in which arguments may attack one another. First, we take care that unalterably violated obligations are attacked by the constraints which violate them. (We write A = −B in case A = ¬B or B = ¬A.)\nDefinition 5 (Fact attack). Where a = 〈OA : . . .〉 is an argument, let UO(a) = {B | OB ∈ C(a)}. Where ∅ 6= Θ ⊆ UO(a), 〈 − ∧ Θ : −−〉 attacks a.\nIn Example 1 the obligation O¬p cannot guide the agent’s actions, since it cannot be acted upon in view of the constraint p. Definition 5 takes care that a1 attacks a2, since UO(b) = {¬p}. Note that, as soon as A ∈ UO(a) for some argument a and formula A, A ∈ UO(b) for any super-argument b of a. Consequently, if an argument c attacks a in view of Definition 5, then c also attacks all super-arguments b of a. So in Example 1 the argument a1 attacks a2 as well as its super-arguments a3 and a5.\nSince we assume that L is a normal modal logic, we know that (¬(¬q ∧ q)) ∈ Cn\nL (Γ1). Hence, by Definition 5 again, argument a7 = 〈 (¬(¬q ∧ q)) :\n−−〉 attacks argument a5 from Example 1.\nExample 2 (Attacks on incoherent arguments). Let Γ2 = {⊤ ⇒ p,⊤ ⇒ ¬p,⊤ ⇒ q}. We construct the following arguments on the basis of Γ2:\na1: 〈Op : ⊤,⊤ ⇒ p〉 a4: 〈O(p ∨ ¬q) : a1, (p ⊃ (p ∨ ¬q))〉 a2: 〈O¬p : ⊤,⊤ ⇒ ¬p〉 a5: 〈O(¬p ∧ (p ∨ ¬q) : a2, a4〉 a3: 〈Oq : ⊤,⊤ ⇒ q〉 a6: 〈O¬q : a5, ((¬p ∧ (p ∨ ¬q)) ⊃ ¬q)〉\n6The example is adapted from [27].\nBy Definition 5:\nUO(a5) = {p, p ∨ ¬q,¬p,¬p ∧ (p ∨ ¬q)} UO(a6) = {p, p ∨ ¬q,¬p,¬p ∧ (p ∨ ¬q),¬q}\nHence, both a5 and a6 are attacked by a7:\na7 = 〈 ¬(p ∧ ¬p) : −−〉\nArguments a5 and a6 are incoherent in the sense that in constructing them we relied on arguments the conclusions of which are conflicting (namely a1 and a2). It is vital that we are able to filter out such incoherent arguments. Definition 5 takes care of that. By attacking a6, argument a7 protects (defends) the unproblematic a3, which is attacked by a6 in view of Definition 6 below. We return to this point in footnote 8, after we explained how arguments are evaluated.\nThe second type of attack relation ensures that mutually incompatible obligations attack each other:\nDefinition 6 (Conflict attack). a = 〈O−A : . . .〉 attacks b = 〈OA : . . .〉, and a attacks all of b’s super-arguments.\nIn Example 1, arguments a3 and a4 attack each other according to Definition 6. Moreover, a3 attacks a5 and a6; and a4 attacks a5. Likewise, in Example 2, a1 and a2 attack each other, and so do a3 and a6. Moreover, a1 attacks a5 and a6; and a2 attacks a4, a5, and a6.\nExample 3 (Conflict attack). Let Γ3 = {p, q, p ⇒ r, (p ∧ q) ⇒ s, ¬(r ∧ s)}. We construct the following arguments on the basis of Γ3:\na1: 〈Or : p, p ⇒ r〉 a4: 〈 ¬(r ∧ s) : −−〉 a2: 〈Os : p ∧ q, (p ∧ q) ⇒ s〉 a5: 〈O¬r : a2, (s ⊃ ¬r)〉 a3: 〈O(r ∧ s) : a1, a2〉 a6: 〈O¬s : a1, (r ⊃ ¬s)〉\na4 attacks a3 by Definition 5. By Definition 6 a1 attacks a5; a5 attacks a1, a3, and a6; a2 attacks a6; and a6 attacks a2, a3, and a5."
    }, {
      "heading" : "2.4 Evaluating deontic arguments",
      "text" : "For the evaluation of deontic arguments relative to a premise set, we extend Dung-style AFs to deontic argumentation frameworks, and we borrow Dung’s argument evaluation mechanism from Definitions 1-3:\nDefinition 7 (DAF). The deontic argumentation framework (DAF) for Γ ⊆ LP ∪ L ∪ L⇒ is an ordered pair 〈A(Γ),Att(Γ)〉 where\n• A(Γ) is the set of arguments constructed from Γ in line with Definition 4; and\n• where a, b ∈ A(Γ): (a, b) ∈ Att(Γ) iff a attacks b according to Definition 5 or Definition 6.\nLike AFs, DAFs can be represented as directed graphs. Here, for instance, is a graph depicting the arguments we constructed on the basis of Γ1: 7\nNodes in the graph represent the arguments constructed on the basis of Γ1 in Example 1. Below the arguments’ names, we stated their conclusions. Arrows represent attacks. Dotted lines represent sub-argument relations.\nWe evaluate arguments in a DAF using Dung’s grounded semantics from Section 2.1: In Definition 1, replace A (resp. Att) with A(Γ) (resp. Att(Γ)). Similarly for Definition 3, where we also replace occurrences of G and Gi with G(Γ) and Gi(Γ) respectively.\nLet us now apply Definition 3 to Example 1. Clearly, a1, a7 ∈ G0(Γ1), since Definitions 5 and 6 provide us with no means to attack arguments the conclusions of which are members of Γ 1 . In the next step of our construction, a4, a6 ∈ G1(Γ1), since they are defended by a1 ∈ G0(Γ1). a2, a3, a5 6∈ G1(Γ1), since each of these arguments is attacked by a1 (hence undefended).\nWe cannot construct any further arguments which attack a4 or a6 and which do not contain any of the undefended arguments a2 or a3 as sub-arguments. Moreover, we show in the Appendix (Lemma 2) that, for any premise set Γ, if a ∈ G(Γ), then a ∈ G1(Γ). By the Definition 3, a1, a4, a6, a7 ∈ G(Γ1) while a2, a3, a5 6∈ G(Γ1).\nDefinition 8 (DAF-consequence). Where Γ ⊆ LP ∪ L ∪ L⇒ and A ∈ LP , Γ ⊢DAF OA iff there is an argument a ∈ G(Γ) with conclusion OA.\nBy Definition 8, Γ1 ⊢DAF Oq and Γ1 ⊢DAF O(q ∨ r), while Γ1 6⊢DAF O¬p and Γ1 6⊢DAF O¬q. In Example 2, Γ2 ⊢DAF Oq.\n8 We leave it to the reader to check that none of Op,O¬p,O(p ∨ ¬q), or O¬q is a DAF-consequence of Γ2, and that none of Or,Os,O(r ∧ s),O¬r, or O¬s is a DAF-consequence of Γ3.\n7Due to space limitations, we leave it to the reader to construct similar graphs for the other examples in this paper.\n8 The conclusion Oq of argument a3 in Example 2 is accepted despite its being attacked by a6. The reason is that a6 is in turn attacked by a7, so that a7 defends a3 from the attack by a6."
    }, {
      "heading" : "2.5 Rationality postulates",
      "text" : "In [3, Sec. 4] the properties of output closure and output consistency were proposed as desiderata for well-behaved argumentation systems. WhereOutput(Γ) = {A | Γ ⊢DAF OA}:\nProperty 1 (Closure). Output(Γ) = CnCL(Output(Γ)).\nProperty 2 (Consistency). CnCL(Output(Γ)) is consistent.\nProperties 1 and 2 follow for DAF in view of resp. Theorems 1 and 2 in the Appendix. Property 3 is proven in Theorem 3 in the Appendix:\nProperty 3 (Cautious cut/cumulative transitivity). Let ∆⇒ = {⊤ ⇒ A | A ∈ ∆}. If Γ ⊢DAF OA for all A ∈ ∆ and Γ ∪∆⇒ ⊢DAF OB, then Γ ⊢DAF OB.\nProperties 4 and 5 fail for DAF:\nProperty 4 (Cautious monotonicity). If Γ ⊢DAF OA and Γ ⊢DAF OB, then Γ ∪ {⊤ ⇒ A} ⊢DAF OB.\nProperty 5 (Rational monotonicity). If Γ ⊢DAF OA and Γ 6⊢DAF O¬B, then Γ ∪ {⊤ ⇒ B} ⊢DAF OA\nExample 4 (Failure of properties 4 and 5, adapted from [2]). Let Γ4 = {p, p ⇒ q, q ⇒ r, r ⇒ ¬q,¬q ⇒ s,⊤ ⇒ ¬s}. We construct the following arguments on the basis of Γ4:\na1: 〈Oq : p, p ⇒ q〉 a4: 〈Os : a3,¬q ⇒ s〉 a2: 〈Or : a1, q ⇒ r〉 a5: 〈O¬s : ⊤,⊤ ⇒ ¬s〉 a3: 〈O¬q : a2, r ⇒ ¬q〉 a6: 〈 ¬(q ∧ ¬q) : −−〉\nBy Definition 6: a1 attacks a3 and a4; a3 attacks all of a1-a4 (including itself); and a4 and a5 attack each other. By Definition 5, a6 attacks a3 and a4, since both q and ¬q are members of UO(a3) and UO(a4). As a result, Oq,Or, and O¬s are DAF-consequences of Γ4, while O¬q and Os are not.\nNow add the new conditional obligation ⊤ ⇒ r to Γ4, so that we obtain the new arguments\na7: 〈Or : ⊤,⊤ ⇒ r〉 a9: 〈Os : a8,¬q ⇒ s〉 a8: 〈O¬q : a7, r ⇒ ¬q〉\nNone of these new arguments is attacked by a6, which defends a1 and a5 from the attacks by a3 and a4 respectively. By Definition 6, a8 and a1 attack each other. So do a9 and a5. As a result, none of a1, a5, a8, and a9 is in the grounded extension of Γ4∪{⊤ ⇒ r}. So we have a counter-example to Property 4: Γ4 ⊢DAF Or and Γ4 ⊢DAF O¬s, while Γ4 ∪ {⊤ ⇒ r} 6⊢DAF O¬s.\nThis example also serves to illustrate the failure of Property 5 for DAF. Arguments with conclusion O¬r can be constructed on the basis of Γ4 only on the basis of incoherent arguments. Let, for instance:\na10: 〈O(q ∧ ¬q) : a1, a3〉 a11: 〈O¬r : a10, ((q ∧ ¬q) ⊃ ¬r)〉\nIn view of Definition 5, arguments constructed on an incoherent basis are attacked by an otherwise unattacked argument. For instance, a11 is attacked by the unattacked argument a6. Because of this, Γ4 6⊢DAF O¬r. But then, since Γ4 ⊢DAF O¬s and Γ4 ∪ {⊤ ⇒ r} 6⊢DAF O¬s, Property 5 fails for DAF."
    }, {
      "heading" : "3 Beyond the basics",
      "text" : ""
    }, {
      "heading" : "3.1 Conflict-resolution",
      "text" : ""
    }, {
      "heading" : "3.1.1 Resolving conflicts via logical analysis",
      "text" : "It has been argued that, in cases of conflict, more specific obligations should be given precedence over less specific ones.9 Consider the following example:\nExample 5 (Specificity). Let Γ5 = {q, r, q ⇒ p, (q∧r) ⇒ ¬p}. We can interpret Γ5 as representing a scenario in which an agent is making carrot soup. Let p, q, and, respectively, r abbreviate ‘there is fennel’, ‘there are carrots’, and ‘there is celery’. If there are carrots in the garden still, our agent should take care that he buys fennel in order to make the soup (q ⇒ p). However, if both carrots and celery are in the garden, he should not get fennel ((q ∧ r) ⇒ ¬p), because celery can be used instead of fennel. As it turns out, both carrots and celery are in his garden (q, r). The desirable outcome in this case is that the agent ought not go out and buy fennel.\nA principled way of obtaining outcomes in which more specific obligations are preferred over less specific ones, is to define specificity in terms of logical strength, and to define a new attack relation for letting more specific arguments attack less specific ones. Let the factual support of a deontic argument a be the set S(a) = {B | B ∈ (C(a) ∩ LP )}.\nWe write S(a) ⊑ S(b) iff for all A ∈ S(a) there is a B ∈ S(b) such that A ⊢ B and for all B ∈ S(b) there is an A ∈ S(a) such that A ⊢ B. S(a) ⊏ S(b) (a is more specific than b) iff S(a) ⊑ S(b) and S(b) 6⊑ S(a).\nWe replace Definition 6 with Definition 9:\nDefinition 9 (Conflict attack w/specificity). Let a = 〈O−A : . . .〉 and b = 〈OA : . . .〉.\n(i) If S(a) ⊏ S(b), then a attacks b and all of b’s super-arguments,\n(ii) b attacks a and all of a’s super-arguments, unless a attacks b in view of clause (i).\nLet DAFs (with subscript ‘s’ for specificity) be the logic resulting from constructing the attack relation Att on the basis of Definitions 5 and 9.\nIn Example 5, we construct the following arguments from Γ5:\n9Understood in this way, specificity cases have been studied extensively in the fields of non-monotonic logic (see e.g. [7, 5]) and deontic logic (see e.g. [4, 27, 30, 31]).\na1: 〈Op : q, q ⇒ p〉 a2: 〈O¬p : q ∧ r, (q ∧ r) ⇒ ¬p〉\nSince S(a2) ⊏ S(a1), a2 attacks a1 by Definition 9, but not vice versa. As a result, only a2 is in Γ5’s grounded extension, and Γ5 ⊢DAFs O¬p, while Γ5 6⊢DAFs Op.\nIn Example 3, the factual support of the arguments constructed from Γ3 is such that S(a2) = S(a5) ⊏ S(a1) = S(a6). By Definition 9, a5 attacks a1 and a2 attacks a6. As a result, the more specific arguments a2 and a5 defeat the less specific a1 and a6, so that Γ3 ⊢DAFs Os and Γ3 ⊢DAFs O¬r, while Γ3 6⊢DAFs Or and Γ3 6⊢DAFs O¬s. As before, Γ3 6⊢DAFs O(r ∧ s).\nIn dealing with conflict-resolution via logical analysis, we have chosen for a cautious notion of specificity. For instance, {p} 6⊏ {p, q} and {p} 6⊏ {p∧q, r}. In certain contexts it may be sensible to opt for a stronger characterization of ‘⊏’. A detailed discussion of such issues would lead us too far astray given our present purposes. Instead, we point out that our framework readily accommodates alternative characterizations of ‘⊏’ to be used in Definition 9."
    }, {
      "heading" : "3.1.2 Resolving conflicts via priorities",
      "text" : "Instead of (or in combination with) conflict-resolution via logical analysis, a priority ordering ≤ can be introduced over conditional norms, and our formal language can be adjusted accordingly. Conditional norms then come with an associated degree of priority α ∈ Z+, written A ⇒α B (higher numbers denote higher priorities).\nWe lift ≤ to a priority ordering over arguments via the weakest link principle: an argument is only as strong as the weakest priority conditional used in its construction [25]. Let Pr(∆) = {α | A ⇒α B ∈ ∆} and let min(Pr(∆)) be the lowest α ∈ Pr(∆). Then ∆ ∆′ iff min(Pr(∆)) ≤ min(Pr(∆′)). Relative to a premise set Γ, we write a b iff C(a) ∩ Γ⇒ C(b) ∩ Γ⇒. a ≺ b iff a b and b 6 a.\nWe replace Definition 6 with the following definition:\nDefinition 10 (Prioritized conflict attack). If a 6≺ b, then a = 〈O−A : . . .〉 attacks b = 〈OA : . . .〉 and all of b’s super-arguments.\nLet DAF≤ be the logic resulting from constructing the attack relation Att on the basis of Definitions 5 and 10.\nExample 6 (Prioritized conflict attack). Let Γ6 = {p, q, r, ¬(s ∧ t ∧ u), p ⇒1 s, q ⇒2 t, r ⇒3 u}. We construct the following arguments on the basis of Γ6:\na1: 〈 ¬(s ∧ t ∧ u) : −−〉 a8: 〈O(s ∧ t ∧ u) : a4, a5〉 a2: 〈Os : p, p ⇒1 s〉 a9: 〈O¬(t ∧ u) : a2, (s ⊃ ¬(t ∧ u))〉 a3: 〈Ot : q, q ⇒2 t〉 a10: 〈O¬(s ∧ u) : a3, (t ⊃ ¬(s ∧ u))〉 a4: 〈Ou : r, r ⇒3 u〉 a11: 〈O¬(s ∧ t) : a4, (u ⊃ ¬(s ∧ t))〉 a5: 〈O(s ∧ t) : a2, a3〉 a12: 〈O¬u : a5, ((s ∧ t) ⊃ ¬u)〉 a6: 〈O(s ∧ u) : a2, a4〉 a13: 〈O¬t : a6, ((s ∧ u) ⊃ ¬t)〉 a7: 〈O(t ∧ u) : a3, a4〉 a14: 〈O¬s : a7, ((t ∧ u) ⊃ ¬s)〉\nThe order of arguments is such that a2, a5, a6, a8, a9, a12, a13 ≺ a3, a7, a10, a14 ≺ a4, a11. By Definition 10, a14 attacks a2, a5, a6, a8, a9, a12, and a13; a3 attacks a13; a4 attacks a12; a11 attacks a5, a8, and a12; a10 attacks a6 and a13; and a7 attacks a9. By Definition 5, a1 attacks a8. As a result, a1, a3, a4, a7, a10, a11, a14 ∈ G(Γ6), while a2, a5, a6, a8, a9, a12, a13 6∈ G(Γ6). The following obligations are DAF≤-consequences of Γ6 : Ot,Ou,O(t ∧ u),O¬(s ∧ u),O¬(s ∧ t),O¬s. The following obligations are not DAF≤-derivable from Γ6 : Os,O(s ∧ t),O(s ∧ u),O(s ∧ t ∧ u),O¬(t ∧ u),O¬u,O¬t.\nAs with ‘⊏’ in Definition 9, there are other ways of characterizing ‘≺’ in Definition 10. For instance, instead of lifting ≤ via the weakest link principle, we could lift it via the strongest link principle, according to which an argument is as strong as the strongest priority conditional used in its construction.10 Depending on the way ≤ is lifted to , different outcomes are possible with respect to the priority puzzles studied in e.g. [9, 14, 15]. A thorough investigation of these puzzles within our framework is left for an extended version of this paper."
    }, {
      "heading" : "3.2 Anticipating violations and conflicts",
      "text" : "Obligations which are violated or conflicted should not be detached. But what about obligations that commit us to violations or conflicts? Consider the following example, adapted from [16, 19].\nExample 7. Let Γ7 = {p, p ⇒ q, q ⇒ r, r ⇒ ¬p}. We construct the following arguments on the basis of Γ7:\na1: 〈 p : −−〉 a3: 〈Or : a2, q ⇒ r〉 a2: 〈Oq : p, p ⇒ q〉 a4: 〈O¬p : a3, r ⇒ ¬p〉\nSuppose you are throwing a party. Let p (resp. q, r) abbreviate ‘Peggy (resp. Quincy, Ruth) is invited to the party’. If Peggy is invited, then Quincy should be invited as well (perhaps because they are good friends and we know both of them). Likewise, if Quincy is invited then Ruth should be invited as well. But if Ruth is invited, then Peggy should not be (perhaps because we know Ruth and Peggy do not get along well). It is settled that Peggy is invited. You already sent her the official invitation, and it would be too awkward to tell her she can’t come. Should Quincy and/or Ruth be invited?\nArguments a1, a2, and a3 are in Γ7’s grounded extension G(Γ7). a4 is not in G(Γ7) since it is attacked by a1 according to Definition 5; consequently, Γ7 ⊢DAF Oq and Γ7 ⊢DAF Or, while Γ7 6⊢DAF O¬p.\nA more cautious reasoner may argue that Oq and Or should not be detached, since they lead to a commitment to O¬p: they form part of the detachment chain\n10If the strongest link principle is used, Definition 10 should no longer allow for attacks on super-arguments, since a 6≺ b no longer warrants that a 6≺ c where c is a super-argument of b. A further alternative is to use the last link principle, according to which an argument gets the priority of the conditional which occurs last in its proof sequence.\nof a4. This commitment reflects very badly on arguments a2 and a3, since O¬p is violated.\nTo model this behavior, we introduce the deontic doubt operator ⊙. We will use this operator to construct new arguments, called shadow arguments, the conclusion of which is of the form ⊙A. A shadow argument with conclusion ⊙A casts doubt on – and attacks – arguments with conclusion OA. Shadow arguments cannot be used to support obligations, but only to attack other arguments. They can only rule out deontic arguments. They cannot generate new consequences.11\nIn the resulting system DAF⊙, our language L is adjusted so as to include members of P within the scope of the new operator ⊙. Arguments are constructed in line with Definition 11:\nDefinition 11. Given a premise set Γ, we allow rules (i)-(vii) for constructing arguments, where (i)-(v) are the rules from Definition 4:\n(vi) If a = 〈 A : −−〉 is an argument, then 〈⊙−A : a〉 is an argument;\n(vii) If a = 〈OA : . . .〉 is an argument, then 〈⊙−A : a〉 is an argument.\nWe say that an argument a has minimal support if there is no argument b with the same conclusion such that C(b) ⊂ C(a). In DAF⊙ the attack relation is constructed on the basis of Definition 12:12\nDefinition 12 (Shadow attack). Where a = 〈OA : . . .〉 has minimal support:\n(i) Where b is a deontic sub-argument of a, 〈⊙A : . . .〉 attacks b as well as all of b’s super-arguments,\n(ii) Where b is a deontic sub-argument of a and ∅ 6= Θ ⊆ UO(a), 〈⊙ ∧ Θ : . . .〉\nattacks b as well as all of b’s super-arguments.\nReconsider Γ7 from Example 7. From a1, we can construct the shadow argument a5 = 〈⊙¬p : a1〉. By clause (i) of Definition 12, a5 attacks a4, a3, and a2. As a result, a2 and a3 are no longer in G(Γ7). Γ7 6⊢DAF⊙ Oq and Γ7 6⊢DAF⊙ Or.\nExample 8. Let Γ8 = { s,⊤ ⇒ p,⊤ ⇒ q, (p ∧ q) ⇒ r, r ⇒ ¬s, q ⇒ t}. We construct the following arguments on the basis of Γ8:\n11Shadow arguments are similar in spirit to Caminada’s HY-arguments from [2]. An HYargument a is an incoherent argument constructed on the basis of the conclusion of another argument b. Since a shows that b leads to incoherence, b’s conclusion is attacked by the HYargument a. Caminada shows how in the presence of HY-arguments, the property of cautious monotonicity may be restored for AFs. The same holds true for shadow arguments in our setting (cfr. infra). As Caminada’s construction is defined within a framework consisting only of literals and (defeasible) rules relating (conjunctions of) literals, we cannot employ it in our setting.\n12By the construction of Definition 12, Definitions 5 and 6 become redundant in DAF⊙. All cases covered by these definitions are covered already by Definition 12.\na1: 〈 s : −−〉 a5: 〈Or : a4, (p ∧ q) ⇒ r〉 a2: 〈Op : ⊤,⊤ ⇒ p〉 a6: 〈O¬s : a5, r ⇒ ¬s〉 a3: 〈Oq : ⊤,⊤ ⇒ q〉 a7: 〈Ot : a3, q ⇒ t〉 a4: 〈O(p ∧ q) : a2, a3〉 a8: 〈⊙¬s : a1〉\nBy Definition 12 the shadow argument a8 attacks a6 as well as its subarguments a2−a5. Moreover, it attacks a7, which is a super-argument of a3. As a result, none of the conclusions of arguments a2-a7 are DAF⊙-consequences of Γ8.\nExample 4 no longer serves as a counter-example to properties 4 and 5 provided in Section 2.5. We can construct the shadow argument a12 : 〈⊙s : a5〉. By clause (i) of Definition 12, this argument attacks a4 as well as its subarguments a1-a3. As a result of this attack, Γ4 6⊢DAF⊙ Oq and Γ4 6⊢DAF⊙ Or. More generally, we can show that the cautious monotonicity property (Property 4 in Section 2.5) holds for DAF⊙. A proof is provided in Theorem 4 of the Appendix.\nInstead of – and equivalently to – working with the ⊙-operator and Definitions 11 and 12, we could have generalized Definitions 5 and 6 so as to include attacks on sub-arguments. Definitions 5 and 6 currently entail that if a attacks b, then a attacks all super-arguments of b. In the generalized form, these definitions would entail that if a attacks b, then a attacks all superarguments of all sub-arguments of b.\nThere are two additional reasons for working with the doubt operator ⊙, however. First, this operator has a clear and intuitive meaning, and adds expressivity to our argumentation frameworks. Second, by characterizing shadow arguments via a separate operator we can think more transparently about (a) the implementation of additional logical properties of this operator, and (b) alternatives to Definition 12. Regarding (a), think about the strengthening rule (‘If ⊙A, then ⊙B whenever B ⊢ A’), which carries some intuitive force. Regarding (b), reconsider Example 8, and suppose we add the premise ⊤ ⇒ ¬p to Γ8. A not-so-skeptical reasoner may argue that in this case we should not be able to cast doubt on the arguments a3 and a7, since the doubt casted on argument a4 arguably arises in view of the conflicted conditional obligation to see to it that p.13"
    }, {
      "heading" : "4 Related work",
      "text" : "Due to space limitations, we restrict our discussion of related formalisms to those of input/output logic (Section 4.1) and those based on formal argumentation frameworks (Section 4.2). A comparison with other related deontic systems, such as Nute’s defeasible deontic logic [22, 21] and Horty’s default-based deontic logic [13, 10, 11, 15] is left for an extended version of this article.\n13Caminada’s HY-arguments from [2] are similar in spirit to this less skeptical proposal."
    }, {
      "heading" : "4.1 Input/output logic",
      "text" : "Like the constrained input/output (I/O) logics from [19], the DAFs defined here are tools for detaching conditional obligations relative to a set of inputs and constraints. Unlike most I/O logics, none of these DAFs validates strengthening of the antecedent (SA) for conditional obligations – from A ⇒ C to infer (A ∧ B) ⇒ C. Unrestricted (SA) is counter-intuitive if we allow for conflict-resolution via logical analysis as defined Section 3.1.1, since it allows the unrestricted derivation of more specific from less specific conditional obligations.14\nExample 9 (DAF and I/O logic). Let Γ9 = {p, p ⇒ q, p ⇒ ¬r, q ⇒ r}. We construct the following arguments on the basis of Γ9:\na1: 〈Oq : p, p ⇒ q〉 a3: 〈Or : a1, q ⇒ r〉 a2 〈O¬r : p, p ⇒ ¬r〉\nSince a2 and a3 attack each other in view of Definition 6, a2, a3 6∈ G(Γ9), while a1 ∈ G(Γ9). Consequently, Γ9 6⊢DAF Or and Γ9 6⊢DAF O¬r while Γ9 ⊢DAF Oq.\nIn constrained I/O logic, triggered conditional obligations in the input are divided into maximally consistent subsets (MCSs). Γ⇒9 has three MCSs: {p ⇒ q, q ⇒ ¬r}, {p ⇒ q, p ⇒ r}, and {q ⇒ ¬r, p ⇒ r}. In [19] two ways are presented for dealing with conflicts and constraints: via a full meet operation on the generated MCSs, or via a full join operation on the generated MCSs. The first approach gives us none of q, r, and ¬r for Γ9. The second gives us all three.\nSome of the I/O logics defined in e.g. [18, 19, 24] validate intuitively appealing rules which are not generally valid in our DAFs, such as the rule (OR) – from A ⇒ C and B ⇒ C to infer (A ∨B) ⇒ C. A detailed study of the appeal and implementation of (OR) and similar rules in the present argumentative setting is left for future investigation."
    }, {
      "heading" : "4.2 Formal argumentation",
      "text" : "Several ways of modeling normative reasoning on the basis of formal argumentation have been proposed in the literature. For instance, the approach in [8] is based on bipolar abstract argumentation frameworks. Dung’s abstract argumentation frameworks are enriched with a support relation that is defined over the set of abstract arguments. This device is used to express deontic conditionals. A similar idea is used in [23] where a relation for evidential support is introduced. Argumentation schemes of normative reasoning are there expressed by means of Prolog-like predicates and subsequently translated into an argumentation framework. Here, we follow the tradition of structured or instantiated argumentation in which no support relation between arguments is needed. In our approach conditional obligations are modeled by a dyadic operator ⇒ that\n14In [29] an I/O system is presented which invalidates (SA) in the context of exempted permissions which are subject to conflict-resolution via logical analysis (specificity).\nis part of the object language. Arguments consist of sequences of applications of factual and deontic detachment. As a consequence, for instance, evidential or factual support is an intrinsic feature of our arguments and is modeled via the factual detachment rule.\nThe general setting of our DAFs is close to ASPIC+. For instance, in the dynamic legal argumentation systems (in short, DLAS) from [26], deontic conditionals are also modeled via a defeasible conditional in the object language. There are several differences to our approach. For instance, our conditionals are not restricted to conjunctions of literals as antecedents. As a consequence we needed to define a strong fact attack rule (Def. 5) that, in order to avoid contamination problems (see Ex. 2), warrants that arguments with inconsistent supports are defeated.15 Our fact attack and our shadow attack rules do not conform to the standard attack types defined in ASPIC+ (rebutting, undercutting, and undermining). Our conflict attacks can be seen as forms of ASPIC+-type rebuttals where the contrary of OA is defined by O¬A.\nUnlike DLAS or Horty’s deontic default logics, we follow the tradition in deontic logic to have a dedicated operator O for unconditional obligations which, for instance, allows to formally distinguish between cases of deontic and cases of factual detachment.\nRecently, van der Torre & Villata extended the DLAS approach with deontic modalities [32], adopting the input/output methodology from Section 4.1. The resulting systems, like DAF, allow for versions of the factual and deontic detachment rules. Moreover, they allow for the representation of permissive norms. Unlike DAF, and unlike the I/O logics from Section 4.1, these systems do not have inheritance (weakening) or aggregation rules.\nAnother approach in which formal argumentation is used for the analysis of traditional problems of deontic logic, such as contrary-to-duty and specificity cases is [31]. There, arguments are Gentzen-type sequents in the language of standard deontic logic and conditionals are expressed using material implication. One drawback which is avoided in our setting is that there conditionals are contrapositable and subject to strengthening of the antecedent."
    }, {
      "heading" : "5 Outlook",
      "text" : "We presented a basic logic, DAF, for detaching conditional obligations based on Dung’s grounded semantics for formal argumentation. We extended DAF with mechanisms for conflict-resolution and for the anticipation of conflicts and violations. For now, these mechanisms mainly serve to illustrate the modularity of our framework. A detailed study of e.g. different approaches to prioritized reasoning, or different conceptions of specificity-based conflict-resolution, is left for an extended companion paper.\nWe conclude by mentioning three challenges for future research. The first is to include permission statements. The second is to increase the ‘logicality’ of\n15Other solutions to this problem have been proposed, e.g., in [33].\nour framework by allowing for the nesting and for the truth-functional combination of formulas of the form OA,A ⇒ B, or A. The third is to extend our focus beyond grounded extensions, and to study how our framework behaves when subjected to different types of acceptability semantics for formal argumentation. Working with Dung’s preferred semantics [6], for instance, allows for the derivation of so-called floating conclusions [12, 17]."
    } ],
    "references" : [ {
      "title" : "Dialogues and HY-arguments",
      "author" : [ "M. Caminada" ],
      "venue" : "in: J. Delgrande and T. Schaub, editors, 10th International Workshop on Non-Monotonic Reasoning (NMR",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2004
    }, {
      "title" : "On the evaluation of argumentation formalisms",
      "author" : [ "M. Caminada", "L. Amgoud" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2007
    }, {
      "title" : "Deontic logic and contrary-to-duties",
      "author" : [ "J. Carmo", "A. Jones" ],
      "venue" : "Handbook of Philosophical Logic (2nd edition)",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2002
    }, {
      "title" : "Compiling specificity into approaches to nonmonotonic reasoning",
      "author" : [ "J. Delgrande", "T. Schaub" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1997
    }, {
      "title" : "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games",
      "author" : [ "P. Dung" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1995
    }, {
      "title" : "An argument-based approach to reasoning with specifity",
      "author" : [ "P. Dung", "T. Son" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2001
    }, {
      "title" : "Bipolar argumentation frames and contrary to duty obligations, preliminary report",
      "author" : [ "D. Gabbay" ],
      "venue" : "Computational Logic in Multi-Agent Systems: Proceedings of the 13th International Workshop, CLIMA XIII,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2012
    }, {
      "title" : "Prioritized conditional imperatives: problems and a new proposal, Autonomous Agents and Multi-Agent Systems",
      "author" : [ "J. Hansen" ],
      "venue" : null,
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2008
    }, {
      "title" : "Deontic logic as founded on nonmonotonic logic",
      "author" : [ "J. Horty" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 1993
    }, {
      "title" : "Nonmonotonic foundations for deontic logic",
      "author" : [ "J. Horty" ],
      "venue" : "Defeasible Deontic Logic: Essays in Nonmonotonic Normative Reasoning, Kluwer Academic Publishers,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1997
    }, {
      "title" : "Skepticism and floating conclusions",
      "author" : [ "J. Horty" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2002
    }, {
      "title" : "Reasoning with moral conflicts, Noûs",
      "author" : [ "J. Horty" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2003
    }, {
      "title" : "Defaults with priorities",
      "author" : [ "J. Horty" ],
      "venue" : "Journal of Philosophical Logic",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2007
    }, {
      "title" : "Reasons as Defaults",
      "author" : [ "J. Horty" ],
      "venue" : "Oxford University Press, 2012.",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Floating conclusions and zombie paths: two deep difficulties in the “directly skeptical” approach to defeasible inheritance nets",
      "author" : [ "D. Makinson", "K. Schlechta" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1991
    }, {
      "title" : "Constraints for input/output logics",
      "author" : [ "D. Makinson", "L. van der Torre" ],
      "venue" : "Journal of Philosophical Logic",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2001
    }, {
      "title" : "The ASPIC+ framework for structured argumentation: a tutorial",
      "author" : [ "S. Modgil", "H. Prakken" ],
      "venue" : "Argument & Computation",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2014
    }, {
      "title" : "Defeasible Deontic Logic: Essays in Nonmonotonic Normative Reasoning",
      "author" : [ "D. Nute", "editor" ],
      "venue" : "Kluwer Academic Publishers, 1997.",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "An argumentation inspired heuristic for resolving normative conflict, in: Proceedings of the fifth workshop on coordination, organizations, institutionsm and norms in agent",
      "author" : [ "N. Oren", "M. Luck", "S. Miles", "T. Norman" ],
      "venue" : null,
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2008
    }, {
      "title" : "Sing and dance!",
      "author" : [ "X. Parent", "L. van der Torre" ],
      "venue" : "Input/output logics without weakening,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2014
    }, {
      "title" : "An abstract framework for argumentation with structured arguments",
      "author" : [ "H. Prakken" ],
      "venue" : "Argument and Computation",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2011
    }, {
      "title" : "Formalising arguments about norms",
      "author" : [ "H. Prakken", "G. Sartor" ],
      "venue" : "in: JU- RIX,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2013
    }, {
      "title" : "The Right and the Good",
      "author" : [ "D.W. Ross" ],
      "venue" : "Oxford University Press, 1930.",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 1930
    }, {
      "title" : "A theory of permission based on the notion of derogation",
      "author" : [ "A. Stolpe" ],
      "venue" : "Journal of Applied Logic",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2010
    }, {
      "title" : "A deontic logic framework allowing for factual detachment",
      "author" : [ "C. Straßer" ],
      "venue" : "Journal of Applied Logic",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2011
    }, {
      "title" : "An ASPIC-based legal argumentation framework for deontic reasoning",
      "author" : [ "L. van der Torre", "S. Villata" ],
      "venue" : "Computational Models of Argument - Proceedings of COMMA",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "We borrow Dung’s semantics [6] for evaluating arguments relative to the attack relations that hold between them.",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 22,
      "context" : "They can be interpreted as all-things-considered obligations – following Ross [28] – or output obligations – following Makinson & van der Torre [18, 19].",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 15,
      "context" : "They can be interpreted as all-things-considered obligations – following Ross [28] – or output obligations – following Makinson & van der Torre [18, 19].",
      "startOffset" : 144,
      "endOffset" : 152
    }, {
      "referenceID" : 4,
      "context" : "Dung [6] showed that for every AF there is a grounded extension, it is unique, and it can be constructed as follows.",
      "startOffset" : 5,
      "endOffset" : 8
    }, {
      "referenceID" : 4,
      "context" : "On Dung’s abstract approach [6], arguments are basic units of analysis the internal structure of which is not represented.",
      "startOffset" : 28,
      "endOffset" : 31
    }, {
      "referenceID" : 16,
      "context" : "[20].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "Example 4 (Failure of properties 4 and 5, adapted from [2]).",
      "startOffset" : 55,
      "endOffset" : 58
    }, {
      "referenceID" : 5,
      "context" : "[7, 5]) and deontic logic (see e.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 3,
      "context" : "[7, 5]) and deontic logic (see e.",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 2,
      "context" : "[4, 27, 30, 31]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 24,
      "context" : "[4, 27, 30, 31]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 20,
      "context" : "We lift ≤ to a priority ordering over arguments via the weakest link principle: an argument is only as strong as the weakest priority conditional used in its construction [25].",
      "startOffset" : 171,
      "endOffset" : 175
    }, {
      "referenceID" : 7,
      "context" : "[9, 14, 15].",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 12,
      "context" : "[9, 14, 15].",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 13,
      "context" : "[9, 14, 15].",
      "startOffset" : 0,
      "endOffset" : 11
    }, {
      "referenceID" : 15,
      "context" : "But what about obligations that commit us to violations or conflicts? Consider the following example, adapted from [16, 19].",
      "startOffset" : 115,
      "endOffset" : 123
    }, {
      "referenceID" : 0,
      "context" : "Shadow arguments are similar in spirit to Caminada’s HY-arguments from [2].",
      "startOffset" : 71,
      "endOffset" : 74
    }, {
      "referenceID" : 17,
      "context" : "A comparison with other related deontic systems, such as Nute’s defeasible deontic logic [22, 21] and Horty’s default-based deontic logic [13, 10, 11, 15] is left for an extended version of this article.",
      "startOffset" : 89,
      "endOffset" : 97
    }, {
      "referenceID" : 11,
      "context" : "A comparison with other related deontic systems, such as Nute’s defeasible deontic logic [22, 21] and Horty’s default-based deontic logic [13, 10, 11, 15] is left for an extended version of this article.",
      "startOffset" : 138,
      "endOffset" : 154
    }, {
      "referenceID" : 8,
      "context" : "A comparison with other related deontic systems, such as Nute’s defeasible deontic logic [22, 21] and Horty’s default-based deontic logic [13, 10, 11, 15] is left for an extended version of this article.",
      "startOffset" : 138,
      "endOffset" : 154
    }, {
      "referenceID" : 9,
      "context" : "A comparison with other related deontic systems, such as Nute’s defeasible deontic logic [22, 21] and Horty’s default-based deontic logic [13, 10, 11, 15] is left for an extended version of this article.",
      "startOffset" : 138,
      "endOffset" : 154
    }, {
      "referenceID" : 13,
      "context" : "A comparison with other related deontic systems, such as Nute’s defeasible deontic logic [22, 21] and Horty’s default-based deontic logic [13, 10, 11, 15] is left for an extended version of this article.",
      "startOffset" : 138,
      "endOffset" : 154
    }, {
      "referenceID" : 0,
      "context" : "Caminada’s HY-arguments from [2] are similar in spirit to this less skeptical proposal.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 15,
      "context" : "Like the constrained input/output (I/O) logics from [19], the DAFs defined here are tools for detaching conditional obligations relative to a set of inputs and constraints.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 15,
      "context" : "In [19] two ways are presented for dealing with conflicts and constraints: via a full meet operation on the generated MCSs, or via a full join operation on the generated MCSs.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 15,
      "context" : "[18, 19, 24] validate intuitively appealing rules which are not generally valid in our DAFs, such as the rule (OR) – from A ⇒ C and B ⇒ C to infer (A ∨B) ⇒ C.",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 19,
      "context" : "[18, 19, 24] validate intuitively appealing rules which are not generally valid in our DAFs, such as the rule (OR) – from A ⇒ C and B ⇒ C to infer (A ∨B) ⇒ C.",
      "startOffset" : 0,
      "endOffset" : 12
    }, {
      "referenceID" : 6,
      "context" : "For instance, the approach in [8] is based on bipolar abstract argumentation frameworks.",
      "startOffset" : 30,
      "endOffset" : 33
    }, {
      "referenceID" : 18,
      "context" : "A similar idea is used in [23] where a relation for evidential support is introduced.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 23,
      "context" : "In [29] an I/O system is presented which invalidates (SA) in the context of exempted permissions which are subject to conflict-resolution via logical analysis (specificity).",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 21,
      "context" : "For instance, in the dynamic legal argumentation systems (in short, DLAS) from [26], deontic conditionals are also modeled via a defeasible conditional in the object language.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 25,
      "context" : "Recently, van der Torre & Villata extended the DLAS approach with deontic modalities [32], adopting the input/output methodology from Section 4.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 4,
      "context" : "Working with Dung’s preferred semantics [6], for instance, allows for the derivation of so-called floating conclusions [12, 17].",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 10,
      "context" : "Working with Dung’s preferred semantics [6], for instance, allows for the derivation of so-called floating conclusions [12, 17].",
      "startOffset" : 119,
      "endOffset" : 127
    }, {
      "referenceID" : 14,
      "context" : "Working with Dung’s preferred semantics [6], for instance, allows for the derivation of so-called floating conclusions [12, 17].",
      "startOffset" : 119,
      "endOffset" : 127
    } ],
    "year" : 2016,
    "abstractText" : "We present a general formal argumentation system for dealing with the detachment of conditional obligations. Given a set of facts, constraints, and conditional obligations, we answer the question whether an unconditional obligation is detachable by considering reasons for and against its detachment. For the evaluation of arguments in favor of detaching obligations we use a Dung-style argumentation-theoretical semantics. We illustrate the modularity of the general framework by considering some extensions, and we compare the framework to some related approaches from the literature.",
    "creator" : "LaTeX with hyperref package"
  }
}