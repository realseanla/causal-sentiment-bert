{
  "name" : "1409.3836.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Hardness of parameter estimation in graphical models",
    "authors" : [ "Guy Bresler", "David Gamarnik", "Devavrat Shah" ],
    "emails" : [ "gbresler@mit.edu", "gamarnik@mit.edu", "devavrat@mit.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n40 9.\n38 36\nv2 [\ncs .C\nC ]\n1 7"
    }, {
      "heading" : "1 Introduction",
      "text" : "Graphical models are a powerful framework for succinct representation of complex highdimensional distributions. As such, they are at the core of machine learning and artificial intelligence, and are used in a variety of applied fields including finance, signal processing, communications, biology, as well as the modeling of social and other complex networks. In this paper we focus on binary pairwise undirected graphical models, a rich class of models with wide applicability. This is a parametric family of probability distributions, and for the models we consider, the canonical parameters θ are uniquely determined by the vector µ of mean parameters, which consist of the node-wise and pairwise marginals.\nTwo primary statistical tasks pertaining to graphical models are inference and parameter estimation. A basic inference problem is the computation of marginals (or conditional probabilities) given the model, that is, the forward mapping θ 7→ µ. Conversely, the backward mapping µ 7→ θ corresponds to learning the canonical parameters from the mean parameters. The backward mapping is defined only for µ in the marginal polytope M of realizable mean parameters, and this is important in what follows. The backward mapping captures maximum likelihood estimation of parameters; the study of the statistical properties of maximum likelihood estimation for exponential families is a classical and important subject.\nIn this paper we are interested in the computational tractability of these statistical tasks. A basic question is whether or not these maps can be computed efficiently (namely in time polynomial in\nthe problem size). As far as inference goes, it is well known that approximating the forward map (inference) is computational hard in general. This was shown by Luby and Vigoda [2] for the hardcore model, a simple pairwise binary graphical model (defined in (2.1)). More recently, remarkably sharp results have been obtained, showing that computing the forward map for the hard-core model is tractable if and only if the system exhibits the correlation decay property [3, 4]. In contrast, to the best of our knowledge, no analogous hardness result exists for the backward mapping (parameter estimation), despite its seeming intractability [1].\nTangentially related hardness results have been previously obtained for the problem of learning the graph structure underlying an undirected graphical model. Bogdanov et al. [5] showed hardness of determining graph structure when there are hidden nodes, and Karger and Srebro [6] showed hardness of finding the maximum likelihood graph with a given treewidth. Computing the backward mapping, in comparison, requires estimation of the parameters when the graph is known.\nOur main result, stated precisely in the next section, establishes hardness of approximating the backward mapping for the hard-core model. Thus, despite the problem being statistically feasible, it is computationally intractable.\nThe proof is by reduction, showing that the backward map can be used as a black box to efficiently estimate the partition function of the hard-core model. The reduction, described in Section 4, uses the variational characterization of the log-partition function as a constrained convex optimization over the marginal polytope of realizable mean parameters. The gradient of the function to be minimized is given by the backward mapping, and we use a projected gradient optimization method. Since approximating the partition function of the hard-core model is known to be computationally hard, the reduction implies hardness of approximating the backward map.\nThe main technical difficulty in carrying out the argument arises because the convex optimization is constrained to the marginal polytope, an intrinsically complicated object. Indeed, even determining membership (or evaluating the projection) to within a crude approximation of the polytope is NP-hard [7]. Nevertheless, we show that it is possible to do the optimization without using any knowledge of the polytope structure, as is normally required by ellipsoid, barrier, or projection methods. To this end, we prove that the polytope boundary has an inherent repulsive property that keeps the iterates inside the polytope without actually enforcing the constraint. The consequence of the boundary repulsion property is stated in Proposition 4.6 of Section 4, which is proved in Section 5.\nOur reduction has a close connection to the variational approach to approximate inference [1]. There, the conjugate-dual representation of the log-partition function leads to a relaxed optimization problem defined over a tractable bound for the marginal polytope and with a simple surrogate to the entropy function. What our proof shows is that accurate approximation of the gradient of the entropy obviates the need to relax the marginal polytope.\nWe mention a related work of Kearns and Roughgarden [8] showing a polynomial-time reduction from inference to determining membership in the marginal polytope. Note that such a reduction does not establish hardness of parameter estimation: the empirical marginals obtained from samples are guaranteed to be in the marginal polytope, so an efficient algorithm could hypothetically exist for parameter estimation without contradicting the hardness of marginal polytope membership.\nAfter completion of our manuscript, we learned that Montanari [9] has independently and simultaneously obtained similar results showing hardness of parameter estimation in graphical models from the mean parameters. His high-level approach is similar to ours, but the details differ substantially."
    }, {
      "heading" : "2 Main result",
      "text" : "In order to establish hardness of learning parameters from marginals for pairwise binary graphical models, we focus on a specific instance of this class of graphical models, the hard-core model. Given a graph G = (V,E) (where V = {1, . . . , p}), the collection of independent set vectors I(G) ⊆ {0, 1}V consist of vectors σ such that σi = 0 or σj = 0 (or both) for every edge {i, j} ∈ E. Each vector σ ∈ I(G) is the indicator vector of an independent set. The hard-core model assigns nonzero probability only to independent set vectors, with\nPθ(σ) = exp\n(∑\ni∈V θiσi − Φ(θ)\n) for each σ ∈ I(G) . (2.1)\nThis is an exponential family with vector of sufficient statistics φ(σ) = (σi)i∈V ∈ {0, 1}p and vector of canonical parameters θ = (θi)i∈V ∈ Rp. In the statistical physics literature the model is usually parameterized in terms of node-wise fugacity (or activity) λi = eθi . The log-partition function\nΦ(θ) = log\n( ∑\nσ∈I(G) exp\n(∑\ni∈V θiσi\n))\nserves to normalize the distribution; note that Φ(θ) is finite for all θ ∈ Rp. Here and throughout, all logarithms are to the natural base.\nThe set M of realizable mean parameters plays a major role in the paper, and is defined as M = {µ ∈ Rp| there exists a θ such that Eθ[φ(σ)] = µ} .\nFor the hard-core model (2.1), the set M is a polytope equal to the convex hull of independent set vectors I(G) and is called the marginal polytope. The marginal polytope’s structure can be rather complex, and one indication of this is that the number of half-space inequalities needed to represent M can be very large, depending on the structure of the graph G underlying the model [10, 11]. The model (2.1) is a regular minimal exponential family, so for each µ in the interior M◦ of the marginal polytope there corresponds a unique θ(µ) satisfying the dual matching condition\nEθ[φ(σ)] = µ .\nWe are concerned with approximation of the backward mapping µ 7→ θ, and we use the following notion of approximation.\nDefinition 2.1. We say that ŷ ∈ R is a δ-approximation to y ∈ R if y(1 − δ) ≤ ŷ ≤ (1 + δ). A vector v̂ ∈ Rp is a δ-approximation to v ∈ Rp if each entry v̂i is a δ-approximation to vi.\nWe next define the appropriate notion of efficient approximation algorithm.\nDefinition 2.2. A fully polynomial randomized approximation scheme (FPRAS) for a mapping fp : Xp → R is a randomized algorithm that for each δ > 0 and input x ∈ Xp, with probability at least 3/4 outputs a δ-approximation f̂p(x) to fp(x) and moreover the running time is bounded by a polynomial Q(p, δ−1).\nOur result uses the complexity classes RP and NP, defined precisely in any complexity text (such as [12]). The class RP consists of problems solvable by efficient (randomized polynomial) algorithms, and NP consists of many seemingly difficult problems with no known efficient algorithms. It is widely believed that NP 6= RP. Assuming this, our result says that there cannot be an efficient approximation algorithm for the backward mapping in the hard-core model (and thus also for the more general class of binary pairwise graphical models).\nWe recall that approximating the backward mapping entails taking a vector µ as input and producing an approximation of the corresponding vector of canonical parameters θ as output. It should be noted that even determining whether a given vector µ belongs to the marginal polytope M is known to be an NP-hard problem [7]. However, our result shows that the problem is NP-hard even if the input vector µ is known a priori to be an element of the marginal polytope M. Theorem 2.3. Assuming NP 6= RP, there does not exist an FPRAS for the backward mapping µ 7→ θ.\nAs discussed in the introduction, Theorem 2.3 is proved by showing that the backward mapping can be used as a black-box to efficiently estimate the partition function of the hard core model, known to be hard. This uses the variational characterization of the log-partition function as well as a projected gradient optimization method. Proving validity of the projected gradient method requires overcoming a substantial technical challenge: we show that the iterates remain within the marginal polytope without explicitly enforcing this (in particular, we do not project onto the polytope). The bulk of the paper is devoted to establishing this fact, which may be of independent interest.\nIn the next section we give necessary background on conjugate-duality and the variational characterization as well as review the result we will use on hardness of computing the log-partition function. The proof of Theorem 2.3 is then given in Section 4."
    }, {
      "heading" : "3 Background",
      "text" : ""
    }, {
      "heading" : "3.1 Exponential families and conjugate duality",
      "text" : "We now provide background on exponential families (as can be found in the monograph by Wainwright and Jordan [1]) specialized to the hard-core model (2.1) on a fixed graph G = (V,E). General theory on conjugate duality justifying the statements of this subsection can be found in Rockafellar’s book [13].\nThe basic relationship between the canonical and mean parameters is expressed via conjugate (or Fenchel) duality. The conjugate dual of the log-partition function Φ(θ) is\nΦ∗(µ) := sup θ∈Rd\n{ 〈µ, θ〉 − Φ(θ) } .\nNote that for our model Φ(θ) is finite for all θ ∈ Rp and furthermore the supremum is uniquely attained. On the interior M◦ of the marginal polytope, −Φ∗ is the entropy function. The logpartition function can then be expressed as\nΦ(θ) = sup µ∈M\n{ 〈θ, µ〉 − Φ∗(µ) } , (3.1)\nwith µ(θ) = argmax\nµ∈M\n{ 〈θ, µ〉 − Φ∗(µ) } . (3.2)\nThe forward mapping θ 7→ µ is specified by the variational characterization (3.2) or alternatively by the gradient map ∇Φ : Rp → M. As mentioned earlier, for each µ in the interior M◦ there is a unique θ(µ) satisfying the dual matching condition Eθ(µ)[φ(σ)] = (∇Φ)(θ(µ)) = µ. For mean parameters µ ∈ M◦, the backward mapping µ 7→ θ(µ) to the canonical parameters is given by\nθ(µ) = argmax θ∈Rp\n{ 〈µ, θ〉 − Φ(θ) }\nor by the gradient ∇Φ∗(µ) = θ(µ) .\nThe latter representation will be the more useful one for us."
    }, {
      "heading" : "3.2 Hardness of inference",
      "text" : "We describe an existing result on the hardness of inference and state the corollary we will use. The result says that, subject to widely believed conjectures in computational complexity, no efficient algorithm exists for approximating the partition function of certain hard-core models. Recall that the hard-core model with fugacity λ is given by (2.1) with θi = lnλ for each i ∈ V . Theorem 3.1 ([3, 4]). Suppose d ≥ 3 and λ > λc(d) = (d−1) d−1\n(d−2)d . Assuming NP 6= RP, there exists no FPRAS for computing the partition function of the hard-core model with fugacity λ on regular graphs of degree d. In particular, no FPRAS exists when λ = 1 and d ≥ 5.\nWe remark that the source of hardness is the long-range dependence property of the hard-core model for λ > λc(d). It was shown in [14] that for λ < λc(d) the model exhibits decay of correlations and there is an FPRAS for the log-partition function (in fact there is a deterministic approximation scheme as well). We note that a number of hardness results are known for the hardcore and Ising models, including [15, 16, 3, 2, 4, 17, 18, 19]. The result stated in Theorem 3.1 suffices for our purposes.\nFrom this section we will need only the following corollary, proved in the Appendix. The proof, standard in the literature, uses the self-reducibility of the hard-core model to express the partition function in terms of marginals computed on subgraphs. Corollary 3.2. Consider the hard-core model (2.1) on graphs of degree most d with parameters θi = 0 for all i ∈ V . Assuming NP 6= RP, there exists no FPRAS µ̂(0) for the vector of marginal probabilities µ(0), where error is measured entry-wise as per Definition 2.1."
    }, {
      "heading" : "4 Reduction by optimizing over the marginal polytope",
      "text" : "In this section we describe our reduction and prove Theorem 2.3. We define polynomial constants\nǫ = p−8 , q = p5 , and s = ( ǫ 2p )2 , (4.1)\nwhich we will leave as ǫ, q, and s to clarify the calculations. Also, given the asymptotic nature of the results, we assume that p is larger than a universal constant so that certain inequalities are satisfied.\nProposition 4.1. Fix a graph G on p nodes. Let θ̂ : M◦ → Rp be a black box giving a γapproximation for the backward mapping µ 7→ θ for the hard-core model (2.1). Using 1/ǫγ2 calls to θ̂, and computation bounded by a polynomial in p, 1/γ, it is possible to produce a 4γp7/2/qǫ2approximation µ̂(0) to the marginals µ(0) corresponding to all zero parameters.\nWe first observe that Theorem 2.3 follows almost immediately.\nProof of Theorem 2.3. A standard median amplification trick (see e.g. [20]) allows to decrease the probability 1/4 of erroneous output by a FPRAS to below 1/pǫγ2 usingO(log(pǫγ2)) function calls. Thus the assumed FPRAS for the backward mapping can be made to give a γ-approximation θ̂ to θ on 1/ǫγ2 successive calls, with probability of no erroneous outputs equal to at least 3/4. By taking γ = γ̃qǫ2p−7/2/2 in Proposition 4.1 we get a γ̃-approximation to µ(0) with computation bounded by a polynomial in p, 1/γ̃. In other words, the existence of an FPRAS for the mapping µ 7→ θ gives an FPRAS for the marginals µ(0), and by Corollary 3.2 this is not possible if NP 6= RP.\nWe now work towards proving Proposition 4.1, the goal being to estimate the vector of marginals µ(0) for some fixed graph G. The desired marginals are given by the solution to the optimization (3.2) with θ = 0:\nµ(0) = − argmin µ∈M Φ∗(µ) . (4.2)\nWe know from Section 3 that for x ∈ M◦ the gradient ∇Φ∗(x) = θ(x), that is, the backward mapping amounts to a gradient first order (gradient) oracle. A natural approach to solving the optimization problem (4.2) is to use a projected gradient method. For reasons that will be come clear later, instead of projecting onto the marginal polytope M, we project onto the shrunken marginal polytope M1 ⊂ M defined as M1 = {µ ∈ M∩ [qǫ,∞)p : µ+ ǫ · ei ∈ M for all i} , (4.3) where ei is the ith standard basis vector.\nAs mentioned before, projecting onto M1 is NP-hard, and this must therefore be avoided if we are to obtain a polynomial-time reduction. Nevertheless, we temporarily assume that it is possible to do the projection and address this difficulty later. With this in mind, we propose to solve the optimization (4.2) by a projected gradient method with fixed step size s,\nxt+1 = PM1(xt − s∇Φ∗(xt)) = PM1(xt − sθ(xt)) , (4.4)\nIn order for the method (4.4) to succeed a first requirement is that the optimum is inside M1. The following lemma is proved in the Appendix. Lemma 4.2. Consider the hard core model (2.1) on a graph G with maximum degree d on p ≥ 2d+1 nodes and canonical parameters θ = 0. Then the corresponding vector of mean parameters µ(0) is in M1.\nOne of the benefits of operating within M1 is that the gradient is bounded by a polynomial in p, and this will allow the optimization procedure to converge in a polynomial number of steps. The following lemma amounts to a rephrasing of Lemmas 5.3 and 5.4 in Section 5 and the proof is omitted. Lemma 4.3. We have the gradient bound ‖∇Φ∗(x)‖∞ = ‖θ(x)‖∞ ≤ p/ǫ = p9 for any x ∈ M1.\nNext, we state general conditions under which an approximate projected gradient algorithm converges quickly. Better convergence rates are possible using the strong convexity of Φ∗ (shown in Lemma 4.5 below), but this lemma suffices for our purposes. The proof is standard (see [21] or Theorem 3.1 in [22] for a similar statement) and is given in the Appendix for completeness.\nLemma 4.4 (Projected gradient method). Let G : C → R be a convex function defined over a compact convex set C with minimizer x∗ ∈ argminx∈C G(x). Suppose we have access to an approximate gradient oracle ∇̂G(x) for x ∈ C with error bounded as supx∈C ‖∇̂G(x)−∇G(x)‖1 ≤ δ/2. Let L = supx∈C ‖∇̂G(x)‖. Consider the projected gradient method xt+1 = PC(xt − s∇̂G(xt)) starting at x1 ∈ C and with fixed step size s = δ/2L2. After T = 4‖x1 − x∗‖2L2/δ2 iterations the average x̄T = 1T ∑T t=1 x t satisfies G(x̄T )−G(x∗) ≤ δ.\nTo translate accuracy in approximating the functionΦ∗(x∗) to approximatingx∗, we use the fact that Φ∗ is strongly convex. The proof (in the Appendix) uses the equivalence between strong convexity of Φ∗ and strong smoothness of the Fenchel dual Φ, the latter being easy to check. Since we only require the implication of the lemma, we defer the definitions of strong convexity and strong smoothness to the appendix where they are used.\nLemma 4.5. The function Φ∗ : M◦ → R is p− 32 -strongly convex. As a consequence, if Φ∗(x) − Φ∗(x∗) ≤ δ for x ∈ M◦ and x∗ = argminy∈M◦ Φ∗(y), then ‖x− x∗‖ ≤ 2p 3 2 δ.\nAt this point all the ingredients are in place to show that the updates (4.4) rapidly approach µ(0), but a crucial difficulty remains to be overcome. The assumed black box θ̂ for approximating the mapping µ 7→ θ is only defined for µ inside M, and thus it is not at all obvious how to evaluate the projection onto the closely related polytope M1. Indeed, as shown in [7], even approximate projection onto M is NP-hard, and no polynomial time reduction can require projecting onto M1 (assuming P 6= NP). The goal of the subsequent Section 5 is to prove Proposition 4.6 below, which states that the optimization procedure can be carried out without any knowledge about M or M1. Specifically, we show that thresholding coordinates suffices, that is, instead of projecting onto M1 we may project onto the translated non-negative orthant [qǫ,∞)p. Writing P≥ for this projection, we show that the original projected gradient method (4.4) has identical iterates xt as the much simpler update rule\nxt+1 = P≥(xt − sθ(xt)) . (4.5) Proposition 4.6. Choose constants as per (4.1). Suppose x1 ∈ M1, and consider the iterates xt+1 = P≥(xt − sθ̂(xt)) for t ≥ 1, where θ̂(xt) is a γ-approximation of θ(xt) for all t ≥ 1. Then xt ∈ M1, for all t ≥ 1, and thus the iterates are the same using either P≥ or PM1 .\nThe next section is devoted to the proof of Proposition 4.6. We now complete the reduction.\nProof of Proposition 4.1. We start the gradient update procedure xt+1 = P≥(xt − sθ̂(xt)) at the point x1 = ( 12p , 1 2p , . . . , 1 2p ), which we claim is within M1 for any graph G for p = |V | large enough. To see this, note that ( 1p , 1 p , . . . , 1 p ) is in M, because it is a convex combination (with weight 1/p each) of the independent set vectors e1, . . . , ep. Hence x1+ 12p ·ei ∈ M, and additionally x1i = 1 2p ≥ qǫ, for all i.\nWe establish that xt ∈ M1 for each t ≥ 1 by induction, having verified the base case t = 1 in the preceding paragraph. Let xt ∈ M1 for some t ≥ 1. At iteration t of the update rule we make a call to the black box θ̂(xt) giving a γ-approximation to the backward mapping θ(xt), compute xt − sθ̂(xt), and then project onto [qǫ,∞)p. Proposition 4.6 ensures that xt+1 ∈ M1. Therefore, the update xt+1 = P≥(xt − sθ̂(xt)) is the same as xt+1 = PM1(xt − sθ̂(xt)). Now we can now apply Lemma 4.4 with G = Φ∗, C = M1, δ = 2γp2/ǫ and L = supx∈C ‖∇̂G(x)‖2 ≤ √ p(p/ǫ)2 = p3/2/ǫ. After\nT = 4‖x1 − x∗‖2L2/δ2 ≤ 4p(p3/ǫ2)/(4γ2p4/ǫ2) = 1/γ2\niterations the average x̄T = 1T ∑T t=1 x t satisfies G(x̄T )−G(x∗) ≤ δ.\nLemma 4.5 implies that ‖x̄T − x∗‖2 ≤ 2δp 32 , and since x∗i ≥ qǫ, we get the entry-wise bound |x̄Ti − x∗i | ≤ 2δp 3 2x∗i /qǫ for each i ∈ V . Hence x̄T is a 4γp7/2/qǫ2-approximation for x∗."
    }, {
      "heading" : "5 Proof of Proposition 4.6",
      "text" : "In Subsection 5.1 we prove estimates on the parameters θ corresponding to µ close to the boundary of M1, and then in Subsection 5.2 we use these estimates to show that the boundary of M1 has a certain repulsive property that keeps the iterates inside."
    }, {
      "heading" : "5.1 Bounds on gradient",
      "text" : "We start by introducing some helpful notation. For a node i, let N (i) = {j ∈ [p] : (i, j) ∈ E} denote its neighbors. We partition the collection of independent set vectors as\nI = Si ∪ S−i ∪ S⊘i , where\nSi = {σ ∈ I : σi = 1} = {Ind sets containing i} S−i = {σ − ei : σ ∈ Si} = {Ind sets where i can be added} S⊘i = {σ ∈ I : σj = 1 for some j ∈ N (i)} = {Ind sets conflicting with i} .\nFor a collection of independent set vectors S ⊆ I we write P(S) as shorthand for Pθ(σ ∈ S) and\nf(S) = P(S) · eΦ(θ) = ∑\nσ∈S exp\n(∑\nj∈V θjσj\n) .\nWe can then write the marginal at node i as µi = P(Si), and since Si, S − i , S ⊘ i partition I, the space of all independent sets of G, 1 = P(Si) + P(S − i ) + P(S ⊘ i ). For each i let\nνi = P(S ⊘ i ) = P(a neighbor of i is in σ) .\nThe following lemma specifies a condition on µi and νi that implies a lower bound on θi. Lemma 5.1. If µi + νi ≥ 1− δ and νi ≤ 1− ζδ for ζ > 1, then θi ≥ ln(ζ − 1).\nProof. Let α = eθi , and observe that f(Si) = αf(S − i ). We want to show that α ≥ ζ − 1.\nThe first condition µi + νi ≥ 1− δ implies that f(Si) + f(S ⊘ i ) ≥ (1 − δ)(f(Si) + f(S⊘i ) + f(S−i )) = (1 − δ)(f(Si) + f(S⊘i ) + α−1f(Si)) , and rearranging gives\nf(S⊘i ) + f(Si) ≥ 1− δ δ α−1f(Si) . (5.1)\nThe second condition νi ≤ 1− ζδ reads f(S⊘i ) ≤ (1− ζδ)(f(Si) + f(S⊘i ) + f(S−i )) or\nf(S⊘i ) ≤ 1− ζδ ζδ f(Si)(1 + α −1) (5.2)\nCombining (5.1) and (5.2) and simplifying results in α ≥ ζ − 1.\nWe now use the preceding lemma to show that if a coordinate is close to the boundary of the shrunken marginal polytope M1, then the corresponding parameter is large. Lemma 5.2. Let r be a positive real number. If µ ∈ M1 and µ+ rǫ · ei /∈ M, then θi ≥ ln ( q r − 1 ) .\nProof. We would like to apply Lemma 5.1 with ζ = q/r and δ = rǫ, which requires showing that (a) νi ≤ 1 − qǫ and (b) µi + νi ≥ 1 − rǫ. To show (a), note that if µ ∈ M1, then µi ≥ qǫ by definition of M1. It follows that νi ≤ 1− µi ≤ 1− qǫ. We now show (b). Since µi = P(Si), νi = P(S ⊘ i ), and 1 = P(Si) + P(S ⊘ i ) + P (S − i ), (b) is equivalent to P(S−i ) ≤ rǫ. We assume that µ + rǫ · ei /∈ M and suppose for the sake of\ncontradiction that P(S−i ) > rǫ. Writing ησ = P(σ) for σ ∈ I, so that µ = ∑\nσ∈I ησ · σ, we define a new probability measure\nη′σ =   \nησ + ησ−ei if σ ∈ Si 0 if σ ∈ S−i ησ otherwise .\nOne can check that µ′ = ∑\nσ∈I η ′ σσ has µ ′ j = µj for each i 6= j and µ′i = µi + P(S−i ) > µi + rǫ.\nThe point µ′, being a convex combination of independent set vectors, must be in M, and hence so must µ+ rǫ · ei. But this contradicts the hypothesis and completes the proof of the lemma.\nThe proofs of the next two lemmas are similar in spirit to Lemma 8 in [23] and are proved in the Appendix. The first lemma gives an upper bound on the parameters (θi)i∈V corresponding to an arbitrary point in M1. Lemma 5.3. If µ+ ǫ · ei ∈ M, then θi ≤ p/ǫ. Hence if µ ∈ M1, then θi ≤ p/ǫ for all i.\nThe next lemma shows that if a component µi is not too small, the corresponding parameter θi is also not too negative. As before, this allows to bound from below the parameters corresponding to an arbitrary point in M1. Lemma 5.4. If µi ≥ qǫ, then θi ≥ −p/qǫ. Hence if µ ∈ M1, then θi ≥ −p/qǫ for all i."
    }, {
      "heading" : "5.2 Finishing the proof of Proposition 4.6",
      "text" : "We sketch the remainder of the proof here; full detail is given in Section D of the Supplement.\nStarting with an arbitrary xt in M1, our goal is to show that xt+1 = P≥(xt − sθ̂(xt)) remains in M1. The proof will then follow by induction, because our initial point x1 is in M1 by the hypothesis.\nThe argument considers separately each hyperplane constraint for M of the form 〈h, x〉 ≤ 1. The distance of x from the hyperplane is 1− 〈h, x〉. Now, the definition of M1 implies that if x ∈ M1, then x+ ǫ ·ei ∈ M1 for all coordinates i, and thus 1−〈h, x〉 ≥ ǫ‖h‖∞ for all constraints. We call a constraint 〈h, x〉 ≤ 1 critical if 1− 〈h, x〉 < ǫ‖h‖∞, and active if ǫ‖h‖∞ ≤ 1− 〈h, x〉 < 2ǫ‖h‖∞. For xt ∈ M1 there are no critical constraints, but there may be active constraints. We first show that inactive constraints can at worst become active for the next iterate xt+1, which requires only that the step-size is not too large relative to the magnitude of the gradient (Lemma 4.3 gives the desired bound). Then we show (using the gradient estimates from Lemmas 5.2, 5.3, and 5.4) that the active constraints have a repulsive property and that xt+1 is no closer than xt to any active constraint, that is, 〈h, xt+1〉 ≤ 〈h, xt〉. The argument requires care, because the projection P≥ may prevent coordinates i from decreasing despite xti−sθ̂i(xt) being very negative if xti is already small. These arguments together show that xt+1 remains in M1, completing the proof."
    }, {
      "heading" : "6 Discussion",
      "text" : "This paper addresses the computational tractability of parameter estimation for the hard-core model. Our main result shows hardness of approximating the backward mapping µ 7→ θ to within a small polynomial factor. This is a fairly stringent form of approximation, and it would be interesting to strengthen the result to show hardness even for a weaker form of approximation. A possible goal would be to show that there exists a universal constant c > 0 such that approximation of the backward mapping to within a factor 1 + c in each coordinate is NP-hard."
    }, {
      "heading" : "Acknowledgments",
      "text" : "GB thanks Sahand Negahban for helpful discussions. Also we thank Andrea Montanari for sharing his unpublished manuscript [9]. This work was supported in part by NSF grants CMMI-1335155 and CNS-1161964, and by Army Research Office MURI Award W911NF-11-1-0036."
    }, {
      "heading" : "Supplementary Material",
      "text" : ""
    }, {
      "heading" : "A Miscellaneous proofs",
      "text" : ""
    }, {
      "heading" : "A.1 Proof of Corollary 3.2",
      "text" : "The proof is standard and uses the self-reducibility of the hard-core model, meaning that conditioning on σi = 0 amounts to removing node i from the graph. Fix a graph G and parameters θ = 0. We show that given an algorithm to approximately compute the marginals for induced subgraphs H ⊆ G, it is possible to approximate the partition function eΦ(0), denoted here by Z . We first claim that\nZ =\np∏\ni=1\n1\n1− µi(G \\ [i− 1]) . (A.1)\nThe graph G \\ [i − 1] is obtained by removing nodes labeled 1, 2, . . . , i − 1, and µi(G \\ [i − 1]) is the marginal at node i for this graph. We use induction on the number of nodes. The base case with one node is trivial: Z = 1 + e0 = 2 = 1/(1 − µ). Suppose now that the formula (A.1) holds for graphs on k nodes and that |V | = k + 1. Let Z0 and Z1 denote the partition function summation restricted to σ1 = 0 or σ1 = 1, respectively. Thus\nZ = Z0 + Z1 = Z0( Z0 + Z1\nZ0 ) = Z0 1− µ1 .\nNow Z0 is the partition function of a new graph obtained by deleting vertex i, and the inductive assumption proves the formula.\nFrom (A.1) we see that in order to compute a γ-approximation to Z−1, it suffices to compute a γ/p approximation to each of the marginals. Now for small γ, a γ approximation to Z−1 gives a 2γ approximation to Z , and this completes the proof."
    }, {
      "heading" : "A.2 Proof of Lemma 4.2",
      "text" : "We wish to show that µ(0) ∈ M1 for a graph G = (V,E) of maximum degree d and p ≥ 2d+1. Consider a particular node i ∈ V with neighbors N(i), and let di = |N(i)| denote its degree. We use the notation Si, S − i , S ⊘ i defined in Subsection 5.1. A collection of independent set vectors S ⊆ I(G) is assigned probability P(S) = |S|/|I(G)| for our choice θ = 0, so it suffices to argue about cardinalities.\nWe first claim that |Si| ≥ 2−d|S⊘i |. This follows by observing that each set in S⊘i gets mapped to a set in Si by removing the neighbors Ni, and moreover at most 2d sets are mapped to the same set in Si. Next, we note that |Si| = |S−i | since the removal of node i is a bijection from Si to S−i and hence they are of the same cardinality. Combining these observations with the fact that P(Si) + P(S − i ) + P(S ⊘ i ) = 1, we get the estimate µi = P(Si) ≥ 1/(2−d + 2) ≥ 2−d−1.\nNext, we show for each coordinate i that the vector µ′ = µ+2−d−1ei is in M, which will complete the proof that µ(0) is M1. Let ησ = P0(σ) denote the probability assigned to σ under the distribution with parameters θ = 0, so that µ = ∑ σ∈I(G) ησ · σ. Similarly to the proof of Lemma 5.2, we define a new probability measure\nη′σ =    ησ + 2 −d−1 if σ ∈ Si\nησ − 2−d−1 if σ ∈ S−i ησ otherwise .\nThis is a valid probability distribution because ησ ≥ 2−d−1 for σ ∈ S−i . One can check that µ′ = ∑ σ∈I η ′ σσ has µ ′ j = µj for each j 6= i and µ′i = µi + 2−d−1. The point µ′, being a convex combination of independent set vectors, must be in M, and hence so must µ+ 2−d−1ei."
    }, {
      "heading" : "B Proofs for projected gradient method",
      "text" : ""
    }, {
      "heading" : "B.1 Proof of Lemma 4.4",
      "text" : "The proof here is a slight modification of the proof of Theorem 3.1 in [22].\nObserve first that if P is the projection onto a convex set, then P is a contraction: ‖P(x)−P(y)‖2 ≤ ‖x−y‖2 (cf. Prop 2.1.3 in [24]). Using the the convexity inequality G(x)−G(x∗) ≤ ∇G(x)T (x− x∗), the definition η = supx∈C ‖∇̂G(x)−∇G(x)‖1, and the update formula xt+1 = xt−s∇̂G(xt), it follows that\nG(xt)−G(x∗) ≤ ∇G(xt)T (xt − x∗) = ∇̂G(xt)T (xt − x∗) + (∇̂G(xt)T −∇G(xt)T )(xt − x∗) ≤ ∇̂G(xt)T (xt − x∗) + η‖xt − x∗‖∞ = 1\ns (xt − xt+1)T (xt − x∗) + η\n= 1\n2s (‖xt − x∗‖22 + ‖xt − xt+1‖22 − ‖xt+1 − x∗‖22) + η\n= 1\n2s (‖xt − x∗‖22 − ‖xt+1 − x∗‖22) +\ns 2 ‖ ∇̂G(xt)‖22 + η .\nAdding the preceding inequality for t = 1 to t = T , the sum telescopes and we get\nT∑\nt=1\n[G(xt)−G(x∗)] ≤ R 2\n2s +\ns 2 L2T + ηT = RL\n√ T + ηT . (B.1)\nHere we used the definitions R = ‖x1 − x∗‖ and L = supx∈C ‖∇̂G(x)‖ and the last equality is by the choice s = R\nL √ T . Now defining x̄T = 1T ∑T t=1 x t, dividing (B.1) through by T and using the\nconvexity of G to apply Jensen’s inequality gives\nG(x̄T )−G(x∗) ≤ RL√ T + η .\nThus in order to make the right hand side smaller than δ it suffices to take T = 4R2L2/δ2 and η = δ/2."
    }, {
      "heading" : "B.2 Proof of Lemma 4.5",
      "text" : "We start by showing that the gradient ∇Φ is p 32 -Lipschitz. Recall that ∇Φ(θ) = µ(θ). We prove a bound on |µi(θ) − µi(θ′)| by changing one coordinate of θ at a time. Let θ(r) = (θ1, . . . , θr, θ ′ r+1, . . . , θ ′ p). The triangle inequality gives\n|µi(θ)− µi(θ′)| = p−1∑\nr=0\n|µi(θ(r))− µi(θ(r+1))| .\nA direct calculation shows that\n∂\n∂θr µi(θ) = P(σi = σr = 1)− µi(θ)µr(θ) .\nSince this is uniformly bounded by one in absolute value, we obtain the inequality |µi(θ)−µi(θ′)| ≤ ‖θ − θ′‖1 or ‖µ(θ)− µ(θ′)‖1 ≤ p‖θ − θ′‖1 Hence\n‖µ(θ)− µ(θ′)‖2 ≤ ‖µ(θ)− µ(θ′)‖1 ≤ p‖θ − θ′‖1 ≤ p 3 2 ‖θ − θ′‖2 , i.e., ∇Φ is p 32 -Lipschitz.\nNow the function ∇Φ being p 32 -Lipschitz implies that Φ is p 32 -strongly smooth, where Φ is βstrongly smooth if\nΦ(x +∆)− Φ(x) ≤ 〈∇Φ(x),∆〉 + 1 2 β‖∆‖2 .\nTo see this, we write Φ(x+∆)− Φ(x) = ∫ 1\n0\n〈∇Φ(x + τ∆),∆〉dτ = 〈∇Φ(x),∆〉 + ∫ 1\n0\n( ∇Φ(x+ τ∆) −∇Φ(x) ) dτ\n≤ 〈∇Φ(x),∆〉 + p 32 ∫ 1\n0\n〈τ∆,∆〉dτ\n= 〈∇Φ(x),∆〉 + 12p 3 2 ‖∆‖2 .\nNow Theorem 6 from [25] or Chapter 5 of [26] imply that Φ∗, being the Fenchel conjugate of Φ, is p− 3 2 -strongly convex, meaning\nΦ∗(x+∆)− Φ∗(x) ≥ 〈∇Φ∗(x),∆〉 + 12p− 3 2 ‖∆‖2 . This gives the desired bound on ‖x− x∗‖ in terms of Φ∗(x)− Φ∗(x∗)."
    }, {
      "heading" : "C Proofs of gradient bounds",
      "text" : ""
    }, {
      "heading" : "C.1 Proof of Lemma 5.3",
      "text" : "We suppose for the sake of deriving a contradiction that θi > p/δ. Let µ̄ = µ + δ · ei, and let η′ be a probability measure such that µ̄ = ∑ σ∈I η ′ σσ. Now η\n′(Si) = µ̄i ≥ δ, and we define the non-negative measure γ (summing to less than one) with support Si as\nγσ = { η′σ · δη′(Si) if σ ∈ Si 0 otherwise .\nIn this way, γσ ≤ η′σ and γ(Si) = δ. We define a new probability measure\nησ =    η′σ − γσ if σ ∈ Si η′σ + γσ∪{i} if σ ∈ S−i η′σ otherwise ,\n(C.1)\nand one may check that µ = ∑\nσ∈I ησσ and η(S − i ) ≥ γ(Si) = δ. We use the definitions in\nSubsection 5.1 to get\nFµ(θ) , µ · θ − log (∑\nσ∈I exp(σ · θ)\n)\n= ∑\nρ∈I ηρ log exp(ρ · θ)∑ σ exp(σ · θ)\n(a) =≤\n∑\nρ∈S−i\nηρ log exp(ρ · θ)\nf(S−i ) + e θif(S−i ) + f(S ⊘ i )\n(b) ≤ ∑\nρ∈S−i\nηρ log f(S−i )\neθif(S−i )\n≤ −η(S−i )θi (c) < −p\n(d)\n≤ − log |I| = F (0) . Here (a) follows by restricting the sum to S−i ⊆ I(G) and from the fact that ∑ σ exp(σ · θ) = f(S−i ) + e θif(S−i ) + f(S ⊘ i ), (b) follows by retaining only the term e\nθif(S−i ) in the denominator and replacing exp(ρ · θ) for ρ ∈ S−i with f(S−i ) = ∑ ρ∈S− i exp(ρ · θ), thereby increasing the argument to the logarithm, (c) uses the fact that η(S−i ) ≥ δ and the assumption that θi > p/δ, and (d) follows from the crude bound on number of independent sets |I| ≤ 2p and log 2 < 1. Finally, the relation θ(µ) = argmaxθ Fµ(θ) from Section 3 contradicts Fµ(θ) < F (0)."
    }, {
      "heading" : "C.2 Proof of Lemma 5.4",
      "text" : "We suppose for the sake of contradiction that θi < −p/δ and show that θ cannot be the vector of canonical parameters corresponding to µ. Since µ ∈ M, there exists a non-negative measure η so that µ = ∑σ∈I ησσ, and furthermore η(Si) = µi ≥ δ. Now arguments similar to the proof of Lemma 5.3 above give\nFµ(θ) = µ · θ − log (∑\nσ\nexp(σ · θ) )\n= ∑\nρ∈I ηρ log exp(ρ · θ)∑ σ exp(σ · θ)\n≤ ∑\nρ∈Si ηρ log exp(ρ · θ) f(S−i ) + e θif(S−i ) + f(S ∗ i )\n≤ ∑\nρ∈Si ηρ log\neθif(S−i )\nf(S−i ) + e θif(S−i ) + f(S ∗ i )\n≤ ∑\nρ∈Si ηρθi = η(Si)θi < −δp/δ = −p ≤ − log |I| = F (0) .\nAs before, this contradicts the relation θ(µ) = argmaxθ Fµ(θ)."
    }, {
      "heading" : "D Proof of Proposition 4.6",
      "text" : "Starting with xt in M1, our goal is to show that xt+1 = P≥(xt − sθ̂(xt)) remains in M1. The proof will then follow by induction, because our initial point x1 is in M1 by the hypothesis. We will use the fact that all hyperplane constraints for M, except for the non-negativity constraints xi ≥ 0, can be written as 〈h, x〉 ≤ 1 for a vector h ∈ [0, 1]p. This can be justified using the fact that ei ∈ M for each i together with the property that for any µ ∈ M, any coordinate of µ can be set to zero while remaining in M. Given our current iterate xt, we call a constraint 〈h, x〉 ≤ 1 active if\n1− 2ǫ‖h‖∞ < 〈h, xt〉 ≤ 1− ǫ‖h‖∞ (D.1) and critical if 1− ǫ‖h‖∞ < 〈h, xt〉 . (D.2) Observe that an active constraint has a coordinate i (namely i with hi = ‖h‖∞) with 〈h, xt + 2ǫ · ei〉 = 〈h, xt〉+2hiǫ > 1 and similarly a critical constraint has a coordinate i with 〈h, xt + ǫ · ei〉 = 〈h, xt〉+ hiǫ > 1. For xt ∈ M1 there are (by definition) no critical constraints, but there may be active constraints. We will first show that inactive constraints can at worst become active for the next iterate xt+1, which requires only that the step-size is not too large relative to the magnitude of the gradient. Then we show that the active constraints have a repulsive property and that xt+1 is no closer than xt to any active constraint, that is, 〈h, xt+1〉 ≤ 〈h, xt〉. Thus, if xt is in M1, then there are no critical constraints for xt+1 and every coordinate i satisfies 〈h, xt+1 + ǫ · ei〉 ≤ 1 for all constraint vectors h. Since the projection P≥ ensures that xt+1i ≥ qǫ, the update xt+1 is in M1. We now focus on inactive constraints.\nInactive constraint. We consider an inactive constraint h, meaning that 〈h, xt〉 + 2ǫ‖h‖∞ ≤ 1 . By assumption the step size s = ( ǫ 2p )2 so the increment in any coordinate j is bounded as\nxt+1j − xtj ≤ s|θ̂j(xt)| ≤ s|θ̂j(xt)− θj(xt)|+ s|θj(xt)| ≤ (1 + γ)s|θj(xt)| ≤ ǫ/p\nusing Lemma 5.3 and fact that γ ≤ 1. These bounds give 〈h, xt+1〉 = 〈h, xt〉+ 〈h, xt+1 − xt〉 ≤ 〈h, xt〉+ ∑\nj\nhj(x t+1 j − xtj)\n≤ 〈h, xt〉+ p(ǫ/p)‖h‖∞ ≤ 1− ǫ‖h‖∞ which shows that the constraint is not critical for xt+1 and at worst becomes active.\nActive constraint. The rough idea is that if a coordinate i cannot be increased by 2ǫ while remaining in M, then the parameter θi must be sufficiently large, and the next iterate xt+1 will decrease enough to overcome the possible increase in other coordinates. This argument does not work, however, because it might be the case that xti = qǫ, which prevents any decrease (i.e., x t+1 i ≥ xti) due to the projection P≥. Instead, we start by showing that if some coordinate cannot be increased by 2ǫ, then there must be a reasonably large coordinate which cannot be increased by 4pǫ.\nLemma D.1. If h is an active constraint, then there is a coordinate ℓ ∈ V with xt + (4pǫ)eℓ /∈ M and xtℓ ≥ 2qǫ.\nProof. If h is active then 1− 2ǫ‖h‖∞ < 〈h, xt〉. Using the fact that hj ≤ 1 for all j we have 1− 2ǫ ≤ 1− 2ǫ‖h‖∞ < 〈h, xt〉 . (D.3)\nLet B ⊆ V consist of coordinates j with small entries xtj ≤ 2ǫq. Then\n〈h, xt〉 = ∑\nj∈B hjx\nt + ∑\nj∈Bc hjx\nt ≤ |B|(2ǫq) + ∑\nj∈Bc hjx\nt ≤ 2 p +\n∑\nj∈Bc hjx\nt j . (D.4)\nThe last inequality used the crude estimate |B| ≤ p. Combining (D.3) and (D.4) and rearranging gives ∑\nj∈Bc hjx\nt j ≥ 1− 2ǫ− 2/p ≥ 1− 3/p ,\nand it follows that there is an ℓ ∈ Bc for which hℓ ≥ hℓxtℓ ≥ 1/2p. Adding hℓ · (4pǫ) ≥ 2ǫ to both sides of (D.3) shows that xt + (4pǫ)eℓ violates the inequality 〈h, x〉 ≤ 1. This proves the lemma, since xtℓ > 2qǫ for ℓ ∈ Bc.\nWe are now ready to prove that 〈h, xt+1〉 ≤ 〈h, xt〉. Let ℓ be the coordinate promised by Lemma D.1, with xt + (4pǫ)eℓ /∈ M and xtℓ ≥ 2qǫ. From Lemma 5.2, we know that θℓ(xt) ≥ log ( q 4p − 1 ) ≥ 3 log p, for p large enough. By definition of θ̂ being a γ-approximation to θ, θ̂ℓ(x t) ≥ (1 − γ)θℓ(xt). Therefore, since γ → 0 as p → ∞, it follows that for p large enough θ̂ℓ(x t) ≥ log p. This implies\nxt+1ℓ − xtℓ ≤ −min(sθ̂(xt), s log p) ≤ −s log p . (D.5) Here we used the fact that xtℓ ≥ qǫ+ s log p so the projection P≥ does not affect this coordinate. Denote by D the set of coordinates\nD = {j ∈ [p] : 〈h, xt〉+ q2ǫhj > 1} . These coordinates have non-positive increment: since xj ≥ qǫ for x ∈ M1, Lemma 5.1 implies that θj ≥ 0, and hence θ̂j ≥ (1 − γ)θj ≥ 0, or\nxt+1j − xtj ≤ 0 for j ∈ D .\nIn contrast, coordinates in Dc might increase, but by a limited amount: since xt ∈ M1, all coordinates j ∈ Dc satisfy xtj ≥ qǫ, and Lemma 5.4 gives the bound θj ≥ −p/qǫ, or\nxt+1j − xtj ≤ (1 + γ)| − sθj | ≤ 2sp/qǫ for all j ∈ Dc . (D.6) Additionally, by the definition of D and the fact that increasing coordinate ℓ by 4pǫ violates 〈h, x〉 ≤ 1, if j ∈ Dc, then 4pǫhℓ > qǫhj/2, or\nhj < 8phℓ/q for all j ∈ Dc . (D.7)\nUsing the crude bound |Dc| ≤ p together with (D.6) and (D.7) gives ∑\nj∈Dc hj(x\nt+1 j − xtj) ≤ |Dc| 8phℓ q · 2sp qǫ ≤ s4p 2 q2ǫ hℓ ≤ 4shℓ . (D.8)\nCounting the contributions from Dc in (D.8) in addition to D (none) and ℓ (negative as per (D.5)), it follows that\n〈c, xt+1〉 = 〈h, xt〉+ 〈h, xt+1 − xt〉 ≤ 〈h, xt〉+ shℓ(4 − θℓ) ≤ 〈h, xt〉+ shℓ(4 − ln p) ≤ 〈h, xt〉 .\nHere we have used the fact that p is large enough (p ≥ e4 suffices for this last step). In words, we move away from any active hyperplane constraint. This completes the proof."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2014,
    "abstractText" : "We consider the problem of learning the canonical parameters specifying an undi-<lb>rected graphical model (Markov random field) from the mean parameters. For<lb>graphical models representing a minimal exponential family, the canonical param-<lb>eters are uniquely determined by the mean parameters, so the problem is feasible<lb>in principle. The goal of this paper is to investigate the computational feasibil-<lb>ity of this statistical task. Our main result shows that parameter estimation is in<lb>general intractable: no algorithm can learn the canonical parameters of a generic<lb>pair-wise binary graphical model from the mean parameters in time bounded by a<lb>polynomial in the number of variables (unless RP = NP). Indeed, such a result has<lb>been believed to be true (see [1]) but no proof was known.<lb>Our proof gives a polynomial time reduction from approximating the partition<lb>function of the hard-core model, known to be hard, to learning approximate pa-<lb>rameters. Our reduction entails showing that the marginal polytope boundary has<lb>an inherent repulsive property, which validates an optimization procedure over<lb>the polytope that does not use any knowledge of its structure (as required by the<lb>ellipsoid method and others).",
    "creator" : "LaTeX with hyperref package"
  }
}