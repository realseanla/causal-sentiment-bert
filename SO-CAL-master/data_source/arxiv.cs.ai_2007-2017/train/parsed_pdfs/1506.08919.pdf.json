{
  "name" : "1506.08919.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Characterization of Logic Program Revision as an Extension of Propositional Revision∗",
    "authors" : [ "Nicolas Schwind", "Katsumi Inoue" ],
    "emails" : [ "schwind@nii.ac.jp", "inoue@nii.ac.jp" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 6.\n∗ This is a revised and full version (including proofs of propositions) of (Schwind and Inoue 2013).\nand the normal logic programs (NLPs) and adapt our characterization result to DLP and NLP revision operators."
    }, {
      "heading" : "1 Introduction",
      "text" : "Logic programs (LPs) under the answer set semantics are well-suited for modeling problems which involve common sense reasoning (e.g., biological networks, diagnosis, planning, etc.) Due to the dynamic nature of our environment, beliefs represented through an LP P are subject to change, i.e., because one wants to incorporate to it a new LP Q. Since there is no unique, consensual procedure to revise a set of beliefs, Alchourrón, Gärdenfors and Makinson (1985) introduced a set of desirable principles w.r.t. belief change called AGM postulates. Katsuno and Mendelzon (1992) adapted these principles to the case of propositional logic, distinguished two kind of change operations, i.e., revision and update (Katsuno and Mendelzon 1991), and characterized axiomatically each one of these change operations by a set of socalled KM postulates. Revision consists in incorporating a new information into a database that represents a static world, i.e., new and old beliefs describe the same situation but new ones are more reliable. In the case of update, the underlying world evolves with respect to the occurence of some events i.e., new and old beliefs describe two different states of the world.\nOur interests focus here on the problem of revision of logic programs. Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.\nIndeed, given the nonmonotonic nature of LPs the AGM/KM postulates can not be directly applied to logic programs (Eiter et al. 2002). However, the notion of SE models introduced by Turner (2003) provided a monotonic semantical characterization of LPs, which is more expressive than the answer set semantics. Initially, SE models were used to characterize the strong equivalence between logic programs (Lifschitz et al. 2001): precisely, two LPs have the same set of SE models if and only if they are strongly equivalent, that is to say, they admit the same answer sets, and will still do even after adding any arbitrary set of rules to them.\nBased on these structures, Delgrande et al. (2008; 2013b) adapted the AGM/KM postulates in the context of logic programming. They focused on the revision of logic programs, i.e., they proposed several revision operators and investigated their properties w.r.t. the adapted postulates. Slota and Leite (2010; 2013) exploited the same idea for update of logic programs by adapting the KM postulates in a similar way. These semantical-based belief change operations (revision and update) changed the focus from the dynamic evolution of a syntactic, rule-based representation of beliefs previously proposed in the literature to the evolution of its semantic content; these works covered a serious drawback in the field of belief revision in logic programming. In the context of update, Slota and Leite also proposed a constructive representation of such update operators. Such a result provides a sound and complete model-theoretic construction of the rational LP update operators, i.e., a\n“generic recipe” to construct all operators that fully satisfy the adaptation of the AGM/KM postulates to logic programs. It is indeed crucial when defining a logical operator in an axiomatic way to give an intuitive constructive characterization of it in order to aid the analysis of its semantic and computational properties.\nIn this paper, we give a particular consideration to the revision of generalized logic programs (GLPs) (Inoue and Sakama 1998) which are of very general form. Revising a GLP P by an other GLPQ should result in a new GLP that satisfy the adapted set of AGM postulates. We provide a characterization of the set of all GLP revision operators by associating each GLP with a certain structure, called GLP parted assignment, which consists of a pair of assignments that are independent from each other. Interestingly, the first one, called here LP faithful assignment, is similar to the structure of faithful assignment defined in (Katsuno and Mendelzon 1992) and used to characterize the (rational) KM revision operators in the propositional setting; the second one, called here well-defined assignment, can be defined independently from the first one. As a consequence, the benefit of our approach is that:\n(i) every rational LP revision operator ⋆ can be derived from a propositional revi-\nsion operator ◦ satisfying the KM postulates, with some additional conditions that are independent from ◦;\n(ii) there is a one-to-one correspondence between the set of rational LP revision\noperators and the set of all pairs of such assignments.\nOur characterization makes the refined analysis of LP revision operators easier. Indeed, we can embed the GLP revision operators into structures of Boolean lattices, that allows us to bring out some potential weaknesses in the original postulates and pave the way for the discrimination of some rational GLP revision operators.\nThe next section introduces some preliminaries about belief revision in propositional logic. We provide in Section 3 some necessary background on generalized logic programs, and we also introduce the notion on logic program revision, an axiomatic characterization of generalized logic program revision operators, and some preliminary results. Section 4 provides our main result, i.e., a constructive characterization of the axiomatic description of the GLP revision operators. We formally compare our characterization result with another recent one proposed in (Delgrande et al. 2013a); the benefit of our approach is that our construction is one-to-one, as opposite to Delgrande et al.’s one. In Section 5 we partition the class of GLP revision operators into subclasses of Boolean lattices, then we introduce and axiomatically characterize two specific classes of (rational) GLP revision operators, i.e., the skeptical and brave GLP revision operators, and lastly we provide some complexity results which are direct consequences of existing results in the propositional case. In Section 6 we consider the revision of more restricted forms of logic programs, i.e., the disjunctive logic programs (DLPs) and normal logic programs (NLPs). We adapt our characterization result to DLP revision operators and NLP revision operators. Though DLP revision operators and NLP revision operators can also be viewed as extensions of propositional revision operators, in constrast with GLP revision operators their construction does not provide us with two indepen-\ndent structures. We conclude in Section 7. The proofs of propositions are provided in an appendix.\nThis version of the paper is a revised and extended version of a published LPNMR’13 paper (Schwind and Inoue 2013). The main extensions include a comparison of our main characterization result with the one proposed in (Delgrande et al. 2013a), some complexity results, characterization results for DLP and NLP revision operators and the proofs of propositions."
    }, {
      "heading" : "2 Belief revision in propositional logic",
      "text" : ""
    }, {
      "heading" : "2.1 Formal preliminaries",
      "text" : "We consider a propositional language L defined from a finite set of propositional variables (also called atoms)A and the usual connectives.⊥ (resp.⊤) is the Boolean constant always false (resp. true). A (classical) interpretation over A is a total function from A to {0, 1}. To avoid heavy expressions, an interpretation I is also viewed as the subset of atoms from A that are true in I . For instance, if A = {p, q}, then the interpretation over A such that I (p) = 1 and I (q) = 0 is also represented as the set {p}. For the sake of simplicity, set-notations will be dropped within interpretations (except for the case where the interpretation is the empty set), e.g., the interpretation {p, q} will be simply denoted pq. The set of all interpretations is denoted Ω. An interpretation I is a model of a formula φ ∈ L, denoted I |= φ, if it makes it true in the usual truth functional way. A consistent formula is a formula that admits a model. The set mod(φ) denotes the set of models of the formula φ, i.e., mod(φ) = {I ∈ Ω | I |= φ}. Two formulae φ, ψ are said to be equivalent, denoted by φ ≡ ψ if and only if mod(φ) = mod(ψ)."
    }, {
      "heading" : "2.2 Propositional revision operators",
      "text" : "We now introduce some background on propositional belief revision. We start by introducing a revision operator as a simple function, that considers two formulae (the original formula and the new one) and that returns the revised formula:\nDefinition 1 (Propositional revision operator, equivalence between operators) A (propositional) revision operator ◦ is a mapping associating two formulae φ, ψ with a new formula, denoted φ ◦ ψ. Two revision operators ◦, ◦′ are said to be equivalent (denoted ◦ ≡ ◦′) when for all formulae φ, ψ, φ ◦ ψ ≡ φ ◦′ ψ.\nThe AGM framework (Alchourrón et al. 1985) describes the standard principles for belief revision (e.g., consistency preservation and minimality of change), which capture changes occuring in a static domain. Katsuno and Mendelzon (1991) equivalently rephrased the AGM postulates as follows:\nDefinition 2 (KM revision operator) A KM revision operator ◦ is a propositional revision operator that satisfies the following postulates, for all formulae φ, φ1, φ2, ψ, ψ1, ψ2:\n(R1) φ ◦ ψ |= ψ; (R2) If φ ∧ ψ is consistent, then φ ◦ ψ ≡ φ ∧ ψ; (R3) If ψ is consistent, then φ ◦ ψ is consistent;\n(R4) If φ1 ≡ φ2 and ψ1 ≡ ψ2, then φ1 ◦ ψ1 ≡ φ2 ◦ ψ2; (R5) (φ ◦ ψ1) ∧ ψ2 |= φ ◦ (ψ1 ∧ ψ2); (R6) If (φ ◦ ψ1) ∧ ψ2 is consistent, then φ ◦ (ψ1 ∧ ψ2) |= (φ ◦ ψ1) ∧ ψ2.\nThese so-called KM postulates capture the desired behavior of a revision operator, e.g., in terms of consistency preservation and minimality of change. We now draw the reader’s attention to the following important detail. The KM postulates also tell us that the outcome of a revision operator relies on an arbitrary syntactic distinction: one can see that a revision operator ◦ is a KM revision operator (i.e., it satisfies postulates (R1 - R6)) if and only if any revision operator equivalent to ◦ is also a KM revision operator. In this paper, since we are only interested in whether an operator satisfies a set of rationality postulates or not, only the semantic contents of the revised base play a role, that is, relevance is considered only within the models of a revised base rather than on its explicit representation. This is why from now on, abusing terms we identify a revision operator modulo equivalence, that is, we actually refer to any revision operator equivalent to it. It becomes then harmless to define the resulting revised base in a modelwise fashion, as a set of models implicitely interpreted disjunctively. As a consequence, given two propositional revision operators ◦, ◦′, one can switch between the notations ◦ ≡ ◦′ and ◦ = ◦′ since there is no longer danger of confusion.\nKM revision operators can be represented in terms of total preorders over interpretations. Indeed, each KM revision operator is associated with some faithful assignment (Katsuno and Mendelzon 1991). For each preorder ≤, ≃ denotes the corresponding indifference relation, and < denotes the corresponding strict ordering; given a binary relation ≤ over a set E and any set F ⊆ E , the set min(F ,≤) denotes the subset of “minimal” elements from F w.r.t. ≤, i.e., min(F ,≤) = {a ∈ F | ∀b ∈ F , b ≤ a ⇒ a ≤ b}.\nDefinition 3 (Faithful assignment)\nA faithful assignment is a mapping which associates with every formula φ a preorder ≤φ over interpretations such that for all interpretations I , J and all formulae φ, φ1, φ2, the following conditions hold:\n(a) If I |= φ and J |= φ, then I ≃φ J ; (b) If I |= φ and J 6|= φ, then I <φ J ; (c) If φ1 ≡ φ2, then ≤φ1=≤φ2.\nTheorem 1 (Katsuno and Mendelzon 1992 ) A revision operator ◦ is a KM revision operator if and only if there exists a faithful assignment associating every formula φ with a total preorder ≤φ such that for all formulae φ, ψ, mod(φ ◦ ψ) = min(mod(ψ),≤φ).\nExample 1 Consider the propositional language defined from the set of atoms A = {p, q}. Let φ = p ⇔ ¬q. Consider the total preorder ≤φ defined as p ≃φ q <φ pq <φ ∅. It can be easily checked that the conditions of a faithful assignment are satisfied by ≤φ. Then denote by ◦ the corresponding KM revision operator. Now, let ψ1 = ¬p ∧ q and ψ2 = p ⇔ q. Figure 1 illustrates the total preorder≤φ and graphically identifies the models of ψ1 and ψ2. We get that:\n• mod(φ ◦ ψ1) = min(mod(ψ1),≤φ) = mod(ψ1). Hence, φ ◦ ψ1 ≡ ψ1; • mod(φ ◦ ψ2) = min(mod(ψ2),≤φ) = {pq}. Hence, φ ◦ ψ2 ≡ p ∧ q.\nIn fact, an implicit consequence of Theorem 1 is that every KM revision operator is represented by a unique faithful assignment, and conversely, every faithful assignment represents a unique KM revision operator (modulo equivalence):\nProposition 1\nThere is a one-to-one correspondence between the KM revision operators and the set of all faithful assignments.\nKM revision operators include the class of distance-based revision operators (see, for instance, (Dalal 1988)), i.e., those operators characterized by a distance between interpretations:\nDefinition 4 (Distance-based revision operators) Let d be a distance between interpretations1, extended to a distance between every interpretation I and every formula φ by\nd(I , φ) =\n{\nmin{d(I , J ) | J |= φ} if φ is consistent, 0 otherwise.\nThe revision operator based on the distance d is the operator ◦d satisfying for all formulae φ, ψ, mod(φ ◦d ψ) = min(mod(ψ),≤dφ) where the preorder ≤ d φ induced by φ is defined for all interpretations I , J by I ≤dφ J if and only if d(I , φ) ≤ d(J , φ).\nThe following result is a direct consequence of Theorem 1:\n1 Actually, a pseudo-distance is enough, i.e., triangular inequality is not mandatory.\nCorollary 1 Every distance-based revision operator is a KM revision operator, i.e., it satisfies the postulates (R1 - R6).\nThe result of revising old beliefs (a propositional formula φ) by new beliefs (a propositional formula ψ) is any propositional formula whose models are models of ψ having a distance to a model of φ which is minimal among all models of ψ.\nIt is clear from Definition 4 that a distance fully characterizes the induced revision operator, that is, different choices for the distance induce different revision operators. Usual distances are dD , the drastic distance (dD (I , J ) = 1 if and only if I 6= J ), and dH the Hamming distance (dH (I , J ) = n if I and J differ on n variables). One can remark that when the drastic distance dD is used, the induced faithful assignment associates with every formula φ a two-level preorder≤φ; indeed, it can be easily verified that the revision operator based on the drastic distance dD is equivalent to the so-called drastic revision operator, which is defined syntactically as follows:\nDefinition 5 (Drastic revision operator) The drastic revision operator, denoted ◦D , is the revision operator defined for all formulae φ, ψ as\nφ ◦D ψ =\n{\nφ ∧ ψ if φ ∧ ψ is consistent, ψ otherwise.\nThis operator was first introduced in (Alchourrón et al. 1985) under the name of full meet revision function. Though “fully rational” in the sense that it satisfies all the KM rationality postulates (i.e., all AGM postulates in (Alchourrón et al. 1985)), it is often considered as unreasonable because it throws away all the old beliefs if the new formula is inconsistent with them.\nLikewise, the revision operator based on Hamming distance dH is equivalent to the well-known Dalal revision operator (Dalal 1988). In fact, in (Dalal 1988) the Dalal revision is also defined in a modelwise fashion, i.e., there is no syntactic definition of it (as opposite to the drastic revision operator, cf. Definition 5):\nDefinition 6 (Dalal revision operator) A Dalal revision operator, denoted ◦Dal , is any revision operator based on the Hamming distance.\nFrom now on, the revision operator based on the Hamming distance (i.e., the revision operator ◦dH ) will simply be referred as the Dalal revision operator, and thus will be denoted ◦Dal .\nExample 2 Let A = {p, q, r}, φ = p ∧ q ∧ ¬r , and ψ = r . We have\n• φ ◦D ψ = r . • φ ◦Dal ψ ≡ p ∧ q ∧ r .\nIt is clear from Example 2 that the Dalal revision operator has a more parsimonious behavior than the drastic revision operator, because it integrates the new information while keeping as much previous beliefs as possible.\nBefore concluding this section, let us remark that distance-based revision operators as defined above do not fully characterize KM revision operators: this comes from the fact that given two formulae φ, φ′ such that φ 6≡ φ′, one can associate within the same faithful assignment two preorders ≤φ,≤φ′ in an independent way; given that observation, one can easily build ≤φ,≤φ′ using two different distances, whereas Definition 4 requires that the same distance is used to define the total preorder ≤φ associated with any formula. However, as far as we know there does not exist in the literature any “fully rational” (with respect to postulates (R1 - R6)) revision operator of interest that is not distance-based."
    }, {
      "heading" : "3 Belief revision in Logic Programming",
      "text" : ""
    }, {
      "heading" : "3.1 Preliminaries on Logic Programming",
      "text" : "We define the syntax and semantics of generalized logic programs. We use the same notations as in (Delgrande et al. 2008). A generalized logic program (GLP) is a finite set of rules of the form\na1; . . . ; ak ;∼ b1; . . . ;∼ bl ← c1, . . . , cm ,∼ d1, . . . ,∼ dn ,\nwhere k , l ,m, n ≥ 0.\nEach ai , bi , ci , di is either one of the constant symbols ⊥, ⊤, or an atom from A; ∼ is the negation by failure; “;” is the disjunctive connective, “,” is the conjunctive connective of atoms. The right-hand and left-hand sides of r are respectively called the head and body of r . For each rule r , we define H (r)+ = {a1, . . . , ak}, H (r)− = {b1, . . . , bl}, B(r)+ = {c1, . . . , cm}, and B(r)− = {d1, . . . , dn}. For the sake of simplicity, a rule r is also expressed as follows:\nH (r)+;∼ H (r)− ← B(r)+,∼ B(r)−·\nA logic program is interpreted through its preferred models based on the answer set semantics. A (classical) model X of a GLP P (written X |= P) is an interpretation from Ω that satisfies all rules from P according to the classical definition of truth in propositional logic. mod(P) will denote the set of all models of a GLP P . An answer set X of a GLP P is a minimal (w.r.t. set inclusion) set of atoms from A that is a model of the program PX , where PX is called the reduct of P relative to X and is defined as PX = {H (r)+ ← B(r)+ | r ∈ P ,H (r)− ⊆ X ,B(r)− ∩X = ∅}. The classical notion of equivalence between programs corresponds to the correspondence of their answer sets. Recall that we denote an interpretation by dropping set-notations except for the case of the interpretation corresponding to the empty set; for instance, the set of interpretations {∅, {p}, {pq}} will be simply denoted {∅, p, pq}.\nExample 3\nConsider the logic program P =\n{\np ←∼ q, ⊥ ← p, q\n}\n. To determine AS (P), the set of\nanswer sets of P , we need to check for each interpretation X whether X is a minimal (w.r.t. set inclusion) model of PX , the reduct of P relative to X :\n• P∅ =\n{\np ← ⊤, ⊥ ← p, q\n}\n, and mod(P∅) = {p}. Since ∅ is not a model of P∅, we\nget that ∅ /∈ AS (P);\n• Pp = P∅, so mod(Pp) = {p}. Since p is a minimal (w.r.t. set inclusion) model\nof Pp , we get that p ∈ AS (P);\n• Pq = {⊥ ← p, q}, so mod(Pq) = {∅, p, q}. Hence, q is a model of Pq but is\nnot minimal w.r.t. set inclusion, since ∅ ∈ mod(Pq). Thus q /∈ AS (P); • lastly, Ppq = Pq , so mod(Ppq) = {∅, p, q}. Hence, pq is a not a model of Ppq ,\nso we get that pq /∈ AS (P);\nTherefore, AS (P) = {p}.\nSE interpretations are semantic structures characterizing strong equivalence between logic programs (Turner 2003), they provide a monotonic semantic foundation of logic programs under answer set semantics. An SE interpretation over A is a pair (X ,Y ) of interpretations over A such that X ⊆ Y . An SE model (X ,Y ) of a logic program P is an SE interpretation over A that satisfies Y |= P and X |= PY , where PY is the reduct of P relative to Y . The set SE denotes the set of all SE interpretations over A; given a logic program P , the set SE(P) denotes the set of SE models of P .\nExample 4 Consider again the logic program P defined in Example 3. We have mod(P) = {p, q}. Hence,\nSE(P) = {(X , p) ∈ SE | X ∈ mod(Pp)} ∪ {(X , q) ∈ SE | X ∈ mod(Pq)}\n= {(X , p) ∈ SE | X ∈ {p}} ∪ {(X , q) ∈ SE | X ∈ {∅, p, q}} = {(p, p), (∅, q), (q, q)}·\nThrough their SE models, logic programs are semantically described in a stronger\nway than through their answer sets, as shown in the following example.\nExample 5\nLet P1 = {p ←∼ q} and P2 =\n{\np ←∼ q, p; q ← ⊤\n}\n, and consider again the logic program\nP defined in Example 3. Then we get that\nAS (P) = AS (P1) = AS (P2) = {p},\nthat is, P , P1 and P2 admit the same answer sets. However their SE models differ:\nSE(P) = {(p, p), (∅, q), (q, q)} (cf. Example 3), SE(P1) = {(p, p), (∅, q), (q, q), (∅, pq), (p, pq), (q, pq), (pq, pq)}, SE(P2) = {(p, p), (p, pq), (q, pq), (pq, pq)},\nA program P is consistent if SE(P) 6= ∅. Two programs P and Q are said to be strongly equivalent, denoted P ≡s Q, whenever SE(P) = SE(Q). We also write P ⊆s Q if SE(P) ⊆ SE(Q). Two programs are equivalent if they are strongly equivalent, but the other direction does not hold in general (cf. Example 5). Note that Y is an answer set of P if and only if (Y ,Y ) ∈ SE(P) and no (X ,Y ) ∈ SE(P) with X ( Y exists. We also have (Y ,Y ) ∈ SE(P) if and only if Y ∈ mod(P). A set of SE interpretations S is well-defined if for every interpretation X ,Y with X ⊆ Y , if (X ,Y ) ∈ S then (Y ,Y ) ∈ S . Every GLP has a well-defined set of SE models. Moreover, from every well-defined set S of SE models, one can build a GLP P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).\nWe close this section by introducing two further notations. For every GLP P ,\nα2P is any propositional formula satisfying mod(α 2 P ) = mod(P), and α 1 P is any propositional formula satisfying mod(α1P ) = {X ∈ Ω | (X ,Y ) ∈ SE(P)}."
    }, {
      "heading" : "3.2 Logic program revision operators",
      "text" : "We now consider belief revision in the context of logic programs. Given two programs P ,Q the goal is to define a program P ⋆ Q which is the revision of P by Q. Delgrande et al. (2008; 2013b) proposed an adaptation of the KM postulates (cf. Definition 2) in the context of logic programming; this can be done using the monotonic characterization of logic programs through their SE models. First, they considered the operation of expansion of two logic programs:\nDefinition 7 (Expansion operator (Delgrande et al. 2008)) Given two programs P ,Q, the expansion of P by Q, denoted P+Q is any program R such that SE(R) = SE(P) ∩ SE(Q).\nThough the expansion of logic programs trivializes the result whenever the two input logic programs admit no common SE models, this operation is of interest in its own right. For instance, it can be observed that the intersection of two welldefined sets of SE interpretations leads to a well-defined set of SE interpretations, and thus the expansion of two GLPs is always defined as a GLP.\nExample 6 Consider again the program P from Example 3, and recall that SE(P) = {(p, p), (∅, q), (q, q)}. Let Q be the GLP Q = {q ← ⊤}, we have SE(Q) = {(q, q), (q, pq),\n(pq, pq)}. Furthermore, the GLPR =\n{\nq ← ⊤, ⊥ ← p\n}\nis such that SE(R) = {(q, q)} =\nSE(P) ∩ SE(Q). Therefore,\nP +Q =\n{\np ←∼ q, ⊥ ← p, q\n}\n+ {q ← ⊤} ≡s\n{\nq ← ⊤, ⊥ ← p\n}\n·\nWe refer the reader to (Delgrande et al. 2013b), Section 3.1 for further examples\nof the use of the expansion operator.\nExpansion of programs corresponds to the model-theoretical definition of expansion expressed through the KM postulates R2, R5 and R6. Delgrande et al.\nrephrased the full set of KM postulates (R1 - R6) in the context of GLPs. Beforehand, we define a logic program revision operator as a simple function, that considers two GLPs (the original one and the new one) and returns a revised GLP:\nDefinition 8 (LP revision operator, equivalence between LP revision operators)\nA LP revision operator ⋆ is a mapping associating two GLPs P ,Q with a new GLP, denoted P ⋆Q. Two LP revision operators ⋆, ⋆′ are said to be equivalent (denoted ⋆ ≡ ⋆′) when for all GLPs P ,Q, P ⋆Q ≡s P ⋆′ Q.\nDefinition 9 (GLP revision operator (Delgrande et al. 2008))\nA GLP revision operator ⋆ is an LP revision operator that satisfies the following postulates, for all GLPs P ,P1,P2,Q,Q1,Q2,R:\n(RA1) P ⋆Q ⊆s Q; (RA2) If P +Q is consistent, then P ⋆Q ≡s P +Q; (RA3) If Q is consistent, then P ⋆Q is consistent;\n(RA4) If P1 ≡s P2 and Q1 ≡s Q2, then P1 ⋆Q1 ≡s P2 ⋆Q2; (RA5) (P ⋆Q) +R ⊆s P ⋆ (Q+R); (RA6) If (P ⋆Q) +R is consistent, then P ⋆ (Q+R) ⊆s (P ⋆Q) +R.\nAs to the case of (propositional) KM revision operators, an LP revision operator ⋆ is a GLP revision operator if and only if any LP revision operator equivalent to ⋆ is also a GLP revision operator. This is why in the rest of the paper, as we identify a propositional revision operator modulo equivalence, we also identify an LP revision operator modulo equivalence. This allows us to define a revised program in a modelwise fashion, i.e., as its set of SE models, and given two LP revision operators ⋆, ⋆′, the notations ⋆ ≡ ⋆′ and ⋆ = ⋆′ are confunded with no harm.\nDelgrande et al. (2008) proposed a revision operator inspired from Satoh’s propositional revision operator (Satoh 1988). This operator, based on the set containment of SE interpretations, satisfies postulates (RA1 - RA5). Though it seems to have a good behavior on some instances, this operator does not satisfy (RA6), so that it does not fully respect the principle of minimality of change (see (Katsuno and Mendelzon 1989), Section 3.1 for details on this postulate). However, the whole set of postulates is consistent, as they later introduce the so-called cardinality-based revision operator (Delgrande et al. 2013b) that reduces to the Dalal revision scheme over propositional models and that satisfies all the postulates (RA1 - RA6). The following definition is a concise, equivalent reformulation of the original one introduced in (Delgrande et al. 2013b), Definition 3.10:\nDefinition 10 (Cardinality-based revision operator)\nGiven a GLP P and an interpretation Y , let formY be any propositional formula satisfying mod(formY ) = {Y }, let α(P,Y ) be any propositional formula satisfying mod(α(P,Y )) = {X ∈ Ω | (X ,Y ′) ∈ SE(P),Y ′ |= formY ◦Dal α2P}, and let αY be any propositional formula satisfying mod(αY ) = {X ∈ Ω | X ⊆ Y }. The\ncardinality-based revision operator, denoted ⋆c, is defined for all GLPs P ,Q by any program P ⋆c Q satisfying\nSE(P ⋆c Q) = {(X ,Y ) ∈ SE(Q) | Y |= α2P ◦Dal α 2 Q\nand if X ( Y then X |= α(P,Y ) ◦Dal αY }}·\nTheorem 2 (Delgrande et al. 2013b) ⋆c is a GLP revision operator.\nIn addition, we introduce below a simple, syntactically defined LP revision ope-\nrator which also satisfies the whole set of postulates (RA1 - RA6):\nDefinition 11 (Drastic LP revision operator) The drastic LP revision operator ⋆D is defined for all GLPs P ,Q as\nP ⋆D Q =\n{\nP +Q if P +Q is consistent, Q otherwise.\nProposition 2 ⋆D is a GLP revision operator.\nNote that the drastic LP revision operator is the counterpart of the propositional drastic revision operator (cf. Definition 5) for logic programs: the old program is thrown away if the new program is inconsistent with it. The cardinality-based revision operator has a more parsimonious behavior. However, Theorem 2 and Proposition 2 show that these operators are both fully satisfactory in terms of revision principles; this raises the problem on how to discard some rational operators from others. Moreover, it is not clear whether there even exist other GLP revision operators than the cardinality-based and the drastic LP revision operators. In the next section, we fill the gap and we give a constructive, full characterization of the class of GLP revision operators, that provides us a clear and complete picture of it."
    }, {
      "heading" : "4 Characterization of GLP revision operators",
      "text" : ""
    }, {
      "heading" : "4.1 Characterization result",
      "text" : "We now provide the main result of our paper, i.e., a characterization theorem for GLP revision operators. That is, we show that each GLP revision operator (i.e., each LP revision operator satisfying the postulates (RA1 - RA6)) can be characterized in terms of preorders over the set of all classical interpretations, with some further conditions specific to SE interpretations.\nDefinition 12 (LP faithful assignment) An LP faithful assignment is a mapping which associates with every GLP P a total preorder ≤P over interpretations such that for all GLPs P ,Q and all interpretations Y ,Y ′, the following conditions hold:\n(1) If Y |= P and Y ′ |= P , then Y ≃P Y ′; (2) If Y |= P and Y ′ 6|= P , then Y <P Y ′; (3) If mod(P) = mod(Q), then ≤P=≤Q.\nPlease note the similarities between an LP faithful assignment and a faithful\nassignment (cf. Definition 3). That is:\nRemark 1\nLet Φ1 be an assignment that associates with every GLP P a total preorder ≤P over interpretations, and Φ2 be and assignment that associates with every formula φ a total preorder ≤φ over interpretations. If for every GLP P , we have Φ1(P) = Φ2(α2P), then Φ1 is an LP faithful assignment if and only if Φ2 is a faithful assignment.\nDefinition 13 (Well-defined assignment)\nA well-defined assignment is a mapping which associates with every GLP P and every interpretation Y a set of interpretations, denoted by P(Y ), such that for all GLPs P ,Q and all interpretations X ,Y , the following conditions hold:\n(a) Y ∈ P(Y );\n(b) If X ∈ P(Y ), then X ⊆ Y ;\n(c) If (X ,Y ) ∈ SE(P), then X ∈ P(Y );\n(d) If (X ,Y ) /∈ SE(P) and Y |= P , then X /∈ P(Y );\n(e) If P ≡s Q, then P(Y ) = Q(Y ).\nDefinition 14 (GLP parted assignment)\nA GLP parted assignment is a pair (Φ,Ψ), where Φ is an LP faithful assignment and Ψ is a well-defined assignment.\nWe are ready to bring to light our main result:\nProposition 3\nAn LP operator ⋆ is a GLP revision operator if and only if there exists a GLP parted assignment (Φ,Ψ), where Φ associates with every GLP P a total preorder ≤P , Ψ associates with every GLP P and every interpretation Y a set of interpretations P(Y ), and such that for all GLPs P ,Q,\nSE(P ⋆Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P ),X ∈ P(Y )}·\nNote that there is no relationship between the LP faithful assignment Φ and the well-defined assignment Ψ forming a GLP parted assignment, that is, each one of these two mappings can be defined in a completely independent way.\nExample 7\nLet us consider again the GLP P =\n{\np ←∼ q, ⊥ ← p, q\n}\nfrom Example 3, and recall that\nSE(P) = {(p, p), (∅, q), (q, q)}. Note that the (classical) models of P (i.e.,mod(P) = {p, q}) correspond to the models of the propositional formula φ given in Example 1 (i.e., mod(φ) = {p, q}). Hence, due to Remark 1 the total preorder ≤P=≤φ, i.e., defined as p ≃P q <P pq <P ∅ satisfies the conditions of an LP faithful assignment (denoted Φ). Furthermore, let us consider the mapping Ψ associating with P and every interpretation Y the following sets of interpretations: P(∅) = {∅}, P(p) = {p}, P(q) = {∅, q} and P(pq) = {p, pq}. One can also check that Ψ satisfies the conditions (a - e) from Definition 13, so Ψ is a well-defined assignment. Hence, (Φ,Ψ) is a GLP parted assignment. Figure 2 gives a graphical representation of the total preorder ≤P and the sets P(Y ) for each Y ∈ Ω. In the figure, all interpretations are ordered w.r.t. ≤P (similarly to Figure 1), and for each such interpretation Y , the set of circle interpretations next to Y corresponds to the set P(Y ).\nNow, let us denote ⋆ the GLP revision operator corresponding to this GLP parted assignment, and let Q1 and Q2 be two GLPs defined as Q1 = {q ←∼ p} and\nQ2 =\n{\n⊥ ← p,∼ q, ⊥ ← q,∼ p, p;∼ p ← ⊤, q;∼ q ← ⊤·\n}\n· We get that:\n• SE(Q1) = {(∅, p), (p, p), (q, q), (∅, pq), (p, pq), (q , pq), (pq, pq)}; then accor-\nding to Proposition 3, we get that SE(P ⋆ Q1) = {(p, p), (q, q)}. Further-\nmore, the GLP R1 =\n\n\n\np ←∼ q, q ←∼ p, ⊥ ← p, q\n\n\n\nis such that SE(R1) = {(p, p), (q, q)} =\nSE(P ⋆Q1). Therefore,\nP ⋆Q1 =\n{\np ←∼ q, ⊥ ← p, q\n}\n⋆ {q ←∼ p} ≡s\n\n\n\np ←∼ q, q ←∼ p, ⊥ ← p, q\n\n\n\n·\n• SE(Q2) = {(∅, ∅), (pq, pq)}; then according to Proposition 3, we get that\nSE(P ⋆ Q2) = {(pq, pq)}. Furthermore, the GLP R2 =\n{\np ← ⊤, q ← ⊤\n}\nis such\nthat SE(R2) = {(pq, pq)} = SE(P ⋆Q2). Therefore,\nP ⋆Q2 =\n{\np ←∼ q, ⊥ ← p, q\n}\n⋆\n{\n⊥ ← p,∼ q, ⊥ ← q,∼ p, p;∼ p ← ⊤, q;∼ q ← ⊤·\n}\n≡s\n{\np ← ⊤, q ← ⊤\n}\n·\nThe SE models of Q1 and Q2 are respectively illustrated in Figures 3(a) and 3(b).\nDue to the similarities between an LP faithful assignment (cf. Definition 12) and a faithful assignment (cf. Definition 3), an interesting consequence from Theorem 1 and Proposition 3 is that every GLP revision operator can be viewed as an extension of a (propositional) KM revision operator:\nDefinition 15 (Propositional-based LP revision operator) Let ◦ be a propositional revision operator and f be a mapping from Ω to 2Ω such that for every interpretation Y , Y ∈ f (Y ) and if X ∈ f (Y ) then X ⊆ Y . The propositional-based LP revision operator w.r.t. ◦ and f , denoted ⋆◦,f , is defined for all GLPs P ,Q by\nSE(P⋆◦,fQ) =\n{\nSE(P +Q) if P +Q is consistent, {(X ,Y ) ∈ SE(Q) | Y |= α2P ◦ α 2 Q,X ∈ f (Y )} otherwise.\n⋆◦,f is said to be a propositional-based GLP revision operator if ◦ is a KM revision\noperator (i.e., satisfying postulates (R1 - R6)).\nProposition 4 An LP revision operator is a GLP revision operator if and only if it is a propositionalbased GLP revision operator.\nIn the previous section, we noticed that there is a one-to-one correspondence between the KM revision operators (modulo equivalence) and the set of all faithful assignments (cf. Proposition 1). Interestingly, we get a similar result in the case of GLP revision operators with respect to propositional-based GLP revision operators (cf. Corollary 2 below). Let us introduce an intermediate result:\nProposition 5 For all propositional-based GLP revision operators ⋆◦1,f1 , ⋆◦2,f2 , we have ⋆◦1,f1 = ⋆◦2,f2 if and only if ◦1 = ◦2 and f1 = f2.\nThis proposition tells us that if ◦1 6= ◦2 or f1 6= f2, then for some pair of GLPs P ,Q we will get P ⋆◦1,f1 Q 6≡ P ⋆◦2,f2 Q, that is to say, different choices of parameters for a propositional-based LP revision operator lead to different propositional-based LP revision operators. As a direct consequence of Propositions 4 and 5, we get that:\nCorollary 2 There is a one-to-one correspondence between the set of GLP revision operators and the set of propositional-based GLP revision operators.\nNote that the cardinality-based revision operator ⋆c (cf. Definition 10) corresponds to the propositional-based GLP revision operator ⋆◦Dal ,f1 , where ◦Dal is the Dalal revision operator (cf. Definition 6) and f1 is defined for every interpretation Y as f1(Y ) = {X ∈ Ω | X ⊆ Y and if X ( Y then X |= α(P,Y ) ◦Dal αY }, where αY is any propositional formula such that mod(αY ) = {X ∈ Ω | X ⊆ Y }, α(P,Y ) is any propositional formula satisfying mod(α(P,Y )) = {X ∈ Ω | (X ,Y ′) ∈ SE(P),Y ′ |= formY ◦Dal α2P}, and formY is any propositional formula satisfying mod(formY ) = {Y }. In addition, the drastic GLP revision operator (cf. Definition 11) corresponds to the propositional-based GLP revision operator ⋆◦D ,f2 , where ◦D is the drastic revision operator (cf. Definition 5) and f2 is defined for every interpretation Y as f2(Y ) = 2 Y . Figures 4(a) and 4(b) provide the graphical representation of these two operators in terms of parted assignments similarly to Figure 2, focusing on the GLP P from Example 3.\nRemark that in the case where P and Q have no common SE models, then a (propositional-based) GLP revision operator ⋆◦,f “rejects” as candidates for the SE models of the revised program P ⋆◦,f Q those SE interpretations whose second component is not a classical model of α2P ◦ α 2 Q; that is to say, as an upstream selection step the potential resulting SE models are chosen with respect to their second component by the underlying propositional revision operator ◦. Then, one can see from Definition 15 that the function f is used as a second filtering step that is made with respect to the first component of those preselected SE interpretations,\nand that this final selection becomes independent of the underlying input program P . Then it becomes questionable whether the postulates (RA1 - RA6) sufficiently describe the rational behavior of LP revision operators. Indeed, we will show in the next section that this “freedom” on the definition of the function f raises some issues for some specific subclasses of fully rational LP revision operators."
    }, {
      "heading" : "4.2 Comparison with other existing works",
      "text" : "As we already briefly mentionned in the introduction, Delgrande et al. (2013a) also recently proposed a constructive characterization of belief revision operators for logic programs that satisfy the whole set of postulates (RA1 - RA6). They considered various forms of logic programs, i.e., generalized, disjunctive, normal, positive, and Horn, so we shall now compare our characterization with the one given in (Delgrande et al. 2013a) for the case of GLPs:\nDefinition 16 (GLP compliant faithful assignment (Delgrande et al. 2013a))\nA GLP compliant faithful assignment is a mapping which associates every GLP P with a total preorder ≤∗P over SE interpretations such that for all GLPs P ,Q and all SE interpretations (X ,Y ), (X ′,Y ′), the following conditions hold:\n(1) If (X ,Y ) ∈ SE(P) and (X ′,Y ′) ∈ SE(P), then (X ,Y ) ≃∗P (X ′,Y ′); (2) If (X ,Y ) ∈ SE(P) and (X ′,Y ′) 6∈ SE(P), then (X ,Y ) <∗P (X ′,Y ′); (3) If P ≡s Q, then ≤P=≤Q; (4) (Y ,Y ) ≤∗P (X ,Y ).\nThe following theorem is expressed as a combination of Theorems 4 and 5 from\n(Delgrande et al. 2013a) applied to GLPs:\nTheorem 3 (Delgrande et al. 2013a)\nAn LP revision operator ⋆ is a GLP revision operator (i.e., it satisfies postulates (RA1 - RA6)) if and only if there exists a GLP compliant faithful assignment associating every GLP P with a total preorder ≤∗P such that for all GLPs P ,Q, SE(P ⋆Q) = min(SE(Q),≤∗P). 2\nSince both our GLP parted assignments and Delgrande et al.’s GLP compliant faithful assignments characterize the class of GLP revision operators, there must exist a relationship between the two structures. We denote by GLPpart the set of all GLP parted assignments and GLPfaith the set of all GLP compliant faithful assignments. We now formally establish a correspondence between the two sets.\n2 In (Delgrande et al. 2013a), an additional postulate is considered in the characterization theorems, namely (Acyc). However, it is harmless to omit this postulate here since (Acyc) is a logical consequence of the postulates (RA1 - RA6) in the case of generalized logic programs (cf. (Delgrande et al. 2013a), Theorem 2).\nDefinition 17 Let σpart→faith be a binary relation on GLPpart × GLPfaith defined as follows. For every (Φ,Ψ) ∈ GLPpart (where Φ associates every GLP P with a total preorder ≤P , and Ψ associates every GLP P and every interpretation Y with a set of interpretations P(Y )), and for every Γ ∈ GLPfaith (where Γ associates every GLP P with a total preorder ≤∗P), we have ((Φ,Ψ),Γ) ∈ σpart→faith if and only if for every GLP P , for all interpretations X ,Y ,Y ′, X ⊆ Y , the following conditions are satisfied:\n(i) (Y ,Y ) ≤∗P (Y ′,Y ′) if and only if Y ≤P Y ′, and\n(ii) (X ,Y ) ≤∗P (Y ,Y ) if and only if X ∈ P(Y ).\nWe show now that a pair of assignments from GLPpart × GLPfaith satisfies the relation σpart→faith if and only if represent both assignments represent the same GLP revision operator:\nProposition 6 For every (Φ,Ψ) ∈ GLPpart and every Γ ∈ GLPfaith , ((Φ,Ψ),Γ) ∈ σpart→faith if and only if for all GLPs P ,Q, min(SE(Q),≤∗P) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q), ≤P),X ∈ P(Y )}.\nWhereas our GLP parted assignments are formed of two structures which are independent from each other (an LP faithful assignment used to order the second components of SE interpretations, and a well-defined assignment selecting the first component of SE interpretations), Delgrande et al.’s GLP compliant faithful assignments consist of a single structure, i.e., a set of total preoders over SE interpretations. Though it may look simpler to represent a GLP revision operator through a single assignment, it turns out that the induced characterization (cf. Theorem 3) is not a one-to-one correspondence; more precisely, σpart→faith is not a function and as a consequence, a given GLP revision operator can be represented by different GLP compliant faithful assignments. Roughly speaking, this is due to the fact that totality required by preorders ≤∗P is actually not needed. Many comparisons between pairs of SE interpretations within a total preorder ≤∗P are irrelevant to the GLP revision operator they correspond to. This is illustrated in the following example:\nExample 8 Consider again the GLP P from Example 3 and the GLP parted assignment (Φ,Ψ) focusing on P depicted in Figure 2. Then Figure 5 depicts three total preorders ≤1P , ≤ 2 P and ≤ 3 P induced from three different GLP compliant faithful assignments Γ1, Γ2 and Γ3 which both correspond to the GLP parted assignment (Φ,Ψ), i.e., ((Φ,Ψ),Γ1), ((Φ,Ψ),Γ2), ((Φ,Ψ),Γ3) ∈ σpart→faith . It can be easily checked that for any GLP Q, min(SE(Q),≤1P) = min(SE(Q),≤ 2 P) = min(SE(Q),≤ 3 P). The SE interpretations enclosed in dashed boxes correspond to those (X ,Y ) ∈ {(∅, p), (∅, pq), (q, pq)} whose comparison with other SE interpretations is irrelevant to the represented GLP revision operator, as far as one has (Y ,Y ) <iP (X ,Y ) for i ∈ {1, 2, 3}.\nIn fact, one can see that as soon as the language contains at least two propositional variables, e.g., {p, q} ⊆ A with p 6= q, then the GLP P satisfying (p, p), (q, q) ∈ SE(P) and (∅, p), (∅, q) /∈ SE(P) can be associated through a GLP compliant faithful assignment with at least three different total preorders; an arbitrary relative ordering between the SE interpretations (∅, p) and (∅, q) will have no effect on the corresponding GLP revision operator.\nRemoving the property of totality from preorders involved in a GLP compliant faithful could be an alternative towards establishing another one-to-one correspondence with GLP revision operators. However, our GLP parted assignments make clear the different roles played by the first and second components of SE interpretations in terms of GLP revision. One the one hand the second components are totally ordered, on the other hand the first components are arbitrarily selected as possible condidates for SE interpretations. This allows us to make precise the link with propositional faithful assignments and propositional revision operators, which would not be clear with a slight adjustment of GLP compliant faithful assignments. The next section shows how our propositional-based GLP revision operator facilitate the comprehension and analysis of GLP revision."
    }, {
      "heading" : "5 GLP revision operators embedded into Boolean lattices",
      "text" : "For every propositional revision operator ◦, let GLP(◦) denote the set of all propositional-based LP revision operators w.r.t. ◦. One can remark that from Proposition 5, the set {GLP(◦) | ◦ is a KM revision operator} forms a partition of the class of all GLP revision operators. Let us now take a closer look to the set of GLP revision operators GLP(◦) when we are given any specific KM revision operator ◦:\nDefinition 18\nLet ◦ be a propositional revision operator. We define the binary relation ◦ over GLP(◦) as follows: for all propositional-based LP revision operators ⋆◦,f1 , ⋆◦,f2 , ⋆◦,f1 ◦ ⋆◦,f2 if and only for every interpretation Y , we have f2(Y ) ⊆ f1(Y ).\nOne can see that for each revision operator ◦, the set (GLP(◦), ◦) forms a structure that is isomorphic to a Boolean lattice3, and the careful reader will notice that (GLP(◦), ◦) precisely corresponds to the product of the Boolean lattices {(BY ,⊆) | Y ∈ Ω}, where BY = {Z∪{Y } | Z ∈ 22 Y \\Y }. The following result shows that this lattice structure can be used to analyse the relative semantic behavior of GLP revision operators from (GLP(◦), ◦).\nProposition 7 Let ◦ be a KM revision operator. It holds that for all GLP revision operators ⋆1, ⋆2 ∈ GLP(◦), ⋆1 ◦ ⋆2 if and only if for all GLPs P ,Q, we have AS (P ⋆1 Q) ⊆ AS (P ⋆2 Q).\nThis result paves the way for the choice of a specific GLP revision operator depending on the desired “amount of information” provided by the revised GLP in terms of number of its answer sets. Precisely, any GLP revision operator ⋆◦,f can be specified from an answer set point of view by the following roadmap. Since in the case where P + Q is consistent, we always have P ⋆◦,f Q = P + Q, the intuition underlying this procedure only applies when the programs considered for the revision have no common SE model. First, one chooses a KM revision operator ◦ whose role is to filter the undesired answer sets of the resulting revised program: only the models Y of the formula resulting from the revision of P by Q in the propositional sense should be selected as “potential answer set candidates”. Then, the function f plays a role in filtering those preselected candidates Y , so that f can be defined according to the following intuition: the more interpretations X ( Y are included in f (Y ), the less likely the interpretation Y will actually be an answer set of the resulting revised program. More precisely, the presence of a given interpretation X ( Y in f (Y ) is enough to discard Y as being an answer set of the resulting revised program when (X ,Y ) is an SE model of Q.\nThis brings in light that, depending on the “position” of the GLP revision operator ⋆◦,f in the lattice (GLP(◦), ◦), when revising P by Q one may expect divergent results for AS (P ⋆◦,f Q). We illustrate this claim by considering two specific classes of GLP revision operators that correspond respectively to the suprema and infima of lattices (GLP(◦), ◦) for all KM revision operators ◦. The first “extreme” operators are defined as follows:\nDefinition 19 (Skeptical GLP revision operators) The skeptical GLP revision operators, denoted ⋆◦S are the propositional-based GLP revision operators ⋆◦,f where f is defined for every interpretation Y by f (Y ) = 2Y .\nNote that skeptical GLP revision operators include the drastic GLP revision operator ⋆D (cf. Definition 11), i.e., ⋆D = ⋆ ◦D S where ◦D is the (propositional) drastic revision operator. For each propositional revision operator ◦, we clearly have ⋆◦S = inf (GLP(◦), ◦). We provide now an axiomatic characterization of the\n3 A Boolean lattice is a partially ordered set (E ,≤E ) which is isomorphic to the set of subsets of some set F together with the usual set-inclusion operation, i.e., (2F ,⊆).\nskeptical GLP revision operators in order to get a clearer view of their general behavior:\nProposition 8 The skeptical GLP revision operators are the only GLP revision operators ⋆ such that for all GLPs P ,Q, whenever P+Q is inconsistent, we haveAS (P⋆Q) ⊆ AS (Q).\nRemark that the drastic GLP revision operator (cf. Definition 11), i.e., the skeptical GLP revision operator based on the propositional drastic revision operator ⋆◦DS , is a specific case from the result given in Proposition 8 where AS (P⋆◦DS Q) = AS (Q) whenever P +Q is inconsistent.\nWe now introduce another class of GLP revision operators which correspond to\nthe other “extreme cases” with respect to lattices (GLP(◦), ◦):\nDefinition 20 (Brave GLP revision operators) The brave GLP revision operators, denoted ⋆◦B are the propositional-based GLP revision operators ⋆◦,f where f is defined for every interpretationY by f (Y ) = {Y }.\nWe get now that for each propositional revision operator ◦, ⋆◦B = sup(GLP(◦),\n◦). The brave operators are axiomatically characterized as follows:\nProposition 9 The brave GLP revision operators are the only GLP revision operators ⋆◦,f such that for all GLPs P ,Q, whenever P + Q is inconsistent, we have AS (P ⋆◦,f Q) = mod(α2P ◦ α 2 Q).\nLet us remark as a specific case that the brave GLP revision operator based on the propositional drastic revision operator, i.e., the operator ⋆◦DB , satisfies AS (P ⋆ ◦D B Q) = mod(Q) whenever P +Q is inconsistent.\nThe following representative example illustrates how much the behavior of skep-\ntical and brave GLP revision operators diverge:\nExample 9\nConsider ◦D , i.e., the propositional drastic revision operator. Let P =\n\n\n\np ← ⊤, q ← ⊤, ⊥ ← r\n\n\n\nand Q = {⊥ ← p, q,∼ r}. We have AS (P) = {p, q}, AS (Q) = {∅}, and {\nAS (P ⋆◦DS Q) = {∅}, AS (P ⋆◦DB Q) = {∅, p, q, r , pr , qr , pqr}·\nThough they are rational LP revision operators w.r.t. the postulates (RA1 - RA6), skeptical and brave operators have a rather trivial, thus undesirable behavior. Consider first the case of skeptical operators and assume that the proposition p is believed to be false, then learned to be true. That is, {⊥ ← p} ⊆ P and Q = {p ← ⊤}. Then one obtains that AS (P ⋆◦S Q) ⊆ AS (Q), that is, AS (P ⋆ ◦ S Q) ⊆ {p}, i.e., for any such program P , on learning that p is true the revision states that only p may be true, which holds independently from the choice of the KM revision\noperator ◦. On the other hand, brave operators only focus on classical models of logic programs P ,Q to compute P ⋆◦B Q (whenever P + Q is inconsistent), thus they do not take into consideration the inherent, non-monotonic behavior of logic programs. As a consequence, programs P ⋆◦B Q will often admit many answer sets that are actually irrelevant to the input programs P and Q.\nStated otherwise, skeptical and brave GLP revision operators are dual sides of a “drastic” behavior for the revision. These operators are representative examples that provide some “bounds” of the complete picture of GLP revision operators GLP(◦), for each KM revision operator ◦. Discarding such drastic behaviors may call for additional postulates in order to capture more parsimonious revision procedures in logic programming, as for instance the cardinality-based revision operator (cf. Definition 10) which is neither brave nor skeptical. Then it seems necessary to refine the existing properties that every rational revision operator should satisfy so that the answer sets of the revised program P ⋆◦,f Q fall “between” these two extremes (i.e., between AS (Q) and mod(P ◦ Q) in the sense of set inclusion).\nAnother benefit from our characterization result is that one can easily derive computational results by exploiting existing ones from propositional revision. We assume that the reader is familiar with the basic concepts of computational complexity, in particular with the classes P, NP and coNP (see (Papadimitriou 1994) for more details). Higher complexity classes are defined using oracles. In particular PC corresponds to the class of decision problems that are solved in polynomial time by deterministic Turing machines using an oracle for C in polynomial time. For instance, Θp2 = P NP[O(log n)] is the class of problems that can be solved in polynomial time by a deterministic Turing machine using a number of calls to an NP oracle bounded by a logarithmic function of the size of the input representation of the problem.\nWe focus here on the the model-checking problem (Liberatore and Schaerf 2001) for LP revision operators. In the propositional case, the model-checking problem consists in deciding whether a (propositional) interpretation is supported by a revised formula:\nProblem 1 (MC(◦))\n• Input: A propositional revision operator ◦, two formulae φ, ψ and an inter-\npretation I ,\n• Question: Does I |= φ ◦ ψ hold?\nThe model-checking problem for the drastic revision operator (cf. Definition 5) is coNP-complete, while it is Θp2 -complete for the Dalal revision operator (cf. Definition 6):\nProposition 10 MC(◦D ) is coNP-complete.\nTheorem 4 (Liberatore and Schaerf 2001 ) MC(◦Dal ) is Θ p 2-complete.\nSimilarly one can consider the model-checking problem for LP revision operators which consists in deciding whether an SE interpretation is an SE model of a revised program:\nProblem 2 (MCSE(⋆))\n• Input: An LP revision operator ⋆, two GLPs P ,Q and an SE interpretation\n(X ,Y ),\n• Question: Does (X ,Y ) belong to SE(P ⋆Q)?\nRemark that given an SE interpretation (X ,Y ) and a logic program P , checking whether (X ,Y ) is an SE model of P is in P: computing the program PY , i.e., the reduct of P relative to Y , is performed in polynomial time; then it is enough to check whether Y |= P and X |= PY which is performed in polynomial time. Interestingly, when f is computed in polynomial time the model-checking problem for propositional-based LP revision operators ⋆◦,f is not harder than the counterpart problem for the propositional revision operator ◦. Obviously enough, this applies for both skeptical and brave GLP revision operators, so Proposition 10 and Theorem 4 provide us with the following complexity results:\nCorollary 3\n• MCSE(⋆ ◦D S ) and MCSE(⋆ ◦D B ) are coNP-complete; • MCSE(⋆ ◦Dal S ) and MCSE(⋆ ◦Dal B ) are Θ p 2-complete."
    }, {
      "heading" : "6 The case of disjunctive and normal logic programs",
      "text" : "In this section we take a look at more restrictive forms of programs, i.e., the disjunctive logic programs and the normal logic programs. A disjunctive logic program (DLP) is a GLP where rules are of the form\na1; . . . ; ak ← b1, . . . , bl ,∼ c1, . . . ,∼ cm ,\nwhere k , l ,m ≥ 0. A normal logic program (NLP) is a DLP where k = 1.\nLet us recall that every GLP has a well-defined set S of SE models, which requires that (Y ,Y ) ∈ S for every (X ,Y ) ∈ S , and that conversely, for every well-defined set S of SE interpretations one can build a GLP P such that SE(P) = S . Since NLPs and DLPs are syntactically more restrictive than GLPs, these programs are characterized by sets of SE models satisfying stronger conditions. A set of SE interpretations S is said to be:\n• complete if it is well-defined and for all interpretations X ,Y ,Z , if Y ⊆ Z\nand (X ,Y ), (Z ,Z ) ∈ S then also (X ,Z ) ∈ S ;\n• closed under here-intersection if it is complete and for all interpretations\nX ,Y ,Z , if (X ,Z ), (Y ,Z ) ∈ S then also (X ∩ Y ,Z ) ∈ S .\nEach DLP (respectively, NLP) has a complete (respectively, closed under hereintersection) set of SE models. Conversely, if a set of SE interpretations S is complete (respectively, closed under here-intersection) then one can build a DLP (respectively, NLP) P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007). For instance, one can easily check that:\n• the logic program P =\n{\np ←∼ q, ⊥ ← p, q\n}\nfrom Example 3 is a NLP and SE(P)\nis well-defined, complete and closed under here-intersection;\n• the logic program P2 =\n{\np ←∼ q, p; q ← ⊤\n}\nfrom Example 5 is a DLP and SE(P2)\nis well-defined and complete, but not closed under here-intersection;\n• the logic program Q2 =\n{\n⊥ ← p,∼ q, ⊥ ← q,∼ p, p;∼ p ← ⊤, q;∼ q ← ⊤·\n}\nfrom Example 7 is\na GLP and SE(Q) is well-defined but not complete.\nWhen revising a logic program by another one, one expects the resulting revised\nprogram to be expressed in the same language as the input programs.\nDefinition 21 (DLP/NLP revision operator) A DLP revision operator (respectively, a NLP revision operator) ⋆ is an LP revision operator associating two DLPs (respectively, two NLPs) P ,Q with a new DLP (respectively, a new NLP) P ⋆Q, and which satisfies postulates (RA1 - RA6).\nWe first remark that both sets of DLP revision operators and NLP revision operators are not empty. Indeed, one can observe that the intersection of two complete sets of SE interpretations is also complete, thus the expansion of two DLPs leads to a DLP. This also applies for NLPs. As a direct consequence, the drastic LP revision operator (cf. Definition 11) is both a DLP revision operator and a NLP revision operator. In fact, we have the more general result:\nProposition 11 The skeptical GLP revision operators are both DLP revision operators and NLP revision operators.\nHowever, the above result does not apply for all GLP revision operators. That is to say, there exist some GLP revision operators which associate two NLPs with a GLP which is not a DLP. Hence, our sound and complete construction of GLP revision operators does not hold anymore for DLP and NLP revision operators. For instance, brave GLP revision operators are neither DLP revision operators nor NLP revision operators, as shown in the following example:\nExample 10\nLet P =\n\n\n\n⊥ ←∼ p,∼ q, ⊥ ← q,∼ p, ⊥ ← p, q\n\n\n\nand Q = {q ← ⊤} be two NLPs. We have that\nSE(P) = {(∅, p), (p, p)} and SE(Q) = {(q, q), (q, pq), (pq, pq)}. Consider the brave GLP revision operator ⋆◦DB based on the propositional drastic revision operator. Then one can verify that SE(P ⋆◦DB Q) = {(q, q), (pq, pq)} is not a complete set of SE interpretations, thus P ⋆◦DB Q cannot be represented as a DLP.\nAs a consequence, our characterization result from Proposition 3 does not hold anymore for DLP/NLP revision operators. Nevertheless, we provide below a representation of both DLP and NLP revision operators in terms of two structures where the first one is an LP faithful assignment adapted to DLPs/NLPs and the second one is a well-defined assignment “strengthened” by some further conditions.\nDefinition 22 (DLP/NLP faithful assignment) A DLP faithful assignment (respectively, a NLP faithful assignment) is a mapping which associates every DLP (respectively, every NLP) with a total preorder over interpretations such that conditions (1 - 3) of an LP faithful assignment are satisfied.\nDefinition 23 (Complete assignment) Let Φ be a DLP faithful assignment which associates every DLP P with a total preorder ≤P . A Φ-based complete assignment is a mapping which associates with every DLP P and every interpretation Y a set of interpretations denoted by PΦ(Y ), such that conditions (a - e) of a well-defined assignment are satisfied as well as the following further condition, for all interpretations X ,Y ,Z :\n(f) If X ∈ PΦ(Y ), Y ≃P Z and Y ⊆ Z then X ∈ PΦ(Z ).\nA pair (Φ,ΨΦ), where Φ is a DLP faithful assignment and ΨΦ is a Φ-based complete assignment, is called a DLP parted assignment.\nDefinition 24 (Normal assignment) Let Φ be a NLP faithful assignment. A Φ-based normal assignment is a mapping which associates with every NLP P and every interpretation Y a set of interpretations denoted by PΦ(Y ), such that conditions (a - f) of a complete assignment are satisfied as well as the following further condition, for all interpretations X ,Y ,Z :\n(g) If X ,Y ∈ PΦ(Z ) then X ∩ Y ∈ PΦ(Z ).\nA pair (Φ,ΨΦ), where Φ is a NLP faithful assignment and ΨΦ is a Φ-based normal assignment, is called a NLP parted assignment.\nWe are ready to provide our characterization results for DLP revision operators\nand NLP revision operators:\nProposition 12 An LP operator ⋆ is a DLP (resp. NLP) revision operator if and only if there exists a DLP (resp. NLP) parted assignment (Φ,ΨΦ), where Φ associates with every DLP (resp. NLP) P a total preorder ≤P , ΨΦ is a Φ-based complete (resp. normal) assignment which associates with every DLP (resp. NLP) P and every interpretation Y a set of interpretations PΦ(Y ), and such that for all DLPs (resp. NLPs) P ,Q,\nSE(P ⋆Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P),X ∈ PΦ(Y )}·\nAs to the case of our characterization of GLP revision operators, Proposition 12 provides us with sound and complete constructions of DLP and NLP revision operators in terms of total preorders over propositional interpretations and some further conditions specific to SE interpretations. Furthermore, because both constructions are similar to the one of GLP revision operators, without stating it formally one\ncan straightforwardly establish a one-to-one correspondence between DLP/NLP revision operators and propositional-based LP revision operators (cf. Definition 15) satisfying some further conditions on the function f very similar to conditions (f) and (g). Indeed, one can see from Definition 23 and 24 that the two structures involved in DLP/NLP parted assignments are not independent anymore, since by condition (f) the Φ-based complete and normal assignments should both be aligned with the corresponding faithful assignment. As a consequence, these structures are more complex than those of GLP parted assignments and similar embeddings of DLP/NLP revision operators into Boolean lattices are no more applicable. A deeper investigation of the type of ruling structures for Φ-based complete and normal assignments is out of the scope of this paper, but constitutes an interesting direction to explore in a future work."
    }, {
      "heading" : "7 Conclusion",
      "text" : "In this paper, we pursued some previous work on revision of logic programs, where the adopted approach is based on a monotonic characterization of logic programs using SE interpretations. We gave a particular attention to the revision of generalized logic programs (GLPs) and characterized the class of rational GLP revision operators in terms of total orderings among classical interpretations with some further conditions specific to SE interpretations. The constructive characterization we provided facilitates the comprehension of the semantic properties of GLP revision operators by drawing a clear, complete picture of them. Interestingly, we showed that a GLP revision operator can be viewed as an extension of a rational propositional revision operator: each propositional revision operator corresponds to a specific subclass of GLP revision operators, and a GLP revision operator from a particular subclass can be specified independentely of the propositional revision operator under consideration. Moreover, we showed that each one of these subclasses can be embedded into a Boolean lattice whose infimum and supremum, the so-called skeptical and brave GLP revision operators, have some relatively drastic behavior. In addition, we adjusted our representation structures and provided sound and complete constructions for two more specific classes of logic programs, i.e., the disjunctive and normal logic programs.\nOur results make easier the improvement of the current AGM framework in the context of logic programming. Indeed, though the subclasses of skeptical and brave revision operators are fully satisfactory w.r.t. the AGM revision principles, their behavior is shown to be rather trivial. This may call for additional postulates which would aim to capture more parsimonious, “balanced” classes of revision operators.\nAs to the case of update of logic programs Slota and Leite (2013) argued that semantic rule updates based on SE models seem to be inappropriate. Indeed they showed that in presence of the irrelevance-of-syntax postulate (whose counterpart in the context of revision is (RA4)), semantic rule update operators based on SE models violate some reasonable properties for rule updates, i.e., dynamic support and fact update (see (Slota and Leite 2013) for more details). The property of dynamic support can be expressed unformally as follows: an rule update operator ⊕\nsatisfies dynamic support if every atom true in an answer set from any updated program P ⊕ Q should be supported by a rule in P ∪ Q, i.e., it should have some “justification” in either the original program or the new one. The property of fact update requires some notion of atom inertia when updating a consistent set of facts (i.e., a set of rules of the type p ← ⊤ where p is an atom) by a consistent set of facts. Both of these properties require rule update operators to have a reasonable “syntactic” behavior, away from the purely semantic approach represented by the adapted AGM postulates. In (Slota and Leite 2012) the same authors successfully reconciliate semantic-based and syntax-based approaches to updating logic programs: they considered different characterizations of logic programs in terms of RE models (standing for robust equivalence models) that proved to be a more suitable semantic fundation for rule updates than SE models. A straightforward direction of research is to investigate whether these richer characterizations of logic programs suit to revision operators.\nAdditionally, we will investigate the case of logic program merging operators (merging can be viewed as a multi-source generalization of belief revision, see for instance (Konieczny and Pino Pérez 2002)). Indeed it is not even known whether there exists a fully rational merging operator, i.e., that satisfies the whole set of postulates proposed by Delgrande et al. (2009; 2013b) for logic program merging operators based on SE models."
    }, {
      "heading" : "Appendix: Proofs of Propositions",
      "text" : "Proposition 1 There is a one-to-one correspondence between the KM revision operators and the set of all faithful assignments."
    }, {
      "heading" : "Proof",
      "text" : "Let ◦1, ◦2 be two KM revision operators. From Theorem 1 one can build two faithful assignments associating respectively with every formula φ the total preorders ≤1φ (for the first faithful assignment) and ≤ 2 φ (for the second one), such that for all formulae φ, ψ, mod(φ ◦1 ψ) = min(mod(ψ),≤1φ) and mod(φ ◦2 ψ) = min(mod(ψ), ≤2φ). Assume now that ◦1 6= ◦2. This means that there exist two propositional formulae φ, ψ such that φ ◦1 ψ 6≡ φ ◦2 ψ, so mod(φ ◦1 ψ) 6= mod(φ ◦2 ψ), thus min(mod(ψ),≤1φ) 6= min(mod(ψ),≤ 2 φ). Hence, ≤ 1 φ 6=≤ 2 φ, so the two faithful assignments associated respectively with ◦1 and ◦2 are different. Conversely, assume that the two faithful assignments associated respectively with ◦1 and ◦2 are different. Then, there exists a formula φ such that ≤1φ 6=≤ 2 φ. This means that there exists two interpretations I , J such that I ≤1φ J and J < 2 φ I . Let ψ be any formula such that mod(ψ) = {I , J}. We have I ∈ min(mod(ψ),≤1φ) and I /∈ min(mod(ψ),≤ 2 φ). Hence, mod(φ ◦1 ψ) 6= mod(φ ◦2 ψ), or equivalently, φ ◦1 ψ 6≡ φ ◦2 ψ. This means that ◦1 6= ◦2.\nProposition 2 ⋆D is a GLP revision operator."
    }, {
      "heading" : "Proof",
      "text" : "Let P ,Q be two logic programs. The fact that P ⋆D Q returns a GLP when P ,Q are both GLPs is obvious from the definition. Postulates (RA1 - RA4) are directly satisfied from the definition. (RA5 - RA6) Let P ,Q,R be three GLPs. If (P⋆DQ)+R is not consistent then (RA5) is trivially satisfied, so assume that (P ⋆D Q) +R is consistent. We have to show that (P⋆DQ)+R ≡s P⋆D (Q+R). We fall now into two cases. Assume first that P+Q is consistent. By definition, (P⋆DQ)+R = P+Q+R. Yet since (P ⋆D Q) + R is consistent, so is P + Q +R, thus we get by definition P ⋆D (Q + R) = P + Q + R. Therefore, (P ⋆D Q) + R ≡s P ⋆D (Q + R). Now, assume that P +Q is not consistent. By definition, (P ⋆D Q) +R = Q+R. Since P + Q is not consistent, we also have P + Q +R not consistent. So by definition P ⋆D (Q+R) = Q+R. Hence, (P ⋆D Q) +R ≡s P ⋆D (Q+R).\nProposition 3 An LP operator ⋆ is a GLP revision operator if and only if there exists a pair (Φ,Ψ), where Φ is an LP faithful assignment associating with every GLP P a total preorder ≤P , Ψ is a well-defined assignment associating with every GLP P and every interpretation Y a set of interpretations P(Y ), and such that for all GLPs P ,Q,\nSE(P ⋆Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P ),X ∈ P(Y )}·"
    }, {
      "heading" : "Proof",
      "text" : "(Only if part) In this proof, for every well-defined set of SE interpretations S , lp(S ) denotes any GLP P such that SE(P) = S . To alleviate notations, when S is of the form {(Y ,Y ) | Y ∈ E} for some set of interpretations E , we write lp(E ) instead of lp(S ). For instance, lp({(Y ,Y ), (Y ′,Y ′), (Y (2),Y (2))}) will simply be denoted by lp({Y ,Y ′,Y (2)}). The proof exploits on several occasions the following remarks:\nRemark 2 If ⋆ is an LP revision operator satisfying the postulates (RA5) and (RA6), then for all GLPs P ,Q,R such that (P ⋆ Q) + R is consistent, we have (P ⋆ Q) + R ≡s P ⋆ (Q+R).\nRemark 3 For all sets of interpretations E ,F , lp(E ) + lp(F ) ≡s lp(E ∩ F ).\nRemark 4 Let ⋆ be an LP revision operator satisfying the postulates (RA1) and (RA3). Then for any GLP P and any non-empty set of interpretations E , mod(P ⋆ lp(E )) 6= ∅ and mod(P ⋆ lp(E )) ⊆ E .\nLet ⋆ be a GLP revision operator. For every GLP P , define the relation ≤P over interpretations such that ∀Y ,Y ′ ∈ Ω, Y ≤P Y ′ iff Y |= P ⋆ lp({Y ,Y ′}). Moreover, for every GLP P , ∀Y ∈ Ω, let P(Y ) = {X ⊆ Y | (X ,Y ) ∈ SE(P ⋆ lp({(X ,Y ), (Y ,Y )}))}. Let P be any GLP. We first show that ≤P is a total preorder. Let Y ,Y ′,Y (2) ∈ Ω. (Totality of ≤P): By Remark 4, Y |= P ⋆ lp({Y ,Y ′}) or Y ′ |= P ⋆ lp({Y ,Y ′}). Hence, Y ≤P Y ′ or Y ′ ≤P Y . (Reflexivity of ≤P): By Remark 4, Y |= P ⋆ lp({Y }), so Y ≤P Y . (Transitivity of ≤P): Assume towards a contradiction that Y ≤P Y ′, Y ′ ≤P Y (2) and Y 6≤P Y (2). We consider two cases: Case 1: (P ⋆ lp({Y ,Y ′,Y (2)})) + lp({Y ,Y (2)}) is consistent. Then we have\n(P ⋆ lp({Y ,Y ′,Y (2)})) + lp({Y ,Y (2)})\n≡s P ⋆ (lp({Y ,Y ′,Y (2)}) + lp({Y ,Y (2)})) (by Remark 2) ≡s P ⋆ lp({Y ,Y (2)}) (by Remark 3)·\nSince Y 6≤P Y (2), by definition of ≤P we get that Y 6|= P ⋆ lp({Y ,Y (2)}), hence Y 6|= P ⋆ lp({Y ,Y ′,Y (2)}). By Remark 4, there are two remaining cases:\n(i) Y ′ |= P ⋆ lp({Y ,Y ′,Y (2)}). In this case, (P ⋆ lp({Y ,Y ′,Y (2)})) + lp({Y ,Y ′}) is\nconsistent, so\n(P ⋆ lp({Y ,Y ′,Y (2)})) + lp({Y ,Y ′})\n≡s P ⋆ (lp({Y ,Y ′,Y (2)}) + lp({Y ,Y ′})) (by Remark 2) ≡s P ⋆ lp({Y ,Y ′}) (by Remark 3)·\nSince Y ≤P Y ′, by definition of ≤P we get that Y |= P ⋆ lp({Y ,Y ′}), hence Y |= P ⋆ lp({Y ,Y ′,Y (2)}). which contradicts the previous conclusion that Y 6|= P ⋆ lp({Y ,Y ′,Y (2)}).\n(ii) Y ′ 6|= P ⋆ lp({Y ,Y ′,Y (2)}). Since we also have that Y 6|= P ⋆ lp({Y ,Y ′,Y (2)}),\nby Remark 4 we must have that Y (2) |= P ⋆ lp({Y ,Y ′,Y (2)}) In this case, (P ⋆ lp({Y ,Y ′,Y (2)})) + lp({Y ′,Y (2)}) is consistent, so\n(P ⋆ lp({Y ,Y ′,Y (2)})) + lp({Y ′,Y (2)})\n≡s P ⋆ (lp({Y ,Y ′,Y (2)}) + lp({Y ′,Y (2)})) (by Remark 2) ≡s P ⋆ lp({Y ′,Y (2)}) (by Remark 3)·\nSince Y ′ ≤P Y (2), by definition of ≤P we get that Y ′ |= P ⋆ lp({Y ′,Y (2)}), hence Y ′ |= P ⋆ lp({Y ,Y ′,Y (2)}), which is a contradiction.\nCase 2: (P⋆lp({Y ,Y ′,Y (2)}))+lp({Y ,Y (2)}) is not consistent. Then by Remark 4, Y ′ |= P⋆lp({Y ,Y ′,Y (2)}). Then (P⋆lp({Y ,Y ′,Y (2)}))+lp({Y ,Y ′}) is consistent, and by using Remark 2 and 3 and following similar reasonings as in (i), we get that Y ′ |= P⋆lp({Y ,Y ′}) and Y 6|= P⋆lp({Y ,Y ′}). By definition of ≤P this contradicts Y ≤P Y ′ and concludes the proof that ≤P is a total preorder.\nNow, let Q be any GLP. We have to show that SE(P ⋆Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P),X ∈ P(Y )}. Let us denote by S the latter set and first show the first inclusion SE(P ⋆Q) ⊆s S. Let (X ,Y ) ∈ SE(P ⋆ Q) and let us show that (i) (X ,Y ) ∈ SE(Q), (ii) ∀Y ′ |= Q,Y ≤P Y ′ and that (iii) X ∈ P(Y ). (i) is direct from (RA1). For (ii), let Y ′ |= Q. Since ⋆ returns a GLP, SE(P ⋆Q) is well-defined. That is, since (X ,Y ) ∈ SE(P ⋆ Q), we have Y |= P ⋆ Q. Therefore, (P ⋆Q) + lp({Y ,Y ′}) is consistent. So by Remark 2 and 3, Y |= P ⋆ lp({Y ,Y ′}). Hence, Y ≤P Y ′. For (iii), since (X ,Y ) ∈ SE(P⋆Q), (P⋆Q)+lp({(X ,Y ), (Y ,Y )}) is consistent, so we have (X ,Y ) ∈ SE(P ⋆ lp({(X ,Y ), (Y ,Y )})) by Remark 2 and 3; hence, X ∈ P(Y ). Let us now show the other inclusion S ⊆s SE(P ⋆ Q). Assume (X ,Y ) ∈ S. Then ∀Y ′ |= Q, Y ≤P Y ′ and X ∈ P(Y ). First, from the definition of P(Y ) we have Y ∈ P(Y ), so also (Y ,Y ) ∈ S. Since S 6= ∅, Q is consistent, thus by Remark 4 there exists Y∗ |= Q, Y∗ |= P ⋆ Q. Let R# = lp({(X ,Y ), (Y ,Y ), (Y∗,Y∗)}). Note that R# ⊆s Q and that (P ⋆ Q) + R# is consistent since Y∗ is a model of both P ⋆ Q and R#. Then by Remark 2 we get that (P ⋆Q)+R# ≡s P ⋆(Q+R#) ≡s P ⋆R#. Since we have to show that (X ,Y ) ∈ SE(P ⋆Q), it comes down to show that (X ,Y ) ∈ SE(P ⋆R#). Assume towards a contradiction that (X ,Y ) /∈ SE(P ⋆R#). By Remark 4 and since Y∗ |= P ⋆R#, we have two cases: (i) Y 6|= P ⋆ R#. Since (P ⋆ R#) + lp({(Y ,Y ), (Y∗,Y∗)}) is consistent, by Remark 2 and 3 we get that Y 6|= P ⋆ lp({(Y ,Y ), (Y∗,Y∗)}). This contradicts Y ≤P Y∗. (ii) Y |= P ⋆R#. Since (P ⋆R#) + lp({(X ,Y ), (Y ,Y )}) is consistent, by Remark 2 and 3 we get that (X ,Y ) /∈ SE(P ⋆ lp({(X ,Y ), (Y ,Y )})). This contradicts X ∈ P(Y ).\nIt remains to verify that all conditions (1 - 3) of the faithful assignment and\nconditions (a - e) of the well-defined assignment are satisfied:\n(1) Assume Y |= P and Y ′ |= P . By (RA2), P ⋆ lp({Y ,Y ′}) ≡s P + lp({Y ,Y ′}). So\nY |= P ⋆ lp({Y ,Y ′}) and Y ′ |= P ⋆ lp({Y ,Y ′}), hence Y ≃P Y ′;\n(2) Assume Y |= P and Y ′ 6|= P . By (RA2), P ⋆ lp({Y ,Y ′}) ≡s P + lp({Y ,Y ′}). So\nY |= P ⋆ lp({Y ,Y ′}) and Y ′ 6|= P ⋆ lp({Y ,Y ′}), hence Y <P Y ′;\n(3) Obvious from (RA4); (a) By definition of P(Y ) and by (RA1) and (RA3), we must haveY |= P⋆lp({(X ,Y ), (Y ,Y )}),\ni.e., Y |= P(Y ); (b) If X ∈ P(Y ) then X ⊆ Y by definition of P(Y ); (c) Assume (X ,Y ) ∈ SE(P). Then Y |= P . By (RA2), P⋆lp({(X ,Y ), (Y ,Y )}) ≡s P+\nlp({(X ,Y ), (Y ,Y )}) ≡s lp({(X ,Y ), (Y ,Y )}), so (X ,Y ) ∈ SE(P⋆lp({(X ,Y ), (Y ,Y )})).\nTherefore, X ∈ P(Y ). (d) Assume (X ,Y ) /∈ SE(P) and Y |= P . By (RA2), P ⋆ lp({(X ,Y ), (Y ,Y )}) ≡s\nP+lp({(X ,Y ), (Y ,Y )}) ≡s lp({Y }), so (X ,Y ) /∈ lp({(X ,Y ), (Y ,Y )}). Therefore,\nX /∈ P(Y ). (e) Obvious from (RA4).\n(If part) We consider a faithful assignment that associates with every GLP P a total preorder ≤P and a well-defined assignment that associates with every GLP P and every interpretation Y a set P(Y ) ⊆ Ω. For all GLPs P ,Q, let S(P ,Q) be the set of SE interpretations defined as S(P ,Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P),X ∈ P(Y )}. Let P ,Q be two GLPs and let us show that S(P ,Q) is well-defined. Let (X ,Y ) ∈ S(P ,Q). By condition (a) of the well-defined assignment and since X ⊆ Y , we have Y ∈ P(Y ), so (Y ,Y ) ∈ S(P ,Q). Hence, S(P ,Q) is well-defined. Then let us define an operator ⋆ associating two GLPs P ,Q with a new GLP P ⋆Q such that for all GLPs P ,Q, SE(P ⋆Q) = S(P ,Q).\nIt remains to show that postulates (RA1 - RA6) are satisfied. Let P ,Q bet two\nGLPs.\n(RA1) By definition, SE(P ⋆Q) ⊆ SE(Q). (RA2) Assume that P +Q is consistent. We have to show that SE(P ⋆Q) = SE(P +Q).\nWe first show the inclusion SE(P ⋆ Q) ⊆ SE(P + Q). Let (X ,Y ) ∈ SE(P ⋆ Q). Towards a contradicton, assume that (X ,Y ) /∈ SE(P + Q). By definition of ⋆ we have (X ,Y ) ∈ SE(Q), thus (X ,Y ) /∈ SE(P). We fall into two cases: (i) (Y ,Y ) ∈ SE(P). Then from condition (d), we have X /∈ P(Y ). This contradicts (X ,Y ) ∈ SE(P ⋆Q); (ii) (Y ,Y ) /∈ SE(P). Then from condition (2), ∀Y ′ |= P , Y ′ <P Y . In particular, ∀Y ′ |= P +Q , Y ′ <P Y . This contradicts (X ,Y ) ∈ SE(P ⋆Q). We now show the other inclusion SE(P+Q) ⊆ SE(P ⋆Q). Let (X ,Y ) ∈ SE(P+Q). So (X ,Y ) ∈ SE(Q). From conditions (1) and (2), ∀Y ′ ∈ Ω, Y <P Y ′. Moreover from condition (c), since (X ,Y ) ∈ SE(P) we get that X ∈ P(Y ). Therefore,\n(X ,Y ) ∈ SE(P ⋆Q). (RA3) Suppose that Q is consistent, i.e., SE(Q) 6= ∅. As Ω is a finite set of interpretations,\nwe have no infinite descending chain of inequalities w.r.t. ≤P . Moreover, ≤P is a total relation. Hence, there is an interpretation Y∗ |= Q such that ∀Y ′ |= Q, Y∗ ≤P Y ′. Lastly by condition (a), Y∗ ∈ PY∗ . Hence, Y∗ |= P ⋆ Q, i.e., P ⋆ Q is\nconsistent. (RA4) Obvious by definition of ⋆ and from conditions (3) and (e). (RA5) Let (X ,Y ) ∈ SE((P ⋆ Q) + R). So by definition of ⋆, ∀Y ′ |= Q, Y ≤P Y ′ and\nX ∈ P(Y ). In particular, ∀Y ′ |= Q +R, Y ≤P Y ′ and X ∈ P(Y ). So (X ,Y ) ∈ SE(P ⋆ (Q+R)).\n(RA6) Assume that (P ⋆ Q) + R is consistent. Let Y∗ |= (P ⋆ Q) + R. Let (X ,Y ) ∈\nSE(P ⋆ (Q+R)). Assume towards a contradiction that (X ,Y ) /∈ SE((P ⋆Q)+R). Since (X ,Y ) ∈ SE(R), we have (X ,Y ) /∈ SE(P ⋆ Q). But (X ,Y ) ∈ SE(Q), this means that Y∗ <P Y or X /∈ P(Y ). Yet Y∗ |= Q+R, so (X ,Y ) /∈ SE(P ⋆(Q+R)). This leads to a contradiction.\nProposition 4 An LP revision operator is a GLP revision operator if and only if it is a propositionalbased GLP revision operator."
    }, {
      "heading" : "Proof",
      "text" : "(Only If part) Let ⋆ be a GLP revision operator. We have to show that there exists a KM revision operator ◦ and a mapping f from Ω to 2Ω such that ∀Y ∈ Ω, Y ∈ f (Y ) and if X ∈ f (Y ) then X ⊆ Y , and such that for all GLPs P ,Q, SE(P ⋆ Q) = SE(P ⋆◦,f Q). Yet from Proposition 3 there exists a GLP parted assignment (Φ,Ψ), where Φ associates with every GLP P a total preorder ≤P and Ψ associates with every GLP P and every interpretation Y a set of interpretations P(Y ), such that for all GLPs P ,Q, SE(P ⋆ Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P),X ∈ P(Y )}. Then, let ◦ be the KM revision operator associated with the faithful assignment (cf. Definition 3) that associates with every propositional formula φ the total preorder ≤φ=≤P , where P is any GLP such that φ ≡ α2P (from Remark 1, such an assignment is, indeed, faithful and unique). Then from Theorem 1, for every Y ∈ Ω, Y ∈ min(mod(Q),≤P) if and only if Y |= α2P ◦ α 2 Q. Then define f as the mapping from Ω to 2 Ω such that ∀Y ∈ Ω, f (Y ) = P(Y ). From conditions (a) and (b) of the well-defined assignment (cf. Definition 13), f is such that ∀Y ∈ Ω, Y ∈ f (Y ) and if X ∈ f (Y ) then X ⊆ Y . Now, given two GLPs P ,Q, if P + Q is consistent, we directly get SE(P ⋆ Q) = SE(P ⋆◦,f Q) from Definition 15 and postulate (RA2). So assume that P + Q is inconsistent. Given an SE interpretation (X ,Y ), we have (X ,Y ) ∈ SE(P ⋆ Q) if and only if (X ,Y ) ∈ SE(Q), Y ∈ min(mod(Q),≤P) and X ∈ P(Y ), if and only if (X ,Y ) ∈ SE(Q), Y |= α2P ◦ α 2 Q and X ∈ f (Y ), if and only if (X ,Y ) ∈ SE(P ⋆◦,f Q). That is to say, SE(P ⋆Q) = SE(P ⋆◦,f Q).\n(If part) Let ⋆◦,f be a propositional-based GLP revision operator. We have to show that there exists a GLP revision operator ⋆ such that SE(P ⋆◦,f Q) = SE(P ⋆Q). Since ◦ is a KM revision operator, from Theorem 1 there is a faithful assignment associating with every propositional formula φ a total preorder ≤φ. Then using Remark 1, let Φ be the LP faithful assignment associating with every GLP P the total preorder ≤P=≤φ, where φ is any propositional formula such that α2P ≡ φ. From Theorem 1, for all GLPs P ,Q and for every Y ∈ Ω, Y |= α2P ◦ α 2 Q if and only if Y ∈ min(mod(Q),≤P). Now, let Ψ be the mapping associating with every GLP P and every interpretation Y the set of interpretations P(Y ) = {X ∈ Ω | (X ,Y ) ∈ SE(P)} ∪ {X ∈ f (Y ) | Y 6|= P}. By definition, Ψ satisfies conditions (a) - (e) of a well-defined assignment (cf. Definition 13). Then, let us consider\nthe GLP revision operator ⋆ associated with the GLP parted assignment (Φ,Ψ). We need to check that for all GLPs P ,Q, SE(P ⋆ Q) = SE(P ⋆◦,f Q). Given two GLPs P ,Q, if P + Q is consistent, we directly get SE(P ⋆ Q) = SE(P ⋆◦,f Q) from Definition 15 and postulate (RA2). So assume that P +Q is inconsistent. We first prove that SE(P ⋆ Q) ⊆ SE(P ⋆◦,f Q). Let (X ,Y ) ∈ SE(P ⋆ Q). We have (X ,Y ) ∈ SE(Q), Y ∈ min(mod(Q),≤P) and X ∈ P(Y ). Thus (X ,Y ) ∈ SE(Q), Y |= α2P ◦ α 2 Q and X ∈ P(Y ). We need to show that X ∈ f (Y ). Yet since P + Q is inconsistent, we have (X ,Y ) 6∈ SE(P); and since (X ,Y ) ∈ SE(Q), we also have (Y ,Y ) ∈ SE(Q), so (Y ,Y ) 6∈ SE(P), thus Y 6|= P . By definition of P(Y ), this means that X ∈ f (Y ). Since (X ,Y ) ∈ SE(Q), Y |= α2P ◦ α 2 Q and X ∈ f (Y ), we have (X ,Y ) ∈ SE(P ⋆◦,f Q). Therefore, SE(P ⋆Q) ⊆ SE(P ⋆◦,f Q). We prove now that SE(P ⋆◦,f Q) ⊆ SE(P ⋆Q). Let (X ,Y ) ∈ SE(P ⋆Q). We have (X ,Y ) ∈ SE(Q), Y ∈ α2P ◦ α 2 Q and X ∈ f (Y ). Thus (X ,Y ) ∈ SE(Q), Y ∈ min(mod(Q),≤P ) and X ∈ f (Y ). We need to show that X ∈ P(Y ). Yet since P +Q is inconsistent and since we have (X ,Y ) ∈ SE(Q), we also have (Y ,Y ) ∈ SE(Q), so (Y ,Y ) 6∈ SE(P), thus Y 6|= P . So by definition of P(Y ), we get that X ∈ P(Y ). Since (X ,Y ) ∈ SE(Q), Y ∈ min(mod(Q),≤P) and X ∈ P(Y ), we have (X ,Y ) ∈ SE(P ⋆ Q). Therefore, SE(P ⋆◦,f Q) ⊆ SE(P ⋆Q). Hence, SE(P ⋆◦,f Q) = SE(P ⋆Q).\nProposition 5 For all propositional-based GLP revision operators ⋆◦1,f1 , ⋆◦2,f2 , we have ⋆◦1,f1 = ⋆◦2,f2 if and only if ◦1 = ◦2 and f1 = f2."
    }, {
      "heading" : "Proof",
      "text" : "Let ⋆◦1,f1 , ⋆◦2,f2 be two propositional-based GLP revision operators. (If part) Obvious by Definition 15. (Only If part) Let us prove the contraposite, i.e., assume that ◦1 6= ◦2 or f1 6= f2 and let us show that ⋆◦1,f1 6= ⋆◦2,f2 . First, assume that ◦1 6= ◦2. This means that there exist two propositional formulae φ, ψ such that φ◦1ψ 6≡ φ◦2ψ. Then, let P ,Q be two GLPs defined such that α2P ≡ φ and α 2 Q ≡ ψ. We have mod(α 2 P ◦1 α 2 Q) 6= mod(α2P ◦2 α 2 Q). By Definition 15 since ⋆ ◦1,f1 , ⋆◦2,f2 are both propositional-based GLP revision operators, ◦1 and ◦2 are both KM revision operators. This means that ◦1 and ◦2 satisfy the postulate (R2) (see Definition 2), but since mod(α2P ◦1 α2Q) 6= mod(α 2 P ◦2 α 2 Q), this also means that α 2 P ∧ α 2 Q is inconsistent, i.e., P +Q is inconsistent. Hence, from Definition 15 we can see that for every propositional-based LP revision operator ⋆◦,f , we have mod(P ⋆◦,f Q) = mod(α2P ◦ α 2 Q), This means that mod(P ⋆◦1,f1 Q) 6= mod(P ⋆◦2,f2 Q), thus SE(P ⋆◦1,f1 Q) 6= SE(P ⋆◦2,f2 Q). Therefore, ⋆◦1,f1 6= ⋆◦2,f2 . Now, assume that f1 6= f2. So there exists an interpretation Y such that f1(Y ) 6= f2(Y ). We fall into at least one of the two following cases: (i) there exists X ∈ f1(Y ) such that X /∈ f2(Y ), or (ii) there exists X ∈ f2(Y ) such that X /∈ f1(Y ). Assume that we fall into the first case (i) (the second case (ii) leads to the same result by symmetry). Now, let P ,Q be two GLPs defined such that Y 6|= P and SE(Q) = {(X ,Y ), (Y ,Y )}. P + Q is inconsistent. Then by Definition 15 we get that SE(P ⋆◦1,f1 Q) = {(X ,Y ), (Y ,Y )} and SE(P ⋆◦2,f2 Q) = {(Y ,Y )}, thus SE(P ⋆◦1,f1 Q) 6= SE(P ⋆◦2,f2 Q). Therefore, ⋆◦1,f1 6= ⋆◦2,f2 .\nProposition 6 For every (Φ,Ψ) ∈ GLPpart and every Γ ∈ GLPfaith , ((Φ,Ψ),Γ) ∈ σpart→faith if and only if for all GLPs P ,Q, min(SE(Q),≤∗P) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q), ≤P),X ∈ P(Y )}."
    }, {
      "heading" : "Proof",
      "text" : "In this proof, for every well-defined set of SE interpretations S , lp(S ) denotes any GLP P such that SE(P) = S . Let (Φ,Ψ) ∈ GLPpart and Γ ∈ GLPfaith . We have to show that ((Φ,Ψ),Γ) ∈ σ, i.e., conditions (i) and (ii) involved in the definition of σpart→faith are satisfied, if and only if for all GLP P ,Q, we have min(SE(Q),≤∗P) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P),X ∈ P(Y )}. For simplicity reasons we abuse notations and respectively denote Sfaith = min(SE(Q),≤∗P) and Spart = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P ),X ∈ P(Y )}.\n(If part) Assume that for all GLP P ,Q, Sfaith = Spart . We have to show that conditions (i) and (ii) involved in the definition of σpart→faith are satisfied.\nWe first prove that (i) for every GLP P and all interpretations Y ,Y ′ ∈ Ω, (Y ,Y ) ≤∗P (Y ′,Y ′) if and only if Y ≤P Y ′. Let Y ,Y ′ ∈ Ω, assume that (Y ,Y ) ≤∗P (Y ′,Y ′) and assume toward a contradiction that Y ′ <P Y . Let Q be the GLP Q = lp({Y ,Y ′}). Then Y /∈ min(mod(Q),≤P), thus (Y ,Y ) /∈ Spart . Hence, (Y ,Y ) /∈ Sfaith , which contradicts (Y ,Y ) ≤∗P (Y ′,Y ′). The other way around, assume that Y ≤P Y ′ and assume toward a contradiction that (Y ′,Y ′) <∗P (Y ,Y ). Let Q be the GLP Q = lp({Y ,Y ′}). Then Y /∈ Sfaith , thus Y /∈ Spart , which means that Y /∈ min(mod(Q),≤P ) or Y /∈ P(Y ). Yet the fact that Y /∈ min(mod(Q),≤P) contradicts Y ≤P Y ′ and Y /∈ P(Y ) contradicts condition (a) required by the well-defined assignment Ψ. This proves (i).\nWe now prove that (ii) for every GLP P , (X ,Y ) ≤∗P (Y ,Y ) and all interpretations X ,Y ∈ Ω s.t. X ⊆ Y , (X ,Y ) ≤∗P (Y ,Y ) if and only if X ∈ P(Y ). Let X ,Y ∈ Ω, X ⊆ Y , assume that (X ,Y ) ≤∗P (Y ,Y ) and assume toward a contradiction that X /∈ P(Y ). Then for the GLP Q defined as Q = lp({(X ,Y ), (Y ,Y )}), we have (X ,Y ) /∈ Sfaith , so (X ,Y ) /∈ Spart , which contradicts (X ,Y ) ≤∗P (Y ,Y ). The other way around, assume that X ∈ P(Y ) and assume toward a contradiction that (Y ,Y ) <∗P (X ,Y ). Let Q be the GLP defined as Q = lp({(X ,Y ), (Y ,Y )}). On the one hand Q has the only model Y , so min(mod(Q),≤P) = {Y }. On the other hand, we have (X ,Y ) /∈ Sfaith , so (X ,Y ) /∈ Spart , which means that we should have Y /∈ min(mod(Q),≤P) since we assumed that X ∈ P(Y ). This leads to a contradiction. This proves (ii).\n(Only If part) Assume that conditions (i) and (ii) involved in the definition of σpart→faith are satisfied. We have to show that for all GLP P ,Q, we have Sfaith = Spart . Let P ,Q be two GLPs.\nWe first prove that Sfaith ⊆ Spart . Let (X ,Y ) ∈ Sfaith . This means that for\nevery (X ′,Y ′) ∈ SE(Q), (X ,Y ) ≤∗P (X ′,Y ′). In particular, (X ,Y ) ≤∗P (Y ′,Y ′). And condition (4) required by the GLP compliant faithful assignment Γ states that (Y ,Y ) ≤∗P (X ,Y ). Hence, (Y ,Y ) ≤ ∗ P (Y ′,Y ′). So by condition (i) involved in the\ndefinition of σpart→faith , we get that Y ≤P Y ′ for every Y ′ ∈ Ω. So we showed that Y ∈ min(mod(Q),≤P). Furthermore, since for all (X ′,Y ′) ∈ SE(Q), (X ,Y ) ≤∗P (X ′,Y ′), we also have that (X ,Y ) ≤∗P (Y ,Y ), and condition (ii) involved in the definition of σpart→faith implies that X ∈ P(Y ). Since Y ∈ min(mod(Q),≤P) and X ∈ P(Y ), we get that (X ,Y ) ∈ Spart .\nWe prove now that Spart ⊆ Sfaith . Let (X ,Y ) ∈ Spart . Since Y ∈ min(mod(Q), ≤P), condition (i) involved in the definition of σpart→faith implies that (Y ,Y ) ≤ ∗ P (Y ′,Y ′) for every Y ′ ∈ Ω. Together with condition (4) required by the GLP compliant faithful assignment Γ, we get for all X ′,Y ′ ∈ Ω s.t. X ′ ⊆ Y ′ that (Y ,Y ) ≤∗P (X ′,Y ′). And since X ∈ P(Y ), condition (ii) involved in the definition of σpart→faith implies that (X ,Y ) ≤∗P (Y ,Y ). Therefore, for all X ′,Y ′ ∈ Ω s.t. X ′ ⊆ Y ′, (X ,Y ) ≤∗P (X ′,Y ′). This is true in particular for every (X ′,Y ′) ∈ SE(Q). This means that (X ,Y ) ∈ Sfaith , and this concludes the proof.\nProposition 7 Let ◦ be a KM revision operator. Then for all GLP revision operators ⋆1, ⋆2 ∈ GLP(◦), ⋆1 ◦ ⋆2 if and only if for all GLPs P ,Q, we have AS (P ⋆1Q) ⊆ AS (P ⋆2 Q)."
    }, {
      "heading" : "Proof",
      "text" : "Let ◦ be a KM revision operator and ⋆1, ⋆2 ∈ GLP(◦). (Only if part) Assume that ⋆1 ◦ ⋆2. By Definition 18, for every interpretation Y we have f2(Y ) ⊆ f1(Y ). Let P ,Q be two GLPs such that P + Q is inconsistent (the case where P + Q is consistent is trivial since by Definition 15, we would have P ⋆1 Q = P ⋆2 Q = P + Q) and let Y ∈ AS (P ⋆1 Q). We need to show that Y ∈ AS (P ⋆2 Q). We have (Y ,Y ) ∈ SE(P ⋆1 Q) and for every X ( Y , (X ,Y ) /∈ SE(P ⋆1Q). Since ⋆1 is a propositional-based revision operator (cf. Proposition 4), from Definition 15 we get that Y |= α2P ◦ α 2 Q (i) and for every X ( Y , (X ,Y ) /∈ SE(Q) or X /∈ f1(Y ), thus (X ,Y ) /∈ SE(Q) or X /∈ f2(Y ), therefore (X ,Y ) /∈ SE(P ⋆2 Q) (ii). By (i) we get that (Y ,Y ) ∈ SE(P ⋆2 Q) and by (ii) we have for every X ( Y , (X ,Y ) /∈ SE (P ⋆2 Q). Therefore, by Definition 15 we get that Y ∈ AS (P ⋆2 Q). Hence, AS (P ⋆1 Q) ⊆ AS (P ⋆2 Q).\n(If part) Assume that for all GLPs P ,Q, AS (P ⋆1 Q) ⊆ AS (P ⋆2 Q). Toward a contradiction, assume that ⋆1 6 ◦ ⋆2. This means that there exists an interpretation Y such that f2(Y ) 6⊆ f1(Y ), that is, there exists an interpretation X ( Y such that X ∈ f2(Y ) and X /∈ f1(Y ). Then, consider a GLP Q such that SE(Q) = {(X ,Y ), (Y ,Y )} and any GLP P such that Y 6|= P . Since Y is the only interpretation satisfying Y |= Q, from postulates (R1) and (R3) of a KM revision operator we have Y |= α2P ◦ α 2 Q. Moreover X /∈ f1(Y ). So we get from Definition 15 that SE(P ⋆1 Q) = {(Y ,Y )}. On the other hand, since X ∈ f2(Y ) we get that SE(P ⋆2Q) = {(X ,Y ), (Y ,Y )}. Therefore, Y ∈ AS (P ⋆1Q) and Y /∈ AS (P ⋆2Q). This contradicts AS (P ⋆1 Q) ⊆ AS (P ⋆2 Q).\nProposition 8 The skeptical GLP revision operators are the only GLP revision operators ⋆ such that for all GLPs P ,Q, whenever P+Q is inconsistent, we haveAS (P⋆Q) ⊆ AS (Q)."
    }, {
      "heading" : "Proof",
      "text" : "Let ◦ be a KM revision operator and ⋆◦S be the corresponding skeptical GLP revision operator. We first show that for all GLPs P ,Q such that P + Q is inconsistent, we have AS (P ⋆◦S Q) ⊆ AS (Q). ⋆ ◦ S corresponds to the propositional-based revision GLP operator ⋆◦,f such that for every interpretation Y , f (Y ) = 2Y . Let P ,Q be two GLPs such that P + Q is inconsistent. Let Y ∈ AS (P ⋆◦S Q). We have (Y ,Y ) ∈ SE(P⋆◦SQ), so by Definition 15 we get that (Y ,Y ) ∈ SE(Q). Now, assume toward a contradiction that Y /∈ AS (Q). This means that there exists X ( Y such that (X ,Y ) ∈ SE(Q). Yet f (Y ) = 2Y , so X ∈ f (Y ), thus by Definition 15 this implies that (X ,Y ) ∈ SE(P ⋆◦S Q), this contradicts Y ∈ AS (P ⋆ ◦ S Q). Therefore, Y ∈ AS (Q). Hence, AS (P ⋆◦S Q) ⊆ AS (Q). We now show that for some any revision operator ⋆◦,f , if we have AS (P ⋆ Q) ⊆ AS (Q) for all GLPs P ,Q such that P + Q is inconsistent, then ⋆◦,f corresponds to the skeptical GLP revision operator ⋆◦S . Let us show the contraposite, that is, assume that ⋆◦,f is not a skeptical GLP revision operator. This means that there exists an interpretation Y such that f (Y ) 6= 2Y , i.e., there exists X ( Y such that X /∈ f (Y ). Then, consider a GLP Q such that SE(Q) = {(X ,Y ), (Y ,Y )} and any GLP P such that Y 6|= P . Since Y is the only interpretation satisfying Y |= Q, from postulates (R1) and (R3) of a KM revision operator we have Y |= α2P ◦α 2 Q. On the one hand, since SE(Q) = {(X ,Y ), (Y ,Y )} we have Y /∈ AS (Q). On the other hand, since X /∈ f (Y ) we get from Definition 15 that SE(P ⋆◦,f Q) = {(Y ,Y )}, that is, Y ∈ AS (P ⋆◦,f Q). Therefore, AS (P ⋆◦,f Q) 6⊆ AS (Q).\nProposition 9 The brave GLP revision operators are the only GLP revision operators ⋆◦,f such that for all GLPs P ,Q, whenever P + Q is inconsistent, we have AS (P ⋆◦,f Q) = mod(α2P ◦ α 2 Q)."
    }, {
      "heading" : "Proof",
      "text" : "Let ◦ be a KM revision operator and ⋆◦B be the corresponding brave GLP revision operator. We first show that for all GLPs P ,Q such that P + Q is inconsistent, we have AS (P ⋆◦B Q) = mod(α 2 P ◦ α 2 Q). ⋆ ◦ B corresponds to the propositional-based revision GLP operator ⋆◦,f such that for every interpretation Y , f (Y ) = {Y }. Let P ,Q be two GLPs such that P + Q is inconsistent. For every interpretation Y and every X ( Y , X /∈ f (Y ), thus from Definition 15 for every interpretation Y , we have Y ∈ AS (P ⋆◦B Q) if and only if (Y ,Y ) ∈ SE(P ⋆ ◦ B Q) if and only if Y |= α2P ◦ α 2 Q. Therefore, AS (P ⋆ ◦ B Q) = mod(α 2 P ◦ α 2 Q). We now show that for some any revision operator ⋆◦,f , if we have AS (P ⋆◦B Q) = mod(α2P ◦ α 2 Q) for all GLPs P ,Q such that P +Q is inconsistent, then ⋆ ◦,f corresponds to the brave GLP revision operator ⋆◦B . Let us show the contraposite, that is, assume that ⋆◦,f is not a brave GLP revision operator. This means that there exists an interpretation Y such that f (Y ) 6= {Y }, i.e., there exists X ( Y such\nthat X ∈ f (Y ). Then, consider a GLP Q such that SE(Q) = {(X ,Y ), (Y ,Y )} and any GLP P such that Y 6|= P . On the one hand, since Y is the only interpretation satisfying Y |= Q, from postulates (R1) and (R3) of a KM revision operator we have Y |= α2P ◦ α 2 Q. On the other hand, since SE(Q) = {(X ,Y ), (Y ,Y )} and X ∈ f (Y ), we get from Definition 15 that SE(P ⋆◦,f Q) = {(X ,Y ), (Y ,Y )}, that is, Y /∈ AS (P ⋆◦,f Q). Therefore, AS (P ⋆◦B Q) = mod(α 2 P ◦ α 2 Q).\nProposition 10 MC(◦D ) is coNP-complete."
    }, {
      "heading" : "Proof",
      "text" : "Let φ, ψ be two formulae and I be an interpretation. In the case where I |= φ ∧ ψ or I 6|= ψ, to determine whether I |= φ ◦D ψ can be checked in polynomial time (the answer is “yes” in the former case, “no” in the latter one). So let us assume that I |= ¬φ∧ψ. Then to determine whether I |= φ ◦D ψ comes down to determine whether φ ∧ ψ is an inconsistent formula, that can be down using one call to a coNP oracle. Hence, MC(◦D ) ∈ coNP. We prove coNP-hardness by exhibiting a polynomial reduction from the unsatisfiability problem. Consider a propositional formula α over a set of propositional variables A, and let us associate with it in polynomial time: • the formulae φ, ψ defined on A ∪ {new , new ′} (with A ∩ {new , new ′} = ∅) as φ = α ∧ new and ψ = new ′; • the interpretation I overA∪{new , new ′} defined as I (p) = 0 if p = new , otherwise I (p) = 1. If α is inconsistent then φ is inconsistent, so φ◦D ψ = ψ = new ′; since I (new ′) = 1, we get that I |= ψ, so I |= φ ◦D ψ. Now, if α is consistent then φ is consistent, so φ ◦D ψ = φ ∧ ψ = α ∧ new ∧ new ′; since I (new) = 0, we get that I 6|= φ ◦D ψ. We just showed that α is inconsistent if and only if I |= φ ◦D ψ, thus MC(◦D) is coNP-hard.\nProposition 11 The skeptical GLP revision operators are both DLP revision operators and NLP revision operators."
    }, {
      "heading" : "Proof",
      "text" : "We show that every skeptical GLP revision operator ⋆◦,f = ⋆◦S is a DLP revision operator. We have to prove that for all DLP P ,Q, P ⋆◦,f Q is a DLP, i.e., that SE(P ⋆◦S Q) is a complete set of SE interpretations. This is trivial when P +Q is consistent since in this case, P ⋆◦S Q = P + Q and expansion preserves completeness of SE models, so assume that P +Q is inconsistent. Let X ,Y ,Z s.t. Y ⊆ Z , (X ,Y ), (Z ,Z ) ∈ SE(P ⋆◦,f Q), and let us show that (X ,Z ) ∈ SE(P ⋆◦,f Q). By definition of a propositional-based LP revision operator, we know that (X ,Y ), (Z ,Z ) ∈ SE(Q). Yet Q is a DLP, thus (X ,Z ) ∈ SE(Q). Since (Z ,Z ) ∈ SE(P ⋆◦,f Q), we get that Z |= α2P ◦ α 2 Q. Moreover, X ∈ f (Z ) since ⋆ ◦ S is a skeptical GLP revision operator. Hence, by definition of a propositional-based LP revision operator we get that (X ,Z ) ∈ SE(P ⋆◦,f Q).\nOne can prove that every skeptical GLP revision operator ⋆◦,f = ⋆◦S is a NLP revision operator is a similar way, by augmenting the above conditions of completeness on SE interpretations with the condition of closeness under hereintersection.\nProposition 12 An LP operator ⋆ is a DLP (resp. NLP) revision operator if and only if there exists a DLP (resp. NLP) parted assignment (Φ,ΨΦ), where Φ associates with every DLP (resp. NLP) P a total preorder ≤P , ΨΦ is a Φ-based complete (resp. normal) assignment which associates with every DLP (resp. NLP) P and every interpretation Y a set of interpretations PΦ(Y ), and such that for all DLPs (resp. NLPs) P ,Q,\nSE(P ⋆Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P),X ∈ PΦ(Y )}·"
    }, {
      "heading" : "Proof",
      "text" : "Let us first prove the representation of DLP revision operators. (Only if part) The proof is identical to the one of Proposition 3 (i.e., our representation theorem for GLP revision operators), except that we now consider that for every well-defined set of SE interpretations S , lp(S ) denotes any DLP R whose set of SE models is the smallest (w.r.t. the set inclusion) superset of S , i.e., S ⊆ SE(R) and there is no DLP R′ such that S ⊆ SE(R′) and SE(R′) ( SE(R). Remark here that given some set S , the DLP lp(S ) is uniquely defined (modulo strong equivalence): to determine SE(lp(S )), it is enough to add to S all SE interpretations (X ,Z ) which are missing from S to ensure its completeness, i.e., those SE interpretations (X ,Z ) such that (X ,Y ), (Z ,Z ) ∈ S for some interpretation Y ⊆ Z . Also when S is of the form {(Y ,Y ) | Y ∈ E} for some set of interpretations E , we write lp(E ) instead of lp(S ).\nObviously enough, Remark 2 and 4 from the proof of Proposition 3 still hold. We show now that Remark 3 from the proof of Proposition 3 also holds, i.e., that for all sets of interpretations E ,F , lp(E ) + lp(F ) ≡s lp(E ∩ F ). First, let us show the following intermediate result, that is, for every set E of interpretations and every SE interpretation (X ,Z ),\n(X ,Z ) ∈ SE(lp(E )) if and only if (X ,X ), (Z ,Z ) ∈ SE(lp(E )) · (1)\nEquation 1 trivially holds when X = Z , so assume X ( Z . The if part comes from the fact that SE(lp(E )) is complete. Let us prove the only if part. On the one hand, (Z ,Z ) ∈ SE(lp(E )) since SE(lp(E )) is well-defined. On the other hand, SE(lp(E )) is complete and minimal w.r.t. the set inclusion, which means that there necessarily exists Y ( Z , X ⊆ Y such that (X ,Y ) ∈ SE(lp(E )). If now X ( Y , then the reasoning can be repeated recursively (by setting Z = Y each time). Then after a finite number of steps we get that X = Y since we deal with a finite set of atoms, that is, (X ,X ) ∈ SE(lp(E )) which proves that Equation 1 holds. Now, for every\nSE interpretation (X ,Z ), we have that\n(X ,Z ) ∈ SE(lp(E ) + lp(F ))\nif and only if (X ,Z ) ∈ SE(lp(E )) ∩ SE(lp(F )) if and only if (X ,X ), (Z ,Z ) ∈ SE(lp(E )) ∩ SE(lp(F )) (by Equation 1) if and only if X ,Z ∈ E ∩ F if and only if (X ,X ), (Z ,Z ) ∈ SE(lp(E ∩ F )) if and only if (X ,Z ) ∈ SE(lp(E ∩ F )) (by Equation 1).\nThis shows that Remark 3 from the proof of Proposition 3 also holds here, i.e., that for all sets of interpretations E ,F , lp(E ) + lp(F ) ≡s lp(E ∩ F ).\nConsider now a DLP revision operator ⋆. We associate with ⋆ a DLP parted assignment (Φ,ΨΦ) which uses the same construction as for a GLP parted assignment in the proof of Proposition 3: define for every DLP P the relation ≤P over interpretations such that ∀Y ,Y ′ ∈ Ω, Y ≤P Y ′ iff Y |= P ⋆ lp({Y ,Y ′}), and by defining for every DLP P and every Y ∈ Ω the set PΦ(Y ) as PΦ(Y ) = {X ⊆ Y | (X ,Y ) ∈ SE(P ⋆ lp({(X ,Y ), (Y ,Y )}))}. Then the same proof as for Proposition 3 can be used to show that:\n(i) for every DLP P , ≤P is a total preorder;\n(ii) for all DLPs P ,Q, SE(P ⋆ Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),\n≤P),X ∈ PΦ(Y )};\n(iii) conditions (1 - 3) of the faithful assignment Φ and conditions (a - e) of the Φ-based\ncomplete assignment ΨΦ are satisfied.\nIt remains to show that the condition (f) of ΨΦ is satisfied. Let P be a DLP, X ,Y ,Z be interpretations such that Y ⊆ Z , Y ≃P Z and X ∈ PΦ(Y ). Assume toward a contradiction that X /∈ PΦ(Z ). By (ii) we get that SE(P ⋆ lp({(X ,Y ), (Y ,Y ), (Z ,Z ), (X ,Z )})) = {(X ,Y ), (Y ,Y ), (Z ,Z )}, which is not a complete set of SE interpretations since (X ,Z ) does not belong to it. This contradicts the fact that P ⋆ lp({(X ,Y ), (Y ,Y ), (Z ,Z ), (X ,Z )}) is a DLP, i.e., that ⋆ is a DLP revision operator.\n(If part) We consider a faithful assignment Φ that associates with every DLP P a total preorder ≤P and a Φ-based complete assignment ΨΦ that associates with every DLP P and every interpretation Y a set PΦ(Y ) ⊆ Ω. For all DLPs P ,Q, let S(P ,Q) be the set of SE interpretations defined as S(P ,Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P ),X ∈ PΦ(Y )}. Let P ,Q be two GLPs. The proof that S(P ,Q) is well-defined is given in the proof of Proposition 3, by using condition (a) of the Φ-based complete assignment ΨΦ. We show that S(P ,Q) is complete by using condition (f). Let (X ,Y ), (Z ,Z ) be two SE interpretations such that Y ⊆ Z and (X ,Y ), (Z ,Z ) ∈ S(P ,Q). By definition of S(P ,Q) we get that Y ,Z ∈ min(mod(Q),≤P ), which means that Y ≃P Z , and we also get that X ∈ PΦ(Y ). Thus condition (f) implies that also X ∈ PΦ(Z ). Therefore, (X ,Z ) ∈ S(P ,Q) which means that S(P ,Q) is complete. Then we define an operator ⋆ associating two DLPs P ,Q with a new DLP P ⋆Q such that for all DLPs P ,Q, SE(P ⋆Q) = S(P ,Q). The proof that ⋆ satisfies postulates (RA1 - RA6) is\nidentical to the one of Proposition 3.\nThe proof in the NLP case is very similar to the DLP one and uses the same construction, by adapting the structures accordingly and considering the additional condition (g) involved in a NLP parted assignment. (Only if part) For every well-defined set of SE interpretations S , lp(S ) denotes any NLP R (which is uniquely defined modulo equivalence) whose set of SE models is the smallest (w.r.t. the set inclusion) superset of S . And when S is of the form {(Y ,Y ) | Y ∈ E} for some set of interpretations E , we write lp(E ) instead of lp(S ).\nRemark 2 and 4 from the proof of Proposition 3 still hold, but we need to show that Remark 3 from the proof of Proposition 3 also holds, i.e., that for all sets of interpretations E ,F , lp(E ) + lp(F ) ≡s lp(E ∩ F ). For this purpose, we prove an adaptation of Equation 1 previously given in this proof for DLPs, to the case of NLPs; that is, for every set E of interpretations and every SE interpretation (X ,Z ),\n(X ,Z ) ∈ SE(lp(E )) if and only if one of the two following conditions holds:\n(i) (X ,X ), (Z ,Z ) ∈ SE(lp(E )) (ii) there is a set of interpretations Y such that ⋂\nY∈Y Y = X , |Y| ≥ 2,\nand ∀Y ∈ Y, (Y ,Y ) ∈ SE(lp(E ))·\n(2)\nEquation 2 trivially holds when X = Z , so assume X ( Z . The if part comes from the fact that SE(lp(E )) is complete and closed under here-intersection. Let us prove the only if part. Assume that it does not hold that (X ,X ), (Z ,Z ) ∈ SE(lp(E )). Then by Equation 1, (X ,Z ) belongs to SE(lp(E )) because its condition specific for closure under here-intersection, i.e., ∃Y ,Y ′ ⊆ Z , Y ∩Y ′ = X , Y 6= Y ′, (Y ,Z ), (Y ′,Z ) ∈ SE(lp(E )). By applying this reasoning recursively, since we are dealing with a finite set of atoms there must exist a finite set Y of at least two interpretations such that ⋂\nY∈Y Y = X , and such that all (Y ,Z ) such that Y ∈ Y belong SE(lp(E )) because the condition of completeness, which means by Equation 1 that for every Y ∈ Y, (Y ,Y ) ∈ SE(lp(E )).\nNow, for every SE interpretation (X ,Z ), we have that\n(X ,Z ) ∈ SE(lp(E ) + lp(F ))\nif and only if (X ,Z ) ∈ SE(lp(E )) ∩ SE(lp(F )) if and only either (i) or (ii) from Equation 2 holds for both E and F ·\nYet on the one hand, condition (i) from Equation 2 holds for both E and F if and only if X ,Z ∈ E ∩ F if and only if (X ,X ), (Z ,Z ) ∈ SE(lp(E ∩ F )). On the other hand, condition (ii) from Equation 2 holds for both E and F if and only if there is a set of interpretations Y such that ⋂\nY∈Y Y = X , |Y| ≥ 2 and\n∀Y ∈ Y, (Y ,Y ) ∈ SE(lp(E ))∩SE (lp(F )), if and only there is a set of interpretations Y such that ⋂\nY∈Y Y = X , |Y| ≥ 2 and ∀Y ∈ Y, Y ∈ E ∩ F , if and only if there\nis a set of interpretations Y such that ⋂\nY∈Y Y = X , |Y| ≥ 2 and ∀Y ∈ Y,\n(Y ,Y ) ∈ SE(lp(E ∩ F )). Therefore, by Equation 2 we get that either (i) or (ii) from Equation 2 holds for both E and F if and only if (X ,Z ) ∈ SE(lp(E ∩ F )).\nThis shows that Remark 3 from the proof of Proposition 3 also holds here, i.e., that for all sets of interpretations E ,F , lp(E ) + lp(F ) ≡s lp(E ∩ F ).\nConsider now a NLP revision operator ⋆, and similarly to the case of DLPs, we associate with ⋆ the following NLP parted assignment (Φ,ΨΦ): we define for every DLP P the relation ≤P over interpretations such that ∀Y ,Y ′ ∈ Ω, Y ≤P Y ′ iff Y |= P ⋆ lp({Y ,Y ′}), and for every GLP P and every Y ∈ Ω the set PΦ(Y ) as PΦ(Y ) = {X ⊆ Y | (X ,Y ) ∈ SE(P ⋆ lp({(X ,Y ), (Y ,Y )}))}. Then the same proof as for Proposition 3 can be used to show that:\n(i) for every NLP P , ≤P is a total preorder;\n(ii) for all NLPs P ,Q, SE(P ⋆ Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),\n≤P),X ∈ PΦ(Y )};\n(iii) conditions (1 - 3) of the faithful assignment Φ and conditions (a - e) of the Φ-based\ncomplete assignment ΨΦ are satisfied.\nAdditionally, we can use the same proof as for DLPs to show that condition (f). It remains to show that the condition (g) of ΨΦ is satisfied. Let P be a DLP,X ,Y ,Z be interpretations such that X ,Y ∈ PΦ(Z ). Assume toward a contradiction that X ∩ Y /∈ PΦ(Z ). By (ii) we get that SE(P ⋆ lp({(X ,Z ), (Y ,Z ), (Z ,Z ), (X ∩Y ,Z )})) = {(X ,Y ), (Y ,Y ), (Z ,Z )}, which is not closed under here-intersection since (X ∩ Y ,Z ) does not belong to it. This contradicts the fact that P ⋆ lp({(X ,Z ), (Y ,Z ), (Z ,Z ), (X ∩Y ,Z )}) is a NLP, i.e., that ⋆ is a NLP revision operator.\n(If part) We consider a NLP parted assignment (Φ,ΨΦ) defined as the DLP parted assignment in the if part of the proof for the DLP case. Then defined an operator ⋆ associating two NLPs P ,Q with a new NLP P ⋆Q such that for all NLPs P ,Q, SE(P ⋆Q) = {(X ,Y ) | (X ,Y ) ∈ SE(Q),Y ∈ min(mod(Q),≤P),X ∈ PΦ(Y )}. We already showed that SE(P ⋆Q) is well-defined and complete, and condition (g) of the Φ-based normal assignment ΨΦ directly implies that SE(P ⋆Q) is closed under here-intersection. Therefore, P ⋆ Q is a NLP. The proof that ⋆ satisfies postulates (RA1 - RA6) is identical to the one of Proposition 3."
    } ],
    "references" : [ {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "C.E. Alchourrón", "P. Gärdenfors", "D. Makinson" ],
      "venue" : "Journal of Symbolic Logic 50, 2, 510–530.",
      "citeRegEx" : "Alchourrón et al\\.,? 1985",
      "shortCiteRegEx" : "Alchourrón et al\\.",
      "year" : 1985
    }, {
      "title" : "Dynamic updates of non-monotonic knowledge bases",
      "author" : [ "J.J. Alferes", "J.A. Leite", "L.M. Pereira", "H. Przymusinska", "T.C. Przymusinski" ],
      "venue" : "Journal of Logic Programming 45, 1-3, 43–70.",
      "citeRegEx" : "Alferes et al\\.,? 2000",
      "shortCiteRegEx" : "Alferes et al\\.",
      "year" : 2000
    }, {
      "title" : "Propositional theories are strongly equivalent to logic programs",
      "author" : [ "P. Cabalar", "P. Ferraris" ],
      "venue" : "Theory and Practice of Logic Programming 7, 6.",
      "citeRegEx" : "Cabalar and Ferraris,? 2007",
      "shortCiteRegEx" : "Cabalar and Ferraris",
      "year" : 2007
    }, {
      "title" : "Investigations into a theory of knowledge base revision: preliminary report",
      "author" : [ "M. Dalal" ],
      "venue" : "Proceedings of the 7th National Conference on Artificial Intelligence (AAAI’88). 475–479.",
      "citeRegEx" : "Dalal,? 1988",
      "shortCiteRegEx" : "Dalal",
      "year" : 1988
    }, {
      "title" : "AGM-style belief revision of logic programs under answer set semantics",
      "author" : [ "J.P. Delgrande", "P. Peppas", "S. Woltran" ],
      "venue" : "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’13). 264– 276.",
      "citeRegEx" : "Delgrande et al\\.,? 2013a",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2013
    }, {
      "title" : "A preference-based framework for updating logic programs",
      "author" : [ "J.P. Delgrande", "T. Schaub", "H. Tompits" ],
      "venue" : "Proceedings of the 9th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’07). 71–83.",
      "citeRegEx" : "Delgrande et al\\.,? 2007",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2007
    }, {
      "title" : "Belief revision of logic programs under answer set semantics",
      "author" : [ "J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran" ],
      "venue" : "Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR’08). 411– 421.",
      "citeRegEx" : "Delgrande et al\\.,? 2008",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2008
    }, {
      "title" : "Merging logic programs under answer set semantics",
      "author" : [ "J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran" ],
      "venue" : "Proceedings of the 25th International Conference on Logic Programming (ICLP’09). 160–174.",
      "citeRegEx" : "Delgrande et al\\.,? 2009",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2009
    }, {
      "title" : "A modeltheoretic approach to belief change in answer set programming",
      "author" : [ "J.P. Delgrande", "T. Schaub", "H. Tompits", "S. Woltran" ],
      "venue" : "ACM Transactions on Computational Logic 14, 2, 1–46.",
      "citeRegEx" : "Delgrande et al\\.,? 2013b",
      "shortCiteRegEx" : "Delgrande et al\\.",
      "year" : 2013
    }, {
      "title" : "On properties of update sequences based on causal rejection",
      "author" : [ "T. Eiter", "M. Fink", "G. Sabbatini", "H. Tompits" ],
      "venue" : "Theory and Practice of Logic Programming 2, 6, 711–767.",
      "citeRegEx" : "Eiter et al\\.,? 2002",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2002
    }, {
      "title" : "On solution correspondences in answer set programming",
      "author" : [ "T. Eiter", "H. Tompits", "S. Woltran" ],
      "venue" : "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI’05). 97–102.",
      "citeRegEx" : "Eiter et al\\.,? 2005",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2005
    }, {
      "title" : "Negation as failure in the head",
      "author" : [ "K. Inoue", "C. Sakama" ],
      "venue" : "Journal of Logic Programming 35, 1, 39–78.",
      "citeRegEx" : "Inoue and Sakama,? 1998",
      "shortCiteRegEx" : "Inoue and Sakama",
      "year" : 1998
    }, {
      "title" : "A unified view of propositional knowledge base updates",
      "author" : [ "H. Katsuno", "A.O. Mendelzon" ],
      "venue" : "Proceedings of the 11th International Joint Conference on Artificial Intelligence (IJCAI’89). 1413–1419.",
      "citeRegEx" : "Katsuno and Mendelzon,? 1989",
      "shortCiteRegEx" : "Katsuno and Mendelzon",
      "year" : 1989
    }, {
      "title" : "On the difference between updating a knowledge base and revising it",
      "author" : [ "H. Katsuno", "A.O. Mendelzon" ],
      "venue" : "Proceedings of the 2nd International Conference on Principles of Knowledge Representation and Reasoning (KR’91). 387–394.",
      "citeRegEx" : "Katsuno and Mendelzon,? 1991",
      "shortCiteRegEx" : "Katsuno and Mendelzon",
      "year" : 1991
    }, {
      "title" : "Propositional knowledge base revision and minimal change",
      "author" : [ "H. Katsuno", "A.O. Mendelzon" ],
      "venue" : "Artificial Intelligence 52, 3, 263–294.",
      "citeRegEx" : "Katsuno and Mendelzon,? 1992",
      "shortCiteRegEx" : "Katsuno and Mendelzon",
      "year" : 1992
    }, {
      "title" : "Merging information under constraints: a logical framework",
      "author" : [ "S. Konieczny", "R. Pino Pérez" ],
      "venue" : "Journal of Logic and Computation 12, 5, 773–808.",
      "citeRegEx" : "Konieczny and Pérez,? 2002",
      "shortCiteRegEx" : "Konieczny and Pérez",
      "year" : 2002
    }, {
      "title" : "Belief revision and update: Complexity of model checking",
      "author" : [ "P. Liberatore", "M. Schaerf" ],
      "venue" : "Journal of Computer and System Sciences 62, 1, 43–72.",
      "citeRegEx" : "Liberatore and Schaerf,? 2001",
      "shortCiteRegEx" : "Liberatore and Schaerf",
      "year" : 2001
    }, {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "V. Lifschitz", "D. Pearce", "A. Valverde" ],
      "venue" : "ACM Transactions on Computational Logic 2, 4, 526–541.",
      "citeRegEx" : "Lifschitz et al\\.,? 2001",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 2001
    }, {
      "title" : "Computational complexity",
      "author" : [ "C.M. Papadimitriou" ],
      "venue" : "Addison-Wesley, Reading, Massachusetts.",
      "citeRegEx" : "Papadimitriou,? 1994",
      "shortCiteRegEx" : "Papadimitriou",
      "year" : 1994
    }, {
      "title" : "An abductive framework for computing knowledge base updates",
      "author" : [ "C. Sakama", "K. Inoue" ],
      "venue" : "Theory and Practice of Logic Programming 3, 6, 671–713.",
      "citeRegEx" : "Sakama and Inoue,? 2003",
      "shortCiteRegEx" : "Sakama and Inoue",
      "year" : 2003
    }, {
      "title" : "Nonmonotonic reasoning by minimal belief revision",
      "author" : [ "K. Satoh" ],
      "venue" : "Proceedings of FGCS’88. 455–462.",
      "citeRegEx" : "Satoh,? 1988",
      "shortCiteRegEx" : "Satoh",
      "year" : 1988
    }, {
      "title" : "Characterization theorems for revision of logic programs",
      "author" : [ "N. Schwind", "K. Inoue" ],
      "venue" : "Proceedings of the 12th International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’13). 485–498.",
      "citeRegEx" : "Schwind and Inoue,? 2013",
      "shortCiteRegEx" : "Schwind and Inoue",
      "year" : 2013
    }, {
      "title" : "On semantic update operators for answer-set programs",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "Proceedings of the 19th European Conference on Artificial Intelligence (ECAI’10). 957–962.",
      "citeRegEx" : "Slota and Leite,? 2010",
      "shortCiteRegEx" : "Slota and Leite",
      "year" : 2010
    }, {
      "title" : "Robust equivalence models for semantic updates of answer-set programs",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "Proceedings of the 13th International Conference on Principles of Knowledge Representation and Reasoning (KR’12). 156–168.",
      "citeRegEx" : "Slota and Leite,? 2012",
      "shortCiteRegEx" : "Slota and Leite",
      "year" : 2012
    }, {
      "title" : "The rise and fall of semantic rule updates based on SE-models",
      "author" : [ "M. Slota", "J. Leite" ],
      "venue" : "CoRR abs/1306.3884.",
      "citeRegEx" : "Slota and Leite,? 2013",
      "shortCiteRegEx" : "Slota and Leite",
      "year" : 2013
    }, {
      "title" : "Strong equivalence made easy: nested expressions and weight constraints",
      "author" : [ "H. Turner" ],
      "venue" : "Theory and Practice of Logic Programming 3, 4-5, 609–622.",
      "citeRegEx" : "Turner,? 2003",
      "shortCiteRegEx" : "Turner",
      "year" : 2003
    }, {
      "title" : "Logic program-based updates",
      "author" : [ "Y. Zhang" ],
      "venue" : "ACM Transactions on Computational Logic 7, 3, 421–472.",
      "citeRegEx" : "Zhang,? 2006",
      "shortCiteRegEx" : "Zhang",
      "year" : 2006
    }, {
      "title" : "Towards generalized rule-based updates",
      "author" : [ "Y. Zhang", "N.Y. Foo" ],
      "venue" : "Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI’97). 82–88.",
      "citeRegEx" : "Zhang and Foo,? 1997",
      "shortCiteRegEx" : "Zhang and Foo",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "Based on the structure of SE interpretations, Delgrande et al. (2008; 2013b) adapted the well-known AGM framework (1985) to logic program (LP) revision.",
      "startOffset" : 46,
      "endOffset" : 121
    }, {
      "referenceID" : 21,
      "context" : "∗ This is a revised and full version (including proofs of propositions) of (Schwind and Inoue 2013).",
      "startOffset" : 75,
      "endOffset" : 99
    }, {
      "referenceID" : 13,
      "context" : ", revision and update (Katsuno and Mendelzon 1991), and characterized axiomatically each one of these change operations by a set of socalled KM postulates.",
      "startOffset" : 22,
      "endOffset" : 50
    }, {
      "referenceID" : 27,
      "context" : "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.",
      "startOffset" : 98,
      "endOffset" : 216
    }, {
      "referenceID" : 1,
      "context" : "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.",
      "startOffset" : 98,
      "endOffset" : 216
    }, {
      "referenceID" : 9,
      "context" : "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.",
      "startOffset" : 98,
      "endOffset" : 216
    }, {
      "referenceID" : 19,
      "context" : "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.",
      "startOffset" : 98,
      "endOffset" : 216
    }, {
      "referenceID" : 26,
      "context" : "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.",
      "startOffset" : 98,
      "endOffset" : 216
    }, {
      "referenceID" : 5,
      "context" : "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence.",
      "startOffset" : 98,
      "endOffset" : 216
    }, {
      "referenceID" : 9,
      "context" : "Indeed, given the nonmonotonic nature of LPs the AGM/KM postulates can not be directly applied to logic programs (Eiter et al. 2002).",
      "startOffset" : 113,
      "endOffset" : 132
    }, {
      "referenceID" : 17,
      "context" : "Initially, SE models were used to characterize the strong equivalence between logic programs (Lifschitz et al. 2001): precisely, two LPs have the same set of SE models if and only if they are strongly equivalent, that is to say, they admit the same answer sets, and will still do even after adding any arbitrary set of rules to them.",
      "startOffset" : 93,
      "endOffset" : 116
    }, {
      "referenceID" : 4,
      "context" : "Katsuno and Mendelzon (1992) adapted these principles to the case of propositional logic, distinguished two kind of change operations, i.",
      "startOffset" : 0,
      "endOffset" : 29
    }, {
      "referenceID" : 1,
      "context" : "Most of works dealing with belief change in logic programming are concerned with rulebased update (Zhang and Foo 1997; Alferes et al. 2000; Eiter et al. 2002; Sakama and Inoue 2003; Zhang 2006; Delgrande et al. 2007), and they do not lie into the AGM framework, particularly due to their syntactic essence. Indeed, given the nonmonotonic nature of LPs the AGM/KM postulates can not be directly applied to logic programs (Eiter et al. 2002). However, the notion of SE models introduced by Turner (2003) provided a monotonic semantical characterization of LPs, which is more expressive than the answer set semantics.",
      "startOffset" : 119,
      "endOffset" : 502
    }, {
      "referenceID" : 11,
      "context" : "In this paper, we give a particular consideration to the revision of generalized logic programs (GLPs) (Inoue and Sakama 1998) which are of very general form.",
      "startOffset" : 103,
      "endOffset" : 126
    }, {
      "referenceID" : 14,
      "context" : "Interestingly, the first one, called here LP faithful assignment, is similar to the structure of faithful assignment defined in (Katsuno and Mendelzon 1992) and used to characterize the (rational) KM revision operators in the propositional setting; the second one, called here well-defined assignment, can be defined independently from the first one.",
      "startOffset" : 128,
      "endOffset" : 156
    }, {
      "referenceID" : 4,
      "context" : "We formally compare our characterization result with another recent one proposed in (Delgrande et al. 2013a); the benefit of our approach is that our construction is one-to-one, as opposite to Delgrande et al.",
      "startOffset" : 84,
      "endOffset" : 108
    }, {
      "referenceID" : 21,
      "context" : "This version of the paper is a revised and extended version of a published LPNMR’13 paper (Schwind and Inoue 2013).",
      "startOffset" : 90,
      "endOffset" : 114
    }, {
      "referenceID" : 4,
      "context" : "The main extensions include a comparison of our main characterization result with the one proposed in (Delgrande et al. 2013a), some complexity results, characterization results for DLP and NLP revision operators and the proofs of propositions.",
      "startOffset" : 102,
      "endOffset" : 126
    }, {
      "referenceID" : 0,
      "context" : "The AGM framework (Alchourrón et al. 1985) describes the standard principles for belief revision (e.",
      "startOffset" : 18,
      "endOffset" : 42
    }, {
      "referenceID" : 0,
      "context" : "The AGM framework (Alchourrón et al. 1985) describes the standard principles for belief revision (e.g., consistency preservation and minimality of change), which capture changes occuring in a static domain. Katsuno and Mendelzon (1991) equivalently rephrased the AGM postulates as follows:",
      "startOffset" : 19,
      "endOffset" : 236
    }, {
      "referenceID" : 13,
      "context" : "Indeed, each KM revision operator is associated with some faithful assignment (Katsuno and Mendelzon 1991).",
      "startOffset" : 78,
      "endOffset" : 106
    }, {
      "referenceID" : 3,
      "context" : "KM revision operators include the class of distance-based revision operators (see, for instance, (Dalal 1988)), i.",
      "startOffset" : 97,
      "endOffset" : 109
    }, {
      "referenceID" : 0,
      "context" : "This operator was first introduced in (Alchourrón et al. 1985) under the name of full meet revision function.",
      "startOffset" : 38,
      "endOffset" : 62
    }, {
      "referenceID" : 0,
      "context" : ", all AGM postulates in (Alchourrón et al. 1985)), it is often considered as unreasonable because it throws away all the old beliefs if the new formula is inconsistent with them.",
      "startOffset" : 24,
      "endOffset" : 48
    }, {
      "referenceID" : 3,
      "context" : "Likewise, the revision operator based on Hamming distance dH is equivalent to the well-known Dalal revision operator (Dalal 1988).",
      "startOffset" : 117,
      "endOffset" : 129
    }, {
      "referenceID" : 3,
      "context" : "In fact, in (Dalal 1988) the Dalal revision is also defined in a modelwise fashion, i.",
      "startOffset" : 12,
      "endOffset" : 24
    }, {
      "referenceID" : 6,
      "context" : "We use the same notations as in (Delgrande et al. 2008).",
      "startOffset" : 32,
      "endOffset" : 55
    }, {
      "referenceID" : 25,
      "context" : "SE interpretations are semantic structures characterizing strong equivalence between logic programs (Turner 2003), they provide a monotonic semantic foundation of logic programs under answer set semantics.",
      "startOffset" : 100,
      "endOffset" : 113
    }, {
      "referenceID" : 10,
      "context" : "Moreover, from every well-defined set S of SE models, one can build a GLP P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).",
      "startOffset" : 96,
      "endOffset" : 142
    }, {
      "referenceID" : 2,
      "context" : "Moreover, from every well-defined set S of SE models, one can build a GLP P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).",
      "startOffset" : 96,
      "endOffset" : 142
    }, {
      "referenceID" : 6,
      "context" : "Definition 7 (Expansion operator (Delgrande et al. 2008)) Given two programs P ,Q, the expansion of P by Q, denoted P+Q is any program R such that SE(R) = SE(P) ∩ SE(Q).",
      "startOffset" : 33,
      "endOffset" : 56
    }, {
      "referenceID" : 8,
      "context" : "We refer the reader to (Delgrande et al. 2013b), Section 3.",
      "startOffset" : 23,
      "endOffset" : 47
    }, {
      "referenceID" : 6,
      "context" : "Definition 9 (GLP revision operator (Delgrande et al. 2008)) A GLP revision operator ⋆ is an LP revision operator that satisfies the following postulates, for all GLPs P ,P1,P2,Q,Q1,Q2,R:",
      "startOffset" : 36,
      "endOffset" : 59
    }, {
      "referenceID" : 20,
      "context" : "(2008) proposed a revision operator inspired from Satoh’s propositional revision operator (Satoh 1988).",
      "startOffset" : 90,
      "endOffset" : 102
    }, {
      "referenceID" : 12,
      "context" : "Though it seems to have a good behavior on some instances, this operator does not satisfy (RA6), so that it does not fully respect the principle of minimality of change (see (Katsuno and Mendelzon 1989), Section 3.",
      "startOffset" : 174,
      "endOffset" : 202
    }, {
      "referenceID" : 8,
      "context" : "However, the whole set of postulates is consistent, as they later introduce the so-called cardinality-based revision operator (Delgrande et al. 2013b) that reduces to the Dalal revision scheme over propositional models and that satisfies all the postulates (RA1 - RA6).",
      "startOffset" : 126,
      "endOffset" : 150
    }, {
      "referenceID" : 8,
      "context" : "The following definition is a concise, equivalent reformulation of the original one introduced in (Delgrande et al. 2013b), Definition 3.",
      "startOffset" : 98,
      "endOffset" : 122
    }, {
      "referenceID" : 3,
      "context" : "Delgrande et al. (2008) proposed a revision operator inspired from Satoh’s propositional revision operator (Satoh 1988).",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 8,
      "context" : "Theorem 2 (Delgrande et al. 2013b) ⋆c is a GLP revision operator.",
      "startOffset" : 10,
      "endOffset" : 34
    }, {
      "referenceID" : 4,
      "context" : ", generalized, disjunctive, normal, positive, and Horn, so we shall now compare our characterization with the one given in (Delgrande et al. 2013a) for the case of GLPs:",
      "startOffset" : 123,
      "endOffset" : 147
    }, {
      "referenceID" : 4,
      "context" : "As we already briefly mentionned in the introduction, Delgrande et al. (2013a) also recently proposed a constructive characterization of belief revision operators for logic programs that satisfy the whole set of postulates (RA1 - RA6).",
      "startOffset" : 54,
      "endOffset" : 79
    }, {
      "referenceID" : 4,
      "context" : "Definition 16 (GLP compliant faithful assignment (Delgrande et al. 2013a)) A GLP compliant faithful assignment is a mapping which associates every GLP P with a total preorder ≤P over SE interpretations such that for all GLPs P ,Q and all SE interpretations (X ,Y ), (X ,Y ), the following conditions hold:",
      "startOffset" : 49,
      "endOffset" : 73
    }, {
      "referenceID" : 4,
      "context" : "The following theorem is expressed as a combination of Theorems 4 and 5 from (Delgrande et al. 2013a) applied to GLPs:",
      "startOffset" : 77,
      "endOffset" : 101
    }, {
      "referenceID" : 4,
      "context" : "Theorem 3 (Delgrande et al. 2013a) An LP revision operator ⋆ is a GLP revision operator (i.",
      "startOffset" : 10,
      "endOffset" : 34
    }, {
      "referenceID" : 4,
      "context" : "2 In (Delgrande et al. 2013a), an additional postulate is considered in the characterization theorems, namely (Acyc).",
      "startOffset" : 5,
      "endOffset" : 29
    }, {
      "referenceID" : 4,
      "context" : "(Delgrande et al. 2013a), Theorem 2).",
      "startOffset" : 0,
      "endOffset" : 24
    }, {
      "referenceID" : 18,
      "context" : "We assume that the reader is familiar with the basic concepts of computational complexity, in particular with the classes P, NP and coNP (see (Papadimitriou 1994) for more details).",
      "startOffset" : 142,
      "endOffset" : 162
    }, {
      "referenceID" : 16,
      "context" : "We focus here on the the model-checking problem (Liberatore and Schaerf 2001) for LP revision operators.",
      "startOffset" : 48,
      "endOffset" : 77
    }, {
      "referenceID" : 10,
      "context" : "Conversely, if a set of SE interpretations S is complete (respectively, closed under here-intersection) then one can build a DLP (respectively, NLP) P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).",
      "startOffset" : 171,
      "endOffset" : 217
    }, {
      "referenceID" : 2,
      "context" : "Conversely, if a set of SE interpretations S is complete (respectively, closed under here-intersection) then one can build a DLP (respectively, NLP) P such that SE(P) = S (Eiter et al. 2005; Cabalar and Ferraris 2007).",
      "startOffset" : 171,
      "endOffset" : 217
    }, {
      "referenceID" : 24,
      "context" : ", dynamic support and fact update (see (Slota and Leite 2013) for more details).",
      "startOffset" : 39,
      "endOffset" : 61
    }, {
      "referenceID" : 22,
      "context" : "As to the case of update of logic programs Slota and Leite (2013) argued that semantic rule updates based on SE models seem to be inappropriate.",
      "startOffset" : 43,
      "endOffset" : 66
    }, {
      "referenceID" : 23,
      "context" : "In (Slota and Leite 2012) the same authors successfully reconciliate semantic-based and syntax-based approaches to updating logic programs: they considered different characterizations of logic programs in terms of RE models (standing for robust equivalence models) that proved to be a more suitable semantic fundation for rule updates than SE models.",
      "startOffset" : 3,
      "endOffset" : 25
    } ],
    "year" : 2015,
    "abstractText" : "We address the problem of belief revision of logic programs, i.e., how to incorporate to a logic program P a new logic program Q. Based on the structure of SE interpretations, Delgrande et al. (2008; 2013b) adapted the well-known AGM framework (1985) to logic program (LP) revision. They identified the rational behavior of LP revision and introduced some specific operators. In this paper, a constructive characterization of all rational LP revision operators is given in terms of orderings over propositional interpretations with some further conditions specific to SE interpretations. It provides an intuitive, complete procedure for the construction of all rational LP revision operators and makes easier the comprehension of their semantic and computational properties. We give a particular consideration to logic programs of very general form, i.e., the generalized logic programs (GLPs). We show that every rational GLP revision operator is derived from a propositional revision operator satisfying the original AGM postulates. Interestingly, the further conditions specific to GLP revision are independent from the propositional revision operator on which a GLP revision operator is based. Taking advantage of our characterization result, we embed the GLP revision operators into structures of Boolean lattices, that allow us to bring to light some potential weaknesses in the adapted AGM postulates. To illustrate our claim, we introduce and characterize axiomatically two specific classes of (rational) GLP revision operators which arguably have a drastic behavior. We additionally consider two more restricted forms of logic programs, i.e., the disjunctive logic programs (DLPs) ∗ This is a revised and full version (including proofs of propositions) of (Schwind and Inoue 2013). 2 N. Schwind and K. Inoue and the normal logic programs (NLPs) and adapt our characterization result to DLP and NLP revision operators.",
    "creator" : "LaTeX with hyperref package"
  }
}