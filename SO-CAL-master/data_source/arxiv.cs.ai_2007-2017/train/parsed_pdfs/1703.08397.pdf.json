{
  "name" : "1703.08397.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Reasoning by Cases in Structured Argumentation",
    "authors" : [ "Mathieu Beirlaen", "Jesse Heyninck" ],
    "emails" : [ "mathieubeirlaen@gmail.com,", "jesse.heyninck@gmail.com,", "christian.strasser@rub.de" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 3.\n08 39\n7v 1\n[ cs\n.A I]"
    }, {
      "heading" : "1 Introduction",
      "text" : "When formulated in terms of the material implication connective ‘⊃’, the pattern of reasoning by cases is valid in classical logic:\nϕ1 ∨ . . . ∨ ϕn, ϕ1 ⊃ ψ, . . . , ϕn ⊃ ψ ⊢ ψ (RBC⊃)\nMany formalisms of non-monotonic logic likewise allow defeasible applications of reasoning by cases, where a formula ‘ϕ ⇒ ψ’ reads ‘If ϕ, then normally/usually/probably ψ’:\nϕ1 ∨ . . . ∨ ϕn, ϕ1 ⇒ ψ, . . . , ϕn ⇒ ψ |∼ψ (RBC⇒)\n∗Research for this article was sponsored by a Sofja Kovalevskaja award of the Alexander von Humboldt Foundation, funded by the German Ministry for Education and Research. We are indebted to Leon van der Torre and Emil Weydert for helpful comments and suggestions.\nIn the context of formal argumentation, it is natural to include a more general argumentative version of the RBC rule. Relative to a knowledge base this rule would allow the construction of an rbc- argument C with conclusion ψ given (i) an argument A with the disjunctive conclusion ϕ1 ∨ . . . ∨ ϕn, and (ii) for each i ∈ {1, . . . , n}, an argument Bi with conclusion ψ based on an extended knowledge base including ϕi. To the best of our knowledge, no such rule has yet been introduced and studied in the context of formal argumentation. The aim of this paper is to do exactly this, and to investigate the nature of ‘argumentation by cases’.\nFor defining rbc-arguments and attacks on rbc-arguments, we will extend the ASPIC+ framework [8]. ASPIC+ is a framework for instantiating abstract argumentation frameworks as conceptualized by Dung [4]. We introduce abstract argumentation frameworks in Section 2, and define our formalism in Section 3. Our approach is limited in at least two ways. First, we do not allow for nested or iterated rbc-arguments. Second, we do not yet take into account priorities assigned to arguments, nor do we include undercutting attacks. The removal of these limitations is left for future work.\nThe present approach raises new questions regarding the nature of arguing by cases. For instance, what happens if in the rbc-argument C one of the arguments Bi is rebutted by an independent argument? Is this a sufficient condition for rejecting argument C? After all, there are n− 1 other defeasible ‘paths’ leading to C’s conclusion. Our formalism implements a cautious rationale according to which a successful rebut on one of its paths is indeed sufficient for rejecting an rbc-argument. In Section 4 we show how this approach leads to intuitive outcomes different from those obtained by other formalisms in non-monotonic logic."
    }, {
      "heading" : "2 Abstract argumentation",
      "text" : "A Dung-style abstract argumentation framework (AF) is a pair (Arg, Att) where Arg is a set of arguments and Att ⊆ Arg × Arg is a binary relation of attack. Relative to an AF, Dung defines a number of extensions – subsets of Arg – on the basis of which we can evaluate the arguments in Arg.\nDefinition 1 (Defense). A set of arguments X defends an argument A iff every attacker of A is attacked by some B ∈ X .\nDefinition 2 (Extensions). Let (Arg, Att) be an AF. If E ⊆ Arg is conflictfree, i.e. there are no A,B ∈ E for which (A,B) ∈ Att, then (i) E is a complete extension iff A ∈ E whenever E defends A; (ii) E is a preferred extension iff it is a set inclusion maximal complete extension; and (iii) E is the grounded extension iff it is the set inclusion minimal complete extension.\nDung [4] showed that for every AF there is a unique grounded extension. On Dung’s abstract approach from [4], arguments are basic units of analysis the internal structure of which is not represented. In what follows we will instantiate\nabstract arguments by allowing for the representation of their internal logical structure."
    }, {
      "heading" : "3 Argumentation by cases",
      "text" : "In this section we define structured argumentation frameworks (SAFs) for reasoning by cases. Our point of departure is an instantiation of the ASPIC+ framework (without priorities, without defeasible premises and without undercuts).\nWe adjust ASPIC+ in the following ways. (i) We define a new type of argument called an rbc-argument (see point 4 in Definition 4). By means of rbc-arguments, we can argue by cases in an argumentation formalism (Section 3.1). (ii) We generalize the attack relation so as to include argumentation by cases, using the concept of a hypothetical argument (Section 3.2), and we define a logical consequence relation for the resulting SAFs (Section 3.3). We briefly discuss the meta-theoretical properties of our framework (Section 3.4)."
    }, {
      "heading" : "3.1 Arguments",
      "text" : "We illustrate our framework using the propositional fragment of classical logic (CL) as our core logic. We denote the consequence relation of CL by ⊢. To obtain the formal language L ofCL, we close a denumerable stock P = {p, q, r, . . .} of propositional letters under the usual CL-connectives ¬,∨,∧,⊃,≡. We also add the verum constant ⊤ and the falsum constant ⊥ to L. For reasons of transparency we will sometimes use subscripted letters p1, p2, q1, q2, . . . as names for propositional letters.\nDefinition 3 (Argumentation theory). An argumentation theory (AT) is a triple AT = (L,R,F) where:\n• L is our formal language defined above;\n• R = S ∪D is a set of strict (S) and defeasible (D) inference rules of the form ϕ1, . . . , ϕn → ψ and ϕ1, . . . , ϕn ⇒ ψ respectively (where ϕ1, . . . , ϕn, ψ ∈ L); and\n• F ⊆ L is a CL-consistent knowledge base.1\nWe assume in addition that ϕ1, . . . , ϕn → ψ ∈ S iff {ϕ1, . . . , ϕn} ⊢ ψ. Since we keep L and S fixed, we will in the remainder refer to ATs as pairs (D,F).\nDefinition 4 (Arguments). Given an argumentation theory AT = (D,F), the set of arguments Arg⊥(AT) contains:"
    }, {
      "heading" : "1. A = 〈φ〉 where φ ∈ F",
      "text" : "• Conc(A) = φ\n• Sub(A) = {A}\n1F ⊆ L is CL-consistent iff F 6⊢ ⊥.\n• HSub(A) = ∅\n2. A = 〈A1, . . . , An → φ〉 where A1, . . . , An ∈ Arg⊥(AT) and Conc(A1), . . . , Conc(An) → φ ∈ S\n• Conc(A) = φ\n• Sub(A) = {A} ∪ Sub(A1) ∪ . . . ∪ Sub(An)\n• HSub(A) = HSub(A1) ∪ . . . ∪ HSub(An)\n3. A = 〈A1, . . . , An ⇒ φ〉 where A1, . . . , An ∈ Arg⊥(AT) and Conc(A1), . . . , Conc(An) ⇒ φ ∈ D\n• Conc(A) = φ\n• Sub(A) = {A} ∪ Sub(A1) ∪ . . . ∪ Sub(An)\n• HSub(A) = HSub(A1) ∪ . . . ∪ HSub(An)\n4. A = 〈A1, [A2], . . . , [An] φ〉 where n ≥ 3\n• φ = ∨\n{Conc(A2), . . . , Conc(An)},\n• Conc(A1) = ∨n i=2 ψi, Ai ∈ Arg ⊥((D,F ∪ {ψi})), • and HSub(Ai) = ∅ for all 2 ≤ i ≤ n.\nWe have:\n• Conc(A) = φ\n• Sub(A) = {A} ∪ Sub(A1)\n• HSub(A) = HSub(A1) ∪ {(A2, ψ2), . . . , (An, ψn)}\nDefinition 4 departs in two respects from the way arguments are usually defined in ASPIC+. First, there is a new class of arguments constructed by means of rule 4: these arguments are called rbc-arguments. They correspond to applications of the reasoning by cases scheme outlined in Section 1.\nExample 1. Let D = {⊤ ⇒ p∨ q; p⇒ p1; p1 ⇒ p2; p2 ⇒ r; q ⇒ q1; q1 ⇒ r} and AT = (D, {⊤}). The following are arguments in Arg⊥(AT):\nA1 = 〈〈⊤〉 ⇒ p ∨ q〉\nA2 = 〈A1, [〈〈〈p〉 ⇒ p1〉 ⇒ p2〉 ⇒ r], [〈〈q〉 ⇒ q1〉 ⇒ r] r〉\nA3 = 〈A1, [〈p〉 ⇒ p1], [〈q〉 ⇒ q1] p1 ∨ q1〉\nA2 and A3 are rbc-arguments constructed on the basis of the ‘cases’ p and q in the disjunctive conclusion of A1. Argument A2 concludes that r, while A3 concludes that p1 ∨ q1.\nThe second novel feature of Definition 4 is that we not only keep track of an argument A’s conclusion (Conc(A)) and its sub-arguments (Sub(A)), but also of its hypothetical sub-arguments (HSub(A)). These are pairs consisting of an argument B and a formula φ, where B is constructible on the basis of the extended AT obtained by adding φ to the knowledge base of the original AT. For instance, HSub(A2) = {( 〈〈〈〈p〉 ⇒ p1〉 ⇒ p2〉 ⇒ r〉, p ) , ( 〈〈〈q〉 ⇒ q1〉 ⇒ r〉, q )} .\nA2’s hypothetical sub-argument (〈〈〈〈p〉 ⇒ p1〉 ⇒ p2〉 ⇒ r〉, p) contains the argument 〈〈〈〈p〉 ⇒ p1〉 ⇒ p2〉 ⇒ r〉 constructible on the basis of the AT (D, {⊤, p}).\nRemark 1. If one is interested in reducing the size of Arg⊥(AT), one may only allow for minimal disjunctions when generating arguments of type 4. More precisely, where A1 is of the form 〈B1, . . . , Bm → ∨n\ni=1 ψi〉 or 〈B1, . . . , Bm ⇒ ∨n\ni=1 ψi〉, A = 〈A1, [A2], . . . , [An] φ〉 ∈ Arg ⊥(AT) only if there is no\n∨\nj∈J ψj where J ⊂ {2, . . . , n} for which Conc(B1), . . . , Conc(Bm) → ∨ j∈J ψj ∈ S.\nDefinition 4 allows for the construction of arguments containing subarguments the conclusions of which are jointly inconsistent, such as arguments A1 and A2 in the following example, both of which rely on both p and ¬p in their construction.\nExample 2. Let AT = ({⊤ ⇒ s,⊤ ⇒ p, p⇒ ¬p}, {⊤}).\nA0 = 〈〈⊤〉 ⇒ p〉 A2 = 〈A0, A1 → ¬s〉\nA1 = 〈A0 ⇒ ¬p〉 A3 = 〈〈⊤〉 ⇒ s〉\nWhen CL is used as the underlying logic, inconsistent arguments like A1 and A2 may contaminate our formalism by blocking intuitively acceptable arguments like A3. (This is because the conclusions of A2 and A3 are conflicting, causing A2 to attack and exclude A3, cfr. infra.) Contamination problems of this kind have been studied and tackled in ASPIC+ [3, 10]. We can avoid them by filtering out inconsistent arguments.\nDefinition 5. We define †A for an argument A recursively as follows:\n• †〈φ〉 = φ\n• †A = φ ∧ †B1 ∧ . . . ∧ †Bn where A = 〈B1, . . . , Bn → φ〉\n• †A = φ ∧ †B1 ∧ . . . ∧ †Bn where A = 〈B1, . . . , Bn ⇒ φ〉\n• †A = φ ∧ †B1 ∧ (†B2 ∨ . . . ∨ †Bn) where A = 〈B1, [B2], . . . [Bn] φ〉.\nDefinition 6. An argument A is inconsistent iff †A ⊢ ⊥. Otherwise A is consistent. Relative to AT = (D,F), Arg(AT) is Arg⊥(AT) without inconsistent arguments.\nFor arguments without occurrences of our definition of inconsistent arguments is equivalent to that of [10]. In the remainder we will focus on the set Arg(AT) rather than Arg⊥(AT), avoiding contamination problems."
    }, {
      "heading" : "3.2 Attacks",
      "text" : "In ASPIC+, attacks are defined in terms of a generic contrariness operator. We define them in terms of ‘¬’, so that arguments the conclusions of which are classical contradictories attack each other. We have to be careful when defining argumentative attacks when rbc-arguments are involved, since we must\ntake into account the hypothetical sub-arguments of an rbc-argument. New questions arise here. For instance, an argument’s hypothetical sub-argument may conflict with a non-hypothetical argument.\nExample 3. Let AT = (D,F), with D = {p ⇒ q ∨ r; q ⇒ s; s ⇒ v; r ⇒ v; t⇒ ¬s} and F = {p, t}.\nA1 = 〈 〈〈p〉 ⇒ q ∨ r〉, [〈〈q〉 ⇒ s〉 ⇒ v], [〈r〉 ⇒ v] v 〉\nA2 = 〈 〈t〉 ⇒ ¬s 〉\nIn Example 3, the non-hypothetical argument A2 is in conflict with the argument 〈〈q〉 ⇒ s〉 ⇒ v, which belongs to A1’s hypothetical sub-argument (〈〈〈q〉 ⇒ s〉 ⇒ v〉, q). The desirable outcome in this example is that A2 attacks A1, but not vice versa.\nAs a further illustration, consider the following scenario.\nExample 4. AT = (D,F), with D = {p ⇒ (q ∨ r); q ⇒ s1; s1 ⇒ s2; s2 ⇒ v; r ⇒ v; q ⇒ ¬s1} and F = {p}.\nA0 = 〈〈p〉 ⇒ q ∨ r〉\nA1 = 〈A0, [〈〈〈q〉 ⇒ s1〉 ⇒ s2〉 ⇒ v], [〈r〉 ⇒ v] v〉\nThe following argument is constructible on the basis of the extended theory AT′ = (D,F ∪ {q}):\nA2 = 〈〈q〉 ⇒ ¬s1〉.\nA1 contains the intermediate conclusion s2 based on the assumption q. However, A2 concludes that ¬s2 on the basis of the same assumption, q. The desirable outcome in this example is to let A1 and A2 attack each other, since these arguments were both constructed on the basis of our knowledge base plus the assumption that q, and since their conclusions are contradictories.\nTo handle examples like these, we introduce the set HArg(D,F) of all arguments that can be constructed on the basis of some disjunct used in the construction of an rbc-argument in Arg(D,F).\nWhere A is an argument and φ a formula, π1(A, φ) = A and π2(A, φ) = φ. We lift the definition as usual: where i ∈ {1, 2}, πi(∆) = {πi(A, φ) | (A, φ) ∈ ∆}.\nWhere φ ∈ L\\F , AT = (D,F) and AT′ = (D,F∪{φ}), we denote Arg(AT′)\\ Arg(AT) by Argφ(AT).\nDefinition 7 (Hypothetical Arguments). Where AT = (D,F), HArg(AT) is the set of all A ∈ Argφ(AT) such that φ ∈ π2(HSub(B)) for some B ∈ Arg(AT).\nDefinition 8 (Attacks, Rebuts). For a given theory AT, we define a direct attack relation\nAtt(AT) ⊆ (Arg(AT)× Arg(AT))\n∪ (Arg(AT)× HArg(AT))\n∪ (HArg(AT)× HArg(AT))\nas follows: A directly attacks B iff B is of the form 〈. . . ⇒ Conc(B)〉, (Conc(A) = ¬Conc(B) or Conc(B) = ¬Conc(A)), and\n• A ∈ Arg(AT) and B ∈ Arg(AT) or\n• A ∈ Arg(AT) and B ∈ HArg(AT) or\n• A ∈ Argφ(AT) and B ∈ Argφ(AT) for some φ ∈ L \\ F .\nWe lift the definition recursively in the following way: A attacks B if A directly attacks B or it attacks some C ∈ (Sub(B) \\ {B}) ∪ ⋃\nπ1(HSub(B)).\nFor an argument A to directly attack an argument B, the following requirements need to be fulfilled: The conclusion of A conflicts with the conclusion of B and (either A is non-hypothetical, or A and B are hypothetical arguments based on the same assumption φ).\nTo illustrate how this works, reconsider our examples. In Example 3, 〈〈q〉 ⇒ s〉 ∈ HArg(AT) and A2 directly attacks 〈〈q〉 ⇒ s〉, so A2 attacks A1 (but not vice versa). In Example 4 the arguments 〈〈q〉 ⇒ s1〉 and A2 are in Argq(AT), so these arguments directly attack each other. Consequently, A2 also attacks A1."
    }, {
      "heading" : "3.3 Consequence relations",
      "text" : "Definition 9. The structured argumentation framework (in short, SAF) defined by the theory AT is the pair (Arg(AT) ∪ HArg(AT), Att(AT)).\nGiven a SAF, we can use the argumentation semantics from Section 2 to define consequence relations:\nDefinition 10. Let SAF = (Arg(AT) ∪ HArg(AT), Att(AT)), let sem ∈ {Cmp,Prf,Grd}, and let Cmp(SAF), Prf(SAF), and Grd(SAF) denote the sets of SAF’s complete extensions, SAF’s preferred extensions, and SAF’s grounded extension respectively. • SAF |∼∩ sem\nφ iff for every B ∈ sem(SAF) there is an A ∈ B ∩ Arg(AT) with conc(A) = φ.\n• SAF |∼⋓ sem φ iff there is a B ∈ ⋂ sem(SAF) ∩ Arg(AT) with conc(A) = φ. Since the grounded extension is unique both definitions coincide for sem = Grd.\nRelative to a theory AT, the ‘virtual’ arguments in HArg(AT) are capable of attacking arguments in Arg(AT) (in their hypothetical subarguments), and consequently of preventing the derivability of conclusions of arguments in Arg(AT). However, the conclusions of virtual arguments are never themselves derivable from AT."
    }, {
      "heading" : "3.4 Rationality postulates",
      "text" : "In [2, 3] several postulates were proposed to evaluate formalisms for structured argumentation. In the present context these postulates read as follows. Given a SAF (Arg(AT) ∪ HArg(AT), Att(AT)) where E ∈ Cmp(SAF):2\n2The proofs of these properties are to be found in the technical appendix as indicated below, except for te proof of non-interference which we omit due to space restrictions. The authors in [2] distinguish between direct and indirect consistency: in our framework these definitions are equivalent since our strict rules are closed under CL.\nSub-argument closure: where A ∈ E , Sub(A) ⊆ E (immediate in view of Theorem 1)\nClosure under strict rules: where A1, . . . , An ∈ E ∩ Arg(AT) and Conc(A1), . . . ,Conc(An) ⊢ B also 〈A1, . . . , An → B〉 ∈ E ∩ Arg(AT) (see Theorem 2),\nConsistency: {Conc(A) | A ∈ E ∩ Arg(AT)} is consistent (see Theorem 3),\nNon-interference: Let Atoms(F) [Atoms(D)] be the set of all atoms occurring in F [D]. Where AT = (D,F), AT′ = (D ∪ D′,F ∪ F ′), SAF = (Arg(AT) ∪ HArg(AT), Att(AT)), SAF′ = (Arg(AT′) ∪ HArg(AT), Att(AT′)), |∼ ∈ {|∼∩\nGrd , |∼⋓ Grd , |∼∩ Prf , |∼⋓ Prf }, Atoms(φ) ⊆ Atoms(D) ∪ Atoms(F), and\n(Atoms(D) ∪ Atoms(F)) ∩ (Atoms(D′) ∪ Atoms(F ′)) = ∅, we have:\nSAF |∼φ iff SAF′ |∼φ.\nThe property of non-interference can be used to show that the present framework avoids contamination problems of the kind discussed in Section 3.1 (see [3, 10])."
    }, {
      "heading" : "4 Related work",
      "text" : ""
    }, {
      "heading" : "4.1 Disjunctive Defaults",
      "text" : "In [5] a generalization of default logic, disjunctive default logic, is proposed that is more apt to deal with disjunctions than Reiter’s original approach. For instance, given the default theory with p∨ q and the defaults p⇒ r and q ⇒ r, r is not a default consequence in Reiter’s approach since the only extension of this theory is Cn(p ∨ q). In disjunctive default logic, an alternative disjunction | is available: p | q enforces that p or q is in any extension of the theory. So, for the default theory consisting of p | q, and the defaults p⇒ r and q ⇒ r we have two extensions, Cn({p, r}) and Cn({q, r}). Now r is a skeptical consequence. Default consequents can also make use of |: a disjunctive default is of the form:\nφ : ψ1, . . . , ψn γ1 | . . . | γm\nwhere φ is the prerequisite, ψ1, . . . , ψn are justifications, and γ1, . . . , γm are consequents of the default. A set of formulas Ξ is an extension of a disjunctive default theory consisting of the disjunctive defaults in ∆ (we here follow the convention in [5] according to which ’facts’ are considered as disjunctive defaults with empty prerequisite and empty justification) if it satisfies the following requirements: (i) for any φ:ψ1,...,ψn\nγ1|...|γm ∈ ∆, if φ ∈ Ξ and ¬ψ1, . . . ,¬ψn /∈ Ξ then\nγi ∈ Ξ for some 1 ≤ i ≤ m, (ii) Cn(Ξ) = Ξ, and (iii) Ξ is minimal with properties (i) and (ii).3\n3This definition in [5] is suboptimal in that it gives undesired results: e.g. for the theory\n∆ = {⊤ : ¬p ¬p } also Cn(p) will form an extension. The problem can easily be fixed though by defining extensions analogous to Reiter.\nWe compare our approach to disjunctive default logic by thinking of ⇒ as a default conditional: ψ ⇒ φ encodes the normal default ψ:φ\nφ . We start\nour comparison with the example given above. Let ∆1 = {p | q, p ⇒ r, q ⇒ r}. ∆1 has two extensions, Cn({p, r}) and Cn({q, r}) and so r is a skeptical consequence. This outcome corresponds to our approach for the theory AT1 = ({p ⇒ r, q ⇒ r}, {p ∨ q}): the argument 〈〈p ∨ q〉, [〈p〉 ⇒ r], [〈q〉 ⇒ r] r〉 is in all complete extensions of AT1.\nNext, consider Poole’s broken arm example [9]. Let l be “having a left broken arm”, r “having a right broken arm”, w “writing legibly”. On our approach, the theory ATarm = ({w ⇒ ¬r}, {l∨r, w}) gives rise to the argument 〈〈〈w〉 ⇒ ¬r〉, 〈l ∨ r〉 → l〉, which is in all complete extensions of ATarm. In contrast, the disjunctive default theory ∆arm = {l | r, w, w ⇒ ¬r} has two extensions Cn({l, w,¬r}) and Cn({r, w}). Since l /∈ Cn({r, w}), l is not a skeptical consequence in disjunctive default logic.\nFinally, reconsider the AT from Example 3. There are various ways in which we can translate this AT into a disjunctive default theory, e.g.4\n∆3 =\n{\np : q ∨ r q | r , q : s s , s : v v , r : v v , t : ¬s ¬s , p, t\n}\nFor ∆3 we have the extensions Cn({p, t, q, s, v}), Cn({p, t, q,¬s}), and Cn({p, t,¬s, r, v}), so v is not a skeptical consequence. This corresponds to our approach in which the argument A1 from Example 3 is excluded due to the attack by A2. However, on our approach A2 is in all complete extensions, so contrary to disjunctive default logic we obtain ¬s as a skeptical consequence."
    }, {
      "heading" : "4.2 The OR meta-rule",
      "text" : "A different approach for dealing with disjunctive information is to allow for inference rules that produce new conditionals from given conditionals. We, for instance, find the following rule in system P [6] and in several Input/Output logics [7]:\nψ ⇒ φ ψ′ ⇒ φ\nψ ∨ ψ′ ⇒ φ [OR]\nOne could define an ASPIC+-like system where arguments are constructed as in rules 1–3 in Definition 4, and in which the defeasible rules are closed under OR. For instance, given AT1 from Section 4.1 this allows to derive p ∨ q ⇒ r from p⇒ r and q ⇒ r, so that we can construct the argument 〈p ∨ q〉 ⇒ r and obtain r as a consequence.\nAdding OR is not sufficient to always get the intuitive outcome. Let AT4 = ({p ⇒ q ∨ r, q ⇒ s, s ⇒ v, r ⇒ u, u ⇒ v}, {p}). One would want to build an argument for v, but we cannot put OR to much use (except for deriving s ∨ u ⇒ v). We would have to combine OR with e.g. right-weakening (RW:\n4Our discussion also applies if we translate p ⇒ q ∨ r by p : q∧r q|r .\nψ⊢φ ψ′⇒ψ ψ′⇒φ ), or generalize OR to\nψ ⇒ φ ψ′ ⇒ φ′ ψ ∨ ψ′ ⇒ φ ∨ φ′ [gOR]\nin order to produce q ∨ r ⇒ s ∨ u. Since also s ∨ u ⇒ v ∨ v can be derived, we now have the means to construct the argument 〈〈〈p ⇒ q ∨ r〉 ⇒ s ∨ u〉 ⇒ v ∨ v〉 → v. In many systems of nonmonotonic logic, e.g. in system P and in many Input/Output logics, OR and RW are available (and thus gOR is a derived rule). We now contrast our approach with such (g)OR-based approaches.\nA striking difference concerns the handling of Example 3. In the gOR-based system we can construct:\nA3 = 〈〈〈p⇒ q ∨ r〉 ⇒ s ∨ v〉 ⇒ v ∨ v〉 → v\nThis argument is not attacked by the argument t ⇒ ¬s. An alternative argument for v is given by 〈t⇒ ¬s〉, 〈〈p ⇒ q∨r〉 ⇒ s∨v〉 → v. Recall that neither in our approach nor in disjunctive default logic v is a skeptical consequence. Even if we add ¬r to the knowledge base F in Example 3, v remains derivable in the gOR-based approach since A3 remains unchallenged. This is counter-intuitive: both the argumentative path via q ⇒ s⇒ v and the path via r ⇒ v are barred in view of the unchallenged arguments t ⇒ ¬s and ¬r. An advantage of using the reasoning-by-cases rule 4 in Definition 4 is that it provides more fine-grained ways of tracking commitments in sub-arguments. This enables us to block the undesired consequence v in this example.5"
    }, {
      "heading" : "5 Conclusion and outlook",
      "text" : "The ideas developed in this paper offer many interesting avenues for further work, partially consisting of the removal of the limitations assumed in this paper. For example, we did not consider nested rbc-arguments or various components that can be modelled in the ASPIC+-framework such as defeasible premises, undermining or undercut attacks. We also plan to present a less cautious variation of this framework where an attack on an rbc-argument A, [B1], . . . , [Bn] ψ succeeds only if each of the Bi’s is attacked. In addition we will investigate prioritized default rules in this framework. Here too, new questions arise. Consider, for instance, an argument 〈p ∨ q〉, [〈〈p〉 ⇒ s〉 ⇒ t], [〈q〉 ⇒ t] t. If in addition there is an argument 〈⊤〉 ⇒ ¬s which is preferred over 〈p〉 ⇒ s, then it seems intuitive to let the former attack the latter argument. But what if the hypothetical argument 〈p〉 ⇒ s has a higher degree of priority than the non-hypothetical 〈⊤〉 ⇒ ¬s? Should we decide in favor of the highest priority assigned, or should we never let a hypothetical argument attack a non-hypothetical one? More generally, how do we lift the priorities assigned to the (hypothetical and non-hypothetical) constituents of an rbc-argument? Difficult questions like\n5An additional advantage is that argument strength can be tracked in a more fine-grained way when using RbC in contrast to OR-based approaches. See also Section 5.\nthese will have to be answered in order to resolve conflicts between prioritized rbc-arguments.\nIn future work we also plan to investigate the use of an ordered disjunction ←− ∨ (see, e.g., [1]). For instance, a rule p ⇒ q ←− ∨ r can be read as: ‘If p then plausibly q or r, where q is more plausible than r’. This is especially interesting when measures of argument strength are considered and when thinking about defeat of rbc-arguments based on ordered disjunctions such as 〈〈q ←− ∨ r〉, [q ⇒ s], [r ⇒ s] s〉."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "We extend the ASPIC framework for structured argumentation so<lb>as to allow applications of the reasoning by cases inference scheme for<lb>defeasible arguments. Given an argument with conclusion ‘A or B’, an<lb>argument based on A with conclusion C, and an argument based on B<lb>with conclusion C, we allow the construction of an argument with con-<lb>clusion C. We show how our framework leads to different results than<lb>other approaches in non-monotonic logic for dealing with disjunctive in-<lb>formation, such as disjunctive default theory or approaches based on the<lb>OR-rule (which allows to derive a defeasible rule ‘If (A or B) then C’,<lb>given two defeasible rules ‘If A then C’ and ‘If B then C’). We raise new<lb>questions regarding the subtleties of reasoning defeasibly with disjunctive<lb>information, and show that its formalization is more intricate than one<lb>would presume.",
    "creator" : "LaTeX with hyperref package"
  }
}