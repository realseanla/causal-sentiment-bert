{
  "name" : "1702.07944.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Stochastic Variance Reduction Methods for Policy Evaluation",
    "authors" : [ "Simon S. Du", "Jianshu Chen", "Lihong Li", "Lin Xiao", "Dengyong Zhou" ],
    "emails" : [ "<ssdu@cs.cmu.edu>,", "shuc@microsoft.com>,", "<lihongli@microsoft.com>,", "<lin.xiao@microsoft.com>,", "zho@microsoft.com>." ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Reinforcement learning (RL) is a powerful learning paradigm for sequential decision making (see, e.g., Bertsekas & Tsitsiklis, 1995; Sutton & Barto, 1998). An RL agent interacts with the environment by repeatedly observing the current state, taking an action according to a certain policy, receiving a reward signal and transitioning to a next state. A policy specifies which action to take given the current state. Policy evaluation estimates a value function that predicts expected cumulative reward the agent would receive by following a fixed policy starting at a certain state. In addition to quantifying long-term values of states, which can be of interest on its own, value functions also provide\n1Machine Learning Department, Carnegie Mellon University, Pittsburgh, Pennsylvania 15213, USA. 2Microsoft Research, Redmond, Washington 98052, USA.. Correspondence to: Simon S. Du <ssdu@cs.cmu.edu>, Jianshu Chen <jianshuc@microsoft.com>, Lihong Li <lihongli@microsoft.com>, Lin Xiao <lin.xiao@microsoft.com>, Dengyong Zhou <denzho@microsoft.com>.\nProceedings of the 34 th International Conference on Machine Learning, Sydney, Australia, PMLR 70, 2017. Copyright 2017 by the author(s).\nimportant information for the agent to optimize its policy. For example, policy-iteration algorithms iterate between policy-evaluation steps and policy-improvement steps, until a (near-)optimal policy is found (Bertsekas & Tsitsiklis, 1995; Lagoudakis & Parr, 2003). Therefore, estimating the value function efficiently and accurately is essential in RL.\nThere has been substantial work on policy evaluation, with temporal-difference (TD) methods being perhaps the most popular. These methods use the Bellman equation to bootstrap the estimation process. Different cost functions are formulated to exploit this idea, leading to different policy evaluation algorithms; see Dann et al. (2014) for a comprehensive survey. In this paper, we study policy evaluation by minimizing the mean squared projected Bellman error (MSPBE) with linear approximation of the value function. We focus on the batch setting where a fixed, finite dataset is given. This fixed-data setting is not only important in itself (Lange et al., 2011), but also an important component in other RL methods such as experience replay (Lin, 1992).\nThe finite-data regime makes it possible to solve policy evaluation more efficiently with recently developed fast optimization methods based on stochastic variance reduction, such as SVRG (Johnson & Zhang, 2013) and SAGA (Defazio et al., 2014). For minimizing strongly convex functions with a finite-sum structure, such methods enjoy the same low computational cost per iteration as the classical stochastic gradient method, but also achieve fast, linear convergence rates (i.e., exponential decay of the optimality gap in the objective). However, they cannot be applied directly to minimize the MSPBE, whose objective does not have the finite-sum structure. In this paper, we overcome this obstacle by transforming the empirical MSPBE problem to an equivalent convex-concave saddle-point problem that possesses the desired finite-sum structure.\nIn the saddle-point problem, we consider the model parameters as the primal variables, which are coupled with the dual variables through a bilinear term. Moreover, without an `2-regularization on the model parameters, the objective is only strongly concave in the dual variables, but not in the primal variables. We propose a primal-dual batch gradient method, as well as two stochastic variance-reduction methods based on SVRG and SAGA, respectively. Surprisingly, we show that when the coupling matrix is full rank, these algorithms achieve linear convergence in both the primal\nar X\niv :1\n70 2.\n07 94\n4v 2\n[ cs\n.L G\n] 9\nJ un\n2 01\n7\nand dual spaces, despite the lack of strong convexity of the objective in the primal variables. Our results also extend to off-policy learning and TD with eligibility traces (Sutton & Barto, 1998; Precup et al., 2001).\nWe note that Balamurugan & Bach (2016) have extended both SVRG and SAGA to solve convex-concave saddlepoint problems with linear-convergence guarantees. The main difference between our results and theirs are\n• Linear convergence in Balamurugan & Bach (2016) relies on the assumption that the objective is strongly convex in the primal variables and strongly concave in the dual. Our results show, somewhat surprisingly, that only one of them is necessary if the primal-dual coupling is bilinear and the coupling matrix is full rank. In fact, we are not aware of similar previous results even for the primal-dual batch gradient method, which we show in this paper. • Even if a strongly convex regularization on the primal variables is introduced to the MSPBE objective, the algorithms in Balamurugan & Bach (2016) cannot be applied efficiently. Their algorithms require that the proximal mappings of the strongly convex and concave regularization functions be computed efficiently. In our saddle-point formulation, the strong concavity of the dual variables comes from a quadratic function defined by the feature covariance matrix, which cannot be inverted efficiently and makes the proximal mapping costly to compute. Instead, our algorithms only use its (stochastic) gradients and hence are much more efficient.\nWe compare various gradient based algorithms on a Random MDP and Mountain Car data sets. The experiments demonstrate the effectiveness of our proposed methods."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We consider a Markov Decision Process (MDP) (Puterman, 2005) described by (S,A,Pass′ ,R, γ), where S is the set of states, A the set of actions, Pass′ the transition probability from state s to state s′ after taking action a,R (s, a) the reward received after taking action a in state s, and γ ∈ [0, 1) a discount factor. The goal of an agent is to find an actionselection policy π, so that the long-term reward under this policy is maximized. For ease of exposition, we assume S is finite, but none of our results relies on this assumption.\nA key step in many algorithms in RL is to estimate the value function of a given policy π, defined as V π(s) , E[ ∑∞ t=0 γ\ntR(st, at)|s0 = s, π]. Let V π denote a vector constructed by stacking the values of V π(1), . . . , V π(|S|) on top of each other. Then V π is the unique fixed point of the Bellman operator Tπ:\nV π = TπV π , Rπ + γPπV π , (1)\nwhere Rπ is the expected reward vector under policy π, defined elementwise as Rπ(s) = Eπ(a|s)R(s, a); and Pπ is the transition matrix induced by the policy applying π, defined entrywise as Pπ(s, s′) = Eπ(a|s)Pass′ ."
    }, {
      "heading" : "2.1 Mean squared projected Bellman error (MSPBE)",
      "text" : "One approach to scale up when the state space size |S| is large or infinite is to use a linear approximation for V π . Formally, we use a feature map φ : S → Rd and approximate the value function by V̂ π (s) = φ(s)T θ, where θ ∈ Rd is the model parameter to be estimated. Here, we want to find θ that minimizes the mean squared projected Bellman error, or MSPBE:\nMSPBE (θ) , 1\n2 ‖V̂ π −ΠTπV̂ π‖2Ξ, (2)\nwhere Ξ is a diagonal matrix with diagonal elements being the stationary distribution over S induced by the policy π, and Π is the weighted projection matrix onto the linear space spanned by φ(1), . . . , φ(|S|), that is,\nΠ = Φ(ΦTΞΦ)−1ΦTΞ (3)\nwhere Φ , [φT (1), . . . , φT (|S|)] is the matrix obtained by stacking the feature vectors row by row. Substituting (3) and (1) into (2), we obtain (see, e.g., Dann et al., 2014)\nMSPBE(θ) = 1\n2 ‖ΦTΞ(V̂ π − TπV̂ π)‖2(ΦTΞΦ)−1 .\nWe can further rewrite the above expression for MSPBE as a standard weighted least-squares problem:\nMSPBE(θ) = 1\n2 ‖Aθ − b‖2C−1 ,\nwith properly defined A, b and C, described as follows. Suppose the MDP under policy π settles at its stationary distribution and generates an infinite transition sequence {(st, at, rt, st+1)}∞t=1, where st is the current state, at is the action, rt is the reward, and st+1 is the next state. Then with the definitions φt , φ(st) and φ′t , φ(st+1), we have\nA = E[φt(φt − γφ′t)T ], b = E[φtrt], C = E[φtφTt ], (4)\nwhere E[·] are with respect to the stationary distribution. Many TD solutions converge to a minimizer of MSPBE in the limit (Tsitsiklis & Van Roy, 1997; Dann et al., 2014)."
    }, {
      "heading" : "2.2 Empirical MSPBE",
      "text" : "In practice, quantities in (4) are often unknown, and we only have access to a finite dataset with n transitions D = {(st, at, rt, st+1)}nt=1. By replacing the unknown statistics with their finite-sample estimates, we obtain the Empirical MSPBE, or EM-MSPBE. Specifically, let\nÂ , 1\nn n∑ t=1 At, b̂ , 1 n n∑ t=1 bt, Ĉ , 1 n n∑ t=1 Ct, (5)\nwhere for t = 1, . . . , n,\nAt , φt(φt − γφ′t)T , bt , rtφt, Ct , φtφTt . (6)\nEM-MSPBE with an optional `2-regularization is given by:\nEM-MSPBE (θ) = 1\n2 ‖Âθ − b̂‖2 Ĉ−1 + ρ 2 ‖θ‖2, (7)\nwhere ρ ≥ 0 is a regularization factor. Observe that (7) is a (regularized) weighted least squares problem. Assuming Ĉ is invertible, its optimal solution is\nθ? = (Â>Ĉ−1Â+ ρI)−1Â>Ĉ−1b̂. (8)\nComputing θ? directly requires O(nd2) operations to form the matrices Â, b̂ and Ĉ, and then O(d3) operations to complete the calculation. This method, known as leastsquares temporal difference or LSTD (Bradtke & Barto, 1996; Boyan, 2002), can be very expensive when n and d are large. One can also skip forming the matrices explicitly and compute θ? using n recusive rank-one updates (Nedić & Bertsekas, 2003). Since each rank-one update costs O(d2), the total cost is O(nd2).\nIn the sequel, we develop efficient algorithms to minimize EM-MSPBE by using stochastic variance reduction methods, which samples one (φt, φ′t) per update without precomputing Â, b̂ and Ĉ. These algorithms not only maintain a low O(d) per-iteration computation cost, but also attain fast linear convergence rates with a log(1/ ) dependence on the desired accuracy ."
    }, {
      "heading" : "3 Saddle-Point Formulation of EM-MSPBE",
      "text" : "Our algorithms (in Section 5) are based on the stochastic variance reduction techniques developed for minimizing a finite sum of convex functions, more specifically, SVRG (Johnson & Zhang, 2013) and SAGA (Defazio et al., 2014). They deal with problems of the form\nmin x∈Rd\n{ f(x) , 1\nn n∑ i=1 fi(x) } , (9)\nwhere each fi is convex. We immediately notice that the EM-MSPBE in (7) cannot be put into such a form, even though the matrices Â, b̂ and Ĉ have the finite-sum structure given in (5). Thus, extending variance reduction techniques to EM-MSPBE minimization is not straightforward.\nNevertheless, we will show that the minimizing the EMMSPBE is equivalent to solving a convex-concave saddlepoint problem which actually possesses the desired finitesum structure. To proceed, we resort to the machinery of conjugate functions (e.g. Rockafellar, 1970, Section 12). For a function f : Rd → R, its conjugate function f? :\nRd → R is defined as f?(y) , supx(yTx − f(x)). Note that the conjugate function of 12‖x‖ 2 Ĉ is 12‖y‖ 2 Ĉ−1 , i.e.,\n1 2 ‖y‖2 Ĉ−1 = max x\n( yTx− 1\n2 ‖x‖2 Ĉ\n) .\nWith this relation, we can rewrite EM-MSPBE in (7) as\nmax w\n( wT (̂b− Âθ)− 1\n2 ‖w‖2 Ĉ\n) + ρ\n2 ‖θ‖2 ,\nso that minimizing EM-MSPBE is equivalent to solving\nmin θ∈Rd max w∈Rd\n{ L(θ, w) = 1\nn n∑ t=1 Lt(θ, w) } , (10)\nwhere the Lagrangian, defined as\nL(θ, w) , ρ 2 ‖θ‖2 − wT Âθ − (1 2 ‖w‖2 Ĉ − wT b̂ ) , (11)\nmay be decomposed using (5), with\nLt(θ, w) , ρ\n2 ‖θ‖2 − wTAtθ − (1 2 ‖w‖2Ct − w T bt ) .\nTherefore, minimizing the EM-MSPBE is equivalent to solving the saddle-point problem (10), which is convex in the primal variable θ and concave in the dual variable w. Moreover, it has a finite-sum structure similar to (9).\nLiu et al. (2015) and Valcarcel Macua et al. (2015) independently showed that the GTD2 algorithm (Sutton et al., 2009b) is indeed a stochastic gradient method for solving the saddle-point problem (10), although they obtained the saddle-point formulation with different derivations. More recently, Dai et al. (2016) used the conjugate function approach to obtain saddle-point formulations for a more general class of problems and derived primal-dual stochastic gradient algorithms for solving them. However, these algorithms have sublinear convergence rates, which leaves much room to improve when applied to problems with finite datasets. Recently, Lian et al. (2017) developed SVRG methods for a general finite-sum composition optimization that achieve linear convergence rate. Different from our methods, their stochastic gradients are biased and they have worse dependency on the condition numbers (κ3 and κ4).\nThe fast linear convergence of our algorithms presented in Sections 4 and 5 requires the following assumption:\nAssumption 1. Â has full rank, Ĉ is strictly positive definite, and the feature vector φt is uniformly bounded.\nUnder mild regularity conditions (e.g., Wasserman, 2013, Chapter 5), we have Â and Ĉ converge in probability to A andC defined in (4), respectively. Thus, if the true statistics A is non-singular and C is positive definite, and we have enough training samples, these assumptions are usually satisfied. They have been widely used in previous works on gradient-based algorithms (e.g., Sutton et al., 2009a;b).\nA direct consequence of Assumption 1 is that θ? in (8) is the unique minimizer of the EM-MSPBE in (7), even without any strongly convex regularization on θ (i.e., even if ρ = 0). However, if ρ = 0, then the Lagrangian L(θ, w) is only strongly concave inw, but not strongly convex in θ. In this case, we will show that non-singularity of the coupling matrix Â can “pass” an implicit strong convexity on θ, which is exploited by our algorithms to obtain linear convergence in both the primal and dual spaces."
    }, {
      "heading" : "4 A Primal-Dual Batch Gradient Method",
      "text" : "Before diving into the stochastic variance reduction algorithms, we first present Algorithm 1, which is a primal-dual batch gradient (PDBG) algorithm for solving the saddlepoint problem (10). In Step 2, the vector B(θ, w) is obtained by stacking the primal and negative dual gradients:\nB (θ, w) , [ ∇θL(θ, w) −∇wL(θ, w) ] = [ ρθ − ÂTw Âθ − b̂+ Ĉw ] . (12)\nSome notation is needed in order to characterize the convergence rate of Algorithm 1. For any symmetric and positive definite matrix S, let λmax(S) and λmin(S) denote its maximum and minimum eigenvalues respectively, and define its condition number to be κ(S) , λmax(S)/λmin(S). We also define Lρ and µρ for any ρ ≥ 0:\nLρ , λmax(ρI + Â T Ĉ−1Â), (13)\nµρ , λmin(ρI + Â T Ĉ−1Â). (14)\nBy Assumption 1, we have Lρ ≥ µρ > 0. The following theorem is proved in Appendix B.\nTheorem 1. Suppose Assumption 1 holds and let (θ?, w?) be the (unique) solution of (10). If the step sizes are chosen as σθ = 19Lρκ(Ĉ) and σw = 8 9λmax(Ĉ) , then the number of iterations of Algorithm 1 to achieve ‖θ − θ?‖2 + ‖w − w?‖2 ≤ 2 is upper bounded by\nO ( κ ( ρI + ÂT Ĉ−1Â ) · κ(Ĉ) · log (1 )) . (15)\nWe assigned specific values to the step sizes σθ and σw for clarity. In general, we can use similar step sizes while keeping their ratio roughly constant as σwσθ ≈ 8Lρ λmin(Ĉ) ; see Appendices A and B for more details. In practice, one can use a parameter search on a small subset of data to find reasonable step sizes. It is an interesting open problem how to automatically select and adjust step sizes.\nNote that the linear rate is determined by two parts: (i) the strongly convex regularization parameter ρ, and (ii) the positive definiteness of ÂT Ĉ−1Â. The second part could be interpreted as transferring strong concavity in dual variables via the full-rank bi-linear coupling matrix Â. For\nAlgorithm 1 PDBG for Policy Evaluation Inputs: initial point (θ, w), step sizes σθ and σw, and\nnumber of epochs M . 1: for i = 1 to M do\n2: [ θ w ] ← [ θ w ] − [ σθ 0 0 σw ] B(θ, w)\nwhere B(θ, w) is computed according to (12). 3: end for\nthis reason, even if the saddle-point problem (10) has only strong concavity in dual variables (when ρ = 0), the algorithm still enjoys a linear convergence rate.\nMoreover, even if ρ > 0, it will be inefficient to solve problem (10) using primal-dual algorithms based on proximal mappings of the strongly convex and concave terms (e.g., Chambolle & Pock, 2011; Balamurugan & Bach, 2016). The reason is that, in (10), the strong concavity of the Lagrangian with respect to the dual lies in the quadratic function (1/2)‖w‖Ĉ , whose proximal mapping cannot be computed efficiently. In contrast, the PDBG algorithm only needs its gradients.\nIf we pre-compute and store Â, b̂ and Ĉ, which costs O(nd2) operations, then computing the gradient operator B(θ, w) in (12) during each iteration of PDBG costsO(d2) operations. Alternatively, if we do not want to store these d × d matrices (especially if d is large), then we can compute B(θ, w) as finite sums on the fly. More specifically, B(θ, w) = 1n ∑n t=1Bt(θ, w), where for each t = 1, . . . , n,\nBt(θ, w) =\n[ ρθ −Atw\nAtθ − bt + Ctw\n] . (16)\nSince At, bt and Ct are all rank-one matrices, as given in (6), computing each Bt(θ, w) only requires O(d) operations. Therefore, computing B(θ, w) costs O(nd) operations as it averages Bt(θ, w) over n samples."
    }, {
      "heading" : "5 Stochastic Variance Reduction Methods",
      "text" : "If we replace B(θ, w) in Algorithm 1 (line 2) by the stochastic gradient Bt(θ, w) in (16), then we recover the GTD2 algorithm of Sutton et al. (2009b), applied to a fixed dataset, possibly with multiple passes. It has a low periteration cost but a slow, sublinear convergence rate. In this section, we provide two stochastic variance reduction methods and show they achieve fast linear convergence."
    }, {
      "heading" : "5.1 SVRG for policy evaluation",
      "text" : "Algorithm 2 is adapted from the stochastic variance reduction gradient (SVRG) method (Johnson & Zhang, 2013). It uses two layers of loops and maintains two sets of parameters (θ̃, w̃) and (θ, w). In the outer loop, the algorithm computes a full gradient B(θ̃, w̃) using (θ̃, w̃), which takes\nAlgorithm 2 SVRG for Policy Evaluation Inputs: initial point (θ, w), step sizes {σθ, σw}, number of\nouter iterations M , and number of inner iterations N . 1: for m = 1 to M do 2: Initialize (θ̃, w̃) = (θ, w) and compute B(θ̃, w̃). 3: for j = 1 to N do 4: Sample an index tj from {1, · · · , n} and do 5: Compute Btj (θ, w) and Btj (θ̃, w̃).\n6:\n[ θ w ] ← [ θ w ] − [ σθ 0 0 σw ] Btj (θ, w, θ̃, w̃)\nwhere Btj (θ, w, θ̃, w̃) is given in (17). 7: end for 8: end for\nAlgorithm 3 SAGA for Policy Evaluation Inputs: initial point (θ, w), step sizes σθ and σw, and\nnumber of iterations M . 1: Compute each gt = Bt(θ, w) for t = 1, . . . , n. 2: Compute B = B(θ, w) = 1n ∑n t=1 gt. 3: for m = 1 to M do 4: Sample an index tm from {1, · · · , n}. 5: Compute htm = Btm(θ, w).\n6: [ θ w ] ← [ θ w ] − [ σθ 0 0 σw ] (B + htm − gtm). 7: B ← B + 1n (htm − gtm) 8: gtm ← htm . 9: end for\nO(nd) operations. Afterwards, the algorithm executes the inner loop, which randomly samples an index tj and updates (θ, w) using variance-reduced stochastic gradient:\nBtj(θ, w, θ̃, w̃) = Btj(θ, w) +B(θ̃, w̃)−Btj(θ̃, w̃). (17)\nHere, Btj (θ, w) contains the stochastic gradients at (θ, w) computed using the random sample with index tj , and B(θ̃, w̃) − Btj (θ̃, w̃) is a term used to reduce the variance in Btj (θ, w) while keeping Btj(θ, w, θ̃, w̃) an unbiased estimate of B(θ, w).\nSince B(θ̃, w̃) is computed once during each iteration of the outer loop with cost O(nd) (as explained at the end of Section 4), and each of the N iterations of the inner loop cost O(d) operations, the total computational cost of for each outer loop isO(nd+Nd). We will present the overall complexity analysis of Algorithm 2 in Section 5.3."
    }, {
      "heading" : "5.2 SAGA for policy evaluation",
      "text" : "The second stochastic variance reduction method for policy evaluation is adapted from SAGA (Defazio et al., 2014); see Algorithm 3. It uses a single loop, and maintains a single set of parameters (θ, w). Algorithm 3 starts by first\ncomputing each component gradients gt = Bt(θ, w) at the initial point, and also form their average B = ∑n t gt. At each iteration, the algorithm randomly picks an index tm ∈ {1, . . . , n} and computes the stochastic gradient htm = Btm(θ, w). Then, it updates (θ, w) using a variance reduced stochastic gradient: B + htm − gtm , where gtm is the previously computed stochastic gradient using the tm-th sample (associated with certain past values of θ and w). Afterwards, it updates the batch gradient estimate B as B + 1n (htm − gtm) and replaces gtm with htm . As Algorithm 3 proceeds, different vectors gt are computed using different values of θ and w (depending on when the index t was sampled). So in general we need to store all vectors gt, for t = 1, . . . , n, to facilitate individual updates, which will cost additional O(nd) storage. However, by exploiting the rank-one structure in (6), we only need to store three scalars (φt − γ′φ)T θ, (φt − γ′φ)Tw, and φTt w, and form gtm on the fly using O(d) computation. Overall, each iteration of SAGA costs O(d) operations."
    }, {
      "heading" : "5.3 Theoretical analyses of SVRG and SAGA",
      "text" : "In order to study the convergence properties of SVRG and SAGA for policy evaluation, we introduce a smoothness parameter LG based on the stochastic gradients Bt(θ, w). Let β = σw/σθ be the ratio between the primal and dual step-sizes, and define a pair of weighted Euclidean norms\nΩ(θ, w) , (‖θ‖2 + β−1‖w‖2)1/2, Ω∗(θ, w) , (‖θ‖2 + β‖w‖2)1/2.\nNote that Ω(·, ·) upper bounds the error in optimizing θ: Ω(θ − θ?, w − w?) ≥ ‖θ − θ?‖. Therefore, any bound on Ω(θ − θ?, w − w?) applies automatically to ‖θ − θ?‖. Next, we define the parameter LG through its square:\nL2G , sup θ1,w1,θ2,w2\n1 n ∑n t=1 Ω ∗(Bt(θ1, w1)−Bt(θ2, w2))2 Ω(θ1 − θ2, w1 − w2)2 .\nThis definition is similar to the smoothness constant L̄ used in Balamurugan & Bach (2016) except that we used the step-size ratio β rather than the strong convexity and concavity parameters of the Lagrangian to define Ω and Ω∗.1 Substituting the definition of Bt(θ, w) in (16), we have\nL2G = ∥∥∥∥ 1n n∑ t=1 GTt Gt ∥∥∥∥, where Gt , [ ρI −√βATt√βAt βCt ] .\n(18)\nWith the above definitions, we characterize the convergence of Ω(θm − θ?, wm − w?), where (θ?, w?) is the solution of (10), and (θm, wm) is the output of the algorithms\n1Since our saddle-point problem is not necessarily strongly convex in θ (when ρ = 0), we could not define Ω and Ω∗ in the same way as Balamurugan & Bach (2016).\nafter the m-th iteration. For SVRG, it is the m-th outer iteration in Algorithm 2. The following two theorems are proved in Appendices C and D, respectively. Theorem 2 (Convergence rate of SVRG). Suppose Assumption 1 holds. If we choose σθ = µρ\n48κ(Ĉ)L2G , σw =\n8Lρ\nλmin(Ĉ) σθ, N = 51κ2(Ĉ)L2G µ2ρ\n, where Lρ and µρ are defined in (13) and (14), then E [ Ω(θm−θ?, wm−w?)2 ] ≤ (4\n5\n)m Ω(θ0−θ?, w0−w?)2.\nThe overall computational cost for reaching E [ Ω(θm −\nθ?, wm − w?) ] ≤ is upper bounded by\nO (( n+\nκ(Ĉ)L2G\nλ2min(ρI + Â T Ĉ−1Â)\n) d log (1 )) . (19)\nTheorem 3 (Convergence rate of SAGA). Suppose Assumption 1 holds. If we choose σθ = µρ\n3(8κ2(Ĉ)L2G+nµ2ρ)\nand σw = 8Lρ\nλmin(Ĉ) σθ in Algorithm 3, then\nE [ Ω(θm−θ?, wm−w?)2 ] ≤ 2(1−ρ)mΩ(θ0−θ?, w0−w?)2,\nwhere ρ ≥ µ 2 ρ\n9(8κ2(Ĉ)L2G+nµ2ρ) . The total cost to achieve E [ Ω(θm− θ?, wm−w?) ] ≤ has the same bound in (19).\nSimilar to our PDBG results in (15), both the SVRG and SAGA algorithms for policy evaluation enjoy linear convergence even if there is no strong convexity in the saddlepoint problem (10) (i.e., when ρ = 0). This is mainly due to the positive definiteness of ÂT Ĉ−1Â when Ĉ is positivedefinite and Â is full-rank. In contrast, the linear convergence of SVRG and SAGA in Balamurugan & Bach (2016) requires the Lagrangian to be both strongly convex in θ and strongly concave in w.\nMoreover, in the policy evaluation problem, the strong concavity with respect to the dual variable w comes from a weighted quadratic norm (1/2)‖w‖Ĉ , which does not admit an efficient proximal mapping as required by the proximal versions of SVRG and SAGA in Balamurugan & Bach (2016). Our algorithms only require computing the stochastic gradients of this function, which is easy to do due to its finite sum structure.\nBalamurugan & Bach (2016) also proposed accelerated variants of SVRG and SAGA using the “catalyst” framework of Lin et al. (2015). Such extensions can be done similarly for the three algorithms presented in this paper, and we omit the details due to space limit."
    }, {
      "heading" : "6 Comparison of Different Algorithms",
      "text" : "This section compares the computation complexities of several representative policy-evaluation algorithms that minimize EM-MSPBE, as summarized in Table 1.\nThe upper part of the table lists algorithms whose complexity is linear in feature dimension d, including the two new algorithms presented in the previous section. We can also apply GTD2 to a finite dataset with samples drawn uniformly at random with replacement. It costs O(d) per iteration, but has a sublinear convergence rate regarding . In practice, people may choose = Ω(1/n) for generalization reasons (see, e.g., Lazaric et al. (2010)), leading to an O(κ′nd) overall complexity for GTD2, where κ′ is a condition number related to the algorithm. However, as verified by our experiments, the bounds in the table show that our SVRG/SAGA-based algorithms are much faster as their effective condition numbers vanish when n becomes large. TDC has a similar complexity to GTD2.\nIn the table, we list two different implementations of PDBG. PDBG-(I) computes the gradients by averaging the stochastic gradients over the entire dataset at each iteration, which costsO(nd) operations; see discussions at the end of Section 4. PDBG-(II) first pre-computes the matrices Â, b̂ and Ĉ using O(nd2) operations, then computes the batch gradient at each iteration with O(d2) operations. If d is very large (e.g., when d n), then PDBG-(I) would have an advantage over PDBG-(II). The lower part of the table also includes LSTD, which hasO(nd2) complexity if rankone updates are used.\nSVRG and SAGA are more efficient than the other algorithms, when either d or n is very large. In particular, they have a lower complexity than LSTD when d > (1 + κ(Ĉ)κ2G n ) log ( 1 ) , This condition is easy to satisfy, when n is very large. On the other hand, SVRG and SAGA algorithms are more efficient than PDBG-(I) if n is large, say n > κ(Ĉ)κ2G /( κ(Ĉ)κ − 1 ) , where κ and κG are described in the caption of Table 1.\nThere are other algorithms whose complexity scales linearly with n and d, including iLSTD (Geramifard et al., 2007), and TDC (Sutton et al., 2009b), fLSTDSA (Prashanth et al., 2014), and the more recent algorithms of Wang et al. (2016) and Dai et al. (2016). However, their\nconvergence is slow: the number of iterations required to reach a desired accuracy grows as 1/ or worse. The CTD algorithm (Korda & Prashanth, 2015) uses a similar idea as SVRG to reduce variance in TD updates. This algorithm is shown to have a similar linear convergence rate in an online setting where the data stream is generated by a Markov process with finite states and exponential mixing. The method solves for a fixed-point solution by stochastic approximation. As a result, they can be non-convergent in off-policy learning, while our algorithms remain stable (c.f., Section 7.1)."
    }, {
      "heading" : "7 Extensions",
      "text" : "It is possible to extend our approach to accelerate optimization of other objectives such as MSBE and NEU (Dann et al., 2014). In this section, we briefly describe two extensions of the algorithms developed earlier."
    }, {
      "heading" : "7.1 Off-policy learning",
      "text" : "In some cases, we may want to estimate the value function of a policy π from a set of data D generated by a different “behavior” policy πb. This is called off-policy learning (Sutton & Barto, 1998, Chapter 8).\nIn the off-policy case, samples are generated from the distribution induced by the behavior policy πb, not the the target policy π. While such a mismatch often causes stochastic-approximation-based methods to diverge (Tsitsiklis & Van Roy, 1997), our gradient-based algorithms remain convergent with the same (fast) convergence rate.\nConsider the RL framework outlined in Section 2. For each state-action pair (st, at) such that πb(at|st) > 0, we define the importance ratio, ρt , π(at|st)/πb(at|st). The EMMSPBE for off-policy learning has the same expression as in (7) except that At, bt and Ct are modified by the weight factor ρt, as listed in Table 2; see also Liu et al. (2015, Eqn 6) for a related discussion.) Algorithms 1–3 remain the same for the off-policy case afterAt, bt andCt are modified correspondingly."
    }, {
      "heading" : "7.2 Learning with eligibility traces",
      "text" : "Eligibility traces are a useful technique to trade off bias and variance in TD learning (Singh & Sutton, 1996; Kearns & Singh, 2000). When they are used, we can pre-compute zt in Table 2 before running our new algorithms. Note that EM-MSPBE with eligibility traces has the same form of (7), with At, bt and Ct defined differently according to the last row of Table 2. At the m-th step of the learning process, the algorithm randomly samples ztm , φtm , φ ′ tm and rtm from the fixed dataset and computes the corresponding stochastic gradients, where the index tm is uniformly distributed over {1, . . . , n} and are independent for different values of m. Algorithms 1–3 immediately work for this case, enjoying a similar linear convergence rate and a com-\nputation complexity linear in n and d. We need additional O(nd) operations to pre-compute zt recursively and an additional O(nd) storage for zt. However, it does not change the order of the total complexity for SVRG/SAGA."
    }, {
      "heading" : "8 Experiments",
      "text" : "In this section, we compare the following algorithms on two benchmark problems: (i) PDBG (Algorithm 1); (ii) GTD2 with samples drawn randomly with replacement from a dataset; (iii) TD: the fLSTD-SA algorithm of Prashanth et al. (2014); (iv) SVRG (Algorithm 2); and (v) SAGA (Algorithm 3). Note that when ρ > 0, the TD solution and EM-MSPBE minimizer differ, so we do not include TD. For step size tuning, σθ is chosen from{\n10−1, 10−2, . . . , 10−6 } 1\nLρκ(Ĉ) and σw is chosen from{ 1, 10−1, 10−2 } 1\nλmax(Ĉ) . We only report the results of\neach algorithm which correspond to the best-tuned step sizes; for SVRG we choose N = 2n.\nIn the first task, we consider a randomly generated MDP with 400 states and 10 actions (Dann et al., 2014). The transition probabilities are defined as P (s′|a, s) ∝ pass′+10−5, where pass′ ∼ U [0, 1]. The data-generating policy and start distribution were generated in a similar way. Each state is represented by a 201-dimensional feature vector, where 200 of the features were sampled from a uniform distribution, and the last feature was constant one. We chose γ = 0.95. Fig. 1 shows the performance of various algorithms for n = 20000. First, notice that the stochastic variance methods converge much faster than others. In fact, our proposed methods achieve linear convergence. Second, as we increase ρ, the performances of PDBG, SVRG and SAGA improve significantly due to better conditioning, as predicted by our theoretical results.\nNext, we test these algorithms on Mountain Car (Sutton & Barto, 1998, Chapter 8). To collect the dataset, we first ran Sarsa with d = 300 CMAC features to obtain a good policy. Then, we ran this policy to collect trajectories that comprise the dataset. Figs. 2 and 3 show our proposed stochastic variance reduction methods dominate other first-order methods. Moreover, with better conditioning (through a larger ρ), PDBG, SVRG and SAGA achieve faster convergence rate. Finally, as we increase sample size n, SVRG and SAGA converge faster. This simulation verifies our\ntheoretical finding in Table 1 that SVRG/SAGA need fewer epochs for large n."
    }, {
      "heading" : "9 Conclusions",
      "text" : "In this paper, we reformulated the EM-MSPBE minimization problem in policy evaluation into an empirical saddlepoint problem, and developed and analyzed a batch gradient method and two first-order stochastic variance reduction methods to solve the problem. An important result we obtained is that even when the reformulated saddle-point problem lacks strong convexity in primal variables and has only strong concavity in dual variables, the proposed algorithms are still able to achieve a linear convergence rate. We are not aware of any similar results for primal-dual\nbatch gradient methods or stochastic variance reduction methods. Furthermore, we showed that when both the feature dimension d and the number of samples n are large, the developed stochastic variance reduction methods are more efficient than any other gradient-based methods which are convergent in off-policy settings.\nThis work leads to several interesting directions for research. First, we believe it is important to extend the stochastic variance reduction methods to nonlinear approximation paradigms (Bhatnagar et al., 2009), especially with deep neural networks. Moreover, it remains an important open problem how to apply stochastic variance reduction techniques to policy optimization."
    }, {
      "heading" : "A Eigen-analysis of G",
      "text" : "In this section, we give a thorough analysis of the spectral properties of the matrix\nG =\n[ ρI −β1/2ÂT\nβ1/2Â βĈ\n] , (20)\nwhich is critical in analyzing the convergence of the PDBG, SAGA and SVRG algorithms for policy evaluation. Here β = σw/σθ is the ratio between the dual and primal step sizes in these algorithms. For convenience, we use the following notation:\nL , λmax(Â T Ĉ−1Â),\nµ , λmin(Â T Ĉ−1Â).\nUnder Assumption 1, they are well defined and we have L ≥ µ > 0.\nA.1 Diagonalizability of G\nFirst, we examine the condition of β that ensures the diagonalizability of the matrix G. We cite the following result from (Shen et al., 2008).\nLemma 1. Consider the matrix A defined as A = [ A −B> B C ] , (21)\nwhereA 0, C 0, andB is full rank. Let τ = λmin(C), δ = λmax(A) and σ = λmax(B>C−1B). If τ > δ+2 √ τσ holds, thenA is diagonalizable with all its eigenvalues real and positive.\nApplying this lemma to the matrix G in (20), we have\nτ = λmin(βĈ) = βλmin(Ĉ),\nδ = λmax(ρI) = ρ, σ = λmax ( β1/2Â>(βĈ)−1β1/2Â ) = λmax(Â >Ĉ−1Â).\nThe condition τ > δ + 2 √ τσ translates into\nβλmin(Ĉ) > ρ+ 2 √ βλmin(Ĉ)λmax(Â>Ĉ−1Â),\nwhich can be solved as\n√ β >\n√ λmax(Â>Ĉ−1Â)+ √ ρ+λmax(Â>Ĉ−1Â)√\nλmin(Ĉ) .\nIn the rest of our discussion, we choose β to be β = 8 ( ρ+ λmax ( Â>Ĉ−1Â )) λmin(Ĉ) = 8(ρ+ L) λmin(Ĉ) , (22)\nwhich satisfies the inequality above.\nA.2 Analysis of eigenvectors\nIf the matrix G is diagonalizable, then it can be written as\nG = QΛQ−1,\nwhere Λ is a diagonal matrix whose diagonal entries are the eigenvalues of G, and Q consists of it eigenvectors (each with unit norm) as columns. Our goal here is to bound κ(Q), the condition number of the matrix Q. Our analysis is inspired by Liesen & Parlett (2008). The core is the following fundamental result from linear algebra. Theorem 4 (Theorem 5.1.1 of Gohberg et al. (2006)). Suppose G is diagonalizable. If H is a symmetric positive definite matrix and HG is symmetric, then there exist a complete set of eigenvectors of G, such that they are orthonormal with respect to the inner product induced by H:\nQ>HQ = I. (23)\nIf H satisfies the conditions in Theorem 4, then we have H = Q−>Q−1, which implies κ(H) = κ2(Q). Therefore, in order to bound κ(Q), we only need to find such an H and analyze its conditioning. To this end, we consider the matrix of the following form:\nH =\n[ (δ − ρ)I\n√ βÂ>√\nβÂ βĈ − δI\n] . (24)\nIt is straightforward to check that HG is a symmetric matrix. The following lemma states the conditions for H being positive definite. Lemma 2. If δ − ρ > 0 and βĈ − δI − βδ−ρ ÂÂ\n> 0, then H is positive definite.\nProof. The matrix H in (24) admits the following Schur decomposition:\nH = [ I 0√ β\nδ−ρ Â I\n] [ (δ − ρ)I\nS\n] [ I √ β\nδ−ρ Â >\n0 I\n] ,\nwhere S = βĈ− δI− βδ−ρ ÂÂ >. Thus H is congruence to the block diagonal matrix in the middle, which is positive definite under the specified conditions. Therefore, the matrix H is positive definite under the same conditions.\nIn addition to the choice of β in (22), we choose δ to be\nδ = 4(ρ+ L). (25)\nIt is not hard to verify that this choice ensures δ−ρ > 0 and βĈ− δI− βδ−ρ ÂÂ\n> 0 so that H is positive definite. We now derive an upper bound on the condition number of H . Let λ be an eigenvalue of H and [xT yT ]T be its associated eigenvector, where ‖x‖2 + ‖y‖2 > 0. Then it holds that\n(δ − ρ)x+ √ βÂT y = λx, (26)\nStochastic Variance Reduction Methods for Policy Evaluation√ βÂx+ (βĈ − δI)y = λy. (27)\nFrom (26), we have\nx =\n√ β\nλ− δ + ρ ÂT y. (28)\nNote that λ− δ + ρ 6= 0 because if λ− δ + ρ = 0 we have ÂT y = 0 so that y = 0 since Â is full rank. With y = 0 in (27), we will have Âx = 0 so that x = 0, which contradicts the assumption that ‖x‖2 + ‖y‖2 > 0. Substituting (28) into (27) and multiplying both sides with yT , we obtain the following equation after some algebra\nλ2 − pλ+ q = 0, (29)\nwhere\np , δ − ρ+ y T (βĈ − δI)y ‖y‖2 ,\nq , (δ − ρ)y T (βĈ − δI)y ‖y‖2 − β y T ÂÂT y ‖y‖2 .\nWe can verify that both p and q are positive with our choice of δ and β. The roots of the quadratic equation in (29) are given by\nλ = p± √ p2 − 4q 2 . (30)\nTherefore, we can upper bound the largest eigenvalue as\nλmax(H) ≤ p+ √ p2 − 4q 2\n≤ p = δ − ρ− δ + β y T Ĉy\n‖y‖2\n≤ −ρ+ βλmax(Ĉ)\n= −ρ+ 8(ρ+ L) λmin(Ĉ) λmax(Ĉ)\n≤ 8(ρ+ L)κ(Ĉ). (31)\nLikewise, we can lower bound the smallest eigenvalue:\nλmin(H) ≥ p− √ p2 − 4q 2 ≥ p− p+ 2q/p 2 = q p\n= β ( (δ − ρ)y T Ĉy ‖y‖2 − yT ÂÂT y ‖y‖2 ) − δ(δ − ρ)\n−ρ+ β yT Ĉy‖y‖2\n(a) ≥ β ( (δ − ρ)y T Ĉy ‖y‖2 − yT ÂÂT y ‖y‖2 ) − δ(δ − ρ)\nβ y T Ĉy ‖y‖2\n= δ − ρ− y T ÂÂT y yT Ĉy − δ(δ − ρ) β · 1 yT Ĉy ‖y‖2\n(b) ≥ δ − ρ− L− δ(δ − ρ) βλmin(Ĉ)\n(c) = (ρ+ L) ( 3− 3ρ+ 4L\n2(ρ+ L) ) ≥ ρ+ L, (32)\nwhere step (a) uses the fact that both the numerator and denominator are positive, step (b) uses the fact\nL , λmax ( ÂT Ĉ−1Â ) ≥ y T ÂÂT y\nyT Ĉy ,\nand step (c) substitutes the expressions of δ and β. Therefore, we can upper bound the condition number of H , and thus that of Q, as follows:\nκ2(Q) = κ(H) ≤ 8(ρ+ L)κ(Ĉ) ρ+ L = 8κ(Ĉ). (33)\nA.3 Analysis of eigenvalues Suppose λ is an eigenvalue of G and let ( ξ>, η> )> be its corresponding eigenvector. By definition, we have\nG [ ξ η ] = λ [ ξ η ] ,\nwhich is equivalent to the following two equations: ρξ − √ βÂ>η = λξ,√\nβÂξ + βĈη = λη.\nSolve ξ in the first equation in terms of η, then plug into the second equation, we obtain:\nλ2η − λ(ρη + βĈη) + β(ÂÂ>η + ρĈη) = 0.\nNow left multiply η>, then divide by the ‖η‖22, we have:\nλ2 − pλ+ q = 0.\nwhere p and q are defined as\np , ρ+ β η>Ĉη\n‖η‖2 ,\nq , β\n( ηT ÂÂ>η\n‖η‖2 + ρ\nηT Ĉη\n‖η‖2\n) . (34)\nTherefore the eigenvalues of G satisfy:\nλ = p± √ p2 − 4q 2 . (35)\nRecall that our choice of β ensures that G is diagonalizable and has positive real eigenvalues. Indeed, we can verify that the diagonalization condition guarantees p2 ≥ 4q\nso that all eigenvalues are real and positive. Now we can obtain upper and lower bounds based on (35). For upper bound, notice that\nλmax(G) ≤ p ≤ ρ+ βλmax(Ĉ)\n= ρ+ 8(ρ+ L)\nλmin(Ĉ λmax(Ĉ)\n= ρ+ 8(ρ+ L)κ(Ĉ) ≤ 9κ(Ĉ) ( ρ+ L ) = 9κ(Ĉ)λmax ( ρI + ÂT Ĉ−1Â ) . (36)\nFor lower bound, notice that\nλmin(G) ≥ p− √ p2 − 4q 2 ≥ p− p+ 2q/p 2 = q/p\n= β ( ηT ÂÂT η ηT Ĉη + ρ )\nρ ‖η‖ 2\nηT Ĉη + β\n(a) ≥ β(ρ+ µ) ρ/λmin(Ĉ) + β = βλmin(Ĉ)(ρ+ µ) ρ+ βλmin(Ĉ)\n(b) =\n8(ρ+ L)(ρ+ µ)\nρ+ 8(ρ+ L)\n≥ 8 9 (ρ+ µ) = 8\n9 (ρ+ λmin(Â\nT Ĉ−1Â))\n= 8\n9 λmin(ρI + Â\nT Ĉ−1Â), (37)\nwhere the second inequality is by the concavity property of the square root function, step (a) used the fact\nµ , λmin ( ÂT Ĉ−1Â ) ≤ y T ÂÂT y\nyT Ĉy ,\nand step (b) substitutes the expressions of β.\nSince G is not a normal matrix, we cannot use their eigenvalue bounds to bound its condition number κ(G)."
    }, {
      "heading" : "B Linear convergence of PDBG",
      "text" : "Recall the saddle-point problem we need to solve:\nmin θ max w L(θ, w),\nwhere the Lagrangian is defined as\nL(θ, w) = ρ 2 ‖θ‖2 − w>Âθ − 1 2 w>Ĉw + b̂>w. (38)\nOur assumption is that Ĉ is positive definite and Â has full rank. The optimal solution can be expressed as\nθ? = ( Â>Ĉ−1Â+ ρI )−1 Â>Ĉ−1b̂,\nw? = Ĉ −1 ( b̂− Â>θ? ) .\nThe gradients of the Lagrangian with respect to θ and w, respectively, are\n∇θL (θ, w) = ρθ − Â>w\n∇wL (θ, w) = −Âθ − Ĉw + b̂.\nThe first-order optimality condition is obtained by setting them to zero, which is satisfied by (θ?, w?):[\nρI −Â> Â Ĉ ] [ θ? w? ] = [ 0 b̂ ] . (39)\nThe PDBG method in Algorithm 1 takes the following iteration: [\nθm+1 wm+1\n] = [ θm wm ] − [ σθ 0 0 σw ] B(θm, wm),\nwhere\nB(θ, w) = [ ∇θL(θ, w) −∇wL(θ, w) ] = [ ρI −Â> Â Ĉ ] [ θ w ] − [ 0 b̂ ] .\nLetting β = σw/σθ, we have[ θm+1 wm+1 ] = [ θm wm ] − σθ ([ ρI −Â> βÂ βĈ ] [ θm wm ] − [ 0 βb̂ ]) .\nSubtracting both sides of the above recursion by (θ?, w?) and using (39), we obtain[ θm+1 − θ? wm+1−w? ] = [ θm − θ? wm−w? ] −σθ [ ρI −ÂT βÂ βĈ ][ θm−θ? wm−w? ] .\nWe analyze the convergence of the algorithms by examining the differences between the current parameters to the optimal solution. More specifically, we define a scaled residue vector\n∆m ,\n[ θm − θ?\n1√ β (wm − w?)\n] , (40)\nwhich obeys the following iteration:\n∆m+1 = (I − σθG) ∆m, (41)\nwhere G is exactly the matrix defined in (20). As analyzed in Section A.1, if we choose β sufficiently large, such as in (22), then G is diagonalizable with all its eigenvalues real and positive. In this case, we let Q be the matrix of eigenvectors in the eigenvalue decomposition G = QΛQ−1, and use the potential function\nPm , ∥∥Q−1∆m∥∥22\nin our convergence analysis. We can bound the usual Euclidean distance by Pm as\n‖θm − θ?‖2 + ‖wm − w?‖2 ≤ (1 + β)σ2max(Q)Pm.\nIf we have linear convergence in Pm, then the extra factor (1 + β)σ2max(Q) will appear inside a logarithmic term.\nRemark: This potential function has an intrinsic geometric interpretation. We can view column vectors of Q−1 a basis for the vector space, which is not orthogonal. Our goal is to show that in this coordinate system, the distance to optimal solution shrinks at every iteration.\nWe proceed to bound the growth of Pm:\nPm+1 = ∥∥Q−1∆m+1∥∥22\n= ∥∥Q−1 (I − σθG) ∆m∥∥22\n= ∥∥Q−1 (QQ−1 − σθQΛQ−1)∆m∥∥22\n= ∥∥(I − σθΛ)Q−1∆m∥∥22\n≤ ‖I − σθΛ‖22 ∥∥Q−1∆m∥∥22 = ‖I − σθΛ‖22 Pm (42)\nThe inequality above uses sub-multiplicity of spectral norm. We choose σθ to be\nσθ = 1\nλmax (Λ) =\n1\nλmax(G) , (43)\nSince all eigenvalues of G are real and positive, we have\n‖I − σθΛ‖2 = (\n1− λmin(G) λmax(G) )2 ≤ ( 1− 8\n81 · 1 κ(Ĉ)κ(ρI + ÂT Ĉ−1Â)\n)2 ,\nwhere we used the bounds on the eigenvalues λmax(G) and λmin(G) in (36) and (37) respectively. Therefore, we can achieve an -close solution with\nm = O ( κ(Ĉ)κ(ρI + ÂT Ĉ−1Â) log ( P0 )) iterations of the PDBG algorithm.\nIn order to minimize ‖I − σθΛ‖, we can choose\nσθ = 2\nλmax(G) + λmin(G) ,\nwhich results in ‖I − σθΛ‖ = 1− 2/(1 + κ(Λ)) instead of 1−1/κ(Λ). The resulting complexity stays the same order. The step sizes stated in Theorem 1 is obtained by replacing λmax in (43) with its upper bound in (36) and setting σw through the ratio β = σw/σθ as in (22)."
    }, {
      "heading" : "C Analysis of SVRG",
      "text" : "Here we establish the linear convergence of the SVRG algorithm for policy evaluation described in Algorithm 2.\nRecall the finite sum structure in Â, b̂ and Ĉ:\nÂ = 1\nn n∑ t=1 At, b̂ = 1 n n∑ t=1 bt, Ĉ = 1 n n∑ t=1 Ct.\nThis structure carries over to the Lagrangian L(θ, w) as well as the gradient operator B(θ, w), so we have\nB(θ, w) = 1\nn n∑ t=1 Bt(θ, w),\nwhere\nBt(θ, w) = [ ρI −A>t At Ct ] [ θ w ] − [ 0 bt ] . (44)\nAlgorithm 2 has both an outer loop and an inner loop. We use the index m for the outer iteration and j for the inner iteration. Fixing the outer loop index m, we look at the inner loop of Algorithm 2. Similar to full gradient method, we first simplify the dynamics of SVRG.[ θm,j+1 wm,j+1 ] = [ θm,j wm,j ] − [ σθ σw ] × ( B(θm−1, wm−1)\n+Btj (θm,j , wm,j)−Bt(θm−1, wm−1) )\n= [ θm,j wm,j ] − [ σθ σw ] × ([ ρI −Â> Â Ĉ ] [ θm−1 wm−1 ] − [ 0 b̂\n] + [ ρI −A>t At Ct ] [ θm,j wm,j ] − [ 0 bt\n] − [ ρI −A>t At Ct ] [ θm−1 wm−1 ] + [ 0 bt ]) .\nSubtracting (θ?, w?) from both sides and using the optimality condition (39), we have[ θm,j+1 − θ? wm,j+1 − w? ] = [ θm,j − θ? wm,j − w? ] − [ σθ σw\n] × ([ ρI −Â> Â Ĉ ][ θm−1 − θ? wm−1 − w?\n] + [ ρI −A>t At Ct ] [ θm,j − θ? wm,j − w?\n] − [ ρI −A>t At Ct ] [ θm−1 − θ? wm−1 − w? ]) .\nMultiplying both sides of the above recursion by diag(I, 1/ √ βI), and using a residue vector ∆m,j defined similarly as in (40), we obtain\n∆m,j+1 = ∆m,j − σθ(G∆m−1 +Gtj∆m,j −Gtj∆m−1) = (I − σθG) ∆m,j\n+ σθ ( G−Gtj ) (∆m,j −∆m−1) , (45)\nwhere Gtj is defined in (18).\nFor SVRG, we use the following potential functions to facilitate our analysis:\nPm , E [∥∥Q−1∆m∥∥2] , (46)\nPm,j , E [∥∥Q−1∆m,j∥∥2] . (47)\nUnlike the analysis for the batch gradient methods, the nonorthogonality of the eigenvectors will lead to additional dependency of the iteration complexity on the condition number of Q, for which we give a bound in (33).\nMultiplying both sides of Eqn. (45) byQ−1, taking squared 2-norm and taking expectation, we obtain\nPm,j+1 = E [∥∥Q−1[ (I − σθG) ∆m,j + σθ ( G−Gtj ) (∆m,j −∆m−1)\n]∥∥2] (a) = E\n[ ∥∥(I − σθΛ)Q−1∆m,j∥∥2 ] + σ2θ E\n[ ∥∥Q−1 (G−Gtj) (∆m,j−∆m−1)∥∥2 ] (b)\n≤ ‖I − σθΛ‖2 E [∥∥Q−1∆m,j∥∥2]\n+ σ2θ E [ ∥∥Q−1Gtj (∆m,j −∆m−1)∥∥2 ]\n(c) = ‖I − σθΛ‖2 Pm,j + σ2θ E [ ∥∥Q−1Gtj (∆m,j −∆m−1)∥∥2 ]. (48)\nwhere step (a) used the facts that Gtj is independent of ∆m,j and ∆m−1 and E[Gtj ] = G so the cross terms are zero, step (b) used again the same independence and that the variance of a random variable is less than its second moment, and step (c) used the definition of Pm,j in (47). To bound the last term in the above inequality, we use the simple notation δ = ∆m,j −∆m−1 and have∥∥Q−1Gtjδ∥∥2 = δTGTtjQ−TQ−1Gtjδ\n≤ λmax(Q−TQ−1)δTGTtjGtjδ.\nTherefore, we can bound the expectation as\nE [∥∥Q−1Gtjδ∥∥2]\n≤λmax(Q−TQ−1)E [ δTGTtjGtjδ ]\n=λmax(Q −TQ−1)E [ δTE[GTtjGtj ]δ ] ≤λmax(Q−TQ−1)L2GE [ δT δ\n] =λmax(Q −TQ−1)L2GE [ δTQ−TQTQQ−1δ\n] =λmax(Q −TQ−1)λmax(Q TQ)L2GE [ δTQ−TQ−1δ\n] ≤κ(Q)2L2GE [ ‖Q−1δ‖2 ] , (49)\nwhere in the second inequality we used the definition ofL2G in (18), i.e., L2G = ‖E[GTtjGtj ]‖. In addition, we have\nE [ ‖Q−1δ‖2 ] =E [∥∥Q−1(∆m,j −∆m−1)∥∥2]\n≤2 E [∥∥Q−1∆m,j∥∥2]+ 2 E[∥∥Q−1∆m−1∥∥2]\n= 2Pm,j + 2Pm−1.\nThen it follows from (48) that\nPm,j+1 ≤‖I − σθΛ‖2Pm,j + 2σ2θκ 2(Q)L2G(Pm,j + Pm−1).\nNext, let λmax and λmin denote the largest and smallest diagonal elements of Λ (eigenvalues of G), respectively. Then we have\n‖I − σθΛ‖2 = max { (1− σθλmin)2, (1− σθλmin)2 }\n≤ 1− 2σθλmin + σ2θλ2max ≤ 1− 2σθλmin + σ2θκ2(Q)L2G,\nwhere the last inequality uses the relation\nλ2max≤‖G‖2 =‖EGt‖2 ≤ ‖EGTt Gt‖= L2G ≤ κ2(Q)L2G.\nIt follows that Pm,j+1 ≤ ( 1− 2σθλmin + σ2θκ2 (Q)L2G ) Pm,j\n+ 2σ2θ κ 2 (Q)L2G(Pm,j + Pm−1) = [ 1− 2σθλmin + 3σ2θκ2(Q)L2G ] Pm,j\n+ 2σ2θ κ 2(Q)L2GPm−1\nIf we choose σθ to satisfy\n0 < σθ ≤ λmin\n3κ2 (Q)L2G , (50)\nthen 3σ2θκ 2(Q)L2G < σθλmin, which implies\nPm,j+1 ≤ (1− σθλmin)Pm,j + 2σ2θ κ2(Q)L2GPm−1.\nIterating the above inequality over j = 1, · · · , N − 1 and using Pm,0 = Pm−1 and Pm,N = Pm, we obtain\nPm = Pm,N ≤ [( 1−σθλmin )N +2σ2θκ 2(Q)L2G N−1∑ j=0 ( 1−σθλmin )j] Pm−1\n= [( 1−σθλmin )N +2σ2θκ 2(Q)L2G 1−(1−σθλmin)N\n1−(1−σθλmin)\n] Pm−1\n≤ [( 1− σθλmin )N + 2σ2θκ\n2(Q)L2G σθλmin\n] Pm−1\n= [( 1− σθλmin )N +\n2σθκ 2(Q)L2G λmin\n] Pm−1. (51)\nWe can choose\nσθ = λmin\n5κ2(Q)L2G , N =\n1\nσθλmin = 5κ2(Q)L2G λ2min , (52)\nwhich satisfies the condition in (50) and results in\nPm ≤ (e−1 + 2/5)Pm−1 ≤ (4/5)Pm−1.\nThere are many other similar choices, for example,\nσθ = λmin\n3κ2(Q)L2G , N =\n3\nσθλmin = 9κ2(Q)L2G λ2min ,\nwhich results in\nPm ≤ (e−3 + 2/3)Pm−1 ≤ (3/4)Pm−1.\nThese results imply that the number of outer iterations needed to have E[Pm] ≤ ] is log(P0/ ). For each outer iteration, the SVRG algorithm need O(nd) operations to compute the full gradient operator B(θ, w), and then N = O(κ2(Q)L2G/λ 2 min) inner iterations with each costingO(d) operations. Therefore the overall computational cost is\nO (( n+\nκ2 (Q)L2G λ2min\n) d log ( P0 )) .\nSubstituting (33) and (37) in the above bound, we get the overall cost estimate\nO (( n+\nκ(Ĉ)L2G\nλ2min(ρI + Â T Ĉ−1Â)\n) d log ( P0 )) .\nFinally, substituting the bounds in (33) and (37) into (52), we obtain the σθ and N stated in Theorem 2:\nσθ = λmin(ρI + Â\nT Ĉ−1Â)\n48κ(Ĉ)L2G ,\nN = 51κ2(Ĉ)L2G\nλ2min(ρI + Â T Ĉ−1Â)\n,\nwhich achieves the same complexity."
    }, {
      "heading" : "D Analysis of SAGA",
      "text" : "SAGA in Algorithm 3 maintains a table of previously computed gradients. Notation wise, we use φmt to denote that\nat m-th iteration, gt is computed using θφmt and wφmt . With this definition, φmt has the following dynamics:\nφm+1t = { φmt if tm 6= t, m if tm = t.\n(53)\nWe can write the m-th iteration’s full gradient as\nB = 1\nn n∑ t=1 Bt ( θφmt , wφmt ) .\nFor convergence analysis, we define the following quantity:\n∆φmt ,\n[ θφmt − θ?\n1√ β (wφmt − w?)\n] . (54)\nSimilar to (53), it satisfies the following iterative relation:\n∆φm+1t = { ∆φmt if tm 6= t, ∆m if tm = t.\nWith these notations, we can express the vectors used in SAGA as\nBm = 1\nn n∑ t=1 [ ρI −ATt At Ct ] [ θφmt wφmt ] − 1 n n∑ t=1 [ 0 bt ] ,\nhtm = [ ρI −ATtm Atm Ctm ] [ θm wm ] − [ 0 btm ] ,\ngtm = [ ρI −ATtm Atm Ctm ] [ θφmt wφmt ] − [ 0 btm ] .\nThe dynamics of SAGA can be written as[ θm+1 wm+1 ] = [ θm wm ] − [ σθ σw ] (Bm + htm − gtm)\n= [ θm wm ] − [ σθ σw ] {\n1\nn n∑ t=1 [ ρI −ATt At Ct ][ θφmt wφmt ] + 1 n n∑ t=1 [ 0 bt ]\n+ [ ρI −ATtm Atm Ctm ][ θm wm ] − [ ρI −ATtm Atm Ctm ][ θφmtm wφmtm ]}\nSubtracting (θ?, w?) from both sides, and using the optimality condition in (39), we obtain[\nθm+1 − θ? wm+1 − w?\n] = [ θm − θ? wm − w? ] − [ σθ σw ] {\n1\nn n∑ t=1 [ ρI −ATt At Ct ][ θφmt − θ? wφmt − w? ] +\n[ ρI −ATtm Atm Ctm ][ θm − θ? wm − w? ]\n− [ ρI −ATtm Atm Ctm ][ θφmtm − θ? wφmtm − w? ]} .\nMultiplying both sides by diag(I, 1/ √ βI), we get\n∆m+1 = ∆m − ( σθ n n∑ t=1 Gt∆φmt ) − σθGtm ( ∆m −∆φmtm ) . (55)\nwhere Gtm is defined in (18).\nFor SAGA, we use the following two potential functions: Pm = E ∥∥Q−1∆m∥∥22 ,\nQm = E [ 1\nn n∑ t=1 ∥∥Q−1Gt∆φmt ∥∥22] = E[∥∥∥Q−1Gtm∆φmtm∥∥∥22 ] .\nThe last equality holds because we use uniform sampling. We first look at how Pm evolves. To simplify notation, let\nvm = ( σθ n n∑ t=1 Gt∆φmt ) + σθGtm ( ∆m −∆φmtm ) ,\nso that (55) becomes ∆m+1 = ∆m − vm. We have\nPm+1 = E [∥∥Q−1∆m+1∥∥22]\n= E [∥∥Q−1 (∆m − vm)∥∥2]\n= E [∥∥Q−1∆m∥∥22−2∆>mQ−>Q−1vm+∥∥Q−1vm∥∥22 ]\n= Pm − E [ 2∆>mQ −>Q−1vm ] + E [ ∥∥Q−1vm∥∥22 ].\nSince ∆m is independent of tm, we have E [ 2∆>mQ −>Q−1vm ] = E [ 2∆>mQ −>Q−1Etm [vm] ] ,\nwhere the inner expectation is with respect to tm conditioned on all previous random variables. Notice that\nEtm [ Gtm∆φmtm ] = 1\nn n∑ t=1 Gt∆φmt ,\nwhich implies Etm [vm] = σθEtm [Gtm ]∆m = σθG∆m. Therefore, we have\nPm+1 = Pm − E [ 2σθ∆ T mQ −TQ−1G∆m ] + E [ ∥∥Q−1vm∥∥22 ] = Pm − E2σθ [ ∆TmQ −TΛQ−1∆m ] + E\n[ ∥∥Q−1vm∥∥22 ] ≤ Pm − 2σθλminE\n[∥∥Q−1∆m∥∥2]+ E[ ∥∥Q−1vm∥∥22 ] = (1− 2σθλmin)Pm + E [∥∥Q−1vm∥∥22] , (56)\nwhere the inequality used λmin,λmin(Λ)=λmin(G) > 0, which is true under our choice of β = σw/σθ in Section A.1. Next, we bound the last term of Eqn. (56):\nE [ ∥∥Q−1vm∥∥22 ]\n= E [∥∥∥Q−1(σθ\nn n∑ t=1 Gt∆φmt +σθGtm ( ∆m−∆φmtm ))∥∥∥2] ≤ 2σ2θE\n[∥∥Q−1Gtm∆m∥∥22] + 2σ2θE [∥∥∥Q−1( 1 n n∑ t=1 Gt∆φmt −Gtm∆φmtm )∥∥∥2]\n≤ 2σ2θE [∥∥Q−1Gtm∆m∥∥22 ]+ 2σ2θE[‖Q−1Gtm∆φmtm ‖2]\n= 2σ2θE [∥∥Q−1Gtm∆m∥∥22 ]+ 2σ2θQm,\nwhere the first inequality uses ‖a+ b‖22 ≤ 2 ‖a‖ 2 2 +2 ‖b‖ 2 2, and the second inequality holds because for any random variable ξ, E ‖ξ − E [ξ]‖22 = E ‖ξ‖ 2 2 − ‖Eξ‖ 2 2 ≤ E ‖ξ‖ 2 2. Using similar arguments as in (49), we have\nE [ ∥∥Q−1Gtm∆m∥∥22 ] ≤ κ2(Q)L2GPm, (57)\nTherefore, we have Pm+1 ≤ ( 1− 2σθλmin + 2σ2θκ2 (Q)L2G ) Pm\n+ 2σ2θQm. (58)\nThe inequality (58) shows that the dynamics ofPm depends on both Pm itself and Qm. So we need to find another iterative relation for Pm and Qm. To this end, we have\nQm+1 = E\n[ 1\nn n∑ t=1 ∥∥∥Q−1Gt∆φm+1t ∥∥∥22 ]\n= E [ 1\nn ‖Q−1Gtm∆φm+1tm ‖ 2\n+ 1\nn ∑ t 6=tm ‖Q−1Gt∆φm+1t ‖ 2 ] (a) = E [ 1\nn ‖Q−1Gtm∆m‖2\n+ 1\nn ∑ t 6=tm ‖Q−1Gt∆φmt ‖ 2\n]\n= E [ 1\nn ‖Q−1Gtm∆m‖2 −\n1 n ‖Q−1Gtm∆φmtm‖ 2\n+ 1\nn n∑ t=1 ‖Q−1Gt∆φmt ‖ 2 ] = 1\nn E[‖Q−1Gtm∆m‖2]−\n1 n E[‖Q−1Gtm∆φmtm‖ 2]\n+ E [ 1\nn n∑ t=1 ‖Q−1Gt∆φmt ‖ 2\n]\n= 1\nn E[‖Q−1Gtm∆m‖2]−\n1 n E[‖Q−1Gtm∆φmtm‖ 2]\n+ E [ ‖Q−1Gtm∆φmtm‖ 2 ] = 1\nn E[‖Q−1Gtm∆m‖2] + n− 1 n Qm\n(b) ≤ κ 2(Q)L2G n Pm + n− 1 n Qm. (59)\nwhere step (a) uses (53) and step (b) uses (57).\nTo facilitate our convergence analysis on Pm, we construct a new Lyapunov function which is a linear combination of Eqn. (58) and Eqn. (59). Specifically, consider\nTm = Pm + nσθλmin (1− σθλmin)\nκ2(Q)L2G Qm.\nNow consider the dynamics of Tm. We have\nTm+1 = Pm+1 + nσθλmin (1− σθλmin)\nκ2(Q)L2G Qm+1 ≤ ( 1− 2σθλmin + 2σ2θκ2 (Q)L2G ) Pm + 2σ 2 θQm\n+ nσθλmin(1−σθλmin)\nκ2(Q)L2G\n( κ2(Q)L2G\nn Pm+ n−1 n Qm ) = ( 1− σθλmin + 2σ2θκ2(Q)L2G − σ2θλ2min ) Pm\n+ 2σ2θκ 2(Q)L2G+(n−1)σθλmin(1−σθλmin) κ2(Q)L2G Qm.\nLet’s define\nρ = σθλmin − 2σ2θκ2(Q)L2G.\nThe coefficient for Pm in the previous inequality can be upper bounded by 1− ρ because 1− ρ− σ2θλ2min ≤ 1− ρ. Then we have\nTm+1\n≤ (1− ρ)Pm+ 2σ2θκ\n2 (Q)L2G+(n−1)σθλmin (1−σθλmin) κ2(Q)L2G Qm\n= (1− ρ) ( Pm +\nnσθλmin (1− σθλmin) κ2(Q)L2G Qm ) + σθ 2σθκ 2(Q)L2G + (nρ− 1)λmin(1− σθλmin)\nκ2(Q)L2G Qm\n= (1− ρ)Tm\n+ σθ 2σθκ 2(Q)L2G + (nρ− 1)λmin(1− σθλmin) κ2(Q)L2G Qm.\n(60)\nNext we show that with the step size\nσθ = λmin\n3 (κ2 (Q)L2G + nλ 2 min)\n(61)\n(or smaller), the second term on the right-hand side of (60) is non-positive. To see this, we first notice that with this choice of σθ, we have\nλ2min 9 (κ2 (Q)L2G+nλ 2 min) ≤ ρ ≤ λ 2 min 3 (κ2 (Q)L2G+nλ 2 min) ,\nwhich implies\nnρ− 1 ≤ nλ 2 min\n3 (κ2 (Q)L2G+nλ 2 min)\n− 1 ≤ 1 3 − 1 = −2 3 .\nThen, it holds that\n2σθκ 2(Q)L2G + (nρ− 1)λmin(1− σθλmin)\n≤2σθκ2(Q)L2G − 2\n3 λmin(1− σθλmin)\n=− (6n− 2)λ 3 min\n9 (κ2(Q)L2G + nλ 2 min)\n< 0.\nTherefore (60) implies\nTm+1 ≤ (1− ρ)Tm.\nNotice that Pm ≤ Tm and Q0 = P0. Therefore we have T0 ≤ 2P0 and\nPm ≤ 2(1− ρ)mP0.\nUsing (61), we have\nρ = σθλmin(G)− 2σ2θκ2(Q)L2G ≥ λ2min 9 ( κ2(Q)L2G + nλ 2 min ) . To achieve Pm ≤ , we need at most\nm = O (( n+\nκ2 (Q)L2G λ2min\n) log ( P0 )) iterations. Substituting (37) and (33) in the above bound, we get the desired iteration complexity\nO (( n+\nκ(Ĉ)L2G\nλ2min(ρI + Â T Ĉ−1Â)\n) log ( P0 )) .\nFinally, using the bounds in (33) and (37), we can replace the step size in (61) by\nσθ = µρ 3 (\n8κ2(Ĉ)L2G + nµ 2 ρ ) , where µρ = λ2min(ρI + Â T Ĉ−1Â) as defined in (14)."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Policy evaluation is concerned with estimating the value function that predicts long-term values of states under a given policy. It is a crucial step in many reinforcement-learning algorithms. In this paper, we focus on policy evaluation with linear function approximation over a fixed dataset. We first transform the empirical policy evaluation problem into a (quadratic) convex-concave saddle-point problem, and then present a primal-dual batch gradient method, as well as two stochastic variance reduction methods for solving the problem. These algorithms scale linearly in both sample size and feature dimension. Moreover, they achieve linear convergence even when the saddle-point problem has only strong concavity in the dual variables but no strong convexity in the primal variables. Numerical experiments on benchmark problems demonstrate the effectiveness of our methods.",
    "creator" : "LaTeX with hyperref package"
  }
}