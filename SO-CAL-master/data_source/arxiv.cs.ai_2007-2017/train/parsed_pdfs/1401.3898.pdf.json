{
  "name" : "1401.3898.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "First-Order Stable Model Semantics and First-Order Loop Formulas",
    "authors" : [ "Joohyung Lee", "Yunsong Meng" ],
    "emails" : [ "joolee@asu.edu", "Yunsong.Meng@asu.edu" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "According to the theorem on loop formulas (Lin & Zhao, 2004), the stable models of a logic program (Gelfond & Lifschitz, 1988) can be characterized as the models of the logic program that satisfy all its loop formulas. This idea has turned out to be widely applicable in relating the stable model semantics to propositional logic, and has resulted in an efficient method for computing answer sets using SAT solvers. Since the original invention of loop formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee, Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu & Truszczynski, 2006; You & Liu, 2008). The theorem has also been applied to other nonmonotonic formalisms, such as nonmonotonic causal theories (Lee, 2004) and McCarthy’s circumscription (Lee & Lin, 2006). The notion of a loop was further refined as an “elementary loop” (Gebser & Schaub, 2005; Gebser, Lee, & Lierler, 2006, 2011). However, all this work is restricted to the propositional case. Variables contained in a program are first eliminated by grounding—the process which replaces every variable with every object constant—and then loop formulas are obtained from the ground program. As a result, loop formulas were defined as formulas in propositional logic.\nc©2011 AI Access Foundation. All rights reserved.\nChen, Lin, Wang, and Zhang’s definition (2006) of a first-order loop formula is different in that loop formulas are directly obtained from a non-ground program, so that they are first-order logic formulas which retain variables. However, since the semantics of a logic program that they refer to is based on grounding, these first-order loop formulas are simply understood as schemas for ground loop formulas, and only Herbrand models of the loop formulas were considered in this context.\nThe stable model semantics that does not involve grounding appeared a year later (Ferraris, Lee, & Lifschitz, 2007, 2011). The authors define the stable models of a firstorder sentence F as the models of the second-order sentence that is obtained by applying the “stable model operator” SM to F . The definition of SM is close to the definition of the circumscription operator CIRC (McCarthy, 1980, 1986). Under the first-order stable model semantics, logic programs are viewed as a special class of first-order theories. A similar definition of a stable model was given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin & Shoham, 1992). The first-order stable model semantics is also closely related to quantified equilibrium logic (Pearce & Valverde, 2005), and indeed, Ferraris et al. (2011) showed that they are essentially equivalent.\nA natural question arising is how first-order loop formulas and the first-order stable model semantics are related to each other. In general, the first-order stable model semantics is more expressive than first-order logic, and as such cannot be completely characterized by first-order loop formulas. Like circumscription, the concept of transitive closure can be represented in the first-order stable model semantics, but not in any set of first-order formulas, even if that set is allowed to be infinite.1 However, as we show in this paper, understanding the precise relationship between them gives us insights into the first-order stable model semantics and its computational properties.\nIn order to facilitate the comparison, we extend the definition of a first-order loop formula which was limited to nondisjunctive programs, to disjunctive programs and to arbitrary first-order theories. Also we present a reformulation of SM[F ] in the style of loop formulas, which includes the characterization of a loop by a syntactic formula. From this formulation, we derive several conditions, under which a first-order theory under the stable model semantics can be equivalently rewritten as first-order loop formulas.\nBased on the relationship between the first-order stable model semantics and first-order loop formulas, we extend the syntax of logic programs with explicit quantifiers, which may be useful in overcoming some limitations of traditional answer set programs in reasoning about non-Herbrand models. We define the semantics of such extended programs by identifying them as a special class of first-order theories under the stable model semantics. Such programs inherit from the general language the ability to handle nonmonotonic reasoning under the stable model semantics even in the absence of the unique name and the domain closure assumptions that are built into the grounding-based answer set semantics. On the other hand, the restricted syntax of an extended program leads to more succinct loop formulas. The following program Π1 is a simple insurance policy example represented in\n1. Vladimir Lifschitz, personal communication.\nthis syntax.\nHasWife(x) ← ∃y Spouse(x, y) HasWife(x) ← Man(x), Married(x) Married(x) ← Man(x), HasWife(x)\n∃w Discount(x,w) ← Married(x), not ∃z Accident(x, z).\nThe second and the third rules express that Married(x) and HasWife(x) are synonymous to each other when x is a Man. The last rule states that x is eligible for some discount plan (with the name unknown) if x is married and has no record of accident. The quantifier in the first rule can be dropped without affecting the meaning, but the other quantifiers cannot. We will say that a program Π entails a query F (under the stable model semantics) if every stable model of Π satisfies F . For example,\n• Π1 conjoined with Π2 = {Man(John)} entails each of ¬∃x Married(x) and ¬∃xy Discount(x, y).\n• Π1 ∪ Π2 conjoined with Π3 = {∃y Spouse(John, y)} entails neither ¬∃x Married(x) nor ¬∃xy Discount(x, y), but entails each of ∃x Married(x), ∃xyDiscount(x, y), and ∀xy(Discount(x, y)→ x = John).\n• Π1 ∪Π2 ∪Π3 conjoined with Π4 = {∃z Accident(John, z)} does not entail ∀xy(Discount(x, y)→ x = John), but entails ¬∃w Discount(John, w).\nThe nonmonotonic reasoning of this kind requires non-Herbrand models since the names (or identifiers) of discount plans, spouses and accident records may be unknown. However, the traditional answer set semantics is limited to Herbrand models due to the reference to grounding. By turning the program into first-order loop formulas we can automate the example reasoning using a first-order theorem prover.\nThe paper is organized as follows. The next section reviews the first-order stable model semantics by Ferraris et al. (2007, 2011). Section 3 reviews the theorem on first-order loop formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary first-order sentences, limiting attention to Herbrand stable models. Section 4 extends these results to allow non-Herbrand stable models as well (possibly allowing functions) under a certain semantic condition, and compare the first-order stable model semantics with loop formulas by reformulating the former in terms of the latter. In Section 5, we present a series of syntactic conditions that imply the semantic condition in Section 4. Section 6 provides an extension of logic programs that contain explicit quantifiers and shows how query answering for such extended programs can sometimes be reduced to entailment checking in first-order logic via loop formulas. In Section 7, the results are further extended to distinguish between intensional and non-intensional predicates. Related work is described in Section 8, and long proofs are given in Appendix A.\nThis article is an extended version of a conference paper by Lee and Meng (2008)."
    }, {
      "heading" : "2. Review of the First-Order Stable Model Semantics",
      "text" : "This review follows a journal paper by Ferraris et al. (2011) that extends a conference paper by the same authors (Ferraris et al., 2007) by distinguishing between intensional and non-intensional predicates.\nA formula is defined the same as in first-order logic. A signature consists of function constants and predicate constants. Function constants of arity 0 are called object constants. We assume the following set of primitive propositional connectives and quantifiers:\n⊥ (falsity), ∧, ∨, →, ∀, ∃ .\n¬F is an abbreviation of F → ⊥, symbol > stands for ⊥ → ⊥, and F ↔ G stands for (F → G) ∧ (G → F ). We distinguish between atoms and atomic formulas as follows: an atom of a signature σ is an n-ary predicate constant followed by a list of n terms that can be formed from function constants in σ (including object constants) and object variables; atomic formulas of σ are atoms of σ, equalities between terms of σ, and the 0-place connective ⊥.\nThe stable models of F relative to a list of predicates p = (p1, . . . , pn) are defined via the stable model operator with the intensional predicates p, denoted by SM[F ; p].2 Let u be a list of distinct predicate variables u1, . . . , un of the same length as p. By u = p we denote the conjunction of the formulas ∀x(ui(x)↔ pi(x)), where x is a list of distinct object variables of the same length as the arity of pi, for all i = 1, . . . , n. By u ≤ p we denote the conjunction of the formulas ∀x(ui(x) → pi(x)) for all i = 1, . . . , n, and u < p stands for (u ≤ p)∧¬(u = p). For any first-order sentence F , the expression SM[F ; p] stands for the second-order sentence\nF ∧ ¬∃u((u < p) ∧ F ∗(u)), (1)\nwhere F ∗(u) is defined recursively:\n• pi(t)∗ = ui(t) for any list t of terms;\n• F ∗ = F for any atomic formula F (including ⊥ and equality) that does not contain members of p;\n• (F ∧G)∗ = F ∗ ∧G∗;\n• (F ∨G)∗ = F ∗ ∨G∗;\n• (F → G)∗ = (F ∗ → G∗) ∧ (F → G);\n• (∀xF )∗ = ∀xF ∗;\n• (∃xF )∗ = ∃xF ∗.\n(There is no clause for negation here, because we treat ¬F as shorthand for F → ⊥.) A model of a sentence F (in the sense of first-order logic) is called p-stable if it satisfies SM[F ; p]. We will often simply write SM[F ] instead of SM[F ; p] when p is the list of all predicate constants occurring in F , and call a model of SM[F ] simply a stable model of F . We distinguish between the terms “stable models” and “answer sets” as follows.3 By σ(F ) we denote the signature consisting of the function and predicate constants occurring in F .\n2. The intensional predicates p are the predicates that we “intend to characterize” by F . 3. The distinction is useful because in the first-order setting, stable models are no longer Herbrand inter-\npretations and may not be represented by sets of atoms.\nIf F contains at least one object constant, an Herbrand interpretation4 of σ(F ) that satisfies SM[F ] is called an answer set of F . The answer sets of a logic program Π are defined as the answer sets of the FOL-representation of Π (i.e., the conjunction of the universal closures of implications corresponding to the rules).\nExample 1 For program Π that contains three rules\np(a) q(b) r(x)← p(x),not q(x)\nthe FOL-representation F of Π is\np(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x))→ r(x)) (2)\nand SM[F ] is\np(a) ∧ q(b) ∧ ∀x((p(x) ∧ ¬q(x))→ r(x)) ∧¬∃uvw(((u, v, w) < (p, q, r)) ∧ u(a) ∧ v(b)\n∧∀x(((u(x) ∧ (¬v(x) ∧ ¬q(x)))→ w(x)) ∧ ((p(x) ∧ ¬q(x))→ r(x)))),\nwhich is equivalent to the first-order sentence\n∀x(p(x)↔ x = a) ∧ ∀x(q(x)↔ x = b) ∧ ∀x(r(x)↔ (p(x) ∧ ¬q(x))) (3)\n(See Example 3 in the work of Ferraris et al., 2007). The stable models of F are any firstorder models of (3). The only answer set of F is the Herbrand model {p(a), q(b), r(a)}."
    }, {
      "heading" : "3. First-Order Loop Formulas and Herbrand Models",
      "text" : "We review the definition of a first-order loop formula for a nondisjunctive program given by Chen et al. (2006) and extend it to a disjunctive program and to an arbitrary first-order sentence."
    }, {
      "heading" : "3.1 Review of First-Order Loop Formulas Defined by Chen et al. (2006)",
      "text" : "We call a formula negative if every occurrence of every predicate constant in it belongs to the antecedent of an implication. For instance, any formula of the form ¬F is negative because this expression is shorthand for F → ⊥. An equality t1 = t2 is also negative because it contains no predicate constants.\nA nondisjunctive program is a finite set of rules of the form\nA← B,N, (4)\n4. Recall that an Herbrand interpretation of a signature σ (containing at least one object constant) is an interpretation of σ such that its universe is the set of all ground terms of σ, and every ground term represents itself. An Herbrand interpretation can be identified with the set of ground atoms to which it assigns the value true.\nwhere A is an atom, B is a set of atoms, and N is a negative formula. The rules may contain function constants of positive arity.5\nWe will say that a nondisjunctive program is in normal form if, for all rules (4) in it, A is of the form p(x) where x is a list of distinct variables. It is clear that every program can be turned into normal form using equality in the body. For instance, p(a, b)← q(a) can be rewritten as p(x, y)← x=a, y=b, q(a).\nLet Π be a nondisjunctive program and let Norm(Π) be a normal form of Π. By σ(Π) we denote the signature consisting of function and predicate constants occurring in Π. Given a finite set Y of atoms, we assume that Norm(Π) does not contain variables in Y , by renaming the variables in Norm(Π). The (first-order) external support formula of Y for Π, denoted by ES Π(Y ), is the disjunction of∨\nθ:Aθ∈Y ∃z ( Bθ ∧Nθ ∧ ∧ p(t)∈Bθ p(t′)∈Y (t 6= t′) )\n(5)\nfor all rules (4) in Norm(Π),6 where θ is a substitution that maps variables in A to terms occurring in Y , and z is the list of all variables that occur in\nAθ ← Bθ,Nθ\nbut not in Y .\nThe (first-order) loop formula of Y for Π, denoted by LF Π(Y ), is the universal closure of ∧\nY → ES Π(Y ). (6)\n(The expression ∧ Y in the antecedent stands for the conjunction of all elements of Y .) When Π is a propositional program, LF Π(Y ) is equivalent to a conjunctive loop formula as defined by Ferraris et al. (2006).\nThe definition of a first-order dependency graph and the definition of a first-order loop are as follows. We say that an atom p(t) depends on an atom q(t′) in a rule (4) if p(t) is A and q(t′) is in B. The (first-order) dependency graph of Π is an infinite directed graph (V,E) such that\n• V is the set of atoms of signature σ(Π);7\n• (p(t)θ, q(t′)θ) is in E if p(t) depends on q(t′) in a rule of Π and θ is a substitution that maps variables in t and t′ to terms (including variables) of σ(Π).\nA nonempty subset L of V is called a (first-order) loop of Π if the subgraph of the first-order dependency graph of Π induced by L is strongly connected.\n5. The original definition by Chen et al. (2006) does not allow function constants of positive arity. 6. For any lists of terms t = (t1, . . . , tn) and t ′ = (t′1, . . . , t ′ n) of the same length, t = t\n′ stands for (t1 = t ′ 1) ∧ · · · ∧ (tn = t′n).\n7. Note that V is infinite since infinitely many object variables can be used to form atoms.\nExample 2 Let Π be the following program:\np(x)← q(x) q(y)← p(y) p(z)← not r(z).\n(7)\nThe following sets of atoms are first-order loops (among many others): Y1 = {p(u)}, Y2 = {q(u)}, Y3 = {r(u)}, Y4 = {p(u), q(u)}. Their loop formulas are\nLF Π(Y1) = ∀u(p(u)→ (q(u) ∨ ¬r(u))), LF Π(Y2) = ∀u(q(u)→ p(u)), LF Π(Y3) = ∀u(r(u)→ ⊥), LF Π(Y4) = ∀u(p(u) ∧ q(u)→ (q(u) ∧ u 6= u) ∨ (p(u) ∧ u 6= u) ∨ ¬r(u)).\nExample 3 Let Π be the one-rule program\np(x)← p(y). (8)\nIts finite first-order loops are Yk = {p(x1), . . . , p(xk)} where k > 0. Formula LF Π(Yk) is ∀x1 . . . xk ( p(x1) ∧ . . . ∧ p(xk)→ ∃y(p(y) ∧ (y 6= x1) ∧ . . . ∧ (y 6= xk)) ) . (9)\nThe following is a reformulation of Theorem 1 from the work of Chen et al. (2006).\nTheorem 1 Let Π be a nondisjunctive program that contains at least one object constant but no function constants of positive arity, and let I be an Herbrand interpretation of σ(Π) that satisfies Π.8 The following conditions are equivalent to each other:\n(a) I is a stable model of Π;\n(b) for every nonempty finite set Y of atoms of σ(Π), I satisfies LF Π(Y ); 9\n(c) for every finite first-order loop Y of Π, I satisfies LF Π(Y ).\nThe sets of first-order loop formulas considered in conditions (b) and (c) above have obvious redundancies. For instance, the loop formula of {p(x)} is equivalent to the loop formula of {p(y)}; the loop formula of {p(x), p(y)} entails the loop formula of {p(z)}. Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2, we say that Y1 subsumes Y2 if there is a substitution θ that maps variables in Y1 to terms so that Y1θ = Y2.\nProposition 1 (Chen et al., 2006, Proposition 7) For any nondisjunctive program Π and any loops Y1 and Y2 of Π, if Y1 subsumes Y2, then LF Π(Y1) entails LF Π(Y2).\nTherefore in condition (c) from Theorem 1, it is sufficient to consider a set Γ of loops such that, for every loop L of Π, there is a loop L′ in Γ that subsumes L. Chen et al. (2006) called such Γ a complete set of loops. In Example 2, set {Y1, Y2, Y3, Y4} is a finite complete set of loops of program (7). Program (8) in Example 3 has no finite complete set of loops.\n8. We say that I satisfies Π if I satisfies the FOL-representation of Π. 9. Note that Y may contain variables."
    }, {
      "heading" : "3.2 Extension to Disjunctive Programs",
      "text" : "A disjunctive program is a finite set of rules of the form\nA← B,N, (10)\nwhere A and B are sets of atoms, and N is a negative formula. Similar to a nondisjunctive program, we say that a disjunctive program is in normal form if, for all rules (10) in it, all atoms in A are of the form p(x) where x is a list of distinct variables.\nLet Π be a disjunctive program and let Norm(Π) be a normal form of Π. Given a finite set Y of atoms, we first rename variables in Norm(Π) so that no variables in Norm(Π) occur in Y . The (first-order) external support formula of Y for Π, denoted by ES Π(Y ), is the disjunction of∨\nθ:Aθ∩Y 6=∅\n∃z ( Bθ ∧Nθ ∧ ∧ p(t)∈Bθ p(t′)∈Y (t 6= t′) ∧ ¬ ( ∨ p(t)∈Aθ ( p(t) ∧ ∧ p(t′)∈Y t 6= t′ )))\n(11)\nfor all rules (10) in Norm(Π), where θ is a substitution that maps variables in A to terms occurring in Y or to themselves, and z is the list of all variables that occur in\nAθ ← Bθ,Nθ\nbut not in Y . The (first-order) loop formula of Y for Π, denoted by LF Π(Y ), is the universal closure of ∧\nY → ES Π(Y ).\nClearly, (11) is equivalent to (5) when Π is nondisjunctive. When Π and Y are propositional, LF Π(Y ) is equivalent to the conjunctive loop formula for a disjunctive program as defined by Ferraris et al. (2006).\nExample 4 Let Π be the program\np(x, y) ; p(y, z) ← q(x)\nand let Y = {p(u, v)}. Formula LF Π(Y ) is the universal closure of\np(u, v)→ ∃z(q(u) ∧ ¬(p(v, z) ∧ ((v, z) 6= (u, v)))) ∨ ∃x(q(x) ∧ ¬(p(x, u) ∧ ((x, u) 6= (u, v)))).\nSimilar to the nondisjunctive case, we say that p(t) depends on q(t′) in Π if there is a rule (10) in Π such that p(t) is in A and q(t′) is in B. The definitions of a first-order dependency graph and a first-order loop are extended to disjunctive programs in a straightforward way. Using these extended notions, the following theorem extends Theorem 1 to a disjunctive program. It is also a generalization of the main theorem by Ferraris et al. (2006) which was restricted to a propositional disjunctive program.\nTheorem 1 d Let Π be a disjunctive program that contains at least one object constant but no function constants of positive arity, and let I be an Herbrand interpretation of σ(Π) that satisfies Π. The following conditions are equivalent to each other:\n(a) I is a stable model of Π;\n(b) for every nonempty finite set Y of atoms of σ(Π), I satisfies LF Π(Y );\n(c) for every finite first-order loop Y of Π, I satisfies LF Π(Y )."
    }, {
      "heading" : "3.3 Extension to Arbitrary Sentences",
      "text" : "In this section we extend the definition of a first-order loop formula to an arbitrary firstorder sentence.\nAs with a propositional loop formula defined for an arbitrary propositional theory (Ferraris et al., 2006), it is convenient to introduce a formula whose negation is close to ES . We define formula NESF (Y ) (“Negation of (First-order) External Support Formula”), where F is a first-order formula and Y is a finite set of atoms, as follows. As before we assume that no variables in Y occur in F , by renaming variables.\n• NES pi(t)(Y ) = pi(t) ∧ ∧ pi(t′)∈Y t 6= t ′;\n• NES t1=t2(Y ) = (t1 = t2);\n• NES⊥(Y ) = ⊥;\n• NESF∧G(Y ) = NESF (Y ) ∧NESG(Y );\n• NESF∨G(Y ) = NESF (Y ) ∨NESG(Y );\n• NESF→G(Y ) = (NESF (Y )→NESG(Y )) ∧ (F→G);\n• NES∀xG(Y ) = ∀xNESG(Y );\n• NES∃xG(Y ) = ∃xNESG(Y ).\nThe (first-order) loop formula of Y for F , denoted by LFF (Y ), is the universal closure of ∧\nY → ¬NESF (Y ). (12)\nNote that the definition of NES looks similar to the definition of F ∗ given in Section 2. When F and Y are propositional, LFF (Y ) is equivalent to a conjunctive loop formula for a propositional formula that is defined by Ferraris et al. (2006). The following lemma tells us that the definition of a loop formula in this section generalizes the definition of a loop formula for a disjunctive program in the previous section.\nLemma 1 Let Π be a disjunctive program in normal form, F an FOL-representation of Π, and Y a finite set of atoms. Formula NESF (Y ) is equivalent to ¬ES Π(Y ) under the assumption F .\nIn order to extend the first-order dependency graph to an arbitrary formula, we introduce a few notions. We say that an occurrence of a subformula G in a formula F is positive if the number of implications in F containing that occurrence in the antecedent is even; it is strictly positive if that number is 0. A rule of a first-order formula F is an implication that occurs strictly positively in F . We will say that a formula is rectified if it has no variables that are both bound and free, and if all quantifiers in the formula refer to different variables. Any formula can be easily rewritten into a rectified formula by renaming bound variables.\nWe say that an atom p(t) depends on an atom q(t′) in an implication G→ H if\n• p(t) has a strictly positive occurrence in H, and\n• q(t′) has a positive occurrence in G that does not belong to any negative subformula of G.10\nThe definition of a first-order dependency graph is extended to formulas as follows. The (first-order) dependency graph of a rectified formula F is the infinite directed graph (V,E) such that\n• V is the set of atoms of signature σ(F );\n• (p(t)θ, q(t′)θ) is in E if p(t) depends on q(t′) in a rule of F and θ is a substitution that maps variables in t and t′ to terms of σ(F ).\nNote that the rectified formula assumption is required in order to distinguish between dependency graphs of formulas such as\n∀x(p(x)→ q(x))\nand ∀x p(x)→ ∀x q(x).\nOnce the definition of a dependency graph is given, a loop of a first-order formula is defined in the same way as with a disjunctive program. Theorem 1 can be extended to first-order sentences using these extended notions.\nTheorem 1 f Let F be a rectified sentence that contains at least one object constant but no function constants of positive arity, and let I be an Herbrand interpretation of σ(F ) that satisfies F . The following conditions are equivalent to each other:\n(a) I is a stable model of F (i.e., I satisfies SM[F ]);\n(b) for every nonempty finite set Y of atoms of σ(F ), I satisfies LFF (Y );\n(c) for every finite first-order loop Y of F , I satisfies LFF (Y ).\nExample 2 (continued) Consider the FOL-representation F of the program in Example 2, for which {Y1, Y2, Y3, Y4} is a complete set of loops. Under the assumption F ,\n10. Recall the definition of a negative formula in Section 3.1.\n• LFF (Y1) is equivalent to the universal closure of p(u)→ ¬ ( ∀x(q(x)→ p(x) ∧ x 6= u) ∧ ∀y(p(y) ∧ y 6= u→ q(y))\n∧ ∀z(¬r(z)→ p(z) ∧ z 6= u) ) ;\n• LFF (Y2) is equivalent to the universal closure of q(u)→ ¬ ( ∀x(q(x) ∧ x 6= u→ p(x)) ∧ ∀y(p(y)→ q(y) ∧ y 6= u) ) ;\n• LFF (Y3) is equivalent to the universal closure of\nr(u)→ ⊥;\n• LFF (Y4) is equivalent to the universal closure of p(u) ∧ q(u)→ ¬ ( ∀x(q(x) ∧ x 6= u→ p(x) ∧ x 6= u)\n∧ ∀y(p(y) ∧ y 6= u→ q(y) ∧ y 6= u) ∧ ∀z(¬r(z)→ p(z) ∧ z 6= u) ) .\nProposition 1 can be straightforwardly extended to arbitrary sentences even without restricting the attention to loops.\nProposition 1 f For any sentence F and any nonempty finite sets of atoms Y1 and Y2 of σ(F ), if Y1 subsumes Y2, then LFF (Y1) entails LFF (Y2).\nProof. Note that LFF (Y1) is ∀z (∧ Y1 → ¬NESF (Y1) ) , (13)\nwhere z is the set of all variables in Y1. If Y1 subsumes Y2, by definition, there is a substitution θ from variables in Y1 to terms in Y2 such that Y1θ = Y2. It is clear that (13) entails\n∀z′ (∧ Y1θ → ¬NESF (Y1θ) ) , (14)\nwhere z′ is the set of all variables in Y1θ. (14) is exactly LFF (Y2).\nTheorem 2 from the work of Ferraris et al. (2006) is a special case of Theorem 1f when F is restricted to a propositional formula.\nCorollary 1 (Ferraris et al., 2006, Thm. 2) For any propositional formula F , the following formulas are equivalent to each other under the assumption F .\n(a) SM[F ];\n(b) the conjunction of LFF (Y ) for all nonempty sets Y of atoms occurring in F ;\n(c) the conjunction of LFF (Y ) for all (ground) loops Y of F ."
    }, {
      "heading" : "4. Comparing First-Order Stable Model Semantics and First-Order Loop",
      "text" : "Formulas\nThe theorems in the previous section were restricted to Herbrand stable models. This section extends the results to allow non-Herbrand stable models as well, and compare the idea of loop formulas with SM by reformulating the latter in the style of loop formulas."
    }, {
      "heading" : "4.1 Loop Formulas Relative to an Interpretation",
      "text" : "Recall that Theorem 1 and its extensions do not allow function constants of positive arity and are limited to Herbrand models of the particular signature obtained from the given theory. Indeed, the statements become wrong if these conditions are dropped.\nExample 5 The following program contains a unary function constant f .\np(a) p(x)← p(f(x)).\nThe loops of this program are all singleton sets of atoms, and their loop formulas are satisfied by the Herbrand model {p(a), p(f(a)), p(f(f(a))), . . . } of the program, but this model is not stable.\nExample 3 (continued) The mismatch can happen even in the absence of function constants of positive arity. Consider the program in Example 3 and an interpretation I such that the universe is the set of all integers, and pI contains all integers. Interpretation I satisfies all first-order loop formulas (9), but it is not a stable model.\nThese examples suggest that the mismatch between the first-order stable model semantics and the first-order loop formulas is related to the presence of an infinite path in the dependency graph that visits infinitely many vertices. In the following we will make this idea more precise, and extend Theorem 1f to allow non-Herbrand interpretations under a certain condition.\nFirst, we define a dependency graph relative to an interpretation. Let F be a rectified formula whose signature is σ and let I be an interpretation of σ. For each element ξ of the universe |I| of I, we introduce a new symbol ξ , called an object name. By σI we denote the signature obtained from σ by adding all object names ξ as additional object constants. We will identify an interpretation I of signature σ with its extension to σI defined by I(ξ ) = ξ (For details, see the work of Lifschitz, Morgenstern, & Plaisted, 2008).\nThe dependency graph of F w.r.t. I is the directed graph (V,E) where\n• V is the set of all atoms of the form pi(ξ ) where pi belongs to σ(F ) and ξ is a list of object names for |I|, and\n• (pi(ξ ), pj(η )) is in E if there are atoms pi(t), pj(t′) such that pi(t) depends on pj(t′) in a rule of F and there is a substitution θ that maps variables in t and t′ to object names such that (tθ)I = ξ and (t′θ)I = η.\nWe call a nonempty subset L of V a loop of F w.r.t. I if the subgraph of the dependency graph of F w.r.t. I that is induced by L is strongly connected. We say that F is bounded w.r.t. I if every infinite path in the dependency graph of F w.r.t. I whose vertices are satisfied by I visits only finitely many vertices. If F is bounded w.r.t. I, then, clearly, every loop L of F w.r.t. I such that I |= L is finite. The definition is extended to a non-rectified formula by first rewriting it as a rectified formula. It also applies to the program syntax by referring to its FOL-representation.\nTheorem 2 Let F be a rectified sentence of a signature σ (possibly containing function constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is bounded w.r.t. I, then the following conditions are equivalent to each other:\n(a) I |= SM[F ];\n(b) for every nonempty finite set Y of atoms formed from predicate constants in σ(F ) and object names for |I|, I satisfies LFF (Y );\n(c) for every finite loop Y of F w.r.t. I, I satisfies LFF (Y ).\nThe condition that F is bounded w.r.t. I is sufficient for ensuring the equivalence among (a), (b), and (c), but it is not a necessary condition. For instance, consider F to be\n∀x p(x) ∧ ∀xy(p(x)→ p(y))\nand I to be a model of F whose universe is infinite. Formula F is not bounded w.r.t. I, but I satisfies every loop formula, as well as SM[F ].\nWhen I is an Herbrand model of σ(F ), the dependency graph of F w.r.t. I is isomorphic to the subgraph of the first-order dependency graph of F that is induced by vertices containing ground atoms. A set of ground atoms of σ(F ) is a loop of F iff it is a loop of F w.r.t. I. Hence Theorem 2 is essentially a generalization of Theorem 1f .\nNote that the programs considered in Examples 3 and 5 are not bounded w.r.t. the interpretations considered there.\nClearly, if the universe of I is finite, then F is bounded w.r.t. I. This fact leads to the following corollary.\nCorollary 2 For any rectified sentence F and any model I of F whose universe is finite, conditions (a), (b), and (c) of Theorem 2 are equivalent to each other.\nIn view of Proposition 1f and Corollary 2, if the size of the universe is known to be a finite number n, it is sufficient to consider at most 2|p| − 1 loop formulas, where p is the set of all predicate constants occurring in the sentence. Each loop formula is to check the external support of ⋃ p∈K{p(x1), . . . , p(xnr)} for each K where\n• K is a nonempty subset of p;\n• r is the arity of p and each xi is a list of variables of the length r such that all variables in x1, . . . ,xnr are pairwise distinct.\nFor instance, consider program (8). If the size of the universe is known to be 3, it is sufficient to consider only one loop formula (9) where k = 3.\nTheorem 1f essentially follows from Corollary 2 as the Herbrand universe of σ(F ) is finite when F contains no function constants of positive arity.\nAnother corollary to Theorem 2 is acquired when F has only “trivial” loops. We say that a formula F is atomic-tight w.r.t. I if every path in the dependency graph of F w.r.t. I whose vertices are satisfied by I is finite. Clearly, this is a special case of boundedness condition, and every loop L of an atomic-tight formula F w.r.t. I such that I |= L is a singleton. The following is a corollary to Theorem 2, which tells us the condition under which stable models can be characterized by loop formulas of singleton loops only. By SLF[F ] (“loop formulas of singletons”) we denote\n{LFF ({p(x)}) | p is a predicate constant in σ(F ), and x is a list of distinct object variables whose length is the same as the arity of p}. (15)\nCorollary 3 Let F be a rectified sentence (possibly containing function constants of positive arity), and let I be a model of F . If F is atomic-tight w.r.t. I, then I satisfies SM[F ] iff I satisfies SLF[F ].\nSLF[F ] is similar to Clark’s completion. In the propositional case, the relationship between the loop formulas of singletons and the completion is studied by Lee (2005). Below we describe their relationship in the first-order case. A sentence F is in Clark normal form (Ferraris et al., 2011) if it is a conjunction of formulas of the form\n∀x(G→ p(x)), (16)\none for each predicate constant p occurring in F , where x is a list of distinct variables, and G has no free variables other than x. The completion of a sentence F in Clark normal form, denoted by Comp[F ], is obtained from F by replacing each conjunctive term (16) with\n∀x(p(x)↔ G).\nAny nondisjunctive program can be turned into Clark normal form (Ferraris et al., 2011, Section 6.1).\nCorollary 4 Let F be the FOL-representation of a nondisjunctive program Π, and let F ′ be the Clark normal form of F as obtained by the process described in the work of Ferraris et al. (2011, Section 6.1). If F is atomic-tight w.r.t. an interpretation I, then I |= SM[F ] iff I |= Comp[F ′].\nProof. Since F is atomic-tight w.r.t. I, by Corollary 3, I |= SM[F ] iff I |= F ∧ SLF[F ]. It is sufficient to show that, for each predicate constant p occurring in F , under the assumption that F is atomic-tight w.r.t. I,\nI |= ∀x ( p(x)→ ∨ p(t′)←B,N∈Π ∃z ( (x = t′) ∧B ∧N ∧ ∧ p(t)∈B (t 6= x) ))\n(17)\niff\nI |= ∀x ( p(x)→ ∨ p(t′)←B,N∈Π ∃z ( (x = t′) ∧B ∧N )) , (18)\nwhere z is the list of all free variables in p(x)← (x = t′), B,N that are not in x. Note that (17) is equivalent to saying that\nI |= ∀x ( p(x)→ ∨ p(t′)←B,N∈Π ∃z ( (x = t′) ∧B ∧N ∧ ∧ p(t)∈B (t 6= t′) )) . (19)\nFrom the assumption that F is atomic-tight w.r.t. I, it follows that, for any rule p(t′) ← B,N in Π and any atom of p(t) in B, I |= ∀y(t 6= t′), where y is the list of all variables in t and t′ (otherwise we find a singleton loop with a self-cycle, which contradicts that F is atomic tight w.r.t. I). Consequently, (19) is equivalent to (18).\nFor example, let F be the FOL-representation of the program\np(b) ← p(a) ← a 6= b (20)\nSLF[p(a)→ p(b)] is ∀x(p(x)→ x = b∧ p(a)∧ x 6= a), while Comp[∀x(x = b∧ p(a)→ p(x))] is ∀x(p(x) ↔ x = b ∧ p(a)). The additional conjunctive term x 6= a can be dropped when we consider any model I of F , for which aI 6= bI .\nCorollary 4 is an enhancement of Theorem 11 from the work of Ferraris et al. (2011), which states the equivalence between SM[F ] and Comp[F ] for any tight sentence F in Clark normal form. (Tight sentences are defined in a similar way, but in terms of a predicate dependency graph, whose vertices are predicate constants instead of atoms.) Every tight sentence is atomic-tight w.r.t. any model of the sentence. On the other hand, program (20) is atomic-tight w.r.t. any model of the program, but is not tight.\nTheorem 2 tells us that one of the limitations of first-order loop formulas is that, even if infinitely many first-order loop formulas are considered, they cannot ensure the external support of a certain infinite set that forms an infinite path in the dependency graph of F w.r.t. I. In the next section, by reformulating SM[F ], we show that the definition of SM[F ] essentially encompasses loop formulas, ensuring the external support of any sets of atoms, including those “difficult” infinite sets."
    }, {
      "heading" : "4.2 A Reformulation of SM",
      "text" : "As before, let F be a first-order formula of a signature σ, let p = (p1, . . . , pn) be the list of all predicate constants occurring in F , and let u and v be lists of predicate variables of the same length as p. We define NSESF (u) (“Negation of Second-Order External Support Formula”) recursively as follows.\n• NSES pi(t)(u) = pi(t) ∧ ¬ui(t);\n• NSES t1=t2(u) = (t1 = t2);\n• NSES⊥(u) = ⊥;\n• NSESF∧G(u) = NSESF (u) ∧NSESG(u);\n• NSESF∨G(u) = NSESF (u) ∨NSESG(u);\n• NSESF→G(u) = (NSESF (u)→NSESG(u)) ∧ (F→G);\n• NSES∀xF (u) = ∀xNSESF (u);\n• NSES∃xF (u) = ∃xNSESF (u).\nLemma 2 Let F be a rectified sentence of a signature σ, I an interpretation of σ, p the list of predicate constants occurring in F , q a list of predicate names 11 of the same length as p and Y a set of atoms formed from predicate constants from σ(F ) and object names such that\npi(ξ ) ∈ Y iff I |= qi(ξ ),\nwhere ξ is a list of object names. If Y is finite, then\nI |= NSESF (q) iff I |= NESF (Y ).\nProof. By induction on F . We only list the case when F is an atom. The other cases are straightforward. Let F be an atom pi(ξ ).\nI |= NSESF (q) iff I |= pi(ξ ) ∧ ¬qi(ξ ) iff I |= pi(ξ ) and pi(ξ ) /∈ Y iff I |= pi(ξ ) and for all η such that pi(η ) ∈ Y, it holds that ξ 6= η iff I |= pi(ξ ) ∧ ∧ pi(η )∈Y ξ 6= η iff I |= NESF (Y ).\nSM[F ] can be written in terms of NSES as follows. By Nonempty(u) we denote the formula\n∃x1u1(x1) ∨ · · · ∨ ∃xnun(xn),\nwhere each xi is a list of distinct variables whose length is the same as the arity of pi.\nProposition 2 For any sentence F , SM[F ] is equivalent to\nF ∧ ∀u((u ≤ p) ∧Nonempty(u)→ ¬NSESF (u)). (21)\nNow we represent the notion of a loop by a second-order formula. Given a rectified formula F , by EF (v,u) we denote∨\n(pi(t),pj(t ′)) :\npi(t) depends on pj(t ′) in a rule of F\n∃z(vi(t) ∧ uj(t′) ∧ ¬vj(t′)),\n11. Like object names, for every n > 0, each subset of |I|n has a name, which is an n-ary predicate constant not from the underlying signature.\nwhere z is the list of all object variables in t and t′. By LoopF (u) we denote the second-order formula Nonempty(u) ∧ ∀v((v < u) ∧Nonempty(v)→ EF (v,u)). (22) Formula (22) represents the concept of a loop without referring to the notion of a dependency graph explicitly. This is based on the following observation. Consider a finite propositional program Π. A nonempty set U of atoms that occur in Π is a loop of Π iff, for every nonempty proper subset V of U , there is an edge from an atom in V to an atom in U \\ V in the dependency graph of Π (Gebser et al., 2006).\nRecall the definition of a dependency graph relative to an interpretation. Let F be a rectified sentence of a signature σ, and let I be an interpretation of σ. The following proposition describes the relationship between formula (22) and a loop of F w.r.t. I.\nProposition 3 Let q be a list of predicate names corresponding to p, and let Y be a set of atoms in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Y iff I |= qi(ξ ),\nwhere ξ is a list of object names. Then I |= LoopF (q) iff Y is a loop of F w.r.t. I.\nOne might expect that, similar to the equivalence between conditions (a) and (c) from Theorem 2, formula SM[F ] is equivalent to the following formula:\nF ∧ ∀u((u ≤ p) ∧ LoopF (u)→ ¬NSESF (u)). (23)\nHowever, the equivalence does not hold in general, as the following example illustrates.\nExample 6 Consider the FOL-representation F of the following program\np(x, y)← q(x, z) q(x, z)← p(y, z),\nand an interpretation I whose universe is the set of all nonnegative integers such that\npI = {(m,m) | m is a nonnegative integer}, qI = {(m,m+1) | m is a nonnegative integer}.\nFormula F is not bounded w.r.t. I since the dependency graph of F w.r.t. I contains an infinite path such as\n〈p(0 , 0 ), q(0 , 1 ), p(1 , 1 ), q(1 , 2 ), . . .〉. (24)\nThe interpretation I satisfies every loop formula of every finite loop of F w.r.t. I, but it is not a stable model.\nIn the example, what distinguishes the set\n{p(0 , 0 ), q(0 , 1 ), p(1 , 1 ), q(1 , 2 ), . . . } (25)\nfrom a loop is that, for every loop contained in (25), there is an outgoing edge in the dependency graph. This is an instance of what we call “unbounded set.” Given a dependency graph of F w.r.t. I, we say that a nonempty set Y of vertices is unbounded w.r.t. I if, for every subset Z of Y that is a loop, there is an edge from a vertex in Z to a vertex in Y \\Z.\nThe following proposition tells us how an unbounded set can be characterized by a second-order formula.\nProposition 4 Let q be a list of predicate names corresponding to p, and let Y be a set of atoms in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Y iff I |= qi(ξ ),\nwhere ξ is a list of object names. Then\nI |= Nonempty(q) ∧ ∀v((v ≤ q) ∧ LoopF (v)→ EF (v,q))\niff Y is an unbounded set of F w.r.t. I.\nIn order to check the stability of a model, we need to check the external support of every loop and every unbounded set. An extended loop of F w.r.t. I is a loop or an unbounded set of F w.r.t. I. We define Ext-LoopF (u) as\nLoopF (u) ∨ (Nonempty(u) ∧ ∀v((v ≤ u) ∧ LoopF (v)→ EF (v,u))). (26)\nFrom Propositions 3 and 4, it follows that I |= Ext-LoopF (q) iff Y is an extended loop of F w.r.t. I.\nIf we replace LoopF (u) with Ext-LoopF (u) in (23), the formula is equivalent to SM[F ], as the following theorem states.\nTheorem 3 For any rectified sentence F , the following sentences are equivalent to each other:\n(a) SM[F ];\n(b) F ∧ ∀u((u ≤ p) ∧Nonempty(u)→ ¬NSESF (u));\n(c) F ∧ ∀u((u ≤ p) ∧ Ext-LoopF (u)→ ¬NSESF (u)).\nIn the following example we use the following fact to simplify the formulas.\nProposition 5 For any negative formula F , formula\nNSESF (u)↔ F\nis logically valid.\nExample 2 (continued) Consider program (7) from Example 2:\np(x)← q(x) q(y)← p(y) p(z)← not r(z).\nLet F be the FOL-representation of the program:\n∀x ( q(x)→ p(x) ) ∧ ∀y ( p(y)→ q(y) ) ∧ ∀z ( ¬r(z)→ p(z) ) .\n1. SM[F ] is equivalent to\nF ∧ ¬∃u1u2u3((u1, u2, u3) < (p, q, r))∧ ∀x(u2(x)→ u1(x)) ∧ ∀y(u1(y)→ u2(y)) ∧ ∀z(¬r(z)→ u1(z)))."
    }, {
      "heading" : "2. Formula in Theorem 3 (b):",
      "text" : "F ∧ ∀u(u ≤ p ∧Nonempty(u)→ ¬NSESF (u))\nis equivalent to\nF ∧ ∀u1u2u3((u1, u2, u3) ≤ (p, q, r) ∧ (∃x u1(x) ∨ ∃x u2(x) ∨ ∃x u3(x)) → ¬(∀x[q(x) ∧ ¬u2(x)→ p(x) ∧ ¬u1(x)]\n∧∀y[p(y) ∧ ¬u1(y)→ q(y) ∧ ¬u2(y)] ∧∀z[¬r(z)→ p(z) ∧ ¬u1(z)])).\n(27)\n3. Formula in Theorem 3 (c): Similar to (27) except that\n∃xu1(x) ∨ ∃xu2(x) ∨ ∃xu3(x)\nin (27) is replaced with Ext-LoopF (u), which is\nLoopF (u) ∨ [(∃xu1(x) ∨ ∃xu2(x) ∨ ∃xu3(x)) ∧ ∀v1v2v3(((v1, v2, v3) ≤ (u1, u2, u3)) ∧ LoopF (v)\n→ (∃x(v1(x) ∧ u2(x) ∧ ¬v2(x)) ∨ ∃y(v2(y) ∧ u1(y) ∧ ¬v1(y))))],\nwhere LoopF (u) is\n(∃xu1(x) ∨ ∃xu2(x) ∨ ∃xu3(x)) ∧ ∀v1v2v3(((∃x v1(x) ∨ ∃x v2(x) ∨ ∃x v3(x)) ∧ (v1, v2, v3) < (u1, u2, u3)) → (∃x(v1(x) ∧ u2(x) ∧ ¬v2(x)) ∨ ∃y(v2(y) ∧ u1(y) ∧ ¬v1(y)))).\nThe proof of Theorem 2 follows from Theorem 3 using the following lemma.\nLemma 3 Let F be a rectified sentence of a signature σ (possibly containing function constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is bounded w.r.t. I,\nI |= ∃u(u ≤ p ∧ Ext-LoopF (u) ∧NSESF (u))\niff there is a finite loop Y of F w.r.t. I such that I |= (∧ Y ∧NESF (Y ) ) ."
    }, {
      "heading" : "5. Representing First-Order Stable Model Semantics by First-Order",
      "text" : "Loop Formulas\nWe noted in the previous section that if a sentence is bounded w.r.t. a model, then loop formulas can be used to check the stability of the model. In this section, we provide a few syntactic counterparts of the boundedness condition."
    }, {
      "heading" : "5.1 Bounded Formulas",
      "text" : "We say that a rectified formula F is bounded if every infinite path in the first-order dependency graph of F visits only finitely many vertices. If F is bounded, then, clearly, every loop of F is finite. Again, the definition is extended to a non-rectified formula by first rewriting it as a rectified formula. It also applies to a program by referring to its FOL-representation.\nOne might wonder if the syntactic notion of boundedness ensures the semantic notion of boundedness: that is, if a formula is bounded, then it is bounded w.r.t. any interpretation. However, the following example tells us that this is not the case in general.\nExample 7 Consider the FOL-representation F of the following program\np(a)← q(x) q(x)← p(b), (28)\nand an interpretation I whose universe |I| is the set of all nonnegative integers, aI = bI = 0, pI = {0} and qI = |I|. Formula (28) is bounded according to the above definition, but not bounded w.r.t. I: the dependency graph of F w.r.t. I contains an infinite path such as\n〈p(0 ), q(1 ), p(0 ), q(2 ), . . . 〉."
    }, {
      "heading" : "5.1.1 Bounded Formulas and Clark’s Equational Theory",
      "text" : "On the other hand, such a relationship holds if the interpretation satisfies Clark’s equational theory (1978). Clark’s equational theory of a signature σ, denoted by CETσ, is the union of the universal closures of the following formulas\nf(x1, . . . , xm) 6= g(y1, . . . , yn), (29)\nfor all pairs of distinct function constants f , g,\nf(x1, . . . , xn) = f(y1, . . . , yn)→ (x1 = y1 ∧ . . . ∧ xn = yn), (30)\nfor all function constants f of arity > 0, and\nt 6= x, (31)\nwhere t is any term which contains the variable x.\nProposition 6 If a rectified formula F of a signature σ is bounded, then F is bounded w.r.t. any interpretation of σ that satisfies CETσ.\nThe following lemma relates loops and loop formulas of different notions of dependency graphs.\nProposition 7 For any rectified sentence F of a signature σ and for any interpretation I of σ that satisfies CETσ, I is a model of\n{LFF (Y ) | Y is a finite first-order loop of F}\niff I is a model of {LFF (Y ) | Y is a finite loop of F w.r.t. I}.\nThe following theorem follows from Theorem 2, Proposition 6 and Proposition 7.\nTheorem 4 Let F be a rectified sentence of a signature σ (possibly containing function constants of positive arity), and let I be an interpretation of σ that satisfies F and CETσ. If F is bounded, then the following conditions are equivalent to each other:\n(a) I |= SM[F ];\n(b) for every nonempty finite set Y of atoms of σ(F ), I satisfies LFF (Y );\n(c) for every finite first-order loop Y of F , I satisfies LFF (Y ).\nProof. By Proposition 6, if F is bounded then F is bounded w.r.t. any interpretation that satisfies CETσ. Then the equivalence between (a) and (b) follows from the equivalence between (a) and (b) of Theorem 2. The equivalence between (a) and (c) follows from the equivalence between (a) and (c) of Theorem 2 and by Proposition 7.\nAs every Herbrand interpretation of σ satisfies CETσ, Theorem 4 applies to Herbrand interpretations as a special case.\nThe theorem also applies to logic programs, since they can be viewed as a special case of formulas. For example, consider the following program, which is bounded.\np(f(x))← q(x) q(x)← p(x), r(x) p(a) r(a) r(f(a)).\n(32)\nThe set {p(a), p(f(a)), p(f(f(a))), q(a), q(f(a)), r(a), r(f(a))} is an answer set of (32). In accordance with Theorem 4, it is also the Herbrand interpretation of the signature obtained from the program that satisfies the FOL-representation of (32) and the loop formulas, which are the universal closures of\np(z)→ (q(x) ∧ z = f(x)) ∨ z = a q(z)→ p(z) ∧ r(z) r(z)→ z = a ∨ z = f(a).\nConsider another example program by Bonatti (2004), where a, . . . , z, nil are object constants.\nletter(a) . . . letter(z) atomic([x])← letter(x) atomic([x|y])← letter(x), atomic(y).\n(33)\nThe expression [x|y] is a list whose head is x and whose tail is y, which stands for a function cons(x, y). The expression [x] stands for cons(x, nil) where nil is a special symbol for\nthe empty list. This program is bounded. The only answer set of the program is the only Herbrand interpretation of the FOL-representation of (33) and the universal closures of\nletter(u)→ u = a ∨ . . . ∨ u = z atomic(u)→ ∃v (letter(v) ∧ u = cons(v, nil))\n∨ ∃xy (letter(x) ∧ atomic(y) ∧ y 6= u ∧ u = cons(x, y)).\nIn fact, the definitions of standard list processing predicates, such as member, append, and reverse (Bonatti, 2004, Figure 1) are bounded, so they can be represented by first-order formulas on Herbrand interpretations.12\nWe say that a formula F is atomic-tight if the first-order dependency graph of F has no infinite paths. Every tight sentence is atomic-tight, but not vice versa. For example, the FOL-representations of programs (32) and (33) are atomic-tight, but are not tight. Similar to Proposition 6, if F is atomic-tight, then F is atomic-tight w.r.t. any interpretation that satisfies CETσ, so that the following statement is derived from Corollary 3.\nCorollary 5 Let F be a rectified sentence of a signature σ (possibly containing function constants of positive arity), and let I be an interpretation of σ that satisfies F and CETσ. If F is atomic-tight, then I satisfies SM[F ] iff I satisfies SLF[F ].\nThe statement of Corollary 5 is restricted to interpretations that satisfy CETσ. Indeed, the statement becomes wrong if this restriction is dropped. For example, program (28) in Example 7 is atomic-tight, but the non-stable model considered there satisfies all loop formulas, including those of singleton loops."
    }, {
      "heading" : "5.1.2 Bounded Formulas and Normal Form",
      "text" : "Normal form is another syntactic condition that can be imposed so that the syntactic notion of boundedness ensures the semantic notion of boundedness. We say that a formula is in normal form if every strictly positive occurrence of an atom is of the form p(x), where x is a list of distinct variables. It is clear that every formula can be turned into normal form using equality.\nProposition 8 If a rectified formula F in normal form is bounded, then F is bounded w.r.t. any interpretation.\nProposition 9 If a rectified sentence F in normal form is bounded, then for any interpretation I, I is a model of\n{LFF (Y ) | Y is a finite first-order loop of F}\niff I is a model of\n{LFF (Y ) | Y is a finite loop of F w.r.t. I}.\nThe following theorem follows from Theorem 2, Proposition 8 and Proposition 9.\n12. They actually satisfy a stronger condition called “finitely recursive” (Bonatti, 2004). See Section 8 for more details.\nTheorem 5 Let F be a rectified sentence in normal form (possibly containing function constants of positive arity). If F is bounded, then the following formulas are equivalent to each other:\n(a) SM[F ];\n(b) {F} ∪ {LFF (Y ) | Y is a nonempty finite set of atoms of σ(F )};\n(c) {F} ∪ {LFF (Y ) | Y is a finite first-order loop of F}.\nProof. By Proposition 8, if F is bounded then F is bounded w.r.t. any interpretation I. Then the equivalence between (a) and (b) follows from the equivalence between (a) and (b) of Theorem 2. The equivalence between (a) and (c) follows from the equivalence between (a) and (c) of Theorem 2 and by Proposition 9.\nConsider a program in normal form\np(x)← x = a, q(a) q(y)← p(b) (34)\nand an interpretation I such that |I| = {1}, aI = bI = 1 and pI = qI = {1}. This interpretation does not satisfy Clark’s equational theory, and is not a stable model. In accordance with Theorem 5, I does not satisfy the loop formula of the loop {p(b), q(a)}, which is\np(b) ∧ q(a)→ (b = a ∧ q(a) ∧ a 6= a) ∨ (p(b) ∧ b 6= b).\nOn the other hand, consider another program in non-normal form that has the same stable models as (34):\np(a)← q(a) q(y)← p(b) (35)\nProgram (35) has a finite complete set of loops, {{p(z)}, {q(z)}}; their loop formulas are the universal closures of\np(z)→ z = a ∧ q(a) q(z)→ p(b)\nand I satisfies all loop formulas. This example illustrates the role of normal form assumption in Theorem 5 (in place of Clark’s equational theory in Theorem 4).\nNote that a normal form conversion may turn a bounded sentence into a non-bounded sentence. For instance, the normal form of the bounded program (32) is\np(y)← y = f(x), q(x) q(x)← p(x), r(x) p(x)← x = a r(x)← x = a r(x)← x = f(a),\n(36)\nwhich is not bounded. Unlike in Corollary 5, if a program is in normal form, atomic-tightness is not more general than tightness. It is not difficult to check that a program in normal form is atomictight iff it is tight."
    }, {
      "heading" : "5.1.3 Decidability of Boundedness and Finite Complete Set of Loops",
      "text" : "In general, checking whether F is bounded is not decidable, but it becomes decidable if F contains no function constants of positive arity. The same is the case for checking whether F is atomic-tight.\nProposition 10 For any rectified sentence F (allowing function constants of positive arity),\n(a) checking whether F is bounded is not decidable;\n(b) checking whether F is atomic-tight is not decidable.\nIf F contains no function constants of positive arity,\n(c) checking whether F is bounded is decidable;\n(d) checking whether F is atomic-tight is decidable.\nThe proof of Proposition 10 (c) is based on the following fact and the straightforward extension of Theorem 2 by Chen et al. (2006) to first-order formulas, which asserts that checking if F has a finite complete set of loops is decidable.\nProposition 11 For any rectified formula F that contains no function constants of positive arity, F is bounded iff F has a finite complete set of loops.\nNote that Proposition 11 does not hold if F is allowed to contain function constants of positive arity. For instance,\np(x)← p(f(x))\nis not bounded, but has a finite complete set of loops {{p(x)}}. The following corollary follows from Theorem 4 and Proposition 11.\nCorollary 6 Let F be a rectified sentence of a signature σ that has no function constants of positive arity, and let I be an interpretation of σ that satisfies F and CETσ. If F has a finite complete set of loops, then conditions (a), (b), and (c) of Theorem 4 are equivalent to each other.\nThe following corollary follows from Theorem 5 and Proposition 11.\nCorollary 7 Let F be a rectified sentence in normal form that has no function constants of positive arity. If F has a finite complete set of loops, formulas in (a), (b), and (c) of Theorem 5 are equivalent to each other."
    }, {
      "heading" : "5.2 Semi-Safe Formulas",
      "text" : "Semi-safety is another decidable syntactic condition that ensures that SM[F ] can be expressed by first-order sentences.\nWe assume that there are no function constants of positive arity. According to Lee, Lifschitz, and Palla (2009), a semi-safe sentence has the “small predicate property”: the relation represented by any of its predicate constants p can hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F . We will show that any semi-safe sentence under the stable model semantics can be turned into a sentence in first-order logic.\nFirst, we review the notion of semi-safety by Lee et al. (2009).13 As a preliminary step, we assign to every formula F a set RV(F ) of its restricted variables as follows:\n• For an atomic formula F ,\n– if F is an equality between two variables, then RV(F ) = ∅; – otherwise, RV(F ) is the set of all variables occurring in F ;\n• RV(G ∧H) = RV(G) ∪ RV(H);\n• RV(G ∨H) = RV(G) ∩ RV(H);\n• RV(G→ H) = ∅;\n• RV(QvG) = RV(G) \\ {v} where Q ∈ {∀,∃}.\nWe say that a variable x is restricted in F if x ∈ RV(F ). A rectified formula F is semisafe if every strictly positive occurrence of every variable x belongs to a subformula G→ H where x is restricted in G.\nIf a sentence has no strictly positive occurrence of a variable, then it is obviously semisafe. The FOL-representation of a disjunctive program is semi-safe if, for each rule (10) of the program, every variable occurring in the head of the rule occurs in B as well.\nExample 8 The FOL-representation of (8) is not semi-safe. Formula\np(a) ∧ q(b) ∧ ∀xy((p(x) ∨ q(y))→ p(y))\nis not semi-safe, while\np(a) ∧ q(b) ∧ ∀xy((p(x) ∧ q(y))→ p(y)) (37)\nis semi-safe.\nFor any finite set c of object constants, inc(x) stands for the formula∨ c∈c x = c.\n13. The definition here is slightly more general in that it does not refer to prenex form. Instead we require a formula to be rectified.\nThe small predicate property can be expressed by the conjunction of the sentences ∀v1, . . . , vn ( p(v1, . . . , vn)→ ∧ i=1,...,n inc(vi) )\nfor all predicate constants p occurring in F , where v1, . . . , vn are distinct variables. We denote this conjunction of the sentences by SPPc. By c(F ) we denote the set of all object constants occurring in F .\nProposition 12 (Lee et al., 2009) For any semi-safe sentence F , formula SM[F ] entails SPPc(F ).\nFor example, for the semi-safe sentence (37), SM[(37)] entails ∀x ( p(x)→ (x = a ∨ x = b)) ∧ ∀x(q(x)→ (x = a ∨ x = b) ) . (38)\nThe following proposition tells us that for a semi-safe sentence F , formula SM[F ] can be equivalently rewritten as a first-order sentence.\nTheorem 6 Let F be a rectified sentence that has no function constants of positive arity. If F is semi-safe, then SM[F ] is equivalent to the conjunction of F , SPPc(F ) and a finite number of first-order loop formulas.\nProof. If F is semi-safe, then SM[F ] entails SPPc(F ). So it is sufficient to prove that under the assumption SPPc(F ), SM[F ] is equivalent to the conjunction of F and a finite number of first-order loop formulas. It follows from I |= SPPc(F ) that F is bounded w.r.t. I. Since every finite loop of F w.r.t. I can be represented by a finite set of atoms whose terms are object variables, it follows from Theorem 2 that I satisfies SM[F ] iff I satisfies the loop formulas of those sets.\nFor example, SM[(37)] is equivalent to the conjunction of F , (38) and the universal closures of\np(z) → z = a ∨ (p(x) ∧ q(z) ∧ z 6= x) q(z) → z = b\nNote that the condition on a finite complete set of loops in Corollaries 6 and 7, and the condition on semi-safety in Theorem 6 do not entail each other. For instance, formula (37) is semi-safe, but has no finite complete set of first-order loops, while ∃x p(x) has a finite complete set of loops {{p(x)}}, but it is not semi-safe. Also program Π1 in Section 1 has a finite complete set of loops, but it is not semi-safe due to w in the fourth rule."
    }, {
      "heading" : "6. Programs with Explicit Quantifiers",
      "text" : "In the following we extend the syntax of a logic program by allowing explicit quantifiers. A rule with quantifiers is of the form\nH ← G, (39)\nwhere G and H are first-order formulas such that every occurrence of every implication in G and H belongs to a negative formula. A program with quantifiers is a finite set of rules\nwith quantifiers. Program Π1 in Section 1 is an example. The semantics of such a program is defined by identifying the program with its FOL-representation under the stable model semantics. By restricting the syntax of a program like the one above, in comparison with the syntax of an arbitrary formula, we are able to write a more succinct loop formulas, as we show below.\nLet F be a formula and Y a finite set of atoms. By FY we denote the formula obtained from F by replacing every occurrence of every atom p(t) in F that does not belong to a negative formula with p(t) ∧ ∧ p(t′)∈Y t 6= t′. Let Π be a program with quantifiers. Given a finite set Y of atoms of σ(Π), we first rename variables in Π so that no variables in Π occur in Y . We define the formula QES Π(Y ) (“External Support Formula for Programs with Quantifiers”) to be the disjunction of\n∃z(GY ∧ ¬HY ) (40)\nfor every rule (39) such that H contains a strictly positive occurrence of a predicate constant that occurs in Y , and z is the list of all free variables in the rule that do not occur in Y .\nThe loop formula of Y for Π is the universal closure of∧ Y → QES Π(Y ). (41)\nThe following proposition tells us that (41) is equivalent to (12) when the notions are applied to a program with explicit quantifiers. It also shows that (41) is a generalization of the definition of a loop formula for a disjunctive program.\nProposition 13 Let Π be a program with quantifiers, F the FOL-representation of Π, and Y a finite set of atoms. Under the assumption Π, formula QES Π(Y ) is equivalent to ¬NESF (Y ). If Π is a disjunctive program in normal form, then QES Π(Y ) is also equivalent to ES Π(Y ) under the assumption Π.\nNote that the size of (41) for each Y is polynomial to the size of the given program. This is not the case when we apply (12) to the FOL-representation of the program, due to the expansion of NES for nested implications. On the other hand, the syntactic condition imposed on the rule with quantifiers avoids such an exponential blow up, as the following lemma tells us.\nLemma 4 Let F be a formula such that every occurrence of an implication in F belongs to a negative formula and let Y be a set of atoms. NESF (Y ) is equivalent to FY .\nProof. By induction on F .\nExample 2 (continued) First-Order Loop Formula when Π is understood as an extended program (Using QESΠ(Y )) : Under the assumption Π,\n• LF Π(Y1) is equivalent to the universal closure of\np(u)→ (∃x(q(x) ∧ ¬(p(x) ∧ x 6= u)) ∨ ∃z(¬r(z) ∧ ¬(p(z) ∧ z 6= u))).\n• LF Π(Y2) is equivalent to the universal closure of\nq(u)→ ∃y(p(y) ∧ ¬(q(y) ∧ y 6= u)).\n• LF Π(Y3) is equivalent to the universal closure of\nr(u)→ ⊥.\n• LF Π(Y4) is equivalent to the universal closure of\n(p(u) ∧ q(u))→ (∃x((q(x) ∧ x 6= u) ∧ ¬(p(x) ∧ x 6= u)) ∨ ∃y((p(y) ∧ y 6= u) ∧ ¬(q(y) ∧ y 6= u)) ∨ ∃z(¬r(z) ∧ ¬(p(z) ∧ z 6= u))).\nA finite set Γ of sentences entails a sentence F under the stable model semantics (symbolically, Γ |=SM F ), if every stable model of Γ satisfies F .\nIf SM[F ] can be reduced to a first-order sentence, as described in Theorem 5 and Theorem 6, then\nΓ |=SM F iff Γ ∪∆ |= F,\nwhere ∆ is the set of first-order loop formulas required (and possibly including SPPc(F ) when Theorem 6 is applied). This fact allows us to use first-order theorem provers to reason about query entailment under the stable model semantics.\nExample 9 Consider program Π1 in Section 1, which has the following finite complete set of loops: {Man(u)}, {Spouse(u, v)}, {HasWife(u)}, {Married(u)}, {Accident(u, v)}, {Discount(u, v)}, and {HasWife(u),Married(u)}. Their loop formulas for Π1∪Π2∪Π3 are equivalent to the universal closure of\nMan(u)→ ¬ ( Man(John) ∧ John 6= u ) ; Spouse(u, v)→ ¬ ( ∃y ( Spouse(John, y) ∧ (John, y) 6= (u, v) )) ; HasWife(u)→ ∃x ( ∃y Spouse(x, y) ∧ ¬(HasWife(x) ∧ x 6= u)\n) ∨ ∃x ( Man(x) ∧Married(x) ∧ ¬(HasWife(x) ∧ x 6= u) ) ;\nMarried(u)→ ∃x ( Man(x) ∧HasWife(x) ∧ ¬(Married(x) ∧ x 6= u) ) ;\nAccident(u, v)→ ⊥;\nDiscount(u, v)→ ∃x ( Married(x) ∧ ¬∃zAccident(x, z) ∧ ¬(∃w(Discount(x,w) ∧ (x,w) 6= (u, v))) ) ;\nMarried(u) ∧HasWife(u)→ ∃x ( ∃y Spouse(x, y) ∧ ¬(HasWife(x) ∧ (x 6= u)) ) ∨ ∃x ( Man(x) ∧Married(x) ∧ x 6= u ∧ ¬(HasWife(x) ∧ x 6= u)\n) ∨ ∃x ( Man(x) ∧HasWife(x) ∧ x 6= u ∧ ¬(Married(x) ∧ x 6= u) ) .\nThese loop formulas, conjoined with the FOL-representation of Π1 ∪ Π2 ∪ Π3, entail under first-order logic each of ∃x Married(x) and ∀xy(Discount(x, y) → x = John). We verified the answers using a first-order theorem prover Vampire 14."
    }, {
      "heading" : "7. Extension to Allow Extensional Predicates",
      "text" : "The definition of a stable model in the journal paper by Ferraris et al. (2011), reviewed in Section 2, is more general than the definition in their conference paper (Ferraris et al., 2007) in that it allows us to distinguish between intensional and non-intensional (a.k.a. extensional) predicates. Similar to Datalog, intensional (output) predicates are characterized in terms of extensional (input) predicates. For instance, consider Example 9 again, but now assume that Man and Spouse are non-intensional. Π1∪Π2∪Π3 still entails ∃xyDiscount(x, y) but no longer entails ∀xy(Discount(x, y)→ x = John) because there may be a person other than John who has a spouse.\nThe results in the earlier sections can be extended to this general semantics in view of Proposition 14 below, which characterizes SM[F ; p] in terms of SM[F ]. By pr(F ) we denote the list of all predicate constants occurring in F ; by Choice(p) we denote the conjunction of “choice formulas” ∀x(p(x) ∨ ¬p(x)) for all predicate constants p in p, where x is a list of distinct object variables; by False(p) we denote the conjunction of ∀x¬p(x) for all predicate constants p in p. We sometimes identify a list with the corresponding set when there is no confusion.\nProposition 14 For any list p of predicate constants, formula SM[F ; p] is equivalent to\nSM[F ∧ Choice(pr(F )\\p) ∧ False(p\\pr(F ))] (42)\nand to\nSM[F¬¬ ∧ Choice(pr(F )\\p) ∧ False(p\\pr(F ))], (43)\nwhere F¬¬ is obtained from F by replacing every atom of the form q(t) in F such that q does not belong to p by ¬¬q(t).\nThis proposition allows us to extend the results established for SM[F ] to SM[F ; p]. For instance, Theorem 3 can be extended to SM[F ; p] by first rewriting it into the form SM[G], where G is\nF¬¬ ∧ Choice(pr(F )\\p) ∧ False(p\\pr(F )). (44)\nIn the next three corollaries, σ is a signature, F is a rectified sentence of σ (possibly containing function constants of positive arity), p is any finite list of predicate constants from σ, and G is (44).\nThe first corollary follows from Theorem 2 and Proposition 14.\nCorollary 8 For any interpretation I of σ that satisfies F , if G is bounded w.r.t. I, then the following conditions are equivalent to each other:\n(a) I |= SM[F ; p];\n14. http://www.vampire.fm .\n(b) for every nonempty finite set Y of atoms formed from predicate constants in p and object names for |I|, I satisfies LFF (Y );\n(c) for every finite loop Y of G w.r.t. I whose predicate constants are contained in p, I satisfies LFF (Y ).\nThe next corollary follows from Theorem 4 and Proposition 14.\nCorollary 9 If G is bounded, then, for any interpretation I of σ that satisfies F and CETσ, the following conditions are equivalent to each other:\n(a) I |= SM[F ; p];\n(b) for every nonempty finite set Y of atoms of σ(G) whose predicate constants are contained in p, I satisfies LFF (Y );\n(c) for every finite first-order loop Y of G whose predicate constants are contained in p, I satisfies LFF (Y ).\nThe last corollary follows from Theorem 5 and Proposition 14.\nCorollary 10 If G is in normal form and is bounded, then the following formulas are equivalent to each other:\n(a) SM[F ; p];\n(b) {F} ∪ {LFF (Y ) | Y is a nonempty finite set of atoms of σ(G) whose predicate constants are contained in p};\n(c) {F} ∪ {LFF (Y ) | Y is a finite first-order loop of G whose predicate constants are contained in p}.\nExample 10 Consider Example 9 again, assuming that Man and Spouse are extensional. Let F be the FOL-presentation of Π1 ∪ Π2 ∪ Π3 and let G be the formula (44). The loops of G are the same as the loops of F . The loop formulas remain the same as before except for the following loop formulas of Man(u) and Spouse(u, v):\nMan(u)→ ¬ ( Man(John) ∧ John 6= u ) ∨ ∃x¬ ( (Man(x) ∧ x 6= u) ∨ ¬Man(x) ) ; Spouse(u, v)→ ¬ ( ∃y ( Spouse(John, y) ∧ (John, y) 6= (u, v) )) ∨\n∃xy ¬ ( (Spouse(x, y) ∧ (x, y) 6= (u, v)) ∨ ¬Spouse(x, y) ) .\nThese two formulas are tautologies. As a result, the loop formulas of all loops, conjoined with G, entail ∃xyDiscount(x, y), but no longer entail ∀xy (Discount(x, y)→ x = John).\nIn general, there are no loops of G that contain both intensional and extensional predicates. Also every loop of G that contains an extensional predicate is a singleton, and the loop formula of such a loop is a tautology.\nCorollary 3 is extended to allow extensional predicates as in the following. By SLF[F ; p], we denote\n{LFF ({p(x)}) | p is a predicate constant in p, and x is a list of distinct object variables whose length is the same as the arity of p}.\nWe say that a formula F is p-atomic-tight w.r.t. I if every infinite path in the dependency graph of F w.r.t. I whose vertices are satisfied by I contains an atom whose predicate constant is not in p.\nCorollary 11 Let F be a rectified sentence (possibly containing function constants of positive arity), and let I be a model of F . If F is p-atomic-tight w.r.t. I, then I satisfies SM[F ; p] iff I satisfies SLF[F ; p].\nThe definition of semi-safety is extended to distinguish between intensional and nonintensional predicates as follows. Let F be a formula that has no function constants of positive arity. To every first-order formula F we assign a set RVp(F ) of restricted variables relative to p as follows.\n• For an atomic formula F (including equality and ⊥),\n– if F is an equality between two variables, or is an atom whose predicate constant is not in p, then RVp(F ) = ∅;\n– otherwise, RVp(F ) is the set of all variables occurring in F ;\n• RVp(G ∧H) = RVp(G) ∪ RVp(H);\n• RVp(G ∨H) = RVp(G) ∩RVp(H);\n• RVp(G→ H) = ∅.\n• RVp(QvG) = RVp(G) \\ {v} where Q ∈ {∀, ∃}.\nWe say that a variable x is p-restricted in F if x ∈ RVp(F ). A rectified formula F is semi-safe relative to p if every strictly positive occurrence of every variable x belongs to a subformula G→ H, where x is p-restricted in G.\nThe small predicate property is generalized as follows. Formula SPPpc is the conjunction of the sentences ∀v1, . . . , vn ( p(v1, . . . , vn)→ ∧ i=1,...,n inc(vi) )\nfor all predicate constants p in p, where v1, . . . , vn are distinct variables.\nProposition 15 (Lee et al., 2009) For any semi-safe sentence F relative to p, formula SM[F ; p] entails SPPpc(F ).\nThe following proposition tells us that for a semi-safe sentence F , formula SM[F ; p] can be equivalently rewritten as a first-order sentence.\nTheorem 7 Let F be a rectified sentence that has no function constants of positive arity. If F is semi-safe relative to p, then SM[F ; p] is equivalent to the conjunction of F , SPPpc(F ) and a finite number of first-order loop formulas.\nProof. Let F be a sentence of the signature σ. If F is semi-safe relative to p, then SM[F ; p] entails SPPpc(F ), so it is sufficient to prove that under the assumption SPP p c(F ), SM[F ; p] is equivalent to the conjunction of F and a finite number of first-order loop formulas. By Proposition 14, SM[F ; p] is equivalent to SM[G], where G is (44). Consider any interpretation I of σ that satisfies G and SPPpc(F ). Note that the dependency graph of G w.r.t. I contains no outgoing edges from a vertex whose predicate constant does not belong to p. Together with the fact that I |= SPPpc(F ), we conclude that each path in the dependency graph whose vertices are satisfied by I visits only finitely many vertices. Consequently, G is bounded w.r.t. I. Since every finite loop of G w.r.t. I can be represented by a finite set of atoms whose terms are object variables, it follows from Theorem 2 that I satisfies SM[G] iff I satisfies the loop formulas of those sets."
    }, {
      "heading" : "8. Related Work",
      "text" : "The notion of a bounded program is related to the notion of a finitely recursive program studied by Bonatti (2004), where a different definition of a dependency graph was considered. The atom dependency graph of a nondisjunctive ground program defined by Bonatti is a directed graph such that the vertices are the set of ground atoms, and the edges go from the atom in the head to atoms in the body of every rule, including those in the negative body. A program is called finitely recursive if, for every atom, there are only finitely many atoms reachable from it in the atom dependency graph. It is clear that every finitely recursive program is bounded, but the converse does not hold. For instance, the program\np(x)← not p(f(x))\nis bounded, but is not finitely recursive because there are infinite paths that involve negative edges. Also the program\np(a)← q(f(x))\nis bounded, but is not finitely recursive because infinitely many atoms q(f(a)), q(f(f(a))), . . . can be reached from p(a) in the atom dependency graph. Like bounded programs, checking finitely recursive programs is undecidable in the presence of function constants of positive arity.\nLin and Wang (2008) extended answer set semantics with functions by extending the definition of a reduct, and also provided loop formulas for such programs. We can provide an alternative account of their results by considering the notions there as special cases of the definitions presented in this paper. For simplicity, we assume non-sorted languages.15 Essentially, they restricted attention to a special case of non-Herbrand interpretations such that object constants form the universe, and ground terms other than object constants are mapped to object constants. According to Lin and Wang, an LW-program P consists of\n15. Lin and Wang (2008) consider essentially many-sorted languages. The result of this section can be extended to that case by considering many-sorted SM (Kim, Lee, & Palla, 2009).\ntype definitions and a set of rules. Type definitions introduce the domains for a many-sorted signature consisting of some object constants, and includes the evaluation of each function symbol of positive arity that maps a list of object constants to an object constant. Since we assume non-sorted languages, we consider only a single domain (universe). We say that an interpretation I is a P -interpretation if the universe is the set of object constants specified by P , object constants are evaluated to itself, and ground terms other than object constants are evaluated conforming to the type definitions of P .\nProposition 16 Let P be an LW-program and let F be the FOL-representation of the set of rules in P . The following conditions are equivalent to each other:\n(a) I is an answer set of P according to Lin and Wang (2008);\n(b) I is a P -interpretation that satisfies SM[F ];\n(c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.r.t. I.\nThe equivalence between (b) and (c) follows from Proposition 2 since the universe is finite. The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c).\nSince the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program Π that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order definability on finite structures by turning programs into modified completion using new predicates to record levels. Chen, Lin, Zhang, and Zhou (2011) present a condition called “loop-separable,” which is more refined than finite complete set of loops under which the finite answer sets of a program can be captured by first-order sentences. However, like the condition of finite complete set of loops, this condition is disjoint with semi-safety. The following program is semi-safe but not loop-separable:\np(x)← p(y), q(x, y).\nHowever, all this work is limited to nondisjunctive programs that contain no function constants of positive arity. Our work is not limited to finite structures, and considers function constants of positive arity as well. Nonetheless the above papers on first-order definability are closely related to our work and more insights would be gained from the relationship between them.\nThe use of first-order theorem provers for the stable model semantics was already investigated by Sabuncu and Alpaslan (2007), but their results are limited in several ways. They\nconsidered nondisjunctive logic programs with “trivial” loops only, in which case the stable model semantics is equivalent to the completion semantics. They also restricted attention to Herbrand models."
    }, {
      "heading" : "9. Conclusion",
      "text" : "This paper puts first-order loop formulas in the context of first-order reasoning and studies how they are related to first-order stable model semantics. The similarities and mismatches found in this paper provide useful insights into first-order reasoning with stable models. Future work is to find further restrictions that make first-order stable model reasoning decidable and computable in an efficient manner, like the conditions imposed in “finitary” programs (Bonatti, 2004). Recently, the first-order stable model semantics was shown to be used as a unifying nonmonotonic logic for integrating rules and ontologies (de Bruijn, Pearce, Polleres, & Valverde, 2010; Lee & Palla, 2011), in which ontology predicates are identified with extensional predicates. Based on the studied relationship between first-order stable model semantics and first-order loop formulas, one may find further restrictions that are tailored to the hybrid knowledge bases for efficient computation."
    }, {
      "heading" : "Acknowledgments",
      "text" : "We are grateful to Joseph Babb, Michael Bartholomew, Piero Bonatti, Vladimir Lifschitz, and Ravi Palla for useful discussions, and to the anonymous referees for their useful comments. The authors were partially supported by the National Science Foundation under Grant IIS-0916116 and by the IARPA SCIL program."
    }, {
      "heading" : "Appendix A. Proofs",
      "text" : "The proofs are presented in the order of dependencies. Theorem 3 is the main theorem. The proof of Theorem 2 uses Theorem 3. The proofs of Theorems 4 and 5 follow from Theorem 2. The proof of Lemma 1 follows from Proposition 13.\nIn the following, unless otherwise noted, F is a rectified first-order sentence, p is the list of distinct predicate constants p1, . . . , pn occurring in F , symbols u, v are lists of distinct predicate variables of the same length as p, and symbols q, r are lists of distinct predicate names of the same length as p."
    }, {
      "heading" : "A.1 Proof of Theorem 3",
      "text" : "Theorem 3 For any rectified sentence F , the following sentences are equivalent to each other:\n(a) SM[F ];\n(b) F ∧ ∀u((u ≤ p) ∧Nonempty(u)→ ¬NSESF (u));\n(c) F ∧ ∀u((u ≤ p) ∧ Ext-LoopF (u)→ ¬NSESF (u)).\nThe notation that we use in the proof involves predicate expressions (Lifschitz, 1994, Section 3.1) of the form\nλxF (x), (45)\nwhere F (x) is a formula. If e is (45) and G(p) is a formula containing a predicate constant p of the same arity as the length of x then G(e) stands for the result of replacing each atomic part of the form p(t) in G(p) with F (t), after renaming the bound variables in G(p) in the usual way, if necessary. For instance, if G(p) is p(a) ∨ p(b) then G(λy(x = y)) is x = a ∨ x = b. Substituting a tuple e of predicate expressions for a tuple p of predicate constants is defined in a similar way.\nLemma 5 Let v be the list of λyi(pi(y i) ∧ ¬ui(yi)). The following formulas are logically valid:\n• u ≤ p→ (F ∗(u)↔ NSESF (v));\n• u ≤ p→ (F ∗(v)↔ NSESF (u)).\nProof. By induction."
    }, {
      "heading" : "A.1.1 Proof of Equivalence between (a) and (b) of Theorem 3",
      "text" : "It is sufficient to show that\n∃u(u < p ∧ F ∗(u))\nis equivalent to\n∃v(v ≤ p ∧Nonempty(v) ∧NSESF (v)).\nFrom left to right: Take u such that u<p∧F ∗(u). Let v be the list of λyi(pi(yi) ∧ ¬ui(yi)).\n• Clearly, v ≤ p holds.\n• From u < p, it follows that there are x and i such that pi(x) ∧ ¬ui(x), from which∨ i ∃xivi(xi) follows, so that Nonempty(v) follows.\n• By Lemma 5, NSESF (v) follows from u < p and F ∗(u).\nFrom right to left: Take v such that v ≤ p∧Nonempty(v)∧NSESF (v). Let u be the list of λyi(pi(y i) ∧ ¬vi(yi)).\n• Clearly, u ≤ p holds. Moreover ¬(u = p) holds. Indeed, if u = p, then ∀xi¬vi(xi) follows, which contradicts the assumption Nonempty(v). Consequently, u < p follows.\n• By Lemma 5, F ∗(u) follows from v ≤ p and NSESF (v)."
    }, {
      "heading" : "A.1.2 Proof of Proposition 3",
      "text" : "Lemma 6 Let I be an interpretation of σ that contains σ(F ), and let q, r be lists of predicate names corresponding to p. Let Z and Y be sets of atoms in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Y iff I |= qi(ξ )\nand\npi(ξ ) ∈ Z iff I |= ri(ξ ),\nwhere ξ is a list of object names. Then\nI |= r ≤ q ∧ EF (r,q)\niff Z is a subset of Y and there is an edge from an atom in Z to an atom in Y \\ Z in the dependency graph of F w.r.t. I.\nProof. From left to right: Assume I |= r ≤ q ∧ EF (r,q). The fact that Z is a subset of Y follows from the assumption that I |= r ≤ q and the construction of Z and Y . Since\nI |= ∨\n(pi(t),pj(t ′)) : pi(t) depends on pj(t′)\nin a rule of F\n∃z(ri(t) ∧ qj(t′) ∧ ¬rj(t′)),\nwhere z is the list of all object variables in t and t′, there is a substitution θ that maps object variables in t and t′ to object names such that\nI |= ∨\n(pi(t),pj(t ′)) : pi(t) depends on pj(t′)\nin a rule of F\nri(tθ) ∧ qj(t′θ) ∧ ¬rj(t′θ).\nConsequently, there are atoms pi(t), pj(t ′) such that pi(t) depends on pj(t ′) in a rule of F and I |= ri(tθ)∧qj(t′θ)∧¬rj(t′θ). From I |= ri(tθ) and the construction of Z, it follows that pi(((tθ)\nI) ) belongs to Z. Also from I |= qj(t′θ)∧¬rj(t′θ), it follows that that pj(((t′θ)I) ) belongs to Y \\Z. Therefore, there is an edge from an atom in Z to an atom in Y \\Z in the dependency graph of F w.r.t. I.\nFrom right to left: Assume that Z is a subset of Y and there is an edge from an atom pi(ξ ) in Z to an atom pj(η ) in Y \\ Z in the dependency graph of F w.r.t. I. Clearly, I |= r ≤ q. From the assumption that pi(ξ\n) ∈ Z, pj(η ) ∈ Y \\Z and the construction of Y and Z, it follows that I |= ri(ξ ) ∧ qj(η ) ∧ ¬rj(η ). From the definition of the dependency graph w.r.t. I, it follows that there are pi(t), pj(t ′) such that pi(t) depends on pj(t ′) in a rule of F with a substitution θ that maps object variables in t and t′ to object names such that (tθ)I = ξ and (t′θ)I = η.\nConsequently, I |= ∨\n(pi(t),pj(t ′)) : pi(t) depends on pj(t′)\nin a rule of F\nri(tθ) ∧ qj(t′θ) ∧ ¬rj(t′θ),\nwhich is equivalent to saying that I |= ∨\n(pi(t),pj(t ′)) : pi(t) depends on pj(t′)\nin a rule of F\n∃z(ri(t) ∧ qj(t′) ∧ ¬rj(t′)),\nwhere z is the list of all variables in t and t′.\nLemma 7 A graph (V,E) is strongly connected iff, for any nonempty proper subset U of V , there is an edge from U to V \\ U .\nProof. Follows from the definition of a strongly connected graph.\nProposition 3 Let q be a list of predicate names corresponding to p, and let Y be a set of atoms in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Y iff I |= qi(ξ ),\nwhere ξ is a list of object names. Then I |= LoopF (q) iff Y is a loop of F w.r.t. I.\nProof. From left to right: Assume that I |= LoopF (q). From I |= Nonempty(q), it follows that Y is nonempty.\nTake any nonempty proper subset Z of Y . Let r be the list of predicate names such that\nI |= ri(ξ ) iff pi(ξ ) ∈ Z.\nIt is clear that I |= Nonempty(r) ∧ r < q.\nConsequently, from I |= LoopF (q), it follows that I |= EF (r,q). By Lemma 6, there is an edge from an atom in Z to an atom in Y \\ Z. Consequently, by Lemma 7, Y induces a strongly connected subgraph and thus a loop of F w.r.t. I.\nFrom right to left: Let Y be loop of F w.r.t. I and q a list of predicate names such that\nI |= qi(ξ ) iff pi(ξ ) ∈ Y.\nSince Y is nonempty, I |= Nonempty(q). Consider any list of predicate names r such that\nI |= Nonempty(r) ∧ r < q.\nLet Z be a set of vertices in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Z iff I |= ri(ξ ).\nClearly, Z is a nonempty proper subset of Y . Since Y induces a strongly connected subgraph, by Lemma 7, there is an edge from an atom in Z to an atom in Y \\ Z. Consequently by Lemma 6, I |= EF (r,q)."
    }, {
      "heading" : "A.1.3 Proof of Proposition 4",
      "text" : "Proposition 4 Let q be a list of predicate names corresponding to p, and let Y be a set of atoms in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Y iff I |= qi(ξ ),\nwhere ξ is a list of object names. Then\nI |= Nonempty(q) ∧ ∀v((v ≤ q) ∧ LoopF (v)→ EF (v,q))\niff Y is an unbounded set of F w.r.t. I.\nProof. From left to right: Assume\nI |= Nonempty(q) ∧ ∀v(v ≤ q ∧ LoopF (v)→ EF (v,q)). (46)\nSince I |= Nonempty(q), it is clear that Y is nonempty. Take any subset Z of Y that is a loop of F w.r.t. I. Let r be a list of predicate names such that\nI |= ri(ξ ) iff pi(ξ ) ∈ Z.\nSince Z is a subset of Y , it is clear that I |= r ≤ q. Since Z is a loop of F w.r.t. I, by Proposition 3, I |= LoopF (r). Consequently, from (46) it follows that I |= EF (r,q). By Lemma 6, there is an edge from an atom in Z to an atom in Y \\ Z. Therefore, Y is an unbounded set of F w.r.t. I.\nFrom right to left: Let Y be an unbounded set of F w.r.t. I. Since Y is nonempty, it is clear that I |= Nonempty(q).\nTake any list of predicate names r such that I |= r ≤ q ∧ LoopF (r). Let Z be a set of vertices in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Z iff I |= ri(ξ ).\nBy Proposition 3, Z is a loop of F w.r.t. I. It is clear that Z is a subset of Y . Since Y is an unbounded set of F w.r.t. I, there is an edge from Z to Y \\Z. Consequently by Lemma 6, I |= EF (r,q)."
    }, {
      "heading" : "A.1.4 Proof of Proposition 5",
      "text" : "Proposition 5 For any negative formula F , formula\nNSESF (u)↔ F\nis logically valid.\nProof. The proof follows immediately from the following two lemmas, which can be proved by induction.\nLemma 8 For any formula F , NSESF (u)→ F\nis logically valid.\nLemma 9 Let F be a formula, and let SF be the set of pi(t) that has a strictly positive occurrence in F . Formula\nF ∧ ∧\npi(t)∈SF\n∀z¬vi(t)→ NSESF (v) (47)\nis logically valid, where z is the tuple of variables in t that are not free in F ."
    }, {
      "heading" : "A.1.5 Proof of Equivalence between (b) and (c) of Theorem 3",
      "text" : "Lemma 10 Let F be a rectified formula, let S+F be the set of all atoms pi(t) that have a positive occurrence in F that does not belong to a negative formula, and let S−F be the set of all atoms pi(t) that have a negative occurrence in F that does not belong to a negative formula.16 The following formulas are logically valid, where z is the list of all variables in t that are not free in F .\n(a) (v ≤ u) ∧ ∧ pi(t)∈S+F ∀z(ui(t)→vi(t)) ∧NSESF (v)→NSESF (u);\n(b) (v ≤ u) ∧ ∧ pi(t)∈S−F ∀z(ui(t)→vi(t)) ∧NSESF (u)→NSESF (v).\nProof. Both parts are proved simultaneously by induction on F .\nCase 1: F is an atom pi(t).\nPart (a): NSESF (v) entails NSESF (u) under the assumption∧ pi(t)∈S+F ∀z(ui(t)→vi(t)).\nPart (b): NSESF (u) entails NSESF (v) under the assumption v ≤ u.\nCase 2: F is ⊥ or an equality. It is clear since NSESF (v) and NSESF (u) are the same as F .\nCase 3: F is G ∧H or G ∨H. Follows from I.H.\nCase 4: F is G→ H. Part (a): Assume\n(v ≤ u) ∧ ∧\npi(t)∈S+F\n∀z(ui(t)→ vi(t)). (48)\nWe need to show that\n(NSESG(v)→ NSESH(v)) ∧ (G→ H)\n16. Note that we distinguish between formula being negative and an occurrence being negative. See at the end of Section 2.\nentails (NSESG(u)→ NSESH(u)) ∧ (G→ H). Note that ∧ pi(t)∈S−G ∀z(ui(t)→ vi(t)) and ∧ pi(t)∈S+H ∀z(ui(t)→ vi(t))\nare entailed by formula (48). By I.H., NSESG(u) entails NSESG(v) and NSESH(v) entails NSESH(u).\nPart (b): Similar to Part (a).\nCase 5: F is ∀xG Part (a): Assume\n(v ≤ u) ∧ ∧\npi(t)∈S+F\n∀z(ui(t)→vi(t)) ∧ ∀xNSESG(v).\nFrom the assumption NSESG(v), G follows by Lemma 8. Also∧ pi(t)∈S+G ∀z′(ui(t)→vi(t))\nfollows, where z′ is the list of all variables in t that are not free in G, so that by I.H. on G, NSESG(u) holds from the assumption. Since x is not free in the assumption, ∀xNSESG(u) holds as well.\nPart (b): Similar to Part (a).\nCase 6: F is ∃x G. Part (a): Assume\n(v ≤ u) ∧ ∧\npi(t)∈S+F\n∀z(ui(t)→vi(t)) ∧ ∃xNSESG(v). (49)\nTake x such that\n(v ≤ u) ∧ ∧\npi(t)∈S+F\n∀z(ui(t)→vi(t)) ∧NSESG(v). (50)\nFrom NSESG(v), by Lemma 8, G follows. Also∧ pi(t)∈S+G ∀z′(ui(t)→vi(t))\nfollows, where z′ is the list of all variables in t that are not free in G. By I.H. on G, NSESG(u) holds under the assumption (50). Consequently, ∃xNSESG(u) holds from the\nsame assumption. Since x is not free in (49), we conclude that ∃xNSESG(u) holds from the assumption (49).\nPart (b): Similar to Part (a).\nLemma 11 For any rectified formula F ,\n(v ≤ u) ∧ ¬EF (v,u) ∧NSESF (u)→ NSESF (v)\nis logically valid.\nProof. By induction on F .\nCase 1: F is an atom pi(t). NSESF (u) entails NSESF (v) under the assumption v ≤ u.\nCase 2: F is ⊥ or equality. It is clear since NSESF (v) and NSESF (u) are the same as F .\nCase 3: F is G ∧H or G ∨H. Follows from I.H.\nCase 4: F is G→ H. Assume\n(v ≤ u) ∧ ¬EF (v,u) ∧NSESF (u)\nand NSESG(v). From NSESF (u), by Lemma 8, we conclude G → H. From NSESG(v), by Lemma 8, G follows, and consequently H.\nAssume ¬NSESH(v) for the sake of contradiction. By Lemma 9, fromH and ¬NSESH(v), it follows that ∨\npi(t) : pi(t) occurs strictly positively in H\n∃xvi(t) (51)\n, where x is the list of variables in t that are not free in H.\nSince F is rectified, the variables in F can be partitioned into three sets: the list of variables x that are not free in H, the list of variables y that are not free in G, and the rest. Note that ¬EF (v,u) entails∧\n(pi(t),pj(t ′)) : pi(t) depends on pj(t′) in a rule G→H in F pi(t) occurs in H,pj(t ′) occurs in G\n( ∃xvi(t)→ ∀y(uj(t′)→ vj(t′)) ) , (52)\nwhere x is the list of all variables in t that are not free in H, and y is the list of all variables in t′ that are not free in G. From (51) and (52), we conclude∧\npj(t′) : pj(t′) occurs positively and not in a negative subformula of G\n∀y(uj(t′)→ vj(t′)).\nFrom this, together with the assumption (v ≤ u) and NSESG(v), by Lemma 10 (a), NSESG(u) follows. Thus NSESH(u) follows from NSESF (u) and NSESG(u). Since ¬EF (v,u) entails ¬EH(v,u), by I.H. on H, NSESH(v) follows, which contradicts the assumption.\nCase 5: F is ∀xG or ∃xG. Follows from I.H.\nLemma 12\nNonempty(u)→ ∃v(v ≤ u ∧ Ext-LoopF (v) ∧ ¬EF (v,u))\nis logically valid.\nProof. Take any list q of predicate names, and any interpretation I that satisfies Nonempty(q). Let Y be a set of vertices in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Y iff I |= qi(ξ ).\nConsider the subgraph G of the dependency graph of F w.r.t. I that is induced by Y . If Y is an unbounded set w.r.t. I, by Proposition 4, I |= Ext-LoopF (q). So\nI |= q ≤ q ∧ Ext-LoopF (q) ∧ ¬EF (q,q).\nOtherwise, consider the graph G′ that is obtained from G by collapsing strongly connected components of G, i.e., the vertices of G′ are the strongly connected components of G and G′ has an edge from V to V ′ if G has an edge from a vertex in V to a vertex in V ′. Since we assumed that Y is not an unbounded set w.r.t. I, there exists a vertex Z in G′ that has no outgoing edges. Consider the list of predicate names r such that\nI |= ri(ξ ) iff pi(ξ ) ∈ Z.\nIt is clear that I |= r ≤ q. By Proposition 3, I |= LoopF (r) thus I |= Ext-LoopF (r). Since there is no edge from Z to Y \\ Z, by Lemma 6, I |= ¬EF (r,q). Consequently, the claim follows."
    }, {
      "heading" : "Proof of Equivalence Between (b) and (c) of Theorem 3",
      "text" : "From (b) to (c): Clear from that the formula Ext-LoopF (u) → Nonempty(u) is logically valid.\nFrom (c) to (b): Assume\nF ∧ ∀v(v ≤ p ∧ Ext-LoopF (v)→ ¬NSESF (v)).\nTake any u such that u ≤ p ∧ Nonempty(u). By Lemma 12, it follows from Nonempty(u) that there exists v such that v ≤ u ∧ Ext-LoopF (v) ∧ ¬EF (v,u). It is clear that v ≤ p follows from v ≤ u and u ≤ p. It follows from the assumption that ¬NSESF (v). Then by Lemma 11, ¬NSESF (u) follows from v ≤ u and ¬EF (v,u)."
    }, {
      "heading" : "A.2 Proof of Theorem 2",
      "text" : "Lemma 3 Let F be a rectified sentence of a signature σ (possibly containing function constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is bounded w.r.t. I,\nI |= ∃u(u ≤ p ∧ Ext-LoopF (u) ∧NSESF (u))\niff there is a finite loop Y of F w.r.t. I such that I |= (∧ Y ∧NESF (Y ) ) .\nProof. From left to right: Assume\nI |= q ≤ p ∧ Ext-LoopF (q) ∧NSESF (q)\nfor some list of predicate names q. Consider Y to be the set of vertices in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Y iff I |= qi(ξ ).\nSince I |= Ext-LoopF (q), by Proposition 3 and Proposition 4, it follows that Y is an extended loop of F w.r.t. I. Since I |= qi(ξ ) for all pi(ξ ) ∈ Y and I |= q ≤ p, it follows that I satisfies every atom in Y . Together with the assumption that F is bounded w.r.t. I, this implies that set Y is finite. Since I |= NSESF (q) and Y is finite, by Lemma 2, it follows that I |= NESF (Y ).\nFrom right to left: Consider any finite loop Y of F w.r.t. I. Assume I |= ∧ Y ∧NESF (Y ).\nLet q be a list of predicate names such that\nI |= qi(ξ ) iff pi(ξ ) ∈ Y.\n• I |= q ≤ p follows from the construction of q and I |= ∧ Y .\n• Since Y is a loop of F w.r.t. I, by Proposition 3, I |= LoopF (q), and consequently, I |= Ext-LoopF (q).\n• From I |= NESF (Y ), by Lemma 2, I |= NSESF (q).\nConsequently, I |= ∃u(u ≤ p ∧ Ext-LoopF (u) ∧NSESF (u)).\nTheorem 2 Let F be a rectified sentence of a signature σ (possibly containing function constants of positive arity), and let I be an interpretation of σ that satisfies F . If F is bounded w.r.t. I, then the following conditions are equivalent to each other:\n(a) I satisfies SM[F ];\n(b) for every nonempty finite set Y of atoms formed from predicate constants in σ(F ) and object names for |I|, I satisfies LFF (Y );\n(c) for every finite loop Y of F w.r.t. I, I satisfies LFF (Y ).\nProof. Between (a) and (c): By Theorem 3 and Lemma 3.\nBetween (b) and (c):\n• From (b) to (c): Clear.\n• From (c) to (b): Assume that I satisfies LFF (L) for every finite loop L of F w.r.t I. Consider any nonempty finite set Y of atoms formed from predicate constants in σ(F ) and object names such that I |= ∧ Y . Let q be a list of predicate names such that\nI |= qi(ξ ) iff pi(ξ ) ∈ Y.\nSince Y is nonempty, it is clear that Nonempty(q) follows. In view of Lemma 12, there is a list of predicate names r such that\nI |= r ≤ q ∧ Ext-LoopF (r) ∧ ¬EF (r,q). (53)\nConsider Z to be the set of vertices in the dependency graph of F w.r.t. I such that\npi(ξ ) ∈ Z iff I |= ri(ξ ).\nSince I |= Ext-LoopF (r), by Proposition 3 and Proposition 4, Z is an extended loop of F w.r.t. I. Clearly, I |= ∧ Z since Z ⊆ Y and I |= ∧ Y . Since F is bounded w.r.t. I, and Z is satisfied by I, it follows that Z is a finite loop of F w.r.t. I. Since I |= r ≤ q ∧ ¬EF (r,q), Z is a subset of Y and, by Lemma 6, there is no edge from Z to Y \\ Z in the dependency graph of F w.r.t. I. Since I |= LFF (Z), we conclude that I |= ¬NESF (Z), and by Lemma 2, I |= ¬NSESF (r). From (53) and that I |= ¬NSESF (r), by Lemma 11, we have I |= ¬NSESF (q). By Lemma 2 again, I |= ¬NESF (Y ). Consequently, I |= LFF (Y )."
    }, {
      "heading" : "A.3 Proof of Proposition 6",
      "text" : "Proposition 6 If a rectified formula F of a signature σ is bounded, then F is bounded w.r.t. any interpretation of σ that satisfies CETσ.\nLemma 13 For any terms t1 and t2 of signature σ, any interpretation I that satisfies CETσ, and any substitution θ from object variables in t1 and t2 to object names such that (t1θ) I = (t2θ) I , Robinson’s unification algorithm (Robinson, 1965), when applied to t1 and t2, returns a most general unifier (mgu) γ of t1 and t2 such that\n(a) t1γ = t2γ, and\n(b) for every variable x in t1 or t2, (xγθ) I = (xθ)I .\nProof. From the assumptions, by Lemma 5.1 from the work of Kunen (1987), t1 and t2 are unifiable, in which case Robinson’s algorithm returns a mgu for t1 and t2 that maps variables occurring in t1 and t2 into terms. Given this, part (b) can be proven by induction.\nThe proof of Proposition 6 follows from the following lemma.\nLemma 14 Let F be a rectified sentence of a signature σ, and let I be an interpretation of σ that satisfies CETσ. For any path\n〈p1(ξ 1), p2(ξ 2), . . . , pk(ξ k), pk+1(ξ k+1)〉 (54)\nin the dependency graph of F w.r.t I, there is a path\n〈p1(u1), p2(u2), . . . , pk(uk), pk+1(uk+1)〉\nin the first-order dependency graph of F with a substitution θ that maps object variables in ui to object names such that (uiθ) I = ξi for all i.\nProof. Each edge (pi(ξ i ), pi+1(ξ i+1)) in (54) is obtained from a pair of atoms (pi(ti), pi+1(t ′ i)) and a substitution θi such that pi(ti) depends on pi+1(t ′ i) in a rule of F , and\n(t1θ1) I = ξ1, (t ′ iθi) I = (ti+1θi+1) I = ξi+1(1 ≤ i < k), (t′kθk)I = ξk+1. (55)\nFor simplicity we assume that each pair (pi(ti), pi+1(t ′ i)) considered above has no common variables with another pair by first renaming variables. This allows us to use one substitution θ = θ1 . . . θk in place of individual θi in the rest of the proof.\nWe will show by induction that, for each j where j ∈ {1 . . . k}, there are substitutions σji (1 ≤ i ≤ j) from variables in ti and t′i to terms such that\n(a) 〈p1(t1)σj1, p2(t2)σ j 2, . . . , pj(tj)σ j j , pj+1(t ′ j)σ j j 〉 is a path in the first-order dependency\ngraph of F , and\n(b) (tiσ j i θ) I = ξi for all 1 ≤ i ≤ j, and (t′jσ j jθ) I = ξj+1.\nWhen j = 1, we take σji to be an identity substitution. Clearly, conditions (a) and (b) are satisfied.\nOtherwise, by I.H. we assume that, for some j in {1, . . . , k−1}, there are substitutions σj1, . . . , σ j j such that conditions (a) and (b) are satisfied. We will prove that there are substitutions σj+1i (1 ≤ i ≤ j+1) from variables in ti and t′i to terms such that\n(a’) 〈p1(t1)σj+11 , p2(t2)σ j+1 2 , . . . , pj+1(tj+1)σ j+1 j+1, pj+2(t ′ j+1)σ j+1 j+1〉 is a path in the first-order de-\npendency graph of F , and\n(b’) (tiσ j+1 i θ) I = ξi for all 1 ≤ i ≤ j+1, and (t′j+1σ j+1 j+1θ) I = ξj+2.\nFrom I.H., we have (t′jσ j jθ) I = ξj+1 and from (55) we have (tj+1θ) I = ξj+1. By Lemma 13\nthere is a substitution γ from variables in t′jσ j j or tj+1 to terms such that t ′ jσ j jγ = tj+1γ and for any variable x in t′jσ j j or tj+1,\n(xγθ)I = (xθ)I . (56)\nWe define σj+1i as\n• σji γ when 1 ≤ i ≤ j and\n• γ when i = j+1.\nIt is easy to check that condition (a’) is satisfied. To check that condition (b’) is satisfied, consider any variable x in the set\n{t1σj1, t2σ j 2, . . . , tjσ j j , t ′ jσ j j , tj+1, t ′ j+1}. (57)\nIf x is in t′jσ j j or tj+1, by (56), (xγθ) I = (xθ)I . Otherwise, since γ does not change the variables that are not in t′jσ j j or tj+1, (xγθ) I = (xθ)I . Consequently, for any variable x in (57), we get (xγθ)I = (xθ)I . It remains to check the following.\n• For 1 ≤ i ≤ j, (tiσj+1i θ)I = (tiσ j i γθ) I = (tiσ j i θ) I . The last one is equal to ξi by I.H.\n• (tj+1σj+1j+1θ)I = (tj+1γθ)I = (tj+1θ)I . The last one is equal to ξj+1 by (55).\n• (t′j+1σ j+1 j+1θ) I = (t′j+1γθ) I = (t′j+1θ) I . The last one is equal to ξj+2 by (55)."
    }, {
      "heading" : "A.4 Proof of Proposition 7",
      "text" : "Proposition 7 For any rectified sentence F of a signature σ and for any interpretation I of σ that satisfies CETσ, I is a model of\n{LFF (Y ) | Y is a finite first-order loop of F}\niff I is a model of {LFF (Y ) | Y is a finite loop of F w.r.t. I}.\nThe proof follows immediately from the following fact and Lemma 15.\nFact 1 Let F be a rectified sentence of a signature σ, and let I be an interpretation of σ. For any first-order loop Y of F and any substitution θ that maps variables in Y to object names, Y ′ = {pi(ξ ) | pi(t) ∈ Y θ, tI = ξ} is a loop of F w.r.t. I.\nLemma 15 Let F be a rectified sentence of a signature σ, and let I be an interpretation of σ. If I satisfies CETσ, then, for any finite loop Y\n′ of F w.r.t. I, there is a finite loop Y of F with a substitution θ that maps variables in Y to object names such that Y ′ = {pi(ξ ) | pi(t) ∈ Y, (tθ)I = ξ}.\nProof. Without loss of generality, consider a path\n〈p1(ξ 1), p2(ξ 2), . . . , pk(ξ k), p1(ξ 1)〉\n(k ≥ 1) in the dependency graph of F w.r.t. I that consists of the vertices in Y ′. Since I |= CETσ, by Lemma 14, there is a path\n〈p1(u1), p2(u2), . . . , pk(uk), p1(uk+1)〉\nin the first-order dependency graph of F with a substitution θ that maps variables in ui to object names such that (uiθ)\nI = ξi for all 1 ≤ i ≤ k, and (uk+1θ)I = ξ1. Since (uk+1θ) I = (u1θ) I , by Lemma 13, there is a unifier γ for uk+1 and u1 such that, for any variable x in uk+1 or u1, (xγθ) I = (xθ)I . Consequently,\n{p1(u1γ), p2(u2γ), . . . , pk(ukγ)}\ninduces a finite strongly connected subgraph such that (uiγθ) I = (uiθ) I = ξi."
    }, {
      "heading" : "A.5 Proof of Proposition 8",
      "text" : "Proposition 8 If a rectified formula F in normal form is bounded, then F is bounded w.r.t. any interpretation.\nThe proof follows from the following lemma.\nLemma 16 Let F be a rectified sentence of a signature σ in normal form, and let I be an interpretation of σ. For any path\n〈p1(ξ 1), p2(ξ 2), . . . , pk(ξ k), pk+1(ξ k+1)〉\nin the dependency graph of F w.r.t I, there exists a path\n〈p1(u1), p2(u2), . . . , pk(uk), pk+1(uk+1)〉\nin the first-order dependency graph of F with a substitution θ that maps object variables in ui to object names such that (uiθ) I = ξi for all i, and u1 is a list of object variables.\nProof. The proof is similar to the proof of Lemma 14 except that we do not require that I satisfy CETσ. Instead, the existence of a unifier γ for t ′ jσ j j and tj+1 is ensured by the assumption on normal form that tj+1 is a list of variables and the assumption that t ′ jσ j j contains none of those variables (due to variable renaming)."
    }, {
      "heading" : "A.6 Proof of Proposition 9",
      "text" : "Proposition 9 If a rectified sentence F in normal form is bounded, then for any interpretation I, I is a model of\n{LFF (Y ) | Y is a finite first-order loop of F}\niff I is a model of {LFF (Y ) | Y is a finite loop of F w.r.t. I}.\nThe proof follows from Fact 1 and the following lemma.\nLemma 17 If a rectified sentence F in normal form is bounded, then for any finite loop Y ′ of F w.r.t. I, there is a finite loop Y of F with a substitution θ that maps variables in Y to object names such that Y ′ = {pi(ξ ) | pi(t) ∈ Y, (tθ)I = ξ}.\nProof. Let Y ′ be a finite loop of F w.r.t. I. Without loss of generality, there is a path\n〈p1(ξ 1), p2(ξ 2), . . . , pk(ξ k), p1(ξ 1)〉\n(k ≥ 1) in the dependency graph of F w.r.t. I that consists of the vertices in Y ′. Since F is in normal form, by Lemma 16, there are a path\n〈p1(u1), p2(u2), . . . , pk(uk), p1(uk+1)〉 (58)\nin the first-order dependency graph of F , where u1 consists of object variables only, and a substitution θ that maps variables in ui to object names such that (uiθ)\nI = ξi for all 1 ≤ i ≤ k, and (uk+1θ)I = ξ1. There are two cases to consider.\n• Case 1: There is a unifier γ for u1 and uk+1 that maps variables in u1 to terms in uk+1 so that u1γ = uk+1. It follows that, for any variable x in uk+1 or u1, (xγθ)\nI = (xθ)I . Consequently,\n{p1(u1γ), p2(u2γ), . . . , pk(ukγ)}\ninduces a finite strongly connected subgraph such that (uiγθ) I = (uiθ) I = ξi.\n• Case 2: There is no such unifier γ. Consider another path\n〈p1(v1), p2(v2), . . . , pk(vk), p1(vk+1)〉\nthat is obtained similar to (58) except that the variables in the path are disjoint from the variables in (58). Clearly, there is a unifier γ′ for uk+1 and v1 that maps the variables v1 to terms, so that\n〈p1(u1), p2(u2), . . . , pk(uk), p1(v1γ′), p2(v2γ′), . . . , pk(vkγ′)〉\nis another path in the first-order dependency graph of F . It is clear that using the same construction repeatedly, we can form an infinite path that visits infinitely many vertices in the first-order dependency graph. But this contradicts the assumption that F is bounded."
    }, {
      "heading" : "A.7 Proof of Proposition 11",
      "text" : "We will use the following lemma in this section and the next section, which extends Theorem 2 in the work of Chen et al. (2006) that provides a few equivalent conditions for a program to have a finite complete set of loops to a disjunctive program and a sentence.\nLemma 18 (Chen et al., 2006, Thm. 2) For any formula F that contains no function constants of positive arity, the following conditions are equivalent:\n(a) F has a finite complete set of loops.\n(b) There is a nonnegative integer N such that for every loop L of F , the number of variables in L is bounded by N .\n(c) For any loop L of F and any atom A1 and A2 in L, the variables occurring in A1 are identical to the variables occurring in A2.\n(d) For any loop L of Groundσ(F )∪{c1,c2}(F ) where c1, c2 are two new object constants, there are no two atoms A1 and A2 in L such that A1 mentions c1 but A2 does not or A1 mentions c2 but A2 does not.\nProposition 11 For any rectified formula F that contains no function constants of positive arity, F is bounded iff F has a finite complete set of loops.\nProof. From left to right: Assume that F is bounded. Then every loop of F is finite. It follows that there exists a nonnegative integer N such that the number of variables in any loop is bounded by N . By Lemma 18 (b), F has a finite complete set of loops.\nFrom right to left: Assume that F has a finite complete set of loops and, for the sake of contradiction, assume that it is not bounded. Without loss of generality, there is an infinite path 〈p1(t1)σ1, p2(t2)σ2, . . .〉 (59) in the first-order dependency graph of F that visits infinitely many vertices, where pi(ti) are atoms occurring in F and σi are substitutions.\nSince F is a finite string, it contains finitely many atoms. It follows that there is an atom pi(ti) occurring in F with arbitrarily many substitutions σ such that atoms pi(ti)σ are contained in (59). Without loss of generality, consider the path\n〈pi(ti)σi, pi+1(ti+1)σi+1, . . . , pi(ti)σk〉\nthat is contained in (59), where σk and σi agree on substituting object constants for variables in ti. Since tiσi and tiσk contain no function constant, there exists a substitution σ0 that maps variables in tiσk to terms in tiσi so that tiσkσ0 = tiσi. Consequently,\n{pi(xi)σiσ0, pi+1(xi+1)σi+1σ0, . . . , pi(xi)σkσ0}\nis a loop of F . Since the length of the path is arbitrarily large, there are arbitrarily many variables occurring in the loop. By Lemma 18 (b), it follows that F has no finite complete set of loops."
    }, {
      "heading" : "A.8 Proof of Proposition 10",
      "text" : "Proposition 10 For any rectified sentence F (allowing function constants of positive arity),\n(a) checking whether F is bounded is not decidable;\n(b) checking whether F is atomic-tight is not decidable.\nIf F contains no function constants of positive arity,\n(c) checking whether F is bounded is decidable;\n(d) checking whether F is atomic-tight is decidable."
    }, {
      "heading" : "A.8.1 Proof of Part (a) and (b)",
      "text" : "We show the proof of Part (a) first. The proof repeats, with minor modifications, the argument from the proof of Theorem 26 from the work of Bonatti (2004), which considers the following program ΠM to simulate deterministic Turing machines M.\nt(s, L, v, [V | R], C)← t(s′, [v′ | L], V,R,C+1) for all instr.〈s, v, v′, s′, right〉 t(s, L, v, [ ], C)← t(s′, [v′ | L], b, [ ], C+1) for all instr.〈s, v, v′, s′, right〉 t(s, [V | L], v, R,C)← t(s′, L, V, [v′ | R], C+1) for all instr.〈s, v, v′, s′, left〉 t(s, [ ], v, R,C)← t(s′, [ ], b, [v′ | R], C+1) for all instr.〈s, v, v′, s′, left〉 t(s, L, v,R,C) for all final states s.\nThe Halting problem can be reduced to the problem of checking bounded formulas. More precisely, we show that ΠM is bounded iff M terminates from every configuration.\nWe first establish the following facts:\n(i) for every non-terminating computation of M on input x, there is a corresponding infinite path in the first-order dependency graph of ΠM that visits infinitely many vertices;\n(ii) if there is an infinite path in the first-order dependency graph of ΠM, then there is an infinite path starting with a legal encoding of an input and corresponds to a non-terminating computation of M.\nFact (i) is immediate from the definition of ΠM: Note that the step counter (the last argument of t) ensures that the dependency graph is acyclic. Then, whenever M falls into a cycle, the dependency graph contains an infinite acyclic path that visits infinitely many vertices and hence the program is not bounded.\nFact (ii) can be proven as follows. Assume that there is an infinite path in the dependency graph. We observe that the first argument of every vertex in the path must be a legal state and the third argument of every vertex must be a legal tape value. Otherwise, there is no outgoing edge from the vertices in the dependency graph of ΠM. So only the second, fourth and fifth arguments can contain variables or illegal values which were obtained from substitutions from the variables L, R, V and C. In this case, we can easily find substitutions from these variables or illegal values to legal values and apply them uniformly along the path, so that we obtain another infinite path starting from the vertex that correctly encodes a configuration of M and thus M has a corresponding non-terminating computation.\nThe claim follows immediately from the two facts: if M does not terminate on some computation, then by (i), ΠM is unbounded. If ΠM is unbounded, then by (ii), M does not terminate.\nThe same proof works for Part (b) as well. This is because the step counter (the last argument of t) ensures that the dependency graph is acyclic. Consequently, every infinite path in the dependency graph visits infinitely many vertices, so that ΠM is atomic-tight iff ΠM is bounded."
    }, {
      "heading" : "A.8.2 Proof of Part (c)",
      "text" : "In view of the equivalence between (a) and (d) in Lemma 18, checking whether a formula F containing no function constants of positive arity has a finite complete set of loops can\nbe done by examining a finite number of loops from a finite dependency graph, which is decidable. By Proposition 11, it follows that checking whether F is bounded is decidable."
    }, {
      "heading" : "A.8.3 Proof of Part (d)",
      "text" : "For any sentence F that has no function constants of positive arity and any finite set c of object constants, Groundc(F ) is defined recursively. If F is an atomic formula thenGroundc(F ) is F . The function Groundc commutes with all propositional connectives; quantifiers turn into finite conjunctions and disjunctions over all object constants occurring in c.\nLemma 19 Let c be the set consisting of all object constants occurring in F , and possibly a new object constant if F contains no object constants. F has a non-trivial loop iff Groundc(F ) has a non-trivial loop.\nIn order to check whether F is atomic-tight, we first check whether F is bounded, which is decidable. If F is not bounded, then F is not atomic-tight. Otherwise, in view of Lemma 19, checking whether F is atomic-tight is the same as checking whether Groundc(F ) is atomic-tight. Since F contains no function constants of positive arity, the dependency graph of Groundc(F ) is finite. So it is decidable to check whether the dependency graph of Groundc(F ) has a non-trivial loop."
    }, {
      "heading" : "A.9 Proof of Proposition 13",
      "text" : "Lemma 20 Let F be a formula and Y a set of atoms. If no predicate constant occurring in Y occurs strictly positively in F , then NESF (Y ) is equivalent to F .\nProof. By induction.\nProposition 13 Let Π be a program with quantifiers, F the FOL-representation of Π, and Y a finite set of atoms. Under the assumption Π, formula QES Π(Y ) is equivalent to ¬NESF (Y ). If Π is a disjunctive program in normal form, then QES Π(Y ) is also equivalent to ES Π(Y ) under the assumption Π.\nProof. Between QES Π(Y ) and ¬NESF (Y ): ¬NESF (Y ) is\n¬ ∧\nH←G∈Π ∀x[(G→ H) ∧ (NESG(Y )→ NESH(Y ))]. (60)\nUnder the assumption F , formula (60) is equivalent to∨ H←G∈Π ∃x(NESG(Y ) ∧ ¬NESH(Y )). (61)\nIn view of Lemma 20, if H does not contain any strictly positive occurrence of a predicate constant that belongs to Y , NESH(Y ) is equivalent to H. Also, it follows from Lemma 2 and Lemma 8 that NESG(Y ) implies G. So NESG(Y )∧¬NESH(Y ) conflicts the assumption\nG → H when H does not contain any strictly positive occurrence of a predicate constant that belongs to Y . As a result, under the assumption F , formula (61) is equivalent to the disjunction of\n∃x(NESG(Y ) ∧ ¬NESH(Y )) (62)\nfor all rules H ← G, where H contains a strictly positive occurrence of a predicate constant that belongs to Y . Note that G and H are formulas such that every occurrence of an implication in G and H belongs to a negative formula. By Lemma 4, (62) is equivalent to QES Π(Y ).\nBetween QES Π(Y ) and ES Π(Y ): When Π is a disjunctive program, QES Π(Y ) is the disjunction of\n∃z ( B ∧N ∧ ∧ p(t)∈B p(t′)∈Y (t 6= t′) ∧ ¬ ( ∨ p(t)∈A (p(t) ∧ ∧ p(t′)∈Y t 6= t′) ))\n(63)\nover all rules (10) such that A contains a predicate constant that occurs in Y , where z is a list of variables in (10) but not in Y . On the other hand, ES Π(Y ) is the disjunction of\n∃z′ ( Bσ ∧Nσ ∧ ∧ p(t)∈Bσ p(t′)∈Y (t 6= t′) ∧ ¬ ( ∨ p(t)∈Aσ (p(t) ∧ ∧ p(t′)∈Y t 6= t′) ))\n(64)\nover all rules (10) such that A contains a predicate constant that occurs in Y and Aσ∩Y 6= ∅, where z′ is a list of variables in Aσ ← Bσ,Nσ but not in Y .\nIt is clear that (64) implies (63). To prove that (63) implies (64), assume\nB ∧N ∧ ∧\np(t)∈B p(t′)∈Y\n(t 6= t′) ∧ ¬ ( ∨ p(t)∈A (p(t) ∧ ∧ p(t′)∈Y t 6= t′) )\n(65)\nand consider two cases. If ∧ p(t′)∈Y t 6= t′ for all p(t) ∈ A, then (65) is equivalent to\nB ∧N ∧ ∧\np(t)∈B p(t′)∈Y\n(t 6= t′) ∧ ¬ ∨\np(t)∈A\np(t)\nwhich contradicts the assumption Π.\nOtherwise, there exists p(t) ∈ A and p(t′) ∈ Y such that t = t′. Since Π is in normal form, there exists σ that maps t to t′, so that Aσ ∩ Y 6= ∅. Consequently, (65) is equivalent to\nBσ ∧Nσ ∧ ∧\np(t)∈Bσ p(t′)∈Y\n(t 6= t′) ∧ ¬ ( ∨ p(t)∈Aσ (p(t) ∧ ∧ p(t′)∈Y t 6= t′) ) .\nThus the claim follows."
    }, {
      "heading" : "A.10 Proof of Proposition 16",
      "text" : "Proposition 16 Let P be an LW-program and let F be the FOL-representation of the set of rules in P . The following conditions are equivalent to each other:\n(a) I is an answer set of P according to Lin and Wang (2008);\n(b) I is a P -interpretation that satisfies SM[F ];\n(c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.r.t. I.\nGiven a program Π, Norm(Π) is a normal form of Π and Ground(Π) is a ground program obtained from Π as described by Lin and Wang (2008). The proof of Proposition 16 follows from the following lemma. We refer readers to the work of Lin and Wang for the definition of ES (·, ·, ·) defined there.\nLemma 21 For any program Π and any set Y of ground atoms, ESNorm(Π)(Y ) is equivalent to ∨ p(c)∈Y ES (p(c), Y,Ground(Π)).\nProof. By definition, ESNorm(Π)(Y ) is∨ p(x)←B,N,x=t is in Norm(Π)\nθ:p(x)θ∈Y\n∃z ( Bθ ∧Nθ ∧ xθ = tθ ∧ ∧ q(t)∈Bθ q(t′)∈Y (t 6= t′) ) , (66)\nwhere x is a list of distinct object variables, θ is a substitution that maps variables in x to object constants occurring in Y , and z is the list of all variables that occur in the rule p(x)θ ← Bθ,Nθ,xθ = tθ. (66) is equivalent to∨\np(t)←B,N∈Π p(c)∈Y\n∃z′ ( B ∧N ∧ t = c ∧ ∧ q(t)∈B q(t′)∈Y (t 6= t′) ) , (67)\nwhere z′ is the list of all variables that occur in the rule p(t) ← B,N . In turn, (67) is equivalent to ∨\np(d)←B′,N′∈Ground(Π) p(c)∈Y\n( B′ ∧N ′ ∧ d = c ∧ ∧ q(tg)∈B′ q(t′)∈Y (tg 6= t′) ) . (68)\nNote that when d does not cover c, there exists di ∈ d such that di mentions only constants and pre-interpreted functions and di can not be evaluated to ci independent of interpretations. In that case, d = c is equivalent to ⊥. Thus (68) is equivalent to∨\np(c)∈Y ∨ p(d)←B′,N′∈Ground(Π) p(d) can cover p(c) ( B′ ∧N ′ ∧ d = c ∧ ∧ q(tg)∈B′ q(t′)∈Y (tg 6= t′) ) , (69)\nwhich is essentially ∨ p(c)∈Y ES (p(c), Y,Ground(Π))."
    } ],
    "references" : [ {
      "title" : "Ordered completion for first-order logic programs on finite structures",
      "author" : [ "V. Asuncion", "F. Lin", "Y. Zhang", "Y. Zhou" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "Asuncion et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Asuncion et al\\.",
      "year" : 2010
    }, {
      "title" : "Reasoning with infinite stable models",
      "author" : [ "P.A. Bonatti" ],
      "venue" : "Artificial Intelligence, 156 (1), 75–111.",
      "citeRegEx" : "Bonatti,? 2004",
      "shortCiteRegEx" : "Bonatti",
      "year" : 2004
    }, {
      "title" : "First-order loop formulas for normal logic programs",
      "author" : [ "Y. Chen", "F. Lin", "Y. Wang", "M. Zhang" ],
      "venue" : "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),",
      "citeRegEx" : "Chen et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2006
    }, {
      "title" : "Loop-separable programs and their firstorder definability",
      "author" : [ "Y. Chen", "F. Lin", "Y. Zhang", "Y. Zhou" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Chen et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2011
    }, {
      "title" : "First-order indefinability of answer set programs on finite structures",
      "author" : [ "Y. Chen", "Y. Zhang", "Y. Zhou" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "Chen et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2010
    }, {
      "title" : "Negation as failure",
      "author" : [ "K. Clark" ],
      "venue" : "Gallaire, H., & Minker, J. (Eds.), Logic and Data Bases, pp. 293–322. Plenum Press, New York.",
      "citeRegEx" : "Clark,? 1978",
      "shortCiteRegEx" : "Clark",
      "year" : 1978
    }, {
      "title" : "A semantical framework for hybrid knowledge bases",
      "author" : [ "J. de Bruijn", "D. Pearce", "A. Polleres", "A. Valverde" ],
      "venue" : "Knowl. Inf. Syst.,",
      "citeRegEx" : "Bruijn et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Bruijn et al\\.",
      "year" : 2010
    }, {
      "title" : "A generalization of the Lin-Zhao theorem",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Ferraris et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Ferraris et al\\.",
      "year" : 2006
    }, {
      "title" : "A new perspective on stable models",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Ferraris et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Ferraris et al\\.",
      "year" : 2007
    }, {
      "title" : "Stable models and circumscription",
      "author" : [ "P. Ferraris", "J. Lee", "V. Lifschitz" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Ferraris et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Ferraris et al\\.",
      "year" : 2011
    }, {
      "title" : "Elementary sets for logic programs",
      "author" : [ "M. Gebser", "J. Lee", "Y. Lierler" ],
      "venue" : "In Proceedings of National Conference on Artificial Intelligence (AAAI),",
      "citeRegEx" : "Gebser et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2006
    }, {
      "title" : "On elementary loops of logic programs",
      "author" : [ "M. Gebser", "J. Lee", "Y. Lierler" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "Gebser et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2011
    }, {
      "title" : "Loops: Relevant or redundant",
      "author" : [ "M. Gebser", "T. Schaub" ],
      "venue" : "In Proceedings of the Eighth International Conference on Logic Programming and Nonmonotonic Reasoning",
      "citeRegEx" : "Gebser and Schaub,? \\Q2005\\E",
      "shortCiteRegEx" : "Gebser and Schaub",
      "year" : 2005
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Proceedings of International Logic Programming Conference and Symposium,",
      "citeRegEx" : "Gelfond and Lifschitz,? \\Q1988\\E",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "Circumscriptive event calculus as answer set programming",
      "author" : [ "Kim", "T.-W", "J. Lee", "R. Palla" ],
      "venue" : "In Proceedings of International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Kim et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kim et al\\.",
      "year" : 2009
    }, {
      "title" : "Negation in logic programming",
      "author" : [ "K. Kunen" ],
      "venue" : "The Journal of Logic Programming, 4 (4), 289 – 308.",
      "citeRegEx" : "Kunen,? 1987",
      "shortCiteRegEx" : "Kunen",
      "year" : 1987
    }, {
      "title" : "Nondefinite vs",
      "author" : [ "J. Lee" ],
      "venue" : "definite causal theories. In Proceedings 7th Int’l Conference on Logic Programming and Nonmonotonic Reasoning, pp. 141–153.",
      "citeRegEx" : "Lee,? 2004",
      "shortCiteRegEx" : "Lee",
      "year" : 2004
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "J. Lee" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI), pp. 503–508.",
      "citeRegEx" : "Lee,? 2005",
      "shortCiteRegEx" : "Lee",
      "year" : 2005
    }, {
      "title" : "Representing synonymity in causal logic and in logic programming",
      "author" : [ "J. Lee", "Y. Lierler", "V. Lifschitz", "F. Yang" ],
      "venue" : "In Proceedings of International Workshop on Nonmonotonic Reasoning (NMR). http://peace.eas.asu.edu/joolee/papers/syn.pdf",
      "citeRegEx" : "Lee et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2010
    }, {
      "title" : "Loop formulas for disjunctive logic programs",
      "author" : [ "J. Lee", "V. Lifschitz" ],
      "venue" : "In Proceedings of International Conference on Logic Programming (ICLP),",
      "citeRegEx" : "Lee and Lifschitz,? \\Q2003\\E",
      "shortCiteRegEx" : "Lee and Lifschitz",
      "year" : 2003
    }, {
      "title" : "Safe formulas in the general theory of stable models",
      "author" : [ "J. Lee", "V. Lifschitz", "R. Palla" ],
      "venue" : "Technical Report. http://peace.eas.asu.edu/joolee/papers/safety.pdf",
      "citeRegEx" : "Lee et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Lee et al\\.",
      "year" : 2009
    }, {
      "title" : "Loop formulas for circumscription",
      "author" : [ "J. Lee", "F. Lin" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Lee and Lin,? \\Q2006\\E",
      "shortCiteRegEx" : "Lee and Lin",
      "year" : 2006
    }, {
      "title" : "On loop formulas with variables",
      "author" : [ "J. Lee", "Y. Meng" ],
      "venue" : "In Proceedings of the International Conference on Knowledge Representation and Reasoning (KR),",
      "citeRegEx" : "Lee and Meng,? \\Q2008\\E",
      "shortCiteRegEx" : "Lee and Meng",
      "year" : 2008
    }, {
      "title" : "Integrating rules and ontologies in the first-order stable model semantics (preliminary report)",
      "author" : [ "J. Lee", "R. Palla" ],
      "venue" : "In Proceedings of International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR),",
      "citeRegEx" : "Lee and Palla,? \\Q2011\\E",
      "shortCiteRegEx" : "Lee and Palla",
      "year" : 2011
    }, {
      "title" : "Circumscription",
      "author" : [ "V. Lifschitz" ],
      "venue" : "Gabbay, D., Hogger, C., & Robinson, J. (Eds.), Handbook of Logic in AI and Logic Programming, Vol. 3, pp. 298–352. Oxford University Press.",
      "citeRegEx" : "Lifschitz,? 1994",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 1994
    }, {
      "title" : "Knowledge representation and classical logic",
      "author" : [ "V. Lifschitz", "L. Morgenstern", "D. Plaisted" ],
      "venue" : "Handbook of Knowledge Representation,",
      "citeRegEx" : "Lifschitz et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 2008
    }, {
      "title" : "A logic of knowledge and justified assumptions",
      "author" : [ "F. Lin", "Y. Shoham" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Lin and Shoham,? \\Q1992\\E",
      "shortCiteRegEx" : "Lin and Shoham",
      "year" : 1992
    }, {
      "title" : "Answer set programming with functions",
      "author" : [ "F. Lin", "Y. Wang" ],
      "venue" : "Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),",
      "citeRegEx" : "Lin and Wang,? \\Q2008\\E",
      "shortCiteRegEx" : "Lin and Wang",
      "year" : 2008
    }, {
      "title" : "ASSAT: Computing answer sets of a logic program by SAT solvers",
      "author" : [ "F. Lin", "Y. Zhao" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Lin and Zhao,? \\Q2004\\E",
      "shortCiteRegEx" : "Lin and Zhao",
      "year" : 2004
    }, {
      "title" : "From answer set logic programming to circumscription via logic of GK",
      "author" : [ "F. Lin", "Y. Zhou" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Lin and Zhou,? \\Q2011\\E",
      "shortCiteRegEx" : "Lin and Zhou",
      "year" : 2011
    }, {
      "title" : "Properties and applications of programs with monotone and convex constraints",
      "author" : [ "L. Liu", "M. Truszczynski" ],
      "venue" : "J. Artif. Intell. Res. (JAIR),",
      "citeRegEx" : "Liu and Truszczynski,? \\Q2006\\E",
      "shortCiteRegEx" : "Liu and Truszczynski",
      "year" : 2006
    }, {
      "title" : "Circumscription—a form of non-monotonic reasoning",
      "author" : [ "J. McCarthy" ],
      "venue" : "Artificial Intelligence, 13, 27–39,171–172.",
      "citeRegEx" : "McCarthy,? 1980",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1980
    }, {
      "title" : "Applications of circumscription to formalizing common sense knowledge",
      "author" : [ "J. McCarthy" ],
      "venue" : "Artificial Intelligence, 26 (3), 89–116.",
      "citeRegEx" : "McCarthy,? 1986",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1986
    }, {
      "title" : "A first order nonmonotonic extension of constructive logic",
      "author" : [ "D. Pearce", "A. Valverde" ],
      "venue" : "Studia Logica,",
      "citeRegEx" : "Pearce and Valverde,? \\Q2005\\E",
      "shortCiteRegEx" : "Pearce and Valverde",
      "year" : 2005
    }, {
      "title" : "A machine-oriented logic based on the resolution principle",
      "author" : [ "J.A. Robinson" ],
      "venue" : "J. ACM, 12, 23–41.",
      "citeRegEx" : "Robinson,? 1965",
      "shortCiteRegEx" : "Robinson",
      "year" : 1965
    }, {
      "title" : "Computing answer sets using model generation theorem provers",
      "author" : [ "O. Sabuncu", "F.N. Alpaslan" ],
      "venue" : null,
      "citeRegEx" : "Sabuncu and Alpaslan,? \\Q2007\\E",
      "shortCiteRegEx" : "Sabuncu and Alpaslan",
      "year" : 2007
    }, {
      "title" : "Loop formulas for logic programs with arbitrary constraint atoms",
      "author" : [ "You", "J.-H", "G. Liu" ],
      "venue" : "In Proceedings of the AAAI Conference on Artificial Intelligence (AAAI),",
      "citeRegEx" : "You et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "You et al\\.",
      "year" : 2008
    }, {
      "title" : "On the progression semantics and boundedness of answer set programs",
      "author" : [ "Y. Zhang", "Y. Zhou" ],
      "venue" : "In Proceedings of International Conference on Principles of Knowledge Representation and Reasoning (KR),",
      "citeRegEx" : "Zhang and Zhou,? \\Q2010\\E",
      "shortCiteRegEx" : "Zhang and Zhou",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 17,
      "context" : "Since the original invention of loop formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee, Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu & Truszczynski, 2006; You & Liu, 2008).",
      "startOffset" : 292,
      "endOffset" : 342
    }, {
      "referenceID" : 16,
      "context" : "The theorem has also been applied to other nonmonotonic formalisms, such as nonmonotonic causal theories (Lee, 2004) and McCarthy’s circumscription (Lee & Lin, 2006).",
      "startOffset" : 105,
      "endOffset" : 116
    }, {
      "referenceID" : 22,
      "context" : "According to the theorem on loop formulas (Lin & Zhao, 2004), the stable models of a logic program (Gelfond & Lifschitz, 1988) can be characterized as the models of the logic program that satisfy all its loop formulas. This idea has turned out to be widely applicable in relating the stable model semantics to propositional logic, and has resulted in an efficient method for computing answer sets using SAT solvers. Since the original invention of loop formulas for nondisjunctive logic programs by Lin and Zhao (2004), the theorem has been extended to more general classes of logic programs, such as disjunctive programs (Lee & Lifschitz, 2003), infinite programs and programs containing classical negation (Lee, 2005; Lee, Lierler, Lifschitz, & Yang, 2010), arbitrary propositional formulas under the stable model semantics (Ferraris, Lee, & Lifschitz, 2006), and programs containing aggregates (Liu & Truszczynski, 2006; You & Liu, 2008).",
      "startOffset" : 110,
      "endOffset" : 519
    }, {
      "referenceID" : 13,
      "context" : "The stable model semantics that does not involve grounding appeared a year later (Ferraris, Lee, & Lifschitz, 2007, 2011). The authors define the stable models of a firstorder sentence F as the models of the second-order sentence that is obtained by applying the “stable model operator” SM to F . The definition of SM is close to the definition of the circumscription operator CIRC (McCarthy, 1980, 1986). Under the first-order stable model semantics, logic programs are viewed as a special class of first-order theories. A similar definition of a stable model was given by Lin and Zhou (2011), via logic of knowledge and justified assumption (Lin & Shoham, 1992).",
      "startOffset" : 92,
      "endOffset" : 594
    }, {
      "referenceID" : 7,
      "context" : "The first-order stable model semantics is also closely related to quantified equilibrium logic (Pearce & Valverde, 2005), and indeed, Ferraris et al. (2011) showed that they are essentially equivalent.",
      "startOffset" : 134,
      "endOffset" : 157
    }, {
      "referenceID" : 2,
      "context" : "Section 3 reviews the theorem on first-order loop formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary first-order sentences, limiting attention to Herbrand stable models.",
      "startOffset" : 62,
      "endOffset" : 81
    }, {
      "referenceID" : 2,
      "context" : "Section 3 reviews the theorem on first-order loop formulas by Chen et al. (2006) and extends it to disjunctive programs and to arbitrary first-order sentences, limiting attention to Herbrand stable models. Section 4 extends these results to allow non-Herbrand stable models as well (possibly allowing functions) under a certain semantic condition, and compare the first-order stable model semantics with loop formulas by reformulating the former in terms of the latter. In Section 5, we present a series of syntactic conditions that imply the semantic condition in Section 4. Section 6 provides an extension of logic programs that contain explicit quantifiers and shows how query answering for such extended programs can sometimes be reduced to entailment checking in first-order logic via loop formulas. In Section 7, the results are further extended to distinguish between intensional and non-intensional predicates. Related work is described in Section 8, and long proofs are given in Appendix A. This article is an extended version of a conference paper by Lee and Meng (2008).",
      "startOffset" : 62,
      "endOffset" : 1081
    }, {
      "referenceID" : 8,
      "context" : "(2011) that extends a conference paper by the same authors (Ferraris et al., 2007) by distinguishing between intensional and non-intensional predicates.",
      "startOffset" : 59,
      "endOffset" : 82
    }, {
      "referenceID" : 7,
      "context" : "Review of the First-Order Stable Model Semantics This review follows a journal paper by Ferraris et al. (2011) that extends a conference paper by the same authors (Ferraris et al.",
      "startOffset" : 88,
      "endOffset" : 111
    }, {
      "referenceID" : 2,
      "context" : "First-Order Loop Formulas and Herbrand Models We review the definition of a first-order loop formula for a nondisjunctive program given by Chen et al. (2006) and extend it to a disjunctive program and to an arbitrary first-order sentence.",
      "startOffset" : 139,
      "endOffset" : 158
    }, {
      "referenceID" : 2,
      "context" : "1 Review of First-Order Loop Formulas Defined by Chen et al. (2006) We call a formula negative if every occurrence of every predicate constant in it belongs to the antecedent of an implication.",
      "startOffset" : 49,
      "endOffset" : 68
    }, {
      "referenceID" : 7,
      "context" : ") When Π is a propositional program, LF Π(Y ) is equivalent to a conjunctive loop formula as defined by Ferraris et al. (2006). The definition of a first-order dependency graph and the definition of a first-order loop are as follows.",
      "startOffset" : 104,
      "endOffset" : 127
    }, {
      "referenceID" : 2,
      "context" : "The original definition by Chen et al. (2006) does not allow function constants of positive arity.",
      "startOffset" : 27,
      "endOffset" : 46
    }, {
      "referenceID" : 2,
      "context" : "The following is a reformulation of Theorem 1 from the work of Chen et al. (2006).",
      "startOffset" : 63,
      "endOffset" : 82
    }, {
      "referenceID" : 2,
      "context" : "Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2, we say that Y1 subsumes Y2 if there is a substitution θ that maps variables in Y1 to terms so that Y1θ = Y2.",
      "startOffset" : 28,
      "endOffset" : 47
    }, {
      "referenceID" : 2,
      "context" : "Following the definition by Chen et al. (2006), given two sets of atoms Y1 and Y2, we say that Y1 subsumes Y2 if there is a substitution θ that maps variables in Y1 to terms so that Y1θ = Y2. Proposition 1 (Chen et al., 2006, Proposition 7) For any nondisjunctive program Π and any loops Y1 and Y2 of Π, if Y1 subsumes Y2, then LF Π(Y1) entails LF Π(Y2). Therefore in condition (c) from Theorem 1, it is sufficient to consider a set Γ of loops such that, for every loop L of Π, there is a loop L′ in Γ that subsumes L. Chen et al. (2006) called such Γ a complete set of loops.",
      "startOffset" : 28,
      "endOffset" : 538
    }, {
      "referenceID" : 7,
      "context" : "When Π and Y are propositional, LF Π(Y ) is equivalent to the conjunctive loop formula for a disjunctive program as defined by Ferraris et al. (2006).",
      "startOffset" : 127,
      "endOffset" : 150
    }, {
      "referenceID" : 7,
      "context" : "It is also a generalization of the main theorem by Ferraris et al. (2006) which was restricted to a propositional disjunctive program.",
      "startOffset" : 51,
      "endOffset" : 74
    }, {
      "referenceID" : 7,
      "context" : "As with a propositional loop formula defined for an arbitrary propositional theory (Ferraris et al., 2006), it is convenient to introduce a formula whose negation is close to ES .",
      "startOffset" : 83,
      "endOffset" : 106
    }, {
      "referenceID" : 7,
      "context" : "When F and Y are propositional, LFF (Y ) is equivalent to a conjunctive loop formula for a propositional formula that is defined by Ferraris et al. (2006). The following lemma tells us that the definition of a loop formula in this section generalizes the definition of a loop formula for a disjunctive program in the previous section.",
      "startOffset" : 132,
      "endOffset" : 155
    }, {
      "referenceID" : 7,
      "context" : "Theorem 2 from the work of Ferraris et al. (2006) is a special case of Theorem 1f when F is restricted to a propositional formula.",
      "startOffset" : 27,
      "endOffset" : 50
    }, {
      "referenceID" : 9,
      "context" : "A sentence F is in Clark normal form (Ferraris et al., 2011) if it is a conjunction of formulas of the form",
      "startOffset" : 37,
      "endOffset" : 60
    }, {
      "referenceID" : 5,
      "context" : "SLF[F ] is similar to Clark’s completion. In the propositional case, the relationship between the loop formulas of singletons and the completion is studied by Lee (2005). Below we describe their relationship in the first-order case.",
      "startOffset" : 22,
      "endOffset" : 170
    }, {
      "referenceID" : 6,
      "context" : "Corollary 4 is an enhancement of Theorem 11 from the work of Ferraris et al. (2011), which states the equivalence between SM[F ] and Comp[F ] for any tight sentence F in Clark normal form.",
      "startOffset" : 61,
      "endOffset" : 84
    }, {
      "referenceID" : 10,
      "context" : "A nonempty set U of atoms that occur in Π is a loop of Π iff, for every nonempty proper subset V of U , there is an edge from an atom in V to an atom in U \\ V in the dependency graph of Π (Gebser et al., 2006).",
      "startOffset" : 188,
      "endOffset" : 209
    }, {
      "referenceID" : 5,
      "context" : "1 Bounded Formulas and Clark’s Equational Theory On the other hand, such a relationship holds if the interpretation satisfies Clark’s equational theory (1978). Clark’s equational theory of a signature σ, denoted by CETσ, is the union of the universal closures of the following formulas f(x1, .",
      "startOffset" : 23,
      "endOffset" : 159
    }, {
      "referenceID" : 1,
      "context" : "Consider another example program by Bonatti (2004), where a, .",
      "startOffset" : 36,
      "endOffset" : 51
    }, {
      "referenceID" : 1,
      "context" : "They actually satisfy a stronger condition called “finitely recursive” (Bonatti, 2004).",
      "startOffset" : 71,
      "endOffset" : 86
    }, {
      "referenceID" : 2,
      "context" : "The proof of Proposition 10 (c) is based on the following fact and the straightforward extension of Theorem 2 by Chen et al. (2006) to first-order formulas, which asserts that checking if F has a finite complete set of loops is decidable.",
      "startOffset" : 113,
      "endOffset" : 132
    }, {
      "referenceID" : 16,
      "context" : "According to Lee, Lifschitz, and Palla (2009), a semi-safe sentence has the “small predicate property”: the relation represented by any of its predicate constants p can hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F .",
      "startOffset" : 13,
      "endOffset" : 46
    }, {
      "referenceID" : 16,
      "context" : "According to Lee, Lifschitz, and Palla (2009), a semi-safe sentence has the “small predicate property”: the relation represented by any of its predicate constants p can hold for a tuple of arguments only if each member of the tuple is represented by an object constant occurring in F . We will show that any semi-safe sentence under the stable model semantics can be turned into a sentence in first-order logic. First, we review the notion of semi-safety by Lee et al. (2009).13 As a preliminary step, we assign to every formula F a set RV(F ) of its restricted variables as follows: • For an atomic formula F , – if F is an equality between two variables, then RV(F ) = ∅; – otherwise, RV(F ) is the set of all variables occurring in F ; • RV(G ∧H) = RV(G) ∪ RV(H); • RV(G ∨H) = RV(G) ∩ RV(H); • RV(G→ H) = ∅; • RV(QvG) = RV(G) \\ {v} where Q ∈ {∀,∃}.",
      "startOffset" : 13,
      "endOffset" : 476
    }, {
      "referenceID" : 20,
      "context" : "Proposition 12 (Lee et al., 2009) For any semi-safe sentence F , formula SM[F ] entails SPPc(F ).",
      "startOffset" : 15,
      "endOffset" : 33
    }, {
      "referenceID" : 8,
      "context" : "(2011), reviewed in Section 2, is more general than the definition in their conference paper (Ferraris et al., 2007) in that it allows us to distinguish between intensional and non-intensional (a.",
      "startOffset" : 93,
      "endOffset" : 116
    }, {
      "referenceID" : 7,
      "context" : "Extension to Allow Extensional Predicates The definition of a stable model in the journal paper by Ferraris et al. (2011), reviewed in Section 2, is more general than the definition in their conference paper (Ferraris et al.",
      "startOffset" : 99,
      "endOffset" : 122
    }, {
      "referenceID" : 20,
      "context" : "Proposition 15 (Lee et al., 2009) For any semi-safe sentence F relative to p, formula SM[F ; p] entails SPPpc(F ).",
      "startOffset" : 15,
      "endOffset" : 33
    }, {
      "referenceID" : 1,
      "context" : "Related Work The notion of a bounded program is related to the notion of a finitely recursive program studied by Bonatti (2004), where a different definition of a dependency graph was considered.",
      "startOffset" : 113,
      "endOffset" : 128
    }, {
      "referenceID" : 27,
      "context" : "Lin and Wang (2008) extended answer set semantics with functions by extending the definition of a reduct, and also provided loop formulas for such programs.",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 25,
      "context" : "Lin and Wang (2008) consider essentially many-sorted languages.",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 27,
      "context" : "The following conditions are equivalent to each other: (a) I is an answer set of P according to Lin and Wang (2008); (b) I is a P -interpretation that satisfies SM[F ]; (c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.",
      "startOffset" : 96,
      "endOffset" : 116
    }, {
      "referenceID" : 27,
      "context" : "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c).",
      "startOffset" : 136,
      "endOffset" : 156
    }, {
      "referenceID" : 27,
      "context" : "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program Π that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics.",
      "startOffset" : 136,
      "endOffset" : 393
    }, {
      "referenceID" : 27,
      "context" : "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program Π that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures.",
      "startOffset" : 136,
      "endOffset" : 869
    }, {
      "referenceID" : 27,
      "context" : "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program Π that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order definability on finite structures by turning programs into modified completion using new predicates to record levels.",
      "startOffset" : 136,
      "endOffset" : 1038
    }, {
      "referenceID" : 27,
      "context" : "The equivalence between (a) and (c) follows from the fact that LW answer sets can be characterized by loop formulas that are defined by Lin and Wang (2008) and that these loop formulas are essentially the same as the loop formulas in (c). Since the proposal of the first-order stable model semantics, there have been some papers about first-order definability of SM[F ]. Zhang and Zhou (2010) show that, for a nondisjunctive program Π that has no function constants of positive arity, its first-order stable model semantics can be reformulated by a progression based semantics. They also showed that the programs whose answer sets can be found by a finite progression are exactly those that can be represented by first-order formulas. Some researchers have paid special attention to first-order definability of SM[F ] on finite structures. Chen, Zhang, and Zhou (2010) show a game-theoretic characterization for the first-order indefinability of first-order answer set programs on finite structures. Asuncion, Lin, Zhang, and Zhou (2010) show first-order definability on finite structures by turning programs into modified completion using new predicates to record levels. Chen, Lin, Zhang, and Zhou (2011) present a condition called “loop-separable,” which is more refined than finite complete set of loops under which the finite answer sets of a program can be captured by first-order sentences.",
      "startOffset" : 136,
      "endOffset" : 1207
    }, {
      "referenceID" : 35,
      "context" : "The use of first-order theorem provers for the stable model semantics was already investigated by Sabuncu and Alpaslan (2007), but their results are limited in several ways.",
      "startOffset" : 98,
      "endOffset" : 126
    }, {
      "referenceID" : 1,
      "context" : "Future work is to find further restrictions that make first-order stable model reasoning decidable and computable in an efficient manner, like the conditions imposed in “finitary” programs (Bonatti, 2004).",
      "startOffset" : 189,
      "endOffset" : 204
    }, {
      "referenceID" : 34,
      "context" : "Lemma 13 For any terms t1 and t2 of signature σ, any interpretation I that satisfies CETσ, and any substitution θ from object variables in t1 and t2 to object names such that (t1θ) I = (t2θ) I , Robinson’s unification algorithm (Robinson, 1965), when applied to t1 and t2, returns a most general unifier (mgu) γ of t1 and t2 such that (a) t1γ = t2γ, and (b) for every variable x in t1 or t2, (xγθ) I = (xθ)I .",
      "startOffset" : 228,
      "endOffset" : 244
    }, {
      "referenceID" : 15,
      "context" : "1 from the work of Kunen (1987), t1 and t2 are unifiable, in which case Robinson’s algorithm returns a mgu for t1 and t2 that maps variables occurring in t1 and t2 into terms.",
      "startOffset" : 19,
      "endOffset" : 32
    }, {
      "referenceID" : 2,
      "context" : "7 Proof of Proposition 11 We will use the following lemma in this section and the next section, which extends Theorem 2 in the work of Chen et al. (2006) that provides a few equivalent conditions for a program to have a finite complete set of loops to a disjunctive program and a sentence.",
      "startOffset" : 135,
      "endOffset" : 154
    }, {
      "referenceID" : 1,
      "context" : "The proof repeats, with minor modifications, the argument from the proof of Theorem 26 from the work of Bonatti (2004), which considers the following program ΠM to simulate deterministic Turing machines M.",
      "startOffset" : 104,
      "endOffset" : 119
    }, {
      "referenceID" : 27,
      "context" : "The following conditions are equivalent to each other: (a) I is an answer set of P according to Lin and Wang (2008); (b) I is a P -interpretation that satisfies SM[F ]; (c) I is a P -interpretation that satisfies F and the loop formulas of Y for all loops Y of F w.",
      "startOffset" : 96,
      "endOffset" : 116
    }, {
      "referenceID" : 27,
      "context" : "Given a program Π, Norm(Π) is a normal form of Π and Ground(Π) is a ground program obtained from Π as described by Lin and Wang (2008). The proof of Proposition 16 follows from the following lemma.",
      "startOffset" : 115,
      "endOffset" : 135
    } ],
    "year" : 2011,
    "abstractText" : "Lin and Zhao’s theorem on loop formulas states that in the propositional case the stable model semantics of a logic program can be completely characterized by propositional loop formulas, but this result does not fully carry over to the first-order case. We investigate the precise relationship between the first-order stable model semantics and first-order loop formulas, and study conditions under which the former can be represented by the latter. In order to facilitate the comparison, we extend the definition of a first-order loop formula which was limited to a nondisjunctive program, to a disjunctive program and to an arbitrary first-order theory. Based on the studied relationship we extend the syntax of a logic program with explicit quantifiers, which allows us to do reasoning involving non-Herbrand stable models using first-order reasoners. Such programs can be viewed as a special class of firstorder theories under the stable model semantics, which yields more succinct loop formulas than the general language due to their restricted syntax.",
    "creator" : "TeX"
  }
}