{
  "name" : "1603.03884.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Grounding Recursive Aggregates: Preliminary Report",
    "authors" : [ "Martin Gebser", "Roland Kaminski", "Torsten Schaub" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 3.\n03 88\n4v 1\n[ cs\n.A I]\n1 2\nM ar\n2 01\n6"
    }, {
      "heading" : "1 Introduction",
      "text" : "Modern grounders like (the one in) dlv [1] or gringo [2] are based on semi-naive database evaluation techniques [3,4] for avoiding duplicate work during grounding. Grounding is seen as an iterative bottom-up process guided by the successive expansion of a program’s Herbrand base, that is, the set of variable-free atoms constructible from the signature of the program at hand. During this process, a ground rule is only produced if its positive body atoms belong to the current Herbrand base, in which case its head atom is added to the current Herbrand base. The basic idea of semi-naive database evaluation is to focus this process on the new atoms generated at each iteration in order to avoid reproducing the same ground rules. This idea is based on the observation that the production of a new ground rule relies on the existence of an atom having been new at the previous iteration. Accordingly, a ground rule is only produced if its positive body contains at least one atom produced at the last iteration.\nIn what follows, we show how a grounding framework relying upon semi-naive database evaluation techniques can be extended to incorporate recursive aggregates. An example of such an aggregate is shown in Table 1, giving an encoding of the Company Controls Problem [5]: A company X controls a company Y , if X directly or indirectly controls more than 50% of the shares of Y . The aggregate sum+ implements summation over positive integers. Notably, it takes part in the recursive definition of controls/2 in Table 1. A corresponding problem instance is given in Table 2. Note that a systematic instantiation of the four variables in Table 1 with the eight constants in Table 2 results in 64 ground rules. However, taken together, the encoding and the instance are equivalent to the program in Table 3, which consists of four ground rules only. In fact, all liter-\n⋆ Affiliated with Simon Fraser University, Canada, and IIIS Griffith University, Australia.\nals in Table 3 can even be evaluated in view of the problem instance, which moreover allows us to evaluate the aggregate atoms, so that the grounding of the above company controls instance boils down to the four facts controls(c1, c2), controls(c3, c4), controls(c1, c3), and controls(c1, c4).\nAccordingly, the goal of this paper is to elaborate upon the efficient computation of the relevant grounding of programs with recursive aggregates. Section 2 starts with recalling the formal preliminaries from [6]. Section 3 provides basic grounding algorithms (cf. [1]), paving the way for the more sophisticated algorithms addressing recursive aggregates in Section 4. We summarize our contribution and relate it to the state of the art in Section 5. The developed approach is implemented in gringo series 4."
    }, {
      "heading" : "2 Formal Preliminaries",
      "text" : "This section recalls the formal preliminaries regarding the syntax and semantics of gringo’s input language, developed in [6]."
    }, {
      "heading" : "2.1 Syntax",
      "text" : "Alphabet. We consider numerals, (symbolic) constants, variables, and aggregate names, along with the symbols\n6= < > ≤ ≥ 4 (1)\n⊥ ∼ ∧ ∨ ← (2)\n, ; : ( ) { } (3)\nNumerals are strings of numbers optionally preceded with a minus symbol. Constants are strings of letters, underscores, and numbers starting with a lowercase letter. Variables are strings of letters, underscores, and numbers starting with an uppercase letter.5\nTerms. Numerals, constants, and variables are terms. Given a constant f and a term tuple t, f(t) is a term as well. A variable-free term is said to be ground.\n4 Equality is not included here because it is treated specially in gringo; a description is beyond the scope of this paper. 5 We use _ to denote anonymous variables, i.e., each _ stands for unique variable.\nInterpretation of numerals and aggregates. A numeral n corresponds to the integer n. There is a total order on all ground terms extending that on numerals, that is, for any integers m and n, m ≤ n if m ≤ n.\nFor a ground term tuple t, weight(t) is n, if the first element of t is a numeral of form n, otherwise it is 0.\nEach aggregate name α is associated with a function α̂ from the set of sets of ground term tuples into the set of ground terms. Given a set T of ground term tuples, we consider the aggregate names/functions defined by\n– ŝum(T ) = Σt∈Tweight(t), if the subset of tuples with non-zero weights is finite, and 0 otherwise;\n– ŝum+(T ) = Σt∈T,weight(t)>0weight(t), if the subset of tuples with positive weights is finite, and ∞ otherwise.6\nAtoms and literals. Symbolic atoms have the form p(t) where p is a constant and t is a term tuple. Comparison atoms have form u1 ≺ u2 where u1 and u2 are terms. We use atom ⊥ to denote a comparison atom that is false (e.g., 0 > 0), and use ⊤ analogously. Simple literals have form a or ∼a where a is a symbolic or comparison atom.\nAggregate atoms have form\nα{t1 : L1; . . . ; tn : Ln} ≺ s (4)\nwhere\n– n ≥ 0 – α is an aggregate name – each ti is a term tuple – each Li is a tuple of simple literals – ≺ is one of the symbols (1) – s is a term, also called guard\n6 n < ∞ holds for any numeral n.\nFinally, literals have the form a or ∼a where a is either a symbolic, comparison, or aggregate atom.7\nRules and programs. Rules are of form h ← l1∧· · ·∧ ln, where n ≥ 0, h is a symbolic atom, and each li is a literal. A program is a finite set of rules.\nMiscellaneous definitions. We use the following projection functions on rules.\n– head(r) = h in a rule r of the above form – body(r) = {l1, . . . , ln} in a rule r of the above form – body+(r) = {a ∈ body(r) | a is a symbolic atom} – body−(r) = {a | ∼a ∈ body(r), a is a symbolic atom} – body±(r) = body+(r) ∪ body−(r)\nIn the following, some body literals are marked. The binary relation r † l holds if the literal l ∈ body(r) of rule r is marked. Marked body literals are indicated by l†.\nA substitution is a mapping from variables to (ground) terms. We represent substitutions by sets of form {x1 7→ t1, . . . , xn 7→ tn} where n ≥ 0, each xi is a variable, and each ti is a ground term. A substitution σ of the above form applied to a literal l, written lσ, replaces all occurrences of variables xi in l with corresponding terms ti.\nMoreover, we associate in what follows each occurrence of an aggregate in a logic program with a unique identifier. We use αi, xi, and si to refer to the aggregate function, tuple of global variables, and guard of the aggregate occurrence identified by i. Furthermore, (si)xig refers to the ground guard where the variables listed in tuple xi are replaced with the corresponding terms in tuple g in si.\nAn aggregate α together with a relation ≺ is monotone, if for any sets T1 ⊆ T2 of ground term tuples and ground term s, we have that α(T1) ≺ s implies α(T2) ≺ s."
    }, {
      "heading" : "2.2 Semantics",
      "text" : "The semantics of programs rests upon a translation into (infinitary) propositional formulas along with their stable models [7].\nGround simple literals are mapped via τ on propositional atoms as follows.\n– τ(a) = a for (ground) symbolic atom a – τ(t1 ≺ t2) is ⊤, if the relation ≺ holds between t1 and t2, and ⊥ otherwise – τ(∼a) = ¬τ(a) for a literal ∼a\nGlobal variables. A variable is global\n– in a simple literal, if it occurs in the literal – in an aggregate literal, if it occurs in the guard – in a rule, if it is global in the head or a body literal\n7 gringo as well as its semantic underpinnings in [6] also allow for double negated literals of form ∼∼a.\nAggregate literals. The translation τ extends to aggregate atoms a as in (4) as follows. An instance of an aggregate element t : L is obtained by substituting all its variables with ground terms. We let τL stand for the conjunction of applications of τ to the ground simple literals in L.\nLet E be the set of all instances of aggregate elements in a. A set ∆ ⊆ E justifies a, if the relation ≺ holds between α̂{t | (t : L) ∈ ∆} and the guard s. Then, τa is the conjunction of formulas ∧ (t:L)∈∆ τL → ∨ (t:L)∈E\\∆ τL for all sets ∆ ⊆ E that do not justify a. A negative aggregate literal ∼a is treated analogous to a negative simple literal.\nRules and programs. An instance of a rule r is obtained by substituting all global variables with ground terms. Then, τr is the set of formulas τl1 ∧ · · · ∧ τln → τh for all instances h ← l1 ∧ · · · ∧ ln of rule r, and τP = ⋃ r∈P τr for a program P .\nStable models. The stable models of a logic program P are the stable models of the (infinitary) propositional formula τP [7]."
    }, {
      "heading" : "2.3 Safety and Rule Dependency Graph",
      "text" : "A global variable is safe in a rule, if it is bound by a positive symbolic literal in the rule body. A non-global variable is safe in an aggregate element, if it is bound by a positive symbolic literal in the corresponding aggregate element. A rule is safe, if all its variables are safe. A program is safe, if all its rules are safe. In what follows, we consider safe programs only.\nThe rule dependency graph G = (V,E) of a (normal) logic program P is a directed graph such that V = P and E = {(r1, r2) ∈ V × V | l ∈ body±(r2), head(r1) unifies l}.8 The positive rule dependency graph G+ is defined similarly but considers edges induced by positive literals only (l ∈ body+(r2))."
    }, {
      "heading" : "3 Basic Grounding Algorithms",
      "text" : "This section provides some basic algorithms underlying semi-naive evaluation based grounding (see also [1]). All of them apply to normal logic programs and are thus independent of the treatment of recursive aggregates described in the next section.\nWe illustrate the basic algorithms by means of a Hamiltonian cycle example9 using the graph in Figure 1. This graph is represented by the problem instance in Table 4. The actual problem encoding is given in (5) to (13) below. The resulting Hamiltonian cycle is expressed through instances of predicate path/2; a detailed discussion of such encodings can be found in [8,9,10].\n8 Unification assumes that variables in r1 and r2 are distinct, even if they have the same name. 9 https://en.wikipedia.org/wiki/Hamiltonian_path_problem\nc d\na b\nFig. 1. Hamiltonian Cycle Instance (Graph)\npath(X,Y ) ← edge(X,Y ) ∧ ∼omit(X,Y ) (5)\nomit(X,Y ) ← edge(X,Y ) ∧ ∼path(X,Y ) (6)\n← path(X,Y ) ∧ path(X ′, Y ) ∧X < X ′ (7)\n← path(X,Y ) ∧ path(X,Y ′) ∧ Y < Y ′ (8)\non_path(Y ) ← path(X,Y ) ∧ path(Y, Z) (9)\n← node(X) ∧ ∼on_path(X) (10)\nreach(X) ← start(X) (11)\nreach(Y ) ← reach(X) ∧ path(X,Y ) (12)\n← node(X) ∧ ∼reach(X) (13)"
    }, {
      "heading" : "3.1 Analyzing Logic Programs",
      "text" : "The function Analyze given in Algorithm 1 takes a logic program P , classifies occurrences of recursive symbolic atoms (Ar), and groups rules into components suitable for successive grounding. The classification of atoms can be used to apply on-the-fly simplifications in the following algorithms (cf. Algorithm 3).\nAnalyze first determines the strongly connected components of the program’s dependency graph (Lines 2-3). This graph contains dependencies induced by both positive and negative literals. The outer loop (Lines 5-10) iterates over its components in topological order.10 Each component is then further refined in terms of its positive dependency graph (Lines 6-7).\nThe set Ar of recursive symbolic atoms is determined in Line 9. These are all body literals whose atom unifies with the head of a rule in the current or a following component. Finally, the refined component together with its recursive atoms is appended to the list L in Line 10. This list is the result of the algorithm returned in Line 11.\nFigure 2 shows the dependency graph of the encoding given in (5) to (13). Positive edges are depicted with solid lines, negative ones with dashed lines. Recursive atoms are typeset in bold. The negative edge from Component1,2 to Component1,1 is due to the fact that path(X,Y ) in the negative body of (6) unifies with path(X,Y ) in the head of (5). Furthermore, the occurrence of path(X,Y ) in (6) is recursive because it induces an edge from a later component in the topological ordering at hand. In contrast to positive literals, the recursiveness of negative literals depends on the topological ordering.\n10 A component C1 precedes C2 when there is an edge (r1, r2) with r1 ∈ C1 and r2 ∈ C2.\n1 function Analyze(P ) 2 let G be the dependency graph of P 3 S be the strongly connected components of G 4 L ← [] 5 foreach C in S do 6 let G+ be the positive dependency graph of C 7 S+ be the strongly connected components of G+ 8 foreach C+ in S+ do 9 let Ar = {a ∈ body±(r2) | r1 ∈ P, r2 ∈ C+,head(r1) unifies a}\n10 (L,P ) ← (L+ [(C+, Ar)], P \\ C +)\n11 return L\nAlgorithm 1: Analyze Logic Programs for Grounding\nFor instance, omit(X,Y ) would be recursive in the topological order obtained by exchanging Component1,1 and Component1,2. Regarding Component7,1, the occurrence of reach(X) in the body of (12) is recursive because it unifies with the head of the same rule. Accordingly, it induces a self-loop in the dependency graph."
    }, {
      "heading" : "3.2 Preparing Components for Grounding",
      "text" : "The function Prepare sets up the rules in a component C for grounding w.r.t. its recursive atoms Ar. To this end, it adds one of the subscripts n, o, or a to the predicate names of the atoms in the positive rule bodies of a given component.11 These subscripts\n11 The alphabet in Section 2 does not allow for predicate names with subscripts. During grounding, we temporarily extend this alphabet with such predicate names.\n1 function Prepare(C,Ar) 2 L ← ∅ 3 foreach r in C do 4 D ← ∅ 5 let S = body+(r) ∩Ar 6 foreach p(x) in S do\n7 L ← L ∪\n \n\nhead(r) ← ∧\nq(y)∈D qo(y) ∧ pn(x)\n∧ ∧\nq(y)∈body+(r)\\(D∪{p(x)}) qa(y)\n∧ ∧\nl∈body(r)\\body+(r) l\n \n\n8 D ← D ∪ {p(x)}"
    }, {
      "heading" : "9 if S = ∅ then",
      "text" : "10 L ← L ∪\n{ head(r) ← ∧ p(x)∈body+(r) pn(x)\n∧ ∧\nl∈body(r)\\body+(r) l\n}\n11 return L\nAlgorithm 2: Prepare Components\nindicate new, old, and all atoms belonging to the current materialization of the Herbrand base. In turn, they are used in the course of semi-naive database evaluation to avoid duplicate work when grounding a component w.r.t. an expanding Herbrand base.\nThe loop in Lines 3-10 iterates over the rules in the component at hand. Each such rule r is expanded into a set of rules (loop in Lines 6-8) w.r.t. the recursive atoms in its body (Line 5). In the first row of Line 7, predicate names of recursive atoms already considered (set D) receive subscript o, and the predicate name of the recursive atom p(x) receives subscript n. In the second row, the recursive atoms not yet considered as well as non-recursive atoms of the positive body receive subscript a. Finally, in the third row, the remaining body literals are kept unmodified. If there are no recursive atoms (Line 9), then subscript n is added to all positive body elements (first row of Line 10). As in the case with recursive atoms, the remaining body literals are kept unmodified (second row).\nThe result of preparing all components of the dependency graph in Figure 2 is given in Figure 3. All rules but r8 contain only non-recursive positive body literals, which are adorned with subscript n. Unlike this, the non-recursive positive body literal path(X,Y ) in r8 is adorned with a, while only the recursive one, reach(X), receives subscript n. Since there is only one recursive body atom, only one rule is generated."
    }, {
      "heading" : "3.3 Grounding Rules",
      "text" : "The rule grounding algorithm relies upon two auxiliary functions. First, function order returns a safe body order of a rule body.12 A safe body order of a body {b1, . . . , bn} is a tuple (b1, . . . , bn) such that {b1, . . . , bi} is safe for each 1 ≤ i ≤ n. For example,\n12 The runtime of instantiation algorithms is sensitive to the chosen body order. In the context of ASP, heuristics for ordering body literals have been studied in [11].\n(p(X),∼q(X)) is a safe body order, while (∼q(X), p(X)) is not. Second, given a symbolic atom a, a substitution σ, and a set A of ground atoms, function matches(a, σ,A) returns the set of matches for a in A w.r.t. σ. A match is a ⊆-minimal substitution σ′ such that aσ′ ∈ A and σ ⊆ σ′. For instance, matches(p(X,Y ), {Y 7→ a}, {p(a, a), p(b, b), p(c, a)}) yields {X 7→ a, Y 7→ a} and {X 7→ c, Y 7→ a}.\nWith both functions at hand, we assemble the basic algorithm GroundRule for grounding individual rules in Algorithm 3. Note that the original rule r′ along with its marking † can be ignored in our context; they are only relevant when treating aggregates in Section 4.13 The algorithm proceeds along the safe body order determined in Line 20. If no body literals remain, a ground rule is generated in Line 7 provided that its head is not among the established facts. Moreover, if the rule in focus has become a fact, its head is added to Af in Line 8. The remainder constitutes a case analysis upon the type of the left-most body literal. If b1 is a positive body literal, an instance of b1 is added in turn to the (partial) ground body B for each match of b1. However, this is only done if the literal is not marked and the instance does not yet belong to the established facts. If b1 is a negative body literal, the instance obtained by applying the current substitution is added to the ground body. Again, this is only done if the literal is not marked, and the literal is recursive or there is already a derivation for it. Substitutions where the instance is a fact are skipped altogether. Finally, comparison literals are directly evaluated and rule instantiation is only pursued if the test was successful.\nFor illustration, we trace in Figure 4 the application of GroundRule to rule r1, viz. ‘omit(X,Y ) ← edgen(X,Y )∧∼path(X,Y )’, from Figure 3. Figure 4 also gives\n13 This is the rule before the application of function Prepare. That is, the positive body literals of r′ are free of subscripts o, n, and a. The conditions r′ 6 † p(x) and r′ 6 † b1 in Line 11 or 15, respectively, are tautological in this section.\nthe contents of the respective sets of atoms (when tackling the very first component in Figure 3). The header in Figure 4 contains the ordered body followed by the rule head. Starting with the first positive body literal edgen(X,Y ) results in eight distinct matches of edge(X,Y ) in An. The atoms resulting from a set of matches are connected with undirected edges in Figure 4. Note that none of the instances of edge(X,Y ) is added to\n1 function Ground(P,Af) 2 (Pg, Aa) ← (∅, Af) 3 foreach (C,Ar) in Analyze(P ) do 4 (An, Ao) ← (Aa, ∅) 5 repeat 6 A∆ ← ∅ 7 foreach r in Prepare(C,Ar) do 8 (P ′g, Af) ← GroundRule(r,Ar, An, Ao, Aa, Af) 9 (A∆, Pg) ← (A∆ ∪ {head(rg) | rg ∈ P ′ g}, Pg ∪ P ′ g)\n10 (An, Ao, Aa) ← (A∆ \\ Aa, Aa, A∆ ∪Aa) 11 until An = ∅ or {r ∈ C | body+(r) ∩Ar 6= ∅} = ∅\n12 return Pg\nAlgorithm 4: Grounding Logic Programs\nthe (empty) body, since they are all found to be facts. Looking at the trace for the first match, we observe that GroundRule’ is next called with the empty body, the singleton (∼path(X,Y )), and substitution {X 7→ a, Y 7→ b}. Given that the atom path(a, b) is not a fact and recursive, no simplifications apply, as indicated by underlining, and the instance is added to the body. The following call with body {∼path(a, b)}, the empty tuple, and the same substitution results in the ground rule ‘omit(a, b) ← ∼path(a, b)’. Analogously, the other six matches result in further instances of r1."
    }, {
      "heading" : "3.4 Grounding Logic Programs",
      "text" : "The above functions are put together in Algorithm 4 for grounding entire (normal) logic programs. The function Ground takes a partition of a program into genuine rules P and atoms Af stemming from facts, and returns (upon termination) a set of ground instantiated rules Pg. The latter is incrementally constructed by following the topological order of components determined by Analyze. Then, in turn, each adorned rule in the prepared component is instantiated via GroundRule. The loop in Lines 5-11 is executed only once whenever the component is free of recursive positive body literals, and otherwise until no new (head) atoms are forthcoming. This is accomplished by manipulating the following sets of atoms:\n– Aa the set of all relevant atoms up to the current grounding step, – An ⊆ Aa the set of atoms atoms newly instantiated in the previous grounding step, – Ao = Aa \\An the set of atoms that are not new w.r.t. the previous step, – A∆ the set of atoms resulting from the current grounding step, and – Af ⊆ Aa ∪ A∆ the set of atoms having a corresponding fact in Pg.\nThe set Aa comprises the relevant Herbrand base when the algorithm terminates. For illustration, let us trace Ground in Figure 5 when grounding the last but one component from Figure 3. To be more precise, this deals with the prepared version of Component7,1 containing rule r8 only, viz. ‘reach(Y ) ← reachn(X) ∧ patha(X,Y )’. The recursive nature of this rule results in three iterations of the loop in Lines 5-11.\nAccordingly, we index the atom sets in Figure 5 to reflect their state in the respective iteration. Moreover, we only provide the parts of Ao, An, Aa, and Af that are relevant to grounding r8. Otherwise, conventions follow the ones in Figure 4.\nAt the first iteration, the atom reach(a) (obtained from grounding Component6,1) is used to obtain rule instances\nreach(b) ← path(a, b)\nreach(c) ← path(a, c)\nNote that reach(a) is removed from both rule bodies because it belongs to the established facts. Moreover, this iteration yields the new atoms reach(b) and reach(c), which are used in the next iteration to obtain the four rule instances\nreach(c) ← reach(b) ∧ path(b, c)\nreach(d) ← reach(b) ∧ path(b, d)\nreach(a) ← reach(c) ∧ path(c, a)\nreach(d) ← reach(c) ∧ path(c, d)\nUnlike above, no simplifications can be performed because no facts are involved. The iteration brings about a single new atom, reach(d), which yields the rule instance\nreach(a) ← reach(d) ∧ path(d, a)\n1 function Rewrite(P ) 2 Q ← ∅ // in the loop below, ⋄ ∈ {ǫ,∼} stands for the sign of the aggregate literal 3 foreach r in P with a ∈ body(r), a = ⋄α{t1 : L1; . . . ; tn : Ln} ≺ s do 4 let i be a unique identifier 5 x be the global variables in a 6 B(L) = ∧ l∈body(r)\\L,l is a simple literal l † 7 replace occurrence a in P with ⋄aggr i(x)\n8\nQ ← Q ∪ {accu i(x,neutral ) ← α̂(∅) ≺ s ∧ B(∅)}\n∪ {accu i(x, tuple(tj)) ← ∧\nl∈Lj l ∧B(Lj) | 1 ≤ j ≤ n}\n∪ {aggr i(x) ← accu i(x, _) ∧ ⊥}"
    }, {
      "heading" : "9 return P ∪Q",
      "text" : "Algorithm 5: Rewrite Logic Programs\nThis iteration produces no new atoms and ends the instantiation of Component7,1. The other components are grounded analogously but within a single iteration due to their lack of recursive positive body literals. This is enforced by the second stop criterion in Line 11 of Algorithm 4."
    }, {
      "heading" : "4 Grounding Recursive Aggregates",
      "text" : "Having laid the foundations of grounding normal logic programs, we now continue with the treatment of recursive aggregates. The idea is to translate aggregate atoms into normal logic programs, roughly one rule per aggregate element, and then to reuse the basic grounding machinery as much as possible. In addition, some aggregate-specific propagation takes place. At the end, the resulting aggregate instances are re-assembled from the corresponding rules."
    }, {
      "heading" : "4.1 Rewriting Logic Programs with Aggregates",
      "text" : "The function Rewrite given in Algorithm 5 takes as input a logic program (possibly with recursive aggregates) and rewrites it into a normal logic program with additional predicates capturing aggregates and aggregate elements.14\nEach aggregate occurrence is replaced with an atom of form aggr i(x) in Line 7, where i is a unique identifier associated with the aggregate occurrence and x are the global variables occurring in the aggregate. The idea is that each atom over predicate aggr i in the grounding of the rewriting corresponds to a ground aggregate, which is substituted for the atom in the final grounding.\nTo represent aggregate elements like tj : Lj , auxiliary rules defining atoms of form accu i(x, t) are added in Line 8, where x are the global variables as above and t is the tuple that is aggregated (or the special constant neutral). Here, the idea is to inspect\n14 We assume that predicates aggr i and accu i are not used elsewhere in the program.\nthe grounding for rules with atoms over accu i in the head. If enough such atoms are accumulated to satisfy an aggregate, then corresponding atoms over aggr i are added to the Herbrand base to further ground the program.\nThe first rule in Line 8 handles the special case that the aggregate is satisfied for an empty set of tuples (e.g., anti-monotone aggregates like sum+{t : L} ≤ s). Its body contains a comparison literal that checks whether the empty aggregate is satisfied. Furthermore, we have to make sure that the rule is safe so that it can be instantiated. For this purpose, all simple literals of the rule in which the aggregate i occurs are added to the rule body (via function B). Hence, if the original rule is safe, the auxiliary rule is also safe because global variables are bound by positive symbolic literals only. Furthermore, literals responsible for binding global variables are marked (via †).\nThe second set of rules in Line 8 is in charge of accumulating tuples of aggregate elements. The rule body contains the literals of the condition of the aggregate element as well as marked literals necessary for ensuring the rule’s safety. Remember that the resulting ground rules represent ground aggregate atoms, where the marking is used to distinguish literals not belonging to the conditions of reconstituted aggregate elements.\nFinally, one last rule is added in Line 8 for ensuring that the dependencies induced by the aggregate are kept intact. Since this rule contains ⊥, it never produces instances though.\nThe result of rewriting the company controls encoding from Table 1 is given in Table 5. The global variables in the (single) aggregate are X and Y , which occur first in all atoms over aggr 1/2 and accu1/3. Since the empty aggregate is not satisfied, the rule accumulating the neutral tuple never produces any instances (and could in principle be dropped from the rewriting)."
    }, {
      "heading" : "4.2 Analyzing and Preparing Logic Programs with Aggregates",
      "text" : "Figure 6 captures the result of function Analyze with Prepare called for each component of the rewritten company controls encoding in Table 5. The rules in Component1,1 and Component2,1 depend on facts only, and thus both induce a singleton component. Component3,1 contains the remaining rules. The aggregate of the company controls encoding is recursive in this component in view of the atom controls(X,Z) in its second aggregate element. Note that not all aggregate elements are involved in this recursion, given that direct shares are accumulated via the rule in Component2,1.\n1 function Propagate(I, r,Aa, Af) 2 A∆ ← ∅ 3 foreach i, g where i ∈ I and accu i(g, t) ∈ Aa do 4 let Tf = {t | accu i(g, tuple(t)) ∈ Af , t is relevant for αi} 5 Ta = {t | accu i(g, tuple(t)) ∈ Aa, t is relevant for αi} 6 if exists Tf ⊆ T ⊆ Ta where α̂i(T ) ≺i (si) xi g is true then 7 if (aggregate i is monotone and α̂i(Tf) ≺i (si) xi g ) 8 or (not r and Ta \\ Tf = ∅) then 9 Af ← Af ∪ {aggr i(g)}\n10 A∆ ← A∆ ∪ {aggr i(g)}\n11 return (A∆, Af)\nAlgorithm 6: Propagation of Aggregates"
    }, {
      "heading" : "4.3 Propagating Aggregates",
      "text" : "The function Propagate inspects the partial grounding of an aggregate instance in view of its grounded aggregate elements. To this end, it checks atoms over predicate accu i obtained during grounding. The loop in Lines 3-10 iterates over the given aggregate indices I and tuples of global variables stored in atoms over predicate accui appearing among the atoms in Aa. Whenever there are enough tuples captured by such atoms to satisfy the corresponding aggregate, Propagate adds atoms over predicate aggr i to A∆ for further instantiation. While Line 4 collects tuples that are necessarily accumulated by the aggregate function, Line 5 gathers tuples whose conditions can possibly hold. Also note that the relevance check skips tuples that do not change the result of an aggregate function.15 For sum aggregates, this amounts to excluding zeroweight tuples by stipulating weight(t) 6= 0. Given these sets of tuples, Line 6 checks whether the aggregate can be satisfied using the tuples accumulated so far. For sum ag-\n15 For non-recursive aggregates, where the flag r is false, Line 8 checks whether Ta \\Tf is empty. This is why only relevant tuples are gathered.\n1 function Assemble(Pg) 2 foreach aggr i(g) occurring in Pg do // below, body(r) is assumed to convert to a tuple of literals 3 let E = {t : body(r) | r ∈ Pg, head(r) = accu i(g, tuple(t))} 4 replace all occurrences of aggr i(g) in Pg with αi(E) ≺i (si) xi g\n5 remove all rules with atoms over accu i in the head from Pg 6 return Pg\nAlgorithm 7: Assembling Aggregates\ngregates, this can be tested by adding up the weights of factual tuples and, on the one hand, the negative weights to obtain a minimum, min , or the positive weights to obtain a maximum, max . Then, depending on the relation, the aggregate is satisfiable\n– if max ≺ (si)xig is true for ≺ ∈ {≥, >}, – if min ≺ (si)xig is true for ≺ ∈ {≤, <}, or – if min ≺ (si)xig or max ≺ (si) xi g is true for ≺ ∈ {6=}.\nIf the test in Line 6 succeeds, the ground aggregate atom is added to the new atoms in Line 10. In addition, given a non-recursive or monotone aggregate, the corresponding ground aggregate atom is added to Af whenever the aggregate is found to be true. At this point, a non-recursive aggregate is true, if all its elements are facts (Line 8), and a monotone aggregate is true, if enough facts to satisfy the aggregate have been accumulated (Line 7). Finally, the sets of new and factual atoms are returned in Line 11."
    }, {
      "heading" : "4.4 Assembling Aggregates",
      "text" : "After Rewrite has decomposed aggregate atoms into normal program rules, Assemble given in Algorithm 7 reconstructs their grounded counterparts from the rewritten ground program. That is, all occurrences of atoms of form aggr i(g) are replaced by their corresponding aggregates. In doing so, the aggregate elements are reconstructed from rules with head atoms accu i(g, tuple(t)) in Line 3, where an element consists of the term tuple t along with the condition expressed by the rule body.16 The actual replacement takes place in Line 4, followed by the deletion of obsolete rules in Line 5. Finally, the reconstructed ground program is returned in Line 6."
    }, {
      "heading" : "4.5 Grounding Logic Programs with Aggregates",
      "text" : "Algorithm 8 extends the Ground function in Algorithm 4 to logic program with aggregates. To this end, the extended Ground function uses algorithms Rewrite, Propagate, and Assemble from the previous subsections. The changes in the algorithm are highlighted with a gray background, while other parts are left untouched.\nThe first change is in Line 3, where function Rewrite is called to turn the logic program P into a normal logic program before calling Analyze. Then, Lines 4 and 5\n16 Recall that marked literals, added for safety, are stripped off by GroundRule in Algorithm 3.\n1 function Ground(P,Af) 2 (Pg, Aa) ← (∅, Af)\n3 foreach (C,Ar) in Analyze(Rewrite(P )) do 4 let I = {i | aggr i occurs in a rule head in C} 5 Ir = {i | r ∈ C,head(r) = accu i(x, t), a ∈ body +(r) ∩Ar, r 6 † a} 6 (An, Ao) ← (Aa, ∅) 7 repeat 8 A∆ ← ∅ 9 foreach r in Prepare(C,Ar) do\n10 (P ′g, Af) ← GroundRule(r,Ar, An, Ao, Aa, Af) 11 (A∆, Pg) ← (A∆ ∪ {head(rg) | rg ∈ P ′ g}, Pg ∪ P ′ g)\n12 if A∆ ⊆ Aa then 13 (A∆, Af) ← Propagate(I \\ Ir, false, Aa, Af)\n14 if A∆ ⊆ Aa then 15 (A∆, Af) ← Propagate(I ∩ Ir, true, Aa, Af)\n16 (An, Ao, Aa) ← (A∆ \\ Aa, Aa, A∆ ∪Aa) 17 until An = ∅ or {r ∈ C | body+(r) ∩Ar 6= ∅} = ∅\n18 return Assemble(Pg)\nAlgorithm 8: Grounding Logic Programs with Aggregates\nare added, just before the loop in charge of grounding each component. Here, all aggregate indices that have to be propagated during the instantiation of a component are collected. First, all indices for which a rule with aggr i in the head appears in the component are gathered in I . Remember that these rules do not contribute instances because ⊥ belongs to their bodies (cf. third row in Line 8 of Algorithm 5). Instead, Propagate is adding atoms over aggr i to A∆. Second, in Line 5, aggregate indices associated with recursive aggregates are collected, where the (positive) recursion involves some aggregate element indicated by a rule with head atom accui(x, t), yet without considering the auxiliary body part marked with †.\nThe collected indices are in Lines 12-15 used to propagate the corresponding aggregates in the current component. Propagation of aggregates is triggered whenever no more new atoms are obtained in the grounding loop in Lines 9-11. First, nonrecursive aggregates I \\ Ir are instantiated. At this point, if there is at least one ground atom of form accui(g, t) ∈ Aa, all aggregate elements of the corresponding aggregate (uniquely determined by the terms g for global variables) have been gathered. The aggregate can thus be propagated, and function Propagate can apply additional simplifications (cf. Line 8 in Algorithm 6). Afterwards, recursive aggregates I ∩ Ir are propagated in Line 15. In this case, we cannot assume that all aggregate elements have already been accumulated, and propagation can thus not use all of the simplifications applicable to non-recursive aggregates, where the distinction is implemented by setting the second argument of Propagate to true. Finally, in Line 18, aggregates are reconstructed from the intermediate grounding by calling function Assemble.\nFigure 7 traces the whole grounding process of the rewritten company controls encoding given in Figure 6. The grounding of each component is separated by a horizontal\ndouble line, and the instantiation of a component is shown analogously to Figure 5. Due to lack of space, we refrain from giving sets Ar, An, Ao, and Aa. For each component, indicated by its number on the right, the contained rules are listed first, followed by grounding iterations for the component in focus. Each iteration is separated by a solid line and indexed with an iteration number on the right, where (instances of) the three rules in Component3,1 are separated by dashed lines. The symbol × indicates that a body literal does not match, which corresponds to the case that the GroundRule’ function in Algorithm 3 backtracks.\nThe grounding of Component1,1 produces no rule instances because the comparison atom 0 > 50 is false. By putting this literal first in the safe body order, the remaining rule body can be completely ignored. Next, in the grounding of Component2,1, direct shares given by facts over owns /3 are accumulated, where the obtained atoms over accu1/3 are classified as facts as well. Then, we trace the grounding of Component3,1. In the first iteration, none of the rules produces instances because there are no atoms over controls /2 and aggr1/2 yet. Hence, aggregate propagation is triggered, resulting in aggregate atoms aggr 1(c1, c2) and aggr1(c3, c4), for which enough shares have been accumulated upon grounding Component2,1. Note that, since the aggregate is monotone, both atoms are established as facts. In the second iteration, the newly obtained aggregate atoms are used to instantiate the second rule of the component, leading to new atoms over controls /2. Observe that, by putting aggr 1(X,Y ) first in the safe body order, GroundRule can instantiate the rule without backtracking. In the third iteration, the newly obtained atoms over controls /2 yield accu1(c1, c3, t(35, c2)) via an instance of the third rule of the component, which in turn leads to the aggregate atom aggr 1(c1, c3). The following iterations proceed in a similar fashion until no new tuples are accumulated and the grounding loop terminates. Confined to the original predicate controls /2, the instantiation generates four atoms, controls(c1, c2), controls(c3, c4), controls(c1, c3), and controls(c1, c4), all of which are produced as facts.\nNote that the utilized safe body order affects the amount of backtracking in rule instantiation [11]. One particular strategy used in gringo is to prefer recursive atoms with subscript n when ordering a rule body. As seen in the grounding of Component3,1 above, this helps to avoid backtracking upon generating new rule instances. Furthermore, for the company controls encoding, simplifications ensure that the program is evaluated to facts. In general, this is guaranteed for programs with stratified negation and monotone aggregates only [12]."
    }, {
      "heading" : "5 Discussion",
      "text" : "We presented an algorithmic framework for grounding logic programs based on semi-naive database evaluation techniques. Our framework, which is implemented in gringo series 4, constitutes the first approach capturing full-fledged aggregates under Ferraris’ semantics [13,6]. While semi-naive evaluation techniques trace back to the field of database systems [3,4], their introduction to grounding in ASP was pioneered by the dlv system [14], laying out basic semi-naive grounding algorithms (cf. [1]) similar to those in Section 3. Given this proximity, our grounding techniques for handling recursive aggregates could be adopted within dlv, which is so far restricted to strati-\nfied aggregates. Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2]. The latter two also support recursive (convex) aggregates but are limited by the necessity to bind non-global variables by domain predicates, given that programs have to be ω- [16] or λ-restricted [17], respectively. Unlike this, our approach merely relies on the safety condition and no further restriction is imposed on the input language.\nRegarding the implementation, our approach aims at reusing existing grounding techniques for (normal) logic programs. To this end, programs with aggregates are rewritten, and conventional semi-naive evaluation is extended with a propagation step for aggregates. Eventually, ground aggregates are reconstructed from the obtained rule instances in a post-processing step. While the present paper considered sum and sum+ aggregates only, our approach is applicable to any aggregate function. In fact, count , min , and max aggregates are also supported in gringo series 4, and it is easily amenable to further aggregates (by extending the Propagate function).\nAcknowledgments This work was funded by AoF (grant 251170), DFG (grants SCHA 550/8 and 550/9), as well as DAAD and AoF (joint project 57071677/ 279121)."
    } ],
    "references" : [ {
      "title" : "Advances in gringo series 3",
      "author" : [ "M. Gebser", "R. Kaminski", "A. König", "T. Schaub" ],
      "venue" : "In Delgrande, J., Faber, W., eds.: Proceedings of the Eleventh International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’11). Springer-Verlag",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Principles of Database and Knowledge-Base Systems",
      "author" : [ "J. Ullman" ],
      "venue" : "Computer Science Press",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Foundations of Databases",
      "author" : [ "S. Abiteboul", "R. Hull", "V. Vianu" ],
      "venue" : "Addison-Wesley",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "The magic of duplicates and aggregates",
      "author" : [ "I. Mumick", "H. Pirahesh", "R. Ramakrishnan" ],
      "venue" : "In McLeod, D., Sacks-Davis, R., Schek, H., eds.: Proceedings of the Sixteenth International Conference on Very Large Data Bases (VLDB’90). Morgan Kaufmann Publishers",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Abstract Gringo",
      "author" : [ "M. Gebser", "A. Harrison", "R. Kaminski", "V. Lifschitz", "T. Schaub" ],
      "venue" : "Theory and Practice of Logic Programming 15(4-5)",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25(3-4)",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V. Marek", "M. Truszczyński" ],
      "venue" : "In Apt, K., Marek, V., Truszczyński, M., Warren, D., eds.: The Logic Programming Paradigm: A 25-Year Perspective. Springer-Verlag",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Answer Set Solving in Practice",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "T. Schaub" ],
      "venue" : "Morgan and Claypool Publishers",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Unfounded sets and well-founded semantics of answer set programs with aggregates",
      "author" : [ "M. Alviano", "F. Calimeri", "W. Faber", "N. Leone", "S. Perri" ],
      "venue" : "Journal of Artificial Intelligence Research 42",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Logic programs with propositional connectives and aggregates",
      "author" : [ "P. Ferraris" ],
      "venue" : "ACM Transactions on Computational Logic 12(4)",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7(3)",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Grounding FO and FO(ID) with bounds",
      "author" : [ "J. Wittocx", "M. Mariën", "M. Denecker" ],
      "venue" : "Journal of Artificial Intelligence Research 38",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Gringo: A new grounder for answer set programming",
      "author" : [ "M. Gebser", "T. Schaub", "S. Thiele" ],
      "venue" : "In Baral, C., Brewka, G., Schlipf, J., eds.: Proceedings of the Ninth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’07). Springer-Verlag",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "On the input language of ASP grounder gringo",
      "author" : [ "M. Gebser", "R. Kaminski", "M. Ostrowski", "T. Schaub", "S. Thiele" ],
      "venue" : "In Erdem, E., Lin, F., Schaub, T., eds.: Proceedings of the Tenth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’09). Springer-Verlag",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Correct Reasoning: Essays on Logic-Based AI in Honour of Vladimir Lifschitz",
      "author" : [ "E. Erdem", "J. Lee", "Y. Lierler", "D. Pearce", "eds." ],
      "venue" : "Springer-Verlag",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Proceedings of the Sixth International Conference on Logic Programming and Nonmonotonic Reasoning (LPNMR’01)",
      "author" : [ "T. Eiter", "W. Faber", "M. Truszczyński", "eds." ],
      "venue" : "Springer-Verlag",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2001
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Modern grounders like (the one in) dlv [1] or gringo [2] are based on semi-naive database evaluation techniques [3,4] for avoiding duplicate work during grounding.",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 1,
      "context" : "Modern grounders like (the one in) dlv [1] or gringo [2] are based on semi-naive database evaluation techniques [3,4] for avoiding duplicate work during grounding.",
      "startOffset" : 112,
      "endOffset" : 117
    }, {
      "referenceID" : 2,
      "context" : "Modern grounders like (the one in) dlv [1] or gringo [2] are based on semi-naive database evaluation techniques [3,4] for avoiding duplicate work during grounding.",
      "startOffset" : 112,
      "endOffset" : 117
    }, {
      "referenceID" : 3,
      "context" : "An example of such an aggregate is shown in Table 1, giving an encoding of the Company Controls Problem [5]: A company X controls a company Y , if X directly or indirectly controls more than 50% of the shares of Y .",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 4,
      "context" : "Section 2 starts with recalling the formal preliminaries from [6].",
      "startOffset" : 62,
      "endOffset" : 65
    }, {
      "referenceID" : 4,
      "context" : "This section recalls the formal preliminaries regarding the syntax and semantics of gringo’s input language, developed in [6].",
      "startOffset" : 122,
      "endOffset" : 125
    }, {
      "referenceID" : 4,
      "context" : "– in a simple literal, if it occurs in the literal – in an aggregate literal, if it occurs in the guard – in a rule, if it is global in the head or a body literal 7 gringo as well as its semantic underpinnings in [6] also allow for double negated literals of form ∼∼a.",
      "startOffset" : 213,
      "endOffset" : 216
    }, {
      "referenceID" : 5,
      "context" : "The resulting Hamiltonian cycle is expressed through instances of predicate path/2; a detailed discussion of such encodings can be found in [8,9,10].",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 6,
      "context" : "The resulting Hamiltonian cycle is expressed through instances of predicate path/2; a detailed discussion of such encodings can be found in [8,9,10].",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 7,
      "context" : "The resulting Hamiltonian cycle is expressed through instances of predicate path/2; a detailed discussion of such encodings can be found in [8,9,10].",
      "startOffset" : 140,
      "endOffset" : 148
    }, {
      "referenceID" : 8,
      "context" : "In general, this is guaranteed for programs with stratified negation and monotone aggregates only [12].",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 9,
      "context" : "Our framework, which is implemented in gringo series 4, constitutes the first approach capturing full-fledged aggregates under Ferraris’ semantics [13,6].",
      "startOffset" : 147,
      "endOffset" : 153
    }, {
      "referenceID" : 4,
      "context" : "Our framework, which is implemented in gringo series 4, constitutes the first approach capturing full-fledged aggregates under Ferraris’ semantics [13,6].",
      "startOffset" : 147,
      "endOffset" : 153
    }, {
      "referenceID" : 1,
      "context" : "While semi-naive evaluation techniques trace back to the field of database systems [3,4], their introduction to grounding in ASP was pioneered by the dlv system [14], laying out basic semi-naive grounding algorithms (cf.",
      "startOffset" : 83,
      "endOffset" : 88
    }, {
      "referenceID" : 2,
      "context" : "While semi-naive evaluation techniques trace back to the field of database systems [3,4], their introduction to grounding in ASP was pioneered by the dlv system [14], laying out basic semi-naive grounding algorithms (cf.",
      "startOffset" : 83,
      "endOffset" : 88
    }, {
      "referenceID" : 10,
      "context" : "While semi-naive evaluation techniques trace back to the field of database systems [3,4], their introduction to grounding in ASP was pioneered by the dlv system [14], laying out basic semi-naive grounding algorithms (cf.",
      "startOffset" : 161,
      "endOffset" : 165
    }, {
      "referenceID" : 11,
      "context" : "Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2].",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 12,
      "context" : "Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2].",
      "startOffset" : 97,
      "endOffset" : 106
    }, {
      "referenceID" : 13,
      "context" : "Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2].",
      "startOffset" : 97,
      "endOffset" : 106
    }, {
      "referenceID" : 0,
      "context" : "Other grounding approaches are pursued in gidl [15], lparse [16], and earlier versions of gringo [17,18,2].",
      "startOffset" : 97,
      "endOffset" : 106
    }, {
      "referenceID" : 12,
      "context" : "The latter two also support recursive (convex) aggregates but are limited by the necessity to bind non-global variables by domain predicates, given that programs have to be ω- [16] or λ-restricted [17], respectively.",
      "startOffset" : 197,
      "endOffset" : 201
    } ],
    "year" : 2016,
    "abstractText" : "Problem solving in Answer Set Programming consists of two steps, a first grounding phase, systematically replacing all variables by terms, and a second solving phase computing the stable models of the obtained ground program. An intricate part of both phases is the treatment of aggregates, which are popular language constructs that allow for expressing properties over sets. In this paper, we elaborate upon the treatment of aggregates during grounding in gringo series 4. Consequently, our approach is applicable to grounding based on semi-naive database evaluation techniques. In particular, we provide a series of algorithms detailing the treatment of recursive aggregates and illustrate this by a running example.",
    "creator" : "LaTeX with hyperref package"
  }
}