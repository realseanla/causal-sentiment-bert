{
  "name" : "1412.1505.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Symmetric Weighted First-Order Model Counting",
    "authors" : [ "Paul Beame", "Guy Van den Broeck", "KU Leuven", "Eric Gribkoff", "Dan Suciu" ],
    "emails" : [ "beame@cs.washington.edu", "guy.vandenbroeck@cs.kuleuven.be", "eagribko@cs.washington.edu", "suciu@cs.washington.edu" ],
    "sections" : [ {
      "heading" : "1. INTRODUCTION",
      "text" : "Probabilistic inference is becoming a central data management problem. Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft’s Probase [43] or Google’s Knowledge Vault [8], have millions to billions of uncertain tuples. These systems scan large corpora of text, such as the Web or complete collections of journal articles, and extract automatically billions of structured facts, representing large collections of knowledge. For an illustration, Google’s Knowledge Vault [8] contains 1.6B triples of the form (subject, predicate, object), for example, </m/02mjmr, /people/person/place_of_birth /m/02hrh0_> where /m/02mjmr is the Freebase id for Barack Obama, and /m/02hrh0_ is the id for Honolulu [8]. The triples are extracted automatically from\nTo appear at PODS’15, May 31–June 4, 2015, Melbourne, Victoria, Australia. .\nthe Web, and each triple is annotated with a probability p representing the confidence in the extraction.\nA central and difficult problem in such systems is probabilistic inference, or, equivalently weighted model counting. The classical FO Model Counting problem (FOMC) is: given a sentence Φ in First-Order Logic (FO) and a number n, compute the number of structures over a domain of size n that satisfy the sentence Φ; in this paper we consider only labeled structures, i.e. isomorphic structures are counted as distinct. We denote the number of models by FOMC(Φ, n), for example FOMC(∀x∃yR(x, y), n) = (2n − 1)n.1 In the Weighted FO Model Counting (WFOMC) variant, one further associates a real number w(t) called weight to each tuple t over the domain of size n, and defines the weight of a structure as the product of the weights of all tuples in that structure. The Weighted Model Count WFOMC(Φ, n,w) is defined as the sum of the weights of all structures over a domain of size n that satisfy the sentence Φ. Weights map immediately to probabilities, in the following way: if each tuple t is included in the database independently with probability w(t)/(1 + w(t)), then the probability that a formula Φ is true is Pr(Φ) = WFOMC(Φ, n,w)/WFOMC(true, n,w), where WFOMC(true, n,w) = ∏ t(1 + w(t)) is the sum of weights of all structures. In this paper we study the symmetric WFMOC problem, where all tuples from the same relation have the same weight, which we denote wi. For example, a random graph G(n, p) is a symmetric structure, since every edge is present with the same probability p (equivalently: has weight p/(1 − p)), and FOMC is another special case where all weights are set to 1. The symmetric WFMOC problem occurs naturally in Knowledge Bases with soft constraints, as we illustrate next.\nExample 1.1. A Markov Logic Network (MLN) [7] is a finite set of soft or hard constraints. Each constraint is a pair (w,ϕ), where ϕ is a formula, possibly with free variables x, and w ∈ [0,∞] is a weight2. For example, 1For a fixed x, there are 2n assignments to R(x, y), which all satisfy ∃yR(x, y), except the one where all atoms are false. Moreover, the models for the n values of x can be counted independently and multiplied. 2In typical MLN systems, users specify the log of the weight rather than the weight. The pair (1.098, ϕ) means that the weight of ϕ is w = exp(1.098) ≈ 3. Using logs simplifies the learning task. We do not address learning and will omit logs; (w,ϕ) means that ϕ has weight w.\nar X\niv :1\n41 2.\n15 05\nv3 [\ncs .D\nB ]\n1 J\nun 2\n01 5\nthe soft constraint\n(3,Spouse(x, y) ∧ Female(x)⇒ Male(y)) (1) specifies that, typically, a female’s spouse is male, and associates the weight w = 3 to this constraint. If w = ∞ then we call (w,ϕ) a hard constraint.\nThe semantics of MLNs naturally extend the Weighted Model Counting setting. Given a finite domain (set of constants), an MLN defines a probability distribution over all structures for that domain (also called possible worlds). Every structure D has a weight\nW (D) = ∏\n(w,ϕ(x))∈MLN,a∈D|x|:w<∞∧D|=ϕ[a/x] w\nIn other words, for each soft constraint (W,ϕ), and for every tuple of constants a such that ϕ(a) holds in D, we multiply D’s weight by w. For example, given the MLN that consists only of the soft constraint (1), the weight of a world D is 3N , where N is the number of pairs of constants a, b for which Spouse(a, b),Female(a) ⇒ Male(b) holds in D. The weight W (Φ) of a sentence Φ is defined as the sum of weights of all worlds D that satisfy both Φ and all hard constraints in the MLN; its probability is obtained by normalizing PrMLN (Φ) = W (Φ)/W (true). Notice that the symmetric WFOMC problem corresponds to the special case of an MLN consisting of one soft constraint (wi, Ri(xi)) for each relation Ri, where |xi| = arity(Ri).\nToday’s MLN systems (Alchemy [26], Tuffy [30, 44]) use an MCMC algorithm called MC-SAT [31] for probabilistic inference. The theoretical convergence guarantees of MC-SAT require access to a uniform sampler over satisfying assignments to a set of constraints. In practice, MC-SAT implementations rely on SampleSAT [42], which provides no guarantees on the uniformity of solutions. Several complex examples are known in the literature where model counting based on SampleSAT leads to highly inaccurate estimates [16].\nA totally different approach to computing PrMLN (Φ) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper. We review here briefly one such reduction, adapting from [22, 37].\nExample 1.2. Given an MLN, replace every soft constraint (w,ϕ(x)) by two new constraints: (∞,∀x(R(x)∨ ϕ(x))) and (1/(w − 1), R(x)). Here R is a new relational symbol with the same arity as the number of free variables in ϕ, and the constraint (1/(w−1), R(x)) defines R as a relation where all tuples have weight 1/(w − 1). Therefore, the probability of a formula Φ in the MLN can be computed as a conditional probability over a symmetric, tuple-independent database: PrMLN (Φ) = Pr(Φ|Γ), where Γ is the conjunction of all hard constraints3. Note that this reduction to WFOMC is independent of the finite domain under consideration. 3The reason why this works is the following: in original MLN, each tuple a contributes to W (D) a factor of 1 or w, depending on whether ϕ(a) is false or true in D; after the rewriting, the contribution of a is 1/(w−1) when ϕ(a) is false, because in that case R(a) must be true, or 1 + 1/(w − 1) = w/(w−1) when ϕ(a) is true, because R(a) can be either false or true. The ratio is the same 1 : w = [1/(w−1)] : [w/(w−1)].\nFor example, the soft constraint in (1) is translated into the hard constraint:\n∀x, y(R(x, y) ∨ ¬Spouse(x, y) ∨ ¬Female(x) ∨Male(y)) and a tuple-independent probabilistic relation R where all tuples have weight 1/(3− 1) = 1/2, or, equivalently, have probability (1/2)/(1 + (1/2)) = 1/3.\nThus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41]. Some tasks on MLNs, such as parameter learning [38], naturally exhibit symmetries. For others, such as computing conditional probabilities given a large “evidence” database, the symmetric WFOMC model is applicable when the database has bounded Boolean rank [36]. Moreover, the problem is of independent theoretical interest as we explain below. We study both the data complexity, and the combined complexity. In both settings we assume that the vocabulary σ = (R1, . . . , Rm) is fixed, and so are the weights w = (w1, . . . , wm) associated with the relations. In data complexity, the formula Φ is fixed, and the only input is the number n representing the size of the domain. In this case WFOMC is a counting problem over a unary alphabet: given an input 1n, compute WFOMC(Φ, n,w). It is immediate that this problem belongs to the class #P1, which is the set of #P problems over a unary input alphabet [34]. In the combined complexity, both n and the formula Φ are input.\nIn this paper we present results on the data complexity and the combined complexity of the FOMC and WFOMC problem, and also some results on the associated decision problem."
    }, {
      "heading" : "Results on Data Complexity",
      "text" : "In a surprising result [37] has proven that for FO2 the data complexity of symmetric WFOMC is in PTIME (reviewed in Appendix C).4 This is surprising because FO2 (the class of FO formulas restricted to two logical variables) contains many formulas for which the asymmetric problem was known to be #P-hard. An example is Φ = ∃x∃y(R(x) ∧ S(x, y) ∧ T (y)), which is #P-hard over asymmetric structures, but the number of models\nis5 22n+n 2 −∑k,m (nk)(nm)2n2−km, which is a number computable in time polynomial in n.6 More generally, the symmetric WFOMC problem for Φ is in PTIME.\nThis begs the question: could it be the case that every FO formula is in PTIME? The answer was shown to be negative by Jaeger and Van den Broeck [21, 20], using the following argument. Recall that the spectrum, Spec(Φ), of a formula Φ is the set of numbers n for which Φ has a model over a domain of size n [9]. Jaeger and Van den Broeck observed that the spectrum membership problem, “is n ∈ Spec(Φ)?”, can be reduced to WFOMC, by checking whether FOMC(Φ, n) > 0.\n4PTIME data complexity for symmetric WFOMC is called domain-liftability in the AI and lifted inference literature [35]. 5Fix the relations R, T , and let their cardinalities be |R| = k and |T | = m. Then the structure does not satisfy Φ iff S contains none of the km tuples in R×T , proving the formula. 6Tractability of Φ was noted before in, for example [32, 35].\nThen, using a result in [23], if ETIME 6= NETIME, then there exists a formula Φ for which computing WFOMC is not in polynomial time7. However, no hardness results for the symmetric WFOMC were known to date.\nWhat makes the data complexity of the symmetric WFOMC difficult to analyze is the fact that the input is a single number n. Valiant already observed in [34] that such problems are probably not candidates for being #P-complete. Instead, he defined the complexity class #P1, to be the set of counting problems for NP computations over a single-letter input alphabet. Very few hardness results are known for this class: we are aware only of a graph matching problem that was proven by Valiant, and of a language-theoretic problem by Bertoni and Goldwurm [1].\nOur data complexity results are the following. First, we establish the existence of an FO sentence Θ1 for which the data complexity of the FOMC problem is #P1-hard; and we also establish the existence of a conjunctive query Υ1 for which the data complexity of the WFOMC problem is #P1-hard. Second, we prove that every γ-acyclic conjunctive query without self-joins is in polynomial time, extending the result in [37] from FO2 to γ-acyclic conjunctive queries. We give now more details about our results, and explain their significance.\nThe tractability for FO2 [37] raises a natural question: do other restrictions of FO, like FOk for k ≥ 3, also have polynomial data complexity? By carefully analyzing the details of the construction of Θ1 we prove that it is actually in FO3. This implies a sharp boundary in the FOk hierarchy where symmetric WFOMC transitions from tractable to intractable: for k between 2 and 3. The tractability of γ-acyclic queries raises another question: could all conjunctive queries be tractable for symmetric WFOMC? We answer this also in the negative: we prove that there exists a conjunctive query Υ1 for which the symmetric WFOMC problem is #P1-hard. It is interesting to note that the decision problem associated to WFOMC, namely given n, does n ∈ Spec(Φ)? is trivial for conjunctive queries, since every conjunctive query has a model over any domain of size n ≥ 1. Therefore, our #P1-hardness result for Υ1 is an instance where the decision problem is easy while the corresponding weighted counting problem is hard. We note that, unlike WFOMC, we do not know the exact complexity of the unweighted, FOMC problem for conjunctive queries.\n0-1 Laws. Our data complexity hardness result sheds some interesting light on 0-1 laws. Recall that, if C is a class of finite structures and P is a property over these structures, then µn(P ) denotes the fraction of labeled8 structures in C over a domain of size n that satisfy the property P [27]. A logic has a 0-1 law over the class of structures C, if for any property P\n7Recall that ETIME = ⋃\nc≥1 DTIME(2 cn) and NETIME =⋃\nc≥1 NTIME(2 cn), and are not to be confused with the more familiar classes EXPTIME and NEXPTIME, which are⋃ c≥1 DTIME(2 nc) and ⋃ c≥1 NTIME(2 nc) respectively. 8The attribute labeled means that isomorphic structures are counted as distinct; 0-1 laws for unlabeled structures also exist. In this paper, we discuss labeled structures only.\nexpressible in that logic, µ(P ) def = limn→∞ µn(P ) is either 0 or 1. Fagin [13] proved a 0-1 law for First-Order logic and all structures, by using an elegant transfer theorem: there exists a unique, countable structure R, which is characterized by an infinite set of extension axioms, τ . He proved that, for every extension axiom, limµn(τ) = 1, and this implies limµn(Φ) = 1 if Φ is true in R, and limµn(Φ) = 0 if Φ is false in R. Compton [3] proved 0-1 laws for several classes of structures C. A natural question to ask is the following: does there exists an elementary proof of the 0-1 laws, by computing a closed formula FOMC(Φ, n) for every Φ, then using elementary calculus to prove that that µn(Φ) converges to 0 or 1? For example, if Φ = ∀x∃yR(x, y), then FOMC(Φ, n) = (2n − 1)n and µn(Φ) = (2\nn − 1)n/2n2 → 0; can we repeat this argument for every Φ? On a historical note, Fagin confirms in personal communication that he originally tried to prove the 0-1 law by trying to find such a closed formula, which failed as an approach. Our #P1-result for FO proves that no such elementary proof is possible, because no closed formula for FOMC(Φ, n) can be computed in general (unless #P1 is in PTIME)."
    }, {
      "heading" : "Results on the Combined Complexity",
      "text" : "Our main result on the combined complexity is the following. We show that, for any k ≥ 2, the combined complexity of FOMC for FOk is #P-complete; membership is a standard application of Scott’s reduction, while hardness is by reduction from the model counting problem for Boolean formulas. Recall that the vocabulary σ is always assumed to be fixed: if it were allowed to be part of the input, then every Boolean formula is a special case of an FO0 formula, by creating a new relational symbol of arity zero for each Boolean variable, and all hardness results for Boolean formulas carry over immediately to FO0."
    }, {
      "heading" : "The Associated Decision Problem",
      "text" : "We also discuss and present some new results on the decision problem associated with (W)FOMC: “given Φ, n, does Φ have a model over a domain of size n?”. The data complexity variant is, of course, the spectrum membership problem, which has been completely solved by Jones and Selman [23], by proving that the class of spectra coincides with NETIME, that is, {Spec(Φ) | Φ ∈ FO} = NETIME. Their result assumes that the input n is represented in binary, thus the input size is log n. In this paper we are interested in the unary representation of n, as 1n, which is also called the tally notation, in which case case NETIME naturally identifies with NP1. Fagin proved that, in the tally notation, {Spec(Φ) | Φ ∈ FO} = NP1 [12, Theorem 6, Part 2].\nFor the decision problem, our result is for the combined complexity: given both Φ, n, does n ∈ Spec(Φ)? We prove that this problem is NP-complete for FO2, and PSPACE-complete for FO. The first of these results has an interesting connection to the finite satisfiability problem for FO2, which we discuss here. Recall the classical satisfiability problem in finite model theory: “given a formula Φ does it have a finite model?”, which is equivalent to checking Spec(Φ) 6= ∅. Grädel, Kolaitis and Vardi [17] have proven the following two\nresults for FO2: if a formula Φ is satisfiable then it has a finite model of size at most exponential in the size of the sentence Φ, and deciding whether Φ is satisfiable is NEXPTIME-complete in the size of Φ. These two results already prove that the combined complexity for deciding n ∈ Spec(Φ) cannot be in polynomial time: otherwise, we could check satisfiability in EXPTIME by iterating n from 1 to exponential in the size of Φ, and checking n ∈ Spec(Φ). Our result settles the combined complexity, proving that it is NP-complete.\nThe paper is organized as follows: we introduce the basic definitions in Section 2, present our results for the data complexity of the FOMC and WFOMC problems in Section 3, present all results on the combined complexity in Section 4, then conclude in Section 5."
    }, {
      "heading" : "2. BACKGROUND",
      "text" : "We review here briefly the main concepts, some already introduced in Section 1.\nWeighted Model Counting (WMC). The Model Counting problem is: given a Boolean formula F , compute the number of satisfying assignments #F . In Weighted Model Counting we are given two real functions w, w̄ : Vars(F ) → R associating two weights w(X), w̄(X) to each variable in Vars(F ) = {X1, . . . , Xn}. The weighted model count WMC(F,w, w̄) is defined as:\nWMC(F,w, w̄) def = ∑ θ:θ(F )=1 W (θ) (2)\nwhere, ∀θ : Vars(F )→ {0, 1}:\nW (θ) def = ∏ i:θ(Xi)=0 w̄(Xi)× ∏ i:θ(Xi)=1 w(Xi) (3)\nThe model count is a special case #F = WMC(F, 1, 1).\nThe standard definition of WMC in the literature does not mention w̄, instead sets w̄ = 1; as we will see, our extension is non-essential. When w̄ = 1, then we simply drop w̄ from the notation, and write WMC(F,w) instead of WMC(F,w, 1). In the probability computation problem, each variable Xi is set to true with some known probability p(Xi) ∈ [0, 1], and we want to compute Pr(F, p) def = WMC(F, p, 1− p), the probability that F is true. All these variations are equivalent, because of the following identities:\nWMC(F,w, w̄) = WMC(F,w/w̄, 1)× ∏ i w̄(Xi) (4)\nWMC(F,w, w̄) = Pr(F,w/(w + w̄))× ∏ i (w(Xi) + w̄(Xi)) Throughout the paper we write 1 for the constant function with value 1, and w1 +w2, and w1/w2 for functions X 7→ w1(X) + w2(X) and X 7→ w1(X)/w2(X) resp."
    }, {
      "heading" : "Weighted First-Order Model Counting (WFOMC).",
      "text" : "Consider FO formulas over a fixed relational vocabulary σ = (R1, . . . , Rm) and equality =. Given a domain size n, denote Tup(n) the set of ground tuples (i.e., ground atoms without equality) over the domain, thus\n|Tup(n)| = ∑i narity(Ri). The lineage of an FO sentence Φ refers to a Boolean function FΦ,n over Tup(n) (a ground FO sentence), as well as the corresponding Boolean function over propositional variables referring to ground tuples (a propositional sentence). It is defined inductively by Ft,n = t for ground tuples t, F¬Φ,n = ¬FΦ,n, F(Φ1 op Φ2),n = FΦ1,n op FΦ2,n for op ∈ {∧,∨}, Fa=b,n = false, Fa=a,n = true and F∃xΦ,n = ∨ a∈[n] FΦ[a/x],n, F∀xΦ,n = ∧ a∈[n] FΦ[a/x],n. For any fixed sentence Φ, the size of its lineage is polynomial in n. Given a domain size n and weight functions w, w̄ : Tup(n) → R, the Weighted FirstOrder Model Count of Φ is WFOMC(Φ, n, w, w̄) def = WMC(FΦ,n, w, w̄).\nSymmetric WFOMC. In the symmetric WFOMC, the weight of a tuple depends only on the relation name and not on the domain constants. We call a weighted vocabulary a triple (σ,w, w̄) where σ = (R1, . . . , Rm) is a relational vocabulary and w = (w1, . . . , wm), w̄ = (w̄1, . . . , w̄m) represent the weights (real numbers) for the relational symbols. For any domain size n, we extend these weights to Tup(n) by setting w′(Ri(a1, . . . , ak)) = wi and w̄ ′(Ri(a1, . . . , ak)) = w̄i, and we define WFOMC(Φ, n,w, w̄) def = WFOMC(Φ, n, w′, w̄′). Throughout this paper we assume that WFOMC refers to the symmetric variant, unless otherwise stated.\nFor a simple illustration, consider the sentence ϕ = ∃yS(y). Then WFOMC(ϕ, n,wS , w̄S) = (w̄S + wS)n − (w̄S)\nn, because the sum of the weights of all possible worlds is (w̄S + wS)\nn, and we have to subtract the weight of the world where S = ∅. For another example, consider Φ = ∀x∃yR(x, y). The reader may check that WFOMC(Φ, n, wR, w̄R) = ((wR + w̄R) n − w̄nR) n. In particular, over a domain of size n, the formula Φ has (2n − 1)n models (by setting wR = w̄R = 1).\nData Complexity and Combined Complexity. We consider the weighted vocabulary (σ,w, w̄) fixed. In the data complexity, we fix Φ and study the complexity of the problem: given n, compute WFOMC(Φ, n,w, w̄). In the combined complexity, we study the complexity of the problem: given Φ, n, compute WFOMC(Φ, n,w, w̄). All our upper bounds continue to hold if the weights w, w̄ are part of the input. We also consider the data- and combined-complexity of the associated decision problem (where we ignore the weights) given n, does Φ have a model over a domain of size n?\nWeights and Probabilities. While in practical applications the weights are positive real numbers, and the probabilities are numbers in [0, 1], in this paper we impose no restrictions on the values of the weights and probabilities. The definition (2) of WMC(F,w) applies equally well to negative weights, and, in fact, to any semiring structure for the weights [25]. There is, in fact, at least one application of negative probabilities [22], namely the particular reduction from MLNs to WFOMC described in Example 1.2: a newly introduced relation has weight 1/(w − 1), which is negative when\nw < 1. Then, the associated probability p = w/(1 +w) belongs to (−∞, 0) ∪ (1,∞).\nAs a final comment on negative weights, we note that the complexity of the symmetric WFOMC problem is the same for arbitrary weights as for positive weights. Indeed, the expression WFOMC(Φ, n,w) is a multivariate polynomial in m variables w1, . . . , wm, where each variable has degree n. The polynomial has (n + 1)m = nO(1) real coefficients. Given access to an oracle computing this polynomial for arbitrary positive values for w, we can compute in polynomial time all nO(1) coefficients with as many calls to the oracle; once we know the coefficients we can compute the polynomial at any values w1, . . . , wm, positive or negative.\nFor all upper bounds in this paper we assume that the weights w, w̄, or probabilities p, are given as rational numbers represented as fractions of two integers of n bits each. We assume w.l.o.g. that all fractions have the same denominator: this can be enforced by replacing the denominators by their least common multiplier, at the cost of increasing the number of bits of all integers to at most n2. It follows that the weight of a world W (θ) (Eq.(3)) and WMC(F,w, w̄) can be represented as ratios of two integers, each with nO(1) bits.\nSummary. Table 1 summarizes the taxonomy and illustrates the various weighted model counting problems considered in this paper. Throughout the rest of the paper, FOMC and WFOMC refer to the symmetric variant, unless otherwise mentioned."
    }, {
      "heading" : "3. DATA COMPLEXITY",
      "text" : "Recall that the language FOk consists of FO formulas with at most k distinct logical variables."
    }, {
      "heading" : "3.1 Lower Bounds",
      "text" : "Our first lower bound is for an FO3 sentence:\nTheorem 3.1. There exists an FO3 sentence, denoted Θ1, s.t. the FOMC problem for Θ1 is #P1-complete.\nVan den Broeck et al. [37] have shown that the Symmetric WFOMC problem for every FO2 formula has polynomial time data complexity (the proof is reviewed in Appendix C); Theorem 3.1 shows that, unless #P1 is in PTIME, the result cannot extend to FOk for k > 2.\nOur second lower bound is for a conjunctive query, or, dually, a positive clause without equality. Recall that a clause is a universally quantified disjunction of literals,\nfor example ∀x∀y(R(x)∨¬S(x, y)). A positive clause is a clause where all relational atoms are positive. A conjunctive query (CQ) is an existentially quantified conjunction of positive literals, e.g. ∃x∃y(R(x) ∧ S(x, y)). Positive clauses without the equality predicate are the duals of CQs, and therefore the WFOMC problem is essentially the same for positive clauses without equality as for CQs. Note that the dual of a clause with the equality predicate is a CQ with 6=, e.g. the dual of ∀x∀y(R(x, y) ∨ x = y) is ∃x∃y(R(x, y) ∧ x 6= y). Corollary 3.2. There exists a positive clause Ξ1 without equality s.t. the Symmetric WFOMC problem for Ξ1 is #P1-hard. Dually, there exists a CQ Υ1 s.t. the Symmetric WFOMC problem for Υ1 is #P1-hard.\nCorollary 3.2 shows that the tractability result for γ-acyclic conjunctive queries (discussed below in Theorem 3.6) cannot be extended to all CQs. The proof of the Corollary follows easily from three lemmas, which are of independent interest, and which we present here; the proofs of the lemmas are in the appendix. We say that a vocabulary σ′ extends σ if σ ⊆ σ′, and that a weighted vocabulary (σ′,w′, w̄′) extends (σ,w, w̄) if σ ⊆ σ′ and the tuples w′, w̄′ extend w, w̄. Lemma 3.3. Let (σ,w, w̄) be a weighted vocabulary and Φ an FO sentence over σ. There exists an extended weighted vocabulary (σ′,w′, w̄′) and sentence Φ′ over σ′, such that Φ′ is in prenex-normal form with a quantifier prefix ∀∗, and WFOMC(Φ, n,w, w̄) = WFOMC(Φ′, n,w′, w̄′) for all n.\nThis lemma was proven by [37], and says that all existential quantifiers can be eliminated. The main idea is to replace a sentence of the form ∀x ∃y ψ(x, y) by ∀x ∀y (¬ψ(x, y) ∨ A(x)), where A is a new relational symbol of arity |x| and with weights wA = 1, w̄A = −1. For every value x = v, in a world where ∃y ψ(v, y) holds, A(v) holds too and the new symbol contributes a factor +1 to the weight; in a world where ∃y ψ(v, y) does not hold, then A(v) may be true or false, and the weights of the two worlds cancel each other out.\nNote that the lemma tells us nothing about the model count of Φ and Φ′, since in Φ′ we are forced to set some negative weights. If we had FOMC(Φ, n) = FOMC(Φ′, n), then we could reduce the satisfiability problem for an arbitrary FO sentence Φ to that for a sentence with a ∀∗ quantifier prefix, which is impossible, since the former is undecidable while the latter is decidable.\nThe next lemma, also following the proof in [37], says that all negations can be eliminated.\nLemma 3.4. Let (σ,w, w̄) be a weighted vocabulary and Φ a sentence over σ in prenex-normal form with quantifier prefix ∀∗. Then there exists an extended weighted vocabulary (σ′,w′, w̄′) and a positive FO sentence Φ′ over σ′, also in prenex-normal form with quantifier prefix ∀∗, s.t. WFOMC(Φ, n,w, w̄) = WFOMC(Φ′, n,w′, w̄′) for all n.\nThe idea is to create two new relational symbols A,B for every negated subformula ¬ψ(x), replace the formula by A(x), and add the sentence ∀x(ψ(x)∨A(x))∧ (A(x) ∨B(x)) ∧ (ψ(x) ∨B(x)). By setting the weights wA = w̄A = wB = 1, w̄B = −1 we ensure that, for every constant x = v, either ¬ψ(v) ≡ A(v), in which case B(v) is forced to be true and the two new symbols contribute a factor +1 to the weight, or ψ(v) ≡ A(v) ≡ true, in which case B(v) can be either true or false, and the weights cancel out.\nFinally, we remove the = predicate.\nLemma 3.5. Let (σ,w, w̄) be a weighted vocabulary and Φ a sentence over σ. Then there exists an extended vocabulary σ′ and sentence Φ′ without the equality predicate =, such that, for all n, WFOMC(Φ, n,w, w̄) can be computed in polynomial time using n+ 1 calls to an oracle for WFOMC(Φ′, n,w′, w̄′), where (σ′,w′, w̄′) is an extension of (σ,w, w̄).\nThe idea is to introduce a new relational symbol E, replace every atom x = y with E(x, y), and add the sentence ∀x E(x, x). Let w′, w̄′ be the extension of w, w̄ with w′E = z, w̄ ′ E = 1. Then WFOMC(Φ\n′, n,w′, w̄′) is a polynomial of degree n2 in z where each monomial has degree ≥ n in z, because the hard constraint ∀x E(x, x) forces |E| ≥ n. Moreover, the coefficient of zn is precisely WFOMC(Φ, n,w, w̄), because that corresponds to the worlds where |E| = n, hence it coincides with =. We compute this coefficient using n+ 1 calls to an oracle for WFOMC(Φ′, n,w′, w̄′).\nNow we give the proof of Corollary 3.2. Starting with the #P1-complete sentence Θ1, we apply the three lemmas and obtain a positive sentence Φ, with quantifier prefix ∀∗ and without the equality predicate, that is #P1-hard. We write it as a conjunction of clauses, Φ = C1∧C2∧· · ·∧Ck (recall that a clause is universally quantified), and then apply the inclusion-exclusion formula: Pr(Φ) = ∑ s⊆[k],s 6=∅(−1)|s|+1 Pr( ∨ i∈s Ci). Since any disjunction of clauses is equivalent to a single clause, we have reduced the computation problem Pr(Φ) to computing the probabilities of 2k − 1 clauses. By duality, this reduces to computing the probabilities of 2k−1 conjunctive queries, Pr(Q1),Pr(Q2), . . . ,Pr(Q2k−1). We can reduce this problem to that of computing the probability of a single conjunctive query Υ1, by the following argument. Create 2k − 1 copies of the relational symbols in the FO vocabulary, and take the conjunction of all queries, where each query uses a fresh copy of the vocabulary. Then Pr(Q1 ∧ · · · ∧ Q2k−1) = Pr(Q1) · · ·Pr(Q2k−1), because now every two distinct queries Qi, Qj have distinct relational symbols. Using\nan oracle to compute the probability of Υ1 def = ∧ iQi, we can compute any Pr(Qi) by setting to 1 the probabilities of all relations occurring in Qj , for j 6= i: in other words, the only possible world for a relation R\nin Qj is one where R is the cartesian product of the domain; assuming n ≥ 1, Qj is true, Pr(Qj) = 1, and hence Pr(Υ1) = Pr(Qi). We repeat this for every i and compute Pr(Q1), . . . ,Pr(Q2k−1). This proves that the CQ Υ1 is #P1-hard. Its dual, Ξ1, is a #P1-hard positive clause without equality. This proves Corollary 3.2."
    }, {
      "heading" : "3.2 Upper Bounds",
      "text" : "A CQ is without self-joins if all atoms refer to distinct relational symbols. It is standard to associate a hypergraph with CQs, where the variables are nodes, and the atoms are hyper-edges. We define a γ-acyclic conjunctive query to be a conjunctive query w/o self-joins whose associated hypergraph is γ-acyclic. We prove:\nTheorem 3.6. The data complexity of Symmetric WFOMC for γ-acyclic CQs is in PTIME.\nFagin’s definition of γ-acyclic hypergraphs [14] is reviewed in the proof of Theorem 3.6.\nAn open problem is to characterize the conjunctive queries without self-joins that are in polynomial time. While no such query has yet been proven to be hard (Υ1 in Corollary 3.2 has self-joins), it is widely believed that, for any k ≥ 3, the symmetric WFOMC problem for a typed cycle of length k, Ck = ∃x1 · · ·xk(R1(x1, x2), R2(x2, x3), . . . , Rk(xk, x1)), is hard. We discuss here several insights into finding the tractability border for conjunctive queries, summarized in Figure 1.\nThis boundary does not lie at γ-acyclicity: the query cγ = R(x, z), S(x, y, z), T (y, z) is γ-cyclic (with cycle RxSyTzR; see Fagin [14]), yet it still has PTIME data complexity. The key observation is that γ-cycles allow the last variable z to appear in all predicates, turning it into a separator variable [5], hence Pr(Q) =∏ a∈[n] Pr(Q[a/z]), which is [Pr(Q[a/z])] n by symmetry; Q[a/z] is isomorphic to the query in Table 1 and can be computed in polynomial time. A weaker notion of acyclicity, called jtdb (for join tree with disjoint branches), can be found in [10]. It also does not characterize the tractability boundary: jtdb contains the γcyclic query above, but it does not contain the PTIME query cjtdb = R(x, y, z, u), S(x, y), T (x, z), V (x, u).\nFagin [14] defines two increasingly weaker notions of acyclicity: β- and α-acyclic. α-Acyclic queries are as hard as any conjunctive query without self-joins. Indeed, if Q = ∃xϕ(x) is a conjunctive query w/o selfjoins, then the query Q′ = ∃x(A(x)∧ϕ(x)) is α-acyclic, where A is a new relational symbol, containing all variables of Q. By setting the probability of A to 1, we have Pr(Q) = Pr(Q′). Thus, if all α-acyclic queries have PTIME data complexity, then all conjunctive queries w/o self-joins have PTIME data complexity.\nFor all we know, β-acyclic queries could well coincide with the class of tractable conjunctive queries w/o self joins. We present here some evidence that all β-cyclic queries are hard, by reduction from typed cycles, Ck. For that, we need to consider a slight generalization of WFOMC for conjunctive queries w/o self-joins, were each existential variable xi ranges over a distinct domain, of size ni: the standard semantics corresponds to the special case where all domains sizes ni are equal. We prove that for any β-cyclic query Q, there exists k such that WFOMC(Ck,n,w, w̄) can be reduced to\nWFOMC(Q,n′,w′, w̄′). Hence, the existence of a βcyclic query with PTIME data complexity would imply PTIME data complexity for at least one Ck (informally called Ck-hardness in Fig. 1). The reduction is as follows. By definition, a β-cyclic query Q contains a weak β-cycle [14] of the form R1x1R2x2 . . . xk−1RkxkRk+1, where k ≥ 3, all xi and Ri are distinct, each xi occurs in both Ri and Ri+1, but in no other Rj , and Rk+1 = R1. Then, we reduce the WFOMC for Ck to that of Q. First, for each relational symbol Rj in Q, if Rj appears in the cycle then we define w ′ j = wj and w̄′j = w̄j , otherwise w ′ j = w̄ ′ j = 1. Second, for all variables xi that appear in the cycle we set their domain size ni to be the same as that of the corresponding variable in Ck, otherwise we set ni = 1. Then Q and Ck have the same WFOMC.\nFinally, we discuss a peculiar sentence, whose complexity we left open in [18]:\nTheorem 3.7. The data complexity of the symmetric WFOMC problem is in PTIME for the query\nQS4 =∀x1∀x2∀y1∀y2(S(x1, y1)∨ ¬S(x2, y1) ∨ S(x2, y2) ∨ ¬S(x1, y2))\nIn [18] we showed that QS4 is in PTIME under the modified semantics, where S is a bipartite graph. This implies that the range of the variables x1, x2 is disjoint from the range of the variables y1, y2. Now we extended the proof to the standard semantics used in this paper. What makes this query interesting is that the algorithm used to compute it requires a subtle use of dynamic programming, and none of the existing lifted inference rules in the literature are sufficient to compute this query. This suggests that we do not yet have a candidate for a complete set of lifted inference rules for the symmetric WFOMC."
    }, {
      "heading" : "3.3 Proofs",
      "text" : "Proof of Theorem 3.1. We briefly recall the basic notions from Valiant’s original papers [33, 34]. A counting Turing machine is a nondeterministic TM with a read-only input tape and a work tape, that (magically) prints in binary, on a special output tape, the number of its accepting computations. The class #P1 consists of all functions computed by some counting TM with polynomial (non-deterministic) running time and a unary input alphabet. A function f is #P1-hard if, for any function g in #P1 there exists a polynomial time, deterministic TM Tdet with access to an oracle\nfor f that computes g. Notice that Tdet’s input alphabet is unary. As usual, f is called #P1-complete if it is both hard, and in #P1.\nOur proof of Theorem 3.1 consists of two steps. First we construct a #P1-complete function f , which is computable by a linear time counting TM U1, which we call a universal #P1 machine; in fact, we will define f by describing U1. A similar construction in [34] is sketched too briefly to see how the particular pairing function can work; we use a different pairing function and give full details. To prove FO3 membership, we also need to ensure U1 runs in (nondeterministic) linear time, which requires some care given that the input is given in unary. Once we have defined U1, the second step of the proof is a standard construction of an FO formula to simulate U1: we follow Libkin [28, p. 167], but make several changes to ensure that the formula is in FO3. The two steps are:\nLemma 3.8. There exists a counting TM, U1, with a unary input alphabet, such that (i) U1 runs in linear time, and (ii) the function f that it computes is #P1hard.\nIt follows immediately that f is #P1-complete.\nLemma 3.9. Let T be any counting TM with a unary input alphabet computing some function f . Suppose T runs in time O(na). Then there exists an FOk formula Φ over some relational vocabulary σ, s.t. f(n) = FOMC(Φ, n)/(n!), where k = 3a for a ≥ 1.\nTheorem 3.1 follows by applying this lemma to U1, hence a = 1 and the formula is in FO3. By allowing runtimes O(na) with a > 1, the lemma implies: #P1 = {f | ∃Φ ∈ FO ,∀n : f(n) = bFOMC(Φ, n)/n!c}; this is an extension of the classic result by Jones and Selman [23], which, restated for the tally notation says NP1 = {Spec(Φ) | Φ ∈ FO} (see [12], [9, Sec.5]). By considering FOMC over unlabeled structures, denoted UFOMC, the correspondence becomes even stronger. In UFOMC, all models that are identical up to a permutation of the constants are counted once, and #P1 = {UFOMC(Φ, n) | Φ ∈ FO}.\nProof of Lemma 3.8. The idea for U1 is simple: its input n is represented in unary and encodes two numbers i, j: n = e(i, j), for some encoding function e to be defined below. U1 first computes i, j from n, then simulates the ith #P1 counting TM on input j. The difficult part is to ensure that U1 runs in linear time:\nevery TM i that it simulates runs in time O(jki) for some exponent ki that depends on i, and thus if we construct U1 naively to simply simulate machine i on input j, then its runtime is no longer polynomial.\nWe start by describing an enumeration of counting TMs in #P1, M1,M2, . . . ,Mi, . . ., with the property that Mi runs in time ≤ (i · ji + i)2 on an input j. We start by listing all counting TMs over a unary input alphabet in standard order M ′1,M ′ 2, . . .. Then we dovetail pairs of the form Mi = (M ′ r, s) where r is an index in the standard TM order and s is a number. Mi represents the counting TM that simulates M ′r on input j with a timer for s · js + s steps. The machine Mi can be constructed with at most quadratic slowdown over M ′r (due to the need to increment the counter). We further ensure that dovetailing Mi = (M ′ r, s) is done such that i ≥ s; for that, it suffices to advance r in such a way that i advances at least as fast as s, that is, M1 = (M ′ 1, 1),M2 = (M ′ 2, 1),M3 = (M ′ 1, 2),M4 = (M ′2, 2),M5 = (M ′ 1, 3), . . .. It follows that, for every i, the runtime of Mi on input j is ≤ (i · ji + i)2. It remains to show that the list M1,M2, . . . ,Mi, . . . enumerates precisely all #P1 functions. Indeed, each function in this list is in #P1, because the runtime of Mi is polynomial in the input j. Conversely, every function in #P1 is computed by some Mi in our list, because it is computed by some M ′r whose runtime on input j is ≤ ar · jkr + br and this is ≤ s · js + s if we choose s def = max(ar, br, kr). This completes the construction of the enumeration M1,M2, . . .. We describe now the counting machine U1. Its input is a number n in unary, which represents an encoding n = e(i, j) of two integers i, j. We will choose the encoding function e below such that it satisfies three properties: (a) U1 can compute i, j from n = e(i, j) in linear time (with auxiliary tapes), (b) e(i, j) ≥ (i · ji + i)2, and (c) for every fixed i, the function j 7→ e(i, j) can be computed in PTIME. We first prove the lemma, assuming that e satisfies these three properties.\nThe counting machine U1 starts by computing a binary representation of its unary input n on its work tape: this step takes linear time in n. Next, it extracts i, j in linear time in n (by property (a)), then it simulates Mi on input j. The runtime of the last step is ≤ (i · ji + i)2 ≤ e(i, j) (by property (b)), hence U1 runs in linear time in the input n = e(i, j). It remains to prove that the function f computed by U1 is #P1hard. Consider any function g in #P1: we will describe a polynomial-time, deterministic Turing machine Tdet with an oracle for f that computes g. Since g is in #P1 there exists i such that g is computed by Mi. On input j, Tdet computes n = e(i, j) in PTIME (by property (c)), stores it on the oracle tape, then invokes U1 and obtains the result g(j) = f(n).\nIt remains to describe the encoding function e. We take e(i, j) = 2i34i·dlog3 je(6j + 1). To prove (a), note that i is obtained by counting the trailing zeroes in the binary representation of n, j is obtained by first computing a ternary representation of 34i·dlog3 je(6j+1), ignoring trailing zeros and deriving j from 6j + 1. (b) 2i34i·dlog3 je(6j+ 1) ≥ (i · ji + i)2 follows through direct\ncalculations, using the fact that 34i·dlog3 je ≥ j4i. (c) is straightforward.\nProof of Lemma 3.9. We describe here the most important steps of the proof, and delegate the details to Appendix B. We will consider only the case k = 1, i.e. the counting TM runs in linear time: the case when k > 1 is handled using a standard technique that encodes nk time stamps using a relation of arity k. We briefly review Trakhtenbrot’s proof from Libkin [28, p. 167]: for every deterministic TM, there is a procedure that generates a formula Θ1 such that TM has an accepting computation starting with an empty input tape iff Θ1 is satisfiable. The signature for Θ1 is (this is a minor variation over Libkin’s):\nσ ={<,Min, T0, T1, H, (Sq)q∈States(T )} Then Θ1 states that (1) x < y is a total order on the domain and Min(x) is its minimum element, (2) T0(t, p) (or T1(t, p)) is true iff at time t the tape has a 0 (or a 1) on position p, (3) H(t, p) is true iff at time t the head is on position p, and Sq(t) is true iff at time t the machine is in state q. Libkin [28] describes the sentence Θ1 that states that all these constraints are satisfied.\nWe adapt this to a more general construction that is sufficient to prove Lemma 3.9. We address five changes: (1) Our TM is non-deterministic, (2) has k tapes instead of 1, (3) its runtime is c ·n instead of n, for some c > 1, (4) the input tape initially contains n symbols 1, and (5) Θ1 needs to be in FO\n3. Support for non-deterministic transitions requires only a slight modification to the sentences. It is also easy to represent multiple tapes, by using k different relations T0τi , T1τi , and similarly k head relations Hτi , for i = 1, k. To encode transitions in FO3, we will assume that the multi-tape TM always reads or writes only one tape at each time. This is without loss of generality: a state that reads and writes all tapes can be converted into a sequence of 2k states that first read one by one each tape and “remember” their symbols, then write one by one each tape and move their heads.\nNext, we show how to encode running times (and space) up to c · n for some integer constant c > 1, with only a domain of size n available. The standard way is to increase the arity of the relations, e.g. with arity a we can represent na time steps, but this is not possible within FO3. Instead, we partition the computation into c epochs, each having exactly n time steps, and similarly we partition the tapes into c regions, each with n cells. We denote T0τer(t, p), T1τer(t, p) the relations T0, T1 specialized to tape τ , epoch e, and region r, and similarly define Hτer and Sqe. Furthermore, we modify the sentences that encode the TM transition relation to move the heads across epochs and regions, using only 3 variables. The fourth item is easy: we write a formula stating that initially (at time 1 of epoch 1), region 1 of (input) tape τ1 is full of 1’s, and all other regions and tapes are full of 0’s. Moreover, Appendix B shows that Θ1 can be written in FO\n3. Finally, FOMC(Θ1, n) is precisely the number of accepting computations of the TM on input n, times n!, coming from the n! ways of ordering the domain.\nProof of Theorem 3.6. We show how to compute Pr(Q) rather than WFOMC(Q,n): we have seen in Sec. 2 that these two are equivalent. We actually prove the theorem for a more general form of query, where each variable xi range over a domain of size ni, thus, Q = ∃x1 ∈ [n1], . . . ,∃xm ∈ [nm]ϕ, where ϕ is quantifier-free. The probability of a query under the standard semantics (when all variables range over the same domain [n]) is obtained by simply setting n1 = · · · = nm = n.\nTo prove the theorem, we use an equivalent definition of γ-acyclicity given by Fagin [14], which we give here together with our algorithm for computing Pr(Q). The graph is γ-acyclic if it can be reduced to an empty graph by applying the following rules, in any order.\n(a) If a node x is isolated (i.e., it belongs to precisely one edge, say R(x, y, z)), then delete x. In this case we replace the relation R(x, y, z) by a new relation R′(y, z), where each tuple has probability 1− (1− p)nx , where p is the probability of tuples in R.\n(b) If an edge R(x) is a singleton (i.e., if it contains exactly one node), then delete that edge (but do not delete the node from other edges that might contain it). Here, we condition on the size k = |R|. For each k, let pk be the probability of the residual query obtained by removing R(x) and restricting the range of x to [k]. By symmetry, this probability depends only on k = |R|, and does not depend on the choice of the k elements in the domain. Then Pr(Q) = ∑ k ( nx k ) pkR(1 − pR)nx−kpk, where pR de-\nnotes the probability of a tuple Pr(R(i)), and is the same for all constants i (by symmetry).\n(c) If an edge is empty, R(), then delete it. We multiply the probability of the residual query by pR.\n(d) If two edges (say R(x, y, z), S(x, y, z)) contain precisely the same nodes, then delete one of these edges. Here we replace the two atoms by a new atom R′(x, y, z) whose probability is pR · pS .\n(e) If two nodes x, y are edge-equivalent, then delete one of them from every edge that contains it. (Recall that two nodes are edge-equivalent if they are in precisely the same edges.) Here we replace the two variables x, y by a new variable z, whose range\nhas size nz def = nx · ny.\nEach operation above is in polynomial time in the size of the binary representation of the inputs, and there are only polynomially many operations. Therefore the entire computation is in polynomial time, because each intermediate result can be represented using polynomially many bits. This follows from the fact that the number of models is 2O(n\na), where a is the maximum arity of any relation in Q, hence the number of models can be represented using O(na) = nO(1) bits.\nExample 3.10. Consider the following linear chain query:\nQ =∃x0∃x1 · · · ∃xmR1(x0, x1) ∧ · · ·Rm(xm−1, xm) where the probabilities of the m relations are p1, . . . , pm. Denote Pn0,...,nm the probability of Q when the domains of x0, x1, . . . , xm are sets of sizes n0, n1, . . . , nm (thus,\ninitially n0 = n1 = · · · = nm = n). Then the variable xm is isolated (item a), hence we can eliminate it and update the probability of Rm to 1−(1−pm)nm . Now Rm is a singleton relation, hence we can remove it (item b), and restrict the domain of xm−1 to have size km−1, for km−1 = 1, nm−1. Therefore:\nPn0,...,nm−1,nm = ∑\nkm−1=1,nm−1\nPn0,...,nm−2,km−1 · ( nm km ) · [1− (1− pm)km ]km−1 · [(1− pm)km ]nm−1−km−1\nRepeating this process we arrive at an expression that is computable in polynomial time in n (for a fixed m). Notice that this formula does not appear to be computable in polynomial time in both n and m. We leave open the combined complexity of acyclic queries.\nProof of Theorem 3.7. First note that, by using resolution, the query implies the following statement, for every k ≥ 2:\n∀x1, y1, . . . , xk, yk(S(x1, y1) ∨ ¬S(x2, y1) ∨S(x2, y2) ∨ ¬S(x2, y3) ∨ . . . ∨ ¬S(x1, yk)) (5)\nFor any two numbers n1, n2, denote Qn1n2 = ∀x1 ∈ [n1],∀x2 ∈ [n1],∀y1 ∈ [n2],∀y2 ∈ [n2], (S(x1, y1) ∨ ¬S(x2, y1) ∨ S(x2, y2) ∨ ¬S(x1, y2)), in other words we restrict the range of the variables to some domains [n1], [n2]. These domains are not required to be disjoint, instead we use the standard assumption n1 ≤ n2 implies [n1] ⊆ [n2]. When n1 = n2 = n then Qn1n2 is equivalent to QS4. We claim the following. If D is a model of Qn1n2 , then either property Pa or Pb holds in D:\nPa ≡∃x ∈ [n1],∀y ∈ [n2], S(x, y) Pb ≡∃y ∈ [n2],∀x ∈ [n1],¬S(x, y)\nSuppose not. Consider any model of Qn1n2 that does not satisfy Pa, Pb. Pick any element x1 ∈ [n1]. As Pa does not hold, ∃y1 ∈ [n2]¬S(x1, y1). As Pb does not hold, ∃x2 ∈ [n1], S(x2, y1). Continuing, ∃y2 ∈ [n2], ¬S(x2, y2), ∃x3 ∈ [n1], S(x3, y2) and ∃y3 ∈ [n2], ¬S(x3, y3). Continuing, we obtain an arbitrarily long sequence of values x1, y1, x2, . . . such that: ¬S(x1, y1), S(x2, y1), ¬S(x2, y2), . . . , S(xn1 , yn1−1), ¬S(xn1 , yn1). Note that we can never have xi = xj or yi = yj , for i 6= j, because that would violate Eq.(5) for k = j − i. Since the domain is finite, this is a contradiction.\nTherefore, either Pa or Pb holds. Clearly, both statements cannot hold, as they are exclusive events. Denote f and g the weighted model count for Qn1n2 in these two cases:\nf(n1, n2) = WFOMC(Qn1n2 ∧ Pa, n, w, w̄) g(n1, n2) = WFOMC(Qn1n2 ∧ Pb, n, w, w̄)\nThen we have WFOMC(Qn1n2 , n, w, w̄) = f(n1, n2) + g(n1, n2). It remains to show how to compute f, g.\nConsider a model that satisfies Pa, hence the set X = {x | ∀y ∈ [n2], S(x, y)} is non-empty, hence k = |X| ≥ 1.\nRemove the elements X from the domain [n1] (and rename the elements such that [n1]−X = [n1 − k]) and call D′ the resulting substructure. Then D′ still satisfies the query Q(n1−k),n2 , and, by the removal of all elements X, cannot satisfy Pa, hence it must satisfy Pb. This justifies the following recurrence, completing the proof of Theorem 3.7:\nf(n1, 0) = 1 f(n1, n2) = n1∑ k=1 ( n1 k ) wkn2g(n1 − k, n2)\ng(0, n2) = 1 g(n1, n2) = n2∑ `=1 ( n2 ` ) w̄n1`f(n1, n2 − `)"
    }, {
      "heading" : "4. COMBINED COMPLEXITY",
      "text" : "In the combined complexity we consider a fixed vocabulary σ = (R1, . . . , Rm), and assume that both Φ and n are given as part of the input. As before, n is given in unary (tally) notation. We consider both the FOMC problem, “compute FOMC(Φ, n)”, and the associated decision problem “is n ∈ Spec(Φ)?”. Our upper bound for FOMC also holds for WFOMC. Recall that the spectrum Spec(Φ) of a formula Φ is the set of numbers n for which Φ has a model over a domain of size n.\nVardi [40] proved that the model checking problem, “given Φ and a structure D, is Φ true in D?” is PSPACE-complete. This implies that the above decision problem is also in PSPACE: to check n ∈ Spec(Φ) enumerate over all structures D of a domain of size n, and check if Φ is true in D. By the same argument, FOMC is also in PSPACE. We prove:\nTheorem 4.1. (1) For every k ≥ 2, the combined complexity for FOMC for FOk is #P-complete. (2) The combined complexity for the decision problem n ∈ Spec(Φ) is NP-complete for FO2, and is PSPACEcomplete for FO.\nThe #P-membership in (1) also holds for the WFOMC problem. Recall that the vocabulary σ is fixed. If σ were allowed to be part of the input, then the lower bound in (1) follows immediately from the #P-hardness result for #SAT, because any Boolean formula is trivially encoded as an FO0 formula, by introducing a new, zero-ary relational symbol for every Boolean variable.\nProof of Theorem 4.1. We start by proving item (1) of Theorem 4.1. To prove membership in #P, it suffices to show that the lineage of a sentence ϕ of size s over a domain of size n is polynomial in s and n, then use the fact that WMC for Boolean functions is in #P. However, FOk formulas have, in general, exponentially large lineage, e.g. the formula checking for the existence of a path of length n, ∃x∃y(R(x, y) ∧ ∃x(R(y, x) ∧ ∃y(R(y, x) ∧ . . .))), over a domain of size n has lineage of size Ω(nn). Instead, we first transform the formula by removing all nested variables. For that, we apply Scott’s reduction, which we give below, following the presentation by Grädel, Kolaitis, and Vardi [17, Prop.3.1]; while Scott’s reduction was described for FO2, it carries over unchanged to FOk. More precisely, the reduction converts a sentence ϕ of size s into a new sentence ϕ∗ over an extended vocabulary, satisfying the following properties:\n1. The finite models of ϕ and ϕ∗ are in one-toone correspondence, and the corresponding models have the same weight.\n2. ϕ∗ has size O(s).\n3. ϕ∗ is a conjunction of sentences in prenex normal form, i.e. Q1x1Q2x2 · · ·Qkxkψ where each Qi is either ∀ or ∃, and ψ is quantifier-free.\nThe new formula has a lineage of size O(nks), because its quantifier depth is bounded by k = O(1), which implies WFOMC is in #P. It remains to describe Scott’s reduction, which we review here briefly, for completeness. Introduce a new relational symbol Sψ for every subformula ψ of ϕ, where the arity of Sψ equals the number of free variables in ψ, and define the sentence θψ ≡ ∀x1 · · · ∀x`(Sψ(x1, . . . , x`) ⇔ θ′ψ), where θ′ψ depends on the structure of ψ as follows: if ψ is an atomic formula, then θ′ψ = ψ, if ψ = ψ1 ∧ ψ2 then θ′ψ = Sψ1 ∧ Sψ2 , if ψ = ¬ψ1 then θ′ψ = ¬Sψ1 and if ψ = ∀xψ1 then θ′ψ = ∀xSψ1 . The new formula ϕ∗ is defined as Sϕ ∧ ∧ ψ θψ. By setting w(Sψ) = w̄(Sψ) = 1 for all new symbols, we ensure that the models of ϕ and ϕ∗ are not just in one-to-one correspondence; they have the same weights.\nNext we prove #P-hardness for FO2 (this implies hardness for FOk for every k ≥ 2). We use reduction from #SAT: given a Boolean formula F over n variables X1, . . . , Xn, compute #F . This problem is #P-hard [33].\nDefine the vocabulary σ consisting of 3 unary symbols A,B,C, and 2 binary symbols R,S. Given a Boolean formula F , we construct an FO2 sentence ϕF such that, over a domain of size n + 1, the number of models of ϕF is FOMC(ϕF , n+ 1) = (n+ 1)! ·#F . The sentence ϕF enforces a particular graph structure, as illustrated in Figure 2, by asserting the following:\n• There exists three unique, distinct elements x, y, z such that A(x), B(y), C(z) are true: ∃xA(x) ∧ ∀x, ∀y(A(x) ∧ A(y)) ⇒ x = y, and similarly for B and C; ¬∃x(A(x)∧B(x)) and similarly for A,C, and B,C. • There exist n elements x1, . . . , xn such that the\nfollowing holds: A(x1), R(x1, x2), R(x2, x3), . . . , R(xn−1, xn), B(xn). This is expressible in FO2, by reusing variables.\n• For every number m ∈ [2n]−{n}, it is not the case that there exists m elements x1, . . . , xm such that: A(x1), R(x1, x2), R(x2, x3), . . . , R(xm−1, xm), B(xm).\n• For all x, y, if R(x, y) then neither C(x) nor C(y). • For all x, y, if S(x, y) then C(x). • Finally, ϕF contains a statement obtained from F\nby replacing each Boolean variable Xi by the sentence γi def = ∃x, ∃z(S(z, x) ∧ αi(x)), where αi(x) is the following formula with free variable x: there exists a path A(x1), R(x1, x2), . . . , R(xi−1, x) (if i = 1 then α1(x) ≡ A(x)).\nThe reader may check that, for any database instance D over a domain of size n+1 that satisfies ϕF there exists a unique permutation c0, c1, . . . , cn over its domain such that the relations A,B,C and R contain precisely the following tuples: C(c0), A(c1), B(cn), R(c1, c2), . . . , R(cn−1, cn). Indeed, if it contained some R(ci, cj) with j 6= i + 1, then c1, . . . , ci, cj , cj+1, . . . , cn forms a path from A to B of some length m ≤ 2n and m 6= n, which contradicts the sentence ϕF ; notice also that αi(x) is true iff x = ci. Therefore the only relation that is left unspecified in D is S, which may contain an arbitrary number of tuples of the form S(c0, ci). These tuples are in one-to-one correspondence with the Boolean variables Xi, proving our claim.\nNow we prove item (2) of Theorem 4.1. The claim for FO2 follows immediately from the proof above. It remains to prove that the combined complexity for FO is PSPACE, for which we use a reduction from the Quantified Boolean Formula (QBF) problem, which is known to be PSPACE complete. A Quantified Boolean Formula is a formula of the form Q1X1Q2X2 . . . QnXnF where each Qi is a quantifier ∀ or ∃, and F is a Boolean formula over the variablesX1, . . . , Xn. We make the following change to the construction above. Recall that a Boolean variable Xi in F was represented by S(c0, ci). Now we extend S to a ternary relation S(x, y, u), restrict u to two constants (we choose c1 and cn arbitrarily) and represent Xi by S(c0, ci, c1) and ¬Xi by S(c0, ci, cn). Then, we replace the quantifiers ∀Xi or ∃Xi with ∀u or ∃u. More precisely, the new formula ϕF contains the following statements:\n• If S(x, y, u) is true, then u is either the distinguished A or the distinguished B element: ∀x, y, u(S(x, y, u)⇒ A(u) ∨B(u)). • If u, v are the distinguished A and B el-\nements, then S(x, y, u) is the negation of S(x, y, v): ∀u, v, x, y(A(u) ∧ B(v) ⇒ (S(x, y, u) xor S(x, y, v))).\nFinally, we rewrite a QBF ∀Xi(. . .) into ∀u(A(u) ∨ B(u) ⇒ . . .) and a QBF ∃Xi(. . .) into ∃u((A(u) ∨ B(u)) ∧ . . .). We omit the straightforward details."
    }, {
      "heading" : "5. CONCLUSIONS",
      "text" : "In this paper we discuss the symmetric Weighted FO Model Counting Problem. Our motivation comes from probabilistic inference in Markov Logic Networks, with applications to modern, large knowledge bases, but the problem is also of independent theoretical interest. We studied both the data complexity, and the combined complexity. For the data complexity we established for the first time the existence of an FO sentence for which the Symmetric Model Counting problem is #P1hard, and also the existence of a Conjunctive Query for which the Symmetric Weighted Model Counting problem is #P1-hard. We also showed that for all γ-acyclic conjunctive queries WFOMC can be computed in polynomial time. For the combined complexity, we proved a tight bound of #P-completeness for FO2. We also discussed the associate decisions problem.\nWe end this paper with a list of open problems, listed in Table 2: for each query in the table, the complexity of the FOMC or the WFOMC problem is open.\nAcknowledgments. We thank Ronald Fagin, Phokion Kolaitis and Lidia Tendera for discussions on topics related to this paper. This work was partially supported by NSF IIS-1115188, IIS-0911036, CCF-1217099, and the Research Foundation-Flanders (FWO-Vlaanderen)."
    }, {
      "heading" : "6. REFERENCES",
      "text" : "[1] Alberto Bertoni and Massimiliano Goldwurm. On\nranking 1-way finitely ambiguous NL languages and #P1-complete census functions. ITA, 27(2):135–148, 1993.\n[2] Andrew Carlson, Justin Betteridge, Bryan Kisiel, Burr Settles, Estevam R. Hruschka Jr., and Tom M. Mitchell. Toward an architecture for never-ending language learning. In AAAI, 2010.\n[3] Kevin J. Compton. The computational complexity of asymptotic problems i: Partial orders. Inf. Comput., 78(2):108–123, 1988.\n[4] Nilesh N. Dalvi and Dan Suciu. Efficient query evaluation on probabilistic databases. VLDB J., 16(4):523–544, 2007.\n[5] Nilesh N. Dalvi and Dan Suciu. The dichotomy of probabilistic inference for unions of conjunctive queries. J. ACM, 59(6):30, 2012.\n[6] http://deepdive.stanford.edu/. [7] Pedro Domingos and Daniel Lowd. Markov Logic:\nAn Interface Layer for Artificial Intelligence. Morgan & Claypool Publishers, 2009.\n[8] X. Dong, E. Gabrilovich, G. Heitz, W. Horn, N. Lao, K. Murphy, T. Strohmann, S. Sun, and W. Zhang. Knowledge vault: A web-scale approach to probabilistic knowledge fusion. In KDD, 2014.\n[9] Arnaud Durand, Neil D. Jones, Johann A. Makowsky, and Malika More. Fifty years of the spectrum problem: survey and new results. Bulletin of Symbolic Logic, 18(4):505–553, 2012.\n[10] David Duris. Some characterizations of γ and β-acyclicity of hypergraphs. Information Processing Letters, 112(16):617–620, 2012.\n[11] Anthony Fader, Stephen Soderland, and Oren Etzioni. Identifying relations for open information extraction. In EMNLP, pages 1535–1545, 2011.\n[12] Ronald Fagin. Generalized first-order spectra and polynomial-time recognizable sets. In SIAM-AMS Proceedings 7, pages 43–73, 1974.\n[13] Ronald Fagin. Probabilities on finite models. J. Symb. Log., 41(1):50–58, 1976.\n[14] Ronald Fagin. Degrees of acyclicity for hypergraphs and relational database schemes. J. ACM, 30(3):514–550, 1983.\n[15] Vibhav Gogate and Pedro Domingos. Probabilistic theorem proving. In UAI, pages 256–265, 2011.\n[16] Carla P Gomes, Joerg Hoffmann, Ashish Sabharwal, and Bart Selman. From sampling to model counting. In IJCAI, pages 2293–2299, 2007.\n[17] Erich Grädel, Phokion G. Kolaitis, and Moshe Y. Vardi. On the decision problem for two-variable first-order logic. Bulletin of Symbolic Logic, 3(1):53–69, 1997.\n[18] Eric Gribkoff, Guy Van den Broeck, and Dan Suciu. Understanding the complexity of lifted inference and asymmetric weighted model counting. In UAI, pages 280–289, 2014.\n[19] Johannes Hoffart, Fabian M. Suchanek, Klaus Berberich, and Gerhard Weikum. Yago2: A spatially and temporally enhanced knowledge base from wikipedia. AIJ, 194:28–61, 2013.\n[20] Manfred Jaeger. Lower complexity bounds for lifted inference. TPLP, 2012.\n[21] Manfred Jaeger and Guy Van den Broeck. Liftability of probabilistic inference: Upper and lower bounds. In StarAI, 2012.\n[22] Abhay Kumar Jha and Dan Suciu. Probabilistic databases with MarkoViews. VLDB, 5(11):1160–1171, 2012.\n[23] Neil Jones and Alan Selman. Turing machines and the spectra of first-order formulas with equality. In STOC, pages 157–167, 1972.\n[24] Kristian Kersting, Babak Ahmadi, and Sriraam Natarajan. Counting belief propagation. In UAI, pages 277–284, 2009.\n[25] Angelika Kimmig, Guy Van den Broeck, and Luc De Raedt. Algebraic model counting. arXiv preprint arXiv:1211.4475, 2012.\n[26] S. Kok, P. Singla, M. Richardson, and P. Domingos. The alchemy system for statistical relational AI, 2005.\n[27] Phokion G. Kolaitis and Moshe Y. Vardi. 0-1 laws for fragments of existential second-order logic: A survey. In MFCS, pages 84–98, 2000.\n[28] Leonid Libkin. Elements of Finite Model Theory. Springer, 2004.\n[29] Mathias Niepert. Symmetry-aware marginal density estimation. In AAAI, 2013.\n[30] Feng Niu, Christopher Ré, AnHai Doan, and Jude W. Shavlik. Tuffy: Scaling up statistical inference in Markov logic networks using an RDBMS. VLDB, 4(6):373–384, 2011.\n[31] Hoifung Poon and Pedro Domingos. Sound and efficient inference with probabilistic and deterministic dependencies. In AAAI, pages 458–463, 2006.\n[32] Dan Suciu, Dan Olteanu, Christopher Ré, and Christoph Koch. Probabilistic Databases. Morgan & Claypool Publishers, 2011.\n[33] Leslie G. Valiant. The complexity of computing the permanent. Theor. Comput. Sci., 8:189–201, 1979.\n[34] Leslie G. Valiant. The complexity of enumeration and reliability problems. SIAM J. Comput., 1979.\n[35] Guy Van den Broeck. On the completeness of first-order knowledge compilation for lifted probabilistic inference. In NIPS, pages 1386–1394, 2011.\n[36] Guy Van den Broeck and Adnan Darwiche. On the complexity and approximation of binary evidence in lifted inference. In NIPS, 2013.\n[37] Guy Van den Broeck, Wannes Meert, and Adnan Darwiche. Skolemization for weighted first-order model counting. In KR, 2014.\n[38] Guy Van den Broeck, Wannes Meert, and Jesse Davis. Lifted generative parameter learning. In StaRAI, 2013.\n[39] Guy Van den Broeck, Nima Taghipour, Wannes Meert, Jesse Davis, and Luc De Raedt. Lifted probabilistic inference by first-order knowledge compilation. In IJCAI, pages 2178–2185. AAAI Press, 2011.\n[40] Moshe Y. Vardi. The complexity of relational query languages (extended abstract). In STOC, pages 137–146, 1982.\n[41] Deepak Venugopal and Vibhav Gogate. Scaling-up importance sampling for markov logic networks. In NIPS, 2014.\n[42] Wei Wei, Jordan Erenrich, and Bart Selman. Towards efficient sampling: Exploiting random walk strategies. In AAAI, pages 670–676, 2004.\n[43] Wentao Wu, Hongsong Li, Haixun Wang, and Kenny Qili Zhu. Probase: a probabilistic taxonomy for text understanding. In SIGMOD, pages 481–492, 2012.\n[44] Ce Zhang and Christopher Ré. Towards high-throughput gibbs sampling at scale: a study across storage managers. In SIGMOD, pages 397–408, 2013."
    }, {
      "heading" : "APPENDIX",
      "text" : ""
    }, {
      "heading" : "A. THE THREE LEMMAS",
      "text" : ""
    }, {
      "heading" : "A.1 Proof of Lemma 3.3: Removing Exists",
      "text" : "Following the proof of [37], we show how to eliminate existential quantifiers from a WFOMC problem (a form of Skolemization). Assume that Φ is in prenex normal form: Φ = Q1x1Q2x2 . . . QkxkΨ, where each Qi is either ∀ or ∃, and Ψ is quantifier-free. Let i be the first position of an ∃, and denote ϕ(x, xi) = Qi+1xi+1 . . . QkxkΨ; note that ϕ is a formula with free variables x = (x1, . . . , xi−1). We have:\nΦ =∀x∃xiϕ(x, xi) Let A be a fresh relational symbol of arity i. The new formula Φ′ is:\nΦ′ =∀x((∃xiϕ(x, xi))⇒ A(x)) (6) Let w′, w̄′ denote the weights of Φ’s vocabulary ex-\ntended with w(A) = 1 and w̄(A) = −1. We claim that WFOMC(Φ, n, w, w̄) = WFOMC(Φ′, n, w′, w̄′). Consider a possible world D ⊆ Tup(n) that satisfies Φ′. Call D “good” if it also satisfies Φ. In a good world D, for any constants x = a, the sentence ∃xiϕ(a, xi) is true, hence A(a) is also true (because Φ′ is true), and therefore the weight of D is the same as the weight of D − {A}, the world obtained from D by removing all tuples referring to the relational symbol A: W (D,w′, w̄′) = W (D−{A}, w, w̄). Thus, the sum of the weights of the good worlds (see Eq.(3)) is precisely WFOMC(Φ, n, w, w̄). We prove that the sum of the weights of the bad worlds is zero. Let D be a bad world: it satisfies Φ′ but not Φ. Thus, there exists some constants a s.t. the sentence ∃xiϕ(a, xi) is false; choose a to be the first such constants, in some lexicographic order. Let D′ be the world obtained from D by flipping the status of A(a): thus D,D′ are identical, but one sets A(a) to true and the other to false. Both satisfy Φ′, and W (D,w′, w̄′) = −W (D′, w′, w̄′), therefore they cancel out in the sum of Eq.(3). This proves that WFOMC(Φ, n, w, w̄) = WFOMC(Φ′, n, w′, w̄′).\nWe note that Φ′ can be written equivalently as:\nΦ′ =∀x∀xi(¬ϕ(x, xi) ∨A(x)) In other words, we have replaced the first existential quantifier in Φ by a universal quantifier (and may have increased the number of ∃ on positions i+ 1, i+ 2, . . .). Lemma 3.3 follows by applying this procedure inductively."
    }, {
      "heading" : "A.2 Proof of Lemma 3.4: Removing Negation",
      "text" : "Let ¬ψ(x) be a negated subformula of Φ, with k free variables x. Let A, B be two new relational symbols of arity k. Let Φp denote the sentence obtained from Φ by replacing the subformula ¬ψ(x) with A(x). Denote: ∆ =∀x[(ψ(x) ∨A(x)) ∧ (A(x) ∨B(x)) ∧ (ψ(x) ∨B(x))]\n(7)\nExtend the weight functions w, w̄ to w′, w̄′ by setting w(A) = w̄(A) = w(B) = 1, w̄(B) = −1. Define Φ′ = Φp ∧ ∆. We claim that WFOMC(Φ, n, w, w̄) = WFOMC(Φ′, n, w′, w̄′). To prove this, consider a world\nD ⊆ Tup(n) over the vocabulary of Φ′, and assume that D satisfies Φ′. Call D “good”, if the statement ∀x(ψ(x) xor A(x)) holds. It is easy to see that in any good world, ∀xB(x) holds too, hence the good world has the same weight as the world obtained by stripping it of the additional relations A,B, and, furthermore, their contributions to WFOMC(Φ′, n, w′, w̄′) is precisely WFOMC(Φ, n, w, w̄). Consider a bad world: it satisfies Φ′, but there exists a such both ψ(a) and A(a) are true. In that case B(a) can be set arbitrarily to true or false and still satisfy the formula Φ′, hence the contributions of these two pairing worlds cancel out. This proves that WFOMC(Φ, n, w, w̄) = WFOMC(Φ′, n, w′, w̄′).\nLemma 3.4 follows by apply this process repeatedly."
    }, {
      "heading" : "A.3 Proof of Lemma 3.5: Removing Equality",
      "text" : "Let E(x, y) be a new predicate symbol, with weights w(E) = z and w̄(E) = 1, where z is a real value to be determined below. Define ΦE to be obtained from Φ by replacing every equality predicate x = y with E(x, y), and define:\nΦ′ =ΦE ∧ ∀xE(x, x) Consider the count f(z) = WFOMC(Φ′, n, w′, w̄′) as a function of z, where w′, w̄′ extend w, w̄ with w(E) = z, w̄(E) = 1. This is a polynomial of degree n2 in z. Since Φ′ asserts ∀xE(x, x), all monomials in f have a degree ≥ n. Let c ·zn be the monomial of degree n. Then we claim that its coefficient c = WFOMC(Φ, n, w, w̄). Indeed, every world D where E has exactly n tuples is a world where E is interpreted as the equality predicate. We can compute c using n + 1 calls to an oracle for f(z) as follows. Fix δ > 0, and denote ∆0f = f , ∆k+1f(z) = (∆kf)(z + δ)− (∆kf)(z). Then ∆nf(0) = c·n! = ( n 0 ) f(0)− ( n 1 ) f(δ)+ ( n 2 ) f(2δ)−· · · (−1)n ( n n ) f(nδ).\nB. A #P1-HARD SENTENCE Θ1 We prove here Lemma 3.9: shows how to reduce a linear-time, multi-tape counting TM with a unary input alphabet (such as the #P1-complete TM) to the FOMC problem on a first-order sentence. The sentence that encodes the #P1-complete TM is referred to as Θ1. This proof is based on the standard encoding of a deterministic Turing machine into first-order logic, as used to prove Trakhtenbrot’s theorem [28, p. 167]. We extend this construction in several ways: (1) towards non-deterministic counting Turing machines, (2) with multiple tapes, (3) with a run time of c · n for some fixed c, instead of n, (4) to have n symbols 1 on the input tape, followed by symbols 0, and finally (5) to obtain a sentence in FO3.\nAs discussed in Section 3.3, we need to encode run times and space with lengths up to c · n, yet we only have a domain size of exactly n available. This is solved by partitioning the run time into c epochs of n steps, and the space into c regions of n cells. Moreover, we assume w.l.o.g. that there are two symbols: {0, 1}."
    }, {
      "heading" : "B.1 Signature",
      "text" : "The signature of Θ1 consists of the following predicates P/a, where a is the arity of P :\n• </2, denoting a strict linear order on the domain,\n• Succ/2, denoting the successor relation w.r.t. the order on the domain,\n• Min/1 and Max/1, denoting the smallest and largest domain element\n• state predicates Sqe/1, where Sqe(t) is true precisely when the machine is in state q at time t in epoch e,\n• head predicates Hτer/2, where Hτer(t, p) is true precisely when at time t in epoch e, the head for tape τ is at position p in region r, and\n• tape predicates Tsτer/2, where Tsτer(t, p) is true precisely when at time t in epoch e, tape τ contains symbol s ∈ {0, 1} at position p in region r, • movement predicates Leftτer/2 and Rightτer/2, where\nLeftτer(t, p) is true precisely when the head on tape τ at time t in epoch e is to the left of p in region r (or when p, r is the first cell on its tape and the head is there), and Right is defined similarly, and\n• frame predicate Unchangedτer/2, where we have that Unchangedτer(t, p) is true precisely when position p in region r of tape τ did not change going from time t in epoch e to the next time step."
    }, {
      "heading" : "B.2 Sentences",
      "text" : "To encode the Turing machine, we let Θ1 consist of the following sentences.\n1. < is an arbitrary strict linear order (total, antisymmetric, irreflexive, and transitive):\n∀x, ∀y, ¬(x = y)⇒ (x < y) ∨ (y < x) ∀x, ∀y, ¬(x < y) ∨ ¬(y < x)\n∀x, ∀y,∀z, (x < y) ∧ (y < z)⇒ (x < z) 2. Min is the smallest element, and Max is the largest\nelement:\n∀x, Min(x)⇔ ¬∃y, (y < x) ∀x, Max (x)⇔ ¬∃y, (x < y)\n3. Succ is the successor relation:\n∀x,∀y, Succ(x, y)⇔ (x < y) ∧ ¬∃z, (x < z) ∧ (z < y) 4. At any time, the machine is in exactly one state:∧\nq,q′,e:q 6=q′ ∀t, ¬Sqe(t) ∨ ¬Sq′e(t)∧\ne\n∀t, ∨ q Sqe(t)\n5. At any time, the head is in exactly one position per tape:\n(a) The head is in at least one position:∧ τ,e ∀t,∃p, ∨ r Hτer(t, p)\n(b) The head is in at most one region:∧ τ,e,r ∀t, ∀p, Hτer(t, p)⇒ ∧ r′:r′ 6=r ∀p′,¬Hτer′(t, p′)\n(c) The head is in at most one position per region:∧ τ,e,r ∀t, ∀p, Hτer(t, p)\n⇒ ¬∃p′,¬(p = p′) ∧Hτer(t, p′)\n6. At any time, each tape position has exactly one symbol:∧\nτ,e,r\n∀t, ∀p, T0τer(t, p)⇔ ¬T1τer(t, p)\n7. In the initial configuration of the TM (first time step),\n(a) it is in state q1, and its heads are in the first position:\n∀x,Min(x)⇒ Sq1e1(x) ∧ ∧ τ Hτe1r1(x, x)\n(b) the first (input) tape τ1 contains n symbols 1 in the first region, followed by symbol 0 in all other regions (starting with cell n+ 1), and all other tapes τi contain symbol 0:\n∀t,Min(t)⇒∀p, T1τ1e1r1(t, p) ∧ ∧ i:i>1 T0τ1e1ri(t, p)\n∧ ∧\ni,r:i>1\nT0τie1r(t, p)\n8. An encoding of the transition relation δ. For example, that state qa operates on tape τa, and that δ(qa, 0) = {(qb, 1, L), (qc, 0, R)} is encoded into the following sentences.\n(a) What changed when t is before the end of an epoch (i.e., has a successor in the epoch):\n∧ e,r ∀t, t′,∀p,  Sqae(t)∧Hτaer(t, p)∧T0τaer(t, p) ∧Succ(t, t′) ⇒ [\nSqbe(t ′)\n∧Leftτaer(t′, p)∧T1τaer(t′, p)\n] ∨ [\nSqce(t ′)\n∧Rightτaer(t′, p)∧T0τaer(t′, p)\n]\n(b) What changed when t is at the end of an epoch:\n∧ i,r:1≤i<c ∀t, t′,∀p,\n Sqaei(t)\n∧Hτaeir(t, p) ∧T0τaeir(t, p) ∧Max (t) ∧Min(t′) ⇒ [\nSqbei+1(t ′)\n∧Leftτaei+1r(t′, p) ∧T1τaei+1r(t′, p)\n] ∨ [\nSqcei+1(t ′)\n∧Rightτaei+1r(t′, p) ∧T0τaei+1r(t′, p)\n]\n(c) What does not change on the tapes: other cells in the region of τa where the head is, regions\nwith no head, and tapes other than τa.∧ e,r ∀t,∀p, [ Sqae(t) ∧Hτaer(t, p) ] ⇒ ∀p′, (p = p′) ∨Unchangedτaer(t, p′)∧\nτ,e,r\n∀t, ∀p,Hτer(t, p)\n⇒ ∧\nr′:r′ 6=r ∀p,Unchangedτer′(t, p)∧\ne\n∀t, Sqae(t) ⇒ ∧\nτ,r:τ 6=τa ∀p,Unchangedτer(t, p)\n(d) The positions of the heads on tapes other than τa do not change:\n∧ τ,e,r:τ 6=τa\n∀t, t′,∀p, [\nSqae(t) ∧Hτer(t, p) ∧Succ(t, t′) ] ⇒ Hτer(t′, p)\n∧ τ,i,r:τ 6=τa,1≤i<c ∀t, t′,∀p,  Sqaei(t)∧Hτeir(t, p)∧Max (t) ∧Min(t′)  ⇒ Hτei+1r(t′, p)\n9. The movement predicates are defined as∧ τ,e,r ∀t, ∀p, p′, [ Leftτer(t, p) ∧Succ(p′, p) ] ⇔ Hτer(t, p′)\n∧ τ,e,i:1≤i<c\n∀t,∀p, p′, [\nLeftτeri+1(t, p) ∧Min(p) ∧Max (p′)\n] ⇔ Hτeri(t, p′)\n∧ τ,e ∀t,∀p, [ Leftτer1(t, p)∧Min(p) ] ⇔ Hτer1(t, p)\n∧ τ,e,r ∀t, ∀p, p′, [ Rightτer(t, p) ∧Succ(p, p′) ] ⇔ Hτer(t, p′)\n∧ τ,e,i:1≤i<c\n∀t, ∀p, p′, [\nRightτeri(t, p)∧Max (p) ∧Min(p′)\n] ⇔ Hτeri+1(t, p′)\n∧ τ,e ∀t,∀p, [ Rightτerc(t, p)∧Max (p) ] ⇔ Hτerc(t, p)\n10. The frame predicates are defined as\n∧ s,τ,e,r\n∀t, t′,∀p, [ Tsτer(t, p) ∧Unchangedτer(t, p)\n∧Succ(t, t′) ] ⇔ Tsτer(t′, p)\n∧ s,τ,i,r:1≤i<c ∀t, t′,∀p,  Tsτeir(t, p)∧Unchangedτeir(t, p)∧Max (t) ∧Min(t′)  ⇔ Tsτei+1r(t′, p)\n11. The machine terminates in an accepting state (e.g., q1, q5, q42, etc.) :\n∀t,Max (t)⇒ Sq1ec(t) ∨ Sq5ec(t) ∨ Sq42ec(t) ∨ . . . It is easy to verify that Θ1 uses at most three logical variables per sentence, and that Θ1 is therefore in FO 3. Note that FO3 permits variables to be reused within the same sentence.\nFor a fixed model of </2, that is, a fixed order on the domain, the models of Θ1 for domain size n correspond one-to-one to the accepting computations of the TM on input n. Since there are exactly (n!) models of < /2, we can compute the number of accepting computations from the FOMC efficiently.\nC. PTIME DATA COMPLEXITY FOR FO2 The proof of the fact that the data complexity for FO2 is in PTIME is spread over two references, [35] and [37]. We include here a brief proof, for completeness.\nGiven an FO2 formula ϕ of size s, we start by applying the reduction in [17], which converts ϕ into a formula ϕ∗ with the following properties:\n• Every relational symbol occurring in ϕ∗ has arity at most 2.\n• Items 1 and 3 of Scott’s reduction hold. (Item 2 becomes: ϕ∗ has size O(s log s). In our case ϕ is fixed, so it suffices to note that the size of ϕ∗ is O(1).)\nThe reduction consists of Scott’s reduction described above, plus the following transformation that ensures that all relational symbols have arity ≤ 2. Replace each relational atom of arity > 2 by a new unary or binary symbol, for example, replace the atoms R(x, y, x), R(y, y, y), R(x, x, y) by R1(x, y), R2(x), R3(x, y). Then append to ϕ∗ conjuncts asserting how the new relational symbols relate, for example ∀x(R1(x, x)↔ R2(x)); we refer the reader to [17] for details.\nWe perform one more transformation: remove all existential quantifiers by using Lemma 3.3, thus transforming ϕ∗ into a universally quantified sentences:\nϕ∗ = ∀x∀y ψ(x, y) where ψ(x, y) is a quantifier-free formula.\nIf ϕ∗ contains any relational symbol R of arity zero then we perform a Shannon expansion and compute P (ϕ∗) = Pr(ϕ∗[R = false]) · (1 − p(R)) + Pr(ϕ∗[R = true]) · p(R). Thus, we can assume w.l.o.g. that all relational symbols in ϕ∗ have arity 1 or 2.\nAssume first that all relational symbols in ϕ∗ have arity 2. Then we write its lineage as:\nF = ∧\na,b∈[n]:a<b ψ(a, b) ∧ ∧ c∈[n] ψ(c, c)\nSince all atoms are binary, for any two distinct sets {a, b} 6= {a′, b′}, the formulas ψ(a, b) and ψ(a′, b′) are\nindependent probabilistic events, because they depend on disjoint sets of ground tuples: one depends on tuples of the form R(a, b) or R(b, a), the other on tuples of the form R(a′, b′) or R(b′, a′), and they are disjoint. (This would fail if ψ contained a unary atom, say U(x), because we may have a = a′, b 6= b′, and in that case both formulas depend on the tuple U(a).) Therefore:\nPr(F ) = ∏\na,b∈[n]:a<b Pr(ψ(a, b)) · ∏ c∈[n] Pr(ψ(c, c))\nBecause the probabilities are symmetric, the quantity p1 = Pr(ψ(a, b)) is independent of a, b, while p2 = Pr(ψ(c, c)) is independent of c, and both can be computed in time O(1). Therefore, Pr(ϕ) = Pr(ϕ∗) = p(F ) = p n(n−1)/2 1 p n 2 . For a simple illustration, consider ϕ∗ = ∀x∀y(R(x, y)∨T (x, y))∧(R(x, y)∨T (y, x)). Then:\nF = ∧\na,b∈[n]:a<b (R(a, b) ∨ T (a, b)) ∧ (R(a, b) ∨ T (b, a)) ∧ (R(b, a) ∨ T (b, a)) ∧ (R(b, a) ∨ T (a, b)) ∧ ∧ c∈[n] (R(c, c) ∨ T (c, c))\nand the probability is given by p n(n−1)/2 1 p n 2 where p1 = Pr((R(a, b) ∨ T (a, b)) ∧ (R(a, b) ∨ T (b, a)) ∧ (R(b, a) ∨ T (b, a)) ∧ (R(b, a) ∨ T (a, b))) and p2 = Pr(R(c, c) ∨ T (c, c)), both quantities that can be computed using brute force.\nNext consider the case when ϕ∗ has both unary and binary relational symbols. Let R1, . . . , Rm be all unary symbols. Consider the 2m cells defined by conjunctions of these atoms or their negation, denote them C1, . . . , C2m ; that is C1(x) ≡ ¬R1(x)∧· · ·∧¬Rm(x), . . ., C2m(x) ≡ R1(x)∧ · · · ∧Rm(x). Let P denote any partition of [n] into 2m disjoint sets, i.e. P = (S1, . . . , S2m) such that S1 ∪ · · · ∪S2m = [n]. Denote (C1, . . . , C2m) = P the event that the 2m cells define precisely the partition P . Then, summing over all partitions P gives us:\nPr(ϕ∗) = ∑ P Pr(ϕ∗ ∧ (C1, · · · , C2m) = P ) (8)\nNext, we split ϕ∗ into a conjunction of several formulas, each x ranging over some cell Si and y over some cell Sj :\nϕ∗ = ∧\ni,j∈[2m]:i<j ∀x : Si,∀y : Sj , (ψ(x, y) ∧ ψ(y, x))\n∧ ∧\n`∈[2m] ∀x : S`,∀y : S`, ψ(x, y)\nWhen x ranges over Si, then every unary predicate R(x) containing the variable x is either true or false. Similarly, when y ranges over Sj , a predicate R(y) is either true or false. Let ψij(x, y) (or ψ`(x, y)) denote the formula ψ(x, y) ∧ ψ(y, x) (or ψ(x, y)) where all the unary predicates have been replaced by true or false, accord-\ning to the cells Si, Sj (or S` respectively). Therefore: ϕ∗ = ∧\ni,j∈[2m]:i<j ∀x : Si,∀y : Sj , ψij(x, y)\n∧ ∧\n`∈[2m] ∀x : S`,∀y : S`, ψ`(x, y)\nNotice that ψij and ψ` have only binary predicates. All conjuncts in the expression above are independent probabilistic events: if {i1, j1} 6= {i2, j2} then ∀x : Si1 ,∀y : Sj1 , ψi1j1(x, y) and ∀x : Si2 ,∀y : Sj2 , ψi2j2(x, y) are independent. Therefore, denoting ni = |Si| for i = 1, 2m, we have: Pr(ϕ∗ ∧ (C1, · · · , C2m) = P ) =∏ i,j∈[2m]:i<j qij · ∏ `∈[2m r`, where:\nqij = Pr(∀x : Si,∀y : Sj , ψij(x, y)) = ∏ a∈Si,b∈Sj Pr(ψij(a, b)) = r ninj ij\nr` = Pr(∀x : S`,∀y : S`, ψ`(x, y)) = ∏ a,b∈S`:a<b Pr(ψ`(a, b) ∧ ψ`(b, a)) · ∏ c∈S` Pr(ψ`(c, c))\n=s n`∗(n`−1)/2 ` · tn``\nwhere rij = Pr(ψij(a, b)), s` = Pr(ψ`(a, b) ∧ ψ`(b, a)), and t` = Pr(ψ`(c, c)) are independent of the choices of a, b, c respectively, and can be computed by brute force in time O(1). Finally, we use the fact that the probabilities are symmetric, which implies that the expression in Eq. (8) depends only on the cell cardinalities n1, . . . , n2m , and not on the actual cells S1, . . . , S2m . Therefore:\nPr(ϕ∗) = ∑\nn1,...,n2m :n1+···+n2m=1\nn!\nn1! · · ·n2m !\n· rninjij s n`∗(n`−1)/2 ` · tn``\nFor a simple illustration, consider ϕ∗ = ∀x∀y(R(x) ∨ U(x, y)∨T (y))∧ (¬R(x)∨¬U(x, y)∨¬T (y)). Denoting the four cells ¬R ∧ ¬T , ¬R ∧ T , R ∧ ¬T , R ∧ T by C1, . . . C4 respectively, we split ϕ into a conjunct of 6 + 4 expressions, such that in each expression x and y are restricted to the domains Ci and Cj respectively, for i ≤ j. Denoting n1, . . . , n4 the sizes of these cells, we have:\nPr(ϕ∗) = ∑\nn1+···+n4=n\nn!\nn1!n2!n3!n4! r ninj ij s n`∗(n`−1)/2 ` · tn``\nwhere r12 = Pr(U(a, b)) (because ∀x : S1,∀y : S2, (R(x)∨ U(x, y) ∨ T (y)) ∧ (¬R(x) ∨ ¬U(x, y) ∨ ¬T (y)) ≡ ∀x : S1,∀y : S2, T (x, y)), and similarly for the others."
    } ],
    "references" : [ {
      "title" : "On ranking 1-way finitely ambiguous NL languages and #P1-complete census functions",
      "author" : [ "Alberto Bertoni", "Massimiliano Goldwurm" ],
      "venue" : "ITA, 27(2):135–148,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 1993
    }, {
      "title" : "Toward an architecture for never-ending language learning",
      "author" : [ "Andrew Carlson", "Justin Betteridge", "Bryan Kisiel", "Burr Settles", "Estevam R. Hruschka Jr.", "Tom M. Mitchell" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2010
    }, {
      "title" : "The computational complexity of asymptotic problems",
      "author" : [ "Kevin J. Compton" ],
      "venue" : "i: Partial orders. Inf. Comput.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 1988
    }, {
      "title" : "Efficient query evaluation on probabilistic databases",
      "author" : [ "Nilesh N. Dalvi", "Dan Suciu" ],
      "venue" : "VLDB J.,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2007
    }, {
      "title" : "The dichotomy of probabilistic inference for unions of conjunctive queries",
      "author" : [ "Nilesh N. Dalvi", "Dan Suciu" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2012
    }, {
      "title" : "Markov Logic: An Interface Layer for Artificial Intelligence",
      "author" : [ "Pedro Domingos", "Daniel Lowd" ],
      "venue" : null,
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2009
    }, {
      "title" : "Knowledge vault: A web-scale approach to probabilistic knowledge fusion",
      "author" : [ "X. Dong", "E. Gabrilovich", "G. Heitz", "W. Horn", "N. Lao", "K. Murphy", "T. Strohmann", "S. Sun", "W. Zhang" ],
      "venue" : "In KDD,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Fifty years of the spectrum problem: survey and new results",
      "author" : [ "Arnaud Durand", "Neil D. Jones", "Johann A. Makowsky", "Malika More" ],
      "venue" : "Bulletin of Symbolic Logic,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2012
    }, {
      "title" : "Some characterizations of γ and β-acyclicity of hypergraphs",
      "author" : [ "David Duris" ],
      "venue" : "Information Processing Letters,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2012
    }, {
      "title" : "Identifying relations for open information extraction",
      "author" : [ "Anthony Fader", "Stephen Soderland", "Oren Etzioni" ],
      "venue" : "In EMNLP,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2011
    }, {
      "title" : "Generalized first-order spectra and polynomial-time recognizable sets",
      "author" : [ "Ronald Fagin" ],
      "venue" : "In SIAM-AMS Proceedings",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1974
    }, {
      "title" : "Probabilities on finite models",
      "author" : [ "Ronald Fagin" ],
      "venue" : "J. Symb. Log.,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1976
    }, {
      "title" : "Degrees of acyclicity for hypergraphs and relational database schemes",
      "author" : [ "Ronald Fagin" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1983
    }, {
      "title" : "Probabilistic theorem proving",
      "author" : [ "Vibhav Gogate", "Pedro Domingos" ],
      "venue" : "In UAI, pages 256–265,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2011
    }, {
      "title" : "From sampling to model counting",
      "author" : [ "Carla P Gomes", "Joerg Hoffmann", "Ashish Sabharwal", "Bart Selman" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2007
    }, {
      "title" : "On the decision problem for two-variable first-order logic",
      "author" : [ "Erich Grädel", "Phokion G. Kolaitis", "Moshe Y. Vardi" ],
      "venue" : "Bulletin of Symbolic Logic,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1997
    }, {
      "title" : "Understanding the complexity of lifted inference and asymmetric weighted model counting",
      "author" : [ "Eric Gribkoff", "Guy Van den Broeck", "Dan Suciu" ],
      "venue" : "In UAI,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2014
    }, {
      "title" : "Yago2: A spatially and temporally enhanced knowledge base from wikipedia",
      "author" : [ "Johannes Hoffart", "Fabian M. Suchanek", "Klaus Berberich", "Gerhard Weikum" ],
      "venue" : "AIJ, 194:28–61,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2013
    }, {
      "title" : "Lower complexity bounds for lifted inference",
      "author" : [ "Manfred Jaeger" ],
      "venue" : "TPLP,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2012
    }, {
      "title" : "Liftability of probabilistic inference: Upper and lower bounds",
      "author" : [ "Manfred Jaeger", "Guy Van den Broeck" ],
      "venue" : "In StarAI,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2012
    }, {
      "title" : "Probabilistic databases with MarkoViews",
      "author" : [ "Abhay Kumar Jha", "Dan Suciu" ],
      "venue" : null,
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2012
    }, {
      "title" : "Turing machines and the spectra of first-order formulas with equality",
      "author" : [ "Neil Jones", "Alan Selman" ],
      "venue" : "In STOC,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1972
    }, {
      "title" : "Counting belief propagation",
      "author" : [ "Kristian Kersting", "Babak Ahmadi", "Sriraam Natarajan" ],
      "venue" : "In UAI, pages 277–284,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2009
    }, {
      "title" : "Algebraic model counting",
      "author" : [ "Angelika Kimmig", "Guy Van den Broeck", "Luc De Raedt" ],
      "venue" : "arXiv preprint arXiv:1211.4475,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2012
    }, {
      "title" : "The alchemy system for statistical relational AI",
      "author" : [ "S. Kok", "P. Singla", "M. Richardson", "P. Domingos" ],
      "venue" : null,
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2005
    }, {
      "title" : "0-1 laws for fragments of existential second-order logic: A survey",
      "author" : [ "Phokion G. Kolaitis", "Moshe Y. Vardi" ],
      "venue" : "In MFCS,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2000
    }, {
      "title" : "Symmetry-aware marginal density estimation",
      "author" : [ "Mathias Niepert" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2013
    }, {
      "title" : "Tuffy: Scaling up statistical inference in Markov logic networks using an RDBMS",
      "author" : [ "Feng Niu", "Christopher Ré", "AnHai Doan", "Jude W. Shavlik" ],
      "venue" : null,
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2011
    }, {
      "title" : "Sound and efficient inference with probabilistic and deterministic dependencies",
      "author" : [ "Hoifung Poon", "Pedro Domingos" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2006
    }, {
      "title" : "The complexity of computing the permanent",
      "author" : [ "Leslie G. Valiant" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1979
    }, {
      "title" : "The complexity of enumeration and reliability problems",
      "author" : [ "Leslie G. Valiant" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 1979
    }, {
      "title" : "On the completeness of first-order knowledge compilation for lifted probabilistic inference",
      "author" : [ "Guy Van den Broeck" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2011
    }, {
      "title" : "On the complexity and approximation of binary evidence in lifted inference",
      "author" : [ "Guy Van den Broeck", "Adnan Darwiche" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2013
    }, {
      "title" : "Skolemization for weighted first-order model counting",
      "author" : [ "Guy Van den Broeck", "Wannes Meert", "Adnan Darwiche" ],
      "venue" : "In KR,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2014
    }, {
      "title" : "Lifted generative parameter learning",
      "author" : [ "Guy Van den Broeck", "Wannes Meert", "Jesse Davis" ],
      "venue" : "In StaRAI,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2013
    }, {
      "title" : "Lifted probabilistic inference by first-order knowledge compilation",
      "author" : [ "Guy Van den Broeck", "Nima Taghipour", "Wannes Meert", "Jesse Davis", "Luc De Raedt" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2011
    }, {
      "title" : "The complexity of relational query languages (extended abstract)",
      "author" : [ "Moshe Y. Vardi" ],
      "venue" : "In STOC,",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 1982
    }, {
      "title" : "Scaling-up importance sampling for markov logic networks",
      "author" : [ "Deepak Venugopal", "Vibhav Gogate" ],
      "venue" : "In NIPS,",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 2014
    }, {
      "title" : "Towards efficient sampling: Exploiting random walk strategies",
      "author" : [ "Wei Wei", "Jordan Erenrich", "Bart Selman" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2004
    }, {
      "title" : "Probase: a probabilistic taxonomy for text understanding",
      "author" : [ "Wentao Wu", "Hongsong Li", "Haixun Wang", "Kenny Qili Zhu" ],
      "venue" : "In SIGMOD,",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 17,
      "context" : "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft’s Probase [43] or Google’s Knowledge Vault [8], have millions to billions of uncertain tuples.",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 1,
      "context" : "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft’s Probase [43] or Google’s Knowledge Vault [8], have millions to billions of uncertain tuples.",
      "startOffset" : 47,
      "endOffset" : 50
    }, {
      "referenceID" : 9,
      "context" : "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft’s Probase [43] or Google’s Knowledge Vault [8], have millions to billions of uncertain tuples.",
      "startOffset" : 73,
      "endOffset" : 77
    }, {
      "referenceID" : 39,
      "context" : "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft’s Probase [43] or Google’s Knowledge Vault [8], have millions to billions of uncertain tuples.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 6,
      "context" : "Large knowledge bases, such as Yago [19], Nell [2], DeepDive [6], Reverb [11], Microsoft’s Probase [43] or Google’s Knowledge Vault [8], have millions to billions of uncertain tuples.",
      "startOffset" : 132,
      "endOffset" : 135
    }, {
      "referenceID" : 6,
      "context" : "For an illustration, Google’s Knowledge Vault [8] contains 1.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 6,
      "context" : "6B triples of the form (subject, predicate, object), for example, </m/02mjmr, /people/person/place_of_birth /m/02hrh0_> where /m/02mjmr is the Freebase id for Barack Obama, and /m/02hrh0_ is the id for Honolulu [8].",
      "startOffset" : 211,
      "endOffset" : 214
    }, {
      "referenceID" : 5,
      "context" : "A Markov Logic Network (MLN) [7] is a finite set of soft or hard constraints.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 24,
      "context" : "Today’s MLN systems (Alchemy [26], Tuffy [30, 44]) use an MCMC algorithm called MC-SAT [31] for probabilistic inference.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 27,
      "context" : "Today’s MLN systems (Alchemy [26], Tuffy [30, 44]) use an MCMC algorithm called MC-SAT [31] for probabilistic inference.",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 28,
      "context" : "Today’s MLN systems (Alchemy [26], Tuffy [30, 44]) use an MCMC algorithm called MC-SAT [31] for probabilistic inference.",
      "startOffset" : 87,
      "endOffset" : 91
    }, {
      "referenceID" : 38,
      "context" : "In practice, MC-SAT implementations rely on SampleSAT [42], which provides no guarantees on the uniformity of solutions.",
      "startOffset" : 54,
      "endOffset" : 58
    }, {
      "referenceID" : 14,
      "context" : "Several complex examples are known in the literature where model counting based on SampleSAT leads to highly inaccurate estimates [16].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 35,
      "context" : "A totally different approach to computing PrMLN (Φ) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper.",
      "startOffset" : 89,
      "endOffset" : 105
    }, {
      "referenceID" : 13,
      "context" : "A totally different approach to computing PrMLN (Φ) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper.",
      "startOffset" : 89,
      "endOffset" : 105
    }, {
      "referenceID" : 33,
      "context" : "A totally different approach to computing PrMLN (Φ) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper.",
      "startOffset" : 89,
      "endOffset" : 105
    }, {
      "referenceID" : 20,
      "context" : "A totally different approach to computing PrMLN (Φ) is to reduce it to a symmetric WFOMC [39, 15, 37, 22], and this motivates our current paper.",
      "startOffset" : 89,
      "endOffset" : 105
    }, {
      "referenceID" : 20,
      "context" : "We review here briefly one such reduction, adapting from [22, 37].",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 33,
      "context" : "We review here briefly one such reduction, adapting from [22, 37].",
      "startOffset" : 57,
      "endOffset" : 65
    }, {
      "referenceID" : 22,
      "context" : "Thus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41].",
      "startOffset" : 194,
      "endOffset" : 210
    }, {
      "referenceID" : 35,
      "context" : "Thus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41].",
      "startOffset" : 194,
      "endOffset" : 210
    }, {
      "referenceID" : 26,
      "context" : "Thus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41].",
      "startOffset" : 194,
      "endOffset" : 210
    }, {
      "referenceID" : 37,
      "context" : "Thus, our main motivation for studying the symmetric WFOMC is very practical, as symmetric models have been extensively researched in the AI community recently, for inference in MLNs and beyond [24, 39, 29, 41].",
      "startOffset" : 194,
      "endOffset" : 210
    }, {
      "referenceID" : 34,
      "context" : "Some tasks on MLNs, such as parameter learning [38], naturally exhibit symmetries.",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 32,
      "context" : "For others, such as computing conditional probabilities given a large “evidence” database, the symmetric WFOMC model is applicable when the database has bounded Boolean rank [36].",
      "startOffset" : 174,
      "endOffset" : 178
    }, {
      "referenceID" : 30,
      "context" : "It is immediate that this problem belongs to the class #P1, which is the set of #P problems over a unary input alphabet [34].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 33,
      "context" : "In a surprising result [37] has proven that for FO the data complexity of symmetric WFOMC is in PTIME (reviewed in Appendix C).",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 19,
      "context" : "This begs the question: could it be the case that every FO formula is in PTIME? The answer was shown to be negative by Jaeger and Van den Broeck [21, 20], using the following argument.",
      "startOffset" : 145,
      "endOffset" : 153
    }, {
      "referenceID" : 18,
      "context" : "This begs the question: could it be the case that every FO formula is in PTIME? The answer was shown to be negative by Jaeger and Van den Broeck [21, 20], using the following argument.",
      "startOffset" : 145,
      "endOffset" : 153
    }, {
      "referenceID" : 7,
      "context" : "Recall that the spectrum, Spec(Φ), of a formula Φ is the set of numbers n for which Φ has a model over a domain of size n [9].",
      "startOffset" : 122,
      "endOffset" : 125
    }, {
      "referenceID" : 31,
      "context" : "PTIME data complexity for symmetric WFOMC is called domain-liftability in the AI and lifted inference literature [35].",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 31,
      "context" : "Tractability of Φ was noted before in, for example [32, 35].",
      "startOffset" : 51,
      "endOffset" : 59
    }, {
      "referenceID" : 21,
      "context" : "Then, using a result in [23], if ETIME 6= NETIME, then there exists a formula Φ for which computing WFOMC is not in polynomial time.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 30,
      "context" : "Valiant already observed in [34] that such problems are probably not candidates for being #P-complete.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 0,
      "context" : "Very few hardness results are known for this class: we are aware only of a graph matching problem that was proven by Valiant, and of a language-theoretic problem by Bertoni and Goldwurm [1].",
      "startOffset" : 186,
      "endOffset" : 189
    }, {
      "referenceID" : 33,
      "context" : "Second, we prove that every γ-acyclic conjunctive query without self-joins is in polynomial time, extending the result in [37] from FO to γ-acyclic conjunctive queries.",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 33,
      "context" : "The tractability for FO [37] raises a natural question: do other restrictions of FO, like FO for k ≥ 3, also have polynomial data complexity? By carefully analyzing the details of the construction of Θ1 we prove that it is actually in FO.",
      "startOffset" : 24,
      "endOffset" : 28
    }, {
      "referenceID" : 25,
      "context" : "Recall that, if C is a class of finite structures and P is a property over these structures, then μn(P ) denotes the fraction of labeled structures in C over a domain of size n that satisfy the property P [27].",
      "startOffset" : 205,
      "endOffset" : 209
    }, {
      "referenceID" : 11,
      "context" : "Fagin [13] proved a 0-1 law for First-Order logic and all structures, by using an elegant transfer theorem: there exists a unique, countable structure R, which is characterized by an infinite set of extension axioms, τ .",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 2,
      "context" : "Compton [3] proved 0-1 laws for several classes of structures C.",
      "startOffset" : 8,
      "endOffset" : 11
    }, {
      "referenceID" : 21,
      "context" : "The data complexity variant is, of course, the spectrum membership problem, which has been completely solved by Jones and Selman [23], by proving that the class of spectra coincides with NETIME, that is, {Spec(Φ) | Φ ∈ FO} = NETIME.",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 15,
      "context" : "Grädel, Kolaitis and Vardi [17] have proven the following two",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 0,
      "context" : "In the probability computation problem, each variable Xi is set to true with some known probability p(Xi) ∈ [0, 1], and",
      "startOffset" : 108,
      "endOffset" : 114
    }, {
      "referenceID" : 0,
      "context" : "While in practical applications the weights are positive real numbers, and the probabilities are numbers in [0, 1], in this paper we impose no restrictions on the values of the weights and probabilities.",
      "startOffset" : 108,
      "endOffset" : 114
    }, {
      "referenceID" : 23,
      "context" : "The definition (2) of WMC(F,w) applies equally well to negative weights, and, in fact, to any semiring structure for the weights [25].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 20,
      "context" : "There is, in fact, at least one application of negative probabilities [22], namely the particular reduction from MLNs to WFOMC described in Example 1.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 3,
      "context" : "depend on i, j #P-hard for Φ [4]",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 33,
      "context" : "[37] have shown that the Symmetric WFOMC problem for every FO formula has polynomial time data complexity (the proof is reviewed in Appendix C); Theorem 3.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 33,
      "context" : "This lemma was proven by [37], and says that all existential quantifiers can be eliminated.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 33,
      "context" : "The next lemma, also following the proof in [37], says that all negations can be eliminated.",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 12,
      "context" : "Fagin’s definition of γ-acyclic hypergraphs [14] is reviewed in the proof of Theorem 3.",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 12,
      "context" : "This boundary does not lie at γ-acyclicity: the query cγ = R(x, z), S(x, y, z), T (y, z) is γ-cyclic (with cycle RxSyTzR; see Fagin [14]), yet it still has PTIME data complexity.",
      "startOffset" : 132,
      "endOffset" : 136
    }, {
      "referenceID" : 4,
      "context" : "The key observation is that γ-cycles allow the last variable z to appear in all predicates, turning it into a separator variable [5], hence Pr(Q) = ∏ a∈[n] Pr(Q[a/z]), which is [Pr(Q[a/z])] n by symme-",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 8,
      "context" : "A weaker notion of acyclicity, called jtdb (for join tree with disjoint branches), can be found in [10].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 12,
      "context" : "Fagin [14] defines two increasingly weaker notions of acyclicity: β- and α-acyclic.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 12,
      "context" : "By definition, a β-cyclic query Q contains a weak β-cycle [14] of the form R1x1R2x2 .",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 16,
      "context" : "Finally, we discuss a peculiar sentence, whose complexity we left open in [18]:",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 16,
      "context" : "QS4 =∀x1∀x2∀y1∀y2(S(x1, y1)∨ ¬S(x2, y1) ∨ S(x2, y2) ∨ ¬S(x1, y2)) In [18] we showed that QS4 is in PTIME under the modified semantics, where S is a bipartite graph.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 29,
      "context" : "We briefly recall the basic notions from Valiant’s original papers [33, 34].",
      "startOffset" : 67,
      "endOffset" : 75
    }, {
      "referenceID" : 30,
      "context" : "We briefly recall the basic notions from Valiant’s original papers [33, 34].",
      "startOffset" : 67,
      "endOffset" : 75
    }, {
      "referenceID" : 30,
      "context" : "A similar construction in [34] is sketched too briefly to see how the particular pairing function can work; we use a different pairing function and give full details.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 21,
      "context" : "By allowing runtimes O(n) with a > 1, the lemma implies: #P1 = {f | ∃Φ ∈ FO ,∀n : f(n) = bFOMC(Φ, n)/n!c}; this is an extension of the classic result by Jones and Selman [23], which, restated for the tally notation says NP1 = {Spec(Φ) | Φ ∈ FO} (see [12], [9, Sec.",
      "startOffset" : 170,
      "endOffset" : 174
    }, {
      "referenceID" : 10,
      "context" : "By allowing runtimes O(n) with a > 1, the lemma implies: #P1 = {f | ∃Φ ∈ FO ,∀n : f(n) = bFOMC(Φ, n)/n!c}; this is an extension of the classic result by Jones and Selman [23], which, restated for the tally notation says NP1 = {Spec(Φ) | Φ ∈ FO} (see [12], [9, Sec.",
      "startOffset" : 250,
      "endOffset" : 254
    }, {
      "referenceID" : 12,
      "context" : "To prove the theorem, we use an equivalent definition of γ-acyclicity given by Fagin [14], which we give here together with our algorithm for computing Pr(Q).",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 36,
      "context" : "Vardi [40] proved that the model checking problem, “given Φ and a structure D, is Φ true in D?” is PSPACE-complete.",
      "startOffset" : 6,
      "endOffset" : 10
    }, {
      "referenceID" : 29,
      "context" : "This problem is #P-hard [33].",
      "startOffset" : 24,
      "endOffset" : 28
    } ],
    "year" : 2015,
    "abstractText" : "The FO Model Counting problem (FOMC) is the following: given a sentence Φ in FO and a number n, compute the number of models of Φ over a domain of size n; the Weighted variant (WFOMC) generalizes the problem by associating a weight to each tuple and defining the weight of a model to be the product of weights of its tuples. In this paper we study the complexity of the symmetric WFOMC, where all tuples of a given relation have the same weight. Our motivation comes from an important application, inference in Knowledge Bases with soft constraints, like Markov Logic Networks, but the problem is also of independent theoretical interest. We study both the data complexity, and the combined complexity of FOMC and WFOMC. For the data complexity we prove the existence of an FO formula for which FOMC is #P1complete, and the existence of a Conjunctive Query for which WFOMC is #P1-complete. We also prove that all γacyclic queries have polynomial time data complexity. For the combined complexity, we prove that, for every fragment FO, k ≥ 2, the combined complexity of FOMC (or WFOMC) is",
    "creator" : "LaTeX with hyperref package"
  }
}