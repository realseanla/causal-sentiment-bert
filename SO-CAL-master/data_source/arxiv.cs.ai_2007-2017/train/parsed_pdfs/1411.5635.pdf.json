{
  "name" : "1411.5635.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Justifying Answer Sets using Argumentation",
    "authors" : [ "CLAUDIA SCHULZ", "FRANCESCA TONI", "Claudia Schulz" ],
    "emails" : [ "f.toni}@imperial.ac.uk)" ],
    "sections" : [ {
      "heading" : null,
      "text" : "KEYWORDS: Answer Set Programming, Assumption-Based Argumentation, Stable Extension, Explanation"
    }, {
      "heading" : "1 Introduction",
      "text" : "Answer Set Programming (ASP) is one of the most widely used non-monotonic reasoning paradigms, allowing to efficiently compute solutions to problems involving defaults and exceptions (Gelfond 2008). A problem is represented in terms of a logic program, that is if-then clauses containing negation-as-failure (NAF) literals which express exception conditions for the applicability of clauses. The solutions to the problem are then given by the declarative answer set semantics (Gelfond and Lifschitz 1991) for the logic program. ASP is applied in a variety of different areas, ranging from bioinformatics (Baral et al. 2004) over music composition (Boenn et al. 2011) to multi-agent systems (Son et al. 2009). Answer set solvers like clingo (Gebser et al. 2011), smodels (Niemelä et al. 2000), and DLV (Eiter et al. 1997) provide efficient tools for the computation of answer sets.\nEspecially with respect to the application of ASP in real-world scenarios involving\nar X\niv :1\n41 1.\n56 35\nv2 [\ncs .A\nI] 2\nnon-experts, it is useful to have an explanation as to why something does or does not belong to a solution. As an example, consider a medical decision support system which operates on a logic program comprising general treatment decision rules along with facts about a patient’s medical conditions. The answer sets of such a logic program contain treatment suggestions or exclusions for the given patient. For a doctor using this medical decision support system, it is important to know why the system suggests a certain treatment as well as why a treatment is not part of a solution. In ASP terms, the doctor needs a justification as to why a literal is or is not contained in an answer set. This is particularly important if the doctor’s intended treatment decision disagrees with the system’s suggestion. However, no matter whether an answer set is computed by an answer set solver or by hand using trial and error, it is a plain set of literals. That is to say that an answer set does not provide any justification as to why certain literals are part of it whereas others are not.\nIn this paper we present two methods for justifying literals with respect to an answer set of a consistent logic program by applying argumentation theory, another widely used technique in the field of non-monotonic reasoning. Here, we use Assumption-Based Argumentation (ABA) (Bondarenko et al. 1997; Dung et al. 2009), a structured argumentation framework which constructs arguments from rules and assumptions, and attacks from the notion of contrary of assumptions. ABA is particularly suitable for our purpose as it was inspired by logic programming, default logic and other non-monotonic reasoning approaches (Bondarenko et al. 1997) which are closely related to ASP. Due to this connection, it is straight forward to construct the translated ABA framework of a logic program, i.e. the ABA framework expressing the same problem as the logic program. One of the semantics for ABA frameworks is the stable extension semantics (Bondarenko et al. 1997; Dung 1995b), which has its roots in the stable model semantics for logic programs. Since the answer set semantics is based on the stable model semantics as well, every answer set of a logic program corresponds to a stable extension of the translated ABA framework, and vice versa. We make use of this connection to justify literals with respect to a given answer set of a consistent logic program by means of arguments in the context of the corresponding stable extension of the translated ABA framework.\nThe first justification approach, an Attack Tree, expresses how to construct an argument for the literal in question (the supporting argument) as well as which arguments attack the argument for the literal in question (the attacking arguments); the same information is provided for all arguments attacking the attacking arguments, and so on. The second justification approach, an ABA-Based Answer Set (ABAS) Justification of a literal, represents the same information as an Attack Tree, but expressed in terms of literals rather than arguments. An ABAS Justification comprises facts and NAF literals necessary to derive the literal in question (the “supporting literals”) as well as information about literals which are in conflict with the literal in question (the “attacking literals”). The same information is provided for all supporting and attacking literals of the literal in question, for all their supporting and attacking literals, and so on.\nAn Attack Tree is a (possibly infinite) tree with nodes holding arguments, where the argument held by a child node attacks the argument held by the parent node. Since arguments are trees themselves, indicating which components (rules, assumptions) are necessary to construct the argument, an Attack Tree has a two-layered structure: It is a tree consisting of trees. An ABAS Justification is the flattened version of an Attack Tree, containing literal-pairs which express the different parentchild relations expressed in an Attack Tree. The relation between arguments in the Attack Tree is represented in terms of literal-pairs which are in an attack relation; the relation between components of an argument is represented in terms of literal-pairs which are in a support relation. An ABAS Justification can also be interpreted as a graph, where every literal occurring in a pair forms a node in the graph. The graph has a support edge between two literal-nodes if these two literals occur as a literal-pair in a support relation in the ABAS Justification. Analogously, the graph has an attack edge between two literal-nodes if these two literals occur as a literal-pair in an attack relation in the ABAS Justification.\nOur justification approaches have two purposes. On the one hand, they contribute to the field of answer set justification research, which has been identified as an important but not yet sufficiently studied research area (Lacave and Diez 2004; Brain and De Vos 2008). The reason to use ABA for explanations instead of constructing justifications from the logic program straight away in terms of simple derivations or proof trees (Arora et al. 1993; Ferrand et al. 2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al. 1991; Moulin et al. 2002). On the other hand, our justification approaches also provide a theoretical impact with respect to the relation between non-monotonic reasoning systems. Even though ASP has been applied to argumentation theory in the sense that an argumentation framework can be equivalently expressed in ASP (Toni and Sergot 2011; Thimm and Kern-Isberner 2008), the converse has not been discussed in the literature. To the best of our knowledge, Attack Trees and ABAS Justifications are the first approaches applying argumentation theory for ASP, with the exception of\n• early work on manually constructing arguments and attacks from a logic program according to Toulmin’s argument scheme, which then serves as an\nexplanation of the logic program (Bench-Capon et al. 1991); and\n• Argumentation-Based Answer Set Justification (Schulz et al. 2013) which can be considered as a predecessor of ABAS Justifications. Similarly to ABAS Jus-\ntifications, Argumentation-Based Answer Set Justifications are constructed from arguments and attacks between them, but using the ASPIC+ argumentation framework (Prakken 2010) instead of ABA.\nThe paper is organized as follows: In Section 2 we recall some key concepts of ASP and ABA and give some preliminary definitions and results building upon this background. Furthermore, we give a motivating (medical) example for ABAS Justifications. In Section 3 we show how to translate a logic program into an ABA framework and prove their correspondence with respect to the stable model seman-\ntics. In Section 4 we introduce Attack Trees drawn from a translated ABA framework as a first justification method, show their relationship with abstract dispute trees for ABA (Dung et al. 2006), and characterize the explanation they provide as an admissible fragment of the answer set in question. Based on Attack Trees, we define two forms of ABAS Justifications: Basic ABA-Based Answer Set Justifications (Section 5) demonstrate the main idea of flattening Attack Trees, yielding a justification in terms of literals and their relations. Labelled ABA-Based Answer Set Justifications (Section 6) are a more elaborate version of Basic ABA-Based Answer Set Justifications, following the same flattening strategy, but additionally using labels to solve some deficiencies of the basic variant. In Section 7 we compare ABAS Justifications to related work and in Section 8 we conclude."
    }, {
      "heading" : "2 Background and Preliminaries",
      "text" : "This section describes all necessary background about ASP and ABA to understand the definitions of ABAS Justifications. In addition, we prove some core results about concepts in ASP and in ABA which have not or have only partially been considered in the literature before. We then use these to prove our main results in the remainder of the paper."
    }, {
      "heading" : "2.1 Answer Set Programming",
      "text" : "A logic program P is a (finite) set of clauses of the form l0 ← l1, . . . , lm, not lm+1, . . . , not lm+n with m,n ≥ 0. All li are classical ground1 literals, i.e. atoms a or negated atoms ¬a, and not lm+1, . . . , not lm+n are negation-as-failure (NAF) literals. The classical literal l0 on the left-hand side of the arrow is referred to as the clause’s head, all literals on the right of the arrow form the body of the clause. If the body of a clause is empty, the head is called a fact.\nNotation 1 The letter k is used for a literal in general, i.e. a classical literal l or a NAF literal not l. HBP denotes the Herbrand Base of P, that is the set of all ground atoms of P. LitP = HBP ∪ {¬a | a ∈ HBP} is the set of all classical literals of P, and NAFP = {not l | l ∈ LitP} consists of all NAF literals of P. We say that l is the corresponding classical literal of a NAF literal not l.\nIn the following, we recall the concept of answer sets as introduced in (Gelfond and Lifschitz 1991). Let P be a logic program not containing NAF literals. The answer set of P, denoted AS(P), is the smallest set S ⊆ LitP such that:\n1. for any clause l0 ← l1, . . . , lm in P: if l1, . . . , lm ∈ S then l0 ∈ S; and 2. S = LitP if S contains complementary classical literals a and ¬a.\nFor a logic program P, possibly containing NAF literals, and any set S ⊆ LitP , the reduct PS is obtained from P by deleting:\n1 As conventional in the logic programming literature, clauses containing variables are shorthand for all their ground instances.\n1. all clauses with not l in their bodies where l ∈ S, and 2. all NAF literals in the remaining clauses.\nThen, S is an answer set of P if it is the answer set of the reduct PS , i.e. if S = AS(PS). A logic program is inconsistent if it has no answer set or if its only answer set is LitP ; otherwise it is consistent. In the remainder of the paper, and if not stated otherwise, we assume that logic programs are consistent.\nNote that answer sets only contain classical literals. However, if l /∈ S for an answer set S of P and some classical literal l ∈ LitP , then not l is considered satisfied with respect to S. Thus, we introduce the following new definition.\nDefinition 1 (Answer Set with NAF literals) Let P be a logic program and let S ⊆ LitP be a set of classical literals. ∆S = {not l ∈ NAFP | l /∈ S} consists of all NAF literals not l whose corresponding classical literal l is not contained in S. If S is an answer set of P, then SNAF = S ∪ ∆S is an answer set with NAF literals of P.\nIntuitively, SNAF consists of all literals in an answer set S plus all NAF literals which are satisfied with respect to S. For the purpose of proving correspondence between answer sets of a logic program and stable extensions of an argumentation framework in Section 3, we introduce a new reformulation of answer sets in terms of modus ponens and prove correspondence with the original definition:\nNotation 2 `MP denotes derivability using modus ponens on ← as the only inference rule. P ∪ ∆S , for P a logic program and ∆S ⊆ NAFP , denotes the logic program P ∪ {not l ← | not l ∈ ∆S}. When used on such P ∪ ∆S , `MP treats NAF literals purely syntactically as in (Eshghi and Kowalski 1989) and treats facts l← as l← true where P ∪ ∆S `MP true for any logic program P and any set of NAF literals ∆S .\nLemma 1 Let P be a consistent logic program and let S ⊆ LitP be a set of classical literals.\n• S is an answer set of P if and only if S = {l ∈ LitP | P ∪ ∆S `MP l}. • SNAF = S ∪ ∆S is an answer set with NAF literals of P if and only if SNAF = {k | P ∪ ∆S `MP k}."
    }, {
      "heading" : "Proof",
      "text" : "We prove both items:\n• If S is an answer set of P then S = AS(PS). This means that ∀l ∈ S there exists a clause l ← l1, . . . , lm ∈ PS such that l1, . . . , lm ∈ S. It follows that there exists a clause l ← l1, . . . , lm, not lm+1, . . . , not lm+n ∈ P such that l1, . . . , lm ∈ S and lm+1, . . . , lm+n /∈ S. Then, by Definition 1, not lm+1, . . . , not lm+n ∈ ∆S . Thus, P ∪ ∆S `MP l. For the other direction, if P ∪ ∆S `MP l then (1) l ∈ ∆S or (2) there exists a clause l← l1, . . . , lm, not lm+1, . . . , not lm+n ∈ P such that ∀li(1 ≤ i ≤ m) : P ∪ ∆S `MP\nli and ∀not lj(m + 1 ≤ j ≤ m + n) : P ∪ ∆S `MP not lj . In the first case, l is a NAF literal which should not be part of S. This is satisfied since l /∈ LitP and therefore l /∈ S = {l ∈ LitP | P ∪ ∆S `MP l}. In the second case, since P contains no clause with a NAF literal in its head it follows that not lj ∈ ∆S , i.e. ∀lj : lj /∈ S. Then, by definition of reduct, l ← l1, . . . , lm ∈ PS . Since P ∪ ∆S `MP li, li ∈ S, thereby satisfying the condition of an answer set for l to be in S.\n• If SNAF is an answer set with NAF literals then by Definition 1, SNAF = S ∪ ∆S . Then, by the first item SNAF = {l ∈ LitP | P ∪ ∆S `MP l} ∪ ∆S . By Notation 2, ∀not li ∈ ∆S : ∆S `MP not li and therefore P ∪ ∆S `MP not li for any logic program P. Thus, not restricting the conclusions of modus ponens to LitP yields SNAF = {k | P ∪ ∆S `MP k}. For the other direction, if P ∪ ∆S `MP k then by the proof of the first item k ∈ ∆S or k ∈ S where S is an answer set. Thus, SNAF is equivalent to S ∪ ∆S , satisfying Definition 1."
    }, {
      "heading" : "2.2 An intuitive example of ASP",
      "text" : "Let Dr. Smith be an ophtalmologist (an eye doctor) and let one of his patients be Peter, who is diagnosed by Dr. Smith as being shortsighted. Based on this diagnosis, Dr. Smith has to decide on the most suitable treatment for Peter, taking into account the additional information he has about his patient, namely that Peter is afraid to touch his own eyes, that he is a student, and that he likes to do sports. Based on this information and his specialist knowledge, Dr. Smith decides that the most appropriate treatment for Peter’s shortsightedness is laser surgery. Dr. Smith now checks whether this decision is in line with the recommendation of his decision support system, which is implemented in ASP.\nExample 1\nThe following logic program Pdoctor represents the decision support system used by Dr. Smith. It encodes some general world knowledge as well as an ophtalmologist’s specialist knowledge about the possible treatments of shortsightedness. Pdoctor also captures the additional information that Dr. Smith has about his shortsighted pa-\ntient Peter.\ntightOnMoney ← student, not richParents caresAboutPracticality ← likesSports\ncorrectiveLens← shortSighted, not laserSurgery laserSurgery ← shortSighted, not tightOnMoney, not correctiveLens\nglasses← correctiveLens, not caresAboutPracticality, not contactLens\ncontactLens← correctiveLens, not afraidToTouchEyes, not longSighted, not glasses\nintraocularLens← correctiveLens, not glasses, not contactLens shortSighted←\nafraidToTouchEyes← student←\nlikesSports←\nPdoctor has only one answer set Sdoctor = {shortSighted, afraidToTouchEyes, student, likesSports, tightOnMoney, correctiveLens, caresAboutPracticality, intraocularLens}.\nTo Dr. Smith’s surprise, the answer set computed by the decision support system contains the literal intraocularLens but not laserSurgery, suggesting that Peter should get intraocular lenses instead of having laser surgery. Dr. Smith now finds himself in the difficult situation to determine whether to trust his own treatment decision or whether to take up the system’s suggestion even without understanding it. Providing Dr. Smith with an explanation of the system’s treatment suggestion or with an explanation as to why his own intended decision might be wrong would make it considerably easier for Dr. Smith to decide whether to trust himself or the decision support system.\nWe will use this example of Dr. Smith and his patient Peter to demonstrate our explanation approaches and to show how they can be applied to explain the solutions of a decision support system which is based on ASP."
    }, {
      "heading" : "2.3 ABA frameworks",
      "text" : "Much of the literature on argumentation in Artificial Intelligence focuses on two kinds of argumentation frameworks. Abstract Argumentation (Dung 1995b) assumes that a set of abstract entities (the arguments) are given along with an attack relation between them. In contrast, structured argumentation frameworks such as (Prakken 2010; Garćıa and Simari 2004; Governatori et al. 2004) provide mechanisms for the construction of arguments from given knowledge, mostly in the form of rules, and for identifying the attack relation between arguments based on the structure of arguments. We will here focus on the structured argumentation\nframework of (Bondarenko et al. 1997; Dung et al. 2009) called Assumption-Based Argumentation (ABA).\nAn ABA framework (Dung et al. 2009) is a tuple 〈L,R,A, ¯〉, where\n• (L,R) is a deductive system with L a formal language and R a set of inference rules of the form α0 ← α1, . . . , αm such that m ≥ 0 and all αi are sentences in L; • A ⊆ L is a non-empty set of assumptions; • ¯ is a total mapping from A into L defining the contrary of each assumption,\nwhere α denotes the contrary of α ∈ A.\nNote that in this paper we use the same notation ← for inference rules in ABA and for clauses in a logic program. This will facilitate the presentation of our methods later. We also adopt the logic programming terminology of “head”, “body”, “fact”, and `MP (see Notation 2) for ABA frameworks. The following definitions are restricted to flat ABA frameworks, where assumptions do not occur as the head of inference rules, as we only need this kind of framework for our purposes.\nIn this paper we use a notion of ABA argument which is slightly different from the definitions in the ABA literature, in that an ABA argument as defined here comprises not only the set of assumptions supporting this argument as in standard ABA, but also the set of facts used in the construction of this argument.\nDefinition 2 (ABA Argument) Let 〈L,R,A, ¯〉 be an ABA framework. An argument for (the conclusion) α ∈ L supported by a set of assumption-premises AP ⊆ A and a set of fact-premises FP ⊆ {β | β ← ∈ R} is a finite tree, where every node holds a sentence in L, such that\n• the root node holds α; • for every node N\n— if N is a leaf then N holds either an assumption or a fact; — if N is not a leaf and N holds the sentence γ0, then there is an inference\nrule γ0 ← γ1, . . . , γm (m > 0) and N has m children, holding γ1, . . . , γm respectively;\n• AP is the set of all assumptions held by leaves; • FP is the set of all facts held by leaves.\nWe now define some further terminology for special kinds of arguments and for\nnaming arguments in general.\nNotation 3 An argument for α supported by AP and FP is denoted (AP,FP ) ` α. We often use a unique name to denote an argument, e.g. A : (AP,FP ) ` α is an argument with name A. With an abuse of notation, the name of an argument sometimes stands for the whole argument, for example A denotes the argument A : (AP,FP ) ` α. An argument of the form ({α}, ∅) ` α is called assumption-argument, and similarly an\nargument of the form (∅, {α}) ` α is called fact-argument. Given some argument A : (AP,FP ) ` α with β ∈ AP and γ ∈ FP , we say that ({β}, ∅) ` β is the assumptionargument of the assumption-premise β of argument A and that (∅, {γ}) ` γ is the fact-argument of the fact-premise γ of A.\nDefinition 2 generates the notion of argument in (Dung et al. 2009): If (AP,FP ) ` α is an argument according to Definition 2, then AP ` α is an argument in (Dung et al. 2009). Conversely, if AP ` α is an argument in (Dung et al. 2009), then there exists some FP ⊆ {β | β ← ∈ R} such that (AP,FP ) ` α is an argument according to Definition 2.\nABA arguments can be naturally formulated in terms of `MP , as follows:\nLemma 2 Let 〈L,R,A, ¯〉 be an ABA framework. (AP,FP ) ` α is an argument in 〈L,R,A, ¯〉 if and only if R ∪ AP `MP α and AP ⊆ A."
    }, {
      "heading" : "Proof",
      "text" : "This follows directly from the definition of arguments.\nThe attack relation between arguments defined here is a slight variation of the notion in (Dung et al. 2009), as it considers arguments with both assumption- and fact-premises.\nDefinition 3 (Attacks) An argument (AP1, FP1) ` α1 attacks an argument (AP2, FP2) ` α2 on the assumption-premise α3 if and only if α3 ∈ AP2 and α3 = α1. Equivalently, we say that (AP2, FP2) ` α2 is attacked by (AP1, FP1) ` α1 or that (AP1, FP1) ` α1 is an attacker of (AP2, FP2) ` α2. A set of arguments X attacks an argument B if and only if there is an argument A ∈ X which attacks B. A set of arguments X1 attacks a set of arguments X2 if and only if X1 attacks some argument B ∈ X2.\nThis definition of attack is purely based on the notion of contrary of assumptions, i.e. fact-premises only occur as part of the argument but do not directly influence the attack relation. Since arguments as introduced here and in (Dung et al. 2009) correspond, the attack relation in Definition 3 directly correspond to attacks in (Dung et al. 2009): If an argument (AP1, FP1) ` α1 attacks an argument (AP2, FP2) ` α2 according to Definition 3, then AP1 ` α1 attacks AP2 ` α2 as defined in (Dung et al. 2009). Conversely, if AP1 ` α1 attacks AP2 ` α2 as defined in (Dung et al. 2009), then there exist FP1, FP2 ⊆ {β | β ← ∈ R} such that (AP1, FP1) ` α1 attacks (AP2, FP2) ` α2 according to Definition 3."
    }, {
      "heading" : "2.4 ABA semantics",
      "text" : "The semantics of argumentation frameworks are given in terms of extensions, i.e. sets of arguments deemed to be “winning”. For our purposes we focus on the admissible and on the stable extension semantics introduced in (Dung 1995b) for Abstract Argumentation and in (Bondarenko et al. 1997) for ABA. Let 〈L,R,A, ¯〉 be an ABA framework and let X be a set of arguments in 〈L,R,A, ¯〉.\n• X defends an argument A if and only if X attacks all attackers of A. • X is an admissible extension of 〈L,R,A, ¯〉 if and only if X does not attack\nitself and X defends all arguments in X.\n• X is a stable extension of 〈L,R,A, ¯〉 if and only if X does not attack itself and X attacks each argument in 〈L,R,A, ¯〉 which does not belong to X, or, equivalently, if and only if X = {A in 〈L,R,A, ¯〉 | X does not attack A}.\nAdmissible extensions can also be defined using trees of attacking arguments. An abstract dispute tree (Dung et al. 2006) for an ABA argument A is a (possibly\ninfinite) tree such that:\n1. Every node in the tree is labelled by an argument and is assigned the status\nof proponent or opponent node, but not both.\n2. The root is a proponent node labelled by A. 3. For every proponent node N labelled by an argument B and for every ar-\ngument C attacking B, there exists a child of N which is an opponent node labelled by C. 4. For every opponent node N labelled by an argument B, there exists exactly\none child of N which is a proponent node labelled by an argument which attacks B.\n5. There are no other nodes in the tree except those given by 1-4 above.\nAn abstract dispute tree is admissible (Dung et al. 2009) if and only if no argument labels both a proponent and an opponent node. It has been shown that the set of all arguments labelling proponent nodes in an admissible dispute tree is an admissible extension (Dung et al. 2007). We will use this result to characterize our justification approaches.\nWe now look at some properties of the stable extension semantics which will be used throughout the paper. Lemma 3 characterizes a stable extension in terms of the assumption-premises of arguments contained in this stable extension as all arguments not attacked by this stable extension.\nLemma 3 Let 〈L,R,A, ¯〉 be an ABA framework and letX be a set of arguments in 〈L,R,A, ¯〉. X is a stable extension of 〈L,R,A, ¯〉 if and only if X = {(AP,FP ) ` α | AP ⊆ ΛX} where ΛX = {β ∈ A | @(AP,FP ) ` β ∈ X}."
    }, {
      "heading" : "Proof",
      "text" : "Similar to the proof of Theorem 3.10 in (Bondarenko et al. 1997): By the definition of stable extension, X is a stable extension if and only if X = {A in 〈L,R,A, ¯〉 | X does not attack A}. Then, X = {(AP1, FP1) ` α1 | @(AP2, FP2) ` α2 ∈ X attacking (AP1, FP1) ` α1} by Definitions 2 and 3, and X = {(AP1, FP1) ` α1 | @(AP2, FP2) ` α2 ∈ X s.t. β ∈ AP1, β = α2} by Definition 3. This can be split into X = {(AP1, FP1) ` α1 | ∀β ∈ AP1 : β ∈ ΛX} where ΛX = {β ∈ A | @(AP2, FP2) ` α2 ∈ X s.t. α2 = β}.\nAfter defining a stable extension in terms of the properties of its arguments, we now take a closer look at conditions for an argument to be or not to be contained\nin a stable extension. The following lemma characterizes the arguments contained in a stable extension: An argument is part of a stable extension if and only if the assumption-arguments of all its assumption-premises and the fact-arguments of all its fact-premises are in this stable extension.\nLemma 4 Let 〈L,R,A, ¯〉 be an ABA framework and letX be a stable extension of 〈L,R,A, ¯〉. (AP,FP ) ` α ∈ X if and only if ∀β ∈ AP it holds that ({β}, ∅) ` β ∈ X and ∀γ ∈ FP it holds that (∅, {γ}) ` γ ∈ X."
    }, {
      "heading" : "Proof",
      "text" : "Note that fact-arguments are always part of a stable extension as they cannot be attacked, so we only focus on assumption-arguments.\n• From left to right: If (AP,FP ) ` α ∈ X then by Lemma 3 ∀β ∈ AP , (AP1, FP1) ` β /∈ X. Consequently, ({β}, ∅) ` β is not attacked by X, so by definition of stable extension ({β}, ∅) ` β ∈ X. • From right to left: If ∀β ∈ AP it holds that ({β}, ∅) ` β ∈ X then by definition of stable extension no ({β}, ∅) ` β is attacked by X, so for none of the β ∈ AP there exists an (AP1, FP1) ` β ∈ X. Thus, (AP,FP ) ` α is not attacked by X, so (AP,FP ) ` α ∈ X.\nThe following lemma characterizes conditions for an argument not to be in a given stable extension: An argument is not part of a stable extension if and only if the assumption-argument of one of its assumption-premises is not in this stable extension:\nLemma 5 Let 〈L,R,A, ¯〉 be an ABA framework and letX be a stable extension of 〈L,R,A, ¯〉. (AP,FP ) ` α /∈ X if and only if ∃β ∈ AP such that ({β}, ∅) ` β /∈ X."
    }, {
      "heading" : "Proof",
      "text" : "• From left to right: If (AP,FP ) ` α /∈ X then (AP,FP ) ` α is attacked by X on some β ∈ AP . Consequently, ({β}, ∅) ` β is attacked by X, so ({β}, ∅) ` β /∈ X. • From right to left: If ∃β ∈ AP such that ({β}, ∅) ` β /∈ X then ({β}, ∅) ` β is attacked by X, meaning that there is some (AP1, FP1) ` β ∈ X. Thus, (AP,FP ) ` α is attacked by X on β, so (AP,FP ) ` α /∈ X."
    }, {
      "heading" : "3 Translating a logic program into an ABA framework",
      "text" : "In order to use ABA for the justification of literals with respect to an answer set of a consistent logic program, the logic program has to be expressed as an ABA framework first."
    }, {
      "heading" : "3.1 The translation",
      "text" : "We use the approach of (Bondarenko et al. 1997) for translating a logic program into an ABA framework, where the clauses of a logic program form the set of ABA rules and NAF literals are used as assumptions in ABA.\nDefinition 4 (Translated ABA framework) Let P be a logic program. ABAP = 〈LP ,RP ,AP , ¯〉 is the translated ABA framework of P where:\n• RP = P • AP = NAFP • for every not l ∈ AP : not l = l • LP = LitP ∪ NAFP\nNote that the clauses of a logic program can be directly used as rules in the translated ABA framework as we utilize the same notation for both of them. Note also that translated ABA frameworks are always flat since NAF literals do not occur in the head of clauses of a logic program.\nExample 2 The following logic program P1 will serve as a running example throughout the paper, where LitP1 = {a,¬a, c,¬c, d,¬d, e,¬e}:\na← not ¬a a← ¬a, not c, not e ¬a← not c, not d c← not e d← not ¬a e←\nThe translated ABA framework of P1 is ABAP1 = 〈LP1 ,RP1 ,AP1 , ¯〉 with:\n• RP1 = P1 • AP1 = NAFP1 = {not a, not ¬a, not c, not ¬c, not d, not ¬d, not e, not ¬e} • not a = a; not ¬a = ¬a; not c = c; not ¬c = ¬c; not d = d; not ¬d = ¬d; not e = e; not ¬e = ¬e\n• LP1 = LitP1 ∪ NAFP1 The following fourteen arguments can be constructed in ABAP1 , including eight assumption-arguments (A1 - A8) and one fact-argument (A14): A1 : ({not a}, ∅) ` not a A2 : ({not ¬a}, ∅) ` not ¬a A3 : ({not c}, ∅) ` not c A4 : ({not ¬c}, ∅) ` not ¬c A5 : ({not d}, ∅) ` not d A6 : ({not ¬d}, ∅) ` not ¬d A7 : ({not e}, ∅) ` not e\nA8 : ({not ¬e}, ∅) ` not ¬e A9 : ({not ¬a}, ∅) ` a A10 : ({not c, not d, not e}, ∅) ` a A11 : ({not c, not d}, ∅) ` ¬a A12 : ({not e}, ∅) ` c A13 : ({not ¬a}, ∅) ` d A14 : (∅, {e}) ` e The attacks between these arguments are given as a graph in Figure 1. An arrow from a node N1 to a node N2 in the graph represents that the argument held by N1 attacks the argument held by N2."
    }, {
      "heading" : "3.2 Correspondence between Answer Sets and Stable Extensions",
      "text" : "In this section, we describe the relationship between answer sets of a logic program and stable extensions of the translated ABA framework. This connection will be used for our justification approaches. Theorem 1 states that an answer set with\nNAF literals consists of the conclusions of all arguments in the “corresponding” stable extension. Conversely, Theorem 2 expresses that a stable extension consists of all arguments supported by NAF literals which are satisfied with respect to the “corresponding” answer set. Note that part of this correspondence has been stated without a formal proof in (Bondarenko et al. 1997).\nTheorem 1 Let P be a logic program and let ABAP = 〈LP ,RP ,AP , ¯ 〉. Let X be a set of arguments in ABAP and let T = {k | ∃(AP,FP ) ` k ∈ X} be the set of all conclusions of arguments in X. X is a stable extension of ABAP if and only if T is an answer set with NAF literals of P."
    }, {
      "heading" : "Proof",
      "text" : "• X is a stable extension of ABAP • iff X = {(AP1, FP1) ` k is an argument in ABAP | AP1 ⊆ ΛX} with\nΛX = {not l ∈ AP | @(AP2, FP2) ` l ∈ X} (by Lemma 3) • iff X = {(AP1, FP1) ` k | AP1 ⊆ ΛX ,RP ∪ ΛX `MP k} with\nΛX = {not l ∈ AP | @(AP2, FP2) ` l ∈ X} (by Lemma 2) • iff X = {(AP1, FP1) ` k | AP1 ⊆ ΛX ,P ∪ ΛX `MP k} with\nΛX = {not l ∈ NAFP | @(AP2, FP2) ` l ∈ X} (by Definition 4) • iff X = {(AP1, FP1) ` k | AP1 ⊆ ΛX ,P ∪ ΛX `MP k} with\nΛX = {not l ∈ NAFP | l /∈ T} and T = {k | ∃(AP,FP ) ` k ∈ X} (by construction of T , see above)\n• iff X = {(AP1, FP1) ` k | AP1 ⊆ ∆T ,P ∪ ∆T `MP k} with ∆T = {not l ∈ NAFP | l /∈ T} and T = {k | ∃(AP,FP ) ` k ∈ X} (by Definition 1) • iff ∆T = {not l ∈ NAFP | l /∈ T} and T = {k | P ∪ ∆T `MP k} (substituting X in T ) • iff T is an answer set with NAF literals of P (by Lemma 1)\nTheorem 2 Let P be a logic program and let ABAP = 〈LP ,RP ,AP , ¯〉. Let T ⊆ LitP be a set of classical literals and let X = {(AP,FP ) ` k | AP ⊆ ∆T } be the set of arguments in ABAP whose assumption-premises are in ∆T . T is an answer set of P if and only if X is a stable extension of ABAP ."
    }, {
      "heading" : "Proof",
      "text" : "• T is an answer set of P • iff T = {l1 ∈ LitP | P ∪ ∆T `MP l1} with\n∆T = {not l ∈ NAFP | l /∈ T} (by Lemma 1 and Definition 1) • iff T = {k ∈ LP\\AP | RP ∪ ∆T `MP k} with\n∆T = {not l ∈ AP | l /∈ T} (by Definition 4) • iff T = {k ∈ LP\\AP | ∃(AP,FP ) ` k,AP ⊆ ∆T } with\n∆T = {not l ∈ AP | l /∈ T} (by Lemma 2)\n• iff T = {k ∈ LP\\AP | ∃(AP,FP ) ` k,AP ⊆ ∆T } with ∆T = {not l ∈ AP | P ∪ ∆T 0MP l} (by Lemma 1) • iff T = {k ∈ LP\\AP | ∃(AP,FP ) ` k,AP ⊆ ∆T } with ∆T = {not l ∈ AP | @(AP,FP ) ` l, AP ⊆ ∆T } (by Lemma 2) • iff T = {k ∈ LP\\AP | ∃(AP,FP ) ` k,AP ⊆ ∆T } with ∆T = {not l ∈ AP | @(AP,FP ) ` l ∈ X} and X = {(AP,FP ) ` k | AP ⊆ ∆T } (by construction of X, see above) • iff T = {k ∈ LP\\AP | ∃(AP,FP ) ` k,AP ⊆ ΛX} with ΛX = {not l ∈ AP | @(AP,FP ) ` l ∈ X} and X = {(AP,FP ) ` k | AP ⊆ ΛX} (by Lemma 3) • iff ΛX = {not l ∈ AP | @(AP,FP ) ` l ∈ X} and X = {(AP,FP ) ` k | AP ⊆ ΛX} • iff X is a stable extension of ABAP (by Lemma 3)\nExample 3 The logic program P1 from Example 2 has two answer sets: S1 = {e, d, a} and S2 = {e,¬a}. The respective sets of satisfied NAF literals are ∆S1 = {not ¬a, not c, not ¬c, not ¬d, not ¬e} and ∆S2 = {not a, not c, not ¬c, not d, not ¬d, not¬e}. Considering the attacks between arguments in the translated ABA framework ABAP1 (see Figure 1), two stable extensions can be determined for ABAP1 : A4, A6, A8, and A14 have to be part of all stable extensions as they are not attacked. Then, A7, A10, and A12 cannot be in any stable extension as they are attacked by A14. Consequently, A3 is part of all stable extensions since it is only attacked by A12, which is definitely not contained in any stable extension. As A11 and A13 attack each other and are not furthered attacked by other arguments, there are two stable extensions, one containing A13 and the other one containing A11. The first stable extension also comprises A2 and A9 as A13 attacks all their attackers, whereas the second one additionally comprises A1 and A5 since A11 attacks all their attackers. Thus, the two stable extensions of ABAP1 are E1 = {A2, A3, A4, A6, A8, A9, A13, A14} and E2 = {A1, A3, A4, A5, A6, A8, A11, A14}. As expected, the conclusions of arguments in the stable extensions, {not ¬a, not c, not ¬c, not ¬d, not ¬e, a, d, e} for E1 and {not a, not c, not ¬c, not d, not ¬d, not ¬e,¬a, e} for E2, coincide with S1NAF and S2NAF , as stated in Theorem 1. Conversely, the two sets of arguments whose assumption-premises are subsets of ∆S1 and ∆S2 , respectively, coincide with the two stable extensions E1 and E2, respectively, as stated in Theorem 2.\nThe following notation introduces some terminology to refer to the stable exten-\nsion which corresponds to a given answer set.\nNotation 4 Given an answer set S of P and a stable extension E of ABAP such that SNAF = {k | ∃(AP,FP ) ` k ∈ E}, E is called the corresponding stable extension of S. Given a literal k ∈ SNAF and the corresponding stable extension E of S, an argument A ∈ E with conclusion k is called a corresponding argument of k.\nIt is easy to show that for every literal k in an answer set with NAF literals there is at least one corresponding argument in the corresponding stable extension.\nConversely, if a literal k is not contained in an answer set with NAF literals, then no argument with conclusion k is part of the corresponding stable extension.\nTheorem 3 Let P be a logic program, S an answer set of P, and E the corresponding stable extension of S in ABAP . Let k ∈ LitP ∪ NAFP .\n1. If k ∈ SNAF, then there exists an argument A ∈ E such that A : (AP,FP ) ` k with AP ⊆ ∆S and FP ⊆ S. 2. If k /∈ SNAF, then there exists no A : (AP,FP ) ` k in ABAP such that A ∈ E ."
    }, {
      "heading" : "Proof",
      "text" : "1. By Theorem 1, SNAF = {k1 | ∃(AP,FP ) ` k1 ∈ E}, so if k ∈ SNAF then there exists at least one argument A : (AP,FP ) ` k ∈ E . By Theorem 2, E = {(AP1, FP1) ` k1 | AP1 ⊆ ∆S}, so it follows that for argument A, AP ⊆ ∆S . Furthermore, FP ⊆ S because FP ⊆ {β | β ← ∈ P} and for consistent logic programs it trivially holds that {β | β ←∈ P} ⊆ S. 2. Assume that there exists A : (AP,FP ) ` k in ABAP such that A ∈ E . Then according to Theorem 1, k ∈ SNAF. Contradiction.\nExample 4 As demonstrated in Example 3, the answer sets of P1 correspond to the stable extensions of ABAP1 , where S1 corresponds to E1 and S2 corresponds to E2. When taking a closer look at S1NAF , we can verify that every literal has a corresponding argument in E1: e has A14, d has A13, a has A9, not ¬a has A2, not c has A3, and so on. Furthermore, for all literals not contained in S1NAF , there is no argument with this conclusion in the stable extension E1, e.g. ¬a /∈ S1NAF and A11 /∈ E1. The same relationship holds between S2 and E2.\nNote that the first part of Theorem 3 only states that for a literal k in the answer set with NAF literals there exists a corresponding argument in the corresponding stable extension. However, there might be further arguments (AP,FP ) ` k which are not part of the corresponding stable extension, where AP * ∆S . Note also that the second part of Theorem 3 does not exclude the existence of arguments with conclusion k. It merely states that no such argument is contained in the corresponding stable extension.\nExample 5 Consider the logic program P1 and its answer set S1. a ∈ S1 has the corresponding argument A9 in E1, but there is another argument with conclusion a in ABAP1 which is not in E1, namely A10. Furthermore, c /∈ S1 but there exists an argument with conclusion c in ABAP1 , namely A12. As expected, this argument is not contained in the corresponding stable extension E1.\nTheorem 3, part 1, provides the starting point for our justification approaches as it allows us to explain why a literal is in an answer set based on the reasons for\na corresponding argument to be in the corresponding stable extension. Similarly, Theorem 3, part 2, is a starting point for justifying that a literal is not contained in an answer set based on arguments for that literal, all of which are not contained in the corresponding stable extension. In ABA it is easy to explain why an argument is or is not contained in a stable extension: An argument is part of a stable extension if it is not attacked by it. Since the stable extension attacks all arguments which are not part of it, this entails that an argument in the stable extension is defended by the stable extension, i.e. the stable extension attacks all attackers of this argument. Conversely, an argument is not part of a stable extension if it is attacked by this stable extension. In the following section, we will make use of these results in order to develop a justification method that provides explanations in terms of arguments and attacks between them."
    }, {
      "heading" : "4 Attack Trees",
      "text" : "Our first justification approach explains why arguments are or are not contained in a stable extension by constructing an Attack Tree of this argument with respect to the stable extension. This tree of attacking arguments is later used to construct a justification in terms of literals: Due to the correspondence between answer sets and stable extensions, a justification of a literal k with respect to an answer set can be obtained from an Attack Tree of an argument with conclusion k constructed with respect to the corresponding stable extension. In this section we define the notion of Attack Trees and show their relationship with abstract dispute trees for ABA, characterizing the explanations they provide as admissible fragments of the stable extension as well as of the answer set if an Attack Tree is constructed with respect to a corresponding stable extension."
    }, {
      "heading" : "4.1 Constructing Attack Trees",
      "text" : "Nodes in an Attack Tree hold arguments which are labelled either '+' or '−'. An Attack Tree of an argument A has A itself in the root node, where either one or all attackers of A form the child nodes of this root. In the same way, every of these child nodes holding some argument B have either all or one of B’s attackers as children, and so on. Whether only one or all attackers of an argument are considered as child nodes depends on the argument’s label in the Attack Tree, which is determined with respect to a given set of arguments (typically a stable extension of the translated ABA framework). If an argument is part of given set, it is labelled '+' and has all its attackers as child nodes. If the argument is not contained in the set, it is labelled '−' and has exactly one of its attackers as a child node.\nDefinition 5 (Attack Tree) Let P be a logic program, X a set of arguments in ABAP , and A an argument in ABAP . An Attack Tree of A (constructed) with respect toX, denoted attTreeX(A), is a (possibly infinite) tree such that:\n1. Every node in attTreeX(A) holds an argument in ABAP , labelled '+' or '−'.\n2. The root node is A+ if A ∈ X or A− if A /∈ X. 3. For every node A+N and for every argument Ai attacking AN in ABAP , there exists\na child node A−i of A + N .\n4. Every node A−N\n(i) has no child node if AN is not attacked in ABAP or if for all attackers Ai of\nAN : Ai /∈ X; or else (ii) has exactly one child node A+i for some Ai ∈ X attacking AN .\n5. There are no other nodes in attTreeX(A) except those given in 1-4.\nIf attTreeX(A) is an Attack Tree of A with respect to X we also say that A has the Attack Tree attTreeX(A). Note that due to condition 4(ii), where only one of possibly many arguments Ai is chosen, an argument can have more than one Attack Tree. Furthermore, note the difference between 3, where Ai is any argument attacking AN , and 4(ii), where Ai has to be an attacking argument contained in X.\nNotation 5 If A ∈ X, and thus the root node of attTreeX(A) is A+, we denote the Attack Tree as attTree+X(A) and call it a positive Attack Tree. If A /∈ X, and thus the root node of attTreeX(A) is A −, we denote the Attack Tree as attTree−X(A) and call it a negative Attack Tree.\nThe next example illustrates the notion of Attack Trees with respect to a set of\narguments which is a stable extension.\nExample 6 We consider the logic program P1 and its translated ABA framework ABAP1 (see Example 2). Figure 2 shows the two negative Attack Trees of argument A10 with respect to the stable extension E1 = {A2, A3, A4, A6, A8, A9, A13, A14}, i.e. attTree−E1(A10)1 and attTree − E1(A10)2. Since A10 /∈ E1, the root node of all Attack Trees of A10 holds A − 10, and consequently has exactly one or not attacker of A10 as a child node. A10 is attacked by the three arguments A12, A13, and A14 (see Figure 1), so these are the candidates for being a child node of A−10. However, A + 12 cannot serve as a child node of A−10 as A12 /∈ E1 (see condition 4(ii) in Definition 5). Since both A13 and A14 are contained in E1, either of them can be used as a child node of A−10, leading to two possible Attack Trees of A10. The left of Figure 2 depicts the negative Attack Tree attTree−E1(A10)1 where A + 14 is chosen as the child node of A − 10, whereas the right illustrates attTree−E1(A10)2 where A + 13 is chosen. attTree − E1(A10)1 ends with A+14 since A14 is not attacked in ABAP1 . In contrast, choosing A + 13 as the child node of A−10 leads to an infinite negative Attack Tree attTree − E1(A10)2: A+13 has a single child A − 11 since A11 is the only argument attacking A13; A11 is attacked by both A12 and A13 in P1, but only A+13 can serve as a child node of A − 11 as A12 /∈ E1; at this point, the Attack Tree starts to repeat itself, since the only possible child node of A−11 is A + 13, whose only child node is A − 11, and so on. With respect to the stable extension E2 = {A1, A3, A4, A5, A6, A8, A11, A14} (see\nExample 3), A10 has a unique negative Attack Tree attTree − E2(A10), which is exactly the same as attTree−E1(A10)1. The reason is that only A + 14 can serve as a child node of A−10 since both A12 /∈ E2 and A13 /∈ E2.\nFigure 2 illustrates that an argument might have more than one Attack Tree, as well as that Attack Trees can be infinite. Figure 3 depicts another negative Attack Tree, illustrating the case where a node labelled '+' has more than one child node. Note that every argument in an ABA framework has at least one Attack Tree. However, an Attack Tree may solely consist of the root, for example the unique positive Attack Tree attTree+E1(A14) of A14 with respect to the stable extension E1 consists of only one node, namely the root node A+14 as this argument has no attackers.\nFrom the definition of Attack Trees it follows that the Attack Trees of an argu-\nment are either all positive or all negative.\nLemma 6 Let P be a logic program and let X be a set of arguments in ABAP .\n1. If A ∈ X then all Attack Trees of A with respect to X are positive Attack Trees attTree+X(A). 2. If A /∈ X then all Attack Trees of A with respect to X are negative Attack Trees attTree−X(A)."
    }, {
      "heading" : "Proof",
      "text" : "This follows directly from Definition 5 and Notation 5.\nIntuitively, an Attack Tree of an argument with respect to a set of arguments explains why the argument is or is not in the set by showing either that the argument is defended by the set, i.e. the set attacks all attackers of the argument, or that the argument is attacked by the sets and cannot defend itself against it. The first case explains why the argument is part of the set, whereas the second one justifies that the argument is not part of the set."
    }, {
      "heading" : "4.2 Attack Trees with respect to Stable Extensions",
      "text" : "For justification purposes we construct Attack Trees with respect to stable extensions rather than an arbitrary set of arguments. This enables us to later extract a justification of a literal with respect to an answer set from an Attack Tree constructed with respect to the corresponding stable extension. In this section we show some properties of Attack Trees when constructed with respect to a stable extension, which hold for both positive and negative Attack Trees.\nOne of these characteristics is that we can deduce whether or not an argument held by a node in an Attack Tree constructed with respect to a stable extension is contained in this stable extension: all arguments labelled '+' in the Attack Tree are contained in the stable extension, whereas all arguments labelled '−' are not in the stable extension.\nLemma 7 Let P be a logic program and let E be a stable extension of ABAP . Let Υ = attTreeE(A) be an Attack Tree of some argument A in ABAP with respect to E . Then:\n1. For each node A+i in Υ: Ai ∈ E . 2. For each node A−i in Υ: Ai /∈ E ."
    }, {
      "heading" : "Proof",
      "text" : "1. A+i is either the root node, then by definition Ai ∈ E , or it is the only child node of some A−N , meaning that by definition Ai ∈ E . 2. A−i is either the root node, then by definition Ai /∈ E , or A − i is a child node of some\nA+N , and Ai attacks AN . From part 1 we know that AN ∈ E , hence Ai /∈ E because E does not attack itself.\nAnother interesting characteristic of an Attack Tree constructed with respect to a stable extension is that all nodes holding arguments labelled '−' have exactly one child node, rather than none. Furthermore, all leaf nodes hold arguments labelled '+'.\nLemma 8 Let P be a logic program and let E be a stable extension of ABAP . Let Υ = attTreeE(A) be an Attack Tree of some argument A in ABAP with respect to E . Then:\n1. Every node A−N in Υ has exactly one child node. 2. All leaf nodes in Υ hold arguments labelled '+'."
    }, {
      "heading" : "Proof",
      "text" : "1. By condition 4 in Definition 5, any node A−N in an Attack Tree has either no\nor exactly one child node. By Lemma 7 AN /∈ E . Assume that A−N has no child node. Then AN is not attacked in ABAP . But by definition of stable extension all arguments not contained in a stable extension are attacked by the stable extension. Contradiction. 2. This follows directly from part 1 as nodes holding an argument labelled '−' always have a child node and thus cannot be a leaf node.\nNote that infinite branches of Attack Trees do not have leaf nodes, in which case the second part of Lemma 8 is trivially satisfied.\nLemma 8 highlights how an Attack Tree justifies an argument A with respect to a stable extension. If the argument A is part of the stable extension, the Attack Tree shows that the reason is that A is defended by the stable extension. This means that any attackers of A are counter-attacked by an argument in the stable extension, defending A against the attacker, and even if the defending argument is further attacked, there will be another argument in the stable extension defending this defender, until eventually the defending arguments from the stable extension are not further attacked, forming the leaf nodes of the Attack Tree. Thus A is defended by the stable extension and consequently belongs to it. If an argument A is not part of the stable extension, the leaf nodes of the Attack Tree again hold arguments from the stable extension, but this time these leaf nodes defend the argument attacking A, meaning that this attacker is contained in the stable extension. Thus, A is attacked by the stable extension and consequently A is not part of the stable extension.\nLemma 8 also emphasizes the idea that to justify an argument which is not in the stable extension, it is enough to show that one of its attackers is contained in the stable extension, even if there might be more than one such attacker. This follows the general proof concept that something can be disproven by giving one counterexample. So an Attack Tree disproves that the argument held by the root node is\nin the stable extension by showing one way in which the argument is attacked by the stable extension.\nFrom these considerations is follows directly that the subtree of any negative Attack Tree obtained by removing the root node is a positive Attack Tree of the argument attacking the root node.\nLemma 9 Let P be a logic program and let E be a stable extension of ABAP . Let Υ = attTree−E (A) be an Attack Tree of some argument A /∈ E and let A + i be the (only) child node of the root node A− in attTree−E (A). Let Υ ′ be the subtree of Υ with root node A+i obtained from Υ by removing its root node A −. Then Υ′ is a positive Attack Tree of Ai."
    }, {
      "heading" : "Proof",
      "text" : "This follows directly from Definition 5 and Notation 5.\nThis observation will be useful when comparing Attack Trees to abstract dispute trees in the following section. Example 7 demonstrates how an Attack Tree can be used to explain why a literal is or is not contained in an answer set in terms of an argument for this literal.\nExample 7\nConsider Dr. Smith, his patient Peter, and the decision support system introduced in Section 2.2. In order to explain to Dr. Smith why laserSurgery is not a suggested treatment of the decision support system, an Attack Tree for an argument with conclusion laserSurgery with respect to the corresponding stable extension of the answer set Sdoctor can be constructed. Figure 4 displays such an Attack Tree, which expresses that Peter should not have laser surgery as the decision to use laser surgery is based on the assumption that the patient is not tight on money; however there is evidence that Peter is tight on money as he is known to be a student and there is no evidence against the assumption that his parents are not rich. Note that this is not the only Attack Tree for A1 and therefore not the only possible explanation why Peter should not have laser surgery: a second Attack Tree can be constructed using an argument with conclusion correctiveLens as an attacker of A1.\nOn the other hand, Dr. Smith might want to know why the treatment recommended by the decision support system is intraocularLens. The respective Attack Tree is illustrated in Figure 5. It expresses that Peter should get intraocular lenses because for every possible evidence against intraocular lenses (A1, A4, A6) there is counter-evidence (A2, A5, and A7 respectively): for example, receiving intraocular lenses is based on the assumption that it has not been decided that the patient should have glasses. Even though there is some evidence that Peter could have glasses, this evidence is based on the assumption that he does not care about the practicality of his treatment. However, it is known that Peter cares about practicality since he likes to do sports."
    }, {
      "heading" : "4.3 Relationship between Attack Trees and Abstract Dispute Tress",
      "text" : "In order to further characterize Attack Trees, we prove that Attack Trees constructed with respect to stable extensions are special cases of abstract dispute trees (Dung et al. 2006). Using this correspondence, we show that Attack Trees provide explanations of an argument in terms of an admissible fragment of the stable extension. This result is then extended, proving that given a literal k and an answer set, an Attack Tree of an argument with conclusion k with respect to the corresponding stable extension provides a justification in terms of an admissible fragment of the answer set. We first define a translation of the nodes holding arguments labelled '+' and '−' in Attack Trees into the status of proponent and opponent nodes in abstract dispute trees.\nDefinition 6 (Translated Abstract Dispute Tree) Let P be a logic program, X a set of arguments in ABAP , and attTreeX(A) an\nAttack Tree of some argument A in ABAP with respect to X. The translated abstract dispute tree TX(A) is obtained form attTreeX(A) by assigning the status of proponent to all nodes holding an argument labelled '+', the status of opponent to all nodes holding an argument labelled '−', and dropping the labels '+' and '−' of all arguments in the tree.\nIf Attack Trees are constructed with respect to a stable extension, they corre-\nspond to abstract dispute trees in the following way:\nLemma 10 Let P be a logic program and E a stable extension of ABAP . Let attTreeE(A) be an Attack Tree of some argument A in ABAP with respect to E and let TE(A) be the translated abstract dispute tree. Then:\n1. If A ∈ E , then TE(A) is an abstract dispute tree for A. 2. If A /∈ E , then the subtree of TE(A) with root node Ai, where A+i is the only child\nof the root A− in attTreeE(A), is an abstract dispute tree for Ai."
    }, {
      "heading" : "Proof",
      "text" : "This follows directly from the definition of abstract dispute trees and Lemma 8.\nNote that the converse of Lemma 10.1 does not hold, i.e. it is not the case that every abstract dispute tree for an argument A corresponds to an Attack Tree attTreeE(A). Example 8 illustrates Lemma 10 as well as that its converse does not hold.\nExample 8 Let P2 be the following logic program:\na← not a, not b b← not a, not c c← not b\nSix arguments can be constructed in the translated ABA framework ABAP2 :\nA1 : ({not a}, ∅) ` not a A4 : ({not a, not b}, ∅) ` a A2 : ({not b}, ∅) ` not b A5 : ({not a, not c}, ∅) ` b A3 : ({not c}, ∅) ` not c A6 : ({not b}, ∅) ` c\nThe only stable extension of ABAP2 is E = {A1, A3, A5}. Figure 6 illustrates the unique negative Attack Tree attTree−E (A4) of A4 with respect to E . Constructing the translated abstract dispute tree of attTree−E (A4) results in the tree shown in Figure 7. As stated in Lemma 10.2 deleting the opponent root node of the translated abstract dispute tree TE(A4) yields an abstract dispute tree for A5. Figure 8 gives an example of an abstract dispute tree which does not correspond to an Attack Tree, showing that the converse of Lemma 10 does not hold. The abstract dispute tree for A6 starts with a proponent node, which corresponds to the label '+' in an Attack Tree. However,any Attack Tree of A6 is negative since A6 /∈ E , so the root\nnode is always A−6 . Thus, there is no Attack Tree which corresponds to the abstract dispute tree for A6.\nUsing the correspondence with abstract dispute trees, we can further characterize Attack Trees constructed with respect to a stable extension as representing admis-\nsible fragments of this stable extension. Starting with positive Attack Trees, we show that translated abstract dispute trees of positive Attack Trees with respect to a stable extension are admissible.\nLemma 11 Let P be a logic program, E a stable extension of ABAP , and A some argument in E . For every positive Attack Tree attTree+E (A) of A with respect to E , TE(A) is an admissible abstract dispute tree."
    }, {
      "heading" : "Proof",
      "text" : "According to Lemma 7, for each A+i in attTree + E (A), Ai ∈ E , and for each A − j in attTree+E (A), Aj /∈ E . By definition of stable extension, for all arguments B in ABAP either B ∈ E or B /∈ E . Thus, Ai 6= Aj for all i, j, and therefore by Definition 6 no argument labels both a proponent and an opponent node in TE(A), satisfying the condition for admissibility. By Lemma 10, TE(A) is an abstract dispute tree.\nSince a positive Attack Tree constructed with respect to a stable extension corresponds to an admissible abstract dispute tree, the set of all arguments labelled '+' in the Attack Tree forms an admissible extension, in particular one that is a subset of this stable extension.\nTheorem 4 Let P be a logic program, E a stable extension of ABAP , and attTree+E (A) a positive Attack Tree of some argument A in ABAP . Then the set Args of all arguments labelled '+' in attTree+E (A) is an admissible extension of ABAP and Args ⊆ E ."
    }, {
      "heading" : "Proof",
      "text" : "Let Args denote the set of all arguments labelled '+' in attTree+E (A). Then Args is the set of arguments held by proponent nodes in the translated abstract dispute tree TE(A) of attTree+E (A). By Lemma 11, TE(A) is an admissible abstract dispute tree. By Theorem 3.2(i) in (Dung et al. 2007), Args is an admissible extension, and by Lemma 7, Args ⊆ E .\nThis result characterizes Attack Trees as a way of justifying an argument by means of an admissible fragment of the stable extension. In other words, the Attack Tree does not use whole stable extension to explain that an argument is in the stable extension, but only provides an admissible subset sufficient to show that it defends the argument in question. Furthermore, we can express this result in logic programming terms: Given a literal and an answer set, an Attack Tree of an argument for this literal constructed with respect to the corresponding stable extension justifies the argument using an admissible fragment of the answer set.\nTheorem 5 Let P be a logic program, S an answer set of P, k ∈ SNAF , and E the corresponding stable extension of S in ABAP . Let A ∈ E be a corresponding argument of k, attTree+E (A) an Attack Tree of A, and Asms = {α | α ∈ AP,A + 1 : (AP,FP ) ` k1 in attTree + E (A)}. Then\n1. P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); 2. {k1 | A+1 : (AP,FP ) ` k1 in attTree + E (A)} ⊆ SNAF ."
    }, {
      "heading" : "Proof",
      "text" : "1. By Theorem 4 and Theorem 2.2(ii) in (Dung et al. 2007), Asms is an admissible\nset of assumptions. Then by Theorem 4.5 in (Bondarenko et al. 1997), P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).2\n2. By Theorem 4 and Theorem 1.\nThis result enables us to construct a justification of a literal in an answer set from an Attack Tree (in Section 5) using an admissible fragment of the answer set. The following example illustrates the characteristics of positive Attack Trees and how they can be used for justifying an argument for a literal in an answer set.\nExample 9 Consider the logic program P1 and its answer set S1 = {e, d, a} with the corresponding stable extension E1 = {A2, A3, A4, A6, A8, A9, A13, A14} (see Examples 2 and 3). To justify that not c ∈ S1NAF , we can construct an Attack Tree of an argument for not c, i.e. of A3, with respect to E1. The resulting positive Attack Tree attTree+E1(A3) is depicted on the left of Figure 9. Translating this Attack Tree into an abstract dispute tree as described in Definition 6, yields the translated abstract dispute tree TE1(A3) illustrated on the right of Figure 9. This abstract dispute tree is admissible as stated in Lemma 11. The set arguments labelled '+' in attTree+E1(A3) is {A3, A14} ⊆ E1 which is an admissible extension of ABAP1 and the set of conclusions of these arguments is {not c, e} ⊆ S1NAF as stated by Theorems 4 and 5. The Attack Tree attTree+E1(A3) explains that the literal not c is in the answer set S1 because it is supported and defended by an admissible subset of S1, namely by {not c, e}. In terms of literal the Attack Tree expresses that not c is “attacked” by the literal c, which is “counter-attacked” by e, thereby defending not c.\nSimilarly to positive Attack Trees, we can characterize the explanations given by negative Attack Trees using the correspondence between the subtree of a negative Attack Tree and an abstract dispute tree: Negative Attack Trees justify that an argument is not in a stable extension because it is attacked by an admissible fragment of this stable extension. We first prove that when deleting the opponent root node of the translated abstract dispute tree of a negative Attack Tree constructed with respect to a stable extension, the resulting abstract dispute tree is admissible.\n2 Theorem 4.5 refers to (Dung 1995a) where admissible scenarios are defined for logic programs without classical negation. This result can be easily extended to the definition of admissible scenarios of logic programs with both classical negation and NAF as we are only concerned with consistent logic programs.\nLemma 12 Let P be a logic program, E a stable extension of ABAP , and A some argument not contained in E . For every negative Attack Tree attTree−E (A) of A with respect to E , the subtree of TE(A) with root node Ai, where A+i is the only child of the root A− in attTree−E (A), is an admissible abstract dispute tree."
    }, {
      "heading" : "Proof",
      "text" : "By Lemma 9, the subtree of Υ′ of attTree−E (A) with root node Ai is a positive Attack Tree of Ai. By Lemma 11, Υ ′ is an admissible abstract dispute tree. Trivially, the subtree of TE(A) with root node Ai coincides with the translated abstract dispute tree of Υ′.\nKnowing that the argument held by the root of a negative Attack Tree constructed with respect to a stable extension is attacked by an admissible abstract dispute tree, we show that this Attack Tree justifies the root by showing that it is attacked by an admissible extension of ABAP , and in particular by an admissible extension which is a subset of the stable extension.\nTheorem 6 Let P be a logic program, E a stable extension of ABAP , and attTree−E (A) a negative Attack Tree of some argument A in ABAP . Then the set Args of all arguments labelled '+' in attTree−E (A) is an admissible extension of ABAP and Args ⊆ E ."
    }, {
      "heading" : "Proof",
      "text" : "Let Args denote the set of all arguments labelled '+' in attTree−E (A). Then Args is the set of arguments held by proponent nodes in the translated abstract dispute tree TE(A) of attTree−E (A). By Lemma 12, the subtree of TE(A) with root node Ai, where A + i is the only child of the root A − in attTree−E (A), is an admissible abstract dispute tree. By Theorem 3.2(i) in (Dung et al. 2007), Args is an admissible extension. By Lemma 7, Args ⊆ E .\nIt follows, that a negative Attack Tree justifies an argument for a literal which is not in the answer set in question in terms of an admissible fragment of the answer set “attacking” the literal.\nTheorem 7 Let P be a logic program, S an answer set of P, k /∈ SNAF , and E the corresponding stable extension of S in ABAP . Let A be some argument for k, attTree − E (A) an Attack Tree of A, and Asms = {α | α ∈ AP,A+1 : (AP,FP ) ` k1 in attTree − E (A)}. Then\n1. P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); 2. {k1 | A+1 : (AP,FP ) ` k1 in attTree − E (A)} ⊆ SNAF ."
    }, {
      "heading" : "Proof",
      "text" : "1. By Theorem 6 and Theorem 2.2(ii) in (Dung et al. 2007), Asms is an admissible\nset of assumptions. Then by Theorem 4.5 in (Bondarenko et al. 1997), P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).2\n2. By Theorem 6 and Theorem 1.\nThis result provides the basis for the construction of a justification of a literal not contained in an answer set from an Attack Tree which provides a meaningful explanation in terms of an admissible subset of the answer set.\nExample 10 Consider the logic program P2 and its only answer set S = {b} with the corresponding stable extension E = {A1, A3, A5} (see Example 8). To justify why a /∈ S we can construct an Attack Tree of an argument with conclusion a, i.e. of A4, with respect to E . The resulting negative Attack Tree attTree−E (A4) is depicted in Figure 6 and the translated abstract dispute tree TE(A4) in Figure 7. When deleting the root opponent node A4 of TE(A4), the resulting abstract dispute tree is admissible as observed in Lemma 12. Furthermore, the set of arguments labelled '+' in attTree−E (A4) is {A5}, which is a subset of the corresponding stable extension E and an admissible extension of ABAP2 (by Theorem 6). Moreover, the set of conclusions of arguments in this admissible extension is {b} ⊆ S, which is an admissible scenario of P as stated in Theorem 7. Therefore, the negative Attack Tree attTree−E (A4) explains that the argument A4 is not in the corresponding stable extension because it is attacked by an admissible fragment of this stable extension, namely by {A5}. Even though A4 together with A6 counter-attacks this attack, A5 defends itself against this counter-attack. This explanation can also be interpreted in terms of literals: a is not in the answer set S because its derivation is “attacked” by a derivation of b, which is an admissible fragment of S. Even though the derivation of a and the derivation of c both “counter-attack” the derivation of b, attempting to defend a, the derivation of b can attack both counter-attacks and thus the derivation of b defends itself. Consequently, the attack of the derivation of b on the derivation of a “succeeds”, which is the reason that a is not part of the answer set.\nIn conclusion, Attack Trees provide a justification of an argument with respect to a stable extension in terms of an admissible subset of this stable extension. Due\nto the correspondence between answer sets and stable extensions, Attack Trees can also be used to justify a literal with respect to an answer set by constructing an Attack Tree of an argument for this literal with respect to the corresponding stable extension. The resulting Attack Tree justifies the argument for the literal in question using an admissible fragment of the answer set. If the literal in question is contained in the given answer set, the admissible fragment supports and defends a derivation of this literal. If the literal in question is not contained in the given answer set, the admissible fragment of the answer set “attacks” a derivation of this literal, in fact by Theorem 3 the admissible fragment attacks all derivations of this literal.\nThe only shortcoming of justifying literals with respect to an answer set in terms of Attack Trees is that they use argumentation-theoretic concepts for the explanation. Thus, we now define a second type of justification which provides explanations in terms of literals and relations between them, rather than in terms of arguments as used in Attack Trees. The new type of justification is constructed from Attack Trees by flattening the structure of arguments occurring in an Attack Tree as well as of the attack relation between these arguments. In addition to better fitting logic programming concepts, another advantage of the new justifications is that they are finite even if constructed from infinite Attack Trees. We first introduce a basic version of this new justification to illustrate the idea of flattening Attack Trees. Then, we define a more elaborate version using the same flattening approach but simultaneously labelling literals and their relations, yielding a more informative explanation."
    }, {
      "heading" : "5 Basic ABA-Based Answer Set Justifications",
      "text" : "In this section we define the basic concepts for constructing justifications of a literal k in terms of literals and their relations, based on Attack Trees of arguments with conclusion k. The idea is to extract the assumptions- and fact-premises of each argument in the Attack Tree to express a support-relation between each of the premise-literals and the literal forming the conclusion of an argument. Furthermore, the attacks between arguments in an Attack Tree are translated into attack-relations between the literals forming the conclusions of these arguments. We first introduce some terminology to refer to the structure of an Attack Tree.\nNotation 6 Let Υ be an Attack Tree and let N be a node in Υ. arg(N) denotes the argument held by node N . If arg(N) is A : (AP,FP ) ` k, then name(N) = A, conc(N) = k, AP (N) = AP , FP (N) = FP , and label(N) is either '+' or '−', depending on the label of A in Υ. The set of all child nodes of N in Υ is denoted children(N)."
    }, {
      "heading" : "5.1 Basic Justifications",
      "text" : "We now define how to express the structure of an Attack Tree as a set of relations between literals.\nDefinition 7 (Basic Justification) Let P be a logic program and let X be a set of arguments in ABAP . Let A be an argument in ABAP and Υ = attTreeX(A) an Attack Tree of A with respect to X. The Basic Justification of A with respect to Υ, denoted justBΥ(A), is obtained as follows:\njustBΥ(A) = ⋃\nN in Υ\n{supp rel(k, conc(N)) | k ∈ AP (N) ∪ FP (N)\\{conc(N)}} ∪ {att rel(conc(M), k) |M ∈ children(N), conc(M) = k}\nExample 11 Consider the logic program P1 from Example 2 and the Attack Trees discussed in Example 6. Since Υ1 = attTree\n+ E1(A14) comprises only the node A + 14, the Basic\nJustification of A14 with respect to Υ1 is justBΥ1(A14) = ∅. Now consider the negative Attack Tree Υ2 = attTree − E2(A10) of A10 with respect to E2 depicted on the left of Figure 2. The Basic Justification of A10 with respect to Υ2 is:\njustBΥ2(A10) = {supp rel(not c, a), supp rel(not d, a), supp rel(not e, a)} ∪ {att rel(e, not e)}\n= {supp rel(not c, a), supp rel(not d, a), supp rel(not e, a), att rel(e, not e)}\nThe following Basic Justification is obtained from the negative Attack Tree Υ3 =\nattTree−E2(A9) of A9 with respect to the stable extension E2 (see Figure 3):\njustBΥ3(A9) = {supp rel(not ¬a, a), att rel(¬a, not ¬a), supp rel(not c,¬a), supp rel(not d,¬a), att rel(c, not c), att rel(d, not d), supp rel(not e, c), att rel(e, not e), supp rel(not ¬a, d)}\nNote that even though Υ3 is an infinite Attack Tree, the Basic Justification of A9 with respect to Υ3 is finite. In particular, when A11 reoccurs in the Attack Tree as an attacker of A13, no new att rel or supp rel pairs are added to the Basic Justification: even though A11 attacks A9 with conclusion a at its first occurrence and A13 with conclusion d at its second occurrence, no new att rel pair is added since the attacked assumption is in both cases not ¬a.\nIn Basic Justifications attacks between arguments are translated into “attacks” between literals, and supports of arguments into “supports” of literals. In other words, a Basic Justification is the flattened version of an Attack Tree. Even though it provides an explanation in terms of literals rather than arguments, it is not sufficient to justify a literal with respect to an answer set for two reasons, as explained below.\nFirstly, a Basic Justification does not contain the literal being justified, which is for example a problem when justifying a fact. When justifying a fact k, we construct an Attack Tree of the fact-argument for k, which consists of only the root node A+ : (∅, {k}) ` k, leading to an empty Basic Justification. An empty set is not meaningful, so it would be useful if the literal in question was contained in the\njustification. Furthermore, a problem arises when trying to justify a literal for which no argument exists in the translated ABA framework, i.e. a literal which cannot be derived in any way from the logic program. For such a literal, which is trivially not part of any answer set, it is not possible to construct an Attack Tree as no argument for this literal exists in the translated ABA framework. Since a Basic Justification is constructed from an Attack Tree, there is no Basic Justification for such a literal. This is unsatisfying, so we would like to have some kind of justification, rather than failing.\nThe second problem or shortcoming of a Basic Justification is that it only provides one reason why a literal is not in an answer set as it is constructed from a single negative Attack Tree, which provides one explanation how the root argument is attacked by the set of arguments in question. However, it is more meaningful to capture all different explanations of how a literal “failed” to be in the answer set in question. Thus, we want the justification of a literal not in the answer set to consist of all possible Basic Justifications of this literal.\nIn order to overcome these two deficiencies, we introduce BABAS Justifications, which add the literal being justified to the Basic Justification set and provide a collection of all Basic Justifications for a literal which is not contained in an answer set."
    }, {
      "heading" : "5.2 BABAS Justifications",
      "text" : "We now define the Basic ABA-Based Answer Set (BABAS) Justification of a literal with respect to an answer set, which is based on the Basic Justifications of an argument with respect to an Attack Tree. If a literal k is contained in an answer set, its BABAS Justification is constructed from one Basic Justification of one of the corresponding arguments of k. This is inspired by the result in Theorem 3 that a literal k is part of an answer set if and only if there exists some argument with conclusion k in the corresponding stable extension. Conversely, if k is not contained in an answer set, its BABAS Justification is constructed from all Basic Justifications of all arguments with conclusion k, expressing all reasons why k is not part of this answer set. Again, the choice to consider all arguments with conclusion k is based on Theorem 3, stating that a literal k is not part of an answer set if and only if all arguments with conclusion k are not contained in the corresponding stable extension.\nDefinition 8 (Basic ABA-Based Answer Set Justification) Let P be a logic program and S an answer set of P. Let E be the corresponding stable extension of S in ABAP .\n1. Let k ∈ SNAF, A ∈ E a corresponding argument of k, and Υ = attTree+E (A) some positive Attack Tree of A with respect to E . A Positive BABAS Justification of k with respect to S is:\njustB+S (k) = {k} ∪ justBΥ(A). 2. Let k /∈ SNAF, A1, . . . , An (n ≥ 0) all arguments with conclusion k in ABAP , and\nΥ11, . . . ,Υ1m1 , . . . ,Υn1, . . . ,Υnmn (m1, . . . ,mn ≥ 0) all negative Attack Trees of A1, . . . , An with respect to E .\n(a) If n = 0, then the Negative BABAS Justification of k with respect to S is:\njustB−S (k) = ∅ (b) If n > 0, then the Negative BABAS Justification of k with respect to S is:\njustB−S (k) = {{k} ∪ justBΥ11(A1), . . . , {k} ∪ justBΥ1m1 (A1), . . . , {k} ∪ justBΥnmn (An)}.\nNote that there can be more than one Positive BABAS Justification of a literal contained in an answer set, but only one Negative BABAS Justification of a literal not contained in an answer set. Note also that the Positive BABAS Justification is a set of supp rel and att rel pairs (plus the literal which is justified), whereas the Negative BABAS Justification is a set of sets containing these pairs (where each set also contains the literal which is justified).\nA BABAS Justification can be represented as a graph, where all literals occurring in a supp rel or att rel pair form nodes, and the supp rel and att rel relations are edges between these nodes. For Negative BABAS Justifications, a separate graph for each set in the justification is given. In contrast, Positive BABAS Justifications are illustrated as a single graph.\nExample 12\nBased on the Basic Justifications in Example 11, we illustrate the construction of BABAS Justifications. Consider e ∈ S1, where the corresponding stable extension of S1 is E1 (see Example 3). There is only one corresponding argument of e in E1, namely A14 : (∅, {e}) ` e, which has a unique positive Attack Tree with respect to E1, Υ1 = attTree+E1(A14). As shown in Example 11, the Basic Justification of A14 with respect to Υ1 is justBΥ1(A14) = ∅. Therefore, the unique Positive BABAS Justification of e with respect to S1 is justB\n+ S1 (e) = {e}. This justification expresses that e is in the answer set S1 because it is supported only by itself, in other words, it is a fact.\nWe now consider the BABAS Justification of a /∈ S2, where the corresponding stable extension of S2 in ABAP1 is E2. Since a /∈ S2, we examine all arguments with conclusion a in ABAP1 , that is A9 and A10. Both A9 and A10 have a unique negative Attack Tree with respect to E2, Υ3 = attTree−E2(A9) (see Figure 3) and Υ2 = attTree−E2(A10) (see left of Figure 2). From the Basic Justifications justBΥ3(A9) and justBΥ2(A10) explained in Example 11, the BABAS Justification of a with respect to S2 is obtained as follows:\njustB−S2(a) = {{a, supp rel(not ¬a, a), att rel(¬a, not ¬a), supp rel(not c,¬a), supp rel(not d,¬a), att rel(c, not c), att rel(d, not d), supp rel(not e, c), att rel(e, not e), supp rel(not ¬a, d)}, {a, supp rel(not c, a), supp rel(not d, a), supp rel(not e, a), att rel(e, not e)}}\nFigure 10 depicts the graphical representation of the Negative BABAS Justification\njustB−S2(a), where the left of the figure represents the first set in justB − S2 (a), and the right of the figure the second set.\nSo far, we only illustrated BABAS Justifications of literals k for which at least one argument with conclusion k exists in the translated ABA framework. The next example demonstrates the BABAS Justification of a literal which does not have such an argument. In general, the BABAS Justification of such literals is the empty set.\nExample 13 Consider the literal ¬c /∈ S1 in the logic program P1 (see Examples 2 and 3). There is no rule with head ¬c in P1, and consequently ABAP1 does not comprise an argument with conclusion ¬c. Thus, there is no Attack Tree of an argument for ¬c and no Basic Justification of an argument for ¬c. As a consequent the Negative BABAS Justification of ¬c with respect to S1 is justB−S1(¬c) = ∅ (by Definition 8.2(b))."
    }, {
      "heading" : "5.3 Shortcomings of BABAS Justifications",
      "text" : "A BABAS Justification is a flat structure which loses some information as compared to the underlying Attack Trees. Attack Trees label arguments with respect to a stable extension, expressing whether or not an argument is part of the stable extension. However, a BABAS Justification does not provide any information about whether or not a literal is contained in the answer set in question. Whether or not a literal is part of an answer set is important to know, since attacks and supports by literals contained in the answer set “succeed”, whereas attacks and supports by\nliterals not in the answer set do not “succeed”. This additional information is not captured by BABAS Justifications, even though it is provided by the underlying Attack Trees.\nExample 14 Consider the Negative BABAS Justification justB−S2(a) from Example 12, depicted as a graph in Figure 10. justB−S2(a) does not express whether or not the “attacking” literal ¬a is part of S2, neither in set notation nor in the graphical representation. In contrast, the underlying Attack Tree attTree−E2(A9) in Figure 3 specifies that the argument A11 for ¬a is in the corresponding stable extension E2 by labelling A11 as '+'. It would be useful to capture this kind of information not only in the Attack Tree but also in the justification in terms of literals, so justB−S2(a) should express that a is not in S2 because the support by not e does not “succeed” as not e /∈ S2NAF because the attack by e on not e “succeeds” as e ∈ S2.\nThe next example illustrates another shortcoming of BABAS Justifications, which arises if the underlying Attack Tree contains different arguments which have the same conclusion and occur as child nodes of the same parent node.\nExample 15 Consider the two logic programs P3 (left) and P4 (right):\np← not a p← not b q ← not p a← b←\np← not a, not b q ← not p a← b←\nBoth logic programs have only one answer set, SP3 = SP4 = {a, b, q}. The translated ABA frameworks ABAP3 (left) and ABAP4 (right) have the following arguments: A1 : ({not a}, ∅) ` not a A2 : ({not ¬a}, ∅) ` not ¬a A3 : ({not b}, ∅) ` not b A4 : ({not ¬b}, ∅) ` not ¬b A5 : ({not p}, ∅) ` not p A6 : ({not ¬p}, ∅) ` not ¬p A7 : ({not q}, ∅) ` not q A8 : ({not ¬q}, ∅) ` not ¬q A9 : ({not p}, ∅) ` q A10 : (∅, {a}) ` a A11 : (∅, {b}) ` b A12 : ({not a}, ∅) ` p A13 : ({not b}, ∅) ` p A1 : ({not a}, ∅) ` not a A2 : ({not ¬a}, ∅) ` not ¬a A3 : ({not b}, ∅) ` not b A4 : ({not ¬b}, ∅) ` not ¬b A5 : ({not p}, ∅) ` not p A6 : ({not ¬p}, ∅) ` not ¬p A7 : ({not q}, ∅) ` not q A8 : ({not ¬q}, ∅) ` not ¬q A9 : ({not p}, ∅) ` q A10 : (∅, {a}) ` a A11 : (∅, {b}) ` b A14 : ({not a, not b}, ∅) ` p\nABAP3 and ABAP4 share arguments A1 to A11. In addition, ABAP3 has arguments A12 and A13, whereas ABAP4 has only one additional argument A14. Both ABA frameworks have a unique stable extension, EP3 = EP4 = {A2, A4, A5, A6, A8, A9,\nA10, A11}. EP3 is the corresponding stable extension of SP3 and EP4 the corresponding stable extension of SP4 . We now examine the BABAS Justifications of q with respect to SP3 and SP4 by constructing Attack Trees of the corresponding arguments of q with respect to EP3 and EP4 , respectively. In both ABAP3 and ABAP4 , the only corresponding argument of q is A9 which has a unique positive Attack Tree with respect to EP3 (attTree+EP3 (A9)), depicted in Figure 11, and two positive Attack Trees with respect to EP4 (attTree+EP4 (A9)1 and attTree + EP4 (A9)2), depicted in Figure 12. The unique Positive BABAS Justification of q with respect to SP3 constructed from attTree+EP3 (A9) and the two possible Positive BABAS Justifications of q with respect to SP4 constructed from attTree + EP4 (A9)1 and attTree + EP4 (A9)2, respectively, are:\njustB+SP3 (q) = {q, supp rel(not p, q), att rel(p, not p), supp rel(not a, p),\natt rel(a, not a), supp rel(not b, p), att rel(b, not b)}\njustB+SP4 (q) = {q, supp rel(not p, q), att rel(p, not p), supp rel(not a, p),\nsupp rel(not b, p), att rel(a, not a)}\njustB+SP4 (q) = {q, supp rel(not p, q), att rel(p, not p), supp rel(not a, p),\nsupp rel(not b, p), att rel(b, not b)}\nThe graphical representations of these BABAS Justifications are depicted in Figure 13. All of them give the impression that p is supported by not a and not b together, which is only correct in the case of P4. In P3, there are two different ways of concluding p, one supported by the NAF literal not a, and the other one by not b, which is not clear from justB+SP3 (q).\nExample 15 suggests that if a node in an Attack Tree has various children holding arguments with the same conclusion, these child nodes should be distinguished in a justification. We address this problem in the next section by defining a more elaborate version of ABAS Justifications."
    }, {
      "heading" : "6 Labelled ABA-Based Answer Set Justifications",
      "text" : "We now introduce Labelled ABA-Based Answer Set (LABAS) Justifications, which address the shortcomings of BABAS Justifications by labelling the relations and literals in the justification as either '+' or '−', depending on the labels of arguments in the underlying Attack Trees. In addition, literals can have an asm or fact tag, indicating that they are used as assumptions or facts, respectively. Non-assumption and non-fact literals are tagged with their argument’s name in order to distinguish between different arguments with the same conclusion occurring in an Attack Tree. We refer to the structure of nodes in an Attack Tree as introduced in Notation 6. Similarly to BABAS Justifications, LABAS Justifications are defined in terms of Labelled Justifications, which are a flattened version of Attack Trees. In contrast to Basic Justifications, Labelled Justifications label the literals and relations extracted from an Attack Tree, and extract only relevant support relations."
    }, {
      "heading" : "6.1 Labelled Justifications",
      "text" : "A Labelled Justification assigns the label '+' to all facts and NAF literals occurring as premises of an argument labelled '+' in the Attack Tree, as well as to this\nargument’s conclusion. A Labelled Justification assigns the label '−' to the conclusion of an argument labelled '−' in the Attack Tree as well as to some NAF literals supporting this argument, namely to those NAF literals whose contrary is the conclusion of a child node of this argument in the Attack Tree. Attack and support relations are labelled '+' if the first literal in the relation is labelled '+', and labelled '−' if the first literal in the relation is labelled '−'. Since the labels in a Labelled Justification depend on the labels of arguments in an Attack Tree, the definition is split into two cases: one for nodes holding arguments labelled '+' in the Attack Tree, and the other for nodes holding arguments labelled '−' in the Attack Tree.\nDefinition 9 (Labelled Justification)\nLet P be a logic program and let X be a set of arguments in ABAP . Let A be an argument in ABAP and Υ = attTreeX(A) an Attack Tree of A with respect to X. The Labelled Justification of A with respect to Υ, denoted justLΥ(A), is obtained as follows: justLΥ(A) =⋃ N in Υ, label(N)=+\n{supp rel+(k+asm, conc(N)+AN ) | k ∈ AP (N)\\conc(N), name(N) = AN} ∪ {supp rel+(k+fact, conc(N) + AN ) | k ∈ FP (N)\\conc(N), name(N) = AN} ∪ {att rel−(conc(M)−AM , k + asm) |M ∈ children(N), conc(M) = k,\nname(M) = AM} ∪⋃ N in Υ, label(N)=−\n{supp rel−(k−asm, conc(N)−AN ) | k ∈ AP (N)\\conc(N), children(N) = {M}, conc(M) = k, name(N) = AN} ∪ {att rel+(conc(M)+fact, k − asm) | children(N) = {M}, conc(M) = k, FP (M) = {conc(M)}, AP (M) = ∅} ∪ {att rel+(conc(M)+AM , k − asm) | children(N) = {M}, conc(M) = k,AP (M) 6= ∅\nor FP (M) 6= {conc(M)}, name(M) = AM}\nTo illustrate Labelled Justifications and the differences with Basic Justification, we construct the Labelled Justifications for some of the arguments we used for Basic Justifications in Example 11.\nExample 16\nThe Labelled Justification of A14 : (∅, {e}) ` e with respect to the positive Attack Tree Υ1 = attTree\n+ E1(A14) is the empty set, exactly as for the Basic Justification:\njustLΥ1(A14) = justBΥ1(A14) = ∅. The reason is that A14 is labelled '+' in Υ1, but none of the three conditions for nodes with label '+' in Definition 9 is satisfied.\nNow consider the Labelled Justification of A10 with respect to the negative Attack\nTree Υ2 = attTree − E2(A10):\njustLΥ2(A10) = {supp rel−(not e−asm, a−A10)} ∪ {att rel +(e+fact, not e − asm)}\n= {supp rel−(not e−asm, a−A10), att rel +(e+fact, not e − asm)}\nThis Labelled Justification contains fewer literal-pairs than the Basic Justification of A10 with respect to Υ2 (see Example 11), which additionally comprises supports of not c and not d for a. Since these two supports are not necessary to explain why a is not in S2 (the explanation is that the supporting literal not e is attacked by the fact e), they are omitted in the Labelled Justification.\nThe procedure of extracting attack and support relations from an Attack Tree in the construction of a Labelled Justification is similar to the method of Basic Justifications, where the relations are extracted step by step for every node in the Attack Tree. The main difference of Labelled Justifications is that nodes holding arguments labelled '+' and nodes holding arguments labelled '−' in an Attack Tree are handled separately in order to obtain the correct labelling of literals and relations in the justification. Furthermore, the extraction of the support relation is divided into two cases: one for assumption-premises, and one for fact-premises. Similarly, there are two cases for the extraction of the attack relation: the attacker can be a fact or another (non-fact and non-assumption) literal. Note that not all supporting literals of an argument with label '−' are extracted for a Labelled Justification, but only “attacked” ones."
    }, {
      "heading" : "6.2 LABAS Justifications",
      "text" : "In this section, we define the Labelled ABA-Based Answer Set (LABAS) Justification of a literal with respect to an answer set, which is based on the Labelled Justifications of an argument for this literal with respect to an Attack Tree. We also prove that a LABAS Justification provides an explanation for a literal using an admissible fragment of the answer set in question.\nJust as for BABAS Justifications, if a literal k is contained in an answer set, its LABAS Justification is constructed from one Labelled Justification of one of the corresponding arguments of k. Conversely, if k is not in an answer set, its LABAS Justification is constructed from all Labelled Justifications of all arguments with conclusion k. The only difference in the construction is that the literal being justified is labelled before it is added to the justification.\nDefinition 10 (Labelled ABA-Based Answer Set Justification) Let P be a logic program and S an answer set of P. Let E be the corresponding stable extension of S in ABAP = 〈LP ,RP ,AP , ¯〉.\n1. Let k ∈ SNAF, A ∈ E a corresponding argument of k, and Υ = attTree+E (A) some positive Attack Tree of A with respect to E . Let lab(k) = k+asm if k ∈ AP , lab(k) = k+fact if k ← ∈ RP , and lab(k) = k + A else. A Positive LABAS Justification\nof k with respect to S is: justL+S (k) = {lab(k)} ∪ justLΥ(A).\n2. Let k /∈ SNAF, A1, . . . , An (n ≥ 0) all arguments with conclusion k in ABAP , and Υ11, . . . ,Υ1m1 , . . . ,Υn1, . . . ,Υnmn (m1, . . . ,mn ≥ 0) all negative Attack Trees of A1, . . . , An with respect to E .\n(a) If n = 0, then the Negative LABAS Justification of k with respect to S is:\njustL−S (k) = ∅ (b) If n > 0, then let lab(k1) = . . . = lab(kn) = k − asm if k ∈ AP and lab(k1) =\nk−A1 , . . . , lab(kn) = k − An else. The Negative LABAS Justification of k with respect to S is: justL−S (k) = {{lab(k1)} ∪ justLΥ11(A1), . . . , {lab(kn)} ∪ justLΥnmn (An)}.\nExample 17 We illustrate the advantages of LABAS Justifications as compared to BABAS Justifications by justifying the same literal as in Example 15, i.e. q ∈ SP3 and q ∈ SP4 of the logic programs P3 and P4. The LABAS Justifications are constructed from the same Attack Trees as the BABAS Justifications (see Figures 11 and 12). The unique Positive LABAS Justification of q with respect to SP3 and the two possible Positive LABAS Justifications of q with respect to SP4 are:\njustL+SP3 (q) = {q+A9 , supp rel +(not p+asm, q + A9 ), att rel−(p−A12 , not p + asm),\natt rel−(p−A13 , not p + asm), supp rel −(not a−asm, p − A12 ), att rel+(a+fact, not a − asm), supp rel −(not b−asm, p − A13 ), att rel+(b+fact, not b − asm)}\njustL+SP4 (q) = {q+A9 , supp rel +(not p+asm, q + A9 ), att rel−(p−A14 , not p + asm),\nsupp rel−(not a−asm, p − A14 ), att rel+(a+fact, not a − asm)}\njustL+SP4 (q) = {q+A9 , supp rel +(not p+asm, q + A9 ), att rel−(p−A14 , not p + asm),\nsupp rel−(not b−asm, p − A14 ), att rel+(b+fact, not b − asm)}\nThe graphical representations of these LABAS Justifications are depicted in Figure 14. The differences between BABAS and LABAS Justifications can be easily spotted when comparing the BABAS Justification graphs in Figure 13 with the LABAS Justification graphs in Figure 14, both of which explain why q is part of SP3 and SP4 . In contrast to the BABAS Justifications, the LABAS Justifications express that in P3 there are two different ways of deriving p, one supported by not a (yielding A12) and the other one by not b (yielding A13), but in P4 there is only one way of deriving p, supported by both not a and not b (yielding A14). The reason that neither of the two LABAS Justifications of q with respect to SP4 comprises both of these supporting NAF literals is that LABAS Justifications only contain the supporting NAF literals which are “attacked”; in the first case not a is attacked by a, in the second case not b is attacked by b.\nAs illustrated by Example 17, LABAS Justifications solve the shortcomings of BABAS Justifications: They indicate whether or not support and attack relations\n“succeed”, as well as which literals are facts or assumptions. Furthermore, tagging literals with argument-names makes it possible to distinguish between different ways of deriving the same literal. In addition, a LABAS Justification is sometimes shorter than the respective BABAS Justification, only comprising relevant supporting literals of a literal not in the answer set in question.\nExample 18 Recall Dr. Smith who has to determine whether to follow his own decision to treat the shortsightedness of his patient Peter with laser surgery or whether to act according to the suggestion of his decision support system and treat Peter with intraocular lenses (see Example 1). In Example 7, we illustrated how Attack Trees can be used to explain the suggestion of the decision support system as well as why Dr. Smith’s treatment decision is wrong. Here, we demonstrate the LABAS Justifications explaining this.\nFigure 15 displays the Negative LABAS Justification of the literal laserSurgery which is not contained in the answer set Sdoctor of the logic program Pdoctor (see Example 1). This LABAS Justification is constructed from all Labelled Justifications of all arguments with conclusion laserSurgery, i.e. from all Attack Trees for arguments with conclusion laserSurgery. There is only one argument with conclusion laserSurgery, but there are two different negative Attack Trees for this argument (see Example 7). The negative Attack Tree underlying the left part of the LABAS Justification in Figure 15 was illustrated in Figure 4. The Negative LABAS Justification of laserSurgery expresses that Peter should not have laser surgery for two reasons: first (left part), because laser surgery should only be used if the patient is not tight on money, but Peter is tight on money as he is a student and as there is no evidence that his parents are rich; second (right part), because\nlaser surgery should only be used if it has not been decided that the patient should have corrective lenses, but there is evidence that Peter should have corrective lenses since he is shortsighted and since there is evidence against having laser surgery (and assuming that the patient does not have laser surgery is a prerequisite for having corrective lenses).\nA Positive LABAS Justification explaining why Peter should get intraocular lenses is displayed in Figure 16. This LABAS Justification expresses that all supporting assumptions needed to draw the conclusion that Peter should have intraocular lenses are satisfied, namely Peter is shortsighted, he should not have laser surgery, he should not have glasses, and he should not have contact lenses. The explanation also illustrates why these other treatments are not applicable.\nUsing the LABAS Justifications, Dr. Smith can now understand why the decision support system suggested intraocular lenses as the best treatment for Peter and why Peter should not have laser surgery. Dr. Smith can therefore easily revise his original decision that Peter should have laser surgery, realizing that he forgot to consider that Peter is a student and that consequently Peter has not enough money to pay for laser surgery.\nIn the following we show that LABAS Justifications explain a literal with respect to an answer set in terms of an admissible fragment of this answer set. We first introduce some terminology to refer to the literals in a LABAS Justification.\nNotation 7 Let justL+S (k) be a Positive LABAS Justification. We say that a literal k1 occurs in justL+S (k) if and only if k1 = k or k1 is one of the literals in a support- or attack-pair in justL+S (k). We say that k1 occurs positively in justL + S (k) if and only if it occurs as k+1asm , k + 1fact , or k+1A (where A is some argument with conclusion k1).\nWe use the same terminology for Negative LABAS Justifications.\nThe following theorem characterizes the explanations given by Positive LABAS\nJustifications.\nTheorem 8 Let P be a logic program and let justL+S (k1) be a Positive LABAS Justification of some literal k1 with respect to an answer set S of P. Let NAF+ = {k | k+asm occurs in justL+S (k1)} be the set of all NAF literals occurring positively in justL+S (k1). Then\n• P ∪ NAF+ is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); • NAF+ ⊆ SNAF ."
    }, {
      "heading" : "Proof",
      "text" : "By Definitions 9 and 10 and Notation 7, NAF+ is the union of all assumptions supporting arguments labelled '+' in the Attack Tree attTree+E (A) used for the construction of justL+S (k1), where E is the corresponding stable extension of S and A ∈ E is a corresponding argument of k1. So NAF+ = Asms as defined in Theorem 7.\nThis result expresses that LABAS Justifications explain that a literal is contained in an answer set because this literal is supported and defended by the answer set. However, LABAS Justifications do not simply provide the whole answer set as an explanation, but instead use an admissible fragment of it. A similar result can be formulated for Negative LABAS Justifications:\nTheorem 9\nLet P be a logic program and let justL−S (k1) be a Negative LABAS Justification of a literal k1 with respect to an answer set S of P. LetNAF+11, . . . , NAF + 1m1 , . . . , NAF+n1, . . . , NAF+nmn be the sets of all NAF literals occurring positively in the subsets of justL−S (k1), i.e. NAF + ij = {k | k+asm occurs in lab(k1i) ∪ justLΥij (Ai)} where 0 ≤ i ≤ n and 0 ≤ j ≤ mn. Then for each NAF+ij\n• P ∪ NAF+ij is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); • NAF+ij ⊆ SNAF ."
    }, {
      "heading" : "Proof",
      "text" : "Analogous to the proof of Theorem 8.\nThis means that the LABAS Justification of a literal which is not part of an answer set explains all different ways in which this literal is “attacked” by an admissible fragment of the answer set.\nIn summary, LABAS Justifications use the same information for an explanation as Attack Trees, namely an admissible fragment of an answer set, but expressing these information in terms of literals and the support and “attack” relations between them rather than in terms of arguments and attacks. Thus, LABAS Justifications are more suitable explanations if logic programming concepts are desired.\nIn the following, we will use the term ABAS Justification as shorthand for both\nBABAS and LABAS Justifications."
    }, {
      "heading" : "7 Discussion and Related Work",
      "text" : "So far, the problem of justifying answer sets has not received much attention, even though the need for justifications has been expressed (Brain and De Vos 2008). According to (Pontelli et al. 2009), a justification should “provide only the information that are relevant to the item being explained”, making it easier understandable. We incorporate this in ABAS Justifications by not using the whole derivation of a literal, but only the underlying facts and NAF literals necessary to derive the literal in question.\nThe two approaches for justifying why a literal is or is not part of an answer set which are most related to ABAS Justifications are Argumentation-Based Answer Set Justifications and off-line justifications. Argumentation-Based Answer Set Justifications (Schulz et al. 2013) are a “predecessor” of ABAS Justifications using the ASPIC+ argumentation framework (Prakken 2010) instead of ABA. Off-line justifications (Pontelli et al. 2009) explain why a literal is or is not part of an answer set by making use of the well-founded model semantics for logic programs. In the following Sections 7.1 and 7.2, we look at these two related approaches in more detail and compare them to ABAS Justifications. In Section 7.3, we look at a number of other, less closely related explanation approaches."
    }, {
      "heading" : "7.1 Off-line Justifications",
      "text" : "The off-line justification for a classical literal l is a graph of classical literals with root node l. The child nodes of l are the relevant literals which l directly depends on. In other words, the justified literal l has the relevant body literals of an applicable clause in the logic program as its child nodes, and the justifications of these body literals as subgraphs.\nExample 19 Consider the following logic program Pabc (taken from (Pontelli et al. 2009)), which has two answer sets S1 = {b, e, f} and S2 = {a, e, f}:\na← f, not b b← e, not a f ← e d← c, e c← d, f e←\nThe off-line justification for b ∈ S1 is depicted on the top right of Figure 17. It is constructed using the second clause in Pabc, yielding a positive dependency of b on e, and a negative dependency of b on a. This expresses that b is in the answer set because it depends on e being part of the answer set and on a not being part of it. Whether or not a classical literal l occurring in the off-line justification is part of the answer set in question is indicated by the labels '+' (if l is in the answer set) or '−' (if l is not in the answer set). The dependency conditions of b on e and a are satisfied, since e is labelled '+' and a is labelled '−'. The off-line justification graph also expresses that e is known to be true since it is a fact (indicated by > in the graph) and that a is assumed to be false (indicated by assume in the graph). It is important to note that NAF literals are represented indirectly in an off-line justification by means of their corresponding classical literal. For example in the off-line justification of b (top right of Figure 17), the classical literal a is used to represent the dependency of b on the NAF literal not a.\nOff-line justifications treat the relationship between literals in a proof-oriented way, that is as top-down dependencies, whereas ABAS Justifications (and Attack Trees) provide explanations in a bottom-up manner in terms of assumptions and underlying knowledge supporting the conclusion. We argue that our bottom-up approach might be clearer for non-experts, as human decision making seems to involve starting from what is known along with some kind of assumptions, and then drawing conclusions from that. Instead of saying that b is dependent on e in Pabc as done by an off-line justification, an ABAS Justification expresses that e supports b, as shown on the top left of Figure 17. Especially with respect to NAF literals, we believe that a bottom-up support relation is more intuitive than a topdown dependency relation: instead of saying that b negatively depends on a not being in the answer set as done by an off-line justification, the ABAS Justification states that not a supports b (compare the two graphs at the top of Figure 17).\nThe well-founded model semantics is used in the construction of off-line justifications to determine literals which are “assumed” to be false with respect to an answer set, as opposed to literals which are always false. These assumed literals are not further justified, i.e. they are leaf nodes in an off-line justification graph. In contrast, ABAS Justifications further justify these “assumed” literals. They are usually true NAF literals which are part of a dependency cycle. An example is the literal a in the logic program Pabc, which is assumed to be false in the off-line justification of b with respect to S1 (bottom right of Figure 17). In contrast, the ABAS Justification further explains that a is not in the answer set because the support by not b does not “succeed” since the attack by b on not b “succeeds” (bottom left of Figure 17).\nAn off-line justification graph includes all intermediate literals in the derivation of the literal in question. However, following (Brain and De Vos 2008) we argue that for a justification it is sufficient to include the most basic relevant literals, without considering intermediate steps. Especially in the case of large logic programs, where\nderivations include many steps, an off-line justification will be a large graph with many positive and negative dependency relations, which is hard to understand for humans. In contrast, an ABAS Justification only contains the basic underlying literals, i.e. facts and NAF literals necessary to derive the literal in question, making the justification clearer. However, if the intermediate steps were required, they could be easily extracted from the arguments in the Attack Trees underlying an ABAS Justification.\nIn contrast to off-line justifications, where in addition to answer sets the wellfounded model has to be computed, for the construction of ABAS Justifications the computation of answer sets is sufficient. Even though the definitions of ABAS Justifications refer to the corresponding stable extensions of the translated ABA framework, it is not necessary to compute these stable extensions. Whether or not the arguments needed for an ABAS Justification are contained in the respective corresponding stable extension can be directly deduced from the answer set due to the correspondence between answer sets and stable extensions as stated in Theorems 1, 2, and 3."
    }, {
      "heading" : "7.2 Argumentation-Based Answer Set Justification",
      "text" : "Argumentation-Based Answer Set Justification (Schulz et al. 2013) is the first work that applies argumentation theory to answer set programming, and in particular for the justification of answer sets. There, the ASPIC+ argumentation framework (Prakken 2010) is used instead of ABA.\nSimilarly to ABAS Justifications, in Argumentation-Based Answer Set Justifications literals are justified with respect to an answer set by means of ASPIC+ arguments with respect to the stable extension corresponding to the answer set in question. For the translation of a logic program into an ASPIC+ framework only a fraction of ASPIC+ features are needed; defeasible rules, issues, and preference orders are redundant. This is to say that the ASPIC+ framework is too complex for the purpose of a justification and a more lightweight framework like ABA is more suitable.\nThe method for constructing a justification in Argumentation-Based Answer Set Justification is slightly different from the ABAS Justification approach. Instead of extracting support- and attack-pairs from Attack Trees, Argumentation-Based Answer Set Justifications are defined recursively: for an assumption-argument its attackers are investigated, whereas for non-assumption- and non-fact-arguments supports by assumption- and fact-arguments are examined. The recursion terminates when fact-arguments or non-attacked assumption-arguments are encountered.\nArgumentation-Based Answer Set Justifications have the same deficiencies as BABAS Justifications; it is not clear which literals are facts or assumptions, and whether or not support and attack relations “succeed”. The implementation of Argumentation-Based Answer Set Justification colours the relations and literals similarly to the labels '+' and '−' on relations and literals in LABAS Justifications, where green corresponds to '+' and red to '−'. However, facts and assumptions cannot be distinguished from other literals, as depicted in Figure 18.\nIn summary, ABAS Justifications are an improvement of Argumentation-Based Answer Set Justifications, both with respect to the elegance of the justification definition and the appropriateness of the argumentation framework used. LABAS Justifications also solve the deficiencies of Argumentation-Based Answer Set Justifications by providing more information about the literals in the explanation as well as about their relationship. Furthermore, Argumentation-Based Answer Set Justifications were introduced without any characterization. In contrast, here we prove that ABAS Justifications provide an explanation in terms of an admissible fragment of the answer set in question, and show their relationship with abstract dispute trees in ABA."
    }, {
      "heading" : "7.3 Other related explanation approaches",
      "text" : "In addition to the two explanations approaches for answer sets discussed in the previous sections, (Erdem and Oztok 2013) introduce a formalism for explaining biomedical queries expressed in ASP. Similar to ABAS Justifications, they construct trees for the explanation, but in contrast to our justifications these trees carry rules in the nodes rather than literals. Another difference is that their explanation trees\ncomprise every step in the derivation of a literal (similar to the approach of (Pontelli et al. 2009) explained in Section 7.1) rather than abstracting away from intermediate derivation steps between the literal in question and the underlying facts and NAF literals.\n(Brain and Vos 2005) try to answer a similar question as the one we address with ABAS Justifications, i.e. why a set of literals is or is not a subset of an answer. Their explanations are presented in text form, but they point out that it might be possible to use a tree representation instead. Just like (Erdem and Oztok 2013), all intermediate steps in a derivation are considered in the explanation, thus differing from ABAS Justifications.\nRelated to the explanation of ASP is the visualization of the structure of logic programs in general. ASPIDE (Febbraro et al. 2011) is an Integrated Development Environment for ASP which, among other features, displays the dependency graph of a logic program, i.e. it visualizes the positive (negative) dependencies between the rule heads and the atoms (NAF literals, respectively). It is thus similar to the previously mentioned approaches in that it illustrates every step in a derivation.\nThe problem of constructing explanations has been addressed for logic programs without NAF in (Arora et al. 1993) and (Ferrand et al. 2012). In the early work by Arora et al. explanations of atoms in a logic program are constructed as simple derivations of these atoms. Thus, this approach is closer to (Erdem and Oztok 2013) and (Brain and Vos 2005) than to ABAS Justifications as it provides all intermediate derivation steps. Similar to this, (Ferrand et al. 2012) show how to use proof trees as explanations for least fixpoint operators, such as the semantics of constraint logic programs, where proof trees are derivations.\nThe comparison with these existing approaches demonstrates the novelty of ABAS Justifications as they only provide the facts and NAF literals necessary for the derivation of a literal in question rather than the whole derivation with all its intermediate steps.\nExplanations have also received attention in other areas in the field of knowledge representation and reasoning, and it has been emphasized that any expert system should provide explanations for its solutions (see (Lacave and Diez 2004) for an overview of explanations in heuristic expert systems). Furthermore, it has been pointed out that even though argumentation and other knowledge-based systems have been studied mostly separately in the past, argumentation could serve as a useful tool for the explanation of other knowledge-based systems (Moulin et al. 2002). In fact, (Bench-Capon et al. 1991) provide an early account of explanations for logic programs in terms of arguments, where Toulmin’s argument scheme is applied. However, a meta-program encoding the argument scheme has to be created by hand for any logic program that needs explanation, making it infeasible for automatic computation. Related to argumentation as an explanation method, (Garćıa et al. 2013) introduce explanations in argumentative terms for argumentation-based reasoning methods, such as Defeasible Logic Programming (Garćıa and Simari 2004), explaining why an argument with a certain conclusion is or is not deemed to be “winning”. Similar to ABAS Justifications and Attack Trees, the motivation behind their approach is to explain the solution of applying\nargumentation semantics to an argumentation framework using the context of the semantic analysis, i.e. the attacking and defending relations between arguments. Explanations are given in terms of argument trees similar to Attack Trees, where arguments held by child nodes in the tree attack the argument held by the parent node. In contrast to Attack Trees, however, every node in the tree is extended with all its attackers and the tree is labelled with respect to the grounded extension, a different argumentation semantics, instead of stable extensions. Another difference to our justifications is that Garćıa et al. explain why a literal l is not a winning conclusion in terms of an explanation why the contrary literal ¬l is a winning conclusion. In contrast, ABAS Justifications explain why a literal l is not a winning conclusion by pointing out why it cannot possibly be winning."
    }, {
      "heading" : "8 Conclusion and Future Work",
      "text" : "We present two approaches for justifying why a literal is or is not contained in an answer set of a consistent logic program by translating the logic program into an Assumption-Based Argumentation (ABA) framework and using the structure of arguments and attacks in this translated ABA framework for the explanation. Attack Trees, our first justification approach, provide an explanation for a literal in argumentation-theoretic terms, i.e. in terms of arguments and attacks between them. ABA-Based Answer Set Justifications, our second justification approach, flatten the structure of Attack Trees, yielding a set of literal-pairs in a support relation and literal-pairs in an attack relation. This justification approach is more aligned with logic programming concepts as it uses literals rather than arguments as an explanation. Both justification approaches are based on the correspondence between answer sets of a logic program and stable extensions of the translated ABA framework, namely for every answer set of a consistent logic program there is a corresponding stable extension of the translated ABA framework and vice versa.\nNodes in an Attack Tree hold arguments, where the argument held by a parent node is attacked by the arguments held by the parent’s child nodes. The root node of an Attack Tree always holds an argument for the literal being justified. Importantly, an Attack Tree is constructed with respect to the stable extension corresponding to the answer set in question. If an argument in the Attack Tree is contained in the corresponding stable extension, all arguments attacking it occur as its child nodes in the Attack Tree. The intuition behind this is that an argument is contained in the stable extension if all attacking arguments are not contained in this stable extension. Thus, all attacking arguments are added as children in the Attack Tree and further justified as to why they are not contained in the stable extension. In contrast, if an argument in the Attack Tree is not contained in the corresponding stable extension, only one attacking argument is picked as a child node, in particular one which is part of the corresponding stable extension. The intuition behind picking only one attacking argument is inspired by the idea of proof by counterexample, i.e. that one counterexample is enough to disprove a claim. Thus, it is enough to show one way in which an argument can be disproven by an attacking argument, even if there are other ways. Importantly, the attacking argument has to be in the stable extension\nto prove that the attacked argument is not in the stable extension. The resulting structure of an Attack Tree is an alternation of arguments in the corresponding stable extension attacked by arguments not in the corresponding stable extension and so on.\nAn ABA-Based Answer Set (ABAS) Justification is obtained from Attack Trees by extracting a support-relation between literals from the structure of arguments occurring in the Attack Trees, and an attack-relation between literals from the attacks between these arguments. Thus, ABAS Justifications are the flattened version of Attack Trees, expressing the same explanation, but in terms of literals and their relations rather than in terms of arguments and attacks between them. We present two versions of ABAS Justifications: The simpler BABAS Justifications are used to introduce the flattening method; the more elaborate LABAS Justifications apply the same flattening method but additionally use labels on literals and their relations in order to overcome some deficiencies of BABAS Justifications. An ABAS Justification can also be interpreted as a graph of literal-nodes connected via support and attack edges.\nImportantly, both Attack Trees and ABAS Justifications explain why a literal is or is not in an answer set in terms of an admissible fragment of this answer set. The justification that a literal is in an answer set is that a derivation of this literal is supported by an admissible fragment of this answer set. In contrast, the justification that a literal is not contained in an answer set is that all derivations of this literal are “attacked” by an admissible fragment of this answer set. In comparison to the few existing explanation methods for logic programming, ABAS Justifications take an argumentative premise-conclusion approach, i.e. a literal is explained in terms of the facts and NAF literals necessary for its derivations, rather than in terms of the whole derivation.\nFuture work includes to apply ABAS Justifications to real-world examples, with focus on medical decision making and legal reasoning. Applying ABAS Justifications to these domains will not only yield a plausible medical or legal decision but also provide an easily accessible explanation for elements of the solution. A potential legal rule base for the application of ABAS Justifications is the encoding of the Japanese Civil Code as used in (Satoh et al. 2010). With respect to applicability of ABAS Justifications, we are planning to develop a user-friendly implementation of ABAS Justification and conduct a survey both among experts in ASP and among non-experts using ASP as a decision-making tool. Furthermore, we are working on an extension of ABAS Justifications to explain inconsistencies in logic programs and to help debugging these logic programs."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We would like to thank the anonymous reviewers and David Pearce for their constructive feedback, as well as Abdallah Arioua for pointing out some related work."
    } ],
    "references" : [ {
      "title" : "Explaining program execution in deductive systems",
      "author" : [ "T. Arora", "R. Ramakrishnan", "W. Roth", "P. Seshadri", "D. Srivastava" ],
      "venue" : "Deductive and Object-Oriented Databases, S. Ceri, K. Tanaka, and S. Tsur, Eds. Lecture Notes in Computer Science, vol. 760. Springer Berlin Heidelberg, 101–119.",
      "citeRegEx" : "Arora et al\\.,? 1993",
      "shortCiteRegEx" : "Arora et al\\.",
      "year" : 1993
    }, {
      "title" : "A knowledge based approach for representing and reasoning about signaling networks",
      "author" : [ "C. Baral", "K. Chancellor", "N. Tran", "N. Tran", "A.M. Joy", "M.E. Berens" ],
      "venue" : "ISMB/ECCB (Supplement of Bioinformatics). 15–22.",
      "citeRegEx" : "Baral et al\\.,? 2004",
      "shortCiteRegEx" : "Baral et al\\.",
      "year" : 2004
    }, {
      "title" : "Argument-based explanation of logic programs",
      "author" : [ "T. Bench-Capon", "D. Lowes", "A. McEnery" ],
      "venue" : "Knowledge-Based Systems 4, 3, 177 – 183.",
      "citeRegEx" : "Bench.Capon et al\\.,? 1991",
      "shortCiteRegEx" : "Bench.Capon et al\\.",
      "year" : 1991
    }, {
      "title" : "Automatic music composition using answer set programming",
      "author" : [ "G. Boenn", "M. Brain", "M.D. Vos", "J. Fitch" ],
      "venue" : "Theory and Practice of Logic Programming 11, 2-3, 397–427.",
      "citeRegEx" : "Boenn et al\\.,? 2011",
      "shortCiteRegEx" : "Boenn et al\\.",
      "year" : 2011
    }, {
      "title" : "An abstract, argumentation-theoretic approach to default reasoning",
      "author" : [ "A. Bondarenko", "P. Dung", "R. Kowalski", "F. Toni" ],
      "venue" : "Artificial Intelligence 93, 1-2, 63 – 101.",
      "citeRegEx" : "Bondarenko et al\\.,? 1997",
      "shortCiteRegEx" : "Bondarenko et al\\.",
      "year" : 1997
    }, {
      "title" : "Answer set programming - a domain in need of explanation: A position paper",
      "author" : [ "M. Brain", "M. De Vos" ],
      "venue" : "Explanation-aware Computing, Papers from the 2008 ECAI Workshop. ExaCt. 37–48.",
      "citeRegEx" : "Brain and Vos,? 2008",
      "shortCiteRegEx" : "Brain and Vos",
      "year" : 2008
    }, {
      "title" : "Debugging logic programs under the answer set semantics",
      "author" : [ "M. Brain", "M.D. Vos" ],
      "venue" : "Proceedings of the 3rd International Workshop on Answer Set Programming (ASP’05). CEUR Workshop Proceedings (2005).",
      "citeRegEx" : "Brain and Vos,? 2005",
      "shortCiteRegEx" : "Brain and Vos",
      "year" : 2005
    }, {
      "title" : "Computing ideal sceptical argumentation",
      "author" : [ "P. Dung", "P. Mancarella", "F. Toni" ],
      "venue" : "Artificial Intelligence 171, 10-15, 642 – 674.",
      "citeRegEx" : "Dung et al\\.,? 2007",
      "shortCiteRegEx" : "Dung et al\\.",
      "year" : 2007
    }, {
      "title" : "An argumentation-theoretic foundation for logic programming",
      "author" : [ "P.M. Dung" ],
      "venue" : "The Journal of Logic Programming 22, 2, 151 – 177.",
      "citeRegEx" : "Dung,? 1995a",
      "shortCiteRegEx" : "Dung",
      "year" : 1995
    }, {
      "title" : "On the acceptability of arguments and its fundamental role in nonmonotonic reasoning, logic programming and n-person games",
      "author" : [ "P.M. Dung" ],
      "venue" : "Artificial Intelligence 77, 2, 321–357.",
      "citeRegEx" : "Dung,? 1995b",
      "shortCiteRegEx" : "Dung",
      "year" : 1995
    }, {
      "title" : "Dialectic proof procedures for assumption-based, admissible argumentation",
      "author" : [ "P.M. Dung", "R.A. Kowalski", "F. Toni" ],
      "venue" : "Artificial Intelligence 170, 2, 114–159.",
      "citeRegEx" : "Dung et al\\.,? 2006",
      "shortCiteRegEx" : "Dung et al\\.",
      "year" : 2006
    }, {
      "title" : "Assumption-based argumentation",
      "author" : [ "P.M. Dung", "R.A. Kowalski", "F. Toni" ],
      "venue" : "Argumentation in Artificial Intelligence, G. Simari and I. Rahwan, Eds. Springer US, 199–218.",
      "citeRegEx" : "Dung et al\\.,? 2009",
      "shortCiteRegEx" : "Dung et al\\.",
      "year" : 2009
    }, {
      "title" : "Well-founded reasoning with classical negation",
      "author" : [ "P.M. Dung", "P. Ruamviboonsuk" ],
      "venue" : "LPNMR. 120–132.",
      "citeRegEx" : "Dung and Ruamviboonsuk,? 1991",
      "shortCiteRegEx" : "Dung and Ruamviboonsuk",
      "year" : 1991
    }, {
      "title" : "A deductive system for non-monotonic reasoning",
      "author" : [ "T. Eiter", "N. Leone", "C. Mateis", "G. Pfeifer", "F. Scarcello" ],
      "venue" : "Proceedings of the 4th International Conference on Logic Programming and Nonmonotonic Reasoning. LPNMR’97. 364–375.",
      "citeRegEx" : "Eiter et al\\.,? 1997",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 1997
    }, {
      "title" : "Generating explanations for biomedical queries",
      "author" : [ "E. Erdem", "U. Oztok" ],
      "venue" : "Theory and Practice of Logic Programming FirstView, 1–44.",
      "citeRegEx" : "Erdem and Oztok,? 2013",
      "shortCiteRegEx" : "Erdem and Oztok",
      "year" : 2013
    }, {
      "title" : "Abduction compared with negation by failure",
      "author" : [ "K. Eshghi", "R.A. Kowalski" ],
      "venue" : "ICLP. 234–254.",
      "citeRegEx" : "Eshghi and Kowalski,? 1989",
      "shortCiteRegEx" : "Eshghi and Kowalski",
      "year" : 1989
    }, {
      "title" : "Aspide: Integrated development environment for answer set programming",
      "author" : [ "O. Febbraro", "K. Reale", "F. Ricca" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning, J. P. Delgrande and W. Faber, Eds. Lecture Notes in Computer Science, vol. 6645. Springer Berlin Heidelberg, 317–330.",
      "citeRegEx" : "Febbraro et al\\.,? 2011",
      "shortCiteRegEx" : "Febbraro et al\\.",
      "year" : 2011
    }, {
      "title" : "Explanations and proof trees",
      "author" : [ "G. Ferrand", "W. Lesaint", "A. Tessier" ],
      "venue" : "Computing and Informatics 25, 2-3.",
      "citeRegEx" : "Ferrand et al\\.,? 2012",
      "shortCiteRegEx" : "Ferrand et al\\.",
      "year" : 2012
    }, {
      "title" : "Formalizing dialectical explanation support for argument-based reasoning in knowledge-based systems",
      "author" : [ "A.J. Garćıa", "C.I.C. nevar", "N.D. Rotstein", "G.R. Simari" ],
      "venue" : "Expert Systems with Applications 40,",
      "citeRegEx" : "Garćıa et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Garćıa et al\\.",
      "year" : 2013
    }, {
      "title" : "Defeasible logic programming: An argumentative approach",
      "author" : [ "A.J. Garćıa", "G.R. Simari" ],
      "venue" : "Theory and Practice of Logic Programming 4, 2, 95–138.",
      "citeRegEx" : "Garćıa and Simari,? 2004",
      "shortCiteRegEx" : "Garćıa and Simari",
      "year" : 2004
    }, {
      "title" : "Potassco: The Potsdam answer set solving collection",
      "author" : [ "M. Gebser", "R. Kaminski", "B. Kaufmann", "M. Ostrowski", "T. Schaub", "M. Schneider" ],
      "venue" : "AI Communications 24, 2, 105–124.",
      "citeRegEx" : "Gebser et al\\.,? 2011",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2011
    }, {
      "title" : "Answer Sets",
      "author" : [ "M. Gelfond" ],
      "venue" : "Elsevier, Chapter 7.",
      "citeRegEx" : "Gelfond,? 2008",
      "shortCiteRegEx" : "Gelfond",
      "year" : 2008
    }, {
      "title" : "Classical negation in logic programs and disjunctive databases",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "New Generation Computing 9, 365–385.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1991",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1991
    }, {
      "title" : "Argumentation semantics for defeasible logic",
      "author" : [ "G. Governatori", "M.J. Maher", "G. Antoniou", "D. Billington" ],
      "venue" : "Journal of Logic and Computation 14, 675–702.",
      "citeRegEx" : "Governatori et al\\.,? 2004",
      "shortCiteRegEx" : "Governatori et al\\.",
      "year" : 2004
    }, {
      "title" : "A review of explanation methods for heuristic expert systems",
      "author" : [ "C. Lacave", "F.J. Diez" ],
      "venue" : "Knowledge Engineering Review 19, 2 (June), 133–146.",
      "citeRegEx" : "Lacave and Diez,? 2004",
      "shortCiteRegEx" : "Lacave and Diez",
      "year" : 2004
    }, {
      "title" : "Explanation and argumentation capabilities: Towards the creation of more persuasive agents",
      "author" : [ "B. Moulin", "H. Irandoust", "M. Blanger", "G. Desbordes" ],
      "venue" : "Artificial Intelligence Review 17, 3, 169–222.",
      "citeRegEx" : "Moulin et al\\.,? 2002",
      "shortCiteRegEx" : "Moulin et al\\.",
      "year" : 2002
    }, {
      "title" : "Smodels: A system for answer set programming",
      "author" : [ "I. Niemelä", "P. Simons", "T. Syrjänen" ],
      "venue" : "CoRR cs.AI/0003033.",
      "citeRegEx" : "Niemelä et al\\.,? 2000",
      "shortCiteRegEx" : "Niemelä et al\\.",
      "year" : 2000
    }, {
      "title" : "Justifications for logic programs under answer set semantics",
      "author" : [ "E. Pontelli", "T.C. Son", "O. Elkhatib" ],
      "venue" : "Theory and Practice of Logic Programming 9, 1, 1–56.",
      "citeRegEx" : "Pontelli et al\\.,? 2009",
      "shortCiteRegEx" : "Pontelli et al\\.",
      "year" : 2009
    }, {
      "title" : "An abstract framework for argumentation with structured arguments",
      "author" : [ "H. Prakken" ],
      "venue" : "Argument and Computation 1, 2, 93–124.",
      "citeRegEx" : "Prakken,? 2010",
      "shortCiteRegEx" : "Prakken",
      "year" : 2010
    }, {
      "title" : "Proleg: An implementation of the presupposed ultimate fact theory of japanese civil code by prolog technology",
      "author" : [ "K. Satoh", "K. Asai", "T. Kogawa", "M. Kubota", "M. Nakamura", "Y. Nishigai", "K. Shirakawa", "C. Takano" ],
      "venue" : "JSAI-isAI Workshops. 153–164.",
      "citeRegEx" : "Satoh et al\\.,? 2010",
      "shortCiteRegEx" : "Satoh et al\\.",
      "year" : 2010
    }, {
      "title" : "Argumentation-based answer set justification",
      "author" : [ "C. Schulz", "M. Sergot", "F. Toni" ],
      "venue" : "Working notes of the 11th International Symposium on Logical Formalizations of Commonsense Reasoning. Commonsense’13.",
      "citeRegEx" : "Schulz et al\\.,? 2013",
      "shortCiteRegEx" : "Schulz et al\\.",
      "year" : 2013
    }, {
      "title" : "Logic programming for multiagent planning with negotiation",
      "author" : [ "T.C. Son", "E. Pontelli", "C. Sakama" ],
      "venue" : "Proceedings of the 25th International Conference on Logic Programming. Springer-Verlag, 99–114.",
      "citeRegEx" : "Son et al\\.,? 2009",
      "shortCiteRegEx" : "Son et al\\.",
      "year" : 2009
    }, {
      "title" : "On the relationship of defeasible argumentation and answer set programming",
      "author" : [ "M. Thimm", "G. Kern-Isberner" ],
      "venue" : "Computational Models of Argument: Proceedings of COMMA 2008, Toulouse, France, May 28-30, 2008. 393–404.",
      "citeRegEx" : "Thimm and Kern.Isberner,? 2008",
      "shortCiteRegEx" : "Thimm and Kern.Isberner",
      "year" : 2008
    }, {
      "title" : "Argumentation and answer set programming",
      "author" : [ "F. Toni", "M. Sergot" ],
      "venue" : "Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning, M. Balduccini and T. Son, Eds. Lecture Notes in Computer Science, vol. 6565. Springer Berlin Heidelberg, 164–180.",
      "citeRegEx" : "Toni and Sergot,? 2011",
      "shortCiteRegEx" : "Toni and Sergot",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 21,
      "context" : "Answer Set Programming (ASP) is one of the most widely used non-monotonic reasoning paradigms, allowing to efficiently compute solutions to problems involving defaults and exceptions (Gelfond 2008).",
      "startOffset" : 183,
      "endOffset" : 197
    }, {
      "referenceID" : 22,
      "context" : "The solutions to the problem are then given by the declarative answer set semantics (Gelfond and Lifschitz 1991) for the logic program.",
      "startOffset" : 84,
      "endOffset" : 112
    }, {
      "referenceID" : 1,
      "context" : "ASP is applied in a variety of different areas, ranging from bioinformatics (Baral et al. 2004) over music composition (Boenn et al.",
      "startOffset" : 76,
      "endOffset" : 95
    }, {
      "referenceID" : 3,
      "context" : "2004) over music composition (Boenn et al. 2011) to multi-agent systems (Son et al.",
      "startOffset" : 29,
      "endOffset" : 48
    }, {
      "referenceID" : 31,
      "context" : "2011) to multi-agent systems (Son et al. 2009).",
      "startOffset" : 29,
      "endOffset" : 46
    }, {
      "referenceID" : 20,
      "context" : "Answer set solvers like clingo (Gebser et al. 2011), smodels (Niemelä et al.",
      "startOffset" : 31,
      "endOffset" : 51
    }, {
      "referenceID" : 26,
      "context" : "2011), smodels (Niemelä et al. 2000), and DLV (Eiter et al.",
      "startOffset" : 15,
      "endOffset" : 36
    }, {
      "referenceID" : 13,
      "context" : "2000), and DLV (Eiter et al. 1997) provide efficient tools for the computation of answer sets.",
      "startOffset" : 15,
      "endOffset" : 34
    }, {
      "referenceID" : 4,
      "context" : "Here, we use Assumption-Based Argumentation (ABA) (Bondarenko et al. 1997; Dung et al. 2009), a structured argumentation framework which constructs arguments from rules and assumptions, and attacks from the notion of contrary of assumptions.",
      "startOffset" : 50,
      "endOffset" : 92
    }, {
      "referenceID" : 11,
      "context" : "Here, we use Assumption-Based Argumentation (ABA) (Bondarenko et al. 1997; Dung et al. 2009), a structured argumentation framework which constructs arguments from rules and assumptions, and attacks from the notion of contrary of assumptions.",
      "startOffset" : 50,
      "endOffset" : 92
    }, {
      "referenceID" : 4,
      "context" : "ABA is particularly suitable for our purpose as it was inspired by logic programming, default logic and other non-monotonic reasoning approaches (Bondarenko et al. 1997) which are closely related to ASP.",
      "startOffset" : 145,
      "endOffset" : 169
    }, {
      "referenceID" : 4,
      "context" : "One of the semantics for ABA frameworks is the stable extension semantics (Bondarenko et al. 1997; Dung 1995b), which has its roots in the stable model semantics for logic programs.",
      "startOffset" : 74,
      "endOffset" : 110
    }, {
      "referenceID" : 9,
      "context" : "One of the semantics for ABA frameworks is the stable extension semantics (Bondarenko et al. 1997; Dung 1995b), which has its roots in the stable model semantics for logic programs.",
      "startOffset" : 74,
      "endOffset" : 110
    }, {
      "referenceID" : 24,
      "context" : "On the one hand, they contribute to the field of answer set justification research, which has been identified as an important but not yet sufficiently studied research area (Lacave and Diez 2004; Brain and De Vos 2008).",
      "startOffset" : 173,
      "endOffset" : 218
    }, {
      "referenceID" : 0,
      "context" : "The reason to use ABA for explanations instead of constructing justifications from the logic program straight away in terms of simple derivations or proof trees (Arora et al. 1993; Ferrand et al. 2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al.",
      "startOffset" : 161,
      "endOffset" : 201
    }, {
      "referenceID" : 17,
      "context" : "The reason to use ABA for explanations instead of constructing justifications from the logic program straight away in terms of simple derivations or proof trees (Arora et al. 1993; Ferrand et al. 2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al.",
      "startOffset" : 161,
      "endOffset" : 201
    }, {
      "referenceID" : 2,
      "context" : "2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al. 1991; Moulin et al. 2002).",
      "startOffset" : 213,
      "endOffset" : 258
    }, {
      "referenceID" : 25,
      "context" : "2012) is that ABA is conceptually close to logic programs but provides additional concepts and constructs which have been identified as useful for explanation purposes, such as the notion of arguments and attacks (Bench-Capon et al. 1991; Moulin et al. 2002).",
      "startOffset" : 213,
      "endOffset" : 258
    }, {
      "referenceID" : 33,
      "context" : "Even though ASP has been applied to argumentation theory in the sense that an argumentation framework can be equivalently expressed in ASP (Toni and Sergot 2011; Thimm and Kern-Isberner 2008), the converse has not been discussed in the literature.",
      "startOffset" : 139,
      "endOffset" : 191
    }, {
      "referenceID" : 32,
      "context" : "Even though ASP has been applied to argumentation theory in the sense that an argumentation framework can be equivalently expressed in ASP (Toni and Sergot 2011; Thimm and Kern-Isberner 2008), the converse has not been discussed in the literature.",
      "startOffset" : 139,
      "endOffset" : 191
    }, {
      "referenceID" : 2,
      "context" : "• early work on manually constructing arguments and attacks from a logic program according to Toulmin’s argument scheme, which then serves as an explanation of the logic program (Bench-Capon et al. 1991); and • Argumentation-Based Answer Set Justification (Schulz et al.",
      "startOffset" : 178,
      "endOffset" : 203
    }, {
      "referenceID" : 30,
      "context" : "1991); and • Argumentation-Based Answer Set Justification (Schulz et al. 2013) which can be considered as a predecessor of ABAS Justifications.",
      "startOffset" : 58,
      "endOffset" : 78
    }, {
      "referenceID" : 28,
      "context" : "Similarly to ABAS Justifications, Argumentation-Based Answer Set Justifications are constructed from arguments and attacks between them, but using the ASPIC+ argumentation framework (Prakken 2010) instead of ABA.",
      "startOffset" : 182,
      "endOffset" : 196
    }, {
      "referenceID" : 10,
      "context" : "In Section 4 we introduce Attack Trees drawn from a translated ABA framework as a first justification method, show their relationship with abstract dispute trees for ABA (Dung et al. 2006), and characterize the explanation they provide as an admissible fragment of the answer set in question.",
      "startOffset" : 170,
      "endOffset" : 188
    }, {
      "referenceID" : 22,
      "context" : "In the following, we recall the concept of answer sets as introduced in (Gelfond and Lifschitz 1991).",
      "startOffset" : 72,
      "endOffset" : 100
    }, {
      "referenceID" : 15,
      "context" : "When used on such P ∪ ∆S , `MP treats NAF literals purely syntactically as in (Eshghi and Kowalski 1989) and treats facts l← as l← true where P ∪ ∆S `MP true for any logic program P and any set of NAF literals ∆S .",
      "startOffset" : 78,
      "endOffset" : 104
    }, {
      "referenceID" : 9,
      "context" : "Abstract Argumentation (Dung 1995b) assumes that a set of abstract entities (the arguments) are given along with an attack relation between them.",
      "startOffset" : 23,
      "endOffset" : 35
    }, {
      "referenceID" : 28,
      "context" : "In contrast, structured argumentation frameworks such as (Prakken 2010; Garćıa and Simari 2004; Governatori et al. 2004) provide mechanisms for the construction of arguments from given knowledge, mostly in the form of rules, and for identifying the attack relation between arguments based on the structure of arguments.",
      "startOffset" : 57,
      "endOffset" : 120
    }, {
      "referenceID" : 19,
      "context" : "In contrast, structured argumentation frameworks such as (Prakken 2010; Garćıa and Simari 2004; Governatori et al. 2004) provide mechanisms for the construction of arguments from given knowledge, mostly in the form of rules, and for identifying the attack relation between arguments based on the structure of arguments.",
      "startOffset" : 57,
      "endOffset" : 120
    }, {
      "referenceID" : 23,
      "context" : "In contrast, structured argumentation frameworks such as (Prakken 2010; Garćıa and Simari 2004; Governatori et al. 2004) provide mechanisms for the construction of arguments from given knowledge, mostly in the form of rules, and for identifying the attack relation between arguments based on the structure of arguments.",
      "startOffset" : 57,
      "endOffset" : 120
    }, {
      "referenceID" : 4,
      "context" : "framework of (Bondarenko et al. 1997; Dung et al. 2009) called Assumption-Based Argumentation (ABA).",
      "startOffset" : 13,
      "endOffset" : 55
    }, {
      "referenceID" : 11,
      "context" : "framework of (Bondarenko et al. 1997; Dung et al. 2009) called Assumption-Based Argumentation (ABA).",
      "startOffset" : 13,
      "endOffset" : 55
    }, {
      "referenceID" : 11,
      "context" : "An ABA framework (Dung et al. 2009) is a tuple 〈L,R,A,  ̄〉, where",
      "startOffset" : 17,
      "endOffset" : 35
    }, {
      "referenceID" : 11,
      "context" : "Definition 2 generates the notion of argument in (Dung et al. 2009): If (AP,FP ) ` α is an argument according to Definition 2, then AP ` α is an argument in (Dung et al.",
      "startOffset" : 49,
      "endOffset" : 67
    }, {
      "referenceID" : 11,
      "context" : "2009): If (AP,FP ) ` α is an argument according to Definition 2, then AP ` α is an argument in (Dung et al. 2009).",
      "startOffset" : 95,
      "endOffset" : 113
    }, {
      "referenceID" : 11,
      "context" : "Conversely, if AP ` α is an argument in (Dung et al. 2009), then there exists some FP ⊆ {β | β ← ∈ R} such that (AP,FP ) ` α is an argument according to Definition 2.",
      "startOffset" : 40,
      "endOffset" : 58
    }, {
      "referenceID" : 11,
      "context" : "The attack relation between arguments defined here is a slight variation of the notion in (Dung et al. 2009), as it considers arguments with both assumption- and fact-premises.",
      "startOffset" : 90,
      "endOffset" : 108
    }, {
      "referenceID" : 11,
      "context" : "Since arguments as introduced here and in (Dung et al. 2009) correspond, the attack relation in Definition 3 directly correspond to attacks in (Dung et al.",
      "startOffset" : 42,
      "endOffset" : 60
    }, {
      "referenceID" : 11,
      "context" : "2009) correspond, the attack relation in Definition 3 directly correspond to attacks in (Dung et al. 2009): If an argument (AP1, FP1) ` α1 attacks an argument (AP2, FP2) ` α2 according to Definition 3, then AP1 ` α1 attacks AP2 ` α2 as defined in (Dung et al.",
      "startOffset" : 88,
      "endOffset" : 106
    }, {
      "referenceID" : 11,
      "context" : "2009): If an argument (AP1, FP1) ` α1 attacks an argument (AP2, FP2) ` α2 according to Definition 3, then AP1 ` α1 attacks AP2 ` α2 as defined in (Dung et al. 2009).",
      "startOffset" : 146,
      "endOffset" : 164
    }, {
      "referenceID" : 11,
      "context" : "Conversely, if AP1 ` α1 attacks AP2 ` α2 as defined in (Dung et al. 2009), then there exist FP1, FP2 ⊆ {β | β ← ∈ R} such that (AP1, FP1) ` α1 attacks (AP2, FP2) ` α2 according to Definition 3.",
      "startOffset" : 55,
      "endOffset" : 73
    }, {
      "referenceID" : 9,
      "context" : "For our purposes we focus on the admissible and on the stable extension semantics introduced in (Dung 1995b) for Abstract Argumentation and in (Bondarenko et al.",
      "startOffset" : 96,
      "endOffset" : 108
    }, {
      "referenceID" : 4,
      "context" : "For our purposes we focus on the admissible and on the stable extension semantics introduced in (Dung 1995b) for Abstract Argumentation and in (Bondarenko et al. 1997) for ABA.",
      "startOffset" : 143,
      "endOffset" : 167
    }, {
      "referenceID" : 10,
      "context" : "An abstract dispute tree (Dung et al. 2006) for an ABA argument A is a (possibly infinite) tree such that:",
      "startOffset" : 25,
      "endOffset" : 43
    }, {
      "referenceID" : 11,
      "context" : "An abstract dispute tree is admissible (Dung et al. 2009) if and only if no argument labels both a proponent and an opponent node.",
      "startOffset" : 39,
      "endOffset" : 57
    }, {
      "referenceID" : 7,
      "context" : "It has been shown that the set of all arguments labelling proponent nodes in an admissible dispute tree is an admissible extension (Dung et al. 2007).",
      "startOffset" : 131,
      "endOffset" : 149
    }, {
      "referenceID" : 4,
      "context" : "10 in (Bondarenko et al. 1997): By the definition of stable extension, X is a stable extension if and only if X = {A in 〈L,R,A,  ̄〉 | X does not attack A}.",
      "startOffset" : 6,
      "endOffset" : 30
    }, {
      "referenceID" : 4,
      "context" : "We use the approach of (Bondarenko et al. 1997) for translating a logic program into an ABA framework, where the clauses of a logic program form the set of ABA rules and NAF literals are used as assumptions in ABA.",
      "startOffset" : 23,
      "endOffset" : 47
    }, {
      "referenceID" : 4,
      "context" : "Note that part of this correspondence has been stated without a formal proof in (Bondarenko et al. 1997).",
      "startOffset" : 80,
      "endOffset" : 104
    }, {
      "referenceID" : 10,
      "context" : "In order to further characterize Attack Trees, we prove that Attack Trees constructed with respect to stable extensions are special cases of abstract dispute trees (Dung et al. 2006).",
      "startOffset" : 164,
      "endOffset" : 182
    }, {
      "referenceID" : 7,
      "context" : "2(i) in (Dung et al. 2007), Args is an admissible extension, and by Lemma 7, Args ⊆ E .",
      "startOffset" : 8,
      "endOffset" : 26
    }, {
      "referenceID" : 12,
      "context" : "P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991);",
      "startOffset" : 56,
      "endOffset" : 85
    }, {
      "referenceID" : 7,
      "context" : "2(ii) in (Dung et al. 2007), Asms is an admissible set of assumptions.",
      "startOffset" : 9,
      "endOffset" : 27
    }, {
      "referenceID" : 4,
      "context" : "5 in (Bondarenko et al. 1997), P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).",
      "startOffset" : 5,
      "endOffset" : 29
    }, {
      "referenceID" : 12,
      "context" : "1997), P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).",
      "startOffset" : 63,
      "endOffset" : 92
    }, {
      "referenceID" : 8,
      "context" : "5 refers to (Dung 1995a) where admissible scenarios are defined for logic programs without classical negation.",
      "startOffset" : 12,
      "endOffset" : 24
    }, {
      "referenceID" : 7,
      "context" : "2(i) in (Dung et al. 2007), Args is an admissible extension.",
      "startOffset" : 8,
      "endOffset" : 26
    }, {
      "referenceID" : 12,
      "context" : "P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); 2.",
      "startOffset" : 56,
      "endOffset" : 85
    }, {
      "referenceID" : 7,
      "context" : "2(ii) in (Dung et al. 2007), Asms is an admissible set of assumptions.",
      "startOffset" : 9,
      "endOffset" : 27
    }, {
      "referenceID" : 4,
      "context" : "5 in (Bondarenko et al. 1997), P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).",
      "startOffset" : 5,
      "endOffset" : 29
    }, {
      "referenceID" : 12,
      "context" : "1997), P ∪ Asms is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991).",
      "startOffset" : 63,
      "endOffset" : 92
    }, {
      "referenceID" : 12,
      "context" : "Then • P ∪ NAF is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); • NAF ⊆ SNAF .",
      "startOffset" : 62,
      "endOffset" : 91
    }, {
      "referenceID" : 12,
      "context" : "• P ∪ NAF ij is an admissible scenario of P in the sense of (Dung and Ruamviboonsuk 1991); • NAF ij ⊆ SNAF .",
      "startOffset" : 60,
      "endOffset" : 89
    }, {
      "referenceID" : 27,
      "context" : "According to (Pontelli et al. 2009), a justification should “provide only the information that are relevant to the item being explained”, making it easier understandable.",
      "startOffset" : 13,
      "endOffset" : 35
    }, {
      "referenceID" : 30,
      "context" : "Argumentation-Based Answer Set Justifications (Schulz et al. 2013) are a “predecessor” of ABAS Justifications using the ASPIC+ argumentation framework (Prakken 2010) instead of ABA.",
      "startOffset" : 46,
      "endOffset" : 66
    }, {
      "referenceID" : 28,
      "context" : "2013) are a “predecessor” of ABAS Justifications using the ASPIC+ argumentation framework (Prakken 2010) instead of ABA.",
      "startOffset" : 90,
      "endOffset" : 104
    }, {
      "referenceID" : 27,
      "context" : "Off-line justifications (Pontelli et al. 2009) explain why a literal is or is not part of an answer set by making use of the well-founded model semantics for logic programs.",
      "startOffset" : 24,
      "endOffset" : 46
    }, {
      "referenceID" : 27,
      "context" : "Example 19 Consider the following logic program Pabc (taken from (Pontelli et al. 2009)), which has two answer sets S1 = {b, e, f} and S2 = {a, e, f}: a← f, not b b← e, not a f ← e d← c, e c← d, f e←",
      "startOffset" : 65,
      "endOffset" : 87
    }, {
      "referenceID" : 30,
      "context" : "Argumentation-Based Answer Set Justification (Schulz et al. 2013) is the first work that applies argumentation theory to answer set programming, and in particular for the justification of answer sets.",
      "startOffset" : 45,
      "endOffset" : 65
    }, {
      "referenceID" : 28,
      "context" : "There, the ASPIC+ argumentation framework (Prakken 2010) is used instead of ABA.",
      "startOffset" : 42,
      "endOffset" : 56
    }, {
      "referenceID" : 14,
      "context" : "In addition to the two explanations approaches for answer sets discussed in the previous sections, (Erdem and Oztok 2013) introduce a formalism for explaining biomedical queries expressed in ASP.",
      "startOffset" : 99,
      "endOffset" : 121
    }, {
      "referenceID" : 27,
      "context" : "comprise every step in the derivation of a literal (similar to the approach of (Pontelli et al. 2009) explained in Section 7.",
      "startOffset" : 79,
      "endOffset" : 101
    }, {
      "referenceID" : 6,
      "context" : "(Brain and Vos 2005) try to answer a similar question as the one we address with ABAS Justifications, i.",
      "startOffset" : 0,
      "endOffset" : 20
    }, {
      "referenceID" : 14,
      "context" : "Just like (Erdem and Oztok 2013), all intermediate steps in a derivation are considered in the explanation, thus differing from ABAS Justifications.",
      "startOffset" : 10,
      "endOffset" : 32
    }, {
      "referenceID" : 16,
      "context" : "ASPIDE (Febbraro et al. 2011) is an Integrated Development Environment for ASP which, among other features, displays the dependency graph of a logic program, i.",
      "startOffset" : 7,
      "endOffset" : 29
    }, {
      "referenceID" : 0,
      "context" : "The problem of constructing explanations has been addressed for logic programs without NAF in (Arora et al. 1993) and (Ferrand et al.",
      "startOffset" : 94,
      "endOffset" : 113
    }, {
      "referenceID" : 17,
      "context" : "1993) and (Ferrand et al. 2012).",
      "startOffset" : 10,
      "endOffset" : 31
    }, {
      "referenceID" : 14,
      "context" : "Thus, this approach is closer to (Erdem and Oztok 2013) and (Brain and Vos 2005) than to ABAS Justifications as it provides all intermediate derivation steps.",
      "startOffset" : 33,
      "endOffset" : 55
    }, {
      "referenceID" : 6,
      "context" : "Thus, this approach is closer to (Erdem and Oztok 2013) and (Brain and Vos 2005) than to ABAS Justifications as it provides all intermediate derivation steps.",
      "startOffset" : 60,
      "endOffset" : 80
    }, {
      "referenceID" : 17,
      "context" : "Similar to this, (Ferrand et al. 2012) show how to use proof trees as explanations for least fixpoint operators, such as the semantics of constraint logic programs, where proof trees are derivations.",
      "startOffset" : 17,
      "endOffset" : 38
    }, {
      "referenceID" : 24,
      "context" : "Explanations have also received attention in other areas in the field of knowledge representation and reasoning, and it has been emphasized that any expert system should provide explanations for its solutions (see (Lacave and Diez 2004) for an overview of explanations in heuristic expert systems).",
      "startOffset" : 214,
      "endOffset" : 236
    }, {
      "referenceID" : 25,
      "context" : "Furthermore, it has been pointed out that even though argumentation and other knowledge-based systems have been studied mostly separately in the past, argumentation could serve as a useful tool for the explanation of other knowledge-based systems (Moulin et al. 2002).",
      "startOffset" : 247,
      "endOffset" : 267
    }, {
      "referenceID" : 2,
      "context" : "In fact, (Bench-Capon et al. 1991) provide an early account of explanations for logic programs in terms of arguments, where Toulmin’s argument scheme is applied.",
      "startOffset" : 9,
      "endOffset" : 34
    }, {
      "referenceID" : 18,
      "context" : "Related to argumentation as an explanation method, (Garćıa et al. 2013) introduce explanations in argumentative terms for argumentation-based reasoning methods, such as Defeasible Logic Programming (Garćıa and Simari 2004), explaining why an argument with a certain conclusion is or is not deemed to be “winning”.",
      "startOffset" : 51,
      "endOffset" : 71
    }, {
      "referenceID" : 19,
      "context" : "2013) introduce explanations in argumentative terms for argumentation-based reasoning methods, such as Defeasible Logic Programming (Garćıa and Simari 2004), explaining why an argument with a certain conclusion is or is not deemed to be “winning”.",
      "startOffset" : 132,
      "endOffset" : 156
    }, {
      "referenceID" : 29,
      "context" : "A potential legal rule base for the application of ABAS Justifications is the encoding of the Japanese Civil Code as used in (Satoh et al. 2010).",
      "startOffset" : 125,
      "endOffset" : 144
    } ],
    "year" : 2014,
    "abstractText" : "An answer set is a plain set of literals which has no further structure that would explain why certain literals are part of it and why others are not. We show how argumentation theory can help to explain why a literal is or is not contained in a given answer set by defining two justification methods, both of which make use of the correspondence between answer sets of a logic program and stable extensions of the Assumption-Based Argumentation (ABA) framework constructed from the same logic program. Attack Trees justify a literal in argumentation-theoretic terms, i.e. using arguments and attacks between them, whereas ABA-Based Answer Set Justifications express the same justification structure in logic programming terms, that is using literals and their relationships. Interestingly, an ABA-Based Answer Set Justification corresponds to an admissible fragment of the answer set in question, and an Attack Tree corresponds to an admissible fragment of the stable extension corresponding to this answer set.",
    "creator" : "LaTeX with hyperref package"
  }
}