{
  "name" : "1505.05367.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Jörg Pührer" ],
    "emails" : [ "ellmauthaler@informatik.uni-leipzig.de", "puehrer@informatik.uni-leipzig.de" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 5.\n05 36\n7v 1\n[ cs\n.A I]\n2 0\nM ay\n2 01\n5"
    }, {
      "heading" : "1 Introduction",
      "text" : "Research in the field of knowledge representation (KR) has originated a plethora of different languages and formats. Based on these formal concepts a wealth of tools has emerged (e.g., ontologies, triple-stores, modal logics, temporal logics, nonmonotonic logics, logic programs under nonmonotonic answer set semantics, . . . ). In a “connected world” it is desirable not to spread out information over different applications but to have it available for every application if need be. Expressing all the knowledge usually represented in specifically tailored languages in a universal language would be too hard to achieve from the point of view of complexity as well as the troubles arising from the translation of the representations. Instead, a framework seems desirable that integrates multiple existing formalisms in order to represent every piece of knowledge in the language that is most appropriate for it.\nAnother aspect that has received little attention in the development of many KR formalisms is that in a variety of applications, knowledge is provided in a constant flow of information and it is desired to reason over this knowledge in a continuous manner. Many formalisms are conceptually one-shot formalisms: given a knowledge base, the user triggers the computation of a result (e.g., the answer to a query). In this paper we aim at using KR formalisms in an online fashion as it has been done in recent works, e.g., on stream data processing and querying [11, 10], stream reasoning with answer set programming [7], and forgetting [9, 5].\nTo address the demand for an integration of heterogeneous knowledge representation formalisms together with the awareness of a continuous flow of knowledge over time, reactive multi-context sys-\n1 This work has been partially supported by the German Research Foundation (DFG) under grants BR-1817/7-1 and FOR 1513. 2 Institute of Computer Science, Leipzig University, Germany, email: {ellmauthaler,puehrer}@informatik.uni-leipzig.de\ntems (rMCSs) [4] and evolving multi-context systems (eMCSs) [8] where proposed. Both frameworks are based on the ideas of managed multi-context systems (mMCSs) [3] which combine multiple contexts which can be seen as representations of different formalisms. The semantics of rMCSs and eMCSs are based on the notion of an equilibrium which realises a tight semantical integration of the different context formalisms which is in many applications not necessary. Due to reasoning over all contexts, the whole computation is necessarily synchronous as the different contexts have to agree on common beliefs for establishing equilibria.\nMany real world applications which utilise communication between different services use asynchronous communication protocols (e.g., web services) and compute as soon as they have appropriate information about the problem they have to address. Therefore, we introduce asynchronous multi-context systems (aMCSs), a framework for loosely coupled knowledge representation formalisms and services. It still provides the capabilities to express different knowledge representation languages and the translation of information from one formalism to another. In addition, aMCSs are also aware of continuous streams of information and provide ways to model the asynchronous exchange of information. To communicate with the environment, they utilise input and output streams.\nWe will illustrate aMCSs using the example of a task planner for medical rescue units. Here, we assume a scenario where persons are calling an emergency response team to report incidents and the employee needs to collect all relevant information about the case. Afterwards, the case needs to be classified and available resources (e.g., free ambulances, . . . ) have to be assigned to the emergencies. In addition, current traffic data as well as the estimated time of arrival should be considered by another employee, the dispatcher. Our proposed aMCS that we understand as a recommender-system for the emergency response employee as well as to the dispatcher, incorporates different contexts like a medical ontology, a database with the current state of the ambulances, or a navigation system which is connected to a traffic density reporter. We want to stress that this might be one application where it would be a great gain for the overall system by allowing asynchronous computation and communication such that it is not necessary to wait for all other contexts (e.g., it would be unnecessary to wait for the recommendation of a plan of action for the dispatcher during the treatment of an emergency call).\nThe remainder of this paper is structured as follows. At first we will give a short background on concepts we need. In Section 3, we extend the basic ideas of MCS to propose our new notion of aMCS for modelling asynchronous interaction between coupled knowledge representation formalisms and formally characterise its behaviour over time. The subsequent section presents an example scenario, where asynchronous computation and a reactive response to different events is needed. Section 5 compares aMCSs to rMCSs and shows how the latter can be simulated by the former. Section 6 concludes\nthis paper with a discussion including an outlook on future work."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We base our approach on the underlying ideas of mMCSs [3] which extend heterogeneous multi-context systems (MCSs) [2] by a management layer. It allows for complex updates and revisions of knowledge bases and is realised by a management function that provides the updates for each equilibrium. Despite we build on mMCSs, they differ substantially in some aspects from the formalism we introduce in this work for reasons intrinsic to the asynchronous approach (cf. Section 5). Consequently, we only reuse basic notions from the original work and refer the interested reader to the paper of Brewka et al. [3] for full details on mMCS.\nLike mMCS, aMCSs build on an abstract notion of a logic suite which can be seen as an abstraction of different formalisms for knowledge representation. A logic suite is a triple LS = 〈KB,BS,ACC〉, where KB is the set of admissible knowledge bases (KBs) of LS. Each knowledge base is a set of formulas that we do not further specify. BS is the set of possible belief sets of LS, whose elements are beliefs. A semantics for LS is a function ACC : KB → 2BS assigning to each KB a set of acceptable belief sets. Using a semantics with potentially more than one acceptable belief set allows for modelling non-determinism, where each belief set corresponds to an alternative solution. Finally, ACC is a set of semantics for LS. We denote KB,BS, respectively, ACC by KBLS ,BSLS , respectively, ACCLS .\nThe motivation behind having multiple semantics for one formalism is that in our framework, the semantics of a formalism can be changed over time. While it is probably rarely the case that one wants to switch between different families of semantics during a run, e.g., from the stable-model semantics to the well-founded semantics of logic programs other switches of semantics are quite natural to many applications: we use different semantics to express different reasoning modes or to express different queries, i.e., ACC1 returns belief sets answering a query q1, whereas ACC2 answers query q2; ACC3, in turn, could represent the computation of all solutions to a problem, whereas at some point in time one could be interested in using ACC4 that only computes a single solution. For instance one that is optimal with respect to some criterion."
    }, {
      "heading" : "3 Asynchronous Multi-Context Systems",
      "text" : "An aMCS is built up by multiple contexts which are defined next and which are used for representing reasoning units. We assume a set N of names that will serve as labels for sensors, contexts, and output streams.\nDefinition 1 A context is a pair C = 〈n,LS〉 where n ∈ N is the name of the context and LS is a logic suite.\nFor a given context C = 〈n,LS〉 we denote n and LS by nC and LSC , respectively.\nDefinition 2 An aMCS (of length n with m output streams) is a pair M = 〈C,O〉, where C = 〈C1, . . . , Cn〉 is an n-tuple of contexts and O = 〈o1, . . . , om〉 with oj ∈ N for each 1 ≤ j ≤ m is a tuple containing the names of the output streams of M .\nBy N (M) we denote the set {nC1 , . . . , nCn , o1, . . . , om} of names of contexts and output streams of M .\nA context in an aMCS communicates with other contexts and the outside world by means of streams of data. In particular, we assume\nthat every context has an input stream on which information can be written from both external sources (we call them sensors) and internal sources (i.e., other contexts). For the data in the communication streams we assume a communication language IL where every i ∈ IL is an abstract piece of information. In our framework, the data in the input stream of a context and the data in output streams are modelled by information buffers that are defined in the following.\nDefinition 3 A data package is a pair d = 〈s, I〉, where s ∈ N is either a context name or a sensor name, stating the source of d , and I ⊆ IL is a set of pieces of information. An information buffer is a sequence of data packages.\nAs we assume that data is asynchronously passed to a context on its input stream, it is natural that not all information required for a computation is available at all times. Consequently, we need means to decide whether a computation should take place, depending on the current KB and the data currently available on the stream, or whether the context has to wait for more data. In our framework, this decision is made by a computation controller as defined next.\nDefinition 4 Let C = 〈n,LS〉 be a context. A computation controller for C is a relation cc between a KB KB ∈ KBLS and a finite information buffer.\nThus, if 〈KB, ib〉 ∈ cc then a computation should take place, whereas 〈KB, ib〉 6∈ cc means that further information is required before the next computation is triggered in the respective context.\nIn contrast to the original definition of multi-context systems [1] and extensions thereof, we do not make use of so-called bridge rules as a means to communicate: a bridge rule defines which information a context should obtain based on the results of all the contexts of a multi-context system. In the asynchronous approach, we do not have (synchronised) results of all contexts available in general. As a consequence we use another type of rules, called output rules, that define which information should be sent to another context or an output stream, based on a result of a single context.\nDefinition 5 Let C = 〈n,LS〉 be a context. An output rule r for C is an expression of the form\n〈n, i〉 ←b1, . . . , bj ,not bj+1, . . . ,not bm, (1)\nsuch that n ∈ N is the name of a context or an output stream, i ∈ IL is a piece of information, and every bℓ (1 ≤ ℓ ≤ m) is a belief for C, i.e., bℓ ∈ S for some S ∈ BSLS .\nWe call n the stakeholder of r, 〈n, i〉 the head of r denoted by hd(r) and b1, . . . , bj ,not bj+1, . . . ,not bm the body bd(r) of r. Moreover, we say that r is active under S, denoted by S |= bd(r), if {b1, . . . , bj} ⊆ S and {bj+1, . . . , bm} ∩ S = ∅.\nIntuitively, the stakeholder is a reference to the addressee of information i.\nDefinition 6 Let C = 〈n,LS〉 be a context, OR a set of output rules for C, S ∈ BSLS a belief set, and n′ ∈ N a name. Then, the data package\ndC(S,OR, n ′) = 〈n, {i | r ∈ OR, hd(r) = 〈n′, i〉, S |= bd(r)}〉\nis the output of C with respect to OR under S relevant for n.\nCompared to previous notions of multi-context systems, contexts in our setting only specify which formalisms they use but they do\nnot contain knowledge bases, the concrete semantics to use, and communication specifications. The reason is that for aMCSs these may change over time. Instead, we wrap concepts that are subject to change during runtime in the following notion of a configuration.\nDefinition 7 Let C = 〈n,LS〉 be a context. A configuration of C is a tuple cf = 〈KB,ACC, ib, cm〉, where KB ∈ KBLS , ACC ∈ ACCLS , ib is a finite information buffer, and cm is a context management for C which is a triple cm = 〈cc, cu,OR〉, where\n• cc is a computation controller for C, • OR is a set of output rules for C, and • cu is a context update function for C which is a function that maps\nan information buffer ib = d1, . . . , dm and an admissible knowledge base of LS to a configuration cf ′ = 〈KB′,ACC′, ib′, cm ′〉 of C with ib′ = dk, . . . , dm for some k ≥ 1.\nWe write cccm , cucm , and ORcm to refer to the components of a given context management cm = 〈cc, cu,OR〉. The context management is the counterpart of a management function of an rMCS, that computes an update of the knowledge base of a context given the results of bridge rules of the context.\nIn Section 2 we already discussed why we want to change semantics over time. Allowing also for changes of output rules can be motivated with applications where it should be dynamically decided where to direct the output of a context. For example, if a particular subproblem can be solved by two contexts C1 and C2 and it is known that some class of instances can be better solved by C1 and others by C2. Then a third context that provides an instance can choose whether C1 or C2 should carry out the computation by adapting its output rules. Dynamically changing output rules and semantics could require adjustments of the other components of the context management. Thus, it makes sense that also compution controllers and context update functions are subject to change for the sake of flexibility.\nDefinition 8 Let M = 〈〈C1, . . . , Cn〉, 〈o1, . . . , om〉〉 be an aMCS. A configuration of M is a pair\nCf = 〈〈cf 1, . . . , cf n〉, 〈ob1, . . . , obm〉〉,\nwhere\n• for all 1 ≤ i ≤ n cf i = 〈KB,ACC, ib, cm〉 is a configuration for Ci and for every output rule r ∈ ORcm we have n ∈ N (M) for 〈n, i〉 = hd(r), and • obj = . . . , dl−1, dl is an information buffer with a final element dl that corresponds to the data on the output stream named oj for each 1 ≤ j ≤ m such that for each h ≤ l with dh = 〈n, i〉 we have n = nCi for some 1 ≤ i ≤ n.\nFigure 1 depicts an aMCS M with three contexts and a configuration for M .\nWe next characterise the dynamic behaviour of an aMCS. For easier notation we stick to a discrete notion of time represented by integers.\nDefinition 9 Let M = 〈〈C1, . . . , Cn〉, 〈o1, . . . , om〉〉 be an aMCS. A run structure for M is a sequence\nR = . . . ,Cf t,Cf t+1,Cf t+2, . . . ,\nwhere t ∈ Z is a point in time, and every Cf t ′\nin R (t′ ∈ Z) is a configuration of M .\nWe will sometimes use cf ti to denote the configuration of a context i that appears at time t in a given run structure in the context of a given aMCS. Similarly, obtj refers to the information buffer representing the data in the output stream named oj . Moreover, we write KBti , ACC t i, ib t i , and cm t i to refer to the components of cf ti = 〈KB,ACC, ib, cm〉. We say that context Ci is waiting at time t if 〈KBti, ib t i〉 6∈ cccmt\ni\n.\nFrom run structure to run In aMCSs we take into account that the computation of the semantics of a knowledge base needs time. Moreover, in a computation of our framework, different belief sets may become available at different times and verifying the nonexistence of further belief sets can also take time after the final belief set has been computated. In order to model whether a context is busy with computing, we introduce a boolean variable busy ti for each configuration cf ti in a run structure. Hence, context Ci is busy at time t iff busy ti is true. While a context is busy, it does not read new information from its input stream until every belief set has been computed and it has concluded that no further belief set exists.\nAfter the computation of a belief set, the output rules are applied in order to determine which data is passed on to stakeholder contexts or output streams. These are represented by stakeholder buffers: An information buffer b is the stakeholder buffer of Ci (for n) at time t if\n• b = ibti′ for some 1 ≤ i ′ ≤ n such that n = nCi is stakeholder of\nsome output rule in OR cm t\ni\nor\n• b = obtj′ for some 1 ≤ j ′ ≤ m such that n = oj′ is stakeholder\nof some output rule in OR cm t\ni\n.\nIn order to indicate that a computation has finished we assume a dedicated symbol EOC ∈ IL that notifies a context’s stakeholder buffers about the end of a computation.\nNext, we formally characterise the behaviour of aMCSs followed by a summary of its intuition.\nDefinition 10 Let M be an aMCS of length n with m output streams and R a run structure for M . R is a run for M if the following conditions hold for every 1 ≤ i ≤ n and every 1 ≤ j ≤ m:\n(i) if cf ti and cf t+1 i are defined, Ci is neither busy nor waiting at time\nt, then\n– Ci is busy at time t+ 1,\n– cf t+1i = cucmt i (ibti,KB t i)\nWe say that Ci started a computation for KBt+1i at time t+ 1. (ii) if Ci started a computation for KB at time t then\n– we say that this computation ended at time t′, if t′ is the earliest time point with t′ ≥ t such that 〈nCi ,EOC〉 is added to every stakeholder buffer b of Ci at t′; the addition of dCi(S,ORcmt′′\ni\n, n) to b is called an end of computation no-\ntification.\n– for all t′ > t such that cf t ′\ni is defined, Ci is busy at t ′ unless\nthe computation ended at some time t′′ with t < t′′ < t′.\n– if the computation ended at time t′ and cf t ′ +1\ni is defined then Ci is not busy at t′ + 1.\n(iii) if Ci started a computation for KB at time t that ended at time t′ then for every belief set S ∈ ACCti there is some time t\n′′ with t ≤ t′′ ≤ t′ such that\n– dCi(S,ORcmt′′ i , n) is added to every stakeholder buffer b of\nCi for n at t′′.\nWe say that Ci computed S at time t′′. The addition of dCi(S,ORcmt′′\ni\n, n) to b is called a belief set notification.\n(iv) if obtj and ob t+1 j are defined and ob t j = . . . , dl−1, dl then\nobt+1j = . . . , dl−1, dl, . . . , dl′ for some l ′ ≥ l. Moreover, every data package dl′′ with l < l ′′ ≤ l′ that was added at time t + 1 results from an end of computation notification or a belief set notification. (v) if cf ti and cf t+1 i are defined, Ci is busy or waiting at time t, and\nibti = d1, . . . , dl then we have ib t+1 i = d1, . . . , dl, . . . , dl′ for some l′ ≥ l. Moreover, every data package dl′′ with l < l ′′ ≤ l′ that was added at time t+ 1 either results from an end of computation notification or a belief set notification or n /∈ N (M) (i.e., n is a sensor name) for dl′′ = 〈n, i〉.\nCondition (i) describes the transition from an idle phase to an ongoing computation. The end of such a compation is marked by an end of computation notification as introduced in Item (ii). Condition (iii) states that between the start and the end of a computation all belief sets are computed and stakeholders are notified. Items (iv) and (v) express how data is added to an output stream or to an input stream, respectively. Note that here, sensors and the flow of information from sensors to the input buffers of contexts are implicit. That is, data packages from a sensor may appear at the end of input buffers at all times and the only reference to a particular sensor is its name appearing in a data package.\nSummarising the behaviour characterised by a run, whenever a context C is not busy, its context controller cc checks whether a new computation should take place, based on the knowledge base and the current input buffer of C. If yes, the current configuration of the context is replaced by a new one, computed by the context update function cu of C. Here, the new input buffer has to be a suffix of the old one and a new computation for the updated knowledge base starts. After an undefined period of time, belief sets are computed and based on the application of output rules of C, data packages are sent to stakeholder buffers. At some point in time, when all belief sets have been computed, an end of computation notification is sent to stakeholders, and the context is not busy anymore."
    }, {
      "heading" : "4 Scenario: Computer-Aided Emergency Team Management",
      "text" : "Now we want to consider a scenario, where aMCSs may be used to describe the asynchronous information-exchange between different specialised reasoning systems. Our example deals with a recommender-system for the coordination and handling of ambulance assignments. The suggested aMCS supports decisions in various stages of an emergency case. It gives assistance during the rescue call, helps in assigning priorities and rescue units to a case, and assists in the necessary communication among all involved parties. The suggestions given by the system are based on different specialised systems which react to sensor readings. Moreover, the system can tolerate and incorporate overriding solutions proposed by the user that it considers non-optimal.\nFigure 2 depicts the example aMCS which models such a Computer-Aided Emergency Team Management System (CAET Management System). Note that interaction with a human (e.g., EM employee) is modelled as a pair containing an input stream and an output stream. The system consists of the following contexts:\nCase Analyser (ca) This context implements a computer-aided call handling system which assists an emergency response employee (ER employee) during answering an emergency call. The system utilises reasoning methods to choose which questions need to be asked based on previous answers. In addition, it may check whether answers are inconsistent (e.g., amniotic sac bursts when the gender is male). For these purposes the case analyser context may also consult a medical ontology represented by another context. The communication with the ER employee is represented, on the one hand, as a sensor that reads the input of the employee and, on the other hand, by an output stream which prints the questions and results on a computer screen. During the collection of all the important facts for this emergency case, the analyser computes the priority of the case and passes it to the task planner. Med Ontology (mo) This medical ontology can be realised, e.g., by a description logic reasoner which handles requests from the case analyser and returns more specific knowledge about ongoing cases. This information may be used for the prioritisation of the importance of a case.\nTask Planner (tp) This context keeps track of emergency cases. Based on the priority and age of a case and the availability and position of ambulances it suggests an efficient plan of action for the ambulances to the (human) case dispatcher (cd). The dispatcher may approve some of the suggestions or all of them. If the dispatcher has no faith in the given plan of action, she can also alter it at will. These decisions are reported back to the planning system such that it can react to the alterations and provide further suggestions. Based on the final plan, the task planner informs the ambulance about their new mission. The knowledge base of the context is an answer-set program for reasoning about a suggested plan. It gets the availability and position of the ambulances by the ambulance manager. In addition, the cases with their priority are provided by the case analyser. With this information, the task planner gives the locations of the ambulances together with the target locations of the cases to a navigation system which provides the distances (i.e., the estimated time of arrival (ETA)) of all the ambulances to all the locations. Amb Manager (am) The ambulance manager is a database, which keeps track of the status and location of ambulance units. Each ambulance team reports its status (e.g., to be on duty, waiting for new mission, . . . ) to the database (modelled by the sensor “Ambulance” (amb)). Additionally, the car periodically sends GPS-coordinates to the database. These updates will be pushed to the task planner. Navigation (na) This part of the aMCS gets traffic information (e.g., congestions, roadblocks, construction zones, . . . ) to predict the travel time for each route as accurate as possible. The task planner may push a query to the navigation system, which consists of a list of locations of ambulance units and a list of locations of target areas. Based on all the given information this context will return a ranking for each target area, representing the ETAs for each ambulance.\nNow we want to have a closer look on the instantiation details of some aspects of our example. At first we investigate the cc relation of the case analyser. It allows for the computation of new belief sets whenever the ER employee pushes new information to the analyser. In addition, it will also approve of a new computation if the medical ontology supplies some requested information. Recall that the case analyser also assigns a priority to each case and that we want to allow the employee to set the priority manually. Let us suppose that such a manual override occurs and that the case analyser has an ongoing query to the medical ontology. Due to the manual priority assignment, the requested information from the ontology is no longer needed. Therefore, it would be desirable that cc does not allow for a recomputation if all conclusions of the ontology are only related to the manually prioritised case. With the same argumentation in mind, the context update function cu will also ignore this information on the input stream. This kind of behaviour may need knowledge about past queries which can be provided by an additional output rule for the case analyser which feeds the relevant information back to the context.\nNext, we will have a look at the task planner that is based on answer-set programming. We will only present parts of the program, to show how the mechanics are intended to work. To represent the incoming information on the input stream, the following predicates can be used:\ncase(caseid,loc,priority) represents an active case (with its location and priority) which needs to be assigned to an ambulance. avail(amb,loc) states the location of an available ambulance.\neta(caseid,amb,value) provides the estimated time of arrival for a unit at the location of the target area of the case. assign(amb,caseid) represents the assignment of an ambulance to a case by the dispatcher.\nThese predicates will be added by the context update function to the knowledge base if corresponding information is put on the input stream of the context. Based on this knowledge, the other components of the answer-set program will compute the belief sets (e.g., via the stable model semantics). Note that an already assigned ambulance or case will not be handled as an available ambulance or an active case, respectively. In addition, cu can (and should) also manage forgetting of no longer needed knowledge. For our scenario it may be suitable to remove all eta, avail and case predicates when the cases or the unit is assigned. The assign predicate can be removed when the ambulance manager reports that the assigned ambulance is available again.\nThe set OR of output rules of the task planner could contain the following rules:3\n〈cd,assign(A,C)〉 ← sugassignment(A,C)\n〈na,queryA(L)〉 ← avail(A), not assign(A, ), loc(A,L)\n〈na,queryC(L)〉 ← case(C,P ), loc(A,L), not assign(A, )\n〈amb,assigned(A,C)〉 ← assign(A,C)\nThe first rule informs the case dispatcher (cd) about a suggested assignment that has been computed by the answer-set program. Rules two and three prepare lists of ambulances and cases for querying the navigation context. Recall that the latter needs a list of ambulance locations (generated by rule two) and a list of target area locations (generated by rule three). Also keep in mind that for each belief set a data package with all information for one context or output stream is constructed. So the whole list of current target areas and free ambulance units will be passed to the navigation context at once. The last rule notifies the ambulance team that it has been assigned to a specific case.\nRelated to this example we want to mention privacy aspects as a real world policy which is especially important to applications in public services and health care. As the multi-context system is a heterogeneous system with different contexts, a completely free exchange of data may be against privacy policies. This issue can be addressed by the adequate design of output rules, which can also be altered with respect to additional information in the input stream (e.g., some context gains the permission to receive real names instead of anonymous data). So each context may decide by its own which parts of the belief sets are shared and exchanged with other contexts.\nAnother interesting aspect about aMCSs is the possibility to easily join two aMCSs together, outsource a subset of contexts in a new aMCS, or to view an aMCS as an abstract context for another aMCS in a modular way. This can be achieved due to the abstract communication by means of streams. With respect to our scenario there could be some aMCS which does the management of resources for hospitals (e.g., free beds with their capabilities). The task planner might communicate with this system to take the needed services for a case into account (e.g., intensive care unit) and informs the hospital via these streams about incoming patients. It would be easy to join both aMCSs together to one big system or to outsource some contexts as input sensors paired with an output stream. In addition, one may also combine different contexts or a whole aMCS to one abstract context\n3 Keep in mind that in an actual implementation one may want to provide further information via communication.\nto provide a dynamic granularity of information about the system and to group different reasoning tasks together."
    }, {
      "heading" : "5 Relation to Reactive Multi-Context Systems",
      "text" : "In this section we want to address differences and communalities between aMCSs and rMCSs [4] as both are types of multi-context systems that work in an online fashion and can react to external information. Runs of rMCSs are based on equilibria which are collections of belief sets—one for each context—on which, intuitively, all of the contexts have to agree. Thus, equilibria can be seen as a tight integration approach in which the semantics of the individual contexts are interdependent. However, the high level of integration also comes at the price that the different contexts must wait for each other for the computation of each equilibrium, i.e., they are synchronised. In aMCSs, on the other hand, the coupling of the semantics is much looser—communication between contexts only works via data packages that are sent to another context after a computation and not via a higher-level common semantics for multiple contexts. But as a benefit, each context can run at its own pace which is useful in settings where there is a context that requires much more time for evaluating its semantics than others.\nA further difference is the role of non-determinism in the semantics of aMCSs and rMCSs. An equilibrium in an aMCS consists of a single belief set for each context. Hence, as aMCSs also use a multiple belief set semantics, there may also be multiple equilibria as a source of non-determinism at each step in a run. For aMCSs, all belief sets of a context are computed in a consecutive way (we assume that if only a single belief set is desired than the semantics of the respective context should be adapted accordingly by the knowledge engineer). Nevertheless, there is also a source of non-determinism in the case of aMCSs caused by the undefined duration of computations.\nRegarding the computational complexity of the two frameworks, the computation of an equilibrium requires to guess an equilibrium candidate first before the semantics of the context is computed which is expensive regarding runtime when put to practice. In theory, this guess does not add extra complexity if the context semantics is already NP-hard (as shown in [4]) because it can be combined with the guesses required in the contexts. However, this trick cannot be used in implementations that uses black boxes for computing context semantics. On the other hand, aMCSs do not add substantial computational requirements to the effort needed for computing context semantics. In particular, aMCSs are scalable as adding a further context has no direct influence on how the semantics of the other contexts are computed but can only influence the input they get.\nBoth, aMCSs and rMCSs are very general frameworks that allow for simulating Turing machines and thus for performing multipurpose computations even if only very simple context formalisms are used (if the length of a run is not restricted). In this sense the approaches are equally expressive. Moreover, when allowing for arbitrary contexts one could trivially simulate the other by including it as a context. Despite the existence of these straightforward translations, we next sketch how we simulate an rMCS with an aMCS using a more direct translation, as this gives further insight into the differences of the two frameworks. Moreover, it demonstrates a way to implement rMCSs by means of aMCSs. For every context Ci of a given rMCS Mr , we introduce three contexts in the aMCS Ma that simulates Mr:\n• a context Ckbi that stores the current knowledge base of the context,\n• a context Ckb ′\ni in which a candidate for an updated knowledge base can be written and its semantics can be computed, and • a management context Cmi that implements the bridge rules, and the management function of the context.\nThere are three further contexts:\n• Cobs receives sensor data and distributes it to every context Cmi where Ci depends on the respective sensor. The context is also responsible for synchronisation: for each sensor, new sensor data is only passed on after an equilibrium has been computed. • Cguess guesses equilibrium candidates for M and passes them to the management contexts Cmi . Based on that and the information from Cobs, Cmi computes an update kb ′ i of the knowledge base in\nCkbi and stores kb ′ i in C\nkb′\ni . The latter context then computes the semantics of kb′i and passes it to the final context • Ccheck that compares every belief set it receives with the equilibrium candidate (that it also receives from Cguess). If a matching belief set has been found for each context of Mr , the candidate is an actual equilibrium. In this case Ccheck sends the equilibrium to an output stream and notifies the other contexts about the success.\nIn case of a success, every context Cmi replaces the knowledge base in Ckbi by kbi and a next iteration begins. In case no equilibrium was found but one of the Ckb ′\ni contexts has finished its computation, Ccheck orders Cguess to guess another equilibrium candidate."
    }, {
      "heading" : "6 Related Work and Discussion",
      "text" : "A concept similar to output-rules has been presented in the form of reactive bridge rules [6]. There the flow of information is represented by rules which add knowledge to the input streams of other contexts. Which information is communicated to other contexts is also determined by the local belief set of each context.\nNote that evolving multi-context systems [8] follow a quite similar approach as rMCSs and hence the relation of aMCSs to rMCSs sketched in the previous section also applies in essence to this approach.\nThe system clingo [7] is a reactive answer-set programming solver. It utilises TCP/IP ports for incoming input streams and does also report the resulting answer sets via such a port. It provides means to compute different semantics and can keep learned structures and knowledge from previous solving steps. Although there are no output rules or input stream pre-processing as in aMCSs, the system features embedded imperative programming languages which may be helpful to model some of the presented concepts of this paper.\nIn general, the tasks performed by a context management can be realised by different formalisms (e.g., imperative scripting languages or declarative programming). Here, it seems likely that different languages can be the most appropriate management language, depending on the type of context formalism and the concrete problem domain. A feature that is not modelled in our proposal but that is potentially useful and we intend to consider in the future is to allow for aborting computations. Moreover, we want to study modelling patterns and best practices for aMCSs design for typical application settings and compare different inter-context topologies and communication strategies.\nThe next natural step towards an implementation is an analysis of how existing tools such as clingo could be used for a realisation. It is clear that such formalisms can be used as a context formalism. Moreover, we are interested in how reactive features of\nclingo (e.g., iterative computation, on-demand grounding, onlinequeries, . . . ) relate to aMCS concepts (e.g., cc, ib, . . . ) and whether the system can be described in terms of an aMCS."
    } ],
    "references" : [ {
      "title" : "Equilibria in heterogeneous nonmonotonic multi-context systems’, in AAAI’07",
      "author" : [ "Gerhard Brewka", "Thomas Eiter" ],
      "venue" : null,
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2007
    }, {
      "title" : "Nonmonotonic multi-context systems: A flexible approach for integrating heterogeneous knowledge sources’, in Logic Programming, Knowledge Representation, and Nonmonotonic Reasoning, 233–258",
      "author" : [ "Gerhard Brewka", "Thomas Eiter", "Michael Fink" ],
      "venue" : null,
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2011
    }, {
      "title" : "Managed multi-context systems’, in IJCAI’11",
      "author" : [ "Gerhard Brewka", "Thomas Eiter", "Michael Fink", "Antonius Weinzierl" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2011
    }, {
      "title" : "Lpforget: A system of forgetting in answer set programming",
      "author" : [ "Fu-Leung Cheng", "Thomas Eiter", "Nathan Robinson", "Abdul Sattar", "Kewen Wang" ],
      "venue" : "in Proc. AUSAI’06,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2006
    }, {
      "title" : "Generalizing multi-context systems for reactive stream reasoning applications",
      "author" : [ "Stefan Ellmauthaler" ],
      "venue" : "in Proc. ICCSW’13, pp",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2013
    }, {
      "title" : "Stream reasoning with answer set programming: Preliminary report",
      "author" : [ "Martin Gebser", "Torsten Grote", "Roland Kaminski", "Philipp Obermeier", "Orkunt Sabuncu", "Torsten Schaub" ],
      "venue" : "in Proc. KR’12,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2012
    }, {
      "title" : "Evolving multicontext systems",
      "author" : [ "Ricardo Gonçalves", "Matthias Knorr", "João Leite" ],
      "venue" : "in Proc. ECAI’14,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2014
    }, {
      "title" : "Reasoning under inconsistency: A forgetting-based approach",
      "author" : [ "Jérôme Lang", "Pierre Marquis" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2010
    }, {
      "title" : "Linked stream data processing",
      "author" : [ "Danh Le-Phuoc", "Josiane Xavier Parreira", "Manfred Hauswirth" ],
      "venue" : "Proc. RW’12,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2012
    }, {
      "title" : "Logical foundations of continuous query languages for data streams",
      "author" : [ "Carlo Zaniolo" ],
      "venue" : "in Proc. Datalog",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : ", on stream data processing and querying [11, 10], stream reasoning with answer set programming [7], and forgetting [9, 5].",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 8,
      "context" : ", on stream data processing and querying [11, 10], stream reasoning with answer set programming [7], and forgetting [9, 5].",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 5,
      "context" : ", on stream data processing and querying [11, 10], stream reasoning with answer set programming [7], and forgetting [9, 5].",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 7,
      "context" : ", on stream data processing and querying [11, 10], stream reasoning with answer set programming [7], and forgetting [9, 5].",
      "startOffset" : 116,
      "endOffset" : 122
    }, {
      "referenceID" : 3,
      "context" : ", on stream data processing and querying [11, 10], stream reasoning with answer set programming [7], and forgetting [9, 5].",
      "startOffset" : 116,
      "endOffset" : 122
    }, {
      "referenceID" : 6,
      "context" : "de tems (rMCSs) [4] and evolving multi-context systems (eMCSs) [8] where proposed.",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 2,
      "context" : "Both frameworks are based on the ideas of managed multi-context systems (mMCSs) [3] which combine multiple contexts which can be seen as representations of different formalisms.",
      "startOffset" : 80,
      "endOffset" : 83
    }, {
      "referenceID" : 2,
      "context" : "We base our approach on the underlying ideas of mMCSs [3] which extend heterogeneous multi-context systems (MCSs) [2] by a man-",
      "startOffset" : 54,
      "endOffset" : 57
    }, {
      "referenceID" : 1,
      "context" : "We base our approach on the underlying ideas of mMCSs [3] which extend heterogeneous multi-context systems (MCSs) [2] by a man-",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 2,
      "context" : "[3] for full details on mMCS.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : "In contrast to the original definition of multi-context systems [1] and extensions thereof, we do not make use of so-called bridge rules as a means to communicate: a bridge rule defines which information a context should obtain based on the results of all the contexts of a multi-context system.",
      "startOffset" : 64,
      "endOffset" : 67
    }, {
      "referenceID" : 4,
      "context" : "A concept similar to output-rules has been presented in the form of reactive bridge rules [6].",
      "startOffset" : 90,
      "endOffset" : 93
    }, {
      "referenceID" : 6,
      "context" : "Note that evolving multi-context systems [8] follow a quite similar approach as rMCSs and hence the relation of aMCSs to rMCSs sketched in the previous section also applies in essence to this approach.",
      "startOffset" : 41,
      "endOffset" : 44
    }, {
      "referenceID" : 5,
      "context" : "The system clingo [7] is a reactive answer-set programming solver.",
      "startOffset" : 18,
      "endOffset" : 21
    } ],
    "year" : 2015,
    "abstractText" : "In this work, we present asynchronous multi-context systems (aMCSs), which provide a framework for loosely coupling different knowledge representation formalisms that allows for online reasoning in a dynamic environment. Systems of this kind may interact with the outside world via input and output streams and may therefore react to a continuous flow of external information. In contrast to recent proposals, contexts in an aMCS communicate with each other in an asynchronous way which fits the needs of many application domains and is beneficial for scalability. The federal semantics of aMCSs renders our framework an integration approach rather than a knowledge representation formalism itself. We illustrate the introduced concepts by means of an example scenario dealing with rescue services. In addition, we compare aMCSs to reactive multi-context systems and describe how to simulate the latter with our novel ap-",
    "creator" : "LaTeX with hyperref package"
  }
}