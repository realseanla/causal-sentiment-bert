{
  "name" : "1609.05811.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Temporal Logic Programs with Variables",
    "authors" : [ "Felicidad Aguado", "Pedro Cabalar", "Mart́ın Diéguez", "Gilberto Pérez", "Concepción Vidal", "F. Aguado", "P. Cabalar", "M. Diéguez", "G. Pérez", "C. Vidal" ],
    "emails" : [ "aguado@udc.es", "cabalar@udc.es", "gperez@udc.es", "eicovima@udc.es", "martin.dieguez@irit.fr" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 9.\n05 81\n1v 1"
    }, {
      "heading" : "Under consideration in Theory and Practice of Logic Programming (TPLP)",
      "text" : "KEYWORDS: Artificial Intelligence; Knowledge Representation; Temporal Logic; Grounding; Logic Programming; Answer Set Programming"
    }, {
      "heading" : "1 Introduction",
      "text" : "Many application domains and example scenarios from Answer Set Programming (ASP) (Niemelä 1999; Marek and Truszczyński 1999) contain a dynamic component, frequently representing transition systems over discrete time. In an attempt to provide a full logical framework for temporal reasoning in ASP, (Aguado et al. 2008) proposed a formalism called Temporal Equilibrium Logic (TEL), syntactically identical to propositional Linear-time Temporal Logic (LTL) (Pnueli 1977), but semantically relying on a temporal extension of Equilibrium Logic (Pearce 1996), the most\ngeneral and best studied logical characterisation of stable models (Gelfond and Lifschitz 1988). In (Aguado et al. 2011) a reduction of (propositional) TEL into regular LTL was presented, but applicable to a subclass of temporal theories called splittable Temporal Logic Programs. This syntactic fragment deals with temporal rules in which, informally speaking, “past does not depend on the future,” a restriction general enough to cover most (if not all) existing examples of ASP temporal scenarios. The reduction was implemented in a tool, STeLP1 (Cabalar and Diéguez 2011), that computes the temporal stable models of a given program, that are shown as a Büchi automaton.\nAlthough the approach in (Aguado et al. 2011) was exclusively propositional, the input language of STeLP was extended with variables. As in non-temporal ASP, these were just understood as a shortcut for all their possible ground instances. This initial approach was not fully satisfactory for several reasons. First, it forced that any variable instance was not only safe (that is, occurring in the positive body of the rule) but also “typed” by a static predicate, i.e., a predicate whose extent does not vary along time. Second, this restriction implied sometimes the generation of irrelevant ground rules that increased the size of the resulting ground LTL theory while they could be easily detected and removed by a simple analysis of the temporal program. Last, but not least, the treatment of variables had no formal background and had not been proved to be sound with respect to the important property of domain independence (Bria et al. 2008) – essentially, a program is domain independent when its stable models do not vary under the arbitrary addition of new constants. Although the usual definition of safe variables guarantees domain independence, there was no formal proof for temporal logic programs under TEL.\nIn this note we provide some results that allow an improved treatment of variables in temporal logic programs, using a first order version of TEL as underlying logical framework. We relax the STeLP definition of safe variable by removing the need for static predicates so that, as in ASP, a variable in a rule is safe when it occurs in the positive body2. We prove that this simpler safety condition satisfies domain independence. Finally, we describe a method for grounding temporal logic programs under this new safety condition that still allows calling a standard ASP grounder as a backend, but using a positive normal logic program that is generated by a given transformation on the original temporal logic program.\n2 A motivating example\nExample 1 Suppose we have a set of cars placed at different cities and, at each transition, we can drive a car from one city to another in a single step, provided that there is a road connecting them. ⊠\nFigure 1 contains a possible representation of this scenario in the language of\n1 http://kr.irlab.org/stelp_online 2 This definition of safety, initially introduced in DLV (Leone et al. 2006) has been adopted in the standard ASP-Core-2 (Calimeri et al. 2015) and also followed by Gringo (Gebser et al. 2011).\nSTeLP. Operator ‘o’ stands for “next” whereas “::-” corresponds to the standard ASP conditional “:-”, but holding at all time points. Rule (1) is the effect axiom for driving car X to city A. The disjunctive rule (2) is used to generate possible occurrences of actions in a non-deterministic way. Rules (3) and (4) represent the inertia of fluent at(X,A). Finally, rule (5) forbids that a car is at two different cities simultaneously.\nAs we can see in the first line, predicates city/1, car/1 and road/2 are declared to be static. The scenario would be completed with rules for static predicates. These rules constitute what we call the static program and can only refer to static predicates without temporal operators. An example of a static program for this scenario could be:\nroad(A,B) :- road(B,A). % roads are bidirectional city(A) :- road(A,B). car(1). car(2). road(lisbon,madrid). road(madrid,paris). road(boston,ny). road(ny,nj).\nAdditionally, our temporal program would contain rules describing the initial state like, for instance, the pair of facts:\nat(1,madrid). at(2,ny).\nNote that all variables in a rule are always in some atom for a static predicate in the positive body. The current grounding process performed by STeLP just consists in feeding the static program to an ASP grounder (DLV or gringo) and, once it provides an extension for all the static predicates, each temporal rule is instantiated for each possible substitution of variables according to static predicates. In our running example, for instance, the grounder provides a unique model3 for the static program containing the facts:\n3 If the static program yields several stable models, each one generates a different ground theory whose temporal stable models are computed independently.\ncar(1), car(2), city(lisbon), city(madrid), city(paris), city(boston), city(ny), city(nj), road(lisbon,madrid), road(madrid,lisbon), road(madrid,paris), road(paris,madrid), road(boston,ny), road(ny,boston), road(ny,nj), road(nj,ny)\nWith these data, rule (1) generates 12 ground instances, since we have two possible cars for X and six possible cities for A. Similarly, rule (4) would generate 60 instances as there are 30 pairs A,B of different cities and two cars for X. Many of these ground rules, however, are irrelevant. Take, for instance:\no at(1,ny) ::- driveto(1,ny). no_at(1,paris) ::- at(1,ny).\ncorresponding to possible instantiations of (1) and (4), respectively. In both cases, the body refers to a situation where car 1 is located or will drive to New York, while we can observe that it was initially at Madrid and that the European roadmap is disconnected from the American one. Of course, one could additionally encode a static reachability predicate to force that rule instances refer to reachable cities for a given car, but this would not be too transparent or elaboration tolerant.\nOn the other hand, if we forget, for a moment, the temporal operators and we consider the definition of safe variables used in ASP, one may also wonder whether it is possible to simply require that each variable occurs in the positive body of rules, without needing to refer to static predicates mandatorily. Figure 2 contains a possible variation of the same scenario allowing this possibility. Our goal is allowing this new, more flexible definition of safe variables and exploiting, if possible, the information in the temporal program to reduce the set of generated ground rules."
    }, {
      "heading" : "3 Temporal Quantified Equilibrium Logic",
      "text" : "Syntactically, we consider function-free first-order languages L = 〈C,P 〉 built over a set of constant symbols, C, and a set of predicate symbols, P . Using L, connectors\nand variables, an L = 〈C,P 〉-formula F is defined following the grammar:\nF ::= p | ⊥ | F1 ∧ F2 | F1 ∨ F2 | F1 → F2 |\n©F | F | ♦F | ∀xF (x) | ∃xF (x)\nwhere p ∈ P is an atom, x is a variable and ©, and ♦ respectively stand for “next”, “always” and “eventually.” A theory is a finite set of formulas. We use the following derived operators:\n¬F def = F → ⊥\n⊤ def = ¬⊥\nF ↔ G def = (F → G) ∧ (G→ F )\nfor any formulas F,G. An atom is any p(t1, . . . , tn) where p ∈ P is a predicate with n-arity and each ti is a term (a constant or a variable) in its turn. We say that a term or a formula is ground if it does not contain variables. An L-sentence or closed-formula is a formula without free-variables.\nThe application of i consecutive ©’s is denoted as follows: ©iϕ def = ©(©i−1ϕ) for i > 0 and ©0ϕ def = ϕ. A temporal fact is a construction of the form ©iA where A is an atom.\nLet D be a non-empty set (the domain or universe). By At(D,P ) we denote the set of ground atomic sentences of the language 〈D,P 〉. We will also define an interpretation σ of constants in C (and domain elements in D) as a mapping\nσ : C ∪D → D\nsuch that σ(d) = d for all d ∈ D.\nA first-order LTL-interpretation is a structure 〈(D, σ),T〉 where D and σ are as above and T is an infinite sequence of sets, T = {Ti}i≥0 with Ti ⊆ At(D,P ). Intuitively, Ti contains those ground atoms that are true at situation i. Given two LTL-interpretations H and T we say that H is smaller than T, written H ≤ T, when Hi ⊆ Ti for all i ≥ 0. As usual, H < T stands for: H ≤ T and H 6= T. We define the ground temporal facts associated to T as follows: Facts(T) def = {©ip | p ∈ Ti}. It is easy to see that H ≤ T iff Facts(H) ⊆ Facts(T).\nGiven T as above, we denote by T|C the sequence of sets {Ti|C}i≥0, where each Ti|C = Ti ∩ At(σ(C), P ), i.e., those atoms from Ti that contain terms exclusively formed with universe elements that are images of syntactic constants in C.\nDefinition 1\nA temporal-here-and-there L-structure with static domains, or a TQHT-structure, is a tuple M = 〈(D, σ),H,T〉 where 〈(D, σ),H〉 and 〈(D, σ),T〉 are two LTLinterpretations satisfying H ≤ T. ⊠\nA TQHT-structure of the form M = 〈(D, σ),T,T〉 is said to be total. If M = 〈(D, σ),H,T〉 is a TQHT-structure and k any positive integer, we denote by (M, k) = 〈(D, σ), (H, k), (T, k)〉 the temporal-here-and-thereL-structure with (H, k) = {Hi}i≥k and (T, k) = {Ti}i≥k. The satisfaction relation for M = 〈(D, σ),H,T〉 is\ndefined recursively forcing us to consider formulas from 〈C ∪D,P 〉. Formally, if ϕ is an L-sentence for the atoms in At(C ∪D,P ), then:\n• If ϕ = p(t1, . . . , tn) ∈ At(C ∪D,P ), then\nM |= p(t1, . . . , tn) iff p(σ(t1), . . . , σ(tn)) ∈ H0.\nM |= t = s iff σ(t) = σ(s)\n• M 6|= ⊥\n• M |= ϕ ∧ ψ iff M |= ϕ and M |= ψ.\n• M |= ϕ ∨ ψ iff M |= ϕ or M |= ψ.\n• M |= ϕ→ ψ iff 〈(D, σ), w,T〉 6|= ϕ or 〈(D, σ), w,T〉 |= ψ for all w ∈ {H,T}\n• M |= ©ϕ if (M, 1) |= ϕ.\n• M |= ϕ if ∀j ≥ 0, (M, j) |= ϕ\n• M |= ♦ϕ if ∃j ≥ 0, (M, j) |= ϕ\n• 〈(D, σ),H,T〉 |= ∀xϕ(x) iff 〈(D, σ), w,T〉 |= ϕ(d) for all d ∈ D and for all\nw ∈ {H,T}.\n• M |= ∃xϕ(x) iff M |= ϕ(d) for some d ∈ D.\nThe resulting logic is called Quantified Temporal Here-and-There Logic with static domains, and denoted by SQTHT or simply by QTHT. It is not difficult to see that, if we restrict to total TQHT-structures, 〈(D, σ),T,T〉 |= ϕ iff 〈(D, σ),T,T〉 |= ϕ in first-order LTL. Furthermore, the following property can be easily checked by structural induction.\nProposition 1\nFor any formula ϕ, if 〈(D, σ),H,T〉 |= ϕ, then:\n〈(D, σ),T,T〉 |= ϕ\nA theory Γ is a set of L-sentences. An interpretation M is a model of a theory\nΓ, written M |= Γ, if it satisfies all the sentences in Γ.\nDefinition 2 (Temporal Equilibrium Model)\nA temporal equilibrium model of a theory Γ is a total model M = 〈(D, σ),T,T〉 of Γ such that there is no H < T satisfying 〈(D, σ),H,T〉 |= Γ. ⊠\nIf M = 〈(D, σ),T,T〉 is a temporal equilibrium model of a theory Γ, we say that the First-Order LTL interpretation 〈(D, σ),T〉 is a temporal stable model of Γ. We write TSM(Γ) to denote the set of temporal stable models of Γ. The set of credulous consequences of a theory Γ, written CredFacts(Γ) contains all the temporal facts that occur at some temporal stable model of Γ, that is:\nCredFacts(Γ) def =\n⋃\n〈(D,σ),T〉∈TSM(Π)\nFacts(T)\nA property of TEL directly inherited from Equilibrium Logic (see Proposition 5\nin (Pearce 2006)) is the following:\nProposition 2 (Cumulativity for negated formulas) Let Γ be some theory and let ¬ϕ be some formula such that M |= ¬ϕ for all temporal equilibrium models of Γ. Then, the theories Γ and Γ ∪ {¬ϕ} have the same set of temporal equilibrium models. ⊠\nIn this work, we will further restrict the study to a syntactic subset called split-\ntable temporal formulas (STF) which will be of one of the following types:\nB ∧N → H (1)\nB ∧©B′ ∧N ∧©N ′ → ©H ′ (2) (B ∧©B′ ∧N ∧©N ′ → ©H ′) (3)\nwhere B and B′ are conjunctions of atomic formulas, N and N ′ are conjunctions of ¬p, being p an atomic formula and H and H ′ are disjunctions of atomic formulas.\nDefinition 3 A splittable temporal logic program (STL-program for short) is a finite set of sentences like\nϕ = ∀x1∀x2 . . . ∀xnψ,\nwhere ψ is a splittable temporal formula with x1, x2, . . . , xn free variables.\nWe will also accept in an STL-program an implication of the form (B∧N → H) (that is, containing but not any ©) understood as an abbreviation of the pair of STL-formulas:\nB ∧N → H\n(©B ∧©N → ©H)\nExample 2 The following theory Π2 is an STL-program:\n¬p → q (4)\nq ∧ ¬© r → ©p (5)\n(q ∧ ¬© p → ©q) (6)\n(r ∧ ¬© p → ©r ∨©q) (7)\nFor an example including variables, the encoding of Example 1 in Figure 2 is also\nan STL-program Π1 whose logical representation corresponds to:\n( Driveto(x, a) → ©At(x, a) ) (8)\n( At(x, a) ∧Road(a, b) → Driveto(x, b) ∨NoDriveto(x, b) ) (9)\n( At(x, a) ∧ ¬©NoAt(x, a) → ©At(x, a) ) (10)\n( At(x, b) ∧ City(a) ∧ a 6= b → NoAt(x, a) ) (11)\n( At(x, a) ∧ At(x, b) ∧ a 6= b → ⊥ ) (12)\nRemember that all rule variables are implicitly universally quantified. For simplicity, we assume that inequality is a predefined predicate.\nAn STL-program is said to be positive if for all rules (1)-(3), N and N ′ are empty (an empty conjunction is equivalent to ⊤). An STL-program is said to be normal if it contains no disjunctions, i.e., for all rules (1)-(3), H and H ′ are atoms.\nGiven a propositional combination ϕ of temporal facts with ∧,∨,⊥,→, we denote ϕi as the formula resulting from replacing each temporal fact A in ϕ by ©iA. For a formula r = ϕ like (3), we denote by ri the corresponding ϕi. For instance, (6) i = (©iq ∧ ¬©i+1 p → ©i+1q). As © behaves as a linear operator in THT, in fact F i ↔ ©iF is a THT tautology.\nDefinition 4 (expanded program) Given an STL-program Π for signature At we define its expanded program Π∞ as the infinitary logic program containing all rules of the form (1), (2) in Π plus a rule ri per each rule r of the form (3) in Π and each integer value i ≥ 0. ⊠\nThe program Π∞2 consists of (4), (5) plus the infinite set of rules:\n©iq ∧ ¬©i+1 p → ©i+1q ©ir ∧ ¬©i+1 p → ©i+1r ∨©i+1q\nfor i ≥ 0. We can interpret the expanded program as an infinite, non-temporal program where the signature is the infinite set of atoms {©ip | p ∈ At, i ≥ 0}.\nTheorem 1 (Theorem 1 in (Aguado et al. 2011)) 〈T,T〉 is a temporal equilibrium model of Π iff {©ip | p ∈ Ti, i ≥ 0} is a stable model of Π∞ under the (infinite) signature {©ip | p ∈ At}. ⊠\nProposition 3 Any normal positive STL-programΠ has a unique temporal stable model 〈(D, σ),T〉 which coincides with its ≤-least LTL-model. We denote LM(Π) = Facts(T). ⊠"
    }, {
      "heading" : "4 Safe Variables and Domain Independence",
      "text" : "In this section we consider a definition of safe variables for temporal programs that removes the reference to static predicates.\nDefinition 5 A splittable temporal formula ϕ of type (1), (2) or (3) is said to be safe if, for any variable x occurring in ϕ, there exists an atomic formula p in B or B′ such that x occurs in p. A formula ∀x1∀x2 . . .∀xnψ is safe if the splittable temporal formula ψ is safe.\nFor instance, rules (8)-(12) are safe. A simple example of an unsafe rule is the splittable temporal formula:\n⊤ → p(x) (13)\nwhere x does not occur in the positive body. Although an unsafe rule does not always lead to lack of domain independence (see examples in (Cabalar et al. 2009)) it is frequently the case. We prove next that domain independence is, in fact, guaranteed for safe STL-programs.\nTheorem 2 If ϕ is a safe sentence and 〈(D, σ),T,T〉 is a temporal equilibrium model of ϕ, then T|C = T and Ti ⊆ At(σ(C), P ) for any i ≥ 0.\nLet (D, σ) be a domain and D′ ⊆ D a finite subset; the grounding over D′ of a\nsentence ϕ, denoted by GrD′(ϕ), is defined recursively\nGrD′(p) def = p, where p denotes any atomic formula\nGrD′(ϕ1 ⊙ ϕ2) def = GrD′(ϕ1)⊙GrD′(ϕ2),\nwith ⊙ any binary operator in {∧,∨,→}\nGrD′(∀xϕ(x)) def =\n∧\nd∈D′ GrD′ϕ(d)\nGrD′(∃xϕ(x)) def =\n∨\nd∈D′ GrD′ϕ(d)\nGrD′(©ϕ) def = ©GrD′(ϕ)\nGrD′( ϕ) def = GrD′(ϕ) GrD′(♦ϕ) def = ♦GrD′(ϕ)\nTheorem 3 (Domain independence) Let ϕ be safe splittable temporal sentence. Suppose we expand the language L by considering a set of constants C′ ⊇ C. A total QTHT-model 〈(D, σ),T,T〉 is a temporal equilibrium model of GrC′(ϕ) if and only if it is a temporal equilibrium model of GrC(ϕ)."
    }, {
      "heading" : "5 Derivable ground facts",
      "text" : "In this section we present a technique for grounding safe temporal programs based on the construction of a positive normal ASP program with variables. The method is based on the idea of derivable ground temporal facts for an STL-program Π. This set, call it ∆, will be an upper estimation of the credulous consequences of the program, that is, CredFacts(Π) ⊆ ∆. Of course, the ideal situation would be that ∆ = CredFacts(Π), but the set CredFacts(Π) requires the temporal stable models of Π and these (apart from being infinite sequences) will not be available at grounding time. In the worst case, we could choose ∆ to contain the whole set of possible temporal facts, but this would not provide relevant information to improve grounding. So, we will try to obtain some superset of CredFacts(Π) as small as possible, or if preferred, to obtain the largest set of non-derivable facts we can find. Note that a non-derivable fact ©ip 6∈ ∆ satisfies that ©ip 6∈ CredFacts(Π) and so, by Proposition 2, Π∪{¬©i p} is equivalent to Π, that is, both theories have the same set of temporal equilibrium models. This information can be used to simplify the ground program either by removing rules or literals.\nWe begin defining several transformations on STL-programs. For any temporal\nrule r, we define r∧ as the set of rules:\n• If r has the form (1) then r∧ def = {B → p | atom p occurs in H} • If r has the form (2) then r∧ def = {B ∧©B′ → ©p | atom p occurs in H ′} • If r has the form (3) then r∧ def = { (B ∧©B′ → ©p) | atom p occurs in H ′}\nIn other words, r∧ will imply all the original disjuncts in the disjunctive head of r. It is interesting to note that for any rule r with an empty head (⊥) this definition implies r∧ = ∅. Program Π∧ is defined as the union of r∧ for all rules r ∈ Π. As an example, Π∧2 consists of the rules:\n⊤ → q\nq → ©p\n(q → ©q) (r → ©r)\n(r → ©q)\nwhereas Π∧1 would be the program:\n( Driveto(x, a) → ©At(x, a) ) (14)\n( At(x, a) ∧Road(a, b) → Driveto(x, b) ) (15)\n( At(x, a) ∧Road(a, b) → NoDriveto(x, b) ) (16)\n( At(x, a) → ©At(x, a) ) (17)\n( At(x, b) ∧ City(a) ∧ a 6= b → NoAt(x, a) ) (18)\nNotice that, by definition, Π∧ is always a positive normal STL-program and, by\nProposition 3, it has a unique temporal stable model, LM(Π∧).\nProposition 4 For any STL-program Π, CredFacts(Π) ⊆ LM(Π∧). ⊠\nUnfortunately, using ∆ = LM(Π∧) as set of derivable facts is unfeasible, since it contains infinite temporal facts corresponding to an “infinite run” of the transition system described by Π∧. Instead, we will adopt a compromise solution taking a superset of LM(Π∧) extracted from a new theory, ΓΠ. This theory will collapse all the temporal facts from situation 2 on, so that all the states Ti for i ≥ 2 will be repeated4. We define ΓΠ as the result of replacing each rule (B ∧©B′ → ©p) in Π∧ by the formulas:\nB ∧©B′ → ©p (19) ©B ∧©2B′ → ©2p (20) ©2B ∧©2B′ → ©2p (21)\nand adding the axiom schema:\n©2 (p↔ ©p) (22)\nfor any ground atom p ∈ At(D,P ) in the signature of Π. As we can see, (19) and (20) are the first two instances of the original rule (B∧©B′ → ©p) corresponding to situations i = 0 and i = 1. Formula (21), however, differs from the instance we\n4 Note that rules of the form (1) and (2) are not in the scope of and so may provide an irregular behaviour for atoms at situations 0 and 1. In a theory only consisting of rules like (3) we could collapse all situations from i = 0 on since they would follow a regular pattern.\nwould get for i = 2 since, rather than having©3B′ and©3p, we use©2B′ and©2p respectively. This can be done because axiom (22) is asserting that from situation 2 on all the states are repeated.\nIn the cars example, for instance, (14) from Π∧1 would yield the three rules:\nDriveto(x, a) → ©At(x, a)\n©Driveto(x, a) → ©2At(x, a) ©2Driveto(x, a) → ©2At(x, a)\nIt is not difficult to see that axiom (22) implies that checking that some M is a temporal equilibrium model of ΓΠ is equivalent to checking that {©ip | p ∈ Ti , i = 0, 1, 2} is a stable model of ΓΠ \\ {(22)} and fixing Ti = T2 for i ≥ 3. This allows us to exclusively focus on the predicate extents in T0, T1 and T2, so we can see the\n-free program ΓΠ \\ {(22)} as a positive normal ASP (i.e., non-temporal) program for the propositional signature {p,©p,©2p | p ∈ At(D,P )} that can be directly fed to an ASP grounder, after some simple renaming conventions.\nTheorem 4 ΓΠ has a least LTL-model, LM(ΓΠ) which is a superset of LM(Π ∧).\nIn other words CredFacts(Π) ⊆ LM(Π∧) ⊆ LM(ΓΠ) = ∆, i.e., we can use LM(ΓΠ) as set of derivable facts and simplify the ground program accordingly. To this aim, a slight adaptation is further required. Each rule in Π like (3) has the form\nα and any predicate p in α is implicitly affected (Theorem 1) by the extension of ©2p in LM(ΓΠ). In order to properly ground the extensions for p,©p and ©2p we replace each α by the equivalent conjunction of the three rules α, ©α and\n©2 α. For instance, (9) would be replaced by:\nAt(x, a) ∧Road(a, b) → Driveto(x, b) ∨NoDriveto(x, b) (23)\n©At(x, a) ∧©Road(a, b) → ©Driveto(x, b)\n∨©NoDriveto(x, b) (24)\n( ©2At(x, a) ∧©2Road(a, b) → ©2Driveto(x, b)\n∨©2 NoDriveto(x, b) ) (25)\nand then check the possible extents for the positive bodies we get from the set of derivable facts ∆ = LM(ΓΠ). For example, for the last rule, we can make substitutions for x, a and b using the extents of ©2At(x, a) and ©2Road(a, b) we have in ∆. However, this still means making a join operation for both predicates. We can also use the ASP grounder for that purpose by just adding a rule that has as body, the positive body of the original temporal rule r, and as head, a new auxiliary predicate Substr(x, a, b) referring to all variables in the rule. In the example, for rule (25) we would include in our ASP program:\n©2At(x, a) ∧©2Road(a, b) → Subst(25)(x, a, b)\nIn this way, each tuple of Substr(x1, . . . , xn) directly points out the variable\nsubstitution to be performed on the temporal rule.\nFor instance, in the small instance case described of our example (2 cars and 6\ncities) we reduce the number of generated ground rules in the scope of ‘ ’ from 160 using the previous STeLP grounding method to 62. The reader may easily imagine that the higher degree of cities interconnection, the smaller obtained reduction of rule instances. Although an exhaustive experimentation is still ongoing work, a reduction of this kind is very promising. In our initial experiments, the grounding performed on ΓΠ (whose generation is polynomial) does not constitute a significant time increase, whereas the computation of temporal stable models is drastically improved by the reduction of ground rules5."
    }, {
      "heading" : "6 Conclusions",
      "text" : "We have improved the grounding method for temporal logic programs with variables in different ways. First, we provided a safety condition that directly corresponds to extrapolating the usual concept of safe variable in ASP. In this way, any variable occurring in a rule is considered to be safe if it also occurs in the positive body of the rule, regardless the possible scope of temporal operators and removing the previous dependence on the use of static predicates.\nWe have proved that this safety condition suffices to guarantee the property of domain independence by which computing the (temporal) stable models is insensitive to the possible addition of new arbitrary constants to the universe.\nWe have also designed a method for grounding the temporal logic program that consists in constructing a non-temporal normal positive program with variables that is fed to an ASP solver to directly obtain the set of variable substitutions to be performed for each rule. The proposed method allows reducing in many cases the number of ground temporal rules generated as a result.\nThe current note contains formal results, providing the correctness (with respect to domain independence) of the safety condition and the method for grounding safe programs. Regarding implementation, a stand-alone prototype for proving examples like the one in the paper has been constructed, showing promising results. The immediate next step is incorporating the new grounding method inside STeLP and analysing its performance on benchmark scenarios.\nAcknowledgements This research was partially supported by Spanish MINECO project TIN2013-42149-P and Xunta de Galicia GPC 2013/070."
    }, {
      "heading" : "Appendix. Proofs",
      "text" : "Proof of Proposition 3. Consider the expanded program Π∞. This is an infinitary positive (non-temporal) logic program. Using the well-known results by (van Emden and Kowalski 1976), we know it has a least Herbrand model LM(Π∞) call it I, which may contain an infinite set of atoms in the signature of ground temporal facts {©ip | p ∈ At, i ≥ 0}, where At is the original signature of Π. Furthermore, as Π∞ is positive, its unique stable model is precisely I. Given any set of ground temporal facts I we can establish a one-to-one correspondence to an LTL-interpretation I with Facts(I) = I. By Theorem 1, J is a stable model of Π∞ iff J, with Facts(J) = J is a temporal stable model of Π. Finally, as I is the unique stable model of Π∞ we get that I is the only temporal stable model of Π. ⊠\nA variable assignment µ in (D, σ) is a mapping from the set of variables to D. If ϕ ∈ L has free-variables, ϕµ is the closed formula obtained by replacing every free variable x by µ(x).\nLemma 1\nLet ϕ be a splittable temporal formula and µ a variable assignment in (D, σ). If ϕ is safe, then if follows that:\n〈(D, σ),T,T〉 |= ϕµ implies 〈(D, σ),T|C ,T〉 |= ϕ µ."
    }, {
      "heading" : "Proof",
      "text" : "First of all, take ϕ = B ∧N → H of type (1) and suppose that 〈T,T〉 |= ϕµ but 〈T|C ,T〉 6|= ϕµ. This means that 〈T|C ,T〉 |= Bµ ∧Nµ and 〈T|C ,T〉 6|= Hµ. Since 〈T,T〉 |= Hµ, there exists an atomic formula q in H such that 〈T,T〉 |= qµ but 〈T|C ,T〉 6|= qµ. So we have a variable x in q with µ(x) 6∈ σ(C). As ϕ is safe, we know that x occurs in an atomic formula p in B. Then 〈T|C ,T〉 6|= pµ and 〈T|C ,T〉 6|= Bµ which yields a contradiction.\nIf ϕ is of type (2), we use a similar argument. Finally, take ϕ = (B ∧ ©B′ ∧ N ∧ ©N ′ → ©H ′) = ψ of type (3) and suppose that 〈T,T〉 |= ϕµ but 〈T|C ,T〉 6|= ϕ µ. There exists i ≥ 0 such that 〈Ti, Ti〉 |= ψµ and 〈Ti ∩ σ(C), Ti〉 6|= ψµ. We then have that 〈Ti ∩ σ(C), Ti〉 |= Bµ ∧ (©B′)µ ∧Nµ ∧ (©N ′)µ and 〈Ti ∩ σ(C), Ti〉 6|= (©H ′)µ. Using that ϕ is safe and the same argument as above, we find an atomic formula p in B or B′ such that 〈Ti ∩ σ(C), Ti〉 6|= pµ which implies 〈Ti ∩ σ(C), Ti〉 6|= Bµ ∧ (©B′)µ and leads to contradiction. The other implication follows directly from Proposition 1.\nProposition 5\nFor any safe sentence ϕ = ∀x1∀x2 . . . ∀xnψ\n〈(D, σ),T,T〉 |= ϕ iff 〈(D, σ),T|C ,T〉 |= ϕ."
    }, {
      "heading" : "Proof",
      "text" : "Proceed by induction over the length of the prefix. If n = 0, we can take any µ assignment of variables and apply Lemma 1 on ϕ = ϕµ . So take ϕ = ∀x1 . . .∀xnψ of length n and suppose that the result is true for any universal safe sentence whose prefix has length at most n − 1. If 〈(D, σ),T,T〉 |= ϕ, put ϕ = ∀x1α(x1) with α(x1) = ∀x2 . . .∀xnψ. For any d ∈ D, we know that 〈(D, σ),T,T〉 |= α(d) and we have to show that 〈(D, σ),T|C ,T〉 |= α(d). The induction hypothesis and the fact that α(d) is a safe sentence whose prefix has length smaller or equal than n − 1 finishes the proof.\nProof of Theorem 2. If ϕ is a safe sentence and 〈(D, σ),T,T〉 is a temporal equilibrium model of ϕ, we have that 〈(D, σ),T|C ,T〉 |= ϕ by Proposition 5. The definition of temporal equilibrium model implies that T|C = T and Ti ⊆ At(σ(C), P ) for any i ≥ 0. ⊠\nLemma 2 Let ϕ(x) be a safe splittable temporal formula of type (1), (2) or (3) and take 〈(D, σ),H,T〉 be such that T = T|C . Then, for any d ∈ D \\ σ(C) we have:\n〈(D, σ),H,T〉 |= ϕ(d)."
    }, {
      "heading" : "Proof",
      "text" : "First of all, suppose that ϕ(x) is of type (1):\nB ∧N → H\nand take d ∈ D \\ σ(C) and w ∈ {H,T} such that 〈(D, σ), w,T〉 6|= ϕ(d). This implies that 〈(D, σ), w,T〉 |= B(d) ∧N(d) but 〈(D, σ), w,T〉 6|= H(d). ϕ(x) is safe so there must be an atom p in B such that x has an occurrence in p. Since T0 ⊆ At(σ(C), P ), it is clear that 〈(D, σ), w,T〉 6|= p(d), so 〈(D, σ), w,T〉 6|= B(d) which yields a contradiction.\nThe proof for the case of ϕ(x) being of type (2) and (3) is similar.\nLemma 3 Let ϕ(x) = ∀x1∀x2 . . . ∀xnψ with ψ a splittable temporal formula and such that ϕ(x) has no other free variables than x. Let M = 〈(D, σ),H,T〉 be such that T = T|C . Then, if ∀xϕ(x) is safe, we have that:\nM |= ∀xϕ(x) iff M |= ∧\nc∈C ϕ(c)."
    }, {
      "heading" : "Proof",
      "text" : "From left to right, just note that if M |= ∀xϕ(x) but M 6|= ϕ(c), for some c ∈ C, we would have that M 6|= ϕ(σ(c)) which would yield a contradiction.\nFor right to left, we can proceed by induction in n. If n = 0, then ϕ(x) is in the case of the previous lemma for any d ∈ D \\ σ(C), so M |= ∀xϕ(x) whenever M |= ∧\nc∈C ϕ(c). Now, suppose the result is true for any prenex formula\nwith length up to n − 1 and take ϕ(x) = ∀x1∀x2 . . . ∀xnψ(x, x1, . . . , xn) such that\nM |= ∧\nc∈C ϕ(c). It only rests to show that M |= ϕ(d) for any d ∈ D \\σ(C). Notice\nthat ϕ(d) = ∀x1α(x1) with α(x1) = ∀x2 . . . ∀xnψ(d, x1, x2, . . . , xn). Since we can apply the induction hypothesis on α(x1), it will be sufficient to prove that:\nM |= ∧\nc∈C α(c).\nNow fix any c ∈ C and take into account that\nM |= ϕ(c′) = ∀x1∀x2 . . . ∀xnψ(c ′, x1, x2 . . . , xn)\nfor all c′ ∈ C, so we can replace x1 by any constant in C, including c, and so:\nM |= ∀x2 . . . ∀xnψ(c ′, c, x2, . . . , xn), for any c ′ ∈ C\nObserve that we can apply the induction hypothesis on β(z), where\nβ(z) = ∀x2 . . . ∀xnψ(z, c, x2, . . . , xn)\nand then M |= ∀zβ(z). In particular M |= β(d) which completes the proof since β(d) = α(c).\nThe following proposition can be easily proved\nProposition 6 Given any D 6= ∅: 〈(D, σ),H,T〉 |= ϕ iff 〈(D, σ),H,T〉 |= GrD(ϕ). ⊠\nTheorem 5 If ϕ = ∀x1∀x2 . . . ∀xnψ is a safe splittable temporal sentence andM = 〈(D, σ),H,T〉 such that T = T|C , then\nM |= ϕ iff M |= GrC(ϕ)."
    }, {
      "heading" : "Proof",
      "text" : "From left to right, suppose that M |= ϕ. By Proposition 6, we know that M |= GrD(ϕ). The result follows since σ(C) ⊆ D and GrC(ϕ) = Grσ(C)(ϕ).\nNow, from the right to left direction, take ϕ = ∀x1∀x2 . . . ∀xnψ a safe splittable temporal sentence and suppose that M |= GrC(ϕ). Again, we can proceed by induction in n. If n = 0, then ϕ is quantifier free so GrC(ϕ) = ϕ. Suppose the result is true for any safe splittable sentence with length up to n−1 and put ϕ = ∀x1α(x1) with α(x1) = ∀x2 . . . ∀xnψ(x1, x2, . . . , xn). Notice that α(x1) is a safe formula that has no more free variables than x1, so, if we apply Lemma 3, it will be sufficient to show that M |= ∧\nc∈C α(c). Since we are supposing that\nM |= GrC(ϕ) = ∧ c∈C GrC(α(c)),\nand we can apply the induction hypothesis on any α(c) with c ∈ C, it follows that M |= ∧\nc∈C α(c) and this completes the proof.\nTheorem 6 If ϕ is a safe splittable temporal sentence, then 〈(D, σ),T,T〉 is a temporal equilibrium model of ϕ iff 〈(D, σ),T,T〉 is a temporal equilibrium model of GrC(ϕ)."
    }, {
      "heading" : "Proof",
      "text" : "Suppose that 〈(D, σ),T,T〉 is a temporal equilibrium model of ϕ and 〈(D, σ),H,T〉 |= GrC(ϕ). Since ϕ is safe, we know by Theorem 2 that T = T|C so, applying Theorem 5, it follows that 〈(D, σ),H,T〉 |= ϕ and H = T. This shows that 〈(D, σ),T,T〉 is also a temporal equilibrium model of GrC(ϕ), The other implication follows directly from the fact that 〈(D, σ),H,T〉 |= ϕ implies 〈(D, σ),H,T〉 |= GrC(ϕ).\nProof of Theorem 3. Let us show that the following assertions are equivalent:\n1. 〈(D, σ),T,T〉 is a temporal equilibrium model of GrC(ϕ) 2. 〈(D, σ),T,T〉 is a temporal equilibrium model of ϕ 3. 〈(D, σ),T,T〉 is a temporal equilibrium model of GrC′(ϕ)\nTaking into account the previous theorem, we only have to prove the equivalence of 2 and 3. Suppose that 〈(D, σ),T,T〉 is a temporal equilibrium model of ϕ and 〈(D, σ),H,T〉 |= GrC′(ϕ). Because of Theorem 2, we have that T = T|C ⊆ T|C′ and an obvious extension of Theorem 5 to C′, implies that\n〈(D, σ),H,T〉 |= ϕ\nand so H = T. This shows that 2 implies 3. The other implication (3. =⇒ 2.) follows directly. ⊠\nLemma 4 If T is any equilibrium model of a (non temporal) program Π with rules of type (1), then T ⊆ J , where J is any model of the normal positive program Π∧."
    }, {
      "heading" : "Proof",
      "text" : "We will prove that 〈T ∩ J, T 〉 |= Π, and so, T ∩ J = T by the minimality of T .\nLet B∧N → H of the form (1) be an arbitrary rule in Π. To prove 〈T ∩J, T 〉 |= r we already know that 〈T, T 〉 |= r and remain to prove that if 〈T ∩ J, T 〉 |= B ∧N then 〈T ∩ J, T 〉 |= H . So, suppose that 〈T ∩ J, T 〉 |= B ∧N . Then 〈T, T 〉 |= B ∧N y 〈J, J〉 |= B. Therefore, 〈T, T 〉 |= H and there exists p ∈ H such that 〈T, T 〉 |= p. Since rule B → p ∈ Π∧ and 〈J, J〉 |= B, we get that 〈J, J〉 |= p and so 〈T ∩ J, T 〉 |= H , as we wanted to prove.\nGiven any rule like r like (2) of (3) and a set of atoms X , we define its simplifi-\ncation simp(r,X) as:\nsimp(r,X) def =\n{\n©B′ ∧©N ′ → ©H ′ if B ⊆ X and N ∩X = ∅ ⊤ otherwise\nDefinition 6 (Slice program) Given some LTL interpretation T, let us define now the sequence of programs:\nslice(Π,T, 0) def = Π0 = ini0(Π) slice(Π,T, 1) def = {simp(r, T0) | r ∈ ini1(Π) ∪ dyn(Π)}\nslice(Π,T, i+ 1) def = {©isimp(r, Ti) | r ∈ dyn(Π)} for i ≥ 1\n⊠\nTheorem 7 (Theorem 3 in (Aguado et al. 2011)) Let 〈T,T〉 be a model of a splittable TLP Π. 〈T,T〉 is a temporal equilibrium model of Π iff\n(i) T0 = T0 is a stable model of slice(Π,T, 0) = Π 0 = ini0(Π) and\n(ii) (T1 \\At0) is a stable model of slice(Π,T, 1) and\n(iii) (Ti \\Ati−1) is a stable model of slice(Π,T, i) for i ≥ 2. ⊠\nProof of Proposition 4. Let 〈T,T〉 be any temporal equilibrium model of Π an denote by {Li}i≥0 the corresponding infinite sequence of ground atoms of LM(Π∧). By Theorem 7, we know that, for all i ≥ 0, Ti (resp. Li) is a stable model of slice(Π,T, i) (resp. of slice(Π∧, LM(Π∧), i). Finally, we can apply Lemma 4 and the fact that slice(Π,T, 0)∧ = slice(Π∧, LM(Π∧), 0) and, for i ≥ 1,\nslice(Π,T, i)∧ ⊆ slice(Π∧, LM(Π∧), i).\n⊠\nProof of Theorem 4. Let 〈T,T〉 be the unique temporal equilibrium model of Π∧ and let 〈D,D〉 denote the temporal interpretation defined by:\n• Di = Ti if 0 ≤ i ≤ 1, • D2 is the stable model of the positive non-disjunctive program:\n{©2B ∧©2B′ → ©2p | (B ∧©B′ → ©p) ∈ dyn(Π∧)} ∪ slice(Π∧, L, 1)\n• Di = D2 if ≥ 3,\nIt is straightforward to check that 〈D,D〉 is a temporal equilibrium model of ΓΠ. Notice that T2 ⊆ D2. This follows from Lemma 4 and the facts that T2 \\ AT 1 is the stable model of slice(Π∧, L, 1) and D2 is a model of this latter program.\nThe cases i = 0, 1, 2 follow from Proposition 4 an the fact that T2 ⊆ D2. When i ≥ 3, we shall prove that 〈Ti \\Ati−1 ∩Di \\Ati−1,Ti \\Ati−1〉 is a model of slice(Π∧,T, i) so by Theorem 7, Ti \\ Ati−1 ∩ Di \\ Ati−1 = Ti \\ Ati−1 and, consequently, Ti ⊆ Di. So, take ©iB′ → ©iH ′ ∈ slice(Π∧,T, i) and suppose that\n〈Ti \\Ati−1 ∩Di \\Ati−1,Ti \\Ati−1〉 |= ©iB′\nThis fact implies that 〈Ti \\ Ati−1,Ti \\ Ati−1〉 |= ©iB′ and also that there exists a (positive normal) dynamic rule like (3) such that B ⊆ Ti−1 ⊆ Di−1. Since 〈Ti \\ Ati−1,Ti \\ Ati−1〉 is a model of slice(Π∧,T, i), the only atom p ∈ H ′ satisfies 〈Ti \\ Ati−1,Ti \\ Ati−1〉 |= ©ip. It only rests to show that 〈Di,Di〉 |= ©ip or equivalently 〈D,D〉 |= ©2p (notice that Di = D2 if i ≥ 2). Finally, we can use that the rule ©2B ∧©2B′ → ©2p ∈ ΓΠ and also the fact that 〈D,D〉 |= ©2B ∧©2B′ because i ≥ 3 and B′ ⊆ Di = D2 and B ⊆ Tı−1 ⊆ Di−1 = D2. ⊠"
    } ],
    "references" : [ {
      "title" : "Strongly equivalent temporal logic programs",
      "author" : [ "F. Aguado", "P. Cabalar", "G. Pérez", "C. Vidal" ],
      "venue" : "JELIA’08. Lecture Notes in Computer Science, vol. 5293. Springer, 8–20.",
      "citeRegEx" : "Aguado et al\\.,? 2008",
      "shortCiteRegEx" : "Aguado et al\\.",
      "year" : 2008
    }, {
      "title" : "Loop formulas for splitable temporal logic programs",
      "author" : [ "F. Aguado", "P. Cabalar", "G. Pérez", "C. Vidal" ],
      "venue" : "LPNMR’11, J. P. Delgrande and W. Faber, Eds. Lecture Notes in Computer Science, vol. 6645. Springer, 80–92.",
      "citeRegEx" : "Aguado et al\\.,? 2011",
      "shortCiteRegEx" : "Aguado et al\\.",
      "year" : 2011
    }, {
      "title" : "On the complexity of temporal equilibrium logic",
      "author" : [ "L. Bozzelli", "D. Pearce" ],
      "venue" : "Proc. of the 30th Annual ACM/IEEE Symp. on Logic in Computer Science, (LICS’15). IEEE Computer Society, 645–656.",
      "citeRegEx" : "Bozzelli and Pearce,? 2015",
      "shortCiteRegEx" : "Bozzelli and Pearce",
      "year" : 2015
    }, {
      "title" : "Normal form nested programs",
      "author" : [ "A. Bria", "W. Faber", "N. Leone" ],
      "venue" : "Proc. of the 11th European Conference on Logics in Artificial Intelligence (JELIA’08), S. H. et al, Ed. Lecture Notes in Artificial Intelligence. Springer, 76–88.",
      "citeRegEx" : "Bria et al\\.,? 2008",
      "shortCiteRegEx" : "Bria et al\\.",
      "year" : 2008
    }, {
      "title" : "STELP - a tool for temporal answer set programming",
      "author" : [ "P. Cabalar", "M. Diéguez" ],
      "venue" : "LPNMR’11. Lecture Notes in Computer Science, vol. 6645. Springer, 370–375.",
      "citeRegEx" : "Cabalar and Diéguez,? 2011",
      "shortCiteRegEx" : "Cabalar and Diéguez",
      "year" : 2011
    }, {
      "title" : "A revised concept of safety for general answer set programs",
      "author" : [ "P. Cabalar", "D. Pearce", "A. Valverde" ],
      "venue" : "Proc. of the 10th Int. Conf. Logic Programming and Nonmonotonic Reasoning (LPNMR’09). Lecture Notes in Computer Science, vol. 5753. Springer, 58–70.",
      "citeRegEx" : "Cabalar et al\\.,? 2009",
      "shortCiteRegEx" : "Cabalar et al\\.",
      "year" : 2009
    }, {
      "title" : "ASP-core-2 input language format",
      "author" : [ "F. Calimeri", "W. Faber", "M. Gebser", "G. Ianni", "R. Kaminski", "T. Krennwallner", "N. Leone", "F. Ricca", "T. Schaub" ],
      "venue" : "https://www.mat.unical.it/aspcomp2013/files/ASP-CORE-2.03c.pdf.",
      "citeRegEx" : "Calimeri et al\\.,? 2015",
      "shortCiteRegEx" : "Calimeri et al\\.",
      "year" : 2015
    }, {
      "title" : "Advances in gringo series",
      "author" : [ "M. Gebser", "R. Kaminski", "A. König", "T. Schaub" ],
      "venue" : null,
      "citeRegEx" : "Gebser et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2011
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Logic Programming: Proc. of the Fifth International Conference and Symposium (Volume 2), R. A. Kowalski and K. A. Bowen, Eds. MIT Press, Cambridge, MA, 1070–1080.",
      "citeRegEx" : "Gelfond and Lifschitz,? 1988",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1988
    }, {
      "title" : "The dlv system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7, 499–562.",
      "citeRegEx" : "Leone et al\\.,? 2006",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2006
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V. Marek", "M. Truszczyński" ],
      "venue" : "Springer-Verlag, 169–181.",
      "citeRegEx" : "Marek and Truszczyński,? 1999",
      "shortCiteRegEx" : "Marek and Truszczyński",
      "year" : 1999
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 241–273.",
      "citeRegEx" : "Niemelä,? 1999",
      "shortCiteRegEx" : "Niemelä",
      "year" : 1999
    }, {
      "title" : "A new logical characterisation of stable models and answer sets",
      "author" : [ "D. Pearce" ],
      "venue" : "Non monotonic extensions of logic programming. Proc. NMELP’96. (LNAI 1216). SpringerVerlag.",
      "citeRegEx" : "Pearce,? 1996",
      "shortCiteRegEx" : "Pearce",
      "year" : 1996
    }, {
      "title" : "Equilibrium logic",
      "author" : [ "D. Pearce" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 47, 1-2, 3–41.",
      "citeRegEx" : "Pearce,? 2006",
      "shortCiteRegEx" : "Pearce",
      "year" : 2006
    }, {
      "title" : "The temporal logic of programs",
      "author" : [ "A. Pnueli" ],
      "venue" : "18th Annual Symposium on Foundations of Computer Science. IEEE Computer Society Press, 46–57.",
      "citeRegEx" : "Pnueli,? 1977",
      "shortCiteRegEx" : "Pnueli",
      "year" : 1977
    }, {
      "title" : "The semantics of predicate logic as a programming language",
      "author" : [ "M.H. van Emden", "R.A. Kowalski" ],
      "venue" : "Journal of the ACM",
      "citeRegEx" : "Emden and Kowalski,? \\Q1976\\E",
      "shortCiteRegEx" : "Emden and Kowalski",
      "year" : 1976
    }, {
      "title" : "Theorem 7 (Theorem 3 in (Aguado et al. 2011)) Let 〈T,T〉 be a model of a splittable TLP Π. 〈T,T〉 is a temporal equilibrium model of Π",
      "author" : [ "F. Aguado", "P. Cabalar", "M. Diéguez", "G. Pérez", "C. Vidal" ],
      "venue" : null,
      "citeRegEx" : "Aguado et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Aguado et al\\.",
      "year" : 2011
    } ],
    "referenceMentions" : [ {
      "referenceID" : 11,
      "context" : "Many application domains and example scenarios from Answer Set Programming (ASP) (Niemelä 1999; Marek and Truszczyński 1999) contain a dynamic component, frequently representing transition systems over discrete time.",
      "startOffset" : 81,
      "endOffset" : 124
    }, {
      "referenceID" : 10,
      "context" : "Many application domains and example scenarios from Answer Set Programming (ASP) (Niemelä 1999; Marek and Truszczyński 1999) contain a dynamic component, frequently representing transition systems over discrete time.",
      "startOffset" : 81,
      "endOffset" : 124
    }, {
      "referenceID" : 0,
      "context" : "In an attempt to provide a full logical framework for temporal reasoning in ASP, (Aguado et al. 2008) proposed a formalism called Temporal Equilibrium Logic (TEL), syntactically identical to propositional Linear-time Temporal Logic (LTL) (Pnueli 1977), but semantically relying on a temporal extension of Equilibrium Logic (Pearce 1996), the most",
      "startOffset" : 81,
      "endOffset" : 101
    }, {
      "referenceID" : 14,
      "context" : "2008) proposed a formalism called Temporal Equilibrium Logic (TEL), syntactically identical to propositional Linear-time Temporal Logic (LTL) (Pnueli 1977), but semantically relying on a temporal extension of Equilibrium Logic (Pearce 1996), the most",
      "startOffset" : 142,
      "endOffset" : 155
    }, {
      "referenceID" : 12,
      "context" : "2008) proposed a formalism called Temporal Equilibrium Logic (TEL), syntactically identical to propositional Linear-time Temporal Logic (LTL) (Pnueli 1977), but semantically relying on a temporal extension of Equilibrium Logic (Pearce 1996), the most",
      "startOffset" : 227,
      "endOffset" : 240
    }, {
      "referenceID" : 8,
      "context" : "general and best studied logical characterisation of stable models (Gelfond and Lifschitz 1988).",
      "startOffset" : 67,
      "endOffset" : 95
    }, {
      "referenceID" : 1,
      "context" : "In (Aguado et al. 2011) a reduction of (propositional) TEL into regular LTL was presented, but applicable to a subclass of temporal theories called splittable Temporal Logic Programs.",
      "startOffset" : 3,
      "endOffset" : 23
    }, {
      "referenceID" : 4,
      "context" : "The reduction was implemented in a tool, STeLP (Cabalar and Diéguez 2011), that computes the temporal stable models of a given program, that are shown as a Büchi automaton.",
      "startOffset" : 47,
      "endOffset" : 73
    }, {
      "referenceID" : 1,
      "context" : "Although the approach in (Aguado et al. 2011) was exclusively propositional, the input language of STeLP was extended with variables.",
      "startOffset" : 25,
      "endOffset" : 45
    }, {
      "referenceID" : 3,
      "context" : "Last, but not least, the treatment of variables had no formal background and had not been proved to be sound with respect to the important property of domain independence (Bria et al. 2008) – essentially, a program is domain independent when its stable models do not vary under the arbitrary addition of new constants.",
      "startOffset" : 171,
      "endOffset" : 189
    }, {
      "referenceID" : 9,
      "context" : "org/stelp_online 2 This definition of safety, initially introduced in DLV (Leone et al. 2006) has been adopted in the standard ASP-Core-2 (Calimeri et al.",
      "startOffset" : 74,
      "endOffset" : 93
    }, {
      "referenceID" : 6,
      "context" : "2006) has been adopted in the standard ASP-Core-2 (Calimeri et al. 2015) and also followed by Gringo (Gebser et al.",
      "startOffset" : 50,
      "endOffset" : 72
    }, {
      "referenceID" : 7,
      "context" : "2015) and also followed by Gringo (Gebser et al. 2011).",
      "startOffset" : 34,
      "endOffset" : 54
    }, {
      "referenceID" : 13,
      "context" : "A property of TEL directly inherited from Equilibrium Logic (see Proposition 5 in (Pearce 2006)) is the following:",
      "startOffset" : 82,
      "endOffset" : 95
    }, {
      "referenceID" : 1,
      "context" : "Theorem 1 (Theorem 1 in (Aguado et al. 2011)) 〈T,T〉 is a temporal equilibrium model of Π iff {©p | p ∈ Ti, i ≥ 0} is a stable model of Π under the (infinite) signature {©p | p ∈ At}.",
      "startOffset" : 24,
      "endOffset" : 44
    }, {
      "referenceID" : 5,
      "context" : "Although an unsafe rule does not always lead to lack of domain independence (see examples in (Cabalar et al. 2009)) it is frequently the case.",
      "startOffset" : 93,
      "endOffset" : 114
    } ],
    "year" : 2016,
    "abstractText" : "In this note we consider the problem of introducing variables in temporal logic programs under the formalism of Temporal Equilibrium Logic (TEL), an extension of Answer Set Programming (ASP) for dealing with linear-time modal operators. To this aim, we provide a definition of a first-order version of TEL that shares the syntax of first-order Linear-time Temporal Logic (LTL) but has a different semantics, selecting some LTL models we call temporal stable models. Then, we consider a subclass of theories (called splittable temporal logic programs) that are close to usual logic programs but allowing a restricted use of temporal operators. In this setting, we provide a syntactic definition of safe variables that suffices to show the property of domain independence – that is, addition of arbitrary elements in the universe does not vary the set of temporal stable models. Finally, we present a method for computing the derivable facts by constructing a non-temporal logic program with variables that is fed to a standard ASP grounder. The information provided by the grounder is then used to generate a subset of ground temporal rules which is equivalent to (and generally smaller than) the full program instantiation. Under consideration in Theory and Practice of Logic Programming (TPLP)",
    "creator" : "LaTeX with hyperref package"
  }
}