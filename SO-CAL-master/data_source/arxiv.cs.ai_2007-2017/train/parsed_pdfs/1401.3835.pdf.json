{
  "name" : "1401.3835.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On Action Theory Change",
    "authors" : [ "Ivan José Varzinczak" ],
    "emails" : [ "ivan.varzinczak@meraka.org.za" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Consider an intelligent agent designed to perform rationally in a dynamic world, and suppose that she should reason about the dynamics of an automatic coffee machine (Figure 1).\nSuppose, for example, that the agent believes that coffee is always a hot beverage. Suppose now that some day she gets a coffee at the machine and observes that it is cold. In such a case, the agent must change her beliefs about the relationship between the two propositions “I hold a coffee” and “I hold a hot drink”. This example is an instance of the problem of changing propositional belief bases and has been largely addressed in the\nc©2010 AI Access Foundation. All rights reserved.\nliterature about belief revision (Alchourrón, Gärdenfors, & Makinson, 1985; Gärdenfors, 1988; Hansson, 1999) and belief update (Katsuno & Mendelzon, 1992).\nNext, let our agent believe that whenever she buys a coffee from the machine, she gets a hot drink. This means that in every state of the world that follows the execution of buying a coffee, the agent ends up with a hot drink. Now, in a situation where the machine is running out of cups, after buying, the coffee runs through the shelf and the agent, contrary to what she was expecting, does not hold a hot drink in her hands.\nImagine now that the agent never considered any relation between buying a coffee on the machine and its service availability, in the sense that she always believed (quite reasonably) that buying does not prevent other users from using the machine. Nevertheless, someday our agent is queuing to buy a coffee and observes that just after the agent before her has bought, the machine went out of order (maybe due to a lack of coffee powder).\nCompleting our agent’s struggle in discovering the intricacies of operating a coffee machine, let us suppose now that she always believed that if she has a token, then it is possible to buy coffee, provided that some other preconditions like being close enough to the button, having a free hand, etc, are satisfied. Eventually, due to a blackout, the agent realizes that she does not manage to buy her coffee, even with a token.\nThe last three examples illustrate cases in which changing the beliefs about the behavior of the action of buying coffee is mandatory. In the first one, buying coffee, once believed to have a deterministic outcome, namely always a hot drink, has now to be seen as nondeterministic or, alternatively, to have a different effect in a more specific context (e.g. if there is no cup in the machine). In the second example, buying a coffee is now known to have side-effects (ramifications) which one was not aware of. Finally, in the last example, the feasibility of the action under concern is questioned in the light of new information showing a context that was not known to preclude its execution.\nSuch cases of theory change are very important when one deals with logical descriptions of dynamic domains: it may always happen that one discovers that an action actually has a behavior that is different from that one has always believed it had.\nUp to now, theory change has been studied mainly for knowledge bases in classical logics, both in terms of revision and update. Since the work by Fuhrmann (1989), only in a few recent studies has it been considered in the realm of modal logics, viz. in epistemic logic (Hansson, 1999) and in dynamic logics (Herzig, Perrussel, & Varzinczak, 2006). Recently some studies have investigated revision of beliefs about facts of the world (Shapiro, Pagnucco, Lespérance, & Levesque, 2000; Jin & Thielscher, 2005) or the agent’s goals (Shapiro, Lespérance, & Levesque, 2005). In our scenario, this would concern for instance the truth of token in a given state: the agent believes that she has a token, but is actually wrong about that. Then she might subsequently be forced to revise her beliefs about the current state of affairs or change her goals according to what she can perform in that state. Such belief revision operations do not modify the agent’s beliefs about the action laws. On the other hand, here we are interested exactly in such modifications. Starting with Baral and Lobo’s work (1997), some recent studies have been done on that issue (Eiter, Erdem, Fink, & Senko, 2005) for domain descriptions in action languages (Gelfond & Lifschitz, 1993).\nWe here take a step further in this direction and propose a method which is more robust by integrating a notion of minimal change and complying with postulates of theory change.\nThe present text is structured as follows: in Section 2 we establish the formal background that will be used throughout this article. Sections 3–6 are the core of the work: in Section 3 we present the central definitions for a semantics of action theory change, providing justifications for the design choices here made (Section 4). Section 5 is devoted to the syntactical counterpart of our operators while Section 6 to the proof of its correspondence with the semantics under certain acceptable conditions. In Section 7 we discuss some postulates for contraction/erasure and then present a semantics for action theory revision (Section 8). After a discussion on and comparison with existing work in the field (Section 9), we conclude with an overview and future directions of research."
    }, {
      "heading" : "2. Logical Preliminaries",
      "text" : "Following the tradition in the Reasoning about Actions and Change (RAC) community, we consider action theories to be finite collections of statements that have the particular form (Shanahan, 1997):\n• if context, then effect after every execution of action (effect laws);\n• if precondition, then action executable (executability laws).\nStatements mentioning no action at all represent laws about the underlying structure of the world, i.e., its possible states (static laws).\nSeveral logical frameworks have been proposed to formalize such statements (Shanahan, 1997). Among the most prominent ones are the first-order based Situation Calculus (McCarthy & Hayes, 1969; Reiter, 2001), the family of Action Languages (Gelfond & Lifschitz, 1993; Giunchiglia, Kartha, & Lifschitz, 1997), the Fluent Calculus (Thielscher, 1997), and Propositional Dynamic Logic (PDL) (Harel, Tiuryn, & Kozen, 2000) with different specific extensions thereof (De Giacomo & Lenzerini, 1995; Castilho, Gasquet, & Herzig, 1999; Zhang & Foo, 2001; Castilho, Herzig, & Varzinczak, 2002).\nHere we opt to formalize action theories using the multimodal logic Kn (Popkorn, 1994). Among the main reasons for such a choice are:\n• We benefit from the well defined semantics for multimodal logics which, as we are going to see in the sequel, provides simple and intuitive foundations on which to build the meaning of changing action domain descriptions.\n• Kn syntax allows us to express all the afore mentioned types of laws without requiring the full expressiveness of PDL or the machinery of a first-order language.\n• Since Kn is the core of all above mentioned PDL-based action formalisms, all we shall say in the sequel should smoothly transfer to them.\n• Contrary to first-order based approaches, Kn is decidable and has several implemented theorem provers for it available in the literature."
    }, {
      "heading" : "2.1 Action Theories in Multimodal Logic",
      "text" : "Let Act = {a1, a2, . . . , an} be the set of all atomic action constants of a given dynamic domain. An example of atomic action is buy. To each atomic action a there is associated a modal operator [a]. We here suppose that our multimodal logic is independently axiomatized (Kracht & Wolter, 1991), i.e., the logic is a fusion and there is no interaction between the different modal operators.1\nProp = {p1, p2, . . . , pn} denotes a finite set of propositional constants, also called fluents or elementary atoms. Examples of those are token (“the agent has a token”) and coffee (“the agent holds a coffee”). Lit = {p,¬p : p ∈ Prop} is the set of literals. We use ` to denote a literal. If ` = ¬p, then we identify ¬` with p. By |`| we denote the atom in `.\nWe use small Greek letters ϕ,ψ, . . . to denote Boolean (propositional) formulas. They are recursively defined in the usual way:\nϕ ::= p | > | ⊥ | ¬ϕ | ϕ ∧ ϕ | ϕ ∨ ϕ | ϕ→ ϕ | ϕ↔ ϕ\n(ϕ⊕ψ denotes (ϕ∨ψ)∧¬(ϕ∧ψ).) Fml is the set of all Boolean formulas. An example of a Boolean formula is coffee→ hot. A propositional valuation v is a maximal consistent set of literals. We denote by v ϕ the fact that v satisfies a propositional formula ϕ. By val(ϕ) we denote the set of all valuations satisfying ϕ. By CPL we denote Classical Propositional Logic and |=\nCPL is its respective consequence relation. Cn(ϕ) denotes all logical consequences\nof ϕ in CPL, i.e., Cn(ϕ) = {ψ : ϕ |= CPL ψ}. If ϕ is a propositional formula, atm(ϕ) denotes the set of elementary atoms actually occurring in ϕ. For example, atm(¬p1 ∧ (¬p1 ∨ p2)) = {p1, p2}.\nFor ϕ a Boolean formula, IP(ϕ) denotes the set of its prime implicants (Quine, 1952), i.e., the weakest terms (conjunctions of literals) that imply ϕ. As an example, IP(p1 ⊕ p2) = {p1 ∧ ¬p2,¬p1 ∧ p2}. For more on prime implicants, their properties and how to compute them, see the chapter by Marquis (2000). With π we denote a prime implicant, and given ` and π, ` ∈ π abbreviates ‘` is a literal of π’. For a given set X, X̄ denotes its complement. Hence atm(π) denotes Prop \\ atm(π).\nWe denote complex formulas (possibly with modal operators) by Φ, Ψ, . . . They are recursively defined in the following way:\nΦ ::= ϕ | [a]Φ | ¬Φ | Φ ∧ Φ | Φ ∨ Φ | Φ→ Φ | Φ↔ Φ\n〈a〉 is the dual operator of [a], defined by 〈a〉Φ =def ¬[a]¬Φ. An instance of a complex formula in our scenario example is ¬coffee→ [buy]coffee.\nGiven a complex formula Φ, with act(Φ) we denote the action names occurring in Φ, i.e., the modalities of Φ. For example, act([a2]p1 ∧ ([a1]p2 → [a2]p3)) = {a1, a2}.\nThe semantics here is the standard semantics of multimodal logic Kn (Popkorn, 1994).\nDefinition 2.1 (Kn-Model) A Kn-model is a tuple M = 〈W,R〉 where W is a set of valuations (also called possible worlds), and R maps action constants a to accessibility relations Ra ⊆W×W.\n1. Later on we will see that this is a requirement to ensure that an action theory is modular.\nAs an example, for Act = {a1, a2} and Prop = {p1, p2}, we have the Kn-model M = 〈W,R〉, where\nW = {{p1, p2}, {p1,¬p2}, {¬p1, p2}},\nR(a1) =\n{ ({p1, p2}, {p1,¬p2}), ({p1, p2}, {¬p1, p2}),\n({p1,¬p2}, {p1,¬p2}), ({p1,¬p2}, {¬p1, p2}) } R(a2) = {({p1, p2}, {¬p1, p2}), ({¬p1, p2}, {¬p1, p2})}\nFigure 2 gives a graphical representation of the model M .\nNotice that our definition of Kn-model does not follow the traditional notion from modal logics: here no two worlds satisfy the same valuation. This is a pragmatic choice, as we will see in Section 5. Nevertheless, all we shall say in the sequel can be straightforwardly formulated for standard Kn models as well.\nDefinition 2.2 (Truth Conditions) Given a Kn-model M = 〈W,R〉,\n• |=M w p (p is true at world w of M ) iff w p (valuation w satisfies p, i.e., p ∈ w);\n• |=M w [a]Φ iff |=M w′ Φ for every w′ such that (w,w′) ∈ Ra;\n• |=M w Φ ∧ Ψ iff |=M w Φ and |=M w Ψ ;\n• |=M w ¬Φ iff 6|=M w Φ, i.e., not |=M w Φ;\n• truth conditions for the other connectives are as usual.\nBy M we will denote a (possibly empty) set of Kn-models.\nA Kn-model M is a model of Φ (denoted |= M Φ) if and only if for all w ∈W, |=M\nw Φ. In the\nmodel depicted in Figure 2, we have |=M p1 → [a2]p2 and |= M\np1 ∨ p2. M is a model of a set of formulas Σ (noted |=M Σ) if and only if |=MΦ for every Φ ∈ Σ. If Σ is the set of formulas we start off with (our non-logical theory), then each Φ ∈ Σ is called a global axiom.\nDefinition 2.3 (Global Consequence) A formula Φ is a global consequence of a set of global axioms Σ in the class of all Kn-models (noted Σ |=Kn Φ) if and only if for every Kn-model M , if |= M Σ, then |=MΦ.\nWith Kn we can state laws describing the behavior of actions. One way of doing this is by stating some formulas as global axioms.2 As usually done in the RAC community (Shanahan, 1997), we here distinguish three types of laws. The first kind of statements are static laws, which are constraints on the allowed states of a dynamic domain.\nDefinition 2.4 (Static Law) A static law is a global axiom ϕ ∈ Fml.\nAn example of a static law is coffee→ hot, saying that if the agent holds a coffee, then she holds a hot drink. In the Situation Calculus formalism (Reiter, 2001) one would write the first-order formula ∀s.[coffee(s)→ hot(s)]. The set of all static laws of a scenario is denoted by S ⊆ Fml. In our example we will have S = {coffee→ hot}.\nThe second kind of action law we consider is given by the effect laws. These are formulas relating an action to its effects, which can be conditional.\nDefinition 2.5 (Effect Law) Let ϕ,ψ ∈ Fml. An effect law for action a is a global axiom of the form ϕ→ [a]ψ.\nThe consequent ψ is the effect which always obtains in accessible states (which need not exist in general) when action a is executed in a state where the antecedent ϕ holds. In our Kripke semantics, this means that in every possible world where ϕ holds, every transition by an a-labeled arrow (if any) leads to a possible world where ψ holds. If a is a nondeterministic action, then the consequent ψ is typically a disjunction. An example of an effect law is ¬coffee→ [buy]coffee, saying that in a situation where the agent has no coffee, after buying, the agent has a coffee. If ψ is inconsistent, then we have a special kind of effect law that we call an inexecutability law. For example, we could also have ¬token→ [buy]⊥, expressing that buy cannot be executed if the agent has no token. In the Situation Calculus our examples of effect and inexecutability laws would be expressed respectively as ∀s.[¬coffee(s)→ coffee(do(buy, s))] and ∀s.[¬token(s)→ ¬Poss(buy, s)].\nThe set of effect laws of a given scenario is denoted by E . In our coffee machine scenario, we could have for example:\nE =  ¬coffee→ [buy]coffee, token→ [buy]¬token, ¬token→ [buy]⊥  Finally, we also define executability laws, which stipulate the context where an action is guaranteed to be executable. In Kn, the operator 〈a〉 is used to express executability. 〈a〉> thus reads “the execution of a is possible”. Formally, 〈a〉> being true in a world w means that there is at least one world w′ accessible from w via Ra (cf. Definition 2.2).\n2. An alternative to that is given by Castilho et al. (1999, 2002), with laws being stated with the aid of an extra universal modality and local consequence being thus considered.\nDefinition 2.6 (Executability Law) Let ϕ ∈ Fml. An executability law for action a is a global axiom of the form ϕ→ 〈a〉>.\nFor instance, token → 〈buy〉> says that buying can be executed whenever the agent has a token. The set of all executability laws of a given domain is denoted by X . In our scenario example we will have X = {token→ 〈buy〉>}.\nNote that in principle one needs to know nothing about the accessible world w′. However, a common (albeit tacit) assumption in the RAC community is that we state executability laws only for actions of which we know the effects, in other words act(X ) ⊆ act(E ).\nIn the Situation Calculus our example would be stated as ∀s.[token(s)→ Poss(buy, s)]. However, we point out that, traditionally, in Reiter basic action theories (Reiter, 2001) executability laws and inexecutability laws are mixed together in the form of bi-conditionals like ∀s.[token(s) ↔ Poss(buy, s)], called precondition axioms. For a critique of such a practice and its implications in formalizing dynamic domains, see the work by Herzig and Varzinczak (2007).\nWith our three basic types of laws, we are able to define action theories:\nDefinition 2.7 (Action Theory) Given any (possibly empty) sets of laws S , E , and X , T = S ∪ E ∪ X is an action theory.\nGiven an action theory T and an action a, Ea (resp. Xa) will denote the set of only those effect (resp. executability) laws about a in E (resp. X ). Ta = S ∪ Ea ∪Xa is then the action theory for a.\nIt is worth noting that for a1, a2 ∈ Act, a1 6= a2, the intuition is indeed that Ta1 and Ta2 overlap only on S , i.e., the only laws that are common to both Ta1 and Ta2 are the laws about the structure of the world. This requirement is somehow related with the underlying modal logic being independently axiomatized (see note above)."
    }, {
      "heading" : "2.2 The Frame, Ramification and Qualification Problems",
      "text" : "During the last 40 years, most of the effort in the reasoning about actions community has been devoted to searching for satisfactory solutions to the frame problem, the ramification problem and the qualification problem.\nRoughly speaking, the frame problem (McCarthy & Hayes, 1969) relates to the need for inferring the persistence of some facts of the world after the execution of an action known not to affect them, without having to state that explicitly in the form of frame axioms. (Frame axioms are a special type of effect law, having the form ` → [a]`, for ` ∈ Lit.) In our example, buying a coffee in a context where the agent has already got one does not make it lose the coffee: coffee → [buy]coffee should be a consequence of our theory. The ramification problem (Finger, 1987) comes from the observation that an action may have several possibly interdependent effects and stating all of them explicitly is a huge task. In our scenario, we want to be able to infer [buy]hot without saying it in the theory, and in such a way some intrinsic causal connection between coffee and hot is taken into account. Finally, the qualification problem (McCarthy, 1977) amounts to addressing the issue of ensuring that an action is executable in a given context. Specifying all the sufficient\nconditions for an action to be executable is an incredibly hard task. In our example, one may state token → 〈buy〉>, but it may well be the case that buying fails due to some condition unforeseen at design time, like the agent’s arm being rusty and stuck.\nFor more on these core problems of the RAC community, the reader is referred to the book by Shanahan (1997).\nFor the sake of clarity, here we abstract from the frame and ramification problems, and suppose that the agent’s theory already entails all the relevant frame axioms. We point out however that all we shall say could have been defined within a formalism with a solution to the frame and ramification problems. For instance, we could have used any suitable solution to the frame problem, like e.g. the dependence relation (Castilho et al., 1999), which is used in the work of Herzig et al. (2006), or a kind of successor state axioms in a slightly modified setting (Demolombe, Herzig, & Varzinczak, 2003). To make the presentation more clear to the reader, here we do not bother with a particular solution to the frame problem and just assume that all frame axioms can be inferred from the action theory. Actually we can suppose that all intended frame axioms are automatically recovered and stated in the theory, more specifically, in the set of effect laws.\nGiven the largely acknowledged difficulty of the qualification problem in the literature (Shanahan, 1997), we do not assume here any a priori solution to it. Instead, as tacitly assumed in many approaches to reasoning about actions (Castilho et al., 1999; Zhang & Foo, 2001; Reiter, 2001), we suppose that the knowledge engineer may want to state some (not necessarily fully specified) executability laws for some actions. These may be incorrect at the starting point (and in all probability they will be), but revising wrong executability laws is an approach towards its solution and one of the aims of this work. With further information the knowledge engineer will have the chance to change them so that eventually they will correspond to the intuition (cf. Sections 3 and 8).\nHaving agreed on these points, the action theory of our example will be:\nT =  coffee→ hot, token→ 〈buy〉>, ¬coffee→ [buy]coffee,\ntoken→ [buy]¬token,¬token→ [buy]⊥, coffee→ [buy]coffee, hot→ [buy]hot  (We have not stated the frame axiom ¬token → [buy]¬token because it can be trivially deduced from the inexecutability law ¬token→ [buy]⊥.)\nFigure 3 below shows a Kn-model for the action theory T above.\nWe are going to see in the sequel that the finite base T formalizing the action theory plays a role in the contraction of laws. In particular, the base representing the static laws turns out to be quite important. So given an action theory T, it will be useful to consider models of T whose possible worlds are all the possible valuations allowed by S :\nDefinition 2.8 (Canonical Frame) Let T = S ∪ E ∪ X be an action theory. Then the tuple Mcan = 〈Wcan,Rcan〉 is the canonical frame of T if and only if:\n• Wcan = val(S ); and\n• Rcan = ⋃ a∈Act Ra s.t. Ra = {(w,w′) : for all ϕ→ [a]ψ ∈ Ea, if |= M w ϕ, then |=M w′ ψ}.\nThe canonical frame of an action theory need not be one of its models. To witness why, let Prop = {p}, Act = {a}, and consider the simple action theory {p → [a]⊥, p → 〈a〉>}. Then in the associated canonical frame we have Wcan = {{p}, {¬p}}. Clearly the world {p} does not satisfy this theory.\nDefinition 2.9 (Canonical Model) M is a canonical model of T if and only if M is a canonical frame of T and |=MT.\nFigure 4 below shows the canonical model of our action theory example T."
    }, {
      "heading" : "2.3 Prime Valuations",
      "text" : "We say that an atom p is essential to a formula ϕ if and only if p ∈ atm(ϕ′) for every ϕ′ such that |=\nCPL ϕ ↔ ϕ′. For instance, p1 is essential to ¬p1 ∧ (¬p1 ∨ p2). Given ϕ, atm!(ϕ)\ndenotes the set of essential atoms of ϕ. (If ϕ is not contingent, i.e., ϕ is a tautology or a contradiction, then atm!(ϕ) = ∅.)\nGiven ϕ a Boolean formula, ϕ∗ is the set of all formulas ϕ′ such that ϕ |= CPL ϕ′ and atm(ϕ′) ⊆ atm!(ϕ). For instance, p1 ∨ p2 /∈ p1∗, as p1 |=CPL p1 ∨ p2 but atm(p1 ∨ p2) 6⊆ atm!(p1). Clearly, atm( ∧ ϕ∗) = atm!( ∧ ϕ∗), moreover whenever |= CPL ϕ ↔ ϕ′ is the case, then atm!(ϕ) = atm!(ϕ′) and also ϕ∗ = ϕ′∗.\nTheorem 2.1 (Least Atom-Set Theorem, Parikh, 1999) Let ϕ be a propositional formula. Then |=\nCPL ϕ↔\n∧ ϕ∗, and for every ϕ′ such that |=\nCPL ϕ↔ ϕ′, atm(ϕ∗) ⊆ atm(ϕ′).\nA proof of this theorem is given by Makinson (2007) and we do not state it here. Essentially, the theorem establishes that for every Boolean formula ϕ, there is a unique least set of elementary atoms such that ϕ may equivalently be expressed using only atoms from that set. Hence, Cn(ϕ) = Cn(ϕ∗).\nGiven a valuation v, v′ ⊆ v is a subvaluation. Given a set of valuations W, a subvaluation v′ satisfies a propositional formula ϕ modulo W (noted v′\nW ϕ) if and only if v ϕ for all\nv ∈ W such that v′ ⊆ v. We say that a subvaluation v essentially satisfies ϕ (modulo W), noted v !\nW ϕ, if and only if v W ϕ and {|`| : ` ∈ v} ⊆ atm!(ϕ). If v ! W ϕ, we call v an\nessential subvaluation of ϕ (modulo W).\nDefinition 2.10 (Prime Subvaluation) Let ϕ be a Boolean formula and W a set of valuations. A subvaluation v is a prime subvaluation of ϕ (modulo W) if and only if v !\nW ϕ\nand there is no v′ ⊂ v such that v′ ! W ϕ.\nA prime subvaluation of a formula ϕ is thus one of the weakest states of truth in which ϕ is true. Hence, prime subvaluations are just another way of seeing prime implicants (Quine, 1952) of ϕ. By base(ϕ,W) we will denote the set of all prime subvaluations of ϕ modulo W.\nProposition 2.1 Let ϕ ∈ Fml and W be a set of valuations. Then for all w ∈ W, w ϕ if and only if w ∨ v∈base(ϕ,W) ∧ `∈v `.\nProof: Right to left direction is straightforward. For the left to right direction, if w ϕ, then w ϕ∗. Let w′ ⊆ w be the least subset of w still satisfying ϕ∗. Clearly, w′ is a prime subvaluation of ϕ modulo W, and then because w ∧ `∈w′ `, the result follows. 2"
    }, {
      "heading" : "2.4 Closeness between Models",
      "text" : "When contracting a formula from a model, we will perform a change in its structure. Because there can be several different ways of modifying a model (not all of them minimal), we need a notion of distance between models to identify those that are closest to the original one.\nAs we are going to see in more depth in the next section, changing a model amounts to modifying its possible worlds or its accessibility relation. Hence, the distance between two Kn-models will depend upon the distance between their sets of worlds and accessibility relations. These here will be based on the symmetric difference between sets, defined as X−̇Y = (X \\ Y ) ∪ (Y \\X).\nDefinition 2.11 (Closeness between Kn-Models) Let M = 〈W,R〉 be a model. Then M ′ = 〈W′,R′〉 is at least as close to M as M ′′ = 〈W′′,R′′〉, noted M ′ M M ′′, if and only if\n• either W−̇W′ ⊆W−̇W′′;\n• or W−̇W′ = W−̇W′′ and R−̇R′ ⊆ R−̇R′′.\nThis is an extension of Burger and Heidema’s relation (Burger & Heidema, 2002) to our modal case. It defines a lexicographic order on the set of all Kn-models. Although simple, this notion of closeness turns out to be sufficient for our purposes here, as we shall see in the sequel. Notice that other notions of distance between models could have been considered as well, namely the cardinality of symmetric differences or Hamming distance. (See Section 4 for a discussion on this.)"
    }, {
      "heading" : "3. Semantics of Action Theory Change",
      "text" : "When admitting the possibility of a law Φ failing, one must ensure that Φ becomes invalid, i.e., not true in at least one model of the dynamic domain that is formalized. Because there can be lots of such models, we may have a setM of models in which Φ is (potentially) valid. Thus contracting Φ amounts to making it no longer valid in this set of models. What are the operations that must be carried out to achieve that? Throwing models out of M does not work, since Φ will keep on being valid in all models of the remaining set. Thus one should add new models to M. Which models? Well, models in which Φ is not true. But not any of such models: taking models falsifying Φ that are too different from our original models will certainly violate the principle of minimal change.\nHence, we shall take some model M ∈M as basis and manipulate it to get a new model M ′ in which Φ is not true. In our modal semantics, the removal of a law Φ from a model M = 〈W,R〉 means modifying the possible worlds or the accessibility relation in M so that Φ becomes false. Such an operation gives as result a set M−Φ of models each of which is no longer a model of Φ. But if there are several candidates, which ones should we choose? We shall take those models that are minimal modifications of the original M , i.e., those which are minimal with respect to our distance M between models. Of course, there can be more than one such an M ′ that is minimal with respect to M . In that case, because adding just one of these new models is enough to invalidate Φ, we take all possible combinations M ∪ {M ′} of expanding our original set of models M by one of these minimal models. (Observe that this approach relates to orderly maxichoice contraction Hansson, 1999.) The result will be a set of sets of models. In each set of models there will be precisely one model M ′ falsifying Φ.\nIt might be claimed that, as such, our contraction method described above does not respect the so-called principle of categorical matching: the input and output are different sorts of objects, namely a set of models and a set of sets of models. It is easy to see, however, that the reasoning above can be stated in such a way that each output set of models corresponds precisely to the result of one contraction operator, satisfying then the referred principle. The choice for defining the result of an operation as a set of possible outputs will become more clear in Section 5, where we are going to present algorithms that correspond exactly to our semantic constructions."
    }, {
      "heading" : "3.1 Model Contraction of Executability Laws",
      "text" : "To contract an executability law ϕ → 〈a〉> from one model, intuitively we should remove transitions leaving ϕ-worlds. In order to succeed in the operation, we have to guarantee that in the resulting model there will be at least one ϕ-world with no departing a-arrow.\nDefinition 3.1 Let M = 〈W,R〉. M ′ = 〈W′,R′〉 ∈M−ϕ→〈a〉> if and only if\n• W′ = W;\n• R′ ⊆ R;\n• if (w,w′) ∈ R \\ R′, then |=M w ϕ; and\n• there is w ∈W′ such that 6|=M ′\nw ϕ→ 〈a〉>.\nObserve that M−ϕ→〈a〉> 6= ∅ if and only if ϕ is satisfiable in W. Moreover, M ∈M − ϕ→〈a〉>\nif and only if 6|=Mϕ→ 〈a〉>.\nJust to provide the reader with an insight on how this operation would be carried out in the Situation Calculus, there one should look at a given situation s in which ϕ holds and then modify the interpretation of the predicate Poss(a) so that it becomes false in s. Like in our case, there may be many of such situations and then all of them must be taken into account. An essential difference here is that our Kripke structures are always finite, whereas the space of situations is possibly infinite (Reiter, 2001).\nTo get minimal change, we want such an operation of removing transitions to be minimal with respect to the original model: one should remove a minimum set of transitions which is sufficient to get the desired result. Definition 3.2 contract(M , ϕ→ 〈a〉>) = ⋃\nmin{M−ϕ→〈a〉>, M }\nAnd now we define the sets of possible models resulting from the contraction of an executability law in a set of models:\nDefinition 3.3 Let M be a set of models, and ϕ→ 〈a〉> an executability law. Then\nM−ϕ→〈a〉> = {M ′ :M′ =M∪ {M ′},M ′ ∈ contract(M , ϕ→ 〈a〉>),M ∈M}\nIn our running example, considerM = {M }, where M is the model in Figure 4. When the agent discovers that even with a token she does not manage to buy a coffee any more, she has to change her models in order to admit (new) models with states where token is the case but from which there is no buy-transition at all. Because having just one such a world in each new model is enough, taking those resulting models whose accessibility relations are maximal guarantees minimal change. Hence we will have M−token→〈buy〉> = {M∪ {M ′1},M∪ {M ′2},M∪ {M ′3}}, where each M ′i is depicted in Figure 5.\nClearly, if ϕ is not satisfied in M, i.e., |=M ¬ϕ for all M ∈ M, then the contraction of ϕ → 〈a〉> does not succeed. This is in line with the expectations and it relates to the Success Postulate (cf. Section 7.2)."
    }, {
      "heading" : "3.2 Model Contraction of Effect Laws",
      "text" : "When our agent discovers that there may be some cases where after buying she gets no hot drink, she must e.g. give up the belief in the effect law token → [buy]hot in her set of models. This means that token ∧ 〈buy〉¬hot shall now be admitted in at least one world of some of the new models of her set of beliefs. Therefore, to contract an effect law ϕ→ [a]ψ from a given model, intuitively we have to add new transitions from ϕ-worlds to worlds not satisfying ψ. As we shall see, the great challenge in such an operation is precisely how to guarantee minimal change.\nIn our example, when contracting token→ [buy]hot from the model of Figure 4 we shall add transitions from token-worlds to ¬hot-worlds. Because coffee→ hot is a static law and so is ¬hot → ¬coffee, this should also give us 〈buy〉¬coffee in some token-world (¬coffee is causally relevant to ¬hot, i.e., to have ¬hot we must also have ¬coffee). This means that if we allow for 〈buy〉¬hot in some token-world, we also have to allow for 〈buy〉¬coffee in that same world. The same argument does not necessarily hold for token: allowing for 〈buy〉¬hot does not necessarily oblige us to allow for 〈buy〉token in the respective world. This is because token is not relevant to ¬hot (as ¬coffee is). This means that we have the freedom either to allow for it or not.\nHence, in our running example we can add transitions from token-worlds to ¬hot ∧ ¬coffee ∧ token-worlds, as well as to ¬hot ∧ ¬coffee ∧ ¬token. This situation is depicted in Figure 6. For instance, we can add a new buy-arrow from the world {token,¬coffee,¬hot} to one of these candidates (Figure 7).\nIn the Situation Calculus, such a modification would be slightly different, but with the same intuition behind: one should look at a given situation s in which ϕ holds and then modify the interpretation of the fluents (atoms) in do(a, s), the situation resulting from performing a in s. Alternatively, new ϕ-situations should lead to at least one ¬ψ-situation.\nNotice however that this would require the addition of new whole branches to the tree-like first-order model induced by Reiter basic action theories (Reiter, 2001).\nBack to our example, observe that adding the new transition to {token,¬coffee,¬hot} itself would make us lose the effect ¬token, true after every execution of buy in the original model (|=M token → [buy]¬token). How do we preserve this law while allowing for the new transition to a ¬hot-world? That is, how do we get rid of the effect hot without losing effects that are not relevant for that? We here develop an approach for this issue.\nWhen adding a new transition leaving a world w we intuitively want to preserve as many effects as we had before doing so. To achieve this, it is enough to preserve old effects only in w (because the remaining structure of the model remains unchanged after adding the new transition). Of course, we cannot preserve effects that are inconsistent with ¬ψ (those will all be lost). Hence it suffices to preserve only the effects that are consistent with ¬ψ. To achieve that we must observe what is true in w and in the target world w′:\n• The proper effects of the action in world w′, i.e., what changes from w to w′ (w′ \\w) through the new execution of a must be what is obliged to be so: either because those literals that now change from w to w′ are necessary to having ¬ψ in w′ (like ¬coffee in our example) or because they are necessary to have another effect (independent of ¬ψ, like ¬token) in world w′.\n• The non-effects of action a in world w′, i.e., what does not change from w to w′ (w ∩ w′) through a’s new execution should be only what is allowed to be so: certain literals are never preserved (like token in our example), then when pointing the new transition towards a world where it does not change with respect to the leaving world (¬hot ∧ ¬coffee ∧ token in our example), we may lose effects that held in w before adding the transition.\nThis means that the only things allowed to change in the candidate target world must be those that are forced to change, either by some non-related law or because of having ¬ψ modulo a set of states W. In other words, we want the literals that (now) change from w to w′ to be at most those that are sufficient to get ¬ψ modulo W, while preserving the maximum of other effects. Every change beyond that is not an intended one. Similarly, we want the literals from w that are (now) preserved in the target world w′ to be at most those that are usually preserved in a given set of models. Every preservation beyond those may make us lose some law. This looks like prime implicants, and that is where prime subvaluations play their role: the worlds to which the new transition will point are those whose difference with respect to the departing world are literals that are relevant and whose similarity with respect to it are literals that we know do not change.\nDefinition 3.4 (Relevant Target Worlds) Let M = 〈W,R〉 be a model, w,w′ ∈W, M a set of models such that M ∈M, and ϕ→ [a]ψ an effect law. Then w′ is a relevant target world of w with respect to ϕ→ [a]ψ for M in M if and only if\n• |=M w ϕ and 6|=M w′ ψ;\n• for all ` ∈ w′ \\ w:\n– either there is v ∈ base(¬ψ,W) such that v ⊆ w′ and ` ∈ v; – or there is ψ′ ∈ Fml such that there is v′ ∈ base(ψ′,W) such that v′ ⊆ w′, ` ∈ v′,\nand for every Mi ∈M, |= Mi w [a]ψ′\n• for all ` ∈ w ∩ w′:\n– either there is v ∈ base(¬ψ,W) such that v ⊆ w′ and ` ∈ v;\n– or there is Mi ∈M such that 6|= Mi\nw [a]¬`;\nBy RelTarget(w,ϕ→ [a]ψ,M ,M) we denote the set of all relevant target worlds of w with respect to ϕ→ [a]ψ for M in M.\nNote that we need the set of modelsM (and here we can suppose it contains all models of the theory we want to change) because preserving effects depends on what other effects hold in the other models that interest us. We need to take them into account in the local operation of changing one model. (The reason we do not need M in the definition of the local, one model contraction of executability laws M−ϕ→〈a〉> is that when removing transitions there is no way of losing effects, as every effect law that held in the world from which a transition has been removed remains true in the same world in the resulting model.)\nDefinition 3.5 Let M = 〈W,R〉, and M be such that M ∈ M. Then M ′ = 〈W′,R′〉 ∈ M−ϕ→[a]ψ if and only if\n• W′ = W;\n• R ⊆ R′;\n• If (w,w′) ∈ R′ \\ R, then w′ ∈ RelTarget(w,ϕ→ [a]ψ,M ,M); and\n• there is w ∈W′ such that 6|=M ′\nw ϕ→ [a]ψ.\nObserve that M−ϕ→[a]ψ 6= ∅ if and only if ϕ and ¬ψ are both satisfiable in W. Moreover,\nM ∈M−ϕ→[a]ψ if and only if 6|= M ϕ→ [a]ψ.\nBecause having just one world where the law is no longer true in each model is enough, taking those resulting models whose accessibility relations are minimal with respect to the original one guarantees minimal change. Definition 3.6 contract(M , ϕ→ [a]ψ) = ⋃\nmin{M−ϕ→[a]ψ, M }\nNow we can define the possible sets of models resulting from contracting an effect law from a set of models:\nDefinition 3.7 Let M be a set of models, and ϕ→ [a]ψ an effect law. Then\nM−ϕ→[a]ψ = {M ′ :M′ =M∪ {M ′},M ′ ∈ contract(M , ϕ→ [a]ψ),M ∈M}\nTaking again M = {M }, where M is the model in Figure 4, after contracting token→ [buy]hot from M we get M−token→[buy]hot = {M∪ {M ′ 1},M∪ {M ′2},M∪ {M ′3}}, where all M ′i s are as depicted in Figure 8.\nIn both cases where ϕ is not satisfiable in M or ψ is valid in M , of course our operator does not succeed in falsifying ϕ → [a]ψ (cf. end of Section 3.1). Again, this works as expected and it has to do with the Success Postulate (see also Section 7.2)."
    }, {
      "heading" : "3.3 Model Contraction of Static Laws",
      "text" : "When contracting a static law from a model, we want to admit the existence of at least one (new) possible state falsifying it. This means that intuitively we should add new worlds to the original model. (In a Situation Calculus setting that would correspond to allowing for situations not satisfying some of the domain constraints.) This is quite easy. A very delicate issue however is what to do with the accessibility relation: should new transitions leave/arrive at the new world? If no transition leaves the new added world, we may lose some executability law. If some transition leaves it, then we may lose some effect law, the same holding if we add a transition pointing to the new world. On the other hand, if no transition arrives at the new world, what about the intuition? Is it intuitive to have an unreachable state? (Similar issues would also arise in Situation Calculus interpretations, which means that they are independent of the underlying formalism.)\nAll this discussion shows how drastic a change in the static laws might be: it is a change in the underlying structure (possible states) of the world! Changing them may have as an indirect, unexpected (and in all probability unwanted) consequence the loss of some effect law(s) or some executability law(s). What we can do is choose which type(s) of laws we may accept to lose in this process and then postpone their change (by the other operators).\nFollowing the tradition in the RAC community, which states that executability laws are in general more difficult to formalize than effect laws, and therefore they are more likely to be incorrect (Shanahan, 1997), here we prefer not to change the accessibility relation, which means that we preserve effect laws and postpone the correction of executability laws, if required. (Remember that this is an approach towards a solution to the qualification problem — cf. Section 2.2 above.)\nOne may argue that doing things this way makes our three operators incoherent in the sense that for effect and executability laws we adopt a minimal change approach, giving stronger theories, whereas for static laws we adopt a more cautious approach, giving weaker theories (see the next section). It is worth noting however that as largely recognized by the RAC community, the different laws of a domain description do not have the same status: a minimal change approach for static law contraction that preserves as many executability laws as possible, even if coherent, would definitely fail to cope with the qualification problem. Moreover, by propagating wrong executability laws, such a coherent method would definitely be less elaboration tolerant (McCarthy, 1998) than the one we are defining with regards to further modifications of the theory.\nFor those reasons, our contention here is that static law contraction should be cautious. (For a detailed discussion on this, see Section 4.2 below and the end of Section 5.3.)\nDefinition 3.8 Let M = 〈W,R〉. M ′ = 〈W′,R′〉 ∈M−ϕ if and only if\n• W ⊆W′;\n• R = R′; and\n• there is w ∈W′ such that 6|=M ′\nw ϕ.\nNote that M−ϕ = ∅ if and only if |= ϕ. Moreover, M ∈M−ϕ if and only if 6|= M ϕ.\nThe minimal modifications of one model are defined as usual: Definition 3.9 contract(M , ϕ) = ⋃\nmin{M−ϕ , M }\nAnd now we define the sets of models resulting from contracting a static law from a given set of models:\nDefinition 3.10 Let M be a set of models, and ϕ a static law. Then\nM−ϕ = {M′ :M′ =M∪ {M ′},M ′ ∈ contract(M , ϕ),M ∈M}\nIn our scenario example, if the initial set of models isM = {M }, where M is the model in Figure 4, then contracting the static law coffee→ hot fromM would give us the resulting new set of models M−coffee→hot = {M ∪ {M ′ 1},M∪ {M ′2}}, where each M ′i is as depicted in Figure 9 below.\nNotice that by not modifying the accessibility relation all the effect laws which are true in the original model M are preserved in the resulting models. This is ensured by [buy]⊥ being true in the new world w7.\nIt is only some executability laws that are potentially lost, due to the cautiousness of our approach. For instance, in M ′1 above, it is no longer the case that token → 〈buy〉> is true, since now there is a world, namely w7, which does not satisfy it anymore. (In M ′2 this executability law is still true in every possible world.)\nIt is worth point out, however, how our approach is indeed in line with intuition: when learning that a new state is now possible, we do not necessarily know all the behavior of the actions in the new added state. We may expect some action laws to hold in the new world (see end of Section 5.3), but, with the information we dispose, not touching the accessibility relation is the safest way of contracting static laws (cf. Section 4.2 below)."
    }, {
      "heading" : "4. Interlude",
      "text" : "Before presenting the algorithmic counterpart of our action theory change operators, in this section we discuss alternatives to some of our technical constructions. We point out the issues that such alternatives would raise. We also provide more justifications for some of the design choices that have been made in the previous sections."
    }, {
      "heading" : "4.1 Other Distance Notions",
      "text" : "Here we have defined and used a model distance which is based on the symmetric difference between sets (Definition 2.11). This distance is an extension to Kripke structures of Winslett’s (1988) notion of closeness between propositional interpretations in the Possible Models Approach (PMA). Instead of it, however, we could have considered other distance notions as well, like Dalal’s (1988) distance, Hamming distance (1950), or weighted distance. Due to space limitations, we do not develop a through comparison among all these distances here. (For more details, the reader may want to refer to Schlechta’s 2004 book.) We nevertheless do show that with a cardinality-based distance, for example, we may not always get the intended result.\nLet card(X) denote the number of elements in set X. Then suppose that our closeness between Kn-models was defined as follows:\nDefinition 4.1 (Cardinality-based Closeness between Kn-Models) Let M = 〈W,R〉 be a model. Then M ′ = 〈W′,R′〉 is at least as close to M as M ′′ = 〈W′′,R′′〉, noted M ′ ≤M M ′′, if and only if\n• either card(W−̇W′) ≤ card(W−̇W′′);\n• or card(W−̇W′) = card(W−̇W′′) and card(R−̇R′) ≤ card(R−̇R′′).\nSuch a notion of distance is closely related to Dalal’s (1988) closeness.\nBecause when contracting a static law ϕ from a model M we usually add one new possible world, it is easy to see that with this cardinality-based distance we get the same result in contract(M , ϕ) as with the distance from Definition 2.11.\nWhen it comes to the contraction of action laws, and then changing the accessibility relations, however, this cardinality-based distance does not seem to fit with the intuitions. To witness, consider the model M in Figure 10, in which the law p1 → 〈a〉> is true.\nThen, the models resulting from contraction of p1 → 〈a〉> in the model M will be M−p1→〈a〉> = {M ′,M ′′}, where M ′ and M ′′ are as depicted in Figure 11.\nNote that M ′′ is an intended contracted model: 6|=M ′′\np1 → 〈a〉>. However, with the cardinality-based distance above we will get {M }−p1→〈a〉> = {{M ,M\n′}}. We do not have {M ,M ′′} in the result since M ′ ≤M M ′′: in M ′ only one transition has been removed, while in M ′′ two."
    }, {
      "heading" : "4.2 Minimal Change v. Cautiousness",
      "text" : "As usually done in the literature on classical belief revision, when defining a (traditional) theory change operator one must always make the fundamental decision which of two opposing principles should be the guiding one: that of minimizing change, which leads to strong modified theories, versus that of cautious change, which leads to weak theories. In this regard, one might argue that our action theory change operators are incoherent. That is because we adopt the first principle for the contraction of effect and executability laws, but then the latter principle for contraction of static laws.3\nIt turns out, however, that this view is debatable. From a different perspective one can think of our three operators as being coherent in the following sense: all of them perform a version of maxichoice, namely the addition of precisely a single model to the original models of the theory.4\nIn any case, in the sequel we give a justification for the behavior of our operators and show that there can be no such an operator for contraction of static laws that is not cautious while being coherent with the operators for contraction of effect and executability laws. (We say that an operator for static law contraction is coherent with respect to our operators for contraction of effect and executability laws if it also performs minimal change with respect to the other types of laws, i.e., if it preserves effect and executability laws.)\nWhere does the claimed ‘incoherence’ come from? Here our contention is that it is inherent to the problem of action theory change itself, and not a flaw of our definitions. The justification is as follows. Remembering the intuitions for our semantic constructions, it is easy to see that for the contraction of executability laws knowledge about some action’s feasibility (the transitions) is removed and only that. For the contraction of effect laws, a\n3. We thank an anonymous referee for having pointed this out. 4. We thank another anonymous referee for having pointed this out.\npiece of knowledge is also added (the new transition), but notice that this one is ‘guided’ by some given concrete extra information, namely the ¬ψ effect that we want to allow.\nNow, for the contraction of static laws, notice that no extra information whatsoever is given about the new possible state which could guide the addition of some knowledge about the feasibility of an action. The only thing that we know is that the new world should exist. Nothing more is said about whether there should be any transition leaving it or arriving at it at all. This is a property of the problem per se: the problem of removing a static law does not mention executabilities, and it is just reflected by our operator.\nTherefore, such an ‘incoherence’ is already in the problem, and as such it is not surprising to find it again in the proposed operators. These are designed to do what they are allowed to do given the constraints of the problem. Should we have more information in our hands regarding the new added state, a coherent version of the corresponding operator would have been defined. (See the discussion in Section 9 for a comparison with Eiter et al.’s 2005 constraint-based method for update of action theories.)\nProposition 4.1 There is no minimal change operator for static law contraction that is coherent with our operators for contraction of effect and executability laws.\nProof: Suppose that we have a minimal change based (non-cautious) contraction operator for static laws that is coherent with the other operators. This operator must be such that when contracting ϕ ∈ Fml only formulas of the type of ϕ are removed (otherwise it is not coherent with the other operators). This means that both effect and executability laws should be preserved. In particular, this operator is coherent in this respect when contracting the formula p1 → ¬p2 from model M in Figure 12 below.\nFollowing the intuition about contraction of Boolean formulas, a new world, viz. the valuation {p1, p2}, is added to W in M . Because the operator in question is non-cautious, a transition should also be added from the new added world {p1, p2} in M , in order to preserve the executability law p1 → 〈a〉>. Also because the operator is non-cautious, the effect law p1 → [a]¬p1 should be preserved. Hence, such a new transition should point neither to world {p1,¬p2} nor to {p1, p2} itself. Now, if we direct the new transition to {¬p1, p2} (the only world that is left), we get the model M ′ in Figure 12.\nObserve that |=M (¬p1 ∨ p2) → [a]p1. However, 6|= M ′\n(¬p1 ∨ p2) → [a]p1: the operator makes us lose an effect law! This means that it is not coherent. In order for us to keep this effect law, the only option is not to direct the new transition to {¬p1, p2}. But then, no transition is added at all: the operator is cautious! Hence there is no such an operator for static law contraction that is based on minimal change and is coherent with the operators for the other laws. 2\nThe result above supports our contention that we cannot have a coherent set of minimal change operators for action theory contraction. This is a general result and it holds not only for modal-based approaches like ours, but it applies to any framework for reasoning about actions which is based on transition systems and which also allows for the three types of laws that we consider here.\nFurthermore, the result also illustrates well the difference between action theory change and classical belief change. To witness, even though contraction of static laws amounts to propositional contraction of Boolean formulas, it remains a special case of the latter. The reason is that when contracting static laws one always asks “what happens to the laws of other types?”, a question that is not asked in classical propositional contraction for the obvious reason that there simply there are no other types of formulas."
    }, {
      "heading" : "5. Syntactic Operators for Contraction of Laws",
      "text" : "Once having given a semantic construction for action theory change, we now turn our attention to the definition of syntactic operators for changing sets of formulas describing a dynamic domain.\nAs Nebel (1989) says, “[. . . ] finite bases usually represent [. . . ] laws, and when we are forced to change the theory we would like to stay as close as possible to the original [. . . ] base.” Hence, besides the definition of syntactical operators, we should also guarantee that they perform minimal change at the theory level. By that we mean that the resulting theory should of course not entail the law we want to contract the theory with, and it should also preserve as much of the previous knowledge as possible when performing syntactical manipulations on the laws in the original theory. Ideally, from the knowledge engineer’s perspective, the modified theory should also keep a certain degree of resemblance with the original one: the resulting laws should be slight modifications of the relevant ones in the original action theory.\nBy T−Φ we denote in the sequel the result of contracting a law Φ from the set of laws T."
    }, {
      "heading" : "5.1 Contracting Executability Laws",
      "text" : "For the case of contracting an executability law ϕ → 〈a〉> from an action theory, first we have to ensure that action a keeps its executability state in all those contexts where the antecedent ¬ϕ holds, if that is the case. We achieve that by strengthening the antecedents of the relevant executability laws. Second, in order to get minimality, we must make a executable in some contexts where ϕ is true, viz. all ϕ-worlds but one. Since there are possibly many different alternatives for that, this means that we can have several action theories as outcome. Algorithm 1 gives a syntactical operator to achieve this.\nIt can be easily checked that Algorithm 1 always terminates: the input action theory T is always finite; from finiteness of Prop follows that of atm(π), for any π ∈ IP(S ∧ ϕ). Moreover, the entailment problem of multimodal K is decidable (Harel et al., 2000), as is that of classical propositional logic. Therefore contracting executability laws is decidable.\nAlgorithm 1: Contraction of an Executability Law\nInput: T, ϕ→ 〈a〉> Output: T−ϕ→〈a〉> /* set of theories output to the knowledge engineer */ begin1 T−ϕ→〈a〉> := ∅2 if T |=\nKn ϕ→ 〈a〉> and S 6|= CPL ¬ϕ then3 foreach π ∈ IP(S ∧ ϕ) do4 forall A ⊆ atm(π) do5\nϕA := ∧\npi∈atm(π) pi∈A\npi ∧ ∧\npi∈atm(π) pi /∈A\n¬pi /* extend π to a valuation */ 6\nif S 6|= CPL (π ∧ ϕA)→ ⊥ then /* it is an allowed state */7 /* construct a theory that is weaker for that state */ T ′ := (T \\ Xa) ∪ {(ϕi ∧ ¬(π ∧ ϕA))→ 〈a〉> : ϕi → 〈a〉> ∈ Xa}8 T−ϕ→〈a〉> := T − ϕ→〈a〉> ∪ {T ′}9\nelse10 T−ϕ→〈a〉> := {T}11 return T−ϕ→〈a〉>12 end13\nIt is straightforward to see that Algorithm 1 above can be adapted to Situation Calculus action theories as well. The crucial point however would be its termination, since entailment in the Situation Calculus is in general undecidable.\nIn our running example, contracting the executability law token → 〈buy〉> from the action theory T would give us T−token→〈buy〉> = {T ′ 1 , T ′2 , T ′3}, where:\nT ′1 =  coffee→ hot,¬coffee→ [buy]coffee, token→ [buy]¬token,¬token→ [buy]⊥, coffee→ [buy]coffee, hot→ [buy]hot, (token ∧ (¬coffee ∨ ¬hot))→ 〈buy〉>  T ′2 =  coffee→ hot,¬coffee→ [buy]coffee, token→ [buy]¬token,¬token→ [buy]⊥, coffee→ [buy]coffee, hot→ [buy]hot, (token ∧ (coffee ∨ ¬hot))→ 〈buy〉> \nT ′3 =  coffee→ hot,¬coffee→ [buy]coffee, token→ [buy]¬token,¬token→ [buy]⊥, coffee→ [buy]coffee, hot→ [buy]hot, (token ∧ (coffee ∨ hot))→ 〈buy〉>  Now all the knowledge engineer has to do is choose which theory is more in line with\nher intuitions and implement the required changes (cf. Figure 5)."
    }, {
      "heading" : "5.2 Contracting Effect Laws",
      "text" : "When contracting an effect law ϕ→ [a]ψ from an action theory T, intuitively we should contract those effect laws that preclude ¬ψ in target worlds. In order to cope with minimality, we must change only those laws that are relevant to the unwanted ϕ→ [a]ψ.\nLet (Eϕ,ψa )1, . . . , (Eϕ,ψa )n denote minimal subsets (with respect to set inclusion) of Ea such that S , (Eϕ,ψa )i |=Knϕ→ [a]ψ, for 1 ≤ i ≤ n. In other words, each (E ϕ,ψ a )i is a support set for the effect law ϕ → [a]ψ in T. To make a parallel with the terminology usually adopted in the belief change community, we shall see each (Eϕ,ψa )i as a special type of kernel (Hansson, 1994) for the formula ϕ→ [a]ψ.\nAccording to Herzig and Varzinczak (2007), given any action theory one can always ensure that at least one support set for ϕ→ [a]ψ exists. Now let\nE−a = ⋃\n1≤i≤n (Eϕ,ψa )i\nThe laws in E−a will serve as guidelines to get rid of [a]ψ in each ϕ-world allowed by the theory T: they are the effect laws to be weakened to allow for 〈a〉¬ψ in some ϕ-contexts. This resembles classical kernel contraction (Hansson, 1994): finding minimal sets implying a formula and changing them. A crucial difference, however, is that instead of completely removing a formula from each kernel, what we do here is weaken the laws.\nWhen modifying the support sets, the first thing we must do is to ensure that action a still has effect ψ in all those contexts in which ϕ does not hold, if that is the case. This means we shall weaken the laws in Eϕ,ψa specializing them to ¬ϕ. Now, we need to preserve all old effects in all ϕ-worlds but one. To achieve that we specialize the above laws to each possible valuation (maximal consistent conjunction of literals) satisfying ϕ but one. Then, in the left ϕ-valuation, we must ensure that action a has either its old effects or ¬ψ as outcome. We achieve that by weakening the consequent of the laws in E−a . Finally, in order to get minimal change, we must ensure that all literals in this ϕ-valuation that are not forced to change in ¬ψ-worlds should be preserved. We do this by stating an effect law of the form (ϕk ∧ `) → [a](ψ ∨ `), where ϕk is the above ϕ-valuation. The reason this is needed is clear: there can be several ¬ψ-valuations, and as far as we want at most one to be reachable from the ϕk-world, we should force it to be the one whose difference to this ϕk-valuation is minimal.\nIn Situation Calculus terms, all these syntactical operations would correspond to strengthening the right-hand side of the relevant successor state axioms and/or weakening their\nleft-hand side. Alternatively, the same can be done with the original effect axioms, then recompiling them again into new successor state axioms afterwards.\nThe output of the operations described above will be a set of action theories which will be output to the knowledge engineer. Algorithm 2 below gives the operator.\nAlgorithm 2: Contraction of an Effect Law\nInput: T, ϕ→ [a]ψ Output: T−ϕ→[a]ψ /* set of theories output to the knowledge engineer */ begin1 T−ϕ→[a]ψ := ∅2 if T |=\nKn ϕ→ [a]ψ and S 6|= CPL ¬ϕ then3 foreach π ∈ IP(S ∧ ϕ) do4 forall A ⊆ atm(π) do5\nϕA := ∧\npi∈atm(π) pi∈A\npi ∧ ∧\npi∈atm(π) pi /∈A\n¬pi /* extend π to a valuation */ 6\nif S 6|= CPL (π ∧ ϕA)→ ⊥ then /* it is an allowed state */7 foreach π′ ∈ IP(S ∧ ¬ψ) do8 T ′ := T \\ E−a /* the support sets will be weakened */9 T ′ := T ′ ∪ {(ϕi ∧ ¬(π ∧ ϕA))→ [a]ψi : ϕi → [a]ψi ∈ E−a }10 /* allow for ¬ψ after a in this state */ T ′ := T ′ ∪ {(ϕi ∧ π ∧ ϕA)→ [a](ψi ∨ π′) : ϕi → [a]ψi ∈ E−a }11 forall L ⊆ Lit do12\nif S |= CPL (π ∧ϕA)→ ∧ `∈L ` and S 6|=CPL(π ′ ∧ ∧ `∈L `)→ ⊥ then13 foreach ` ∈ L do14 if T 6|=\nKn (π ∧ ϕA ∧ `)→ [a]¬` or ` ∈ π′ then15 T ′ := T ′ ∪ {(π ∧ ϕA ∧ `)→ [a](ψ ∨ `)}16\nT−ϕ→[a]ψ := T − ϕ→[a]ψ ∪ {T ′}17\nelse18 T−ϕ→[a]ψ := {T}19 return T−ϕ→[a]ψ20 end21\nAgain, from the finiteness of the action theory T and that of atm(π), for any π ∈ IP(S ∧ ϕ), and from the decidability of multimodal K (Harel et al., 2000) as well as that of classical propositional logic, it can be easily verified that Algorithm 2 always terminates.\nTherefore, contracting effect laws is decidable. Of course, the complexity of computing all the support sets as well as the prime implicants is quite high (see Section 5.4 later on for a discussion on this matter).\nFor an example of execution of Algorithm 2, let us suppose that we want to contract the effect law token→ [buy]hot from the action theory T of our running example. First we have to compute the support sets for token → [buy]hot in T (i.e., the minimal subsets of Ebuy which together with S entail token→ [buy]hot). These are the following:\n(E token,hotbuy )1 = { coffee→ [buy]coffee, ¬coffee→ [buy]coffee } (E token,hotbuy )2 = { hot→ [buy]hot, ¬coffee→ [buy]coffee\n} Now for each possible context in which the antecedent token is the case, we have to\nweaken the effect laws in E−buy = (E token,hot buy )1 ∪ (E token,hot buy )2. Since S = {coffee→ hot}, such contexts are token ∧ coffee ∧ hot, token ∧ ¬coffee ∧ ¬hot and token ∧ ¬coffee ∧ hot. For token ∧ coffee ∧ hot: Algorithm 2 replaces in T the laws from E−buy with (coffee ∧ ¬(token ∧ coffee ∧ hot))→ [buy]coffee, (hot ∧ ¬(token ∧ coffee ∧ hot))→ [buy]hot,\n(¬coffee ∧ ¬(token ∧ coffee ∧ hot))→ [buy]coffee  so that we preserve their effects in all possible contexts but token ∧ coffee ∧ hot. Now, in order to preserve some effects in token ∧ coffee ∧ hot-contexts while allowing for reachable ¬hot-worlds, the algorithm adds the laws:{\n(token ∧ coffee ∧ hot)→ [buy](coffee ∨ ¬hot), (token ∧ coffee ∧ hot)→ [buy](hot ∨ ¬coffee) } Now, we search all possible combinations of laws from Ebuy that apply on token∧coffee∧hot contexts and find token→ [buy]¬token. Because ¬token must be true after every execution of action buy, we do not state the law (token ∧ coffee ∧ hot) → [buy](hot ∨ token), and end up with the following theory:\nT ′1 = \ncoffee→ hot, token→ 〈buy〉>, token→ [buy]¬token,¬token→ [buy]⊥,\n(coffee ∧ ¬(token ∧ coffee ∧ hot))→ [buy]coffee, (hot ∧ ¬(token ∧ coffee ∧ hot))→ [buy]hot,\n(¬coffee ∧ ¬(token ∧ coffee ∧ hot))→ [buy]coffee, (token ∧ coffee ∧ hot)→ [buy](coffee ∨ ¬hot), (token ∧ coffee ∧ hot)→ [buy](hot ∨ ¬coffee)  On the other hand, if in our language we also had an atom p with the same theory T, then we should have added a law (token∧ coffee∧ hot∧ p)→ [buy](hot∨ p) to meet minimal change by preserving effects that are not relevant to ¬ψ (cf. Definition 3.4).\nThe execution for contexts token∧¬coffee∧¬hot and token∧¬coffee∧hot are analogous and the algorithm ends with T−token→[buy]hot = {T ′ 1 , T ′2 , T ′3}, where:\nT ′2 = \ncoffee→ hot, token→ 〈buy〉>, token→ [buy]¬token,¬token→ [buy]⊥,\n(coffee ∧ ¬(token ∧ ¬coffee ∧ ¬hot))→ [buy]coffee, (hot ∧ ¬(token ∧ ¬coffee ∧ ¬hot))→ [buy]hot,\n(¬coffee ∧ ¬(token ∧ ¬coffee ∧ ¬hot))→ [buy]coffee, (token ∧ ¬coffee ∧ ¬hot)→ [buy](coffee ∨ ¬hot)\n\nT ′3 = \ncoffee→ hot, token→ 〈buy〉>, token→ [buy]¬token,¬token→ [buy]⊥,\n(coffee ∧ ¬(token ∧ ¬coffee ∧ hot))→ [buy]coffee, (hot ∧ ¬(token ∧ ¬coffee ∧ hot))→ [buy]hot,\n(¬coffee ∧ ¬(token ∧ ¬coffee ∧ hot))→ [buy]coffee, (token ∧ ¬coffee ∧ hot)→ [buy](hot ∨ ¬coffee), (token ∧ ¬coffee ∧ hot)→ [buy](coffee ∨ ¬hot)  Looking at Figure 8, we can see the correspondence between these theories and their respective models. It is now up to the knowledge engineer to look at these action theories and pick up the one corresponding to her expectations."
    }, {
      "heading" : "5.3 Contracting Static Laws",
      "text" : "Finally, in order to contract a static law from a theory, we can use any contraction/erasure operator for classical logic that is available in the literature. Because contracting static laws means admitting new possible states (cf. the semantics), just modifying the set S of static laws may not be enough for the multimodal logic case. However, since in general we do not necessarily know the behavior of the actions in a new discovered state of the world, a careful approach is to change the theory so that all action laws remain the same in the contexts where the contracted law is the case. (The reader is invited to see that in the Situation Calculus by allowing a new situation to exist one may need to change the precondition axioms as well, which means that the problem here described is independent of the logical formalism chosen.)\nIn our scenario example, if in contracting the static law coffee → hot the knowledge engineer is not really sure whether action buy is still executable or not, then she should weaken the set of executability laws specializing them to the context coffee → hot, and make buy a priori inexecutable in all ¬(coffee → hot)-contexts. It is worth noting that this is in line with the assumption commonly made in the RAC community according to which executability laws are by and large much more likely to be incorrect right from the beginning (Shanahan, 1997). Therefore extrapolating them to previously unknown states might (and in all probability will) result in the propagation of errors and, even worse, the loss of effect laws (remember the discussion in Sections 3.3 and 4.2). The operator given in Algorithm 3 formalizes this.\nAlgorithm 3: Contraction of a Static Law\nInput: T, ϕ Output: T−ϕ /* set of theories output to the knowledge engineer */ begin1 T−ϕ := ∅2 if S |=\nCPL ϕ then3 /* call classical contraction S ϕ of S with ϕ */ foreach S− ∈ S ϕ do4\n/* build a theory preserving executability in old states */\nT ′ := ((T \\ S ) ∪ S−) \\ Xa5 T ′ := T ′ ∪ {(ϕi ∧ ϕ)→ 〈a〉> : ϕi → 〈a〉> ∈ Xa} ∪ {¬ϕ→ [a]⊥}6 T−ϕ := T−ϕ ∪ {T ′}7\nelse8 T−ϕ := {T}9\nreturn T−ϕ10 end11\nIn our running coffee example, contracting the static law coffee → hot from the action theory T produces T−coffee→hot = {T ′ 1 , T ′2}, where\nT ′1 =  ¬(¬token ∧ coffee ∧ ¬hot), (token ∧ coffee→ hot)→ 〈buy〉>, ¬coffee→ [buy]coffee, token→ [buy]¬token, ¬token→ [buy]⊥, coffee→ [buy]coffee,\nhot→ [buy]hot, (coffee ∧ ¬hot)→ [buy]⊥\n\nT ′2 =  ¬(token ∧ coffee ∧ ¬hot), (token ∧ coffee→ hot)→ 〈buy〉>, ¬coffee→ [buy]coffee, token→ [buy]¬token, ¬token→ [buy]⊥, coffee→ [buy]coffee,\nhot→ [buy]hot, (coffee ∧ ¬hot)→ [buy]⊥  Observe that the effect laws are not affected at all by the change: as far as we do not pronounce ourselves about the executability of some action in the new added world, all the effect laws remain true in it.\nIf the knowledge engineer is not happy with (coffee ∧ ¬hot)→ [buy]⊥, she can contract this formula from the theory using Algorithm 2. Ideally, besides stating that buy is executable in the context coffee ∧ ¬hot, we should want to specify its outcome in this context as well. For example, we could want (coffee ∧ ¬hot) → 〈buy〉hot to be true in the result. This requires theory revision. See Section 8 for the semantics of such an operation."
    }, {
      "heading" : "5.4 Complexity Issues",
      "text" : "While terminating, our algorithms come with a considerable computational cost: the Knentailment tests with global axioms in the beginning of the algorithms and inside the loops are known to be exptime-complete (Harel et al., 2000). The computation of all possible contexts allowed by the theory, namely ∧ pi∈atm(π)\npi∈A pi ∧\n∧ pi∈atm(π)\npi /∈A\n¬pi, for all A ⊆ atm(π) and\nall π ∈ IP(S ∧ ϕ), is clearly exponential. Moreover, the computation of prime implicants IP(.) might result in exponential growth (Marquis, 2000).\nGiven that theory change can be carried out offline, from the perspective of the knowledge engineer what is more important is the complexity of the size of the computed contracted theories: the number of formulas as well as the length of the modified ones. This plays an important role when deciding among several output theories which one corresponds to the knowledge engineer’s expectations. In that matter, whereas the length of new added formulas may increase exponentially, with respect to the number of laws our results are positive: the size of the computed contracted theories is linear in the size of the original action theory. (Remember that card(X) denotes the number of elements in set X.)\nProposition 5.1 Let T be an action theory, ϕ → 〈a〉> an executability law, and T ′ ∈ T−ϕ→〈a〉>. Then card(T ′) = card(T).\nProof: If T 6|= Kn ϕ → 〈a〉>, then T−ϕ→〈a〉> = {T}, and then T ′ = T, from which the result follows. Suppose T |=\nKn ϕ → 〈a〉> is the case. Then T ′ is such that T ′ = (T \\ Xa) ∪ Xa′,\nwhere Xa′ is obtained from Xa in such a way that (ϕi ∧ ϕ′) → 〈a〉> ∈ Xa′ if and only if ϕi → 〈a〉> ∈ Xa, for a fixed ϕ′. From this it follows card(Xa′) = card(Xa). Now, card((T \\ Xa) ∪ Xa′) = card(T \\ Xa)+card(Xa′)−card((T \\ Xa) ∩ Xa′) = card(T)−card(Xa)+ card(Xa′)− card(∅) = card(T)− card(Xa) + card(Xa)− 0 = card(T). 2\nProposition 5.2 Let T be an action theory, ϕ → [a]ψ an effect law, and T ′ ∈ T−ϕ→[a]ψ. Then card(T ′) ≤ card(T) + card(E−a ) + card(Lit).\nProof: If T 6|= Kn ϕ → [a]ψ, then T−ϕ→[a]ψ = {T}, and then T ′ = T, from what we get card(T ′) = card(T). Since card(T) ≤ card(T) + card(E−a ) + card(Lit), the result follows. Suppose that T |=\nKn ϕ→ [a]ψ is the case. Then T ′ = (T \\ E−a ) ∪ Ea′ ∪ Ea′′ ∪ Fa, where:\n• Ea′ and Ea′′ are both obtained from E−a in such a way that (ϕi ∧ ¬ϕ′) → [a]ψi ∈ Ea′ and (ϕi ∧ ϕ′)→ [a](ψi ∧ ψ′) ∈ Ea′′ if and only if ϕi → [a]ψi ∈ E−a , for fixed ϕ′, ψ′;\n• Fa ⊆ {(ϕ′ ∧ `)→ [a](ψ ∨ `) : ` ∈ Lit}, for a fixed ϕ′; and\n• T, Ea′, Ea′′,Fa are pairwise disjoint.\nHence card(Ea′) = card(Ea′′) = card(E−a ), and card(Fa) ≤ card(Lit). Then card(T ′) = card(T \\ E−a ) + card(Ea′) + card(Ea′′) + card(Fa) = card(T \\ E−a ) + card(E−a ) + card(E−a ) + card(Fa) = card(T) − card(E−a ) + card(E−a ) + card(E−a ) + card(Fa) = card(T) + card(E−a ) + card(Fa) ≤ card(T) + card(E−a ) + card(Lit). 2\nGiven the arbitrary choice of the contraction operator for static laws, without loss of generality we can resort to a slightly modified version of it, viz. one that always gives us as result a set of static laws with the same cardinality as the original S . (This is possible since, contrary to E and X , a conjunction of static laws is still a static law, with no further rewriting.) By agreeing on that, the following proposition is straightforward:\nProposition 5.3 Let T be an action theory, ϕ a static law, and T ′ ∈ T−ϕ . Then card(T ′) = card(T) + 1.\nPropositions 5.1–5.3 are positive results: if the knowledge engineer can deal with the original action theory, then she will be able to deal with the output of the algorithms. (Observe that for a given T ′ all the conditional frame axioms added to Fa in the contraction of an effect law can be ‘factored’ into a single law, so that the resulting theory has a cardinality of at most card(T) + card(E−a ) + 1.)\nWe finish this section by observing that the size of T−Φ , the set of resulting contracted theories, depends solely on the set of static laws plus the law we contract T with:\nProposition 5.4 Let T be an action theory, and let Φ be a law such that T |= Kn Φ. Then\n• card(T−Φ ) = card(S ϕ), if Φ is ϕ\n• card(T−Φ ) = card(val(S ∪ {ϕ})), if Φ is either ϕ→ 〈a〉> or ϕ→ [a]ψ.\nProof: The proof follows straightforwardly from the outermost loops in Algorithms 1–3. 2"
    }, {
      "heading" : "6. Correctness of the Operators",
      "text" : "We now address the correctness of our algorithms with respect to our semantics for contraction. Correctness here is understood as completeness and adequacy. Adequacy means that the algorithms output only theories whose models result from our semantic modifications of models of the original theory. Conversely, completeness says that every model resulting from the semantic modifications of models of the original theory is indeed a model of some theory output by the algorithm."
    }, {
      "heading" : "6.1 Challenges to Completeness and Adequacy",
      "text" : "Let the theory T = {p1 → 〈a〉>, (¬p1 ∨ p2) → [a]⊥, [a]¬p2} and consider its model M depicted in Figure 13. (Notice that T |=\nKn ¬(p1 ∧ p2).) When contracting p1 → [a]¬p2 in M ,\nwe get M ′ in Figure 13. Now contracting p1 → [a]¬p2 from T using Algorithm 2 gives T−p1→[a]¬p2 = {T ′}, where\nT ′ =  p1 → 〈a〉>, (¬p1 ∨ p2)→ [a]⊥,\n(p1 ∧ ¬p2)→ [a](¬p2 ∨ p2), (p1 ∧ ¬p2)→ [a](¬p2 ∨ p1)  Notice that the formula (p1 ∧ ¬p2) → [a](¬p2 ∨ p1) is put in T ′ by Algorithm 2 because there is {p1} ⊆ Lit such that S 6|=CPL (p1 ∧ p2) → ⊥ and T 6|=Kn (p1 ∧ ¬p2) → [a]¬p1. It is\nclearly the case that 6|=M ′ T ′ and no theory in T−p1→[a]¬p2 has M ′ as model. This means that there are theories for which the contraction operators are not complete.\nThis issue arises because Algorithm 2 tries to allow a transition from the p1∧¬p2-world to a p2-world that is closest to it, viz. {p1, p2}, but has no way of knowing that such a world does not exist. A remedy for that is replacing the test T 6\nK̀n (π′ ∧ ∧ `∈L `) → ⊥ for\nS 6 C̀PL (π′∧ ∧ `∈L `)→ ⊥, but that would increase even more the complexity of the algorithm. A better option would be to have S ‘complete enough’ to allow the algorithm to determine the worlds to which a new transition could exist.\nThe other way round, it does not hold in general that the models of each T ′ ∈ T−Φ result from the semantic contraction of models of T by Φ. To see why suppose that there is only one atom p and one action a, and consider the action theory T = {p → [a]⊥, 〈a〉>}. The only model of T is M = 〈{{¬p}}, {({¬p}, {¬p})}〉 in Figure 14.\nFrom our definitions, contract(M , p→ 〈a〉>) = {M }. (There is no p-world in M from which to remove an arrow.) On the other hand, T−p→〈a〉> is the singleton {T\n′} such that T ′ = {p → [a]⊥,¬p → 〈a〉>}. Then M ′ = 〈{{¬p}, {p}}, ({¬p}, {¬p})〉 in Figure 14 is a model of the resulting contracted theory. Clearly, M ′ does not result from the semantic contraction of p→ 〈a〉> from M : while ¬p is valid in the contraction of the models of T, it is not valid in the models of T ′. This means that there are theories for which the operators are not adequate.\nThis problem occurs because, in our example, the worlds that are forbidden by T, e.g. {p}, are not preserved as such in T ′. When contracting an executability or an effect law, we are not supposed to change the possible worlds of a theory (cf. Section 3).\nFortunately correctness of the algorithms with respect to our semantics can be established for those action theories whose S is maximal, i.e., the set of static laws in S alone\ncharacterize what worlds are possible in the models of the theory. This is the principle of modularity (Herzig & Varzinczak, 2005b) and we briefly review it in the next section."
    }, {
      "heading" : "6.2 Modular Action Theories",
      "text" : "A quite useful, albeit simple, property of domain descriptions in reasoning about actions is that of action theory modularity (Herzig & Varzinczak, 2005b).\nDefinition 6.1 (Modularity) An action theory T is modular if and only if for every Boolean formula ϕ ∈ Fml, if T |=\nKn ϕ, then S |= CPL ϕ.\nFor an example of a non-modular theory, let us suppose that the action theory T of our coffee machine scenario were stated as\nT =  coffee→ hot, 〈buy〉>, ¬coffee→ [buy]coffee,\ntoken→ [buy]¬token,¬token→ [buy]⊥, coffee→ [buy]coffee, hot→ [buy]hot  The modified law is underlined: we have (in this case wrongly) stated that the agent can always buy at the machine. Then T |=\nKn token, but S 6|= CPL token.\nSince the underlying multimodal logic is independently axiomatized (see Section 2.1), we can use the algorithms given by Herzig and Varzinczak (2005b) to check whether an action theory satisfies the principle of modularity. Whenever this is not the case, the algorithms return the Boolean formulas entailed by the theory which are not consequences of S alone. For the theory T above, they would return {token}: as we have stated 〈buy〉>, from this and the inexecutability law ¬token → [buy]⊥ we have that T |=\nKn token. Because S 6|= CPL token,\ntoken is what is called an implicit static law (Herzig & Varzinczak, 2004) of the action theory T.5\nModular action theories have several interesting computational properties. For example, consistency can be checked by just checking consistency of the static laws in S : if T is modular, then T |=\nKn ⊥ if and only if S |= CPL ⊥. Deduction of effect laws does not\nneed the executability ones and vice versa. Deduction of an effect of a sequence of actions a1; . . . ; an (prediction) does not need to take into account the effect laws for actions other than a1, . . . , an. This applies in particular to plan validation when deciding whether 〈a1; . . . ; an〉ϕ is the case.\nModularity is not an exclusive property of action theories formalized in Kn: similar notions have also been investigated for different contexts in other formalisms, like regulation consistency in deontic logic (Cholvy, 1999), Situation Calculus (Herzig & Varzinczak, 2005a), DL ontologies (Herzig & Varzinczak, 2006), dynamic logic (Zhang, Chopra, & Foo, 2002) and also in the Fluent Calculus (Thielscher, 2010). For more details on modularity in Kn action theories, as well as its role in the presence of a solution to the frame and ramification problems, see the work by Varzinczak (2006).\n5. Implicit static laws are closely related to veridical paradoxes (Quine, 1962). It turns out that sometimes they are intuitive, but sometimes they are not. For a deep discussion on implicit static laws, see the work by Varzinczak (2006).\nAnother interesting property of modular action theories is the following:\nTheorem 6.1 T is modular if and only if T has a canonical model.\nProof: Let Mcan = 〈Wcan,Rcan〉 be the canonical frame of T.\n(⇒): By definition, Mcan is such that |= McanS ∧ E . It remains to show that |=McanX . Let ϕi → 〈a〉> ∈ Xa, and let w ∈ Wcan be such that |= Mcan\nw ϕi. Therefore for all ϕj ∈ Fml such\nthat T |= Kn ϕj → [a]⊥, we must have 6|=\nMcan w ϕj , because T |=Kn¬(ϕi ∧ϕj), and as T is modular,\nS |= CPL ¬(ϕi ∧ ϕj), and hence |= Mcan¬(ϕi ∧ ϕj). Then by the construction of Mcan, there is some w′ ∈Wcan such that |= Mcan\nw′ ψ for all ϕ→ [a]ψ ∈ Ea such that |=\nMcan w ϕ. Thus Ra(w) 6= ∅\nand |=Mcanϕi → 〈a〉>.\n(⇐): Suppose T is not modular. Then there must be some ϕ ∈ Fml such that T |= Kn ϕ and S 6|= CPL\nϕ. This means that there is v ∈ val(S ) such that v 6 ϕ. As v ∈Wcan (because Wcan contains all possible valuations of S ), Mcan is not a model of T. 2"
    }, {
      "heading" : "6.3 Correctness Under Modularity",
      "text" : "As shown by Herzig and Varzinczak (2007), given an action theory formalized with any framework available in the literature allowing for the expression of our three basic types of laws, it is always possible to ensure modularity. Moreover, as we are going to see in the sequel (cf. Section 7.2), it has to be computed at most once during the evolution of the action theory. Hence, relying on modular theories is not a limitation at all to our approach.\nThe following theorem establishes that under the assumption that the action theory T is modular, the semantic contraction of a formula Φ from the set of models of T produces models of some contracted theory in T−Φ .\nTheorem 6.2 Let T be modular, and Φ be a law. For all M′ ∈ M−Φ such that |= M T for every M ∈M, there is T ′ ∈ T−Φ such that |= M ′T ′ for every M ′ ∈M′.\nProof: See Appendix A. 2\nThe next theorem establishes the other way round: under modularity models of theories in T−Φ are all models of the semantic contraction of Φ from models of T.\nTheorem 6.3 Let T be modular, Φ a law, and T ′ ∈ T−Φ . For all M ′ such that |= M ′T ′, there is M′ ∈M−Φ such that M ′ ∈M′ and |= MT for every M ∈M.\nProof: See Appendix B. 2\nWith these two theorems we get the correctness of our operators:\nCorollary 6.1 Let T be modular, Φ a law, and T ′ ∈ T−Φ . Then T ′ |=KnΨ if and only if |= M ′ Ψ for every M ′ ∈M′ such that M′ ∈M−Φ for some M such that |= MT for all M ∈M.\nProof: (⇒): Let M ′ be such that |=M\n′ T ′. By Theorem 6.3, there isM′ ∈M−Φ such that M ′ ∈M′\nfor some M such that |=MT for all M ∈M. From this and T ′ |= Kn Ψ , we have |=M\n′ Ψ .\n(⇐): Suppose T ′ 6|= Kn Ψ . (We show that there is some model M ′ ∈M′ such thatM′ ∈M−Φ for some M with |=MT for all M ∈M, and 6|=M ′ Ψ .)\nGiven that T is modular, by Lemma B.1 T ′ is modular, too. Then, by Lemma B.3, there is some M ′ = 〈val(S ′),R′〉 such that 6|=M ′ Ψ . Clearly |=M ′ T ′, and from Lemma B.4 the result follows. 2"
    }, {
      "heading" : "7. Assessment of Postulates for Change",
      "text" : "Do our action theory change operators satisfy the classical postulates for change? Before answering this question, one should ask: do our operators behave like revision or update operators? We here address this issue and then show which postulates for theory change are satisfied by our definitions."
    }, {
      "heading" : "7.1 Contraction or Erasure?",
      "text" : "The distinction between revision/contraction and update/erasure for classical theories is historically controversial in the literature. The same is true for the case of modal theories describing actions and their effects. We here rephrase Katsuno and Mendelzon’s definitions (1992) in our terms so that we can see to which one our method is closer.\nIn Katsuno and Mendelzon’s view, contracting a law Φ from an action theory T intuitively means that the description of the possible behavior of the dynamic world T must be adjusted to the possibility of Φ being false. This amounts to selecting from the models of ¬Φ those that are closest to models of T and allow them as models of the result.\nIn contrast, update methods select, for each model M of T, the set of models of Φ that are closest to M . Erasing Φ from T means adding models to T; for each model M , we add all those models closest to M in which Φ is false. Hence, from our constructions so far it seems that our operators are closer to update than to revision.\nMoreover, according to Katsuno and Mendelzon’s view (1992), our change operators would also be classified as update because we make modifications in each model independently, i.e., without changing other models.6 Besides that, in our setting a different ordering on the resulting models is induced by each model of the theory T (see Definitions 3.3, 3.7 and 3.10), which according to Katsuno and Mendelzon is a typical property of an update/erasure method.\nNevertheless, things get quite different when it comes to the postulates for theory change."
    }, {
      "heading" : "7.2 The Postulates",
      "text" : "In this section we analyze the behavior of our action theory change operators with respect to AGM-like postulates. Here we follow Katsuno and Mendelzon’s presentation of the\n6. Even if when contracting an effect law from one particular model we need to check the other models of the theory, those are not modified.\npostulates to assess both contraction and erasure. Let T = S ∪ E ∪ X denote an action theory and Φ denote a law.\nMonotonicity Postulate: T |= Kn T ′, for all T ′ ∈ T−Φ .\nThis postulate is our version of Katsuno and Mendelzon’s (C1) and (E1) postulates for contraction and erasure, respectively, and it is satisfied by our change operators. The proof is in Lemma A.1. Such a postulate is not satisfied by the operators proposed by Herzig et al. (2006): there when removing e.g. an executability law ϕ → 〈a〉> one may make ϕ→ [a]⊥ valid in all models of the resulting theory.\nPreservation Postulate: If T 6|= Kn Φ, then |= Kn T ↔ T ′, for all T ′ ∈ T−Φ .\nThis is Katsuno and Mendelzon’s (C2) postulate. Our operators satisfy it as far as whenever T 6|=\nKn Φ, then the models of the resulting theory are exactly the models of T,\nbecause these are the minimal models falsifying Φ.\nThe corresponding version of Katsuno and Mendelzon’s (E2) postulate about erasure, i.e., if T |=\nKn ¬Φ, then |= Kn T ↔ T ′, for all T ′ ∈ T−Φ , is clearly also satisfied by our operators\nas a special case of the postulate above. Satisfaction of (C2) indicates that our operators are closer to contraction than to erasure.\nSuccess Postulate: If T 6|= Kn ⊥ and 6|= Kn Φ, then T ′ 6|= Kn Φ, for all T ′ ∈ T−Φ .\nThis postulate is our version of Katsuno and Mendelzon’s (C3) and (E3) postulates. If Φ is a propositional ϕ ∈ Fml, our operators satisfy it, as long as the classical propositional change operator satisfies it as well. For the general case, however, as stated the postulate is not always satisfied. This is shown by the following example: let T = {¬p, 〈a〉>, p→ [a]⊥}. Note that T is modular and consistent. Now, contracting the (contingent) formula p→ 〈a〉> from T gives us T ′ = T. Clearly T ′ |=\nKn p→ 〈a〉>. This happens because, despite not being a\ntautology, p→ 〈a〉> is a ‘trivial’ formula with respect to T: since ¬p is valid in all T-models, p→ 〈a〉> is trivially true in these models (cf. end of Section 3.1).\nFortunately, for all those formulas that are non-trivial consequences of the theory, our operators guarantee success of contraction:\nTheorem 7.1 Let T be consistent, and Φ be an executability or an effect law such that S 6|=\nKn Φ. If T is modular, then T ′ 6|= Kn Φ for every T ′ ∈ T−Φ .\nProof: Let us suppose that there is some T ′ ∈ T−Φ such that T ′ |=KnΦ. Since T is modular, Corollary 6.1 tells us that |=M ′ Φ for every M ′ ∈M′ such thatM′ ∈M−Φ , whereM = {M : |=MT and M = 〈val(S ),R〉}. If |=M ′ Φ for every M ′ ∈M′, then even for M ′′ ∈M′\\M we have |=M\n′′ Φ. But M ′′ ∈M−Φ\nfor some M ∈M, and by definition 6|=M ′′ Φ. Hence M−Φ = ∅, and then the truth of Φ in M does not depend on the accessibility relation Ra. Hence, whether Φ has the form ϕ→ 〈a〉> or ϕ→ [a]ψ, for ϕ,ψ ∈ Fml, this holds only if S |=\nCPL ¬ϕ (see Definitions 3.1 and 3.5), and\ntherefore we get S |= Kn Φ. 2\nEquivalences Postulate: If |= Kn T1 ↔ T2 and |=KnΦ1 ↔ Φ2, then |=KnT ′ 1 ↔ T ′2 , for some T ′1 ∈ (T1) − Φ2 and T ′2 ∈ (T2) − Φ1 .\nThis postulate corresponds to Katsuno and Mendelzon’s (C4) and (E4) postulates. It is worth noting that equivalence here is considered always modulo action laws, i.e., the formulas are assumed to be either static laws, effect laws or executability laws, as well as their equivalents. Moreover we remember that the theories here must be action theories, i.e., sets of action laws of our three basic types. Under modularity and the assumption that the propositional change operator satisfies (C4)/(E4), our operations satisfy this postulate:\nTheorem 7.2 Let T1 and T2 be modular. If |=KnT1 ↔ T2 and |=KnΦ1 ↔ Φ2, then for each T ′1 ∈ (T1) − Φ2 there is T ′2 ∈ (T2) − Φ1 such that |= Kn T ′1 ↔ T ′2 , and vice-versa.\nProof: The proof follows straight from our results: since |= Kn T1 ↔ T2 and |=KnΦ1 ↔ Φ2, they have pairwise the same models. Hence, given M such that |=M T1 and |= M T2, the semantic contraction of Φ1 and that of Φ2 from M have the same operations on M . As T1 and T2 are modular, Corollary 6.1 guarantees we get the same syntactical results. Moreover, as the classical operator satisfies (C4)/(E4), if follows that |=\nKn T ′1 ↔ T ′2 . 2\nRecovery Postulate: T ′ ∪ {Φ} |= Kn T, for all T ′ ∈ T−Φ .\nThis is the action theory counterpart of Katsuno and Mendelzon’s (C5) and (E5) postulates. Again we rely on modularity in order to satisfy it.\nTheorem 7.3 Let T be modular. T ′ ∪ {Φ} |= Kn T, for all T ′ ∈ T−Φ .\nProof: If T 6|= Kn Φ, because our operators satisfy the preservation postulate, T ′ = T, and then the result follows by monotonicity.\nLet T |= Kn Φ, and let M′ denote the set of all models of T ′. As T is modular, by Corol-\nlary 6.1 every M ′ ∈M′ is such that either |=M ′ T (and then |=M ′ Φ) or M ′ ∈ contract(M , Φ) (and then M ′ ∈M−Φ ) for some M such that |= MT.\nLet M′′ denote the set of all models of T ′ ∪ {Φ}. Clearly M′′ ⊆ M′, by monotonicity. Moreover, every M ′′ ∈ M′′ is such that |=M\n′′ Φ, hence M ′′ /∈ M−Φ for every M such that\n|=M T, and then M ′′ /∈ contract(M , Φ), for any M model of T. Thus M ′′ is a model of T and then T ′ ∪ {Φ} |=\nKn T. 2 Let ∨ T−Φ denote the disjunction of all T ′ in T − Φ .\nDisjunctive Rule: (T1 ∨ T2)−Φ is equivalent to ∨ (T1)−Φ ∨ ∨ (T2)−Φ .\nThis is our version of (E8) erasure postulate by Katsuno and Mendelzon. Clearly our syntactical operators do not manage to contract a law from a disjunction of theories: T1∨T2 is not an action theory and cannot in general be rewritten as one. Nevertheless, by proving that it holds in the semantics, from the correctness of our operators, we get an equivalent operation. Again the fact that the theories under concern are modular gives us the result.\nTheorem 7.4 Let T1 and T2 be modular, and Φ be a law. Then\n|= Kn ∨ (T1 ∨ T2)−Φ ↔ ( ∨ (T1)−Φ ∨ ∨ (T2)−Φ )\nProof: (⇐): Let M ′ be such that |=M ′∨ (T1)−Φ ∨ ∨ (T2)−Φ . Then |= M ′∨ (T1)−Φ or |= M ′∨ (T2)−Φ . Suppose\n|=M ′∨\n(T1)−Φ (the other case is analogous). Then there is (T1)′ ∈ (T1) − Φ such that |= M ′ (T1)′.\nThen by Corollary 6.1, there is M′ ∈ M−Φ such that M ′ ∈ M′, for M a set of models of T1. Then M ′ is a model resulting from contracting Φ from models of T1 , and then M ′ also results from contracting Φ in models of T1 ∨ T2, viz. those models of T1. Then by Corollary 6.1, there is (T1 ∨ T2)′ ∈ (T1 ∨ T2)−Φ such that |= M ′ (T1 ∨ T2)′, and then |= M ′∨ (T1 ∨ T2)−Φ .\n(⇒): Let M ′ be such that |=M ′∨\n(T1 ∨ T2)−Φ . Then there is (T1∨T2)′ ∈ (T1 ∨ T2) − Φ such that\n|=M ′ (T1 ∨ T2)′. By Corollary 6.1, there is M′ ∈ M−Φ such that M ′ ∈ M′, for M a set of models of T1∨T2. Then M ′ is a model resulting from contracting Φ from models of T1∨T2. Hence M ′ results from contracting Φ from models of T1 or from models of T2. Suppose the former is the case (the second is analogous). Then by Corollary 6.1 there is (T1)′ ∈ (T1)−Φ such that |=M ′ (T1)′, and then |= M ′∨ (T1)−Φ . 2\nWe have thus shown that our constructions satisfy the (E8) postulate. Nevertheless, as far as we see, it is not immediate whether it is really expected here. This supports our position that our operators’ behavior is closer to contraction than to erasure.\nAs we have seen from the results above, modularity is a sufficient condition for the satisfaction of the AGM-like postulates for action theory contraction. To finish up we state a new postulate:\nPreservation of Modularity: If T is modular, then every T ′ ∈ T−Φ is modular. Changing a modular theory should not make it non-modular. This is not a standard postulate, but we think that since it is a good property modularity should be preserved across changing an action theory. If so, this means that whether a theory is modular or not can be checked once for all and one does not need to care about it during the future evolution of the action theory, i.e., when other changes will be made on it. Our operators satisfy this postulate and the proof is given in Appendix B.\nNow one may naturally asks whether we can get a characterization result in the traditional AGM sense, i.e., whether any contraction operator satisfying all our versions of the postulates is one of our three contraction operations. Unfortunately, good sense points towards a negative answer: there might well be an operator satisfying all the above postulates that, by not complying with all the assumptions in the RAC community (Shanahan, 1997), is not necessarily one of the operators defined in Section 3 (cf. the discussion on general formula contraction in Section 10). To witness, consider for example an operator that also modifies worlds when contracting effect laws. This supports one of the contentions of the present work, viz. that classical belief change cannot be fully transposed to action theories and expected to give exactly the same kind of outcome. Similar negative results have also been found for revision in DL ontologies (Flouris, Plexousakis, & Antoniou, 2004) and contraction of Horn theories (Booth, Meyer, & Varzinczak, 2009)."
    }, {
      "heading" : "8. A Semantics for Action Theory Revision",
      "text" : "So far we have analyzed the case of contraction: the knowledge engineer realizes that the theory is too strong and therefore it has to be weakened. Let us now take a look at the other way round, i.e., the theory is (possibly) too liberal and the agent discovers new laws about the world that should be added to her beliefs, which amounts to strengthening them.\nSuppose that the action theory of our scenario example were initially stated as follows:\nT =  coffee→ hot, token→ 〈buy〉>,\n¬coffee→ [buy]coffee,¬token→ [buy]⊥, coffee→ [buy]coffee, hot→ [buy]hot  Then the canonical model of theory T is as shown in Figure 15.\nLooking at model M in Figure 15 we can see that, for example, the agent does not know that she loses her token every time she buys coffee at the machine. This is a new law that she should incorporate to her knowledge base at some stage of her action theory evolution.\nContrary to contraction, where we want the negation of some law to become satisfiable, in revision we want to make a new law valid. This means that one has to eliminate all cases satisfying its negation. This depicts the duality between revision and contraction: whereas in the latter one invalidates a formula by making its negation satisfiable, in the former one makes a formula valid by forcing its negation to be unsatisfiable prior to adding the new law to the theory.\nThe idea behind our semantics for revision is as follows: we initially have a set of models M in which a given formula Φ is (potentially) not valid, i.e., Φ is (possibly) not true in every model in M. In the result we want to have only models of Φ. Adding Φ-models to M is of no help. Moreover, adding models makes us lose laws: the corresponding resulting theory would be more liberal.\nOne solution amounts to deleting from M those models that are not Φ-models. Of course removing only some of them does not solve the problem, we must delete every such a model. By doing that, all resulting models will be models of Φ. (This corresponds to theory expansion, when the resulting theory is satisfiable.) However, if M contains no model of Φ, we will end up with ∅. Consequence: the resulting theory is inconsistent. (This is the main revision problem.) In this case the solution is to substitute each model M in M by\nits nearest modification M ?Φ that makes Φ true. This lets us to keep as close as possible to the original models we had. But, what if for one model in M there are several minimal (incomparable) modifications of it validating Φ? In that case we shall consider all of them. The result will also be a list of models M?Φ, all being models of Φ.\nBefore defining the revision of sets of models, we present what modifications of (individual) models are."
    }, {
      "heading" : "8.1 Revising a Model by a Static Law",
      "text" : "Suppose that our coffee deliverer agent discovers that the only hot drink that is served on the machine is coffee. In this case, she might want to revise her beliefs with the new static law ¬coffee→ ¬hot: she cannot hold a hot drink that is not a coffee.\nConsidering the model depicted in Figure 15, one can see that the Boolean formula ¬coffee ∧ hot is satisfiable (there is a world of the model in which it holds). Since we do not want this to be the case, the first step is to remove all worlds in which ¬coffee ∧ hot is true. The second step is to guarantee that all the remaining worlds (if any) satisfy the new static law. Such an issue has been largely addressed in the literature on propositional belief base revision and update (Gärdenfors, 1988; Winslett, 1988; Katsuno & Mendelzon, 1992; Herzig & Rifi, 1999). Here we can achieve that with a semantics similar to that of classical revision operators: basically one can change the set of possible valuations, by removing or adding worlds.\nIn our example, removing the possible worlds {t,¬c, h} and {¬t,¬c, h} would do the job (there is no need to add new valuations since the new incoming law is already satisfied in at least one world of the original model, and therefore the resulting set of worlds is non-empty).\nThe delicate point in removing worlds is that this may have as consequence the loss of some executability laws: in the example, if there were some transition from some world w to say {¬t,¬c, h}, then removing the latter from the model would make the action under concern no longer executable in w, if it was the only transition labeled by that action leaving it. From a semantic point of view, this is intuitive: if the state of the world to which we could move is no longer possible, then we do not have a transition to that state anymore. Therefore, if that transition was the only one we had, it is natural to lose it.\nSimilarly, one could ask what to do with the accessibility relation if new worlds are added, i.e., when expansion is not possible. Following the discussion in Section 3.3, we here prefer not to add new transitions systematically to the accessibility relation. Hence we shall postpone correction of executability laws, if needed. This approach may be debatable, but with the information we have at hand, this is the safest way of changing static laws. (See also the discussion in Sections 3.3 and 4.2.)\nThe semantics for revision of one model by a static law is as follows:\nDefinition 8.1 Let M = 〈W,R〉. M ′ = 〈W′,R′〉 ∈M ?ϕ if and only if:\n• W′ = (W \\ val(¬ϕ)) ∪Wϕ, where Wϕ ⊆ val(ϕ); and\n• R′ ⊆ R.\nClearly unless ϕ |= CPL ⊥, we have that |=M ′ ϕ for each M ′ ∈ M ?ϕ . The minimal models\nresulting from revising a model M by ϕ are those closest to M with respect to M :\nDefinition 8.2 Let M be a model and ϕ a static law. revise(M , ϕ) = ⋃\nmin{M ?ϕ , M }.\nIn the example of model M in Figure 15, revise(M ,¬coffee → ¬hot) is the singleton {M ′}, where M ′ is as shown in Figure 16."
    }, {
      "heading" : "8.2 Revising a Model by an Effect Law",
      "text" : "Let us suppose now that our agent eventually discovers that after buying coffee she does not keep her token anymore. (That was a design mistake that the agent still possesses a token even after ordering a coffee at the machine). This means that her theory should now be revised in such a way that the new effect law token → [buy]¬token holds. Looking at model M in Figure 15, this amounts to guaranteeing that the formula token ∧ 〈buy〉token is satisfiable in none of its worlds. To do that, we have to look at all the worlds satisfying this formula (if any) and either (i) make token false in each of these worlds; or (ii) make 〈buy〉token false in all of them. If we chose the first option, we will essentially flip the truth value of literal token in the respective worlds, which changes the set of valuations of the model. If we chose the latter, we will basically remove buy-arrows leading to token-worlds. In that case, a change in the accessibility relation will be made.\nIn our example, we have that the possible worlds {token, coffee, hot}, {token,¬coffee, hot} and {token,¬coffee,¬hot} satisfy token ∧ 〈buy〉token and all they have to change.\nFlipping token in all these worlds to ¬token would do the job, but would also have as consequence the introduction of a new static law: ¬token would now be valid, i.e., the agent never has a token! Another issue with this approach is that by making ¬token true everywhere, the new incoming law token→ [buy]¬token will be trivially true in the resulting model, which does not mean that there is an execution of action buy from a token-world to a ¬token one. This defeats the purpose of changing the action theory on the basis that it has been observed that every execution of the action under consideration should lead to ¬token-contexts.\nOne of our contentions in the present work is that changing action laws should never have as a side effect a change in the static laws (cf. Sections 3 and 4). Given their special status (Shanahan, 1997), these should change only if explicitly required. In this case, each world\nsatisfying token ∧ 〈buy〉token has to be changed so that 〈buy〉token is no longer true in it. In our example, we should remove the transitions ({token, coffee, hot}, {token, coffee, hot}), ({token,¬coffee, hot}, {token, coffee, hot}) and ({token,¬coffee,¬hot}, {token, coffee, hot}).\nThe semantics of one model revision for the case of a new effect law is:\nDefinition 8.3 Let M = 〈W,R〉. M ′ = 〈W′,R′〉 ∈M ?ϕ→[a]ψ if and only if:\n• W′ = W;\n• R′ ⊆ R;\n• If (w,w′) ∈ R \\ R′, then |=M w ϕ; and\n• |=M ′ ϕ→ [a]ψ.\nThe minimal models resulting from the revision of a model M by a new effect law are those that are closest to M with respect to our order on the models M : Definition 8.4 Let M be a model and ϕ → [a]ψ an effect law. revise(M , ϕ → [a]ψ) =⋃ min{M ?ϕ→[a]ψ, M }.\nTaking once again M as shown in Figure 15, revise(M , token → [buy]¬token) will be the singleton {M ′} (Figure 17)."
    }, {
      "heading" : "8.3 Revising a Model by an Executability Law",
      "text" : "Let us now suppose that in some stage it has been decided to grant free coffee to everybody. Faced with this information, the agent will now revise her laws to reflect the fact that buy can also be executed in ¬token-contexts: ¬token→ 〈buy〉> is a new executability law (and therefore we will have 〈buy〉> in all new models of the agent’s beliefs).\nConsidering again the model in Figure 15, we observe that ¬(¬token → 〈buy〉>) is satisfiable in M . This means that we must throw ¬token ∧ [buy]⊥ away to ensure that the new formula becomes true in the new model, i.e., satisfied by all of its worlds.\nTo remove ¬token ∧ [buy]⊥ we have to look at all worlds satisfying it and modify M so that they no longer satisfy that formula. Given worlds {¬token,¬coffee,¬hot} and {¬token,¬coffee, hot}, we have two options: change the interpretation of token or add new transitions leaving these worlds. A question that arises is ‘what choice is more drastic: change a world or a transition’? Again, here we think that changing the world’s content (the valuation) is more drastic, as the existence of such a world was foreseen by some static law and is hence assumed to be as it is, unless we have enough information supporting the contrary, in which case we explicitly change the static laws (see above). Moreover, changing the truth value of token in these worlds would trivialize the new incoming law ¬token→ 〈buy〉> in the new model, defeating the purpose of guaranteeing the existence of a buy-transition from a ¬token-context. Therefore we shall add a new buy-arrow from each of {¬token,¬coffee,¬hot} and {¬token,¬coffee, hot}.\nHaving agreed on that, the issue now is: which worlds should the new transitions be directed to? Recalling the reasoning developed in Section 3.2, in order to comply with minimal change, the new transitions shall be directed to worlds that are relevant targets of each of the ¬token-worlds in question. In our example, {¬token, coffee, hot} is the only relevant target world here: the two other ¬token-worlds violate the effect coffee of buy, while the three token-worlds would make us violate the frame axiom ¬token→ [buy]¬token.\nThe semantics for one model revision by a new executability law is as follows:\nDefinition 8.5 Let M = 〈W,R〉. M ′ = 〈W′,R′〉 ∈M ?ϕ→〈a〉> if and only if:\n• W′ = W;\n• R ⊆ R′;\n• If (w,w′) ∈ R′ \\ R, then w′ ∈ RelTarget(w,ϕ→ [a]⊥,M ,M); and\n• |=M ′ ϕ→ 〈a〉>.\nThe minimal models resulting from revising a model M by a new executability law are those closest to M with respect to M :\nDefinition 8.6 Let M be a model and ϕ → 〈a〉> be an executability law. revise(M , ϕ → 〈a〉>) = ⋃ min{M ?ϕ→〈a〉>, M }.\nIn our running example, revise(M ,¬token→ 〈buy〉>) is the singleton {M ′}, where M ′ is as depicted in Figure 18.\nIn this example, observe that because we have a single relevant target world we get a single model in the result of revision."
    }, {
      "heading" : "8.4 Revising Sets of Models",
      "text" : "Up until now we have seen what the revision of single models means. This is needed when expansion by the new law is not possible due to inconsistency. We here give a unified definition of revision of a set of models M by a new law Φ:\nDefinition 8.7 Let M be a set of models and Φ be a law. Then\nM?Φ = { M\\ {M : 6|=MΦ}, if there is M ∈M such that |=MΦ;⋃\nM∈M revise(M , Φ), otherwise.\nObserve that Definition 8.7 comprises both expansion and revision: in the first one, simple addition of the new law gives a satisfiable theory; in the latter a deeper change is needed to get rid of inconsistency."
    }, {
      "heading" : "9. Related Work",
      "text" : "To the best of our knowledge, the first work on updating an action domain description is that by Li and Pereira (1996) in a narrative-based action description language (Gelfond & Lifschitz, 1993). Contrary to us, however, they mainly investigate the problem of updating the narrative with new observed facts and (possibly) with occurrences of actions that explain those facts. This amounts to updating a given state/configuration of the world (in our terms, what is true in a possible world) and focusing on the models of the narrative in which some actions took place (in our terms, the models of the action theory with a particular sequence of action executions). Clearly the models of the action laws remain the same.\nBaral and Lobo (1997) introduce extensions of action languages that allow for some causal laws to be stated as defeasible. Their work is similar to ours in that they also allow for weakening of laws: in their setting, effect propositions can be replaced by what they call defeasible (weakened versions of) effect propositions. Our approach is different from theirs in the way executability laws are dealt with. Here executability laws are explicit and we are also able to contract them. This feature is important when the qualification problem is considered: we may always discover contexts that preclude the execution of a given action (cf. the Introduction).\nLiberatore (2000) proposes a framework for reasoning about actions in which it is possible to express a given semantics of belief update, like Winslett’s (1988) and Katsuno and Mendelzon’s (1992). This means it is the formalism, essentially an action description lan-\nguage, that is used to describe updates (the change of propositions from one state of the world to another) by expressing them as laws in the action theory.\nThe main difference between Liberatore’s work (2000) and Li and Pereira’s (1996) is that, despite not being concerned, at least a priori, with changing action laws, Liberatore’s framework allows for abductively introducing in the action theory new effect propositions (effect laws, in our terms) that consistently explain the occurrence of an event.\nThe work by Eiter et al. (2005) is similar to ours in that they also propose a framework which is oriented to updating action laws. They mainly investigate the case where e.g. a new effect law is added to the description (and then has to be true in all models of the modified theory). This problem is the dual of contraction and is then closer to our definition of revision (cf. Section 8).\nIn Eiter et al.’s framework (2005), action theories are described in a variant of a narrativebased action description language. Like in the present work, the semantics is also in terms of transition systems, with transitions (action occurrences) linking states (configurations of the world). Contrary to us, however, the minimality condition on the outcome of the update is in terms of inclusion of sets of laws, which means that the approach is more syntax oriented to some extent.\nIn their setting, during an update an action theory T is seen as composed of two pieces, Tu and Tm, where Tu stands for the part of T that is not supposed to change and Tm contains the laws which may be modified. In our terms, when contracting a static law we would have Tm = S ∪ Xa; when contracting an executability law Tm = Xa; and when contracting effects laws Tm = E−a . The difference here is that in our approach it is always clear what laws should not change in a given type of contraction, and therefore Tu and Tm do not need to be explicitly specified prior to the update.\nTheir approach and ours can both be described as constraint-based update, in that the theory change is carried out relative to some constraints (a set of laws that we want to hold in the result). In our framework, for example, all changes in the action laws are relative to the set of static laws S (and that is why we concentrate on models of T having val(S ) as worlds). When changing a law, we want to keep the same set of states. The difference with respect to Eiter et al.’s (2005) approach is that there it is also possible to update a theory relatively to e.g. executability laws: when expanding T with a new effect law, one may want to constrain the change so that the action under concern is guaranteed to be executable in the result.7 As shown in the referred work, this may require the withdrawal of some static law. Hence, in Eiter et al.’s framework, static laws do not have the same status as in ours.\nHerzig et al. (2006) define a method for action theory contraction that, despite the similarity with the current work and the common underlying motivations, is more limited than the present constructions.\nFirst, with the referred approach we do not get minimal change. For example, in the referred work the operator for contracting executability laws is such that in the resulting theory the modified set of executability laws is given by\nX−a = {(ϕi ∧ ¬ϕ)→ 〈a〉> : ϕi → 〈a〉> ∈ Xa}\n7. We could simulate that in our approach with two successive modifications of T: first adding the effect law and then an executability law (cf. Section 8).\nwhich, according to its semantics, gives theories among whose models are those resulting from removing transitions from all ϕ-worlds. A similar comment can be made with respect to contraction of effect laws.\nSecond, Herzig et al.’s (2006) contraction method does not satisfy most of the postulates for action theory change that we have addressed in Section 7. Besides not satisfying the monotonicity postulate, it does not satisfy the preservation one. To witness, suppose that we have a language with only one atom p, and the model M depicted in Figure 19.\nThen |=M p → [a]¬p and 6|=M [a]¬p. Now the contraction operator defined there is such that when removing [a]¬p from M yields the model M ′ in Figure 19 such that R′a = W×W. Then 6|=M ′ p→ [a]¬p, i.e., the effect law p→ [a]¬p is not preserved.\nFinally, another work that is related to ours is that by Zhang and Ding (2008). Like ours, their approach is also about giving a semantic characterization of the basic operations for changing Kripke models. Contrary to us however, their focus is on model checking, not on entailment. Despite the definition and use of operations that in essence are similar to ours (modifications of the set of possible worlds or of the accessibility relation), their work is concerned mainly with modifications of a single model, not with that of sets of models as we do, and hence it does not provide operations for changing action laws. Because of that, their approach is not directly comparable to ours, since here we are interested in entailment-based revision."
    }, {
      "heading" : "10. Concluding Remarks",
      "text" : "In this work we have addressed the problem of changing an action domain description for reasoning about actions, a problem not sufficiently investigated in the literature so far. We have seen the intuitions behind such a kind of theory modification and have given a semantics for action theory change in terms of distances between models that captures the notion of minimal change. We have given algorithms to contract a formula from a theory that terminate and that are correct with respect to our semantics (Corollary 6.1). We have shown the importance that our modularity notion has in this result and in others.\nWe have also extended Varzinczak’s investigations (2008) by defining a semantics for action theory revision based on minimal modifications of models. For the corresponding revision algorithms, the reader is referred to the work by Varzinczak (2009). One of our ongoing research topics is on assessing our revision operators’ behavior with respect to appropriate versions of the AGM postulates for revision (Alchourrón et al., 1985) and its links with the contraction counterpart.\nWith our algorithms we provide a set of tools to be used by the knowledge engineer in an interactive and possibly iterative way to modify an action theory. These tools are guaranteed\nto perform minimal change when assisting the knowledge engineer in implementing her desired modifications. They give her a set of options and it is up to the knowledge engineer to decide which one is more in line with her intuitions.\nGiven that action theory change is not a single step operation, the knowledge engineer is expected to make use of the contraction/revision operators to make a series of modifications that eventually will give a fine-grained theory not entailing the contracted laws and entailing the new learned laws about the domain.\nFor the sake of presentation, here we have abstracted from the frame and ramification problems. However our definitions could have been stated in a formalism with a suitable solution to them, like Castilho et al.’s approaches (1999, 2002). With regards to the qualification problem, this is not ignored here: contracting wrong executability laws is an approach towards its solution. Indeed, given the difficulty of stating all sufficient conditions for executability of an action, the knowledge engineer writes down some of them and lets the theory ‘evolve’ via subsequent revisions.\nA possible criticism to the approach here developed concerns the cautiousness of our operator for contracting static laws: we prefer to lose some executability laws rather than induce them and lose effect laws. This behavior could make our operators to be interpreted as incoherent. We have pointed out nevertheless that this is in line with largely accepted assumptions in the RAC community, and moreover we have shown the impossibility of a non-cautious static law contraction operator that complies with all that and is coherent with the other operators.\nIndeed one of the purposes of the present work is to shed some light on the fundamental differences between belief change in action domain descriptions and in logical theories in general. Classical belief change cannot be fully transplanted to action theories, and here we have shown why (cf. Sections 3.2, 4.2, 5.3 and 8.3).\nIn particular, looking at the postulates of classical belief change (or our versions thereof) one sees that they are not enough to fully characterize operators for action theory change. For that to be achieved the fundamental assumptions in reasoning about actions that we have extensively used throughout this work should somehow be ‘compiled’ into postulates supplementing the classical ones. It is not immediately clear what these new postulates would look like, but this is an interesting thread of investigation worth pursuing.\nIt might also be argued that our semantic operations do not respect the principle of categorical matching, given that the input and output are different sorts of objects, viz. a set of models and a set of sets of models (cf. Definitions 3.3, 3.7 and 3.10). It is easy to see, however, that our semantic constructions could have been defined in such a way that each M′ ∈ M−Φ corresponds to the result of one contraction operator. The choice for defining the result of an operation as a set of possible outputs was driven by the definition of the algorithms, where a theory (corresponding to a set of models) is given as input and the output is a set of theories (hence corresponding to a set of set of models).\nAlthough the semantic operators can be redefined to satisfy the principle of categorical matching, the same is not immediate about the algorithms (they would be nondeterministic). Therefore we preferred to keep a balance between the semantic and the syntactic definitions so that we see more clearly their direct correspondence.\nOne of our contentions here is that sticking to modular theories (and hence to canonical models) is not a big deal: we can use existent algorithms in the literature (Herzig & Varzinczak, 2007) to ensure that an action theory T is characterized by its canonical models.\nWe have seen that under modularity, our operators satisfy all the postulates for contraction: Modularity is one of the sufficient conditions for Success in Theorem 7.1. It is also a sufficient condition in Theorem 7.2, and, as shown in Theorem 7.3, it is a sufficient condition for Recovery. Finally it is also a sufficient condition for the Disjunctive Rule to hold, and is shown to be preserved by the contraction operators (cf. last paragraph of Section 7.2, proof in Appendix B). Preservation of modularity is an important result since it means that it has to be checked/ensured at most once during the lifetime of the action theory. All these results support the thesis that our modularity notion is fruitful.\nBy forcing formulas to be explicitly stated in their respective modules (and thus possibly making them inferable in independently different ways), modularity intuitively could be seen to diminish elaboration tolerance (McCarthy, 1998). For instance, when contracting a Boolean formula ϕ in a non-modular theory, it seems reasonable to expect not to change the set of static laws S , while the theory being modular surely forces changing such a module. It is not difficult, however, to conceive non-modular theories in which contraction of a formula ϕ may demand a change in S as well. As an example, suppose S = {ϕ1 → ϕ2} in an action theory from whose dynamic part we (implicitly) infer ¬ϕ2. In this case, contracting ¬ϕ1 while keeping ¬ϕ2 would necessarily ask for a change in S .\nWe point out nevertheless that in both cases (modular and non-modular) the extra work in changing other modules stays in the mechanical level, i.e., in the algorithms that carry out the modification, and does not augment in a significant way the amount of work the knowledge engineer is expected to do.\nContrary to the trend in the belief change community, where the focus is either on belief bases or belief sets (Hansson, 1999), the method here proposed is a hybrid one (Delgrande, 2009). On one hand, semantics plays a crucial role in the notion of minimal change here studied. On the other hand, we deal only with domain descriptions in reasoning about actions, which are sets of laws of specific types. On top of that, the modularity property (a syntactical one) is fundamental to our main results.\nFollowing those lines, another issue that drives our future research on the subject is how to contract not only laws but any Kn-formula. As defined, the order of application of our operators matter in the final result: if we contract ϕ and then ϕ → [a]ψ from a theory T, the result may not be the same as contracting ϕ → [a]ψ first and then removing ϕ. This problem would not appear in a more general framework in which any formula could be contracted: removing ϕ ∧ (ϕ → [a]ψ) should give the same result as (ϕ → [a]ψ) ∧ ϕ. This is the principle of syntax independence (Dalal, 1988).\nRelated to that is the question on how our revision definitions relate to our contraction operators. What is known is that the Levi identity (1977), T?Φ = T − ¬Φ ∪ {Φ}, in general does not hold for action laws (effect and executability ones). The reason is that up to now there is no contraction operator for ¬Φ where Φ is an effect or an executability law. Indeed this is the general contraction problem for non-classical logics: contraction of a general formula (like ¬Φ above) is still an open problem in the belief change area. Some insights in this direction are given by our revision definitions, with which we make ¬Φ false in every possible world of a Kripke model.\nDefinitions 3.1, 3.5 and 3.8 appear to be important for better understanding the problem of contracting general formulas: basically the set of modifications to perform in a given model in order to force it to falsify a general formula will comprise removal/addition of transitions/worlds. The definition of a general revision/contraction method will then benefit from our constructions.\nFurthermore, given the well-known connection between multimodal logics and Description Logics (Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003), we believe that our definitions may also contribute to ontology evolution and debugging in some specific families of DLs."
    }, {
      "heading" : "Acknowledgments",
      "text" : "Parts of this work have been done during the author’s stay at the Institut de Recherche en Informatique de Toulouse (IRIT), France, and during his visit to the National ICT Australia (NICTA), Sydney.\nThe author is grateful to the anonymous referees for their constructive and useful remarks, which helped improving the quality of the work. The paper has also benefited from discussions with Andreas Herzig and Laurent Perrussel.\nSpecial thanks to my colleagues at the Meraka Institute Arina Britz, Ken Halland, Johannes Heidema and Tommie Meyer for their invaluable comments and suggestions on earlier versions of this article."
    }, {
      "heading" : "Appendix A. Proof of Theorem 6.2",
      "text" : "Let T be modular, and Φ be a law. For all M′ ∈ M−Φ such that |= M T for every M ∈ M, there is T ′ ∈ T−Φ such that |= M ′T ′ for every M ′ ∈M′.\nBefore we give the proof of this theorem, we will need the following lemma (cf. the Monotonicity Postulate in Section 7.2):\nLemma A.1 T |= Kn T ′.\nProof: Let T be an action theory, and let T ′ ∈ T−Φ , for a given law Φ. We are going to analyze each case.\nLet Φ be of the form ϕ→ 〈a〉>, for some ϕ ∈ Fml. Then T ′ is such that\nT ′ = (T \\ Xa) ∪ {(ϕi ∧ ¬(π ∧ ϕA))→ 〈a〉> : ϕi → 〈a〉> ∈ Xa}\nwhere π ∈ IP(S ∧ ϕ) and ϕA = ∧\npi∈atm(π) pi∈A\npi ∧ ∧\npi∈atm(π) pi /∈A\n¬pi, for some A ⊆ atm(π).\nLet M = 〈W,R〉 be such that |=MT. It is enough to show that M is a model of the new laws. For every (ϕi∧¬(π∧ϕA))→ 〈a〉>, for every w ∈W, if |= M\nw ϕi∧¬(π∧ϕA), then |=\nM w ϕi.\nBecause T |= Kn ϕi → 〈a〉>, |=\nM ϕi → 〈a〉>, and then Ra(w) 6= ∅.\nTherefore we have that |=MT ′.\nLet now Φ have the form ϕ→ [a]ψ, for ϕ,ψ ∈ Fml. Then T ′ is such that\nT ′ =\n(T \\ E−a ) ∪ {(ϕi ∧ ¬(π ∧ ϕA))→ [a]ψi : ϕi → [a]ψi ∈ E−a } ∪ {(ϕi ∧ π ∧ ϕA)→ [a](ψi ∨ π′) : ϕi → [a]ψi ∈ E−a } ∪ ` ∈ L, for some L ⊆ Lit s.t. (π ∧ ϕA ∧ `)→ [a](ψ ∨ `) : S 6` (π′ ∧ ∧ `∈L `)→ ⊥, and ` ∈ π′\nor T 6 K̀n (π ∧ ϕA ∧ `)→ [a]¬`  where E−a = ⋃ 1≤i≤n(E ϕ,ψ a )i, π ∈ IP(S ∧ ϕ), ϕA = ∧ pi∈atm(π)\npi∈A pi ∧\n∧ pi∈atm(π)\npi /∈A\n¬pi, for some\nA ⊆ atm(π), and π′ ∈ IP(S ∧ ¬ψ). Let M = 〈W,R〉 be such that |=M T. It is enough to show that M is a model of the added laws. Given (ϕi ∧ ¬(π ∧ ϕA)) → [a]ψi, for every w ∈ W, if |= M\nw ϕi ∧ ¬(π ∧ ϕA), then\n|=M w ϕi. Because T |=Knϕi → [a]ψi, |= M ϕi → [a]ψi, and then |= M w′ ψi for every w ′ ∈W such that (w,w′) ∈ Ra.\nFor (ϕi ∧ π ∧ ϕA) → [a](ψi ∨ π′), for every w ∈ W, if |= M\nw ϕi ∧ π ∧ ϕA, then again |=\nM w′ ψi\nfor every w′ ∈W such that (w,w′) ∈ Ra. Now, given (π ∧ ϕA ∧ `)→ [a](ψ ∨ `), for every w ∈W, if |= M\nw π ∧ ϕA ∧ `, then |=\nM w π, and\nthen |=M w ϕ. Since T |= Kn ϕ → [a]ψ, we have |=M ϕ → [a]ψ, and then |=M w′ ψ for every w′ ∈ W such that (w,w′) ∈ Ra. Therefore |=MT ′.\nLet Φ be a propositional ϕ. Then T ′ is such that\nT ′ = ((T \\ S ) ∪ S−) \\ Xa ∪ {(ϕi ∧ ϕ)→ 〈a〉> : ϕi → 〈a〉> ∈ Xa} ∪ {¬ϕ→ [a]⊥}\nfor some S− ∈ S ϕ. Let M = 〈W,R〉 be such that |=MT. It suffices to show that M satisfies the added laws. Since we assume behaves like a classical contraction operator, like e.g. Katsuno and Mendelzon’s (1992), we have |= CPL S → S−, and then, because |=MS , we have |=MS−.\nNow given (ϕi ∧ ϕ) → 〈a〉>, for every w ∈ W, if |= M\nw ϕi ∧ ϕ, then |=\nM w ϕi, and because\n|=Mϕi → 〈a〉>, we have Ra(w) 6= ∅. Finally, for ¬ϕ→ [a]⊥, because |=Mϕ, M trivially satisfies ¬ϕ→ [a]⊥. Therefore |=MT ′. 2\nProof of Theorem 6.2\nLet M = {M : |=MT}, and M′ ∈M−Φ . We show that there is T ′ ∈ T − Φ such that |= M ′T ′ for every M ′ ∈M′.\nBy definition, each M ′ ∈ M′ is such that either |=M ′ T or 6|=M ′ Φ. Because T−Φ 6= ∅, there\nmust be T ′ ∈ T−Φ . If |= M ′T, by Lemma A.1 |=M ′ T ′ and we are done. Let us then suppose that 6|=M ′ Φ. We analyze each case.\nLet Φ have the form ϕ→ 〈a〉> for some ϕ ∈ Fml. Then M ′ = 〈W′,R′〉, where W′ = W, R′ = R \\ Rϕa , with Rϕa = {(w,w′) : |= M w ϕ and (w,w′) ∈ Ra}, for some M ∈M.\nLet u ∈W′ be such that 6|=M ′\nu ϕ→ 〈a〉>, i.e., |=M\n′\nu ϕ and R′a(u) = ∅. Because u ϕ, there must be v ∈ base(ϕ,W′) such that v ⊆ u. Let π = ∧ `∈v `. Clearly\nπ is a prime implicant of S ∧ ϕ. Let also ϕA = ∧ `∈u\\v `, and consider\nT ′ = (T \\ Xa) ∪ {(ϕi ∧ ¬(π ∧ ϕA))→ 〈a〉> : ϕi → 〈a〉> ∈ Xa}\n(Clearly, T ′ is a theory produced by Algorithm 1.) It is enough to show that M ′ is a model of the new added laws. Given (ϕi∧¬(π∧ϕA))→ 〈a〉> ∈ T ′, for every w ∈W′, if |=M ′\nw ϕi ∧ ¬(π ∧ ϕA), then |=\nM ′ w ϕi, from what it follows |= M w ϕi.\nBecause |=M ϕi → 〈a〉>, there is w′ ∈ W such that w′ ∈ Ra(w). We need to show that (w,w′) ∈ R′a. If 6|= M w ϕ, then Rϕa = ∅, and (w,w′) ∈ R′a. If |= M w ϕ, either w = u, and then from |=M ′\nu π ∧ ϕA we conclude |=\nM ′ u (ϕi ∧ ¬(π ∧ ϕA)) → 〈a〉>, or w 6= u and then we must have\n(w,w′) ∈ R′a, otherwise there is Sϕa ⊂ Rϕa such that R−̇(R \\ Sϕa ) ⊂ R−̇(R \\ Rϕa ), and then M ′′ = 〈W′,R \\ Sϕa 〉 is such that 6|= M ′′ ϕ → 〈a〉> and M ′′ M M ′, a contradiction because M ′ is minimal with respect to M . Thus (w,w′) ∈ R′a, and then |= M ′ w 〈a〉>. Hence |=M ′ T ′.\nNow let Φ be of the form ϕ→ [a]ψ, for ϕ,ψ both Boolean. Then M ′ = 〈W′,R′〉, where W′ = W, R′ = R ∪ Rϕ,¬ψa , with\nRϕ,¬ψa = {(w,w′) : w′ ∈ RelTarget(w,ϕ→ [a]ψ,M ,M)}\nfor some M = 〈W,R〉 ∈ M. Let u ∈W′ be such that 6|=M ′\nu ϕ→ [a]ψ. Then there is u′ ∈W′ such that (u, u′) ∈ R′a and\n6|=M ′\nu′ ψ. Because u ϕ, there is v ∈ base(ϕ,W′) such that v ⊆ u, and as u′ ¬ψ, there must be v′ ∈ base(¬ψ,W′) such that v′ ⊆ u′. Let π = ∧ `∈v `, ϕA = ∧ `∈u\\v `, and π ′ = ∧ `∈v′ `. Clearly π (resp. π′) is a prime implicant of S ∧ ϕ (resp. S ∧ ¬ψ). Now let E−a = ⋃ 1≤i≤n(E ϕ,ψ a )i and let the theory\nT ′ =\n(T \\ E−a ) ∪ {(ϕi ∧ ¬(π ∧ ϕA))→ [a]ψi : ϕi → [a]ψi ∈ E−a } ∪ {(ϕi ∧ π ∧ ϕA)→ [a](ψi ∨ π′) : ϕi → [a]ψi ∈ E−a } ∪ ` ∈ L, for some L ⊆ Lit s.t. (π ∧ ϕA ∧ `)→ [a](ψ ∨ `) : S 6` (π′ ∧ ∧ `∈L `)→ ⊥, and ` ∈ π′\nor T 6 K̀n (π ∧ ϕA ∧ `)→ [a]¬`  (Clearly, T ′ is a theory produced by Algorithm 2.)\nIn order to show that M ′ is a model of T ′, it is enough to show that it is a model of the added laws. Given (ϕi∧¬(π∧ϕA))→ [a]ψi ∈ T ′, for every w ∈W′, if |= M ′\nw ϕi∧¬(π∧ϕA), then\n|=M ′\nw ϕi, and then |=\nM w ϕi. Because |= M ϕi → [a]ψi, |= M w′ ψi for all w ′ ∈W such that (w,w′) ∈ Ra. We need to show that R′a(w) = Ra(w). If 6|= M w ϕ, then Rϕ,¬ψa = ∅, and then R′a(w) = Ra(w). If |=M w ϕ, then either w = u, and from |=M ′ u π ∧ ϕA we conclude |= M ′ u (ϕi ∧ ¬(π ∧ ϕA))→ [a]ψi, or w 6= u, and then we must have Rϕ,¬ψa = ∅, otherwise there would be Sϕ,¬ψa ⊂ Rϕ,¬ψa such that R−̇(R∪ Sϕ,¬ψa ) ⊂ R−̇(R∪Rϕ,¬ψa ), and then M ′′ = 〈W′,R∪ Sϕ,¬ψa 〉 would be such that 6|=M ′′ ϕ → [a]ψ and M ′′ M M ′, a contradiction since M ′ is minimal with respect to M . Hence R′a(w) = Ra(w), and |= M ′\nw′ ψi for all w\n′ such that (w,w′) ∈ R′a.\nNow, given (ϕi ∧ π ∧ ϕA) → [a](ψi ∨ π′), for every w ∈ W′, if |= M ′\nw ϕi ∧ π ∧ ϕA, then\n|=M ′\nw ϕi, and then |=\nM w ϕi. Because, |= M ϕi → [a]ψi, we have |= M w′ ψi for all w ′ ∈ W such that\n(w,w′) ∈ Ra, and then |= M ′\nw′ ψi for every w\n′ ∈W′ such that (w,w′) ∈ R′a \\Rϕ,¬ψa . Now, given\n(w,w′) ∈ Rϕ,¬ψa , |= M ′ w′ π′, and the result follows.\nNow, for each (π ∧ ϕA ∧ `) → [a](ψ ∨ `), for every w ∈ W′, if |= M ′\nw π ∧ ϕA ∧ `, then\n|=M ′\nw ϕ, and then |=M w ϕ. Because |=M ϕ → [a]ψ, we have |=M w′ ψ for every w′ ∈ W such that\n(w,w′) ∈ Ra, and then |= M ′\nw′ ψ for all w′ ∈ W′ such that (w,w′) ∈ R′a \\ Rϕ,¬ψa . It remains to\nshow that |=M ′\nw′ ` for every w′ ∈ W′ such that (w,w′) ∈ Rϕ,¬ψa . Since M ′ is minimal, it is\nenough to show that |=M ′\nu′ ` for every ` ∈ Lit such that |=M\n′\nu π ∧ ϕA ∧ `. If ` ∈ π′, the result\nfollows. Otherwise, suppose 6|=M ′\nu′ `. Then\n• either ¬` ∈ π′, then π′ and ` are unsatisfiable, and in this case Algorithm 2 has not put the law (π ∧ ϕA ∧ `)→ [a](ψ ∨ `) in T ′, a contradiction;\n• or ¬` ∈ u′ \\ v′. In this case, there is a valuation u′′ = (u′ \\ {¬`}) ∪ {`} such that u′′ 6 ψ. We must have u′′ ∈W′, otherwise there will be L′ = {`i : `i ∈ u′′} such that T |=\nKn (π′∧ ∧ `i∈L′ `i)→ ⊥, and, because T is modular, S |=CPL(π ′∧ ∧ `i∈L′ `i)→ ⊥, and then Algorithm 2 has not put the law (π∧ϕA ∧ `)→ [a](ψ∨ `) in T ′, a contradiction. Then u′′ ∈ W′, and moreover u′′ /∈ Rϕ,¬ψa (u), otherwise M ′ is not minimal. As u′′ \\u ⊂ u′ \\u, the only reason why u′′ /∈ Rϕ,¬ψa (u) is that there is `′ ∈ u∩u′′ such that |=Mi ∧ `j∈u `j → [a]¬` ′ for every Mi ∈M if and only if `′ /∈ v′ for any v′ ∈ base(¬ψ,W ′)\nsuch that v′ ⊆ u′′. Clearly `′ = `, and because ` /∈ π′, we have |=Mi ∧ `j∈u `j → [a]¬` for every Mi ∈ M. Then T |=Kn (π ∧ ϕA ∧ `) → [a]¬`, and then Algorithm 2 has not put the law (π ∧ ϕA ∧ `)→ [a](ψ ∨ `) in T ′, a contradiction.\nHence we have |=M ′\nw′ ψ ∨ ` for every w′ ∈W′ such that (w,w′) ∈ R′a.\nPutting the above results together, we get |=M ′ T ′.\nLet now Φ be some propositional ϕ. Then M ′ = 〈W′,R′〉, where W ⊆ W′, R′ = R, is minimal with respect to M , i.e., W′ is a minimal superset of W such that there is u ∈W′\nwith u 6 ϕ. Because we have assumed the syntactical classical contraction operator is sound and complete with respect to its semantics and is moreover minimal, then there must be S− ∈ S ϕ such that W′ = val(S−). Therefore |=M ′ S−.\nBecause R′ = R, every effect law of T remains true in M ′.\nNow, let\nT ′ = ((T \\ S ) ∪ S−) \\ Xa ∪ {(ϕi ∧ ϕ)→ 〈a〉> : ϕi → 〈a〉> ∈ Xa} ∪ {¬ϕ→ [a]⊥}\n(Clearly, T ′ is a theory produced by Algorithm 3.) For every (ϕi ∧ ϕ) → 〈a〉> ∈ T ′ and every w ∈ W′, if |= M ′\nw ϕi ∧ ϕ, then Ra(w) 6= ∅,\nbecause |=M w ϕi → 〈a〉>. Given ¬ϕ → [a]⊥, for every w ∈ W′, if |=\nM ′ w ¬ϕ, then w = u, and\nRa(w) = ∅.\nPutting all these results together, we have |=M ′ T ′. 2"
    }, {
      "heading" : "Appendix B. Proof of Theorem 6.3",
      "text" : "Let T be modular, Φ a law, and T ′ ∈ T−Φ . For all M ′ such that |= M ′T ′, there is M′ ∈ M−Φ such that M ′ ∈M′ and |=MT for every M ∈M.\nIn order to prove this result, first we need to show four important lemmas.\nLemma B.1 Let Φ be a law. If T is modular, then every T ′ ∈ T−Φ is modular.\nProof: Let Φ be nonclassical, and suppose there is T ′ ∈ T−Φ such that T ′ is not modular. Then there is some ϕ′ ∈ Fml such that T ′ |=\nKn ϕ′ and S ′ 6|= CPL ϕ′, where S ′ is the set of static\nlaws in T ′. By Lemma A.1, T |= Kn T ′, and then we have T |= Kn ϕ′. Because Φ is nonclassical, S ′ = S . Thus S 6|= CPL ϕ′, and therefore T is not modular.\nLet now Φ be some ϕ ∈ Fml. Then\nT ′ = ((T \\ S ) ∪ S−) \\ Xa ∪ {(ϕi ∧ ϕ)→ 〈a〉> : ϕi → 〈a〉> ∈ Xa} ∪ {¬ϕ→ [a]⊥}\nfor some S− ∈ S ϕ. Assume that T is modular, and let ϕ′ ∈ Fml be such that T ′ |=\nKn ϕ′ and S− 6|= CPL ϕ′.\nAs S− 6|= CPL ϕ′, there is v ∈ val(S−) such that v 6 ϕ′. If v ∈ val(S ), then S 6|= CPL ϕ′, and as T is modular, T 6|=\nKn ϕ′. By Lemma A.1, T |= Kn T ′, and we have T ′ 6|= Kn ϕ′, a contradiction.\nHence v /∈ val(S ). Moreover, we must have v 6 ϕ, otherwise has not worked as expected. Let M = 〈W,R〉 be such that |=M T ′. (We extend M to another model of T ′.) Let M ′ = 〈W′,R′〉 be such that W′ = W ∪ {v} and R′ = R. To show that M ′ is a model of T ′, it suffices to show that v satisfies every law in T ′. As v ∈ val(S−), |=M ′\nv S−. Given\n¬ϕ→ [a]⊥ ∈ T ′, as v 6 ϕ and R′a(v) = ∅, |= M ′ v ¬ϕ→ [a]⊥. Now, for every ϕi → [a]ψi ∈ T ′, if |=M ′\nv ϕi, then we trivially have |=\nM ′ v′ ψi for every v ′ such that (v, v′) ∈ R′a. Finally, given\n(ϕi ∧ϕ)→ 〈a〉> ∈ T ′, as v 6 ϕ, the formula trivially holds in v. Hence |= M ′T ′, and because there is v ∈W′ such that 6|=M ′\nv ϕ′, we have T ′ 6|= Kn ϕ′, a contradiction. Hence for all ϕ′ ∈ Fml\nsuch that T ′ |= Kn ϕ′, S− |= CPL ϕ′, and then T ′ is modular. 2\nLemma B.2 If Mcan = 〈Wcan,Rcan〉 is a model of T, then for every M = 〈W,R〉 such that |=M T there is a minimal (with respect to set inclusion) extension R′ ⊆ Rcan \\ R such that M ′ = 〈val(S ),R ∪ R′〉 is a model of T.\nProof: Let Mcan = 〈Wcan,Rcan〉 be a model of T, and let M = 〈W,R〉 be such that |= MT. Consider M ′ = 〈val(S ),R〉. If |=M ′ T, we have R′ = ∅ ⊆ Rcan \\ R that is minimal. Suppose then 6|=M ′ T. We extend M ′ to a model of T that is a minimal extension of M . As 6|=M ′ T, there is v ∈ val(S ) \\W such that 6|=M ′\nv T. Then there is Φ ∈ T such that 6|=M\n′\nv Φ. If Φ is\nsome ϕ ∈ Fml, as v ∈ Wcan, Mcan is not a model of T. If Φ is of the form ϕ → [a]ψ, for ϕ,ψ ∈ Fml, there is v′ ∈ val(S ) such that (v, v′) ∈ Ra and v′ 6 ψ, a contradiction since Ra(v) = ∅. Let now Φ have the form ϕ→ 〈a〉> for some ϕ ∈ Fml. Then |= M ′\nv ϕ. As v ∈Wcan,\nif 6|=Mcan v ϕ → 〈a〉>, then 6|=McanT. Hence, Rcana(v) 6= ∅. Thus taking any (v, v′) ∈ Rcana gives us a minimal R′ = {(v, v′)} such that M ′′ = 〈val(S ),R ∪ R′〉 is a model of T. 2\nLemma B.3 Let T be modular, and Φ be a law. Then T |= Kn Φ if and only if every M ′ = 〈val(S ),R′〉 such that |=〈W,R〉T and R ⊆ R′ is a model of Φ.\nProof: (⇒): Straightforward, since T |= Kn Φ implies |=MΦ for every M such that |=MT, in particular for those which are extensions of some model of T.\n(⇐): Suppose T 6|= Kn Φ. Then there is M = 〈W,R〉 such that |=MT and 6|=MΦ. As T is modular, the canonical frame Mcan = 〈Wcan,Rcan〉 of T is a model of T. Then by Lemma B.2 there is a minimal extension R′ of R with respect to Rcan such that M ′ = 〈val(S ),R∪R′〉 is a model of T. Because 6|=MΦ, there is w ∈ W such that 6|=M\nw Φ. If Φ is some propositional ϕ ∈ Fml or\nan effect law, any extension M ′ of M is such that 6|=M ′\nw Φ. If Φ is of the form ϕ → 〈a〉>,\nthen |=M w ϕ and Ra(w) = ∅. As any extension of M is such that (u, v) ∈ R′ if and only if u ∈ val(S ) \\W, only worlds other than those in W get a new departing transition. Thus (R ∪ R′)a(w) = ∅, and then 6|= M ′\nw Φ. 2\nLemma B.4 Let T be modular, Φ a law, and T ′ ∈ T−Φ . If M ′ = 〈val(S ′),R′〉 is a model of T ′, then there is M = {M : M = 〈val(S ),R〉 and |=M T} such that M ′ ∈ M′ for some M′ ∈M−Φ .\nProof: Let M ′ = 〈val(S ′),R′〉 be such that |=M ′ T ′. If |=M ′ T, the result follows. Let us suppose then 6|=M ′ T. We analyze each case.\nLet Φ be of the form ϕ → 〈a〉>, for some ϕ ∈ Fml. Let M = {M : M = 〈val(S ),R〉}. Since by hypothesis T is modular, from Lemmas B.2 and B.3 it follows thatM is non-empty and contains only models of T.\nSuppose M ′ is not a minimal model of T ′, i.e., there is M ′′ such that M ′′ M M ′ for some M ∈ M. Then M ′ and M ′′ differ only in the executability of a in a given ϕ-world, viz. a π ∧ ϕA-context, for some π ∈ IP(S ∧ ϕ) and ϕA = ∧ pi∈atm(π)\npi∈A pi ∧\n∧ pi∈atm(π)\npi /∈A\n¬pi such\nthat A ⊆ atm(π). Because 6|=M ′ (π ∧ ϕA) → 〈a〉>, we must have |= M ′′ (π ∧ ϕA) → 〈a〉> and then |=M ′′ T. Hence M ′ is minimal with respect to M .\nWhen contracting executability laws, S ′ = S . Hence taking the right R and a minimal Rϕa such that M = 〈val(S ),R〉 and R′ = R\\Rϕa , for some Rϕa ⊆ {(w,w′) :|= M w ϕ and (w,w′) ∈ Ra}, we construct M′ =M∪ {M ′} ∈ M−ϕ→〈a〉>.\nLet Φ now be of the form ϕ→ [a]ψ, for ϕ,ψ ∈ Fml. Let M = {M : M = 〈val(S ),R〉}. Since by hypothesis T is modular, from Lemmas B.2 and B.3 it follows thatM is non-empty and contains only models of T.\nWe claim that M ′ has only one transition linking a ϕ-world, viz. a context ϕi ∧ π ∧ ϕA for some π ∈ IP(S ∧ ϕ) and ϕA = ∧ pi∈atm(π)\npi∈A pi ∧\n∧ pi∈atm(π)\npi /∈A\n¬pi, such that A ⊆ atm(π), to a\nπ′-world, where π′ ∈ IP(S ∧ ¬ψ). The proof is as follows: given ` ∈ Lit such that ` holds in this ϕi ∧ π ∧ ϕA-world\n• if (π ∧ ϕA ∧ `) → [a](ψ ∨ `) /∈ T ′, then ` /∈ π′ and T |=Kn (π ∧ ϕA ∧ `) → [a]¬`. Then this world has only ¬`-successors.\n• if (π ∧ ϕA ∧ `)→ [a](ψ ∨ `) ∈ T ′, then every π′-successor is an `-world.\nBy successively applying this reasoning to each ` that holds in this ϕi ∧ π ∧ ϕA-world, we will end up with only one π′-successor.\nSuppose now that M ′ is not a minimal model of T ′, i.e., there is M ′′ such that |=M ′′ T ′ and M ′′ M M ′ for some M ∈ M. Then M ′ and M ′′ differ only in the effects on that ϕi ∧ π ∧ ϕA-world: M ′′ has no transition linking it to a π′-world. Then we have |=M ′′ (ϕi ∧ π ∧ ϕA) → [a]ψi, and then |=\nM ′′T. Therefore M ′ is a minimal model of T ′ with respect to M .\nWhen contracting effect laws, S ′ = S . Thus taking the right R and a minimal Rϕ,ψa such that M = 〈val(S ),R〉 and R′ = R ∪ Rϕ,ψa , for some Rϕ,ψa ⊆ {(w,w′) :|= M w ϕ and w′ ∈ RelTarget(w,ϕ→ [a]ψ,M ,M)}, we construct M′ =M∪ {M ′} ∈ M−ϕ→[a]ψ.\nLet now Φ be ϕ for some ϕ ∈ Fml. Since T is modular, by Lemmas B.2 and B.3 there is M = 〈val(S ),R〉 such that |=M T. We know val(S ) ⊆ val(S−). Because ¬ϕ → [a]⊥ ∈ T ′, R′a(v) = ∅ for every ¬ϕ-world v added in M ′. Hence, because is minimal, taking M = {M } gives us the result. 2\nProof of Theorem 6.3\nFrom the hypothesis that T is modular and Lemma B.1, it follows that T ′ is modular, too. Then M ′ = 〈val(S ′),R〉 is a model of T ′, by Lemma B.3. From this and Lemma B.4 the result follows. 2"
    } ],
    "references" : [ {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "C. Alchourrón", "P. Gärdenfors", "D. Makinson" ],
      "venue" : "Journal of Symbolic Logic,",
      "citeRegEx" : "Alchourrón et al\\.,? \\Q1985\\E",
      "shortCiteRegEx" : "Alchourrón et al\\.",
      "year" : 1985
    }, {
      "title" : "Description Logic Handbook",
      "author" : [ "F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P. Patel-Schneider" ],
      "venue" : null,
      "citeRegEx" : "Baader et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2003
    }, {
      "title" : "Defeasible specifications in action theories",
      "author" : [ "C. Baral", "J. Lobo" ],
      "venue" : "Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Baral and Lobo,? \\Q1997\\E",
      "shortCiteRegEx" : "Baral and Lobo",
      "year" : 1997
    }, {
      "title" : "Next steps in propositional Horn contraction",
      "author" : [ "R. Booth", "T. Meyer", "I. Varzinczak" ],
      "venue" : "Proceedings of the 21st International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Booth et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Booth et al\\.",
      "year" : 2009
    }, {
      "title" : "Merging inference and conjecture",
      "author" : [ "I. Burger", "J. Heidema" ],
      "venue" : "by information. Synthese,",
      "citeRegEx" : "Burger and Heidema,? \\Q2002\\E",
      "shortCiteRegEx" : "Burger and Heidema",
      "year" : 2002
    }, {
      "title" : "Formalizing action and change in modal logic I: the frame problem",
      "author" : [ "M. Castilho", "O. Gasquet", "A. Herzig" ],
      "venue" : "Journal of Logic and Computation,",
      "citeRegEx" : "Castilho et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Castilho et al\\.",
      "year" : 1999
    }, {
      "title" : "It depends on the context! A decidable logic of actions and plans based on a ternary dependence relation",
      "author" : [ "M. Castilho", "A. Herzig", "I. Varzinczak" ],
      "venue" : "In 9th International Workshop on Nonmonotonic Reasoning (NMR)",
      "citeRegEx" : "Castilho et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Castilho et al\\.",
      "year" : 2002
    }, {
      "title" : "Checking regulation consistency by using SOL-resolution",
      "author" : [ "L. Cholvy" ],
      "venue" : "Proceedings of the 7th International Conference on AI and Law, pp. 73–79.",
      "citeRegEx" : "Cholvy,? 1999",
      "shortCiteRegEx" : "Cholvy",
      "year" : 1999
    }, {
      "title" : "Investigations into a theory of knowledge base revision: preliminary report",
      "author" : [ "M. Dalal" ],
      "venue" : "Smith, R., & Mitchell, T. (Eds.), Proceedings of the 7th National Conference on Artificial Intelligence (AAAI), pp. 475–479. Morgan Kaufmann Publishers.",
      "citeRegEx" : "Dalal,? 1988",
      "shortCiteRegEx" : "Dalal",
      "year" : 1988
    }, {
      "title" : "PDL-based framework for reasoning about actions",
      "author" : [ "G. De Giacomo", "M. Lenzerini" ],
      "venue" : "Proceedings of the 4th Congress of the Italian Association for Artificial Intelligence (IA*AI),",
      "citeRegEx" : "Giacomo and Lenzerini,? \\Q1995\\E",
      "shortCiteRegEx" : "Giacomo and Lenzerini",
      "year" : 1995
    }, {
      "title" : "Personal communication",
      "author" : [ "J. Delgrande" ],
      "venue" : "Commonsense’09, Toronto.",
      "citeRegEx" : "Delgrande,? 2009",
      "shortCiteRegEx" : "Delgrande",
      "year" : 2009
    }, {
      "title" : "Regression in modal logic",
      "author" : [ "R. Demolombe", "A. Herzig", "I. Varzinczak" ],
      "venue" : "Journal of Applied Non-Classical Logic,",
      "citeRegEx" : "Demolombe et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Demolombe et al\\.",
      "year" : 2003
    }, {
      "title" : "Updating action domain descriptions",
      "author" : [ "T. Eiter", "E. Erdem", "M. Fink", "J. Senko" ],
      "venue" : "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Eiter et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2005
    }, {
      "title" : "Exploiting constraints in design synthesis",
      "author" : [ "J. Finger" ],
      "venue" : "Ph.D. thesis, Stanford University.",
      "citeRegEx" : "Finger,? 1987",
      "shortCiteRegEx" : "Finger",
      "year" : 1987
    }, {
      "title" : "Generalizing the AGM postulates",
      "author" : [ "G. Flouris", "D. Plexousakis", "G. Antoniou" ],
      "venue" : "In 10th International Workshop on Nonmonotonic Reasoning (NMR)",
      "citeRegEx" : "Flouris et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Flouris et al\\.",
      "year" : 2004
    }, {
      "title" : "On the modal logic of theory change",
      "author" : [ "A. Fuhrmann" ],
      "venue" : "The Logic of Theory Change, pp. 259–281.",
      "citeRegEx" : "Fuhrmann,? 1989",
      "shortCiteRegEx" : "Fuhrmann",
      "year" : 1989
    }, {
      "title" : "Knowledge in Flux: Modeling the Dynamics of Epistemic States",
      "author" : [ "P. Gärdenfors" ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Gärdenfors,? 1988",
      "shortCiteRegEx" : "Gärdenfors",
      "year" : 1988
    }, {
      "title" : "Representing action and change by logic programs",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Journal of Logic Programming,",
      "citeRegEx" : "Gelfond and Lifschitz,? \\Q1993\\E",
      "shortCiteRegEx" : "Gelfond and Lifschitz",
      "year" : 1993
    }, {
      "title" : "Representing action: indeterminacy and ramifications",
      "author" : [ "E. Giunchiglia", "G. Kartha", "V. Lifschitz" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Giunchiglia et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 1997
    }, {
      "title" : "Error detecting and error correcting codes",
      "author" : [ "R. Hamming" ],
      "venue" : "Bell System Technical Journal, 26 (2), 147–160.",
      "citeRegEx" : "Hamming,? 1950",
      "shortCiteRegEx" : "Hamming",
      "year" : 1950
    }, {
      "title" : "Kernel contraction",
      "author" : [ "S. Hansson" ],
      "venue" : "Journal of Symbolic Logic, 59 (3), 845–859.",
      "citeRegEx" : "Hansson,? 1994",
      "shortCiteRegEx" : "Hansson",
      "year" : 1994
    }, {
      "title" : "A Textbook of Belief Dynamics: Theory Change and Database Updating",
      "author" : [ "S. Hansson" ],
      "venue" : "Kluwer Academic Publishers.",
      "citeRegEx" : "Hansson,? 1999",
      "shortCiteRegEx" : "Hansson",
      "year" : 1999
    }, {
      "title" : "Elaborating domain descriptions",
      "author" : [ "A. Herzig", "L. Perrussel", "I. Varzinczak" ],
      "venue" : "Proceedings of the 17th European Conference on Artificial Intelligence (ECAI),",
      "citeRegEx" : "Herzig et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Herzig et al\\.",
      "year" : 2006
    }, {
      "title" : "Propositional belief base update and minimal change",
      "author" : [ "A. Herzig", "O. Rifi" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Herzig and Rifi,? \\Q1999\\E",
      "shortCiteRegEx" : "Herzig and Rifi",
      "year" : 1999
    }, {
      "title" : "Domain descriptions should be modular",
      "author" : [ "A. Herzig", "I. Varzinczak" ],
      "venue" : "Proceedings of the 16th European Conference on Artificial Intelligence (ECAI),",
      "citeRegEx" : "Herzig and Varzinczak,? \\Q2004\\E",
      "shortCiteRegEx" : "Herzig and Varzinczak",
      "year" : 2004
    }, {
      "title" : "Cohesion, coupling and the meta-theory of actions",
      "author" : [ "A. Herzig", "I. Varzinczak" ],
      "venue" : "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Herzig and Varzinczak,? \\Q2005\\E",
      "shortCiteRegEx" : "Herzig and Varzinczak",
      "year" : 2005
    }, {
      "title" : "On the modularity of theories",
      "author" : [ "A. Herzig", "I. Varzinczak" ],
      "venue" : "Advances in Modal Logic,",
      "citeRegEx" : "Herzig and Varzinczak,? \\Q2005\\E",
      "shortCiteRegEx" : "Herzig and Varzinczak",
      "year" : 2005
    }, {
      "title" : "Metatheory of actions: beyond consistency",
      "author" : [ "A. Herzig", "I. Varzinczak" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Herzig and Varzinczak,? \\Q2007\\E",
      "shortCiteRegEx" : "Herzig and Varzinczak",
      "year" : 2007
    }, {
      "title" : "Iterated belief revision, revised",
      "author" : [ "Y. Jin", "M. Thielscher" ],
      "venue" : "Proceedings of the 19th International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Jin and Thielscher,? \\Q2005\\E",
      "shortCiteRegEx" : "Jin and Thielscher",
      "year" : 2005
    }, {
      "title" : "On the difference between updating a knowledge base and revising it",
      "author" : [ "H. Katsuno", "A. Mendelzon" ],
      "venue" : "Belief revision,",
      "citeRegEx" : "Katsuno and Mendelzon,? \\Q1992\\E",
      "shortCiteRegEx" : "Katsuno and Mendelzon",
      "year" : 1992
    }, {
      "title" : "Properties of independently axiomatizable bimodal logics",
      "author" : [ "M. Kracht", "F. Wolter" ],
      "venue" : "Journal of Symbolic Logic,",
      "citeRegEx" : "Kracht and Wolter,? \\Q1991\\E",
      "shortCiteRegEx" : "Kracht and Wolter",
      "year" : 1991
    }, {
      "title" : "Subjunctives, dispositions and chances",
      "author" : [ "I. Levi" ],
      "venue" : "Synthese, 34, 423–455.",
      "citeRegEx" : "Levi,? 1977",
      "shortCiteRegEx" : "Levi",
      "year" : 1977
    }, {
      "title" : "What is believed is what is explained",
      "author" : [ "R. Li", "L. Pereira" ],
      "venue" : "Proceedings of the 13th National Conference on Artificial Intelligence (AAAI),",
      "citeRegEx" : "Li and Pereira,? \\Q1996\\E",
      "shortCiteRegEx" : "Li and Pereira",
      "year" : 1996
    }, {
      "title" : "A framework for belief update",
      "author" : [ "P. Liberatore" ],
      "venue" : "Proceedings of the 7th European Conference on Logics in Artificial Intelligence (JELIA), pp. 361–375.",
      "citeRegEx" : "Liberatore,? 2000",
      "shortCiteRegEx" : "Liberatore",
      "year" : 2000
    }, {
      "title" : "Friendliness and sympathy in logic",
      "author" : [ "D. Makinson" ],
      "venue" : "Béziau, J.-Y. (Ed.), Logica Universalis, Vol. 2, pp. 195–224. Springer-Verlag.",
      "citeRegEx" : "Makinson,? 2007",
      "shortCiteRegEx" : "Makinson",
      "year" : 2007
    }, {
      "title" : "Consequence finding algorithms",
      "author" : [ "P. Marquis" ],
      "venue" : "Gabbay, D., & Smets, P. (Eds.), Handbook on Defeasible Reasoning and Uncertainty Management Systems, Vol. 5: Algorithms for Uncertainty and Defeasible Reasoning, edited by J. Kohlas and S. Moral, chap. 2, pp. 41–145. Kluwer Academic Publishers.",
      "citeRegEx" : "Marquis,? 2000",
      "shortCiteRegEx" : "Marquis",
      "year" : 2000
    }, {
      "title" : "Epistemological problems of artificial intelligence",
      "author" : [ "J. McCarthy" ],
      "venue" : "Sridharan, N. (Ed.), Proceedings of the 5th International Joint Conference on Artificial Intelligence (IJCAI), pp. 1038–1044. Morgan Kaufmann Publishers.",
      "citeRegEx" : "McCarthy,? 1977",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1977
    }, {
      "title" : "Elaboration tolerance",
      "author" : [ "J. McCarthy" ],
      "venue" : "Proceedings of the 4th International Symposium on Logical Formalizations of Commonsense Reasoning.",
      "citeRegEx" : "McCarthy,? 1998",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1998
    }, {
      "title" : "Some philosophical problems from the standpoint of artificial intelligence",
      "author" : [ "J. McCarthy", "P. Hayes" ],
      "venue" : "Machine Intelligence,",
      "citeRegEx" : "McCarthy and Hayes,? \\Q1969\\E",
      "shortCiteRegEx" : "McCarthy and Hayes",
      "year" : 1969
    }, {
      "title" : "A knowledge level analysis of belief revision",
      "author" : [ "B. Nebel" ],
      "venue" : "Brachman, R., Levesque, H., & Reiter, R. (Eds.), Proceedings of the 1st International Conference on Principles of Knowledge Representation and Reasoning (KR), pp. 301–311. Morgan Kaufmann Publishers.",
      "citeRegEx" : "Nebel,? 1989",
      "shortCiteRegEx" : "Nebel",
      "year" : 1989
    }, {
      "title" : "Beliefs, belief revision, and splitting languages",
      "author" : [ "R. Parikh" ],
      "venue" : "Moss, L. (Ed.), Logic, Language and Computation, No. 96 in CSLI Lecture Notes, pp. 266–278. CSLI Publications.",
      "citeRegEx" : "Parikh,? 1999",
      "shortCiteRegEx" : "Parikh",
      "year" : 1999
    }, {
      "title" : "First Steps in Modal Logic",
      "author" : [ "S. Popkorn" ],
      "venue" : "Cambridge University Press.",
      "citeRegEx" : "Popkorn,? 1994",
      "shortCiteRegEx" : "Popkorn",
      "year" : 1994
    }, {
      "title" : "The problem of simplifying truth functions",
      "author" : [ "W. Quine" ],
      "venue" : "American Mathematical Monthly, 59, 521–531.",
      "citeRegEx" : "Quine,? 1952",
      "shortCiteRegEx" : "Quine",
      "year" : 1952
    }, {
      "title" : "Paradox",
      "author" : [ "W. Quine" ],
      "venue" : "Scientific American, 1, 84–96.",
      "citeRegEx" : "Quine,? 1962",
      "shortCiteRegEx" : "Quine",
      "year" : 1962
    }, {
      "title" : "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems",
      "author" : [ "R. Reiter" ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Reiter,? 2001",
      "shortCiteRegEx" : "Reiter",
      "year" : 2001
    }, {
      "title" : "Coherent Systems",
      "author" : [ "K. Schlechta" ],
      "venue" : "Studies in Logic and Practical Reasoning 2. Elsevier.",
      "citeRegEx" : "Schlechta,? 2004",
      "shortCiteRegEx" : "Schlechta",
      "year" : 2004
    }, {
      "title" : "Solving the frame problem: a mathematical investigation of the common sense law of inertia",
      "author" : [ "M. Shanahan" ],
      "venue" : "MIT Press.",
      "citeRegEx" : "Shanahan,? 1997",
      "shortCiteRegEx" : "Shanahan",
      "year" : 1997
    }, {
      "title" : "Iterated belief change in the situation calculus",
      "author" : [ "S. Shapiro", "M. Pagnucco", "Y. Lespérance", "H. Levesque" ],
      "venue" : "Proceedings of the 7th International Conference on Principles of Knowledge Representation and Reasoning (KR),",
      "citeRegEx" : "Shapiro et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Shapiro et al\\.",
      "year" : 2000
    }, {
      "title" : "Ramification and causality",
      "author" : [ "M. Thielscher" ],
      "venue" : "Artificial Intelligence, 89 (1–2), 317–364.",
      "citeRegEx" : "Thielscher,? 1997",
      "shortCiteRegEx" : "Thielscher",
      "year" : 1997
    }, {
      "title" : "A unifying action calculus",
      "author" : [ "M. Thielscher" ],
      "venue" : "To appear in Artificial Intelligence.",
      "citeRegEx" : "Thielscher,? 2010",
      "shortCiteRegEx" : "Thielscher",
      "year" : 2010
    }, {
      "title" : "What is a good domain description? Evaluating and revising action theories in dynamic logic",
      "author" : [ "I. Varzinczak" ],
      "venue" : "Ph.D. thesis, Université Paul Sabatier, Toulouse.",
      "citeRegEx" : "Varzinczak,? 2006",
      "shortCiteRegEx" : "Varzinczak",
      "year" : 2006
    }, {
      "title" : "Action theory contraction and minimal change",
      "author" : [ "I. Varzinczak" ],
      "venue" : "Lang, J., & Brewka, G. (Eds.), Proceedings of the 11th International Conference on Principles of Knowledge Representation and Reasoning (KR), pp. 651–661. AAAI Press.",
      "citeRegEx" : "Varzinczak,? 2008",
      "shortCiteRegEx" : "Varzinczak",
      "year" : 2008
    }, {
      "title" : "On the revision of action laws: an algorithmic approach",
      "author" : [ "I. Varzinczak" ],
      "venue" : "IJCAI Workshop on Nonmonotonic Reasoning, Action and Change (NRAC).",
      "citeRegEx" : "Varzinczak,? 2009",
      "shortCiteRegEx" : "Varzinczak",
      "year" : 2009
    }, {
      "title" : "Reasoning about action using a possible models approach",
      "author" : [ "Winslett", "M.-A." ],
      "venue" : "Smith, R., & Mitchell, T. (Eds.), Proceedings of the 7th National Conference on Artificial Intelligence (AAAI), pp. 89–93. Morgan Kaufmann Publishers.",
      "citeRegEx" : "Winslett and M..A.,? 1988",
      "shortCiteRegEx" : "Winslett and M..A.",
      "year" : 1988
    }, {
      "title" : "Consistency of action descriptions",
      "author" : [ "D. Zhang", "S. Chopra", "N. Foo" ],
      "venue" : "Proceedings of the 7th Pacific Rim International Conference on Artificial Intelligence,",
      "citeRegEx" : "Zhang et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Zhang et al\\.",
      "year" : 2002
    }, {
      "title" : "EPDL: A logic for causal reasoning",
      "author" : [ "D. Zhang", "N. Foo" ],
      "venue" : "Proceedings of the 17th International Joint Conference on Artificial Intelligence (IJCAI),",
      "citeRegEx" : "Zhang and Foo,? \\Q2001\\E",
      "shortCiteRegEx" : "Zhang and Foo",
      "year" : 2001
    }, {
      "title" : "CTL model update for system modifications",
      "author" : [ "Y. Zhang", "Y. Ding" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Zhang and Ding,? \\Q2008\\E",
      "shortCiteRegEx" : "Zhang and Ding",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 16,
      "context" : "literature about belief revision (Alchourrón, Gärdenfors, & Makinson, 1985; Gärdenfors, 1988; Hansson, 1999) and belief update (Katsuno & Mendelzon, 1992).",
      "startOffset" : 33,
      "endOffset" : 108
    }, {
      "referenceID" : 21,
      "context" : "literature about belief revision (Alchourrón, Gärdenfors, & Makinson, 1985; Gärdenfors, 1988; Hansson, 1999) and belief update (Katsuno & Mendelzon, 1992).",
      "startOffset" : 33,
      "endOffset" : 108
    }, {
      "referenceID" : 21,
      "context" : "in epistemic logic (Hansson, 1999) and in dynamic logics (Herzig, Perrussel, & Varzinczak, 2006).",
      "startOffset" : 19,
      "endOffset" : 34
    }, {
      "referenceID" : 14,
      "context" : "Since the work by Fuhrmann (1989), only in a few recent studies has it been considered in the realm of modal logics, viz.",
      "startOffset" : 18,
      "endOffset" : 34
    }, {
      "referenceID" : 2,
      "context" : "Starting with Baral and Lobo’s work (1997), some recent studies have been done on that issue (Eiter, Erdem, Fink, & Senko, 2005) for domain descriptions in action languages (Gelfond & Lifschitz, 1993).",
      "startOffset" : 14,
      "endOffset" : 43
    }, {
      "referenceID" : 46,
      "context" : "Following the tradition in the Reasoning about Actions and Change (RAC) community, we consider action theories to be finite collections of statements that have the particular form (Shanahan, 1997):",
      "startOffset" : 180,
      "endOffset" : 196
    }, {
      "referenceID" : 46,
      "context" : "Several logical frameworks have been proposed to formalize such statements (Shanahan, 1997).",
      "startOffset" : 75,
      "endOffset" : 91
    }, {
      "referenceID" : 44,
      "context" : "Among the most prominent ones are the first-order based Situation Calculus (McCarthy & Hayes, 1969; Reiter, 2001), the family of Action Languages (Gelfond & Lifschitz, 1993; Giunchiglia, Kartha, & Lifschitz, 1997), the Fluent Calculus (Thielscher, 1997), and Propositional Dynamic Logic (PDL) (Harel, Tiuryn, & Kozen, 2000) with different specific extensions thereof (De Giacomo & Lenzerini, 1995; Castilho, Gasquet, & Herzig, 1999; Zhang & Foo, 2001; Castilho, Herzig, & Varzinczak, 2002).",
      "startOffset" : 75,
      "endOffset" : 113
    }, {
      "referenceID" : 48,
      "context" : "Among the most prominent ones are the first-order based Situation Calculus (McCarthy & Hayes, 1969; Reiter, 2001), the family of Action Languages (Gelfond & Lifschitz, 1993; Giunchiglia, Kartha, & Lifschitz, 1997), the Fluent Calculus (Thielscher, 1997), and Propositional Dynamic Logic (PDL) (Harel, Tiuryn, & Kozen, 2000) with different specific extensions thereof (De Giacomo & Lenzerini, 1995; Castilho, Gasquet, & Herzig, 1999; Zhang & Foo, 2001; Castilho, Herzig, & Varzinczak, 2002).",
      "startOffset" : 235,
      "endOffset" : 253
    }, {
      "referenceID" : 41,
      "context" : "Here we opt to formalize action theories using the multimodal logic Kn (Popkorn, 1994).",
      "startOffset" : 71,
      "endOffset" : 86
    }, {
      "referenceID" : 42,
      "context" : "For φ a Boolean formula, IP(φ) denotes the set of its prime implicants (Quine, 1952), i.",
      "startOffset" : 71,
      "endOffset" : 84
    }, {
      "referenceID" : 35,
      "context" : "For more on prime implicants, their properties and how to compute them, see the chapter by Marquis (2000). With π we denote a prime implicant, and given ` and π, ` ∈ π abbreviates ‘` is a literal of π’.",
      "startOffset" : 91,
      "endOffset" : 106
    }, {
      "referenceID" : 41,
      "context" : "The semantics here is the standard semantics of multimodal logic Kn (Popkorn, 1994).",
      "startOffset" : 68,
      "endOffset" : 83
    }, {
      "referenceID" : 46,
      "context" : "2 As usually done in the RAC community (Shanahan, 1997), we here distinguish three types of laws.",
      "startOffset" : 39,
      "endOffset" : 55
    }, {
      "referenceID" : 44,
      "context" : "In the Situation Calculus formalism (Reiter, 2001) one would write the first-order formula ∀s.",
      "startOffset" : 36,
      "endOffset" : 50
    }, {
      "referenceID" : 44,
      "context" : "However, we point out that, traditionally, in Reiter basic action theories (Reiter, 2001) executability laws and inexecutability laws are mixed together in the form of bi-conditionals like ∀s.",
      "startOffset" : 75,
      "endOffset" : 89
    }, {
      "referenceID" : 24,
      "context" : "For a critique of such a practice and its implications in formalizing dynamic domains, see the work by Herzig and Varzinczak (2007).",
      "startOffset" : 103,
      "endOffset" : 132
    }, {
      "referenceID" : 13,
      "context" : "The ramification problem (Finger, 1987) comes from the observation that an action may have several possibly interdependent effects and stating all of them explicitly is a huge task.",
      "startOffset" : 25,
      "endOffset" : 39
    }, {
      "referenceID" : 36,
      "context" : "Finally, the qualification problem (McCarthy, 1977) amounts to addressing the issue of ensuring that an action is executable in a given context.",
      "startOffset" : 35,
      "endOffset" : 51
    }, {
      "referenceID" : 5,
      "context" : "the dependence relation (Castilho et al., 1999), which is used in the work of Herzig et al.",
      "startOffset" : 24,
      "endOffset" : 47
    }, {
      "referenceID" : 46,
      "context" : "Given the largely acknowledged difficulty of the qualification problem in the literature (Shanahan, 1997), we do not assume here any a priori solution to it.",
      "startOffset" : 89,
      "endOffset" : 105
    }, {
      "referenceID" : 5,
      "context" : "Instead, as tacitly assumed in many approaches to reasoning about actions (Castilho et al., 1999; Zhang & Foo, 2001; Reiter, 2001), we suppose that the knowledge engineer may want to state some (not necessarily fully specified) executability laws for some actions.",
      "startOffset" : 74,
      "endOffset" : 130
    }, {
      "referenceID" : 44,
      "context" : "Instead, as tacitly assumed in many approaches to reasoning about actions (Castilho et al., 1999; Zhang & Foo, 2001; Reiter, 2001), we suppose that the knowledge engineer may want to state some (not necessarily fully specified) executability laws for some actions.",
      "startOffset" : 74,
      "endOffset" : 130
    }, {
      "referenceID" : 42,
      "context" : "For more on these core problems of the RAC community, the reader is referred to the book by Shanahan (1997). For the sake of clarity, here we abstract from the frame and ramification problems, and suppose that the agent’s theory already entails all the relevant frame axioms.",
      "startOffset" : 92,
      "endOffset" : 108
    }, {
      "referenceID" : 5,
      "context" : "the dependence relation (Castilho et al., 1999), which is used in the work of Herzig et al. (2006), or a kind of successor state axioms in a slightly modified setting (Demolombe, Herzig, & Varzinczak, 2003).",
      "startOffset" : 25,
      "endOffset" : 99
    }, {
      "referenceID" : 34,
      "context" : "A proof of this theorem is given by Makinson (2007) and we do not state it here.",
      "startOffset" : 36,
      "endOffset" : 52
    }, {
      "referenceID" : 42,
      "context" : "Hence, prime subvaluations are just another way of seeing prime implicants (Quine, 1952) of φ.",
      "startOffset" : 75,
      "endOffset" : 88
    }, {
      "referenceID" : 44,
      "context" : "An essential difference here is that our Kripke structures are always finite, whereas the space of situations is possibly infinite (Reiter, 2001).",
      "startOffset" : 131,
      "endOffset" : 145
    }, {
      "referenceID" : 44,
      "context" : "Notice however that this would require the addition of new whole branches to the tree-like first-order model induced by Reiter basic action theories (Reiter, 2001).",
      "startOffset" : 149,
      "endOffset" : 163
    }, {
      "referenceID" : 46,
      "context" : "Following the tradition in the RAC community, which states that executability laws are in general more difficult to formalize than effect laws, and therefore they are more likely to be incorrect (Shanahan, 1997), here we prefer not to change the accessibility relation, which means that we preserve effect laws and postpone the correction of executability laws, if required.",
      "startOffset" : 195,
      "endOffset" : 211
    }, {
      "referenceID" : 37,
      "context" : "Moreover, by propagating wrong executability laws, such a coherent method would definitely be less elaboration tolerant (McCarthy, 1998) than the one we are defining with regards to further modifications of the theory.",
      "startOffset" : 120,
      "endOffset" : 136
    }, {
      "referenceID" : 8,
      "context" : "Instead of it, however, we could have considered other distance notions as well, like Dalal’s (1988) distance, Hamming distance (1950), or weighted distance.",
      "startOffset" : 86,
      "endOffset" : 101
    }, {
      "referenceID" : 8,
      "context" : "Instead of it, however, we could have considered other distance notions as well, like Dalal’s (1988) distance, Hamming distance (1950), or weighted distance.",
      "startOffset" : 86,
      "endOffset" : 135
    }, {
      "referenceID" : 8,
      "context" : "Such a notion of distance is closely related to Dalal’s (1988) closeness.",
      "startOffset" : 48,
      "endOffset" : 63
    }, {
      "referenceID" : 39,
      "context" : "As Nebel (1989) says, “[.",
      "startOffset" : 3,
      "endOffset" : 16
    }, {
      "referenceID" : 20,
      "context" : "To make a parallel with the terminology usually adopted in the belief change community, we shall see each (E a )i as a special type of kernel (Hansson, 1994) for the formula φ→ [a]ψ.",
      "startOffset" : 142,
      "endOffset" : 157
    }, {
      "referenceID" : 20,
      "context" : "To make a parallel with the terminology usually adopted in the belief change community, we shall see each (E a )i as a special type of kernel (Hansson, 1994) for the formula φ→ [a]ψ. According to Herzig and Varzinczak (2007), given any action theory one can always ensure that at least one support set for φ→ [a]ψ exists.",
      "startOffset" : 143,
      "endOffset" : 225
    }, {
      "referenceID" : 20,
      "context" : "This resembles classical kernel contraction (Hansson, 1994): finding minimal sets implying a formula and changing them.",
      "startOffset" : 44,
      "endOffset" : 59
    }, {
      "referenceID" : 46,
      "context" : "It is worth noting that this is in line with the assumption commonly made in the RAC community according to which executability laws are by and large much more likely to be incorrect right from the beginning (Shanahan, 1997).",
      "startOffset" : 208,
      "endOffset" : 224
    }, {
      "referenceID" : 35,
      "context" : ") might result in exponential growth (Marquis, 2000).",
      "startOffset" : 37,
      "endOffset" : 52
    }, {
      "referenceID" : 7,
      "context" : "Modularity is not an exclusive property of action theories formalized in Kn: similar notions have also been investigated for different contexts in other formalisms, like regulation consistency in deontic logic (Cholvy, 1999), Situation Calculus (Herzig & Varzinczak, 2005a), DL ontologies (Herzig & Varzinczak, 2006), dynamic logic (Zhang, Chopra, & Foo, 2002) and also in the Fluent Calculus (Thielscher, 2010).",
      "startOffset" : 210,
      "endOffset" : 224
    }, {
      "referenceID" : 49,
      "context" : "Modularity is not an exclusive property of action theories formalized in Kn: similar notions have also been investigated for different contexts in other formalisms, like regulation consistency in deontic logic (Cholvy, 1999), Situation Calculus (Herzig & Varzinczak, 2005a), DL ontologies (Herzig & Varzinczak, 2006), dynamic logic (Zhang, Chopra, & Foo, 2002) and also in the Fluent Calculus (Thielscher, 2010).",
      "startOffset" : 393,
      "endOffset" : 411
    }, {
      "referenceID" : 23,
      "context" : "1), we can use the algorithms given by Herzig and Varzinczak (2005b) to check whether an action theory satisfies the principle of modularity.",
      "startOffset" : 39,
      "endOffset" : 69
    }, {
      "referenceID" : 7,
      "context" : "Modularity is not an exclusive property of action theories formalized in Kn: similar notions have also been investigated for different contexts in other formalisms, like regulation consistency in deontic logic (Cholvy, 1999), Situation Calculus (Herzig & Varzinczak, 2005a), DL ontologies (Herzig & Varzinczak, 2006), dynamic logic (Zhang, Chopra, & Foo, 2002) and also in the Fluent Calculus (Thielscher, 2010). For more details on modularity in Kn action theories, as well as its role in the presence of a solution to the frame and ramification problems, see the work by Varzinczak (2006).",
      "startOffset" : 211,
      "endOffset" : 591
    }, {
      "referenceID" : 43,
      "context" : "Implicit static laws are closely related to veridical paradoxes (Quine, 1962).",
      "startOffset" : 64,
      "endOffset" : 77
    }, {
      "referenceID" : 42,
      "context" : "Implicit static laws are closely related to veridical paradoxes (Quine, 1962). It turns out that sometimes they are intuitive, but sometimes they are not. For a deep discussion on implicit static laws, see the work by Varzinczak (2006).",
      "startOffset" : 65,
      "endOffset" : 236
    }, {
      "referenceID" : 24,
      "context" : "As shown by Herzig and Varzinczak (2007), given an action theory formalized with any framework available in the literature allowing for the expression of our three basic types of laws, it is always possible to ensure modularity.",
      "startOffset" : 12,
      "endOffset" : 41
    }, {
      "referenceID" : 29,
      "context" : "We here rephrase Katsuno and Mendelzon’s definitions (1992) in our terms so that we can see to which one our method is closer.",
      "startOffset" : 17,
      "endOffset" : 60
    }, {
      "referenceID" : 29,
      "context" : "We here rephrase Katsuno and Mendelzon’s definitions (1992) in our terms so that we can see to which one our method is closer. In Katsuno and Mendelzon’s view, contracting a law Φ from an action theory T intuitively means that the description of the possible behavior of the dynamic world T must be adjusted to the possibility of Φ being false. This amounts to selecting from the models of ¬Φ those that are closest to models of T and allow them as models of the result. In contrast, update methods select, for each model M of T, the set of models of Φ that are closest to M . Erasing Φ from T means adding models to T; for each model M , we add all those models closest to M in which Φ is false. Hence, from our constructions so far it seems that our operators are closer to update than to revision. Moreover, according to Katsuno and Mendelzon’s view (1992), our change operators would also be classified as update because we make modifications in each model independently, i.",
      "startOffset" : 17,
      "endOffset" : 860
    }, {
      "referenceID" : 22,
      "context" : "Such a postulate is not satisfied by the operators proposed by Herzig et al. (2006): there when removing e.",
      "startOffset" : 63,
      "endOffset" : 84
    }, {
      "referenceID" : 46,
      "context" : "Unfortunately, good sense points towards a negative answer: there might well be an operator satisfying all the above postulates that, by not complying with all the assumptions in the RAC community (Shanahan, 1997), is not necessarily one of the operators defined in Section 3 (cf.",
      "startOffset" : 197,
      "endOffset" : 213
    }, {
      "referenceID" : 16,
      "context" : "Such an issue has been largely addressed in the literature on propositional belief base revision and update (Gärdenfors, 1988; Winslett, 1988; Katsuno & Mendelzon, 1992; Herzig & Rifi, 1999).",
      "startOffset" : 108,
      "endOffset" : 190
    }, {
      "referenceID" : 46,
      "context" : "Given their special status (Shanahan, 1997), these should change only if explicitly required.",
      "startOffset" : 27,
      "endOffset" : 43
    }, {
      "referenceID" : 32,
      "context" : "To the best of our knowledge, the first work on updating an action domain description is that by Li and Pereira (1996) in a narrative-based action description language (Gelfond & Lifschitz, 1993).",
      "startOffset" : 97,
      "endOffset" : 119
    }, {
      "referenceID" : 29,
      "context" : "Liberatore (2000) proposes a framework for reasoning about actions in which it is possible to express a given semantics of belief update, like Winslett’s (1988) and Katsuno and Mendelzon’s (1992). This means it is the formalism, essentially an action description lan-",
      "startOffset" : 165,
      "endOffset" : 196
    }, {
      "referenceID" : 32,
      "context" : "The main difference between Liberatore’s work (2000) and Li and Pereira’s (1996) is that, despite not being concerned, at least a priori, with changing action laws, Liberatore’s framework allows for abductively introducing in the action theory new effect propositions (effect laws, in our terms) that consistently explain the occurrence of an event.",
      "startOffset" : 28,
      "endOffset" : 53
    }, {
      "referenceID" : 32,
      "context" : "The main difference between Liberatore’s work (2000) and Li and Pereira’s (1996) is that, despite not being concerned, at least a priori, with changing action laws, Liberatore’s framework allows for abductively introducing in the action theory new effect propositions (effect laws, in our terms) that consistently explain the occurrence of an event.",
      "startOffset" : 57,
      "endOffset" : 81
    }, {
      "referenceID" : 12,
      "context" : "The work by Eiter et al. (2005) is similar to ours in that they also propose a framework which is oriented to updating action laws.",
      "startOffset" : 12,
      "endOffset" : 32
    }, {
      "referenceID" : 12,
      "context" : "The work by Eiter et al. (2005) is similar to ours in that they also propose a framework which is oriented to updating action laws. They mainly investigate the case where e.g. a new effect law is added to the description (and then has to be true in all models of the modified theory). This problem is the dual of contraction and is then closer to our definition of revision (cf. Section 8). In Eiter et al.’s framework (2005), action theories are described in a variant of a narrativebased action description language.",
      "startOffset" : 12,
      "endOffset" : 426
    }, {
      "referenceID" : 12,
      "context" : "The work by Eiter et al. (2005) is similar to ours in that they also propose a framework which is oriented to updating action laws. They mainly investigate the case where e.g. a new effect law is added to the description (and then has to be true in all models of the modified theory). This problem is the dual of contraction and is then closer to our definition of revision (cf. Section 8). In Eiter et al.’s framework (2005), action theories are described in a variant of a narrativebased action description language. Like in the present work, the semantics is also in terms of transition systems, with transitions (action occurrences) linking states (configurations of the world). Contrary to us, however, the minimality condition on the outcome of the update is in terms of inclusion of sets of laws, which means that the approach is more syntax oriented to some extent. In their setting, during an update an action theory T is seen as composed of two pieces, Tu and Tm, where Tu stands for the part of T that is not supposed to change and Tm contains the laws which may be modified. In our terms, when contracting a static law we would have Tm = S ∪ Xa; when contracting an executability law Tm = Xa; and when contracting effects laws Tm = E− a . The difference here is that in our approach it is always clear what laws should not change in a given type of contraction, and therefore Tu and Tm do not need to be explicitly specified prior to the update. Their approach and ours can both be described as constraint-based update, in that the theory change is carried out relative to some constraints (a set of laws that we want to hold in the result). In our framework, for example, all changes in the action laws are relative to the set of static laws S (and that is why we concentrate on models of T having val(S ) as worlds). When changing a law, we want to keep the same set of states. The difference with respect to Eiter et al.’s (2005) approach is that there it is also possible to update a theory relatively to e.",
      "startOffset" : 12,
      "endOffset" : 1945
    }, {
      "referenceID" : 22,
      "context" : "Second, Herzig et al.’s (2006) contraction method does not satisfy most of the postulates for action theory change that we have addressed in Section 7.",
      "startOffset" : 8,
      "endOffset" : 31
    }, {
      "referenceID" : 22,
      "context" : "Figure 19: Counter-example to preservation in the method by Herzig et al. (2006).",
      "startOffset" : 60,
      "endOffset" : 81
    }, {
      "referenceID" : 56,
      "context" : "Finally, another work that is related to ours is that by Zhang and Ding (2008). Like ours, their approach is also about giving a semantic characterization of the basic operations for changing Kripke models.",
      "startOffset" : 57,
      "endOffset" : 79
    }, {
      "referenceID" : 0,
      "context" : "One of our ongoing research topics is on assessing our revision operators’ behavior with respect to appropriate versions of the AGM postulates for revision (Alchourrón et al., 1985) and its links with the contraction counterpart.",
      "startOffset" : 156,
      "endOffset" : 181
    }, {
      "referenceID" : 49,
      "context" : "We have also extended Varzinczak’s investigations (2008) by defining a semantics for action theory revision based on minimal modifications of models.",
      "startOffset" : 22,
      "endOffset" : 57
    }, {
      "referenceID" : 49,
      "context" : "We have also extended Varzinczak’s investigations (2008) by defining a semantics for action theory revision based on minimal modifications of models. For the corresponding revision algorithms, the reader is referred to the work by Varzinczak (2009). One of our ongoing research topics is on assessing our revision operators’ behavior with respect to appropriate versions of the AGM postulates for revision (Alchourrón et al.",
      "startOffset" : 22,
      "endOffset" : 249
    }, {
      "referenceID" : 37,
      "context" : "By forcing formulas to be explicitly stated in their respective modules (and thus possibly making them inferable in independently different ways), modularity intuitively could be seen to diminish elaboration tolerance (McCarthy, 1998).",
      "startOffset" : 218,
      "endOffset" : 234
    }, {
      "referenceID" : 21,
      "context" : "Contrary to the trend in the belief change community, where the focus is either on belief bases or belief sets (Hansson, 1999), the method here proposed is a hybrid one (Delgrande, 2009).",
      "startOffset" : 111,
      "endOffset" : 126
    }, {
      "referenceID" : 10,
      "context" : "Contrary to the trend in the belief change community, where the focus is either on belief bases or belief sets (Hansson, 1999), the method here proposed is a hybrid one (Delgrande, 2009).",
      "startOffset" : 169,
      "endOffset" : 186
    }, {
      "referenceID" : 8,
      "context" : "This is the principle of syntax independence (Dalal, 1988).",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 8,
      "context" : "This is the principle of syntax independence (Dalal, 1988). Related to that is the question on how our revision definitions relate to our contraction operators. What is known is that the Levi identity (1977), TΦ = T − ¬Φ ∪ {Φ}, in general does not hold for action laws (effect and executability ones).",
      "startOffset" : 46,
      "endOffset" : 208
    }, {
      "referenceID" : 29,
      "context" : "Katsuno and Mendelzon’s (1992), we have |= CPL S → S−, and then, because |=S , we have |=S−.",
      "startOffset" : 0,
      "endOffset" : 31
    } ],
    "year" : 2010,
    "abstractText" : "As historically acknowledged in the Reasoning about Actions and Change community, intuitiveness of a logical domain description cannot be fully automated. Moreover, like any other logical theory, action theories may also evolve, and thus knowledge engineers need revision methods to help in accommodating new incoming information about the behavior of actions in an adequate manner. The present work is about changing action domain descriptions in multimodal logic. Its contribution is threefold: first we revisit the semantics of action theory contraction proposed in previous work, giving more robust operators that express minimal change based on a notion of distance between Kripke-models. Second we give algorithms for syntactical action theory contraction and establish their correctness with respect to our semantics for those action theories that satisfy a principle of modularity investigated in previous work. Since modularity can be ensured for every action theory and, as we show here, needs to be computed at most once during the evolution of a domain description, it does not represent a limitation at all to the method here studied. Finally we state AGM-like postulates for action theory contraction and assess the behavior of our operators with respect to them. Moreover, we also address the revision counterpart of action theory change, showing that it benefits from our semantics for contraction.",
    "creator" : "TeX"
  }
}