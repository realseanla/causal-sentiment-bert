{
  "name" : "1605.05807.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Heuristics for Planning, Plan Recognition and Parsing (Written: June 2009, Published: May 2016)",
    "authors" : [ "Miquel Ramı́rez", "Hector Geffner" ],
    "emails" : [ "miquel.ramirez@protonmail.ch", "hector.geffner@upf.edu" ],
    "sections" : [ {
      "heading" : "Introduction",
      "text" : "Plan Recognition is a common task in a number of areas where the goal and plan of an agent must be inferred from observations of its behavior (Schmidt, Sridharan, and Goodson 1978; Cohen, Perrault, and Allen 1981; Pentney et al. 2006). Plan Recognition is a form of Planning in reverse: while in Planning, we seek the actions that achieve a goal, in Plan Recognition, we seek the goals that explain the observed actions. Work in Plan Recognition, however, has proceeded independently of the work in Planning, using mostly handcrafted libraries or algorithms not related to Planning (Kautz and Allen 1986; Vilain 1990; Charniak and Goldman 1993; Lesh and Etzioni 1995; Goldman, Geib, and Miller 1999; Avrahami-Zilberbrand and Kaminka 2005).\nRecently, we have shown that Plan Recognition can be formulated and solved using Classical Planning algorithms (Ramirez and Geffner 2009). This is important since Classical Planning algorithms have become quite powerful in recent years. This formulation does not work over libraries but over STRIPS theories where a set G of possible goals is given. The Plan Recognition task is defined as the problem of identifying the goals G ∈ G that have some optimal plan compatible with the observationsO. Such goals are grouped into the optimal goal set G∗, G∗ ⊆ G. The reason for focusing on the optimal plans is that they represent the possible\nbehaviors of a perfectly rational agent pursuing the goal G (Baker, Tenenbaum, and Saxe 2007). By suitable transformation, it is then shown in (Ramirez and Geffner 2009) that this optimal set G∗ can be computed exactly by means of optimal Planning algorithms and approximately by efficient suboptimal Planning algorithms and polynomial heuristics.\nIn this work, we show that this formulation subsumes the standard formulation of Plan Recognition over libraries through a compilation of libraries into STRIPS. The libraries correspond AND/OR graphs that may be cyclic and where children of AND nodes may be partially ordered. This libraries include Context-Free Grammars as a special case, where the Plan Recognition problem becomes a parsing problem. Plan Recognition over the standard Plan Libraries become simple Planning problems that can be easily solved by any modern planner, while recognition over more complex libraries, including CFGs, illustrate limitations of current Planning heuristics and improvements that may be relevant in other Planning problems as well.1\nThe paper is organized as follows. First we review the formulation of Plan Recognition over STRIPS theories in (Ramirez and Geffner 2009), then we consider Plan Recognition over libraries, present some experimental results, and draw some conclusions."
    }, {
      "heading" : "Plan Recognition as Planning",
      "text" : "A STRIPS Planning problem is a tuple P = 〈F, I,A,G〉 where F is the set of fluents, I ⊆ F and G ⊆ F are the initial and goal situations, and A is a set of actions a with precondition, add, and delete lists Pre(a),Add(a), andDel(a) respectively, all of which are subsets of F . For each action a ∈ A, we assume that there is a non-negative cost c(a) so that the cost of a sequential plan π = a1, . . . , an is c(π) = ∑ c(ai). A plan π is optimal if it has minimum cost. For unit costs, i.e., c(a) = 1 for all a ∈ A, plan cost is plan 1 Parsing in CFGs is polynomial while Planning is known to be NP–hard. This worst complexity bounds, however, do not imply that the reduction of parsing to Planning is necessarily a bad idea. First, many Planning problems – like manySAT problems – can be solved quite efficiently; second, parsing with constraints, as required in Natural Language Processing, is also intractable, yet many of these constraints can be handled naturally in Planning. In addition, the mapping handles missing tokens in the input sentence and yields interesting lessons for Planning heuristics. ar X iv :1\n60 5.\n05 80\n7v 2\n[ cs\n.A I]\n2 2\nM ay\n2 01\n6\nlength, and the optimal plans are the shortest ones. Unless stated otherwise, action costs are assumed to be 1."
    }, {
      "heading" : "Definition",
      "text" : "The Plan Recognition problem given a plan library L for a set G of possible goals G can be understood, at an abstract level, as the problem of finding a goal G with a plan π in the library, written π ∈ ΠL(G), such that π satisfies the observations. We define the Plan Recognition problem over a domain theory in a similar way just changing the set ΠL(G) of plans for G in the library by the set Π∗P (G) of optimal plans for G given the domain P . We use P = 〈F, I,O〉 to represent Planning domains so that a Planning problem P (G) is obtained by concatenating a Planning domain with a goal G, which is a set of fluents. We define a Plan Recognition problem or theory as follows:\nDefinition 1 A Plan Recognition problem or theory is a triplet T = 〈P,G, O〉 where P = 〈F, I,A〉 is a Planning domain, G is the set of possible goals G, G ⊆ F , and O = o1, . . . , om is an observation sequence with each oi being an action in A.\nWe also need to make precise what it means for an action sequence to satisfy an observation sequence made up of actions. E.g., the action sequence π = {a, b, c, d, e, a} satisfies the observation sequences O1 = {b, d, a} and O2 = {a, c, a}, but not O3 = {b, d, c}. This can be formalized with the help of a function that maps observation indices in O into action indices in A:\nDefinition 2 An action sequence π = a1, . . . , an satisfies the observation sequence O = o1, . . . , om if there is a monotonic function f mapping the observation indices j = 1, . . . ,m into action indices i = 1, . . . , n, such that af(j) = oj .\nThe solution to a Plan Recognition theory T = 〈P,G, O〉 is given by the goals G that admit an optimal plan that is compatible with the observations:\nDefinition 3 The exact solution to a theory T = 〈P,G, O〉 is given by the optimal goal set G∗T which comprises the goals G ∈ G such that for some π ∈ Π∗P (G), π satisfies O.\nFigure 1 shows a simple Plan Recognition problem. Room A (marked with a circle) is the initial position of the agent, while Rooms C, I and K (marked with a square) are its possible destinations. Arrows between Rooms A and B,\nand F and G, are the observed agent movements in that order. In the resulting theory T , the only possible goals that have optimal plans compatible with the observation sequence are I and K. In the terminology above, the set of possible goals G is given by the atoms at(C), at(I), and at(K), while the optimal goal set G∗T comprises at(I) and at(K), leaving out the possible goal at(C)."
    }, {
      "heading" : "Computation",
      "text" : "In order to solve the Plan Recognition problem using Planning algorithms, we get rid of the observations. For simplicity, we assume that no pair of observations oi and oj refer to the same action a in P . When this is not so, we create a copy a′ of the action a in P so that oi refers to a′ and oj refers to a.\nWe will eliminate observations by mapping the theory T = 〈P,G, O〉 into an slightly different theory T ′ = 〈P ′,G′, O′〉 with an empty set O′ of observations, such that the solution set G∗T for T can be read off from the solution set G∗T ′ for T ′. Definition 4 For a theory T = 〈P,G, O〉, the transformed theory is T ′ = 〈P ′,G′, O′〉 with • P ′ = 〈F ′, I ′, A′〉 has fluents F ′ = F ∪ Fo, initial sit-\nuation I ′ = I , and actions A′ = A ∪ Ao, where P = 〈F, I,A〉, F0 = {pa | a ∈ O}, and Ao = {oa | a ∈ O}, • G′ contains the goal G′ = G ∪ Go for each goal G in G, where Go = Fo, • O′ is empty\nThe new actions oa in P ′ have the same precondition, add, and delete lists as the actions a in P except for the new fluent pa that is added to Add(oa), and the fluent pb, for the action b that immediately precedes a in O, if any, that is added to Pre(oa).\nIn the transformed theory T ′, the observations a ∈ O are encoded as extra fluents pa ∈ Fo, extra actions oa ∈ Ao, and extra goals pa ∈ Go. Moreover, these extra goals pa can only be achieved by the new actions oa, that due to the precondition pb for the action b that precedes a in O, can be applied only after all the actions preceding a inO, have been executed. The result is that the plans that achieve the goal G′ = G∪Go in P ′ are in correspondence with the plans that achieve the goal G in P that satisfy the observations O:\nProposition 5 π = a1, . . . , an is a plan for G in P that satisfies the observations O = o1, . . . , om under the function f iff π′ = b1, . . . , bn is a plan for G′ in P ′ with bi = oai , if i = f(j) for some j ∈ [1,m], and bi = ai otherwise.\nIt follows from this that π is an optimal plan for G in P that satisfies the observations iff π′ is an optimal plan in P ′ for two different goals: G, on the one hand, andG′ = G∪Go on the other. If we let Π∗P (G) stand for the set of optimal plans for G in P , we can thus test whether a goal G in G accounts for the observation as follows:2\n2 Note that while a plan for G′ = G ∪ Go is always a plan for G, it is not true that an optimal plan for G′ is an optimal plan for G, or even that a good plan for G′ is a good plan for G.\nTheorem 6 G ∈ G∗T iff there is an action sequence π in Π∗P ′(G) ∩Π∗P ′(G′). Moreover, since G ⊆ G′, if we let c∗P ′(G) stand for the optimal cost of achieving G in P ′, we can state this result in a simpler form: Theorem 7 G ∈ G∗T iff c∗P ′(G) = c∗P ′(G′)\nThe optimal goal set G∗ can be computed, using this result, by solving two optimal Planning problems for each possible goal G: one extending the domain P ′ with the goal G, the other extending P ′ with the goal G′ made up of G and the dummy goals Go encoding the observations. The goal G explains the observations and thus belongs to G∗T iff the solutions to these two optimal Planning problems have the same cost. In (Ramirez and Geffner 2009), a more efficient method for computing this set exactly is introduced, where the cost of the first problem is used as the upper bound in the solution of the second. In addition, two methods that approximate G∗T and scale up much better are presented. For Plan Recognition over libraries, the situation is simpler, as the resulting Planning problems have zero action costs, and hence all plans are optimal."
    }, {
      "heading" : "Plan Recognition over Libraries",
      "text" : "As mentioned above, the Plan Recognition problem given a plan library L for a set G of possible goals G can be understood, at an abstract level, as the problem of finding a goalG with a plan π ∈ L, written π ∈ ΠL(G), such that π satisfies the observations O. We show now that a library L for a goal G can be compiled intro a STRIPS Planning problem PL(G) so that π is in ΠL(G) iff π is a plan for PL(G). Provided with this correspondence and by setting the cost of all the actions in PL to zero, so that no plan in the library is ruled out due to their cost, a plan in the library for G will satisfy the observations O iff G is in the optimal goal set G∗T of the theory T = 〈PL,G, O〉, a set that can be computed by using an off-the-shelf classical planner upon the Planning problems P ′L(G\n′) obtained from the transformation that compiles the observation O in T away."
    }, {
      "heading" : "Plan Libraries",
      "text" : "As it is standard, we take a library L for a goal G to be a rooted, ordered AND/OR graph where each node is a AND node, an OR node, or a leaf. Leaves represent primitive task (actions), OR nodes represent non-primitive tasks, and AND nodes represent methods for decomposing nonprimitive task. The children of OR nodes are AND nodes or leaves, while the children of AND nodes are OR nodes or leaves. The children of an AND node n can be ordered partially; we write n′ <n n′′ to express that child n′ of n must come before child n′′. The root of the library is a task (OR node) that represents the goal G to be achieved. We will allow libraries to be cyclic, and thus, CFGs will be an special case where the OR nodes stand for the non-terminal symbols in the grammar, the AND nodes stands for the grammar rules, and the leaves stand for the grammar terminals. The children of the AND/OR graphs that represent CFGs are normally cyclic and the children of AND nodes (rules) are ordered linearly.\nThe set of solutions to one such AND/OR graph can be defined by means of derivations as it is common in parsing, with the only difference that a partially ordered rule X → Y1, . . . , Ym represented by an AND node, stands for the set of all totally ordered rules X → Yi1 , . . . , Yim compatible with the partial order. The set of plans ΠL(G) in the library forG denotes the set of ’strings’ (sequences of terminal tasks or actions) that can be derived from the root node corresponding to G."
    }, {
      "heading" : "Compilation",
      "text" : "The compilation of the library L for a goal G into a STRIPS Planning problem PL(G) depends on a depth parameter N , and it ensures that the plans in PNL (G) are in correspondence with the set of plans (strings of primitive tasks) ΠL(G) that can be derived from the library by bounding the depth of the derivation to N . If the library is acyclic, it suffices to set N to the depth of the graph to ensure completeness; otherwise, the parameter N puts a bound on the number of derivations. For simplicity, we often drop the index N from the notation.\nThe Planning problem PL(G) = 〈FL, IL, GL, AL〉 have a set of fluents FL, initial and goal situations IL and GL, and actions AL. For simplicity, we will describe the problem assuming a STRIPS language with negation. Negation, however, can be easily compiled away (Gazen and Knoblock 1997).\nThe fluents FL in PL are started(n, i), ¬started(n, i), finished(n, i), ¬finished(n, i), and top(i), where n corresponds to the nodes in the AND/OR graph representing the library L, and i = [0 . . . N ]. The integers i aim to capture the possible levels of the stack, with the true level captured by the fluent top(i) that is mutex with top(k) for k 6= i. In a state, where top(i) is true, the fluents started(n, k) and finished(n, k) for k ≤ i express the contents of the stack. In any such a state, all fluents started(n, k) and finished(n, k) for k > i will be false.\nThe initial and goal situations of PL are IL = {top(0)} and GL = {finished(n, 0)}, where n is the single (OR) root node of the library L. That is, the stack starts at level 0 empty with no node started, and the goal is to finish with the root node executed at the same level. For doing this, the stack will expand and contract, while the execution of a node will allow the execution of its children. Roughly the started(n, i) fluents flow downward in the graph, and the fluents finished(n, i) flow upward, with the actions start(n, i) and end(n, i) emulating the start and ending of the primitive and non-primitive tasks in the AND/OR graph. As a convenient abbreviation, we write i+1 and i−1 to denote constants i′ defined as the successor and predecessor of the constant i in the encoding. The actions in PNL (G)are: • Calls from AND nodes n to non–terminal children n′ are repre-\nsented by actions start(n, n′, i) with preconditions\nPre = {top(i), started(n, i),¬finished(n′)} ∪ {finished(n′′, i) |n′′ <n n′} ∪ {¬started(n′′, i) |n′′ ∈ children(n)}\nadd list Add = {top(i+1), started(n′, i+1} and delete list Del = {top(i)}. For calls to terminal children n′, the precon-\ndition of start(n, n′, i) is the same as the one described above but Add = {finished(n′, i)} and Del = ∅.\n• Termination of calls made from AND nodes n are encoded with actions end(n, i), with preconditions\nPre = {top(i), started(n, i)} ∪ {finished(n′) |n′ ∈ children(n)}\nand add list Add = {finished(n, i−1), top(i−1)} and delete list Del = Pre. • Calls from internal OR nodes n to children n′ are represented by actions start(n, n′, i) with precondition\nPre = {top(i), started(n, i)} ∪ {¬finished(n′′, i+1) |n′′ ∈ children(n)} ∪ {¬started(n′′, i+1) |n′′ ∈ children(n)}\nadd list Add = {top(i+1), started(n′, i+1)} and delete list Del = {top(i)}.\n• Termination of calls from internal OR nodes are represented by actions end(n, n′, i), where n′ is a child of n, with precondition Pre = {top(i), started(n, i), finished(n′, i)}, add list Add = {finished(n, i− 1), top(i− 1)} and delete list Del = Pre.\n• Root OR nodes are handled like other OR nodes, except that the action end(n, i = 0) adds finished(n, 0) rather than adding finished(n, i−1). For a plan π for PL(G), let us keep only the sequence of start(n, n′, k) actions where n is a leaf node of L, and let us set fL(π) to the corresponding sequence with the start(n, n′, k) actions replaced by the primitive actions associated with the nodes n.\nThe first result is about the correspondence between the set of plans in the library L for G with depth bounded by N , ΠNL (G), and the sequences of primitive actions f(π) for plans π for PNL (G): Theorem 8 (Correspondence) For a library L for goal G and a positive integer N , π ∈ ΠNL (G) iff there is a plan π′ for PL(G) such that π = fL(π).\nThe second result exploits this correspondence for computing the plans in the library that comply with a set of observations O using an off-the-shelf classical planner, suboptimal or not, over the problem P ′L(G\n′) obtained from PL(G) by compiling the observations O away (Definition 4): Theorem 9 (Computation) For a library L for a goal G, and a positive integerN ,G has a plan in ΠNL (G) compatible with the observations O iff there is a plan for the Planning problem P ′NL (G\n′) obtained from PL(G) by compiling the observations O away.\nThe third result is semantic, and shows that this computational method follows from the general formulation for Plan Recognition from STRIPS theories when action costs are taken to be zero: Theorem 10 (Subsumption) Let G be a set of possible goals, and let L be the library for G ∈ G. Then G has a plan in the library that satisfies the observations O with depth no greater than N iff there is an optimal plan for the problem PNL (G) that satisfies O, assuming action costs to be zero.\nIndeed, this result follows from the one above, as when all action costs are zero, any plan for P ′NL (G\n′) is an optimal plan for P ′NL (G), which in turn from Proposition 5, represents a plan for the problem PL(G) that satisfies the observations."
    }, {
      "heading" : "Experimental Results",
      "text" : "We test below the Plan Recognition framework laid out above over plan libraries and Context-Free Grammars."
    }, {
      "heading" : "The Soccer Plan Library",
      "text" : "From the descriptions found (Tambe et al. 1999) on plan hierarchies for controlling simulated RoboSoccer teams, we have defined ourselves a set plan libraries for recognizing the intentions of the opposing soccer team. Each library considers one of the following four root tasks, namely, Frontal– Attack, Flank–Attack, Fight–Back and Fall–Back 3. Plans in the first two libraries share a substantial amount of activities, e.g. kicking the ball, or running towards the general direction of the opposing team, which do not or hardly take place in plans conveyed by the latter two libraries. In Figure 2 we show the plan library for the task Frontal–Attack.\nIn the experiments, we test which plan libraries are compatible with a sequence of observations drawn from a plan obtained from one of them. The planner we used to search for such plans is the satisfying classical planner FFV2.3.\nIn Table 1 we can see that the Planning problems we obtain from our compilation are handled easily by FF. It is important to note that the size of the observation sequence |O| does not seem to be related with the running time. While the plan library depicted in Figure 2 might be very simple, it is not simpler than the plan libraries typically found in the Plan Recognition literature."
    }, {
      "heading" : "Context-Free Grammars",
      "text" : "Context-free grammars (CFGs) appear to present more interesting Planning challenges than the common plan libraries. First, most, if not all, CFGs of interest in Natu-\n3Names of tasks loosely correspond with those of top–level goals featured by the plan hierarchy found in the ISIS source distribution.\nral Language Processing (NLP) are cyclic, though in languages like English, the depth of the derivation is not big. On the other hand, CFGs used as benchmarks for parsers, like ATIS–3 or COMMANDTALK 4, feature thousands of rules. Compiling such grammars into Plan Libraries results in graphs with several thousand nodes. Until recently (Geib and Goldman 2009), there has not been any serious attempt at developing a set of challenging benchmarks for Plan Recognition algorithms.\nWe have tested our compilation in a toy CFG of the English language, described below: 1. S → NP V P 2. V P → V NP |V |V P PP 3. NP → Det N |Name|NP PP 4. PP → P NP 5. V → saw|ate|ran 6. N → boy|cookie|table|telescope|hill 7. Name→ Jack|Bob 8. P → with|under 9. Det→ the|a|my\nCompiling this simple CFG yields a Plan Library with 85 nodes, which in turn yields a Planning problem with about 800 actions after having fixed the maximum derivation depth to 10.\nTable 2 confirms our intuition that even very simple CFGs yield significantly more challenging Planning problems than Plan Libraries do. In general more search is required to find\n4These grammars can be found in the NLTK (http://www. nltk.org) Natural Language Processing toolkit corpora.\nSentence Type Time (secs) Expanded Plan Len Algorithm Covered 266.5, TO(1) 1,698 54.2 BFS\nIncomplete 271 393 34 BFS Not Covered TO 4,000 – –\nTable 3: Average time, number of nodes expanded – for timeouts an educated guess is provided – and plan lengths obtained with the second grammar. TO stands for timeout (time limit was set to 600 seconds). Twelve sentences were divided into three sets. The Covered set contained full sentences covered by the grammar. The Incomplete set contained covered sentences with missing tokens. The final set, Not Covered, refers to non–English sequences of tokens.\na parse tree for the input token sequence. One very interesting property inherent to our approach is its ability to “interpolate” missing tokens from the input sentence, as is the case of sentence #3. In that sentence there is no verb, and the planner introduces one of the available productions for non–terminal V in order to obtain a correct parse tree. In sentence #2 the subject is missing, and in this case the planner introduces a noun–phrase.\nEncouraged by these results, we wanted to conduct an experiment with a “real grammar”. We aimed at obtaining a parse for sentences using the ATIS–3 benchmark CFG. Yet this grammar contains over 3,000 different production rules, which resulted in an AND/OR graph with over 6,000 nodes. The Planning problem resulting from compiling that graph featured over 300,000 actions and a disk footprint of about 2 Gigabytes.\nWe have thus tested our Plan Recognition framework over a CFG not as complex as ATIS–3 but a bit more complex than the toy CFG above. This second grammar features a much richer lexicon: 7 verbs with tenses and number, over twenty nouns, pronouns, auxiliary verbs and all of English prepositions. It also features rules for modeling pragmatics – statements, questions and commands – and taking as well into account applicable syntactic cases – declarative, imperative and interrogation – for each pragmatic. This second grammar, when compiled, resulted in an AND/OR graph with 251 nodes, which, after fixing the derivation depth N to 30 to ensure solubility, resulted in a Planning problem with over 10,000 actions.\nThe results of applying our scheme to this second grammar are shown in Table 3, where three types of sentences are considered. Interestingly FF, solved pretty well the sentences in the Covered set, but had trouble processing the non–English token sequences in the Not Covered set. The timeout we get in the Covered set corresponds to the sentence “why did you take the book”, while the sentence “take the book” was solved after having to expand just 441 nodes. This observation and the fact that incomplete sentences are much smaller than the average sentence in the Complete set, leads us to conclude that in the context of parsing as Planning, the length of the sentence to parse seems to be relevant for the hardness of the problem. We can also see that the “interpolating” behavior of our scheme is biased towards providing a reasonably sized parse tree. It is also worthy to note that none of the problems was solved with the incomplete EHC procedure.\nThe result confirms that the search for plans in the resulting theories becomes much more expensive due to the limitations of current heuristics that make planners like FF get lost in much larger search spaces. Moreover, we have found that it is possible to incorporate some ideas from parsing algorithms like CYK (Younger 1967) into relaxed–plan graph heuristics, while keeping the heuristic itself computable in polynomial time. We think that such heuristics will help the search to become more focused. Interestingly, the new heuristic is general and thus applies to Planning problems that are completely unrelated to parsing. Unfortunately, we haven’t had the time to test these ideas yet, but would like to do that for the camera–ready version if the paper is accepted for the workshop."
    }, {
      "heading" : "Discussion",
      "text" : "We have shown that the framework for plan recognition over STRIPS theories, formulated recently in (Ramirez and Geffner 2009), subsumes the Plan Recognition problem over libraries, as they can be compiled into STRIPS. We have also shown that recognition over standard libraries become Planning problems that can be easily solved by modern planners, while recognition over more complex libraries, including CFGs, illustrate limitations of current Planning heuristics and suggest improvements that may be relevant in other Planning problems as well (to be worked out and shown)."
    } ],
    "references" : [ {
      "title" : "Fast and complete symbolic plan recognition",
      "author" : [ "Avrahami-Zilberbrand", "G.A. Kaminka" ],
      "venue" : "In Proceedings of IJCAI,",
      "citeRegEx" : "Avrahami.Zilberbrand et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Avrahami.Zilberbrand et al\\.",
      "year" : 2005
    }, {
      "title" : "Goal inference as inverse planning",
      "author" : [ "Tenenbaum Baker", "C.L. Saxe 2007] Baker", "J.B. Tenenbaum", "R.R. Saxe" ],
      "venue" : "In Proceedings of the Twenty-Ninth Annual Conference of the Cognitive Science Society",
      "citeRegEx" : "Baker et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Baker et al\\.",
      "year" : 2007
    }, {
      "title" : "A bayesian model of plan recognition",
      "author" : [ "Charniak", "E. Goldman 1993] Charniak", "R.P. Goldman" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Charniak et al\\.,? \\Q1993\\E",
      "shortCiteRegEx" : "Charniak et al\\.",
      "year" : 1993
    }, {
      "title" : "Beyond question answering",
      "author" : [ "Perrault Cohen", "P.R. Allen 1981] Cohen", "C.R. Perrault", "J.F. Allen" ],
      "venue" : null,
      "citeRegEx" : "Cohen et al\\.,? \\Q1981\\E",
      "shortCiteRegEx" : "Cohen et al\\.",
      "year" : 1981
    }, {
      "title" : "Combining the expressiveness of UCPOP with the efficiency of Graphplan",
      "author" : [ "Gazen", "B. Knoblock 1997] Gazen", "C. Knoblock" ],
      "venue" : "Recent Advances in AI Planning. Proc. 4th European Conf. on Planning (ECP-97). Lect. Notes in AI",
      "citeRegEx" : "Gazen et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Gazen et al\\.",
      "year" : 1997
    }, {
      "title" : "A probabilistic plan recognition algorithm based on plan tree grammars",
      "author" : [ "Geib", "C.W. Goldman 2009] Geib", "R.P. Goldman" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Geib et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Geib et al\\.",
      "year" : 2009
    }, {
      "title" : "A new model of plan recognition",
      "author" : [ "Geib Goldman", "R.P. Miller 1999] Goldman", "C.W. Geib", "C.A. Miller" ],
      "venue" : "In Proceedings of the 1999 Conference on Uncertainty in Artificial Intelligence",
      "citeRegEx" : "Goldman et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Goldman et al\\.",
      "year" : 1999
    }, {
      "title" : "Generalized plan recognition",
      "author" : [ "Kautz", "H. Allen 1986] Kautz", "J.F. Allen" ],
      "venue" : "In AAAI,",
      "citeRegEx" : "Kautz et al\\.,? \\Q1986\\E",
      "shortCiteRegEx" : "Kautz et al\\.",
      "year" : 1986
    }, {
      "title" : "A sound and fast goal recognizer",
      "author" : [ "Lesh", "N. Etzioni 1995] Lesh", "O. Etzioni" ],
      "venue" : "In Proc. IJCAI-95,",
      "citeRegEx" : "Lesh et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Lesh et al\\.",
      "year" : 1995
    }, {
      "title" : "Sensor-based understanding of daily life via large-scale use of common sense",
      "author" : [ "Pentney" ],
      "venue" : "Proceedings of AAAI",
      "citeRegEx" : "Pentney,? \\Q2006\\E",
      "shortCiteRegEx" : "Pentney",
      "year" : 2006
    }, {
      "title" : "Plan recognition as planning",
      "author" : [ "Ramirez", "M. Geffner 2009] Ramirez", "H. Geffner" ],
      "venue" : "In Proceedings of the Twenty-First International Joint Conference on Artificial Intelligence (IJCAI-09)",
      "citeRegEx" : "Ramirez et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Ramirez et al\\.",
      "year" : 2009
    }, {
      "title" : "The plan recognition problem: an intersection of psychology and artificial intelligence",
      "author" : [ "Sridharan Schmidt", "C. Goodson 1978] Schmidt", "N. Sridharan", "J. Goodson" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "Schmidt et al\\.,? \\Q1978\\E",
      "shortCiteRegEx" : "Schmidt et al\\.",
      "year" : 1978
    }, {
      "title" : "Building Agent Teams Using an Explicit Teamwork Model and Learning",
      "author" : [ "Tambe" ],
      "venue" : "Artifical Intelligence",
      "citeRegEx" : "Tambe,? \\Q1999\\E",
      "shortCiteRegEx" : "Tambe",
      "year" : 1999
    }, {
      "title" : "Recognition and parsing of context–free languages in time n. Information and Control 10:189–208",
      "author" : [ "D.H. Younger" ],
      "venue" : null,
      "citeRegEx" : "Younger,? \\Q1967\\E",
      "shortCiteRegEx" : "Younger",
      "year" : 1967
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : "Moreover, we have found that it is possible to incorporate some ideas from parsing algorithms like CYK (Younger 1967) into relaxed–plan graph heuristics, while keeping the heuristic itself computable in polynomial time.",
      "startOffset" : 103,
      "endOffset" : 117
    } ],
    "year" : 2016,
    "abstractText" : "In a recent paper, we have shown that Plan Recognition over STRIPS can be formulated and solved using Classical Planning heuristics and algorithms (Ramirez and Geffner 2009). In this work, we show that this formulation subsumes the standard formulation of Plan Recognition over libraries through a compilation of libraries into STRIPS theories. The libraries correspond to AND/OR graphs that may be cyclic and where children of AND nodes may be partially ordered. These libraries include Context-Free Grammars as a special case, where the Plan Recognition problem becomes a parsing with missing tokens problem. Plan Recognition over the standard libraries become Planning problems that can be easily solved by any modern planner, while recognition over more complex libraries, including Context–Free Grammars (CFGs), illustrate limitations of current Planning heuristics and suggest improvements that may be relevant in other Planning problems too.",
    "creator" : "LaTeX with hyperref package"
  }
}