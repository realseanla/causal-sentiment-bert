{
  "name" : "1312.6151.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Abstract Modular Systems and Solvers",
    "authors" : [ "Yuliya Lierler", "Miroslaw Truszczynski", "M. Truszczynski" ],
    "emails" : [ "ylierler@unomaha.edu", "mirek@cs.uky.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Abstract Modular Systems and Solvers\nYuliya Lierler1 and Miroslaw Truszczynski2\n1 University of Nebraska at Omaha ylierler@unomaha.edu\n2 University of Kentucky mirek@cs.uky.edu\nAbstract. Integrating diverse formalisms into modular knowledge representation systems offers increased expressivity, modeling convenience and computational benefits. We introduce concepts of abstract modules and abstract modular systems to study general principles behind the design and analysis of modelfinding programs, or solvers, for integrated heterogeneous multi-logic systems. We show how abstract modules and abstract modular systems give rise to transition systems, which are a natural and convenient representation of solvers pioneered by the SAT community. We illustrate our approach by showing how it applies to answer set programming and propositional logic, and to multi-logic systems based on these two formalisms."
    }, {
      "heading" : "1 Introduction",
      "text" : "Knowledge representation and reasoning (KR) is concerned with developing formal languages and logics to model knowledge, and with designing and implementing corresponding automated reasoning tools. The choice of specific logics and tools depends on the type of knowledge to be represented and reasoned about. Different logics are suitable for common-sense reasoning, reasoning under incomplete information and uncertainty, for temporal and spatial reasoning, and for modeling and solving boolean constraints, or constraints over larger, even continuous domains. In applications in areas such as distributed databases, semantic web, hybrid constraint modeling and solving, to name just a few, several of these aspects come to play. Accordingly, often diverse logics have to be accommodated together. Similar issues arise in research on multi-context systems where the major task is to model contextual information and the flow of information among contexts [17,7]. The contexts are commonly modeled by theories in some logics.\nModeling convenience is not the only reason why diverse logics are combined into modular hybrid KR systems. Another major motivation is to exploit in reasoning the transparent structure that comes from modularity, computational strengths of individual logics, and synergies that may arise when they are put together. Constraint logic programming [8] and satisfiability modulo theories (SMT) [20,2] are well-known examples of formalisms stemming directly from such considerations. More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules\nar X\niv :1\n31 2.\n61 51\nv1 [\ncs .A\nI] 2\n0 D\nec 2\n01 3\nexpressed as logic theories under the classical semantics with modules given as answerset programs.\nThe key computational task arising in KR is that of model generation. Modelgenerating programs or solvers, developed in satisfiability (SAT) and ASP proved to be effective in a broad range of KR applications. Accordingly, model generation is of critical importance in modular multi-logic systems. Research on formalisms listed above resulted in fast solvers that demonstrate gains one can obtain from their heterogeneous nature. However, the diversity of logics considered and low-level technical details of their syntax and semantics obscure general principles that are important in the design and analysis of solvers for multi-logic systems.\nIn this paper we address this problem by proposing a language for talking about modular multi-logic systems that (i) abstracts away the syntactic details, (ii) is expressive enough to capture various concepts of inference, and (iii) is based only on the weakest assumptions concerning the semantics. The basic elements of this language are abstract modules. Collections of abstract modules constitute abstract modular systems. We define the semantics of abstract modules and show that they provide a uniform language capable of capturing different logics, diverse inference mechanisms, and their modular combinations. Importantly, abstract modules and abstract modular systems give rise to transition systems of the type introduced by Nieuwenhuis, Oliveras, and Tinelli [20] in their study of SAT and SMT solvers. We show that as in that earlier work, our transition systems provide a natural and convenient representation of solvers for abstract modules and abstract modular systems. We demonstrate that they lend themselves well to extensions that capture such important solver design techniques as learning (which here comes in two flavors: local that is limited to single modules, and global that is applied across modules). Throughout the paper, we illustrate our approach by showing how it applies to propositional logic and answer set programming, and to multi-logic systems based on these two formalisms.\nThe results of our paper show that abstract modular systems and the corresponding abstract framework for describing and analyzing algorithms for modular declarative programming tools relying on multi-logics are useful and effective conceptualizations that can contribute to (i) clarifying computational principles of such systems and to (ii) the development of new ones.\nThe paper is organized as follows. We start by introducing one of the main concepts in the paper – abstract modules. We then proceed to formulating an algorithm (a family of algorithms) for finding models of such modules. We use an abstract transition system stemming from the framework by Nieuwenhuis et al. [20] for this purpose. Section 4 presents the definition of an abstract modular system and a corresponding solver based on backtrack search. We then discuss how this solver maybe augmented by such advanced SAT solving technique as learning. Section 6 provides an account on related work."
    }, {
      "heading" : "2 Abstract Modules",
      "text" : "Let σ be a fixed finite vocabulary (a set of propositional atoms). A module over the vocabulary σ is a directed graph S whose nodes are ⊥ and all consistent sets of literals,\nand each edge is of the form (M,⊥) or (M,Ml), where l /∈ M and Ml is a shorthand for M ∪ {l}. If S is a module, we write σ(S) for its vocabulary. For a set X of literals, we denote X+ = {a : a ∈ X} and X− = {a : ¬a ∈ X}.\nIntuitively, an edge (M,Ml) in a module indicates that the module supports inferring l whenever all literals in M are given. An edge (M,⊥), M 6= ∅, indicates that there is a literal l ∈ M such that a derivation of its dual l̄ (and hence, a derivation of a contradiction) is supported by the module, assuming the literals inM are given. Finally, the edge (∅,⊥) indicates that the module is “explicitly” contradictory.\nA node in a module is terminal if no edge leaves it. A terminal node that is consistent and complete is a model node of the module. A set X of atoms is a model of a module S if for some model node Y in S, X ∩ σ(S) = Y +. Thus, models of modules are not restricted to the signature of the module. Clearly, for every model node Y in S, Y + is a model of S.\nA module S entails a formula ϕ, written S |= ϕ, if for every model I of S we have I |= ϕ. It is immaterial what logic the formula ϕ comes from as long as (i) the vocabulary of the logic is a subset of the vocabulary of S, and (ii) the semantics of the logic is given by a satisfiability relation I |= ϕ. A module S entails a formula ϕ wrt a set M of literals (over the same vocabulary as S), written S |=M ϕ, if for every model I of S such that M+ ⊆ I and M− ∩ I = ∅, I |= ϕ.\nClearly, if two modules over the same signature have the same model nodes, they have the same models. Semantically the three modules in Figure 1 are the same. They have the same models (each has {a} as its only model in the signature of the module) and so they entail the same formulas. We call modules with the same models equivalent.\nModules represent more than just the set of their models. As already suggested above, the intended role of edges in a module is to represent allowed “local” inferences. For instance, given the empty set of literals, the first module in Figure 1 supports inferring a and the third module ¬a. In the latter case, the inference is not “sound” as it contradicts the semantic information in the module as that module does not entail ¬a with respect to the empty set of literals.\nFormally, an edge from a node M to a node M ′ in a module S is sound if S |=M M ′.3 Clearly, if M ′ has the form Ml then S |=M M ′ if and only if S |=M l. Similarly, if M ′ = ⊥ then S |=M M ′ if and only if no model of S is consistent with M (that is, contains M+ and is disjoint with M−). A module is sound if all of its edges are sound,\n3 In the paper, we sometimes identify a set of literals with the conjunction of its elements. Here M ′ is to be understood as the conjunction of its elements.\nthat is, if all inferences supported by the module are sound with respect to the semantics of the module given by its set of models. The modules in Figures 1(a) and (b) are sound, the one in Figure 1(c) is not. Namely, the inference of ¬a from ∅ is not sound.\nGiven two modules S and S′ over the same vocabulary, we say that S is equivalently contained in S′, S v S′, if S and S′ are equivalent (have the same model nodes) and the set of edges of S is a subset of the set of edges of S′. Maximal (wrt v) sound modules are called saturated. We say that an edge from a node M to ⊥ in a module S is critical if M is a complete and consistent set of literals over σ(S). The following properties are evident.\nProposition 1. Every two modules over the same signature and with the same critical edges are equivalent. For a saturated module S, every sound module with the same critical edges as S is equivalently contained in S. A module S is saturated if and only if it is sound and for every set M of literals and for every literal l 6∈M , (M,Ml) is an edge of S whenever S |=M l.\nClearly, only the module in Figure 1(a) is saturated. The other two are not. The one in (b) is not maximal with respect to the containment relation, the one in (c) is not sound. We also note that all three modules have the same critical edges. Thus, by Proposition 1, they are equivalent, a property we already observed earlier. Finally, the module in Figure 1(b) is equivalently contained in the module in Figure 1(a).\nIn practice, modules (graphs) are specified by means of theories and logics (more precisely, specific forms of inference in logics). For instance, a propositional theory T over a vocabulary σ and the inference method given by the classical concept of entailment determine a module over σ in which (i) (M,Ml) is an edge if and only if T ∪M |= l; and (ii) (M,⊥) is an edge if and only if no model of T is consistent with M . Figure 1(a) shows the module determined in this way by the theory consisting of the clause a. Similarly, Figure 2 presents such a module for the theory\na ∨ b, ¬a ∨ ¬b. (1)\nThis module is saturated. Also, theory (1) and the inference method given by the unit propagate rule, a classical propagator used in SAT solvers, determines this module. In other words, for the theory (1) the unit propagation rule captures entailment.\nWe say that a module S is equivalent to a theory T in some logic if the models of S coincide with the models of T . Clearly, the module in Figure 2 is equivalent to the propositional theory (1).\nModules are not meant for modeling. Representations by means of logic theories are usually more concise (the size of a module is exponential in the size of its vocabulary). Furthermore, the logic languages align closely with natural language, which facilitates modeling and makes the correspondence between logic theories and knowledge they represent direct. Modules lack this connection to natural language.\nThe power of modules comes from the fact that they provide a uniform, syntaxindependent way to describe theories and inference methods stemming from different logics. For instance, they represent equally well both propositional theories and logic programs under the answer-set semantics. Indeed, let us consider the logic program\n{a}, b← not a, (2)\nwhere {a} represents the so-called choice rule [23]. This program has two answer sets {a} and {b}. Since these are also the only two models of the propositional theory (1), it is clear that the module in Figure 2 represents the program (2) and the reasoning mechanism of entailment with respect to its answer sets. Two other modules associated with program (2) are given in Figure 3. The module in Figure 3(a) represents program (2) and the reasoning on programs based on forward chaining; we call this moduleMfc . We recall that given a set of literals, forward chaining supports the derivation of the head of a rule whose body is satisfied. We note that the module Mfc is not equivalent to program (2). Indeed, {a, b} is a model ofMfc whereas it is not an answer set of (2). This is due to the fact that the critical edge from a b to⊥ is unsupported by forward chaining and is not present in Mfc . On the other hand, all edges due to forward chaining are sound both in the module in Figure 2, which we callMe, andMfc . In the next section we discuss a combination of inference rules that yields a reasoning mechanism subsuming forward chaining and resulting in a module, shown in Figure 3(b), that is equivalently contained inMe and so, equivalent to the program (2). This discussion indicates that the language of modules is flexible enough to represent not only the semantic mechanism of entailment, but also syntactically defined “proof systems” — reasoning mechanisms based on specific inference rules.\n3 Abstract Modular Solver: AMS\nFinding models of logic theories and programs is a key computational task in declarative programming. Nieuwenhuis et al. [20] proposed to use transition systems to describe search procedures involved in model-finding programs commonly called solvers, and developed that approach for the case of SAT. Their transition system framework can express DPLL, the basic search procedure employed by SAT solvers, and its enhancements such as conflict driven clause learning. Lierler [12] proposed a similar framework for specifying an answer set solver SMODELS. Lierler and Truszczynski [14] extended that framework to capture such modern ASP solvers as CMODELS and CLASP, as well as a PC(ID) solver MINISAT(ID).\nAn abstract nature (independence from language and reasoning method selection) of modules introduced in this work and their relation to proof systems makes them a convenient, broadly applicable tool to study and analyze solvers. In this section, we adapt the transition system framework of Nieuwenhuis et al. [20] to the case of abstract modules. We then illustrate how it can be used to define solvers for instantiations of abstract modules such as propositional theories under the classical semantics and logic programs under the answer-set semantics.\nA state relative to σ is either a special state ⊥ (fail state) or an ordered consistent set M of literals over σ, some possibly annotated by ∆, which marks them as decision literals. For instance, the states relative to a singleton set {a} of atoms are ∅, a, ¬a, a∆, ¬a∆, ⊥.\nFrequently, we consider a state M as a set of literals, ignoring both the annotations and the order between its elements. If neither a literal l nor its complement occur in M , then l is unassigned by M .\nEach module S determines its transition graph AMS : The set of nodes of AMS consists of the states relative to the vocabulary of S. The edges of the graph AMS are specified by the transition rules listed in Figure 4. The first three rules depend on the module, the fourth rule, Decide, does not. It has the same form no matter what module we consider. Hence, we omit the reference to the module from its notation.\nThe graph AMS can be used to decide whether a module S has a model. The following properties are essential.\nTheorem 1. For every sound module S,\n(a) graph AMS is finite and acyclic, (b) for any terminal state M of AMS other than ⊥, M+ is a model of S, (c) state⊥ is reachable from ∅ in AMS if and only if S is unsatisfiable (has no models).\nThus, to decide whether a sound module S has a model it is enough to find in the graph AMS a path leading from node ∅ to a terminal node M . If M = ⊥, S is unsatisfiable. Otherwise, M is a model of S.\nFor instance, let S be a module in Figure 2. Below we show a path in the transition graph AMS with every edge annotated by the corresponding transition rule:\n∅ Decide−→ b∆ PropagateS−→ b∆ ¬a. (3)\nThe state b∆ ¬a is terminal. Thus, Theorem 1 (b) asserts that {b,¬a} is a model of S. There may be several paths determining the same model. For instance, the path\n∅ Decide−→ ¬a∆ Decide−→ ¬a∆ b∆. (4)\nleads to the terminal node¬a∆ b∆, which is different from b∆ ¬a but corresponds to the same model. We can view a path in the graph AMS as a description of a process of search for a model of module S by applying transition rules. Therefore, we can characterize a solver based on the transition system AMS by describing a strategy for choosing a path in AMS . Such a strategy can be based, in particular, on assigning priorities to some or all transition rules of AMS , so that a solver will never apply a transition rule in a state if a rule with higher priority is applicable to the same state. For example, priorities\nBacktrackS ,FailS >> PropagateS >> Decide\non the transition rules of AMS specify a solver that follows available inferences (modeled by edges in the module S) before executing a transition due to Decide. The path (3) in the transition graph of the module from Figure 2 follows that strategy, whereas the path (4) does not.\nWe now review the graph DPF introduced for the classical DPLL algorithm by Nieuvenhuis et al. [20], adjusting the presentation to the form convenient for our purposes. We then demonstrate its relation to the AMS graph. The set of nodes of DPF consists of the states relative to the vocabulary of a CNF formula (a set of clauses) F . The edges of the graph DPF are specified by the transition rule Decide of the graph AMS and the rules presented in Figure 5. For example, let F1 be the theory consisting of a single clause a. Figure 6 presents DPF1 .\nFor a CNF formula F , by µ(DPF ) we denote the graph (abstract module) constructed from DPF by dropping all nodes that contain decision literals. We note that for the graph DPF1 in Figure 6, the module µ(DPF1) coincides with the module in Figure 1(a). This is a manifestation of a general property.\nProposition 2. For every CNF formula F , the graph µ(DPF ) is a sound abstract module equivalent to F . Furthermore, the graphs AMµ(DPF ) and DPF are identical.\nTheorem 1 and the fact that the module µ(DPF ) is equivalent to a CNF formula F (Proposition 2) imply that the graph DPF can be used for deciding the satisfiability of F . It is enough to find a path leading from node ∅ to a terminal node M : if M = ⊥ then F is unsatisfiable; otherwise, M is a model of F . For instance, the only terminal states reachable from the state ∅ in DPF1 are a and a∆. This translates into the fact that a is a model of F1. This is exactly the result that Nieuwenhuis et al. [20] stated for the graph DPF :\nCorollary 1. For any CNF formula F ,\n(a) graph DPF is finite and acyclic, (b) for any terminal state M of DPF other than ⊥, M is a model of F , (c) state⊥ is reachable from ∅ in DPF if and only if F is unsatisfiable (has no models).\nWe now introduce the graph ASΠ that extends the DPLL graph by Nieuwenhuis et al. so that the result can be used to specify an algorithm for finding answer sets of a program. The graph ASΠ can be used to form a sound module equivalent to a program Π in the same way as we used DPF to form a sound module equivalent to a CNF formula F .\nWe assume the reader to be familiar with the concept of unfounded sets [26,10]. For a set M of literals and a program Π , by U(M,Π) we denote an unfounded set on M w.r.t. Π . It is common to identify logic rules of a program with sets of clauses. By Πcl we denote the set of clauses corresponding to the rules of Π . For instance, let Π be (2), then Πcl consists of clauses a ∨ ¬a, a ∨ b.\nThe set of nodes of ASΠ consists of the states relative to the vocabulary of program Π . The edges of the graph ASΠ are specified by the transition rules of the graph DPΠcl and the rules presented in Figure 7.\nFor a program Π , by µ(ASΠ) we denote the graph (abstract module) constructed from ASΠ by removing all nodes that contain decision literals.\nProposition 3. For every program Π , the graph µ(ASΠ) is a sound abstract module equivalent to a program Π under the answer set semantics. Furthermore, the graphs AMµ(ASΠ) and ASΠ are identical.\nFrom Theorem 1 and the fact that µ(ASΠ) is an abstract module equivalent to an answer-set program Π it follows that the graph ASΠ can be used for deciding whether Π has an answer set. It is enough to find a path in ASΠ leading from the node ∅ to a terminal node M . If M = ⊥ then Π has no answer sets; otherwise, M is an answer set of Π .\nCorollary 2. For any program Π ,\n(a) graph ASΠ is finite and acyclic, (b) for any terminal state M of ASΠ other than ⊥, M+ is an answer set of Π , (c) state ⊥ is reachable from ∅ in ASΠ if and only if Π has no answer sets.\nLet Π be the program (2). Figure 3(b) presents the module µ(ASΠ). It is easy to see that this module is equivalently contained in the saturated module for Π presented in Figure 2. For program Π the inference rules of UnitPropagate and Unfounded are capable to capture all but one inference due to the entailment (the missing inference corresponds to the edge from b to ¬a b in Figure 2).\nLet us now consider the graph AS−Π constructed from ASΠ by either dropping the rules UnfoundedΠ , BacktrackΠ , FailΠ or the rules UnitPropagateΠcl , BacktrackΠcl , FailΠcl . In each case, the module µ(AS − Π) in general is not equivalent to a program Π . This demonstrates the importance of two kinds of inferences for the case of logic programs: (i) those stemming from unit propagate and related to the fact that an answer set of a program is also its classical model; as well as (ii) those based on the concept of “unfoundedness” and related to the fact that every answer set of a program contains no unfounded sets. We note that forward chaining mentioned in earlier section is subsumed by unit propagate.\nThe graph ASΠ is inspired by the graph SMΠ introduced by Lierler [11] for specifying an answer set solver SMODELS [19]. The graph SMΠ extends ASΠ by two additional transition rules (inference rules or propagators): All Rules Cancelled and Backchain True. We chose to start the presentation with the graph ASΠ for its simplicity. We now recall the definition of SMΠ and illustrate how a similar result to Proposition 3 is applicable to it.\nIfB is a conjunction of literals then byB we understand the set of the complements of literals occurring in B.\nThe set of nodes of SMΠ consists of the states relative to the vocabulary of program Π . The edges of the graph SMΠ are specified by the transition rules of the graph ASΠ and the following rules: All Rules Cancelled : M −→ M ¬a if { B ∩M 6= ∅ for all B ∈ Bodies(Π, a) ¬a is unassigned by M Fail ARC: M −→ ⊥ if { B ∩M 6= ∅ for all B ∈ Bodies(Π, a), a ∈M , M contains no decision literals Backtrack ARC: P l∆ Q −→ P l if { B ∩M 6= ∅ for all B ∈ Bodies(Π, a), a ∈ P l Q, Q contains no decision literals\nBackchain True : M −→ M l if  a← B ∈ Π , a ∈M , l ∈ B B′ ∩M 6= ∅ for all B′ ∈ Bodies(Π, a) \\B l is unassigned by M\nFail BT: M −→ ⊥ if  a← B ∈ Π , a ∈M , l ∈ B B′ ∩M 6= ∅ for all B′ ∈ Bodies(Π, a) \\B l ∈M , M contains no decision literals\nBacktrack BT: P l∆ Q −→ P l if  a← B ∈ Π , a ∈ P l Q, l′ ∈ B B′ ∩ P l Q 6= ∅ for all B′ ∈ Bodies(Π, a) \\B l′ ∈ P l Q, Q contains no decision literals\nThe graph SMΠ shares the important properties of the graph ASΠ . Indeed, Proposition 3 and Corollary 2 hold if one replaces ASΠ with SMΠ . Corollary 2 in this form was one of the main results stated in [11]4.\nLet Π be the program (2). Figure 3(b) presents the module µ(ASΠ). The module µ(SMΠ) coincides with the saturated module for Π presented in Figure 2. For program Π , the inference rule Backchain True captures the inference that corresponds to the edge from b to ¬a b, which the transition rules of the graph ASΠ are incapable to capture.\nThe examples above show that the framework of abstract modules uniformly encompasses different logics. We illustrated this point by means of propositional logic and answer-set programming. Furthermore, it uniformly models diverse reasoning mechanisms (entailment and its proof theoretic specializations). The results also demonstrate that transition systems proposed earlier to represent and analyze SAT and ASP solvers are special cases of general transition systems for abstract modules introduced here.\n4 In [11], Lierler presented the SMΠ graph in a slightly different from: the states of that graph permitted inconsistent states of literals, which in turn allowed to unify the Fail and Backtrack transition rules for different propagators.\n4 Abstract Modular System and Solver AMSA\nBy capturing diverse logics in a single framework, abstract modules are well suited for studying modularity in declarative formalisms, and principles underlying solvers for modular declarative formalisms. We now define an abstract modular declarative framework that uses the concept of a module as its basic element. We then show how abstract transition systems for modules generalize to the new formalism.\nAn abstract modular system (AMS) is a set of modules. The vocabulary of an AMS A is the union of the vocabularies of modules of A (they do not have to have the same vocabulary); we denote it by σ(A).\nAn interpretation I over σ(A) (that is, a subset of σ(A)) is a model of A, written I |= A, if I is a model of every module S ∈ A. An AMS A entails a formula ϕ (over the same vocabulary as A), written A |= ϕ, if for every model I of A we have I |= ϕ. We say that an AMS A is sound if every module S ∈ A is sound.\nLet S1 be a module presented in Figure 1(a) and S2 be a module in Figure 3(b). The vocabulary of the AMS {S1, S2} consists of the atoms a and b. It is easy to see that the interpretation {a,¬b} is its only model.\nFor a vocabulary σ and a set of literals M , by M |σ we denote the maximal subset of M consisting of literals over σ. For example, {¬a,¬b}|{a} = {¬a}.\nEach AMS A determines its transition system AMSA. The set of nodes of AMSA consists of the states relative to σ(A). The transition rules of AMSA comprise the rule Decide and the rules PropagateS , FailS , and BacktrackS , for all modules S ∈ A. The latter three rules are modified to account for the vocabulary σ(A) and are presented in Figure 8.\nTheorem 2. For every sound AMS A,\n(a) the graph AMSA is finite and acyclic, (b) any terminal state of AMSA other than ⊥ is a model of A, (c) the state ⊥ is reachable from ∅ in AMSA if and only if A is unsatisfiable.\nThis theorem demonstrates that to decide a satisfiability of a sound AMS A it is sufficient to find a path leading from node ∅ to a terminal node. It provides a foundation for the development and analysis of solvers for modular systems.\nFor instance, let A be the AMS {S1, S2}. Below is a valid path in the transition graph AMSA with every edge annotated by the corresponding transition rule:\n∅ Decide−→ ¬a∆ PropagateS2−→ ¬ a∆ b BacktrackS1−→ a Decide−→ a ¬b∆.\nThe state a ¬b∆ is terminal. Thus, Theorem 2 (b) asserts that {a,¬b} is a model of A. Let us interpret this example. Earlier we demonstrated that module S1 can be regarded as a representation of a propositional theory consisting of a single clause a whereas S2 corresponds to the logic program (2) under the semantics of answer sets. We then illustrated how modules S1 and S2 give rise to particular algorithms for implementing search procedures. The graph AMSA represents the algorithm obtained by integrating the algorithms supported by the modules S1 and S2 separately.\nThe results presented above imply, as special cases, earlier results on the logics PC(ID) and SM(ASP), and their solvers [14]."
    }, {
      "heading" : "5 Learning in Solvers for AMSs.",
      "text" : "Nieuwenhuis et al. [20, Section 2.4] defined the DPLL System with Learning graph to describe SAT solvers’ learning, one of the crucial features of current SAT solvers responsible for rapid success in this area of automated reasoning. The approach of Nieuwenhuis, Oliveras, and Tinelli extends to our abstract setting. Specifically, the graph AMSA can be extended with “learning transitions” to represent solvers for AMSs that incorporate learning.\nThe intuition behind learning in SAT is to allow new propagations by extending the original clause database as computation proceeds. These “learned” clauses provide new “immediate derivations” to a SAT solver by enabling additional applications of UnitPropagate. In the framework of abstract modules, immediate derivations are represented by edges. Adding edges to modules captures the idea of learning by supporting new propagations that the transition rule Propagate may take an advantage of. We now state these intuitions formally for the case of abstract modular systems.\nLet S be a module and E a set of edges between nodes of S. By SE we denote the module constructed by adding to S the edges in E. A set E of edges is S-safe if the module SE is sound and equivalent to S. For an AMS A and a set of edges E over the vocabulary ofA, we defineAE = {SE|S : S ∈ A} (where E|S is the set of those edges in E that connect nodes in S). We say that E isA-safe ifA andAE are equivalent, and each module SE in AE is sound.\nAn (augmented) state relative to an AMS A = {S1, . . . , Sn} is either a distinguished state ⊥ or a pair of the form M ||Γ1, . . . , Γn where M is an ordered consistent setM of literals over σ, some possibly annotated by∆; and Γ1, . . . , Γn are sets of edges between nodes of modules S1, . . . , Sn, respectively. Sometimes we denote Γ1, . . . , Γn by G. For any AMS A = {S1, . . . , Sn}, we define a graph AMSLA. Its nodes are the augmented states relative to A. The rule Decide of the AMSA graph extends to AMSLA as follows\nDecide: M ||G −→ M l∆||G if l is unassigned by M . Figure 9 presents the transition rules of AMSLA that are specific to each module Si in A. We note that the set E of edges in the rule Learn LocalSi is required to consist of\nedges that run between the nodes of Si. The transition rule\nLearn Global: M || . . . , Γj , . . . −→ M || . . . , Γj ∪ E|Si , . . . if E is A-safe\nwhere E is a set of edges between nodes over the vocabulary σ(A), concludes the definition of AMSLA.\nWe refer to the transition rules Propagate, Backtrack, Decide, and Fail of the graph AMSLA as basic. We say that a node in the graph is semi-terminal if no basic rule is applicable to it. The graph AMSLA can be used for deciding whether an AMS A has an answer set by constructing a path from ∅||∅, . . . , ∅ to a semi-terminal node.\nTheorem 3. For any sound AMS A,\n(a) there is an integer m such that every path in AMSLA contains at most m edges due to basic transition rules, (b) for any semi-terminal state M ||G of AMSLA reachable from ∅||∅, . . . , ∅, M is a model of A, (c) state ⊥ is reachable from ∅||∅, . . . , ∅ in AMSLA if and only if A has no models.\nIt follows that if we are constructing a path starting in ∅||∅, . . . , ∅ in a way that guarantees that every sequence of consecutive edges of the path labeled with Learn Local and Learn Global eventually ends (is finite), then the path will reach some semi-terminal state. As soon as a semi-terminal state is reached the problem of finding a model is solved.\nThere is an important difference between Learn Local and Learn Global. The first one allows new propagations within a module but does not change its semantics as the models of the module stay the same (and it is local, other modules are unaffected by it). The application of Learn Global while preserving the overall semantics of the system may change the semantics of individual modules by eliminating some of their models (and, being global, affects in principle all modules of the system). SAT researchers have demonstrated that Learn Local is crucial for the success of SAT technology both in practice and theoretically. Our initial considerations suggest that under some circumstances, Learn Global offers additional substantial performance benefits.\nWe stress that our discussion of learning does not aim at any specific algorithmic ways in which one could perform learning. Instead, we formulate conditions that learned edges are to satisfy (S-safety for learning local to a module S, andA-safety for the global learning rule), which ensure the correctness of solvers that implement learning so that to satisfy them. In this way, we provide a uniform framework for correctness proofs of multi-logic solvers incorporating learning."
    }, {
      "heading" : "6 Related Work",
      "text" : "In an important development, Brewka and Eiter [3] introduced an abstract notion of a heterogeneous nonmonotonic multi-context system (MCS). One of the key aspects of that proposal is its abstract representation of a logic and hence contexts that rely on such abstract logics. The independence of contexts from syntax promoted focus on semantic aspect of modularity exhibited by multi-context systems. Since their inception, multi-context systems have received substantial attention and inspired implementations of hybrid reasoning systems including DLVHEX [5] and DMCS [1]. Abstract modular systems introduced here are similar to MCSs as they too do not rely on any particular syntax for logics assumed in modules (a counterpart of a context). What distinguishes them is that they encapsulate some semantic features stemming from inferences allowed by the underlying logic. This feature of abstract modules is essential for our purposes as we utilize them as a tool for studying algorithmic aspects of multi-logic systems. Another difference between AMS and MCS is due to “bridge rules.” Bridge rules are crucial for defining the semantics of an MCS. They are also responsible for “information sharing” in MCSs. They are absent in our formalism altogether. In AMS information sharing is implemented by a simple notion of a shared vocabulary between the modules.\nModularity is one of the key techniques in principled software development. This has been a major trigger inspiring research on modularity in declarative programming paradigms rooting in KR languages such as answer set programming, for instance. Oikarinen and Janhunen [21] proposed a modular version of answer set programs called lp-modules. In that work, the authors were primarily concerned with the decomposition of lp-modules into sets of simpler ones. They proved that under some assumptions such decompositions are possible. Järvisalo, Oikarinen, Janhunen, and Niemelä [9], and Tasharrofi and Ternovska [24] studied the generalizations of lp-modules. In their work the main focus was to abstract lp-modules formalism away from any particular syntax or semantics. They then study properties of the modules such as “joinability” and analyze different ways to join modules together and the semantics of such a join. We are interested in building simple modular systems using abstract modules – the only composition mechanism that we study is based on conjunction of modules. Also in contrast to the work by Järvisalo et al. [9] and Tasharrofi and Ternovska [24], we define such conjunction for any modules disregarding their internal structure and interdepencies between each other.\nTasharrofi, Wu, and Ternovska [25] developed and studied an algorithm for processing modular model expansion tasks in the abstract multi-logic system concept developed by Tasharrofi and Ternovska [24]. They use the traditional pseudocode method to present the developed algorithm. In this work we adapt the graph-based framework\nfor designing backtrack search algorithms for abstract modular systems. The benefits of that approach for modeling families of backtrack search procedures employed in SAT, ASP, and PC(ID) solvers were demonstrated by Nieuwenhuis et al. [20], Lierler [11], and Lierler and Truszczynski [14]. Our work provides additional support for the generality and flexibility of the graph-based framework as a finer abstraction of backtrack search algorithms than direct pseudocode representations, allowing for convenient means to prove correctness and study relationships between the families of the algorithms."
    }, {
      "heading" : "7 Conclusions",
      "text" : "We introduced abstract modules and abstract modular systems and showed that they provide a framework capable of capturing diverse logics and inference mechanisms integrated into modular knowledge representation systems. In particular, we showed that transition graphs determined by modules and modular systems provide a unifying representation of model-generating algorithms, or solvers, and simplify reasoning about such issues as correctness or termination. We believe they can be useful in theoretical comparisons of solver effectiveness and in the development of new solvers. Learning, a fundamental technique in solver design, displays itself in two quite different flavors, local and global. The former corresponds to learning studied before in SAT and SMT and demonstrated both theoretically and practically to be essential for good performance. Global learning is a new concept that we identified in the context of modular systems. It concerns learning across modules and, as local learning, promises to lead to performance gains. In the future work we will conduct a systematic study of global learning in abstract modular systems and its impact on solvers for practical multi-logic formalisms."
    } ],
    "references" : [ {
      "title" : "The dmcs solver for distributed nonmonotonic multi-context systems",
      "author" : [ "S.E.D. Bairakdar", "M. Dao-Tran", "T. Eiter", "M. Fink", "T. Krennwallner" ],
      "venue" : "12th European Conference on Logics in Artificial Intelligence (JELIA). pp. 352–355",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Satisfiability modulo theories",
      "author" : [ "C. Barrett", "R. Sebastiani", "S. Seshia", "C. Tinelli" ],
      "venue" : "Biere, A., Heule, M., van Maaren, H., Walsch, T. (eds.) Handbook of Satisfiability, pp. 737–797. IOS Press",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Equilibria in heterogeneous nonmonotonic multi-context systems",
      "author" : [ "G. Brewka", "T. Eiter" ],
      "venue" : "Proceedings of National conference on Artificial Intelligence (AAAI). pp. 385–390",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A Tarskian informal semantics for answer set programming",
      "author" : [ "M. Denecker", "Y. Lierler", "M. Truszczynski", "J. Vennekens" ],
      "venue" : "Dovier, A., Costa, V.S. (eds.) International Conference on Logic Programming (ICLP). LIPIcs, vol. 17. Schloss Dagstuhl - Leibniz-Zentrum fuer Informatik",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "A uniform integration of higher-order reasoning and external evaluations in answer set programming",
      "author" : [ "T. Eiter", "G. Ianni", "R. Schindlauer", "H. Tompits" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). pp. 90–96",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "M. Gelfond", "V. Lifschitz" ],
      "venue" : "Kowalski, R., Bowen, K. (eds.) Proceedings of International Logic Programming Conference and Symposium. pp. 1070–1080. MIT Press",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Contextual reasoning",
      "author" : [ "F. Giunchiglia" ],
      "venue" : "Epistemologia XVI, 345–364",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1993
    }, {
      "title" : "Constraint logic programming: A survey",
      "author" : [ "J. Jaffar", "M. Maher" ],
      "venue" : "Journal of Logic Programming 19(20), 503–581",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 1994
    }, {
      "title" : "A module-based framework for multilanguage constraint modeling",
      "author" : [ "M. Järvisalo", "E. Oikarinen", "T. Janhunen", "I. Niemelä" ],
      "venue" : "Proceedings of the 10th International Conference on Logic Programming and Nonmonotonic Reasoning",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2009
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "J. Lee" ],
      "venue" : "Proceedings of International Joint Conference on Artificial Intelligence (IJCAI). pp. 503–508. Professional Book Center",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Abstract answer set solvers",
      "author" : [ "Y. Lierler" ],
      "venue" : "Proceedings of International Conference on Logic Programming (ICLP). pp. 377–391. Springer",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Abstract answer set solvers with backjumping and learning",
      "author" : [ "Y. Lierler" ],
      "venue" : "Theory and Practice of Logic Programming 11, 135–169",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "On the relation of constraint answer set programming languages and algorithms",
      "author" : [ "Y. Lierler" ],
      "venue" : "Proceedings of the AAAI Conference on Artificial Intelligence. MIT Press",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Transition systems for model generators — a unifying approach",
      "author" : [ "Y. Lierler", "M. Truszczynski" ],
      "venue" : "Theory and Practice of Logic Programming, 27th Int’l. Conference on Logic Programming (ICLP’11) Special Issue 11, issue 4-5",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Stable models and an alternative logic programming paradigm",
      "author" : [ "V. Marek", "M. Truszczyński" ],
      "venue" : "The Logic Programming Paradigm: a 25-Year Perspective, pp. 375–398. Springer Verlag",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "SAT(ID): Satisfiability of propositional logic extended with inductive definitions",
      "author" : [ "M. Mariën", "J. Wittocx", "M. Denecker", "M. Bruynooghe" ],
      "venue" : "SAT. pp. 211–224",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Generality in Artificial Intelligence",
      "author" : [ "J. McCarthy" ],
      "venue" : "Communications of the ACM 30(12),",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1987
    }, {
      "title" : "Logic programs with stable model semantics as a constraint programming paradigm",
      "author" : [ "I. Niemelä" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence 25, 241–273",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Extending the Smodels system with cardinality and weight constraints",
      "author" : [ "I. Niemelä", "P. Simons" ],
      "venue" : "Minker, J. (ed.) Logic-Based Artificial Intelligence, pp. 491–521. Kluwer",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "Solving SAT and SAT modulo theories: From an abstract Davis-Putnam-Logemann-Loveland procedure to DPLL(T)",
      "author" : [ "R. Nieuwenhuis", "A. Oliveras", "C. Tinelli" ],
      "venue" : "Journal of the ACM 53(6), 937–977",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Modular equivalence for normal logic programs",
      "author" : [ "E. Oikarinen", "T. Janhunen" ],
      "venue" : "17th European Conference on Artificial Intelligence(ECAI). pp. 412–416",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Constraint programming",
      "author" : [ "F. Rossi", "P. van Beek", "T. Walsh" ],
      "venue" : "van Harmelen, F., Lifschitz, V., Porter, B. (eds.) Handbook of Knowledge Representation, pp. 181–212. Elsevier",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "P. Simons", "I. Niemelä", "T. Soininen" ],
      "venue" : "Artificial Intelligence 138, 181–234",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2002
    }, {
      "title" : "A semantic account for modularity in multi-language modelling of search problems",
      "author" : [ "S. Tasharrofi", "E. Ternovska" ],
      "venue" : "Frontiers of Combining Systems, 8th International Symposium (FroCoS). pp. 259–274",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Solving modular model expansion tasks",
      "author" : [ "S. Tasharrofi", "X.N. Wu", "E. Ternovska" ],
      "venue" : "CoRR abs/1109.0583",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "The well-founded semantics for general logic programs",
      "author" : [ "A. Van Gelder", "K. Ross", "J. Schlipf" ],
      "venue" : "Journal of ACM 38(3), 620–650",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 1991
    } ],
    "referenceMentions" : [ {
      "referenceID" : 16,
      "context" : "Similar issues arise in research on multi-context systems where the major task is to model contextual information and the flow of information among contexts [17,7].",
      "startOffset" : 157,
      "endOffset" : 163
    }, {
      "referenceID" : 6,
      "context" : "Similar issues arise in research on multi-context systems where the major task is to model contextual information and the flow of information among contexts [17,7].",
      "startOffset" : 157,
      "endOffset" : 163
    }, {
      "referenceID" : 7,
      "context" : "Constraint logic programming [8] and satisfiability modulo theories (SMT) [20,2] are well-known examples of formalisms stemming directly from such considerations.",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 19,
      "context" : "Constraint logic programming [8] and satisfiability modulo theories (SMT) [20,2] are well-known examples of formalisms stemming directly from such considerations.",
      "startOffset" : 74,
      "endOffset" : 80
    }, {
      "referenceID" : 1,
      "context" : "Constraint logic programming [8] and satisfiability modulo theories (SMT) [20,2] are well-known examples of formalisms stemming directly from such considerations.",
      "startOffset" : 74,
      "endOffset" : 80
    }, {
      "referenceID" : 12,
      "context" : "More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules ar X iv :1 31 2.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 5,
      "context" : "More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules ar X iv :1 31 2.",
      "startOffset" : 122,
      "endOffset" : 131
    }, {
      "referenceID" : 14,
      "context" : "More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules ar X iv :1 31 2.",
      "startOffset" : 122,
      "endOffset" : 131
    }, {
      "referenceID" : 17,
      "context" : "More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules ar X iv :1 31 2.",
      "startOffset" : 122,
      "endOffset" : 131
    }, {
      "referenceID" : 21,
      "context" : "More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules ar X iv :1 31 2.",
      "startOffset" : 168,
      "endOffset" : 172
    }, {
      "referenceID" : 15,
      "context" : "More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules ar X iv :1 31 2.",
      "startOffset" : 209,
      "endOffset" : 213
    }, {
      "referenceID" : 13,
      "context" : "More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules ar X iv :1 31 2.",
      "startOffset" : 223,
      "endOffset" : 227
    }, {
      "referenceID" : 3,
      "context" : "More recent examples include constraint answer set programming (CASP) [13], which integrates answer set programming (ASP) [6,15,18]) with constraint modeling languages [22], and “multilogic” formalisms PC(ID) [16], SM(ASP) [14] and ASP-FO [4] that combine modules ar X iv :1 31 2.",
      "startOffset" : 239,
      "endOffset" : 242
    }, {
      "referenceID" : 19,
      "context" : "Importantly, abstract modules and abstract modular systems give rise to transition systems of the type introduced by Nieuwenhuis, Oliveras, and Tinelli [20] in their study of SAT and SMT solvers.",
      "startOffset" : 152,
      "endOffset" : 156
    }, {
      "referenceID" : 19,
      "context" : "[20] for this purpose.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "where {a} represents the so-called choice rule [23].",
      "startOffset" : 47,
      "endOffset" : 51
    }, {
      "referenceID" : 19,
      "context" : "[20] proposed to use transition systems to describe search procedures involved in model-finding programs commonly called solvers, and developed that approach for the case of SAT.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 11,
      "context" : "Lierler [12] proposed a similar framework for specifying an answer set solver SMODELS.",
      "startOffset" : 8,
      "endOffset" : 12
    }, {
      "referenceID" : 13,
      "context" : "Lierler and Truszczynski [14] extended that framework to capture such modern ASP solvers as CMODELS and CLASP, as well as a PC(ID) solver MINISAT(ID).",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 19,
      "context" : "[20] to the case of abstract modules.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20], adjusting the presentation to the form convenient for our purposes.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "[20] stated for the graph DPF :",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "We assume the reader to be familiar with the concept of unfounded sets [26,10].",
      "startOffset" : 71,
      "endOffset" : 78
    }, {
      "referenceID" : 9,
      "context" : "We assume the reader to be familiar with the concept of unfounded sets [26,10].",
      "startOffset" : 71,
      "endOffset" : 78
    }, {
      "referenceID" : 10,
      "context" : "The graph ASΠ is inspired by the graph SMΠ introduced by Lierler [11] for specifying an answer set solver SMODELS [19].",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 18,
      "context" : "The graph ASΠ is inspired by the graph SMΠ introduced by Lierler [11] for specifying an answer set solver SMODELS [19].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 10,
      "context" : "Corollary 2 in this form was one of the main results stated in [11]4.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 10,
      "context" : "4 In [11], Lierler presented the SMΠ graph in a slightly different from: the states of that graph permitted inconsistent states of literals, which in turn allowed to unify the Fail and Backtrack transition rules for different propagators.",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 13,
      "context" : "The results presented above imply, as special cases, earlier results on the logics PC(ID) and SM(ASP), and their solvers [14].",
      "startOffset" : 121,
      "endOffset" : 125
    }, {
      "referenceID" : 2,
      "context" : "In an important development, Brewka and Eiter [3] introduced an abstract notion of a heterogeneous nonmonotonic multi-context system (MCS).",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 4,
      "context" : "Since their inception, multi-context systems have received substantial attention and inspired implementations of hybrid reasoning systems including DLVHEX [5] and DMCS [1].",
      "startOffset" : 155,
      "endOffset" : 158
    }, {
      "referenceID" : 0,
      "context" : "Since their inception, multi-context systems have received substantial attention and inspired implementations of hybrid reasoning systems including DLVHEX [5] and DMCS [1].",
      "startOffset" : 168,
      "endOffset" : 171
    }, {
      "referenceID" : 20,
      "context" : "Oikarinen and Janhunen [21] proposed a modular version of answer set programs called lp-modules.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 8,
      "context" : "Järvisalo, Oikarinen, Janhunen, and Niemelä [9], and Tasharrofi and Ternovska [24] studied the generalizations of lp-modules.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 23,
      "context" : "Järvisalo, Oikarinen, Janhunen, and Niemelä [9], and Tasharrofi and Ternovska [24] studied the generalizations of lp-modules.",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 8,
      "context" : "[9] and Tasharrofi and Ternovska [24], we define such conjunction for any modules disregarding their internal structure and interdepencies between each other.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 23,
      "context" : "[9] and Tasharrofi and Ternovska [24], we define such conjunction for any modules disregarding their internal structure and interdepencies between each other.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 24,
      "context" : "Tasharrofi, Wu, and Ternovska [25] developed and studied an algorithm for processing modular model expansion tasks in the abstract multi-logic system concept developed by Tasharrofi and Ternovska [24].",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 23,
      "context" : "Tasharrofi, Wu, and Ternovska [25] developed and studied an algorithm for processing modular model expansion tasks in the abstract multi-logic system concept developed by Tasharrofi and Ternovska [24].",
      "startOffset" : 196,
      "endOffset" : 200
    }, {
      "referenceID" : 19,
      "context" : "[20], Lierler [11], and Lierler and Truszczynski [14].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[20], Lierler [11], and Lierler and Truszczynski [14].",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 13,
      "context" : "[20], Lierler [11], and Lierler and Truszczynski [14].",
      "startOffset" : 49,
      "endOffset" : 53
    } ],
    "year" : 2013,
    "abstractText" : "Modular Systems and Solvers Yuliya Lierler and Miroslaw Truszczynski 1 University of Nebraska at Omaha ylierler@unomaha.edu 2 University of Kentucky",
    "creator" : "LaTeX with hyperref package"
  }
}