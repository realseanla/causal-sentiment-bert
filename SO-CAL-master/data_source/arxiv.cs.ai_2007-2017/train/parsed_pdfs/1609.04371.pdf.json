{
  "name" : "1609.04371.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Finite LTL Synthesis is EXPTIME-complete",
    "authors" : [ "Jorge A. Baier", "Alberto Camacho", "Christian Muise", "Sheila A. McIlraith" ],
    "emails" : [ "jabaier@ing.puc.cl", "acamacho@cs.toronto.edu", "cjmuise@mit.edu", "sheila@cs.toronto.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "LTL synthesis – the construction of a function to satisfy a logical specification formulated in Linear Temporal Logic – is a 2EXPTIME-complete problem with relevant applications in controller synthesis and a myriad of artificial intelligence applications. In this research note we consider De Giacomo and Vardi’s variant of the synthesis problem for LTL formulas interpreted over finite rather than infinite traces. Rather surprisingly, given the existing claims on complexity, we establish that LTL synthesis is EXPTIME-complete for the finite interpretation, and not 2EXPTIME-complete as previously reported. Our result coincides nicely with the planning perspective where non-deterministic planning with full observability is EXPTIME-complete and partial observability increases the complexity to 2EXPTIME-complete; a recent related result for LTL synthesis shows that in the finite case with partial observability, the problem is 2EXPTIME-complete."
    }, {
      "heading" : "1. Introduction",
      "text" : "Church’s synthesis problem, a classical problem in computer science, calls for the automatic construction of a procedure which, given a logical specification ϕ(I,O) between input strings I and output strings O, determines whether there exists an operator F that implements the specification such that ϕ(I, F (I)) holds for all inputs I. It was first posed\nEmail addresses: jabaier@ing.puc.cl (Jorge A. Baier), acamacho@cs.toronto.edu (Alberto Camacho), cjmuise@mit.edu (Christian Muise), sheila@cs.toronto.edu (Sheila A. McIlraith)\nUnder review for publication\nar X\niv :1\n60 9.\n04 37\n1v 1\n[ cs\n.L O\nby Church in 1957 in the context of synthesizing digital circuits from a logical specification [1, 2] and is considered one of the most challenging problems in reactive systems [3]. Büchi and Landweber first solved the problem in 1969 [4]. Soon after, Rabin proposed a solution exploiting automata on infinite trees [5]. In the years that have followed, two common approaches to solving the problem have emerged: reducing the problem to the emptiness problem of tree automata, and characterizing the problem in terms of a two-player game.\nIn 1989, Pnueli and Rosner examined the problem of reactive synthesis using Linear Temporal Logic (LTL) [6] as the specification language, viewing the problem as a two-player game, and showing that this problem was 2EXPTIME-complete [7]. Pnueli and Rosner’s approach required two translations, first from the LTL formula, ϕ, to a Büchi automaton, Bϕ, and then determinization of Bϕ to a deterministic Rabin automaton. This double translation gives the procedure its worst case double exponential complexity in the size of ϕ. The subsequent game over the Rabin automata can be solved in nk, where n is the number of states of the automaton and k is the number of accepting pairs.\nOver the years, this discouraging result has been mitigated by the identification of several restricted classes of LTL for which the complexity of the synthesis problem need not be so high. For example, in 1998 Asarin, Maler, Pnueli and Sifakis presented efficient polynomial (N2) solutions to games, and therefore synthesis problems, where the acceptance condition was restricted to an LTL formula of the form p, q, p or q. In 2004, Alur and La Torre also identified what they argued to be a compelling fragment of LTL that restricts to Boolean combinations of either (,∧) or (,∧,∨), proving that the synthesis problem was PSPACE-complete or EXPSPACE, respectively, utilizing a parameterization in terms of the so-called longest distance (length of the longest simple path in the Büchi automaton) [8]. Further, in 2006, Piterman, Pnueli, and Sa’ar examined the synthesis of reactive designs when the LTL specification was restricted to the class of so-called Generalized Reactivity(1) (GR1) formulae, presenting an N3-time algorithm which checks whether the formula is realizable, and in the case where it is, constructs an automaton representing one of the possible implementing circuits [3].\nIn this paper, we identify another important and rich class of LTL formulae for which the synthesis problem does not require a double exponential solution. In particular, we show that when the specification, ϕ, is restricted to formulae expressed in LTL interpreted over finite traces, so-called finite LTL or LTLf , the synthesis problem is EXPTIME-complete. The notion of interpreting LTL over finite traces dates back at least 20 years to its use expressing domain control knowledge or temporally extended goals and preferences in artificial intelligence (AI) automated plan generation tasks. Various techniques for generating plans with finite LTL goals have been developed for actions with deterministic effects (e.g., [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.g., [15]). Finite LTL generally exploits a weak-next operator () and often includes a special modality to designate the final state of the finite trace, distinguishing its syntax and expressivity from LTL interpreted over infinite traces (e.g., [16, 17, 18]). Finite LTL supports the specification\nof an important classes of planning and synthesis problems. The majority of automated planning applications require solutions that are finite, such as a plan for a fleet of trucks to deliver a set of packages. Similarly, the class of synthesis problems for which solutions are finite is large, including a myriad of tasks from component robot skills or terminating software activities such as web services and the processing of business transactions (e.g., [19, 20]). Indeed, LTLf is used extensively in business process specifications [21].\nIn 2015, De Giacomo and Vardi investigated synthesis from LTL specifications interpreted over finite traces, characterizing the problem computationally as 2EXPTIMEcomplete and presenting a sound and complete synthesis technique based on Deterministic Finite Automata (reachability) games. This paper shows that synthesis from LTL specifications interpreted over finite traces is EXPTIME-complete. Similar in spirit to the work of Asarin et al., Alur and La Torre, and Piterman et al., this result is important not only for clarifying the complexity of the finite LTL synthesis task, but also because it identifies another rich fragment of LTL for which synthesis avoids the discouraging double exponential originally described by Pnueli and Rosner.\nThe paper proceeds as follows. First, we provide necessary background on alternating Turing machines and finite LTL, LTLf . Next, we briefly describe a technique by the Torres and Baier’s for translating LTLf into alternating automata that has been used in support of automated plan generation with LTLf temporally extended goals [22]. In the next section we introduce the problem of LTLf synthesis, and present the central contribution of this paper: a proof that LTLf synthesis is EXPTIME-complete. The proof is based on two lemmas. In Lemma 1, we show that LTLf synthesis is in EXPTIME by means of an algorithm, inspired in Torres and Baier’s alternating automata compilation, that shows that LTLf synthesis can be solved using alternating Turing machines in polynomial space. In Lemma 2, we show that LTLf synthesis is EXPTIME-hard. The technique we use transforms an alternating Turing machine into LTLf synthesis, and gains some inspiration from methods used by Rintanen to prove the complexity of non-deterministic planning with full and partial observability [23]."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "In this section we review alternating Turing machines and LTLf . We also overview a technique for translating LTLf into alternating automata. These concepts are necessary for the proofs that follow. The reader familiar with some or all of these topics can safely skip the corresponding subsections."
    }, {
      "heading" : "2.1. Alternating Turing Machines",
      "text" : "Alternating Turing Machines (ATMs) where introduced by Chandra et al. (1981). Throughout the paper, we use a variant of the original definition, and follow the notation that has been used by Rintanen (2004).\nDefinition 1 (Alternating Turing Machine) An Alternating Turing Machine (ATM) is a tuple 〈Σ, Q, q0, g〉 where:\n• Σ is a finite alphabet\n• Q is a finite set of internal states\n• δ : Σ ∪ {|, } × Q → 2Σ∪{|}×Q×{L,N,R} is a transition function, where | and are, respectively, the end-of-tape and blank symbols. Additionally, we require:\n– s′ = | and m = R for all 〈s′, q′,m〉 ∈ δ(|, q) – s′ ∈ Σ for all 〈s′, q′,m〉 ∈ δ(s, q) where s ∈ Σ\n• q0 ∈ Q is the initial internal state\n• g : Q → {accept , reject ,∃, ∀} is a labeling function. States q ∈ Q with g(q) = ∀ are called universal, whereas states with g(q) = ∃ are called existential.\nA configuration of an ATM A is defined by the content of its tape cells, its internal state, and the position of the R/W head over the tape cells (see Definition 2). In the initial configuration, the R/W head is positioned over the second tape cell. The first tape cell has an end-of-tape symbol, and the following cells have, in order, the value of the elements in the input string σ. The remaining cells of the tape are assumed to be blank ( ).\nFor a given configuration C of an ATM A, each element 〈s′, q′,m〉 in δ(q, s) identifies a successor configuration. Intuitively, the content of the tape cell under the R/W head is updated to s′. The internal state of A switches to q′, and m describes the movement of the R/W head – which moves either one cell right, left, or stays in the same position (see Definition 3).\nDefinition 2 (Configuration of an ATM) A configuration of an ATM A = 〈Σ, Q, q0, g〉 is a tuple 〈q, σl, σr〉 where q ∈ Q is the current state of A, σl is a word containing the tape cells to the left head, including the symbol under the head, σr is a word describing the contents of the tape to the right of the head. Elements in σl and σr have values in Σ ∪ {|, }. For an input string σ = s0, s1, . . . , sn, the initial configuration of A is 〈q0, |s0, s1 . . . sn〉.\nDefinition 3 (Successor Configurations of an ATM) For a configuration C of an ATM A = 〈Σ, Q, q0, g〉, the set of successor configurations is the smallest set that has the following elements:\n• 〈q′, σ, s′σ′〉 if 〈s′, q′, L〉 ∈ δ(s, q) and C = 〈q, σs, σ′〉\n• 〈q′, σs′, σ′〉 if 〈s′, q′, N〉 ∈ δ(s, q) and C = 〈q, σs, σ′〉\n• 〈q′, σs′t, σ′〉 if 〈s′, q′, R〉 ∈ δ(s, q) and C = 〈q, σs, tσ′〉\n• 〈q′, σs′ , σ′〉 if 〈s′, q′, R〉 ∈ δ(s, q), C = 〈q, σs, σ′〉, and |σ′| = 0\nA configuration 〈q, σl, σr〉 of n ATM A = 〈Σ, Q, q0〉 is final if g(q) ∈ {accept , reject}. The acceptance of a string σ by A is defined inductively as follows. A final configuration is 0-accepting if g(q) = accept . A non-final configuration is n-accepting, for n > 0, if one of these conditions hold: (1) g(q) = ∀, at least one successor configuration is (n−1)-accepting, and all other successor configurations are m-accepting for some m < n; or (2) g(q) = ∃, at least one successor configuration is (n−1)-accepting, and no other successor configurations are m-accepting for any m < n − 1. A configuration is accepting if it is n-accepting for some n ≥ 0. In particular, we say that A accepts string σ if the initial configuration is accepting.\nDefinition 4 (Computation Subtrees) The computation subtree of an ATM A = 〈Σ, Q, q0, g〉 is the set T of accepting configurations defined recursively as follows:\n• 〈q0, σ〉 ∈ T , i.e., T contains the initial configuration of the ATM\n• If 〈q, σ′〉 ∈ T and g(q) = ∀, then all successor configurations of 〈q, σ′〉 are in T\n• If 〈q, σ′〉 ∈ T , q is existential, and 〈q, σ′〉 is n-accepting, then there exists at least one successor configuration of 〈q, σ′〉 that is in T and is m-accepting for some m < n.\nA Deterministic Turing Machine (DTM) is an ATM without universal states, and such that |δ(q, s)| = 1 for all q ∈ Q and s ∈ Σ∪{|}. EXPTIME is the class of decision problems that can be solved by DTMs that use a number of tape cells bounded by an exponential on the input length n. APSPACE is the class of decision problems that can be solved by ATMs that use a number of tape cells bounded by a polynomial on the input length n. It is well-known that EXPTIME = APSPACE [24].\n2.2. Finite LTL\nFinite LTL, or LTLf , is a variant of LTL interpreted over finite traces. The syntax of finite LTL differs only slightly from standard LTL, save the addition of a “weak next” operator (). The definition follows.\nDefinition 5 (LTLf formulas) The set of LTLf formulas over a set of propositions P, LTLf(P), is inductively defined as follows:\n• >, ⊥, and p are in LTLf(P), for every p ∈ P.\n• If ϕ and ψ are in LTLf(P) then so are ¬ϕ, (ϕ ∧ ψ), (ϕ ∨ ψ), ϕ, ϕ, (ϕUψ), and (ϕRψ).\nThe standard LTL operators eventually () and always () are defined as macros ϕ ≡ (>Uϕ) and ϕ ≡ (⊥Rϕ). As usual, > evaluates to true and ⊥ evaluates to false.\nDefinition 6 (Subformulas of an LTLf Formula) Given a formula ϕ over a set of propositions P, we define the set of subformulae of ϕ, denoted sub(ϕ), inductively as follows.\n1. If ϕ is a proposition in P, then sub(ϕ) = {ϕ}. 2. If ϕ = ?ψ, where ? is a unary connective in {¬,,}, then sub(ϕ) = {ϕ}∪ sub(ψ). 3. If ϕ = (ψ ∗ χ) where ∗ is any binary connective in {∧,∨,U,R} then sub(ϕ) = {ϕ} ∪ sub(ψ) ∪ sub(χ).\nFinally, the size of a formula ϕ, denoted by |ϕ|, is defined as the number of connectives in ϕ plus the number of atomic formulas in ϕ; thus the size of (p ∨ ¬p) is 4.\nProposition 1 The cardinality of sub(ϕ) is at most |ϕ|.\nProof: By induction on the construction of ϕ. The base case, that is, ϕ is a propositional variable, is straightforward. For the induction, if ϕ = ?ψ, for a unary connective ?, we observe that |sub(ϕ)| ≤ 1 + |sub(ψ)|, from where the results follows immediately by using the inductive hypothesis. The proof for binary connectives is analogous. If ϕ = (ψ ? χ), then |sub(ϕ)| ≤ 1 + |sub(ψ)|+ |sub(χ)|. In both cases, |sub(ϕ)| ≤ |ϕ|.\nThe truth of an LTLf formula over P is evaluated over a finite word of states, where each state is an element over alphabet 2P .\nDefinition 7 Given a finite word of states σ = s0 . . . sn, and a formula ϕ ∈ LTLf(P), we say that σ satisfies ϕ, denoted as σ |= ϕ, iff it holds that σ, 0 |= ϕ, where, for every i ∈ {0, . . . , n}:\n1. σ, i |= >. 2. σ, i |= p iff p ∈ si, when p ∈ P. 3. σ, i |= ¬ϕ iff σ, i 6|= ϕ 4. σ, i |= (ψ ∧ χ) iff σ, i |= ψ and σ, i |= χ 5. σ, i |= (ψ ∨ χ) iff σ, i |= ψ or σ, i |= χ 6. σ, i |= ψ iff i < n and σ, (i+ 1) |= ψ 7. σ, i |= ψ iff i = n or σ, (i+ 1) |= ψ 8. σ, i |= (ψUχ) iff there exists k ∈ {i, ..., n} such that σ, k |= χ and for each j ∈ {i, ..., k − 1}, it holds that σ, j |= ψ 9. σ, i |= (ψ Rχ) iff for each k ∈ {i, ..., n} it holds that σ, k |= χ or there exists a j ∈ {i, ..., k − 1} such that σ, j |= ψ\n2.3. An Alternating Automaton for LTLf\nWe present Torres and Baier’s construction of alternating automata from LTLf formulae [22]. Given an LTLf formula ϕ, this construction defines an alternating automaton Aϕ that accepts precisely the models of ϕ. We commence with some definitions and then present the construction."
    }, {
      "heading" : "2.3.1. Alternating Automata",
      "text" : "Definition 8 (Positive Boolean Formula) The set of positive formulae over a set of propositions P—denoted by B+(P)—is the set of all Boolean formulae over P and constants ⊥ and > that do not use the connective “¬”.\nDefinition 9 (Alternating Automata) An alternating automata (AA) over words is a tuple A = (Q,Σ, δ, I,F), where Q is a finite set of states, the alphabet Σ is a finite set of symbols, δ : Q × Σ → B+(Q) is the transition function, I ⊆ Q are the initial states, and F ⊆ Q is a set of final states.\nFor a set of states Q′ ⊆ Q, we define δ(Q′, s) def= ∧ q∈Q′ δ(q, s). In what follows, a word\nis an ordered finite sequence x1, x2, . . . , xn of symbols in Σ.\nDefinition 10 (Run of an AA over a Finite String) A run of an AA A = (Q,Σ, δ, I,F) over word x1x2 . . . xn is a sequence Q0Q1 . . . Qn of subsets of Q, where Q0 = I, and Qi |= δ(Qi−1, xi), for every i ∈ {1, . . . , n}.\nDefinition 11 A word w is accepted by an AA, A, iff there is a run Q0 . . . Qn of A over w such that Qn ⊆ F .\nFor example, if the definition of an AA, A, is such that δ(q, b) = (s∧t)∨r, and I = {q}, then both {q}{s, t} and {q}{r} are runs of A over word b."
    }, {
      "heading" : "2.3.2. Torres and Baier’s Automaton",
      "text" : "Given a formula ψ in LTLf(P), the first step is to convert it into an equivalent formula, ϕ, in negation normal form (NNF). NNF is a form in which negations, if any, are applied only over propositional variables. This can be done in linear time by applying successively the substitutions given by ¬(α ∧ β) ≡ (¬α ∨ ¬β), ¬(α ∨ β) ≡ (¬α ∧ ¬β), ¬α ≡ ¬α, ¬(αUβ) ≡ (¬αR¬β), ¬α ≡ ¬α. Henceforth we assume that all LTL formulae are in NNF.\nFor a formula ϕ Torres and Baier’s automaton is a tuple Aϕ = (Q, 2 P , δ, qϕ, {qF }),\nwhere Q = {α | α ∈ sub(ϕ)} ∪ {qF } and:\nδ(`, s) = { >, if ` is a literal over P and s |= ` ⊥, if ` is a literal over P and s 6|= `\nδ(qF , s) = ⊥ δ(α ∨ β, s) = δ(α, s) ∨ δ(β, s) δ(α ∧ β, s) = δ(α, s) ∧ δ(β, s) δ(α, s) = α\nδ(α, s) = qF ∨ α δ(αUβ, s) = δ(β, s) ∨ (δ(α, s) ∧ αUβ) δ(αRβ, s) = δ(β, s) ∧ (qF ∨ δ(α, s) ∨ αRβ)\nThis AA is based on Muller et al.’s AA for infinite [25]. Unlike theirs, this AA has a state qF , which, besides from being a final state, has the intuitive meaning of “forcing the input to finish now”. Indeed, when the automaton is in qF , processing any input symbol gets the automaton into a rejection configuration.\nTheorem 1 (Correctness of Aϕ [22]) σ |= ϕ iff Aϕ accepts σ.\n3. LTLf Synthesis\nLTL synthesis is a 2EXPTIME-complete problem. In this section, we introduce the problem of LTLf synthesis. The community has assumed that LTLf synthesis was a 2EXPTIMEcomplete problem [21]. We prove that, contrary to the common thought, LTLf synthesis is an EXPTIME-hard problem.\nDefinition 12 (LTLf Realizability) Given two disjoint sets of variables X and Y, and a formula ϕ over LTLf(X ∪ Y), we say that ϕ is realizable iff there exists a function f : (2X )∗ → 2Y such that for every infinite word X1X2 . . . over subsets of X , there exists a natural n such that when π = (X1 ∪ f(X1))(X2 ∪ f(X2X1)) . . . (Xn ∪ f(XnXn−1 . . . X1)), it holds that π |= ϕ.\nLemma 1 LTLf realizability is in EXPTIME.\nProof: Algorithm 1 defines an alternating, non-deterministic procedure where Realizable({ϕ}) accepts iff ϕ is realizable. Moreover, as we show below, it requires memory that is linear in |ϕ|. This proves that the problem is in APSPACE, the class of problems that can be decided with an ATM that requires polynomial space on its input. In addition, because APSPACE=EXPTIME [24], we conclude that LTLf realizability is in EXPTIME.\nAlgorithm 1: An Algorithm for Deciding Realizability 1 procedure Realizable(Q) 2 if Q ⊆ {qF } then 3 accept 4 if qF ∈ Q then 5 reject 6 forall subsets X of X do 7 guess a subset Y of Y do 8 s← X ∪ Y 9 Progress(Q, ∅, s)\n10 procedure Progress(Qold,Qnew, s) 11 if Qold = ∅ then 12 Realizable(Qnew) 13 Remove a formula ϕ from Qold (different from qF ) 14 switch ϕ do 15 case ϕ is a literal 16 if s 6|= ϕ then 17 reject\n18 case ϕ is of the form α ∨ β 19 choose 20 either Progress(Qold ∪ {α},Qnew, s) 21 or Progress(Qold ∪ {β},Qnew, s)\n22 case ϕ is of the form α ∧ β 23 Progress(Qold ∪ {α, β},Qnew, s) 24 case ϕ is of the form α 25 Progress(Qold,Qnew ∪ {α}, s) 26 case ϕ is of the form α 27 choose 28 either Progress(Qold,Qnew ∪ {qF }, s) 29 or Progress(Qold,Qnew ∪ {α}, s)\n30 case ϕ is of the form αUβ 31 choose 32 either Progress(Qold ∪ {β},Qnew, s) 33 or Progress(Qold ∪ {α},Qnew ∪ {αUβ}, s)\n34 case ϕ is of the form αRβ 35 Qold ← Qold ∪ {β} 36 choose 37 either Progress(Qold,Qnew ∪ {qF }, s) 38 or Progress(Qold ∪ {α},Qnew, s) 39 or Progress(Qold,Qnew ∪ {αRβ}, s)\nBefore continuing with the proof, we provide some intuition for both procedures. Let us first denote the set of infinite words over alphabet 2X by W∞. The objective of the algorithm is to prove that for every infinite word w = X1X2 . . . ∈ W∞, there exists a finite word Y1Y2 . . . Yn over alphabet 2\nY such that when π = (X1∪Y1)(X2∪Y2) . . . (XN(w)∪YN(w)), where N is a function from W∞ to the natural numbers, it holds that π |= ϕ. To prove this, via successive calls, the recursive algorithm Realizable attempts to compute an accepting run Q0Q1 . . . QN(w) of the automaton Aϕ for each possible w ∈ W∞, by guessing sets Y0Y1 . . . YN(w). In the k-th recursive call, as we prove below, the set of states Q used as the argument for the procedure corresponds to Qk.\nIn each call to Realizable, both variables for X and Y are chosen non-deterministically (Lines 6 and 7). Observe, however, that variables from X are chosen using a universal transition. (In fact, Line 6 is the only universal transition in the algorithm.) Once state s is built, the algorithm invokes procedure Progress.\nProcedure Progress is also a recursive procedure whose objective is to build the next set of states that conforms to a run (that is, it computes Qk+1 given Qk and the (k+ 1)-th symbol of the input string). To do this it uses two arguments: Qold and Qnew. The former set represents the set of states Aϕ is in before processing symbol s. The latter is the new set of states. Through multiple iterations, Progress builds Qnew and yields the control back to Realizable when Qold is empty (Line 12).\nNow we argue that the algorithm we propose is correct, that is, it accepts iff ϕ is realizable. We start by arguing that Progress is correct. Specifically we prove that if Progress is called in Line 9 with Q as the first argument and s as the third argument, and, after a number of self-recursive calls of Progress, the next call to Realizable in Line 12 is made with argument Q′, then Q′ |= δ(Q, s). This follows from the fact that Progress adds to Qnew precisely the formulae that are added in a branch of a Tableaux proof tree for the formula δ(Q, s). In the successive calls for Progress when Qold is empty, Qnew thus contains a model of the formula δ(Q, s). Observe also that a Progress call never reaches Line 12 and rejects: if the Tableaux proof tree branch would have added ⊥ to the Tableaux set, it would mean that there is no model for the formula.\nNow we prove that Realizable is correct too, that is, it accepts iff ϕ is realizable. For the ⇒ direction, assume Realizable accepts. Then the accepting run of Realizable can be conceptualized as a finite tree, as shown in Figure 1, which every internal node has one children for each element of 2X . Each of these sets is accompanied by an element of 2Y . Thus each branch of the tree of length n defines words X1X2 . . . Xn and Y1Y2 . . . Yn, respectively in (2X )∗ and (2Y)∗, together with a sequence Q0Q1 . . . Qn of sets of states of Aϕ, such that Q0 = {ϕ} and Qk+1 |= δ(Qk, s), for every k ∈ {0, . . . , n − 1}, and such that Qn ⊆ {qF }. From the correctness of the automaton, this means that (X1 ∪ Y1)(X2 ∪ Y2) . . . (Xn ∪ Yn) |= ϕ. Finally, it only remains to define function f : for every path of the tree labeled with (X1, Y1)(X2, Y2) . . . (Xm, Ym), we define f(Xm . . . X1) = Ym. This proves that ϕ is realizable since for every infinite word wX in 2\nX there is a branch in the tree that defines a (finite) prefix of wX .\nFor the ⇐ direction, recall we denote the set of infinite words over alphabet 2X as W∞. Because ϕ is realizable, for each w = X1X2 . . . in W∞ there exists a finite word Y1 . . . YN(w) in (2\nY)∗ such that (X1 ∪ Y1) . . . (XN(w) ∪ YN(w)) |= ϕ, where N is a function from words inW∞ to the natural numbers. This means that to prove realizability, we only need to check a (finite) number of finite words rather than over all words in W∞; in fact, we need to check at most all words in (2X )∗ whose size is bounded by maxw∈W∞ N(w). In other words, this means that for each infinite word w in W∞, there is a prefix of w that is sufficient to characterize all words in W∞ that share the same prefix. Then it is clear that if one can provide a finite proof for realizability, it is possible to represent this proof as a finite tree, analogous to the one shown Figure 1. This means that Realizable({ϕ}) will accept.\nWe have proven that Realizable({ϕ}) accepts iff ϕ is realizable. Now it remains to prove that a call to Realizable({ϕ}) requires only polynomial memory on |ϕ|. Clearly, all operations in the Progress procedure require polynomial space. To see this, observe that the cardinality of bothQold andQnew is at most |sub(ϕ)|+1. This implies that Realizable requires memory linear in ϕ to store its Q argument. Moreover, the other operations in Realizable, namely the forall and guess can be implemented in polynomial space by choosing, in sequence, whether or not each variable is included in the set X.\nWe conclude that LTLf realizability can be decided in APSPACE and thus that it is in EXPTIME.\nLemma 2 LTLf realizability is EXPTIME-hard.\nProof: We show that LTLf synthesis is at least as hard as the problem of deciding plan existence in ATMs with a polynomial space bound p(x) on the size of the input string. We do so by introducing a polynomial time transformation, similar to the one used by Rintanen to prove that non-deterministic planning with partial observability is 2EXPTIME-hard [23].\nFirst, we describe the transformation from a given ATM A = 〈Σ, Q, δ, q0, g〉 with input string σ = s1, . . . , sn – therefore, space bound p(n) – to an LTLf synthesis specification. Finally, we show that accepting ATM computation trees correspond one-to-one with solutions to the LTLf synthesis problem.\nControllable Variables The set of controllable variables in the LTLf synthesis problem consists of the following sets:\n• {vq | q ∈ Q}, denoting the internal state of the ATM\n• {vs,i | s ∈ Σ ∪ {|, } and i ∈ {0, . . . , p(n)}}, denoting the state of each tape cell\n• {vi | i ∈ {0, . . . , p(n) + 1}}, denoting the position of the R/W head\n• Z = {z1, z2, . . . , z∆}, where ∆ = max{|δ(s, q)| , s.t. s ∈ Σ ∪ {|, }, q ∈ Q}\nThe value of these variables simulate the configuration of the ATM. Intuitively, vq is true when the internal state of A is q, vs,i is true when the value in the i-th tape cell is s, and vi is true when the R/W head is over the i-th tape cell. The values of variables in Z are used to uniquely identify one of the successor configurations of the ATM when the internal state is existential.\nUncontrollable Variables The set of uncontrollable variables is X = {x1, x2, . . . , x∆}. For convenience, we define the formulae evalX(i, k) as follows:\nevalX(i, k) =  xi ∧ ∧ j=1..i−1 ¬xj if i < k∧\nj=1..i−1 ¬xj if i = k undefined if i > k\nIntuitively, evalX(i, k) evaluates true when i is the lowest index of the first k variables in X that evaluates true. evalX(k, k) also evaluates true when none of the first k variables in X evaluates true. We will use the truth of these formulae to distinguish one among k possible transitions. For the set of controllable variables Z, evalZ(i, k) is defined analogously. Initial Configuration Let C = 〈q′, σl, σr〉 be a configuration of the ATM A, where the internal state is q′, the values in the tape cells are s0, . . . , sp(n), and the R/W head is over sj . We simulate configuration C with the formula:\nϕC = ∧ VQ ∧ ∧ VS ∧ ∧ VH (1)\nThe sets of variables that constitute each of the subformulas in ϕC are defined as follows:\n• VQ = {vq′} ∪ {¬vq | q ∈ Q \\ {q′}}\n• VS = {vs,i | s ∈ Σ ∪ {|, }, si ∈ σ′, si = s} ∪ {¬vs,i | s ∈ Σ ∪ {|, }, si ∈ σ′, si 6= s}\n• VH = {vj} ∪ {¬vi | i ∈ {0, 1, . . . , p(n) + 1}, i 6= j}\nIn order to simulate the initial configuration of the ATM with input string σ = s1, . . . , sn, we consider the formula ϕC with C = 〈q0, σl, σr〉 as follows. The R/W head is placed over s1, so σl = |s1. The values of the remaining tape cells are σr = s2 . . . sp(n). Here, we set si = for n < i < p(n) + 1, as the value of the tape cells in positions greater than n are initially blank cells. Note that the value of controllable variables Z is not set.\nGoal Configuration The goal configuration of the ATM is captured in Formula (2), which simulates achievement of an accepting state of the ATM.\n ∨ q∈Q\ng(q)=accept\nvq (2)\nTransitions For all s ∈ Σ ∪ {|, } and q ∈ Q, the transition function δ maps the pair 〈s, q〉 into a set of tuples δ(s, q) = {〈s′1, q′1,m1〉, . . . , 〈s′k, q′k,mk〉}, where s′ ∈ Σ∪{|}, q′ ∈ Q, and m ∈ {L,R,N}. Let α, κ, and θ be functions such that, for each 〈s′ρ, q′ρ,mρ〉 ∈ δ(s, q), we have s′ρ = α(s, q, ρ), q ′ ρ = κ(s, q, ρ), and mρ = θ(s, q, ρ) for ρ = 1..|δ(s, q)|, and undefined for ρ > |δ(s, q)|. The successor configurations of the ATM are captured with the families of LTLf formulae described below. Each family of formulae can be viewed as successor state axioms [26], that describe the updates in the value of each variable after each time step. For each q ∈ Q such that g(q) = ∃, and each s ∈ Σ ∪ {|, }:∧\nj=1..p(n)+1\n(vs′,j ←→ ∨\ni=1..p(n) i 6=j\n(vs′,j ∧ vi ∧ ¬vj)∨\n∨ ρ=1..|δ(s,q)|\ns s.t. s′=α(s,q,ρ)\n(vs,j ∧ vj ∧ vq ∧ evalZ(ρ, |δ(s, q)|))) (3)\n(vq′ ←→ ∨\ni=1..p(n) ρ=1..|δ(s,q)|\nq s.t. q′=κ(s,q,ρ)\n(vs,i ∧ vi ∧ vq ∧ evalZ(ρ, |δ(s, q)|))) (4)\n∧ j=1..p(n)+1 (vj ←→ ∨\nρ=1..|δ(s,q)| θ(s,q,ρ)=L\ni=j+1,i≤p(n)+1\n(vs,i ∧ vi ∧ vq ∧ evalZ(ρ, |δ(s, q)|)))∨\n∨ ρ=1..|δ(s,q)| θ(s,q,ρ)=R i=j−1,i>0 (vs,i ∧ vi ∧ vq ∧ evalZ(ρ, |δ(s, q)|)))∨\n∨ ρ=1..|δ(s,q)| θ(s,q,ρ)=N\ni=j\n(vs,i ∧ vi ∧ vq ∧ evalZ(ρ, |δ(s, q)|)))\n(5)\nFor each q ∈ Q such that g(q) = ∀, and each s ∈ Σ ∪ {|, }:∧ j=1..p(n)+1 (vs′,j ←→ ∨\ni=1..p(n) i 6=j\n(vs′,j ∧ vi ∧ ¬vj)∨\n∨ ρ=1..|δ(s,q)|\ns s.t. s′=α(s,q,ρ)\n(vs,j ∧ vj ∧ vq ∧ evalX(ρ, |δ(s, q)|))) (6)\n(vq′ ←→ ∨\ni=1..p(n) ρ=1..|δ(s,q)|\nq s.t. q′=κ(s,q,ρ)\n(vs,i ∧ vi ∧ vq ∧ evalX(ρ, |δ(s, q)|))) (7)\n∧ j=1..p(n)+1 (vj ←→ ∨\nρ=1..|δ(s,q)| θ(s,q,ρ)=L\ni=j+1,i≤p(n)+1\n(vs,i ∧ vi ∧ vq ∧ evalX(ρ, |δ(s, q)|)))∨\n∨ ρ=1..|δ(s,q)| θ(s,q,ρ)=R i=j−1,i>0 (vs,i ∧ vi ∧ vq ∧ evalX(ρ, |δ(s, q)|)))∨\n∨ ρ=1..|δ(s,q)| θ(s,q,ρ)=N\ni=j\n(vs,i ∧ vi ∧ vq ∧ evalX(ρ, |δ(s, q)|)))\n(8)\nIntuitively, the family of formulae in (3) simulate the update of the value in the tape cell under the R/W head according to one of the successor configurations of the ATM. Similarly, the family of formulae in (4) simulate the update of the internal state of the ATM. Finally, the family of formulae in (5) simulate the update of the position of the R/W head over the cell tapes of the ATM. In all cases, the selection of a particular successor configuration is simulated by evalZ(s, q), which depends on the value of the variables in Z. The families of Formulae (6), (7), and (8) are analogous. This time, q is an universal state and all successor\nconfigurations of the ATM are plausible and need to be considered. This is simulated by means of evalX(s, q), whose truth value depends on the set of uncontrollable variables X.\nMemory bounds The formulae above simulate the transitions of the ATM, but do not guarantee the memory bounds are preserved. The memory bound is maintained if the R/W head never reaches the position p(n) + 1. We simulate this requirement with the following formula:\n¬vp(n)+1 (9)\nFor a configuration C of ATM A, we consider the synthesis problem synth(A, C) whose specification is given by the conjunction of all formulae defined above. In particular, Formula (1) is such that simulates configuration C. Such transformation can be computed in polynomial time. We claim that if the ATM A with input string σ accepts without violating the space bound, then the associated LTLf synthesis problem also has a solution, and vice-versa.\nThe first implication we prove is, that from a computation tree of a t-accepting configuration C of an ATM A = 〈Σ, Q, δ, q0, g〉 we can extract a solution for the LTLf synthesis problem synth(A, C). We prove it via induction on t. If t = 0, then g(q′0) = accept and, by construction, the initial state of synth(A,C) is accepting. For the general case, we distinguish two cases:\n• If g(q′0) = ∃, then let 〈s′ρ, q′ρ,mρ〉 ∈ δ(sj , q′0) be a transition that leads to a successor configuration in the ATM computation tree that is (t− 1)-accepting. Let Z0 be the assignment of variables in Z that satisfy evalZ(ρ, |δ(sj , q′0)|). The first assignment to controllable variables in synth(A, C) assigns Z0 to variables in Z. The values of the remaining controllable variables simulate the configuration C of the ATM.\nLet C ′ be the successor configuration of C that is associated with transition 〈s′ρ, q′ρ,mρ〉 ∈ δ(sj , q ′ 0). Such configuration is (t−1)-accepting and, by inductive hypothesis, we can construct a solution to synth(A, C ′). It is easy to see that the assignment to controllable variables defined above, followed by the the solution strategy to synth(A, C ′) is a solution to synth(A, C).\n• If g(q′0) = ∀, then the first assignment to controllable variables in synth(A, C) assigns any value to variables in Z. As in the previous case, the value of the remaining controllable variables simulates the configuration C of the ATM.\nLet C ′ be the successor configuration of C that is associated with transition 〈s′ρ, q′ρ,mρ〉 ∈ δ(sj , q ′ 0). Such configuration is t\n′-accepting, for certain t′ < t and, by inductive hypothesis, we can construct a solution to synth(A, C ′). As in the previous case, the assignment to controllable variables defined above, followed by the the solution strategy to synth(A, C ′) is a solution to synth(A, C).\nFor the other direction, we first prove one of the contrapositives. If the ATM violates the space bounds p(n), then at some point the variable vp(n)+1 has to become true, representing that the R/W head moves to a tape cell position that violates the space bounds. At this point, the Formula (9) is not satisfied.\nIt remains to prove that from a solution to the LTLf synthesis problem synth(A, C0), where C0 is the initial configuration of the ATM A, we can construct a computation tree. This can be done by constructing the tree directly by unfolding a simulation of the LTLf synthesis problem. By construction, assignments to variables in the LTLf problem describe configurations of the ATM. Satisfaction of Formula (2) guarantees that the ATM is accepting.\nWe have shown that deciding whether or not an ATM with a polynomial space bound accepts can be converted to an LTLf synthesis problem in polynomial time. Therefore, existence of solutions to LTLf synthesis is APSPACE-hard or, equivalently, EXPTIMEhard.\nTheorem 2 LTLf realizability is EXPTIME-complete.\nProof: Follows directly from Lemmas 1 and 2."
    }, {
      "heading" : "4. Conclusion",
      "text" : "In this research note we have presented a proof that the synthesis problem with logical specification represented in LTLf , LTL interpreted over finite traces, is EXPTIME-complete. This result improves upon the 2EXPTIME-complete result reported in [21]. Our complexity result completes the landscape of complexity results that connect LTLf synthesis and non-deterministic planning. With full observability, LTLf synthesis and non-deterministic planning are EXPTIME-complete. With partial observability, LTLf synthesis and nondeterministic planning are 2EXPTIME-complete. This latter result was recently reported in [27].\nOur proofs leverage recent advances from the automated planning community. In particular, the algorithm used to prove EXPTIME membership in Lemma 1 is inspired by recent compilations based on alternating automata [22, 15]. Lemma 2 proves that LTLf synthesis is EXPTIME-hard, with a polynomial transformation of ATMs into LTLf specifications.\nAI automated planning with temporally extended goals specified in LTLf is a practically motivated task of broad interest. The synthesis problem is an extension of plan synthesis where aspects of state are uncontrollable by the agent’s actions, and the synthesized procedure must fulfill the specification regardless of how the uncontrollable aspects of state change. Like it’s automated planning counterpart, LTLf synthesis is well-motivated by myriad finite controller applications. Indeed, conditional planning with an LTLf goal\nis a special case of the synthesis problem that can be realized by LTLf FOND planning algorithms such as those proposed by the authors in related work [15]. The techniques developed in that work provide the computational core for the development of efficient algorithms for the realization of LTLf synthesis – a topic of current exploration. There is renewed interest to link planning and LTL synthesis, as demonstrated by Sardina and D’Ippolito where non-deterministic planning is modeled as a synthesis problem [28]. Our approach is complementary, as we leverage planning techniques to establish complexity results in synthesis.\nAcknowledgements: The authors gratefully acknowledge funding from Fondecyt (grant number 1150328), and from the Natural Sciences and Engineering Research Council of Canada (NSERC) under the Discovery Grant and Postdoctoral Fellowship programs."
    } ],
    "references" : [ {
      "title" : "Applications of recursive arithmetic to the problem of circuit synthesis",
      "author" : [ "A. Church" ],
      "venue" : "Summaries of the Summer Institute of Symbolic Logic, Cornell University 1957 1 ",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1957
    }, {
      "title" : "Logic",
      "author" : [ "A. Church" ],
      "venue" : "arithmetic and automata, in: Proceedings of the international congress of mathematicians, 23–35",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1962
    }, {
      "title" : "Y",
      "author" : [ "N. Piterman", "A. Pnueli" ],
      "venue" : "Sa’ar, Synthesis of Reactive(1) Designs, in: Verification, Model Checking, and Abstract Interpretation, 7th International Conference, VMCAI 2006, Charleston, SC, USA, January 8-10, 2006, Proceedings, 364–380",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Solving Sequential Conditions by Finite-State Strategies",
      "author" : [ "J.R. Büchi", "L.H. Landweber" ],
      "venue" : "Transactions of the American Mathematical Society 138 ",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 1969
    }, {
      "title" : "Automata on Infinite Objects and Church’s Problem",
      "author" : [ "M.O. Rabin" ],
      "venue" : "American Mathematical Society, Boston, MA, USA",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 1972
    }, {
      "title" : "The temporal logic of programs",
      "author" : [ "A. Pnueli" ],
      "venue" : "in: Proceedings of the 18th IEEE Symposium on Foundations of Computer Science, 46–57",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "On the Synthesis of a Reactive Module",
      "author" : [ "A. Pnueli", "R. Rosner" ],
      "venue" : "in: Conference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, Austin, Texas, USA, January 11-13, 1989, 179–190",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 1989
    }, {
      "title" : "Deterministic Generators and Games for LTL Fragments",
      "author" : [ "R. Alur", "S. La Torre" ],
      "venue" : "ACM Trans. Comput. Logic 5 (1) ",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Using temporal logics to express search control knowledge for planning",
      "author" : [ "F. Bacchus", "F. Kabanza" ],
      "venue" : "Artificial Intelligence 116 (1-2) ",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2000
    }, {
      "title" : "TALplanner: A Temporal Logic-Based Planner",
      "author" : [ "P. Doherty", "J. Kvarnström" ],
      "venue" : "AI Magazine 22 (3) ",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Compilation of LTL Goal Formulas into PDDL",
      "author" : [ "S. Cresswell", "A.M. Coddington" ],
      "venue" : "in: R. L. de Mántaras, L. Saitta (Eds.), Proceedings of the 16th European Conference on Artificial Intelligence, IOS Press, Valencia, Spain, 985–986",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Planning with First-Order Temporally Extended Goals using Heuristic Search",
      "author" : [ "J.A. Baier", "S.A. McIlraith" ],
      "venue" : "in: Proceedings, The Twenty-First National Conference on Artificial Intelligence and the Eighteenth Innovative Applications of Artificial Intelligence Conference, July 16-20, 2006, Boston, Massachusetts, USA, 788–795",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Planning with Qualitative Temporal Preferences",
      "author" : [ "M. Bienvenu", "C. Fritz", "S.A. McIlraith" ],
      "venue" : "in: Proceedings of the 10th International Conference on Knowledge Representation and Reasoning, 134–144",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "On the Compilation of Plan Constraints and Preferences",
      "author" : [ "S. Edelkamp" ],
      "venue" : "in: Proceedings of the 16th International Conference on Automated Planning and Scheduling, 374–377",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Non- Deterministic Planning with Temporally Extended Goals: Completing the Story for Finite and Infinite LTL (Amended Version)",
      "author" : [ "A. Camacho", "E. Triantafillou", "C.J. Muise", "J.A. Baier", "S.A. McIlraith" ],
      "venue" : "in: Proceedings of the Workshop on Knowledge-based Techniques for Problem Solving and Reasoning co-located with 25th International Joint Conference on Artificial Intelligence ",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Deterministic planning in the fifth international planning competition: PDDL3 and experimental evaluation of the planners",
      "author" : [ "A. Gerevini", "P. Haslum", "D. Long", "A. Saetti", "Y. Dimopoulos" ],
      "venue" : "Artificial Intelligence 173 (5-6) ",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Linear Temporal Logic and Linear Dynamic Logic on Finite Traces",
      "author" : [ "G. De Giacomo", "M.Y. Vardi" ],
      "venue" : "in: Proceedings of the 23rd International Joint Conference on Artificial Intelligence, Beijing, China, 854–860",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Reasoning on LTL on Finite Traces: Insensitivity to Infiniteness",
      "author" : [ "G. De Giacomo", "R.D. Masellis", "M. Montali" ],
      "venue" : "in: Proceedings of the 28th AAAI Conference on Artificial Intelligence, 1027–1033",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Semantic Web Services",
      "author" : [ "S.A. McIlraith", "T.C. Son", "H. Zeng" ],
      "venue" : "IEEE Intelligent Systems 16 (2) ",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "Monitoring Business Metaconstraints Based on LTL and LDL for Finite Traces",
      "author" : [ "G. De Giacomo", "R. De Masellis", "M. Grasso", "F.M. Maggi", "M. Montali" ],
      "venue" : "in: Business Pro- 18  cess Management - 12th International Conference, BPM 2014, Haifa, Israel, September 7-11, 2014. Proceedings, 1–17",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Synthesis for LTL and LDL on Finite Traces",
      "author" : [ "G. De Giacomo", "M.Y. Vardi" ],
      "venue" : "in: Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence, 1558–1564",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Polynomial-Time Reformulations of LTL Temporally Extended Goals into Final-State Goals",
      "author" : [ "J. Torres", "J.A. Baier" ],
      "venue" : "in: Q. Yang, M. Wooldridge (Eds.), International Joint Conference on Artificial Intelligence, AAAI Press, Buenos Aires, Argentina, 1696– 1703",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "Complexity of Planning with Partial Observability",
      "author" : [ "J. Rintanen" ],
      "venue" : "in: Proceedings of the 14th International Conference on Automated Planning and Scheduling, 345–354",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Alternation",
      "author" : [ "A.K. Chandra", "D. Kozen", "L.J. Stockmeyer" ],
      "venue" : "Journal of the ACM 28 (1) ",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 1981
    }, {
      "title" : "Weak Alternating Automata Give a Simple Explanation of Why Most Temporal and Dynamic Logics are Decidable in Exponential Time",
      "author" : [ "D.E. Muller", "A. Saoudi", "P.E. Schupp" ],
      "venue" : "in: Proceedings of the 3rd Annual Symposium on Logic in Computer Science, 422–427",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 1988
    }, {
      "title" : "Knowledge in Action: Logical Foundations for Specifying and Implementing Dynamical Systems",
      "author" : [ "R. Reiter" ],
      "venue" : "MIT Press, Cambridge, MA",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2001
    }, {
      "title" : "LTLf and LDLf Synthesis under Partial Observability",
      "author" : [ "G. De Giacomo", "M.Y. Vardi" ],
      "venue" : "in: Proceedings of the 25th International Joint Conference on Artificial Intelligence, 1044–1050",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "N",
      "author" : [ "S. Sardina" ],
      "venue" : "D’Ippolito, Towards Fully Observable Non-deterministic Planning as Assumption-based Reactive Synthesis, in: Proceedings of the International Joint Conference on Artificial Intelligence (IJCAI), 3200–3206",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "by Church in 1957 in the context of synthesizing digital circuits from a logical specification [1, 2] and is considered one of the most challenging problems in reactive systems [3].",
      "startOffset" : 95,
      "endOffset" : 101
    }, {
      "referenceID" : 1,
      "context" : "by Church in 1957 in the context of synthesizing digital circuits from a logical specification [1, 2] and is considered one of the most challenging problems in reactive systems [3].",
      "startOffset" : 95,
      "endOffset" : 101
    }, {
      "referenceID" : 2,
      "context" : "by Church in 1957 in the context of synthesizing digital circuits from a logical specification [1, 2] and is considered one of the most challenging problems in reactive systems [3].",
      "startOffset" : 177,
      "endOffset" : 180
    }, {
      "referenceID" : 3,
      "context" : "Büchi and Landweber first solved the problem in 1969 [4].",
      "startOffset" : 53,
      "endOffset" : 56
    }, {
      "referenceID" : 4,
      "context" : "Soon after, Rabin proposed a solution exploiting automata on infinite trees [5].",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 5,
      "context" : "In 1989, Pnueli and Rosner examined the problem of reactive synthesis using Linear Temporal Logic (LTL) [6] as the specification language, viewing the problem as a two-player game, and showing that this problem was 2EXPTIME-complete [7].",
      "startOffset" : 104,
      "endOffset" : 107
    }, {
      "referenceID" : 6,
      "context" : "In 1989, Pnueli and Rosner examined the problem of reactive synthesis using Linear Temporal Logic (LTL) [6] as the specification language, viewing the problem as a two-player game, and showing that this problem was 2EXPTIME-complete [7].",
      "startOffset" : 233,
      "endOffset" : 236
    }, {
      "referenceID" : 7,
      "context" : "In 2004, Alur and La Torre also identified what they argued to be a compelling fragment of LTL that restricts to Boolean combinations of either (,∧) or (,∧,∨), proving that the synthesis problem was PSPACE-complete or EXPSPACE, respectively, utilizing a parameterization in terms of the so-called longest distance (length of the longest simple path in the Büchi automaton) [8].",
      "startOffset" : 375,
      "endOffset" : 378
    }, {
      "referenceID" : 2,
      "context" : "Further, in 2006, Piterman, Pnueli, and Sa’ar examined the synthesis of reactive designs when the LTL specification was restricted to the class of so-called Generalized Reactivity(1) (GR1) formulae, presenting an N3-time algorithm which checks whether the formula is realizable, and in the case where it is, constructs an automaton representing one of the possible implementing circuits [3].",
      "startOffset" : 387,
      "endOffset" : 390
    }, {
      "referenceID" : 8,
      "context" : ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.",
      "startOffset" : 2,
      "endOffset" : 25
    }, {
      "referenceID" : 9,
      "context" : ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.",
      "startOffset" : 2,
      "endOffset" : 25
    }, {
      "referenceID" : 10,
      "context" : ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.",
      "startOffset" : 2,
      "endOffset" : 25
    }, {
      "referenceID" : 11,
      "context" : ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.",
      "startOffset" : 2,
      "endOffset" : 25
    }, {
      "referenceID" : 12,
      "context" : ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.",
      "startOffset" : 2,
      "endOffset" : 25
    }, {
      "referenceID" : 13,
      "context" : ", [9, 10, 11, 12, 13, 14]) and more recently for Fully Observable Non-Deterministic Planning (FOND) problems, where actions have non-deterministic effects (e.",
      "startOffset" : 2,
      "endOffset" : 25
    }, {
      "referenceID" : 14,
      "context" : ", [15]).",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 15,
      "context" : ", [16, 17, 18]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 16,
      "context" : ", [16, 17, 18]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 17,
      "context" : ", [16, 17, 18]).",
      "startOffset" : 2,
      "endOffset" : 14
    }, {
      "referenceID" : 18,
      "context" : ", [19, 20]).",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 19,
      "context" : ", [19, 20]).",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 20,
      "context" : "Indeed, LTLf is used extensively in business process specifications [21].",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 21,
      "context" : "Next, we briefly describe a technique by the Torres and Baier’s for translating LTLf into alternating automata that has been used in support of automated plan generation with LTLf temporally extended goals [22].",
      "startOffset" : 206,
      "endOffset" : 210
    }, {
      "referenceID" : 22,
      "context" : "The technique we use transforms an alternating Turing machine into LTLf synthesis, and gains some inspiration from methods used by Rintanen to prove the complexity of non-deterministic planning with full and partial observability [23].",
      "startOffset" : 230,
      "endOffset" : 234
    }, {
      "referenceID" : 23,
      "context" : "It is well-known that EXPTIME = APSPACE [24].",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 21,
      "context" : "An Alternating Automaton for LTLf We present Torres and Baier’s construction of alternating automata from LTLf formulae [22].",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 24,
      "context" : "’s AA for infinite [25].",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 21,
      "context" : "Theorem 1 (Correctness of Aφ [22]) σ |= φ iff Aφ accepts σ.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 20,
      "context" : "The community has assumed that LTLf synthesis was a 2EXPTIMEcomplete problem [21].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 23,
      "context" : "In addition, because APSPACE=EXPTIME [24], we conclude that LTLf realizability is in EXPTIME.",
      "startOffset" : 37,
      "endOffset" : 41
    }, {
      "referenceID" : 22,
      "context" : "We do so by introducing a polynomial time transformation, similar to the one used by Rintanen to prove that non-deterministic planning with partial observability is 2EXPTIME-hard [23].",
      "startOffset" : 179,
      "endOffset" : 183
    }, {
      "referenceID" : 25,
      "context" : "Each family of formulae can be viewed as successor state axioms [26], that describe the updates in the value of each variable after each time step.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 20,
      "context" : "This result improves upon the 2EXPTIME-complete result reported in [21].",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 26,
      "context" : "This latter result was recently reported in [27].",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 21,
      "context" : "In particular, the algorithm used to prove EXPTIME membership in Lemma 1 is inspired by recent compilations based on alternating automata [22, 15].",
      "startOffset" : 138,
      "endOffset" : 146
    }, {
      "referenceID" : 14,
      "context" : "In particular, the algorithm used to prove EXPTIME membership in Lemma 1 is inspired by recent compilations based on alternating automata [22, 15].",
      "startOffset" : 138,
      "endOffset" : 146
    }, {
      "referenceID" : 14,
      "context" : "is a special case of the synthesis problem that can be realized by LTLf FOND planning algorithms such as those proposed by the authors in related work [15].",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 27,
      "context" : "There is renewed interest to link planning and LTL synthesis, as demonstrated by Sardina and D’Ippolito where non-deterministic planning is modeled as a synthesis problem [28].",
      "startOffset" : 171,
      "endOffset" : 175
    } ],
    "year" : 2017,
    "abstractText" : "LTL synthesis – the construction of a function to satisfy a logical specification formulated in Linear Temporal Logic – is a 2EXPTIME-complete problem with relevant applications in controller synthesis and a myriad of artificial intelligence applications. In this research note we consider De Giacomo and Vardi’s variant of the synthesis problem for LTL formulas interpreted over finite rather than infinite traces. Rather surprisingly, given the existing claims on complexity, we establish that LTL synthesis is EXPTIME-complete for the finite interpretation, and not 2EXPTIME-complete as previously reported. Our result coincides nicely with the planning perspective where non-deterministic planning with full observability is EXPTIME-complete and partial observability increases the complexity to 2EXPTIME-complete; a recent related result for LTL synthesis shows that in the finite case with partial observability, the problem is 2EXPTIME-complete.",
    "creator" : "LaTeX with hyperref package"
  }
}