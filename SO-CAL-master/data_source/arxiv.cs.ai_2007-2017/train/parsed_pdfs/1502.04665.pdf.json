{
  "name" : "1502.04665.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Optimizations for Decision Making and Planning in Description Logic Based Dynamic Knowledge Bases",
    "authors" : [ "Michele Stawowy" ],
    "emails" : [ "michele.stawowy@imtlucca.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 2.\n04 66\n5v 1\n[ cs\n.A I]\n1 6\nFe b\n20 15"
    }, {
      "heading" : "1 Introduction",
      "text" : "Classically, management of business processes always focused on the workflows and the actions/interactions that take part in them, an approach called process-centric. One of the most prominent operations related to business processes is planning [Ghallab et al., 2004], namely finding a sequence of operations/actions that allows to reach a desired goal. Lately, such approach has been call into question under two different aspects. First, the sole focus on the workflow leaves out the informational context in which the workflow is executed. Secondly, the traditional imperative approach to define workflows turns out to be too rigid, burdened by over-specified constrains, while in reality the actors (e.g., the humans that execute the workflow) may still be able to break them while still reaching the prefixed goal. This last point could be also applied to planning, as in general its scope is to find only the first valid plan to reach a goal, while agents might execute others (we can’t consider all possible real-life conditions).\nArtifact-centric models for business processes recently raised a lot of attention [Bhattacharya et al., 2007; Cohn and Hull, 2009], as they manage to combine structural (i.e. data related) with dynamical (i.e. process related)\naspects in a seamless way, thus overcoming the limits of process-centric approach. In this context, we can see the development of the framework called Knowledge and Actions Bases [Hariri et al., 2013], the later higher formalization of it named Description Logic Based Dynamic Systems [Calvanese et al., 2013], and the Golog-based work of [Baader and Zarrieß, 2013]. These works all share the same concept: handle the data-layer through a Description Logic ontology, while the process-layer, since DLs are only able to give a static representation of the domain of interest, is defined as actions that update the ontology (the so-called “functional view of knowledge bases” [Levesque, 1984]). The combination of these two elements generates a transition system, in which states are represented by DL knowledge bases. They do also share a similar objective: verification of temporal formulas over the afore-mentioned transition system. Since finding a path that lead to a goal state can be expressed as a reachability temporal formula, these environments can be used as planners.\nArtifact-centric models developed in parallel with declarative approaches for modelling processes [Pesic and Van Der Aalst, 2006; Montali et al., 2010], where activities try to adapt the internal system to the humans involved and the input they receive. Following such idea, we think that also the traditional planning function could be changed: finding only one plan might be too restrictive, especially if we consider that capturing all the real-life aspects that could influence the building of the plan is, in general, very difficult if not impossible. We treat the planner as a stage in a decision-making tool-chain: we expect the planning phase to produce all the plans that can be considered relevant to the goal, which are then fed to the following stages for further refinements. Since the relevance of a plan might not be expressible as a temporal formula or common heuristic function, it would pose some problems in the previous frameworks. From their definition, we are limited to explore the state-space in a forward manner (we could end up having to explore the full state-space) and only by using the full body of the available knowledge.\nIn this paper we propose a framework, called Dynamic Knowledge Base, aimed at describing rich business domains and, by overcoming the described limitations, be a more versatile environment for planning and decision-making. It takes inspiration from the afore-mentioned Knowledge and Actions\nBases, but differs in the definition and introduces few optimizations. The data-layer is taken care of by a DL-LiteA knowledge base, while a set of actions allows the system to evolve by adding/removing assertions and introducing new instances to the system. We then introduce the following optimizations: action rewriting, that allows to ditch completely the TBox in the building of the transition system (while keeping the consistency w.r.t. it), and abstraction, that gives the possibility to work with partial abstract knowledge. The described framework constitutes the basis of an on-going work aimed at exploring new planning techniques in DL-based artifact-centric business models, where large amount of structured data poses a difficulty in handling resources efficiently and in avoiding inconsistent behaviours.\nOrganization: in Sec. 2 we introduce the formalization of Dynamic Knowledge Bases . In Sec. 3 we illustrate a business example to better explain our framework. In Sec. 4 we describe the optimizations we introduce, namely action rewriting (Sec. 4.1), and abstraction (Sec. 4.2). Finally, in Sec. 4.3 we study the properties of the resulting abstract framework w.r.t. the original one."
    }, {
      "heading" : "2 Dynamic Knowledge Base",
      "text" : "Dynamic Knowledge Bases (or DKBs) are, briefly, dynamic systems (more precisely labelled transition systems) in which states are constituted by DL-Lite knowledge bases composed of a TBox and an ABox, and a set of actions that makes the system evolve by modifying the ABox: it follows that the TBox is fixed, while the ABox changes as the system evolves (thus an ABox Ai is sufficient to identify the state i of the system). More specifically, we adopt DL-LiteA ontologies [Calvanese et al., 2006], and restrict the possible TBox axioms by not allowing functional roles, nor attributes. The ABox is a finite set of assertions, i.e., atomic formulas of the form C(i) and R(i, i′), where C is an atomic concept name, R is an atomic role name, and i, i′ are individual constants defined over a countably infinite (object) universe ∆ of individuals. The set ADOM(A) identifies the constants in A (it follows that ADOM(A) ⊆ ∆). AT denotes the set of all possible consistent ABoxes w.r.t. T that can be constructed using concept and role names in T , and individuals in ∆. The semantic adopted is the standard one based on first-order interpretations and on the notion of (first-order) model: a TBox is satisfiable if admits at least one model, an ABox A is consistent w.r.t. a TBox T if (T,A) is satisfiable, and (T,A) logically implies an ABox assertion α (denoted (T,A) |= α) if every model of (T,A) is also a model of α.\nDefinition 2.1. A DKB is a tuple D = (T,A0,Γ), where (T,A0) is a DL-LiteA KB, while Γ is a finite set of actions.\nAn action from the set Γ is of the form a: q ∪ N E, where a is the action name, q is a query called action guard, N is a set of variables which are used in an instance creation function, and E are the action effects. The guard q is a standard conjunctive query of the type q = {−→x |conj(−→x )}, where conj(−→x ) is a conjunction of atoms with only free variables −→x , no existential ones and no individuals. Atoms of q uses concepts and roles found in T . The set N simply contains variables which do not appear in\nq (Vars(q) ∩ N = ∅), and are fed to an assignment function m when the action is executed. The set E is a set of atomic effects (i.e., atomic non-grounded ABox assertions) which use variables that are in Vars(q) ∪ N , and is divided in two subsets: E−, the set of negative effects, and E+, the set of positive effects. All atoms of E− must occur among the atoms of q+ (E− = {e− | e− ∈ q+}), while the atoms of E+ must be different from them (E+ = {e+ | e+ 6∈ q+}). We also assume, for consistency reasons, that (T,E+) is satisfiable under the canonical interpretation [Glimm et al., 2011].\nThe dynamics of a DKB D is defined by the transition system ΥD it generates.\nDefinition 2.2. The transition system ΥD is defined as a tuple ΥD = (∆, T,Σ, A0,⇒), where: (i) ∆ is the universe of individual constants; (ii) T is a TBox; (iii) Σ is a set of states, namely ABoxes from the set AT (Σ ⊆ AT ); (iv) A0 is the initial state; (v) ⇒⊆ Σ × L × Σ is a labelled transition relation between states, where L = Γ × Θ is the set of labels containing one pair (a, ϑ) for every action a ∈ Γ and a corresponding homomorphism ϑ ∈ Θ.\nThe informal semantic of a transition is that, starting from a state A and selected an action a, we: i) extract the certain answers ANS(q, T,A) of the guard q from the current state A; ii) pick randomly one of the homomorphisms ϑa from the certain answers of q in (T,A) (ϑa ∈ ANS(q, T,A)); iii) apply the assignment function m : N → ∆ to the variables of the set N and complete ϑa; iv) use ϑa to instantiate the effects E (aϑa is called an instantiation of a) and calculate A′ by applying the instantiated effects to A. The assignment function m assigns to each variable of N an individual from ∆ which does not appear already in A (m(N,A) : N → (∆ \\ ADOM(A))).\nThe sets Σ and ⇒ are thus mutually defined using induction (starting from A0) as the smallest sets satisfying the following property: for every A ∈ Σ and action a ∈ Γ, if exists an action instantiation aϑa s.t. A′ = A\\sub(E−)ϑa∪E+ϑa, and A′ ∈ AT , then A′ ∈ Σ and A l ⇒ A′, with l = (a, ϑa).\nNotice that we apply first the negative effects E−, then the positive effects E+. sub(E−) represents all the assertions that are subsumed by the assertions of E−. The reason we remove also subsumed assertions is due to practicality, as described in Example 2.1.\nExample 2.1. Consider the following elements: a TBox T = {Assembler ⊑ Worker}, an action to fire a worker (fire: Worker(x) {Worker(x)}−), and an ABox A = {Assembler(a)}. If we apply fire to A (using ϑ = {x 7→ cos a}, a valid answer in ANS(q, T,A)), we see that, if we remove only E−ϑ from A, we do not change the ABox, as Worker(a) belongs to the inferred terms. This is not what we would expect in a real-life scenario.\nGiven a negative effect e−, an assertion α is in sub(E−) if: • e− = A1(x), α = A2(x), and T |= A2 ⊑ A1; • e− = A(x), α = R(x, ) 1 , and T |= ∃R ⊑ A; • e− = A(x), α = R( , x), and T |= ∃R− ⊑ A; • e− = R1(x, y), α = R2(x, y), and T |= R2 ⊑ R1;\n1 The symbol denotes that it can be substituted with any instance in ADOM(A)\n• e− = R(x, y), α = A(x), and T |= A ⊑ ∃R; • e− = R(y, x), α = A(x), and T |= A ⊑ ∃R−; The generated transition system ΥD is possibly infinite, as we have the possibility to introduce new constants. We call a path π a (possibly infinite) sequence of transitions over ΥD that start from A0 (π = A0 a1ϑ1⇒ ... anϑn⇒ An).\nA DKB is a concrete instantiation of the abstract framework Description Logic Based Dynamic System [Calvanese et al., 2013], which is a tuple S = (TS , AS ,ΓS) where (TS , AS) is a DL KB (note that the KB is not restricted to use DL-Lite), and ΓS is a set of actions of the type a = (π, τ). Without explaining the mechanisms that define a Description Logic Based Dynamic System , we provide the translations from it to our DKB. The KB (TS , AS) corresponds to the KB (T,A0) used in the DKB. To match the definition of actions ΓS , we reformulate the actions in Γ as a = (πa, τa), where: • πa executes the guard q over (T,A), obtaining a partial\naction instantiation ϑa, partially instantiating the effects, and returning the variables of the set N ; • τa(A,m) completes the instantiation of the effects by using the assignment function m, and returns the ABox A′\nobtained by applying the effects to A. If A′ is not consistent w.r.t. T , then τa(A,m) is undefined. Our framework is also closely related to the framework Knowledge and Action Bases (KAB) [Hariri et al., 2013]. , although with some minor differences in the specific DL-Lite flavour used (our is more strict) and in the dynamic aspect of the system. A KAB action γKAB is a finite set of effects ei (γKAB = {e1, ..., en}), with each effect defined as ei = [q + i ] ∪ Q − i A ′ i, where q\n+ is an UCQ, Q− an ECQ used to refine the result set [q+] (i.e. the result set obtained by performing q+ over the KB (T,Ai)), and A′i a complete ABox. Our actions are not sets of effects, but resemble the definition of a single KAB effect, thus this difference can be easily overcome by defining a DKB action for each effect in a KAB action. In our framework the guard is simply a CQ (we do not provide an ECQ to refine the result set of the guard), and our effects states what to add/remove from the starting ABox. Given the close relationship to KABs, we also inherit the capability of verifying µLA temporal formulas and the complexity results (both verification and synthesis can be done in EXPTIME)."
    }, {
      "heading" : "3 Example",
      "text" : "We now detail an example based on a manufacturing company that produces electronic goods and, as in a typical situation, has different product assembly lines and a warehouse.\nThrough the TBox T we model the structure of the company, which represented graphically Figure 1: solid arrows corresponds to the hierarchy of concepts, while the dashed lines to the disjointness of concepts. It is a fairly simple TBox in which we represent different type of workers (the concept Worker and its subconcepts Assembler and Warehouse), the products being assembled by the company (Cellphone and Tablet concepts) and some product attributes (like Packed to denote a product being ready to be shipped, and Stocked if it has being placed in the warehouse). The intial ABox A0 contains the following assertions:\nA0 = { Assembler(e1), Warehouse(e2), Parts(p1), Parts(p2), Cellphone(c1), Stocked(c1) }\nWe now define the actions available in the set Γ:\npack product : Worker(x) ∧ Product(y) {Packed(y)}+\ncreate tablet : (Assembler(x) ∧ Parts(y)) ∪ {z}\n{Parts(y)}− ∪ {Tablet(z),Scrap(y)}+\nunstock product : Warehouse(x) ∧ Stocked(y) {Stocked(y)}−\nclean : Worker(x) ∧ Scrap(y) {Scrap(y)}−\nWe have thus defined the elements that compose the DKB D = 〈T,A0,Γ〉 (as detailed in Sec. 2). We show in Figure 2 (we omit the homomorphisms for clarity of the image) a partial development of the transition system ΥD with a couple of possible transitions and their properties. Starting from A0: • we can perform pack product with ϑ = {x 7→ e1, y 7→ c1}, but the resulting state A′ = A0 ∪ {Packed(c1)} is inconsistent, as c1 appears in the disjoint concepts Packed and Stocked. Such transition is therefore not valid, and does not appear in ΥD; • we can’t perform clean, as the query Worker(x)∧Scrap(y) has no certain answers in A0; • we can perform create tablet with ϑ = {x 7→ e1, y 7→ p1}, and the resulting state A1 is consistent w.r.t T , making\nA0 create tabletϑ\n⇒ A1 a valid transition. Notice that we also introduce a new individual t1 which was not present in A0.\nA1 = { Assembler(e1), Warehouse(e2),Parts(p2), Cellphone(c1), Stocked(c1), Tablet(t1), Scrap(p1) }"
    }, {
      "heading" : "4 Optimizations",
      "text" : "As stated in the introduction, our aim is to use DKBs for planning and decision making purposes. Given the specifications of a DKB, few details arise that pose a problem to reach our objective. First of all, we only consider the totality of the available knowledge at a given time.\nWhile such condition is necessary to asses the consistency of the overall system, it bounds us to work with details that might not be of interests immediately. In decision making [Gigerenzer and Gaissmaier, 2011], “an heuristic is a strategy that ignores part of the information, with the goal of making decisions more quickly, frugally, and/or accurately than more complex methods”. To allow our framework to be used for such strategies, it must be able to work with partial information, so that users can focus on a chosen subset of knowledge. This goal is vital when we deal with systems described by complex ontologies and are composed of millions (if not more) instances.\nTo fulfil these objectives, we introduces two optimizations to our framework, namely action rewriting and abstraction of the transition system. The first is aimed at simplifying the building of the transition system and removing the dependency from the TBox T , while guaranteeing that all the states are still consistent w.r.t. it. The second, instead, allows to build a transition system which uses partial knowledge and allows us to work in an abstract environment which is not tied to the instances in the ABox."
    }, {
      "heading" : "4.1 Action Rewriting",
      "text" : "In the actual specification of a DKB (and also in the framework Knowledge and Action Bases [Hariri et al., 2013]), actions could lead to inconsistent states w.r.t. the TBox T . We first introduce three theorems related to DL-LiteA KBs.\nTheorem 4.1. Given a DL-LiteA KB (T,A) and a partition A = ⋃ i Ai, we have that chase(T,A) = ⋃ i chase(T,Ai).\nProof. This property can be easily derived from the definition of chase of a DL-LiteA KB [Calvanese et al., 2009], which is used to generate the set of inferred terms.\nTheorem 4.2. Given a DL-LiteA KB (T,A) every ABoxA′ ⊂ A is consistent w.r.t T .\nProof. If (T,A) is satisfiable, from the definition of chase and NI-closure of T (denoted cln(T )) of a DL-LiteA KB [Calvanese et al., 2009], it follows that, for every assertion α in chase(T,A) we have cln(T ) |= α.\nAssume that it exists A′ ⊆ A such that (T,A′) is not satisfiable, thus it exists at least one assertionα′ in chase(T,A′) ⊆ which is not implied by cln(T ) (cln(T ) 6|= α′). From the definition of chase, although, it’s easy to see that α′ must be also in chase(T,A), which creates the absurd situation where α′ is both implied and not implied by cln(T ).\nDefinition 4.1. Given a DL-LiteA TBox T , we call NI-closure of T w.r.t. an assertion α (with α an assertion of the type A(i) or P(i1, i2)), denoted by cln(T, α), the TBox defined as the NI-closure of T [Calvanese et al., 2009] where all the assertions in which A (resp. P, ∃P, or ∃P−) does not appear on any side are removed.\nTheorem 4.3. Given a satisfiable DL-LiteA KB K = (T,A) and an assertion α 6∈ A, we have that K′ = (T,A ∪ {α}) is satisfiable if cln(T, α) |= α.\nProof. From [Calvanese et al., 2009], we have that the canonical interpretation can(K′) is a model of K′ if and only if DB(A ∪ {α}) is a model of (cln(T ), A ∪ {α}). Since K = (T,A) is already satisfiable, it means that every membership assertion in A already respects the axioms in T , and thus in cln(T ). If α doesn’t respect cln(T ), then can(K′) can’t be a model of K′. This would mean that α breaks an axiom inside cln(T ), which has to contain the concept (or role) used in α, thus this axiom must be also in cln(T, α) by definition. It follows that it is sufficient to test if cln(T, α) |= α to know if K′ = (T,A ∪ {α}) is satisfiable or not.\nDefinition 4.2. Given an action a ∈ Γ, we define its rewriting as arew = q ∪N ∪B E, with B = ∨ i bi an union of conjunctive queries (UCQ) (where bi are single non-grounded assertions), called blocking query.\nB is built in the following manner. For each effect e+ ∈ E+: 1. calculate cln(T, e+), and, for every NI-assertions in it,\nbuild the assertion A(x) (resp., R(x1, x2)), where: A (resp., role R) is the class (res., role) that is disjoint with the class (resp., role) of e+, x (resp., x1, x2) is the variable appearing in e+. We do not consider the cases ∃R or ∃R−; 2. remove the assertions that use variables from the set N , as they would require instances that do not exists in A; 3. remove the assertions that appear in sub(E−), as they would be removed in A′; 4. add the remaining assertions to B by or-connecting them.\nTheorem 4.4. Given an action a ∈ Γ and its rewrite arew, for every ABox A such that ϑa ∈ ANS(q, T,A) and (∅, A) 6|= Bϑa, we can create the transition A a rewϑa⇒ A′ and be sure that A′ is consistent w.r.t. T .\nProof. From the definition of ⇒, we have that A′ is equal to A \\ sub(E−)ϑa ∪E+ϑa. Since (T,A) is satisfiable, then for Theorem 4.2 also (T,A \\ sub(E−)ϑa) is satisfiable.\nAdding E+ϑa to A\\sub(E−)ϑa maintains the consistency thanks to Theorem 4.3 and the way B is built, since we test the presence of possible assertions that could break any NIassertions in cln(T,E+) (excluding the one that are either removed or related to new instances).\nExample 4.1. Given the action create tablet from Sec. 3 with E+ = {Tablet(z), Scrap(y)}+, cln(T,E+) equals to:\ncln(T,E+) = {Tablet ⊑ ¬Cellphone,Tablet ⊑ ¬Worker,\n..., Scrap ⊑ ¬Product,Scrap ⊑ ¬Cellphone, ...}\nFrom it we derive the UCQ B: B =Product(y) ∨ Tablet(y) ∨ Cellphone(y)\n∨ Packed(y) ∨ Stocked(y)\nNotice that there are no assertions related to Tablet(z) (i.e., Cellphone(z)), since z ∈ N .\nThanks to the rewriting of the actions, we build the transition system ΥD without having to check the consistency of each ABox, and thus skipping the use of T for such task. Using the query reformulation algorithm [Calvanese et al., 2009], the TBox T is not necessary to find the possible action instantiations (query answering), thus making T superfluous for the building of ΥD, but still being consistent w.r.t. it."
    }, {
      "heading" : "4.2 Abstract Transition System",
      "text" : "We now build an abstraction of the transition system ΥD, which takes place in two points: i) we no longer use ABoxes to define states, but conjunctive queries; ii) we define a looser transition function to build the transition system.\nWe first characterize a DL-LiteA abstract KB, which is a tuple (T, Â) constituted by a TBox T and an abstract ABox Â. An abstract ABox Â is a finite set of non-ground facts, i.e., atomic formulas of the form C(x) and R(x, x′), where C is a concept name, R is a role name, and x, x′ are variables taken from a countably infinite (object) universe ∆̂ of variables (note that here we allow C and R to be non atomic, as it should be instead in a normal DL-LiteA ABox). Given Â, we obtain the relative conjunctive query Q(Â) by simply and-connecting all the assertions:\nQ(Â) = ∧\ni αi | αi ∈ Â\nWith a little abuse of notation, we identify with Â both the abstract ABox and the corresponding query, depending on the context of use. The set Vars(Â) identifies the variables in Â (it follows that Vars(Â) ⊆ ∆̂). ÂT denotes the set of all possible consistent abstract ABoxes that can be constructed using concept and role names in T , and variables in ∆̂. The semantic adopted for abstract ABoxes is based on the canonical interpretation [Glimm et al., 2011]: an abstract ABox Â is consistent w.r.t. a TBox T if it exists a canonical interpretation I\nÂ , such that I Â |= (T, Â).\nDefinition 4.3. An abstract transition system Υ̂D is a tuple Υ̂D = (∆̂, T, Σ̂, Â0, ), where: (i) ∆̂ is the universe of variables; (ii) T is a TBox; (iii) Σ̂ is a set of abstract states, namely abstract ABoxes from the set ÂT (Σ̂ ⊆ ÂT ); (iv) Â0 is a set of initial abstract states obtained from the intial ABox A0; (v) ⊆ Σ̂ × L̂ × Σ̂ is a labelled transition relation between states, where L̂ = Γ×Φ is the set of labels containing one pair (a, φ) for every action a ∈ Γ and a corresponding homomorphism φ ∈ Φ.\nThe set Â0 is obtained in the following way: 1. define an homomorphism ϑ−A0 that assigns each individ-\nual of ADOM(A0) to a distinct variable from ∆̂ (ϑ − A0 : ADOM(A0) 7→ ∆̂ s.t. (i = i′ ⇒ x = x′) ∧ (i 6= i′ ⇒ x 6= x′) , ∀i 7→ x, i′ 7→ x′);\n2. obtain the abstract state Âmax = chase(A0)ϑ − A0 . Âmax is obviously a valid query, as ϑA0 is an answer; 3. Â0 = P≥1(Âmax), which is a set of queries (not all the possible ones) that do find an answer in A0.\nExample 4.2. Considering the initial ABox A0 detailed in Sec. 3 , we can obtain the following elements related to the definition of Â0: • ϑ−A0 = {e1 7→ x, e2 7→ y, p1 7→ z, p2 7→ w, c1 7→ v}; • (A0)inf = {Worker(e1),Worker(e2),Product(c1)}; • Âmax = {Assembler(x), Warehouse(y), Parts(z), Parts(w),\nCellphone(v), Stocked(v), Worker(x), Worker(y), Product(v)};\n• Â0 = {Â0a, Â0b, ...} with Â0a = {Assembler(x), Parts(z)}, and Â0b = {Assembler(x), Worker(x), Parts(z)};\nThe informal semantic of a transition is the same of ⇒ (we substitute A and ∆ with, respectively, Â and ∆̂), with the only difference that we look for the certain answers of ANS(q, ∅, Â) (we do not consider T ). We can also apply the rewriting of actions detailed in Sec. 4.1, and get the same properties as for normal ABoxes. The sets Σ̂ and are defined using a more loose definition w.r.t. to Σ and ⇒. Given a Â ∈ Σ̂, an action arew (a ∈ Γ), and a valid action instantiation φa (so that (∅, Â) 6|= Bφa), we express Â′ as:\nÂ′ ⊆ Â \\ sub(E−)φa ∪E +\nallφa\nwhere E+all = chase(T,E +). If such Â′, then Â′ ∈ ÂT (thanks to Theorem 4.4) and Â′ ∈ Σ̂ and Â l̂ Â′, with\nl̂ = (a, φa). The generated transition system Υ̂D is, like ΥD, a possibly infinite transition system, since we have the possibility to introduce new variables. We call an abstract path π̂ a (possibly infinite) sequence of transitions over Υ̂D (π̂ ∈ Υ̂D) that starts from Â0 ∈ Â0 (Â0 a1φ1 ⇒ ... anφn ⇒ Ân).\nExample 4.3. Considering the initial abstract state Â0b = {Assembler(x), Worker(x), Parts(z)} (detailed in Example 4.2), we can execute the action create tablet (with φ = {x 7→ x, y 7→ z, z 7→ w}) and get Â0b \\ sub(E−)φ ∪ E+allφ = {Assembler(x), Worker(x), Scrap(z), Tablet(w), Product(w)} (sub(E−) = {Parts(y)}). From it, all the possible subsets are valid ending states A′ of the transition:\nÂ0b create tabletφ A′\nAs for the construction of ΥD, also the abstract transition system Υ̂D can be built without the use of T ."
    }, {
      "heading" : "4.3 Abstract Transition System Properties",
      "text" : "Having said that the abstract transition system Υ̂D is an abstraction of ΥD , we look for the exact relation between the two. We define first when an abstract transition Â l̂ Â′ is a proper abstraction of a transition A l ⇒ A′.\nDefinition 4.4. An abstract transition Â l̂ Â′ is a proper abstraction of a transition A l ⇒ A′ if:\n• both transitions are caused by the same action a; • Â (Â′) returns some results as a query against A (A′), thus ∃ϑA | ϑA ∈ ANS(Â, T, A) (∃ϑA′ | ϑA′ ∈ ANS(Â′, T, A′)); • a variable is linked to the same individual through-out all the transition (∀x 7→ i, x′ 7→ i′ ∈ (ϑA ∪ ϑA′ ∪ φ−a ϑa) s.t. x = x′ ⇒ i = i′).\nIf Â l̂ Â′ is a proper abstraction of a transition A l ⇒ A′,\nthen A l ⇒ A′ is a proper concretion of Â l̂ Â′. The definition can be extended to paths: an abstract path π̂ (resp., a path π) is an abstraction (resp., a concretion) of a path π (resp., an abstract path π̂) if each transition in π̂ (resp., π) is a proper abstraction (resp., concretion) of the corresponding transition in π (resp., π̂).\nFrom the last point of Definition 4.4, we can derive the fact that φ−\na ϑa ⊆ ϑA ∪ ϑA′ , as the instances (resp., variables) in-\nvolved in the action must be present either in A (resp., Â), or in A′ (resp., Â′). The constrain about variables-individuals is needed in order to have a significant representation of the concrete transition by the abstract one. If we do not force it, we could end up with a non-logical representation, as demonstrated in Example 4.4.\nExample 4.4. Consider the transition A0 create tabletϑ\n⇒ A1 with ϑ = {x 7→ e1, y 7→ p1} (from Sec. 3), and the ab-\nstract transaction Â0b create tabletφ Â1 with Â1 = {Scrap(z)}\n(Â0b is detailed in Example 4.2). We could set ϑA0 = {x 7→ e1, z 7→ p2}, ϑA1 = {z 7→ p1}, but we would have a meaningless abstraction, as the variable z would point to different individuals throughout the transition.\nTheorem 4.5. An abstract transition system Υ̂D is a simulation of the transition system ΥD.\nProof. Let’s consider a path π = A0 a1ϑa1⇒ ... anϑan⇒ An in ΥD. We try to build an abstract path π̂ = Â0 a1φa1 ... aNφaN ÂN , so that: • each state Âi of π̂ is equal to (Ai)allϑ\n− Ai , with Ai the corresponding state in π, and (Ai)all = chase(Ai); • each abstract transition Âi alφal Âl is a proper abstraction\nof the corresponding transition Ai alϑal⇒ Al.\nWe proceed inductively starting from A0, and seeing that, from the definition of Â0 we can define Â0 = (A0)allϑ\n− A0\n(with ϑA0 the homomorphism from Â0 to A0). We can build the homomorphisms ϑa1 and φa1 by using ϑA0 as a guide, and thus respecting the constrain about variables from Definition 4.4 (we just have to complete them with the variables from N of the action a1). The last step is to see if, after the transition, we can have Â1 as (A1)allϑ\n− A1 . Given the definition of an transition in ΥD, we know that A1 = A0 \\ sub(E−)ϑa1 ∪E\n+ϑa1 , thus we can, using Theorem 4.1, rewrite (A1)all ((A1)all = chase(T,A1)) as:\n(A1)all = (A0 \\ sub(E −)ϑa1 ∪ E +ϑa1)all\n= (A0 \\ sub(E −)ϑa1)all ∪ (E +)allϑa1\nWe can also define ϑA1 by combining ϑA0 and ϑa1 , since ADOM(A1) ⊆ ADOM(A0) ∪ Nϑa1 (where Nϑa1 are the instances introduced by a). Given the definition of a transition in Υ̂D, we know that Â1 ⊆ Â0 \\ sub(E−)φa1 ∪E +\nallφa1 , thus we can consider the extreme case:\nÂ1−max = Â0 \\ sub(E −)φa1 ∪ E + allφa1\n= (A0)allϑ − A0 \\ sub(E−)φa1 ∪ E + allφa1\nAs we already defined ϑA0 , ϑa1 and φa1 , we can apply them to (A0)allϑ\n− A0 \\ sub(E−)φa1 , thus transforming the variables in instances and get (A0)all \\ sub(E−)ϑa1 ∪ E +\nallϑa1 . We see now that the definition of A1 and its abstract counterpart Â1−max are very similar, the only difference given by the set (A0\\sub(E−)ϑa1)all and (A0)all\\sub(E −)ϑa1 , which can be\nnot equal (more precisely, (A0 \\ sub(E−)ϑa1)all ⊆ (A0)all \\ sub(E−)ϑa1 ). Since Â1 ⊆ Â1−max, we can select the proper subset where Â1 = (A0ϑ\n− A0 \\ sub(E−)φa1)all ∪E + allφa1 .\nWe thus demonstrated that the abstract transition function is capable of reproducing the transition function ⇒, meaning that every path in ΥD has at least one proper abstraction in Υ̂D. An abstract path π̂, on the other side, doesn’t always have a proper concretion in ΥD: this is a clear (and intended) consequence of working with partial knowledge. To know if it exists a path π that is a concretion of π̂, we have to consider all the available knowledge, which means we have to take into account the whole initial knowledge of the state A0, and the application of all of the effects of each action. We build π starting from A0 and using the transition function ⇒; π̂ acts as a guide for the actions to perform, and at each step we see if the proposed action respects its blocking query or not."
    }, {
      "heading" : "5 Conclusions",
      "text" : "In this paper we formalize a framework, based on description logic, aimed at modelling the dynamics of business processes. Such framework, called Dynamic Knowledge Bases, is represented by a transition system where states are defined by a DL-Lite knowledge base, and where a set of actions allow the system to evolve by adding or removing assertions, along with the possibility to introduce new instances. The expressive power and reasoning services of description logics are very helpful to describe and manage the domain knowledge, but constitute a difficult environment to deal with when it comes to the processes. To tackle this problem, we introduce two optimizations, namely action rewriting and the abstraction of the transition system related to a Dynamic Knowledge Base: these optimizations give us a framework where we can work with partial knowledge and where the TBox is not needed, still guaranteeing that the resulting system is consistent with it. Our framework represents a formal base which can be used to solve planning and decision making problems, a relevant aspect of rich business domains.\nWe are currently working to further expand this framework in various directions. Under the theoretical side, we intend to expose more properties of the abstract transition system, in particular the connections with the concrete one (e.g., being able to asses if an abstract path π̂ has a concretion π without explicitly calculating it). Another progression is the expansion of the expressive power of the framework, namely by allowing the use of full DL-LiteA knowledge bases, along with more powerful actions, e.g., allowing the use of ECQs to refine the results of the guard. Under the practical side, a backward planning algorithm is already under development, which takes advantage of the abstract transition system and the possibility to work with partial knowledge to return all plans of interest w.r.t. a goal.\nAlthough further investigation is surely needed, Dynamic Knowledge Bases are a promising framework that can be usefully employed to tackle the problem of planning and decision making in artifact-centric business domains."
    } ],
    "references" : [ {
      "title" : "Verification of Golog programs over description logic actions",
      "author" : [ "Baader", "Zarrieß", "2013] Franz Baader", "Benjamin Zarrieß" ],
      "venue" : "Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics),",
      "citeRegEx" : "Baader et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2013
    }, {
      "title" : "Business Process Management",
      "author" : [ "Kamal Bhattacharya", "Cagdas Gerede", "Richard Hull. Towards formal analysis of artifact-centric business process models" ],
      "venue" : "pages 288–304,",
      "citeRegEx" : "Bhattacharya et al.. 2007",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Linking data to ontologies: The description logic DL-LiteA",
      "author" : [ "Diego Calvanese", "Giuseppe De Giacomo", "Domenico Lembo", "Maurizio Lenzerini", "Antonella Poggi", "Riccardo Rosati" ],
      "venue" : "CEUR Workshop Proceedings, 216,",
      "citeRegEx" : "Calvanese et al.. 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Ontologies and Databases: the DL-Lite Approach",
      "author" : [ "Diego Calvanese", "Giuseppe Giacomo", "Domenico Lembo", "Maurizio Lenzerini", "Antonella Poggi", "Mariano Rodriguez-Muro", "Riccardo Rosati" ],
      "venue" : "5689:255–356,",
      "citeRegEx" : "Calvanese et al.. 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "volume 7994 of Lecture Notes in Computer Science",
      "author" : [ "Diego Calvanese", "Giuseppe De Giacomo", "Marco Montali", "Fabio Patrizi. Verification", "Synthesis in Description Logic Based Dynamic Systems" ],
      "venue" : "Springer Berlin Heidelberg, Berlin, Heidelberg,",
      "citeRegEx" : "Calvanese et al.. 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Business artifacts: A data-centric approach to modeling business operations and processes",
      "author" : [ "David Cohn", "Richard Hull" ],
      "venue" : "IEEE Data Eng. Bull, 32(3):3–9,",
      "citeRegEx" : "Cohn and Hull. 2009",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Automated planning - theory and practice",
      "author" : [ "Malik Ghallab", "Dana S. Nau", "Paolo Traverso" ],
      "venue" : "Elsevier,",
      "citeRegEx" : "Ghallab et al.. 2004",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "Annual review of psychology",
      "author" : [ "Gerd Gigerenzer", "Wolfgang Gaissmaier. Heuristic decision making" ],
      "venue" : "62:451–482,",
      "citeRegEx" : "Gigerenzer and Gaissmaier. 2011",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Conjunctive Query Answering for the Description Logic SHIQ",
      "author" : [ "Birte Glimm", "Ian Horrocks", "Carsten Lutz", "Ulrike Sattler" ],
      "venue" : "volume 31.",
      "citeRegEx" : "Glimm et al.. 2011",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "JAIR)",
      "author" : [ "Babak Bagheri Hariri", "Diego Calvanese", "Marco Montali", "Giuseppe De Giacomo", "Riccardo De Masellis", "Paolo Felli. Description Logic Knowledge", "Action Bases. J. Artif. Intell. Res" ],
      "venue" : "46:651–686,",
      "citeRegEx" : "Hariri et al.. 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Artif",
      "author" : [ "Hector J. Levesque. Foundations of a Functional Approach to Knowledge Representation" ],
      "venue" : "Intell., 23(2):155–212,",
      "citeRegEx" : "Levesque. 1984",
      "shortCiteRegEx" : null,
      "year" : 1984
    }, {
      "title" : "ACM Transactions on the Web",
      "author" : [ "Marco Montali", "Maja Pesic", "Wil M.P. Van Der Aalst", "Federico Chesani", "Paola Mello", "Sergio Storari. Declarative specification", "verification of service choreographiess" ],
      "venue" : "4(May):1–62,",
      "citeRegEx" : "Montali et al.. 2010",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Van Der Aalst",
      "author" : [ "Maja Pesic", "Wil M. P" ],
      "venue" : "A Declarative Approach for Flexible Business Processes Management.",
      "citeRegEx" : "Pesic and Van Der Aalst. 2006",
      "shortCiteRegEx" : null,
      "year" : 2006
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "One of the most prominent operations related to business processes is planning [Ghallab et al., 2004], namely finding a sequence of operations/actions that allows to reach a desired goal.",
      "startOffset" : 79,
      "endOffset" : 101
    }, {
      "referenceID" : 1,
      "context" : "Artifact-centric models for business processes recently raised a lot of attention [Bhattacharya et al., 2007; Cohn and Hull, 2009], as they manage to combine structural (i.",
      "startOffset" : 82,
      "endOffset" : 130
    }, {
      "referenceID" : 5,
      "context" : "Artifact-centric models for business processes recently raised a lot of attention [Bhattacharya et al., 2007; Cohn and Hull, 2009], as they manage to combine structural (i.",
      "startOffset" : 82,
      "endOffset" : 130
    }, {
      "referenceID" : 9,
      "context" : "In this context, we can see the development of the framework called Knowledge and Actions Bases [Hariri et al., 2013], the later higher formalization of it named Description Logic Based Dynamic Systems [Calvanese et al.",
      "startOffset" : 96,
      "endOffset" : 117
    }, {
      "referenceID" : 4,
      "context" : ", 2013], the later higher formalization of it named Description Logic Based Dynamic Systems [Calvanese et al., 2013], and the Golog-based work of [Baader and Zarrieß, 2013].",
      "startOffset" : 92,
      "endOffset" : 116
    }, {
      "referenceID" : 10,
      "context" : "These works all share the same concept: handle the data-layer through a Description Logic ontology, while the process-layer, since DLs are only able to give a static representation of the domain of interest, is defined as actions that update the ontology (the so-called “functional view of knowledge bases” [Levesque, 1984]).",
      "startOffset" : 307,
      "endOffset" : 323
    }, {
      "referenceID" : 12,
      "context" : "Artifact-centric models developed in parallel with declarative approaches for modelling processes [Pesic and Van Der Aalst, 2006; Montali et al., 2010], where activities try to adapt the internal system to the humans involved and the input they receive.",
      "startOffset" : 98,
      "endOffset" : 151
    }, {
      "referenceID" : 11,
      "context" : "Artifact-centric models developed in parallel with declarative approaches for modelling processes [Pesic and Van Der Aalst, 2006; Montali et al., 2010], where activities try to adapt the internal system to the humans involved and the input they receive.",
      "startOffset" : 98,
      "endOffset" : 151
    }, {
      "referenceID" : 2,
      "context" : "More specifically, we adopt DL-LiteA ontologies [Calvanese et al., 2006], and restrict the possible TBox axioms by not allowing functional roles, nor attributes.",
      "startOffset" : 48,
      "endOffset" : 72
    }, {
      "referenceID" : 8,
      "context" : "We also assume, for consistency reasons, that (T,E) is satisfiable under the canonical interpretation [Glimm et al., 2011].",
      "startOffset" : 102,
      "endOffset" : 122
    }, {
      "referenceID" : 4,
      "context" : "A DKB is a concrete instantiation of the abstract framework Description Logic Based Dynamic System [Calvanese et al., 2013], which is a tuple S = (TS , AS ,ΓS) where (TS , AS) is a DL KB (note that the KB is not restricted to use DL-Lite), and ΓS is a set of actions of the type a = (π, τ).",
      "startOffset" : 99,
      "endOffset" : 123
    }, {
      "referenceID" : 9,
      "context" : "Our framework is also closely related to the framework Knowledge and Action Bases (KAB) [Hariri et al., 2013].",
      "startOffset" : 88,
      "endOffset" : 109
    }, {
      "referenceID" : 7,
      "context" : "In decision making [Gigerenzer and Gaissmaier, 2011], “an heuristic is a strategy that ignores part of the information, with the goal of making decisions more quickly, frugally, and/or accurately than more complex methods”.",
      "startOffset" : 19,
      "endOffset" : 52
    }, {
      "referenceID" : 9,
      "context" : "In the actual specification of a DKB (and also in the framework Knowledge and Action Bases [Hariri et al., 2013]), actions could lead to inconsistent states w.",
      "startOffset" : 91,
      "endOffset" : 112
    }, {
      "referenceID" : 3,
      "context" : "This property can be easily derived from the definition of chase of a DL-LiteA KB [Calvanese et al., 2009], which is used to generate the set of inferred terms.",
      "startOffset" : 82,
      "endOffset" : 106
    }, {
      "referenceID" : 3,
      "context" : "If (T,A) is satisfiable, from the definition of chase and NI-closure of T (denoted cln(T )) of a DL-LiteA KB [Calvanese et al., 2009], it follows that, for every assertion α in chase(T,A) we have cln(T ) |= α.",
      "startOffset" : 109,
      "endOffset" : 133
    }, {
      "referenceID" : 3,
      "context" : "an assertion α (with α an assertion of the type A(i) or P(i1, i2)), denoted by cln(T, α), the TBox defined as the NI-closure of T [Calvanese et al., 2009] where all the assertions in which A (resp.",
      "startOffset" : 130,
      "endOffset" : 154
    }, {
      "referenceID" : 3,
      "context" : "From [Calvanese et al., 2009], we have that the canonical interpretation can(K) is a model of K if and only if DB(A ∪ {α}) is a model of (cln(T ), A ∪ {α}).",
      "startOffset" : 5,
      "endOffset" : 29
    }, {
      "referenceID" : 3,
      "context" : "Using the query reformulation algorithm [Calvanese et al., 2009], the TBox T is not necessary to find the possible action instantiations (query answering), thus making T superfluous for the building of ΥD, but still being consistent w.",
      "startOffset" : 40,
      "endOffset" : 64
    }, {
      "referenceID" : 8,
      "context" : "ical interpretation [Glimm et al., 2011]: an abstract ABox Â is consistent w.",
      "startOffset" : 20,
      "endOffset" : 40
    } ],
    "year" : 2017,
    "abstractText" : "Artifact-centric models for business processes recently raised a lot of attention as they manage to combine structural (i.e. data related) with dynamical (i.e. process related) aspects in a seamless way. This developed in parallel with declarative approaches for modelling processes, where activities are not burdened by over-specified constrains like in traditional process-centric approaches, but try to adapt the internal system to the humans involved and the input they receive. In this paper, we try to merge these two aspects by proposing a framework aimed at describing rich business domains through Description Logic-based ontologies, and where a set of actions allows the system to evolve by modifying such ontologies. We then propose an evolution of such framework which represents a viable and formal environment to develop decision making and planning techniques for DL-based artifactcentric business domains.",
    "creator" : "LaTeX with hyperref package"
  }
}