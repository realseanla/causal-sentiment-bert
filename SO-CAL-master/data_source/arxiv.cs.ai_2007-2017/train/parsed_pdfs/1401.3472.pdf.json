{
  "name" : "1401.3472.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Variable Forgetting in Reasoning about Knowledge",
    "authors" : [ "Kaile Su", "Abdul Sattar", "Guanfeng Lv", "Yan Zhang" ],
    "emails" : [ "sukl@pku.edu.cn", "a.sattar@griffith.edu.au", "lvgf@yahoo.com", "yan@cit.uws.edu.au" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Epistemic logics, or logics of knowledge are usually recognized as having originated in the work of Jaakko Hintikka - a philosopher who showed how certain modal logics could be used to capture intuitions about the nature of knowledge in the early 1960s (Hintikka,\nc©2009 AI Access Foundation. All rights reserved.\n1962). In the mid of 1980s, Halpern and his colleagues discovered that S5 epistemic logics could be given a natural interpretation in terms of the states of processes (commonly called agents) in a distributed system. This model now is known as the interpreted system model (Fagin, Halpern, Moses, & Vardi, 1995). It was found that this model plays an important role in the theory of distributed systems and has been applied successfully in reasoning about communication protocols (Halpern & Zuck, 1992). However, the work on epistemic logic has mainly focused on theoretical issues such as variants of modal logic, completeness, computational complexity, and derived notions like distributed knowledge and common knowledge.\nIn this paper, we explore knowledge reasoning within a more concrete model of knowledge. Our framework of reasoning about knowledge is simple and powerful enough to analyze realistic protocols such as some widely used security protocols.\nTo illustrate the problem investigated in this paper, let us consider the communication scenario that Alice sends Bob a message and Bob sends Alice an acknowledgement when receiving the message. We assume Alice and Bob commonly have the following background knowledge base ΓCS :\nBob recv msg ⇒ Alice send msg Bob send ack ⇒ Bob recv msg Alice recv ack ⇒ Bob send ack\nwhere Bob recv msg and Bob send ack are observable variables to Bob, while Alice send msg and Alice recv ack are observable to Alice.\nThe problem we are concerned with is how to verify that Alice or Bob knows a statement ϕ. Intuitively, we should be able to prove that for a statement observable to Alice (Bob), Alice (Bob) knows the statement if and only if the statement itself holds. As for the knowledge of non-observable statements, the following should hold:\n1. Alice knows Bob recv msg if Alice recv ack holds; on the other hand, if Alice knows Bob recv msg, then Alice recv ack holds, which means that, in the context of this example, the only way that Alice gets to know Bob recv msg is that Alice receives the acknowledgement from Bob.\n2. Bob knows Alice send msg if Bob recv msg holds; moreover, if Bob knows Alice send msg, then Bob recv msg holds. The latter indicates that the only way that Bob gets to know Alice send msg is that Bob receives the message from Alice.\n3. Finally, Bob does not know Alice recv ack.\nThe idea behind the presented knowledge model for those scenarios demonstrated above is that an agent’s knowledge is just the agent’s observations or logical consequences of the agent’s observations under the background knowledge base.\nOne of the key notions introduced in this paper is agents’ observable variables. This notion shares a similar spirit of those of local variables in the work of van der Hoek and Wooldridge (2002) and local propositions in the work of Engelhardt, van der Meyden and Moses (1998) and in the work of Engelhardt, van der Meyden and Su (2003). Informally speaking, local propositions are those depending only upon an agent’s local information; and an agent can always determine whether a given local proposition is true. Local variables\nare those primitive propositions that are local. Nevertheless, the notion of local propositions (Engelhardt et al., 1998, 2003) is a semantics property of the truth assignment function in a Kripke structure, while the notion of local variables (van der Hoek & Wooldridge, 2002) is a property of syntactical variables. In this paper, we prefer to use the term “observable variable” in order to avoid any confusion with the term “local variable” used in programming, where “non-local variables” such as “global variables” may often be observable.\nOur knowledge model is also closely related to the notion of weakest sufficient condition, which was first formalized by Lin (2001). Given a background knowledge base Γ and a set of observable variables Oi for each agent i, we show that the notion of agent i knowing a formula ϕ can be defined as the weakest sufficient condition of ϕ over Oi under Γ, which can be computed via the operation of variable forgetting (Lin & Reiter, 1994) or eliminations of middle terms (Boole, 1854). Moreover, we generalize the notion of weakest sufficient condition and capture the notion of common knowledge.\nNow we briefly discuss the role of variable forgetting in our knowledge model. Let us examine the scenario described above again. Consider the question: how can Alice figure out Bob’s knowledge when she receives the acknowledgement from Bob? Note that Alice’s knowledge is the conjunction of the background knowledge base ΓCS and her observations Alice recv ack etc. Moreover, all Alice knows about Bob’s knowledge is the conjunction of the background knowledge base ΓCS and all she knows about Bob’s observations. Thus, Alice gets Bob’s knowledge by computing all she knows about Bob’s observations. In our setting, Alice gets her knowledge on Bob’s observations simply by forgetting Bob’s nonobservable variables in her own knowledge.\nThere is a recent trend of extending epistemic logics with dynamic operators so that the evolution of knowledge can be expressed (van Benthem, 2001; van Ditmarsch, van der Hoek, & Kooi, 2005a). The most basic extension is public announcement logic (PAL), which is obtained by adding an operator for truthful public announcements (Plaza, 1989; Baltag, Moss, & Solecki, 1998; van Ditmarsch, van der Hoek, & Kooi, 2005b). We show that public announcement operator can be conveniently dealt with via our notion of knowledge structure. This makes the notion of knowledge structure genuinely useful for those applications like the automated analysis of the well-known muddy children puzzle.\nFrom the discussion above, we can see that our framework of reasoning about knowledge is appropriate in those situations where every agent has a specified set of observable variables. To further show the significance of our framework, we investigate some of its interesting applications to the automated analysis of the well-known muddy children puzzle and the verification of the revised Needham-Schroeder protocol (Lowe, 1996).\nWe believe that there are many scenarios where the natural presentation of the available information about knowledge is under the form of a knowledge structure. What makes it valuable compared with the corresponding multi-agent S5 Kripke structure is that it can be much more succinct. Of course, the price to pay is that determining whether a formula holds in a knowledge structure is PSPACE-hard in the general case, while it is in PTIME when the corresponding S5 Kripke structure is taken as input. However, the achieved trade-off between time and space can prove computationally valuable. In particular, the validity problem from a knowledge structure can be addressed for some instances for which generating the corresponding Kripke structure would be unfeasible. The muddy children puzzle shows this point clearly: generating the corresponding Kripke structure is impossible\nfrom a practical point of view, even for the least number of children considered in the experiments.\nThe organization of this paper is as follows. In the next section, we briefly introduce the concept of forgetting and the notion of weakest sufficient and strongest necessary conditions. In Section 3, we define our framework of reasoning about knowledge via variable forgetting. In Section 4, we generalize the notion of weakest sufficient condition and strongest necessary condition to capture common knowledge within our framework. In Section 5, we show that public announcement operator can also be conveniently dealt with via our notion of knowledge structure. Section 6 discusses the computational complexity issue about the problem of whether an epistemic formula is realized in a knowledge structure. In the general case, this problem is PSPACE-hard; however, for some interesting subcases, it can be reduced to co-NP. In Section 7, we consider a case study by applying our framework to model the well known muddy children puzzle; and further more to security protocol verification in Section 8. Finally, we discuss some related work and conclude the paper with some remarks."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "In this section, we provide some preliminaries about the notions of variable forgetting and weakest sufficient condition, and epistemic logic."
    }, {
      "heading" : "2.1 Forgetting",
      "text" : "Given a set of propositional variables P , we identify a truth assignment over P with a subset of P . We say a formula ϕ is a formula over P if each propositional variable occurring in ϕ is in P . For convenience, we define true as an abbreviation for a fixed valid propositional formula, say p ∨ ¬p, where p is primitive proposition in P . We abbreviate ¬true by false.\nWe also use |= to denote the usual satisfaction relation between a truth assignment and a formula. Moreover, for a set of formulas Γ and a formula ϕ, we use Γ |= ϕ to denote that for every assignment σ, if σ |= α for all α ∈ Γ, then σ |= ϕ.\nGiven a propositional formula ϕ, and a propositional variable p, we denote by ϕ( ptrue) the result of replacing every p in ϕ by true. We define ϕ( pfalse) similarly.\nThe notion of variable forgetting (Lin & Reiter, 1994), or eliminations of middle terms (Boole, 1854), can be defined as follows:\nDefinition 1 Let ϕ be a formula over P , and V ⊆ P . The forgetting of V in ϕ , denoted as ∃V ϕ, is a quantified formula over P , defined inductively as follows:\n1. ∃∅ϕ = ϕ; 2. ∃{p}ϕ = ϕ ( ptrue ) ∨ ϕ ( pfalse ) ;\n3. ∃(V ∪ {p})ϕ = ∃V (∃{p}ϕ). For convenience, we use ∀V ϕ to denote ¬∃V (¬ϕ).\nExample 2: Let ϕ = (p ∨ q) ∧ (¬p ∨ r). We have ∃{p}ϕ ≡ (q ∨ r) and ∃{q}ϕ ≡ (¬p ∨ r). 2\nMany characterizations of variable forgetting, together with complexity results, are reported in the work of Lang and Marquis (1998). In particular, the notion of variable forgetting is closely related to that of formula-variable independence (Lang, Liberatore, & Marquis, 2003).\nDefinition 3 Let ϕ be a propositional formula, and V a set of propositional variables. We say ϕ is independent from V if and only if ϕ is logically equivalent to a formula in which none of the variables in V appears.\nThe following proposition was given in the work of Lang, Liberatore and Marquis (2003).\nProposition 4 Let ϕ be a propositional formula, and V a set of propositional variables. Then ∃V ϕ is the logically strongest consequence of ϕ that is independent from V (up to logical equivalence)."
    }, {
      "heading" : "2.2 Weakest Sufficient Conditions",
      "text" : "The formal definitions of weakest sufficient conditions and strongest necessary conditions were first formalized via the notion of variable forgetting by Lin (2001), which in turn play an essential role in our approach.\nDefinition 5 Let V be a set of propositional variables and V ′ ⊆ V . Given a set of formulas Γ over V as a background knowledge base and a formula α over V .\n• A formula ϕ over V ′ is called a sufficient condition of α over V ′ under Γ if Γ |= ϕ ⇒ α. It is called a weakest sufficient condition of α over V ′ under Γ if it is a sufficient condition of α over V ′ under Γ, and for any sufficient condition ϕ′ of α on V ′ under Γ, we have Γ |= ϕ′ ⇒ ϕ.\n• A formula ϕ over V ′ is called a necessary condition of α over V ′ under Γ if Γ |= α ⇒ ϕ. It is called a strongest necessary condition of α over V ′ under Γ if it is a necessary condition of α over V ′ under Γ, and for any necessary condition ϕ′ of α over V ′ under Γ, we have Γ |= ϕ ⇒ ϕ′.\nThe notions given above are closely related to theory of abduction. Given an observation, there may be more than one abduction conclusion that we can draw. It should be useful to find the weakest one of such conclusions, i.e., the weakest sufficient condition of the observation (Lin, 2001). The notions of strongest necessary and weakest sufficient conditions of a proposition also have many potential applications in other areas such as reasoning about actions. The following proposition, which is due to Lin (2001), shows how to compute the two conditions.\nProposition 6 Given a background knowledge base {θ} over V , a formula α over V , and a subset V ′ of V . Let SNCα and WSCα be a strongest necessary condition and a weakest sufficient condition of α over V ′ under {θ} respectively. Then\n• WSCα is equivalent to ∀(V − V ′)(θ ⇒ α); and • SNCα is equivalent to ∃(V − V ′)(θ ∧ α)."
    }, {
      "heading" : "2.3 Epistemic Logic and Kripke Structure",
      "text" : "We now recall some standard concepts and notations related to the modal logics for multiagents’ knowledge.\nGiven a set V of propositional variables. Let L(V ) be the set of all propositional formulas on V . The language of epistemic logic, denoted by Ln(V ), is L(V ) augmented with modal operator Ki for each agent i. Kiφ can be read “agent i knows φ ”. Let LCn (V ) be the language of Ln(V ) augmented with modal operator C∆ for each set of agents ∆. A formula C∆α indicates that it is common knowledge among agents in ∆ that α holds. We omit the argument V and write Ln and LCn , if it is clear from context.\nAccording to the paper by Halpern and Moses (1992), semantics of these formulas can be given by means of Kripke structure (Kripke, 1963), which formalizes the intuition behind possible worlds. A Kripke structure is a tuple (W,π,K1, · · · ,Kn), where W is a set of worlds, π associates with each world a truth assignment to the propositional variables, so that π(w)(p) ∈ {true, false} for each world w and propositional variable p, and K1, · · · ,Kn are binary accessibility relations. By convention, WM , KMi and πM are used to refer to the set W of possible worlds, the Ki relation and the π function in the Kripke structure M , respectively. We omit the superscript M if it is clear from context. Finally, let C∆ be the transitive closure of ⋃ i∈∆Ki.\nA situation is a pair (M, w) consisting of a Kripke structure and a world w in M . By using situations, we can inductively give semantics to formulas as follows: for primitive propositions p,\n(M, w) |= p iff πM (w)(p) = true.\nConjunctions and negations are dealt with in the standard way. Finally, (M, w) |= Kiα iff for all w′ ∈ W such that wKMi w′, we have that (M, w′) |= α; and (M, w) |= C∆α iff for all w′ ∈ W such that wCM∆ w′, we have that (M, w′) |= α. We say a formula α is satisfiable in Kripke structure M if (M, w) |= α for some possible world w in Kripke structure M . A Kripke structure M is called an S5n Kripke structure if, for every i, KMi is an equivalence relation. A Kripke structure M is called a finite Kripke structure if the set of possible worlds is finite. According to the work of Halpern and Moses (1992), we have the following lemma.\nLemma 7 If a formula is satisfiable in an S5n Kripke structure, then so is in a finite S5n Kripke structure."
    }, {
      "heading" : "3. Knowledge and Weakest Sufficient Conditions",
      "text" : "In our framework, a knowledge structure is a simple model of reasoning about knowledge. The advantage of this model is, as will be shown later, that agents’ knowledge can be computed via the operation of variable forgetting."
    }, {
      "heading" : "3.1 Knowledge Structure",
      "text" : "Definition 8 A knowledge structure F with n-agents is a (n + 2)-tuple (V, Γ, O1, · · · , On) where (1) V is a set of propositional variables; (2) Γ is a consistent set of propositional formulas over V ; and (3) for each agent i, Oi ⊆ V .\nThe variables in Oi are called agent i’s observable variables. An assignment that satisfies Γ is called a state of knowledge structure F . Given a state s of F , we define agent i’s local state at state s as s ∩Oi. Two knowledge structures are said to be equivalent if they have the same set of propositional variables, the same set of states and, for each agent i, the same set of agent i’s observable variables.\nA pair (F , s) of knowledge structure F and a state s of F is called a scenario. Given a knowledge structure (V, Γ, O1, · · · , On) and a set V of subsets of V , we use EV to denote a relation between two assignments s, s′ on V satisfying Γ such that (s, s′) ∈ EV iff there exists a P ∈ V with s ∩ P = s′ ∩ P . We use E∗V to denote the transitive closure of EV .\nLet V∆ = {Oi | i ∈ ∆}. We then have that (s, s′) ∈ EV∆ iff there exists an i ∈ ∆ with s ∩Oi = s′ ∩Oi.\nA simple instance of knowledge structure is F0 = ({p, q}, {p ⇒ q}, {p}, {q}), where p, q are propositional variables. There are two agents for knowledge structure F0. Variables p and q are observable to agents 1 and 2, respectively. We have that V{1,2} = {{p}, {q}}; and for any two subsets s and s′ of {p, q} that satisfy p ⇒ q, we have that (s, s′) ∈ E∗V{1,2} .\nWe now give the semantics of language LCn based on scenarios.\nDefinition 9 The satisfaction relationship |= between a scenario (F , s) and a formula ϕ is defined by induction on the structure of ϕ.\n1. For each propositional variable p, (F , s) |= p iff s |= p. 2. For any formulas α and β, (F , s) |= α ∧ β iff (F , s) |= α and (F , s) |= β; and\n(F , s) |= ¬α iff not (F , s) |= α. 3. (F , s) |= Kiα iff for all s′ of F such that s′ ∩Oi = s ∩Oi, (F , s′) |= α. 4. (F , s) |= C∆α iff (F , s′) |= α for all s′ of F such that (s, s′) ∈ E∗V∆ .\nWe say that a proposition formula in L(V ) is i-local if it is over Oi. Clearly, agent i knows an i-local formula ϕ in F iff Γ |= ϕ.\nLet F = (V, Γ, O1, · · · , On) be a knowledge structure. We say that a formula α is realized in knowledge structure F , if for every state s of F , (F , s) |= α. For convenience, by F |= α, we denote formula α is realized in knowledge structure F .\nWe conclude this subsection by the following lemma, which will be used in the remains of this paper.\nLemma 10 Let V be a finite set of variables, F = (V, Γ, O1, · · · , On) be a knowledge structure, and s be a state of F . Also suppose that ∆ ⊆ {1, · · · , n}, and V∆ = {Oi | i ∈ ∆}. Then\n1. for any objective formula ψ (i.e., propositional formula over V ), (F , s) |= ψ iff s |= ψ; 2. for any formula γ ∈ Γ, (F , s) |= γ; 3. for any i-local formula β, (F , s) |= Kiβ ⇔ β; 4. for any formula β, if there exists, for each i ∈ ∆, an i-local formula logically equivalent\nto β under Γ, then (F , s) |= C∆β ⇔ β; 5. for any formulas α1 and α2, (F , s) |= Ki(α1 ⇒ α2) ⇒ (Kiα1 ⇒ Kiα2); 6. for any formulas α1 and α2, (F , s) |= C∆(α1 ⇒ α2) ⇒ (C∆α1 ⇒ C∆α2); 7. for any formula α and i ∈ ∆, (F , s) |= C∆α ⇒ KiC∆α.\nProof:\n1. The first item of this proposition can be proved by induction on the structure of ψ. When ψ is a primitive proposition, it is done by the first item of Definition 9. When ψ is of the form of negation or conjunction, the conclusion also follows immediately by the first item of Definition 9.\n2. The second item of this proposition can be proved by the first item and the fact s satisfies Γ.\n3. Given an i-local formula β, it suffices to show (F , s) |= Kiβ iff (F , s) |= β. By the first item of this proposition, we have that (F , s) |= β iff s |= β. Moreover, as β is i-local or over Oi, for all assignments s′ with s′ ∩ Oi = s ∩ Oi, we have that s′ |= β iff s |= β. Therefore, we get the following three “iff”s: (F , s) |= Kiβ iff, for all state s′ of F with s′ ∩ Oi = s ∩ Oi, we have that (F , s′) |= β iff, for all state s′ of F with s′ ∩Oi = s ∩Oi, we have that s′ |= β iff s |= β. Thus, (F , s) |= Kiβ iff (F , s) |= β.\n4. Suppose that, for each i ∈ ∆, there exists an i-local formula logically equivalent to β under Γ. We need to show (F , s) |= C∆β ⇔ β. First, because (s, s) ∈ EV∆ ⊆ E∗V∆ , for all formula α, we have that (F , s) |= C∆α implies (F , s) |= α. Therefore, it suffices to prove that (F , s) |= β ⇒ C∆β. Assume (F , s) |= β. To prove that (F , s) |= C∆β, we need to show that for every assignment s′ such that (s, s′) ∈ E∗V∆ , (F , s′) |= β. From the definition of E∗V∆ , it suffices to show that for every finite sequence of assignments s0, · · · , sk with s0 = s and (sj , sj+1) ∈ EV∆ (0 ≤ j < k), we have that for every j ≤ k, (F , sj) |= β. We show this by induction on j. When j = 0, the result is clearly true. Assume (F , sj) |= β. Now we prove (F , sj+1) |= β. Because (sj , sj+1) ∈ EV∆ , there is an i ∈ ∆ such that Oi ∩ sj = Oi ∩ sj+1. On the other hand, we have that sj |= β iff sj+1 |= β because β is equivalent under Γ to an i-local formula. Hence, (F , sj+1) |= β as desired.\n5. It suffice to show that if (F , s) |= Ki(α1 ⇒ α2) and (F , s) |= Kiα1, then (F , s) |= Kiα2. Assume that (F , s) |= Ki(α1 ⇒ α2) and (F , s) |= Kiα1, by item 3 of Definition 9 we get that, for all s′ of F with s′ ∩Oi = s ∩Oi, we have (F , s′) |= (α1 ⇒ α2) and (F , s′) |= α1. However, by item 2 of Definition 9, we get (F , s′) |= α2 from (F , s′) |= (α1 ⇒ α2) and (F , s′) |= α1. Therefore, we get that, for all s′ of F with s′ ∩Oi = s ∩Oi, we have (F , s′) |= α2. It follows immediately that (F , s) |= Kiα2.\n6. This item can be shown in the same way as in the proof of item 5.\n7. It suffices to prove that for those state s′′ such that there is a state s′ with s ∩ Oi = s′ ∩Oi and s′E∗V∆s′′, we can get sE∗V∆s′′, which follows immediately from the fact thatE∗V∆ is the transitive closure of EV∆ . 2"
    }, {
      "heading" : "3.2 Relationship with S5 Kripke Structure",
      "text" : "Given a knowledge structure F = (V, Γ, O1, · · · , On), let M(F) be Kripke structure (W,π,K1, · · · ,Kn), where\n1. W is the set of all states of F ; 2. for each w ∈ W , the assignment π(w) is the same as w; and 3. for each agent i and assignments w, w′ ∈ W , we have that wKiw′ iff w∩Oi = w′ ∩Oi. The following proposition indicates that a knowledge structure can be viewed as a spe-\ncific Kripke structure.\nProposition 11 Given a knowledge structure F , a state s of F , and a formula α in LCn (V ), we have that (F , s) |= α iff (M(F), s) |= α. Proof: Immediately by the definition of the satisfaction relationship between a scenario and a formula and that between a situation and a formula. 2\nFrom Proposition 11, we conclude that if a formula in LCn is satisfiable in some knowledge structure, then the formula is also satisfiable in some Kripke structure. From the following proposition and Lemma 7, we can get that if a formula in LCn is satisfiable in some Kripke structure, then the formula is also satisfiable in some knowledge structure.\nProposition 12 For a finite S5n Kripke structure M with the propositional variable set V and possible world w in M , there exists a knowledge structure FM and a state sw of F such that, for every formula α ∈ LCn (V ), we have that (FM , sw) |= α iff (M, w) |= α.\nProof: Let M = (W,π, R1, · · · , Rn), where W is a finite set and R1, · · · , Rn are equivalence relations. Let O1, · · · , On be sets of new propositional variables such that\n1. O1, · · · , On are finite and pairwise disjoint; and 2. for each i (0 < i ≤ n), the number of all subsets of Oi is not less than that of all\nequivalence classes of Ri.\nBy the latter condition, there is, for each i, a function gi: W 7→ 2Oi such that for all w1, w2 ∈ W , gi(w1) and gi(w2) are the same subset of Oi iff w1 and w2 are in the same equivalence class of Ri.\nLet V ′ = V ∪⋃0<i≤n Oi. We define a function g : W 7→ 2V ′ as follows. For each possible\nworld w in W , g(w) = {v ∈ V | π(w)(v) = true} ∪ ⋃\n0<i≤n gi(w).\nThe following two claims hold:\nC1 For all w1, w2 ∈ W , and i (0 < i ≤ n), we have that g(w1) ∩ Oi = g(w2) ∩ Oi iff w1Riw2.\nC2 For all w ∈ W and v ∈ V , we have that v ∈ g(w) iff π(w)(v) = true. Let\nΓM = {α | α is over V ′, and g(w) |= α for all w ∈ W}. We then get the knowledge structure\nFM = (V ′,ΓM , O1, · · · , On).\nWe now show the following claim:\nC3 For every s ⊆ V ′, s is a state of FM iff s = g(w) for some w ∈ W. The “if” part of claim C3 is easy to prove. If s = g(w′) for some w′ ∈ W , then by the definition of ΓM , we have that g(w′) |= ΓM and hence g(w′) is a state of FM . To show the “only if” part, assume that for every w ∈ W , s 6= g(w). Then, for every w ∈ W , there exists αw over V ′ such that s |= αw but g(w) |= ¬αw. Therefore, s |= ∧ w∈W αw.\nMoreover, we have that, for every w′ ∈ W , g(w′) |= ∨w∈W ¬αw, and hence ∨\nw∈W ¬αw ∈ ΓM . Consequently, we have that s 6|= ΓM and hence s is not a state of FM .\nTo complete the proof, it suffices to show, for every α ∈ LCn (V ), that (FM , g(w)) |= α iff (M, w) |= α. With conditions C1, C2 and C3, we can do so by induction on α. For the base case, we assume α is a propositional variable, say p. Then, by condition C2, we have that (FM , g(w)) |= p iff p ∈ g(w) iff π(w)(p) = true iff (M, w) |= p.\nSuppose that α is not a propositional variable and the claim holds for every subformula of α. There are three cases:\n1. α is of form ¬β or β ∧ γ. This case can be dealt with by the definitions of satisfaction relations directly.\n2. α is of form Kiβ. In this case, we have (FM , g(w)) |= Kiβ iff (FM , s) |= β for all states s of FM with g(w) ∩Oi = s ∩Oi. By condition C3, we have that (FM , g(w)) |= Kiβ iff (FM , g(w′)) |= β for all w′ ∈ W with g(w) ∩ Oi = g(w′) ∩ Oi. By condition C1, we then have (FM , g(w)) |= Kiβ iff (FM , g(w′)) |= β for all w′ ∈ W with wRiw′. Therefore, by the induction assumption, we have (FM , g(w)) |= Kiβ iff (M, w′) |= β for all w′ ∈ W with wRiw′. The right part is just (M, w) |= Kiβ.\n3. α is of form C∆β. Recall that, for arbitrary two states s and s′ of FM , (s, s′) ∈ EV∆ iff there exists an i ∈ ∆ with s ∩Oi = s′ ∩Oi. By condition C1, for all w1, w2 ∈ W ,\n(g(w1), g(w2)) ∈ EV∆ iff (w1, w2) ∈ ⋃\ni∈∆ Ri.\nAs E∗V∆ is the transitive closure of EV∆ , and CM∆ is that of ⋃\ni∈∆ Ri, by condition C3 we get that (g(w1), g(w2)) ∈ E∗V∆ iff (w1, w2) ∈ CM∆ for all w1, w2 ∈ W .\nWe want to show that (FM , g(w)) |= C∆β iff (M, w) |= C∆β. On one hand, (FM , g(w)) |= C∆β iff for all states s of FM with (g(w), s) ∈ E∗V∆ , (FM , s) |= β. By condition C3, we have that (FM , g(w)) |= C∆β iff for all w′ ∈ W with (g(w), g(w′)) ∈ E∗V∆ . On the other hand, (M, w) |= C∆β iff for all w′ ∈ W with (w, w′) ∈ CM∆ . Therefore, we conclude that (FM , g(w)) |= C∆β iff (M, w) |= C∆β by the above discussion. 2\nPropositions 11 and 12 show that the satisfiability issue for a formula in the language of multi-agent S5 with the common knowledge modality is the same whatever satisfiability is meant w.r.t. a standard Kripke structure or w.r.t. a knowledge structure."
    }, {
      "heading" : "3.3 Knowledge as Weakest Sufficient Conditions",
      "text" : "The following theorem establishes a bridge between the notion of knowledge and the notion of weakest sufficient and strongest necessary conditions.\nTheorem 13 Let V be a finite set of variables, F = (V, Γ, O1, · · · , On) a knowledge structure, α a propositional formula in L(V ), and for an agent i, WSCαi and SNCαi a weakest sufficient condition and a strongest necessary condition of α over Oi under Γ respectively. Then, for each state s of F ,\n(F , s) |= Kiα ⇔ WSCαi and\n(F , s) |= ¬Ki¬α ⇔ SNCαi . Proof: We only show (F , s) |= Kiα ⇔ WSCαi , while the other part comes in a straightforward way by duality between WSCs and SNCs. Because WSCαi is a sufficient condition of α under Γ, we have Γ |= WSCαi ⇒ α. Let θ be the conjunction of all formulas in Γ, then we have |= θ ⇒ (WSCαi ⇒ α), which leads to (F , s) |= KiWSCαi ⇒ Kiα (by item 5 of Lemma 10.) Because WSCαi is i-local, by Lemma 10 (item 3) again, we have (F , s) |= WSCαi ⇒ KiWSCαi . Hence, (F , s) |= WSCαi ⇒ Kiα.\nTo show the other direction (F , s) |= Kiα ⇒ WSCαi , we consider the formula ∀(V − Oi)(θ ⇒ α), where θ is the same as above. By Proposition 6, we have Γ |= ∀(V −Oi)(θ ⇒ α) ⇒ WSCαi . On the other hand, we know that (F , s) |= Kiα ⇒ ∀(V −Oi)(θ ⇒ α) by the definition of Kiα. This proves (F , s) |= Kiα ⇒ WSCαi . 2\nThe following corollary characterizes the subjective formulas Kiα (where α is objective) which are satisfied in a given knowledge structure.\nCorollary 14 Let V be a finite set of variables, F = (V, {θ}, O1, · · · , On) a knowledge structure with n agents, and α a formula over V . Then, for every state s of F ,\n(F , s) |= Kiα ⇔ ∀(V −Oi)(θ ⇒ α). Proof: Immediately by Theorem 13 and Proposition 6. 2\nExample 15 : Now we consider the communication scenario between Alice and Bob addressed in section 1 once again. To show how our system can deal with the knowledge reasoning issue in this scenario, we define a knowledge structure F as follows:\nF = (V, {θ}, OA, OB),\nwhere\n• OA = {Alice send msg, Alice recv ack},\n• OB = {Bob recv msg, Bob send ack},\n• V = OA ∪OB, and\n• θ is the conjunction of the following three formulas:\nBob recv msg ⇒ Alice send msg, Bob send ack ⇒ Bob recv msg, Alice recv ack ⇒ Bob send ack,\nNow given a state of F\ns =    Alice send msg, Alice recv ack, Bob recv msg, Bob send ack    ,\nwe would like to know whether Alice knows that Bob received the message. Consider the formula\n∀ {\nBob recv msg, Bob send ack\n} (θ ⇒ Bob recv msg).\nFrom Definition 1, the above formula is simplified as Alice recv ack, which, obviously, is satisfied in the scenario (F , s), i. e. ,\n(F , s) |= Alice recv ack.\nThen from Corollary 14, we have\n(F , s) |= KABob recv msg. From item 3 of lemma 10, it follows that\n(F , s) |= KAAlice send msg\nand (F , s) |= KAAlice recv ack,\nwhich indicates that Alice knows that she sent the message and she knows that she received acknowledgement from Bob. 2\nGiven a set of states S of a knowledge structure F and a formula α, by (F , S) |= α, we mean that for each s ∈ S, (F , s) |= α. The following proposition presents an alternative way to compute an agent’s knowledge.\nProposition 16 Let V be a finite set of variables, F = (V, Γ, O1, · · · , On) a knowledge structure with n agents, ψ a formula over V , and α a formula in LCn . Suppose that SNCψi is a strongest necessary condition of ψ over Oi under Γ, Sψ denotes the set of those states s of F such that (F , s) |= ψ, and S\nSNCψi denotes the set of those states s such that (F , s) |=\nSNCψi . Then, for each agent i, we have that\n(F , Sψ) |= Kiα iff (F , SSNCψi ) |= α.\nProof: Let S1 be the set of all states s satisfying (F , s) |= ∃(V − Oi)(θ ∧ ψ). Because Γ |= SNCψi ⇔ ∃(V −Oi)(θ∧ψ), we have S1 = SSNCψi . Also it is easy to see that for state s of F , s ∈ S1 iff there is a state s′ of F such that s′ |= ψ and s∩Oi = s′ ∩Oi. Therefore we have (F , Sψ) |= Kiα iff S1 ⊆ {s | (F , s) |= α}. This leads to (F , Sψ) |= Kiα iff (F , S1) |= α iff (F , S\nSNCψi ) |= α. 2\nThe intuitive meaning behind Proposition 16 is that if all we know about the current state is ψ, then all we know about agent i’s knowledge (or agent i’s observations) is the strongest necessary condition of ψ over Oi.\nThe following proposition provides a method to determined whether a formula with the nested depth of knowledge operators (like Ki1 · · ·Kikα, where α is a propositional formula) is always true in those states, where a given proposition formula ψ is true.\nProposition 17 Let V be a finite set of variables, F = (V, {θ}, O1, · · · , On) a knowledge structure with n agents, α and ψ two formulas over V , and Sψ denotes the set of states s of F such that (F , s) |= ψ. Then, for each group of agents i1, · · · , ik, we have (F , Sψ) |= Ki1 · · ·Kikα holds iff |= θ ∧ ψk ⇒ α where ψk is defined inductively as follows:\nψ1 = ∃(V −Oi1)(θ ∧ ψ);\nand for each j < k, ψj+1 = ∃(V −Oij+1)(θ ∧ ψj).\nProof: We show this proposition by induction on the nested depth of knowledge operations. The base case is implied directly by Proposition 16. Assume that the claim holds for those cases with nested depth k, we want to show it also holds when the nested depth is k + 1, i. e. , (F , Sψ) |= Ki1 · · ·Kik+1α iff |= θ ∧ ψk+1 ⇒ α. By Proposition 16, we have\n(F , Sψ) |= Ki1 · · ·Kik+1α iff (F , Sψ1) |= Ki2 · · ·Kik+1α. By the inductive assumption, we have that\n(F , Sψ1) |= Ki2 · · ·Kik+1α iff |= θ ∧ ψk+1 ⇒ α.\nCombining two assertions above, we get\n(F , Sψ) |= Ki1 · · ·Kik+1α iff |= θ ∧ ψk+1 ⇒ α. 2\nWhen we consider the case where the nested depth of knowledge operators is no more than 2, we get the following corollary.\nCorollary 18 Let V,F , α, ψ and Sψ be as in Proposition 17. Then, for each agent i and each agent j, we have\n1. (F , Sψ) |= Kiα holds iff |= (θ ∧ ∃(V −Oi)(θ ∧ ψ)) ⇒ α;\n2. (F , Sψ) |= KjKiα holds iff |= (θ ∧ ∃(V −Oi)(θ ∧ ∃(V −Oj)(θ ∧ ψ))) ⇒ α.\nProof: Immediately from Proposition 17. 2\nAs will be illustrated in our analysis of security protocols (i.e. Section 6), the part 2 of Corollary 18 is useful for verifying protocol specifications with nested knowledge operators. Given a background knowledge base θ, when we face the task of testing whether KjKiα holds in those states satisfying ψ, by part 2 of Corollary 18, we can first get φ1 = ∃(V −Oj)(θ∧ψ), which is a strongest necessary condition of ψ over Oj . This is all we know about what agent j observes from ψ. Then we compute φ2 = ∃(V −Oi)(θ∧φ1), i. e. , the strongest necessary condition of φ1 over Oi which is, from the viewpoint of agent j, about what agent i observes. In this way, the task of checking KjKiα is reduced to a task of checking θ ∧ φ2 ⇒ α.\nThe following corollary gives two methods to check the truth of Kiα (where α is a propositional formula) in all those states where a given formula ψ is true. One is via the strongest necessary condition of ψ and the other is via the weakest sufficient condition of α.\nCorollary 19 Let V be a finite set of propositional variables and F = (V, {θ}, O1, · · · , On) a knowledge structure with n agents, α and ψ two formulas over V . Suppose that Sψ denotes the set of all states s of F such that (F , s) |= ψ, and SNCψi and WSCαi are a strongest necessary condition of ψ over Oi and a weakest sufficient condition of α over Oi under {θ} respectively. Then\n1. (F , Sψ) |= Kiα iff |= (θ ∧ ψ) ⇒ WSCαi ; and 2. (F , Sψ) |= Kiα iff |= (θ ∧ SNCψi ) ⇒ α.\nProof: The first part of the corollary follows from Theorem 13 and Lemma 10, while the second part follows immediately by Proposition 16. 2\nIn our analysis of security protocols, we observe that very often, it seems more efficient to check an agent’s knowledge via the second part of Corollary 19 rather than via the first part. But this may not be always true for some other applications (e.g. see the example of the muddy children puzzle in the next section)."
    }, {
      "heading" : "4. Common Knowledge",
      "text" : "Common knowledge is a special kind of knowledge for a group of agents, which plays an important role in reasoning about knowledge (Fagin et al., 1995). A group of agents ∆ commonly know ϕ when all the agents in ∆ know ϕ, they all know that they know ϕ, they all know that they all know that they know ϕ, and so on ad infinitum. We recall that common knowledge can be characterized in terms of Kripke structures. Given a Kripke structure M = (W,π,K1, · · · ,Kn), a group ∆ of agents commonly know ϕ ( or in modal logic language, C∆ϕ is true ) in a world w iff ϕ is true in all worlds w′ such that (w, w′) ∈ C∆, where C∆ denotes the transitive closure of ⋃ i∈∆Ki.\nIn this section, we generalize the concept of weakest sufficient and strongest necessary conditions so that they can be used to compute common knowledge."
    }, {
      "heading" : "4.1 Generalized Weakest Sufficient and Strongest Necessary Conditions",
      "text" : "The following gives a generalized notion of weakest sufficient conditions and strongest necessary conditions.\nDefinition 20 Given a set of formulas Γ over V as a background knowledge base. Let α be a formula over V , and V a nonempty set of subsets of V .\n• A formula ϕ is called V-definable under Γ (or simply called V-definable if there is no confusion in the context), if for each P ∈ V, there is a formula ψP over P such that Γ |= ϕ ⇔ ψP .\n• A formula ϕ is called a V-sufficient condition of α under Γ if it is V-definable and Γ |= ϕ ⇒ α. It is called a weakest V-sufficient condition of α under Γ if it is a V-sufficient condition of α under Γ, and for any other V-sufficient condition ϕ′ of α under Γ, we have Γ |= ϕ′ ⇒ ϕ.\n• Similarly, formula ϕ is called a V-necessary condition of α under Γ if it is V-definable and Γ |= α ⇒ ϕ. It is called a strongest V-necessary condition of α under Γ if it is a V-necessary condition of α under Γ, and for any other V-necessary condition ϕ′ of α under Γ, we have Γ |= ϕ ⇒ ϕ′.\nWe notice that the notion of V-definability introduced here is a simple elaboration of the notion of V-definability as given in the work of Lang and Marquis (1998): φ is V-definable under Γ iff φ is V -definable under Γ for each V ∈ V. Moreover, it is easy to see that the formulas implied by Γ or inconsistent with it are exactly the formulas ∅-definable under Γ, and that definability exhibits a monotonicity property: if φ is V -definable under Γ, then φ is V ′-definable under Γ for each superset V ′ of V (Lang & Marquis, 1998). Observe also that φ is V -definable under Γ iff ¬φ is V -definable under Γ, and this extends trivially to V-definability.\nThe following lemma says that the notions of weakest V-sufficient conditions and strongest V-necessary ones are dual to each other.\nLemma 21 Given a set of formulas Γ over V as a background knowledge base, and V a set of subsets of V . Let ϕ and α be formulas over V . Then, we have that ϕ is a weakest\nV-sufficient condition of α under Γ iff ¬ϕ is a strongest V-necessary condition of ¬α under Γ.\nProof: Straightforward by the duality between WSCs and SNCs. 2\nTo give some intuition and motivation of the above definition, let us consider the following example.\nExample 22: Imagine that there are two babies, say Marry and Peter, playing with a dog. Suppose the propositions “The dog is moderately satisfied” (denoted by m, for short) and “The dog is full”(f) are understandable to Marry, and the propositions “The dog is hungry” (h) and “The dog is unhappy”(u) are understandable to Peter.\nLet Γ = {h ⇒ u,¬(m∧ f), (m∨ f) ⇔ ¬h}, V1 = {m, f}, V2 = {h, u}, and V = {V1, V2}. We will show that\n1. h is V-definable under Γ;\n2. h is a weakest V-sufficient condition of u under Γ; and\n3. ¬h is a strongest V-necessary condition of ¬u under Γ.\nThe first claim is easy to check by the definition. The last two claims follow immediately if we can prove that all the V-definable propositions under Γ are false, true, h and ¬h (up to logical equivalence under Γ). There are 8 propositions over V1 up to logical equivalence. The 8 propositions are: true, false, m,¬m, f,¬f,m ∨ f,¬m ∧ ¬f . Similarly, there are 8 propositions over V2 up to logical equivalence under Γ, i.e., true, false, h,¬h, u,¬u, h ∨ ¬u,¬h ∧ u. However, we can find, between the two classes of propositions, only 4 pairs of equivalence relations under Γ, i.e., Γ |= true ⇔ true, Γ |= false ⇔ false, Γ |= (m ∨ f) ⇔ ¬h, Γ |= (¬m ∧ ¬f) ⇔ h. Therefore, all the V-definable propositions under Γ are false, true, h and ¬h (up to logical equivalence under Γ). 2\nExample 23: Now we recall the background knowledge ΓCS about the communication scenario between Alice and Bob in the introduction section. ΓCS is the set of the following three formulas:\nBob recv msg ⇒ Alice send msg Bob send ack ⇒ Bob recv msg Alice recv ack ⇒ Bob send ack\nLet OA = {Alice send msg, Alice recv ack}, OB = {Bob recv msg, Bob send ack}, VAB = {OA, OB}.\nClearly, if a formula ϕ is logically implied by ΓCS or inconsistent with ΓCS , then ϕ is VAB-definable under ΓCS . Moreover, as in Example 22, we are able to check that there are no VAB-definable formulas other than those implied by ΓCS or inconsistent with ΓCS . Therefore, given a formula α, a weakest VAB-sufficient condition of α under ΓCS is implied by ΓCS if ΓCS |= α, or inconsistent with ΓCS . 2\nLet Γ be a set of formulas, V a set of propositional variables, and V a set of subsets of V . The following proposition gives the existence of weakest V-sufficient and strongest V-necessary conditions. For a given formula α over V , a weakest V-sufficient condition φ1 of α and a strongest V-necessary condition φ2 of α can be obtained in the proposition. Indeed, the set of assignments satisfying φ1 and that of assignments satisfying φ2 can be given in terms of relation EV . Proposition 24 Given a finite set V of propositional variables, a set Γ of formulas over V as a background knowledge base, a formula α over V , and a set V of subsets of V . Denote by SαWSC the set of assignments s over V such that s |= Γ, and for all assignments s′ satisfying Γ with (s, s′) ∈ E∗V , s′ |= α. Also denote by SαSNC the set of assignments s over V such that s |= Γ, and there exists an s′ such that s′ |= Γ, s′ |= α and (s, s′) ∈ E∗V . Then, the following two points hold.\n• If a formula is satisfied exactly by those assignments in SαWSC , then the formula is a weakest V-sufficient condition of α under Γ; and\n• If a formula is satisfied exactly by those assignments in SαSNC , then the formula is a strongest V-necessary condition of α under Γ.\nProof: We first prove the former point, and then show the other by Lemma 21. Let φ1 be a propositional formula over V such that, for all assignments s, s |= φ1 iff s ∈ SαWSC . Then, for every assignment s ∈ SαWSC , we have s |= α because (s, s) ∈ E∗V . Thus, φ1 |= α.\nWe remark that for arbitrarily given formula ϕ over V and assignment s over V , s |= ∀(V − P )ϕ iff for all assignments s′ over V such that s ∩ P = s′ ∩ P , we have s′ |= ϕ.\nTo prove that φ1 is V-definable, we show that, for each P ∈ V, φ1 |= ∀(V −P )φ1, which implies that φ1 is equivalent to the formula ∀(V −P )φ1 over P . To prove φ1 |= ∀(V −P )φ1, in a semantical way, it suffices to show that, for every assignment s ∈ SαWSC and s′ |= Γ, if s∩P = s′ ∩P , then s′ ∈ SαWSC . Let s and s′ be given as above and suppose s∩P = s′ ∩P . Then, (s, s′) ∈ EV . Given an assignment t such that t |= Γ, if (s′, t) ∈ E∗V , then (s, t) ∈ E∗V by (s, s′) ∈ EV . Thus, s′ ∈ SαWSC . This proves that φ1 is V-definable.\nNow we show that φ1 is a weakest V-sufficient condition under Γ. Suppose φ is a Vdefinable and sufficient condition of α under Γ, we want to prove that Γ |= φ ⇒ φ1. The semantical argument of such a proof is as follows. Let s be an assignment with s |= Γ and φ, we must show that s ∈ SαWSC , i.e., for every assignment s′ with s′ |= Γ such that (s, s′) ∈ E∗V , s′ |= α. Because Γ |= φ ⇒ α, it suffices to show that s′ |= φ. By the condition (s, s′) ∈ E∗V , there is a finite sequence of assignments s0, · · · , sk such that sj |= Γ with s0 = s and sk = s′, and for every j < k, (sj , sj+1) ∈ EV . By the V-definability of φ, we know that for every j < k, sj |= φ implies sj+1 |= φ. Thus, we have s′ |= φ by induction.\nNow we prove the second point of this proposition by Lemma 21. Let φ2 be a propositional formula over V such that, for all assignments s, s |= φ2 iff s ∈ SαSNC . Let θ be the conjunction of formulas in Γ. Then, s |= ¬φ2 ∧ θ iff for all assignments s′ with s′ |= Γ such that sE∗Vs′, we have s′ |= ¬ϕ. Thus, by the first point of this proposition, we have that ¬φ2 ∧ θ is a weakest V-sufficient condition of ¬α. Thus, φ2 ∨¬θ and hence φ2 is a strongest V-necessary condition of α according to Lemma 21. 2\nThe above proposition can be thought of as a semantical characterization of weakest V-sufficient and strongest V-necessary conditions."
    }, {
      "heading" : "4.2 Characterizations with Least and Greatest Fixed Points",
      "text" : "We investigate the computation of the weakest V-sufficient and strongest V-necessary conditions by using the notions of a least and a greatest fixed points of an operator, which is introduced as follows. Let V be a set of propositional variables, and Λ be an operator (or a mapping) from the set of propositional formulas over V to the set of propositional formulas over V . We say a ψ is a fixed point of Λ, if |= Λ(ψ) ⇔ ψ. We say a ψ0 is a greatest fixed point of Λ, if ψ0 is a fixed point of Λ and for every fixed point ψ of Λ, we have |= ψ ⇒ ψ0. Clearly, any two greatest fixed points are logically equivalent to each other. Thus, we denote a greatest fixed point of Λ by gfpZΛ(Z). Similarly, we say a ψ0 is a least fixed point of Λ, if ψ0 is a fixed point of Λ and for every fixed point ψ of Λ, we have |= ψ0 ⇒ ψ. We denote a least fixed point of Λ by lfpZΛ(Z). We say Λ is monotonic, if for every two formulas ψ1 and ψ2 such that |= ψ1 ⇒ ψ2, we have |= Λ(ψ1) ⇒ Λ(ψ2). For a finite set V of propositional variables if Λ is monotonic, then there exists a least fixed point and a greatest fixed point (Tarski, 1955).\nTheorem 25 Let V be a finite set of variables, F = (V, {θ}, O1, · · · , On) a knowledge structure, α a formula over V , ∆ ⊆ {1, · · · , n}, V∆ = {Oi | i ∈ ∆}. Assume that Λ1 and Λ2 are two operators such that\nΛ1(Z) = ∧\ni∈∆ ∀(x−Oi)(θ ⇒ Z)\nand Λ2(Z) = ∨\ni∈∆ ∃(x−Oi)(θ ∧ Z).\nThen,\n• a weakest V∆-sufficient condition of α under {θ} is equivalent to gfp Z(α ∧ Λ1(Z)); and\n• a strongest V∆-necessary condition of α under {θ} is equivalent to lfp Z(α ∨Λ2(Z)). Proof: Let WSCα∆ be a weakest V∆-sufficient condition of α under {θ}. Note that the operator (α ∧ Λ1(Z)) is monotonic and thus there exists a greatest fixed point of it. Let ψ1= gfp Z(α ∧ Λ1(Z)). To prove the first point of this theorem, we must show that θ |= WSCα∆ ⇔ ψ1.\nWe first show that θ |= WSCα∆ ⇒ ψ1. For this purpose, we only need to prove 1. θ |= WSCα∆ ⇒ (α ∧ Λ1(true)); and 2. for all formulas ϕ on V , if θ |= WSCα∆ ⇒ ϕ, then θ |= WSCα∆ ⇒ (α ∧ Λ1(ϕ)).\nThe first point is trivially true because Λ1(true) is equivalent to true and WSCα∆ is a sufficient condition of α under {θ}. To show the second point, suppose θ |= WSCα∆ ⇒ ϕ. For i ∈ ∆, let αi be the formula over Oi such that θ |= WSCα∆ ⇔ αi. Then, θ |= αi ⇒ ϕ. It follows that |= αi ⇒ (θ ⇒ ϕ) and hence |= αi ⇒ ∀(V − Oi)(θ ⇒ ϕ) because αi does not depend on the variables in (V − Oi). So, we have that, for all i ∈ ∆, θ |= WSCα∆ ⇒ ∀(V −Oi)(θ ⇒ ϕ). The conclusion of the second point follows immediately.\nWe now show that θ |= ψ1 ⇒ WSCα∆, or θ |= (θ ⇒ ψ1) ⇒ WSCα∆. It suffices to show that θ ⇒ ψ1 is V∆-sufficient condition of α under {θ}, that is,\n1. θ ⇒ ψ1 is V∆-definable; and 2. θ |= (θ ⇒ ψ1) ⇒ α.\nBy the fact that ψ1 is a fixed point of the operator (α ∧ Λ1(Z)), we have that\n|= ψ1 ⇒ (α ∧ ∧\ni∈∆ ∀(x−Oi)(θ ⇒ ψ1)).\nIt follows that |= ψ1 ⇒ α, and hence θ |= (θ ⇒ ψ1) ⇒ α. To show the other point, for i ∈ ∆, we need to prove that θ ⇒ ψ1 is equivalent to a formula over Oi. By the above, we have that ψ1 ⇒ ∀(V − Oi)(θ ⇒ ψ1). It follows that θ |= (θ ⇒ ψ1) ⇒ ∀(V − Oi)(θ ⇒ ψ1), and hence θ |= (θ ⇒ ψ1) ⇔ ∀(V −Oi)(θ ⇒ ψ1) because |= ∀(V − Oi)(θ ⇒ ψ1) ⇒ (θ ⇒ ψ1) holds trivially. Thus (θ ⇒ ψ1) is equivalent under θ to ∀(V − Oi)(θ ⇒ ψ1), which is over Oi. This completes the first point of the conclusion of the theorem.\nWe now show the second point of this theorem by using the first point and Lemma 21. Let SNCα∆ be a strongest V∆-necessary condition of α under {θ}. By Lemma 21, ¬SNCα∆ is a weakest V∆-sufficient condition of ¬α under {θ}. Thus, by the first point of this theorem, ¬SNCα∆ is equivalent to gfp Z(¬α ∧ Λ1(Z)) under θ. Hence, SNCα∆ is equivalent to ¬gfp Z(¬α ∧ Λ1(Z)) under θ. However, ¬gfp Z(¬α ∧ Λ1(Z)) is logically equivalent to lfp Z(¬(¬α∧Λ1(¬Z))), which is in turn equivalent to lfp Z(α∨Λ2(Z)). This completes the second point of the theorem. 2"
    }, {
      "heading" : "4.3 Common Knowledge as Weakest V-sufficient Conditions",
      "text" : "Given a set ∆ of agents and a family V∆ of observable variable sets of these agents, we investigate the relationship between common knowledge and the weakest V∆-sufficient and strongest V∆-necessary conditions.\nTheorem 26 Let V be a finite set of variables, F = (V, Γ, O1, · · · , On) a knowledge structure, ∆ ⊆ {1, · · · , n}, V∆ = {Oi | i ∈ ∆}, α a formula over V , and WSCα∆ and SNCα∆ a weakest V∆-sufficient condition and a strongest V∆-necessary condition of α under Γ respectively. Then, for every state s of F ,\n(F , s) |= C∆α ⇔ WSCα∆ and\n(F , s) |= ¬C∆¬α ⇔ SNCα∆.\nProof: We only show the first part of this theorem, i.e., (F , s) |= C∆α ⇔ WSCα∆, by which and Lemma 21 we can get the other part immediately. Because WSCα∆ is a sufficient condition of α, we have that Γ |= WSCα∆ ⇒ α. Let θ be the conjunction of all formulas in Γ, we have that |= θ ⇒ (WSCα∆ ⇒ α), which leads to (F , s) |= C∆WSCα∆ ⇒ C∆α (by point 6 of Lemma 10). Because WSCα∆ is V∆-definable, we have, by point 4 of Lemma 10, (F , s) |= WSCα∆ ⇒ C∆WSCα∆. Hence, (F , s) |= WSCα∆ ⇒ C∆α.\nTo show the other direction (F , s) |= C∆α ⇒ WSCα∆, we consider the formula ψ1 in the proof of Theorem 25, i.e., the greatest fixed point of the operator\nΛ(Z) = α ∧ ∧\ni∈∆ ∀(V −Oi)(θ ⇒ Z).\nBecause we already have (F , s) |= ψ1 ⇒ WSCα∆ by Theorem 25, it suffices to show (F , s) |= C∆α ⇒ ψ1. Because the greatest fixed point ψ1 of the operator Λ can be obtained by a finite iteration of the operator with the starting point Λ(true), we only need to prove that\n1. F |= C∆α ⇒ Λ(true); and\n2. for an arbitrary propositional formula ϕ over V , if F |= C∆α ⇒ ϕ, then F |= C∆α ⇒ Λ(ϕ).\nThe first point is trivially true because Λ(true) is equivalent to α. To prove the second, suppose F |= C∆α ⇒ ϕ. Then, for each i ∈ ∆, F |= Ki(C∆α ⇒ ϕ). Thus, we have that F |= C∆α ⇒ Kiϕ by points 5 and 7 of Lemma 10. Hence, F |= C∆α ⇒ ∀(V −Oi)(θ ⇒ ϕ) (by Corollary 14). It follows that F |= C∆α ⇒ ∧ i∈∆ ∀(V − Oi)(θ ⇒ ϕ) and hence F |= C∆α ⇒ Λ(ϕ). We thus get F |= C∆α ⇒ ψ1. This completes the proof. 2\nProposition 27 Given V , F , ∆, V∆, α as defined in Theorem 26. Let ψ be a formula over V . Assume that a strongest V∆-necessary condition of ψ is SNCψ∆. Denote by Sψ the set of those states s of F such that (F , s) |= ψ, and by S\nSNCψ∆ the set of those states s such\nthat (F , s) |= SNCψ∆. Then, we have\n(F , Sψ) |= C∆α iff (F , SSNCψ∆) |= α.\nProof: Let S1 be the set of all states s such that there is a state s′ with s′ |= ψ and (s′, s) ∈ V∆. We have that (F , Sψ) |= C∆α iff for every s ∈ S1, (F , s) |= α. This leads to (F , Sψ) |= C∆α iff (F , S1) |= α. On the other hand, by Proposition 24, we have that S1 = SSNCψ∆ . Then the conclusion of the proposition follows immediately. 2\nNote that, in Proposition 27, if α is a propositional formula, we have that (F , Sψ) |= C∆α iff Γ |= SNCψ∆ ⇒ α. Moreover, by Theorem 26, we have (F , Sψ) |= C∆α iff Γ |= ψ ⇒ WSCα∆, where WSC α ∆ is a weakest V∆-sufficient of α."
    }, {
      "heading" : "5. Adding Public Announcement Operator",
      "text" : "There is a recent trend of extending epistemic logic with dynamic operators so that the evolution of knowledge can be expressed. The most basic such extension is public announcement logic (PAL), which is obtained by adding an operator for truthful public announcements. The original version of PAL was proposed by Plaza (1989). In this section, we show that public announcement operator can be conveniently dealt with via our notion of knowledge structure."
    }, {
      "heading" : "5.1 Public Announcement Logic",
      "text" : "Given a set of agents A = {1, . . . , n} and a set V of propositional variables. The language of public announcement logic (PALn) is inductively defined as\nϕ ::= p|¬ϕ|ϕ ∧ ψ|Kiϕ|C∆ϕ|[ϕ]ψ\nwhere p ∈ V , i ∈ A and ∆ ⊆ A. In other words, PALn is obtained from epistemic logic LCn (V ) by adding public announcement operator [ϕ] for each formula ϕ. Formula [ϕ]ψ means that “after public announcement of ϕ, formula ψ is true.”\nWe now give the semantics of public announcement logic under Kripke model. Given a Kripke structure M = (W,π,K1, . . . ,Kn), the semantics of the new operators is defined as follows.\nM, w |= [ϕ]ψ iff M, w |= ϕ implies M |ϕ, w |= ψ, where M |ϕ is a Kripke structure such that M |ϕ = (W ′, π′,K′1, . . . ,K′n) and\n• W ′ = {w ∈ W |M, w |= ϕ},\n• π′(w′)(p) = π(w′)(p) for each w′ ∈ W ′ and each p ∈ V , and\n• K′i = Ki ∩ (W ′ ×W ′) for each i ∈ A.\nThere are some sentences that become false immediately after the announcement of them. Consider, for example, the sentence ‘p is true but was not commonly known to be true ’. By the announcement of the sentence all agents learn that p and therefore p is commonly known. This can be modelled in public announcement logic by valid formula [ϕ]¬ϕ, where ϕ = p ∧ ¬C∆p. To see its validity, let (M, w) be an arbitrary situation. If M, w |= ϕ,then M, w |= p, which implies that M |ϕ, w |= C∆p, and therefore M |ϕ, w |= ¬ϕ."
    }, {
      "heading" : "5.2 Semantics under Knowledge Structure",
      "text" : "The semantics of public announcement logic can be conveniently characterized by our notion of knowledge structure. We define the satisfaction relationship |= between a scenario (F , s) and a formula in PALn. We need only consider those formulas of the form [ϕ]ψ; other cases are the same as in Definition 9.\nLet V be a finite set of propositional variables and F = (Γ, V,O1, · · · , On). The semantics definition for the new operators is as follows. First, let F|ϕ be the knowledge structure ({θ}, V,O1, · · · , On), where θ is a propositional formula on V such that (F , s) |= ϕ iff s satisfies θ. As V is a finite set, such a propositional formula θ always exists.\nThen, we set that (F , s) |= [ϕ]ψ iff (F , s) |= ϕ implies that (F|ϕ, s) |= ψ. We remark that if formula ϕ is equivalent to propositional one ϕ′ in knowledge structure F , i.e., F |= ϕ ⇔ ϕ′ for some propositional formula ϕ′, then we can simply define F|ϕ as (Γ ∪ {ϕ′}, V,O1, · · · , On).\nThe following proposition indicates that the semantics of public announcement logic under knowledge structure coincides with that under Kripke model.\nProposition 28 (1) Let V be a finite set of propositional variables and F = (Γ, V,O1, · · · , On). For every state s of F and every formula α ∈ PALn, we have that (F , s) |= α iff the situation (M(F), s) |= α. (2) For a finite S5n Kripke structure M and possible world w in M , there is a knowledge structure FM and a state sw of F such that, for every formula α ∈ PALn, we have that (FM , sw) |= α iff (M, w) |= α.\nProof: (1) Let us proceed by induction on the structure of formula α. We consider only the case that α is of the form [ϕ]ψ; other cases are straightforward by the definitions.\nBy the definition, we have that (F , s) |= [ϕ]ψ iff (F , s) |= ϕ implies that (F|ϕ, s) |= ψ. Thus, by the inductive assumption, we have that (F , s) |= [ϕ]ψ iff (M(F), s) |= ϕ implies that (M(F|ϕ), s) |= ψ. We want to show that (F , s) |= [ϕ]ψ iff (M(F), s) |= [ϕ]ψ. It suffices to show that M(F|ϕ) equals M(F)|ϕ because (M(F), s) |= [ϕ]ψ iff (M(F), s) |= ϕ implies that (M(F)|ϕ, s) |= ψ.\nFirst, the set of possible states of M(F|ϕ) equals to the set of those states s′ of F with (F , s′) |= ϕ. By the inductive assumption, (F , s′) |= ϕ iff (M(F), s′) |= ϕ. Thus, the set of possible states of M(F|ϕ) equals to the set of those states s′ of F with (M(F), s′) |= ϕ, hence equals to the set of possible states of M(F)|ϕ. Second, we have that for each s′ of F with (M(F), s′) |= ϕ, πM(F|ϕ)(s′) = s′ and πM(F)|ϕ(s′) = πM(F)(s′) = s′. Hence πM(F|ϕ) = πM(F)|ϕ . Finally, for all states s1 and s2 of F with (M(F), s1) |= ϕ and (M(F), s2) |= ϕ, we have that (s1, s2) ∈ KM(F|ϕ)i iff (s1, s2) ∈ KM(F)i iff s1 ∩ Oi = s2 ∩ Oi. Moreover, (s1, s2) ∈ KM(F)|ϕi iff s1 ∩Oi = s2 ∩Oi. Therefore, KM(F|ϕ)i = KM(F)|ϕi . This completes the proof for M(F|ϕ) = M(F)|ϕ.\n(2) Suppose M = (W0, π0, R1, · · · , Rn), where W0 is a finite set and R1, · · · , Rn are equivalence relations. We assume also that the set of propositional variables is V0.\nLet O1, · · · , On be sets of new propositional variables such that 1. O1, · · · , On are finite and pairwise disjoint; and 2. for each i (0 < i ≤ n), the number of all subsets of Oi is not less than that of all\nequivalence classes of Ri.\nBy the latter condition, there is, for each i, a function gi: W0 7→ 2Oi such that for all w1, w2 ∈ W0, gi(w1) and gi(w2) are the same subset of Oi iff w1 and w2 are in the same equivalence class of Ri.\nLet V = V0∪ ⋃\n0<i≤n Oi. We define a function g : W0 7→ 2V as follows. For each possible world w in W0,\ng(w) = {v ∈ V | π(w)(v) = true} ∪ ⋃\n0<i≤n gi(w).\nThe following two claims hold:\nC1 For all w1, w2 ∈ W0, and i (0 < i ≤ n), we have that g(w1) ∩ Oi = g(w2) ∩ Oi iff w1Riw2.\nC2 For all w ∈ W0 and v ∈ V0, we have that v ∈ g(w) iff π(w)(v) = true. For any W ⊂ W0, let\nΓW = {α | α is over V, and g(w) |= α for all w ∈ W}.\nWe then get a knowledge structure\nFW = (V, ΓW , O1, · · · , On). We now show that following claim:\nC3 For every s ⊆ V , s is a state of FW iff s = g(w) for some w ∈ W. The “if” part of claim C3 is easy to prove. If s = g(w′) for some w′ ∈ W , then by the definition of ΓW , we have that g(w′) |= ΓW and hence g(w′) is a state of FM . To show the “only if” part, assume that for every w ∈ W , s 6= g(w). Then, for every w ∈ W , there exists αw over V such that s |= αw but g(w) |= ¬αw. Therefore, s |= ∧ w∈W αw. Moreover, we have\nthat, for every w′ ∈ W , g(w′) |= ∨w∈W ¬αw, and hence ∨\nw∈W ¬αw ∈ ΓW . Consequently, we have that s 6|= ΓW and hence s is not a state of FW .\nTo complete the proof of the second part, it suffices to show, for every α ∈ PALn, that (FW , g(w)) |= α iff (M |W , w) |= α, where M |W is a Kripke structure such that M |ϕ = (W,π, R′1, . . . , R′n) and\n• π(w)(p) = π0(w)(p) for each w ∈ W and each p ∈ V0, and • R′i = Ri ∩ (W ′ ×W ′) for each i with 0 < i ≤ n. With claims C1, C2 and C3, we can do so by induction on α. Again, we consider only the case that α is of the form [ϕ]ψ; other cases can be dealt with in the same way as the proof of Proposition 12.\nWe first show that knowledge structure FW |ϕ is equivalent to FW ′ , where W ′ = {w′ ∈ W | MW , w |= ϕ}.\nAs the two knowledge structures have the same set V of propositional variables and, for each agent i, the same set Oi of observable variables to agent i, we need only to prove that they have the same set of states. An assignment s on V is a state of FW |ϕ iff s is a state of FW and FW , s |= ϕ. Thus, by claim C3, s is a state of FW |ϕ iff s = g(w′) for some w′ ∈ W with FW , g(w′) |= ϕ. On the other hand, we have, by claim C3 again, that assignment s is a state of FW ′ iff s = g(w′) for some w′ ∈ W ′, i.e., w′ ∈ W and MW , w′ |= ϕ. However, by the induction assumption, FW , g(w′) |= ϕ iff MW , w′ |= ϕ. Therefore, knowledge structures FW |ϕ and FW ′ have the same set of states.\nTo show (FW , g(w)) |= [ϕ]ψ iff (M |W , w) |= [ϕ]ψ, we have, by the induction assumption, that (FW , g(w)) |= ϕ iff (M |W , w) |= ϕ. Also, by the claim we just proved above, we have that (FW |ϕ, g(w)) |= ψ iff (FW ′ , g(w)) |= ψ. By the induction assumption again, (FW ′ , g(w)) |= ψ iff MW ′ , w |= ψ. By the definition of W ′, we have that MW |ϕ, w |= ψ. Hence, (FW |ϕ, g(w)) |= ψ iff MW |ϕ, w |= ψ. Therefore, by the semantics of the announcement operators in Kripke structure and knowledge structure, we have that (FW , g(w)) |= [ϕ]ψ iff (M |W , w) |= [ϕ]ψ. 2\nThe above proposition is a generalization of Propositions 11 and 12 to PALn, which shows that the satisfiability issue for a formula in the language of multi-agent S5 with the announcement operators is the same whatever satisfiability is meant w.r.t. a standard Kripke structure or w.r.t. a knowledge structure.\nNotice that, for every formula in PALn, we can get an equivalent propositional formula. More specifically, we have the following:\nRemark 29 Let V be a finite set of propositional variables and F = ({θ}, V,O1, · · · , On). Given a formula α ∈ PALn, we define a propositional formula bαeθ by induction on the structure of α:\n• If α is a propositional formula, then bαeθ = α.\n• bα ∧ βeθ = bαeθ ∧ bβeθ.\n• bKiαeθ = ∀(V −Oi)(θ ⇒ bαeθ).\n• Let ∆ ⊆ {1, · · · , n}, V∆ = {Oi | i ∈ ∆}. Then\nbC∆αeθ = WSCbαe θ\n∆\nwhere WSCbαe θ\n∆ is a weakest V∆-sufficient condition bαeθ under θ.\n• b[ϕ]αeθ = bαeθ∧bϕeθ\nThen, for every α ∈ PALn, we have that F |= α ⇔ bαeθ."
    }, {
      "heading" : "6. Complexity Results",
      "text" : "We are interested in the following problem: given a knowledge structure F and a formula α in the language of epistemic logic, whether formula α is realized in structure F . This kind of problem is called the realization problem. In this section, we examine the inherent difficulty of the realization problem in terms of computational complexity. In the general case, this problem is PSPACE-Complete; however, for some interesting subset of the language, it can be reduced to co-NP.\nLet L be some epistemic logic (or language). The realization problem for L is, given a knowledge structure F and a formula α ∈ L, to determine whether F |= α holds.\nThe realization problem here is closely related to the model checking problem: given an epistemic formula α and a Kripke structure M , to determine whether M |= α. By checking the definition of Kripke structure semantics for epistemic logic, we can see that the model checking problem can be solved in polynomial time (with respect to the input size (| M | + | α |). We can determine whether a formula α is realized in a knowledge structure F by first translating knowledge structure F into a Kripke structure M then checking M |= α. However, the resulting algorithm will be exponential in space. This is because the size of the corresponding Kripke structure M is exponential with respect to knowledge structure F .\nA number of algorithms for model checking epistemic specifications and the computational complexity of the related realization problems were studied in (van der Meyden, 1998). However, like Kripke structure, the semantics framework they adopt is to list all global states explicitly. As a result, the size of the input of the concerned decision problem can be very large.\nProposition 30 The realization problem for Ln is PSPACE-complete.\nProof: The proposition is of two parts: the PSPACE-easiness and the PSPACE-hardness. The PSPACE-easiness part means that there is an algorithm that determines in polynomial space whether an epistemic formula α ∈ Ln is realized in a knowledge structure F . The PSPACE-completeness indicates that there is a PSPACE-hard problem, say the satisfiability problem for quantified propositional formulas (QBF) (Stockmeyer & Meyer, 1973), can be effectively reduced to the realization problem we consider.\nIt is not difficult to see the PSPACE-easiness. Given a knowledge structure and epistemic formula α, by Corollary 14, we can replace knowledge modalities by propositional quantifiers in formula α. So, the problem of whether α is realized in F is reduced to determine whether a quantified Boolean formulas is valid. The latter can be done in polynomial space (Stockmeyer & Meyer, 1973).\nAs for the PSPACE-hardness, it suffices to show that for every QBF formula\n∀p1∃q2∀p2∃q3 · · · ∀pm−1∃qmA(p1, q2, p2, q3 · · · , pm−1, qm),\nwe can construct a knowledge structure F such that\n` ∀p1∃q2∀p2∃q3 · · · ∀pm−1∃qmA(p1, q2, p2 · · · , pm−1, qm) iff\nF |= d1 ∧ ¬d2 ⇒ (K1¬K2¬)m−1(dm ∧A(p1, q2, p2, q3 · · · , pm−1, qm)). Let F = (V, {θ}, O1, O2), where 1. V = {c} ∪ {d1, · · · , dm} ∪ {d′1, · · · , d′m} ∪ {p1, · · · , pm} ∪ {q1, · · · , qm} 2. θ is the conjunction of the following formulas\n(a) ∧\nj<m\n(dj+1 ⇒ dj) ∧ (d′j+1 ⇒ d′j)\n(b) ∧\nj<m\n dj ∧ ¬dj+1 ⇒ ∧\ni6=j (pi ⇔ qi)\n \n(c) c ⇒ ∧\nj<m+1\n(dj ⇔ d′j)\n(d)\n¬c ⇒  ((dm−1 ∧ ¬dm) ⇔ d′m ) ∧ ∧\nj<m−1\n( (dj ∧ ¬dj+1) ⇔ (d′j+1 ∧ ¬d′j+2)\n)  \n3. O1 = {c} ∪ {d1, · · · , dm} ∪ {q1, · · · , qm} 4. O2 = {d′1, · · · , d′m} ∪ {p1, · · · , pm}\nIn our picture, we have only two agents: agents 1 and 2. We assign every state an integer number, called the depth of the state for convenience. For every j, dj expresses that the depth of the state is at least j. Propositions d1, · · · , dm are observable to agent 1, but not to agent 2. Nevertheless, agent 2 can observe d′1, · · · , d′m, which are closely related to d1, · · · , dm. The formula in item 2c indicates that d′1, · · · , d′m are the same as d1, · · · , dm if c holds, while the formula in item 2d says that, if c does not hold, the depth expressed by d1, · · · , dm is less than that by d′1, · · · , d′m and the difference is 1. The formula in item 2b implies that, under the condition that the depth of the state is exactly j, only pj is unobservable to agent 1 and only qj is unobservable to agent 2.\nIn order to show that\n` ∀p1∃q2∀p2∃q3 · · · ∀pm−1∃qmA(p1, q2, p2 · · · , pm−1, qm) implies\nF |= d1 ∧ ¬d2 ⇒ (K1¬K2¬)m−1(dm ∧A(p1, q2, p2, q3 · · · , pm−1, qm)),\nit suffices to prove that, for every j ≤ m and propositional formula ϕ over p1, · · · , pm, q1, · · · , qm,\nF |= dj ∧ ¬dj+1 ∧ ∀pj∃qj+1ϕ ⇒ K1¬K2¬(dj+1 ∧ ¬dj+2 ∧ ϕ) To do so, we need only to show that\nF |= dj ∧ ¬dj+1 ∧ ∀pjϕ ⇒ K1(dj ∧ ¬dj+1 ∧ ϕ) and\nF |= dj ∧ ¬dj+1 ∧ ∃qj+1ϕ ⇒ ¬K2¬(dj+1 ∧ ¬dj+2 ∧ ϕ). As for the other direction, we notice that, for each l < m− 1,\nF |= d1 ∧ ¬d2 ⇒ (K1K2)l¬dl+2. We also notice that, for each 1 < m′ ≤ m,\nF |= K1¬K2dm′ ⇒ dm′−1 and F |= dm′−1 ∧ ¬dm′ ∧K1¬K2¬(dm′ ∧ ϕ) ⇒ ∀pm′−1∃qm′ϕ. By applying the above three claims repeatedly, we can obtain that\nF |= d1 ∧ ¬d2 ∧ (K1¬K2¬)m−1(dm ∧ ϕ) ⇒ ∀p1∃q2∀p2∃q3 · · · ∀pm−1∃qmϕ. Therefore, if\nF |= d1 ∧ ¬d2 ⇒ (K1¬K2¬)m−1(dm ∧ ϕ) then we have that ∀p1∃q2∀p2∃q3 · · · ∀pm−1∃qmϕ is satisfiable in F because so is d1 ∧ ¬d2. However, as the QBF formula ∀p1∃q2∀p2∃q3 · · · ∀pm−1∃qmϕ does not contain any free variable, we immediately conclude that the QBF formula is valid from that QBF formula is satisfiable in F . 2\nBy Remark 29, we can see that, for the language of formulas in PALn without common knowledge operators, the realization problem can be reduced to the problem of validness problem of quantified Boolean formulas, and hence is PSPACE-complete by Proposition 30. We conjecture that the realization problem is also PSPACE-complete for LCn and PALn.\nProposition 30 indicates that the realization problem in the general case is hard for a computer to solve. Thus, it is interesting to give some special cases with lower computational complexity. Let L+Kn be the fragment of positive formulas in Ln. It consists of those formulas such that the negation can be applied only to propositional formulas and the modalities are restricted to K1, · · · ,Kn. For instance, formula K1K2p∨K1K2¬p (where p is a propositional formula) belongs to L+Kn , but formula K1K2p ∨K1¬K2p does not.\nThe sublanguage L+Kn is interesting in that it is sufficient to represent most important security properties for security protocols. Moreover, as shown in the following proposition, the complexity of the realization problem for L+Kn is co-NP-complete.\nProposition 31 The realization problem for L+Kn is co-NP-complete.\nProof: It is well-known that the validity problem for propositional formulas is co-NPcomplete. We can easily get the co-NP-hardness of the realization problem for L+Kn , because the validity problem for propositional formulas can be reduced to the realization problem for propositional formulas (considering the case where background knowledge base is a tautology).\nOn the other hand, to show the realization problem for L+Kn is in co-NP, we show it can be reduced to the validity problem of propositional formulas. Given a knowledge structure F and formula ϕ in L+Kn , we will translate ϕ into a propositional formula ‖ϕ‖F (which will be define below), so that ϕ is realized in F iff θ ⇒ ‖ϕ‖F is valid, where θ is the background knowledge base of knowledge structure F .\nSuppose F = (V, {θ}, O1, · · · , On). For every subformula Kiψ of ϕ, we introduce a set V iψ of new propositional variables such that | V iψ |=| V −Oi |.\nThe propositional translation ‖ϕ‖F is inductively given as follows. 1. If ϕ is a propositional formula, then ‖ϕ‖F = ϕ. 2. If ϕ is of the conjunction form ϕ1 ∧ ϕ2, then\n‖ϕ‖F = ‖ϕ1‖F ∧ ‖ϕ2‖F .\n3. If ϕ is of the disjunction form ϕ1 ∨ ϕ2, then\n‖ϕ‖F = ‖ϕ1‖F ∨ ‖ϕ2‖F .\n4. If ϕ is of the form Kiψ, then\n‖ϕ‖F = (θ ⇒ ‖ψ‖F )(V −Oi V iψ ),\nwhere (θ ⇒ ‖ψ‖F )(V−OiV i ψ ) is the formula obtained from (θ ⇒ ‖ψ‖F ) by replacing variables in V −Oi by the new ones in V iψ.\nThe idea behind the above translation is that we first translate formula ϕ into a quantified propositional formula, where all the quantifiers are universal ones, and then eliminate those universal quantifiers by introducing new variables.\nLet Vϕ be the set of new variables in ‖ϕ‖F . To show the correctness of the translation, it suffices to show that F |= ϕ ⇔ ∀Vϕ‖ϕ‖F .\nWe prove this claim by induction on ϕ.\n• It is trivial, if ϕ is a propositional formula.\n• If ϕ is of the form ϕ1 ∧ ϕ2, the claim can be obtained immediately by the induction assumption.\n• If ϕ is of the form ϕ1 ∨ ϕ2, we have that ∀Vϕ(‖ϕ1‖F ∨ ‖ϕ2‖F ) is logically equivalent to ∀Vϕ1‖ϕ1‖F ∨ ∀Vϕ2‖ϕ2‖F , as the variables in Vϕ1 do not appear in ∀Vϕ2‖ϕ2‖F and those in Vϕ2 do not in ∀Vϕ1‖ϕ1‖F . Thus, the claim holds by the induction assumption.\n• Finally, if ϕ is of the form Kiψ, then\n‖ϕ‖F = (θ ⇒ ‖ψ‖F )(V −Oi V iψ ).\nTherefore, Vϕ = Vψ∪V iψ and ∀Vϕ‖ϕ‖F is logically equivalent to (θ ⇒ ∀V iψ∀Vψ‖ψ‖F )(V−OiV i ψ ). Thus, by the induction assumption, we have that\nF |= ∀Vϕ‖ϕ‖F ⇔ (θ ⇒ ∀V iψψ( V −Oi\nV iψ )\nand hence\nF |= ∀Vϕ‖ϕ‖F ⇔ (θ ⇒ ∀(V −Oi)ψ).\nTherefore, we have F |= ∀Vϕ‖ϕ‖F ⇔ Kiψ. 2\nProposition 31 implies that, for an arbitrary formula ϕ in L+Kn and a knowledge structure F with background knowledge base θ,\nF |= ϕ iff θ ∧ ¬‖ϕ‖F is unsatisfiable.\nThus, we can solve the realization problem for formulas in L+Kn by using a propositional satisfiability solver."
    }, {
      "heading" : "7. A Case Study: the Muddy Children Puzzle",
      "text" : "In this section, we demonstrate how our framework can be applied to practical problems by using the example of the muddy children puzzle."
    }, {
      "heading" : "7.1 Muddy Children Puzzle",
      "text" : "The muddy children puzzle is a well-known variant of the wise men puzzle. The story goes as follows (Fagin et al., 1995): Imagine n children playing together. Some of the children, say k of them, get mud on their foreheads. Each can see the mud on others but not on his/her own forehead. Along comes the father, who says, “at least one of you has mud on your forehead.” The father then asks the following question, over and over: “Does any of you know whether you have mud on your own forehead?”\nAssuming that all children are perceptive, intelligent, truthful, and they answer simultaneously, what we want to show is that the first (k− 1) times the father asks the question, they will say “No” but the kth time the children with muddy foreheads will all answer “Yes.”"
    }, {
      "heading" : "7.2 Modeling the Muddy Children Puzzle",
      "text" : "To model the muddy children puzzle, let mi be a propositional variable, which means that child i is muddy (i < n). Denote by V the set {mi | i < n}. Suppose the assignment s0 = {mi | i < k} represents the actual state: child 0, · · ·, child k − 1 have mud on their foreheads; and the other children have not. This can be captured by the scenario (F0, s0), where F0 = (V, Γ0, O0, · · · , On−1) with\n• V = {mi | i < n};\n• Γ0 = ∅;\n• and Oi = V − {mi} for each i < n. Let ϕ = ∧\ni<n ¬Kimi, which indicates that every child does not know whether he has mud on his own forehead. For convenience, we introduce, for all natural number l, the notations [ϕ]lψ so that [ϕ]0ψ = ψ and [ϕ]l+1ψ = [ϕ][ϕ]lψ. The properties we want to show is then formally expressed in PALn:\n• [∨i<n mi][ϕ]jϕ for every 0 ≤ j < k − 1, and • [∨i<n mi][ϕ]k−1 ∧ i<k Kimi.\nFormula [ ∨\ni<n mi][ϕ] jϕ means that the children will all say “No” for the j + 1th time the\nfather asks the question. In particular, when j = 0, the condition 0 ≤ j < k−1 is simplified as k > 1; and the resulting formula [ ∨ i<n mi]ϕ says that after the father announces ∨ i<n mi\nevery child says “No”. Formula [ ∨ i<n mi][ϕ] k−1 ∧ i<k Kimi indicates that the k th time the children with muddy foreheads will all answer “Yes.” Therefore, what we want to prove is that\n(F0, s0) |=   ∧\n0≤j<k−1 [ ∨ i<n mi][ϕ]jϕ\n  ∧  [ ∨\ni<n\nmi][ϕ]k−1 ∧\ni<k\nKimi\n  .\nTo check the above, we basically follow the definition of PAL semantics under knowledge structure. During the checking process, a series Fj (0 < j ≤ k) of knowledge structures are constructed so that F1 = F0 |∨\ni<n mi\nand, for every j (0 < j < k), Fj+1 = Fj |ϕ.\nSpecifically, we have that, for each step j ≤ k, we get\nFj = (V, Γj , O0, · · · , On−1)\nwhere Oi = V − {mi} for each i < n, and Γj is defined as follows:\n• At step 1: Γ1 = { ∨ i<n mi}. • At step j + 1: Let ϕb = ∧i<n ¬∀mi(Γj ⇒ mi). As for each i < n, Fj |= Kimi ⇔ ∀mi(Γj ⇒ mi), we have that Fj |= ϕ ⇔ ϕb. Thus, we may set Γj+1 = Γj ∪ { ϕb } .\nTherefore, it suffices to verify, for 0 < j < k and i < n, (Fj , s0) |= ¬Kimi, and for i < k, (Fk, s0) |= Kimi."
    }, {
      "heading" : "7.3 Experimental Results",
      "text" : "Our framework of knowledge structure has been implemented by using the BDD library (CUDD) developed by Fabio Somenzi at Colorado University. Notice that BDD-based QBF solvers for satisfiability problems are not among the best solvers nowadays. However, in the experiments here we need to compute and represent a serial of Boolean functions (say Γj), which are not decision problems and can not be solved by a general QBF solver.\nTo check agents’ knowledge, we implemented two different algorithms in terms of Part 1 and 2 of Corollary 19 in Section 3, respectively. Algorithm 1, which is based on part 1 of Corollary 19, seems much more efficient than Algorithm 2, which is based on part 2 of Corollary 19, for this particular example. The reason is as follows. It is clear that the main task of both algorithms is to check whether (Fj , s0) |= Kimi. However, Algorithm 1’s method is to compute s0 |= ∀mi(Γj ⇒ mi), while Algorithm 2 is to compute |= ∃mi(Γj ∧ s0) ⇒ mi. Now the main reason why Algorithm 1 is much more efficient for this particular problem is clear: ∀mi(Γj ⇒ mi) is simply equivalent to ¬Γj( mifalse). Assuming half of the children are muddy, Fig. 1 gives the performances for a Pentium IV PC at 2.4GHz, with 512RAM. In the figure, the x-axis is for the number of children, and the y-axis for the CPU run time in seconds.\nThe muddy children puzzle as a famous benchmark problem of reasoning about knowledge can be resolved by both proof-theoretic and semantical approaches (Baltag et al., 1998; Gerbrandy, 1999; Lomuscio, 1999). Proof-theoretic approaches depend on efficient provers for multi-modal logics; and semantical ones may suffer from the state-explosion problem. Our approach is essentially a semantic one, but we give a syntactical and compact way to represent Kripke structures by using knowledge structures, and hence may avoid the state-explosion problem to some extent."
    }, {
      "heading" : "8. Application to Verification of Security Protocols",
      "text" : "In this section, we apply our knowledge model to security protocol verification. Security protocols that set up credits of the parties and deal with the distribution of cryptographic keys are essential in communication over vulnerable networks. Authentication plays a key role in security protocols. Subtle bugs that lead to attack are often found when the protocols have been used for many years. This presents a challenge of how to prove the correctness of a security protocol. Formal methods are introduced to establish and prove whether a secure protocol satisfies a certain authentication specification."
    }, {
      "heading" : "8.1 Background on Authentication Protocols",
      "text" : "Authentication protocols aim to coordinate the activity of different parties (usually referred to as principals) over a network. They generally consist of a sequence of message exchanges whose format is fixed in advance and must be conformed to. Usually, a principal can take part into a protocol run in different ways, as the initiator or the responder ; we often call the principal has different roles. Very often a principal can take part into several protocol runs simultaneously with different roles.\nThe designers of authentication protocols must have the conscious in mind that the message may be intercepted and someone with malicious intention can impersonate an honest principal. One of the key issues in authentication is to ensure the confidentiality, that is, to prevent private information from being disclosed to unauthorized entities. Another issue is to avoid intruder impersonating other principals. In general, a principal should ensure that the message he receives was created recently and sent by the principal who claims to have sent it.\nCryptography is a fundamental element in authentication. A message transmitted over a channel without any cryptographic converting is called plaintext. The intention of cryptography is to transform a given message to some form that is unrecognizable by anyone except the intended receiver. The procedure is called encryption and the corresponding parameter is known as encryption key. The encoded message is referred to as ciphertext. The reverse procedure is called decryption and uses the corresponding decryption key. The symmetric-key cryptography, which is also called secret-key cryptography, uses the same key for both encryption and decryption. The asymmetric-key cryptography, which is also called public-key cryptography, uses different keys for encryption and decryption. The one for the encryption is the public key that is generally available for anyone. Corresponding to the public key is the private key, which is for the decryption and only owned by one principal."
    }, {
      "heading" : "8.2 The Dolev-Yao Intruder Model",
      "text" : "The standard adversary model for the analysis of security protocols was introduced by Dolev and Yao in 1983 and is commonly known as Dolev-Yao model (Dolev & Yao, 1983). According to this model, a set of conservative assumptions are made as follows:\n1. Messages are considered as indivisible abstract values instead of sequences of bits.\n2. All the messages from one principal to any other principals must pass through the adversary and the adversary acts as a general router in the communication.\n3. The adversary can read, alter and redirect any message.\n4. The adversary can only decrypt a message if he has the right keys, and can only compose new messages from keys and messages that he already possesses.\n5. The adversary can not perform any statistical or other cryptanalytic attacks.\nAlthough this model has the drawback of finding implementation dependent attacks, it simplifies the protocol analysis. It has been proved to be the most powerful modeling of the adversary (Cervesato, 2001) because it can simulate any other possible attackers."
    }, {
      "heading" : "8.3 The Revised Needham-Schroeder Protocol",
      "text" : "As Lowe (1996) pointed out, the Needham-Schroeder protocol has the problem of lacking the identity of the responder and can be fixed by a small modification. However, it is not clear if the revised version is correct. Our approach provides a method to automatically prove the correctness of security protocols instead of just finding bugs as usual analysis tools do for security protocols.\nIn the cryptography literature, the revised Needham-Schroeder protocol is described as follows:\n1. A → B: {Na, A}Kb 2. B → A: {B,Na, Nb}Ka 3. A → B: {Nb}Kb\nwhere A → B : M is a notation for “A sends B the message M ” or “B receives the message M from A”. The notation {M}K means the encryption of M with the key K. Also, A,B denote the principal identifiers; and Ka, Kb indicate, respectively, A’s and B’s public keys. Moreover, Na and Nb are the nonces which are newly generated unguessable values by A and B, respectively, to guarantee the freshness of messages.\nTwo informal goals or specifications of the protocol are “A knows that B knows A said Na and Na is fresh,” and “B knows that A knows B said Nb and Nb is fresh .”\nTo analyze the protocol, we introduce A and B local histories for the protocol: If A plays the role of the initiator in the protocol, and assumes that B be the responsor, then A’s local history is that\n1. A said {Na,A}KbA\n2. A sees {BA, Na, NbA}Ka 3. A said {NbA}KbA\nwhere “A said M” means that A sent the message M , or other message containing M ; “A sees M” indicates that A receives M or got M by some received messages; BA is the responsor of the protocol from A’s local view; KbA and NbA are, from A’s local view, the responsor’s public key and nonce, respectively.\nIf B plays the role of the responsor in the protocol, and assumes A be the initiator, then A’s local history is that\n1. B sees {NaB, AB}Kb 2. B said {B,NaB, Nb}Ka 3. B sees {Nb}Kb\nwhere AB is the initiator of the protocol from B’s local observations; KaB and NaB are, from B’s local view, the initiator’s public key and nonce, respectively.\nThe main point of our analysis is that if an agent is involved in the protocol, then the agent’s real observations should be compatible with the so-called local history. For example, if A is the initiator of the protocol, and A sees {B,NaB, Nb}Ka, then according to A’s local history for the protocol we have that A assumes that B is the responsor of the protocol, the responsor’s nonce is Nb, and from the responsor’s view, the initiator’s nonce is Na (see the 4th formula of the background knowledge Γ below).\nLet us see how our framework of reasoning about knowledge can be applied to this protocol.\nThe variable set VRNS consists of the following atoms:\n• fresh(Na): Nonce Na is fresh. • fresh(Nb): Nonce Nb is fresh. • role(Init, A): A plays the role of the initiator of the protocol. • role(Resp, B): B plays the role of the responder of the protocol. • RespA = B: A assumes that the responder of the protocol is B. • InitB = A: B assumes that the initiator of the protocol is A. • NaB = Na: B assumes that the partner’s nonce in the execution of the protocol is\nNa.\n• NbA = Nb: A assumes that the partner’s nonce in the execution of the protocol is Nb.\n• said(B,Na): B said Na by sending a message containing Na. • said(A,Nb): A said Nb.\n• sees(B, {Na, A}Kb): B sees {Na,A}Kb (possibly by decrypting the messages received.)\n• sees(A, {B,NaB, Nb}Ka): A sees {B,NaB, Nb}Ka.\nThe background knowledge ΓRNS consists of the following formulas:\n1.  \nsees(B, {Na,A}Kb)∧ said(B,Na)∧ fresh(Na)\n  ⇒ role(Resp, B)\n2.  \nsees(A, {B,NaB, Nb}Ka)∧ said(A,Nb)∧ fresh(Nb)\n  ⇒ role(Init, A)\n3.   role(Resp, B)∧ sees(B, {Na,A}Kb)∧ said(B,Na)∧ fresh(Na)   ⇒ ( InitB = A∧ NaB = Na )\n4.  \nrole(Init, A)∧ sees(A, {B,NaB , Nb}Ka)∧ said(A,Nb)∧ fresh(Nb)\n  ⇒  \nRespA = B∧ NaB = Na∧ NbA = Nb\n \n5. ( role(Init, A)∧ RespA = B ) ⇒ ( sees(B, {Na, A}Kb)∧ said(B,Na) ) 6. (\nrole(Resp, B)∧ InitB = A\n) ⇒ ( sees(A, {B,NaB , Nb}Ka)∧ said(A,Nb) )\n7. (role(Init, A) ⇒ fresh(Na))∧ (role(Resp, B) ⇒ fresh(Nb))\nNotice that the first two formulas are required for the rationality of the agents A and B. The other formulas in Γ can be obtained automatically by some fixed set of meta rules. We obtain the third and fourth formulas by comparing their local history for the protocols to the conditions appearing in the formulas. To get the fifth formula informally, consider A’s local history under the conditions role(Init, A) and RespA = B, which should be that\n1. A said {Na,A}Kb 2. A sees {B,Na, NbA}Ka 3. A said {NbA}Kb.\nAccording to A’s local history, A sees the nonce Na generated by A itself. Because Na is only said in the message {Na,A}Kb, thus B, who has the inverse key of Kb, must see this message and said Na. Similarly, we can see that the sixth formula holds. The last formula follows immediately by the definition of the protocol.\nThe set OA of the observable variables to A is\n{fresh(Na), role(Init, A), RespA = B}.\nThe set OB of the observable variables to B is\n{fresh(Nb), role(Resp, B), InitB = A}.\nNow consider the knowledge structure\nF = (VRNS ,ΓRNS , OA, OB).\nLet SpecA be the formal specification:  \nfresh(Na)∧ role(Init, A)∧ RespA = B\n  ⇒ KAKB ( said(A,Na)∧ fresh(Na) )\nand SpecB be the formal specification:  \nfresh(Nb)∧ role(Resp, B)∧ InitB = A\n  ⇒ KBKA ( said(B,Nb)∧ fresh(Nb) ) .\nIt is easy to show that, for all states s of F ,\n(F , s) |= SpecA ∧ SpecB as desired.\nWe should mention that, in the original Needham-Schroeder protocol (Needham & Schroeder, 1978), the second message is B → A: {Na, Nb}Ka instead of B → A: {B,Na, Nb}Ka. Therefore, the fourth formula in Γ would be changed to\n \nrole(Init, A)∧ sees(A, {NaB , Nb}Ka)∧ said(A,Nb)∧ fresh(Nb)\n  ⇒ ( NaB = Na∧ NbA = Nb )\nThus, RespA = B does not necessarily hold under the condition\nrole(Init, A) ∧ sees(A, {NaB, Nb}Ka) ∧ said(A,Nb) ∧ fresh(Nb).\nThis is why the specifications SpecA and SpecB do not hold for the original NeedhamSchroeder protocol."
    }, {
      "heading" : "8.4 Discussion",
      "text" : "BAN logic (Burrows, Abadi, & Needham, 1990) is one of the most successful logical tools to reason about security protocols. However, the semantics of BAN is always arguable, and it is not clear under what assumption the rules of BAN logic is sound and complete. This\nmotivated the research of seeking more adequate frameworks (models). Providing a modeltheoretic semantics for BAN logic has been a central idea in the development of BAN-like logics such as AT (Abadi & Tuttle, 1991) and SVO (Syversion & van Oorschot, 1996). The advantage of our approach is that we use knowledge structures as semantic models to verify the correctness of epistemic goals for security protocols.\nAn important problem is that, given a security protocol, where and how the corresponding knowledge structure comes from. To get the knowledge structure corresponding to a security protocol, we have developed a semantic model, and the background knowledge base of the corresponding knowledge structure consists of those formulas valid in the semantic model. Moreover, we can generate the background knowledge systematically. The ongoing work is to implement our approach into a promising automatic security protocol verifier."
    }, {
      "heading" : "9. Related Work",
      "text" : "There are a number of approaches dealing with the concept of variable forgetting or eliminations of middle terms (Boole, 1854) in several contexts. The notion of variable forgetting was formally defined in propositional and first order logics by Lin and Reiter (1994). In recent years, theories of forgetting under answer set programming semantics were proposed (Zhang & Foo, 2006; Eiter & Wang, 2008). Forgetting was also generalized to description logics (Kontchakov, Wolter, & Zakharyaschev, 2008; Wang, Wang, Topor, & Pan, 2008; Kontchakov, Walther, & Wolter, 2009).\nIn the context of epistemic logic, the notion of forgetting was studied in a number of ways. Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect ¬Kϕ ∧ ¬K¬ϕ: after knowledge forgetting ϕ, the agent would neither know ϕ nor ¬ϕ. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]ϕ means that after the agent forgets his knowledge about p, ϕ is true. (Zhang & Zhou, 2008) modeled forgetting via bisimulation invariance except for the forgotten variable. This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003).\nThe notion of variable forgetting has various applications in knowledge representation and reasoning. For example, Weber (1986) applied it to updating propositional knowledge bases. Lang and Marquis (2002) used it for merging a set of knowledge bases when simply taking their union may result in inconsistency. The notion of variable forgetting is also closely related to that of formula-variable independence, because the result of forgetting the set of variables V in a formula ϕ can be defined as the strongest consequence of ϕ being independent from V (Lang et al., 2003). More recently, Liu and Lakemeyer (2009) applied the notion of forgetting into the situation calculus, and obtained some interesting results about the first-order definability and computability of progression for local-effect actions."
    }, {
      "heading" : "10. Conclusion",
      "text" : "The main contribution of this paper is as follows. First, we have investigated knowledge reasoning within a simple framework called knowledge structure, which consists of a global\nknowledge base and a set of observable variables for each agent. The notion of knowledge structure can be used as a semantic model for a multi-agent logic of knowledge and common knowledge. In this model, the computation of knowledge and common knowledge can be reduced to the operation of variable forgetting; moreover, an objective formula α is known by agent i at state s when any of its weakest sufficient condition on Oi holds at state s.\nSecond, to capture the notion of common knowledge in our framework, we have generalized the notion of weakest sufficient conditions and obtained, for a set V of sets of propositional variables, the notion of the weakest V-sufficient conditions. Given a set ∆ of agents and a family V∆ of observable variable sets of these agents, we have shown that an objective formula α is common knowledge for agents in ∆ iff the weakest {Oi | i ∈ ∆}-sufficient of α holds. Also, we have shown that public announcement operator can be conveniently dealt with via our notion of knowledge structure.\nThird, the relationship between S5 Kripke structure and knowledge structure has been explored. Specifically, the satisfiability issue for a formula in the language of multi-agent S5 with public announcement operator is the same as what satisfiability is meant w.r.t. a standard Kripke structure or w.r.t. a knowledge structure.\nFourth, we have examined the computational complexity of the problem whether a formula α is realized in structure F . In the general case, this problem is PSPACE-hard; however, there are some interesting subcases in which it can be reduced to co-NP.\nFinally, we have shown the strength of the concept of knowledge structure from the practical side by some empirical results about the satisfiability problem for knowledge structures based on the instances of the muddy children puzzle, since even for the smallest instances considered in the experiments generating the corresponding S5 Kripke structure would be out of reach. we have also discussed the automated analysis and verification of the corrected Needham-Schroeder protocol via knowledge structures.\nOur work presented in this paper can be further extended in several directions. First, we will investigate whether our knowledge structures can be extended and used as a basis for knowledge based programming (Fagin et al., 1995). Secondly, in our current framework of knowledge structures, we have not considered the issue of only knowing which has been extensively studied in other knowledge reasoning models (Halpern & Lakemeyer, 1996; van der Hock, Jaspars, & Thijsse, 2003; Levesque, 1990). It will be an interesting topic of how our knowledge model handles only knowing in reasoning about knowledge. Thirdly, the notions and methods in this work can be extended to investigate the extension of the variable forgetting operator to multi-agent logics of beliefs. Finally, recent research has shown that knowledge update has many important applications in reasoning about actions and plans and dynamic modeling of multi-agent systems (Zhang, 2003). A first step in this direction (in mono-agent S5) can be found in the work of Herzig, Lang and Marquis (2003). Baral and Zhang have proposed a general model for performing knowledge update based on the standard single agent S5 modal logic (Baral & Zhang, 2001). We believe that their work can be extended to multi-agent modal logics by using the knowledge structure defined in this paper and therefore to develop a more general system for knowledge update. Along this direction, an interesting research issue is to explore the underlying relationship between knowledge forgetting - a specific type of knowledge update, and variable forgetting as addressed in this paper."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The authors thank Ron van der Meyden, Fangzheng Lin and the anonymous reviewers for their valuable comments on an earlier version of this paper. This work was partially supported by the Australian Research Council grant DP0452628, the National Basic Research 973 Program grants (Nos. 2010CB328103, 2009CB320701 and 2005CB321902), and National Natural Science Foundation of China grants (Nos. 60725207 and 60763004). This paper is the revised and extended version of a paper which appeared in Proceedings of KR 2004 (Su, Lv, & Zhang, 2004)"
    } ],
    "references" : [ {
      "title" : "A semantics for a logic of authentication",
      "author" : [ "M. Abadi", "M. Tuttle" ],
      "venue" : "In Proceedings of the Tenth Annual ACM Symposium on Principles of Distributed Computing,",
      "citeRegEx" : "Abadi and Tuttle,? \\Q1991\\E",
      "shortCiteRegEx" : "Abadi and Tuttle",
      "year" : 1991
    }, {
      "title" : "The logic of public announcements and common knowledge for distributed applications (extended abstract)",
      "author" : [ "A. Baltag", "L. Moss", "S. Solecki" ],
      "venue" : "In Proceedings of TARKVII,",
      "citeRegEx" : "Baltag et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Baltag et al\\.",
      "year" : 1998
    }, {
      "title" : "On the semantics of knowledge update",
      "author" : [ "C. Baral", "Y. Zhang" ],
      "venue" : "In Proceedings of the 17th International Joint Conference on Artificial Intelligence",
      "citeRegEx" : "Baral and Zhang,? \\Q2001\\E",
      "shortCiteRegEx" : "Baral and Zhang",
      "year" : 2001
    }, {
      "title" : "Knowledge updates: semantic and complexity issues",
      "author" : [ "C. Baral", "Y. Zhang" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Baral and Zhang,? \\Q2006\\E",
      "shortCiteRegEx" : "Baral and Zhang",
      "year" : 2006
    }, {
      "title" : "An Investigation of the Laws of Thought",
      "author" : [ "G. Boole" ],
      "venue" : "Walton, London.",
      "citeRegEx" : "Boole,? 1854",
      "shortCiteRegEx" : "Boole",
      "year" : 1854
    }, {
      "title" : "A logic of authentication",
      "author" : [ "M. Burrows", "M. Abadi", "R.M. Needham" ],
      "venue" : "ACM Transactions on Computer Systems,",
      "citeRegEx" : "Burrows et al\\.,? \\Q1990\\E",
      "shortCiteRegEx" : "Burrows et al\\.",
      "year" : 1990
    }, {
      "title" : "The Dolev-Yao intruder is the most powerful attacker",
      "author" : [ "I. Cervesato" ],
      "venue" : "Proc. 16th Annual Int. Symp on Logic in Computer Science.",
      "citeRegEx" : "Cervesato,? 2001",
      "shortCiteRegEx" : "Cervesato",
      "year" : 2001
    }, {
      "title" : "On the security of public-key protocols",
      "author" : [ "D. Dolev", "A. Yao" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "Dolev and Yao,? \\Q1983\\E",
      "shortCiteRegEx" : "Dolev and Yao",
      "year" : 1983
    }, {
      "title" : "Semantic forgetting in answer set programming",
      "author" : [ "T. Eiter", "K. Wang" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Eiter and Wang,? \\Q2008\\E",
      "shortCiteRegEx" : "Eiter and Wang",
      "year" : 2008
    }, {
      "title" : "Knowledge and the logic of local propositions",
      "author" : [ "K. Engelhardt", "R. van der Meyden", "Y. Moses" ],
      "venue" : "In Proceedings of TARK VII",
      "citeRegEx" : "Engelhardt et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Engelhardt et al\\.",
      "year" : 1998
    }, {
      "title" : "Modal logics with a hierarchy of local propositional quantifiers",
      "author" : [ "K. Engelhardt", "R. van der Meyden", "K. Su" ],
      "venue" : "In Advance in Modal Logic,",
      "citeRegEx" : "Engelhardt et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Engelhardt et al\\.",
      "year" : 2003
    }, {
      "title" : "Reasoning about knowledge",
      "author" : [ "R. Fagin", "J. Halpern", "Y. Moses", "M. Vardi" ],
      "venue" : null,
      "citeRegEx" : "Fagin et al\\.,? \\Q1995\\E",
      "shortCiteRegEx" : "Fagin et al\\.",
      "year" : 1995
    }, {
      "title" : "Bisimulation on Plant Kripke",
      "author" : [ "J. Gerbrandy" ],
      "venue" : "Ph.D thesis, Institute for Logic, Language and Computation, University of Amsterdam.",
      "citeRegEx" : "Gerbrandy,? 1999",
      "shortCiteRegEx" : "Gerbrandy",
      "year" : 1999
    }, {
      "title" : "A guide to completeness and complexity for modal logics of knowledge and belief",
      "author" : [ "J. Halpern", "Y. Moses" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Halpern and Moses,? \\Q1992\\E",
      "shortCiteRegEx" : "Halpern and Moses",
      "year" : 1992
    }, {
      "title" : "A little knowledge goes a long way: Simple knowledge based derivations and correctness proofs for a family of protocols",
      "author" : [ "J. Halpern", "L. Zuck" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Halpern and Zuck,? \\Q1992\\E",
      "shortCiteRegEx" : "Halpern and Zuck",
      "year" : 1992
    }, {
      "title" : "Multi-agent only knowing",
      "author" : [ "J.Y. Halpern", "G. Lakemeyer" ],
      "venue" : "In Proceedings of TARK VI,",
      "citeRegEx" : "Halpern and Lakemeyer,? \\Q1996\\E",
      "shortCiteRegEx" : "Halpern and Lakemeyer",
      "year" : 1996
    }, {
      "title" : "Action representation and partially observable planning using epistemic logic",
      "author" : [ "A. Herzig", "J. Lang", "P. Marquis" ],
      "venue" : "In Proceedings of IJCAI-03,",
      "citeRegEx" : "Herzig et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Herzig et al\\.",
      "year" : 2003
    }, {
      "title" : "Knowledge and Belief",
      "author" : [ "J. Hintikka" ],
      "venue" : "Cornell University Press, Ithaca, NY.",
      "citeRegEx" : "Hintikka,? 1962",
      "shortCiteRegEx" : "Hintikka",
      "year" : 1962
    }, {
      "title" : "Forgetting and uniform interpolation in large-scale description logic terminologies",
      "author" : [ "R. Kontchakov", "D. Walther", "F. Wolter" ],
      "venue" : "In Proc. of IJCAI’09",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2009
    }, {
      "title" : "Can you tell the difference between dl-lite ontologies",
      "author" : [ "R. Kontchakov", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "In Proc. of KR’08",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2008
    }, {
      "title" : "A semantical analysis of modal logic",
      "author" : [ "S. Kripke" ],
      "venue" : "i: Normal modal propositional calculi. Z. Math. Logik Grundl. Math., 9, 67–96.",
      "citeRegEx" : "Kripke,? 1963",
      "shortCiteRegEx" : "Kripke",
      "year" : 1963
    }, {
      "title" : "Propositional independence: Formulavariable independence and forgetting",
      "author" : [ "J. Lang", "P. Liberatore", "P. Marquis" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Lang et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Lang et al\\.",
      "year" : 2003
    }, {
      "title" : "Complexity results for independence and definability",
      "author" : [ "J. Lang", "P. Marquis" ],
      "venue" : "In Proc. the 6th International Conference on Knowledge Representation and Reasoning,",
      "citeRegEx" : "Lang and Marquis,? \\Q1998\\E",
      "shortCiteRegEx" : "Lang and Marquis",
      "year" : 1998
    }, {
      "title" : "Resolving inconsistencies by variable forgetting",
      "author" : [ "J. Lang", "P. Marquis" ],
      "venue" : "In Proc. of KR’2002,",
      "citeRegEx" : "Lang and Marquis,? \\Q2002\\E",
      "shortCiteRegEx" : "Lang and Marquis",
      "year" : 2002
    }, {
      "title" : "All I know: a study in autoepistemic logic",
      "author" : [ "H. Levesque" ],
      "venue" : "Artificial Intelligence, 42, 263–309.",
      "citeRegEx" : "Levesque,? 1990",
      "shortCiteRegEx" : "Levesque",
      "year" : 1990
    }, {
      "title" : "On the strongest necessary and weakest sufficient conditions",
      "author" : [ "F. Lin" ],
      "venue" : "Artificial Intelligence, 128, 143–159.",
      "citeRegEx" : "Lin,? 2001",
      "shortCiteRegEx" : "Lin",
      "year" : 2001
    }, {
      "title" : "On first-order definability and computability of progression for local-effect actions and beyond",
      "author" : [ "Y. Liu", "G. Lakemeyer" ],
      "venue" : "In Proc. of IJCAI’09",
      "citeRegEx" : "Liu and Lakemeyer,? \\Q2009\\E",
      "shortCiteRegEx" : "Liu and Lakemeyer",
      "year" : 2009
    }, {
      "title" : "Knowledge Sharing among Ideal Agents",
      "author" : [ "A. Lomuscio" ],
      "venue" : "Ph.D thesis, School of Computer Science, University of Birmingham.",
      "citeRegEx" : "Lomuscio,? 1999",
      "shortCiteRegEx" : "Lomuscio",
      "year" : 1999
    }, {
      "title" : "Breaking and fixing the Needham-Schroeder public-key protocol using FDR",
      "author" : [ "G. Lowe" ],
      "venue" : "Margaria, & Steffen (Eds.), Tools and Algorithms for the Construction and Analysis of Systems, Vol 1055 of Lecture Notes in Computer Science, pp. 147–166. Springer Verlag.",
      "citeRegEx" : "Lowe,? 1996",
      "shortCiteRegEx" : "Lowe",
      "year" : 1996
    }, {
      "title" : "Using encryption for authentication in large networks of computers",
      "author" : [ "R.M. Needham", "M.D. Schroeder" ],
      "venue" : "Communication of the ACM,",
      "citeRegEx" : "Needham and Schroeder,? \\Q1978\\E",
      "shortCiteRegEx" : "Needham and Schroeder",
      "year" : 1978
    }, {
      "title" : "Logics of public communications",
      "author" : [ "J. Plaza" ],
      "venue" : "Proceedings of the 4th International Symposium on Methodologies for Intelligent Systems, pp. 201–216–346.",
      "citeRegEx" : "Plaza,? 1989",
      "shortCiteRegEx" : "Plaza",
      "year" : 1989
    }, {
      "title" : "Word problem requiring exponential time: prelimnary report",
      "author" : [ "L. Stockmeyer", "A. Meyer" ],
      "venue" : "In Proc. 5th ACM Symp. on Theory of Computing,",
      "citeRegEx" : "Stockmeyer and Meyer,? \\Q1973\\E",
      "shortCiteRegEx" : "Stockmeyer and Meyer",
      "year" : 1973
    }, {
      "title" : "Reasoing about knowledge by variable forgetting",
      "author" : [ "K. Su", "G. Lv", "Y. Zhang" ],
      "venue" : "In Proceedings of KR-04,",
      "citeRegEx" : "Su et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Su et al\\.",
      "year" : 2004
    }, {
      "title" : "An unified cryptographic protocol logic",
      "author" : [ "P.F. Syversion", "P. van Oorschot" ],
      "venue" : "Tech. rep. NRL Publication",
      "citeRegEx" : "Syversion and Oorschot,? \\Q1996\\E",
      "shortCiteRegEx" : "Syversion and Oorschot",
      "year" : 1996
    }, {
      "title" : "A lattice-theoretical fixpoint theorem ans its applications",
      "author" : [ "A. Tarski" ],
      "venue" : "Pacific J. Math., 5, 285–309.",
      "citeRegEx" : "Tarski,? 1955",
      "shortCiteRegEx" : "Tarski",
      "year" : 1955
    }, {
      "title" : "Logics for information update",
      "author" : [ "J. van Benthem" ],
      "venue" : "In Proceedings of TARK-VIII,",
      "citeRegEx" : "Benthem,? \\Q2001\\E",
      "shortCiteRegEx" : "Benthem",
      "year" : 2001
    }, {
      "title" : "Theories of knowledge and ignorance",
      "author" : [ "W. van der Hock", "J. Jaspars", "E. Thijsse" ],
      "venue" : "Logic, Epistemology and the Unity of Science. Kluwer",
      "citeRegEx" : "Hock et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Hock et al\\.",
      "year" : 2003
    }, {
      "title" : "Model checking knowledge and time",
      "author" : [ "W. van der Hoek", "M. Wooldridge" ],
      "venue" : "In Proc. 19th Workshop on SPIN (Model Checking Software),",
      "citeRegEx" : "Hoek and Wooldridge,? \\Q2002\\E",
      "shortCiteRegEx" : "Hoek and Wooldridge",
      "year" : 2002
    }, {
      "title" : "Common knowledge and update in finite environments",
      "author" : [ "R. van der Meyden" ],
      "venue" : "Information and Computation,",
      "citeRegEx" : "Meyden,? \\Q1998\\E",
      "shortCiteRegEx" : "Meyden",
      "year" : 1998
    }, {
      "title" : "Introspective forgetting",
      "author" : [ "H. van Ditmarsch", "A. Herzig", "J. Lang", "P. Marquis" ],
      "venue" : "AI 2008: Advances in Artificial Intelligence,",
      "citeRegEx" : "Ditmarsch et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ditmarsch et al\\.",
      "year" : 2008
    }, {
      "title" : "Dynamic epistemic logic with assignment",
      "author" : [ "H. van Ditmarsch", "W. van der Hoek", "B. Kooi" ],
      "venue" : "In Proceedings of AAMAS-05,",
      "citeRegEx" : "Ditmarsch et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Ditmarsch et al\\.",
      "year" : 2005
    }, {
      "title" : "Public announcements and belief expansion",
      "author" : [ "H. van Ditmarsch", "W. van der Hoek", "B. Kooi" ],
      "venue" : "In Advances in Modal Logic, Volume",
      "citeRegEx" : "Ditmarsch et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Ditmarsch et al\\.",
      "year" : 2005
    }, {
      "title" : "Forgetting in dl-lite",
      "author" : [ "Z. Wang", "K. Wang", "R. Topor", "J. Pan" ],
      "venue" : "In Proc. of ESWC’08",
      "citeRegEx" : "Wang et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2008
    }, {
      "title" : "Updating propositional formulas",
      "author" : [ "A. Weber" ],
      "venue" : "Proc. First Conference on Expert Database Systems, pp. 487–500.",
      "citeRegEx" : "Weber,? 1986",
      "shortCiteRegEx" : "Weber",
      "year" : 1986
    }, {
      "title" : "Minimal change and maximal coherence for epistemic logic program updates",
      "author" : [ "Y. Zhang" ],
      "venue" : "Proceedings of the 18th International Joint Conference on Artificial Intelligence (IJCAI-03), pp. 112–117.",
      "citeRegEx" : "Zhang,? 2003",
      "shortCiteRegEx" : "Zhang",
      "year" : 2003
    }, {
      "title" : "Solving logic program conflict through strong and weak forgettings",
      "author" : [ "Y. Zhang", "N. Foo" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Zhang and Foo,? \\Q2006\\E",
      "shortCiteRegEx" : "Zhang and Foo",
      "year" : 2006
    }, {
      "title" : "Properties of knowledge forgetting",
      "author" : [ "Y. Zhang", "Y. Zhou" ],
      "venue" : "In Proceedings of the 20th International Workshop on Non-monoronic Reasoning ( NMR’08),",
      "citeRegEx" : "Zhang and Zhou,? \\Q2008\\E",
      "shortCiteRegEx" : "Zhang and Zhou",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 37,
      "context" : "This notion shares a similar spirit of those of local variables in the work of van der Hoek and Wooldridge (2002) and local propositions in the work of Engelhardt, van der Meyden and Moses (1998) and in the work of Engelhardt, van der Meyden and Su (2003).",
      "startOffset" : 87,
      "endOffset" : 114
    }, {
      "referenceID" : 37,
      "context" : "This notion shares a similar spirit of those of local variables in the work of van der Hoek and Wooldridge (2002) and local propositions in the work of Engelhardt, van der Meyden and Moses (1998) and in the work of Engelhardt, van der Meyden and Su (2003).",
      "startOffset" : 87,
      "endOffset" : 196
    }, {
      "referenceID" : 37,
      "context" : "This notion shares a similar spirit of those of local variables in the work of van der Hoek and Wooldridge (2002) and local propositions in the work of Engelhardt, van der Meyden and Moses (1998) and in the work of Engelhardt, van der Meyden and Su (2003). Informally speaking, local propositions are those depending only upon an agent’s local information; and an agent can always determine whether a given local proposition is true.",
      "startOffset" : 87,
      "endOffset" : 256
    }, {
      "referenceID" : 4,
      "context" : "Given a background knowledge base Γ and a set of observable variables Oi for each agent i, we show that the notion of agent i knowing a formula φ can be defined as the weakest sufficient condition of φ over Oi under Γ, which can be computed via the operation of variable forgetting (Lin & Reiter, 1994) or eliminations of middle terms (Boole, 1854).",
      "startOffset" : 335,
      "endOffset" : 348
    }, {
      "referenceID" : 30,
      "context" : "The most basic extension is public announcement logic (PAL), which is obtained by adding an operator for truthful public announcements (Plaza, 1989; Baltag, Moss, & Solecki, 1998; van Ditmarsch, van der Hoek, & Kooi, 2005b).",
      "startOffset" : 135,
      "endOffset" : 223
    }, {
      "referenceID" : 28,
      "context" : "To further show the significance of our framework, we investigate some of its interesting applications to the automated analysis of the well-known muddy children puzzle and the verification of the revised Needham-Schroeder protocol (Lowe, 1996).",
      "startOffset" : 232,
      "endOffset" : 244
    }, {
      "referenceID" : 8,
      "context" : "Nevertheless, the notion of local propositions (Engelhardt et al., 1998, 2003) is a semantics property of the truth assignment function in a Kripke structure, while the notion of local variables (van der Hoek & Wooldridge, 2002) is a property of syntactical variables. In this paper, we prefer to use the term “observable variable” in order to avoid any confusion with the term “local variable” used in programming, where “non-local variables” such as “global variables” may often be observable. Our knowledge model is also closely related to the notion of weakest sufficient condition, which was first formalized by Lin (2001). Given a background knowledge base Γ and a set of observable variables Oi for each agent i, we show that the notion of agent i knowing a formula φ can be defined as the weakest sufficient condition of φ over Oi under Γ, which can be computed via the operation of variable forgetting (Lin & Reiter, 1994) or eliminations of middle terms (Boole, 1854).",
      "startOffset" : 48,
      "endOffset" : 628
    }, {
      "referenceID" : 4,
      "context" : "The notion of variable forgetting (Lin & Reiter, 1994), or eliminations of middle terms (Boole, 1854), can be defined as follows:",
      "startOffset" : 88,
      "endOffset" : 101
    }, {
      "referenceID" : 22,
      "context" : "Many characterizations of variable forgetting, together with complexity results, are reported in the work of Lang and Marquis (1998). In particular, the notion of variable forgetting is closely related to that of formula-variable independence (Lang, Liberatore, & Marquis, 2003).",
      "startOffset" : 109,
      "endOffset" : 133
    }, {
      "referenceID" : 25,
      "context" : "The formal definitions of weakest sufficient conditions and strongest necessary conditions were first formalized via the notion of variable forgetting by Lin (2001), which in turn play an essential role in our approach.",
      "startOffset" : 154,
      "endOffset" : 165
    }, {
      "referenceID" : 25,
      "context" : ", the weakest sufficient condition of the observation (Lin, 2001).",
      "startOffset" : 54,
      "endOffset" : 65
    }, {
      "referenceID" : 25,
      "context" : ", the weakest sufficient condition of the observation (Lin, 2001). The notions of strongest necessary and weakest sufficient conditions of a proposition also have many potential applications in other areas such as reasoning about actions. The following proposition, which is due to Lin (2001), shows how to compute the two conditions.",
      "startOffset" : 55,
      "endOffset" : 293
    }, {
      "referenceID" : 20,
      "context" : "According to the paper by Halpern and Moses (1992), semantics of these formulas can be given by means of Kripke structure (Kripke, 1963), which formalizes the intuition behind possible worlds.",
      "startOffset" : 122,
      "endOffset" : 136
    }, {
      "referenceID" : 13,
      "context" : "According to the paper by Halpern and Moses (1992), semantics of these formulas can be given by means of Kripke structure (Kripke, 1963), which formalizes the intuition behind possible worlds.",
      "startOffset" : 26,
      "endOffset" : 51
    }, {
      "referenceID" : 13,
      "context" : "According to the work of Halpern and Moses (1992), we have the following lemma.",
      "startOffset" : 25,
      "endOffset" : 50
    }, {
      "referenceID" : 11,
      "context" : "Common knowledge is a special kind of knowledge for a group of agents, which plays an important role in reasoning about knowledge (Fagin et al., 1995).",
      "startOffset" : 130,
      "endOffset" : 150
    }, {
      "referenceID" : 22,
      "context" : "We notice that the notion of V-definability introduced here is a simple elaboration of the notion of V-definability as given in the work of Lang and Marquis (1998): φ is V-definable under Γ iff φ is V -definable under Γ for each V ∈ V.",
      "startOffset" : 140,
      "endOffset" : 164
    }, {
      "referenceID" : 34,
      "context" : "For a finite set V of propositional variables if Λ is monotonic, then there exists a least fixed point and a greatest fixed point (Tarski, 1955).",
      "startOffset" : 130,
      "endOffset" : 144
    }, {
      "referenceID" : 30,
      "context" : "The original version of PAL was proposed by Plaza (1989). In this section, we show that public announcement operator can be conveniently dealt with via our notion of knowledge structure.",
      "startOffset" : 44,
      "endOffset" : 57
    }, {
      "referenceID" : 11,
      "context" : "The story goes as follows (Fagin et al., 1995): Imagine n children playing together.",
      "startOffset" : 26,
      "endOffset" : 46
    }, {
      "referenceID" : 1,
      "context" : "The muddy children puzzle as a famous benchmark problem of reasoning about knowledge can be resolved by both proof-theoretic and semantical approaches (Baltag et al., 1998; Gerbrandy, 1999; Lomuscio, 1999).",
      "startOffset" : 151,
      "endOffset" : 205
    }, {
      "referenceID" : 12,
      "context" : "The muddy children puzzle as a famous benchmark problem of reasoning about knowledge can be resolved by both proof-theoretic and semantical approaches (Baltag et al., 1998; Gerbrandy, 1999; Lomuscio, 1999).",
      "startOffset" : 151,
      "endOffset" : 205
    }, {
      "referenceID" : 27,
      "context" : "The muddy children puzzle as a famous benchmark problem of reasoning about knowledge can be resolved by both proof-theoretic and semantical approaches (Baltag et al., 1998; Gerbrandy, 1999; Lomuscio, 1999).",
      "startOffset" : 151,
      "endOffset" : 205
    }, {
      "referenceID" : 6,
      "context" : "It has been proved to be the most powerful modeling of the adversary (Cervesato, 2001) because it can simulate any other possible attackers.",
      "startOffset" : 69,
      "endOffset" : 86
    }, {
      "referenceID" : 28,
      "context" : "As Lowe (1996) pointed out, the Needham-Schroeder protocol has the problem of lacking the identity of the responder and can be fixed by a small modification.",
      "startOffset" : 3,
      "endOffset" : 15
    }, {
      "referenceID" : 4,
      "context" : "There are a number of approaches dealing with the concept of variable forgetting or eliminations of middle terms (Boole, 1854) in several contexts.",
      "startOffset" : 113,
      "endOffset" : 126
    }, {
      "referenceID" : 10,
      "context" : "This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003).",
      "startOffset" : 206,
      "endOffset" : 231
    }, {
      "referenceID" : 21,
      "context" : "The notion of variable forgetting is also closely related to that of formula-variable independence, because the result of forgetting the set of variables V in a formula φ can be defined as the strongest consequence of φ being independent from V (Lang et al., 2003).",
      "startOffset" : 245,
      "endOffset" : 264
    }, {
      "referenceID" : 2,
      "context" : "There are a number of approaches dealing with the concept of variable forgetting or eliminations of middle terms (Boole, 1854) in several contexts. The notion of variable forgetting was formally defined in propositional and first order logics by Lin and Reiter (1994). In recent years, theories of forgetting under answer set programming semantics were proposed (Zhang & Foo, 2006; Eiter & Wang, 2008).",
      "startOffset" : 114,
      "endOffset" : 268
    }, {
      "referenceID" : 2,
      "context" : "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect ¬Kφ ∧ ¬K¬φ: after knowledge forgetting φ, the agent would neither know φ nor ¬φ.",
      "startOffset" : 0,
      "endOffset" : 23
    }, {
      "referenceID" : 2,
      "context" : "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect ¬Kφ ∧ ¬K¬φ: after knowledge forgetting φ, the agent would neither know φ nor ¬φ. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]φ means that after the agent forgets his knowledge about p, φ is true.",
      "startOffset" : 0,
      "endOffset" : 220
    }, {
      "referenceID" : 2,
      "context" : "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect ¬Kφ ∧ ¬K¬φ: after knowledge forgetting φ, the agent would neither know φ nor ¬φ. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]φ means that after the agent forgets his knowledge about p, φ is true. (Zhang & Zhou, 2008) modeled forgetting via bisimulation invariance except for the forgotten variable. This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003). The notion of variable forgetting has various applications in knowledge representation and reasoning. For example, Weber (1986) applied it to updating propositional knowledge bases.",
      "startOffset" : 0,
      "endOffset" : 879
    }, {
      "referenceID" : 2,
      "context" : "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect ¬Kφ ∧ ¬K¬φ: after knowledge forgetting φ, the agent would neither know φ nor ¬φ. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]φ means that after the agent forgets his knowledge about p, φ is true. (Zhang & Zhou, 2008) modeled forgetting via bisimulation invariance except for the forgotten variable. This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003). The notion of variable forgetting has various applications in knowledge representation and reasoning. For example, Weber (1986) applied it to updating propositional knowledge bases. Lang and Marquis (2002) used it for merging a set of knowledge bases when simply taking their union may result in inconsistency.",
      "startOffset" : 0,
      "endOffset" : 957
    }, {
      "referenceID" : 2,
      "context" : "Baral and Zhang (2006) treated knowledge forgetting as a special form of update with the effect ¬Kφ ∧ ¬K¬φ: after knowledge forgetting φ, the agent would neither know φ nor ¬φ. Ditmarsch, Herzig, Lang and Marquis (2008) proposed a dynamic epistemic logic with an epistemic operator K and a dynamic modal operator [Fg(p)] so that formula [Fg(p)]φ means that after the agent forgets his knowledge about p, φ is true. (Zhang & Zhou, 2008) modeled forgetting via bisimulation invariance except for the forgotten variable. This notion of variable forgetting is closely related to quantified modal logics, where the existential variable quantification can be modeled via bisimulation invariance except for the quantified variable (Engelhardt et al., 2003). The notion of variable forgetting has various applications in knowledge representation and reasoning. For example, Weber (1986) applied it to updating propositional knowledge bases. Lang and Marquis (2002) used it for merging a set of knowledge bases when simply taking their union may result in inconsistency. The notion of variable forgetting is also closely related to that of formula-variable independence, because the result of forgetting the set of variables V in a formula φ can be defined as the strongest consequence of φ being independent from V (Lang et al., 2003). More recently, Liu and Lakemeyer (2009) applied the notion of forgetting into the situation calculus, and obtained some interesting results about the first-order definability and computability of progression for local-effect actions.",
      "startOffset" : 0,
      "endOffset" : 1368
    }, {
      "referenceID" : 11,
      "context" : "First, we will investigate whether our knowledge structures can be extended and used as a basis for knowledge based programming (Fagin et al., 1995).",
      "startOffset" : 128,
      "endOffset" : 148
    }, {
      "referenceID" : 24,
      "context" : "Secondly, in our current framework of knowledge structures, we have not considered the issue of only knowing which has been extensively studied in other knowledge reasoning models (Halpern & Lakemeyer, 1996; van der Hock, Jaspars, & Thijsse, 2003; Levesque, 1990).",
      "startOffset" : 180,
      "endOffset" : 263
    }, {
      "referenceID" : 44,
      "context" : "Finally, recent research has shown that knowledge update has many important applications in reasoning about actions and plans and dynamic modeling of multi-agent systems (Zhang, 2003).",
      "startOffset" : 170,
      "endOffset" : 183
    }, {
      "referenceID" : 9,
      "context" : "First, we will investigate whether our knowledge structures can be extended and used as a basis for knowledge based programming (Fagin et al., 1995). Secondly, in our current framework of knowledge structures, we have not considered the issue of only knowing which has been extensively studied in other knowledge reasoning models (Halpern & Lakemeyer, 1996; van der Hock, Jaspars, & Thijsse, 2003; Levesque, 1990). It will be an interesting topic of how our knowledge model handles only knowing in reasoning about knowledge. Thirdly, the notions and methods in this work can be extended to investigate the extension of the variable forgetting operator to multi-agent logics of beliefs. Finally, recent research has shown that knowledge update has many important applications in reasoning about actions and plans and dynamic modeling of multi-agent systems (Zhang, 2003). A first step in this direction (in mono-agent S5) can be found in the work of Herzig, Lang and Marquis (2003). Baral and Zhang have proposed a general model for performing knowledge update based on the standard single agent S5 modal logic (Baral & Zhang, 2001).",
      "startOffset" : 129,
      "endOffset" : 981
    } ],
    "year" : 2009,
    "abstractText" : "In this paper, we investigate knowledge reasoning within a simple framework called knowledge structure. We use variable forgetting as a basic operation for one agent to reason about its own or other agents’ knowledge. In our framework, two notions namely agents’ observable variables and the weakest sufficient condition play important roles in knowledge reasoning. Given a background knowledge base Γ and a set of observable variables Oi for each agent i, we show that the notion of agent i knowing a formula φ can be defined as a weakest sufficient condition of φ over Oi under Γ. Moreover, we show how to capture the notion of common knowledge by using a generalized notion of weakest sufficient condition. Also, we show that public announcement operator can be conveniently dealt with via our notion of knowledge structure. Further, we explore the computational complexity of the problem whether an epistemic formula is realized in a knowledge structure. In the general case, this problem is PSPACE-hard; however, for some interesting subcases, it can be reduced to co-NP. Finally, we discuss possible applications of our framework in some interesting domains such as the automated analysis of the well-known muddy children puzzle and the verification of the revised Needham-Schroeder protocol. We believe that there are many scenarios where the natural presentation of the available information about knowledge is under the form of a knowledge structure. What makes it valuable compared with the corresponding multi-agent S5 Kripke structure is that it can be much more succinct.",
    "creator" : " TeX output 2009.08.13:2309"
  }
}