{
  "name" : "1412.0320.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Canonical Logic Programs are Succinctly Incomparable with Propositional Formulas",
    "authors" : [ "Yuping Shen", "Xishun Zhao" ],
    "emails" : [ "hsszxs}@mail.sysu.edu.cn" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n41 2.\n03 20\nv2 [\ncs .L"
    }, {
      "heading" : "1 Introduction",
      "text" : "The study of logic programs under answer set semantics, i.e., answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades. As a competing approach to SAT [4], ASP has been successfully applied in many fields like Planning, Commonsense Reasoning, Scheduling, etc.\n∗Extended version of a paper with the same name in KR2014. †Corresponding Author.\nThe relationship between logic programs and propositional formulas (PF) gains a lot of attention in the literature. A well-known theorem shown by Lin & Zhao [29] gives a method for translating a normal (logic) program (LP) to a (logically) equivalent set of formulas in PF, without introducing additional variables. However, it has been observed that the translation may result in an exponential number of socalled loop formulas in the worst case. In 2006, Lifschitz and Razborov proved that such exponential blowup is generally inevitable, more precisely, they showed that (a variant of) the P-complete problem PATH has polynomial size representations in LP, however, it cannot be polynomially represented in PF (assuming P * NC1/poly) [28]. In other words, we say PATH separates LP from PF.\nAs noted in [28], PF can be considered as a special case of (nondisjunctive) nested programs (NLP) [25], which is a general form of programs that subsumes LP and some other kinds of programs. Therefore, NLP is stronger than PF in terms of the succinctness criterion (or the “comparative linguistics” approach) proposed in [17]:\nThat is, we consider formalism A to be stronger than formalism B if and only if any knowledge base (KB) in B has an equivalent KB in A that is only polynomially longer, while there is a KB in A that can be translated to B only with an exponential blowup.\nSo the following footnote in [26] seems convincing at first glance:\n...ASP appears to be stronger than SAT in the sense of the “comparative linguistics” approach to knowledge representation...\nHowever, since ASP involves many kinds of programs, the above statement probably needs further clarification. Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a “minimal” form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger. So a question naturally arises: Does there exist a problem that separates CP from PF? If there is such a problem, then CP and PF are succinctly incomparable (assuming P * NC1/poly).\nIn this paper we address the question and give a positive answer. Our main result shows that the problem PARITY separates PF from CP. Simply speaking, this means an exponential size blowup is generally inevitable when translating a set of formulas in PF into an equivalent program in CP (without introducing new variables). The PARITY problem asks whether a binary string contains an odd number of 1’s, and it is well-known that (i) PARITY∈ NC1/poly, i.e., it has polynomial representations in PF2 [3, 21], (ii) PARITY/∈ AC0, i.e., it cannot be represented by polynomial size boolean circuits with constant depth and unbounded fan-in [14, 20].\nTo show PARITY separates PF from CP, we provide a procedure that simplifies every PARITY program Π into a shorter, loop-free program Π′. By Lin-Zhao\n1Extends LP with connective not not. 2NC1/poly (or non-uniform NC1) exactly contains languages computable (i.e., representable) by\npolynomial size propositional formulas.\nTheorem (or the (generalized) Fages Theorem [11, 10, 33]), Π′ is equivalent to its completion Comp(Π′), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |Π′|. According to PARITY/∈ AC0, these circuits must be of exponential size, consequently, there are no polynomial size CP programs for PARITY.\nFrom the view of the theory of computation, the above result may also be considered as the separation of two models of computation [31], i.e., we identify a language in NC1/poly which is not in the set of languages computable by polynomial size CP programs. Based on the observation, we point out more separation results on some classes of logic programs, e.g., PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC1/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.\nThe rest of the paper is organized as follows: Section 2 gives preliminaries to the semantics of canonical programs, the concepts of succinctness and the PARITY problem. In Section 3 we briefly review the notation of boolean circuit, the completion semantics and the Lin-Zhao theorem. Section 4 illustrates how to simply an arbitrary PARITY program to be loop-free and presents the main theorem. In Section 5 we discuss the importance of succinctness research and point out more results on a family of logic program classes. Conclusions are drawn in the last Section."
    }, {
      "heading" : "2 Background",
      "text" : ""
    }, {
      "heading" : "2.1 Canonical Programs",
      "text" : "The following notations are adopted from [25, 22]. A rule element e is defined as\ne := ⊤ | ⊥ | x | not x | not not x\nin which ⊤,⊥ are 0-ary connectives, x is a (boolean) variable (or an atom) and not is a unary connective3. A (nondisjunctive canonical) rule is an expression of the form\nH ← B (1)\nwhere the head H is either a variable or the connective ⊥, and the body B is a finite set of rule elements. A canonical program (CP) Π is a finite set of rules, Π is normal if it contains no connectives not not. A normal program Π is basic if it contains no connectives not. The following is a canonical program:\nx1 ← not not x1, x2 ← not not x2, x3 ← not x1, not x2, x3 ← x1, x2.\n(2)\n3According to [25], not not not x can be replaced by not x.\nThe satisfaction relation |= between a set of variables I and a rule element is defined as follows:\n• I |= ⊤ and I 2 ⊥,\n• I |= x iff I |= not not x iff x ∈ I ,\n• I |= not x iff x /∈ I .\nSay I satisfies a set of rule elements B if I satisfies each rule elements in B. We say I is closed under a program Π, if I is closed under every rule in Π, i.e., for each rule H ← B ∈ Π, I |= H whenever I |= B. Let Π be a basic program, Cn(Π) denotes the minimal set (in terms of inclusion) closed under Π, we say I is an answer set of Π if I = Cn(Π). Note that a basic program has exactly one answer set.\nThe reduct ΠI of a canonical program Π w.r.t. I is a set of rules obtained from Π via: (i) Replacing each not not x with ⊤ if I |= x, and with ⊥ otherwise; (ii) Replacing each not x with ⊤ if I 2 x, and with ⊥ otherwise. Observe that ΠI must be a basic program. We say I is an answer set of Π if I = Cn(ΠI), i.e., I is an answer set of ΠI .\nThe following single rule canonical program Π:\nx← not not x (3)\nhas two answer sets {x} and ∅. To see this, check that Π{x} is {x ← ⊤}, whose only answer set is {x}. Similarly, Π∅ is {x← ⊥}, whose only answer set is ∅. For convenience, ⊤ in the body is often omitted.\nFor a set of rule elements B, define var(B) = {e ∈ B : e is a variable}. E.g., var({x1, not x2, not not x3}) = {x1}. Let Π be a program, by var(Π) we denote the set of all variables involved in Π and by Ans(Π) we denote the set of all answer sets of Π. E.g., let Π be program (2), then var(Π) = {x1, x2, x3} and Ans(Π) = {{x1, x2, x3}, {x1}, {x2}, {x3}}. As a convention, by Πn we refer to a program with n variables {x1, . . . , xn}, i.e., var(Πn) = {x1, . . . , xn}. The size |Πn| of a program Πn, is the number of rules in it."
    }, {
      "heading" : "2.2 Problem Representation and Succinctness",
      "text" : "A string is a finite sequence of bits from {0, 1}. A string w of length n (i.e., w ∈ {0, 1}n) can be written as w1w2 . . . wn, in which each bit wi ∈ {0, 1}. Note that a string w ∈ {0, 1}n defines a subset of variables {x1, . . . , xn}, e.g., 1010 stands for {x1, x3}. So a set of variables and a string is regarded as the same. A problem (or language ) L is a set of strings.\nDefinition 2.1 (Problem Representation). A problem L can be represented in a class of programs C (i.e., L ∈ C), if there exists a sequence of programs {Πn} (n = 1, 2, . . .) in C that computes L, i.e., for every string w ∈ {0, 1}n,\nw ∈ L ⇔ w ∈ Ans(Πn).\nMoreover, say L has polynomial representations in C (i.e., L ∈ Poly-C), if L ∈ C and |Πn| is bounded by a polynomial p(n).\nThe following concept is adopted from [17, 13].\nDefinition 2.2 (Succinctness). Let C, C′ be two classes of programs and for every problem L, L ∈ C ⇔ L ∈ C′. Say C is at least as succinct as C′ (i.e., C′ C), if for every problem L,\nL ∈ Poly-C′ ⇒ L ∈ Poly-C.\nIf L ∈ Poly-C but L 6∈ Poly-C′ (i.e., C 6 C′), then L separates C from C′. If C′ C and C 6 C′, then C is strictly more succinct than C′ (i.e., C′ ≺ C). Moreover, C, C′ are succinctly incomparable if there is a problem L separates C from C′, and vice versa ( i.e.,C 6 C′ and C′ 6 C).\nPlease note that the above notions also apply to formalisms like PF or boolean circuits, etc."
    }, {
      "heading" : "2.3 The PARITY Problem",
      "text" : "The PARITY problem is defined as:\nPARITY = {Binary strings with an odd number of 1’s}.\nWe may simply call a string in PARITY an odd string, and PARITYn denotes the set of odd strings of length n. Observe that PARITYn contains 2n−1 strings. It is not hard to see that PARITYn for n = 1, 2 can be computed by normal programs Π1 = {x1 ←} and Π2 = {x1 ← not x2, x2 ← not x1} respectively. Since Ans(Π1) = {1} (i.e., {x1}), and Ans(Π2) = {10, 01} (i.e., {x1}, {x2}). However, as stated below, PARITYn for n ≥ 3 have no representations in normal programs.\nTheorem 2.1 (PARITY/∈LP). PARITY cannot be represented by normal programs.\nProof. Suppose there is a normal program Πn that computes PARITYn for a fixed n ≥ 3. Then {x1} and {x1, x2, x3}, which are two odd strings, belong toAns(Πn). However, this is impossible since it contradicts the anti-chain property of Πn [28]: if strings I, I ′ ∈ Ans(Πn) and I ⊆ I ′ then I = I ′.\nOn the other hand, the anti-chain property is suppressed in CP. E.g., the answer set 111 of program (2) is a superset of the other three answer sets 100, 010, 001. Clearly, program (2) represents PARITY3, moreover, it suggests a “pattern” for representing PARITYn: The first part of the program (e.g., the first two rules in (2)) generates all possible strings of n − 1 bits, the second part identifies the last bit to produce an odd string.\nTherefore, it is straightforward to give a sequence of canonical programs {Πn} for PARITYn. The following is a PARITY4 program generated from the pattern:\nx1 ← not not x1, x2 ← not not x2, x3 ← not not x3,\nx4 ← x1, x2, not x3, x4 ← x1, x3, not x2, x4 ← x2, x3, not x1,\nx4 ← not x1, not x2, not x3.\n(4)\nPlease note that the number of rules involved in the second part of the pattern grows exponentially, since the number of odd strings with the last bit 1 grows exponentially.\nTheorem 2.2 (PARITY∈CP). PARITY can be represented by exponential size canonical programs.\nBy PF we denote propositional formulas built on classical connectives {∧,∨,¬} with boolean variables. Related concepts like satisfaction, model etc., are defined as usual. ByM(φ) we denoted the set of models of φ. The size |φ| of a formula φ is the number of connectives occur in it. PARITYn for n = 1, 2 can be represented by formulas x1 and (x1 ∧ ¬x2)∨ (¬x2 ∧ x1). Furthermore, it is a textbook result that PARITYn for n ≥ 3 has polynomial size formulas in PF, i.e., PARITY∈ NC1/poly (or Poly-PF) [3, 21].\n3 Boolean Circuits, Completion and PARITYn Programs for n ≤ 2"
    }, {
      "heading" : "3.1 Boolean Circuits",
      "text" : "A (boolean) circuit is a directed, cycle-free graph where each node is either a gate marked with one of {∧,∨,¬} or a boolean variable. The in-degree (resp. out-degree) of a node is called its fan-in (resp. fan-out). A node marked with a variable always has fan-in 0 and is called an input. The output of the circuit is one gate designated with fan-out 0.\nThe value of a circuit Cn under inputs x1, . . . , xn, denoted by Cn(x1, . . . , xn), is the value of the output obtained from an iterative calculation through the inputs and the intermediate gates in the usual way. The size |Cn| of a circuit Cn is the number of gates occur in it. The depth of a circuit is the length of the longest path from an input to the output. We say a circuit computes (or represents) a problem L ⊆ {0, 1}n, if w ∈ L ⇔ Cn(w) = 1. E.g., a circuit C2 that computes PARITY2 is shown in Fig. 1. If L consists of strings of arbitrary lengths, then we introduce a sequence of circuits {Cn}(n = 1, 2, . . .) to represent L, as indicated in Definition 2.1.\nA circuit is said with bounded fan-in if each gate has at most fain-in 2. If we do not have such restriction then the circuit is with unbounded fan-in. The class AC0\nexactly contains all problems that can be computed by a sequence of circuits {Cn} in which the circuits Cn have constant depth and polynomial size p(n).\nE.g., a sequence of polynomial size CNFs {ψn} computes an AC0 language, in which a CNF is a conjunction of clause of the form (L1 ∨ . . . ∨ Lm), where each Li is either a variable x or a negated variable ¬x. Observe that CNF has constant depth 2 (¬ is usually not counted in the depth), and each clause can be regarded as an unbounded fan-in gate ∨ with m inputs. Note that {ψn} cannot represent PARITY since PARITY/∈ AC0. For more details about circuits, please see [3]."
    }, {
      "heading" : "3.2 Completion and Related Theorems",
      "text" : "The completion Comp(Π) [6, 10] of a canonical program Π, consists of a set (or conjunction) of formulas4:\n• x ≡ B̃1 ∨ B̃2 ∨ · · · ∨ B̃m, where x ← B1, . . . , x ← Bm are all rules in Π with head x, and each B̃i is the conjunction of rule elements in Bi with connective not replaced by ¬,\n• x ≡ ⊥, if x is not a head of any rule in Π,\n• ¬B̃, if a rule ⊥ ← B is in Π.\nProposition 3.1. Let Π be an arbitrary canonical program. Then Comp(Π) is a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |Π|.\nProof. All propositional formulas are circuits of fan-out 1, so Comp(Π) is definitely a circuit. Clearly, its size is polynomially bounded by |Π|, and its depth is a constant for arbitrary program Π. Moreover, there are no restrictions on the number of rule elements in a body or the number of rules in Π, therefore the corresponding gates in Comp(Π) are with unbounded fan-in.\nIt is well-known that every answer set of a canonical program Π is a model of Comp(Π), but the inverse is generally not hold. E.g., the completion of the program x← x has two models {x} and ∅, while it has a unique answer set ∅. It turns\n4For convenience, we slightly abuse the connective ≡ here.\nout that x← x gives rise to a so-called loop, which leads to an inappropriate model. It is shown in [29, 23] that the so-called loop formulas LF (Π) nicely eliminate inappropriate models of Comp(Π), s.t. the models of the union (or conjunction) of LF (Π) and Comp(Π) are coincided with Ans(Π).\nThe (positive) dependency graph [2] of a canonical program Π is a pair (N,E) in which the set of nodes N = var(Π), and E contains a directed edge (x, x′) iff there is a rule H ← B in Π s.t. H = x and x′ ∈ B. Note that rule elements of the form not x′ or not not x′ in B do not contribute to the edges. A non-empty set of variables U ⊆ var(Π) is called a loop of Π, if i) U is a singleton {x} and (x, x) ∈ E, or ii) U is not a singleton and the restriction of the graph on U is strongly connected.\nLetU be a loop of Π, defineR−(U,Π) = {H ← B ∈ Π : H ∈ U, ¬∃ variable x ∈ B s.t. x ∈ U}. Let {B1, . . . , Bm} be all the bodies of the rules in R−(U,Π), then the loop formula LF (U,Π) is the following:\n¬[B̃1 ∨ . . . ∨ B̃m] ⊃ ∧\nx∈U\n¬x. (5)\nLF (Π) denotes the conjunction of all loop formulas of Π.\nTheorem 3.1 (Lin-Zhao Theorem[29, 23]). Let Π be a canonical program. Then Π is equivalent to Comp(Π) ∪ LF (Π), i.e., Ans(Π) =M(Comp(Π) ∪ LF (Π)).\nBy Theorem 3.1 (or the (generalized) Fages theorem [11, 10, 33]), if Π has no loops, then LF (Π) is a tautology ⊤ and Π is equivalent to Comp(Π) (i.e., completion-equivalent).\n3.3 PARITYn Programs for n ≤ 2\nProposition 3.2. Let Π1 be a PARITY1 canonical program. Then Π1 is equivalent to Comp(Π1).\nProof. By Theorem 3.1, the unique answer set {x1} of Π1 is a model ofComp(Π1)∪ LF (Π1), which also is a model of LF (Π1). There are two cases about the loops in Π1: (i) Π1 has no loops. LF (Π1) is simply ⊤; (ii) Π1 has a singleton loop {x1}. Recall that LF (Π1) is a formula of the form ¬[B̃1 ∨ . . . ∨ B̃m] ⊃ ¬x1, in which B1 . . . Bm are all the bodies of rules in R−({x1},Π1). In both cases, ∅ is a model of LF (Π1), so LF (Π1) is a tautology. Therefore, Π1 is equivalent to Comp(Π1).\nObserve that Proposition 3.2 does not hold for PARITY2 programs. Consider the following PARITY2 program:\nx1 ← not x2, x2 ← not x1, x1 ← x1, x2 ← x2.\n(6)\nClearly, {x1, x2} (i.e., 11) is not an answer set of (6), but a model of its completion {x1 ≡ x1 ∨ ¬x2, x2 ≡ x2 ∨ ¬x1}.\nNote that the rules {x1 ← x1, x2 ← x2} contribute to so-called singleton loops. We may check that without the above two rules, program (6) is a completionequivalent PARITY2 program. In fact, such “singleton loop” rules can be always safely removed, as stated in Proposition 3.3.\nLet Π be a basic program and I be a set of variables, define the Knaster-Tarski operator [2] as TΠ(I) = {H : H ← B ∈ Π and I |= B}. The operator T is monotone w.r.t. I therefore has a least fixed point T∞\nΠ (∅), which can be computed\nby: (i) T 0 Π (∅) = ∅; (ii) T i+1 Π (∅) = TΠ(T i Π (∅)) and (iii) T∞ Π (∅) = ⋃ i≥0(T i Π (∅)). Moreover, T is also monotone w.r.t. Π for a given I , i.e., TΠ(I) ⊆ TΠ′(I) if Π ⊆ Π′. It is pointed out in [15, 33] that I ∈ Ans(Π) iff I = T∞\nΠI (∅) for a canonical\nprogram Π.\nProposition 3.3. Let Π be a canonical program. Then removing each rule x ← B ∈ Π with x ∈ var(B) results in a program Π′ s.t. Ans(Π) = Ans(Π′).\nProof. It is sufficient to show T∞ ΠI (∅) = T∞ Π′I (∅) for any set I of variables. Suppose H ∈ T∞\nΠI (∅) for some I , then ∃i > 0, H ∈ T i ΠI (∅) and H /∈ T i−1 ΠI (∅). It is not\nhard to see that H must be obtained from a rule H ← B in Π s.t. H /∈ var(B), H ← var(B) ∈ ΠI and T i−1\nΠI (∅) |= var(B). Note that H ← B ∈ Π′ and\nH ← var(B) is in Π′I as well. Now we show H ∈ T∞ Π′I (∅). Suppose H ∈ T 1 ΠI (∅). So a rule H ← is in ΠI and Π′I , clearly H ∈ T∞\nΠ′I (∅). Let k > 1 and assume for\nall i < k, T i ΠI (∅) ⊆ T∞ Π′I (∅). Suppose H ′ ∈ T k ΠI (∅), then ∃H ′ ← var(B′) ∈ ΠI s.t. T k−1 ΠI (∅) |= var(B′). Obviously H ′ ∈ T∞ Π′I (∅) since H ′ ← var(B′) ∈ Π′I and T∞ Π′I (∅) |= var(B′) by induction hypothesis. Therefore T∞ ΠI (∅) ⊆ T∞ Π′I\n(∅). Note that Π′I ⊆ ΠI since Π′ ⊆ Π. It follows that T∞\nΠ′I (∅) ⊆ T∞ ΠI (∅) due to the\nmonotonicity of operator T . Hence T∞ ΠI (∅) = T∞ Π′I (∅).\nIt turns out that we have a more general observation: deleting all rules with variables in the body (thus removing all loops) does not affect the answer sets of a PARITY2 program!\nProposition 3.4. LetΠ2 be a PARITY2 canonical program. Then there is a PARITY2 program Π′2 which is equivalent to Comp(Π ′ 2) and |Π ′ 2| ≤ |Π2|.\nProof. W.l.o.g., assume Π2 has no singleton loops. Let Π′2 = {H ← B ∈ Π2 : var(B) = ∅}, clearly Π′2 ⊆ Π2 and thus |Π ′ 2| ≤ |Π2|. To see Π ′ 2 is also a PARITY2 program, it is sufficient to show for any I ∈ Ans(Π2), Cn(ΠI2) = Cn(Π ′I 2 ). Suppose H ∈ I , i.e., H ∈ Cn(ΠI2). We claim that H must be obtained from a rule H ← B in Π2 s.t. (i) I |= B, and (ii) var(B) = ∅. Clearly (i) holds. To see (ii), note that Π2 has exactly two answer sets {x1} and {x2}. W.l.o.g., let I = {x1} thus H = x1. Since Π2 has no singleton loops, x1 /∈ var(B), and x2 /∈ var(B) since I |= B. Hence var(B) = ∅.\nNow it is easy to see H ← B ∈ Π′2 and H ←∈ Π ′I 2 since I |= B and\nvar(B) = ∅. Thus H ∈ Cn(Π′I2 ). Therefore Cn(Π I 2) ⊆ Cn(Π ′I 2 ). Since Π ′ 2 ⊆\nΠ2, we have Cn(Π′I2 ) ⊆ Cn(Π I 2) due to the monotonicity of operator Cn(·). Consequently, Cn(ΠI2) = Cn(Π ′I 2 ). Observe that Π ′ 2 has no loops, so Π ′ 2 is equivalent to Comp(Π′2) .\nConsider the following PARITY2 program (7), which has a non-singleton loop {x1, x2} but not completion-equivalent. One may see that removing the two rules in the second line makes it completion-equivalent, without affecting its answer sets.\nx1 ← not x2, x1 ← x2, not not x1, x2 ← not x1, x2 ← x1, not not x2.\n(7)\nIn the following, we shall introduce a general approach to simply an arbitrary PARITY program to be completion-equivalent.\n4 General Simplification of PARITYn Programs\nLet B be a set of rule elements built on associated variables V = {x1, . . . , xn}. We say B is consistent if there is a set of variables I s.t. I |= B. Define S(B) to be the set {I ⊆ V : I |= B}. E.g., let V = {x1, x2, x3, x4} and B = {x2, not x3, not not x4}, thenB is consistent and S(B) = {{x1, x2, x4}, {x2, x4}} = {1101, 0101}. Clearly, if B is not consistent then S(B) = ∅. Note that if a rule has an inconsistent body, then it is redundant and can be safely removed.\nWe say B covers a variable x ∈ V iff x ∈ B or not x ∈ B or not not x ∈ B. If B covers every variable in V thenB fully covers V . E.g.,B = {x1, not x2, not not x3} fully covers V = {x1, x2, x3}. Obviously, B is consistent and fully covers V iff S(B) contains a unique string.\nIn the next section, we stipulate that the set of associated variables is var(Πn) whenever Πn is the program under discussion, we also assume that a PARITY program has no singleton-loops and contains no inconsistent bodies."
    }, {
      "heading" : "4.1 Simplifying Full Coverage Rules",
      "text" : "A rule H ← B ∈ Πn is a full coverage rule if B fully covers var(Πn).\nLemma 4.1. Let Πn be a PARITYn program. Suppose there is a rule x ← B in Πn s.t. not not x ∈ B and S(B) contains a unique even string. Then removing x← B from Πn results in a PARITYn program Π′n.\nProof. We show for any set I of variables, I = Cn(ΠIn) iff I = Cn(Π ′I n ). Observe that Π′n ⊆ Πn, then Cn(Π ′I n ) ⊆ Cn(Π I n) for any I . So it is sufficient to show Cn(ΠIn) ⊆ Cn(Π ′I n ). Assume Cn(Π I n) * Cn(Π ′I n ) for some I . It must be the case that x ∈ Cn(ΠIn) and x /∈ Cn(Π ′I n ) since Π ′ n ∪ {x ← B} = Πn. Moreover, we have x ← var(B) ∈ ΠIn and Cn(Π I n) |= var(B). The former implies that I |= B \\ var(B). Since not not x ∈ B \\ var(B), we have I |= not not x (i.e., x ∈ I).\nNow suppose I = Cn(ΠIn), then I is an odd string. However, recall that I |= B \\ var(B) and I = Cn(ΠIn) |= var(B). Hence we have I |= B, i.e., I ∈ S(B). This contradicts the fact that I ∈ S(B) is an even string. So Cn(ΠIn) ⊆ Cn(Π ′I n ).\nSuppose I = Cn(Π′In ). As mentioned above, Cn(Π I n) * Cn(Π ′I n ) implies that\nx /∈ Cn(Π′In ) and x ∈ I . However, recall that I = Cn(Π ′I n ), hence x ∈ Cn(Π ′I n ), a contradiction. So Cn(ΠIn) ⊆ Cn(Π ′I n ).\nNote that Lemma 4.1 also justifies our simplification for (7).\nLemma 4.2. Let Πn be a PARITYn program. Suppose there is a rule x ← B in Πn s.t. not not x ∈ B and S(B) contains a unique odd string. Then replacing its body B with B′ = B \\ {not not x} results in a PARITYn program Π′n.\nProof. We show that I = Cn(ΠIn) iff I = Cn(Π ′I n ) for any set I of variables. Suppose I = Cn(ΠIn), we shall prove Cn(Π I n) = Cn(Π ′I n ). Consider the following cases:\n• I |= B \\ var(B). Since B′ = B \\ {not not x}, clearly, B′ \\ var(B′) ⊆ B \\var(B), hence I |= B′\\var(B′). It follows that x← var(B) ∈ ΠIn and x ← var(B′) ∈ Π′In . Furthermore, note that Πn \\ {x ← B} = Π ′ n \\ {x ←\nB′} and var(B) = var(B′), thus ΠIn = Π ′I n . So Cn(Π I n) = Cn(Π ′I n ).\n• I 2 B \\ var(B). Consider the following subcases:\n– I 2 B′ \\ var(B′). Similarly, we have Π′In = Π I n, thus Cn(Π ′I n ) =\nCn(ΠIn).\n– I |= B′ \\ var(B′). Clearly, in this case I 2 not not x. Now suppose I |= var(B′), so we have I |= B′. Recall that (i) not not x ∈ B, (ii) x /∈ B since Πn has no singleton loops, (iii) B′ = B \\{not not x} and (iv) S(B) contains a unique odd string, say I ′. It follows that S(B′) = {I ′, I ′ \\ {x}}. Obviously I must be I ′ \\ {x} since I ′ |= not not x. However, this is a contradiction since I ′ \\ {x} is an even string and I is an odd string since I is an answer set of Πn. So suppose I 2 var(B). Note that in this case Π′In = Π I n ∪ {x ← var(B)}, we show\nCn(ΠIn) = Cn(Π I n ∪ {x ← var(B)}), i.e., Cn(Π I n) = Cn(Π ′I n ). Firstly, Cn(ΠIn) ⊆ Cn(Π I n ∪{x← var(B)}) due to the monotonicity of operator Cn(·). Assume Cn(ΠIn ∪ {x ← var(B)}) * Cn(Π I n), it must be Cn(ΠIn) |= var(B) and x ∈ Cn(Π I n ∪ {x ← var(B)}), x /∈ Cn(ΠIn). However this is impossible since I = Cn(Π I n) and I 2 var(B). Therefore Cn(ΠIn ∪ {x← var(B)}) ⊆ Cn(Π I n).\nSuppose I = Cn(Π′In ), we shall prove Cn(Π I n) = Cn(Π ′I n ). Consider the\nfollowing cases:\n• x ← var(B′) /∈ Π′In . Clearly, I 2 B ′ \\ var(B′). So I 2 B \\ var(B) since\nB′ \\ var(B′) ⊆ B \\ var(B). Therefore x ← var(B) /∈ ΠIn and we have Π′In = Π I n. Hence Cn(Π ′I n ) = Cn(Π I n).\n• x← var(B′) ∈ Π′In . There are two subcases:\n– x ← var(B) ∈ ΠIn. Similarly, Π ′I n = Π I n and then Cn(Π ′I n ) =\nCn(ΠIn).\n– x ← var(B) /∈ ΠIn. Clearly, I 2 not not x, i.e., x /∈ I . Furthermore, recall that Π′In = Π I n ∪ {x ← var(B\n′)}, We shall show Cn(Π′In ) = Cn(ΠIn). Obviously Cn(Π I n) ⊆ Cn(Π ′I n ). Now assume Cn(Π ′I n ) * Cn(ΠIn). It must be the case that x ∈ Cn(Π ′I n ) but x /∈ Cn(Π I n). However, since I = Cn(Π′In ), we have x ∈ I , a contradiction. So Cn(Π′In ) ⊆ Cn(Π I n), therefore Cn(Π ′I n ) = Cn(Π I n).\n4.2 Standard PARITYn Programs\nA PARITYn program Πn is standard if for each rule x← B ∈ Πn, not not x /∈ B whenever S(B ∪ {x}) contains a unique string. E.g., the PARITY program (2) is standard, while (7) is not. Note that if Πn is standard, then for any rule x ← B ∈ Πn, B does not cover x, i.e., x /∈ B, not x /∈ B and not not x /∈ B, since Πn has no singleton loops and S(B ∪ {x}) is consistent.\nProposition 4.1. Let Πn be a PARITYn program. Then there is a standard PARITYn program Π′n s.t. |Π ′ n| ≤ |Πn|.\nProof. For each rule x ← B ∈ Πn in which not not x ∈ B and S(B) contains a unique string: (i) Delete x ← B from Πn if S(B) contains an even string; (ii) Remove not not x from B if S(B) contains an odd string. By Lemma 4.1 and 4.2, the above procedure results in a standard PARITYn program Π′n and |Π ′ n| ≤ |Πn|.\nProposition 4.2. Let Πn be a standard PARITYn program. Then Πn is equivalent to its completion Comp(Πn).\nThe proof idea of Proposition 4.2 is that every standard PARITYn program Πn can be equivalently rewritten to a loop-free program Π′n by replacing each x ∈ var(B) with not not x for every rule bodyB in Πn. By the Lin-Zhao Theorem or the (generalized) Fages Theorem, Π′n is equivalent to its completion Comp(Π ′ n). And then the proposition follows from the fact that Comp(Π′n) = Comp(Πn), since not is treated as classical negation ¬ in the completion. The detailed proof is presented in subsection 4.3."
    }, {
      "heading" : "4.3 Proof of Proposition 4.2",
      "text" : "For technical reasons, we divide the rewriting procedure into two steps, in the first step a standard PARITY program is converted to so-called almost pure program and in the second step the program is converted to a pure one, i.e., a PARITY program that does not have any loops. Before doing so we show some lemmas.\nLemma 4.3. Let Πn be a standard PARITYn program. For each rule x← B ∈ Πn, if S(B ∪ {x}) contains a unique string, then the string must be odd.\nProof. Since Πn is standard, B does not cover x. So we have S(B) = {I, I \\{x}}. Assume I is an even string, then I \\ {x} must be an odd string. It follows that I \\ {x} is not closed under x← B, since I \\ {x} |= B but I \\ {x} 2 x. However, Πn is a PARITYn program, every odd string must be closed under x ← B. A contradiction.\nLemma 4.4. Let Πn be a PARITYn program.\n(i) If there is a rule x← B ∈ Πn s.t. B is consistent and B ∪ {x} does not fully cover var(Πn), then not not x ∈ B.\n(ii) If there is a rule H ← B ∈ Πn s.t. B is consistent and B ∪ {H} is inconsistent, then B fully covers var(Πn).\nProof. Note that for any rule x ← B in a PARITY1 program, B ∪ {x} must fully cover var(Π1) since Π1 involves only one variable. So in the following we consider n ≥ 2.\n(i) Equivalently, we show that if B is consistent and not not x /∈ B, then B ∪ {x} fully covers var(Πn). Assume B ∪ {x} does not fully cover var(Πn). It follows that B covers 0 ≤ i < n variables in var(Πn) (i.e., B does not fully cover var(Πn)). Consider the following cases:\n• not x ∈ B. Note that B is consistent and n ≥ 2. It is not hard to see S(B) has exactly 2n−i−1 ≥ 1 odd strings. It means there is at least one odd string I , I |= B and I 2 x. Therefore I is not close under x← B. However, since Πn is a PARITYn program, every odd string must be closed under x ← B. A contradiction.\n• not x /∈ B. B does not cover x, since not not x /∈ B and x /∈ B for Πn has no singleton loops. Recall that B is consistent and n ≥ 2, thus S(B) has exactly 2n−i−1 odd strings. Obviously, half of these strings do not satisfy x. To be more precise, there are 2n−i−2 odd strings I , I |= B and I 2 x. We have 2n−i−2 ≥ 1 since i is at most n−2. In other words, there is at least one odd string I which is not close under x← B. Again a contradiction.\nConsequently, B ∪ {x} must fully cover var(Πn). (ii) There are two cases about H:\n• H is ⊥. Assume B does not fully cover var(Πn), i.e., B covers i variables in var(Πn) with 0 ≤ i < n. Since B is consistent, it is easy to see S(B) has exactly 2n−i−1 ≥ 1 odd strings. So there exists at least one odd string I is not closed under ⊥ ← B. A contradiction.\n• H is a variable x ∈ var(Πn). SinceB∪{x} is inconsistent, we have not x ∈ B. It is not hard to see in this case x ← B can be rewritten as ⊥ ← B. By an argument similar to the above, B must fully cover var(Πn).\n4.3.1 Almost Pure PARITYn Programs\nLet Πn be a standard PARITYn program in CP, by F−(Πn) we denote the set of rules H ← B ∈ Πn s.t. B ∪ {H} does not fully cover var(Πn), by F+(Πn) we denote Πn \\ F−(Πn). If for each rule H ← B ∈ F+(Πn) we have var(B) = ∅, then Πn is called almost pure.\nBy Lemma 4.4, it is not hard to see that every rule of the form x← B,not not x is in F−(Πn), and every rule of the form ⊥ ← B or x← B,not x is in F+(Πn).\nProposition 4.3. Let Πn be a standard PARITYn program. Then there is an almost pure PARITYn program Π′n s.t. |Π ′ n| ≤ |Πn|.\nProof. Let B′ be the set obtained from B by replacing every x ∈ var(B) with not not x. Note that I |= B iff I |= B′ for any set of variables I . Let Π′n be the program obtained from Πn by replacing every rule H ← B ∈ F+(Πn) with H ← B′. Clearly Π′n is almost pure and |Π ′ n| ≤ |Πn|. It remains to prove that Π ′ n is also a PARITYn program, i.e., I = T∞ΠIn (∅) iff I = T∞ Π′In (∅).\n(⇒) Suppose I is an answer set of Πn, i.e., I = T∞ΠIn (∅), we shall show\nT∞ ΠIn (∅) = T∞ Π′In (∅):\n• T∞ ΠIn (∅) ⊆ T∞ Π′In (∅). Note that ⊥ /∈ T∞ ΠIn (∅) since T∞ ΠIn (∅) is an answer set.\nSuppose x ∈ T 1 ΠIn (∅), then ∃x ← B ∈ Πn s.t. var(B) = ∅ and I |= B. Clearly, we have x ← B ∈ Π′n. It follows that x ←∈ Π ′I n and then x ∈ T∞ Π′In (∅). Let k > 1 and assume for all i < k, T i ΠIn (∅) ⊆ T∞ Π′In (∅). Suppose x ∈ T k ΠIn (∅) but x /∈ T k−1 ΠIn\n(∅). Then ∃x ← B ∈ Πn s.t. x ← var(B) ∈ ΠIn and T k−1\nΠIn (∅) |= var(B). Observe that either x← B ∈ Π′n or x← B ′ ∈ Π′n.\nThe former implies that x ← var(B) ∈ Π′In , clearly, T ∞ Π′In (∅) |= var(B) by induction hypothesis, and thus x ∈ T∞ Π′In (∅). The latter implies that x ←∈ Π′In , trivially, x ∈ T ∞ Π′In (∅). Therefore, T∞ ΠIn (∅) ⊆ T∞ Π′In (∅).\n• T∞ Π′In (∅) ⊆ T∞ ΠIn (∅). We first show ⊥ /∈ T∞ Π′In (∅). Assume ⊥ ∈ T∞ Π′In (∅), then\n∃⊥ ← B1 ∈ Π ′ n s.t. I |= B1 \\ var(B1). Consider its source ⊥ ← B in Πn. Recall that Πn has no singleton loops and B is consistent since Πn is standard. Furthermore, B ∪ {⊥} is inconsistent, then ⊥ ← B ∈ F+(Πn) by Lemma 4.4 (ii). So var(B1) = ∅, I |= B1 and thus I |= B. The latter means that I is not closed under ⊥ ← B ∈ Πn, which contradicts the fact that I is an answer set of Πn. So ⊥ /∈ T∞Π′In (∅). Now suppose x ∈ T 1 Π′In (∅), then ∃x ← B1 ∈ Π′n s.t. x ←∈ Π ′I n and I |= B1. Consider the source of x← B1:\n(i) x ← B1 ∈ Πn, var(B1) = ∅. Since I |= B1, x ←∈ ΠIn, we have x ∈ T∞\nΠIn (∅).\n(ii) x← B ∈ F+(Πn), var(B) 6= ∅ and B1 = B′. Note that I |= B since I |= B1. Furthermore, I is closed under x ← B since I is an answer set of Πn. So x ∈ I , i.e, x ∈ T∞ΠIn (∅).\nSuppose x ∈ T k Π′In (∅) but x /∈ T k−1 Π′In (∅) for some k > 1. It means that ∃x← B1 ∈ Π ′ n s.t. var(B1) 6= ∅, x← var(B1) ∈ Π ′I n , I |= B1 \\ var(B1) and T k−1 Π′In (∅) |= var(B1). Note that var(B1) 6= ∅ implies that x ← B1 ∈ F−(Πn), B1 ∪ {x} does not fully cover var(Πn). By Lemma 4.4 (i), we have not not x ∈ B1. Recall that I |= B1 \\ var(B1), so I |= not not x, i.e., x ∈ T∞\nΠIn (∅). Therefore, T∞ Π′In (∅) ⊆ T∞ ΠIn (∅).\n(⇐) Suppose I is an answer set of Π′n, i.e., I = T ∞ Π′In (∅), we shall show\nT∞ Π′In (∅) = T∞ ΠIn (∅):\n• T∞ Π′In (∅) ⊆ T∞ ΠIn (∅). Note that ⊥ /∈ T∞ Π′In (∅). Suppose x ∈ T 1 Π′In (∅), then\n∃x ← B1 ∈ Π ′ n s.t. var(B1) = ∅, x ←∈ Π ′I n and I |= B1. Now consider the source of x← B1:\n(i) x← B1 ∈ Πn. So x←∈ ΠIn and clearly x ∈ T ∞ ΠIn (∅).\n(ii) x← B ∈ F+(Πn), var(B) 6= ∅ and B1 = B. Note that I |= B1∪{x} since x ∈ I and I |= B1, it follows that I |= B∪{x}. Clearly, B∪{x} is consistent and fully covers var(Πn). By Lemma 4.3, I is exactly the unique odd string in S(B ∪ {x}). Recall that Πn is a PARITYn program, so I must be an answer set of Πn, i.e., I = T∞ΠIn (∅). Therefore\nx ∈ T∞ ΠIn (∅).\nLet k > 1 and assume for all i < k, T i Π′In (∅) ⊆ T∞ ΠIn (∅). Suppose x ∈ T k Π′In (∅) but x /∈ T k−1 Π′In (∅). Then ∃x ← B1 ∈ Π′n s.t. var(B1) 6= ∅, x ← var(B1) ∈ Π ′I n , I |= B1 \\ var(B1) and T\nk−1 Π′In (∅) |= var(B1). Note that\nvar(B1) 6= ∅ implies x ← B1 ∈ F−(Πn). Moreover, x ← var(B1) ∈ ΠIn. By inductive hypothesis, T\n∞ ΠIn (∅) |= var(B1), therefore x ∈ T∞ΠIn (∅).\nConsequently, T∞ Π′In (∅) ⊆ T∞ ΠIn (∅).\n• T∞ ΠIn (∅) ⊆ T∞ Π′In (∅). We first show x ∈ T∞ ΠIn (∅) implies x ∈ T∞ Π′In (∅). Suppose\nx ∈ T 1 ΠIn (∅), then ∃x ← B ∈ Πn, var(B) = ∅ and I |= B. It follows that x ← B ∈ Π′n and x ←∈ Π ′I n . Clearly, x ∈ T\n∞ Π′In (∅). Let k > 1 and assume\nfor all i < k, x ∈ T i ΠIn (∅) implies x ∈ T∞ Π′In (∅). Suppose x ∈ T k ΠIn (∅) but x /∈ T k−1 ΠIn (∅). Then ∃x ← B ∈ Πn s.t. x ← var(B) ∈ ΠIn, var(B) 6= ∅, I |= B \\ var(B) and T k−1 ΠIn (∅) |= var(B). By induction hypothesis, T∞ Π′In (∅) |= var(B), i.e., I |= var(B). Now I |= B since I |= B \\ var(B) and I |= var(B), hence I |= B′. Observe that either x ← B′ ∈ Π′n or\nx ← B ∈ Π′n, in both cases I |= x since I is an answer set of Π ′ n and must be closed under every rule of Π′n.Consequently, x ∈ T ∞ ΠIn (∅) implies x ∈ T∞ Π′In (∅). It remains to show ⊥ /∈ T∞ ΠIn (∅). Assume ⊥ ∈ T∞ ΠIn (∅), then ∃⊥ ← B in F+(Πn) s.t. I |= B \\ var(B) and T kΠIn (∅) |= var(B) for some k ≥ 1. Notice that the latter means I |= var(B), since variables T k ΠIn (∅) |= var(B) implies T∞ Π′In (∅) |= var(B) by the previous result and I = T∞ Π′In (∅). So I |= B, i.e., I |= B′. However, note that ⊥ ← B′ in Π′n and I is not closed under ⊥ ← B′. This contradicts the fact that I is an answer set of Π′n. Therefore ⊥ /∈ T\n∞ ΠIn (∅), and hence T∞ ΠIn (∅) ⊆ T∞ Π′In (∅).\n4.3.2 Pure PARITYn Programs\nLet Πn be an almost pure PARITYn program. If for every rule H ← B ∈ Πn we have var(B) = ∅, then Πn is called pure. Clearly, a pure program has no loops and is hence completion-equivalent.\nProposition 4.4. Let Πn be an almost pure PARITYn program. Then there is a pure PARITYn program Π′n s.t. |Π ′ n| ≤ |Πn|.\nProof. A rule H ← B is non-pure if var(B) 6= ∅. We show by induction on the number m of non-pure rules in Πn. Base step m = 0, the claim trivially holds. Let m > 0 and assume the claim holds for all almost pure PARITYn programs containing j < m non-pure rules. Suppose Πn is an almost pure PARITYn program with m non-pure rules, and let H ← B be a non-pure rule in Πn. Note that H ← B must be in F−(Πn) and H is a variable x, since Πn is almost pure. Let B′ be obtained from B by replacing each variable x ∈ var(B) with not not x. Note that I |= B iff I |= B′ for any set of variables I . Let Π be Πn \\ {H ← B} and let Π′′n = Π∪{H ← B ′}. Clearly, Π′′n is almost pure and |Π ′′ n| ≤ |Πn|. We shall show that Π′′n is also a PARITYn program, i.e., I = T ∞ ΠIn (∅) iff I = T∞ Π′′In (∅).\n(⇒) Suppose I = T∞ ΠIn (∅), we prove T∞ ΠIn (∅) = T∞ Π′′In (∅):\n• T∞ ΠIn (∅) ⊆ T∞ Π′′In (∅). Note that ⊥ /∈ T∞ ΠIn (∅) since T∞ ΠIn (∅) is an answer set.\nSuppose x ∈ T 1 ΠIn (∅), then ∃x ← B1 ∈ Πn s.t. var(B1) = ∅ and I |= B1. Clearly, x ← B1 ∈ Π′′n and x ←∈ Π ′′I n , thus x ∈ T\n∞ Π′′In (∅). Let k > 1\nand assume for all i < k, T i ΠIn (∅) ⊆ T∞ Π′′In (∅). Suppose x ∈ T k ΠIn (∅) but x /∈ T k−1 ΠIn\n(∅). Then ∃x ← B1 ∈ Πn s.t. var(B1) 6= ∅, x ← var(B1) ∈ ΠIn and T k−1\nΠIn (∅) |= var(B1). Hence if x = H,B1 = B then x ← B′ ∈ Π′′n,\notherwise x ← B1 ∈ Π′′n. The former implies x ←∈ Π ′′I n since var(B ′) = ∅, and I |= B′ due to I |= B1, trivially, x ∈ T∞Π′′In (∅). The latter implies x← var(B1) ∈ Π ′′I n , clearly, T\n∞ Π′′In (∅) |= var(B1) by induction hypothesis,\nand thus x ∈ T∞ Π′′In (∅). Therefore, T∞ ΠIn (∅) ⊆ T∞ Π′′In (∅).\n• T∞ Π′′In (∅) ⊆ T∞ ΠIn (∅). We first show that ⊥ /∈ T∞ Π′′In (∅). Assume ⊥ ∈ T∞ Π′′In (∅).\nSo ∃⊥ ← B1 ∈ Π′′n s.t. ⊥ ← var(B1) ∈ Π ′′I n and I |= B1 \\ var(B1). Note that ⊥ ← B1 must be in F+(Πn) since Πn is almost pure. Hence var(B1) = ∅, I |= B1 thus I |= B. The latter means that I is not closed under ⊥ ← B1 ∈ Πn, which contradicts the fact that I is an answer set of Πn. So ⊥ /∈ T∞Π′′In (∅). Suppose x ∈ T 1 Π′′In (∅), then ∃x ← B1 ∈ Π′′n s.t. x←∈ Π′′In and I |= B1. There are two cases about the source of x← B1: (i) x← B1 ∈ Πn, var(B1) = ∅. Since I |= B1, so x←∈ ΠIn, x ∈ T ∞ ΠIn (∅). (ii)x ← B1 is obtained from H ← B ∈ F−(Πn), i.e., H = x, var(B) 6= ∅ and B1 = B′. Note that I |= B since I |= B1. Recall that not not x ∈ B, so x ∈ I , i.e, x ∈ T∞\nΠIn (∅).\nNow suppose x ∈ T k Π′′In (∅) but x /∈ T k−1 Π′′In (∅) for some k > 1. It means that ∃x← B1 ∈ Π ′′ n s.t. var(B1) 6= ∅, x← var(B1) ∈ Π ′′I n , I |= B1 \\ var(B1) and T k−1 Π′′In (∅) |= var(B1). Since Πn is almost pure, var(B1) 6= ∅ implies that x ← B1 ∈ F−(Πn). By Lemma 4.4 (i), not not x ∈ B1. Recall that I |= B1 \\ var(B1), so I |= not not x, i.e., x ∈ T∞ΠIn (∅). Therefore, T∞ Π′′In (∅) ⊆ T∞ ΠIn (∅).\n(⇐) Suppose I = T∞ Π′′In (∅), we show T∞ Π′′In (∅) = T∞ ΠIn (∅).\n• T∞ Π′′In (∅) ⊆ T∞ ΠIn (∅). Note that ⊥ /∈ T∞ Π′′In (∅). Suppose x ∈ T 1 Π′′In (∅), then\n∃x ← B1 ∈ Π ′′ n s.t. x ←∈ Π ′′I n and I |= B1. Now consider the source of x← B1:\n(i) x ← B1 ∈ Πn and var(B1) = ∅. It follows that x ←∈ ΠIn and clearly x ∈ T∞\nΠIn (∅).\n(ii) x← B1 is obtained from H ← B ∈ F−(Πn), i.e.,H = x and B1 = B′. So x ← var(B) ∈ ΠIn and I |= B. The latter implies T\n∞ Π′′In (∅) |= B thus\nT∞ Π′′In (∅) |= var(B). Note that Π′′In = Π I ∪ {x ←}, and x /∈ var(B) since Πn is almost pure, it has no singleton loops. We prove by induction that T∞\nΠI (∅) |= var(B). Suppose x′ ∈ var(B) and x′ ∈ T 1 Π′′In (∅), then\n∃x′ ← B2 ∈ Π ′′, var(B2) = ∅ and I |= B2. Clearly, x′ ←∈ ΠI , thus x′ ∈ T∞ ΠI\n(∅). Let s > 1 and assume for all t < s, x′ ∈ var(B) and x′ ∈ T t Π′′In (∅) implies x′ ∈ T∞ ΠIn (∅). Suppose x′ ∈ var(B) and x′ ∈ T s Π′′In (∅). Then ∃x′ ← B2 ∈ Π′′, x′ ← var(B2) ∈ Π′′I and T s−1 Π′′In (∅) |= var(B2). Recall that x 6= x′ since x /∈ var(B), so x′ ← var(B2) ∈ ΠI . By induction hypothesis, T∞\nΠIn (∅) |= var(B2), x′ ∈ T∞ΠIn (∅). Hence T∞ ΠI (∅) |= var(B).\nFurthermore, ΠIn = Π I ∪ {x ← var(B)}, so T∞ ΠI (∅) ⊆ T∞ ΠIn (∅), T∞ ΠIn (∅) |= var(B). Therefore T∞ ΠIn (∅) |= x, i.e., x ∈ T∞ ΠIn (∅).\nLet k > 1 and assume for all i < k, T i Π′′In (∅) ⊆ T∞ ΠIn (∅). Suppose x ∈ T k Π′′In (∅), then ∃x ← B1 ∈ Π′′n, var(B1) 6= ∅, x ← var(B1) ∈ Π ′′I n , T k−1 Π′′In (∅) |= var(B1). Clearly, x ← var(B1) ∈ ΠI . It follows that x ← var(B1) ∈ Π I n since Π\nI ⊆ ΠIn. By induction hypothesis, T ∞ ΠIn (∅) |= var(B1).\nHence T∞ ΠIn (∅) |= x, i.e., x ∈ T∞ ΠIn (∅). Therefore, T∞ Π′′In (∅) ⊆ T∞ ΠIn (∅).\n• T∞ ΠIn (∅) ⊆ T∞ Π′′In (∅). We first show for any variable x, x ∈ T∞ ΠIn (∅) implies\nx ∈ T∞ Π′′In (∅). Suppose x ∈ T 1 ΠIn (∅), then ∃x← B1 ∈ Πn, var(B1) = ∅ and I |= B1. It follows that x ← B1 ∈ Π′′n and x ←∈ Π ′′I n . So x ∈ T\n∞ Π′′In (∅).\nLet k > 1 and assume for all i < k, x ∈ T i ΠIn (∅) implies x ∈ T∞ Π′′In (∅). Suppose x ∈ T k ΠIn (∅), then ∃x ← B1 ∈ Πn s.t. x ← var(B1) ∈ ΠIn, var(B1) 6= ∅, I |= B1 \\ var(B1) and T k−1 ΠIn (∅) |= var(B1). By induction hypothesis, T∞ Π′′In (∅) |= var(B1), i.e., I |= var(B1). Now I |= B1 since I |= B1 \\ var(B1) and I |= var(B1), hence I |= B1. Observe that if H = x and B1 = B then x ← B′ ∈ Π′′n, otherwise x ← B1 ∈ Π ′′ n. In both cases I |= x since I is an answer set of Π′′n and it must be closed under every rule of Π′′n. Consequently, x ∈ T\n∞ ΠIn (∅) implies x ∈ T∞ Π′′In (∅).\nIt remains to show ⊥ /∈ T∞ ΠIn (∅). Assume ⊥ ∈ T∞ ΠIn (∅), then ∃⊥ ← B1 in F+(Πn) s.t. ⊥ ←∈ ΠIn and I |= B1. Notice that var(B1) = ∅ since Πn is almost pure. Furthermore, ⊥ ← B1 must be in Π′′n, therefore I |= ⊥ since I |= B1.However, this contradicts the fact that I is an answer set of Π′′n. Therefore ⊥ /∈ T∞\nΠIn (∅), and hence T∞ ΠIn (∅) ⊆ T∞ Π′′In (∅).\nConsequently, Π′′n is an almost pure PARITYn program with m − 1 non-pure rules. By induction hypothesis, there is a pure PARITYn program Π′n with |Π ′ n| ≤ |Π′′n| ≤ |Πn|."
    }, {
      "heading" : "4.4 The Main Results",
      "text" : "The main lemma below easily follows from Proposition 4.1 and 4.2.\nLemma 4.5 (Main Lemma). Let Πn be a PARITYn program. Then there is a PARITYn program Π′n s.t. Π ′ n is equivalent to Comp(Π ′ n) and |Π ′ n| ≤ |Πn|.\nTheorem 4.1 (PARITY/∈Poly-CP). PARITY has no polynomial size CP programs.\nProof. Assume the contrary that there is a sequence of programs {Πn} in CP which represents PARITY, and |Πn| is bounded by a polynomial p(n). By Lemma 4.5, there is a sequence of completion-equivalent PARITY programs {Π′n} in which |Π′n| is also bounded by the polynomial p(n). By Proposition 3.1, {Π ′ n} represents a language in AC0. This contradicts PARITY/∈ AC0.\nCorollary 4.1. PARITY separates PF from CP.\nCorollary 4.2. Suppose P * NC1/poly. Then CP and PF are succinctly incomparable."
    }, {
      "heading" : "5 Discussion and Some More Results",
      "text" : "Interestingly, our main result may at first appear counter-intuitive: the P-complete problem PATH has Poly-CP representations, while this does not hold for an “easy” problem PARITY. Actually, there is no contradiction. As noted in [1, 8], a complete problem in a complexity class can be represented in a formalism C, does not imply that all problems in that class can be represented in C.\nGenerally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same. In terms of the theory of computation, succinctness essentially concerns with the computational power of different formalisms (i.e., models of computation). This is particularly interesting if the formalisms are equally expressive and share the same reasoning complexity. E.g., logic programs with cardinality constraints and choice rules (CC, without classic negation ¬) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking. But they have a non-trivial succinctness picture, see Fig. 2.\nBesides the theoretical interests, succinctness also tells us something like “which for what is the best” in choosing KR formalisms for a given application. E.g., one should choose ASP instead of SAT if the application involves reasoning about PATH or Transitive Closure5, because the former provides compact representations to avoid unnecessary overload. Recall that from the complexity viewpoint, even one extra variable may double the search space for intractable problems.\nIn the following we shall briefly discuss some succinctness results illustrated\n5An NL-complete problem. It is believed that NL * NC1/Poly.\nin Fig. 2, note that all mentioned formalisms have the same expressive power and same reasoning complexity."
    }, {
      "heading" : "5.1 Logic Programs with Cardinality Constraints (CC)",
      "text" : "Simply speaking, CC extends normal programs (LP) with so-called cardinality constraints and choice rules [32]. A choice rule\n{x} ← (8)\nhas two answer sets {x} and ∅, i.e., same as x ← not not x. Moreover, a choice rule {x1, . . . , xn} ← produces 2n answer sets, i.e., all subsets of {x1, . . . , xn}. A cardinality constraint is an expression of the form\nl ≤ B ≤ u (9)\nin whichB is a finite set of rule elements of the form x or not x, and integer l (resp. u) is the lower (resp. upper) bound on B. In this paper we assume the magnitude of l (and u) is polynomially bounded by n.\nIntuitively, a set of variables I satisfies (9), if the number of satisfied rule elements in B fulfills the related bounds. E.g., {x1} satisfies 1 ≤ {x1, x2, x3} ≤ 1 but not 2 ≤ {x1, x2, x3} ≤ 3, while {x2, x3} satisfies the latter. Informally, we may think of (9) as a special kind of rule element, and the answer set semantics is defined accordingly.\nThe following is a PARITY3 program in CC:\n{x1, x2, x3} ←, ⊥ ← 0 ≤ {x1, x2, x3} ≤ 0, ⊥ ← 2 ≤ {x1, x2, x3} ≤ 2,\n(10)\nClearly, the pattern applies to all PARITYn and the program grows linearly. We define the size of a CC program to be the number of cardinality constraints occur in it.\nTheorem 5.1 (PARITY∈Poly-CC). PARITY has polynomial size programs in CC.\nAn equivalent translation from CC to NLP was presented in [12], however, the translation may involve exponential size blowup, since every cardinality constraint is simply converted to a formula via a brute force enumeration. In fact, such a translation can be reduced to be polynomial by adopting a non-trivial, sophisticated encoding for so-called threshold functions6 . Therefore, we have:\nTheorem 5.2. NLP is at least as succinct as CC. 6E.g., see Chapter 2 of [31]."
    }, {
      "heading" : "5.2 Definite Causal Theories (DT)",
      "text" : "A variable x or negated variable ¬x is called a literal. A definite (causal) theory Dn on signature {x1, . . . , xn} is a finite set of (causal) rules of the form\nH ⇐ G (11)\nin which H is either a literal or ⊥, and G is a propositional formula. If every G is a conjunction of variables or negated variables, then Dn is called simple (SDT)7.\nThe reduct DIn of Dn w.r.t. a set of variables I , is the set of the heads H of all rules in Dn whose bodies G are satisfied by I . Say I is a model of Dn if I is the unique model of DIn. The following theory:\nx⇐ x, ¬x⇐ ¬x (12)\nhas two models {x} and ∅, which is equivalent to program x ← not not x or {x} ←.\nIf a definite theory Dn is simple, then its size |Dn| is defined as the number of rules in it, otherwise |Dn| is the number of connectives in it. It is well-known that Dn is equivalent to its (literal) completion Comp(Dn), in which Comp(Dn) is similarly defined as for logic programs [30, 16]. It means that definite theories are fragments of PF, i.e., DT PF. Therefore, the problems that can be represented by Poly-DT are in NC1/poly as well. Moreover, the completion of a simple definite theory is also a constant depth, unbounded fan-in circuit whose size is polynomially bounded. By a proof similar to that of Theorem 4.1, we have the following theorem:\nTheorem 5.3 (PARITY/∈Poly-SDT). PARITY has no polynomial size theories in SDT.\nConsider the (non-simple) causal theory (13) for PARITY2, where the body of the last rule is the negation of a PARITY2 formula:\nx1 ⇐ x1, ¬x1 ⇐ ¬x1, x2 ⇐ x2, ¬x2 ⇐ ¬x2, ⊥ ⇐ ¬((x1 ∧ ¬x2) ∨ (¬x2 ∧ x1)).\n(13)\nRecall that PARITY have polynomial formulas in PF, therefore it is not hard to see we can have polynomial DT theory for PARITY by the above pattern.\nTheorem 5.4 (PARITY∈Poly-DT). PARITY has polynomial size theories in DT.\nSince PATH is P-complete [28], therefore if PATH has polynomial representations in Poly-DT, then P ⊆ NC1/poly, which is believed impossible.\nTheorem 5.5 (PATH/∈Poly-DT). Suppose P * NC1/poly. Then PATH has no polynomial size definite theories.\n7SDT is originally named as Objective Programs in [30].\nBy the fact that PATH has polynomial size CP programs, we have:\nCorollary 5.1. Suppose P * NC1/poly. Then CP and DT are succinctly incomparable.\nIt is worth to point out that some difficulties observed in the literature could be nicely explained by the above succinctness results. E.g., DT has been observed hard to concisely encode Transitive Closure (TC) [16, 9]. Recall that Poly-DT represents problems in NC1/Poly, and TC is a problem in NC2/poly [18], a class widely believed strictly contains NC1/poly. So unless the two classes coincide, TC has no polynomial size definite theories."
    }, {
      "heading" : "5.3 Two-Valued Logic Programs (TV)",
      "text" : "A (two-valued) program [27] Πn on signature {x1, . . . , xn} is a finite set of (twovalued) rules of the form:\nH ← B : G (14)\nin which B ∪ {H} is a finite set of literals and G is a formula. The reduct ΠIn of Πn w.r.t. a set of variables I , is the set of rules\nH ← B (15)\nfrom Πn s.t. I satisfies G. A set of literals J is closed under rule (15) if H ∈ J whenever B ⊆ J . We say I is a model of Πn if I is the unique model of the minimal closure J under every rule of ΠIn. The following program Π2 in TV\nx←: x, ¬x←: ¬x (16)\nhas two models {x} and ∅, which is equivalent to (12). The following observations were pointed out in [27]. A formula φn can be rewritten in TV (i ∈ {1, . . . , n})8:\nxi ←: xi, ¬xi ←: ¬xi, ⊥ ←: ¬φn. (17)\nA causal rule H ⇐ G can be equivalently rewritten as H ←: G. Moreover, to equivalently rewrite a CP program Πn, each rule:\nH ← u1, . . . , uj , not yj+1, . . . , not ym, not not zm+1, . . . , not not zk\n(18)\ncan be translated as:\nH ← u1, . . . , uj : ¬yj+1∧, . . .¬ym ∧ zm+1 ∧ . . . zk (19)\nand add ¬x←: ¬x for every x ∈ var(Πn). All together, we have:\nTheorem 5.6. Two valued programs are strictly more succinct than: (i) propositional formulas and definite theories, if P * NC1/poly; (ii) canonical programs.\n8 ⊥ ←: ¬φn is a shorthand of x1 ←: ¬φn, ¬x1 ←: ¬φn."
    }, {
      "heading" : "6 Conclusions",
      "text" : "The main result of the paper is that the PARITY problem separates PF from CP, i.e., PARITY has no polynomial size CP programs, but has polynomial size PF formulas. Together with Lifschitz and Razborov’s separation result, i.e., there exists a problem separates CP from PF (assuming P * NC1/poly), we conclude that the two well-known KR formalisms are succinctly incomparable. In other words, if we consider CP and PF as two different models of computation, the above result just states that they are incomparable in terms of computational power. We also give a non-trivial succinctness picture on a family of logic program classes which posses the same expressive power and same reasoning complexity as PF.\nIn future work, we plan to investigate some missing connections in Fig. 2, e.g., we conjecture that there is a problem separates NLP from CP, SDT and CP are succinctly incomparable."
    }, {
      "heading" : "Acknowledgement",
      "text" : "We are grateful to the anonymous reviewers for their valuable comments. Thanks to Shiguang Feng, Yan Zhang, Jiankun He, Guangrui Dang and Xiaolong Liang for their helpful discussions. The research was partially supported by NSFC Grant 61272059, MOE Grant 11JJD720020, NSSFC Grant 13&ZD186, 14CZX058 and the Fundamental Research Funds for the Central Universities Grant 1409025."
    } ],
    "references" : [ {
      "title" : "Towards a theory of declarative knowledge",
      "author" : [ "K.R. Apt", "H.A. Blair", "A. Walker" ],
      "venue" : "Foundations of Deductive Databases and Logic Programming,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 1988
    }, {
      "title" : "Computational Complexity: A Modern Approach",
      "author" : [ "Sanjeev Arora", "Boaz Barak" ],
      "venue" : null,
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2009
    }, {
      "title" : "Handbook of Satisfiability, volume 185 of Frontiers in Artificial Intelligence and Applications",
      "author" : [ "Armin Biere", "Marijn Heule", "Hans van Maaren", "Toby Walsh", "editors" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2009
    }, {
      "title" : "Answer set programming at a glance",
      "author" : [ "Gerhard Brewka", "Thomas Eiter", "Miroslaw Truszczynski" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Negation as failure",
      "author" : [ "Keith L. Clark" ],
      "venue" : "Logic and Data Bases,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1978
    }, {
      "title" : "Expressive power and succinctness of propositional languages for preference representation",
      "author" : [ "Sylvie Coste-Marquis", "Jérôme Lang", "Paolo Liberatore", "Pierre Marquis" ],
      "venue" : "In Proceedings of the Ninth International Conference on Principles of Knowledge Representation and Reasoning,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2004
    }, {
      "title" : "Complexity and expressive power of logic programming",
      "author" : [ "Evgeny Dantsin", "Thomas Eiter", "Georg Gottlob", "Andrei Voronkov" ],
      "venue" : "ACM Computing Surveys,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2001
    }, {
      "title" : "Almost definite causal theories",
      "author" : [ "Semra Doğandağ", "Paolo Ferraris", "Vladimir Lifschitz" ],
      "venue" : "Logic Programming and Nonmonotonic Reasoning,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2004
    }, {
      "title" : "Tight logic programs",
      "author" : [ "Esra Erdem", "Vladimir Lifschitz" ],
      "venue" : "Theory and Practice of Logic Programming,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2003
    }, {
      "title" : "Consistency of clark’s completion and existence of stable models",
      "author" : [ "François Fages" ],
      "venue" : "Journal of Methods of Logic in Computer Science,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 1994
    }, {
      "title" : "Weight constraints as nested expressions",
      "author" : [ "Paolo Ferraris", "Vladimir Lifschitz" ],
      "venue" : "Theory Pract. Log. Program.,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2005
    }, {
      "title" : "On the succinctness of some modal logics",
      "author" : [ "Tim French", "Wiebe van der Hoek", "Petar Iliev", "Barteld P. Kooi" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2013
    }, {
      "title" : "Parity, circuits, and the polynomial-time hierarchy",
      "author" : [ "Merrick L. Furst", "James B. Saxe", "Michael Sipser" ],
      "venue" : "Mathematical Systems Theory,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1984
    }, {
      "title" : "The stable model semantics for logic programming",
      "author" : [ "Michael Gelfond", "Vladimir Lifschitz" ],
      "venue" : "Proceedings of International Logic Programming Conference and Symposium,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 1988
    }, {
      "title" : "Nonmonotonic causal theories",
      "author" : [ "Enrico Giunchiglia", "Joohyung Lee", "Vladimir Lifschitz", "Norman McCain", "Hudson Turner", "Joohyung Lee Vladimir Lifschitz" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2004
    }, {
      "title" : "The comparative linguistics of knowledge representation",
      "author" : [ "Goran Gogic", "Henry A. Kautz", "Christos H. Papadimitriou", "Bart Selman" ],
      "venue" : "In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1995
    }, {
      "title" : "Limits to parallel computation: P-completeness theory",
      "author" : [ "Raymond Greenlaw", "H. James Hoover", "Walter L. Ruzzo" ],
      "venue" : null,
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1995
    }, {
      "title" : "The succinctness of first-order logic on linear orders",
      "author" : [ "Martin Grohe", "Nicole Schweikardt" ],
      "venue" : "Logical Methods in Computer Science,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2005
    }, {
      "title" : "Almost optimal lower bounds for small depth circuits",
      "author" : [ "Johan Hastad" ],
      "venue" : "In Proceedings of the eighteenth annual ACM symposium on Theory of computing,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1986
    }, {
      "title" : "Boolean Function Complexity - Advances and Frontiers, volume 27 of Algorithms and combinatorics",
      "author" : [ "Stasys Jukna" ],
      "venue" : null,
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2012
    }, {
      "title" : "A model-theoretic counterpart of loop formulas",
      "author" : [ "Joohyung Lee" ],
      "venue" : "In Proceedings of the 19th international joint conference on Artificial intelligence,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2005
    }, {
      "title" : "Loop formulas for disjunctive logic programs",
      "author" : [ "Joohyung Lee", "Vladimir Lifschitz" ],
      "venue" : "Logic Programming,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2003
    }, {
      "title" : "Action language BC: Preliminary report",
      "author" : [ "Joohyung Lee", "Vladimir Lifschitz", "Fangkai Yang" ],
      "venue" : "In Proceedings of the 23rd International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2013
    }, {
      "title" : "Nested expressions in logic programs",
      "author" : [ "Vladimir Lifschitz" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1999
    }, {
      "title" : "What is answer set programming",
      "author" : [ "Vladimir Lifschitz" ],
      "venue" : "In Proceedings of the AAAI Conference on Artificial Intelligence,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2008
    }, {
      "title" : "Two-valued logic programs",
      "author" : [ "Vladimir Lifschitz" ],
      "venue" : "Technical Communications of the 28th International Conference on Logic Programming,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2012
    }, {
      "title" : "Why are there so many loop formulas",
      "author" : [ "Vladimir Lifschitz", "Alexander Razborov" ],
      "venue" : "ACM Transactions on Computational Logic,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2006
    }, {
      "title" : "ASSAT: computing answer sets of a logic program by SAT solvers",
      "author" : [ "Fangzhen Lin", "Yuting Zhao" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2004
    }, {
      "title" : "Causality in Commonsense Reasoning about Actions",
      "author" : [ "Norman McCain" ],
      "venue" : "PhD thesis, University of Texas at Austin,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 1997
    }, {
      "title" : "Models of computation",
      "author" : [ "John E Savage" ],
      "venue" : "Exploring the Power of Computing. Addison-Wesley,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 1998
    }, {
      "title" : "Extending and implementing the stable model semantics",
      "author" : [ "Patrik Simons", "Ilkka Niemelä", "Timo Soininen" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2002
    }, {
      "title" : "On the equivalence between answer sets and models of completion for nested logic programs",
      "author" : [ "Jia-Huai You", "Li-Yan Yuan", "Mingyi Zhang" ],
      "venue" : "In Proceedings of the 18th international joint conference on Artificial intelligence,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 13,
      "context" : ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.",
      "startOffset" : 31,
      "endOffset" : 42
    }, {
      "referenceID" : 24,
      "context" : ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.",
      "startOffset" : 31,
      "endOffset" : 42
    }, {
      "referenceID" : 3,
      "context" : ", answer set programming (ASP) [15, 26, 5], has been an active area in artificial intelligence since the past decades.",
      "startOffset" : 31,
      "endOffset" : 42
    }, {
      "referenceID" : 2,
      "context" : "As a competing approach to SAT [4], ASP has been successfully applied in many fields like Planning, Commonsense Reasoning, Scheduling, etc.",
      "startOffset" : 31,
      "endOffset" : 34
    }, {
      "referenceID" : 27,
      "context" : "A well-known theorem shown by Lin & Zhao [29] gives a method for translating a normal (logic) program (LP) to a (logically) equivalent set of formulas in PF, without introducing additional variables.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 26,
      "context" : "In 2006, Lifschitz and Razborov proved that such exponential blowup is generally inevitable, more precisely, they showed that (a variant of) the P-complete problem PATH has polynomial size representations in LP, however, it cannot be polynomially represented in PF (assuming P * NC/poly) [28].",
      "startOffset" : 288,
      "endOffset" : 292
    }, {
      "referenceID" : 26,
      "context" : "As noted in [28], PF can be considered as a special case of (nondisjunctive) nested programs (NLP) [25], which is a general form of programs that subsumes LP and some other kinds of programs.",
      "startOffset" : 12,
      "endOffset" : 16
    }, {
      "referenceID" : 23,
      "context" : "As noted in [28], PF can be considered as a special case of (nondisjunctive) nested programs (NLP) [25], which is a general form of programs that subsumes LP and some other kinds of programs.",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 15,
      "context" : "Therefore, NLP is stronger than PF in terms of the succinctness criterion (or the “comparative linguistics” approach) proposed in [17]:",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 24,
      "context" : "So the following footnote in [26] seems convincing at first glance:",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 20,
      "context" : "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a “minimal” form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.",
      "startOffset" : 70,
      "endOffset" : 82
    }, {
      "referenceID" : 23,
      "context" : "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a “minimal” form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.",
      "startOffset" : 70,
      "endOffset" : 82
    }, {
      "referenceID" : 22,
      "context" : "Particularly, the so-called (nondisjunctive) canonical programs (CP)1 [22, 25, 24], is a “minimal” form of ASP that is equally expressive as PF, but looks more likely not succinctly stronger.",
      "startOffset" : 70,
      "endOffset" : 82
    }, {
      "referenceID" : 1,
      "context" : ", it has polynomial representations in PF2 [3, 21], (ii) PARITY/ ∈ AC, i.",
      "startOffset" : 43,
      "endOffset" : 50
    }, {
      "referenceID" : 19,
      "context" : ", it has polynomial representations in PF2 [3, 21], (ii) PARITY/ ∈ AC, i.",
      "startOffset" : 43,
      "endOffset" : 50
    }, {
      "referenceID" : 12,
      "context" : ", it cannot be represented by polynomial size boolean circuits with constant depth and unbounded fan-in [14, 20].",
      "startOffset" : 104,
      "endOffset" : 112
    }, {
      "referenceID" : 18,
      "context" : ", it cannot be represented by polynomial size boolean circuits with constant depth and unbounded fan-in [14, 20].",
      "startOffset" : 104,
      "endOffset" : 112
    }, {
      "referenceID" : 9,
      "context" : "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), Π′ is equivalent to its completion Comp(Π′), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |Π′|.",
      "startOffset" : 44,
      "endOffset" : 56
    }, {
      "referenceID" : 8,
      "context" : "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), Π′ is equivalent to its completion Comp(Π′), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |Π′|.",
      "startOffset" : 44,
      "endOffset" : 56
    }, {
      "referenceID" : 31,
      "context" : "Theorem (or the (generalized) Fages Theorem [11, 10, 33]), Π′ is equivalent to its completion Comp(Π′), the latter is essentially a constant depth, unbounded fan-in circuit whose size is polynomially bounded by |Π′|.",
      "startOffset" : 44,
      "endOffset" : 56
    }, {
      "referenceID" : 29,
      "context" : "From the view of the theory of computation, the above result may also be considered as the separation of two models of computation [31], i.",
      "startOffset" : 131,
      "endOffset" : 135
    }, {
      "referenceID" : 30,
      "context" : ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 28,
      "context" : ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.",
      "startOffset" : 158,
      "endOffset" : 166
    }, {
      "referenceID" : 14,
      "context" : ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.",
      "startOffset" : 158,
      "endOffset" : 166
    }, {
      "referenceID" : 25,
      "context" : ", PARITY separates logic programs with cardinality constraints and choice rules (CC) [32] from CP; assuming P * NC/poly, CP and definite causal theories (DT) [30, 16] are succinctly incomparable; two-valued programs (TV) [27] are strictly more succinct than CP and DT, etc.",
      "startOffset" : 221,
      "endOffset" : 225
    }, {
      "referenceID" : 23,
      "context" : "The following notations are adopted from [25, 22].",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 20,
      "context" : "The following notations are adopted from [25, 22].",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 23,
      "context" : "According to [25], not not not x can be replaced by not x.",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 15,
      "context" : "The following concept is adopted from [17, 13].",
      "startOffset" : 38,
      "endOffset" : 46
    }, {
      "referenceID" : 11,
      "context" : "The following concept is adopted from [17, 13].",
      "startOffset" : 38,
      "endOffset" : 46
    }, {
      "referenceID" : 26,
      "context" : "However, this is impossible since it contradicts the anti-chain property of Πn [28]: if strings I, I ′ ∈ Ans(Πn) and I ⊆ I ′ then I = I ′.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 1,
      "context" : ", PARITY∈ NC/poly (or Poly-PF) [3, 21].",
      "startOffset" : 31,
      "endOffset" : 38
    }, {
      "referenceID" : 19,
      "context" : ", PARITY∈ NC/poly (or Poly-PF) [3, 21].",
      "startOffset" : 31,
      "endOffset" : 38
    }, {
      "referenceID" : 1,
      "context" : "For more details about circuits, please see [3].",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 4,
      "context" : "The completion Comp(Π) [6, 10] of a canonical program Π, consists of a set (or conjunction) of formulas4:",
      "startOffset" : 23,
      "endOffset" : 30
    }, {
      "referenceID" : 8,
      "context" : "The completion Comp(Π) [6, 10] of a canonical program Π, consists of a set (or conjunction) of formulas4:",
      "startOffset" : 23,
      "endOffset" : 30
    }, {
      "referenceID" : 27,
      "context" : "It is shown in [29, 23] that the so-called loop formulas LF (Π) nicely eliminate inappropriate models of Comp(Π), s.",
      "startOffset" : 15,
      "endOffset" : 23
    }, {
      "referenceID" : 21,
      "context" : "It is shown in [29, 23] that the so-called loop formulas LF (Π) nicely eliminate inappropriate models of Comp(Π), s.",
      "startOffset" : 15,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : "The (positive) dependency graph [2] of a canonical program Π is a pair (N,E) in which the set of nodes N = var(Π), and E contains a directed edge (x, x′) iff there is a rule H ← B in Π s.",
      "startOffset" : 32,
      "endOffset" : 35
    }, {
      "referenceID" : 27,
      "context" : "1 (Lin-Zhao Theorem[29, 23]).",
      "startOffset" : 19,
      "endOffset" : 27
    }, {
      "referenceID" : 21,
      "context" : "1 (Lin-Zhao Theorem[29, 23]).",
      "startOffset" : 19,
      "endOffset" : 27
    }, {
      "referenceID" : 9,
      "context" : "1 (or the (generalized) Fages theorem [11, 10, 33]), if Π has no loops, then LF (Π) is a tautology ⊤ and Π is equivalent to Comp(Π) (i.",
      "startOffset" : 38,
      "endOffset" : 50
    }, {
      "referenceID" : 8,
      "context" : "1 (or the (generalized) Fages theorem [11, 10, 33]), if Π has no loops, then LF (Π) is a tautology ⊤ and Π is equivalent to Comp(Π) (i.",
      "startOffset" : 38,
      "endOffset" : 50
    }, {
      "referenceID" : 31,
      "context" : "1 (or the (generalized) Fages theorem [11, 10, 33]), if Π has no loops, then LF (Π) is a tautology ⊤ and Π is equivalent to Comp(Π) (i.",
      "startOffset" : 38,
      "endOffset" : 50
    }, {
      "referenceID" : 0,
      "context" : "Let Π be a basic program and I be a set of variables, define the Knaster-Tarski operator [2] as TΠ(I) = {H : H ← B ∈ Π and I |= B}.",
      "startOffset" : 89,
      "endOffset" : 92
    }, {
      "referenceID" : 13,
      "context" : "It is pointed out in [15, 33] that I ∈ Ans(Π) iff I = T∞ Π (∅) for a canonical program Π.",
      "startOffset" : 21,
      "endOffset" : 29
    }, {
      "referenceID" : 31,
      "context" : "It is pointed out in [15, 33] that I ∈ Ans(Π) iff I = T∞ Π (∅) for a canonical program Π.",
      "startOffset" : 21,
      "endOffset" : 29
    }, {
      "referenceID" : 6,
      "context" : "As noted in [1, 8], a complete problem in a complexity class can be represented in a formalism C, does not imply that all problems in that class can be represented in C.",
      "startOffset" : 12,
      "endOffset" : 18
    }, {
      "referenceID" : 15,
      "context" : "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.",
      "startOffset" : 49,
      "endOffset" : 64
    }, {
      "referenceID" : 5,
      "context" : "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.",
      "startOffset" : 49,
      "endOffset" : 64
    }, {
      "referenceID" : 17,
      "context" : "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.",
      "startOffset" : 49,
      "endOffset" : 64
    }, {
      "referenceID" : 11,
      "context" : "Generally speaking, the research of succinctness [17, 7, 19, 13] gives us a deeper understanding about KR formalisms, for it reveals their (in)abilities of concisely representing different problems under the condition that the encoded models are the same.",
      "startOffset" : 49,
      "endOffset" : 64
    }, {
      "referenceID" : 30,
      "context" : ", logic programs with cardinality constraints and choice rules (CC, without classic negation ¬) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 14,
      "context" : ", logic programs with cardinality constraints and choice rules (CC, without classic negation ¬) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 25,
      "context" : ", logic programs with cardinality constraints and choice rules (CC, without classic negation ¬) [32], (simple) definite causal theories (S/DT) [16] and two-valued programs (TV) [27] are as expressive as PF and NP-complete for consistency checking.",
      "startOffset" : 177,
      "endOffset" : 181
    }, {
      "referenceID" : 30,
      "context" : "Simply speaking, CC extends normal programs (LP) with so-called cardinality constraints and choice rules [32].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 10,
      "context" : "An equivalent translation from CC to NLP was presented in [12], however, the translation may involve exponential size blowup, since every cardinality constraint is simply converted to a formula via a brute force enumeration.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 29,
      "context" : ", see Chapter 2 of [31].",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 28,
      "context" : "It is well-known that Dn is equivalent to its (literal) completion Comp(Dn), in which Comp(Dn) is similarly defined as for logic programs [30, 16].",
      "startOffset" : 138,
      "endOffset" : 146
    }, {
      "referenceID" : 14,
      "context" : "It is well-known that Dn is equivalent to its (literal) completion Comp(Dn), in which Comp(Dn) is similarly defined as for logic programs [30, 16].",
      "startOffset" : 138,
      "endOffset" : 146
    }, {
      "referenceID" : 26,
      "context" : "Since PATH is P-complete [28], therefore if PATH has polynomial representations in Poly-DT, then P ⊆ NC/poly, which is believed impossible.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 28,
      "context" : "SDT is originally named as Objective Programs in [30].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 14,
      "context" : ", DT has been observed hard to concisely encode Transitive Closure (TC) [16, 9].",
      "startOffset" : 72,
      "endOffset" : 79
    }, {
      "referenceID" : 7,
      "context" : ", DT has been observed hard to concisely encode Transitive Closure (TC) [16, 9].",
      "startOffset" : 72,
      "endOffset" : 79
    }, {
      "referenceID" : 16,
      "context" : "Recall that Poly-DT represents problems in NC/Poly, and TC is a problem in NC/poly [18], a class widely believed strictly contains NC/poly.",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 25,
      "context" : "3 Two-Valued Logic Programs (TV) A (two-valued) program [27] Πn on signature {x1, .",
      "startOffset" : 56,
      "endOffset" : 60
    }, {
      "referenceID" : 25,
      "context" : "The following observations were pointed out in [27].",
      "startOffset" : 47,
      "endOffset" : 51
    } ],
    "year" : 2015,
    "abstractText" : "Canonical (logic) programs (CP) refer to normal logic programs augmented with connective not not. In this paper we address the question of whether CP are succinctly incomparable with propositional formulas (PF). Our main result shows that the PARITY problem, which can be polynomially represented in PF but only has exponential representations in CP. In other words, PARITY separates PF from CP. Simply speaking, this means that exponential size blowup is generally inevitable when translating a set of formulas in PF into an equivalent program in CP (without introducing new variables). Furthermore, since it has been shown by Lifschitz and Razborov that there is also a problem that separates CP from PF (assuming P * NC/poly), it follows that CP and PF are indeed succinctly incomparable. From the view of the theory of computation, the above result may also be considered as the separation of two models of computation, i.e., we identify a language in NC/poly which is not in the set of languages computable by polynomial size CP programs.",
    "creator" : "LaTeX with hyperref package"
  }
}