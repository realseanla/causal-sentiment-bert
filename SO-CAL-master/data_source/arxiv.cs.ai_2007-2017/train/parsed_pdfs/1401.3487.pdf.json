{
  "name" : "1401.3487.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "The DL-Lite Family and Relations",
    "authors" : [ "Alessandro Artale", "Diego Calvanese", "Roman Kontchakov", "Michael Zakharyaschev" ],
    "emails" : [ "artale@inf.unibz.it", "calvanese@inf.unibz.it", "roman@dcs.bbk.ac.uk", "michael@dcs.bbk.ac.uk" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "Description Logic (cf. Baader, Calvanese, McGuinness, Nardi, & Patel-Schneider, 2003 and references therein) is a family of knowledge representation formalisms developed over the past three decades and, in recent years, widely used in various application areas such as:\n• conceptual modeling (Bergamaschi & Sartori, 1992; Calvanese et al., 1998b, 1999; McGuinness & Wright, 1998; Franconi & Ng, 2000; Borgida & Brachman, 2003; Berardi, Calvanese, & De Giacomo, 2005; Artale et al., 1996, 2007, 2007b),\n• information and data integration (Beeri, Levy, & Rousset, 1997; Levy & Rousset, 1998; Goasdoue, Lattes, & Rousset, 2000; Calvanese et al., 1998a, 2002a, 2002b, 2008; Noy, 2004; Meyer, Lee, & Booth, 2005),\n• ontology-based data access (Dolby et al., 2008; Poggi et al., 2008a; Heymans et al., 2008),\n• the Semantic Web (Heflin & Hendler, 2001; Horrocks, Patel-Schneider, & van Harmelen, 2003).\nc©2009 AI Access Foundation. All rights reserved.\nDescription logics (DLs, for short) underlie the standard Web Ontology Language OWL,1 which is now in the process of being standardized by the W3C in its second edition, OWL 2. The widespread use of DLs as flexible modeling languages stems from the fact that, similarly to more traditional modeling formalisms, they structure the domain of interest into classes (or concepts, in the DL parlance) of objects with common properties. Properties are associated with objects by means of binary relationships (or roles) to other objects. Constraints available in standard DLs also resemble those used in conceptual modeling formalisms for structuring information: is-a hierarchies (i.e., inclusions) and disjointness for concepts and roles, domain and range constraints for roles, mandatory participation in roles, functionality and more general numeric restrictions for roles, covering within concept hierarchies, etc. In a DL knowledge base (KB), these constraints are combined to form a TBox asserting intensional knowledge, while an ABox collects extensional knowledge about individual objects, such as whether an object is an instance of a concept, or two objects are connected by a role. The standard reasoning services over a DL KB include checking its consistency (or satisfiability), instance checking (whether a certain individual is an instance of a concept), and logic entailment (whether a certain constraint is logically implied by the KB). More sophisticated services are emerging that can support modular development of ontologies by checking, for example, whether one ontology is a conservative extension of another with respect to a certain vocabulary (see, e.g., Ghilardi, Lutz, & Wolter, 2006; Cuenca Grau, Horrocks, Kazakov, & Sattler, 2008; Kontchakov, Wolter, & Zakharyaschev, 2008; Kontchakov, Pulina, Sattler, Schneider, Selmer, Wolter, & Zakharyaschev, 2009).\nDescription logics have recently been used to provide access to large amounts of data through a high-level conceptual interface, which is of relevance to both data integration and ontology-based data access. In this setting, the TBox constitutes the conceptual, high-level view of the information managed by the system, and the ABox is physically stored in a relational database and accessed using the standard relational database technology (Poggi et al., 2008a; Calvanese et al., 2008). The fundamental inference service in this case is answering queries to the ABox with the constraints in the TBox taken into account. The kind of queries that have most often been considered are first-order conjunctive queries, which correspond to the commonly used Select-Project-Join SQL queries. The key properties for such an approach to be viable in practice are (i) efficiency of query evaluation, with the ideal target being traditional database query processing, and (ii) that query evaluation can be done by leveraging the relational technology already used for storing the data.\nWith these objectives in mind, a series of description logics—the DL-Lite family—has recently been proposed and investigated by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2005, 2006, 2008a), and later extended by Artale, Calvanese, Kontchakov, and Zakharyaschev (2007a), Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, and Rosati (2008a). Most logics of the family meet the requirements above and, at the same time, are capable of representing many important types of constraints used in conceptual modeling. In particular, inference in various DL-Lite logics can be done efficiently both in the size of the data (data complexity) and in the overall size of the KB (combined complexity): it was shown that KB satisfiability in these logics is polynomial for combined complexity, while answering queries is in AC0 for data complexity—which, roughly, means that, given a\n1. http://www.w3.org/2007/OWL/\nconjunctive query over a KB, the query and the TBox can be rewritten (independently of the ABox) into a union of conjunctive queries over the ABox alone. (It is to be emphasized that the data complexity measure is very important in the application context of the DL-Lite logics, since one can reasonably assume that the size of the data largely dominates the size of the TBox.) Query rewriting techniques have been implemented in various systems such as QuOnto2 (Acciarri, Calvanese, De Giacomo, Lembo, Lenzerini, Palmieri, & Rosati, 2005; Poggi, Rodriguez, & Ruzzi, 2008b), ROWLKit (Corona, Ruzzi, & Savo, 2009), Owlgres (Stocker & Smith, 2008) and REQUIEM (Pérez-Urbina, Motik, & Horrocks, 2009). It has also been demonstrated (Kontchakov et al., 2008) that developing, analyzing and re-using DL-Lite ontologies (TBoxes) can be supported by efficient tools capable of checking various types of entailment between such ontologies with respect to given vocabularies, in particular, by minimal module extraction tools (Kontchakov et al., 2009)—which do not yet exist for richer languages.\nThe significance of the DL-Lite family is testified by the fact that it forms the basis of OWL 2 QL, one of the three profiles of OWL 2.3 The OWL 2 profiles are fragments of the full OWL 2 language that have been designed and standardized for specific application requirements. According to (the current version of) the official W3C profiles document, the purpose of OWL 2 QL is to be the language of choice for applications that use very large amounts of data and where query answering is the most important reasoning task.\nThe common denominator of the DL-Lite logics constructed so far is as follows: (i) quantification over roles and their inverses is not qualified (in other words, in concepts of the form ∃R.C we must have C = >) and (ii) the TBox axioms are concept inclusions that cannot represent any kind of disjunctive information (say, that two concepts cover the whole domain). The other DL-Lite-related dialects were designed—with the aim of capturing more conceptual modeling constraints, but in a somewhat ad hoc manner—by extending this ‘core’ language with a number of constructs such as global functionality constraints, role inclusions and restricted Boolean operators on concepts (see Section 4 for details). Although some attempts have been made (Calvanese et al., 2006; Artale et al., 2007a; Kontchakov & Zakharyaschev, 2008) to put the original DL-Lite logics into a more general perspective and investigate their extensions with a variety of DL constructs required for conceptual modeling, the resulting picture still remains rather fragmentary and far from comprehensive. A systematic investigation of the DL-Lite family and relatives has become even more urgent and challenging in view of the choice of the constructs to be included in the specification of the OWL 2 QL profile4 (in particular, because OWL does not make the unique name assumption, UNA, which was usually adopted in DL-Lite, and uses equalities and inequalities between object names instead).\nThe main aim of this article is to fill in this gap and provide a thorough and comprehensive understanding of the interaction between various DL-Lite constructs and their impact on the computational complexity of reasoning. To achieve this goal, we consider a spectrum of logics, classified according to five mutually orthogonal features:\n(1) the presence or absence of role inclusions;\n2. http://www.dis.uniroma1.it/quonto/ 3. http://www.w3.org/TR/owl2-profiles/ 4. http://www.w3.org/TR/owl2-profiles/#OWL_2_QL\n(2) the form of the allowed concept inclusions, where we consider four classes, called core, Krom, Horn, and Bool, that exhibit different computational properties;\n(3) the form of the allowed numeric constraints, ranging from none, to global functionality constraints only, and to arbitrary number restrictions;\n(4) the presence or absence of the unique name assumption (and the equalities and inequalities between object names, if this assumption is dropped); and\n(5) the presence or absence of standard role constraints such as disjointness, symmetry, asymmetry, reflexivity, irreflexivity, and transitivity.\nFor all the resulting cases, we investigate the combined and data complexity of KB satisfiability and instance checking, as well as the data complexity of query answering. The obtained tight complexity results are summarized in Section 3.4 (Table 2 and Remark 3.1).\nAs already mentioned, the original motivation and distinguishing feature for the logics in the DL-Lite family was their ‘lite’-ness in the sense of low computational complexity of the reasoning tasks (query answering in AC0 for data complexity and tractable KB satisfiability for combined complexity). In the broader perspective we take here, not all of our logics meet this requirement, in particular, those with Krom or Bool concept inclusions.5 However, we identify another distinguishing feature that can be regarded as the natural logic-based characterization of the DL-Lite family: embeddability into the one-variable fragment of firstorder logic without equality and function symbols. This allows us to relate the complexity of DL-Lite logics to the complexity of the corresponding fragments of first-order logic, and thus to obtain a deep insight into the underlying logical properties of each DL-Lite variant. For example, most upper complexity bounds established below follow from this embedding and well-known results on the classical decision problem (see, e.g., Börger, Grädel, & Gurevich, 1997) and descriptive complexity (see, e.g., Immerman, 1999).\nOne of the most interesting findings in this article is that number restrictions, even expressed locally, instead of global role functionality, can be added to the original DL-Lite logics (under the UNA and without role inclusions) ‘for free,’ that is, without changing their computational complexity. The first-order approach shows that in most cases we can also extend the DL-Lite logics with the role constraints mentioned above, again keeping the same complexity. It also gives a framework to analyze the effect of adopting or dropping the UNA and using (in)equalities between object names. For example, we observe that if equality is allowed in the language of DL-Lite (which only makes sense without the UNA) then query answering becomes LogSpace-complete for data complexity, and therefore not first-order rewritable. It also turns out that dropping the UNA results in P-hardness of reasoning (for both combined and data complexity) in the presence of functionality constraints (NLogSpace-hardness was shown by Calvanese et al., 2008), and in NP-hardness if arbitrary number restrictions are allowed.\nAnother interesting finding is the dramatic impact of role inclusions, when combined with number restrictions (or even functionality constraints), on the computational complexity of reasoning. As was already observed by Calvanese et al. (2006), such a combination increases data complexity of instance checking from membership in LogSpace to\n5. Note, by the way, that logics with Bool concept inclusions turn out to be quite useful in conceptual modeling and reasonably manageable computationally (Kontchakov et al., 2008).\nNLogSpace-hardness. We show here that the situation is actually even worse: for data complexity, instance checking turns out to be P-complete in the case of core and Horn logics and coNP-complete in the case of Krom and Bool logics; moreover, KB satisfiability, which is NLogSpace-complete for combined complexity in the simplest ‘core’ case—i.e., efficiently tractable, when role inclusions or number restrictions are used separately—becomes ExpTime-complete—i.e., provably intractable, when they are used together.\nTo retain both role inclusions and functionality constraints in the language and keep complexity within the required limits, Poggi et al. (2008a) introduced another DL-Lite dialect, called DL-LiteA, which restricts the interaction between role inclusions and functionality constraints. Here we extend this result by showing that the DL-Lite logics with such a limited interaction between role inclusions and number restrictions can still be embedded into the one-variable fragment of first-order logic, and so exhibit the same behavior as their fragments with only role inclusions or only number restrictions.\nThe article is structured in the following way. In Section 2, we introduce the logics of the extended DL-Lite family and illustrate their features as conceptual modeling formalisms. In Section 3, we discuss the reasoning services and the complexity measures to be analyzed in what follows, and give an overview of the obtained complexity results. In Section 4, we place the introduced DL-Lite logics in the context of the original DL-Lite family, and discuss its relationship with OWL 2. In Section 5, we study the combined complexity of KB satisfiability and instance checking, while in Section 6, we consider the data complexity of these problems. In Section 7, we study the data complexity of query answering. In Section 8, we analyze the impact of dropping the UNA and adding (in)equalities between object names on the complexity of reasoning. Section 9 concludes the article.\n2. The Extended DL-Lite Family of Description Logics\nDescription Logic (Baader et al., 2003) is a family of logics that have been studied and used in knowledge representation and reasoning since the 1980s. In DLs, the elements of the domain of interest are structured into concepts (unary predicates), and their properties are specified by means of roles (binary predicates). Complex concept and role expressions (or simply concepts and roles) are constructed, starting from a set of concept and role names, by applying suitable constructs, where the set of available constructs depends on the specific description logic. Concepts and roles can then be used in a knowledge base to assert knowledge, both at the intensional level, in a so-called TBox (‘T’ for terminological), and at the extensional level, in a so-called ABox (‘A’ for assertional). A TBox typically consists of a set of axioms stating the inclusion between concepts and roles. In an ABox, one can assert membership of objects (i.e., constants) in concepts, or that a pair of objects is connected by a role. DLs are supported by reasoning services, such as satisfiability checking and query answering, that rely on their logic-based semantics.\n2.1 Syntax and Semantics of the Logics in the DL-Lite Family\nWe introduce now the (extended) DL-Lite family of description logics, which was initially proposed with the aim of capturing typical conceptual modeling formalisms, such as UML class diagrams and ER models (see Section 2.2 for details), while maintaining good computational properties of standard DL reasoning tasks (Calvanese et al., 2005). We begin\nby defining the logic DL-LiteHNbool , which can be regarded as the supremum of the original DL-Lite family (Calvanese et al., 2005, 2006, 2007b) in the lattice of description logics.\nDL-LiteHNbool. The language of DL-Lite HN bool contains object names a0, a1, . . . , concept names A0, A1, . . . , and role names P0, P1, . . . . Complex roles R and concepts C of this language are defined as follows:\nR ::= Pk | P−k , B ::= ⊥ | Ak | ≥ q R, C ::= B | ¬C | C1 u C2,\nwhere q is a positive integer. The concepts of the form B will be called basic. A DL-LiteHNbool TBox, T , is a finite set of concept and role inclusion axioms (or simply concept and role inclusions) of the form:\nC1 v C2 and R1 v R2,\nand an ABox, A, is a finite set of assertions of the form:\nAk(ai), ¬Ak(ai), Pk(ai, aj) and ¬Pk(ai, aj).\nTaken together, T and A constitute the DL-LiteHNbool knowledge base K = (T ,A). In the following, we denote by role(K) the set of role names occurring in T and A, by role±(K) the set {Pk, P−k | Pk ∈ role(K)}, and by ob(A) the set of object names in A. For a role R, we set:\ninv(R) =\n{ P−k , if R = Pk,\nPk, if R = P − k .\nAs usual in description logic, an interpretation, I = (∆I , ·I), consists of a nonempty domain ∆I and an interpretation function ·I that assigns to each object name ai an element aIi ∈ ∆I , to each concept name Ak a subset AIk ⊆ ∆I of the domain, and to each role name Pk a binary relation P I k ⊆ ∆I × ∆I over the domain. Unless otherwise stated, we adopt here the unique name assumption (UNA):\naIi 6= aIj for all i 6= j. (UNA)\nHowever, we shall always indicate which of our results depend on the UNA and which do not, and when they do depend on this assumption, we discuss also the consequences of dropping it (see also Sections 4 and 8).\nThe role and concept constructs are interpreted in I in the standard way:\n(P−k ) I = {(y, x) ∈ ∆I ×∆I | (x, y) ∈ P Ik }, (inverse role) ⊥I = ∅, (the empty set)\n(≥q R)I = { x ∈ ∆I | ]{y ∈ ∆I | (x, y) ∈ RI} ≥ q } , (at least q R-successors)\n(¬C)I = ∆I \\ CI , (not in C) (C1 u C2)I = CI1 ∩ CI2 , (both in C1 and in C2)\nwhere ]X denotes the cardinality of X. We will use standard abbreviations such as\nC1 t C2 = ¬(¬C1 u ¬C2), > = ¬⊥, ∃R = (≥ 1R), ≤ q R = ¬(≥ q + 1R).\nConcepts of the form ≤ q R and ≥ q R are called number restrictions, and those of the form ∃R are called existential concepts.\nThe satisfaction relation |= is also standard:\nI |= C1 v C2 iff CI1 ⊆ CI2 , I |= R1 v R2 iff RI1 ⊆ RI2 , I |= Ak(ai) iff aIi ∈ AIk , I |= Pk(ai, aj) iff (aIi , aIj ) ∈ P Ik , I |= ¬Ak(ai) iff aIi /∈ AIk , I |= ¬Pk(ai, aj) iff (aIi , aIj ) /∈ P Ik .\nA knowledge base K = (T ,A) is said to be satisfiable (or consistent) if there is an interpretation, I, satisfying all the members of T and A. In this case we write I |= K (as well as I |= T and I |= A) and say that I is a model of K (and of T and A).\nThe languages of the DL-Lite family we investigate in this article are obtained by restricting the language of DL-LiteHNbool along three axes: (i) the Boolean operators (bool ) on concepts, (ii) the number restrictions (N ) and (iii) the role inclusions, or hierarchies (H).\nSimilarly to classical logic, we adopt the following definitions. A DL-LiteHNbool TBox T will be called a Krom TBox 6 if its concept inclusions are restricted to:\nB1 v B2, B1 v ¬B2 or ¬B1 v B2 (Krom)\n(here and below all the Bi and B are basic concepts). T will be called a Horn TBox if its concept inclusions are restricted to:\nl\nk\nBk v B (Horn)\n(by definition, the empty conjunction is >). Finally, we will call T a core TBox if its concept inclusions are restricted to:\nB1 v B2 or B1 v ¬B2. (core)\nAs B1 v ¬B2 is equivalent to B1 u B2 v ⊥, core TBoxes can be regarded as sitting in the intersection of Krom and Horn TBoxes.\nRemark 2.1 We will sometimes use conjunctions on the right-hand side of concept inclusions in these restricted languages: C v d k Bk. Clearly, this ‘syntactic sugar’ does not add any extra expressive power.\nDL-LiteHNkrom, DL-Lite HN horn and DL-Lite HN core. The fragments of DL-Lite HN bool with Krom, Horn, and core TBoxes will be denoted by DL-LiteHNkrom, DL-Lite HN horn and DL-Lite HN core, respectively. Other fragments are obtained by limiting the use of number restrictions and role inclusions.\n6. The Krom fragment of first-order logic consists of all formulas in prenex normal form whose quantifier-free part is a conjunction of binary clauses.\nDL-LiteHα . The fragment of DL-Lite HN α , α ∈ {core, krom, horn, bool}, without number restrictions ≥q R, for q ≥ 2, (but with role inclusions) will be denoted by DL-LiteHα . Note that, in DL-LiteHα , we can still use existential concepts ∃R (that is, ≥1R). DL-LiteHFα . Denote by DL-Lite HF α the fragment of DL-Lite HN α in which of all number restrictions ≥q R, we have existential concepts (with q = 1) and only those with q = 2 that occur in concept inclusions of the form ≥2R v ⊥. Such an inclusion is called a global functionality constraint because it states that role R is functional (more precisely, if I |= (≥2R v ⊥) and both (x, y) ∈ RI and (x, z) ∈ RI , then y = z).\nDL-LiteNα , DL-Lite F α and DL-Liteα. If role inclusions are excluded from the language, then for each α ∈ {core, krom, horn, bool} we obtain three fragments: DL-LiteNα (with arbitrary number restrictions), DL-LiteFα (with functionality constraints and existential concepts ∃R), and DL-Liteα (without number restrictions different from ∃R).\nAs we shall see later on in this article, the logics of the form DL-LiteHFα and DL-Lite HN α , even for α = core, turn out to be computationally rather costly because of the interaction between role inclusions and functionality constraints (or, more generally, number restrictions). On the other hand, for the purpose of conceptual modeling one may need both of these constructs; cf. the example in Section 2.2. A compromise can be found by artificially limiting the interplay between role inclusions and number restrictions in a way similar to the logic DL-LiteA proposed by Poggi et al. (2008a).\nFor a TBox T , let v∗T denote the reflexive and transitive closure of the relation{ (R,R′), (inv(R), inv(R′)) | R v R′ ∈ T } and let R ≡∗T R′ iff R v∗T R′ and R′ v∗T R. Say that R′ is a proper sub-role of R in T if R′ v∗T R and R′ 6≡∗T R. DL-Lite (HN ) α . We now introduce the logics DL-Lite (HN ) α , α ∈ {core, krom, horn, bool}, which, on the one hand, restrict the logics DL-LiteHNα by limiting the interaction between role inclusions and number restrictions in order to reduce complexity of reasoning, and, on the other hand, include additional constructs, such as limited qualified existential quantifiers, role disjointness, (a)symmetry and (ir)reflexivity constraints, which increase the expressive power of the logics but do not affect their computational properties.\nDL-Lite (HN ) α TBoxes T must satisfy the conditions (A1)–(A3) below. (We remind the reader that an occurrence of a concept on the right-hand (left-hand) side of a concept inclusion is called negative if it is in the scope of an odd (even) number of negations ¬; otherwise the occurrence is called positive.)\n(A1) T may contain only positive occurrences of qualified number restrictions ≥ q R.C, where C is a conjunction of concepts allowed on the right-hand side of α-concept inclusions;\n(A2) if ≥ q R.C occurs in T , then T does not contain negative occurrences of number restrictions ≥ q′R or ≥ q′ inv(R) with q′ ≥ 2;\n(A3) if R has a proper sub-role in T , then T does not contain negative occurrences of ≥ q R or ≥ q inv(R) with q ≥ 2.\n(It follows that no DL-Lite (HN ) α TBox can contain both, say, a functionality constraint ≥2R v ⊥ and an occurrence of ≥q R.C, for any q ≥ 1.) Additionally, DL-Lite (HN ) α TBoxes can contain role constraints (or axioms) of the form:\nDis(R1, R2), Asym(Pk), Sym(Pk), Irr(Pk), and Ref(Pk).\nThe meaning of these new constructs is defined as usual: for an interpretation I = (∆I , ·I),\n• (≥q R.C)I = { x ∈ ∆I | ]{y ∈ CI | (x, y) ∈ RI} ≥ q } ;\n• I |= Dis(R1, R2) iff RI1 ∩RI2 = ∅ (roles R1 and R2 are disjoint);\n• I |= Asym(Pk) iff P Ik ∩ (P − k ) I = ∅ (role Pk is asymmetric);\n• I |= Sym(Pk) iff P Ik = (P − k ) I (Pk is symmetric);\n• I |= Irr(Pk) iff (x, x) /∈ P Ik for all x ∈ ∆I (Pk is irreflexive);\n• I |= Ref(Pk) iff (x, x) ∈ P Ik for all x ∈ ∆I (Pk is reflexive).\nIt is to be emphasized that these extra constructs are often used in conceptual modeling and their introduction in DL-Lite (HN ) α is motivated by the OWL 2 QL proposal. (Note that DL-Lite (HN ) α contains both DL-Lite H α and DL-Lite N α as its proper fragments.)\nDL-Lite (HN )+ α . For α ∈ {bool, horn, krom, core}, denote by DL-Lite(HN ) + α the extension of DL-Lite (HN ) α with role transitivity constraints of the form Tra(Pk), the meaning of which is as expected:\n• I |= Tra(Pk) iff (x, y) ∈ P Ik and (y, z) ∈ P Ik imply (x, z) ∈ P Ik , for all x, y, z ∈ ∆I (Pk is transitive).\nWe remind the reader of the standard restriction limiting the use of transitive roles in DLs (see, e.g., Horrocks, Sattler, & Tobies, 2000):\n• only simple roles R are allowed in concepts of the form ≥ q R, for q ≥ 2,\nwhere by a simple role in a given TBox T we understand a role without transitive sub-roles (including itself). In particular, if T contains Tra(P ) then P and P− are not simple, and so T cannot contain occurrences of concepts of the form ≥ q P and ≥ q P−, for q ≥ 2.\nDL-Lite (HF) α and DL-Lite (HF)+ α . We also define languages DL-Lite (HF) α as sub-languages of DL-Lite (HN ) α , in which only number restrictions of the form ∃R, ∃R.C and functionality constraints ≥2R v ⊥ are allowed—provided, of course, that they satisfy (A1)–(A3); in particular, ∃R.C is not allowed ifR is functional. As before, DL-Lite(HF) +\nα are the extensions\nof DL-Lite (HF) α with role transitivity constraints (satisfying the restriction above).\nThus, the extended DL-Lite family we consider in this article consists of 40 different logics collected in Table 1. The inclusions between these logics are shown in Figure 1. They are obtained by taking the product of the left- and right-hand parts of the picture, where the subscript α on the right-hand part ranges over {core, krom, horn, bool}, i.e., the subscripts on the left-hand part, and similarly, the superscript β on the left-hand part ranges over { ,F ,N ,H,HF ,HN , (HF), (HN ), (HF)+, (HN )+}, i.e., the superscripts on the right-hand part.\nThe position of these logics relative to other DL-Lite logics known in the literature and the OWL 2 QL profile will be discussed in Section 4. And starting from Section 5, we begin a thorough investigation of the computational properties of the logics in the extended DLLite family, both with and without the UNA. But before that we illustrate the expressive power of the DL-Lite logics by a concrete example.\n2.2 DL-Lite for Conceptual Modeling\nA tight correspondence between conceptual modeling formalisms, such as the ER model and UML class diagrams, and various description logics has been pointed out in various papers (e.g., Calvanese et al., 1998b, 1999; Borgida & Brachman, 2003; Berardi et al., 2005). Here we give an example showing how DL-Lite logics can be used for conceptual modeling purposes; for more details see the work by Artale et al. (2007b).\nLet us consider the UML class diagram depicted in Figure 2 and representing (a portion of) a company information system. According to the diagram, all managers are employees and are partitioned into area managers and top managers. This information can be represented by means of the following concept inclusions (where in brackets we specify the minimal DL-Lite language the inclusion belongs to):\nManager v Employee (DL-Litecore) AreaManager v Manager (DL-Litecore) TopManager v Manager (DL-Litecore) AreaManager v ¬TopManager (DL-Litecore) Manager v AreaManager t TopManager (DL-Litebool)\nEach employee has two functional attributes, empCode and salary, with integer values. Unlike OWL, here we do not distinguish between abstract objects and data values. Hence we model a datatype, such as Integer , by means of a concept, and an attribute, such as employee’s salary, by means of a role. Thus, salary can be represented as follows:\nEmployee v ∃salary (DL-Litecore) ∃salary− v Integer (DL-Litecore) ≥ 2 salary v ⊥ (DL-LiteFcore)\nThe functional attribute empCode with values in Integer is represented in the same way. The binary relationship worksOn has Employee as its domain and Project as its range:\n∃worksOn v Employee (DL-Litecore) ∃worksOn− v Project (DL-Litecore)\nThe binary relationship boss with domain Employee and range Manager is treated analogously. Each employee works on a project and has exactly one boss, while a project must\ninvolve at least three employees:\nEmployee v ∃worksOn (DL-Litecore) Employee v ∃boss (DL-Litecore) ≥ 2 boss v ⊥ (DL-LiteFcore)\nProject v ≥ 3 worksOn− (DL-LiteNcore)\nA top manager manages exactly one project and also works on that project, while a project is managed by exactly one top manager:\n∃manages v TopManager (DL-Litecore) ∃manages− v Project (DL-Litecore) TopManager v ∃manages (DL-Litecore) Project v ∃manages− (DL-Litecore)\n≥ 2 manages v ⊥ (DL-LiteFcore) ≥ 2 manages− v ⊥ (DL-LiteFcore)\nmanages v worksOn (DL-LiteHcore)\nAll in all, the only languages in the extended DL-Lite family capable of representing the UML class diagram in Figure 2 are DL-LiteHNbool and DL-Lite (HN ) bool . Note, however, that except for the covering constraint, Manager v AreaManager tTopManager , all other concept inclusions in the DL-Lite translation of the UML class diagram belong to variants of the ‘core’ fragments DL-LiteHNcore and DL-Lite (HN ) core . It is not hard to imagine a situation where one needs Horn concept inclusions to represent integrity constraints over UML class diagrams, for example, to express (together with the above axioms) that ‘no chief executive officer may work on five projects and be a manager of one of them:’\nCEO u (≥ 5 worksOn) u ∃manages v ⊥ (DL-LiteNhorn)\nIn the context of UML class diagrams, the Krom fragment DL-Litekrom (with its variants) seems to be useless: it extends DL-Litecore with concept inclusions of the form ¬B1 v B2 or, equivalently, > v B1 t B2, which are rarely used in conceptual modeling. Indeed, this would correspond to partitioning the whole domain of interest in just two parts, while more general and useful covering constraints of the form B v B1 t · · · tBk require the full Bool language. On the other hand, the Krom fragments are important for pinpointing the borderlines of various complexity classes over the description logics of the DL-Lite family and their extensions; see Table 2.\n3. Reasoning in DL-Lite Logics\nWe discuss now the reasoning problems we consider in this article, their mutual relationships, and the complexity measures we adopt. We also provide an overview of the complexity results for DL-Lite logics obtained in this article."
    }, {
      "heading" : "3.1 Reasoning Problems",
      "text" : "We will concentrate on three fundamental and standard reasoning tasks for description logics: satisfiability (or consistency), instance checking, and query answering.\nFor a DL L in the extended DL-Lite family, we define an L-concept inclusion as any concept inclusion allowed in L. Similarly, we define the notions of L-KB and L-TBox. Finally, define an L-concept as any concept that can occur on the right-hand side of an L-concept inclusion or a conjunction of such concepts.\nSatisfiability. The KB satisfiability problem is to check, given an L-KB K, whether there is a model of K. Clearly, satisfiability is the minimal requirement for any ontology. As is well known in DL (Baader et al., 2003), many other reasoning tasks for description logics are reducible to the satisfiability problem. Consider, for example, the subsumption problem: given an L-TBox T and an L-concept inclusion C1 v C2, decide whether T |= C1 v C2, that is, CI1 ⊆ CI2 , for every model I of T . To reduce this problem to (un)satisfiability, take a fresh concept name A, a fresh object name a, and set K = (T ′,A), where\nT ′ = T ∪ {A v C1, A v ¬C2} and A = {A(a)}.\nIt is easy to see that T |= C1 v C2 iff K is not satisfiable. For core, Krom and Horn KBs, if C2 = d kDk, where each Dk is a (possibly negated) basic concept, checking unsatisfiability of K amounts to checking unsatisfiability of each of the KBs Kk = (Tk,A), where Tk = T ∪ {A v C1, A v ¬Dk} (for Horn KBs, replace A v ¬B with the equivalent A uB v ⊥).\nThe concept satisfiability problem—given an L-TBox T and an L-concept C, decide whether CI 6= ∅ in a model I of T—is also easily reducible to KB satisfiability. Indeed, take a fresh concept name A, a fresh object name a, and set K = (T ′,A), where\nT ′ = T ∪ {A v C} and A = {A(a)}.\nThen C is satisfiable with respect to T iff K is satisfiable.\nInstance checking. The instance checking problem is to decide, given an object name a, an L-concept C and an L-KB K = (T ,A), whether K |= C(a), that is, aI ∈ CI , for every model I of K. Instance checking is also reducible to (un)satisfiability: an object a is an instance of an L-concept C in every model of K = (T ,A) iff the KB K′ = (T ′,A′), with\nT ′ = T ∪ {A v ¬C} and A′ = A ∪ {A(a)},\nis not satisfiable, where A is a fresh concept name. For core, Krom and Horn KBs, if C = d kDk, where each Dk is a (possibly negated) basic concept, we can proceed as for subsumption: checking the unsatisfiability of K′ amounts to checking the unsatisfiability of each KB K′k = (T ′k ,A′) with T ′k = T ∪ {A v ¬Dk}.\nConversely, KB satisfiability is reducible to the complement of instance checking: K is satisfiable iff K 6|= A(a), for a fresh concept name A and a fresh object a.\nQuery answering. A positive existential query q(x1, . . . , xn) is any first-order formula ϕ(x1, . . . , xn) constructed by means of conjunction, disjunction and existential quantification starting from atoms of the from Ak(t) and Pk(t1, t2), where Ak is a concept name, Pk\na role name, and t, t1, t2 are terms taken from the list of variables y0, y1, . . . and the list of object names a0, a1, . . . (i.e., ϕ is a positive existential formula). More precisely,\nt ::= yi | ai, ϕ ::= Ak(t) | Pk(t1, t2) | ϕ1 ∧ ϕ2 | ϕ1 ∨ ϕ2 | ∃yi ϕ.\nThe free variables of ϕ are called distinguished variables of q and the bound ones are nondistinguished variables of q. We write q(x1, . . . , xn) for a query with distinguished variables x1, . . . , xn. A conjunctive query is a positive existential query that contains no disjunction (it is constructed from atoms by means of conjunction and existential quantification only).\nGiven a query q(~x) = ϕ(~x) with ~x = x1, . . . , xn and an n-tuple ~a of object names, we write q(~a) for the result of replacing every occurrence of xi in ϕ(~x) with the ith member of ~a. Queries containing no distinguished variables will be called ground (they are also known as Boolean).\nLet I = (∆I , ·I) be an interpretation. An assignment a in ∆I is a function associating with every variable y an element a(y) of ∆I . We will use the following notation: aI,ai = a I i and yI,a = a(y). The satisfaction relation for positive existential formulas with respect to a given assignment a is defined inductively by taking:\nI |=a Ak(t) iff tI,a ∈ AIk ,\nI |=a Pk(t1, t2) iff (tI,a1 , t I,a 2 ) ∈ P I k ,\nI |=a ϕ1 ∧ ϕ2 iff I |=a ϕ1 and I |=a ϕ2, I |=a ϕ1 ∨ ϕ2 iff I |=a ϕ1 or I |=a ϕ2, I |=a ∃yi ϕ iff I |=b ϕ, for some assignment b in ∆I that may differ from a on yi.\nFor a ground query q(~a), the satisfaction relation does not depend on the assignment a, and so we write I |= q(~a) instead of I |=a q(~a). The answer to such a query is either ‘yes’ or ‘no.’\nFor a KB K = (T ,A), we say that a tuple ~a of object names from A is a certain answer to q(~x) with respect to K, and write K |= q(~a), if I |= q(~a) whenever I |= K. The query answering problem can be formulated as follows: given an L-KB K = (T ,A), a query q(~x), and a tuple ~a of object names from A, decide whether K |= q(~a).\nNote that the instance checking problem is a special case of query answering: an object a is an instance of an L-concept C with respect to a KB K iff the answer to the query A(a) with respect to K′ is ‘yes,’ where K′ = (T ′,A) and T ′ = T ∪ {C v A}, with A a fresh concept name. For Horn-concepts B1 u · · · uBk, we consider the query A1(a) ∧ · · · ∧Ak(a) with respect to K′, where K′ = (T ′,A) and T ′ = T ∪ {B1 v A1, . . . , Bk v Ak}, with the Ai fresh concept names. Similarly, we deal with Krom-concepts D1 u · · · uDk, where each Di is a possibly negated basic concept. For core-concepts, the reduction holds just for conjunctions of basic concepts."
    }, {
      "heading" : "3.2 Complexity Measures: Data and Combined Complexity",
      "text" : "The computational complexity of the reasoning problems discussed above can be analyzed with respect to different complexity measures, which depend on those parameters of the\nproblem that are regarded to be the input (i.e., can vary) and those that are regarded to be fixed. For satisfiability and instance checking, the parameters to consider are the size of the TBox T and the size of the ABox A, that is the number of symbols in T and A, denoted |T | and |A|, respectively. The size |K| of the knowledge K = (T ,A) is simply given by |T |+ |A|. For query answering, one more parameter to consider would be the size of the query. However, in our analysis we adopt the standard database assumption that the size of queries is always bounded by some reasonable constant and, in any case, negligible with respect to both the size of the TBox and the size of the ABox. Thus we do not count the query as part of the input.\nHence, we consider our reasoning problems under two complexity measures. If the whole KB K is regarded as an input, then we deal with combined complexity. If, however, only the ABox A is counted as an input, while the TBox T (and the query) is regarded to be fixed, then our concern is data complexity (Vardi, 1982). Combined complexity is of interest when we are still designing and testing the ontology. On the other hand, data complexity is preferable in all those cases where the TBox is fixed or its size (and the size of the query) is negligible compared to the size of the ABox, which is the case, for instance, in the context of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy, 2004; Lenzerini, 2002; Calvanese et al., 2008). Since the logics of the DL-Lite family were tailored to deal with large data sets stored in relational databases, data complexity of both instance checking and query answering is of particular interest to us.\n3.3 Remarks on the Complexity Classes LogSpace and AC0\nIn this paper, we deal with the following complexity classes:\nAC0 ( LogSpace ⊆ NLogSpace ⊆ P ⊆ NP ⊆ ExpTime.\nTheir definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979; Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006). Here we only remind the reader of the two smallest classes LogSpace and AC0.\nA problem belongs to LogSpace if there is a two-tape Turing machine M such that, starting with an input of length n written on the read-only input tape,M stops in an accepting or rejecting state having used at most log n cells of the (initially blank) read/write work tape. A LogSpace transducer is a three-tape Turing machine that, having started with an input of length n written on the read-only input tape, writes the result (of polynomial size) on the write-only output tape using at most log n cells of the (initially blank) read/write work tape. A LogSpace-reduction is a reduction computable by a LogSpace transducer; the composition of two LogSpace transducers is also a LogSpace transducer (Kozen, 2006, Lemma 5.1).\nThe formal definition of the complexity class AC0 (see, e.g., Boppana & Sipser, 1990; Vollmer, 1999 and references therein) is based on the circuit model, where functions are represented as directed acyclic graphs built from unbounded fan-in And, Or and Not gates (i.e., And and Or gates may have an unbounded number of incoming edges). For this definition we assume that decision problems are encoded in the alphabet {0, 1} and so can be regarded as Boolean functions. AC0 is the class of problems definable using\na family of circuits of constant depth and polynomial size, which can be generated by a deterministic Turing machine in logarithmic time (in the size of the input); the latter condition is called LogTime-uniformity. Intuitively, AC0 allows us to use polynomially many processors but the run-time must be constant. A typical example of an AC0 problem is evaluation of first-order queries over databases (or model checking of first-order sentences over finite models), where only the database (first-order model) is regarded as the input and the query (first-order sentence) is assumed to be fixed (Abiteboul, Hull, & Vianu, 1995; Vollmer, 1999). On the other hand, the undirected graph reachability problem is known to be in LogSpace (Reingold, 2008) but not in AC0. A Boolean function f : {0, 1}n → {0, 1} is called AC0-reducible (or constant-depth reducible) to a function g : {0, 1}n → {0, 1} if there is a (LogTime-uniform) family of constant-depth circuits built from And, Or, Not and g gates that computes f . In this case we say that there is an AC0-reduction. Note that all the reductions considered in Section 3.1 are AC0-reductions. Unless otherwise indicated, in what follows we write ‘reduction’ for ‘AC0-reduction.’"
    }, {
      "heading" : "3.4 Summary of Complexity Results",
      "text" : "In this article, our aim is to investigate (i) the combined and data complexity of the satisfiability and instance checking problems and (ii) the data complexity of the query answering problem for the logics of the extended DL-Lite family, both with and without the UNA. The obtained and known results for the first 32 logics from Table 1 (the logics DL-Lite (HF)+ α and DL-Lite (HN )+ α are not included) are summarized in Table 2 (we remind the reader that satisfiability and instance checking are reducible to the complements of each other and that instance checking is a special case of query answering). In fact, all of the results in the table follow from the lower and upper bounds marked with [≥] and [≤], respectively (by taking into account the hierarchy of languages of the DL-Lite family): for example, the NLogSpace membership of satisfiability in DL-LiteNkrom in Theorem 5.7 implies the same upper bound for DL-LiteFkrom, DL-Litekrom, DL-Lite N core, DL-Lite F core and DL-Litecore because all of them are sub-languages of DL-LiteNkrom.\nRemark 3.1 Two further complexity results are to be noted (they are not included in Table 2):\n(i) If equality between object names is allowed in the language of DL-Lite, which only makes sense if the UNA is dropped, then the AC0 memberships in Table 2 are replaced by LogSpace-completeness (see Section 8, Theorem 8.3 and 8.9); inequality constraints do not affect the complexity.\n(ii) If we extend any of our languages with role transitivity constraints then the combined complexity of satisfiability remains the same, while for data complexity, instance checking and query answering become NLogSpace-hard (see Lemma 6.3), i.e., the membership in AC0 for data complexity is replaced by NLogSpace-completeness, while all other complexity results remain the same.\nIn either case, the property of first-order rewritability—that is, the possibility of rewriting a given query q and a given TBox T into a single first-order query q′ returning the certain answers to q over (T ,A) for every ABox A, which ensures that the query answering problem is in AC0 for data complexity—is lost.\n(in particular, DL-Lite[ |H]α is either DL-Liteα or DL-Lite H α ).\nDL-Liteβcore/horn means DL-Lite β core or DL-Lite β horn (likewise for DL-Lite β krom/bool). ‘≤ [X]’ (‘≥ [X]’) means that the upper (respectively, lower) bound follows from [X].\nDetailed proofs of our results will be given in Sections 5–8. For the variants of logics involving number restrictions, all upper bounds hold also under the assumption that the numbers q in concepts of the form ≥ q R are given in binary. (Intuitively, this follows from the fact that in our proofs we only use those numbers that explicitly occur in the KB.) All lower bounds remain the same for the unary coding, since in the corresponding proofs we only use numbers not exceeding 4.\nIn the next section we consider the extended DL-Lite family in a more general context by identifying its place among other DL-Lite-related logics, in particular the OWL 2 profiles.\n4. The Landscape of DL-Lite Logics\nThe original family of DL-Lite logics was created with two goals in mind: to identify description logics that, on the one hand, are capable of representing some basic features of conceptual modeling formalisms (such as UML class diagrams and ER diagrams) and, on the other hand, are computationally tractable, in particular, matching the AC0 data complexity of database query answering.\nAs we saw in Section 2.2, to represent UML class diagrams one does not need the typical quantification constructs of the basic description logic ALC (Schmidt-Schauß & Smolka, 1991), namely, universal restriction ∀R.C and qualified existential quantification ∃R.C: one can always take the role filler C to be >. Indeed, domain and range restrictions for a relationship P can be expressed by the concepts inclusions ∃P v B1 and ∃P− v B2, respectively. Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v ¬B2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-LiteFcore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-LiteFhorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2). The computational behavior of the new logic turned out to be the same as that of DL-LiteHcore. It may be worth mentioning that DL-LiteHcore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004). Note also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity. We conjecture that similar results can be obtained for the other DL-Lite logics introduced in this paper. Artale et al. (2007b) demonstrated how n-ary relations can be represented in DL-LiteFcore by means of reification.\nA further variant of DL-Lite, called DL-LiteA (‘A’ for attributes), was introduced by Poggi et al. (2008a) with the aim of capturing as many features of conceptual modeling formalisms as possible, while still maintaining the computational properties of the basic variants of DL-Lite. One of the features in DL-LiteA, borrowed from conceptual modeling formalisms and adopted also in OWL, is the distinction between (abstract) objects and data values, and consequently, between concepts (sets of objects) and datatypes (sets of data values), and between roles (i.e., object properties in OWL, relating objects with objects) and attributes (i.e., data properties in OWL, relating objects with data values). However, as far as the results in this paper are concerned, the distinction between concepts and datatypes, and between roles and attributes has no impact on reasoning whatsoever, since datatypes can simply be treated as special concepts that are mutually disjoint and are also disjoint from the proper concepts. Instead, more relevant for reasoning is the possibility to express in DL-LiteA both role inclusions and functionality, i.e., DL-LiteA includes both DL-LiteHcore and DL-Lite F core, but not DL-Lite HF core.\nAs we have already mentioned, role inclusions and functionality constraints cannot be combined in an unrestricted way without losing the good computational properties: in\nTheorems 5.10 and 6.7, we prove that satisfiability of DL-LiteHFcore KBs is ExpTime-hard for combined complexity, while instance checking is data-hard for P (NLogSpace-hardness was shown by Calvanese et al., 2006). In DL-LiteA, to keep query answering in AC\n0 for data complexity and satisfiability in NLogSpace for combined complexity, functional roles (and attributes) are not allowed to be specialized, i.e., used positively on the right-hand side of role (and attribute) inclusion axioms. So, condition (A3) is a slight generalization of this restriction. DL-LiteA also allows axioms of the form B v ∃R.C for non-functional roles R, which is covered by conditions (A1) and (A2). Thus, DL-LiteA can be regarded as a proper fragment of both DL-Lite (HF) core and DL-Lite (HN ) horn . We show in Sections 5.3 and 7 that these three languages enjoy very similar computational properties under the UNA: tractable satisfiability and query answering in AC0.\nWe conclude this section with a picture in Figure 3 illustrating the landscape of DLLite-related logics by grouping them according to the data complexity of positive existential query answering under the UNA. The original eight DL-Lite logics, called by Calvanese et al. (2007b) ‘the DL-Lite family,’ are shown in the bottom sector of the picture (the logics DL-Lite+A and DL-Lite + A,u extend DL-LiteA and DL-LiteA,u with identification constraints, which are out of the scope of this article). Their nearest relatives are the logic DL-Lite (HN ) horn and its fragments, which are all in AC0 as well. The next layer contains the logics DL-LiteHFcore and DL-LiteHFhorn, in which query answering is data-complete for P (no matter whether the UNA is adopted or not). In fact, these logics are fragments of the much more expressive DL Horn-SHIQ, which was shown to enjoy the same data complexity of query answering by Eiter et al. (2008). It remains to be seen whether polynomial query answering is practically feasible; recent experiments with the DL EL (Lutz, Toman, & Wolter, 2008) indicate that this may indeed be the case. Finally, very distant relatives of the DL-Lite family comprise\nthe upper layer of the picture, where query answering is data-complete for coNP, that is, the same as for the very expressive DL SHIQ.\n4.1 The DL-Lite Family and OWL 2\nThe upcoming version 2 of the Web Ontology Language OWL7 defines three profiles,8 that is, restricted versions of the language that suit specific needs. The DL-Lite family, notably DL-LiteHcore (or the original DL-LiteR), is at the basis of one of these OWL 2 profiles, called OWL 2 QL. According to http://www.w3.org/TR/owl2-profiles/, ‘OWL 2 QL is aimed at applications that use very large volumes of instance data, and where query answering is the most important reasoning task. In OWL 2 QL, [. . . ] sound and complete conjunctive query answering can be performed in LogSpace with respect to the size of the data (assertions) [and] polynomial time algorithms can be used to implement the ontology consistency and class expression subsumption reasoning problems. The expressive power of the profile is necessarily quite limited, although it does include most of the main features of conceptual models such as UML class diagrams and ER diagrams.’ In this section, we briefly discuss the results obtained in this article in the context of additional constructs that are present in OWL 2.\nA very important difference between the DL-Lite family and OWL is the status of the unique name assumption (UNA): this assumption is quite common in data management, and hence adopted in the DL-Lite family, but not adopted in OWL. Instead, the OWL syntax provides explicit means for stating that object names, say a and b, are supposed to denote the same individual, a ≈ b, or that they should be interpreted differently, a 6≈ b (in OWL, these constructs are called sameAs and differentFrom).\nThe complexity results we obtain for logics of the form DL-LiteHα do not depend on whether the UNA is adopted or not (because every model of a DL-LiteHα KB without UNA can be ‘untangled’ into a model of the same KB respecting the UNA; see Lemma 8.10). However, this is not the case for the logics DL-LiteFα and DL-Lite N α , where there is an obvious interaction between the UNA and number restrictions (cf. Table 2). For example, under the UNA, instance checking for DL-LiteFcore is in AC\n0 for data complexity, whereas dropping this assumption results in a much higher complexity: in Section 8, we prove that it is P-complete. The addition of the equality construct ≈ to DL-LiteHcore and DL-LiteHhorn slightly changes data complexity of query answering and instance checking, as it rises from membership in AC0 to LogSpace-completeness; see Section 8. What is more important, however, is that in this case we loose first-order rewritability of query answering and instance checking, and as a result cannot use the standard database query engines in a straightforward manner.\nSince the OWL 2 profiles are defined as syntactic restrictions of the language without changing the basic semantic assumptions, it was chosen not to include in the OWL 2 QL profile any construct that interferes with the UNA and which, in the absence of the UNA, would cause higher complexity. That is why OWL 2 QL does not include number restrictions, not even functionality constraints. Also, keys (the mechanism of identifying objects by means of the values of their properties) are not supported, although they are an impor-\n7. http://www.w3.org/2007/OWL/ 8. In logic, profiles would be called fragments as they are defined by placing restrictions on the OWL 2\nsyntax only.\ntant notion in conceptual modeling. Indeed, keys can be considered as a generalization of functionality constraints (Toman & Weddell, 2005, 2008; Calvanese, De Giacomo, Lembo, Lenzerini, & Rosati, 2007a, 2008b), since asserting a unary key, i.e., one involving only a single role R, is equivalent to asserting the functionality of the inverse of R. Hence, in the absence of the UNA, allowing keys would change the computational properties.\nAs we have already mentioned, some other standard OWL constructs, such as role disjointness, (a)symmetry and (ir)reflexivity constraints, can be added to the DL-Lite logics without changing their computational behavior. Role transitivity constraints, Tra(R), asserting that R must be interpreted as a transitive role, can also be added to DL-Lite (HN ) horn but this leads to the increase of the data complexity for all reasoning problems to NLogSpace, although satisfiability remains in P for combined complexity. These results can be found in Section 5.3.\nOf other constructs of OWL 2 that so far are not supported by the DL-Lite logics we mention nominals (i.e., singleton concepts), Boolean operators on roles, and role chains."
    }, {
      "heading" : "5. Satisfiability: Combined Complexity",
      "text" : "DL-LiteHNbool is clearly a sub-logic of the description logic SHIQ, the satisfiability problem for which is known to be ExpTime-complete (Tobies, 2001).\nIn Section 5.1 we show, however, that the satisfiability problem for DL-LiteNbool KBs is reducible to the satisfiability problem for the one-variable fragment, QL1, of first-order logic without equality and function symbols. As satisfiability of QL1-formulas is NP-complete (see, e.g., Börger et al., 1997) and the logics under consideration contain full Booleans on concepts, satisfiability of DL-LiteNbool KBs is NP-complete as well. We shall also see that the translations of Horn and Krom KBs into QL1 belong to the Horn and Krom fragments of QL1, respectively, which are known to be P- and NLogSpace-complete (see, e.g., Papadimitriou, 1994; Börger et al., 1997). In Section 5.2, we will show how to simulate the behavior of polynomial-space-bounded alternating Turing machines by means of DL-LiteHFcore KBs. This will give the (optimal) ExpTime lower bound for satisfiability of KBs in all the languages of our family containing unrestricted occurrences of both functionality constraints and role inclusions. In Section 5.3, we extend the embedding into QL1, defined in Section 5.1, to the logic DL-Lite\n(HN ) bool , thereby establishing the same upper bounds as for DL-Lite N bool and its\nfragments. Finally, in Section 5.4 we investigate the impact of role transitivity constraints.\n5.1 DL-LiteNbool and its Fragments: First-Order Perspective Our aim in this section is to construct a reduction of the satisfiability problem for DL-LiteNbool KBs to satisfiability of QL1-formulas. We will do this in two steps: first we present a lengthy yet quite ‘natural’ and transparent (yet exponential) reduction ·†, and then we shall see from the proof that this reduction can be substantially optimized to a linear reduction ·‡.\nLet K = (T ,A) be a DL-LiteNbool KB. Recall that role±(K) denotes the set of direct and inverse role names occurring in K and ob(A) the set of object names occurring in A. For R ∈ role±(K), let QRT be the set of natural numbers containing 1 and all the numbers q for which the concept ≥ q R occurs in T (recall that the ABox does not contain number restrictions). Note that |QRT | ≥ 2 if T contains a functionality constraint for R.\nWith every object name ai ∈ ob(A) we associate the individual constant ai of QL1 and with every concept name Ai the unary predicate Ai(x) from the signature of QL1. For each role R ∈ role±(K), we introduce |QRT |-many fresh unary predicates\nEqR(x), for q ∈ QRT .\nThe intended meaning of these predicates is as follows: for a role name Pk,\n• EqPk(x) and EqP−k (x) represent the sets of points with at least q distinct Pk-successors and at least q distinct Pk-predecessors, respectively. In particular, E1Pk(x) and E1P − k (x) represent the domain and range of Pk, respectively.\nAdditionally, for every pair of roles Pk, P − k ∈ role ±(K), we take two fresh individual constants\ndpk and dp − k\nof QL1, which will serve as ‘representatives’ of the points from the domains of Pk and P−k , respectively (provided that they are not empty). Let dr(K) = { dr | R ∈ role±(K) } . Furthermore, for each pair of object names ai, aj ∈ ob(A) and each R ∈ role±(K), we take a fresh propositional variable Raiaj of QL1 to encode the ABox assertion R(ai, aj).9\nBy induction on the construction of a DL-LiteNbool concept C we define the QL1-formula C∗:\n⊥∗ = ⊥, (Ai)∗ = Ai(x), (≥q R)∗ = EqR(x), (¬C)∗ = ¬C∗(x), (C1 u C2)∗ = C∗1 (x) ∧ C∗2 (x).\nThe DL-LiteNbool TBox T corresponds then to the QL1-sentence ∀x T ∗(x), where\nT ∗(x) = ∧\nC1vC2∈T\n( C∗1 (x)→ C∗2 (x) ) . (1)\nThe ABox A is translated into the following pair of QL1-sentences\nA†1 = ∧\nAk(ai)∈A\nAk(ai) ∧ ∧\n¬Ak(ai)∈A\n¬Ak(ai), (2)\nA†2 = ∧\nPk(ai,aj)∈A\nPkaiaj ∧ ∧\n¬Pk(ai,aj)∈A\n¬Pkaiaj . (3)\nFor every role R ∈ role±(K), we need two QL1-formulas:\nεR(x) = E1R(x)→ inv(E1R)(inv(dr)), (4) δR(x) = ∧\nq,q′∈QRT , q ′>q\nq′>q′′>q for no q′′∈QRT\n( Eq′R(x)→ EqR(x) ) , (5)\n9. In what follows, we slightly abuse notation and write R(ai, aj) ∈ A to indicate that Pk(ai, aj) ∈ A if R = Pk, or Pk(aj , ai) ∈ A if R = P−k .\nwhere (by overloading the inv operator),\ninv(EqR) =\n{ EqP − k , if R = Pk,\nEqPk, if R = P − k ,\nand inv(dr) =\n{ dp−k , if R = Pk,\ndpk, if R = P − k .\nFormula (4) says that if the domain of R is not empty then its range is not empty either: it contains the constant inv(dr), the ‘representative’ of the domain of inv(R).\nWe also need formulas representing the relationship of the propositional variables Raiaj with the unary predicates for the role domain and range: for a role R ∈ role±(K), let R† be the following QL1-sentence\n∧ ai∈ob(A) ∧ q∈QRT ∧ aj1 ,...,ajq∈ob(A) jk 6=jk′ for k 6=k′ ( q∧ k=1 Raiajk → EqR(ai) ) ∧ ∧ ai,aj∈ob(A) ( Raiaj → inv(R)ajai ) , (6)\nwhere inv(R)ajai is the propositional variable P − k ajai if R = Pk and Pkajai if R = P − k . Note that the first conjunct of (6) is the only part of the translation that relies on the UNA. Finally, for the DL-LiteNbool knowledge base K = (T ,A), we set\nK† = ∀x [ T ∗(x) ∧ ∧ R∈role±(K) ( εR(x) ∧ δR(x) ) ] ∧ [ A†1 ∧ A†2 ∧ ∧ R∈role±(K) R† ] .\nThus, K† is a universal sentence of QL1.\nExample 5.1 Consider, for example, the KB K = (T ,A) with T = { A v ∃P−, ∃P− v A, A v ≥ 2P, > v ≤ 1P−, ∃P v A } and A = {A(a), P (a, a′)}. Then we obtain the following first-order translation:\nK† = ∀xχ(x) ∧ A(a) ∧ Paa′ ∧( Paa′ → E1P (a) ) ∧ ( Paa→ E1P (a) ) ∧(\nPa′a→ E1P (a′) ) ∧ ( Pa′a′ → E1P (a′) ) ∧(\nP−aa′ → E1P−(a) ) ∧ ( P−aa→ E1P−(a) ) ∧(\nP−a′a→ E1P−(a′) ) ∧ ( P−a′a′ → E1P−(a′) ) ∧(\nPaa′ ∧ Paa→ E2P (a) ) ∧ ( Pa′a ∧ Pa′a′ → E2P (a′) ) ∧(\nP−aa′ ∧ P−aa→ E2P−(a) ) ∧ ( P−a′a ∧ P−a′a′ → E2P−(a′) ) ∧(\nPaa′ ↔ P−a′a ) ∧ ( Pa′a↔ P−aa′ ) ∧ ( Paa↔ P−aa ) ∧ ( Pa′a′ ↔ P−a′a′ ) .\nwhere\nχ(x) = ( A(x)→ E1P−(x) ) ∧ ( E1P −(x)→ A(x) ) ∧ ( A(x)→ E2P (x) ) ∧(\n> → ¬E2P−(x) ) ∧ ( E1P (x)→ A(x) ) ∧(\nE1P (x)→ E1P−(dp−) ) ∧ ( E1P −(x)→ E1P (dp) ) ∧(\nE2P (x)→ E1P (x) ) ∧ ( E2P −(x)→ E1P−(x) ) . (7)\nTheorem 5.2 A DL-LiteNbool knowledge base K = (T ,A) is satisfiable iff the QL1-sentence K† is satisfiable.\nProof (⇐) If K† is satisfiable then there is a model M of K† whose domain consists of all the constants occurring in K†—i.e., ob(A) ∪ dr(K) (say, an Herbrand model of K†). We denote this domain by D and the interpretations of the (unary) predicates P , propositional variables p and constants a of QL1 in M by PM, pM and aM, respectively. Thus, for every constant a, we have aM = a. Let D0 be the set of all constants a, a ∈ ob(A). Without loss of generality we may assume that D0 6= ∅.\nWe construct an interpretation I for DL-LiteNbool based on some domain ∆I ⊇ D0 that will be inductively defined as the union\n∆I = ∞⋃ m=0 Wm, where W0 = D0.\nThe interpretations of the object names ai in I are given by their interpretations in M, namely, aIi = a M i ∈ W0. Each set Wm+1, for m ≥ 0, is constructed by adding to Wm some new elements that are fresh copies of certain elements from D \\D0. If such a new element w′ is a copy of w ∈ D \\D0 then we write cp(w′) = w, while for w ∈ D0 we let cp(w) = w. The set Wm \\Wm−1, for m ≥ 0, will be denoted by Vm (for convenience, let W−1 = ∅, so that V0 = D0).\nThe interpretations AIk of concept names Ak in I are defined by taking\nAIk = { w ∈ ∆I | M |= A∗k[cp(w)] } . (8)\nThe interpretation P Ik of a role name Pk in I will be defined inductively as the union\nP Ik = ∞⋃ m=0 Pmk , where P m k ⊆Wm ×Wm,\nalong with the construction of ∆I . First, for a role R ∈ role±(K), we define the required R-rank r(R, d) of a point d ∈ D by taking\nr(R, d) = max ( {0} ∪ { q ∈ QRT | M |= EqR[d] } ) .\nIt follows from (5) that if r(R, d) = q then, for every q′ ∈ QRT , we have M |= Eq′R[d] whenever q′ ≤ q, and M |= ¬Eq′R[d] whenever q < q′. We also define the actual R-rank rm(R,w) of a point w ∈ ∆I at step m by taking\nrm(R,w) = { ]{w′ ∈Wm | (w,w′) ∈ Pmk }, if R = Pk, ]{w′ ∈Wm | (w′, w) ∈ Pmk }, if R = P − k .\nFor the basis of induction we set, for each role name Pk ∈ role(K), P 0k = { (aMi , a M j ) ∈W0 ×W0 | M |= Pkaiaj } . (9)\nObserve that, by (6), for all R ∈ role±(K) and w ∈W0,\nr0(R,w) ≤ r(R, cp(w)). (10)\nSuppose now that Wm and the P m k , for m ≥ 0, have already been defined. If we had rm(R,w) = r(R, cp(w)), for all roles R ∈ role±(K) and points w ∈ Wm, then the interpretation I we need would be constructed. However, in general this is not the case because there may be some ‘defects’ in the sense that the actual rank of some points is smaller than the required rank.\nFor a role name Pk ∈ role(K), consider the following two sets of defects in Pmk : Λmk = { w ∈ Vm | rm(Pk, w) < r(Pk, cp(w)) } ,\nΛm−k = { w ∈ Vm | rm(P−k , w) < r(P − k , cp(w)) } .\nThe purpose of, say, Λmk is to identify those ‘defective’ points w ∈ Vm from which precisely r(Pk, cp(w)) distinct Pk-arrows should start (according to M), but some arrows are still missing (only rm(Pk, w) many arrows exist). To ‘cure’ these defects, we extend Wm and Pmk respectively to Wm+1 and P m+1 k according to the following rules: (Λmk ) Let w ∈ Λmk , q = r(Pk, cp(w)) − rm(Pk, w) and d = cp(w). We have M |= Eq′Pk[d] for some q′ ∈ QRT with q′ ≥ q > 0. Then, by (5), M |= E1Pk[d] and, by (4), M |= E1P−k [dp − k ]. In this case we take q fresh copies w ′ 1, . . . , w ′ q of dp − k (and set\ncp(w′i) = dp − k , for 1 ≤ i ≤ q), add them to Wm+1 and add the pairs (w,w ′ i), 1 ≤ i ≤ q, to Pm+1k .\n(Λm−k ) Let w ∈ Λ m− k , q = r(P − k , cp(w))− rm(P − k , w) and d = cp(w). Then M |= Eq′P − k [d]\nfor some q′ ∈ QRT with q′ ≥ q > 0. So, by (5), we have M |= E1P − k [d] and, by (4), M |= E1Pk[dpk]. Take q fresh copies w′1, . . . , w′q of dpk (and set cp(w′i) = dpk, for 1 ≤ i ≤ q), add them to Wm+1 and add the pairs (w′i, w), 1 ≤ i ≤ q, to P m+1 k .\nExample 5.3 Consider again the KBK and its first-order translationK† from Example 5.1. Consider also a model M of K† with the domain D = {a, a′, dp, dp−}, where\nAM = (E1P ) M = (E1P −)M = (E2P ) M = D, (E2P −)M = ∅, (Paa′)M = (P−a′a)M = t.\nWe begin the construction of the interpretation I of K by setting W0 = V0 = D0 = {a, a′} and P 0 = {(a, a′)}. Then we compute the required and actual ranks r(R,w) and r0(R,w), for R ∈ {P, P−} and w ∈ V0:\n(i) r(P, a) = 2 and r0(P, a) = 1, (ii) r(P, a ′) = 2 and r0(P, a ′) = 0, (iii) r(P−, a) = 1 and r0(P −, a) = 0, (iv) r(P−, a′) = 1 and r0(P −, a′) = 1.\nAt the next step, we draw a P -arrow from a to a fresh copy of dp− to cure defect (i), draw two P -arrows from a′ to two more fresh copies of dp− in order to cure defects (ii), and finally we take a fresh copy of dp and connect it to a by a P -arrow, thereby curing defect (iii).\nOne more step of this ‘unraveling’ construction is shown in Figure 4.\nObserve the following important property of the construction: for m,m0 ≥ 0, w ∈ Vm0 and R ∈ role±(K),\nrm(R,w) =  0, if m < m0,\nq, if m = m0, for some q ≤ r(R, cp(w)), r(R, cp(w)), if m > m0.\n(11)\n.\nTo prove this property, consider all possible cases:\n• If m < m0 then the point w has not been added to Wm yet, i.e., w /∈Wm, and so we have rm(R,w) = 0.\n• If m = m0 and m0 = 0 then rm(R,w) ≤ r(R, cp(w)) follows from (10).\n• If m = m0 and m0 > 0 then w was added at step m0 to cure a defect of some point w′ ∈ Wm0−1. This means that there is Pk ∈ role(K) such that either (w′, w) ∈ P m0 k\nand w′ ∈ Λm0−1k or (w,w ′) ∈ Pm0k and w ′ ∈ Λ(m0−1)−k . Consider the former case. We have cp(w) = dp−k . Since fresh witnesses are picked up every time the rule (Λ m0−1 k ) is applied, rm0(P − k , w) = 1, rm0(Pk, w) = 0 and rm0(R,w) = 0, for every R 6= Pk, P − k . So it suffices to show that r(P−k , dp − k ) ≥ 1. Indeed, as M |= EqPk[cp(w\n′)] for some q ∈ QRT , we have, by (5), M |= E1Pk[cp(w′)], and so, by (4), M |= E1P − k [dp − k ]. By the definition of r, we have r(P−k , dp − k ) ≥ 1. The latter case is considered analogously.\n• If m = m0 + 1 then, for each role name Pk, all defects of w are cured at step m0 + 1 by applying the rules (Λm0k ) and (Λ m0− k ). Therefore, rm0+1(R,w) = r(R, cp(w)).\n• If m > m0 +1 then (11) follows from the observation that new arrows involving w can only be added at step m0 + 1, that is, for all m ≥ 0 and each role name Pk ∈ role(K),\nPm+1k \\ P m k ⊆ Vm × Vm+1 ∪ Vm+1 × Vm. (12)\nIt follows that, for all R ∈ role±(K), q ∈ QRT and w ∈ ∆I , we have:\nM |= EqR[cp(w)] iff w ∈ (≥ q R)I . (13)\nIndeed, if M |= EqR[cp(w)] then, by definition, r(R, cp(w)) ≥ q. Let w ∈ Vm0 . Then, by (11), rm(R,w) = r(R, cp(w)) ≥ q, for all m > m0. It follows from the definition of\nrm(R,w) and R I that w ∈ (≥ q R)I . Conversely, let w ∈ (≥ q R)I and w ∈ Vm0 . Then, by (11), q ≤ rm(R,w) = r(R, cp(w)), for all m > m0. So, by the definition of r(R, cp(w)) and (5), M |= EqR[cp(w)].\nBy induction on the construction of concepts C in K one can readily see that, for every w ∈ ∆I , we have\nM |= C∗[cp(w)] iff w ∈ CI . (14)\nIndeed, the basis is trivial for B = ⊥ and follows from (8) for B = Ak and from (13) for B = ≥ q R, while the induction step for the Booleans (C = ¬C1 and C = C1 u C2) immediately follows from the induction hypothesis.\nFinally, we show that for each ψ ∈ T ∪ A,\nM |= ψ† iff I |= ψ.\nThe case ψ = C1 v C2 follows from (14); for ψ = Ak(ai) and ψ = ¬Ak(ai) from the definition of AIk . For ψ = Pk(ai, aj) and ψ = ¬Pk(ai, aj), we have (aIi , aIj ) ∈ P Ik iff, by (12), (aIi , a I j ) ∈ P 0k iff, by (9), M |= Pkaiaj .\nThus, we have established that I |= K. (⇒) Conversely, suppose that I |= K is an interpretation with domain ∆I . We construct a model M of K† based on the same ∆I . For every ai ∈ ob(A), we let aMi = aIi and, for every R ∈ role±(K), we take some d ∈ (≥ 1R)I if (≥ 1R)I 6= ∅ and an arbitrary element d ∈ ∆I otherwise, and let drM = d. Next, for every concept name Ak, we let AMk = AIk and, for every role R ∈ role±(K) and q ∈ QRT , we set EqRM = (≥ q R)I . Finally, for every role R ∈ role±(K) and every pair of objects ai, aj ∈ ob(A), we define (Raiaj)M to be true iff I |= R(ai, aj). One can readily check that M |= K†. Details are left to the reader. q\nThe first-order translation K† of K is obviously too lengthy to provide us with reasonably low complexity results: |K†| ≤ |K|+ (2+ q2T ) · |role(K)|+ 2 · |role(K)| · |ob(A)|qT . However, it follows from the proof above that a lot of information in this translation is redundant and can be safely omitted.\nNow we define a more concise translation K‡ of K = (T ,A) into QL1 by taking:\nK‡ = ∀x [ T ∗(x) ∧ ∧ R∈role±(K) ( εR(x) ∧ δR(x) )] ∧ A†1 ∧ A‡2 ,\nwhere T ∗(x), εR(x), δR(x) and A† 1\nare defined as before by means of (1), (4), (5) and (2), respectively, and\nA‡2 = ∧\na∈ob(A)\n∧ R∈role±(K)\n∃a′∈ob(A) R(a,a′)∈A\nEqR,aR(a) ∧ ∧\n¬Pk(ai,aj)∈A\n(¬Pk(ai, aj))⊥, (15)\nwhere qR,a is the maximum number in Q R T such that there are qR,a many distinct ai with R(a, ai) ∈ A (here we use the UNA) and (¬Pk(ai, aj))⊥ = ⊥ if Pk(ai, aj) ∈ A and > otherwise. Now both the size of A‡2 and the size of K‡ are linear in the size of A and K, respectively, no matter whether the numbers are coded in unary or in binary.\nMore importantly, the translation ·‡ can actually be done in LogSpace. Indeed, this is trivially the case for T ∗(x), εR(x), δR(x), A† 1 and the last conjunct of A‡2 . As for the first conjunct of A‡2 then, for R ∈ role±(K) and a ∈ ob(A), the maximum qR,a in QRT such that there are qR,a many distinct ai with R(a, ai) ∈ A, can be computed using log min(maxQRT , |ob(A)|) + log |ob(A)| cells. Initially we set q = 0, and then enumerate all object names ai in A incrementing the current q each time we find R(a, ai) ∈ A. We stop if q = maxQRT or we reach the end of the object name list. The resulting qR,a is the maximum number in QRT not exceeding q.\nExample 5.4 The translation K‡ of the KB K from Example 5.1 looks as follows:\nK‡ = ∀xχ(x) ∧ A(a) ∧ E1P (a) ∧ E1P−(a′),\nwhere χ(x) is defined by (7).\nCorollary 5.5 A DL-LiteNbool KB K is satisfiable iff the QL1-sentence K‡ is satisfiable.\nProof The claim follows from the fact that K† is satisfiable iff K‡ is satisfiable. Indeed, if M |= K† then clearly M |= K‡. Conversely, if M |= K‡ then one can construct a new model M′ based on the same domain D as M by taking:\n• AM′k = AMk , for all concept names Ak; • EqRM ′ = EqR M, for all R ∈ role±(K) and q ∈ QRT ; • (Raiaj)M ′ is true iff R(ai, aj) ∈ A;\n• aM′i = aMi , for all ai ∈ ob(A);\n• drM′ = drM, for all R ∈ role±(K).\nWe claim that M′ |= K†. Indeed, EqRM ′ = EqR M, for every R ∈ role±(K) and q ∈ QRT . It follows then that M′ |= ∀x T ∗(x) and M′ |= ∀x εR(x). By definition, M′ |= A† 1 , M′ |= A†2\nand M′ |= ∀x δR(x). It remains to show that M′ |= R†. Suppose M′ |= ∧q i=1Raaji , that is R(a, aji) ∈ A, for distinct aj1 , . . . , ajq , and q ∈ QRT . Clearly, we have q ≤ qR,a and M |= EqR(a) and thus M′ |= EqR(a). q\nAs an immediate consequence of Corollary 5.5, the facts that the translation ·‡ can be done in LogSpace, that the satisfiability problem for QL1-formulas is NP-complete and that DL-Litebool contains all the Booleans—and so can encode full propositional logic—we obtain the following result:\nTheorem 5.6 Satisfiability of DL-LiteNbool, DL-Lite F bool and DL-Litebool knowledge bases is NP-complete for combined complexity.\nObserve now that if K is a DL-LiteNkrom KB then K‡ is in the Krom fragment of QL1.\nTheorem 5.7 Satisfiability of DL-LiteNα , DL-Lite F α and DL-Liteα knowledge bases, where α ∈ {core, krom}, is NLogSpace-complete for combined complexity.\nProof As the satisfiability problem for Krom formulas with the prefix of the form ∀x (as in K‡) is NLogSpace-complete (see, e.g., Börger et al., 1997, Exercise 8.3.7) and ·‡ is a LogSpace reduction, satisfiability is in NLogSpace for all the logics mentioned in the theorem. As for the lower bound, it suffices to recall that the NLogSpace-hardness for satisfiability of propositional Krom formulas is proved by reduction of the directed graph reachability problem using only ‘core’ propositional formulas (Börger et al., 1997), and so satisfiability in all of the above logics is NLogSpace-hard. q\nIf K is a DL-LiteNhorn KB then K‡ belongs to the universal Horn fragment of QL1.\nTheorem 5.8 Satisfiability of DL-LiteNhorn, DL-Lite F horn and DL-Litehorn KBs is P-complete for combined complexity.\nProof As QL1 contains no function symbols and K‡ is universal, satisfiability of K‡ is LogSpace-reducible to satisfiability of a set of propositional Horn formulas, namely, the formulas that are obtained from K‡ by replacing x with each of the constants occurring in K‡. It remains to recall that the satisfiability problem for propositional Horn formulas is P-complete (see, e.g., Papadimitriou, 1994), which gives the required upper bound for DL-LiteNhorn and lower bound for DL-Litehorn. q\n5.2 DL-LiteHFcore is ExpTime-hard Unfortunately, the translation ·‡ constructed in the previous section cannot be extended to logics of the form DL-LiteHNα with both number restrictions and role inclusions. In this section we show that the satisfiability problem for DL-LiteHFcore KBs is ExpTime-hard, which matches the upper bound for satisfiability of DL-LiteHNbool KBs even under binary coding of natural numbers (Tobies, 2001).\nNote first that, although intersection is not allowed on the left-hand side of DL-LiteHFcore concept inclusions, in certain cases (when the right-hand side is consistent) we can ‘simulate’ it by using role inclusions and functionality constraints. Suppose that a knowledge base K contains a concept inclusion of the form C1 u C2 v C. Define a new KB K′ by replacing this axiom in K with the following set of new axioms, where R1, R2, R3, R12, R23 are fresh role names:\nC1 v ∃R1 C2 v ∃R2, (16) R1 v R12, R2 v R12, (17)\n≥ 2R12 v ⊥, (18) ∃R−1 v ∃R − 3 , (19)\n∃R3 v C, (20) R3 v R23, R2 v R23, (21) ≥ 2R−23 v ⊥. (22)\nLemma 5.9 (i) If I |= K′ then I |= K, for every interpretation I. (ii) If I |= K and CI 6= ∅ then there is a model I ′ of K′ which has the same domain as I and agrees with it on every symbol from K.\nProof (i) Suppose that I |= K′ and x ∈ CI1 ∩ CI2 . By (16), there is y with (x, y) ∈ RI1 , and so y ∈ (∃R−1 )I , and there is z with (x, z) ∈ RI2 . By (17), {(x, y), (x, z)} ⊆ RI12, whence y = z in view of (18). By (19), y ∈ (∃R−3 )I and hence there is u with (u, y) ∈ RI3 and u ∈ (∃R3)I . By (20), u ∈ CI . By (21), (u, y) ∈ RI23 and (x, y) ∈ RI23. Finally, it follows from (22) that u = x, and so x ∈ CI . Thus, I |= K.\n(ii) Take some point c ∈ CI and define an extension I ′ of I to the new role names by setting:\n• RI′1 = {(x, x) | x ∈ CI1 }, • RI′2 = {(x, x) | x ∈ CI2 }, • RI′3 = {(x, x) | x ∈ (C1 u C2)I} ∪ {(c, x) | x ∈ (C1 u ¬C2)I}, • RI′12 = RI ′ 1 ∪RI ′ 2 and R I′ 23 = R I′ 2 ∪RI ′ 3 .\nIt is readily seen that I ′ satisfies all the axioms (16)–(22), and so I ′ |= K′. q\nWe are now in a position to prove the following:\nTheorem 5.10 Satisfiability of DL-LiteHFcore KBs is ExpTime-hard for combined complexity (with or without the UNA).\nProof We will prove this theorem in two steps. First we consider the logic DL-LiteHFhorn and show how to encode the behavior of polynomial-space-bounded alternating Turing machines (ATMs, for short) by means of DL-LiteHFhorn KBs. As APSpace = ExpTime, where APSpace is the class of problems recognized by polynomial-space-bounded ATMs (see, e.g., Kozen, 2006), this will establish ExpTime-hardness of satisfiability for DL-LiteHFhorn. Then, using Lemma 5.9, we will show how to get rid of conjunctions on the left-hand side of the concept inclusions involved in this encoding of ATMs and thus establish ExpTime-hardness of DL-LiteHFcore.\nWithout loss of generality, we can consider only ATMs M with binary computational trees. This means that, for every non-halting state q and every symbol a from the tape alphabet, M has precisely two instructions of the form\n(q, a) ;0M (q ′, a′, d′) and (q, a) ;1M (q ′′, a′′, d′′), (23)\nwhere d′, d′′ ∈ {→,←} and → (resp., ←) means ‘move the head right (resp., left) one cell’. We remind the reader that each non-halting state ofM is either an and-state or an or-state.\nGiven such an ATMM, a polynomial function p(n) such that every run ofM on every input of length n does not use more than p(n) tape cells, and an input word ~a = a1, . . . , an, we construct a DL-LiteHFhorn knowledge base KM,~a with the following properties: (i) the size of KM,~a is polynomial in the size of M, ~a, and (ii) M accepts ~a iff KM,~a is not satisfiable. Denote by Q the set of states and by Σ the tape alphabet of M.\nTo encode the instructions of M, we need the following roles:\n• Sq, S0q , S1q , for each q ∈ Q: informally, x ∈ (∃S−q )I , for some interpretation I, means that x represents a configuration of M with the state q, and x ∈ (∃Skq )I means that the next state, according to the transition ;kM, is q, where k ∈ {0, 1};\n• Hi, H0i , H1i , for each i ≤ p(n): x ∈ (∃H − i ) I means that x represents a configuration of\nM where the head scans the ith cell, and x ∈ (∃Hki )I that, according to the transition ;kM, k ∈ {0, 1}, in the next configuration the head scans the ith cell; • Cia, C0ia, C1ia, for each i ≤ p(n) and each a ∈ Σ: x ∈ (∃C − ia) I means that x represents\na configuration of M where the ith cell contains a, and x ∈ (∃Ckia)I that, according to ;kM, k ∈ {0, 1}, in the next configuration the ith cell contains a.\nThis intended meaning can be encoded using the following concept inclusions: for every instruction (q, a) ;kM (q ′, a′,→) of M and every i < p(n),\n∃S−q u ∃H−i u ∃C − ia v ∃H k i+1 u ∃Skq′ u ∃Ckia′ , (24)\nand for every instruction (q, a) ;kM (q ′, a′,←) of M and every i, 1 < i ≤ p(n),\n∃S−q u ∃H−i u ∃C − ia v ∃H k i−1 u ∃Skq′ u ∃Ckia′ . (25)\nTo preserve the symbols on the tape that are not in the active cell, we use the following concept inclusions, for k ∈ {0, 1}, i, j ≤ p(n) with j 6= i, and a ∈ Σ:\n∃H−j u ∃C − ia v ∃C k ia. (26)\nTo ‘synchronize’ our roles, we need two more (functional) roles Tk and a number of role inclusions to be added to the TBox: for all k ∈ {0, 1}, i ≤ p(n), q ∈ Q, and a ∈ Σ,\nCkia v Cia, Hki v Hi, Skq v Sq, (27) Ckia v Tk, Hki v Tk, Skq v Tk, (28) ≥ 2Tk v ⊥. (29)\nIt remains to encode the acceptance conditions forM on ~a. This can be done with the help of the role names Yk, for k ∈ {0, 1}, and the concept name A:\n∃S−q v A, q an accepting state, (30) Yk v Tk, (31) ≥ 2T−k v ⊥, (32) ∃T−k uA v ∃Y − k , (33) ∃S−q u ∃Yk v A, q an or-state, (34) ∃S−q u ∃Y0 u ∃Y1 v A, q an and-state. (35)\nThe TBox T of the DL-LiteHFhorn knowledge base KM,~a we are constructing consists of the axioms (24)–(35) together with the auxiliary axiom\nA uD v ⊥, (36)\nwhere D is a fresh concept name. The ABox A of KM,~a is comprised of the following assertions, for some object names s and u:\nSq0(u, s), q0 the initial state, (37) H1(u, s), (38) Ciai(u, s), i ≤ p(n), ai the ith symbol on the input tape, (39) D(s). (40)\nClearly, KM,~a = (T ,A) is a DL-LiteHFhorn KB and its size is polynomial in the size of M, ~a.\nLemma 5.11 The ATM M accepts ~a iff the KB KM,~a is not satisfiable.\nProof (⇒) Suppose that M accepts ~a but I |= KM,~a for some interpretation I. Then we can reconstruct the full computation tree for M on ~a by induction in the following way.\nLet the root of the tree be the point sI . By (37)–(39), s represents the initial configuration of M on ~a in accordance with the intended meaning of the roles Sq0 , H1 and Ciai explained above (it does not matter if, for instance, we also have sI ∈ (∃H−5 )I).\nAssume now that we have already found a point x ∈ ∆I representing some configuration\nc = b1, . . . , bi−1, (q, bi), bi+1, . . . , bp(n), (41)\nwhere q is the current non-halting state and the head scans the ith cell containing bi. This means that we have\nx ∈ (∃S−q )I ∩ (∃H−i ) I and x ∈ (∃C−jbj ) I , for all j ≤ p(n).\nAssume also that M contains two instructions of the form (23) for (q, bi), that is q is nonhalting. If we have (q, bi) ; k M (q\n′, b′,→), for k = 0 or 1, then, by (24) and (26), there are points ys, yh and yj , for j ≤ p(n), in ∆I such that\n(x, ys) ∈ (Skq′)I , (x, yh) ∈ (Hki+1)I , (x, yi) ∈ (Ckib′)I , (x, yj) ∈ (Ckjbj ) I , for j 6= i.\nBy (28)–(29), S0q′ , H 0 i+1, C 0 ib′i and the C0jbj , j 6= i, are all sub-roles of the functional role Tk, and so all the points ys, yh and yj coincide; we denote this point by xk. By (27), we then have:\n(x, xk) ∈ T Ik , xk ∈ (∃S−q′ ) I ∩ (∃H−i+1) I ∩ (∃C−ib′) I and xk ∈ (∃C−jbj ) I , for j 6= i.\nSimilarly, if we have (q, bi) ; k M (q ′′, b′′,←), for k = 0 or 1, then, by (25) and (26), there is a point xk ∈ ∆I such that\n(x, xk) ∈ T Ik , xk ∈ (∃S−q′′) I ∩ (∃H−i−1) I ∩ (∃C−ib′′) I and xk ∈ (∃C−jbj ) I , for j 6= i.\nThus, for k = 0, 1, xk is a Tk-successor of x representing the configuration ck of M after it has executed (q, bi) ; k M (q\n′′, b′′, d) in c; in this case ck is called the k-successor of c. According to (30), every point in the constructed computation tree for M on ~a representing a configuration with an accepting state is in AI . Suppose now, inductively, that x represents some configuration c of the form (41), q is an or-state, xk represents the ksuccessor of c and (x, xk) ∈ T Ik , for k = 0, 1, and one of the xk, say x0, is in AI . In view of (33), we have x0 ∈ (∃Y −0 )I . As T − 0 is functional by (32) and Y0 is a sub-role of T0 by (31), (x, x0) ∈ Y I0 , and so, by (34), x ∈ AI . The case of x being an and-state is considered analogously with the help of (35).\nSince M accepts ~a, we then conclude that sI ∈ AI , contrary to (36) and (40). (⇐) Conversely, suppose now thatM does not accept ~a. Consider the full computation tree (∆, <0 ∪ <1) with nodes labeled with configurations ofM in such a way that the root is labeled with the initial configuration\n(q0, a1), a2, . . . , an, an+1, . . . , ap(n),\n(where the ai, for n+1 ≤ i ≤ p(n), are all ‘blank’), and if some node x in the tree is labeled with a non-halting c of the form (41) andM contains two instructions of the form (23), then x has one <0-successor labeled with the 0-successor of c and one <1-successor labeled with the 1-successor of c. (It should be emphasized that (∆, <0 ∪ <1) is a tree, where different nodes may be labeled with the same configuration.)\nWe use this tree to construct an interpretation I = (∆I , ·I) as follows:\n• ∆I = ∆ ∪ {u}, for some u /∈ ∆;\n• sI is the root of ∆ and uI = u;\n• DI = {sI};\n• (x, xk) ∈ (Skq′)I , (x, xk) ∈ (Hki+1)I , (x, xk) ∈ (Ckib′)I , and (x, xk) ∈ (Ckjbj ) I , for j 6= i,\niff x is labeled with c of the form (41), (q, bi) ; k M (q ′, b′,→) and x <k xk, for k = 0, 1;\n• (x, xk) ∈ (Skq′)I , (x, xk) ∈ (Hki−1)I , (x, xk) ∈ (Ckib′)I , and (x, xk) ∈ (Ckjbj ) I , for j 6= i,\niff x is labeled with c of the form (41), (q, bi) ; k M (q ′, b′,←) and x <k xk, for k = 0, 1;\n• (u, sI) ∈ (Sq0)I , (u, sI) ∈ (H1)I , (u, sI) ∈ (Ciai)I , i ≤ p(n) and over ∆ the extensions for the roles Sq, Hi and Cia are defined according to (27);\n• T Ik = <k, for k = 0, 1;\n• Y I0 , Y I1 and AI are defined inductively:\n– Induction basis: if x ∈ ∆ is labeled with an accepting configuration, then x ∈ AI . – Induction step: (i) if x <k xk, for k = 0, 1, and xk ∈ AI , then (x, xk) ∈ Y Ik ; (ii) if x is an or-state (respectively, and-state) and (x, xk) ∈ Y Ik for some (respectively, all) k ∈ {0, 1}, then x ∈ AI .\nIt follows from the given definition that I |= KM,~a. Details are left to the reader. q\nThe lemma we have just proved establishes that satisfiability of DL-LiteHFhorn KBs is ExpTime-hard. Our next aim is to show how one can eliminate the conjunctions in the left-hand side of the TBox axioms (24)–(26), (33)–(35). We will do this with the help of Lemma 5.9. Before applying it, we check first that if KM,~a is satisfiable then it is satisfiable in an interpretation I such that I |= KM,~a and CI 6= ∅, for every C occurring in an axiom of the form C1 u C2 v C in K. Consider, for instance, axiom (24) and assume that I |= KM,~a, but (∃Skq′)I = ∅. Then, we can construct a new interpretation I ′ by adding two new points, say x and y, to the domain of I, and setting (x, y) ∈ (Skq′)I ′ , (x, y) ∈ (Sq′)I ′ , (x, y) ∈ (Tk)I ′ . Furthermore, if q′ is an accepting state, we also set y ∈ AI′ and (x, y) ∈ Y I′k . One can readily check that I ′ is still a model for KM,~a. The other conjuncts of (24) and the remaining axioms are considered analogously.\nAfter an application of Lemma 5.9 to an axiom of the form C1uC2 v C with C2 = C ′2uC ′′2 we obtain, by (16)–(22), a new KB K′ with the concept inclusion of the form C ′2uC ′′2 v ∃R1, which also requires treatment by means of the same lemma. To be able to do this, we again\nhave to check that K′ is satisfiable in some interpretation I ′′ with (∃R1)I ′′ 6= ∅. Suppose that I ′ |= K′ and (∃R1)I ′\n= ∅. Then we can construct I ′′ by adding two new points, say x and y, to the domain of I ′, adding x to CI′ and (x, y) to each of RI′1 , RI ′ 12, R I′ 23 and R I′ 3 . It is readily seen that I ′′ |= K′. It is to be noted that the proof above does not depend on whether the UNA is adopted or not. q\nAs an immediate consequence we obtain:\nCorollary 5.12 Satisfiability of DL-LiteHFα and DL-Lite HN α KBs with or without the UNA is ExpTime-complete for combined complexity, where α ∈ {core, krom, horn, bool}."
    }, {
      "heading" : "5.3 Reconciling Number Restrictions and Role Inclusions",
      "text" : "As we have seen in the previous section, the unrestricted interaction between number restrictions and role inclusions allowed in the logics of the form DL-LiteHNα results in high combined complexity of satisfiability. In Section 6.2, we shall see that the data complexity of instance checking and query answering also becomes unacceptably high for these logics. A quick look at the proof of Theorem 5.10 reveals the ‘culprit:’ the interplay between role inclusions R1 v R, R2 v R and functionality constraints ≥2R v ⊥, which effectively mean that if R1(x, y) and R2(x, z) then y = z. In this section we study the case when such an interplay is not allowed.\nRecall from Section 2.1 that DL-Lite (HN ) α TBoxes T , for α ∈ {core, krom, horn, bool},\nsatisfy the following conditions:\n(A1) T may contain only positive occurrences of qualified number restrictions ≥ q R.C, where C is a conjunction of concepts allowed on the right-hand side of α-concept inclusions;\n(A2) if ≥ q R.C occurs in T , then T does not contain negative occurrences of number restrictions ≥ q′R or ≥ q′ inv(R) with q′ ≥ 2;\n(A3) if R has a proper sub-role in T , then T does not contain negative occurrences of ≥ q R or ≥ q inv(R) with q ≥ 2.\nDL-Lite (HN ) α TBoxes can contain role constraints such as Dis(R1, R2), Asym(Pk), Sym(Pk), Irr(Pk), and Ref(Pk). Our main aim in this section is to prove the following theorem and develop the technical tools we need to investigate the data complexity of reasoning with DL-Lite (HN ) bool and its sublogics later on in the paper.\nTheorem 5.13 For combined complexity, (i) satisfiability of DL-Lite (HN ) bool KBs is NPcomplete; (ii) satisfiability of DL-Lite (HN ) horn KBs is P-complete; and (iii) satisfiability of DL-Lite (HN ) krom and DL-Lite (HN ) core KBs is NLogSpace-complete.\nLet us consider first the sub-language of DL-Lite (HN ) bool without qualified number restrictions and the role constraints mentioned above; we denote it by DL-Lite (HN )− bool . This sublanguage is required for purely technical reasons. In Section 7, we will also use DL-Lite (HN )− horn , but we do not need the core or Krom fragments.\nSuppose we are given a DL-Lite (HN )− bool KB K = (T ,A). Let Id be a distinguished role name. We will use it to simulate the identity relation required for encoding the role constraints. We assume that either K does not contain Id at all or satisfies the following conditions:\n(Id1) Id(ai, aj) ∈ A iff i = j, for all ai, aj ∈ ob(A),\n(Id2) { > v ∃Id, Id− v Id } ⊆ T , and QIdT = QId − T = {1},\n(Id3) Id is only allowed in role inclusions of the form Id − v Id and Id v R.\nIn what follows, without loss of generality, we will assume that\n(Q) QRT ⊆ QR ′ T whenever R v∗T R′ (for if this is not the case we can always add the missing numbers to QR ′ T , e.g., by introducing fictitious concept inclusions of the form ⊥ v ≥ q R′). Now, in the same way as in Section 5.1, we define two translations ·†e and ·‡e of K into the one-variable fragment QL1 of first-order logic. The former translation, ·†e , retains the information about the relationships between ABox objects, and we show that every model of K†e can again be ‘unraveled’ into a model of K. We define ·†e by taking:\nK†e = ∀x [ T ∗(x) ∧ T R(x) ∧ ∧ R∈role±(K) ( εR(x) ∧ δR(x) ) ] ∧\n[ A†1 ∧ A†2 ∧ ∧ R∈role±(K) R† ∧ ∧\nRvR′∈T ai,aj∈ob(A)\n( Raiaj → R′aiaj )] ,\nwhere T ∗(x), A†1 , A†2 , εR(x), δR(x) and R† are as in (1)–(6) and\nT R(x) = ∧\nRvR′∈T or inv(R)vinv(R′)∈T\n∧ q∈QRT ( EqR(x)→ EqR′(x) ) . (42)\nThe following lemma is an analogue of Theorem 5.2:\nLemma 5.14 A DL-Lite (HN )− bool KB K is satisfiable iff the QL 1-sentence K†e is satisfiable.\nProof The proof basically follows the lines of the proof of Theorem 5.2 with some modifications. We present a modified unraveling construction here; the converse direction is exactly the same as in Theorem 5.2.\nIn each equivalence class [Ri] = {Rj | Ri ≡∗T Rj} we select a single role (a representative of that class) and denote it by rep∗T (Ri). When extending P m k to P m+1 k , we use the following modified ‘curing’ rules:\n(Λmk ) If Pk 6= rep∗T (Pk) do nothing: the defects are cured for rep∗T (Pk). Otherwise, let w ∈ Λmk , q = r(Pk, cp(w)) − rm(Pk, w) and d = cp(w). We have M |= Eq′Pk[d] for some q′ ≥ q > 0. Then, by (5), M |= E1Pk[d] and, by (4), M |= E1P−k [dp − k ]. In this\ncase we take q fresh copies w′1, . . . , w ′ q of dp − k (and set cp(w ′ i) = dp − k , for 1 ≤ i ≤ q), add them to Wm+1 and\n• add the pairs (w,w′i), 1 ≤ i ≤ q, to each P m+1 j with Pk v∗T Pj (including\nPj = Pk);\n• add the pairs (w′i, w), 1 ≤ i ≤ q, to each P m+1 j with P − k v ∗ T Pj ; • if Id occurs in K, add the pairs (w′i, w′i), 1 ≤ i ≤ q, to each P m+1 j with Id v∗T Pj .\n(Λm−k ) This rule is the mirror image of (Λ m k ): Pk and dp − k are replaced everywhere with\nP−k and dpk, respectively; see the proof of Theorem 5.2.\nIt follows from this definition that Id never has any defects and is interpreted in the resulting interpretation I by the identity relation IdI = { (w,w) | w ∈ ∆I } ; the interpretations of roles respect all the role inclusions, i.e., RI1 ⊆ RI2 whenever R1 v∗T R2. It remains to show that the constructed interpretation I is indeed a model of K. First, (11) trivially holds for Id as both the required and actual ranks are equal to 1. Second, (11) holds for R such that R 6= Id and R has no proper sub-roles: the proof is exactly the same as in Theorem 5.2, taking into account that we cure defects only for a single role in each equivalence class and that, by (42), for all R′ ∈ [R], we have r(R′, cp(w)) = r(R, cp(w)) and r(inv(R), cp(w)) = r(inv(R′), cp(w)). It follows that (13) holds for Id and any role R without proper sub-roles. However, (13) does not necessarily hold for roles R with proper sub-roles: as follows from the construction, the actual rank may be greater than the required rank, in which case we only have the following:\nif M |= EqR[cp(w)] then w ∈ (≥ q R)I .\nHowever, this is enough for our purposes. By induction on the structure of concepts and using (A3), one can show that I |= C1 v C2 whenever M |= ∀x (C∗1 (x)→ C∗2 (x)), for each concept inclusion C1 v C2 ∈ T , and therefore, I |= T . We also have I |= A (see the proof of Theorem 5.2) and thus I |= K. q\nRemark 5.15 It follows from the proofs of Theorem 5.2 and Lemma 5.14 that, for the DL-Lite (HN )− bool KB K = (T ,A), every model M of K\n‡e induces a model IM of K with the following properties:\n(ABox) For all ai, aj ∈ ob(A), we have (aIMi , a IM j ) ∈ RIM iff R(ai, aj) ∈ Cl e T (A), where\nCleT (A) = { R2(ai, aj) | R1(ai, aj) ∈ A, R1 v∗T R2 } .\n(forest) The object names a ∈ ob(A) induce a partitioning of ∆IM into disjoint labeled trees Ta = (Ta, Ea, `a) with nodes Ta, edges Ea, root a\nIM , and a labeling function `a : Ea → role±(K) \\ {Id, Id−}.\n(copy) There is a function cp : ∆IM → ob(A) ∪ dr(K) such that\n• cp(aIM) = a for a ∈ ob(A), and • cp(w) = dr if, for some a and w′ ∈ Ta, (w′, w) ∈ Ea and `a(w′, w) = inv(R).\n(iso) For each R ∈ role±(K), all labeled subtrees generated by elements w ∈ ∆IM with cp(w) = dr are isomorphic.\n(concept) w ∈ BIM iff M |= B∗[cp(w)], for each basic concept B in K and each w ∈ ∆IM .\n(role) IdIM = { (w,w) ∣∣ w ∈ ∆IM} and, for every other role name Pk,\nP IMk = { (aIMi , a IM j ) | R(ai, aj) ∈ A, R v ∗ T Pk } ∪ { (w,w) | Id v∗T Pk } ∪⋃\na∈ob(A)\n{ (w,w′) ∈ Ea | `a(w,w′) = R, R v∗T Pk } .\nSuch a model will be called an untangled model of K (the untangled model of K induced by M, to be more precise).\nThe translation ·†e generalizes ·† and thus suffers from the same exponential blowup. So we define an optimized translation, ·‡e , which is linear in the size of K, by taking:\nK‡e = ∀x [ T ∗(x) ∧ T R(x) ∧ ∧ R∈role±(K) ( εR(x) ∧ δR(x) ) ] ∧ A†1 ∧ A‡2e ,\nwhere T ∗(x), T R(x), εR(x), δR(x) and A† 1\nare defined by (1), (42), (4), (5) and (2), respectively, and\nA‡2e = ∧\na∈ob(A)\n∧ R∈role±(K)\n∃a′∈ob(A) R(a,a′)∈CleT (A)\nEqeR,aR(a) ∧ ∧\n¬Pk(ai,aj)∈A\n(¬Pk(ai, aj))⊥e , (43)\nwhere qeR,a is the maximum number in Q R T such that there are q e R,a many distinct ai with R(a, ai) ∈ CleT (A) (here we use the UNA) and (¬Pk(ai, aj))⊥e = ⊥ if Pk(ai, aj) ∈ CleT (A) and > otherwise; cf. (15). We note again that if QRT = {1}, for all roles R ∈ role\n±(K), then the translation does not depend on whether the UNA is adopted or not.\nThe following corollary is proved similarly to Corollary 5.5:\nCorollary 5.16 A DL-Lite (HN )− bool KB K is satisfiable iff the QL 1-sentence K‡e is satisfiable.\nIt should be clear that the translation ·‡e can be computed in NLogSpace (for combined complexity). Indeed, this is readily seen for T ∗(x), T R(x), εR(x), δR(x), and A† 1 . In order to compute A‡2e , we need to be able to check whether R(ai, aj) ∈ CleT (A): this test can be performed by a non-deterministic algorithm using logarithmic space in |role±(K)| (it is basically the same as the standard directed graph reachability problem, which is NLogSpace-complete; see, e.g., Kozen, 2006); it can be done using N · log |role±(K)| + 2 log |ob(A)| cells on the work tape, where N is a constant (in fact, N = 3 is enough: one\nhas to store R, the current role R′ and the path length for the graph reachability subroutine, which is also bounded by log |role±(K)|). Therefore, the translation ·‡e can be computed by an NLogSpace transducer.\nNow we show how satisfiability of DL-Lite (HN ) bool KBs can be easily reduced to satisfiability\nof DL-Lite (HN )− bool KBs. First, we assume that DL-Lite (HN ) bool KBs contain no role symmetry and asymmetry constraints because Asym(Pk) can be equivalently replaced with Dis(Pk, P − k ) and Sym(Pk) with P − k v Pk (it should be noted that the introduction of P − k v Pk in the TBox does not violate (A3)). The following lemma allows us to get rid of qualified number restrictions as well as role disjointness, reflexivity and irreflexivity constraints:\nLemma 5.17 For every DL-Lite (HN ) bool KB K ′ = (T ′,A′), one can construct a DL-Lite(HN ) − bool KB K = (T ,A) such that\n• every untangled model IM of K is a model of K′, provided that\nthere are no R1(ai, aj), R2(ai, aj) ∈ CleT (A) with Dis(R1, R2) ∈ T ′, there is no R(ai, ai) ∈ CleT (A) with Irr(R) ∈ T ′;\n(44)\n• every model I ′ of K′ gives rise to a model I of K based on the same domain as I ′ and such that I agrees with I ′ on all symbols from K′.\nIf K′ is a DL-Lite(HN )horn KB then K is a DL-Lite (HN )− horn KB. Proof First, for every pair R, C such that ≥ q R.C occurs in T ′, we introduce a fresh role name RC . Then we replace each (positive) occurrence of ≥ q R.C in T ′ with ≥ q RC and add the following concept and role inclusions to the TBox:\n∃R−C v C and RC v R.\nWe repeat this procedure until all the occurrences of qualified number restrictions are eliminated. Denote by T ′′ the resulting TBox. Observe that (A1) and (A2) ensure that T ′′ satisfies (A3). We also notice that C occurs only on the right-hand side of those extra axioms and thus T ′′ belongs to the same fragment as T ′. It should be clear that, since the ≥ q R.C occur only positively, every model of T ′′ is a model of T ′. Conversely, for every model I ′ of T ′, there is a model I ′′ of T ′′ based on the same domain such that I ′′ coincides with I ′ on all symbols in T ′ and RI′′C = {(w, u) ∈ RI\n′ | u ∈ CI′}, for each new role RC . So, without loss of generality we may assume that T ′ = T ′′.\nLet T ′ = T ′0 ∪ T ′ref ∪ T ′irref ∪ T ′disj,\nwhere T ′ref, T ′irref and T ′disj are the sets of role reflexivity, irreflexivity and disjointness constraints in T ′ and T ′0 is the remaining DL-Lite (HN )− bool TBox. Let\nT ′1 = { > v ∃Id, Id− v Id } ∪ { Id v P | Ref(P ) ∈ T ′ref } ,\nA′1 = { Id(ai, ai) | ai ∈ ob(A′) } .\nWe construct K by modifying the DL-Lite(HN ) −\nbool KB K0 = (T ′ 0 ∪ T ′1 ,A′ ∪ A′1) in two steps: Step 1. For every reflexivity constraint Ref(P ) ∈ T ′ref, take a fresh role name SP and\n• add a new role inclusion SP v P to the TBox;\n• replace every basic concept B in T ′0 with BSP , which is defined inductively as follows:\n– ASP = A, for each concept name A, – (≥ q R)SP = ≥ q R, for each role R /∈ {P, P−}, – (≥ q P )SP = ≥ (q − 1)SP and (≥ q P−)SP = ≥ (q − 1)S−P , for q ≥ 2, – (∃P )SP = > and (∃P−)SP = >;\n• replace R(ai, aj) ∈ A′ such that R ≡∗T ′ P with SP (ai, aj) whenever i 6= j.\nIntuitively, we split the role P into its irreflexive part SP and Id. Note that if P has a reflexive proper sub-role then, by (A3), there are no restrictions on the maximal number of P -successors and P -predecessors, and therefore on SP if Ref(P ) ∈ T ′. Let (T1,A) be the resulting DL-Lite\n(HN )− bool KB. Clearly, (T1,A) satisfies (Id1)–(Id3). Observe that\nCleT1(A) role(K′) = Cl e T ′0∪T ′1 (A′), (45)\nwhere role(K′) means the restriction to the role names in K′. Let IM be an untangled model of (T1,A). We show that IM |= T ′0 . Consider a role P with Ref(P ) ∈ T ′. Notice that SP has no proper sub-roles in T1 and IdIM is disjoint with SIMP . Thus, S IM P ∪ Id IM ⊆ P IM and\n(*) (BSP )IM ⊆ BIM , for B = ≥ q R with q ≥ 2, whenever Ref(P ) ∈ T ′, R ∈ {P, P−} and P has a proper sub-role in T ′.\nIf P has no proper sub-roles in T ′ (i.e., no proper sub-roles in T1 different from SP and Id) then we have SIMP ∪ Id\nIM = P IM . So, for all basic concepts B in T ′0 not covered by (*), we have BIM = (BSP )IM . It follows from (A3) that IM |= T ′0 . Step 2. Next we take into account the set D = T ′disj ∪ {Dis(Pk, Id) | Irr(Pk) ∈ T ′irref} of disjointness constraints by modifying the KB (T1,A) constructed at the previous step. Observe that ∃R1 v ⊥ is a logical consequence of any T ∪{Dis(R1, R2)} whenever R1 v∗T R2. Let T = T1 ∪ T2, where T2 is defined by taking\nT2 = { ∃R1 v ⊥ ∣∣ R1 v∗T1 R2 and either Dis(R1, R2) ∈ D or Dis(R2, R1) ∈ D}. By (role), for any untangled model IM of (T ,A) and R1, R2 ∈ role±(K), IM |= Dis(R1, R2) if there are no R1(ai, aj), R2(ai, aj) ∈ CleT1(A), which, by (45), means that there are no R1(ai, aj), R2(ai, aj) ∈ CleT ′0∪T ′1 (A\n′). So, if (44) holds then every untangled model IM of (T ,A) is also a model of T1 ∪ D and thus, IM |= T ′disj. As Id\nIM is the identity relation, we have IM |= T ′ref ∪ T ′irref. By (45), IM |= A′ and as we have shown above, IM |= T ′0 . Therefore, IM |= K′.\nConversely, suppose I ′ is a model of K′. Let I be an interpretation such that IdI is the identity relation, SIP = P\nI′ \\ IdI′ , for all P with Ref(P ) ∈ T ′, and AI = AI′ , P I = P I ′ and aI = aI ′ , for all concept, role and object names A, P and a in K′. Clearly, I |= (T ′0 ∪ T ′1 ,A′ ∪ A′1). By the definition of the SP , I |= T1 and, since I |= D, we obtain I |= T2 and thus I |= T . By (45), I |= A, whence I |= K. q\nNow, as follows from Lemma 5.17, given a DL-Lite (HN ) α KB K′, for α ∈ {krom, horn,\nbool}, we can compute the DL-Lite(HN ) −\nbool KB K using a LogSpace transducer (which is essentially required for checking whether R ≡∗T ′ P ). We immediately obtain Theorem 5.13 from Lemma 5.14 by observing that, for each α ∈ {krom, horn, bool}, K‡e belongs to the respective first-order fragment and that condition (44) can be checked in NLogSpace (computing CleT (A) requires directed graph accessibility checks). The result for DL-Lite (HN ) core follows from the corresponding result for DL-Lite (HN ) krom ."
    }, {
      "heading" : "5.4 Role Transitivity Constraints",
      "text" : "We now consider the languages DL-Lite (HN )+ α , α ∈ {core, krom, horn, bool}, which extend DL-Lite (HN ) α with role transitivity constraints of the form Tra(Pk). We remind the reader that a role is called simple (see, e.g., Horrocks et al., 2000) if it has no transitive sub-roles (including itself) and that only simple roles R are allowed in concepts of the form ≥ q R, for q ≥ 2. In particular, if T contains Tra(P ) then P and P− are not simple, and so T cannot contain occurrences of concepts of the form ≥ q P and ≥ q P−, for q ≥ 2.\nFor a DL-Lite (HN )+ α KB K = (T ,A), define the transitive closure TraT (A) of A by\ntaking TraT (A) = A ∪ { P (ai1 , ain) | ∃ai2 . . . ain−1 P (ai1 , aij+1) ∈ A, 1 ≤ j < n, Tra(P ) ∈ T } .\nClearly, TraT (A) can be computed in NLogSpace: for each pair (ai, aj) of objects in ob(A), we add P (ai, aj) to TraT (A) iff there is a P -path of length < |ob(A)| between ai and aj in A (recall that the directed graph reachability problem is NLogSpace-complete).\nLemma 5.18 A DL-Lite (HN )+ α KB (T ,A) is satisfiable iff the DL-Lite(HN )α KB (T ′,A′) is satisfiable, where T ′ results from T by removing all the transitivity axioms and\nA′ = CleT (TraT (CleT (A))).\nProof Indeed, if the KB (T ′,A′) is satisfiable then we construct a model I for it as described in the proofs of Lemmas 5.14 and 5.17 and then take the transitive closure of P I for every P with Tra(P ) ∈ T (and update each RI with P v∗T R). As P and P− are simple, T contains no axioms imposing upper bounds on the number of P -successors and predecessors, and so the resulting interpretation must be a model of (T ,A). The converse direction is trivial. q\nWe note that an analogue of Remark 5.15 also holds in this case: just replace CleT (A) with CleT (TraT (Cl e T (A))) in (ABox) and take the transitive closure for each transitive subrole in (role).\nRemark 5.19 It should be noted that there are two different reasons for the reduction in Lemma 5.18 to be in NLogSpace rather than in LogSpace (as the reduction ·‡ is). First, in order to compute CleT (A), for each pair of ai, aj , one has to find a path in the directed graph induced by the role inclusion axioms. Second, in order to compute TraT (Cl e T (A)), one has to find a path in the graph induced by the ABox A itself. So, if we are concerned with the data complexity, CleT (A) can be computed in LogSpace (in fact, in AC0, as we shall\nsee in Section 6.1) because the role inclusion graph (and hence its size) does not depend on A. The second reason, however, is more ‘dangerous’ for data complexity as we shall see in Section 6.1.\nAs a consequence of Lemma 5.18 and Theorem 5.13 we obtain the following:\nCorollary 5.20 For combined complexity, (i) satisfiability of DL-Lite (HN )+ bool KBs is NPcomplete; (ii) satisfiability of DL-Lite (HN )+ horn KBs is P-complete; and (iii) satisfiability of DL-Lite (HN )+ krom and DL-Lite (HN )+ core KBs is NLogSpace-complete.\nNote again that if the KBs do not contain number restrictions of the form ≥q R, for q ≥ 2, (as in the extensions of the DL-LiteHα languages) then the result does not depend on the UNA.\nRemark 5.21 It should be noted that role disjointness, symmetry, asymmetry and transitivity constraints can be added to any of the logics DL-LiteHFα and DL-Lite HN α , for α ∈ {core, krom, horn, bool}, without changing the combined complexity of their satisfiability problems (which, by Corollary 5.12, are all ExpTime-complete). Indeed, as follows from Theorem 10 of Glimm et al. (2007), KB satisfiability in the extension of SHIQ with role conjunction is in ExpTime if the length of role conjunctions is bounded by some constant (in our case, this constant is 2 because Dis(R1, R2) can be encoded by ∃(R1 u R2).> v ⊥; Asym(R) is dealt with similarly). We conjecture that role reflexivity and irreflexivity constraints do not change complexity either."
    }, {
      "heading" : "6. Instance Checking: Data Complexity",
      "text" : "So far we have assumed the whole KB K = (T ,A) to be the input for the satisfiability problem. According to the classification suggested by Vardi (1982), we have been considering its combined complexity. Two other types of complexity for knowledge bases are:\n• the schema (or TBox ) complexity, where only the TBox T is regarded to be the input, while the ABox A is assumed to be fixed; and\n• the data (or ABox ) complexity, where only the ABox A is regarded to be the input.\nIt is easy to see that the schema complexity of the satisfiability problem for all our logics considered above coincides with the corresponding combined complexity. In this section, we analyze the data complexity of satisfiability and instance checking.\n6.1 DL-LiteNbool, DL-Lite H bool and DL-Lite (HN ) bool are in AC 0\nIn what follows, without loss of generality we assume that all role and concept names of a given knowledge base K = (T ,A) occur in its TBox and write role(T ), role±(T ) and dr(T ) instead of role(K), role±(K) and dr(K), respectively; the set of concept names in T is denoted by con(T ). In this section we reduce satisfiability of DL-Lite(HN )bool KBs to model checking in first-order logic. To this end, we fix a signature containing two unary predicates Ak and Ak, for each concept name Ak, and two binary predicates Pk and Pk, for each role name Pk.\nConsider first the case of a DL-Lite (HN )− bool KB K. We represent the ABox A of K as a first-order model AA of the above signature. The domain of AA is ob(A) and, for all ai, aj ∈ ob(A) and all predicates Ak, Ak, Pk and Pk in the signature,\nAA |= Ak[ai] iff Ak(ai) ∈ A, AA |= Ak[ai] iff ¬Ak(ai) ∈ A, AA |= Pk[ai, aj ] iff Pk(ai, aj) ∈ A, AA |= Pk[ai, aj ] iff ¬Pk(ai, aj) ∈ A.\nNow we construct a first-order sentence ϕT in the same signature such that (i) ϕT depends on T but does not depend on A, and (ii) AA |= ϕT iff K‡e is satisfiable.\nTo simplify presentation, we denote by ext(T ) the extension of T with the following concept inclusions:\n• ≥ q′R v ≥ q R, for all R ∈ role±(T ) and q, q′ ∈ QRT such that q′ > q and q′ > q′′ > q for no q′′ ∈ QRT , and\n• ≥ q R v ≥ q R′, for all q ∈ QRT and R v R′ ∈ T or inv(R) v inv(R′) ∈ T .\nClearly, (ext(T ))∗(x) is equivalent (in first-order logic) to T ∗(x)∧T R(x)∧ ∧ R∈role±(T ) δR(x); see (1), (5) and (42). Let Bcon(T ) be the set of basic concepts occurring in T (i.e., concepts of the form A and ≥ q R, for A ∈ con(T ), R ∈ role±(T ) and q ∈ QRT ). To indicate which basic concepts hold or do not hold on a domain element of a first-order model of K‡e , we use functions ξ : Bcon(T ) → {>,⊥}, which will be called types. Denote by Tp the set of all such types (there are 2|Bcon(T )| of them). For a complex concept C, we define ξ(C) by induction: ξ(¬C) = ¬ξ(C) and ξ(C1 u C2) = ξ(C1) ∧ ξ(C2). The propositional variable-free formula\nξT = ∧\nC1vC2∈ext(T )\n( ξ(C1)→ ξ(C2) ) ensures that the type ξ is consistent with concept and role inclusions in T . It should be emphasized that ξT is built from ⊥ and > using the Boolean connectives and therefore does not depend on a particular domain element of AA. The following formula is true if a given element x of AA is of type ξ (see A† 1 and A‡2e ; (2) and (43), respectively):\nξ∗(x) = ∧\nAk∈con(T )\n( (Ak(x)→ ξ(Ak)) ∧ (Ak(x)→ ¬ξ(Ak)) ) ∧\n∧ R∈role±(T ) ∧ q∈QRT ( EqR T (x)→ ξ(≥ q R) ) ∧ ∧ Pk∈role(T ) ∀x∀y ( P Tk (x, y) ∧ Pk(x, y)→ ⊥ ) ,\nwhere EqR T (x) and RT (x, y), for R ∈ role±(T ), are abbreviations defined by\nEqR T (x) = ∃y1 . . . ∃yq ( ∧ 1≤i<j≤q (yi 6= yj) ∧ ∧ 1≤i≤q RT (x, yi) ) , (46)\nRT (x, y) = ∨\nPkv∗T R Pk(x, y) ∨ ∨ P−k v ∗ T R Pk(y, x). (47)\nClearly, we have R(ai, aj) ∈ CleT (A) iff AA |= RT [ai, aj ] and AA |= EqRT [a] iff a has at least q distinct R-successors in CleT (A) (and thus in every model of K).\nWithout loss of generality we may assume that role±(T ) = {R1, . . . , Rk} 6= ∅. Denote by Tpk the set of k-tuples ~ξ containing a type ξdri ∈ Tp for each role Ri ∈ role±(T ). We then set\nϕT = ∨\n~ξ∈Tpk ∀xϑ~ξT (x),\nwhere\nϑ (ξdr1 ,...,ξdrk ) T (x) = ∨ ξ∈Tp ( ξ∗(x) ∧ ξT ∧ ∧ Ri∈role±(T )\nξTdri ∧∧ Ri∈role±(T ) (( ξ(∃Ri) ∨ ∨ S∈role±(T ) ξds(∃Ri) ) → ξinv(dri)(∃inv(Ri)) )) .\nTo explain the meaning of the subformulas of ϕT , assume that (T ,A) is satisfiable. In order to construct a model M for K‡e from the first-order model AA, we have to specify the basic concepts that contain a given constant of K‡e . In other words, we have to select a type for each dri ∈ dr(T ) and each a ∈ ob(A). The formula ϕT says that one can select a k-tuple of types ~ξ = (ξdr1 , . . . , ξdrk) ∈ Tp\nk such that one of its disjuncts is true in AA. Such a k-tuple fixes the ‘witness’ part of the model M, consisting of the dri, and determines the basic concepts these dri belong to. Then each disjunct of ϕT says that (having fixed the ‘witness’ part of the model), for every a ∈ ob(A), there is a type ξ (determining the basic concepts a belongs to) such that\n• ξ is consistent with the information about a in A (cf. ξ∗(x));\n• ξ is also consistent with the concept and role inclusions of T (cf. ξT );\n• each of ξdr1 , . . . , ξdrk is consistent with the concept and role inclusions of T (cf. ξTdri);\n• each role Ri with a nonempty domain (i.e., either ξ or any of ξds is > on ∃Ri) has a nonempty range, in particular, ξinv(dri)(∃inv(Ri)) = >; see also εR(x) as defined by (4).\nLemma 6.1 AA |= ϕT iff K‡e is satisfiable.\nProof (⇒) Fix some ~ξ = (ξdr1 , . . . , ξdrk) ∈ Tp k such that AA |= ∀xϑ ~ξ T (x). Then, for each a ∈ ob(A), fix some type such that the respective disjunct of ϑ~ξT (x) holds on a in AA and denote it by ξa. Define a first-order model M over the domain ob(A) ∪ dr(T ) by taking:\n• M |= B∗[c] iff ξc(B) = >, for all c ∈ ob(A) ∪ dr(T ) and B ∈ Bcon(T )\n(B∗ is the unary predicate for B as defined on p. 22). It is easy to check that M |= K‡e . (⇐) Suppose now that K‡e is satisfiable. Then there is a model M of K‡e with domain ob(A) ∪ dr(T ). To see that AA |= ϕT , it suffices to take the functions ξdri and ξa defined by:\n• ξdri(B) = > iff M |= B∗[dri], for dri ∈ dr(T ) and B ∈ Bcon(T ),\n• ξa(B) = > iff M |= B∗[a], for a ∈ ob(A) and B ∈ Bcon(T ).\nDetails are left to the reader. q\nIt follows from Lemmas 6.1 and 5.17 and Corollary 5.16 that we have:\nCorollary 6.2 The satisfiability and instance checking problems for DL-LiteNbool, DL-Lite H bool and DL-Lite (HN ) bool KBs are in AC 0 for data complexity.\nProof DL-LiteNbool and DL-Lite H bool are sub-languages of DL-Lite (HN )− bool , and for them the result immediately follows from Lemma 6.1 and Corollary 5.16. For a DL-Lite (HN ) bool KB K′ = (T ′,A′), by Lemma 5.17, we construct a DL-Lite(HN ) −\nbool KB K = (T ,A) such that K′ is satisfiable iff K is satisfiable and (44) holds. The latter condition corresponds to the following first-order sentence\nγT ′ = ∧\nDis(R1,R2)∈T ′ ∀x∀y\n( RT1 (x, y) ∧RT2 (x, y)→ ⊥ ) ∧ ∧ Irr(Pk)∈T ′ ∀x ( P Tk (x, x)→ ⊥ ) ,\nevaluated in AA. Therefore, K′ is satisfiable iff AA |= ϕT ∧ γT ′ . Let ψ = ϕT ∧ γT ′ and ψ′ be the result of replacing each SP (t1, t2), for Ref(P ) ∈ T ′, with P (t1, t2)∧ (t1 6= t2); see the proof of Lemma 5.17. It remains to observe that AA |= ψ iff AA′ |= ψ′. q\nAs before, this result does not depend on the UNA for any member of the DL-Lite family that has no number restrictions of the form ≥ q R, for q ≥ 2 (in particular, for DL-LiteHbool and its fragments).\nWe also note that transitive roles cannot be included in our languages for free if we are concerned with data complexity:\nLemma 6.3 Satisfiability and instance checking of DL-Litecore KBs extended with role transitivity constraints are NLogSpace-hard for data complexity.\nProof Suppose we are given a directed graph. Let P be a role name. Define an ABox A by taking P (ai, aj) ∈ A iff there is an edge (ai, aj) in the graph. Then a node an is reachable from a node a0 iff the DL-Litecore ABox A ∪ {¬P (a0, an)} is not satisfiable in models with transitive P . This encoding immediately gives the claim of the lemma because the directed graph reachability problem is NLogSpace-complete, NLogSpace is closed under the complement (see, e.g., Kozen, 2006) and the TBox {Tra(P )} does not depend on the input. q\nOn the other hand, as the reduction of Lemma 5.18 is computable in NLogSpace, we obtain the following:\nCorollary 6.4 Satisfiability and instance checking of DL-Lite (HN )+ bool KBs are NLogSpacecomplete for data complexity.\nProof The upper bound is obtained by applying the NLogSpace reduction of Lemma 5.18 and using Corollary 6.2. The lower bound follows from Lemma 6.3. q"
    }, {
      "heading" : "6.2 P- and coNP-hardness for Data Complexity",
      "text" : "Let us now turn to the data complexity of instance checking for the DL-Lite logics with arbitrary number restrictions and role inclusions. As follows from the results of Ortiz et al. (2006) for SHIQ, instance checking (and in fact query answering) for DL-LiteHNbool is in coNP for data complexity, while the results of Hustadt et al. (2005) and Eiter et al. (2008) for Horn-SHIQ imply a polynomial-time upper bound for DL-LiteHFhorn.\nHere we show that these upper bounds are optimal in the following sense: on the one hand, instance checking in DL-LiteHFcore is P-hard for data complexity; on the other hand, it becomes coNP-hard for both DL-LiteHFkrom and DL-Lite HN core (that is, if we allow negated concept names or arbitrary number restrictions—in fact, ≥ 2R is enough). Note that the results of this section do not depend on whether we adopt the UNA or not.\nTheorem 6.5 The instance checking (and query answering) problem for DL-LiteHFkrom KBs is data-hard for coNP (with or without the UNA).\nProof The proof is by reduction of the unsatisfiability problem for 2+2CNF, which is known to be coNP-complete (Schaerf, 1993). Given a 2+2CNF formula\nϕ = n∧ k=1 (ak,1 ∨ ak,2 ∨ ¬ak,3 ∨ ¬ak,4),\nwhere each ak,j is one of the propositional variables a1, . . . , am, we construct a KB (T ,Aϕ) whose TBox T does not depend on ϕ. We will use the object names f , ck, for 1 ≤ k ≤ n, and ai, for 1 ≤ i ≤ m, role names S, Sf and Pj , Pj,t, Pj,f, for 1 ≤ j ≤ 4, and concept names A and D.\nDefine Aϕ to be the set of the following assertions, for 1 ≤ k ≤ n:\nS(f, ck), P1(ck, ak,1), P2(ck, ak,2), P3(ck, ak,3), P4(ck, ak,4),\nand let T consist of the axioms\n≥ 2Pj v ⊥, for1 ≤ j ≤ 4, (48) Pj,f v Pj , Pj,t v Pj , for 1 ≤ j ≤ 4, (49) ¬∃Pj,t v ∃Pj,f, for 1 ≤ j ≤ 4, (50) ∃P−j,f v ¬A, ∃P − j,t v A, for 1 ≤ j ≤ 4, (51)\n∃P1,f u ∃P2,f u ∃P3,t u ∃P4,t v ∃S−f , (52) ≥ 2S− v ⊥, (53)\nSf v S, (54) ∃Sf v D. (55)\nNote that axiom (52) does not belong to DL-LiteHFkrom because of the conjunctions in its left-hand side. However, it can be eliminated with the help of Lemma 5.9. So let us prove that (T ,Aϕ) |= D(f) iff ϕ is not satisfiable.\n(⇐) Suppose that ϕ is not satisfiable and I |= (T ,Aϕ). Define an assignment a of the truth values t and f to propositional variables by taking a(ai) = t iff a I i ∈ AI . As ϕ is false\nunder a, there is k, 1 ≤ k ≤ n, such that a(ak,1) = a(ak,2) = f and a(ak,3) = a(ak,4) = t. In view of (50), for each j, 1 ≤ j ≤ 4, we have cIk ∈ (∃Pj,t)I ∪ (∃Pj,f)I , and by (49), cIk ∈ (∃Pj)I . Therefore, by (48) and (51), cIk ∈ (∃Pj,t)I if a(ak,j) = t and cIk ∈ (∃Pj,f)I if a(ak,j) = f, and hence, by (52), c I k ∈ (∃S − f ) I . Then by (53) and (54), we have fI ∈ (∃Sf)I , from which, by (55), fI ∈ DI . It follows that (T ,Aϕ) |= D(f). (⇒) Conversely, suppose that ϕ is satisfiable. Then there is an assignment a such that a(ak,1) = t or a(ak,2) = t or a(ak,3) = f or a(ak,4) = f, for all 1 ≤ k ≤ n. Define I by taking\n• ∆I = { xi | 1 ≤ i ≤ m } ∪ { yk | 1 ≤ k ≤ n } ∪ { z } ,\n• aIi = xi, for 1 ≤ i ≤ m, cIk = yk, for 1 ≤ k ≤ n, fI = z,\n• AI = { xi | a(ai) = t } ∪ { yk | 1 ≤ k ≤ n } ∪ { z } ,\n• P Ij,t = { (yk, a I k,j) | 1 ≤ k ≤ n, a(ak,j) = t } ∪ { (xi, xi) | a(ai) = t } ∪ { (z, z) } ,\n• P Ij,f = { (yk, a I k,j) | 1 ≤ k ≤ n, a(ak,j) = f } ∪ { (xi, xi) | a(ai) = f } ,\n• P Ij = P Ij,t ∪ P Ij,f, for 1 ≤ j ≤ 4,\n• SIf = { (z, yk) | a(ak,1 ∨ ak,2 ∨ ¬ak,3 ∨ ¬ak,4) = f } = ∅,\n• SI = { (z, yk) | 1 ≤ k ≤ n } ,\n• DI = { z | a(ϕ) = f } = ∅.\nIt is not hard to check that I |= (T ,Aϕ) and I 6|= D(f). q\nTheorem 6.6 The instance checking (and the query answering) problem for DL-LiteHNcore KBs is data-hard for coNP (with or without the UNA).\nProof The proof is again by reduction of the unsatisfiability problem for 2+2CNF. The main difference from the previous one is that DL-LiteHNcore, unlike DL-Lite HF krom, cannot express ‘covering conditions’ like (50). It turns out, however, that we can use number restrictions to represent constraints of this kind. Given a 2+2CNF formula ϕ, we take the same ABox Aϕ constructed in the proof of Theorem 6.5. The (ϕ independent) TBox T , describing the meaning of any such representation of ϕ in terms of Aϕ, is also defined in the same way as in that proof, except that the axiom (50) is now replaced by the following set of axioms:\nTj,1 v Tj , Tj,2 v Tj , Tj,3 v Tj , (56) ≥ 2T−j v ⊥, (57) ∃Pj v ∃Tj,1, ∃Pj v ∃Tj,2, (58)\n∃T−j,1 u ∃T − j,2 v ∃T − j,3, (59)\n≥ 2Tj v ∃Pj,t ∃Tj,3 v ∃Pj,f, (60)\nwhere Tj , Tj,1, Tj,2, Tj,3 are fresh role names, for each j, 1 ≤ j ≤ 4. Note that axioms (52) and (59) do not belong to DL-LiteHNcore because of the conjunctions in their left-hand side, but\nwe can easily eliminate them using Lemma 5.9. So it remains to prove that (T ,Aϕ) |= D(f) iff ϕ is not satisfiable.\n(⇐) Suppose that ϕ is not satisfiable and I |= (T ,Aϕ). Define an assignment a of the truth values t and f to propositional variables by taking a(ai) = t iff a I i ∈ AI . As ϕ is false under a, there is k, 1 ≤ k ≤ n, such that a(ak,1) = a(ak,2) = f, a(ak,3) = a(ak,4) = t. For each j, 1 ≤ j ≤ 4, we have cIk ∈ (∃Pj)I ; by (58), cIk ∈ (∃Tj,1)I , (∃Tj,2)I . So there are v1, v2 such that (c I k , v1) ∈ T Ij,1 and (cIk , v2) ∈ T Ij,2. If v1 6= v2 then cIk ∈ (≥ 2Tj)I and, by (60), cIk ∈ (Pj,t)I . Otherwise, if v1 = v2 = v, we have v ∈ (∃T − j,3) I by (59), and so by (56) and (57), cIk ∈ (∃Tj,3)I , from which, by (60), cIk ∈ (Pj,f)I . Therefore, cIk ∈ (∃Pj,t)I ∪ (∃Pj,f)I , and by (49), cIk ∈ (∃Pj)I . Thus, by (48) and (51), cIk ∈ (∃Pj,t)I if a(ak,j) = t and c I k ∈ (∃Pj,f)I if a(ak,j) = f, and hence, by (52), cIk ∈ (∃S − f ) I . Then by (53) and (54), we have fI ∈ (∃Sf)I , from which, by (55), fI ∈ DI . It follows that (T ,Aϕ) |= D(f).\n(⇒) Conversely, suppose that ϕ is satisfiable. Then there is an assignment a such that a(ak,1) = t or a(ak,2) = t or a(ak,3) = f or a(ak,4) = f, for all 1 ≤ k ≤ n. Define I by taking\n• ∆I = { xi | 1 ≤ i ≤ m } ∪ { yk | 1 ≤ k ≤ n } ∪ { uk,j,1, uk,j,2 | 1 ≤ j ≤ 4, 1 ≤ k ≤ n } ∪ { z } ,\n• aIi = xi, for 1 ≤ i ≤ m, cIk = yk, for 1 ≤ k ≤ n, fI = z,\n• AI = {xi | a(ai) = t}, • P Ij,t = { (yk, a I k,j) | 1 ≤ k ≤ n, a(ak,j) = t } , for 1 ≤ j ≤ 4,\n• P Ij,f = { (yk, a I k,j) | 1 ≤ k ≤ n, a(ak,j) = f } , for 1 ≤ j ≤ 4,\n• P Ij = P Ij,t ∪ P Ij,f, for 1 ≤ j ≤ 4,\n• T Ij,1 = { (yk, uk,j,1) | 1 ≤ k ≤ n } , for 1 ≤ j ≤ 4,\n• T Ij,2 = { (yk, uk,j,2) | 1 ≤ k ≤ n, a(ak,j) = t } ∪{\n(yk, uk,j,1) | 1 ≤ k ≤ n, a(ak,j) = f } , for 1 ≤ j ≤ 4,\n• T Ij,3 = { (yi, uk,j,1) | 1 ≤ k ≤ n, a(ak,j) = f } , for 1 ≤ j ≤ 4,\n• T Ij = T Ij,1 ∪ T Ij,2,\n• SIf = { (z, yk) | a(ak,1 ∨ ak,2 ∨ ¬ak,3 ∨ ¬ak,4) = f } = ∅,\n• SI = { (z, yk) | 1 ≤ k ≤ n } ,\n• DI = { z | a(ϕ) = f } = ∅.\nIt is not hard to check that I |= (T ,Aϕ) and I 6|= D(f). q\nOur next lower bound would follow from Theorem 6, item 2 in the work of Calvanese et al. (2006); unfortunately, the proof there is incorrect and cannot be repaired.\nTheorem 6.7 The instance checking (and query answering) problem for DL-LiteHFcore KBs is data-hard for P (with or without the UNA).\nProof The proof is by reduction of the entailment problem for Horn-CNF, which is known to be P-complete (see, e.g., Börger et al., 1997, Exercise 2.2.4). Given a Horn-CNF formula\nϕ = n∧ k=1 (¬ak,1 ∨ ¬ak,2 ∨ ak,3) ∧ p∧ l=1 al,0,\nwhere each ak,j and each al,0 is one of the propositional variables a1, . . . , am, we construct a KB (T ,Aϕ) whose TBox T does not depend on ϕ. We will need the object names c1, . . . , cn and vk,j,i, for 1 ≤ k ≤ n, 1 ≤ j ≤ 3, 1 ≤ i ≤ m (for each variable, we take one object name for each possible occurrence of this variable in each non-unit clause), role names S, St and Pj , Pj,t, for 1 ≤ j ≤ 3, and a concept name A.\nDefine Aϕ to be the set containing the assertions:\nS(v1,1,i, v1,2,i), S(v1,2,i, v1,3,i), S(v1,3,i, v2,1,i), S(v2,1,i, v2,2,i), S(v2,2,i, v2,3,i), . . . . . . , S(vn,2,i, vn,3,i), S(vn,3,i, v1,1,i), for 1 ≤ i ≤ m, Pj(vk,j,i, ck) iff ak,j = ai, for 1 ≤ i ≤ m, 1 ≤ k ≤ n, 1 ≤ j ≤ 3, A(v1,1,i) iff al,0 = ai, for 1 ≤ i ≤ m, 1 ≤ l ≤ p\n(all objects for each variable are organized in an S-cycle and Pj(vk,j,i, ck) ∈ Aϕ iff the variable ai occurs in the kth non-unit clause of ϕ in the jth position). Let T consist of the following concept and role inclusions:\nSt v S, (61) ≥ 2S v ⊥, (62)\nA v ∃St, (63) ∃S−t v A, (64) ≥ 2P1 v ⊥ ≥ 2P2 v ⊥, (65) P1,t v P1, P2,t v P2, (66) A v ∃P1,t, A v ∃P2,t, (67) ≥ 2P−3 v ⊥, (68) P3,t v P3, (69)\n∃P−1,t u ∃P − 2,t v ∃P − 3,t, (70)\n∃P3,t v A. (71)\nAs before, here we have an axiom, namely (70), that does not belong to DL-LiteHFcore because of the conjunction in its left-hand side, but again it can be eliminated with the help of Lemma 5.9. Our aim is to show that (T ,Aϕ) |= A(v1,1,i0) iff ϕ |= ai0 .\n(⇐) Suppose that ϕ |= ai0 . Consider an arbitrary model I of (T ,Aϕ) and define a to be the assignment of the truth values t and f to propositional variables such that a(ai) = t iff vI1,1,i ∈ AI , for 1 ≤ i ≤ m. By (61)–(64), for each i, 1 ≤ i ≤ m, we have either vIk,j,i ∈ AI , for all k, j with 1 ≤ k ≤ n, 1 ≤ j ≤ 3, or vIk,j,i /∈ AI , for all k, j with 1 ≤ k ≤ n, 1 ≤ j ≤ 3. Now, if we have a(ak,1) = t and a(ak,2) = t, for 1 ≤ k ≤ n then, by (65)–(67), cIk ∈ (∃P − 1,t) I , (∃P−2,t)I . By (70), cIk ∈ (∃P − 3,t) I and hence, by (68) and (69), vIk,3,i ∈ (∃P3,t)I ,\nwhere ak,3 = ai, which means, by (71), that v I k,3,i ∈ AI , and so vI1,1,i ∈ AI and a(ai) = t. It follows that a(ϕ) = t, and hence a(ai0) = t, which, by definition, means that v I 1,1,i0\n∈ AI . So we can conclude that (T ,Aϕ) |= A(v1,1,i0).\n(⇒) Conversely, suppose that ϕ 6|= ai0 . Then there is an assignment a with a(ϕ) = t and a(ai0) = f. We construct a model I of (T ,Aϕ) such that I 6|= A(v1,1,i0). Define I by taking\n• ∆I = { xk,j,i, zk,j,i | 1 ≤ k ≤ n, 1 ≤ j ≤ 3, 1 ≤ i ≤ m } ∪ { yk | 1 ≤ k ≤ n } ,\n• cIk = yk, for 1 ≤ k ≤ n,\n• vIk,j,i = xk,j,i, for 1 ≤ k ≤ n, 1 ≤ j ≤ 3, 1 ≤ i ≤ m,\n• AI = { xk,j,i | 1 ≤ k ≤ n, 1 ≤ j ≤ 3, a(ai) = t } ,\n• SI = ⋃\n1≤i≤m Si, where Si =\n{ (xk,1,i, xk,2,i), (xk,2,i, xk,3,i), (xk,3,i, xk⊕1,1,i) | 1 ≤ k ≤ n } and k ⊕ 1 = k + 1 if k < n, and k ⊕ 1 = 1 if k = n,\n• SIt = ⋃\n1≤i≤m a(ai)=t\nSi,\n• P Ij = { (xk,j,i, yk) | 1 ≤ k ≤ n, ai = ak,j } ∪{\n(xk,j,i, zk,j,i) | 1 ≤ k ≤ n, ai 6= ak,j } , for 1 ≤ j ≤ 2,\n• P I3 = { (xk,3,i, yk) | 1 ≤ k ≤ n, ai = ak,3 } ,\n• P Ij,t = { (xk,j,i, yk) | 1 ≤ k ≤ n, ai = ak,j , a(ai) = t } ∪{\n(xk,j,i, zk,j,i) | 1 ≤ k ≤ n, ai 6= ak,j } , for 1 ≤ j ≤ 2,\n• P I3,t = { (xk,3,i, yk) | 1 ≤ k ≤ n, ai = ak,3, a(ai) = t } .\nIt is routine to check that we indeed have I |= (T ,Aϕ) and I 6|= A(v1,1,i0). See Figure 5 for an example. q"
    }, {
      "heading" : "7. Query Answering: Data Complexity",
      "text" : "The positive existential query answering problem is known to be data-complete for coNP in the case of DL-LiteHNbool : the upper bound follows from the results of Ortiz et al. (2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993). In the case of DL-LiteHFhorn, query answering is data-complete for P, as follows from the results of Hustadt et al. (2005) and Eiter et al. (2008) for Horn-SHIQ, while for DL-LiteHhorn it is in AC\n0 (Calvanese et al., 2006). In fact, the coNP upper bound holds for the extension of DL-LiteHNbool with role disjointness and (a)symmetry constraints (this follows from Glimm et al., 2007, Theorem 10; cf. Remark 5.21). We conjecture that the same result holds for role (ir)reflexivity constraints.\nOur main result in this section is the following:\nTheorem 7.1 The positive existential query answering problem for the logics DL-LiteNhorn, DL-LiteHhorn and DL-Lite (HN ) horn is in AC 0 for data complexity.\nProof Suppose that we are given a consistent DL-Lite (HN ) horn KB K ′ = (T ′,A′) (with all its concept and role names occurring in the TBox T ′) and a positive existential query in prenex form q(~x) = ∃~y ϕ(~x, ~y) in the signature of K′. Consider the DL-Lite(HN ) −\nhorn KB K = (T ,A) provided by Lemma 5.17 (the language DL-Lite\n(HN )− horn is defined in Section 5.3).\nLemma 7.2 For every tuple ~a of object names in K′, we have K′ |= q(~a) iff I |= q(~a) for all untangled models I of K.\nProof (⇒) Suppose that K′ |= q(~a) and I is an untangled model I of K. By Lemma 5.17 and in view of consistency of K′, which ensures that (44) holds, we then have I |= K′ and therefore, I |= q(~a).\n(⇐) Suppose I ′ |= K′. By Lemma 5.17, there is a model I of K with the same domain as I ′ that coincides with I ′ on all symbols in K′. As I |= q(~a), we must then have I ′ |= q(~a), and so K′ |= q(~a) as required. q\nNext we show that, as K‡e is a Horn sentence, it is enough to consider just one special model I0 of K in the formulation of Lemma 7.2. Let M0 be the minimal Herbrand model of (the universal Horn sentence) K‡e . We remind the reader (for details consult, e.g., Apt, 1990; Rautenberg, 2006) that M0 can be constructed by taking the intersection of all Herbrand models for K‡e , that is, of all models based on the domain that consists of constant symbols from K‡e—i.e., Λ = ob(A) ∪ dr(T ); cf. Remark 5.15. We then have the following\nM0 |= B∗[c] iff K‡e |= B∗(c), for B ∈ Bcon(T ) and c ∈ Λ.\nLet I0 be the untangled model of K induced by M0. Denote the domain of I0 by ∆I0 . Property (copy) of Remark 5.15 provides us with a function cp : ∆I0 → Λ.\nThere are two consequences of Lemma 5.14. First, we have\naI0i ∈ B I0 iff K |= B(ai), for B ∈ Bcon(T ) and ai ∈ ob(A). (72)\nSecond, for every R ∈ role±(T ), if RI0 6= ∅ then RI 6= ∅, for all models I of K. Indeed, if RI0 6= ∅ then M0 |= (∃R)∗[dr]. Therefore, (T ∪ {∃R v ⊥},A) is not satisfiable, and thus RI 6= ∅, for all I with I |= K. Moreover, if RI0 6= ∅ then\nw ∈ BI0 iff K |= ∃R v B, for B ∈ Bcon(T ) and w ∈ ∆I0 with cp(w) = dr. (73)\nLemma 7.3 If I0 |= q(~a) then I |= q(~a) for all untangled models I of K.\nProof Suppose I |= K. As q(~a) is a positive existential sentence, it is enough to construct a homomorphism h : I0 → I. We remind the reader that, by (forest), the domain ∆I0 of I0 is partitioned into disjoint trees Ta, for a ∈ ob(A). Define the depth of a point w ∈ ∆I0 to be the length of the shortest path in the respective tree to its root. Denote by Wm the set of points of depth ≤ m; in particular, W0 = {aI0 | a ∈ ob(A)}. We construct h as the union of maps hm, m ≥ 0, where each hm is defined on Wm and has the following properties: hm+1(w) = hm(w), for all w ∈Wm, and\n(am) for every w ∈Wm, if w ∈ BI0 then hm(w) ∈ BI , for each B ∈ Bcon(T );\n(bm) for all u, v ∈Wm, if (u, v) ∈ RI0 then (hm(u), hm(v)) ∈ RI , for each R ∈ role±(T ).\nFor the basis of induction, we set h0(a I0 i ) = a I i , for ai ∈ ob(A). Property (a0) follows then from (72) and (b0) from (ABox) of Remark 5.15. For the induction step, suppose that hm has already been defined for Wm, m ≥ 0. Set hm+1(w) = hm(w) for all w ∈ Wm. Consider an arbitrary v ∈ Wm+1 \\Wm. By (forest), there is a unique u ∈ Wm such that (u, v) ∈ Ea, for some Ta. Let `a(u, v) = S. Then, by (copy), cp(v) = inv(ds). By (role), u ∈ (∃S)I0 and, by (am), hm(u) ∈ (∃S)I , which means that there is w ∈ ∆I with (hm(u), w) ∈ SI . Set hm+1(v) = w. As cp(v) = inv(ds) and (∃inv(S))I0 6= ∅, it follows from (73) that if v ∈ BI0 then w′ ∈ BI whenever we have w′ ∈ (∃inv(S))I . As w ∈ (∃inv(S))I , we obtain (am+1) for v. To show (bm+1), we notice that, by (role), we have (w, v) ∈ RI0 , for some w ∈ Wm+1, just in two cases: either w ∈Wm+1 \\Wm, and then w = v and Id v∗T R, or w ∈Wm, and then w = u and S v∗T R. In the former case, (hm+1(v), hm+1(v)) ∈ RI because IdI is the identity relation by (role). In the latter case, we have (u, v) ∈ SI0 ; hence (hm+1(u), hm+1(v)) ∈ SI and, as S v∗T R, (hm+1(u), hm+1(v)) ∈ RI . q\nAssume now that, in the query q(~x) = ∃~y ϕ(~x, ~y), we have ~y = y1, . . . , yk, and ϕ is a quantifier-free formula. Our next lemma shows that in this case to check whether I0 |= q(~a) it suffices to consider only the points of depth ≤ m0 in ∆I0 , for some m0 that does not depend on |A|.\nLemma 7.4 Let m0 = k+ |role±(T )|. If I0 |= ∃~y ϕ(~a, ~y) then there is an assignment a0 in Wm0 (i.e., a0(yi) ∈Wm0 for all i) such that I0 |=a0 ϕ(~a, ~y).\nProof Suppose that I0 |=a ϕ(~a, ~y), for some assignment a in ∆I0 , and that there is yi, 1 ≤ i ≤ k, with a(yi) /∈ Wm0 . Let Y be the minimal subset of ~y that contains yi and every y such that either P (y′, y) or P (y, y′) is a subformula of ϕ, for some y′ ∈ Y and some role name P . Let yj ∈ Y be such that there is m > |role±(T )| with a(yj) ∈ Wm and\na(y) /∈Wm−1 for all y ∈ Y (for convenience, W−1 = ∅ as before). Clearly, such an m exists: a(yi) /∈Wm0 , Y has at most k variables and, by (forest), relations P I0 can connect a point in Wn \\Wn−1 only with a point in Wn+1 \\Wn−2, for n ≥ 1. Let w = a(yj) be a point in Ta. As w ∈Wm \\Wm−1, we have cp(w) = dr, for some R ∈ role±(T ). As there are at most |role±(T )| distinct labels in each labeled tree Ta and in view of (copy), for each point u of depth > |role±(T )|, there is a point u′ of depth ≤ |role±(T )| in the same Ta such that cp(u) = cp(u′); by (iso), the trees generated by u and u′ are isomorphic. So, there is an isomorphism g from the labeled tree generated by w (which contains all a(y), for y ∈ Y ) onto the labeled tree generated by some point of depth ≤ |role±(T )| in Ta. Define a new assignment aY by taking aY (y) = g(a(y)) if y ∈ Y and aY (y) = a(y) otherwise. By (copy), (concept) and (role) we then have I0 |=aY ϕ(~a, ~y) and aY (y) ∈ Wm0 , for each y ∈ Y . If aY (yj) /∈Wm0 for some j, we repeat the described construction. After at most k iterations we shall obtain an assignment a0 required by the lemma. q\nTo complete the proof of Theorem 7.1, we encode the problem ‘K |= q(~a)?’ as a model checking problem for first-order formulas. In precisely the same way as in Section 6.1, we fix a signature that contains unary predicates A, A, for each concept name A, and binary predicates P , P , for each role name P , and then represent the ABox A of K as a first-order model AA with domain ob(A). Now we define a first-order formula ϕT ,q(~x) in the above signature such that (i) ϕT ,q(~x) depends on T and q but not on A, and (ii) AA |= ϕT ,q(~a) iff I0 |= q(~a).\nWe begin by defining formulas ψB(x), for B ∈ Bcon(T ), that describe the types of the elements of ob(A) in the model I0 in the following sense (see also (72)):\nAA |= ψB[ai] iff aI0i ∈ B I0 , for B ∈ Bcon(T ) and ai ∈ ob(A). (74)\nThese formulas are defined as the ‘fixed-points’ of sequences ψ0B(x), ψ 1 B(x), . . . of formulas with one free variable, where\nψ0B(x) =\n{ A(x), if B = A,\nEqR T (x), if B = ≥ q R,\nψiB(x) = ψ 0 B(x) ∨ ∨ B1u···uBkvB∈ext(T ) ( ψi−1B1 (x) ∧ · · · ∧ ψ i−1 Bk (x) ) , for i ≥ 1,\nand EqR T (x) is given by (46). (As in Section 6.1, to simplify presentation we use ext(T ) instead of T .) It should be clear that if there is some i such that, for all B ∈ Bcon(T ), ψiB(x) ≡ ψ i+1 B (x) (i.e., every ψ i B(x) is equivalent to ψ i+1 B (x) in first-order logic), then ψiB(x) ≡ ψ j B(x) for every B ∈ Bcon(T ) and j ≥ i. So the minimum such i does not exceed N = |Bcon(T )|, and we set ψB(x) = ψNB (x). Next we introduce sentences θB,dr, for B ∈ Bcon(T ) and dr ∈ dr(T ), that describe the types of elements in dr(T ) in the following sense (see also (73)):\nAA |= θB,dr iff w ∈ BI0 , for B ∈ Bcon(T ) and each w ∈ ∆I0 with cp(w) = dr. (75)\n(By (concept), this definition is correct.) These sentences are defined similarly to ψB(x). Namely, for each B ∈ Bcon(T ) and each dr ∈ dr(T ), we inductively define a sequence\nθ0B,dr, θ 1 B,dr, . . . by taking\nθ0B,dr = ρ 0 B,dr and θ i B,dr = ρ i B,dr ∨ ∨ B1u···uBkvB∈ext(T ) ( θi−1B1,dr ∧ · · · ∧ θ i−1 Bk,dr ) , for i ≥ 1,\nwhere ρiB,dr = ⊥, for all i ≥ 0, whenever B 6= ∃R and\nρ0∃R,dr = ∃xψ∃inv(R)(x) and ρi∃R,dr = ∨\nds∈dr(T )\nθi−1∃inv(R),ds, for i ≥ 1.\nIt should be clear that there is i ≤ |role±(T )|·N such that θiB,dr ≡ θ i+1 B,dr, for all B ∈ Bcon(T ) and dr ∈ dr(T ). So we set θB,dr = θ |role±(T )|·N B,dr .\nNow we consider the directed graphGT = (VT , ET ), where VT is the set of all equivalence classes [R], [R] = {R′ | R ≡∗T R′}, such that ∃R is not empty in some model of T , and ET is the set of all pairs ([Ri], [Rj ]) such that\n(path) T |= ∃inv(Ri) v ≥ q Rj and either inv(Ri) 6v∗T Rj or q ≥ 2,\nand Rj has no proper sub-role satisfying (path). We have ([Ri], [Rj ]) ∈ ET iff, for any ABox A′, whenever the minimal untangled model I0 of (T ,A′) contains a copy w of inv(dr′i), for R′i ∈ [Ri], then w is connected to a copy of inv(dr′j), for R′j ∈ [Rj ], by all relations S with Rj v∗T S.\nRecall now that we are given a query q(~x) = ∃~y ϕ(~x, ~y), where ϕ is a quantifier-free positive formula and ~y = y1, . . . , yk. Let ΣT ,m0 be the set of all paths in the graph GT of length ≤ m0. More precisely,\nΣT ,m0 = { ε } ∪ { ([R1], [R2], . . . , [Rn]) | 1 ≤ n ≤ m0, ([Rj ], [Rj+1]) ∈ ET , for 1 ≤ j < n } .\nFor σ, σ′ ∈ ΣT ,m0 and a role R ∈ role±(T ), we write σ R→ σ′ if one of the following three conditions is satisfied: (i) σ = σ′ and Id v∗T R, (ii) σ.[S] = σ′ or (iii) σ = σ′.[inv(S)], for some role S with S v∗T R.\nLet ΣkT ,m0 be the set of all k-tuples of the form ~σ = (σ1, . . . , σk), σi ∈ ΣT ,m0 . Intuitively, when evaluating the query ∃~y ϕ(~x, ~y) over I0, each bound, or non-distinguished, variable yi is mapped to a point w in Wm0 . However, the first-order model AA does not contain the points from Wm0 \\W0, and to represent them, we use the following ‘trick.’ By (forest), every point w in Wm0 is uniquely determined by the pair (a, σ), where a\nI0 is the root of the tree Ta containing w, and σ is the sequence of labels `a(u, v) on the path from a\nI0 to w. It follows from the unraveling procedure and (path) that σ ∈ ΣT ,m0 . So, in the formula ϕT ,q we are about to define we assume that the yi range over W0 and represent the first component of the pairs (a, σ), whereas the second component is encoded in the ith member of ~σ (these yi should not be confused with the yi in the original query q, which range over all of Wm0). In order to treat arbitrary terms t occurring in ϕ(~x, ~y) in a uniform way, we set t~σ = ε, if t = a ∈ ob(A) or t = xi, and t~σ = σi, if t = yi (the distinguished variables xi and the object names a are mapped to W0 and do not require the second component of the pairs).\nGiven an assignment a0 in Wm0 we denote by split(a0) the pair (a, ~σ), where a is an assignment in AA and ~σ = (σ1, . . . , σk) ∈ ΣkT ,m0 are such that\n• for each distinguished variable xi, a(xi) = a with aI0 = a0(xi);\n• for each bound variable yi, a(yi) = a and σi = ([R1], . . . , [Rn]), n ≤ m0, with aI0 being the root of the tree containing a0(yi) and R1, . . . , Rn being the sequence of labels `a(u, v) on the path from a I0 to a0(yi).\nNot every pair (a, ~σ), however, corresponds to an assignment in Wm0 because some paths in ~σ may not exist in our I0: GT represents possible paths in all models for the fixed TBox T and varying ABox. As follows from the unraveling procedure, a point in Wm0 \\W0 corresponds to a ∈ ob(A) and σ = ([R], . . . ) ∈ ΣT ,m0 iff a does not have enough R-witnesses in A, i.e., iff AA |= ¬ψ0≥q R[a] ∧ ψ≥q R[a], for some q ∈ QRT . Thus, for every (a, ~σ) with ~σ = (σ1, . . . , σk), there is an assignment a0 in Wm0 with split(a0) = (a, ~σ) iff AA |=a η~σ(~y), where\nη(σ1,...,σk)(y1, . . . , yk) = ∧\n1≤i≤k σi 6=ε\n∨ q∈QRiT ( ¬ψ0≥q Ri(yi) ∧ ψ≥q Ri(yi) ) and each Ri, for 1 ≤ i ≤ k with σi 6= ε, is such that σi = ([Ri], . . . ).\nWe define now, for every ~σ ∈ ΣkT ,m0 , concept name A and role name R,\nA~σ(t) =\n{ ψA(t), if t ~σ = ε,\nθA,inv(ds), if t ~σ = σ′.[S], for some σ′ ∈ ΣT ,m0 ,\nR~σ(t1, t2) =  RT (t1, t2), if t ~σ 1 = t ~σ 2 = ε, (t1 = t2), if t ~σ 1 R→ t~σ2 and either t~σ1 6= ε or t~σ2 6= ε,\n⊥, otherwise,\nwhere RT (y1, y2) is given by (47). We claim that, for every assignment a0 in Wm0 and (a, σ) = split(a0),\nI0 |=a0 A(t) iff AA |=a A~σ(t), for all concept names A and terms t, (76) I0 |=a0 R(t1, t2) iff AA |=a R~σ(t1, t2), for all roles R and terms t1, t2. (77)\nFor A(a), A(xi) or A(yi) with σi = ε the claim follows from (74). For A(yi) with σi = σ ′.[S], by (copy), we have cp(a(yi)) = inv(dr), for some R ∈ [S]; the claim then follows from (75). For R(yi1 , yi2) with σi1 = σi2 = ε, the claim follows from (ABox). Let us consider the case of R(yi1 , yi2) with σi2 6= ε: we have a0(yi2) /∈W0 and thus, by (role), I0 |=a0 R(yi1 , yi2) iff\n• a0(yi1), a0(yi2) are in the same tree Ta, for a ∈ ob(A), i.e., AA |=a (yi1 = yi2),\n• and either (a0(yi1), a0(yi2)) ∈ Ea and then `a(a0(yi1), a0(yi2)) = S for some S v∗T R, or (a0(yi2), a0(yi1)) ∈ Ea and then `a(a0(yi2), a0(yi1)) = S for some inv(S) v∗T R, or a0(yi1) = a0(yi2) and then Id v∗T R, i.e., σi1 R→ σi2 .\nOther cases are similar and left to the reader. Finally, let ϕ~σ(~x, ~y) be the result of attaching the superscript ~σ to each atom of ϕ and\nϕT ,q(~x) = ∃~y ∨\n~σ∈ΣkT ,m0\n( ϕ~σ(~x, ~y) ∧ η~σ(~y) ) .\nAs follows from (76)–(77), for every assignment a0 in Wm0 , we have I0 |=a0 ϕ(~x, ~y) iff AA |=a ϕ~σ(~x, ~y) for (a, σ) = split(a0). For the converse direction notice that, if AA |=a η~σ(~y) then there is an assignment a0 in Wm0 with split(a0) = (a, ~σ).\nClearly, AA |= ϕT ,q(~a) iff I0 |= q(~a), for every tuple ~a. We also note that, for every pair of tuples ~a and ~b of object names in ob(A), ϕ~σ(~a,~b) is a positive existential sentence with inequalities, and so is domain-independent.10 It is also easily seen that, for each ~b, η~σ(~b) is domain-independent. It follows from the minimality of I0 that ϕT ,q(~a) is domainindependent, for each tuple ~a of object names in ob(A).\nFinally, note that the resulting query contains ≤ |role±(T )|k·(k+|role±(T )|) disjuncts. q\n8. DL-Lite without the Unique Name Assumption\nIn this section, unless otherwise stated, we assume that the interpretations do not respect the UNA, that is, we may have aIi = a I j for distinct object names ai and aj . The consequence relation |=noUNA refers to the class of such interpretations. Description logics without the UNA are usually extended with additional equality and inequality constraints of the form:\nai ≈ aj and ai 6≈ aj ,\nwhere ai, aj are object names. Their semantics is quite obvious: we have I |= ai ≈ aj iff aIi = a I j , and I |= ai 6≈ aj iff aIi 6= aIj . The equality and inequality constraints are supposed to belong to the ABox part of a knowledge base. It is to be noted, however, that reasoning with equalities is LogSpace-reducible to reasoning without them:\nLemma 8.1 For every KB K = (T ,A), one can construct in LogSpace in the size of A a KB K′ = (T ,A′) without equality constraints such that I |= K iff I |= K′, for every interpretation I.\nProof Let G = (V,E) be the undirected graph with V = ob(A), E = { (ai, aj) | ai ≈ aj ∈ A or aj ≈ ai ∈ A }\nand [ai] the set of all vertices of G that are reachable from ai. Define A′ by removing all the equality constraints from A and replacing every ai with aj ∈ [ai] with minimal j. Note that this minimal j can be computed in LogSpace: just enumerate the object names aj with respect to the order of their indexes j and check whether the current aj is reachable from ai in G. It remains to recall that reachability in undirected graphs is SLogSpace-complete and that SLogSpace = LogSpace (Reingold, 2008). q\nAs we mentioned in Section 5.3, the logics of the form DL-LiteHα do not ‘feel’ whether we adopt the UNA or not. With this observation and Lemmas 5.17, 5.18 and 8.1 at hand, we obtain the following result as a consequence of Theorem 5.13:\n10. A query q(~x) is said to be domain-independent in case AA |=a q(~x) iff A |=a q(~x), for each A such that the domain of A contains ob(A), the active domain of AA, and AA = AAA and PA = PAA , for all concept and role names A and P .\nTheorem 8.2 With or without the UNA, for combined complexity, (i) satisfiability of DL-LiteHbool KBs is NP-complete; (ii) satisfiability of DL-Lite H horn KBs is P-complete; and (iii) satisfiability of DL-LiteHkrom and DL-Lite H core KBs is NLogSpace-complete. These results hold even if the KBs contain role disjointness, (a)symmetry, (ir)reflexivity and transitivity constraints, equalities and inequalities.\nOn the other hand, from Corollary 6.2 and Lemmas 5.17, 5.18 and 8.1 we can derive the following:\nTheorem 8.3 Without the UNA, satisfiability and instance checking for DL-LiteHbool KBs are in AC0 for data complexity. These problems are also in AC0 if the KBs contain role disjointness, (a)symmetry and (ir)reflexivity constraints and inequalities. However, they are LogSpace-complete if the KBs may contain equalities, and NLogSpace-complete if role transitivity constraints are allowed.\nWe also note that our complexity results (Corollary 5.12, Theorems 6.5, 6.6 and 6.7) for the logics DL-LiteHFα and DL-Lite HN α do not depend on the UNA.\nIn this section, we analyze the combined and data complexity of reasoning in the logics\nof the form DL-Lite (HF) α and DL-Lite (HN ) α (as well as their fragments) without the UNA. The obtained and known results are summarized in Table 2 on page 17.\n8.1 DL-Lite (HN ) α : Arbitrary Number Restrictions\nThe following theorem shows that the interaction between number restrictions and the possibility of identifying objects in the ABox results in a higher complexity.\nTheorem 8.4 Without the UNA, satisfiability of DL-LiteNcore KBs (even without equality and inequality constraints) is NP-hard for both combined and data complexity.\nProof The proof is by reduction of the following variant of the 3SAT problem—called monotone one-in-three 3SAT—which is known to be NP-complete (Garey & Johnson, 1979): given a positive 3CNF formula\nϕ = n∧ k=1 ( ak,1 ∨ ak,2 ∨ ak,3 ) ,\nwhere each ak,j is one of the propositional variables a1, . . . , am, decide whether there is an assignment for the variables aj such that exactly one variable is true in each of the clauses in ϕ. To encode this problem in the language of DL-LiteNcore, we need object names a k i , for 1 ≤ k ≤ n, 1 ≤ i ≤ m, and ck and tk, for 1 ≤ k ≤ n, role names S and P , and concept names A1, A2, A3. Let Aϕ be the ABox containing the following assertions:\nS(a1i , a 2 i ), . . . , S(a n−1 i , a n i ), S(a n i , a 1 i ), for 1 ≤ i ≤ m, S(t1, t2), . . . , S(tn−1, tn), S(tn, t1),\nP (ck, t k), for 1 ≤ k ≤ n, P (ck, a k k,j), Aj(a k k,j), for 1 ≤ k ≤ n, 1 ≤ j ≤ 3,\nand let T be the TBox with the following axioms:\nA1 v ¬A2, A2 v ¬A3, A3 v ¬A1, ≥ 2S v ⊥, ≥ 4P v ⊥.\nClearly, (T ,Aϕ) is a DL-LiteNcore KB and T does not depend on ϕ (so that we cover both combined and data complexity). We claim that the answer to the monotone one-in-three 3SAT problem is positive iff (T ,Aϕ) is satisfiable without the UNA.\n(⇐) Suppose I |= (T ,Aϕ). Define an assignment a of the truth values f and t to propositional variables by taking a(ai) = t iff (a 1 i ) I = (t1)I . Our aim is to show that a(ak,j) = t for exactly one j ∈ {1, 2, 3}, for each k, 1 ≤ k ≤ n. For all j ∈ {1, 2, 3}, we have (cIk , (a k k,j) I) ∈ P I . Moreover, (akk,i)I 6= (akk,j)I for i 6= j. As cIk ∈ (≤ 3P )I and (cIk , (t k)I) ∈ P I , we then must have (akk,j)I = (tk)I for some unique j ∈ {1, 2, 3}. It follows from functionality of S that, for each 1 ≤ k ≤ n, we have (a1k,j)I = (t1)I for exactly one j ∈ {1, 2, 3}.\n(⇒) Let a be an assignment satisfying the monotone one-in-three 3SAT problem. Take some ai0 with a(ai0) = t (clearly, such an i0 exists, for otherwise a(ϕ) = f) and construct an interpretation I = (∆I , ·I) by taking:\n• ∆I = { yk, z k | 1 ≤ k ≤ n } ∪ { xki | a(ai) = f, 1 ≤ i ≤ m, 1 ≤ k ≤ n } ,\n• cIk = yk and (tk)I = zk, for 1 ≤ k ≤ n,\n• (aki )I =\n{ xki , if a(ai) = f,\nzk, if a(ai) = t, for 1 ≤ i ≤ m, 1 ≤ k ≤ n,\n• SI = {\n((a1i ) I , (a2i ) I), . . . , ((an−1i ) I , (ani ) I), ((ani ) I , (a1i )\nI) | 1 ≤ i ≤ m } ,\n• P I = {\n(cIk , (t k)I), (cIk , (a k k,1) I), (cIk , (a k k,2) I), (cIk , (a k k,3) I) | 1 ≤ k ≤ n\n} .\nIt is readily checked that I |= (T ,Aϕ). q\nIn fact, the above lower bound is optimal:\nTheorem 8.5 Without the UNA, satisfiability of DL-LiteNα , DL-Lite (HN ) α and DL-Lite (HN )+ α KBs with equality and inequality constraints is NP-complete for both combined and data complexity and any α ∈ {core, krom, horn, bool}.\nProof The lower bound is immediate from Theorem 8.4, and the matching upper bound can be proved by the following non-deterministic algorithm. Given a DL-Lite (HN )+ bool KB K = (T ,A), we\n• guess an equivalence relation ∼ over ob(A);\n• select in each equivalence class ai/∼ a representative, say ai, and replace every occurrence of a ∈ ai/∼ in A with ai;\n• fail if the equalities and inequalities are violated in the resulting ABox—i.e., if it contains ai 6≈ ai or ai ≈ aj , for i 6= j;\n• otherwise, remove the equality and inequality constraints from the ABox and denote the result by A′;\n• use the NP satisfiability checking algorithm for DL-Lite(HN ) +\nbool to decide whether the KB K′ = (T ,A′) is consistent under the UNA.\nClearly, if the algorithm returns ‘yes,’ then I ′ |= K′, for some I ′ respecting the UNA, and we can construct a model I of K (not necessarily respecting the UNA) by extending I ′ with the following interpretation of object names: aI = aI\n′ i , whenever ai is the representative\nof a/∼ (I coincides with I ′ on all other symbols). Conversely, if I |= K then we take the equivalence relation ∼ defined by ai ∼ aj iff aIi = aIj . Let I ′ be constructed from I by removing the interpretations of all object names that are not representatives of the equivalence classes for ∼. It follows that I ′ respects the UNA and I ′ |= K′, so the algorithm returns ‘yes.’ q\n8.2 DL-Lite (HF) α : Functionality Constraints Let us consider now DL-Lite (HF)+ bool and its fragments. The following lemma shows that for these logics reasoning without the UNA can be reduced in polynomial time in the size of the ABox to reasoning under the UNA.\nLemma 8.6 For every DL-Lite (HF)+ bool KB K = (T ,A) with equality and inequality constraints, one can construct in polynomial time in |A| a DL-Lite(HF) +\nbool KB K ′ = (T ,A′) such\nthat A′ contains no equalities and inequalities and K is satisfiable without the UNA iff K′ is satisfiable under the UNA.\nProof In what follows by identifying aj with ak in A we mean replacing each occurrence of ak in A with aj . We construct A′ by first identifying aj with ak, for each aj ≈ ak ∈ A, and removing the equality from A, and then exhaustively applying the following procedure to A:\n• if ≥ 2R v ⊥ ∈ T and R(ai, aj), R(ai, ak) ∈ CleT (A), for distinct aj and ak, then identify aj with ak (recall that a functional R cannot have transitive sub-roles and thus CleT (A) is enough).\nIf the resulting ABox contains ai 6≈ ai, for some ai, then, clearly, K is not satisfiable, so we add A(ai) and ¬A(ai) to the ABox, for some concept name A. Finally, we remove all inequalities from the ABox and denote the result by A′. It should be clear that A′ is computed from A in polynomial time and that, without the UNA, K is satisfiable iff K′ is satisfiable. So it suffices to show that K′ is satisfiable without the UNA iff it is satisfiable under the UNA. The implication (⇐) is trivial.\n(⇒) Observe that the above procedure ensures that\nqeR,a ≤ 1, for each R with ≥ 2S v ⊥ ∈ T , R v∗T S and a ∈ ob(A′)\n(see page 37 for definitions). Let K′′ be the DL-Lite(HN ) −\nbool KB provided by Lemma 5.17 for K′. It follows from the above property and the proofs of Lemma 5.14 and Corollary 5.16\nthat if K′′ is satisfiable without the UNA then (K′′)‡e is satisfied in a first-order model with some constants interpreted by the same domain element. As (K′′)‡e is a universal first-order sentence containing no equality, it is satisfiable in a first-order model such that all constants are interpreted by distinct elements. It follows from the proofs of Lemma 5.14 and Corollary 5.16 that this first-order model can be unraveled into a model J for K′′ respecting the UNA. By Lemma 5.17, J is a model of K′. q\nThe reduction above cannot be done better than in P, as shown by the next theorem:\nTheorem 8.7 Without the UNA, satisfiability of DL-LiteFcore KBs (even without equality and inequality constraints) is P-hard for both combined and data complexity.\nProof The proof is by reduction of the entailment problem for Horn-CNF (as in the proof of Theorem 6.7). Let\nϕ = n∧ k=1 ( ak,1 ∧ ak,2 → ak,3 ) ∧ p∧ l=1 al,0\nbe a Horn-CNF formula, where each ak,j and each al,0 is one of the propositional variables a1, . . . , am and ak,1, ak,2, ak,3 are all distinct, for each k, 1 ≤ k ≤ n. To encode the Pcomplete problem ‘ϕ |= ai?’ in the language of DL-LiteFcore we need object names t, aki , for 1 ≤ k ≤ n, 1 ≤ i ≤ m, and fk and gk, for 1 ≤ k ≤ n, and role names P , Q, S and T . The ABox A contains the following assertions\nS(a1i , a 2 i ), . . . , S(a n−1 i , a n i ), S(a n i , a 1 i ), for 1 ≤ i ≤ m, P (akk,1, fk), P (a k k,2, gk), Q(gk, a k k,3), Q(fk, a k k,1), for 1 ≤ k ≤ n, T (t, a1l,0), for 1 ≤ l ≤ p,\nand the TBox T asserts that all of the roles are functional:\n≥ 2P v ⊥, ≥ 2Q v ⊥, ≥ 2S v ⊥ and ≥ 2T v ⊥.\nClearly, K = (T ,A) is a DL-LiteFcore KB and T does not depend on ϕ. We claim that ϕ |= aj iff (T ,A∪ {¬T (t, a1j )}) is not satisfiable without the UNA. To show this, it suffices to prove that ϕ |= aj iff K |=noUNA T (t, a1j ).\n(⇒) Suppose ϕ |= aj . Then we can derive aj from ϕ using the following inference rules:\n• ϕ |= al,0 for each l, 1 ≤ l ≤ p;\n• if ϕ |= ak,1 and ϕ |= ak,2, for some k, 1 ≤ k ≤ n, then ϕ |= ak,3.\nWe show that K |=noUNA T (t, a1j ) by induction on the length of the derivation of aj from ϕ. The basis of induction is trivial. So assume that aj = ak,3, ϕ |= ak,1, ϕ |= ak,2, for some k, 1 ≤ k ≤ n, and that K |=noUNA T (t, a1k,1) ∧ T (t, a1k,2). Suppose also that I |= K. Since T is functional, we have (a1k,1) I = (a1k,2) I . Since S is functional, (ak ′ k,1) I = (ak ′ k,2) I , for all k′, 1 ≤ k′ ≤ n, and in particular, for k′ = k. Then, since P is functional, fIk = gIk , from which, by functionality of Q, (akk,3) I = (akk,1) I . Finally, since S is functional, (ak ′ k,3) I = (ak ′ k,1) I ,\nfor all k′, 1 ≤ k′ ≤ n, and in particular, for k′ = 1. Thus, I |= T (t, a1j ) and therefore K |=noUNA T (t, a1j ).\n(⇐) Suppose that ϕ 6|= aj . Then there is an assignment a such that a(ϕ) = t and a(aj) = f. Construct an interpretation I by taking\n• ∆I = { xki | a(ai) = f, 1 ≤ k ≤ n, 1 ≤ i ≤ m } ∪ { zk, uk, vk | 1 ≤ k ≤ n } ∪ { w } ,\n• (aki )I =\n{ xki , if a(ai) = f,\nzk, if a(ai) = t, for 1 ≤ k ≤ n and 1 ≤ i ≤ m,\n• tI = w, T I = { (w, z1) } ,\n• SI = {\n((a1i ) I , (a2i ) I), . . . , ((an−1i ) I , (ani ) I), ((ani ) I , (a1i )\nI) | 1 ≤ i ≤ m } ,\n• fIk = uk and gIk =\n{ vk, if a(ak,2) = f,\nuk, if a(ak,2) = t, for 1 ≤ k ≤ n,\n• P I = {\n((akk,1) I , fIk ), ((a k k,2) I , gIk ) | 1 ≤ k ≤ n\n} ,\n• QI = {\n(gIk , (a k k,3) I), (fIk , (a k k,1) I) | 1 ≤ k ≤ n\n} .\nIt is readily checked that I |= K and I 6|= T (t, a1j ), and so K 6|=noUNA T (t, a1j ). q\nThe above result strengthens the NLogSpace lower bound for instance checking in DL-LiteFcore proved by Calvanese et al. (2008).\nCorollary 8.8 Without the UNA, satisfiability of DL-LiteFα , DL-Lite (HF) α and DL-Lite (HF)+ α KBs, α ∈ {core, krom, horn}, with equalities and inequalities is P-complete for both combined and data complexity.\nWithout the UNA, satisfiability of DL-LiteFbool, DL-Lite (HF) bool and DL-Lite (HF)+ bool KBs with equalities and inequalities is NP-complete for combined complexity and P-complete for data complexity.\nProof The upper bounds follow from Lemma 8.6 and the corresponding upper bounds for the UNA case. The NP lower bound for combined complexity is obvious and the polynomial lower bounds follow from Theorem 8.7. q"
    }, {
      "heading" : "8.3 Query Answering: Data Complexity",
      "text" : "The P and coNP upper bounds for query answering without the UNA follow from the results for Horn-SHIQ (Hustadt et al., 2005; Eiter et al., 2008) and SHIQ (Ortiz et al., 2006, 2008; Glimm et al., 2007), respectively (see the discussion at the beginning of Section 7). We present here the following result:\nTheorem 8.9 Without the UNA, positive existential query answering for DL-LiteHhorn KBs with role disjointness, (a)symmetry, (ir)reflexivity constraints and inequalities is in AC0 for data complexity. This problem is LogSpace-complete if, additionally, equalities are allowed in the KBs.\nProof The proof follows the lines of the proof of Theorem 7.1 and uses the observation that models without the UNA give no more answers than their untangled counterparts. More precisely, let KB K′ = (T ′,A′) be as above. Suppose that it is consistent. Let q(~x) be a positive existential query in the signature of K′. Given K′, Lemma 5.17 provides us with a KB K. It is easy to see that K is a DL-LiteHhorn KB extended with inequality constraints. The following is an analogue of Lemma 7.2, which also allows us to get rid of those inequalities:\nLemma 8.10 For every tuple ~a of object names in K′, we have K′ |=noUNA q(~a) iff I |= q(~a) for all untangled models I of K (respecting the UNA).\nProof (⇒) Suppose that K′ |=noUNA q(~a) and I is an untangled model of K. As I respects the UNA, by Lemma 5.17 and in view of satisfiability of K′, which ensures that (44) holds, we then have I |= K′ and therefore, I |= q(~a).\n(⇐) Suppose I ′ |= K′. We construct an interpretation J ′ respecting the UNA as follows. Let ∆J ′ be the disjoint union of ∆I ′ and ob(A). Define a function h : ∆J ′ → ∆I′ by taking h(a) = aI ′ , for each a ∈ ob(A), and h(w) = w, for each w ∈ ∆I′ , and let\naJ ′ = a, AJ ′ = { u | h(u) ∈ AI′ } and PJ ′ = { (u, v) | (h(x), h(v)) ∈ P I′ } ,\nfor each object, concept and role name a, A, P . Clearly, J ′ respects the UNA and J ′ |= K′. It also follows that h is a homomorphism.\nBy Lemma 5.17, there is a model I of K with the same domain as J ′ that coincides with J ′ on all symbols in K′. As I |= q(~a), we must then have J ′ |= q(~a), and since h is a homomorphism, I ′ |= q(~a). Therefore, K′ |=noUNA q(~a) as required. q\nThe remaining part of the proof is exactly as in Theorem 7.1 (since now we may assume that K is a DL-LiteHhorn KB containing no inequality constraints).\nLogSpace-completeness for the case with equalities follows from Lemma 8.1. q"
    }, {
      "heading" : "9. Conclusion",
      "text" : "In this article, we investigated the boundaries of the ‘extended DL-Lite family’ of description logics by providing a thorough and comprehensive understanding of the interaction between various DL-Lite constructs and their impact on the computational complexity of reasoning. We studied 40 different logics, classified according to five mutually orthogonal features: (1) the presence or absence of role inclusion assertions, (2) the form of the allowed concept inclusion assertions, distinguishing four main logical groups called core, Krom, Horn, and Bool, (3) the form of the allowed numeric constraints, ranging from none, to global functionality constraints only, and to arbitrary number restrictions, (4) the presence or absence of the unique name assumption (and equalities and inequalities between object names, if this assumption is dropped), and (5) the presence or absence of standard role constraints such as role disjointness, role symmetry, asymmetry, reflexivity, irreflexivity and transitivity. For all of the resulting logics, we studied the combined and data complexity of KB satisfiability and instance checking, as well as the data complexity of answering positive existential queries.\nThe obtained tight complexity results are illustrated in Figure 6, where the combined complexity of satisfiability is represented by the height of vertical dashed lines, while the data complexity of instance checking by the size and color of the circle on top of these lines (recall that satisfiability and instance checking are reducible to the complement of each other). The data complexity of query answering for the core and Horn logics, shown on the left-hand side of the separating vertical plane, coincides with the data complexity of instance checking; for the Krom and Bool logics, shown on the right-hand side of the plane, query answering is always data-complete for coNP. The upper layer shows the complexity of logics with role inclusions, in which case it does not depend on whether we adopt the UNA or not. The middle and the lower layers deal with the logics without role inclusions when the UNA is dropped or adopted, respectively. In each of these layers, the twelve languages are arranged in the 4 × 3 grid: one axis shows the type of concepts inclusions allowed (Horn, core, Krom, Bool), while the other the type of number restrictions (none, global functionality F or arbitrary N ). Some observations are in order:\n• Under the UNA but without role inclusions, number restrictions do not increase the complexity of reasoning, which depends only on the form of concept inclusions allowed.\n• On the other hand, without any form of number restrictions, the logics can have role inclusions and are insensitive to the UNA; again, the complexity is determined by the shape of concept inclusions only.\n• In either of the above cases, instance checking is in AC0 for data complexity, which means that the problems are first-order rewritable.\n• Without UNA adopted and without either disjunctions or role inclusions, functionality leads to P-completeness of instance checking for data complexity, which suggests its reducibility to Datalog.\n• For data complexity, there is no difference between the core and Horn logics, and between the Krom and Bool ones, which means that the core and Krom logics can be extended with conjunctions on the left-hand side of concept inclusions ‘for free.’\nFinally, for the logics DL-Lite (HF) α and DL-Lite (HN ) α with both (qualified) number restrictions and role inclusions, whose interaction is restricted by conditions (A1)–(A3), the complexity of reasoning always coincides with the complexity of the fragments DL-LiteFα and, respectively, DL-LiteNα without role inclusions, no matter whether we adopt the UNA or not.\nRole disjointness, symmetry and asymmetry constraints can be added to any of the\nlanguages without changing their complexity. In fact, the DL-Lite (HN ) α and DL-Lite (HF) α logics contain all of the above types of constraints together with role reflexivity and irreflexivity. We conjecture that (ir)reflexivity constraints can be added to all other logics without affecting their complexity. However, if we extend any DL-Lite logic with role transitivity constraints, then the combined complexity of satisfiability remains the same, while instance checking and query answering become data-hard for NLogSpace. And the addition of equality between object names—which only makes sense if the UNA is dropped—leads to an increase from membership in AC0 to LogSpace-completeness for data complexity; all other results remain unchanged.\nThe list of DL constructs considered in this paper is far from being complete. For example, it would be of interest to analyze the impact of nominals, role chains and Boolean operators on roles on the computational behavior of the DL-Lite logics. Another interesting and practically important problem is to investigate in depth the interaction between various constructs with the aim of pushing restrictions like (A1)–(A3) as far as possible.\nOne of the main ideas behind the DL-Lite logics was to provide efficient access to large amounts of data through a high-level conceptual interface. This is supposed to be achieved by representing the high-level view of the information managed by the system as a DL-Lite TBox T , the data stored in a relational database as an ABox A, and then rewriting positive existential queries to the knowledge base (T ,A) as standard first-order queries to the database represented by A. Such an approach is believed to be viable because, for a number of DL-Lite logics, the query answering problem is in AC0 for data complexity; cf. Theorems 7.1, 8.9 and Figure 6. The first-order rewriting technique has been implemented in various system, notably in QuOnto (Acciarri et al., 2005; Poggi et al., 2008b), which can query, relying on ontology-to-relational mappings, data stored in any standard relational database management system, and in Owlgres (Stocker & Smith, 2008), which can access an ABox stored in a Postgres database (though, to the best of our knowledge, the latter implementation is incomplete for conjunctive query answering). It is to be noted, however, that the size of the rewritten query can be substantially larger than the size of the original query, which can cause problems even for a very efficient database query engine.\nFor a positive existential query q and TBox T , there are two major sources of high complexity of the first-order formula ϕT ,q in the proof of Theorem 7.1: (i) the formulas ψB(x) computing whether an ABox object is an instance of a concept B (and the formulas\nθR,dr computing whether objects with outgoing R-arrows are instances of B), and (ii) the disjunction over the paths ~σ in the graph GT . In the case of DL-Lite (HN ) core , the size of ψB(x) is linear in |T |, while for DL-Lite(HN )horn it can become exponential (however, various optimizations are possible). The size of the disjunction in (ii) is exponential in the number of non-distinguished variables in q. One way of removing source (i) would be to extend the given database (ABox) A by precomputing the Horn closure of the ABox with respect to the TBox and storing the resulting data in a supplementary database. This approach is advocated by Lutz et al. (2008) for querying databases via the description logic EL. It could also be promising for the Horn fragments of expressive description logics such as SHIQ (Hustadt et al., 2005; Hustadt, Motik, & Sattler, 2007)—containing DL-LiteHFhorn as a sub-language—for which the data complexity of instance checking (Hustadt et al., 2005, 2007) and conjunctive query answering is polynomial (Eiter et al., 2008). The disadvantage of using a supplementary database is the necessity to update it every time the ABox is changed. It would be interesting to investigate this alternative approach for DL-Lite logics and compare it with the approach described above. Another important problem is to characterize those queries for which the disjunction in (ii) can be represented by a formula of polynomial size.\nAs the unique name assumption is replaced in OWL by the constructs sameAs and differentFrom (i.e., ≈ and 6≈), a challenging problem is to investigate possible ways of dealing with equality (inequality does not require any special treatment as shown in the proof of Lemma 8.10). Although reasoning with equality is LogSpace-reducible to reasoning without it (cf. Lemma 8.1), we lose the property of first-order rewritability, and computing equivalence classes under ≈ may be too costly for real-world applications.\nDL-Lite logics are among those few examples of DLs for which usually very complex ‘non-standard’ reasoning problems—such as checking whether one ontology is a conservative extension of another one with respect to a given signature Σ (Kontchakov et al., 2008), computing minimal modules of ontologies with respect to Σ (Kontchakov et al., 2009) or uniform interpolants (Wang, Wang, Topor, & Pan, 2008)—can be supported by practical reasoning tools. However, only first steps have been made in this direction, and more research is needed in order to include these reasoning problems and tools into the standard OWL toolkit. It would be also interesting to investigate the unification problem for DL-Lite logics (Baader & Narendran, 2001).\nFinally, there exist certain parallels between the Horn logics of the DL-Lite family, EL, Horn-SHIQ and the first-order language of tuple and equality generating dependencies, TGDs and EGDs, used in the theory of databases (see, e.g., Gottlob & Nash, 2008). Further investigations of the relationships between these logics may lead to a deeper understanding of the role description logics can play in the database framework."
    }, {
      "heading" : "Acknowledgments",
      "text" : "This research has been partially supported by FET project TONES (Thinking ONtologiES), funded within the EU 6th Framework Programme under contract FP6-7603, and by the large-scale integrating project (IP) OntoRule (ONTOlogies meet Business RULEs ONtologiES), funded by the EC under ICT Call 3 FP7-ICT-2008-3, contract number FP7231875. We thank the referees for their constructive criticism, comments, and suggestions."
    } ],
    "references" : [ {
      "title" : "QuOnto: Querying ontologies",
      "author" : [ "A. Acciarri", "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "M. Palmieri", "R. Rosati" ],
      "venue" : "In Proc. of the 20th Nat. Conf. on Artificial Intelligence (AAAI",
      "citeRegEx" : "Acciarri et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Acciarri et al\\.",
      "year" : 2005
    }, {
      "title" : "Logic programming",
      "author" : [ "K. Apt" ],
      "venue" : "van Leeuwen, J. (Ed.), Handbook of Theoretical Computer Science, Volume B: Formal Models and Sematics, pp. 493–574. Elsevier and MIT Press.",
      "citeRegEx" : "Apt,? 1990",
      "shortCiteRegEx" : "Apt",
      "year" : 1990
    }, {
      "title" : "DL-Lite in the light of first-order logic",
      "author" : [ "A. Artale", "D. Calvanese", "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 22nd Nat. Conf. on Artificial Intelligence (AAAI",
      "citeRegEx" : "Artale et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Artale et al\\.",
      "year" : 2007
    }, {
      "title" : "Reasoning over extended ER models",
      "author" : [ "A. Artale", "D. Calvanese", "R. Kontchakov", "V. Ryzhikov", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 26th Int. Conf. on Conceptual Modeling (ER 2007),",
      "citeRegEx" : "Artale et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Artale et al\\.",
      "year" : 2007
    }, {
      "title" : "Describing database objects in a concept language environment",
      "author" : [ "A. Artale", "F. Cesarini", "G. Soda" ],
      "venue" : "IEEE Trans. on Knowledge and Data Engineering,",
      "citeRegEx" : "Artale et al\\.,? \\Q1996\\E",
      "shortCiteRegEx" : "Artale et al\\.",
      "year" : 1996
    }, {
      "title" : "Evolving objects in temporal information systems",
      "author" : [ "A. Artale", "C. Parent", "S. Spaccapietra" ],
      "venue" : "Ann. of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Artale et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Artale et al\\.",
      "year" : 2007
    }, {
      "title" : "Unification of concepts terms in description logics",
      "author" : [ "F. Baader", "P. Narendran" ],
      "venue" : "J. of Symbolic Computation,",
      "citeRegEx" : "Baader and Narendran,? \\Q2001\\E",
      "shortCiteRegEx" : "Baader and Narendran",
      "year" : 2001
    }, {
      "title" : "The Description Logic Handbook: Theory, Implementation and Applications",
      "author" : [ "F. Baader", "D. Calvanese", "D. McGuinness", "D. Nardi", "P.F. Patel-Schneider" ],
      "venue" : null,
      "citeRegEx" : "Baader et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Baader et al\\.",
      "year" : 2003
    }, {
      "title" : "Rewriting queries using views in description logics",
      "author" : [ "C. Beeri", "A.Y. Levy", "Rousset", "M.-C" ],
      "venue" : "In Proc. of the 16th ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems",
      "citeRegEx" : "Beeri et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Beeri et al\\.",
      "year" : 1997
    }, {
      "title" : "Reasoning on UML class diagrams",
      "author" : [ "D. Berardi", "D. Calvanese", "G. De Giacomo" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Berardi et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Berardi et al\\.",
      "year" : 2005
    }, {
      "title" : "On taxonomic reasoning in conceptual design",
      "author" : [ "S. Bergamaschi", "C. Sartori" ],
      "venue" : "ACM Trans. on Database Systems,",
      "citeRegEx" : "Bergamaschi and Sartori,? \\Q1992\\E",
      "shortCiteRegEx" : "Bergamaschi and Sartori",
      "year" : 1992
    }, {
      "title" : "The complexity of finite functions",
      "author" : [ "R. Boppana", "M. Sipser" ],
      "venue" : "Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity,",
      "citeRegEx" : "Boppana and Sipser,? \\Q1990\\E",
      "shortCiteRegEx" : "Boppana and Sipser",
      "year" : 1990
    }, {
      "title" : "The Classical Decision Problem",
      "author" : [ "E. Börger", "E. Grädel", "Y. Gurevich" ],
      "venue" : "Perspectives in Mathematical Logic. Springer",
      "citeRegEx" : "Börger et al\\.,? \\Q1997\\E",
      "shortCiteRegEx" : "Börger et al\\.",
      "year" : 1997
    }, {
      "title" : "Conceptual modeling with description logics",
      "author" : [ "A. Borgida", "R.J. Brachman" ],
      "venue" : "In Baader et al. (Baader et al., 2003),",
      "citeRegEx" : "Borgida and Brachman,? \\Q2003\\E",
      "shortCiteRegEx" : "Borgida and Brachman",
      "year" : 2003
    }, {
      "title" : "Ontology-based database access",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "R. Rosati" ],
      "venue" : "In Proc. of the 15th Ital. Conf. on Database Systems (SEBD",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "Data integration through DL-LiteA ontologies",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "A. Poggi", "R. Rosati", "M. Ruzzi" ],
      "venue" : "Revised Selected Papers of the 3rd Int. Workshop on Semantics in Data and Knowledge Bases (SDKB 2008),",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2008
    }, {
      "title" : "DL-Lite: Tractable description logics for ontologies",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "In Proc. of the 20th Nat. Conf. on Artificial Intelligence (AAAI",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2005
    }, {
      "title" : "Data complexity of query answering in description logics",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "In Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2006
    }, {
      "title" : "Can OWL model football leagues",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "In Proc. of the 3rd Int. Workshop on OWL: Experiences and Directions (OWLED 2007),",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "Tractable reasoning and efficient query answering in description logics: The DL-Lite family",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "J. of Automated Reasoning,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2007
    }, {
      "title" : "Inconsistency tolerance in P2P data integration: An epistemic logic approach",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "Information Systems,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2008
    }, {
      "title" : "Path-based identification constraints in description logics",
      "author" : [ "D. Calvanese", "G. De Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "In Proc. of the 11th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2008
    }, {
      "title" : "Description logics for information integration",
      "author" : [ "D. Calvanese", "G. De Giacomo", "M. Lenzerini" ],
      "venue" : "Essays in Honour of Robert A. Kowalski, Vol. 2408 of Lecture Notes in Computer Science,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2002
    }, {
      "title" : "A framework for ontology integration",
      "author" : [ "D. Calvanese", "G. De Giacomo", "M. Lenzerini" ],
      "venue" : "The Emerging Semantic Web — Selected Papers from the First Semantic Web Working Symposium,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q2002\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 2002
    }, {
      "title" : "Description logic framework for information integration",
      "author" : [ "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "D. Nardi", "R. Rosati" ],
      "venue" : "In Proc. of the 6th Int. Conf. on the Principles of Knowledge Representation and Reasoning",
      "citeRegEx" : "Calvanese et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 1998
    }, {
      "title" : "Description logics for conceptual data modeling",
      "author" : [ "D. Calvanese", "M. Lenzerini", "D. Nardi" ],
      "venue" : "Logics for Databases and Information Systems,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 1998
    }, {
      "title" : "Unifying class-based representation formalisms",
      "author" : [ "D. Calvanese", "M. Lenzerini", "D. Nardi" ],
      "venue" : "J. of Artificial Intelligence Research,",
      "citeRegEx" : "Calvanese et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Calvanese et al\\.",
      "year" : 1999
    }, {
      "title" : "Filling the gap between OWL 2 QL and QuOnto: ROWLKit",
      "author" : [ "C. Corona", "M. Ruzzi", "D.F. Savo" ],
      "venue" : "In Proc. of the 22nd Int. Workshop on Description Logics (DL 2009),",
      "citeRegEx" : "Corona et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Corona et al\\.",
      "year" : 2009
    }, {
      "title" : "Modular reuse of ontologies: Theory and practice",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "Y. Kazakov", "U. Sattler" ],
      "venue" : "J. of Artificial Intelligence Research,",
      "citeRegEx" : "Grau et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Grau et al\\.",
      "year" : 2008
    }, {
      "title" : "Ontobroker: Ontology based access to distributed and semi-structured information",
      "author" : [ "S. Decker", "M. Erdmann", "D. Fensel", "R. Studer" ],
      "venue" : "Database Semantic: Semantic Issues in Multimedia Systems, chap",
      "citeRegEx" : "Decker et al\\.,? \\Q1999\\E",
      "shortCiteRegEx" : "Decker et al\\.",
      "year" : 1999
    }, {
      "title" : "Scalable grounded conjunctive query evaluation over large and expressive knowledge bases",
      "author" : [ "J. Dolby", "A. Fokoue", "A. Kalyanpur", "L. Ma", "E. Schonberg", "K. Srinivas", "X. Sun" ],
      "venue" : "In Proc. of the 7th Int. Semantic Web Conf. (ISWC 2008),",
      "citeRegEx" : "Dolby et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Dolby et al\\.",
      "year" : 2008
    }, {
      "title" : "Query answering in the description logic Horn-SHIQ",
      "author" : [ "T. Eiter", "G. Gottlob", "M. Ortiz", "M. Šimkus" ],
      "venue" : "In Proc. of the 11th Eur. Conference on Logics in Artificial Intelligence (JELIA",
      "citeRegEx" : "Eiter et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Eiter et al\\.",
      "year" : 2008
    }, {
      "title" : "The i.com tool for intelligent conceptual modeling",
      "author" : [ "E. Franconi", "G. Ng" ],
      "venue" : "In Proc. of the 7th Int. Workshop on Knowledge Representation meets Databases (KRDB 2000),",
      "citeRegEx" : "Franconi and Ng,? \\Q2000\\E",
      "shortCiteRegEx" : "Franconi and Ng",
      "year" : 2000
    }, {
      "title" : "Computers and Intractability: A Guide to the Theory of NP-Completeness",
      "author" : [ "M. Garey", "D. Johnson" ],
      "venue" : null,
      "citeRegEx" : "Garey and Johnson,? \\Q1979\\E",
      "shortCiteRegEx" : "Garey and Johnson",
      "year" : 1979
    }, {
      "title" : "Did I damage my ontology? A case for conservative extensions in description logics",
      "author" : [ "S. Ghilardi", "C. Lutz", "F. Wolter" ],
      "venue" : "Proc. of the 10th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Ghilardi et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Ghilardi et al\\.",
      "year" : 2006
    }, {
      "title" : "Conjunctive query answering for the description logic SHIQ",
      "author" : [ "B. Glimm", "I. Horrocks", "C. Lutz", "U. Sattler" ],
      "venue" : "In Proc. of the 20th Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Glimm et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Glimm et al\\.",
      "year" : 2007
    }, {
      "title" : "The use of CARIN language and algorithms for information integration: The Picsel system",
      "author" : [ "F. Goasdoue", "V. Lattes", "Rousset", "M.-C" ],
      "venue" : "Int. J. of Cooperative Information Systems,",
      "citeRegEx" : "Goasdoue et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Goasdoue et al\\.",
      "year" : 2000
    }, {
      "title" : "Efficient core computation in data exchange",
      "author" : [ "G. Gottlob", "A. Nash" ],
      "venue" : "J. of the ACM,",
      "citeRegEx" : "Gottlob and Nash,? \\Q2008\\E",
      "shortCiteRegEx" : "Gottlob and Nash",
      "year" : 2008
    }, {
      "title" : "RDF semantics",
      "author" : [ "P. Hayes" ],
      "venue" : "W3C Recommendation. http://www.w3.org/TR/ rdf-mt/.",
      "citeRegEx" : "Hayes,? 2004",
      "shortCiteRegEx" : "Hayes",
      "year" : 2004
    }, {
      "title" : "A portrait of the Semantic Web in action",
      "author" : [ "J. Heflin", "J. Hendler" ],
      "venue" : "IEEE Intelligent Systems,",
      "citeRegEx" : "Heflin and Hendler,? \\Q2001\\E",
      "shortCiteRegEx" : "Heflin and Hendler",
      "year" : 2001
    }, {
      "title" : "Ontology reasoning with large data repositories",
      "author" : [ "S. Heymans", "L. Ma", "D. Anicic", "Z. Ma", "N. Steinmetz", "Y. Pan", "J. Mei", "A. Fokoue", "A. Kalyanpur", "A. Kershenbaum", "E. Schonberg", "K. Srinivas", "C. Feier", "G. Hench", "B. Wetzstein", "U. Keller" ],
      "venue" : "Ontology Management,",
      "citeRegEx" : "Heymans et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Heymans et al\\.",
      "year" : 2008
    }, {
      "title" : "Practical reasoning for very expressive description logics",
      "author" : [ "I. Horrocks", "U. Sattler", "S. Tobies" ],
      "venue" : "J. of the Interest Group in Pure and Applied Logic,",
      "citeRegEx" : "Horrocks et al\\.,? \\Q2000\\E",
      "shortCiteRegEx" : "Horrocks et al\\.",
      "year" : 2000
    }, {
      "title" : "Reasoning in description logics by a reduction to disjunctive Datalog",
      "author" : [ "U. Hustadt", "B. Motik", "U. Sattler" ],
      "venue" : "J. of Automated Reasoning,",
      "citeRegEx" : "Hustadt et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Hustadt et al\\.",
      "year" : 2007
    }, {
      "title" : "Data complexity of reasoning in very expressive description logics",
      "author" : [ "U. Hustadt", "B. Motik", "U. Sattler" ],
      "venue" : "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Hustadt et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Hustadt et al\\.",
      "year" : 2005
    }, {
      "title" : "Descriptive Complexity",
      "author" : [ "N. Immerman" ],
      "venue" : "Springer.",
      "citeRegEx" : "Immerman,? 1999",
      "shortCiteRegEx" : "Immerman",
      "year" : 1999
    }, {
      "title" : "Resource description framework (RDF): Concepts and abstract syntax",
      "author" : [ "G. Klyne", "J.J. Carroll" ],
      "venue" : "W3C Recommendation",
      "citeRegEx" : "Klyne and Carroll,? \\Q2004\\E",
      "shortCiteRegEx" : "Klyne and Carroll",
      "year" : 2004
    }, {
      "title" : "Minimal module extraction from DL-Lite ontologies using QBF solvers",
      "author" : [ "R. Kontchakov", "L. Pulina", "U. Sattler", "T. Schneider", "P. Selmer", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2009
    }, {
      "title" : "Can you tell the difference between DL-Lite ontologies",
      "author" : [ "R. Kontchakov", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "In Proc. of the 11th Int. Conf. on the Principles of Knowledge Representation and Reasoning (KR",
      "citeRegEx" : "Kontchakov et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Kontchakov et al\\.",
      "year" : 2008
    }, {
      "title" : "DL-Lite and role inclusions",
      "author" : [ "R. Kontchakov", "M. Zakharyaschev" ],
      "venue" : "Proc. of the 3rd Asian Semantic Web Conf. (ASWC 2008),",
      "citeRegEx" : "Kontchakov and Zakharyaschev,? \\Q2008\\E",
      "shortCiteRegEx" : "Kontchakov and Zakharyaschev",
      "year" : 2008
    }, {
      "title" : "Theory of Computation",
      "author" : [ "D. Kozen" ],
      "venue" : "Springer.",
      "citeRegEx" : "Kozen,? 2006",
      "shortCiteRegEx" : "Kozen",
      "year" : 2006
    }, {
      "title" : "Data integration: A theoretical perspective",
      "author" : [ "M. Lenzerini" ],
      "venue" : "Proc. of the 21st ACM SIGACT SIGMOD SIGART Symp. on Principles of Database Systems (PODS 2002), pp. 233–246.",
      "citeRegEx" : "Lenzerini,? 2002",
      "shortCiteRegEx" : "Lenzerini",
      "year" : 2002
    }, {
      "title" : "Combining Horn rules and description logics in CARIN",
      "author" : [ "A.Y. Levy", "Rousset", "M.-C" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Levy et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Levy et al\\.",
      "year" : 1998
    }, {
      "title" : "Conceptual modelling for configuration: A description logic-based approach. Artificial Intelligence for Engineering Design, Analysis, and Manufacturing",
      "author" : [ "D. McGuinness", "J.R. Wright" ],
      "venue" : "Special Issue on Configuration,",
      "citeRegEx" : "McGuinness and Wright,? \\Q1998\\E",
      "shortCiteRegEx" : "McGuinness and Wright",
      "year" : 1998
    }, {
      "title" : "Knowledge integration for description logics",
      "author" : [ "T. Meyer", "K. Lee", "R. Booth" ],
      "venue" : "In Proc. of the 20th Nat. Conf. on Artificial Intelligence (AAAI",
      "citeRegEx" : "Meyer et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Meyer et al\\.",
      "year" : 2005
    }, {
      "title" : "Semantic integration: A survey of ontology-based approaches",
      "author" : [ "N.F. Noy" ],
      "venue" : "SIGMOD Record, 33 (4), 65–70.",
      "citeRegEx" : "Noy,? 2004",
      "shortCiteRegEx" : "Noy",
      "year" : 2004
    }, {
      "title" : "Characterizing data complexity for conjunctive query answering in expressive description logics",
      "author" : [ "M. Ortiz", "D. Calvanese", "T. Eiter" ],
      "venue" : "In Proc. of the 21st Nat. Conf. on Artificial Intelligence (AAAI",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2006\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2006
    }, {
      "title" : "Data complexity of query answering in expressive description logics via tableaux",
      "author" : [ "M. Ortiz", "D. Calvanese", "T. Eiter" ],
      "venue" : "J. of Automated Reasoning,",
      "citeRegEx" : "Ortiz et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Ortiz et al\\.",
      "year" : 2008
    }, {
      "title" : "Computational Complexity",
      "author" : [ "C. Papadimitriou" ],
      "venue" : "Addison-Wesley.",
      "citeRegEx" : "Papadimitriou,? 1994",
      "shortCiteRegEx" : "Papadimitriou",
      "year" : 1994
    }, {
      "title" : "A comparison of query rewriting techniques for DL-Lite",
      "author" : [ "H. Pérez-Urbina", "B. Motik", "I. Horrocks" ],
      "venue" : "In Proc. of the 22nd Int. Workshop on Description Logics (DL 2009),",
      "citeRegEx" : "Pérez.Urbina et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Pérez.Urbina et al\\.",
      "year" : 2009
    }, {
      "title" : "Linking data to ontologies",
      "author" : [ "A. Poggi", "D. Lembo", "D. Calvanese", "G. De Giacomo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "J. on Data Semantics,",
      "citeRegEx" : "Poggi et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Poggi et al\\.",
      "year" : 2008
    }, {
      "title" : "Ontology-based database access with DIG-Mastro and the OBDA Plugin for Protégé",
      "author" : [ "A. Poggi", "M. Rodriguez", "M. Ruzzi" ],
      "venue" : "Proc. of the 4th Int. Workshop on OWL: Experiences and Directions (OWLED 2008 DC)",
      "citeRegEx" : "Poggi et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Poggi et al\\.",
      "year" : 2008
    }, {
      "title" : "A Concise Introduction to Mathematical Logic",
      "author" : [ "W. Rautenberg" ],
      "venue" : "Springer.",
      "citeRegEx" : "Rautenberg,? 2006",
      "shortCiteRegEx" : "Rautenberg",
      "year" : 2006
    }, {
      "title" : "Undirected connectivity in log-space",
      "author" : [ "O. Reingold" ],
      "venue" : "J. of the ACM, 55 (4).",
      "citeRegEx" : "Reingold,? 2008",
      "shortCiteRegEx" : "Reingold",
      "year" : 2008
    }, {
      "title" : "On the complexity of the instance checking problem in concept languages with existential quantification",
      "author" : [ "A. Schaerf" ],
      "venue" : "J. of Intelligent Information Systems, 2, 265–278.",
      "citeRegEx" : "Schaerf,? 1993",
      "shortCiteRegEx" : "Schaerf",
      "year" : 1993
    }, {
      "title" : "Attributive concept descriptions with complements",
      "author" : [ "M. Schmidt-Schauß", "G. Smolka" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Schmidt.Schauß and Smolka,? \\Q1991\\E",
      "shortCiteRegEx" : "Schmidt.Schauß and Smolka",
      "year" : 1991
    }, {
      "title" : "Owlgres: A scalable OWL reasoner",
      "author" : [ "M. Stocker", "M. Smith" ],
      "venue" : "In Proc. of the 5th Int. Workshop on OWL: Experiences and Directions (OWLED",
      "citeRegEx" : "Stocker and Smith,? \\Q2008\\E",
      "shortCiteRegEx" : "Stocker and Smith",
      "year" : 2008
    }, {
      "title" : "Complexity results and practical algorithms for logics in Knowledge Representation",
      "author" : [ "S. Tobies" ],
      "venue" : "Ph.D. thesis, LuFG Theoretical Computer Science, RWTH-Aachen, Germany.",
      "citeRegEx" : "Tobies,? 2001",
      "shortCiteRegEx" : "Tobies",
      "year" : 2001
    }, {
      "title" : "On the interaction between inverse features and pathfunctional dependencies in description logics",
      "author" : [ "D. Toman", "G.E. Weddell" ],
      "venue" : "In Proc. of the 19th Int. Joint Conf. on Artificial Intelligence (IJCAI",
      "citeRegEx" : "Toman and Weddell,? \\Q2005\\E",
      "shortCiteRegEx" : "Toman and Weddell",
      "year" : 2005
    }, {
      "title" : "On keys and functional dependencies as first-class citizens in description logics",
      "author" : [ "D. Toman", "G.E. Weddell" ],
      "venue" : "J. of Automated Reasoning,",
      "citeRegEx" : "Toman and Weddell,? \\Q2008\\E",
      "shortCiteRegEx" : "Toman and Weddell",
      "year" : 2008
    }, {
      "title" : "The complexity of relational query languages (extended abstract)",
      "author" : [ "M. Vardi" ],
      "venue" : "Proc. of the 14th ACM SIGACT Symp. on Theory of Computing (STOC’82), pp. 137–146.",
      "citeRegEx" : "Vardi,? 1982",
      "shortCiteRegEx" : "Vardi",
      "year" : 1982
    }, {
      "title" : "Introduction to Circuit Complexity: A Uniform Approach",
      "author" : [ "H. Vollmer" ],
      "venue" : "Springer.",
      "citeRegEx" : "Vollmer,? 1999",
      "shortCiteRegEx" : "Vollmer",
      "year" : 1999
    }, {
      "title" : "Forgetting concepts in DL-Lite",
      "author" : [ "Z. Wang", "K. Wang", "R.W. Topor", "J.Z. Pan" ],
      "venue" : "Proc. of the 5th Eur. Semantic Web Conf. (ESWC 2008),",
      "citeRegEx" : "Wang et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Wang et al\\.",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 54,
      "context" : "• information and data integration (Beeri, Levy, & Rousset, 1997; Levy & Rousset, 1998; Goasdoue, Lattes, & Rousset, 2000; Calvanese et al., 1998a, 2002a, 2002b, 2008; Noy, 2004; Meyer, Lee, & Booth, 2005),",
      "startOffset" : 35,
      "endOffset" : 205
    }, {
      "referenceID" : 30,
      "context" : "• ontology-based data access (Dolby et al., 2008; Poggi et al., 2008a; Heymans et al., 2008),",
      "startOffset" : 29,
      "endOffset" : 92
    }, {
      "referenceID" : 40,
      "context" : "• ontology-based data access (Dolby et al., 2008; Poggi et al., 2008a; Heymans et al., 2008),",
      "startOffset" : 29,
      "endOffset" : 92
    }, {
      "referenceID" : 15,
      "context" : "In this setting, the TBox constitutes the conceptual, high-level view of the information managed by the system, and the ABox is physically stored in a relational database and accessed using the standard relational database technology (Poggi et al., 2008a; Calvanese et al., 2008).",
      "startOffset" : 234,
      "endOffset" : 279
    }, {
      "referenceID" : 14,
      "context" : ", 2008a; Calvanese et al., 2008). The fundamental inference service in this case is answering queries to the ABox with the constraints in the TBox taken into account. The kind of queries that have most often been considered are first-order conjunctive queries, which correspond to the commonly used Select-Project-Join SQL queries. The key properties for such an approach to be viable in practice are (i) efficiency of query evaluation, with the ideal target being traditional database query processing, and (ii) that query evaluation can be done by leveraging the relational technology already used for storing the data. With these objectives in mind, a series of description logics—the DL-Lite family—has recently been proposed and investigated by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2005, 2006, 2008a), and later extended by Artale, Calvanese, Kontchakov, and Zakharyaschev (2007a), Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, and Rosati (2008a).",
      "startOffset" : 9,
      "endOffset" : 902
    }, {
      "referenceID" : 14,
      "context" : ", 2008a; Calvanese et al., 2008). The fundamental inference service in this case is answering queries to the ABox with the constraints in the TBox taken into account. The kind of queries that have most often been considered are first-order conjunctive queries, which correspond to the commonly used Select-Project-Join SQL queries. The key properties for such an approach to be viable in practice are (i) efficiency of query evaluation, with the ideal target being traditional database query processing, and (ii) that query evaluation can be done by leveraging the relational technology already used for storing the data. With these objectives in mind, a series of description logics—the DL-Lite family—has recently been proposed and investigated by Calvanese, De Giacomo, Lembo, Lenzerini, and Rosati (2005, 2006, 2008a), and later extended by Artale, Calvanese, Kontchakov, and Zakharyaschev (2007a), Poggi, Lembo, Calvanese, De Giacomo, Lenzerini, and Rosati (2008a). Most logics of the family meet the requirements above and, at the same time, are capable of representing many important types of constraints used in conceptual modeling.",
      "startOffset" : 9,
      "endOffset" : 970
    }, {
      "referenceID" : 47,
      "context" : "It has also been demonstrated (Kontchakov et al., 2008) that developing, analyzing and re-using DL-Lite ontologies (TBoxes) can be supported by efficient tools capable of checking various types of entailment between such ontologies with respect to given vocabularies, in particular, by minimal module extraction tools (Kontchakov et al.",
      "startOffset" : 30,
      "endOffset" : 55
    }, {
      "referenceID" : 46,
      "context" : ", 2008) that developing, analyzing and re-using DL-Lite ontologies (TBoxes) can be supported by efficient tools capable of checking various types of entailment between such ontologies with respect to given vocabularies, in particular, by minimal module extraction tools (Kontchakov et al., 2009)—which do not yet exist for richer languages.",
      "startOffset" : 270,
      "endOffset" : 295
    }, {
      "referenceID" : 17,
      "context" : "Although some attempts have been made (Calvanese et al., 2006; Artale et al., 2007a; Kontchakov & Zakharyaschev, 2008) to put the original DL-Lite logics into a more general perspective and investigate their extensions with a variety of DL constructs required for conceptual modeling, the resulting picture still remains rather fragmentary and far from comprehensive.",
      "startOffset" : 38,
      "endOffset" : 118
    }, {
      "referenceID" : 14,
      "context" : "It also turns out that dropping the UNA results in P-hardness of reasoning (for both combined and data complexity) in the presence of functionality constraints (NLogSpace-hardness was shown by Calvanese et al., 2008), and in NP-hardness if arbitrary number restrictions are allowed. Another interesting finding is the dramatic impact of role inclusions, when combined with number restrictions (or even functionality constraints), on the computational complexity of reasoning. As was already observed by Calvanese et al. (2006), such a combination increases data complexity of instance checking from membership in LogSpace to",
      "startOffset" : 193,
      "endOffset" : 527
    }, {
      "referenceID" : 47,
      "context" : "Note, by the way, that logics with Bool concept inclusions turn out to be quite useful in conceptual modeling and reasonably manageable computationally (Kontchakov et al., 2008).",
      "startOffset" : 152,
      "endOffset" : 177
    }, {
      "referenceID" : 59,
      "context" : "To retain both role inclusions and functionality constraints in the language and keep complexity within the required limits, Poggi et al. (2008a) introduced another DL-Lite dialect, called DL-LiteA, which restricts the interaction between role inclusions and functionality constraints.",
      "startOffset" : 125,
      "endOffset" : 146
    }, {
      "referenceID" : 7,
      "context" : "Description Logic (Baader et al., 2003) is a family of logics that have been studied and used in knowledge representation and reasoning since the 1980s.",
      "startOffset" : 18,
      "endOffset" : 39
    }, {
      "referenceID" : 16,
      "context" : "2 for details), while maintaining good computational properties of standard DL reasoning tasks (Calvanese et al., 2005).",
      "startOffset" : 95,
      "endOffset" : 119
    }, {
      "referenceID" : 59,
      "context" : "A compromise can be found by artificially limiting the interplay between role inclusions and number restrictions in a way similar to the logic DL-LiteA proposed by Poggi et al. (2008a). For a TBox T , let vT denote the reflexive and transitive closure of the relation { (R,R′), (inv(R), inv(R′)) | R v R′ ∈ T }",
      "startOffset" : 164,
      "endOffset" : 185
    }, {
      "referenceID" : 9,
      "context" : "A tight correspondence between conceptual modeling formalisms, such as the ER model and UML class diagrams, and various description logics has been pointed out in various papers (e.g., Calvanese et al., 1998b, 1999; Borgida & Brachman, 2003; Berardi et al., 2005).",
      "startOffset" : 178,
      "endOffset" : 263
    }, {
      "referenceID" : 2,
      "context" : "Here we give an example showing how DL-Lite logics can be used for conceptual modeling purposes; for more details see the work by Artale et al. (2007b).",
      "startOffset" : 130,
      "endOffset" : 152
    }, {
      "referenceID" : 7,
      "context" : "As is well known in DL (Baader et al., 2003), many other reasoning tasks for description logics are reducible to the satisfiability problem.",
      "startOffset" : 23,
      "endOffset" : 44
    }, {
      "referenceID" : 69,
      "context" : "If, however, only the ABox A is counted as an input, while the TBox T (and the query) is regarded to be fixed, then our concern is data complexity (Vardi, 1982).",
      "startOffset" : 147,
      "endOffset" : 160
    }, {
      "referenceID" : 54,
      "context" : "On the other hand, data complexity is preferable in all those cases where the TBox is fixed or its size (and the size of the query) is negligible compared to the size of the ABox, which is the case, for instance, in the context of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy, 2004; Lenzerini, 2002; Calvanese et al., 2008).",
      "startOffset" : 361,
      "endOffset" : 454
    }, {
      "referenceID" : 50,
      "context" : "On the other hand, data complexity is preferable in all those cases where the TBox is fixed or its size (and the size of the query) is negligible compared to the size of the ABox, which is the case, for instance, in the context of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy, 2004; Lenzerini, 2002; Calvanese et al., 2008).",
      "startOffset" : 361,
      "endOffset" : 454
    }, {
      "referenceID" : 15,
      "context" : "On the other hand, data complexity is preferable in all those cases where the TBox is fixed or its size (and the size of the query) is negligible compared to the size of the ABox, which is the case, for instance, in the context of ontology-based data access (Calvanese, De Giacomo, Lembo, Lenzerini, Poggi, & Rosati, 2007) and other data intensive applications (Decker, Erdmann, Fensel, & Studer, 1999; Noy, 2004; Lenzerini, 2002; Calvanese et al., 2008).",
      "startOffset" : 361,
      "endOffset" : 454
    }, {
      "referenceID" : 57,
      "context" : "Their definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979; Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006).",
      "startOffset" : 57,
      "endOffset" : 135
    }, {
      "referenceID" : 70,
      "context" : "Their definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979; Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006).",
      "startOffset" : 57,
      "endOffset" : 135
    }, {
      "referenceID" : 49,
      "context" : "Their definitions can be found in the standard textbooks (e.g., Garey & Johnson, 1979; Papadimitriou, 1994; Vollmer, 1999; Kozen, 2006).",
      "startOffset" : 57,
      "endOffset" : 135
    }, {
      "referenceID" : 70,
      "context" : "A typical example of an AC problem is evaluation of first-order queries over databases (or model checking of first-order sentences over finite models), where only the database (first-order model) is regarded as the input and the query (first-order sentence) is assumed to be fixed (Abiteboul, Hull, & Vianu, 1995; Vollmer, 1999).",
      "startOffset" : 281,
      "endOffset" : 328
    }, {
      "referenceID" : 62,
      "context" : "On the other hand, the undirected graph reachability problem is known to be in LogSpace (Reingold, 2008) but not in AC.",
      "startOffset" : 88,
      "endOffset" : 104
    }, {
      "referenceID" : 63,
      "context" : "[A] complexity of the respective fragment of propositional Boolean logic [B] follows from the proof of the data complexity result for instance checking in ALE (Schaerf, 1993) [C] (Calvanese et al.",
      "startOffset" : 159,
      "endOffset" : 174
    }, {
      "referenceID" : 17,
      "context" : "[A] complexity of the respective fragment of propositional Boolean logic [B] follows from the proof of the data complexity result for instance checking in ALE (Schaerf, 1993) [C] (Calvanese et al., 2006) [D] follows from Horn-SHIQ (Hustadt, Motik, & Sattler, 2005; Eiter, Gottlob, Ortiz, & Šimkus, 2008) [E] follows from SHIQ (Ortiz, Calvanese, & Eiter, 2006, 2008; Glimm, Horrocks, Lutz, & Sattler, 2007) [F] follows from SHIQ (Tobies, 2001)",
      "startOffset" : 179,
      "endOffset" : 203
    }, {
      "referenceID" : 66,
      "context" : ", 2006) [D] follows from Horn-SHIQ (Hustadt, Motik, & Sattler, 2005; Eiter, Gottlob, Ortiz, & Šimkus, 2008) [E] follows from SHIQ (Ortiz, Calvanese, & Eiter, 2006, 2008; Glimm, Horrocks, Lutz, & Sattler, 2007) [F] follows from SHIQ (Tobies, 2001)",
      "startOffset" : 232,
      "endOffset" : 246
    }, {
      "referenceID" : 38,
      "context" : "It may be worth mentioning that DL-Litecore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004).",
      "startOffset" : 75,
      "endOffset" : 111
    }, {
      "referenceID" : 1,
      "context" : "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v ¬B2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore.",
      "startOffset" : 50,
      "endOffset" : 188
    }, {
      "referenceID" : 1,
      "context" : "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v ¬B2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively.",
      "startOffset" : 50,
      "endOffset" : 531
    }, {
      "referenceID" : 1,
      "context" : "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v ¬B2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2).",
      "startOffset" : 50,
      "endOffset" : 683
    }, {
      "referenceID" : 1,
      "context" : "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v ¬B2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2). The computational behavior of the new logic turned out to be the same as that of DL-Litecore. It may be worth mentioning that DL-Litecore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004). Note also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity.",
      "startOffset" : 50,
      "endOffset" : 1080
    }, {
      "referenceID" : 1,
      "context" : "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v ¬B2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2). The computational behavior of the new logic turned out to be the same as that of DL-Litecore. It may be worth mentioning that DL-Litecore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004). Note also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity. We conjecture that similar results can be obtained for the other DL-Lite logics introduced in this paper. Artale et al. (2007b) demonstrated how n-ary relations can be represented in DL-Litecore by means of reification.",
      "startOffset" : 50,
      "endOffset" : 1413
    }, {
      "referenceID" : 1,
      "context" : "Thus, almost all concept inclusions required for capturing UML class diagrams are of the form B1 v B2 or B1 v ¬B2. These observations motivated the introduction by Calvanese et al. (2005) of the first DL-Lite logic, which in our new nomenclature corresponds to DL-Litecore. Their main results were a polynomial-time upper bound for the combined complexity of KB satisfiability and a LogSpace upper bound for the data complexity of conjunctive query answering (under the UNA). These results were extended by Calvanese et al. (2006) to two larger languages: DL-Litehorn and DL-Lite H horn, which were originally called DL-Liteu,F and DL-Liteu,R, respectively. Calvanese et al. (2007b) introduced another member of the DL-Lite family (named DL-LiteR), which extended DL-Lite H core with role disjointness axioms of the form Dis(R1, R2). The computational behavior of the new logic turned out to be the same as that of DL-Litecore. It may be worth mentioning that DL-Litecore covers the DL fragment of RDFS (Klyne & Carroll, 2004; Hayes, 2004). Note also that Calvanese et al. (2006) considered the variants of both DL-Liteu,F and DL-Liteu,R with arbitrary n-ary relations (not only the usual binary roles) and showed that query answering in them is still in LogSpace for data complexity. We conjecture that similar results can be obtained for the other DL-Lite logics introduced in this paper. Artale et al. (2007b) demonstrated how n-ary relations can be represented in DL-Litecore by means of reification. A further variant of DL-Lite, called DL-LiteA (‘A’ for attributes), was introduced by Poggi et al. (2008a) with the aim of capturing as many features of conceptual modeling formalisms as possible, while still maintaining the computational properties of the basic variants of DL-Lite.",
      "startOffset" : 50,
      "endOffset" : 1612
    }, {
      "referenceID" : 14,
      "context" : "7, we prove that satisfiability of DL-LiteHF core KBs is ExpTime-hard for combined complexity, while instance checking is data-hard for P (NLogSpace-hardness was shown by Calvanese et al., 2006). In DL-LiteA, to keep query answering in AC 0 for data complexity and satisfiability in NLogSpace for combined complexity, functional roles (and attributes) are not allowed to be specialized, i.e., used positively on the right-hand side of role (and attribute) inclusion axioms. So, condition (A3) is a slight generalization of this restriction. DL-LiteA also allows axioms of the form B v ∃R.C for non-functional roles R, which is covered by conditions (A1) and (A2). Thus, DL-LiteA can be regarded as a proper fragment of both DL-Lite (HF) core and DL-Lite (HN ) horn . We show in Sections 5.3 and 7 that these three languages enjoy very similar computational properties under the UNA: tractable satisfiability and query answering in AC. We conclude this section with a picture in Figure 3 illustrating the landscape of DLLite-related logics by grouping them according to the data complexity of positive existential query answering under the UNA. The original eight DL-Lite logics, called by Calvanese et al. (2007b) ‘the DL-Lite family,’ are shown in the bottom sector of the picture (the logics DL-Lite+A and DL-Lite + A,u extend DL-LiteA and DL-LiteA,u with identification constraints, which are out of the scope of this article).",
      "startOffset" : 171,
      "endOffset" : 1214
    }, {
      "referenceID" : 14,
      "context" : "7, we prove that satisfiability of DL-LiteHF core KBs is ExpTime-hard for combined complexity, while instance checking is data-hard for P (NLogSpace-hardness was shown by Calvanese et al., 2006). In DL-LiteA, to keep query answering in AC 0 for data complexity and satisfiability in NLogSpace for combined complexity, functional roles (and attributes) are not allowed to be specialized, i.e., used positively on the right-hand side of role (and attribute) inclusion axioms. So, condition (A3) is a slight generalization of this restriction. DL-LiteA also allows axioms of the form B v ∃R.C for non-functional roles R, which is covered by conditions (A1) and (A2). Thus, DL-LiteA can be regarded as a proper fragment of both DL-Lite (HF) core and DL-Lite (HN ) horn . We show in Sections 5.3 and 7 that these three languages enjoy very similar computational properties under the UNA: tractable satisfiability and query answering in AC. We conclude this section with a picture in Figure 3 illustrating the landscape of DLLite-related logics by grouping them according to the data complexity of positive existential query answering under the UNA. The original eight DL-Lite logics, called by Calvanese et al. (2007b) ‘the DL-Lite family,’ are shown in the bottom sector of the picture (the logics DL-Lite+A and DL-Lite + A,u extend DL-LiteA and DL-LiteA,u with identification constraints, which are out of the scope of this article). Their nearest relatives are the logic DL-Lite (HN ) horn and its fragments, which are all in AC as well. The next layer contains the logics DL-LiteHF core and DL-LiteHF horn, in which query answering is data-complete for P (no matter whether the UNA is adopted or not). In fact, these logics are fragments of the much more expressive DL Horn-SHIQ, which was shown to enjoy the same data complexity of query answering by Eiter et al. (2008). It remains to be seen whether polynomial query answering is practically feasible; recent experiments with the DL EL (Lutz, Toman, & Wolter, 2008) indicate that this may indeed be the case.",
      "startOffset" : 171,
      "endOffset" : 1871
    }, {
      "referenceID" : 66,
      "context" : "Satisfiability: Combined Complexity DL-LiteHN bool is clearly a sub-logic of the description logic SHIQ, the satisfiability problem for which is known to be ExpTime-complete (Tobies, 2001).",
      "startOffset" : 174,
      "endOffset" : 188
    }, {
      "referenceID" : 12,
      "context" : "We shall also see that the translations of Horn and Krom KBs into QL belong to the Horn and Krom fragments of QL, respectively, which are known to be P- and NLogSpace-complete (see, e.g., Papadimitriou, 1994; Börger et al., 1997).",
      "startOffset" : 176,
      "endOffset" : 229
    }, {
      "referenceID" : 12,
      "context" : "As for the lower bound, it suffices to recall that the NLogSpace-hardness for satisfiability of propositional Krom formulas is proved by reduction of the directed graph reachability problem using only ‘core’ propositional formulas (Börger et al., 1997), and so satisfiability in all of the above logics is NLogSpace-hard.",
      "startOffset" : 231,
      "endOffset" : 252
    }, {
      "referenceID" : 66,
      "context" : "In this section we show that the satisfiability problem for DL-LiteHF core KBs is ExpTime-hard, which matches the upper bound for satisfiability of DL-LiteHN bool KBs even under binary coding of natural numbers (Tobies, 2001).",
      "startOffset" : 211,
      "endOffset" : 225
    }, {
      "referenceID" : 35,
      "context" : "Indeed, as follows from Theorem 10 of Glimm et al. (2007), KB satisfiability in the extension of SHIQ with role conjunction is in ExpTime if the length of role conjunctions is bounded by some constant (in our case, this constant is 2 because Dis(R1, R2) can be encoded by ∃(R1 u R2).",
      "startOffset" : 38,
      "endOffset" : 58
    }, {
      "referenceID" : 69,
      "context" : "According to the classification suggested by Vardi (1982), we have been considering its combined complexity.",
      "startOffset" : 45,
      "endOffset" : 58
    }, {
      "referenceID" : 52,
      "context" : "As follows from the results of Ortiz et al. (2006) for SHIQ, instance checking (and in fact query answering) for DL-LiteHN bool is in coNP for data complexity, while the results of Hustadt et al.",
      "startOffset" : 31,
      "endOffset" : 51
    }, {
      "referenceID" : 41,
      "context" : "(2006) for SHIQ, instance checking (and in fact query answering) for DL-LiteHN bool is in coNP for data complexity, while the results of Hustadt et al. (2005) and Eiter et al.",
      "startOffset" : 137,
      "endOffset" : 159
    }, {
      "referenceID" : 31,
      "context" : "(2005) and Eiter et al. (2008) for Horn-SHIQ imply a polynomial-time upper bound for DL-LiteHF horn.",
      "startOffset" : 11,
      "endOffset" : 31
    }, {
      "referenceID" : 63,
      "context" : "Proof The proof is by reduction of the unsatisfiability problem for 2+2CNF, which is known to be coNP-complete (Schaerf, 1993).",
      "startOffset" : 111,
      "endOffset" : 126
    }, {
      "referenceID" : 14,
      "context" : "Our next lower bound would follow from Theorem 6, item 2 in the work of Calvanese et al. (2006); unfortunately, the proof there is incorrect and cannot be repaired.",
      "startOffset" : 72,
      "endOffset" : 96
    }, {
      "referenceID" : 17,
      "context" : "(2008) for Horn-SHIQ, while for DL-Litehorn it is in AC 0 (Calvanese et al., 2006).",
      "startOffset" : 58,
      "endOffset" : 82
    }, {
      "referenceID" : 38,
      "context" : "The positive existential query answering problem is known to be data-complete for coNP in the case of DL-LiteHN bool : the upper bound follows from the results of Ortiz et al. (2006), while the lower bound was established for DL-Litekrom by Calvanese et al.",
      "startOffset" : 163,
      "endOffset" : 183
    }, {
      "referenceID" : 14,
      "context" : "(2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993).",
      "startOffset" : 65,
      "endOffset" : 89
    }, {
      "referenceID" : 14,
      "context" : "(2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993). In the case of DL-LiteHF horn, query answering is data-complete for P, as follows from the results of Hustadt et al.",
      "startOffset" : 65,
      "endOffset" : 105
    }, {
      "referenceID" : 14,
      "context" : "(2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993). In the case of DL-LiteHF horn, query answering is data-complete for P, as follows from the results of Hustadt et al. (2005) and Eiter et al.",
      "startOffset" : 65,
      "endOffset" : 230
    }, {
      "referenceID" : 14,
      "context" : "(2006), while the lower bound was established for DL-Litekrom by Calvanese et al. (2006), Schaerf (1993). In the case of DL-LiteHF horn, query answering is data-complete for P, as follows from the results of Hustadt et al. (2005) and Eiter et al. (2008) for Horn-SHIQ, while for DL-Litehorn it is in AC 0 (Calvanese et al.",
      "startOffset" : 65,
      "endOffset" : 254
    }, {
      "referenceID" : 61,
      "context" : "We remind the reader (for details consult, e.g., Apt, 1990; Rautenberg, 2006) that M0 can be constructed by taking the intersection of all Herbrand models for K‡e , that is, of all models based on the domain that consists of constant symbols from K‡e—i.",
      "startOffset" : 21,
      "endOffset" : 77
    }, {
      "referenceID" : 62,
      "context" : "It remains to recall that reachability in undirected graphs is SLogSpace-complete and that SLogSpace = LogSpace (Reingold, 2008).",
      "startOffset" : 112,
      "endOffset" : 128
    }, {
      "referenceID" : 14,
      "context" : "The above result strengthens the NLogSpace lower bound for instance checking in DL-Litecore proved by Calvanese et al. (2008).",
      "startOffset" : 102,
      "endOffset" : 126
    }, {
      "referenceID" : 43,
      "context" : "The P and coNP upper bounds for query answering without the UNA follow from the results for Horn-SHIQ (Hustadt et al., 2005; Eiter et al., 2008) and SHIQ (Ortiz et al.",
      "startOffset" : 102,
      "endOffset" : 144
    }, {
      "referenceID" : 31,
      "context" : "The P and coNP upper bounds for query answering without the UNA follow from the results for Horn-SHIQ (Hustadt et al., 2005; Eiter et al., 2008) and SHIQ (Ortiz et al.",
      "startOffset" : 102,
      "endOffset" : 144
    }, {
      "referenceID" : 35,
      "context" : ", 2008) and SHIQ (Ortiz et al., 2006, 2008; Glimm et al., 2007), respectively (see the discussion at the beginning of Section 7).",
      "startOffset" : 17,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : "The first-order rewriting technique has been implemented in various system, notably in QuOnto (Acciarri et al., 2005; Poggi et al., 2008b), which can query, relying on ontology-to-relational mappings, data stored in any standard relational database management system, and in Owlgres (Stocker & Smith, 2008), which can access an ABox stored in a Postgres database (though, to the best of our knowledge, the latter implementation is incomplete for conjunctive query answering).",
      "startOffset" : 94,
      "endOffset" : 138
    }, {
      "referenceID" : 43,
      "context" : "It could also be promising for the Horn fragments of expressive description logics such as SHIQ (Hustadt et al., 2005; Hustadt, Motik, & Sattler, 2007)—containing DL-LiteHF horn as a sub-language—for which the data complexity of instance checking (Hustadt et al.",
      "startOffset" : 96,
      "endOffset" : 151
    }, {
      "referenceID" : 31,
      "context" : ", 2005, 2007) and conjunctive query answering is polynomial (Eiter et al., 2008).",
      "startOffset" : 60,
      "endOffset" : 80
    }, {
      "referenceID" : 47,
      "context" : "DL-Lite logics are among those few examples of DLs for which usually very complex ‘non-standard’ reasoning problems—such as checking whether one ontology is a conservative extension of another one with respect to a given signature Σ (Kontchakov et al., 2008), computing minimal modules of ontologies with respect to Σ (Kontchakov et al.",
      "startOffset" : 233,
      "endOffset" : 258
    }, {
      "referenceID" : 46,
      "context" : ", 2008), computing minimal modules of ontologies with respect to Σ (Kontchakov et al., 2009) or uniform interpolants (Wang, Wang, Topor, & Pan, 2008)—can be supported by practical reasoning tools.",
      "startOffset" : 67,
      "endOffset" : 92
    } ],
    "year" : 2009,
    "abstractText" : "The recently introduced series of description logics under the common moniker ‘DLLite’ has attracted attention of the description logic and semantic web communities due to the low computational complexity of inference, on the one hand, and the ability to represent conceptual modeling formalisms, on the other. The main aim of this article is to carry out a thorough and systematic investigation of inference in extensions of the original DL-Lite logics along five axes: by (i) adding the Boolean connectives and (ii) number restrictions to concept constructs, (iii) allowing role hierarchies, (iv) allowing role disjointness, symmetry, asymmetry, reflexivity, irreflexivity and transitivity constraints, and (v) adopting or dropping the unique name assumption. We analyze the combined complexity of satisfiability for the resulting logics, as well as the data complexity of instance checking and answering positive existential queries. Our approach is based on embedding DL-Lite logics in suitable fragments of the one-variable first-order logic, which provides useful insights into their properties and, in particular, computational behavior.",
    "creator" : "TeX"
  }
}