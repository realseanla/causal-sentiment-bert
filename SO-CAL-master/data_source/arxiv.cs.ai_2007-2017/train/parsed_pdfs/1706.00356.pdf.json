{
  "name" : "1706.00356.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Enhancing workflow-nets with data for trace completion",
    "authors" : [ "Riccardo De Masellis", "Chiara Di Francescomarino", "Chiara Ghidini", "Sergio Tessaris" ],
    "emails" : [ "r.demasellis@fbk.eu", "dfmchiara@fbk.eu", "ghidini@fbk.eu", "tessaris@inf.unibz.it" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "The use of IT systems for supporting business activities has brought to a large diffusion of process mining techniques and tools that offer business analysts the possibility to observe the current process execution, identify deviations from themodel, perform individual and aggregated analysis on current and past executions.\nAccording to the process mining manifesto, all these techniques and tools can be grouped in three basic types: process discovery, conformance checking and process enhancement (see Figure 1), and require in input an event log and, for conformance checking and enhancement, a (process) model. A log, usually described in the IEEE standard XES format3, is a set of execution traces (or cases) each of\nwhich is an ordered sequence of events carrying a payload as a set of attribute-value pairs. Process models instead provide a description of the scenario at hand and can be constructed using one of the available Business Process Modeling Languages, such as BPMN, YAWL and Declare.\n3 http://www.xes-standard.org/\nar X\niv :1\n70 6.\n00 35\n6v 1\n[ cs\n.A I]\n1 J\nun 2\n01 7\nEvent logs are therefore a crucial ingredient to the accomplishment of process mining. Unfortunately, a number of difficulties may hamper the availability of event logs. Among these are partial event logs, where the execution traces may bring only partial information in terms of which process activities have been executed and what data or artefacts they produced. Thus repairing incomplete execution traces by reconstructing the missing entries becomes an important task to enable process mining in full, as noted in recent works such as [17,8]. While these works deserve a praise for having motivated the importance of trace repair and having provided some basic techniques for reconstructing missing entries using the knowledge captured in process models, they all focus on event logs (and process models) of limited expressiveness. In fact, they all provide techniques for the reconstruction of control flows, thus completely ignoring the data flow component. This is a serious limitation, given the growing practical and theoretical efforts to extend business process languages with the capability to model complex data objects, along with the traditional control flow perspective [6].\nIn this paper we show how to exploit state-of-the-art planning techniques to deal with the repair of data-aware event logs in the presence of imperative process models. Specifically we will focus on the well established Workflow Nets [20], a particular class of Petri nets that provides the formal foundations of several process models, of the YAWL language and have become one of the standard ways to model and analyze workflows. In particular we provide: 1. a modeling language DAW-net, an extension of the workflow nets with data for-\nmalism introduced in [18] so to be able to deal with even more expressive data (Section 3); 2. a recast of data aware trace repair as a reachability problem in DAW-net (Section C); 3. a sound and complete encoding of reachability in DAW-net in a planning problem\nso to be able to deal with trace repair using planning (Section 5). The solution of the problem are all and only the repairs of the partial trace compliant with the DAW-net model. The advantage of using automated planning techniques is that we can exploit the underlying logic language to ensure that generated plans conform to the observed traces without resorting to ad hoc algorithms for the specific repair problem. The theoretical investigation presented in this work provides an important step forward towards the exploitation of mature planning techniques for the trace repair w.r.t. data-aware processes."
    }, {
      "heading" : "2 Preliminaries",
      "text" : ""
    }, {
      "heading" : "2.1 The Workflow Nets modeling language",
      "text" : "Petri Nets (PN) is a modeling language for the description of distributed systems that has widely been applied to the description and analysis of business processes [1].The classical PN is a directed bipartite graph with two node types, called places and transitions, connected via directed arcs. Connections between two nodes of the same type are not allowed. Definition 1 (Petri Net). A Petri Net is a triple 〈P, T, F 〉 where P is a set of places; T is a set of transitions; F ⊆ (P × T ) ∪ (T × P ) is the flow relation describing the arcs between places and transitions (and between transitions and places).\nThe preset of a transition t is the set of its input places: •t = {p ∈ P | (p, t) ∈ F}. The postset of t is the set of its output places: t• = {p ∈ P | (t, p) ∈ F}. Definitions of preand postsets of places are analogous.\nPlaces in a PN may contain a discrete number of marks called tokens. Any distribution of tokens over the places, formally represented by a totalmappingM : P 7→ N, represents a configuration of the net called a marking. PNs come with a graphical notation where places are represented by means of circles, transitions by means of rectangles and tokens by means of full\ndots within places. Figure 2 depicts a PN with a marking M(p0) = 2, M(p1) = 0, M(p2) = 1. The preset and postset of t are {p0, p1} and {p2}, respectively.\nProcess tasks are modeled in PNs as transitions while arcs and places constraint their ordering. For instance, the process in Figure 34 exemplifies how PNs can be used to model parallel and mutually exclusive choices, typical of business processes: sequences T2;T4-T3;T5 and transitions T6-T7-T8 are indeed placed on mutually exclusive paths. Transitions T10 and T11 are instead placed on parallel paths. Finally, T9 is needed to prevent connections between nodes of the same type.\nThe expressivity of PNs exceeds, in the general case, what is needed to model business processes, which typically have a well-defined starting point and a well-defined ending point. This imposes syntactic restrictions on PNs, that result in the following definition of a workflow net (WF-net) [1].\nDefinition 2 (WF-net). A PN 〈P, T, F 〉 is a WF-net if it has a single source place start, a single sink place end, and every place and every transition is on a path from start to end, i.e., for all n ∈ P ∪ T , (start, n) ∈ F ∗ and (n, end) ∈ F ∗, where F ∗ is the reflexive transitive closure of F .\nAmarking in a WF-net represents the workflow state of a single case. The semantics of a PN/WF-net, and in particular the notion of valid firing, defines how transitions route tokens through the net so that they correspond to a process execution.\nDefinition 3 (Valid Firing). A firing of a transition t ∈ T from M to M ′ is valid, in symbolsM t→M ′, iff\n4 For the sake of simplicity we only focus here on the, so-called, happy path, that is the successful granting of the loan.\n1. t is enabled inM , i.e., {p ∈ P |M(p) > 0} ⊇ •t; and 2. the markingM ′ is such that for every p ∈ P :\nM ′(p) =  M(p)− 1 if p ∈ •t \\ t•\nM(p) + 1 if p ∈ t• \\ •t M(p) otherwise\nCondition 1. states that a transition is enabled if all its input places contain at least one token; 2. states that when t fires it consumes one token from each of its input places and produces one token in each of its output places.\nA case of aWF-Net is a sequence of valid firingsM0 t1→M1,M1 t2→M2, . . . ,Mk−1 tk→\nMk whereM0 is the marking indicating that there is a single token in start.\nDefinition 4 (k-safeness). A marking of a PN is k-safe if the number of tokens in all places is at most k. A PN is k-safe if the initial marking is k-safe and the marking of all cases is k-safe.\nFrom now on we concentrate on 1-safe nets, which generalize the class of structured workflows and are the basis for best practices in process modeling [11]. We also use safeness as a synonym of 1-safeness. It is important to notice that our approach can be seamlessly generalized to other classes of PNs, as long as it is guaranteed that they are k-safe. This reflects the fact that the process control-flow is well-defined (see [10]).\nReachability on Petri Nets. The behavior of a PN can be described as a transition system where states are markings and directed edges represent firings. Intuitively, there is an edge from Mi to Mi+1 labeled by ti if Mi\nt→ Mi+1 is a valid firing. Given a “goal” markingMg , the reachability problem amounts to check if there is a path from the initial markingM0 toMg . Reachability on PNs (WF-nets) is of enormous importance in process verification as it allows for checking natural behavioral properties, such as satisfiability and soundness in a natural manner [2]."
    }, {
      "heading" : "2.2 Trace repair",
      "text" : "One of the goals of process mining is to capture the as-is processes as accurately as possible: this is done by examining event logs that can be then exploited to perform the tasks in Figure 1. In many cases, however, event logs are subject to data quality problems, resulting in incorrect or missing events in the log. In this paper we focus on the latter issue addressing the problem of repairing execution traces that contain missing entries (hereafter shortened in trace repair).\nThe need for trace repair is motivated in depth in [17], where missing entities are described as a frequent cause of low data quality in event logs, especially when the definition of the business processes integrates activities that are not supported by IT systems due either to their nature (e.g. they consist of human interactions) or to the high level of abstraction of the description, detached from the implementation. A further cause of missing events are special activities (such as transition T9 in Figure 3) that are introduced in the model to guarantee properties concerning e.g., the structure of the workflow or syntactic constraints, but are never executed in practice.\nThe starting point of trace repair are execution traces and the knowledge captured in process models. Consider for instance the model in Figure 3 and the (partial) execution trace {T3, T7}. By aligning the trace to the model using a replay-based approach or a planning based approach, the techniques presented in [17] and [8] are able to exploit the events stored in the trace and the control flow specified in the model to reconstruct two possible repairs:\n{T1, T3, T5, T7, T9, T10, T11, T12} {T1, T3, T5, T7, T9, T11, T10, T12}\nConsider now a different scenario in which the partial trace reduces to {T7}. In this case, by using the control flow in Figure 3 we are not able to reconstruct whether the loan is a student loan or a worker loan. This increases the number of possible repairs and therefore lowers the usefulness of trace repair. Assume nonetheless that the event log conforms to the XES standard and stores some observed data attached to T7 (enclosed in square brackets): {T7[request = 60k, loan = 50k]} If the process model is able to specify how transitions can read and write variables, and furthermore some constraints on how they do it, the scenario changes completely. Indeed, assume that transition T4 is empowered with the ability to write the variable request with a value smaller or equal than 30k (being this the maximum amount of a student loan). Using this fact, and the fact that the request examined by T7 is greater than 30k, we can understand that the execution trace has chosen the path of the worker loan. Moreover, if the model specifies that variable loanType is written during the execution of T1, when the applicant chooses the type of loan she is interested to, we are able to infer that T1 sets variable loanType to w. This example, besides illustrating the idea of trace repair, also motivates why data are important to accomplish this task, and therefore why extending repair techniques beyond the mere control flow is a significant contribution to address data quality problems in event logs."
    }, {
      "heading" : "2.3 The planning language K",
      "text" : "The main elements of action languages are fluents and actions. The former represent the state of the systemwhichmay change bymeans of actions. Causation statements describe the possible evolution of the states, and preconditions associated to actions describe which action can be executed according to the current state. A planning problem inK [9] is specified using a Datalog-like language where fluents and actions are represented by literals (not necessarily ground). The specification includes the list of fluents, actions, initial state and goal conditions; also a set of statements specifies the dynamics of the planning domain using causation rules and executability conditions. The semantics of K borrows heavily from Answer Set Programming (ASP) paradigm. In fact, the system enables the reasoning with partial knowledge and provides both weak and strong negation.\nA causation rule is a statement of the form caused f if b1,. . ., bk, not bk+1, . . ., not b`\nafter a1,. . ., am, not am+1, . . ., not an.\nThe rule states that f is true in the new state reached by executing (simultaneously) some actions, provided that a1, . . . , am are known to hold while am+1, . . . , an are not known to hold in the previous state (some of the aj might be actions executed on it), and b1, . . . , bk are known to hold while bk+1, . . . , b` are not known to hold in the new state. Rules without the after part are called static.\nAn executability condition is a statement of the form executable a if b1,. . ., bk, not bk+1, . . ., not b`.\nInformally, such a condition says that the action a is eligible for execution in a state, if b1, . . . , bk are known to hold while bk+1, . . . , b` are not known to hold in that state.\nTerms in both kind of statements could include variables (starting with capital letter) and the statements must be safe in the usual Datalog meaning w.r.t. the first fluent or action of the statements.\nA planning domain PD is a tuple 〈D,R〉 where D is a finite set of action and fluent declarations and R a finite set of rules, initial state constraints, and executability conditions.\nThe semantics of the language is provided in terms of a transition system where the states are ASP models (sets of atoms) and actions transform the state according to the rules. A state transition is a tuple t = 〈s,A, s′〉 where s, s′ are states and A is a set of action instances. The transition is said to be legal if the actions are executable in the first state and both states are the minimal ones that satisfy all causation rules. Semantics of plans including default negation is defined by means of a GelfondLifschitz type reduction to a positive planning domain. A sequence of state transitions 〈s0, A1, s1〉, . . . , 〈sn−1, An, sn〉, n ≥ 0, is a trajectory for PD, if s0 is a legal initial state of PD and all 〈si−1, Ai, si〉, are legal state transitions of PD.\nA planning problem is a pair of planning domain PD and a ground goal g1, . . . , gm, not gm+1, . . ., not gn that is required to be satisfied at the end of the execution."
    }, {
      "heading" : "3 Framework",
      "text" : "In this section we suitably extend WF-nets to represent data and their evolution as transitions are performed. In order for such an extension to be meaningful, i.e., allowing reasoning on data, it has to provide: (i) a model for representing data; (ii) a way to make decisions on actual data values; and (iii) a mechanism to express modifications to data. Therefore, we enhance WF-nets with the following elements: – a set of variables taking values from possibly different domains (addressing (i)); – queries on such variables used as transitions preconditions (addressing (ii)) – variables updates and deletion in the specification of net transitions (addressing (iii)).\nOur framework follows the approach of state-of-the-art WF-nets with data [18,12], from which it borrows the above concepts, extending them by allowing reasoning on actual data values as better explained in Section 6.\nThroughout the section we use the WF-net in Figure 3 extended with data as a running example."
    }, {
      "heading" : "3.1 Data Model",
      "text" : "As our focus is on trace repair, we follow the data model of the IEEE XES standard for describing logs, which represents data as a set of variables. Variables take values from specific sets on which a partial order can be defined. As customary, we distinguish between the data model, namely the intensional level, from a specific instance of data, i.e., the extensional level.\nDefinition 5 (Data model). A data model is a tuple D = (V, ∆, dm, ord) where: – V is a possibly infinite set of variables; – ∆ = {∆1, ∆2, . . .} is a possibly infinite set of domains (not necessarily disjoint); – dm : V → ∆ is a total and surjective function which associates to each variable v its domain ∆i;\n– ord is a partial function that, given a domain∆i, if ord(∆i) is defined, then it returns a partial order (reflexive, antisymmetric and transitive) ≤∆i⊆ ∆i ×∆i.\nAdatamodel for the loan example isV = {loanType, request, loan},dm(loanType) = {w, s}, dm(request) = N, dm(loan) = N, with dm(loan) and dm(loanType) being total ordered by the natural ordering ≤ in N.\nAn actual instance of a data model is simply a partial function associating values to variables.\nDefinition 6 (Assignment). Let D = 〈V, ∆, dm, ord〉 be a data model. An assignment for variables in V is a partial function η : V → ⋃ i∆i such that for each v ∈ V , if η(v) is defined, i.e., v ∈ img(η) where img is the image of η, then we have η(v) ∈ dm(v).\nWe now define our boolean query language, which notably allows for equality and comparison. As will become clearer in Section B.2, queries are used as guards, i.e., preconditions for the execution of transitions.\nDefinition 7 (Query language - syntax). Given a data model, the language L(D) is the set of formulas Φ inductively defined according to the following grammar:\nΦ := true | def(v) | t1 = t2 | t1 ≤ t2 | ¬Φ1 | Φ1 ∧ Φ2\nwhere v ∈ V and t1, t2 ∈ V ∪ ⋃ i∆i.\nExamples of queries of the loan scenarios are request ≤ 5k or loanType = w. Given a formula Φ and an assignment η, we write Φ[η] for the formula Φ where each occurrence of variable v ∈ img(η) is replaced by η(v).\nDefinition 8 (Query language - semantics). Given a data model D, an assignment η and a query Φ ∈ L(D) we say thatD, η satisfies Φ, writtenD, η |= Φ inductively on the structure of Φ as follows: – D, η |= true; – D, η |= def(v) iff v ∈ img(η); – D, η |= t1 = t2 iff t1[η], t2[η] 6∈ V and t1[η] ≡ t2[η]; – D, η |= t1 ≤ t2 iff t1[η], t2[η] ∈ ∆i for some i and ord(∆i) is defined and t1[η] ≤∆i t2[η];\n– D, η |= ¬Φ iff it is not the case that D, η |= Φ; – D, η |= Φ1 ∧ Φ2 iff D, η |= Φ1 and D, η |= Φ2. Intuitively, def can be used to check if a variable has an associated value or not (recall that assignment η is a partial function); equality has the intended meaning and t1 ≤ t2 evaluates to true iff t1 and t2 are values belonging to the same domain ∆i, such a domain is ordered by a partial order ≤∆i and t1 is actually less or equal than t2 according to ≤∆i ."
    }, {
      "heading" : "3.2 Data-aware net",
      "text" : "We now combine the data model with a WF-net and formally define how transitions are guarded by queries and how they update/delete data. The result is a Data-AWare net (DAW-net) that incorporates aspects (i)–(iii) described at the beginning of Section 3.\nDefinition 9 (DAW-net). A DAW-net is a tuple 〈D, N , wr, gd〉 where: – N = 〈P, T, F 〉 is a WF-net; – D = 〈V, ∆, dm, ord〉 is a data model; – wr : T 7→ (V ′ 7→ 2dm(V)), where V ′ ⊆ V , dm(V) = ⋃ v∈V dm(v) and wr(t)(v) ⊆\ndm(v) for each v ∈ V ′, is a function that associates each transition to a (partial) function mapping variables to a finite subset of their domain. – gd : T 7→ L(D) is a function that associates a guard to each transition. Function gd associates a guard, namely a query, to each transition. The intuitive semantics is that a transition t can fire if its guard gd(t) evaluates to true (given the current assignment of values to data). Examples are gd(T6) = request ≤ 5k and gd(T8) = ¬(request ≤ 99999). Function wr is instead used to express how a transition t modifies data: after the firing of t, each variable v ∈ V ′ can take any value among a specific finite subset of dm(v). We have three different cases: – ∅ ⊂ wr(t)(v) ⊆ dm(v): t nondeterministically assigns a value from wr(t)(v) to v; – wr(t)(v) = ∅: t deletes the value of v (hence making v undefined); – v 6∈ dom(wr(t)): value of v is not modified by t. Notice that by allowing wr(t)(v) ⊆ dm(v) in the first bullet above we enable the specification of restrictions for specific tasks. E.g., wr(T4) : {request} 7→ {0 . . . 30k} says that T4 writes the request variable and intuitively that students can request a maximum loan of 30k, while wr(T5) : {request} 7→ {0 . . . 500k} says that workers can request up to 500k.\nThe intuitive semantics of gd and wr is formalized next. We start from the definition of DAW-net state, which includes both the state of the WF-net, namely its marking, and the state of data, namely the assignment. We then extend the notions of state transition and valid firing.\nDefinition 10 (DAW-net state). A state of a DAW-net 〈D,N ,wr, gd〉 is a pair (M,η) whereM is a marking for 〈P, T, F 〉 and η is an assignment for D. Definition 11 (DAW-net Valid Firing). Given a DAW-net 〈D,N ,wr, gd〉, a firing of a transition t ∈ T is a valid firing from (M,η) to (M ′, η′), written as (M,η) t→ (M ′, η′), iff conditions 1. and 2. of Def. 3 holds for M and M ′, i.e., it is a WF-Net valid firing, and\n1. D, η |= gd(t), 2. assignment η′ is such that, if wr = {v | wr(t)(v) 6= ∅}, del = {v | wr(t)(v) = ∅}:\n– its domain dom(η′) = dom(η) ∪ wr \\ del; – for each v ∈ dom(η′):\nη′(v) = { d ∈ wr(t)(v) if v ∈ wr η(v) otherwise.\nCondition 1. and 2. extend the notion of valid firing of WF-nets imposing additional pre- and postconditions on data, i.e., preconditions on η and postconditions on η′. Specifically, 1. says that for a transition t to be fired its guard gd(t) must be satisfied by the current assignment η. Condition 2. constrains the new state of data: the domain of η′ is defined as the union of the domain of η with variables that are written (wr), minus the set of variables that must be deleted (del). Variables in dom(η′) can indeed be grouped in three sets depending on the effects of t: (i) old = dom(η) \\ wr: variables whose value is unchanged after t; (ii) new = wr \\ dom(η): variables that were undefined but have a value after t; and (iii) overwr = wr ∩ dom(η): variables that did have a value and are updated with a new one after t. The final part of condition 2. says that each variable in new ∪ overwr takes a value in wr(t)(v), while variables in old maintain the old value η(v).\nA case of a DAW-net is defined as a case of a WF-net, with the only difference that the assignment η0 of the initial state (M0, η0) is empty, i.e., dom(η0) = ∅."
    }, {
      "heading" : "4 Trace repair as reachability",
      "text" : "In this section we provide the intuition behind our technique for solving the trace repair problem via reachability. Full details and proofs are contained in Appendices A–D.\nA trace is a sequence of observed events, each with a payload including the transition it refers to and its effects on the data, i.e., the variables updated by its execution. Intuitively, a DAW-net case is compliant w.r.t. a trace if it contains all the occurrences of the transitions observed in the trace (with the corresponding variable updates) in the right order.\nAs a first step, we assumewithout loss of generality that DAW-net models start with a special transition startt and terminate with a special transition endt. Every process can be reduced to such a structure as informally illustrated in the left hand side of Figure 4 by arrows labeled with (1). Note that this change would not modify the behavior of the net: any sequence of firing valid for the original net can be extended by the firing of the additional transitions and vice versa.\nNext, we illustrate the main idea behind our approach by means of the right hand side of Figure 4: we consider the observed events as transitions (in red) and we suitably “inject” them in the original DAW-net. By doing so, we obtain a new model where, intuitively, tokens are forced to activate the red transitions of DAW-net, when events are observed in the trace. When, instead, there is no red counterpart, i.e., there is missing information in the trace, the tokens move in the black part of the model. The objective is then to perform reachability for the final marking (i.e., to have one token in the end\nplace and all other places empty) over such a new model in order to obtain all and only the possible repairs for the partial trace.\nMore precisely, for each event ewith a payload including transition t and some effect on variables we introduce a new transition te in the model such that: – te is placed in parallel with the original transition t; – te includes an additional input place connected to the preceding event and an additional output place which connects it to the next event;\n– gd(te) = gd(t) and – wr(te) specifies exactly the variables and the corresponding values updated by the event, i.e. if the event set the value of v to d, then wr(te)(v) = {d}; if the event deletes the variable v, then wr(te)(v) = ∅. Given a trace τ and a DAW-netW , it is easy to see that the resulting trace workflow (indicated asW τ ) is a strict extension ofW (only new nodes are introduced) and, since all newly introduced nodes are in a path connecting the start and sink places, it is a DAW-net, whenever the original one is a DAW-net net.\nWe now prove the soundness and completeness of the approach by showing that: (1) all cases ofW τ are compliant with τ ; (2) each case ofW τ is also a case ofW and (3) if there is a case ofW compliant with τ , then that is also a case forW τ .\nProperty (1) is ensured by construction. For (2) and (3) we need to relate cases from W τ to the original DAW-netW .We indeed introduce a projection functionΠτ that maps elements from cases of the enriched DAW-net to cases of elements from the original DAW-net. Essentially, Πτ maps newly introduced transitions te to the corresponding transitions in event e, i.e., t, and also projects away the new places in the markings. Given that the structure of W τ is essentially the same as that of W with additional copies of transitions that are already inW , it is not surprising that any case forW τ can be replayed onW by mapping the new transitions te into the original ones t, as shown by the following:\nLemma 1. If C is a case ofW τ then Πτ (C) is a case ofW .\nThis lemma proves that whenever we find a case onW τ , then it is an example of a case onW that is compliant with τ , i.e., (2). However, to reduce the original problem to reachability on DAW-net, we need to prove that all the W cases compliant with τ can be replayed onW τ , that is, (3). In order to do that, we can build a case forW τ starting from the compliant case forW , by substituting the occurrences of firings corresponding to events in τ with the newly introduced transitions. The above results pave the way to the following:\nTheorem 1. LetW be a DAW-net and τ = (e1, . . . , en) a trace; thenW τ characterises all and only the cases ofW compatible with τ . That is ⇒ if C is a case ofW τ containing ten then Πτ (C) is compatible with τ ; and ⇐ ifC is a case ofW compatible with τ , then there is a caseC ′ ofW τ s.t.Πτ (C ′) = C.\nTheorem 1 provides the main result of this section and is the basis for the reduction of the trace repair forW and τ to the reachability problem forW τ . In fact, by enumerating all the cases ofW τ reaching the final marking (i.e. a token in end) we can provide all possible repairs for the partial observed trace. Moreover, the transformation generating W τ is preserving the safeness properties of the original workflow:\nLemma 2. LetW be a DAW-net and τ a trace ofW . IfW is k-safe thenW τ is k-safe as well.\nThis is essential to guarantee the decidability of the reasoning techniques described in the next section."
    }, {
      "heading" : "5 Reachability as a planning problem",
      "text" : "In this section we exploit the similarity between workflows and planning domains in order to describe the evolution of a DAW-net by means of a planning language. Once the original workflow behaviour has been encoded into an equivalent planning domain, we can use the automatic derivation of plans with specific properties to solve the reachability problem. In our approach we introduce a new action for each transition (to ease the description we will use the same names) and represent the status of the workflow – marking and variable assignments – by means of fluents. Although their representation as dynamic rules is conceptually similar we will separate the description of the encoding by considering first the behavioural part (the WF-net) and then the encoding of data (variable assignments and guards)."
    }, {
      "heading" : "5.1 Encoding DAW-net behaviour",
      "text" : "Since we focus on 1-safe WF-nets the representation of markings is simplified by the fact that each place can either contain 1 token or no tokens at all. This information can be represented introducing a propositional fluent for each place, true iff the corresponding place holds a token. Let us consider 〈P, T, F 〉 the safe WF-net component of a DAW-net system. The declaration part of the planning domain will include: – a fluent declaration p for each place p ∈ P ; – an action declaration t for each task t ∈ T .\nSince each transition can be fired5 only if each input place contains a token, then the corresponding action can be executed when place fluents are true: for each task t ∈ T , given {it1, . . . , itn} = •t, we include the executability condition:\nexecutable t if it1, . . . , itn.\n5 Guards will be introduced in the next section.\nAs valid firings are sequential, namely only one transition can be fired at each step, we disable concurrency in the planning domain introducing the following rule for each pair of tasks t1, t2 ∈ T 6\ncaused false after t1, t2. Transitions transfer tokens from input to output places. Thus the corresponding actions must clear the input places and set the output places to true. This is enforced by including\ncaused −it1 after t. . . . caused −itn after t. caused ot1 after t. . . . caused otk after t.\nfor each task t ∈ T and {it1, . . . , itn} = •t \\ t•, {ot1, . . . , otk} = t•. Finally, place fluents should be inertial since they preserve their value unless modified by an action. This is enforced by adding for each p ∈ P\ncaused p if not −p after p.\nPlanning problem. Besides the domain described above, a planning problem includes an initial state, and a goal. In the initial state the only place with a token is the source:\ninitially: start. The formulation of the goal depends on the actual instance of the reachability problem we need to solve. The goal corresponding to the state in which the only place with a token is end is written as:\ngoal: end, not p1, . . ., not pk? where {p1, . . . , pk} = P \\ {end}."
    }, {
      "heading" : "5.2 Encoding data",
      "text" : "For each variable v ∈ V we introduce a fluent unary predicate varv holding the value of that variable. Clearly, varv predicates must be functional and have no positive instantiation for undefined variables.\nWe also introduce auxiliary fluents to facilitate the writing of the rules. Fluent defv indicates whether the v variable is not undefined – it is used both in tests and to enforce models where the variable is assigned/unassigned. The fluent chngv is used to inhibit inertia for the variable v when its value is updated because of the execution of an action.\nDAW-net includes the specification of the set of values that each transition can write on a variable. This information is static, therefore it is included in the background knowledge by means of a set of unary predicates domv,t as a set of facts:\ndomv,t(e). for each v ∈ V , t ∈ T , and e ∈ wr(t)(v).\nConstraints on variables. For each variable v ∈ V: – we impose functionality\ncaused false if varv(X), varv(Y), X != Y. – we force its value to propagate to the next state unless it is modified by an action (chngv)\n6 For efficiency reasons we can relax this constraint by disabling concurrency only for transitions sharing places or updating the same variables. This would provide shorter plans.\ncaused varv(X) if not −varv(X), not chngv after varv(X).\n– the defined fluent is the projection of the argument caused defv if varv(X).\nVariable updates. The value of a variable is updated by means of causation rules that depend on the transition t that operates on the variable, and depends on the value of wr(t). For each v in the domain of wr(t):\n– wr(t)(v) = ∅: delete (undefine) a variable v caused false if defv after t. caused chngv after t. – wr(t)(v) ⊆ dm(v): set v with a value nondeterministically chosen among a set of elements from its domain\ncaused varv(V) if domv,t(V), not −varv(V) after t. caused −varv(V) if domv,t(V), not varv(V) after t. caused false if not defv after t. caused chngv after t.\nIf wr(t)(v) contains a single element d, then the assignment is deterministic and the first three rules above can be substituted with7\ncaused varv(d) after t.\nGuards. To each subformula ϕ of transition guards is associated a fluent grdϕ that is true when the corresponding formula is satisfied. To simplify the notation, for any transition t, we will use grdt to indicate the fluent grdgd(t). Executability of transitions is conditioned to the satisfiability of their guards; instead of modifying the executability rule including the grdt among the preconditions, we use a constraint rule preventing executions of the action whenever its guard is not satisfied:\ncaused false after t, not grdt. Translation of atoms (ξ) is defined in terms of varv predicates. For instance ξ(v = w) corresponds to varv(V), varw(W), V == W. That is ξ(v, T ) = vart(T) for t ∈ V , and ξ(d, T ) = vartT == d for d ∈ ⋃ i∆i. For each subformula ϕ of transition guards a static rule is included to “define” the fluent grdϕ: true : caused grdϕ if true .\ndef(v) : caused grdϕ if defv . t1 = t2 : caused grdϕ if ξ(t1,T1), ξ(t2,T2), T1 == T2 . t1 ≤ t2 : caused grdϕ if ξ(t1,T1), ξ(t2,T2), ord(T1,T2) . ¬ϕ1 : caused grdϕ if not grdϕ1 .\nϕ1 ∧ . . . ∧ ϕn : caused grdϕ if grdϕ1 , . . . , grdϕn ."
    }, {
      "heading" : "5.3 Correctness and completeness",
      "text" : "We provide a sketch of the correctness and completeness of the encoding. Proofs can be found in [4].\n7 The deterministic version is a specific case of the non-deterministic ones and equivalent in the case that there is a single domv,t(d) fact.\nPlanning states include all the information to reconstruct the original DAW-net states. In fact, we can define a function Φ(·) mapping consistent planning states into DAW-net states as following: Φ(s) = (M,η) with\n∀p ∈ P, M(p) = { 1 if p ∈ s 0 otherwise\nη = {(v, d) | varv(d) ∈ s}\nΦ(s) is well defined because s it cannot be the case that {varv(d), varv(d′)} ⊆ s with d 6= d′, otherwise the static rule\ncaused false if varv(X), varv(Y), X != Y. would not be satisfied. Moreover, 1-safeness implies that we can restrict to markings with range in {0, 1}. By looking at the static rules we can observe that those defining the predicates defv and grdt are stratified. Therefore their truth assignment depends only on the extension of varv(·) predicates. This implies that grdt fluents are satisfied iff the variables assignment satisfies the corresponding guard gd(t). Based on these observations, the correctness of the encoding is relatively straightforward since we need to show that a legal transition in the planning domain can be mapped to a valid firing. This is proved by inspecting the dynamic rules.\nLemma 3 (Correctness). Let W be a DAW-net and Ω(W ) the corresponding planning problem. If 〈s, {t}, s′〉 is a legal transition in Ω(W ), then Φ(s) t→ Φ(s′) is a valid firing ofW .\nThe proof of completeness is more complex because – given a valid firing – we need to build a new planning state and show that it is minimal w.r.t. the transition. Since the starting state s of 〈s, {t}, s′〉 does not require minimality we just need to show its existence, while s′ must be carefully defined on the basis of the rules in the planning domain.\nLemma 4 (Completeness). LetW be a DAW-net, Ω(W ) the corresponding planning problem and (M,η) t→ (M ′, η′) be a valid firing ofW . Then for each consistent state s s.t. Φ(s) = M there is a consistent state s′ s.t. Φ(s′) = M ′ and 〈s, {t}, s′〉 is a legal transition in Ω(W ).\nLemmata 13 and 12 provide the basis for the inductive proof of the following theorem:\nTheorem 2. LetW be a safeWF-net andΩ(PN) the corresponding planning problem. Let (M0, η0) be the initial state of W – i.e. with a single token in the source and no assignments – and s0 the planning state satisfying the initial condition.\n(⇒) For any case inW\nζ : (M0, η0) t1→ (M1, η1) . . . (Mn−1, ηn−1) tn→ (Mn, ηn)\nthere is a trajectory in Ω(W )\nη : 〈s0, {t1}, s1〉, . . . , 〈sn−1, {tn}, sn〉\nsuch that (Mi, ηi) = Φ(si) for each i ∈ {0 . . . n} and viceversa.\n(⇐) For each trajectory η : 〈s0, {t1}, s1〉, . . . , 〈sn−1, {tn}, sn〉\nin Ω(W ), the following sequence of firings is a case ofW\nζ : Φ(s0) t1→ Φ(s1) . . . Φ(sn−1) tn→ Φ(sn).\nTheorem 5 above enables the exploitation of planning techniques to solve the reachability problem in DAW-net. Indeed, to verify whether the final marking is reachable it is sufficient to encode it as a condition for the final state and verify the existence of a trajectory terminating in a state where the condition is satisfied. Decidability of the planning problem is guaranteed by the fact that domains are effectively finite, as in Definition 9 the wr functions range over a finite subset of the domain."
    }, {
      "heading" : "6 Related Work and Conclusions",
      "text" : "The key role of data in the context of business processes has been recently recognized. A number of variants of PNs have been enriched so as to make tokens able to carry data and transitions aware of the data, as in the case of Workflow nets enriched with data [18,12], the model adopted by the business process community. In detail, Workflow Net transitions are enriched with information about data (e.g., a variable request) and about how it is used by the activity (for reading or writing purposes). Nevertheless, these nets do not consider data values (e.g., in the example of Section 2.2 we would not be aware of the values of the variable request that T4 is enabled to write). They only allow for the identification of whether the value of the data element is defined or undefined, thus limiting the reasoning capabilities that can be provided on top of them. For instance, in the example of Section 2.2, we would not be able to discriminate between the worker and the student loan for the trace in (2.2), as we would only be aware that request is defined after T4.\nThe problem of incomplete traces has been investigated in a number of works of trace alignment in the field of process mining, where it still represents one of the challenges. Several works have addressed the problem of aligning event logs and procedural models, without [3] and with [13,12] data. All these works, however, explore the search space of possible moves in order to find the best one aligning the log and the model. Differently from them, in this work (i) we assume that the model is correct and we focus on the repair of incomplete execution traces; (ii) we want to exploit state-of-the-art planning techniques to reason on control and data flow rather than solving an optimisation problem.\nWe can overall divide the approaches facing the problem of reconstructing flows of model activities given a partial set of information in two groups: quantitative and qualitative. The former rely on the availability of a probabilistic model of execution and knowledge. For example, in [17], the authors exploit stochastic PNs and Bayesian Networks to recover missing information (activities and their durations). The latter stand on the idea of describing “possible outcomes” regardless of likelihood; hence, knowledge about the world will consist of equally likely “alternative worlds” given the available observations in time, as in this work. For example, in [5] the same issue of reconstructing missing information has been tackled by reformulating it in terms of a Satisfiability(SAT) problem rather than as a planning problem.\nPlanning techniques have already been used in the context of business processes, e.g., for verifying process constraints [16] or for the construction and adaptation of autonomous process models [19,15]. In [7] automated planning techniques have been applied for aligning execution traces and declarative models. As in this work, in [8], planning techniques have been used for addressing the problem of incomplete execution traces with respect to procedural models. However, differently from the two approaches above, this work uses for the first time planning techniques to target the problem of completing incomplete execution traces with respect to a procedural model that also takes into account data and the value they can assume.\nDespite this work mainly focuses on the problem of trace completion, the proposed automated planning approach can easily exploit reachability for model satisfiability and trace compliance and furthermore can be easily extended also for aligning dataaware procedural models and execution traces. Moreover, the presented encoding in the planning language K, can be directly adapted to other action languages with an expressiveness comparable to C [14]. In the future, we would like to explore these extensions and implement the proposed approach and its variants in a prototype."
    }, {
      "heading" : "A Preliminaries",
      "text" : "A.1 Workflow Nets\nDefinition 12 (Petri Net [12]). A Petri Net is a triple 〈P, T, F 〉 where\n– P is a set of places; – T is a set of transitions; – F ⊆ (P × T ) ∪ (T × P ) is the flow relation describing the “arcs” between places and transitions (and between transitions and places).\nThe preset of a transition t is the set of its input places: •t = {p ∈ P | (p, t) ∈ F}. The postset of t is the set of its output places: t• = {p ∈ P | (t, p) ∈ F}. Definitions of pre- and postsets of places are analogous.\nThe marking of a Petri net is a total mappingM : P 7→ N.\nDefinition 13 (WF-net [18]). A Petri net 〈P, T, F 〉 is a workflow net (WF-net) if it has a single source place start, a single sink place end, and every place and every transition is on a path from start to end; i.e. for all n ∈ P ∪ T , (start, n) ∈ F ∗ and (n, end) ∈ F ∗, where F ∗ is the reflexive transitive closure of F .\nThe semantics of a PN is defined in terms of its markings and valid firing of transitions which change the marking. A firing of a transition t ∈ T fromM toM ′ is valid – denoted byM t0→M – iff:\n– t is enabled inM , i.e., {p ∈ P |M(p) > 0} ⊇ •t; and – the markingM ′ satisfies the property that for every p ∈ P :\nM ′(p) =  M(p)− 1 if p ∈ •t \\ t•\nM(p) + 1 if p ∈ t• \\ •t M(p) otherwise\nA case of PN is a sequence of valid firings\nM0 t1→M1,M1 t2→M2, . . . ,Mk−1 tk→Mk\nwhereM0 is the marking where there is a single token in the start place.\nDefinition 14 (safeness). A marking of a Petri Net is k-safe if the number of tokens in all places is at most k. A Petri Net is k-safe if the initial marking is k-safe and the marking of all cases is k-safe.\nIn this document we focus on 1-safeness, which is equivalent to the original safeness property as defined in [1].8 Note that for safe nets the range of markings is restricted to {0, 1}.\nA.2 Action Language K\nThe formal definition of K can be found in Appendix A of [9]; here, as reference, we include the main concepts.\nWe assume disjoint sets of action, fluent and type names, i.e., predicate symbols of arity ≥ 0, and disjoint sets of constant and variable symbols. Literals can be positive or negative atoms; denoted by −. Given a set of literals L, L+ (respectively, L−) is the set of positive (respectively, negative) literals in L. A set of literals is consistent no atoms appear both positive and negated.\nThe set of all action (respectively, fluent, type) literals is denoted as Lact (respectively, Lfl, Ltyp).\nFurthermore, Lfl,typ = Lfl ∪ Ltyp, Ldyn = Lfl ∪ L+act, and L = Lfl,typ ∪ L+act.\nDefinition 15 (Causation rule). A (causation) rule is an expression of the form caused f if b1, . . . , bk, not bk+1, . . ., not b` after a1, . . . , am, not am+1, . . ., not an. were f ∈ Lfl ∪ {false}, bi ∈ Lfl,typ, ai ∈ L, ` ≥ k ≥ 0 and n ≥ m ≥ 0.\nIf n = 0 the rule is called static. We define h(r) = f , pre+(r) = {a1, . . . , am}, pre−(r) = {am+1, . . . , an},\npost+(r) = {b1, . . . , bk}, post−(r) = {bk+1, . . . , b`}\nDefinition 16 (Initial state constraints). An initial state constraint is a static rule preceded by the keyword initially.\nDefinition 17 (Executability condition). An executability condition e is an expression of the form executable a if b1, . . . , bk, not bk+1, . . ., not b`. were a ∈ L+act, bi ∈ Lfl,typ, and ` ≥ k ≥ 0.\nWe define h(e) = a, pre+(e) = {b1, . . . , bk}, and pre−(e) = {bk+1, . . . , b`}\nSince in this document we’re dealing with ground plans, for the definition of typed instantiation the reader is referred to the original paper.\n8 In the following we will use safeness as a synonym of 1-safeness.\nDefinition 18 (Planning domain, [9] Def. A.5). An action description 〈D,R〉 consists of a finite setD of action and fluent declarations and a finite setR of safe causation rules, safe initial state constraints, and safe executability conditions. A K planning domain is a pair PD = 〈Π,AD〉, where Π is a stratified Datalog program (the background knowledge) which is safe, and AD is an action description. We call PD positive, if no default negation occurs in AD.\nThe set lit(PD) contains all the literals appearing in PD.\nDefinition 19 (State, State transition). A state w.r.t. a planning domain PD is any consistent set s ⊆ Lfl ∩ (lit(PD) ∪ lit(PD)−) of legal fluent instances and their negations. A state transition is any tuple t = 〈s,A, s′〉 where s, s′ are states and A ⊆ Lact ∩ lit(PD) is a set of legal action instances in PD.\nSemantics of plans including default negation is defined by means of a GelfondâĂŞLifschitz type reduction to a positive planning domain.\nDefinition 20. Let PD be a ground and well-typed planning domain, and let t = 〈s,A, s′〉 be a state transition. Then, the reduction PDt of PD by t is the planning domain where the set of rules R of PD is substituted by Rt obtained by deleting\n1. each r ∈ R,where either post−(r) ∩ s′ 6= ∅ or pre−(r) ∩ s 6= ∅,and 2. all default literals not ` (` ∈ L) from the remaining r ∈ R.\nDefinition 21 (Legal initial state, executable action set, legal state transition). For any planning domain PD = 〈D,R〉\n– a state s0 is a legal initial state, if s0 is the least set s.t. for all static and initial rules r post(r) ⊆ s0 implies h(r) ⊆ s0; – a set A ⊆ L+act is an executable action set w.r.t. a state s, if for each a ∈ A there is an executability condition e ∈ R〈s,A,∅〉 s.t. h(e) = {a}, pre(e) ∩ Lfl ⊆ s, and pre(e) ∩ L+act ⊆ A; – a state transition t = 〈s,A, s′〉 is legal if A is an executable action set w.r.t. s, and s′ is the minimal consistent set that satisfies all causation rules in R〈s,A,s′〉 w.r.t. s ∪A. A causation rule r ∈ R〈s,A,s′〉, is satisfied if the three conditions 1. post(r) ⊆ s′ 2. pre(r) ∩ Lfl ⊆ s 3. pre(r) ∩ Lact ⊆ A all hold, then h(r) 6= {false} and h(r) ⊆ s′.\nDefinition 22 (Trajectory). A sequence of state transitions\n〈s0, A1, s1〉, 〈s1, A2, s2〉, . . . , 〈sn−1, An, sn〉\n, n ≥ 0, is a trajectory for PD, if s0 is a legal initial state of PD and all 〈si−1, Ai, si〉, 1 ≤ i ≤ n, are legal state transitions of PD.\nIf n = 0, then the trajectory is empty.\nDefinition 23 (Planning problem). A planning problem is a pair of planning domain PD and a ground goal q\ng1, . . . , gm, not gm+1, . . ., not gn. where gi ∈ Lft and n ≥ m ≥ 0.\nA state s satisfies the goal if {g1, . . . , gm} ⊆ s and {gm+1, . . . , gn} ∩ s = ∅.\nDefinition 24 (Optimistic plan). A sequence of action setsA1, . . . , Ak is an optimistic plan for a planning problem 〈PD, q〉 if there is a trajectory 〈s0, A1, s1〉, . . . , 〈sk−1, Ak, sk〉 establishing the goal q, i.e. sk satisfies q.\nDefinition 25 (Secure plan). An optimistic planA1, . . . , An is secure if for every legal initial state s0 and trajectory 〈s0, A1, s1〉, 〈s1, A2, s2〉, . . . , 〈sk−1, Ak, sk〉 0 ≤ k ≤ n, it holds that\n1. if k = n then sk satisfies the goal; 2. if k < n, then there is a legal transition 〈sk, Ak+1, sk+1〉."
    }, {
      "heading" : "B Framework",
      "text" : "B.1 Data Model\nDefinition 26 (Data model). A data model for is a coupleD = (V, ∆, dm, ord) where: – V is a possibly infinite set of variables; – ∆ = {∆1, . . . ,∆n} is a set of domains (not necessarily disjoints); – dm : V → ∆ is a total and surjective function which associate to each variable v its finite domain ∆i;\n– ord is a partial function that, given a domain∆i, if ord(∆i) is defined, then it returns a partial order (reflexive, antisymmetric and transitive) ≤∆i⊆ ∆i ×∆i.\nDefinition 27 (Assignment). LetD = 〈V, ∆, dm, ord〉 be a data model. An assignment for variables in V is a partial function η : V → ∆v such that for each v ∈ V , if η(v) is defined, then we have η(v) ∈ dm(v). We write Φ[η] for the formula Φ where each occurrence of a variable v ∈ img(η) is replaced by η(v).\nDefinition 28 (Guard language, syntax). Given a data model, the language L(D) of guards is the set of formulas Φ inductively defined according to the following grammar:\nΦ := true | def(v) | t1 = t2 | t1 ≤ t2 | ¬Φ1 | Φ1 ∧ Φ2 where v ∈ V and t1, t2 ∈ V ∪ ⋃ i∆i.\nDefinition 29 (Guard language, semantics). Given a data model D, an assignment η and a guard Φ ∈ L(D) we say that D, η satisfies Φ, written D, η |= Φ inductively on the structure of Φ as follows:\n– D, η |= true; – D, η |= def(v) iff v ∈ img(η); – D, η |= t1 = t2 iff t1[η], t2[η] 6∈ V and t1[η] ≡ t2[η]; – D, η |= t1 ≤ t2 iff t1[η], t2[η] ∈ ∆i for some i and ord(∆i) is defined and t1[η] ≤∆i t2[η]; – D, η |= ¬Φ iff it is not the case that D, η |= Φ; – D, η |= Φ1 ∧ Φ2 iff D, η |= Φ1 and D, η |= Φ2.\nB.2 Petri Nets with Data\nDefinition 30 (DAW-net). A Petri Net with data is a tuple 〈D,N ,wr, gd〉 where:\n– N = 〈P, T, F 〉 is a Petri Net; – D = 〈V, ∆, dm, ord〉 is a data model; – wr : T 7→ (V ′ 7→ 2dm(V)), where V ′ ⊆ V and wr(t)(v) ⊆ dm(v) for each v ∈ V ′, is\na function that associate each transition to a (partial) function mapping variables to a subset of their domain.\n– gd : T 7→ L(D) a function that associates a guard expression to each transition.\nThe definition of wr provides a fine grained description of the way that transitions modify the state of the DAW-net, enabling the description of different cases:\n– ∅ ⊂ wr(t)(v) ⊆ dm(v): transition t nondeterministically assigns a value from wr(t)(v) to v;9 – wr(t)(v) = ∅: transition t deletes the value of v (undefined); – v 6∈ dom(wr(t)): value of v is not modified by transition t.\nDefinition 31. A state of a DAW-net 〈D,N ,wr, gd〉 is a pair (M,η) where M is a marking for 〈P, T, F 〉 and η is an assignment. State transitions and firing are adapted to the additional information about data.\nDefinition 32 (Valid Firing). Given a DAW-net 〈D,N ,wr, gd〉, a firing of a transition t ∈ T is valid firing in (M,η) resulting in a state (M ′, η′) (written as (M,η) t→ (M ′, η′)) iff:\n– t is enabled inM , i.e., {p ∈ P |M(p) > 0} ⊇ •t; and – D, η |= gd(t); – the markingM ′ satisfies the property that for every p ∈ P :\nM ′(p) =  M(p)− 1 if p ∈ •t \\ t•\nM(p) + 1 if p ∈ t• \\ •t M(p) otherwise\n– the assignment η′ satisfies the properties that its domain is\ndom(η′) = dom(η) ∪ {v | wr(t)(v) 6= ∅} \\ {v | wr(t)(v) = ∅}\nand for each v ∈ dom(η′):\nη′(v) = { d ∈ wr(t)(v) if v ∈ dom(wr(t)) η(v) otherwise.\nCases of DAW-net are defined as those of WF-nets, with the only difference that in the initial state the assignment is empty.\n9 Allowing a subset of dm(v) enables the specification of restrictions for specific tasks, e.g., while a task selects among yes, no, maybe another one can only choose between yes and no."
    }, {
      "heading" : "C Trace completion as Reachability",
      "text" : "Within this document we consider the possibility that some of the activities can be observable or not. In the sense that they might or can never appear in logs. This enables a fine grained information on the different type of activities that compose a process. For example, is common practice in modelling the introduction of transitions for routing purposes (e.g. and-joins) that do not correspond to real activities and as such they would never be observed. On the other end, some activities must be logged by their nature – e.g. a database update – so if they are not observed we can be sure that they never occurred. We use the term always observable for transitions that must appear in the logs and never observable for those that would never appear in logs; all other transitions may or may not be present in the logs but they may occur in actual cases.\nSince the focus of the paper is on the use of planning techniques to provide reasoning services for workflows with data, we decided to omit this aspect for reasons of space.\nDefinition 33 (Trace). Let Let P = 〈D,N ,wr, gd〉 be a DAW-net. An event of P is a tuple 〈t, w,wd〉 where t ∈ T is a transition, w ∈ dm(V)V′ – with V ′ ⊆ V and w(v) ∈ wr(t)(v) for all v ∈ V ′ – is a partial function that represents the variables written by the execution of t, and wd ⊆ V the set of variables deleted (undefined) by the execution of t. Obviously, wd ∩ V ′ = ∅.\nA trace of P is a finite sequence of events τ = (e1, . . . , en). In the following we indicate the i-th event of τ as τ i. Given a set of tasks T , the set of traces is inductively defined as follows: – is a trace; – if τ is a trace and e an event, then τ · e is a trace.\nDefinition 34 (Trace Compliance). A (valid) firing (M,η) t→ (M ′, η′) is compliant with an event 〈t′, w, wd〉 iff t = t′, wd = {v | wr(t′)(v) = ∅}, dom(η′) = dom(w) ∪ dom(η) \\ wd, and for all v ∈ dom(w) w(v) = η′(v).\nA case (M0, η0) t1→ (M1, η1) . . . (Mk−1, ηk−1) tk→ (Mk, ηk)\nis compliant with the trace τ = (e1, . . . , e`) iff there is an injective mapping γ between [1 . . . `] and [1 . . . k] such that:10\n∀i, j s.t. 1 ≤ i < j ≤ ` γ(i) < γ(j) (1)\n∀i s.t. 1 ≤ i ≤ ` (Mγ(i−1), ηγ(i−1)) tγ(i)→ (Mγ(i), ηγ(i)) is compliant with ei (2)\n∀i s.t. 1 ≤ i ≤ k ti always observable implies ∃j s.t. γ(j) = i (3)\nWe assume that theworkflow starts and terminateswith special transitions – indicated by startt and endt – while start and end denote start place and sink respectively.\nDefinition 35 (Trace workflow). Let W = 〈D,N = 〈P, T, F 〉,wr, gd〉 be a DAW-net and τ = (e1, . . . , en) – where ei = 〈ti, wi, wdi 〉 – a trace of W . The trace workflow\n10 If the trace is empty then ` = 0 and γ is empty."
    }, {
      "heading" : "W τ = 〈D,N τ = 〈P τ , T τ , F τ 〉,wrτ , gdτ 〉 is defined as following:",
      "text" : "P τ = P ∪ {pe0} ∪ {pe | e ∈ τ} pe0 , pe new places T τ = T ∪ {te | e ∈ τ} te new transitions F τ = F ∪\n{(tei , p) | i = 1 . . . n, (ti, p) ∈ F} ∪ {(p, tei) | i = 1 . . . n, (p, ti) ∈ F} ∪ {(tei , pei) | i = 1 . . . n} ∪ {(pei−1 , tei) | i = 1 . . . n} ∪ {(startt, pe0), (pen , endt)}\nwrτ (t) = { {(v, {j}) | (v, j) ∈ wi} ∪ {(v, ∅) | v ∈ wdi } for t = tei wr(t) for t ∈ T\ngdτ (t) =  gd(ti) for t = tei false for t ∈ T fully observable gd(t) for t ∈ T not fully observable\nIt’s not difficult to see that whenever the original DAW-net W is a workflow net, thenW τ is a workflow net as well because the newly introduced nodes are in a the path start, startt, pe0 , te1 , pe1 , . . . , ten , pen , endt, end.\nTo relate cases from W τ to the original workflow W we introduce a “projection” function Πτ that maps elements from cases of the enriched workflow to cases using only elements from the original workflow. To simplify the notation we will use the same name to indicate mappings from states, firings and cases.\nDefinition 36. Let W = 〈D,N = 〈P, T, F 〉,wr, gd〉 be a DAW-net, τ = (e1, . . . , en) – where ei = 〈ti, wi, wdi 〉 a trace ofW , andW τ = 〈D,N τ = 〈P τ , T τ , F τ 〉,wrτ , gdτ 〉 the corresponding trace workflow. The mapping Πτ is defined as following:\n1. let (M ′, η′) be a marking ofW τ , then\nΠτ (M ′) = (M ′ ∩ P × N)\nis a state ofW ; 2. let (M ′, η′) be a state ofW τ , then\nΠτ ((M ′, η′)) = (Πτ (M ′), η′)\nis a state ofW ; 3. let t be a transition in T τ , then\nΠτ (t) = { ti for t = tei t for t ∈ T\n4. let (M,η) t→ (M ′, η′) be a firing inW τ , then\nΠτ ((M,η) t→ (M ′, η′)) = Πτ ((M,η)) Πτ (t)→ Πτ ((M ′, η′))\n5. let C = f0, . . . , fk be a case ofW τ , then\nΠτ (C) = Πτ (f0), . . . ,Πτ (fk)\nIn the following we consider a DAW-net W = 〈D,N = 〈P, T, F 〉,wr, gd〉 and a trace τ = (e1, . . . , en) ofW –where ei = 〈ti, wi, wdi 〉. LetW τ = 〈D,N τ = 〈P τ , T τ , F τ 〉,wrτ , gdτ 〉 be the corresponding trace workflow. To simplify the notation, in the following we will use te0 as a synonymous for startt and ten+1 as endt; as if they were part of the trace.\nLemma 5. Let C be a case ofW τ , then Πτ (C) is a case ofW .\nProof. Let C = (M0, η0) t1→ (M1, η1) . . . (Mk−1, ηk−1) tk→ (Mk, ηk), to show that Πτ (C) is a case of W we need to prove that (i) Πτ ((M0, η0)) is an initial state of W and that (ii) the firingΠτ ((Mi−1, ηi−1)\nti→ (Mi, ηi)) is valid w.r.t.W for all 1 ≤ i ≤ n. i) By definition Πτ ((M0, η0)) = (Πτ (M0), η′) and Πτ (M0) ⊆ M0. Since the start\nplace is in P , then start is the only place with a token in Πτ (M0). ii) Let consider an arbitrary firing fi = (Mi−1, ηi−1)\nti→ (Mi, ηi) in C (valid by definition), then Πτ (fi) = (Πτ (Mi−1), ηi−1)\nΠτ (ti)→ (Πτ (Mi), ηi). Note that – by construction – gd(ti) = gd(Πτ (ti)),Πτ (ti)• = t•i ∩ P , •Πτ (ti) = •ti ∩P , dom(wr(ti)) = dom(wr(Πτ (ti))) and wr(ti)(v) ⊆ wr(Πτ (ti))(v) ; therefore – {p ∈ P τ | Mi−1 > 0} ∩ P = {p ∈ P | Πτ (Mi−1) > 0} ⊇ •Πτ (ti) because {p ∈ P τ |Mi−1 > 0} ⊇ •ti;\n– D, η |= gd(Πτ (ti)) because D, η |= gd(ti) – for all p ∈ P Πτ (Mj)(p) =Mj(p), therefore:\nMi(p) = Πτ (Mi)(p) =  Mi−1(p)− 1 = Πτ (Mi−1)(p)− 1 if p ∈ •Πτ (ti) \\Πτ (ti)•\nMi−1(p) + 1 = Πτ (Mi−1)(p) + 1 if p ∈ Πτ (ti)• \\ •Πτ (ti) Mi−1(p) = Πτ (Mi−1)(p) otherwise\nbecause fi is valid w.r.t.W τ ; – the assignment ηi satisfies the properties that its domain is\ndom(ηi) = dom(ηi−1)∪{v | wr(Πτ (ti))(v) 6= ∅}\\{v | wr(Πτ (ti))(v) = ∅}\nand for each v ∈ dom(ηi):\nηi(v) = { d ∈ wr(ti)(v) ⊆ wr(Πτ (ti))(v) if v ∈ dom(wr(ti)) = dom(wr(Πτ (ti))) ηi−1(v) otherwise.\nbecause fi is valid.\nBefore going into details, we will consider some properties of the “trace” workflow.\nLemma 6. LetW = 〈D,N = 〈P, T, F 〉,wr, gd〉 be a DAW-net and τ = (e1, . . . , en) – where ei = 〈ti, wi, wdi 〉–a trace ofW . IfC = (M0, η0) t1→ (M1, η1) . . . (Mk−1, ηk−1) tk→ (Mk, ηk) is a case ofW τ then for all 0 ≤ i ≤ k:\nΣp∈P τ\\PMi(p) ≤M0(start)\nProof. By induction on the length of C.\n– For k = 1 then the only executable transition is startt, therefore t1 = startt which – by assumption – has two output places and – by construction – start•t \\P = {pe0}. Since the firing is valid, thenM1(pe0) =M0(pe0) + 1 = 1 ≤M0(start). – Let’s assume that the property is true a case C of length n and consider C ′ = C(Mn, ηn)\ntn+1→ (Mn+1, ηn+1). By construction, each p ∈ P τ \\ P has a single incoming edge and {t ∈ T τ | ei ∈ t•} = {tei} and {t ∈ T τ | ei ∈ •t} = {tei+1}. Therefore the only occurrence in which a pei ∈ P τ \\ P can increase its value is when tn+1 = tei . Since the transition is valid, thenMn+1(pei) =Mn(pei)+1 and Mn+1(pei−1) =Mn(pei−1)−1; thereforeΣp∈P τ\\PMi(p) = Σp∈P τ\\PMi−1(p) ≤ M0(start) – by the inductive hypothesis.\nLemma 7. LetW = 〈D,N = 〈P, T, F 〉,wr, gd〉 be a DAW-net and τ = (e1, . . . , en) – where ei = 〈ti, wi, wdi 〉 – a trace ofW ,C = (M0, η0) t1→ (M1, η1) . . . (Mk−1, ηk−1) tk→ (Mk, ηk) a case ofW τ , and tei is a transition of a firing fm in C with 1 ≤ i ≤ n, then (i) tei−1 is in a transition of a firing in C that precedes fm, (ii) and ifM0(start) = 1 then there is a single occurrence of tei in C.\nProof. The proof for the first part follows from the structure of the workflow net; because – by construction – each p ∈ P τ \\ P has a single incoming edge and {t ∈ T τ | ei ∈ t•} = {tei} and {t ∈ T τ | ei ∈ •t} = {tei+1}. Since each firing must be valid – if fm = (Mm−1, ηm−1) tei→ (Mm, ηm) is in C, thenMm−1(pei−1) ≥ 1 and this can only be true if there is a firing fr = (Mr−1, ηr−1) tei−1→ (Mr, ηr) in C s.t. r < m.\nTo prove the second part is enough to show that for each 1 ≤ i ≤ n, if tei appears more than once in C then there must be multiple occurrences of tei−1 as well. In fact, if this is the fact, then we can use the previous part to show that there must be multiple occurrences of te0 = start, and this is only possible ifM0(start) > 1.\nBy contradiction let’s assume that there are two firings fm and f ′m, with m < m′, with the same transition tei , but there is only a single occurrence of tei−1 in a firing fr. Using the previous part of this lemma we conclude that r < m < m′, therefore Mm−1(pei−1) = 1 because a token could be transferred into pei−1 only by tei−1 , so Mm(pei−1) = 0. In the firings betweenm andm′ there are no occurrences of tei−1 , so Mm′−1(pei−1) = Mm(pei−1) = 0 which is in contradiction with the assumption that f ′m is a valid firing.\nNow we’re ready to show that the “trace” workflow characterises all and only the cases compliant wrt the given trace. We divide the proof into correctness and completeness.\nLemma 8 (Correctness).LetC = (M0, η0) t1→ (M1, η1) . . . (Mk−1, ηk−1) tk→ (Mk, ηk) be a case ofW τ s.t.M0(start) = 1, and ` = max({i | ti is in a firing of C} ∪ {0}), then the caseΠτ (C) ofW is compliant with τ ′ = (e1, . . . , e`) or the empty trace if ` is 0.\nProof. By induction on the length of C.\n– If C = (M0, η0) t1→ (M1, η1) then t1 = startt because the firing is valid and the\nonly place with a token inM0 is start; therefore ` = 0 and τ ′ is the empty trace. C trivially satisfy the empty trace because no observable transitions are in Πτ (C).\n– Let C = (M0, η0) t1→ (M1, η1) . . . (Mk−1, ηk−1) tk→ (Mk, ηk) s.t. Πτ (C) is compliant with τ ′. Let’s consider C ′ = C · (Mk, ηk)\ntk+1→ (Mk+1, ηk+1): either tk+1 ∈ T τ \\ T or tk+1 ∈ T . In the first case tk+1 = te` for some 1 ≤ ` ≤ n, and – by using Lemma 7 – inC there are occurrences of all the tei for 1 ≤ i < ` and it’s the only occurrence of te` . This means that ` = max({i | ti is in a firing of C} ∪ {0}) and we can extend γ to γ′ by adding the mapping from ` to k + 1. The mapping is well defined because of the single occurrence of te` . By definition of te` , (Mk, ηk)\ntk+1→ (Mk+1, ηk+1) is compliant with e` and the mapping Πτ preserve the assignments, therefore Πτ (Mk, ηk)\ntk+1→ (Mk+1, ηk+1) is compliant with e` as well. By using the inductive hypnotises we can show that C ′ is compliant as well. In the second case the mapping is not modified, therefore the inductive hypothesis can be used to provide evidence of the first two conditions for trace compliance of Definition 34. For the third (transitions always observable) it’s sufficient to consider that tk+1 cannot be always observable because its guard is never satisfiable inW τ .\nLemma 9 (Completeness).LetC = (M0, η0) t1→ (M1, η1) . . . (Mk−1, ηk−1) tk→ (Mk, ηk) be a case of W compatible with τ = (e1, . . . , en), then there is a case C ′ of W τ s.t. Πτ (C ′) = C.\nProof. Since C is compliant with τ , then there is a mapping γ satisfying the conditions of Definition 34. Let C ′ = (M ′0, η0) t′1→ (M ′1, η1) . . . (M ′k−1, ηk−1)\nt′k→ (M ′k, ηk) a sequence of firing ofW τ defined as following:\n– M ′0 =M0 ∪ {(pei , 0) | 0 ≤ i ≤ n} – t′1 = t1 andM ′1 =M1 ∪ {(pej , 0) | 1 ≤ j ≤ n} ∪ {(pe0 , 1)} – for each (M ′i−1, ηi−1) t′i→ (M ′i , ηi), 2 ≤ i ≤ n:\n• if there is ` s.t. γ(`) = i then t′i = te` and\nM ′i =Mi ∪ {(pej , 0) | 0 ≤ j ≤ n, j 6= `} ∪ {(pe` , 1)}\n• otherwise t′i = ti and\nM ′i =Mi ∪ (M ′i−1 ∩ (P τ \\ P )× N)\nIt’s not difficult to realise that by construction Πτ (C ′) = C. To conclude the proof we need to show thatC ′ is a case ofW τ . Clearly (M ′0, η0) is a starting state, so we need to show that all the firings are valid. The conditions involving variables – guards and update of the assignment – follows from the fact that the original firings are valid and the newly introduced transitions are restricted according to the trace data.\nConditions on input and output places that are both in W and W τ are satisfied because of the validity of the original firing. The newly introduced places satisfy the conditions because of the compliance wrt the trace, which guarantees that for each firing with transition te` there is the preceding firing with transition te`−1 that put a token in the pe`−1 place.\nTheorem 3. LetW be a DAW-net and τ = (e1, . . . , en) a trace; thenW τ characterises all and only the cases ofW compatible with τ . That is ⇒ if C is a case ofW τ containing ten then Πτ (C) is compatible with τ ; and ⇐ ifC is a case ofW compatible with τ , then there is a caseC ′ ofW τ s.t.Πτ (C ′) = C.\nProof.\n⇒ If C is a case ofW τ containing ten , then ` of Lemma 8 is n therefore τ ′ = τ and Πτ (C) is compatible with τ . ⇐ IfC is compatiblewith τ then byLemma9 there is a caseC ′ ofW τ s.t.Πτ (C ′) = C.\nTheorem 4. LetW = 〈D,N = 〈P, T, F 〉,wr, gd〉 be a DAW-net and τ = (e1, . . . , en) – where ei = 〈ti, wi, wdi 〉 – a trace ofW . IfW is k-safe thenW τ is k-safe as well.\nProof. We prove the theorem by induction on the length of a case C = (M0, η0) t1→ (M1, η1) . . . (Mk−1, ηk−1) tk→ (Mk, ηk). Note that by construction, for any markingM ′ ofW τ and p ∈ P ,M ′(p) = Πτ (M ′)(p).\n– For a case of length 1 the property trivially holds because by definitionM0(start) ≤ k and for each p ∈ P τ (different from start)M0(start) = 0, and since (M0, η0)\nt1→ (M1, η1) is valid the only case in which the number of tokens in a place is increased is for p ∈ t•1 \\ •t1. For any p different from start this becomes 1 ≤ k; while since the start place – by assumption – doesn’t have any incoming arc therefore M1(start) =M0(start)− 1 ≤ k. – For the inductive step we assume that each marking M0, . . .Mm−1 is k-safe. By contradiction we assume that Mm is not k-safe; therefore there is a place p ∈ P τ s.t. Mm > k. There are two cases, either p ∈ P τ \\ P or p ∈ P . In the first case there is a contradiction because, by Lemma 6, Σp∈P τ\\PMi(p) ≤M0(start) = k. In the second case, since Πτ (C) is a case ofW and Πτ (Mm)(p) =Mm(p), there is a contradiction with the hypothesis thatW is k-safe."
    }, {
      "heading" : "D Encoding Reachability as Planning Problem",
      "text" : "D.1 Encoding WF-nets behaviour\nLet PN = 〈D,N = 〈P, T, F 〉,wr, gd〉 be a safe DAW-net be a safe WF-net, we define the planning problem Ω(W ) = 〈Π,D,R, q〉 by introducing a fluent for each place and an action for each task. Execution and causation rules constraint the plan to mimic the behaviour of the petri net.\nDeclarations\n– D contains a fluent declaration p for each place p ∈ P ; – D contains an action declaration t for each task t ∈ T ;\nExecutability rules\n– actions are executable if each input place has a token; i.e. for each task t ∈ T , given {it1, . . . , itn} = •t, there’s an executability rule:\nexecutable t if it1, . . . , itn.\nCausation rules\n– parallelism is disabled; for each pair of tasks t1, t2 ∈ T there’s the rule:11 caused false after t1, t2. – after the execution of a task, input conditions must be “cleared” and tokens moved to the output ones; for each task t ∈ T and {it1, . . . , itn} = •t \\ t•, {ot1, . . . , otk} = t•:\ncaused −it1 after t. . . . caused −itn after t. caused ot1 after t. . . . caused otk after t.\n– the positive state of the places is inertial (i.e. must be explicitly modified); for each p ∈ P :\ncaused p if not −p after p.\nInitial state\n– The only place with a token is the source: initially: i.\nGoal\nThe formulation of the goal depends on the actual instance of the reachability problem we need to solve. E.g. it can be a specific marking:\n– The only place with a token is the sink: goal: o, not p1, . . ., not pk?\nwhere {p1, . . . , pk} = P \\ {o}.\nD.2 Encoding of Data\nTo each variable v ∈ V corresponds to a inertial fluent predicate varv with a single argument “holding” the value of the variable, and a “domain” predicate domv representing the domain of the variable. Unset variables have no positive instantiation of the varv predicate. The predicate varv must be functional.\nWe introduce also auxiliary fluents that indicate whether a variable is not undefined defv – used both in tests and to enforcemodels where the variable is assigned/unassigned – and chngv to “inhibit” inertia when variables might change because of the result of an action.\n11 There’s aKmacro to disable concurrency. In practice concurrency could be enabled for actions that do not share input or output places.\nConstraints on variables For each variable v ∈ V:\n– functionality caused false if varv(X), varv(Y), X != Y. – variable defined predicate caused defv if varv(X). – variable fluents are inertial unless they can be modified by actions caused varv(X) if not −varv(X), not chngv after varv(X). – the background knowledge (Π) includes the set of facts: domv,t(d).\nfor each v ∈ V , t ∈ T , and d ∈ wr(t)(v).\nGuards To each task t is associated a fluent grdt that is true when the corresponding guard is satisfied. Instead of modifying the executability rule including the grdt among the preconditions, we use a constraint rule ruling out executions of the action whenever its guard is not satisfied:\ncaused false after t, not grdt. This equivalent formulation simplify the proofs because of its incremental nature (there are just additional rules).\nTranslation of atoms (ξ) is defined in terms of varv predicates, e.g., ξ(v = w) corresponds to varv(V), varw(W), V == W. The defv predicate can be used to test whether a variable is defined, or undefined, i.e. not defv .\nThe guard gd(t) = (a1,1 ∧ . . .∧ a1,n1)∨ . . .∨ (ak,1 ∧ . . .∧ ak,nk) where each ai,j is an atom, corresponds to the set of rules for grdt:12\ncaused grdt if ξ(a1,1), . . ., ξ(a1,n1). ... caused grdt if ξ(ak,1), . . ., ξ(a1,nk).\nVariables update The value of a variable is updated by means of causation rules that depend on the task t that operates on the variable:\n– wr(t)(v) = ∅: delete (undefine) a variable v caused false if defv after t. caused chngv after t. – wr(t)(v) ⊆ dm(v): set v with a value nondeterministically chosen among a set of elements from its domain\ncaused varv(V) if domv,t(V), not −varv(V) after t. caused −varv(V) if domv,t(V), not varv(V) after t. caused chngv after t. caused false if not defv after t.\nIf wr(t)(v) contains a single element e, then there the assignment is deterministic and the above rules can be substituted with13\n12 Arbitrary expressions can be easily translated by introducing newfluents for the subexpressions. 13 The deterministic version is a specific case of the non-deterministic ones and equivalent in the case that there is a single domv,t(d) fact. In the following, the proofs will consider the general non-deterministic formulation only.\ncaused varv(d) after t. caused chngv after t.\nGuards To each subformula ϕ of transition guards is associated a fluent grdϕ that is true when the corresponding formula is satisfied. To simplify the notation, for any transition t, we will use grdt to indicate the fluent grdgd(t).\nExecutability of transitions is conditioned to the satisfiability of their guards: caused false after t, not grdt. Translation of atoms (ξ) is defined in terms of varv predicates. We assume a binary ord predicate representing the partial order among the elements of the domains. We also assume that elements of ⋃ i∆i can be directly represented by constants of K language.\nFor t ∈ V ∪ ⋃ i∆i and T a K variable we define\nξ(t, T ) = { vart(T) for t ∈ V T == t for t ∈ ⋃ i∆i\nFor each subformula ϕ of transition guards a static rule is included to “define” the\nfluent grdϕ:\ntrue : caused grdϕ if true . def(v) : caused grdϕ if defv . t1 = t2 : caused grdϕ if ξ(t1,T1), ξ(t2,T2), T1 == T2 . t1 ≤ t2 : caused grdϕ if ξ(t1,T1), ξ(t2,T2), ord(T1,T2) . ¬ϕ1 : caused grdϕ if not grdϕ1 .\nϕ1 ∧ . . . ∧ ϕn : caused grdϕ if grdϕ1 , . . . , grdϕn .\nD.3 Correctness and completeness\nDefinition 37 (Φ(·) function). Let W = 〈D,N = 〈P, T, F 〉,wr, gd〉 be a safe DAWnet,M the set of its markings, H the set of all assignments, Ω(W ) the corresponding planning problem and S the set of its states, namely, the set of all consistent set of ground fluent literals. We define the function Φ(·) : S → M× H mapping planning and DAW-net states. For any consistent s ∈ S, Φ(s) = (M,η) is defined as follows:\n∀p ∈ P M(p) = { 1 if p ∈ s 0 otherwise\nη = {(v, d) | varv(d) ∈ s}\nThe function Φ(·) is well defined because s is assumed to be consistent therefore it cannot be the case that {varv(d), varv(d′)} ⊆ s with d 6= d′ otherwise the static rule\ncaused false if varv(X), varv(Y), X != Y. would not be satisfied.\nMoreover, since we assume thatW is safe, we can restrictM to markings with range restricted to {0, 1} and there is not loss of information between markings and planing states.\nThe function Φ(·) is not injective because of the strongly negated atoms. However it can be shown that if two states differ on the positive atoms then the corresponding DAW-net states are different as well:\nLemma 10. Let s and s′ consistent states in S, then s ∩ L+ 6= s′ ∩ L+ implies Φ(s) 6= Φ(s′).\nObserving the static rules (those without the after part) it can be noted those defining the predicates defv and grdt are stratified, therefore their truth assignment depends only on the extension of varv(·) predicates. This fact can be used to show that\nLemma 11 (Guards translation). Let s ∈ S satisfying the static rules ofΩ(W ), and ϕ a subformula of transition guards inW . Given Φ(s) = (M,η), grdϕ ∈ s iff D, η |= ϕ.\nProof. We prove the lemma by structural induction on ϕ. First we consider the base cases. true : trivially satisfied because true is in consistent state. def(v) : the only rule where defv is in the head is\ncaused defv if varv(X). therefore defv ∈ s iff there is a constant d s.t. varv(d) ∈ s, and that is the case iff v ∈ dom(η). t1 = t2 : for the sake of simplicity we consider only the case in which t1 ≡ v is a variable and t2 ≡ d is a constant; the other 3 combinations can be demonstrated in the same way. With this assumption, the only rule with grdϕ in the head is\ncaused grdϕ if varv(T1), T2 == d, T1 == T2 . therefore grdϕ ∈ s iff varv(d) ∈ s, and this is the case iff η(v) = d.\nt1 ≤ t2 : this case is analogous to the previous one, where we consider the predicate ord(T1,T2) instead of equality. Since ord facts correspond to the orders defined in D, then we can conclude. For the inductive step we assume that the property holds for subformulae ϕ1, ϕ2.\n¬ϕ1 : the only rule with grdϕ in the head is caused grdϕ if not grdϕ1 .\ntherefore grdϕ ∈ s iff grdϕ1 6∈ s. We can use the inductive hypothesis to conclude that this is the case iff D, η 6|= ϕ1, that is D, η |= ϕ.\nϕ1 ∧ . . . ∧ ϕn : the only rule with grdϕ in the head is caused grdϕ if grdϕ1 , . . . , grdϕn .\ntherefore grdϕ ∈ s iff {grdϕ1 , . . . , grdϕn} ⊆ s. We can use the inductive hypothesis to show that this is the case iff D, η |= ϕ1 ∧ . . . ϕn because they are all ground terms.\nLooking at the guard translation rules and the proof of Lemma 11 it is not difficult to realise that according to the structure of the guards some of the rules are redundant and can be simplified. E.g. defv can be used in place of grddefv , not grdϕ in place of grddef¬ϕ , and t1 = t2 can be expanded in place of grdt1=t2 unless they are in the scope of a negation.\nLemma 12 (Completeness). LetW be a safe DAW-net and Ω(W ) the corresponding planning problem.\nLet (M,η) t→ (M ′, η′) be a valid firing of W , then for each consistent state s s.t. Φ(s) = M there is a consistent state s′ s.t. Φ(s′) = M ′ and 〈s, {t}, s′〉 is a legal transition in Ω(W ).\nProof. Let s be a consistent state s.t. Φ(s) = M . Note that such s exists because Φ(·) involves only the positive literals; therefore any consistent set s′ s.t. {p ∈ P | M(p) > 0} ∪ {varv(d) | (v, d) ∈ η} ⊆ s′ and s′ ∩ ({p ∈ P | M(p) < 1} ∪ V × dm(V) \\ η satisfies the property that Φ(s′) =M .\nWe define a new state s′ such that 〈s, {t}, s′〉 is a legal state transition and such that Φ(s′) =M ′; this new state is the union of the following parts:\ns′P+ = {p ∈ P |M ′(p) > 0} s′P− = {−p | p ∈ •t \\ t•} s′V+ = {varv(d) | (v, d) ∈ η ′} s′V− = {−varv(d) | d ∈ wr(t)(v), (v, d) 6∈ η ′} s′V↓ = {defv | varv(d) ∈ s ′ V+}\ns′Vc = {chngv | v ∈ dom(wr(t))} s′wr = {domv,t(d) | ∀v, t, d.d ∈ wr(t)(v)} s′gd = {grdt | ∀t.M, η |= gd(t)}\nBy constructionΦ(s′) =M and it is consistent: s′P+∩s ′ P− = ∅ because the fact that\n(M,η) t→ (M ′, η′) is a valid firing implies p ∈ •t \\ t•M ′(p) = 0, and s′V+ ∩ s ′ V− = ∅ because their conditions are mutually exclusive. Since (M,η) t→ (M ′, η′) is valid, then •t ⊆ s because Φ(s) = M , therefore the corresponding executable condition with t in the head executable t if it1, . . . , itn. is satisfied. We need to show that all the causation rules in Ω(W )〈s,{t},s\n′〉 are satisfied and that s′ is minimal.\n– For each pair of tasks t1, t2, the positive rule: caused false after t1, t2.\nis satisfied because there is only a task t in the action set. – Consider the rules\ncaused −ia1 after a. . . . caused −ian after a. caused oa1 after a. . . . caused oak after a.\nwhere {ia1 , . . . , ian} = •a\\a•, {oa1 , . . . , oak} = a•\\•a. For all a 6= t they are satisfied because the after condition is false. For a = t the validity of (M,η) t→ (M ′, η′) ensures that •t \\ t• ⊆ s′P− and t\n• ⊆ s′P+ , therefore the rules are satisfied. – For each p ∈ P :\ncaused p if not −p after p. we consider the three cases where p ∈ •t \\ t•, p ∈ t•, or p 6∈ (•t ∪ t•). p ∈ •t \\ t• then−p ∈ s′P− by construction, therefore the rule is not inΩ(W ) 〈s,{t},s′〉 p ∈ t• then M ′(p) = 1 and by construction p ∈ s′P+ and −p 6∈ s ′ P+ because s ′\nis consistent, so the rule caused p after p. is in Ω(W )〈s,{t},s ′〉. This rule is\nsatisfied if p ∈ s and also if p 6∈ s. p 6∈ (•t ∪ t•) then M ′(p) = M(p). If p ∈ s′P+ the rule caused p after p. is in\nΩ(W )〈s,{t},s ′〉 it’s satisfied regardless of the value ofM(p); on the other end, if p 6∈ s′ then M(p) = 0 therefore even if caused p after p. would be in Ω(W )〈s,{t},s ′〉 then it’d be satisfied because its after part is false.\n– Functionality rules caused false if varv(X), varv(Y), X != Y.\nis satisfied by construction of s′V+ – Variable defined predicate rules\ncaused defv if varv(X). are satisfied by construction of s′V↓ .\n– variable fluents are inertial – The background knowledge facts\ndomv,t(d). are satisfied by construction of s′wr\n– The guard predicates rules are satisfied by Lemma 11 and the construction of s′gd.\nFor rules involving the varv predicates (including intertiality rules) we consider the three cases: v 6∈ dom(wr(t)), wr(t)(v) = ∅, and wr(t)(v) 6= ∅. Note that, since the transition includes only t, all the rules in Ω(W )〈s,{t},s\n′〉 with a different action in the after part are satisfied; therefore we focus on the remaining ones.\nv 6∈ dom(wr(t)): in this case the only rule inΩ(W )〈s,{t},s′〉 to verify is the inertial one caused varv(X) if not −varv(X), not chngv after varv(X).\nand by construction −varv(d) 6∈ s′V− for any d and chngv 6∈ s ′ Vc . This would be not satisfied only in the case that for some d varv(d) ∈ s and varv(d) 6∈ s – which means that (v, d) ∈ η and (v, d) 6∈ η – but his would be in contradiction with the fact that (M,η) t→ (M ′, η′) is a valid firing.\nwr(t)(v) = ∅: in this case the corresponding rules are caused false if defv after t. caused chngv after t. caused varv(X) if not −varv(X), not chngv after varv(X).\nSince there is no d s.t. (v, d) ∈ η′ then varv(d′) 6∈ s′V+ for any d ′, therefore defv 6∈ s′V↓ and the first rule is satisfied. The second rule is satisfied by construction of s′Vc , and the third is not be in Ω(W )〈s,{t},s\n′〉 because chngv ∈ s′Vc . wr(t)(v) 6= ∅: the rules are\ncaused varv(V) if domv,t(V), not −varv(V) after t. caused −varv(V) if domv,t(V), not varv(V) after t. caused chngv after t. caused false if not defv after t. caused varv(X) if not −varv(X), not chngv after varv(X).\nThe first two rules are satisfied by construction of s′V+ and s ′ V− , while the third by s′Vc . The fourth because of the fact that the firing is valid, therefore there is a value d ∈ wr(t)(v) s.t. (v, d) ∈ η′, so varv(d) ∈ s′V+ and defv ∈ s ′ V↓ . Last rule is not in Ω(W )〈s,{t},s ′〉 because chngv ∈ s′Vc .\nTo demonstrate the minimality of s′ we need to show that removing one literal from any of the components s′P+ , s ′ P− , s ′ V+ , s ′ V− , s ′ V↓ , s ′ Vc , s ′ wr, s ′ gd results in some of the rules not being satisfied.\ns′P+ any p ∈ s ′ P+ is either in t • or not. In the first case removing it would not satisfy the rule\ncaused p after t. while in the second it would not satisfy the inertial rule\ncaused p if not −p after p. because −p 6∈ s′P− and p ∈ s since the firing is valid.\ns′P− removing −p from s ′ P− would not satisfy the rule caused −p after t. s′wr removing domv,t(d) from s′wr would not satisfy the rule domv,t(d). s′V+ let be varv(d) ∈ s ′ V+ : either v ∈ dom(wr(t)) or not. In the first case the rule\ncaused varv(d) if domv,t(d), not −varv(d) after t. would not be satisfied because−varv(d) 6∈ s′V− since by assumption (v, d) ∈ η\n′. In the second case the inertial rule\ncaused varv(d) if not −varv(d), not chngv after varv(d). would not be satisfied because −varv(d) 6∈ s′V− , chngv 6∈ s ′ Vc , and varv(d) ∈ s\nsince the firing is valid. s′V− removing −varv(d) from s ′ V− would not satisfy rule\ncaused −varv(d) if domv,t(d), not varv(d) after t. because varv(d) 6∈ s′V+ since (v, d) 6∈ η\n′. s′V↓ removing any of the defv′ ∈ {defv | varv(d) ∈ s ′ V+} would contradict one of the\nrules caused defv′ if varv′ (d).\nsince there is a an element d′ s.t. varv′(d′) ∈ s′V+ s′Vc removing any chngv′ ∈ {chngv | v ∈ dom(wr(t))} since v′ ∈ dom(wr(t)), so\ntherefore there is the rule caused chngv′ after t.\nthat would not be satisfied. s′gd removing grdt from s′gd would contradict one of the guard rules according to\nLemma 11.\nLemma 13 (Correctness). Let W be a safe DAW-net and Ω(W ) the corresponding planning problem.\nIf 〈s, {t}, s′〉 is a legal transition in Ω(W ), then Φ(s) t→ Φ(s′) is a valid firing of W .\nProof. Let (M,η) = Φ(s) and (M ′, η′) = Φ(s′); to show that Φ(s) t→ Φ(s′) is a valid firing ofW (see Definition 32) we need to show that: 1. t is enabled inM , i.e., {p ∈ P |M(p) > 0} ⊇ •t; and 2. D, η |= gd(t); 3. the markingM ′ satisfies the property that for every p ∈ P :\nM ′(p) =  M(p)− 1 if p ∈ •t \\ t•\nM(p) + 1 if p ∈ t• \\ •t M(p) otherwise\n4. the assignment η′ satisfies the properties that its domain is\ndom(η′) = dom(η) ∪ {v | wr(t)(v) 6= ∅} \\ {v | wr(t)(v) = ∅}\nand for each v ∈ dom(η′):\nη′(v) = { d ∈ wr(t)(v) if v ∈ dom(wr(t)) η(v) otherwise.\nSince 〈s, {t}, s′〉 is a legal transition, then the action tmust be executable, therefore the rule:\nexecutable t if it1, . . . , itn. with {it1, . . . , itn} = •t must be satisfied in s, that is •t ⊆ s and M(itj) = 1 for 1 ≤ j ≤ n.\nSince 〈s, {t}, s′〉 is a legal transition, then the rule: caused false after t, not grdt.\nmust be satisfied, therefore its body should be false. This means that grdt ∈ s and by using Lemma 11 we can conclude that D, η |= gd(t).\nTo verify the condition onM ′, for each p ∈ P we consider the three cases:\np ∈ •t \\ t• then in Ω(W ) there is the rule caused −p after t.\ntherefore p 6∈ s′ and Φ(s′)(p) = 0 p ∈ t• \\ •t then in Ω(W ) there is the rule\ncaused p after t. therefore p ∈ s′ and Φ(s′)(p) = 1\np 6∈ (•t \\ t•) ∪ (t• \\ •t) in this case none of the bodies of rules with p (or −p) in the head and an action in the body are satisfied because the only executed action is t. Therefore the only “active” rule having p (or −p) in the head can be the “inertial” one for the positive atom:\ncaused p if not −p after p. Since rules with−p in the head have their bodies falsified−p 6∈ s′. This means that the rule caused p after p. is in Ω(W )〈s,{t},s\n′〉. If Φ(s′)(p) = 0 then p 6∈ s′ therefore p 6∈ s otherwise the inertial rule would not be satisfied; so Φ(s)(p) = 0. If Φ(s′)(p) = 1 and Φ(s)(p) = 0, then s′ would not be minimal because s′ \\ {p} satisfies the only “active” rule with p in the head, therefore Φ(s)(p) = 1.\nNow we verify the conditions on η′ and for each v ∈ V we consider three distinct cases: v 6∈ dom(wr(t)), wr(t)(v) = ∅, and wr(t)(v) 6= ∅. First we should note that chngv ∈ s′ iff v ∈ dom(wr(t)), therefore only in the two latter cases where the inertial rule\ncaused varv(X) if not −varv(X), not chngv after varv(X). would not be in Ω(W )〈s,{t},s ′〉.\nv 6∈ dom(wr(t)): In this case, the only active rule where varv(·) appears in the head is the inertial\ncaused varv(X) if not −varv(X), not chngv after varv(X). while there are no rules with −varv(·) in the head, because for all actions t′ 6= t are “false” in s. Therefore −varv(d) 6∈ s and chngv 6∈ s′ so varv(d) ∈ s′ iff varv(d) ∈ s. This means that v ∈ dom(η′) iff v ∈ dom(η), and v ∈ dom(η) implies that η′(v) = η(v). wr(t)(v) = ∅: in this case if varv(d) ∈ s′ for some d, then defv ∈ s′ as well; therefore the rule\ncaused false if defv after t. caused chngv after t.\nwould not be satisfied contradicting the hypothesis that 〈s, {t}, s′〉 is a legal transition.\nwr(t)(v) 6= ∅: in this case Ω(W ) contains the rules caused varv(V) if domv,t(V), not −varv(V) after t. caused −varv(V) if domv,t(V), not varv(V) after t. caused false if not defv after t. caused chngv after t.\nSince defv ∈ s′ otherwise the third rule would not be satisfied, there there must be a d s.t. varv(d) ∈ s′, and this means that v ∈ dom(η′). Let assume that d 6∈ wr(t)(v), then it means that domv,t(d) 6∈ s′ therefore none of the rules with varv(d) in the head would be satisfied in Ω(W )〈s,{t},s ′〉 that contradicts the minimality of s′.\nThe analysis of the three cases confirms that the fourth condition is satisfied as well.\nTheorem 5. LetW be a safe WF-net and Ω(W ) the corresponding planning problem. Let (M0, η0) be the initial state of W – i.e. with a single token in the source and no assignments – and s0 the planning state satisfying the initial condition.\n(⇒) For any case\nζ : (M0, η0) t1→ (M1, η1) . . . (Mn−1, ηn−1) tn→ (Mn, ηn)\ninW there is a trajectory in Ω(W )\nη : 〈s0, {t1}, s1〉, . . . , 〈sn−1, {tn}, sn〉\nsuch that (Mi, ηi) = Φ(si) for each i ∈ {0 . . . n} and vice versa. (⇐) For each trajectory\nη : 〈s0, {t1}, s1〉, . . . , 〈sn−1, {tn}, sn〉\nin Ω(W ) the sequence of firings\nζ : Φ(s0) t1→ Φ(s1) . . . Φ(sn−1) tn→ Φ(sn)\nis a case ofW .\nProof. We first prove the left-to-right direction by induction on the length of the case.\n– Base case: by construction, Φ(s0) = (M0, η0) because of the structure of the initial state. – Inductive case: we consider a case of size n + 1. By inductive hypothesis, for the case (M0, η0) t1→ (M1, η1) . . . (Mn−1, ηn−1) tn→ (Mn, ηn) there is a trajectory\n〈s0, {t1}, s1〉, . . . , 〈sn−1, {tn}, sn〉 s.t. Φ(si) =Mi for each i ∈ {0 . . . n}. Since sn is consistent and Φ(sn) = (Mn, ηn), by Lemma 12, there is a state sn+1 s.t. 〈sn, {tn}, sn+1〉 is a legal transition and Φ(sn+1) = (Mn, ηn) thus proving the claim.\nThe right-to-left direction can be proved – in the same way as the other case – by induction on the length trajectories by using the Lemma 13."
    } ],
    "references" : [ {
      "title" : "The application of petri nets to workflow management",
      "author" : [ "W. van der Aalst" ],
      "venue" : "J. of Circuits, Sys. and Comp. 08, 21–66",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "Verification of workflow nets",
      "author" : [ "W.M.P. van der Aalst" ],
      "venue" : "Proc. of ICATPN. pp. 407–426",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Conformance checking using cost-based fitness analysis",
      "author" : [ "A. Adriansyah", "B.F. van Dongen", "W. van der Aalst" ],
      "venue" : "Proc. of EDOC. pp. 55–64",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Reasoning-based techniques for dealing with incomplete business process execution traces",
      "author" : [ "P. Bertoli", "C. Di Francescomarino", "M. Dragoni", "C. Ghidini" ],
      "venue" : "AI*IA, LNCS, vol. 8249, pp. 469–480. Springer",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Foundations of data-aware process analysis: A database theory perspective",
      "author" : [ "D. Calvanese", "G. De Giacomo", "M. Montali" ],
      "venue" : "pp. 1–12",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Computing trace alignment against declarative process models through planning",
      "author" : [ "G. De Giacomo", "F.M. Maggi", "A. Marrella", "S. Sardiña" ],
      "venue" : "ICAPS. pp. 367–375",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Completing workflow traces using action languages",
      "author" : [ "C. Di Francescomarino", "C. Ghidini", "S. Tessaris", "I.V. Sandoval" ],
      "venue" : "CAiSE. LNCS, vol. 9097, pp. 314–330. Springer",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "A logic programming approach to knowledge-state planning, II: The DLVK system",
      "author" : [ "T. Eiter", "W. Faber", "N. Leone", "G. Pfeifer", "A. Polleres" ],
      "venue" : "Art. Intell. 144(1–2), 157–211",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Soundness and Separability of Workflow Nets in the Stepwise Refinement Approach",
      "author" : [ "K. van Hee", "N. Sidorova", "M. Voorhoeve" ],
      "venue" : "ICATPN. No. 2679 in Lecture Notes in Computer Science, Springer",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "On structured workflow modelling",
      "author" : [ "B. Kiepuszewski", "A.H.M. ter Hofstede", "C.J. Bussler" ],
      "venue" : "Seminal Contributions to Information Systems Engineering",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Data-aware Process Mining: Discovering Decisions in Processes Using Alignments",
      "author" : [ "M. de Leoni", "W. van der Aalst" ],
      "venue" : "Proc of ACM SAC. pp. 1454–1461",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Data- and resource-aware conformance checking of business processes",
      "author" : [ "M. de Leoni", "W. van der Aalst", "B.F. van Dongen" ],
      "venue" : "LNBIP, vol. 117, pp. 48–59",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Action languages, answer sets and planning",
      "author" : [ "V. Lifschitz" ],
      "venue" : "The Logic Programming Paradigm: a 25-Year Perspective, pp. 357–373. Springer",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Planlets: Automatically recovering dynamic processes in yawl",
      "author" : [ "A. Marrella", "A. Russo", "M. Mecella" ],
      "venue" : "OTM Conferences (1). pp. 268–286",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Specifying and verifying declarative fluent temporal logic properties of workflows",
      "author" : [ "G. Regis", "N. Ricci", "N. Aguirre", "T.S.E. Maibaum" ],
      "venue" : "Proc. of SBMF. pp. 147–162",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Improving documentation by repairing event logs",
      "author" : [ "A. Rogge-Solti", "S. Ronny", "W. van der Aalst", "M. Weske" ],
      "venue" : "The Practice of Enterprise Modeling, LNBIP, vol. 165, pp. 129–144. Springer",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Soundness verification for conceptual workflow nets with data",
      "author" : [ "N. Sidorova", "C. Stahl", "N. Trčka" ],
      "venue" : "Inf. Sys. 36(7), 1026–1043",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "A framework for automatic generation of processes for selfadaptive software systems",
      "author" : [ "C.E. da Silva", "R. de Lemos" ],
      "venue" : "Informatica (Slov.) 35(1), 3–13",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Soundness of workflow nets",
      "author" : [ "W. van der Aalst", "Hee", "K.v.", "Hofstede", "A.t.", "N. Sidorova", "H. Verbeek", "M. Voorhoeve", "M. Wynn" ],
      "venue" : "Formal Aspects of Comp. 23(3), 333–363",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2010
    }, {
      "title" : "Automated Reasoning Support for Process Models using Action Language. mastersthesis, Computer Science Faculty",
      "author" : [ "I. Vázquez Sandoval" ],
      "venue" : "Free University of Bozen– Bolzano",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2014
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "Thus repairing incomplete execution traces by reconstructing the missing entries becomes an important task to enable process mining in full, as noted in recent works such as [17,8].",
      "startOffset" : 174,
      "endOffset" : 180
    }, {
      "referenceID" : 6,
      "context" : "Thus repairing incomplete execution traces by reconstructing the missing entries becomes an important task to enable process mining in full, as noted in recent works such as [17,8].",
      "startOffset" : 174,
      "endOffset" : 180
    }, {
      "referenceID" : 4,
      "context" : "This is a serious limitation, given the growing practical and theoretical efforts to extend business process languages with the capability to model complex data objects, along with the traditional control flow perspective [6].",
      "startOffset" : 222,
      "endOffset" : 225
    }, {
      "referenceID" : 18,
      "context" : "Specifically we will focus on the well established Workflow Nets [20], a particular class of Petri nets that provides the formal foundations of several process models, of the YAWL language and have become one of the standard ways to model and analyze workflows.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 16,
      "context" : "a modeling language DAW-net, an extension of the workflow nets with data formalism introduced in [18] so to be able to deal with even more expressive data (Section 3); 2.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 0,
      "context" : "Petri Nets (PN) is a modeling language for the description of distributed systems that has widely been applied to the description and analysis of business processes [1].",
      "startOffset" : 165,
      "endOffset" : 168
    }, {
      "referenceID" : 0,
      "context" : "This imposes syntactic restrictions on PNs, that result in the following definition of a workflow net (WF-net) [1].",
      "startOffset" : 111,
      "endOffset" : 114
    }, {
      "referenceID" : 9,
      "context" : "From now on we concentrate on 1-safe nets, which generalize the class of structured workflows and are the basis for best practices in process modeling [11].",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 8,
      "context" : "This reflects the fact that the process control-flow is well-defined (see [10]).",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 1,
      "context" : "Reachability on PNs (WF-nets) is of enormous importance in process verification as it allows for checking natural behavioral properties, such as satisfiability and soundness in a natural manner [2].",
      "startOffset" : 194,
      "endOffset" : 197
    }, {
      "referenceID" : 15,
      "context" : "The need for trace repair is motivated in depth in [17], where missing entities are described as a frequent cause of low data quality in event logs, especially when the definition of the business processes integrates activities that are not supported by IT systems due either to their nature (e.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 15,
      "context" : "By aligning the trace to the model using a replay-based approach or a planning based approach, the techniques presented in [17] and [8] are able to exploit the events stored in the trace and the control flow specified in the model to reconstruct two possible repairs:",
      "startOffset" : 123,
      "endOffset" : 127
    }, {
      "referenceID" : 6,
      "context" : "By aligning the trace to the model using a replay-based approach or a planning based approach, the techniques presented in [17] and [8] are able to exploit the events stored in the trace and the control flow specified in the model to reconstruct two possible repairs:",
      "startOffset" : 132,
      "endOffset" : 135
    }, {
      "referenceID" : 7,
      "context" : "A planning problem inK [9] is specified using a Datalog-like language where fluents and actions are represented by literals (not necessarily ground).",
      "startOffset" : 23,
      "endOffset" : 26
    }, {
      "referenceID" : 16,
      "context" : "Our framework follows the approach of state-of-the-art WF-nets with data [18,12], from which it borrows the above concepts, extending them by allowing reasoning on actual data values as better explained in Section 6.",
      "startOffset" : 73,
      "endOffset" : 80
    }, {
      "referenceID" : 10,
      "context" : "Our framework follows the approach of state-of-the-art WF-nets with data [18,12], from which it borrows the above concepts, extending them by allowing reasoning on actual data values as better explained in Section 6.",
      "startOffset" : 73,
      "endOffset" : 80
    }, {
      "referenceID" : 16,
      "context" : "A number of variants of PNs have been enriched so as to make tokens able to carry data and transitions aware of the data, as in the case of Workflow nets enriched with data [18,12], the model adopted by the business process community.",
      "startOffset" : 173,
      "endOffset" : 180
    }, {
      "referenceID" : 10,
      "context" : "A number of variants of PNs have been enriched so as to make tokens able to carry data and transitions aware of the data, as in the case of Workflow nets enriched with data [18,12], the model adopted by the business process community.",
      "startOffset" : 173,
      "endOffset" : 180
    }, {
      "referenceID" : 2,
      "context" : "Several works have addressed the problem of aligning event logs and procedural models, without [3] and with [13,12] data.",
      "startOffset" : 95,
      "endOffset" : 98
    }, {
      "referenceID" : 11,
      "context" : "Several works have addressed the problem of aligning event logs and procedural models, without [3] and with [13,12] data.",
      "startOffset" : 108,
      "endOffset" : 115
    }, {
      "referenceID" : 10,
      "context" : "Several works have addressed the problem of aligning event logs and procedural models, without [3] and with [13,12] data.",
      "startOffset" : 108,
      "endOffset" : 115
    }, {
      "referenceID" : 15,
      "context" : "For example, in [17], the authors exploit stochastic PNs and Bayesian Networks to recover missing information (activities and their durations).",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 3,
      "context" : "For example, in [5] the same issue of reconstructing missing information has been tackled by reformulating it in terms of a Satisfiability(SAT) problem rather than as a planning problem.",
      "startOffset" : 16,
      "endOffset" : 19
    }, {
      "referenceID" : 14,
      "context" : ", for verifying process constraints [16] or for the construction and adaptation of autonomous process models [19,15].",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 17,
      "context" : ", for verifying process constraints [16] or for the construction and adaptation of autonomous process models [19,15].",
      "startOffset" : 109,
      "endOffset" : 116
    }, {
      "referenceID" : 13,
      "context" : ", for verifying process constraints [16] or for the construction and adaptation of autonomous process models [19,15].",
      "startOffset" : 109,
      "endOffset" : 116
    }, {
      "referenceID" : 5,
      "context" : "In [7] automated planning techniques have been applied for aligning execution traces and declarative models.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 6,
      "context" : "As in this work, in [8], planning techniques have been used for addressing the problem of incomplete execution traces with respect to procedural models.",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 12,
      "context" : "Moreover, the presented encoding in the planning language K, can be directly adapted to other action languages with an expressiveness comparable to C [14].",
      "startOffset" : 150,
      "endOffset" : 154
    }, {
      "referenceID" : 10,
      "context" : "Definition 12 (Petri Net [12]).",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 16,
      "context" : "Definition 13 (WF-net [18]).",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 0,
      "context" : "In this document we focus on 1-safeness, which is equivalent to the original safeness property as defined in [1].",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 7,
      "context" : "The formal definition of K can be found in Appendix A of [9]; here, as reference, we include the main concepts.",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 7,
      "context" : "Definition 18 (Planning domain, [9] Def.",
      "startOffset" : 32,
      "endOffset" : 35
    } ],
    "year" : 2017,
    "abstractText" : "The growing adoption of IT-systems for modeling and executing (business) processes or services has thrust the scientific investigation towards techniques and tools which support more complex forms of process analysis. Many of them, such as conformance checking, process alignment, mining and enhancement, rely on complete observation of past (tracked and logged) executions. In many real cases, however, the lack of human or IT-support on all the steps of process execution, as well as information hiding and abstraction of model and data, result in incomplete log information of both data and activities. This paper tackles the issue of automatically repairing traces with missing information by notably considering not only activities but also data manipulated by them. Our technique recasts such a problem in a reachability problem and provides an encoding in an action language which allows to virtually use any state-of-the-art planning to return solutions.",
    "creator" : "LaTeX with hyperref package"
  }
}