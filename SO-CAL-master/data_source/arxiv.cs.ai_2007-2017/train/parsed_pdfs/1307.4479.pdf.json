{
  "name" : "1307.4479.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : null,
    "authors" : [ "Gabriele Puppis", "Tiziano Villa" ],
    "emails" : [ "dariodm@ru.is", "napoli@dia.unisa.it", "parente@unisa.it" ],
    "sections" : [ {
      "heading" : null,
      "text" : "Gabriele Puppis, Tiziano Villa (Eds.): Fourth International Symposium on Games, Automata, Logics and Formal Verification EPTCS 119, 2013, pp. 240–255, doi:10.4204/EPTCS.119.20\nc© D. Della Monica, M. Napoli, M. Parente This work is licensed under the Creative Commons Attribution License.\nModel checking coalitional games in shortage resource scenarios∗\nDella Monica, Dario ICE-TCS, School of Computer Science\nReykjavik University, Iceland\ndariodm@ru.is\nNapoli, Margherita Dipartimento di Informatica University of Salerno, Italy\nnapoli@dia.unisa.it\nParente, Mimmo Dipartimento di Informatica University of Salerno, Italy\nparente@unisa.it\nVerification of multi-agents systems (MAS) has been recently studied taking into account the need of expressing resource bounds. Several logics for specifying properties of MAS have been presented in quite a variety of scenarios with bounded resources. In this paper, we study a different formalism, called Priced Resource-Bounded Alternating-time Temporal Logic (PRB-ATL), whose main novelty consists in moving the notion of resources from a syntactic level (part of the formula) to a semantic one (part of the model). This allows us to track the evolution of the resource availability along the computations and provides us with a formalisms capable to model a number of real-world scenarios. Two relevant aspects are the notion of global availability of the resources on the market, that are shared by the agents, and the notion of price of resources, depending on their availability. In a previous work of ours, an initial step towards this new formalism was introduced, along with an EXPTIME algorithm for the model checking problem. In this paper we better analyze the features of the proposed formalism, also in comparison with previous approaches. The main technical contribution is the proof of the EXPTIME-hardness of the the model checking problem for PRB-ATL, based on a reduction from the acceptance problem for Linearly-Bounded Alternating Turing Machines. In particular, since the problem has multiple parameters, we show two fixed-parameter reductions."
    }, {
      "heading" : "1 Introduction",
      "text" : "Verification of multi-agents systems (MAS) is a topic under investigation by several research groups in computer science in the last ten years ([8]). Most of the research is based on logical formalisms, maybe the most famous being the Alternating-time Temporal Logics (ATL) [3] and the Coalition Logic (CL) [15, 16], both oriented towards the description of collective behaviors and used as specification languages for open systems. These scenarios are hence naturally modeled as games. In [10] it has been shown that CL can be embedded into ATL. Recently, these two logics have been used for the verification of multi-agent systems (MAS), enhanced with resource constraints [1, 2, 5, 6, 9]. The intuitive idea is that agent actions consume and/or produce resources, thus the choice of a given action of an agent is subject to the availability of the resources. In [1], Alechina et al. introduce the logic Resource-Bounded Coalition Logic (RBCL), whose language extends the one of CL with explicit representation of resource bounds. In [2], the same authors propose an analogous extension for ATL, called Resource-Bounded Alternating-time Temporal Logics (RB-ATL), and give a model checking procedure that runs in time O(|ϕ |2·r+1 × |G|), where |ϕ | is the length of the formula ϕ to be checked, |G| is the size of the model\n∗The work of Dario Della Monica has been partially supported by the project Processes and Modal Logics (project nr. 100048021) of the Icelandic Research Fund and the project Decidability and Expressiveness for Interval Temporal Logics (project nr. 130802-051) of the Icelandic Research Fund in partnership with the European Commission Framework 7 Programme (People) under “Marie Curie Actions”. The work of Margherita Napoli has been partially supported by the Italian PRIN 2010 project Logical Methods of Information Management. The work of Margherita Napoli and Mimmo Parente has been partially supported by the Italian FARB projects 2010-2012.\nG, and r is the number of resources. However, the problem of determining a lower bound to the model checking problem is left open. In [6], Bulling and Farwer introduce two Resource-Bounded Agent Logics, called RAL and RAL∗. The former represents a generalization of Alechina et al.’s RB-ATL, the latter is an analogous extension of ATL∗ (analogous extensions for, respectively, CTL and CTL∗ were presented by the same authors in [5]). The authors study several syntactic and semantic variants of RAL and RAL∗ with respect to the (un)decidability of the model checking problem. In particular, while previous approaches only conceive actions consuming resources, they introduce the notion of actions producing resources. It turned out that such a new notion makes the model checking problem undecidable. Formulae of the formalisms proposed in [1, 2, 5, 6] allow one to assign an endowment of resources to the agents by means of the so-called team operators (borrowed from ATL). The problem is then to determine whether the agents in the proponent team have a strategy for the game to carry out the assigned goals with that bounded amount of resources, whatever the agents in the opponent team do.\nIn this paper we study a different formalism, called Priced Resource-Bounded Alternating-time Temporal Logic (PRB-ATL), introduced in [9], but in a much less mature version. The key features of this new approach toward the formalization of such complex systems can be summarized as follows.\n• Boundedness of the resources. This is a crucial point in our formalization. In order to model boundedness of the resources, a notion of global availability of resources on the market (or in nature), which evolves depending on both proponent and opponent behaviors, is introduced. Such a global availability is a semantic component (it is part of the structure where the logic is interpreted) and its evolution is tracked during the executions of the system. Agents’ moves are affected by the current global availability (e.g., agents cannot consume an unbounded amount of resources).\n• Resources are shared. Resources are global, that is, they are shared by all the agents. Thus, the agents either consume or produce resources out of a shared pool of bounded capability, and acquisition (resp., release) of a resource by an agent (independently if the agent belongs to the proponent or opponent team) implies that the resource will be available in smaller (resp., greater) quantity. In this way, we can model several scenarios where shared resources are acquired at a cost that depends on that resource current availability (for example in concurrent systems where there is a competition on resources).\n• Money as a meta-resource. In addition to public shared resources, our setting also allows one to model private resources, that is, resources that are possessed by agents (public resources are present in the market and will be acquired by the agents in case they need). The idea is to provide the agents with the unique private resource, money, that can be used to acquire (public) resources needed to perform the tasks. In this sense, money represent several resource combinations and can be considered as a meta-resource. Unlike the other resources, it is a syntactic component (money endowment is part of the formula), and is the only (meta-)resource which is private for an agent. At this stage, our formalization only features the possibility of assigning to agents one private resource. Nevertheless, in principle, it is possible to extend the idea to admit a vector of private resources. Furthermore, one could think of including the same resource in both the pool of public resources and in the pool of private ones. For instance, in a car race one of the players (the cars) possesses some gasoline in the tank (private resource) but he needs to acquire more gasoline at the gas station (public resource) to complete the race.\n• Resource production. Production of resources is allowed in a quantity that is not greater than a fixed amount. Thus, we extend the model still preserving the decidability of the model checking problem. Observe that the constraint we impose still allows us to describe many interesting realworld scenarios, such as acquiring memory by a program, or leasing a car during a travel, or, in\ngeneral, any release of resources previously acquired. A similar setting has been already observed also in [6].\n• Opponent power. First observe that we use the standard terminology which separates the role of the agents in a proponent team and those in the opponent team. This distinction is not within the game structure, but it is due to the formula under consideration. Agents of the opponent team are subject to resource availability in choosing the action to perform, in the same way as the agent of the proponent team, thus the opponent team cannot interfere with a proponent strategy performing actions which either consume or produce too much (see Example 3 in Section 3). However, it is common practice to consider opponent having maximum power, to look for robust strategy. We give unlimited economic power to the agents in the opponent team, in the sense that at each moment they have money enough to acquire the resources they need for a move, provided that the resources are available.\nActually in [9] an EXPTIME algorithm for the model checking problem was given, along with a PSPACE lower bound. The main technical contribution here is to provide an EXPTIME lower bound for the model checking problem for PRB-ATL. This result shows that the model checking problem for this logic is EXPTIME-complete. The hardness proof is obtained by means of a reduction from the acceptance problem for Linearly-Bounded Alternating Turing Machines (LB-ATM), known to be EXPTIME-complete [7], to the model checking problem for PRB-ATL. More precisely, let n be the number of agents, r the number of resources, and M the maximum component occurring in the initial resource availability vector, the algorithm given in [9] runs in exponential time in n, r, and the size of the representation of M (assuming that M is represented in binary). To prove here the inherent difficulty with respect to multiple input parameters, we show two reductions: one parametric in the representation of M (the digit size), that assumes constant both n and r, and another parametric in r, and assuming constant both n and the value of M."
    }, {
      "heading" : "2 Comparison with related works",
      "text" : "In this section we compare our approach with the existing literature underlining differences and similarities respect to [2] and [6].\nIn the work by Alechina et al. [2], resource bounds only appear in the formulae and are applied solely to the proponent team, but they are not represented inside the model. Indeed, agents of the proponent team are endowed with new resources at the different steps of the system execution. This means that it is possible to ask whether a team can reach a goal with a given amount of resources, but it is not possible to keep trace of the evolution of the global availability of resources. Moreover, resources are private to agents of the proponent team (not shared, as in our approach) and resource consumption due to the actions of the opponent is not controlled. Here instead, we keep trace of resource global availability, whose evolution depends on both proponent and opponent moves. In this way, it is possible to avoid undesired/unrealistic computations of the system such as, for instance, computations consuming unboundedly. Let us see a very simple example. Consider the formula ψ = 〈〈A~$〉〉 p. Its semantics is that agents in team A have together a strategy which can guarantee that p always holds, whatever agents of the opponent team do (without consuming too many resources) and provided the expense of the agents in A does not exceed~$. A loop in the structure where the joint actions of agents consume resources without producing them, cannot be a model for ψ . On the contrary, consider the formula ψ ′ = 〈〈Ab〉〉 p, belonging to the formalism proposed in [2], expressing a similar property, with the only difference that the agents of A use an amount of resources bounded by b. A model for ψ ′ must contain a loop where\nthe actions of agents in A do not consume resources, but the actions of agents in the opponent team may possibly consume resources, leading to an unlimited consumption of resources.\nAs a further difference, recall that in [2] actions can only consume resources. Without resource productions, the model for many formulae (for example those containing the global operator ) must have a loop whose actions do not consume resources (do-nothing actions), and a run satisfying these formulae is eventually formed by only such actions. On the contrary, by allowing resource production, we can model more complex situations when dealing with infinite games.\nFinally, observe that a similarity with the cited paper is in the role of money, that could be seen as a private resource, endowed to the agents of the proponent team.\nBulling and Farwer [6] adopted an “horizontal” approach, in the sense that they explored a large number of variants of a formalism to model these complex systems. In particular, they explored the border between decidability and undecidability of the model checking problem for all such variants, and they showed how the status of a formalisms (wrt decidability of its model checking problem) is affected by (even small) changes in language, model, and semantics. Our work takes advantage of this analysis in order to propose a logic that captures several desirable properties (especially concerning the variety of natural real world scenario that is possible to express), still preserving decidability. However, our approach presents conceptual novelties that make it difficult to accomplish a direct comparisons between the formalisms presented here and the ones proposed in [6]. We are referring here to both the above mentioned idea of dealing with resources as global entities for which agents compete, and the notion of cost of resource acquisition (price of the resources) that dynamically changes depending on the global availability of that resource (thus allowing one to model the classic market law that says that getting a resource is more expensive in shortage scenario). In [6], there is no such a notion as resources are assigned to (team of) agents and proponent and opponent do not compete for their acquisition.\nAs regards the complexity issue, in [6], no complexity analysis (for the model checking problem) is performed, while, in [2], an upper bound is given for RB-ATL, that matches the one given in [9] for PRB-ATL. The algorithm for PRB-ATL runs in exponential time in the number n of agents, the number r of resources, and the digit size of the maximum component M occurring in the initial resource availability vector (assuming a binary reppresentation). Analogously, the model checking algorithm for RB-ATL runs in exponential time in r, in the digit size of the maximum component of resource endowment vectors b occuring in team operators 〈〈Ab〉〉 of ϕ and in the number n of the agents (this is implicit in set of states of |G|). Actually, both n and r are often treated as constant [2, 3] (without this assumption, the complexity of ATL model-checking is shown to be exponential in the number of agents [11]). However, no complexity lower bound has been exhibit so far. Aim of this paper is to fill this gap, by providing an EXPTIME lower bound for PRB-ATL.\n3 A logical formalization: PRB-ATL\nSyntax. We start with the introduction of some notations we will use in the rest of the paper. The set of agents is A G = {a1,a2, . . . ,an} and a team is any subset of A G . The integers n and r will be used throughout the paper to denote the number of agents and resource types (or simply resources), respectively. Let M = (N∪{∞})r denote the set of global availabilities of resources on the market (or in nature) and let N = (N∪{∞})n denote the set of money availabilities for the agents, where N is the set of natural numbers (zero included). Given a money availability~$ ∈ N , its i-th component~$[i] is the\nmoney availability of agent ai1. Finally, the set Π is a finite set of atomic propositions. The formulae of PRB-ATL are given by the following grammar:\nϕ ::= p | ¬ϕ | ϕ ∧ϕ | 〈〈A~$〉〉©ϕ | 〈〈A~$〉〉ϕU ϕ | 〈〈A~$〉〉 ϕ | ∼ ~m\nwhere p ∈ Π, A ⊆ A G , ∼∈ {<,≤,=,≥,>}, ~m ∈ M and~$ ∈ N . Formulae of the kind ∼ ~m test the current availability of resources on the market. As usual, other standard operators can be considered as abbreviation, e.g., the operator 〈〈A ~$〉〉♦ψ can be defined as 〈〈A~$〉〉⊤U ψ , for every formula ψ .\nPriced game structure. Priced game structures are defined by extending the definitions of concurrent game structure and resource-bounded concurrent game structure given in, respectively, [3] and [2].\nDefinition 1 A priced game structure G is a tuple 〈Q,π,d,D,qty,δ ,ρ , ~m0〉, where: • Q is the finite set of locations; q0 ∈ Q is called initial location. • π : Q → 2Π is the evaluation function, which determines the atomic propositions holding true in\neach location. • d : Q×A G → N is the action function giving the number d(q,a) ≥ 1 of actions available to an\nagent a ∈A G at a location q ∈ Q. The actions available to a at q are identified with the numbers2 1, . . . ,d(q,a) and a generic action is usually denoted by α . We assume that each agent has at least one available action at each location, that could be thought of as the action do-nothing and we assume that it is always the first.\n• D : Q → 2N n\nis a function that maps each location q to the set of vectors {1, . . . ,d(q,a1)}× . . .× {1, . . . ,d(q,an)}. Each vector, called action profile and denoted by ~α , identifies a choice among the actions available for each agent in the location q. (The action of the agent a in ~α is ~α(a).) • qty : Q×A G ×N→ Zr is a partial function, where qty(q,a,α), with 1 ≤ α ≤ d(q,a), defines at location q the amount of resources required by the a’s action α . We define qty(q,a,1) =~0, that is the vector whose components are all equal to 0, for every q ∈ Q, a ∈ A G (doing nothing neither consumes nor produces resources). • δ : Q×Nn → Q is the transition function. For q ∈ Q and ~α ∈ D(q), δ (q,~α) defines the next location reached from q if the agents perform the actions in the action profile ~α . • ρ : M ×Q×A G →Nr is the price function. It returns the price vector of the resources (a price for each resource), based on the current resource availability and location, and on the acting agent. • ~m0 ∈M is the initial global availability of resources. It represents the resource availability on the market at the initial state of the system.\nNote that a negative value in qty(q,a,~α) represents a resource consumption, while a positive one represents a resource production. We also consider the extension of the function qty, called again with the same name, to get the amount of resources required by a given team. Thus, for a location q, a team A and an action profile ~α , qty(q,A,~α) = ∑a∈A qty(q,a,~α (a)). Moreover, we will use the function consd : Q ×A G ×N → Nr that for the tuple (q,a,α) returns the vector of the resources which are consumed by an agent a, being in state q, for an action α . This vector is obtained from qty(q,a,α) by replacing the positive components, representing a resource production, with zeros, and the negative components, representing a resource consumption, with their absolute values.\nExample 1 A priced game structure with two agents a1 and a2 and one resource R1 is depicted in Figure 1. The only atomic proposition is p, labeling the locations q0, q1, q2. The action profiles, labeling\n1Throughout all the paper, symbols identifying vectors are denoted with an arrow on the top (e.g.,~$, ~m). 2No ambiguity will arise from the fact that actions of different agents are identified with the same numbers.\nthe transitions in the graph and depicted with square brackets, are as follows. D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1. In all the other locations the only action profile is [1,1] corresponding to the existence of a single action of both the agents. The function qty is represented by parentheses. The price vector is not depicted.\nSemantics. In the following, given a resource availability ~m, by M≤~m we denote the set {~m′ ∈M | ~m′ ≤ ~m}. In order to give the formal semantics let us first define the following notions.\nDefinition 2 A configuration c of a priced game graph G is a pair 〈q,~m〉 ∈ Q ×M≤ ~m0 . Given two configurations c = 〈q,~m〉 and c′ = 〈q′, ~m′〉, and an action profile ~α ∈ D(q), we say that c →~α c′ if q′ = δ (q,~α) and ~m′ = ~m+qty(q,A G ,~α). A computation over G is an infinite sequence C = c1c2 . . . of configurations of G, such that for each i there is an action profile ~αi such that ci →~αi ci+1.\nLet C = c1c2 . . . be a computation. We denote by C[i] the i-th configuration ci in C and by C[i, j], with 1 ≤ i ≤ j, the finite sequence of configurations cici+1 . . .c j in C. Given a configuration c = 〈q,~m〉 and a team A, a function ~αA : A → N is called A-feasible in c if there exists an action profile ~α ∈ D(q) with ~αA(a) =~α(a) for all a ∈ A and~0 ≤ qty(q,A,~α)+~m ≤ ~m0. In this case we say that ~α extends ~αA.\nDefinition 3 A strategy FA of a team A is a function which associates to each finite sequence of configurations c1c2 . . .cs, a function ~αA : A → N which is A-feasible in cs.\nIn other words, a strategy FA returns a choice of the actions of the agents in the team A, considering only those actions whose resource consumption does not exceed the available amount and whose resource production does not exceed the amount consumed so far. Clearly, this constraint will limit both proponent and opponent team.\nFor each strategy FA of a team A and for each sequence of configurations c1c2 . . .cs, there are several possibilities for the next configuration cs+1, depending on the different choices of the opponent team A = A G \\A. Anyway, fixed a strategy FA of the opponent team, there is at most one action profile obtained according to both the strategies, that is the action profile ~α extending both ~αA, given by the strategy FA, and ~αA, given by the strategy FA (i.e. ~α is such that ~α(a) = ~αX(a), for X ∈ {A,A} and a∈ X ). A computation C = c1,c2 . . ., is the outcome of the strategies FA and FA from the configuration c1 if, for each i ≥ 1, there is an action profile ~αi obtained according to both FA and FA, such that ci →~αi ci+1. Given a strategy FA and a configuration c, out(c,FA) denotes the set of the outcomes of FA and FA from c, for all the strategies FA of the team A. Observe that, given a finite sequence of configurations C = c1c2 . . .cs, if the action profile ~α according to the two strategies is not such that~0 ≤ qty(qs,A G ,~α)+ ~ms ≤ ~m0, then there is no next configuration. Thus outcome of the strategies FA and FA from a given configuration may be undefined (recall that we consider only infinite computations).\nExample 2 Consider the priced game structure in Figure 1, with teams A = {a1} and B = {a2}, one resource type and initial global availability ~m0 = 〈1〉. Let c = 〈q0,〈1〉〉 be a sequence of configurations (of length 1). Team A has two possible strategies in c, one for each possible action of agent a1, and team B has one strategy for the single available action of agent a2. Suppose that, according to the strategy FA, agent a1 chooses to perform the action 2 (FA(c)(a1) = 2), then the action profile [2,1] is performed and one unit of the unique resource is consumed. In the obtained configuration 〈q1,〈0〉〉 the agent a1 has one available action while the agent a2 has two actions. Anyway FB cannot return the action 2 for the agent a2, since this action would require an amount of the resource greater than 0, which is the current availability. Thus only the configuration 〈q2,〈0〉〉 can be reached and the computation C = 〈q0,〈1〉〉〈q1,〈0〉〉〈q2,〈0〉〉〈q2,〈0〉〉 . . . is the only one that belongs to out(c,FA).\nNow we introduce the concept of consistent strategy. Two properties have to be satisfied: first, the outcomes starting from c are always defined and also the agents of the proponent team have enough money to realize the chosen actions.\nDefinition 4 Let~$ ∈ N , c be a configuration, A ⊆ A G be the proponent team, and A = A G \\A be the opponent team. A strategy FA of A is said to be consistent with respect to~$ and c ((~$,c)-strategy), if\n1. for any strategy FA of A, the outcome of FA and FA from the configuration c is defined, 2. for every C = c1c2 . . .∈ out(c,FA), with ci = 〈qi, ~mi〉, for every i≥ 1 and ak ∈A: ∑ij=1 ρ(~m j,q j,ak) ·\nconsd(q j,ak,FA(C[1, j])(ak))≤~$[k].\nIn the above condition the dot operator denotes the usual scalar product of vectors. Observe that only the money availability of the team A is tested. Actually, we suppose that the opponent team A always has money enough to make its choice. Notice also that the actions producing resources do not cause a reimbursement of money to the agents. As it is usual when dealing with temporal logics, we guarantee that priced game structures are non-blocking, in the sense that at least a (~$,c)-strategy exists for a given team A. Indeed, agents of A can always jointly choose the do-nothing action.\nA formula of PRB-ATL is evaluated with respect to a priced game structure G and a configuration c = 〈q,~m〉. The definition of the semantics is completed by the definition of the satisfaction relation |=:\n• (G,c) |= p iff p ∈ π(q) • (G,c) |= ¬ψ iff (G,c) 6|= ψ • (G,c) |= ψ1 ∧ψ2 iff (G,c) |= ψ1 and (G,c) |= ψ2 • (G,c) |= 〈〈A\n~$〉〉©ψ iff there exists a (~$,c)-strategy FA such that, for all C ∈ out(c,FA), it holds that (G,C[2]) |= ψ • (G,c) |= 〈〈A ~$〉〉ψ1U ψ2 iff there exists a (~$,c)-strategy FA such that, for all C ∈ out(c,FA), there\nexists i ≥ 0 such that (G,C[i]) |= ψ2 and, for all 1 ≤ j < i, it holds that (G,C[ j]) |= ψ1 • (G,c) |= 〈〈A\n~$〉〉 ψ iff there exists a (~$,c)-strategy FA such that, for all C ∈ out(c,FA), it holds that (G,C[i]) |= ψ for all i ≥ 1\n• (G,c) |=∼ ~m′ iff ~m∼ ~m′ where ∼∈ {<,≤,=,≥,>}.\nGiven a PRB-ATL formula and a priced game srtucture G, we say that G satisfies ϕ , G |= ϕ , if (G,c0) |= ϕ where c0 = 〈q0, ~m0〉. The model checking problem for PRB-ATL consists in verifying whether G |= ϕ .\nExample 3 Consider the priced game structure in Figure 1, with teams A = {a1} and B = {a2}. A formula ψ = 〈〈A G~$〉〉©〈〈A~$′〉〉 p holds true in the configuration 〈q0,〈1〉〉, provided that~$ and ~$′ are enough to make the move. Indeed, a1 and a2 together are able to force the computation to reach the\n〈q1,〈0〉〉 (one unit of resource is consumed). From such a configuration, the opponent team B cannot force the computation into q3, as the action 2 is not allowed for a2 (no resources are available to perform the action), and thus ψ holds. Instead, ψ is false in the configuration 〈q0,〈2〉〉 (actually in each configuration 〈q0,〈x〉〉, with x > 1), because 〈q1,〈1〉〉 is reached after the execution of the first transition, and in that configuration action 2 for a2 in B is allowed, leading to q3. Finally, notice that the formula is false also when evaluated in 〈q0,〈0〉〉, as the only possible transition is the one leading from q0 to q4 (no resources are available to perform action 1 for agent a1)."
    }, {
      "heading" : "4 Complexity lower bounds for the model checking problem",
      "text" : "In [9], the authors presented an algorithm for model checking PRB-ATL, providing an exponential upper bound for the problem. In particular, let n be the number of agents, r the number of resources, and M the maximum component occurring in the initial resource availability vector, the proposed algorithm runs in exponential time in n, r, and the size of the representation of M (assuming that M is represented in binary). In this section we prove that an algorithm that behaves asymptotically better cannot exist, thus proving that the problem is EXPTIME-complete. To prove the inherent difficulty with respect to the multiple input parameters, we show two reductions: one parametric in the representation of M (the digit size), which assumes both n and r constant, and the other parametric in r, this time assuming constant both n and the value of M. We conjecture the existence of a third EXPTIME reduction, in which r and M are constant and the parameter is n. In fact, if it was not the case, it would be possible to improve the proposed model checking algorithm in a way that its complexity would not be exponential in n.\nWe first recall the formalism of linearly-bounded alternating Turing machines (LB-ATM) and the notion of hierarchical representation, a succinct way of representing priced game structures inspired to the work done in [4] for classical Kripke structures. Finally, we present the two reductions from the acceptance problem for LB-ATM, known to be EXPTIME-complete [7], to the model checking problem for PRB-ATL."
    }, {
      "heading" : "4.1 Linearly-bounded alternating Turing Machines",
      "text" : "A linearly-bounded alternating Turing machines (LB-ATM) is a tuple 〈Q,Γ,I ,q0,〉, where Q is the set of states, partitioned in Q∀ (universal states) and Q∃ (existential states); Γ is the set of tape symbols, including the ‘blank’ symbol B, and two special symbols x and y, denoting the left and right tape delimiters; I ⊆ Q×Γ×Q×Γ×{←,→} is the instruction set; q0 ∈ Q is the initial state.\nSymbols from Γ are stored in the tape cells, and the first and the last cell of the tape store, respectively, the symbols x and y. A tape configuration s is a sequence of the symbols stored in the tape cells, and keeps trace of an head cell. A configuration c is a pair (q,s) of a state q and a tape configuration s, and C is the set of the configurations. The initial configuration is c = (q0,s0), where s0 contains the input, possibly followed by a sequence of blanks, and its head cell stores the first input symbol.\nAn instruction i = (q,λ , r,ν ,∼) ∈ I is also denoted 〈q,λ 〉 → 〈r,ν ,∼〉, where 〈q,λ 〉 is called a full state. Its intuitive meaning is as follows: “whenever the machine is in the state q and the symbol in the head cell is λ , then the machine switches to state r, the symbol in the head cell is replaced with ν , and the head position is moved to the left or to the right (according to ∼)”. An execution step of the machine is denoted c i −→ c′, where c,c′ ∈ C , i ∈ I and c′ is the configuration reached from c after the execution of the instruction i. Let Cnext(c) = {c ′ ∈ C | c i −→ c′ is an execution step, for some i ∈ I }. All the tape configurations are linear in the length of the input and we follow the common practice to only consider\nmachines whose tape length does not vary during the computation. We can also assume that LB-ATM have no infinite computations since any LB-ATM can be transformed into another, accepting the same language and haltingin a finite number of steps. Such a LB-ATM counts the number of execution steps and rejects any computation whose number of steps exceeds the number of possible configurations.\nThe acceptance condition is defined recursively. A configuration c = (q,s) is said to be accepting if either one of the following conditions is verified: (i) q ∈ Q∀ and c′ is accepting for all c′ ∈ Cnext(c) or (ii) q ∈ Q∃ and there exists c′ ∈ Cnext(c) such that c\n′ is accepting. Notice that an universal (existential) state always accepts (rejects) if Cnext(c) = /0. A LB-ATM accepts on an initial input tape s0, if the initial configuration (q0,s0) is accepting. Hierarchical representation. In order to exhibit our encoding proposal, we make use of a hierarchical representation analogous to the one described in [4, 12, 13] for model checking, and in [14] for module checking procedures. Given a finite state machine, the idea of hierarchical representation is to replace two or more substructures of the machine that are structurally equivalent, by another (structurally equivalent) module, that is a finite state machine itself. The use of hierarchical representation results in an exponentially more succinct representation of the system, that amounts (in most cases) to more efficient model checking procedures (in the other cases, this does not yield a more efficient behavior, as the analysis requires a flattening of the machine itself, thus incurring in an exponential blow up in its size).\nIn our context, this idea can be suitably adapted to deal with the presence of resources, as follows. Modules do not represent structurally equivalent substructures, but substructures that have the same impact on the values of resource variables. In principle, whenever the analysis is focused on the evolution of resource variables, it makes sense to consider as equivalent two substructures that can possibly differ in their structure but whose effect on the set of resource variables is exactly the same. This approach could be thought of as a hierarchical representation based on functional equivalence between substructures, as opposed to the classical notion of hierarchical representation based on structural equivalence.\n4.2 A reduction from the acceptance problem for LB-ATM\nGiven an LB-ATM A and an input tape configuration s0, we provide a priced game structure GA ,s0 , with two agents ag1 and ag2, and a formula φA ,s0 such that GA ,s0 |= φA ,s0 if and only if A accepts on s0.\nIn the following, we exhibit the game structure by using a graphical (hierarchical) representation (Figures 2-7 in Appendix). Notice that only significant information is explicitly shown in the pictures. In particular, labels on transitions (arcs) represent consumptions/productions of resources due to the execution of the joint move (proponent and opponent moves) associated to that transition. For example, the label “−1i,+1i,+10µL,−10µL” on the loop transition of Figure 4b means that the actions associated to the transition will consume 1 unit of the (type) resource i and 10 unit of µL, and will produce 1 unit of the resource i and 10 unit of µL. Availability of other resources is unchanged, then the relative information is omitted.\nThe reduction uses the three resource variables µL, µ , and µR to encode the tape configuration, plus three auxiliary resource variables i, r, and t, that will be useful during the construction. Moreover, we associate to the above set of variables the set of counterbalanced variables {µL,µ ,µR, i,r, t}. The idea behind the use of counterbalanced variables, that is also the key idea of the reduction, consists of designing the game structure in a way that to every consumption (resp., production) of a resource, say for instance µ , a corresponding production (resp., consumption) of its counterbalanced µ exists. In particular, this is true inside each module of the hierarchical structure, thus the sum of the availability of a resource variable and its counterbalanced variable is kept constant along all the computation at every module’s entry and exit points, equal to a value Max, which depends on the input of the LB-ATM. This\nwill allow us to force the execution of specific transitions at specific availabilities of resource variables. Consider, for example, the node of Figure 4b with 2 outgoing transitions, one of which is a loop transition. The presence of 2 outgoing transitions means that either the proponent or the opponent can choose between 2 moves. But such a freedom is only potential, as in any moment of the computation the choice of the next move by the proponent/opponent is constrained by the resource availability: if the loop transition is enabled, then the availability of the resource i is greater than 0, and thus the availability of its counterbalanced variable i is less than Max, that means that the other transition, which consumes Max units of the resource i, is disabled. On the contrary, if the non-loop transition is enabled, there are Max units of the resource i available, and thus the availability of the resource i is 0, that means that the loop transition is disabled. Thus, by taking advantage of the features of counterbalanced variables, we are able to force the executions to have a somehow deterministic behavior.\nEncoding of the tape. Without loss of generality, we consider LB-ATM on input alphabet Σ = {1,2,B}, thus Γ is the set {1,2,B,x,y}. Recall that the symbols B, x, and y denote the ‘blank’ symbol, the left delimiter, and the right delimiter, respectively. Tape symbols are encoded by the digits 0,1,2,3 and 4, in a pretty natural way: 0 encodes the ‘blank’ symbol, 1 and 2 encode the input symbols 1 and 2, and 3 and 4 encode the left and right delimiters. The tape configuration is encoded by means of the three resource variables µL, µ , and µR. The value of µ ranges over the set {0,1,2,3,4} and encodes the value stored in the cell currently read by the head (according to the above encoding of tape symbols into digits). The value of µL encodes the tape configuration at the left of the current head position in a forward fashion. The value of µR encodes the tape configuration at the right of the current head position in a reverse fashion, that is, µR encodes the reverse of the string corresponding to the tape configuration at the right of current head position. As an example, consider the tape configuration s= xB11211B2BBy, the symbol read by the head is the underlined one. Such a configuration is encoded by means of the three resource variables as follows: µL = 30112, µL = 1, and µR = 400201. It can be noticed that the length of the representation of the three variables µL, µ , and µR is proportional to the length of the tape configuration which is at most linear in the size of the input, namely O(|s0|). Using such an encoding, the machine operation “shift the head to the left” can be represented by means of the following operations on resource variables:\n• the new value of µR is µR ∗10+µ • the new value of µ is µL mod 10, • the new value of µL is µL/10 ( / is the integer division),\nThe operation “shift the head to the right” can be encoded analogously. Notice that in order to encode in polynomial time the operations of shifting the head to left and right, we encode the string to the right of the current head position in a reverse order. Indeed, in this way the symbol stored on the cell immediately to the right of the head corresponds to the least significant digit of µR, and thus can be accessed by using the module operation (µR mod 10).\nEncoding of the instructions. The encoding of the instructions is depicted in Figure 2. Transitions starting from a node labeled 〈q,λ 〉 represent all the possible instructions matching the full state 〈q,λ 〉 of the LB-ATM, that is, all the instructions that can be possibly performed at the full state 〈q,λ 〉.\nMore in detail, given a full state 〈q,λ 〉 of the machine, with q ∈ Q∃, the encoding of the set {〈q,λ 〉 → 〈r1,ν1,∼1〉,〈q,λ 〉 → 〈r2,ν2,∼2〉, . . . ,〈q,λ 〉 → 〈rm,νm,∼m〉} of matching instructions is shown in Figure 2a, (recall that ∼i∈ {←,→}). Analogously, the encoding of the set of instructions matching the full state 〈q,λ 〉, with q ∈ Q∀, is shown in Figure 2b. Let us underline that the action profiles 〈α1,β 〉, . . . ,〈αm,β 〉 labeling transitions corresponding to an existential state are such that the first agent ag1 has the capability to force a specific transition (instruction) to be executed, depending on the\nchoice of the αi for the next action, independently from the choice β of the other agent ag2. On the other hand, the action profiles 〈α ,β1〉, . . . ,〈α ,βm〉 labeling transitions corresponding to an universal state are such that the roles of the agents are exchanged.\nThe LB-ATM representation of Figure 2 is hierarchical and involves the modules write and move. The former encodes the rewriting of the head cell performed by A and, to this aim, makes use of one of the following modules (Figure 3), depending on the symbol λ read by the head, and on the symbol ν to be written:\n• inc, depicted in Figure 3a, is used when the rewriting corresponds to an increment, for example, when the symbol 2 has to be written in place of the symbol 1; • double inc, depicted in Figure 3b, is used when the rewriting corresponds to a double increment, for example, when the symbol 2 (encoded as 2) has to be written in place of the symbol B (encoded as 0); • dec, depicted in Figure 3c, is used when the rewriting corresponds to a decrement, for example, when the symbol 1 has to be written in place of the symbol 2; • double dec, depicted in Figure 3d, is used when the rewriting corresponds to a double decrement, for example, when the symbol B has to be written in place of the symbol 2. Obviously, the module does nothing when the symbol to be written corresponds to the symbol currently stored in the head cell.\nThe module move encodes the shift (to right or to left) of the head. It is designed in a way that the only next location that can be reached by the game is consistent with the value stored on the new head cell (after the shift operation). In Figure 4 and 5 the sub-modules encoding the operation “shift to right” are depicted. The encoding of the operation “shift to left” can be realized analogously.\nAs an example, we describe the first two modules of Figure 4. The module shi f t right, depicted in\nFigure 4a, is performed through the following steps: • multiply by 10 the value of µL (module times 10(µL)), • increment the value of µL by the value of µ (module add(µL,µ)), • divide by 10 the value of µR (module div 10(µR) — the remainder of the division is stored in the\nresource variable r), • assign to the resource variable µ the value of r (module assign(µ ,r)), • suitably lead the computation to the location corresponding to the next state of the LB-ATM,\ndepending on the value read by the head, that is, the value stored on the resource variable µ (module choose next state(µ)).\nThe module times 10(µL), that multiplies by 10 the value of µL (Figure 4b), is performed by storing the value of µL in the resource variable i, by setting the value of µL to 0, and then by executing a transition (the loop transition), which consumes 1 unit of i and produces 10 units of µL (the suitable quantity of the counterbalanced variables is produced or consumed as well, to keep the sum constant) as long as items of the resource i are available. When the availability of i goes down to 0, the other transition is executed (the last transition is needed to keep constant the sum between i and its counterbalanced variable i). It is easy to convince oneself that the value of µL in the exit node is equal to its value in the entry node times 10, and that the sum of each variable and its counterbalanced one is constant. As a last remark, we point out that the names of some of the modules are parametric, in the sense that the arguments between parenthesis are not actual resource variables, but parameters (e.g., x, x1, x2) to be instantiated. We adopted this notation for modules that are used more than once, and that are instantiated with actual resource variables when they are used (e.g., the module assign depicted in Figure 4c is called assign(x1 ,x2) and it is used, for instance, inside the module times 10(µL) (Figure 4b), where x1 (resp., x2) is instantiated with i (resp., µL), and inside the module add(µL,µ) (Figure 5a), where x1 (resp., x2) is instantiated with t (resp., µ).\nNow, as resource productions are involved in the reduction, we need to guarantee that the availability of each resource never exceeds the initial one. To this end the values of the components of the vector ~m0 of initial resource availability are set to the value Max = 322 . . .224, that is the largest number corresponding to an encoding of any tape configuration (precisely, it encodes the tape configuration x22 . . .22y). Before starting the simulation of the LB-ATM, a preliminary step, depicted in Figure 6, modifies the value of the resource variables in such a way that they correctly encode the input tape s0 and the sum of the availability of each resource variable and its counterbalanced is equal to Max. Thus, the value of the resource variables never exceed Max.\nAt this point, given a LB-ATM A and an input tape configuration s0, the game structure GA ,s0 presents, among others, the following features (the other features of GA ,s0 are either irrelevant or represented in the graphical representation of the encoding — see Figures 2-6):\ninstructions; • initial global availability ~m0 is such that all resources are available in quantity Max, as already\nmentioned above; notice that Max also represents the maximum value occurring in the initial resource availability vector, that is, M = Max; • initial location 〈q0,λ 〉, where q0 is the initial state of the LB-ATM and λ is the first input symbol. The formula φA ,s0 = 〈〈A\n~$〉〉♦p, with A = {ag1} and the value of~$ being irrelevant for our purposes, is such that GA ,s0 |= φA ,s0 if and only if A accepts on input s0.\nNotice that, for the sake of readability, the game structure used in the reduction does not respect the requirement that, in every location, the first action of every agent is the do-nothing action, which does not consume or produce resources. Nevertheless, this omission does not affect the correctness of our reduction, that can be easily adapted using a game structure fulfilling the above requirement.\nTheorem 1 Model checking PRB-ATL is EXPTIME-hard even assuming n and r constant.\nLet us stress that the above reduction makes use of a constant number of agents and resources, while the digit size of M (the maximum value occurring in ~m0) is linear in the size of the tape configuration. This is consistent with the complexity of the algorithm in [9], which remains exponential even if we consider a constant number of agents and resources as input.\nCorollary 1 The model checking problem for PRB-ATL is EXPTIME-complete."
    }, {
      "heading" : "4.3 Another reduction.",
      "text" : "As noted at the beginning of Section 4, it is possible to exhibit two more reductions according to which two parameters, out of three, are assumed constant. In the following, we briefly outline how to obtain a reduction from the acceptance problem for LB-ATM, when n and M are constant.\nThis reduction is simpler than the previous. Here the encoding of the tape is obtained using a number of resources which is linear in the length of the tape. Let |s| be the length of the tape, we use 2 sets of\n|s| resource variables, namely, µ1L ,µ2L , . . . ,µ |s| L and µ1R,µ2R, . . . ,µ |s| R , plus the resource variable µ . Each variable encodes the content of a tape cell: variable µ encodes the content of the head cell, while, for each i, the variable µ iL (resp., µ iR) encodes the content of the i-th cell on the left (resp., right) of the tape cell. Notice that, since there are finitely many possible values for a tape cell, the value of M is upper bounded. Now, the encoding of the set of instructions matching a full state 〈q,λ 〉 of a LB-ATM is the same used for the previous reduction and depicted in Figure 2. Nevertheless, the encoding of the module move, which encodes the shift (to right or to left) of the head, is slightly different. In Figure 7, the sub-modules encoding the operation “shift to right” are depicted. Essentially, the value of the variable representing a cell is transmitted to the variable representing the cell on the right, and the next location reached on the game structure is set according to the value stored on the current head cell (after the shift operation). The encoding of the operation “shift to left” is made analogously.\nTheorem 2 Model checking PRB-ATL is EXPTIME-hard even assuming n and M constant."
    }, {
      "heading" : "5 Discussion",
      "text" : "In this paper we have presented a formalism which is very suitable to model properties of multi-agent systems when the agents share resources and the need of avoiding an unbounded consumption of such resources is crucial. Within our framework it is possible to keep trace of a real global availability of the\nresources, used by both the proponent and opponent players, avoiding thus unrealistic situations in which an unbounded quantity of resources is used in a game.\nThe technical focus of the paper has been on the complexity of the model checking problem, and we proved that it is EXPTIME complete (recall that also for simpler formalism this problem is in EXPTIME, though the lower bound is not known). Other problems of interest exist in the context of multi-agents system verification. The most important one is the reachability problem, that is the problem of determining whether a team, with a given amount of money and a given initial global resource availability, has a strategy to force the execution of the system to reach a given location. More precisely, the reachability problem for a team A on a priced game structure G is a particular instance of the model checking problem, namely, the problem of verifying the truth at the initial configuration of G of a PRB-ATL formula of the kind 〈〈A ~$〉〉♦p, for a team A, a money endowment~$ and p ∈ Π. An upper bound on the complexity of this problem is clearly given by the algorithm for solving the model checking problem for PRB-ATL. Let us observe that the reductions given in section 4 apply also to the reachability problem, since the formula used there was φA ,s0 = 〈〈A ~$〉〉♦p, thus we have the following corollary.\nCorollary 2 The reachability problem for PRB-ATL is EXPTIME-complete.\nOne of the novelties of our logic is that the resource production is allowed in the actions, though with some limitations. Model checking and reachability problems seem both to be simpler in the case one restricts our formalism by considering agent actions that cannot produce resources. The reachability problem is indeed NP-hard in this case: it immediately follows from a result in [11], when the number of agents is not constant. Anyway, we can prove the NP-hardness for just two agents using a reduction from 3-SAT (due to lack of space we omit here the proof). The model checking problem, instead, turns out to be PSPACE-hard, since the reduction from QBF problem given in [9] works also in this case, when actions cannot produce resources. Observe that PRB-ATL with this restriction is again different from other formalisms in literature, mainly for the possibility of tracking resources avalability and for considering shared resources.\nFinally, we want to note that also the more general problem, called optimal coalition problem, is EXPTIME-complete (the upper bound was shown in [9]). It is the problem of finding optimal (with respect to a suitable cost function) coalitions that are capable to satisfy a given parametric PRB-ATL formula, that is, a PRB-ATL formula in which parametric team operators 〈〈X ~$〉〉 may occur in place of the classical team operators 〈〈A ~$〉〉. One could also investigate other optimization problems. The most interesting is, perhaps, to consider the money availability not as an input of the problem, but rather as a parameter to minimize, that is to establish how much money each agent should be provided with, to perform a given task.\nFurther research directions concern the study of variants of the logic. First, one can consider extensions based on the full alternating-time temporal language ATL∗, as already done in [6], and its fragment ATL+."
    } ],
    "references" : [ {
      "title" : "A Logic for Coalitions with Bounded Resources",
      "author" : [ "Natasha Alechina", "Brian Logan", "Nguyen Hoang Nga", "Abdur Rakib" ],
      "venue" : "Proc. of the 21st International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2009
    }, {
      "title" : "Resource-bounded alternatingtime temporal logic",
      "author" : [ "Natasha Alechina", "Brian Logan", "Nguyen Hoang Nga", "Abdur Rakib" ],
      "venue" : "Proc. of the 9th International Conference on Autonomous Agents and Multiagent Systems: Volume 1,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2010
    }, {
      "title" : "Alternating-time temporal logic",
      "author" : [ "Rajeev Alur", "Thomas A. Henzinger", "Orna Kupferman" ],
      "venue" : "Journal of ACM 49(5),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2002
    }, {
      "title" : "Model checking of hierarchical state machines",
      "author" : [ "Rajeev Alur", "Mihalis Yannakakis" ],
      "venue" : "ACM Transactions on Programming Languages and Systems (TOPLAS)",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2001
    }, {
      "title" : "Expressing Properties of Resource-Bounded Systems: The Logics RTL and RTL",
      "author" : [ "Nils Bulling", "Berndt Farwer" ],
      "venue" : "editors: Computational Logic in Multi-Agent Systems (CLIMA X),",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2009
    }, {
      "title" : "On the (Un-)Decidability of Model Checking Resource-Bounded Agents",
      "author" : [ "Nils Bulling", "Berndt Farwer" ],
      "venue" : "Proc. of the 19th European Conference on Artificial Intelligence,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2010
    }, {
      "title" : "Specification and Verification of Multi-agent Systems, 1st edition",
      "author" : [ "Mehdi Dastani", "Koen V. Hindriks", "John-Jules Charles Meyer" ],
      "venue" : null,
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2010
    }, {
      "title" : "On a Logic for Coalitional Games with Priced-Resource Agents",
      "author" : [ "D. Della Monica", "M. Napoli", "M. Parente" ],
      "venue" : "Electronic Notes in Theoretical Computer Science (ENTCS)",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2011
    }, {
      "title" : "Coalition games and alternating temporal logics",
      "author" : [ "Valentin Goranko" ],
      "venue" : "Proc. of the 8th Conference on Theoretical Aspects of Rationality and Knowledge,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2001
    }, {
      "title" : "Do Agents Make Model Checking Explode (Computationally)",
      "author" : [ "Wojciech Jamroga", "Jürgen Dix" ],
      "venue" : "Proc. of the 4th International Central and Eastern European Conference on Multi-Agent Systems (CEEMAS",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2005
    }, {
      "title" : "Hierarchical and Recursive State Machines with Context-Dependent Properties",
      "author" : [ "Salvatore La Torre", "Margherita Napoli", "Mimmo Parente", "Gennaro Parlato" ],
      "venue" : "editors: Proc. of the 30th International Colloquium on Automata, Languages and Programming (ICALP), Lecture Notes in Computer Science",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2003
    }, {
      "title" : "Verification of scopedependent hierarchical state machines",
      "author" : [ "Salvatore La Torre", "Margherita Napoli", "Mimmo Parente", "Gennaro Parlato" ],
      "venue" : "Information and Computation",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2008
    }, {
      "title" : "Program Complexity in Hierarchical Module Checking",
      "author" : [ "Aniello Murano", "Margherita Napoli", "Mimmo Parente" ],
      "venue" : "editors: Proc. of the 15th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR), Lecture Notes in Computer Science",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2008
    }, {
      "title" : "A Logical Framework for Coalitional Effectivity in Dynamic Procedures",
      "author" : [ "Marc Pauly" ],
      "venue" : "Bulletin of Economic Research",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2001
    }, {
      "title" : "A Modal Logic for Coalitional Power in Games",
      "author" : [ "Marc Pauly" ],
      "venue" : "Journal of Logic and Computation",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2002
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "Verification of multi-agents systems (MAS) is a topic under investigation by several research groups in computer science in the last ten years ([8]).",
      "startOffset" : 144,
      "endOffset" : 147
    }, {
      "referenceID" : 2,
      "context" : "Most of the research is based on logical formalisms, maybe the most famous being the Alternating-time Temporal Logics (ATL) [3] and the Coalition Logic (CL) [15, 16], both oriented towards the description of collective behaviors and used as specification languages for open systems.",
      "startOffset" : 124,
      "endOffset" : 127
    }, {
      "referenceID" : 13,
      "context" : "Most of the research is based on logical formalisms, maybe the most famous being the Alternating-time Temporal Logics (ATL) [3] and the Coalition Logic (CL) [15, 16], both oriented towards the description of collective behaviors and used as specification languages for open systems.",
      "startOffset" : 157,
      "endOffset" : 165
    }, {
      "referenceID" : 14,
      "context" : "Most of the research is based on logical formalisms, maybe the most famous being the Alternating-time Temporal Logics (ATL) [3] and the Coalition Logic (CL) [15, 16], both oriented towards the description of collective behaviors and used as specification languages for open systems.",
      "startOffset" : 157,
      "endOffset" : 165
    }, {
      "referenceID" : 8,
      "context" : "In [10] it has been shown that CL can be embedded into ATL.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 0,
      "context" : "Recently, these two logics have been used for the verification of multi-agent systems (MAS), enhanced with resource constraints [1, 2, 5, 6, 9].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 1,
      "context" : "Recently, these two logics have been used for the verification of multi-agent systems (MAS), enhanced with resource constraints [1, 2, 5, 6, 9].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 4,
      "context" : "Recently, these two logics have been used for the verification of multi-agent systems (MAS), enhanced with resource constraints [1, 2, 5, 6, 9].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 5,
      "context" : "Recently, these two logics have been used for the verification of multi-agent systems (MAS), enhanced with resource constraints [1, 2, 5, 6, 9].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 7,
      "context" : "Recently, these two logics have been used for the verification of multi-agent systems (MAS), enhanced with resource constraints [1, 2, 5, 6, 9].",
      "startOffset" : 128,
      "endOffset" : 143
    }, {
      "referenceID" : 0,
      "context" : "In [1], Alechina et al.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 1,
      "context" : "In [2], the same authors propose an analogous extension for ATL, called Resource-Bounded Alternating-time Temporal Logics (RB-ATL), and give a model checking procedure that runs in time O(|φ |2·r+1 × |G|), where |φ | is the length of the formula φ to be checked, |G| is the size of the model",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 5,
      "context" : "In [6], Bulling and Farwer introduce two Resource-Bounded Agent Logics, called RAL and RAL.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 4,
      "context" : "’s RB-ATL, the latter is an analogous extension of ATL (analogous extensions for, respectively, CTL and CTL were presented by the same authors in [5]).",
      "startOffset" : 146,
      "endOffset" : 149
    }, {
      "referenceID" : 0,
      "context" : "Formulae of the formalisms proposed in [1, 2, 5, 6] allow one to assign an endowment of resources to the agents by means of the so-called team operators (borrowed from ATL).",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 1,
      "context" : "Formulae of the formalisms proposed in [1, 2, 5, 6] allow one to assign an endowment of resources to the agents by means of the so-called team operators (borrowed from ATL).",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 4,
      "context" : "Formulae of the formalisms proposed in [1, 2, 5, 6] allow one to assign an endowment of resources to the agents by means of the so-called team operators (borrowed from ATL).",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 5,
      "context" : "Formulae of the formalisms proposed in [1, 2, 5, 6] allow one to assign an endowment of resources to the agents by means of the so-called team operators (borrowed from ATL).",
      "startOffset" : 39,
      "endOffset" : 51
    }, {
      "referenceID" : 7,
      "context" : "In this paper we study a different formalism, called Priced Resource-Bounded Alternating-time Temporal Logic (PRB-ATL), introduced in [9], but in a much less mature version.",
      "startOffset" : 134,
      "endOffset" : 137
    }, {
      "referenceID" : 5,
      "context" : "A similar setting has been already observed also in [6].",
      "startOffset" : 52,
      "endOffset" : 55
    }, {
      "referenceID" : 7,
      "context" : "Actually in [9] an EXPTIME algorithm for the model checking problem was given, along with a PSPACE lower bound.",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 7,
      "context" : "More precisely, let n be the number of agents, r the number of resources, and M the maximum component occurring in the initial resource availability vector, the algorithm given in [9] runs in exponential time in n, r, and the size of the representation of M (assuming that M is represented in binary).",
      "startOffset" : 180,
      "endOffset" : 183
    }, {
      "referenceID" : 1,
      "context" : "In this section we compare our approach with the existing literature underlining differences and similarities respect to [2] and [6].",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 5,
      "context" : "In this section we compare our approach with the existing literature underlining differences and similarities respect to [2] and [6].",
      "startOffset" : 129,
      "endOffset" : 132
    }, {
      "referenceID" : 1,
      "context" : "[2], resource bounds only appear in the formulae and are applied solely to the proponent team, but they are not represented inside the model.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 1,
      "context" : "On the contrary, consider the formula ψ ′ = 〈〈Ab〉〉 p, belonging to the formalism proposed in [2], expressing a similar property, with the only difference that the agents of A use an amount of resources bounded by b.",
      "startOffset" : 93,
      "endOffset" : 96
    }, {
      "referenceID" : 1,
      "context" : "As a further difference, recall that in [2] actions can only consume resources.",
      "startOffset" : 40,
      "endOffset" : 43
    }, {
      "referenceID" : 5,
      "context" : "Bulling and Farwer [6] adopted an “horizontal” approach, in the sense that they explored a large number of variants of a formalism to model these complex systems.",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 5,
      "context" : "However, our approach presents conceptual novelties that make it difficult to accomplish a direct comparisons between the formalisms presented here and the ones proposed in [6].",
      "startOffset" : 173,
      "endOffset" : 176
    }, {
      "referenceID" : 5,
      "context" : "In [6], there is no such a notion as resources are assigned to (team of) agents and proponent and opponent do not compete for their acquisition.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 5,
      "context" : "As regards the complexity issue, in [6], no complexity analysis (for the model checking problem) is performed, while, in [2], an upper bound is given for RB-ATL, that matches the one given in [9] for PRB-ATL.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 1,
      "context" : "As regards the complexity issue, in [6], no complexity analysis (for the model checking problem) is performed, while, in [2], an upper bound is given for RB-ATL, that matches the one given in [9] for PRB-ATL.",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 7,
      "context" : "As regards the complexity issue, in [6], no complexity analysis (for the model checking problem) is performed, while, in [2], an upper bound is given for RB-ATL, that matches the one given in [9] for PRB-ATL.",
      "startOffset" : 192,
      "endOffset" : 195
    }, {
      "referenceID" : 1,
      "context" : "Actually, both n and r are often treated as constant [2, 3] (without this assumption, the complexity of ATL model-checking is shown to be exponential in the number of agents [11]).",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 2,
      "context" : "Actually, both n and r are often treated as constant [2, 3] (without this assumption, the complexity of ATL model-checking is shown to be exponential in the number of agents [11]).",
      "startOffset" : 53,
      "endOffset" : 59
    }, {
      "referenceID" : 9,
      "context" : "Actually, both n and r are often treated as constant [2, 3] (without this assumption, the complexity of ATL model-checking is shown to be exponential in the number of agents [11]).",
      "startOffset" : 174,
      "endOffset" : 178
    }, {
      "referenceID" : 2,
      "context" : "Priced game structures are defined by extending the definitions of concurrent game structure and resource-bounded concurrent game structure given in, respectively, [3] and [2].",
      "startOffset" : 164,
      "endOffset" : 167
    }, {
      "referenceID" : 1,
      "context" : "Priced game structures are defined by extending the definitions of concurrent game structure and resource-bounded concurrent game structure given in, respectively, [3] and [2].",
      "startOffset" : 172,
      "endOffset" : 175
    }, {
      "referenceID" : 1,
      "context" : "q4 ¬p [2,1 ] (−1 ,0)",
      "startOffset" : 6,
      "endOffset" : 12
    }, {
      "referenceID" : 0,
      "context" : "q4 ¬p [2,1 ] (−1 ,0)",
      "startOffset" : 6,
      "endOffset" : 12
    }, {
      "referenceID" : 0,
      "context" : "¬p [1,1] (0,0) [1,1 (0,0 )",
      "startOffset" : 3,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : "¬p [1,1] (0,0) [1,1 (0,0 )",
      "startOffset" : 3,
      "endOffset" : 8
    }, {
      "referenceID" : 0,
      "context" : "1,2] ,−1) [1,1] (0,0)",
      "startOffset" : 10,
      "endOffset" : 15
    }, {
      "referenceID" : 0,
      "context" : "1,2] ,−1) [1,1] (0,0)",
      "startOffset" : 10,
      "endOffset" : 15
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 0,
      "endOffset" : 6
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 255,
      "endOffset" : 260
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 255,
      "endOffset" : 260
    }, {
      "referenceID" : 1,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 262,
      "endOffset" : 267
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 262,
      "endOffset" : 267
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 279,
      "endOffset" : 284
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 279,
      "endOffset" : 284
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 286,
      "endOffset" : 291
    }, {
      "referenceID" : 1,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 286,
      "endOffset" : 291
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 318,
      "endOffset" : 323
    }, {
      "referenceID" : 0,
      "context" : "[1,1 ] ( 0,0 ) A G = {a1,a2}, R = {R1}, Q = {q0,q1,q2,q3,q4}, ~ m0 = 〈1〉 π(q0) = π(q1) = π(q2) = {p}, π(q3) = π(q4) = {} d(q0,a1) = 2, d(q0,a2) = 1, d(q1,a1) = 1, d(q1,a2) = 2 d(q2,a1) = d(q2,a2) = d(q3,a1) = d(q3,a2) = 1 d(q4,a1) = d(q4,a2) = 1 D(q0) = {[1,1], [2,1]}, D(q1) = {[1,1], [1,2]} D(q2) = D(q3) = D(q4) = {[1,1]} qty(q0,a1,1) = 〈0〉, qty(q0,a1,2) = 〈−1〉, qty(q0,a2,1) = 〈0〉 qty(q1,a1,1) = 〈0〉, qty(q1,a2,1) = 〈0〉, qty(q1,a2,2) = 〈−1〉 qty(q,a,1) = 〈0〉, ∀q ∈ {q2,q3,q4},a ∈ A G",
      "startOffset" : 318,
      "endOffset" : 323
    }, {
      "referenceID" : 0,
      "context" : "D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1.",
      "startOffset" : 9,
      "endOffset" : 14
    }, {
      "referenceID" : 0,
      "context" : "D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1.",
      "startOffset" : 9,
      "endOffset" : 14
    }, {
      "referenceID" : 1,
      "context" : "D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1.",
      "startOffset" : 16,
      "endOffset" : 21
    }, {
      "referenceID" : 0,
      "context" : "D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1.",
      "startOffset" : 16,
      "endOffset" : 21
    }, {
      "referenceID" : 0,
      "context" : "D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1.",
      "startOffset" : 114,
      "endOffset" : 119
    }, {
      "referenceID" : 0,
      "context" : "D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1.",
      "startOffset" : 114,
      "endOffset" : 119
    }, {
      "referenceID" : 0,
      "context" : "D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1.",
      "startOffset" : 121,
      "endOffset" : 126
    }, {
      "referenceID" : 1,
      "context" : "D(q0) = {[1,1], [2,1]} is due to the existence of two actions of a1 and one action of a2 at location q0, D(q1) = {[1,1], [1,2]} corresponds to a single action of a1 and two actions of a2 at location q1.",
      "startOffset" : 121,
      "endOffset" : 126
    }, {
      "referenceID" : 0,
      "context" : "In all the other locations the only action profile is [1,1] corresponding to the existence of a single action of both the agents.",
      "startOffset" : 54,
      "endOffset" : 59
    }, {
      "referenceID" : 0,
      "context" : "In all the other locations the only action profile is [1,1] corresponding to the existence of a single action of both the agents.",
      "startOffset" : 54,
      "endOffset" : 59
    }, {
      "referenceID" : 1,
      "context" : "Suppose that, according to the strategy FA, agent a1 chooses to perform the action 2 (FA(c)(a1) = 2), then the action profile [2,1] is performed and one unit of the unique resource is consumed.",
      "startOffset" : 126,
      "endOffset" : 131
    }, {
      "referenceID" : 0,
      "context" : "Suppose that, according to the strategy FA, agent a1 chooses to perform the action 2 (FA(c)(a1) = 2), then the action profile [2,1] is performed and one unit of the unique resource is consumed.",
      "startOffset" : 126,
      "endOffset" : 131
    }, {
      "referenceID" : 1,
      "context" : "The definition of the semantics is completed by the definition of the satisfaction relation |=: • (G,c) |= p iff p ∈ π(q) • (G,c) |= ¬ψ iff (G,c) 6|= ψ • (G,c) |= ψ1 ∧ψ2 iff (G,c) |= ψ1 and (G,c) |= ψ2 • (G,c) |= 〈〈A $〉〉©ψ iff there exists a (~$,c)-strategy FA such that, for all C ∈ out(c,FA), it holds that (G,C[2]) |= ψ",
      "startOffset" : 313,
      "endOffset" : 316
    }, {
      "referenceID" : 7,
      "context" : "In [9], the authors presented an algorithm for model checking PRB-ATL, providing an exponential upper bound for the problem.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 3,
      "context" : "We first recall the formalism of linearly-bounded alternating Turing machines (LB-ATM) and the notion of hierarchical representation, a succinct way of representing priced game structures inspired to the work done in [4] for classical Kripke structures.",
      "startOffset" : 217,
      "endOffset" : 220
    }, {
      "referenceID" : 3,
      "context" : "In order to exhibit our encoding proposal, we make use of a hierarchical representation analogous to the one described in [4, 12, 13] for model checking, and in [14] for module checking procedures.",
      "startOffset" : 122,
      "endOffset" : 133
    }, {
      "referenceID" : 10,
      "context" : "In order to exhibit our encoding proposal, we make use of a hierarchical representation analogous to the one described in [4, 12, 13] for model checking, and in [14] for module checking procedures.",
      "startOffset" : 122,
      "endOffset" : 133
    }, {
      "referenceID" : 11,
      "context" : "In order to exhibit our encoding proposal, we make use of a hierarchical representation analogous to the one described in [4, 12, 13] for model checking, and in [14] for module checking procedures.",
      "startOffset" : 122,
      "endOffset" : 133
    }, {
      "referenceID" : 12,
      "context" : "In order to exhibit our encoding proposal, we make use of a hierarchical representation analogous to the one described in [4, 12, 13] for model checking, and in [14] for module checking procedures.",
      "startOffset" : 161,
      "endOffset" : 165
    }, {
      "referenceID" : 7,
      "context" : "This is consistent with the complexity of the algorithm in [9], which remains exponential even if we consider a constant number of agents and resources as input.",
      "startOffset" : 59,
      "endOffset" : 62
    }, {
      "referenceID" : 9,
      "context" : "The reachability problem is indeed NP-hard in this case: it immediately follows from a result in [11], when the number of agents is not constant.",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 7,
      "context" : "The model checking problem, instead, turns out to be PSPACE-hard, since the reduction from QBF problem given in [9] works also in this case, when actions cannot produce resources.",
      "startOffset" : 112,
      "endOffset" : 115
    }, {
      "referenceID" : 7,
      "context" : "Finally, we want to note that also the more general problem, called optimal coalition problem, is EXPTIME-complete (the upper bound was shown in [9]).",
      "startOffset" : 145,
      "endOffset" : 148
    }, {
      "referenceID" : 5,
      "context" : "First, one can consider extensions based on the full alternating-time temporal language ATL, as already done in [6], and its fragment ATL.",
      "startOffset" : 112,
      "endOffset" : 115
    } ],
    "year" : 2013,
    "abstractText" : "Verification of multi-agents systems (MAS) has been recently studied taking into account the need of expressing resource bounds. Several logics for specifying properties of MAS have been presented in quite a variety of scenarios with bounded resources. In this paper, we study a different formalism, called Priced Resource-Bounded Alternating-time Temporal Logic (PRB-ATL), whose main novelty consists in moving the notion of resources from a syntactic level (part of the formula) to a semantic one (part of the model). This allows us to track the evolution of the resource availability along the computations and provides us with a formalisms capable to model a number of real-world scenarios. Two relevant aspects are the notion of global availability of the resources on the market, that are shared by the agents, and the notion of price of resources, depending on their availability. In a previous work of ours, an initial step towards this new formalism was introduced, along with an EXPTIME algorithm for the model checking problem. In this paper we better analyze the features of the proposed formalism, also in comparison with previous approaches. The main technical contribution is the proof of the EXPTIME-hardness of the the model checking problem for PRB-ATL, based on a reduction from the acceptance problem for Linearly-Bounded Alternating Turing Machines. In particular, since the problem has multiple parameters, we show two fixed-parameter reductions.",
    "creator" : "LaTeX with hyperref package"
  }
}