{
  "name" : "1505.04123.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Margins, Kernels and Non-linear Smoothed Perceptrons",
    "authors" : [ "Aaditya Ramdas" ],
    "emails" : [ "aramdas@cs.cmu.edu", "jfp@andrew.cmu.edu" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 5.\n04 12\n3v 1\n[ cs\n.L G\n] 1\n5 M\nWe cast our problem as one of maximizing the regularized normalized hard-margin (ρ) in an RKHS and rephrase it in terms of a Mahalanobis dot-product/semi-norm associated with the kernel’s (normalized and signed) Gram matrix. We derive an accelerated smoothed algorithm with a convergence rate of √ log n\nρ given\nn separable points, which is strikingly similar to the classical kernelized Perceptron algorithm whose rate is 1\nρ2 . When no such classifier exists, we prove a version of Gordan’s separation theorem for RKHSs, and give a reinterpretation of negative margins. This allows us to give guarantees for a primal-dual algorithm that halts in min{ √ n |ρ| , √ n ǫ } iterations with a perfect separator in the RKHS if the primal is feasible or a dual ǫ-certificate of near-infeasibility."
    }, {
      "heading" : "1 Introduction",
      "text" : "We are interested in the problem of finding a non-linear separator for a given set of n points x1, ..., xn ∈ Rd with labels y1, ..., yn ∈ {±1}. Finding a linear separator can be stated as the problem of finding a unit vector w ∈ Rd (if one exists) such that for all i\nyi(w ⊤xi) ≥ 0 i.e. sign(w⊤xi) = yi. (1)\nThis is called the primal problem. In the more interesting non-linear setting, we will be searching for functions f in a Reproducing Kernel Hilbert Space (RKHS) FK associated with kernel K (to be defined later) such that for all i yif(xi) ≥ 0. (2) We say that problems (1), (2) have an unnormalized margin ρ > 0, if there exists a unit vector w, such that for all i,\nyi(w ⊤xi) ≥ ρ or yif(xi) ≥ ρ.\nTrue to the paper’s title, margins of non-linear separators in an RKHS will be a central concept, and we will derive interesting smoothed accelerated variants of the Perceptron algorithm that have convergence rates (for the aforementioned primal and a dual problem introduced later) that are inversely proportional to the RKHS-margin as opposed to inverse squared margin for the Perceptron.\nThe linear setting is well known by the name of linear feasibility problems - we are asking if there exists any vector w which makes an acute angle with all the vectors yixi, i.e.\n(XY )⊤w > 0n, (3)\nwhere Y := diag(y), X := [x1, ..., xn]. This can be seen as finding a vector w inside the dual cone of cone{yixi}.\nWhen normalized, as we will see in the next section, the margin is a well-studied notion of conditioning for these problems. It can be thought of as the width of the feasibility cone as in Freund & Vera (1999), a radius of well-posedness as in Cheung & Cucker (2001), and its inverse can be seen as a special case of a condition number defined by Renegar (1995) for these systems."
    }, {
      "heading" : "1.1 Related Work",
      "text" : "In this paper we focus on the famous Perceptron algorithm from Rosenblatt (1958) and the less-famous VonNeumann algorithm from Dantzig (1992) that we introduce in later sections. As mentioned by Epelman & Freund (2000), in a technical report by the same name, Nesterov pointed out in a note to the authors that the latter is a special case of the now-popular Frank-Wolfe algorithm.\nOur work builds on Soheili & Peña (2012, 2013b) from the field of optimization - we generalize the setting to learning functions in RKHSs, extend the algorithms, simplify proofs, and simultaneously bring new perspectives to it. There is extensive literature around the Perceptron algorithm in the learning community; we restrict ourselves to discussing only a few directly related papers, in order to point out the several differences from existing work.\nWe provide a general unified proof in the Appendix which borrows ideas from accelerated smoothing methods developed by Nesterov (2005) - while this algorithm and others by Nemirovski (2004), Saha et al. (2011) can achieve similar rates for the same problem, those algorithms do not possess the simplicity of the Perceptron or Von-Neumann algorithms and our variants, and also don’t look at the infeasible setting or primal-dual algorithms.\nAccelerated smoothing techniques have also been seen in the learning literature like in Tseng (2008) and many others. However, most of these deal with convex-concave problems where both sets involved are the probability simplex (as in game theory, boosting, etc), while we deal with hard margins where one of the sets is a unit ℓ2 ball. Hence, their algorithms/results are not extendable to ours trivially. This work is also connected to the idea of ǫ-coresets by Clarkson (2010), though we will not explore that angle.\nA related algorithm is called the Winnow by Littlestone (1991) - this works on the ℓ1 margin and is a saddle point problem over two simplices. One can ask whether such accelerated smoothed versions exist for the Winnow. The answer is in the affirmative - however such algorithms look completely different from the Winnow, while in our setting the new algorithms retain the simplicity of the Perceptron."
    }, {
      "heading" : "1.2 Paper Outline",
      "text" : "Sec.2 will introduce the Perceptron and Normalized Perceptron algorithm and their convergence guarantees for linear separability, with specific emphasis on the unnormalized and normalized margins. Sec.3 will then introduce RKHSs and the Normalized Kernel Perceptron algorithm, which we interpret as a subgradient algorithm for a regularized normalized hard-margin loss function.\nSec.4 describes the Smoothed Normalized Kernel Perceptron algorithm that works with a smooth approximation to the original loss function, and outlines the argument for its faster convergence rate. Sec.5 discusses the non-separable case and the Von-Neumann algorithm, and we prove a version of Gordan’s theorem in RKHSs.\nWe finally give an algorithm in Sec.6 which terminates with a separator if one exists, and with a dual certificate of near-infeasibility otherwise, in time inversely proportional to the margin. Sec.7 has a discussion and some open problems."
    }, {
      "heading" : "2 Linear Feasibility Problems",
      "text" : ""
    }, {
      "heading" : "2.1 Perceptron",
      "text" : "The classical perceptron algorithm can be stated in many ways, one is in the following form\nAlgorithm 1 Perceptron Initialize w0 = 0 for k = 0, 1, 2, 3, ... do\nif sign(w⊤k xi) 6= yi for some i then wk+1 := wk + yixi else Halt: Return wk as solution\nend if end for\nIt comes with the following classic guarantee as proved by Block (1962) and Novikoff (1962): If there exists a unit vector u ∈ Rd such that Y X⊤u ≥ ρ > 0, then a perfect separator will be found in maxi ‖xi‖ 2 2\nρ2\niterations/mistakes. The algorithm works when updated with any arbitrary point (xi, yi) that is misclassified; it has the same guarantees when w is updated with the point that is misclassified by the largest amount, argmini yiw⊤xi. Alternately, one can define the probability distribution over examples\np(w) = arg min p∈∆n\n〈Y X⊤w, p〉, (4)\nwhere ∆n is the n-dimensional probability simplex. Intuitively, p picks the examples that have the lowest margin when classified byw. One can also normalize the updates so that we can maintain a probability distribution over examples used for updates from the start, as seen below:\nAlgorithm 2 Normalized Perceptron Initialize w0 = 0, p0 = 0 for k = 0, 1, 2, 3, ... do\nif Y X⊤wk > 0 then Exit, with wk as solution else θk := 1 k+1\nwk+1 := (1− θk)wk + θkXY p(wk) end if\nend for\nRemark. Normalized Perceptron has the same guarantees as perceptron - the Perceptron can perform its update online on any misclassified point, while the Normalized Perceptron performs updates on the most misclassified point(s), and yet there does not seem to be any change in performance. However, we will soon see that the ability to see all the examples at once gives us much more power."
    }, {
      "heading" : "2.2 Normalized Margins",
      "text" : "If we normalize the data points by the ℓ2 norm, the resulting mistake bound of the perceptron algorithm is slightly different. Let X2 represent the matrix with columns xi/‖xi‖2. Define the unnormalized and\nnormalized margins as\nρ := sup ‖w‖2=1 inf p∈∆n\n〈Y X⊤w, p〉,\nρ2 := sup ‖w‖2=1 inf p∈∆n\n〈Y X⊤2 w, p〉.\nRemark. Note that we have sup‖w‖2=1 in the definition, this is equivalent to sup‖w‖2≤1 iff ρ2 > 0. Normalized Perceptron has the following guarantee on X2: If ρ2 > 0, then it finds a perfect separator in\n1 ρ22 iterations.\nRemark. Consider the max-margin separator u∗ for X (which is also a valid perfect separator for X2). Then\nρ maxi ‖xi‖2 = mini\n( yix ⊤ i u ∗\nmaxi ‖xi‖2\n)\n≤ min i\n( yix ⊤ i u ∗\n‖xi‖2\n)\n≤ sup ‖u‖2=1 min i\n( yix ⊤ i u\n‖xi‖2\n)\n= ρ2.\nHence, it is always better to normalize the data as pointed out in Graepel et al. (2001). This idea extends to RKHSs, motivating the normalized Gram matrix considered later.\nExample Consider a simple example in R2+. Assume that + points are located along the line 6x2 = 8x1, and the − points along 8x2 = 6x1, for 1/r ≤ ‖x‖2 ≤ r, where r > 1. The max-margin linear separator will be x1 = x2. If all the data were normalized to have unit Euclidean norm, then all the + points would all be at (0.6, 0.8) and all the − points at (0.8, 0.6), giving us a normalized margin of ρ2 ≈ 0.14. Unnormalized, the margin is ρ ≈ 0.14/r and maxi ‖xi‖2 = r. Hence, in terms of bounds, we get a discrepancy of r4, which can be arbitrarily large.\nWinnow The question arises as to which norm we should normalize by. There is a now classic algorithm in machine learning, called Winnow by Littlestone (1991) or Multiplicate Weights. It works on a slight transformation of the problem where we only need to search for u ∈ Rd+. It comes with some very wellknown guarantees - If there exists a u ∈ Rd+ such that Y X⊤u ≥ ρ > 0, then feasibility is guaranteed in ‖u‖21maxi ‖ai‖2∞ logn/ρ2 iterations. The appropriate notion of normalized margin here is\nρ1 := max w∈∆d min p∈∆n\n〈Y X⊤∞w, p〉,\nwhere X∞ is a matrix with columns xi/‖xi‖∞. Then, the appropriate iteration bound is logn/ρ21. We will return to this ℓ1-margin in the discussion section. In the next section, we will normalize by using the kernel appropriately."
    }, {
      "heading" : "3 Kernels and RKHSs",
      "text" : "The theory of Reproducing Kernel Hilbert Spaces (RKHSs) has a rich history, and for a detailed introduction, refer to Schölkopf & Smola (2002). Let K : Rd × Rd → R be a symmetric positive definite kernel, giving rise to a Reproducing Kernel Hilbert Space FK with an associated feature mapping at each point x ∈ Rd called φx : Rd → FK where φx(.) = K(x, .) i.e. φx(y) = K(x, y). FK has an associated inner product 〈φu, φv〉K = K(u, v). For any f ∈ FK , we have f(x) = 〈f, φx〉K .\nDefine the normalized feature map\nφ̃x = φx √\nK(x, x) ∈ FK and φ̃X := [φ̃xi ]n1 .\nFor any function f ∈ FK , we use the following notation\nY f̃(X) := 〈f, Y φ̃X〉K = [yi〈f, φ̃xi〉K ]n1 = [\nyif(xi)√ K(xi,xi)\n]n\n1 .\nWe analogously define the normalized margin here to be\nρK := sup ‖f‖K=1 inf p∈∆n\n〈 Y f̃(X), p 〉 . (5)\nConsider the following regularized empirical loss function\nL(f) =\n{\nsup p∈∆n\n〈 −Y f̃(X), p 〉\n}\n+ 12‖f‖ 2 K. (6)\nDenoting t := ‖f‖K > 0 and writing f = t (\nf ‖f‖K\n)\n= tf̄ , let us calculate the minimum value of this\nfunction\ninf f∈FK L(f) = inf t>0 inf ‖f̄‖K=1 sup p∈∆n\n〈−〈tf̄ , Y φ̃X〉K , p〉+ t 2\n2\n= inf t>0\n{ −tρK + 12 t 2 }\n= − 12ρ 2 K when t = ρK > 0. (7)\nSince maxp∈∆n 〈 −Y f̃(X), p 〉\nis some empirical loss function on the data and 12‖f‖2K is an increasing function of ‖f‖K , the Representer Theorem (Schölkopf et al. 2001) implies that the minimizer of the above function lies in the span of φxis (also the span of the yiφ̃xis). Explicitly,\narg min f∈FK L(f) =\nn ∑\ni=1\nαiyiφ̃xi = 〈Y φ̃X , α〉. (8)\nSubstituting this back into Eq.(6), we can define\nL(α) :=\n{\nsup p∈∆n\n〈−α, p〉 G\n}\n+ 12‖α‖ 2 G, (9)\nwhere G is a normalized signed Gram matrix with Gii = 1,\nGji = Gij := yiyjK(xi,xj)√ K(xi,xi)K(xj ,xj) = 〈yiφ̃xi , yj φ̃xj 〉K ,\nand 〈p, α〉 G := p⊤Gα, ‖α‖G :=\n√ α⊤Gα. One can verify that G is a PSD matrix and the G-norm ‖.‖G is a\nsemi-norm, whose properties are of great importance to us."
    }, {
      "heading" : "3.1 Some Interesting and Useful Lemmas",
      "text" : "The first lemma justifies our algorithms’ exit condition.\nLemma 1. L(α) < 0 implies Gα > 0 and there exists a perfect classifier iff Gα > 0. Proof. L(α) < 0 ⇒ supp∈∆n 〈−Gα, p〉 < 0 ⇔ Gα > 0. Gα > 0 ⇒ fα := 〈α, Y φ̃X〉 is perfect since\nyjfα(xj) √\nK(xj , xj) =\nn ∑\ni=1\nαi yiyjK(xi, xj) √\nK(xi, xi)K(xj , xj)\n= Gjα > 0.\nIf a perfect classifier exists, then ρK > 0 by definition and\nL(f∗) = L(α∗) = − 12ρ 2 K < 0 ⇒ Gα > 0,\nwhere f∗, α∗ are the optimizers of L(f), L(α).\nThe second lemma bounds the G-norm of vectors.\nLemma 2. For any α ∈ Rn, ‖α‖G ≤ ‖α‖1 ≤ √ n‖α‖2. Proof. Using the triangle inequality of norms, we get\n√ α⊤Gα = √ 〈 〈α, Y φ̃X〉, 〈α, Y φ̃X〉 〉\nK\n= ‖ ∑\ni\nαiyiφ̃xi‖K ≤ ∑\ni\n‖αiyiφ̃xi‖K\n≤ ∑\ni\n|αi| ∥ ∥ ∥ ∥\n∥\nyi φxi √\nK(xi, xi)\n∥ ∥ ∥ ∥ ∥\nK\n= ∑\ni\n|αi|,\nwhere we used 〈φxi , φxi〉K = K(xi, xi).\nThe third lemma gives a new perspective on the margin.\nLemma 3. When ρK > 0, f maximizes the margin iff ρKf optimizes L(f). Hence, the margin is equivalently\nρK = sup ‖α‖G=1 inf p∈∆n\n〈α, p〉 G ≤ ‖p‖G for all p ∈ ∆n.\nProof. Let fρ be any function with ‖fρ‖K = 1 that achieves the max-margin ρK > 0. Then, it is easy to plug ρKfρ into Eq. (6) and verify that L(ρKfρ) = − 12ρ2K and hence ρKfρ minimizes L(f).\nSimilarly, let fL be any function that minimizes L(f), i.e. achieves the value L(fL) = − 12ρ2K . Defining t := ‖fL‖K , and examining Eq. (7), we see that L(fL) cannot achieve the value − 12ρ2K unless t = ρK and supp∈∆n 〈 −Y f̃L(X), p 〉\n= −ρ2K which means that fL/ρK must achieve the max-margin. Hence considering only f = ∑\ni αiyiφ̃xi is acceptable for both. Plugging this into Eq. (5) gives the equality and\nρK = inf p∈∆n sup ‖α‖G=1\n〈α, p〉 G ≤ sup ‖α‖G=1 〈α, p〉 G\n≤ ‖p‖G by applying Cauchy-Schwartz\n(can also be seen by going back to function space)."
    }, {
      "heading" : "4 Smoothed Normalized Kernel Perceptron",
      "text" : "Define the distribution over the worst-classified points\np(f) := arg min p∈∆n\n〈 Y f̃(X), p 〉\nor p(α) := arg min p∈∆n 〈α, p〉 G . (10)\nImplicitly fk+1 = (1− θk)fk + θk〈Y φ̃X , p(fk)〉 = fk − θk ( fk − 〈Y φ̃X , p(fk)〉 )\n= fk − θk∂L(fk)\nand hence the Normalized Kernel Perceptron (NKP) is a subgradient algorithm to minimize L(f) from Eq. (6).\nRemark. Lemma 3 yields deep insights. Since NKP can get arbitrarily close to the minimizer of strongly convex L(f), it also gets arbitrarily close to a margin maximizer. It is known that it finds a perfect classifier\nAlgorithm 3 Normalized Kernel Perceptron (NKP) Set α0 := 0 for k = 0, 1, 2, 3, ... do\nif Gαk > 0n then Exit, with αk as solution else θk := 1 k+1\nαk+1 := (1− θk)αk + θkp(αk) end if\nend for\nin 1/ρ2K iterations - we now additionally infer that it will continue to improve to find an approximate maxmargin classifier. While both classical and normalized Perceptrons find perfect classifiers in the same time, the latter is guaranteed to improve.\nRemark. αk+1 is always a probability distribution. Curiously, a guarantee that the solution will lie in ∆n is not made by the Representer Theorem in Eq. (8) - any α ∈ Rn could satisfy Lemma 1. However, since NKP is a subgradient method for minimizing Eq. (6), we know that we will approach the optimum while only choosing α ∈ ∆n.\nDefine the smooth minimizer analogous to Eq. (10) as\npµ(α) := arg min p∈∆n\n{\n〈α, p〉 G + µd(p)\n}\n(11)\n= e−Gα/µ\n‖e−Gα/µ‖1 ,\nwhere d(p) := ∑\ni\npi log pi + log n (12)\nis 1-strongly convex with respect to the ℓ1-norm (Nesterov 2005). Define a smoothened loss function as in\nAlgorithm 4 Smoothed Normalized Kernel Perceptron Set α0 = 1n/n, µ0 := 2, p0 := pµ0(α0) for k = 0, 1, 2, 3, ... do\nif Gαk > 0n then Halt: αk is solution to Eq. (8) else θk := 2 k+3\nαk+1 := (1− θk)(αk + θkpk) + θ2kpµk(αk) µk+1 = (1− θk)µk pk+1 := (1− θk)pk + θkpµk+1(αk+1)\nend if end for\nEq. (9)\nLµ(α) = sup p∈∆n\n{\n− 〈α, p〉 G − µd(p)\n}\n+ 12‖α‖ 2 G.\nNote that the maximizer above is precisely pµ(α).\nLemma 4 (Lower Bound). At any step k, we have\nLµk(αk) ≥ L(αk)− µk logn.\nProof. First note that supp∈∆n d(p) = logn. Also,\nsup p∈∆n\n{\n− 〈α, p〉 G − µd(p)\n}\n≥ sup p∈∆n\n{\n− 〈α, p〉 G\n}\n− sup p∈∆n\n{ µd(p) } .\nCombining these two facts gives us the result.\nLemma 5 (Upper Bound). In any round k, SNKP satisfies\nLµk(αk) ≤ − 12‖pk‖ 2 G.\nProof. We provide a concise, self-contained and unified proof by induction in the Appendix for Lemma 5 and Lemma 8, borrowing ideas from Nesterov’s excessive gap technique (Nesterov 2005) for smooth minimization of structured non-smooth functions.\nFinally, we combine the above lemmas to get the following theorem about the performance of SNKP.\nTheorem 1. The SNKP algorithm finds a perfect classifier f ∈ FK when one exists in O (√\nlogn ρK\n)\niterations.\nProof. Lemma 4 gives us for any round k,\nLµk(αk) ≥ L(αk)− µk logn.\nFrom Lemmas 3, 5 we get Lµk(αk) ≤ − 12p ⊤ k Gpk ≤ − 12ρ 2 K .\nCombining the two equations, we get that\nL(αk) ≤ µk logn− 12ρ 2 K .\nNoting that µk = 4(k+1)(k+2) < 4 (k+1)2 , we see that L(αk) < 0 (and hence we solve the problem by Lemma 1) after at most k = 2 √ 2 logn/ρK steps."
    }, {
      "heading" : "5 Infeasible Problems",
      "text" : "What happens when the points are not separable by any function f ∈ FK? We would like an algorithm that terminates with a solution when there is one, and terminates with a certificate of non-separability if there isn’t one. The idea is based on theorems of the alternative like Farkas’ Lemma, specifically a version of Gordan’s theorem (Chvatal 1983):\nLemma 6 (Gordan’s Thm). Exactly one of the following two statements can be true\n1. Either there exists a w ∈ Rd such that for all i,\nyi(w ⊤xi) > 0,\n2. Or, there exists a p ∈ ∆n such that ‖XY p‖2 = 0, (13)\nor equivalently ∑\ni piyixi = 0.\nAlgorithm 5 Normalized Von-Neumann (NVN) Initialize p0 = 1n/n,w0 = XY p0 for k = 0, 1, 2, 3, ... do\nif ‖XY pk‖2 ≤ ǫ then Exit and return pk as an ǫ-solution to (13) else j := argmini yix ⊤ i wk\nθk := argminλ∈[0,1] ‖(1− λ)wk + λyjxj‖2 pk+1 := (1− θk)pk + θkej wk+1 := XY pk+1 = (1 − θk)wk + θkyjxj\nend if end for\nAs mentioned in the introduction, the primal problem can be interpreted as finding a vector in the interior of the dual cone of cone{yixi}, which is infeasible the dual cone is flat i.e. if cone{yixi} is not pointed, which happens when the origin is in the convex combination of yixis.\nWe will generalize the following algorithm for linear feasibility problems, that can be dated back to VonNeumann, who mentioned it in a private communication with Dantzig, who later studied it himself (Dantzig 1992).\nThis algorithm comes with a guarantee: If the problem (3) is infeasible, then the above algorithm will terminate with an ǫ-approximate solution to (13) in 1/ǫ2 iterations.\nEpelman & Freund (2000) proved an incomparable bound - Normalized Von-Neumann (NVN) can com-\npute an ǫ-solution to (13) in O (\n1 ρ22 log ( 1 ǫ )\n) and can also find a solution to the primal (using wk) in O (\n1 ρ22\n)\nwhen it is feasible. We derive a smoothed variant of NVN in the next section, after we prove some crucial lemmas in RKHSs."
    }, {
      "heading" : "5.1 A Separation Theorem for RKHSs",
      "text" : "While finite dimensional Euclidean spaces come with strong separation guarantees that come under various names like the separating hyperplane theorem, Gordan’s theorem, Farkas’ lemma, etc, the story isn’t always the same for infinite dimensional function spaces which can often be tricky to deal with. We will prove an appropriate version of such a theorem that will be useful in our setting.\nWhat follows is an interesting version of the Hahn-Banach separation theorem, which looks a lot like Gordan’s theorem in finite dimensional spaces. The conditions to note here are that either Gα > 0 or ‖p‖G = 0.\nTheorem 2. Exactly one of the following has a solution: 1. Either ∃f ∈ FK such that for all i,\nyif(xi) √\nK(xi, xi) = 〈f, yiφ̃xi〉K > 0 i.e. Gα > 0,\n2. Or ∃p ∈ ∆n such that ∑\ni\npiyiφ̃xi = 0 ∈ FK i.e. ‖p‖G = 0. (14)\nProof. Consider the following set\nQ =\n{\n(f, t) =\n(\n∑\ni\npiyiφ̃xi , ∑\ni\npi\n) : p ∈ ∆n }\n= conv [ (y1φ̃x1 , 1), ..., (ynφ̃xn , 1) ]\n⊆ FK × R.\nIf (2) does not hold, then it implies that (0, 1) /∈ Q. Since Q is closed and convex, we can find a separating hyperplane between Q and (0, 1), or in other words there exists (f, t) ∈ FK × R such that\n〈 (f, t), (g, s) 〉 ≥ 0 ∀(g, s) ∈ Q\nand 〈 (f, t), (0, 1) 〉 < 0.\nThe second condition immediately yields t < 0. The first condition, when applied to (g, s) = (yiφ̃xi , 1) ∈ Q yields\n〈f, yiφ̃xi〉K + t ≥ 0\n⇔ yif(xi)√ K(xi, xi) > 0\nsince t < 0, which shows that (1) holds. It is also immediate that if (2) holds, then (1) cannot.\nNote that G is positive semi-definite - infeasibility requires both that it is not positive definite, and also that the witness to p⊤Gp = 0 must be a probability vector. Similarly, while it suffices that Gα > 0 for some α ∈ Rn, but coincidentally in our case α will also lie in the probability simplex."
    }, {
      "heading" : "5.2 The infeasible margin ρK",
      "text" : "Note that constraining ‖f‖K = 1 (or ‖α‖G = 1) in Eq. (5) and Lemma 3 allows ρK to be negative in the infeasible case. If it was ≤, then ρK would have been non-negative because f = 0 (ie α = 0) is always allowed.\nSo what is ρK when the problem is infeasible? Let\nconv(Y φ̃X) := { ∑\ni\npiyiφ̃xi |p ∈ ∆n } ⊂ FK\nbe the convex hull of the yiφ̃xis.\nTheorem 3. When the primal is infeasible, the margin1 is\n|ρK | = δmax := sup { δ ∣ ∣ ‖f‖K ≤ δ ⇒ f ∈ conv(Y φ̃X) }\nProof. (1) For inequality ≥. Choose any δ such that f ∈ conv(Y φ̃X) for any ‖f‖K ≤ δ. Given an arbitrary f ′ ∈ FK with ‖f ′‖K = 1, put f̃ := −δf ′.\n1We thank a reviewer for pointing out that by this definition, ρK might always be 0 for infinite dimensional RKHSs because there are always directions perpendicular to the finite-dimensional hull - we conjecture the definition can be altered to restrict attention to the relative interior of the hull, making it non-zero.\nBy our assumption on δ, we have f̃ ∈ conv(Y φ̃X) implying there exists a p̃ ∈ ∆n such that f̃ = 〈Y φ̃X , p̃〉 . Also\n〈 f ′, 〈Y φ̃X , p̃〉 〉 K = 〈f ′, f̃〉K = −δ‖f ′‖2K = −δ.\nSince this holds for a particular p̃, we can infer\ninf p∈∆n\n〈 f ′, 〈Y φ̃X , p̃〉 〉\nK ≤ −δ.\nSince this holds for any f ′ with ‖f ′‖G = 1, we have\nsup ‖f‖K=1 inf p∈∆n\n〈 f ′, 〈Y φ̃X , p̃〉 〉\nK ≤ −δ i.e. |ρK | ≥ δ.\n(2) For inequality ≤. It suffices to show ‖f‖K ≤ |ρK | ⇒ f ∈ conv(Y φ̃X). We will prove the contrapositive f /∈ conv(Y φ̃X) ⇒ ‖f‖K > |ρK |.\nSince∆n is compact and convex, conv(Y φ̃X) ⊂ FK is closed and convex. Therefore if f /∈ conv(Y φ̃X), then there exists g ∈ FK with ‖g‖K = 1 that separates f and conv(Y φ̃X), i.e. for all p ∈ ∆n,\n〈g, f〉K < 0 and 〈g, 〈Y φ̃X , p〉〉K ≥ 0 i.e. 〈g, f〉K < inf\np∈∆n 〈g, 〈Y φ̃X , p〉〉K\n≤ sup ‖f‖K=1 inf p∈∆n 〈f, 〈Y φ̃X , p〉〉K = ρK .\nSince ρK < 0 |ρK | < |〈f, g〉K | ≤ ‖f‖K‖g‖K = ‖f‖K ."
    }, {
      "heading" : "6 Kernelized Primal-Dual Algorithms",
      "text" : "The preceding theorems allow us to write a variant of the Normalized VonNeumann algorithm from the previous section that is smoothed and works for RKHSs. Define\nW := { p ∈ ∆n ∣ ∣ ∣ ∑\ni\npiyiφ̃xi = 0 } = { p ∈ ∆n ∣ ∣ ∣ ‖p‖G = 0 }\nas the set of witnesses to the infeasibility of the primal. The following lemma bounds the distance of any point in the simplex from the witness set by its ‖.‖G norm.\nLemma 7. For all q ∈ ∆n, the distance to the witness set\ndist(q,W ) := min w∈W\n‖q − w‖2 ≤ min { √ 2, √ 2‖q‖G |ρK | } ."
    }, {
      "heading" : "As a consequence, ‖p‖G = 0 iff p ∈ W .",
      "text" : "Proof. This is trivial for p ∈ W . For arbitrary p ∈ ∆n\\W , let p̃ := − |ρK |p‖p‖G so that ‖〈Y φ̃X , p̃〉‖K = ‖p̃‖G ≤ |ρK |.\nHence by Theorem 3, there exists α ∈ ∆n such that\n〈Y φ̃X , α〉 = 〈Y φ̃X , p̃〉.\nLet β = λα+ (1 − λ)p where λ = ‖p‖G‖p‖G+|ρK | . Then\n〈Y φ̃X , β〉 = 1 ‖p‖G + |ρK | 〈 Y φ̃X , ‖p‖Gα+ |ρK |p 〉\n= 1\n‖p‖G + |ρK | 〈Y φ̃X , ‖p‖Gp̃+ |ρK |p〉\n= 0,\nso β ∈ W (by definition of what it means to be in W ) and\n‖p− β‖2 = λ‖p− α‖2 ≤ λ √ 2 ≤ min\n{\n√ 2, √ 2‖q‖G |ρK | } .\nWe take min with √ 2 because ρK might be 0.\nHence for the primal or dual problem, points with small G-norm are revealing - either Lemma 3 shows that the margin ρK ≤ ‖p‖G will be small, or if it is infeasible then the above lemma shows that it is close to the witness set.\nWe need a small alteration to the smoothing entropy prox-function that we used earlier. We will now use\ndq(p) = 1 2‖p− q‖ 2 2\nfor some given q ∈ ∆n, which is strongly convex with respect to the ℓ2 norm. This allows us to define\npqµ(α) = arg min p∈∆n 〈Gα, p〉+ µ 2 ‖p− q‖22,\nLqµ(α) = sup p∈∆n\n{ − 〈α, p〉G − µdq(p) } + 12‖α‖ 2 G,\nwhich can easily be found by sorting the entries of q − Gαµ .\nAlgorithm 6 Smoothed Normalized Kernel Perceptron-VonNeumann (SNKPVN(q, δ)) Input q ∈ ∆n, accuracy δ > 0 Set α0 = q, µ0 := 2n, p0 := pqµ0(α0) for k = 0, 1, 2, 3, ... do\nif Gαk > 0n then Halt: αk is solution to Eq. (8) else if ‖pk‖G < δ then Return pk else θk := 2 k+3\nαk+1 := (1− θk)(αk + θkpk) + θ2k pqµk(αk) µk+1 = (1− θk)µk pk+1 := (1− θk)pk + θk pqµk+1(αk+1)\nend if end for\nWhen the primal is feasible, SNKPVN is similar to SNKP.\nLemma 8 (When ρK > 0 and δ < ρK). For any q ∈ ∆n,\n− 12‖pk‖ 2 G ≥ Lqµk(αk) ≥ L(αk)− µk.\nHence SNKPVN finds a separator f in O (√\nn ρK\n)\niterations.\nProof. We give a unified proof for the first inequality and Lemma 5 in the Appendix. The second inequality mimics Lemma 4. The final statement mimics Theorem 1.\nThe following lemma captures the near-infeasible case.\nLemma 9 (When ρK < 0 or δ > ρK). For any q ∈ ∆n,\n− 12‖pk‖ 2 G ≥ Lqµk(αk) ≥ − 1 2µkdist(q,W ) 2.\nHence SNKPVN finds a δ-solution in at most O ( min {√\nn δ , √ n‖q‖G δ|ρK | }) iterations.\nProof. The first inequality is the same as in the above Lemma 8, and is proved in the Appendix.\nLqµk(αk) = sup p∈∆n\n{ − 〈α, p〉G − µkdq(p) } + 12‖α‖ 2 G\n≥ sup p∈W\n{ − 〈α, p〉G − µkdq(p) }\n= sup p∈W\n{\n− 12µk‖p− q‖ 2 2\n}\n= − 12µkdist(q,W ) 2 ≥ −µk min {\n2, ‖q‖2G |ρK |2\n}\nusing Lemma 7.\nSince µk = 4n(k+1)(k+2) ≤ 4n(k+1)2 we get\n‖pk‖G ≤ 2 √ n\n(k + 1) min\n{√ 2, ‖q‖G ρK } .\nHence ‖p‖G ≤ δ after 2 √ n δ min {√ 2, ‖q‖GρK } steps.\nUsing SNKPVN as a subroutine gives our final algorithm.\nAlgorithm 7 Iterated Smoothed Normalized Kernel Perceptron-VonNeumann (ISNKPVN(γ, ǫ)) Input constant γ > 1, accuracy ǫ > 0 Set q0 := 1n/n for t = 0, 1, 2, 3, ... do δt := ‖qt‖G/γ qt+1 := SNKPVN(qt, δt) if δt < ǫ then\nHalt; qt+1 is a solution to Eq. (14) end if\nend for\nTheorem 4. Algorithm ISNKPVN satisfies\n1. If the primal (2) is feasible and ǫ < ρK , then each call to SNKPVN halts in at most 2 √ 2n\nρK iterations.\nAlgorithm ISNKPVN finds a solution in at most log(1/ρK)log(γ) outer loops, bounding the total iterations by\nO\n(√ n\nρK log\n(\n1\nρK\n))\n.\n2. If the dual (14) is feasible or ǫ > ρK , then each call to SNKPVN halts in at most O ( min {√ n ǫ , √ n |ρK | })\nsteps. Algorithm ISNKPVN finds an ǫ-solution in at most log(1/ǫ)log(γ) outer loops, bounding the total iterations by\nO\n(\nmin\n{√ n\nǫ ,\n√ n\n|ρK |\n}\nlog\n(\n1\nǫ\n))\n.\nProof. First note that if ISNKPVN has not halted, then we know that after t outer iterations, qt+1 has small G-norm:\n‖qt+1‖G ≤ δt ≤ ‖q0‖G γt+1 . (15)\nThe first inequality holds because of the inner loop return condition, the second because of the update for δt.\n1. Lemma 3 shows that for all p we have ρK ≤ ‖p‖G, so the inner loop will halt with a solution to the primal as soon as δt ≤ ρK (so that ‖p‖G < δt ≤ ρK cannot be satisfied for the inner loop to return). From Eq. (15), this will definitely happen when ‖q0‖Gγt+1 ≤ ρK , ie within T = log(‖qo‖G/ρK) log(γ) iterations.\nBy Lemma 8, each iteration runs for at most 2 √ 2n\nρK steps.\n2. We halt with an ǫ-solution when δt < ǫ, which definitely happens when ‖q0‖G γt+1 < ǫ, ie within\nT = log(‖qo‖G/ǫ)log(γ) iterations. Since ‖qt‖G δt = γ, by Lemma 9, each iteration runs for at most O ( min {√\nn ǫ ,\n√ n |ρK | }) steps."
    }, {
      "heading" : "7 Discussion",
      "text" : "The SNK-Perceptron algorithm presented in this paper has a convergence rate of √ logn ρK and the Iterated SNK-Perceptron-Von-Neumann algorithm has a min {√\nn ǫ ,\n√ n |ρK | } dependence on the number of points. Note\nthat both of these are independent of the underlying dimensionality of the problem. We conjecture that it is possible to reduce this dependence to √ logn for the primal-dual algorithm also, without paying a price in terms of the dependence on margin 1/ρ (or the dependence on ǫ). It is possible that tighter dependence on n is possible if we try other smoothing functions instead of the ℓ2 norm used in the last section. Specifically, it might be tempting to smooth with the ‖.‖G semi-norm and define:\npqµ(α) = arg min p∈∆n\n〈α, p〉G + µ\n2 ‖p− q‖2G\nOne can actually see that the proofs in the Appendix go through with no dimension dependence on n at all! However, it is not possible to solve this in closed form - taking α = q and µ = 1 reduces the problem to asking\npq(q) = arg min p∈∆n 1 2‖p‖ 2 G\nwhich is an oracle for our problem as seen by equation (14) - the solution’s G-norm is 0 iff the problem is infeasible.\nIn the bigger picture, there are several interesting open questions. The ellipsoid algorithm for solving linear feasibility problems has a logarithmic dependence on 1/ǫ, and a polynomial dependence on dimension.\nRecent algorithms involving repeated rescaling of the space like the one by Dunagan & Vempala (2008) have logarithmic dependence on 1/ρ and polynomial in dimension. While both these algorithms are polytime under the real number model of computation of Blum et al. (1998), it is unknown whether there is any algorithm that can achieve a polylogarithmic dependence on the margin/accuracy, and a polylogarithmic dependence on dimension. This is strongly related to the open question of whether it is possible to learn a decision list polynomially in its binary description length.\nOne can nevertheless ask whether rescaled smoothed perceptron methods like Dunagan & Vempala (2008) can be lifted to RKHSs, and whether using an iterated smoothed kernel perceptron would yield faster rates. The recent work Soheili & Peña (2013a) is a challenge to generalize - the proofs relying on geometry involve arguing about volumes of balls of functions in an RKHS - we conjecture that it is possible to do, but we leave it for a later work."
    }, {
      "heading" : "Acknowledgements",
      "text" : "We thank Negar Soheili and Avrim Blum for insightful discussions."
    }, {
      "heading" : "A Unified Proof By Induction of Lemma 5, 8: Lµk(αk) ≤ −12‖pk‖2G",
      "text" : "Let d(p) be 1-strongly convex with respect to the #-norm, ie d(q)− d(p)− 〈∇d(p), q− p〉 ≥ 12‖q− p‖2#for any p, q ∈ ∆n. Let the #-norm be lower bounded by the G-norm as ‖p‖2G ≤ λ#‖p‖2#. For d(p) = ∑\ni pi log pi + logn, # is the 1-norm, λ# = 1 and p ∗ = 1nn . For d(p) = 1 2‖q − p‖22, # is the 2-norm,\nλ# = n and p∗ = q. Choose µ0 = 2λ#. Let the smoothed minimizer be defined by pµ(α) := argminp∈∆n〈Gα, p〉+µd(p), and p∗ := argminp∈∆n d(p). The optimality condition of pµ(α) and p∗ (the gradient is perpendicular to any feasible direction) is that for any r ∈ ∆n,\n〈Gα+ µ∇d(pµ(α)), r − p〉 = 0 (16) 〈∇d(p∗), r − p〉 = 0 ⇒ d(p0) ≥ 12‖p0 − p ∗‖2#. (17)\nFor k = 0 : − 12‖p0‖ 2 G = − 12‖p0 − p ∗‖2G − 〈p∗, p0 − p∗〉G − 12‖p ∗‖2G writing p0 = (p0 − p∗) + p∗\n≥ −λ#2 ‖p0 − p ∗‖2# − 〈p∗, p0〉G + 12‖p ∗‖2G using ‖p‖2G ≤ λ#‖p‖2# ≥ −µ0d(p0)− 〈α0, p0〉G + 12‖α0‖ 2 G adding − λ# 2 ‖p0 − p∗‖21, using Eq. (2) = Lµ0(α0).\nAssume it holds upto k. We drop index k, and write x+ for xk+1. Let p̂ = (1 − θ)p + θpµ(α) so α+ = (1− θ)α + θp̂. (3)\nLµ+(α+) = 1 2‖α+‖ 2 G −\n〈 α+, pµ+(α+) 〉 G − µ+d(pµ+(α+))\n= 12 ∥ ∥(1 − θ)α+ θp̂ ∥ ∥ 2 G − θ 〈 p̂, pµ+(α+) 〉 G − (1− θ)\n[\n〈 α, pµ+(α+) 〉\nG + µd(pµ+(α+))\n]\nusing Eq. (3)\n≤ (1− θ) [\n1 2‖α‖ 2 G −\n〈 α, pµ+(α+) 〉 G − µd(pµ+(α+))\n]\n1\n+ θ\n[\n− 12‖p̂‖ 2 G −\n〈 p̂, pµ+(α+)− p̂ 〉\nG\n]\n,\nwhere we used the convexity of ‖.‖2G. Recall p+ = (1 − θ)p + θpµ+(α+), so that p+ − p̂ = θ(pµ+(α+) − pµ(α)). (4)\n[ . ]\n1 =\n[\n1 2‖α‖ 2 G −\n〈 α, pµ(α) 〉\nG − µd(pµ(α))\n] − 〈 α, pµ+(α+)− pµ(α) 〉 G − µ [ d(pµ+(α+))− d(pµ(α)) ]\n= Lµ(α) − µ [ d(pµ+(α+))− d(pµ(α)) − 〈 ∇d(pµ(α)), pµ+ (α+)− pµ(α) 〉] using Eq. (1)\n≤ − 12‖p‖ 2 G − µ2 ‖pµ+(α+)− pµ(α)‖ 2 # using strong convexity of d(p) ≤ − 12‖p̂+ (p− p̂)‖2G − µ 2λ# ‖pµ+(α+)− pµ(α)‖2G using ‖p‖2G ≤ λ#‖p‖2#\n≤ − 12‖p̂‖ 2 G −\n〈 p̂, p− p̂ 〉 G − µ\n2λ#θ2 ‖p+ − p̂‖2G using Eq. (4) and dropping a − 12‖p− p̂‖2G term.\nUsing (1− θ)(p− p̂) = −θ(pµ(α)− p̂) and substituting back,\nLµ+(α+) ≤ (1− θ) [ − 12‖p̂‖ 2 G + θ 1−θ 〈 p̂, pµ(α)− p̂ 〉 G − µ\n2λ#θ2 ‖p+ − p̂‖2G\n]\n+ θ\n[\n− 12‖p̂‖ 2 G −\n〈 p̂, pµ+(α+)− p̂ 〉\nG\n]\n= − 12‖p̂‖ 2 G − θ\n〈 p̂, pµ+(α+)− pµ(α) 〉 G − µ(1− θ)\n2λ#θ2 ‖p+ − p̂‖2G\n≤ − 12‖p̂‖ 2 G −\n〈 p̂, p+ − p̂ 〉\nG − 12‖p+ − p̂‖ 2 G using Eq. (4) and\nθ2\n1−θ = 4 (k+1)(k+3) ≤ 4(k+1)(k+2) = µ λ#\n= − 12‖p+‖ 2 G.\nThis wraps up our unified proof for both settings."
    } ],
    "references" : [ {
      "title" : "The perceptron: A model for brain functioning",
      "author" : [ "H. Block" ],
      "venue" : "i’, Reviews of Modern Physics",
      "citeRegEx" : "Block,? \\Q1962\\E",
      "shortCiteRegEx" : "Block",
      "year" : 1962
    }, {
      "title" : "Complexity and real computation, Springer",
      "author" : [ "L. Blum", "F. Cucker", "M. Shub", "S. Smale" ],
      "venue" : null,
      "citeRegEx" : "Blum et al\\.,? \\Q1998\\E",
      "shortCiteRegEx" : "Blum et al\\.",
      "year" : 1998
    }, {
      "title" : "A new condition number for linear programming",
      "author" : [ "D. Cheung", "F. Cucker" ],
      "venue" : "Mathematical programming",
      "citeRegEx" : "Cheung and Cucker,? \\Q2001\\E",
      "shortCiteRegEx" : "Cheung and Cucker",
      "year" : 2001
    }, {
      "title" : "Coresets, sparse greedy approximation, and the Frank-Wolfe algorithm",
      "author" : [ "K.L. Clarkson" ],
      "venue" : "ACM Transactions on Algorithms",
      "citeRegEx" : "Clarkson,? \\Q2010\\E",
      "shortCiteRegEx" : "Clarkson",
      "year" : 2010
    }, {
      "title" : "A simple polynomial-time rescaling algorithm for solving linear programs",
      "author" : [ "J. Dunagan", "S. Vempala" ],
      "venue" : "Mathematical Programming",
      "citeRegEx" : "Dunagan and Vempala,? \\Q2008\\E",
      "shortCiteRegEx" : "Dunagan and Vempala",
      "year" : 2008
    }, {
      "title" : "Condition number complexity of an elementary algorithm for computing a reliable solution of a conic linear system",
      "author" : [ "M. Epelman", "R.M. Freund" ],
      "venue" : "Mathematical Programming",
      "citeRegEx" : "Epelman and Freund,? \\Q2000\\E",
      "shortCiteRegEx" : "Epelman and Freund",
      "year" : 2000
    }, {
      "title" : "Condition-based complexity of convex optimization in conic linear form via the ellipsoid algorithm",
      "author" : [ "R.M. Freund", "J.R. Vera" ],
      "venue" : "SIAM Journal on Optimization",
      "citeRegEx" : "Freund and Vera,? \\Q1999\\E",
      "shortCiteRegEx" : "Freund and Vera",
      "year" : 1999
    }, {
      "title" : "From margin to sparsity’, Advances in neural information processing systems",
      "author" : [ "T. Graepel", "R. Herbrich", "R.C. Williamson" ],
      "venue" : null,
      "citeRegEx" : "Graepel et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Graepel et al\\.",
      "year" : 2001
    }, {
      "title" : "Redundant noisy attributes, attribute errors, and linear-threshold learning using winnow, in ‘Proceedings of the fourth annual workshop on Computational learning theory",
      "author" : [ "N. Littlestone" ],
      "venue" : null,
      "citeRegEx" : "Littlestone,? \\Q1991\\E",
      "shortCiteRegEx" : "Littlestone",
      "year" : 1991
    }, {
      "title" : "Prox-method with rate of convergence O(1/t) for variational inequalities with Lipschitz continuous monotone operators and smooth convex-concave saddle point problems",
      "author" : [ "A. Nemirovski" ],
      "venue" : "SIAM Journal on Optimization",
      "citeRegEx" : "Nemirovski,? \\Q2004\\E",
      "shortCiteRegEx" : "Nemirovski",
      "year" : 2004
    }, {
      "title" : "Excessive gap technique in nonsmooth convex minimization",
      "author" : [ "Y. Nesterov" ],
      "venue" : "SIAM Journal on Optimization",
      "citeRegEx" : "Nesterov,? \\Q2005\\E",
      "shortCiteRegEx" : "Nesterov",
      "year" : 2005
    }, {
      "title" : "On convergence proofs for perceptrons, Technical report",
      "author" : [ "A.B. Novikoff" ],
      "venue" : null,
      "citeRegEx" : "Novikoff,? \\Q1962\\E",
      "shortCiteRegEx" : "Novikoff",
      "year" : 1962
    }, {
      "title" : "Incorporating condition measures into the complexity theory of linear programming",
      "author" : [ "J. Renegar" ],
      "venue" : "SIAM Journal on Optimization",
      "citeRegEx" : "Renegar,? \\Q1995\\E",
      "shortCiteRegEx" : "Renegar",
      "year" : 1995
    }, {
      "title" : "The perceptron: a probabilistic model for information storage and organization in the brain.",
      "author" : [ "F. Rosenblatt" ],
      "venue" : "Psychological review",
      "citeRegEx" : "Rosenblatt,? \\Q1958\\E",
      "shortCiteRegEx" : "Rosenblatt",
      "year" : 1958
    }, {
      "title" : "New approximation algorithms for minimum enclosing convex shapes, in ‘Proceedings of the Twenty-Second",
      "author" : [ "A. Saha", "S. Vishwanathan", "X. Zhang" ],
      "venue" : "Annual ACM-SIAM Symposium on Discrete Algorithms’,",
      "citeRegEx" : "Saha et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Saha et al\\.",
      "year" : 2011
    }, {
      "title" : "A generalized representer theorem, in ‘Computational learning theory",
      "author" : [ "B. Schölkopf", "R. Herbrich", "A.J. Smola" ],
      "venue" : null,
      "citeRegEx" : "Schölkopf et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Schölkopf et al\\.",
      "year" : 2001
    }, {
      "title" : "Learning with kernels",
      "author" : [ "B. Schölkopf", "A.J. Smola" ],
      "venue" : null,
      "citeRegEx" : "Schölkopf and Smola,? \\Q2002\\E",
      "shortCiteRegEx" : "Schölkopf and Smola",
      "year" : 2002
    }, {
      "title" : "A smooth perceptron algorithm",
      "author" : [ "N. Soheili", "J. Peña" ],
      "venue" : "SIAM Journal on Optimization",
      "citeRegEx" : "Soheili and Peña,? \\Q2012\\E",
      "shortCiteRegEx" : "Soheili and Peña",
      "year" : 2012
    }, {
      "title" : "2013a), ‘A deterministic rescaled perceptron algorithm",
      "author" : [ "N. Soheili", "J. Peña" ],
      "venue" : null,
      "citeRegEx" : "Soheili and Peña,? \\Q2013\\E",
      "shortCiteRegEx" : "Soheili and Peña",
      "year" : 2013
    }, {
      "title" : "2013b), A primal–dual smooth perceptron–von Neumann algorithm, in ‘Discrete Geometry and Optimization",
      "author" : [ "N. Soheili", "J. Peña" ],
      "venue" : null,
      "citeRegEx" : "Soheili and Peña,? \\Q2013\\E",
      "shortCiteRegEx" : "Soheili and Peña",
      "year" : 2013
    }, {
      "title" : "On accelerated proximal gradient methods for convex-concave optimization",
      "author" : [ "P. Tseng" ],
      "venue" : "SIAM Journal on Optimization",
      "citeRegEx" : "Tseng,? \\Q2008\\E",
      "shortCiteRegEx" : "Tseng",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 8,
      "context" : "It can be thought of as the width of the feasibility cone as in Freund & Vera (1999), a radius of well-posedness as in Cheung & Cucker (2001), and its inverse can be seen as a special case of a condition number defined by Renegar (1995) for these systems.",
      "startOffset" : 222,
      "endOffset" : 237
    }, {
      "referenceID" : 8,
      "context" : "It can be thought of as the width of the feasibility cone as in Freund & Vera (1999), a radius of well-posedness as in Cheung & Cucker (2001), and its inverse can be seen as a special case of a condition number defined by Renegar (1995) for these systems. 1.1 Related Work In this paper we focus on the famous Perceptron algorithm from Rosenblatt (1958) and the less-famous VonNeumann algorithm from Dantzig (1992) that we introduce in later sections.",
      "startOffset" : 222,
      "endOffset" : 354
    }, {
      "referenceID" : 8,
      "context" : "It can be thought of as the width of the feasibility cone as in Freund & Vera (1999), a radius of well-posedness as in Cheung & Cucker (2001), and its inverse can be seen as a special case of a condition number defined by Renegar (1995) for these systems. 1.1 Related Work In this paper we focus on the famous Perceptron algorithm from Rosenblatt (1958) and the less-famous VonNeumann algorithm from Dantzig (1992) that we introduce in later sections.",
      "startOffset" : 222,
      "endOffset" : 415
    }, {
      "referenceID" : 8,
      "context" : "It can be thought of as the width of the feasibility cone as in Freund & Vera (1999), a radius of well-posedness as in Cheung & Cucker (2001), and its inverse can be seen as a special case of a condition number defined by Renegar (1995) for these systems. 1.1 Related Work In this paper we focus on the famous Perceptron algorithm from Rosenblatt (1958) and the less-famous VonNeumann algorithm from Dantzig (1992) that we introduce in later sections. As mentioned by Epelman & Freund (2000), in a technical report by the same name, Nesterov pointed out in a note to the authors that the latter is a special case of the now-popular Frank-Wolfe algorithm.",
      "startOffset" : 222,
      "endOffset" : 492
    }, {
      "referenceID" : 7,
      "context" : "As mentioned by Epelman & Freund (2000), in a technical report by the same name, Nesterov pointed out in a note to the authors that the latter is a special case of the now-popular Frank-Wolfe algorithm. Our work builds on Soheili & Peña (2012, 2013b) from the field of optimization - we generalize the setting to learning functions in RKHSs, extend the algorithms, simplify proofs, and simultaneously bring new perspectives to it. There is extensive literature around the Perceptron algorithm in the learning community; we restrict ourselves to discussing only a few directly related papers, in order to point out the several differences from existing work. We provide a general unified proof in the Appendix which borrows ideas from accelerated smoothing methods developed by Nesterov (2005) - while this algorithm and others by Nemirovski (2004), Saha et al.",
      "startOffset" : 81,
      "endOffset" : 793
    }, {
      "referenceID" : 7,
      "context" : "We provide a general unified proof in the Appendix which borrows ideas from accelerated smoothing methods developed by Nesterov (2005) - while this algorithm and others by Nemirovski (2004), Saha et al.",
      "startOffset" : 172,
      "endOffset" : 190
    }, {
      "referenceID" : 7,
      "context" : "We provide a general unified proof in the Appendix which borrows ideas from accelerated smoothing methods developed by Nesterov (2005) - while this algorithm and others by Nemirovski (2004), Saha et al. (2011) can achieve similar rates for the same problem, those algorithms do not possess the simplicity of the Perceptron or Von-Neumann algorithms and our variants, and also don’t look at the infeasible setting or primal-dual algorithms.",
      "startOffset" : 172,
      "endOffset" : 210
    }, {
      "referenceID" : 7,
      "context" : "We provide a general unified proof in the Appendix which borrows ideas from accelerated smoothing methods developed by Nesterov (2005) - while this algorithm and others by Nemirovski (2004), Saha et al. (2011) can achieve similar rates for the same problem, those algorithms do not possess the simplicity of the Perceptron or Von-Neumann algorithms and our variants, and also don’t look at the infeasible setting or primal-dual algorithms. Accelerated smoothing techniques have also been seen in the learning literature like in Tseng (2008) and many others.",
      "startOffset" : 172,
      "endOffset" : 541
    }, {
      "referenceID" : 3,
      "context" : "This work is also connected to the idea of ǫ-coresets by Clarkson (2010), though we will not explore that angle.",
      "startOffset" : 57,
      "endOffset" : 73
    }, {
      "referenceID" : 3,
      "context" : "This work is also connected to the idea of ǫ-coresets by Clarkson (2010), though we will not explore that angle. A related algorithm is called the Winnow by Littlestone (1991) - this works on the l1 margin and is a saddle point problem over two simplices.",
      "startOffset" : 57,
      "endOffset" : 176
    }, {
      "referenceID" : 0,
      "context" : "do if sign(w⊤ k xi) 6= yi for some i then wk+1 := wk + yixi else Halt: Return wk as solution end if end for It comes with the following classic guarantee as proved by Block (1962) and Novikoff (1962): If there exists a unit vector u ∈ R such that Y X⊤u ≥ ρ > 0, then a perfect separator will be found in maxi ‖xi‖ 2 2 ρ2 iterations/mistakes.",
      "startOffset" : 167,
      "endOffset" : 180
    }, {
      "referenceID" : 0,
      "context" : "do if sign(w⊤ k xi) 6= yi for some i then wk+1 := wk + yixi else Halt: Return wk as solution end if end for It comes with the following classic guarantee as proved by Block (1962) and Novikoff (1962): If there exists a unit vector u ∈ R such that Y X⊤u ≥ ρ > 0, then a perfect separator will be found in maxi ‖xi‖ 2 2 ρ2 iterations/mistakes.",
      "startOffset" : 167,
      "endOffset" : 200
    }, {
      "referenceID" : 7,
      "context" : "Hence, it is always better to normalize the data as pointed out in Graepel et al. (2001). This idea extends to RKHSs, motivating the normalized Gram matrix considered later.",
      "startOffset" : 67,
      "endOffset" : 89
    }, {
      "referenceID" : 7,
      "context" : "Hence, it is always better to normalize the data as pointed out in Graepel et al. (2001). This idea extends to RKHSs, motivating the normalized Gram matrix considered later. Example Consider a simple example in R+. Assume that + points are located along the line 6x2 = 8x1, and the − points along 8x2 = 6x1, for 1/r ≤ ‖x‖2 ≤ r, where r > 1. The max-margin linear separator will be x1 = x2. If all the data were normalized to have unit Euclidean norm, then all the + points would all be at (0.6, 0.8) and all the − points at (0.8, 0.6), giving us a normalized margin of ρ2 ≈ 0.14. Unnormalized, the margin is ρ ≈ 0.14/r and maxi ‖xi‖2 = r. Hence, in terms of bounds, we get a discrepancy of r, which can be arbitrarily large. Winnow The question arises as to which norm we should normalize by. There is a now classic algorithm in machine learning, called Winnow by Littlestone (1991) or Multiplicate Weights.",
      "startOffset" : 67,
      "endOffset" : 883
    }, {
      "referenceID" : 7,
      "context" : "Hence, it is always better to normalize the data as pointed out in Graepel et al. (2001). This idea extends to RKHSs, motivating the normalized Gram matrix considered later. Example Consider a simple example in R+. Assume that + points are located along the line 6x2 = 8x1, and the − points along 8x2 = 6x1, for 1/r ≤ ‖x‖2 ≤ r, where r > 1. The max-margin linear separator will be x1 = x2. If all the data were normalized to have unit Euclidean norm, then all the + points would all be at (0.6, 0.8) and all the − points at (0.8, 0.6), giving us a normalized margin of ρ2 ≈ 0.14. Unnormalized, the margin is ρ ≈ 0.14/r and maxi ‖xi‖2 = r. Hence, in terms of bounds, we get a discrepancy of r, which can be arbitrarily large. Winnow The question arises as to which norm we should normalize by. There is a now classic algorithm in machine learning, called Winnow by Littlestone (1991) or Multiplicate Weights. It works on a slight transformation of the problem where we only need to search for u ∈ R+. It comes with some very wellknown guarantees - If there exists a u ∈ R+ such that Y X⊤u ≥ ρ > 0, then feasibility is guaranteed in ‖u‖1maxi ‖ai‖∞ logn/ρ iterations. The appropriate notion of normalized margin here is ρ1 := max w∈∆d min p∈∆n 〈Y X⊤ ∞w, p〉, where X∞ is a matrix with columns xi/‖xi‖∞. Then, the appropriate iteration bound is logn/ρ1. We will return to this l1-margin in the discussion section. In the next section, we will normalize by using the kernel appropriately. 3 Kernels and RKHSs The theory of Reproducing Kernel Hilbert Spaces (RKHSs) has a rich history, and for a detailed introduction, refer to Schölkopf & Smola (2002). Let K : R × R → R be a symmetric positive definite kernel, giving rise to a Reproducing Kernel Hilbert Space FK with an associated feature mapping at each point x ∈ R called φx : R → FK where φx(.",
      "startOffset" : 67,
      "endOffset" : 1646
    }, {
      "referenceID" : 15,
      "context" : "is some empirical loss function on the data and 12‖f‖K is an increasing function of ‖f‖K , the Representer Theorem (Schölkopf et al. 2001) implies that the minimizer of the above function lies in the span of φxis (also the span of the yiφ̃xis).",
      "startOffset" : 115,
      "endOffset" : 138
    }, {
      "referenceID" : 10,
      "context" : "i pi log pi + log n (12) is 1-strongly convex with respect to the l1-norm (Nesterov 2005).",
      "startOffset" : 74,
      "endOffset" : 89
    }, {
      "referenceID" : 10,
      "context" : "We provide a concise, self-contained and unified proof by induction in the Appendix for Lemma 5 and Lemma 8, borrowing ideas from Nesterov’s excessive gap technique (Nesterov 2005) for smooth minimization of structured non-smooth functions.",
      "startOffset" : 165,
      "endOffset" : 180
    } ],
    "year" : 2015,
    "abstractText" : "We focus on the problem of finding a non-linear classification function that lies in a Reproducing Kernel Hilbert Space (RKHS) both from the primal point of view (finding a perfect separator when one exists) and the dual point of view (giving a certificate of non-existence), with special focus on generalizations of two classical schemes the Perceptron (primal) and Von-Neumann (dual) algorithms. We cast our problem as one of maximizing the regularized normalized hard-margin (ρ) in an RKHS and rephrase it in terms of a Mahalanobis dot-product/semi-norm associated with the kernel’s (normalized and signed) Gram matrix. We derive an accelerated smoothed algorithm with a convergence rate of √ log n ρ given n separable points, which is strikingly similar to the classical kernelized Perceptron algorithm whose rate is 1 ρ2 . When no such classifier exists, we prove a version of Gordan’s separation theorem for RKHSs, and give a reinterpretation of negative margins. This allows us to give guarantees for a primal-dual algorithm that halts in min{ √ n |ρ| , √ n ǫ } iterations with a perfect separator in the RKHS if the primal is feasible or a dual ǫ-certificate of near-infeasibility.",
    "creator" : "LaTeX with hyperref package"
  }
}