{
  "name" : "1301.4910.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
    "authors" : [ "MINAS GERAIS", "FOLHA DE APROVAÇÃO", "SÉRGIO FERREIRA", "ALVIM JÚNIOR" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n30 1.\n49 10\nv1 [\ncs .L\nO ]\n2 1\nJa n\n20 13\nMÁRIO SÉRGIO FERREIRA ALVIM JÚNIOR\nASPECTOS COMPUTACIONAIS DO CÁLCULO DAS\nESTRUTURAS\nBelo Horizonte, Minas Gerais\n04 de abril de 2008\nUNIVERSIDADE FEDERAL DE MINAS GERAIS INSTITUTO DE CIÊNCIAS EXATAS\nPROGRAMA DE PÓS-GRADUAÇÃO EM CIÊNCIA DA COMPUTAÇÃO\nASPECTOS COMPUTACIONAIS DO CÁLCULO DAS\nESTRUTURAS\nDissertação apresentada ao Curso de PósGraduação em Ciência da Computação da Universidade Federal de Minas Gerais como requisito parcial para a obtenção do grau de Mestre em Ciência da Computação.\nMÁRIO SÉRGIO FERREIRA ALVIM JÚNIOR\nBelo Horizonte, Minas Gerais\n04 de abril de 2008\nUNIVERSIDADE FEDERAL DE MINAS GERAIS\nFOLHA DE APROVAÇÃO\nAspectos computacionais do cálculo das estruturas\nMÁRIO SÉRGIO FERREIRA ALVIM JÚNIOR\nDissertação defendida e aprovada pela banca examinadora constituída por:\nPh. D ELAINE GOUVÊA PIMENTEL – Orientador Departamento de Matemática / UFMG\nPh. D ROBERTO DA SILVA BIGONHA – Co-orientador Departamento de Ciência da Computação / UFMG\nPh. D JOÃO MARCOS Departamento de Informática e Matemática Aplicada / UFRN\nPh. D LUCÍLIA CAMARÃO DE FIGUEIREDO Departamento de Computação / UFOP\nBelo Horizonte, Minas Gerais, 04 de abril de 2008\nResumo\nA lógica é a ciência das inferências corretas, e um sistema lógico formal é uma ferramenta para demonstrar proposições em uma certa lógica de maneira correta. Há muitos sistemas lógicos formais, e muitas maneiras de formalizá-los, por exemplo, usando dedução natural ou cálculo de seqüentes. O cálculo de estruturas (CoS) é um novo formalismo proposto por Alessio Guglielmi em 2004 que generaliza o cálculo de seqüentes no sentido de que regras de inferência podem ser aplicadas em qualquer profundidade dentro de uma fórmula, em vez de apenas no conectivo principal. Com esta característica, demonstrações em CoS são menores do que em qualquer outro formalismo que suporte provas analíticas. Apesar de ser interessante ter esta nova liberdade e expressividade do cálculo de estruturas, sob o ponto de vista de construção de demonstrações, mais liberdade significa um espaço de busca maior. E isto deve ser restringido quando se procura pela automação completa de sistemas dedutivos. Alguns esforços foram realizados para reduzir este não determinismo, mas se tratam de abordagens basicamente operacionais, e nenhum resultado teórico sólido a respeito do comportamento computacional do CoS foi obtido até agora. O foco principal desta dissertação é discutir caminhos para propor uma estratégia de demonstração para CoS adequada à implementação. Esta estratégia deve ser teórica, e não puramente operacional. Nós introduzimos o conceito de número de incoerência de subestruturas dentro de uma estrutura e usamos este conceito para atingir nosso resultado principal: um algoritmo que, de acordo com a nossa conjectura, corresponde a uma estratégia de demonstração para toda estrutura demonstrável no subsistema FBV (a lógica linear multiplicativa MLL estendida pela regra mix) contendo apenas pares de átomos distintos dois a dois. Nosso algoritmo foi implementado e acreditamos que nossa estratégia seja um bom ponto de partida para explorar os aspectos computacionais do CoS em sistemas mais gerais, como o próprio sistema BV.\ni\nAbstract\nLogic is the science of correct inferences and a logical system is a tool to prove assertions in a certain logic in a correct way. There are many logical systems, and many ways of formalizing them, e.g., using natural deduction or sequent calculus. Calculus of structures (CoS) is a new formalism proposed by Alessio Guglielmi in 2004 that generalizes sequent calculus in the sense that inference rules can be applied at any depth inside a formula, rather than only to the main connective. With this feature, proofs in CoS are shorter than in any other formalism supporting analytical proofs. Although it is great to have the freedom and expressiveness of CoS, under the point of view of proof search more freedom means a larger search space. And that should be restricted when looking for complete automation of deductive systems. Some efforts were made to reduce this non-determinism, but they are all basically operational approaches, and no solid theoretical result regarding the computational behaviour of CoS has been achieved so far. The main focus of this thesis is to discuss ways to propose a proof search strategy for CoS suitable to implementation. This strategy should be theoretical instead of purely operational. We introduce the concept of incoherence number of substructures inside structures and we use this concept to achieve our main result: there is an algorithm that, according to our conjecture, corresponds to a proof search strategy to every provable structure in the subsystem of FBV (the multiplicative linear logic MLL plus the rule mix) containing only pairwise distinct atoms. Our algorithm is implemented and we believe our strategy is a good starting point to exploit the computational aspects of CoS in more general systems, like BV itself.\niii\nSumário\n1 Introdução 1\n1.1 Definição do problema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\n1.1.1 Introdução . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.1.2 Motivação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.1.3 Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.1.4 Contribuição . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.2 Revisão da literatura . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4 1.3 Sumário da dissertação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.4 Consideração relevante . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6"
    }, {
      "heading" : "2 Teoria da Demonstração: conceitos fundamentais 7",
      "text" : "2.1 Lógica clássica e sistemas formais . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n2.1.1 Cálculo de seqüentes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\n2.2 Lógica intuicionista . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10 2.3 Lógica linear . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\n2.3.1 MLL: fragmento multiplicativo da lógica linear . . . . . . . . . . . . . . 13\n2.4 Regra mix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.5 Demonstrações uniformes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n2.5.1 Cláusulas de Horn e fórmulas de Harrop . . . . . . . . . . . . . . . . . 19 2.5.2 demonstrações uniformes em lógica linear . . . . . . . . . . . . . . . . 20"
    }, {
      "heading" : "3 Cálculo das estruturas 23",
      "text" : "3.1 O Cálculo das estruturas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\n3.1.1 Visão geral . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 3.1.2 Estruturas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24 3.1.3 Redes de interação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 3.1.4 O Sistema BV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37 3.1.5 O teorema de splitting . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n3.2 Reduzindo o não determinismo no cálculo das estruturas . . . . . . . . . . . . 63\n3.2.1 Análise do estado da arte . . . . . . . . . . . . . . . . . . . . . . . . . . 65"
    }, {
      "heading" : "4 Aspectos computacionais do cálculo das estruturas 67",
      "text" : "4.1 Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67\nv\n4.2 Abordagem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68\n4.2.1 O problema do comportamento operacional . . . . . . . . . . . . . . . 68 4.2.2 O problema do não-determinismo . . . . . . . . . . . . . . . . . . . . . 70\n4.3 A tentativa de solução proposta . . . . . . . . . . . . . . . . . . . . . . . . . . . 71\n4.3.1 Resultados fundamentais e definições . . . . . . . . . . . . . . . . . . . 72 4.3.2 Resultados principais . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81"
    }, {
      "heading" : "5 Implementação 101",
      "text" : "5.1 Entrada de dados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101 5.2 Saída de dados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102 5.3 Complexidade computacional . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104 5.4 Qualidade dos resultados . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105"
    }, {
      "heading" : "6 Conclusão 107",
      "text" : "vi\nLista de Figuras\n1.1 Sistema SKSg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n2.1 Cálculo de seqüentes para a lógica clássica LK . . . . . . . . . . . . . . . . . . . . 10 2.2 Cálculo de seqüentes para a lógica intuicionista LJ . . . . . . . . . . . . . . . . . . 11 2.3 Cálculo de seqüentes para a lógica linear clássica LL . . . . . . . . . . . . . . . . . 14 2.4 Cálculo de seqüentes de um lado só para a lógica linear multiplicativa MLL . . . 14 2.5 Sistema G3c para a lógica clássica de primeira ordem . . . . . . . . . . . . . . . . 17 2.6 Sistema de demonstrações de Forum . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n3.1 Equivalência sintática = . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 3.2 Propriedade do quadrado para ⊳ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31 3.3 Propriedade do quadrado para ↓ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32 3.4 Sistema BV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38 3.5 Sistema FBV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39\n4.1 Regras de inferência não criam relações ↓ quando vistas de baixo para cima. . . . 76\nvii\nLista de Tabelas\n2.1 Tabela de verdade para a lógica clássica proposicional . . . . . . . . . . . . . . . . 8\n5.1 Exemplos das principais construções da gramática de estruturas para o CoSProver.101 5.2 Representação de regras na saída. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\nix\nCapítulo 1\nIntrodução"
    }, {
      "heading" : "1.1 Definição do problema",
      "text" : ""
    }, {
      "heading" : "1.1.1 Introdução",
      "text" : "A lógica é o estudo dos princípios e critéiros de inferências e demonstrações válidas.\nUm sistema lógico é composto por três partes: a sintaxe (ou notação), uma especificação de regras de inferência (ou de argumentação), e o significado das sentenças lógicas (semântica).\nEm geral, para uma dada lógica, existem diversas formas de se definir o sistema de regras de um sistema lógico formal. Para as lógicas mais difundidas como a lógica clássica, a lógica intuicionista e a lógica linear, os sistemas de inferência mais utilizados são baseados em formalismos como a dedução natural e o cálculo de seqüentes, ambos propostos por Gentzen no século XX. A dedução natural é um formalismo cujas regras possuem uma apresentação mais intuitiva, semelhante ao raciocínio humano. Entretanto, construir demonstrações utilizando dedução natural é muito difícil, uma vez que não existe, começando da fórmula que se deseja demonstrar e seguindo de baixo para cima1, uma estratégia de demonstração.\nJá o cálculo de seqüentes é um formalismo menos intuitivo, mas computacionalmente muito mais poderoso, uma vez que as regras relativas aos conectivos lógicos, quando analisadas de baixo para cima, reduzem o número de conectivos utilizados, reduzindo assim também, a cada passo, o número de opções para se seguir com a demonstração.\nUtilizando este formalismo, foi possível a formulação do conceito de demonstrações uniformes. Intuitivamente, um sistema de demonstrações é dito uniforme se existe um método único de demonstrações para qualquer seqüente provável. Este conceito facilita enormemente a construção de demonstrações, uma vez que o não-determinismo é reduzido ao máximo, permitindo uma implementação direta do sistema. O ramo de pesquisa que se preocupa com a busca de demonstrações em sistemas lógicos é conhecido como Teoria da Demonstração2.\n1Em inglês: bottom-up 2Em inglês: Proof Theory. Algumas traduções para o português utilizam o termo Teoria da Prova.\n1\n2 CAPÍTULO 1. INTRODUÇÃO\nAtualmente, existe um novo sistema formal conhecido como cálculo das estruturas, proposto por Alessio Guglielmi em 2004, que é, sob alguns aspectos, ainda mais poderoso que o cálculo de seqüentes.\nPara algumas lógicas, ocorre que o problema de como tratar com o não-determinismo deste formalismo a fim de produzir uma interpretação computacional eficiente está ainda engatinhando. Discutir caminhos para encontrar uma estratégia de demonstração para este formalismo é o foco principal deste trabalho."
    }, {
      "heading" : "1.1.2 Motivação",
      "text" : "Desde o surgimento da dedução natural e do cálculo de seqüentes nos anos de 1930, pouco foi feito no sentido de se proporem novos formalismos de representação de regras de inferência. Apenas em 2004 foi proposto um novo sistema de inferência conhecido como cálculo das estruturas [?], que não só revolucionou o conceito de demonstrações, como também permitiu a observação de uma série de simetrias nunca antes apresentadas em sistemas dedutivos.\nUma estrutura é uma expressão intermediária entre um seqüente representado em apenas um lado3 e uma fórmula. Mais precisamente, é uma fórmula lógica comum, módulo uma teoria equacional normalmente imposta aos seqüentes. Na prática, os conectivos desaparecem e as regras são estruturais (em vez de lógicas), no sentido de que elas lidam com a posição relativa de uma subestrutura dentro da estrutura mais geral. As estruturas são o único tipo de expressão permitido, e as regras de inferência são simplesmente regras de reescrita de estruturas. Daí o nome de cálculo das estruturas.\nO cálculo das estruturas apresenta um aspecto único que representa uma grande vantagem sobre os demais sistemas de inferência: a deep-inference. Deep-inference é ummecanismo que permite que, durante a construção de uma demonstração, as regras de inferência possam ser aplicadas tão profundamente quanto se queira dentro da estrutura. Isso quer dizer que, ao contrário do cálculo de seqüentes, por exemplo, não existe um lugar delimitado em cada passo onde se pode trabalhar na construção de uma demonstração (o conectivo principal). No cálculo das estruturas é possível aplicar regras de inferência em qualquer subestrutura da estrutura principal. Esta característica leva a duas conseqüências muito importantes. Emprimeiro lugar, as demonstrações se tornampotencialmentemenores, quando comparadas às demonstrações obtidas com o cálculo de seqüentes. Em contrapartida, devido à liberdade propiciada pela deep-inference, o não-determinismo na construção de uma demonstração se torna muito maior, uma vez que há muitas maneiras em cada passo de se aplicarem regras de inferência.\nO primeiro sistema de cálculo das estruturas proposto, e também o mais simples, é o sistema BV [?], que é o fragmento multiplicativo da lógica linear estendido com a regra mix e um operador auto-dual e não comutativo, o seq. Um fato notável é que BV não pode ser formalizado em cálculo de seqüentes [?]. Então, a pergunta que surge é se todos os sistemas\n3Em inglês: one-sided sequent"
    }, {
      "heading" : "1.1. DEFINIÇÃO DO PROBLEMA 3",
      "text" : "formalizados em cálculo de seqüentes podem ser formalizados em cálculo das estruturas. Para responder a esta pergunta, houve inicialmente um grande interesse em formalizar outras lógicas no cálculo das estruturas. A figura 1.1.2 apresenta um sistema em cálculo das estruturas para lógica clássica, o SKSg.\nS{t}\n[R, R̄] i ↓\nS(R, R̄)\nS{f} i ↑\nS([R,U ], T ) S[(R,T ), U ] s\nS{f} S{R} w ↓\nS{R}\nS{t} w ↑\nS[R,R]\nS{R} c ↓\nS{R}\nS(R,R) c ↑\nFigura 1.1: Sistema SKSg\nAlém lógica clássica [?], outras lógicas já foram formalizadas utilizando o cálculo das\nestruturas como a lógica intuicionista [?], lógica linear [?] e modal [?].\nNão pretendemos aqui trabalhar no sentido de formalizar lógicas. O nosso interesse é em formular ao cálculo das estruturas algo que ainda não tem: um significado computacional. Alguns esforços no sentido de diminuir o não-determinismo do formalismo têm sido empreendidosmas, até hoje, nenhum resultado definitivo, como o conceito de demonstrações uniformes para o cálculo de seqüentes, foi encontrado."
    }, {
      "heading" : "1.1.3 Objetivo",
      "text" : "O objetivo principal do trabalho é:\nDiscutir caminhos possíveis para uma estratégia de busca por demonstrações em cálculo das es-\ntruturas adequada para a implementação computacional. Esta estratégia deve ser, de preferência,\nteórica e não puramente operacional.\nOu seja, desejamos aprofundar o conhecimento existente sobre o cálculo das estruturas no sentido de contribuir para, no futuro, conseguir um resultado similar ao obtido através conceito de demonstrações uniformes para o cálculo de seqüentes."
    }, {
      "heading" : "1.1.4 Contribuição",
      "text" : "O cálculo das estruturas é um formalismo poderoso e vem sendo estendido para diversas lógicas. Embora seu uso permita a construção de demonstrações menores (em comparação com o cálculo de seqüentes), simétricas e elegantes, seu aspecto computacional ainda não\n4 CAPÍTULO 1. INTRODUÇÃO\nfoi discutido a fundo. O não-determinismo na construção de demonstrações por este formalismo ainda é um limitador na sua utilização prática em implementações para computador. Embora algumas tentativas de diminuir este não-determinismo tenham sido empreendidas, elas ainda têm um caráter operacional, e não teórico.\nAs principais contribuições deste trabalho são: (i) apresentar de forma sucinta o cálculo das estruturas em português, assim como uma breve compilação do estado da arte e (ii) propor uma tentativa de estratégia teórica que permita a implementação computacional do cálculo das estruturas para um subconjunto do sistema FBV (flat BV)."
    }, {
      "heading" : "1.2 Revisão da literatura",
      "text" : "O formalismo de cálculo das estruturas (CoS, do inglês Calculus of Structures) foi apresentado por Alessio Guglielmi em 2004 e publicado em 2007 [?]. Neste artigo foi introduzido o sistema lógico BV, que estende o fragmento multiplicativo da lógica linear com a regra mix e um operador dual a si mesmo e não comutativo. Até então não se tinha conseguido realizar esta extensão para o cálculo de seqüentes, mas no cálculo das estruturas ela ocorreu de forma natural. O cálculo das estruturas foi obtido como uma generalização do cálculo de seqüentes de tal forma que existisse uma simetria top down de derivações. No artigo também se discute o conceito de deep-inference presente no CoS, que permite que as regras de inferência sejam aplicadas tão profundamente quanto se queira em uma estrutura, havendo, portanto, muito maior liberdade na construção de uma demonstração. Um resultado importante do artigo é o Teorema de Splitting, que, em linhas gerais, enuncia que derivações complexas podem ser divididas em derivações mais simples e então o resultado dessas subderivações pode ser utilizado na composição da derivação original mais complexa. Este é um resultado importante porque mostra a existência de caminhos alternativos de demonstração para estruturas complicadas, e a quebra em demonstrações mais simples pode reduzir o espaço de busca por derivações. Apesar de ser o artigo seminal em CoS, o trabalho não chegou a abordar os aspectos computacionais do formalismo, no sentido de que não se discutiram maneiras de lidar com o não-determinismo provocado pela deep-inference.\nEste artigo causou um grande movimento na comunidade de Teoria da Demonstração ao redor do mundo, e motivou vários pesquisadores a escrever sistemas baseados em CoS para outras lógicas que não o fragmento da lógica linear coberto pelo sistema BV. Em [?] foram propostos sistemas dedutivos para a lógica clássica proposicional. Como no cálculo de seqüentes, estes sistemas possuem uma regra Cut admissível4. As regras Cut, weakening e contraction são apresentadas em sua forma atômica.\nEmbora já houvesse sistemas de CoS para a lógica linear [?], para a lógica clássica [?], e para várias lógicas modais [?], ainda era um desafio a criação de um sistema assim para a lógica intuicionista. A dificuldade principal se encontrava em criar um conjunto de regras de\n4Uma regra ρ é dita adimissível em um sistema dedutivo se ρ sua ocorrência explícita pode ser retirada do sistema sem afetar a sua completude. Em outras palavras, os conjuntos de fórmulas prováveis em um sistema e no sistema sem ρ explicitamente são idênticos."
    }, {
      "heading" : "1.3. SUMÁRIO DA DISSERTAÇÃO 5",
      "text" : "inferência que não permitisse a demonstrabilidade do princípio do terceiro excluído5. Este problema foi resolvido por Tiu em [?], onde sitemas de inferência baseados em CoS para a lógica intuicionista de primeira ordem e algumas extensões (a lógica intermediária de Dummett - LC, a lógica de Göedel e a lógica clássica) foram propostos. Os sistemas propostos utilizam o conceito de contextos positivos (lado direito de um seqüente) e negativos (lado esquerdo de um seqüente). As regras de inferência são positivas ou negativas e só podem ser aplicadas no contexto adequado (regras positivas para contextos positivos e regras negativas para contextos negativos). Esta necessidade de checagem de contexto para aplicação de regras compromete a noção pura de localidade, mas ainda a preserva no sentido de que as regras são todas atômicas. A demonstração de que a regra Cut é admissível nestes sistemas foi feita de forma indireta, através da equivalência a outros sistemas de inferência. A grande contribuição do trabalho é o pioneirismo na aplicação de CoS para sistemas lógicos assimétricos6.\nEmbora o cálculo das estruturas viesse sendo empregado com sucesso na criação de sistemas de inferência para várias lógicas, o problema de seu não-determinismo conseqüente da deep-inference ainda era uma questão pouco explorada. As demonstrações criadas em sistemas baseados em CoS eram menores que as criadas em sistemas baseados em cálculo de seqüentes,mas o espaço de buscas de demonstrações no primeiro formalismo émuitomaior. Em [?], Kahramanoğullari introduz uma nova técnica que reduz este não-determinismo para o sistema BV, sem quebrar as propriedades teóricas do sistema. Esta técnica propicia um acesso mais imediato a demonstrações menores. No artigo argumenta-se que a técnica, por se basear em aspectos gerais do CoS, pode ser facilmente estendida para outros sistemas que não o BV. Entretanto, a técnica proposta é basicamente operacional, por tratar-se da introdução de regras de inferência que checam previamente se a decisão tomada em um passo da derivação conduzirá a um estado sobre o qual não será mais possível avançar.\nPortanto, o problema teórico de se definir com clareza o comportamento computacional do cálculo das estruturas, assim como o conceito de demonstrações uniformes fez com o cálculo de seqüentes [?], continua em aberto."
    }, {
      "heading" : "1.3 Sumário da dissertação",
      "text" : "O Capítulo 2 apresenta os conceitos fundamentais de Teoria da Demonstração utilizados nesta dissertação, incluindo o conceito de lógica clássica, intuicionista e linear, cálculo de seqüentes e demonstrações uniformes (em cálculo de seqüentes). O Capítulo 3 apresenta o formalismo do cálculo das estruturas, com sua definição formal, o conceito de teias de interação, o teorema de splitting e uma estratégia já proposta na literatura para reduzir seu não-determinismo. O Capítulo 4 contém as principais contribuições desta dissertação: uma\n5O princípio do terceiro excluído afirma que sempre ou uma fórmula é verdadeira, ou então é falsa. Trata-se de um princípio essencialmente não-construtivo, uma vez que não exige a construção de uma demonstração para a fórmula. É um princípio característico da lógica clássica, mas que não é válido para a lógica intuicionista\n6Aqui o termo simetria equivale à presença de negação involutiva e da possibilidade de representação de seqüentes em um só lado.\n6 CAPÍTULO 1. INTRODUÇÃO\ndiscussão sobre as possíveis abordagens para o problema de se encontrar uma estratégia de demonstração em cálculo das estruturas, algumas definições e teoremas importantes e o resultado principal deste trabalho, que consiste numa tentativa de estratégia de demonstração para um subconjunto do sistema FBV. O Capítulo 5 apresenta uma implementação do sistema FBV segundo a tentativa de estratégia proposta nesta dissertação. Por fim, o Capítulo 6 revisa os conceitos apresentados e discute trabalhos futuros."
    }, {
      "heading" : "1.4 Consideração relevante",
      "text" : "Apesar de este trabalho ser uma dissertação na área de teoria da computação, ele possui um caráter prático bastante relevante, uma vez que o interesse da comunidade acadêmica da área está cada vez mais voltado para a implementação eficiente de sistemas dedutivos.\nCapítulo 2\nTeoria da Demonstração: conceitos fundamentais"
    }, {
      "heading" : "2.1 Lógica clássica e sistemas formais",
      "text" : "A lógica clássica lida com a formalização e a análise de tipos de argumentação utilizados em matemática. Desta forma, os sistemas lógicos formais utilizados para esse fim devem ser ferramentas adequadas para demonstraçãor proposições. Parte do problema com a formalização da argumentação matemática é a necessidade de se especificar de maneira precisa uma linguagem matemática formal. Linguagens naturais, tais como o português ou inglês, não servem a este propósito: elas são muito complexas, ambíguas e em constante modificação. Por outro lado, linguagens formais como (algumas) linguagens de programação, que também são rigidamente definidas, são muito mais simples e menos flexíveis que as linguagens naturais. Utilizamos, então, um sistema lógico formal que apresente um balanceamento entre expressividade e precisão, sem, entretanto, apresentar a ambigüidade das linguagens naturais ou ser demasiado simplista como uma linguagem de programação.\nUm sistema lógico formal é composto por três partes: a sintaxe (ou notação), uma especificação cuidadosa de regras de argumentação (regras de inferência), e alguma noção de como interpretar e dar um significado a sentenças (ou proposições) da linguagem adotada (semântica). Apresentaremos rapidamente os conceitos citados acima para a lógica clássica de primeira ordem:\n• Sintaxe\nA sintaxe consiste nos símbolos utilizados na representação do sistema lógico. Na sintaxe há um alfabeto, que é um conjunto de símbolos pré-definidos sobre os quais se pode construir sentenças e uma gramática, que define como as sentenças podem ser construídas.\nA gramática para a lógica clássica de primeira ordem é:\nE ::= A | ⊤ | ⊥ | (E ∧ E) | (E ∨E) | (E ⇒ E) | ∀x.E| ∃x.E\n7"
    }, {
      "heading" : "8 CAPÍTULO 2. TEORIA DA DEMONSTRAÇÃO: CONCEITOS FUNDAMENTAIS",
      "text" : "que significa que uma fórmula E pode ser uma proposição atômica (sem conectivos), verdadeiro, falso, a conjunção de duas fórmulas, a disjunção de duas fórmulas, uma implicação ou fórmulas quantificadas (quantificação de universalidade ou de existência).\nNão acrescentamos a negação como um conectivo primitivo da lógica, mas representamos E ⇒ ⊥ por ¬E. De fato, ao longo do texto utilizaremos uma ou outra representação da maneira que for mais conveniente.\n• Regras de inferência\nAs regras de inferência determinam como se podem obter fórmulas a partir de outras fórmulas, num processo equivalente a tirar conclusões válidas a partir de premissas. Existem diversas formas de se definir regras e axiomas de um sistema lógico formal. Este trabalho tem como foco apenas sistemas apresentados em cálculo de seqüentes e cálculo das estruturas.\nUm exemplo de regra de inferência (em cálculo de seqüentes) é a regra Cut:\nΓ1 ⊢ ∆1, A A,Γ2 ⊢ ∆2 Γ1,Γ2 ⊢ ∆1,∆2 Cut\nBasicamente, essa regra formaliza o conceito de demonstraçõesmatemáticas utilizando lemas auxiliares. Ou seja, se podemos demonstraçãor um lema A (ou outros resultados ∆1) a partir de um conjunto de hipóteses Γ1 e, a partir de A (e possivelmente algumas outras hipóteses Γ2) é possível demonstraçãor outro conjunto de resultados (∆2), então podemos demonstraçãor∆1,∆2 diretamente a partir de Γ1,Γ2.\n• Semântica\nA semântica de um sistema formal dá o significado dos símbolos utilizados. No caso da lógica clássica proposicional (sem quantificadores), o significado das fórmulas pode ser trivialmente expresso através de uma tabela de verdade. Nessa tabela, a cada símbolo é atribuído um valor (V para verdadeiro ou F para falso). A partir desses valores, podemos calcular os valores das fórmulas compostas. Veja a tabela 2.1.\nA B ¬A A ∧B A ∨B A ⇒ B ⊤ ⊥ V V F V V V V F V F F F V V V F F V V F V F V F F F V F F V V F\nTabela 2.1: Tabela de verdade para a lógica clássica proposicional"
    }, {
      "heading" : "2.1. LÓGICA CLÁSSICA E SISTEMAS FORMAIS 9",
      "text" : ""
    }, {
      "heading" : "2.1.1 Cálculo de seqüentes",
      "text" : "O cálculo de seqüentes, introduzido nos anos 1930 por Gerhard Gentzen [?], consiste em um formalismo para tratar da verdade lógica 1 considerando apenas a forma da dedução.\nDefinição 1. Um seqüente possui a forma Γ ⊢ ∆, onde Γ e∆ são multiconjuntos finitos (possivelmente vazios) de fórmulas. Chamamos Γ de antecedente e∆ de sucedente do seqüente.\nUma demonstração para o seqüente Γ ⊢ ∆ é uma árvore finita, construída utilizando as\nregras de inferência do sistema tal que a raiz é Γ ⊢ ∆.\nAs principais características do cálculo de seqüentes são:\n• possui apenas regras de introdução de conectivos lógicos2;\n• antecedentes e sucedentes são tratados da mesma forma e são construídos simultane-\namente;\n• é tecnicamente simples: quando lidas de baixo pra cima, as regras no cálculo de\nseqüentes simplificam o processo de construção de demonstrações, com exceção da regra de contraction (cont) e da regra Cut.\nAs regras do cálculo de seqüentes para a lógica clássica LK estão listadas na Figura 2.1.\nAs regras à direita e à esquerda são chamadas regras lógicas, uma vez que definem o\nsignificado dos conectivos lógicos.\nExemplo 2. Na lógica clássica vale o princípio do terceiro excluído. Ou seja, a proposição\np ∨ ¬p\né sempre válida. Isso significa que uma fórmula é sempre ou verdadeira, ou falsa.\nEssa afirmação é extremamente não construtiva, uma vez que nada se pode dizer de qual\ndas opções é valida.\nA demonstração do princípio do terceiro excluído no sistema LK é dada abaixo.\np ⊢ ⊥, p Initial\n⊢ p,¬p ⇒ R\n⊢ p, p ∨ ¬p ∨R2\n⊢ p ∨ ¬p, p ∨ ¬p ∨R1\n⊢ p ∨ ¬p contR\nChamaremos de C-demonstração qualquer demonstração no sistema LK.\n1A verdade do conhecimento, ou verdade lógica, é a conformidade da inteligência com o que é, isto é, com o objeto.\n2Outro formalismo proposto por Gentzen é a dedução natural, que possui regras de introdução e eliminação de conectivos lógicos."
    }, {
      "heading" : "10 CAPÍTULO 2. TEORIA DA DEMONSTRAÇÃO: CONCEITOS FUNDAMENTAIS",
      "text" : "Axioma inicial e a regra Cut\nΓ, A ⊢ ∆, A Initial\nΓ1 ⊢ ∆1, A A,Γ2 ⊢ ∆2 Γ1,Γ2 ⊢ ∆1,∆2 Cut\nRegras à direita\nΓ ⊢ ⊤,∆ ⊤R\nΓ ⊢ A,∆ Γ ⊢ B,∆\nΓ ⊢ A ∧B,∆ ∧ R\nΓ, A ⊢ B,∆\nΓ ⊢ A ⇒ B,∆ ⇒ R\nΓ ⊢ A,∆\nΓ ⊢ A ∨B,∆ ∨R1\nΓ ⊢ B,∆\nΓ ⊢ A ∨B,∆ ∨R2\nΓ ⊢ A[x/y],∆\nΓ ⊢ ∀xA,∆ ∀R\nΓ ⊢ A[x/t],∆\nΓ ⊢ ∃xA,∆ ∃R\nRegras à esquerda\nΓ,⊥ ⊢ ∆ ⊥L\nΓ, A ⊢ ∆\nΓ, A ∧B ⊢ ∆ ∧ L1\nΓ, B ⊢ ∆\nΓ, A ∧B ⊢ ∆ ∧ L2\nΓ, A ⊢ ∆ Γ, B ⊢ ∆\nΓ, A ∨B ⊢ ∆ ∨ L\nΓ1 ⊢ A,∆1 Γ2, B ⊢ ∆2 Γ1,Γ2, A ⇒ B ⊢ ∆1,∆2 ⇒ L\nΓ, A[x/t] ⊢ ∆\nΓ,∀xA ⊢ ∆ ∀L\nΓ, A[x/y] ⊢ ∆\nΓ,∃xA ⊢ ∆ ∃L\nRegras estruturais Γ ⊢ ∆\nΓ, A ⊢ ∆ weak L\nΓ ⊢ ∆\nΓ ⊢ ∆, A weak R\nΓ, A,A ⊢ ∆\nΓ, A ⊢ ∆ cont L\nΓ ⊢ ∆, A,A\nΓ ⊢ ∆, A cont R\nFigura 2.1: Cálculo de seqüentes para a lógica clássica LK"
    }, {
      "heading" : "2.2 Lógica intuicionista",
      "text" : "Como descrito na Seção 2.1, o entendimento clássico de lógica é baseado na noção de verdade. Ou seja, a veracidade de uma afirmativa é “absoluta” e independente de qualquer argumentação, crença ou ação.\nDesta forma, afirmativas são ou verdadeiras ou falsas, onde falso é a mesma coisa que\nnão verdadeiro. De fato, é fácil demonstraçãor em LK as seguintes equivalências:\n⊤ ≡ ⊥ ⇒ ⊥\ne\n⊥ ≡ ⊤ ⇒ ⊥\n,\nonde ≡ é o símbolo de relação de equivalência entre fórmulas.\nClaro que essa abordagem de pensamento é muito intuitiva e baseada em experiência e"
    }, {
      "heading" : "2.2. LÓGICA INTUICIONISTA 11",
      "text" : "observação. Para ummatemático preocupado em demonstraçãor um teorema, é importante a idéia de que toda afirmativa pode ser demonstraçãoda verdadeira se uma demonstração é apresentada ou falsa se existe um contra-exemplo. Além disso, várias técnicas de demonstração utilizam implicitamente o princpípio do terceiro excluído.\nA lógica intuicionista abandona a idéia de verdade absoluta, e afirmativas são conside-\nradas válidas se, e somente se, existe uma demonstração construtiva das mesmas.\nEm cálculo de seqüentes, o sistema de demonstraçõesmais conhecido para a lógica intuicionista é o sistema LJ, onde os seqüentes válidos possuem exatamente uma fórmula como sucedente e as regras de weakening e contraction não são válidas à direita. O sistema LJ é apresentado na Figura 2.2.\nΓ, A ⊢ A Initial\nΓ1 ⊢ A A,Γ2 ⊢ C\nΓ1,Γ2 ⊢ C Cut\nΓ ⊢ ⊤ ⊤R\nΓ ⊢ A Γ ⊢ B\nΓ ⊢ A ∧B ∧ R\nΓ, A ⊢ B\nΓ ⊢ A ⇒ B ⇒ R\nΓ ⊢ A\nΓ ⊢ A ∨B ∨R1\nΓ ⊢ B\nΓ ⊢ A ∨B ∨R2\nΓ ⊢ A[x/y]\nΓ ⊢ ∀xA ∀R\nΓ ⊢ A[x/t]\nΓ ⊢ ∃xA ∃R\nΓ,⊥ ⊢ A ⊥L\nΓ, A ⊢ C\nΓ, A ∧B ⊢ C ∧ L1\nΓ, B ⊢ C\nΓ, A ∧B ⊢ C ∧ L2\nΓ, A ⊢ C Γ, B ⊢ C\nΓ, A ∨B ⊢ C ∨ L\nΓ1 ⊢ A Γ2, B ⊢ C Γ1,Γ2, A ⇒ B ⊢ C ⇒ L\nΓ, A[x/t] ⊢ C\nΓ,∀xA ⊢ C ∀L\nΓ, A[x/y] ⊢ C\nΓ,∃xA ⊢ C ∃L\nΓ ⊢ C\nΓ, A ⊢ C weak L\nΓ, A,A ⊢ C\nΓ, A ⊢ C cont L\nFigura 2.2: Cálculo de seqüentes para a lógica intuicionista LJ\nExemplo 3. Todos os seqüentes abaixo são prováveis em lógica clássica:\n1. ¬(p ∨ q) ⊢ (¬p ∧ ¬q)\n2. (p ∨ q) ⊢ ¬(¬p ∧ ¬q)\n3. (p ∨ q) ⊢ (¬p ⇒ q)\n4. ¬(p ∧ q) ⊢ (¬p ∨ ¬q)\n5. ((p ⇒ q) ⇒ p) ⊢ p\n6. ⊢ (p ⇒ q) ∨ (q ⇒ p)\nMas apenas (1), (2) e (3) apresentam demonstrações construtivas, isto é, são prováveis intuicionisticamente."
    }, {
      "heading" : "12 CAPÍTULO 2. TEORIA DA DEMONSTRAÇÃO: CONCEITOS FUNDAMENTAIS",
      "text" : "Chamaremos de I-demonstração qualquer demonstração no sistema LJ."
    }, {
      "heading" : "2.3 Lógica linear",
      "text" : "Na lógica clássica (seção 2.1), matemáticos começam de um conjunto de axiomas, demonstraçãom alguns lemas e então os utilizam para demonstraçãor teoremas. Algumas das demonstrações utilizadas não são construtivas, e o uso da estratégia conhecida como redução ao absurdo é muito comum.\nUma vez que um lema é demonstraçãodo, ele pode ser usado de novo para demonstraçãor outras proposições ou teoremas, uma vez que um lema demonstraçãodo verdadeiro será verdadeiro para sempre. Portanto, matemáticos trabalham com a lógica clássica, a lógica da verdade estável e de recursos e conclusões infinitos.\nJá a lógica intuicionista (Seção 2.2) descarta essa noção de verdade absoluta e a veracidade de uma afirmativa depende da existência de uma demonstração (ou construção) da afirmativa. Alguns matemáticos preferem a lógica intuicionista à clássica, justamente por acreditarem na importância de se construir uma demonstração, em vez de se contentar em apenas saber que ela existe. A lógica intuicionista ainda é muito utilizada em ciência da computação, sendo a base de linguagens de programação como Prolog. Mas a lógica intuicionista ainda é uma lógica de infinitos recursos – mas não infinitas conclusões, uma vez que permitir a demonstração de todos os resultados possíveis em lógica clássica implicaria em permitir o princípio do terceiro excluído.\nA lógica linear (desenvolvida por Girard [?]) é uma lógica de recursos conscientes. É, portanto, um refinamento das lógicas clássica e intuicionista, no sentido que substitui a ênfase em verdade ou em demonstraçãobilidade por recursos.\nEm lógica linear, afirmativas não podem ser livremente copiadas (contraction) ou descartadas (weakening), apenas em situações especiais, onde aparece um tipo muito particular de conectivos: os exponenciais “?” e “!”. Intuitivamente, !B significa que o recurso B pode ser usado tantas vezes quanto necessárias. De maneira dual, ?B indica a possibilidade de produção de uma quantidade infinita da conclusão B.\nA implicação linear é representada pelo símbolo “−◦” e o significado de A−◦B é:\nconsome-se A dando origem a B\nIsto significa que, a partir do ponto em que B é produzido, o predicado A deixa de ser válido. A implicação intuicionista “⇒” então significa:\nA ⇒ B ≡ !A−◦B\nou seja, um predicado A implica B intuicionisticamente se e somente se existe uma quantidade infinita de A que linearmente implica B.\nA ausência de contraction e weakening muda a natureza dos conectivos lógicos. De fato, poderíamos propor uma variante das regras do sistema LK, considerando as regras para a\n2.3. LÓGICA LINEAR 13\nconjunção como:\nΓ, A,B ⊢ ∆\nΓ, A ∧B ⊢ ∆ ∧L ′\nΓ1 ⊢ A,∆1 Γ2 ⊢ B,∆2 Γ1,Γ2 ⊢ A ∧B,∆1,∆2 ∧R′\nAs regras acima são chamadas de multiplicativas, enquanto que as regras apresentadas na Figura 2.1 são chamadas de aditivas. Ocorre que, na presença das regras cont e weak, esses dois formatos são equivalentes. De fato, se supusermos a regra ∧R, podemos derivar a regra ∧R′: Γ1 ⊢ A,∆1\nΓ1,Γ2 ⊢ A,∆1,∆2 weak R,weak L Γ2 ⊢ B,∆2 Γ1,Γ2 ⊢ B,∆1,∆2 weak R,weak L\nΓ1,Γ2 ⊢ A ∧B,∆1,∆2 ∧R\ne vice versa: Γ ⊢ A,∆ Γ ⊢ B,∆\nΓ,Γ ⊢ A ∧B,∆,∆ ∧R ′\nΓ ⊢ A ∧B,∆ contR, contL\nSe removermos contraction e weakening, então as regras não são mais equivalentes, e a conjunção (assim como a disjunção) é separada emdois conectivos diferentes. Portanto, existem duas maneiras distintas de formular a conjunção, correspondendo a dois conectivos distintos em lógica linear: o conectivo multiplicativo “⊗” (A⊗B significa ambosA eB) e o aditivo “&” (A&B = escolha entre A e B). O mesmo para a disjunção: multiplicativo “O” (AOB é igual a A paralelo a B) e aditivo “⊕” (A⊕B significa ou A ou B).\nA lógica linear utiliza ainda os seguintes conectivos: ⊥, e 1 para a versão multiplicativa de falso e verdadeiro respectivamente; 0, ⊤ para a versão aditiva desses conectivos; e ∀ e ∃ para quantificações universal e existencial.\nNa Figura 2.3 apresentamos as regras de inferência para a lógica linear.\n2.3.1 MLL: fragmento multiplicativo da lógica linear\nObserve que as regras da Figura 2.3 apresentam uma simetria fantástica. De fato, a regra à direita para o conectivo O possui o mesmo formato da regra à esquerda para o conectivo ⊗. O mesmo ocorre com os conectivos & e ⊕. Este fato, juntamente com o fato de que, na lógica linear, a negação é involutiva3 permitem a representação da lógica linear através de seqüentes que possuem apenas o sucedente. Desta forma, os conectivos possuem apenas regras à direita.\nNa Figura 2.4 apresentamos as regras utilizando o cálculo de seqüentes de um lado só4 para MLL, que é o fragmento da lógica linear contendo apenas os conectivos multiplicativos.\nTal sistema será importante para a definição do sistema BV, no Capítulo3.1.\n3A negação é dita involutiva se ¬¬A ≡ A. 4Em inglês: one sided sequent calculus"
    }, {
      "heading" : "14 CAPÍTULO 2. TEORIA DA DEMONSTRAÇÃO: CONCEITOS FUNDAMENTAIS",
      "text" : "A ⊢ A Initial\nΓ1 ⊢ ∆1, A A,Γ2 ⊢ ∆2 Γ1,Γ2 ⊢ ∆1,∆2 Cut\nΓ1 ⊢ ∆1, !A (!A) n,Γ2 ⊢ ∆2\nΓ1,Γ2 ⊢ ∆1,∆2 Cut!\nΓ1 ⊢ ∆1, (?A) n ?A,Γ2 ⊢ ∆2\nΓ1,Γ2 ⊢ ∆1,∆2 Cut? n > 1\nRegras à direita\nΓ ⊢ ⊤,∆ ⊤R\nΓ ⊢ ∆\nΓ ⊢⊥,∆ ⊥ R\n⊢ 1 1R\nΓ ⊢ A,∆ Γ ⊢ B,∆\nΓ ⊢ A&B,∆ & R\nΓ ⊢ A,B,∆ Γ ⊢ AOB,∆ OR\nΓ ⊢ A,∆\nΓ ⊢ A⊕B,∆ ⊕ R\nΓ ⊢ B,∆\nΓ ⊢ A⊕B,∆ ⊕ R\nΓ1 ⊢ A,∆1 Γ2 ⊢ B,∆2 Γ1,Γ2 ⊢ A⊗B,∆1,∆2 ⊗ R Γ, A ⊢ B,∆ Γ ⊢ A−◦B,∆ −◦ R\nΓ ⊢ A[x/y],∆\nΓ ⊢ ∀lxA,∆ ∀lR\nΓ ⊢ A[x/t],∆\nΓ ⊢ ∃lxA,∆ ∃lR\nRegras à esquerda\n0,Γ ⊢ ∆ 0L\n⊥⊢ ⊥ L\nΓ ⊢ ∆\n1,Γ ⊢ ∆ 1L\nΓ, A ⊢ ∆\nΓ, A&B ⊢ ∆ & L\nΓ, B ⊢ ∆\nΓ, A&B ⊢ ∆ & L\nΓ, A ⊢ ∆ Γ, B ⊢ ∆\nΓ, A⊕B ⊢ ∆ ⊕ L\nΓ1, A ⊢ ∆1 Γ2, B ⊢ ∆2 Γ1,Γ2, AOB ⊢ ∆1,∆2 OL\nΓ, A,B ⊢ ∆\nΓ, A⊗B ⊢ ∆ ⊗ L\nΓ1 ⊢ A,∆1 Γ2, B ⊢ ∆2 Γ1,Γ2, A−◦B ⊢ ∆1,∆2 −◦ L\nΓ, A[x/t] ⊢ ∆\nΓ,∀lxA ⊢ ∆ ∀lL\nΓ, A[x/y] ⊢ ∆\nΓ,∃lxA ⊢ ∆ ∃lL\nRegras para os exponenciais\nΓ ⊢ ∆\nΓ, !A ⊢ ∆ !W\nΓ, A ⊢ ∆\nΓ, !A ⊢ ∆ !D\n! Γ ⊢ A, ?∆\n!Γ ⊢ !A, ?∆ !R\nΓ, !A, !A ⊢ ∆\nΓ, !A ⊢ ∆ !C\nΓ ⊢ ∆\nΓ ⊢ ?A,∆ ?W\n! Γ, A ⊢ ?∆\n! Γ, ?A ⊢ ?∆ ?L\nΓ ⊢ A,∆\nΓ ⊢ ?A,∆ ?D\nΓ ⊢ ?A, ?A,∆\nΓ ⊢ ?A,∆ ?C\nFigura 2.3: Cálculo de seqüentes para a lógica linear clássica LL\n⊢ A,¬A Initial\n⊢ Γ1, A ⊢ ¬A,Γ2 ⊢ Γ1,Γ2 Cut\n⊢ Γ, A,B ⊢ Γ, AOB O\n⊢ Γ1, A ⊢ Γ2, B\n⊢ Γ1,Γ2, A⊗B ⊗\nFigura 2.4: Cálculo de seqüentes de um lado só para a lógica linear multiplicativa MLL\n2.4. REGRA MIX 15\n2.4 Regra mix\nOutra regra que vai ser de fundamental importância na Seção 3.1.4 é a regra mix:\n⊢ Γ ⊢ ∆ ⊢ Γ,∆ mix\nTal regra se parece com a regra Cut, a diferença está no fato de que nenhuma fórmula é eliminada, elas são na verdade todas “misturadas”. A presença da regra mix muda completamente a demonstraçãobilidade de um sistema lógico. Por exemplo, em MLL + mix é possível demonstraçãor o seqüente ⊢ AOB,¬AO¬B (que em cálculo de seqüentes de dois lados corresponde a A⊗B ⊢ AOB):\n⊢ A,¬A Initial ⊢ B,¬B Initial\n⊢ A,B,¬A,¬B mix ⊢ A,B,¬AO¬B O ⊢ AOB,¬AO¬B O\nObserve que, em lógica linear, a demonstração poderia ser construída de baixo para cima apenas até o seqüente ⊢ A,B,¬A,¬B. Este seqüente não é provável, pois não há nenhuma regra de inferência que possa ser aplicada, e, além disso, o axioma inical não pode ser empregado (em lógica linear o axioma inicial é relevante, no sentido de que só admite uma única fórmula e sua negação). Porém, com a regra mix, podem-se separar as fórmulas de modo que o axioma inicial se aplique, e o seqüente passa a ser provável.\nEm resumo, a regra mix estende o conjunto de seqüentes prováveis em MLL , uma vez\nque permite a simulação de um axioma inical do tipo:\n⊢ A1,¬A1, . . . , Ah,¬An Initial′"
    }, {
      "heading" : "2.5 Demonstrações uniformes",
      "text" : "Considere o seqüente A ∨ B ⊢ B ∨ A. Tal seqüente é sabidamente demonstrável em lógica clássica e em lógica intuicionista, por exemplo, uma vez que ele corresponde à demonstração de que a disjunção é comutativa.\nA princípio, poderia-se pensar que seria uma tarefa simples demonstraçãor tal seqüente. Entretanto, observe que se decidirmos começar a demonstração eliminando a disjunção da direita\nA ∨B ⊢ B A ∨B ⊢ B ∨A ∨R1 ou A ∨B ⊢ A A ∨B ⊢ B ∨A ∨R2\ntemos necessariamente que fazer primeiro a escolha de qual fórmula demonstraçãor (A ou B), para depois proceder com a demonstração.\nEntretanto, os seqüentes das premissas de ambas derivações não são prováveis: a única"
    }, {
      "heading" : "16 CAPÍTULO 2. TEORIA DA DEMONSTRAÇÃO: CONCEITOS FUNDAMENTAIS",
      "text" : "regra aplicável é∨L,weak L ou cont L, e nenhuma delas conduz a uma demonstração. Desta forma, devemos obrigatoriamente adiar a escolha, o que significa, na lógica intuicionista, que devemos começar a redução pela disjunção da esquerda.\nA ⊢ A Initial\nA ⊢ B ∨A ∨R2\nB ⊢ B Initial\nB ⊢ B ∨A ∨R1\nA ∨B ⊢ B ∨A ∨L\nEssa é uma situação que se deseja evitar na prática, se estamos preocupados com a automatização completa de sistemas lógicos: a implementação teria que tentar todas as possibilidades até decidir o caminho certo, o que tornaria o tempo de execução exponencial, no pior caso. Desta forma, é importante saber quando um sistema lógico possui uma estratégia de redução. Ou seja, um caminho único e bem determinado para se demonstraçãor um seqüente qualquer.\nAinda analisando o seqüente A ∨ B ⊢ B ∨ A, vemos que, no sistema LK, existe ainda\noutra possibilidade de demonstração, duplicando a fórmula da direita:\nA ⊢ B,A Initial B ⊢ B,A Initial\nA ∨B ⊢ B,A ∨L\nA ∨B ⊢ B,B ∨A ∨R2\nA ∨B ⊢ B ∨A,B ∨A ∨R1\nA ∨B ⊢ B ∨A contR\nTal derivação segue a estratégia de começar a demonstração pelo lado direito do seqüente, mas não pode ser chamada de uma estratégia de redução. Isto porque, ao duplicar a fórmula B ∨ A, estamos na verdade aumentando o número de fórmulas no seqüente, em vez de diminuir.\nDe fato, quando derivações são analisadas de baixo para cima, as regras estruturais de contração da Figura 2.1 podem sempre ser aplicadas, duplicando fórmulas e, consequentemente, aplicação de regras de inferência. Outra regra que pode sempre ser aplicada é a regra Cut, que “cria” uma fórmula na derivação. Este é um problema extremamente sério, uma vez que o processo de criação requer a presença de inteligência, que um programa de computador não possui. Um problema semelhante ocorre com as regras ∀L e ∃R, pois a aplicação de tais regras requer que se saiba, a priori, o termo t que deve ser usado como instância.\nClaro que tais dificuldades podem ser superadas parcialmente. Por exemplo, as regras estruturais podem vir implícitas em algumas regras (dando origem ao sistema G3c – veja a Figura 2.5), a regra Cut pode ser eliminada [?] nas lógicas clássica, intuicionista e linear e o problema com a aplicação de regras para os quantificadores pode ser parcialmente resolvido utilizando unificação [?].\nSubstituir o sistema LK pelo sistema G3c pode resolver alguns problemas relativos à\nimplementação da lógica clássica, mas introduz outros."
    }, {
      "heading" : "2.5. DEMONSTRAÇÕES UNIFORMES 17",
      "text" : "Γ, A ⊢ ∆, A Initial\nΓ ⊢ ⊤,∆ ⊤ R\nΓ ⊢ A,∆ Γ ⊢ B,∆\nΓ ⊢ A ∧B,∆ ∧R\nΓ, A ⊢ B,∆\nΓ ⊢ A ⇒ B,∆ ⇒ R\nΓ ⊢ A,B,∆\nΓ ⊢ A ∨B,∆ ∨R\nΓ ⊢ A[x/y],∆\nΓ ⊢ ∀xA,∆ ∀R\nΓ ⊢ ∃xA,A[x/t],∆\nΓ ⊢ ∃xA,∆ ∃R\nΓ,⊥ ⊢ ∆ ⊥ L\nΓ, A,B ⊢ ∆\nΓ, A ∧B ⊢ ∆ ∧L\nΓ, A ⊢ ∆ Γ, B ⊢ ∆\nΓ, A ∨B ⊢ ∆ ∨L\nΓ ⊢ A,∆ Γ, B ⊢ ∆\nΓ, A ⇒ B ⊢ ∆ ⇒ L\nΓ, A[x/t],∀xA ⊢ ∆\nΓ,∀xA ⊢ ∆ ∀L\nΓ, A[x/y] ⊢ ∆\nΓ,∃xA ⊢ ∆ ∃L\nFigura 2.5: Sistema G3c para a lógica clássica de primeira ordem\nExemplo 4. O seqüente p(a) ∨ p(b) ⊢ ∃x.p(x) é provável em lógica clássica. No sistema LK, uma possibilidade de demonstração é começando pelo antecedente:\np(a) ⊢ p(a) Initial\np(a) ⊢ ∃x.p(x) ∃R\np(b) ⊢ p(b) Initial p(b) ⊢ ∃x.p(x) (∃R)\np(a) ∨ p(b) ⊢ ∃x.p(x) ∨L\nClaro que podemos sempre começar pela contração da fórmula quantificada, desta forma\ncomeçando pelo sucedente. Em G3c, a demonstração correspondente seria:\np(a) ⊢ ∃x.p(x), p(a), p(b) Initial p(b) ⊢ ∃x.p(x), p(a), p(b) Initial\np(a) ∨ p(b) ⊢ ∃x.p(x), p(a), p(b) ∨L\np(a) ∨ p(b) ⊢ ∃x.p(x), p(a) ∃R\np(a) ∨ p(b) ⊢ ∃x.p(x) ∃R\nO problema que surge é que a aplicação de ∃R gera a duplicação da fórmula ∃x.p(x) o que, na prática, cria um problema de implementação. Como a regra pode ser aplicada indefinidamente, torna-se mais complicado controlar o seu uso, evitando que o programa entre em loop.\nOutros problemas podem surgir com a procura por demonstrações em seqüentes que contenham mais de uma fórmula no sucedente. O principal, no caso da lógica clássica, é o de scope extrusion. Para entender o que significa este conceito, considere o seqüente"
    }, {
      "heading" : "18 CAPÍTULO 2. TEORIA DA DEMONSTRAÇÃO: CONCEITOS FUNDAMENTAIS",
      "text" : "Γ ⊢ D ⇒ G. Tal seqüente é provável se e somente se Γ,D ⊢ G é provável5. Fazendo a relação entre lógica e programação, a fórmula D pode ser vista como uma unidade de programa que é adicionada ao programa Γ durante a computação 6. Para garantir que tal procedimento irá obedecer a noção correta de escopo (ou seja, que as ações emD terão reflexo apenas sobre G), precisamos de um cálculo que permita apenas uma fórmula no sucedente.\nDe fato, se G = G1 ∨ (D ⇒ G2), uma redução no sistema LJ começando pelo sucedente resultaria em uma busca por demonstrações de um dos seqüentes: Γ ⊢ G1 ou Γ,D ⊢ G2. Em particular, a fórmulaD está disponível apenas para demonstraçãor a fórmulaG2. Entretanto, a fórmulaG1∨(D ⇒ G2) é classicamente equivalente a (D ⇒ G1)∨G2 eD ⇒ (G1∨G2). Em particular, p ∨ (p ⇒ q) não possui uma I-demonstração, mas possui uma C-demonstração. De fato, observe que na demonstração abaixo o “módulo” (a fórmula p) é utilizado para demonstraçãor um programa que não está no seu escopo:\np ⊢ p, q (Initial)\n⊢ p, (p ⇒ q) ⇒ R\n⊢ p ∨ (p ⇒ q) ∨R\nPor este motivo, para determinar uma estratégia de redução bem definida, que suporte esta noção de programação modular com uma disciplina correta para escopo, é necessário, no presente momento, restringir as demonstrações para I-demonstrações. Iremos generalizar tal conceito para o caso da lógica linear, em 2.5.2.\nEm [?] foi apresentada uma fundamentação teórica para caracterizar lógicas como linguagens abstratas de programação. Tal fundamentação é baseada no conceito de demonstrações uniformes, restrito ao caso de I-demonstrações.\nDefinição 5. Uma I-demonstração livre da regra Cut7 Ξ é uniforme se para toda subdemonstração Ξ′ de Ξ e para toda ocorrência de uma fórmula não atômica B no lado direito de um sequente em Ξ′, existe uma demonstração Ξ′′ que é igual a Ξ′ a menos de permutação de regras de inferência e tal que a última regra de inferência de Ξ′′ introduz o conectivo principal de B.\nEm outras palavras:\numa demonstração uniforme pode ser construída utilizando um algoritmo determinístico.\nDesta forma, a estratégia de redução é baseada em busca direcionada por objetivo8. Ou seja, o seqüente P ⊢ G denota um estado de um interpretador, onde P denota um programa e G o objetivo que queremos demonstraçãor a partir de P. Além disso, uma demonstração de tal seqüente representa uma seqüência de transições de estado determinadas pelo interpretador, que deve necessariamente reduzir o conectivo principal da fórmula G, caso exista. 5A regra (⇒ R) é inversível, veja [?]. 6Ou seja, modularização. 7Em inglês: cut-free proof 8Em inglês, goal-directed search."
    }, {
      "heading" : "2.5. DEMONSTRAÇÕES UNIFORMES 19",
      "text" : "Com esta estratégia, podemos definir linguagens lógicas de programação:\nDefinição 6. Uma lógica com um sistema de demonstrações baseado em cálculo de seqüentes é uma linguagem lógica de programação abstrata se, restrita a demonstrações uniformes, não perde a completude 9.\nPelos exemplos apresentados anteriormente, vimos que as lógicas clássica e intuicionista não são linguagens lógicas de programação, uma vez que há seqüentes que são prováveis, mas não há uma demonstração uniforme para eles, como A ∨B ⊢ B veeA.\nPara obter completude de linguagens lógicas de programação, devemos ou restingir a gramática e as fórmulas que podem ser inseridas nos antecedentes e sucedentes, ou escolher a lógica base com muito cuidado. No que se segue, faremos ambos."
    }, {
      "heading" : "2.5.1 Cláusulas de Horn e fórmulas de Harrop",
      "text" : "Comecemos por limitar a gramática da lógica de primeira ordem. Pelos exemplos que vimos anteriormente, fica claro que a disjunção e o quantificador existencial, quando presentes no sucedente, trazem sérios problemas para uniformidade.\nBaseado nessa observação nasceu o Prolog, baseado em Cláusulas de Horn:\nG ::= A|(G ∧G)\nD ::= A|G ⇒ A|∀x.D\nonde G é o objetivo e D é o programa. Objetivos (sucedentes) são conjunções de fórmulas atômicas e programas (antecedentes) possuem a forma\n∀x1 . . . xm[A1 ∧ . . . ∧An ⇒ A0]\ncom m,n ≥ 0.\nPode-se observar que, restrito às cláusulas deHorn, I-demonstrações e C-demonstrações\ncoincidem.\nEntretanto, as cláusulas de Horn dão origem a um sistema lógico muito fraco, que não\ncomporta, por exemplo, modularização ou mecanismos de abstração de dados.\nCom esta motivação, em [?] as Cláusulas de Horn foram generalizadas para fórmulas de\nHarrop10:\nG ::= A|(G ∧G)|D ⇒ G|∀x.G\nD ::= A|G ⇒ A|∀x.D\nNasceu assim a linguagem de programação λ-Prolog [?]. Não há meio de estendermais a gramática de modo a obter um subconjunto da lógica de primeira ordem que seja uniforme e completo. Ou seja, a gramática acima é maximal. Desta\n9Neste contexo, entende-se que não perder a completude signifca que o conjunto de fórmulas prováveis continua sendo exatamente o mesmo\n10Em inglês, hereditary Harrop formulas."
    }, {
      "heading" : "20 CAPÍTULO 2. TEORIA DA DEMONSTRAÇÃO: CONCEITOS FUNDAMENTAIS",
      "text" : "forma, a única possibilidade de obtermos maior expressividade, ou seja, a demonstrabilidade de fórmulas mais interessantes, é mudando o sistema lógico."
    }, {
      "heading" : "2.5.2 demonstrações uniformes em lógica linear",
      "text" : "É fácil ver que a lógica linear clássica, com regras de inferência apresentadas no sistema LL, não é, segundo a Definição 5, uma linguagem lógica de programação. Por exemplo, os seqüentes a⊗ b ⊢ b⊗ a\n! a ⊢ ! a⊗ ! a\n! a& b ⊢ ! a\nb⊗ (b−◦ ! a) ⊢ ! a\n1 ⊢ 1\nsão prováveis em LL mas não possuem demonstrações uniformes11.\nUma alternativa seria restringir a lógica linear de modo a não permitir os conectivos ⊕, ! e 1 no sucedente, restrição parecida com a que foi feita na lógica de primeira ordem. Mas isso resultaria em uma lógica muito restrita, e a linguagem que obteríamos não seria tão mais interessante que λ-Prolog.\nOcorre que não há necessidade de restringir a lógica linear pois ela é, completa 12, uma linguagem lógica de programação. Basta que tomemos o cuidado de apresentar suas regras de inferênciamaneira adequada a este objetivo.\nDe fato, os conectivos da lógica linear podem ser classificados em síncronos e assíncronos [?], dependendo de se a regra de introdução à direita para aquele conectivo depende ou não do seu contexto. O dual De Morgan de um conectivo em uma dessas classes é um conectivo na outra classe.\nDada essa divisão de conectivos, Miller propôs em [?] a presentação Forum de lógica linear na qual fórmulas são construídas utilizando apenas os conectivos assíncronos, a saber: ?, O, ⊥, &, ⊤, −◦ e ∀, junto com a versão intuicionista da implicação B ⇒ C .13 Os conectivos síncronos da lógica linear estão disponíveis implicitamente, uma vez que conectivos que aparecem no antecedente do seqüente de cada regra comportam-se de modo síncrono. Como a negação em lógica linear é involutiva, podemos usar este fato para simluar os conectivos sícronos, o que faz de Forum um sistema completo para a lógica linear.\nO fato impressionante é que Forum é uma linguagem lógica de programação, uma vez que a busca por demonstrações em seqüentes com conectivos assíncronos no sucedente corresponde à busca dirigida por objetivo, ao mesmo tempo que conectivos assíncronos no antecedente correspondem ao procedimento de backchaining sobre cláusulas de programas [?].\nO sistema de demonstrações de Forum é apresentado na Figura 2.6. Seqüentes emForumpossuemuma das formasΣ: Ψ;∆ −→ Γ;Υ e Σ: Ψ;∆ B−→ Γ;Υ, onde Σ é uma assinatura,∆ e Γ são multiconjuntos de fórmulas, Ψ e Υ são conjuntos de fór-\n11O problema é que as regras (1R), (⊗R) e (!R) não permutam com regras à esquerda. 12Ou seja, não estamos lidando com fragmentos, mas com a lógica inteira. 13Utilizamos aqui o símbolo ⇒ ao invés de ⊃ para a implicação intuicionista para seguir a notação em [?]."
    }, {
      "heading" : "2.5. DEMONSTRAÇÕES UNIFORMES 21",
      "text" : "Σ: Ψ;∆ −→ ⊤,Γ;Υ ⊤R\nΣ: Ψ;∆ −→ B,Γ;Υ Σ: Ψ;∆ −→ C,Γ;Υ\nΣ: Ψ;∆ −→ B & C,Γ;Υ & R\nΣ: Ψ;∆ −→ Γ;Υ\nΣ: Ψ;∆ −→ ⊥,Γ;Υ ⊥R\nΣ: Ψ;∆ −→ B,C,Γ;Υ Σ: Ψ;∆ −→ BOC,Γ;Υ OR\nΣ: Ψ;B,∆ −→ C,Γ;Υ\nΣ: Ψ;∆ −→ B −◦ C,Γ;Υ −◦ R\nΣ: B,Ψ;∆ −→ C,Γ;Υ\nΣ: Ψ;∆ −→ B ⇒ C,Γ;Υ ⇒ R\ny : τ,Σ: Ψ;∆ −→ B[y/x],Γ;Υ\nΣ: Ψ;∆ −→ ∀τx.B,Γ;Υ ∀R\nΣ: Ψ;∆ −→ Γ;B,Υ\nΣ: Ψ;∆ −→ ?B,Γ;Υ ?R\nΣ: B,Ψ;∆ B −→ A; Υ Σ: B,Ψ;∆ −→ A; Υ decide !\nΣ: Ψ;∆ −→ A, B;B,Υ\nΣ: Ψ;∆ −→ A;B,Υ decide ?\nΣ: Ψ;∆ B −→ A; Υ\nΣ: Ψ;B,∆ −→ A; Υ decide\nΣ: Ψ; · A −→ A; Υ initial Σ: Ψ; · A −→ ·;A,Υ initial ?\nΣ: Ψ; · ⊥ −→ ·; Υ ⊥L\nΣ: Ψ;∆ Bi−→ A; Υ\nΣ: Ψ;∆ B1&B2−→ A; Υ\n& Li Σ: Ψ;B −→ ·; Υ\nΣ: Ψ; · ?B −→ ·; Υ\n?L\nΣ: Ψ;∆1 B −→ A1; Υ Σ: Ψ;∆2 C −→ A2; Υ\nΣ: Ψ;∆1,∆2 BOC −→ A1,A2; Υ\nOL Σ: Ψ;∆\nB[t/x] −→ A; Υ\nΣ: Ψ;∆ ∀τx.B−→ A; Υ\n∀L\nΣ: Ψ;∆1 −→ A1, B; Υ Σ: Ψ;∆2 C −→ A2; Υ\nΣ: Ψ;∆1,∆2 B−◦C −→ A1,A2; Υ\n−◦ L\nΣ: Ψ; · −→ B; Υ Σ: Ψ;∆ C −→ A; Υ\nΣ: Ψ;∆ B⇒C −→ A; Υ\n⇒ L\nFigura 2.6: Sistema de demonstrações de Forum\nmulas, e B é uma fórmula. Todas as fórmulas nos seqüentes são compostas dos conectivos assíncronos listados anteriormente (juntamente com ⇒). Os significados de tais seqüentes em lógica linear são ! Ψ,∆ ⊢ Γ, ?Υ e ! Ψ,∆, B ⊢ Γ, ?Υ, respectivamente.\nNo sistema de demonstrações da Figura 2.6, as regras à direita atuam apenas sobre seqüentes da forma Σ: Ψ;∆ −→ Γ;Υ. A variável sintática A na Figura 2.6 denota um multiconjunto de fórmulas atômicas. Regras à esquerda são aplicadas apenas à fórmula B, que é o label de Σ: Ψ;∆ B−→ A; Υ.\nO conceito de demonstrações uniformes foi então generalizado em [?] para seqüentes\ncom mais de uma fórmula no sucedente.\nDefinição 7. Uma demonstração livre da regra Cut Ξ é uniforme se para toda subdemonstração Ξ′ de Ξ e para toda ocorrência de uma fórmula não atômica B no lado direito de um sequente em Ξ′, existe uma demonstração Ξ′′que é igual a Ξ′ a menos de uma permutação"
    }, {
      "heading" : "22 CAPÍTULO 2. TEORIA DA DEMONSTRAÇÃO: CONCEITOS FUNDAMENTAIS",
      "text" : "de regras de inferência e tal que a última regra de inferência de Ξ′′ introduz o conectivo principal de B.\nA busca por demonstrações em Forum é uniforme. De fato, podemos sempre começar pelo sucedente, passando ao antecedente somente quando temos apenas átomos do lado direito do seqüente.\nCapítulo 3\nCálculo das estruturas"
    }, {
      "heading" : "3.1 O Cálculo das estruturas",
      "text" : ""
    }, {
      "heading" : "3.1.1 Visão geral",
      "text" : "O cálculo das estruturas é um formalismo proposto por Alessio Guglielmi [?] que generaliza o cálculo de seqüentes de tal forma que uma nova simetria vertical (top-down) é observada nas derivações. Além disso, este formalismo emprega regras de reescrita que podem ser aplicadas dentro da estrutura em qualquer profundidade.\nUma das motivações para a invenção do cálculo das estruturas foi a dificuldade em se expressar, usando o cálculo de seqüentes, lógicas com operadores auto-duais não comutativos. Estes operadores naturalmente geram uma classe de fórmulas cujas demonstraçãos dependemde um acesso a subfórmulas em profundidades arbitrárias, que é uma característica que o cálculo de seqüentes não suporta. O cálculo das estruturas supre essa necessidade, sendo mais geral que o cálculo de seqüentes para lógicas com negação involutiva, como as lógicas clássica e linear, sem sacrificar com isso a simplicidade.\nO cálculo das estruturas é uma generalização do cálculo de seqüentes de um lado só. Muitas lógicas com negação involutiva e leis de De Morgan podem ser definidas no cálculo de seqüentes de um lado só, e a tradução delas para cálculo das estruturas é uma tarefa direta e trivial. O que torna o cálculo das estruturasmais atraente é a possibilidade de definir lógicas utilizando conceitos fundamentalmente diferentes daqueles conceitos utilizados no cálculo de seqüentes. Dois conceitos centrais desse formalismo são:\n• Deep inference: regras de inferência no cálculo das estruturas podem operar em qual-\nquer lugar dentro das expressões, e não apenas na subfórmula mais externa em torno da raiz das árvores de fórmulas.\n• Simetria vertical: ao contrário do cálculo de seqüentes, da dedução natural e outros\nformalismos em que as derivações são essencialmente baseadas em árvores, no cálculo das estruturas as derivações podem ser invertidas de cima para baixo e negadas, permanecendo ainda válidas.\n23"
    }, {
      "heading" : "24 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "A implementação dessas idéias é possível utilizando o conceito de \"estrutura\". Uma estrutura é uma expressão intermediária entre um seqüente de um lado só e uma fórmula. Mais precisamente, é uma fórmula lógica comum módulo uma teoria de equações do tipo tipicamente imposta a seqüentes. De um ponto de vista prático, conectivos lógicos desaparecem (em particular conectivos na raiz das árvores de fórmulas) e as regras lógicas se tornam estruturais (em oposição a regras lógicas), no sentido de que elas lidam com a posição relativa de subestruturas dentro de uma estrutura. Estruturas são a única forma de expressão permitida, e regras de inferência são simplesmente regras de reescrita sobre estruturas, de onde vem o nome \"cálculo das estruturas\".\nO cálculo das estruturas é um formalismo adequado à Teoria da demonstração. Podese demonstrar propriedades importantes como uma regra Cut e, assim como no cálculo de seqüentes, a eliminação da regra Cut faz sentido. Além disso, há uma propriedade análoga à propriedade da subfórmula, que garante que qualquer regra dada (exceto pela regra Cut e excepcionalmente outras regras especiais) tem aplicação finita. Com essas características, o cálculo das estruturas está mais próximo do cálculo de seqüentes do que de qualquer outro formalismo. Entretanto, a eliminação da regra Cut nos dois formalismos é bastante distinta, ao menos quando se utiliza a característica de deep inference. No cálculo de seqüentes, a eliminação da regra Cut depende crucialmente da existência de um conectivo principal, o que não acontece no cálculo das estruturas. Além disso, no cálculo das estruturas a regra Cut pode ser dividida em várias regras.\nTodos esses conceitos de estrutura, \"deep inference\"e simetria vertical se baseiam em uma representação gráfica de estruturas que se assemelha a grafos. Essa representação é chamada de redes de interação1. As redes de interação podem ser usadas tanto como uma semântica para as estruturas quanto para um modelo abstrato de computação [?]."
    }, {
      "heading" : "3.1.2 Estruturas",
      "text" : "Apesar de o conceito de estrutura não ser complicado, começar a entendê-lo através da relação com conceitos já tradicionais da Teoria da demonstração pode ser útil. Simplificando bastante, uma estrutura é, ao mesmo tempo, uma fórmula e um seqüente, além de capturar alguns aspectos de redes de demonstraçãos.\nJustamente porque estruturas capturam aspectos de redes de demonstraçãos, é interessante começar a introduzir seu conceito através da construção de uma demonstração na lógica linear multiplicativa. Na representação de seqüentes de um lado só, a conjunção multiplicativa ⊗ (times) é definida como:\n⊢ A,Φ ⊢ B,Ψ ⊗\n⊢ A⊗B,Φ,Ψ\nInstâncias de ⊗ podem ser vistas como passos elementares em uma computação que correspondem à construção de uma demonstração (de baixo para cima). Esta perspectiva\n1Em inglês:Relation webs"
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 25",
      "text" : "é chamada de paradigma de busca por demonstraçãos como computação ou de construção de demonstraçãos. Sob este ponto de vista, a regra ⊗ acima apresenta uma grave falha: quando a regra é aplicada, temos que decidir como dividir o contexto Φ,Ψ da fórmula principal A⊗B, e se há n fórmulas no multiconjunto Φ,Ψ, então há 2n maneiras de dividi-las entre Φ eΨ. Esta é uma fonte exponencial de não-determinismo indesejável, se estamos interessados em implementar o nosso sistema.\nUma alternativa para resolver o problema é adotar uma abordagem externa ao cálculo de seqüentes, ou seja, uma implementação que controle o uso da regra a posteriori. Nesta abordagem, na construção da demonstração, o multiconjunto Φ, Ψ não é dividido a princípio, mas é utilizado conforme vai surgindo a necessidade por suas fórmulas ao longo da construção da demonstração. Sempre que necessário, a instância da regra ⊗ é atualizada para refletir essa utilização, até que uma demonstração válida seja construída. Esta abordagem “preguiçosa” foi adotada por Hodas e Miller no caso da lógica intuicionista linear [?].\nMas ainda resta a questão de se o problema pode ser resolvido dentro de um sistema dedutivo. Uma idéia seria criar clusters de fórmulas, correspondendo a contextos a serem divididos, e cada fórmula poderia ser tomada sob demanda. No cálculo de seqüentes tradicional, esta solução não é atingível facilmente. O que realmente conta no cálculo de seqüentes, enquanto construímos uma demonstração de baixo para cima, é a fronteira de hipóteses, cuja natureza é de um multiconjunto. Em vez disso, precisamos manter uma árvore, cuja estrutura trata automaticamente do aninhamento de clusters.\nConsideremos o seguinte exemplo de demonstração em MLL:\n⊢ b,¬b Inicial\n⊢ a,¬a Inicial ⊢ c,¬c Inicial\na,¬a⊗ c,¬c ⊗\n⊢ a, (¬a⊗ c)O¬c O\n⊢ a, b,¬b⊗ ((¬a⊗ c)O¬c) ⊗\n⊢ a, b,O(¬b⊗ ((¬a⊗ c)O¬c)) O\n⊢ aO(bO(¬b⊗ ((¬a⊗ ¬c)O¬c))) O\nNeste caso, partições apropriadas do contexto foram achadas, e temos então uma demonstração. Como será visto adiante, no cálculo das estruturas, essas partições de contexto são tratadas internamente no sistema dedutivo, graças às características únicas que este formalismo apresenta.\nNa sintaxe de cálculo das estruturas, vamos chamar O de par e ⊗ de copar. A negação de um átomo a, ou seu dual, é representado como sendo ā. A fórmula demonstraçãoda acima será representada como [a, b, (b̄, [(ā, c), c̄])] e expressões como esta são chamadas de estruturas. Em vez de usar conectivos binários para definir relações lógicas, as relações são induzidas pelo contexto, significando, por exemplo, que [R1, . . . , Rh ] é uma estrutura par, dentro da qual as subestruturas são consideradas unidas por conectivos par. Já que a relação par é comutativa e associativa, as estruturas não são distingüidas com base na ordem ou agrupamento de subestruturas. O mesmo é verdade para copar: (R1, . . . , Rh) tem as mesmas propriedades que uma estrutura par."
    }, {
      "heading" : "26 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "Definição 8. Há infinitos átomos positivos e infinitos átomos negativos. Átomos, não importando se positivos ou negativos, são denotados por a, b, c, . . .. Estruturas são , denotadas por S, P , Q, R, T , U , V eX. A gramática para geração de estruturas é:\nS ::= ◦ | a | 〈S; . . . ;S〉 ︸ ︷︷ ︸\n>0\n| [S, . . . , S ] ︸ ︷︷ ︸\n>0\n| (S, . . . , S) ︸ ︷︷ ︸\n>0\n| S̄\nonde ◦, a unidade, não é um átomo. 〈S; . . . ;S〉 é chamada de uma estrutura seq (ou simplesmente seq), [S, . . . , S ] é uma estrutura par (ou simplesmente par) e (S, . . . , S) é uma estrutura copar (ou simplesmente copar). S̄ é a negação da estrutura S. Um átomo negado ā é negativo se a for positivo e positivo se a for negativo. Existe um átomo especial chamado contexto aberto 2, denotado por { }, cujo propósito é indicar um lugar específico dentro de uma estrutura onde eventualmente outras estruturas são encaixadas. Estruturas que possuem um contexto aberto que não aparece no escopo de uma negação são denotadas como S{ }, e são chamadas de contextos de estruturas, ou simplesmente contextos. A estrutura R é uma subestrutura de S{R}, e S{ } é o contexto de R.\nObservação 9. Delimitadores são sinais utilizados para delimitar estruturas, indicando sua natureza. Os delimitadores de uma estrutura seq são 〈〉, de uma estrutura par são [ ] e de uma estrutura copar são ().\nNotação 10. Quando houver delimitadores de algum tipo em torno do conteúdo de um contexto aberto, as chaves do contexto aberto poderão ser omitidas. Por exemplo, S [a, b] é o mesmo que S{[a, b]}.\nNotação 11. Uma letra estabelece implicitamente a classe à qual um objeto pertence. Por exemplo, S é sempre uma estrutura, sem ser preciso explicitar isso.\nA associatividade é válida para todas as estruturas, mas a comutatividade não é válida para estruturas seq. A negação é involutiva e obedece às leis usuais de De Morgan para par e copar, que são duais. Já seq é auto-dual.\nDefinição 12. Estruturas são consideradas equivalentes módulo =, que é a relação de equivalência minimal definida pelos axiomas da figura 3.1. Nessa figura, ~R, ~T , ~U representam seqüências finitas e não vazias de estruturas. Uma estrutura, ou um contexto, é dito estar na forma normal quando as únicas estruturas negadas são átomos, não há nenhuma unidade ◦ e nenhum delimitador pode ser eliminado mantendo a equivalência. Se duas estruturas R e T são tais que R 6= ◦ 6= T , então a estrutura 〈R;T 〉 é um seq próprio, a estrutura [R;T ] é um par próprio e a estrutura (R;T ) é um copar próprio. Uma estrutura S{ } é um contexto seq próprio (ou um contexto par próprio, ou um contexto copar próprio) se, para todo X 6= ◦, a estrutura S{X} é um seq próprio (ou um par próprio, ou um copar próprio). As estruturas cuja forma normal não contenham estruturas seq são chamadas flat. Se uma forma normal é flat, então todas as demais também o são."
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 27",
      "text" : "Associatividade 〈~R; 〈~T 〉; ~U 〉 = 〈 ~R; ~T ; ~U〉\n[ ~R, [ ~T ] ] = [ ~R, ~T ] (~R, [ ~T ]) = ( ~R, ~T )\nSingleton 〈R〉 = [R] = (R) = R\nUnidade 〈◦; ~R〉 = 〈~R; ◦〉 = 〈~R〉\n[◦, ~R] = [ ~R] (◦, ~R) = (~R)\nComutatividade [ ~R, ~T ] = [ ~T , ~R] ( ~R, ~T ) = (~T , ~R)\nNegação ◦̄ = ◦\n¯〈R;T 〉 = 〈R̄; T̄ 〉 ¯[R;T ] = (R̄; T̄ ) ¯(R;T ) = [R̄; T̄ ] R̄ = R\nFechamento de contexto R = T ⇒ S{R} = S{T} ∧ R̄ = T̄\nFigura 3.1: Equivalência sintática =\nPor exemplo, as estruturas [a, ◦, b], (([◦, b]), 〈ā〉) e (ā, ◦, b̄) são todas equivalentes, mas nenhuma está na forma normal. Já a estrutura (ā, b̄) é equivalente a elas e está na forma normal, assim como (b̄, ā). E todas as estruturas são flat.\nUma vez que as estruturas são consideradas equivalentes sob =, a estrutura [◦, 〈a; b〉] é um seq próprio, mas não é um par próprio ou um copar próprio. 〈a; [{ }, b]〉 é um contexto seq próprio, enquanto [{ }, b] é um contexto par próprio.\nObservação 13. Toda estrutura pode ser colocada na forma normal, uma vez que a negação sempre pode ser trazida para os átomos mais internos via os axiomas de negação, e unidades podem ser removidas, assim como delimitadores extras (pelas leis de associatividade e singleton). Toda estrutura pode ser equivalente a apenas um dos seguintes: unidade, um átomo, um seq próprio, um par próprio ou um copar próprio.\nAs regras de negação se assemelham às leis de De Morgan para par e copar, mas, para o conectivo auto-dual não comutativo seq, a ordem das subestruturas é mantida sob a negação. A equação ◦̄ = ◦ indica que em cálculo das estruturas a unidade é um pouco diferente das constantes lógicas tradicionais como ⊤ (verdadeiro) e ⊥ (falso). A unidade é apenas uma marca de representação à qual não daremos interpretação semântica.\nDefinição 14. Dada uma estrutura S, suas ocorrências de átomos são todos átomos em S levando em conta aparições distintas do mesmo átomo (por exemplo indexando-os de forma que dois átomos iguais recebem índices diferentes). Assim, em 〈a, a〉 há duas ocorrências de átomos. A notação occ S indica o conjunto de todos as ocorrências de átomos em S. O tamanho de S é a cardinalidade do conjunto occ S.\nO conjunto occ S poderia ser definido como o multiconjunto de átomos de S, ou de S na forma normal. Note que occ ◦ = ∅. Além disso, occ 〈S;S′〉 = occ [S, S′ ] = occ (S, S′) =\n2Em inglês: hole"
    }, {
      "heading" : "28 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "occ S ∪ occ S′ é verdadeiro somente se occ S e occ S′ são disjuntos, e pode-se sempre assumir isto sem perda de generalidade."
    }, {
      "heading" : "3.1.3 Redes de interação",
      "text" : "Estruturas sempre podem ser representadas pela gramática exposta na seção anterior. Existe, porém, uma forma gráfica alternativa que captura toda a essência da estrutura e, por motivos que serão expostos mais adiante, é muito conveniente em certas situações. Essa forma de representação são as redes de interação. Um ponto importante é que existe uma única teia de interação para cada classe de equivalência de estruturas sob a relação de igualdade =.\nRedes de interação podem ser usadas como uma espécie de semântica para regras de\ninferência.\nConsidere [R1, . . . , Rh ]. Sejam 1 ≤ i, j ≤ h distintos. Para todo átomo a que aparece em Ri e todo átomo b que aparece em Rj , a relação a ↓ b é válida. Observa-se que ↓ é simétrica. Analogamente, duas estruturas distintas R e T numa relação de copar induzem em seus átomos a relação a ↑ b, onde a pertence a R e b pertence a T.\nPor exemplo, seja a estrutura:\n[a, b, (b̄, [(ā, c), c̄])]\nNesse caso temos os seguintes pares relacionados: a ↓ b, a ↓ b̄, a ↓ ā, a ↓ c, a ↓ c̄, b ↓ b̄, b ↓ ā, b ↓ c, b ↓ c̄, b̄ ↑ ā, b̄ ↑ c, b̄ ↑ c̄, ā ↑ c, ā ↓ c̄, c ↓ c̄. Além desses, há os pares simétricos, que foram omitidos.\nAlém dessas relações, 〈S1, . . . , Sh〉, com 1 ≤ i < j ≤ h induz a relação a ⊳ b para todo a\nem Si e b em Sj . Observe que ⊳ não é simétrica.\nDefinição 15. Dada uma estrutura S na forma normal, as quatro relações estruturais ⊳S (seq), ⊲S (coseq), ↓S (par) e ↑S (copar) são os conujuntos minimais tais que ⊳S , ⊲S , ↓S , ↑S⊂ (occ S)2 e, para todo S′{ }, U e V e para todo a em U e b em V , as seguintes asserções podem ser verificadas:\n1. se S = S′〈U ;V 〉, então a ⊳S b e b ⊲S a;\n2. se S = S′ [U, V ], então a ↓S b;\n3. se S = S′(U, V ), então a ↑S b;\nPara uma estrutura que não está em sua forma normal, obtém-se a teia de interação a partir de qualquer de suas formas normais, uma vez todas elas levarão à mesma rede. A quádrupla (occ S, ⊳S , ↓S , ↑S) é chamada de teia de interação (ou simplesmente rede) de S, denotada por w S. Pode-se abolir os subscritos em ⊳S , ⊲S , ↓S , ↑S quando eles não forem necessários. Dados dois conjuntos de átomos µ e ν, escrevem-se µ ⊳ ν, µ ⊲ ν, µ ↓ ν, µ ↑ ν para indicar situações nas quais, para todo a pertencente a µ e todo b pertencente a ν, o seguinte vale, respectivamente: a ⊳ b, a ⊲ b, a ↓ b, a ↑ b. Representam-se relações estruturais entre"
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 29",
      "text" : "ocorrências de átomos desenhando a b///o/o quando a ⊳ b (e b ⊲ a), a boo ///o/o quando a ⊳ b ou a ⊲ b, a b quando a ↓ b e a b/o/o quando a ↑ b. Linhas pontilhadas representam a negação das respectivas relações estruturais.\nPor exemplo, em (〈ā; b〉, (c, d̄)) = (〈a, b̄〉, [c̄, d]) determinam-se as relações a ⊳ b̄, a ↑ c̄, a ↑ d, b̄ ⊲ a, b̄ ↑ c̄, b̄ ↑ d, c̄ ↑ a, c̄ ↑ b̄, c̄ ↓ d, d ↑ a, d ↑ b̄, d ↓ c̄. A teia de interação para ◦ é\n(∅, ∅, ∅, ∅)\nObservação 16. Uma estrutura S tal que w S = (occ S, ⊳, ↓, ↑) é flat se, e somente se, ⊳ = ∅.\nPode-se perceber pelas definições acima que todos os átomos de uma subestrutura respeitam a mesma relação estrutural em relação aos átomos do contexto que envolve esta subestrutura:\nProposição 17. Dada uma estrutura S{R} e duas ocorrências de átomos a em S{ } e b em R, se\na ⊳ b (respectivamente, a ⊲ b, a ↓ b, a ↑ b) então a ⊳ c (respectivamente, a ⊲ c, a ↓ c, a ↑ c) para todas\nas ocorrências de átomos c em R.\nA sintaxe de estruturas apresentada, assim como a relação de equivalência =, ajuda a manter o foco do sistema mais no significado do que na sua forma de representação. O que realmente importa são os átomos e suas relações mútuas. Entretanto, não basta tomar um conjunto de átomos e atribuir relações arbitrárias entre eles para se obter uma estrutura. Duas questões importantes são levantadas neste momento:\n1. Em que condições uma atribuição de relações a átomos realmente forma uma estru-\ntura.\n2. Se duas estruturas que possuem uma dada teia de interação são equivalentes por= ou\nnão.\nOs teoremas seguintes [?] fornecem as respostas.\nTeorema 18. Dada uma estrutura S e suas relações estruturais ⊳, ⊲, ↓, ↑, as seguintes propriedades\nsão válidas, onde a, b, c e d são ocorrências de átomos distintas em S:\ns1 Nenhuma das relações ⊳, ⊲, ↓ e ↑ é reflexiva: ¬(a ⊳ a), ¬(a ⊲ a), ¬(a ↓ a), ¬(a ↑ a).\ns2 Uma, e apenas uma, das relações a ⊳ b, a ⊲ b, a ↓ b, a ↑ b é válida.\ns3 As relações ⊳ e ⊲ são mutuamente inversas: a ⊳ b ⇐⇒ b ⊲ a.\ns4 As relações ⊳ e ⊲ são transitivas: a ⊳ b ∧ b ⊳ c =⇒ a ⊳ c e a ⊲ b ∧ b ⊲ c =⇒ a ⊲ c.\ns5 As relações ↓ e ↑ são simétricas: a ↓ b ⇐⇒ b ↓ a e a ↑ b ⇐⇒ b ↑ a.\ns6 Propriedade triangular: para σ1, σ2, σ3 ∈ {⊳ ∪ ⊲, ↓, ↑} pode-se afirmar que:\n(aσ1b) ∧ (bσ2c) ∧ (cσ3a) =⇒ (σ1 = σ2) ∨ (σ2 = σ3) ∨ (σ3 = σ1)"
    }, {
      "heading" : "30 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "s7 Propriedade do quadrado:\ns⊳7 (a ⊳ b) ∧ (a ⊳ d) ∧ (c ⊳ d) =⇒ (a ⊳ c) ∨ (b ⊳ c) ∨ (b ⊳ d) ∨ (c ⊳ a) ∨ (c ⊳ b) ∨ (d ⊳ b). s↓7 (a ↓ b) ∧ (a ↓ d) ∧ (c ↓ d) =⇒ (a ↓ c) ∨ (b ↓ c) ∨ (b ↓ d). s↑7 (a ↑ b) ∧ (a ↑ d) ∧ (c ↑ d) =⇒ (a ↑ c) ∨ (b ↑ c) ∨ (b ↑ d).\nDemonstração. As propriedades de s1, s2, s3, s4 e s5 seguem diretamente da definição. Será dada a demonstração das propriedades s6 e s7.\ns6 Suponha que a ⊳ b e b ↓ c. Os únicos casos possíveis são S〈P{a};T [Q{b}, R{c}]〉 (e então\ntem-se que a ⊳ c) ou S [T 〈P{a};Q{b}〉, R{c}] (e então tem-se que a ↓ c), onde P{ }, Q{ }, R{ }, S{ } e T{ } são contextos. Outras combinações de σ1 e σ2 geram casos análogos.\ns7 Por indução estrutural em S. Qualquer estrutura com menos do que quatro ocorrências\nde átomos satisfaz s7 trivialmente, já que a hipótese do teorema necessita de quatro ocorrências distintas. Serão consideradas, portanto, estruturas em que haja pelo menos quatro ocorrências. Sejam U e V duas estruturas tais que U 6= ◦ 6= V e temos uma das seguintes situações pode ser verificada: ou S = 〈U ;V 〉, ou S = [U, V ], ou S = (U, V ). Escolham-se quatro átomos a, b, c e d em S. Se a, b, c e d estão todos em U ou em V , então pode-se aplicar a hipótese de indução. Serão considerados então os casos em que os quatro átomos não estão todos em U ou em V . Considere s⊳7. Já que S = [U, V ] e S = (U, V ) falsificam a hipótese de s⊳7, a única situação a ser considerada é S = 〈U ;V 〉. Suponha que a conclusão de s⊳7 seja falsa e que a está em U , logo c deve estar em U (de outra forma a ⊳ c seria verdadeiro), e então b e d devem estar em U , o que contradiz a hipótese assumida. Analogamente, se a está em V então c deve necessariamente estar em V e logo b e d também devem estar em V , o que novamente é uma contradição. Enfim, se a hipótese de s⊳7 é verdadeira quando a, b, c, e d estão distribuídos entre U e V , então sua conclusão é verdadeira. O mesmo argumento se aplica a s↓7 e a s ↑ 7.\nA propriedade do triângulo diz que não há estrutura que contenha uma subestrutura da\nforma:\nbOO O O O O O O O O\n▼▼▼ ▼▼▼\n▼▼▼ ▼▼▼\n▼\nc\na\n8x8x8x8x8x8x8x8x\nEm outras palavras, em todo triângulo pelo menos dois lados devem representar a\nmesma relação estrutural."
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 31",
      "text" : "A propriedade do quadrado para ⊳ pode ser representada como na figura 3.1.3, onde a transitividade foi levada em conta e um exemplo de estrutura é mostrado abaixo de cada diagrama. Levando em conta a comutatividade, os casos para par e copar são mais simples. A figura 3.1.3 mostra o que acontece no caso do par. Informalmente, podemos dizer que nenhum quadrado tem exatamente três lados ou diagonais da mesma natureza (isto é, representando a mesma relação estrutural) e formando um caminho simples (sem levar em conta a orientação).\ndOO\nO O O __\n_ _\n_ _\n_ bOO\nO O O\nc a =⇒\ndOO\nO O O\nc b\na\n__ _ _ _ _ _\n??? ?\n? ?\n?\nEx: 〈a; [〈c; d〉, b]〉 ∨\ndOO\nO O O\ncOO\nO O O\nbOO\nO O O\na Ex: 〈a; b; c; d〉 ∨\nd@@\n@ @ @ @ @ ^^ ^ ^ ^ ^ ^\nc b\na\nOO O O O\nEx: 〈[c, 〈a; b〉]; d〉\n∨\nd b\naOO\nO O O\n__ _ _ _ _ _\n??? ?\n? ?\n?\nc Ex: 〈c; a; [d, b]〉\n∨\ndOO\nO O O __\n_ _\n_ _\n_ bOO\nO O O\n??\n? ? ? ? ?\nc a Ex: 〈[c, a]; [d, b]〉\n∨\nbOO\nO O O\nd??\n? ? ? ? ? __\n_ _\n_ _\n_\nc a Ex: 〈[c, a]; d; b〉\nFigura 3.2: Propriedade do quadrado para ⊳\nObservação 19. As relações ↓ e ↑ não são transitivas: considere [〈a; c〉, b] (nesse caso a ↓ b e b ↓ cmas ¬(a ↓ c)) e (〈a; c〉, b) (nesse caso a ↑ b e b ↑ cmas ¬(a ↑ c)).\nAté agora foi mostrado que as condições de s1 a s7 são necessárias para uma estrutura, mas ainda não foi mostrado que são suficientes. Isto será feito em seguida, mas antes são necessárias algumas definições auxiliares.\nDefinição 20. Uma rede candidata3 é uma quádrupla ζ = (ξ, ⊳, ↓, ↑), onde ξ é um conjunto 3Em inglês: Web candidate\n32 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\nd c\na b =⇒\nd c\n✁✁ ✁✁ ✁✁ ✁✁\na b\nEx: [a, 〈b; [d, c]〉] ∨\nd c\na b\nEx: [〈a; c〉, 〈b; d〉] ∨\nd\n❂❂ ❂❂\n❂❂ ❂❂\nc\na b\nEx: [〈[a, b]; c〉, d]\nFigura 3.3: Propriedade do quadrado para ↓\nde ocorrências de átomos e ⊳, ↓, ↑⊆ ξ2. Dadas as redes candidatas ζµ = (µ, ⊳µ, ↓µ, ↑µ) e ζν = (ν, ⊳ν , ↓ν , ↑ν), tais que µ 6= ∅ 6= ν, µ ∪ ν = ξ e µ ∩ ν = ⊳µ ∩ ⊳ν =↓µ ∩ ↓ν=↑µ ∩ ↑ν= ∅, o par (ζµ, ζν) pode ser:\n1. uma partição-⊳ de ζ se, e somente se, ↓=↓µ ∪ ↓ν , ↑=↑µ ∪ ↑ν e\n⊳ = ⊳µ ∪ ⊳ν ∪ {(a, b)|a ∈ µ ∧ b ∈ ν}\n2. uma partição-↓ de ζ se, e somente se, ⊳ = ⊳µ ∪ ⊳ν , ↑=↑µ ∪ ↑ν e\n↓=↓µ ∪ ↓ν ∪{(a, b)|(a ∈ µ ∧ b ∈ ν) ∨ (a ∈ ν ∧ b ∈ µ)}\n3. uma partição-↑ de ζ se, e somente se, ⊳ = ⊳µ ∪ ⊳ν , ↓=↓µ ∪ ↓ν e\n↑=↑µ ∪ ↑ν ∪{(a, b)|(a ∈ µ ∧ b ∈ ν) ∨ (a ∈ ν ∧ b ∈ µ)}\nPara toda rede candidata, a relação ⊲ = {(a, b)|b ⊳ a} deve ser definida, e isto é feito de\nmaneira implícita.\nEvidentemente redes de interação são redes candidatas. Com essas definições já é possí-\nvel demonstrar que as condições s1 a s7 são suficientes para uma estrutura.\nTeorema 21. Se as condições de s1 a s7 valem para uma rede candidata ζ então existe uma estrutura cuja teia de interação é ζ .\nDemonstração. Seja ζ = (ξ, ⊳, ↓, ↑): vamos proceder por indução sobre a cardinalidade |ξ| de ξ para construir uma estrutura S tal que w S = ζ . Se ξ = ∅ então S = ◦. Se ξ = {a} então ⊳ =↓=↑= ∅ (por s1) e S = a. Consideremos os casos em que há pelo menos duas ocorrências de átomos em ξ. Veremos que as condições de s1 a s7 reforçam a existência de uma partição -⊳, -↓ ou -↑ de ζ . Suponha que exista uma partição-⊳ de ζ , consistindo de ζµ e"
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 33",
      "text" : "ζν . As condições de s1 a s7 valem para ζµ e ζν , então, pela hipótese de indução, existem duas estruturas U e V tais que w U = ζµ e w V = ζν . Mas então podemos tomar S = 〈U ;V 〉 e, pela definição e por s2 e s3, temos que w S = ζ . Podemos proceder analogamente quando ζµ e ζν formarem uma partição-↓ (tome S = [U, V ]) ou uma partição-↑ (tome S = (U, V )). O papel de s5 é assegurar a correta formação de uma partição.\nÉ preciso mostrar que existe uma partição -⊳, -↓ ou -↑ de ζ , sob as hipóteses dadas, consistindo de ζµ = (µ, ⊳µ, ↓µ, ↑µ) e ζν = (ν, ⊲ν , ↓ν , ↑ν). Vamos construir os conjuntos de ocorrências de átomos µ e ν incrementalmente, começando por µ2 = {a} e ν2 = {b} para algum a e algum b em ξ, e construindo uma família de pares {(µi, νi)}2≤i≤|ξ| de tal forma que em cada passo um elemento de ξ que não foi adicionado antes é adicionado à união de µi e νi; em cada passo µi 6= ∅ 6= νi e ou µi ⊳ νi ou µi ↓ νi ou µi ↑ νi. O passo final dá a partição, ou seja, µ = µ|ξ| e ν = ν|ξ|. Abaixo é apresentado um algoritmo não-determinístico para isso.\nPrimeiro passo Tome µ2 = {a} e ν2 = {b}, onde a e b são ocorrências de átomos distintas aleatoriamente escolhidas em ξ e tais que uma das relações µ2 ⊳ ν2, µ2 ↓ ν2, ou µ2 ↑ ν2 é válida (as condições s2 e s3 se aplicam).\nPasso iterativo Temos dois conjuntos disjuntos e não-vazios de ocorrências µi e νi tais que todas as ocorrências de átomos em µi possuem a mesma relação estrutural σ ∈ {⊳, ↓, ↑} com as ocorrências de átomos em νi, ou seja, µi ⊳νi, µi ↓ νi, ou µi ↑ νi. Escolha um c qualquer em ξ\\(µi∪νi). Se d σ c para todo d em µi então faça µi+1 = µi e νi+1 = νi ∪ {c}; se c σ e para todo e em νi então faça µi+1 = µi ∪ {c} e νi+1 = νi; em ambos os casos µi+1σνi+1. Se isso não ocorrer é preciso rearranjar µi e νi a fim de que eles atendam as nossas restrições. Procedamos por casos:\n1. µi ⊳ νi e existem a em µi e b em νi tais que ¬(a ⊳ c) e ¬(c ⊳ b). Esta situação está repre-\nsentada à esquerda (onde a c///o/o significa ¬(a ⊳ c)):\n{νi} b OO\nO O O O O O O O\nee\n%e %e\n%e %e\n%e\nc99\ny9 y9 y9 y9 y9\n{µi} a\n=⇒ {νi} b OO\nO O O O O O O O\n❑❑ ❑❑\n❑❑ ❑❑\n❑❑ ❑❑\n❑❑\nc\nss ss ss ss ss ss ss\n{µi} a\n∨ {νi} b OO\nO O O O O O O O\n%e%e %e\n%e%e %e\n%e%e %e\nc\ny9 y9 y9\ny9 y9 y9\ny9 y9 y9\n{µi} a\nComo a ⊳ b, por transitividade de ⊳ (s4), por simetria de ↓ e ↑ (s5) e pela propriedade triangular (s6), apenas dois casos são possíveis: ou a ↓ c e c ↓ b, ou a ↑ c e c ↑ b (o primeiro caso está representado no diagrama central, o segundo no da direita). Vamos considerar o primeiro caso, o segundo sendo similar. Novamente por s4, s5 e s6, ou"
    }, {
      "heading" : "34 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "d ↓ c ou d ⊳ c, para cada elemento d em µi, e ou c ↓ e ou c ⊳ e para cada elemento e em νi. Podemos então particionar µi em dois conjuntos disjuntos µ ↓ i e µ ⊳ i e particionar νi em dois conjuntos disjuntos ν ↓ i e ν ⊲ i de tal forma que µ ↓ i ↓ {c}, µ ⊳ i ⊳ {c} e {c} ↓ ν ↓ i , {c} ⊳ ν⊲i . Claro que a ∈ µ ↓ i e b ∈ ν ↓ i . Essa situação é representada à esquerda:\n{ν↓i } b\n{ν⊲i }\nc\n❂❂❂❂❂❂❂❂❂\n999y 9y\n9y 9y\n9y 9y\n9y 9y\n9y\n{µ↓i } a\nOO O O O O O O O O\n<< <|\n<| <|\n<| <|\n<| <|\n<| <|\n<| <|\n<| <|\n<| <|\n<|\n{µ⊳i }\nOO O O O O O O O O ee e% e% e% e%\ne% e% e%\ne% e%\nbb b\" b\" b\" b\" b\" b\" b\" b\" b\" b\" b\" b\" b\" b\" b\" b\"\n=⇒ {ν ⊲ i }\n{ν↓i } b\nOO O O O\nc\nZZ Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z Z ❏❏❏❏❏❏❏❏❏❏❏❏❏❏\nss ss ss ss ss ss ss DD D D D D D D D D D D D D D D D {µ↓i } a\nOO O O O O O O O O\n{µ⊳i }\nOO O O O\nDevido a s4, s5, s6 e propriedade do quadrado para ↓ (s ↓ 7) entre µ ↓ i , µ ⊳ i , ν ↓ i e c, temos que necessariamente µ⊳i ⊳ µ ↓ i . Analogamente, necessariamente temos que ν ↓ i ⊳ ν ⊲ i . A situação resultante, simplificada por transitividade, é mostrada na figura da direita. Se µ⊳i 6= ∅ então tome µi+1 = µ ⊳ i e νi+1 = µ ↓ i ∪ ν ↓ i ∪ ν ⊲ i ∪ {c}: nesse caso µi+1 ⊳ νi+1. Se µ⊳i = ∅, então se ν ⊲ i 6= ∅ tome µi+1 = µ ↓ i ∪ ν ↓ i ∪ {c} e νi+1 = ν ⊲ i : de novo µi+1 ⊳ νi+1. Se µ⊳i = ∅ e ν ⊲ i = ∅, tome µi+1 = µ ↓ i ∪ ν ↓ i e νi+1 = {c}: nesse caso µi+1 ↓ νi+1.\n2. µi ↓ νi e existem a em µi e b em νi tais que ¬(a ↓ c) e ¬(b ↓ c): por um argumento\nanálogo ao do caso 1, temos que essa situação, representada à esquerda no diagrama abaixo (onde a c❴❴❴ representa ¬(a ↓ c)), implica uma das três possibilidades que estão representadas abaixo:\n3.1. O CÁLCULO DAS ESTRUTURAS 35\nc\n❃ ❃\n❃ ❃\n❃\n{µi} a\n{νi} b\n=⇒\nc??\n? ? ? ? ?\n^^\n^ ^\n^ ^\n^\n{µi} a\n{νi} b\n∨ {µi} a\n{νi} b\nc\n__ _ _ _ _ _\n@@ @\n@ @\n@ @\n∨ c\n? ? ? ? ?\n^ ^\n^ ^\n^\n{µi} a\n{νi} b\nVamos considerar o primeiro caso, onde a ⊳ c e b ⊳ c. Usando a propriedade triangular (s6), podemos parcitionar µi em µ ↓ i e µ ⊳ i e νi em ν ↓ i e ν ⊳ i de tal forma que temos a situação representada à esquerda:\nc??\n? ? ? ? ?\n__\n_ _\n_ _\n_ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ {µ⊳i } a\n❏❏ ❏❏\n❏❏ ❏❏\n❏❏ ❏❏\n❏❏ ❏❏\n{ν⊳i } b\n{µ↓i } tttttttttttttttt {ν↓i }\n=⇒ c??\n? ? ? ? ?\n__\n_ _\n_ _\n_ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✑✑ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ ✲✲ {µ⊳i } a\n❏❏ ❏❏\n❏❏ ❏❏\n❏❏ ❏❏\n❏❏ ❏❏\n{ν⊳i } b\n{µ↓i } tttttttttttttttt {ν↓i }\nA propriedade do quadrado forçosamente nos leva à situação da direita, onde agora podemos definir uma partição apropriada. Se µ↓i 6= ∅ então tome µi+1 = µ ↓ i e νi+1 = µ⊳i ∪ {c} ∪ ν ⊳ i ∪ ν ↓ i : nesse caso µi+1 ↓ νi+1. Se µ ↓ i = ∅, então se ν ↓ i 6= ∅ tome µi+1 = µ⊳i ∪ {c} ∪ ν ⊳ i e νi+1 = ν ↓ i : de novo µi+1 ↓ νi+1. Se µ ↓ i = ∅ e ν ↓ i = ∅, tome µi+1 = µ ⊳ i ∪ ν ⊳ i e νi+1 = {c}: nesse caso µi+1 ⊳ νi+1. Os outros casos acima, nos quais a ⊲ c e b ⊲ c, são tratados de forma análoga.\n3. µi ↑ νi e existe a em µi e b em νi tais que ¬(a ↑ c) e ¬(b ↑ c): esse caso é similar ao caso\n2.\nO passo final do algoritmo acontece quando nenhuma ocorrência de átomos em ζ já\npertence a uma partição.\nA essência da demonstração acima reside na ação combinada da propriedade triangular (s6) e na propriedade do quadrado (s7). A propriedade triangular reduz o problema a um"
    }, {
      "heading" : "36 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "caso onde apenas duas relações estruturais estão envolvidas, então a propriedade do quadrado é usada para decidir o lado do quadrado que ainda permanece por ser determinado.\nO algoritmo fornecido na demonstração acima é não-determinístico, logo ele não pode ser usado de maneira razoável para responder a seguinte pergunta: a cada rede de iteração corresponde uma única estrutura (módulo equivalência)? O seguinte teorema mostra que sim.\nLema 22. Dada uma estrutura T , se (ζµ, ζν) é uma partição-⊳ dew T (respectivamente uma partição↓, uma partição-↑) então existem duas estruturas U e V tais que w U = ζµ, w V = ζν e T = 〈U ;V 〉 (respectivamente, T = [U, V ], T = (U, V )).\nDemonstração. Seja w T = (occ T, ⊳, ↓, ↑). Sejam as redes candidatas ζµ = (µ, ⊳µ, ↓µ, ↑µ) e ζν = (ν, ⊳ν , ↓ν , ↑ν) uma partição-⊳ de w T . Já que µ 6= ∅ 6= ν, a estrutura T está em um dos três seguintes casos:\n1. T = 〈T1, . . . , Th〉, onde h > 1 e, para 1 ≤ i ≤ h, temos que Ti 6= ◦ e Ti não é um seq\npróprio. Então necessariamente temos que occ Ti ⊆ µ ou occ Ti ⊆ ν, para todo i. Com efeito, suponha o contrário, e suponha que Ti = [T ′i , T ′′ i ] para algum T ′ i e algum T ′′ i tais que T ′i 6= ◦ 6= T ′′ i (o mesmo argumento vale quando Ti = (T ′ i , T ′′ i ), nas mesmas condições). Então é possível achar a em T ′i e b em T ′′ i , ou a em T ′′ i e b em T ′ i , tais que a está em µ e b está em ν. Mas então a ↓ b, o que viola a hipótese assumida. Então, para todo i, as cocorrências de átomos em Ti vêm ou de µ ou de ν, mas não de ambos. Logo necessariamente temos que há k e k+ 1 em 1, . . . , h tais que todas as ocorrências de átomos de T1, . . . , Tk estão em µ e todas as ocorrências de átomos de Tk+1, . . . , Th estão em ν (de outra forma haveria casos de b ⊳ a para algum a em µ e algum b em ν). Então tome U = 〈T1; . . . ;Tk〉 e V = 〈Tk+1, . . . , Th〉.\n2. T = [T ′, T ′′ ], onde T ′ 6= ◦ 6= T ′′. Então necessariamente deve haver a em T ′ e b em T ′′,\nou a em T ′′ e b em T ′, tais qeu a está em µ e b está em ν. Mas então a ↓ b, o que viola a hipótese. Logo, este caso é de fato impossível.\n3. T = (T ′, T ′′), onde T ′ 6= ◦ 6= T ′′. Este caso é análogo ao anterior.\nDessa forma o lema é demonstraçãodo para qualquer partição-⊳ de w T . Um argumento\nanálogo pode ser usado para partições-↓ e partições-↑.\nTeorema 23. Duas estruturas são equivalentes se, e somente se, elas possuem a mesma teia de inte-\nração.\nDemonstração. A demonstração do \"somente se\" é trivial. Vamos mostrar então a demonstração do \"se\".\nSejam S e T duas estruturas na forma normal. Temos que demonstrar que se w S = w T então S = T . Vamos aplicar indução estrutural em S. Nos casos base S = ◦ ou S = a temos trivialmente que S = T . Suponha então que existam P eQ tais que S = 〈P ;Q〉 e P 6= ◦ 6= Q."
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 37",
      "text" : "O par (w P,w Q) é então uma partição-⊳ de w S, e portanto de w T . Pelo lema 22, existem U e V tais que T = 〈U ;V 〉 e w U = w P e w V = w Q, e então pode-se aplicar a hipótese de indução. Usam-se argumentos similares quando S = [P,Q] e S = (P,Q), onde P 6= ◦ 6= Q."
    }, {
      "heading" : "3.1.4 O Sistema BV",
      "text" : "O sistema BV, ou sistema básico V4, é uma extensão conservativa do fragmento multiplicativo da lógica linear acrescido da regra mix (MLL + mix) e do operador não comutativo e auto-dual seq. Tal sistema foi um dos primeiros propostos dentro do cálculo das estruturas [?]. É para um fragmento deste sistema (o flat BV, ou FBV) que este trabalho propõe uma estratégia de demonstraçãos.\nDefinição 24. Uma regra de inferência é um esquema da forma\nT ρ R\nonde ρ é o nome da regra, T é sua premissa e R é sua conclusão; nomes de regras são denotados por ρ e π. Em uma regra de inferência, ou a premissa ou a conclusão podem ser vazias, mas não ambas. Quando premissa e conclusão de uma instância de uma regra de inferência são equivalentes, esta instância é dita trivial, ou, caso contrário, é dita não-trivial. Um sistema (formal) é um conjunto de regras de inferência; sistemas formais são denotados por S . Uma derivação em um certo sistema formal é uma seqüência de instâncias de regras de inferência do sistema, e pode consistir de uma única estrutura; derivações são denotadas por ∆. A premissa da instância de regra de inferência mais acima na derivação, se presente, é chamada de premissa da derivação; se presente, a conclusão da instância de regra mais abaixo na derivação é chamada de conclusão da derivação; a premissa e a conclusão de derivações consistindo de uma única estrutura é a própria estrutura. Uma derivação ∆ cuja premissa é\nT , cuja conclusão é R e cujas regras de inferência estão em S é indicada por\nT\n∆ ‖‖ S\nR\n(o nome\n∆ pode ser omitido). O comprimento de uma derivação é o número de instâncias de regras de inferência que ela possui. Dois sistemas S e S ′ são fortemente equivalentes se para toda\nderivação T ‖ ‖ S\nR\nexiste uma derivação T ‖ ‖ S ′\nR\n, e vice-versa.\nExistem, no cálculo de seqüentes, duas formas complementares de enxergar uma deri-\nvação, que podem ser adaptadas ao cálculo das estruturas:\n4Basic system V"
    }, {
      "heading" : "38 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "1. A visão de baixo para cima: premissas se unem (em árvores) para formar novas con-\nclusões, e a derivação cresce no sentido de sua conclusão. Este pode ser chamado de ponto de vista dedutivo.\n2. A visão de cima para baixo 5: a conclusão é o ponto de partida e regras de inferência\nsão usadas para atingir as premissas desejadas. Este pode ser chamado de ponto de vista de construção de demonstraçãos.\nDepois de escolher regras de premissa única, existe uma situação de simetria: derivações são seqüências de inferências (simetria top-down), par e copar são o mesmo tipo de estrutura com dois nomes diferentes e seq é auto-dual.\nA figura 3.1.4 apresenta as regras de inferência para o sistema BV.\n◦ ↓ ◦\nS{◦} ai↓\nS [a, ā]\nS〈[R,T ]; [R′, T ′ ]〉 q↓\nS [〈R;R′〉, 〈T ;T ′〉]\nS([R,T ], R′) s\nS [(R,R′), T ]\nFigura 3.4: Sistema BV\nDefinição 25. Os nomes das regras são:\n◦ ↓ unidade (axioma lógico);\nai↓ interação atômica;\nq↓ seq;\ns switch.\nDefinição 26. Uma demonstração é uma derivação cuja regra mais acima seja o axioma lógico ◦ ↓. demonstraçãos são denotadas porΠ. Um sistema formal S demonstração R se existe em\nS uma demonstração Π cuja conclusão seja R, escrita\n− Π ‖ ‖ S\nR (o nome Π pode ser omitido).\nDois sistemas são (fracamente) equivalentes se eles demonstraçãom as mesmas estruturas.\nExemplo 27. demonstração de uma estrutura em BV:\n5Em inglês: bottom-up\n3.1. O CÁLCULO DAS ESTRUTURAS 39\n◦ ↓ ◦\nai↓ [a, ā]\n= [a, (ā, ◦)]\nai↓ [a, (ā, [b̄, b])]\ns [a, b̄, (ā, b)]\n= 〈[a, b̄, (ā, b)]; ◦〉\nai↓ 〈[a, b̄, (ā, b)]; [c, c̄]〉\nq↓ [〈[a, b̄]; c〉, 〈(ā, b); c̄〉]\nDefinição 28. O sistema flat BV (FBV) é o sistema BV sem a regra q↓. As estruturas permitidas no FBV são apenas estruturas flat (sem a estrutura seq).\nA figura 3.1.4 apresenta as regras de inferência para o sistema FBV.\n◦ ↓ ◦\nS{◦} ai↓\nS [a, ā]\nS([R,T ], R′) s\nS [(R,R′), T ]\nFigura 3.5: Sistema FBV\nObservação 29. O FBV é um subsistema do sistema BV, no sentido de que toda estrutura provável em FBV é provável em BV (mas a recíproca não é verdadeira). Mais do que isto, pode-se mostrar que o sistema BV é uma extensão conservativa do sistema FBV.\nExemplo 30. demonstração de uma estrutura em FBV:\n◦ ↓ ◦\nai↓ [b, b̄]\n= [(◦, b), b̄]\nai↓ [([a, ā], b), b̄]\ns [a, b, (ā, b̄)]\n3.1.5 O teorema de splitting\nO teorema de splitting tem um papel muito importante neste trabalho por dois motivos:\n1. Ele é a chave para a demonstração de eliminação da regra Cut para o cálculo das\nestruturas para MLL + mix+ seq (o sistema BV);"
    }, {
      "heading" : "40 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "2. Sua idéia central foi a motivadora para a estratégia de demonstraçãos para o sistema\nFBV com pares de átomos dois a dois distintos proposta neste trabalho.\nO segundo item, referente à motivação para a estratégia de demonstraçãos proposta, será retomado com detalhes mais adiante, na seção 4.2. No momento vamos nos concentrar no primeiro item.\nA eliminação da regra Cut é uma propriedade desejável em todo sistema lógico para o qual se deseja uma implementação eficiente. Em cálculo de seqüentes, a regra Cut pode ser escrita como:\nΓ1 ⊢ ∆1, A A,Γ2 ⊢ ∆2 Γ1,Γ2 ⊢ ∆1,∆2 Cut\nVista de baixo para cima, esta regra precisa que uma fórmula A seja “criada” do nada, o que exige uma criatividade que o computador não possui. Por isso, quando se foca na implementação, é desejável que a regra Cut possa ser eliminada. Os argumentos clássicos para se demonstrar a eliminação da regra Cut no cálculo de seqüentes se baseiam na propriedade de que, quando as fórmulas principais em uma instância da regra Cut estão ativas em ambas as ramificações, elas determinam quais regras são aplicadas imediatamente acima da regra Cut. Isto é uma conseqüência do fato de que estas fórmulas possuem um conectivo raiz, e regras lógicas são aplicáveis somente a este conectivo e em nenhum outro lugar da fórmula.\nEntretanto, no cálculo das estruturas, esta propriedade não é válida. O sistema BV compreende o fragmentomultiplicativo da lógica linear (MLL) mais a regramix emais seq. Existe uma versão atômica da regra Cut para BV chamada ai↑:\nS(a, ā) ai↑\nS{◦}\nEsta regra é simétrica à regra ai↓ e diz que, de baixo para cima, pode-se criar dois átomos de polaridades opostas em qualquer lugar dentro da estrutura. Isto torna o argumento para demonstrar a eliminação da regra Cut um tanto mais complicado, pois qualquer coisa pode acontecer acima de uma instância da regra Cut. Por outro lado, uma simplificação considerável pode ser feita porque no sistema BV a regra ai↑ cria apenas fórmulas atômicas. A dificuldade restante fica por parte de entender o que acontece, enquanto sobe-se em uma demonstração, ao redor dos átomos produzidos por um Cut atômico. Os dois átomos de um Cut atômico podem ser produzidos dentro de qualquer estrutura, e eles não pertencem a ramos distintos como no cálculo de seqüentes.\nUma abordagem possível para a demonstração da eliminação da regra Cut utiliza o teorema de splitting [?]. É importante observar que o sistema BV não possui a regra Cut como primitiva. A eliminação da regra Cut a que nos referimos aqui para o sistema MLL + mix + seq significa que:"
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 41",
      "text" : "Podemos acrescentar a regra Cut ai↑ ao sistema BV sem aumentar o conjunto de fórmulas prová-\nvies em MLL + mix+ seq. Ou seja, a regra Cut é admissível em BV.\nEm outras palavras, o sistema BV é completo para MLL + mix + seq sem ter a regra Cut,\no que torna sua implementação muito mais prática.\n3.1.5.1 Teorema de splitting\nA idéia de splitting pode ser entendida considerando um sistema de seqüentes em que não há regras de weakening e contraction. Considere o exemplo da lógica linear multiplicativa. Se temos uma demonstração do seqüente:\n⊢ F{A⊗B}\nonde F{A⊗ B} é uma fórmula que contém a subfórmula A⊗ B, sabemos com certeza que em algum lugar na demonstração existe uma, e apenas uma, instância da regra⊗ que separa A e B juntamente com seu contexto. Temos então a seguinte situação:\n− Π1\n‖ ‖\n⊢ A,Φ\n− Π2\n‖ ‖\n⊢ B,Ψ ⊗\n⊢ A⊗B,Φ,Ψ\n∆ ‖ ‖\n⊢ F{A⊗B} equivale a\n− Π2\n‖ ‖\n[B,Ψ] Π1 ‖ ‖\n([A,Φ], [B,Ψ]) s\n[([A,Φ], B),Ψ] s\n[(A,B),Φ,Ψ]\n∆ ‖ ‖\n[F (A,B),Γ]\nPodemos considerar, como mostrado à esquerda, uma demonstração para o seqüente dado como composta de três partes, ∆, Π1 e Π2. No cálculo das estruturas existem muitas demonstraçãos diferentes correspondentes à mesma demonstração em cálculo de seqüentes: elas diferem apenas na possível ordenação das regras. Regras no cálculo das estruturas têm menor granularidade emaior aplicabilidade. Mas, entre todas as demonstraçãos, deve haver uma que se encaixe no esquema da demonstração à direita da figura acima. Este exemplo ilustra precisamente a idéia por trás da técnica de splitting.\nA derivação ∆ acima implementa uma instância de context reduction 6 e um splitting pró-\nprio. De forma geral, podemos enunciar estes princípios da seguinte forma:\n1. Context reduction: Se S{R} é provável, então S{ } pode ser reduzido, de baixo para\ncima em uma demonstração, à estrutura [{ }, U ], tal que [R,U ] é provável. No exemplo acima, [F{ },Γ] é reduzido a [{ },Γ′ ] para algum Γ′.\n6Como veremos adiante, context reduction é um lema necessário para o teorema de splitting."
    }, {
      "heading" : "42 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "2. (Shallow) splitting: Se [(R,T ), P ] é provável, então P pode ser reduzido, de baixo para\ncima em uma demonstração, a [P1, P2 ], tal que [R,P1 ] e [T, P2 ] são prováveis. No exemplo acima, Γ′ é reduzido a [Φ,Ψ].\nO conceito de context reduction é demonstraçãodo usando o conceito de (shallow) splitting. Antes de prová-los, vamos introduzir duas proposições simples que serão utilizadas implicitamente ao longo da demonstração.\nProposição 31. O tamanho da premissa de uma derivação em BV não é maior que o tamanho da sua\nconclusão.\nProposição 32. Em BV, 〈R;T 〉 é provável se, e somente se, R e T são prováveis. Da mesma forma,\n(R,T ) é provável se, e somente se, R e T são prováveis.\nComo o cálculo das estruturas pode ser visto como um sistema de reescrita, podemos\nintroduzir uma terminologia análoga à destes sistemas.\nDefinição 33. As inferências do sistema BV são todas da forma S{V }\nρ S{U} , onde a estrutura U\né chamada de redex e V de contractum da instância da regra.\nTeorema 34 (Shallow Splitting). Para todas as estruturas R, T e P :\n1. Se [〈R;T 〉, P ] é provável em BV, então existem P1, P2 e 〈P1;P2〉 ‖ ‖ BV\nP\ntais que [R,P1 ] e [T, P2 ]\nsão prováveis em BV.\n2. Se [(R,T ), P ] é provável em BV, então existem P1, P2 e [P1, P2 ] ‖ ‖ BV\nP\ntais que [R,P1 ] e [T, P2 ]\nsão prováveis em BV.\nDemonstração. Todas as derivações da prova são feitas em BV. Vamos considerar a ordem lexicográfica ≺ sobre os números naturais definida como (m′, n′) ≺ (m,n) se, e somente se, oum′ < m, ou m′ = m e n′ < n. Considere as seguintes proposições: S(m,n) = ∀m′, n.∀R,T, P. ( ( (m′, n′) (m,n)\ne m′ = |occ [〈R;T 〉, P ]|\ne ∃\n−‖ ‖\n[〈R;T 〉, P ] de comprimento n′)\n=⇒ ∃P1, P2.( 〈P1;P2〉 ‖ ‖\nP\ne\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T, P2 ] ))"
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 43",
      "text" : "C(m,n) = ∀m′, n.∀R,T, P. ( ( (m′, n′) (m,n)\ne m′ = |occ [(R,T ), P ]|\ne ∃\n−‖ ‖\n[(R,T ), P ] de comprimento n′)\n=⇒ ∃P1, P2.( [P1, P2 ] ‖ ‖\nP\ne\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T, P2 ] ))\nO enunciado do teorema é equivalente a\n∀m,n.(S(m,n) e C(m,n))\nPodemos considerar (m,n) como uma medida de (S(m,n) e C(m,n)), e a prova é\numa indução, por ≺, sobre esta medida.\n• Casos Base\n1. R = ◦\n−‖ ‖\n[〈◦;T 〉, P ] equivale a\n〈◦;P 〉 ‖ ‖\nP\ne\n−‖ ‖\n[◦, ◦] e\n−‖ ‖\n[T, P ] equivale a\n−‖ ‖\n[T, P ]\n−‖ ‖\n[(◦, T ), P ] equivale a\n[◦, P ] ‖ ‖\nP\ne\n−‖ ‖\n[◦, ◦] e\n−‖ ‖\n[T, P ] equivale a\n−‖ ‖\n[T, P ]\n2. T = ◦\n−‖ ‖\n[〈R; ◦〉, P ] equivale a\n〈P ; ◦〉 ‖ ‖\nP\ne\n−‖ ‖\n[R,P ] e\n−‖ ‖\n[◦, ◦] equivale a\n−‖ ‖\n[R,P ]\n−‖ ‖\n[(R, ◦), P ] equivale a\n[P, ◦] ‖ ‖\nP\ne\n−‖ ‖\n[R,P ] e\n−‖ ‖\n[◦, ◦] equivale a\n−‖ ‖\n[R,P ]\n3. P = ◦\n44 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\n−‖ ‖\n[〈R;T 〉, ◦] equivale a\n〈◦; ◦〉 ‖ ‖\n◦\ne\n−‖ ‖\n[R, ◦] e\n−‖ ‖\n[T, ◦] equivale a\n−‖ ‖ R e −‖ ‖ T\n−‖ ‖\n[(R,T ), ◦] equivale a\n[◦, ◦] ‖ ‖\n◦\ne\n−‖ ‖\n[R, ◦] e\n−‖ ‖\n[T, ◦] equivale a\n−‖ ‖ R e −‖ ‖ T\n• Casos Indutivos\n1. ∀m′, n′.((m′, n′) ≺ (m,n) e S(m′, n′) e C(m′, n′)) =⇒ S(m,n) O\ntamanho de [〈R;T 〉, P ] é m e existe uma prova desta estrutura de tamanho n. Vamos considerar a instância de regra de derivação mais abaixo na prova:\n−‖ ‖\nQ ρ [〈R;T 〉, P ]\nOnde assumimos que ρ é não-trivial (ρ 6= equivale a ), pois de outra forma a hipótese de indução se aplicaria. Vamos argumentar baseados na posição do redex de ρ em [〈R;T 〉, P ]. As possibilidades são:\na) ρ = ai↓\ni. O redex está em R\n−‖ ‖\n[〈R′;T 〉, P ] ai↓\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP e\n−‖ ‖\n[R′, P1 ] ai↓\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\nii. O redex está em T\n−‖ ‖\n[〈R;T ′〉, P ] ai↓\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T ′, P2 ] ai↓\n[T, P2 ]\niii. O redex está em P\n3.1. O CÁLCULO DAS ESTRUTURAS 45\n−‖ ‖\n[〈R;T 〉, P ′ ] ai↓\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP ′ ai↓\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\nb) ρ = q↓\ni. O redex está em R\n−‖ ‖\n[〈R′;T 〉, P ] q↓\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP e\n−‖ ‖\n[R′, P1 ] q↓\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\nii. O redex está em T\n−‖ ‖\n[〈R;T ′〉, P ] q↓\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T ′, P2 ] q↓\n[T, P2 ]\niii. O redex está em P\n−‖ ‖\n[〈R;T 〉, P ′ ] q↓\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP ′ q↓\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\niv. R = 〈R′;R′′〉, P = [〈P ′;P ′′〉, U ] e\n−‖ ‖\n[〈[R′, P ′ ]; [〈R′′;T 〉, P ′′ ]〉, U ] q↓\n[〈R′;R′′;T 〉, 〈P ′;P ′′〉, U ]\nQueremos mostrar que existem Π1, Π2 e Π3 tais que:\n−‖ ‖\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉\nΠ1 ‖ ‖\nP e\n− Π2\n‖ ‖\n[R,P1 ] e\n− Π3\n‖ ‖\n[T, P2 ]\nOu seja, queremos mostrar que:\n46 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\n−‖ ‖\n[〈R′;R′′;T 〉, 〈P ′;P ′′〉, U ] equivale a\n〈P1;P2〉\nΠ1 ‖ ‖\n[〈P ′;P ′′〉, U ] e\n− Π2\n‖ ‖\n[〈R′;R′′〉, P1 ] e\n− Π3\n‖ ‖\n[T, P2 ]\nUmavez que |occ [〈[R′, P ′ ]; [〈R′′;T 〉, P ′′ ]〉, U ]| = |occ [〈R′;R′′;T 〉, 〈P ′;P ′′〉, U ]| mas n′ < n, podemos aplicar a hipótese de indução e obter:\n〈U1;U2〉\nΠ4 ‖ ‖\nU e\n− Π5\n‖ ‖\n[R′, P ′, U1 ] e\n− Π6\n‖ ‖\n[〈R′′;T 〉, P ′′, U2 ]\nUma vez que |occ [〈R′′;T 〉, P ′′, U2 ]| < |occ [〈R′;R′′;T 〉, 〈P ′;P ′′〉, U ]|, podemos aplicar a hipótese de indução e obter:\n〈P ′1;P2〉\nΠ7 ‖ ‖\n[P ′′, U2 ] e\n− Π8\n‖ ‖\n[R′′, P ′1 ] e\n− Π9\n‖ ‖\n[T,U2 ]\nAgora podemos fazer P1 = 〈[p′, U ′1 ];P ′ 1〉 e construir Π1, Π2 e Π3 da seguinte forma:\n〈P1;P2〉 =\n〈[P ′, U1 ];P ′ 1;P2〉\nΠ7 ‖ ‖\n〈[P ′, U1 ]; [P ′′, U2 ]〉\nq↓ [〈P ′;P ′′〉, 〈U1;U2〉]\nΠ4 ‖ ‖\n[〈P ′;P ′′〉, U ] =\nP\n \n\nΠ1.\n− Π5\n‖ ‖\n[R′, P ′, U1 ]\nΠ8 ‖ ‖\n〈[R′, P ′, U1 ]; [R ′′, P ′1 ]〉\nq↓ [〈R′;R′′〉, 〈[P ′, U1 ];P ′ 1〉]\n= [R,P1 ]\n \n\nΠ2.\n3.1. O CÁLCULO DAS ESTRUTURAS 47\n− Π9\n‖ ‖\n[T, P2 ]\n}\nΠ3.\nv. P = [〈P ′;P ′′〉, U ′, U ′′ ] e\n−‖ ‖\n[〈[〈R;T 〉, P ′, U ′ ];P ′′〉, U ′′ ] q↓\n[〈R;T 〉, 〈P ′;P ′′〉, U ′, U ′′ ]\nQueremos mostrar que existem Π1, Π2 e Π3 tais que:\n−‖ ‖\n[〈R;T 〉, P ] equivale a\n〈P1, P2〉\nΠ1 ‖ ‖\n[〈P ′;P ′′〉, U ′, U ′′ ] e\n− Π2\n‖ ‖\n[R,P1 ] e\n− Π3\n‖ ‖\n[T, P2 ]\nUmavez que |occ [〈[〈R;T 〉, P ′, U ′ ];P ′′〉, U ′′ ]| = |occ [〈R;T 〉, 〈P ′;P ′′〉, U ′, U ′′ ]| mas n′ < n, podemos aplicar a hipótese de indução e obter:\n〈U1;U2〉\nΠ4 ‖ ‖\nU ′′ e\n− Π5\n‖ ‖\n[〈R;T 〉, P ′, U ′, U1 ] e\n− Π6\n‖ ‖\n[P ′′, U2 ]\nUma vez que |occ [〈R;T 〉, P ′, U ′, U1 ]| < |occ [〈R;T 〉, 〈P ′;P ′′〉, U ′, U ′′ ]|, podemos aplicar a hipótese de indução e obter:\n〈P ′1;P ′ 2〉\nΠ7 ‖ ‖\n[P ′, U ′, U1 ] equivale a\n− Π8\n‖ ‖\n[R,P ′1 ] e\n− Π9\n‖ ‖\n[T, P ′2 ]\nAgora podemos fazer P1 = P ′1 e P2 = P ′ 2 e construir Π1, Π2 e Π3 da seguinte forma:\n48 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\n〈P1;P2〉 =\n〈P ′1;P ′ 2〉\nΠ7 ‖ ‖\n[P ′, U1, U ′ ]\nΠ6 ‖ ‖\n[〈[P ′, U1 ]; [P ′′, U2 ]〉, U ′ ] q↓\n[〈P ′;P ′′〉, U ′, 〈U1;U2〉]\nΠ4 ‖ ‖\n[〈P ′;P ′′〉, U ′, U ′′ ] =\nP\n \n\nΠ1.\n− Π8\n‖ ‖\n[R,P ′1 ] =\n[R,P1 ]\n \n\nΠ2.\n− Π9\n‖ ‖\n[T, P ′2 ] =\n[T, P2 ]\n \n\nΠ3.\nc) ρ = s\ni. O redex está em R\n−‖ ‖\n[〈R′;T 〉, P ] s\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP e\n−‖ ‖\n[R′, P1 ] s\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\nii. O redex está em T\n−‖ ‖\n[〈R;T ′〉, P ] s\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T ′, P2 ] s\n[T, P2 ]\niii. O redex está em P\n3.1. O CÁLCULO DAS ESTRUTURAS 49\n−‖ ‖\n[〈R;T 〉, P ′ ] s\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉 ‖ ‖\nP ′ s\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\niv. P = [(P ′;P ′′), U ′, U ′′ ] e\n−‖ ‖\n[([〈R;T 〉, P ′, U ′ ], P ′′), U ′′ ] s\n[〈R;T 〉, (P ′, P ′′), U ′, U ′′ ]\nQueremos mostrar que existem Π1, Π2 e Π3 tais que:\n−‖ ‖\n[〈R;T 〉, P ] equivale a\n〈P1;P2〉\nΠ1 ‖ ‖\n[(P ′, P ′′), U ′, U ′′ ] e\n− Π2\n‖ ‖\n[R,P1 ] e\n− Π3\n‖ ‖\n[T, P2 ]\nUmavez que |occ [〈R;T 〉, (P ′, P ′′), U ′, U ′′ ]| = |occ [([〈R;T 〉, P ′, U ′ ], P ′′), U ′′ ]| mas n′ < n, podemos aplicar a hipótese de indução e obter:\n[U1, U2 ]\nΠ4 ‖ ‖\nU ′′ e\n− Π5\n‖ ‖\n[〈R;T 〉, P ′, U ′, U1 ] e\n− Π6\n‖ ‖\n[P ′′, U2 ]\nUma vez que |occ [〈R;T 〉, P ′, U ′, U1 ]| < |occ [〈R;T 〉, (P ′, P ′′), U ′, U ′′ ]|, podemos aplicar a hipótese de indução e obter:\n〈P ′1;P ′ 2〉\nΠ7 ‖ ‖\n[P ′, U ′, U1 ] e\n− Π8 ‖‖ [R,P ′1 ] e − Π9 ‖‖ [T, P ′2 ]\nAgora podemos fazer P1 = P ′1 e P2 = P ′ 2 e construir Π1, Π2 e Π3 da seguinte forma:\n50 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\n〈P1;P2〉 =\n〈P ′1;P ′ 2〉\nΠ7 ‖ ‖\n[P ′, U ′, P1 ]\nΠ6 ‖ ‖\n([P ′′, U2 ], [P ′, U ′, P1 ])\ns [([P ′, U ′, U1 ], P\n′′), U2 ] s\n[(P ′, P ′′), U ′, U1, U2 ]\nΠ7 ‖ ‖\n[(P ′, P ′′), U ′, U ′′ ] =\nP\n \n\nΠ1\n− Π8\n‖ ‖\n[R,P ′1 ] =\n[R,P1 ]\n \n\nΠ2\n− Π9\n‖ ‖\n[T, P ′2 ] =\n[T, P2 ]\n \n\nΠ3\n2. ∀m′, n′.((m′, n′) ≺ (m,n) e S(m′, n′) e C(m′, n′)) =⇒ C(m,n) O\ntamanho de [(R,T ), P ] é m e existe uma prova desta estrutura de tamanho n. Vamos considerar a instância de regra de derivação mais abaixo na prova:\n−‖ ‖\nQ ρ [(R,T ), P ]\nOnde assumimos que ρ é não-trivial (ρ 6= equivale a ), pois de outra forma a hipótese de indução se aplicaria. Vamos argumentar baseados na posição do redex de ρ em [(R,T ), P ]. As possibilidades são:\na) ρ = ai↓\ni. O redex está em R\n−‖ ‖\n[(R′, T ), P ] ai↓\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP e\n−‖ ‖\n[R′, P1 ] ai↓\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]"
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 51",
      "text" : "ii. O redex está em T\n−‖ ‖\n[(R,T ′), P ] ai↓\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T ′, P2 ] ai↓\n[T, P2 ]\niii. O redex está em P\n−‖ ‖\n[(R,T ), P ′ ] ai↓\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP ′ ai↓\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\nb) ρ = q↓\ni. O redex está em R\n−‖ ‖\n[(R′, T ), P ] q↓\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP e\n−‖ ‖\n[R′, P1 ] q↓\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\nii. O redex está em T\n−‖ ‖\n[(R,T ′), P ] q↓\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T ′, P2 ] q↓\n[T, P2 ]\niii. O redex está em P\n−‖ ‖\n[(R,T ), P ′ ] q↓\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP ′ q↓\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\niv. P = [〈P ′;P ′′〉, U ′, U ′′ ] e\n−‖ ‖\n[〈[(R,T ), P ′, U ′ ];P ′′〉, U ′′ ] q↓\n[(R,T ), 〈P ′;P ′′〉, U ′, U ′′ ]"
    }, {
      "heading" : "52 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "Queremos mostrar que existem Π1, Π2 e Π3 tais que:\n−‖ ‖\n[(R,T ), P ] equivale a\n[P1;P2 ] Π1 ‖ ‖\n[〈P ′;P ′′〉, U ′, U ′′ ] e\n− Π2\n‖ ‖\n[R,P1 ] e\n− Π3\n‖ ‖\n[T, P2 ]\nUmavez que |occ [〈[(R,T ), P ′, U ′ ];P ′′〉, U ′′ ]| = |occ [(R,T ), 〈P ′;P ′′〉, U ′, U ′′ ]| mas n′ < n, podemos aplicar a hipótese de indução e obter:\n〈U1;U2〉\nΠ4 ‖ ‖\nU ′′ e\n− Π5\n‖ ‖\n[(R,T ), P ′, U ′, U1 ] e\n− Π6\n‖ ‖\n[P ′′, U2 ]\nUma vez que |occ [(R,T ), P ′, U ′, U1 ]| < |occ [〈[(R,T ), P ′, U ′ ];P ′′〉, U ′′ ]|, podemos aplicar a hipótese de indução e obter:\n[P ′1, P ′ 2 ] Π7 ‖ ‖\n[P ′, U ′, U1 ] equivale a\n− Π8\n‖ ‖\n[R,P ′1 ] e\n− Π9\n‖ ‖\n[T, P ′2 ]\nAgora podemos fazer P1 = P ′1 e P2 = P ′ 2 e construir Π1, Π2 e Π3 da seguinte forma:\n[P1, P2 ] =\n[P ′1, P ′ 2 ]\nΠ7 ‖ ‖\n[P ′, U1, U ′ ]\nΠ6 ‖ ‖\n[〈[P ′, U1 ]; [P ′′, U2 ]〉, U ′ ] q↓\n[〈P ′;P ′′〉, U ′, 〈U1;U2〉]\nΠ4 ‖ ‖\n[〈P ′;P ′′〉, U ′, U ′′ ] =\nP\n \n\nΠ1.\n− Π8\n‖ ‖\n[R,P ′1 ] =\n[R,P1 ]\n \n\nΠ2.\n3.1. O CÁLCULO DAS ESTRUTURAS 53\n− Π9\n‖ ‖\n[T, P ′2 ] =\n[T, P2 ]\n \n\nΠ3.\nc) ρ = s\ni. O redex está em R\n−‖ ‖\n[(R′, T ), P ] s\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP e\n−‖ ‖\n[R′, P1 ] s\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\nii. O redex está em T\n−‖ ‖\n[(R,T ′), P ] s\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T ′, P2 ] s\n[T, P2 ]\niii. O redex está em P\n−‖ ‖\n[(R,T ), P ′ ] s\n[(R,T ), P ] equivale a\n[P1, P2 ] ‖ ‖\nP ′ s\nP e\n−‖ ‖\n[R,P1 ] e\n−‖ ‖\n[T, P2 ]\niv. R = (R′, R′′), T = (T ′, T ′′), P = [P ′, P ′′ ] e\n[([(R′, T ′), P ′ ], R′′, T ′′), P ′′ ] s\n[(R′, R′′, T ′, T ′′), P ′, P ′′ ]\nQueremos mostrar que existem Π1, Π2 e Π3 tais que:\n−‖ ‖\n[(R,T ), P ] equivale a\n[P1;P2 ] Π1 ‖ ‖ [P ′, P ′′ ] e\n− Π2\n‖ ‖\n[(R′, R′′), P1 ] e\n− Π3\n‖ ‖\n[(T ′, T ′′), P2 ]\nUmavez que |occ [([(R′, T ′), P ′ ], R′′, T ′′), P ′′ ]| = |occ [(R′, R′′, T ′, T ′′), P ′, P ′′ ]| mas n′ < n, podemos aplicar a hipótese de indução e obter:\n54 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\n[P ′1, P ′ 2 ] Π4 ‖ ‖\nP ′′ e\n− Π5\n‖ ‖\n[(R′;T ′), P ′, P ′1 ] e\n− Π6\n‖ ‖\n[(R′′, T ′′), P ′2 ]\nUma vez que |occ [(R′;T ′), P ′, P ′1 ]| < |occ [(R ′, R′′, T ′, T ′′), P ′, P ′′ ]|, podemos aplicar a hipótese de indução e obter:\n[P ′′1 , P ′′ 2 ]\nΠ7 ‖ ‖ [P ′, P ′1 ] e\n− Π8\n‖ ‖\n[R′, P ′′1 ] e\n− Π9\n‖ ‖\n[T ′, P ′′2 ]\nUma vez que |occ [(R′′, T ′′), P ′2 ]| < |occ [(R ′, R′′, T ′, T ′′), P ′, P ′′ ]|, podemos aplicar a hipótese de indução e obter:\n[P ′′′1 , P ′′′ 2 ]\nΠ10 ‖ ‖\nP ′′2 e\n− Π11 ‖‖ [R′′, P ′′′1 ] e − Π12 ‖‖ [T ′′, P ′′′2 ]\nAgora podemos fazer P1 = [P ′′1 , P ′′′ 1 ] e P2 = [P ′′ 2 , P ′′′ 2 ] e construir Π1, Π2 e Π3 da seguinte forma:\n[P1, P2 ] =\n[P ′′1 , P ′′ 2 , P ′′′ 1 , P ′′′ 2 ]\nΠ10 ‖ ‖\n[P ′′1 , P ′′ 2 , P ′ 2 ]\nΠ7 ‖ ‖\n[P ′, P ′1, P ′ 2 ]\nΠ4 ‖ ‖\n[P ′, P ′′ ] =\nP\n \n\nΠ1\n− Π11\n‖ ‖\n[R′′, P ′′′1 ]\nΠ8 ‖ ‖\n[([R′, P ′′1 ], R ′′), P ′′′1 ]\ns [(R′, R′′), P ′′1 , P ′′′ 1 ]\n= [R,P1 ]\n \n\nΠ2\n3.1. O CÁLCULO DAS ESTRUTURAS 55\n− Π12\n‖ ‖\n[T ′′, P ′′′2 ]\nΠ9 ‖ ‖\n[([T ′, P ′′2 ], T ′′), P ′′′2 ]\ns [(T ′, T ′′), P ′′2 , P ′′′ 2 ]\n= [T, P2 ]\n \n\nΠ3\nv. P = [(P ′, P ′′), U ′, U ′′ ] e\n[([(R,T ), P ′, U ′ ], P ′′), U ′′ ] s\n[(R,T ), (P ′, P ′′), U ′, U ′′ ]\nQueremos mostrar que existem Π1, Π2 e Π3 tais que:\n−‖ ‖\n[(R,T ), P ] equivale a\n[P1, P2 ] Π1 ‖ ‖\n[(P ′, P ′′), U ′, U ′′ ] e\n− Π2\n‖ ‖\n[R,P1 ] e\n− Π3\n‖ ‖\n[T, P2 ]\nUmavez que |occ [([(R,T ), P ′, U ′ ], P ′′), U ′′ ]| = |occ [(R,T ), (P ′, P ′′), U ′, U ′′ ]| mas n′ < n, podemos aplicar a hipótese de indução e obter:\n[U1, U2 ]\nΠ4 ‖ ‖\nU ′′ e\n− Π5\n‖ ‖\n[(R,T ), P ′, U ′, U1 ] e\n− Π6\n‖ ‖\n[P ′′, U2 ]\nUma vez que |occ [(R,T ), P ′, U ′, U1 ]| < |occ [([(R,T ), P ′, U ′ ], P ′′), U ′′ ]|, podemos aplicar a hipótese de indução e obter:\n[P ′1, P ′ 2 ] Π7 ‖ ‖\n[P ′, U ′, U1 ] e\n− Π8\n‖ ‖\n[R,P ′1 ] e\n− Π9\n‖ ‖\n[T, P ′2 ]\nAgora podemos fazer P1 = P ′1 e P2 = P ′ 2 e construir Π1, Π2 e Π3 da seguinte forma:\n56 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\n[P1, P2 ] =\n[P ′1, P ′ 2 ]\nΠ7 ‖ ‖\n[P ′, U ′, U1 ]\nΠ6 ‖ ‖\n([P ′, U ′, U1 ], [P ′′, U2 ])\ns [([P ′, U ′, U1 ], P\n′′), U2 ] s\n[(P ′, P ′′), U ′, U1, U2 ]\nΠ4 ‖ ‖\n[(P ′, P ′′), U ′, U ′′ ] =\nP\n \n\nΠ1\n− Π8\n‖ ‖\n[R,P ′1 ] =\n[R,P1 ]\n \n\nΠ2\n− Π9\n‖ ‖\n[T, P ′2 ] =\n[T, P2 ]\n \n\nΠ3\nTeorema 35 (Context Reduction). Para todas as estruturas R e para todos os contextos S{ } tais que S{R} é provável em BV, existe uma estrutura U tal que, para todas as estruturas X, existem\nderivações:\n[X,U ] ‖ ‖ BV S{X} e\n−‖ ‖ BV [R,U ]\nDemonstração. Todas as derivações da prova são feitas em BV. Por indução no tamanho de S{◦}:\n• Caso Base\n|S{◦}| = 0 =⇒ S{X} = X =⇒\n[X,U ] ‖ ‖ S{X} equivale a X ‖ ‖ X =⇒ U = ◦"
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 57",
      "text" : "Logo:\n[X,U ] ‖ ‖ S{X} e\n−‖ ‖\n[R,U ] equivale a\nX ‖ ‖ X e\n−‖ ‖ U\n• Casos Indutivos\n1. S = 〈S′{};P 〉, P 6= ◦\n−‖ ‖\n〈S′{R};P 〉 equivale a\n− Π1\n‖ ‖\nS′{R} e\n− Π2\n‖ ‖ P\nLogo podemos fazer a seguinte derivação:\nS′{X} Π2 ‖ ‖\n〈S′{X};P 〉\nUma vez que |occ S′{X}| < |occ 〈S′{X};P 〉|, podemos aplicar a hipótese de indução e obter:\n[X,U ] ‖ ‖ S′{X} e\n−‖ ‖\n[R,U ]\n2. S{} = [S′{}, P ], P 6= ◦ e S′{} não é uma estrutura par própria.\nSubcasos:\n– S′{◦} = ◦\nEntão nós temos:\nS{R} equivale a [S′{R}, P ] equivale a [R,P ]\nFazendo U = P temos então:\n[X,P ] ‖ ‖ [X,P ] e\n−‖ ‖\n[R,P ]\n– S′{} = 〈S′′{};P ′〉, P ′ 6= ◦\nTemos:\n−‖ ‖\nS{R} equivale a\n−‖ ‖\n[S′{R}, P ] equivale a\n−‖ ‖\n[〈S′′{R};P ′〉, P ]"
    }, {
      "heading" : "58 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "Pelo teorema de Shallow Splitting, temos:\n−‖ ‖\n[〈S′′{R}, P ′〉, P ] =⇒\n〈P1;P2〉\nΠ1 ‖ ‖\nP e\n− Π2\n‖ ‖\n[S′′{R}, P1 ] e\n− Π3\n‖ ‖\n[P ′, P2 ]\nLogo:\n[S′′{R}, P1 ]\nΠ3 ‖ ‖\n〈[S′′{R}, P1 ]; [P ′, P2 ]〉 q↓ [〈S′′{R};P ′〉, 〈P1;P2〉]\nΠ1 ‖ ‖\n[〈S′′{R};P ′〉, P ]\nUma vez que |occ [S′′{}, P1 ]| < |occ S{}|, podemos aplicar a hipótese de indução e obter:\n[X,U ] ‖ ‖\n[S′′{X}, P1 ] e\n−‖ ‖\n[R,U ]\nPodemos proceder analogamente quando S′{} = 〈P ′;S′′{}〉.\n– S′{} = (S′′{}, P ′), P 6= ◦\nTemos que:\n−‖ ‖\nS{R} equivale a [S′{R}, P ] equivale a [(S′′{R}, P ′), P ]\nPelo teroema de Shallow Splitting, temos:\n−‖ ‖\n[(S′′{R}, P ′), P ] =⇒\n[P1, P2 ] Π1 ‖ ‖\nP e\n− Π2\n‖ ‖\n[S′′{R}, P1 ] e\n− Π3\n‖ ‖\n[P ′, P2 ]\nLogo:\n[S′′{R}, P1 ]\nΠ3 ‖ ‖\n[([P ′, P2 ], S ′′{R}), P1 ]\ns [(S′′{R}, P ′), P1, P2 ]\nΠ1 ‖ ‖\n[(S′′{R}, P ′), P ]"
    }, {
      "heading" : "3.1. O CÁLCULO DAS ESTRUTURAS 59",
      "text" : "Uma vez que |occ [S′′{}, P1 ]| < |occ S{}|, podemos aplicar a hipótese de indução e obter:\n[X,U ] ‖ ‖\n[S′′{X}, P1 ] e\n−‖ ‖\n[R,U ]\nPodemos proceder analogamente quando S′{} = (P ′;S′′{}).\n3. S{} = (S′{}, P ), P 6= ◦\nTemos que:\n−‖ ‖\n(S′{R}, P ) equivale a\n− Π1\n‖ ‖\nS′{R} e\n− Π2\n‖ ‖ P\nLogo:\nS′{X} Π2 ‖ ‖\n(S′{X}, P )\nUma vez que |occ S′{}| < |occ S{}|, podemos aplicar a hipótese de indução e obter:\n[X,U ] ‖ ‖ S′{X} ‖ ‖\n(S′{X}, P ) e\n−‖ ‖\n[R,U ]\nCorolário 36 (Splitting). Para todas as estruturas R, T e para todos os contextos S{}:\n1. Se S〈R;T 〉 é provável em BV, então existem estruturas S1 e S2 tais que, para todas estrutura\nX, existe uma derivação:\n[X, 〈S1;S2〉] ‖ ‖ BV\nS{X} e\n−‖ ‖ BV\n[R,S1 ] e\n−‖ ‖ BV\nT, S2\n2. Se S(R,T ) é provável em BV, então existem estruturas S1 e S2 tais que, para todas estrutura\nX, existe uma derivação:\n60 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\n[X,S1, S2 ] ‖ ‖ BV\nS{X} e\n−‖ ‖ BV\n[R,S1 ] e\n−‖ ‖ BV\nT, S2\nDemonstração. Todas as derivações da prova são feitas em BV. Primeiramente aplicamos o teorema de Context Reduction e então aplicamos o teorema de Shallow Splitting.\n1. −‖ ‖\nS〈R;T 〉\nContext Reduction\n⇓\n[U,X ] Π1 ‖ ‖\nS{X} e\n− Π2\n‖ ‖\n[〈R;T 〉, U ]\nShallow Splitting\n⇓\n[U,X ] Π1 ‖ ‖\nS{X} e\n〈S1;S2〉 Π3 ‖ ‖\nU e\n− Π4\n‖ ‖\n[R,S1 ] e\n− Π5\n‖ ‖\n[T, S2 ]\nEntão nós combinamos Π1 e Π3 para obter Π6:\n[X, 〈S1;S2〉]\nΠ3 ‖ ‖ [U,X ] Π1 ‖ ‖\nS{X} equivale a\n[X, 〈S1;S2〉]\nΠ6 ‖ ‖\nS{X}\nE com Π4, Π5 e Π6 temos o caso 1 provado.\n3.1. O CÁLCULO DAS ESTRUTURAS 61\n2. −‖ ‖\nS(R,T )\nContext Reduction\n⇓\n[X,U ] Π1 ‖ ‖\nS{X} e\n− Π2\n‖ ‖\n[(R,T ), U ]\nShallow Splitting\n⇓\n[X,U ] Π1 ‖ ‖\nS{X} e\n[S1, S2 ] Π3 ‖ ‖\nU e\n− Π4\n‖ ‖\n[R,S1 ] e\n− Π5\n‖ ‖\n[T, S2 ]\nEntão nós combinamos Π1 e Π3 para obter Π6:\n[X,S1, S2 ]\nΠ3 ‖ ‖ [X,U ] Π1 ‖ ‖\nS{X} equivale a\n[X,S1, S2 ]\nΠ6 ‖ ‖\nS{X}\nE com Π4, Π5 e Π6 temos o caso 2 provado."
    }, {
      "heading" : "3.1.5.2 Eliminação da regra Cut",
      "text" : "Antes de demonstrar que a regra de Cut ai↑ é admissível, é preciso introduzir uma proposição importante:\nProposição 37. Para todo contexto S{ } e estruturas R, T existe uma derivação\nS [R,T ] ‖ ‖ {q↓, s }\n[S{R}, T ] .\nTeorema 38. A regra ai↑ é admissível em BV.\nDemonstração. Considere a demonstração\n62 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS\n−‖ ‖ BV S(a, ā) ai↑\nS{◦}\nPelo corolário 36, existem S1 e S2 tais que há derivações:\n[S1, S2 ] ‖ ‖ BV\nS{◦} ,\n− Π1\n‖ ‖ BV\n[a, S1 ] e\n− Π2\n‖ ‖ BV [ā, S2 ]\nConsidere a demonstração Π1. Deve haver um contexto S′1{ } tal que S1 = S ′ 1{ā} e\n−‖ ‖ BV\nS′′{◦} ai↓\nS′′ [a, ā]\nΠ1 ‖ ‖ BV\n[a, S′1{ā}]\npara algum S′′{ }, onde nós destacamos a instância de ai↓ na qual a ocorrência de a interage com a ocorrência de ā que vem de S′1{ā}. Podemos substituir cada ocorrência de a e ā emΠ1 por ◦, e obtemos em BV uma demonstração de S′1{◦}. Analogamente, podemos transformar Π2 em uma demonstração em BV de S′2{◦} tal que S2 = S ′ 2{a}. Podemos construir então a seguinte demonstração:\n−‖ ‖ BV S′1{◦} ‖ ‖ BV\nS′1{S ′ 2{◦}}\nai↓ S′1{S\n′ 2 [a, ā]} ‖ ‖ BV\n[S′1{ā}, S ′ 2{a}]\n‖ ‖ BV\nS{◦}\nonde usamos duas vezes a proposição 37. Podemos repetir indutivamente este argumento, começando do topo, para qualquer demonstração em BV ∪ {ai↑}, eliminando todas as instâncias de ai↑ uma a uma."
    }, {
      "heading" : "3.2. REDUZINDO O NÃO DETERMINISMO NO CÁLCULO DAS ESTRUTURAS 63",
      "text" : ""
    }, {
      "heading" : "3.2 Reduzindo o não determinismo no cálculo das estruturas",
      "text" : "Uma das possíveis abordagens para reduzir o não-determinismo do cálculo das estruturas é limitar as possibilidades de aplicação de regras durante a construção de uma demonstração. Em [?] esta abordagem é tomada, e um sistema equivalente ao sistema BV é proposto, mas com regras reprojetadas de forma a diminuir o não-determinismo de sua aplicação. A solução proposta realmente diminui o não-determinismo, mas é uma abordagem basicamente operacional. Esta seção apresenta a abordagem proposta e os principais resultados obtidos.\nA idéia central é reprojetar as regras switch e seq de tal forma que sua aplicação contribua para encurtar o tamanho da demonstração. Freqüentemente, regras de inferência podem ser aplicadas de muitas formas diferentes. Entretanto, apenas algumas dessas aplicações podem conduzir a uma demonstração. Por exemplo, para a estrutura [(ā, b̄), a, b] existem doze formas distintas de se aplicar, de baixo para uma instância de switch, duas delas sendo:\n([ā, a, b], b̄) s [(ā, b̄), a, b] e\n[([ā, a], b̄), b] s\n[(ā, b̄), a, b]\nA primeira instância não leva a uma demonstração, enquanto a segunda pode levar. De\nfato, das doze aplicações possíveis, apenas duas podem levar a uma demonstração.\nDefinição 39. Dada uma estrutura S, a notação at S indica o conjunto de todos os átomos que aparecem em S.\nProposição 40. Se uma estrutura R tem uma demonstração em BV então, para cada átomo a que\naparece em R, há um átomo ā em R tal que a ↓R ā.\nDefinição 41. Seja a regra interaction switch:\nS([R,W ], T ) is\nS [(R,T ),W ]\nonde at W ∩ at R 6= ∅\nO objetivo do interaction switch é evitar que apliquemos o switch desnecessariamente, uma vez que só faz sentido colocar as estruturas R e W em par se elas tiverem átomos opostos, de forma a facilitar o futuro uso de uma regra ai↓.\nDefinição 42. Seja o sistema BV com interaction switch, ou sistema BVs, o sistema {◦ ↓ ,ai↓, is,q↓}. Seja o sistema BV com lazy interaction switch, ou sistema BVsl, o sistema resultante da substituição da regra is em BVs pela sua instância, chamada de lazy interaction switch, ou lis, onde a estruturaW não é um par próprio.\nÉ possível demonstrar que:\nTeorema 43. Os sistemas BV, BVsl e BVs são fortemente equivalentes."
    }, {
      "heading" : "64 CAPÍTULO 3. CÁLCULO DAS ESTRUTURAS",
      "text" : "A demonstração encontra-se em [?]. À primeira vista, as regras switch e seq parecem ter naturezas diferentes devido aos operadores diferentes sobre os quais elas trabalham. Entretanto, uma inspeção mais cuidadosa mostra que ambas as regras lidam com o contexto das estruturas sobre as quais se aplicam: enquanto a regra switch reduz as interações nas estruturas que envolvem uma estrutura copar (numa visão de baixo para cima), a regra seq faz a mesma coisa com as estruturas envolvendo uma estrutura seq. Nesse sentido, podem-se estender os conceitos de redefinição da regra switch para a regra seq.\nDefinição 44. Seja o sistema lazy seq V, ou QVI, o sistema que consiste das seguintes regras\nS〈[R,T ]; [U, V ]〉 q1 ↓\nS [〈R;U〉, 〈T ;V 〉]\nS〈R;T 〉 q2 ↓\nS [R,T ]\nS〈[R,W ];T 〉 lq3 ↓\nS [W, 〈R;T 〉]\nS〈R; [T,W ]〉 lq3 ↓\nS [W, 〈R;T 〉]\nonde W não é uma estrutura par própria, e nenhuma das estruturas R, T , U , V ou W é\na unidade ◦.\nProposição 45. Os sistemas QVI e {q↓} são equivalentes.\nProposição 46. Seja o sistema S ∈ {BV, BVs, BVsl}. O sistema resultante da substituição da regra q↓ em mathscrS pelo sistema QVI é equivalente ao sistema BV.\nDefinição 47. As seguintes regras são chamadas de interaction seq rule 1, lazy interaction seq rule 3 e lazy interaction seq rule 4, respectivamente:\nS〈[R,T ]; [U, V ]〉 iq1 ↓\nS [〈R;U〉, 〈T ;V 〉]\nS〈[R,W ];T 〉 liq3 ↓\nS [W, 〈R;T 〉]\nS〈R; [T,W ]〉 liq4 ↓\nS [W, 〈R;T 〉]\nonde em iq1 ↓temos que at R̄ ∩ at T 6= ∅ e at Ū ∩ at V 6= ∅; em liq3 ↓e em liq4 ↓temos que at R̄ ∩ at W 6= ∅ e W não é uma estrutura par própria. O sistema resultante da substituição da regra seq no sistema BVsl pelas regras iq1 ↓, q2 ↓, liq3 ↓e liq4 ↓é chamado de interaction BV, ou BVi.\nTeorema 48. Os sistemas BV e BVi são equivalentes.\nVeja [?] para a demonstração do teorema. Na aplicação de regras switch e seq de baixo para cima durante a construção de uma demonstração, além de promover a interação entre alguns átomos, a interação entre alguns átomos pode ser quebrada. Entretanto, se a estrutura a ser demonstraçãoda consiste de pares de átomos distintos, quebrar a interação entre átomos duais (numa visão de baixo para cima), conduz a uma estrutura não-provável. As definições seguintes introduzem uma nova restrição sobre as regras de inferência, que explora esta observação e permite que apenas instâncias “cautelosas” das regras de inferência, ou seja, que não quebram essas interações entre átomos duais."
    }, {
      "heading" : "3.2. REDUZINDO O NÃO DETERMINISMO NO CÁLCULO DAS ESTRUTURAS 65",
      "text" : "Definição 49. Seja pruned switch a regra ps abaixo, onde at T ∩ at W = ∅, e seja pruned seq a regra pq ↓ abaixo, onde at T̄ ∩ at U = ∅ e at R̄ ∩ at V = ∅:\nS([R,W ], T ) ps\nS [(R,T ),W ]\n〈[R,T ]; [U, V ]〉 pq ↓\nS [〈R;U〉, 〈T ;V 〉]\nSeja pruned BV, ou sistema BVp, o sistema {◦ ↓,ai↓,ps,pq ↓}.\nProposição 50. Seja P uma estrutura em BV que consista de pares de átomos distintos e π uma demonstração de P em BVi. Em π todas as intâncias da regra s são instâncias da regra ps; e todas as instâncias das regras iq1 ↓, q2 ↓, liq3 ↓ e liq4 ↓ são instâncias da regra pq ↓.\nA demonstração encontra-se em [?]. Em outras palavras, a proposição 50 diz que, em uma demonstração, todas as instâncias de switch e seq devem obedecer às restrições do sistema BVp. Em termos práticos, isso significa que, ao implementar o sistema BVi, deve-se checar, quando da aplicação de uma regra, se ela satisfaz BVp. Se não satisfizer, ela não deve ser aplicada, pois não levará a uma demonstração."
    }, {
      "heading" : "3.2.1 Análise do estado da arte",
      "text" : "A solução apresentada na seção 3.2 realmente diminui o não determinismo do cálculo das estruturas. A abordagem consiste em checar, a cada passo na construção de uma demonstração, se a aplicação da regra pode ser realizada sem atingir um estágio do qual não se pode sair. Trata-se de uma solução válida, mas que apresenta as seguintes restrições:\n1. É uma solução operacional. Durante a implementação do sistema, uma série de checa-\ngens é necessária para verificar se as regras podem ser aplicadas ou não.\n2. Não emprega o conceito de demonstração uniforme, no sentido de que não apresenta\numa estratégia de demonstração teórica.\nUma questão que permanece em aberto é: seria possível resolver o problema do não-determinismo\nsem recorrer a uma solução operacional? É esta a principal contribuição deste trabalho: uma solução não operacional para a implementação de um fragmento do sistema FBV. A solução é apresentada no Capítulo 4.\nCapítulo 4\nAspectos computacionais do cálculo das estruturas"
    }, {
      "heading" : "4.1 Objetivo",
      "text" : "É interessante ter a liberdade e expressividade do cálculo das estruturas. Entretanto, quando se está tentando construir uma demonstração, mais liberdade significa um espaço de busca maior. É desejável restringir a busca caso estejamos procurando por implementações eficientes dos sistemas dedutivos. Teoremas de splitting representam um papel chave para reduzir o não-determinismo, uma vez que eles proporcionam um balanço entre tamanho de demonstrações e largura do espaço de busca, e essa proporção pode ser variada conforme se desejar.\nQuanto ao cálculo das estruturas, estamos hoje na mesma situação em que se encontrava o cálculo de seqüentes antes que Dale Miller introduzisse a noção de demonstrabilidade uniforme, que é uma maneira de casar demonstrabilidade e a demonstrações dirigidas a objetivo1, necessárias em implementações.\nNesse momento surge a pergunta: qual seria uma boa noção de uma demonstração dirigida a objetivo no caso mais geral do cálculo das estruturas? Esta pergunta poderia, a princípio, ser respondida de várias maneiras, e as noções a serem desenvolvidas podem ou não ser dependentes de lógicas particulares. A calibração desta dependência pode tornar o projeto mais específico ou mais abrangente.\nNesse sentido, o objetivo principal do trabalho é:\nDiscutir caminhos possíveis para uma estratégia de busca por demonstrações em cálculo das es-\ntruturas adequada para a implementação computacional. Esta estratégia deve ser, de preferência,\nteórica e não puramente operacional.\nOu seja, desejamos aprofundar o conhecimento existente sobre o cálculo das estruturas no sentido de contribuir para, no futuro, conseguir um resultado similar ao obtido através conceito de demonstrações uniformes para o cálculo de seqüentes.\n1Em inglês: goal directed proofs\n67"
    }, {
      "heading" : "68 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : ""
    }, {
      "heading" : "4.2 Abordagem",
      "text" : "Para começar, é importante notar que o desenvolvimento de um conceito de demonstrações uniformes para cálculo das estruturas esbarra nos seguintes problemas:\n1. O comportamento operacional do cálculo das estruturas está longe de ser claro.\n2. Existe um alto grau de não determinismo no cálculo das estruturas.\nPara resolver estes problemas, estudamos uma gama abordagens possíveis, que serão\nexpostas a seguir."
    }, {
      "heading" : "4.2.1 O problema do comportamento operacional",
      "text" : "Uma primeira idéia que estudamos está relacionada à suposição de que a noção de demonstrações uniformes em cálculo das estruturas se basearia principalmente na relação entre implicação (⇒) e validade (⊢). Esta noção pode ser melhor entendida com o exemplo de cláusulas de Horn e Prolog. Em Prolog, uma fórmula como\nB1 ∧ . . . ∧Bh =⇒ H\nespecifica o comportamento de um seqüente da forma\nB1, . . . , Bh ⊢ H\nquando este seqüente é demonstrado seguindo uma demonstração uniforme. O que é importante ressaltar é que a fórmula já indica a forma da demonstração uniforme, devido à conexão clara entre implicação e validade para este caso. A construção de demonstrações para cláusulas de Horn faz uso constante desta conexão. Esta analogia pode ser estendida para cláusulas de Harrop e para a lógica linear clássica, mas não para a lógica clássica completa.\nO problema com cálculo das estruturas é que não há analogia entre implicação e vali-\ndade. Além disso:\n1. a princípio, o cálculo das estruturas não apresenta implicação explícita;\n2. usualmente, a negação não é definida explicitamente;\n3. o formalismo normalmente é usado para lógicas clássicas;\n4. existe a deep inference.\nOs problemas 1, 2 e 3 podem ser resolvidos movendo o foco para linguagens adequadas. O problema 4, entretanto, é crucial. Vamos analisar cada problema com um pouco mais de cuidado:"
    }, {
      "heading" : "4.2. ABORDAGEM 69",
      "text" : "• Problemas 1 e 2.\nDada a estrutura:\n[a, b, c̄, d̄]\nela representa (c, d) =⇒ [a, b] ou (ā, b̄) =⇒ [c̄, d̄]?\nO Problema 1 pode ser resolvido ao se adotar um símbolo explícito para a implicação, enquanto o Problema 2 ao se estabelecer que existe um símbolo de negação na linguagem, tal que ¬a é negativo enquanto a é positivo. Com isso, há uma conseqüência importante: temos que lidar com “contextos negativos”. Isso quer dizer que dentro de negações e dentro de premissas de implicações teremos que usar as regras de inferências duais às regras normais (positivas). Isto dobraria o número de regras dos sistemas dedutivos.\nNote que o Problema 2 é separado do Problema 1. De fato, analisando o Problema 2, poderíamos estipular que a linguagem fica restrita de forma que o símbolo de negação só é permitido sobre átomos, implicando que só trabalhemos com fórmulas na forma normal. Trata-se de uma solução bastante operacional.\n• Problema 3.\nClaramente, deveríamos esperar que lógicas não-clássicas tenham maior propensão a apresentar demonstrações uniformes em cálculo das estruturas do que lógicas clássicas. Depois de um artigo sobre lógica intuicionista em cálculo das estruturas [?], outros para outras lógicas não-clássicas estão sendo lançados. Mas este não é um problema que representa um grande obstáculo.\n• Problema 4.\nEste é um problema grave. Por exemplo, como visto na seção 2.5.1, dada uma fórmula de Harrop, pode-se vê-la como um programa: sabemos como os conectivos se comportam e, crucialmente, sabemos que o programa se desenvolve de fora para dentro da fórmula. Em outras palavras, o aninhamento de fórmulas tem um papel direto no que se refere à ordem de execução. Claramente, se usamos deep inference, este não é mais o caso.\nConsidere que algumas interpretações operacionais de fórmulas dependam da estrutura de ramificação do cálculo de seqüentes. Por exemplo, módulos são mantidos em separados em ramos diferentes de uma árvore de cálculo de seqüentes. Se adotássemos um sistema de cálculo das estruturas que contivesse a regramedial2, teríamos que\n2A regramedial não está presente no sistema BV. É uma regra da lógica clássica, proposta por Alwen e Kai[?]:\nS [(A,C), (B,D)] m\nS([A,B ], [C,D])\ncuja presença permite que a aplicação da regra contraction possa ser restrita a átomos - um resultado notável, pois é a primeira vez que se vê um sistema com tal regra definida localmente."
    }, {
      "heading" : "70 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "módulos diferentes (ou seja, premissas de diferentes implicações em uma fórmula) seriam capazes de interagir com a demonstração, o que é indesejável3. E isto contrasta com a noção usual de demonstrações uniformes."
    }, {
      "heading" : "4.2.2 O problema do não-determinismo",
      "text" : "Como já foi visto, demonstrações uniformes propiciam menor grau de não-determinismo, algo realmente desejável em cálculo das estruturas. Uma abordagem para o problema poderia ser partir de demonstrações uniformes em cálculo de seqüentes e tentar entender como elas poderiam nos ajudar a reduzir o não-determinismo em cálculo das estruturas.\nExiste uma certa dualidade de jogos em deep inference. No cálculo de seqüentes, regras à direita e à esquerda se comportam como jogador e oponente, respectivamente, e o jogo prossegue com cada um se movendo em turnos. Claramente, apenas conseguiríamos este tipo de comportamento em cálculo das estruturas se adotássemos uma das seguintes “soluções”: implicação explícita, polaridades ou contextos positivos e negativos. Esta é uma idéia que poderia ser explorada.\nEntretanto, já temos uma fonte de jogos em cálculo das estruturas, num sentido um tanto mais inesperado que o citado acima. Este seria o teorema de splitting. Relembrando, o teorema de splitting pode ser enunciado como:\n−‖ ‖ BV\nS(R,T ) equivale a\n[X,KR,KT ] ‖ ‖ BV\nS{X} e\n−‖ ‖ BV\n[R,KR ] e\n−‖ ‖ BV [T,KT ]\nondeX é uma estrutura qualquer.\nUtilizando a mesma metáfora acima, poderíamos dizer que o jogador escolhe S(R,T ), ou seja, o contexto e a conjunção a ser dividida, e o oponente terá que achar os killers KR e KT . O jogo então prossegue sobre as novas estruturas a serem demonstradas [R,KR ] e [T,KT ].\nEntão, uma possível abordagem para buscar demonstrações uniformes em cálculo das estruturas seria entender como a noção de jogos se relaciona com demonstrações uniformes em cálculo de seqüentes e trazer esta noção para o cálculo das estruturas.\nO teorema de splitting garante demonstrações para qualquer S(R,T ), entretanto, a maneira como S, R e T são escolhidos não é elucidada, ela é completamente arbitrária. Então, a questão que surge é: como escolhê-los?\nQuanto a uma outra fonte de não-determinismo, a aplicação de regras, o trabalho [?] trata do assunto, mas de uma maneira completamente operacional. Tal trabalho já foi discutido na Seção 3.2.\n3Essa situação corresponde ao problema de scope extrusion, discutido na Seção 2.5"
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 71",
      "text" : ""
    }, {
      "heading" : "4.3 A tentativa de solução proposta",
      "text" : "De acordo com os estudos realizados, dentre os caminhos estudados o que apresenta maior probabilidade de produzir frutos seguemais oumenos a linha do teorema de splitting. Dessa forma, baseamo-nos em resultados teóricos que apresentaremos a seguir para conjecturar que eles levarão a uma estratégia de demonstração uniforme para cálculo das estruturas. Entretanto, no atual estágio de desenvolvimento da pesquisa, podemos dizer que este trabalho apresenta uma tentativa de estratégia.\nDizemos tentativa de estratégia porque, apesar de se basear em resultados teóricos apresentados formalmente e de ter funcionado perfeitamente em todos os testes que executamos (o Capítulo 5 apresenta a implementação computacional da tentativa de estratégia), a demonstração de sua correção ainda está em curso (apesar de a maior parte do trabalho neste sentido já estar pronta).\nAntes de aprofundar em resultados teóricosmais precisos, abaixo damos uma idéia geral de como a tentativa de estratégia lida com a busca por demonstrações uniformes em FBV com pares de átomos dois a dois distintos:\n1. Em vez de escolhermos um contexto S(R,T ) a ser divido, escolheríamos um átomo a\nem S{a} a ser eliminado. No caso trivial, a não estaria em uma estrutura copar, nos casos mais complicados, teríamos S(R,T ), onde R = S′{a}. A escolha de quem seria o átomo a a ser eliminado seria feita baseada no conceito de número de incoerência, que será introduzido mais adiante.\n2. Uma vez escolhido o átomo a ser eliminado, determinaríamos o seu killer, que seria\nsempre ā. Por isso a estratégia seria aplicável somente a estruturas com pares de átomos distintos dois a dois, ou seja, só existe um átomo com o mesmo “nome”.\n3. Escolhido o átomo e o seu killer, procederíamos aplicando regras switch até que ambos\nse encontrassem em uma estrutura par. Então poderíamos aplicar a regra ai↓ para eliminá-los.\n4. O processo seguiria até que a estrutura fosse demonstrada, ou até que atingíssemos\num estágio sobre o qual não fosse possível avançar, indicando que a estrutura não é demonstrável.\nÉ interessante notar que, se a estratégia for demonstrada correta, ela apresentará as se-\nguintes características importantes:\n1. Ela funcionaria para o sistema FBV, restrita a estruturas com pares de átomos distintos\ndois a dois, ou seja, só poderia haver uma única ocorrência de cada átomo.\n2. Ela não exigiria backtracking na construção de uma demonstração: uma vez tomado\num passo na derivação, não seria preciso reconsiderá-lo."
    }, {
      "heading" : "72 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "3. Se um estágio fosse atingido sobre o qual não seria mais possível avançar, é porque a\nestrutura inicial não era demonstrável.\nEstamos prontos para enunciar os resultados principais desta dissertação. Nesse ponto, é importante ressaltar que tais resultados são inéditos e constituem em um avanço na busca de um conceito de demonstrações uniformes em cálculo das estruturas. Ainda muito deve ser feito, uma vez que nossos resultados estão restritos a um fragmento pequeno do sistema BV. Mas é o primeiro resultado teórico obtido na área. A seção 4.3.1 apresenta conceitos e definições necessárias, e a tentativa de estratégia é formalmente apresentada e explicada em detalhes na seção 4.3.2."
    }, {
      "heading" : "4.3.1 Resultados fundamentais e definições",
      "text" : "Vamos começar com um teorema que nos dá condições necessárias para que uma estrutura seja demonstrável em FBV. Em seguida, vamos introduzir o conceito fundamental para a tentativa de estratétiga proposta: número de incoerência."
    }, {
      "heading" : "4.3.1.1 Condições necessárias para demonstrabilidade",
      "text" : "Vamos começar com um lema necessário:\nLema 51 (Propriedade X). Seja uma estrutura S da forma S [P (X{x}, Y {y}), Q(Z{z},W{w})]. Não existem derivações Π1 e Π2 em FBV tais que:\nS′(P ′ [X ′{x},W ′{w}], Q′ [Y ′{y}, Z ′{z}])\nΠ1 ‖ ‖ FBV\nS [P (X{x}, Y {y}), Q(Z{z},W{w})]\nS′(P ′ [X ′{x}, Z ′{z}], Q′ [Y ′{y},W ′{w}])\nΠ2 ‖ ‖ FBV\nS [P (X{x}, Y {y}), Q(Z{z},W{w})]\nEquivalentemente, podemos enunciar o lema como: Uma subrede de interação da forma w0 não pode ser transformada em uma subrede de interação da forma w1 ou em uma subrede de interação da forma w2, via regras de infererência de FBV durante a construção de uma demonstração (de baixo para cima):\nw0 w1 w2 Partindo de x\n` `\n` `\nw\nz\n>~ >~\n>~ >~\ny\nnão podemos chegar a x\nO O O\n` `\n` `\nw\nO O O\nz\n>~ >~\n>~ >~\ny\nnem a x /o/o/o\n` `\n` `\nw\nz /o/o/o\n>~ >~\n>~ >~\ny\nDemonstração. Sabemos que em FBV o número de aplicações de regras de inferência sobre uma estrutura S1, demonstrável ou não, é finito. Seja n(S1) = |ρ| onde ρ ∈ {◦ ↓,ai↓, s } são todas as instâncias de regras de inferência aplicáveis em FBV tais que:\nS2 ρ S1"
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 73",
      "text" : "Temos que, necessariamente, n(S2) < n(S1) Portanto, vamos utilizar este fato para demonstrar o lema por indução no número de\npossibilidades de aplicações de regras n(S).\nCasos base:\n1. P{◦} = ◦\nUma possibilidade é:\nS([X{x}, Q(Z{z},W{w})], Y {y}) s\nS [(X{x}, Y {y}), Q(Z{z},W{w})]\nMas, com isso, y ↑ z (o que vai contra a criação da rede w1) e y ↑ w (o que vai contra a criação a rede w2). Dado que uma vez que criamos uma relação ↑ de baixo para cima em uma demonstração ela não pode mais ser desfeita, então não poderemos criar as desejadas w1 ou w2. A outra possibilidade é:\nS([Y {y}, Q(Z{z},W{w})],X{x}) s\nS [(X{x}, Y {y}), Q(Z{z},W{w})]\nMas, com isso, x ↑ w (o que vai contra a criação da rede w1) e x ↑ z (o que vai contra a criação da rede w2). Dado que uma vez que criamos uma relação ↑ de baixo para cima em uma demonstração ela não pode mais ser desfeita, então não poderemos criar as desejadas w1 ou w2.\n2. Q{◦} = ◦\nAnálogo ao caso anterior.\n3. Aplica-se uma instância de ai↓ sobre um ocorrência de átomo x, y, z ou w e seu\nrespectivo dual.\nNeste caso o átomo em questão não figura mais na teia de interação da estrutura e, portanto, claramente as subredes w1 e w2 não podem ser atingidas.\nCasos indutivos:\nVamos argumentar baseados na última aplicação de regra ρ sobre a estrutura S [P (X{x}, Y {y}), Q(Z{z},W{w})]:\nS∗ ρ S [P (X{x}, Y {y}), Q(Z{z},W{w})]\nNos concentraremos nos casos em que ρ é não-trivial.\n1. ρ = ai↓"
    }, {
      "heading" : "74 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "a) O redex está emX{ }\nS [P (X∗{x}, Y {y}), Q(Z{z},W{w})] ai↓\nS [P (X{x}, Y {y}), Q(Z{z},W{w})]\nNa estrutura do contractum ainda temos a subrede de interação w0, porém o número de possibilidades de aplicação de regras agora é menor. Podemos, então, aplicar a hipótese de indução.\nb) O redex está em Y { }, Z{ }, W{ }, P{ }, Q{ } ou S{ }\nAnálogos ao caso anterior.\n2. ρ = s\na) O redex está emX{ }\nS [P (X∗{x}, Y {y}), Q(Z{z},W{w})] s\nS [P (X{x}, Y {y}), Q(Z{z},W{w})]\nNa estrutura do contractum ainda temos a subrede de interação w0, porém o número de possibilidades de aplicação de regras agora é menor. Podemos, então, aplicar a hipótese de indução.\nb) O redex está em Y { }, Z{ }, W{ }, P{ }, Q{ } ou S{ }\nAnálogos ao caso anterior.\nc) O redex envolve P (X{x}, Y {y}) e Q(Z{z},W{w})\nSabemos que P{◦} 6= ◦ 6= Q{◦}, pois senão teríamos o caso base. Vamos analisar as possibilidades para P (X{x}, Y {y}):\ni. P (X{x}, Y {y}) = [(X{x}, Y {y}), P1 ]\nMas então a estrutura seria da forma S [(X{x}, Y {y}), P1, Q(Z{z},W{w})], que é o equivalente a um dos casos base.\nii. P (X{x}, Y {y}) = (X{x}, Y {y}, P1)\nMas então podemos chamar Y ′′{y} = (Y {y}, P1) e temos que a estrutura é da forma S [(X{x}, Y ′′{y}), Q(Z{z},W{w})], que é o equivalente a um dos casos base.\niii. P (X{x}, Y {y}) = ([P ′′(X{x}, Y {y}), P2 ], P1)\nAs possibilidades para Q(Z{z},W{w}) são análogas. Portanto, o único caso a ser analisado é o em que P (X{x}, Y {y}) = ([P ′′(X{x}, Y {y}), P2 ], P1) e Q(Z{z},W{w}) = ([Q′′(Z{z},W{w}), Q2 ], Q1). Façamos P ′′′ = [P ′′(X{x}, Y {y}), P2 ] e Q′′′ = [Q′′(Z{z},W{w}), Q2 ]. As possibilidades de aplicação da regra switch sobre a estrutura copar (P ′′′, P1):"
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 75",
      "text" : "S([P ′′′, (Q′′′, Q1)], P1) s\nS [(P ′′′, P1), (Q ′′′, Q1)]\nNa estrutura do contractum ainda temos a subrede de interação w0, porém o número de possibilidades de aplicação de regras agora é menor. Podemos, então, aplicar a hipótese de indução.\nS([P1, (Q ′′′, Q1)], P ′′′) s\nS [(P ′′′, P1), (Q ′′′, Q1)]\nMas, com isso, x ↑ w e y ↑ z (o que vai contra a criação da rede w1) e x ↑ z e y ↑ w (o que vai contra a criação da rede w2). Dado que uma vez que criamos uma relação ↑ de baixo para cima em uma demonstração ela não pode mais ser desfeita, então não poderemos criar as desejadas w1 ou w2. As possibilidades de aplicação da regra switch sobre a estrutura copar (Q′′′, Q1) são análogas.\nAgora podemos enunciar o teorema que nos fornece condições necessárias para uma\nestrutural ser demonstrável em FBV.\nTeorema 52 (Condições necessárias para demonstrabilidade). Se uma estrutura S é demonstrável em FBV, então:\n1. Condição C1\n∃f : occ S → occ S. f(a) = ā ∧ (a ↓ ā) em S\n2. Condição C2\n∀a ∈ occ S. 6 ∃ q ∈ occ S . S[S′(A{a}, Q{q}), S′′(A′{ā}, Q′{q̄})]\nonde S{ }, S′{ }, S′′{ }, A{ }, Q{ }, A′{ }, Q′{ } são contextos, possivelmente vazios.\nObservação 53. De agora em diante, consideraremos ā ≡ f(a) para todo a ∈ occ S, considerando que a negação em BV é involutiva (ā = a) e que, se existe mais de uma ocorrência de um átomo a em S, elas podem ser diferenciadas através do uso de índices.\nObservação 54. O Teorema 52 é equivalente a\n−‖ ‖ FBV S =⇒ C1 ∧ C2\nObservação 55. A condição C2 é equivalente a:\n6 ∃a, ā, q, q̄ ∈ occ S.\n76 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS\na\n^ ^\n^ ^\n^ q̄\nā\n@ @\n@ @\n@\nq\nDemonstração. O contrapositivo do teorema diz que ¬C1 ∨ ¬C2 =⇒ ¬\n[−‖ ‖ FBV\nS\n]\n.\n• ¬C1 =⇒ ¬\n[−‖ ‖ FBV\nS\n]\nA demonstração segue diretamente das regras do sistema FBV. Numa visão de baixo para cima, nenhuma aplicação de regra de inferência pode criar uma relação ↓ entre dois átomos. Observe na figura 52 que as relações ↑ são sempre mantidas do contractum para o redex, e que as relações ↓ do contractum ou são mantidas ou convertidas em relações ↑. Em outras palavras, relações ↓ jamais são criadas de baixo para cima em uma demonstração.\nRegra Antes da aplicação ↓mantidas ↓ transformadas em ↑\n◦ ↓ ◦ - - -\nS{◦} ai↓\nS [a, ā] a ↓ a - a− a S([R,T ], R′) s S [(R,R′), T ] R ↓ T , R′ ↓ T , R ↑ R′ R ↓ T R′ ↑ T\nFigura 4.1: Regras de inferência não criam relações ↓ quando vistas de baixo para cima.\nPortanto, se existe um átomo a ∈ occ S para o qual não exista um ā ∈ occ S tal que a ↓ ā, nunca será possível criar, via regras de inferência, uma relação ↓ entre estes átomos. Levando em conta que toda estrutura demonstrável deve cancelar seus átomos (relacionados por ↓) via instâncias da regra ai↓, a nunca poderá ser cancelado com ā e S não é, portanto, demonstrável.\n• ¬C2 =⇒ ¬\n[−‖ ‖ FBV\nS\n]\nSe nós temos ¬C2, então a estrutura S é da forma:\nS [S′(A{a}, Q{q}), S′′(A′{ā}, Q′{q̄})]\nNote que a estrutura possui uma subrede de interação da forma:\n4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 77\na\n^ ^\n^ ^ ^\nq̄\nā\n@ @\n@ @\n@\nq\nSe a estrutura for demonstrável, então uma hora necessariamente deve haver uma aplicação de regra:\nS{◦} ai↓\nS [a, ā]\n, onde podemos chamar [a, ā] = R. (O caso em que desejássemos argumentar baseados em q e q̄ seria análogo.)\nMas sabemos que, dada uma estrutura S{R} e duas ocorrências de átomos a em S{ } e b em R, se a ⊳ b (respectivamente, a ⊲ b, a ↓ b, a ↑ b) então a ⊳ c (respectivamente, a ⊲ c, a ↓ c, a ↑ c) para todas as ocorrências de átomos c em R.\nLogo, se a estrutura for demonstrável, em um dado ponto da demonstração a e ā devem manter a mesma relação estrutural com todas as ocorrências de átomos em S, em particular com q e com q̄.\nVamos nos concentrar na subrede de interação:\na\n^ ^\n^ ^ ^\nq̄\nā\n@ @\n@ @\n@\nq\nComo não há maneira de transformar uma relação ↑ em ↓ na construção de baixo para cima de uma demonstração em FBV, só nos resta tentar transformar as relações ↓ em ↑. Em particular, temos que criar pelo menos duas relações: a ↑ q̄ e ā ↑ q.\nVamos analisar os casos. Suponha que consigamos criar a ↑ q̄. Pela propriedade do quadrado, na teia de interação de uma estrutura, um quadrado não pode apresentar exatamente três lados representando a mesma relação estrutural: deve haver um quarto lado. Portanto, teremos um dos seguintes casos:"
    }, {
      "heading" : "78 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "a /o/o/o\n^ ^\n^ ^\n^ q̄\nā\n@ @\n@ @ @\nq\n=⇒\nI a /o/o/o\nO O O\n^ ^\n^ ^\n^ q̄\nā\n@ @\n@ @\n@\nq\n∨\nII a /o/o/o\n^ ^\n^ ^ ^\nq̄\nO O O\nā\n@ @\n@ @ @\nq\n∨\nIII a /o/o/o\n^ ^ ^\n^ ^\nq̄\nā /o/o/o\n@ @\n@ @\n@\nq\nMas no caso I, a estrutura não seria demonstrável, uma vez que a ↑ ā. No caso II, q ↑ q̄ e também a estrutura não seria demonstrável. Já o caso III implicaria que, durante a construção de uma demonstração:\nw0 w1 Partindo de a\n^ ^\n^ ^ ^\nq̄\nā\n@ @\n@ @ @\nq\nchegamos a a /o/o/o\n^ ^ ^\n^ ^\nq̄\nā /o/o/o\n@ @ @\n@ @\nq\n, o que não é possível, pelo Lema 51.\nDa mesma forma, se supusermos que conseguimos criar ā ↑ q, teremos casos análogos."
    }, {
      "heading" : "4.3.1.2 Número de incoerência",
      "text" : "As Definições 56 e 58 são a chave do nosso trabalho. Elas são equivalentes, e a diferença consiste na forma de apresentação: a Definição 58 é recursiva.\nDefinição 56 (Número de incoerência). Seja S uma estrutura em FBV. Sejam a e b dois átomos ∈ occ S. Sejam σ1, σ2 ∈ {↓, ↑} possíveis relações entre átomos em uma estrutura. O número de incoerência do par de átomos {a, b} no contexto S é definido da seguinte maneira:\n1. < S >#a,b= |{x ∈ occ S | (a σ1 x) ∧ (b σ2 x) ∧ (σ1 6= σ2)}|, se a ↓ b;\n2. < S >#a,b= ∞, se a ↑ b;\nO número de incoerência entre dois átomos a e b dentro da estrutura S, por motivos que veremos adiante, só faz sentido se a ↓ b. Nesse caso, ele é definido como número de ocorrências de átomos de S que mantêm uma relação estrutural com a e outra diferente com b (daí o nome de número de incoerência)."
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 79",
      "text" : "Exemplo 57. Seja a estrutura S = [a, b, (c, [d, e])]. Assim temos:\n< S >#a,b= 0; < S >#a,c= 2, pois a ↓ d e a ↓ emas c ↑ d e c ↑ e; < S >#a,d= 1, pois a ↓ cmas d ↑ c; < S >#c,d= ∞, pois c ↑ d;\nDefinição 58 (Número de incoerência). Seja S uma estrutura em FBV. Sejam a e b dois átomos ∈ occ S. O número de incoerência do par de átomos {a, b} no contexto S é recursivamente definido da seguinte maneira:\n1. < S [a, b] >#a,b= 0\n2. < S [S′{a}, S′′{b}, P ] >#a,b=< [S ′{a}, S′′{b}] >#a,b\n3. < S [S′{a}, (S′′{b}, P )] >#a,b= |occ P |+ < [S ′{a}, S′′{b}] >#a,b , onde S ′′{b} não é um\ncopar próprio.\n4. < S [(S′{a}, P ), S′′{b}] >#a,b= |occ P |+ < [S ′{a}, S′′{b}] >#a,b , onde S ′{a} não é um\ncopar próprio.\n5. < S(S′{a}, S′′{b}) >#a,b= ∞\ne, em todos os casos, P é uma estrutura.\nExemplo 59. Seja a estrutura S = [([a, b], c), (d, [e, f ])]. Nesse caso temos: < S >#a,b= < S ′′′ [a, b] >#a,b= 0 , pelo caso (1);\n< S >#a,c= < S′′′(S′{a}, S′′{c}) > # a,c= ∞ , pelo caso (5);\n< S >#a,d= < [(S ′{a}, P ), S′′{d}] >#a,d= , pelo caso (4)\n< [(S′{a}, c), S′′{d}] >#a,d= |occ P |+ < [S′{a}, S′′{d}] >#a,d= |occ c|+ < [a, b, (d, [e, f ])] >#a,d= 1+ < [S′{a}, S′′{d}, P ′ ] >#a,d= , pelo caso (2) 1+ < [a, (d, [e, f ])] >#a,d= 1+ < [S′{a}, (S′′′{d}, P ′′)] >#a,d= , pelo caso (3) 1 + |occ P ′′|+ < [a, d] >#a,d= 1 + |occ [e, f ]|+ < [a, d] >#a,d= 1 + 2 + 0 = , pelo caso (1)\n3\nConsidere a seguinte estrutura:\nS = [a, (b, [c, d])]"
    }, {
      "heading" : "80 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "Pela definição de número de incoerência, < S >#a,b= 2. Entretanto, observe que se consi-\nderarmos a subestrutura T = [c, d], podemos reescrever S como:\nS = [a, (b, T )]\nNesse caso, pode-se abstrair do tamanho de T , ou seja, quantas ocorrências de átomos T possui, e focar no que realmente interessa: o número de incoerência entre os átomos a e b se deve às relações estruturais diferentes que estes átomos mantêm com toda a subestrutura T , não importando se T é um átomo ou uma estrutura maior. Dessa forma, faria sentido generalizar a idéia de incoerência além de átomos, lidando com subestruturas. O número de incoerência entre a e b em S seria 1, pois a e bmantêm relações diferentes com a subestrutura T , independentementede seu tamanho ou natureza. Essa é a idéia de número de incoerência módulo coerência.\nDefinição 60 (Número de incoerência módulo coerência). Seja S uma estrutura em FBV. Sejam U e V duas subestruturas disjuntas em S. O número de incoerência módulo coerência do par de estruturas {U, V } dentro da estrutura S é recursivamente definido da seguinte maneira:\n1. {S [U, V ]}#U,V = 0\n2. {S [S′{U}, S′′{V }, P ]}#U,V = {[S ′{U}, S′′{V }]}#U,V\n3. {S [S′{U}, (S′′{V }, P )]}#U,V = 1+{[S ′{U}, S′′{V }]}#U,V , onde S ′′{V } não é um copar\npróprio.\n4. {S [(S′{U}, P ), S′′{V }]}#U,V = 1+ {[S ′{U}, S′′{V }]}#U,V , onde S ′{U} não é um copar\npróprio.\n5. {S(S′{U}, S′′{V })}#U,V = ∞\nonde P é uma estrutura.\nExemplo 61. Seja a estrutura S = [([a, b], c), (d, [e, f ])]. Nesse caso temos:\n4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 81\n{S}#a,b = {S ′′′ [a, b]}#a,b = 0 , pelo caso (1);\n{S}#a,c = {S′′′(S′{a}, S′′{c})} # a,c = ∞ , pelo caso (5);\n{S}#a,d = {[(S ′{a}, P ), S′′{d}]}#a,d = , pelo caso (4)\n{[(S′{a}, c), S′′{d}]}#a,d = |occ P |+ {[S′{a}, S′′{d}]}#a,d = |occ c|+ {[a, b, (d, [e, f ])]}#a,d = 1 + {[S′{a}, S′′{d}, P ′ ]}#a,d = , pelo caso (2) 1 + {[a, (d, [e, f ])]}#a,d = 1 + {[S′{a}, (S′′′{d}, P ′′)]}#a,d = , pelo caso (3) 1 + 1 + {[a, d]}#a,d = 2 + {[a, d]}#a,d = 2 + 0 = , pelo caso (1)\n2\nNote que, para a estrutura S = [([a, b], c), (d, [e, f ])], o número de incoerência entre os\nátomos a e d é < S >#a,b= 3, mas o número de incoerência módulo coerência é {S} # a,b = 2"
    }, {
      "heading" : "4.3.2 Resultados principais",
      "text" : "Agora estamos prontos, para, usando o teorema de condições necessárias para demonstrabilidade e a idéia de número de incoerência módulo coerência, começar a propor a nossa tentativa de estratégia de demonstração para o sistema FBV com pares de átomos distintos dois a dois.\nAntes de mais nada, entretando, vamos nos deter um momento para entender o porquê de no momento restringirmos a nossa estratégia ao sistema FBV com pares de átomos dois a dois distintos.\n4.3.2.1 Porque FBV com pares de átomos dois a dois distintos\nComo vimos pelo Teorema 52, a condição C1 exige que, para uma estrutura demonstrável S haja uma função de escolha\nf : occ S → occ S. f(a) = ā ∧ (a ↓ ā) em S\nEntretanto, não é possível, a princípio, determinar trivialmente qual ocorrência de a deve ser associada a qual ocorrência de ā via a função f . Como mostram os exemplos a seguir, esta escolha não pode ser feita arbitrariamente.\nExemplo 62. A estrutura [a, ā, b, b̄, (a, b), (ā, b̄)] é demonstrável. Apenas com o objetivo de facilitar a argumentação, vamos diferenciar cada ocorrência de átomos repetidos indexandoos da seguinte forma: [a1, ā1, b1, b̄1, (a2, b2), (ā2, b̄2)]."
    }, {
      "heading" : "82 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "Esta estrutura é demonstrável, como podemos ver a seguir:\n◦ ↓ ◦\nai↓ [b2, b̄2 ]\nai↓ [b2, ([a1, ā2 ], b̄2)]\ns [a1, b2, (ā2, b̄2)]\nai↓ [a1, b1, b̄1, b2, (ā2, b̄2)]\nai↓ [a1, b1, b̄1, ([a2, ā1 ], b2), (ā2, b̄2)]\ns [a1, ā1, b1, b̄1, (a2, b2), (ā2, b̄2)]\no que equivale à função de escolha f(a1) = ā2, f(a2) = ā1, f(b1) = b̄1 e f(b2) = b̄2 (basta olhar os índices das ocorrências atômicas em cada instância de aplicação da regra ai↓ na demonstração).\nSe, por outro lado, optássemos por começar a demonstração pela aplicação da regra ai↓ duas vezes, eliminando primeiro os átomos na estrutura par, cairíamos na seguinte situação:\n[(a2, b2), (ā2, b̄2)] ai↓\n[b1, b̄1, (a2, b2), (ā2, b̄2)] ai↓\n[a1, ā1, b1, b̄1, (a2, b2), (ā2, b̄2)]\nMas a estrutura [(a, b), (ā, b̄)] não é demonstrável, pela condição C2 do Teorema 52. Portanto, não podemos começar eliminando todos os átomos duais da estrutura par mais externa, ou seja, a função de escolha f(a1) = ā1, f(a2) = ā2, f(b1) = b̄1 e f(b2) = b̄2 não é válida.\nApenas para ressaltar o quão complicada a escolha da função pode ficar, podemos mostrar que não é necessariamente preciso adiar a aplicação das regras ai↓ para o final da construção da demonstração: é possível construir uma demonstração da mesma estrutura em que começamos com uma aplicação ai↓ sobre apenas um dos pares de átomos da estrutura par mais externa, no caso, o par a1 e ā1:\n◦ ↓ ◦\nai↓ [b1, b̄2 ]\nai↓ [b1, ([a2, ā2 ], b̄2)]\ns [b1, a2, (ā2, b̄2)]\nai↓ [b1, (a2, [b2, b̄1 ]), (ā2, b̄2)]\ns [b1, b̄1, (a2, b2), (ā2, b̄2)]\nai↓ [a1, ā1, b1, b̄1, (a2, b2), (ā2, b̄2)]"
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 83",
      "text" : "o que equivale à função de escolha f(a1) = ā1, f(a2) = ā2, f(b1) = b̄2 e f(b2) = b̄1.\nOmesmo poderia ser feito se escolhêssemos eliminar b1 e b̄1 primeiro. De fato, das quatro funções de escolha possíveis, três podem levar a uma demonstração, e uma necessariamente não leva.\nComo vemos, escolher qual a função f adequada para cada estrutura não parece ser uma tarefa trivial, e por isso, não foi focada neste trabalho. Eliminamos o problema de lidar com f restringindo o sistema FBV de modo a ter apenas pares de átomos dois a dois distintos. Desta forma, a cada ocorrência de a ∈ occ S só existe uma única possibilidade de mapeamento via função f , que consiste em ā ∈ occ S.\nContornado o problema da função f , vamos agora justificar o porquê de trabalharmos com FBV no momento, e não com o sistema BV completo. Em primeiro lugar, porque queremos começar do subsistema mais simples para depois generalizar a estratégia para o supersistema mais complexo. Além disso, a presença da regra q↓ em BV complica a escolha das regras de inferência a aplicar, uma vez que não é possível ordenar as instâncias de regra em uma demonstração de forma que se possa usar todas as instâncias de uma regra antes de todas as instâncias de outra regra. Mais especificamente, isso quer dizer que mesmo que os átomos da estrutura a ser demonstrada sejam dois a dois distintos, a presença da regra q↓ não permite que a aplicação da regra ai↓ seja adiada de modo a ocorrer apenas na parte superior da derivação, depois que todas as instâncias q↓ já tenham sido aplicadas. De fato, a estrutura\n[〈([d, d̄], 〈a; b〉); c〉, 〈ā; (〈b̄; c̄〉, [e, ē])〉]\né demonstrável mas, temos que aplicar a regra ai↓ no início da demonstração senão a estrutura copar que envolve o seq não permitirá a aplicação da regra q↓."
    }, {
      "heading" : "4.3.2.2 A tentativa estratégia de demonstração",
      "text" : "Vamos começar por um lema chave para a nossa estratégia.\nLema 63 (“Esquecimento”). Seja S{a, ā} = S{X{a}, Y {ā}} uma estrutura demonstrável em BV\ncom pares distintos de átomos, tal que f(a) = ā, pela condição C1 do teorema de condições necessárias para demonstrabilidade (Teorema 52). Então S{◦} = {X{◦}, Y {◦}} é demonstrável.\nDemonstração. A demonstração segue facilmente por indução no tamanho da derivação Π\n− Π ‖ ‖ BV S{a, ā}\nSeja ρ a última regra de Π. Se ρ = ai↓:\n− Π′\n‖ ‖ BV\nS{◦} ai↓\nS[a, ā]"
    }, {
      "heading" : "84 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "o resultado segue imediatamente. Se não, Π é da forma:\n− Π′\n‖ ‖ BV\nS′{a, ā} ρ S{a, ā}\nPor indução, S′{◦} é demonstrável. Portanto\n− Π′ ‖‖ BV\nS′{◦} ρ S{◦}\né a demonstração desejada.\nNote que a demonstração do lema 63 foi dada para uma estrutura em BV, mas o resultado vale também para o sistema FBV (a demonstração apresentada é igualmente válida para uma estrutura em FBV).\nPelo justificado na seção 4.3.2.1, restringimos neste trabalho o nosso foco de interesse ao sistema FBV com pares de átomos dois a dois distintos. Isto nos possibilita uma série de resultados interessantes. Vamos começar a expô-los agora.\nLema 64 (Estratégia para {S}#a,ā = 0). Se uma estrutura S em FBV só possui pares de átomos dois a dois distintos e S = S′ [a, ā], então podemos aplicar a regra ai↓ sobre a e ā.\nDemonstração. Como restringimos a estrutura ao sistema FBV com pares de átomos dois a dois distintos, sabemos que necessariamente devemos eliminar a única ocorrência de a com a única ocorrência de ā. Considere a seguinte derivação:\n−‖ ‖\nS{◦} ai↓\nS [a, ā]\nObserve que esta derivação equivale exatamente a, de baixo para cima, “esquecer” os átomos duais a e ā. Pelo lema do “esquecimento” (Lema 63), podemos concluir que S [a, ā] é demonstrável se, e somente se, S{◦} o é. Logo, podemos aplicar a regra ai↓.\nEste lema é particularmente útil por dizer que, sempre que encontrarmos um par de átomos duais que tenham número de incoerência igual a zero, podemos aplicar a regra ai↓ sem comprometer a demonstrabilidade da estrutura.\nLema 65. A estrutura S [a, (ā,X)] é demonstrável em FBV com apenas pares de átomos dois a dois\ndistintos se, e somente se, S{X} é demonstrável no mesmo sistema."
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 85",
      "text" : "Demonstração. Como restringimos a estrutura ao sistema FBV com pares de átomos dois a dois distintos, sabemos que necessariamente devemos eliminar a única ocorrência de a com a única ocorrência de ā. Considere a seguinte derivação:\nS{X} ai↓\nS([a, ā],X) s\nS [a, (ā,X)]\nObserve que esta derivação equivale exatamente a, de baixo para cima, “esquecer” os\nátomos duais a e ā. Pelo lema do “esquecimento” (Lema 63), podemos concluir que S [a, (ā,X)] é demonstrável se, e somente se, S{X} o é.\nLema 66 (Estratégia para {S}#a,ā = 1). Em FBV com apenas pares de átomos dois a dois distintos, S [a, (ā,X)] é demonstrável se, e somente se, S([a, ā],X) o é.\nDemonstração. Pelo lema 65, S [a, (ā,X)] é demonstrável se, e somente se, S{X} é demonstrável. Mas, pelo Lema 64, S{X} é demonstrável se, e somente se, S([a, ā],X) é demonstrável. Logo, por transitividade, S [a, (ā,X)] é demonstrável se, e somente se S([a, ā],X) o é.\nEste lema é particularmente útil por dizer que, sempre que encontrarmos um par de\nátomos duais que tenham número de incoerência igual a um, podemos aplicar a regra s sem comprometer a demonstrabilidade da estrutura:\n−‖ ‖\nS([a, ā],X) s\nS [a, (ā,X)]\nonde chegamos à situação em que o número de incoerência entre o par de átomos duais diminui para zero.\nPelo lema 64 podemos, se quisermos, aplicar a regra ai↓:\n−‖ ‖\nS{X} ai↓\nS(X, [a, ā]) s\nS [a, (ā,X)]\nEntretanto, se não quisermos, temos a liberdade de adiar a aplicação da regra ai↓ para\nmais tarde na construção da demonstração.\nObserve que os lemas 64 e 66 fornecem uma idéia da estratégia de demonstração para quando temos pares de átomos duais cujo número de incoerência seja zero ou um. Se a"
    }, {
      "heading" : "86 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "estrutura que se deseja demonstrar possuir apenas pares de átomos destes tipos, a estratégia de demonstração já está completa. Basta aplicar o lema 64 sempre que possível, eliminando os pares de átomos duais com número de incoerência igual a zero, e depois prosseguir com o lema 66 eliminando os demais átomos.\nEntretanto, o que fazer no caso de, para todo par de átomos duais na estrutura, o número de incoerência for maior que um? A situação em questão equivale a ∀a ∈ occ S, {S}#a,ā > 1, onde S é uma estrutura demonstrável. Uma idéia seria escolher um par de átomos a e ā e tentar reduzir seu número de incoerência até que ele se torne 1 ou 0 para, assim, poder aplicar a estratégia já conhecida.\nNeste momento é importante notar que os resultados obtidos até agora, que consistem na estratégia para pares de átomos duais cujo número de incoerência seja igual a zero ou um, já estão demonstrados. A partir deste ponto utilizamos indícios obtidos através de observações e considerações teóricas para propor um caminho para avançar na busca por uma estratégia para átomos duais com número de incoerência maior que um. Vamos argumentar a favor do caminho proposto, embasando a conjectura de que ele seja um caminho válido, produzindo a nossa tentativa de estratégia final.\nIniciando nossa tentativa de solução, conjecturamos que para “diminuir” o número de incoerência de um par de átomos, podemos utilizar a idéia do lema do “esquecimento” (Lema 63). Além das aplicações já mostradas, este lema é particularmente interessante porque ele dá uma idéia de como seria possível reduzir o número de incoerência de um par de átomos: bastaria “esquecer” (retirar) subestruturas adequadas de forma que a estrutura resultante possuísse pelo menos um par de átomos duais com número de incoerência igual a zero ou 1.\nVoltando à idéia de estratégia de demonstração em BV, notemos que se S{a, ā} é de-\nmonstrável e os átomos em S são pares distintos, então Π é da forma\n− Π2\n‖ ‖ BV\nS{◦} ai↓\nS [a, ā]\nΠ1 ‖ ‖ BV S{a, ā}\nIsto significa que as regras switch e seq devem ser aplicadas para aproximar átomos com\npolaridades opostas.\nA idéia é então aplicar o switch quantas vezes forem necessárias para aproximar um átomo de sua forma negada, “esquecendo” do resto da estrutura. Como podemos ver no Lema 63, “esquecer” átomos não altera a demonstrabilidade da estrutura.\nA questão é: demonstramos o Lema 63 mantendo a “estrutura” da demonstração. Podemos alterar a demonstração para retornar novamente com os átomos que retiramos? Se a resposta for sim, então claramente temos uma estratégia para demonstrar estruturas, que é o principal objetivo deste trabalho."
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 87",
      "text" : "Antes, entretanto, precisamos de uma definição do que seria “esquecer” estruturas in-\nteiras, uma vez que o lema 63 se refere a “esquecer” apenas átomos.\nDefinição 67. “Esquecer”R em S{R} significa\n∀a ∈ occ R. “esquecer” a, ā ∈ occ S{R}\nNote que não necessariamente ā ∈ occ R. Pode ser o caso em que ā está em occ S{ }.\nExemplo 68. Seja a estrutura [a, (b̄, c), (ā, b), c̄]. “Esquecer” a subestrutura (ā, b) significa “esquecer” os pares de átomos a, ā e b, b̄, obtendo assim a estrutura [c, c̄].\nPodemos agora voltar à busca da estratégia de demonstração, começando por um exem-\nplo.\nExemplo 69. Seja S = [(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]. Há várias maneiras de se demonstrar S. Observe que todos os átomos possuem número de incoerência módulo coerência igual a 2. Entretanto, os átomos a, b, d e e estão “aninhados”, o que torna a escolha de por onde começar a demonstração mais complicada. A maneira mais clara de proceder seria aplicar um switch sobre c e c̄. Vamos fazer R = [ā, b] e T = [d̄, e], de forma que S = [(a, b̄), (c̄, R), (c, T ), (d, ē)].\nPodemos então usar a idéia da Definição 67 e “esquecer” a subestrutura T . Nesse caso, consideramos que a estrutura S fica implicitamente transformada em [(a, b̄), (c̄, R), c]. Note que, com isso, o número de incoerência {S}#c,c̄ diminui para um. E é exatamente o que queríamos! Já sabemos como lidar com os casos em que há um par de átomos duais com número de incoerência módulo coerência igual a um (Lema 66). Podemos então construir a seguinte demonstração da estrutura S:\n−‖ ‖\n[(a, b̄), (T,R), (d, ē)] ai↓\n[(a, b̄), (([c̄, c], T ), R), (d, ē)] s\n[(a, b̄), ([c̄, (c, T )], R), (d, ē)] s\n[(a, b̄), (c̄, R), (c, T ), (d, ē)]\nNote que na demonstração não explicitamos o “esquecimento” de T . Simplesmente usamos a idéia implícita de esquecimento para nos guiar por quem começar a demonstração, no caso, por uma instância switch sobre o par de átomos duais c e c̄, que possuem então um número de incoerência módulo coerência com que sabemos lidar (no caso, um).\nÉ claro que poderíamos “esquecer” R e o resultado seria equivalente. Neste caso, não importa a subestrutura que decidimos apagar, uma vez que as estruturas (c̄, R) e (c, T ) são similares."
    }, {
      "heading" : "88 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "Após este exemplo, estamos preparados para formalizar a idéia de “esquecimento” como meio para diminuir números de incoerência módulo coerência maiores que um e, assim, obter uma estratégia.\nConjectura 70 (Estratégia para {S}#a,ā > 1). Seja S uma estrutura demonstrável em FBV com átomos dois a dois distintos tal que {S}#a,ā > 1 para todo a ∈ occ S. Seja a ∈ occ S o átomo com menor número de incoerência módulo coerência na estrutura. Então S{a, ā} é da forma S′(R{a}, T{ā}) e\ntemos um dos seguintes casos:\n1 R{◦} = T{◦} = ◦: S{a, ā} = S′ [(a,X), (ā, Y )] 2 R{◦} = ◦ e T{◦} 6= ◦: S{a, ā} = S′ [(a,X), (T{ā}, Y )] 3 R{◦} 6= ◦ e T{◦} 6= ◦: S{a, ā} = S′ [(R{a},X), (T{ā}, Y )]\n, onde X,Y 6= ◦\nAlém disso:\n1 S′ [(a,X), (ā, Y )] é demonstrável ⇐⇒ S′(X,Y ) é demonstrável; 2 S′ [(a,X), (T{ā}, Y )] é demonstrável ⇐⇒ S′([T{ā}, (a,X)], Y ) é demonstrável; 3 S′ [(R{a},X), (T{ā}, Y )] é demonstrável ⇐⇒ S′([T{ā}, (R{a},X)], Y ) ou\nS′([R{a}, (T{ā}, Y )],X) é demonstrável.\nArgumentação a favor da conjectura: A primeira parte da conjectura segue facilmente da definição de número de incoerência\ne da minimalidade de a.\nSeja S{a, ā} = [X{a}, Y {ā}]. A demonstração da demonstrabilidade seria por indução\nsobre o número de incoerência de {a, ā}.\n• Caso 1: S′ [(a,X), (ā, Y )]\n(⇒) Por indução no tamanho da derivaçãoΠ de S [(a,X), (ā, Y )]. Se occ X ∩ occ Y = ∅, então acreditamos que não seria criada nenhuma inconsistência. Se occX ∩ occ Y 6= ∅, a estrutura inicial conteria uma subestrutura equivalente a [(a, b), (ā, b̄)], que sabemos não ser demonstrável pela condição C2 do Teorema 52.\n(⇐) Considere a demonstração\nS(Y,X) ai↓\nS([a, ā], Y,X) s\nS([a, (ā, Y )],X) s\nS [(a,X), (ā, Y )]\n• Caso 2: S′ [(a,X), (T{ā}, Y )], T{◦} 6= ◦\nConsidere a derivação que “esquece”X:"
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 89",
      "text" : "S′([T{ā}, (a,X)], Y ) s\nS′ [(a,X), (T{ā}, Y )]\nIsto se occ X ∩ occ Y = ∅. Mas se occ X ∩ occ Y 6= ∅ a estrutura já não seria demonstrável pela condição C2 do Teorema 52.\nAcreditamos que o resultado seguiria por indução.\n• Case 3: S′ [(R{a},X), (T{ā}, Y )], R{◦} 6= ◦ e T{◦} 6= ◦\nNesse caso há duas hipóteses, sendo que necessariamente pelo menos uma das duas ocorre:\n1. R{a} ∩ Y = ∅\nNesse caso poderíamos usar o fato de que R{a} ∩ Y = ∅, “esquecer”X e fazer:\nS′([T{ā}, (R{a},X)], Y ) s\nS′ [(R{a},X), (T{ā}, Y )]\nIsto se occ X ∩ occ Y = ∅. Mas se occ X ∩ occ Y 6= ∅ a estrutura já não seria demonstrável pela condição C2 do Teorema 52.\nAcreditamos que o resultado seguiria por indução.\n2. T{ā} ∩X = ∅\nNesse caso poderíamos usar o fato de que T{ā} ∩X = ∅, “esquecer” Y e fazer:\nS′([R{a}, (T{ā}, Y )],X) s\nS′ [(R{a},X), (T{ā}, Y )]\nIsto se occ X ∩ occ Y = ∅. Mas se occ X ∩ occ Y 6= ∅ a estrutura já não seria demonstrável pela condição C2 do Teorema 52.\nAcreditamos que o resultado seguiria por indução.\nFaltaria apenas mostrar que R{a} ∩ Y = ∅ ou T{ā} ∩ X = ∅ deve ocorrer. Imagine, por contradição, que R{a} ∩ Y 6= ∅ e T{ā} ∩X 6= ∅. Então as seguintes asserções são verdadeiras:\n∃n ∈ occ Y.n̄ ∈ occ R{a} =⇒\n{\nY = Y ′{n} ∧ R{a} = R′{a, n̄}\n∃m ∈ occ Y.m̄ ∈ occ T{ā} =⇒\n{\nX = X ′{m} ∧ T{ā} = T ′{ā, m̄}\nTomemos o caso de R{a} = R′{a, n̄}. Há apenas duas possibilidades:\nR{a} = R′{a, n̄} =⇒\n{\nR′{a, n̄} = R′′ [P{a}, P ′{n̄}] ∨ R′{a, n̄} = R′′(P{a}, P ′{n̄})"
    }, {
      "heading" : "90 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "Similarmente, para T{ā} = T ′{ā, m̄} também há apenas duas possibilidades:\nT{ā} = T ′{ā, m̄} =⇒\n{\nT ′{ā, m̄} = T ′′ [Q{ā}, Q′{m̄}] ∨ T ′{ā, m̄} = T ′′(Q{ā}, Q′{m̄})\nCombinando as possibilidades para R{a} e T{ā}, há, então, quatro possibilidades a serem avaliadas:\n1. R′{a, n̄} = R′′ [P{a}, P ′{n̄}] e T ′{ā, m̄} = T ′′ [Q{ā}, Q′{m̄}]\nNesse caso S = [(R′′ [P{a}, P ′{n̄}],X ′{m}), (T ′′ [Q{ā}, Q′{m̄}], Y ′{n})].\n2. R′{a, n̄} = R′′ [P{a}, P ′{n̄}] e T ′{ā, m̄} = T ′′(Q{ā}, Q′{m̄})\nNesse caso S = [(R′′ [P{a}, P ′{n̄}],X ′{m}), (T ′′(Q{ā}, Q′{m̄}), Y ′{n})]\n3. R′{a, n̄} = R′′(P{a}, P ′{n̄}) e T ′{ā, m̄} = T ′′ [Q{ā}, Q′{m̄}]\nNesse caso S = [(R′′(P{a}, P ′{n̄}),X ′{m}), (T ′′ [Q{ā}, Q′{m̄}], Y ′{n})]\n4. R′{a, n̄} = R′′(P{a}, P ′{n̄}) e T ′{ā, m̄} = T ′′(Q{ā}, Q′{m̄})\nNesse caso S = [(R′′(P{a}, P ′{n̄}),X ′{m}), (T ′′(Q{ā}, Q′{m̄}), Y ′{n})]\nEm qualquer dos casos acima, temos que S possui uma subestrutura da forma:\nm\n` `\n` `\nn\nm̄\n>~ >~\n>~ >~\nn̄\no que, pela condição C2 do Teorema 52, mostra que a estrutura S já não seria, desde o princípio, demonstrável, o que entra em contradição com a hipótese de que S é demonstrável. Logo, não é o caso em que R{a} ∩ Y 6= ∅ e T{ā} ∩X 6= ∅.\nFim da argumentação a favor da conjectura. Antes de enunciar o resultado principal, vamos apresentar um lema auxiliar que, apesar\nde não ser essencial, facilita a estratégia proposta.\nLema 71 (Estratégia para {S}#a,ā = 0 ou {S} # a,ā = 1). Se S é demonstrável em FBV contendo apenas pares de átomos distintos dois a dois, podemos escolher eliminar qualquer par de átomos duais a, ā ∈ occ S tal que {S}#a,ā = 0 ou 1.\nDemonstração. Pelos Lemas 66 e 63.\nAgora sim estamos prontos para enunciar o resultado principal desta dissertação, atra-\nvés do teorema seguinte."
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 91",
      "text" : "Conjectura 72 (Tentativa de estratégia de demonstração). Existe um algoritmo que corresponde a uma estratégia de demonstração para toda estrutura demonstrável S em FBV contendo apenas pares\nde átomos distintos dois a dois.\nArgumentação a favor da conjectura: Considere a estratégia fornecida pelos Lemas 64, 66 e 71 e pela Conjectura 70. Comece a demonstração pela redução da subestrutura que contém ocorrências de átomos a e ā de número de incoerência módulo coerência igual a 0 ou 1 (pelo Lema 71 posso começar a por qual par de átomos duais cujo número de incoerência módulo coerência seja 0 ou 1. Pelos lemas 64 e 66 sei como agir em cada caso). Se não houver tal subestrutura, escolha o par de átomos com menor número de incoerência módulo coerência e “reduza” este número via “esquecimento” (pela Conjectura 70). Se um estágio for atingido sobre o qual não se possa avançar, é porque a estrutura já não era demonstrável desde o início (pelos lemas 64, 66 e pela conjectura 70).\nFim da argumentação a favor da conjectura. Vamos demonstrar a aplicação da tentativa de estratégia proposta na Conjectura 72 atra-\nvés de um exemplo.\nExemplo 73. Seja a seguinte estrutura demonstrável em FBV com pares de átomos dois a dois distintos:\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\nVamos prosseguir com a estratégia proposta, passo a passo.\n1. Estrutura a ser demonstrada:\nS = [(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\nNúmeros de incoerência módulo coerência:\nÁtomo i a b c d e\n{S}# i,̄i\n2 2 2 2 2\nTodos os valores são iguais a 2, portanto posso escolher qualquer um como sendo o menor. Escolhamos o par a, ā.\nComo {S}#a,ā = 2, recorremos então à conjectura 70, que trata de número de incoerência módulo coerência maior que 1, e vemos que o nosso caso equivale a:\nS′ [(a,X), (T{ā}, Y )]\n \n\nX = b̄\nY = c̄\nT{ā} = [ā, b̄]\n, de onde concluímos que devemos “esquecer” X e a regra de inferência a ser aplicada é um switch da forma:"
    }, {
      "heading" : "92 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "S′([T{ā}, (a,X)], Y ) s\nS′ [(a,X), (T{ā}, Y )]\nAssim, podemos começar a construção da nossa demonstração:\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n2. Agora temos que demonstrar a seguinte estrutura:\nS = [([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)]\nNúmeros de incoerência módulo coerência:\nÁtomo i a b c d e\n{S}# i,̄i\n1 1 2 2 2\nHá dois valores iguais a 1, portanto, posso escolher {S}#a,ā = 1.\nRecorremos, então, ao Lema 66, que trata de número de incoerênica módulo coerência igual a 1, e vemos que o nosso caso equivale a:\nS′ [a, (ā,X)] } X = b̄\n, de onde concluímos que devemos “esquecer” X e a regra de inferência a ser aplicada é um switch da forma:\nS′([a, ā],X) s\nS′ [a, (ā,X)]\nAssim, podemos continuar a construção da nossa demonstração:\n[([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)] s\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n3. Agora a estrutura a ser demonstrada é a seguinte:\nS = [([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)]\nNúmeros de incoerência módulo coerência:"
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 93",
      "text" : "Átomo i a b c d e\n{S}# i,̄i\n0 1 2 2 2\nO menor valor é {S}#a,ā = 0\nRecorremos, então, ao Lema 64, que trata de número de incoerênica módulo coerência igual a 0, e vemos que o nosso caso equivale a:\nS′ [a, ā]\n, de onde concluímos que devemos aplicar uma instância de ai↓ da forma:\nS′{◦} ai↓\nS′ [a, ā]\nAssim, podemos continuar a construção da nossa demonstração, já levando em conta a relação de equivalência sintática:\n[([b, b̄], c̄), (c, [d̄, e]), (d, ē)] =\n[([b, (◦, b̄)], c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)] s\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n4. Temos que demonstrar, então, a seguinte estrutura:\nS = [([b, b̄], c̄), (c, [d̄, e]), (d, ē)]\nNúmeros de incoerência módulo coerência:\nÁtomo i b c d e\n{S}# i,̄i\n0 2 2 2\nO menor valor é {S}# b,b̄ = 0.\nRecorremos, então, ao Lema 64, que trata de número de incoerênica módulo coerência igual a 0, e vemos que o nosso caso equivale a:\nS′ [b, b̄]\n, de onde concluímos que devemos aplicar uma instância de ai↓ da forma:"
    }, {
      "heading" : "94 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "S′{◦} ai↓\nS′ [b, b̄]\nAssim, podemos continuar a construção da nossa demonstração, já levando em conta a relação de equivalência sintática:\n[c̄, (c, [d̄, e]), (d, ē)] =\n[(◦, c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, b̄], c̄), (c, [d̄, e]), (d, ē)] =\n[([b, (◦, b̄)], c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)] s\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n5. Neste momento temos que a estrutura a ser demonstrada é:\nS = [c̄, (c, [d̄, e]), (d, ē)]\nNúmeros de incoerência módulo coerência:\nÁtomo i c d e\n{S}# i,̄i\n1 2 2\nO menor valor é {S}#c,c̄ = 1.\nRecorremos, então, ao Lema 66, que trata de número de incoerênica módulo coerência igual a 1, e vemos que o nosso caso equivale a:\nS′ [c, (c̄, X)] } X = [d̄, e]\n, de onde concluímos que devemos “esquecer” X e a regra de inferência a ser aplicada é um switch da forma:\nS′([c, c̄],X) s\nS′ [c, (c̄, X)]\nAssim, podemos continuar a construção da nossa demonstração:"
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 95",
      "text" : "[([c, c̄], [d̄, e]), (d, ē)] s\n[c̄, (c, [d̄, e]), (d, ē)] =\n[(◦, c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, b̄], c̄), (c, [d̄, e]), (d, ē)] =\n[([b, (◦, b̄)], c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)] s\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n6. Agora a estrutura a ser demonstrada é a seguinte:\nS = [([c, c̄], [d̄, e]), (d, ē)]\nNúmeros de incoerência módulo coerência:\nÁtomo i c d e\n{S}# i,̄i\n0 2 2\nO menor valor é {S}#c,c̄ = 0\nRecorremos, então, ao Lema 64, que trata de número de incoerênica módulo coerência igual a 0, e vemos que o nosso caso equivale a:\nS′ [c, c̄]\n, de onde concluímos que devemos aplicar uma instância de ai↓ da forma:\nS′{◦} ai↓\nS′ [c, c̄]\nAssim, podemos continuar a construção da nossa demonstração, já levando em conta a relação de equivalência sintática:"
    }, {
      "heading" : "96 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS",
      "text" : "[d̄, e, (d, ē)] =\n[(◦, [d̄, e]), (d, ē)] ai↓\n[([c, c̄], [d̄, e]), (d, ē)] s\n[c̄, (c, [d̄, e]), (d, ē)] =\n[(◦, c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, b̄], c̄), (c, [d̄, e]), (d, ē)] =\n[([b, (◦, b̄)], c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)] s\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n7. Neste momento temos que a estrutura a ser demonstrada é:\nS = [d̄, e, (d, ē)]\nNúmeros de incoerência módulo coerência:\nÁtomo i d e\n{S}# i,̄i\n1 1\nHá dois valores iguais a 1, portanto, posso escolher {S}# d,d̄ = 1.\nRecorremos, então, ao Lema 66, que trata de número de incoerênica módulo coerência igual a 1, e vemos que o nosso caso equivale a:\nS′ [d, (d̄,X)] } X = ē\n, de onde concluímos que devemos “esquecer” X e a regra de inferência a ser aplicada é um switch da forma:\nS′([d, d̄],X) s\nS′ [d, (d̄,X)]\nAssim, podemos continuar a construção da nossa demonstração:"
    }, {
      "heading" : "4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 97",
      "text" : "[([d, d̄], ē), e] s\n[d̄, e, (d, ē)] =\n[(◦, [d̄, e]), (d, ē)] ai↓\n[([c, c̄], [d̄, e]), (d, ē)] s\n[c̄, (c, [d̄, e]), (d, ē)] =\n[(◦, c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, b̄], c̄), (c, [d̄, e]), (d, ē)] =\n[([b, (◦, b̄)], c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)] s\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n8. Agora a estrutura a ser demonstrada é a seguinte:\nS = [([d, d̄], ē), e]\nNúmeros de incoerência módulo coerência:\nÁtomo i d e\n{S}# i,̄i\n0 1\nO menor valor é {S}# d,d̄ = 0\nRecorremos, então, ao Lema 64, que trata de número de incoerênica módulo coerência igual a 0, e vemos que o nosso caso equivale a:\nS′ [d, d̄]\n, de onde concluímos que devemos aplicar uma instância de ai↓ da forma:\nS′{◦} ai↓\nS′ [d, d̄]\nAssim, podemos continuar a construção da nossa demonstração, já levando em conta a relação de equivalência sintática:\n98 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS\n[ē, e] =\n[(◦, ē), e] ai↓\n[([d, d̄], ē), e] s\n[d̄, e, (d, ē)] =\n[(◦, [d̄, e]), (d, ē)] ai↓\n[([c, c̄], [d̄, e]), (d, ē)] s\n[c̄, (c, [d̄, e]), (d, ē)] =\n[(◦, c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, b̄], c̄), (c, [d̄, e]), (d, ē)] =\n[([b, (◦, b̄)], c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)] s\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n9. Chegamos a um ponto em que só falta demonstrar a estrutura:\nS = [ē, e]\nNúmeros de incoerência módulo coerência:\nÁtomo i e\n{S}# i,̄i\n0\nO menor valor é {S}#e,ē = 0\nRecorremos, então, ao Lema 64, que trata de número de incoerênica módulo coerência igual a 0, e vemos que o nosso caso equivale a:\nS′ [e, ē]\n, de onde concluímos que devemos aplicar uma instância de ai↓ da forma:\nS′{◦} ai↓\nS′ [e, ē]\nAssim, podemos continuar a construção da nossa demonstração, já levando em conta a relação de equivalência sintática:\n4.3. A TENTATIVA DE SOLUÇÃO PROPOSTA 99\n◦ ai↓\n[ē, e] =\n[(◦, ē), e] ai↓\n[([d, d̄], ē), e] s\n[d̄, e, (d, ē)] =\n[(◦, [d̄, e]), (d, ē)] ai↓\n[([c, c̄], [d̄, e]), (d, ē)] s\n[c̄, (c, [d̄, e]), (d, ē)] =\n[(◦, c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, b̄], c̄), (c, [d̄, e]), (d, ē)] =\n[([b, (◦, b̄)], c̄), (c, [d̄, e]), (d, ē)] ai↓\n[([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)] s\n[([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)] s\n[(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\n10. Para finalizar, temos que:\nS = ◦\ne podemos invocar o axioma lógico (unidade), concluindo, assim, a nossa demonstração:\n100 CAPÍTULO 4. ASPECTOS COMPUTACIONAIS DO CÁLCULO DAS ESTRUTURAS\n◦ ↓ ◦\nai↓ [ē, e]\n= [(◦, ē), e]\nai↓ [([d, d̄], ē), e]\ns [d̄, e, (d, ē)]\n= [(◦, [d̄, e]), (d, ē)]\nai↓ [([c, c̄], [d̄, e]), (d, ē)]\ns [c̄, (c, [d̄, e]), (d, ē)]\n= [(◦, c̄), (c, [d̄, e]), (d, ē)]\nai↓ [([b, b̄], c̄), (c, [d̄, e]), (d, ē)]\n= [([b, (◦, b̄)], c̄), (c, [d̄, e]), (d, ē)]\nai↓ [([b, ([a, ā], b̄)], c̄), (c, [d̄, e]), (d, ē)]\ns [([(a, b̄), ā, b], c̄), (c, [d̄, e]), (d, ē)]\ns [(a, b̄), (c̄, [ā, b]), (c, [d̄, e]), (d, ē)]\nCapítulo 5\nImplementação\nA tentativa de estratégia de demonstração proposta para o sitema FBV com pares de átomos distintos dois a dois foi implementada em uma ferramenta chamada de CoSProver (demonstrador de cálculo das estruturas). A implementação foi feita em Java e a documentação se encontra disponível em [?].\nO formato de entrada e saída de dados para o CoSProver é apresentado a seguir."
    }, {
      "heading" : "5.1 Entrada de dados",
      "text" : "A entrada para o CoSProver é uma <estrutura> em FBV gerada pela seguinte gramática:\n<unidade> ::= * <letra> ::= a . . . z | A . . . Z <algarismo> ::= 0 . . . 9 <atm> ::= <letra> | <algarismo> | <atm> <letra> |\n<atm> <algarismo>\n<atomo> ::= <atm> | ˜<atm> <estruturas> ::= <estrutura> | <estruturas> , <estrutura> <estrutura> ::= <unidade> | <atomo> | [<estruturas>] | (<estruturas>)\nA tabela 5.1 apresenta exemplos de construções válidas da gramática acima.\n<unidade> * <atomo> a, ˜b1, aToMo, ˜123 <estrutura> *, ˜a, [a,˜b1], (c,[˜a,b])\nTabela 5.1: Exemplos das principais construções da gramática de estruturas para o CoSProver.\nSão exemplos de entradas válidas:\n1. [˜a, (a,˜b), (b,˜c), (c,˜d), (d,˜e), (e,˜f), f ]\n101"
    }, {
      "heading" : "102 CAPÍTULO 5. IMPLEMENTAÇÃO",
      "text" : "2. [(a,b,c), ˜a, ˜b, ˜c]\n3. (a, [˜a], *)\n4. *\n5. [[a,b], *]\nNote que a estrutura de entrada não precisa estar na forma normal. As estruturas (3) e (5) possuem unidades, a estrutura (3) apresenta um singleton e a estrutura (5) apresenta associatividade explícita.\nAlém disso, é importante observar que as únicas estruturas que podem estar negadas são átomos. Por exemplo, a estrutura ˜(a,b), apesar de ser bem formada para o sistema FBV, não é uma entrada permitida. Uma estrutura equivalente permitida seria [˜a, ˜b]"
    }, {
      "heading" : "5.2 Saída de dados",
      "text" : "A saída é uma mensagem dizendo que a estrutura não é provável (se for o caso), ou então uma demonstração em FBV para a estrutura dada.\nCaso haja uma demonstração, cada instância de regra:\nredex ρ contractum\né representada por\nregra redex\ncontractum\nToda estrutura que aparece na saída está na forma normal. As instâncias de regras trivi-\nais (equivalência =) são omitidas.\nA Tabela 5.2 apresenta a representação do nome das regras.\nRegra Representação\n◦ ↓ oi ai↓ ai s s\nTabela 5.2: Representação de regras na saída.\nSão exemplos de saídas:\n5.2. SAÍDA DE DADOS 103\n1.\noi ai * ai [˜c,c] s [˜c,([b,˜b],c)] ai [˜b,˜c,(b,c)] s [˜b,˜c,([a,˜a],b,c)]\n[(a,b,c),˜a,˜b,˜c]\n2.\noi ai * ai [f,˜f] s [f,([e,˜e],˜f)] ai [(e,˜f),f,˜e] s [(e,˜f),f,([d,˜d],˜e)] ai [(d,˜e),(e,˜f),f,˜d] s [(d,˜e),(e,˜f),f,([c,˜c],˜d)] ai [(c,˜d),(d,˜e),(e,˜f),f,˜c] s [(c,˜d),(d,˜e),(e,˜f),f,([b,˜b],˜c)] ai [(b,˜c),(c,˜d),(d,˜e),(e,˜f),f,˜b] s [(b,˜c),(c,˜d),(d,˜e),(e,˜f),f,([a,˜a],˜b)]\n[˜a,(a,˜b),(b,˜c),(c,˜d),(d,˜e),(e,˜f),f]\n3.\noi ai * ai [e,˜e] s [e,([d,˜d],˜e)] ai [(d,˜e),˜d,e] s [(d,˜e),([c,˜c],[˜d,e])] ai [(c,[˜d,e]),(d,˜e),˜c] ai [(c,[˜d,e]),(d,˜e),([b,˜b],˜c)] s [(c,[˜d,e]),(d,˜e),([b,([a,˜a],˜b)],˜c)] s [(c,[˜d,e]),(d,˜e),([˜a,b,(a,˜b)],˜c)]\n[(a,˜b),(˜c,[˜a,b]),(c,[˜d,e]),(d,˜e)]\n4. [(a,b),(˜a,˜b)]\nThe structure is not provable.\n5. [(a,˜b),(b,˜c),(c,˜d),(d,˜e),(e,˜f),(f,˜a)]\nThe structure is not provable."
    }, {
      "heading" : "104 CAPÍTULO 5. IMPLEMENTAÇÃO",
      "text" : ""
    }, {
      "heading" : "5.3 Complexidade computacional",
      "text" : "Uma questão importante é analisar a complexidade computacional em termos de tempo do algoritmo proposto. Duas questões centrais para a implementação da estratégia de demonstração são:\n1. Como calcular o número de incoerência módulo coerência.\n2. Como resolver a questão da igualdade sob a definição de relação de equivalência sin-\ntática.\nVamos discutir em mais detalhes a complexidade de uma dessas questões.\n5.3.0.3 Cálculo do número de incoerência módulo coerência\nSeja n = |occ S|, ou seja, o tamanho da estrutura a ser demonstrada S. A complexidade de se calcular o número de incoerência módulo coerência entre dois átomos a e b no contexto S é O(n4). A estratégia precisa que se calcule o menor número de incoerência módulo coerência, portanto é preciso calcular {S}# i,̄i para cada um dos n/2 pares de átomos duais (i, ī). Dessa, forma, a complexidade de se calcular o menor {S}# i,̄i é O(n/2 ∗ n4) = O(n5), o que é, claramente, um custo polinomial.\n5.3.0.4 Igualdade sob a definição de relação de equivalência sintática\nUma possível fonte de não-determinismo é a que se oculta sob a relação de equivalência sintática (ver Figura 3.1). Uma mesma estrutura pode se apresentar em diversas formas equivalentes. Por exemplo:\n[a, (b, c)] = [(a, ◦), (b, [c, ◦])] = [ [a], (b, (c))]\nA rigor, esse não determinismo não causa nenhum problema do ponto de vista da aplicação da estratégia proposta. O número de incoerência módulo coerência é calculado sobre a teia de interação da estrutura, e o Teorema 23 garante que duas estruturas equivalentes possuem a mesma teia de interação. Logo, como só se lida com a teia de interação, pouco importa a maneira como a estrutura está apresentada.\nEntretanto, a fim de uniformizar a representação utilizada, toda estrutura dentro do CoSProver deve estar na forma normal (ver Seção 3.1.2). Ou seja, em toda estrutura é preciso que:\n• as únicas estruturas negadas sejam átomos;\n• não haja unidades (◦);\n• nenhum delimitador possa ser eliminado mantendo a equivalência."
    }, {
      "heading" : "5.4. QUALIDADE DOS RESULTADOS 105",
      "text" : "A opção por colocar, sempre que possível, as estruturas em sua forma normal tem duas vantagens principais. Em primeiro lugar, é esteticamente mais agradável a apresentação de estruturas na forma mais compacta que é a forma normal. Em segundo lugar, a representação em forma normal evita subestruturas desnecessárias, o que representa uma economia de memória na sua representação interna ao CoSProver.\nA estrutura de entrada não precisa estar na forma normal, entretanto, as únicas estruturas negadas devem ser átomos (ver Seção 5.1). Além disso, a cada aplicação de regra de inferência, o redex é colocado na forma normal antes de dar prosseguimento ao algoritmo.\nPortanto, é preciso uma função que coloque uma estrutura na forma normal. Como nenhuma regra de inferência lida com negação, e a estrutura de entrada só pode possuir átomos negados, o algoritmo que coloca uma estrutura na forma normal dentro do CoSProver precisa lidar com os seguintes casos:\n1. Eliminar unidades.\nExemplo: [a, b, ◦, c] =⇒ [a, b, c]\n2. Eliminar delimitadores supérfluos. Divide-se em dois casos:\na) Eliminar singletons.\nExemplo: [a, (b), c] =⇒ [a, b, c]\nb) Eliminar associatividade explícita.\nExemplo: [a, [b, c] ] =⇒ [a, b, c]\nO algoritmo que coloca estruturas na forma normal realiza os três passos seguintes:\n1. elimina unidades a um custo O(n2);\n2. elimina singletons a um custo O(n2);\n3. elimina associatividade explícita a um custo O(n2);\nComo os três passsos são seqüenciais, o custo final de colocar uma estrutura na forma\nnormal é de O(n2), o que é, claramente, um custo polinomial."
    }, {
      "heading" : "5.4 Qualidade dos resultados",
      "text" : "Como visto no capítulo 4, o algoritmo proposto consiste em uma tentativa de estratégia, no sentido de que a demonstração matemática de seu funcionamento ainda não está completa neste estágio da pesquisa. Entretanto, para todos os testes realizados, o CoSProver obteve o resultado correto, fornecendo uma demonstração no caso de a estrutura ser demonstrável, ou indicando que a mesma não o é.\nSabemos que a ausência de contra-exemplos não equivale a uma demonstração de correção, mas em se tratando de um campo de pesquisa novo e de um formalismo cujo comportamento operacional ainda não é completamente compreendido, este fato é um indício de o"
    }, {
      "heading" : "106 CAPÍTULO 5. IMPLEMENTAÇÃO",
      "text" : "caminho escolhido possa ser promissor ou, no mínimo, que ainda é cedo para descartá-lo sem mais investimento em sua pesquisa.\nCapítulo 6\nConclusão\nO impacto que o cálculo das estruturas provocou na comunidade de Teoria da Demonstração ainda não foi completamente absorvido. Como um formalismo em muitos casos mais poderoso que o cálculo de seqüentes, aquele mais utilizado até então, o cálculo das estruturas deixou a comunidade muito interessada em entender como ele poderia ser melhor explorado. Após a formalização de diversas lógicas em cálculo das estruturas, como a lógica clássica, a intuicionista, a modal, etc., a atenção tem se voltado para o problema de como implementar um sistema que utilize o cálculo das estruturas. A questão central reside no alto grau de não-determinismo que o formalismo apresenta.\nUma idéia é encontrar uma estratégia de demonstrações para o cálculo das estruturas, que torne possível sua implementação, inspirada no conceito de demonstrações uniformes para cálculo de seqüentes. Neste trabalho propusemos uma tentativa de estratégia que atende esse objetivo para um subconjunto do sistema FBV, um subsistema do sistema BV, que corresponde ao fragmento multiplicativo da lógica linear mais a regra mix (MLL + mix+ seq). Dizemos tentativa de estratégia porque, apesar de se basear em resultados teóricos apresentados formalmente e de ter funcionado perfeitamente em todos os testes que executamos (através da implementação computacional da tentativa de estratégia), a demonstração de sua correção ainda está em curso (apesar de a maior parte do trabalho neste sentido já estar pronta).\nSe comprovada, a nossa tentativa de estratégia apresentará como principais contribui-\nções relevantes:\n1. A estratégia teria uma fundamentação teórica, e não apenas operacional. Omelhor tra-\nbalho no sentido de se melhorar a implementação do cálculo das estruturas até então se baseia na redução do não-determinismo do formalismo pela restrição da maneira como se aplicam regras de inferência. Esta é uma abordagem predominantemente operacional, que não captura a essência do processo de demonstração.\n2. A estratégia não exigiria bactracking: uma vez que se decidisse aplicar uma regra de in-\nferência, ela não precisaria ser reconsiderada mais em nenhummomento. A estratégia manteria a demonstrabilidade da estrutura em cada passo, de forma que seria sempre\n107"
    }, {
      "heading" : "108 CAPÍTULO 6. CONCLUSÃO",
      "text" : "possível avançar na busca pela demonstração. Se não for possível avançar a partir de um certo ponto, é porque a estrutura já não era demonstrável desde o princípio.\nComo pontos a serem melhorados, podemos levantar as seguintes questões:\n1. Ela funcionaria somente para um subsistema do sistema FBV (lógica linear multiplica-\ntiva MLL mais a regra mix) em que não houvesse pares de átomos repetidos. É preciso ainda mais trabalho para suportar átomos repetidos e incluir na estratégia a noção de como lidar com a estrutura seq, no sentido de expandí-la para ser usada no sistema BV completo.\n2. As estruturas que poderiam ser demonstradas deveriam ter pares de átomos distintos,\nou seja, não seriam permitidos dois átomos iguais. Se a estrutura possuísse átomos iguais, seria possível diferenciá-los atribuindo índices diferentes aos átomos. Entretanto, o trabalho de atribuir estes índices parece não ser trivial, pois é preciso ter uma função de escolha f : occ S → occ S. f(a) = ¬a ∧ a ↓ ā, que é uma condição necessária para uma estrutura ser provável.\nPara finalizar, podemos dizer que o trabalho representa um passo, apesar de restrito a um subsistema do sistema BV, importante para o entendimento dos aspectos computacionais do cálculo das estruturas e, sem dúvida, terá certa visibilidade na comunidade de Teoria da Demonstração."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2013,
    "abstractText" : "Logic is the science of correct inferences and a logical system is a tool to prove assertions in a certain logic in a correct way. There are many logical systems, and many ways of formalizing them, e.g., using natural deduction or sequent calculus. Calculus of structures (CoS) is a new formalism proposed by Alessio Guglielmi in 2004 that generalizes sequent calculus in the sense that inference rules can be applied at any depth inside a formula, rather than only to the main connective. With this feature, proofs in CoS are shorter than in any other formalism supporting analytical proofs. Although it is great to have the freedom and expressiveness of CoS, under the point of view of proof search more freedom means a larger search space. And that should be restricted when looking for complete automation of deductive systems. Some efforts were made to reduce this non-determinism, but they are all basically operational approaches, and no solid theoretical result regarding the computational behaviour of CoS has been achieved so far. The main focus of this thesis is to discuss ways to propose a proof search strategy for CoS suitable to implementation. This strategy should be theoretical instead of purely operational. We introduce the concept of incoherence number of substructures inside structures and we use this concept to achieve our main result: there is an algorithm that, according to our conjecture, corresponds to a proof search strategy to every provable structure in the subsystem of FBV (the multiplicative linear logic MLL plus the rule mix) containing only pairwise distinct atoms. Our algorithm is implemented and we believe our strategy is a good starting point to exploit the computational aspects of CoS in more general systems, like BV itself.",
    "creator" : "LaTeX with hyperref package"
  }
}