{
  "name" : "1402.0588.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Refined View of Causal Graphs and Component Sizes: SP-Closed Graph Classes and Beyond",
    "authors" : [ "Christer Bäckström", "Peter Jonsson" ],
    "emails" : [ "christer.backstrom@liu.se", "peter.jonsson@liu.se" ],
    "sections" : [ {
      "heading" : "1. Introduction",
      "text" : "We will first briefly explain what a causal graph is and give a short survey of applications as well as theoretical results reported in the literature. Following that, we give an overview of the new results presented in this article."
    }, {
      "heading" : "1.1 Background",
      "text" : "The causal graph for a planning instance is an explicit description of the variable dependencies that are implicitly defined by the operators. More precisely, it is a directed graph such that there is an arc from a variable x to another variable y if either x appears in the precondition of an operator with an effect on y or some operator has effects on both x and y.\nThis standard definition of the causal graph can be traced back to Knoblock (1994) although he did not give it a name. He used the causal graph in the Alpine algorithm, as a guidance for partitioning and ordering the variables in the process of automatically deriving state abstraction hierarchies. The actual name causal graph can be traced back to Williams and Nayak (1997). Their approach was both more general and more restricted\nc©2013 AI Access Foundation. All rights reserved.\nthan Knoblock’s. On the one hand, they generalized the concept from binary variables to multi-valued variables, but on the other hand, they considered only acyclic causal graphs which implies that all operators are unary, i.e. every operator changes only one variable. The context of their work was the reactive planner Burton for onboard space-ship control. A causal model was compiled into a transition system that could be efficiently exploited by a reactive controller to choose appropriate operators to achieve given goals. The compilation was done in such a way that all operators were unary, and they claimed that this is often possible in real applications. The resulting acyclicity of the causal graph was then exploited by Burton, which traversed the graph bottom up in order to issue operators in an order consistent with their causal relationships.\nJonsson and Bäckström (1998b) also studied acyclic causal graphs, but referred to them as dependency graphs. They considered a subclass of such graphs having a particular structure and used this to implicitly define a corresponding class of planning instances, the 3S class. This class has the property that it is always possible to decide in polynomial time if there is a solution or not, but the solutions themselves may be of exponential length, thus necessarily taking exponential time to generate. Although only one single restricted case, the 3S class is probably the first example of relating structural properties of the causal graph to the computational complexity of planning. A more general and extensive such analysis was done by Domshlak and Dinitz (2001a), who analysed the complexity of planning for classes of instances corresponding to a number of different possible structures of acyclic causal graphs. However, their work was done in the context of multi-agent coordination and the term causal graph was never used.\nThe first two of these papers may be viewed as early examples of exploiting the causal graph in practice, while the latter papers form the starting point of the subsequent theoretical research into the relationships between planning complexity and the structure of causal graphs.\nAn important step forward in the usage of causal graphs was the paper by Helmert (2004) where he demonstrated that the causal graph is particularly useful in the context of multi-valued variables. Previous research on the complexity of planning with multi-valued variables had focussed on the structure of the domain-transition graphs for the variables (Jonsson & Bäckström, 1998a), rather than the causal graph. Helmert realized the power of using both the domain-transition graphs and the causal graph in heuristic planning. This was exploited in practice in his highly succesful Fast Downward planner (Helmert, 2006a). It translates PDDL planning instances with binary variables into a representation with multi-valued variables and then removes carefully chosen edges in the resulting causal graph to make it acyclic. The resulting causal graph is then used to compute a heuristic by hierarchically computing and composing plan lengths for subgraphs having one of the particular structures studied by Domshlak and Dinitz (2001a). Somewhat similarly, Katz and Domshlak (2010) identified subgraphs of the causal graph that have certain structures that make planning for them tractable. They exploited this to be able to use larger variables sets when constructing pattern databases. A further example of exploiting the causal graph to make planning more efficient is the paper on factored planning by Brafman and Domshlak (2006). They showed that the structure of the causal graph can be used as a guide for deciding if and how a planning instance can be solved more efficiently by dividing it into loosely coupled subinstances and use constraint processing. The basic idea of the causal\ngraph to represent variable dependencies is, of course, quite general and not necessarily restricted to planning. For instance, Wehrle and Helmert (2009) transferred the causal graph concept to the context of model checking.\nAs previously mentioned, the two papers by Jonsson and Bäckström (1998b) and by Domshlak and Dinitz (2001a) can be viewed as the starting point for a successful line of research into studying the relationships between planning complexity and the structure of the causal graph. While the 3S class by Jonsson and Bäckström was a very limited special case, Domshlak and Dinitz studied classes of planning instances corresponding to a number of more general graph structures, like in-stars (aka. inverted forks), out-stars (aka. forks), directed path graphs (aka. directed chain graphs), polytrees and singly-connected DAGs. Further results followed, for instance, in articles by Brafman and Domshlak (2003), and Giménez and Jonsson (2008). The latter article additionally showed that although 3S instances can have exponential-length plans, it is possible to generate a macro representation of such a plan in polynomial time, a result they extended also to some other classes defined by the structure of the causal graph. Many of the complexity results in these papers use additional numerical parameters in conjunction with the graph structure. Examples of such parameters are the maximum domain size of the variables and the maximum in-degree of the graph. While increasing the number of possible cases to analyse, it does allow for a more fine-grained analysis in many cases. Consider for instance the case of directed path graphs. Domshlak and Dinitz (2001a) proved that it is tractable to decide if there is a plan for this case when the domains are binary, while Giménez and Jonsson (2009) proved that a domain size of 5 is sufficient to make the problem NP-hard. Similarly, Giménez and Jonsson (2012) proved tractability for planning instances with binary variables, a constant number of prevail conditions and where the causal graph is a polytree. Also the paper by Brafman and Domshlak (2006) fits into this line of theoretical research, exhibiting a planning algorithm that runs in time exponential in two parameters, the tree-width of the undirected version of the causal graph and the maximum number of times a variable must change value.\nWhile most research has been based on the standard definition of causal graphs that was set already by Knoblock, although often in the generalisation to multi-valued variables, there are important exceptions. One potential problem with the standard defintion is that whenever two variables are both affected by the same operator, then the causal graph must necessarily contain cycles, which is the major reason why the focus has mainly been on planning with unary operators. In an attempt to circumvent this problem, Jonsson (2009) defined a more relaxed variant of the causal graph that does not always introduce cycles for non-unary operators, which can sometimes allow for a more fine-grained complexity analysis.\nThe previous results relate the structure of the causal graph to the complexity of satisficing planning, i.e. deciding if there is a plan. There has also been a corresponding branch of research relating the structure of the causal graph to the complexity of cost-optimal planning (cf., Katz & Domshlak, 2007, 2008, 2010; Katz & Keyder, 2012)."
    }, {
      "heading" : "1.2 Our Contributions",
      "text" : "All of the theoretical research above studies the complexity of planning based on the structure of the causal graph, and possibly other parameters like domain sizes. An important\nmilestone that deviates from this line of research was an article by Chen and Giménez (2010) who did not even consider the structure of the causal graph but only a simple quantitative measure, the size of the weakly connected components. They proved that deciding if there is a plan can be done in polynomial time if and only if the size of the weakly connected components in the causal graph is bounded by a constant. In one sense, this is a very sharp and final result. However, the intractability result for unbounded components is conditional on the assumtion that W[1] 6⊆ nu-FPT. This assumption relies on the theory of parameterised complexity theory and neither the complexity classes nor the assumption itself can be related to ordinary complexity classes in a clear way. Chen and Giménez acknowledge that the problems they prove conditionally intractable include NP-intermediate problems. Hence, we take their result as a take-off point for further investigation of how the component sizes reflect on the standard complexity classes. Since we know from Chen and Giménez that not all graph classes with unbounded components are NP-hard we must consider further restrictions in order to find NP-hard classes. We do so by adding a new type of closure property, SP-closure, which is incomparable to subset-closure but is a subset of minor-closure, and prove that planning is NP-hard for any SP-closed graph class with unbounded components. It should be noted that this result still holds for the class of all acyclic graphs, which is important considering the practical relevance of acyclicity previously mentioned.\nWhile many graph classes that have been studied in the literature are indeed SP-closed, there also exists natural classes that lack this property. We present one way of handling such classes with the aid of non-uniform complexity theory. In this case, we are not able to show NP-hardness but we can show that the polynomial hierarchy collapses to its second level. This is a fairly general result that can be applied even when the component sizes grow very slowly and the graph class is not very densely populated with graphs. Also this result holds even if restricted to acyclic graphs. This result can be used to demonstrate clearly that complexity results for planning based only on the class of causal graphs does not necessarily have any connection to the complexity of a generic planning problem having the same class of causal graphs. This result also raises the question of where to find (preferably natural) NP-intermediate planning problems. Chen and Giménez state that NP-intermediate problems can be obtained by using methods similiar to the ones employed by Bodirsky and Grohe (2008). Such problems are hard to describe as natural, though. They are based on Ladner’s (1975) diagonalization technique that removes a large fraction of input strings from a problem. It is apparently difficult to connect graph classes constructed by this technique with simple conditions on component growth. As an alternative, we show that graph classes where the component sizes grow polylogarithmically are NP-intermediate under the double assumption that W[1] 6⊆ nu-FPT and that the exponential time hypothesis (Impagliazzo & Paturi, 2001) holds. We also show that for every k > 1, there exists a class Gk of graphs such that component size is bounded by |V (G)|1/k for all G ∈ Gk and the corresponding planning problem is NP-hard. These results coarsely stake out the borderline between NP-hard and NP-intermediate classes.\nA possible conclusion from this paper is that complexity analysis of planning based only on the structure of the causal graph is of limited value, and that additional parameters are needed to achieve more useful results. While this may be a fair conclusion in general, there are cases where the graph structure is sufficient. For instance, Katz, Hoffmann, and Domsh-\nlak (2013) have applied the result by Chen and Giménez (2010) in the context of so called red-black planning, a variant of delete relaxation for computing heuristics. Furthermore, even when the structure of the causal graph has to be combined with other parameters, it is still important to know the behaviour of each parameter in isolation.\nThe remainder of the article is structured as follows. In Section 2 we set the notation and terminology used for planning and for graphs, and in Section 3 we define causal graphs and structural planning in general. Section 4 contains a number of NP-hardness results for various special graph classes that we need for the main results. The first of the two main theorems of the article appears in Section 5, where we define the concept of SP-closed graph classes and prove that planning is NP-hard for such classes when the component size is unbounded. Section 6 discusses some of the problems with both the previous theorem and other similar results in the literature. As a way around these problems, our second main theorem shows that even without any closure requirements, planning is likely to be hard even when the components grow slowly and the graphs do not appear densely in the class. Section 7 contains some observations concerning the borderline between NP-intermediate and NP-hard planning problems. The article ends with a discussion section."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "This section sets the terminology and notation for planning and graphs used in this article. We write |X| to denote the cardinality of a set X or the length of a sequence X, i.e. the number of elements in X, and we write ||X|| to denote the size of the representation of an object X."
    }, {
      "heading" : "2.1 Planning",
      "text" : "Since this article has many connections with the one by Chen and Giménez (2010) we follow their notation and terminology for plannning, which is a notational variant of SAS+ (Bäckström & Nebel, 1995). An instance of the planning problem is a tuple Π = (V, init, goal, A) whose components are defined as follows:\n• V is a finite set of variables, where each variable v ∈ V has an associated finite domain D(v). Note that variables are not necessarily propositional, that is, D(v) may be any finite set. A state is a mapping s defined on the variables V such that s(v) ∈ D(v) for all v ∈ V . A partial state is a mapping p defined on a subset vars(p) of the variables V such that for all v ∈ vars(p), it holds that p(v) ∈ D(v), and p is otherwise undefined.\n• init is a state called the initial state.\n• goal is a partial state.\n• A is a set of operators; each operator a ∈ A consists of a precondition pre(a) and a postcondition post(a) which are both partial states. We often use the notation 〈pre ; post〉 to define an operator with precondition pre and postcondition post. For instance, a = 〈x = 0, y = 1 ; z = 1〉 defines an operator a which is applicable in any state s such that s(x) = 0 and s(y) = 1, and which has the effect of setting variable z to 1.\nWhen s is a state or a partial state and W is a subset of the variable set V , we write s W to denote the partial state resulting from restricting s to W . We say that a state s is a goal state if goal = s vars(goal).\nWe define a plan (for an instance Π) to be a sequence of operators P = a1, . . . , an. Starting from a state s, we define the state resulting from s by applying a plan P , denoted by s[P ], inductively as follows. For the empty plan P = , we define s[ ] = s. For non-empty plans P we define s[P ] as follows, where a is the last operator in P and P ′ is the prefix of P up to, but not including, a:\n• If pre(a) 6= s[P ′] vars(pre(a)) (that is, the preconditions of a are not satisfied in the state s[P ′]), then s[P ′, a] = s[P ′].\n• Otherwise, s[P ′, a] is the state equal to post(a) on variables v ∈ vars(post(a)), and equal to s[P ′] on variables v ∈ V \\ vars(post(a)).\nA plan P is a solution plan if init[P ] is a goal state. We are concerned with the computational problem plan existence (PlanExist): given an instance Π = (V, init, goal, A), decide if there exists a solution plan."
    }, {
      "heading" : "2.2 Graphs",
      "text" : "A directed graph is a pair (V,E) where V is the vertex set and E ⊆ V × V is the edge set. An undirected graph is a pair (V,E) where V is the vertex set and E ⊆ {{u, v} | u, v ∈ V } is the edge set. We will often only say graph and edge if it is clear from the context whether it is directed or undirected. The notation V (G) refers to the vertex set of a graph G and E(G) refers to its edge set. If e = (u, v) or e = {u, v} is an edge, then the vertices u and v are incident with e. Furthermore, the directed edge (u, v) is an outgoing edge of u and an incoming edge of v. For a directed graph G = (V,E), we write U(G) to denote the correspsonding undirected graph U(G) = (V,EU ) where EU = {{u, v} | (u, v) ∈ E}. That is, U(G) is the undirected graph induced by G by ignoring the orientation of edges.\nLet G = (V,E) be a directed graph and let v0, . . . , vk ∈ V such that v1, . . . , vk are distinct and (vi−1, vi) ∈ E for all i (1 ≤ i ≤ k). Then the sequence v0, . . . , vk is a directed path of length k in G if v0 6= vk and it is a directed cycle of length k in G if v0 = vk. Paths and cycles in undirected graphs are defined analogously, except that there is no direction to consider. A graph is acyclic if it contains no cycles.\nLet G = (V,E) be a directed graph and let v ∈ V be a vertex. Then, v is isolated if it has no incoming or outgoing edges, v is a source if it has at least one outgoing edge but no incoming edge, v is a sink if it has at least one incoming edge but no outgoing edge and otherwise v is intermediate.\nLet G = (VG, EG) and H = (VH , EH) be two directed graphs. Then G and H are isomorphic (denoted G ' H) if there exists a bijective function f : VG → VH such that (u, v) ∈ EG if and only if (f(u), f(v)) ∈ EH . Furthermore, H is a subgraph of G if VH ⊆ VG and EH ⊆ EG ∩ (VH × VH). When EH = EG ∩ (VH × VH) we say that the subgraph H is induced by the vertex set VH . Isomorphisms and subgraphs are analogously defined for undirected graphs.\nLet G be an undirected graph. Then G is connected if there is a path between every pair of vertices in G. A connected component of G is a maximal subgraph of G that is\nconnected. Let G be a directed graph. Then G is weakly connected if U(G) is connected. A weakly connected component of G is a maximal subgraph of G that is weakly connected. That is, in a weakly connected component there are paths between every pair of vertices if we ignore the direction of edges. Let G = (VG, EG) and H = (VH , EH) be two directed graphs such that VG and VH are disjoint. Then the (disjoint) union of G and H is defined as G ∪H = (VG ∪ VH , EG ∪ EH) and is a commutative operation. Note that if a graph G consists of the (weakly) connected components G1, . . . , Gn, then G = G1 ∪G2 ∪ . . . ∪Gn.\nWe further define some numeric graph parameters. For a directed graph G and a vertex v ∈ V (G), the indegree of v is |{u ∈ V (G) | (u, v) ∈ E(G)}|, i.e. the number of incoming edges incident with v, and the outdegree of v is |{u ∈ V (G) | (v, u) ∈ E(G)}|, i.e. the number of outgoing edges incident with v. For an undirected graph G, the degree of v ∈ V (G) is |{u ∈ V (G) | {v, u} ∈ E(G)}|, i.e. the number of edges incident with v. We extend this to graphs as follows. If G is an undirected graph, then deg(G) denotes the largest degree of any vertex in V (G). Similarly, if G is a directed graph then in-deg(G) denotes the largest indegree of any vertex in V (G) and out-deg(G) denotes the largest outdegree of any vertex in V (G). Furthermore, if G is an undirected graph, then path-length(G) denotes the length of the longest path in G and cc-size(G) denotes the size of the largest connected component in G. If G is a directed graph, then path-length(G) denotes the length of longest directed path in G. We also define upath-length(G) = path-length(U(G)) and cc-size(G) = cc-size(U(G)). That is, upath-length(G) is the length of the longest path in G if ignoring the direction of edges and cc-size(G) is the size of the largest weakly connected component in G. Note that if G is an undirected connected graph, then path-length(G) equals the diameter of G. We extend all such numeric graph properties (in-deg, path-length etc.) to sets of graphs such that if C is a set of graphs and prop is a graph property, then prop(C) = maxG∈C prop(G)."
    }, {
      "heading" : "2.3 Special Graph Types",
      "text" : "In the literature on causal graphs, as well as in this article, there are certain types of graphs that are of particular interest and that are thus useful to refer to by names. We distinguish the following types of undirected graphs: A tree is an undirected graph in which any two vertices are connected by exactly one path, i.e. it is acyclic and connected. A path graph is a tree where all vertices have degree 1 or 2, i.e. it is a tree that does not branch. A star graph is a tree where all vertices except one, the centre vertex, have degree 1.\nFor directed graphs, we distinguish the following types: An in-star graph is a directed graph G such that U(G) is a star graph and all edges are directed towards the centre. An out-star graph is a directed graph G such that U(G) is a star graph and all edges are directed out from the centre. A directed path graph is a directed graph G such that U(G) is a path graph, in-deg(G) ≤ 1 and out-deg(G) ≤ 1, i.e. G is a directed path over all its vertices and contains no other edges. A polytree is a directed graph G such that U(G) is a tree, i.e. G is a weakly connected directed graph that can be constructed from a tree by giving a unique direction to every edge. A polypath is a directed graph G such that U(G) is a path graph, i.e. G is a weakly connected directed graph that can be constructed from a path graph by giving a unique direction to every edge. A fence is a polypath where every vertex is either a source or a sink, i.e. the edges alternate in direction at every vertex.\nIt should be noted that the out-star graph is usually called a directed star graph in graph theory, while the in-star graph appears to have no standard name. We hence deviate sligthly from standard terminology in order to have logical names for both graph types. Also the polypath appears to have no standard name, but polypath is a logical term in analogy with polytree. It should be further noted that a parallel terminology for certain graph types has evolved in the literature on causal graphs in planning. For instance, instars, out-stars and directed paths are commonly referred to as inverted forks, forks and directed chains, respectively.\nNote that the number of sinks and sources in a polypath differ by at most one, i.e. a polypath with m sinks has m+ c sources for some c ∈ {−1, 0, 1}. Furthermore, every fence is a polypath, but not every polypath is a fence.\nWe define the following graphs and graphs classes:\n• Sink denotes the in-star graph with one centre vertex and k sources. Also define the class Sin = {Sink | k ≥ 0}.\n• Soutk denotes the out-star with one centre vertex and k sinks. Also define the class Sout = {Soutk | k ≥ 0}.\n• dPk denotes the directed path on k vertices. Also define the class dP = {dPk | 1 ≤ k}.\n• F cm, for c ∈ {−1, 0, 1}, denotes the fence with m sinks and m+ c sources. Also define the class Fc = {F cm | 1 ≤ m}, for each c ∈ {−1, 0, 1}, and the class F = F−1∪F0∪F+1.\nExamples of these graph types are illustrated in Figure 1.\nThe following observation about polypaths will be used later on.\nProposition 1. Let G be a polypath with at most m sinks and m + 1 sources such that path-length(G) ≤ k. Then |V (G)| ≤ 2mk + 1.\nProof. There are at most 2m distinct paths from a source to a sink, each of these having at most k− 1 intermediate vertices. Hence |V (G)| ≤ m+ (m+ 1) + 2m(k− 1) = 2mk+ 1.\nThis bound is obviously tight in the case where there are m sinks and m + 1 sources, and every path from a source to a sink contains exactly k − 1 intermediate vertices."
    }, {
      "heading" : "3. Structurally Restricted Planning",
      "text" : "The topic of study in this article is causal graphs for planning, but before discussing this concept we first define the concept of domain-transition graphs (Jonsson & Bäckström, 1998a). Although not used explicitly in any of our results, it is useful for explaining some of the proofs later in the article. Let Π = (V, init, goal, A) be a planning instance. For each variable v ∈ V , we define the domain-transition graph (DTG) for v as a directed graph (D(v), E), where for all x, y ∈ D(v), E contains the edge (x, y) if there is some operator a ∈ A such that post(a)(v) = y and either pre(a)(v) = x or v 6∈ vars(pre(a)).\nThe causal graph for a planning instance describes how the variables of the instance depends on each other, as implicitly defined by the operators.\nDefinition 2. The causal graph of a planning instance Π = (V, init, goal, A) is the directed graph CG(Π) = (V,E) where E contains the edge (u, v) for every pair of distinct vertices u, v ∈ V such that u ∈ vars(pre(a)) ∪ vars(post(a)) and v ∈ vars(post(a)) for some operator a ∈ A.\nThe causal graph gives some, but not all, information about the operators. For instance, if the causal graph is acyclic, then all operators must be unary, i.e. |vars(post)(a)| = 1 for all operators, since any non-unary operator must necessarily introduce a cycle according to the definition. However, the presence of cycles does not necessarily mean that there are non-unary operators. For instance, if both the edges (u, v) and (v, u) are present in the graph, then this can mean that there is some operator a such that both u ∈ vars(post(a)) and v ∈ vars(post(a)). However, it can also mean that there are two operators a and a′ such that u ∈ vars(pre(a)), v ∈ vars(post(a)), v ∈ vars(pre(a′)) and u ∈ vars(post(a′)), which could thus both be unary operators. Similarly, the degree of the vertices provides an upper bound on the number of pre- and postconditions of the operators, but no lower bound. Suppose there is a vertex u with indegree 2 and incoming edges (v, u) and (w, u). This could mean that there is some operator a such that u ∈ vars(post(a)) and both v ∈ vars(pre(a)) and w ∈ vars(pre(a)). However, it can also mean that there are two different operators a and a′ such that v ∈ vars(pre(a)), u ∈ vars(post(a)), w ∈ vars(pre(a′)) and u ∈ vars(post(a′)).\nThe PlanExist problem is extended from planning instances to causal graphs in the following way. For a class C of directed graphs, PlanExist(C) is the problem of deciding for an arbitrary planning instance Π such that CG(Π) ∈ C, whether Π has a solution or not. That is, the complexity of PlanExist(C) refers to the complexity of the set of planning instances whose causal graphs are members of C.\nThere are a number of results in the literature on the computational complexity of planning for various classes of causal graphs. However, these results usually assume that the graph class has a restricted structure, e.g. containing only in-stars or only directed paths. A more general and abstract result is the following theorem.\nTheorem 3. (Chen & Giménez, 2010, Thm. 3.1) Let C be a class of directed graphs. If cc-size(C) is bounded, then PlanExist(C) is solvable in polynomial time. If cc-size(C) is unbounded, then PlanExist(C) is not polynomial-time solvable (unless W[1] ⊆ nu-FPT).\nWhile the theorem describes a crisp borderline between tractable and intractable graph classes, it does so under the assumption that W[1] 6⊆ nu-FPT1. Both these complexity classes are from the theory of parameterised complexity and cannot be immediately related to the usual complexity classes. It is out of the scope of this article to treat parameterised complexity and we refer the reader to standard textbooks (Downey & Fellows, 1999; Flum & Grohe, 2006). The result in the theorem is not a parameterised result, however; it is only the condition that is parameterised, so it suffices to note that the intractability result holds under a condition that is difficult to relate to other common assumptions, such as P 6= NP. One of the reasons why Chen and Giménez were forced to state the theorem in this way was that a classification into polynomial and NP-hard classes would not have been exhaustive, since there are graph classes that are NP-intermediate. (A problem is NP-intermediate if it is neither in P nor NP-complete, unless P = NP.)\nThis theorem might be viewed as the starting point for the research reported in this article, where we investigate this problem from the perspective of standard complexity classes. For instance, NP-hardness can be proved in the case of unbounded components if adding further restrictions, which we will do in Section 5."
    }, {
      "heading" : "4. Basic Constructions",
      "text" : "This section presents some results that are necessary for the theorems later in the article. The first three results, that planning is NP-hard for in-stars (aka. inverted forks), out-stars (aka. forks) and directed paths (aka. directed chains), are known from the literature, while the NP-hardness result for fences is new. We will, however, provide new proofs also for the in-star and out-star cases. The major reason is that in Section 6 we will need to refer to reductions that have certain precisely known properties. Furthermore, the original proofs are only published in a technical report (Domshlak & Dinitz, 2001b) and may thus be hard to access.\nLemma 4. (Domshlak & Dinitz, 2001a, Thm. 3.IV) PlanExist(Sin) is NP-hard. This result holds even when restricted to operators with at most 2 preconditions and 1 postcondition.\nProof. (New proof) Proof by reduction from 3SAT to a class of planning instances with causal graphs in Sin. The reduction constructs a planning instance where each source in the causal graph corresponds to one of the variables in the formula and the centre corresponds to the clauses. The construction is illustrated in Figure 2 and formally defined as follows.\nLet F = c1∧ . . .∧cm be an arbitrary 3SAT formula with variables x1, . . . , xn and clauses c1, . . . , cm. Construct a corresponding planning instance ΠF = (V, init, goal, A) as follows:\n• V = {vc, v1, . . . , vn}, where D(vc) = {0, . . . ,m} and D(vi) = {u, f, t}, for all i (1 ≤ i ≤ n).\n1. The condition can be simplified to W[1] 6⊆ FPT if the class C is recursively enumerable.\n• init(vi) = u, for all i (1 ≤ i ≤ n), and init(vc) = 0.\n• goal(vc) = m and goal is otherwise undefined.\n• A consists of the following operators:\n– For each i (1 ≤ i ≤ n), A contains the operators set-f(i)= 〈vi = u ; vi = f〉 and set-t(i)= 〈vi = u ; vi = t〉. – For each clause ci = (` 1 i ∨ `2i ∨ `3i ) and each j (1 ≤ j ≤ 3), there is some k such\nthat `ji = xk or ` j i = xk, so let A contain either the operator verify-clause-pos(i, j)= 〈vc = i− 1, vk = t ; vc = i〉, if `ji = xk, or the operator verify-clause-neg(i, j)= 〈vc = i− 1, vk = f ; vc = i〉, if `ji = xk.\nClearly, the instance ΠF can be constructed in polynomial time and CG(ΠF ) = S in n , so it remains to prove that ΠF has a solution if and only if F is satisfiable.\nEach source variable vi can be changed independently. It starts with the undefined value u and can be set to either t or f , corresponding to true and false, respectively, for the corresponding variable xi in F . Once it is set to either t or f , it cannot be changed again. That is, variables v1, . . . , vn can be used to choose and commit to a truth assignment for x1, . . . , xn. The centre variable vc has one value, i, for each clause ci in F , plus the initial value 0. It is possible to reach the goal value m from the inital value 0 by stepping through\nall intermediate values in numerical order. For each such step, from i − 1 to i, there are three operators to choose from, corresponding to each of the literals in clause ci. The step is possible only if one of v1, . . . , vn is set to a value consistent with one of the literals in ci. That is, the goal vc = m can be achieved if and only if variables v1, . . . , vn are set to values corresponding to a truth assignment for x1, . . . , xn that satisfies F .\nThe restricted case (with respect to pre- and post-conditions) is immediate from the construction above.\nThe problem is known to be tractable, though, if the domain size of the centre variable is bounded by a constant (Katz & Domshlak, 2010). Furthermore, the causal graph heuristic by Helmert (2004) is based on identifying in-star subgraphs of the causal graph, and it should be noted that he provided a variant of the original proof due to some minor technical differences in the problem formulations.\nLemma 5. (Domshlak & Dinitz, 2001a, Thm. 3.III) PlanExist(Sout) is NP-hard. This result holds even when restricted to operators with at most 1 precondition and 1 postcondition.\nProof. (New proof) Proof by reduction from 3SAT to a class of planning instances with causal graphs in Sout. The reduction constructs a planning instance where the centre vertex of the causal graph corresponds to the variables in the formula and each sink corresponds to one of the clauses. The construction is illustrated in Figure 3 and formally defined as follows.\nLet F = c1∧ . . .∧cm be an arbitrary 3SAT formula with variables x1, . . . , xn and clauses c1, . . . , cm. Construct a corresponding planning instance ΠF = (V, init, goal, A) as follows:\n• V = {vc, v1, . . . , vm}, where D(vc) = {f0, . . . , fn, t0, . . . , tn} and D(vi) = {u, s}, for all i (1 ≤ i ≤ m).\n• init(vi) = u, for all i (1 ≤ i ≤ m), and init(vc) = f0.\n• goal(vi) = s, for all i (1 ≤ i ≤ m), and goal(vc) is undefined.\n• A consists of the following operators:\n– For each i (1 ≤ i ≤ n), A contains the operators step-c(fi−1, fi)= 〈vc = fi−1 ; vc = fi〉, step-c(fi−1, ti)= 〈vc = fi−1 ; vc = ti〉, step-c(ti−1, fi)= 〈vc = ti−1 ; vc = fi〉 and step-c(ti−1, ti)= 〈vc = ti−1 ; vc = ti〉. – For each clause ci = (` 1 i ∨ `2i ∨ `3i ) and each j (1 ≤ j ≤ 3), there is a k such that\n`ji = xk or ` j i = xk, so let A contain either the operator verify-clause-pos(i, j)= 〈vc = tk ; vi = s〉, if `ji = xk, or the operator verify-clause-neg(i, j)= 〈vc = fk ; vi = s〉, if `ji = xk.\nClearly, the instance ΠF can be constructed in polynomial time and CG(ΠF ) = S out n , so it remains to prove that ΠF has a solution if and only if F is satisfiable. Variable vc can be changed independently and it has two values, ti and fi, for each variable xi in F , corresponding to the possible truth values for xi. In addition there is an initial value f0 (and a dummy value t0 in order to simplify the formal definition). Both the values tn and fn are reachable from the initial value f0, and each such plan will correspond to a path f0, z1, z2, . . . , zn where each zi is either ti or fi. That is, vc must pass either value ti or fi, but not both, for each i. Hence, any such path will correspond to a truth assignment for the variables x1, . . . , xn in F . For each clause ci in F , there is a corresponding variable vi that can change value from the initial value u, unsatisfied, to the goal value s, satisfied. Each vi has three operators to do this, one for each literal in ci. That is, if ci contains a literal xk (or xk) then vi can change value from u to s while vc has value tk (or fk). Hence, the goal v1 = . . . = vm = s can be achieved if and only if there is a path for vc that corresponds to a truth assignment for x1, . . . , xn that satisfies F . (Note, though, that vc must not always follow a path all the way to fn or tn since a partial assignment may sometimes be sufficient to prove satisfiability.)\nThe restricted case (with respect to pre- and post-conditions) is immediate from the construction above.\nThe problem is known to be tractable, though, if the domain size of the centre variable is bounded by a constant (Katz & Keyder, 2012).\nThe following result on planning with directed-path causal graphs is also known from the literature.\nLemma 6. (Giménez & Jonsson, 2009, Prop. 5.5) PlanExist(dP) is NP-hard, even when all variables have domain size 5 and the operators have at most 2 preconditions and 1 postcondition.\nWe refer to Giménez and Jonsson for the proof. However, we will implicitly use their proof later in this article so there are a few important observations to make about it. The reduction is from SAT and, thus, works also as a reduction from 3SAT. Furthermore, the reduction transforms a formula with n variables and m clauses to a planning instance with (2m+4)n variables. As a final remark, this problem is known to be tractable if all variables have a domain of size 2 (Domshlak & Dinitz, 2001a).\nWhile the three previous results are known in the literature, the following result is new to the best of our knowledge.\nLemma 7. PlanExist(F+1) is NP-hard. This result holds even when restricted to operators with at most 2 preconditions and 1 postcondition.\nProof. Proof by reduction from 3SAT to a class of planning instances with causal graphs in F+1.\nThe reduction constructs a planning instance where each sink of the causal graph corresponds to one of the clauses in the formula, while each source corresponds to all variables. Furthermore, the source variables are synchronized to have the same behaviour. The construction is illustrated in Figure 4 and formally defined as follows.\nLet F = c1∧ . . .∧cm be an arbitrary 3SAT formula with variables x1, . . . , xn and clauses c1, . . . , cm. Construct a corresponding planning instance ΠF as follows:\n• V = {u0, . . . , um, v1, . . . , vm}, where D(ui) = {f0, . . . , fn, t0, . . . , tn}, for all i (0 ≤ i ≤ m), and D(vi) = {fu0 , . . . , fum, tu0 , . . . , tum, fs0 , . . . fsm, ts0, . . . , tsm, s}, for all i (1 ≤ i ≤ m).\n• init(ui) = f0, for all i (0 ≤ i ≤ m), and init(vi) = fu0 , for all i (1 ≤ i ≤ m).\n• goal(vi) = s, for all i (1 ≤ i ≤ m), and goal is otherwise undefined.\n• Let A consist of the following operators:\n– For all i, j (1 ≤ i ≤ n, 0 ≤ j ≤ m), A contains the operators step-x(j, fi−1, fi)= 〈uj = fi−1 ; uj = fi〉, step-x(j, fi−1, ti)= 〈uj = fi−1 ; uj = ti〉, step-x(j, ti−1, fi)= 〈uj = ti−1 ; uj = fi〉 and step-x(j, ti−1, ti)= 〈uj = ti−1 ; uj = ti〉. – For all i, j, (1 ≤ i ≤ n, 1 ≤ j ≤ m), A contains the operators step-clause-u(j, fui−1, f u i )= 〈vj = fui−1, uj−1 = fi, uj = fi ; vj = fui 〉,\nstep-clause-u(j, fui−1, t u i )= 〈vj = fui−1, uj−1 = ti, uj = ti ; vj = tui 〉, step-clause-u(j, tui−1, f u i )= 〈vj = tui−1, uj−1 = fi, uj = fi ; vj = fui 〉, step-clause-u(j, tui−1, t u i )= 〈vj = tui−1, uj−1 = ti, uj = ti ; vj = tui 〉, step-clause-s(j, f si−1, f s i )= 〈vj = f si−1, uj−1 = fi, uj = fi ; vj = f si 〉, step-clause-s(j, f si−1, t s i )= 〈vj = fsi−1, uj−1 = ti, uj = ti ; vj = tsi 〉, step-clause-s(j, tsi−1, f s i )= 〈vj = tsi−1, uj−1 = fi, uj = fi ; vj = fsi 〉, step-clause-s(j, tsi−1, t s i )= 〈vj = tsi−1, uj−1 = ti, uj = ti ; vj = tsi 〉,\n– For each j (1 ≤ j ≤ m), A contains the operators finalize-clause-f(j)= 〈vj = fsn ; vj = s〉 and finalize-clause-t(j)= 〈vj = tsn ; vj = s〉.\n– For each clause ci = (` 1 i ∨ `2i ∨ `3i ) and for each j (1 ≤ j ≤ 3), there is a k such\nthat `ji = xk or ` j i = xk so let A contain either the operator verify-pos(i, j)= 〈vi = tuk ; vi = tsk〉, if ` j i = xk, or the operator verify-neg(i, j)= 〈vi = fuk ; vi = fsk〉, if ` j i = xk.\nClearly, the instance ΠF can be constructed in polynomial time and CG(ΠF ) = F +1 m . Hence, it remains to prove that ΠF has a solution if and only if F is satisfiable.\nFirst consider only variables ui and vi, for some i. The construction of the domain and the operators for ui is identical to the one for vc in the proof of Lemma 5, i.e. there is a directed path from value f0 to fn or tn for every possible truth assignment for the variables x1, . . . , xn in F . Variable vi, corresponds to clause ci and contains two copies of the DTG for ui, where the values differ only in the extra superscript, u or s. The latter copy is extended with the additional value s, denoting that the clause has been satisfied. There are operators that allows vi to mimic the behaviour of ui; it can follow the corresponding path in either of its two copies. Furthermore, for each of the three literals in ci there is an operator that\nmakes it possible to move from value zuk to value z s k if value zk of ui is consistent with this literal. Since vi starts at f u 0 and must reach either f s m or t s m in order to reach the goal value s, it is necessary for vi to make such a transition for one of the literals in ci. That is, if ui follows the path f0, z1, . . . , zn then vi must follow the path f u 0 , z u 1 , . . . , z u k , z s k, . . . , z s n, s, for some k such that xk occurs in a literal in ci and zk is a satisfying truth value for this literal.\nNow consider also variable ui−1. Since each operator that affects the value of vi either has the same precondition on both ui−1 and ui or no precondition on either, it follows that ui−1 and ui must both choose the same path if vi is to reach its goal. Since every variable vj forces synchronization of its adjacent variables uj−1 and uj in this manner, it follows that all of u0, . . . , um must choose exactly the same path for any plan that is a solution. It thus follows from this and from the argument for ui and vi that the goal v1 = . . . = vm = s can be achieved if and only if there is a path that all of u0, . . . , um can choose such that this path corresponds to a satisfying truth assignment for F .\nFor the restriction, we first note that it is immediate from the construction that operators with 3 preconditions and 1 postcondition are sufficient. To see that 2 preconditions are sufficient, consider the following variation on the construction. Each step-clause-u and stepclause-t operator is replaced with two operators as follows. As an example, consider an operator step-clause-u(j, fui−1, t u i ). First introduce an extra value ft u i in D(vj). Then replace the operator with two new operators step-clause-u(j, fui−1, ft u i )= 〈vj = fui−1, uj−1 = ti ; vj = ftui 〉 and\nstep-clause-u(j, ftui , t u i )= 〈vj = ftui , uj = ti ; vj = tui 〉.\nConsider the step in the DTG for vj from f u i−1 to t u i . In the original construction, this is done by the single operator step-clause-u(j, fui−1, t u i ), which requires that both uj−1 and uj have value ti. The modified construction instead requires two steps, first a step from f u i−1 to the new intermediate value ftui and then a step from this value to t u i . The previous conjunctive constraint that uj−1 = uj = ti is replaced by a sequential constraint that first uj−1 = ti and then uj = ti. Although it is technically possible for uj−1 to have moved on to a new value when the second step is taken, this does not matter; both uj−1 and uj must still choose exactly the same path in their respective DTGs.\nCorollary 8. PlanExist(F−1), PlanExist(F0) and PlanExist(F) are NP-hard.\nProof. Neither of the two outer source vertices, u0 and um, are necessary in the construction in the previous proof. Hence, by omitting either or both of these the reduction works also for F−1 and F0. Finally, PlanExist(F) is NP-hard since F+1 ⊆ F.\nWe now have all the basic results necessary for the main theorems of the following two sections."
    }, {
      "heading" : "5. Graph Classes and Closure Properties",
      "text" : "Like most other results in the literature, the results in the previous section are about classes consisting of some particular graph type, like the class Sin of all in-stars or the class F of all fences. This section will depart from this and instead study graph classes with certain closure properties. We will first discuss the standard concepts of subgraph closure and minor closure, finding that the first does not contain all the graphs we need while the latter results\nin a set with too many graphs. For that reason, we will define a new concept, SP-closure, which is incomparable with subgraph closure but is a subset of minor closure. We will then show that this closure concept defines a borderline between the non-NP-hard graph classes and large number of useful NP-hard classes."
    }, {
      "heading" : "5.1 Subgraph Closure and Minor Closure",
      "text" : "Suppose C is a class of graphs which is closed under taking subgraphs. Then for every graph G in C it is the case that every subgraph H of G must also be in C. Subgraph closure is not sufficient for our purposes, though. For instance, a subgraph of a polypath will always be either a polypath or a graph where every weakly connected component is a polypath. However, a polypath need not have any subgraphs that are fences of more than trivial size. We will need a closure property that guarantees that if C contains a polypath with m sinks, then it also contains a fence with m sinks. An obvious candidate for this is the concept of minor-closure, which is a superset of the subgraph-closure. The concepts of graph minors and minor-closure has rapidly evolved into a very important and useful research area in mathematical as well as computational graph theory (Lovász, 2005; Mohar, 2006).\nIn order to define graph minors we first need the concept of edge contraction, which is commonly defined as follows, although other definitions occur in the literature.\nDefinition 9. Let G = (V,E) be a directed graph and let e = (u, v) ∈ E be an edge such that u 6= v. Then the contraction of e in G results in a new graph G′ = (V ′, E′), such that\n• V ′ = (V \\ {u, v}) ∪ {w} and\n• E′ = {(f(x), f(y)) | (x, y) ∈ E, (x, y) 6= (u, v) and (x, y) 6= (v, u)},\nwhere w is a new vertex, not in V , and the function f : V → V ′ is defined such that f(u) = f(v) = w and otherwise f(x) = x.\nThat is, when an edge (u, v) is contracted, the two vertices u and v are replaced with a single new vertex w and all edges that were previously incident with either u or v are redirected to be incident with w. Figure 5 shows an example of edge contraction. We say that a graph H is a contraction of another graph G if H can result from contracting zero or more edges in G.\nThe concept of graph minors can now be defined as follows.\nDefinition 10. A directed graph H is a minor of a directed graph G if H is isomorphic to a graph that can be obtained by zero or more edge contractions of a subgraph of G.\nAn example is illustrated in Figure 6. The graph G in the figure is a weakly connected directed graph, which also happens to be a polypath. If vertex v9 is removed from G, then the restriction to the remaining vertices is still a weakly connected graph which is a subgraph of G. Removing also v4 results in the graph H, which consists of two weakly connected components H1 and H2. All of H, H1 and H2 are subgraphs of G, but they are also minors of G, since a subgraph is a minor, by definition. Contracting the edge (v1, v2) in H1 results in the graph M1, where w1 is the new vertex replacing v1 and v2. Similarly, contracting the edge (v8, v7) in H2 results in M2. The graph M1 is a minor of G since it is\nthe result of an edge contraction in the subgraph H1 of G and the graph M2 is analogously a minor of G too. Also the graph M , consisting of the two components M1 and M2 is a minor of G, since it is the result of two contractions in the subgraph H of G. While the graphs H, H1 and H2 are both subgraphs and minors of G, the graphs M , M1 and M2 are only minors of G, not subgraphs.\nA trivial example of a minor-closed class is the class of all graphs, which is minor-closed since it contains all graphs and every minor of a graph is itself a graph. More interestingly, many commonly studied graph types result in minor-closed classes. For instance, the class Sin of all in-stars is minor-closed, as is the class Sout of all out-stars and the class dP of all\ndirected paths. Furthermore, a weakly connected minor of a polypath is a polypath and a weakly connected minor of a polytree is a polytree. As an illustration, once again consider Figure 6. The graph G is a polypath, and the weakly connected graphs H1, H2, M1 and M2 are all minors of G, but they are also polypaths. In fact, M1 and M2 are also fences. Note though, that neither H nor M is a polypath, since they both consist of more than one weakly connected component. It is worth noting, however, that the class F of all fences is not minor-closed although every fence is a polypath; a weakly connected minor of a fence must be a polypath, but it is not necessarily a fence.\nRequiring minor-closed graph classes is, however, overly strong. For instance, it would be sufficient to require that for every graph G ∈ C, also every weakly connected minor of G is in C. That is, in the example in Figure 6 we would require that H1, H2, M1 and M2 are all in C if G is in C, but we would not require that also H and M are in C. This is both reasonable and desirable in the context of causal graphs. If the causal graph of a planning instance consists of two or more weakly connected components, then these components correspond to entirely independent subinstances that can be solved separately.\nFurthermore, certain natural restrictions do not mix well with minor-closed classes. Consider, for instance, the example in Figure 7, with an acyclic graph G = (V,E), where V = {v1, v2, v3, v4} and E = {(v1, v2), (v2, v3), (v3, v4), (v1, v4)}. If we contract the edge (v1, v4) to a new vertex w we get a cycle graph on the vertices w, v2, v3. That is, a class of acyclic graphs is not minor-closed in general, which is problematic considering the importance of acyclic causal graphs."
    }, {
      "heading" : "5.2 SP-Closed Graph Classes",
      "text" : "In order to avoid problems with acyclicity (and other similar problems) and to avoid defining special variants of the contraction and minor concepts, we instead identify a set of minimal requirements that a closure must satisfy in order to imply NP-hardness for the PlanExist problem. We will focus on one such set of restrictions, defining a concept we refer to as SP-closure (where SP denotes that the set is closed under stars and polypaths).\nDefinition 11. Let G and H be two directed graphs. Then H is an SP-graph of G if H is weakly connected and either of the following holds:\n1. H is an in-star that is a subgraph of G,\n2. H is an out-star that is a subgraph of G or\n3. H can be obtained by zero or more contractions of some polypath G′ such that G′ is a subgraph of G.\nA class C of graphs is SP-closed if it contains every SP-graph of every graph G ∈ C.\nSP-closure has a number of interesting properties, including the following:\nProposition 12. Let G and H be directed graphs and let C be a class of directed graphs.\n1. If G is a polypath, then every SP-graph of G is a polypath.\n2. Every SP-graph of G is acyclic.\n3. If H is an SP-graph of G, then H is a minor of G.\n4. If C is minor-closed, then C is SP-closed.\nProof. 1) Suppose G is a polypath. Obviously, G cannot contain an in-star or out-star with higher degree than two, and any such star is also a polypath. Hence, we only need to consider the third case in the definition. We note that any weakly connected subgraph G′ of G must also be a polypath, and that doing contractions on a polypath results in a polypath.\n2) Immediate since in-stars, out-stars and polypaths are all acyclic and contracting edges cannot introduce a cycle in any of these cases.\n3) Immediate from the definitions of minors and SP-graphs. 4) Immediate from 3.\nThis proposition says that it makes sense to talk about SP-closed classes of polypaths and SP-closed classes of acyclic graphs. It also says that SP-closure and minor-closure are comparable concepts; the SP-closure of a class is a subset of the minor-closure of the same class.\nWe can now prove the following result about SP-closed classes of polypaths, which we need for the main theorem.\nLemma 13. Let C be an SP-closed class of polypaths. If cc-size(C) is unbounded, then PlanExist(C) is NP-hard. This result holds even when restricted to operators with at most 2 preconditions and 1 postcondition.\nProof. Proof by cases depending on whether the directed path length of C is bounded or not. Case 1: Suppose that path-length(C) is unbounded. Let n > 1 be an arbitrary integer. Then there must be some graph G ∈ C such that G contains a subgraph H that is a directed path graph and V (H) = n. Obviously, H is an SP graph of G, since a directed path is also a polypath. It follows that H ∈ C since C is SP-closed. Furthermore, H ' dPn so NP-hardness of PlanExist(C) follows from Lemma 6, since n was choosen arbitrarily.\nCase 2: Instead suppose that path-length(C) ≤ k for some constant k ≥ 0. Let n > 1 be an arbitrary integer. Since all graphs in C are polypaths and cc-size(C) is unbounded, there must be some polypath G ∈ C such that V (G) ≥ n. It thus follows from the assumption and Proposition 1 that G must have at least m sinks and m + 1 sources, for some m such\nthat V (G) ≤ 2mk+1. There must, thus, be some subgraph G′ of G that is a polypath with exactly m sinks and m+ 1 sources (i.e. G′ is weakly connected) and there must, thus, also be a graph H that can be obtained by zero or more contractions of G′ such that H ' F+1m . It follows that H ∈ C since C is SP-closed. NP-hardness of PlanExist(C) thus follows from Lemma 7, since n was choosen arbitrarily and k is constant.\nTo see that the result holds even if the operators under consideration have at most 2 preconditions and 1 postcondition, simply note that this restriction holds for all reductions used in the underlying NP-hardness proofs in Section 4.\nChen and Giménez (2010, Thm. 3.19) proved a similar result: If C is a class of polypaths2 with unbounded components and unbounded number of sources, then PlanExist(C) is not polynomial-time solvable unless W[1] ⊆ nu-FPT.\nIn order to prove the main result of this section, we also need the Moore bound (Biggs, 1993, p. 180), which is stated as follows: for an arbitrary connected undirected graph G, the maximum number of vertices is\n|V (G)| ≤ 1 + d k−1∑ i=0 (d− 1)i, (1)\nwhere d = deg(G) and k = path-length(G).\nWe can now prove that under the additional restriction that graph classes are SPclosed, we can avoid NP-intermediate problems and prove NP-hardness for graph classes with unbounded components.\nTheorem 14. Let C be an SP-closed class of directed graphs. If cc-size(C) is unbounded, then PlanExist(C) is NP-hard. This result holds even when restricted to operators with at most 2 preconditions and 1 postcondition and all graphs in C are acyclic.\nProof. First suppose there is some constant k such that in-deg(C) ≤ k, out-deg(C) ≤ k and upath-length(C) ≤ k. Consider an arbitrary graph G ∈ C. Obviously, deg(U(G)) ≤ 2k and path-length(U(G)) ≤ k, so it follows from the Moore bound that no component in U(G) can have more than 1 + 2k ∑k−1 i=0 (2k − 1)i vertices. However, since cc-size(G) = cc-size(U(G)) and G was choosen arbitrarily, it follows that cc-size(C) is bounded. This contradicts the assumption so at least one of in-deg(C), out-deg(C) and upath-length(C) is unbounded. The remainder of the proof is by these three (possibly overlapping) cases.\nCase 1: Suppose that in-deg(C) is unbounded. Let n > 0 be an arbitrary integer. Then there must be some graph G ∈ C containing a vertex with indegree n or more, so there must also be a subgraph H of G such that H ' Sinn . Hence, H ∈ C since C is SP-closed. It thus follows from Lemma 4 that PlanExist(C) is NP-hard, since n was choosen arbitrarily.\nCase 2: Suppose that out-deg(C) is unbounded. This case is analogous to the previous one, but using Lemma 5 instead of Lemma 4.\nCase 3: Suppose that upath-length(C) is unbounded. Let n > 0 be an arbitrary integer. Then there must be some graph G ∈ C such that U(G) contains a path of length n, and there must, thus, also be a subgraph H of G such that H is a polypath of length n. Obviously, H\n2. Chen and Giménez use the term source-sink configuration for polypath.\nis an SP-graph of G (doing zero contractions) so H ∈ C since C is SP-closed. It thus follows from Lemma 13 that PlanExist(C) is NP-hard, since n was choosen arbitrarily.\nTo see that the result holds even if the operators under consideration have at most 2 preconditions and 1 postcondition, simply note that this restriction holds for all reductions used in the underlying NP-hardness proofs in Section 4. Similarly, the acyclicity restriction holds since the result is based only on in-stars, out-stars and polypaths, which are all acyclic graphs.\nThis theorem is somewhat more restricted than the one by Chen and Giménez since it requires the additional constraint that C is SP-closed. On the other hand, it demonstrates that SP-closure is a sufficient condition to avoid graph classes such that PlanExist is NPintermediate and, thus, sharpen the result to NP-hardness. It should be noted, though, that this is not an exact characterization of all graph classes that are NP-hard for PlanExist. There are other such graph classes, but SP-closure captures a large number of interesting graph classes. For instance, the class of all acyclic graphs is SP-closed (recall that this class is not minor-closed), although not every subclass of it is SP-closed. As an opposite example, any non-empty class that does not contain a single acyclic graph cannot be SP-closed."
    }, {
      "heading" : "6. Beyond SP-Closed Graph Classes",
      "text" : "This section is divided into three parts. We first discuss why the previous results, as well as most other similar NP-hardness results in the literature, are problematic, which motivates us to switch over to non-uniform complexity theory. The second part contains a number of preparatory results that are required for the main theorem in the third part."
    }, {
      "heading" : "6.1 Why NP-Hardness is Not Enough",
      "text" : "We refer to a planning problem as generic if it has instances of varying size, depending on one or more parameters. An archetypical example is the blocks world, where the natural parameter is the number of blocks. For a particular encoding and a specified number of blocks, the variables and operators will be the same whatever the inital state and goal is. That is, if we fix the encoding then we get a planning frame Φn = (Vn, An) for every number, n, of blocks. That is, Φn is the same for all instances with n blocks and is thus a function of n. All instances (Vn, init, goal, An) with n blocks will be instantiations of Φn with different init and goal components but with the same Vn and An components. An instance can thus be specified with three unique parameters, n, init and goal, where only the first parameter, n, affects the size of the instance. Furthermore, the causal graph for an instance depends only on the variables and the operators, which means that all instantiations of a frame Φn have the same causal graph, which we denote CG(Φn). The class of causal graphs for blocks world instances will be D = {CG(Φ1), CG(Φ2), CG(Φ3), . . .}, although Φ1,Φ2,Φ3, . . ., and thus also D, will differ depending on the encoding.\nIt is often possible to analyse the complexity of a particular generic planning problem. Examples of this are the complexity of blocks-world planning (Gupta & Nau, 1992) and the complexity of various problems from the International Planning Competitions (IPC) (Helmert, 2003, 2006b). In the context of this article, though, we are rather interested in the complexity of the class of causal graphs corresponding to a generic problem, than\nthe complexity of the specific problem itself. Suppose that a class D of causal graphs happens to be a subset of some class C of graphs such that we know that PlanExist(C) is tractable. Then we can infer that also PlanExist(D) is tractable, and thus also that all generic planning problems with causal graphs in D are tractable. However, in order to prove that PlanExist(D) is NP-hard (or hard for some other complexity class) we would have to prove that there is some class C of graphs such that PlanExist(C) is NP-hard and C is a subset of D. Finding such a class C may not be trivial, though.\nOne problem is that the encoding can have a large influence on how densely or sparsely the causal graphs occur with respect to size. Consider, for instance, blocks world encodings with multi-valued variables and with boolean variables respectively. A typical encoding with multi-valued variables will use one variable for the status of the hand and two variables for each block, one for the position of the block and one to flag whether the block is clear or not. That is, such encodings will use 2n + 1 variables for an n-block frame. An encoding with boolean variables, on the other hand, will typically represent the block position with a number of boolean variables, one for each other block that a block can be on. A boolean encoding will thus use n2 + 1 variables for an n-block frame. While D will contain a graph for every odd number of vertices in the first case, it will be increasingly sparse in the second case. The class D of causal graphs for a generic planning problem will, thus, typically not be SP-closed, or even closed under taking subsets. Furthermore, since D will typically not contain a member for every possible number of vertices, it cannot possibly contain any of the known NP-hard sets Sin, Sout, dP etc. as a subset. Hence, in order to prove that a class D of causal graphs is hard for NP (or some other complexity class), it will often be necessary to make a dedicated proof for D. This is often doable, however. A generic planning problem has a corresponding function f that takes a parameter value n, e.g. the number of blocks in blocks world, such that f(n) = Φn. If f is furthermore polynomialtime computable in the value of n, which will often be the case, then also the corresponding causal graph, CG(Φn), is polynomial-time computable. However, even if this can be done for many generic planning problems, it will be a specific proof for every specific encoding of every particular generic planning problem. The same holds for particular classes of causal graphs; every specific class will typically require its own dedicated proof.\nIn order to get around these problems and to be able to prove a more general result that does not depend on the specific planning problems or causal graphs, we switch over to nonuniform complexity. This makes it possible to prove more powerful results, while retaining natural connections with the ordinary complexity classes. The basic vehicle for proving nonuniform complexity results is the advice-taking Turing machine, which is defined as follows.\nDefinition 15. An advice-taking Turing machine M has an associated sequence of advice strings A0, A1, A2, . . ., a special advice tape and an advice function A, from the natural numbers to the advice sequence, s.t. A(n) = An. On input x the advice tape is immediately loaded with A(||x||). After that M continues like an ordinary Turing machine, except that it also has access to the advice written on the advice tape.\nIf there exists a polynomial p s.t. ||A(n)|| ≤ p(n), for all n > 0, then M is said to use polynomial advice. The complexity class P/poly is the set of all decision problems that can be solved on some advice-taking TM that runs in polynomial time using polynomial advice.\nNote that the advice depends only on the size of the input, not its content, and need not even be computable. Somewhat simplistically, an advice-taking Turing machine is a machine that has an infinite data-base with constant access time. However, for each input size there is only a polynomial amount of information while there might be an exponential number of instances sharing this information. The power of polynomial advice is thus still somewhat limited and useful relationships are known about how the non-uniform complexity classes relate to the standard ones are known. One such result is the following.\nTheorem 16. (Karp & Lipton, 1980, Thm. 6.1) If NP ⊆ P/poly, then the polynomial hierarchy collapses to the second level."
    }, {
      "heading" : "6.2 Preparatory Results",
      "text" : "Before carrying on to the main theorem of this section, we need a few auxiliary results. We first show that if a planning instance has a causal graph G that is a subgraph of some graph H, then the instance can be extended to an equivalent instance with H as causal graph.\nLemma 17. Let Π be a planning instance and let G be a directed graph such that CG(Π) is a subgraph of G. Then there is a planning instance ΠG such that\n• ΠG can be constructed from Π in polynomial time,\n• CG(ΠG) = G and\n• ΠG has a solution if and only if Π has a solution.\nFurthermore, ΠG has the same maximum number of pre- and postconditions for its operators as Π (or one more if this value is zero in Π).\nProof. Let Π = (V, init, goal, A) be a planning instance and let CG(Π) = (V,E). Let G = (VG, EG) be a directed graph such that CG(Π) is a subgraph of G. Let U = VG \\ V . Construct a planning instance ΠG = (VG, initG, goalG, AG) as follows:\n• DG(u) = {0, 1}, for all u ∈ U , and DG(v) = D(v) ∪ {?}, for all v ∈ V , (where ? is a new value not in D(v)).\n• initG(v) = init(v), for all v ∈ V , and initG(u) = 0, for all u ∈ U .\n• goalG(v) = goal(v), for all v ∈ V , and goalG(u) is undefined for all u ∈ U .\n• Let AG consist of the following operators:\n– Let AG contain all a ∈ A. – For each edge (x, v) ∈ EG \\ E such that x ∈ VG and v ∈ V , let AG also contain\nan operator star(x, v)= 〈x = 0 ; v = ?〉. – For each edge (x, u) ∈ EG such that x ∈ VG and u ∈ U , let AG also contain\nan operator set(x, u)= 〈x = init(x) ; u = 1〉.\nObviously ΠG can be constructed in polynomial time and CG(ΠG) = G, so it remains to prove that ΠG has a solution if and only if Π has a solution.\nSuppose P = a1, . . . , an is a plan for Π. Then P is also a plan for ΠG since goalG(u) is undefined for all u ∈ U and a1, . . . , an ∈ AG. To the contrary, suppose P = a1, . . . , an is a plan for ΠG. For each operator ai in P , there are three cases: (1) ai ∈ A, (2) ai is a set operator or (3) ai is a star operator. In case 2, operator ai serves no purpose since it only modifies some variable in U , which has an undefined goal value. In case 3, operator ai sets some variable v ∈ V to ? and has no effect on any other variables. If goalG(v) is undefined, then ai serves no purpose. Otherwise there must be some operator aj , j > i, such that aj can change v from ? to some value in D(v), i.e. ai serves no purpose in this case either. It follows that the operator sequence P ′ obtained from P by removing all operators that are not in A is also a plan for ΠG. Furthermore, since P\n′ contains only operators from A it is also a plan for Π. It follows that Π has a plan if and only if ΠG has a plan.\nThis construction increases the maximum domain size by one but has very little effect on the maximum number of pre- and postconditions. This is suitable for our purpose, since we do not consider the influence of domain sizes in this article. Other constructions are possible if we want to balance the various factors differently.\nIn the proof of the forthcoming theorem we will also do the opposite of taking graph minors, that is, starting from a minor G of some target graph H we will extend G to H. In order to do so, we need an operation similar to the opposite of edge contraction. This is satisfied by a graph operation known as edge subdivision.\nDefinition 18. Let G = (V,E) be a directed graph and let (u, v) ∈ E be an edge such that u 6= v. Then the subdivision of (u, v) in G is a graph G′ = (V ∪ {w}, E′) where w is a new vertex and E′ = (E \\ {(u, v)}) ∪ {(u,w), (w, v)}.\nAlthough one might consider other definitions, e.g. in the case where both (u, v) and (v, u) are in E, this one is sufficient for our purpose and it follows the usual extension to directed graphs (cf., Kühn, Osthus, & Young, 2008). Usually an operation called smoothing is considered as the inverse of edge subdivision. However, smoothing can be viewed as a restricted case of edge contraction, so it is reasonable to think of edge subdivision as a sort of inverse of edge contraction. An example of edge subdivision is illustrated in Figure 8. We further note that just like an edge contraction of a polypath is a polypath, also an edge subdivision of a polypath is a polypath.\nWe also need an operation on planning instances corresponding to edge subdivision in their causal graphs. For that purpose, we need a concept of variable substitution for operators. We denote the substitution of a variable w for a variable v in a partial state s with a[v/w], defined as:\ns[v/w](x) =  s(v), if x = w, s(x), if x ∈ vars(s) \\ {v, w}, undefined, otherwise.\nIf a is an operator, then the operator a′ = a[v/w] is defined such that pre(a′) = pre(a)[v/w] and post(a′) = post(a)[v/w].\nWe now have the necessary concepts for modifying an arbitrary planning instance such that the result corresponds to subdividing an edge in the causal graph of the instance. However, we will only need to do this for instances where the causal graph is a polypath. Before proving that this can be done, we first need the following lemma, which states a certain reordering property for plans when the causal graph is a polypath. If we choose an arbitrary vertex v in a polypath G and remove v from G, then G falls apart into two weakly connected components C1 and C2. In other words, the vertices of G can be partitioned into three sets C0, C1 and C2 such that C0 = {v} and there is no edge directly between a vertex in C1 and a vertex in C2. It then follows from the definition of causal graphs that no operator that changes some variable in C1 can have a precondition on a variable in C2 and vice versa. The following lemma utilises this fact to prove that any sequence of operators that does not change variable v can be reordered such that all operators that change variables in C1 come before all operators that change variables in C2.\nLemma 19. Let Π = (V, init, goal, A) be a planning instance such that G = CG(Π) is a polypath. Let v be an arbitrary variable in V , let C0 = {v} and let C1, C2 ⊆ V be the two (possibly empty) weakly connected components of G that result if vertex v is removed from G. Define Ai = {a ∈ A | vars(post(a)) ⊆ Ci} for all i (0 ≤ i ≤ 2). Let P be a plan for Π. Let P1, P2 and Q be operator sequences such that P = P1, Q, P2 and Q contains no operator from A0. Let Q1 be the subsequence of Q containing only operators from A1 and let Q2 be the subsequence of Q containing only operators from A2. Then P1, Q1, Q2, P2 is a plan for Π.\nProof. Assume C0, C1 and C2 as defined in the lemma and recall that C0 = {v}. First note that G is acyclic since it is a polypath, so all operators in A are unary. It follows that {A0, A1, A2} is a partition of A and, thus, that A0 ∪ A1 ∪ A2 = A. Let s0 = init[P1]. Obviously, (vars(pre(a))∩C2 = (vars(post(a))∩C2 = ∅ for all a inQ1 and (vars(pre(a))∩C1 = (vars(post(a))∩C1 = ∅ for all a in Q2, i.e. for any state s it holds that s[a] C2 = s C2 for all a in Q1 and that s[a] C1 = s C1 for all a in Q2. Furthermore, for any state s it holds\nthat s[a](v) = s(v) for all a in Q, since a 6∈ A0. It follows that s0[Q] C1 = s0[Q1] C1 and s0[Q] C2 = s0[Q2] C2. Hence,\ns0[Q1, Q2] C0 = s0[Q] C0, s0[Q1, Q2] C1 = s0[Q1] C1 = s0[Q] C1 and s0[Q1, Q2] C2 = s0[Q2] C2 = s0[Q] C2.\nThat is, s0[Q1, Q2] = s0[Q] and it follows that also P1, Q1, Q2, P2 is a plan for Π.\nWe now prove that if Π is a planning instance such that CG(Π) is a polypath, then we can subdivide any edge in CG(Π) and create a planning instance Π′ such that CG(Π′) is this subdivision of CG(Π) and Π′ is solvable if and only if Π is solvable.\nLemma 20. Let Π be a planning instance such that CG(Π) is a polypath and let e be an edge in CG(Π). Then there is a planning instance Π′ such that\n• Π′ can be constructed from Π in polynomial time,\n• CG(Π′) is an edge subdivision of e in CG(Π) and\n• Π′ has a solution if and only if Π has a solution.\nProof. Let Π = (V, init, goal, A) be a planning instance such that CG(Π) is a polypath and let e = (u, v) be an edge in CG(Π). Construct a new instance Π′ = (V ′, init′, goal′, A′) as follows:\n• V ′ = V ∪ {w}, where D(w) = D(u) and w 6∈ V .\n• init′(v) = init(v), for all v ∈ V , and init′(w) = init(u).\n• goal′ = goal.\n• Let A′ consist of the following groups of operators:\n1. Let A′ contain all operators a ∈ A such that u 6∈ vars(pre(a)) or v 6∈ vars(post(a)). 2. Let A′ contain the operator a[u/w] for every operator a ∈ A such that u ∈ vars(pre(a)) and v ∈ vars(post(a)). 3. Let A′ contain an operator copy(u,w, x) = 〈u = x ; w = x〉 for every value x ∈ D(v).\nThe operators in group 1 are the original operators from A corresponding to all edges in CG(Π) except (u, v). The operators in group 2 are the operators from A corresponding to edge (u, v) but modified to instead correspond to the new edge (w, v). The operators in group 3 correspond to the new edge (u,w) and are defined such that variable w can ’mimic’ variable u. Clearly, this is a polynomial-time construction and CG(Π′) is an edge subdivision of CG(Π). It remains to prove that Π′ has a plan if and only if Π has a plan.\nIf: Suppose P = a1, . . . , an is a plan for Π. Construct a new operator sequence P ′ over A′ from P as follows: First, for each ai in P such that u ∈ vars(pre(ai)) and v ∈ vars(post(ai)), replace ai with ai[u/w]. Then, for each ai in P such that u ∈ vars(post(ai)),\nlet x = post(ai)(u) and add operator copy(u,w, x) between ai and ai+1. The resulting sequence P ′ is a plan for Π′.\nOnly if: Suppose P = a1, . . . , an is a plan for Π ′. Define the corresponding state sequence s0, . . . , sn such that s0 = init ′ and si = s0[a1, . . . , ai] for all i (1 ≤ i ≤ n). Without losing generality, assume that P is a shortest plan for Π′, which implies that ai is applicable in si−1 for every i (1 ≤ i ≤ n). Define three variable sets C0, C1 and C2 as in Lemma 19 such that C0 = {w}, v ∈ C1 and u ∈ C2. Also define the corrsponding partition {A0, A1, A2} of A′, i.e. Ai = {a ∈ A′ | vars(post(a)) ⊆ Ci} for all i (0 ≤ i ≤ 2). Then A0 contains all copy operators and nothing else. Before proving the main result of this direction, we first prove the following auxiliary result:\nAccording to Lemma 19 we can assume that every longest subsequence ak, . . . , a` that does not contain any operator from A0 is on the form ak, . . . , am, am+1, . . . , a` such that ak, . . . , am ∈ A1 and am+1, . . . , a` ∈ A2. Since it is a longest such sequence, it must hold that either (1) k = 1 or (2) ak−1 ∈ A0. In case (1) we have sk−1 = s0 = init′, so sk−1(u) = sk−1(w) since init\n′(u) = init′(w). In case (2) operator ak−1 = copy(u,w, x) for some x such that sk−1(w) = sk−2(u) = x. Hence, sk−1(u) = sk−1(w) = x since ak−1 does not change u. That is, in either case we have sk−1(u) = sk−1(w). Furthermore, for all i (k ≤ i ≤ m) it holds that si (C0 ∪ C2) = sk−1 (C0 ∪ C2) since ai ∈ A1. It follows that si(u) = si(w) for all i (k ≤ i ≤ m). Now, for every i (k ≤ i ≤ `), if w ∈ vars(pre(ai)) then ai must be on the form a[u/w], for some a ∈ A, so v ∈ vars(pre(ai)) by definition. Hence, ai ∈ A1 so i ≤ m and it follows that si−1(u) = si−1(w). Since this proof holds for all longest subsequences not containing any operator from A0 we can conclude the following, which will be used below:\n(*) For any operator ai in P such that ai = a[u/w] for some a ∈ A, it holds that si−1(u) = si−1(w).\nWe now prove the main result of this direction, that also Π has a plan since Π′ has a plan. We do so by constructing a plan P ′′ for Π from P in two steps. First we construct an intermediate operator sequence P ′ and then construct the plan P ′′ from P ′. The sequence P ′ is technically not a plan for either Π or Π′, but this intermediate step makes the proof clearer. Temporarily introduce a virtual dummy operator dum that has no precondition and no postcondition, i.e. it is applicable in any state and has no effect. Then construct the new operator sequence P ′ = b1, . . . , bn over A ∪ {dum} as follows: • If ai ∈ A, then bi = ai.\n• If ai is a copy operator, then bi = dum.\n• Otherwise, ai = a[u/w] for some operator a ∈ A, so let bi be that operator a. Define the corresponding state sequence t0, . . . , tn such that t0 = init\n′ and ti = t0[b1, . . . , bi] for all i (1 ≤ i ≤ n). We claim that ti V = si V for all i (0 ≤ i ≤ n). Proof by induction over i:\nBasis: t0 = s0 by definition. Induction: Suppose ti−1 V = si−1 V for some i (1 ≤ i ≤ n). There are three cases: (1) ai = bi and ai ∈ A. Then w is not in the pre- or postcondition of either ai or bi so bi is applicable in ti−1 since ai is applicable in si−1 and ti−1 V = si−1 V by assumption. Furthermore, ti V = ti−1[bi] V = si−1[ai] V = si V .\n(2) ai is a copy operator and bi = dum. It is immediate from the definition of bi that it is applicable in ti−1 and that ti = ti−1. Furthermore, vars(post(ai)) ∩ V = ∅ so si V = si−1 V . Since ti−1 V = si−1 V by assumption it thus follows that ti V = si V .\n(3) ai is bi[u/w] and bi ∈ A. It follows from (*) that si−1(w) = si−1(u), so si−1(w) = ti−1(u) since u ∈ V and ti−1 V = si−1 V by assumption. Since ai is applicable in si−1, pre(ai)(w) = pre(bi)(u) and pre(ai)(x) = pre(bi)(x) for all variables in V \\{u}, it follows that bi is applicable in ti−1. By definition, vars(post(bi)) = vars(post(ai)) = {v}, since both ai and bi must be unary, and it thus also follows from the definition that post(bi) = post(ai). Hence, it also follows that ti V = si V , since ti−1 V = si−1 V by assumption.\nWe have thus shown that ti V = si V for all i (0 ≤ i ≤ n). Furthermore, clearly ti = ti−1 for all i such that bi = dum. It follows that we can create a plan P\n′′ for Π by removing all dummy operators from P ′.\nWe conclude that Π has a solution if and only if Π′ has a solution.\nWe will finally need the following observations about 3SAT instances. Let F be a 3SAT formula with n variables and m clauses. If it contains no repeated clauses, then\nn 3 ≤ m ≤ 8n3 and, thus, (m 8 )1/3 ≤ n ≤ 3m.\nFurthermore, F can be represented as a list of 3m literals which requires 3m(1 + log n) ≤ 3m(1+log 3m) bits, plus some overhead. Hence, F can be represented by at most cm2 bits, for some constant c, and we will later use the upper bound 40m3, which is safe.\nWe also note that the reduction used in the proof of Lemma 6 transforms a 3SAT instance with n variables and m clauses to a planning instance with N = (2m + 4)n variables. However, n ≤ 3m so N ≤ (2m + 4) · 3m = 6m2 + 12m, which can be safely overestimated with N ≤ 18m2."
    }, {
      "heading" : "6.3 The Main Theorem",
      "text" : "We are now prepared to state and prove the main theorem of this section. It follows from the proof of Theorem 14 that if in-deg(C), out-deg(C) and upath-length(C) are all bounded for a class C of graphs, then cc-size(C) is bounded. In that case it is immediate from Theorem 3 that planning is tractable for C. This begs the question what happens if these parameters are not bounded by a constant, yet bounded by some slow-growing function? We will consider the case when they are allowed to grow slowly, as long as they are polynomially related to the instance size. Since we have also noted that practical planning problems will typically not have a causal graph of every size, we will only require that for every graph G in C there must also be some larger graph G′ in C of size at most p(|G|), for some polynomial p. We also define the parameter τ(G) = max{upath-length(G), in-deg(G), out-deg(G)}, and require that τ(G) and ||G|| are polynomially related. It turns out that planning is still hard under these restrictions, as the following theorem says.\nTheorem 21. Let p and q be increasing polynomials on the natural numbers. Let C be a class of directed graphs containing a subset of weakly connected graphs G1, G2, G3, . . . such that:\n1. |V (G1)| ≤ p(q(1)), |V (Gi−1)| < |V (Gi)| ≤ p(|V (Gi−1)|), for all i > 1, and\n2. |V (Gi)| ≤ q(τ(Gi)), for all i ≥ 1.\nIf PlanExist(C) is polynomial-time solvable, then the polynomial hierarchy collapses. This result holds even when restricted to operators with at most 2 preconditions and 1 postcondition and all graphs in C are acyclic.\nProof. Let G1, G2, G3, . . . be a sequence of weakly connected graphs in C as assumed in the theorem. Let H1, H2, H3, . . . be a sequence of graphs defined as follows: for each i > 0, Hi = Gj for the smallest j such that q(i) ≤ |V (Gj)|.\nWe first prove that i underestimates τ(Hi). Combining the requirement that q(i) ≤ |V (Gj)| with condition 2 of the theorem, that |V (Gj)| ≤ q(τ(Gj)), we get q(i) ≤ |V (Gj)| ≤ q(τ(Gj)). Since Hi = Gj we get q(i) ≤ |V (Hi)| ≤ q(τ(Hi)), that is, that i ≤ τ(Hi). It follows that also i ≤ |V (Hi)| holds.\nWe then prove that |V (Hi)| is polynomially bounded by p(q(i)). Since j is choosen as the smallest value satisfying that q(i) ≤ |V (Gj)|, it must be that either j = 1 or |V (Gj−1)| < q(i). If j = 1, then Hi = Gj = G1 and |V (G1)| ≤ p(q(1)) by condition 1 in the theorem. Hence, |V (Hi)| = |V (G1)| ≤ p(q(1)) ≤ p(q(i)), since p and q are increasing. Otherwise, when j > 1, condition 1 of the lemma says that |V (Gj)| ≤ p(|V (Gj−1)|). Combining this with the inequality |V (Gj−1)| < q(i) yields that |V (Gj)| ≤ p(|V (Gj−1)|) < p(q(i)), that is, |V (Hi)| ≤ p(q(i)) since Hi = Gj . Combining this with the previous result that i ≤ |V (Hi)| and the construction of Hi yields that H1, H2, H3 is a sequence of graphs with non-decreasing and unbounded size.\nNow, define a sequence A0, A1, A2, . . . of tuples such that for all i ≥ 0, either of the following holds:\n1. in-deg(Hi) ≥ i and Ai = (in-deg, Hi, Xi) such thatXi is a subgraph ofHi andXi ' Sini .\n2. out-deg(Hi) ≥ i and Ai = (out-deg, Hi, Xi) such that Xi is a subgraph of Hi and Xi ' Souti .\n3. upath-length(Hi) ≥ i and Ai = (upath-length, Hi, Xi) such that Xi is a subgraph of Hi and Xi is a polypath of length i.\nFor every i > 0, at least one of these three cases must hold since i ≤ τ(Hi). Define an advice-taking Turing machine M that uses the sequence A1, A2, A3, . . . as advice and takes 3SAT formulae as input. Assume that the representation of each formula F is padded to size 40m3 bits, where m is the number of clauses. Although somewhat redundant, this is still a reasonable encoding in the sense of Garey and Johnson (1979). Let M work as follows. Let F be an input formula with n variables and m clauses and let t = ||F || = 40m3. Then the advice is At = (x, Ht, Xt). First M constructs a planning instance ΠF . There are three cases depending on x:\nx = in-deg: By construction, Xt is a subgraph of Ht such that Ht ' Sint . Since t = 40m3 and n ≤ 3m, it follows that n ≤ t, so Xt contains a subgraph H ′ such that H ′ ' Sinn . Construct ΠF in the same way as in the proof of Lemma 4, using the vertices of H ′\nas variables. Then, CG(ΠF ) = H ′.\nx = out-deg: Analogous to previous case, but constructing ΠF according to the proof of Lemma 5 instead.\nx = upath-length: By construction, Xt is a subgraph of Ht which is a polypath of length t = 40m3. Suppose that Xt contains less than m sinks and m + 1 sources and that path-length(Xt) < 18m 2. It then follows from Proposition 1 that\n|V (Xt)| < 2m · 18m2 + 1 = 36m3 + 1 < 40m3 = t.\nHowever, this contradicts the construction so Xt must either contain a directed path of length 18m2 or have at least m sinks and m+ 1 sources.\n1. If Xt contains a subgraph H ′ which is a directed path of length 18m2, then\nconstruct a planning instance ΠF according to the proof of Lemma 6, using the vertices from H ′ as variables. Then, CG(ΠF ) ' H ′. 2. If Xt contains a subgraph H ′ which is a polypath with m sinks and m+1 sources,\nthen construct a planning instance Π−F according to the proof of Lemma 7, using the variables of H ′ as variables. Then, CG(Π−F ) ' F+1m . This graph is a fence, i.e. a polypath where all directed paths are of length 1. Each such path can be ’stretched’ to a directed path of arbitrary length by repeatedly applying Lemma 20. The graph H ′ is a polypath that can be used as a template for which paths in CG(Π−F ) to stretch and how much in order to get a graph that is isomorphic to H ′. Instance Π−F can thus be modified into a new instance ΠF such that CG(ΠF ) ' H ′.\nAll these constructions can be done in polynomial time, and for all cases, ΠF has a solution if and only if F is satisfiable. Furthermore, CG(ΠF ) is isomorphic to a subgraph of Ht in all four cases. According to Lemma 17 it is thus possible to extend ΠF to a new planning instance Π+F such that CG(Π + F ) ' Ht and Π + F has a solution if and only if Π has a solution. This extension can be done in polynomial time according to the same lemma.\nSince PlanExist(C) can be solved in polynomial time by assumption in the theorem, it thus follows that M can solve 3SAT in polynomial time. However, this implies that NP ⊆ P/poly, which is impossible unless the polynomial hierarchy collapses (Theorem 16).\nTo see that the result holds even if the operators under consideration have at most 2 preconditions and 1 postcondition, simply note that this restriction holds for all reductions used in the underlying NP-hardness proofs in Section 4. Similarly, the acyclicity restriction holds since the result is based only on in-stars, out-stars and polypaths, which are all acyclic graphs.\nRecall the generic blocks world encoding that we discussed in the beginning of this section. The class D of causal graphs for these blocks-world instances satisfies the requirements in Theorem 21, which means that PlanExist(D) is not likely to be tractable. However, finding non-optimal plans for blocks world is tractable; a plan of length at most twice the length of the optimal plan can be found in polynomial time (Gupta & Nau, 1992). That is, there are most likely more difficult problems than blocks world that happen to have exactly the same causal graphs, which illustrates that the complexity of a generic planning problem cannot be deduced from its corresponding class of causal graphs alone."
    }, {
      "heading" : "7. NP-Hard and NP-Intermediate Classes",
      "text" : "The theorem by Chen and Giménez (2010) states a crisp complexity-theoretic borderline: if the component sizes are bounded by a constant, then planning is polynomial-time solvable and, otherwise, planning is not polynomial-time solvable. We have exploited an extra constraint, SP-closure, to be able to prove NP-hardness, which leaves a greyzone between the polynomial cases and the NP-hard ones. If we no longer require the classes to be SPclosed, then they are no longer obviously NP-hard even if the components are unbounded. The natural question then arises, can we say something about this middle ground? For instance, can we say something about what the NP-intermediate cases may look like and where the borderline between NP-hard and NP-intermediate is? Although it does not seem likely that we could find any results that characterize this borderline exactly, we can at least give some partial answers to these questions. We will do this by proving two theorems related to the growth rate of the components. The first of these shows that planning is still NP-hard if the components grow as O(|V (G)|1/k) for integers k, while the second one shows that planning is likely to be NP-intermediate if the components grow polylogarithmically.\nTheorem 22. For every constant integer k > 1, there is a class Gk of graphs such that cc-size(G) ≤ |V (G)|1/k for all G ∈ Gk and PlanExist(Gk) is NP-hard.\nProof. Let k > 1 be an arbitrary integer. Construct the graph class Gk = {G1, G2, G3, . . .} as follows. For each m > 0, let Gm have m\nk−1 components, each of them isomorphic to dPm, i.e. |V (Gm)| = mk so all components are of size m = |V (Gm)|1/k. We prove NP-hardness of PlanExist(Gk) by reduction from PlanExist(dP). Let Π be an arbitrary planning instance such that CG(Π) ∈ dP. Then CG(Π) = dPm for some m > 0. Construct a new instance Π′ which consists of mk−1 renamed copies of Π. This is clearly a polynomial time construction since k is constant and m < ||Π||. Furthermore, CG(Π′) is isomorphic to Gm and Π′ has a solution if and only if Π has a solution. Hence, this is a polynomial reduction so it follows from Lemma 6 that PlanExist(Gk) is NP-hard.\nObviously, the size of the graphs is exponential in k.\nOur second result must be conditioned by the assumption that the exponential time hypothesis (Impagliazzo & Paturi, 2001; Impagliazzo, Paturi, & Zane, 2001) holds. This hypothesis is a conjecture stated as follows.\nDefinition 23. For all constant integers k > 2, let sk be the infimum of all real numbers δ such that k-SAT can be solved in O(2δn) time, where n is the number of variables of an instance. The exponential time hypothesis (ETH) is the conjecture that sk > 0 for all k > 2.\nInformally, ETH says that satisfiability cannot be solved in subexponential time. ETH is not just an arbitrarily choosen concept, but a quite strong assumption that allows for defining a theory similar to the one of NP-completeness. There is a concept called SERF (subexponential reduction family) reduction which preserves subexponential time solvability. There is also a concept called SERF-completeness which is similar to NP-completeness, but based on SERF reductions. That is, there is a subclass of the NP-complete problems that are also SERF-complete, meaning that these can all be SERF reduced to each other. Hence, if one of these can be solved in subexponential time, then all of them can.\nTheorem 24. For all constant integers k > 0 and all classes C of directed graphs, if cc-size(G) ≤ logk |V (G)| for all G ∈ C, then PlanExist(C) is not NP-hard unless ETH is false.\nProof. Let k > 0 be an arbitrary integer. Let Π be an arbitrary planning instance with n variables of maximum domain size d such that cc-size(CG(Π)) ≤ c. The components correspond to independent subinstances, which can thus be solved separately. Each component has a state space of size dc or less, so a plan for the corresponding subinstance can be found in O(d2c) time, using Dijkstra’s algorithm. Since there are at most n components, the whole instance can be solved in O(nd2c) time. However, it follows from the standard assumptions of reasonable encodings that both n ≤ ||Π|| and d ≤ ||Π||, so a looser bound is that Π can be solved in O(x · x2c) = O(x1+2c) time, where x = ||Π||.\nSuppose PlanExist(C) is NP-hard. Then there is a polynomial reduction from 3SAT to PlanExist(C). Furthermore, the size of a 3SAT instance is polynomially bounded in the number of variables. Hence, there must be some polynomial p such that for a 3SAT instance with n variables, the corresponding planning instance Π has size ||Π|| ≤ p(n).\nSince the number of variables in Π is upper bounded by ||Π||, it follows from the assumption that the component size is upper bounded by logk ||Π|| ≤ logk p(n). Hence, Π can be solved in O(p(n)1+2 log k p(n)) time, according to the earlier observation, and\np(n)1+2 log k p(n) = (2log p(n))1+2 log k p(n) ≤ (2(1+2 log k p(n)) logk p(n)) ≤ 23 log 2k p(n).\nFurthermore, logk p(n) ∈ O(logk n), since p is a polynomial, so 23 log2k p(n) ∈ 2O(log2k n) and it follows that Π can be solved in 2O(log 2k n) time. However, then Π can be solved in 2δn time for arbitrarily small δ, which contradicts ETH. It follows that PlanExist(C) cannot be NP-hard unless ETH is false.\nSince the components are unbounded, this problem is not likely to be solvable in polynomial time either. It is thus an NP-intermediate problem under the double assumption that W[1] 6⊆ nu-FPT and that ETH holds.\nTheorems 22 and 24 together thus tell us something about where the borderline between NP-intermediate and NP-hard graph classes is. However, it is not a very crisp distinction; asymptotically, there is quite a gap between the polylogarithmic functions and the root functions (i.e. functions on the form x1/k). One may, for instance, note that the function f(n) = 2(logn) 1− 1 (log logn)c lies within this gap whenever 0 < c < 1."
    }, {
      "heading" : "8. Discussion",
      "text" : "SP-closed graph classes have appealing properties and fit in well as a concept stronger than subgraph-closed but weaker than minor-closed. They also give a partial characterization of where the borderline to NP-hardness lies. However, as noted earlier, it is possible to define other types of graph classes which also imply that planning is NP-hard. One example is the family G1,G2,G3, . . . of classes in the proof of Theorem 22. Another more specialized and, perhaps, contrived class is the following, intended to give a contrast to the SP-closure concept and the Gk classes.\nA tournament is a directed graph formed by giving directions to each edge in a complete graph. Let T denote the set of tournaments and note that T is not SP-closed. However, tournaments are Hamiltonian graphs (Rédei, 1934) so if T is a tournament on n vertices, then path-length(T ) = n − 1. Furthermore, the path of length n − 1 can be computed in polynomial time (Bar-Noy & Naor, 1990).\nAssume we are given a 3SAT formula F with n variables and m clauses. Let ` = (2m + 4)n, i.e. ` is polynomially bounded in F . According to Lemma 6 we can thus construct a planning instance ΠF in polynomial time such that\n1. ΠF contains ` variables,\n2. CG(ΠF ) ' dP`, and\n3. ΠF has a solution if and only if F is satisfiable.\nChoose an arbitrary tournament T with ` vertices in T. Find the path of length `−1 in T and identify it with CG(ΠF ). Then add dummy operators corresponding to the remaining edges of T . We have thus shown that there is a polynomial-time transformation from 3SAT to PlanExist(T), and that PlanExist(T) is NP-hard. One may also note that variations of this technique can be used for proving that PlanExist(T′) is NP-hard for many different T′ ⊆ T.\nWhile we have not considered domain sizes or tractable restrictions in this article, we note that the Theorem 24 may give some ideas for where to look for tractable cases. Consider the case where all variable domains are bounded in size by some constant k and where cc-size(G) ≤ log V (G). Using the first part of the proof, we see that planning can be solved in O(n · k2 logn) time. However, k2 logn = (2log k)2 logn = (2logn)2 log k = n2 log k, which is polynomial since k is a constant. That is, planning is tractable for this restricted case. Even though this observation is straightforward, it is interesting as a contrast to Theorem 24. It also suggests that there are even larger tractable subgraphs if we also consider additional restrictions on the planning instances.\nWhile we have explicitly commented on the sufficient number of pre- and postconditions for the various results, there are also alternative such characterizations that might be relevant. It would bear to far to list all such possibilities, so let it suffice with one example. The concept of prevail conditions, i.e. preconditions on variables that are not changed by the operator, originate from the SAS+ formalism (Bäckström & Nebel, 1995) but has more recently been considered also in the context of causal graphs. Giménez and Jonsson (2012) refer to an operator as k-dependent if it has a precondition on at most k variables that it does not also change. We may note that the proofs of Lemmata 17 and 20 only introduce operators that are 1-dependent, at most. Since the proof of Theorem 21 does not impose any further such restrictions on the original planning instance, it follows that this theorem holds also when all operators are 1-dependent, at most.\nAs a final question, one might wonder if it is of any practical use at all to know that planning is tractable, or NP-intermediate, for severely limited component sizes? After all, most planning instances are likely to have a causal graph that is weakly connected, that is, the whole graph is one single component. To answer that question, the first important observation to make is that the complexity of planning for instances is directly related to the complexity of planning for the components separately. This is because there can be at\nmost linearly (in the number of variables) many components. If planning can be solved in polynomial time for all components of an instance, then it can be solved in polynomial time for the whole instance. Conversely, if planning cannot be solved in polynomial time for the whole instance, then there is at least one component which is not polynomial-time solvable. That is, the complexity results for instances and for components are directly related to each other. In other words, the results are relevant for all methods that artificially split the causal graph into components, in one way or another. Examples are the causal-graph heuristic by Helmert (2006a), factored planning (Brafman & Domshlak, 2006) and structural pattern data bases (Katz & Domshlak, 2010)."
    }, {
      "heading" : "Acknowledgments",
      "text" : "The anonymous reviewers provided valuable comments and suggestions for improving this article."
    } ],
    "references" : [ {
      "title" : "Complexity results for SAS+ planning",
      "author" : [ "C. Bäckström", "B. Nebel" ],
      "venue" : "Computational Intelligence,",
      "citeRegEx" : "Bäckström and Nebel,? \\Q1995\\E",
      "shortCiteRegEx" : "Bäckström and Nebel",
      "year" : 1995
    }, {
      "title" : "Sorting, minimal feedback sets, and Hamilton paths in tournaments",
      "author" : [ "A. Bar-Noy", "J. Naor" ],
      "venue" : "SIAM Journal on Discrete Mathematics,",
      "citeRegEx" : "Bar.Noy and Naor,? \\Q1990\\E",
      "shortCiteRegEx" : "Bar.Noy and Naor",
      "year" : 1990
    }, {
      "title" : "Algebraic Graph Theory",
      "author" : [ "N. Biggs" ],
      "venue" : null,
      "citeRegEx" : "Biggs,? \\Q1993\\E",
      "shortCiteRegEx" : "Biggs",
      "year" : 1993
    }, {
      "title" : "Non-dichotomies in constraint satisfaction complexity",
      "author" : [ "M. Bodirsky", "M. Grohe" ],
      "venue" : "In Proceedings of the 35th International Colloquium on Automata, Languages and Programming (ICALP",
      "citeRegEx" : "Bodirsky and Grohe,? \\Q2008\\E",
      "shortCiteRegEx" : "Bodirsky and Grohe",
      "year" : 2008
    }, {
      "title" : "Structure and complexity in planning with unary operators",
      "author" : [ "R.I. Brafman", "C. Domshlak" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Brafman and Domshlak,? \\Q2003\\E",
      "shortCiteRegEx" : "Brafman and Domshlak",
      "year" : 2003
    }, {
      "title" : "Factored planning: How, when, and when not",
      "author" : [ "R.I. Brafman", "C. Domshlak" ],
      "venue" : "In Proceedings of the 21st National Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Brafman and Domshlak,? \\Q2006\\E",
      "shortCiteRegEx" : "Brafman and Domshlak",
      "year" : 2006
    }, {
      "title" : "Causal graphs and structurally restricted planning",
      "author" : [ "H. Chen", "O. Giménez" ],
      "venue" : "Journal of Computer and Systems Science,",
      "citeRegEx" : "Chen and Giménez,? \\Q2010\\E",
      "shortCiteRegEx" : "Chen and Giménez",
      "year" : 2010
    }, {
      "title" : "Multi-agent off-line coordination: Structure and complexity",
      "author" : [ "C. Domshlak", "Y. Dinitz" ],
      "venue" : "In Proceedings of the 6th European Conference on Planning (ECP’01),",
      "citeRegEx" : "Domshlak and Dinitz,? \\Q2001\\E",
      "shortCiteRegEx" : "Domshlak and Dinitz",
      "year" : 2001
    }, {
      "title" : "Multi-agent off-line coordination: Structure and complexity",
      "author" : [ "C. Domshlak", "Y. Dinitz" ],
      "venue" : "Tech. rep., Department of Computer Science, Ben-Gurion University",
      "citeRegEx" : "Domshlak and Dinitz,? \\Q2001\\E",
      "shortCiteRegEx" : "Domshlak and Dinitz",
      "year" : 2001
    }, {
      "title" : "Parameterized Complexity Theory, Vol. XIV of Texts in Theoretical Computer Science. An EATCS Series",
      "author" : [ "J. Flum", "M. Grohe" ],
      "venue" : null,
      "citeRegEx" : "Flum and Grohe,? \\Q2006\\E",
      "shortCiteRegEx" : "Flum and Grohe",
      "year" : 2006
    }, {
      "title" : "Computers and Intractability: A Guide to the Theory of NP-Completeness",
      "author" : [ "M.R. Garey", "D.S. Johnson" ],
      "venue" : null,
      "citeRegEx" : "Garey and Johnson,? \\Q1979\\E",
      "shortCiteRegEx" : "Garey and Johnson",
      "year" : 1979
    }, {
      "title" : "The complexity of planning problems with simple causal graphs",
      "author" : [ "O. Giménez", "A. Jonsson" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Giménez and Jonsson,? \\Q2008\\E",
      "shortCiteRegEx" : "Giménez and Jonsson",
      "year" : 2008
    }, {
      "title" : "Planning over chain causal graphs for variables with domains of size 5 is NP-hard",
      "author" : [ "O. Giménez", "A. Jonsson" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Giménez and Jonsson,? \\Q2009\\E",
      "shortCiteRegEx" : "Giménez and Jonsson",
      "year" : 2009
    }, {
      "title" : "The influence of k-dependence on the complexity of planning",
      "author" : [ "O. Giménez", "A. Jonsson" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Giménez and Jonsson,? \\Q2012\\E",
      "shortCiteRegEx" : "Giménez and Jonsson",
      "year" : 2012
    }, {
      "title" : "On the complexity of blocks-world planning",
      "author" : [ "N. Gupta", "D.S. Nau" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Gupta and Nau,? \\Q1992\\E",
      "shortCiteRegEx" : "Gupta and Nau",
      "year" : 1992
    }, {
      "title" : "Complexity results for standard benchmark domains in planning",
      "author" : [ "M. Helmert" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Helmert,? \\Q2003\\E",
      "shortCiteRegEx" : "Helmert",
      "year" : 2003
    }, {
      "title" : "A planning heuristic based on causal graph analysis",
      "author" : [ "M. Helmert" ],
      "venue" : "In Proceedings of the 14th International Conference on Automated Planning and Scheduling (ICAPS",
      "citeRegEx" : "Helmert,? \\Q2004\\E",
      "shortCiteRegEx" : "Helmert",
      "year" : 2004
    }, {
      "title" : "The Fast Downward planning system",
      "author" : [ "M. Helmert" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Helmert,? \\Q2006\\E",
      "shortCiteRegEx" : "Helmert",
      "year" : 2006
    }, {
      "title" : "New complexity results for classical planning benchmarks",
      "author" : [ "M. Helmert" ],
      "venue" : "In Proceedings of the 16th International Conference on Automated Planning and Scheduling (ICAPS",
      "citeRegEx" : "Helmert,? \\Q2006\\E",
      "shortCiteRegEx" : "Helmert",
      "year" : 2006
    }, {
      "title" : "On the complexity of k-SAT",
      "author" : [ "R. Impagliazzo", "R. Paturi" ],
      "venue" : "Journal of Computer and System Science,",
      "citeRegEx" : "Impagliazzo and Paturi,? \\Q2001\\E",
      "shortCiteRegEx" : "Impagliazzo and Paturi",
      "year" : 2001
    }, {
      "title" : "Which problems have strongly exponential complexity",
      "author" : [ "R. Impagliazzo", "R. Paturi", "F. Zane" ],
      "venue" : "Journal of Computer and System Science,",
      "citeRegEx" : "Impagliazzo et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Impagliazzo et al\\.",
      "year" : 2001
    }, {
      "title" : "The role of macros in tractable planning",
      "author" : [ "A. Jonsson" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Jonsson,? \\Q2009\\E",
      "shortCiteRegEx" : "Jonsson",
      "year" : 2009
    }, {
      "title" : "State-variable planning under structural restrictions: Algorithms and complexity",
      "author" : [ "P. Jonsson", "C. Bäckström" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Jonsson and Bäckström,? \\Q1998\\E",
      "shortCiteRegEx" : "Jonsson and Bäckström",
      "year" : 1998
    }, {
      "title" : "Tractable plan existence does not imply tractable plan generation",
      "author" : [ "P. Jonsson", "C. Bäckström" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "Jonsson and Bäckström,? \\Q1998\\E",
      "shortCiteRegEx" : "Jonsson and Bäckström",
      "year" : 1998
    }, {
      "title" : "Some connections between nonuniform and uniform complexity classes",
      "author" : [ "R.M. Karp", "R.J. Lipton" ],
      "venue" : "In Proceedings of the 12th ACM Symposium on Theory of Computing (STOC’80),",
      "citeRegEx" : "Karp and Lipton,? \\Q1980\\E",
      "shortCiteRegEx" : "Karp and Lipton",
      "year" : 1980
    }, {
      "title" : "Structural patterns of tractable sequentially-optimal planning",
      "author" : [ "M. Katz", "C. Domshlak" ],
      "venue" : "In Proceedings of the 17th International Conference on Automated Planning and Scheduling (ICAPS",
      "citeRegEx" : "Katz and Domshlak,? \\Q2007\\E",
      "shortCiteRegEx" : "Katz and Domshlak",
      "year" : 2007
    }, {
      "title" : "New islands of tractability of cost-optimal planning",
      "author" : [ "M. Katz", "C. Domshlak" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Katz and Domshlak,? \\Q2008\\E",
      "shortCiteRegEx" : "Katz and Domshlak",
      "year" : 2008
    }, {
      "title" : "Implicit abstraction heuristics",
      "author" : [ "M. Katz", "C. Domshlak" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "Katz and Domshlak,? \\Q2010\\E",
      "shortCiteRegEx" : "Katz and Domshlak",
      "year" : 2010
    }, {
      "title" : "Who said we need to relax all variables",
      "author" : [ "M. Katz", "J. Hoffmann", "C. Domshlak" ],
      "venue" : "In Proceedings of the 23rd International Conference on Automated Planning and Scheduling (ICAPS",
      "citeRegEx" : "Katz et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Katz et al\\.",
      "year" : 2013
    }, {
      "title" : "Structural patterns beyond forks: Extending the complexity boundaries of classical planning",
      "author" : [ "M. Katz", "E. Keyder" ],
      "venue" : "In Proceedings of the 26th AAAI Conference on Artificial Intelligence (AAAI",
      "citeRegEx" : "Katz and Keyder,? \\Q2012\\E",
      "shortCiteRegEx" : "Katz and Keyder",
      "year" : 2012
    }, {
      "title" : "Automatically generating abstractions for planning",
      "author" : [ "C.A. Knoblock" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "Knoblock,? \\Q1994\\E",
      "shortCiteRegEx" : "Knoblock",
      "year" : 1994
    }, {
      "title" : "A note on complete subdivisions in digraphs of large outdegree",
      "author" : [ "D. Kühn", "D. Osthus", "A. Young" ],
      "venue" : "Journal of Graph Theory,",
      "citeRegEx" : "Kühn et al\\.,? \\Q2008\\E",
      "shortCiteRegEx" : "Kühn et al\\.",
      "year" : 2008
    }, {
      "title" : "On the structure of polynomial time reducibility",
      "author" : [ "R.E. Ladner" ],
      "venue" : "Journal of the ACM,",
      "citeRegEx" : "Ladner,? \\Q1975\\E",
      "shortCiteRegEx" : "Ladner",
      "year" : 1975
    }, {
      "title" : "Graph minor theory",
      "author" : [ "L. Lovász" ],
      "venue" : "Bulletin of the AMS,",
      "citeRegEx" : "Lovász,? \\Q2005\\E",
      "shortCiteRegEx" : "Lovász",
      "year" : 2005
    }, {
      "title" : "What is ... a graph minor",
      "author" : [ "B. Mohar" ],
      "venue" : "Notices of the AMS,",
      "citeRegEx" : "Mohar,? \\Q2006\\E",
      "shortCiteRegEx" : "Mohar",
      "year" : 2006
    }, {
      "title" : "Ein kombinatorischer Satz",
      "author" : [ "L. Rédei" ],
      "venue" : "Acta Litteraria Szeged,",
      "citeRegEx" : "Rédei,? \\Q1934\\E",
      "shortCiteRegEx" : "Rédei",
      "year" : 1934
    }, {
      "title" : "The causal graph revisited for directed model checking",
      "author" : [ "M. Wehrle", "M. Helmert" ],
      "venue" : "In Proceedings of Static Analysis, the 16th International Symposium (SAS’09),",
      "citeRegEx" : "Wehrle and Helmert,? \\Q2009\\E",
      "shortCiteRegEx" : "Wehrle and Helmert",
      "year" : 2009
    }, {
      "title" : "A reactive planner for a model-based executive",
      "author" : [ "B. Williams", "P.P. Nayak" ],
      "venue" : "In Proceedings of the 15th International Joint Conference on Artificial Intelligence (IJCAI’97),",
      "citeRegEx" : "Williams and Nayak,? \\Q1997\\E",
      "shortCiteRegEx" : "Williams and Nayak",
      "year" : 1997
    } ],
    "referenceMentions" : [ {
      "referenceID" : 30,
      "context" : "This standard definition of the causal graph can be traced back to Knoblock (1994) although he did not give it a name.",
      "startOffset" : 67,
      "endOffset" : 83
    }, {
      "referenceID" : 30,
      "context" : "This standard definition of the causal graph can be traced back to Knoblock (1994) although he did not give it a name. He used the causal graph in the Alpine algorithm, as a guidance for partitioning and ordering the variables in the process of automatically deriving state abstraction hierarchies. The actual name causal graph can be traced back to Williams and Nayak (1997). Their approach was both more general and more restricted",
      "startOffset" : 67,
      "endOffset" : 376
    }, {
      "referenceID" : 13,
      "context" : "Jonsson and Bäckström (1998b) also studied acyclic causal graphs, but referred to them as dependency graphs.",
      "startOffset" : 0,
      "endOffset" : 30
    }, {
      "referenceID" : 5,
      "context" : "A more general and extensive such analysis was done by Domshlak and Dinitz (2001a), who analysed the complexity of planning for classes of instances corresponding to a number of different possible structures of acyclic causal graphs.",
      "startOffset" : 55,
      "endOffset" : 83
    }, {
      "referenceID" : 5,
      "context" : "A more general and extensive such analysis was done by Domshlak and Dinitz (2001a), who analysed the complexity of planning for classes of instances corresponding to a number of different possible structures of acyclic causal graphs. However, their work was done in the context of multi-agent coordination and the term causal graph was never used. The first two of these papers may be viewed as early examples of exploiting the causal graph in practice, while the latter papers form the starting point of the subsequent theoretical research into the relationships between planning complexity and the structure of causal graphs. An important step forward in the usage of causal graphs was the paper by Helmert (2004) where he demonstrated that the causal graph is particularly useful in the context of multi-valued variables.",
      "startOffset" : 55,
      "endOffset" : 716
    }, {
      "referenceID" : 5,
      "context" : "A more general and extensive such analysis was done by Domshlak and Dinitz (2001a), who analysed the complexity of planning for classes of instances corresponding to a number of different possible structures of acyclic causal graphs. However, their work was done in the context of multi-agent coordination and the term causal graph was never used. The first two of these papers may be viewed as early examples of exploiting the causal graph in practice, while the latter papers form the starting point of the subsequent theoretical research into the relationships between planning complexity and the structure of causal graphs. An important step forward in the usage of causal graphs was the paper by Helmert (2004) where he demonstrated that the causal graph is particularly useful in the context of multi-valued variables. Previous research on the complexity of planning with multi-valued variables had focussed on the structure of the domain-transition graphs for the variables (Jonsson & Bäckström, 1998a), rather than the causal graph. Helmert realized the power of using both the domain-transition graphs and the causal graph in heuristic planning. This was exploited in practice in his highly succesful Fast Downward planner (Helmert, 2006a). It translates PDDL planning instances with binary variables into a representation with multi-valued variables and then removes carefully chosen edges in the resulting causal graph to make it acyclic. The resulting causal graph is then used to compute a heuristic by hierarchically computing and composing plan lengths for subgraphs having one of the particular structures studied by Domshlak and Dinitz (2001a). Somewhat similarly, Katz and Domshlak (2010) identified subgraphs of the causal graph that have certain structures that make planning for them tractable.",
      "startOffset" : 55,
      "endOffset" : 1661
    }, {
      "referenceID" : 5,
      "context" : "A more general and extensive such analysis was done by Domshlak and Dinitz (2001a), who analysed the complexity of planning for classes of instances corresponding to a number of different possible structures of acyclic causal graphs. However, their work was done in the context of multi-agent coordination and the term causal graph was never used. The first two of these papers may be viewed as early examples of exploiting the causal graph in practice, while the latter papers form the starting point of the subsequent theoretical research into the relationships between planning complexity and the structure of causal graphs. An important step forward in the usage of causal graphs was the paper by Helmert (2004) where he demonstrated that the causal graph is particularly useful in the context of multi-valued variables. Previous research on the complexity of planning with multi-valued variables had focussed on the structure of the domain-transition graphs for the variables (Jonsson & Bäckström, 1998a), rather than the causal graph. Helmert realized the power of using both the domain-transition graphs and the causal graph in heuristic planning. This was exploited in practice in his highly succesful Fast Downward planner (Helmert, 2006a). It translates PDDL planning instances with binary variables into a representation with multi-valued variables and then removes carefully chosen edges in the resulting causal graph to make it acyclic. The resulting causal graph is then used to compute a heuristic by hierarchically computing and composing plan lengths for subgraphs having one of the particular structures studied by Domshlak and Dinitz (2001a). Somewhat similarly, Katz and Domshlak (2010) identified subgraphs of the causal graph that have certain structures that make planning for them tractable.",
      "startOffset" : 55,
      "endOffset" : 1707
    }, {
      "referenceID" : 4,
      "context" : "A further example of exploiting the causal graph to make planning more efficient is the paper on factored planning by Brafman and Domshlak (2006). They showed that the structure of the causal graph can be used as a guide for deciding if and how a planning instance can be solved more efficiently by dividing it into loosely coupled subinstances and use constraint processing.",
      "startOffset" : 118,
      "endOffset" : 146
    }, {
      "referenceID" : 8,
      "context" : "For instance, Wehrle and Helmert (2009) transferred the causal graph concept to the context of model checking.",
      "startOffset" : 25,
      "endOffset" : 40
    }, {
      "referenceID" : 8,
      "context" : "For instance, Wehrle and Helmert (2009) transferred the causal graph concept to the context of model checking. As previously mentioned, the two papers by Jonsson and Bäckström (1998b) and by Domshlak and Dinitz (2001a) can be viewed as the starting point for a successful line of research into studying the relationships between planning complexity and the structure of the causal graph.",
      "startOffset" : 25,
      "endOffset" : 184
    }, {
      "referenceID" : 5,
      "context" : "As previously mentioned, the two papers by Jonsson and Bäckström (1998b) and by Domshlak and Dinitz (2001a) can be viewed as the starting point for a successful line of research into studying the relationships between planning complexity and the structure of the causal graph.",
      "startOffset" : 80,
      "endOffset" : 108
    }, {
      "referenceID" : 4,
      "context" : "Further results followed, for instance, in articles by Brafman and Domshlak (2003), and Giménez and Jonsson (2008).",
      "startOffset" : 55,
      "endOffset" : 83
    }, {
      "referenceID" : 4,
      "context" : "Further results followed, for instance, in articles by Brafman and Domshlak (2003), and Giménez and Jonsson (2008). The latter article additionally showed that although 3S instances can have exponential-length plans, it is possible to generate a macro representation of such a plan in polynomial time, a result they extended also to some other classes defined by the structure of the causal graph.",
      "startOffset" : 55,
      "endOffset" : 115
    }, {
      "referenceID" : 4,
      "context" : "Further results followed, for instance, in articles by Brafman and Domshlak (2003), and Giménez and Jonsson (2008). The latter article additionally showed that although 3S instances can have exponential-length plans, it is possible to generate a macro representation of such a plan in polynomial time, a result they extended also to some other classes defined by the structure of the causal graph. Many of the complexity results in these papers use additional numerical parameters in conjunction with the graph structure. Examples of such parameters are the maximum domain size of the variables and the maximum in-degree of the graph. While increasing the number of possible cases to analyse, it does allow for a more fine-grained analysis in many cases. Consider for instance the case of directed path graphs. Domshlak and Dinitz (2001a) proved that it is tractable to decide if there is a plan for this case when the domains are binary, while Giménez and Jonsson (2009) proved that a domain size of 5 is sufficient to make the problem NP-hard.",
      "startOffset" : 55,
      "endOffset" : 839
    }, {
      "referenceID" : 4,
      "context" : "Further results followed, for instance, in articles by Brafman and Domshlak (2003), and Giménez and Jonsson (2008). The latter article additionally showed that although 3S instances can have exponential-length plans, it is possible to generate a macro representation of such a plan in polynomial time, a result they extended also to some other classes defined by the structure of the causal graph. Many of the complexity results in these papers use additional numerical parameters in conjunction with the graph structure. Examples of such parameters are the maximum domain size of the variables and the maximum in-degree of the graph. While increasing the number of possible cases to analyse, it does allow for a more fine-grained analysis in many cases. Consider for instance the case of directed path graphs. Domshlak and Dinitz (2001a) proved that it is tractable to decide if there is a plan for this case when the domains are binary, while Giménez and Jonsson (2009) proved that a domain size of 5 is sufficient to make the problem NP-hard.",
      "startOffset" : 55,
      "endOffset" : 972
    }, {
      "referenceID" : 4,
      "context" : "Further results followed, for instance, in articles by Brafman and Domshlak (2003), and Giménez and Jonsson (2008). The latter article additionally showed that although 3S instances can have exponential-length plans, it is possible to generate a macro representation of such a plan in polynomial time, a result they extended also to some other classes defined by the structure of the causal graph. Many of the complexity results in these papers use additional numerical parameters in conjunction with the graph structure. Examples of such parameters are the maximum domain size of the variables and the maximum in-degree of the graph. While increasing the number of possible cases to analyse, it does allow for a more fine-grained analysis in many cases. Consider for instance the case of directed path graphs. Domshlak and Dinitz (2001a) proved that it is tractable to decide if there is a plan for this case when the domains are binary, while Giménez and Jonsson (2009) proved that a domain size of 5 is sufficient to make the problem NP-hard. Similarly, Giménez and Jonsson (2012) proved tractability for planning instances with binary variables, a constant number of prevail conditions and where the causal graph is a polytree.",
      "startOffset" : 55,
      "endOffset" : 1084
    }, {
      "referenceID" : 4,
      "context" : "Further results followed, for instance, in articles by Brafman and Domshlak (2003), and Giménez and Jonsson (2008). The latter article additionally showed that although 3S instances can have exponential-length plans, it is possible to generate a macro representation of such a plan in polynomial time, a result they extended also to some other classes defined by the structure of the causal graph. Many of the complexity results in these papers use additional numerical parameters in conjunction with the graph structure. Examples of such parameters are the maximum domain size of the variables and the maximum in-degree of the graph. While increasing the number of possible cases to analyse, it does allow for a more fine-grained analysis in many cases. Consider for instance the case of directed path graphs. Domshlak and Dinitz (2001a) proved that it is tractable to decide if there is a plan for this case when the domains are binary, while Giménez and Jonsson (2009) proved that a domain size of 5 is sufficient to make the problem NP-hard. Similarly, Giménez and Jonsson (2012) proved tractability for planning instances with binary variables, a constant number of prevail conditions and where the causal graph is a polytree. Also the paper by Brafman and Domshlak (2006) fits into this line of theoretical research, exhibiting a planning algorithm that runs in time exponential in two parameters, the tree-width of the undirected version of the causal graph and the maximum number of times a variable must change value.",
      "startOffset" : 55,
      "endOffset" : 1278
    }, {
      "referenceID" : 4,
      "context" : "Further results followed, for instance, in articles by Brafman and Domshlak (2003), and Giménez and Jonsson (2008). The latter article additionally showed that although 3S instances can have exponential-length plans, it is possible to generate a macro representation of such a plan in polynomial time, a result they extended also to some other classes defined by the structure of the causal graph. Many of the complexity results in these papers use additional numerical parameters in conjunction with the graph structure. Examples of such parameters are the maximum domain size of the variables and the maximum in-degree of the graph. While increasing the number of possible cases to analyse, it does allow for a more fine-grained analysis in many cases. Consider for instance the case of directed path graphs. Domshlak and Dinitz (2001a) proved that it is tractable to decide if there is a plan for this case when the domains are binary, while Giménez and Jonsson (2009) proved that a domain size of 5 is sufficient to make the problem NP-hard. Similarly, Giménez and Jonsson (2012) proved tractability for planning instances with binary variables, a constant number of prevail conditions and where the causal graph is a polytree. Also the paper by Brafman and Domshlak (2006) fits into this line of theoretical research, exhibiting a planning algorithm that runs in time exponential in two parameters, the tree-width of the undirected version of the causal graph and the maximum number of times a variable must change value. While most research has been based on the standard definition of causal graphs that was set already by Knoblock, although often in the generalisation to multi-valued variables, there are important exceptions. One potential problem with the standard defintion is that whenever two variables are both affected by the same operator, then the causal graph must necessarily contain cycles, which is the major reason why the focus has mainly been on planning with unary operators. In an attempt to circumvent this problem, Jonsson (2009) defined a more relaxed variant of the causal graph that does not always introduce cycles for non-unary operators, which can sometimes allow for a more fine-grained complexity analysis.",
      "startOffset" : 55,
      "endOffset" : 2059
    }, {
      "referenceID" : 5,
      "context" : "milestone that deviates from this line of research was an article by Chen and Giménez (2010) who did not even consider the structure of the causal graph but only a simple quantitative measure, the size of the weakly connected components.",
      "startOffset" : 69,
      "endOffset" : 93
    }, {
      "referenceID" : 3,
      "context" : "Chen and Giménez state that NP-intermediate problems can be obtained by using methods similiar to the ones employed by Bodirsky and Grohe (2008). Such problems are hard to describe as natural, though.",
      "startOffset" : 119,
      "endOffset" : 145
    }, {
      "referenceID" : 3,
      "context" : "Chen and Giménez state that NP-intermediate problems can be obtained by using methods similiar to the ones employed by Bodirsky and Grohe (2008). Such problems are hard to describe as natural, though. They are based on Ladner’s (1975) diagonalization technique that removes a large fraction of input strings from a problem.",
      "startOffset" : 119,
      "endOffset" : 235
    }, {
      "referenceID" : 6,
      "context" : "lak (2013) have applied the result by Chen and Giménez (2010) in the context of so called red-black planning, a variant of delete relaxation for computing heuristics.",
      "startOffset" : 38,
      "endOffset" : 62
    }, {
      "referenceID" : 6,
      "context" : "Since this article has many connections with the one by Chen and Giménez (2010) we follow their notation and terminology for plannning, which is a notational variant of SAS+ (Bäckström & Nebel, 1995).",
      "startOffset" : 56,
      "endOffset" : 80
    }, {
      "referenceID" : 15,
      "context" : "Furthermore, the causal graph heuristic by Helmert (2004) is based on identifying in-star subgraphs of the causal graph, and it should be noted that he provided a variant of the original proof due to some minor technical differences in the problem formulations.",
      "startOffset" : 43,
      "endOffset" : 58
    }, {
      "referenceID" : 33,
      "context" : "The concepts of graph minors and minor-closure has rapidly evolved into a very important and useful research area in mathematical as well as computational graph theory (Lovász, 2005; Mohar, 2006).",
      "startOffset" : 168,
      "endOffset" : 195
    }, {
      "referenceID" : 34,
      "context" : "The concepts of graph minors and minor-closure has rapidly evolved into a very important and useful research area in mathematical as well as computational graph theory (Lovász, 2005; Mohar, 2006).",
      "startOffset" : 168,
      "endOffset" : 195
    }, {
      "referenceID" : 10,
      "context" : "Although somewhat redundant, this is still a reasonable encoding in the sense of Garey and Johnson (1979). Let M work as follows.",
      "startOffset" : 81,
      "endOffset" : 106
    }, {
      "referenceID" : 6,
      "context" : "The theorem by Chen and Giménez (2010) states a crisp complexity-theoretic borderline: if the component sizes are bounded by a constant, then planning is polynomial-time solvable and, otherwise, planning is not polynomial-time solvable.",
      "startOffset" : 15,
      "endOffset" : 39
    }, {
      "referenceID" : 35,
      "context" : "However, tournaments are Hamiltonian graphs (Rédei, 1934) so if T is a tournament on n vertices, then path-length(T ) = n − 1.",
      "startOffset" : 44,
      "endOffset" : 57
    }, {
      "referenceID" : 11,
      "context" : "Giménez and Jonsson (2012) refer to an operator as k-dependent if it has a precondition on at most k variables that it does not also change.",
      "startOffset" : 0,
      "endOffset" : 27
    }, {
      "referenceID" : 15,
      "context" : "Examples are the causal-graph heuristic by Helmert (2006a), factored planning (Brafman & Domshlak, 2006) and structural pattern data bases (Katz & Domshlak, 2010).",
      "startOffset" : 43,
      "endOffset" : 59
    } ],
    "year" : 2013,
    "abstractText" : "The causal graph of a planning instance is an important tool for planning both in practice and in theory. The theoretical studies of causal graphs have largely analysed the computational complexity of planning for instances where the causal graph has a certain structure, often in combination with other parameters like the domain size of the variables. Chen and Giménez ignored even the structure and considered only the size of the weakly connected components. They proved that planning is tractable if the components are bounded by a constant and otherwise intractable. Their intractability result was, however, conditioned by an assumption from parameterised complexity theory that has no known useful relationship with the standard complexity classes. We approach the same problem from the perspective of standard complexity classes, and prove that planning is NP-hard for classes with unbounded components under an additional restriction we refer to as SPclosed. We then argue that most NP-hardness theorems for causal graphs are difficult to apply and, thus, prove a more general result; even if the component sizes grow slowly and the class is not densely populated with graphs, planning still cannot be tractable unless the polynomial hierachy collapses. Both these results still hold when restricted to the class of acyclic causal graphs. We finally give a partial characterization of the borderline between NP-hard and NP-intermediate classes, giving further insight into the problem.",
    "creator" : "TeX"
  }
}