{
  "name" : "1606.04753.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Safe Exploration in Finite Markov Decision Processes with Gaussian Processes",
    "authors" : [ "Matteo Turchetta", "Felix Berkenkamp" ],
    "emails" : [ "matteotu@ethz.ch", "befelix@ethz.ch", "krausea@ethz.ch" ],
    "sections" : [ {
      "heading" : null,
      "text" : "In classical reinforcement learning, when exploring an environment, agents accept arbitrary short term loss for long term gain. This is infeasible for safety critical applications, such as robotics, where even a single unsafe action may cause system failure. In this paper, we address the problem of safely exploring finite Markov decision processes (MDP). We define safety in terms of an, a priori unknown, safety constraint that depends on states and actions. We aim to explore the MDP under this constraint, assuming that the unknown function satisfies regularity conditions expressed via a Gaussian process prior. We develop a novel algorithm for this task and prove that it is able to completely explore the safely reachable part of the MDP without violating the safety constraint. To achieve this, it cautiously explores safe states and actions in order to gain statistical confidence about the safety of unvisited state-action pairs from noisy observations collected while navigating the environment. Moreover, the algorithm explicitly considers reachability when exploring the MDP, ensuring that it does not get stuck in any state with no safe way out. We demonstrate our method on digital terrain models for the task of exploring an unknown map with a rover."
    }, {
      "heading" : "1 Introduction",
      "text" : "Today’s robots are required to operate in variable and often unknown environments. The traditional approach is to specify all potential scenarios that a robot may encounter during operation a priori. This is time consuming or even infeasible. As a consequence, robots need to be able to learn and adapt to unknown environments autonomously [10, 2]. While exploration algorithms are known, safety is still an open problem in the development of such systems [18]. In fact, most learning algorithms allow robots to make unsafe decisions during exploration. This can damage the learning system.\nIn this paper, we provide a solution to this problem and develop an algorithm that enables agents to safely explore unknown environments. Specifically, we consider the problem of exploring a Markov decision process (MDP), where it is a priori unknown if a particular state-action pair is safe. The algorithm that we present cautiously explores this environment without taking actions that are unsafe or may render the exploring agent stuck.\nRelated Work. Safe exploration is an open problem in the reinforcement learning community and several definitions of safety have been proposed [16]. In risk-sensitive reinforcement learning, the goal is to maximize the expected return for the worst case scenario [5]. However, these approaches only minimize risk and do not treat safety as a hard constraint. For example, Geibel and Wysotzki [7] define risk as the probability of driving the system to a previously known set of undesirable states. The main difference to our approach is that we do not assume the undesirable states to be known a priori. Garcia and Fernández [6] propose to ensure safety by means of a backup policy; that is, a policy that is known to be safe in advance. Our approach is different, since does not require a backup policy but only a set of initially safe states from which the agent starts to explore. Another approach\n29th Conference on Neural Information Processing Systems (NIPS 2016), Barcelona, Spain.\nar X\niv :1\n60 6.\n04 75\n3v 1\n[ cs\n.L G\n] 1\n5 Ju\nn 20\nthat makes use of a backup policy is shown by Hans et al. [9], where safety is defined in terms of a minimum reward, which is learned from data.\nMoldovan and Abbeel [14] provide probabilistic safety guarantees at every time step by optimizing over ergodic policies; that is, policies that let the agent recover from any visited state. This approach needs to solve a large linear program at every time step, which is computationally demanding even for small state spaces. Nevertheless, the idea of ergodicity also plays an important role in our method. In the control community, safety is mostly considered in terms of stability or constraint satisfaction of controlled systems. Akametalu et al. [1] use reachability analysis to ensure stability under the assumption of bounded disturbances. The work in [3] uses robust control techniques in order to ensure robust stability for model uncertainties, while the uncertain model is improved.\nAnother field that has recently considered safety is Bayesian optimization [13]. There, in order to find the global optimum of an a priori unknown function [21], regularity assumptions in form of a Gaussian process (GP) [17] are made. The corresponding GP posterior distribution over the unknown function is used to guide evaluations to informative locations. In this setting, safety centered approaches include the work of Sui et al. [22] and Schreiter et al. [20], where the goal is to find the safely reachable optimum without violating an a priori unknown safety constraint at any evaluation. To achieve this, the function is cautiously explored, starting from a set of points that is known to be safe initially. The method in [22] has the advantage of being sample efficient. It was applied to the field of robotics to safely optimize the controller parameters of a quadrotor vehicle [4]. However, they considered a bandit setting, where at each iteration any arm can be played. In contrast, in this paper we consider an MDP, which introduces restrictions in terms of reachability that have not been considered in Bayesian optimization before.\nContribution. We introduce a novel algorithm for safe exploration in MDPs. We model safety via an a priori unknown constraint that depends on state-action pairs. Starting from an initial set of states and actions that are known to fulfill the safety constraint, the algorithm exploits the regularity assumptions on the constraint function in order to determine if nearby, unvisited states are safe. This leads to safe exploration, where only state-actions pairs that are known to be safe are evaluated. The main contribution consists of extending the work on safe Bayesian optimization in [22] from the bandit setting to MDPs. In order to achieve this, we explicitly consider not only the safety constraint, but also the reachability properties induced by the MDP dynamics. We provide a full theoretical analysis of the algorithm. It enjoys similar safety guarantees in terms of ergodicity, the ability to return to the safe starting point, as presented in [14], but at a vastly reduced computational cost. The reason for this is that our method separates safety from the reachability properties of the MDP, making computations more tractable. Beyond this, our method is able to handle general safety constraints and we prove that it is able to fully explore the safely reachable region of the MDP, without getting stuck or violating the safety constraint with high probability. We validate our method on an exploration task, where a rover has to explore an a priori unknown map."
    }, {
      "heading" : "2 Problem Statement",
      "text" : "In this section, we define our problem and assumptions. The unknown environment is modeled as a finite Markov Decision Processes (MDP) [23]. A finite MDP is a tuple M = 〈S,A, f(s, a), r(s, a)〉 with finite state and action spaces, S and A, respectively, a known, deterministic transition model, f(s, a), and reward function, r(s, a). In the typical reinforcement learning framework, the reward is a known function that encodes desirable states. In this paper, we consider the problem of safely exploring the MDP, and thus do not aim to maximize the reward. Instead we define r(s, a) as an a priori unknown safety feature. Although r(s, a) is unknown, we make regularity assumptions about it to make the problem tractable. When traversing the MDP, at each discrete time step, k, the agent has to decide which action and thereby state to visit next. We assume that the underlying system is safety-critical and that for any visited state-action pair, (sk, ak), the unknown, associated safety feature, r(sk, ak), must be above a safety threshold, h. While the assumption of deterministic dynamics does not hold for general MDPs, in our framework, uncertainty about the environment is captured by the safety feature. If requested, the agent can obtain noisy measurements of the safety feature, r(sk, ak). The index t is used to index measurements, while k denotes movement steps. Typically k t.\nIt is hopeless to achieve the goal of safe exploration unless the agent starts in a safe location. Hence, we assume that the agent stays in an initial set of state action pairs, S0, that is known to be safe a priori. The goal is to identify the maximum safely reachable region starting from S0, without visiting any unsafe states. In the following we assume that safety depends on states only; that is, r(s, a) = r(s). We provide an extension to safety features on actions in Fig. 2b.\nAssumptions on the reward function Ensuring that all visited states are safe without any prior knowledge about the safety feature is an impossible task (e.g., if the safety feature is discontinuous). However, many practical safety features exhibit some regularity, where similar states will lead to similar values of r.\nIn the following, we assume that S is endowed with a positive definite kernel function, k(·, ·), and that the function, r(·), has bounded norm in the associated Reproducing Kernel Hilbert Space (RKHS) [19]. The norm induced by the inner product of the RKHS indicates the smoothness of functions with respect to the kernel. This assumption allows us to model r as a Gaussian Process (GP) [17], r(s) ∼ GP(µ(s), k(s, s′)). A GP is a probability distribution over functions fully specified by its mean function, µ(s), and its covariance function, k(s, s′). We assume µ(s) = 0, for all s ∈ S, without loss of generality. The posterior distribution over r can be computed analytically, based on t measurements at states At = {s1, . . . , st} ⊆ S with measurements, yt = [r(s1) + ω1 . . . r(st) + ωt]T, that are corrupted by zero-mean Gaussian noise, ωt ∼ N (0, σ2). The posterior is a GP distribution, with mean µt(s) = kt(s)T(Kt + σ2I)−1yt, variance σt(s) = kt(s, s) and covariance kt(s, s′) = k(s, s′)− kt(s)T(Kt + σ2I)−1kt(s′), where kt(s) = [k(s1, s), . . . , k(st, s)]T and Kt is the positive definite kernel matrix, [k(s, s′)]s,s′∈At .\nFor many commonly used kernels, the GP assumption implies that the reward function is Lipschitz continuous with high probability [21, 8]. Thus, we assume that the reward function is Lipschitz continuous, with Lipschitz constant L, with respect to some metric, d(· , ·), on S. Goal In this section we define the goal of the algorithm more precisely. In particular we ask, what the best that any algorithm may hope to achieve is. Since we only observe noisy measurements, it is impossible to know the underlying function, r, accurately after a finite number of measurements. Instead, we consider algorithms that only have knowledge of r up to some statistical confidence, . Based on this confidence within some safe set S, states with small distance to S can be classified to satisfy the safety constraint using the Lipschitz continuity of r. The resulting set of safe states is\nRsafe (S) = S ∪ {s ∈ S | ∃s′ ∈ S : r(s′)− − Ld(s, s′) ≥ h}, (1)\nwhich contains states that can be classified as safe given the information about the states in S. While (1) considers the safety constraint, it does not consider any restrictions put in place by the structure of the MDP. In particular, we may not be able to visit every state inRsafe (S) without visiting an unsafe state first. As a result, the agent is further restricted to\nRreach(S) = S ∪ {s ∈ S | ∃s′ ∈ S, a ∈ A(s′) : s = f(s′, a)}, (2)\nthe set of all states that can be reached starting from the safe set in one step. These states are called the one-step safely reachable states. However, even restricted to this set, the agent may still get stuck in a state without any safe actions. We define\nRret(S, S) = S ∪ {s ∈ S | ∃a ∈ A(s) : f(s, a) ∈ S} (3)\nas the set of states that are able to return to a set S through some other set of states, S, in one step. In particular, we care about the ability to return to a certain set through a set of safe states S. Therefore, these are called the one-step safely recoverable states. In general, the return routes\nAlgorithm 1 Safe exploration in MDPs (SafeMDP) Inputs: M = 〈S, A, f(·, ·), GP(0, k(s, s′)) 〉, Safety threshold h,\nLipschitz constant L, Safe seed S0. C0(s)← [h,∞) for all s ∈ S0 for t = 1, 2, . . . do St ← {s ∈ S | ∃s′ ∈ Ŝt−1 : lt(s′)− Ld(s, s′ ≥ h} Ŝt ← {s ∈ St | s ∈ Rreach(Ŝt−1), s ∈ R ret (St, Ŝt−1)}\nGt ← {s ∈ Ŝt | gt(s) > 0} st ← argmaxs∈Gt wt(s) Safe Dijkstra in St from st−1 to st Update GP with st and yt ← r(st) + ωt if Gt = ∅ or max\ns∈Gt wt(s) ≤ then Break\nmay require taking more than one action, see Fig. 1. The n-step returnability operator, Rretn (S, S) = Rret(S,Rret(S, . . .)), considers these longer return routes by repeatedly applying the return operator, (3), n times. The limit, R ret (S, S) = limn→∞R ret n (S, S), contains all the states that can reach the set S through an arbitrarily long path in S.\nFor safe exploration of MDPs, all of the above are requirements; that is, any state that we may want to visit needs to be safe (satisfy the safety constraint), reachable, and we must be able to return to safe states from this new state. Thus, any algorithm that aims to safely explore an MDP is only allowed to visit states in\nR (S) = R safe (S) ∩Rreach(S) ∩R ret (Rsafe (S), S), (4)\nwhich is the intersection of the three safety-relevant sets. Given a safe set, S, that fulfills all the safety requirements, R ret (Rsafe (S), S) is the set of states from which we can return to S by only visiting states that can be classified as above the safety threshold.\nGiven knowledge about the safety feature in S up to accuracy thus allows us to expand the set of safe ergodic states to R (S). Any algorithm that has the goal of exploring the state space should consequently explore these newly available safe states and gain new knowledge about the safety feature, r. The safe set after n such expansions can be found by repeatedly applying n times the operator in (4): Rn (S) = R (R . . . R (S)) . . .). Ultimately, the size of the safe set is bounded by surrounding unsafe states or the number of states in S. As a result, the biggest set that any algorithm may classify as safe without visiting unsafe states is given by taking the limit, R (S) = limn→∞R n (S).\nThus, given a tolerance level, , and an initial safe seed set, S0, the baseline that we compare our algorithm against is the exploration of R (S0), the set of states that any algorithm may hope to classify as safe. Let St denote the set of states that is classified as safe at iteration t. In the following, we will refer to complete, safe exploration whenever an algorithm fulfills R (S0) ⊆ limt→∞ St ⊆ R0(S0); that is, the algorithm classifies every safely reachable state up to accuracy as safe, without misclassification or visiting unsafe states."
    }, {
      "heading" : "3 Algorithm",
      "text" : "We start by giving a high level overview of the method. The algorithm relies on a GP model of r to make predictions about the safety feature and uses the predictive uncertainty to guide the safe exploration. In order to guarantee safety, it maintains two sets. The first set, St, contains all states that can be classified as satisfying the safety constraint on r using the GP posterior, while the second one, Ŝt, additionally considers the ability to reach points in St and the ability to safely return to the previous safe set, Ŝt−1. The algorithm ensures safety and ergodicity by only visiting states in Ŝt. In order to expand the safe region, the algorithm visits states in Gt ⊆ Ŝt, a set of candidate states that, if visited, could expand the safe set. Specifically, the algorithm selects the most uncertain state in Gt, which is the safe state that we can gain the most information about. We move to this state via the shortest safe path, which is guaranteed to exist (Lemma 2). The algorithm is summarized in Algorithm 1.\nInitialization. The algorithm relies on an initial safe set, S0, as a starting point to explore the MDP. These states must be safe; that is, r(s) ≥ h, for all s ∈ S0. They must also fulfill the reachability and returnability requirements from Sec. 2. Consequently, for any two states, s, s′ ∈ S0, there must exist a path in S0 that connects them: s′ ∈ R ret (S0, {s}). While this may seem restrictive, the requirement is, for example, fulfilled by a single state that has an action corresponding to staying in place.\nClassification. In order to safely explore the MDP, the algorithm must determine which states are safe without visiting them. The regularity assumptions introduced in Sec. 2 allow us to model the safety feature as a GP , so that we can use the uncertainty estimate of the GP model in order to determine a confidence interval within which the true safety function lies with high probability. For every state s, this confidence interval has the form Qt(s) = [ µt−1(s)± √ βtσt−1(s) ] , where βt is a positive scalar that determines the amplitude of the interval. We discuss how to select βt in Sec. 4.\nRather than defining high probability bounds on the values of r(s) directly in terms ofQt, we consider the intersection of the setsQt up to iteration t, Ct(s) = Qt(s) ∩ Ct−1(s). This choice ensures that set of states that we classify as safe does not shrink over iterations. This choice is justified by the selection of βt in Sec. 4. Based on these confidence intervals, we define a lower bound, lt(s) = min Ct(s), and upper bound, ut(s) = max Ct(s), on the values that the safety features r(s) are likely to take based on the data obtained up to iteration t. Based on these lower bounds, we define\nSt = { s ∈ S | ∃s′ ∈ Ŝt−1 : lt(s′)− Ld(s, s′) ≥ h } (5)\nas the set of states that fulfill the safety constraint on r with high probability by using the Lipschitz constant to generalize beyond the current safe set. Based on this classification, the set of ergodic safe states is the set of states that achieve the safe threshold and, additionally, fulfill the reachability and returnability properties discussed in Sec. 2:\nŜt = { s ∈ St | s ∈ Rreach(Ŝt−1) ∩R ret (St, Ŝt−1) } . (6)\nExpanders. With the set of safe states defined, the task of the algorithm is to identify and explore states that might expand the set of states that can be classified as safe. We use the uncertainty estimate in the GP in order to define an optimistic set of expanders,\nGt = {s ∈ Ŝt | gt(s) > 0}, (7) where, gt(s) = ∣∣{s′ ∈ S \\ St |ut(s)− Ld(s, s′) ≥ h}∣∣. The function gt(s) is positive whenever an optimistic measurement at s, equal to the upper confidence bound, ut, would allow us to determine that a previously unsafe state indeed has has value r(s′) above the safety threshold. Intuitively, sampling s might lead to the expansion of St. For a graphical intuition of the set Gt see Fig. 2a.\nSampling and shortest safe path. The remaining part of the algorithm is concerned with selecting a state from these sets to evaluate and find a safe path in the MDP that leads towards them. The goal is to visit states that allow the safe set to expand as quickly as possible, so that we do not waste resources when exploring the MDP. We use the GP posterior uncertainty about the states in Gt in order to make this choice. At each iteration t, we select as next target sample the state with the highest variance in Gt, st = argmaxs∈Gt wt(s), where wt(s) = ut(s) − lt(s). This choice is justified, because while all points in Gt are safe and can potentially enlarge the safe set, based on one noisy sample we can gain the most information from the state about which we are the most uncertain. Given st, we use Dijkstra’s algorithm within the set St in order to find the shortest safe path to the target from the current state, st−1. Since we require reachability and returnability for all safe states, such a path is guaranteed to exist. We terminate the algorithm when we reach the desired accuracy; that is, argmaxs∈Gt wt(s) ≤ . Action-dependent safety. So far, we have considered safety features that only depend on the states, r(s). In general, safety can also depend on the actions, r(s, a). In this section we introduce an abstract MDP that generalizes for these dependencies without modifying the algorithm. The abstract model is equivalent to the original one in terms of dynamics, f(s, a). However, we introduce additional, abstract action-states, sa, for each action. In the abstract MDP, when we start in a state s, and take action a, we first transition to this abstract action-state, from which there is only one action that deterministically transitions to f(s, a). This model is illustrated in Fig. 2b. Safety features that depend on these Action-state, sa, are equivalent to action-dependent safety features. Algorithm 1 can be used on this abstract model without modification. See the experiments in Sec. 5 for an example.\nState s\nSa fe\nty r(\ns)\n(a) Example for the classification scheme. States are classified as above the safety constraint (dashed line) according to the confidence intervals of the GP model, St (red bar). The green bar indicates the states that can expand the safe set if sampled, Gt.\n(b) Abstract MDP model that is used to encode safety features that depend on actions. In this model, actions lead to abstract states, sa, which only have one available action that leads to f(s, a)."
    }, {
      "heading" : "4 Theoretical Results",
      "text" : "The safety and exploration aspects of the algorithm that we presented in the previous section rely on the correctness of the confidence intervals Ct(s). In particular, they require that the true value of the safety feature, r(s), lies within Ct(s) with high probability for all s ∈ S and all iterations t > 0. Furthermore, these confidence intervals have to shrink sufficiently fast over time. The probability of r taking values within the confidence intervals depends on the scaling factor βt. This scaling factor trades off conservativeness in the exploration for the probability of unsafe states being visited. Appropriate selection of βt has been studied by Srinivas et al. [21] in the multi-armed bandit setting. Even though our framework is different, their setting can be applied to our case. We choose,\nβt = 2B + 300γt log 3(t/δ), (8)\nwhere B is the bound on the RKHS norm of the reward function, δ is the probability of visiting unsafe states, and γt is the maximum mutual information that can be gained about r(·) from t noisy observations; that is, γt = max|A|≤t I(r,yA). The information gain has a sublinear dependence on t for many commonly used kernels. More details on these bounds on γt can be found in [21]. The choice of βt in (8) is justified by the following Lemma, which follows from Theorem 6 in [21]:\nLemma 1. Assume that ‖r‖2k ≤ B, and that the noise, ωt, is zero-mean conditioned on the history, as well as uniformly bounded by σ for all t > 0. If βt is chosen as in (8), then, for all t > 0, and all s ∈ S, it holds with probability at least 1− δ that r(s) ∈ Ct(s).\nThis Lemma states that, for βt as in (8), the reward function r(s) takes values within the confidence intervals C(s) with high probability. Based on this, we state the main theoretical result:\nTheorem 1. Assume that r is L-Lipschitz continuous and that the assumptions of Lemma 1 hold. Also, assume that S0 6= ∅, r(s) ≥ h for all s ∈ S0, and that for any two states, s, s′ ∈ S0, s′ ∈ Rret(S0, {s}). Choose βt as in (8). Let (s0, s1, . . . , sk, . . .) denote a state trajectory induced by Algorithm 1 on an MDP with transition function f(s, a). Then, with probability at least 1− δ, r(sk) ≥ h,∀k > 0.Moreover, let t∗ be the smallest integer such that t ∗\nβt∗γt∗ ≥ C |R0(S0)| 2 ,\nwith C = 8/log(1 + σ−2). Then, there exists a t0 ≤ t∗ such that, with probability at least 1− δ, R (S0) ⊆ Ŝt0 ⊆ R0(S0).\nThis theorem states that Algorithm 1 performs safe and complete exploration of the state space; that is, it explores the maximum reachable safe set without visiting unsafe states. Moreover, for any desired accuracy, , and probability of failure, δ, the safely reachable region can be found within a finite number of observations. This bound depends on the information gain, which in turn depends on the kernel. If the safety feature is allowed to change rapidly across states, the information gain will be larger than if the safety feature was smooth. Intuitively, the less prior knowledge the kernel encodes, the more careful we have to be when exploring the MDP, which requires more measurements.\nAn important aspect of the proofs is guaranteeing that we cannot get stuck when running Algorithm 1:\nLemma 2. Assume that S0 6= ∅ and that for all states, s, s′ ∈ S0, s ∈ R ret (S0, {s′}). Then, when using Algorithm 1 under the assumptions in Theorem 1, for all t > 0 and for all states, s, s′ ∈ Ŝt, s ∈ Rret(St, {s′}).\nThis lemma states that given an initial safe set that fulfills the initialization requirements, the safe set Ŝt will continue to fulfill these requirements for all iterations; that is, we can always find a policy that drives us from any state in Ŝt to any other state in Ŝt without leaving the set of safe states."
    }, {
      "heading" : "5 Experiments",
      "text" : "In this section, we demonstrate Algorithm 1 on an exploration task. We consider the setting in [14], the exploration of the surface of Mars with a rover. The code for the experiments is available at http://github.com/befelix/SafeMDP.\nFor space exploration, communication delays between the rover and the operator on Earth can be prohibitive. Thus, it is important that the robot can act autonomously and explore the environment without risking unsafe behavior. For the experiment, we consider the Mars Science Laboratory (MSL) [11], a rover deployed on Mars. Due to communication delays, the MSL can travel 20 meters before it can obtain new instructions from an operator. It can climb a maximum slope of 30◦ [15, Sec. 2.1.3]. In our experiments we use digital terrain models of the surface of Mars from High Resolution Imaging Science Experiment (HiRISE), which have a resolution of one meter [12].\nAs opposed to the experiments considered by Moldovan and Abbeel [14], we do not have to subsample or smoothen the data in order to achieve good exploration results. This is due to the flexibility of the GP framework that considers noisy measurements. Therefore, every state in the MDP represents a d× d square area with d = 1m, as opposed to d = 20m in [14]. At every state the agent can take one of four actions: up, down, left and right. If the rover attempts to climb a slope that is steeper than 30◦, it fails and may be damaged. Otherwise it moves deterministically to the desired neighboring state. In this setting, we define safety over state transitions by using the extension we outlined in Fig. 2b. The safety feature over the transition from s to s′ is defined in terms of height difference between the two states, H(s)−H(s′). Given the maximum slope of α = 30◦ that the rover can climb, the safety threshold is set at a conservative h = −d tan(25◦). This encodes, that it is unsafe for the robot to climb hills that are too steep. In particular, while the MDP dynamics assume that Mars is flat and every state can be reached, the safety constraint depends on the a priori unknown heights. Therefore, under the prior belief, it is unknown which transitions are safe.\nWe model the height distribution,H(s), as a GP with a Matérn kernel with ν = 5/2. The lengthscales are set to 14.5m and the prior variance over heights is 100m2. We assume a noise standard deviation of 0.075 m. Since the safety feature of each state transition is a linear combination of heights, the GP model of the heights induces a GP model over the differences of heights, which we use to classify whether state transitions fulfill the safety constraint. In particular, the safety depends on the direction of travel, that is, going downhill is possible, while going uphill might be unsafe.\nFollowing the recommendations in [22], in our experiments we use the GP confidence intervals Qt(s) directly to determine the safe set St. As a result, the Lipschitz constant is only used to determine expanders in G. Guaranteeing safe exploration with high probability over multiple steps leads to conservative behavior, as every step beyond the set that is known to be safe decreases the ‘probability budget’ for failure. In order to demonstrate that safety can be achieved empirically using less conservative parameters than those suggested by Theorem 1, we fix beta to a constant value, βt = 2, ∀t ≥ 0. This aims to guarantee safety per iteration rather than jointly over all the iterations. The same assumption is used in [14].\nWe compare our algorithm to several baselines. The first one considers both the safety threshold and the ergodicity requirements but neglects the expanders. In this setting the agent samples the most uncertain safe state transaction, which corresponds to the safe Bayesian optimization framework in [20]. We expect the exploration to be safe, but less efficient than our approach. The second baseline considers the safety threshold, but does not consider ergodicity requirements. In this setting, we expect the rover’s behavior to fulfill the safety constraint and to never attempt to climb steep slopes, but it may get stuck in states without safe actions. The third method uses the unconstrained Bayesian optimization framework in order to explore new states, without safety requirements. In this setting, the agent tries to obtain measurements from the most uncertain state transition over the entire space, rather than restricting itself to the safe set. In this case, the rover can easily get stuck and may also incur failures by attempting to climb steep slopes. Last, we consider a random exploration strategy, which is similar to the -greedy exploration strategies that are widely used in reinforcement learning.\n0 30 60 90 120\ndistance [m]\n70\n35\n0\ndi st\nan ce\n[m ]\n(a) Non-ergodic.\n0 30 60 90 120\ndistance [m] (b) Unsafe.\n0 30 60 90 120\ndistance [m] (c) Random.\n0 30 60 90 120\ndistance [m] (d) No Expanders.\nWe compare these baselines over an 120 by 70 meters area at −30.6◦ latitude and 202.2◦ longitude. The resulting exploration behaviors can be seen in Fig. 2. The rover starts in the center-top part of the plot, a relatively planar area. In the top-right corner there is a hill that the rover cannot climb, while in the bottom-right corner there is a crater that, once entered, the rover cannot leave. The safe behavior that we expect is to explore the planar area, without moving into the crater or attempting to climb the hill. We run all algorithms for 525 iterations or until the first unsafe action is attempted. It can be seen in Fig. 2e that our method explores the safe area that surrounds the crater, without attempting to move inside. While some state-action pairs closer to the crater are also safe, the GP model would require more data classify them as safe with the necessary confidence. In contrast, the baselines perform significantly worse. The baseline that does not consider the ability to return to the safe set (non-ergodic) can be seen in Fig. 2a. It does not explore the area, because it quickly reaches a state without a safe path to the next target sample. Our approach avoids these situations explicitly. The unsafe exploration baseline in Fig. 2b considers ergodicity, but concludes that every state is reachable according to the MDP model. Consequently, it follows a path that crosses the boundary of the crater and eventually evaluates an unsafe action. Overall, it is not enough to consider only ergodicity or only safety, in order to solve the safe exploration problem. The random exploration in Fig. 2c attempts an unsafe action after some exploration. In contrast, Algorithm 1 manages to safely explore a large part of the unknown environment. Running the algorithm without considering expanders leads to the behavior in Fig. 2d, which is safe, but only manages to explore a small subset of the safely reachable area within the same number of iterations in which Algorithm 1 explores over 80% of it. The results are summarized in Table 2f."
    }, {
      "heading" : "6 Conclusion",
      "text" : "We presented an algorithm to safely explore a priori unknown environments. We used a Gaussian process model to model the safety constraints, which allows the algorithm to reason about the safety of state-action pairs before visiting them. An important aspect of the algorithm is that it considers the transition dynamics of the MDP in order to ensure that there is a safe return route before visiting states. We proved that the algorithm is capable of exploring the full safely reachable region with few measurements, and demonstrated its practicality and performance in experiments."
    }, {
      "heading" : "A Preliminary lemmas",
      "text" : "Lemma 3. ∀s ∈ S, ut+1(s) ≤ ut(s), lt+1(s) ≥ lt(s), wt+1(s) ≤ wt(s).\nProof. This lemma follows directly from the definitions of ut(s), lt(s), wt(s) and Ct(s).\nLemma 4. ∀n ≥ 1, s ∈ Rretn (S, S) =⇒ s ∈ S ∪ S.\nProof. Proof by induction. Consider n = 1, then s ∈ Rret(S, S) =⇒ s ∈ S ∪ S by definition. For the induction step, assume s ∈ Rretn−1(S, S) =⇒ s ∈ S ∪ S. Now consider s ∈ Rretn (S, S). We know that\nRretn (S, S) = R ret(S,Rretn−1(S, S)),\n= Rretn−1(S, S) ∪ {s ∈ S | ∃a ∈ A(s) : f(s, a) ∈ Rretn−1(S, S)}.\nTherefore, since s ∈ Rretn−1(S, S) =⇒ s ∈ S ∪ S and S ⊆ S ∪ S, it follows that s ∈ S ∪ S and the induction step is complete.\nLemma 5. ∀n ≥ 1, s ∈ Rretn (S, S) ⇐⇒ ∃k, 0 ≤ k ≤ n and (a1, . . . , ak), a sequence of k actions, that induces (s0, s1, . . . , sk) starting at s0 = s, such that si ∈ S, ∀i = 1, . . . , k − 1 and sk ∈ S.\nProof. ( =⇒ ). s ∈ Rretn (S, S) means that either s ∈ Rretn−1(S, S) or ∃a ∈ A(s) : f(s, a) ∈ Rretn−1(S, S). Therefore, we can reach a state in R ret n−1(S, S) with at most one action. Repeating this procedure i times, the system reaches a state in Rretn−i(S, S). This requires a number of actions that that goes from 0 to i because each time we have the zero-or-one action type of situation we mentioned before. Therefore, after i = n − 1 times we repeat this procedure, the system reaches a state in ∈ Rret(S, S). Similarly, in this case, the system can reach the set S with either zero or one action. In the end there is a sequence of actions of length k, with 0 ≤ k ≤ n, inducing a state trajectory such that: s0 = s, si ∈ Rretn (S, S) ⊆ S ∪ S for every i = 1, . . . , k − 1 and sk ∈ S. If it happens that for some i, si ∈ S, then it is possible to just cut the sequence of actions at ai. ( ⇐= ). Consider k = 0. This means that s ∈ S ⊆ Rretn (S, S). In case k = 1 we have that s0 ∈ S and that f(s0, a1) ∈ S. Therefore s ∈ Rret(S, S) ⊆ Rretn (S, S). For k ≥ 2 we know sk−1 ∈ S and f(sk−1, ak) ∈ S =⇒ sk−1 ∈ Rret(S, S). Similarly sk−2 ∈ S and f(sk−2, ak−1) = sk−1 ∈ Rret(S, S) =⇒ sk−2 ∈ Rret2 (S, S). If we apply this reasoning k times we obtain that s ∈ Rretk (S, S) ⊆ Rretn (S, S).\nLemma 6. ∀S, S ⊆ S, ∀N ≥ |S|, RretN (S, S) = RretN+1(S, S) = R ret (S, S)\nProof. This is a direct consequence of Lemma 5. In fact, Lemma 5 states that s belongs to RretN (S, S) if and only if there is a path of length at most N starting from s contained in S that drives the system to a state in S. Since we are dealing with a finite MDP, there are |S| different states. Therefore, if such a path exists it cannot be longer than |S|.\nLemma 7. Given S ⊆ R ⊆ S and S ⊆ R ⊆ S, it holds that Rret(S, S) ⊆ Rret(R,R).\nProof. Let s ∈ Rret(S, S). It follows from Lemmas 5 and 6 that there exists a sequence of actions, (a1, . . . , ak), with 0 ≤ k ≤ |S|, that induces a state trajectory, (s0, s1, . . . , sk), starting at s0 = s with si ∈ S ⊆ R, ∀i = 1, . . . , k − 1 and sk ∈ S ⊆ R. Using the ( ⇐= ) direction of Lemma 5 and Lemma 6, we conclude that s ∈ Rret(R,R).\nLemma 8. S ⊆ R =⇒ Rreach(S) ⊆ Rreach(R).\nProof. Consider s ∈ Rreach(S). Then either s ∈ S ⊆ R or ∃ŝ ∈ S ⊆ R, â ∈ A(ŝ) : s = f(ŝ, â), by definition. This implies that s ∈ Rreach(R).\nLemma 9. For any t ≥ 1, S0 ⊆ St ⊆ St+1 and Ŝ0 ⊆ Ŝt ⊆ Ŝt+1\nProof. Proof by induction. Consider s ∈ S0, S0 = Ŝ0 by initialization. We known that\nl1(s)− Ld(s, s) = l1(s) ≥ l0(s) ≥ h,\nwhere the last inequality follows from Lemma 3. This implies that s ∈ S1 or, equivalently, that S0 ⊆ S1. Furthermore, we know by initialization that s ∈ Rreach(Ŝ0). Moreover, we can say that s ∈ Rret(S1, Ŝ0), since S1 ⊇ S0 = Ŝ0. We can conclude that s ∈ Ŝ1. For the induction step assume that St−1 ⊆ St and Ŝt−1 ⊆ Ŝt. Let s ∈ St. Then,\n∃s′ ∈ Ŝt−1 ⊆ Ŝt : lt(s′)− Ld(s, s′) ≥ h.\nFurthermore, it follows from Lemma 3 that lt+1(s′)− Ld(s, s′) ≥ lt(s′)− Ld(s, s′). This implies that lt+1(s′)− Ld(s, s′) ≥ h. Thus s ∈ St+1. Now consider s ∈ Ŝt. We known that\ns ∈ Rreach(Ŝt−1) ⊆ Rreach(Ŝt) by Lemma 8\nWe also know that s ∈ Rret(St, Ŝt−1). Since we just proved that St ⊆ St+1 and we assumed Ŝt−1 ⊆ Ŝt for the induction step, Lemma 7 allows us to say that s ∈ R ret (St+1, Ŝt). All together this allows us to complete the induction step by saying s ∈ Ŝt+1.\nLemma 10. S ⊆ R =⇒ Rsafe (S) ⊆ Rsafe (R).\nProof. Consider s ∈ Rsafe (S), we can say that:\n∃s′ ∈ S ⊆ R : r(z′)− − Ld(z, z′) ≥ h (9)\nThis means that s ∈ Rsafe (R)\nLemma 11. Given two sets S,R ⊆ S such that S ⊆ R, it holds that: R (S) ⊆ R (R).\nProof. We have to prove that:\ns ∈ (Rreach(S) ∩Rret(Rsafe (S), S)) =⇒ s ∈ (Rreach(R) ∩R ret (Rsafe (R), R)) (10)\nLet’s start by checking the reachability condition first:\ns ∈ Rreach(S) =⇒ s ∈ Rreach(R). by Lemma 8\nNow let’s focus on the recovery condition. We use Lemmas 7 and 10 to say that s ∈ Rret(Rsafe (S), S) implies that s ∈ Rret(Rsafe (R), R) and this completes the proof.\nLemma 12. Given two sets S,R ⊆ S such that S ⊆ R, the following holds: R (S) ⊆ R (R).\nProof. The result follows by repeatedly applying Lemma 11.\nLemma 13. Assume that r is sampled from a GP and that the measurement noise is bounded by σ for all t ≥ 1. If βt = 2 log ( |S|πk δ ) , where ∑ k≥1 πk = 1,πk > 0, then the following hold at least with probability 1− δ:\n∀t ≥ 1, ∀s ∈ S, |r(s)− µt−1(s)| ≤ β 1 2 t σt−1(s).\nProof. See Lemma 5.1 in [21].\nGiven the assumptions of Lemma 13, the following holds with probability at least 1− δ:\n∀t ≥ 1, ∀s ∈ S, r(s) ∈ Ct(s).\nProof. See Corollary 1 in [22]."
    }, {
      "heading" : "B Safety",
      "text" : "Lemma 14. For all t ≥ 1 and for all s ∈ Ŝt, ∃(a1, a2, . . . , ak) inducing (s0, s1, . . . , sk), such that s0 = s, sk ∈ S0 and si ∈ St,∀i = 0, . . . , k.\nProof. We use a recursive argument to prove this lemma. Since s ∈ St, we know that s ∈ R ret (St, Ŝt−1). Because of Lemmas 5 and 6 we know ∃(a1, . . . , aj), with j ≤ |S|, inducing s0, s1, . . . , sj such that s0 = s, si ∈ St, ∀i = 1, . . . , j−1 and sj ∈ Ŝt−1. Now we can build another sequence of actions that drives the system to some state in Ŝt−2 passing through St−1 ⊆ St starting from sj ∈ Ŝt−1. By applying repeatedly this procedure we can build a finite sequence of actions that drives the system to a state in S0 passing through St starting from s.\nLemma 15. For all t ≥ 1 and for all s ∈ Ŝt, ∃(a1, a2, . . . , ak) inducing (s0, s1, . . . , sk), such that: s0 ∈ S0, sk = s and si ∈ Ŝt,∀i = 0, . . . , k.\nProof. The proof is analogous to the the one we gave for lemma Lemma 14. The only difference is that here we need to use the reachability property of Ŝt instead of the recovery property of Ŝt.\nLemma 16. For all sstart, send ∈ Ŝt, ∃(a1, a2, . . . , aN ), with N ∈ N, inducing (s0, s1, . . . , sN ), such that s0 = sstart, sN = send and si ∈ St,∀i = 0, . . . , N .\nProof. By initialization of the safe seed we know that we can reach any point in S0 from any other point in S0 following a path that goes only through states in S0 ⊆ St. This observation, jointly with Lemma 14 and Lemma 15 completes the proof.\nLemma 17. For any t ≥ 0, the following holds with probability at least 1− δ: ∀s ∈ St, r(s) ≥ h.\nProof. Let’s prove this result by induction. By initialization we know that r(s) ≥ h for all s ∈ S0. For the induction step assume that for all s ∈ St−1 holds that r(s) ≥ h. For any s ∈ St, by definition, there exists z ∈ Ŝt−1 ⊆ St−1 such that\nh ≤ lt(z)− Ld(s, z), ≤ r(z)− Ld(s, z), by Lemma 13 ≤ r(s). by Lipschitz continuity\nThis relation holds with probability at least 1− δ because we used Lemma 13 to prove it.\nTheorem 2. Let (s0, s1, . . . , sk, . . .) be a state trajectory of a MDP with the following transition function, sk+1 = f(sk, ak). If the input trajectory is chosen according to our algorithm, then, with probability at least 1− δ, holds that r(sk) ≥ h,∀k ≥ 0.\nProof. Let’s denote as (st1, s t 2, . . . , s t k) the state trajectory of the system until the end of iteration t ≥ 0. We know from Lemma 16 that the sti ∈ St, ∀i = 1, . . . , k. Lemma 17 completes the proof as it allows us to say that r(sti) ≥ h, ∀i = 1, . . . , k with probability at least 1− δ."
    }, {
      "heading" : "C Completeness",
      "text" : "Lemma 18. For any t1 ≥ t0 ≥ 1, if Ŝt1 = Ŝt0 , then, ∀t such that t0 ≤ t ≤ t1, it holds that Gt+1 ⊆ Gt\nProof. Since Ŝt is not changing we are always computing the enlargement function over the same points. Therefore we only need to prove that the enlargement function is non increasing. We known from Lemma 3 that ut(s) is a non increasing function of t for all s ∈ S. Furthermore we know that (S \\ St) ⊇ (S \\ St+1) because of Lemma 9. Hence, the enlargement function is non increasing and the proof is complete.\nLemma 19. For any t1 ≥ t0 ≥ 1, if Ŝt1 = Ŝt0 , C1 = 8/log(1 + σ−2) and st = argmax s∈Gt wt(s), then, ∀t such that t0 ≤ t ≤ t1, it holds that wt(st) ≤ √ C1βtγt t−t0 .\nProof. See Lemma 5 in [22].\nFor any t ≥ 1, if C1 = 8/log(1+σ−2) and Tt is the smallest positive integer such that Ttβt+Ttγt+Tt ≥ C1 2 and St+Tt = St, then, for any s ∈ Gt+Tt it holds that wt+Tt(s) ≤\nProof. The proof is trivial because Tt was chosen to be the smallest integer for which the right hand side of the inequality proved in Lemma 19 is smaller or equal to .\nLemma 20. For any t ≥ 1, if R (S0) \\ Ŝt 6= ∅, then, R (Ŝt) \\ Ŝt 6= ∅.\nProof. For the sake of contradiction assume that R (Ŝt) \\ Ŝt = ∅. This implies R (Ŝt) ⊆ Ŝt. On the other hand, since Ŝt is included in all the sets whose intersection defines R (Ŝt), we know that, Ŝt ⊆ R (Ŝt). This implies that Ŝt = R (Ŝt). If we apply repeatedly the one step reachability operator on both sides of the equality we obtain R (Ŝt) = Ŝt. By Lemmas 3 and 12 we know that\nS0 = Ŝ0 ⊆ Ŝt =⇒ R (S0) ⊆ R (Ŝt) = Ŝt.\nThis contradicts the assumption that R (S0) \\ Ŝt 6= ∅.\nLemma 21. For any t ≥ 1, if R (S0) \\ Ŝt 6= ∅, then, with probability at least 1 − δ it holds that Ŝt ⊂ Ŝt+Tt .\nProof. By Lemma 20 we know that R (Ŝt) \\ Ŝt 6= ∅. This implies that ∃s ∈ R (Ŝt) \\ Ŝt. Therefore there exists a s′ ∈ Ŝt such that:\nr(s′)− − Ld(s, s′) ≥ h (11)\nFor the sake of contradiction assume that Ŝt+Tt = Ŝt. This means that s ∈ S \\ Ŝt+Tt and s′ ∈ Ŝt+Tt . Then we have:\nut+Tt(s ′)− Ld(s, s′) ≥ r(s′)− Ld(s, s′) by Lemma 13\n≥ r(s′)− − d(s, s′) (12) ≥ h by equation 11\nAssume, for the sake of contradiction, that s ∈ S \\ St+Tt . This means that s′ ∈ Gt+Tt . We know that for any t ≤ t̂ ≤ t + Tt holds that Ŝt̂ = Ŝt, because Ŝt = Ŝt+Tt and Ŝt ⊆ Ŝt+1 for all t ≥ 1. Therefore we have s′ ∈ Ŝt+Tt−1 such that:\nlt+Tt(s ′)− Ld(s, s′) ≥ lt+Tt(s′)− r(s′) + + h by equation 11\n≥ −wt+Tt(s′) + + h by Lemma 13 ≥ h by Lemma 19\nThis implies that s ∈ St+Tt , which is a contradiction. Thus we can say that s ∈ St+Tt . Now we want to focus on the recovery and reachability properties of s in order to reach the contradiction that s ∈ Ŝt+Tt . Since s ∈ R (Ŝt+Tt) \\ Ŝt+Tt we know that:\ns ∈ Rreach(Ŝt+Tt) = Rreach(Ŝt+Tt−1) (13)\nWe also know that s ∈ R (Ŝt+Tt) \\ Ŝt+Tt =⇒ s ∈ R ret\n(Rsafe (Ŝt+Tt), Ŝt+Tt). We want to use this fact to prove that s ∈ Rret(St+Tt , Ŝt+Tt−1). In order to do this, we intend to use the result from Lemma 7. We already know that Ŝt+Tt−1 = Ŝt+Tt . Therefore we only need to prove\nthat Rsafe (Ŝt+Tt) ⊆ St+Tt . For the sake of contradiction assume this is not true. This means ∃z ∈ Rsafe (Ŝt+Tt) \\ St+Tt . Therefore there exists a z′ ∈ Ŝt+Tt such that: r(z′)− − Ld(z′, z) ≥ h (14) Consequently:\nut+Tt(z ′)− Ld(z′, z) ≥ r(z′)− Ld(z′, z) by Lemma 13\n≥ r(z′)− − d(z′, z) (15) ≥ h by equation 14\nHence z′ ∈ Gt+Tt . Once again we can say there exists z′ ∈ St+Tt−1 such that: lt+Tt(z\n′)− Ld(z′, z) ≥ lt+Tt(z′)− r(z′) + + h by equation 11 ≥ −wt+Tt(z′) + + h by Lemma 13 ≥ h by Lemma 19\nTherefore z ∈ St+Tt . This is a contradiction. Therefore we can say that Rsafe (Ŝt+Tt) ⊆ St+Tt . Hence:\ns ∈ R (Ŝt+Tt) \\ Ŝt+Tt =⇒ s ∈ R ret\n(St+Tt , Ŝt+Tt−1) (16) In the end the fact that s ∈ St+Tt and (13) and (16) allow us to conclude that s ∈ Ŝt+Tt . This contradiction proves the theorem.\nLemma 22. ∀t ≥ 0, Ŝt ⊆ R0(S0) with probability at least 1− δ.\nProof. Proof by induction. We know that S0 ⊆ R0(S0) by definition. For the induction step assume that for some t ≥ 1 holds that Ŝt−1 ⊆ R0(S0). Our goal is to show that s ∈ Ŝt =⇒ s ∈ R0(S0). In order to this, we will try to show that s ∈ R0(Ŝt−1). We know that:\ns ∈ Ŝt =⇒ s ∈ Rreach(Ŝt−1) (17) Furthermore we can say that:\ns ∈ Ŝt =⇒ s ∈ R ret (St, Ŝt−1) (18)\nConsider s ∈ St. We know that ∃s′ ∈ Ŝt−1 such that: h ≤ lt(s′)− Ld(s, s′), (19) ≤ r(s′)− Ld(s, s′). by Lemma 13\nThis means s ∈ Rsafe0 (Ŝt−1), or, equivalently, that St ⊆ Rsafe0 (Ŝt−1). Hence, Lemma 7 allows us to say that R ret (St, Ŝt−1) ⊆ R ret (Rsafe0 (Ŝt−1), Ŝt−1). This result, together with (17), leads us to the conclusion that s ∈ R0(Ŝt−1). Since we assumed for the induction step that Ŝt−1 ⊆ R0(S0), we conclude that s ∈ R0(S0). This proves that s ∈ Ŝt =⇒ s ∈ R0(S0) and the induction step is complete.\nLemma 23. Let t∗ be the smallest integer such that t∗ ≥ |R0(S0)|Tt∗ , then there exists a t0 ≤ t∗ such that, with probability at least 1− δ holds that St0+Tt0 = St0 .\nProof. For the sake of contradiction assume that the opposite holds true: ∀t ≤ t∗, St ⊂ St+Tt . This implies that S0 ⊂ ST0 . Furthermore we know that Tt is increasing in t. Therefore 0 ≤ t∗ =⇒ T0 ≤ Tt∗ =⇒ ST0 ⊆ STt∗ . Now if |R0(S0)| ≥ 1 we know that:\nt∗ ≥ Tt∗ =⇒ Tt∗ ≥ TTt∗ =⇒ Tt∗ + TTt∗ ≤ 2Tt∗ =⇒ STt∗+TTt∗ ⊆ S2Tt∗\nThis justifies the following chain of inclusions: S0 ⊂ ST0 ⊆ STt∗ ⊂ STt∗+TTt∗ ⊆ S2Tt∗ ⊂ . . . This means that for any 0 ≤ k ≤ |R0(S0)| it holds that |SkTt∗ | > k. In particular, for k∗ = |R0(S0)| we have |Sk∗Tt∗ | > |R0(S0)|. This contradicts Lemma 22 (which holds true with probability at least 1− δ).\nLet t∗ be the smallest integer such that t ∗ βt∗γt∗ ≥ C1|R0(S0)| 2 , then, there is t0 ≤ t ∗ such that St0+Tt0 = St0 with probability at least 1− δ.\nProof. The proof consists in applying the definition of Tt to the condition of Lemma 23.\nTheorem 3. Let t∗ be the smallest integer such that t ∗ βt∗γt∗ ≥ C1|R0(S0)| 2 , with C1 = 8/log(1+σ −2), then, there is t0 ≤ t∗ such that R (S0) ⊆ St0 ⊆ R0(S0) with probability at least 1− δ.\nProof. Due to Lemma 23 we know that ∃t0 ≤ t∗ such that St0 = St0+Tt0 with probability at least 1 − δ. This implies that R (S0) \\ (St) = ∅ with probability at least 1 − δ because of Lemma 21. Therefore R (S0) ⊆ St. Furthermore we know that St ⊆ R0(S0) with probability at least 1 − δ because of Lemma 22 and this completes the proof."
    }, {
      "heading" : "D Main result",
      "text" : "Theorem 1. Assume that r is L-Lipschitz continuous and that the assumptions of Lemma 1 hold. Also, assume that S0 6= ∅, r(s) ≥ h for all s ∈ S0, and that for any two states, s, s′ ∈ S0, s′ ∈ Rret(S0, {s}). Choose βt as in (8). Let (s0, s1, . . . , sk, . . .) denote a state trajectory induced by Algorithm 1 on an MDP with transition function f(s, a). Then, with probability at least 1− δ, r(sk) ≥ h,∀k > 0.Moreover, let t∗ be the smallest integer such that t ∗\nβt∗γt∗ ≥ C |R0(S0)| 2 ,\nwith C = 8/log(1 + σ−2). Then, there exists a t0 ≤ t∗ such that, with probability at least 1− δ, R (S0) ⊆ Ŝt0 ⊆ R0(S0).\nProof. This is a direct consequence of Theorem 2 and Theorem 3."
    } ],
    "references" : [ {
      "title" : "Reachability-based safe learning with Gaussian processes",
      "author" : [ "Anayo K. Akametalu", "Shahab Kaynama", "Jaime F. Fisac", "Melanie N. Zeilinger", "Jeremy H. Gillula", "Claire J. Tomlin" ],
      "venue" : "In Proc. of the IEEE Conference on Decision and Control (CDC),",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2014
    }, {
      "title" : "A survey of robot learning from demonstration",
      "author" : [ "Brenna D. Argall", "Sonia Chernova", "Manuela Veloso", "Brett Browning" ],
      "venue" : "Robotics and Autonomous Systems,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2009
    }, {
      "title" : "Safe and robust learning control with Gaussian processes",
      "author" : [ "Felix Berkenkamp", "Angela P. Schoellig" ],
      "venue" : "In Proc. of the European Control Conference (ECC),",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2015
    }, {
      "title" : "Safe controller optimization for quadrotors with Gaussian processes",
      "author" : [ "Felix Berkenkamp", "Angela P. Schoellig", "Andreas Krause" ],
      "venue" : "In Proc. of the IEEE International Conference on Robotics and Automation (ICRA),",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2016
    }, {
      "title" : "Risk-sensitive and minimax control of discrete-time, finite-state Markov decision processes",
      "author" : [ "Stefano P. Coraluppi", "Steven I. Marcus" ],
      "venue" : null,
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 1999
    }, {
      "title" : "Safe exploration of state and action spaces in reinforcement learning",
      "author" : [ "Javier Garcia", "Fernando Fernández" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2012
    }, {
      "title" : "Risk-sensitive reinforcement learning applied to control under constraints",
      "author" : [ "Peter Geibel", "Fritz Wysotzki" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2005
    }, {
      "title" : "Posterior consistency of Gaussian process prior for nonparametric binary regression",
      "author" : [ "Subhashis Ghosal", "Anindya Roy" ],
      "venue" : "The Annals of Statistics,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2006
    }, {
      "title" : "Safe exploration for reinforcement learning",
      "author" : [ "Alexander Hans", "Daniel Schneegaß", "Anton Maximilian Schäfer", "Steffen Udluft" ],
      "venue" : "In Proc. of the European Symposium on Artificial Neural Networks (ESANN),",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2008
    }, {
      "title" : "Reinforcement learning in robotics: a survey",
      "author" : [ "Jens Kober", "J. Andrew Bagnell", "Jan Peters" ],
      "venue" : "The International Journal of Robotics Research,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2013
    }, {
      "title" : "Introduction: Mars Science Laboratory: The Next Generation of Mars Landers",
      "author" : [ "Mary Kae Lockwood" ],
      "venue" : "Journal of Spacecraft and Rockets,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2006
    }, {
      "title" : "Mars Reconnaissance Orbiter’s High Resolution Imaging Science Experiment (HiRISE)",
      "author" : [ "Alfred S. McEwen", "Eric M. Eliason", "James W. Bergstrom", "Nathan T. Bridges", "Candice J. Hansen", "W. Alan Delamere", "John A. Grant", "Virginia C. Gulick", "Kenneth E. Herkenhoff", "Laszlo Keszthelyi", "Randolph L. Kirk", "Michael T. Mellon", "Steven W. Squyres", "Nicolas Thomas", "Catherine M. Weitz" ],
      "venue" : "Journal of Geophysical Research: Planets,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2007
    }, {
      "title" : "Bayesian Approach to Global Optimization, volume 37 of Mathematics and Its Applications",
      "author" : [ "Jonas Mockus" ],
      "venue" : null,
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 1989
    }, {
      "title" : "Safe exploration in Markov decision processes",
      "author" : [ "Teodor Mihai Moldovan", "Pieter Abbeel" ],
      "venue" : "In Proc. of the International Conference on Machine Learning (ICML),",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2012
    }, {
      "title" : "Safe exploration techniques for reinforcement learning – an overview",
      "author" : [ "Martin Pecka", "Tomas Svoboda" ],
      "venue" : "In Modelling and Simulation for Autonomous Systems,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2014
    }, {
      "title" : "Gaussian processes for machine learning. Adaptive computation and machine learning",
      "author" : [ "Carl Edward Rasmussen", "Christopher K.I. Williams" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2006
    }, {
      "title" : "Learning Control in Robotics",
      "author" : [ "Stefan Schaal", "Christopher Atkeson" ],
      "venue" : "IEEE Robotics & Automation Magazine,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2010
    }, {
      "title" : "Learning with Kernels: Support Vector Machines, Regularization, Optimization, and Beyond",
      "author" : [ "Bernhard Schölkopf", "Alexander J. Smola" ],
      "venue" : null,
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2002
    }, {
      "title" : "Safe exploration for active learning with Gaussian processes",
      "author" : [ "Jens Schreiter", "Duy Nguyen-Tuong", "Mona Eberts", "Bastian Bischoff", "Heiner Markert", "Marc Toussaint" ],
      "venue" : "In Proc. of the European Conference on Machine Learning (ECML),",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2015
    }, {
      "title" : "Gaussian process optimization in the bandit setting: no regret and experimental design",
      "author" : [ "Niranjan Srinivas", "Andreas Krause", "Sham M. Kakade", "Matthias Seeger" ],
      "venue" : "In Proc. of the International Conference on Machine Learning (ICML),",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2010
    }, {
      "title" : "Safe exploration for optimization with Gaussian processes",
      "author" : [ "Yanan Sui", "Alkis Gotovos", "Joel Burdick", "Andreas Krause" ],
      "venue" : "In Proc. of the International Conference on Machine Learning (ICML),",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 9,
      "context" : "As a consequence, robots need to be able to learn and adapt to unknown environments autonomously [10, 2].",
      "startOffset" : 97,
      "endOffset" : 104
    }, {
      "referenceID" : 1,
      "context" : "As a consequence, robots need to be able to learn and adapt to unknown environments autonomously [10, 2].",
      "startOffset" : 97,
      "endOffset" : 104
    }, {
      "referenceID" : 16,
      "context" : "While exploration algorithms are known, safety is still an open problem in the development of such systems [18].",
      "startOffset" : 107,
      "endOffset" : 111
    }, {
      "referenceID" : 14,
      "context" : "Safe exploration is an open problem in the reinforcement learning community and several definitions of safety have been proposed [16].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 4,
      "context" : "In risk-sensitive reinforcement learning, the goal is to maximize the expected return for the worst case scenario [5].",
      "startOffset" : 114,
      "endOffset" : 117
    }, {
      "referenceID" : 6,
      "context" : "For example, Geibel and Wysotzki [7] define risk as the probability of driving the system to a previously known set of undesirable states.",
      "startOffset" : 33,
      "endOffset" : 36
    }, {
      "referenceID" : 5,
      "context" : "Garcia and Fernández [6] propose to ensure safety by means of a backup policy; that is, a policy that is known to be safe in advance.",
      "startOffset" : 21,
      "endOffset" : 24
    }, {
      "referenceID" : 8,
      "context" : "[9], where safety is defined in terms of a minimum reward, which is learned from data.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 13,
      "context" : "Moldovan and Abbeel [14] provide probabilistic safety guarantees at every time step by optimizing over ergodic policies; that is, policies that let the agent recover from any visited state.",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : "[1] use reachability analysis to ensure stability under the assumption of bounded disturbances.",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "The work in [3] uses robust control techniques in order to ensure robust stability for model uncertainties, while the uncertain model is improved.",
      "startOffset" : 12,
      "endOffset" : 15
    }, {
      "referenceID" : 12,
      "context" : "Another field that has recently considered safety is Bayesian optimization [13].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 19,
      "context" : "There, in order to find the global optimum of an a priori unknown function [21], regularity assumptions in form of a Gaussian process (GP) [17] are made.",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 15,
      "context" : "There, in order to find the global optimum of an a priori unknown function [21], regularity assumptions in form of a Gaussian process (GP) [17] are made.",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 20,
      "context" : "[22] and Schreiter et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[20], where the goal is to find the safely reachable optimum without violating an a priori unknown safety constraint at any evaluation.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "The method in [22] has the advantage of being sample efficient.",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 3,
      "context" : "It was applied to the field of robotics to safely optimize the controller parameters of a quadrotor vehicle [4].",
      "startOffset" : 108,
      "endOffset" : 111
    }, {
      "referenceID" : 20,
      "context" : "The main contribution consists of extending the work on safe Bayesian optimization in [22] from the bandit setting to MDPs.",
      "startOffset" : 86,
      "endOffset" : 90
    }, {
      "referenceID" : 13,
      "context" : "It enjoys similar safety guarantees in terms of ergodicity, the ability to return to the safe starting point, as presented in [14], but at a vastly reduced computational cost.",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 17,
      "context" : "In the following, we assume that S is endowed with a positive definite kernel function, k(·, ·), and that the function, r(·), has bounded norm in the associated Reproducing Kernel Hilbert Space (RKHS) [19].",
      "startOffset" : 201,
      "endOffset" : 205
    }, {
      "referenceID" : 15,
      "context" : "This assumption allows us to model r as a Gaussian Process (GP) [17], r(s) ∼ GP(μ(s), k(s, s′)).",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 19,
      "context" : "For many commonly used kernels, the GP assumption implies that the reward function is Lipschitz continuous with high probability [21, 8].",
      "startOffset" : 129,
      "endOffset" : 136
    }, {
      "referenceID" : 7,
      "context" : "For many commonly used kernels, the GP assumption implies that the reward function is Lipschitz continuous with high probability [21, 8].",
      "startOffset" : 129,
      "endOffset" : 136
    }, {
      "referenceID" : 19,
      "context" : "[21] in the multi-armed bandit setting.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 19,
      "context" : "More details on these bounds on γt can be found in [21].",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 19,
      "context" : "The choice of βt in (8) is justified by the following Lemma, which follows from Theorem 6 in [21]: Lemma 1.",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 13,
      "context" : "We consider the setting in [14], the exploration of the surface of Mars with a rover.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 10,
      "context" : "For the experiment, we consider the Mars Science Laboratory (MSL) [11], a rover deployed on Mars.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 11,
      "context" : "In our experiments we use digital terrain models of the surface of Mars from High Resolution Imaging Science Experiment (HiRISE), which have a resolution of one meter [12].",
      "startOffset" : 167,
      "endOffset" : 171
    }, {
      "referenceID" : 13,
      "context" : "As opposed to the experiments considered by Moldovan and Abbeel [14], we do not have to subsample or smoothen the data in order to achieve good exploration results.",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 13,
      "context" : "Therefore, every state in the MDP represents a d× d square area with d = 1m, as opposed to d = 20m in [14].",
      "startOffset" : 102,
      "endOffset" : 106
    }, {
      "referenceID" : 20,
      "context" : "Following the recommendations in [22], in our experiments we use the GP confidence intervals Qt(s) directly to determine the safe set St.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 13,
      "context" : "The same assumption is used in [14].",
      "startOffset" : 31,
      "endOffset" : 35
    }, {
      "referenceID" : 18,
      "context" : "In this setting the agent samples the most uncertain safe state transaction, which corresponds to the safe Bayesian optimization framework in [20].",
      "startOffset" : 142,
      "endOffset" : 146
    } ],
    "year" : 2016,
    "abstractText" : "In classical reinforcement learning, when exploring an environment, agents accept arbitrary short term loss for long term gain. This is infeasible for safety critical applications, such as robotics, where even a single unsafe action may cause system failure. In this paper, we address the problem of safely exploring finite Markov decision processes (MDP). We define safety in terms of an, a priori unknown, safety constraint that depends on states and actions. We aim to explore the MDP under this constraint, assuming that the unknown function satisfies regularity conditions expressed via a Gaussian process prior. We develop a novel algorithm for this task and prove that it is able to completely explore the safely reachable part of the MDP without violating the safety constraint. To achieve this, it cautiously explores safe states and actions in order to gain statistical confidence about the safety of unvisited state-action pairs from noisy observations collected while navigating the environment. Moreover, the algorithm explicitly considers reachability when exploring the MDP, ensuring that it does not get stuck in any state with no safe way out. We demonstrate our method on digital terrain models for the task of exploring an unknown map with a rover.",
    "creator" : "LaTeX with hyperref package"
  }
}