{
  "name" : "1406.0303.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Superposition Calculus for Abductive Reasoning",
    "authors" : [ "M. Echenim" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "to generate consequences of sets of first-order axioms. This approach is proven to be sound and deductive-complete in the presence of redundancy elimination rules, provided the considered consequences are built on a given finite set of ground terms, represented by constant symbols. In contrast to other approaches, most existing results about the termination of the Superposition calculus can be carried over to our procedure. This ensures in particular that the calculus is terminating for many theories of interest to the SMT community."
    }, {
      "heading" : "1 Introduction",
      "text" : "The verification of complex systems is generally based on proving the validity, or, dually, the satisfiability of a logical formula. A standard practice consists in translating the behavior of the system to be verified into a logical formula, and proving that the negation of the formula is unsatisfiable. These formulæ may be domain-specific, so that it is only necessary to test the satisfiability of the formula modulo some background theory, whence the name Satisfiability Modulo Theories problems, or SMT problems. If the formula is actually satisfiable, this means the system is not error-free, and any model can be viewed as a trace that generates an error. The models of a satisfiable formula can therefore help the designers of the system guess the origin of the errors and deduce how they can be corrected; this is the main reason for example why state-of-the-art SMT solvers feature automated model building tools (see for instance Caferra, Leitsch, and Peltier, 2004). However, this approach is not always satisfactory. First, there is the risk of an information overkill: indeed, the generated model may be very large and complex, and discovering the origin of the error may require a long and difficult analysis. Second, the model may be too specific, in the sense that it only corresponds to one particular execution of the system and that dismissing this single execution may not be sufficient to fix the system. Also, there are generally many interpretations on different domains that satisfy the formula. In order to understand where the error(s) may come from, it is generally necessary\nar X\niv :1\n40 6.\n03 03\nv2 [\ncs .L\nO ]\n1 3\nJu l 2\nto analyze all of these models and to identify common patterns. This leaves the user with the burden of having to infer the general property that can rule out all the undesired behaviors. A more useful and informative solution would be to directly infer the missing axioms, or hypotheses, that can be added in order to ensure the unsatisfiability of the input formula. These axioms can be viewed as sufficient conditions ensuring that the system is valid. Such conditions must be plausible and economical: for instance, explanations that contradict the axioms of the considered theories are obviously irrelevant.\nIn this paper, we present what is, to the best of our knowledge, a novel approach to this debugging problem: we argue that rather than studying one or several models of a formula, more valuable information can be extracted from the properties that hold in all the models of the formula. For example, consider the theory of arrays, which is axiomatized as follows (as introduced by McCarthy, 1962):\n∀x, z, v. select(store(x, z, v), z) ' v, (1) ∀x, z, w, v. z ' w ∨ select(store(x, z, v), w) ' select(x,w). (2)\nThese axioms state that if element v is inserted into array x at position z, then the resulting array contains v at position z, and the same elements as in x elsewhere. Assume that to verify that the order in which elements are inserted into a given array does not matter, the satisfiability of the following formula is tested (see also Figure 1):\nselect(store(store(a, i, b), j, c), k) 6' select(store(store(a, j, c), i, b), k).\nThis formula asserts that there is a position k that holds different values in the array obtained from a by first inserting element b at position i and then element c at position j, and in the array obtained from a by first inserting element c at position j and then element b at position i. It turns out that this formula is actually satisfiable, which in this case means that some hypotheses are missing. State-of-the-art SMT solvers such as Yices (Dutertre and de Moura, 2006) or Z3 (de Moura and Bjørner, 2008) can help find out what hypotheses are missing by outputting a model of the formula. In this case, Yices outputs (= b 1) (= c 3) (= i 2) (= k 2) (= j 2), and for this simple example, such a model may be sufficient to quickly understand where the error comes from. However, a\nsimpler and more natural way to determine what hypotheses are missing would be to have a tool that, when fed the formula above, outputs i ' j ∧ b 6' c, stating that the formula can only be true when elements b and c are distinct, and are inserted at the same position in array a. This information permits to know immediately what additional hypotheses must be made for the formula to be unsatisfiable. In this example, there are two possible hypotheses that can be added: i 6' j or b ' c.\nWe investigate what information should be provided to the user and how it can be obtained, by distinguishing a set of ground terms on which additional hypotheses are allowed to be made. These terms may be represented by a particular set of constant symbols, called abducible constants or simply abducibles, and the problem boils down to determining what ground clauses containing only abducible constants are logically entailed by the formula under consideration, since the negation of any of these clauses can be viewed as a set of additional hypotheses that make the formula unsatisfiable. Indeed, by duality, computing implicants (or explanations) of a formula φ is equivalent to computing implicates (i.e., logical consequences) of ¬φ. In order to compute such implicates, we devise a variant of the Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) that is deductive-complete for the considered set of abducible constants, i.e., that can generate all the clauses built on abducible constants using finite set of predicate symbols including ' that are logical consequences of the input clause set (up to redundancy). Our procedure is defined by enriching the standard calculus with some new mechanisms allowing the assertion of relevant hypotheses during the proof search. These additional hypotheses are stored as constraints associated with the clauses and are propagated along the derivations. If the empty clause can be generated under a conjunction of hypotheses X , then the conjunction of the original formula and X is unsatisfiable. An essential feature of this approach is that the conditions are not asserted arbitrarily or eagerly, using a generate-and-test approach (which would be inefficient): instead they are discovered on a need basis, either by considering residual equations of unification failures (for positive hypotheses) or by negating some of the literals occurring in the clauses (for negative hypotheses).\nRelated Work The generation of implicants (or, by duality, of implicates) of logical formulæ has many applications in system verification and artificial intelligence, and this problem has been thoroughly investigated in the context of propositional logic. The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011). These methods mainly focus on the efficient representation of information, and develop compact ways of storing and manipulating huge sets of implicates.\nIn contrast, the approaches handling abductive reasoning in first-order or equational logic are very scarce. Implicates can be generated automatically\nfrom sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formulæ that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories. This approach is closer to ours, since it is based on the Superposition calculus, hence handles equality in an efficient way; however it is very focused: indeed, it is well-known that the Superposition calculus is not deductive-complete in general, for instance it cannot generate the clause a 6' b from the clause f(a) 6' f(b), although f(a) 6' f(b) |= a 6' b.\nWhile the previous approaches rely on usual complete proof procedures for first-order logic, more recent work builds on the recent developments and progresses in the field of Satisfiability Modulo Theories by devising algorithms relying on theory-specific decision procedures. Sofronie-Stokkermans (2010, 2013) devises a technique for generating abductive explanations in local extensions of decidable theories. The approach reduces the considered problem to a formula in the basic theory by instantiating the axioms of the extension. Dillig, Dillig, McMillan, and Aiken (2012) generate an incomplete set of implicants of formulæ interpreted in decidable theories by combining quantifier-elimination (for discarding useless variables) with model building tools (to construct sufficient conditions for satisfiability). In contrast to these approaches, our method is proof-theoretic, hence it is generic and self-sufficient. The drawback is that it requires the adaptation of usual theorem provers instead of using them as black boxes (see also Example 52 for a comparison of our method with the simplification technique devised by Dillig et al (2012)).\nWernhard (2013) proposes a method to derive abductive explanations from first-order logical programs, under several distinct non-classical semantics, using a reduction to second-order quantifier-elimination. Both the considered framework and the proposed techniques completely depart from our work.\nOrganization of the Paper The rest of the paper is structured as follows. In Section 2 we review basic definitions and adapt usual results to our framework. In Section 3 the new Superposition calculus SA≺sel is presented, and it is shown in Section 4 that it is deductive-complete for ground clauses built on the set of abducible constants. In Section 5 some refinements of the calculus are presented, aiming at more efficiency. In Section 6, we show that most termination results holding for the usual Superposition calculus also apply to SA≺sel. The present paper is a thoroughly expanded and revised version of (Echenim and Peltier, 2012). See Section 5.2 for more details on the relationship of SA≺sel with the calculus in (Echenim and Peltier, 2012)."
    }, {
      "heading" : "2 Preliminaries",
      "text" : ""
    }, {
      "heading" : "2.1 Basic Definitions",
      "text" : "The set of terms is built as usual on a set of function symbols F including a set of predicate symbols P, containing in particular a special constant >, and a set of variables V. Every symbol f ∈ F is mapped to a unique arity ar(f) ∈ N. The set Fn is the set of function symbols of arity n; an element of F0 is a constant. A term whose head is in P is boolean.\nAn atom (or equation) is an unordered pair of terms, written t ' s, where t and s are terms. A literal is either an atom or the negation of an atom (i.e., a disequation), written t 6' s. For every literal l, we denote by lc the complementary literal of l, which is defined as follows: (t ' s)c def= t 6' s and (t 6' s)c def= t ' s. We use the notation t ./ s to denote a literal of the form t ' s or t 6' s, and t 6./ s then denotes the complementary literal of t ./ s. As usual, a non-equational atom p(~t) where p ∈ P is encoded as an equation p(~t) ' >. For readability, such an equation is sometimes written p(~t), and p(~t) 6' > can be written ¬p(~t). A clause is a finite multiset of literals, sometimes written as a disjunction. The empty clause is denoted by 2. For technical reasons, we assume that the predicate symbols only occur in atoms of the form t ' >, where t 6= > (literals of the form > 6' > can be removed from the clauses and clauses containing a literal > ' > can be dismissed; equations of the form p(~t) = q(~s) with p, q ∈ P \\ {>} are forbidden). For every clause C = {l1, . . . , ln}, Cc denotes the set of unit clauses {{lci} | i ∈ [1, n]} and for every set of unit clauses S = {{li} | i ∈ [1, n]}, Sc denotes the clause {lc1, . . . , lcn}. Throughout the paper, we assume that ≺ denotes some fixed reduction ordering on terms (see, e.g., Baader and Nipkow, 1998) such that > ≺ t, for all terms t 6= >, extended to atoms, literals and clauses as usual1.\nThe set of variables occurring in an expression (term, atom, literal, clause) E is denoted by var(E). If var(E) = ∅ then E is ground. A substitution is a function mapping variables to terms. For every term t and for every substitution\n1The literals t ' s and t 6' s are ordered as {{t}, {s}} and {{t, s}}, respectively.\nσ, we denote by tσ the term obtained from t by replacing every variable x by its image w.r.t. σ. The domain of a substitution is the set of variables x such that xσ 6= x. A substitution σ is ground if for every x in the domain of σ, xσ is ground.\nA position is a finite sequence of positive integers. A position p occurs in a term t if either p = ε or if t = f(t1, . . . , tn), p = i.q with i ∈ [1, n] and q is a position in ti. If p is a position in t, the terms t|p and t[s]p are defined as follows: t|ε def = t, t[s]ε def = s, f(t1, . . . , tn)|i.q def = (ti)|q and f(t1, . . . , tn)[s]i.q def = f(t1, . . . , ti−1, ti[s]q, ti+1, . . . , tn). Given a set of constants E, a literal t ./ s is E-flat if either t, s ∈ V ∪ E or t = p(t1, . . . , tn), s = > and t1, . . . , tn ∈ V ∪ E. A clause is E-flat if all its literals are E-flat. The set of E-flat clauses is denoted by Cflat(E). A clause is flat if it is F0-flat and elementary if it is A-flat and contains no symbol in P (in other words, every literal is of the form a ./ b with a, b ∈ V ∪ A).\nAn interpretation is a congruence relation on ground terms. An interpretation I validates a clause C if for all ground substitutions σ of domain var(C) there exists l ∈ C such that either l = (t ' s) and (l, s)σ ∈ I, or l = (t 6' s) and (l, s)σ 6∈ I.\n2.2 Abducible Constants and A-Sets In this section we introduce the notion of an A-set, that provides a convenient way of representing partial interpretations defined on a particular set of constant symbols. Let A ⊆ F0 be a set of constants, called the abducible constants. The set A is fixed by the user and contains all constants on which the abducible formulæ can be constructed. We assume that f(~t) a, for all a ∈ A and f 6∈ A, and that q(t1, . . . , tn) p(a1, . . . , an) if a1, . . . , an ∈ A, p, q are predicate symbols and ∃i ∈ [1, n] ti a1, . . . , an.\nDefinition 1 An A-set is a set of A-flat literals X satisfying the following properties.\n• If L ∈ X and L is not ground then L is negative or of the form p(t1, . . . , tn) ' >.\n• If {L[a]p, a ' b} ⊆ X , where a, b 6= >, then L[b]p ∈ X .\n• a ' a ∈ X , for all a ∈ A.\nAn A-set X is positive if it only contains positive literals, and complete if for every ground A-flat atom A, X contains either A or ¬A.\nNote that all elementary positive literals in X must be ground whereas negative or non elementary literals possibly contain variables. . Informally, a satisfiable A-set can be viewed as a partial interpretation on the constant symbols in A. The positive elementary literals in X define an equivalence relation between elements on A and the negative elementary literals specify the equivalence classes that are known to be distinct. Literals of the form p(t1, . . . , tn) ./ >\nspecify the interpretation of predicate symbols on constants of A. Variables correspond to unknown (or unspecified) constant symbols in A. Complete Asets are total interpretations on A.\nThis definition of A-sets is given for theoretical purposes only: in practice, they can be more conveniently represented by a set of oriented equations of the form {ai ' bi | i ∈ [1, n]}, where ∀i ∈ [1, n] ai, bi ∈ A, ai bi and i 6= j ⇒ ai 6= aj , together with a set of irreducible literals of the form c 6' d or p(c1, . . . , cn) ./ >, where ∀i ∈ [1, n], c, d, c1, . . . , cn 6= ai. When convenient, we may represent an A-set by a set X of equations and disequations, with the intended meaning that we are actually referring to the smallest A-set X that contains X.\nExample 2 Let A = {a, b, c, d} and x ∈ V. Then the set\nX = {a ' a, b ' b, c ' c, d ' d, e ' e, a ' b, c 6' a, c 6' b, d 6' x}\nis an A-set. Assuming an ordering such that a b c d, it can be more concisely represented by {a ' b, c 6' b, d 6' x}. X defines a partial interpretation in which a, b are known to be equal and distinct from c, while d is distinct from some unspecified constant x (x can represent a, b, c or e – if x represents d then the set is unsatisfiable). The interpretation is only partial since it can be extended into a total interpretation that satisfies either a ' d or a 6' d.\nDefinition 3 For every A-set X and for every expression (term, atom, literal, clause or clause set) E, we denote by E↓X the expression obtained from E by replacing every constant a ∈ A in E by the smallest (according to ≺) constant b in A such that a ' b ∈ X . We write t ∼XA s iff t↓X = s↓X and t ∼A s iff there exists an A-set X such that t ∼XA s. This definition is extended to substitutions: we write σ = θ↓X if xσ = (xθ)↓X and σ ∼XA θ if for all x ∈ dom(σ) ∪ dom(θ), xσ ∼XA xθ.\nProposition 4 Let C be a clause, σ be a substitution and X be an A-set. If (Cσ)↓X is A-flat (resp. elementary), then so is C.\nProof. 1 The contrapositive is obvious: if C is not A-flat, then it contains a non-boolean term t that is not in A∪V. But then, neither tσ nor tσ↓X can be in A ∪ V, and (Cσ)↓X cannot be A-flat. The reasoning is similar for elementary clauses.\n2.3 A-Unification A-unification is an extension of unification that, given two terms t and s, aims at computing a substitution σ such that tσ ∼A sσ, meaning that tσ and sσ are equal up to a renaming of constants in A. The set of necessary constant renamings is collected and stored in a positive A-set. This set corresponds exactly to residual (non-solvable) equations obtained when applying standard unification algorithms.\nExample 5 The terms f(a, b) and f(x, x) are not unifiable in the standard sense, but they are A-unifiable. The substitution σ : {x 7→ a} is an A-unifier of these two terms, together with the A-set {a ' a, b ' b, a ' b}.\nDefinition 6 An A-substitution is a pair (σ,X ) where σ is a substitution and X is an A-set containing only equations between elements of A. An A-substitution (σ,X ) is an A-unifier of an equation t ' s iff tσ ∼XA sσ. Two terms admitting an A-unifier are A-unifiable.\nIntuitively, if (σ,X ) is an A-unifier of an equation t ' s, then the equations in X can be used to reduce t and s to terms that are unifiable in the standard sense.\nDefinition 7 An A-substitution (σ,X ) is more general than an A-substitution (σ′,X ′), written (σ,X ) ≥A (σ′,X ′), if there exists a (standard) substitution θ such that the two following conditions hold:\n• X ⊆ X ′.\n• For every x ∈ V, xσ′ ∼X ′A xσθ.\nWe write (σ,X ) ∼A (σ′,X ′) if (σ,X ) ≥A (σ′,X ′) and (σ′,X ′) ≥A (σ,X ).\nExample 8 Let A = {a, b, c}, and consider the following substitutions and Asets:\nσ = {x 7→ a, y 7→ c, z 7→ f(a, z′)} and X = {a ' c} σ′ = {x 7→ a, y 7→ b, z 7→ f(b, b), } and X ′ = {a ' b, b ' c} .\nBy letting θ = {z′ 7→ b}, it is simple to verify that (σ,X ) ≥A (σ′,X ′).\nNote that most general A-unifiers are not unique modulo variable renamings. For example, the equation f(g(a), g(b)) ' f(g(x), g(y)) admits several most general unifiers, including ({x→ a, y → b}, {a ' b}), ({x→ b, y → a}, {a ' b}), . . . which are of course all ∼A-equivalent. A-unifiers can be computed by a slight adaptation of the usual unification algorithm (see Appendix A for details)."
    }, {
      "heading" : "3 A-Superposition Calculus",
      "text" : "In this section we define an extension of the standard Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) with which it is possible to generate all A-flat implicates of a considered clause set. The calculus handles constrained clauses, called A-clauses, the constraint part of an A-clause being an A-set containing all the equations and disequations needed to derive the corresponding non-constraint part from the original clause set. Unification is replaced by A-unification, and the A-set of the generated Aunifier is appended to the constraint of the conclusion of the rule. Furthermore, an additional inference rule, called the A-Assertion rule, is introduced in order to add disequations to the constraints.\nDefinition 9 An A-clause is a pair [C | X ] where C is a clause and X is an A-set. If X = ∅, then we may write C instead of [C |∅].\nIn what follows, we first define the ordering and selection function the calculus is based upon before presenting the inference rules and redundancy criterion of the A-Superposition calculus. We conclude this section by showing that the calculus is sound."
    }, {
      "heading" : "3.1 Ordering and Selection Function",
      "text" : "We begin by introducing some additional notations and terminology.\nDefinition 10 For all terms t, s, we write t A s if for every A-set X and ground substitution σ, we have tσ↓X sσ↓X . This ordering is extended to atoms, literals and clauses in a similar way to ≺.\nIntuitively t A s means that t is always greater than s, regardless of the names of the constants in A.\nExample 11 If a, b, c ∈ A and f(x) a b c, then we have f(b) A a, but f(a) 6 A f(b), since f(a)↓{a'c} = f(c) ≺ f(b) = f(b)↓{a'c}.\nDefinition 12 A substitution σ is X -pure if for all variables x ∈ var(X ), xσ is either a variable or a constant in A.\nDefinition 13 A function sel is a selection function for an ordering > iff sel maps every clause C to a set of literals in C such that sel(C) either contains a negative literal or contains all literals that are >-maximal in C.\nWe consider a selection function sel for the ordering A, that satisfies the following assumptions.\nAssumption 14 The function sel is stable under A-substitutions, i.e., for every clause C, for every literal l ∈ C and for every A-substitution (η,X ), if lη↓X ∈ sel(Cη↓X ), then l ∈ sel(C).\nAssumption 15 For every A-clause C, if sel(C) contains a literal of the form p(~t) = > then sel(C) contains no negative literal of the form a 6' b with a, b ∈ V ∪ A.\nAssumption 15 can always be fulfilled since negative literals can be selected arbitrarily."
    }, {
      "heading" : "3.2 Inference Rules",
      "text" : "The calculus SA≺sel is defined by the rules below. The standard Superposition calculus (denoted by SP≺sel) coincides with SA ≺ sel if A = ∅.\nRemark 16 Following our convention, in all rules, if X , Y are two A-sets, then X ∪Y does not denote the mere union of X and Y, but rather the smallest A-set containing both X and Y (it is obtained by transitive closure from the union of X and Y). For example, if {a, b, c} ⊆ A with a b c, X = {a ' a, b ' b, c ' c, a ' b} and Y = {a ' a, b ' b, c ' c, a ' c}, then X ∪ Y denotes the A-set {a ' a, b ' b, c ' c, a ' b, a ' c, b ' c}. Similarly, if X is an A-set and σ is an X -pure substitution, then Xσ denotes the smallest A-set containing Xσ. For instance, if X = {a ' a, b ' b, a ' b, x 6' y} and σ = {x 7→ a}, then Xσ = {a ' a, b ' b, a ' b, a 6' y, b 6' y}.\nA-Superposition\n[C ∨ t ./ s |X ], [D ∨ u ' v |Y] [C ∨D ∨ t[v]p ./ s |X ∪ Y ∪ E ]σ\nIf ./∈ {', 6'}, (σ, E) is an (X ∪ Y)-pure most general A-unifier of u and t|p, vσ 6 A uσ, sσ 6 A tσ, (t ./ s)σ ∈ sel((C ∨ t ./ s)σ), (u ' v)σ ∈ sel((D ∨ u ' v)σ) and if t|p is a variable then t|p occurs in X .\nWe shall refer to the left and right premises of the inference rule as the into and from premises, respectively. The main difference with the usual Superposition rule (besides the replacement of by A and of unifiers by A-unifiers) is that superposition into a variable is permitted, provided the considered variable occurs in the constraint part of the clause. The reason is that these do not actually represent variables in the usual sense, but rather placeholders for (unknown) constants (see also Example 41).\nBy definition of the calculus, variables can only occur in the constraints if the A-Assertion rule (see below) is applied on a non-ground literal. This is the case because, by definition of A-unification, the other rules add only ground equations into the constraints. Furthermore, by definition, a non-ground literal can be added to the constraints only if the considered clause is variable-eligible, i.e. contains a selected literal of the form x ' t, where x 6≺ t. This cannot happen if the clause set is variable-inactive (Armando et al, 2009). However, there exist theories of interest that are not variable-inactive, for instance the theory of arrays with axioms for constant arrays (e.g., ∀x, select(t, x) ' c).\nNote that the rule applies if t and u are of the form p(~t) ./ > and p(~s) ' > (with p = ε), in which case t[v]p ./ s is of the form > ./ >. If ./ is ' then the A-clause is a tautology and can be deleted, and if ./ is 6' then the literal > 6' > is deleted from the clause as explained before. The rule is essentially equivalent to Ordered Resolution in this case (see for instance Leitsch, 1997).\nA-Reflection [C ∨ t 6' s |X ] [C |X ∪ E ]σ\nIf (σ, E) is an X -pure most general A-unifier of t and s and (t 6' s)σ ∈ sel((C ∨ t 6' s)σ).\nEquational A-Factorization\n[C ∨ t ' s ∨ u ' v |X ] [C ∨ s 6' v ∨ t ' s |X ∪ E ]σ\nIf (σ, E) is an X -pure most general A-unifier of t and u, sσ 6 A tσ, vσ 6 A uσ and (t ' s)σ ∈ sel((C ∨ t ' s ∨ u ' v)σ).\nFor technical convenience, we assume that s 6' v is omitted in the conclusion if sσ = vσ.\nA-Assertion [t ' s ∨ C |X ]\n[C |X ∪ {t 6' s}]\nIf t, s ∈ A ∪ V, t ' s ∈ sel(t ' s ∨ C) and A 6= ∅.\n[p(t1, . . . , tn) ./ > ∨ C |X ] [C |X ∪ {p(t1, . . . , tn) 6./ >}]\nIf t1, . . . , tn ∈ A ∪ V, p(t1, . . . , tn) ./ > ∈ sel(t ' s ∨ C) and A 6= ∅.\nA-Substitutivity Rule\n[t1 ' s1 ∨ C1 |X1] . . . [tn ' sn ∨ Cn |Xn] [p(t1, . . . , tn) ./ > ∨ C1 ∨ · · · ∨ Cn |{p(s1, . . . , sn) ./ >} ∪ ⋃n i=1 Xi]\nThe rule can be applied also by replacing some of the premisses [ti ' si∨Ci |Xi] by variants of the Reflexivity axiom x ' x (note that if all premisses are of this form then the conclusion is a tautology)."
    }, {
      "heading" : "3.3 Soundness",
      "text" : "The interpretation of an A-clause is defined as a logical implication:\nDefinition 17 An interpretation I validates an A-clause [C | X ] iff for every X -pure ground substitution σ of domain var(C) ∪ var(X ), either I 6|= Xσ or I |= Cσ.\nIf I |= [C |X ] for all interpretations I, then [C |X ] is a tautology. In particular, this property holds if X is unsatisfiable, if C↓X contains two complementary literals or a literal of the form t ' t, or if all the literals in C occurs in X .\nTheorem 18 Let S be a set of A-clauses. If C is generated from S by one of the rules of SA≺sel then S |= C.\nProof. 2 It suffices to prove that all the rules are sound, i.e., that the conclusion of the rule is a logical consequence of the premises. This is due to the fact that if (σ, E) is an A-unifier of t ' s, then the A-clause [tσ ' sσ | E ] is valid in all interpretations. Then the proof follows by a straightforward inspection of the rules, as in the usual case."
    }, {
      "heading" : "3.4 Redundancy",
      "text" : "We now adapt the standard redundancy criterion to A-clauses. An A-clause is quasi-positive if the only negative literals occurring in it are of the form p(~t) 6' >.\nDefinition 19 An A-clause [C | X ] is A-redundant in a set of A-clauses S if either [C | X ] is a tautology, or for every ground substitution θ of the variables in [C | X ] such that X θ is a satisfiable A-set, one of the following conditions hold.\n• There exists an A-clause [D |Y] and a substitution σ such that Dσ ⊆ Cθ and Yσ ⊆ X θ.\n• If A = ∅ or Cθ is not both A-flat and quasi-positive, then there exist A-clauses [Di |Yi] and substitutions σi (1 ≤ i ≤ n), such that:\n– Yiσi ⊆ X θ for all i = 1, . . . , n, – X θ,D1σ1, . . . , Dnσn |= Cθ, – Cθ A D1σ1, . . . , Dnσn.\nWhen applied to standard clauses (with A = ∅), this notion of redundancy coincides with the usual criterion (see for instance Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001).\nIt is easy to check that the standard redundancy detection rules such as subsumption, tautology deletion or equational simplification, are particular cases of this redundancy criterion. Note that the second item in Definition 19 is similar to the usual redundancy criterion of the Superposition calculus (see, e.g, Bachmair and Ganzinger, 1994), with the following differences: (i) the entire constraint part of the considered A-clause may be used to infer the clausal part, disregarding any ordering condition, (ii) the condition only applies to clauses that are not both A-flat and quasi-positive. For the clauses that are A-flat and quasi-positive, redundancy testing is limited to tautology deletion and subsumption (this is necessary to ensure completeness, see Remark 27).\nExample 20 Let A = {a, b, c}. The A-clause [a 6' c ∨ b 6' c ∨ f(x) ' d |a 6' b] is A-redundant in any set S, since for all ground substitutions θ, a 6' b |= (a 6' c ∨ b 6' c ∨ f(x) ' d)θ.\nThe A-clause [f(a, b) ' c ∨ g(a) ' d | a 6' b] is A-redundant in {f(a, x) ' c∨a ' b}. Indeed, let σ = {x 7→ b}, then a 6' b, f(a, x)σ ' c∨a ' b |= f(a, b) ' c ∨ g(a) ' d and f(a, b) ' c ∨ g(a) ' d A f(a, x)σ ' c ∨ a ' b.\nThe following result is a straightforward consequence of Definition 19.\nProposition 21 If [C |X ] is redundant in a set S, then for any A-substitution (σ,Y), [Cσ |X ∪ Y] is also redundant in S.\nDefinition 22 A set S is SA≺sel-saturated if every A-clause that can be derived from A-clauses in S by a rule in SA≺sel is redundant in S.\nExamples\nWe provide simple application examples.\nExample 23 Let S = {g(f(x)) ' d, f(a) ' a, g(b) ' b, d ' c}. Assume that A = {a, b, c}. By applying the A-Superposition rule on the terms f(x) and f(a), we derive the clause g(a) ' d (note that this application of the rule is equivalent to the usual one). Then the A-Superposition rule can be applied again on the terms g(a) and g(b). The unification yields the constraints a ' b, hence the following A-clause is derived: [b ' d | a ' b]. The Assertion rule cannot be applied on b ' d, since this literal is not A-flat. Instead,the application of the A-Superposition rule on the term d (note that we must have d b, c since d 6∈ A and b, c ∈ A) yields: [b ' c | a ' b]. Finally, the Assertion rule can be applied on b ' c since this literal is A-flat, thus generating [2 | b 6' c ∧ a ' b]. This A-clause is equivalent to the clause b ' c∨a 6' b, and we have S |= b ' c∨a 6' b.\nThe second example involves predicate symbols.\nExample 24 We consider two functions f and g such that f and y 7→ g(x, y) are increasing, together with abducible constants a, b, i and j. The aim is to determine under which conditions the property f(g(a, i)) ≤ f(g(b, j)) holds. The problem is formalized as follows (where t ≤ s stands for (t ≤ s) ' > and <∈ P, x, y, u ∈ V): S = {x 6≤ y ∨ f(x) ≤ f(y), x 6≤ y ∨ g(u, x) ≤ g(u, y), f(g(a, i)) 6≤ f(g(b, j))}. For conciseness, the axioms corresponding to ≤ (e.g., transitivity) are omitted since they play no rôle in our context.\nThe Superposition rule applies on the first and last clauses, yielding g(a, i) 6≤ g(b, j). Then the rule applies again from the latter clause into the second one, and it generates: [i 6≤ j | {a ' b}]. Finally the A-Assertion rule yields the Aclause: [2 | {i ≤ j, a ' b}], meaning that the desired property is fulfilled if i ≤ j and a ' b hold.\nThe A-Assertion rule is necessary to guarantee deductive completeness, as shown in the example below.\nExample 25 Consider the (satisfiable) clause set: S def= {y ' x ∨ f(x, x, y) ' a, f(a, b, c) 6' a}, where A def= {a, b, c} and x, y are variables. It is simple to verify that S |= a 6' b ∨ c ' a, and the calculus is designed to generate from S a clause of the form [2 | X ], where ¬X ≡ a 6' b ∨ c ' a. In order to generate such a clause, it is clear that one has to unify f(x, x, y) and f(a, b, c), since the unification of f(a, b, c) and a leads to an immediate failure, so that the Reflection rule is not applicable. This is feasible only if the condition a ' b is added to the constraints of the obtained clause, yielding a constrained clause of the form: [c ' a | a ' b]. The literal c ' a is deleted using the A-Assertion rule, by appending the disequation c 6' a to the constraints, thus obtaining the required A-clause: {[2 |a ' b, c 6' a]}.\nThe last example shows that the A-Substitutivity rule is also needed for completeness.\nExample 26 Consider the clause set: S def= {a ' b}. It is clear that S |= p(a) ' >∨p(b) 6' > for any predicate symbol p of arity 1, but [2 |{p(a) 6' >, p(b) ' >}] cannot be generated without the help of the A-Substitutivity rule. The above implicate is indeed obtained as follows: The A-Substitutivity rule generates the A-clause [p(x) ' > | p(x) ' >], then the A-Superposition rule applies from a ' b, yielding [p(a) ' > | p(b) ' >], and the desired result is obtained by applying the A-Assertion rule. Note that the equation p(a) ' p(b) does not need to be inferred in our context since predicate symbols are allowed only in atoms of the form t ' >. Considering implicates built on arbitrary function symbols (with nested applications) would lead to divergence since, e.g., an infinite number of clauses of the form fn(a) ' fn(b) (with n ∈ N) could be derived from the above clause.\nRemark 27 The previous example also shows the importance of the restriction on the redundancy criterion. Indeed, if the criterion is relaxed by removing the condition “Cθ is not A-flat and quasi-positive” in the second item of Definition 19, then the A-clause [p(a) ' > | p(b) ' >] is redundant in S (since a ' b ≺ p(a) ' > and a ' b, p(b) ' > |= p(a) ' >). Consequently no non redundant inferences apply on S and the implicate p(a) ' >∨p(b) 6' > cannot be generated."
    }, {
      "heading" : "4 Deductive Completeness",
      "text" : "We show in this section that SA≺sel is deduction-complete for the clauses in Cflat(A). More precisely, we prove that for any SA≺sel-saturated set S and clause C ∈ Cflat(A), if S |= C then S contains an A-clause of the form [2 | Y] where Cc |= Y. The result is obtained in the following way. Given such a set S and clause C, we consider the smallest A-set X that contains Cc, and construct a set of standard ground clauses Φ(S,X ) such that:\n• Φ(S,X ) contains all ground instances of clauses in S, as well as a set of unit clauses equivalent to X ≡ Cc.\n• Φ(S,X ) is saturated under a slightly adapted version of the Superposition calculus which is refutationally complete.\nSince S ∪ {Cc} is unsatisfiable and the considered calculus is refutationally complete, these two properties together will entail that Φ(S,X ) contains the empty clause. Finally, we show that this is possible only if S contains an Aclause of the required form.\nFirst, we formally define the notions of A-implicates and prime A-implicates.\nDefinition 28 Let S be a set of A-clauses. A clause C is an A-implicate of S if it satisfies the following conditions.\n• C is A-flat and ground.\n• C is not a tautology.\n• S |= C.\nC is a prime A-implicate of S if, moreover, C |= D holds for every A-implicate D of S such that D |= C. We denote by IA(S) the set of A-implicates of S.\nDefinition 29 We denote by CA(S) the set of clauses of the form (Xσ)c, where [2 |X ] ∈ S and σ maps each variable x in X to some constant symbol a ∈ A in such a way that Xσ is satisfiable2. We write S v S′ if for every clause C ′ ∈ S′, there exists C ∈ S such that C |= C ′.\nOur goal is to prove that CA(S) v IA(S) when S is SA≺sel-saturated, i.e., that every prime implicate of S occurs in CA(S) (up to equivalence)."
    }, {
      "heading" : "4.1 Definition of Φ(S,X )",
      "text" : "Let α and β be two arbitrarily chosen function symbols not occurring in S, where ar(α) = 1 and ar(β) = 0. We assume that ∀a ∈ A, β α(a) and that ∀g 6∈ A ∪ {α}, g(~t) β.\nFor every clause C and clause set S, sup(C, S) denotes the set inductively defined as follows.\n• C ∈ sup(C, S).\n• If D ∈ sup(C, S) and D′ is obtained by applying the standard Superposition rule into D from a positive and elementary clause in S, then D′ ∈ sup(C, S).\nA clause set S is non-redundant iff for every clause C ∈ S, C is not redundant in S \\ {C}. For every clause set S, it is easy to obtain a non-redundant subset of S that is equivalent to S by recursively removing from S every clause C that is redundant in S \\ {C}.\nWe define the set of standard ground clauses Φ(S,X ) as well as a selection function selΦ as follows.\n2In other words, σ is such that for every u 6' v ∈ X , uσ 6= vσ.\nDefinition 30 Let S be a set of A-clauses and let X be an A-set. We denote by Φ(S,X ) the set\nΦ(S,X ) def= Φ1(S,X ) ] Φ2(S,X ) ] Φ3(S,X ) ] Φ4(S,X ) ] Φ5(S,X )\nwhere for i = 1, . . . , 5, Φi(S,X ) is defined as follows:\n1. Φ1(S,X ) is the set of clauses of the form Dσ↓X∨C ′, where [D |Y] ∈ S, σ is a ground substitution of domain var(D) such that Yσ ⊆ X and xσ↓X = xσ for all x ∈ var(D), and C ′ is defined as follows:\n• C ′ def= 2 if Dσ is A-flat and quasi-positive;\n• C ′ def= (β 6' >) otherwise.\nThe selection function selΦ is defined on Φ1(S,X ) as follows: selΦ(Dσ↓X ∨ C ′) contains all literals l↓X such that l ∈ sel(Dσ) and one of the following holds:\n• l is negative, • sel(Dσ) is positive and l↓X is -maximal in Dσ↓X ∨ C ′.\n2. Φ2(S,X ) is the set of unit clauses of the form c ' c↓X , where c ∈ A and c 6= c↓X . The selection function is defined on Φ2(S,X ) by: selΦ(c ' c↓X ) def = {c ' c↓X }.\n3. Φ3(S,X ) is the set of non-redundant clauses in⋃ a6'b∈X sup(α(a↓X ) 6' α(b↓X ),Φ1(S,X )),\nand for all C ∈ Φ3(S,X ), selΦ(C) contains all negative literals in C.\n4. Φ4(S,X ) is the set of non-redundant clauses in⋃ p(a1,...,an)./>∈X sup(p(a1↓X , . . . , an↓X ) ./ >,Φ1(S,X )),\nand for all C ∈ Φ3(S,X ), selΦ(C) contains all literals of the form t ./ > in C. Note that the symbol ./ occurring in the generated clause is the same as the one in the corresponding literal p(a1, . . . , an) ./ > of X .\n5. Φ5(S,X ) = {β ' >} ∪ {α(u) 6' α(v) ∨ u ' v | u, v ∈ A, u = u↓X , v = v↓X , u 6= v}. We let selΦ(β ' >) def = {β ' >}, and selΦ(α(u) 6' α(v) ∨ u '\nv) def = {α(u) 6' α(v)}.\nIt is easy to verify that the sets Φi(S,X ) with i = 1, . . . , 5 are disjoint. The type of a clause C ∈ Φ(S,X ) is the number i such that C ∈ Φi(S,X ).\nExample 31 Let A = {a, b, c, d, e}, and X be the reflexive-transitive closure of {a ' b, c ' d, b 6' e}, where a b c d e. Consider the set of clauses\nS = {f(a) ' c∨a 6' b, b 6' c, c ' d, [g(x, y) ' f(d) |y 6' e], [f(x) ' x |a ' c]}.\nThen Φ(S,X ) is decomposed as follows:\nΦ1(S,X ): This set consists of f(b) ' d ∨ a 6' b ∨ β 6' >, b 6' d ∨ β 6' >, d ' d and g(t, b) ' f(d)∨β 6' >, where t ranges over the set of all ground terms. The constants a and c occurring in S are respectively replaced by b = a↓X and d = c↓X in Φ(S,X ). The A-clause [f(x) ' x | a ' c] generates no clauses in Φ(S,X ), since (a ' c) 6∈ X .\nΦ2(S,X ): {a ' b, c ' d}.\nΦ3(S,X ): {α(b) 6' α(e), α(d) 6' α(e)}. The first clause is constructed from (b 6' e) ∈ X , the second one is generated by Superposition into α(b) 6' α(e) from the clause b ' d above.\nΦ4(S,X ): ∅. There is no predicate symbols other than '.\nΦ5(S,X ): This set consists of the following clauses:\n{β ' >, α(b) 6' α(d) ∨ b ' d, α(b) 6' α(e) ∨ b ' e, α(d) 6' α(e) ∨ d ' e} .\nRemark 32 The addition of α is irrelevant from a semantic point of view, since by construction, α(a) 6' α(b) if and only if a 6' b for all a, b ∈ A; it is possible to replace all atoms of the form α(x) 6' α(y) by x 6' y. However, this technical trick ensures that all the clauses of type 3 are strictly greater than all elementary A-flat clauses in Φ(S,X ), which plays a crucial rôle in the proof of Lemma 37. Similarly, the addition of the literal β 6' > does not affect the semantics of the clause set (since by definition β ' > occurs in this set), but ensures that all clauses of type 1 that are not quasi-positive are strictly greater than all clauses of type 2 or 3.\nProposition 33 For all sets of clauses S and A-sets X , selΦ is a selection function for the ordering .\nProof. 3 We must check that for every clause C ∈ Φ(S,X ), selΦ(C) contains either a negative literal in C or all -maximal literals in C (see Definition 30 for the notations). This is immediate for clauses of type 2 and 5, since selΦ(C) = C. For clauses of type 3, we observe that C necessarily contains a negative literal, obtained from the literal α(a↓X ) 6' α(b↓X ) by Superposition. Similarly, all Aclauses of type 4 contains a (unique) literal of the form p(a1, . . . , an) ./ >, that is necessarily maximal. Now assume that C is a clause of type 1, i.e., that C = Dσ↓X ∨D′′ for some [D | Y] in S and D′′ ⊆ {β 6' >}. If we suppose that selΦ(C) contains no negative literal, then the same must hold for sel(Dσ), thus sel(Dσ) necessarily contains all A-maximal literals in Dσ, and by Assumption\n15, if Dσ is A-flat then it must be quasi-positive, and in this case D′′ = 2. Furthermore, by definition of A, for all m ∈ Dσ, if m↓X is -maximal in Dσ↓X , then m is A-maximal in Dσ, which entails that selΦ(C) contains all -maximal literals in C (note that if D′′ 6= 2 then D is not A-flat, hence Dσ D′′).\nProposition 34 Let Sinit be a set of standard clauses and let S be a set of clauses generated from Sinit by SA≺sel. Then Φ(S,X ) |= Sinit ≡ S.\nProof. 4 Let S′ = Φ(S,X ) and consider the set of standard clauses Scl occurring in S, i.e., Scl def = {C | [C |∅] ∈ S}. Since SA≺sel is sound, Sinit |= S. Furthermore, if a standard clause is A-redundant in a set of A-clauses, then it is also redundant w.r.t. the standard clauses in this set, by definition of the redundancy criterion. Thus Scl ≡ S ≡ Sinit.\nBy construction, S′ contains all the clauses that can be obtained from ground instances of clauses in Scl, by replacing every constant a by a↓X and possibly adding literals of the form β 6' >. Since S′ contains all atoms of the form a ' a↓X where a 6= a↓X as well as the atom β ' >, we deduce that S′ |= Scl, and that S′ |= Sinit ≡ S."
    }, {
      "heading" : "4.2 Saturatedness of Φ(S,X )",
      "text" : "The next lemma states that Φ(S,X ) is saturated w.r.t. a slight restriction of the usual Superposition calculus. We shall also use a refined version of the redundancy criterion.\nDefinition 35 A set of ground clauses S is weakly saturated w.r.t. an inference rule in SP≺selΦ if every application of the rule on a set of premises {C1, . . . , Cn} ⊆ S (with n = 1, 2) yields a clause C such that there exists {D1, . . . , Dm} ⊆ S with ∀i ∈ [1,m], Di ≺ max≺({C1, . . . , Cn}) and {D1, . . . , Dm} |= C.\nLemma 36 Let S be a set of ground clauses that is weakly saturated w.r.t. all rules in SP≺selΦ . The set S is satisfiable iff it does not contain 2.\nProof. 5 See (Bachmair and Ganzinger, 1994) or (Nieuwenhuis and Rubio, 2001, theorem 4.8).\nLemma 37 below is the main technical result that is used to prove the completeness of SA≺sel.\nLemma 37 Let S be an SA≺sel-saturated set of A-clauses and let X be a ground and satisfiable A-set. The set Φ(S,X ) is weakly saturated under all inference rules in SP≺selΦ , except for Equational Factorization on positive A-flat clauses.\nProof. 6 The proof is given in Appendix B.\nRemark 38 The set Φ(S,X ) is not saturated under Equational Factorization, because the literal β 6' > is not added to the clauses that are positive and A-flat, and such clauses can have non-positive descendants. For example, {a ' b∨ a ' c, b 6' c} is SA≺sel-saturated, but Φ(S, ∅) = {a ' b∨ a ' c, b 6' c∨β 6' >, β ' >} is not.\nCorollary 39 Let S be an SA≺sel-saturated set of A-clauses and let X be a ground and satisfiable A-set. If Φ(S,X ) is unsatisfiable then it contains 2.\nProof. 7 The proof is not straightforward since Φ(S,X ) is not saturated w.r.t. Equational Factorization on A-flat A-clauses, as explained above. However it can be shown that the application of this rule on A-flat is useless in our context; this is due to the fact that the constants in A are not ordered (see Appendix C for details)."
    }, {
      "heading" : "4.3 Deductive Completeness Theorem",
      "text" : "The previous results lead to the following theorem, which states that the calculus SA≺sel can be used to generate all ground implicates built on A.\nTheorem 40 Let Sinit be a set of standard clauses and let S be a set of Aclauses obtained from Sinit by SA≺sel-saturation. Then CA(S) v IA(Sinit).\nProof. 8 Let C ∈ IA(Sinit), let X be the smallest A-set containing Cc and let S′ def = Φ(S,X ). Note that X is ground since C is ground. Since X is equivalent to Cc and C is not a tautology, this A-set is satisfiable. We first prove that S′ is equivalent to S′′ def= S ∪ Cc ∪ {β ' >, α(u) 6' α(v) ∨ u ' v | u, v ∈ A}, and therefore unsatisfiable. By Proposition 34 S′ |= Sinit ≡ S; since Φ2(S,X ) ∪ Φ3(S,X ) ⊆ S′, we have S′ |= Cc, and since Φ5(S,X ) ⊆ S′, we conclude that S′ |= S′′. We now show that S′′ entails all clauses in S′.\nClauses in Φ5(S,X ). All the clauses in Φ5(S,X ) are in S′′, and the result is obvious.\nClauses in Φ2(S,X ). For all c ∈ A, Cc |= c ' c↓X . Since Cc ⊆ S′′, we have the result.\nClauses in Φ1(S,X ). Let [D | Y] ∈ S, and consider a ground substitution σ such that Yσ ⊆ X and xσ↓X = xσ for all x ∈ var(D). Then S′′ |= Dσ, and since Yσ ⊆ X ≡ Cc, S′′ |= (Dσ)↓X . But β ' > ∈ S′′, thus S′′ |= (Dσ)↓X ∨ C ′, regardless of whether C ′ = 2 or C ′ = (β 6' >).\nClauses in Φ4(S,X ). These clauses are all in Cc, hence the result is obvious.\nClauses in Φ3(S,X ). Consider a literal a 6' b ∈ X . Since the clause a ' b ∨ α(a) 6' α(b) occurs in S′′, we have S′′ |= α(a) 6' α(b); therefore, S′′ |= sup(α(a↓X ) 6' α(b↓X ),Φ1(S,X )).\nSince S′′ is unsatisfiable by construction, so is S′ and by Corollary 39, S′ contains the empty clause. This means that S must contain an A-clause of the form [2 |Y] where Yθ ⊆ Cc. By definition CA(S) contains the clause (Yθ)c and since Yθ ⊆ Cc we have (Yθ)c |= C.\nNote that Theorem 40 does not hold if S is not obtained by SA≺sel-saturation from a set of standard clauses; this is due to the fact that no inference is performed on the literals occurring in the constraints. For example, the set: S = {[2 | a ' b], [2 | a 6' b]} is clearly unsatisfiable and SA≺sel-saturated, however we have CA(S) = {a ' b, a 6' b} 6v IA(S), since 2 ∈ IA(S). We also provide an example showing that the theorem does not hold if A-Superposition into the variables occurring in the constraints is not allowed.\nExample 41 Let S def= {x ' a ∨ x ' c, x ' b ∨ x ' d} and C def= e ' a ∨ e ' b∨c ' d. It is straightforward to verify that S |= C. The only way of generating an A-clause [2 |X ] such that Xσ |= Cc is to apply the Superposition rule on the literals x ' c and x ' d upon the term x, which is usually forbidden. This can be done by first applying the A-Assertion rule on the literals x ' a and x ' b, yielding [x ' c | {x 6' a}] and [x ' d | {x 6' b}]. Then it is possible to apply the Superposition on the term x since it occurs in the constraints. This yields [c ' d | {x 6' a, x 6' b}], and by applying the A-Assertion rule again, we obtain the A-clause [2 |{x 6' a, x 6' b, c 6' d}], which satisfies the required property."
    }, {
      "heading" : "5 Refinements",
      "text" : "Theorem 40 proves that SA≺sel-saturation permits to obtain the prime Aimplicates of any set of clauses. This set may still be very large, it could thus require a lot of time to be generated and be difficult to handle. In this section we introduce some refinements of the calculus SA≺sel, showing that at almost no cost, it is possible to generate only those prime A-implicates of a clause set S that satisfy properties that are closed under subsumption (see Definition 42), or to obtain a more concise representation of all the A-implicates of S."
    }, {
      "heading" : "5.1 Imposing Additional Restriction on the Implicates",
      "text" : "The first refinement is rather straightforward: it consists in investigating how the calculus can be adapted to generate implicates satisfying additional arbitrary restrictions (e.g., for generating implicates of some bounded cardinality, or purely positive implicates). We show that some restrictions can be imposed on the constraint part of all the A-clauses occurring in the search space without losing deductive completeness; in other words, inferences yielding to A-clauses whose constraints do not fulfill the considered restriction can be blocked. This is possible if these implicates belong to some class that is closed under some form of logical generalization. More formally:\nDefinition 42 A set of clauses P is closed under subsumption if for every C ∈ P and for every clause D such that Dσ ⊆ C for some substitution σ, we have D ∈ P. An A-clause [C |X ] is P-compatible if X c ∈ P.\nProposition 43 Let P be a set of clauses that is closed under subsumption, and let [E | Z] be an A-clause generated by an SA≺sel-rule, with [C | X ] as a premise. If [E |Z] is P-compatible, then so is [C |X ].\nProof. 9 We only consider the case where [E | Z] is generated by the ASuperposition rule applied to [C |X ] and [D |Y], the case for the unary inference rules is similar. Then by definition, Z = (X ∪ Y ∪ E)σ, where (σ, E) is an (X ∪ Y)-pure A-substitution, and we have\nX cσ ⊆ [(X ∪ Y ∪ E)σ]c = Zc.\nSince P is closed under subsumption, we deduce that [C |X ] is P-compatible.\nSA≺sel(P) denotes the calculus SA ≺ sel in which all inferences that generate non-P-compatible A-clause are blocked. The following theorem shows that the calculus SA≺sel(P) is deductive complete for the clauses in Cflat(A) ∩P.\nTheorem 44 Let Sinit be a set of standard clauses and let S be a set of Aclauses obtained from Sinit by SA≺sel(P)-saturation. If P is closed under subsumption then CA(S) v IA(Sinit) ∩P.\nProof. 10 A simple induction together with Proposition 43 proves that all the ancestors of P-compatible clauses generated by SA≺sel are necessarily Pcompatible themselves. Since 2 ∈ P for all sets P that are closed under subsumption, all the clauses in Sinit must be P-compatible, hence the result.\nExamples of classes of clauses that are closed under subsumption include the following sets that are of some practical interest:\n• The set of clauses C such that there exists a substitution σ such that Cσ is equivalent to a clause of length at most k.\n• The set of positive (resp. negative) clauses.\n• The set of implicants of some formula φ.\nNote also that the class of clause sets that are closed under subsumption is closed under union and intersection, which entails that these criteria can be combined easily."
    }, {
      "heading" : "5.2 Discarding the Inferences on A-flat Clauses",
      "text" : "In this section we impose a restriction on the calculus that consists in preventing inferences on A-literals. The obtained calculus is not complete since it does not generate all A-implicates in general, but it is complete in a restricted sense: every A-implicate is a logical consequence of the set of A-flat clauses generated by the calculus.\nDefinition 45 We denote by SAR≺sel the calculus SA ≺ sel in which no inference upon A-literals is allowed, except for the A-Assertion and A-Reflection rules. We denote by Ψ(S,X ) the set obtained from Φ(S,X ) by deleting, in every clause C ∈ Φ(S,X ), each literal l such that the unit clause lc belongs to X ∪ {β ' >}.\nExample 46 Consider the set of clauses and A-set from Example 31. The set Ψ(S,X ) contains the following clauses:\n• f(b) ' d, b 6' d, d ' d and g(t, b) ' f(d), where t ranges over the set of all ground terms;\n• a ' b and c ' d;\n• α(b) 6' α(e) and α(d) 6' α(e);\n• β ' >, α(b) 6' α(d) ∨ b ' d, α(b) 6' α(e) and α(d) 6' α(e) ∨ d ' e.\nProposition 47 For all sets of A-clauses S and A-sets X , Φ(S,X ) ≡ Ψ(S,X ).\nSAR≺sel essentially simulates the calculus in (Echenim and Peltier, 2012), but there are some important differences: in particular our previous approach does not handle variable-active axioms and is complete only for implicates containing no predicate symbol other than '. This entails that for example, an implicate of the form p(c1, . . . , cn) ' d can only be generated if a new constant c is added to A, along with the axiom c ⇔ p(c1, . . . , cn). It is clear that applying this operation on all ground atoms is costly from a practical point of view. This is avoided with the new calculus SAR≺sel, thanks to the addition of new inference rules.\nLemma 48 Let S be an SAR≺sel-saturated set of A-clauses and let X be a complete and satisfiable A-set. The set Ψ(S,X ) is SP≺selΦ-saturated.\nProof. 11 We prove that every A-flat clause of type 1 in Ψ(S,X ) is redundant in Ψ(S,X ). Let C = a ./ b ∨ C ′ be such a clause, by definition of Φ(S,X ), we have a = a↓X and b = b↓X . If a = b then either ./=', in which case a ./ b ∨ C is a tautology, or ./= 6', in which case (a 6' a)c ∈ X , and C cannot occur in Ψ(S,X ). Thus a 6= b, and since X is complete, we deduce that a 6' b ∈ X ad that α(a) 6' α(b) occurs in Φ(S,X ). This implies that ./ is 6', since otherwise the literal a ' b would have been deleted from the clause. Thus, C is of the form a 6' b ∨ C ′; it is not positive, and by construction, it contains the literal β 6' >. We deduce that α(a) 6' α(b) |= C and that α(a) 6' α(b) ≺ C; C is therefore redundant. This implies that the only non-redundant inferences that can be applied on clauses in Ψ(S,X ) are upon literals that are not A-flat. The restriction on the calculus SAR≺sel does not affect such inferences, thus, as shown in the proof of Lemma 37, they can be simulated by inferences on the corresponding A-clauses in S.\nThe next theorem states a form of completeness for the restricted calculus SAR≺sel, which is weaker than that of the calculus SA ≺ sel (compare with Theorem 40) and similar to that of (Echenim and Peltier, 2012). The proof is based on the following result.\nProposition 49 Let S be a set of A-clauses and let X be a complete A-set. Then Ψ(S,X ) |= S.\nProof. 12 By Proposition 47 we have Ψ(S,X ) ≡ Φ(S,X ). Let [C | Y] be a clause in S and let σ be a ground Y-pure substitution. If Yσ 6⊆ X , then there exists l ∈ Yσ such that l 6∈ X and since X is complete we deduce that lc ∈ X , which entails that X |= Yσc, and thus Φ(S,X ) |= Yσc (since by Proposition 66 Φ(S,X ) |= X ). Otherwise, we must have Cσ↓X∨C ′ ∈ Φ(S,X ), with C ′ ⊆ β 6' > and since β ' > ∈ Φ(S,X ) we deduce that Φ(S,X ) |= Cσ.\nTheorem 50 Let S be an SAR≺sel-saturated set of A-clauses. Then CA(S) |= IA(S).\nProof. 13 We prove the contrapositive, i.e., that every counter-model of IA(S) is a counter-model of CA(S). Let M be a counter-model of IA(S) and let X be the corresponding A-set, i.e. the set containing all A-flat literals that are true in M. By definition, X is complete and satisfiable. By Proposition 49, Ψ(S,X ) |= S |= IA(S). Since Ψ(S,X ) |= X and X ∪ IA(S) is unsatisfiable, we deduce that Ψ(S,X ) is unsatisfiable; but Ψ(S,X ) is SP≺selΦ-saturated by Lemma 48, hence 2 ∈ Ψ(S,X ). We deduce that S contains an A-clause of the form [C | Y] and there exists a substitution σ such that Ccσ↓X ∪ Yσ ⊆ X . Without loss of generality, we assume that C is the clause with the least number of literals satisfying this property. Assume that C is nonempty. Then selΦ(Cσ↓X ) contains at least one literal (u ./ v)σ↓X and C is of the form u ./ v ∨ D. If ./ is ', then the A-Assertion rule can be applied to this literal, yielding the A-clause [D | Y ∪ {u 6' v}]. Since S is SAR≺sel-saturated, this A-clause must be A-redundant and by Definition 19, S contains an A-clause [D′ | Y ′], such that, for some substitution θ, D′θ ⊆ Dσ and (Y ′ ∪ {u 6' v})θ ⊆ Yσ (note that Dσ cannot be a tautology because Dcσ ⊆ X and X is satisfiable). This is impossible because then [D′ | Y ′] would then satisfy the above restriction, thus contradicting the minimality of C. If ./ is 6' then (u ' v)σ↓X must occur in X since Ccσ↓X ⊆ X ; this implies that uσ↓X = vσ↓X , hence that uσ ∼XA vσ. Thus the A-Reflection rule applies, yielding [D |Y ∪E ]η, where (η, E) is the most general unifier of u and v. There exists a substitution σ′ such that σ ∼XA ησ′, and by the same reasoning as previously, since S is SAR≺sel-saturated, it contains an A-clause [D′ | Y ′] and there exists a substitution θ′ such that D′θ′ ⊆ Dησ′ and Y ′θ′ ⊆ Yησ′ ∪ E. But then (D′θ′↓X )c ⊆ (Dησ′↓X )c = (Dσ↓X )c ⊆ X , and Y ′θ′↓X ⊆ (Yησ′ ∪ E)↓X = (Yσ ∪ E)↓X ⊆ X . Again, this contradicts the minimality of C. Therefore, C is empty, and (Yσ)c ∈ CA(S). Now Yσ ⊆ X , thusM 6|= (Yσ)c, which proves thatM is indeed a counter-model of CA(S), and the proof is completed.\nThe difference between the calculi SA≺sel and SAR ≺ sel can be summarized as\nfollows.\n• The calculus SA≺sel explicitly generates all prime implicates in IA(S), whereas SAR≺sel only generates a finite representation of them, in the form of an A-flat implicant S′ of IA(S). The formula S′ can still contain redundancies and some additional post-processing step is required to generate explicitly the prime implicates of S′ if needed. Any algorithm for generating prime implicates of propositional clause sets can be used for this purpose, since flat ground equational clause sets can be reduced into equivalent sets of propositional clauses by adding equality axioms. In (Echenim et al, 2013) a much more efficient algorithm has been proposed, in which equality axioms are directly taken into account in the inference engine and redundancy pruning mechanism. From a practical point of view, the set IA(S) can be very large, thus S′ can also be viewed as a concise and suitable representation of such a set.\n• The calculus SAR≺sel restricts inferences on A-flat literals to those that actually delete such literals, possibly by transferring them to the constraint part of the clauses (the A-Assertion and A-Reflection rules). From a practical point of view, this entails that these literals do not need to be considered anymore in the clausal part of the A-clause: they can be transferred systematically in the constraints. This can reduce the number of generated clauses by an exponential factor, since a given A-flat clause l1 ∨ . . . ∨ ln can be in principle represented by 2n distinct A-clauses depending on whether li is stored to the clausal or constraint part of the A-clause (for instance a ' b can be represented as [a ' b |∅] or [2 |a 6' b]). Furthermore, the number of applicable inferences is also drastically reduced, since the rules usually apply in many different ways on (selected) A-literals, due to the fact that two A-flat terms are always A-unifiable and that the ordering A is empty when applied on terms in A. For example the clauses a ' b and c ' d generate the A-clauses\n[d ' b |{a ' c}], [d ' a |{b ' c}], [c ' b |{a ' d}], [c ' a |{b ' d}],\nregardless of the ordering ≺.\nThe following example illustrates the differences between SA≺sel and SAR ≺ sel.\nExample 51 Let S = {f(a, b) 6' f(c, d), g(x) ' 0 ∨ x ' c, g(a) 6' 0}, where x ∈ V, g(x) a b c d and A = {a, b, c, d}. It is easy to check that SAR≺sel generates the implicates [2 |{a ' c, b ' d}] (by A-Reflection on the first clause) and [2 |{a 6' c}] (by an application of the A-Superposition rule from the second clause into the third one, followed by an application of the A-Assertion rule). However, the implicate [2 | {b ' d}] that is a logical consequence of the above A-clauses is not generated. In contrast, it is possible to infer this implicate with SA≺sel: First the A-Superposition rule generates as usual the clauses a ' c and then f(c, b) 6' f(c, d) (the constraints are empty at this point since all the\nconsidered A-unifiers are standard unifiers), and [2 | {b ' d}] is inferred by applying A-Reflection on the latter clause. Note that SA≺sel has a larger search space than SAR≺sel. Consider for instance a clause a ' b ∨ c ' d. SAR ≺ sel simply reduces this clause into [2 | {a 6' b, c 6' d}] and no further inference is applicable on it, while SA≺sel also generates the A-clauses [a ' b | {c 6' d}] and [c ' d |{a 6' b}], which in turn possibly enable other inferences.\nIt is possible to combine the two calculi SA≺sel and SAR ≺ sel. This can be done as follows.\n• Starting from a set of clauses S, SAR≺sel is first applied until saturation, yielding a new set S′. By Theorem 50 we have CA(S′) ≡ IA(S).\n• Then SA≺sel(P) is applied on CA(S′) until saturation yielding a set S′′, where P denotes the set of clauses that logically entail at least one clause in CA(S′). It is clear that this set of clauses is closed under subsumption, hence by Theorem 44, we eventually obtain a set of clauses CA(S′′) v IA(CA(S′)) ∩P. But IA(CA(S′)) ∩P v CA(S′), hence CA(S′′) v CA(S′), and CA(S′′) ≡ IA(S). The set of clauses CA(S′′) can therefore be considered as a concise representation of IA(S). This approach is appealing since CA(S′′) is in generally much smaller than IA(S), and contrary to CA(S′), this set is free of redundancies.\nAnother straightforward method to eliminate redundant literals from the clauses in CA(S′) without having to explicitly compute the set IA(S′) is to test, for every clause l∨C ∈ CA(S′), whether the relation CA(S′) |= C, holds, in which case the literal l can be safely removed. The test can be performed by using any decision procedure for ground equational logic (see for instance Meir and Strichman, 2005; Dillig et al, 2010, for a similar approach). Note however that removing redundant literals is not sufficient to obtain prime implicates, as shown in the following example.\nExample 52 Consider the clause set: S def= {a 6' c∨ b 6' c∨ d ' e, a ' c∨ a ' f, b ' c ∨ a ' f, f 6' b}. It is easy to check that a 6' b ∨ d ' e is an implicate of S and that this clause is strictly more general than a 6' c ∨ b 6' c ∨ d ' e. The calculus SA≺sel computes the A-clause [2 | {a ' b, d ' e}], yielding the set of prime implicates: S′ def= {a 6' b ∨ d ' e, a ' c ∨ a ' f, b ' c ∨ a ' f, f 6' b}. S′ is equivalent to S and strictly smaller. In contrast, the approach devised by Dillig et al (2010) cannot simplify S since there is no useless literal."
    }, {
      "heading" : "6 Termination",
      "text" : "We relate the termination behavior of SA≺sel to that of the usual Superposition calculus. We first introduce restricted ordering and redundancy criteria. For all expressions (terms, atoms, literals or clauses) t and s, we write t BA s if t′ s′ holds for all expressions t′, s′ such that t ∼A t′ and s ∼A s′. Note that the ordering BA is stronger than A (and also stronger than ) because the\nconstants in t and s can be rewritten independently of each other. Assume for instance that ≺ is such that f(a) ≺ g(a) ≺ f(b) ≺ g(b) with A = {a, b}. Then it is easy to check that g(a) A f(a) but g(a) 6BA f(a) since g(a) ≺ f(b) ∼A f(a). Also, let selA be the selection function defined from the function sel as follows: for every clause l ∨ C, l ∈ selA(l ∨ C) if there exists l′, C ′ such that l′ ∼A l, C ′ ∼A C and l′ ∈ sel(l′ ∨ C ′). We show that most termination results for the calculus SPCAselA also apply to SA ≺ sel. To this purpose, we consider a restricted form of redundancy testing.\nDefinition 53 A standard clause C is strongly redundant in a set of standard clauses S iff for every clause C ′ ∼A C, C ′ is A-redundant in S.\nDefinition 54 For every set of A-clauses S and for every ground A-set Y, we denote by Γ(S,Y) the set of standard clauses Cσ, where [C |X ] ∈ S and σ is an X -pure substitution of domain var(X ) such that σ↓Y = σ and Xσ ⊆ Y.\nThe definition of Γ(S,Y) is similar to that of Φ(S,Y) (see Section 4), except that: (i) only the variables occurring in X are instantiated; (ii) the clauses are not reduced with respect to the equations in the constraint part (but the constants replacing the variables in X are reduced).\nExample 55 Let S = {[f(x, y) ' a |{x 6' b}]} with A = {a, b, c} and a b c. We have Γ(S, {a 6' b, a ' c}) = {f(c, y) ' a} and Γ(S, {a 6' b, c 6' b}) = {f(a, y) ' a, f(c, y) ' a}.\nLemma 56 Let S be a set of A-clauses, E be an A-clause and U be a ground A-set.\n• If E can be deduced from S by SA≺sel, then every clause in Γ(E,U) can be deduced from Γ(S,U) ∪ U by SPCAselA .\n• If S is a set of standard clauses and Γ(E,U) contains a clause that is strongly redundant in Γ(S,U) then E is A-redundant in S.\nProof. 14 See Appendix D.\nWe denote by UA the set of all unit clauses of the form p(a1, . . . , an) ./ > or a ./ b, with a1, . . . , an, a, b ∈ A. For any set of clauses S, we denote by S? the set of clauses inductively defined as follows.\n• S ⊆ S?.\n• If C is not strongly redundant in S and is deducible from S? ∪ UA by applying the rules in SPCAselA (in one step), then C ∈ S ?.\nLemma 56 immediately entails the following:\nCorollary 57 Let S be a set of clauses. If S? is finite then SA≺sel terminates on S (up to redundancy).\nIn order to prove that SA≺sel terminates on some class of clause sets S, it suffices to prove that S? is finite, for every S ∈ S. The calculus SPCAsel is slightly less restrictive than the usual Superposition calculus SP≺sel, since CA is a stronger relation than ≺. However, most of the usual termination results for the Superposition calculus still hold for SPCAsel , because they are closed under the addition of equalities between constants and do not depend on the order of ∼A-equivalent terms. Similarly, redundancy testing is usually restricted to subsumption and tautology detection. In particular, all the termination results described by Armando, Ranise, and Rusinowitch (2003) are preserved (it is easy to check that S? is finite for the considered sets of axioms).\nAn interesting continuation of the present work would be to devise formal (automated) proofs of the termination of SA≺sel on the usual theories of interest in program verification, enriched by arbitrary ground clauses. This could be done by using existing schematic calculi (see, e.g., Lynch and Morawska, 2002; Lynch et al, 2011; Tushkanova et al, 2013) to compute a symbolic representation of the set of A-clauses S?."
    }, {
      "heading" : "7 Conclusion and Discussion",
      "text" : "Although the Superposition calculus is not deductive-complete in general, we have shown that it can be adapted in order to make it able to generate all implicates defined over a given finite set of ground terms denoted by constant symbols, using a finite set of predicate symbols including the equality predicate. Furthermore, this is done in such a way that the usual termination properties of the calculus are preserved. By duality, the procedure can be used to generate abductive explanations of first-order formulæ.\nA major restriction of our approach is that it cannot handle built-in theories such as arithmetics which play an essential rôle in verification. Axiomatizing these theories in first-order logic is infeasible or inefficient. A natural follow-up of this work is therefore to make the procedure able to cooperate with external decision procedures. This can be done for instance by combining our approach with existing techniques for fusing the Superposition calculus and external reasoning tools (Bachmair et al, 1994; Althaus et al, 2009; Baumgartner and Waldmann, 2013). These techniques, based on the use of constrained Superposition together with an abstraction of the terms of the considered theory, should be easy to combine with A-Superposition. Note that our calculus has many commun points with the above-mentioned constrained Superposition calculi, however in our case the constraint and clausal parts are not defined over disjoint signatures: in contrast the A-unification and Assertion rules allow one to transfer literals from the clausal part to the constraints. In other approaches (Bachmair et al, 1994; Althaus et al, 2009; Baumgartner and Waldmann, 2013) the constraints are used to store formulæ that cannot be handled by the Superposition calculus, whereas in our case they are used to store properties that are asserted instead of being proved.\nAnother obvious drawback with the calculi SA≺sel and SAR ≺ sel is that the\nuser has to explicitly declare the set of abducible terms (i.e., the constants in A). This set must be finite and must contain all built-in constants. Note that, thanks to the results in Section 5, unsatisfiable or irrelevant implicates (such as 0 ' 1) can be easily detected and discarded on the fly during proof search. Handling infinite (but recursive) sets of terms is possible from a theoretical point of view: it suffices to add an inference rule generating clauses of the form a ' t, where t is an abducible ground terms and a is a fresh abducible constant symbol. It is easy to see that completeness is preserved, but of course termination is lost. A way to recover termination is to develop additional techniques to restrict the application of this rule by selecting the terms t. This could be done either statically, from the initial set of clauses, or dynamically, from the information deduced during proof search.\nAnother possible extension would be to generate “mixed” implicates, containing both abducible and non-abducible terms, which would avoid having to declare built-in constants as abducible. An alternative approach consists in avoiding to have to explicitly declare abducible terms, by adding rules for generating them symbolically (as the A-Substitutivity rule does for predicate symbols). For termination, additional conditions should be added to ensure that the set of abducible terms is finite (using, e.g., sort constraints).\nAnother restriction is that our method does not handle non-ground abducible terms, hence cannot generate quantified formulæ. We are now investigating these issues."
    }, {
      "heading" : "B Proof of Lemma 37",
      "text" : "The proof is based on the following intermediate results.\nDefinition 61 Let S be a set of A-clauses and X be an A-set. If u ./ v∨C∨D is a clause of type 1 in Φ(S,X ), where ./∈ {', 6'} and D ⊆ {β 6' >}, then there exist an A-clause [u′ ./ v′ ∨ C ′ | Y] ∈ S and a substitution σ such that3 (u′σ)↓X = u, (v ′σ)↓X = v, (C ′σ)↓X = C and Yσ ⊆ X . The term occurrence u is superposable in u ./ v ∨ C if u′ occurs in Y whenever it is a variable.\nProposition 62 Let S be a set of A-clauses and X be an A-set. Let C be a clause of type 1 in Φ(S,X ) and a, b be constants in A such that a↓X = a and b↓X = b. Let P be a set of non-superposable occurrences of a in C. Then there exists a set P ′ of occurrences of a in C that contains P , and a clause D in Φ(S,X ) such that D is obtained from C by replacing all occurrences of a in P ′ by b.\nProof. 17 By definition, there exists an A-clause [C ′ |Y] ∈ S and a substitution σ such that C = C ′σ↓X ∨ C ′′, C ′′ ⊆ {β 6' >} and Yσ ⊆ X . Since P is a set of non-superposable occurrences in C, the subterms of D at the positions in P are variables x1, . . . , xn not occurring in Y.\nConsider the substitution θ coinciding with σ, except that ∀i ∈ [1, n], xiθ def = b. Since the variables xi (1 ≤ i ≤ n) do not occur in Y, θ and σ coincide on Y, hence Yθ ⊆ X . This means that Φ(S,X ) must contain the clause of type 1 C ′θ↓X ∨ C ′′ (note that C ′′ is not affected because C ′σ is A-flat and positive exactly when C ′θ satisfies the same property). By definition, since a↓X = a and b↓X = b, C ′θ↓X ∨ C ′′ is therefore obtained from C = C ′σ↓X ∨ C ′′ by replacing some occurrences of a by b, and in particular, all the occurrences in P are replaced.\nNote that P ′ can be a strict superset of P : for example, if S = {x ' c∨x ' d}, then a ' c∨a ' d ∈ Φ(S, ∅), position 1.1 is not superposable in a ' c∨a ' d, and it is clear that b ' c ∨ b ' d ∈ Φ(S, ∅) but b ' c ∨ a ' c 6∈ Φ(S, ∅).\nProposition 63 Let [C | X ] be an A-clause; assume that X is satisfiable and that C is A-flat and quasi-positive. Then [C |X ] is a tautology if and only if C↓X is either a tautology or contains a literal that also occurs in X . In particular, if C is elementary and positive then [C | X ] is a tautology exactly when C↓X is a tautology.\nProof. 18 Assume that C↓X is not a tautology and contains no literal in X . Let I be the interpretation such that ∀a, b ∈ A, I |= a ' b iff a↓X = b↓X and for all a1, . . . , an where ai↓X = ai, I |= p(a1, . . . , an) ' > iff p(a1, . . . , an) ' > ∈ X or p(a1, . . . , an) 6' > ∈ C↓X . Note that I is well-defined, since X and C↓X share no literals and neither of them contains complementary literals. By definition, I validates all positive literals in X . If a 6' b ∈ X and I 6|= a 6' b, then a↓X = b↓X , hence X |= a ' b, which means that X is unsatisfiable, and this contradicts the hypothesis of the lemma. Similarly, if p(a1, . . . , an) 6' > ∈ X\n3If several terms u′ satisfying the above conditions exist then one of them is chosen arbitrarily.\nand I |= p(a1, . . . , an) ' > then since X is satisfiable, p(a1, . . . , an) 6' > must occur in C↓X , which contradicts the hypothesis that X and C↓X share no literals. Therefore, I |= X . Now consider a literal l ∈ C. Since C is A-flat and quasipositive, l is of the form a ' b or p(a1, . . . , an) ./ >. If l is of the form a ' b and a↓X = b↓X then C↓X is a tautology, and this is impossible by hypothesis. Thus a↓X 6= b↓X and I 6|= a ' b. Now assume that l is of the form p(a1, . . . , an) ' > and that I |= l; the case where l is of the form p(a1, . . . , an) 6' > is similar. Let m = p(a1↓X , . . . , an↓X ) ' >. Since I |= l,X , it is clear that I |= m, thus by definition of I, either m ∈ X or mc ∈ C↓X . In the first case m occurs in both X and C↓X , and in the second case, both m and mc occur in C↓X which is a tautology; thus we get a contradiction in both cases. Therefore, I is a counter-model of [C |X ].\nThe converse is straightforward.\nNote that the previous property does not hold if C is not quasi-positive; for example, [a 6' b |a 6' b] is a tautology but the unit clause (a 6' b)↓{a6'b} = a 6' b is not.\nLemma 64 Let S be an SA≺sel-saturated set of A-clauses and X be an A-set. For i = 1, 2, let ui ' vi ∨ Ci be an A-flat clause of type 1 in Φ(S,X ), and assume that ui 6= vi. If the following conditions hold:\n• u1 = u2 6= >,\n• u1 is superposable in u1 ' v1 ∨ C1,\n• for i = 1, 2, ui ' vi ∈ selΦ(ui ' vi ∨ Ci),\n• v1 ' v2 ∨ C1 ∨ C2 is not a tautology,\nthen Φ(S,X ) contains a clause of type 1 contained in v1 ' v2 ∨ C1 ∨ C2.\nProof. 19 For i = 1, 2, since ui ' vi ∨Ci is of type 1, there exists an A-clause [ti ' si ∨Di | Yi] ∈ S and a substitution σi such that Yiσi ⊆ X , Diσi↓X = Ci, tiσi↓X = ui and siσi↓X = vi.\nLet σ = σ1σ2. Since u1 = u2, we have t1σ = t1σ1 ∼XA t2σ2 = t2σ, hence (σ,X ) is an A-unifier of t1 ' t2. Let (η,Z) be a most general A-unifier of t1 ' t2, then Z ⊆ X , and there exists a ground substitution σ′ such that ∀x, xησ′ ∼XA xσ. Now, [(ti ' si)ησ′]↓X = ui ' vi, which is selected in ui ' vi ∨Ci, and since sel is stable under A-substitutions, (ti ' si)η ∈ sel((ti ' si ∨Di)η).\nBy hypothesis v1, v2 ∈ A ∪ V, hence s1, s2 ∈ A ∪ V. By definition of A, this implies that siη 6 A tiη: indeed, s1, s2 can be replaced by the minimal constant >, either by instantiation or by rewriting of constants in A. Note also that siη 6= tiη since otherwise we would have ui = vi, which contradicts the hypotheses of the lemma.\nSince u1 is superposable, either t1 is not a variable or t1 occurs in Y1, hence by definition of SA≺sel, the A-Superposition from [t2 ' s2 ∨ D2 | Y2] into [t1 ' s1 ∨D1 | Y1] upon the terms t1 and t2 generates [(s1 ' s2 ∨D1 ∨D2)η | Y1η ∪\nY2η ∪ Z]. Now, the A-clause [(s1 ' s2 ∨ D1 ∨ D2)ησ′ | Y1ησ′ ∪ Y2ησ′ ∪ Z] must be A-redundant in S, because S is SA≺sel-saturated. This clause cannot be a tautology; indeed, for i = 1, 2, since ui ' vi ∈ selΦ(ui ' vi ∨ Ci) and ui ' vi∨Ci ∈ Cflat(A), Ci must be positive by definition of the selection function selΦ, and cannot contain a symbol in P (otherwise the literal containing this symbol would be strictly greater than ui ' vi). By hypothesis, v1 ' v2 ∨C1 ∨C2 is not a tautology and since C1, C2 are positive and elementary, we deduce by Proposition 63 that [(s1 ' s2 ∨ D1 ∨ D2)ησ′ | Y1ησ′ ∪ Y2ησ′ ∪ Z] is not a tautology either. Thus, by Definition 19, there exists an A-clause [E | Z ′] ∈ S and a substitution θ such that Eθ ⊆ (s1 ' s2 ∨D1 ∨D2)ησ′ and Z ′θ ⊆ Y1ησ′ ∪ Y2ησ′ ∪Z ⊆ X . Therefore, Φ(S,X ) contains the clause Eθ↓X that is contained in [(s1 ' s2 ∨D1 ∨D2)ησ′]↓X = v1 ' v2 ∨ C1 ∨ C2.\nProposition 65 Let S be an SA≺sel-saturated set of A-clauses and X be a ground A-set. If Φ(S,X ) contains a non-tautological clause D ⊆ C∨a ' b∨a ' b, where C ∨ a ' b is positive and elementary then C ∨ a ' b is redundant in Φ(S,X ).\nProof. 20 If D contains at most one occurrence of a ' b, then necessarily D ⊆ C ∨ a ' b and the proof is immediate. Otherwise, since a ' b∨ a ' b ⊆ D, the latter cannot be of type 2; it is therefore of type 1, thus there exists an Aclause [D′ | Y] ∈ S and a substitution σ such that D′σ↓X = D and Yσ ⊆ X . D′ is of the form C ′ ∨ u ' v ∨ u′ ' v′, where C ′σ↓X ⊆ C, uσ↓X = u′σ↓X = a and vσ↓X = v′σ↓X = b. By Proposition 4, D′ is A-flat; thus the literal u ' v is necessarily A-maximal in D′, and the A-Factorization rule applied to [D′ |Y] generates [(C ′ ∨ u ' v ∨ v 6' v′)θ |Yθ ∪ Z], where (θ,Z) is the m.g.u. of u and u′, or simply [(C ′ ∨ u ' v)θ | Yθ ∪ Z], if vθ = v′θ. We assume that vθ 6= v′θ, the proof when they are equal is simpler. Since (σ,X ) is an instance of (θ,Z), by Proposition 21 the clause [(C ′ ∨ u ' v ∨ v 6' v′)σ | X ] must be redundant in S, and since vσ↓X = v′σ↓X = b, it is equivalent to [(C ′ ∨ u ' v)σ |X ]. This Aclause cannot be a tautology; otherwise, by Proposition 63, (C ′ ∨ u ' v)σ↓X ≡ D would also be a tautology. Therefore, by Definition 19, there exists an A-clause [E | U ] ∈ S and a substitution η such that Eη ⊆ (C ′ ∨ u ' v ∨ v 6' v′)σ and Uη ⊆ X . By definition of Φ(S,X ), the clause Eη↓X occurs in Φ(S,X ). If Eη ⊆ (C ′ ∨ u ' v)σ then the proof is completed. Otherwise, E is of the form E′ ∨ w 6' w′, where E′η ⊆ (C ′ ∨ u ' v)σ, wη = vσ and w′η = v′σ. Note that w and w′ cannot both be equal to >, since otherwise w 6' w′ would have been removed from the A-clause, thus the literal w 6' w′ is necessarily A-maximal in E′ ∨ w 6' w′, and it must be selected; therefore, the A-Reflection rule can be applied on this clause. Since (η,X ) is a unifier of w and w′, necessarily, the A-clause [E′η | X ] is redundant in S. By Definition 19, S contains a clause [E′′ | U ′] and there exists a substitution µ such that E′′µ ⊆ E′η and U ′µ ⊆ X . We conclude that E′η↓X ⊆ C ∨ a ' b must be redundant in Φ(S,X ).\nProposition 66 There exists a set of clauses U ⊆ Φ2(S,X ) ∪ Φ3(S,X ) ∪ Φ4(S,X ) ∪ Φ5(S,X ) such that U contains no occurrence of β, and U |= X\nProof. 21 Consider the following sets:\nX1 def = {a ' a↓X | a ∈ X , a 6= a↓X } ,\nX2 def = { (a 6' b)↓X | a 6' b ∈ X } ,\nX3 def = { (f(a1, . . . , an) ./ >)↓X | f(a1, . . . , an) ./ > ∈ X } .\nIt is clear that X ≡ X1 ∪ X2 ∪ X3 and that X1 ⊆ Φ2(S,X ). By letting X ′2 def =⋃\na6'b∈X2 {α(a) 6' α(b)}, we have X ′ 2 |= X2, the set U def = X1 ∪X ′2 ∪X3 entails X , it is a subset of Φ2(S,X ) ∪Φ3(S,X ) ∪Φ4(S,X ) and contains no occurrence of β.\nWe now establish a result concerning the form of the clauses of type 3 or 4 in Φ(S,X ).\nLemma 67 Any clause C of type 3 (resp. 4) in Φ(S,X ) is of the form α(a1) 6' α(a2) ∨ C ′ (resp. p(a1, . . . , an) ./ > ∨ C ′) where:\n1. a1, a2 ∈ A (resp. a1, . . . , an ∈ A)\n2. C ′ is positive and elementary.\n3. X contains a clause of the form b1 6' b2 (resp. p(b1, . . . , bn)).\n4. For every i ∈ [1, 2] (resp. i ∈ [1, n]) either ai = bi or ai ≺ bi and Φ(S,X ) contains a clause of the form ai ' bi∨Ci with Ci ⊆ C ′ and Ci ≺ (ai ' bi).\nProof. 22 By definition of the clauses of type 3 and 4 in Φ(S,X ) (see Definition 30), C is obtained from a clause of the form α(b1) 6' α(b2) with b1 6' b2 ∈ X (resp. from a clause p(b1, . . . , bn) ∈ X ) by applying Superposition inferences from positive elementary clauses in Φ(S,X ). Furthermore, C cannot be redundant. We prove the result by induction on the number of Superposition inferences. The base case is immediate (with ai = bi, C ′ = 2). Assume that C is obtained by Superposition into a clause D. Without loss of generality we assume that the considered derivation is minimal (w.r.t. the number of steps). By the induction hypothesis, D is necessarily of the form α(a1) 6' α(a2) ∨ C ′ (resp. p(a1, . . . , an) ./ >∨C ′), where a1, . . . , an and C ′ satisfy the above properties. By definition of the selection function selΦ, only the literal α(a1) 6' α(a2) (resp. p(a1, . . . , an)) is selected, hence the replacement necessarily occurs in this literal. By symmetry, we may assume that it occurs upon the constant a1, from a clause of the form a1 ' a′1 ∨ D′ (with a1 a′1). The inference yields C = α(a′1) 6' α(a2)∨C ′∨D′ (resp. p(a′1, a2, . . . , an) ./ >∨C ′∨D′). If b1 = a1, then the proof is completed, since the clause a1 ' a′1 ∨ D′ fulfills the property of Item 4. Otherwise, by the induction hypothesis, Φ(S,X ) contains a clause of the form a1 ' b1 ∨ C1 with C1 ⊆ C ′ Assume that a1 is not superposable in a1 ' b1 ∨ C1. By Proposition 62, this entails that Φ(S,X ) contains a clause of type 1 of the form a′1 ' b1 ∨ C ′1, where C ′1 is obtained from C1 by replacing\noccurrences of a1 by a′1 (b1 is not replaced, since b1 6= a1). By replacing the Superposition inference upon b1 in the derivation yielding C by a Superposition from a′1 ' b1 ∨ C ′1, we get a clause D′′ of the form a′1 6' a2 ∨ C ′′ (resp. p(a′1, a2, . . . , an) ./ >∨C ′′ with C ′′ ⊆ C ′∨C ′1. Clause D′′ satisfies the following properties.\n• D′′ is a clause of type 3 or 4 in Φ(S,X ).\n• D′′ C, since a′1 ≺ a1.\n• a′1 ' a1∨D′ ≺ C, since by definition of the ordering α(x) c and p(~x) c for every c ∈ A.\n• D′′, a′1 ' a1 ∨D′ |= C.\nThe number of inferences in the derivation is strictly lower than that of C (since the sequence of Superposition inferences replacing b1 by a1 and then a1 by a′1 has been replaced by a single replacement of b1 by a′1), which by minimality of the derivation entails that D′′ 6= C. Thus D′′ C and C is redundant, which contradicts the definition of the clauses of type 3 and 4. Consequently a1 is superposable in a1 ' b1 ∨ C1. We now distinguish two cases.\n• The clause b1 ' a′1 ∨ C1 ∨D′ is a tautology. Since this clause is positive, this entails that it contains a literal of the form t ' t (otherwise the interpretation mapping all constants to distinct elements would falsify the clause). Since b1 a1 and a1 a′1 we have b1 6= a′1 hence the literal t ' t occurs in C1 ∨D′. But then C would be redundant (since it contains C1 ∨D′), which contradicts the definition of the clauses of type 3 and 4.\n• The clause b1 ' a′1 ∨ C1 ∨D′ is not a tautology. Since a1 is superposable in a1 ' b1 ∨ C1, by Lemma 64, we deduce that there is a clause of type 1 in Φ(S,X ) that is contained in (a′1 ' b1) ∨ C1 ∨ D′. If this clause is contained in C1∨D′ then it is also contained in C which is redundant and the proof is completed; otherwise it is of the form (a′1 ' b1) ∨ C ′1, where C ′1 ⊆ C1∨D′ ⊆ C ′∨D′, which proves that the above property holds for C.\nWe are now in a position to provide the proof of Lemma 37. We have to prove that every clause generated from Φ(S,X ) by an inference in SP≺selΦ except for Equational Factorization on positive A-flat clauses is a logical consequence of some clauses in Φ(S,X ) that are strictly smaller than the maximal premise of the inference. Note that this condition necessarily holds if the conclusion is redundant in Φ(S,X ), since a clause cannot be greater than its maximal premise. We distinguish several cases, depending on the types of the clauses involved in the inference.\nClauses of type 2.\nBy definition, every such clause is of the form c ' c↓X , where c 6= c↓X and by construction, c c↓X . Constant c cannot occur in other clauses in Φ(S,X ), since\nall its occurrences are replaced by c↓X . Thus the clause c ' c↓X cannot interact with any other clause, because of the ordering restrictions of the Superposition calculus.\nClauses of type 5.\nBy construction, constant β only occurs in literals of the form β 6' > and β ' >. By definition of selΦ, the literal β 6' > is never selected, thus the clause β ' > cannot interact with other clauses in Φ(S,X ). Now, consider a clause of the form α(u) 6' α(v) ∨ u ' v. By definition, u = u↓X , and u cannot be the maximal term of a selected literal in Φ(S,X ). Since α occurs only in negative literals, no literal can interact with α(u) 6' α(v), and since u 6= v, the Reflection rule does not apply either.\nClauses of type 3.\nLet C be a clause of type 3. By definition, only negative literals are selected in C, thus the only inference rules that can be applied on C are the Reflection rule or the Superposition rule into C, where the “from” premise is necessarily a clause of type 1 in Φ(S,X ). By Case 3 of Definition 30, all the non-redundant clauses that can be generated by the Superposition inference rule are already in Φ3(S,X ). Thus, we only consider the case where the Reflection inference rule applied on C generates a clause D.\nBy Lemma 67, C is of the form α(a1) 6' α(a2) ∨ C ′, where X contains a clause of the form b1 6' b2 with for all i = 1, 2 either bi = ai or Φ(S,X ) contains a clause of type 1 of the form (bi ' ai) ∨ Ci, where Ci ⊆ C ′. Furthermore, by definition of the Reflection rule, we must have a1 = a2.\nIf b1 = a1 or b2 = a2 or if ai is superposable in (bi ' ai) ∨ Fi, then by Lemma 64, Φ(S,X ) contains a clause (b1 ' b2) ∨C ′′ with C ′′ ⊆ C1 ∨C2. Then S contains an A-clause of the form [u ' v ∨ E |Y], where uθ↓X = b, vθ↓X = a, Eθ↓X = C\n′′ and Yθ ⊆ X . Then the A-Assertion rule can be applied to this A-clause, yielding [E | Y ∪ {u 6' v}]. Note that since b1 6= b2, Yθ ∪ {u 6' v} θ must be satisfiable. If [E | Y ∪ {u 6' v}]θ is a tautology, then so is Eθ↓X = C ′′ by Proposition 63, hence D is also a tautology and is redundant in Φ(S,X ), thus the proof is completed. Otherwise, by Definition 19, since S is SA≺selsaturated, it contains an A-clause [E′ | Y ′] and there exists a substitution θ′ such that E′θ′ ⊆ Eθ and Y ′θ′ ⊆ Yθ ∪ {u 6' v} θ. Then Φ(S,X ) contains the clause E′θ′θ↓X ⊆ Eθ↓X = C ′′ ⊆ C ′, and the latter is therefore redundant in Φ(S,X ).\nNow assume that b1 6= a1, b2 6= a2 and that neither a1 nor a2 is superposable. By Proposition 62, Φ(S,X ) contains a clause of the form b1 ' b2 ∨ G1, where G1 is obtained from F1 by replacing occurrences of a1 by b2. Using the fact that S is saturated under A-Assertion, we deduce as in the previous case that Φ(S,X ) contains a clause G′1 ⊆ G1. Thus, since α(a1) 6' α(a2) ∨ F1 ∨ F2 ⊆ C and a1 = a2, we have:\nG′1, b2 ' a2 ∨ F2 |= G1, b2 ' a2 ∨ F2 |= G1 ∨ F2 |= C.\nSince C contains an occurrence of α, it is strictly greater than G′1 and b2 ' a2 ∨ F2, thus C is redundant, and cannot be a clause of type 3.\nClauses of type 4.\nBy Lemma 67, C is necessarily of the form p(a1, . . . , an) ./ > ∨ C ′, where for every i ∈ [1, n], one of the two following conditions hold:\n1. ai = bi.\n2. Φ(S,X ) contains a positive elementary clause of the form ai ' bi ∨ Ci, with ai ≺ bi, (ai ' bi) Ci, Ci ⊆ C ′.\nThe only rule that can be applied on C (beside Superposition from elementary positive clauses for which the proof follows immediately from Case 4 of Definition 30) is the Superposition rule on the term p(a1, . . . , an), and in this case the other premisse must be of the form p(a1, . . . , an) 6./ > ∨ F . The generated clause is C ′ ∨ F , since literals of the form > 6' > are deleted.\nBy definition of Φ(S,X ), for each index i satisfying the second item, there exist an A-clause [a′i ' b′i∨C ′i |Yi] ∈ S and a substitution σi such that a′iσi↓X = ai, b′iσi↓X = bi, C ′ iσi↓X = Ci, and Yiσ ⊆ X . Let E (resp. E′) be the disjunction of the clauses Ci (resp. C ′i), for all indices such that ai 6= bi. Note that E ⊆ C ′, hence it is sufficient to prove that E ∨ F is redundant in Φ(S,X ). The ASubstitutivity rule applied on the clauses [a′i ' b′i ∨ C ′i | Yi] generates the Aclause: [p(a′1, . . . , a′n) ./ > ∨ E′ | {p(b′1, . . . , b′n) ./ >}], with bi = ai ⇒ (b′i = a′i = xi) (where the xi’s denote pairwise distinct fresh variables) and bi 6= ai ⇒ (b′i = bi ∧ a′i = ai). This A-clause must be redundant in S, in particular (taking xi = bi if bi = ai) either [p(a1, . . . , an) ./ > ∨ E | {p(b1, . . . , bn) ./ >}] is a tautology (Case (i)) or there exist an A-clause [D |Y] and a substitution θ with Dθ↓X ⊆ p(a1, . . . , an) ./ > ∨ E and Yθ ⊆ {p(b1, . . . , bn) ./ >} (Case (ii)).\nIf Dθ↓X ⊆ E then E ∨ F is clearly redundant in Φ(S,X ), thus we assume that D is of the form p(~s) ./ >∨D′, with ~sθ↓X = (a1, . . . , an) and D′θ↓X ⊆ E. Note that by definition of the ordering p(~sθ↓X ) ./ > is strictly greater than any literal in D′θ↓X .\nBy Proposition 63, we observe that [p(a1, . . . , an) ./ >∨E |{p(b1, . . . , bn) ./ >}] is a tautology only if (a1, . . . , an) = (b1, . . . , bn). We then distinguish two cases, according to the type of the other premisse p(a1, . . . , an) 6./ > ∨ F .\n1. If p(a1, . . . , an) 6./ >∨ F is of type 1, then there exist an A-clause [p(~t) 6./ > ∨ F ′ | Z] ∈ S and a substitution θ′ such that ~tθ′↓X = (a1, . . . , an), F ′θ′↓X ∨ F ′′ = F and Zθ′ ⊆ X , where F ′′ = β 6' > if F is quasi-positive and F ′′ = 2 otherwise. Then:\n• In Case (i), we have (a1, . . . , an) = (b1, . . . , bn), by the above remark. Furthermore, the A-Assertion rule applies on [p(~t) 6./ > ∨ F ′ | Z], yielding [F ′ | Z ∪ {p(~t) ./ >}]. Since S is saturated under the AAssertion rule, this A-clause is redundant in S. Since (p(~tθ′↓X ) ' >) = (p(a1, . . . , an) ' >) = (p(b1, . . . , bn) ' >) ∈ X , this entails\nthat F ′θ′↓X ∨ F ′′ (hence also E ∨ F since F = F ′θ′↓X ∨ F ′′) is redundant in Φ(S,X ).\n• In Case (ii), since ~tθ′↓X = (a1, . . . , an) = ~sθ↓X , ~t and ~s have an Aunifier (µ,U), that is more general than (θ ∪ θ′,X ). Furthermore, (p(~s) ./ >)µ and (p(~t) 6./)µ must be selected in Dµ and (p(~t) 6./ >∨F ′)µ, respectively, because the selection function is stable under A-substitution and p(~sθ↓X ) ./ > and p(~tθ′↓X ) 6./ must be selected in Dθ↓X and (p(~s) 6./ > ∨ F ′)θ′↓X respectively. Consequently, the Superposition rule applies on [p(~s) ./ >∨D′ |Y] and [p(~t) 6./ >∨ F ′ | Z], yielding [(D′ ∨ F ′) |Y ∪ Z ∪ U ]µ. The A-clause [D′θ ∨ F ′θ′ |X ] is thus redundant in S, hence E ∨ F is redundant in Φ(S,X ).\n2. Otherwise, p(a1, . . . , an) 6./ > ∨ F must be of type 4, F must be positive and elementary, and by the same reasoning as before we can prove that X contains a clause p(b′1, . . . , b′n) 6./ >, such that either [p(a1, . . . , an) 6./ >∨F |{p(b′1, . . . , b′n) 6./ >}] is a tautology (Case (iii)) or there exist an Aclause [p(~s′) 6./ >∨D′′ |Y ′] and a substitution θ′ with ~s′θ′↓X = (a1, . . . , an), D′′↓X θ ⊆ F and Y ′θ ⊆ {p(b′1, . . . , b′n) ./ >} (Case (iv)). By Proposition 63, Case (iii) can only occur if (a1, . . . , an) = (b′1, . . . , b′n) Also, we note that Cases (i) and (iii) cannot hold simultaneously (otherwise we would have (b1, . . . , bn) = (a1, . . . , an) = (b′1, . . . , b′n) hence X would contain both p(a1, . . . , an) ./ > and p(a1, . . . , an) 6./ > and would be thus unsatisfiable). By symmetry, we may assume that (i) does not hold. Then:\n• In Case (iii), we can apply the A-Assertion rule on [p(~s) ./ >∨D′ |Y], yielding [D′ | Y ∪ {p(~s) 6./ >}]. Since (a1, . . . , an) = (b′1, . . . , b′n), we have Yθ ∪ {(p(~s↓X ) 6./ >)θ} ⊆ {p(b1, . . . , bn) ./ >, p(b′1, . . . , b′n) 6./ >} ⊆ X and D′θ ⊆ E is thus redundant in Φ(S,X ).\n• In Case (iv), it is easy to check that we can apply theA-Superposition rule on [p(~s) ./ > ∨D′ | Y] and [p(~s′) 6./ > ∨D′′ | Y ′], yielding an Aclause of the form [D′∨D′′ |Y ∪Y ′∪U ]µ, where (µ,U) is more general than (θ ∪ θ′,X ). Then E ∨ F is redundant in Φ(S,X ).\nClauses of type 1.\nAll inferences involving a clause of type 2, 3 or 4 have already been considered, we now focus on inferences involving only clauses of type 1. We assume the Superposition rule is applied; the proof for the unary inference rules is similar. Let C = u ' v ∨ D and E = t ./ s ∨ F be two clauses of type 1 in Φ(S,X ). Assume that the Superposition rule applies from C into E, upon the terms u and t|p, yielding t[v]p ./ s∨F ∨D, where t|p = u, u v, t s, u ' v ∈ selΦ(C) and t ./ s ∈ selΦ(E). Note that this implies that u ' v is strictly maximal in C. We prove that the clause t[v]p ./ s ∨ F ∨D is redundant in Φ(S,X ). Note that by definition of selΦ, t ./ s cannot be β 6' >. By definition, S contains\ntwo A-clauses C ′ = [u′ ' v′ ∨D′ |Y] and E′ = [t′ ./ s′ ∨ F ′ |Z] and there exist substitutions σ and θ such that:\n• u′σ↓X = u, v′σ↓X = v, D′σ↓X ∨D′′ = D, Yσ ⊆ X and D′′ ⊆ {β 6' >},\n• t′θ↓X = t, s′θ↓X = s, F ′θ↓X ∨ F ′′ = F , Zθ ⊆ X and F ′′ ⊆ {β 6' >}.\nFirst assume that there is a strict prefix q of p such that t′|q is a variable x. Then x cannot occur in Z, since otherwise xθ would be a constant in A (because Zθ ⊆ X ), and q would not be a strict prefix of p. Let θ′ be the substitution coinciding with θ, except for the value of x, and such that xθ′ is obtained from xθ by replacing all occurrences of u by v. Since θ and θ′ coincide on all the variables in Z, necessarily Zθ′ ⊆ X . Furthermore, since (t′ ./ s′∨F ′)θ′ is A-flat and positive exactly when (t′ ./ s′ ∨F ′)θ is A-flat and positive, we deduce that (t′ ./ s′ ∨ F ′)θ′↓X ∨ F ′′ ∈ Φ(S,X ), and this clause is such that\n(t′ ./ s′ ∨ F ′)θ′↓X ∨ F ′′, u ' v ∨D |= (t′ ./ s′ ∨ F ′)θ↓X ∨ F ′′ ∨D, u ' v ∨D = t ./ s ∨ F ∨D,u ' v ∨D |= t[v]p ./ s ∨ F ∨D.\nIf (t′ ./ s′ ∨ F ′)θ′↓X ∨ F ′′ = t[v]p ./ s ∨ F ∨ D then t[v]p ./ s ∨ F ∨ D occurs in Φ(S,X ) hence the proof is completed. Otherwise (t′ ./ s′ ∨ F ′)θ′↓X ∨ F ′′ ≺ t[u]p ./ s∨F . If p 6= ε or ./= 6', then necessarily u ' v ≺ t[u]p ./ s, since u v. Furthermore, D ≺ u ' v, hence (t′ ./ s′ ∨ F ′)θ′↓X ∨ F ′′, u ' v ∨ D ≺ t[u]p ./ s ∨ F , and the clause t[v]p ./ s ∨ F ∨ D is therefore a logical consequence of clauses of Φ(S,X ) that are strictly smaller than one of its premises, the proof is thus completed.\nIf p = ε and ./=', then E = u ' s ∨ F , and the generated clause is v ' s∨D∨F . If v = s then this clause is a tautology, and is trivially redundant in Φ(S,X ). Otherwise, assume w.l.o.g. that v ≺ s (since the same inference can be performed by considering E as the “from” premise, the two parent clauses play symmetric rôles), then u ' v ≺ u ' s, and as in the previous case, the clause v ' s∨F ∨D is therefore a logical consequence of clauses that are strictly smaller than one of its premises.\nNow assume that there is no strict prefix q of p such that t′|q is a variable x. Necessarily, pmust be a position in t′. Since u = t|p, we have u′σ ∼XA t′|pθ, hence u′ and t′|p are A-unifiable. Let (η,X ′) be a most general A-unifier of u′ and t′|p. Since (σθ,X ) is an A-unifier of u′ and t′|p we have X ′ ⊆ X and there exists a substitution η′ such that ηη′ ∼XA σθ. Since u′σ↓X = u v = v′σ↓X , we have v′η 6 A u′η, and similarly, t′η 6 A s′η. Furthermore, since the selection function sel is stable by A-substitution, (t′ ./ s′)η and (u′ ' v′)η must be selected in C ′η and E′η respectively. Thus the A-Superposition rule applied to C ′ and E′, generates [(t′[v′]p ./ s′∨D′∨F ′)η |(Y∪Z)η∪X ′]. Since S is SA≺sel-saturated, this clause is A-redundant in S, and so is [(t′[v′]p ./ s′∨D′∨F ′)ηη′ |(Y∪Z)ηη′∪X ′].\nSuppose that (t′[v′]p ./ s′ ∨ D′ ∨ F ′)ηη′ is A-flat and quasi-positive. If [(t′[v′]p ./ s\n′ ∨D′ ∨ F ′)ηη′ |(Y ∪Z)ηη′ ∪X ′] is a tautology, then by Proposition 63 (t′[v′]p ./ s′ ∨D′ ∨ F ′)ηη′↓X either is a tautology or contains a literal A ./\n> occurring in X . In both cases, (t′[v′]p ./ s′ ∨D′ ∨ F ′)ηη′↓X is redundant in Φ(S,X ) Otherwise, by Definition 19, S contains an A-clause [G | U ] and there exists a substitution µ such that Gµ ⊆ (t′[v′]p ./ s′ ∨ D′ ∨ F ′)ηη′ and Uµ ⊆ (Y ∪ Z)ηη′ ∪ X ′ ⊆ X . The clause Gµ must be positive and A-flat, hence by Case 1 of Definition 30, Φ(S,X ) contains Gµ↓X ∨2 = Gµ, and Gµ ⊆ (t′[v′]p ./ s\n′ ∨D′ ∨ F ′)ηη′↓X = t[v]p ./ s ∨D ∨ F . If (t′[v′]p ./ s′ ∨D′ ∨ F ′)ηη′ is not A-flat or not quasi-positive, then there\nexist n A-clauses [C1 |X1], . . . , [Cn |Xn] and substitutions γ1, . . . , γn such that:\n• ∀i ∈ [1, n]Xiγi ⊆ (Y ∪ Z)ηη′ ∪ X ′,\n• X ′′, C1γ1, . . . , Cnγn |= (t′[v′]p ./ s′ ∨D′ ∨ F ′)ηη′,\n• (t′[v′]p ./ s′ ∨D′ ∨ F ′)ηη′↓X A C1γ1, . . . , Cnγn.\nSince X ′′ ⊆ X , we deduce that X , C1γ1, . . . , Cnγn |= (t′[v′]p ./ s′ ∨ D′ ∨ F ′)ηη′. Also, by definition of A, we have C1γ1↓X , . . . , Cnγn↓X (t′[v′]p ./ s ′ ∨D′ ∨ F ′)ηη′↓X . But since X1γ, . . . ,Xnγ ⊆ (Y ∪ Z)ηη ′ ∪ X ′ ⊆ X , Φ(S,X ) contains clauses of the form Ciγi↓X ∨ Gi (1 ≤ i ≤ n), where Gi ⊆ {β 6' >}. By Proposition 66, X is a logical consequence of a subset of Φ2(S,X ) ∪ Φ3(S,X ) ∪ Φ4(S,X ) ∪ Φ5(S,X ) that contains no occurrence of β. Since (t′[v′]p ./ s′ ∨ D′ ∨ F ′)ηη′ is either not A-flat or not positive, t[v]p ./ s ∨ F ∨ D contains β 6' >, and must be strictly greater than all clauses of type 2, 3, 4 or 5 that do not contain any occurrence of β. Thus (t′[v′]p ./ s ′ ∨D′ ∨ F ′)ηη′↓X = t[v]p ./ s ∨ F ∨D is redundant in Φ(S,X )."
    }, {
      "heading" : "C Proof of Corollary 39",
      "text" : "Let S′ be the smallest set of (standard ground) clauses such that S′ contains all clauses C satisfying the following properties:\n• C is generated by one of the rules in SP≺selΦ from Φ(S,X ) ∪ S ′.\n• C is not a logical consequence of the set of clauses in Φ(S,X ) ∪ S′ that are strictly smaller than the maximal premise of C.\nLet S′′ = Φ(S,X ) ∪ S′. Intuitively, S′′ is the SA≺sel-closure of Φ(S,X ) modulo redundancy. By definition S′′ must be unsatisfiable and weakly SP≺sel-saturated, hence S′′ contains the empty clause. For any term t, we denote by P+(t) the set of positive clauses in Φ(S,X ) that contain no term s t. We prove that the clauses in S′ are A-flat and of the form c ' a′ ∨ a 6' b ∨ C ′, where:\n1. C ′ is positive,\n2. c a′, a′ a and a′ b,\n3. P+(c) |= C ′ ∨ a ' a′ ∨ b ' a′,\n4. Φ(S,X ) contains a positive A-flat clause C ′′ ⊆ c ' a ∨ c ' b ∨D of type 1 such that {D} ∪ P+(c) |= C ′ and D C ′.\nThis immediately implies that 2 6∈ S′, hence that 2 ∈ Φ(S,X ). The proof is by structural induction on S′. Let C ∈ S′. Note that C cannot be redundant in Φ(S,X ), by definition of S′ since the conclusion of an inference rule cannot be greater than its maximal premise.\n• Assume that C is derived by the Reflection inference rule. Then, since Φ(S,X ) is weakly saturated under Reflection, the parent of C must occur in S′, hence by the induction hypothesis, it must be of the form c ' a′∨a 6' b ∨C ′, where Φ(S,X ) contains a clause C ′′ ⊆ c ' a ∨ c ' b ∨D such that {D} ∪P+(c) |= C ′, P+(c) |= C ′ ∨ a ' a′ and D C ′. By definition of the Reflection rule we have a = b and by Proposition 65 the clause c ' a ∨D is necessarily redundant in Φ(S,X ). But C = c ' a′ ∨ C ′ is redundant in {c ' a ∨D} ∪ P+(c) by Condition 3 above, since a = b. Therefore, C is redundant in Φ(S,X ), which is impossible.\n• Assume that C is derived by Factorization. Then C is of the form c ' a ∨ a 6' b ∨ C ′, and its parent is c ' a ∨ c ' b ∨ C ′. Note that this parent clause must be positive, otherwise c ' a would not be selected, and that it is of type 1. Thus, it cannot occur in S′, and c ' a∨ c ' b∨C ′ ∈ Φ(S,X ). It is simple to verify that the induction hypothesis holds on C.\n• Assume that C is generated by a Superposition from C1 into C2. Then one of the premises is necessarily in S′, and by the induction hypothesis, it contains a negative literal. Since a positive literal is selected in the first premise of the inference rule, we deduce that C1 = a ' d∨C ′1, where a d, C2 = c ' a′∨a 6' b∨C ′2, and C = c ' a′∨b 6' d∨C ′1∨C ′2. Note that C1 must be of type 1; furthermore, a 6= b, since otherwise the Reflection rule would apply upon C2, c ' a′∨C ′2 would be redundant in Φ(S,X ) and so would C. We prove that C verifies the induction hypothesis.\n1. Since C1 is a positive clause and C ′2 is positive by the induction hypothesis, it is clear that C ′1 ∨ C ′2 is positive. 2. Since a′ a d, we have c a′, a′ b and a′ d. 3. By the induction hypothesis, P+(c) |= C ′2 ∨ a ' a′ ∨ b ' a′. Since c a′ a d, we deduce that C1 ∈ P+(c), and therefore P+(c) |= C ′2 ∨ C ′1 ∨ d ' a′ ∨ b ' a′. 4. By the induction hypothesis, there is a positive clause C ′′2 ∈ Φ(S,X ) of type 1 such that C ′′2 ⊆ c ' a∨c ' b∨D2, where {D2}∪P+(c) |= C ′2 and D2 C ′2. If C ′′2 does not contain literal c ' a, then the proof is immediate, by letting C ′′ def= C ′′2 and D def = D2. Otherwise, C ′′2 is\nof the form c ' a ∨ E, where E ⊆ c ' b ∨ D2. If a is superposable in c ' a ∨ E, then by Lemma 64, there is a clause in Φ(S,X ) that is contained in c ' d ∨ C ′1 ∨ E ⊆ c ' b ∨ c ' d ∨ C ′1 ∨ D2, and the proof is completed. Otherwise, by Proposition 62, since C ′′2 is of type\n1, Φ(S,X ) contains a clause c ' d ∨ E′, where E′ is obtained from E by replacing some occurrences of a by d. Since E ⊆ c ' b ∨ D2 and a 6= b, c, we deduce that E′ ⊆ c ' b ∨ D′2, for a clause D′2 obtained from D2 by replacing some occurrences of a by d. Since a ' d∨C ′1 ∈ P+(c), we deduce that {D′2} ∪P+(c) |= C ′1 ∨D2, hence {D′2}∪P+(c) |= C ′1∨C ′2. Now a d, so that D′2 D2 C ′2, and the clause d ' c ∨E′ ⊆ d ' c ∨ b ' c ∨D′2 fulfills the required property."
    }, {
      "heading" : "D Proof of Lemma 56",
      "text" : "The proof is based on the following results:\nProposition 68 If (σ, E) is a most general A-unifier of t ' s, then for all X such that E ⊆ X , t↓X and s↓X are unifiable, and σ↓X is a most general unifier of t↓X ' s↓X .\nProof. 23 This is because if (S, θ,X ) and (S′, θ′,X ′) are A-unification problems such that (S, θ,X )→ (S′, θ′,X ′), then for all A-sets Y such that X ′ ⊆ Y, we have S↓Y → S′↓Y for the standard unification rules. The proof follows by a straightforward induction.\nSince terms that are ∼A-equivalent cannot be distinguished by EA and selA, we have the following result.\nProposition 69 Let C = [t ./ s ∨D |X ] be an A-clause, where t ./ s ∈ sel(t ./ s ∨ D) and t 6 A s. Let σ be a ground X -pure substitution of domain var(X ). If tσ ∼A t′, then t′ 6EA sσ and (t′ ./ sσ) ∈ selA(t′ ./ sσ ∨Dσ).\nProposition 70 Let µ be an m.g.u. of t ' s.\n• If µ1, µ2 are such that dom(µ1) ∩ dom(µ2) = ∅ and µ = µ1µ2, then µ2 is an m.g.u. of tµ1 ' sµ1.\n• Let σ be a substitution such that dom(σ) ⊆ var(t ' s) and dom(σ) ∩ dom(µ) = ∅. Then the restriction of µσ to dom(µ) is an m.g.u. of tσ ' sσ.\nProof. 24 Since tµ1µ2 = tµ = sµ = sµ1µ2, it is clear that tµ1 and sµ1 are unifiable. If δ is a unifier of of tµ1 ' sµ1, then tµ1δ = sµ1δ, hence µ1δ is a unifier of t ' s, and is therefore an instance of µ = µ1µ2, thus δ is an instance of µ2. This proves that µ2 is an m.g.u. of tµ1 ' sµ1.\nThe second point is a consequence of the fact that for any unification problem, if S → S′, then Sσ → S′σ. The result is proved by induction on the transformation of the unification problem {t ' s}.\nWe prove that if the A-Superposition rule applied to C,D generates E, then for all E′ ∈ Γ(E,U), there exists C ′ ∈ Γ(C,U) and D′ ∈ Γ(D,U) such that E′\ncan be derived from C ′, D′,U by SA≺sel. The proof for the other inference rules is similar. We let\nC = [u ' v ∨ C1 |X ], D = [t ./ s ∨D1 |Y], E = [(t[v]p ./ s ∨ C1 ∨D1)µ |Z],\nwhere (µ, E) is an (X ∪Y)-pure most general A-unifier of u ' t|p and Z = (X ∪ Y∪E)µ. Up to a renaming, we may assume that var(Z) ⊆ var(X∪Y), so that for all x ∈ dom(µ)∩var(X ∪Y), xµ ∈ A∪var(X ∪Y). Let E′ ∈ Γ({[E |Z]} ,Z), and let σ be the Z-pure substitution of domain var(Z) such that σ↓U = σ, Zσ ⊆ U and E′ = Eσ. We let C def= dom(µ)∩ var(X ∪Y) and define µ1 as the restriction of µ to C and µ2 as the restriction of µ to dom(µ) \\ C, so that µ = µ1 ] µ2. Consider the substitution δ def= µ1σ. It is clear that δ is a ground (X ∪ Y)-pure substitution of domain var(X ∪ Y), and that Xµ1,Yµ1 ⊆ Zσ ⊆ U , therefore, C ′ def = Cδ ∈ Γ({[C |X ]} ,U) and D′ def= Dδ ∈ Γ({[D |Y]} ,U). The clause C ′ is of the form u1 ' v1 ∨ C ′1, and the clause D′ of the form t1 ./ s1 ∨D′1, where:\n• u1 = uδ, v1 = vδ and C ′1 = C1δ,\n• t1 = tδ, s1 = sδ and D′1 = D1δ.\nLet t′1 def = t1↓U |p and u′1 def = u1↓U . By Proposition 69, t1 ./ s1 and u1 ' v1 are selected in C ′ and D′ respectively, and we have t1 6CA s1, u1 6CA v1. Thus, there is an SA≺sel-derivation from {C ′}∪U that generates the clause u′1 ' v1∨C ′1, and an SA≺sel-derivation from {D′} ∪ U that generates t1[t′1]p ./ s1 ∨D′1: it suffices to use repeated applications of the Superposition rule from equations in U to replace every constant a occurring in u1 or t1|p by a↓U . Note that u′1 ' v1 and t1[t ′ 1]p ./ s1 are both selected and that u′1 6CA v1 and t1[t′1]p 6CA s1. We prove that t′1 and u′1 are unifiable. For i = 1, 2, let γi def = µi↓U , and let γ def = γ1]γ2. By Proposition 68, since (µ, E) is a most general A-unifier of t|p ' s and E ⊆ U , γ is a most general unifier of (t|p)↓U ' u↓U . By Proposition 70, γ2 is an m.g.u. of (t|p)↓Uγ1 ' u↓Uγ1, and the restriction ν of γ2σ to dom(γ2) is an m.g.u. of (t|p)↓Uγ1σ ' u↓Uγ1σ. But we have\n(t|p)↓Uγ1σ = (tµ1σ)|p↓U = (tδ)|p↓U = t ′ 1,\nand similarly, u↓Uγ1σ = u′1. Since t′1 and u′1 are unifiable with m.g.u. ν, the Superposition rule applied to u′1 ' v1 ∨ C ′1 and t1[t′1]p ./ s1 ∨D′1 generates the clause F def= (t1[v1]p ./ s1 ∨ C ′1 ∨D′1)ν, and:\nF = (t1[v1]p ./ s1 ∨ C ′1 ∨D′1)ν = (t[v]pδ ./ sδ ∨ C ′δ ∨D′δ)ν = (t[v]p ./ s ∨ C ′ ∨D′)µ1σν.\nWe now prove that for any variable x, we have xµ1σν = xµσ. First assume that x /∈ dom(µ1). If x ∈ var(X ∪ Y), then necessarily x ∈ var(Z), and therefore,\nxµ = x and x ∈ dom(σ). Thus, xµ1σν = xσν = xσ = xµσ. Otherwise, since dom(σ) ⊆ var(X ∪ Y), necessarily xσ = x and xµ1σν = xσν = xν. If x ∈ dom(ν) then xν = xµσ by definition of ν, otherwise, since x /∈ dom(µ1) ] dom(µ2) = dom(µ), we deduce that xν = x = xµ = xµσ. Now assume that x ∈ dom(µ1). Then xµ1 = xµ, and if xµ ∈ A, then xµ1σν = xµ = xµσ. Otherwise xµ ∈ var(Z) = dom(σ), hence xµσγ = xµσ.\nFor the second part of the lemma, let E def= [E′ |Z] and suppose that Γ(E,U) contains a clause E′γ′ (with γ′↓U = γ′) that is strongly redundant in Γ(S,U). Let σ be a ground substitution of the variables in [E′ |Z] such that Zσ ⊆ U . We show that [E′ |Z]σ is A-redundant in S. We assume, w.l.o.g., that σ = σ↓X . Let γ and θ be the restrictions of σ to var(X ) and dom(θ) \\ var(X ) respectively. By definition we have dom(γ) = var(X ) = dom(γ′), hence E′γ′ ∼A Eγ. Since E′γ′ is strongly redundant in Γ(S,U) we deduce that E′γθ = E′σ is A-redundant in S. Since S is a set of standard clauses, this entails that Eσ is also A-redundant."
    } ],
    "references" : [ {
      "title" : "Superposition modulo linear arithmetic sup(la)",
      "author" : [ "E Althaus", "E Kruglov", "C Weidenbach" ],
      "venue" : "FroCoS 2009, Springer, LNCS,",
      "citeRegEx" : "Althaus et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Althaus et al\\.",
      "year" : 2009
    }, {
      "title" : "A rewriting approach to satisfiability procedures. Information and Computation",
      "author" : [ "A Armando", "S Ranise", "M Rusinowitch" ],
      "venue" : null,
      "citeRegEx" : "Armando et al\\.,? \\Q2003\\E",
      "shortCiteRegEx" : "Armando et al\\.",
      "year" : 2003
    }, {
      "title" : "New results on rewritebased satisfiability procedures",
      "author" : [ "A Armando", "MP Bonacina", "S Ranise", "S Schulz" ],
      "venue" : "ACM Transactions on Computational Logic",
      "citeRegEx" : "Armando et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Armando et al\\.",
      "year" : 2009
    }, {
      "title" : "Term Rewriting and All That",
      "author" : [ "F Baader", "T Nipkow" ],
      "venue" : null,
      "citeRegEx" : "Baader and Nipkow,? \\Q1998\\E",
      "shortCiteRegEx" : "Baader and Nipkow",
      "year" : 1998
    }, {
      "title" : "Rewrite-based equational theorem proving with selection and simplification",
      "author" : [ "L Bachmair", "H Ganzinger" ],
      "venue" : "Journal of Logic and Computation",
      "citeRegEx" : "Bachmair and Ganzinger,? \\Q1994\\E",
      "shortCiteRegEx" : "Bachmair and Ganzinger",
      "year" : 1994
    }, {
      "title" : "Refutational theorem proving for hierarchic first-order theories. Applicable Algebra in Engineering, Communication and Computing",
      "author" : [ "L Bachmair", "H Ganzinger", "U Waldmann" ],
      "venue" : null,
      "citeRegEx" : "Bachmair et al\\.,? \\Q1994\\E",
      "shortCiteRegEx" : "Bachmair et al\\.",
      "year" : 1994
    }, {
      "title" : "Hierarchic superposition with weak abstraction",
      "author" : [ "P Baumgartner", "U Waldmann" ],
      "venue" : null,
      "citeRegEx" : "Baumgartner and Waldmann,? \\Q2013\\E",
      "shortCiteRegEx" : "Baumgartner and Waldmann",
      "year" : 2013
    }, {
      "title" : "Automated Deduction - CADE-24 - 24th International Conference on Automated Deduction, Lake Placid",
      "author" : [ "MP Bonacina" ],
      "venue" : "NY, USA, June 9-14,",
      "citeRegEx" : "Bonacina,? \\Q2013\\E",
      "shortCiteRegEx" : "Bonacina",
      "year" : 2013
    }, {
      "title" : "Automated Model Building",
      "author" : [ "R Caferra", "A Leitsch", "N Peltier" ],
      "venue" : "Applied Logic Series,",
      "citeRegEx" : "Caferra et al\\.,? \\Q2004\\E",
      "shortCiteRegEx" : "Caferra et al\\.",
      "year" : 2004
    }, {
      "title" : "An improved incremental algorithm for generating prime implicates",
      "author" : [ "J De Kleer" ],
      "venue" : "Proceedings of the National Conference on Artificial Intelligence,",
      "citeRegEx" : "Kleer,? \\Q1992\\E",
      "shortCiteRegEx" : "Kleer",
      "year" : 1992
    }, {
      "title" : "A (2010) Small formulas for large programs: On-line constraint simplification in scalable static analysis",
      "author" : [ "I Dillig", "T Dillig", "Aiken" ],
      "venue" : "Lecture Notes in Computer Science,",
      "citeRegEx" : "Dillig et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Dillig et al\\.",
      "year" : 2010
    }, {
      "title" : "Minimum satisfying assignments for smt",
      "author" : [ "I Dillig", "T Dillig", "KL McMillan", "A Aiken" ],
      "venue" : "Lecture Notes in Computer Science,",
      "citeRegEx" : "Dillig et al\\.,? \\Q2012\\E",
      "shortCiteRegEx" : "Dillig et al\\.",
      "year" : 2012
    }, {
      "title" : "The YICES SMT-solver",
      "author" : [ "D Dutertre", "L de Moura" ],
      "venue" : "In SMT-COMP: Satisfiability Modulo Theories Competition. Available at http://yices.csl.sri.com",
      "citeRegEx" : "Dutertre and Moura,? \\Q2006\\E",
      "shortCiteRegEx" : "Dutertre and Moura",
      "year" : 2006
    }, {
      "title" : "A Calculus for Generating Ground Explanations",
      "author" : [ "M Echenim", "N Peltier" ],
      "venue" : "Proceedings of the International Joint Conference on Automated Reasoning (IJCAR’12), Springer LNCS,",
      "citeRegEx" : "Echenim and Peltier,? \\Q2012\\E",
      "shortCiteRegEx" : "Echenim and Peltier",
      "year" : 2012
    }, {
      "title" : "An approach to abductive reasoning in equational logic",
      "author" : [ "M Echenim", "N Peltier", "S Tourret" ],
      "venue" : "Proceedings of IJCAI’13 (International Conference on Artificial Intelligence),",
      "citeRegEx" : "Echenim et al\\.,? \\Q2013\\E",
      "shortCiteRegEx" : "Echenim et al\\.",
      "year" : 2013
    }, {
      "title" : "The prime normal form of boolean formulas",
      "author" : [ "L Henocque" ],
      "venue" : "Technical report at http://wwwIsisorg/fichephp",
      "citeRegEx" : "Henocque,? \\Q2002\\E",
      "shortCiteRegEx" : "Henocque",
      "year" : 2002
    }, {
      "title" : "Computing prime implicants",
      "author" : [ "P Jackson", "J Pais" ],
      "venue" : "10th International Conference on Automated Deduction,",
      "citeRegEx" : "Jackson and Pais,? \\Q1990\\E",
      "shortCiteRegEx" : "Jackson and Pais",
      "year" : 1990
    }, {
      "title" : "An incremental method for generating prime implicants/implicates",
      "author" : [ "A Kean", "G Tsiknis" ],
      "venue" : "Journal of Symbolic Computation",
      "citeRegEx" : "Kean and Tsiknis,? \\Q1990\\E",
      "shortCiteRegEx" : "Kean and Tsiknis",
      "year" : 1990
    }, {
      "title" : "Equality and abductive residua for horn clauses",
      "author" : [ "E Knill", "P Cox", "T Pietrzykowski" ],
      "venue" : "Theoretical Computer Science",
      "citeRegEx" : "Knill et al\\.,? \\Q1992\\E",
      "shortCiteRegEx" : "Knill et al\\.",
      "year" : 1992
    }, {
      "title" : "The resolution calculus",
      "author" : [ "A Leitsch" ],
      "venue" : "Springer. Texts in Theoretical Computer Science",
      "citeRegEx" : "Leitsch,? \\Q1997\\E",
      "shortCiteRegEx" : "Leitsch",
      "year" : 1997
    }, {
      "title" : "Automatic Decidability",
      "author" : [ "C Lynch", "B Morawska" ],
      "venue" : "Proc. of 17th IEEE Symposium on Logic in Computer Science (LICS’2002),",
      "citeRegEx" : "Lynch and Morawska,? \\Q2002\\E",
      "shortCiteRegEx" : "Lynch and Morawska",
      "year" : 2002
    }, {
      "title" : "Automatic decidability and combinability",
      "author" : [ "C Lynch", "S Ranise", "C Ringeissen", "DK Tran" ],
      "venue" : "Information and Computation",
      "citeRegEx" : "Lynch et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Lynch et al\\.",
      "year" : 2011
    }, {
      "title" : "Extending abduction from propositional to first-order logic",
      "author" : [ "P Marquis" ],
      "venue" : "Lecture Notes in Computer Science,",
      "citeRegEx" : "Marquis,? \\Q1991\\E",
      "shortCiteRegEx" : "Marquis",
      "year" : 1991
    }, {
      "title" : "Prime implicate tries. Automated Reasoning with Analytic Tableaux and Related Methods pp",
      "author" : [ "A Matusiewicz", "N Murray", "E Rosenthal" ],
      "venue" : null,
      "citeRegEx" : "Matusiewicz et al\\.,? \\Q2009\\E",
      "shortCiteRegEx" : "Matusiewicz et al\\.",
      "year" : 2009
    }, {
      "title" : "Tri-based set operations and selective computation of prime implicates",
      "author" : [ "A Matusiewicz", "N Murray", "E Rosenthal" ],
      "venue" : "Foundations of Intelligent Systems",
      "citeRegEx" : "Matusiewicz et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Matusiewicz et al\\.",
      "year" : 2011
    }, {
      "title" : "First order abduction via tableau and sequent calculi",
      "author" : [ "MC Mayer", "F Pirri" ],
      "venue" : "Logic Journal of the IGPL",
      "citeRegEx" : "Mayer and Pirri,? \\Q1993\\E",
      "shortCiteRegEx" : "Mayer and Pirri",
      "year" : 1993
    }, {
      "title" : "Computer programs for checking mathematical proofs",
      "author" : [ "J McCarthy" ],
      "venue" : "Recursive Function Theory, Proc. of Symposia in Pure Mathematics,",
      "citeRegEx" : "McCarthy,? \\Q1962\\E",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1962
    }, {
      "title" : "Yet another decision procedure for equality logic",
      "author" : [ "O Meir", "O Strichman" ],
      "venue" : "Proceedings of the 17th International Conference on Computer Aided Verification,",
      "citeRegEx" : "Meir and Strichman,? \\Q2005\\E",
      "shortCiteRegEx" : "Meir and Strichman",
      "year" : 2005
    }, {
      "title" : "Paramodulation-based theorem proving",
      "author" : [ "R Nieuwenhuis", "A Rubio" ],
      "venue" : "Handbook of Automated Reasoning,",
      "citeRegEx" : "Nieuwenhuis and Rubio,? \\Q2001\\E",
      "shortCiteRegEx" : "Nieuwenhuis and Rubio",
      "year" : 2001
    }, {
      "title" : "Efficient consequence finding",
      "author" : [ "L Simon", "A Del Val" ],
      "venue" : "Proceedings of the 17th International Joint Conference on Artificial Intelligence,",
      "citeRegEx" : "Simon and Val,? \\Q2001\\E",
      "shortCiteRegEx" : "Simon and Val",
      "year" : 2001
    }, {
      "title" : "Hierarchical reasoning for the verification of parametric systems",
      "author" : [ "V Sofronie-Stokkermans" ],
      "venue" : "IJCAR, Springer, LNCS,",
      "citeRegEx" : "Sofronie.Stokkermans,? \\Q2010\\E",
      "shortCiteRegEx" : "Sofronie.Stokkermans",
      "year" : 2010
    }, {
      "title" : "Hierarchical reasoning and model generation for the verification of parametric hybrid systems",
      "author" : [ "V Sofronie-Stokkermans" ],
      "venue" : null,
      "citeRegEx" : "Sofronie.Stokkermans,? \\Q2013\\E",
      "shortCiteRegEx" : "Sofronie.Stokkermans",
      "year" : 2013
    }, {
      "title" : "Generalization of consensus theory and application to the minimization of boolean functions",
      "author" : [ "P Tison" ],
      "venue" : "Electronic Computers, IEEE Transactions on 4:446–456",
      "citeRegEx" : "Tison,? \\Q1967\\E",
      "shortCiteRegEx" : "Tison",
      "year" : 1967
    }, {
      "title" : "Combination of convex the",
      "author" : [ "DK Tran", "C Ringeissen", "S Ranise", "H Kirchner" ],
      "venue" : null,
      "citeRegEx" : "Tran et al\\.,? \\Q2010\\E",
      "shortCiteRegEx" : "Tran et al\\.",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 4,
      "context" : "In order to compute such implicates, we devise a variant of the Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) that is deductive-complete for the considered set of abducible constants, i.",
      "startOffset" : 87,
      "endOffset" : 146
    }, {
      "referenceID" : 28,
      "context" : "In order to compute such implicates, we devise a variant of the Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) that is deductive-complete for the considered set of abducible constants, i.",
      "startOffset" : 87,
      "endOffset" : 146
    }, {
      "referenceID" : 32,
      "context" : "The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011).",
      "startOffset" : 64,
      "endOffset" : 142
    }, {
      "referenceID" : 17,
      "context" : "The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011).",
      "startOffset" : 64,
      "endOffset" : 142
    }, {
      "referenceID" : 16,
      "context" : "The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011).",
      "startOffset" : 226,
      "endOffset" : 297
    }, {
      "referenceID" : 15,
      "context" : "The earlier approaches use refinements of the resolution method (Tison, 1967; Kean and Tsiknis, 1990; De Kleer, 1992; Simon and Del Val, 2001), while more recent and more efficient proposals use decomposition-based procedures (Jackson and Pais, 1990; Henocque, 2002; Matusiewicz et al, 2009, 2011).",
      "startOffset" : 226,
      "endOffset" : 297
    }, {
      "referenceID" : 22,
      "context" : "from sets of first-order clauses by using the resolution rule (Marquis, 1991).",
      "startOffset" : 62,
      "endOffset" : 77
    }, {
      "referenceID" : 22,
      "context" : "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic.",
      "startOffset" : 63,
      "endOffset" : 269
    }, {
      "referenceID" : 22,
      "context" : "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning.",
      "startOffset" : 63,
      "endOffset" : 801
    }, {
      "referenceID" : 22,
      "context" : "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formulæ that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories.",
      "startOffset" : 63,
      "endOffset" : 1495
    }, {
      "referenceID" : 22,
      "context" : "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formulæ that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories. This approach is closer to ours, since it is based on the Superposition calculus, hence handles equality in an efficient way; however it is very focused: indeed, it is well-known that the Superposition calculus is not deductive-complete in general, for instance it cannot generate the clause a 6' b from the clause f(a) 6' f(b), although f(a) 6' f(b) |= a 6' b. While the previous approaches rely on usual complete proof procedures for first-order logic, more recent work builds on the recent developments and progresses in the field of Satisfiability Modulo Theories by devising algorithms relying on theory-specific decision procedures. Sofronie-Stokkermans (2010, 2013) devises a technique for generating abductive explanations in local extensions of decidable theories. The approach reduces the considered problem to a formula in the basic theory by instantiating the axioms of the extension. Dillig, Dillig, McMillan, and Aiken (2012) generate an incomplete set of implicants of formulæ interpreted in decidable theories by combining quantifier-elimination (for discarding useless variables) with model building tools (to construct sufficient conditions for satisfiability).",
      "startOffset" : 63,
      "endOffset" : 2553
    }, {
      "referenceID" : 22,
      "context" : "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formulæ that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories. This approach is closer to ours, since it is based on the Superposition calculus, hence handles equality in an efficient way; however it is very focused: indeed, it is well-known that the Superposition calculus is not deductive-complete in general, for instance it cannot generate the clause a 6' b from the clause f(a) 6' f(b), although f(a) 6' f(b) |= a 6' b. While the previous approaches rely on usual complete proof procedures for first-order logic, more recent work builds on the recent developments and progresses in the field of Satisfiability Modulo Theories by devising algorithms relying on theory-specific decision procedures. Sofronie-Stokkermans (2010, 2013) devises a technique for generating abductive explanations in local extensions of decidable theories. The approach reduces the considered problem to a formula in the basic theory by instantiating the axioms of the extension. Dillig, Dillig, McMillan, and Aiken (2012) generate an incomplete set of implicants of formulæ interpreted in decidable theories by combining quantifier-elimination (for discarding useless variables) with model building tools (to construct sufficient conditions for satisfiability). In contrast to these approaches, our method is proof-theoretic, hence it is generic and self-sufficient. The drawback is that it requires the adaptation of usual theorem provers instead of using them as black boxes (see also Example 52 for a comparison of our method with the simplification technique devised by Dillig et al (2012)).",
      "startOffset" : 63,
      "endOffset" : 3125
    }, {
      "referenceID" : 22,
      "context" : "from sets of first-order clauses by using the resolution rule (Marquis, 1991). However, when dealing with equational clause sets, the addition of equality axioms leads to inefficiency and divergence in almost all but trivial cases. Knill, Cox, and Pietrzykowski (1992) use a proof technique called surface resolution for generating implicates of Horn clauses in equational logic. The proposed approach, based on a systematic flattening of the terms and on the application of the resolution principle with substitutivity axioms, is very general and has some nice theoretical properties, but it is also very inefficient. The search space is huge, because the systematic abstraction of every subterm destroys all ordering or unifiability constraints, and termination is very rare. Mayer and Pirri (1993) describe a tableaux-based (or, dually, a sequent-based) proof procedure for abductive reasoning. The intuitive idea is to apply the usual decomposition rules of propositional logic, and then compute the formulæ that force the closure of all open branches in the tableaux, thus yielding sufficient conditions ensuring unsatisfiability. The approach can be extended to first-order logic, by relying on reverse skolemization techniques in order to eliminate the Skolem symbols introduced inside the branches for handling existential quantifiers. Again, this approach is not well-suited for handling equality, and no termination results are presented. Tran, Ringeissen, Ranise, and Kirchner (2010) show that the Superposition calculus can be used to generate positive and unit implicates for some specific theories. This approach is closer to ours, since it is based on the Superposition calculus, hence handles equality in an efficient way; however it is very focused: indeed, it is well-known that the Superposition calculus is not deductive-complete in general, for instance it cannot generate the clause a 6' b from the clause f(a) 6' f(b), although f(a) 6' f(b) |= a 6' b. While the previous approaches rely on usual complete proof procedures for first-order logic, more recent work builds on the recent developments and progresses in the field of Satisfiability Modulo Theories by devising algorithms relying on theory-specific decision procedures. Sofronie-Stokkermans (2010, 2013) devises a technique for generating abductive explanations in local extensions of decidable theories. The approach reduces the considered problem to a formula in the basic theory by instantiating the axioms of the extension. Dillig, Dillig, McMillan, and Aiken (2012) generate an incomplete set of implicants of formulæ interpreted in decidable theories by combining quantifier-elimination (for discarding useless variables) with model building tools (to construct sufficient conditions for satisfiability). In contrast to these approaches, our method is proof-theoretic, hence it is generic and self-sufficient. The drawback is that it requires the adaptation of usual theorem provers instead of using them as black boxes (see also Example 52 for a comparison of our method with the simplification technique devised by Dillig et al (2012)). Wernhard (2013) proposes a method to derive abductive explanations from first-order logical programs, under several distinct non-classical semantics, using a reduction to second-order quantifier-elimination.",
      "startOffset" : 63,
      "endOffset" : 3143
    }, {
      "referenceID" : 13,
      "context" : "The present paper is a thoroughly expanded and revised version of (Echenim and Peltier, 2012).",
      "startOffset" : 66,
      "endOffset" : 93
    }, {
      "referenceID" : 13,
      "context" : "2 for more details on the relationship of SAsel with the calculus in (Echenim and Peltier, 2012).",
      "startOffset" : 69,
      "endOffset" : 96
    }, {
      "referenceID" : 4,
      "context" : "In this section we define an extension of the standard Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) with which it is possible to generate all A-flat implicates of a considered clause set.",
      "startOffset" : 78,
      "endOffset" : 137
    }, {
      "referenceID" : 28,
      "context" : "In this section we define an extension of the standard Superposition calculus (Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001) with which it is possible to generate all A-flat implicates of a considered clause set.",
      "startOffset" : 78,
      "endOffset" : 137
    }, {
      "referenceID" : 28,
      "context" : "When applied to standard clauses (with A = ∅), this notion of redundancy coincides with the usual criterion (see for instance Bachmair and Ganzinger, 1994; Nieuwenhuis and Rubio, 2001).",
      "startOffset" : 108,
      "endOffset" : 184
    }, {
      "referenceID" : 4,
      "context" : "5 See (Bachmair and Ganzinger, 1994) or (Nieuwenhuis and Rubio, 2001, theorem 4.",
      "startOffset" : 6,
      "endOffset" : 36
    }, {
      "referenceID" : 13,
      "context" : "SARsel essentially simulates the calculus in (Echenim and Peltier, 2012), but there are some important differences: in particular our previous approach does not handle variable-active axioms and is complete only for implicates containing no predicate symbol other than '.",
      "startOffset" : 45,
      "endOffset" : 72
    }, {
      "referenceID" : 13,
      "context" : "The next theorem states a form of completeness for the restricted calculus SARsel, which is weaker than that of the calculus SA ≺ sel (compare with Theorem 40) and similar to that of (Echenim and Peltier, 2012).",
      "startOffset" : 183,
      "endOffset" : 210
    }, {
      "referenceID" : 6,
      "context" : "This can be done for instance by combining our approach with existing techniques for fusing the Superposition calculus and external reasoning tools (Bachmair et al, 1994; Althaus et al, 2009; Baumgartner and Waldmann, 2013).",
      "startOffset" : 148,
      "endOffset" : 223
    }, {
      "referenceID" : 6,
      "context" : "In other approaches (Bachmair et al, 1994; Althaus et al, 2009; Baumgartner and Waldmann, 2013) the constraints are used to store formulæ that cannot be handled by the Superposition calculus, whereas in our case they are used to store properties that are asserted instead of being proved.",
      "startOffset" : 20,
      "endOffset" : 95
    } ],
    "year" : 2014,
    "abstractText" : "We present a modification of the Superposition calculus that is meant to generate consequences of sets of first-order axioms. This approach is proven to be sound and deductive-complete in the presence of redundancy elimination rules, provided the considered consequences are built on a given finite set of ground terms, represented by constant symbols. In contrast to other approaches, most existing results about the termination of the Superposition calculus can be carried over to our procedure. This ensures in particular that the calculus is terminating for many theories of interest to the SMT community.",
    "creator" : "LaTeX with hyperref package"
  }
}