{
  "name" : "1602.04498.pdf",
  "metadata" : {
    "source" : "META",
    "title" : "Extending Consequence-Based Reasoning to SRIQ",
    "authors" : [ "Andrew Bate", "Boris Motik", "Bernardo Cuenca Grau", "František Simančı́k", "Ian Horrocks" ],
    "emails" : [ "firstname.lastname@cs.ox.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "1 Introduction Description logics (DLs) (Baader et al. 2003) are a family of knowledge representation formalisms with numerous applications in practice. DL-based applications model a domain of interest by means of an ontology, in which key notions in the domain are described using concepts (i.e., unary predicates), and the relationships between concepts are described using roles (i.e., binary predicates). Subsumption is the problem of determining whether each instance of a concept C is also an instance of a conceptD in all models of an ontology, and it is a fundamental reasoning problem in applications of DLs. For expressive DLs, this problem is of high worst-case complexity, ranging from EXPTIME up to N2EXPTIME.\nDespite these discouraging complexity bounds, highly optimised reasoners such as FaCT++ (Tsarkov and Horrocks 2006), Pellet (Sirin et al. 2007), HermiT (Glimm et al. 2014), and Konclude (Steigmiller, Liebig, and Glimm 2014) have proved successful in practice. These systems are typically based on (hyper)tableau calculi, which construct a finite representation of a canonical model of the ontology disproving a postulated subsumption. While such calculi can handle many ontologies, in some cases they construct very large model representations, which is a source of performance problems; this is further exacerbated by the large number of subsumption tests often required to classify an ontology.\nA recent breakthrough in DL reasoning came in the form of consequence-based calculi. The reasoning algorithm by Baader, Brandt, and Lutz (2005) for the lightweight logic EL can be seen as the first such calculus. It was later extended to the more expressive DLs Horn-SHIQ (Kazakov 2009) and\nHorn-SROIQ (Ortiz, Rudolph, and Simkus 2010)—DLs that support counting quantifiers, but not disjunctions between concepts. Consequence-based calculi were also developed for ALCH (Simančı́k, Kazakov, and Horrocks 2011) and ALCI (Simančı́k, Motik, and Horrocks 2014), which support concept disjunction, but not counting quantifiers. Such calculi can be seen as combining resolution and hypertableau (see Section 3 for details): as in resolution, they describe ontology models by systematically deriving relevant consequences; and as in (hyper)tableau, they are goaldirected and avoid drawing unnecessary consequences. Additionally, they are not only refutationally complete, but can also (dis)prove all relevant subsumptions in a single run, which can greatly reduce the overall computational work. Finally, unlike implemented (hyper)tableau reasoners, they are worst-case optimal for the logic they support. Steigmiller, Glimm, and Liebig (2014) presented a way of combining a consequence-based calculus with a traditional tableau-based prover; while such a combination seems to perform well in practice, the saturation rules are only known to be complete for EL ontologies, and the overall approach is not worst-case optimal for SRIQ.\nExisting consequence-based algorithms cannot handle DLs such as ALCHIQ that provide both disjunctions and counting quantifiers. As we argue in Section 3, extending these algorithms to handle such DLs is challenging: counting quantifiers require equality reasoning which, together with disjunctions, can impose complex constraints on ontology models; and, unlike existing consequence-based calculi, such constraints cannot be captured using DLs themselves, which makes the reasoning process much more involved.\nIn Section 4 we present a consequence-based calculus for ALCHIQ; by using the encoding of role chains by Kazakov (2008), our calculus can also handle SRIQ, which covers all of OWL 2 DL except for nominals, reflexive roles, and datatypes. Borrowing ideas from resolution theorem proving, we encode the calculus’ consequences as first-order clauses of a specific form, and we handle equality using a variant of ordered paramodulation (Nieuwenhuis and Rubio 1995)—a state of the art calculus for equational theorem proving used in modern theorem provers such as E (Schulz 2002) and Vampire (Riazanov and Voronkov 2002). Furthermore, we have carefully constrained the inference rules so that our calculus mimics existing calculi on ELH ontolo-\nar X\niv :1\n60 2.\n04 49\n8v 3\n[ cs\n.A I]\n2 3\nFe b\n20 16\ngies, which ensures robust performance of our calculus on ‘mostly-ELH’ ontologies.\nWe have implemented a prototype system and compared its performance with that of well-established reasoners. Our results in Section 5 suggest that our system can significantly outperform FaCT++, Pellet, or HermiT, and often exhibits comparable performance to that of Konclude.\n2 Preliminaries First-Order Logic. It is usual in equational theorem proving to encode atomic formulas as terms, and to use a multisorted signature that prevents us from considering malformed terms. Thus, we partition the signature into a set P of predicate symbols and a set F of function symbols; moreover, we assume that P has a special constant ℘. A term is constructed as usual using variables and the signature symbols, with the restriction that predicate symbols are allowed to occur only at the outermost level; the latter terms are calledP-terms, while all other terms areF-terms. For example, for P a predicate and f a function symbol, f(P (x)) and P (P (x)) are both malformed; P (f(x)) is a well-formed Pterm; and f(x) and x are both well-formed F-terms. Term f(t) is an f -successor of t, and t is an f -predecessor of f(t).\nAn equality is a formula of the form s ≈ t, where s and t are either both F- or both P-terms. An equality of the form P (~s) ≈ ℘ is called an atom and is written as just P (~s) whenever it is clear from the context that the expression denotes a formula, and not a P-term. An inequality is a negation of an equality and is written as s 6≈ t. We assume that≈ and 6≈ are implicitly symmetric—that is, s ./ t and t ./ s are identical, for ./ ∈ {≈, 6≈}. A literal is an equality or an inequality. A clause is a formula of the form ∀~x.[Γ→ ∆] where Γ is a conjunction of atoms called the body, ∆ is a disjunction of literals called the head, and ~x contains all variables occurring in the clause; quantifier ∀~x is usually omitted as it is understood implicitly. We often treat conjunctions and disjunctions as sets (i.e., they are unordered and without repetition) and use them in standard set operations; and we write the empty conjunction (disjunction) as > (⊥). For α a term, literal, clause, or a set thereof, we say that α is ground if it does not contain a variable; ασ is the result of applying a substitution σ to α; and we often write substitutions as σ = {x 7→ t1, y 7→ t2, . . .}. We use the standard notion of subterm positions; s|p is the subterm of s at position p; position p is proper in a term t if t|p 6= t; and s[t]p is the term obtained by replacing the subterm of s at position p with t.\nA Herbrand equality interpretation is a set of ground equalities satisfying the usual congruence properties. Satisfaction of a ground conjunction, a ground disjunction, or a (not necessarily ground) clause α in an interpretation I , written I |= α, as well as entailment of a clause Γ→ ∆ from a set of clauses O, written O |= Γ→ ∆, are defined as usual. Note that a ground disjunction of literals ∆ may contain inequalities so I |= ∆ does not necessarily imply I ∩∆ 6= ∅.\nUnless otherwise stated, (possibly indexed) letters x, y, and z denote variables; l, r, s, and t denote terms;A denotes an atom or a P-term (depending on the context); L denotes a literal; f and g denote function symbols; B denotes a unary predicate symbol; and S denotes a binary predicate symbol.\nOrders. A strict order on a universe U is an irreflexive, asymmetric, and transitive relation on U ; and is the non-strict order induced by . Order is total if, for all a, b ∈ U , we have a b, b a, or a = b. Given ◦ ∈ { , }, element b ∈ U , and subset S ⊆ U , the notation S ◦ b abbreviates ∃a ∈ S : a ◦ b. The multiset extension mul of compares multisets M and N on U such that M mul N if and only if M 6= N and, for each n ∈ N \\M , some m ∈M \\N exists such that m n, where \\ is the multiset difference operator.\nA term order is a strict order on the set of all terms. We extend to literals by identifying each s 6≈ t with the multiset {s, s, t, t} and each s ≈ t with the multiset {s, t}, and by comparing the result using the multiset extension of . We reuse the symbol for the induced literal order since the intended meaning should be clear from the context.\nDL-Clauses. Our calculus takes as input a set O of DLclauses—that is, clauses restricted to the following form. Let P1 and P2 be countable sets of unary and binary predicate symbols, and letF be a countable set of unary function symbols. DL-clauses are written using the central variable x and variables zi. A DL-F-term has the form x, zi, or f(x) with f ∈ F ; a DL-P-term has the form B(zi), B(x), B(f(x)), S(x, zi), S(zi, x), S(x, f(x)), S(f(x), x) with B ∈ P1 and S ∈ P2; and a DL-term is a DL-F-term or a DL-P-term. A DL-atom has the form A ≈ ℘ with A a DL-P-term. A DL-literal is a DL-atom, or it is of the form f(x) ./ g(x), f(x) ./ zi, or zi ./ zj with ./ ∈ {≈, 6≈}. A DL-clause contains only DL-atoms of the form B(x), S(x, zi), and S(zi, x) in the body and only DL-literals in the head, and each variable zi occurring in the head also occurs in the body. An ontology O is a finite set of DL-clauses. A query clause is a DL-clause in which all literals are of the form B(x). Given an ontology O and a query clause Γ→ ∆, our calculus decides whether O |= Γ→ ∆ holds. SRIQ ontologies written using the DL-style syntax can be transformed into DL-clauses without affecting query clause entailment. First, we normalise DL axioms to the form shown on the left-hand side of Table 1: we transform away role chains and then replace all complex concepts with fresh atomic ones; this process is well understood (Kazakov 2009; 2008; Simančı́k, Motik, and Horrocks 2014), so we omit the details. Second, using the well-known correspondence between DLs and first-order logic (Baader et al. 2003), we translate normalised axioms to DL-clauses as shown on the right-hand side of Table 1. The standard translation of B1 v 6nS.B2 requires atoms B2(zi) in clause bodies, which are not allowed in our setting. We address this issue by introducing a fresh role SB2 that we axiomatise as S(y, x) ∧B2(x)→ SB2(y, x); this, in turn, allows us to clausify the original axiom as if it were B1 v 6nSB2 . For an ELH ontology, O contains DL-clauses of type DL1 with m = n+ 1, DL2 with n = 1, DL3, and DL5.\n3 Motivation As motivation for our work, in Section 3.1 we discuss the drawbacks of existing DL reasoning calculi, and then in Section 3.2 we discuss how existing consequence-based calculi\nTable 1: Translating Normalised ALCHIQ Ontologies into DL-Clauses\nDL1\nd 1≤i≤n\nBi v\n⊔\nn+1≤i≤m Bi\n∧\n1≤i≤n Bi(x)→\n∨\nn+1≤i≤m Bi(x)\nDL2 B1 v >nS.B2 B1(x)→ S(x, fi(x)) for 1 ≤ i ≤ n B1(x)→ B2(fi(x)) for 1 ≤ i ≤ n B1(x)→ fi(x) 6≈ fj(x) for 1 ≤ i < j ≤ n\nDL3 ∃S.B1 v B2 S(z1, x) ∧B1(x)→ B2(z1)\nDL4 B1 v 6nS.B2 S(z1, x) ∧B2(x)→ SB2(z1, x) for fresh SB2 B1(x) ∧ ∧\n1≤i≤n+1 SB2(x, zi)→ ∨ 1≤i<j≤n+1 zi ≈ zj\nDL5 S1 v S2 S1(z1, x)→ S2(z1, x)\naddress these problems by separating clauses into contexts in a way that considerably reduces the number of inferences. Next, in Section 3.3 we discuss the main contribution of this paper, which lies in extending the consequence-based framework to a DL with disjunctions and number restrictions. Handling the latter requires equality reasoning, which requires a more involved calculus and completeness proof."
    }, {
      "heading" : "3.1 Why Consequence-Based Calculi?",
      "text" : "Consider the EL ontology O1 in Figure 1; one can readily check thatO |= Bi(x)→ Ci(x) holds for 0 ≤ i ≤ n. To proveO |= B0(x)→ C0(x) using the (hyper)tableau calculus, we start with B0(a) and apply (1)–(4) in a forwardchaining manner. Since O contains (1) for j ∈ {1, 2}, this constructs a tree-shaped model of depth n and a fanout of two, where nodes at depth i are labelled by Bi and Ci. Forward chaining ensures that reasoning is goal-oriented; however, all nodes labelled with Bi are of the same type and they share the same properties, which reveals a weakness of (hyper)tableau calculi: the constructed models can be large (exponential in our example) and highly redundant; apart from causing problems in practice, this often prevents (hyper)tableau calculi from being worst-case optimal. Techniques such as caching (Goré and Nguyen 2007) or any-\nwhere blocking (Motik, Shearer, and Horrocks 2009) can constrain model construction, but their effectiveness often depends on the order of rule applications. Thus, model size is a key limiting factor for (hyper)tableau-based reasoners (Motik, Shearer, and Horrocks 2009).\nIn contrast, resolution describes models using (universally quantified) clauses that ‘summarise’ the model. This eliminates redundancy and ensures worst-case optimality of many resolution decision procedures. Many resolution variants have been proposed (Bachmair and Ganzinger 2001), each restricting inferences in a specific way. However, to ensure termination, all decision procedure for DLs we are aware of perform inferences with the ‘deepest’ and the ‘covering’ clause atoms, so all of them will resolve all (1) with all (4) to obtain all 2n2 clauses of the form\nBi(x) ∧ Ck+1(fi+1,j(x))→ Ck(x) for 1 ≤ i, k < n and 1 ≤ j ≤ 2. (21)\nOf these 2n2 clauses, only those with i = k are relevant to proving our goal. If we extendO with additional clauses that contain Bi and Ci, each of these 2n2 clauses can participate in further inferences and give rise to more irrelevant clauses. This problem is particularly pronounced when O is satisfiable since we must then produce all consequences of O."
    }, {
      "heading" : "3.2 Basic Notions",
      "text" : "Consequence-based calculi combine ‘summarisation’ of resolution with goal-directed search of (hyper)tableau calculi. Simančı́k, Motik, and Horrocks (2014) presented a framework for ALCI capturing the key elements of the related calculi by Baader, Brandt, and Lutz (2005), Kazakov (2009), Ortiz, Rudolph, and Simkus (2010), and Simančı́k, Kazakov, and Horrocks (2011). Before extending this framework to ALCHIQ in Section 4, we next informally recapitulate the basic notions; however, to make this paper easier to follow, we use the same notation and terminology as in Section 4.\nOur consequence-based calculus constructs a directed graph D = 〈V, E ,S, core, 〉 called a context structure. The vertices in V are called contexts. Let I be a Herbrand model ofO; hence, the domain of I contains ground terms. Instead of representing each ground term of I separately as in (hyper)tableau calculi, D can represent the properties of several terms by a single context v. Each context v ∈ V is associated with a (possibly empty) conjunction corev of core atoms that must hold for all ground terms that v represents; thus, corev determines the ‘kind’ of context v. Moreover, v is associated with a set Sv of clauses that capture the constraints that these terms must satisfy. Partitioning clauses into sets allows us to restrict the inferences between clause sets and thus eliminate certain irrelevant inferences. Clauses in Sv are ‘relative’ to corev: for each Γ→ ∆ ∈ Sv , we have O |= corev ∧ Γ→ ∆—that is, we do not include corev in clause bodies since corev holds implicitly. Function provides each context v ∈ V with a concept order v that restricts resolution inferences in the presence of disjunctions.\nContexts are connected by directed edges labelled with function symbols. If u is connected to v via an f -labelled edge, then the f -successor of each ground term represented by u is represented by v. Conversely, if u and v are not connected by an f -edge, then each ground term represented by v is not an f -successor of a ground term represented by u, so no inference between Su and Sv is ever needed.\nConsequence-based calculi are not just complete for refutation: they derive the required consequences. Figure 1 demonstrates this forO1 |= B0(x)→ C0(x). The cores and the clauses shown above and below, respectively, each context, and clause numbers correspond to the derivation order. To prove B0(x)→ C0(x), we introduce context vB0(x) with core B0(x) and add clause (5) to it. The latter says that B0 holds for a, and it is analogous to initialising a (hyper)tableau calculus with B0(a). The calculus then applies rules from Table 2 to derive new clauses and/or extend D. Hyper is the standard hyperresolution rule restricted to a single context at a time. Thus, we derive (6) from (1) and (5), and (7) from (2) and (5). Hyperresolution resolves all body atoms, which makes the resolvent relevant for the context and prevents the derivation of irrelevant clauses such as (21).\nContext vB0(x) contains atoms with function symbols f1,1 and f1,2, so the Succ rule must ensure that the f1,1- and f1,2-successors of the ground terms represented by vB0(x) are adequately represented in D. We can control context introduction via a parameter called an expansion strategy—a function that determines whether to reuse an existing con-\ntext or introduce a fresh one; in the latter case, it also determines how to initialise the context’s core. We discuss possible strategies in Section 4.1; in the rest of this example, we use the so-called cautious strategy, where the Succ rule introduces context vB1(x) and initialises it with (10) and (11). Note that (6) represents two clauses, both of which we satisfy (in separate applications of the Succ rule) using vB1(x).\nWe construct contexts vB2(x), . . . , vBn(x) analogously, we derive (16) by hyperresolving (3) and (14), and we derive (17) by hyperresolving (4), (14), and (16). Clause (17) imposes a constraint on the predecessor context, which we propagate using the Pred rule, deriving (19) and (20). Since clauses of vB0(x) are ‘relative’ to the core of vB0(x), clause (20) represents our query clause, as required.\n3.3 Extending the Framework to ALCHIQ In all consequence-based calculi presented thus far, the constraints that the ground terms represented by a context v must satisfy can be represented using standard DL-style axioms. For example, for ALCI, Simančı́k, Motik, and Horrocks (2014) represented all relevant consequences using DL axioms of the following form:\nl Bi v ⊔ Bj t ⊔ ∃Sk.Bk t ⊔ ∀S`.B` (55)\nALCHIQ provides both counting quantifiers and disjunctions, the interplay of which may impose constraints that cannot be represented in ALCHIQ. Let O2 be as in Figure 2. To see that O2 |= B0(x)→ B4(x) holds, we construct a Herbrand interpretation I from B0(a): (22) and (23) derive S(f1(a), a) and B1(f1(a)); and (25) and (26) derive S(f1(a), f2(f1(a))) and B2(f2(f1(a))), and S(f1(a), f3(f1(a))) and B3(f3(f1(a))). Due to (27) we derive B4(f2(f1(a))) and B4(f3(f1(a))). Finally, from (28) we derive the following clause:\nf2(f1(a)) ≈ a ∨ f3(f1(a)) ≈ a ∨ f3(f1(a)) ≈ f2(f1(a)) (56)\nDisjunct f3(f1(a)) ≈ f2(f1(a)) cannot be satisfied due to (24); but then, regardless of whether we choose to satisfy f3(f1(a)) ≈ a or f2(f1(a)) ≈ a, we derive B4(a).\nOur calculus must be able to capture constraint (56) and its consequences, but standard DL axioms cannot explicitly refer to specific successors and predecessors. Instead, we capture consequences using context clauses—clauses over terms x, fi(x), and y, where variable x represents the ground terms that a context stands for, fi(x) represents fisuccessors of x, and y represents the predecessor of x. We can thus identify the predecessor and the successors of x ‘by name’, allowing us to capture constraint (56) as\nf2(x) ≈ y ∨ f3(x) ≈ y ∨ f3(x) ≈ f2(x). (57)\nBased on this idea, we adapted the rules by Simančı́k, Motik, and Horrocks (2014) to handle context clauses correctly, and we added rules that capture the consequences of equality. The resulting set of rules is shown in Table 2.\nFigure 2 shows how to verify O2 |= B0(x)→ B4(x) using our calculus; the maximal literal of each clause is shown on the right. We next discuss the inferences in detail.\nWe first create context v0 and initialise it with (29); this ensures that each interpretation represented by the context structure contains a ground term for which B0 holds. Next, we derive (30) and (31) using hyperresolution. At this point, we could hyperresolve (25) and (31) to obtain > → S(f1(x), f2(f1(x))); however, this could easily lead to nontermination of the calculus due to increased term nesting. Therefore, we require hyperresolution to map variable x in the DL-clauses to variable x in the context clauses; thus, hyperresolution derives in each context only consequences about x, which prevents redundant derivations.\nThe Succ rule next handles function symbol f1 in clauses (30) and (31). To determine which information to propagate to a successor, Definition 2 in Section 4 introduces a set Su(O) of successor triggers. In our example, DL-clause (28) contains atoms B1(x) and S(x, zi) in its body, and zi can be mapped to a predecessor or a successor of x; thus, a context in which hyperresolution is applied to (28) will be interested in information about its predecessors, which we reflect by adding B1(x) and S(x, y) to Su(O). In this example we use the so-called eager strategy (see Section 4.1), so the Succ rule introduces context v1, sets its core to B1(x) and S(x, y), and initialises the context with (33) and (34).\nWe next introduce (35)–(38) using hyperresolution, at which point we have sufficient information to apply hyperresolution to (28) to derive (39). Please note how the presence of (33) is crucial for this inference.\nWe use paramodulation to deal with equality in clause\n(39). As is common in resolution-based theorem proving, we order the literals in a clause and apply inferences only to maximal literals; thus, we derive (40).\nClauses (35), (36), and (40) contain function symbol f2, so the Succ rule introduces context v2. Due to clause (36), B2(x) holds for all ground terms that v2 represents; thus, we add B2(x) to corev2 . In contrast, atom B3(f2(x)) occurs in clause (40) in a disjunction, which means it may not hold in v2; hence, we add B3(x) to the body of clause (44). The latter clause allows us to derive (45) using hyperresolution.\nClause (45) essentially says ‘B3(f2(x)) should not hold in the predecessor’, which the Pred rule propagates to v1 as clause (49); one can understand this inference as hyperresolution of (40) and (45) while observing that term f2(x) in context v1 is represented as variable x in context v2.\nAfter two paramodulation steps, we derive clause (51), which essentially says ‘the predecessor must satisfy B2(x) or B3(x)’. The set Pr(O) of predecessor triggers from Definition 2 identifies this as relevant to v0: the DL-clauses in (27) containB2(x) andB3(x) in their bodies, which are represented in v1 as B2(y) and B3(y). Hence Pr(O) contains B2(y) and B3(y), allowing the Pred rule to derive (52).\nAfter two more steps, we finally derive our target clause (54). We could not do this if B4(x) were maximal in (53); thus, we require all atoms in the head of a goal clause to be smallest. A similar observation applies to Pr(O): if B3(y) were maximal in (50), we would not derive (51) and propagate it to v0; thus, all atoms in Pr(O) must be smallest too.\n4 Formalising the Algorithm In this section, we first present our consequence-based algorithm for ALCHIQ formally, and then we present an outline of the completeness proof; full proofs are given in the appendix."
    }, {
      "heading" : "4.1 Definitions",
      "text" : "Our calculus manipulates context clauses, which are constructed from context terms and context literals as described in Definition 1. Unlike in general resolution, we restrict context clauses to contain only variables x and y, which have a special meaning in our setting: variable x represents a ground term in a Herbrand model, and y represents the predecessor of x; this naming convention is important for the rules of our calculus. This is in contrast to the DL-clauses of an ontology, which can contain variables x and zi, and where zi refer to either the predecessor or a successor of x. Definition 1. A context F-term is a term of the form x, y, or f(x) for f ∈ F; a context P-term is a term of the form B(y), B(x), B(f(x)), S(x, y), S(y, x), S(x, f(x)), or S(f(x), x) for B,R ∈ P and f ∈ F; and a context term is an F-term or a P-term. A context literal is a literal of the form A ≈ ℘ (called a context atom), f(x) ./ g(x), or f(x) ./ y, y ./ y, forA a context P-term and ./ ∈ {≈, 6≈}. A context clause is a clause with only function-free context atoms in the body, and only context literals in the head.\nDefinition 2 introduces sets Su(O) and Pr(O), that identify the information that must be exchanged between adjacent contexts. Intuitively, Su(O) contains atoms that are of interest to a context’s successor, and it guides the Succ rule whereas Pr(O) contains atoms that are of interest to a context’s predecessor and it guides the Pred rule. Definition 2. The set Su(O) of successor triggers of an ontology O is the smallest set of atoms such that, for each clause Γ→ ∆ ∈ O, • B(x) ∈ Γ implies B(x) ∈ Su(O), • S(x, zi) ∈ Γ implies S(x, y) ∈ Su(O), and • S(zi, x) ∈ Γ implies S(y, x) ∈ Su(O). The set Pr(O) of predecessor triggers of O is defined as\nPr(O) = {A{x 7→ y, y 7→ x} | A ∈ Su(O) } ∪ {B(y) | B occurs in O}.\nAs in resolution, we restrict the inferences using a term order . Definition 3 specifies the conditions that the order must satisfy. Conditions 1 and 2 ensure that F-terms are compared uniformly across contexts; however, P-terms can be compared in different ways in different contexts. Conditions 1 through 4 ensure that, if we ground the order by mapping x to a term t and y to the predecessor of t, we obtain a simplification order (Baader and Nipkow 1998)— a kind of term order commonly used in equational theorem proving. Finally, condition 5 ensures that atoms that might be propagated to a context’s predecessor via the Pred rule are smallest, which is important for completeness. Definition 3. Let m be a total, well-founded order on function symbols. A context term order is an order on context terms satisfying the following conditions:\n1. for each f ∈ F , we have f(x) x y; 2. for all f, g ∈ F with f m g, we have f(x) g(x); 3. for all terms s1, s2, and t and each position p in t, if s1 s2, then t[s1]p t[s2]p;\n4. for each term s and each proper position p in s, we have s s|p; and 5. for each atom A ≈ ℘ ∈ Pr(O) and each context term s 6∈ {x, y}, we have A 6 s.\nEach term order is extended to a literal order, also written , as described in Section 2.\nA lexicographic path order (LPO) (Baader and Nipkow 1998) over context F-terms and context P-terms, in which x and y are treated as constants such that x y, satisfies conditions 1 through 4. Furthermore, Pr(O) contains only atoms of the form B(y), S(x, y), and S(y, x), which we can always make smallest in the ordering; thus, condition 5 does not contradict the other conditions. Hence, an LPO that is relaxed for condition 5 satisfies Definition 3, and thus, for any given m, at least one context term order exists.\nApart from orders, effective redundancy elimination techniques are critical to efficiency of resolution calculi. Definition 4 defines a notion compatible with our setting.\nDefinition 4. A set of clauses U contains a clause Γ→ ∆ up to redundancy, written Γ→ ∆ ∈̂ U , if\n1. {s ≈ s′, s 6≈ s′} ⊆ ∆ or s ≈ s ∈ ∆ for some terms s and s′, or 2. Γ′ ⊆ Γ and ∆′ ⊆ ∆ for some clause Γ′ → ∆′ ∈ U . Intuitively, if U contains Γ→ ∆ up to redundancy, then\nadding Γ→ ∆ to U will not modify the constraints that U represents because either Γ→ ∆ is a tautology or U contains a stronger clause. Note that tautologies of the form A→ A are not redundant in our setting as they are used to initialise contexts; however, whenever our calculus derives a clause A→ A ∨A′, the set of clauses will have been initialised with A→ A, which makes the former clause redundant by condition 2 of Definition 4. Moreover, clause heads are subjected to the usual tautology elimination rules; thus, clauses γ → ∆ ∨ s ≈ s and Γ→ ∆ ∨ s ≈ t ∨ s 6≈ t can be eliminated. Proposition 1 shows that we can remove from U each clause C that is contained in U \\ {C} up to redundancy; the Elim uses this to support clause subsumption.\nProposition 1. For U a set of clauses and C and C ′ clauses with C ∈̂ U \\ {C} and C ′ ∈̂ U , we have C ′ ∈̂ U \\ {C}.\nWe are finally ready to formalise the notion of a context structure, as well as a notion of context structure soundness. The latter captures the fact that context clauses from a set Sv do not contain corev in their bodies. We shall later show that our inference rules preserve context structure soundness, which essentially proves that all clauses derived by our calculus are indeed conclusions of the ontology in question.\nDefinition 5. A context structure for an ontology O is a tuple D = 〈V, E ,S, core, 〉, where V is a finite set of contexts, E ⊆ V × V × F is a finite set of edges each labelled with a function symbol, function core assigns to each context v a conjunction corev of atoms over the P-terms from\nSu(O), function S assigns to each context v a finite set Sv of context clauses, and function assigns to each context v a context term order v . A context structure D is sound for O if the following conditions both hold.\nS1. For each context v ∈ V and each clause Γ→ ∆ ∈ Sv , we have O |= corev ∧ Γ→ ∆. S2. For each edge 〈u, v, f〉 ∈ E , we have O |= coreu → corev{x 7→ f(x), y 7→ x}.\nDefinition 6 introduces an expansion strategy—a parameter of our calculus that determines when and how to reuse contexts in order to satisfy existential restrictions. Definition 6. An expansion strategy is a function strategy that takes a function symbol f , a set of atoms K, and a context structure D = 〈V, E ,S, core, 〉. The result of strategy(f,K,D) is computable in polynomial time and it is a triple 〈v, core′, ′〉 where core′ is a subset of K; either v /∈ V is a fresh context, or v ∈ V is an existing context inD such that corev = core′; and ′ is a context term order.\nSimančı́k, Motik, and Horrocks (2014) presented two basic strategies, which we can adapt to our setting as follows. • The eager strategy returns for each K1 the context vK1\nwith core K1. The ‘kind’ of ground terms that vK1 represents is then very specific so the set SvK1 is likely to be smaller, but the number of contexts can be exponential.\n• The cautious strategy examines the function symbol f : if f occurs in O in exactly one atom of the form B(f(x)) and if B(x) ∈ K1, then the result is the context vB(x) with core B(x); otherwise, the result is the ‘trivial’ context v> with the empty core. Context vB(x) is then less constrained, but the number of contexts is at most linear.\nSimančı́k, Motik, and Horrocks (2014) discuss extensively the differences between and the relative merits of the two strategies; although their discussion deals with ALCI only, their conclusions apply to SRIQ as well.\nWe are now ready to show soundness and completeness. Theorem 1 (Soundness). For any expansion strategy, applying an inference rule from Table 2 to an ontology O and a context structure D that is sound forO produces a context structure that is sound for O.\nTheorem 2 (Completeness). Let O be an ontology, and let D = 〈V, E ,S, core, 〉 be a context structure such that no inference rule from Table 2 is applicable to O and D. Then, ΓQ → ∆Q ∈̂ Sq holds for each query clause ΓQ → ∆Q and each context q ∈ V that satisfy conditions C1–C3.\nC1. O |= ΓQ → ∆Q. C2. For each atom A ≈ ℘ ∈ ∆Q and each context term\ns 6∈ {x, y}, if A q s, then s ≈ ℘ ∈ ∆Q ∪ Pr(O). C3. For each A ∈ ΓQ, we have ΓQ → A ∈̂ Sq . Conditions C2 and C3 can be satisfied by appropriately initialising the corresponding context. Hence, Theorems 1 and 2 show that the following algorithm is sound and complete for deciding O |= ΓQ → ∆Q.\nA1. Create an empty context structure D and select an expansion strategy.\nTable 2: Rules of the Consequence-Based Calculus\nCore rule\nIf A ∈ corev , and > → A /∈ Sv , then add > → A to Sv . Hyper rule\nIf ∧n i=1Ai → ∆ ∈ O,\nσ is a substitution such that σ(x) = x, Γi → ∆i ∨Aiσ ∈ Sv s.t. ∆i 6 v Aiσ for 1 ≤ i ≤ n, and ∧n i=1 Γi → ∆σ ∨ ∨n i=1 ∆i 6∈̂ Sv ,\nthen add ∧n i=1 Γi → ∆σ ∨ ∨n i=1 ∆i to Sv . Eq rule If Γ1 → ∆1 ∨ s1 ≈ t1 ∈ Sv ,\ns1 v t1 and ∆1 6 v s1 ≈ t1, Γ2 → ∆2 ∨ s2 ./ t2 ∈ Sv with ./ ∈ {≈, 6≈}, s2 v t2 and ∆2 6 v s2 ./ t2, s2|p = s1, and Γ1 ∧ Γ2 → ∆1 ∨∆2 ∨ s2[t1]p ./ t2 6∈̂ Sv ,\nthen add Γ1 ∧ Γ2 → ∆1 ∨∆2 ∨ s2[t1]p ./ t2 to Sv . Ineq rule If Γ→ ∆ ∨ t 6≈ t ∈ Sv and Γ→ ∆ 6∈̂ Sv , then add Γ→ ∆ to Sv . Factor rule If Γ→ ∆ ∨ s ≈ t ∨ s ≈ t′ ∈ Sv , ∆ ∪ {s ≈ t} 6 v s ≈ t′ and s v t′ and Γ→ ∆ ∨ t 6≈ t′ ∨ s ≈ t′ 6∈̂ Sv , then add Γ→ ∆ ∨ t 6≈ t′ ∨ s ≈ t′ to Sv . Elim rule If Γ→ ∆ ∈ Sv and Γ→ ∆ ∈̂ Sv \\ {Γ→ ∆} then remove Γ→ ∆ from Sv . Pred rule If 〈u, v, f〉 ∈ E ,∧l i=1Ai → ∨l+n i=l+1Ai ∈ Sv ,\nΓi → ∆i ∨Aiσ ∈ Su s.t. ∆i 6 u Aiσ for 1 ≤ i ≤ l, Ai ∈ Pr(O) for each l + 1 ≤ i ≤ l + n, and ∧l i=1 Γi → ∨l i=1 ∆i ∨ ∨l+n i=l+1Aiσ 6∈̂ Su,\nthen add ∧l i=1 Γi → ∨l i=1 ∆i ∨ ∨l+n i=l+1Aiσ to Su, where σ = {x 7→ f(x), y 7→ x}. Succ rule If Γ→ ∆ ∨A ∈ Su s.t. ∆ 6 u A and A contains f(x), and, for each A′ ∈ K2 \\ corev , no edge 〈u, v, f〉 ∈ E exists such that A′ → A′ ∈̂ Sv , then let 〈v, core′, ′〉 := strategy(f,K1,D); if v ∈ V , then let v := v ∩ ′, and otherwise let V := V ∪ {v}, v := ′,\ncorev := core ′, and Sv := ∅;\nadd the edge 〈u, v, f〉 to E ; and add A′ → A′ to Sv for each A′ ∈ K2 \\ corev;\nwhere σ = {x 7→ f(x), y 7→ x}, K1 = {A′ ∈ Su(O) | > → A′σ ∈ Su }, and K2 = {A′ ∈ Su(O) | Γ′ → ∆′ ∨A′σ ∈ Su and\n∆′ 6 u A′σ }.\nA2. Introduce a context q intoD; set coreq = ΓQ; for each A ∈ ΓQ, add > → A to Sq to satisfy condition C3; and initialise q in a way that satisfies condition C2.\nA3. Apply the inference rules from Table 2 to D and O. A4. ΓQ → ∆Q holds if and only if ΓQ → ∆Q ∈̂ Sv . Propositions 2 and 3 show that our calculus is worst-case optimal for both ALCHIQ and ELH. Proposition 2. For each expansion strategy that introduces at most exponentially many contexts, algorithm A1–A4 runs in worst-case exponential time.\nProposition 3. For ELH ontologies and queries of the form B1(x)→ B2(x), algorithm A1–A4 runs in polynomial time with either the cautious or the eager strategy; and with the cautious strategy and the Hyper rule applied eagerly, the inferences in step A3 correspond directly to the inferences of the ELH calculus by Baader, Brandt, and Lutz (2005)."
    }, {
      "heading" : "4.2 An Outline of the Completeness Proof",
      "text" : "To prove Theorem 2, we fix an ontology O, a context structure D, a query clause ΓQ → ∆Q, and a context q such that properties C2 and C3 of Theorem 2 are satisfied and ΓQ → ∆Q 6∈̂ Sq holds, and we construct a Herbrand interpretation that satisfies O but refutes ΓQ → ∆Q. We reuse techniques from equational theorem proving (Nieuwenhuis and Rubio 1995) and represent this interpretation by a rewrite system R—a finite set of rules of the form l⇒ r. Intuitively, such a rule says that that any two terms of the form f1(. . . fn(l) . . . ) and f1(. . . fn(r) . . . ) with n ≥ 0 are equal, and that we can prove this equality in one step by rewriting (i.e., replacing) l with r. Rewrite system R induces a Herbrand equality interpretation R∗ that contains each l ≈ r for which the equality between l and r can be verified using a finite number of such rewrite steps. The universe of R∗ consists of F- and P-terms constructed using the symbols in F and P , and a special constant c; for convenience, let T be the set of all F-terms from this universe.\nWe obtainR by unfolding the context structureD starting from context q: we map each F-term t ∈ T to a context Xt in D, and we use the clauses in SXt to construct a model fragment Rt—the part of R that satisfies the DL-clauses of O when x is mapped to t. The key issue is to ensure compatibility between adjacent model fragments: when moving from a predecessor term t′ to a successor term t = f(t′), we must ensure that adding Rt to Rt′ does not affect the truth of the DL-clauses of O at term t′; in other words, the model fragment constructed at t must respect the choices made at t′. We represent these choices by a ground clause Γt → ∆t: conjunction Γt contains atoms that are ‘inherited’ from t′ and so must hold at t, and disjunction ∆t contains atoms that must not hold at t because t′ relies on their absence.\nThe model fragment construction takes as parameters a term t, a context v = Xt, and a clause Γt → ∆t. Let Nt be the set of ground clauses obtained from Sv by mapping x to t and y to the predecessor of t (if it exists), and whose body is contained in Γt. Moreover, let Sut and Prt be obtained from Su(O) and Pr(O) by mapping x to t and y to the predecessor of t if one exists; thus, Sut contains the ground atoms of\ninterest to the successors of t, and Prt contains the ground atoms of interest to the predecessor of t. The model fragment for t can be constructed if properties L1–L3 hold:\nL1. Γt → ∆t 6∈̂ Nt. L2. If t = c, then ∆t = ∆Q; and if t 6= c, then ∆t ⊆ Prt. L3. For each A ∈ Γt, we have Γt → A ∈̂ Nt.\nThe construction produces a rewrite system Rt such that\nF1. R∗t |= Nt, and F2. R∗t 6|= Γt → ∆t—that is, all of Γt, but none of ∆t hold\nin R∗t , and so the model fragment at t is compatible with the ‘inherited’ constraints.\nWe construct rewrite system Rt by adapting the techniques from paramodulation-based theorem proving. First, we order all clauses in Nt into a sequence Ci = Γi → ∆i ∨ Li, 1 ≤ i ≤ n, that is compatible with the context ordering v in a particular way. Next, we initialise Rt to ∅, and then we examine each clauseCi in this sequence; ifCi does not hold in the model constructed thus far, we make the clause true by adding Li to Rt. To prove condition F1, we assume for the sake of a contradiction that a clause Ci with smallest i exists such that R∗t 6|= Ci, and we show that an application of the Eq, Ineq, or Factor rule to Ci necessarily produces a clause Cj such that R∗t 6|= Cj and j < i. Conditions L1 through L3 allow us to satisfy condition F2. Due to condition L2 and condition 5 of Definition 3, we can order the clauses in the sequence such that each clause Ci capable of producing an atom from ∆t comes before any other clause in the sequence; and then we use condition L1 to show that no such clause actually exists. Moreover, condition L3 ensures that all atoms in Γt are actually produced in R∗t .\nTo obtain R, we inductively unfold D, and at each step we apply the model fragment construction to the appropriate parameters. For the base case, we map constant c to context Xc = q, and we define Γc = ΓQ and ∆c = ∆Q; then, conditions L1 and L2 hold by definition, and condition L3 holds by property C3 of Theorem 2. For the induction step, we assume that we have already mapped some term t′ to a context u = Xt′ , and we consider term t = f(t′) for each f ∈ F . • If t does not occur in an atom inRt′ , we letRt = {t⇒ c}\nand thus make t equal to c. Term t is thus interpreted in exactly the same way as c, so we stop the unfolding.\n• If Rt′ contains a rule t⇒ s, then t and s are equal, and so we interpret t exactly as s; hence, we stop the unfolding.\n• In all other cases, the Succ rule ensures that D contains an edge 〈u, v, f〉 such that v satisfies all preconditions of the rule, so we define Xt = v. Moreover, we let Γt = R∗t′ ∩ Sut be the set of atoms that hold at t′ and are relevant to t , and we let ∆t = Prt \\R∗t′ be the set of atoms that do not hold at t′ and are relevant to t. We finally show that such Γt and ∆t satisfy condition L1: otherwise, the Pred rule derives a clause inNt′ that is not true inR∗t′ .\nAfter processing all relevant terms, we let R be the union of all Rt from the above construction. To show that R∗ satisfies O, we consider a DL-clause Γ→ ∆ ∈ O and a substitution τ that makes the clause ground. W.l.o.g. we can\nassume that τ is irreducible by R—that is, it does not contain terms that can we rewritten using the rules in R. Since each model fragment satisfies condition F2, we can evaluate Γτ → ∆τ in R∗τ(x) instead of R\n∗. Moreover, we show that R∗τ(x) |= Γτ → ∆τ holds: if that were not the case, the Hyper rule derives a clause in Nτ(x) that violates condition F1. Finally, we show that the same holds for the query clause ΓQ → ∆Q, which completes our proof.\n5 Evaluation We have implemented our calculus in a prototype system called Sequoia. The calculus was implemented exactly as presented in this paper, with no optimisation other than a suitable indexing scheme for clauses. The system is written in Scala, and it can be used via the command line or the OWL API. It currently handles the SRIQ subset of OWL 2 DL (i.e., it does not support datatypes, nominals, or reflexive roles), for which it supports ontology classification and concept satisfiability; other standard services such as ABox realisation are currently not supported.\nWe have evaluated our system using the methodology by Steigmiller, Liebig, and Glimm (2014) by comparing Se-\nquoia with HermiT 1.3.8, Pellet 2.3.1, FaCT++ 1.6.4, and Konclude 1.6.1. We used all reasoners in single-threaded mode in order to compare the underlying calculi; moreover, Sequoia was configured to use the cautious strategy. All systems, ontologies, and test results are available online.1\nWe used the Oxford Ontology Repository2 from which we excluded 7 ontologies with irregular RBoxes. Since Sequoia does not support datatypes or nominals, we have systematically replaced datatypes and nominals with fresh classes and data properties with object properties, and we have removed ABox assertions. We thus obtained a corpus of 777 ontologies on which we tested all reasoners.\nWe run our experiments on a Dell workstation with two Intel Xeon E5-2643 v3 3.4 GHz processors with 6 cores per processor and 128 GB of RAM running Windows Server 2012 R2. We used Java 8 update 66 with 15 GB of heap memory allocated to each Java reasoner, and a maximum private working set size of 15 GB for each reasoner in native code. In each test, we measured the wall-clock classification time; this excludes parsing time for reasoners based on the OWL API (i.e., HermiT, Pellet, FaCT++, and Sequoia). Each test was given a timeout of 5 minutes. We report the average time over three runs, unless an exception or timeout occurred in one of the three runs, in which case we report failure.\nFigure 3 shows an overview of the classification times for the entire corpus. The y-axis shows the classification times in logarithmic scale, and timeouts are shown as infinity. A number n on the x-axis represents the n-th easiest ontology for a reasoner with ontologies sorted (for that reasoner) in the ascending order of classification time. For example, a point (50, 100) on a reasoner’s curve means that the 50th easiest ontology for that reasoner took 100 ms to classify.\nSequoia could process most ontologies (733 out of 784) in under 10s, which is consistent with the other reasoners. The system was fairly robust, failing on only 22 ontologies; in contrast, HermiT failed on 42, Pellet on 138, FaCT++ on 132, and Konclude on 8 ontologies. Moreover, Sequoia succeeded on 21 ontologies on which all of HermiT, Pellet and FaCT++ failed. Finally, there was one ontology where Sequoia succeeded and all other reasoners failed; this was a hard version of FMA (ID 00285) that uses both disjunctions and number restrictions.\nFigure 4 shows an overview of how each reasoner performed on each type of ontology. We partitioned the ontologies in the following four groups: within a profile of OWL 2 DL (i.e., captured by OWL 2 EL, QL, or RL); Horn but not in a profile; disjunctive but without number restrictions; and disjunctive and with number restrictions. We used the OWL API to determine profile membership, and we identified the remaining three groups after structural transformation. In addition, for each reasoner, we categorise each ontology as either ‘easy’ (< 10s), ‘medium’ (10s to 5min), and ‘hard’ (timeout or exception). The figure depicts a bar for each reasoner and group, where each bar is divided into blocks representing the percentage of ontologies in each of the aforementioned categories of difficulty. For Sequoia, over 98% of\n1http://krr-nas.cs.ox.ac.uk/2015/KR/cr/ 2http://www.cs.ox.ac.uk/isg/ontologies/\nprofile ontologies and over 91% of out-of-profile Horn ontologies are easy, with the remainder being of medium difficulty. Sequoia timed out largely on ontologies containing both disjunctions and equality, and even in this case only Konclude timed out in fewer cases.\nIn summary, although only an early prototype, Sequoia is a competitive reasoner that comfortably outperforms HermiT, Pellet, and FaCT++, and which exhibits a nice payas-you-go behaviour. Furthermore, problematic ontologies seem to mostly contain complex RBoxes or large numbers in cardinality restrictions, which suggests promising directions for future optimisation.\n6 Conclusion and Future Work We have presented the first consequence based calculus for SRIQ—a DL that includes both disjunction and counting quantifiers. Our calculus combines ideas from state of the art resolution and (hyper)tableau calculi, including the use of ordered paramodulation for equality reasoning. Despite its increased complexity, the calculus mimics existing calculi on ELH ontologies. Although it is an early prototype with plenty of room for optimisation, our system Sequoia is competitive with well-established reasoners and it exhibits nice pay-as-you-go behaviour in practice.\nFor future work, we are confident that we can extend the calculus to support role reflexivity and datatypes, thus handling all of OWL 2 DL except nominals. In contrast, handling nominals seems to be much more involved. In fact, adding nominals to ALCHIQ raises the complexity of reasoning to NEXPTIME so a worst-case optimal calculus must be nondeterministic, which is quite different from all consequence-based calculi we are aware of. Moreover, a further challenge is to modify the calculus so that it can effectively deal with large numbers in number restrictions.\nReferences Baader, F., and Nipkow, T. 1998. Term Rewriting and All That. Cambridge University Press. Baader, F.; Calvanese, D.; McGuinness, D.; Nardi, D.; and Patel-Schneider, P. F., eds. 2003. The Description Logic Handbook: Theory, Implementation and Applications. Cambridge University Press. Baader, F.; Brandt, S.; and Lutz, C. 2005. Pushing the EL Envelope. In Kaelbling, L. P., and Saffiotti, A., eds., Proc. of the 19th Int. Joint Conference on Artificial Intelligence (IJCAI 2005), 364–369. Edinburgh, UK: Morgan Kaufmann Publishers. Bachmair, L., and Ganzinger, H. 2001. Resolution Theorem Proving. In Robinson, A., and Voronkov, A., eds., Handbook of Automated Reasoning, volume I. Elsevier Science. chapter 2, 19–99. Glimm, B.; Horrocks, I.; Motik, B.; Stoilos, G.; and Wang, Z. 2014. HermiT: An OWL 2 Reasoner. Journal of Automated Reasoning 53(3):245–269. Goré, R., and Nguyen, L. A. 2007. EXPTIME Tableaux with Global Caching for Description Logics with Transitive Roles, Inverse Roles and Role Hierarchies. In Olivetti,\nN., ed., Proc. of the 16th Int. Conf. on Automated Reasoning with Tableaux and Related Methods (TABLEAUX 2007), volume 4548 of LNCS, 133–148. Aix en Provence, France: Springer. Kazakov, Y. 2008. RIQ and SROIQ are Harder than SHOIQ. In Brewka, G., and Lang, J., eds., Proc. of the 11th Int. Joint Conf. on Principles of Knowledge Representation and Reasoning (KR 2008), 274–284. Sydney, NSW, Australia: AAAI Press. Kazakov, Y. 2009. Consequence-Driven Reasoning for Horn SHIQ Ontologies. In Boutilier, C., ed., Proc. of the 21st Int. Joint Conf. on Artificial Intelligence (IJCAI 2009), 2040– 2045. Motik, B.; Shearer, R.; and Horrocks, I. 2009. Hypertableau Reasoning for Description Logics. Journal of Artificial Intelligence Research 36:165–228. Nieuwenhuis, R., and Rubio, A. 1995. Theorem Proving with Ordering and Equality Constrained Clauses. Journal of Symbolic Computation 19(4):312–351. Ortiz, M.; Rudolph, S.; and Simkus, M. 2010. Worst-Case Optimal Reasoning for the Horn-DL Fragments of OWL 1 and 2. In Lin, F.; Sattler, U.; and Truszczynski, M., eds., Proc. of the 12th Int. Conf. on Knowledge Representation and Reasoning (KR 2010), 269–279. Toronto, ON, Canada: AAAI Press. Riazanov, A., and Voronkov, A. 2002. The design and implementation of VAMPIRE. AI Communications 15(2–3):91– 110. Schulz, S. 2002. E—A Brainiac Theorem Prover. AI Communications 15(2–3):111–126. Simančı́k, F.; Kazakov, Y.; and Horrocks, I. 2011. Consequence-Based Reasoning beyond Horn Ontologies. In Walsh, T., ed., Proc. of the 22nd Int. Joint Conf. on Artificial Intelligence (IJCAI 2011), 1093–1098. Simančı́k, F.; Motik, B.; and Horrocks, I. 2014. Consequence-Based and Fixed-Parameter Tractable Reasoning in Description Logics. Artificial Intelligence 209:29–77. Sirin, E.; Parsia, B.; Cuenca Grau, B.; Kalyanpur, A.; and Katz, Y. 2007. Pellet: A practical OWL-DL reasoner. Journal of Web Semantics 5(2):51–53. Steigmiller, A.; Glimm, B.; and Liebig, T. 2014. Coupling Tableau Algorithms for Expressive Description Logics with Completion-Based Saturation Procedures. In Demri, S.; Kapur, D.; and Weidenbach, C., eds., Proc. of the 7th Int. Joint Conf. on Automated Reasoning (IJCAR 2014), volume 8562 of LNCS, 449–463. Vienna, Austria: Springer. Steigmiller, A.; Liebig, T.; and Glimm, B. 2014. Konclude: System description. Journal of Web Semantics 27:78–85. Tsarkov, D., and Horrocks, I. 2006. FaCT++ Description Logic Reasoner: System Description. In Proc. of the 3rd Int. Joint Conf. on Automated Reasoning (IJCAR 2006), volume 4130 of LNAI, 292–297. Seattle, WA, USA: Springer.\nA Proof of Theorem 1 In this chapter, we show that our calculus is sound, as stated in Theorem 1. The proof is analogous to the soundness proof of ordered superposition (Nieuwenhuis and Rubio 1995). Theorem 1 (Soundness). For any expansion strategy, applying an inference rule from Table 2 to an ontology O and a context structure D that is sound for O produces a context structure that is sound for O.\nProof. Let O be an ontology, let D = 〈V, E ,S, core, 〉 be a context structure that is sound for O, and consider an application of an inference rule from Table 2 to D and O. We show that each clause produced by the rule is a context clause and that it satisfies conditions S1 and S2 of Definition 5. Condition S1 holds obviously for the rules different from Hyper, Eq, and Pred. For condition S2, we rely on soundness of hyperresolution: for arbitrary formulas ω, φi, ψi, and γi, 1 ≤ i ≤ n, we have\n{ n∧ j=1 φj → ω} ∪ ⋃ 1≤i≤n {γi → ψi ∨ φi} |= n∧ i=1 γi → n∨ i=1 ψi ∨ ω. (58)\nTo prove the claim, we consider each rule from Table 2 and assume that the rule is applied to clauses, contexts, and edges as shown in the table; then, we show that the clause produced by the rule satisfies condition S1 of Definition 5; moreover, for the Succ rule, we show in addition that the edge introduced by the rule satisfies condition S2.\n(Core) For each A ∈ corev , we clearly have O |= corev → A. (Hyper) Since D is sound for O, we have O |= corev ∧ Γi → ∆i ∨Aiσ for each i with 1 ≤ i ≤ n. By (58), we have O |= corev ∧ ∧n i=1 Γi → ∨n i=1 ∆i ∨∆σ. Moreover, substitution σ satisfies σ(x) = x, all premises are context clauses, and O contains only DL-clauses; thus, the inference rule can only match an atom S(x, zi) or S(zi, x) in an ontology clause to atoms S(y, x), S(x, y), S(f(x), x) or S(x, f(x)) in the context clause, and so σ(zi) is either y or f(x); thus, the result is a context clause.\n(Eq) Since D is sound for O, properties (59) and (60) hold. Moreover, clause in (61) is a logical consequence of the clauses in (59) and (60), so property (61) holds, as required.\nO |= corev ∧ Γ1 → ∆1 ∨ s1 ≈ t1 (59) O |= corev ∧ Γ2 → ∆2 ∨ s2 ./ t2 (60) O |= corev ∧ Γ1 ∧ Γ2 → ∆1 ∨∆2 ∨ s2[t1]p ./ t2 (61)\nFinally, term s1 is always of the form g(f(x)), term t1 is of the form h(f(x)) or y, and term s2 is of the form g(f(x)), B(g(f(x))), S(f(x), g(f(x))), or S(g(f(x)), f(x)); thus, s2[t1]p is a context term, and so the result is a context clause.\n(Ineq) Since D is sound for O, we have O |= corev ∧ Γ→ ∆ ∨ t 6≈ t; but then, we clearly have O |= corev ∧ Γ→ ∆, as required.\n(Factor) Since D is sound for O, property (62) holds. Moreover, clause in (63) is a logical consequence of the clause in (62), so property (63) holds, as required.\nO |= corev ∧ Γ→ ∆ ∨ s ≈ t ∨ s ≈ t′ (62) O |= corev ∧ Γ→ ∆ ∨ t 6≈ t′ ∨ s ≈ t′ (63)\n(Elim) The resulting context structure contains a subset of the clauses from D, so it is clearly sound for O. (Pred) Let σ = {x 7→ f(x), y 7→ x}. Since D is sound for O, properties (64)–(66) hold. Now clause in (67) is an instance of the clause in (64), so property (67) holds. But then, by (58), properties (64) and (65) imply property (68). Finally, properties (66) and (68) imply property (69), as required.\nO |= corev ∧ ∧m i=1Ai → ∨m+n j=m+1Aj (64)\nO |= coreu ∧ Γi → ∆i ∨Aiσ for 1 ≤ i ≤ m (65) O |= coreu → corevσ (66) O |= corevσ ∧ ∧m i=1Aiσ → ∨m+n j=m+1Ajσ (67)\nO |= corevσ ∧ corev ∧ ∧m i=1 Γi → ∨m+n j=m+1Ajσ (68)\nO |= coreu ∧ ∧m i=1 Γi → ∨m+n j=m+1Ajσ (69)\nFor each m+ 1 ≤ i ≤ m+ n, we have Ai ∈ Pr(O), so Ai is of the form B(y), S(x, y), or S(y, x); but then, the definition of σ ensures that Aiσ is a context atom, as required.\n(Succ) Let σ = {x 7→ f(x), y 7→ x}. For each clause A→ A added to Sv , we clearly have O |= corev ∧A→ A, as required for condition S1 of Definition 5. Moreover, assume that the inference rule adds an edge 〈u, v, fk〉 to E ; since D is sound for O, we have (70); by Definition 6, we have corev ⊆ K1.\nO |= coreu → Aσ for each A ∈ K1 (70) O |= coreu → corevσ (71)\nBut then, property (71) holds, as required for condition S2 of Definition 5.\nB Preliminaries: Rewrite Systems In the proof of Theorem 2 we construct a model of an ontology, which, as is common in equational theorem proving, we represent using a ground rewrite system. We next recapitulate the definitions of rewrite systems, following the presentation by Baader and Nipkow (1998).\nLet T be the set of all ground terms constructed using a distinguished constant c (of sort F), the function symbols from F , and the predicate symbols from P . A (ground) rewrite system R is a binary relation on T . Each pair (s, t) ∈ R is called a rewrite rule and is commonly written as s⇒ t. The rewrite relation→R forR is the smallest binary relation on T such that, for all terms s1, s2, t ∈ T and each (not necessarily proper) position p in t, if s1 ⇒ s2 ∈ R, then t[s1]p →R t[s2]p. Moreover,\n∗→R is the reflexive–transitive closure of→R, and\n∗↔R is the reflexive–symmetric–transitive closure of→R. A term s is irreducible by R if no term t exists such that s→R t; and a literal, clause, or substitution α is irreducible by R if no term occurring in α is irreducible by R. Moreover, term t is a normal form of s w.r.t. R if s ∗↔R t and t is irreducible by R. We consider the following properties of rewrite systems. • R is terminating if no infinite sequence s1, s2, . . . of terms exists such that, for each i, we have si →R si+1. • R is left-reduced if, for each s⇒ t ∈ R, the term s is irreducible by R \\ {s⇒ t}.\n• R is Church-Rosser if, for all terms t1 and t2 such that t1 ∗↔R t2, a term z exists such that t1 ∗→R z and t2 ∗→R z.\nIf R is terminating and left-reduced, then R is Church-Rosser (Baader and Nipkow 1998, Theorem 2.1.5 and Exercise 6.7). If R is Church-Rosser, then each term s has a unique normal form t such that s ∗→R t holds. The Herbrand interpretation induced by a Church-Rosser system R is the set R∗ such that, for all s, t ∈ T , we have s ≈ t ∈ R∗ if and only if s ∗↔R t.\nTerm orders can be used to prove termination of rewrite systems. A term order is a simplification order if the following conditions hold: • for all terms s1, s2, and t, all positions p in t, and all substitutions σ, we have that s1 s2 implies t[s1σ]p t[s2σ]p; and • for each term s and each proper position p in s, we have s s|p. Given a rewrite system R, if a simplification order exists such that s⇒ t ∈ R implies s t, then R is terminating (Baader and Nipkow 1998, Theorems 5.2.3 and 5.4.8), and s→R t implies s t.\nC Proof of Theorem 2 Theorem 2 (Completeness). LetO be an ontology, and letD = 〈V, E ,S, core, 〉 be a context structure such that no inference rule from Table 2 is applicable to O and D. Then, ΓQ → ∆Q ∈̂ Sq holds for each query clause ΓQ → ∆Q and each context q ∈ V that satisfy conditions C1–C3.\nC1. O |= ΓQ → ∆Q. C2. For each atom A ≈ ℘ ∈ ∆Q and each context term s 6∈ {x, y}, if A q s, then s ≈ ℘ ∈ ∆Q ∪ Pr(O). C3. For each A ∈ ΓQ, we have ΓQ → A ∈̂ Sq . In this section, we fix an ontology O, a context structure D = 〈V, E ,S, core, 〉, a context q ∈ V , and a query clause ΓQ → ∆Q such that conditions C3 and C2 of Theorem 2 are satisfied, and we show the contrapositive of condition C1: if ΓQ → ∆Q 6∈̂ Sq , then O 6|= ΓQ → ∆Q. To this end, we construct a rewrite system R such that the induced Herbrand model R∗ satisfies all clauses in O, but not ΓQ → ∆Q. We construct the model using a distinguished constant c, the unary function symbols from F , and the unary and binary predicate symbols from P1 and P2, respectively.\nLet t be a term. If t is of the form t = f(s), then s is the predecessor of t, and t is a successor of s; by these definitions, a constant has no predecessor. The F-neighbourhood of t is the set of F-terms containing t, f(t) with f ∈ F , and the predecessor t′ of t if one exists; the P-neighbourhood of t contains P-termsB(t), S(t, f(t)), S(f(t), t),B(f(t)), and, if t has the predecessor t′, also P-terms S(t′, t), S(t, t′), and B(t′), for all B ∈ P1 and S ∈ P2. Let σt be the substitution such that σt(x) = t and, if t has the predecessor t′, then σt(y) = t′. Finally, for each term t, we define sets of atoms Prt and Sut as follows:\nSut = {Aσt | A ∈ Su(O) and Aσt is ground } (72) Prt = {Aσt | A ∈ Pr(O) and Aσt is ground } (73)"
    }, {
      "heading" : "C.1 Constructing a Model Fragment",
      "text" : "In this section, we show how, given a term t, we can generate a part of the model of O that covers the neighbourhood of t. In the rest of Appendix C.1, we fix the following parameters to the model fragment generation process: • t is a ground F-term, • v is a context in D, • Γt is a conjunction of atoms, and • ∆t is a disjunction of atoms. Let Nt be the set of ground clauses obtained from Sv as follows:\nNt = {Γσt → ∆σt | Γ→ ∆ ∈ Sv, both Γσt and ∆σt are ground, and Γσt ⊆ Γt} We assume that the following conditions hold.\nL1. Γt → ∆t 6∈̂ Nt. L2. If t = c, then ∆t = ∆Q; and if t 6= c, then ∆t ⊆ Prt. L3. For each A ∈ Γt, we have Γt → A ∈̂ Nt. We next construct a rewrite system Rt such that R∗t |= Nt and R∗t 6|= Γt → ∆t holds. Throughout Appendix C.1, we treat the terms in the F-neighbourhood of t as if they were constants. Thus, even though the rewrite system R will contain terms t and f(t), we will not consider terms with further nesting."
    }, {
      "heading" : "C.1.1 Grounding the Context Order",
      "text" : "To construct Rt, we need an order on the terms in the neighbourhood of t that is compatible with v . To this end, let >t be a total, strict, simplification order on the set of ground terms constructed using the F-neighbourhood of t and the predicate symbols in P that satisfies the following conditions for all context terms s1 and s2 such that s1σt and s2σt are both ground, and where t′ is the predecessor of t if it exists.\nO1. s1 v s2 implies s1σt >t s2σt. O2. s1σt ≈ ℘ ∈ ∆t and s1σt >t s2σt and s2σt 6∈ {t, t′} imply s2σt ≈ ℘ ∈ ∆t.\nCondition C2 of Theorem 2 and condition 5 of Definition 3 ensure that the order v on (nonground) context terms can be grounded in a way compatible with condition L2. Moreover, since in this section we treat all F-terms as constants, we can make the P-terms of the form B(t′), S(t′, t), and S(t, t′) smaller than other F- and P-terms (i.e., we do not need to worry about defining the order on the predecessor of t′ or on the ancestors of f(t)). Thus, at least one such order exists, so in the rest of this section we fix an arbitrary such order >t. We extend >t to ground literals (also written >t) by identifying each s 6≈ t with the multiset {s, s, t, t} and each s ≈ t with the multiset {s, t}, and then comparing the result using the multiset extension of the term order (as defined in Section 2). Finally, we further extend >t to disjunctions of ground literals (also written >t) by identifying each disjunction ∨n i=1 Li with the multiset {L1, . . . , Ln} and then comparing the result using the multiset extension of the literal order."
    }, {
      "heading" : "C.1.2 Constructing the Rewrite System Rt",
      "text" : "We arrange all clauses in Nt into a sequence C1, . . . , Cn. Since the body of each Ci is a subset of Γt, no Ci can contain ⊥ in its head as that would contradict condition L1; thus, we can assume that each Ci is of the form Ci = Γi → ∆i ∨ Li where Li >t ∆\ni, literal Li is of the form Li = li ./ ri with ./ ∈ {≈, 6≈}, and li ≥t ri. For the rest of Appendix C.1, we reserve Ci, Γi, ∆i, Li, li, and ri for referring to the (parts of) the clauses in this sequence. Finally, we assume that, for all 1 ≤ i < j ≤ n, we have ∆j ∨ Lj ≥t ∆i ∨ Li.\nWe next define the sequence R0t , . . . , R n t of rewrite systems by setting R 0 t = ∅ and defining each Rit with 1 ≤ i ≤ n induc-\ntively as follows: • Rit = Ri−1t ∪ {li ⇒ ri} if Li is of the form li ≈ ri such that\nR1. (Ri−1t ) ∗ 6|= ∆i ∨ li ≈ ri, R2. li >t ri, R3. li is irreducible by Ri−1t , and R4. s ≈ ri 6∈ (Ri−1t )∗ for each li ≈ s ∈ ∆i;\n• Rit = Ri−1t in all other cases. Finally, let Rt = Rnt ; we call Rt the model fragment for t, v, Γt, and ∆t. Each clause C\ni = Γi → ∆i ∨ li ≈ ri that satisfies the first condition in the above construction is called generative, and the clause is said to generate the rule li ⇒ ri in Rt."
    }, {
      "heading" : "C.1.3 The Properties of the Model Fragment Rt",
      "text" : "Lemma 1. The rewrite system Rt is Church-Rosser.\nProof. To see that Rt is terminating, simply note that, for each rule l⇒ r ∈ Rt, condition R2 ensures l >t r, and that >t is a simplification order.\nTo see that Rt is left-reduced, consider an arbitrary rule l⇒ r ∈ Rt that is added to Rt in step i of the clause sequence. By condition R3, l⇒ r is irreducible by Rit. Now consider an arbitrary rule l′ ⇒ r′ ∈ Rt that is added to Rt at any step j of the construction where j > i. The definition of the clause order implies l′ ≈ r′ ≥t l ≈ r; since l′ >t r′ and l >t r by condition R2, by the definition of the literal order we have l′ ≥t l. Since l⇒ r ∈ Rj−1t , condition R3 ensures l 6= l′, and so we have l′ >t l; consequently, l′ is not a subterm of l, and thus l is irreducible by Rjt .\nLemma 2. For each 1 ≤ i ≤ n and each l 6≈ r ∈ ∆i ∨ Li, we have (Ri−1t )∗ |= l ≈ r if and only if R∗t |= l ≈ r.\nProof. Consider an arbitrary clause Ci = Γi → ∆i ∨ Li and an arbitrary inequality l 6≈ r ∈ ∆i ∨ Li. If l ≈ r ∈ (Ri−1t )∗, then Ri−1t ⊆ Rt implies l ≈ r ∈ R∗t , and so we have R∗t |= l ≈ r, as required. Now assume that l ≈ r 6∈ (Ri−1t )∗. Let l′ and r′ be the normal forms of l and r, respectively, w.r.t.Ri−1t . Now consider an arbitrary j with i ≤ j ≤ n such that lj ⇒ rj is generated by Cj . We then have lj ≈ rj >t l 6≈ r, which by the definition of literal order implies lj >t l ≥t l′ and lj >t r ≥t r′; since >t is a simplification order, lj is a subterm of neither l′ nor r′. Thus, l′ and r′ are the normal forms of l and r, respectively, w.r.t. Rjt , and so we have l ′ ≈ r′ 6∈ (Rjt )∗; but then, we have l ≈ r 6∈ (R j t ) ∗, as required.\nLemma 3. For each generative clause Γi → ∆i ∨ li ≈ ri, we have R∗t 6|= ∆i.\nProof. Consider a generative clause Ci = Γi → ∆i ∨ li ≈ ri and a literal L ∈ ∆i; condition R1 ensures that (Ri−1t )∗ 6|= L. We next show that (Ri−1t )\n∗ 6|= L. Assume that L is of the form l 6≈ r. Since l 6≈ r ∈ ∆i ∨ li ≈ ri, by Lemma 2 we have R∗t 6|= L, as required. Assume that L is of the form l ≈ r with l >t r. We show by induction that, for each j with i ≤ j ≤ n, we have (Rjt )∗ 6|= L.\nTo this end, we assume that (Rj−1t ) ∗ 6|= L. If Cj is not generational, then Rjt = R j−1 t , and so (R j t ) ∗ 6|= L. Thus, assume that Cj is generational. We consider the following two cases.\n• lj = l. We have the following two subcases. – j = i. Condition R4 then ensures r ≈ ri 6∈ (Ri−1t )∗. Let r′ and r′′ be the normal forms of r and ri, respectively, w.r.t. Ri−1t ; we have r\n′ ≈ r′′ 6∈ (Ri−1t )∗. Moreover, l >t r ≥t r′ and l >t ri ≥t r′′ hold; since >t is a simplification order, l is a subterm of neither r′ nor r′′; therefore, r′ and r′′ are the normal forms of r and ri, respectively, w.r.t. Rit, and therefore r′ ≈ r′′ 6∈ (Rit)∗. Finally, since l⇒ ri ∈ Rit, term r′′ is the normal form of l w.r.t. Rit, and so l ≈ r 6∈ (Rit)∗. – j > i. But then, lj ≈ rj ≥t li ≈ ri >t l ≈ r implies lj = li = l. Furthermore, Ci is generational, so we have li ⇒ ri ∈ Rj−1t . But then, lj is not irreducible by R j−1 t , which contradicts condition R3. • lj >t l. Let l′ and r′ be the normal forms of l and r, respectively, w.r.t. Rj−1t . Then, we have lj >t l ≥t l′ and lj >t r ≥t r′; since >t is a simplification order, lj is a subterm of neither l′ nor r′. Thus, l′ and r′ are the normal forms of l and r, respectively, w.r.t. Rjt , and so l ′ ≈ r′ 6∈ (Rjt )∗; hence, l ≈ r 6∈ (R j t ) ∗ holds.\nLemma 4. Let Γ→ ∆ be a clause with Γ→ ∆ ∈̂ Nt. Then R∗t |= ∆ holds if i with 1 ≤ i ≤ n+ 1 exists such that 1. for each 1 ≤ j < i, we have R∗t |= ∆j ∨ Lj , and 2. if i ≤ n (i.e., i is an index of a clause from Nt), then ∆i ∨ Li >t ∆.\nProof. Assume that Γ→ ∆ ∈̂ Nt holds. If Γ→ ∆ satisfies condition 1 of Definition 4, then we clearly have R∗t |= ∆. Assume that Γ→ ∆ satisfies condition 2 of Definition 4 due to some clause Γj → ∆j ∨ Lj ∈ Nt such that Γj ⊆ Γ and ∆j ∪ {Lj} ⊆ ∆ hold; the latter clearly implies ∆ ≥t ∆j ∨ Lj . Let i be an integer satisfying this lemma’s assumption. If i = n+ 1, then we clearly have j < i; otherwise, ∆i ∨ Li >t ∆ implies ∆i ∨ Li >t ∆j ∨ Lj , and so we also have j < i. But then, by the lemma assumption we have R∗t |= ∆j ∨ Lj , which implies R∗t |= ∆, as required.\nLemma 5. For each clause Γ→ ∆ such that Γ→ ∆ ∈̂ Sv and Γσt ⊆ Γt hold, we have Γσt → ∆σt ∈̂ Nt.\nProof. Assume that Γ→ ∆ ∈̂ Sv holds. If Γ→ ∆ satisfies condition 1 of Definition 4, then terms s and s′ exist such that s ≈ s ∈ ∆ or {s ≈ s′, s 6≈ s′} ⊆ ∆; but then, sσt ≈ s′σt ∈ ∆σt or {sσt ≈ s′σt, sσt 6≈ s′σt} ⊆ ∆σt, so Γσt → ∆σt ∈̂ Nt holds. Furthermore, if Γ→ ∆ satisfies condition 2 of Definition 4, then clause Γ′ → ∆′ ∈ Sv exists such that Γ′ ⊆ Γ and ∆′ ⊆ ∆; but then, due to Γ′σt ⊆ Γσt ⊆ Γt, we have that Γ′σt → ∆′σt ∈ Nt holds, and so Γσt → ∆σt ∈̂ Nt holds as well.\nLemma 6. For each Γ→ ∆ ∈ Nt, we have R∗t |= ∆.\nProof. For the sake of a contraction, choose Ci = Γi → ∆i ∨ Li as the clause in the sequence of clauses from Appendix C.1.2 with the smallest i such that R∗t 6|= ∆i ∨ Li; please recall that Li >t ∆i and that Li = li ./ ri with ./ ∈ {≈, 6≈}. Due to our choice of i, condition 1 of Lemma 4 holds for Ci and i. By the definition of Nt, a clause Γ→ ∆ ∨ L ∈ Sv exists such that\nΓσt = Γ i ⊆ Γt, ∆σt = ∆i, Lσt = Li, and ∆ 6 v L. (74)\nWe next prove the claim of this lemma by considering the possible forms of Li.\nAssume Li = li ≈ ri with li = ri. But then, we have R∗t |= Li, which contradicts our assumption that R∗t 6|= ∆i ∨ Li.\nAssume Li = li ≈ ri with li >t ri. Then, literal L is of the form l ≈ r such that lσt ≈ rσt = li ≈ ri. By the definition of>t, we have l v r. We first show that (Ri−1t )∗ 6|= ∆i ∨ Li holds; towards this goal, note that, for each equality s1 ≈ s2 ∈ ∆i ∨ Li, properties R∗t 6|= s1 ≈ s2 and Ri−1t ⊆ Rt imply (Ri−1t )∗ 6|= s1 ≈ s2; and for each inequality s1 6≈ s2 ∈ ∆i, Lemma 2 and R∗t 6|= s1 6≈ s2 imply (Ri−1t )∗ 6|= s1 6≈ s2. Thus, clause Ci satisfies conditions R1 and R2; however, since R∗t 6|= li ≈ ri, clause Ci is not generational and thus either condition R3 or condition R4 are not satisfied. We next consider both of these possibilities.\n• Condition R3 does not hold—that is, li is reducible by Ri−1t . By the definition of reducibility, a position p and a clause Cj = Γj → ∆j ∨ lj ≈ rj generating the rule lj ⇒ rj exist such that j < i and li|p = lj . Due to j < i, we have li ≈ ri ≥t lj ≈ rj ; together with lj ≈ rj >t ∆j , we have li ≈ ri >t ∆j . Lemma 3 ensures R∗t 6|= ∆j , and the definition of Nt ensures that a clause Γ′ → ∆′ ∨ l′ ≈ r′ ∈ Sv exists such that\nΓ′σt = Γ j ⊆ Γt, ∆′σt = ∆j , l′σt = lj , r′σt = rj , ∆′ 6 v l′ ≈ r′, and l′ v r′. (75)\nBy the assumption of Theorem 2, the Eq rule is not applicable to (74) and (75), and so Γ ∧ Γ′ → ∆ ∨∆′ ∨ l[r′]p ≈ r ∈̂ Sv . Let ∆′′ = ∆i ∨∆j ∨ li[rj ]p ≈ ri. Then clearly Γσt ∪ Γ′σt ⊆ Γt, so Lemma 5 ensures that Γi ∧ Γj → ∆′′ ∈̂ Nt holds. Set R∗t is a congruence, so l\ni[rj ]p ≈ ri 6∈ R∗t holds, and therefore R∗t 6|= ∆′′ holds. Finally, >t is a simplification order, which ensures li ≈ ri >t li[rj ]p ≈ ri; together with li ≈ ri >t ∆i and li ≈ ri >t ∆j , we have li ≈ ri >t ∆′′. But then, Lemma 4 implies R∗t |= ∆′′, which is a contradiction. • Condition R4 does not hold. Then, some term s exists such that li ≈ s ∈ ∆i and s ≈ ri ∈ (Ri−1t )∗. Due to Ri−1t ⊆ Rt, we have s ≈ ri ∈ R∗t , and so R∗t 6|= s 6≈ ri. Furthermore, ∆ ∨ L is of the form ∆′ ∨ l ≈ r ∨ l′ ≈ r′ such that\nlσt = l i, rσt = s, l ′σt = l i, and r′σt = ri. (76)\nBut then, we clearly have l′ = l. By the assumption of Theorem 2, the Factor rule is not applicable to Γ→ ∆ ∨ L, and so we have Γ→ ∆′ ∨ r 6≈ r′ ∨ l′ ≈ r′ ∈̂ Sv . Let ∆′′ = ∆′σt ∨ s 6≈ ri ∨ li ≈ ri. But then, Γσt ⊆ Γt and Lemma 5 ensure that Γi → ∆′′ ∈̂ Nt holds. By all the previous observations, we have R∗t 6|= ∆′′. Moreover, li >t ri and li >t s imply li ≈ ri >t s ≈ ri; thus, ∆i ∨ li ≈ ri >t ∆′′ holds. But then, Lemma 4 implies R∗t |= ∆′′, which is a contradiction.\nAssume Li = li 6≈ ri with li = ri. Then, literal L is of the form l 6≈ r such that lσt 6≈ rσt = li 6≈ ri. But then, li = ri implies l = r. By the assumption of Theorem 2, the Ineq rule is not applicable to clause Γ→ ∆ ∨ L, and so we have Γ→ ∆ ∈̂ Sv . Since Γσt ⊆ Γt, by Lemma 5 we have Γi → ∆i ∈̂ Nt. Clearly, ∆i ∨ li 6≈ ri >t ∆i, and so Lemma 4 implies R∗t |= ∆i, which is a contradiction.\nAssume Li = li 6≈ ri with li >t ri. Lemma 2 ensures (Ri−1t )∗ 6|= li 6≈ ri; hence, li is reducible by Ri−1t so, by the definition of reducibility, a position p and a generative clause Cj = Γj → ∆j ∨ lj ≈ rj exist such that j < i and li|p = lj . Due to j < i, we have li 6≈ ri >t lj ≈ rj >t ∆j . Lemma 3 ensures R∗t 6|= ∆j , and the definition of Nt ensures that a clause Γ′ → ∆′ ∨ l′ ≈ r′ ∈ Sv exists satisfying (75), as in the first case. By the assumption of Theorem 2, the Eq rule is not applicable to clauses (74) and (75), and so Γ ∧ Γ′ → ∆ ∨∆′ ∨ l[r′]p 6≈ r ∈̂ Sv holds. Let ∆′′ = ∆i ∨∆j ∨ li[rj ]p 6≈ ri. We clearly have Γσt ∪ Γ′σt ⊆ Γt, so by Lemma 5 we have Γi ∧ Γj → ∆′′ ∈̂ Nt. Since R∗t is a congruence, we have R∗t 6|= li[lj ]p 6≈ ri, and therefore R∗t 6|= ∆′′ holds. Finally, >t is a simplification order, so li 6≈ ri >t li[lj ]p; together with li ≈ ri >t ∆i and li ≈ ri >t ∆j , we have li ≈ ri >t ∆′′. But then, Lemma 4 implies R∗t |= ∆′′, which is a contradiction.\nLemma 7. For each clause Γ→ ∆ with Γ→ ∆ ∈̂ Nt, we have R∗t |= ∆.\nProof. Apply Lemma 4 for i = n+ 1 and Lemma 6.\nLemma 8. For each generative clause Γi → ∆i ∨ li ≈ ri, disjunction ∆i does not contain a literal of the form s 6≈ s.\nProof. For the sake of a contradiction, let us assume that clause Ci = Γi → ∆i ∨ li ≈ ri ∈ Nt is generative and that s 6≈ s ∈ ∆i holds for some term s. By the definition of Nt, a clause Γ′ → ∆′ ∨ s′ 6≈ s′ ∨ l′ ≈ r′ ∈ Sv exists such that\nΓ′σt = Γ i ⊆ Γt, ∆′σt ∪ {s′σt 6≈ s′σt} = ∆i, s′σt = s, l′σt = li, and r′σt = ri. (77)\nBy assumption of Theorem 2, the Ineq rule is not applicable to this clause, and so we have Γ′ → ∆′ ∨ l′ ≈ r′ ∈̂ Sv . Thus, we have Γi → ∆′σt ∨ li ≈ ri ∈̂ Nt, and so Γ→ ∆ ∈ Nt holds for some Γ ⊆ Γi and some ∆ ( ∆i ∪ {li ≈ ri}. Now Lemma 3 implies R∗t 6|= ∆i; moreover, by condition R1, we have (Ri−1t )∗ 6|= ∆i ∨ li ≈ ri. However, by Lemma 6 we have R∗t |= Γ→ ∆. Now let j be the index of clause Γ→ ∆ in the sequence of clauses from Appendix C.1.2; due to (Rjt ) ∗ ⊆ (Ri−1t )∗ and Lemma 2, we have (R j t ) ∗ |= Γ→ ∆. Since j < i, by the same argument we have (Ri−1t )∗ |= Γ→ ∆. But then, ∆ ⊆ ∆i ∨ li ≈ ri implies (Ri−1t )∗ |= ∆i ∨ li ≈ ri, which is a contradiction.\nLemma 9. R∗t 6|= Γt → ∆t.\nProof. For R∗t |= Γt, note that condition L2 ensures Γt → A ∈̂ Nt, and so Lemma 7 ensures R∗t |= A for each atom A ∈ Γt. For R∗t 6|= ∆t, assume for the sake of a contradiction that an atom A ∈ ∆t exists such that R∗t |= A. Then, a generative clause Ci = Γi → ∆i ∨ li ≈ ri ∈ Nt and a position p exist such that A|p = li; let ∆ = ∆i ∨ li ≈ ri. Since >t is a simplification order and li >t ri, we have A ≥t li ≈ ri; but then, since li ≈ ri >t ∆i, we have A ≥t ∆. We next consider an arbitrary literal l ./ r ∈ ∆ with ./ ∈ {≈, 6≈} and l ≥t r; by the observations made thus far, A ≥t l ./ r holds. By condition O2, one of the following holds.\n1. l ∈ {t, t′}. Moreover, since l ./ r is obtained by grounding a context literal, both l and r can be of the form f(t) or t′. Together with l ≥t r, we have l = r = t′. Now if l ./ r is t′ ≈ t′, then clause Ci is not generative due to condition R1. Hence, the only remaining possibility is for l ./ r to be of the form t′ 6≈ t′; but then, clause Ci is not generative by Lemma 8. Consequently, in either case we get a contradiction.\n2. l ≈ r ∈ ∆t where r = ℘. Thus, the second point above holds for arbitrary l ./ r ∈ ∆, and therefore we have ∆ ⊆ ∆t. But then, Γi ⊆ Γt implies that Γt → ∆t ∈̂ Nt holds, which contradicts condition L1.\nC.2 Interpreting the Ontology O We now combine the rewrite systems Rt constructed in Appendix C.1 into a single rewrite system R, and we then show that R∗ satisfies R∗ |= O and R∗ 6|= ΓQ → ∆Q."
    }, {
      "heading" : "C.2.1 Unfolding the Context Structure",
      "text" : "We construct R by a partial induction over the terms in T . We define several partial functions: function X maps a term t to a context Xt ∈ V; functions Γ and ∆ assign to a term t a conjunction Γt and a disjunction ∆t, respectively, of atoms; and function R maps each term into a model fragment Rt for t, Xt, Γt, and ∆t. M1. For the base case, we consider the constant c.\nXc = q (78) Γc = ΓQσc (79) ∆c = ∆Qσc (80) Rc = the model fragment for c, q,Γc, and ∆c (81)\nM2. For the inductive step, assume that Xt′ has already been defined, and consider an arbitrary function symbol f ∈ F such that f(t′) is irreducible by Rt′ . Let u = Xt′ and t = f(t′). We have two possibilities. M2.a. Term t occurs in Rt′ . Then, term t = f(t′) was generated in Rt′ by some ground clause C = Γ→ ∆ ∨ L ∈ Nt′\nsuch that L >t ∆ and f(t′) occurs in L. By the definition of Nt, then a clause C ′ = Γ′ → ∆′ ∨ L′ ∈ Su exists such that C = C ′σt′ and L′ contains f(x); moreover, L >t′ ∆ implies ∆′ 6 u L′. The Succ and Core rules are not applicable to D, so we can choose a context v ∈ V such that 〈u, v, f〉 ∈ E and A→ A ∈̂ Sv for each A ∈ K2, where K2 is as in the Succ rule. We define the following:\nXt = v (82) Γt = R ∗ t′ ∩ Sut (83) ∆t = Prt \\R∗t′ (84) Rt = the model fragment for t, v,Γt, and ∆t (85)\nM2.b. Term t does not occur in Rt′ . Then, let Rt = {t⇒ c}, and we do not define any other functions for t. Finally, let R be the rewrite system defined by R = ⋃ tRt. Lemma 10. The model fragments Rc and Rt constructed in lines (81) and (85) satisfy conditions L1 through L3 in Appendix C.1.\nProof. The proof is by induction on the structure of terms t ∈ dom(X). For t = c, conditions L1 through L3 hold directly from conditions C1 through C3 of Theorem 2. We next assume that the lemma holds for some term t′ ∈ dom(X), and we consider an arbitrary term t of the form t = f(t′); let u = Xt′ and v = Xt. Condition L2 holds because ∆t = Prt \\R∗t′ due to (84), and hence ∆t ⊆ Prt. Before proceeding, note that terms t and t′ are irreducible by Rt′ due to condition M2; but then, since Γt ⊆ R∗t′ holds by (83), each each atom Ai ∈ Rt′ is generated by clause satisfying (86) (where subscript i does not necessarily indicate the position of the clause in sequence of clauses from Appendix C.1.2). By the definition of Nt′ , then there exists a clause satisfying (87).\nΓi → ∆i ∨Ai ∈ Nt′ with Ai >t ∆i (86) Γ′i → ∆′i ∨A′i ∈ Su Γi = Γ′iσt′ , ∆i = ∆′iσt′ , Ai = A′iσt′ , and ∆′i 6 u A′i (87)\nFor condition L3, consider an arbitrary atom Ai ∈ Γt, let (86) be the clause that generates Ai in Rt′ , and let (87) be the corresponding nonground clause. Since Ai ∈ Sut, atom A′i is of the form A′′i σ, where σ is the substitution from the Succ rule; but then, A′′i ∈ K2, where K2 is as specified in the Succ rule. In condition M2.a we chose v so that the Succ rule is satisfied, and therefore A′′i → A′′i ∈̂ Sv; but then, since A′′i σt = Ai, we have Ai → Ai ∈̂ Nt, as required for condition L3.\nTo prove that condition L1 holds as well, assume for the sake of a contradiction that Γt → ∆t ∈̂ Nt holds. We have ∆t ⊆ Prt due to (84). Therefore, due to condition 2 of Definition 4, set Nt contains a clause\nm∧ i=1 Ai → m+n∨ i=m+1 Ai with {Ai | 1 ≤ i ≤ m } ⊆ Γt and {Ai | m+ 1 ≤ i ≤ m+ n } ⊆ ∆t ⊆ Prt. (88)\nBy the definition of Nt, set Sv contains a clause m∧ i=1 A′i → m+n∨ i=m+1 A′i where Ai = A ′ iσt for 1 ≤ i ≤ m+ n and A′i ∈ Pr(O) for m+ 1 ≤ i ≤ m+ n. (89)\nNow eachAi with 1 ≤ i ≤ m is generated by a ground clause (86), and the latter is obtained from the corresponding nonground clause (87). The Pred rule is not applicable to (87) and (89) so (90) holds; together with Lemma 5, this ensures (91).\nm∧ i=1 Γ′i → m∨ i=1 ∆′i ∨ m+n∨ i=m+1 A′iσ ∈̂ Su for σ = {x 7→ f(x), y 7→ x} (90)\nm∧ i=1 Γi → m∨ i=1 ∆i ∨ m+n∨ i=m+1 Ai ∈̂ Nt′ (91)\nBy Lemma 3, we have R∗t′ 6|= ∆i; and (84) ensures that R∗t′ 6|= ∆t, and so R∗t′ 6|= Ai for each m+ 1 ≤ i ≤ m+ n; however, this contradicts (91) and Lemma 7."
    }, {
      "heading" : "C.2.2 Termination, Confluence, and Compatibility",
      "text" : "Lemma 11. The rewrite system R is Church-Rosser.\nProof. We show that R is terminating and left-reduced, and thus Church-Rosser. In the proof of the former, we use a total simplification order B on all ground F- and P-terms defined as follows. We extend the precedence m from Definition 3 to all F- and P-symbols in an arbitrary way, but ensuring that constant ℘ is smallest in the order; then, let B be a lexicographic path order (Baader and Nipkow 1998) over such m. It is well known that such B is a simplification order, and that it satisfies the following properties for each F-term t with predecessor t′ (if one exists), all function symbols f, g ∈ F , and each P-term A:\n• f(t)B tB t′, • f m g implies f(t)B g(t), and • AB ℘.\nThus, conditions 1 and 2 of Definition 3 and the manner in which context orders are grounded in Appendix C.1.1 clearly ensure that, for each F-term t ∈ dom(X) and for all terms s1 and s2 from the F-neighbourhood of t with s1 >t s2, we have s1 B s2.\nWe next show that R is terminating by arguing that each rule in R is embedded in B. To this end, consider an arbitrary rule l⇒ r ∈ R. Clearly, a term t ∈ dom(R) exists such that l⇒ r ∈ Rt. This rule is obtained from a head l ≈ r of a clause in Nt, and condition R2 of the definition of Rt ensures that l >t r. Moreover, l ≈ r is obtained by grounding a context literal with σt, so we have the following possible forms of l ≈ r.\n• Terms l and r are both from the F-neighbourhood of t. Then, l >t r implies l B r. • We have l ≈ r = A ≈ ℘ for A a P-term. Then, AB ℘ since ℘ is smallest in m.\nWe next show that R is left-reduced. For the sake of a contradiction, assume that a rule l⇒ r ∈ R exists such that l is reducible by R′ = R \\ {l⇒ r}. Let p be the ‘deepest’ position at which some rule in R′ reduces l (i.e., no rule in R′ reduces l at position below p), and let l′ ⇒ r′ ∈ R′ be the rule that reduces l at position p; thus, l′ = l|p. By the definition of R, we have l′ ⇒ r′ ∈ Rt where t can be as follows.\n• Term t is handled in condition M2.a. Then l′ ⇒ r′ is generated by an equality l′ ≈ r′ in the head of a generative clause, and so l′ is of the form f(t). Thus, f(t) is reducible by Rt, which contradicts condition M2 from the construction of R. • Term t is handled in condition M2.b. Then l′ = t; moreover,R′ does not contain t by the construction ofR, which contradicts the assumption that l′ ⇒ r′ ∈ R′.\nLemma 12. For each term t, each f ∈ F , and each atom A ∈ Sut ∪ Prf(t) such that A ∈ R∗ and all F-terms in A are irreducible by R, we have A ∈ R∗t .\nProof. Let t be a term, let f ∈ F be a function symbol, and let A ∈ Sut ∪ Prf(t) be an atom such that all F-terms in A are irreducible by R; the latter ensures A⇒℘ ∈ R. We next consider the possible forms of A.\nAssume A ∈ Sut. By the definition of Sut in (72) and the fact that Su(O) contains only atoms of the form B(x), S(x, y), and S(y, x), atom A can be of the form B(t), S(t, t′), or S(t′, t), for t′ the predecessor of t (if one exists). By the form of the generative clauses, we clearly have A ∈ R∗t or A ∈ R∗t′ . Now assume A ∈ R∗t′ . Due to A ∈ Sut and the definition of Γt in (83), we have A ∈ Γt. Lemma 9 ensures that R∗t 6|= Γt → ∆t. But then, we have A ∈ R∗t , as required.\nAssumeA ∈ Prf(t). By the definition of Prf(t) in (73) and the fact that Pr(O) contains only atoms of the formB(y), S(y, x), and S(x, y), atom A can be of the form B(t), S(t, f(t)), or S(f(t), t). By the form of the generative clauses, we clearly have A ∈ R∗t orA ∈ R∗f(t). Assume for the sake of a contradiction thatA 6∈ R ∗ t , butA ∈ R∗f(t). Due toA ∈ Prf(t) and the definition of ∆f(t) in (84), we have A ∈ ∆f(t); due to Lemma 9, we have R∗f(t) 6|= Γf(t) → ∆f(t); therefore, we have A 6∈ R ∗ f(t), which is a contradiction.\nLemma 13. Let s1 and s2 be DL-terms, and let τ be a substitution irreducible byR such that s1τ and s2τ are ground and each τ(zi) (if defined) is in the F-neighbourhood of τ(x). Then, for ./ ∈ {≈, 6≈}, if R∗τ(x) |= s1τ ./ s2τ , then R ∗ |= s1τ ./ s2τ .\nProof. Let s1 and s2 and τ be as stated above, let t = τ(x), and let t′ be the predecessor of t (if one exists). Since t is irreducible by R, rewrite system Rt has been defined in Appendix C.2.1. We next consider the possible forms of ./.\n• Assume ./ = ≈. But then, Rt ⊆ R and R∗t |= s1τ ≈ s2τ imply R∗ |= s1τ ≈ s2τ . • Assume ./ = 6≈. Let s′1 and s′2 be the normal forms of s1τ and s2τ , respectively, w.r.t. Rt. Due to the shape of DL-literals, s1 and s2 can be of the form f(x) or zi; therefore, s1τ and s2τ are of the form f(t) or t′. Term t is irreducible by R, and thus t′ is irreducible by R as well. Furthermore, due to the shape of context terms, the only rewrite system where f(t) could occur on the left-hand side of a rewrite rule is Rt. Consequently, f(t) is irreducible by R as well. But then, s′1 and s ′ 2 are the\nnormal forms of s1τ and s2τ , respectively, w.r.t. R; thus, R∗ |= s′1 6≈ s′2, and thus R∗ |= s1τ 6≈ s2τ holds, as required."
    }, {
      "heading" : "C.2.3 The Completeness Claim",
      "text" : "Lemma 14. For each DL-clause Γ→ ∆ ∈ O, we have R∗ |= Γ→ ∆.\nProof. Consider an arbitrary DL-clause Γ→ ∆ ∈ O of the following form:∧n i=1Ai → ∆ (92)\nLet τ ′ be an arbitrary substitution such that Γτ ′ → ∆τ ′ is ground, and let τ be the substitution obtained from τ ′ by replacing each ground term with its normal form w.r.t. R. Since R∗ is a congruence, we have R∗ |= Γτ ′ → ∆τ ′ if and only if R∗ |= Γτ → ∆τ . We next assume that R∗ |= Γτ , and we show that R∗ |= ∆τ holds as well.\nConsider an arbitrary atom Ai ∈ Γ. By the definition of DL-clauses, Ai is of the form B(x), S(x, zj), or S(zj , x). Substitution τ is irreducible by R, and so all F-terms in Aiτ are irreducible by R; but then, Aiτ ∈ R∗ clearly implies Aiτ ⇒℘ ∈ R. Each such rule is obtained from a generative clause soAiτ is of the formB(t), S(t, f(t)), S(f(t), t), S(t, t′), or S(t′, t), where t = τ(x) and t′ is the predecessor of t (if it exists). We next prove that Aiτ ∈ Sut ∪ Prf(t) holds by considering the possible forms of Ai.\n• Ai = B(x), so Aiτ = B(t). Then, we have B(x) ∈ Su(O), which implies that B(t) ∈ Sut holds. • Ai = S(x, zj), soAiτ is of the form S(t, t′) or S(t, f(t)). Then, we have S(x, y) ∈ Su(O), which implies that S(t, t′) ∈ Sut\nholds; moreover, we have S(y, x) ∈ Pr(O), which implies that S(t, f(t)) ∈ Prf(t) holds.\n• Ai = S(zj , x), soAiτ is of the form S(t′, t) or S(f(t), t). Then, we have S(y, x) ∈ Su(O), which implies that S(t′, t) ∈ Sut holds; moreover, we have S(x, y) ∈ Pr(O), which implies that S(f(t), t) ∈ Prf(t) holds.\nLemma 12 then implies Aiτ ∈ Rt, and so Nt contains a generative clause of the form (93). Now let v = Xt; by the definition of Nt, set Sv contains a clause of the form (94).\nΓi → ∆i ∨Ai with Ai >t ∆i and Γi ⊆ Γt (93) Γ′i → ∆′i ∨A′i with ∆′i 6 vA′i and Γ′iσt = Γi, ∆′iσt = ∆i, and A′iσt = Ai (94)\nThe Hyper rule is not applicable to (92) and (94), and therefore (95) holds, where σ is the substitution obtained from τ by replacing each occurrence of t (possibly nested in another term) with x. Finally, Lemma 5 ensures that (96) holds as well.\nn∧ i=1 Γ′i → ∆σ ∨ n∨ i=1 ∆′i ∈̂ Sv (95)\nn∧ i=1 Γi → ∆τ ∨ n∨ i=1 ∆i ∈̂ Nt (96)\nNow (96) and Lemma 7 imply R∗t |= ∆τ ∨ ∨n i=1 ∆i, but Lemma 3 implies R ∗ t 6|= ∆i; therefore, we have R∗t |= ∆τ . Finally, Lemma 13 ensures R∗ |= ∆τ , as required.\nLemma 15. R∗ 6|= ΓQ → ∆Q.\nProof. The claim clearly follows from R∗ 6|= Γc → ∆c. Note that Lemma 9 ensures R∗c 6|= Γc → ∆c; thus, R∗c |= Γc and R∗c 6|= ∆c. The former observation and Lemma 13 ensure that R∗ |= Γc holds. Moreover, for each atom B(x) ∈ ∆Q, Definition 2 ensures B(y) ∈ Pr(O); thus, for each f ∈ F , we have B(c) ∈ Prf(c), and so the contrapositive of Lemma 12 ensures R∗ 6|= B(c). Thus, R∗ 6|= ∆c holds, as required.\nD Proof of Proposition 2 Proposition 2. For each expansion strategy that introduces at most exponentially many contexts, algorithm A1–A4 runs in worst-case exponential time.\nProof. The number ℘ of context clauses that can be generated using the symbols in O is at most exponential in the size of O, and the number m of clauses participating in each inference is linear in the size of O. Hence, with k contexts, the number of inferences is bounded by (k · ℘)m; if k is at most exponential in the size of O, the number of inferences is exponential as well. Thus, if at most exponentially many contexts are introduced, our algorithm runs in exponential time.\nE Proof of Proposition 3 Proposition 3. For ELH ontologies and queries of the form B1(x)→ B2(x), algorithm A1–A4 runs in polynomial time with either the cautious or the eager strategy; and with the cautious strategy and the Hyper rule applied eagerly, the inferences in step A3 correspond directly to the inferences of the ELH calculus by Baader, Brandt, and Lutz (2005).\nProof. Consider an ELH ontology that is transformed into a setO of DL-clauses as specified in Section 2, and consider a query of the form B1(x)→ B2(x). Due to the form of the query, the core of q is initialised to B1(x).\nWe first consider applying algorithm A1–A4 to O with the cautious strategy and the eager application of the Hyper rule. By induction on the application of the rules from Table 2, we next show that each context clause derived by the rules is of the form (97)–(101) and that the core of each context is of the form B(x).\n> → B(x) (97) > → S(x, f(x)) (98) > → B(f(x)) (99)\nS(y, x)→ B(y) (100) S1(y, x)→ S2(y, x) (101)\nIn particular, in step A3 we can perform the following inferences, with the specified correspondence to the completion rules CR1–CR4 and CR10 by Baader, Brandt, and Lutz (2005).\n• The core of each context is of the form B(x), so the Core rule introduces a clause of the form form (97). This corresponds to way in which Baader, Brandt, and Lutz (2005) initialise their mappings.\n• The Hyper rule can be applied to a DL-clause of type DL1. All other clauses participating in the inference are of the form (97), so the result is of the form (97). Such an inference corresponds to the completion rules CR1 or CR2.\n• The Hyper rule can be applied to a DL-clause of type DL2. The other clause participating in the inference is of the form (97), so the result is of the form (98) or (99). Moreover, function symbol f occurs inO in exactly one pair of clauses DL2, and the Hyper rule is applied eagerly; thus, whenever f occurs in a context in a clause of the form (98), it also occurs in a clause of the form (99). Now the Succ rule can be applied to the function symbol f , in which case the cautious strategy thus returns a context whose core is of the form B(x). All of these inferences correspond to the completion rule CR3.\n• The Hyper rule can be applied to a DL-clause of type DL3. The two other clauses participating in the inference are of the form (100) and (97), so the result is of the form (100); the Pred rule can then be applied to the latter clause, producing a clause of the form (97). Such a pair of inferences corresponds to the completion rule CR4.\n• The Hyper rule can be applied to a DL-clause of type DL5. The other clause participating in the inference is of the form (100), so the result is of the form (100) as well; the Pred rule can then be applied to the latter clause, producing a clause of the form (98). Such a pair of inferences corresponds to the completion rule CR10.\nOne can show in an analogous way that each inference of the calculus by Baader, Brandt, and Lutz (2005) corresponds to one or more inferences of our calculus. Furthermore, it is clear that our algorithm runs in polynomial time.\nWe next consider applying algorithm A1–A4 to O with the eager strategy. One can show that the core of each context is of the form A(x), R(y, x), or A(x) ∧R(y, x), and that context can contain clauses of the form (97)–(103).\n> → S2(y, x) (102) > → B(y) (103)\nThe proof is analogous to the case of the cautions strategy (without correspondence to the completion rules) so we omit the details for the sake of brevity. The only minor difference is that, if an application of the the Pred to contexts u and v introduces a clause of the form (98) in u, then the Succ rule does not become applicable to u since the precondition of the Succ rule is still satisfied by v. Thus, the Succ rule never introduces contexts whose cores contain conjunctions of binary atoms. Thus, if O contains k1 unary and k2 binary predicates, the number of contexts is bounded by O(k1 · k2), and each context can contain at most k1 + k2 + k1 · k2 clauses. All rules can be applied in polynomial time, so the algorithm runs in polynomial time."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Consequence-based calculi are a family of reasoning algorithms for description logics (DLs), and they combine hypertableau and resolution in a way that often achieves excellent performance in practice. Up to now, however, they were proposed for either Horn DLs (which do not support disjunction), or for DLs without counting quantifiers. In this paper we present a novel consequence-based calculus for SRIQ— a rich DL that supports both features. This extension is nontrivial since the intermediate consequences that need to be derived during reasoning cannot be captured using DLs themselves. The results of our preliminary performance evaluation suggest the feasibility of our approach in practice.",
    "creator" : "TeX"
  }
}