{
  "name" : "1502.02799.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "On Forgetting in Tractable Propositional Fragments",
    "authors" : [ "Yisong Wang" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n50 2.\n02 79\n9v 1\n[ cs\n.A I]\n1 0\nKeywords: Forgetting; CNF; Horn theories; Algorithms; Complexity"
    }, {
      "heading" : "1 Introduction",
      "text" : "Motivated from Lin and Reiter’s seminal work in first-order logic [1], the notion of forgetting – distilling from a knowledge base only the part that is relevant to a subset of the alphabet – has attracted extensive interests [2, 3]. A dual notion of forgetting in mathematical logic is called uniform interpolation [4]. In artificial intelligence, it has been studied under many different names including variable eliminating, irrelevance, independence, irredundancy, novelty, or separability [5].\nIn recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15]. It is commonly recognized that forgetting has both theoretical and practical interest as it can be\nused for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.\nThough forgetting has been extensively investigated from various aspects of different logical systems, in standard propositional logic, a general algorithm of forgetting and its computation-oriented investigation in various fragments whose satisfiability are tractable are still lacking.\nFirstly, the syntactic forgetting operator, which is defined as Forget(Σ, p) = Σ[p/⊤] ∨ Σ[p⊥] where ϕ[p/⊤] (resp. ϕ[p/⊥]) is obtained from ϕ be replacing p with ⊤ (resp. ⊥), results in a disjunctive formula. Thus, it violates categoricity for non-disjunctive formulas, e.g., if Σ is a conjunctive normal form (CNF) formula then Forget(Σ, p) is not a CNF formula any longer. Though one can transform a CNF formula into an equivalent disjunctive normal form (DNF) formula, the translation will bring about exponential explosion if no fresh atoms are allowed.\nSecondly, from the perspective of computation, Lang et al. have showed that deciding if a formula is independent of a set of atoms (called VAR-INDEPENDENCE) is co-NP-complete, and deciding if two formulas are equivalent on a common signature (called VAR-EQUIVALENCE) is ΠP2 -complete [2]. To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.\nIn the paper we mainly focus on CNF fragments of propositional logic, for which a resolution-based algorithm of forgetting is presented at first. Accordingly, we show that forgetting is categorical in the Horn, ren-Horn, q-Horn, double Horn [22] and Krom [23] (or 2-CNF) fragments. Namely, the result of forgetting from a Horn (resp. ren-Horn, q-Horn, double Horn and Krom [23] (or 2-CNF)) theory is Horn (resp. ren-Horn, q-Horn, double Horn and Krom) expressible.\nMore importantly, from the perspective of knowledge bases evolving, we are also interested in the following reasoning problems about forgetting, besides the VAR-INDEPENDENCE and VAR-EQUIVALENCE in [2], where Forget(ϕ, V ) stands for a result of forgetting V from formula ϕ,\n(1) [VAR-INDEPENDENCE] If a knowledge base Π is independent of a set V of atoms, i.e. Forget(Π, V ) ≡ Π.\n(2) After a knowledge base Σ has evolved from a knowledge base Π by incorporating some knowledge additionally on a set V of new propositions,\n[VAR-WEAK] if the restriction of Σ on the signature of Π is at most as strong as Π, i.e. Π |= Forget(Σ, V ).\n[VAR-STRONG] if the restriction of Σ on the signature of Π is at least as strong as Π, i.e. Forget(Σ, V ) |= Π.\nWe answer these problems for CNF, DNF, Horn, ren-Horn, q-Horn, and Krom fragments of propositional logic. The main complexity results are summarized in Table 1, from which one can see that for Krom (resp. DNF) fragments, all of the six problems are tractable (resp. co-NP-complete). While comparing Horn and its variants with CNF fragments, the corresponding complexity of the former is one level below the latter in the complexity hierarchy.\nThe rest of the paper are organized as follows. The basic notations of propositional logics and its fragments are briefly introduced in Section 2. Forgetting and its basic properties, algorithms and complexity are presented in Section 3. Related work and concluding remarks are discussed in Section 4 and 5 respectively."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We assume a underlying propositional language LA with a finite set A of atoms, called the signature of LA. A literal is either an atom p (called positive literal) or its negation ¬p (called negative literal). The complement of a literal l is ¬l. The formulas (of LA) are defined as usual using connectives ∧,∨,⊃,↔ and ¬.\nWe assume two propositional constants ⊤ and ⊥ for tautology and contradiction respectively. A theory is a finite set of formulas. For a theory Σ, we use the following denotations:\n• ¬Σ = {¬ϕ|ϕ ∈ Σ},\n• ∧ Σ = ∧\nϕ∈Σ ϕ,\n• ∨ Σ = ∨\nϕ∈Σ ϕ, and\n• Var(Σ) stands for the set of all atoms occurring in Σ.\nAn interpretation is a set of atoms, which assigns true to the atoms in the set and false to the others. The notion of satisfaction between an interpretation I and a formula ϕ, written I |= ϕ, is inductively defined in the standard manner. In this case I is a called model of ϕ. By Mod(ϕ) we denote the set of models of ϕ.\nA formula ψ is a logical consequence of a formula ϕ, denoted by ϕ |= ψ, if Mod(ϕ) ⊆ Mod(ψ). Two formulas ϕ and ψ are equivalent, written ϕ ≡ ψ, if ϕ |= ψ and ψ |= ϕ. A formula ψ is irrelevant to a set V of atoms, denoted by IR(ψ, V ), if there is a formula ϕ such that ψ ≡ ϕ and Var(ϕ)∩V = ∅. Otherwise, ψ is relevant to V ."
    }, {
      "heading" : "2.1 Clauses and terms",
      "text" : "In the following we assume that ¬¬ϕ is shortten to ϕ where ϕ is a formula, unless explicitly stated otherwise. A clause is an expression of the form l1∨· · ·∨ ln (n ≥ 0) where li (1 ≤ i ≤ n) are literals such that li 6= ¬lj for every i, j (1 ≤ i < j ≤ n). It is an empty clause in the case n = 0, which means false. Dually, a term is an expression of the form l1 ∧ · · · ∧ ln (n ≥ 0) where li (1 ≤ i ≤ n) are literals such that li 6= ¬lj for every i, j (1 ≤ i < j ≤ n). By abusing the notation, we identify a clause l1∨· · ·∨ ln and a term l1∧· · ·∧ ln with the set {l1, . . . , ln} when it is clear from its context.\nA conjunctive normal form (CNF) formula is a conjunction of clauses, and a disjunctive normal form (DNF) formula is a disjunction of terms. A k-CNF (resp. k-DNF) formula is a CNF (resp. DNF) formula whose each clause (resp. term) contains no more than k literals. In particular, 2-CNF formulas are called Krom formulas [23].\nA prime implicate of a formula ϕ is a clause c such that ϕ |= c and ϕ 6|= c′ for every proper subclause c′ ⊂ c. Dually, a prime implicant of ϕ is a term t such that t |= ϕ and t′ 6|= ϕ for each proper subterm t′ ⊂ t. A CNF (resp. DNF) formula\nThe definition of relevant is equivalent with, but slightly different from, that of [24], in which ψ is relevant to V if there is a prime implicate of ψ which mentions some atom from V .\nis prime, if it contains only prime implicates (resp. implicants). By PI(ψ) (resp. IP(ψ)) we denote the set of prime implicates (resp. implicants) of formula ψ.\nIn the following we shall identify a theory Σ with the formula ∧\nΣ when there is no confusion. The following lemma is well-known [25].\nLemma 1 Let Σ be a theory and ϕ be a term. Then\n(1) ∧ PI(Σ) ≡ ∨ IP(Σ) ≡ Σ.\n(2) ϕ is a prime implicant of Σ iff ¬ϕ is a prime implicate of ¬Σ.\n(3) If Π ≡ Σ then PI(Σ) = PI(Π) and IP(Σ) = IP(Π).\nTwo clauses c, c′ are resolvable, if there is an atom p such that p,¬p ∈ c ∪ c′ and c∗ = (c∪c′)\\{p,¬p} is a legal clause, viz, c∗ contains no pair of complement literals. In this case we denote the clause c ∪ c′ \\ {p,¬p} by res(c, c′), which is called their resolvent; otherwise, res(c, c′) is undefined. It is well-known that all prime implicates of a CNF formula ϕ can be generated by resolution."
    }, {
      "heading" : "2.2 Horn formulas and its variants",
      "text" : "In the following, by Pos(c) (resp. Neg(c)) we denote the set of atoms occurring positively (resp. negatively) in the clause or term c. In this sense a clause c can be written as Pos(c) ∪ ¬Neg(c).\nA clause c is Horn [19] if |Pos(c)| ≤ 1. Here |D| denotes the number of elements in the set D. A Horn formula is a conjunction of Horn clauses. A formula ϕ is Horn expressible if there is a Horn formula ψ such that ψ ≡ ϕ. A Horn formula ϕ is double Horn [22] if there is a Horn formula ψ such that ψ ≡ ¬ϕ, i.e., the negation of ϕ is also Horn expressible.\nGiven a formula ϕ and V ⊆ A, we denote ren(ϕ, V ) the result of replacing every occurrence of atom p ∈ V in ϕ by ¬p and ¬¬p is shortened to p. For instance ren(p1 ∨ ¬p2 ∨ ¬p3, {p1, p2}) is the formula ¬p1 ∨ p2 ∨ ¬p3. A CNF formula ϕ is Horn renamable [20] iff there exists a Horn renaming for it, i.e., ren(ϕ, V ) is a Horn formula for some V ⊆ A.\nDefinition 1 ([21, 18]) A CNF theory Σ has a QH-partition iff there exists a partition {Q,H} of Var(Σ) s.t for every clause δ of Σ, the following conditions hold:\n(i) |Var(δ) ∩Q| ≤ 2.\n(ii) |Pos(δ) ∩H| ≤ 1.\n(iii) If |Pos(δ) ∩H| = 1 then Var(δ) ∩Q = ∅.\nA CNF theory Σ is q-Horn iff there exists a q-Horn renaming for it [21], i.e., there is a set V ⊆ A such that replacing in Σ every occurrence of p ∈ V by ¬p leads to a CNF theory having a QH-partition {Q,H}. Here ¬¬p is shorten to p. It is not difficult to see that, every Horn theory is Horn renamable, every Horn renamable theory is q-Horn (Q = ∅), and every 2-CNF theory is also q-Horn (H = ∅). A CNF formula ϕ is Krom (resp. ren-Horn and q-Horn) expressible if there is Krom (resp. ren-Horn and q-Horn) formula ψ such that ϕ ≡ ψ.\nIn terms of Lemma 1, the following lemma are well-known.\nLemma 2 Let Σ be a CNF theory. The following conditions are equivalent.\n(i) Σ is Horn expressible.\n(ii) PI(Σ) is a Horn theory.\n(iii) M1 |= Σ and M2 |= Σ imply M1 ∩M2 |= Σ, i.e. Mod(Σ) is closed under intersection.\nIt is known that it is tractable to recognize if a CNF theory is ren-Horn [20, 26], q-Horn [27], or double-Horn [22], and the satisfiability of ren-Horn, q-Horn and double Horn formulas are all tractable.\nProposition 1 Let Σ be a CNF theory, V ⊆ A and c1, c2 two resolvable clauses of Σ. We have the following.\n(i) res(ren(c1, V ), ren(c2, V )) = ren(res(c1, c2), V ).\n(ii) If two subsets Q,H of A with Q ∩H = ∅ and Var(c1 ∪ c2) ⊆ Q ∪H satisfy the conditions (i), (ii) and (iii) of Definition 1 for both c1 and c2, then Q and H satisfy the same conditions for res(c1, c2) as well.\nProof: Without loss of generality, suppose c1 = {p} ∪ c′1 and c2 = {¬p} ∪ c ′ 2.\n(i) Note that res(c1, c2) = c′1 ∪ c ′ 2, ren(c1, V ) = ren(p, V ) ∪ ren(c ′ 1, V ) and ren(c2, V ) = ren(¬p, V )∪ren(c′2, V ). Due to the fact that ren(c1, v) and ren(c2, V ) are resolvable and res(ren(c1, V ), ren(c2, V )) = ren(c′1, V )∪ren(c ′ 2, V ), it follows that res(ren(c1, V ), ren(c2, V )) = ren(res(c1, c2), V ). (ii) We consider the following two cases: (a) p ∈ Q. We have the following:\n• Note that p ∈ Var(c1) ∩ Var(c2) and |Var(ci) ∩ Q| ≤ 2 for i = 1, 2 by the condition (i) in Definition 1. It shows that |Var(c′1 ∪ c ′ 2) ∩Q| ≤ 2;\n• By Var(ci) ∩Q 6= ∅ for i = 1, 2 we have that |Pos(ci) ∩H| = 0 due to the fact |Pos(ci) ∩ H| ≤ 1 and |Pos(ci) ∩ H| 6= 1 according to the conditions (ii) and (iii) of Definition 1. It follows |Pos(c′1 ∪ c ′ 2) ∩H| = 0.\n(b) p /∈ Q i.e. p ∈ H . Now we have the following:\n• Since p ∈ Pos(c1) ∩H we have Var(c1) ∩Q = ∅ by conditions (ii) and (iii) of Definition 1. It implies that |Var(c1 ∪ c2) ∩ Q| = |V ar(c2) ∩ Q| ≤ 2 by condition (i) of Definition 1. Thus |Var(c′1 ∪ c ′ 2) ∩Q| ≤ 2.\n• Note that |Pos(c1) ∩ H| ≤ 1 by condition (ii) of Definition 1 and p ∈ Pos(c1) ∩ H . It shows that |Pos(c1) ∩ H| = 1 and Pos(c′1) ∩ H = ∅, thus |Pos(c′1 ∪ c ′ 2) ∩ H| ≤ 1 due to |Pos(c2) ∩ H| ≤ 1 by condition (ii) of\nDefinition 1.\n• In the case |Pos(c′1 ∪ c ′ 2) ∩H| = 1 we have that |Pos(c ′ 2) ∩ H| = 1 due to\nPos(c′1) ∩H = ∅, which shows that |Pos(c2) ∩H| = 1 by condition (ii) of Definition 1, and then Var(c2)∩Q = ∅. Recall that Var(c1)∩Q = ∅ (see the proof in the first item). Thus Var(c1∪c2)∩Q = ∅, then Var(c′1∪c ′ 2)∩Q = ∅.\nIt completes the proof.\nLet Σ be a CNF theory. We define\nres0Σ = Σ, resn+1Σ = res n Σ ∪ {res(c, c ′)|c, c′ ∈ resnΣ and c, c ′ are resolvable}.\nTheorem 1 Let V ⊆ A and Σ a CNF theory.\n(i) If ren(Σ, V ) is a Horn theory then ren(resnΣ, V ) is a Horn theory for n ≥ 0.\n(ii) If the partition {Q,H} of Var(ren(Σ, V )) satisfies the conditions (i), (ii) and (iii) of Definition 1 for every clause of Σ, then {Q,H} satisfies the same conditions for every clauses in resnren(Σ,V ) for n ≥ 0.\nProof: We prove the theorem by induction on n. (i) Base: it trivially holds for n = 0 due to res0Σ = Σ.\nStep: Suppose that ren(resnΣ, V ) is a Horn formula. For any c ∈ res n+1 Σ \\ res n Σ, c = res(c1, c2) for some clauses c1, c2 of resnΣ. According to (i) of Proposition 1 we have ren(c, V ) = ren(res(c1, c2), V ) = res(ren(c1, V ), ren(c2, V )). It follows that ren(c, V ) is a Horn clauses since the resolvent of two Horn clauses is a Horn clause.\n(ii) Base: it trivially holds for n = 0 due to res0ren(Σ,V ) = ren(Σ, V ). Step: Suppose that Q and H satisfy the same conditions for every clauses in\nresnren(Σ,V ). For every clause c ∈ res n+1 ren(Σ,V ) \\ res n ren(Σ,V ), there are two resolvable clauses c1, c2 ∈ resnren(Σ,V ) such that c = res(c1, c2). In terms of (ii) of Proposition 1,Q andH satisfy the conditions (i), (ii) and (iii) of Definition 1 for the clause\nc. Thus {Q,H} satisfies the same conditions for every clauses in resn+1ren(Σ,V ).\nTogether with Lemma 2 and the fact that |res(c1, c2)| ≤ 2 if |ci| ≤ 2 (1 ≤ i ≤ 2), the theorem above implies:\nCorollary 2 Let V ⊆ A and Σ a CNF theory. If Σ is a Horn (resp. ren-Horn and q-Horn) theory then PI(Σ) is a Horn (resp. ren-Horn and q-Horn) theory.\nAs illustrated by the following example, the reverse of the above corollary do not generally hold even if Σ is Horn expressible.\nExample 1 Let Σ = (p ∨ q) ∧ (¬p ∨ ¬q) ∧ (p ∨ ¬q). Since Mod(Σ) = {{p}} (over the signature {p, q}), Σ is Horn expressible but it is not a Horn formula. In fact, PI(Σ) = {p,¬q}, which is a Horn theory. However Σ is not Horn renamable as we have that ren(Σ, V ) is not a Horn formula for any V ⊆ {p, q}.\nLet Π = (p∨q∨r)∧ (p∨q∨¬r)∧ (¬p∨¬q∨r)∧ (¬p∨¬q∨¬r)∧ (p∨¬q). We have that PI(Π) = {p,¬q}. It is evident that PI(Π) is a 2-CNF formula, thus a q-Horn formula. However, one can verify that Π is not a q-Horn formula.\nLet M,X be two sets of atoms. We denote M ÷X the symmetric difference (M \\X)∪ (X \\M). For a collection M of interpretations, we denote M÷X = {M ÷X|M ∈ M}.\nProposition 2 Let Σ be a formula and V ⊆ A. Then Mod(Σ)÷V = Mod(ren(Σ, V )).\nProof: (⇒) Let M ∈ Mod(Σ) ÷ V . There exists M ′ |= Σ such that M = (M ′ \\ V ) ∪ (V \\M ′). Suppose M 6|= ren(Σ, V ). It follows that M 6|= ren(c, V ) for some clause c ∈ Σ. By M ′ |= c we have that M ′ |= l for some literal l in c. Evidently, if Var(l) /∈ V then l is also a literal of ren(c, V ) and M |= l, thus M |= ren(c, V ). In the case Var(l) ∈ V , we consider the two cases, where p is an atom:\n• l = p. It shows that p ∈ M ′ and then p /∈ M . Thus M |= ren(c, V ) due to M |= ¬p.\n• l = ¬p. It shows p /∈ M ′ and then p ∈ M . Thus M |= ren(c, V ) due to M |= p.\nEither of the above two cases result in a confliction. (⇐) Let M ∈ Mod(ren(Σ, V )). We have that (M \\ V ) ∪ (V \\ M) |= ren(ren(Σ, V ), V ), which implies (M \\ V ) ∪ (V \\M) |= Σ, i.e. M ∈ Mod(Σ).\nThe following corollary easily follows from the proposition above.\nCorollary 3 Let Σ be a CNF theory. Then Σ is Horn renamable iff there exists V ⊆ A such that Mod(Σ)÷ V is closed under intersection."
    }, {
      "heading" : "3 Forgetting",
      "text" : "Starting with the basic notations and properties of forgetting, we will consider a general algorithm for computing forgetting results of CNF theories, and computational complexity on various reasoning problems relating to forgetting.\nLet Σ be a propositional formula, we denote Σ[p/⊤] (resp. Σ[p/⊥]) the formula obtained from Σ by substituting all occurrences of p with ⊤ (true) (resp. ⊥ (false)). For instance, if Σ = {p ⊃ q, (q ∧ r) ⊃ s}, then Σ[q/⊤] ≡ {r ⊃ s} and Σ[q/⊥] ≡ {¬p}."
    }, {
      "heading" : "3.1 Basic properties",
      "text" : "Let M,N be two interpretations and V ⊆ A. M and N are V -bisimilar, written M ∼V N , if and only if M \\ V = N \\ V .\nDefinition 2 ([1]) Let ϕ be a formula and V ⊆ A. A formula ψ is a result of forgetting V from ϕ iff, for every model M of ψ, ϕ has a model M ′ such that M ∼V M ′.\nThe syntactic counterpart of forgetting is a binary operator, written Forget(., .), which is defined recursively as:\nForget(ϕ, ∅) = ϕ,\nForget(ϕ, {p}) = ϕ[p/⊤] ∨ ϕ[p/⊥],\nForget(ϕ, V ∪ {p}) = Forget(Forget(ϕ, {p}), V )\nwhere ϕ is a formula and V ⊆ A. Due to the fact that if ϕ′ and ψ′ is a result of forgetting V from ϕ and ψ respectively, then ϕ′ ≡ ψ′, by abusing the notation, we will denote Forget(ϕ, V ) the result of forgetting V from ϕ when there is no ambiguity.\nThe following proposition easily follows from the definition of forgetting, cf, Propositions 17 and 21 of [2].\nProposition 3 Let ψ, φ be two formulas and V ⊆ A. Then we have\n(i) Forget(ψ ∨ φ, V ) ≡ Forget(ψ, V ) ∨ Forget(φ, V ).\n(ii) Forget(ψ ∧ φ, V ) ≡ Forget(ψ, V ) ∧ φ if IR(φ, V ).\nTo establish a semantic characterization of forgetting, we introduce the notion of extension. Let M be an interpretation and V ⊆ A. The extension of M over V , written M†V , is the collection {X ⊆ A|X ∼V M}. The extension of a collection M of interpretations is ⋃\nM∈MM†V . The following lemma establishes the\nsemantic characterization of the syntactic forgetting, which says that ϕ is a result of forgetting V from ψ if and only if the models of ϕ consist of the V -extensions of models of ψ.\nThe following proposition is a variant of Corollary 1 of [2] and an extension of Corollary 5 of [2].\nProposition 4 Let ϕ, ψ be two formulas and X ⊆ A. Then ϕ ≡ Forget(ψ, V ) if and only if Mod(ϕ) = Mod(ψ)†V .\nProof: (⇒) On the one hand, for every M ∈ Mod(ϕ), there exists M ′ ∈ Mod(ψ) such that M ∼V M ′ by Definition 2, i.e. M ∈ Mod(ψ)†V . On the other hand, if M ∈ Mod(ψ)†V then there exists M ′ ∈ Mod(ψ) such that M ∼V M ′, which shows that M |= ϕ by Definition 2 again. Thus Mod(ϕ) = Mod(ψ)†V .\n(⇐) Note that Mod(ϕ) = Mod(ψ)†V implies, for every M |= ϕ, there exists a mode M ′ |= ψ such that M ∼V M ′. Thus ϕ is a result of forgetting V from ψ by Definition 2, i.e. ϕ ≡ Forget(ψ, V ).\nThe following theorem shows that the forgetting is closely connected with prime implicates and implicants.\nTheorem 4 Let Π,Σ be two theories and V a set of atoms. The following conditions are equivalent to each other.\n(i) Σ ≡ Forget(Π, V ).\n(ii) Σ ≡ {ψ|Π |= ψ and IR(ψ, V )}.\n(iii) Σ ≡ ∨ {t|t ∈ IP(Π) and Var(t) ∩ V = ∅}.\n(iv) Σ ≡ {c|c ∈ PI(Π) and Var(c) ∩ V = ∅}.\nProof: (i) ⇔ (ii). It is trivial if Π ≡ ⊥. Suppose Π is not falsity. Let Π′ = {ψ|Π |= ψ and IR(ψ, V )}. It is sufficient to prove Forget(Π, V ) ≡ Π′. On the one side, M |= Forget(Π, V ) implies ∃M ′ |= Π such that M ∼V M ′. It follows that M ′ |= Π′. On the other side, M ′ |= Π′ implies M ′ can be modified to a model M of Π where M ∼V M ′. It shows that M ′ ∈ Mod(Π)†V .\n(i) ⇔ (iii). Forget(Σ, V ) ≡ Forget( ∨ IP(Σ), V ) as Σ ≡ ∨\nIP(Σ) ≡ ∨\nt∈IP(Σ) Forget(t, V ) by (i) of Proposition 3 ≡ ∨\n{t|t ∈ IP(Π) and Var(t) ∩ V = ∅} by (ii) of Proposition 3. (i) ⇔ (iv). It is proved by Theorem 37 of [24], and can follows from Proposi-\ntions 19 and 20 of [2]. .\nActually, (i)⇔(iv) is mentioned as a fact in [17], which states that Forget(Σ, V ) is equivalent to the conjunction of prime implicates of Σ that do not mention any propositions from V . In terms of Corollary 2 and the theorem above, we have the following corollary.\nCorollary 5 Let Σ be a CNF theory and V ⊆ A. If Σ is a Horn (resp. Krom, renHorn and q-Horn) expressible then Forget(Σ, V ) is a Horn (resp. Krom, ren-Horn and q-Horn) expressible."
    }, {
      "heading" : "3.2 A resolution-based algorithm",
      "text" : "Given a set Π of clauses and an atom p, the unfolding of Π w.r.t. p, written unfold(Π, p), is the set of clauses obtained from Π by replacing every clause c ∈ Π such that p ∈ Pos(c) with the clauses\nres(c, ci) (1 ≤ i ≤ k)\nwhere c1, . . . , ck are all the clauses of Π such that p ∈ Neg(ci) and, the two clauses c and ci are resolvable for every i (1 ≤ i ≤ k). In particular, if k = 0 then unfold(Π, p) is obtained from Π by simply removing all the clauses that contain the positive literal p.\nThe strong unfolding of Π w.r.t. an atom p, denoted sunfold(Π, p), is obtained from unfold(Π, p) by removing all clauses containing ¬p.\nExample 2 Let us consider the below two CNF theories.\nΠ = {p ∨ q ∨ ¬a, p ∨ ¬q, b ∨ ¬p, c ∨ ¬p}.\nΣ = {p ∨ ¬a, p ∨ ¬q ∨ ¬b, q ∨ ¬p, c ∨ ¬p}.\nWe have that\nsunfold(Π, p) = {b ∨ q ∨ ¬a, c ∨ q ∨ ¬a, b ∨ ¬q, c ∨ ¬q},\nsunfold(Π, q) = {p ∨ ¬a, b ∨ ¬p, c ∨ ¬p},\nsunfold(sunfold(Π, p), q) = {b ∨ ¬a, c ∨ ¬a, b ∨ c ∨ ¬a},\nsunfold(sunfold(Π, q), p) = {b ∨ ¬a, c ∨ ¬a},\nsunfold(Σ, p) = {q ∨ ¬a, c ∨ ¬a, c ∨ ¬q ∧ b},\nsunfold(Σ, q) = {p ∨ ¬a, c ∨ ¬p},\nsunfold(sunfold(Σ, p), q) = {c ∨ ¬a, c ∨ ¬a ∨ ¬b},\nsunfold(sunfold(Σ, q), p) = {c ∨ ¬a}.\nThough sunfold(sunfold(Π, p), q) 6= sunfold(sunfold(Π, q), p), we will see that the two theories are equivalent, i.e., having same models.\nAs demonstrated by Theorem 4, forgetting results always exist, as every formula can be translated into an equivalent CNF theory. The below proposition shows that forgetting in CNF theories can be achieved by unfolding.\nTheorem 6 Let Π be a CNF theory and p ∈ A. Then Forget(Π, p) ≡ sunfold(Π, p).\nProof: Without loss of generality, we assume that Π contains no tautology. Note that if the clause c : A ∪ ¬B in Π satisfies p /∈ A ∪ B then c ∈ sunfold(Π, p) and Forget(Π, p) |= c by (ii) of Proposition 3. Thus we can assume p ∈ A ∪ B for every clause A ∪ ¬B of Π.\nLet ci (1 ≤ i ≤ n) be all the clauses of Π such that p ∈ ci, and c′j (1 ≤ j ≤ m) be all the clauses of Π such that ¬p ∈ c′j .\nThe direction from left to right is clear by (ii) of Theorem 4, i.e., Forget(Π, p) |= sunfold(Π, p), since Π |= res(ci, c′j) for every i, j (1 ≤ i ≤ n, 1 ≤ j ≤ m) whenever ci, c′j are resolvable.\nTo prove the other direction, it is sufficient to show that for every model M of sunfold(Π, P ), there exists a model M ′ of Π such that M ′ ∼p M . We prove this by contradiction. Without loss of generality, let M |= sunfold(Π, p), p /∈ M , M ′ = M ∪ {p}, M 6|= Π and M ′ 6|= Π. It follows that M 6|= ci for some i (1 ≤ i ≤ n) and M ′ 6|= c′j for some j (1 ≤ j ≤ m). Let us consider the following two cases:\n(1) ci and c′j are not resolvable. It shows that there is an atom q different from p such that q,¬q ∈ ci ∪ c′j . Recall that ci, c ′ j are not tautology. In the case q ∈ M we have that q ∈ c′j and ¬q ∈ ci as M 6|= ci. It shows that M |= c ′ j , thus M\n′ |= c′j , a contradiction. In the case q /∈M we have that q ∈ ci and ¬q ∈ c′j as M 6|= ci. It follows that M |= c′j , thus M\n′ |= c′j , a contradiction. (2) ci and c′j are resolvable. It shows that the resolvent res(ci, c ′ j) = (ci\\{p})∪ (c′j \\ {¬p}) belongs to sunfold(Π, p). Note that M 6|= ci implies M 6|= ci \\ {p}. It follows that M |= c′j \\ {¬p} since M |= res(ci, c ′ j), thus M\n′ |= c′j \\ {¬p} and M ′ |= c′j by c ′ j \\ {¬p} |= c ′ j , a contradiction.\nProposition 5 Let Π be a CNF theory, p, q two atoms. Then we have that\nsunfold(sunfold(Π, p), q) ≡ sunfold(sunfold(Π, q), p).\nProof: By Theorem 6, we have that sunfold(sunfold(Π, p), q) ≡ sunfold(Forget(Π, p), q) ≡ Forget(Forget(Π, p), q) ≡ Forget(Π, {p, q}) ≡ Forget(Forget(Π, q), p)\n≡ Forget(sunfold(Π, q), p) ≡ Forget(Forget(Π, q), p) ≡ sunfold(sunfold(Π, p), q).\nIn terms of the above proposition, the unfolding is independent of the ordering of atoms to be strongly unfolded. We define unfolding a set of atoms as following,\nsunfold(Π, ∅) = Π,\nsunfold(Π, V ∪ {p}) = sunfold(sunfold(Π, p), V )\nwhere Π is a CNF theory and V ⊆ A. It follows that, by Theorem 6 and Proposition 5,\nCorollary 7 Let Π be a CNF theory and V ⊆ A. Forget(Π, V ) ≡ sunfold(Π, V ).\nIn terms of Corollaries 2 and 7, we have\nCorollary 8 Let Σ be a CNF theory and V ⊆ A. If Σ is a Horn (resp. Krom, renHorn and q-Horn) theory then sunfold(Σ, V ) is a Horn (resp. Krom, ren-Horn and q-Horn) theory.\nThe strong unfolding provides alternative approach of evaluating forgetting. In particular, strong unfolding results of CNF theories are in CNF as well. If Π is a Horn theory then Forget(Π, V ) is also Horn which can be achieved by strong unfolding. It distinguishes from the syntactic approach Forget(Π, p) = Π[p/⊥] ∨ Π[p/⊤], which is not in CNF, though it can be transformed into CNF (with possibly much more expense).\nBased on the notion of strong unfolding, we present the algorithm for computing forgetting results of CNF theories in Algorithm 1. The following proposition asserts the correctness.\nProposition 6 Let Π, V,Σ be as in Algorithm 1. Then Σ ≡ Forget(Π, V ).\nProof: It follows from that the lines 3-9 of Algorithm 1 compute Forget(Π, p).\nThe algorithm remains the potentiality of heuristics. For example, one can forget the atoms one by one in a specific order, and similarly choose two specific clauses to do resolution sequentially. In addition, to save space, one can add the condition Σ 6|= res(c, c′) at line 7 of the algorithm. While checking the condition is intractable generally, however, it is tractable for some special CNF theories, including Horn, ren-Horn, q-Horn and Krom ones.\nBefore end of the section, we formally analyze the computational costs.\nAlgorithm 1: An Algorithm for Forget(Π, V ) input : A set Π of clauses and a set V of atoms output: The result of forgetting V in Π 1 begin 2 S ← {c|c ∈ Π and V ∩ Var(c) = ∅}; 3 Π ← Π \\ S; 4 foreach (p ∈ V ) do 5 Π′ ← {c|c ∈ Π and p ∈ Var(c)}; 6 Σ ← Π \\ Π′; 7 foreach (c ∈ Π′ s.t p ∈ Pos(c)) do 8 foreach (c′ ∈ Π′ s.t p ∈ Neg(c′) and c, c′ are resolvable) do 9 Σ ← Σ ∪ res(c, c′);\n10 end 11 end 12 Π ← Σ; 13 end 14 return Σ ∪ S 15 end\nProposition 7 Let Π be a CNF theory and V ⊆ A where |Π| = n and |V | = k. The time and space complexity of Algorithm 1 are O(n2 k ).\nProof: It follows from that the lines 5-9 of the algorithm, which is to compute sunfold(Π, p), is bounded by O(|Π|2), and the size of sunfold(Π, p) is bounded by O(|Π|2) as well.\nOne can evidently note that, if k is given as a fixed parameter then sunfold(Π, V ) can be computed in polynomial time in the size of Π. The following example shows that an exponential explosion of Forget(Π, V ) is inescapable even if Π is a Horn theory.\nExample 3 Let Π be the Horn theory consisting of\np ∨ ¬q1 ∨ . . . ∨ ¬qn, q1 ∨ ¬r1, q1 ∨ ¬r ′ 1, . . . , qn ∨ ¬rn, qn ∨ ¬r ′ n.\nIt is not difficult to see that, for each subset I of N = {1, . . . , n},\nΠ |=\n(\n∨\ni∈I\n¬ri\n)\n∨\n\n\n∨\nj∈(N\\I)\n¬r′j\n\n ∨ p.\nThus Forget(Π, {q1, . . . , qn}) is in exponential size of Π since there are 2n number of subsets of N . And as a matter of fact, there is no Horn theory that is in polynomial size of Π and is equivalent to Forget(Π, {q1, . . . , qn}) since ( ∨ i∈I ¬ri ) ∨ (\n∨\nj∈(N\\I) ¬r ′ j\n)\n∨ p is a prime implicate of Π.\nNote that, in the case Π is a Krom theory, there are at most O(m2) number clauses where m = |Var(Π)|. Thus |Σ| in the line 7 of Algorithm 1 is bounded by O(n2) where n = |Π|. Then the overall time and space complexity is O(kn2) whenever Π is a Krom theory where k = |V |."
    }, {
      "heading" : "3.3 Complexities",
      "text" : "In the following we consider the complexities of reasoning problems on forgetting for various fragments of propositional logic."
    }, {
      "heading" : "3.3.1 DNF, CNF and arbitrary theories",
      "text" : "Proposition 8 Let Π,Σ be two (CNF) theories, and V ⊆ A. We have that\n(i) deciding if Π |= Forget(Σ, V ) is ΠP2 -complete,\n(ii) deciding if Forget(Π, V ) |= Σ is co-NP-complete,\n(iii) deciding if Forget(Π, V ) |= Forget(Σ, V ) is ΠP2 -complete.\nProof: (i) Membership. In the case Π 6|= Forget(Σ, V ), there exists a model M of Π such that M 6|= Forget(Σ, V ), i.e. for every model M ′ of Σ such that M ∼V M\n′, M ′ 6|= Σ, which can be done in polynomial time in the size of Σ and V by calling a nondeterministic Turing machine.\nHardness. It follows from the fact that ⊤ |= Forget(Σ, V ) iff Forget(Σ, V ) is valid, i.e. ∀V ′∃V Σ is valid, where V ′ = Var(Σ) \\ V . The latter is ΠP2 -complete even if Σ is a CNF theory, as every formula can be translated into a CNF theory with auxiliary variables that preserves the satisfiability, informally ∀V ′∃V Σ can be translated polynomially into ∀V ′∃V ∃V ∗Σ′ such that (a) Σ′ is a CNF theory, and (b) ∀V ′∃V Σ is valid iff ∀V ′∃V ∃V ∗Σ′ is valid, where V ∗ is the introduced auxiliary variables [28].\n(ii) Membership. If Forget(Π, V ) 6|= Σ then there exists two sets M and M ′ such that M |= Π,M ′ 6|= Σ and M ∼V M ′. It is in polynomial time to guess such M,M ′ and check the conditions M |= Π,M ′ 6|= Σ and M ∼V M ′. Hence the problem is in co-NP.\nHardness. Forget(Π, V ) |= ⊥ if and only if Π |= ⊥, i.e. Π has no model, which is co-NP-hard. Thus the problem is co-NP-complete.\n(iii) Membership. If Forget(Π, V ) 6|= Forget(Σ, V ) then there exist an interpretation M such that M |= Forget(Π, V ) but M 6|= Forget(Σ, V ), i.e., there is M ′ ∼V M withM ′ |= Π butM ′′ 6|= Σ for everyM ′′ withM ′′ ∼V M . It is evident that guessing such M,M ′ with M ∼V M ′ and checking M ′ |= Π are feasible, while checking M ′′ 6|= Σ for every M ′′ ∼V M can be done in polynomial time in the size of V and Σ by call a nondeterministic Turing machine. Thus the problem is in ΠP2 .\nHardness. It follows from (i) due to the fact that Forget(Π, V ) |= Forget(Σ, V ) iff Π |= Forget(Σ, V ).\nThe proposition implies:\nCorollary 9 Let Π,Σ be two (CNF) theories, and V ⊆ A. Then\n(i) deciding if Π ≡ Forget(Σ, V ) is ΠP2 -complete,\n(ii) deciding if Forget(Π, V ) ≡ Forget(Σ, V ) is ΠP2 -complete, and\n(iii) deciding if Forget(Π, V ) ≡ Π is co-NP-complete.\nIn the case Π is an arbitrary propositional formula, (ii) and (iii) of the corollary corresponds to VAR-EQUIVALENCE and VAR-INDEPENDENCE in [2], in which it is proved to be the same complexity as that of CNF theory case, respectively. Note that the inverse of item (iii) is the relevance problem, i.e., if a formula Π is relevant to V , which is NP-hard (cf. Theorem 50 of [24]).\nRecall that Forget(ϕ, p) = ϕ[p/⊤]∨ϕ[p/⊥] for a given formula ϕ and an atom p. According to (i) of Proposition 4, when ϕ is a term l1 ∧ · · · ∧ ln, Forget(ϕ, V ) is the term obtained from ϕ by replacing li (1 ≤ i ≤ n) with ⊤ if Var(li) ⊆ V . E.g. Forget(p ∧ ¬q, {p}) ≡ ¬q and Forget(p ∧ ¬q, {q}) ≡ q. It implies that if Π is a DNF theory then Forget(Π, V ) can be computed in linear time in the size of Π by (i) of Proposition 3.\nProposition 9 Let Π,Σ be two DNF theories, and V ⊆ A. The following problems are co-NP-complete:\n(i) deciding if Π |= Forget(Σ, V ),\n(ii) deciding if Forget(Π, V ) |= Σ,\n(iii) deciding if Forget(Π, V ) |= Forget(Σ, V ).\nProof: (i) Membership. It is obvious that if Π 6|= Forget(Σ, V ) then there exists a set M of atoms such that M |= Π and M 6|= Forget(Σ, V ). As Forget(Σ, V ) is\ncomputable in polynomial time, the checking M |= Π and M 6|= Forget(Σ, V ) is feasible in polynomial time as well. Hence the problem is in co-NP.\nHardness. Let Π ≡ ⊤. Note that ⊤ |= Forget(Σ, V ) iff Forget(Σ, V ) is valid. As Forget(Σ, V ) is still a DNF theory whose validness is co-NP-hard, it shows that the problem is co-NP-hard as well.\n(ii) and (iii) can be similarly proved as that of (i).\nThe proposition above implies\nCorollary 10 Let Π,Σ be two DNF theories, and V ⊆ A. The following problems are co-NP-complete.\n(i) deciding if Π ≡ Forget(Σ, V ),\n(ii) deciding if Forget(Π, V ) ≡ Forget(Σ, V ),\n(iii) deciding if Forget(Π, V ) ≡ Π."
    }, {
      "heading" : "3.3.2 Horn theories and its variants",
      "text" : "For a Horn formula Σ, its dependency graph is the directed graph G(Σ) = (V,E), where V = A and (ai, aj) ∈ E iff there is a Horn clause c ∈ Σ such that ¬ai ∈ c and aj ∈ c. A Horn formula Σ is acyclic if G(Σ) has no directed cycle.\nTheorem 11 Let Π,Σ be Horn (resp. ren-Horn and q-Horn) theories and V ⊆ A.\n(i) The problem of deciding if Π |= Forget(Σ, V ) is co-NP-complete, even if Π and Σ are acyclic.\n(ii) The problem of deciding if Forget(Π, V ) |= Σ is tractable.\n(iii) The problem of deciding if Forget(Π, V ) |= Forget(Σ, V ) is co-NP-complete, even if Π and Σ are acyclic.\nProof: (i) Membership. Note that Π 6|= Forget(Σ, V ) iff there is a prime implicate c of Σ such that Var(c)∩V = ∅ and Π 6|= c, the latter holds iff Π∪¬c has a model, where ¬c = {¬l|l is a disjunct of c}. In the case Π is q-Horn, Π ∪ ¬c is q-Horn and its satiability checking is tractable [21]. One can guess such a prime implicate c and check if Π 6|= c in polynomial time in the size of Π and Σ. Thus the problem is in co-NP even if Π,Σ are q-Horn theories.\nHardness. Let γ = c1 ∧ · · · ∧ cm be a 3CNF formula over atoms x1, . . . , xn, where ci = li,1 ∨ li,2 ∨ li,3. The below construction is quite similar to the one used in the proof of Theorem 4.1 [29]. We introduce for each clause ci a new atom yi, for each atom xj a new atom x′j (which intuitively corresponds to ¬xj), and a\nspecial atom z. The Horn theory Π = {¬xi ∨ ¬x′i|1 ≤ i ≤ n} and Σ contains Π and additional the below clauses:\n¬z ∨ y1, ¬yi ∨ ¬l ∗ i,j ∨ yi+1 for all i = 1, . . . , m− 1, and j = 1, 2, 3, ¬ym ∨ ¬l ∗ m,j for j = 1, 2, 3\nwhere l∗ = x if l is a positive literal x, and l∗ = x′ if l is a negative literal ¬x. It is clear that both Π and Σ are acyclic Horn formulas, thus Horn renamable and q-Horn formulas. We claim that γ is satisfiable iff Π 6|= Forget(Σ, V ) where V = {y1, . . . , ym}. It is easy to see that Σ has a prime implicate c such that Var(c) ∩ V = ∅ and c /∈ Π iff Π 6|= Forget(Σ, V ).\nOn the one hand, let σ be a satisfying assignment of γ. Then we arbitrarily choose from each ci a literal li,ji satisfied by σ. It follows that c = ¬z ∨ ( ∨\n1≤i≤m ¬l ∗ i,ji ) is an implicate of Σ where ji ∈ {1, 2, 3}, and c contains at most one literal in {¬xi,¬x′i} for every i (1 ≤ i ≤ n). As Var(c)∩V = ∅, and ∨ i ¬l ∗ i,ji is not an implicate of Π since there is no subclauses of it is generated by the resolution procedure for Π, we have that c is a prime implicate of Σ and Π 6|= c. Thus Π 6|= Forget(Σ, V ).\nOn the other hand, there exists a prime implicate c of Σ such that both Π 6|= c and Var(c)∩V = ∅ due to Π 6|= Forget(Σ, V ). This prime implicate c can only be generated from the Horn clauses in Σ \\ Π and has the form ¬z ∨ ( ∨\n1≤i≤m ¬l ∗ i,ji ) where ji ∈ {1, 2, 3}. As ¬xi ∨ ¬x′i ∈ Π, we have ¬xi ∨ ¬x ′ i 6|= c for every i (1 ≤ i ≤ n) due to Π 6|= c. It shows that c mentions at most one atom in {xi, x′i} for every i. Therefore c corresponds to a satisfying assignment for γ.\n(ii) In the case that Σ is unsatisfiable, i.e. Σ ≡ ⊥, Forget(Π, V ) ≡ ⊥ iff Π ≡ ⊥. In this case the problem is tractable. Suppose Σ is satisfiable. We have Forget(Π, V ) |= Σ iff Forget(Π, V ) |= c for every clause c of Σ. In the case Var(c) ∩ V 6= ∅, we have Forget(Π, V ) 6|= c. in the case Var(c) ∩ V = ∅, Forget(Π, V ) |= c iff Π |= c iff Π ∪ ¬c is unsatisfiable, which is tractable even if Π is a q-Horn theory [21].\n(iii) Membership. If Forget(Π, V ) 6|= Forget(Σ, V ) then there exists a prime implicate c of Σ such that Π 6|= c and Var(c) ∩ V = ∅. Thus it is in co-NP.\nHardness. It follows from (i) since Forget(Π, V ) |= Forget(Σ, V ) iff Π |= Forget(Σ, V ).\nAccordingly, we have the following corollary.\nCorollary 12 Let Π,Σ be two Horn (resp. ren-Horn and q-Horn) theories and V ⊆ A.\n(i) The problem of deciding if Π ≡ Forget(Σ, V ) is co-NP-complete.\n(ii) The problem of deciding if Forget(Π, V ) ≡ Forget(Σ, V ) is co-NP-complete.\n(iii) The problem of deciding if Forget(Π, V ) ≡ Π is tractable.\nProof: (i) As Π 6≡ Forget(Σ, V ) iff Π 6|= Forget(Σ, V ) or Forget(Σ, V ) 6|= Π, the latter is tractable by (ii) of Theorem 11 while the former is in co-NP. Hardness follows from (i) of Theorem 11. Thus the problem is co-NP-complete.\n(ii) Membership is easy. Hardness follows from (iii) of Theorem 11. (iii) It follows from the facts that Forget(Π, V ) ≡ Π iff Forget(Π, V ) |= Π,\nand (ii) of Theorem 11.\nThe item (iii) in the above corollary shows that the problem of deciding whether Π is relevant to V is tractable if Π is a q-Horn theory. Thus it generalizes Theorem 51 of [24] for Horn theories."
    }, {
      "heading" : "3.3.3 Krom theories",
      "text" : "Note that, for every Krom theory Σ and V ⊆ A. It is evident that\nForget(Σ, V ) ≡ {l1 ∨ l2|Var({l1, l2}) ⊆ Var(Σ) \\ V and Σ |= l1 ∨ l2}.\nIt implies that Forget(Σ, V ) can be computed in polynomial time in the size of Σ and V since Σ |= l1 ∨ l2 is tractable [23] and there are at most O(|Var(Σ) \\ V |2) number of such clauses. The following corollary follows.\nCorollary 13 Let Π,Σ be two Krom theories and V ⊆ A. All of the following problems are tractable:\n(i) deciding if Π |= Forget(Σ, V ),\n(ii) deciding if Forget(Π, V ) |= Σ,\n(iii) deciding if Forget(Π, V ) |= Forget(Σ, V ),\n(iv) deciding if Π ≡ Forget(Σ, V ),\n(v) deciding if Forget(Π, V ) ≡ Forget(Σ, V ),\n(vi) deciding if Forget(Π, V ) ≡ Π."
    }, {
      "heading" : "4 Related Work",
      "text" : "In the section we consider the applications of forgetting, including uniform interpolation [30], strongest necessary and weakest sufficient conditions [17], and strongest and weakest definitions [18]."
    }, {
      "heading" : "4.1 Uniform interpolation",
      "text" : "Let α, β be two formulas. If α |= β, an interpolant for (α, β) is a formula γ s.t\nα |= γ and γ |= β (1)\nwhere Var(γ) ⊆ Var(α) ∩ Var(β). A logic L with inference |=L is said to have the interpolantion property if an interpolant exists for every pair of formulas (α, β) such that α |=L β. A logic L has uniform interpolation property iff for any formula α and V a set of atoms, there exists a formula γ such that Var(γ) ⊆ Var(α) \\ V , and for any formula β with Var(β) ∩ V = ∅,\nα |=L β iff γ |=L β. (2)\nIt is easy to see that uniform interpolation is a strengthening of interpolation. A well-known result is that propositional logic has uniform interpolation property, while first-order logic does not [30].\nProposition 10 If Σ is a double Horn theory and V ⊆ A then Forget(Σ, V ) is a double Horn theory.\nProof: Firstly Forget(Σ, V ) is Horn expressible by Corollary 5. We show that ¬Forget(Σ, V ) is Horn expressible by contradiction in the following. Suppose that there exist two interpretations X, Y such that\nX 6|= Forget(Σ, V ), Y 6|= Forget(Σ, V ), X ∩ Y |= Forget(Σ, V ).\nNote that Forget(Σ, V ) is irrelevant to V . Thus I |= Forget(Σ, V ) if and only if I \\ V |= Forget(Σ, V ). For this reason, we assume X ∩ V = ∅ and Y ∩ V = ∅. The following three conditions hold:\n(a) X ′ 6|= Σ for any X ⊆ X ′ ⊆ X ∪ V .\n(b) Y ′ 6|= Σ for any Y ⊆ Y ′ ⊆ Y ∪ V .\n(c) There exists Z |= Σ for some X ∩ Y ⊆ Z ⊆ X ∩ Y ∪ V .\nThe conditions (a) and (b) imply X ′ ∩ Y ′ 6|= Σ since Σ is a double Horn formula. It is evident that X ∩ Y ⊆ X ′ ∩ Y ′ ⊆ (X ∪ V ) ∩ (Y ∪ V ) = X ∩ Y ∪ V . This contradicts with condition (c).\nTogether with Corollary 8, the proposition above implies:\nCorollary 14 The Horn, Krom, double Horn, ren-Horn and q-Horn fragments of propositional logic have uniform interpolation property."
    }, {
      "heading" : "4.2 Strongest necessary and weakest sufficient conditions",
      "text" : "Let T be a theory, V ⊆ Var(T ) and q ∈ Var(T ) \\ V . A formula ϕ of V is a necessary condition of q on V under T if T |= q ⊃ ϕ. It is a strongest necessary condition (SNC) if it is a necessary condition and for any other necessary condition ϕ′, T |= ϕ ⊃ ϕ′. A formula ψ of V is a sufficient condition of q on V under T if T |= ψ ⊃ q. It is a weakest sufficient condition (WSC) if it is a sufficient condition and, for any other sufficient condition ψ′, T |= ψ′ ⊃ ψ [17].\nTheorem 15 (Theorem 2 of [17]) Let T be a theory, V ⊆ Var(T ), q ∈ Var(T ) \\ V , and V ′ = Var(T ) \\ (V ∪ {q}).\n• The strongest necessary condition of q on V under T is Forget(T [q/⊤], V ′).\n• The weakest sufficient condition of q on V under T is ¬Forget(T [q/⊥], V ′).\nNote that T [q/⊤] is a Horn (resp. Krom, ren-Horn and q-Horn) theory if T is a Horn (resp. Krom, ren-Horn and q-Horn) theory. In terms of Corollary 14, the SNC of q under T is Horn (resp. Krom, ren-Horn and q-Horn) expressible if T is a Horn (resp. Krom, ren-Horn and q-Horn) theory.\nThe following example shows that the weakest sufficient condition on Horn (resp. Krom) formulas may be not Horn (resp. Krom) expressible.\nExample 4 Let’s consider the following two theories. (1) Let Σ = (¬p ∨ ¬r) ∧ (¬q ∨ r) ∧ (¬s ∨ r) ∧ ¬t, which is a Horn formula. We have that Forget(Σ[t/⊥], r) ≡ (¬p∨¬q)∧ (¬p∨¬s). Thus ¬Forget(Σ, r) ≡ p∧ (q∨ s), which is evidently not Horn expressible. That is the weakest sufficient condition of t on {p, q, s} under Σ is not Horn expressible.\n(2) Let Π = (p1 ∨ p2) ∧ (¬p1 ∨ p3) ∧ (¬p2 ∨ ¬p3) ∧ ¬q, which is a Krom formula. Note that Forget(Π[q/⊥], ∅) ≡ (p1 ∨ p2) ∧ (¬p1 ∨ p3) ∧ (¬p2 ∨ ¬p3). Thus ¬Forget(Π[q/⊥], ∅) ≡ (¬p1 ∨ p2 ∨ ¬p3) ∧ (p1 ∨ ¬p2 ∨ p3) ∧ (¬p2 ∨ ¬p3). It is not a Krom formula. Actually, the clause ¬p1 ∨ p2 ∨¬p3 is a prime implicate of ¬Forget(Π[q/⊥], ∅).\nTheorem 16 Let T, ϕ be two formulas, V ⊆ Var(T ), q ∈ Var(T ) \\ V .\n(i) Deciding if ϕ is a necessary (sufficient) condition of q under T is co-NPcomplete.\n(ii) Deciding if ϕ is a necessary (sufficient) condition of q under T is tractable if T and ϕ are Horn (resp. ren-Horn and q-Horn) formulas.\n(iii) Deciding if ϕ is a strongest necessary (weakest sufficient) condition of q under T is ΠP2 -complete.\n(iv) Deciding if ϕ is a strongest necessary (weakest sufficient) condition of q under T is co-NP-complete if T and ϕ are Horn (resp. ren-Horn and qHorn) formulas.\nProof: (i) T |= q ⊃ ϕ iff T ∧ q∧¬ϕ is unsatisfiable. This is in co-NP and co-NPhard, i.e. deciding if ϕ is a necessary condition of q under T is co-NP-complete. The case of sufficient condition is similar.\n(ii) T |= q ⊃ ϕ iff T ∧ q ∧ ¬c is unsatisfiable for every clause c of ϕ, which is tractable even T and ϕ are q-Horn formulas. Thus deciding if ϕ is a necessary condition of q under T is tractable. Similarly T |= ϕ ⊃ q iff T ∧ ϕ ∧ ¬q is unsatisfiable even if T and ϕ are q-Horn formulas.\n(iii) In terms of Theorem 15, ϕ is a strongest necessary condition of q under T iff ϕ ≡ Forget(T [q/⊤], V ′) where V ′ = Var(T ) \\ (V ∪ {q}). It is in ΠP2 and ΠP2 -hard by (i) of Corollary 9.\n(iv) Recall that ϕ is a strong necessary condition of q under T if and only if ϕ ≡ Forget(T [q/⊤], V ′) by (i) of Theorem 15 where V ′ = Var(T ) \\ (V ∪ {q}). Thus it is in co-NP when ϕ and T are q-Horn formulas and is co-NP-hard when ϕ and T are Horn formulas by (i) of Corollary 12.\nProposition 11 Let T and ϕ be two Krom formulas, V ⊆ Var(T ), q ∈ Var(T )\\V .\n(i) Deciding if ϕ is a strongest necessary condition of q under T is tractable.\n(ii) Deciding if ϕ is a weakest sufficient condition of q under T is tractable.\nProof: Firstly, according to Theorem 4, one can compute Forget(T [q/⊤], V ′) in polynomial time in the size of T and V where V ′ = Var(T ) \\ (V ∪ {q}). It is evident that Σ = sunfold(Forget[q/⊤], V ′) and Σ′ = Forget(T [q/⊥], V ′) are Krom theories.\n(i) It follows from the facts that checking equivalence for Krom theories is tractable and ϕ is a strongest condition of q under T iff ϕ ≡ Σ by (i) of Theorem 15.\n(ii) ϕ is a weakest sufficient condition of q under T iff ϕ ≡ ¬Σ′ iff ϕ |= ¬Σ′ and ¬Σ′ |= ϕ iff ϕ ∧ Σ′ is unsatisfiable and ¬Σ′ |= l1 ∨ l2 for every conjunct l1 ∨ l2 of ϕ.\nIt is evident that checking satisfiability of ϕ ∧ Σ′ is tractable since ϕ ∧ Σ′ is a Krom formula. Note further that ¬Σ′ |= l1 ∨ l2 iff ¬Σ′ ∧ ¬l1 ∧ ¬l2 is unsatisfiable iff Σ′′ = ¬(Σ′[¬l1/⊤][¬l2/⊤]) is unsatisfiable iff s1 ∧ s2 is unsatisfiable for every disjunct s1 ∧ s2 of Σ′′, which is a 2-DNF formula."
    }, {
      "heading" : "4.3 Strongest and weakest definitions",
      "text" : "Definability is acknowledged as an important logical concept when reasoning about knowledge represented in propositional logic. Informally speaking, an atom p can be “defined” in a given formula Σ in terms of a set X of atoms whenever the knowledge of the truth values of X enables concluding about the truth value of p, under the condition of Σ [18].\nDefinition 3 ([18]) Let Σ be a formula, p ∈ A, X ⊆ A and Y ⊆ A.\n• Σ defines p in terms of X , denoted by X ⊑Σ p, iff there exists a formula Ψ over X such that Σ |= Ψ ↔ p.\n• Σ defines Y in terms of X , denoted by X ⊑Σ Y , iff there exists a formula Ψ over X such that Σ |= Ψ ↔ p for every p ∈ Y .\nIt is known that if both ϕ and ψ (over a same signature X) are definitions of p in Σ then Σ |= ϕ ↔ ψ, and additionally both ϕ ∧ ψ and ϕ ∨ ψ are definitions of p in Σ. In this situation, the strongest (resp. weakest) definition of p in Σ exist, they are denoted by DefX,lΣ (p) and Def X,u Σ (p) respectively. In terms of Corollary 9 of [3] and Theorem 10 of [18], if Σ defines p in terms of X then DefX,lΣ (p) (resp. DefX,uΣ (p)) is equivalent to the strongest necessary (resp. weakest sufficient) condition of p under Σ. Thus according to Theorem 16 and Proposition 11 we have the following:\nCorollary 17 Let Σ, ϕ be two formulas, X ⊆ A, p ∈ A and Var(ϕ) ⊆ X .\n(i) The problem of deciding if ϕ is a strongest (resp. weakest) definition of p (in terms of X) in Σ is ΠP2 -complete.\n(ii) The problem of deciding if ϕ is a strongest (resp. weakest) definition of p (in terms of X) in Σ is co-NP-complete if both Σ and ϕ are Horn (resp. ren-Horn and q-Horn) formulas.\n(iii) deciding if ϕ is a strongest (resp. weakest) definition of p (in terms of X) in Σ is tractable if both Σ and ϕ are Krom formulas."
    }, {
      "heading" : "5 Concluding Remarks",
      "text" : "As mentioned in the introduction, forgetting is closely connected with many other logical concepts. Quite late, the notion of relevance was quantitatively investigated [31], and the notion of independence was applied to belief change [32], which is a long-standing and vive topic in AI [33]. The main concerned Horn,\nKrom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].\nIn the paper we have firstly presented a resolution-based algorithm for computing forgetting results of CNF fragments of propositional logic. Though the algorithm is generally expensive even for Horn fragment as it is theoretically intractable, it opens a heuristic potentiality, e.g. choosing different orders of atoms to forget, and choosing different orders of resolvable clauses to do resolution. To investigate the effectiveness of the algorithm, heuristics and extensive experiments are worthy of studying.\nWhat’s more, when concerning the dynamics of knowledge base, we considered various reasoning problems about forgetting in the fragments of propositional logic whose satisfiability are tractable. In particular, we concentrated on Horn, renamable Horn, q-Horn and Krom theories. The considered reasoning problems include VAR-EQUIVALENCE, VAR-INDEPENDENCE, VAR-WEAK, VAR-STRONG, VAR-MATCH and VAR-ENTAILMENT. Although some of the problems have been partially solved, e.g., VAR-EQUIVALENCE and VAR-INDEPENDENCE for propositional logic are proved in [2], this is the first comprehensive study on these problems for CNF, Horn, ren-Horn, q-Horn, Krom and DNF fragments, to our knowledge. It motivates us to consider these reasoning problems for forgetting in non-classical logical systems, such as model logic S5 in particular.\nIt deserves our further effort to investigate the knowledge simplification or compilation [16] in other logical formalisms, logic programming under stable model semantics, particularly.\nAcknowledgement This work was supported by the National Natural Science Foundation of China under grants 60963009,61370161 and Stadholder Foundation of Guizhou Province under grant (2012)62."
    } ],
    "references" : [ {
      "title" : "Propositional independence: Formula-variable independence and forgetting",
      "author" : [ "Jérôme Lang", "Paolo Liberatore", "Pierre Marquis" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2003
    }, {
      "title" : "Reasoning under inconsistency: A forgetting-based approach",
      "author" : [ "Jérôme Lang", "Pierre Marquis" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2010
    }, {
      "title" : "Uniform interpolation and layered bisimulation",
      "author" : [ "Albert Visser" ],
      "venue" : "In Gödel’96,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 1996
    }, {
      "title" : "Solving logic program conflict through strong and weak forgettings",
      "author" : [ "Yan Zhang", "Norman Y. Foo" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2006
    }, {
      "title" : "Semantic forgetting in answer set programming",
      "author" : [ "Thomas Eiter", "Kewen Wang" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2008
    }, {
      "title" : "Forgetting in Logic Programs",
      "author" : [ "Ka-Shu Wong" ],
      "venue" : "PhD thesis, The University of New South Wales,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2009
    }, {
      "title" : "Forgetting in logic programs under strong equivalence",
      "author" : [ "Yisong Wang", "Yan Zhang", "Yi Zhou", "Mingyi Zhang" ],
      "venue" : "In Principles of Knowledge Representation and Reasoning: Proceedings of the Thirteenth International Conference,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2012
    }, {
      "title" : "Forgetting for answer set programs revisited",
      "author" : [ "Yisong Wang", "Kewen Wang", "Mingyi Zhang" ],
      "venue" : "IJCAI",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2013
    }, {
      "title" : "Forgetting for knowledge bases in dl-lite",
      "author" : [ "Zhe Wang", "Kewen Wang", "Rodney W. Topor", "Jeff Z. Pan" ],
      "venue" : "Annuals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2010
    }, {
      "title" : "Foundations for uniform interpolation and forgetting in expressive description logics",
      "author" : [ "Carsten Lutz", "Frank Wolter" ],
      "venue" : "IJCAI",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2011
    }, {
      "title" : "Knowledge forgetting: Properties and applications",
      "author" : [ "Yan Zhang", "Yi Zhou" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2009
    }, {
      "title" : "Variable forgetting in reasoning about knowledge",
      "author" : [ "Kaile Su", "Abdul Sattar", "Guanfeng Lv", "Yan Zhang" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2009
    }, {
      "title" : "On the progression of knowledge in the situation calculus",
      "author" : [ "Yongmei Liu", "Ximing Wen" ],
      "venue" : "IJCAI",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2011
    }, {
      "title" : "Knowledge compilation in the modal logic s5",
      "author" : [ "Meghyn Bienvenu", "Hélène Fargier", "Pierre Marquis" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2010
    }, {
      "title" : "On strongest necessary and weakest sufficient conditions",
      "author" : [ "Fangzhen Lin" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2001
    }, {
      "title" : "On propositional definability",
      "author" : [ "Jérôme Lang", "Pierre Marquis" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2008
    }, {
      "title" : "On sentences which are true of direct unions of algebras",
      "author" : [ "Alfred Horn" ],
      "venue" : "The Journal of Symbolic Logic,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1951
    }, {
      "title" : "Renaming a set of clauses as a horn set",
      "author" : [ "Harry R. Lewis" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1978
    }, {
      "title" : "Polynomial-time inference of all valid implications for horn and related formulae",
      "author" : [ "Endre Boros", "Yves Crama", "Peter L. Hammer" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1990
    }, {
      "title" : "The decision problem for formulas in prenex conjunctive normal form with binary disjunctions",
      "author" : [ "M.R. Krom" ],
      "venue" : "The Journal of Symbolic Logic,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1970
    }, {
      "title" : "Relevance from an epistemic perspective",
      "author" : [ "Gerhard Lakemeyer" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1997
    }, {
      "title" : "Handbook of Defeasible Reasoning and Uncertainty Management Systems: Algorithms for Defeasible and Uncertain Reasoning, volume 5, chapter Consequence finding algorithms, pages 41–145",
      "author" : [ "Pierre Marquis" ],
      "venue" : null,
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 1999
    }, {
      "title" : "On renamable horn and generalized horn functions",
      "author" : [ "V. Chandru", "Collette R. Coullard", "Peter L. Hammer", "M. Montanuz", "Xiaorong Sun" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 1990
    }, {
      "title" : "Recognition of q-horn formulae in linear time",
      "author" : [ "Endre Boros" ],
      "venue" : "Discrete Applied Mathematics,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1994
    }, {
      "title" : "Handbook of Satisfiability, chapter 23 Theory of Quantified Boolean Formulas, pages 735–760",
      "author" : [ "Hans Kleine Büning", "Uwe Bubeck" ],
      "venue" : null,
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2009
    }, {
      "title" : "On computing all abductive explanations from a propositional horn theory",
      "author" : [ "Thomas Eiter", "Kazuhisa Makino" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2007
    }, {
      "title" : "Interpolation in non-classical",
      "author" : [ "Giovanna D’Agostino" ],
      "venue" : "logics. Synthese,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2008
    }, {
      "title" : "Quantitatively evaluating formula-variable relevance by forgetting",
      "author" : [ "Xin Liang", "Zuoquan Lin", "Jan Van den Bussche" ],
      "venue" : "In Canadian Conference on AI,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2013
    }, {
      "title" : "Lost in translation: Language independence in propositional logic – application to belief change",
      "author" : [ "Pierre Marquis", "Nicolas Schwind" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2014
    }, {
      "title" : "On the logic of theory change: Partial meet contraction and revision functions",
      "author" : [ "Carlos E. Alchourrön", "Peter Gärdenfors", "David Makinson" ],
      "venue" : "Journal of Symbolic Logic,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1985
    }, {
      "title" : "Quantifier rewriting and equivalence models for quantified horn formulas",
      "author" : [ "Uwe Bubeck", "Hans Kleine Büing", "Xishun Zhao" ],
      "venue" : "editors, Theory and Applications of Satisfiability Testing,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2005
    }, {
      "title" : "Redundancy in logic II: 2CNF and horn propositional formulae",
      "author" : [ "Paolo Liberatore" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2008
    }, {
      "title" : "Language splitting and relevance-based belief change in horn logic",
      "author" : [ "Maonian Wu", "Dongmo Zhang", "Mingyi Zhang" ],
      "venue" : null,
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2011
    }, {
      "title" : "Horn clause contraction functions",
      "author" : [ "James P. Delgrande", "Renata Wassermann" ],
      "venue" : "Journal of Artificial Intelligence Research,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2013
    }, {
      "title" : "Belief revision in horn theories",
      "author" : [ "James P. Delgrande", "Pavlos Peppas" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2015
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Motivated from Lin and Reiter’s seminal work in first-order logic [1], the notion of forgetting – distilling from a knowledge base only the part that is relevant to a subset of the alphabet – has attracted extensive interests [2, 3].",
      "startOffset" : 226,
      "endOffset" : 232
    }, {
      "referenceID" : 1,
      "context" : "Motivated from Lin and Reiter’s seminal work in first-order logic [1], the notion of forgetting – distilling from a knowledge base only the part that is relevant to a subset of the alphabet – has attracted extensive interests [2, 3].",
      "startOffset" : 226,
      "endOffset" : 232
    }, {
      "referenceID" : 2,
      "context" : "A dual notion of forgetting in mathematical logic is called uniform interpolation [4].",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 3,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 191,
      "endOffset" : 207
    }, {
      "referenceID" : 4,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 191,
      "endOffset" : 207
    }, {
      "referenceID" : 5,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 191,
      "endOffset" : 207
    }, {
      "referenceID" : 6,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 191,
      "endOffset" : 207
    }, {
      "referenceID" : 7,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 191,
      "endOffset" : 207
    }, {
      "referenceID" : 8,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 241,
      "endOffset" : 249
    }, {
      "referenceID" : 9,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 241,
      "endOffset" : 249
    }, {
      "referenceID" : 10,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 291,
      "endOffset" : 303
    }, {
      "referenceID" : 11,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 291,
      "endOffset" : 303
    }, {
      "referenceID" : 12,
      "context" : "In recent years, researchers have developed forgetting notions and theories in other non-classical logic systems, such as forgetting in logic programs under answer set/stable model semantics [6, 7, 8, 9, 10], forgetting in description logic [11, 12], and knowledge forgetting in modal logic [13, 14, 15].",
      "startOffset" : 291,
      "endOffset" : 303
    }, {
      "referenceID" : 3,
      "context" : "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.",
      "startOffset" : 26,
      "endOffset" : 32
    }, {
      "referenceID" : 1,
      "context" : "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.",
      "startOffset" : 26,
      "endOffset" : 32
    }, {
      "referenceID" : 10,
      "context" : "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.",
      "startOffset" : 59,
      "endOffset" : 67
    }, {
      "referenceID" : 13,
      "context" : "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.",
      "startOffset" : 59,
      "endOffset" : 67
    }, {
      "referenceID" : 14,
      "context" : "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.",
      "startOffset" : 190,
      "endOffset" : 194
    }, {
      "referenceID" : 15,
      "context" : "used for conflict solving [6, 3] and knowledge compilation [13, 16], and it is also closely related to other logical notions, including strongest necessary and weakest sufficient conditions [17], strongest and weakest definitions [18] and so on.",
      "startOffset" : 230,
      "endOffset" : 234
    }, {
      "referenceID" : 0,
      "context" : "have showed that deciding if a formula is independent of a set of atoms (called VAR-INDEPENDENCE) is co-NP-complete, and deciding if two formulas are equivalent on a common signature (called VAR-EQUIVALENCE) is Π2 -complete [2].",
      "startOffset" : 224,
      "endOffset" : 227
    }, {
      "referenceID" : 16,
      "context" : "To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 17,
      "context" : "To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.",
      "startOffset" : 155,
      "endOffset" : 159
    }, {
      "referenceID" : 18,
      "context" : "To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.",
      "startOffset" : 197,
      "endOffset" : 205
    }, {
      "referenceID" : 15,
      "context" : "To our best knowledge, such two reasoning problems remain unknown for many interesting fragments of propositional logic, such as Horn [19], renamable Horn [20] (ren-Horn in short), q-Horn theories [21, 18] and so forth.",
      "startOffset" : 197,
      "endOffset" : 205
    }, {
      "referenceID" : 19,
      "context" : "Accordingly, we show that forgetting is categorical in the Horn, ren-Horn, q-Horn, double Horn [22] and Krom [23] (or 2-CNF) fragments.",
      "startOffset" : 109,
      "endOffset" : 113
    }, {
      "referenceID" : 19,
      "context" : "ren-Horn, q-Horn, double Horn and Krom [23] (or 2-CNF)) theory is Horn (resp.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 0,
      "context" : "More importantly, from the perspective of knowledge bases evolving, we are also interested in the following reasoning problems about forgetting, besides the VAR-INDEPENDENCE and VAR-EQUIVALENCE in [2], where Forget(φ, V ) stands for a result of forgetting V from formula φ, (1) [VAR-INDEPENDENCE] If a knowledge base Π is independent of a set V of atoms, i.",
      "startOffset" : 197,
      "endOffset" : 200
    }, {
      "referenceID" : 19,
      "context" : "In particular, 2-CNF formulas are called Krom formulas [23].",
      "startOffset" : 55,
      "endOffset" : 59
    }, {
      "referenceID" : 20,
      "context" : "The definition of relevant is equivalent with, but slightly different from, that of [24], in which ψ is relevant to V if there is a prime implicate of ψ which mentions some atom from V .",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 21,
      "context" : "The following lemma is well-known [25].",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 16,
      "context" : "A clause c is Horn [19] if |Pos(c)| ≤ 1.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 17,
      "context" : "A CNF formula φ is Horn renamable [20] iff there exists a Horn renaming for it, i.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 18,
      "context" : "Definition 1 ([21, 18]) A CNF theory Σ has a QH-partition iff there exists a partition {Q,H} of Var(Σ) s.",
      "startOffset" : 14,
      "endOffset" : 22
    }, {
      "referenceID" : 15,
      "context" : "Definition 1 ([21, 18]) A CNF theory Σ has a QH-partition iff there exists a partition {Q,H} of Var(Σ) s.",
      "startOffset" : 14,
      "endOffset" : 22
    }, {
      "referenceID" : 18,
      "context" : "A CNF theory Σ is q-Horn iff there exists a q-Horn renaming for it [21], i.",
      "startOffset" : 67,
      "endOffset" : 71
    }, {
      "referenceID" : 17,
      "context" : "It is known that it is tractable to recognize if a CNF theory is ren-Horn [20, 26], q-Horn [27], or double-Horn [22], and the satisfiability of ren-Horn, q-Horn and double Horn formulas are all tractable.",
      "startOffset" : 74,
      "endOffset" : 82
    }, {
      "referenceID" : 22,
      "context" : "It is known that it is tractable to recognize if a CNF theory is ren-Horn [20, 26], q-Horn [27], or double-Horn [22], and the satisfiability of ren-Horn, q-Horn and double Horn formulas are all tractable.",
      "startOffset" : 74,
      "endOffset" : 82
    }, {
      "referenceID" : 23,
      "context" : "It is known that it is tractable to recognize if a CNF theory is ren-Horn [20, 26], q-Horn [27], or double-Horn [22], and the satisfiability of ren-Horn, q-Horn and double Horn formulas are all tractable.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 0,
      "context" : "The following proposition easily follows from the definition of forgetting, cf, Propositions 17 and 21 of [2].",
      "startOffset" : 106,
      "endOffset" : 109
    }, {
      "referenceID" : 0,
      "context" : "The following proposition is a variant of Corollary 1 of [2] and an extension of Corollary 5 of [2].",
      "startOffset" : 57,
      "endOffset" : 60
    }, {
      "referenceID" : 0,
      "context" : "The following proposition is a variant of Corollary 1 of [2] and an extension of Corollary 5 of [2].",
      "startOffset" : 96,
      "endOffset" : 99
    }, {
      "referenceID" : 20,
      "context" : "It is proved by Theorem 37 of [24], and can follows from Propositions 19 and 20 of [2].",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 0,
      "context" : "It is proved by Theorem 37 of [24], and can follows from Propositions 19 and 20 of [2].",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 14,
      "context" : "Actually, (i)⇔(iv) is mentioned as a fact in [17], which states that Forget(Σ, V ) is equivalent to the conjunction of prime implicates of Σ that do not mention any propositions from V .",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 24,
      "context" : "The latter is Π2 -complete even if Σ is a CNF theory, as every formula can be translated into a CNF theory with auxiliary variables that preserves the satisfiability, informally ∀V ∃V Σ can be translated polynomially into ∀V ∃V ∃V Σ such that (a) Σ is a CNF theory, and (b) ∀V ∃V Σ is valid iff ∀V ∃V ∃V Σ is valid, where V ∗ is the introduced auxiliary variables [28].",
      "startOffset" : 364,
      "endOffset" : 368
    }, {
      "referenceID" : 0,
      "context" : "In the case Π is an arbitrary propositional formula, (ii) and (iii) of the corollary corresponds to VAR-EQUIVALENCE and VAR-INDEPENDENCE in [2], in which it is proved to be the same complexity as that of CNF theory case, respectively.",
      "startOffset" : 140,
      "endOffset" : 143
    }, {
      "referenceID" : 20,
      "context" : "Theorem 50 of [24]).",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 18,
      "context" : "In the case Π is q-Horn, Π ∪ ¬c is q-Horn and its satiability checking is tractable [21].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 25,
      "context" : "1 [29].",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 18,
      "context" : "in the case Var(c) ∩ V = ∅, Forget(Π, V ) |= c iff Π |= c iff Π ∪ ¬c is unsatisfiable, which is tractable even if Π is a q-Horn theory [21].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 20,
      "context" : "Thus it generalizes Theorem 51 of [24] for Horn theories.",
      "startOffset" : 34,
      "endOffset" : 38
    }, {
      "referenceID" : 19,
      "context" : "It implies that Forget(Σ, V ) can be computed in polynomial time in the size of Σ and V since Σ |= l1 ∨ l2 is tractable [23] and there are at most O(|Var(Σ) \\ V |) number of such clauses.",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 26,
      "context" : "In the section we consider the applications of forgetting, including uniform interpolation [30], strongest necessary and weakest sufficient conditions [17], and strongest and weakest definitions [18].",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 14,
      "context" : "In the section we consider the applications of forgetting, including uniform interpolation [30], strongest necessary and weakest sufficient conditions [17], and strongest and weakest definitions [18].",
      "startOffset" : 151,
      "endOffset" : 155
    }, {
      "referenceID" : 15,
      "context" : "In the section we consider the applications of forgetting, including uniform interpolation [30], strongest necessary and weakest sufficient conditions [17], and strongest and weakest definitions [18].",
      "startOffset" : 195,
      "endOffset" : 199
    }, {
      "referenceID" : 26,
      "context" : "A well-known result is that propositional logic has uniform interpolation property, while first-order logic does not [30].",
      "startOffset" : 117,
      "endOffset" : 121
    }, {
      "referenceID" : 14,
      "context" : "It is a weakest sufficient condition (WSC) if it is a sufficient condition and, for any other sufficient condition ψ, T |= ψ ⊃ ψ [17].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 14,
      "context" : "Theorem 15 (Theorem 2 of [17]) Let T be a theory, V ⊆ Var(T ), q ∈ Var(T ) \\ V , and V ′ = Var(T ) \\ (V ∪ {q}).",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 15,
      "context" : "Informally speaking, an atom p can be “defined” in a given formula Σ in terms of a set X of atoms whenever the knowledge of the truth values of X enables concluding about the truth value of p, under the condition of Σ [18].",
      "startOffset" : 218,
      "endOffset" : 222
    }, {
      "referenceID" : 15,
      "context" : "Definition 3 ([18]) Let Σ be a formula, p ∈ A, X ⊆ A and Y ⊆ A.",
      "startOffset" : 14,
      "endOffset" : 18
    }, {
      "referenceID" : 1,
      "context" : "In terms of Corollary 9 of [3] and Theorem 10 of [18], if Σ defines p in terms of X then Def Σ (p) (resp.",
      "startOffset" : 27,
      "endOffset" : 30
    }, {
      "referenceID" : 15,
      "context" : "In terms of Corollary 9 of [3] and Theorem 10 of [18], if Σ defines p in terms of X then Def Σ (p) (resp.",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 27,
      "context" : "Quite late, the notion of relevance was quantitatively investigated [31], and the notion of independence was applied to belief change [32], which is a long-standing and vive topic in AI [33].",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 28,
      "context" : "Quite late, the notion of relevance was quantitatively investigated [31], and the notion of independence was applied to belief change [32], which is a long-standing and vive topic in AI [33].",
      "startOffset" : 134,
      "endOffset" : 138
    }, {
      "referenceID" : 29,
      "context" : "Quite late, the notion of relevance was quantitatively investigated [31], and the notion of independence was applied to belief change [32], which is a long-standing and vive topic in AI [33].",
      "startOffset" : 186,
      "endOffset" : 190
    }, {
      "referenceID" : 30,
      "context" : "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].",
      "startOffset" : 74,
      "endOffset" : 94
    }, {
      "referenceID" : 31,
      "context" : "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].",
      "startOffset" : 74,
      "endOffset" : 94
    }, {
      "referenceID" : 32,
      "context" : "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].",
      "startOffset" : 74,
      "endOffset" : 94
    }, {
      "referenceID" : 33,
      "context" : "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].",
      "startOffset" : 74,
      "endOffset" : 94
    }, {
      "referenceID" : 34,
      "context" : "Krom and other fragments of propositional logic are also ubiquitous in AI [34, 35, 36, 37, 38].",
      "startOffset" : 74,
      "endOffset" : 94
    }, {
      "referenceID" : 0,
      "context" : ", VAR-EQUIVALENCE and VAR-INDEPENDENCE for propositional logic are proved in [2], this is the first comprehensive study on these problems for CNF, Horn, ren-Horn, q-Horn, Krom and DNF fragments, to our knowledge.",
      "startOffset" : 77,
      "endOffset" : 80
    }, {
      "referenceID" : 13,
      "context" : "It deserves our further effort to investigate the knowledge simplification or compilation [16] in other logical formalisms, logic programming under stable model semantics, particularly.",
      "startOffset" : 90,
      "endOffset" : 94
    } ],
    "year" : 2015,
    "abstractText" : "Distilling from a knowledge base only the part that is relevant to a subset of alphabet, which is recognized as forgetting, has attracted extensive interests in AI community. In standard propositional logic, a general algorithm of forgetting and its computation-oriented investigation in various fragments whose satisfiability are tractable are still lacking. The paper aims at filling the gap. After exploring some basic properties of forgetting in propositional logic, we present a resolution-based algorithm of forgetting for CNF fragment, and some complexity results about forgetting in Horn, renamable Horn, q-Horn, Krom, DNF and CNF fragments of propositional logic.",
    "creator" : "LaTeX with hyperref package"
  }
}