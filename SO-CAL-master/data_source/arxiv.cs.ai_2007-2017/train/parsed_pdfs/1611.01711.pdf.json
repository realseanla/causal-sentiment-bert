{
  "name" : "1611.01711.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Causes for Query Answers from Databases: Datalog Abduction, View-Updates, and Integrity Constraints",
    "authors" : [ "Leopoldo Bertossi", "Babak Salimi" ],
    "emails" : [ "bertossi@scs.carleton.ca.", "imi@cs.washington.edu." ],
    "sections" : [ {
      "heading" : null,
      "text" : "Causality has been recently introduced in databases, to model, characterize, and possibly compute causes for query answers. Connections between QAcausality and consistency-based diagnosis and database repairs (wrt. integrity constraint violations) have already been established. In this work we establish precise connections between QA-causality and both abductive diagnosis and the view-update problem in databases, allowing us to obtain new algorithmic and complexity results for QA-causality. We also obtain new results on the complexity of view-conditioned causality, and investigate the notion of QA-causality in the presence of integrity constraints, obtaining complexity results from a connection with view-conditioned causality. The abduction connection under integrity constraints allows us to obtain algorithmic tools for QA-causality.\nKeywords: Causality in databases, abductive diagnosis, view updates, delete propagation, integrity constraints"
    }, {
      "heading" : "1. Introduction",
      "text" : "Causality is an important concept that appears at the foundations of many scientific disciplines, in the practice of technology, and also in our everyday life. Causality is fundamental to understand and manage uncertainty in data, information, knowledge, and theories. In data management in particular, there is a need to represent, characterize and compute causes that explain why certain query results are obtained or not, or why natural semantic conditions, such as integrity constraints, are not satisfied, or not. Causality can also be used to explain the contents of a view, i.e. of a predicate with virtual contents that is defined in terms of other physical, materialized relations (tables).\nMost of the work on causality has been developed in the context of artificial intelligence [46] and Statistics [47], and little has been said about causality in\n1 Contact author. Carleton University, School of Computer Science, Ottawa, Canada. Email: bertossi@scs.carleton.ca.\n2 University of Washington, Computer Science & Engineering, Seattle, USA. Email: bsalimi@cs.washington.edu.\nPreprint submitted to Journal of LATEX Templates October 3, 2017\nar X\niv :1\n61 1.\n01 71\n1v 1\n[ cs\n.D B\n] 6\nN ov\ndata management. In this work we concentrate on causality as defined for- and applied to relational databases. In a world of big, uncertain data, the necessity to understand the data beyond direct query answers, introducing explanations in different forms, becomes particularly relevant.\nThe notion of causality-based explanation for a query result was introduced in [43], on the basis of the deeper concept of actual causation.3 We will refer to this notion as query-answer causality (or simply, QA-causality). Intuitively, a database atom (or tuple) τ is an actual cause for an answer ā to a conjunctive query Q from a relational instance D if there is a “contingent” subset of tuples Γ, accompanying τ , such that, after removing Γ from D, removing τ from DrΓ causes ā to switch from being an answer to being a non-answer (i.e. not being an answer). Usually, actual causes and contingent tuples are restricted to be among a pre-specified set of endogenous tuples, which are admissible, possible candidates for causes, as opposed to exogenous tuples.\nA cause τ may have different associated contingency sets Γ. Intuitively, the smaller they are the strongest is τ as a cause (it need less company to undermine the query answer). So, some causes may be stronger than others. This idea is formally captured through the notion of causal responsibility, and introduced in [43]. It reflects the relative degree of actual causality. In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities [44, 43].\nFurthermore, view-conditioned causality (in short, vc-causality) was proposed in [44, 45] as a restricted form of QA-causality, to determine causes for unexpected query results, but conditioned to the correctness of prior knowledge that cannot be altered by hypothetical tuple deletions.\nActual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.4 Causal responsibility was introduced in [13], to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.\nIn [55, 7] connections were established between QA-causality and database repairs [4], which allowed to obtain several complexity results for QA-causality related problems. Connections between QA-causality and consistency-based diagnosis [52] were established in [55, 7]. More specifically, QA-causality and causal responsibility were characterized in terms of consistency-based diagnosis, which led to new algorithmic results for QA-causality [55, 7]. In [6] first connections between QA-causality, view updates, and abductive diagnosis in Datalog [17, 22] were announced. We elaborate elaborate on this in the rest of this section.\nThe definition of QA-causality applies to monotone queries [43, 44]. How-\n3 In contrast with general causal claims, such as “smoking causes cancer”, which refer some sort of related events, actual causation specifies a particular instantiation of a causal relationship, e.g., “Joe’s smoking is a cause for his cancer”.\n4 As discussed in [55], some objections to the Halpern-Pearl model of causality and the corresponding changes [32, 33] do not affect results in the context of databases.\never, all complexity and algorithmic results in [43, 55] have been restricted to first-order (FO) monotone queries, mainly conjunctive queries. However, Datalog queries [11, 1], which are also monotone, but may contain recursion, require investigation in the context of QA-causality.\nIn contrast to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly done with different sorts of logic programming-based specifications [21, 23, 29]. In particular, Datalog can be used as the specification language, giving rise to Datalog-abduction [29]. In this work we establish a relationship between Datalog-abduction and QAcausality, which allows us to obtain complexity results for QA-causality for Datalog queries.\nWe also explore fruitful connections between QA-causality and the classical and important view-update problem in databases [1], which is about updating a database through views. An important aspect of the problem is that one wants the base relations (sometimes called “the source database”) to change in a minimal way while still producing the intended view updates. This is an update propagation problem, from views to base relations.\nThe delete-propagation problem [10, 38, 39] is a particular case of the viewupdate problem, where only tuple deletions are allowed from the views. If the views are defined by monotone queries, only source deletions can give an account of view deletions. When only a subset-minimal set of deletions from the base relations is expected to be performed, we are in the “minimal source-side-effect” case. The “minimum source-side-effect” case appears when that set is required to have a minimum cardinality. In a different case, we may want to minimize the side-effects on the view, requiring that other tuples in the (virtual) view contents are not affected (deleted) [10].\nIn this work we provide precise connections between QA-causality and different variants of the delete-propagation problem. In particular, we show that the minimal-source-side-effect deletion-problem and the minimum-source-sideeffect deletion-problem are related to QA-causality for monotone queries and the most-responsible cause problem, as investigated in [43, 55? ]. The minimumview-side-effect deletion-problem is related to vc-causality. We establish precise mutual characterizations (reductions) between these problems, obtaining in particular, new complexity results for view-conditioned causality.\nFinally, we also define and investigate the notion of query-answer causality in the presence of integrity constraints, which are logical dependencies between database tuples [1]. Under the assumption that the instance at hand satisfies a given set of ICs, the latter should have an effect on the causes for a query answer, and their computation. We show that they do, proposing a notion of QA-cause under ICs. But taking advantage of the connection with Datalog-abduction (this time under ICs on the extensional relations), we develop techniques to compute causes for query answers from Datalog queries in the presence of ICs.\nSummarizing, our main results are the following:\n1. We establish precise connections between QA-causality for Datalog queries and abductive diagnosis from Datalog specifications, i.e. mutual charac-\nterizations and computational reductions between them.\n2. We establich that, in contrast to (unions of) conjunctive queries, deciding tuple causality for Datalog queries is NP-complete in data.\n3. We identify a class of (possibly recursive) Datalog queries for which deciding causality is fixed-parameter tractable in combined complexity.\n4. We establish that deciding whether the causal responsibility of a tuple for a Datalog query-answer is greater than a given threshold is NP-complete in data.\n5. We establish mutual characterizations between QA-causality and different forms of delete-propagation as a view-update problem.\n6. We obtain that computing the size of the solution to a minimum-sourceside-effect deletion-problem is hard for the complexity class FPNP(log(n)), that of computational problems solvable in polynomial time (in data) by calling a logarithmic number of times an NP-oracle.\n7. We investigate in detail the problem of view-conditioned QA-causality (vc-causality), and we establish connections with the view-side-effect free delete propagation problem for view updates.\n8. We obtain that deciding if an answer has a vc-cause is NP-complete in data; that deciding tuple vc-causality is NP-complete in data; and deciding if the vc-causal responsibility of a tuple for a Datalog query-answer is greater than a given threshold is also NP-complete in data.\n9. We define the notion of QA-causality in the presence of integrity constraints (ICs), and investigate its properties. In particular, we make the case that the new property provides natural results.\n10. We obtain complexity results for QA-causality under ICs. In particular, we show that even for conjunctive queries, deciding tuple causality may become NP-hard under inclusion dependencies.\n11. We establish connections between QA-causality for Datalog queries under ICs and the view update problem and abduction from Datalog specifications, both under ICs. Through these connections we provide algorithmic results for computing causes for Datalog query answers under ICs.\nThis paper is structured as follows. Section 2 provides background material on relational databases and Datalog queries. Section 3 introduces the necessary concepts, known results, and the main computational problems for QAcausality. Section 4 introduces the abduction problem in Datlog specifications, and establishes its connections with QA-causality. Section 5 introduces the main problems related to updates trough views defined by monotone queries, and their connections with QA-causality problems. Section 6 defines and investigates view-conditioned QA-causality. Section 7 defines and investigates\nQA-causality under integrity constraints. Finally, Section 8 discusses some relevant related problems and draws final conclusions. The Appendix contains a couple of proofs that are not in the main body of the paper. This paper is an extension of both [56] and [57]."
    }, {
      "heading" : "2. Preliminaries",
      "text" : "We consider relational database schemas of the form S = (U,P), where U is the possibly infinite database domain and P is a finite set of database predicates of fixed arities.5 A database instance D compatible with S can be seen as a finite set of ground atomic formulas (a.k.a. atoms or tuples), of the form P (c1, ..., cn), where P ∈ P has arity n, and c1, . . . , cn ∈ U .\nA conjunctive query (CQ) is a formula of the first-order (FO) language L(S) associated to S, of the form Q(x̄) : ∃ȳ(P1(s̄1)∧ · · · ∧Pm(s̄m)), where the Pi(s̄i) are atomic formulas, i.e. Pi ∈ P, and the s̄i are sequences of terms, i.e. variables or constants of U . The x̄ in Q(x̄) shows all the free variables in the formula, i.e. those not appearing in ȳ. A sequence c̄ of constants is an answer to query Q(x̄) if D |= Q[c̄], i.e. the query becomes true in D when the free variables are replaced by the corresponding constants in c̄. We denote the set of all answers from instance D to a conjunctive query Q(x̄) with Q(D).\nA conjunctive query is Boolean (a BCQ), if x̄ is empty, i.e. the query is a sentence, in which case, it is true or false in D, denoted by D |= Q and D 6|= Q, respectively. Accordingly, when Q is a BCQ, Q(D) = {yes} if Q is true, and Q(D) = ∅, otherwise.\nA queryQ is monotone if for every two instances D1 ⊆ D2, Q(D1) ⊆ Q(D2), i.e. the set of answers grows monotonically with the instance. For example, CQs and unions of CQs (UCQs) are monotone queries. In this work we consider only monotone queries.\nAn integrity constraint (IC) is a sentence ϕ in the language L(S). For a given instance D for schema S, it may be true or false in D, which is denoted with D |= ϕ, resp. D 6|= ϕ. Given a set Σ of integrity constraints, a database instance D is consistent if D |= Σ; otherwise it is said to be inconsistent. In this work we assume that sets of integrity constraints are always finite and logically consistent (i.e. they are all simultaneously true in some instance).\nA particular class of ICs is formed by inclusion dependencies (INDs), which are sentences of the form ∀x̄(P (x̄) → ∃ȳR(x̄′, ȳ)), with P,R predicates, x̄′ ∩ ȳ = ∅, and x̄′ ⊆ x̄. The tuple-generating dependencies (tgds) are ICs that generalize INDs, and are of the form ∀x̄( ∧ i Pi(x̄i) → ∃ȳ ∧ j Pj(x̄ ′ j , ȳj)), with Pi, Pj predicates, x̄ ′ j ⊆ ⋃ x̄i = x̄, and ȳj ∩ x̄ = ∅.\nAnother special class of ICs is formed by functional dependencies (FDs). For example, ψ : ∀x∀y∀z(P (x, y) ∧ P (x, z) → y = z) specifies that the second attribute of P functionally depends upon the first. (If A,B are the first and second attributes for P , the usual notation for this FD is P : A→ B.) Actually,\n5 As opposed to built-in predicates, e.g. 6=, that we leave implicit, unless otherwise stated.\nthis FD is also a key constraint (KC), in the sense that the attribute(s) on the LHS of the arrow functionally determines all the other attributes of the predicate (cf. [1] for more details on ICs).\nGiven a relational schema S, queries Q1(x̄),Q2(x̄), and a set Σ of ICs (all for schema schema S), Q1 and Q2 are equivalent wrt. Σ, denoted Q1 ≡Σ Q2, iff Q1(D) = Q2(D) for every instance D for S that satisfies Σ. One can define in similar terms the notion of query containment under ICs, denoted Q1 ⊆Σ Q2.\nA Datalog query Q(x̄) is a whole program Π consisting of positive Horn rules (a.k.a. positive definite rules), of the form P (t̄)← P1(t̄1), . . . , Pn(t̄n), with the Pi(t̄i) atomic formulas. All the variables in t̄ appear in some of the t̄i. Here, n ≥ 0, and if n = 0, P (t̄) is called a fact and does not contain variables. We assume the facts are those stored in an underlying extensional database D.\nWe may assume that a Datalog program Π as a query defines an answercollecting predicate Ans(x̄) by means of a top rule of the form Ans(t̄) ← P1(t̄1), . . . , Pm(t̄m), where all the predicates in the RHS (a.k.a. as the rule body) are defined by other rules in Π or are database predicates for D. Here, the t̄, t̄i are lists of variables or constants, and the variables in t̄ belong to ⋃ i t̄i.\nNow, ā is an answer to query Π onD when Π∪D |= Ans(ā). Here, entailment (|=) means that the RHS belongs to the minimal model of the LHS. So, the extension, Ans(Π ∪D), of predicate Ans contains the answers to the query in the minimal model of the program (including the database). The Datalog query is Boolean if the top answer-predicate is propositional, with a definition of the form ans ← P1(s̄1), . . . , Pm(s̄m). In this case, the query is true if Π∪D |= ans, equivalently, if ans belongs to the minimal model of Π ∪D [1, 11].\nDatalog queries may contain recursion, and then they may not be FO [1, 11]. However they are also monotone."
    }, {
      "heading" : "3. QA-Causality and its Decision Problems",
      "text" : "In this section we review the notion of QA-causality as introduced in [43]. We also summarize the main decision and computational problems that emerge in this context and the established results for them."
    }, {
      "heading" : "3.1. Causality and responsibility",
      "text" : "In the rest of this work, unless otherwise stated, we assume that a relational database instance D is split in two disjoint sets, D = Dn ∪Dx, where Dn and Dx are the sets of endogenous and exogenous tuples, respectively.\nA tuple τ ∈ Dn is a counterfactual cause for an answer ā to Q(x̄) in D if D |= Q(ā), but D r {τ} 6|= Q(ā). A tuple τ ∈ Dn is an actual cause for ā if there exists Γ ⊆ Dn, called a contingency set, such that τ is a counterfactual cause for ā in D r Γ. Causes(D,Q(ā)) denotes the set of actual causes for ā. If Q is Boolean, Causes(D,Q) contains the causes for answer yes. For τ ∈ Causes(D,Q(ā)), Cont(D,Q(ā), τ) denotes the set of contingency sets for τ as a cause for Q(ā) in D.\nNotice that Causes(D,Q(ā)) is non-empty when D |= Q(ā), but Dx 6|= Q(ā), reflecting the fact that endogenous tuples are required for the answer.\nGiven a τ ∈ Causes(D,Q(ā)), we collect all subset-minimal contingency sets associated with τ :\nConts(D,Q(ā), τ) := {Γ ⊆ Dn | D r Γ |= Q(ā), D r (Γ ∪ {τ}) 6|= Q(ā), and ∀Γ′ $ Γ, D r (Γ′ ∪ {τ}) |= Q(ā)}.\nThe causal responsibility of a tuple τ for answer ā, denoted with ρD Q(ā) (τ), is 1 (|Γ|+1) , where |Γ| is the size of the smallest contingency set for τ . When τ is not an actual cause for ā, no contingency set is associated to τ . In this case, ρD Q(ā) (τ) is defined as 0.\nExample 1. Consider an instance D with relations Author(AName, JName) and Journal(JName, Topic, Paper#), and contents as below:\nAuthor AName JName\nJoe TKDE John TKDE Tom TKDE John TODS\nJournal JName Topic Paper#\nTKDE XML 30 TKDE CUBE 31 TODS XML 32\nThe following conjunctive query:\nQ(AName,Topic) : ∃JName ∃Paper#(Author(AName, JName) ∧ (1) Journal(JName,Topic,Paper#))\nhas the following answers:\nQ(D) AName Topic Joe XML Joe CUBE Tom XML Tom CUBE John XML John CUBE\nAssume 〈John,XML〉 is an unexpected answer to Q. That is, it is not likely that John has a paper on XML. Now, we want to compute causes for this unexpected observation. For the moment assume all tuples in D are endogenous.\nIt holds that Author(John, TODS) is an actual cause for answer 〈John,XML〉. Actually, it has two contingency sets, namely: Γ1 = {Author(John,TKDE)} and Γ2={Journal(TKDE,XML, 32)}. That is, Author(John,TODS) is a counterfactual cause for 〈John,XML〉 in both DrΓ1 and DrΓ2. Moreover, the responsibility of Author(John,TODS) is 12 , because its minimum-cardinality contingency sets have size 1.\nTuples Journal(TKDE,XML, 32), Author(John,TKDE) and Journal(TODS, XML, 32) are also actual causes for 〈John,XML〉, with responsibility 12 .\nFor more subtle situation, assume only Author tuples are endogenous, possibly reflecting the fact that the data in Journal table are more reliable than those in the Author table. Under this assumption, the only actual causes for answer 〈John,XML〉 are Author(John,TKDE) and Author(John,TODS).\nThe definition of QA-causality can be applied without any conceptual changes to Datalog queries. Actually, CQs can be expressed as Datalog queries. For example, (1) can be expressed in Datalog as:\nAnsQ(AName,Topic)← Author(AName, JName), Journal(JName,Topic,Paper#), with the auxiliary predicate AnsQ collecting the answers to query Q. In the case of Datalog, we sometimes use the notation Causes(D,Π(ā)) for the set of causes for answer ā (and simply Causes(D,Π) when Π is Boolean).\nExample 2. Consider the instance D with a single binary relation E as below (t1-t7 are tuple identifiers). Assume all tuples are endogenous.\nE A B t1 a b t2 b e t3 e d t4 d b t5 c a t6 c b t7 c d\nInstance D can be represented as the directed graph G(V, E) in Figure 1, where the set of vertices V coincides with the active domain of D (i.e. the set of constants in E). The set of edges E contains (v1, v2) iff E(v1, v2) ∈ D. The tuple identifiers are used as labels for the corresponding edges, and also to refer to the database tuples.\nConsider the recursive Datalog query Π:\nAns(x, y) ← P (x, y) P (x, y) ← E(x, y) P (x, y) ← P (x, z), E(z, y),\nwhich collects pairs of vertices of G that are connected through a path. Since Π∪D |= Ans(c, e), we have 〈c, e〉 as an answer to query Π on D. This is because there are three distinct paths between c and e in G. All tuples except for t3 are actual causes for this answer: Causes(E,Π(c, e)) = {t1, t2, t4, t5, t6, t7}. We can see that all of these tuples contribute to at least one path between c and\ne. Among them, t2 has the highest responsibility, because, t2 is a counterfactual cause for the answer, i.e. it has an empty contingency set.\nThe complexity of the computational and decision problems that arise in QA-causality have been investigated in [43, 55]. Here we recall those results that we will use throughout this work. The first problem is about deciding whether a tuple is an actual cause for a query answer.\nDefinition 1. For a Boolean monotone query Q, the causality decision problem (CDP) is (deciding about membership of): CDP(Q) := {(D, τ) | τ ∈ Dn, and τ ∈ Causes(D,Q)}.\nThis problem is tractable for UCQs [55]. The next problem is about deciding if the responsibility of a tuple as a cause for a query answer is above a given threshold.\nDefinition 2. For a Boolean monotone query Q, the responsibility decision problem (RDP) is (deciding about membership of): RDP(Q) = {(D, τ, v) | τ ∈ Dn, v ∈ {0} ∪\n{ 1k | k ∈ N +}, D |= Q and ρD Q (τ) > v}.\nThis problem is NP-complete for CQs [43] and UCQs [55], but tractable for linear CQs [43]. Roughly speaking, a CQ is linear if its atoms can be ordered in a way that every variable appears in a continuous sequence of atoms that does not contain a self-join (i.e. a join involving the same predicate), e.g. ∃xvyu(A(x) ∧ S1(x, v) ∧ S2(v, y) ∧ R(y, u) ∧ S3(y, z)) is linear, but not ∃xyz(A(x) ∧B(y) ∧ C(z) ∧W (x, y, z)), for which RDP is NP-complete [43].\nThe functional, non-decision, version of RDP is about computing responsibilities. This optimization problem is complete (in data) for FPNP(log(n)) for UCQs [55]. Finally, we have the problem of deciding whether a tuple is a most responsible cause:\nDefinition 3. For a Boolean monotone query Q, the most responsible cause decision problem is: MRCD(Q) = {(D, τ) | τ ∈ Dn and 0 < ρDQ(τ) is a maximum for D}.\nFor UCQs this problem is complete for PNP(log(n)) [55]. Hardness already holds for a CQ.\nA notion of view-conditioned causality [44] will be formalized and investigated in Section 6."
    }, {
      "heading" : "4. Causality and Abduction",
      "text" : "In general logical terms, an abductive explanation for an observation is a formula that, together with a background logical theory, entails the observation. Although one could see an abductive explanation as a cause for the observation, it has been argued that causes and abductive explanations are not necessarily the same [50, 21].\nUnder the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules. By restricting the explanation formulas to the predicates describing primitive causes (action executions), an explanation formula which entails an observation gives also a cause for the observation [21]. In this case, and is some sense, causality information is imposed by the system specifier [48].\nIn database causality we do not have, at least not initially, a system description,6 but just a set of tuples. It is when we pose a query that we create something like a description, and the causal relationships between tuples are captured by the combination of atoms in the query. If the query is a Datalog query (in particular, a CQ), we have a specification in terms of positive definite rules.\nIn this section we will first establish connections between abductive diagnosis and database causality.7 We start by making precise the kind of abduction problems we will consider."
    }, {
      "heading" : "4.1. Background on Datalog abductive diagnosis",
      "text" : "A Datalog abduction problem [23] is of the form AP = 〈Π, E,Hyp,Obs〉, where: (a) Π is a set of Datalog rules, (b) E is a set of ground atoms (the extensional database), (c) Hyp, the hypothesis, is a finite set of ground atoms, the abducible atoms in this case,8 and (d) Obs, the observation, is a finite conjunction of ground atoms. As it is common, we will start with the assumption that Π∪E∪Hyp |= Obs. Π∪E is called the background theory (or specification).\nDefinition 4. Consider a Datalog abduction problem AP = 〈Π, E,Hyp,Obs〉. (a) An abductive diagnosis (or simply, a solution) for AP is a subset-minimal\n∆ ⊆ Hyp, such that Π ∪ E ∪∆ |= Obs. This requires that no proper subset of ∆ has this property.9 Sol(AP) denotes the set of abductive diagnoses for problem AP.\n(b) A hypothesis h ∈ Hyp is relevant for AP if h contained in at least one diagnosis of AP, otherwise it is irrelevant. Rel(AP) collects all relevant hypothesis for AP.\n(c) A hypothesis h ∈ Hyp is necessary for AP if h contained in all diagnosis of AP. Ness(AP) collects all the necessary hypothesis for AP.\n6 Having integrity constraints would go in that direction, but this is something that has not been considered in database causality so far. See [55, sec. 5] for a consistency-based diagnosis connection, where the DB is turned into a theory.\n7 In [55] we established such a connection between another form of model-based diagnosis [59], namely consistency-based diagnosis [52]. For relationships and comparisons between consistency-based and abductive diagnosis see [17].\n8 It is common to accept as hypothesis all the possible ground instantiations of abducible predicates. We assume abducible predicates do not appear in rule heads.\n9 Of course, other minimality criteria could take this place.\nNotice that for a problem AP, Sol(AP) is never empty due to the assumption Π ∪D ∪Hyp |= Obs. In case, Π ∪D |= Obs, it holds Sol(AP) = {∅}.\nExample 3. Consider the digital circuit in Figure 2. The inputs are a = 1, b = 0, c = 1, but the output is d = 0. So, the circuit is not working properly. The diagnosis problem is formulated below as a Datalog abduction problem whose data domain is {a, b, c, d, e, and, or}. The underlying, extensional database is as follows: E = {One(a),Zero(b), One(c),And(a, b, e, and),Or(e, c, d, or}.\nThe Datalog program Π contains rules that model the normal and the faulty behavior of each gate. We show only the Datalog rules for the And gate. For its normal behavior, we have the following rules:\nOne(O) ← And(I1, I2, O,G),One(I1),One(I2) Zero(O) ← And(I1, I2, O,G),One(I1),Zero(I2) Zero(O) ← And(I1, I2, O,G),Zero(I1),One(I2) Zero(O) ← And(I1, I2, O,G),Zero(I1),One(I2).\nThe faulty behavior is modeled by the following rules:\nZero(O) ← And(I1, I2, O,G),One(I1),One(I2),Faulty(G) One(O) ← And(I1, I2, O,G),One(I1),Zero(I2),Faulty(G) One(O) ← And(I1, I2, O,G),Zero(I1),One(I2),Faulty(G) One(O) ← And(I1, I2, O,G),Zero(I1),One(I2),Faulty(G)\nFinally, we consider Obs : Zero(d), and Hyp = {Faulty(and),Faulty(or)}. The abduction problem consists in finding minimal ∆ ⊆ Hyp, such that Π∪E∪∆ |= Zero(d). There is one abductive diagnosis: ∆ = {Faulty(or)}.\nIn the context of Datalog abduction, we are interested in deciding, for a fixed Datalog program, if a hypothesis is relevant/necessary or not, with all the data as input. More precisely, we consider the following decision problems.\nDefinition 5. Given a Datalog program Π, (a) The necessity decision problem (NDP) for Π is (deciding about the membership of):\nNDP(Π) = {(E ,Hyp,Obs, h) | h ∈ Ness(AP),with AP = 〈Π, E,Hyp,Obs〉}. (b) The relevance decision problem (RLDP) for Π is (deciding about the membership of):\nRLDP(Π) = {(E ,Hyp,Obs, h) | h ∈ Rel(AP),with AP = 〈Π, E,Hyp,Obs〉}.\nAs it is common, we will assume that |Obs|, i.e. the number of atoms in the conjunction, is bounded above by a fixed parameter p. In many cases, p = 1 (a single atomic observation).\nThe last two definitions suggest that we are interested in the data complexity of the relevance and necessity decision problems for Datalog abduction. That is, the Datalog program is fixed, but the data consisting of hypotheses and input structure E may change. In contrast, under combined complexity the program is also part of the input, and the complexity is measured also in terms of the program size.\nA comprehensive complexity analysis of several reasoning tasks on abduction from propositional logic programs, in particular of the relevance and necessity problems, can be found in [23]. Those results are all in combined complexity. In [23], it has been shown that for abduction from function-free first-order logic programs, the data complexity of each type of reasoning problem in the firstorder case coincides with the complexity of the same type of reasoning problem in the propositional case. In this way, the next two results can be obtained for NDP and RLDP from [23, the. 26] and the complexity of these problems for propositional Horn abduction (PDA), established in [24]. In the Appendix we provide direct, ad hoc proofs by adapting the full machinery developed in [23] for general programs.\nProposition 1. For every Datalog program, Π, NDP(Π) is in PTIME (in data).\nProposition 2. For Datalog programs Π,RLDP(Π) is NP-complete (in data).10\nIt is clear from this result that deciding relevance for Datalog abduction is also intractable in combined complexity. However, a tractable case of combined complexity is identified in [29], on the basis of the notions of tree-decomposition and bounded tree-width, which we now briefly present.\nLet H = 〈V,H〉 be a hypergraph, where V is the set of vertices, and H is the set of hyperedges, i.e. of subsets of V . A tree-decomposition of H is a pair (T , λ), where T = 〈N,E〉 is a tree and λ is a labeling function that assigns to each node n ∈ N , a subset λ(n) of V (λ(n) is aka. bag), i.e. λ(n) ⊆ V , such\n10 More precisely, this statement (and others of this kind) means: (a) For every Datalog program Π, RLDP(Π) ∈ NP ; and (b) there are programs Π′ for which RLDP(Π′) is NP-hard (all this in data).\nthat, for every node n ∈ N , the following hold: (a) For every v ∈ V , there exists n ∈ N with v ∈ λ(n). (b) For every h ∈ H, there exists a node n ∈ N with h ⊆ λ(n). (c) For every v ∈ V , the set of nodes {n | v ∈ λ(n)} induces a connected subtree of T .\nThe width of a tree decomposition (T , λ) of H = 〈V,H〉, with T = 〈N,E〉, is defined as max{|λ(n)| − 1 : n ∈ N}. The tree-width tw(H) of H is the minimum width over all its tree decompositions.\nIntuitively, the tree-width of a hypergraph H is a measure of the “treelikeness” of H. A set of vertices that form a cycle in H are put into a same bag, which becomes (the bag of a) node in the corresponding tree-decomposition. If the tree-width of the hypergraph under consideration is bounded by a fixed constant, then many otherwise intractable problems become tractable [28].\nIt is possible to associate an hypergraph to any finite structure D (think of a relational database): If its universe (the active domain in the case of a relational database) is V , define the hypergraph H(D) = (V,H), with H = { {a1, . . . , an} | D contains a ground atom P (a1 . . . an) for some predicate symbol P}.\nExample 4. Consider instance D in Example 1. The hypergraph H(D) associated to D is shown in Figure 3(a). Its vertices are the elements of Adom(D) = {John, Joe,Tom,TODS,TKDE,XML,CUBE, 30, 31, 32}, the active domain of D. For example, since Journal(TKDE,XML, 30) ∈ D, {TKDE,XML, 30} is one of the hyperedges.\nThe dashed ovals show four sets of vertices, i.e. hyperedges, that together form a cycle. Their elements are put into the same bag of the tree-decomposition. Figure 3(b) shows a possible tree-decomposition of H(D). In it, the maximum |λ(n)|−1 is 6−1, corresponding to the top box bag of the tree. So, tw(H(D)) ≤ 5.\nThe following is a fixed-parameter tractability result for the relevance decision problem for Datalog abduction for guarded programs Π, where in every rule body there is an atom that contains (guards) all the variables appearing in that body.\nTheorem 1. [29, theo. 7.9] Let k be an integer. For Datalog abduction problems AP = 〈Π, E,Hyp,Obs〉 where Π is guarded, and tw(H(E)) ≤ k, relevance can be decided in polynomial time in |AP|. More precisely, the following decision problem is tractable: RLDP = {(〈Π,E ,Hyp,Obs〉, h) | h ∈ Rel(〈Π,E ,Hyp,Obs〉), h ∈ Hyp,\nΠ is guarded, and tw(H(E)) ≤ k}.\nThis is a case of tractable combined complexity with a fixed parameter that is the tree-width of the extensional database.\nIn the rest of this section we assume, unless otherwise stated, that we have a partitioned relational instance D = Dx ∪Dn."
    }, {
      "heading" : "4.2. Actual causes from abductive diagnoses",
      "text" : "In this section we show that, for Datalog system specifications, abductive inference corresponds to actual causation. That is, abductive diagnoses for an observation essentially contain actual causes for the observation.\nConsider that Π is a Boolean, possibly recursive Datalog query; and assume that Π ∪D |= ans. Then, the decision problem in Definition 1 takes the form:\nCDP(Π) := {(D, τ) | τ ∈ Dn, and τ ∈ Causes(D,Π)}. (2)\nWe now show that actual causes for ans can be obtained from abductive diagnoses of the associated causal Datalog abduction problem (CDAP): APc := 〈Π, Dx, Dn, ans〉, where Dx takes the role of the extensional database for Π. Accordingly, Π ∪ Dx becomes the background theory, Dn becomes the set of hypothesis, and atom ans is the observation.\nProposition 3. For an instance D = Dx ∪ Dn and a Boolean Datalog query Π, with Π ∪D |= ans, and its associated CDAP APc, the following hold:\n(a) τ ∈ Dn is an counterfactual cause for ans iff τ ∈ Ness(APc).\n(b) τ ∈ Dn is an actual cause for ans iff τ ∈ Rel(APc).\nProof: Part (a) is straightforward. To proof part (b), first assume τ is an actual cause for ans. According to the definition of an actual cause, there exists a contingency set Γ ⊆ Dn such that Π∪DrΓ |= ans but Π∪Dr(Γ∪{τ}) 6|= ans. This implies that there exists a set ∆ ⊆ Dn with τ ∈ ∆ such that Π ∪ ∆ |= ans. It is easy to see that ∆ is an abductive diagnosis for APc. Therefore, τ ∈ Rel(APc).\nSecond, assume τ ∈ Rel(APc). Then there exists a set Sk ∈ Sol(APc) = {s1 . . . sn} such that Sk |= ans with τ ∈ Sk. Obviously, Sol(APc) is a collection of subsets of Dn. Pick a set Γ ⊆ Dn such that for all Si ∈ Sol(APc) i 6= k, Γ ∩ Si 6= ∅ and Γ ∩ Sk = ∅. It is clear that Π ∪ D r (Γ ∪ {t}) 6|= ans but Π∪DrΓ |= ans. Therefore, τ is an actual cause for ans. To complete the proof we need to show that such Γ always exists. This can be done by applying the digitalization technique to construct such Γ. Since all elements of Sol(APc) are\nsubset-minimal, then, for each Si ∈ Sol(APc) with i 6= k, there exists a τ ′ ∈ Si such that τ ′ 6∈ Sk. So, Γ can be obtained from the union of differences between each Si (i 6= k) and Sk.\nExample 5. Consider the instance D with relations R and S as below, and the\nquery Π : ans ← R(x, y), S(y), which is true in D. Assume all tuples are endogenous.\nR A B a1 a4 a2 a1 a3 a3\nS B a1 a2 a3\nIn this case, APc = 〈Π, ∅, D, ans〉, which has two (subset-minimal) abductive diagnoses: ∆1 = {S(a1), R(a2, a1)} and ∆2 = {S(a3), R(a3, a3)}. Then, Rel(APc) = {S(a3), R(a3, a3), S(a1), R(a2, a1)}. It is easy to see that the relevant hypothesis are actual causes for ans."
    }, {
      "heading" : "4.3. Causal responsibility and abductive diagnosis",
      "text" : "In the previous section we showed that counterfactual and actual causes for Datalog query answers appear as necessary and relevant hypotheses in the associated Datalog abduction problem. The form causal responsibility takes in Datalog abduction is less direct. Actually, we first show that causal responsibility inspires an interesting concept for Datalog abduction, that of degree of necessity of a hypothesis.\nExample 6. (ex. 5 cont.) Consider nowD′ = {R(a1, a3), R(a2, a3), S(a3)}, and APc = 〈Π, ∅, D′, ans〉. APc has two abductive diagnosis: ∆1 = {S(a3), R(a1, a3)} and ∆2 = {S(a3), R(a2, a3)}.\nHere, Ness(APc) = {S(a3)}, i.e. only S(a3) is necessary for abductively explaining ans. However, this is not capturing the fact that R(a1, a3) or R(a3, a3) are also needed as a part of the explanation.\nThis example suggests that necessary hypotheses might be better captured as sets of them rather than as individuals.\nDefinition 6. Given a DAP, AP = 〈Π, E,Hyp,Obs〉, N ⊆ Hyp is a necessaryhypothesis set if: (a) for AP−N := 〈Π, E,Hyp r N,Obs〉, Sol(AP−N ) = ∅, and (b) N is subset-minimal, i.e. no proper subset of N has the previous property.\nIt is easy to verify that a hypothesis h is necessary according to Definition 4 iff {h} is a necessary-hypothesis set.\nIf we apply Definition 6 to APc in Example 6, we obtain two necessaryhypothesis sets: N1 = {S(a3)} and N2 = {R(a1, a3), R(a2, a3)}. In this case, it makes sense to claim that S(a3) is more necessary for explaining ans than the other two tuples, that need to be combined. Actually, we can think of ranking hypothesis according to the minimum cardinality of necessary-hypothesis sets where they are included.\nDefinition 7. Given a DAP, AP = 〈Π, E,Hyp,Obs〉, the necessity-degree of a hypothesis h ∈ Hyp is ηAP(h) := 1|N | where, N is a minimum-cardinality necessary-hypothesis set with h ∈ N . If h does not belong to any necessary hypothesis set, ηAP(h) := 0.\nExample 7. (ex. 6 cont.) We have ηAPc(S(a3)) = 1 and ηAPc(R(a2, a3)) = ηAPc(R(a1, a3)) = 1 2 . Now, if we consider the original Datalog query in the causality setting, where Π∪D′ |= ans, then S(a3), R(a2, a3), R(a1, a3) are all actual causes, with responsibilities: ρD\nΠ (S(a3)) = 1, ρ D Π (R(a2, a3)) = ρ D Π\n(R(a1, a3)) = 12 . This is not a coincidence. In fact the notion of causal responsibility is in correspondence with the notion of necessity degree in the Datalog abduction setting.\nProposition 4. Let D = Dx ∪Dn be an instance and Π be a Boolean Datalog query with Π ∪D |= ans, and APc its associated CDAP. For τ ∈ Dn, it holds: ηAPc(τ) = ρ D Π (τ).\nProof: It is easy to verify that each actual cause, together with a contingency set, forms a necessary hypothesis set for the corresponding causal Datalog abduction setting (and the other way around). Then, the two values are in correspondence.\nNotice that the notion of necessity-degree is interesting and applicable to general abduction from logical theories, that may not necessarily represent causal knowledge about a domain. In this case, the necessity-degree is not a causality-related notion, and merely reflects the extent by which a hypothesis is necessary for making an observation explainable within an abductive theory."
    }, {
      "heading" : "4.4. Abductive diagnosis from actual causes",
      "text" : "Now we show, conversely, that QA-causality can capture Datalog abduction. In particular, we show that abductive diagnoses from Datalog programs are formed essentially by actual causes for the observation. More precisely, consider a Datalog abduction problem AP = 〈Π, E,Hyp,Obs〉, where E is the underlying extensional database, and Obs is a conjunction of ground atoms. For this we need to construct a QA-causality setting.\nProposition 5. Let AP = 〈Π, E,Hyp,Obs〉 be a Datalog abduction problem, and h ∈ Hyp. It holds that h is a relevant hypothesis for AP, i.e. h ∈ Rel(AP), iff h is an actual cause for the associated Boolean Datalog query Πc := Π ∪ {ans ← Obs} being true in D := Dx ∪ Dn with Dx := E, and Dn := Hyp. Here, ans is a fresh propositional atom.\nThe proof is similar to that of Proposition 3.\nExample 8. (ex. 3 cont.) For the given DAP AP, we construct a QA-causality setting as follows. Consider the instance D with relations And, Or, Faulty , One and Zero, as below, and the Boolean Datalog query Πc : Π ∪ {ans ← Zero(d)}, where Π is the Datalog program in Example 3.\nAnd I1 I2 O G a b e and\nZero I b\nOr I1 I2 O G e c d or\nOne I a c\nFaulty G and or\nIt clear that Πc ∪ D |= ans. D is partitioned into the set of endogenous tuples Dn := {Faulty(and), Faulty(or)} and the set of exogenous tuples Dx := D rDn.\nIt is easy to verify that this result has only one actual cause, namely Faulty(or) (with responsibility 1), confirming the correspondence with Example 3 as stated in Proposition 5."
    }, {
      "heading" : "4.5. Complexity of causality for Datalog queries",
      "text" : "Now we use the results obtained so far in this section to obtain new complexity results for Datalog QA-causality. We first consider the problem of deciding if a tuple is a counterfactual cause for a query answer.\nA counterfactual cause is a tuple that, when removed from the database, undermines the query-answer, without having to remove other tuples, as is the case for actual causes. Actually, for each of the latter there may be an exponential number of contingency sets, i.e. of accompanying tuples [55]. Notice that a counterfactual cause is an actual cause with responsibility 1.\nDefinition 8. For a Boolean monotone query Q, the counterfactual causality decision problem (CFDP) is (deciding about membership of):\nCFDP(Q) := {(D, τ) | τ ∈ Dn and ρD Q (τ) = 1}.\nThe complexity of this problem can be obtained from the connection between counterfactual causation and the necessity of hypothesis in Datalog abduction via Propositions 1 and 3.\nProposition 6. For Boolean Datalog queries Π, CFDP(Π) is in PTIME (in data).\nProof: Directly from Propositions 1 and 3.\nNow we address the complexity of the actual causality problem for Datalog queries. The following result is obtained from Propositions 2 and 5.\nProposition 7. For Boolean Datalog queries Π, CDP(Π) is NP-complete (in data).\nProof: To show the membership of NP, consider an instance D = Dn∪Dx and a tuple τ ∈ Dn. To check if (D, τ) ∈ CDP(Π) (equivalently τ ∈ Causes(D,Π)), non-deterministically guess a subset Γ ⊆ Dn, return yes if τ is a counterfactual cause for Q(ā) in D r Γ, and no otherwise. By Proposition 6 this can be done in polynomial time.\nThe NP-hardness is obtained by a reduction from the relevance problem for Datalog abduction to causality problem, as given in Proposition 5.\nThis result should be contrasted with the tractability of the same problem for UCQs [55]. In the case of Datalog, the NP-hardness requires a recursive query. This can be seen from the proof of Proposition 7, which appeals in the end to the NP-hardness in Proposition 2, whose proof uses a recursive query (program) (cf. the query given by (A.1)-(A.2) in the Appendix).\nWe now introduce a fixed-parameter tractable case of the actual causality problem. Actually, we consider the “combined” version, CDP, of the decision problem in Definition 1, where both the Datalog query and the instance are part of the input. For this, we take advantage of the tractable case of Datalog abduction presented in Section 4.1. The following is an immediate consequence of Theorem 1 and Proposition 3.\nProposition 8. For a guarded Boolean Datalog query Π, an instance D = Dx∪ Dn, with Dx of bounded tree-width, and τ ∈ Dn, deciding if τ ∈ Causes(D,Π) is fixed-parameter tractable (in combined complexity), and the parameter is the tree-width bound.\nFinally, we establish the complexity of the responsibility problem for Datalog queries.\nProposition 9. For Boolean Datalog queries Π, RDP(Π) is NP-complete.\nProof: To show membership of NP, consider an instance D = Dn ∪ Dx, a tuple τ ∈ Dn, and a responsibility bound v. To check if ρD\nΠ (τ) > v, non-\ndeterministically guess a set Γ ⊆ Dn and check if Γ is a contingency set and Γ < 1v . The verification can be done in polynomial time. Hardness is obtain from the NP-completeness of RDP for conjunctive queries established in [55]."
    }, {
      "heading" : "5. Causality and View-Updates",
      "text" : "There is a close relationship between QA-causality and the view-update problem in the form of delete-propagation. It was first suggested in [38, 39], and here we investigate it more deeply. We start by formalizing some computational problems related to the general delete-propagation problem that are interesting from the perspective of QA-causality."
    }, {
      "heading" : "5.1. Background on delete-propagation",
      "text" : "Given a monotone query Q, we can think of it as defining a view, V, with virtual contents Q(D). If ā ∈ Q(D), which may not be intended, we may try to delete some tuples from D, so that ā disappears from Q(D). This is a particular case of database updates through views [1], and may appear in different and natural formulations. The next example shows one of them.\nExample 9. Consider relational predicates GroupUser(User ,Group) and GroupFile(File,Group), with extensions as in instance D below. They represent users’ memberships of groups, and access permissions for groups to files, respectively.11\nGroupUser User Group\nJoe g1 Joe g2 John g1 Tom g2 Tom g3 John g3\nGroupFiles File Group\nf1 g1 f1 g3 f2 g2 f3 g3\nIt is expected that a user u can access file f if u belongs to a group that can access f , i.e. there is some group g such that GroupUser(u, g) and GroupFile(f, g) hold. Accordingly, we can define a view that collects users with the files they can access, as defined by the following query:\nAccess(User ,File) ← GroupUser(User ,Group),GroupFile(File,Group). (3)\nQuery Access in (3) has the following answers, providing a view extension:\nAccess(D) User File\nJoe f1 Joe f2 Tom f1 Tom f2 Tom f3 John f1 John f3\nIn a particular version of the delete-\npropagation problem, the objective may be to delete a minimum number of tuples from the instance, so that an authorized access (unexpected answer to the query) is deleted from the query answers, while all other authorized accesses (other answers to the query) remain intact.\nIn the following, we consider several variations of this problem, both in their functional and decision versions.\nDefinition 9. Let D be a database instance, and Q(x̄) a monotone query.\n(a) For ā ∈ Q(D), the minimal-source-side-effect deletion-problem is about computing a subset-minimal Λ ⊆ D, such that ā /∈ Q(D r Λ).\n(b) The minimal-source-side-effect decision problem is (deciding about the membership of):\n11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates. We use it here to point to the similarities between the seemingly different problems of view-updates and causality.\nMSSEPs(Q) = {(D,D′, ā) | ā ∈ Q(D), D′ ⊆ D, ā 6∈ Q(D′), and D′ is subset-maximal}. (The superscript s stands for subset-minimal.)\n(c) For ā ∈ Q(D), the minimum-source-side-effect deletion-problem is about computing a minimum-cardinality Λ ⊆ D, such that ā /∈ Q(D r Λ).\n(d) The minimum-source-side-effect decision problem is (deciding about the membership of):\nMSSEPc(Q) = {(D,D′, ā) | ā ∈ Q(D), D′ ⊆ D, ā /∈ Q(D′), and D′ has maximum cardinality}. (Here, c stands for cardinality.)\nDefinition 10. [10] Let D be a database instance D, and Q(x̄) a monotone query.\n(a) For ā ∈ Q(D), the view-side-effect-free deletion-problem is about computing a Λ ⊆ D, such that Q(D) r {ā} = Q(D r Λ).\n(b) The view-side-effect-free decision problem is (deciding about the membership of):\nVSEFP(Q) = {(D, ā) | ā ∈ Q(D), and exists D′ ⊆ D with Q(D) r {ā} = Q(D′)}.\nThe decision problem in Definition 10(b) is NP-complete for conjunctive queries [10, theorem 2.1]. Notice that, in contrast to those in (a) and (c) in Definition 9, this decision problem does not involve a candidate D′, and only asks about its existence. This is because candidates always exist for Definition 9, whereas for the view-side-effect-free deletion-problem there may be no subinstance that produces exactly the intended deletion from the view. As usual, there are functional problems associated to VSEFP, about computing a maximal/maximum D′ that produces the intended side-effect free deletion; and also the two corresponding decision problems about deciding concrete candidates D′.\nExample 10. (ex. 1 cont.) Consider the instance D and the conjunctive query Q in (1). Assume that XML is not among John’s research interests, so that tuple 〈John,XML〉 in the view Q(D) is unintended. We want to find tuples in D whose removal leads to the deletion of this view tuple. There are multiple ways to achieve this goal.\nNotice that the tuples in D related to answer 〈John,XML〉 through the query are Author(John, TKDE), Journal(TODS, XML, 32), Author(John, TODS) and Journal(TKDE, XML, 30). They are all candidates for removal. However, the decision problems described above impose different conditions on what are admissible deletions. (a) Source-side effect: The objective is to find minimal/minimum sets of tuples whose removal leads to the deletion of 〈John,XML〉. One solution is removing S1={Author(John, TODS), Author(John, TKDE)} from the Author table.\nThe other solution is removing S2={Journal(TODS, XML, 30), Journal(TKDE, XML, 30)} from the Journal table.\nFurthermore, the removal of either S3 = {Author(John,TKDE), Journal(TODS, XML, 32)} or S4 = {Author(John,TODS), Journal(TKDE,XML, 30)} eliminates the intended view tuple. Thus, S1, S2, S3 and S4 are solutions to both the minimum- and minimal-source side-effect deletion-problems. (b) View-side effect: Removing any of the sets S1, S2, S3 or S4, leads to the deletion of 〈John,XML〉. However, we now want those sets whose elimination produce no side-effects on the view. That is, their deletion triggers the deletion of 〈John,XML〉 from the view, but not of any other tuple in it.\nNone of the sets S1, S2, S3 and S4 is side-effect free. For example, the deletion of S1 also results in the deletion of 〈John,CUBE〉 from the view.\nExample 11. (ex. 9 cont.) It is easy to verify that there is no solution to the view-side-effect-free deletion-problem for answer 〈Tom, f3〉 (in the view extension Access). To eliminate this entry from the view, either GroupUser(Tom, g3) or GroupFiles(f3, g3) must be deleted from D. Removing the former results in the additional deletion of 〈Tom, f1〉 from the view; and eliminating the latter, results in the additional deletion of 〈John, f3〉.\nHowever, for the answer 〈Joe, f1〉, there is a solution to the view-side-effectfree deletion-problem, by removing GroupUser(Joe, g1) from D. This deletion does not have unintended side-effects on the view contents."
    }, {
      "heading" : "5.2. QA-causality and delete-propagation",
      "text" : "In this section we first establish mutual reductions between the deletepropagation problems and QA-causality."
    }, {
      "heading" : "5.2.1. Delete propagation from QA-causality.",
      "text" : ""
    }, {
      "heading" : "In this section, unless otherwise stated, all the database tuples are",
      "text" : "assumed to be endogenous.12\nConsider a relational instance D, a view V defined by a monotone query Q. Then, the virtual view extension, V(D), is Q(D).\nFor a tuple ā ∈ Q(D), the delete-propagation problem, in its most general form, is about deleting a set of tuples from D, and so obtaining a subinstance D′ of D, such that ā /∈ Q(D′). It is natural to expect that the deletion of ā from Q(D) can be achieved through deletions from D of actual causes for ā (to be in the view extension). However, to obtain solutions to the different variants of this problem introduced in Section 5.1, different combinations of actual causes must be considered.\nFirst, we show that an actual cause for ā forms, with any of its contingency sets, a solution to the minimal-source-side-effect deletion-problem associated to ā (cf. Definition 9).\n12 The reason is that in this section we want to characterize view-deletions in term of causality, but for the former problem we did not partition the database tuples.\nProposition 10. For an instance D, a subinstance D′ ⊆ D, a view defined by a monotone query Q(x̄), and ā ∈ Q(D), (D,D′, ā) ∈ MSSEPs(Q) iff there is a τ ∈ D r D′, such that τ ∈ Causes(D,Q(ā)) and D r (D′ ∪ {τ}) ∈ Conts(D,Q(ā), τ).\nProof: Suppose first that (D,D′, ā) ∈ MSSEPs(Q). Then, according to Definition 9, ā 6∈ Q(D′). Let Λ = D r D′. For an arbitrary element τ ∈ Λ (clearly, Λ 6= ∅), let Γ := Λ r {τ}. Due to the subset-maximality of D′ (then, subset-minimality of Λ), we obtain: D r (Γ ∪ {τ}) 6|= Q(ā), but D r Γ |= Q(ā). Therefore, τ is an actual cause for ā.\nFor the other direction, suppose τ ∈ Causes(D,Q(ā)) and Dr (D′ ∪ {τ}) ∈ Conts(D,Q(ā), τ). Let Γ := D r (D′ ∪ {τ}). From the definition of an actual cause, we obtain that ā /∈ Q(D r (Γ ∪ {τ}). So, ā /∈ Q(D′) (notice that D′ = D r (Γ ∪ {τ}). Since Γ is a subset-minimal contingency set for τ , D′ is a subset-maximal subinstance that enjoys the mentioned property. So, (D,D′, ā) ∈MSSEPs(Q).\nCorollary 1. For a view defined by a monotone query, deciding if a set of source deletions producing the deletion from the view is subset minimal is in polynomial time in data.\nProof: This follows from the connection between QA-causality and deletepropagation established in Proposition 10, and the fact that deciding a cause for a monotone query and deciding the subset minimality of an associated contingency set candidate are both in polynomial time in data [43, 7].\nWe show next that, in order to minimize the number of side-effects on the source (the problem in Definition 9(c)), it is good enough to pick a most responsible cause for ā with any of its minimum-cardinality contingency sets.\nProposition 11. For an instance D, a subinstance D′ ⊆ D, a view V defined by a monotone query Q, and ā ∈ Q(D), (D,D′, ā) ∈ MSSEPc(Q) iff there is a τ ∈ D r D′, such that τ ∈ MRC(D,Q(ā)), Γ := D r (D′ ∪ {τ}) ∈ Conts(D,Q(ā), τ), and there is no Γ′ ∈ Conts(D,Q(ā), τ) with |Γ′| < |Γ|.\nProof: Similar to the proof of Proposition 10.\nIn relation to the problems involved in this proposition, the decision problems associated to computing a minimum-side-effect source deletion and computing the responsibility of a cause, both for monotone queries, have been independently established as NP-complete in data, in [10] and [7], resp.\nExample 12. (ex. 10 cont.) We obtained the followings solutions to the minimum- (and also minimal-) source-side-effect deletion-problem for the view tuple 〈John,XML〉:\nS1 = {Author(John,TODS),Author(John,TKDE)}, S2 = {Journal(TODS,XML, 30), Journal(TKDE,XML, 30)}, S3 = {Author(John,TKDE), Journal(TODS,XML, 32)}, S4 = {Author(John,TODS), Journal(TKDE,XML, 30)}.\nOn the other side, in Example 1, we showed that the tuples Author(John,TODS), Journal(TKDE,XML, 32), Author(John,TKDE), and Journal(TODS, XML, 32) are actual causes for the answer 〈John,XML〉 (to the view query). In particular, for the cause Author(John,TODS) we obtained two contingency sets: Γ1 = {Author(John,TKDE)} and Γ2={Journal(TKDE,XML, 32)}.\nIt is easy to verify that each actual cause for answer 〈John,XML〉, together with any of its subset-minimal (and minimum-cardinality) contingency sets, forms a solution to the minimal- (and minimum-) source-side-effect deletionproblem for 〈John,XML〉. For illustration, {Author(John,TODS)}∪Γ1 coincides with S1, and {Author(John,TODS)}∪Γ1 coincides with S4. Thus, both of them are solutions to minimal- (and minimum-) source-side-effect deletion-problem for the view tuple 〈John,XML〉. This confirms Propositions 10 and 11.\nNow we consider a variant of the functional problem in Definition 9(c), about computing the minimum number of source deletions. The next result is obtained from the FPNP(log(n))-completeness of computing the highest responsibility associated to a query answer (i.e. the responsibility of the most responsible causes for the answer) [55, prop. 42].\nProposition 12. Computing the size of a solution to a minimum-source-sideeffect deletion-problem is FPNP(log(n))-hard.\nProof: By reduction from computing responsibility of a most responsible cause (cf. Definition 3) via the characterization in Proposition 11."
    }, {
      "heading" : "5.2.2. QA-causality from delete-propagation.",
      "text" : "In this subsection we assume that all tuples are endogenous since the endogenous vs. exogenous classification has not been considered on the view update side (but cf. Section 8.2).\nConsider a relational instance D, and a monotone query Q with ā ∈ Q(D). We will show that actual causes and most responsible causes for ā can be obtained from different variants of the delete-propagation problem associated with ā.\nFirst, we show that actual causes for a query answer can be obtained from the solutions to a corresponding minimal-source-side-effect deletion-problem.\nProposition 13. For an instance D and a monotone query Q(x̄) with ā ∈ Q(D), τ ∈ D is an actual cause for ā iff there is a D′ ⊆ D with τ ∈ (D rD′) and (D,D′, ā) ∈MSSEPs(Q).\nProof: Suppose τ ∈ D is an actual cause for ā with a subset-minimal contingency set Γ ⊆ D. Let Λ = Γ ∪ {τ} and D′ = D r Λ . It is clear that ā 6∈ Q(D′). Then, due to the subset-minimality of Λ, we obtain that (D,D′, ā) ∈ MSSEPs(Q). A similar argument applies to the other direction.\nSimilarly, most-responsible causes for a query answer can be obtained from solutions to a corresponding minimum-source-side-effect deletion-problem.\nProposition 14. For an instance D and a monotone query Q(x̄) with ā ∈ Q(D), τ ∈ D is a most responsible actual cause for ā iff there is a D′ ⊆ D with t ∈ (D rD′) and (D,D′, ā) ∈MSSEPc(Q).\nProof: Similar to the proof of Proposition 13.\nExample 13. (ex. 1 and 12 cont.) Assume all tuples are endogenous. We obtained S1, S2, S3 and S4 as solutions to the minimal- (and minimum-) sourceside-effect deletion-problems for the view-element 〈John,XML〉. Let S be their union, i.e. S = {Author(John,TODS), Journal(TKDE,XML, 32),Author(John, TKDE), Journal(TODS,XML, 32)}.\nWe can see that S contains actual causes for 〈John,XML〉. In this case, actual causes are also most responsible causes. This coincides with the results obtained in Example 1, and confirms Propositions 13 and 14.\nConsider a view defined by a query Q as in Proposition 14. Deciding if a candidate contingency set (for an actual cause τ) has minimum cardinality (giving to τ its responsibility value) is the complement of checking if a set of tuples is a maximum-cardinality repair (i.e a cardinality-based repair [4]) of the given instance with respect to the denial constraint that has Q as violation view (instantiated on τ). The latter problem is in coNP-hard in data [42, 2]. Thus, we obtain that checking minimum-cardinality contingency sets is NP-hard in data. Appealing to Proposition 14, we can reobtain via repairs and causality the result in [10] about the NP -completeness ofMSSEPc(Q). We illustrate the connection with an example.\nExample 14. Consider the instance D as below, and the view V defined by the query V (y) ← R(x, y), S(y).\nA view element (and query answer) is: 〈a1〉.\nNow, the denial constraint that has this (instantiated) view as violation view is κ : ¬V (a1), equivalently,\nR A B a1 a4 a2 a1 a3 a1\nS B a1 a2 a3\nκ : ¬∃x(R(x, a1) ∧ S(a1)). Instance D is inconsistent with respect to κ, and has to be repaired by keeping a consistent subset of D of maximum cardinality. The only cardinality-repair is: D r {S(a1)}. The complement of this repair, Γ = {S(a1)}, will be the minimum-cardinality contingency set for any cause in D for the query answer, i.e. for R(a2, a1) and R(a3, a1), but not for the cause S(a1), which is a counterfactual cause. Cf. [7] for more details on the relationship between repairs and causes with their contingency sets."
    }, {
      "heading" : "6. View-Conditioned Causality",
      "text" : ""
    }, {
      "heading" : "6.1. VC-causality and its decision problems",
      "text" : "QA-causality is defined for a fixed query Q and a fixed answer ā. However, in practice one often has multiple queries and/or multiple answers. For a query\nwith several answers one might be interested in causes for a fixed answer, on the condition that the other query answers are correct. This form of conditioned causality was suggested in [44]; and formalized in [45], in a more general, nonrelational setting, to give an account of the effect of a tuple on multiple outputs (views). Here we adapt this notion of view-conditioned causality to the case of a single query, with possibly several answers. We illustrate first the notion with a couple of examples.\nExample 15. (ex. 1 cont.) Consider again the answer 〈John,XML〉 to Q. Suppose this answer is unexpended and likely to be wrong, while all other answers to Q are known to be correct. In this case, it makes sense that for the causality status of 〈John,XML〉 only those contingency sets whose removal does not affect the correct answers to the query are admissible. In other words, the hypothetical states of the database D that do not provide the correct answers are not considered.\nExample 16. (ex. 9 cont.) Consider the query in (3) as defining a view Access, collecting users and the files they can access.\nSuppose we observe that a particular file is accessible by an unauthorized user (an unexpected answer to the query), while all other users’ accesses are known to be authorized (i.e. the other answers to the query are deemed to be correct). We want to find out the causes for this unexpected observation. For this task, contingency sets whose removal do not return the correct answers anymore should not be considered.\nMore generally, consider a query Q with Q(D) = {ā1, . . . , ān}. Fix an answer, say ā1 ∈ Q(D), while the other answers will be used as a condition on ā1’s causality. Intuitively, ā1 is somehow unexpected, we look for causes, but considering the other answers as “correct”. This has the effect of reducing the spectrum of contingency sets, by keeping Q(D)’s extension fixed (the fixed view extension), except for ā1 [45].\nDefinition 11. Given an instance D and a monotone query Q, consider ā ∈ Q(D), and V := Q(D) r {ā}:\n(a) Tuple τ ∈ Dn is a view-conditioned counterfactual cause (vcc-cause) for ā in D relative to V if ā /∈ Q(D r {τ}) but Q(D r {τ}) = V .\n(b) Tuple τ ∈ Dn is a view-conditioned actual cause (vc-cause) for ā in D relative to V if there exists a contingency set, Γ ⊆ Dn, such that τ is a vcc-cause for ā in D r Γ relative to V .\n(c) vc-Causes(D,Q(ā)) denotes the set of all vc-causes for ā.\n(d) The vc-causal responsibility of a tuple τ for answer ā is vc-ρD Q(ā) (τ) := 11+|Γ| ,\nwhere |Γ| is the size of the smallest contingency set that makes τ a vc-cause for ā.\nNotice that the implicit conditions on vc-causality in Definition 11(b) are: ā ∈ Q(D r Γ), ā /∈ (D r (Γ ∪ {τ})), and Q(D r (Γ ∪ {τ})) = V . In the following, we will omit saying “relative to V ” since the fixed contents can be understood from the context.\nClearly, vc-Causes(D,Q(ā)) ⊆ Causes(D,Q(ā)), but not necessarily the other way around. Furthermore, the causal responsibility and the vc-causal responsibility of a tuple as a cause, resp. vc-cause, for a same query answer may take different values.\nExample 17. (ex. 9 and 16 cont.) The extension for the Access view, given by query (3), is as follows:\nAccess(D) User File\nJoe f1 Joe f2 Tom f1 Tom f2 Tom f3 John f1 John f3\nAssume the access of Joe to file f1 -corresponding to the query answer 〈Joe, f1〉- is deemed to be unauthorized, while all other users’ accesses are considered to be authorized, i.e. the other answers to the query are considered to be correct.\nFirst, GroupUser(Joe, g1) is a counterfactual cause for answer 〈Joe, f1〉, and then also an actual cause, with empty contingency set. Now we are interested in causes for the answer 〈Joe, f1〉 that keep all the other answers untouched. GroupUser(Joe, g1) is also a vcc-cause.\nIn fact, Access(Dr{GroupUser(Joe, g1)}) = Access(D)r{〈Joe, f1〉}, showing that after the removal of GroupUser(Joe, g1), all the other previous answers remain. So, GroupUser(Joe, g1) is a vc-cause with empty contingency set, or equivalently, a vcc-cause.\nGroupFile(f1 , g1 ) is also an actual cause for 〈Joe, f1〉, actually a counterfactual cause. However, it is not a vcc-cause, because its removal leads to the elimination of the previous answer 〈John, f1〉. Even less could it be a vc-cause, because deleting a non-empty contingency set together with GroupFile(f1 , g1 ) can only make things worse: answer 〈John, f1〉 would still be lost.\nActually, GroupUser(Joe, g1) is the only vc-cause and the only vcc-cause for 〈Joe, f1〉.\nLet us assume that, instead of D, we have instance D′, with extensions:\nGroupUser’ User Group\nJoe g0 Joe g1 Joe g2 John g1 Tom g2 Tom g3 John g3\nGroupFiles’ File Group\nf1 g0 f1 g1 f1 g3 f2 g2 f3 g3\nThe answers to the query are the same as with D, in particular, we still have 〈Joe, f1〉 as an answer to the query.\nNow, GroupUser(Joe, g1 ) is not a counterfactual cause for 〈Joe, f1〉 anymore, since this answer can still be obtained via the tuples involving g0. However, GroupUser(Joe, g1 ) is an actual cause, with minimal contingency sets: Γ1 = {GroupUsers(Joe, g0)} and Γ2 = {GroupFiles(f1, g0)}.\nNow, GroupUser(Joe, g1 ) is not a vcc-cause, but it is a vc-cause, with minimal contingence sets Γ1 and Γ2 as above: Removing Γ1 or Γ2 from D\n′ keeps 〈Joe, f1〉 as an answer. However, both under D′ r (Γ1 ∪ {GroupUser(Joe, g1 )}) and D′r (Γ2∪{GroupUser(Joe, g1 )}) the answer 〈Joe, f1〉 is lost, but the other answers stay.\nExample 18. (ex. 1 and 15 cont.) The answer 〈John,XML〉 does not have any vc-cause. In fact, consider for example the tuple Author(John, TODS) that is an actual cause for 〈John,XML〉, with two contingency sets, Γ1 and Γ2. It is easy to verify that none of these contingency sets satisfies the condition in Definition 11(b). For example, the original answer 〈John,CUBE〉 is not preserved in DrΓ1. The same argument can be applied to all actual causes for 〈John,XML〉.\nNotice that Definition 11 could be generalized by considering that several answers are unexpected and the others are correct. This generalization can only affect the admissible contingency sets.\nThe notions of vc-causality and vc-responsibility have corresponding decisions problems, which can be defined in terms similar to those for plain causality and responsibility.\nDefinition 12. (a) The vc-causality decision problem (VCDP) is about membership of VCDP(Q) = {(D, ā, τ) | ā ∈ Q(D) and τ ∈ vc-Causes(D,Q(ā)) }. (b) The vc-causal responsibility decision problem is about membership of: VRDP(Q) = {(D, ā, τ, v) | τ ∈ Dn, v ∈ {0} ∪ { 1k | k ∈ N\n+}, D |= Q(ā), and vc-ρD\nQ (τ) > v}.\nLeaving the answers to a view fixed when finding causes for a query answer is a strong condition. Actually, as Example 18 shows, sometimes there are no vc-causes. For this reason it makes sense to study the complexity of deciding whether a query answer has a vc-cause or not. This is a relevant problem. For illustration, consider the query Access in Example 16. The existence of a vccause for an unexpected answer (unauthenticated access) to this query, tells us that it is possible to revoke the unauthenticated access without restricting other users’ access permissions.\nDefinition 13. For a monotone queryQ, the vc-cause existence problem (VCEP) is (deciding about membership of): VCEP(Q) = {(D, ā) | ā ∈ Q(D) and vc-Causes(D,Q(ā)) 6= ∅ }."
    }, {
      "heading" : "6.2. Characterization of vc-causality",
      "text" : "In this section we establish mutual reductions between the delete-propagation problem and view-conditioned QA-causality. They will be used in Section 6.3 to obtain some complexity results for view-conditioned causality.\nNow, we show that, in order to check if there exists a solution to the viewside-effect-free deletion-problem for ā ∈ V(D) (cf. Definition 10), it is good enough to check if ā has a view-conditioned cause for ā.13\nProposition 15. For an instance D and a view defined by a monotone query Q, with ā ∈ Q(D), (D, ā) ∈ VSEFP(Q) iff vc-Causes(D,Q(ā)) 6= ∅.\nProof: Assume ā1 has a view-conditioned cause τ . According to Definition 11, there exists a Γ ⊆ D, such that D r (Γ ∪ {τ}) 6|= Q(ā), D r Γ |= Q(ā), and Dr (Γ∪{τ}) |= Q(ā′), for every ā′ ∈ Q(D) with ā′ 6= ā. So, Γ∪{τ} is a viewside-effect-free delete-propagation solution for ā; and (D, ā) ∈ VSEFP(Q). A similar argument applies in the other direction.\nExample 19. (ex. 10, 12 and 18 cont.) We obtained in Example 10(b) that there is no view-side-effect-free solution to the delete-propagation problem for the view tuple 〈John,XML〉. This coincides with the result in Example 18, and confirms Proposition 15.\nNext, we show that vc-causes for an answer can be obtained from solutions to a corresponding view-side-effect-free deletion-problem.\nProposition 16. For an instance D = Dn ∪ Dx and a monotone query Q(x̄) with ā ∈ Q(D), τ ∈ Dn is a vc-cause for ā iff there is D′ ⊆ D, with τ ∈ (D rD′) ⊆ Dn, that is a solution to the view-side-effect-free deletion-problem for ā.\nProof: Similar to the proof of Proposition 13."
    }, {
      "heading" : "6.3. Complexity of vc-causality",
      "text" : "We now investigate the complexity of the view-conditioned causality problem (cf. Definition 12). For this, we take advantage of the connection between vccausality and view-side-effect-free delete-propagation.\nFirst, the following result about the vc-cause existence problem (cf. Definition 13) is obtained from the NP-completeness of the view-side-effect-free delete-propagation decision problem for conjunctive views [10, theorem 2.1] and Proposition 15.\nProposition 17. For CQs Q, VCEP(Q) is NP-complete (in data).\n13 Since this delete-propagation problem does not explicitly involve anything like contingency sets, the existential problem in Definition 10(b) is the right one to consider.\nProof: For membership of NP, the following is a non-deterministic PTIME algorithm for VCEP: Given D and answer ā to Q, guess a subset Γ ⊆ Dn and a tuple τ ∈ Dn, return yes if τ is a vc-cause for ā with contingency set Γ; otherwise return no. This test can be performed in PTIME in the size of D.\nHardness is by the reduction from the (NP-hard) view-side-effect-free deletepropagation problem that is explicitly given in the formulation of Proposition 15.\nThe next result is about deciding vc-causality (cf. Definition 12).\nProposition 18. For CQs Q, VCDP(Q) is NP-complete (in data).\nProof: Membership: For an input (D, ā), non-deterministically guess τ ∈ Dn and Γ ⊆ Dn, with τ /∈ Γ. If τ is a vc-cause for ā with contingency set Γ (which can be checked in polynomial time), return yes; otherwise return no.\nHardness: Given an instance D and ā ∈ Q(D), it is easy to see that: (D, ā) ∈ VCEP(Q) iff there is τ ∈ Dn with (D, ā, τ) ∈ VCDP(Q). This immediately gives us a one-to-many reduction from VCEP(Q): (D, ā) is mapped to the polynomially-many inputs of the form (D, ā, τ) for VCDP(Q), with τ ∈ Dn. The answer for (D, ā) is yes iff at least for one τ , (D, ā, τ) gets answer yes. This is a polynomial number of membership tests for VCDP(Q).\nIn this result, NP -hardness is defined in terms of “Cook (or Turing) reductions” as opposed to many-one (or Karp) reductions [25, 27]. NP -hardness under many-one reductions implies NP -hardness under Cook reductions, but the converse, although conjectured not to hold, is an open problem. However, for Cook reductions, it is still true that there is no efficient algorithm for an NP -hard problem, unless P = NP .\nFinally, we settle the complexity of the vc-causality responsibility problem for conjunctive queries.\nProposition 19. For CQs Q, VRDP(Q) is NP-complete (in data).\nProof: Membership: For an input (D, ā, τ, v), non-deterministically guess Γ ⊆ Dn, and return yes if τ is a vc-cause for ā with contingency set Γ, and |Γ| < 1v . Otherwise, return no. The verification can be done in PTIME in data.\nHardness: By reduction from the VCDP problem, shown to be NP -complete in Proposition 18.\nMap (D, ā, τ), an input for VCDP(Q), to the input (D, ā, τ, k) for VRDP(Q), where k = 1|D|+1 . Clearly, (D, ā, τ) ∈ VCDP(Q) iff (D, τ, ā, k) ∈ VRDP(Q). This follows from the fact that τ ∈ Dn is an actual cause for ā iff vc-ρD\nQ(ā) (τ) ≥\n1 |D| .\nNotice that the previous proof uses a Karp reduction, but from a problem identified as NP -hard through the use of a Cook reduction (in Proposition 18).\nAll results on vc-causality in this section also hold for UCQs."
    }, {
      "heading" : "7. QA-Causality under Integrity Constraints",
      "text" : "We start with some observations and examples on QA-causality in the presence of integrity constraints (ICs). First, at the basis of Halpern & Pearl’s approach to causality [30], we find interventions, i.e. actions on the model that determine counterfactual scenarios. In databases, they take the form of database updates, in particular, tuple deletions, which is the scenario we have consider so far. Accordingly, if a database D is expected to satisfy a given set of integrity constraints (that should also be considered as parts of the “model”), the instances obtained from D by tuple deletions (as interventions), as used to determine causes, should also satisfy the ICs.\nOn a different side, QA-causality as introduced in [43] is insensitive to equivalent query rewriting (as first pointed out in [26]): On the same instance, causes for query answers coincide for logically equivalent queries. However, QAcausality might be sensitive to equivalent query rewritings in the presence of ICs, as the following example shows.\nExample 20. Consider a relational schema S with predicates Dep(DName, TStaff ) and Course(CName, LName,DName). Consider the instance D for S:\nDep DName TStaff t1 Computing John t2 Philosophy Patrick t3 Math Kevin\nCourse CName TStaff DName t4 COM08 John Computing t5 Math01 Kevin Math t6 HIST02 Patrick Philosophy t7 Math08 Eli Math t8 COM01 John Computing\nwhere all the tuples are endogenous. Now, consider the CQ, Q, that collects the teaching staff who are lecturing in the department they are associated with:\nAnsQ(TStaff ) ← Dep(DName,TStaff ), (4) Course(CName,TStaff ,DName).\nThe answers are: Q(D) = {John,Patrick,Kevin}. Answer 〈John〉 has the following actual causes: t1, t4 and t8. t1 is a counterfactual cause, t4 has a single minimal contingency set Γ1 = {t8}; and t8 has a single minimal contingency set Γ2 = {t4}.\nNow, consider the following inclusion dependency that is satisfied by D:\nψ : ∀x∀y (Dep(x, y)→ ∃u Course(u, y, x)). (5)\nIn the presence of ψ, Q is equivalent to the query Q′ given by:\nAnsQ′(TStaff ) ← Dep(DName,TStaff )). (6)\nThat is, Q ≡{ψ} Q′. For query Q′, 〈John〉 is still an answer from D. However, considering only query Q′ and instance D, this answer has a single cause, t1, which is also a counterfactual cause. The question is whether t4 and t8 should still be considered as causes for answer 〈John〉 in the presence of ψ.\nNow consider the query Q1 given by\nAnsQ1(TStaff ) ← Course(CName,TStaff ,DName). (7)\n〈John〉 is an answer, and t4 and t8 are the only actual causes, with contingency sets Γ1 = {t8} and Γ2 = {t4}, resp.\nIn the presence of ψ, one should wonder if also t1 would be a cause (it contains the referring value John in table Dept), or, if not, whether its presence would make the previous causes less responsible.\nDefinition 14. Given an instance D = Dn ∪Dx that satisfies a set Σ of ICs, i.e. D |= Σ, and a monotone query Q with D |= Q(ā), a tuple τ ∈ Dn is an actual cause for ā under Σ if there is Γ ⊆ Dn, such that:\n(a) D r Γ |= Q(ā), and (b) D r Γ |= Σ.\n(c) D r (Γ ∪ {t}) 6|= Q(ā), and (d) D r (Γ ∪ {t}) |= Σ.\nCauses(D,Q(ā),Σ) denotes the set of actual causes for ā under Σ. For τ ∈ Causes(D,Q(ā),Σ), Cont(D,Q(ā), τ,Σ) and Conts(D,Q(ā), τ,Σ) denote the set of contingency sets, resp. subset-minimal contingency sets, for τ under Σ.\nThe responsibility of τ as a cause for an answer ā to query Q under a set Σ of ICs, denoted by ρD,Σ\nQ(ā) (τ), is defined exactly as in Section 3.1.\nExample 21. (ex. 20 cont.) Consider query Q in (4), and its answer 〈John〉. Without the constraint ψ in (5), tuple t4 was a cause with minimal contingency set Γ1 = {t8}.\nNow, it holds D r Γ1 |= ψ, but D r (Γ1 ∪ {t2}) 6|= ψ. So, in presence of ψ, and applying Definition 14, t4 is not longer an actual cause for answer 〈John〉. The same happens with t8. However, t1 is still an actual (counterfactual) cause, and the only one. So, it holds: Cause(D,Q(John), ψ) $ Causes(D,Q(John)).\nNotice that Q and Q′ in (6) have the same actual causes for answer 〈John〉 under ψ, namely t1.\nNow consider queryQ1 in (7), and its answer 〈John〉. Tuples t4 and t8 are still (non-counterfactual) actual causes in the presence of ψ. However, their previous contingency sets are not such anymore: Dr(Γ1∪{t4}) 6|= ψ, Dr(Γ2∪{t8}) 6|= ψ. Actually, the smallest contingency set for t4 is Γ3 = {t8, t1}; and for t8, Γ4 = {t4, t1}. Accordingly, the causal responsibilities of t4, t8 decrease in the presence of ψ: ρD\nQ(John) (t4) = 1 2 , but ρ D,ψ Q(John) (t4) = 1 3 .\nIn the presence of ψ, tuple t1 is still not an actual cause for answer 〈John〉 to Q1. For example, if we check the conditions in Definition 14, with Γ1 as potential contingency set, we find that (a),(b) and (d) hold: D r Γ1 |= Q1(John), D r Γ1 |= ϕ, and D r (Γ1 ∪ {t1}) |= ψ, resp. However, (c) does not hold: D r (Γ1 ∪ {t1}) |= Q1(John). For any other potential contingency set, some of the conditions (a)-(d) are not satisfied.\nFunctional dependencies (FDs) are never violated by tuple deletions. For these reason, conditions (b) and (d) in Definition 14, those that have to do with the ICs, are always satisfied. So, FDs should not have no effect on the set of causes for a query answer. Actually, this applies to the more general class of denial constraints (DCs), i.e. of the form ¬∀x̄(A1(x̄1) ∧ · · · ∧ An(x̄n)), with Ai a database predicate or a built-in.\nProposition 20. Consider an instance D, a monotone query Q, and a set of ICs Σ, such that D |= Σ. The following hold:\n(a) Causes(D,Q(ā),Σ) ⊆ Causes(D,Q(ā)). Furthermore, for every τ ∈ D, ρD,Σ\nQ(ā) (τ) ≤ ρD Q(ā) (τ).\n(b) Causes(D,Q(ā), ∅) = Causes(D,Q(ā)).\n(c) If Σ is a set of DCs, Causes(D,Q(ā),Σ) = Causes(D,Q(ā)). Furthermore, for every τ ∈ D, ρD,Σ\nQ(ā) (τ) = ρD Q(ā) (τ).\n(d) For a monotone query Q′ with Q′ ≡Σ Q, it holds Causes(D,Q(ā),Σ) = Causes(D,Q′(ā),Σ).\nProof: (a) Any contingency set Γ used for τ ∈ Causes(D,Q(ā),Σ), can be used as a contingency set for the definition of causality without ICs (which are those in Definition 14(a,c)): Cont(D,Q(ā), τ,Σ) ⊆ Cont(D,Q(ā), τ). The same inclusion holds for subset-minimal contingency sets. (b) For every contingency set Γ for a cause τ without ICs, conditions in Definition 14(b,d) are trivially satisfied with an empty set of ICs. (c) When D |= Σ, and Σ are DCs, every subset of D also satisfies Σ. Then, the new conditions on candidate contingency sets, those in Definition 14(b,d), are immediately satisfied. Since the same contingency sets apply both with or without ICs, the responsibility does not change. (d) For a potential cause τ with a candidate contingency set Γ, conditions in Definition 14(a,c) will be always simultaneously satisfied for Q and Q′, because according to the conditions in Definition 14(b,d), both DrΓ and Dr (Γ∪{τ}) satisfy Σ.\nNotice that Example 21 shows that the inclusion in item (a) above can be proper. It also shows that for a same actual cause, with and without ICs, the inequality of responsibilities may be strict.\nItem (d) above corresponds to the equivalent rewriting of the query in (4) into query (6) under the referential constraints. As shown in Example 21, under the latter both queries have the same causes.14 The monotonicity condition on Q′ in item (d) is necessary, first to apply the notion of cause to it, but more importantly, because monotonicity is not implied by the monotonicity of Q and\n14 Notice that this rewriting resembles the resolution-based rewritings used in semantic query optimization [12].\nquery equivalence under Σ. In fact, for schema S = {R(A,B), S(A,B)}, the FD R : A→ B, the BCQ Q : ∃x∃y∃z(R(x, y) ∧R(x, z) ∧ y 6= z), and the nonmonotonic Boolean query Q′ : ∃x∃y∃z(R(x, y) ∧R(x, z) ∧ ¬S(x, y) ∧ y 6= z), it holds Q ≡FD Q\n′. All the causality-related decision and computational problems for the case without ICs can be easily redefined in the presence of a set Σ of ICs, that we now make explicitly appear as a problem parameter, such as in RDP(Q,Σ), for the responsibility decision problem.\nSince FDs have no effect on causes, the causality-related decision problems in the presence of FDs have the same complexity upper bound as causality without FDs. For example, for a set Σ of FDs, RDP(Q,Σ), the responsibility problem now under FDs, is NP-complete, since this is already the case without ICs [43].\nWhen an instance satisfies a set of FDs, the decision problems may become tractable depending on the query structure. A particular syntactic class of CQs is that of key-preserving CQs: Given a set κ of key constraints (KCs), a CQ Q is key-preserving (more precisely, κ-preserving) if the key attributes of the relations appearing inQ are all included among the non-existentially quantified attributes of Q [15]. For, example, for the schema S(A,B,C), R(C,D), with the keys underlined, the queries Q1(y, z) : ∃xS(x, y, z), Q2(x, y, z) : (S(x, y, z)∧R(z, v)) are not key-preserving, but Q3(x, y) : ∃zS(x, y, z) and Q′2(x, y, z, w, z) : (S(x, y, z)∧ R(w, v) ∧ z = w) are. It turns out that, in the case of key-preserving CQs, deciding responsibility over instances that satisfy the key constraints (KCs) is in PTIME [14].\nThe view-side-effect-free delete propagation (VSEFD) problem can be easily reformulated in the presence of ICs, by including their satisfaction in Definition 10, both by D and the instance resulting from delete propagation, D r Λ. Furthermore, the mutual characterizations between the VSEFD and view-conditioned causality problems of Section 6.2 still hold in the presence of ICs.\nIt turns out that the decision version of the view-side-effect-free deletion problem for key preserving CQs is tractable in data complexity [15]. By appealing to the connection in Section 6 between vc-causality and that form of delete-propagation, vc-responsibility under KCs becomes tractable.15 However, it is intractable in general, because the problem without KCs already is, as shown in Proposition 19).\nProposition 21. Given a set κ of KCs, and a key-preserving CQ query Q, deciding VRDP(Q, κ) is in PTIME.\nOther classes of (view-defining) CQs for which different variants of deletepropagation are tractable are investigated in [38, 39] (generalizing those in [15]).\n15 Actually, the result in [15] just mentioned holds for single tuple deletions (with multiple deletions it can be NP-hard), which is the case in the causality setting, where a single answer is hypothetically deleted.\nThe connections between delete-propagation and causality established in Sections 5 and 6 should allow us to obtain new tractability results for causality.\nOur next result tells us that it is possible to capture vc-causality through non-conditioned QA-causality under tuple-generating dependencies (tgds).\nLemma 1. For every instance D an for a schema S, Q(x̄) ∈ L(S) a conjunctive query with n free variables, and ā ∈ Q(D), there is a tgd ψ over schema S∪{V }, with V a fresh n-ary predicate, and an instance D′ for S ∪ {V }, such that vc-Causes(D,Q(ā)) = Causes(D′,Q(ā), {ψ}).\nProof: Consider the instance D′ := D ∪ {V (c̄) | c̄ ∈ (Q(D) r {ā}), where the second disjunct is the extension for predicate V . The tgd ψ over schema S∪{V } is ∀x̄(V (x̄)→ Q(x̄)).\nIn the absence of ICs, deciding causality for CQs is tractable [43], but their presence may have an impact on this problem.\nProposition 22. For a CQ Q and a tgd ψ, CDP(Q, {ψ}) is NP-complete.\nProof: Membership is clear. Hardness is established by reduction from the NPcomplete vc-causality decision problem (cf. Proposition 18) for a CQ Q(x̄) over schema S. Now, consider the schema S ′ := S ∪{V } and the tgd ψ as in Lemma 1. In order to decide about (D,Q(ā), τ)’s membership of VCDP(Q), consider the instance D′ for S ′ as in Proposition 1. It holds: (D,Q(ā), τ) ∈ VCDP(Q) iff (D′,Q(ā), τ) ∈ CDP(Q, {ψ})."
    }, {
      "heading" : "7.1. Causality under ICs via view-updates and abduction",
      "text" : "In this work we have connected QA-causality with both abduction and viewupdates in form of delete-propagations. It is expected to find connections between causality under ICs and those two other problems in the presence of ICs, as the following example suggests.\nExample 22. (ex. 20 cont.) Formulated as an abduction problem, we have the query Q specified in by the Datalog rule in (4), defining an intentional predicate, AnsQ(TStaff ). All the tuples in the underlying database D, all endogenous, are considered to be abducible. The view-update request is the deletion of 〈John〉 from Q(D) (more precisely, from AnsQ(D)). As an abduction task, it is about giving an explanation for obtaining tuple AnsQ(John).\nAccording to our approach to abduction of Section 4, the abductive explanations are obtained from (and also lead to) maximal subsets E of D, such that E plus the query rule (4) does not entail AnsQ(John) anymore. These sets are: E1 = D r {t1}, and E2 = D r {t4, t8}, and are determined by finding minimal abductive explanations for AnsQ(John). So far, all this without considering the IC ψ in (5).\nNow, these maximal sub-instances have to be examined at the light of the IC. In this case, E1 does satisfy ψ, but E2 does not. So, the latter is rejected. As a consequence, the only admissible update is the deletion of t1 from D, which\ncoincides with having t1 as the only actual cause under the IC, as determined in Example 21.\nThis example shows that, and how, (minimal) abductive explanations, and also admissible view-updates, could be used to define, provide alternative characterizations, and compute actual causes in the presence of ICs. In this case, and according to Section 5, an admissible view-update (under the ICs) should be in correspondence, by definition, with an admissible combination of an actual cause and one of its contingency sets. This would make, in the previous example, t1 the only actual cause (also counterfactual) for 〈John〉 under ψ, as expected from the direct definition of cause under ICs.\nBoth view-updates and abduction can be defined in the presence of ICs. In particular, theories written in languages of logic programming have been considered as underlying theories for abduction and view updates in the presence of ICs [35, 36]. More specifically, in [18], view updates via abductive explanations are investigated in the context of stratified logic programs with ICs on the extensional database (as opposed to on the intentional relations).\nWe briefly illustrate using our ongoing example how Datalog abduction à la logic programming with constraints [40] could be used to determine causes in the presence of ICs.\nExample 23. (ex. 20 and 21 cont.) Consider query Q1, defined by the Datalog rule in (7), and the IND ψ in (5). We want to compute the causes for answer John by applying a resolution-based refutation procedure that generates candidate causes, but checks possible support from ICs, for underlying causes:\n← AnsQ1(John) (negated answer) AnsQ1(x) ← Course(u, x, y)\n← Course(u, John, y) Course(COM08, John,Computing) ← (from D) (*)\n← (tuple is candidate) Course(u, John, y) ← Dep(y, John) (check IND with (*))\n← Dep(y, John) Dep(Computing, John) ← (from D)\n← (tuple is candidate, no more IC)\nThe successful refutation shows Dep(Computing, John) as an abductive explanation (or a cause).16\nNotice that our additional checking above of (*) with the IND can be seen as generating a new query through the interaction of (7) and the IND, namely: Ans ′Q1(x)← Course(u, x, y),Dept(y, x), where the last body atom appended to the original query is the residue from that interaction, via resolution. This is\n16 More precisely, a Skolem functional term f(y, John) should replace variable u in Course(u, John, y)← Dep(y, John) [41].\nreminiscent of semantic query optimization [12], where satisfied ICs are used to optimize query answering, and also of consistent query answering [4, sec. 3.1], where possibly not satisfied ICs are imposed on queries to obtain semantically correct answers.\nThe procedure shown in the example could be refined to obtain contingent tuples for the obtained cause. Furthermore, it could be applied with Datalog extended with stratified negation [1, 11], using negation-as-failure [41] in the refutation. It could even be applied with causes for answers to conjunctive queries with negated atoms,17 and Why-No causes (as opposed to our Why-So causes [43]), i.e. for not obtaining an expected answer. This could be treated through view insertions with ICs, for which abduction can also be applied [18].\nIt is outside the scope of this work to give a full deductive-abductive approach to causes for answers to Datalog queries. However, it is worth mentioning that a FO, classical abductive approach to view updates in the presence of ICs is proposed in [18]. Continuing with our ongoing example, we briefly sketch this approach.\nExample 24. (ex. 23 cont.) Consider again the query Q defined by (4). Now, in FO-logic it becomes:18\n∀x(AnsQ1(x) ≡ ∃y∃z(Dep(y, x) ∧ Course(z, x, y))). (8)\nIn contrapositive, considering that we want to virtually delete the unintended answer AnsQ1(John):\n¬AnsQ1(John) ≡ ∀y∀z(¬Dep(y, John) ∨ ¬Course(z, John, y)). (9)\nThe formula on the right-hand side is (essentially) in disjunctive normal form (DNF), and expressed in terms of base atoms ( or abducible atoms). It is obtained through the negation (due to a virtual answer deletion) of the (only partially ground) lineage of the instantiated query [60, 9, 37].\nUp to this point the ICs have not been taken into account. This is the next step. First, the IND is written in DNF as well, via Skolemization, obtaining\nψ′ : ∀x∀y (¬Dep(x, y) ∨ Course(f(x, y), y, x)), (10)\nwhich is equiconsistent with ψ [41]. Next, to enforce the ICs, the atoms in (9) are appended residues from the ICs. They are obtained by resolution between each of the atoms (or more generally, literals) in (9) and the constraint (10). In this case, Dep(y, John) has not residue, but Course(z, John, y)) has Dept(y, John).19 So, the RHS of (9) becomes:\n∀y∀z(¬Dep(y, John) ∨ (¬Course(z, John, y) ∧Dept(y, John)). (11)\n17 This kind of queries were considered in [58], with a probabilistic approach. 18 Notice that this is the completion of predicate AnsQ as defined by (4). Predicate completion [41] can be used to deal with more complex Datalog queries [18]. 19 Notice the similarity with query rewriting for obtaining consistent query answers from possibly inconsistent databases [4, sec. 3.1].\nWe could call the right-hand side the semantic lineage of the (negated) query. Actually, it holds: (8) ∧ (11) |= ¬AnsQ(John) [18]. Notice that (11) can be written as:\n∀y(¬Dep(y, John) ∨ (¬∃zCourse(z, John, y) ∧Dept(y, John))). (12)\nDue to the IND, the second disjunct (which is its negation) can be eliminated, simply obtaining: ∀y¬Dep(y, John).\nUp to now the (extensional) databaseD has not been considered. By looking it up, we obtain that the (minimal) abductive explanation is Dep(Computing, John), leading to its deletion, and to it as a cause for the original answer.\nIn our case, formula (12) is very simple. In general, it can be much more complicated, e.g. when we have: (a) More complex Datalog queries, possibly with stratified negation, for which the intentional predicate completions have to be computed. In particular, conjunctive queries with negated atoms. (b) Several, possibly interacting ICs. (c) Complex view (intentional) updates, with both positive and negative ground atoms [18]. For tuple view insertions denial constraints, in particular key constraints and FDs, become relevant. It is possible to apply resolution to them, to obtain residues for the lineage literals.\nThe final interaction with the extensional database D, to keep everything in a classical FO setting, can be done (via resolution and the unique names assumption [41]) with the logical reconstruction of D [51]. In our example, it is given by the theory:\n∀x∀y(Dep(x, y) ≡ (x = Computing ∧ y = John) ∨ (x = Philosophy ∧ y = Patrick) ∨ ∨ (x = Math ∧ y = Kevin)).\n∀x∀y∀z(Course(x, y, z) ≡ (x = Com08 ∧ y = John ∧ z = Computing) ∨ (x = Math01 ∧ y = Kevin ∧ z = Math) ∨ (x = Hist02 ∧ y = Patrick ∧ z = Philosophy) ∨ (x = Math08 ∧ y = Eli ∧ z = Math) ∨ (x = Com01 ∧ y = John ∧ z = Computing))."
    }, {
      "heading" : "8. Discussion and Conclusions",
      "text" : "In this work we have investigated the computational aspects causality for answers to Datalog queries. This was made possible by establishing a precise connections (mutual reductions) with adbuction from Datalog theories. This connection is interesting per se. In particular, the notion of necessity-degree for abductive explanations, motivated by causality concepts, has been identified as relevant (cf. Section 4.3).\nWe have also investigated in detail the connections between query-answer causality for monotone queries and updates through views defined by monotone\nqueries. Particularly relevant is our investigation of view-conditioned causality, for which we established connections with the view side-effect free delete propagation problem. We obtained new complexity results for both problems.\nThe problem of causality under integrity constraints (ICs) had not been investigated so far. Here we proposed the corresponding notions and obtained first complexity results. Abduction under ICs was shown to be a promising direction to compute causes under ICs. There are still many problems and issues to investigate around causality in the presence of ICs.\nIn this work we concentrated on Why-So causes, i.e. causes for obtained query answers. In [43], causality for non-query-answers, i.e. causes for not obtaining an expected answer, i.e. Why-No causality, is defined on basis of sets of potentially missing tuples that account for the missing answer. However, concepts and techniques for abduction under ICs as found in [18] and suggested in Section 7.1 seem to be applicable to Why-No causality. This is also left for future work.\nIn the rest of this section we discuss in a bit more depth some issues that deserve being considered for future research. At the same time we also mention some related work that could be explored in more depth, for possibly interesting connections with our work."
    }, {
      "heading" : "8.1. Causality and ICs",
      "text" : "Some ICs are implicative, e.g. INDs and tgds, which makes it tempting to give them a causal semantics. For example, in [54] and more in the context of interventions for explanations, a ground instantiation, Pi(t̄i)→ Pj(t̄j), of an inclusion dependency is regarded a causal dependency of Pj(t̄j) upon Pi(t̄i). On this basis, a valid intervention removes Pj(t̄j) whenever Pi(t̄i) is removed from the instance. This is in line with our general approach, as can be seen from Example 21, with query Q1 and tuple t1.\nGiving to ICs a causal connotation is controversial. Actually, according to [31] logical dependencies are not causal dependencies per se. Our approach is also consistent with this view, in that antecedents of implications are not actual causes, but only elements of contingency sets, as can be seen, again, from Example 21, with query Q1 and tuple t1.\nOur use in Section 7.1 of the semantic lineage for determining causes in the presence of ICs leads, after grounding, to Boolean formulas in DNF. This opens the ground for possible applications of knowledge compilation techniques that are used in knowledge representation [20], and had also provided interesting results in data management [34]. This is direction that deserves investigation.\nEven more, we should point out that there are different ways of seeing ICs, and they could have an impact on the notion of cause. For example, according to [53], ICs are “epistemic in nature”, in the sense that rather than being statements about the domain represented by a database (or knowledge base), they are statement about the contents of the database, or about what it knows."
    }, {
      "heading" : "8.2. Endogenous tuples and view updates",
      "text" : "The partition of a database into endogenous and exogenous tuples used in causality may also be of interest in the context of delete-propagation. It makes sense to consider solutions based on endogenous delete-propagation, obtained through deletions of endogenous tuples only. Actually, given an instance D = Dn ∪Dx, a view V defined by a monotone query Q, and ā ∈ V(D), endogenous delete-propagation solutions for ā (in all of its flavors) can be obtained from actual causes for ā from the partitioned instance.\nExample 25. (ex. 10 cont.) Assume again that 〈John,XML〉 has to be deleted from the query answer (view extension). Assume now only the data in the Journal relation are reliable. Then, only deletions from the Author relation make sense. This can be captured by making Journal-tuples exogenous, and Author-tuples endogenous. With this partition, only Author(John,TODS) and Author(John,TKDE) are actual causes for 〈John,XML〉, with contingency sets Γ = {Author(John,TKDE)} and Γ′ = {Author(John,TODS)}, respectively (see Example 1).\nNow, each actual cause for 〈John,XML〉, together with its one-tuple subsetminimal (and also minimum-cardinality) contingency set, leads to the same set {Author(John,TODS), Author(John,TKDE)}, which, according to Propositions 10 and 11, is an endogenous minimal- (and minimum-) delete-propagation solution for 〈John,XML〉."
    }, {
      "heading" : "8.3. Related connections",
      "text" : "Our work, in combination with the results reported in [7], shows that there are deeper and multiple connections between the areas of QA-causality, abductive and consistency-based diagnosis, view-updates, and database repairs. Connections between consistency-based and abductive diagnosis have been established, e.g. in [16]. Abduction has been explicitly applied to database repairs [3]. The idea, again, is to “abduce” possible repair updates that bring the database to a consistent state. Further exploring and exploiting these connections is matter of ongoing and future research.\nThe view-update problem has been treated from the point of view of abductive reasoning [35, 18]. The basic idea is to “abduce” the presence of tuples in the base tables that explain the presence of those tuples in the view extension, of those one would like to, e.g. get rid of (cf. Section 7.1).\nDatabase repairs are related to the view-update problem. Actually, answer set programs (ASPs) [8] for database repairs [4, chap. 4] implicity repair the database by updating conjunctive combinations of intentional, annotated predicates. Those logical combinations -views after all- capture violations of integrity constraints in the original database or along the (implicitly iterative) repair process (a reason for the use of annotations).\nIn order to protect sensitive information, in [5] databases are explicitly and virtually “repaired” through secrecy views that specify the information that has to be kept secret. In order to protect information, a user is allowed to interact\nonly with the virtually repaired versions of the original database that result from making those views empty or contain only null values. Repairs are specified and computed using ASP, and an explicit connection to prioritized attribute-based repairs [4].\nAcknowledgments: Research funded by NSERC Discovery, and the NSERC Strategic Network on Business Intelligence (BIN)."
    }, {
      "heading" : "Appendix A. Proofs of Results",
      "text" : "Proof of Proposition 1: Consider a DAP AP = 〈Π, E,Hyp,Obs〉 associated to Π, and h ∈ Hyp. From the subset minimality of abductive diagnosis and Definition 4 (part (c)), we obtain h ∈ Ness(AP) iff Sol(AP ′) = ∅ where, AP ′ = 〈Π, E,Hyp r {h},Obs〉. To decide whether Sol(AP ′) = ∅, it is good enough to check if Π∪E∪Hyp |= Obs. This can be done in polynomial time since Datalog evaluation is in polynomial time in data complexity.\nProof of Proposition 2: Membership: Consider a Datalog abduction problem AP and a hypotheses h ∈ Hyp. To check whether h is relevant for AP, nondeterministically guess a subset ∆ ⊆ Hyp, check if: (a) h ∈ ∆, and (b) ∆ is an abductive diagnosis for AP. If h passes both tests then it is relevant, otherwise, it is irrelevant.\nClearly, test (a) can be performed in polynomial time. We only need to show that checking (b) is also polynomial time. More precisely, we need to show that Π∪E∪∆ |= Obs and ∆ is subset-minimal. Checking whether Π∪E∪∆ |= Obs can be done in polynomial time, because Datalog evaluation is polynomial time. It is easy to verify that to check the minimality of ∆, it is good enough to show that for all elements δ ∈ ∆, Π ∪ E ∪∆ r {δ} 6|= Obs. This is because positive Datalog is monotone.\nHardness: We show that the combined complexity of deciding relevance for the Propositional Horn Clause Abduction (PHCA) problem, that is NPcomplete [24], is a lower bound for the data complexity of the relevance problem for Datalog abduction.\nA PHCA problem is of the form P = 〈Var ,H,SD ,O〉, where Var is a finite set of propositional variables, H ⊆ Var contains hypotheses, SD is a set of definite propositional Horn clauses, and O ⊆ Var is the observation, with H ∩ O = ∅. An abductive diagnosis for P is a subset-minimal ∆ ⊆ H, such that ∆∪SD |= ∧ o∈O o. Deciding whether h ∈ H is relevant to P (i.e. it is an element of an abductive diagnosis of P) is NP-complete [24]. Deciding relevance for PHCA remains NP-hard for the 3-bounded case where: SD contains a rule “true ←”, and all the other rules are of the form “a ← b1, b2, b3”. 20\nNow, we provide a polynomial-time reduction from the problem of deciding relevance for 3-bounded PHCA to our problem RLDP. To obtain data complexity for the latter, we need a fixed relational schema and a fixed Datalog program Π over it, so that inputs for relevance in 3-bounded PHCA are mapped to the extensional components of Π, where relevance is tested.\nMore precisely, given a 3-bounded PHCA P, build the DAP problem APP =\n20 Every PHCA can be transformed to an equivalent 3-bounded PHCA, because each rule a ← b1, b2, . . . , bn can be equivalently replaced by two rules a ← c, . . . , bn and c ← b1, b2. Furthermore, true can be used to augment rule bodies with less than three propositional variables.\n〈Π, EP ,HypP ,ObsP〉 as follows, where Π is the following (non-propositional) Datalog program (whose underlying domain consists of the propositional variables in SD plus true):\nT (true) ← (A.1) T (x0) ← T (x1), T (x2), T (x3), R(x0, x1, x2, x3). (A.2)\nFurthermore, EP := {R(a, b1, b2, b3) | a ← b1, b2, b3 appears in SD}. Furthermore, Hyp = {T (a) | a ∈ H} and Obs = {T (a) | a ∈ O}. Notice that this reduction can be done in polynomial-time in the size of P.\nIt is possible to prove that: For a P = 〈Var ,H,SD ,O〉 and a hypothesis h ∈ H, h is relevant for P iff T (h) ∈ Rel(APP).\nThe following example illustrates the reduction in the hardness part of the proof of Proposition 2.\nExample 26. Consider the “Propositional Horn Clause Abduction” (PHCA) P = 〈{a, b, c}, {c, b}, {a ← b, c ; b ← c}, {a}〉, whose components are, respectively, a set of propositional variables, a subset of the former formed by the abductibles (hypothesis), a positive propositional program, and the set of observations. It is easy to verify that P has the single abductive diagnosis, {c}, and then a single relevant hypotheses, c.\nThe 3-bounded PHCA P3b = 〈{a, b, c}, {c, b}, {true ← ; a← b, c, true ; b← c, true, true}, {a}〉 is equivalent to P.\nNow, P3b can be mapped to the DAP APP 3b\n= 〈Π, {R(a, b, c, true), R(c, b, true, true)}, {T (c), T (b)}, {T (a))}〉, with Π as in (A.1, (A.2), which has a single abductive diagnosis, {T (c)}."
    } ],
    "references" : [ {
      "title" : "Repair Checking in Inconsistent Databases: Algorithms and Complexity",
      "author" : [ "F.N. Afrati", "Kolaitis", "Ph" ],
      "venue" : "Proc. ICDT,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2009
    }, {
      "title" : "Coherent Integration of Databases by Abductive Logic Programming",
      "author" : [ "O. Arieli", "M. Denecker", "B. Van Nuffelen", "M. Bruynooghe" ],
      "venue" : "J. Artif. Intell. Res.,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2004
    }, {
      "title" : "Database Repairing and Consistent Query Answering",
      "author" : [ "L. Bertossi" ],
      "venue" : "Synthesis Lectures on Data Management,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2011
    }, {
      "title" : "Achieving Data Privacy through Secrecy Views and Null-Based Virtual Updates",
      "author" : [ "L. Bertossi", "L. Li" ],
      "venue" : "IEEE Transaction on Knowledge and Data Engineering,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2013
    }, {
      "title" : "Unifying Causality, Diagnosis, Repairs and View- Updates in Databases",
      "author" : [ "L. Bertossi", "B. Salimi" ],
      "venue" : "First International PODS-Workshop on Big Uncertain Data (BUDA",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2014
    }, {
      "title" : "Answer Set Programming at a Glance",
      "author" : [ "G. Brewka", "T. Eiter", "M. Truszczynski" ],
      "venue" : "Communications of the ACM,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2011
    }, {
      "title" : "Why and Where: A Characterization of Data Provenance",
      "author" : [ "P. Buneman", "S. Khanna", "W.C. Tan" ],
      "venue" : "Proc. ICDT,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2001
    }, {
      "title" : "On Propagation of Deletions and Annotations Through Views",
      "author" : [ "P. Buneman", "S. Khanna", "W.C. Tan" ],
      "venue" : "Proc. PODS,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2002
    }, {
      "title" : "Logic-Based Approach to Semantic Query Optimization",
      "author" : [ "U.S. Chakravarthy", "J. Grant", "J. Minker" ],
      "venue" : "ACM TODS,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 1990
    }, {
      "title" : "Responsibility and Blame: A Structural- Model Approach",
      "author" : [ "H. Chockler", "J.Y. Halpern" ],
      "venue" : "J. Artif. Intell. Res.,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2004
    }, {
      "title" : "A Characterization of the Complexity of Resilience and Responsibility for Conjunctive Queries",
      "author" : [ "F. Cibele", "W. Gatterbauer", "N. Immerman", "Meliou A" ],
      "venue" : null,
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2015
    }, {
      "title" : "On the Complexity of View Update Analysis and its Application to Annotation Propagation",
      "author" : [ "G. Cong", "W. Fan", "F. Geerts", "J. Li", "J. Luo" ],
      "venue" : "IEEE Transactions on Knowledge and Data Engineering,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2012
    }, {
      "title" : "A Spectrum of Logical Definitions of Model- Based Diagnosis",
      "author" : [ "L. Console", "P. Torasso" ],
      "venue" : "Comput. Intell.,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 1991
    }, {
      "title" : "On the Relationship between Abduction and Deduction",
      "author" : [ "L. Console", "D. Theseider-Dupre", "P. Torasso" ],
      "venue" : "J. Log. Comput.,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1991
    }, {
      "title" : "The Role of Abduction in Database View Updating",
      "author" : [ "L. Console", "M.L. Sapino", "D. Theseider-Dupre" ],
      "venue" : "J. Intell. Inf. Syst.,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 1995
    }, {
      "title" : "Run-Time Translation of View Tuple Deletions Using Data Lineage",
      "author" : [ "Y. Cui", "J. Widom" ],
      "venue" : "Technical Report,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2001
    }, {
      "title" : "A Knowledge Compilation Map",
      "author" : [ "A. Darwiche", "P. Marquis" ],
      "venue" : "J. Artif. Intell. Res.,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2002
    }, {
      "title" : "Abduction in Logic Programming",
      "author" : [ "M. Denecker", "A.C. Kakas" ],
      "venue" : "In Computational Logic: Logic Programming and Beyond,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 2002
    }, {
      "title" : "The Complexity of Logic-Based Abduction",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "J. ACM ,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 1995
    }, {
      "title" : "Abduction from Logic Programs: Semantics and Complexity",
      "author" : [ "T. Eiter", "G. Gottlob", "N. Leone" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 1997
    }, {
      "title" : "Hypothesis Classification, Abductive Diagnosis and Therapy",
      "author" : [ "G. Friedrich", "Gottlob. G", "W. Nejdl" ],
      "venue" : "Proc. Internat. Workshop on Expert Systems in Engineering,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1990
    }, {
      "title" : "Reexamining Some Holy Grails of Data Provenance",
      "author" : [ "B. Glavic", "R.J. Miller" ],
      "venue" : "Proc. Theory and Practice of Provenance (TaPP),",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2011
    }, {
      "title" : "Computational Complexity",
      "author" : [ "O. Goldreich" ],
      "venue" : null,
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2008
    }, {
      "title" : "Bounded Treewidth as a Key to Tractability of Knowledge Representation And Reasoning",
      "author" : [ "G. Gottlob", "R. Pichler", "F. Wei" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2010
    }, {
      "title" : "Tractable Database Design and Datalog Abduction through Bounded Treewidth",
      "author" : [ "G. Gottlob", "R. Pichler", "F. Wei" ],
      "venue" : "Inf. Syst.,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2010
    }, {
      "title" : "Causes and Explanations: A Structural-Model Approach: Part 1",
      "author" : [ "J. Halpern", "J. Pearl" ],
      "venue" : "British J. Philosophy of Science,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2005
    }, {
      "title" : "Actual Causation and The Art of Modelling",
      "author" : [ "J. Halpern", "C.R. Hitchcock" ],
      "venue" : "College Publications,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2010
    }, {
      "title" : "Appropriate Causal Models and Stability of Causation",
      "author" : [ "J. Halpern" ],
      "venue" : "Proc. KR,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2014
    }, {
      "title" : "A Modification of Halpern-Pearl Definition of Causality",
      "author" : [ "J. Halpern" ],
      "venue" : "In Proc. IJCAI,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2015
    }, {
      "title" : "Knowledge Compilation Meets Database Theory: Compiling Queries to Decision Diagrams",
      "author" : [ "A. Jha", "D. Suciu" ],
      "venue" : "Theory of Computing Systems,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2013
    }, {
      "title" : "Database Updates through Abduction",
      "author" : [ "A.C. Kakas", "P. Mancarella" ],
      "venue" : "Proc. VLDB,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 1990
    }, {
      "title" : "Abductive Logic Programming",
      "author" : [ "A.C. Kakas", "R.A. Kowalski", "F. Toni" ],
      "venue" : "J. Logic and Computation,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 1992
    }, {
      "title" : "Semiring-Annotated Data: Queries and Provenance",
      "author" : [ "G. Karvounarakis", "T.J. Green" ],
      "venue" : "SIGMOD Record,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2012
    }, {
      "title" : "A Dichotomy in the Complexity of Deletion Propagation with Functional Dependencies",
      "author" : [ "B. Kimelfeld" ],
      "venue" : "Proc. PODS,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2012
    }, {
      "title" : "Maximizing Conjunctive Views in Deletion Propagation",
      "author" : [ "B. Kimelfeld", "J. Vondrak", "R. Williams" ],
      "venue" : "ACM TODS,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2012
    }, {
      "title" : "Integrity Checking in Deductive Databases",
      "author" : [ "R.A. Kowalski", "F. Sadri", "P. Soper" ],
      "venue" : "Proc. VLDB",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 1987
    }, {
      "title" : "Complexity of Consistent Query Answering in Databases under Cardinality-Based and Incremental Repair Semantics",
      "author" : [ "A. Lopatenko", "L. Bertossi" ],
      "venue" : "Proc. ICDT,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2007
    }, {
      "title" : "The Complexity of Causality and Responsibility for Query Answers and Non-Answers",
      "author" : [ "A. Meliou", "W. Gatterbauer", "K.F. Moore", "D. Suciu" ],
      "venue" : "Proc. VLDB,",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2010
    }, {
      "title" : "Causality in Databases",
      "author" : [ "A. Meliou", "W. Gatterbauer", "J. Halpern", "C. Koch", "K.F. Moore", "D. Suciu" ],
      "venue" : "IEEE Data Eng. Bull,",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2010
    }, {
      "title" : "Tracing Data Errors with View-Conditioned Causality",
      "author" : [ "A. Meliou", "W. Gatterbauer", "S. Nath", "D. Suciu" ],
      "venue" : "Proc. SIGMOD,",
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 2011
    }, {
      "title" : "Logic Programming, Abduction and Probability",
      "author" : [ "D. Poole" ],
      "venue" : "Proc. FGCS,",
      "citeRegEx" : "48",
      "shortCiteRegEx" : "48",
      "year" : 1992
    }, {
      "title" : "Representing Diagnosis Knowledge",
      "author" : [ "D. Poole" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence,",
      "citeRegEx" : "49",
      "shortCiteRegEx" : "49",
      "year" : 1994
    }, {
      "title" : "Ampliative Reasoning: Induction or Abduction",
      "author" : [ "A. Psillos" ],
      "venue" : "Proc. ECAI’96 Workshop on Abductive and Inductive Reasoning,",
      "citeRegEx" : "50",
      "shortCiteRegEx" : "50",
      "year" : 1996
    }, {
      "title" : "Towards a Logical Reconstruction of Relational Database Theory",
      "author" : [ "R. Reiter" ],
      "venue" : "In On Conceptual",
      "citeRegEx" : "51",
      "shortCiteRegEx" : "51",
      "year" : 1984
    }, {
      "title" : "A Theory of Diagnosis from First Principles",
      "author" : [ "R. Reiter" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "52",
      "shortCiteRegEx" : "52",
      "year" : 1987
    }, {
      "title" : "What Should A Database Know",
      "author" : [ "R. Reiter" ],
      "venue" : "J. Log. Program,",
      "citeRegEx" : "53",
      "shortCiteRegEx" : "53",
      "year" : 1992
    }, {
      "title" : "A Formal Approach to Finding Explanations for Database Queries",
      "author" : [ "S. Roy", "D. Suciu" ],
      "venue" : "Proc. SIGMOD,",
      "citeRegEx" : "54",
      "shortCiteRegEx" : "54",
      "year" : 2014
    }, {
      "title" : "From Causes for Database Queries to Repairs and Model-Based Diagnosis and Back",
      "author" : [ "B. Salimi", "L. Bertossi" ],
      "venue" : "Proc. ICDT,",
      "citeRegEx" : "55",
      "shortCiteRegEx" : "55",
      "year" : 2015
    }, {
      "title" : "Query-Answer Causality in Databases: Abductive Diagnosis and View-Updates",
      "author" : [ "B. Salimi", "L. Bertossi" ],
      "venue" : "Proc. UAI Workshop on Causal Inference,",
      "citeRegEx" : "56",
      "shortCiteRegEx" : "56",
      "year" : 2015
    }, {
      "title" : "Causes for Query Answers from Databases, Datalog Abduction and View-Updates: The Presence of Integrity Constraints",
      "author" : [ "B. Salimi", "L. Bertossi" ],
      "venue" : "Proc. FLAIRS,",
      "citeRegEx" : "57",
      "shortCiteRegEx" : "57",
      "year" : 2016
    }, {
      "title" : "Quantifying Causal Effects on Query Answering in Databases",
      "author" : [ "B. Salimi", "L. Bertossi", "D. Suciu", "G. Van den Broeck" ],
      "venue" : "Proc. 8th USENIX Workshop on the Theory and Practice of Provenance",
      "citeRegEx" : "58",
      "shortCiteRegEx" : "58",
      "year" : 2016
    }, {
      "title" : "Model-based Problem Solving",
      "author" : [ "P. Struss" ],
      "venue" : "In Handbook of Knowledge Representation, chap. 10. Elsevier,",
      "citeRegEx" : "59",
      "shortCiteRegEx" : "59",
      "year" : 2008
    } ],
    "referenceMentions" : [ {
      "referenceID" : 37,
      "context" : "The notion of causality-based explanation for a query result was introduced in [43], on the basis of the deeper concept of actual causation.",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 37,
      "context" : "This idea is formally captured through the notion of causal responsibility, and introduced in [43].",
      "startOffset" : 94,
      "endOffset" : 98
    }, {
      "referenceID" : 38,
      "context" : "In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities [44, 43].",
      "startOffset" : 118,
      "endOffset" : 126
    }, {
      "referenceID" : 37,
      "context" : "In applications involving large data sets, it is crucial to rank potential causes according to their responsibilities [44, 43].",
      "startOffset" : 118,
      "endOffset" : 126
    }, {
      "referenceID" : 38,
      "context" : "Furthermore, view-conditioned causality (in short, vc-causality) was proposed in [44, 45] as a restricted form of QA-causality, to determine causes for unexpected query results, but conditioned to the correctness of prior knowledge that cannot be altered by hypothetical tuple deletions.",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 39,
      "context" : "Furthermore, view-conditioned causality (in short, vc-causality) was proposed in [44, 45] as a restricted form of QA-causality, to determine causes for unexpected query results, but conditioned to the correctness of prior knowledge that cannot be altered by hypothetical tuple deletions.",
      "startOffset" : 81,
      "endOffset" : 89
    }, {
      "referenceID" : 37,
      "context" : "Actual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.",
      "startOffset" : 29,
      "endOffset" : 41
    }, {
      "referenceID" : 38,
      "context" : "Actual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.",
      "startOffset" : 29,
      "endOffset" : 41
    }, {
      "referenceID" : 39,
      "context" : "Actual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.",
      "startOffset" : 29,
      "endOffset" : 41
    }, {
      "referenceID" : 25,
      "context" : "Actual causation, as used in [43, 44, 45], can be traced back to [30], which provides a model-based account of causation on the basis of counterfactual dependence.",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 9,
      "context" : "Causal responsibility was introduced in [13], to provide a graded, quantitative notion of causality when multiple causes may over-determine an outcome.",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 47,
      "context" : "In [55, 7] connections were established between QA-causality and database repairs [4], which allowed to obtain several complexity results for QA-causality related problems.",
      "startOffset" : 3,
      "endOffset" : 10
    }, {
      "referenceID" : 2,
      "context" : "In [55, 7] connections were established between QA-causality and database repairs [4], which allowed to obtain several complexity results for QA-causality related problems.",
      "startOffset" : 82,
      "endOffset" : 85
    }, {
      "referenceID" : 44,
      "context" : "Connections between QA-causality and consistency-based diagnosis [52] were established in [55, 7].",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 47,
      "context" : "Connections between QA-causality and consistency-based diagnosis [52] were established in [55, 7].",
      "startOffset" : 90,
      "endOffset" : 97
    }, {
      "referenceID" : 47,
      "context" : "More specifically, QA-causality and causal responsibility were characterized in terms of consistency-based diagnosis, which led to new algorithmic results for QA-causality [55, 7].",
      "startOffset" : 172,
      "endOffset" : 179
    }, {
      "referenceID" : 4,
      "context" : "In [6] first connections between QA-causality, view updates, and abductive diagnosis in Datalog [17, 22] were announced.",
      "startOffset" : 3,
      "endOffset" : 6
    }, {
      "referenceID" : 13,
      "context" : "In [6] first connections between QA-causality, view updates, and abductive diagnosis in Datalog [17, 22] were announced.",
      "startOffset" : 96,
      "endOffset" : 104
    }, {
      "referenceID" : 18,
      "context" : "In [6] first connections between QA-causality, view updates, and abductive diagnosis in Datalog [17, 22] were announced.",
      "startOffset" : 96,
      "endOffset" : 104
    }, {
      "referenceID" : 37,
      "context" : "The definition of QA-causality applies to monotone queries [43, 44].",
      "startOffset" : 59,
      "endOffset" : 67
    }, {
      "referenceID" : 38,
      "context" : "The definition of QA-causality applies to monotone queries [43, 44].",
      "startOffset" : 59,
      "endOffset" : 67
    }, {
      "referenceID" : 47,
      "context" : "4 As discussed in [55], some objections to the Halpern-Pearl model of causality and the corresponding changes [32, 33] do not affect results in the context of databases.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 27,
      "context" : "4 As discussed in [55], some objections to the Halpern-Pearl model of causality and the corresponding changes [32, 33] do not affect results in the context of databases.",
      "startOffset" : 110,
      "endOffset" : 118
    }, {
      "referenceID" : 28,
      "context" : "4 As discussed in [55], some objections to the Halpern-Pearl model of causality and the corresponding changes [32, 33] do not affect results in the context of databases.",
      "startOffset" : 110,
      "endOffset" : 118
    }, {
      "referenceID" : 37,
      "context" : "ever, all complexity and algorithmic results in [43, 55] have been restricted to first-order (FO) monotone queries, mainly conjunctive queries.",
      "startOffset" : 48,
      "endOffset" : 56
    }, {
      "referenceID" : 47,
      "context" : "ever, all complexity and algorithmic results in [43, 55] have been restricted to first-order (FO) monotone queries, mainly conjunctive queries.",
      "startOffset" : 48,
      "endOffset" : 56
    }, {
      "referenceID" : 17,
      "context" : "In contrast to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly done with different sorts of logic programming-based specifications [21, 23, 29].",
      "startOffset" : 195,
      "endOffset" : 207
    }, {
      "referenceID" : 19,
      "context" : "In contrast to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly done with different sorts of logic programming-based specifications [21, 23, 29].",
      "startOffset" : 195,
      "endOffset" : 207
    }, {
      "referenceID" : 24,
      "context" : "In contrast to consistency-based diagnoses, which is usually practiced with FO specifications, abductive diagnosis is commonly done with different sorts of logic programming-based specifications [21, 23, 29].",
      "startOffset" : 195,
      "endOffset" : 207
    }, {
      "referenceID" : 24,
      "context" : "In particular, Datalog can be used as the specification language, giving rise to Datalog-abduction [29].",
      "startOffset" : 99,
      "endOffset" : 103
    }, {
      "referenceID" : 7,
      "context" : "The delete-propagation problem [10, 38, 39] is a particular case of the viewupdate problem, where only tuple deletions are allowed from the views.",
      "startOffset" : 31,
      "endOffset" : 43
    }, {
      "referenceID" : 33,
      "context" : "The delete-propagation problem [10, 38, 39] is a particular case of the viewupdate problem, where only tuple deletions are allowed from the views.",
      "startOffset" : 31,
      "endOffset" : 43
    }, {
      "referenceID" : 34,
      "context" : "The delete-propagation problem [10, 38, 39] is a particular case of the viewupdate problem, where only tuple deletions are allowed from the views.",
      "startOffset" : 31,
      "endOffset" : 43
    }, {
      "referenceID" : 7,
      "context" : "In a different case, we may want to minimize the side-effects on the view, requiring that other tuples in the (virtual) view contents are not affected (deleted) [10].",
      "startOffset" : 161,
      "endOffset" : 165
    }, {
      "referenceID" : 48,
      "context" : "This paper is an extension of both [56] and [57].",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 49,
      "context" : "This paper is an extension of both [56] and [57].",
      "startOffset" : 44,
      "endOffset" : 48
    }, {
      "referenceID" : 37,
      "context" : "In this section we review the notion of QA-causality as introduced in [43].",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 37,
      "context" : "The complexity of the computational and decision problems that arise in QA-causality have been investigated in [43, 55].",
      "startOffset" : 111,
      "endOffset" : 119
    }, {
      "referenceID" : 47,
      "context" : "The complexity of the computational and decision problems that arise in QA-causality have been investigated in [43, 55].",
      "startOffset" : 111,
      "endOffset" : 119
    }, {
      "referenceID" : 47,
      "context" : "This problem is tractable for UCQs [55].",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 37,
      "context" : "This problem is NP-complete for CQs [43] and UCQs [55], but tractable for linear CQs [43].",
      "startOffset" : 36,
      "endOffset" : 40
    }, {
      "referenceID" : 47,
      "context" : "This problem is NP-complete for CQs [43] and UCQs [55], but tractable for linear CQs [43].",
      "startOffset" : 50,
      "endOffset" : 54
    }, {
      "referenceID" : 37,
      "context" : "This problem is NP-complete for CQs [43] and UCQs [55], but tractable for linear CQs [43].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 37,
      "context" : "∃xvyu(A(x) ∧ S1(x, v) ∧ S2(v, y) ∧ R(y, u) ∧ S3(y, z)) is linear, but not ∃xyz(A(x) ∧B(y) ∧ C(z) ∧W (x, y, z)), for which RDP is NP-complete [43].",
      "startOffset" : 141,
      "endOffset" : 145
    }, {
      "referenceID" : 47,
      "context" : "This optimization problem is complete (in data) for FP for UCQs [55].",
      "startOffset" : 64,
      "endOffset" : 68
    }, {
      "referenceID" : 47,
      "context" : "For UCQs this problem is complete for P [55].",
      "startOffset" : 40,
      "endOffset" : 44
    }, {
      "referenceID" : 38,
      "context" : "A notion of view-conditioned causality [44] will be formalized and investigated in Section 6.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 42,
      "context" : "Although one could see an abductive explanation as a cause for the observation, it has been argued that causes and abductive explanations are not necessarily the same [50, 21].",
      "startOffset" : 167,
      "endOffset" : 175
    }, {
      "referenceID" : 17,
      "context" : "Although one could see an abductive explanation as a cause for the observation, it has been argued that causes and abductive explanations are not necessarily the same [50, 21].",
      "startOffset" : 167,
      "endOffset" : 175
    }, {
      "referenceID" : 13,
      "context" : "Under the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules.",
      "startOffset" : 42,
      "endOffset" : 58
    }, {
      "referenceID" : 18,
      "context" : "Under the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules.",
      "startOffset" : 42,
      "endOffset" : 58
    }, {
      "referenceID" : 40,
      "context" : "Under the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules.",
      "startOffset" : 42,
      "endOffset" : 58
    }, {
      "referenceID" : 41,
      "context" : "Under the abductive approach to diagnosis [17, 22, 48, 49], it is common that the system specification rather explicitly describes causal information, specially in action theories where the effects of actions are directly represented by positive definite rules.",
      "startOffset" : 42,
      "endOffset" : 58
    }, {
      "referenceID" : 17,
      "context" : "By restricting the explanation formulas to the predicates describing primitive causes (action executions), an explanation formula which entails an observation gives also a cause for the observation [21].",
      "startOffset" : 198,
      "endOffset" : 202
    }, {
      "referenceID" : 40,
      "context" : "In this case, and is some sense, causality information is imposed by the system specifier [48].",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 19,
      "context" : "A Datalog abduction problem [23] is of the form AP = 〈Π, E,Hyp,Obs〉, where: (a) Π is a set of Datalog rules, (b) E is a set of ground atoms (the extensional database), (c) Hyp, the hypothesis, is a finite set of ground atoms, the abducible atoms in this case, and (d) Obs, the observation, is a finite conjunction of ground atoms.",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 47,
      "context" : "7 In [55] we established such a connection between another form of model-based diagnosis [59], namely consistency-based diagnosis [52].",
      "startOffset" : 5,
      "endOffset" : 9
    }, {
      "referenceID" : 51,
      "context" : "7 In [55] we established such a connection between another form of model-based diagnosis [59], namely consistency-based diagnosis [52].",
      "startOffset" : 89,
      "endOffset" : 93
    }, {
      "referenceID" : 44,
      "context" : "7 In [55] we established such a connection between another form of model-based diagnosis [59], namely consistency-based diagnosis [52].",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 13,
      "context" : "For relationships and comparisons between consistency-based and abductive diagnosis see [17].",
      "startOffset" : 88,
      "endOffset" : 92
    }, {
      "referenceID" : 19,
      "context" : "A comprehensive complexity analysis of several reasoning tasks on abduction from propositional logic programs, in particular of the relevance and necessity problems, can be found in [23].",
      "startOffset" : 182,
      "endOffset" : 186
    }, {
      "referenceID" : 19,
      "context" : "In [23], it has been shown that for abduction from function-free first-order logic programs, the data complexity of each type of reasoning problem in the firstorder case coincides with the complexity of the same type of reasoning problem in the propositional case.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 20,
      "context" : "26] and the complexity of these problems for propositional Horn abduction (PDA), established in [24].",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 19,
      "context" : "In the Appendix we provide direct, ad hoc proofs by adapting the full machinery developed in [23] for general programs.",
      "startOffset" : 93,
      "endOffset" : 97
    }, {
      "referenceID" : 24,
      "context" : "However, a tractable case of combined complexity is identified in [29], on the basis of the notions of tree-decomposition and bounded tree-width, which we now briefly present.",
      "startOffset" : 66,
      "endOffset" : 70
    }, {
      "referenceID" : 23,
      "context" : "If the tree-width of the hypergraph under consideration is bounded by a fixed constant, then many otherwise intractable problems become tractable [28].",
      "startOffset" : 146,
      "endOffset" : 150
    }, {
      "referenceID" : 47,
      "context" : "of accompanying tuples [55].",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 47,
      "context" : "This result should be contrasted with the tractability of the same problem for UCQs [55].",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 47,
      "context" : "Hardness is obtain from the NP-completeness of RDP for conjunctive queries established in [55].",
      "startOffset" : 90,
      "endOffset" : 94
    }, {
      "referenceID" : 33,
      "context" : "It was first suggested in [38, 39], and here we investigate it more deeply.",
      "startOffset" : 26,
      "endOffset" : 34
    }, {
      "referenceID" : 34,
      "context" : "It was first suggested in [38, 39], and here we investigate it more deeply.",
      "startOffset" : 26,
      "endOffset" : 34
    }, {
      "referenceID" : 15,
      "context" : "11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates.",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 7,
      "context" : "11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates.",
      "startOffset" : 64,
      "endOffset" : 76
    }, {
      "referenceID" : 33,
      "context" : "11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates.",
      "startOffset" : 64,
      "endOffset" : 76
    }, {
      "referenceID" : 34,
      "context" : "11 This example, originally presented in [19] and later used in [10, 38, 39], is borrowed from the area of view-updates.",
      "startOffset" : 64,
      "endOffset" : 76
    }, {
      "referenceID" : 7,
      "context" : "[10] Let D be a database instance D, and Q(x̄) a monotone query.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 37,
      "context" : "Proof: This follows from the connection between QA-causality and deletepropagation established in Proposition 10, and the fact that deciding a cause for a monotone query and deciding the subset minimality of an associated contingency set candidate are both in polynomial time in data [43, 7].",
      "startOffset" : 284,
      "endOffset" : 291
    }, {
      "referenceID" : 7,
      "context" : "In relation to the problems involved in this proposition, the decision problems associated to computing a minimum-side-effect source deletion and computing the responsibility of a cause, both for monotone queries, have been independently established as NP-complete in data, in [10] and [7], resp.",
      "startOffset" : 277,
      "endOffset" : 281
    }, {
      "referenceID" : 2,
      "context" : "e a cardinality-based repair [4]) of the given instance with respect to the denial constraint that has Q as violation view (instantiated on τ).",
      "startOffset" : 29,
      "endOffset" : 32
    }, {
      "referenceID" : 36,
      "context" : "The latter problem is in coNP-hard in data [42, 2].",
      "startOffset" : 43,
      "endOffset" : 50
    }, {
      "referenceID" : 0,
      "context" : "The latter problem is in coNP-hard in data [42, 2].",
      "startOffset" : 43,
      "endOffset" : 50
    }, {
      "referenceID" : 7,
      "context" : "Appealing to Proposition 14, we can reobtain via repairs and causality the result in [10] about the NP -completeness ofMSSEP(Q).",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 38,
      "context" : "This form of conditioned causality was suggested in [44]; and formalized in [45], in a more general, nonrelational setting, to give an account of the effect of a tuple on multiple outputs (views).",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 39,
      "context" : "This form of conditioned causality was suggested in [44]; and formalized in [45], in a more general, nonrelational setting, to give an account of the effect of a tuple on multiple outputs (views).",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 39,
      "context" : "This has the effect of reducing the spectrum of contingency sets, by keeping Q(D)’s extension fixed (the fixed view extension), except for ā1 [45].",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 22,
      "context" : "In this result, NP -hardness is defined in terms of “Cook (or Turing) reductions” as opposed to many-one (or Karp) reductions [25, 27].",
      "startOffset" : 126,
      "endOffset" : 134
    }, {
      "referenceID" : 25,
      "context" : "First, at the basis of Halpern & Pearl’s approach to causality [30], we find interventions, i.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 37,
      "context" : "On a different side, QA-causality as introduced in [43] is insensitive to equivalent query rewriting (as first pointed out in [26]): On the same instance, causes for query answers coincide for logically equivalent queries.",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 21,
      "context" : "On a different side, QA-causality as introduced in [43] is insensitive to equivalent query rewriting (as first pointed out in [26]): On the same instance, causes for query answers coincide for logically equivalent queries.",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 8,
      "context" : "14 Notice that this rewriting resembles the resolution-based rewritings used in semantic query optimization [12].",
      "startOffset" : 108,
      "endOffset" : 112
    }, {
      "referenceID" : 37,
      "context" : "For example, for a set Σ of FDs, RDP(Q,Σ), the responsibility problem now under FDs, is NP-complete, since this is already the case without ICs [43].",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 11,
      "context" : "A particular syntactic class of CQs is that of key-preserving CQs: Given a set κ of key constraints (KCs), a CQ Q is key-preserving (more precisely, κ-preserving) if the key attributes of the relations appearing inQ are all included among the non-existentially quantified attributes of Q [15].",
      "startOffset" : 288,
      "endOffset" : 292
    }, {
      "referenceID" : 10,
      "context" : "It turns out that, in the case of key-preserving CQs, deciding responsibility over instances that satisfy the key constraints (KCs) is in PTIME [14].",
      "startOffset" : 144,
      "endOffset" : 148
    }, {
      "referenceID" : 11,
      "context" : "It turns out that the decision version of the view-side-effect-free deletion problem for key preserving CQs is tractable in data complexity [15].",
      "startOffset" : 140,
      "endOffset" : 144
    }, {
      "referenceID" : 33,
      "context" : "Other classes of (view-defining) CQs for which different variants of deletepropagation are tractable are investigated in [38, 39] (generalizing those in [15]).",
      "startOffset" : 121,
      "endOffset" : 129
    }, {
      "referenceID" : 34,
      "context" : "Other classes of (view-defining) CQs for which different variants of deletepropagation are tractable are investigated in [38, 39] (generalizing those in [15]).",
      "startOffset" : 121,
      "endOffset" : 129
    }, {
      "referenceID" : 11,
      "context" : "Other classes of (view-defining) CQs for which different variants of deletepropagation are tractable are investigated in [38, 39] (generalizing those in [15]).",
      "startOffset" : 153,
      "endOffset" : 157
    }, {
      "referenceID" : 11,
      "context" : "15 Actually, the result in [15] just mentioned holds for single tuple deletions (with multiple deletions it can be NP-hard), which is the case in the causality setting, where a single answer is hypothetically deleted.",
      "startOffset" : 27,
      "endOffset" : 31
    }, {
      "referenceID" : 37,
      "context" : "In the absence of ICs, deciding causality for CQs is tractable [43], but their presence may have an impact on this problem.",
      "startOffset" : 63,
      "endOffset" : 67
    }, {
      "referenceID" : 30,
      "context" : "In particular, theories written in languages of logic programming have been considered as underlying theories for abduction and view updates in the presence of ICs [35, 36].",
      "startOffset" : 164,
      "endOffset" : 172
    }, {
      "referenceID" : 31,
      "context" : "In particular, theories written in languages of logic programming have been considered as underlying theories for abduction and view updates in the presence of ICs [35, 36].",
      "startOffset" : 164,
      "endOffset" : 172
    }, {
      "referenceID" : 14,
      "context" : "More specifically, in [18], view updates via abductive explanations are investigated in the context of stratified logic programs with ICs on the extensional database (as opposed to on the intentional relations).",
      "startOffset" : 22,
      "endOffset" : 26
    }, {
      "referenceID" : 35,
      "context" : "We briefly illustrate using our ongoing example how Datalog abduction à la logic programming with constraints [40] could be used to determine causes in the presence of ICs.",
      "startOffset" : 110,
      "endOffset" : 114
    }, {
      "referenceID" : 8,
      "context" : "reminiscent of semantic query optimization [12], where satisfied ICs are used to optimize query answering, and also of consistent query answering [4, sec.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 37,
      "context" : "It could even be applied with causes for answers to conjunctive queries with negated atoms, and Why-No causes (as opposed to our Why-So causes [43]), i.",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 14,
      "context" : "This could be treated through view insertions with ICs, for which abduction can also be applied [18].",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 14,
      "context" : "However, it is worth mentioning that a FO, classical abductive approach to view updates in the presence of ICs is proposed in [18].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 6,
      "context" : "It is obtained through the negation (due to a virtual answer deletion) of the (only partially ground) lineage of the instantiated query [60, 9, 37].",
      "startOffset" : 136,
      "endOffset" : 147
    }, {
      "referenceID" : 32,
      "context" : "It is obtained through the negation (due to a virtual answer deletion) of the (only partially ground) lineage of the instantiated query [60, 9, 37].",
      "startOffset" : 136,
      "endOffset" : 147
    }, {
      "referenceID" : 50,
      "context" : "17 This kind of queries were considered in [58], with a probabilistic approach.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 14,
      "context" : "Predicate completion [41] can be used to deal with more complex Datalog queries [18].",
      "startOffset" : 80,
      "endOffset" : 84
    }, {
      "referenceID" : 14,
      "context" : "Actually, it holds: (8) ∧ (11) |= ¬AnsQ(John) [18].",
      "startOffset" : 46,
      "endOffset" : 50
    }, {
      "referenceID" : 14,
      "context" : "(c) Complex view (intentional) updates, with both positive and negative ground atoms [18].",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 43,
      "context" : "The final interaction with the extensional database D, to keep everything in a classical FO setting, can be done (via resolution and the unique names assumption [41]) with the logical reconstruction of D [51].",
      "startOffset" : 204,
      "endOffset" : 208
    }, {
      "referenceID" : 37,
      "context" : "In [43], causality for non-query-answers, i.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 14,
      "context" : "However, concepts and techniques for abduction under ICs as found in [18] and suggested in Section 7.",
      "startOffset" : 69,
      "endOffset" : 73
    }, {
      "referenceID" : 46,
      "context" : "For example, in [54] and more in the context of interventions for explanations, a ground instantiation, Pi(t̄i)→ Pj(t̄j), of an inclusion dependency is regarded a causal dependency of Pj(t̄j) upon Pi(t̄i).",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 26,
      "context" : "Actually, according to [31] logical dependencies are not causal dependencies per se.",
      "startOffset" : 23,
      "endOffset" : 27
    }, {
      "referenceID" : 16,
      "context" : "This opens the ground for possible applications of knowledge compilation techniques that are used in knowledge representation [20], and had also provided interesting results in data management [34].",
      "startOffset" : 126,
      "endOffset" : 130
    }, {
      "referenceID" : 29,
      "context" : "This opens the ground for possible applications of knowledge compilation techniques that are used in knowledge representation [20], and had also provided interesting results in data management [34].",
      "startOffset" : 193,
      "endOffset" : 197
    }, {
      "referenceID" : 45,
      "context" : "For example, according to [53], ICs are “epistemic in nature”, in the sense that rather than being statements about the domain represented by a database (or knowledge base), they are statement about the contents of the database, or about what it knows.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 12,
      "context" : "in [16].",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 1,
      "context" : "Abduction has been explicitly applied to database repairs [3].",
      "startOffset" : 58,
      "endOffset" : 61
    }, {
      "referenceID" : 30,
      "context" : "The view-update problem has been treated from the point of view of abductive reasoning [35, 18].",
      "startOffset" : 87,
      "endOffset" : 95
    }, {
      "referenceID" : 14,
      "context" : "The view-update problem has been treated from the point of view of abductive reasoning [35, 18].",
      "startOffset" : 87,
      "endOffset" : 95
    }, {
      "referenceID" : 5,
      "context" : "Actually, answer set programs (ASPs) [8] for database repairs [4, chap.",
      "startOffset" : 37,
      "endOffset" : 40
    }, {
      "referenceID" : 3,
      "context" : "In order to protect sensitive information, in [5] databases are explicitly and virtually “repaired” through secrecy views that specify the information that has to be kept secret.",
      "startOffset" : 46,
      "endOffset" : 49
    }, {
      "referenceID" : 2,
      "context" : "Repairs are specified and computed using ASP, and an explicit connection to prioritized attribute-based repairs [4].",
      "startOffset" : 112,
      "endOffset" : 115
    } ],
    "year" : 2017,
    "abstractText" : "Causality has been recently introduced in databases, to model, characterize, and possibly compute causes for query answers. Connections between QAcausality and consistency-based diagnosis and database repairs (wrt. integrity constraint violations) have already been established. In this work we establish precise connections between QA-causality and both abductive diagnosis and the view-update problem in databases, allowing us to obtain new algorithmic and complexity results for QA-causality. We also obtain new results on the complexity of view-conditioned causality, and investigate the notion of QA-causality in the presence of integrity constraints, obtaining complexity results from a connection with view-conditioned causality. The abduction connection under integrity constraints allows us to obtain algorithmic tools for QA-causality.",
    "creator" : "LaTeX with hyperref package"
  }
}