{
  "name" : "1301.6479.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Ontology-based Data Access: A Study through Disjunctive Datalog, CSP, and MMSNP",
    "authors" : [ "Meghyn Bienvenu", "Balder ten Cate", "Carsten Lutz", "Frank Wolter" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "Categories and Subject Descriptors",
      "text" : "H.2.3 [Database Management]: Languages—Query languages; H.2.5 [Database Management]: Heterogeneous Databases"
    }, {
      "heading" : "Keywords",
      "text" : "Ontology-Based Data Access; Query Answering; Query Rewriting"
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "Ontologies are logical theories that formalize domain-specific knowledge, thereby making it available for machine processing. Recent years have seen an increasing interest in using ontologies in data-intensive applications, especially in the context of intelligent systems, the semantic web, and in data integration. A much studied scenario is that of answering queries over an incomplete database under the open world semantics, taking into account knowledge\nPermission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PODS’13, June 22–27, 2013, New York, New York, USA. Copyright 2013 ACM 978-1-4503-2066-5/13/06 ...$15.00.\nprovided by an ontology [19, 18, 16]. We refer to this as ontologybased data access (OBDA).\nThere are several important use cases for OBDA. A classical one is to enrich an incomplete data source with background knowledge, in order to obtain a more complete set of answers to a query. For example, if a medical patient database contains the facts that patient1 has finding Erythema Migrans and patient2 has finding Lyme disease, and the ontology provides the background knowledge that a finding of Erythema Migrans is sufficient for diagnosing Lyme disease, then both patient1 and patient2 can be returned when querying for patients that have the diagnosis Lyme disease. This use of ontologies is also central to query answering in the semantic web. OBDA can also be used to enrich the data schema (that is, the relation symbols used in the presentation of the data) with additional symbols to be used in a query. For example, a patient database may contain facts such as patient1 has diagnosis Lyme disease and patient2 has diagnosis Listeriosis, and an ontology could add the knowledge that Lyme disease and Listeriosis are both bacterial infections, thus enabling queries such as “return all patients with a bacterial infection” despite the fact that the data schema does not include a relation or attribute explicitly referring to bacterial infections. Especially in the bio-medical domain, applications of this kind are fueled by the availability of comprehensive professional ontologies such as SNOMED CT and FMA. A third prominent application of OBDA is in data integration, where an ontology can be used to provide a uniform view on multiple data sources [40]. This typically involves mappings from the source schemas to the schema of the ontology, which we will not explicitly consider here.\nWe may view the actual database query and the ontology as two components of one composite query, which we call an ontologymediated query. OBDA can then be described as the problem of answering ontology-mediated queries. The database queries used in OBDA are typically unions of conjunctive queries, while the ontologies are typically specified in an ontology language that is either a description logic, or, more generally, a suitable fragment of first-order logic. For popular choices of ontology languages, the data complexity of ontology-mediated queries can be CONP-complete, which has resulted in extensive research on finding tractable classes of ontology-mediated queries, as well as on finding classes of ontology-mediated queries that are amenable to efficient query answering techniques [17, 29, 32]. In particular, relevant classes of ontology-mediated queries have been identified that admit an FO-rewriting (i.e., that are equivalent to a first-order query), or, alternatively, admit a datalog-rewriting. FO-rewritings make it possible to answer ontology-based queries using traditional database management systems. This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42]. ar X\niv :1\n30 1.\n64 79\nv2 [\ncs .D\nB ]\n6 J\nun 2\n01 3\nThe main aims of this paper are (i) to characterize the expressive power of ontology-mediated queries, both in terms of more traditional database query languages and from a descriptive complexity perspective and (ii) to make progress towards complete and decidable classifications of ontology-mediated queries, with respect to their data complexity, as well as with respect to FO-rewritability and datalog-rewritability.\nWe take an ontology-mediated query to be a triple (S,O, q) where S is a data schema, O an ontology, and q a query. Here, the data schema S fixes the set of relation symbols than can occur in the data and the ontology O is a logical theory that may use the relation symbols from S as well as additional symbols. The query q can use any relation symbol that occurs in S or O. As ontology languages, we consider a range of standard description logics (DLs) and several fragments of first-order logic that embed ontology languages such as Datalog± [15], namely the guarded fragment (GF), the unary negation fragment (UNFO), and the guarded negation fragment (GNFO). As query languages for q, we focus on unions of conjunctive queries (UCQs) and unary atomic queries (AQs). The latter are of the form A(x), with A a unary relation symbol, and correspond to what are traditionally called instance queries in the OBDA literature (note that A may be a relation symbol from O that is not part of the data schema). These two query languages are among the most used query languages in OBDA. In the following, we use (L,Q) to denote the query language that consists of all ontology-mediated queries (S,O, q) with O specified in the ontology language L and q specified in the query language Q. For example, (GF,UCQ) refers to ontologymediated queries in whichO is a GF-ontology and q is a UCQ. We refer to such query languages (L,Q) as ontology-mediated query languages (or, OBDA languages).\nIn Section 3, we characterize the expressive power of OBDA languages in terms of natural fragments of (negation-free) disjunctive datalog. We first consider the basic description logic ALC. We show that (ALC,UCQ) has the same expressive power as monadic disjunctive datalog (abbreviated MDDlog) and that (ALC,AQ) has the same expressive power as unary queries defined in a syntactic fragment of MDDlog that we call connected simple MDDlog. Similar results hold for various description logics that extendALC with, for example, inverse roles, role hierarchies, and the universal role, all of which are standard operators included in the W3Cstandardized ontology language OWL2 DL. Turning to other fragments of first-order logic, we then show that (UNFO,UCQ) also has the same expressive power as MDDlog, while (GF,UCQ) and (GNFO,UCQ) are strictly more expressive and coincide in expressive power with frontier-guarded disjunctive datalog, which is the DDlog fragment given by programs in which, for every atom α in the head of a rule, there is an atom β in the rule body that contains all variables from α.\nIn Sections 4 and 5, we study ontology-mediated queries from a descriptive complexity perspective. In particular, we establish an intimate connection between OBDA query languages, constraint satisfaction problems, and MMSNP. Recall that constraint satisfaction problems (CSPs) form a subclass of the complexity class NP that, although it contains NP-hard problems, is in certain ways more computationally well-behaved. The widely known FederVardi conjecture [24] states that there is a dichotomy between PTIME and NP for the class of all CSPs, that is, each CSP is either in PTIME or NP-hard. In other words, the conjecture asserts that there are no CSPs which are NP-intermediate in the sense of Ladner’s theorem. Monotone monadic strict NP without inequality (abbreviated MMSNP) was introduced by Feder and Vardi as a logical generalization of CSP that enjoys similar computational\nproperties [24]. In particular, it was shown in [24, 33] that there is a dichotomy between PTIME and NP for MMSNP sentences if and only if the Feder-Vardi conjecture holds.\nIn Section 4, we observe that (ALC,UCQ) and many other OBDA languages based on UCQs have the same expressive power as the query language coMMSNP, consisting of all queries whose complement is definable by an MMSNP formula with free variables. In the spirit of descriptive complexity theory, we say that (ALC,UCQ) captures coMMSNP. In fact, this result is a consequence of the results in Section 3 and the observation that MDDlog has the same expressive power as coMMSNP. It has fundamental consequences regarding the data complexity of ontology-mediated queries and the containment problem for such queries, which we describe next.\nFirst, we obtain that there is a dichotomy between PTIME and CONP for ontology-mediated queries from (ALC,UCQ) if and only if the Feder-Vardi conjecture holds, and similarly for many other OBDA languages based on UCQs. To appreciate this result, recall that considerable effort has been directed towards identifying tractable classes of ontology-mediated queries. Ideally, one would like to classify the data complexity of every ontology-mediated query within a given OBDA language such as (ALC,UCQ). Our aforementioned result ties this task to proving the Feder-Vardi conjecture. Significant progress has been made in understanding the complexity of CSPs and MMSNPs [14, 12, 34], and the connection established in this paper facilitates the transfer of techniques and results from CSP and MMSNP in order to analyze the data complexity of query evaluation in (ALC,UCQ). We also consider the standard extension ALCF of ALC with functional roles and note that, for query evaluation in (ALCF ,AQ), there is no dichotomy between PTIME and CONP unless PTIME = NP.\nTo establish a counterpart of (GF,UCQ) and (GNFO,UCQ) in the MMSNP world, we introduce guarded monotone strict NP (abbreviated GMSNP) as a generalization of MMSNP; specifically, GMSNP is obtained from MMSNP by allowing guarded secondorder quantification in the place of monadic second-order quantification, similarly as in the transition from MDDlog to frontierguarded disjunctive datalog. The resulting query language coGMSNP has the same expressive power as frontier-guarded disjunctive datalog, and therefore, in particular, (GF,UCQ) and (GNFO,UCQ) capture coGMSNP. We observe that GMSNP has the same expressive power as the extension MMSNP2 of MMSNP proposed in [37]. It follows from our results in Section 3 that GMSNP (and thus MMSNP2) is strictly more expressive than MMSNP, closing an open problem from [37]. We leave it as an open problem whether GMSNP is computationally as well-behaved as MMSNP, that is, whether there is a dichotomy between PTIME and NP if the Feder-Vardi conjecture holds.\nThe second application of the connection between OBDA and MMSNP concerns query containment. It was shown in [24] that containment between MMSNP sentences is decidable. We use this result to prove that query containment is decidable for many OBDA languages based on UCQs, including (ALC,UCQ) and (GF,UCQ). Note that this refers to a very general form of query containment in OBDA, as recently introduced and studied in [10]. For (ALCF ,AQ), this problem (and every other decision problem discussed below) turns out to be undecidable.\nIn Section 5, we consider OBDA languages based on atomic queries and establish a tight connection to (certain generalizations of) CSPs. This connection is most easily stated for Boolean atomic queries (BAQs): we prove that (ALC,BAQ) captures the query language that consists of all Boolean queries definable as the complement of a CSP. Similarly (ALC,AQ) extended with the uni-\nversal role captures the query language that consists of all unary queries definable as the complement of a generalized CSP, which is given by a finite collection of structures enriched with a constant symbol. We then proceed to transfer results from the CSP literature to the ontology-mediated query languages (ALC, BAQ) and (ALC, AQ). First we immediately obtain that the existence of a PTIME/CONP dichotomy for these ontology-mediated query languages is equivalent to the Feder-Vardi conjecture. Then we show that query containment is not only decidable (as we could already conclude from the connection with coMMSNP described in Section 4), but, in fact, NEXPTIME-complete. Finally, taking advantage of recent results for CSPs [35, 26, 13], we are able to show that FO-rewritability and datalog-rewritability, as properties of ontology-mediated queries, are decidable and NEXPTIMEcomplete for (ALC, AQ) and (ALC,BAQ).\nThe results in Sections 4 and 5 just summarized are actually proved not only forALC, but also for several of its extensions. This relies on the equivalences between DL-based OBDA-languages established in Section 3.\nRelated Work A connection between query answering in DLs and the negation-free fragment of disjunctive datalog was first discovered and utilized in the influential [39, 29], see also [44]. This research is concerned with answer-preserving translations of ontology-mediated queries into disjunctive datalog. In contrast to the current paper, it does not consider the expressive power of ontology-mediated queries, nor their descriptive complexity. A connection between DL-based OBDA and CSPs was first found and exploited in [36], in a setup that is different from the one studied in this paper. In particular, instead of focusing on ontology-mediated queries that consist of a data schema, an ontology, and a database query, [36] concentrates on ontologies while quantifying universally over all database queries and without fixing a data schema. It establishes links to the Feder-Vardi conjecture that are incomparable to the ones found in this paper, and does not consider the expressive power and descriptive complexity of queries used in OBDA."
    }, {
      "heading" : "2. PRELIMINARIES",
      "text" : "Schemas, Instances, and Queries. A schema is a finite collection S = (S1, . . . , Sk) of relation symbols with associated arity. A fact over S is an expression of the form S(a1, . . . , an) where S ∈ S is an n-ary relation symbol, and a1, . . . , an are elements of some fixed, countably infinite set const of constants. An instance D over S is a finite set of facts over S. The active domain adom(D) of D is the set of all constants that occur in the facts of D. We will frequently use boldface notation for tuples, such as in a = (a1, . . . , an), and we denote by () the empty tuple.\nA query over S is semantically defined as a mapping q that associates with every instance D over S a set of answers q(D) ⊆ adom(D)n, where n ≥ 0 is the arity of q. If n = 0, then we say that q is a Boolean query, and we write q(D) = 1 if () ∈ q(D) and q(D) = 0 otherwise.\nA prominent way of specifying queries is by means of first-order logic (FO). Specifically, each schema S and domain-independent FO-formula ϕ(x1, . . . , xn) that uses only relation names from S (and, possibly, equality) give rise to the n-ary query qϕ,S, defined by setting for all S-instances D,\nqϕ,S(D) = {(a1, . . . , an) ∈ adom(D)n | D |= ϕ[a1, . . . , an]}.\nTo simplify exposition, we assume that FO-queries do not contain constants. We use FOQ to denote the set of all first-order queries, as defined above. Similarly, we use CQ and UCQ to refer to the class of conjunctive queries and unions of conjunctive queries, defined\nas usual and allowing the use of equality. AQ denotes the set of atomic queries, which are of the formA(x) withA a unary relation symbol. Each of these is called a query language, which is defined abstractly as a set of queries. Besides FOQ, CQ, UCQ, and AQ, we consider various other query languages introduced later, including ontology-mediated ones and variants of datalog.\nTwo queries q1 and q2 over S are equivalent, written q1 ≡ q2, if for every S-instance D, we have q1(D) = q2(D). We say that query language Q2 is at least as expressive as query language Q1, written Q1 Q2, if for every query q1 ∈ Q1 over some schema S, there is a query q2 ∈ Q2 over S with q1 ≡ q2. Q1 andQ2 have the same expressive power ifQ1 Q2 Q1. Ontology-Mediated Queries. We introduce the fundamentals of ontology-based data access. An ontology language L is a fragment of first-order logic (i.e., a set of FO sentences), and an L-ontology O is a finite set of sentences from L. We introduce various ontology languages throughout the paper, including descriptions logics and the guarded fragment.\nAn ontology-mediated query over a schema S is a triple (S,O, q), where O is an ontology and q a query over S ∪ sig(O), with sig(O) the set of relation symbols used in O. Here, we call S the data schema. Note that the ontology can introduce symbols that are not in the data schema. As explained in the introduction, this allows the ontology to enrich the schema of the query q. Of course, we do not require that every relation of the data schema needs to occur in the ontology. We have explicitly included S in the specification of the ontology-mediated query to emphasize that the ontology-mediated query is interpreted as a query over S.\nThe semantics of an ontology-mediated query is given in terms of certain answers, defined next. A finite relational structure over a schema S is a pair B = (dom,D) where dom is a non-empty finite set called the domain of B and D is an instance over S with adom(D) ⊆ dom. When S is understood, we use Mod(O) to denote the set of all finite relational structures B over S ∪ sig(O) such that B |= O. Let (S,O, q) be an ontology-mediated query with q of arity n. The certain answers to q on an S-instance D given O is the set certq,O(D) of tuples a ∈ adom(D)n such that for all (dom,D′) ∈ Mod(O) with D ⊆ D′ (that is, all models of O that extend D), we have a ∈ q(D′).\nNote that all ontology languages considered in this paper enjoy finite controllability, meaning that finite relational structures can be replaced with unrestricted ones without changing the certain answers to unions of conjunctive queries [6, 7].\nEvery ontology-mediated query Q = (S,O, q) can be semantically interpreted as a query qQ over S by setting qQ(D) = certq,O(D) for all S-instances D. Taking this view one step further, each choice of an ontology language L and query languageQ gives rise to a query language, denoted (L,Q), defined as the set of queries q(S,O,q) with S a schema, O an L-ontology, and q ∈ Q a query over S∪ sig(O). We refer to such query languages (L,Q) as ontology-mediated query languages (or, OBDA languages).\nExample 1 The left-hand side of Table 1 shows an ontology O that is formulated in the guarded fragment of FO. Consider the ontology-mediated query (S,O, q) with data schema and query\nS = {ErythemaMigrans, LymeDisease, HereditaryPredisposition, finding, diagnosis, parent}\nq(x) = ∃y( diagnosis(x, y) ∧ BacterialInfection(y) ).\nFor the instance D over S that consists of the facts\nfinding(pat1, jan12find1) ErythemaMigrans(jan12find1)\ndiagnosis(pat2,may7diag2) Listeriosis(may7diag2)\nwe have certq,O(D) = {pat1, pat2}.\nDescription Logics for Specifying Ontologies. In description logic, schemas are generally restricted to relations of arity one and two, called concept names and role names, respectively. For brevity, we speak of binary schemas. We briefly review the basic description logic ALC. Relevant extensions of ALC will be introduced later on in the paper.\nAn ALC-concept is formed according to the syntax rule\nC,D ::= A | > | ⊥ | ¬C | C uD | C tD | ∃R.C | ∀R.C\nwhere A ranges over concept names and R over role names. An ALC-ontology O is a finite set of concept inclusions C v D, with C and D ALC-concepts. We define the semantics of ALCconcepts by translation to FO-formulas with one free variable, as shown in Table 2. An ALC-ontology O then translates into the set of FO-sentences O∗ = {∀x.(C∗(x) → D∗(x)) | C v D ∈ O}. On the right-hand side of Table 1, we show theALC-version of the guarded fragment ontology displayed on the left-hand side. Note that, although the translation is equivalence-preserving in this case, in general, the guarded fragment is a more expressive ontology language than ALC. Throughout the paper, we do not explicitly distinguish between a DL ontology and its translation into FO.\nWe remark that, from a DL perspective, the above definitions of instances and certain answers correspond to making the standard name assumption (SNA) in ABoxes, which in particular implies the unique name assumption. We make the SNA only to facilitate uniform presentation; the SNA is inessential for the results presented in this paper.\nExample 2 Let O and S be as in Example 1. For q1(x) = BacterialInfection(x), the ontology-mediated query (S,O, q1) is equivalent to the union of conjunctive queries LymeDisease(x) ∨ Listeriosis(x). For q2(x) = HereditaryDisposition(x), the ontology-mediated query (S,O, q2) is equivalent to the query defined by the datalog program\nP (x) ← HereditaryDisposition(x) goal(x) ← P (x) P (x) ← parent(y, x) ∧ P (y)\nbut not to any first-order query."
    }, {
      "heading" : "3. OBDA AND DISJUNCTIVE DATALOG",
      "text" : "We show that for many OBDA languages, there is a natural fragment of disjunctive datalog with exactly the same expressive power.\nA disjunctive datalog rule ρ has the form\nS1(x1) ∨ · · · ∨ Sm(xm)← R1(y1) ∧ · · · ∧Rn(yn)\nwithm ≥ 0 and n > 0. We refer to S1(x1)∨· · ·∨Sm(xm) as the head of ρ, and to R1(y1) ∧ . . . ∧ Rn(yn) as the body of ρ. Every variable that occurs in the head of a rule ρ is required to also occur in the body of ρ. Empty rule heads are denoted ⊥. A disjunctive datalog (DDlog) program Π is a finite set of disjunctive datalog rules with a selected goal predicate goal that does not occur in rule bodies and only in goal rules of the form goal(x) ← R1(x1) ∧ · · · ∧ Rn(xn). The arity of Π is the arity of the goal relation. Relation symbols that occur in the head of at least one rule of Π are intensional (IDB) predicates of Π, and all remaining relation symbols in Π are extensional (EDB) predicates.\nEvery DDlog program Π of arity n naturally defines an n-ary query qΠ over the schema S that consists of the EDB predicates of Π: for every instance D over S, we have\nqΠ(D) = {a ∈ adom(D)n | goal(a) ∈ D′\nfor all D′ ∈ Mod(Π) with D ⊆ D′}.\nHere, Mod(Π) denotes the set of all instances over S′ that satisfy all rules in Π, with S′ the set of all IDB and EDB predicates in Π. Note that the DDlog programs considered in this paper are negation-free. Restricted to this fragment, there is no difference between the different semantics of DDlog studied e.g. in [21].\nWe use adom(x) in rule bodies as a shorthand for “x is in the active domain of the EDB predicates”. Specifically, whenever we use adom in a rule of a DDlog program Π, we assume that adom is an IDB predicate and that the program Π includes all rules of the form adom(x) ← R(x) where R is an EDB predicate of Π and x is a tuple of distinct variables that includes x.\nA monadic disjunctive datalog (MDDlog) program is a DDlog program in which all IDB predicates with the possible exception of goal are monadic. We use MDDlog to denote the query language that consists of all queries defined by an MDDlog program."
    }, {
      "heading" : "3.1 Ontologies Specified in Description Logics",
      "text" : "We show that (ALC,UCQ) has the same expressive power as MDDlog and identify a fragment of MDDlog that has the same expressive power as (ALC,AQ). In addition, we consider the extensions of ALC with inverse roles, role hierarchies, transitive roles, and the universal role, which we also relate to MDDlog and its fragments. To match the syntax of ALC and its extensions, we generally assume schemas to be binary throughout this section.1\n(ALC,UCQ) and MDDlog. The first main result of this section is Theorem 1 below, which relates (ALC,UCQ) and MDDlog.\nTheorem 1 (ALC,UCQ) and MDDlog have the same expressive power.\n1In fact, this assumption is inessential for Theorems 1 and 3 (which speak about UCQs), but required for Theorems 2, 4, and 5 (which speak about AQs) to hold.\nProof. (sketch) We start with giving some intuitions about answering (ALC,UCQ) queries which guide our translation of such queries into MDDlog programs. Recall that the definition of certain answers to an ontology-mediated query on an instance D involves a quantification over all models of O which extend D. It turns out that in the case of (ALC,UCQ) queries (and, as we will see later, more generally for (UNFO,UCQ) queries), it suffices to consider a particular type of extensions of D that we term pointwise extensions. Intuitively, such an extension of D corresponds to attaching domain-disjoint structures to the elements of D. Formally, for instances D ⊆ D′, we call D′ a pointwise extension of D if D′ \\ D is the union of instances {D′a | a ∈ adom(D)} such that adom(D′a) ∩ adom(D) ⊆ {a} and adom(D′a) ∩ adom(D′b) = ∅ for a 6= b. The fact that we need only consider models of O which are pointwise extensions of D is helpful because it constrains the ways in which a CQ can be satisfied. Specifically, every homomorphism h from q to D′ gives rise to a query q′ obtained from q by identifying all variables that h sends to the same element, and to a decomposition of q′ into a collection of components q′0, . . . , q′k where the ‘core component’ q′0 comprises all atoms of q′ whose variables h sends to elements of D and for each D′a in the image of h, there is a ‘non-core component’ q′i, 1 ≤ i ≤ k, such that q′i comprises all atoms of q′ whose variables h sends to elements of D′a. Note that the non-core components are pairwise variable-disjoint and share at most one variable with the core component.\nWe now detail the translation from an ontology-mediated query (S,O, q) ∈ (ALC,UCQ) into an equivalent MDDlog program. Let sub(O) be the set of subconcepts (that is, syntactic subexpressions) of concepts that occur in O, and let cl(O, q) denote the union of sub(O) and the set of all CQs that have at most one free variable, use only symbols from q, and whose number of atoms is bounded by the number of atoms of q. A type (for O and q) is a subset of cl(O, q). The CQs present in cl(O, q) include all potential ‘noncore components’ from the intuitive explanation above. The free variable of a CQ in cl(O, q) (if any) represents the overlap between the core component and the non-core component.\nWe introduce a fresh unary relation symbol Pτ for every type τ , and we denote by S′ the schema that extends S with these additional symbols. In the MDDlog program that we aim to construct, the relation symbols Pτ will be used as IDB relations, and the symbols from S will be the EBD relations.\nWe will say that a relational structure B over S′ ∪ sig(O) is type-coherent if Pτ (d) ∈ B just in the case that\nτ = {q′ ∈ cl(O, q) | q′ Boolean ,B |= q′} ∪ {C ∈ cl(O, q) | C unary,B |= C[d]}.\nSet k equal to the maximum of 2 and the width of q, that is, the number of variables that occur in q. By a diagram, we mean a conjunction δ(x1, . . . , xn) of atomic formulas over the schema S′, with n ≤ k variables. A diagram δ(x) is realizable if there exists a type-coherent B ∈ Mod(O) that satisfies ∃xδ(x). A diagram δ(x) implies q(x′), with x′ a sequence of variables from x, if every type-coherent B ∈ Mod(O) that satisfies δ(x) under some variable assignment, satisfies q(x′) under the same assignment.\nThe desired MDDlog program Π consists of the following collections of rules:∨\nτ⊆cl(O,q) Pτ (x)← adom(x) ⊥ ← δ(x) for all non-realizable diagrams δ(x)\ngoal(x′)← δ(x) for all diagrams δ(x) that imply q(x′)\nIntuitively, these rules ‘guess’ a pointwise extension D′ of D. Specifically, the types Pτ guessed in the first line determine which\nsubconcepts of O are made true at each element of D′. Since MDDlog does not support existential quantifiers, the D′a parts of D′ cannot be guessed explicitly. Instead, the CQs included in the guessed types determine those non-core component queries that matched in the D′a parts. The second line ensures coherence of the guesses and the last line guarantees that q has the required match in D′. It is proved in the full version of this paper that the MDDlog query qΠ is indeed equivalent to (S,O, q).\nFor the converse direction, let Π be an MDDlog program. For each unary IDB relation A of Π, we introduce two fresh unary relations, denoted by A and Ā. The ontology O enforces that Ā represents the complement of A, that is, it consists of all inclusions of the form\n> v (A t Ā) u ¬(A u Ā). Let q be the union of (i) all conjunctive queries that constitute the body of a goal rule, as well as (ii) all conjunctive queries obtained from a non-goal rule of the form\nA1(x1) ∨ · · · ∨Am(xm)← R1(y1) ∧ · · · ∧Rn(yn)\nby taking the conjunctive query\nĀ1(x1) ∧ · · · ∧ Ām(xm) ∧R1(y1) ∧ · · · ∧Rn(yn).\nIt can be shown that the ontology-mediated query (S,O, q), where S is the schema that consists of the EDB relations of Π, is equivalent to the query defined by Π. o\nALC with Atomic Queries. We characterize (ALC,AQ) by a fragment of MDDlog. This query language has the same expressive power as the OBDA language (ALC,ConQ), where ConQ denotes the set of all ALC-concept queries, that is, queries C(x) with C a (possibly compound) ALC-concept. Specifically, each query (S,O, q) ∈ (ALC,ConQ) with q = C(x) can be expressed as a query (S,O′, A(x)) ∈ (ALC,AQ) where A is a fresh concept name (that is, it does not occur in S ∪ sig(O)) and O′ = O ∪ {C v A}. As a consequence, (ALC,AQ) also has the same expressive power as (ALC,TCQ), where TCQ is the set of all CQs that take the form of a directed tree with a single answer variable at the root.\nEach disjunctive datalog rule can be associated with an undirected graph whose nodes are the variables that occur in the rule and whose edges reflect co-occurrence of two variables in an atom in the rule body. We say that a rule is connected if its graph is connected, and that a DDlog program is connected if all its rules are connected. An MDDlog program is simple if each rule contains at most one atom R(x) with R an EDB relation; additionally, we require that, in this atom, every variable occurs at most once.\nTheorem 2 (ALC,AQ) has the same expressive power as unary connected simple MDDlog.\nProof. (sketch) The translation from (ALC,AQ) to unary connected simple MDDlog queries is a modified version of the translation given in the proof of Theorem 1. Assume that (S,O, q) with q = A(x) is given. We now take types to be subsets of sub(O) and then define diagrams exactly as before (with k = 2). The MDDlog program Π consists of the following rules:∨\nτ⊆sub(O) Pτ (x)← adom(x) ⊥ ← δ(x) for all non-realizable diagrams δ(x)\nof the form Pτ1(x) ∧ Pτ2(x), Pτ (x) ∧A(x), or Pτ1(x1) ∧ S(x1, x2) ∧ Pτ2(x2)\ngoal(x)← Pτ (x) for all Pτ with A ∈ Pτ\nClearly, Π is unary, connected, and simple. Equivalence of the queries (S,O, q) and qΠ is proved in the full version of this paper.\nConversely, let Π be a unary connected simple MDDlog program. It is easy to rewrite each rule of Π into an equivalent ALCconcept inclusion, where goal is now regarded as a concept name. For example, goal(x) ← R(x, y) is rewritten into ∃R.> v goal and P1(x) ∨ P2(y) ← R(x, y) ∧ A(x) ∧ B(y) is rewritten into A u ∃R.(B u ¬P2) v P1. Let O be the resulting ontology and let q = goal(x). Then the query qΠ is equivalent to the query (S,O, q), where S consists of the EDB relations in Π. o\nNote that the connectedness condition is required since one cannot express MDDlog rules such as goal(x) ← adom(x) ∧ A(y) with y 6= x in (ALC,AQ). Multiple variable occurrences in EDB relations have to be excluded because programs such as goal(x) ← A(x), ⊥ ← R(x, x) (return all elements in A if the instance contains no reflexive R-edge, and return the active domain otherwise) also cannot be expressed in (ALC,AQ). Extensions of ALC. We identify several standard extensions of (ALC,UCQ) and (ALC,AQ) that have the same expressive power, and some that do not. We introduce the relevant extensions only briefly and refer to [4] for more details. ALCI is the extension ofALC in which one can state that a role name R is the inverse of a role name S, that is, ∀xy(R(x, y) ↔ S(y, x)); ALCH is the extension in which one can state that a role name R is included in a role name S, that is, ∀xy(R(x, y)→ S(x, y)); S is the extension ofALC in which one can require some roles names to be interpreted as transitive relations; ALCF is the extension in which one can state that some role names are interpreted as partial functions; and ALCU is the extension with the universal role U , interpreted as dom×dom in any relational structure B with domain dom. Note that U should be regarded as a logical symbol and is not a member of any schema. All these means of expressivity are included in the OWL2 DL profile of the W3Cstandardized ontology language OWL2 [47].\nWe use the usual naming scheme to denote combinations of these extensions, for example ALCHI for the union of ALCH andALCI and SHI for the union of S andALCHI. The following result summarizes the expressive power of extensions of ALC.\nTheorem 3 1. (ALCHIU ,UCQ) has the same expressive power as MDDlog\nand as (ALC,UCQ). 2. (S,UCQ) and (ALCF ,UCQ) are strictly more expressive than\n(ALC,UCQ).\nProof. (sketch) In Point 1, we start with (ALCIU ,UCQ), for which the result follows from Theorem 6 in Section 3.2 since ALCIU is a fragment of UNFO. Role inclusions ∀xy(R(x, y) → S(x, y)) do not add expressive power since they can be simulated by adding to the ontology the inclusions ∃R.C v ∃S.C for all C ∈ sub(O), and replacing every atom S(x, y) in the UCQ byR(x, y)∨S(x, y).\nFor Point 2, we separate (S,UCQ) from (ALC,UCQ) by showing that the following ontology-mediated query (S1,O1, q1) cannot be expressed in (ALC,UCQ): S1 consists of two role names R and S, O1 states that these role names are both transitive, and q1 = ∃xy(R(x, y) ∧ S(x, y)). For (ALCF ,UCQ), we show that (S2,O2, q2) cannot be expressed in (ALC,UCQ), where S2 consists of role name R and concept name A,O2 states that R is functional, and q2 = A(x). Detailed proofs are provided in the full version of this paper. They rely on a characterization of (ALC,UCQ) in terms of colored forbidden patterns [38], which is a by-product\nof the connection between (ALC,UCQ) and MMSNP that will be established in Section 4. o\nThe next result is interesting when contrasted with Point 2 of Theorem 3: when (ALC,UCQ) is replaced with (ALC,AQ), then the addition of transitive roles no longer increases the expressive power.\nTheorem 4 (ALC,AQ) has the same expressive power as (SHI,AQ).\nProof. (sketch) The proof of Theorem 2 given above actually shows that unary connected simple MDDlog is at least as expressive as (ALCI,AQ). Thus, (ALC,AQ) has the same expressive power as (ALCI,AQ). Now it is folklore that in ALCI transitive roles can be replaced by certain concept inclusions without changing the certain answers to atomic queries. This can be done similarly to the elimination of role inclusions in the proof above, see [39, 45]. Thus (ALCI,AQ) has the same expressive power as (SHI,AQ), and the result follows. o\nIt follows from [45] that this observation can be extended to all complex role inclusions that are admitted in the description logic SROIQ. In contrast, the addition of the universal role on the side of the OBDA query language extends the expressive power of (ALC,AQ). Namely, it corresponds, on the MDDlog side, to dropping the requirement that rule bodies must be connected. For example, the MDDlog query goal(x)← adom(x)∧A(y) can then be expressed using the ontology O = {∃U.A v goal} and the AQ goal(x).\nTheorem 5 (ALCU ,AQ) and (SHIU ,AQ) both have the same expressive power as unary simple MDDlog.\nWe close this section with a brief remark about Boolean atomic queries (BAQs), that is, queries of the form ∃x.A(x), where A is a unary relation symbol. Such queries will be considered in Section 5. It is possible to establish modified versions of Theorems 2 to Theorem 5 above in which AQs are replaced by BAQs and unary goal predicates by 0-ary goal-predicate, respectively."
    }, {
      "heading" : "3.2 Ontologies Specified in First-Order Logic",
      "text" : "Ontologies formulated in description logic are not able to speak about relation symbols of arity greater than two.2 To overcome this restriction, we consider the guarded fragment of first-order logic and the unary-negation fragment of first-order logic [6, 46]. Both generalize the description logic ALC in different ways. We also consider their natural common generalization, the guarded negation fragment of first-order logic [7]. Our results from the previous subsection turn out to generalize to all these fragments. We start by considering the unary negation fragment.\nThe unary-negation fragment of first-order logic (UNFO) [46] is the fragment of first-order logic that consists of those formulas that are generated from atomic formulas, including equality, using conjunction, disjunction, existential quantification, and unary negation, that is, negation applied to a formula with at most one free variable. Thus, for example, ¬∃xyR(x, y) belongs to UNFO, whereas ∃xy¬R(x, y) does not. It is easy to show that everyALCTBox is equivalent to a UNFO sentence.\n2There are actually a few DLs that can handle relations of unrestricted arity, such as those presented in [19]. We do not consider such DLs in this paper, but remark that large fragments of them can be translated into UNFO.\nTheorem 6 (UNFO,UCQ) has the same expressive power as MDDlog.\nProof. (sketch) The translation from MDDlog to (UNFO,UCQ) is given by Theorem 1. Here, we provide the translation from (UNFO,UCQ) to MDDlog. Let Q = (S,O, q) ∈ (UNFO,UCQ) be given. We assume that O is a single UNFO sentence that is in the normal form generated by the following grammar:\nϕ(x) ::= > | ¬ϕ(x) | ∃y(ψ1(x, y) ∧ · · · ∧ ψn(x, y))\nwhere each ψi is either a relational atom or a formula with at most one free variable generated by the same grammar, and the free variables in ψi are among x,y. Note that no equality is used and that all generated formulas have at most one free variable. Easy syntactic manipulations show that every UNFO-formula with at most one free variable is equivalent to a disjunction of formulas generated by the above grammar. In the case of O, we may furthermore assume that it is a single such sentence, rather than a disjunction, because certq,O1∨O2(D) is the intersection of certq,O1(D) and certq,O2(D), and MDDlog is closed under taking intersections of queries.\nLet sub(O) be the set of all subformulas of O with at most one free variable z (we apply a one-to-one renaming of variables as needed to ensure that each formula in sub(O) with a free variable has the same free variable z). Let k be the maximum of the number of variables in O and the number of variables in q. We denote by clk(O) the set of all formulas ϕ(x) of the form\n∃y(ψ1(x, y) ∧ · · · ∧ ψn(x, y))\nwith y = (y1, . . . , ym),m ≤ k, where each ψi is either a relational atom that uses a symbol from q or is of the form χ(x) or χ(yi), for χ(z) ∈ sub(O). Note that, as in the proof of Theorem 1, clk(O) contains all CQs that use only symbols from q and whose size is bounded by the size of q. A type τ is a subset of clk(O); the set of all types is denoted type(O).\nWe introduce a fresh unary relation symbol Pτ for each type τ , and we denote by S′ the schema that extends S with these additional relations. As before, we call a structure B over S′ ∪ sig(O) type-coherent if for all types τ and elements d in the domain of B, we have Pτ (d) ∈ B just in the case that τ is the (unique) type realized at d in B. Diagrams, realizability, and “implying q” are defined as in the proof of Theorem 1. It follows from [46] that it is decidable whether a diagram implies a query, and whether a diagram is realizable. The MDDlog program Π is defined as in the proof of Theorem 1, except that now in the first rule, τ ranges over types in type(O). In the full version of this paper, we prove that the resulting MDDlog query qΠ is equivalent to Q. o\nNext, we consider the guarded fragment of first-order logic (GF). It comprises all formulas built up from atomic formulas using the Boolean connectives and guarded quantification of the form ∃x(α∧ϕ) and ∀x(α→ ϕ), where, in both cases, α is an atomic formula (a “guard”) that contains all free variables of ϕ. To simplify the presentation of the results, we consider here the equality-free version of the guarded fragment. We do allow one special case of equality, namely the use of trivial equalities of the form x = x as guards, which is equivalent to allowing unguarded quantifiers applied to formulas with at most one free variable. This restricted form of equality is sufficient to translate every ALC TBox into an equivalent sentence of GF.\nIt turns out that the OBDA language (GF, UCQ) is strictly more expressive than MDDlog.\nProposition 1 The Boolean query\n(†) there are a1, . . . , an, b, for some n ≥ 2, such that A(a1), B(an), and P (ai, b, ai+1) for all 1 ≤ i < n\nis definable in (GF,UCQ) and not in MDDlog.\nProof. Let S consist of unary predicates A,B and a ternary predicate P , and let Q be the S-query defined by (†). It is easy to check thatQ can be expressed by the (GF,UCQ) query qS,O,∃xU(x) where\nO = ∀xyz (P (x, z, y)→ (A(x)→ R(z, x))) ∧ ∀xyz (P (x, z, y)→ (R(z, x)→ R(z, y))) ∧ ∀xyz (R(x, y)→ (B(y)→ U(y)))\nWe show in the full version of this paper that Q is not expressible in MDDlog using the colored forbidden patterns characterization mentioned in the proof sketch of Theorem 3. o\nAs fragments of first-order logic, the unary-negation fragment and the guarded fragment are incomparable in expressive power. They have a common generalization, which is known as the guarded-negation fragment (GNFO) [8]. This fragment is defined in the same way as UNFO, except that, besides unary negation, we allow guarded negation of the form α ∧ ¬ϕ, where the guard α is an atomic formula that contains all the variables of ϕ. Again, for simplicity, we consider here the equality-free version of the language, except that we allow the use of trivial equalities of the form x = x as guards. As we will see, for the purpose of OBDA, GNFO is no more powerful than GF. Specifically, (GF, UCQ) and (GNFO, UCQ) are expressively equivalent to a natural generalization of MDDlog, namely frontier-guarded DDlog. Recall that a datalog rule is guarded if its body includes an atom that contains all variables which occur in the rule [27]. A weaker notion of guardedness, which we call here frontier-guardedness, inspired by [5, 7], requires that, for each atom α in the head of the rule, there is an atom β in the rule body such that all variables that occur in α occur also in β. We define a frontier-guarded DDlog query to be a query defined by a DDlog program in which every rule is frontierguarded. Observe that frontier-guarded DDlog subsumes MDDlog.\nTheorem 7 (GF,UCQ) and (GNFO,UCQ) have the same expressive power as frontier-guarded DDlog.\nTheorem 7 is proved in the full version of this paper via translations from (GNFO,UCQ) to frontier-guarded DDlog and back that are along the same lines as the translations from (UNFO,UCQ) to MDDlog and back. In addition, we use a result from [8] to obtain a translation from (GNFO,UCQ) to (GF,UCQ)."
    }, {
      "heading" : "4. OBDA AND MMSNP",
      "text" : "We show that MDDlog captures coMMSNP and thus, by the results obtained in the previous section, the same is true for many OBDA languages based on UCQs. We then use this connection to transfer results from MMSNP to OBDA languages with UCQs, linking the data complexity of these languages to the Feder-Vardi conjecture and establishing decidability of query containment. We also propose GMSNP, an extension of MMSNP inspired by frontier guarded DDlog, and show that (GF,UCQ) and (GNFO,UCQ) capture coGMSNP, and that GMSNP has the same expressive power as a previously proposed extension of MMSNP called MMSNP2.\nAn MMSNP formula over schema S has the form ∃X1 · · · ∃Xn∀x1 · · · ∀xmϕ with X1, . . . , Xn monadic secondorder (SO) variables, x1, . . . , xm FO-variables, and ϕ a conjunction of quantifier-free formulas of the form\nψ = α1 ∧ · · · ∧ αn → β1 ∨ · · · ∨ βm with n,m ≥ 0,\nwhere each αi is of the formXi(x),R(x) (withR ∈ S), or x = y, and each βi is of the form Xi(x). In order to use MMSNP as a query language, and in contrast to the standard definition, we admit free FO-variables and speak of sentences to refer to MMSNP formulas without free variables. To connect with the query languages studied thus far, we are interested in queries obtained by the complements of MMSNP formulas: each MMSNP formula Φ over schema S with n free variables gives rise to a query\nqΦ,S(D) = {a ∈ adom(D)n | (adom(D),D) 6|= Φ[a]}\nwhere we set (adom(D),D) |= Φ to true when D is the empty instance (that is, adom(D) = ∅) and Φ is a sentence. We observe that the resulting query language coMMSNP has the same expressive power as MDDlog.\nProposition 2 coMMSNP and MDDlog have the same expressive power.\nProof. Let Φ = ∃X1 · · · ∃Xn∀x1 · · · ∀xmϕ be an MMSNP formula with free variables y1, . . . , yk, and let qΦ,S ∈ coMMSNP be the corresponding query. We can assume w.l.o.g. that all implications ψ = α1∧· · ·∧αn → β1∨· · ·∨βm in ϕ satisfy the following properties: (i) n > 0 and, (ii) each variable that occurs in a βi atom also occurs in an αi atom. In fact, we can achieve both (i) and (ii) by replacing violating implications ψ with the set of implications ψ′ that can be obtained from ψ by adding, for each variable x that occurs only in the head of ψ, an atom S(x) where S is a predicate that occurs in Φ and x is a tuple of variables that contains x once and otherwise only fresh variables that do not occur in Φ. Define an MDDlog program ΠΦ that consists of all implications in ϕ whose head is not ⊥ plus a rule\ngoal(y1, . . . , yk)← ϑ ∧ adom(y1) ∧ · · · ∧ adom(yk)\nfor each implication ϑ → ⊥ in ϕ. It can be proved that qΦ,S = qΠΦ,S for all schemas S. Finally, it is straightforward to remove the equalities from the rule bodies in ΠΦ.\nConversely, let Π be a k-ary MDDlog program and assume w.l.o.g. that each rule uses a disjoint set of variables. Reserve fresh variables y1, . . . , yk as free variables for the desired MMSNP formula, and let X1, . . . , Xn be the IDB predicates in Π and x1, . . . , xm the FO-variables in Π that do not occur in the goal predicate. Set ΦΠ = ∃X1 · · · ∃Xn∀x1 · · · ∀xmϕ where ϕ is the conjunction of all non-goal rules in Π plus the implication ϑ′ → ⊥ for each rule goal(x) ← ϑ in Π. Here, ϑ′ is obtained from ϑ by replacing each variable x ∈ x whose left-most occurrence in the rule head is in the i-th position with yi, and then conjunctively adding yi = yj whenever the i-th and j-th position in the rule head have the same variable. It can be proved that qΠ,S = qΦΠ,S for all schemas S. o\nThus, the characterizations of OBDA languages in terms of MDDlog provided in Section 3 also establish the descriptive complexity of these languages by identifying them with (the complement of) MMSNP. Furthermore, Proposition 2 allow us to transfer results from MMSNP to OBDA. We start by considering the data complexity of the query evaluation problem: for a query q, the evaluation problem is to decide, given an instance D and a tuple a of elements from D, whether a ∈ q(D). Our first result is that the Feder-Vardi dichotomy conjecture for CSPs is true if and only if there is a dichotomy between PTIME and CONP for query evaluation in (ALC,UCQ), and the same is true for several other OBDA languages. For brevity, we say that a query language has a dichotomy between PTIME and CONP, referring only implicitly to the evaluation problem.\nThe proof of the following theorem relies on Proposition 2 and Theorems 1, 3, and 6. It also exploits the fact that the Feder-Vardi dichotomy conjecture can equivalently be stated for MMSNP sentences [24, 33]. Some technical development is needed to deal with the presence of free variables. Details are in the full version of this paper.\nTheorem 8 (ALC,UCQ) has a dichotomy between PTIME and CONP iff the Feder-Vardi conjecture holds. The same is true for (ALCHIU ,UCQ) and (UNFO,UCQ).\nRecall that (ALCF ,UCQ) and (S,UCQ) are two extensions of (ALC,UCQ) that were identified in Section 3 to be more expressive than (ALC,UCQ) itself. It was already proved in [36] (Theorem 27) that, compared to ontology-mediated queries based on ALC, the functional roles of ALCF dramatically increase the computational power. This is true even for atomic queries.\nTheorem 9 ([36]) For every NP-Turing machine M , there is a query q in (ALCF ,AQ) such that the complement of the word problem of M has the same complexity as evaluating q, up to polynomial-time reductions. Consequently, (ALCF ,AQ) does not have a dichotomy between PTIME and CONP (unless PTIME = NP).\nWe leave it as an open problem to analyze the computational power of (S,UCQ).\nThere are other interesting results that can be transferred from MMSNP to OBDA. Here, we consider query containment. Specifically, the following general containment problem was proposed in [10] as a powerful tool for OBDA: given ontology-mediated queries (S,Oi, qi), i ∈ {1, 2}, decide whether for all S-instances D, we have certq1,O1(D) ⊆ certq2,O2(D).3 Applications include the optimization of ontology-mediated queries and managing the effects on query answering of replacing an ontology with a new, updated version. In terms of OBDA languages such as (ALC,UCQ), the above problem corresponds to query containment in the standard sense: an S-query q1 is contained in an S-query q2, written q1 ⊆ q2, if for every S-instance D, we have q1(D) ⊆ q2(D). Note that there are also less general (and computationally simpler) notions of query containment in OBDA that do not fix the data schema [19].\nIt was proved in [24] that containment of MMSNP sentences is decidable. We thus obtain the following result for OBDA languages.\nTheorem 10 Query containment is decidable for the OBDA languages (ALC,UCQ), (ALCHIU ,UCQ), and (UNFO,UCQ).\nNote that this result is considerably stronger than those in [10], which considered only containment of ontology-mediated queries (S,O, q) with q an atomic query since already this basic case turned out to be technically intricate. The treatment of CQs and UCQs was left open, including all cases stated in Theorem 10.\nWe now consider OBDA languages based on the guarded fragment and GNFO. By Proposition 1, (GF,UCQ) and (GNFO,UCQ) are strictly more expressive than MDDlog and we cannot use Proposition 2 to relate these query languages to the Feder-Vardi conjecture. Theorem 7 suggests that it would be useful to have 3In fact, this definition is slightly different from the one used in [10]. There, containment is defined only over instances D that are consistent w.r.t. O1 and O2, i.e., where there is at least one finite S-structure (dom,D′) such that D ⊆ D′ and D′ ∈ Mod(Oi).\na generalization of MMSNP that is equivalent to frontier-guarded DDlog. Such a generalization is introduced next.\nA formula of guarded monotone strict NP (abbreviated GMSNP) has the form ∃X1 · · · ∃Xn∀x1 · · · ∀xmϕ with X1, . . . , Xn SO variables of any arity, x1, . . . , xn FO-variables, and ϕ a conjunction of formulas\nψ = α1 ∧ · · · ∧ αn → β1 ∨ · · · ∨ βm with n,m ≥ 0,\nwhere each αi is of the form Xi(x), R(x) (with R ∈ S), or x = y, and each βi is of the form Xi(x). Additionally, we require that for every head atom βi, there is a body atom αj such that αj contains all variables from βi. GMSNP gives rise to a query language coGMSNP in analogy with the definition of coMMSNP. It can be shown by a straightforward syntactic transformation that every MMSNP formula is equivalent to some GMSNP formula. Together with Proposition 1 and Theorem 7, this yields the second statement of the following lemma; the first statement can be proved similarly to Proposition 2.\nTheorem 11 coGMSNP has the same expressive power as frontier-guarded DDlog and is strictly more expressive than coMMSNP.\nAlthough defined in a different way, GMSNP is essentially the same logic as MMSNP2, which is studied in [37]. Specifically, MMSNP2 is the extension of MMSNP in which monadic SOvariables range over sets of domain elements and facts, and where atoms of the form X(R(x)) are allowed in place of atoms X(x) with X an SO-variable and R from the data schema S. Additionally, a guardedness condition is imposed, requiring that whenever an atom X(R(x)) occurs in a rule head, then the atom R(x) must occur in the rule body. Formally, the SO-variables Xi are interpreted in an instance D as sets π(Xi) ⊆ adom(D) ∪ D and D |=π X(R(x1, . . . , xn)) if R(π(x1), . . . , π(xn)) ∈ π(X). We observe the following.\nProposition 3 GMSNP and MMSNP2 have the same expressive power.\nDetails for the proofs of both Theorem 11 and Lemma 3 are in the full version of this paper. In [37], it was left as an open question whether MMSNP2 is more expressive than MMSNP, which is resolved by the results above.\nWe leave it as an interesting open question whether Theorem 8 can be extended to (GF,UCQ) and (GNFO,UCQ), that is, whether GMSNP (equivalently: MMSNP2) has a dichotomy between PTIME and NP if the Feder-Vardi conjecture holds. While this question is implicit already in [37], the results established in this paper underline its significance from a different perspective."
    }, {
      "heading" : "5. OBDA AND CSP",
      "text" : "We show that OBDA languages based on AQs capture CSPs (and generalizations thereof), and we transfer results from CSPs to OBDA languages. In comparison to the previous section, we obtain a richer set of results, and often even worst-case optimal decision procedures. Recall that each finite relational structure B over a schema S gives rise to a constraint satisfaction problem which is to decide, given a finite relational structure A over S, whether there is a homomorphism from A to B (written A → B). In this context, the relational structure B is also called the template of the CSP.\nCSPs give rise to a query language coCSP in the spirit of the query language coMMSNP introduced in the previous section. In\nits basic version, this language is Boolean and turns out to have exactly the same expressive power as (ALC,BAQ), where BAQ is the class of Boolean atomic queries. To also cover non-Boolean AQs, we consider two natural generalizations of CSPs. First, a generalized CSP is defined by a finite set F of templates, rather than only a single one [25]. The problem then consists in deciding, given an input structure A, whether there is a template B ∈ F such that A → B. Second, in a (generalized) CSP with constant symbols, both the template(s) and the input structure are endowed with constant symbols [23, 1]. To be more precise, let S be a schema and c = c1, . . . , cm a finite sequence of distinct constant symbols. A finite relational structure over S ∪ c has the form (A, d1, . . . , dm) with A a finite relational structure over A that, in addition, interprets the constant symbols ci by elements di of the domain dom of A, for 1 ≤ i ≤ m. Let (A,a) and (B,b) be finite relational structures over S ∪ c. A mapping h is a homomorphism from (A,a) to (B,b), written (A,a)→ (B,b), if it is a homomorphism from A to B and h(ai) = bi for 1 ≤ i ≤ m. A (generalized) CSP with constant symbols is then defined like a (generalized) CSP, based on this extended notion of homomorphism.\nWe now introduce the query languages obtained from the different versions of CSPs, where generalized CSPs with constant symbols constitute the most general case. Specifically, each finite set of templates F over S∪c with c = c1, . . . , cm gives rise to anm-ary query coCSP(F) that maps every S-instance D to\n{d ∈ adom(D)m |∀(B,b)∈ F : (D,d) 6→ (B,b)},\nwhere we view (D,d) as a finite relational structure whose domain is adom(D). The query language that consists of all such queries is called generalized coCSP with constant symbols. The fragment of this query language that is obtained by admitting only sets of templates F without constant symbols is called generalized coCSP, and the fragment induced by singleton sets F without constant symbols is called coCSP.\nExample 3 Selecting an illustrative fragment of Examples 1 and 2, let\nO = {∃parent.HereditaryDisposition v HereditaryDisposition} S = {HereditaryDisposition, parent}\nMoreover, let q2(x) = HereditaryDisposition(x) be the query from Example 2. To identify a query in coCSP with constant symbols that is equivalent to the ontology-mediated query (S,O, q2), let B be the following template:\nparent a b\nHereditaryDisposition\nparent parent\nIt can be shown that for all instances D over S and for all d ∈ adom(D), we have d ∈ certq2,O(D) iff (D, d) 6→ (B, a) and thus the query coCSP(B) is as required.\nThe following theorem summarizes the connections between OBDA languages with (Boolean) atomic queries, MDDlog, and CSPs. Note that we consider binary schemas only.\nTheorem 12 The following are lists of query languages that have the same expressive power:\n1. (ALCU ,AQ), (SHIU ,AQ), unary simple MDDlog, and generalized coCSP with one constant symbol;\n2. (ALC,AQ), (SHI,AQ), unary connected simple MDDlog, and generalized coCSPs with one constant symbol such that all templates are identical except for the interpretation of the constant symbol;\n3. (ALCU ,BAQ), (SHIU ,BAQ), Boolean simple MDDlog, and generalized coCSP;\n4. (ALC,BAQ), (SHI,BAQ), Boolean connected simple MDDlog, and coCSP.\nMoreover, given the ontology-mediated query or monadic datalog program, the correponding CSP template is of at most exponential size and can be constructed in time polynomial in the size of the template.\nProof. The equivalences between OBDA languages and fragments of MDDlog have been proved in Section 3. We give a proof of the remaining claim of Point 1, namely that (ALCU ,AQ) and generalized coCSP with one constant symbol are equally expressive. We extend the notation used in the proof of Theorem 1. For simplicity, throughout this proof we regard ∀R.C as an abbreviation for ¬∃R.¬C.\nLet Q = (S,O, A(x)) be an ontology-mediated query formulated in (ALCU ,AQ). A type forO is a set τ ⊆ sub(O) and tp(O) denotes the set of all types for O. We say that τ ∈ tp(O) is realizable if there is an A = (dom,D) ∈ Mod(O) and a d ∈ dom such that C ∈ τ iff A |= C∗[d] for all C ∈ sub(O). A set of types T ⊆ tp(O) is realizable in a Q-countermodel if there is an A ∈ Mod(O) that realizes exactly the types in T and such that A 6∈ τ for at least one τ ∈ T .\nLet C be the set of all T ⊆ tp(O) that are realizable in a Qcountermodel and maximal with this property. Note that the number of elements of C is bounded by the size of O since for any two distinct T1, T2 ∈ C, there must be a concept ∃U.D ∈ sub(O) such that ∃U.D ∈ τ for all τ ∈ T1 and ∃U.D 6∈ τ for all τ ∈ T2 or vice versa; otherwise, we can take the disjoint union of any structures A1,A2 which show that T1, T2 are realizable in a Q-countermodel to obtain Q-countermodel that realizes T1 ∪ T2. For R ∈ S, we call a pair (τ1, τ2) of types R-coherent if ∃R.C ∈ τ1 for every ∃R.C ∈ sub(O) such that C ∈ τ2.\nWith each T ∈ C, we associate the canonical S-structure BT with domain T and the following facts:\n• B(τ) for all τ ∈ T and B ∈ S such that B ∈ τ ;\n• R(τ1, τ2) for all τ1, τ2 ∈ T and R ∈ S such that (τ1, τ2) is R-coherent.\nNote that the construction of BT is well-known from the literature on modal and description logic. For example, BT can be viewed as a finite fragment of a canonical model of a modal logic that is constructed from maximal consistent sets of formulas [11]. Alternatively, BT can be viewed as the result of a type elimination procedure [41].\nWe obtain the desired set F of CSP templates by setting\nF = {(BT , τ) | T ∈ C, τ ∈ T,A 6∈ τ}.\nOne can show that for every S-instance D and d ∈ adom(D), there exists (BT , τ) ∈ F with (D, d)→ (BT , τ) iff d 6∈ qS,O,A(x)(D). Thus, the ontology-mediated query Q is equivalent to the query defined by F .\nConversely, assume that F is a finite set of S-structures with one constant. Take some (B, b) ∈ F , and for every d in the domain\ndom(B) of B, create some fresh concept name Ad. Let A be another fresh concept name, and set\nOB,b = {Ad v ¬Ad′ | d 6= d′} ∪ {Ad u ∃R.Ad′ v ⊥ | R(d, d′) 6∈ B, R ∈ S} ∪ {Ad uB v ⊥ | B(d) 6∈ B, B ∈ S} ∪ {> v t\nd∈dom(B) Ad, ¬Ab v A}\nConsider the ontology-mediated query QB,b = (S,OB,b, A(x)). One can show that for every S-instance D and d ∈ adom(D), (D, d) → (B, b) iff d 6∈ qQB,b(D). Thus, QB,b is the desired query ifF is a singleton. For the general case, letO be the disjunction over all OB,b with (B, b) ∈ F . Note that O can be expressed in ALCU : first, rewrite each OB,b into a single inclusion of the form > v CB,b and then set\nO = {> v t (B,b)∈F ∀U.CB,b}.\nUsing the above observation about the queries QB,b, it is not hard to show that the (ALCU ,AQ)-query Q = (S,O, A(x)) is equivalent to the query coCSP(F).\nThis completes the proof of Point 1. The proofs of Points 2 to 4 are similar and given in the full version of this paper. o\nTheorem 12 allows us to transfer results from the CSP world to OBDA, which, in light of recent progress on CSPs, turns out to be very fruitful. We start with data complexity.\nTheorem 13 (ALC,BAQ) has a dichotomy between PTIME and CONP iff the Feder-Vardi conjecture holds. The same is true for (SHIU ,AQ), and (SHIU ,BAQ).\nSince SHIU -ontologies can be replaced by ALCU-ontologies in ontology-mediated queries due to Theorem 5, the “if” direction of (all cases mentioned in) Theorem 13 actually follows from Theorem 8. The “only if” direction is a consequence of Theorem 12. We now consider further interesting applications of Theorem 12, in particular to deciding query containment, FO-rewritability, and datalog rewritability."
    }, {
      "heading" : "5.1 Query Containment",
      "text" : "In Section 4, we have established decidability results for query containment in OBDA languages based on UCQs. For OBDA languages based on AQs and BAQs, we even obtain a tight complexity bound. It is easy to see that query containment in coCSP is characterized by homomorphisms between templates. Consequently, it is straightforward to show that query containment for generalized coCSP with constant symbols is NP-complete. Thus, Theorem 12 yields the following NEXPTIME upper bound for query containment in OBDA languages. The corresponding lower bound is proved in the full version of this paper by a non-trivial reduction of a NEXPTIME-complete tiling problem.\nTheorem 14 Query containment in (SHIU ,AQ∪BQ) is in NEXPTIME. It is NEXPTIME-hard already for (ALC,AQ) and for (ALC,BAQ).\nIt is a consequence of a result in [10] that query containment is undecidable for ALCF . We show in the full version of this paper how the slight gap pointed out in Footnote 3 can be bridged."
    }, {
      "heading" : "5.2 FO- and Datalog-Rewritability",
      "text" : "One prominent approach to answering ontology-mediated queries is to make use of existing relational database systems or\ndatalog engines, eliminating the ontology by query rewriting [18, 22, 20]. Specifically, an ontology-mediated query (S,O, q) is FOrewritable if there exists an FO-query over S that is equivalent to it and datalog-rewritable if there exists a datalog program over S that defines it. We observe that every ontology-mediated query that is FO-rewritable is also datalog-rewritable.\nProposition 4 If Q = (S,O, q) is an ontology-mediated query with O formulated in equality-free FO and q a UCQ, then qQ is preserved by homomorphisms. Consequently, it follows from [43] that if qQ is FO-rewritable, then qQ is rewritable into a UCQ (thus into datalog).\nExample 2 illustrates that ontology-mediated queries are not always rewritable into an FO-query, and the same holds for datalogrewritability. It is a central problem to decide, given an ontologymediated query, whether it is FO-rewritable and whether it is datalog-rewritable. By leveraging the CSP connection, we show that both problems are decidable and pinpoint their complexities.\nOn the CSP side, FO-rewritability corresponds to FOdefinability, and datalog-rewritability to datalog-definability. Specifically, an S-query coCSP(F) is FO-definable if there is an FO-sentence ϕ over S such that for all finite relational structures A over S, we have A |= ϕ iff A 6→ B for all B in F . Similarly, coCSP(F) is datalog-definable if there exists a datalog program Π that defines it. FO-definability and datalog-definability have been studied extensively for CSPs, culminating in the following results.\nTheorem 15 Deciding, for a given finite relational structure B without constant symbols, whether coCSP(B) is FO-definable is NP-complete [35]. The same is true for datalog-definability [26].4\nCombining the preceding theorem with Theorem 12, we obtain NEXPTIME upper bounds for deciding FO-rewritability and datalog-rewritability of queries from (SHI,BAQ).\nTo capture the more important AQs rather than only BAQs, we show that Theorem 15 can be lifted, in a natural way, to generalized CSPs with constant symbols. The central step is provided by Proposition 5 below. For each finite relational structure B with constant symbols c1, . . . , cn, let us denote by Bc the corresponding relational structure without constant symbols over the schema that contains additional unary relations P1, . . . , Pn, where each Pi denotes the singleton set that consists of the element denoted by ci.\nProposition 5 For every set of homomorphically incomparable structures B1, . . . ,Bn with constant symbols,\n1. coCSP(B1, . . . ,Bn) is FO-definable iff coCSP(Bci ) is FOdefinable for 1 ≤ i ≤ n.\n2. coCSP(B1, . . . ,Bn) is datalog-definable iff coCSP(Bci ) is datalog-definable for 1 ≤ i ≤ n.\nA proof of Proposition 5 is provided in the full version of this paper. It relies on the characterization of FO-definable CSPs as those CSPs that have finite obstruction sets; this characterization was given in [2] for structures without constant symbols and follows from results in [43] for the case of structures with constant symbols.\n4An NP algorithm for datalog-definability is implicit in [26], based on results from [9], see also [13]. We thank Benoit Larose and Liber Barto for pointing this out.\nNote that every set of structures B1, . . . ,Bn has a subset B′1, . . . ,B′m which consists of homomorphically incomparable structures such that coCSP(B1, . . . ,Bn) is equivalent to coCSP(B′1, . . . ,B′m). We use this observation to establish the announced lifting of Theorem 15.\nTheorem 16 FO-definability and datalog-definability of generalized CSP with constant symbols is NP-complete.\nProof. To decide whether a generalized CSP with constant symbols given as a set of templates F = {B1, . . . ,Bn} is FO-definable, it suffices to first guess a subset F ′ ⊆ F and then to verify that (i) coCSP(Bc) is FO-definable for each B ∈ F ′, and (ii) for each B ∈ F there is a B′ ∈ F ′ such that B → B′. By Theorem 15, this can be done in NP. Correctness follows from Proposition 5 and the fact that whenever there is a subset F ′ satisfying (i) and (ii), then by the observation above there must be a subset F ′′ ⊆ F ′ of homomorphically incomparable structures such that coCSP(F ′′) is equivalent to coCSP(F ′), which by (ii) is equivalent to coCSP(F). Datalog-definability can be decided analogously. o\nFrom Theorems 12 and 16, we obtain a NEXPTIME upper bound for deciding FO-rewritability and datalog-rewritability of ontologymediated queries based on DLs and (B)AQs. The corresponding lower bounds are proved in the full version of this paper using a reduction from a NEXPTIME-hard tiling problem (in fact, the same problem as in the lower bound for query containment).\nTheorem 17 It is in NEXPTIME to decide FO-rewritability and datalog-rewritability of queries in (SHIU ,AQ∪BAQ). Both problems are NEXPTIME-hard for (ALC,AQ) and (ALC, BAQ).\nModulo a minor difference in the treatment of instances that are not consistent (see Footnote 3), it follows from a result in [36] that FOrewritability is undecidable for (ALCF ,AQ). In the full version of this paper, we show how to bridge the difference and how to modify the proof so that the result also applies to datalog-rewritability.\nTheorem 18 FO-rewritability and datalog-rewritability are undecidable for (ALCF ,AQ) and (ALCF ,BAQ)."
    }, {
      "heading" : "6. CONCLUSION",
      "text" : "Another query language frequently used in OBDA with description logics is conjunctive queries. The results in this paper imply that there is a dichotomy between PTIME and CONP for (ALC,CQ) if and only if the Feder-Vardi conjecture holds. We leave it open whether there is a natural characterization of (ALC,CQ) in terms of disjunctive datalog.\nWe mention two natural lines of future research. First, it would be interesting to understand the data complexity and query containment problem for (GF,UCQ) and (GNFO,UCQ). In particular, we would like to know whether Theorems 8 and 10 extend to (GF,UCQ) and (GNFO,UCQ). As explained in Section 4, resolving this question for Theorem 8 is equivalent to clarifying the computational status of GMSNP and MMSNP2.\nAnother interesting topic for future work is to analyze FO-rewritability and datalog-rewritability of ontology-mediated queries based on UCQs (instead of AQs) as a decision problem. It follows from our results that this is equivalent to deciding FOdefinability and datalog-definability of MMSNP formulas (or even GMSNP formulas).\nAcknowledgements. We thank Benoit Larose and Liber Barto for discussions on datalog-definability of CSPs, and Florent Madeleine and Manuel Bodirsky for discussions on MMSNP.\nMeghyn Bienvenu was supported by the ANR project PAGODA (ANR-12-JS02-007-01). Balder ten Cate was supported by NSF Grants IIS-0905276 and IIS-1217869. Carsten Lutz was supported by the DFG SFB/TR 8 “Spatial Cognition”."
    }, {
      "heading" : "7. REFERENCES",
      "text" : "[1] B. Alexe, B. ten Cate, P. G. Kolaitis, and W. C. Tan.\nCharacterizing schema mappings via data examples. ACM Trans. Database Syst., 36(4), 2011.\n[2] A. Atserias. On digraph coloring problems and treewidth duality. In LICS, 2005.\n[3] F. Baader, M. Bienvenu, C. Lutz, and F. Wolter. Query and predicate emptiness in description logics. In KR, 2010.\n[4] F. Baader, D. Calvanese, D. L. McGuiness, D. Nardi, and P. Patel-Schneider, editors. The Description Logic Handbook. Cambridge University Press, 2003.\n[5] J.-F. Baget, M.-L. Mugnier, S. Rudolph, and M. Thomazo. Walking the complexity lines for generalized guarded existential rules. In IJCAI, 2011.\n[6] V. Bárány, G. Gottlob, and M. Otto. Querying the guarded fragment. In LICS, 2010.\n[7] V. Bárány, B. ten Cate, and M. Otto. Queries with guarded negation. PVLDB, 5(11), 2012.\n[8] V. Bárány, B. ten Cate, and L. Segoufin. Guarded negation. In ICALP, 2011.\n[9] L. Barto and M. Kozik. Constraint satisfaction problems of bounded width. In FOCS, 2009.\n[10] M. Bienvenu, C. Lutz, and F. Wolter. Query containment in description logics reconsidered. In KR, 2012.\n[11] P. Blackburn, M. de Rijke, and Y. Venema. Modal Logic. Cambridge University Press, 2001.\n[12] M. Bodirsky, H. Chen, and T. Feder. On the complexity of MMSNP. SIAM J. Discrete Math., 26(1):404–414, 2012.\n[13] A. Bulatov. Bounded relational width. In preparation. http://www.cs.sfu.ca/∼abulatov/mpapers.html.\n[14] A. A. Bulatov. On the CSP dichotomy conjecture. In CSR, 2011.\n[15] A. Calì, G. Gottlob, and T. Lukasiewicz. A general datalog-based framework for tractable query answering over ontologies. In PODS, 2009.\n[16] A. Calì, G. Gottlob, and A. Pieris. Towards more expressive ontology languages: The query answering problem. Artif. Intell., 193, 2012.\n[17] D. Calvanese, G. D. Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. Data complexity of query answering in description logics. In KR, 2006.\n[18] D. Calvanese, G. D. Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. Tractable reasoning and efficient query answering in description logics: The DL-Lite family. J. Autom. Reasoning, 39(3), 2007.\n[19] D. Calvanese, G. D. Giacomo, and M. Lenzerini. On the decidability of query containment under constraints. In PODS, 1998.\n[20] B. Cuenca Grau, M. Kaminski, and B. Motik Computing Datalog Rewritings Beyond Horn Ontologies. In IJCAI, 2013\n[21] T. Eiter, G. Gottlob, and H. Mannila. Disjunctive datalog. ACM Trans. Database Syst., 22(3), 1997.\n[22] T. Eiter, M. Ortiz, M. Simkus, T.-K. Tran, and G. Xiao. Towards practical query answering for Horn-SHIQ. In DL, 2012.\n[23] T. Feder, F. R. Madelaine, and I. A. Stewart. Dichotomies for classes of homomorphism problems involving unary functions. Theor. Comput. Sci., 314(1-2), 2004.\n[24] T. Feder and M. Y. Vardi. The computational structure of monotone monadic SNP and constraint satisfaction: A study through datalog and group theory. SIAM J. Comput., 28(1), 1998.\n[25] J. Foniok, J. Nesetril, and C. Tardif. Generalised dualities and maximal finite antichains in the homomorphism order of relational structures. Eur. J. Comb., 29(4), 2008.\n[26] R. Freese, M. Kozik, A. Krokhin, M. Maróti, R. KcKenzie, and R. Willard. On Maltsev conditions associated with omitting certain types of local structures. In preparation. http://www.math.hawaii.edu/∼ralph/Classes/619/ OmittingTypesMaltsev.pdf\n[27] G. Gottlob, E. Grädel, and H. Veith. Datalog LITE: a deductive query language with linear time model checking. ACM Trans. Comput. Log., 3(1), 2002.\n[28] G. Gottlob and T. Schwentick. Rewriting ontological queries into small nonrecursive datalog programs. In KR, 2012.\n[29] U. Hustadt, B. Motik, and U. Sattler. Reasoning in description logics by a reduction to disjunctive datalog. J. Autom. Reasoning, 39(3), 2007.\n[30] S. Kikot, R. Kontchakov, V. V. Podolskii, and M. Zakharyaschev. Exponential lower bounds and separation for query rewriting. In ICALP, 2012.\n[31] R. Kontchakov, C. Lutz, D. Toman, F. Wolter, and M. Zakharyaschev. The combined approach to query answering in DL-Lite. In KR, 2010. [32] A. Krisnadhi and C. Lutz. Data complexity in the EL family of DLs. In LPAR, 2007.\n[33] G. Kun. Constraints, MMSNP, and Expander Structures. http://arxiv.org/abs/0706.1701v1, 2007.\n[34] G. Kun and J. Nesetril. Forbidden lifts (NP and CSP for combinatorialists). Eur. J. Comb., 29(4), 2008.\n[35] B. Larose, C. Loten, and C. Tardif. A characterisation of first-order constraint satisfaction problems. Logical Methods in Comp. Sci., 3(4), 2007.\n[36] C. Lutz and F. Wolter. Non-uniform data complexity of query answering in description logics. In KR, 2012.\n[37] F. R. Madelaine. Universal structures and the logic of forbidden patterns. Logical Methods in Comp. Sci., 5(2), 2009.\n[38] F. R. Madelaine and I. A. Stewart. Constraint satisfaction, logic and forbidden patterns. SIAM J. Comput., 37(1), 2007.\n[39] B. Motik. Reasoning in description logics using resolution and deductive databases. PhD thesis, 2006.\n[40] A. Poggi, D. Lembo, D. Calvanese, G. D. Giacomo, M. Lenzerini, and R. Rosati. Linking data to ontologies. J. Data Semantics, 10, 2008.\n[41] V. R. Pratt. Models of program logics. In FoCS, 1979. [42] R. Rosati and A. Almatelli. Improving Query Answering\nover DL-Lite Ontologies. In KR, 2010. [43] B. Rossman. Homomorphism preservation theorems. J.\nACM, 55(3), 2008. [44] S. Rudolph, M. Krötzsch, and P. Hitzler.\nType-elimination-based reasoning for the description logic SHIQbs using decision diagrams and disjunctive datalog. Logical Methods in Comp. Sci., 8(1), 2012.\n[45] F. Simancik. Elimination of complex RIAs without automata. In DL, 2012.\n[46] B. ten Cate and L. Segoufin. Unary negation. In STACS, 2011.\n[47] W3C OWL Working Group. OWL 2 Web Ontology Language. http://www.w3.org/TR/owl2-overview/, 2012."
    }, {
      "heading" : "APPENDIX",
      "text" : ""
    }, {
      "heading" : "A. PROOFS FOR SECTION 3",
      "text" : ""
    }, {
      "heading" : "A.1 Proofs for Section 3.1",
      "text" : "We remark that the direction “from (ALC,AQ) to MDDlog” of Theorem 1 is actually a consequence of Theorem 6, which makes a strictly more general statement. We still provide it here (and in the main paper) as a warmup for the proof of Theorem 6. As an extra bit of notation, we say that an assignment π of elements of an instance D to the variables of a CQ q is a match of q in D if D satisfies q under π.\nTheorem 1. (ALC,UCQ) and MDDlog have the same expressive power.\nProof. (continued) We establish here the correctness of the translation from (ALC,UCQ) to MDDlog. Letm be the arity of (S,O, q). We have to show the following.\nClaim. For all instances D over S and all a ∈ adom(D)m, we have a ∈ certq,O(D) iff a ∈ qΠ(D).\n“if”. Assume that a /∈ certq,O(D). Then there is a (dom′,D′) ∈ Mod(O) such that D ⊆ D′ and a /∈ q(D′). For each b ∈ adom(D), let µ(b) be the unique type realized at b in D′, that is,\nµ(b) = {q′ ∈ cl(O, q) | q′ is Boolean and D′ |= q′}∪ {C ∈ cl(O, q) | C is unary and D′ |= C[b]}.\nLet D′′ be the instance that consists of the atoms in D and the atom Pµ(b)(b) for each b ∈ adom(D). It can be verified that D′′ is a model of Π. In particular, it follows from the construction of D′′ and the fact that a /∈ q(D′) that whenever a diagram δ(x) has a match π in D′′ and δ(x) implies q(x′), then π(x′) 6= a. Since D′′ is a model of Π and goal(a) /∈ D′′, we have a 6∈ qΠ(D).\n“only if”. Assume that a 6∈ qΠ(D), and let D′ ∈ Mod(Π) be such that D ⊆ D′ and D′ does not contain goal(a). We assume w.l.o.g. that adom(D) = adom(D′). Note that the first two rules of Π ensure that for each a ∈ adom(D), there is a unique type µ(a) such that Pµ(a)(a) ∈ D′. The second rule further ensures that for each a ∈ adom(D), there is a model (doma,Da) of O in which µ(a) is realized at a. We may assume that these models have disjoint domains. Let (dom′′,D′′) be the relational structure obtained by first taking the union of (doma,Da)a∈adom(D), and then adding all facts from D. To prove that a /∈ certq,O(D), it suffices to show that\n(i) (dom′′,D′′) is a model of O, and (ii) a 6∈ q(D′′).\nFor Point (i), let µ(d) be the unique type realized by d in (doma,Da), for all d ∈ doma. It is not difficult to show by induction on the structural complexity of C that for all concepts C ∈ cl(O, q) ∩ sub(O) and all d ∈ dom′′, we have\n(dom′′,D′′) |= C(d) iff C ∈ µ(d) (1)\n(refer to the proof of Theorem 2 for details). Since cl(O, q) by definition includes C and D whenever C v D is inO, this implies Point (i) as desired.\nIt thus remains to establish Point (ii). Assume to the contrary that there is a disjunct q′(x′) of q such that a ∈ q′(D′′), that is, there is a match π of q′(x′) in D′′ such that π(x′) = a. We define a diagram δ(x) based on the restriction of the original model D′ of Π , as follows: δ(x) contains (a) all atoms A(x) such that π(x) ∈ adom(D′) and A(π(x)) ∈ D′ (where A can be either a concept name or of the form Pτ ), (b) all atoms R(x, y) such that π(x), π(y) ∈ adom(D′) and R(π(x), π(y)) ∈ D′, and (c) all atoms Pµ(d)(zd) (with zd a fresh variable) such that Pµ(d)(d) ∈ D′ and there is some π(w) ∈ domd. Atoms of type (c) are used to handle the case in which a Boolean subquery q′′ of q′ is mapped inside Dd, but the element d does not itself belong to the image of π. We remark that the mapping π can be straightforwardly extended to a match for δ(x) in D′ by setting π(zd) = d. Since δ(x) is satisfied in D′ under π and π(x′) = a, by the last rule of Π, we can obtain the desired contradiction by showing that δ(x) implies q′(x′).\nThus, let (dom,B) ∈ Mod(O) be a type-coherent structure, and let τ be a match of δ(x) in B. Consider the following CQs:\n• q0 is the restriction of q′ to those variables that π maps to elements of D;\n• for each a ∈ adom(D) such that some element of doma is in the range of π, the CQ qa is obtained by first taking the restriction of q′ to those variables that π maps to elements of doma and then identifying all variables that π maps to the same element (preserving the names of free variables).\nClearly, each qa has at most one free variable, which, if it exists, is mapped to a by π.\nWe start by showing that q0 is satisfied in B under τ . For role atoms in q0, this is immediate since all such atoms also belong to δ(x). Thus, consider some concept atom A(x) ∈ q0. Since A(x) ∈ q′ and π is a match for q′ in D′′, we have A(π(x)) ∈ D′′. Then using the fact that A ∈ cl(O, q) ∩ sub(O) and Equation (1) above, we obtain A ∈ µ(π(x)). We know that Pµ(π(x))(π(x)) ∈ D′, so by construction of δ(x), we must have Pµ(π(x))(x) ∈ δ(x), hence Pµ(π(x))(τ(x)) ∈ B. Using the type-coherence of B and the fact that A ∈ µ(π(x)), we obtain A(τ(x)) ∈ B, as desired.\nNow consider a query qa. By construction, the length of qa cannot exceed the length of q, and so qa ∈ cl(O, q). Since qa has a match in Da (such that, if qa has a free variable, it is mapped to a) and Da realizes the type µ(a) at a, we must have qa ∈ µ(a). By construction of δ(x), there is an atom Pµ(a)(x) ∈ δ(x). Since τ is a match for δ(x) in B, we must have Pµ(a)(τ(x)) ∈ B. Then, using the fact that B is type-coherent, we can find a match τa of qa in B (such that, if qa has a free variable, τa maps it to τ(x)). It is not hard to see that the matches τ and τa can be assembled into a match τ ′ of q′ in B which coincides with τ on x′. o\nTheorem 2 (ALC,AQ) has the same expressive power as unary connected simple MDDlog.\nProof. (continued) We establish here the correctness of the translation from (ALC,AQ) to MDDlog. That is, we show that, for every instance D and elements a ∈ adom(D), we have a ∈ certq,O(D) if and only if a ∈ qΠ(D).\n“if”. Assume that a 6∈ certq,O(D). Then there is (dom,D′) ∈ Mod(O) with D ⊆ D′ such that a 6∈ q(D′). For each b ∈ adom(D), let µ(b) be the unique type realized at b in D′. Let D′′ be the instance that consists of the atoms in D and an atom Pµ(b)(b) for each b ∈ adom(D). It can be checked that D′′ is a model of Π. Since goal(a) /∈ D′′, we obtain a 6∈ qΠ(D).\n“only if”. Assume that a 6∈ qΠ(D) and let D′ be a model of Π with D ⊆ D′ that does not contain goal(a). For each b ∈ adom(D), let µ(b) be a type such that Pµ(b)(b) ∈ D′ (in fact, the rules in Π enforce that there is exactly one such µ(b)). Note that A 6∈ µ(a). Also note that each type µ(b) must be realizable in some model of O (else, there would be a rule forbidding Pµ(b) atoms). Thus, for each b ∈ adom(D), we can find a model (domb,Db) of O in which the type µ(b) is realized at b. We may assume that these models have disjoint domains. Let (dom′′,D′′) be obtained by first taking the union of (domb,Db)b∈adom(D), and then adding all facts in D. By construction, D ⊆ D′′ and a 6∈ q(D′′). It remains to show that (dom′′,D′′) is a model of O.\nLet µ(d) be the unique type realized by d in (doma,Da), for all d ∈ doma. We show the following by induction on the structural complexity of C:\n(∗) For every concept C ∈ sub(O) and every d ∈ dom′′, we have (dom′′,D′′) |= C(d) iff C ∈ µ(d).\nNote that it follows from (∗) that (dom′′,D′′) is a model of O. For the base case, first suppose that A ∈ µ(d), with A a concept name and d ∈ doma. Then A(d) ∈ Da ⊆ D′′, so (dom′′,D′′) |= A(d). Next suppose that (dom′′,D′′) |= A(d). Then A(d) ∈ D′′, so either A(d) ∈ Da, or d = a and A(d) ∈ D. In the former case, we immediately obtain A ∈ µ(d). In the latter case, note that if A 6∈ µ(d), then Π would contain the rule ⊥ ← Pµ(d)(x) ∧ A(x), and this would yield a contradiction since {A(d), Pµ(d)(d)} ⊆ D′.\nThe inductive step for the Boolean operators is trivial, so we consider only the case of the ∃R constructor (the argument for the ∀R constructor is similar). Thus, let C = ∃R.D and d ∈ doma, and suppose that C ∈ µ(d). Then (doma,Da) |= ∃R.D(d), so there exists e ∈ doma such that R(d, e) ∈ Da and (doma,Da) |= D(e). It follows that D ∈ µ(e), and hence by the induction hypothesis, we must have (dom′′,D′′) |= D(e). Since Da ⊆ D′′, we have R(d, e) ∈ D′′, which yields (dom′′,D′′) |= C(d).\nConversely, suppose (dom′′,D′′) satisfies ∃R.D(d), that is, there is an element e such that (dom′′,D′′) satisfies R(d, e) and D(e). If e ∈ doma, the claim (∗) follows immediately from the induction hypothesis. Otherwise, we must have that e ∈ adom(D) and, by induction hypothesis, D ∈ µ(e). It follows that ∃R.D ∈ µ(d), because otherwise Pµ(d)(x) ∧R(x, y) ∧ Pµ(e)(y) would be a non-realizable diagram, and Π would derive an inconsistency.\no\nTheorem 3.\n1. (ALCHIU ,UCQ) has the same expressive power as MDDlog and as (ALC,UCQ).\n2. (S,UCQ) and (ALCF ,UCQ) are strictly more expressive than (ALC,UCQ).\nTo complete the proof of Theorem 3, we need to show that the queries from (S,UCQ) and (ALCF ,UCQ) indicated in the proof sketch cannot be expressed in (ALC,UCQ), or equivalently, MDDlog. We start by providing a means of identifying queries which cannot be expressed in MDDlog, using the notion of colored instances, defined as follows:\nDefinition 1 Let S be a schema and C be a set of unary predicates (colors) {C1, . . . , Cn} disjoint from S. A C-colored S-structure is an S ∪ C-structure (dom,D) such that • For every d ∈ dom, Ci(d) ∈ D for some i; • If Ci(d) ∈ D, then Cj(d) 6∈ D for every j 6= i.\nD is called a C-coloring of an S-structure D′ if D′ is the S-reduct of D′.\nNow for each k > 0, fix Ck with |Ck| = k and Ck ∩S = ∅. Then a k-coloring of D is simply a Ck-coloring of D.\nWe will also utilize the notion of forbidden pattern problems from [38, 34, 12], whose definition we recall here.\nDefinition 2 Given a set F of C-colored S-structures (called forbidden patterns), we define Forb(F) as the set of all S-structures D such that there exists a C-coloring D′ of D for which F 6→ D′ for every F ∈ F . The forbidden patterns problem defined by F is to decide whether a given S-structure belongs to Forb(F).\nAnalogously to coMMSNP, we can define a query language coFPP consisting of all those Boolean queries qF,S defined by\nqF,S(D) = 1 iff (adom(D),D) 6∈ Forb(F)\nwith F a set of C-colored S-structures. It follows directly from results in [38] that coMMSNP and coFPP have the same expressive power. Combining this result with Proposition 2 (from Section 4), we obtain the following:\nProposition 6 coFPP and Boolean MDDlog have the same expressive power.\nWe use Proposition 6 in the proof of the following lemma, whose purpose is to establish a sufficient condition for non-expressibility in MDDlog.\nLemma 1 A Boolean query Q over schema S does not belong to MDDlog if for every m,n > 0, there exist S-instances D0 and D1 with Q(D0) = 0 and Q(D1) = 1 such that for every mcoloring B0 of (adom(D0),D0), there exists anm-coloring B1 of (adom(D1),D1) such that from every substructure of B1 having at most n elements there is a homomorphism to B0.\nProof. Assume for a contradiction that the conditions of the lemma hold for every n,m > 0 but that Q is equivalent to some query in MDDlog. Then, by Proposition 6, there is a set F of C-colored S-structures such that for all S-instances D, we have Q(D) = 1 if and only if (adom(D),D) 6∈ Forb(F). Let m0 = |C|, and let n0 be the maximal number of elements in the domain of some F ∈ F . We can assume w.l.o.g. that C = Cm0 .\nTake S-instances D0 and D1 satisfying the conditions of the lemma for m0, n0. As Q(D0) = 0, there exists a C-coloring B0 of (adom(D0),D0) such that F 6→ B0 for every F ∈ F . It follows that there exists a C-coloring B1 of (adom(D1),D1) such that from every substructure of B1with at most n0 elements, there exists a homomorphism to B0. Since Q(D1) = 1, we know that there must exist some F ∈ F such that F → B1. As F contains at most n0 elements, we can compose this homomorphism with the previous homomorphism to obtain a homomorphism of F into B0, contradicting the fact that (adom(D0),D0) ∈ Forb(F). o\nUsing the preceding lemma, we can now prove that the queries mentioned in the proof sketch cannot be expressed in MDDlog.\nLemma 2 There exist queries in (S,UCQ) which do not belong to MDDlog.\nProof. Consider Q = (S,O, q) where S = {R,S}, O asserts transitivity of R and S, and q = ∃xy(R(x, y) ∧ S(x, y)).\nWe apply Lemma 1. Assume that m,n > 0 are given. Let k = n− 1 and k′ = mk+2 + 1. Define D1 and D0 as follows:\n• D1 has elements e, f and a1, . . . , ak and b1, . . . , bk and the atoms R(e, a1), R(ak, f) and R(ai, ai+1) for 1 ≤ i < k, and S(e, a1), S(ak, f) and S(bi, bi+1) for 1 ≤ i < k.\n• D0 has elements e1, . . . , ek ′ and f1, . . . , fk ′\nas well as aj1, . . . , a j k for 1 ≤ j ≤ k ′ and bi,j1 , . . . , b i,j k for 1 ≤ j < i ≤ k′. The atoms of D0 consist of: – R(ei, ai1), R(aik, f i), and R(aij , aij+1) for 1 ≤ i ≤ k′ and\n1 ≤ j < k; – S(ei, bi,j1 ) and S(b i,j k , fj) for 1 ≤ j < i ≤ k\n′, and S(bi,jl , b i,j l+1) for 1 ≤ l < k and 1 ≤ j < i ≤ k\n′. It is readily checked that Q(D0) = 0 and Q(D1) = 1, as required. Let B0 be an m-coloring of (adom(D0),D0). Since k′ = mk+2 + 1, we can find i, i′ with i > i′ such that the colorings of ei, ai1, . . . , aik, f i and ei ′ , ai ′ 1 , . . . , a i′ k , f\ni′ coincide. Define an m-coloring of (adom(D1),D1) by taking the coloring of ei, ai1, . . . , aik, f\ni for e, a1, . . . , ak, f and the coloring of bi,i ′ 1 , . . . , b i,i′\nk for b1, . . . , bk. Denote by B1 the resulting colored structure.\nConsider a subset C of adom(B1) having at most n elements, and let B′1 be the restriction of B1 to the elements in C. We define a function h from C to adom(B0) as follows: • If e 6∈ C, then let h be the restriction of the following mapping\nto C: h(al) = ai ′ l , h(bl) = b i,i′ l and h(f) = f i′ ;\n• If f 6∈ C, then let h be the restriction of the following mapping to C: h(al) = ail , h(bl) = b i,i′ l and h(e) = e i; • Otherwise there exists ai0 6∈ C. Then let h be the restriction of the following mapping to C: h(e) = ei, h(al) = ail for all l < i0, h(al) = ai ′ l for all l > i0, h(bl) = b i,i′\nl for all 1 ≤ l ≤ k, and h(f) = f i ′ .\nIt is easily verified that h is a homomorphism from B′1 to B0. o\nLemma 3 There exist queries in (ALCF ,UCQ) which do not belong to MDDlog.\nProof. Consider Q = (S,O, ∃x.A(x)) where S = {S,A} and O states that S is functional. Set D1 = {S(a, b), S(a, c)} and D0 = {S(a, b)}. Note that qQ(D1) = 1 (since no model of O contains D1) and qQ(D0) = 0. Let B0 be any m-coloring of (adom(D0),D0). We define anm-coloring B1 of D1 by assigning a, b the same colors as in B0 and giving c the same color as b. Then the mapping sending a to itself and b, c to b defines a homomorphism from B1 to B0 (and hence also defines a homomorphism from any substructure of B1 to B0). It follows by Lemma 1 thatQ is not definable in MDDlog. o\nTheorem 5 (ALCU ,AQ) and (SHIU ,AQ) both have the same expressive power as unary simple MDDlog.\nProof. We first show • (ALCU ,AQ) is at least as expressive as unary simple MDDlog; • unary simple MDDlog is at least as expressive as\n(ALCIU ,AQ). For Point 1, let Π be a unary simple MDDlog program. The rewriting of each rule of Π into an equivalent ALCU-concept inclusion is similar to the proof of Theorem 2 except that now one also has to concider non-connected bodies. They can be translated using the universal role. For example,\nP1(x) ∨ P2(y)← A(x) ∧B(y)\nis rewritten into A u ∃U.(B u ¬P2) v P1. Now consider Point 2. The translation from (ALCIU ,AQ) to unary simple MDDlog queries is a modified version of the translation given in the proof of Theorem 2 for the translation from (ALC,AQ) to connected unary simple MDDlog queries.\nAssume that (S,O, q) with q = A(x) is given. As in Theorem 2, we take types to be subsets of sub(O). The MDDlog program Π consists of the following rules:∨\nτ⊆sub(O) Pτ (x)← adom(x) ⊥ ← δ(x) for all non-realizable diagrams δ(x)\nof the form Pτ1(x1) ∧ Pτ2(x2), Pτ (x) ∧A(x), or Pτ1(x1) ∧ S(x, y) ∧ Pτ2(x2)\ngoal(x)← Pτ (x) for all Pτ with A ∈ Pτ Note that the only difference with the rules in the proof of Theorem 2 is the presence of rules of the form\n⊥ ← Pτ1(x1) ∧ Pτ2(x2)\nwhich are not connected. Π is still unary and simple. Equivalence of (S,O, q) and qΠ can now be proved similarly to Theorem 2.\nIt remains to be shown that (ALCIU ,AQ) and (SHIU ,AQ) are equally expressive. But this is again folkore [39, 45]: it is known that for every SHIU -ontologyO, there exists anALCIU - ontology O′ (possibly using additional concept names) such that (i) O′ |= O and (ii) for every A ∈ Mod(O), there exists a model A′ ∈ Mod(O′) with the same domain and interpreting the concept names of O in the same way as A and interpreting the role names as relations containing their interpretation in A. It follows that (ALCIU ,AQ) and (SHIU ,AQ) are equally expressive. o\nWe briefly discuss Boolean atomic queries (BAQs), i.e., queries of the form ∃x.A(x), where A is a unary relation symbol. BAQs behave similarly to AQs and one can show modified versions of Theorems 2 to Theorem 5 above in which AQs are replaced by BAQs and unary goal predicates by 0-ary goal-predicate, respectively.\nTheorem 19 Theorems 2 to Theorem 5 hold if AQs are replaced by BAQs and unary goal predicates by 0-ary goal-predicate, respectively.\nProof. We show the required modifications to the proof of Theorem 2. The remaining results are proved by similar modifications and left to the reader. For the translation from (ALC,BAQ) to Boolean connected simple MDDlog, the only difference to the program constructed in the proof of Theorem 2 is that rules of the form goal(x)← Pτ (x) are replaced by rules of the form goal← Pτ (x). Conversely, for the translation from Boolean connected simple MDDlog to (ALC,BAQ), we regard goal as a concept name and take the BAQ ∃x.goal(x). The rewriting of goal rules must also be accordingly modified. For example, goal ← R(x, y) is rewritten into ∃R.> v goal. o"
    }, {
      "heading" : "A.2 Proofs for Section 3.2",
      "text" : "Theorem 6 (UNFO,UCQ) has the same expressive power as MDDlog.\nProof. (continued) We establish here the correctness of the translation from (UNFO,UCQ) to MDDlog. That is, we show that, for every instance D and elements a ∈ adom(D), we have\na ∈ certq,O(D) if and only if a ∈ qΠ(D). The “if” direction proceeds exactly as in the proof of Theorem 1, so here we focus on the “only if” direction.\n“only if”. Assume that a 6∈ qΠ(D) and let D′ be a model of Π with D ⊆ D′ that does not contain goal(a). For each a ∈ adom(D), let µ(a) be the unique type such that Pµ(a)(a) ∈ D′, and let (doma,Da) be a model of O in which µ(a) is realized at a. Note that such a model must exist because otherwise the diagram Pµ(a)(x) would be non-realizable and Π would include a rule ⊥ ← Pµ(a)(x). We may assume that these models have disjoint domains. Let (dom′′,D′′) be obtained by first taking the union of (doma,Da)a∈adom(D), and then adding to it all facts of D. We show that\n(i) (dom′′,D′′) is a model of O, and (ii) a 6∈ q(D′′). We start with the first claim. Let µ(d) be the unique type realized by d in (doma,Da), for all d ∈ doma. We show the following by induction on the structure of ϕ:\n(∗) For all ϕ ∈ clk(O) and d ∈ dom′′, we have that ϕ ∈ µ(d) iff (dom′′,D′′) |= ϕ[d].\nNote that ϕ may be either a sentence or a formula with exactly one free variable, and in the former case, we interpret ϕ[d] as ϕ. Since all types µ(d) must include the sentence O, (∗) implies (i).\nThe base case (ϕ = >) and the inductive step for formulas of the form ¬ψ(x) are omitted since they are straightforward. Thus, let ϕ be a formula from clk(O) of the form ∃y ∧ i ψi(x,y), and let d ∈ doma. We may assume that ϕ is connected, meaning that the graph whose nodes are the subformulas ψi and containing an edge between ψi and ψj if they share a variable, is connected. This is because, if ϕ is not connected, then the claim follows immediately from the analogous claims for each of the connected components of ϕ. We present the proof for the case where ϕ has answer variable x (the argument for sentences is similar).\nFirst suppose that ϕ ∈ µ(d), which means (doma,Da) |= ϕ[d]. It follows that there is an assignment π of elements of doma to the variables x,y such that π(x) = d and for every i, (doma,Da) |= ψi(π(x,y)). If ψi is an atomic formula, then using the fact that Da ⊆ D′′, we obtain (dom′′,D′′) |= ψi(π(x,y)). If ψi is not atomic, then it must have at most one free variable u. We thus have that (doma,Da) |= ψi[π(u)], so ψi ∈ µ(π(u)). Applying the induction hypothesis, we obtain (dom′′,D′′) |= ψi[π(u)]. It follows that π is a satisfying assignment for ϕ in (dom′′,D′′), hence (dom′′,D′′) |= ϕ[d].\nConversely, suppose (dom′′,D′′) |= ϕ[d], that is, (dom′′,D′′) satisfies ∧ i ψi(x,y) for some assignment π of elements of dom ′′ to the variables x,y such that π(x) = d. First assume that the image of π is entirely contained in doma. Using the induction hypothesis to treat the non-atomic ψi as before, we then get that (doma,Da) |= ϕ[d], hence ϕ ∈ µ(d) as required.\nNext suppose that the image of π is not wholly contained in doma, and let I be the set consisting of the elements of adom(D) that are in the range of π. By the connectedness assumption and the fact that d ∈ doma, the set I contains a. In what follows, we will define a number of formulas by syntactic operations on ϕ. It will follow from the definition of clk(O) that each of these formulas again belongs to clk(O), and hence, is subject to the induction hypothesis. Let ϕ′ be obtained from ϕ by identifying all variables z, z′ such that π(z) = π(z′) ∈ I . We assume that the free variable x retains its name, and use ψ′i to denote the conjunct of ϕ\n′ which corresponds to ψi. For each b ∈ I , let zb ∈ y ∪ {x} be the unique variable in ϕ′ with π(zb) = b. Let ϕ′b be the restriction of ϕ ′ to\nthose ψ′i which contain only variables z with π(z) ∈ domb, with free variable zb. We have (dom′′,D′′) |= ϕ′b[b] via the restriction of π to the variables in ϕ′b, thus, by the earlier argument (since all witnessing elements are contained in domb), we have ϕ′b ∈ µ(b). Let ϕ′0 be ϕ′, but with free variable za instead of x. Note that (dom′′,D′′) |= ϕ′0[a].\nConsider the diagram δ obtained by taking the restriction of D′ to I , and then replacing each b ∈ I with zb. Since δ is made true by D′, and D′ is a model of Π, we have that δ is a realizable diagram. Moreover, using the fact that Pµ(b)(zb) ∈ δ and ϕ′b ∈ µ(b) for every b ∈ I , one can show that the diagram δ implies the query ϕ′0. This together with the realizability of δ yields ϕ′0 ∈ µ(a), hence (doma,Da) |= ϕ′0[a]. Let π′ be a satisfying assignment of ϕ′0 in Da such that π′(za) = a. We use π′ to construct a satisfying assignment π′′ of ϕ′ mapping x to d, such that the range of π′′ lies entirely inside doma. The assignment π′′ is defined as follows: for all u with π(u) in doma, set π′′(u) = π(u); for all other u, set π′′(u) = π′(u). To see that π′′ is indeed a satisfying assignment of ϕ′, note that each conjunct of ϕ′ contains, besides za, either only variables u with π(u) ∈ doma, or only variables u with π(u) 6∈ doma. The former conjuncts are satisfied because π is a match, and the latter conjuncts are satisfied because π′ is a match. Moreover, π′′(x) = d. Therefore, (doma,Da) |= ϕ[d] and hence ϕ ∈ µ(d) as required.\nFinally, we can show (ii) in a similar way. We suppose, for the sake of contradiction, that a ∈ q(D′′) under some assignment π to the existentially quantified variables in q. Let b be the elements of adom(D) belonging to the range of π (here again we focus on the case in which q is connected and contains at least one free variable). Then, in the same way as above, we can decompose q into unary subqueries qb that are satisfied in the different subinstances Db with b ∈ b, and conclude that qb ∈ µ(b) for each b ∈ b. We can then show that the diagram obtained by taking all facts in D′ over elements in b and replacing each b ∈ b by zb implies the query q. This yields the desired contradiction since D′ is a model of Π.\no\nProposition 1. The Boolean query (†) there are a1, . . . , an, b, for some n ≥ 2, such that A(a1),\nB(an), and P (ai, b, ai+1) for all 1 ≤ i < n is definable in (GF,UCQ) and not in MDDlog.\nProof. Let S consist of unary predicates A,B and a ternary predicateP , and letQ be the S-query defined by (†). A (GF,UCQ) query expressing Q was given in the body of the paper. It thus remains to show that Q cannot be expressed in MDDlog. We make use of the characterization of MDDlog queries in terms of k-colorings provided by Lemma 1.\nAssume that m,n are given. Let k = mn + 2n. Define Sinstances D1 and D0 as follows: • D1 has elements d1, . . . , dk, e and the atoms A(d1), B(dk),\nand P (di, e, di+1) for 1 ≤ i < k.\n• D0 has elements d1, . . . , dk, and e1, . . . , ek and the following atoms: A(d1), B(dk), and P (di, ej , di+1) whenever 1 ≤ i < k, 1 ≤ j < k, and j 6= i.\nIt is readily checked that Q(D1) = 1 and Q(D0) = 0, as required. Let B0 be an m-coloring of D0. Define an m-coloring B1 of D1 by giving all elements of {d1, . . . , dk} exactly the same color as in B0. Choose i with n < i < k − n in such a way that for every sequence dl, . . . , dl+n with l > 1 and l + n < k there exists a sequence dl′ , . . . , dl′+n with l′ > 1 and l′+n < k such that the coloring of dl, . . . , dl+n coincides with the coloring of dl′ , . . . , dl′+n\nand i 6∈ {l′, l′ + n}. Such an i exists since k ≥ mn + 2n. Now give e the color of ei. One can now easily construct, for every structure corresponding to an n-element subset of B1, a homomorphism to B0. o\nTheorem 7 (GF,UCQ) and (GNFO,UCQ) have the same expressive power as frontier-guarded DDlog.\nProof. We start by describing the translation from frontierguarded DDlog to (GNFO,UCQ). Let Π be a frontier-guarded DDlog query. It is easily verified that if we write out the implication symbol in a frontier-guarded DDlog rule using conjunction and negation, the resulting formula belongs to GNFO. Thus, we can take O to be the set of all non-goal rules of Π, viewed as a GNFO sentence, and let q be the UCQ that consists of all bodies of rules whose conclusion contains the IDB relation goal. It is easy to check that the ontology-mediated query (S,O, q), where S is the schema consisting of all EDB relations, is equivalent to the frontier-guarded DDlog query qΠ.\nNext, we explain how to translate (GNFO, UCQ) to frontierguarded DDlog. Since every sentence of GF is equivalent to a sentence of GNFO [8], this also yields a translation of (GF,UCQ) to frontier-guarded DDlog. Recall that we used a specific normal form for UNFO sentences. For GNFO, we can use an analogous normal form. Specifically, we can assume that O is generated by the following grammar:\nϕ(x) ::= > | α(x) ∧ ¬ϕ(x) | ∃y(ψ1(x, y) ∧ · · · ∧ ψn(x, y))\nwhere each ψi is either a relational atom or a formula generated by the same grammar whose free variables are among x,y. The “guard” α is an atomic formula, possibly an equality, containing all variables in x.\nLet sub(O) be the set of all subformulas ofO. Let k be the maximum of the number of variables in O and the number of variables in q. For ` ≥ 0, we denote by cl`k(O) the set of all formulas χ(x) with x = (x1, . . . , x`) of the form\n∃y(ψ1(x, y) ∧ · · · ∧ ψn(x, y))\nwith y = (y1, . . . , ym), m+ ` ≤ k, and such that each ψi is either an atomic formula that uses a symbol from q or is of the form χ(z) for some χ(z′) ∈ sub(O).\nA guarded `-type τ is a subset of cl`k(O) that contains at least one atomic relation (possibly equality) containing all variables x1, . . . , x`, and also contains the sentence O itself. We denote the set of all guarded `-types by type`(O). Note that, by definition, there are no guarded `-types for ` greater than the maximal arity of a relation from S.\nWe now proceed the same way as we did in the case of UNFO (but using guarded `-types instead of unary types). We introduce a fresh `-ary relation symbol Pτ for each guarded `-type τ , and we denote by S′ the schema that extends S with these additional relations. Diagrams, realizability, and implying a query are defined in the same way as before. The DDlog program is also constructed in essentially the same manner, except that the first rule of the program is replaced by the following:∨ τ a guarded `-type\nwithR(x) ∈ τ\nPτ (x)← R(x) for each relation R of arity ` ≥ 0.\nWe establish the correctness of the translation. That is, we show that, for every instance D and elements a = a1, . . . , an ∈ adom(D), we have a ∈ certq,O(D) if and only if a ∈ qΠ(D).\n“if”. Assume that a 6∈ certq,O(D). Then there is (dom,D′) ∈ Mod(O) with D ⊆ D′ such that a 6∈ q(D′). For every fact R(b) of D, let µ(b) be the unique guarded `-type (with ` = |b|) realized at a in D′. Let D′′ be the instance that consists of the atoms in D and the atom Pµ(a)(b) for each fact R(b) in D. It can be checked that D′′ is a model of Π. Since goal(a) /∈ D′′, a 6∈ qΠ(D).\n“only if”. Assume that a 6∈ qΠ(D) and let D′ be a model of Π with D ⊆ D′ that does not contain goal(a). We say that a tuple b is “live” in D if D contains R(b) for some relation symbol R. For each live tuple b of D, let µ(b) be the unique guarded `-type (with ` = |b|) such that Pµ(b)(b) ∈ D′, and let (domb,Db) be a model ofO in which µ(b) is realized at b (such a model must exist because otherwise the diagram Pµ(b)(x) would be non-realizable and Π would include a rule ⊥ ← Pµ(b)(x)). We may assume that for distinct live tuples b and c, domb and domc overlap only (possibly) on {b} ∩ {c}. Let (dom′′,D′′) be obtained by first taking the union of (domb,Db) for all live tuples b of D, and then adding to it all facts of D. We show that\n(i) (dom′′,D′′) is a model of O and (ii) a 6∈ q(D′′). For all live tuples d of Db, let µ(d) be the unique guarded `- type realized by d in (domb,Db), for all d ∈ doma. Note that a tuple d may be live in Db for several different choices of b, but then the guarded `-type realized by d in each such (domb,Db) is the same: otherwise, there must be some atom R(y) that belongs to µ(b), but not to µ(b′), and then the diagram Pµ(b′)(x) ∧R(y) is non-realizable and thus ruled out by Π.\nClaim (i) is proved by establishing the following, by induction on the length of ϕ:\n(∗) For all formulas ϕ(x) ∈ cl`k(O) and for each live `-tuple d of D′′, we have (dom′′,D′′) |= ϕ[d] iff ϕ ∈ µ(d).\nWe omit the proofs of (∗) and of (ii), as they proceed similarly to the proofs of Theorem 1 and 6. o"
    }, {
      "heading" : "B. PROOFS FOR SECTION 4",
      "text" : "In Section B.1, we start by establishing a central technical result about MMSNP extended with constant symbols which allows us to lift key results from MMSNP sentences to coMMSNP queries (with free variables). Then in Section B.2, we provide the proofs for the results stated in Section 4 of the main paper."
    }, {
      "heading" : "B.1 MMSNP with Constant Symbols",
      "text" : "For readability, throughout this subsection, we will adopt a more convenient notation for schemas and structures involving constant symbols. If S is a schema and c a (possibly empty) set of constant symbols, then we will use Sc as a shorthand for S ∪ c. A Scstructure B will be given by a pair (dom(B), ·B), where dom(B) is a finite, non-empty set and ·B is a function assigning to each n-ary predicate in S an n-ary relation PB over dom(B) and to each constant symbol c ∈ c an element cB ∈ dom(B). We use adom(B) to denote the active domain of B, and we call B an active domain structure if dom(B) = adom(B).\nOur objective is to establish the following theorem, which lifts the containment and dichotomy results for MMSNP sentences [24] to coMMSNP queries:\nTheorem 20 coMMSNP has a dichotomy between PTIME and CONP iff the Feder-Vardi conjecture holds. Containment of coMMSNP queries is decidable.\nWe prove Theorem 20 in several steps. We consider the language MMSNP with constant symbols (abbreviated MMSNPc), consisting of all sentences which can be obtained from MMSNP formulas by replacing each free variable by a constant symbol. The evaluation problem for MMSNPc consists in deciding whether an MMSNPc sentence with schema S and constant symbols c holds in a given Sc-structure B. The containment problem for MMSNPc is to decide for two MMSNPc sentences Ψ1,Ψ2 with relations S and constants symbols c, whether B |= Ψ1 implies B |= Ψ2 for all Scstructures B. We use Ψ1 ⊆ Ψ2 to denote containment.\nMMSNPc will serve as a bridge between coMMSNP queries (with free variables) and MMSNP sentences. More precisely, we will first show that evaluation of coMMSNP queries is polynomially equivalent to evaluation of MMSNPc sentences, and show a polynomial reduction from coMMSNP query containment to containment of MMSNPc sentences. Afterwards, we will move from MMSNPc sentences to MMSNP sentences, again showing polynomial equivalence of the evaluation problems and a polynomial reduction for containment.\nTo link coMMSNP queries and MMSNPc, it will actually prove more convenient to suppose that MMSNPc sentences are interpreted over active domain structures, whereas to relate MMSNPc with plain MMSNP, we will wish to work over arbitrary structures. Thus, as a preliminary step, we relate the two variants of the MMSNPc evaluation and containment problems.\nLemma 4 The evaluation problem for MMSNPc restricted to active domain structures is polynomially equivalent to the evaluation problem for MMSNPc (over general structures).\nProof. Let Φ = ∃X1 · · · ∃X`∀x1 · · · ∀xmϕ be an MMSNPc sentence over schema S and constants c, which is interpreted over active domain structures. Pick a fresh second-order variable Y and a fresh constant c not appearing in c. Let ϕ′ be the formula obtained from ϕ by replacing every conjunct ψ1 → ψ2 of ϕ by ψ1 → (ψ2 ∨ Y (c)). Let χ be the conjunction of all formulas of the formR(x1, . . . , xk)→ ¬Y (xi), whereR is a k-ary relation in S, and xi is one of the variables among x1, . . . , xk. Define a new MMSNPc sentence\nΦ′ = ∃X1 · · · ∃X`∃Y ∀x1 · · · ∀xm(ϕ′ ∧ χ)\nWe claim that the evaluation problem for Φ over active domain structures is polynomially equivalent to the evaluation problem for Φ′ over general structures. The first reduction is trivial since for every Sc-structure A such that dom(A) = adom(A), we have A |= Φ if and only if A |= Φ′. To see why, notice that χ ensures that Y is false everywhere on the active domain, so the additional disjuncts have no effect. For the second reduction, we remark that B |= Φ′ for a general Sc-structure B if and only if dom(B) 6= adom(B) (since we can trivially satisfy Φ′ by sending c to an element outside the active domain and including that element in Y ) or dom(B) = adom(B) and B |= Φ.\nIt remains to be shown that every evaluation problem for MMSNPc over general structures is polynomially equivalent to an evaluation problem for MMSNPc over active domain structures. Let Φ be an MMSNPc sentence with schema S and constant symbols c, and select a fresh monadic second order variable Y , a fresh input relation Elem, and and a fresh constant symbol c. We define Φ′ as the sentence over S∪{Elem}∪ c∪{c} obtained from Φ by: • replacing every conjunct ψ1 → ψ2 by ψ1 ∧ ∧ t∈T Elem(t) →\nψ2 ∨ Y (c), where T is the set of terms appearing in ψ1 → ψ2, • adding a new conjunct Elem(x)→ ¬Y (x), and\n• adding Y to the initial sequence of existentially quantified monadic second-order variables.\nWe claim that the evaluation problem for Φ over general structures is polynomially equivalent to the evaluation problem for Φ′ over active domain structures. For the first reduction, we have that for every Sc-structure B, B |= Φ if and only if B′ |= Φ′, where B′ extends B by setting ElemB ′ = dom(B) and letting cB ′\nbe any element in dom(B). For the other reduction, we have that for every S ∪ {Elem} ∪ c ∪ {c}-structure B with dom(B) = adom(B), B |= Φ′ if and only if either ElemB 6= dom(B) or B′ |= Φ, where B′ is obtained by taking the S ∪ c-reduct of B. o\nLemma 5 Containment of MMSNPc over active domain structures is polynomially reducible to containment of MMSNPc (over arbitrary structures).\nProof. Consider MMSNPc sentences Φ1,Φ2 with schema S and constants c. We apply the construction from the first part of the proof of Lemma 4 to obtain MMNSPc sentences Φ′1 and Φ′2 with the property that B |= Φ′i for a general Sc-structure B if and only if dom(B) 6= adom(B) or dom(B) = adom(B) and B |= Φi (for i ∈ {1, 2}). It is readily verified that Φ1 ⊆ Φ2 for the class of active domain structures if and only if Φ′1 ⊆ Φ′2. o\nBy the preceding lemmas, we can choose to work with active domain structures. It is then straightforward to relate the evaluation and containment problems for coMMSNP queries with the corresponding problems for MMSNPc sentences.\nLemma 6 The evaluation problem for coMMSNP is polynomially equivalent to the evaluation problem for MMSNPc. Containment of coMMSNP queries is polynomially reducible to containment of MMSNPc sentences.\nThe next step, and the core technical contribution of this subsection, is to relate the evaluation and containment of MMSNPc sentences to the analogous problems for MMSNP sentences. To simplify the technical constructions, it will prove convenient to work with forbidden pattern problems [38, 34, 12].\nWe extend forbidden patterns problems to handle constant symbols, by simply substituting S ∪ c-structures for S-structures in Definitions 1 and 2. We denote by FPPc the class of forbidden patterns problems thus defined, and use FPP to refer to the restriction to structures without constant symbols. Note that both FPPc and FPP define problems over structures, not instances (although this distinction is irrelevant in the absence of constant symbols).\nIt was shown in [38] that MMSNP sentences and FPP have the same expressive power. This result can be straightforwardly extended to handle constant symbols:\nLemma 7 MMSNPc and FPPc have the same expressive power (over structures with constant symbols).\nBy the previous lemma and the fact that FPP is a subset of FPPc, to show polynomial equivalence of MMSNPc and MMSNP it suffices to show that every problem in FPPc is polynomially equivalent to some problem in FPP. To formulate the reductions, we will require some additional notation and terminology, which we introduce next.\nLet S be a schema, c = {c1, . . . , cn} be a set of constant symbols, and P = {P1, . . . , Pn} be a set of unary predicates which do not appear in S. We will abbreviate S ∪ P to SP .\nWe define operations which allow us to transform SP -structures into Sc-structures, and vice-versa. With every SP -structure B with PBi 6= ∅ for all 1 ≤ i ≤ n, we associate the Sc-structure Bc, called the collapse of B, by factorizing through the PBi . Specifically, let ∼ be the smallest equivalence relation such that whenever d, d′ ∈ PBi for some i, then d ∼ d′. Then dom(Bc) is {[d] | d ∈ ∆B}, where [d] denotes the equivalence class of d w.r.t. ∼. For convenience, when [d] = {d}, we will use d in place of [d]. Set cB c i = [d], for some d ∈ PBi , and define RB c as follows: ([d], [e]) ∈ RB c\nif and only if there exist d′ ∈ [d] and e′ ∈ [e] such that (d′, e′) ∈ RB. Note that the mapping g : d 7→ [d] defines an S-homomorphism from B to Bc, which we call the canonical homomorphism.\nFor a Sc-structure A, we define the SP -structure Â which interprets the predicates in S in the same way as A and interprets the predicates in P as follows: P Âi = {cAi }. With every Sc-structure B, one can associate a finite set of finite SP -structures, Bac, called its anti-collapse, such that the following two properties hold:\n1. for all SP -structures A: B → Ac (and Ac is defined) if and only if there exists B′ ∈ Bac such that B′ → A.\n2. for all Sc-structures A: B→ A iff there exists B′ ∈ Bac such that B′ → Â.\nTo employ the anti-collapse Bac for the reduction of FPPc to FPP, we require some properties from the construction of Bac (cf. pages 43-45 of [1]). The domain ∆B ′ of each B′ ∈ Bac consists of ∆B \\ {cB1 , . . . , cBn } (the unnamed individuals in B) together with the union ⋃ 1≤i≤nDi of fresh non-empty (but possibly not mutually disjoint) sets D1, . . . , Dn with PB ′\ni = Di. Moreover, in Point 1 and Point 2 we have the following more detailed statement:\n(1a) if h : B → Ac (and Ac is defined), and g : A → Ac is the canonical homomorphism, then h′ : B′ → A can be chosen in such a way that h′(d) ∈ g−1(h(d)) for all unnamed individuals d in B and h′(d) ∈ g−1(cA c\ni ) for all d ∈ Di. (1b) if h : B′ → A, then h′ : B → Ac can be defined such that\nh′(cBi ) = c Ac i and h ′(d) = g(h(d)) if d is not named.\n(2b) if h : B′ → Â, then h′ : B → A can be constructed in such a way that h′(d) = h(d) for all unnamed d.\nIn what follows, we will be interested in colorings of SP - structures which respects the intuitive meaning of the predicates Pi. A C-coloring B[C] of a SP -structure B is said to be a uniform C-coloring of B if for every 1 ≤ i ≤ n, d, d′ ∈ PBi implies that d and d′ have the same color in B[C]. Given a set G of C-colored SP -structures, we define Forbun(G) as the set of SP -structures A such that there exists a uniform C-coloring A[C] of A such that there exists no G ∈ G with G→ A[C].\nWe are now ready to present the reduction from FPPc to FPP. Suppose that we are given a FPPc problem defined by the set F of C-colored Sc-structures (where C = {T1, . . . , Tk}). We construct a set G which contains all uniform C-colored SP -structures G such that\n• There exists F ∈ F and a member F′ of the anti-collapse of the Sc-reduct of F such that G is the C-coloring of F′ defined as follows: (†) d ∈ TGj iff d is unnamed in F and d ∈ TFj or there exists 1 ≤ i ≤ n such that d ∈ Di and cFi ∈ T F j .\n(Note that we require that in the resulting structure TGj ∩TGj′ = ∅ for j 6= j′, otherwise G is not in G).\nIt is easy to see that this construction guarantees that every G ∈ G is such that PGi 6= ∅ for every 1 ≤ i ≤ n.\nWe let Gu = G ∪ U , where U is the set of all SP ∪ C-structures of the form {Pi(d), Pi(e), Tj(d), T`(e)} with 1 ≤ i ≤ n and 1 ≤ j < ` ≤ k.\nNotice that Forbun(G) = Forb(Gu).\nLemma 8 FPPc is polynomially equivalent to FPP. Specifically: • For all SP -structures A, A ∈ Forb(Gu) iff Ac is undefined or\nAc ∈ Forb(F); • For all Sc-structures A, A ∈ Forb(F) iff Â ∈ Forb(Gu).\nProof. First let A be a SP -structure such that A ∈ Forb(Gu). Since Forb(Gu) = Forbun(G), we have A ∈ Forbun(G), and so there exists a uniform C-colored expansion A[C] of A such that there exists no G ∈ G with G → A[C]. Assume the collapse Ac is defined (i.e., PAi 6= ∅ for 1 ≤ i ≤ n). We want to show Ac ∈ Forb(F). By uniformity of A[C], we obtain a C-colored Sc-structure Ac[C] extending Ac by setting d ∈ TA c[C] j iff d is unnamed and d ∈ TA[C]j or d = c Ac i and P A[C] i ⊆ T A[C] j . Assume for a contradiction that h : F → Ac[C] for F ∈ F . Then h is a homomorphism from the Sc-reduct Fr of F to the Sc-reduct Ac of Ac[C]. By (1a), we find F′ ∈ (Fr)ac and h′ : F′ → A such that h′(d) ∈ g−1(h(d)) for all unnamed individuals d in Fr and h′(d) ∈ g−1(cA c\ni ) for all d ∈ Di. Let F′[C] be the C-coloring of F′ defined with (†). To see that F′[C] is well-defined, note that d ∈ Di ∩Dj implies that PF ′ i ∩P F′ j 6= ∅, which yields P A i ∩PAj 6= ∅, hence cA c i = c Ac j . It follows that c Ac i and c Ac\nj have the same colour in Ac[C], and thus also in F, which ensures that each element in F′ is assigned a unique colour by (†). Now to obtain the desired contradiction, we show that h′ is a SP ∪ C-homomorphism from F′[C] to A[C]. Let d ∈ dom(F′) and d ∈ TF ′[C] j . If d is unnamed in F, then d ∈ TF ′[C]\nj implies that d ∈ T F j . Hence h(d) ∈ T Ac[C] j and\nh′(d) ∈ g−1(h(d)) ⊆ TA[C]j . If d ∈ Di, then d ∈ T F′[C] j implies cFi ∈ T F j , hence c Ac i ∈ T Ac[C] j and P A[C] i ⊆ T A[C] j . From h\n′(d) ∈ g−1(cA c\ni ), we know that there exists a sequence A`1 , . . . , A`p of predicates from {P1, . . . , Pn} such that h′(d) ∈ AA[C]`1 ,A`p = Pi, and AA[C]`k ∩ A A[C] `k+1\n6= ∅ for every 1 ≤ k ≤ `p. By uniformity of A[C] and PA[C]i ⊆ T A[C] j , we obtain A A[C] `1\n⊆ TA[C]j , hence h′(d) ∈ TA[C]j .\nConversely, if Ac is undefined, then A ∈ Forb(Gu) since PGi 6= ∅ for all G ∈ G and 1 ≤ i ≤ n, and so any uniform C-coloring of A will avoid Gu. Assume now that Ac ∈ Forb(F). There exists a C-colored expansion Ac[C] of Ac such that there exists no F ∈ F with F→ Ac[C]. We define a (uniform) C-colored expansion A[C] of A in the obvious way; let g : A→ Ac be the canonical mapping and set TA[C]j = g −1(T Ac[C] j ), for 1 ≤ j ≤ k. Assume for a contradiction that G → A[C] for G ∈ G. Then G is obtained from some F ∈ F and some member F′ of the anti-collapse of the Sc-reduct of F as described in (†). Assume h : G → A[C]. Then h : F′ → A and so, by (1b) there exists h′ : Fr → Ac that can be defined such that h′(cF r\ni ) = c Ac i and h ′(d) = g(h(d))\nif d is not named, where Fr is the Sc-reduct of F. We derive a contradiction by showing that h′ a homomorphism from F to Ac[C]. First suppose that d ∈ TFj , and d is unnamed in F. Then d ∈ T G j , hence h(d) ∈ TA[C]j . It follows from the definition of T A[C] j that h′(d) = g(h(d)) ∈ TA c[C]\nj . Next consider the case where c F i ∈\nTFj . Then there must exist e such that e ∈ T G j and e ∈ PGi . It\nfollows that h(e) ∈ TA[C]j and h(e) ∈ P A[C] i . The definition of T A[C] j together with g(h(e)) = c Ac[C] i yields h ′(cFi ) = c Ac[C] i ∈ T Ac[C] j . The second statement follows easily from the first, since for every Sc-structure A, we have A = (Â)c. o\nLemma 9 Containment of FPPc is polynomially reducible to containment of FPP.\nProof. Consider Forb(F1) and Forb(F2), both over Sc. Let Gu,1 and Gu,2 be the corresponding FPPs over schema SP , which satisfy statements in Lemma 8. We claim that Forb(F1) ⊆ Forb(F2) iff Forb(Gu,1) ⊆ Forb(Gu,2).\nFor the first direction, suppose that Forb(F1) ⊆ Forb(F2). Let A be a ΣP -structure such that A ∈ Forb(Gu,1). If Ac is undefined, then we immediately obtain A ∈ Forb(Gu,2). Otherwise, we have Ac ∈ Forb(F1), and hence Ac ∈ Forb(F2) and A ∈ Forb(Gu,2).\nFor the second direction, suppose that Forb(Gu,1) ⊆ Forb(Gu,2), and let B be a Sc-structure such that B ∈ Forb(F1). Then applying the previous lemma, we have B̂ ∈ Forb(Gu,1), hence B̂ ∈ Forb(Gu,2). Again applying the lemma, we obtain B ∈ Forb(F2). o\nBy combining in a straightforward manner Lemmas 4 to 9, we obtain Theorem 20."
    }, {
      "heading" : "B.2 Proofs for Section 4",
      "text" : "Theorem 8. (ALC,UCQ) has a dichotomy between PTIME and CONP iff the Feder-Vardi conjecture holds. The same is true for (ALCHIU ,UCQ) and (UNFO,UCQ).\nProof. Easily obtained by combining Proposition 2 and Theorems 1, 3, 6, and 20. o\nTheorem 10. Query containment is decidable for the OBDA languages (ALC,UCQ), (ALCHIU ,UCQ), and (UNFO,UCQ).\nProof. Here again we straightforwardly combine Proposition 2 and Theorems 1, 3, 6, and 20 o\nTheorem 11. coGMSNP has the same expressive power as frontier-guarded DDlog and is strictly more expressive than coMMSNP.\nProof. The proof of the first part follows the lines of the proof of Proposition 2 and is omitted. It thus remains to show that coGMSNP is strictly more expressive than coMMSNP. Note first that it is at least as expressive: we can convert any MMSNP formula into an equivalent one satisfying conditions (i) and (ii) from the proof of Proposition 2, and clearly every such MMSNP formula is also a GMSNP formula. To see that coGMSNP is indeed strictly more expressive than coMMSNP, note that by Proposition 1, there is a (GF,UCQ) query q that is not expressible in MDDlog. By Proposition 2, q is not expressible in coMMSNP; by Theorem 7 and the first part of Theorem 11, q is expressible in coGMSNP. o\nProposition 3 GMSNP and MMSNP2 have the same expressive power.\nProof. For simplicity, we prove the result for sentences (no free variables) and without equality in the body of implications.\nWe start by proving that every MMSNP2 sentence is equivalent to a GMSNP sentence. Assume Φ = ∃X1 · · · ∃Xn∀x1 · · · ∀xmϕ\nis a MMSNP2 sentence. Introduce for each Xi a monadic SOvariable X1i and, for every R ∈ S of arity n, an n-ary SO-variable XRi . Now replace inϕ everyXi(x) byX 1 i (x) and everyXi(R(x)) by XRi (x). The resulting formula is a GMSNP sentence that is equivalent to Φ.\nConversely, assume we are given a GMSNP sentence Φ = ∃X1 · · · ∃Xn∀x1 · · · ∀xmϕ. It is straightforward to show that Φ is equivalent to a GMSNP sentence in which\n• each Xi(x) in the head of an implication is guarded by an input relation: for every Xi(x) in the head of an implication ψ there exists an R ∈ S such that R(y) is in the body of ψ and x ⊆ y. (If this is not the case, one can introduce additional conjuncts R(y) in the body of implications).\n• ϕ is closed under identifying individual variables: if ψ′ is the result of identifying variables in an implication ψ of ϕ, then ψ is a conjunct of ϕ (module renaming of individual variables).\n• the individual variables used in distinct implications of ϕ are disjoint.\nIt follows that we may also assume that distinct occurrences of SOvariables Xi in ϕ determine distinct atoms Xi(xi). From now we assume that Φ satisfies these conditions.\nFor the translation, we take for every atom A = Xi(x) in the head of an implication ψ in ϕ, a fresh second-order domain and fact variable XA. Moreover, we fix a guard RA(yA) with RA ∈ S forA from the body of the (unique) implication in whichA occurs. Consider now an implication ψ in ϕ of the form\nR1(x1) ∧ · · · ∧Rk(xk) ∧Xk+1(xk+1) ∧ · · · ∧Xn(xn) → Xn+1(xn+1) ∨ · · · ∨Xm(xm)\nFirst replace all atoms Aj = Xj(xj), n + 1 ≤ j ≤ m, by XAj (RAj (yAj )), where RAj (yAj ) is the guard for Aj selected above. Next consider every possible choice\nAk+1 = Xk+1(zk+1), . . . , An = Xn(zn)\nof atoms in the heads of implications in ϕ such that the componentwise mappings ρl : xl → zl, k + 1 ≤ l ≤ n, are bijections between the sets of variables in xl and zl and replace everyXl(xl), k + 1 ≤ l ≤ n, by\nXAl(RAl(y ′ l))\nwhere y′l is obtained from the guard RAl(yAl) associated with Al above by replacing each ρl(x) by x and each individual variable that is not in the range of ρl by some fresh individual variable. Let ψ′ be the conjunction over all implications derived from ψ in this manner, let ϕ′ be the conjunction of all of the ψ′, and let Φ′ be the resulting MMSNP2 sentence when existential quantification over non-monadic variables is replaced by existential quantification over all XA such that A an atom in a head of an implication of ϕ. Note that Φ′ contains all individual variables in Φ, but may also contain additional individual variables not in Φ.\nWe show that Φ and Φ′ are equivalent. Assume first that (adom(D),D) |= Φ′. Take an assignment π for the secondorder domain and fact variables of Φ′ such that (adom(D),D) |=π ∀x1 · · · ∀xmϕ′. For every non-monadic second-order variable X of Φ, define π(X) as the union of all\n{ρ(x) | RA(ρ(yA)) ∈ π(XA), ρ injective variable assignment},\nsuch that A = X(x) appears in the head of some implication in ϕ and RA(yA) is the guard selected for A. We show that\n(adom(D),D) |=π Φ. Assume for a contradiction that this is not the case. Take an implication ψ in ϕ of the form\nR1(x1) ∧ · · · ∧Rk(xk) ∧Xk+1(xk+1) ∧ · · · ∧Xn(xn) → Xn+1(xn+1) ∨ · · · ∨Xm(xm)\nand let ρ be an individual variable assignment such that (adom(D),D) 6|=π,ρ ψ. We may assume that ρ is injective. The following holds:\n1. for every 1 ≤ i ≤ k, we have Ri(π(xi)) ∈ D. 2. for every k + 1 ≤ i ≤ n, there exists Ai = Xi(zi) in\nthe head of some implication of ϕ with RAi(z ′ i) the guard selected for Ai, and an injective variable assignment ρi such that RAi(ρi(z ′ i)) ∈ π(XAi) and ρi(zi) = ρ(xi) ∈ π(Xi). 3. for no n + 1 ≤ i ≤ m does there exist Ai = Xi(zi) in the head of some implication of ϕ with RAi(z ′ i) the guard se-\nlected for Ai, and an injective variable assignment ρ′ such that RAi(ρ\n′(z′i)) ∈ π(XAi) and ρ′(zi) = ρ(xi) ∈ π(Xi). Consider the following sequences of atoms\nAk+1 = Xk+1(zk+1), . . . , An = Xn(zn)\nAn+1 = Xn+1(xn+1), . . . , Am = Xm(xm)\nIt follows from construction of Φ′ that the formula ϕ′ contains the implication\nζ = R1(x1) ∧ · · · ∧Rk(xk) ∧ XAk+1(RAk+1(y ′ k+1)) ∧ · · · ∧XAn(RAn(y ′ n))\n→ XAn+1(RAn+1(yAn+1)) ∨ · · · ∨XAm(RAm(yAm))\nwhere the y′i are defined in the same way as earlier. Let µ be an individual variable assignment satisfying:\n• µ(x) = ρ(x) for x in the image of ρ • µ(u) = ρi(z) if u is the fresh variable introduced to replace z ∈ z′i\nNote that such an assignment must exist since every variable in Φ′ is in the image of exactly one assignment among ρ and the ρi. It follows from the properties of µ and points 1 and 2 above that the body of the implication ζ is satisfied under assignments π, µ. From point 3, we can derive that none of the head atoms is satisfied under π, µ. It follows that the implication ζ is refuted, so (adom(D),D) 6|= Φ′, and we have the desired contradiction.\nFor the other direction, assume that (adom(D),D) |= Φ. Take an assignment π for the SO-variables of Φ such that (adom(D),D) |=π ∀x1 · · · ∀xm ϕ. Now define, for A = X(x) in the head of an implication of ϕ with selected guard RA(yA):\nπ(XA) = {RA(ρ(yA)) ∈ D | ρ(x) ∈ π(X), ρ variable assignment}\nIt can be verified that (adom(D),D) |= Φ′. o"
    }, {
      "heading" : "C. PROOFS FOR SECTION 5",
      "text" : "Theorem 12 In each case, the following query languages are equally expressive:\n• (ALCU ,AQ), (SHIU ,AQ), unary simple MDDlog, and generalized coCSP with one constant symbol;\n• (ALC,AQ), (SHI,AQ), unary connected simple MDDlog, and generalized coCSPs with one constant symbol such that all templates are identical except for the interpretation of the constant symbol;\n• (ALCU ,BAQ), (SHIU ,BAQ), Boolean simple MDDlog, and generalized coCSP;\n• (ALC,BAQ), (SHI,BAQ), Boolean connected simple MDDlog, and coCSP.\nMoreover, given the ontology-mediated query or monadic datalog program, the correponding CSP template is of at most exponential size and can be constructed in time polynomial in the size of the template.\nProof. Recall that the equivalences between the OBDA languages and fragments of monadic disjunctive datalog have been proved already. Moreover, Point 1 has been proved in the paper. It thus remains to be proved that the following query languages are equally expressive:\n(a) (ALC,AQ) and generalized coCSPs with one constant symbol such that all templates are identical except for the interpretation of the constant symbol;\n(b) (ALC,BAQ) and coCSP; (c) (ALCU ,BAQ) and generalized coCSP. We use the notation from the proof of Point 1. In particular, BT denotes the canonical S-structure with domain T . For (a), assume S, O, and A(x) are given, where O is an ALC-ontology. Let T be the set of all types τ that are realizable for O and define\nF = {(BT , τ) | τ ∈ T,A 6∈ τ}.\nOne can show that for every S-instance D and d ∈ adom(D): (D, d) → (BT , τ) for some (BT , τ) ∈ F iff d 6∈ qS,O,A(x)(D). Thus, the query defined by (S,O, A(x)) is equivalent to the query defined by F .\nConversely, assume that F is a finite set of S ∪ {c}-structures which coincide except for the interpretation of the constant symbol c, and let B be the S-reduct of these structures. Take for every d in the domain dom(B) of B a fresh concept name Ad, let A be another fresh concept name, and set\nO = {Ad v ¬Ad′ | d 6= d′} ∪ {Ad u ∃R.Ad′ v ⊥ | R(d, d′) 6∈ B, R ∈ S} ∪ {Ad uB v ⊥ | B(d) 6∈ B, B ∈ S} ∪\n{> v t d∈dom(B) Ad} ∪ { l\n(B,b)∈F\n¬Ab v A}\nOne can show that for every S-instance D and d ∈ adom(D), (D, d)→ (B, b) for some (B, b) ∈ F iff d 6∈ qS,O,A(x)(D). Thus (S,O, A(x)) expresses the same query as F .\nFor (b) assume that a query (S,O, ∃x.A(x)) ∈ (ALC,BAQ) is given. We assume w.l.o.g. thatO 6|= > v ∃U.A because otherwise we have qQ(D) = 1 for all S-instances D, and so qQ is trivial. Let T be the set of all types τ ⊆ sub(O) that are realized in a model A of O with A 6|= ∃x.A(x). Since O 6|= > v ∃U.A, the set T is non-empty. One can show that for every S-instance D: D → BT iff QS,O,∃x.A(x)(D) = 0. Thus, the query defined by (S,O, ∃x.A(x)) is equivalent to the query defined by BT .\nConversely, for a CSP template B over schema S, we construct an ontology-mediated query (S,O, q) as follows. Take for every d in the domain dom(B) of B a fresh concept name Ad, let A be\nanother fresh concept name, and set q = ∃x.A(x) and\nO = {Ad uAd′ v A | d 6= d′} ∪ {Ad u ∃R.Ad′ v A | R(d, d′) 6∈ B, R ∈ S} ∪ {Ad uB v A | B(d) 6∈ B, B ∈ S} ∪ {> v t\nd∈dom(B) Ad}\nThe query (S,O, ∃x.A(x)) is equivalent to the query defined by the template B.\nThe proof of Point (c) is similar and left to the reader. o\nTheorem 14 Query containment in (SHIU ,AQ∪BQ) is in NEXPTIME. It is NEXPTIME-hard already for (ALC, AQ) and for (ALC,BAQ).\nProof. We provide the proof of the lower bound. The proof is by reduction of a NEXPTIME-hard 2n × 2n-tiling problem. An instance of this tiling problem is given by a natural number n > 0 and a triple (T, H, V ) with T a non-empty, finite set of tile types including an initial tile Tinit to be placed on the lower left corner, H ⊆ T× T a horizontal matching relation, and V ⊆ T× T a vertical matching relation. A solution for the 2n × 2n-tiling problem for (T, H, V ) is a map f : {0, . . . , 2n−1}×{0, . . . , 2n−1} → T such that f(0, 0) = Tinit, (f(i, j), f(i + 1, j)) ∈ H for all i < 2n − 1, and (f(i, j), f(i, j + 1)) ∈ V for all j < 2n − 1. It is NEXPTIME-complete to decide whether an instance of the 2n×2ntiling problem has a solution.\nFor the reduction, let n > 0 and (T, H, V ) be an instance of the 2n × 2n-tiling problem with T = {T1, . . . , Tp}. We construct a schema S, twoALC-ontologiesO1 andO2, and a queryE(x) with E a unary relation symbol such that (T, H, V ) has a solution if and only if qS,O1,E(x) ⊆ qS,O2,E(x) if and only if qS,O1,∃x.E(x) ⊆ qS,O2,∃x.E(x).\nWe first define an ontology G (for grid) which encodes the 2n × 2n-grid. To define G, we use role names x and y to represent the 2n × 2n-grid and two binary counters X and Y for counting from 0 to 2n − 1. The counters use concept names X0, . . . , Xn−1, X0, . . . , Xn−1 and Y0, . . . , Yn−1, Y 0, . . . , Y n−1 as their bits, respectively. G contains the inclusions\nXi v ¬Xi, Y i v ¬Yi,\nfor i = 0, . . . , n− 1. Counters are relevant only if the concept\nDef = ( l\n0=1..n−1\n(Xi tXi)) u ( l\n0=1..n−1\n(Yi t Y i))\nis true. G contains the following well-known inclusions stating that the value of the counter X is incremented when going to xsuccessors (and Def is true) and the value of the counter Y is incremented when going to y-successors (and Def is true): for k = 0, . . . , n− 1,\nDef u l\nj=0..k−1\nXj v Pk\nwhere\nPk = (Xk → ∀x.(Def → Xk)) u (Xk → ∀x.(Def → Xk))\nand\nDef u t j=0..k−1 Xj v Qk\nwhere\nQk = (Xk → ∀x.(Def → Xk)) u (Xk → ∀x.(Def → Xk))\nand similarly for Y and y. G also states that the value of the counter X does not change when going to y-successors and the value of the counter Y does not change when going to x-successors: for i = 0, . . . , n− 1,\nDef uXi v ∀y.(Def → Xi), Def uXi v ∀y.(Def → Xi)\nand similarly for Y and x. In addition, G states that when the counter X is 2n − 1, there is no x-successor (with Def) and if the counter Y is 2n − 1, there is no y-successor (with Def):\nDef uX0 u · · · uXn−1 v ∀x.(Def → ⊥)\nand\nDef u Y0 u · · · u Yn−1 v ∀y.(Def → ⊥)\nThis finishes the definition of G. Define the schema\nSG = {x, y,X0, . . . , Xn−1, X0, . . . , Xn−1} ∪ {Y0, . . . , Yn−1, Y 0, . . . , Y n−1}.\nWe set O2 = G ∪ {E v E} (the latter inclusion merely serves to ensure E is part of the schema of O2).\nWe now extend G to another ontology Gt. In addition to the inclusions in G, Gt states that Tinit holds at (0, 0):\n¬X0 u · · · u ¬Xn−1 u ¬Y0 u · · · u ¬Yn−1 v Tinit\nand that the tiling is complete on Def:\nDef v t i=1..p Ti,\nNext, Gt states that if a tiling condition is violated, then a concept name E is true. For all i 6= j:\nTi u Tj v E,\nfor all (i, j) 6∈ H:\nTi u ∃x.Tj v E,\nand for all (i, j) 6∈ V :\nTi u ∃y.Tj v E.\nFinally, E is propagated along x and y:\n∃x.E v E, ∃y.E v E\nWe set O1 = Gt and show:\nClaim. The following conditions are equivalent:\n1. the 2n × 2n-tiling problem for (T, H, V ) has no solution; 2. qSG ,O1,E(x) is not contained in qSG ,O2,E(x);\n3. qSG ,O1,∃x.E(x) is not contained in qSG ,O2,∃x.E(x). Assume first that (T, H, V ) admits no 2n×2n-tiling. Define a SGinstance DG as follows. We regard the pairs (i, j) with i ≤ 2n − 1 and j ≤ 2n − 1 as constants and let • x((i, j), (i+ 1, j)) ∈ DG for i < 2n − 1 and • y((i, j), (i, j + 1)) ∈ DG for j < 2n − 1.\nWe also set\n• Xk(i, j) ∈ DG if the kth bit of i is 1, • Xk(i, j) ∈ DG if the kth bit of i is 0,\n• Yk(i, j) ∈ DG if the kth bit of j is 1, and\n• Y k(i, j) ∈ DG if the kth bit of j is 0.\nThen\n• qSG ,O2,E(x)(DG) = ∅ and\n• qSG ,O2,∃x.E(x)(DG) = 0\nsince DG counts correctly, and hence is satisfiable w.r.t. O2. However, since (T, H, V ) admits no 2n × 2n-tiling, it follows that\n• (0, 0) ∈ qSG ,O1,E(x)(DG);\n• qSG ,O1,∃x.E(x)(DG) = 1.\nWe have proved Points 2 and 3.\nConversely, assume that (T, H, V ) admits a 2n×2n-tiling given by f : {0, . . . , 2n − 1} × {0, . . . , 2n − 1} → T. We show that qSG ,O1,∃x.E(x)(D) = 0 for all SG-instances D which are satisfiable w.r.t. O2. Then Points 2 and 3 are refuted, as required.\nAssume D is satisfiable w.r.t.O2. We define a model (dom,D′) of O1 with D′ ⊇ D as follows: the domain of D′ coincides with adom(D). Symbols from SG are defined in D′ in exactly the same way as in D. To define the facts involving tile types Tk associate with every d ∈ adom(D) such that Def applies to d, the uniquely determined pair v(d) = (i, j) given to the values of the counters X and Y by Def. Then set Tk(d) ∈ D′ iff f(v(d)) = Tk. Note that D′ contains no facts involving E. It is readily checked that the resulting structure is a model of O1. o\nProposition 4. If Q = (S,O, q) is an ontology-mediated query with O formulated in equality-free FO and q a UCQ, then qQ is preserved by homomorphisms. Consequently, it follows from [43] that if qQ is FO-rewritable, then qQ is rewritable into a UCQ (thus into datalog).\nProof. Let h : D1 → D2 be a homomorphism, and a a tuple from adom(D1) such that a ∈ qQ(D1). Furthermore, suppose for the sake of contradiction that h(a) 6∈ qQ(D2). Then there is a finite relational structure (dom2,D′2) |= O such that D2 ⊆ D′2 and h(a) 6∈ q(D′2). Let (dom1,D′1) be the inverse image of (dom2,D′2) under h. More precisely, dom1 = adom(D1)∪(dom2\\adom(D2)), and D′1 contains all facts whose ĥ-image is a fact of D′2 where ĥ is the map that extends h by sending every element of adom(D′2) \\ adom(D2) to itself. Clearly, D1 ⊆ D′1. Furthermore, a 6∈ q(D′1) because ĥ : D′1 → D′2 is a homomorphism and q is preserved by homomorphisms. To obtain a contradiction against a ∈ qQ(D1), it therefore only remains to show that (dom1,D′1) |= O. It is known that equality-free first-order sentences are preserved by passing from a structure to its quotient under an equivalence relation that is a congruence. By construction, the kernel of the map ĥ is a congruence relation on the structure (dom1,D′1) and its quotient is isomorphic to (dom2,D′2).\no\nThe following lemma reduces the problem of deciding FOrewritability from generalized CSP with constants to generalized CSP without constants.\nLemma 10 Let F be a finite set of S∪ c-structures. The following conditions are equivalent:\n1. coCSP(F) is FO-definable;\n2. coCSP(Fc) is FO-definable;\nProof. If coCSP(Fc) is defined by a first-order sentence ϕ, then replacing every subformula of the form Pi(x) in ϕ by x = ci yields a first-order sentence defining coCSP(F).\nFor the converse, we make use a characterization of FOdefinability of generalized coCSPs with constants using finite obstruction sets. Let F be a finite set of S ∪ c-structures. A set D of S ∪ c-structures is an obstruction set for CSP(F) if for all S ∪ cstructures D the following conditions are equivalent:\n• there exists B ∈ F such that D→ B; • there does not exist A ∈ D such that A→ D.\nIt is known that, for any finite set of structures F , coCSP(F) is FO-definable if and only if F has a finite obstruction set. This was shown in [2] for structures without constant symbols, and follows easily from results in [43] even for the case of structures with constants. Finally, it was shown in Proposition A.2 (1) in [1] that if coCSP(F) has a finite obstruction set, then so does coCSP(Fc).\no\nThe following lemma reduces the problem of deciding FOdefinability from generalized CSP without constants to CSP without constants.\nLemma 11 Let F be a finite set of S ∪ c-structures. • If coCSP(B) is FO-definable for all B ∈ F , then coCSP(F) is\nFO-definable.\n• Conversely, if all B ∈ F are mutually homomorphically incomparable, and coCSP(F) is FO-definable, then each coCSP(B), B ∈ F , is FO-definable.\nProof. For Point 1 choose for every B ∈ F a FO-sentence ϕB such that (dom,D) |= ϕB iff D 6→ B for all S-instances D. Let ϕ be the conjunction over all ϕB with B ∈ F . Then (dom,D) |= ϕ iff D 6→ B for any B ∈ F holds for all S-instances D, as required.\nTo prove the other direction we require the notion of a critical obstruction: a S-structure A is called a critical obstruction for CSP(G) iff A 6→ B for any B ∈ G but for any proper substructure A′ of A there exists a B ∈ F such that A′ → B. It is readily checked that coCSP(G) has a finite obstruction set iff there only exist finitely many critical obstructions for CSP(G).\nFor Point 2 assume that all B ∈ F are mutually homomorphically incomparable and that coCSP(F) is FO-definable. Assume for a proof by contradiction that coCSP(B0) is not FO-definable for some B0 ∈ F . Then the set C of critical obstructions for CSP(B0) is infinite. Let B′0 be a substructure of B′0 such that no proper substructure of B0 can be homomorphically mapped to any B ∈ F \\ {B0}. It is readily checked that the set C′ of disjoint unions A ∪B′0, A ∈ C, are critical obstructions for CSP(F). Thus coCSP(F) is not FO-definable and we have derived a contradiction. o\nNext, we move on the datalog-definability.\nLemma 12 Let F be a finite set of S ∪ c-structures. 1. If coCSP(Bc) is datalog-definable for all B ∈ F , then\ncoCSP(F) is datalog-definable. 2. Conversely, if all B ∈ F are mutually homomorphically in-\ncomparable, and coCSP(F) is datalog-definable, then each coCSP(Bc), B ∈ F , is datalog-definable.\nProof. (1) If each coCSP(Bc) is datalog-definable, then, since datalog is closed under conjunction, we also have that coCSP(Fc) is datalog-definable. Let Π be a datalog program that defines\ncoCSP(Fc). A datalog program Π′ defining coCSP(F) may be obtained from Π by replacing every Pi(x) with x = ci.\nFor (2), we make use of a characterization of datalog-definability in terms of obstruction sets of bounded treewidth. Recall from the proof of Lemma 10 the notion of an obstruction set for a set of structures. Suppose that coCSP(F) is definable by a datalog program whose rules contain at most k variables. Then F has an obstruction set of treewidth k, namely, the set of all canonical structures of non-recursive datalog programs obtained by unfolding the given datalog program finitely many times (a standard argument).\nWe claim that, in fact, each B ∈ F has an obstruction set of treewidth k. We prove this claim by contraposition: if some B ∈ F does not have an obstruction set of treewidth at most k, there is a structure A such that A 6→ B, while, at the same time, B′ → A implies B′ → B for all structures B′ of treewidth at most k. Now, take A′ to be the disjoint union of A and B. Then we have that A 6→ F (here, we are using also the fact that F consists of homomorphically incomparable structures). At the same time, B′ → A implies B′ → B for all structures B′ of treewidth at most k. Therefore, coCSP(F) has no obstruction set of bounded treewidth, a contradiction.\nSo far, we have shown that, for each B ∈ F , coCSP(B) has an obstruction set of bounded tree width. By Proposition A.2 (1) in [1], we have that, for all structures A with constant symbols, if coCSP(A) has an obstruction set of bounded treewidth, then coCSP(Ac) has an obstruction set of bounded treewidth too (although it is not explicitly stated, it can easily be verified that the relevant construction used there preserves bounded treewidth). Thus, we obtain that, for each B ∈ F , coCSP(Bc) has an obstruction set of bounded width. It was shown in [24] that, for any structure A without constant symbols, coCSP(A) is datalog-definable if and only if A has an obstruction set of bounded tree-width. Therefore we have that, for each B ∈ F , coCSP(Bc) is datalog-definable.\no\nThe above lemmas, together, establish Proposition 5. We now proceed with the proof of Theorem 16. We now give the lower bound proofs for Theorem 16.\nLemma 13 It is NEXPTIME-hard to decide FO-rewritability of queries in (ALC,AQ) and of queries in (ALC,BAQ).\nProof. We prove the lower bound and employ for the reduction the same tiling problem as in the lower bound proof of Theorem 14. We also employ the ontologies constructed in the proof of Theorem 14.\nFor the reduction, let n > 0 and (T, H, V ) be an instance of the 2n × 2n-tiling problem with T = {T1, . . . , Tp}. We construct a schema S, anALC-ontologyO and a queryA(x) such that (T, H, V ) has a solution if and only if qS,O,A(x) is FO-rewritable if and only if qS,O,∃x.A(x) is FO-rewritable.\nWe consider the ontology G, its extension Gt, and the schema SG from the proof of Theorem 14. To define O, we take a fresh role name S and two concept names A and F and set"
    }, {
      "heading" : "O = Gt ∪ {∃S.E v E,E u F v A}",
      "text" : "and S = SG ∪ {S, F}.\nClaim. The following conditions are equivalent:\n• (T, H, V ) admits no 2n × 2n-tiling;\n• qS,O,A(x) is not FO-rewritable;\n• qS,O,∃x.A(x) is not FO-rewritable.\nAssume that (T, H, V ) admits no 2n × 2n-tiling. qS,O,A(x) is not FO-rewritable iff there does not exist a finite set D of S ∪ {c}structures (an obstruction set) such that the following conditions are equivalent for every S-instance D and d ∈ adom(D): 1. d ∈ qS,O,A(x)(D). 2. there exists A ∈ D such that (A, a)→ (D, d). We show that no finite obstruction set exists. To this end, we define S-instances Dm as the union of DG and the facts\nF (a0), S(a0, a1), . . . , S(am, (0, 0)).\nIt is readily checked that\n• a0 ∈ qS,O,A(x)(Dm) for all m > 0; • a0 6∈ qS,O,A(x)(D′m), where D′m results from Dm by removing\nsome fact (ak, ak+1) from Dm.\nIt follows immediately that no finite obstruction set exists. The argument for qS,O,∃x.A(x) is similar.\nConversely, assume that (T, H, V ) has a 2n × 2n-tiling given by f : {0, . . . , 2n − 1} × {0, . . . , 2n − 1} → T. We have to show that there exists an FO-formula ϕ(x) over S such that for all S-instances D and d ∈ adom(D), (adom(D),D) |= ϕ[d] iff d ∈ qS,O,A(x)(D).\nNote that one can easily construct a first-order sentence ϕG over SG such that, for all SG-instances D, the following are equivalent:\n• D is not satisfiable w.r.t. G; • (adom,D) |= ϕG .\nWe fix such a sentence ϕG and show that the following are equivalent for every S-instance D:\n• (adom(D),D) |= ϕG ; • d ∈ qS,O,A(x)(D).\nThe direction from Point 1 to Point 2 is trivial. Conversely, assume that (adom(D),D) 6|= ϕG . Then D is satisfiable w.r.t. G. We define a model (dom,D′) ofO with D′ ⊇ D as follows. The domain of D′ coincides with adom(D). Symbols from S are defined in D′ in exactly the same way as in D. To define the facts involving tile types Tk, associate with every d ∈ adom(D) such that Def applies to d, the uniquely determined pair v(d) = (i, j) given to the values of the counters X and Y by Def. Then set Tk(d) ∈ D′ iff f(v(d)) = Tk. Note that D′ contains no facts involving E or A. It is readily checked that the resulting structure is a model of O, as required. o\nLemma 14 It is NEXPTIME-hard to decide datalog-rewritability of queries in (ALC,AQ) and of queries in (ALC,BAQ).\nProof. The proof is based on a modification of the proof of Lemma 13. For the reduction, let n > 0 and (T, H, V ) be an instance of the 2n × 2n-tiling problem with T = {T1, . . . , Tp}. We construct a schema S, anALC-ontologyO′ and a queryA(x) such that (T, H, V ) has a solution if and only if qS,O′,A(x) is datalogrewritable if and only if qS,O′,∃x.A(x) is datalog-rewritable.\nWe consider the ontology G, its extension Gt, and the schema SG from the proof of Theorem 14. To define O′ we take fresh role names S and H and fresh concept names P1, P2, P3 and encode the 3-colorability problem as follows:\nO′ = Gt ∪ {∃S.E v E,∃H.A v A} ∪ {E v P1 t P2 t P3} ∪ {Pi u Pj v A | 1 ≤ i < j ≤ 3} ∪ {Pi u ∃H.Pi v A | 1 ≤ i ≤ 3}\nand S = SG ∪ {S,H}.\nClaim. The following conditions are equivalent:\n• (T, H, V ) admits no 2n × 2n-tiling; • qS,O′,A(x) is not datalog-rewritable; • qS,O′,∃x.A(x) is not datalog-rewritable.\nAssume that (T, H, V ) admits no 2n × 2n-tiling. For any connected undirected graphG, we identify some v inGwith (0, 0) and define a S-instance D as the union of DG and the facts S(d, d′) for all d, d′ in G and H(d, d′) for every edge {d, d′} in G. It is readily checked that\n• (0, 0) ∈ qS,O′,A(x)(D) iff G is not 3-colorable; • qS,O′,∃x.A(x)(D) = 1 iff G is not 3-colorable.\nIt follows immediately that neither qS,O′,A(x) nor qS,O′,∃x.A(x) are datalog-rewritable.\nConversely, if (T, H, V ) admits a 2n × 2n-tiling then one can show datalog-rewritability using exactly the same argument as in the proof of Lemma 13. o\nWe now prove the undecidability results forALCF . In [10, 36], alternative definitions of query containment and FO-rewritability are employed which consider only instances that are satisfiable w.r.t. the ontologies involved. We say that (S,O1, q1) is contained in (S,O2, q2) w.r.t. consistent instances if q(S,O1,q1)(D) ⊆ q(S,O2,q2)(D) for all S-instance D such that D is satisfiable w.r.t. O1. Similarly, a query (S,O, q) is FO-rewritable w.r.t consistent instances if there exists an FO-query q′ such that q′(D) = q(S,O,q)(D) for all S-instance D that are satisfiable w.r.t. O. Undecidability of query containment w.r.t. consistent instances and of FO-rewritability w.r.t. consistent instances were proven respectively in [10] and [36]. Here we show how the proofs can be modified to work for query containment, FO-rewritability, and datalog rewritability as defined in this paper.\nTheorem 21 Query containment, FO-rewritability, and datalogrewritability are all undecidable for queries in (ALCF ,AQ) and queries in (ALCF ,BAQ).\nProof. The proof is by reduction of the following finite rectangle tiling problem. An instance of the finite rectangle tiling problem is given by a triple P = (T, H, V ) with\n• T = {T1, . . . , Tp} a non-empty, finite set of tile types including an initial tile Tinit to be placed on the lower left corner, a final tile Tfinal to be placed on the upper right corner, and sets U ⊆ T and R ⊆ T of tile types to be placed on the upper and right borders respectively, satisfying U ∩R = {Tfinal}; • H ⊆ T× T a horizontal matching relation; and • V ⊆ T× T a vertical matching relation.\nA tiling for (T, H, V ) is a map f : {0, . . . , n}× {0, . . . ,m} → T such that n,m ≥ 0, • f(0, 0) = Tinit, • f(n,m) = Tfinal, • f(n, j) ∈ R for all 0 ≤ j ≤ m; • f(j, i) 6∈ R for all j < n and 0 ≤ i ≤ m; • f(i,m) ∈ U for all 0 ≤ i ≤ n; • f(i, j) 6∈ U for all 0 ≤ i ≤ n and 1 ≤ j < m. • (f(i, j), f(i+ 1, j)) ∈ H for all 0 ≤ i < n, and\n• (f(i, j), f(i, j + 1)) ∈ v for all 0 ≤ i < m. Thus, we can assume that H , V , U, and R are such that:\n• if (Ti, Tj) ∈ H , then Ti ∈ U if and only if Tj ∈ U; • if Ti ∈ U, then there exists no Tj with (Ti, Tj) ∈ V or\n(Tj , Ti) ∈ V ; • if (Ti, Tj) ∈ V , then Ti ∈ R if and only if Tj ∈ R; • if Ti ∈ R, then there exists no Tj with (Ti, Tj) ∈ H or\n(Tj , Ti) ∈ H . It is undecidable whether an instance P of the finite rectangle tiling problem has a tiling.\nFix a particular P = (T, H, V ). For the data schema, we use S = {T1, . . . , Tp, x, y, x−, y−}, where T1, . . . , Tp are treated as concept names, and x, y, x−, and y− are role names. We use x and y to specify horizontal and vertical adjacency of points in the rectangle, and the role names x− and y− to simulate the inverses of x and y (note that since x− and y− are regular role names, they need not be interpreted as the inverses of x and y). We construct an ALCF -ontology OP which asserts functionality of x, y, x−, y− and contains inclusions using additional concept names U,R, Y, Ix, Iy, C, Zc,1, Zc,2, Zx,1, Zx,2, Zy,1. The concept names U and R are used to mark the upper and right border of the rectangle, Y is used to mark points in the rectangle, and the remaining concept names are used for technical purposes explained below. In the following, for e ∈ {c, x, y}, we let Be range over all Boolean combinations of the concept names Ze,1 and Ze,2, i.e., over all concepts L1 u L2 where Li is a literal over Ze,i, for i ∈ {1, 2}. The ontology OP contains the following concept inclusions, where (Ti, Tj) ∈ H and (Ti, T`) ∈ V :\nTfinal v Y u U uR ∃x.(U u Y u Tj) u Ix u Ti v U u Y ∃y.(R u Y u T`) u Iy u Ti v R u Y\n∃x.(Tj u Y u ∃y.Y ) u∃y.(T` u Y u ∃x.Y )\nuIx u Iy u C u Ti v Y ∃x.∃y.Bc u ∃y.∃x.Bc v C Bx u ∃x.∃x−.Bx v Ix By u ∃y.∃y−.By v Iy\nTi v ∀y.⊥ Tj v ∀x.⊥ U v ∀x.U R v ∀y.R\nt 1≤s<t≤p Ts u Tt v ⊥\nwhere Ti ∈ U and Tj ∈ R. The first four inclusions propagate the concept Y downwards and leftwards starting from a point marked with the final tile Tfinal. Note that these inclusions enforce the horizontal and vertical matching conditions. The concept inclusion with right-hand side C serves to enforce confluence, i.e., C is entailed at a constant a if there is a constant b that is both an x-y-successor and a y-x-successor of a. This is so because, intuitively, Bc is universally quantified: if confluence fails, then we can interpret Zc,1 and Zc,2 so that neither of the two conjuncts on the left-hand side of the inclusion for C is satisfied. In a similar manner, the inclusion for Ix (resp. Iy) is used to ensure that x− (resp. y−) act as the inverse of x (resp. y) at all points in the rectangle.\nThe following property can be obtained by a minor modification of Lemma 30 in [3]:\nLemma 15 P admits a tiling if and only if there is a Sinstance D which is consistent with OP and such that qS,OP,Tinit(x)∧Y (x)(D) 6= ∅.\nLet ϕP be the first-order translation of the conjunction of all Ti v ∀y.⊥, Ti ∈ U, Tj v ∀x.⊥, Tj ∈ R, and of t\n1≤s<t≤p Ts u\nTt v ⊥. The following is readily checked:\nClaim. For all S-instances D, (adom(D),D) |= ϕP iff D is satisfiable w.r.t. OP.\nWe now prove undecidability of query containment. Let E be a fresh concept name and let\nO2 = OP ∪ {E v E}, O1 = OP ∪ {Y u Tinit v E}\nNow one can prove that the following conditions are equivalent:\n• P admits a tiling; • (S,O1, E(x)) is not contained in (S,O2, E(x)); • (S,O1, ∃x.E(x)) is not contained in (S,O2,∃x.E(x))\nAssume first that P admits a tiling. Then by Lemma 15, there is a S-instance D which is consistent with OP and such that qS,OP,Tinit(x)∧Y (x)(D) 6= ∅. It follows immediately that qS,O1,E(x)(D) 6= ∅ and qS,O1,∃x.E(x)(D) = 1. On the other hand, since D is consistent with O2, and E appears only trivially in O2, we have qS,O2,E(x)(D) = ∅ and qS,O2,∃x.E(x)(D) = 0.\nNext suppose that P does not admit a tiling, and let D be an S-instance which is consistent with O1. By Lemma 15, qS,OP,Tinit(x)∧Y (x)(D) = ∅, and hence qS,O1,∃x.E(x)(D) = 0. The desired containments trivially follow.\nTo prove undecidability of FO-rewritability, we expand O1 to a new ontology O3. To define O3 we take a fresh role name S and two concept names A and F and set"
    }, {
      "heading" : "O3 = O1 ∪ {∃S.E v E,E u F v A}",
      "text" : "and S3 = S ∪ {S, F}.\nClaim. The following conditions are equivalent:\n• P admits a tiling; • qS3,O3,A(x) is not FO-rewritable; • qS3,O3,∃x.A(x) is not FO-rewritable.\nAssume first that P admits a tiling. By Lemma 15, we can find an S-instance DP which is consistent with OP and b ∈ adom(DP) such that b ∈ qS,OP,Tinit(x)∧Y (x)(DP), and hence b ∈ qS,O1,E(x)(DP). We can use essentially the same argument as in Lemma 13 to show that qS,O1,E(x) and qS,O1,E(x) are not FOrewritable. Specifically, we construct S-instances Dm by taking the union of DP and the facts\nF (a0), S(a0, a1), . . . , S(am, b).\nIt is readily checked that\n• a0 ∈ qS3,O3,A(x)(Dm) for all m > 0; • a0 6∈ qS3,O3,A(x)(D ′ m), where D′m results from Dm by remov-\ning some fact (ak, ak+1) from Dm.\nIt follows that no finite obstruction set exists, and hence that qS,O1,A(x) is not FO-rewritable. We can proceed similarly for qS,O1,∃x.A(x).\nAssume now that P does not admit a tiling. Then for every S-instance D, D is satisfiable w.r.t. OP if and only if\nqS,O3,∃x.A(x)(D) = 0. Thus, the query defined by ¬ϕP is equivalent to qS,O3,∃x.A(x), and the query defined by (x = x) ∧ ¬ϕP is equivalent to qS,O3,A(x).\nTo prove undecidability of datalog-rewritability, we expand O1 to a new ontology O4. To define O4, we take fresh role names S and H and fresh concept names P1, P2, P3 and encode the 3- colorability problem as follows:\nO4 = G1 ∪ {∃S.E v E,∃H.A v A} ∪ {E v P1 t P2 t P3} ∪ {Pi u Pj v A | 1 ≤ i < j ≤ 3} ∪ {Pi u ∃H.Pi v A | 1 ≤ i ≤ 3}\nWe use the schema S4 = S ∪ {S,H}.\nClaim. The following conditions are equivalent:\n• P admits a tiling; • qS4,O4,A(x) is not datalog-rewritable; • qS4,O4,∃x.A(x) is not datalog-rewritable.\nFirst suppose that P admits a tiling. We have seen previously that this implies the existence of an S-instance DP which is consistent with OP and contains b ∈ adom(DP) such that b ∈ qS,O1,E(x)(DP). We proceed similarly to Lemma 14. Given a connected undirected graph G, we define an S-instance D as the union of DP and the facts S(d, d′) for all d, d′ in G and H(d, d′) for every edge {d, d′} in G. It is readily checked that • b ∈ qS4,O4,A(x) iff G is not 3-colorable; • qS4,O4,∃x.A(x)(D) = 1 iff G is not 3-colorable.\nIt follows directly that neither qS,O′,A(x) nor qS,O′,∃x.A(x) are datalog-rewritable.\nNext suppose that P does not admit a tiling. Then for every S-instance D, we have that D is satisfiable w.r.t. OP if and only if qS,O4,∃x.A(x)(D) = 0. We can then simply reuse the FOrewritings ¬ϕP and (x = x) ∧ ¬ϕP from above, since these can be equivalently expressed as datalog queries. o"
    } ],
    "references" : [ {
      "title" : "Characterizing schema mappings via data examples",
      "author" : [ "B. Alexe", "B. ten Cate", "P.G. Kolaitis", "W.C. Tan" ],
      "venue" : "ACM Trans. Database Syst.,",
      "citeRegEx" : "1",
      "shortCiteRegEx" : "1",
      "year" : 2011
    }, {
      "title" : "On digraph coloring problems and treewidth duality",
      "author" : [ "A. Atserias" ],
      "venue" : "In LICS,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2005
    }, {
      "title" : "Query and predicate emptiness in description logics",
      "author" : [ "F. Baader", "M. Bienvenu", "C. Lutz", "F. Wolter" ],
      "venue" : "In KR,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2010
    }, {
      "title" : "The Description Logic Handbook",
      "author" : [ "F. Baader", "D. Calvanese", "D.L. McGuiness", "D. Nardi", "P. Patel-Schneider", "editors" ],
      "venue" : null,
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2003
    }, {
      "title" : "Walking the complexity lines for generalized guarded existential rules",
      "author" : [ "J.-F. Baget", "M.-L. Mugnier", "S. Rudolph", "M. Thomazo" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Querying the guarded fragment",
      "author" : [ "V. Bárány", "G. Gottlob", "M. Otto" ],
      "venue" : "In LICS,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 2010
    }, {
      "title" : "Constraint satisfaction problems of bounded width",
      "author" : [ "L. Barto", "M. Kozik" ],
      "venue" : "In FOCS,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2009
    }, {
      "title" : "Query containment in description logics reconsidered",
      "author" : [ "M. Bienvenu", "C. Lutz", "F. Wolter" ],
      "venue" : "In KR,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2012
    }, {
      "title" : "Modal Logic",
      "author" : [ "P. Blackburn", "M. de Rijke", "Y. Venema" ],
      "venue" : null,
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2001
    }, {
      "title" : "On the complexity of MMSNP",
      "author" : [ "M. Bodirsky", "H. Chen", "T. Feder" ],
      "venue" : "SIAM J. Discrete Math.,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2012
    }, {
      "title" : "On the CSP dichotomy conjecture",
      "author" : [ "A.A. Bulatov" ],
      "venue" : "In CSR,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2011
    }, {
      "title" : "A general datalog-based framework for tractable query answering over ontologies",
      "author" : [ "A. Calì", "G. Gottlob", "T. Lukasiewicz" ],
      "venue" : "In PODS,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2009
    }, {
      "title" : "Towards more expressive ontology languages: The query answering problem",
      "author" : [ "A. Calì", "G. Gottlob", "A. Pieris" ],
      "venue" : "Artif. Intell.,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2012
    }, {
      "title" : "Data complexity of query answering in description logics",
      "author" : [ "D. Calvanese", "G.D. Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "In KR,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2006
    }, {
      "title" : "Tractable reasoning and efficient query answering in description logics: The DL-Lite family",
      "author" : [ "D. Calvanese", "G.D. Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : "18",
      "year" : 2007
    }, {
      "title" : "On the decidability of query containment under constraints",
      "author" : [ "D. Calvanese", "G.D. Giacomo", "M. Lenzerini" ],
      "venue" : "In PODS,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1998
    }, {
      "title" : "Computing Datalog Rewritings Beyond Horn Ontologies",
      "author" : [ "B. Cuenca Grau", "M. Kaminski", "B. Motik" ],
      "venue" : "In IJCAI,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 2013
    }, {
      "title" : "Disjunctive datalog",
      "author" : [ "T. Eiter", "G. Gottlob", "H. Mannila" ],
      "venue" : "ACM Trans. Database Syst.,",
      "citeRegEx" : "21",
      "shortCiteRegEx" : "21",
      "year" : 1997
    }, {
      "title" : "Towards practical query answering for Horn-SHIQ",
      "author" : [ "T. Eiter", "M. Ortiz", "M. Simkus", "T.-K. Tran", "G. Xiao" ],
      "venue" : "In DL,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2012
    }, {
      "title" : "Dichotomies for classes of homomorphism problems involving unary functions",
      "author" : [ "T. Feder", "F.R. Madelaine", "I.A. Stewart" ],
      "venue" : "Theor. Comput. Sci.,",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2004
    }, {
      "title" : "The computational structure of monotone monadic SNP and constraint satisfaction: A study through datalog and group theory",
      "author" : [ "T. Feder", "M.Y. Vardi" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 1998
    }, {
      "title" : "Generalised dualities and maximal finite antichains in the homomorphism order of relational structures",
      "author" : [ "J. Foniok", "J. Nesetril", "C. Tardif" ],
      "venue" : "Eur. J. Comb.,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2008
    }, {
      "title" : "Datalog LITE: a deductive query language with linear time model checking",
      "author" : [ "G. Gottlob", "E. Grädel", "H. Veith" ],
      "venue" : "ACM Trans. Comput. Log.,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2002
    }, {
      "title" : "Rewriting ontological queries into small nonrecursive datalog programs",
      "author" : [ "G. Gottlob", "T. Schwentick" ],
      "venue" : "In KR,",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2012
    }, {
      "title" : "Reasoning in description logics by a reduction to disjunctive datalog",
      "author" : [ "U. Hustadt", "B. Motik", "U. Sattler" ],
      "venue" : "J. Autom. Reasoning,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2007
    }, {
      "title" : "Exponential lower bounds and separation for query rewriting",
      "author" : [ "S. Kikot", "R. Kontchakov", "V.V. Podolskii", "M. Zakharyaschev" ],
      "venue" : "In ICALP,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2012
    }, {
      "title" : "The combined approach to query answering in DL-Lite",
      "author" : [ "R. Kontchakov", "C. Lutz", "D. Toman", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "In KR,",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2010
    }, {
      "title" : "Data complexity in the EL family of DLs",
      "author" : [ "A. Krisnadhi", "C. Lutz" ],
      "venue" : "In LPAR,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2007
    }, {
      "title" : "Constraints, MMSNP, and Expander Structures",
      "author" : [ "G. Kun" ],
      "venue" : "http://arxiv.org/abs/0706.1701v1,",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2007
    }, {
      "title" : "Forbidden lifts (NP and CSP for combinatorialists)",
      "author" : [ "G. Kun", "J. Nesetril" ],
      "venue" : "Eur. J. Comb.,",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2008
    }, {
      "title" : "A characterisation of first-order constraint satisfaction problems",
      "author" : [ "B. Larose", "C. Loten", "C. Tardif" ],
      "venue" : "Logical Methods in Comp. Sci.,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2007
    }, {
      "title" : "Non-uniform data complexity of query answering in description logics",
      "author" : [ "C. Lutz", "F. Wolter" ],
      "venue" : "In KR,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2012
    }, {
      "title" : "Universal structures and the logic of forbidden patterns",
      "author" : [ "F.R. Madelaine" ],
      "venue" : "Logical Methods in Comp. Sci.,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2009
    }, {
      "title" : "Constraint satisfaction, logic and forbidden patterns",
      "author" : [ "F.R. Madelaine", "I.A. Stewart" ],
      "venue" : "SIAM J. Comput.,",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2007
    }, {
      "title" : "Reasoning in description logics using resolution and deductive databases",
      "author" : [ "B. Motik" ],
      "venue" : "PhD thesis,",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2006
    }, {
      "title" : "Linking data to ontologies",
      "author" : [ "A. Poggi", "D. Lembo", "D. Calvanese", "G.D. Giacomo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "J. Data Semantics,",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2008
    }, {
      "title" : "Models of program logics",
      "author" : [ "V.R. Pratt" ],
      "venue" : "In FoCS,",
      "citeRegEx" : "41",
      "shortCiteRegEx" : "41",
      "year" : 1979
    }, {
      "title" : "Improving Query Answering over DL-Lite Ontologies",
      "author" : [ "R. Rosati", "A. Almatelli" ],
      "venue" : "In KR,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2010
    }, {
      "title" : "Homomorphism preservation theorems",
      "author" : [ "B. Rossman" ],
      "venue" : "J. ACM,",
      "citeRegEx" : "43",
      "shortCiteRegEx" : "43",
      "year" : 2008
    }, {
      "title" : "Type-elimination-based reasoning for the description logic SHIQbs using decision diagrams and disjunctive datalog",
      "author" : [ "S. Rudolph", "M. Krötzsch", "P. Hitzler" ],
      "venue" : "Logical Methods in Comp. Sci.,",
      "citeRegEx" : "44",
      "shortCiteRegEx" : "44",
      "year" : 2012
    }, {
      "title" : "Elimination of complex RIAs without automata",
      "author" : [ "F. Simancik" ],
      "venue" : "In DL,",
      "citeRegEx" : "45",
      "shortCiteRegEx" : "45",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 15,
      "context" : "provided by an ontology [19, 18, 16].",
      "startOffset" : 24,
      "endOffset" : 36
    }, {
      "referenceID" : 14,
      "context" : "provided by an ontology [19, 18, 16].",
      "startOffset" : 24,
      "endOffset" : 36
    }, {
      "referenceID" : 12,
      "context" : "provided by an ontology [19, 18, 16].",
      "startOffset" : 24,
      "endOffset" : 36
    }, {
      "referenceID" : 35,
      "context" : "A third prominent application of OBDA is in data integration, where an ontology can be used to provide a uniform view on multiple data sources [40].",
      "startOffset" : 143,
      "endOffset" : 147
    }, {
      "referenceID" : 13,
      "context" : "For popular choices of ontology languages, the data complexity of ontology-mediated queries can be CONP-complete, which has resulted in extensive research on finding tractable classes of ontology-mediated queries, as well as on finding classes of ontology-mediated queries that are amenable to efficient query answering techniques [17, 29, 32].",
      "startOffset" : 331,
      "endOffset" : 343
    }, {
      "referenceID" : 24,
      "context" : "For popular choices of ontology languages, the data complexity of ontology-mediated queries can be CONP-complete, which has resulted in extensive research on finding tractable classes of ontology-mediated queries, as well as on finding classes of ontology-mediated queries that are amenable to efficient query answering techniques [17, 29, 32].",
      "startOffset" : 331,
      "endOffset" : 343
    }, {
      "referenceID" : 27,
      "context" : "For popular choices of ontology languages, the data complexity of ontology-mediated queries can be CONP-complete, which has resulted in extensive research on finding tractable classes of ontology-mediated queries, as well as on finding classes of ontology-mediated queries that are amenable to efficient query answering techniques [17, 29, 32].",
      "startOffset" : 331,
      "endOffset" : 343
    }, {
      "referenceID" : 14,
      "context" : "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].",
      "startOffset" : 145,
      "endOffset" : 165
    }, {
      "referenceID" : 23,
      "context" : "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].",
      "startOffset" : 145,
      "endOffset" : 165
    }, {
      "referenceID" : 25,
      "context" : "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].",
      "startOffset" : 145,
      "endOffset" : 165
    }, {
      "referenceID" : 26,
      "context" : "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].",
      "startOffset" : 145,
      "endOffset" : 165
    }, {
      "referenceID" : 37,
      "context" : "This is considered one of the most promising approaches for OBDA, and is currently the subject of significant research activity, see for example [18, 28, 30, 31, 42].",
      "startOffset" : 145,
      "endOffset" : 165
    }, {
      "referenceID" : 11,
      "context" : "As ontology languages, we consider a range of standard description logics (DLs) and several fragments of first-order logic that embed ontology languages such as Datalog± [15], namely the guarded fragment (GF), the unary negation fragment (UNFO), and the guarded negation fragment (GNFO).",
      "startOffset" : 170,
      "endOffset" : 174
    }, {
      "referenceID" : 20,
      "context" : "The widely known FederVardi conjecture [24] states that there is a dichotomy between PTIME and NP for the class of all CSPs, that is, each CSP is either in PTIME or NP-hard.",
      "startOffset" : 39,
      "endOffset" : 43
    }, {
      "referenceID" : 20,
      "context" : "Monotone monadic strict NP without inequality (abbreviated MMSNP) was introduced by Feder and Vardi as a logical generalization of CSP that enjoys similar computational properties [24].",
      "startOffset" : 180,
      "endOffset" : 184
    }, {
      "referenceID" : 20,
      "context" : "In particular, it was shown in [24, 33] that there is a dichotomy between PTIME and NP for MMSNP sentences if and only if the Feder-Vardi conjecture holds.",
      "startOffset" : 31,
      "endOffset" : 39
    }, {
      "referenceID" : 28,
      "context" : "In particular, it was shown in [24, 33] that there is a dichotomy between PTIME and NP for MMSNP sentences if and only if the Feder-Vardi conjecture holds.",
      "startOffset" : 31,
      "endOffset" : 39
    }, {
      "referenceID" : 10,
      "context" : "Significant progress has been made in understanding the complexity of CSPs and MMSNPs [14, 12, 34], and the connection established in this paper facilitates the transfer of techniques and results from CSP and MMSNP in order to analyze the data complexity of query evaluation in (ALC,UCQ).",
      "startOffset" : 86,
      "endOffset" : 98
    }, {
      "referenceID" : 9,
      "context" : "Significant progress has been made in understanding the complexity of CSPs and MMSNPs [14, 12, 34], and the connection established in this paper facilitates the transfer of techniques and results from CSP and MMSNP in order to analyze the data complexity of query evaluation in (ALC,UCQ).",
      "startOffset" : 86,
      "endOffset" : 98
    }, {
      "referenceID" : 29,
      "context" : "Significant progress has been made in understanding the complexity of CSPs and MMSNPs [14, 12, 34], and the connection established in this paper facilitates the transfer of techniques and results from CSP and MMSNP in order to analyze the data complexity of query evaluation in (ALC,UCQ).",
      "startOffset" : 86,
      "endOffset" : 98
    }, {
      "referenceID" : 32,
      "context" : "We observe that GMSNP has the same expressive power as the extension MMSNP2 of MMSNP proposed in [37].",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 32,
      "context" : "It follows from our results in Section 3 that GMSNP (and thus MMSNP2) is strictly more expressive than MMSNP, closing an open problem from [37].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 20,
      "context" : "It was shown in [24] that containment between MMSNP sentences is decidable.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 7,
      "context" : "Note that this refers to a very general form of query containment in OBDA, as recently introduced and studied in [10].",
      "startOffset" : 113,
      "endOffset" : 117
    }, {
      "referenceID" : 30,
      "context" : "Finally, taking advantage of recent results for CSPs [35, 26, 13], we are able to show that FO-rewritability and datalog-rewritability, as properties of ontology-mediated queries, are decidable and NEXPTIMEcomplete for (ALC, AQ) and (ALC,BAQ).",
      "startOffset" : 53,
      "endOffset" : 65
    }, {
      "referenceID" : 34,
      "context" : "Related Work A connection between query answering in DLs and the negation-free fragment of disjunctive datalog was first discovered and utilized in the influential [39, 29], see also [44].",
      "startOffset" : 164,
      "endOffset" : 172
    }, {
      "referenceID" : 24,
      "context" : "Related Work A connection between query answering in DLs and the negation-free fragment of disjunctive datalog was first discovered and utilized in the influential [39, 29], see also [44].",
      "startOffset" : 164,
      "endOffset" : 172
    }, {
      "referenceID" : 39,
      "context" : "Related Work A connection between query answering in DLs and the negation-free fragment of disjunctive datalog was first discovered and utilized in the influential [39, 29], see also [44].",
      "startOffset" : 183,
      "endOffset" : 187
    }, {
      "referenceID" : 31,
      "context" : "A connection between DL-based OBDA and CSPs was first found and exploited in [36], in a setup that is different from the one studied in this paper.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 31,
      "context" : "In particular, instead of focusing on ontology-mediated queries that consist of a data schema, an ontology, and a database query, [36] concentrates on ontologies while quantifying universally over all database queries and without fixing a data schema.",
      "startOffset" : 130,
      "endOffset" : 134
    }, {
      "referenceID" : 5,
      "context" : "Note that all ontology languages considered in this paper enjoy finite controllability, meaning that finite relational structures can be replaced with unrestricted ones without changing the certain answers to unions of conjunctive queries [6, 7].",
      "startOffset" : 239,
      "endOffset" : 245
    }, {
      "referenceID" : 17,
      "context" : "in [21].",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 3,
      "context" : "We introduce the relevant extensions only briefly and refer to [4] for more details.",
      "startOffset" : 63,
      "endOffset" : 66
    }, {
      "referenceID" : 33,
      "context" : "They rely on a characterization of (ALC,UCQ) in terms of colored forbidden patterns [38], which is a by-product of the connection between (ALC,UCQ) and MMSNP that will be established in Section 4.",
      "startOffset" : 84,
      "endOffset" : 88
    }, {
      "referenceID" : 34,
      "context" : "This can be done similarly to the elimination of role inclusions in the proof above, see [39, 45].",
      "startOffset" : 89,
      "endOffset" : 97
    }, {
      "referenceID" : 40,
      "context" : "This can be done similarly to the elimination of role inclusions in the proof above, see [39, 45].",
      "startOffset" : 89,
      "endOffset" : 97
    }, {
      "referenceID" : 40,
      "context" : "It follows from [45] that this observation can be extended to all complex role inclusions that are admitted in the description logic SROIQ.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 5,
      "context" : "To overcome this restriction, we consider the guarded fragment of first-order logic and the unary-negation fragment of first-order logic [6, 46].",
      "startOffset" : 137,
      "endOffset" : 144
    }, {
      "referenceID" : 15,
      "context" : "There are actually a few DLs that can handle relations of unrestricted arity, such as those presented in [19].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 22,
      "context" : "Recall that a datalog rule is guarded if its body includes an atom that contains all variables which occur in the rule [27].",
      "startOffset" : 119,
      "endOffset" : 123
    }, {
      "referenceID" : 4,
      "context" : "A weaker notion of guardedness, which we call here frontier-guardedness, inspired by [5, 7], requires that, for each atom α in the head of the rule, there is an atom β in the rule body such that all variables that occur in α occur also in β.",
      "startOffset" : 85,
      "endOffset" : 91
    }, {
      "referenceID" : 20,
      "context" : "It also exploits the fact that the Feder-Vardi dichotomy conjecture can equivalently be stated for MMSNP sentences [24, 33].",
      "startOffset" : 115,
      "endOffset" : 123
    }, {
      "referenceID" : 28,
      "context" : "It also exploits the fact that the Feder-Vardi dichotomy conjecture can equivalently be stated for MMSNP sentences [24, 33].",
      "startOffset" : 115,
      "endOffset" : 123
    }, {
      "referenceID" : 31,
      "context" : "It was already proved in [36] (Theorem 27) that, compared to ontology-mediated queries based on ALC, the functional roles of ALCF dramatically increase the computational power.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 31,
      "context" : "Theorem 9 ([36]) For every NP-Turing machine M , there is a query q in (ALCF ,AQ) such that the complement of the word",
      "startOffset" : 11,
      "endOffset" : 15
    }, {
      "referenceID" : 7,
      "context" : "Specifically, the following general containment problem was proposed in [10] as a powerful tool for OBDA: given ontology-mediated queries (S,Oi, qi), i ∈ {1, 2}, decide whether for all S-instances D, we have certq1,O1(D) ⊆ certq2,O2(D).",
      "startOffset" : 72,
      "endOffset" : 76
    }, {
      "referenceID" : 15,
      "context" : "Note that there are also less general (and computationally simpler) notions of query containment in OBDA that do not fix the data schema [19].",
      "startOffset" : 137,
      "endOffset" : 141
    }, {
      "referenceID" : 20,
      "context" : "It was proved in [24] that containment of MMSNP sentences is decidable.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 7,
      "context" : "Note that this result is considerably stronger than those in [10], which considered only containment of ontology-mediated queries (S,O, q) with q an atomic query since already this basic case turned out to be technically intricate.",
      "startOffset" : 61,
      "endOffset" : 65
    }, {
      "referenceID" : 7,
      "context" : "In fact, this definition is slightly different from the one used in [10].",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 32,
      "context" : "Although defined in a different way, GMSNP is essentially the same logic as MMSNP2, which is studied in [37].",
      "startOffset" : 104,
      "endOffset" : 108
    }, {
      "referenceID" : 32,
      "context" : "In [37], it was left as an open question whether MMSNP2 is more expressive than MMSNP, which is resolved by the results above.",
      "startOffset" : 3,
      "endOffset" : 7
    }, {
      "referenceID" : 32,
      "context" : "While this question is implicit already in [37], the results established in this paper underline its significance from a different perspective.",
      "startOffset" : 43,
      "endOffset" : 47
    }, {
      "referenceID" : 21,
      "context" : "First, a generalized CSP is defined by a finite set F of templates, rather than only a single one [25].",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 19,
      "context" : "Second, in a (generalized) CSP with constant symbols, both the template(s) and the input structure are endowed with constant symbols [23, 1].",
      "startOffset" : 133,
      "endOffset" : 140
    }, {
      "referenceID" : 0,
      "context" : "Second, in a (generalized) CSP with constant symbols, both the template(s) and the input structure are endowed with constant symbols [23, 1].",
      "startOffset" : 133,
      "endOffset" : 140
    }, {
      "referenceID" : 8,
      "context" : "For example, BT can be viewed as a finite fragment of a canonical model of a modal logic that is constructed from maximal consistent sets of formulas [11].",
      "startOffset" : 150,
      "endOffset" : 154
    }, {
      "referenceID" : 36,
      "context" : "Alternatively, BT can be viewed as the result of a type elimination procedure [41].",
      "startOffset" : 78,
      "endOffset" : 82
    }, {
      "referenceID" : 7,
      "context" : "It is a consequence of a result in [10] that query containment is undecidable for ALCF .",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 14,
      "context" : "datalog engines, eliminating the ontology by query rewriting [18, 22, 20].",
      "startOffset" : 61,
      "endOffset" : 73
    }, {
      "referenceID" : 18,
      "context" : "datalog engines, eliminating the ontology by query rewriting [18, 22, 20].",
      "startOffset" : 61,
      "endOffset" : 73
    }, {
      "referenceID" : 16,
      "context" : "datalog engines, eliminating the ontology by query rewriting [18, 22, 20].",
      "startOffset" : 61,
      "endOffset" : 73
    }, {
      "referenceID" : 38,
      "context" : "Consequently, it follows from [43]",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 30,
      "context" : "without constant symbols, whether coCSP(B) is FO-definable is NP-complete [35].",
      "startOffset" : 74,
      "endOffset" : 78
    }, {
      "referenceID" : 1,
      "context" : "It relies on the characterization of FO-definable CSPs as those CSPs that have finite obstruction sets; this characterization was given in [2] for structures without constant symbols and follows from results in [43] for the case of structures with constant symbols.",
      "startOffset" : 139,
      "endOffset" : 142
    }, {
      "referenceID" : 38,
      "context" : "It relies on the characterization of FO-definable CSPs as those CSPs that have finite obstruction sets; this characterization was given in [2] for structures without constant symbols and follows from results in [43] for the case of structures with constant symbols.",
      "startOffset" : 211,
      "endOffset" : 215
    }, {
      "referenceID" : 6,
      "context" : "An NP algorithm for datalog-definability is implicit in [26], based on results from [9], see also [13].",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 31,
      "context" : "Modulo a minor difference in the treatment of instances that are not consistent (see Footnote 3), it follows from a result in [36] that FOrewritability is undecidable for (ALCF ,AQ).",
      "startOffset" : 126,
      "endOffset" : 130
    } ],
    "year" : 2013,
    "abstractText" : "Ontology-based data access is concerned with querying incomplete data sources in the presence of domain-specific knowledge provided by an ontology. A central notion in this setting is that of an ontology-mediated query, which is a database query coupled with an ontology. In this paper, we study several classes of ontology-mediated queries, where the database queries are given as some form of conjunctive query and the ontologies are formulated in description logics or other relevant fragments of first-order logic, such as the guarded fragment and the unary-negation fragment. The contributions of the paper are three-fold. First, we characterize the expressive power of ontology-mediated queries in terms of fragments of disjunctive datalog. Second, we establish intimate connections between ontology-mediated queries and constraint satisfaction problems (CSPs) and their logical generalization, MMSNP formulas. Third, we exploit these connections to obtain new results regarding (i) first-order rewritability and datalogrewritability of ontology-mediated queries, (ii) P/NP dichotomies for ontology-mediated queries, and (iii) the query containment problem for ontology-mediated queries.",
    "creator" : "LaTeX with hyperref package"
  }
}