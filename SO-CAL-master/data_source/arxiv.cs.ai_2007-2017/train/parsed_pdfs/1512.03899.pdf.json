{
  "name" : "1512.03899.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Query Answering over Contextualized RDF/OWL Knowledge with Forall-Existential Bridge Rules: Decidable Finite Extension Classes (Post Print)",
    "authors" : [ "Mathew Joseph", "Gabriel Kuper", "Till Mossakowski", "Luciano Serafini" ],
    "emails" : [ "kuper}@disi.unitn.it,", "serafini@fbk.eu,", "mossakow@iws.cs.uni-magdeburg.de" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n51 2.\n03 89\n9v 1\n[ cs\n.D B\nKeywords: Contextualized Query Answering, Contextualized RDF/OWL knowledge bases, Multi-Context Systems, Quads, Query answering, forall-existential rules, Knowledge Representation, Semantic Web"
    }, {
      "heading" : "1 Introduction",
      "text" : "As the Semantic Web (SW) is getting more and more ubiquitous and its constellation of interlinked ontologies, the web of data, is seamlessly proliferating at a steady rate,\nmore and more applications have started using SW as a back end, providing their users manifold services, leveraging semantic technologies. One of the main reasons why SW enjoys such admirable hospitality from its mammoth geographically disparate users is its “simple” and “open” model. The model is simple, as the only intricacy that a creator/consumer of a SW application needs to be equipped with is that of a (RDF) triple. A triple t = (s, p, o) represents the most basic piece of knowledge in the SW, where s, called the subject, is an identifier for a person, place, thing, value, or a resource in general, about which the creator of t intended to express his/her knowledge using t. p, called the predicate, is an identifier for a property, attribute, or in general a binary relation that relates s with the component o, called the object, that is also an identifier for a resource similar to s. The model is called open, as it allows anybody, anywhere around the world to freely create their RDF/OWL ontologies about a domain of their choice, and publish them in (embedded) RDF/OWL formats in their web portals, also linking via URIs to the concepts in other similarly published ontologies. Thus the open model, in order to promote reuse and freedom, imposes no arbitration mechanism for the ontologies users publish on the SW.\nA problem caused by this open model is that any piece of knowledge which a person publishes is often his/her own perspective about a particular domain, which largely is relative to this person. As a consequence, the truth value of a piece of knowledge in the SW is context-dependent. Recently, as a solution to the aforementioned problem, the SW community adopts the use of quads, an extension of triples, as the primary carrier of knowledge. A quad c : (s, p, o) thus adds a fourth component of the context c to the triple (s, p, o), explicating the identifier of the context in which the triple holds. As a result, more and more triple-stores are becoming quad-stores. Some of the popular quad-stores are 4store1, Openlink Virtuoso 2, and some of the currently popular triplestores like Sesame3, Allegrograph4 internally keep track of the contexts of triples. Some of the recent initiatives in this direction have also extended existing formats like NTriples to N-Quads, which the RDF 1.1 has introduced as a W3C recommendation. The latest Billion triple challenge datasets have all been released in the N-Quads format.\nOther benefits of quads over triples are that they allow knowledge creators to specify various attributes of meta-knowledge that further qualify knowledge [2], and also allow users to query for this meta knowledge [3]. These attributes, which explicate the various assumptions under which knowledge holds, are also called context dimensions [4]. Examples of context dimensions are provenance, creator, intended user, creation time, validity time, geo-location, and topic. Having defined knowledge that is contextualized, as in c1 : (Renzi, primeMinsiterOf, Italy), one can now declare in a meta-context mc, statements such as mc : (c1, creator, John), mc : (c1, expiryTime, “jun-2016”) that talk about the knowledge in context c1, in this case its creator and expiry time. Another benefit of such a contextualized approach is that it opens possibilities of interesting ways for querying a contextualized knowledge base. For instance, if context c1 contains knowledge about football world cup 2014 and context c2 about football euro cup\n1 http://4store.org 2 http://virtuoso.openlinksw.com/rdf-quad-store/ 3 http://www.openrdf.org/ 4 http://www.franz.com/agraph/allegrograph/\n2012, then the query “who beat Italy in both world cup 2014 and euro cup 2012” can be formalized as the conjunctive query:\nc1: (x, beat, Italy) ∧ c2: (x, beat, Italy),\nwhere x is a variable. When reasoning with knowledge in quad form, since knowledge can be grouped and divided context wise and simultaneously be fed to separate reasoning engines, this approach improves both efficiency and scalability [9]. Besides the above flexibility, bridge rules [5] can be provided for inter-operating the knowledge in different contexts. Such rules are primarily of the form:\nc : φ → c′ : φ′ (1)\nwhere φ, φ′ are both atomic concept (role) symbols, c, c′ are contexts. The semantics of such a rule is that if, for any a, φ(a) holds in context c, then φ′(a) should hold in context c′, where a is a unary/binary vector depending on whether φ, φ′ are concept/role symbols. Although such bridge rules serve the purpose of specifying knowledge interoperability from a source context c to a target context c′, in many practical situations there is the need of inter-operating multiple source contexts with multiple target contexts, for which the bridge rules of the form (1) are inadequate. Besides, one would also want the ability of creating new values in target contexts for the bridge rules.\nIn this work, we study contextual reasoning and query answering over contextualized RDF/OWL knowledge bases in the presence of forall-existential bridge rules that allow conjunctions and existential quantifiers in them, and hence are more expressive than those in DDL [5] and McCarthy et al. [6]. We provide a basic semantics for contextual reasoning based on which we provide procedures for conjunctive query answering. For query answering, we use the notion of a distributed chase, which is an extension of the standard chase [20, 21] that is widely used in the knowledge representation (KR) and Database (DB) settings for similar purposes. As far as the semantics for reasoning is concerned, we adopt the approach given in works such as Distributed Description Logics [5], E-connections [22], and two-dimensional logic of contexts [23], to use a set of interpretation structures as a model for contextualized knowledge. In this way, knowledge in each context is separately interpreted in a different interpretation structure. The main contributions of this work are:\n1. We formulate a context-based semantics that reuses the standard RDF/OWL semantics, which can be used for reasoning over quad-systems. Studying conjunctive query answering over quad-systems, it turns out that the entailment problem of conjunctive queries is undecidable for the most general class of quad-systems, called unrestricted quad-systems. 2. We derive decidable subclasses of unrestricted quad-systems, namely csafe, msafe, and safe quad-systems, for which we detail both data and combined complexities of conjunctive query entailment. These classes are based on the constrained DAG structure of Skolem blank nodes generated during the chase construction. We also provide decision procedures to decide whether an input quad-system is safe (csafe, msafe) or not.\n3. We further derive less expressive classes, RR and restricted RR quad-systems, for which no Skolem blank nodes are generated during the chase construction. 4. We show that the class of unrestricted quad-systems is equivalent to the class of ternary ∀∃ rule sets. We compare the derived classes of quad-systems with well known subclasses of ∀∃ rule sets, such as jointly acyclic and model faithful acyclic rule sets, and show that the technique of safety we propose, subsumes these other techniques, in expressivity.\nThe paper is structured as follows. In section 2, we formalize the idea of contextualized quad-systems, giving various definitions and notations for setting the background. In section 3, we formalize the problem of query answering for quad-systems, define notions such as distributed chase that are further used for query answering, and give the undecidability results of query entailment on unrestricted quad-systems. In section 4, we present csafe, msafe, and safe quad-systems and their computational properties. In section 5, RR quad-systems and restricted RR quad-systems are introduced. In section 6, we prove the equivalence of quad-systems with ternary ∀∃ rule sets, and formally compare a few well known decidable classes in the realm of ∀∃ rules to the classes of quad-systems, we presented in section 4. We provide a detailed discussion to other relevant related works in section 7, and conclude in section 8.\nNote that parts of the contents of section 2 and section 3 has been taken from conference papers [11] and [12]."
    }, {
      "heading" : "2 Contextualized Quad-Systems",
      "text" : "In this section, we formalize the notion of a quad-system and its semantics. For any vector or sequence x, we denote by ‖x‖ the number of symbols in x, and by {x} the set of symbols in x. For any sets A and B, A → B denotes the set of all functions from set A to set B.\nGiven the set of URIs U, the set of blank nodes B, and the set of literals L, the set C = U ⊎ B ⊎ L is called the set of (RDF) constants. Any (s, p, o) ∈ C × C ×C is called a generalized RDF triple (from now on, just triple). A graph is a set of triples. A quad is a tuple of the form c : (s, p, o), where (s, p, o) is a triple and c is a URI5, called the context identifier that denotes the context of the RDF triple. A quad-graph is defined as a set of quads. For any quad-graph Q and any context identifier c, we denote by graphQ(c) the set {(s, p, o)|c : (s, p, o) ∈ Q}. We denote by QC the quad-graph whose set of context identifiers is C. The set of constants occurring in QC is given as C(QC) = {c, s, p, o | c : (s, p, o) ∈ QC}. The set of URIs in QC is given by U(QC) = C(QC) ∩ U. The set of blank nodes B(QC) and the set of literals L(QC) are similarly defined. Let V be the set of variables, any element of the set CV = V ∪ C is a term. Any (s, p, o) ∈ CV × CV × CV is called a triple pattern, and an expression of the form c : (s, p, o), where (s, p, o) is a triple pattern, c a context identifier, is called a quad pattern. A triple pattern t, whose variables are elements of the vector x or elements of the vector y is written as t(x,y). For any function f : A → B, the restriction of f to\n5 Although, in general a context identifier can be a constant, for the ease of notation, we restrict them to be a URI\na set A′, is the mapping f |A′ from A′ ∩ A to B such that f |A′(a) = f(a), for each a ∈ A ∩ A′. For any triple pattern t = (s, p, o) and function µ from V to a set A, t[µ] denotes (µ′(s), µ′(p), µ′(o)), where µ′ is an extension of µ to C such that µ′|C is the identity function. For any set of triple patterns G, G[µ] denotes ⋃\nt∈G t[µ]. For any vector of constants a = 〈a1, . . . , a‖a‖〉, and vector of variables x of the same length, x/a is the function µ such that µ(xi) = ai, for 1 ≤ i ≤ ‖a‖. We use the notation t(a,y) to denote t(x,y)[x/a]. Similarly, the above notations are also extended to sets of quad-patterns. For instance Q(x,y) denotes a set of quad-patterns, whose variables are fromx or y, and Q(a,y) is written for Q(x,y)[x/a]. For the sake of interoperating knowledge in different contexts, bridge rules need to be provided:\nBridge rules (BRs) Formally, a BR is of the form:\n∀x∀z [c1: t1(x, z) ∧ ... ∧ cn: tn(x, z) → ∃y c′1: t ′ 1(x,y) ∧ ... ∧ c ′ m: t ′ m(x,y)] (2)\nwhere c1, ..., cn, c′1, ..., c ′ m are context identifiers, x, y, z are vectors of variables such that {x}, {y}, and {z} are pairwise disjoint. t1(x, z), ..., tn(x, z) are triple patterns which do not contain blank-nodes, and whose set of variables are from x or z. t′1(x, y), ..., t′m(x,y) are triple patterns, whose set of variables are fromx or y, and also does not contain blank-nodes. For any BR r of the form (2), body(r) is the set of quad patterns {c1: t1(x, z),...,cn: tn(x, z)}, and head(r) is the set of quad patterns {c′1: t ′ 1(x,y), ... c′m: t ′ m(x, y)}, and the frontier of r, fr(r) = {x}. Occasionally, we also note the BR r above as body(r)(x, z) → head(r)(x, y). The set of terms in a BR r is:\nC V(r) = {c, s, p, o | c : (s, p, o) ∈ body(r) ∪ head(r)}\nThe set of terms for a set of BRs R is CV(R) = ⋃\nr∈R C V(r). The URIs, blank nodes,\nliterals, variables of a BR r (resp. set of BRs R) are similarly defined, and are denoted as U(r), B(r), L(r), V(r) (resp. U(R), B(R), L(R), V(R)), respectively.\nDefinition 1 (Quad-System). A quad-system QSC is defined as a pair 〈QC , R〉, where QC is a quad-graph, whose set of context identifiers is C, and R is a set of BRs.\nFor any quad-system,QSC = 〈QC , R〉, the set of constants inQSC is given byC(QSC) = C(QC) ∪C(R). The sets U(QSC), B(QSC), L(QSC), and V(QSC) are similarly defined for any quad-system QSC . For any quad-graph QC (BR r), its symbol size ‖QC‖ (‖r‖) is the number of symbols required to print QC (r). Hence, ‖QC‖ ≈ 4 ∗ |QC |, where |QC | denotes the cardinality of the set QC . Note that |QC | equals the number of quads in QC . For a BR r, ‖r‖ ≈ 4 ∗ k, where k is the number of quad-patterns in r. For a set of BRs R, ‖R‖ is given as Σr∈R‖r‖. For any quad-system QSC = 〈QC , R〉, its size ‖QSC‖ = ‖QC‖+ ‖R‖.\nSemantics In order to provide a semantics for enabling reasoning over a quad-system, we need to use a local semantics for each context to interpret the knowledge pertaining to it. Since the primary goal of this paper is a decision procedure for query answering over quad-systems based on forward chaining, we consider the following desiderata for the choice of the local semantics and its deductive machinery:\n– there exists an operation lclosure() that computes the deductive closure of a graph w.r.t to the local semantics using the local inference rules in a set LIR, – each inference rule in LIR is range restricted, i.e. non value-generating, – given a finite graph as input, the lclosure() operation terminates with a finite graph\nas output in polynomial time whose size is polynomial w.r.t. to the input set.\nSome of the alternatives for the local semantics satisfying the above mentioned criterion are Simple, RDF, RDFS [31], OWL-Horst [27] etc. Assuming that a local semantics has been fixed, for any context c, we denote by Ic = 〈∆c, ·c〉 an interpretation structure for the local semantics, where ∆c is the interpretation domain, ·c the corresponding interpretation function. Also |=local denotes the local satisfaction relation between a local interpretation structure and a graph. Given a quad graphQC , a distributed interpretation structure is an indexed set IC = {Ic}c∈C, where Ic is a local interpretation structure, for each c ∈ C. We define the satisfaction relation |= between a distributed interpretation structure IC and a quad-system QSC as:\nDefinition 2 (Model of a Quad-System). A distributed interpretation structure IC = {Ic}c∈C satisfies a quad-system QSC = 〈QC , R〉, in symbols IC |= QSC, iff all the following conditions are satisfied: 1. Ic |=local graphQC (c), for each c ∈ C; 2. aci = acj , for any a ∈ C, ci, cj ∈ C; 3. for each BR r ∈ R of the form (2) and for each σ ∈ V → ∆C , where ∆C =\n⋃\nc∈C ∆ c, if\nIc1 |=local t1(x, z)[σ], ..., I cn |=local tn(x, z)[σ],\nthen there exists a function σ′ ⊇ σ, such that Ic ′ 1 |=local t ′ 1(x,y)[σ ′], ..., Ic ′ m |=local t ′ m(x,y)[σ\n′]. Condition 1 in the above definition ensures that for any model IC of a quad-graph, each Ic ∈ IC is a local model of the set of triples in context c. Condition 2 ensures that any constant c is rigid, i.e. represents the same resource across a quad-graph, irrespective of the context in which it occurs. Condition 3 ensures that any model of a quad-system satisfies each BR in it. Any IC such that IC |= QSC is said to be a model of QSC . A quad-system QSC is said to be consistent if there exists a model IC , such that IC |= QSC , and otherwise said to be inconsistent. For any quad-system QSC = 〈QC , R〉, it can be the case that graphQC(c) is locally consistent, i.e. there exists an I\nc such that Ic |=local graphQC (c), for each c ∈ C, whereas QSC is not consistent. This is because the set of BRs R adds more knowledge to the quad-system, and restricts the set of models that satisfy the quad-system.\nDefinition 3 (Quad-system entailment). (a) A quad-system QSC entails a quad c : (s, p, o), in symbols QSC |= c : (s, p, o), iff for any distributed interpretation structure IC , if IC |= QSC then IC |= 〈{c : (s, p, o)}, ∅〉. (b) A quad-system QSC entails a quadgraph Q′C′ , in symbols QSC |= Q ′ C′ iff QSC |= c : (s, p, o) for any c : (s, p, o) ∈ Q ′ C′ . (c) A quad-system QSC entails a BR r iff for any IC , if IC |= QSC then IC |= 〈∅, {r}〉. (d) For a set of BRs R, QSC |= R iff QSC |= r, for every r ∈ R. (e) Finally, a quadsystem QSC entails another quad-system QS′C′ = 〈Q ′ C′ , R\n′〉, in symbols QSC |= QS′C′ iff QSC |= Q′C′ and QSC |= R\n′. We call the decision problems corresponding to the entailment problems (EPs) in (a), (b), (c), (d), and (e) as quad EP, quad-graph EP, BR EP, BRs EP, and quad-system EP, respectively."
    }, {
      "heading" : "3 Query Answering on Quad-Systems",
      "text" : "In the realm of quad-systems, the classical conjunctive queries or select-project-join queries are slightly extended to what we call Contextualized Conjunctive Queries (CCQs). A CCQ CQ(x) is an expression of the form:\n∃y q1(x,y) ∧ ... ∧ qp(x,y) (3)\nwhere qi, for i = 1, ..., p are quad patterns over vectors of free variables x and quantified variables y. A CCQ is called a boolean CCQ if it does not have any free variables. With some abuse, we sometimes discard the logical symbols in a CCQ and consider it as a set of quad-patterns. For any CCQ CQ(x) and a vector a of constants such that ‖x‖ = ‖a‖, CQ(a) is boolean. A vector a is an answer for a CCQ CQ(x) w.r.t. structure IC , in symbols IC |= CQ(a), iff there exists assignment µ : {y} → B such that IC |= ⋃\ni=1,...,p qi(a,y)[µ]. A vector a is a certain answer for a CCQ CQ(x) over a quad-system QSC , iff IC |= CQ(a), for every model IC of QSC . Given a quadsystem QSC , a CCQ CQ(x), and a vector a, decision problem of determining whether QSC |= CQ(a) is called the CCQ EP. It can be noted that the other decision problems over quad-systems, namely Quad/Quad-graph EP, BR(s) EP, Quad-system EP, are reducible to the CCQ EP (See Property 6). Hence, in this paper, we primarily focus on the CCQ EP."
    }, {
      "heading" : "3.1 dChase of a Quad-System",
      "text" : "In order to build a procedure for query answering over a quad-system, we employ what has been called in the literature a chase [20, 21]. Specifically, we adopt notions of the restricted chase in Fagin et al. [24] (also called non-oblivious chase). In order to fit the framework of quad-systems, we extend the standard notion of chase to a distributed chase, abbreviated dChase. In the following, we show how the dChase of a quad-system can be constructed.\nFor a set of quad-patternsS and a set of terms T , we define the relationT -connectedness between quad-patterns in S as the least relation with:\n– q1 and q2 are T -connected, if CV(q1)∩CV(q2)∩T 6= ∅, for any two quad-patterns q1, q2 ∈ S, – if q1 and q2 are T -connected, and q2 and q3 are T -connected, then q1 and q3 are also T -connected, for any quad-patterns q1, q2, q3 ∈ S.\nIt can be noted that T -connectedness is an equivalence relation and partitions S into a set of T -components (similar notion is called a piece in Baget et al. [15]). Note that for two distinct T -components P1, P2 of S, CV(P1) ∩ CV(P2) ∩ T = ∅. For any BR r = body(r)(x, z) → head(r)(x,y), suppose P1, P2, . . . , Pk are the pairwise distinct {y}-components of head(r)(x,y), then r can be replaced by the semantically equivalent set of BRs {body(r)(x, z) → P1, . . . , body(r)(x, z) → Pk} whose symbol size is worst case quadratic w.r.t. the symbol size of r. Hence, w.l.o.g. we assume that for any BR r, the set of quad-patterns head(r) is a single component w.r.t. the set of existentially quantified variables in r.\nConsidering the fact that the local semantics for contexts are fixed a priori (for instance RDFS), both the number of rules in the set of local inference rules LIR and the size of each rule in LIR can be assumed to be a constant. Note that each local inference rule is range restricted and does not contain existentially quantified variables in its head. Any ir ∈ LIR is of the form:\n∀x∀z [t1(x, z) ∧ . . . ∧ tk(x, z) → t ′ 1(x)], (4)\nwhere ti(x, z), for i = 1, . . . , n are triple patterns, whose variables are from {x} or {z}, and t′1(x) is a triple pattern, whose variables are from {x}. Hence, for any quadsystem QSC = 〈QC , R〉 in order to accomplish the effect of local inferencing in each context c ∈ C, for each ir ∈ LIR of the form (4), we could augment R with a BR irc of the form:\n∀x∀z [c : t1(x, z) ∧ . . . ∧ c : tk(x, z) → c : t ′ 1(x)]\nSince ‖LIR‖ is a constant and the size of the augmentation is linear in |C|, w.l.o.g we assume that the set R contains a BR irc, for each ir ∈ LIR, c ∈ C.\nGiven a quad-system QSC , we denote by Bsk ⊆ B, a set of blank nodes called Skolem blank nodes, such that Bsk ∩ B(QSC) = ∅. For any BR r = body(r)(x, z) → head(r)(x, y) and an assignment µ : {x} ∪ {z} → C, the application of µ on r is defined as:\napply(r, µ) = head(r)[µext(y)]\nwhere µext(y) ⊇ µ such that µext(y)(yi) = : b is a fresh blank node from Bsk, for each yi ∈ {y}.\nWe assume that there exists an order≺l (for instance, lexicographic order) on the set of constants. We extend ≺l to the set of quads such that for any two quads c : (s, p, o) and c′ : (s′, p′, o′), c : (s, p, o) ≺l c′ : (s′, p′, o′), iff c ≺l c′, or c = c′, s ≺l s′, or c = c′, s = s′, p ≺l p′, or c = c′, s = s′, p = p′, o ≺l o′. It can be noted that ≺l is a strict linear order over the set of all quads. For any finite quad-graphQC, the ≺l-greatest quad of QC , denoted greatestQuad≺l(QC), is the quad q ∈ QC such that q\n′ ≺l q, for every other q′ ∈ QC . Also, the order ≺q is defined over the set of finite quad-graphs as follows: for any two finite quad-graphs QC , Q′C′ ,\nQC ≺q Q′C′ , if (i) QC ⊂ Q ′ C′ ; QC ≺q Q ′ C′ , if (i) does not hold and (ii) greatestQu-\n-ad≺l(QC \\ Q ′ C′) ≺l greatestQuad≺l(Q ′ C′ \\ QC);\nQC 6≺q Q′C′ , if both (i) and (ii) are not satisfied;\nA relation R over a set A is called a strict linear order iff R is irreflexive, transitive, and R(a, b) or R(b, a) holds, for every distinct a, b ∈ A.\nProperty 1. Let Q be the set of all finite quad-graphs; ≺q is a strict linear order over Q.\nAlso, we now define in parallel the dChase of a quad system QSC = 〈QC , R〉 and the level of a quad in the dChase of QSC as follows: any quad in QC is of level 0. The level of a set of quads is the largest among levels of quads in the set. The level of any quad that results from the application of a BR r w.r.t. an assignment µ is one more\nthan the level of the set body(r)[µ], if it has not already been assigned a level. Let ≺ be an ordering on the quad-graphs such that for any two quad-graphs Q′C′ and Q ′′ C′′ of the same level, Q′C′ ≺ Q ′′ C′′ , iff Q ′ C′ ≺q Q ′′ C′′ . For Q ′ C′ and Q ′′ C′′ of different levels, Q′C′ ≺ Q ′′ C′′ , iff level of Q ′ C′ is less than level of Q ′′ C′′ . It can easily be seen that ≺ is a strict linear order over the set of quad-graphs. For any BRs r, r′ and assignments µ, µ′ over V(body(r)),V(body(r′)), respectively, (r, µ) ≺ (r′, µ′) iff body(r)[µ] ≺ body(r′)[µ′]. For any quad-graph Q′C′ , a set of BRs R, a BR r ∈ R, an assignment µ ∈ V(body(r)) → C, let applicableR be the least ternary predicate defined inductively as:\napplicableR(r, µ,Q ′ C′) holds, if (a) body(r)[µ] ⊆ Q ′ C′ , head(r)[µ ′′] 6⊆ Q′C′ , ∀µ ′′ ⊇ µ, and (b) 6 ∃r′ ∈ R, 6 ∃µ′ such that r′ 6= r or µ′ 6= µ with (r′, µ′) ≺ (r, µ) and\napplicableR(r ′, µ′, Q′C′);\nFor any quad-system QSC = 〈QC , R〉, let dChase0(QSC) = QC ; dChasei+1(QSC) = dChasei(QSC) ∪ apply(r, µ), if there exists r = body(r)(x, z)→ head(r)(x, y) ∈R, assignment µ : {x} ∪ {z} →C such that applicableR(r, µ, dChasei(QSC));\ndChasei+1(QSC) = dChasei(QSC), otherwise; for any i ∈ N. The dChase of QSC , noted dChase(QSC), is given as:\ndChase(QSC) = ⋃\ni∈N\ndChasei(QSC)\nIntuitively, dChasei(QSC) can be thought of as the state of dChase(QSC) at the end of iteration i. It can be noted that, if there exists i such that dChasei(QSC) = dChasei+1(QSC), then dChase(QSC) is equal to dChasei( QSC). A model IC of a quad-system QSC is called universal [30], iff the following holds: IC is a model of QSC , and for any model I ′C of QSC there exists a homomorphism from IC to I ′C .\nTheorem 1. For any consistent quad-systemQSC, the following holds: (i) dChase(QSC) is a universal model of QSC .6, and (ii) for any boolean CCQ CQ(), QSC |= CQ() iff there exists a map µ : V(CQ) → C such that {CQ()}[µ] ⊆ dChase(QSC).\nAn anolog of the above theorem for DLs and Databases is stated and proved in [25]. Since the proof in [25] can easily be adapted to our case, we refer the reader to [25] for the proof. We call the sequence dChase0(QSC), dChase1(QSC), ..., the dChase sequence of QSC. It should be noted that at each iteration i, after the application of a BR, any new quad added is assigned a level, and as a result any subset of the set of quads in dChasei(QSC) has a level. This assignment of levels guarantees that applicableR(r, µ, dChasei(QSC)) is either true or false, for any r ∈ R, assignment µ : V(body(r)) → C. The following lemma shows that in a dChase sequence of a quad-system, any dChase iteration can be performed in time exponential w.r.t. the size of the largest BR.\n6 Though dChase(QSC) is not an interpretation in a strict model theoretic sense, one can easily create the corresponding interpretation IdChase(QSC) = {I\nc = 〈∆c, .c〉}c∈C , s.t. for every c ∈ C, ∆c is equal to set of constants in graphdChase(QSC)(c), and .\nc is s.t (s, p, o) ∈ graphdChase(QSC)(c) iff (s c, oc) ∈ pc.\nLemma 1. For a quad-system QSC = 〈QC , R〉, for any i ∈ N+, the following holds: (i) dChasei(QSC) can be computed in time O( |R| ∗ ‖dChasei−1(QSC)‖rs), where rs = maxr∈R‖r‖, (ii) ‖dChasei(QSC)‖ = O(‖dChasei−1(QSC)‖+ ‖R‖).\nProof. (i) We can first find, if there exists an r among the set of BRs R, assignment µ such that applicableR(r, µ, dChasei−1(QSC)) holds, in the following naive way: (1) bind the set of variables in all rules in R with the set of constants in dChasei−1(QSC). Let this set be called S. Note that |S| = O(|R|∗‖dChasei−1(QSC )‖‖rs‖), where rs = maxr∈R‖r‖. Also, note that each of the binding in S is of the form body(r)(x, z)(µ) → head(r)(x, y)(µ′) (♥), where r ∈ R. (2) From the set S we filter out every binding of the form (♥) in which x[µ] 6= x[µ′]. Let S′ be the resulting set after the above filtering operation. (3) From the set S′, we now filter out all the bindings of the form (♥) with head(r)(x, y)(µ′)⊆ dChasei−1(QSC), with resulting set S′′. (4) If S′′ = ∅, then there is no r ∈ R, assignment µ such that applicableR(r, µ, dChasei−1(QSC)) is True. Otherwise if S′′ 6= ∅, then note that each binding of the form (♥) in S′′ is such that condition (a) of the true applicableR(r, µ, dChasei−1(QSC)) is satisfied. Now, we can sort S′′ w.r.t. ≺ and select the least binding b of the form (♥), so that condition (b) in True condition of applicableR() is satisfied for b. It can easily be seen that applicableR(r, µ, dChasei−1(QSC)) holds for the r, µ extracted from b. Since the size of each binding is at most ‖rs‖, the operations (1)-(4) can be performed in time O(|R| ∗ ‖dChasei−1(QSC)‖rs). Since dChasei(QSC) = dChasei−1(QSC) ∪ head(r)[µ], for r, µ with applicableR(r, µ, dChasei−1(QSC)), dChasei(QSC) can be computed in time O(‖dChasei−1(QSC )‖rs).\n(ii) Trivially holds, since at worst dChasei(QSC) = dChasei−1(QSC)∪ head(r)[µ], for r ∈ R.\nLemma 2. For any quad-system QSC, If : b is a Skolem blank node in dChase(QSC), generated by the application of assignment µ on r = body(r)(x, z) → head(r)(x, y), with µext(y)(yj) = : b, yj ∈ {y}, then : b is unique for (r, yj ,x[µext(y)]).\nProof. By contradiction, suppose if : b is not unique for (r, yj ,x[µext(y)]), i.e. there exists : b′ 6= : b in dChase(QSC), with : b′ generated by r such that : b′ = µ′ext(y)(yj) and x[µext(y)] = x[µ′ext(y)]. W.l.o.g. suppose : b was generated in an iteration l ∈ N and : b′ in an iterationm > l. This means that head(r)(x, y)[µext(y)]⊆ dChasel(QSC), and hence head(r)(x, y)[µext(y)] ⊆ dChasem−1(QSC). Also, since µ|x = µ′|x, there ∃µ′′ ⊇ µ′ s.t. head(r)(x, y)[µ′′] ⊆ dChasem−1(QSC). This means that (a) part of the function applicableR is false, for applicableR(r, µ′, dChasem−1(QSC)) to be true, and hence applicableR(r, µ′, dChasem−1(QSC)) is false. Hence, our assumption that : b′ = yj [µ ′ext(y)] is false. Hence, : b is unique for (r, yj , x[µext(y)]).\nAlthough we now know how to compute the dChase of a quad-system, which can be used for deciding CCQ EP, the following proposition reveals that for the class of quadsystems whose BRs are of the form (2), which we call unrestricted quad-systems, the dChase can be infinite.\nProposition 1. There exists unrestricted quad-systems whose dChase is infinite.\nProof. Consider an example of a quad-system QSc = 〈Qc, r〉, where Qc = {c : (a, rdf:type, C)}, and the BR r = c : (x, rdf:type, C) → ∃y c : (x, P , y), c : (y, rdf:type, C). The dChase computation starts with dChase0(QSc) = {c : (a, rdf:type,C)}, now the rule r is applicable, and its application leads to dChase1(QSc) = {c : (a, rdf:type, C), c : (a, P, : b1), c : ( : b1, rdf:type, C)}, where : b1 is a fresh Skolem blank node. It can be noted that r is yet again applicable on dChase1(QSc), for c : ( : b1, rdf:type, C), which leads to the generation of another Skolem blank node, and so on. Hence, dChase(QSc) does not have a finite fix-point, and dChase(QSc) is infinite.\nA class C of quad-systems is called a finite extension class (FEC), iff for every member QSC ∈ C, dChase(QSC) is a finite set. Therefore, the class of unrestricted quadsystems is not a FEC. This raises the question if there are other approaches that can be used, for instance, a similar problem of non-finite chase is manifested in description logics (DLs) with value creation, due to the presence of existential quantifiers, whereas the approaches like the one in Glimm et al. [28] provides an algorithm for CQ entailment based on query rewriting. Theorem 2 below establishes the fact that the CCQ EP for unrestricted quad-systems is undecidable. Despite this, the reader should note that the following undecidability result and its proof is only provided for the sake of self containedness, and we do not claim the undecidability theorem nor its proof to be a novel contribution, as we will show in section 6, ternary ∀∃ rule sets are polynomially reducible to unrestricted quad-systems. Hence, the undecidability results provided in Baget et al. [15], Krötzsch et al. [39], or Beeri et al. [14] can trivially be applied in our setting to obtain the undecidability result for unrestricted quad-systems.\nTheorem 2. The CCQ entailment problem over unrestricted quad-systems is undecidable.\nProof. (sketch) We show that the well known undecidable problem of non-emptiness of intersection of context-free grammars (CFGs) is reducible to the CCQ entailment problem. Given two CFGs, G1 = 〈V1, T, S1, P1〉 and G2 = 〈V2, T, S2, P2〉, where V1, V2 are the set of variables, T such that T ∩ (V1 ∪ V2) = ∅ is the set of terminals. S1 ∈ V1 is the start symbol of G1, and P1 are the set of PRs of the form v → w, where v ∈ V , w is a sequence of the form w1...wn, where wi ∈ V1 ∪ T . s2, P2 are defined similarly. Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [33].\nGiven two CFGs G1 = 〈V1, T, S1, P1〉 and G2 = 〈V2, T, S2, P2〉, we encode grammars G1, G2 into a quad-system QSc = 〈Qc, R〉, with only a single context identifier c. Each PR r = v → w ∈ P1 ∪ P2, with w = w1w2w3..wn, is encoded as a BR of the form: c : (x1, w1, x2), c : (x2, w2, x3), ..., c : (xn, wn, xn+1) → c : (x1, v, xn+1), where x1, .., xn+1 are variables. For each terminal symbol ti ∈ T , R contains a BR of the form: c : (x,rdf:type, C) → ∃y c : (x, ti, y), c : (y, rdf:type, C) and Qc is the singleton: { c : (a, rdf:type, C)}. It can be observed that:\nQSc |= ∃y c : (a, S1, y) ∧ c : (a, S2, y) ⇔\nL(G1) ∩ L(G2) 6= ∅\nWe refer the reader to Appendix for the complete proof.\nHaving shown the undecidability results of query answering of unrestricted quad-systems, the rest of the paper focuses on defining subclasses of unrestricted quad-systems for which query answering is decidable, and establishing their relationships with similar classes in the realm of ∀∃ rules. While defining decidable classes for quad-systems, one mainly has two fundamentally distinct options: (i) is to define notions that solely use the structure/properties of the BR part, ignoring the quad-graph part, or (ii) to define notions that takes into account both the BR and quad-graph part. The decidability notions which we define in section 4, namely safety, msafety, and csafety belong to type (ii), as these techniques take into account the property of the dChase of a quad-system, which is determined by both the quad-graph and BRs of the quad-system. Whereas the ones which we define in section 5, namely RR and restricted RR quad-systems fall into type (i), as the properties of BRs alone are used. With an analogy between a set of BRs and a set of ∀∃ rules, and between a quad-graph and a set of ∀∃ instances, the reader should note that such distinctions can also be made for the decidability notions in the realm of ∀∃ rule sets. Techniques such as Weak acyclicity [24], Joint acyclicity [38], and Acyclic graph of rule dependencies [15] belong to type (ii), as these notions ignore the instance part. Whereas techniques such as model faithful acyclicity [32] and model summarizing acyclicity [32] are of type (i) as both the rules and instance part is considered."
    }, {
      "heading" : "4 Safe, Msafe and Csafe Quad-Systems: Decidable FECs",
      "text" : "In the previous section, we saw that the query answering problem over unrestricted quad-systems is undecidable, in general. We will also see in section 6 that any quadsystem is polynomially translatable to a ∀∃ rule set, which is also a first order logic theory. Hence, a possible solution approach is to translate to these more expressive languages, and apply well known tests (see related work for details on such tests) available in these languages to check if query answering is decidable. If the translated quadsystem passes one of these tests, then query answering can be performed on this translation using available algorithms in these expressive languages. But such an approach is often discouraged, because of the non-applicability of the already available tools and techniques available for reasoning over quads. Instead, we in the following define three classes of quad-systems, namely SAFE, MSAFE and CSAFE, that are FECs and for which query entailment is decidable. Finiteness/decidability is achieved by putting certain restrictions (explained below) on the blank nodes generated in the dChase.\nRecall that, for any quad-system QSC, the set of blank-nodes B(dChase(QSC)) in its dChase(QSC) not only contains blank nodes present in QSC, i.e. B(QSC), but also contains Skolem blank nodes that are generated during the dChase construction process. Note that the following holds: Bsk(dChase(QSC)) = B(dChase(QSC)) \\ B(QSC). We assume w.l.o.g. that for any set of BRs R, any BR in R has a unique rule identifier, and we often write ri for the BR in R, whose identifier is i.\nDefinition 4 (Origin RuleId/Vector). For any Skolem blank node : b, generated in the dChase by the application of a BR ri = body(ri)(x, z) → head(ri)(x,y) using assignment µ : {x} ∪ {z} → C, i.e. : b = µext(y)(yj), for some yj ∈ y, we say that the origin ruleId of : b is i, denoted originRuleId( : b) = i. Moreover w = x[µ] is said to be the origin vector of : b, denoted originV ector( : b) =w.\nAs we saw in Lemma 2, any such Skolem blank node : b, generated in the dChase can uniquely be represented by the expression (i, j,w), where i is rule id, j is identifier of the existentially quantified variable yj in ri substituted by : b during the application of µ on ri. Also in the above case, we denote relation between each constant k = µext(y)(xh), xh ∈ {x}, and : b with the relation childOf. Moreover, since children of a Skolem blank node can be Skolem blank nodes, which themselves can have children, one can naturally define relation descendantOf =childOf+ as the transitive closure of childOf. Note that according to the above definition, ‘descendantOf’ is not reflexive. In addition, we could keep track of the set of contexts in which a blank-node was first generated, using the following notion:\nDefinition 5 (Origin-contexts). For any quad-system QSC and for any Skolem blank node : b ∈Bsk(dCha- se(QSC)), the set of origin-contexts of : b is given by origin-Contexts( : b) = {c | ∃i. c:(s, p, o) ∈ dChasei(QSC), s = : b or p = : b or o = : b, and ∄j < i with c′:(s′, p′, o′) ∈ dChasej(QSC), s′ = : b or p′ = : b or o′ = : b, for any c′ ∈ C}.\nIntuitively, origin-contexts for a Skolem blank node : b is the set of contexts in which triples containing : b are first generated, during the dChase construction. Note that there can be multiple contexts in which : b can simultaneously be generated. By setting originRuleId(k) = n.d., (resp. originV ector(k) = n.d., resp. originContexts(k) = n.d.,) where n.d. is an ad hoc constant, ∀k 6∈ Bsk(dChase(QSC)), we extend the definition of origin ruleId, (resp. origin vector, resp. origin-contexts) to all the constants in the dChase of a quad-system.\nExample 1. Consider the quad-system 〈QC , R〉, where QC = {c1 : (a, b, c)}. Suppose R is the following set:\nR =\n\n   \n    \nc1 : (x11, x12, z1) → c2 : (x11, x12, y1) (r1) c2 : (a, z2, x22) → c3 : (a, x22, y2) (r2) c2 : (z3, b, x32) → c3 : (b, x32, y3) (r3) c3 : (a, z41, x41), c3 : (b, z42, x42)\n→ c2 : (y4, x41, a), c2 : (y4, x42, b) (r4)\n\n   \n    \nSuppose that for brevity quantifiers have been omitted, and variables of the form yi or yij are implicitly existentially quantified. Iterations during the dChase construction are:\ndChase0(QSC) = {c1:(a, b, c)}\ndChase1(QSC) = {c1 : (a, b, c), c2 : (a, b, : b1)}\ndChase2(QSC) = {c1:(a, b, c), c2 : (a, b, : b1), c3 : (a, : b1, : b2)}\ndChase3(QSC) = {c1:(a, b, c), c2 : (a, b, : b1), c3 : (a, : b1, : b2),\nc3 : (b, : b1, : b3)}\ndChase4(QSC) = {c1:(a, b, c), c2 : (a, b, : b1), c3 : (a, : b1, : b2), c3 : (b, : b1,\n: b3), c2 : ( : b4, : b2, a), c2 : ( : b4, : b3, b)}\ndChase5(QSC) = dChase4(QSC),\nAlso note: originRuleId( : b1) = 1, originRuleId( : b2) = 2, originRuleId( : b3) = 3, originRuleId( : b4) = 4, originV ector( :b1) = 〈a, b〉, originV ector( :b2) = originV ector( :b3) = 〈 : b1〉, originV ector( :b4) = 〈 :b2, :b3〉, also originContexts( :b1) = {c2}, originConte- xts( : b2) = originContexts( : b3) = {c3}, origin- Contexts( : b4) = {c2}, also : b1 descendantOf : b3, : b1 descendantOf : b2, : b2 descendantOf : b4, : b3 descendantOf : b4, : b1 descendantOf : b4.\nFor any Skolem blank node : b (in dChase), its descendant hierarchy can be analyzed using a descendance graph 〈V,E, λr, λv, λc〉, which is a labeled graph rooted at : b, whose set of nodes V are constants in the dChase, the set of edges E is such that (k, k′) ∈ E, iff k′ is a descendant of k. λr, λv , λc are node labeling functions, such that λr(k) = originRuleId(k),λv(k) = originV ector(k), and λc(k) = originContexts(k), for any k ∈ V . The descendance graph for :b4 of Example 1 is shown in Fig.1. For any two vectors of constants v,w, we note v ∼= w, iff there exists a bijection µ : B(v) → B(w) such that w = v[µ].\nDefinition 6 (safe, msafe, csafe quad-systems). A quad-system QSC is said to be unsafe (resp. unmsafe, resp. uncsafe), iff there exist Skolem blank nodes : b 6= : b′ in dChase(QSC) such that : b is a descendant of : b′, with originRuleId( : b) = originRuleId( : b′) and originV ector( : b) ∼= originV ector( : b′) (resp. originRuleId( : b) = originRuleId( : b′), resp. originContexts( : b) = originConte-\nxts( : b′)). A quad-system is safe (resp. msafe, resp. csafe) iff it is not unsafe (resp. unmsafe, resp. uncsafe).\nIntuitively, safe, msafe and csafe quad-systems, does not allow repetitive generation of Skolem blank-nodes with a certain set of attributes in its dChase. The containment relation between the class of safe, msafe, and csafe quad-systems are established by the following theorem:\nTheorem 3. Let SAFE, MSAFE, and CSAFE denote the class of safe, msafe, and csafe quad-systems, respectively, then the following holds:\nCSAFE ⊂ MSAFE ⊂ SAFE\nProof. We first show MSAFE ⊆ SAFE, by showing the inverse inclusion of their compliments, i.e. UNSAFE ⊆ UNMSAFE. Suppose a given quad-system QSC is unsafe, then by definition its dChase contains two distinct Skolem blank nodes : b, : b′ such that : b is a descendant of : b′, with originRuleId( : b) = originRuleId( : b′) and originV ector( : b) ∼= originV ector( : b′). But this will imply that originRuleId( : b) = originRuleId( : b′). Hence, by definition,QSC is unmsafe. Hence UNSAFE ⊆ UNMSAFE (†). Now, we show that CSAFE ⊆ MSAFE by showing UNMSAFE ⊆ UNCSAFE. Suppose a given quad-system QSC = 〈QC , R〉 is unmsafe, then by definition its dChase contains two distinct Skolem blank nodes : b, : b′ such that : b is a descendant of : b′, with originRuleId( : b) = originRuleId( : b′). But this implies that there exists a BR ri = body(ri)(x, z)→ head(ri)(x, y), assignment µ, (resp. µ′,) s.t. : b (resp. : b′) was generated in dChase(QSC) as result of application of µ (resp. µ′) on ri. That is : b = yj [µ\next(y)], and : b′ = yk[µ′ext(y)], where yj , yk ∈ {y}. We have the following two subcases (i) j = k, (ii) j 6= k. Suppose (i) j = k, then it immediately follows that originContexts( : b) = originContexts( : b′). Hence, QSC is uncsafe. Suppose (ii) j 6= k, then by construction of dChase, on application of µ′ to ri, along with : b′, there gets also generated a Skolem blank node : b′′ = yj [µ′ext(y)], with yj ∈ {y}. Since : b and : b′′ are generated by substitutions of the same variable yj ∈ {y} of BR ri, originContexts( : b) = originContexts( : b′′). Also considering that childOf( : b′) = childOf( : b′′) = {x[µ′ext(y)]}, we can deduce that : b is a descendant of : b′′. Hence, by definition, it holds that QSC is uncsafe. Hence UNMSAFE ⊆ UNCSAFE (‡).\nFrom † and ‡, it follows that CSAFE ⊆ MSAFE ⊆ SAFE. To show that the containments are strict, consider the quad-system QSC in example 1. By definition, QSC is msafe, however uncsafe, as the Skolem blank nodes : b1, : b4, which have the same origin contexts are s.t. : b1 is a descendant of : b4. Hence, CSAFE ⊂ MSAFE. For MSAFE ⊂ SAFE, the following example shows an instance of a quad-system that is unmsafe, yet is safe.\nExample 2. Consider the quad-system QSC = 〈QC , R〉, where QC = {c1 : (a, b, c), c2 : (c, d, e)}, R is given by:\nc1 : (x11, x12, x13), c2 : (x13, x14, z1) → c3 : (y1, x11, x12), c4 : (x12, x13, x14) (r1)\nc3 : (x21, a, x22), c4 : (x22, x23, x24) → c1 : (x21, a, x22), c2 : (x22, x23, x24) (r2)\nc3 : (x21, x22, a), c4 : (a, x23, x24) → c1 : (x21, x22, a), c2 : (a, x23, x24) (r3)\nc3 : (x21, x22, x23), c4 : (x23, a, x24) → c1 : (x21, x22, x23), c2 : (x23, a, x24) (r4)\nc3 : (x21, x22, x23), c4 : (x23, x24, a) → c1 : (x21, x22, x23), c2 : (x23, x24, a) (r5)\nNote that for brevity quantifiers have been omitted, and variables of the form yi or yij are implicitly existentially quantified. Iterations during the dChase construction are:\ndChase0(QSC) = {c1:(a, b, c), c2:(c, d, e)}\ndChase1(QSC) = dChase0(QSC) ∪ {c3 : ( : b1, a, b), c4 : (b, c, d)}\ndChase2(QSC) = dChase1(QSC) ∪ {c1 : ( : b1, a, b), c2 : (b, c, d)}\ndChase3(QSC) = dChase2(QSC) ∪ {c3 : ( : b2, : b1, a), c4 : (a, b, c)}\ndChase4(QSC) = dChase3(QSC) ∪ {c1 : ( : b2, : b1, a), c2 : (a, b, c)}\ndChase5(QSC) = dChase4(QSC) ∪ {c3 : ( : b3, : b2, : b1), c4 : ( : b1, a, b)}\ndChase6(QSC) = dChase5(QSC) ∪ {c1 : ( : b3, : b2, : b1), c2 : ( : b1, a, b)}\ndChase7(QSC) = dChase6(QSC) ∪ {c3 : ( : b4, : b3, : b2), c4 : ( : b2, : b1, a)}\ndChase8(QSC) = dChase7(QSC) ∪ {c1 : ( : b4, : b3, : b2), c2 : ( : b2, : b1, a)}\ndChase9(QSC) = dChase8(QSC) ∪ {c3 : ( : b5, : b4, : b3), c4 : ( : b3, : b2,\n: b1)}\ndChase(QSC) = dChase9(QSC)\nIt can be seen that : b1, : b2, : b3, : b4, : b5 form a descendant chain, since : bi descendantOf : bi+1, for each i = 1, . . . , 4. Also, originRuleId( : bi) = originRuleId( : bi+1), for each i = 1, . . . , 4. Hence it turns out that QSC is unmsafe. However, it can be seen that originV ector( : b1) = 〈a, b, c, d〉, and originV ector( : b2) = 〈 : b1, a, b, c〉, and originV ector( : b3) = 〈 : b2, : b1, a, b〉, and originV ector( : b4) = 〈 : b3, : b2, : b1, a〉, and originV ector( : b5) = 〈 : b4, : b3, : b2, : b1〉, and originV ector( : bi) 6∼= originV ector( : bj), for 1 ≤ i 6= j ≤ 5, and hence, by definition, QSC is safe with a terminating dChase. It can be noticed that during each distinct application of r1, the vector of constants bound to the vector of variables 〈x11, . . . , x14〉 are different w.r.t ∼=. Safe quad-systems in this way are capable of recognizing such positive cases of finite dChases (which are classified as negative cases by msafe quadsystems) by also keeping track of the origin vectors of Skolem blank-nodes in their dChases.\nThe following property shows that for a safe quad-system, the descendance graph of any Skolem blank node in its dChase is a directed acyclic graph (DAG):\nProperty 2 (DAG property). For a safe (csafe, msafe) quad-system QSC, and for any blank node b ∈ Bsk(dChase(QSC)), its descendance graph is a DAG.\nProof. By construction, as there exists no descendant for any constant k ∈ C(QSC), there cannot be any out-going edge from any such k. Hence, no member of C(QSC) can be involved in cycles. Therefore, the only members that can be involved in cycles are the members of C(dChase(QSC))−C(QSC) =Bsk(dChase(QSC)). But if there exists : b ∈ Bsk(dChase(QSC)), such that there exists a cycle through : b, then this implies that : b is a descendant of : b. This would violate the prerequisites of being safe (resp. csafe, resp. msafe), and imply that QSC is unsafe (resp. uncsafe, resp. unmsafe), which is a contradiction.\nAlgorithm 1: UnRavel (Descendance Graph G) /* procedure to unravel, a descendance graph into a tree */ Input : descendance graph G = 〈V,E, λr , λv , λc〉 Output: A labeled Tree G begin\nG = 〈V,E, λr, λv , λc〉 := RemoveTranstiveEdges(G); foreach Node vo ∈ preOrder(G) do\nif (k = indegree(vo)) > 1 then {v1, ..., vk} :=getFreshNodes();/* each vi 6∈ V is fresh */ /* replace old node vo by the fresh nodes in V */ removeNodeFrom(vo, V ); addNodesTo({v1, ..., vk}, V ); foreach (vo, v′) ∈ E do\n/* replace each outgoing edge from vo with a fresh outgoing edges from each fresh node vi */ removeEdgeFrom((vo, v ′), E); addEdgesTo({(v1, v ′), ..., (vk, v ′)}, E);\ni := 1; foreach (v′, vo) ∈ E do\n/* replace each incoming edge of vo with an incoming edge for a unique vi */ removeEdgeFrom((v′, vo), E); addEdgeTo((v′, vi), E); i++;\n/* restrict node labels to the updated set of nodes in V */ λr := λr |V , λv := λv |V , λc := λc|V ; return G;\nSince the descendance graph G of any Skolem blank node : b ∈ Bsk(dChase(QSC)) is such that G is rooted at : b and is acyclic, any directed path from : b terminates at some node. Hence, one can use a tree traversal technique, such as preorder (visit a node first and then its children) to sequentially traverse nodes in G. Algorithm 1 takes a descendance graph G and unravels it into a tree. The algorithm first removes all the transitive edges from G, i.e. if there are v, v′ ∈ V with (v, v′) ∈ E and G contains a path of length greater than 1 from v to v′, then it removes (v, v′). Note that, in the resulting graph, the presence of a path from v to v′′ still gives us the information that v′′ is a descendant of v. The algorithm then traverses the graph in preorder fashion, as it encounters a node v, if v has an indegree k greater than one, it replaces v with k fresh nodes v1, ..., vk, and distributes the set of edges incident to v across v1, ..., vk, such that (i) each vi has at-most one incoming edge (ii) all the edges incident to v are incident to some vi, i ∈ {1, . . . , k}. Outgoing edges of v are copied for each vi. Hence, after the above operation each vi has an indegree 1, whereas outdegree of vi is same as the outdegree of v, i ∈ {1, . . . , k}. Hence, after all the nodes are visited, every node except the root in the new graph G has an indegree 1. G is still rooted, connected, acyclic, and is hence a tree. The algorithm terminates as there are no cycles in the graph, and at some point reaches a node with no children. For instance, the unraveling of the descendance graph of :b4 in Fig. 1 is shown in Fig. 2. The following property holds for any Skolem blank node of a safe quad-system.\nProperty 3. For a safe quad-system QSC = 〈QC , R〉, and any Skolem blank node in dChase(QSC), the unraveling (Algorithm 1) of its descendance graph results in a tree t = 〈V , E, λr , λv , λc〉 s.t.:\n1. any leaf node of t is from the set C(QSC), 2. any non-leaf node of t is from Bsk(dChase(QSC)), 3. order(t) ≤ w, where w =maxr∈R|fr(r)|, 4. there cannot be a path between b 6= b′ ∈ V , with λr(b) = λr(b′) and λv(b) ∼=\nλv(b ′),\n5. there cannot be a path between b 6= b′ ∈ V , with λr(b) = λr(b′), if QSC is also msafe, 6. there cannot be a path between b 6= b′ ∈ V , with λc(b) = λc(b′), if QSC is also csafe.\nProof. 1. Any node n in the descendance graph is such that n ∈ C(dChase(QSC)), and C(dChas- e(QSC)) = C(QSC) ⊎ Bsk(dChase(QSC)). Since any member m ∈ Bsk(dChase(QSC)) is generated from an application of a BR with an assignment µ such that its frontier variables are assigned by µ with a set of constants, m has at-least one child. But, since n is a leaf node, n ∈ C(QSC).\n2. Since no member m ∈ C(QSC) can have descendants and any non-leaf node has children, m cannot be a non-leaf node. Hence, non-leaf nodes must be from Bsk(dChase( QSC)). 3. The order of t is the maximal outdegree among the nodes of t, and outdegree of a node is the number of children it has. Since any node in t with non-zero outdegree is a Skolem blank-node : b generated by application of an assignment µ to r =\nbody(r)(x, z)→ head(r)(x, y) ∈ R, the number of children : b has equals ‖x‖. Hence the order of t is bounded by w. 4. Since any path from b to b′ implies that b′ is a descendant of b, it must be the case that λr(b) 6= λr(b′) or λv(b) 6∼= λv(b′), otherwise safety condition would be violated.\n5. Similar as above, immediate by definition. 6. Similar as above, immediate by definition.\nThe property above is exploited to show that there exists a finite bound in the dChase size and its computation time.\nLemma 3. For any safe/msafe/csafe quad-systemQSC = 〈QC , R〉, the following holds: (i) the dChase size ‖dChase(QSC)‖ = O(22\n‖QSC‖), (ii) dChase(QSC) can be computed in 2EXPTIME, (iii) if ‖R‖ and the set of schema triples in QC is fixed to a constant, then ‖dChase(QSC)‖ is a polynomial in ‖QSC‖ and can be computed in PTIME.\nProof. The proofs are provided for safe quad-systems, but since CSAFE ⊂ MSAFE ⊂ SAFE and since we are giving upper bounds, they also propagate trivially to msafe and csafe quad-systems.\n(i) For any Skolem blank node in dChase(QSC), the size of its originVector is upper bounded by w = maxr∈R|fr(r)|. If S is the set of all origin vectors of blanknodes in dChase(QSC), then cardinality of the set S′ = S\\ ∼= is upper bounded by (|U(QSC)| + |L(QSC)| + w)\nw , which means that |S′| = O(2‖QSC‖). Also, since the set of origin ruleId labels, Rids, can at most be |R|, the cardinality of the set Rids×S′ =O(2‖QSC‖). For the descendance tree t of any Skolem blank node of dChase(QSC), since there cannot be paths in t between distinct b and b′, such that originRuleId(b) = originRuleId(b′) and originV ector(b) ∼= originV ector(b′), the length of any such path is upper bounded by |Rids × S′| = O(2‖QSC‖). However, it turns out that the above upper bound provided is loose, as there is the need of additional filter BRs to transform/back-propagate vectors of constants associated with Skolem blank nodes generated by repetitive application of the same BR. For instance, consider the set of BRs in eg: 2. The BR r1 transforms the origin vector to a new vector each time during its application. BRs r2 - r5 deals with back propagation of these vectors back to input origin vectors of BR r1. Such filter BRs rule out the case of a BR being applied to a quad that contains a Skolem blank node that was generated using the same BR on an isomorphic origin vector, ensuring that the safety criteria for Skolem blank-nodes generated is not violated. It turns out that the number of such filter BRs required is polynomial w.r.t. to the number of descendants with the same rule id, for a node in t. Hence, it turns out the depth of t is polynomially bounded by ‖R‖. (Note that depth of t is bounded by |R| for msafe quad-systems. Also since, the set of origin context labels are bounded by the set of existential variables in R, depth of t is bounded by ‖R‖ for csafe quad-systems.) Also order of the tree is bounded by w. Hence, any such tree can have at most O(2‖QSC‖) leaf nodes, O(2‖QSC‖) inner nodes, and O(2‖QSC‖) nodes. Since each of the leaf nodes can only be from C(QSC) and each of the inner nodes correspond to an existential variable in R, the number of such possible trees are clearly\nbounded double exponentially in ‖QSC‖, hence bounds the number of Skolem blank nodes generated in the dChase.\n(ii) From (i) ‖dChase(QSC)‖ is double exponential in ‖QSC‖, and since each iteration add at-least one quad to its dChase, the number of iterations are bounded double exponentially in ‖QSC‖. Also, by Lemma 1 any iteration i can be done in time O(‖dChasei−1(QSC)‖‖R‖). Hence, by using (i), we get ‖dChasei−1(QSC)‖ = O(22 ‖QSC‖). Hence, we can infer that each iteration i can be done in timeO(2‖R‖∗2\n‖QSC‖). Also since the number of iterations is at most double exponential, computing dChase(QSC) is in 2EXPTIME.\n(iii) Since ‖R‖ is fixed to a constant, the set of existential variables is also a constant. In this case, since the size of the frontier of any r ∈ R is also a constant, the order and depth of any descendant tree t of a Skolem blank node is a constant. Hence, the number of (leaf) nodes of t is bounded by a constant. Also in this setting, the label of inner nodes of t, which correspond to existential variables, is also a constant, and the leaf nodes of t can only be a constant in C(QSC). Hence, the number of descendant trees and consequentially, the number of Skolem blank nodes generated is bounded by O(|C(QSC)|z), where z is a constant. Hence, the set of constants generated in dChase(QSC) is a polynomial in ‖QSC‖, and so is ‖dChase(QSC)‖.\nSince in any dChase iteration except the final one, at least one quad is added, and also since the final dChase can have at most O(‖QSC‖z) triples, the total number of iterations are bounded by O(‖QSC‖z) (†). By Lemma 1, since any iteration i can be computed in O(‖dChasei−1(QSC)‖‖R‖) time, and since ‖R‖ is a constant, the time required for each iteration is a polynomial in ‖dChasei−1(QSC)‖, which is at most a polynomial in ‖QSC‖. Hence, any dChase iteration can be performed in polynomial time in size of QSC (‡). From (†) and (‡), it can be concluded that dChase can be computed in PTIME.\nLemma 4. For any safe/msafe/csafe quad-system, the following holds: (i) data complexity of CCQ entailment is in PTIME, (ii) combined complexity of CCQ entailment is in 2EXPTIME.\nProof. Note that the proofs are provided for safe quad-systems, but since CSAFE ⊂ MSAFE ⊂ SAFE and since we are giving upper bounds, they also propagate trivially to msafe and csafe quad-systems.\nGiven a safe quad-system QSC = 〈QC , R〉, since dChase(QSC) is finite, a boolean CCQ CQ() can naively be evaluated by binding the set of constants in the dChase to the variables in the CQ(), and then checking if any of these bindings are contained in dChase(QSC). The number of such bindings can at most be ‖dChase(QSC)‖‖CQ()‖ (†). (i) Since for data complexity, the size of the BRs ‖R‖, the set of schema triples, and ‖CQ()‖ is fixed to a constant. From Lemma 3 (iii), we know that under the above mentioned settings the dChase can be computed in PTIME and is polynomial in the size of QSC . Since ‖CQ()‖ is fixed to a constant, and from (†), binding the set of constants in dChase(QSC) on CQ() still gives a number of bindings that is worst case polynomial in the size of ‖QSC‖. Since membership of these bindings can checked in the polynomially sized dChase in PTIME, the time required for CCQ entailment is in PTIME.\n(ii) Since in this case ‖dChase(QSC)‖ = O(22 ‖QSC‖\n) (‡), from (†) and (‡), binding the set of constants in dChase(QSC) to CQ() amounts to O(2‖CQ()‖∗2\n‖QSC‖) number of bindings. Since the dChase is double exponential in ‖QSC‖, checking the membership of each of these bindings can be done in 2EXPTIME. Hence, the combined complexity is in 2EXPTIME.\nTheorem 4. For any safe/msafe/csafe quad-system, the following holds: (i) The data complexity of CCQ entailment is PTIME-complete (ii) The combined complexity of CCQ entailment is 2EXPTIME-complete.\nProof. (i)(Membership) See Lemma 4 for the membership in PTIME. (Hardness) Follows from the PTIME-hardness of data complexity of CCQ entailment for Range-Restricted quad-systems (Theorem 8), which are contained in safe/msafe/csafe quad-systems. (ii) (Membership) See Lemma 4. (Hardness) See following heading."
    }, {
      "heading" : "4.1 2EXPTIME-Hardness of CCQ Entailment",
      "text" : "In this subsection, we show that the combined complexity of the decision problem of CCQ entailment for context acyclic quad-systems is 2EXPTIME-hard. We show this by reduction of the word-problem of a 2EXPTIME deterministic turing machine (DTM) to the CCQ entailment problem. We notify the reader that the technique we follow is, similar to works such as [35, 36], to iteratively generate a doubly exponential number of objects that represent the configurations and cells of the tape of the DTM, and then simulate its working by appropriate BRs. A DTM M is a tuple M = 〈Q,Σ,∆, q0, qA〉, where\n– Q is a set of states, – Σ is a finite set of letters that includes the blank symbol , – ∆ : (Q ×Σ) → (Q×Σ × {+1,−1}) is the transition function, – q0 ∈ Q is the initial state. – qA ∈ Q is the accepting state.\nW.l.o.g. we assume that there exists exactly one accepting state, which is also the lone halting state. A configuration is a word α ∈ Σ∗QΣ∗. A configurationα2 is a successor of the configuration α1, iff one of the following holds:\n1. α1 = wlqσσrwr and α2 = wlσ′q′σrwr, if ∆(q, σ) = (q′, σ′, R), or 2. α1 = wlqσ and α2 = wlσ′q′ , if ∆(q, σ) = (q′, σ′, R), or 3. α1 = wlσlqσwr and α2 = wlq′σlσ′wr, if ∆(q, σ) = (q′, σ′, L).\nwhere q, q′ ∈ Q, σ, σ′, σl, σr ∈ Σ, and wl,wr ∈ Σ∗. Since number of configurations can at most be doubly exponential in the size of the input string, and since 2EXPTIME ⊆ 2EXPSPACE, the number of tape cells traversed by the DTM tape head is also bounded double exponentially. A configuration c = wlqwr is an accepting configuration iff q = qA. A language L ⊆ Σ∗ is accepted by a 2EXPTIME bounded DTM M , iff for every w ∈ L, M accepts w in time O(22 ‖w‖ ).\nSimulating DTMs using Safe Quad-Systems Consider a double exponential time bounded DTM M = 〈Q,Σ,∆, q0, qA〉, and a string w, with ‖w‖ = m. Suppose that M terminates in 22 n\ntime, where n =mk, k is a constant. In order to simulate M , we construct a quad-system QSMC = 〈Q M C , R〉, where C = {c0, c1, ..., cn}, whose various elements represents the constructs of M . Let QMC be initialized with the following quads:\nc0 : (k0,rdf:type, R), c0 : (k1,rdf:type, R), c0 : (k0,rdf:type,min0),\nc0 : (k1,rdf:type,max0), c0 : (k0, succ0, k1)\nNow for each pair of elements of type R in ci, a Skolem blank-node is generated in ci+1, and hence follows the recurrence relation r(j +1) = [r(j)]2, with seed r(0) = 2, which after n iterations yields 22 n\n. In this way, a doubly exponentially long chain of elements is created in cn using the following set of rules:\nci : (x0,rdf:type, R), ci : (x1,rdf:type, R) → ∃y ci+1 : (x0, x1, y),\nci+1 : (y,rdf:type, R) (eBr)\nThe combination of the minimal element with the minimal element (elements of type mini) in ci create the minimal element in ci+1, and similarly the combination of the maximal element with the maximal element (elements of type maxi) in ci create the maximal element of ci+1:\nci+1 : (x0, x0, x1), ci : (x0,rdf:type,mini) → ci+1 : (x1,rdf:type,mini+1)\nci+1 : (x0, x0, x1), ci : (x0,rdf:type,maxi) → ci+1 : (x1,rdf:type,maxi+1)\nThe successor relation succi+1 is created in ci+1 using the following set of rules, using the well-known integer counting technique:\nci : (x1, succi, x2), ci+1 : (x0, x1, x3), ci+1 : (x0, x2, x4) → ci+1 : (x3, succi+1, x4)\nci : (x1, succi, x2), ci+1 : (x1, x3, x5), ci+1 : (x2, x4, x6), ci : (x3,rdf:type,\nmaxi), ci : (x4,rdf:type,mini) → ci+1 : (x5, succi+1, x6)\nEach of the above set of rules are instantiated for 0 ≤ i < n, and in this way after n generating dChase iterations, cn has doubly exponential number of elements of type R, that are ordered linearly using the relation succn. By virtue of the first rule below, each of the objects representing the cells of the DTM are linearly ordered by the relation succ. Also the transitive closure of succ is defined as the relation succt\ncn : (x0, succn, x1) → cn : (x0, succ, x1)\ncn : (x0, succ, x1) → cn : (x0, succt, x1)\ncn : (x0, succt, x1), cn : (x1, succt, x2) → cn : (x0, succt, x2)\nAlso using a similar construction, we can reuse the 22 n−1\nlinearly ordered elements in cn−1 to create another linearly ordered chain of a doubly exponential number of objects in cn that represents configurations of M , whose minimal element is of type conInit, and the linear order relation being conSucc.\nVarious triple patterns that are used to encode the possible configurations, runs and their relations in M are:\n(x0, head, x1) denotes the fact that in configuration x0, the head of the DTM is at cell x1. (x0, state, x1) denotes the fact that in configuration x0, the DTM is in state x1. (x0, σ, x1) where σ ∈ Σ, denotes the fact that in configuration x0, the cell x1 contains\nσ. (x0, succ, x1) denotes the linear order between cells of the tape. (x0, succt, x1) denotes the transitive closure of succ. (x0, conSucc, x1) to denote the fact that x1 is a successor configuration of x0. (x0,rdf:type, Accept) denotes the fact that the configuration x0 is an accepting\nconfiguration.\nSince in our construction, each σ ∈ Σ is represented as a relation, we could constrain that no two letters σ 6= σ′ are on the same cell using the following axiom:\ncn : (z1, σ, z2), cn : (z1, σ ′, z2) →\nfor each σ 6= σ′ ∈ Σ. Note that the above BR has an empty head, is equivalent to asserting the negation of its body.\nInitialization Suppose the initial configuration is q0w , where w = σ0...σn−1, then we enforce this using the following BRs in our quad-system QSMC as:\ncn : (x0,rdf:type, conInit), cn : (x1,rdf:type,minn) → cn : (x0, head, x1),\ncn : (x0, state, q0)\ncn : (x0,rdf:type,minn) ∧ n−1 ∧\ni=0\ncn : (xi, succ, xi+1) ∧ cn : (xj ,rdf:type,\nconInit) → n−1 ∧\ni=0\ncn : (xj , σi, xi) ∧ cn : (xj , , xn)\ncn : (xj ,rdf:type, conInit), cn : (xj , , x0), cn : (x0, succt, x1) → cn : (xj , , x1)\nThe last BR copies the to every succeeding cell in the initial configuration.\nTransitions For every left transition ∆(q, σ) = (qj , σ′, −1), the following BR:\ncn : (x0, head, xi), cn : (x0, σ, xi), cn : (x0, state, q), cn : (xj , succ, xi), cn : (x0, conSucc, x1) → cn : (x1, head, xj), cn : (x1, σ ′, xi), cn : (x1, state, qj)\nFor every right transition ∆(q, σ) = (qj , σ′,+1), the following BR:\ncn : (x0, head, xi), cn : (x0, σ, xi), cn : (x0, state, q), cn : (xi, succ, xj), cn : (x0, conSucc, x1) → cn : (x1, head, xj), cn : (x1, σ ′, xi), cn : (x1, state, qj)\nInertia If in any configuration the head is at cell i of the tape, then in every successor configuration, elements in preceding and following cells of i in the tape are retained. The following two BRs ensures this:\ncn : (x0, head, xi), cn : (x0, conSucc, x1), cn : (xj , succt, xi), cn : (x0, σ, xj)\n→ cn : (x1, σ, xj)\ncn : (x0, head, xi), cn : (x0, conSucc, x1), cn : (xi, succt, xj), cn : (x0, σ, xj)\n→ cn : (x1, σ, xj)\nThe rules above are instantiated for every σ ∈ Σ.\nAcceptance A configuration whose state is qA is accepting:\ncn : (x0, state, qA) → cn : (x0,rdf:type, Accept)\nIf a configuration of accepting type is reached, then it can be back propagated to the initial configuration, using the following BR:\ncn : (x0, conSucc, x1), cn : (x1,rdf:type, Accept) → cn : (x0,rdf:type, Accept)\nFinally M accepts w iff the initial configuration is an accepting configuration. Let CQM be CCQ: ∃y cn : (y, rdf:type, conInit), cn : (y, rdf:type, Accept). It can easily be verified that QSMC |= CQ\nM iff the initial configuration is an accepting configuration. In order to prove the soundness and completeness of our simulation, we prove the following claims:\nClaim. (1) The quad-system QSMC in the aforementioned simulation is a csafe quadsystem\nIt can be noted that the only BRs in which existentials are present are the BRs used to generate the double exponential chain of tape cells and configurations, and are of the form (eBr). Note that in each of application of such a BR, a blank-node : b generated in a context ci, for any i = 1, . . . , n, is such that originContexts( : b) = {ci} and has exactly two child blank-nodes, each of whose origin contexts is {ci−1}. Hence, any Skolem blank-node generated in any ci, for i = 1 . . . n is such that its child blank-nodes has origin contexts ci−1. Thanks to the above property, it turns out that there exists no two blank-nodes : b, : b′ in the dChase of QSMC such that : b is a descendant of : b ′ and originContexts( : b) = originContexts( : b′). Therefore QSMC is csafe.\nClaim. (2) QSMC |= CQ M iff M accepts w.\nSuppose thatQSMC |=CQ M , then by Theorem 1, there exists an assignmentµ : V(CQM ) → C, with CQM [µ] ⊆ dChase(QSC). This implies that there exists a constant o in C(dChase(QSC)), with {cn : (o, rdf:type,Accept), cn : (o, rdf:type, conInit)} ⊆ dChase(QSC . But thanks to the acceptance axioms it follows that there exists an constant o′ such that {cn : (o, conSucc, o1), cn : (o1, conSucc, o2), . . . , cn : (on, conSucc, o′)} ⊆ dChase(QSC), and cn : (o′, rdf:type, Accept) ∈ dChase(QSC).\nAlso thanks to the initialization axioms, it can be seen that o represents the initial configuration of M i.e. it represents the configuration in which the initial state is q0, and the left end of the read-write tape contains w followed by trailing s, with the read-write head positioned at the first cell of the tape. Also the transition axioms makes sure that if cn : (o, conSucc, o\n′′) ∈ dChase(QSC), then o′′ represents a successor configuration of o. That is, if o represents the configuration in which M is at state q with read-write head at position pos of the tape that contains a letter σ ∈ Σ, and if ∆(q, σ) = (q′, σ′, D), then o′′ represents the configuration in which M is at state q′, in which read-write head is at the position pos − 1/pos + 1 depending on whether D = −1/ + 1, and σ′ is at the position pos of the tape. As a consequence of the above arguments, it follows that o′ represents an accepting configuration of M , i.e. a configuration in which the state is qA, the lone accepting, halting state. This means that M accepts the string w.\nFor the converse, we briefly show that if QSMC 6|= CQ M then M does not accept w. Suppose that QSMC 6|= CQ M , then by Theorem 1, for every assignment µ : V(CQM ) →C, it should be the case that CQM [µ] 6⊆ dChase(QSC). By the initialization axioms, we know that there exists a constant o ∈ C(dChase(QSC)) with cn : (o, rdf:type, conInit) ∈ dChase(QSC). We know that o represents the initial configuration of M . Also by the initial construction axioms of QSMC , we know that o is the initial element of a double exponential chain of objects that are linearly ordered by property symbol conSucc. From transition axioms we know that, if, for any o′′, cn : (o, conSucc, o′′) ∈ dChase(QSC), then o′′ represents a valid successor configuration of o, which itself holds for o′′, and so on. This means that for none of the succeeding double exponential configurations of M , the accepting state qA holds. This means that M does not reach an accepting configuration with string w, and hence rejects it.\nSince the construction above shows the existence of a polynomial time reduction of the word problem of a 2EXPTIME DTM, which is a 2EXPTIME-hard problem, to the CCQ entailment problem over csafe quad-systems, it immediately follows that CCQ entailment over csafe/msafe/safe quad-systems is 2EXPTIME-hard."
    }, {
      "heading" : "4.2 Procedure for detecting safe/msafe/csafe quad-systems",
      "text" : "In this subsection, we present a procedure for deciding whether a given quad-system is safe (resp. msafe, resp. csafe) or not. If the quad-system is safe (resp. msafe, resp. csafe), the result of the procedure is a safe dChase (resp. msafe dChase, csafe dChase) that contains the standard dChase, and can be used for query answering. Since the safety (resp. msafety, resp. csafety) property of a quad-system is attributed to the dChase of the quad-system, the procedure nevertheless performs the standard operations for computing the dChase, but also generate quads that indicate origin ruleIds and origin vectors (resp. origin ruleIds, resp. origin-contexts) of each Skolem blank node generated. In each iteration, a test for safety is performed, by checking the presence of Skolem blank-nodes that violate the safety (resp. msafety, resp. csafety) condition. In case a violation is detected, a distinguished quad is generated and the safe (resp. msafe, resp. csafe) dChase construction is aborted, prematurely. On the contrary, if there exists an iteration in which no new quad is generated, the safe (resp. msafe, resp. csafe) dChase computation stops with a completed safe (resp. msafe, resp. csafe) dChase that contains\nthe standard dChase. Since all the additional quads produced for accounting information use a distinguished context identifier cc 6∈ C, the computed safe (resp. msafe, resp. csafe) dChase itself can be used for standard query answering. Before geting to the details of the procedure, we give a few necessary definitions.\nDefinition 7 (Context Scope). The context scope of a term t in a set of quad-patterns Q, denoted by cScope(t, Q) is given as: cScope(t, Q) = {c | c : (s, p, o) ∈ Q, s = t ∨ p = t ∨ o = t}.\nFor any quad-system QSC = 〈QC , R〉, let cc be an ad hoc context identifier such that cc 6∈ C, then for ri = body(ri)(x, z)→ head(ri)(x, y) ∈R, we define transformations augS(ri), augM(ri), augC(ri) as follows:\naugS(ri) = body(ri)(x, z) → head(ri)(x,y) ∧ ∀yj ∈ {y} [ ∧\nxk∈{x}\ncc : (xk,\ndescendantOf, yj) ∧ cc : (yj , descendantOf, yj) ∧ cc : (yj , originRuleId, i) ∧\ncc : (yj , originVector,x)]\nIt should be noted that cc : (yj , originVector, x) is not a valid quad pattern, and is only used for notation brevity. In the actual implementation, vectors can be stored using an rdf container data structure such as rdf:List, rdf:Seq or by typecasting it as a string.\naugM(ri) = body(ri)(x, z) → head(ri)(x,y) ∧ ∀yj ∈ {y} [ ∧\nxk∈{x}\ncc : (xk,\ndescendantOf, yj) ∧ cc : (yj , descendantOf, yj) ∧ cc : (yj , originRuleId, i)]\naugC(ri) = body(ri)(x, z) → head(ri)(x,y) ∧ ∀yj ∈ {y} [ ∧\nxk∈{x}\ncc : (xk,\ndescendantOf, yj) ∧ cc : (yj , descendantOf, yj) ∧ ∧\nc∈cScope(yj,head(ri))\ncc : (yj ,\noriginContext, c)]\nIntuitively, the transformation augS/augM/augC on a BR ri, augments the head part of ri with additional types of quad patterns, which are the following:\n1. cc : (xk, descendantOf, yj), for every existentially quantified variable yj in y and universally quantified variablexk ∈ {x}. This is done because, during dChase computation any application of an assignment µ to ri such that x[µ] = a, resulting in the generation of a Skolem blank node : b = µext(y)(yj), any ai ∈ {a} is a descendant of : b. Hence, due to these additional quad-patterns, quads of the form cc : (ai, descendantOf, : b) are also produced, and in this way, keeps track of the descendants of any Skolem blank node produced. 2. cc : (yj , descendantOf, yj), in order to maintain also the reflexivity of ‘descendantOf’ relation.\n3. cc : (yj , originContext, c), for every existentially quantified variable yj in {y}, every c ∈ cScope(yj , head(ri)). This is done because during dChase computation, any application of an assignment µ on ri, such that x[µ] = a, resulting in the generation of a Skolem blank node : b = µext(y)(yj), c is an origin context of : b. Hence due to these additional quad-patterns, quads of the form cc : ( : b, originContext, c) is also produced. In this way, we keep track of the origin-contexts of any Skolem blank node produced. 4. cc : (yj , originVector, x), This is done because during the dChase computation, for any application of an assignment µ on ri, such that x[µ] = a, resulting in the generation of a Skolem blank node : b = µext(y)(yj), a is the origin vector of : b. Hence, due to these additional quad-patterns, quads of the form cc : ( : b, originVector, a) is also produced. In this way, we keep track of the origin vector of any Skolem blank node produced. 5. cc : (yj , originRuleId, i), for every existentially quantified variable yj in {y}, inorder to keep track of the ruleId of the BR used to create any Skolem blank node.\nIt can be noticed that for any BR ri without existentially quantified variables, the transformations augS/augM/augC leaves ri unchanged. For any set of BRs R, let\naugS(R) (resp. augM(R), resp. augC(R)) = ⋃\nri∈R\naugS(ri) (resp. augM(ri),\nresp. augC(ri)) ∪ {cc : (x1, descendantOf, z1) ∧ cc : (z1, descendantOf, x2)\n→ cc : (x1, descendantOf, x2)}\nThe function unSafeTest (resp. unMSafeTest, resp. unCSafeTest) defined below, given a BR ri = body(ri)(x, z) → head(ri)(x, y), an assignment µ, and a quad-graph Q checks, if application of µ on ri violates the safety (resp. msafety, resp. csafety) condition on Q. unSafeTest(ri, µ,Q)=True iff ∃ : b, : b′ ∈ B, with all the following conditions being satisfied:\n– : b ∈ {x[µ]}, and – cc : ( : b′, descendantOf, : b) ∈ Q, and – cc : ( : b′, originRuleId, i) ∈ Q, and – cc : ( : b′, originVector,a) ∈ Q, and a ∼= x[µ].\nIntuitively, unSafeTest returns True, if µ applied to ri will produce a fresh Skolem blank node : b′′, whose child : b ∈ {x[µ]}, and according to knowledge in Q, : b′ is a descendant of : b such that the origin ruleId of : b′ is i (which is also the origin ruleId of : b′′) and the origin vector of : b′ is isomorphic to the origin vector of x[µ] (which is also the origin vector of : b′′). The functions unMSafeTest and unCSafeTest are similarly defined as follows: unMSafeTest(ri, µ, Q)=True iff ∃ : b, : b′ ∈ B, with all the following conditions being satisfied:\n– : b ∈ {x[µ]}, and – cc : ( : b′,descendantOf, : b) ∈ Q, and\n– cc : ( : b′, originRuleId, i) ∈ Q.\nunCSafeTest(ri, µ, Q)=True iff ∃ : b, : b′ ∈ B, ∃yj ∈ {y}, with all the following being satisfied:\n– : b ∈ {x[µ]}, and – cc : ( : b′, descendantOf, : b) ∈ Q, and – {c | cc : ( : b′, originContext, c) ∈ Q} = cScope( yj , head(ri)(x, y)) \\ {cc}.\nFor any BR ri and an assignment µ, the safe/msafe/csafe application of µ on ri w.r.t. a quad-graph QC is defined as follows:\napplysafe(ri, µ,QC) =\n{\nunSafe, If unSafeTest(ri, µ,QC) = True; apply(ri, µ), Otherwise;\napplymsafe(ri, µ,QC) =\n{\nunMSafe, If unMSafeTest(ri, µ,QC) = True; apply(ri, µ), Otherwise;\napplycsafe(ri, µ,QC) =\n{\nunCSafe, If unCSafeTest(ri, µ,QC) = True; apply(ri, µ), Otherwise;\nwhere unSafe= cc : (unsafe, unsafe, unsafe) (resp. unMSafe = cc : (unmsafe, unmsafe, unmsafe), resp. unCSafe = cc : (uncsafe, uncsafe, uncsafe)) is a distinguished quad that is generated, if the prerequisites of safety (resp. msafety, resp. csafety) is violated. For any quad-system QSC = 〈QC , R〉, we define its safe dChase dChasesafe(QSC) as follows:\ndChasesafe0 (QSC) = QC ; dChase safe m+1(QSC) = dChase safe m (QSC) ∪ apply safe(ri, µ, dChasesafem (QSC)), if ∃ ri ∈ augS(R), assignmentµ such that applicableaugS(R)(ri, µ, dChasesafem (QSC));\ndChasesafem+1(QSC) = dChase safe m (QSC), otherwise; for any m ∈ N. dChasesafe(QSC) = ⋃ m∈N dChase safe m (QSC)\nThe termination condition for safe dChase computation can be implemented using the following conditional: If there exists m such that\ndChasesafem (QSC) = dChase safe m+1(QSC); then dChasesafe(QSC) = dChase safe m (QSC).\nThe dChases dChasemsafe(QSC) and dChasecsafe(QSC) are defined, similarly, for msafe and csafe quad-systems, respectively. We bring to the notice of the reader that although application of any augS(r) (resp. augM(r), resp. augC(r)) produces quad-patterns of the form cc : ( : b, descendantOf, : b), for any Skolem blank node : b generated, there is no raise of a false alarm in the unSafeTest (resp. unMSafeTest, resp. unCSafeTest). This is because unSafeTest (resp. unMSafeTest, resp. unCSafeTest) on a bridge rule r = body(r)(x, z) → head(r)(x, y) and assignment µ checks if the application of µ of r with the fresh : b′′ assigned to a yi ∈ {y} by µext(y) would have a child : b 6= b′′ assigned to some xi ∈ {x} by µ, such that there exists a quad of the form cc : ( : b′, descendantOf, : b) in the safe (resp. msafe, resp. csafe) dChase constructed so far, and : b′′ and : b′ have the same origin ruleId and originVector (resp. originRuleId, resp. originContexts). Note that in the above : b′ should also be distinct from : b′′, and hence rules out the case in which unSafeTest (resp. unMSafeTest, resp. unCSafeTest) returns True because of the detection of a blank node as a self descendant of itself.\nThe following theorem shows that the procedure above described for detecting unsafe quad-systems is sound and complete:\nTheorem 5. For any quad-system QSC = 〈QC , R〉, the quad unSafe (resp. unMSafe, resp. unCSafe) ∈ dChasesafe(QSC) (resp. dChasemsafe(QSC), resp. dChasecsafe(QSC)), iff QSC is unsafe (resp. unmsafe, resp. uncsafe).\nIt should be noted that for any quad-system QSC = 〈QC , R〉, dChasesafe(QSC) (resp. dChasemsafe(QSC), resp. dChasecsafe(QSC)) is a finite set and hence the iterative procedure which we described earlier terminates, regardless of whether QSC is safe (resp. msafe, resp. csafe) or not. This is because if QSC is safe (resp. msafe, resp. csafe), then, as we have seen before, there exists a double exponential bound on number of quads in its dChase. Hence, there is an iteration in which no new quad is generated, which leads to stopping of computation. Otherwise, if QSC is unsafe (resp. msafe, resp. csafe), then from Theorem 5, we know that the quad unSafe (resp. unMSafe, resp. unCSafe) gets generated in dChasesafe(QSC) (resp. dChasemsafe(QSC), resp. dChasecsafe(QSC)) in not more than O(22\n‖QSC‖) iterations. This implies that there exists an iteration m such that the quad unSafe (resp. unMSafe, resp. unCSafe) is in dChasesafem (QSC) (resp. dChasemsafem (QSC), resp. dChase csafe m (QSC)). W.l.o.g, let m be the first such iteration. This means that there exists a BR ri ∈ R with head head(ri)(x, y), assignment µ such that applicableaugS(R)(ri, µ, dChasesafem−1(QSC)) (resp. applicableaugM(R)(ri, µ, dChasemsafem−1(QSC)), resp. applicableaugC(R)(ri, µ, dChase csafe m−1(QSC)) holds. By construction, since head(ri)[µext(y)] is not generated, and instead the quad unSafe (resp. unMSafe, resp. unCSafe) is generated, applicableaugS(R)(ri, µ, dChasesafem (QSC)) (resp. applicableaugM(R)(ri, µ, dChasemsafem (QSC)), resp. applicableaugC(R)( ri, µ, dChasecsafem (QSC)) holds yet again. This means that the termination condition is satisfied at iteration m + 1, and hence computation stops. Note that regardless of whether a given quad-system is safe (resp. msafe, resp. csafe) or not, the number of safe (resp. msafe, resp. csafe) dChase iterations is double exponentially bounded in the size of the quad-system. Consequently, we derive the following theorem.\nTheorem 6. Recognizing whether a quad-system is safe/msafe/csafe is in 2EXPTIME.\nAlso notice that after running procedure described above, if the quad unSafe (resp. unMSafe, resp. unCSafe) is not generated, then its safe (resp. msafe, resp. csafe) dChase itself can be used for CCQ answering, as in such a case the standard dChase is contained in safe (resp. msafe, resp. csafe) dChase, and all the quads generated for accounting information have the context identifier cc. Hence, for any safe (resp. msafe, resp. csafe) quad-system, for any boolean CCQ that does not contain quad patterns of the form cc : (s, p, o), the dChase entails CCQ iff the safe (resp. msafe, resp. csafe) dChase entails CCQ.\nA set of BRs R is said to be universally safe (resp. msafe, resp. csafe) iff, for any quad-graph QC , the quad-system 〈QC , R〉 is safe (resp. msafe, resp. csafe). For any set of BRs R, whose set of context identifiers is C, also let UR be the set of URIs that occur in the triple patterns of R plus an additional ad hoc blank node : bcrit, the critical quad-graph of R is defined as the set {c : (s, p, o)|c ∈ C, {s, p, o} ⊆ UR}. The following property illustrates how the critical quad-graph of a set of BRs R can be used to determine, whether or not R is universally safe/msafe/csafe.\nProperty 4. A set of BRs R is universally safe (resp. msafe, resp. csafe) iff 〈QcritC , R〉 is safe (resp. msafe, resp. csafe), where QcritC is the critical quad-graph of R."
    }, {
      "heading" : "5 Range Restricted Quad-Systems: Restricting to Range Restricted BRs",
      "text" : "In this section, we investigate the complexity of CCQ entailment over quad-systems, whose BRs do not have existentially quantified variables. Such BRs are of the form:\nc1 : t1(x, z) ∧ ... ∧ cn : tn(x, z) → c ′ 1 : t ′ 1(x) ∧ ... ∧ c ′ m : t ′ m(x)\nNote that any set of BRs R of the form above can be replaced by semantically equivalent set R′, such that each r ∈ R′ is the form:\nc1 : t1(x, z), ..., cn : tn(x, z) → c ′ 1 : t ′ 1(x) (5)\nAlso ‖R′‖ is at most quadratic in ‖R‖, and hence, w.l.o.g, we assume that each r ∈ R is of the form (5). Borrowing the parlance from the ∀∃ rules setting, where rules whose variables in the head part are contained in the variables in the body part are called range restricted rules [15], we call such BRs range restricted (RR) BRs. We call a quad-system whose BRs are all of RR-type, a RR quad-system. Since there exists no existentially quantified variable in the BRs of a RR quad-system, no Skolem blank node is produced during dChase computation. Hence, there can be no violation of the safety/msafety/csafety condition in section 4, and hence, the class of RR quad-systems are contained in the class of safe/msafe/csafe quad-systems, and is also a FEC. Of course, this containment is strict as any quad-system that contains a BR with an existential variable is not RR. Since one can determine whether or not a given quad-system is RR or not by simply iterating through set of BRs and checking their syntax, the following holds:\nTheorem 7. Recognizing whether a quad-system is RR can be done in linear time.\nIn the following, we see that restricting to RR BRs, size of the dChase becomes polynomial w.r.t. size of the input quad-system, and the complexity of CCQ entailment further reduces compared to safe/msafe/csafe quad-systems.\nLemma 5. For any RR quad-systemQSC = 〈QC , R〉, the following holds: (i) ‖dChase(QSC)‖ = O(‖QSC‖4) (ii) dChase(QSC) can be computed in EXPTIME (iii) If ‖R‖ is fixed to be a constant, dChase(QSC) can be computed in PTIME.\nProof. (i) Note that the number of constants in QSC is roughly equal to ‖QSC‖. As no existential variable occurs in any BR in a RR quad-system QSC , the set of constants C(dChase(QSC)) is contained in C(QSC). Since each c : (s, p, o) ∈ dChase(QSC) is such that c, s, p, o ∈ C(QSC), |dChase(QSC)|=O(|C(QSC )|4). Hence ‖dChase(QSC)‖ = O(|C(QSC)|4) = O(‖QSC‖4).\n(ii) Since from (i) |dChase(QSC)| = O(‖QSC‖4), and in each iteration of the dChase at least one new quad is added, the number of iterations cannot exceedO(‖QSC‖4).\nSince by Lemma 1, computation of each iteration i of the dChase requires O(|R| ∗ ‖dChasei−1(QSC)‖rs) time, where rs = maxr∈R‖r‖, and rs ≤ ‖QSC‖, time required for each iteration is of the order O(2‖QSC‖) time. Although the number of iterations is a polynomial, each iteration requires an exponential amount of time w.r.t ‖QSC‖. Hence time complexity of dChase computation is in EXPTIME.\n(iii) As we know that the time taken for application of a BR R is O(‖dChasei−1(QSC)‖‖R‖). Since ‖R‖ is fixed to a constant, application of R can be done in PTIME. Hence, each dChase iteration can be computed in PTIME. Also since the number of iterations is a polynomial in ‖QSC‖, computing dChase is in PTIME.\nTheorem 8. Data complexity of CCQ entailment over RR quad-systems is PTIMEcomplete.\nProof. (Membership) Follows from the membership in P of data complexity of CCQ entailment for safe quad-systems, whose expressivity subsumes the expressivity of RR quad-systems (Theorem 4).\n(Hardness) In order to prove P-hardness, we reduce a well known P-complete problem, 3HornSat, i.e. the satisfiability of propositional Horn formulas with at most 3 literals. Note that a (propositional) Horn formula is a propositional formula of the form:\nP1 ∧ . . . ∧ Pn → Pn+1 (6)\nwhere Pi, for 1 ≤ i ≤ n + 1, are either propositional variables or constants t, f , that represents true and false, respectively. Note that for any propositional variable P , the fact that “P holds” is represented by the formula t → P , and “P does not hold” is represented by the formula P → f . A 3Horn formula is a formula of the form (6), where 1 ≤ n ≤ 2. Note that any (set of) Horn formula(s) Φ can be transformed in polynomial time to a polynomially sized set Φ′ of 3Horn formulas, by introducing auxiliary propositional variables such that Φ is satisfiable iff Φ′ is satisfiable. A pure 3Horn formula is a 3Horn formula of the form (6), where n = 2. Any 3Horn formula φ that is not pure can be trivially converted to equivalent pure form by appending a ∧ t on the body part of φ. For instance, P → Q, can be converted to P ∧ t → Q. Hence, w.l.o.g. we assume that any set of 3Horn formulas is pure, and is of the form:\nP1 ∧ P2 → P3 (7)\nIn the following, we reduce the satisfiability problem of pure 3Horn formulas to CCQ entailment problem over a quad-system whose set of schema triples, the set of BRs, and the CCQ CQ are all fixed.\nFor any set of pure Horn formulasΦ, we construct the quad-systemQSC = 〈QC , R〉, where C = {ct, cf}. For any formula φ ∈ Φ of the form (7), QC contains a quad cf : (P1, P2, P3). In addition QC contains a quad ct : (t, rdf:type, T ). R is the singleton that contains only the following fixed BR:\nct : (x1,rdf:type, T ), ct : (x2,rdf:type, T ), cf : (x1, x2, x3) → ct : (x3,\nrdf:type, T )\nLet the CQ be the fixed query ct : (f,rdf:type, T ). Now, it is easy to see that QSC |= CQ, iff Φ is not satisfiable.\nTheorem 9. Combined complexity of CCQ entailment over RR quad-systems is in EXPTIME.\nProof. (Membership) By Lemma 5, for any RR quad-systemQSC , its dChase dChase(QSC) can be computed in EXPTIME. Also by Lemma 5, its dChase size ‖dChase(QSC)‖ is a polynomial w.r.t to ‖QSC‖. A boolean CCQ CQ() can naively be evaluated by grounding the set of constants in the dChase to the variables in the CQ(), and then checking if any of these groundings are contained in dChase(QSC). The number of such groundings can at most be ‖dChase(QSC)‖‖CQ()‖ (†). Since ‖dChase(QSC)‖ is a polynomial in ‖QSC‖, there are an exponential number of groundings w.r.t ‖CQ()‖. Since containment of each of these groundings can be checked in time polynomial w.r.t. the size of dChase(QSC), and since ‖dChase(QSC)‖ is a polynomial w.r.t. ‖QSC‖, the time complexity of CCQ entailment is in EXPTIME.\nConcerning the combined complexity of CCQ entailment of RR quad-systems, we leave the lower bounds open."
    }, {
      "heading" : "5.1 Restricted RR Quad-Systems",
      "text" : "We call those quad-systems with BRs of form (5) with a fixed bound on n as restricted RR quad-systems. They can be further classified as linear, quadratic, cubic,..., quadsystems, when n = 1, 2, 3, ..., respectively.\nTheorem 10. Data complexity of CCQ entailment over restricted RR quad-systems is P-complete.\nProof. The proof is same as in Theorem 8, since the size of BRs are fixed to constant.\nTheorem 11. Combined complexity of CCQ entailment over restricted RR quad-systems is NP-complete.\nProof. Let the problem of deciding if QSC |= CQ() be called DP’. (Membership) for any QSC whose rules are of restricted RR-type, the size of any r ∈ R is a constant. Hence, by Lemma 1, any dChase iteration can be computed in PTIME. Since the number of iterations is also polynomial in ‖QSC‖, dChase(QSC) can be computed in PTIME in the size of QSC and dChase(QSC) has a polynomial number of constants. Hence, we can guess an assignment µ for all the existential variables in CCQ CQ(), to the set of constants in dChase(QSC). Then, one can evaluate the CCQ, by checking if c : (s, p, o) ∈ dChase(QSC), for each c : (s, p, o) ∈ CQ()[µ], which can be done in time O(‖CQ‖ ∗ ‖dChase(QSC)‖), and is hence is in nondeterministic PTIME, which implies that DP’ is in NP.\n(Hardness) We show that DP’ is NP-hard, by reducing the well known NP-hard problem of 3-colorability to DP’. Given a graph G = 〈V , E〉, where V = {v1, ..., vn} is the set of nodes, E ⊆ V × V is the set of edges, the 3-colorability problem is to decide if there exists a labeling function l : V → {r, b, g} that assigns each v ∈ V to an element in {r, b, g} such that the condition: (v, v′) ∈ E → l(v) 6= l(v′), for each (v, v′) ∈ E, is satisfied.\nOne can construct a quad-system QSc = 〈Qc, ∅〉, where graphQc(c) has the following triples:\n{(r, edge, b), (r, edge, g), (b, edge, g), (b, edge, r), (g, edge, r), (g, edge, b)} LetCQ be the boolean CCQ: ∃v1, ...., vn ∧ (v,v′)∈E [ c : (v, edge, v ′)∧ c : (v′, edge, v)].\nThen, it can be seen that G is 3-colorable, iff QSc |= CQ."
    }, {
      "heading" : "6 Quad-Systems and Forall-Existential rules: A formal comparison",
      "text" : "In this section, we formally compare the formalism of quad-systems with forall-existential (∀∃) rules, which are also called Tuple generating dependencies (Tgds)/Datalog+- rules. ∀∃ rules is a fragment of first order logic in which every formula is restricted to a certain syntactic form. A ∀∃ rule is a first order formula of the form:\n∀x∀z [p1(x, z) ∧ ... ∧ pn(x, z) → ∃y p ′ 1(x,y) ∧ ... ∧ p ′ m(x,y)] (8)\nwhere x,y, z are vectors of variables such that {x}, {y} and {z} are pairwise disjoint, pi(x, z), for 1 ≤ i ≤ n are predicate atoms whose variables are from x or z, p′1(x,y), for 1 ≤ i ≤ m are predicate atoms whose variables are from x or y. We, for short, occasionally note a ∀∃ rule of the form (8) as φ(x, z) → ψ(x, y), where φ(x, z) = {p1(x, z), ..., pn(x, z)}, ψ(x, y) = {p′1(x,y), ... p ′ m(x,y)}. A set of ∀∃ rules is called a ∀∃ rule set. In the realm of ∀∃ rule sets, a conjunctive query (CQ) is an expression of the form:\n∃y p1(x,y) ∧ ... ∧ pr(x,y) (9)\nwhere pi(x,y), for 1 ≤ i ≤ r are predicate atoms over vectors x or y. A boolean CQ is defined as usual. The decision problem of whether, for a ∀∃ rule set P and a CQ Q, if P |=fol Q is called the CQ EP, where |=fol is the standard first order logic entailment relation.\nFor any quad-graph QC = {c1 : (s1, p1, o1), . . . , cn : (sr, pr, or)}, let rQC be the BR\n→ ∃yb1 , . . . , ybq c1 : (s1, p1, o1)[µB] ∧ . . . ∧ cr : (sr, pr, or)[µB],\nwhere { : b1, . . . , : bq} is the set of blank nodes in QC, and µB is the substitution function { : bi → ybi}i=1,...,q that assigns each blank-node to a fresh existentially quantified variable. It can be noted that the quad-systems 〈QC , R〉 and 〈∅, R ∪ {rQC}〉 are semantically equivalent. The following definition gives the translation functions that will be necessary to establish the relation between quad-systems and ∀∃ rule sets.\nDefinition 8 (Translations τq , τr, τccq, τ ). The translation function τq from the set of quad patterns to the set of ternary atoms is defined as: for any quad-pattern c : (s, p, o), τq(c : (s, p, o)) = c(s, p, o).\nThe translation function τbr from the set of BRs to the set of ∀∃ rules is defined as: for any BR r of the form (2):\nτbr(r) = ∀x∀z [τq(c1 : t1(x, z)) ∧ ... ∧ τq(cn : tn(x, z)) → ∃y τq(c ′ 1 : t ′ 1(x,y)) ∧ ... ∧ τq(c ′ m : t ′ m(x,y))],\nThe translation function τ from the set of quad-systems to forall-existential rule sets is defined as: for any quad-system QSC = 〈QC , R〉, τ(QSC) = τbr(R) ∪ {τbr(rQC )}, where τbr(R) = ⋃\nr∈R τbr(r). The translation function τccq from the set of boolean CCQs to the set of boolean CQs is defined as: for any boolean CCQ CQ = ∃y c1 : t1(a,y) ∧ . . .∧ cr : tr(a,y), τccq(CQ) is:\n∃y τq(c1 : t1(a,y)) ∧ . . . ∧ τq(cr : tr(a,y)).\nThe following property gives the relation between CCQ entailment of unrestricted quadsystems and standard first order CQ entailment of ∀∃ rule sets.\nProperty 5. For any quad-systemQSC, CCQ CQ, QSC |= CQ iff τ(QSC) |=fol τccq(CQ).\nProof. Notice that every context c ∈ C becomes a ternary predicate symbol in the resulting translation. Also, τ(QSC) is a ∀∃ rule set, and for any CCQ CQ, τccq(CQ) is a CQ.\nIn order to construct the restricted chase for τ(QSC), suppose that ≺q is also extended to set of instances such that for any two quad-graphs QC, Q′C′ , QC ≺q Q ′ C′ iff τq(QC) ≺q τq(Q′C′). Suppose ≺ is extended similarly to set of instances. Also assume that during the construction of standard chase chase(τ(QSC)) of τ(QSC), for any application of a τbr(r) with existential variables, with r ∈ R, suppose that the Skolem blank nodes generated in chase(τ(QSC)) follow the same order as they are generated in dChase(QSC). Also let us extend the rule applicability function to the ∀∃ rules settings such that for any set of BRs R, for any r ∈ R, quad-graph Q′C′ , assignment µ, applicableR(r, µ,Q ′ C′) iff applicableτbr(R)(τbr(r), µ, τq(Q ′ C′)).\nNow dChase0(〈∅,R ∪ {rQC}〉) = ∅, and also chase0(τ(QSC)) = ∅, dChase1(QSC) = apply(rQC , µ∅), whereµ∅ is the empty function, chase1(τ(QSC)) = apply(τbr(rQC ), µ∅), and so on. It is straightforward to see that for any m ∈ N, τq( dChasem(〈∅, R ∪ {rQC}〉)) = chasem(τ(QSC)). As a consequence, τq(dChase(QSC)) = chase(τ(QSC)), and {CQ}[σ] ⊆ dChase(QSC) iff {τccq(CQ)}[σ] ⊆ chase(τ(QSC)).\nHence, applying Theorem 1 and the analogous theorem for ∀∃ rulesets from Deutch et al. [30], it follows that for any quad-systemQSC = 〈QC , R〉 and a boolean CCQ CQ, QSC |= CQ iff τ(QSC) |=fol τccq(CQ).\nTheorem 12. There exists a polynomial time translation function τ (resp. τccq) from the set of unrestricted quad-systems (resp. CCQs) to the set of ∀∃ rule sets (resp. CQs), such that for any unrestricted quad-system QSC and a CCQ CQ, QSC |= CQ iff τ(QSC) |=fol τccq(CQ).\nProof. It is easy to see that τq , τbr, τ , and τccq in Definition 8 can be implemented using simple syntax transformation, by iterating through the respective components of a quad-system/CCQ, and the time complexity of these functions are linear w.r.t their inputs.\nNotice that for any CCQ CQ (resp. CQ Q), → CQ (resp. → Q) is a bridge (resp. ∀∃) rule, with an empty body. Also, since for any quad-graph QC, the translation function τbr defined above can directly be applied on rQC to obtain a ∀∃ rule, the following theorem immediately follows:\nTheorem 13. For quad-systems, the EPs: (i) quad EP, (ii) quad-graph EP, (iii) BR EP, (iv) BRs EP, (v) Quad-System EP, and (vi) CCQ EP are polynomially reducible to entailment of ∀∃ rule sets.\nA ∀∃ rule set P is said to be a ternary ∀∃ rule set, iff all the predicate symbols in the vocabulary of P are of arity less than or equal to three. P is a purely ternary rule set, iff all the predicate symbols in the vocabulary P is of arity three. Similarly, a (purely) ternary CQ is defined. The following property gives the relation between the CQ entailment problem of ∀∃ rule sets and CCQ EP of unrestricted quad-systems.\nTheorem 14. There exists a polynomial time tranlation function ν (resp. νcq) from ternary ∀∃ rule sets (resp. ternary CQs) to unrestricted quad-systems (resp. CCQs) such that for any ternary ∀∃ rule set P and a ternary CQ Q, P |=fol CQ iff 〈∅, ν(P)〉 |= νcq(Q).\nProof. Note that the CQ EP of any ternary ∀∃ rule set P, whose set of predicate symbols is P , and CQ Q over P , can polynomially reduced to the CQ EP of a purely ternary rule set P′ and purely ternary CQ Q′, by the following transformation function χ. Let be an adhoc fresh URI; χ is such that for any ternary atom c(s, p, o), χ(c(s, p, o)) = c(s, p, o). For any binary atom c(s, p), χ(c(s, p)) = c(s, p, ), and for any unary atom c(s), χ(c(s)) = c(s, , ). For any ∀∃ rule r of the form (8),\nχ(r) = ∀x∀z [χ(p1(x, z)) ∧ . . . ∧ χ(pn(x, z)) → ∃y χ(p′1(x,y)) ∧ . . . ∧ χ(p ′ m(x,y))]\nAnd, for any ∀∃ rule set P, χ(P) = ⋃\nr∈P χ(r). For any CQ Q, χ(Q) is similarly defined. Note that for any ternary ∀∃ rule set P, ternary CQ Q, χ(P) (resp. χ(Q)) is purely ternary, and P |=fol Q iff χ(P) |=fol χ(Q).\nAlso, it can straightforwardly seen that τ−1br (χ(P)) (resp. τ −1 ccq(χ(Q))) is a set of BRs (resp. CCQ). Suppose, ν(P) is such that ν(P) = QSC = 〈∅, τ −1 br (χ(P))〉. Intuitively, C contains a context identifier c, for each predicate symbol c ∈ P . Also suppose, νcq(Q) = τ −1 ccq(χ(Q)). Notice that νcq(Q) is CCQ. It can straightforwardly seen that ν and νcq can be computed in polynomial time, and P |=fol Q iff ν(P) |= νcq(Q).\nThanks to Theorem 12 and Theorem 14, the following theorem immediately holds:\nTheorem 15. The CCQ EP over quad-systems is polynomially equivalent to CQ EP over ternary ∀∃ rule sets.\nBy virtue of the theorem above, we derive the following property:\nProperty 6. For quad-systems, the Quad EP, Quad-graph EP, BR(s) EP, and Quadsystem EP are polynomially reducible to CCQ EP.\nProof. The following claim is a folklore in the realm of ∀∃ rules.\nClaim. (1) The ∀∃ rule set EP is polynomially reducible to CQ EP.\nReducibility of ∀∃ rule EP to CQ EP is a folklore in the realm of ∀∃ rules. For a formal proof, we refer the reader to Baget et al. [15], where it is shown that the ∀∃ rule EP is polynomially reducible to fact (a set of instances) EP, and fact EP are equivalent to CQ EP. Also, Cali et al [34] show that CQ containment problem, which is equivalent to ∀∃ rule EP, is reducible to CQ EP. Since a ∀∃ rule set is a set of ∀∃ rules, by using a series of oracle calls to a function that solves the ∀∃ rule EP, we can define a function for deciding ∀∃ rule set entailment. Hence, the claim holds.\n(a) Thanks to translation functions τ , τbr defined earlier, such that for any quadsystem QSC , quad-graph Q′C′ , QSC |= Q ′ C′ iff τ(QSC) |=fol τbr(rQ′C′ ), we can infer that quad-graph EP is polynomially reducible to ∀∃ rule set EP. Applying claim 1, it follows the quad-graph EP over quad-systems is polynomially reducible to CQ EP over ∀∃ rule sets. By Theorem 14, we can deduce that quad-graph EP is polynomially reducible to CCQ EP.\n(b) By the translation functions τ and τbr , defined earlier, such that for any quadsystem QSC, a set of BRs R, QSC |= R iff τ(QSC) |=fol τbr(R), we can infer that BRs EP is polynomially reducible to ∀∃ rule set EP. Similar to (a) above, we deduce that BRs EP is polynomially reducible to CCQ EP.\nFrom (a) and (b), it follows that Quad-system EP is reducible to CCQ EP.\nHaving seen that the CCQ EP over quad-systems is polynomially equivalent to CQ EP over ternary ∀∃ rule sets, we now compare some of the well known techniques used to ensure decidability of CQ entailment in the ∀∃ rules settings to the decidability techniques for quad-systems that we saw earlier in the previous sections. Note that since all the quad-system classes we proposed in this paper are FECs, for a judicious comparison, the ∀∃ rule classes to which we compare are classes which have a finite chase property. We compare to the following three well known classes: (i) Weakly Acyclic rule sets (WA), (ii) Jointly Acyclic rule sets (JA), and (iii) Model Faithful Acyclic ∀∃ rule sets (MFA). The following property is well known in the realm of ∀∃ rules:\nProperty 7. For the any ∀∃ rule set P, the following holds:\n1. If P ∈ WA, then P ∈ JA (from [38]), 2. If P ∈ JA, then P ∈ MFA (from [32]), 3. WA ⊂ JA ⊂ MFA (from [38] and [32]).\nNote that a description of few other ∀∃ rule classes that do not have the finite chase property, but still enjoy decidability of CQ entailment are given in the related work."
    }, {
      "heading" : "6.1 Weak Acyclicity",
      "text" : "Weak acyclicity [24, 26] is a popular technique used to detect whether a ∀∃ rule set has a finite chase, thus ensuring decidability of query answering. The set WA represents class of ternary ∀∃ rule sets that have the weak acyclicity property.\nFor any predicate atom p(t1, . . . , tn), an expression 〈p, i〉, for i = 1, . . . , n is called a position of p. In the above case, t1 is said to occur at position 〈p, 1〉, t2 at 〈p, 2〉, and so on. For a set of ∀∃ rules P, its dependency graph is a graph whose nodes are positions of predicate atoms in P; for each r ∈ P of the form (8), and for any variable x occurring in position 〈p, i〉 in head of r:\n1. if x is universally quantified and x occurs in the body of r at position 〈p′, j〉, then there exists an edge from 〈p′, j〉 to 〈p, i〉 2. if x is existentially quantified, then for any universally quantified variable x′ occurring in the head of r, with x′ also occurring in the body of r at position 〈p′, j〉, there exists a special edge from 〈p′, j〉 to 〈p, i〉.\nP is called weakly acyclic, iff its dependency graph does not contain cycles going through a special edge. For any ∀∃ rule set P, if P is WA, then its chase is finite, and hence CQ EP is decidable. Note that the nodes in the dependency graph that has incoming special edges corresponds to the positions of predicates where new values are created due to existential variables, and the normal edges capture the propagation of constants from one predicate position to another predicate position. In this way, absence of cycles involving special edges ensures that newly created Skolem blank nodes are not recursively used to create other new Skolem blank nodes in the same position, leading to termination of chase computation.\nExample 3. Let us revisit the quad-system QSC = 〈QC , R〉 mentioned in example 1, whose dependency graph is shown in Fig. 3. Note that the QSC is uncsafe, since its dChase contains a Skolem blank-node : b4, which has as descendant another Skolem blank node : b1, with the same origin context c2 (see Fig. 1). However, it can be seen from Fig. 3 that the dependency graph of τ(QSC) does not contain any directed cycle involving special edges. Hence τ(QSC) is weakly acyclic.\nIt turns out that there exists no inclusion relationship between the classes WA and CSAFE in either directions, i.e. WA 6⊆ CSAFE (from example 3), and CSAFE 6⊆ WA (from the fact that WA ⊂ JA, and example 4 below). Whereas WA ⊂ MSAFE, since WA ⊂ MFA and MFA ≡ MSAFE (Theorem 16)."
    }, {
      "heading" : "6.2 Joint Acyclicity",
      "text" : "Joint acyclicity [38] extends weak acyclicity, by also taking into consideration the join between variables in body of ∀∃ rules while analyzing the rules for acyclicity. The set\nJA represents the class of all ternary ∀∃ rule sets that have the joint acyclicity property. A ∀∃ rule set P is said to be renamed apart, if for any r 6= r′ ∈ R, V(r) ∩V(r′) = ∅. Since any set of rules can be converted to an equivalent renamed apart one by simple variable renaming, we assume that any rule set P is renamed apart. Also for any r ∈ P and for a variable y, let PosrH(y) (Pos r B(y)) be the set of positions in which y occurs in the head (resp. body) of r. For any ∀∃ rule set P and an existentially quantified variable y occurring in a rule in P, we define MovP(y) as the least set with:\n– PosrH(y) ⊆ MovP(y), if y occurs in r; – PosrH(x) ⊆ MovP(y), if x is a universally quantified variable and Pos r B(x) ⊆\nMovP(y);\nfor any r ∈ P. The existential dependency graph of a (renamed apart) set of rules P is a graph whose nodes are the existentially quantified variables in P. There exists an edge from a variable y to y′, if there is a rule r ∈ P in which y′ occurs and there exists a universally quantified variable x in the head (and body) of r such that PosrB(x) ⊆ MovP(y). A ∀∃ rule set P is jointly acyclic, iff its existential dependency graph is acyclic. Analyzing the containment relationships, it happens to be the case that JA 6⊆ CSAFE (since WA ⊂ JA, and eg. 3). Also example 4 shows us that CSAFE 6⊆ JA. However JA ⊂ MSAFE, since JA ⊂ MFA and MFA ≡ MSAFE (Theorem 16).\nExample 4. Consider the quad-system QSC = 〈QC , R〉, where QC = {c1 : (a, b, c)}. Suppose R is the following set:\nR =\n\n\n\nc1 : (x11, x12, z1) → c2 : (x11, x12, y1) (r1) c1 : (x21, x22, z2), c2 : (x22, x21, x23) → c3 : (x21, x22, x23) (r2)\nc3 : (x31, x32, x33) → c1 : (x33, x31, x32) (r3)\n\n\n\nIterations during the dChase construction are:\ndChase0(QSC) = {c1:(a, b, c)}\ndChase1(QSC) = {c1 : (a, b, c), c2 : (a, b, : b1)}\ndChase(QSC) = dChase1(QSC)\nNote that the lone Skolem blank node generated is : b1, which do not have any descendants. Hence, by definition QSC is csafe (msafe/safe). Now analyzing the BRs for joint acyclicity, we note that for the only existentially quantified variable y1,\nMovR(y1) = {〈c2, 3〉, 〈c3, 3〉, 〈c1, 1〉} Since the BR r1 in which y1 occurs contains the universally quantified variable x11 in\nthe head of r1 such that Pos r1 B (x11) ⊆ MovR(y1), there exists a cycle from y1 to y1 itself in the existential dependency graph of τ(QSC). Hence, by definition τ(QSC) is not joint acyclic. Also since the class of weakly acyclic rules are contained in the class of jointly acyclic rule, it follows that τ(QSC) is also not weakly acyclic."
    }, {
      "heading" : "6.3 Model Faithful Acyclicity (MFA)",
      "text" : "MFA, proposed in Cuenca Grau et al. [32], is an acyclicity technique that guarantees finiteness of chase and decidability of query answering, in the realm of ∀∃ rules. The\nset MFA denotes the class of all ternary ∀∃ rule sets that are model faithfully acyclic. As far as we know, the MFA technique subsumes almost all other known techniques that guarantee a finite chase, in the ∀∃ rules setting. Obviously, WA ⊂ JA ⊂ MFA.\nFor any ∀∃ rule r = φ(r)(x, z) → ψ(r)(x,y), for each yj ∈ {y}, let Y jr be a fresh unary predicate unique for yj and r; furthermore, let S be a fresh binary predicate. The transformation mfa of r is defined as:\nmfa(r) = φ(r)(x, z) → ψ(r)(x,y) ∧ ∧\nyj∈{y}\n[Y jr (yj) ∧ ∧\nxk∈{x}\nS(xk, yj)]\nAlso let r1 and r2 be two additional rules defined as:\nS(x1, z) ∧ S(z, x2) → S(x1, x2) (r1) Y jr (x1) ∧ S(x1, x2) ∧ Y j r (x2) → C (r2)\nwhere C is a fresh nullary predicate. For any set of ∀∃ rules P, let ad(P) be the union of r1 with the set of rules obtained by instantiating r2, for each r ∈ P, for each existential variable yj in r. For a set of ∀∃ rules P, mfa(P) = ⋃\nr∈Pmfa(r)∪ad(P). A ∀∃ rule set P is said to be MFA, iff mfa(P) 6|=fol C. It was shown in Cuenca Grau et al. [32] that if P is MFA, then P has a finite chase, thus ensuring decidability of query answering. The following theorem establishes the fact that the notion of msafety is equivalent to MFA, thanks to the polynomial time translations between quad-systems and ternary ∀∃ rule sets.\nTheorem 16. Let τ be the translation function from the set of unrestricted quad-systems to the set of ternary ∀∃ rule sets, as defined in Definition 8, then, for any quad-system QSC = 〈QC , R〉, QSC is msafe iff τ(QSC) is MFA.\nProof. (outline) Recall that τ = 〈τq , τbr〉, where τq is the quad translation function and τbr is the translation function from BRs to ∀∃ rules. Also, τ(QSC) = τbr({rQC} ∪ R). Also, recall that for every blank node b in QC, the BR rQC contains a corresponding existentially quantified variable yb. We already saw that for such a transformation, the following property holds: for any m ∈ N, τq(dChasem(QSC)) = chasem(τ(QSC)), and for any BR r ∈R ∪ {rQC}, an assignmentµ, applicableR∪{rQC}(r, µ, dChasem(QSC)) iff applicableτ(QSC)( τbr(r), µ, chasem(τ(QSC))). Also notice that for any two blank nodes : b1, : b2, S( : b1, : b2) ∈ chase(τ(QSC)), iff : b1 is a descendant of : b2 in dChase(QSC). Hence, the relations S and descendantOf are identical.\nIntuitively, MFA looks for cyclic creation of a Skolem blank-node whose descendant is another Skolem blank-node that is generated by the same rule r = body(r)(x, z) → head(r)(x, y), by the same existential variable in yj ∈ {y} of r. Wheras, msafety looks only for generation of a Skolem blank-node : b′ whose descendant is another Skolem : b using the same rule r. Hence, if τ(QSC) is not MFA, then QSC is not msafe, and consequently onlyIf part of the theorem trivially holds.\n(If part) Suppose QSC is unmsafe, and µ and µ′ are the assignments applied on r ∈ R to create Skolem blank nodes : b and : b′, respectively, and suppose : b is a descendant of : b′ in the dChase(QSC). That is : b = µ(yj) and : b′ = µ′(yk), for yj , yk ∈ {y} of r. Suppose j = k, then the prerequisite of non-MFA is trivially\nsatisfied. Suppose if j 6= k is the case, then there exists : b′′ in dChase(QSC) such that : b′′ = µ′(yj), since µ′ is applied on r and yj ∈ {y}. This means that also in this case, the prerequisite of non-MFA is satisfied. As a consequence τ(QSC) is not MFA. Hence it follows that, QSC is msafe iff τ(QSC) is MFA.\nLet us revisit the quad-system QSC in example 2, it can be easily seen that τ(QSC) is not MFA. Recall that we have seen that QSC is safe but not msafe. We consider the Theorem 16 to be of importance, as it not only establishes the equivalence of MFA and msafety, but thanks to it and the translation τ , it can be deduced that the technique of safety, which we presented earlier, (strictly) extends the MFA technique. As far as we know, the MFA class of ∀∃ rule sets is one of the most expressive class in the realm of ∀∃ rule sets which allows a finite chase. Hence, the notion of safety that we propose can straightforwardly be ported to ∀∃ settings. The main difference between MFA and safety is that MFA only looks for cyclic creation of two distinct Skolem blank-nodes : b, : b′ that are generated by the same rule r, by the same existential variable in r. Whereas safety also takes into account the origin vectors a and a′ used during rule application to create : b and : b′, respectively, and only raises an alarm if a ∼= a′. Although, equivalence holds only between quad-systems and ternary ∀∃ rule sets, it can easily be noticed that the technique of safety can be applied to ∀∃ rule sets of arbitrary arity, and can be used to extend currently established tools and systems that work on existing notions of acyclicity such as WA, JA, or MFA."
    }, {
      "heading" : "7 Related Work",
      "text" : "Contexts and Distributed Logics Work on contexts gained its attention as early as in the 80s, as McCarthy [1] proposed context as a solution to the generality problem in AI. After this, various studies about logics of contexts mainly in the field of KR were done by Guha [18], Distributed First Order Logics by Ghidini et al. [17] and Local Model Semantics by Giunchiglia et al. [8]. Primarily in these works, contexts were formalized as a first order/propositional theory and bridge rules were provided to inter-operate the various theories of contexts. Some of the initial works on contexts relevant to semantic web were the ones like Distributed Description Logics [5] by Borgida et al., and Context-OWL [7] by Bouquet et al., and the work of CKR [13, 10] by Serafini et al. These were mainly logics based on DLs, which formalized contexts as OWL KBs, whose semantics is given using a distributed interpretation structure with additional semantic conditions that suits varying requirements. Compared to these works, the bridge rules we consider are much more expressive with conjunctions and existential variables that supports value/blank-node creation.\nTemporal RDF/Annotated RDF Studies in extending standard RDF with dimensions such as time and annotations have already been accomplished. Gutierrez et al. in [41] tried to add a temporal extension to RDF and defines the notion of a ‘temporal rdf graph’, in which a triple is augmented to a quadruple of the form t : (s, p, o), where t is a time point. Whereas annotated extensions to RDF and querying annotated graphs have been studied in Udrea et al. [42] and Straccia et al. [43]. Unlike the case of time,\nhere the quadruple has the form: a : (s, p, o), where a is an annotation. The authors provide semantics, inference rules and query language that allows for expressing temporal/annotated queries. Although these approaches, in a way address contexts by means of time and annotations, the main difference in our work is that we provide the means to specify expressive bridge rules for inter-operating the reasoning between the various contexts.\nDL+rules Works on extending DL KBs with Datalog like rules was studied by Horrocks et al. [29] giving rise to the SWRL [29] language. Related initiatives propose a formalism using which one can mix a DL ontology with the Unary/Binary Datalog RuleML sublanguages of the Rule Markup Language, and hence enables Horn-like rules to be combined with an OWL KB. Since SWRL is undecidable in general, studies on computable sub-fragments gave rise to works like Description Logic Rules [40], where the authors deal with rules that can be totally internalized by a DL knowledge base, and hence if the DL considered is decidable, then also is a DL+rules KB. The authors give various fragments of the rule bases like SROIQ rules, EL++ rules etc. and show that certain new constructs that are not expressible by plain DL can be expressed using rules, although they are finally internalized into DL KBs. Unlike in our scenario, these works consider only horn rules without existential variables.\n∀∃ rules, TGDs, Datalog+- rules Query answering over rules with universal-existential quantifiers in the context of databases, where these rules are called Datalog+- rules/tuple generating dependencies (TGDs), was done by Beeri and Vardi [14] even in the early 80s, where the authors show that the query entailment problem, in general, is undecidable. However, recently many classes of such rules have been identified for which query answering is decidable. These classes (according to [15]) can broadly be divided into the following three categories: (i) bounded treewidth sets (BTS), (ii) finite unification sets (FUS), and (iii) finite extension sets (FES). BTS contains the classes of ∀∃ rule sets, whose models have bounded treewidth. Some of the important classes of these sets are the linear ∀∃ rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38]. BTS classes in general need not have a finite chase, and query answering is done by exploiting the fact that the chase is tree shaped, whose nodes (which are sets of instances) start replicating (up to isomorphism) after a while. Hence, one could stop the computation of the chase, once it can be made sure that any future iterations of chase can only produce nodes that are isomorphic to existing nodes. A deterministic algorithm for deciding query entailment for the greedy BTS, which is a subset of this class is provided in Thomazo et al. [16].\nFUS classes include the class of ‘sticky’ rules [36, 35], atomic hypothesis rules in which the body of each rule contains only a single atom, and also the class of linear ∀∃ rules. The approach used for query answering in FUS classes is to rewrite the input query w.r.t. to the ∀∃ rule sets to another query that can be evaluated directly on the set of instances, such that the answers for the former query and latter query coincides. The approach is called the query rewriting approach. Compared to approaches proposed in this paper, these approaches do not enjoy the finite chase property, and are hence not conducive to materialization/forward chaining based query answering.\nUnlike BTS and FUS, the FES classes are characterized by the finite chase property, and hence are most related to the techniques proposed in our work. Some of the classes in this set employ termination guarantying checks called ‘acyclicity tests’ that analyze the information flow between rules to check whether cyclic dependencies exists that can lead to infinite chase. Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37]. The main approach used in these techniques is to exploit the structure of the rules and use a dependency graph that models the propagation path of constants across various predicates in the rules, and restricting the dependency graph to be acyclic. The main drawback of these approaches is that they only analyze the schema/Tbox part of the rule sets, and ignore the instance part, and hence produce a large number of false alarms, i.e. it is often the case that although dependency graph is cyclic, the chase is finite. Recently, a more dynamic approach, called the MFA technique, that also takes into account the instance part of the rule sets was proposed in Cuenca grau et al. [32], where existence of cyclic Skolem blank-node/constant generations in the chase is detected by augmenting the rules with extra information that keeps track of the Skolem function used to generate each Skolem blank-node. As shown in section 6, our technique of safety subsumes the MFA technique, and supports for much more expressive rule sets, by also keeping track of the vectors used by rule bodies while Skolem blank-nodes are generated.\nData integration Studies in query answering on integrated heterogeneous databases with expressive integration rules in the realm of data integration is primarily studied in the following two settings: (i) Data exchange [24], in which there is a source database and target database that are connected with existential rules, and (ii) Peer-to-peer data management systems (PDMS) [19], where there are an arbitrary number of peers that are interconnected using existential rules.\nThe approach based on dependency graphs, for instance, is used by Halevi et al. in the context of peer-peer data management systems [19], and decidability is attained by not allowing any kind of cycles in the peer topology. Whereas in the context of Data exchange, WA is used in [24, 26] to assure decidability, and the recent work by Marnette [37] employs the super weak acyclicity (SWA) to ensure decidability. It was shown in Cuenca Grau et al [32] that their MFA technique strictly subsumes both WA and SWA techniques in expressivity. Since we saw in section 6 that our technique of safety subsumes the MFA technique and allows the representation of much more expressive rule sets, the safety technique can straightforwardly be employed in the above mentioned systems with decidability guarantees for query answering."
    }, {
      "heading" : "8 Summary and Conclusion",
      "text" : "In this paper, we study the problem of query answering over contextualized RDF knowledge in the presence of forall-existential bridge rules. We show that the problem, in general, is undecidable, and present a few decidable classes of quad-systems. Table 1 displays the complexity results of chase computation and query entailment for the various classes of quad-systems we have derived. Classes csafe, msafe, and safe, ensure decidability by restricting the structure of Skolem blank-nodes generated in the\ndChase. Briefly, the above classes do not allow an infinite descendant chain for Skolem blank-nodes generated, by constraining each Skolem blank-node in a descendant chain to have a different value for certain attributes, whose value sets are finite. RR and restricted RR quad-systems, do not allow the generation of Skolem blank nodes, thus constraining the dChase to have only constants from the initial quad-system. The above classes which suit varying situations, can be used to extend the currently established tools for contextual reasoning to give support for expressive bridge rules with conjunctions and existential quantifiers with decidability guarantees. From an expressivity point of view, the class of safe quad-systems subsumes all the above classes, and other well known classes in the realm of ∀∃ rules with finite chases. We view the results obtained in this paper as a general foundation for contextual reasoning and query answering over contextualized RDF knowledge formats such as quads, and can straightforwardly be used to extend existing quad stores."
    }, {
      "heading" : "9 Acknowledgements",
      "text" : "We sincerely thank Loris Bozzatto (FBK-IRST, Italy), and Francesco Corcoglionitti (FBK-IRST, Italy), and Prof. Roberto Zunino (DISI, University of Trento, Italy) for all their helpful technical feedbacks on an initial version of this paper. We also thank Dr. Christoph Lange (School of Computer Science, University of Birmingham, UK), Prof. Sethumadhavan (Center for Cyber Security, Amrita University, India), and Prof. Padmanabhan T.R. (Dept. of Computer Science, Amrita University, India), for their time and motivating discussions."
    }, {
      "heading" : "A Proofs for Section 3",
      "text" : "Proof (Property 1). Note that a strict linear order is a relation that is irreflexive, transitive, and linear.\nIrreflexivity: By contradiction, suppose ≺q is not irreflexive, then there exists Q ∈ Q such that Q ≺q Q holds. This means that neither of the conditions (i) and (ii) of ≺q definition holds for Q. Hence, due to condition (iii) Q 6≺q Q, which is a contradiction.\nLinearity: Note that for any two distinct Q,Q′ ∈ Q, one of the following holds: (a) Q ⊂ Q′, (b) Q′ ⊂ Q, or (c) Q \\ Q′ and Q′ \\ Q are non-empty and disjoint. Suppose (a) is the case, then Q ≺q Q′ holds. Similarly, if (b) is the case then Q′ ≺q Q holds. Otherwise if (c) is the case, then by condition (ii), either Q ≺q Q′ or Q′ ≺q Q should hold. Hence, ≺q is a linear order over Q.\nTransitivity: Suppose there exists Q,Q′, Q′′ ∈ Q such that Q ≺q Q′ andQ′ ≺q Q′′. Then, one of the following four cases hold: (a) Q ≺q Q′ due to (i) and Q′ ≺q Q′′ due to (i), (b) Q ≺q Q′ due to (i) and Q′ ≺q Q′′ due to (ii), (c) Q ≺q Q′ due to (ii) and Q′ ≺q Q′′ due to (i), (d) Q ≺q Q′ due to (ii) and Q′ ≺q Q′′ due to (ii).\nSuppose if (a) is the case, then trivially Q ⊂ Q′′, and hence by applying condition (i) Q ≺q Q′′. Otherwise if (b) is the case, then either (1) Q ⊂ Q′′ or (2) Q 6⊂ Q′′.\nSuppose, (1) is the case then, by (i) Q ≺q Q′′. Otherwise, if (2) is the case, then since, Q ⊂ Q′, it cannot be the case that greatestQuad≺l(Q ′′\\Q)≺l greatestQuad≺l(Q ′′\\Q′), and it cannot be the case that greatestQuad≺l(Q ′ \\ Q′′) ≺l greatestQuad≺l(Q \\ Q\n′′). Hence, it should be the case that greatestQuad≺l(Q ′′ \\Q′) l greatestQuad≺l(Q ′′ \\Q) and greatestQuad≺l(Q \\Q ′′) ≺l greatestQuad≺l(Q\n′ \\Q′′). But since, greatestQuad≺l(Q ′\\Q′′)≺l greatestQuad≺l(Q ′′\\Q′), it allows us to derive greatestQuad≺l(Q \\ Q′′) ≺l greatestQuad≺l(Q ′′ \\ Q), and hence by condition (ii), Q ≺q Q′′. Hence, if (b) is the case, then in both possible cases (1) or (2), it should be the case that Q ≺q Q′′. Otherwise if (c) is the case, then similar to the arguments in (b), by condition (i) or (ii), it can easily be seen that Q ≺q Q′′.\nOtherwise, if (d) is the case, then the following must hold: greatestQuad≺l(Q \\ Q′) ≺l greatestQuad≺l(Q ′ \\Q) (†) and greatestQuad≺l(Q ′ \\Q′′) ≺l greatestQuad≺l( Q′′ \\ Q′) (‡). Suppose by contradiction Q′′ ≺q Q, then one of the following holds: (1) Q′′ ≺q Q by condition (i) or (2) Q′′ ≺q Q by condition (ii). Suppose, (1) is the case, then it should be the case that Q′′ ⊂ Q. Hence, it should not be the case that greatestQuad≺l(Q\\Q ′)≺l greatestQuad≺l(Q ′′ \\Q′) and it should not be the case that greatestQuad≺l(Q ′ \\Q′′) ≺l greatestQuad≺l(Q\n′ \\Q). Hence, it should be the case that greatestQuad≺l(Q ′′ \\Q′) l greatestQuad≺l(Q\\Q ′) (♥), and it should be the case that greatestQuad≺l(Q ′ \\Q) l greatestQuad≺l(Q\n′ \\Q′′) (♠). Applying (‡) in (♥), we get greatestQuad≺l(Q ′ \\Q′′) ≺l greatestQuad≺l(Q \\Q ′), and Applying (†) in (♠), we get greatestQuad≺l(Q\\Q ′)≺l greatestQuad≺l(Q\n′\\Q′′), which is a contradiction. Suppose if (2) is the case, then greatestQuad≺l(Q ′′ \\Q)≺l greatestQuad≺l(Q\\Q ′′). The above can be written as: greatestQuad≺l(Q ′′ \\ (Q∩Q′′)) ≺l greatestQuad≺l(Q \\ (Q∩Q\n′′)). Using Q∩Q′ ∩Q′′ ⊆ Q∩Q′, it follows that greatestQuad≺l(Q\n′′ \\ (Q∩Q′ ∩Q′′)) l greatestQuad≺l(Q\\(Q∩Q\n′∩Q′′)) (♣). Also applying similar transformation in (†) and (‡), we get greatestQuad≺l(Q\\(Q∩Q ′∩Q′′)) l greatestQuad≺l(Q ′\\(Q∩Q′∩Q′′)), and greatestQuad≺l(Q ′\\(Q∩Q′∩Q′′)) l greatestQuad≺l(Q\n′′\\(Q∩Q′∩Q′′)). From which, it follows that greatestQuad≺l(Q \\ (Q ∩ Q ′ ∩ Q′′)) l greatestQuad≺l(Q ′′ \\ (Q∩Q′∩Q′′)). Using (♣) in the above, we get greatestQuad≺l(Q \\ (Q∩Q ′∩Q′′)) = greatestQuad≺l(Q ′ \\ (Q ∩Q′ ∩Q′′)) = greatestQuad≺l(Q\n′′ \\ (Q ∩Q′ ∩Q′′)), which is a contradiction. Hence, it should be the case that Q ≺q Q′′.\nProof (Theorem 2). We show that CCQ entailment is undecidable for unrestricted quadsystems, by showing that the well known undecidable problem of “non-emptiness of intersection of context-free grammars” is reducible to the CCQ answering problem.\nGiven an alphabet Σ, string w is a sequence of symbols from Σ. A language L is a subset of Σ∗, where Σ∗ is the set of all strings that can be constructed from the alphabet Σ, and also includes the empty string ǫ. Grammars are machineries that generate a particular language. A grammar G is a quadruple 〈V, T, S, P 〉, where V is the set of variables, T , the set of terminals, S ∈ V is the start symbol, and P is a set of production rules (PR), in which each PR r ∈ P , is of the form:\nw → w′\nwhere w,w′ ∈ {T ∪ V }∗. Intuitively application of a PR r of the form above on a string w1, replaces every occurrence of the sequence w in w1 with w′. PRs are applied starting from the start symbol S until it results in a string w, with w ∈ Σ∗ or no more\nproduction rules can be applied on w. In the former case, we say that w ∈ L(G), the language generated by grammar G. For a detailed review of grammars, we refer the reader to Harrison et al. [33]. A context-free grammar (CFG) is a grammar, whose set of PRs P , have the following property:\nProperty 8. For a CFG, every PR is of the form v → w, where v ∈ V , w ∈ {T ∪ V }∗.\nGiven two CFGs, G1 = 〈V1, T, S1, P1〉 and G2 = 〈V2, T, S2, P2〉, where V1, V2 are the set of variables, T such that T ∩ (V1 ∪ V2) = ∅ is the set of terminals. S1 ∈ V1 is the start symbol of G1, and P1 are the set of PRs of the form v → w, where v ∈ V , w is a sequence of the form w1...wn, where wi ∈ V1 ∪ T . S2, P2 are defined similarly. Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [33].\nGiven two CFGs, G1 = 〈V1, T, S1, P1〉 andG2 = 〈V2, T, S2, P2〉, we encode grammars G1, G2 into a quad-system of the form QSc = 〈Qc, R〉, with a single context identifier c. Each PR r = v → w ∈ P1 ∪ P2, with w = w1w2w3..wn, is encoded as a BR of the form:\nc : (x1, w1, x2), c : (x2, w2, x3), ..., c : (xn, wn, xn+1) → c : (x1, v, xn+1) (10)\nwhere x1, .., xn+1 are variables. W.l.o.g. we assume that the set of terminal symbols T is equal to the set of terminal symbols occurring in P1 ∪ P2. For each terminal symbol ti ∈ T , R contains a BR of the form:\nc : (x,rdf:type, C) → ∃y c : (x, ti, y), c : (y,rdf:type, C) (11)\nand Qc contains only the triple:\nc : (a,rdf:type, C)\nWe in the following show that:\nQSc |= ∃y c : (a, S1, y) ∧ c : (a, S2, y) ↔ L(G1) ∩ L(G2) 6= ∅ (12)\nClaim. (1) For any w = t1, ..., tp ∈ T ∗, there exists b1, ...bp, such that c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp−1, tp, bp), c : (bp,rdf:type, C) ∈ dChase( QSc).\nwe proceed by induction on |w|.\nbase case suppose if |w| = 1, then w = ti, for some ti ∈ T . But by construction c : (a, rdf:type, C) ∈ dChase0(QSc), on which rules of the form (11) is applicable. Hence, there exists an i such that dChasei(QSc) contains c : (a, ti, bi), c : (bi,rdf:type, C), for each ti ∈ T . Hence, the base case. hypothesis for any w = t1...tp, if |w| ≤ p′, then there exists b1, ..., bp, such that c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp−1, tp, bp), c : (bp, rdf:type, C) ∈ dChase(QSc). inductive step suppose w = t1...tp+1, with |w| ≤ p′ + 1. Since w can be written as w′tp+1, where w′ = t1...tp, and by hypothesis, there exists b1, ..., bp such that c : (a, t1, b1), c : (b1, t2, b2), ..., c : (bp−1, tp, bp), c : (bp,rdf:type, C) ∈ dChase(QSc). Also since rules of the form (11) are applicable on c : (bp, rdf:type, C), and hence produces triples of the form c : (bp, ti, bip+1), c : (b i p+1, rdf:type,\nC), for each ti ∈ T . Since tp+1 ∈ T , the claim follows.\nFor a grammar G = 〈V, T, S, P 〉, whose start symbol is S, and for any w ∈ {V ∪ T }∗, for some Vj ∈ V , we denote by Vj →i w, the fact that w was derived from Vj by i production steps, i.e. there exists steps Vj → r1, ..., ri → w, which lead to the production of w. For any w, w ∈ L(G), iff there exists an i such that S →i w. For any Vj ∈ V , we use Vj →∗ w to denote the fact that there exists an arbitrary i, such that Vj →i w.\nClaim. (2) For any w = t1...tp ∈ {V ∪ T }∗, and for any Vj ∈ V , if Vj →∗ w and there exists b1, ..., bp+1, with c : (b1, t1, b2), ..., c : (bp, tp, bp+1) ∈ dChase(QSc), then c : (b1, Vj , bp+1) ∈ dChase(QSc).\nWe prove this by induction on the size of w.\nbase case Suppose |w| = 1, then w = tk, for some tk ∈ T . If there exists b1, b2 such that c : (b1, tk, b2). But since there exists a PR Vj → tk, by transformation given in (10), there exists a BR c : (x1, tk, x2) → c : (x1, Vj , x2) ∈ R, which is applicable on c : (b1, tk, b2) and hence the quad c : (b1, Vj , b2) ∈ dChase(QSc). hypothesis For any w = t1...tp, with |w| ≤ p′, and for any Vj ∈ V , if Vj →∗\nw and there exists b1, ...bp, bp+1, such that c : (b1, t1, b2), ..., c : (bp, tp, bp+1) ∈ dChase(QSc), then c : (b1, Vj , bp+1) ∈ dChase(QSc). inductive step Suppose if w = t1...tp+1, with |w| ≤ p′ + 1, and Vj →i w, and there exists b1, ...bp+1, bp+2, such that c : (b1, t1, b2), ..., c : (bp+1, tp+1, bp+2) ∈ dChase(Qc). Also, one of the following holds (i) i = 1, or (ii) i > 1. Suppose (i) is the case, then it is trivially the case that c : (b1, Vj , bp+2) ∈ dChase(QSc). Suppose if (ii) is the case, one of the two sub cases holds (a) Vj →i−1 Vk, for some Vk ∈ V and Vk →1 w or (b) there exist a Vk ∈ V , such that Vk →∗ tq+1...tq+l, with 2 ≤ l ≤ p, where Vj →∗ t1...tqVktp−l+1...tp+1. If (a) is the case, trivially then c : (b1, Vk, bq+2) ∈ dChase(QSc), and since by construction there exists c : (x0, Vk, x1) → c : (x0, Vk+1, x1), ..., c : (x0, Vk+i, x1) → c : (x0, Vj , x1) ∈ R, c : (b1, Vj , bq+2) ∈ dChase( QSc). If (b) is the case, then since |tq+1...tq+l| ≥ 2, |t1...tqV2tp−l+1...tp+1| ≤ p′. This implies that c : (b1, Vj , bp+2) ∈ dChase(QSc).\nSimilarly, by construction of dChase(QSc), the following claim can straightforwardly be shown to hold:\nClaim. (3) For any w = t1...tp ∈ {V ∪ T }∗, and for any Vj ∈ V , if there exists b1, ..., bp, bp+1, with c : (b1, t1, b2), ..., c : (bp, tp, bp+1) ∈ dChase(QSc) and c : (b1, Vj , bp+1) ∈ dChase(QSc), then Vj →∗ w.\n(a) For any w = t1...tp ∈ T ∗, if w ∈ L(G1) ∩ L(G2), then by claim 1, since there exists b1, ..., bp, such that c : (a, t1, b1), ..., c : (bp−1, tp, bp) ∈ dChase(QSc). But since w ∈ L(G1) and w ∈ L(G2), S1 → w and S2 → w. Hence by claim 2, c : (a, S1, bp), c : (a, S2, bp) ∈ dChase(QSc), which implies that dChase(QSc) |= ∃y c : (a, s1, y)∧ c : (a, s2, y). Hence, by Theorem 1,QSc |= ∃y c : (a, s1, y)∧ c : (a, s2, y). (b) Suppose if QSc |= ∃y c : (a, S1, y)∧ c : (a, S2, y), then applying Theorem 1, it follows that there exists bp such that c : (a, S1, bp), c : (a, S2, bp) ∈ dChase(QSC). Then it is the case that there exists w = t1...tp ∈ T ∗, and b1, ..., bp such that c : (a, t1, b1), ..., c : (bp−1, tp, bp), c : (a, S1, bp), c : (a, S2, bp) ∈ dChase(QSc). Then by claim 3, S1 →∗ w, S2 →∗ w. Hence, w ∈ L(G1) ∩ L(G2).\nBy (a),(b) it follows that there exists w ∈ L(G1)∩L(G2) iffQSc |= ∃y c : (a, s1, y)∧ c : (a, s2, y). As we have shown that the intersection of CFGs, which is an undecidable problem, is reducible to the problem of query entailment on unrestricted quad-system, the latter is undecidable."
    }, {
      "heading" : "B Proofs for Section 4",
      "text" : "Proof (Theorem 5). We in the following show the case of dChasecsafe(QSC), i.e. unCSafe ∈ dChasecsafe(QSC) iff QSC is uncsafe. The proof follows from Lemma 6 and Lemma 7 below.\nThe proofs for the case of dChasesafe(QSC) and dChasemsafe(QSC) is similar, and is omitted.\nLemma 6 (Soundness). For any quad-system QSC = 〈QC , R〉, if the quad unCSafe ∈ dChasecsafe(QSC), then QSC is uncsafe.\nProof. Note that augC(R) = ⋃\nr∈R augC(r) ∪ {brTR}, where brTR is the range restricted BR cc : (x1, descendantOf, z), cc : (z, descendantOf, x2)→ cc : (x1, descendantOf, x2). Also for each r ∈ R, body(r) = body(augC(r)), and for any c ∈ C, c : (s, p, o) ∈ head(r) iff c : (s, p, o) ∈ head(augC(r)). That is, head(r) = head(augC(r))(C), where head( r)(C) denotes the quad-patterns in head(r), whose context identifiers is in C. Also, head(augC(r)) = head(augC(r))(C) ∪ head(augC(r))(cc), and also the set of existentially quantified variables in head(augC(r))(cc) is contained in the set of existentially quantified variables in head(augC(r))(C) (†). We first prove the following claim:\nClaim. (0) For any quad-system QSC = 〈QC , R〉, let i be a csafe dChase iteration, let j be the number of csafe dChase iterations before i in which brTR was applied, then dChasei−j(QSC) = dChase csafe i (QSC)(C).\nWe approach the proof of the above claim by induction on i.\nbase case If i = 1, then dChasecsafe0 (QSC)(cc) = ∅ and dChase csafe 0 (QSC)(C) =\ndChasecsafe0 (QSC) = dChase0(QSC). Hence, it should be the case that applicableaugC(R)(brTR, µ, dChasecsafe0 (QSC)) does not hold, for anyµ. Hence, applicableR( r, µ, dChase0(QSC)) iff applicableaugC(R)( augC(r), µ, dChasecsafe0 (QSC)), for any r ∈ R, assignment µ. Also using (†), it follows that dChase1(QSC) = dChasecsafe1−0(QSC)(C).\nhypothesis for any i ≤ k, if i is a csafe dChase iteration, and j be the number of csafe dChase iterations before i in which brTR was applied, then dChasei−j(QSC) = dChasecsafei (QSC)(C). inductive suppose i = k + 1, then one of the following three cases should hold: (a) applicableaugC(R)(r, µ, dChasecsafek (QSC)) does not hold for any r ∈ augC(R), assignmentµ, and dChasecsafek+1(QSC) = dChase csafe k (QSC), or (b) applicableaugC(R)(\nbrTR, µ, dChasecsafek (QSC)) holds, for some assignmentµ, or (c) applicableaugC(R)(r, µ, dChasecsafek (QSC)) holds, for some r ∈ augC(R) \\ {brTR}, for some assignment µ. If (a) is the case, then it should be the case that applicableR(r′,\nµ, dChasek−j(QSC)) does not hold, for any r′ ∈ R, assignment µ. As a result dChasek+1−j(QSC) = dChasek−j(QSC), and hence, dChasek+1−j( QSC) = dChasecsafek+1(QSC)(C). If (b) is the case, then since dChase csafe k+1(QSC)(C) = dChasecsafek ( QSC)(C), dChase csafe k+1(QSC)(C) = dChasek+1−j−1( QSC) = dChasek−j(QSC). If (c) is the case, then it should the case that applicableR(r′, µ, dChasek−j(QSC), where r = augC(r′) and head(r)(C) = head(r). Hence, it should be the case that dChasecsafek+1(QSC)(C) = dChasek+1−j( QSC).\nThe following claim, which straightforwardly follows from claim 0, shows that any quad c : (s, p, o), with c ∈ C derived in csafe dChase, is also derived in its standard dChase. In this way, csafe dChase do not generate any unsound triples in any context c ∈ C.\nClaim. (1) For any quad c : (s, p, o), where c ∈ C, if c : (s, p, o) ∈ dChasecsafe(QSC), then c : (s, p, o) ∈ dChase(QSC).\nThe following claim shows that the set of origin context quads are also sound.\nClaim. (2) If there exists quad cc : (b, originContext, c) ∈ dChasecsafe(QSC), then c ∈ originContexts(b).\nIf cc : (b, originContext, c) ∈ dChasecsafe(QSC), there exists i ∈ N, such that cc : (b, originContext, c) ∈ dChasecsafei ( QSC) and there exists no j < i with cc : (b, originContext, c) ∈ dChasecsafej (QSC). But if cc : (b, originContext, c) ∈ dChase csafe i (QSC) implies that there exists an augC(r) = body(x, z) → head(x,y) ∈ augC(R), with cc : (yj , originContext, c) ∈ head(x, y), yj ∈ {y}, such that cc : (b, originContext, c) was generated due to application of an assignment µ on augC(r), with b = yj[µext(y)]. This implies that there exists c : (s, p, o) ∈ head(x,y), with s = yj or p = yj or o = yj , c ∈ C. Since according to our assumption, i is the first iteration in which cc : (b, originContext, c) is generated, it follows that i is the first iteration in which c : (s, p, o)[µext(y)] is also generated. Let k be the number of iterations before i in which brTR was applied. By applying claim 0, it should be the case that c : (s, p, o)[µext(y)] ∈ dChasei−k(QSC), and i − k should be the first such dChase iteration. Hence, c ∈ orginContexts(b). In the following claim, we prove the soundness of the descendant quads generated in a safe dChase.\nClaim. (3) For any two distinct blank nodes b, b′ in dChasecsafe(QSC), if cc : (b′, descendantOf, b) ∈ dChasecsafe(QSC) then b′ is a descendant of b.\nSince any quad of the form cc : (b′, descendantOf, b) ∈ dChasecsafe(QSC) is not an element of QC , and can only be introduced by an application of a BR r ∈ augC(R), any quad of the form cc : (b′, descendantOf, b) can only be introduced, earliest in the first iteration of dChasecsafe(QSC). Suppose cc : (b′, descendantOf, b) ∈ dChasecsafe(QSC), then there exists an iteration i ≥ 1 such that cc : (b′, descendantOf, b)∈ dChasecsafej (QSC), for any j ≥ i, and cc : (b′, descendantOf, b) 6∈ dChasecsafej′ (QSC), for any j\n′ < i. We apply induction on i for the proof.\nbase case suppose cc:(b′, descendantOf, b) ∈ dChas- -ecsafe1 ( QSC) and since b 6= b′, then there exists a BR r ∈ augC(R), ∃µ such that applicableaugC(R)( r, µ, dChasecsafe0 (QSC)), i.e. body(r)(x, z)[µ] ⊆ dChase csafe 0 (QSC) and cc : (b\n′, descendantOf, b) ∈ head(r)(x,y)[µext(y)]. Then by construction of augC(r), it follows that b = yj [µext(y)], for some yj ∈ {y} and b′ = µ(xi), for some xi ∈ {x}. Since dChase0(QSC) = dChasecsafe0 (QSC), it follows using (†) that applicableR(r\n′, µ, dChas- -e0(QSC)) holds, for r′ = body(r′)(x, z)→ head(r′)(x, y), with augC(r′) = r. Hence, by construction, it follows that b = yj[µext(y)] ∈ C(dChase1(QSC)), for yj ∈ {y} and b′ = µ(xi), for xi ∈ {x}. Hence b′ is a descendant of b (by definition).\nhypothesis if cc : (b′, descendantOf, b) ∈ dChasecsafei ( QSC), for 1 ≤ i ≤ k, then b ′ is\na descendant of b. inductive step suppose cc : (b′, descendantOf, b) ∈ dChasecsafek+1(QSC), then either (i)\ncc : (b ′, descendantOf, b) ∈ dChasecsafek (QSC) or (ii) cc : (b ′, descendantOf, b) 6∈ dChasecsafek (QSC). Suppose (i) is the case, then by hypothesis, b\n′ is a descendant of b. If (ii) is the case, then either (a) cc : (b′, descendantOf, b) is the result of the application of a brTR ∈ augC(R) on dChasecsafek (QSC) or (b) cc : (b\n′, descendantOf, b) is the result of the application of a r ∈ augC(R)\\{brTR} on dChasecsafek (QSC). If (a) is the case, then there exists a b′′ ∈ C(dChasecsafek (QSC)) such that cc : (b\n′, descendantOf, b′′)∈ dChasecsafek (QSC) and cc : (b\n′′, descendantOf, b) ∈ dChasecsafek ( QSC). Hence, by hypothesis b′ is a descendantOf b′′ and b′′ is a descendantOf b. Since ‘descendantOf’ relation is transitive, b′ is a descendantOf b. Otherwise if (b) is the case then similar to the arguments used in the base case, it can easily be seen that b′ is a descendant of b.\nSuppose if the quad unCSafe ∈ dChasecsafe(QSC), then this implies that there exists an iteration i such that the function unCSafeTest on augC(r), with r = body(r)(x, z) → head(r)(x, y) ∈ R, assignment µ, and dChasecsafei (QSC) returns True. This implies that, there exists b, b′ ∈ B, yj ∈ {y} such that body(r)(x, z)[µ] ⊆ dChasecsafei (QSC), b ∈ {µ(x)}, cc : (b′, descendantOf, b) ∈ dChasecsafei (QSC) and {c | cc : (b\n′, originContext, c) ∈ dChasecsafei (QSC)} = cScope(yj , head(r)(x, y)). Suppose k be the number of csafe dChase iterations before i, in which brTR was applied. Hence, by claim 0, dChasei−k−1(QSC) = dChasecsafei−1 (QSC)(C), and consequently applicableR( r, µ, dChasei−k−1(QSC)) holds. Hence, as a result of µ being applied on r, there exists b′′ = yj [µ\next(y)] ∈ B(dChasei−k(QSC))), with b ∈ {µ(x)}. Hence, by definition originContext(b′′) = cScope(yj , head(r)), and b is a descendantOf b′′. If b 6= b′, then by Claim 2, b′ is a descendantOf b, otherwise b′ = b and hence b′ is a descendantOf b′′. Consequently, b′ is a descendantOf b′′. Also, applying claim 3, we get that originContexts(b′) = originContexts(b′′), which means that prerequisites of uncsafety is satisfied, and hence, QSC is uncsafe.\nLemma 7 (Completeness). For any quad-system, QSC = 〈QC , R〉, if QSC is uncsafe then unCSafe ∈ dChasecsafe(QSC).\nProof. We first prove a few supporting claims in order to prove the theorem.\nClaim. (0) For any quad-systemQSC = 〈QC , R〉, suppose unCSafe 6∈ dChasecsafe(QSC), then for any dChase iteration i, there exists a j ≥ 0 such that dChasei(QSC) = dChasecsafei+j (QSC)(C).\nWe approach the proof by induction on i.\nbase case for i = 0, we know that dChase0(QSC) = dChasecsafe0 (QSC) = QC . Hence, the base case trivially holds. hypothesis for i ≤ k ∈ N, there exists j ≥ 0 such that dChasei(QSC) = dChasecsafei+j ( QSC) step case for i= k+1, one of the following holds: (a) dChasek+1(QSC) = dChasek( QSC) or (b) dChasek+1(QSC) = dChasek(QSC) ∪ head(r)( x, y)[µext(y)] and applicableR(r, µ, dChasek(QSC)) holds, for some r= body(r)(x, z)→ head(r)( x, y), assignment µ. If (a) is the case, then trivially the claim holds. Otherwise, if (b) is the case, then let j ∈ N be such that dChasek(QSC) = dChasecsafek+j(QSC)(C). Let j′ ≥ j, l ∈ N be such that applicableaugC(R)(brTR, µ, dChasecsafek+l (QSC)), for any j′ ≥ l ≥ j, and applicableaugC(R)(brTR, µ, dChasecsafek+j′+1(QSC )) does not hold. By construction, it should be the case that applicable(r′, µ, dChasecsafek+j′+1(QSC)) holds, where r\n′ = augC( r). Also since no new Skolem blank node was introduced in any csafe dChase iteration k + l, for any j ≤ l ≤ j′. It should be the case that head(r)[µext(y)] = head(r′)[µext(y)](C). Since, dChasecsafek+l (QSC)(C) = dChasek(QSC), for any j ≤ l ≤ j ′, and dChasecsafek+j′+1(QSC) = dChasecsafek+j′(QSC)∪ head(r ′)[µext(y)], dChasecsafek+j′+1(QSC)(C) = dChasek+1( QSC). Hence, the claim follows.\nThe following claim, which straightforwardly follows from claim 0, shows that, for csafe quad-systems its standard dChase is contained in its safe dChase.\nClaim. (1) Suppose unCSafe 6∈ dChasecsafe(QSC), then dChase(QSC)⊆ dChasecsafe( QSC).\nClaim below shows that the generation of originContext quads in csafe dChase is complete.\nClaim. (2) For any quad-system QSC , if unCSafe 6∈ dChasecsafe(QSC), then for any Skolem blank-node b generated in dChase(QSC), and for any c ∈ C, if c ∈ originContexts(b), then there exists a quad cc : (b, originContext, c) ∈ dChasecsafe(QSC).\nSince the only way a Skolem blank node b gets generated in any iteration i of dChase( QSC) is by the application of a BR r ∈ R, i.e. when there ∃r = body(r)(x, z) → head(r)(x, y) ∈ R, assignment µ, such that applicableR(r, µ, dChasei−1(QSC)), and b = yj [µext(y)], for some yj ∈ {y}, and dChasei(QSC) = dChasei−1(QSC) ∪ head(r)(x, y)[µext(y)]. Also since c ∈ originContexts(b), it should be the case that c ∈ cScope(yj , head(r)). From claim 0, we know that there exists j ≥ 0, such that dChasei(QSC) = dChase csafe i+j (QSC)(C). W.l.o.g, assume that i + j is the first such csafe dChase iteration. Hence, it follows that applicableaugC(R)(r′, µ, dChasecsafei+j−1( QSC)), where r′ = augC(r). Since, head(r) ⊆ head(r′), it should be the case that c ∈ cScope(yj , head(r′)). Hence, by construction of augC, cc : (yj , originContext, c) ∈\nhead(r′), and as a result of application of µ on r′ in iteration i+j, cc : (b, originContext, c) gets generated in dChasecsafei+j (QSC). Hence, the claim holds.\nFor the claim below, we introduce the concept of the sub-distance. For any two blank nodes, their sub-distance is inductively defined as:\nDefinition 9. For any two blank nodes b, b′, sub-distance(b, b′) is defined inductively as:\n– sub-distance(b, b′) = 0, if b′ = b; – sub-distance(b, b′) = ∞, if b 6= b′ and b is not a descendant of b′; – sub-distance(b, b′) =mint∈{x[µ]}{ sub-distance(b, t)} + 1, if b′ was generated by\napplication of µ on r = body(r)(x, z) → head(r)(x,y), i.e. b′ = yj[µext(y)], for some yj ∈ {y}, and b is a descendant of b′.\nClaim. (3) For any quad-system QSC = 〈QC , R〉, if unCSafe 6∈ dChasecsafe(QSC), then for any two Skolem blank nodes b, b′ in dChase(QSC), if b is a descendant of b′ then there exists a quad of the form cc : (b, descendantOf, b′) ∈ dChasecsafe(QSC).\nNote by the definition of sub-distance that if b is a descendant of b′, then sub-distance(b, b′) ∈ N. Assuming unCSafe 6∈ dChasecsafe(QSC), and b is a descendant of b′, we approach the proof by induction on sub-distance(b, b′).\nbase case Suppose sub-distance(b, b′) = 1, then this implies that there exists r = body(x, z) → head(r)(x, y), assignment µ such that b′ was generated due to application of µ on r, i.e. b′ = yj[µext(y)], for some yj ∈ {y}, and b ∈ {x[µ]}. This implies that there exists a dChase iteration i such that applicableR(r, µ, dChasei(QSC)) and dChasei+1(QSC) = dChasei(QSC) ∪ apply(r, µ). Since unCSafe 6∈ dChasecsafe(QSC), using claim 0, ∃ k ≥ i such that dChasei(QSC) = dChasecsafek (QSC)(C). W.l.o.g., let k be the first such csafe dChase iteration. This means that applicableaugC(R)(r′, µ, dChasecsafek (QSC)), where r\n′ = augC(r), and dChasecsafek+1 = dChas e csafe k (QSC) ∪ head(r ′)[µext(y)], and b, b′ ∈ head(r′ )[µext(y)], b ∈ {x[µ]}, b′ = yj [µext(y)]. By construction of augC(), since there exists a quad-pattern cc : (xl, descendantOf, yj) ∈ head(r′), for any xl ∈ {x}, yj ∈ {y}, it follows that cc : (b, descendantOf, b′) ∈ dChasecsafek+1(QSC). hypothesis Suppose sub-distance(b, b′) ≤ k, k ∈ N, then cc : (b, descendantOf, b′) ∈ dChasecsafe(QSC). inductive step Suppose sub-distance(b, b′) = k+1, then there exists a b′′ 6= b, assignment µ, and BR r = body(r)(x, z) → head(r)(x,y) ∈ R such that b′ was generated due to the application of µ or r with b′′ ∈ {x[µ]}, i.e. b′ = yj[µext(y)], for yj ∈ {y}, and b is a descendant of b′′. This implies that sub-distance(b′′, b′) = 1, and sub-distance(b, b′′) = k, and hence by hypothesis cc : (b, descendantOf, b′′) ∈ dChasecsafe(QSC), and cc : (b′′, descendantOf, b′) ∈ dChasecsafe(QSC). Hence, by construction of csafe dChase, cc : (b, descendantOf, b′) ∈ dChasecsafe( QSC).\nSuppose QSC is uncsafe, then by definition, there exists a blank nodes b, b′ in Bsk( dChase(QSC)), such that b is descendant of b′, and originContexts(b) is equal to originContexts(b′). By contradiction, if unCSafe 6∈ dChasecsafe(QSC), then by claim 1, dChase(QSC) ⊆ dChasecsafe(QSC). Since by claim 2, for any c ∈ originContexts(b),\nthere exists quads of the form cc : (b, originContext, c) ∈ dChasecsafe(QSC) and for every c′ ∈ originContexts(b′), there exists cc : (b′, originContext, c′)∈ dChasecsafe(QSC). Since originContexts(b) = originContexts(b′), it follows that {c | cc : (b, originContext, c) ∈ dChasecsafe( QSC)} = {c′ | cc : (b′, originContext, c′) ∈ dChasecsafe( QSC)} Also by claim 3, since b is a descendant of b′, there exists a quad of the form cc : (b, descendantOf, b′) in dChasecsafe(QSC). But, by construction of dChasecsafe(QSC), it should be the case that there exist a b′′ ∈ Bsk(dChasecsafe(QSC)), r= body(r)(x, z) → head(r)(x, y) ∈ augC(R), assignment µ such that b′ was generated due to the application of µ on r, i.e. b′ = yj[µext(y)] with b′′ ∈ {x[µ]}, and cc : (b, descendantOf, b′′) ∈ dChasecsafe(QSC). But, since {c | cc : (b, originContext, c) ∈ dChasecsafe(QSC)} = cScope(yj , head(ri)), the method unCSafeTest(r, µ, dChasecsafel (QSC)) should return True, for some l ∈ N. Hence, it should be the case that unCSafe∈ dChasecsafe(QSC), which is a contradiction to our assumption. Hence unCSafe ∈ dChasecsafe(QSC), if dChase(QSC) is uncsafe.\nProof (Property 4). (Only If) By definition, R is universally safe (resp. msafe, resp csafe) iff 〈QC , R〉 is safe (resp. msafe, resp. csafe), for any quad-graph QC . Hence, 〈QcritC , R〉 is safe (resp. msafe, resp. csafe).\n(If part) We give the proof for the case of safe quad-systems. The proof for the msafe and csafe case can be obtained by slight modification. In order to show that if 〈QcritC , R〉 is safe, then R is universally safe, we prove the contrapositive. That is we show that if there exists QC such that 〈QC , R〉 is unsafe, then QScritC = 〈Q crit C , R〉 is unsafe. Suppose, there exists such an unsafe quad-system QSC = 〈QC , R〉, we show how to incrementally construct a homomorphism h from constants in dChase(QSC) to the constants in dChase(QScritC ) such that for any Skolem blank node : b in dChase(QSC), there exists a homomorphism from descendance graph of : b to the descendance graph of h( : b) in dChase(QScritC ). Supposeh is initialized as: for any constant c ∈ C(QSC), h(c) = : bcrit, if c ∈ C(QSC) \\ C(QScritC ); and h(c) = c otherwise . It can be noted that for any BR r = body(r)(x, z) → head(r)(x,y) ∈ R, if body(r)[µ] ⊆ dChase0(QSC) then body(r)[µ][h] ⊆ dChase0(QScricC ). Now it follows that for any i ∈ N, level(body(r)[µ]) = 0 if applicable(r, µ, dChasei(QSC)), then there exists j ≤ i such that applicable(r, h ◦ µ, dChasej(QScritC )). Let h be extended so that for any i ∈ N, for any Skolem blank node : b introduced in dChasei+1(QSC) while applying µ on r, for existential variable y ∈ {y}, let h( : b) be the blank node introduced in dChasej+1(QScritC ), for the existential variable y while applying h ◦µ on r. Hence, it follows that, for any i ∈ N, applicableR(r, µ, dChasei(QSC)) implies there exists j ≤ i such that applicable(r, h◦µ, dChasej(QScritC )), for any r, µ. Also note that, for any Skolem blank node : b generated in dChasei(QSC), it can be noted that λr( : b) = λr(h( : b)) and λc( : b) = λc(h( : b)) and λv( : b)[h] = λv(h( : b)). Hence, it follows that for any Skolem blank node : b in dChase(QSC), h is a homomorphism from descendance graph of : b to the descendance graph of h( : b) in dChase(QScritC . Hence, if there exists two Skolem blank nodes : b, : b′ in dChase(QSC), with : b′ a descendant of : b and originRuleId( : b) = originRuleId( : b′) and originV ector( : b) ∼= originV ector( : b′), then it follows that there exists h( : b), h( : b′) in dChase( QScritC ), with h( : b ′) descendant of h( : b) and originRuleId(h( : b)) =\noriginRuleId(h( : b′)) and originV ector(h( : b))∼= originV ector(h( : b′)). Hence, it follows from the definition that QScriticC is unsafe."
    } ],
    "references" : [ {
      "title" : "Named graphs, provenance and trust,",
      "author" : [ "J. Carroll", "C. Bizer", "P. Hayes", "P. Stickler" ],
      "venue" : "WWW ’05: Proceedings of the 14th international conference on World Wide Web,",
      "citeRegEx" : "2",
      "shortCiteRegEx" : "2",
      "year" : 2005
    }, {
      "title" : "Querying for meta knowledge,",
      "author" : [ "B. Schueler", "S. Sizov", "S. Staab", "D.T. Tran" ],
      "venue" : "WWW ’08: Proceedings of the 17th international conference on World Wide Web,",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2008
    }, {
      "title" : "Distributed Description Logics: Assimilating Information from Peer Sources,",
      "author" : [ "A. Borgida", "L. Serafini" ],
      "venue" : "Journal on Data Semantics,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2003
    }, {
      "title" : "Notes on Formalizing Context,” in Proceedings of the 13th international joint conference on Artifical intelligence (ICAI",
      "author" : [ "J. McCarthy" ],
      "venue" : "Volume",
      "citeRegEx" : "6",
      "shortCiteRegEx" : "6",
      "year" : 1995
    }, {
      "title" : "C-OWL: Contextualizing Ontologies",
      "author" : [ "P. Bouquet", "F. Giunchiglia", "F. van Harmelen", "L. Serafini", "H. Stuckenschmidt" ],
      "venue" : "The Semantic Web - ISWC",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2003
    }, {
      "title" : "Local models semantics, or contextual reasoning = locality + compatibility",
      "author" : [ "F. Giunchiglia", "C. Ghidini" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2001
    }, {
      "title" : "Comparing contextual and flat representations of knowledge: a concrete case about football data",
      "author" : [ "L. Bozzato", "C. Ghidini", "L. Serafini" ],
      "venue" : "Proceedings of the seventh international conference on Knowledge capture (K-CAP",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2013
    }, {
      "title" : "Simple reasoning for contextualized RDF knowledge",
      "author" : [ "M.Joseph", "L.Serafini" ],
      "venue" : "Modular Ontologies - Proceedings of the Fifth International Workshop (WOMO-2011),",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2011
    }, {
      "title" : "Contextualized knowledge repositories for the semantic web. Web Semantics: Science, Services and Agents on the World Wide Web, Special Issue: Reasoning with Context in the Semantic",
      "author" : [ "L. Serafini", "M. Homola" ],
      "venue" : "Web, Elsevier,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2012
    }, {
      "title" : "The Implication Problem for Data Dependencies",
      "author" : [ "C. Beeri", "M.Y. Vardi" ],
      "venue" : "In Shimon Even, Oded Kariv (Eds.): Automata, Languages and Programming,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 1981
    }, {
      "title" : "On rules with existential variables: Walking the decidability line",
      "author" : [ "J.-F. Baget", "M. Leclère", "M.-L. Mugnier", "E. Salvat" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2011
    }, {
      "title" : "A Generic Querying Algorithm for Greedy Sets of Existential Rules",
      "author" : [ "M. Thomazo", "J.-F. Baget", "M.-L. Mugnier", "S. Rudolph" ],
      "venue" : "KR’12: International Conference on Principles of Knowledge Representation and Reasoning,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2012
    }, {
      "title" : "Distributed first order logics. In Frontiers Of Combining Systems 2, Studies in Logic and Computation, pages 121–140",
      "author" : [ "C. Ghidini", "L. Serafini" ],
      "venue" : "Research Studies Press,",
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 1998
    }, {
      "title" : "Schema mediation in peer data management systems,",
      "author" : [ "A.Y. Halevy", "Z.G. Ives", "D. Suciu", "I. Tatarinov" ],
      "venue" : "19th International Conference on Data Engineering In ICDE, IEEE Computer Society,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 2003
    }, {
      "title" : "Testing containment of conjunctive queries under functional and inclusion dependencies,",
      "author" : [ "D.S. Johnson", "A.C. Klug" ],
      "venue" : "Journal of Computer and System Sciences,",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1984
    }, {
      "title" : "E-Connections of Abstract Description Systems,",
      "author" : [ "O. Kutz", "C. Lutz", "F. Wolter", "M. Zakharyaschev" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2004
    }, {
      "title" : "Data Exchange: Semantics and Query Answering,",
      "author" : [ "R. Fagin", "P.G. Kolaitis", "R.J. Miller", "L. Popa" ],
      "venue" : "Theoretical Computer Science,",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2005
    }, {
      "title" : "Tractable Reasoning and Efficient Query Answering in Description Logics: The DL-Lite Family",
      "author" : [ "D. Calvanese", "G. Giacomo", "D. Lembo", "M. Lenzerini", "R. Rosati" ],
      "venue" : "In Journal of Automated Reasoning,",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2007
    }, {
      "title" : "Reformulation of XML Queries and Constraints,",
      "author" : [ "A. Deutsch", "V. Tannen" ],
      "venue" : "In Proceedings of the 9th International Conference on Database Theory (ICDT’",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2003
    }, {
      "title" : "Completeness, decidability and complexity of entailment for RDF Schema and a semantic extension involving the OWL vocabulary,",
      "author" : [ "H.J. ter Horst" ],
      "venue" : "Web Semantics: Science, Services and Agents on the WWW,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 2005
    }, {
      "title" : "Answering conjunctive queries in the SHIQ description logic,",
      "author" : [ "B. Glimm", "C. Lutz", "I. Horrocks", "U. Sattler" ],
      "venue" : "Proceedings of the Twentieth International Joint Conference on Artificial Intelligence",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2007
    }, {
      "title" : "SWRL: A Semantic Web Rule Language Combining OWL and RuleML,",
      "author" : [ "I. Horrocks", "P.F. Patel-Schneider", "H. Boley", "S. Tabet", "B. Grosof", "M. Dean" ],
      "venue" : "W3C member submission, World Wide Web Consortium,",
      "citeRegEx" : "29",
      "shortCiteRegEx" : "29",
      "year" : 2004
    }, {
      "title" : "The chase revisited,",
      "author" : [ "A. Deutsch", "A. Nash", "J. Remmel" ],
      "venue" : "Proceedings of the twenty-seventh ACM SIGMOD-SIGACTSIGART symposium on Principles of database systems, PODS ’08,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 2008
    }, {
      "title" : "Acyclicity Notions for Existential Rules and Their Application to Query Answering in Ontologies,",
      "author" : [ "B. Cuenca Grau", "I. Horrocks", "M. Krötzsch", "C. Kupke", "D. Magka", "B. Motik", "Z. Wang" ],
      "venue" : "Journal of Artificial Intelligence Research (JAIR),",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2013
    }, {
      "title" : "Introduction to Formal Language Theory",
      "author" : [ "M.A. Harrison" ],
      "venue" : null,
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 1978
    }, {
      "title" : "Taming the infinite chase: Query answering under expressive relational constraints",
      "author" : [ "A. Calı", "G. Gottlob", "M. Kifer" ],
      "venue" : "Jrme Lang (Eds.): Principles of Knowledge Representation and Reasoning (KR’",
      "citeRegEx" : "34",
      "shortCiteRegEx" : "34",
      "year" : 2008
    }, {
      "title" : "Towards more expressive ontology languages: The query answering problem,",
      "author" : [ "A. Calı", "G. Gottlob", "A. Pieris" ],
      "venue" : "Artificial Intelligence,",
      "citeRegEx" : "35",
      "shortCiteRegEx" : "35",
      "year" : 2012
    }, {
      "title" : "Query Answering under Non-guarded Rules in Datalog+/-,” in Pascal Hitzler, Thomas Lukasiewicz (Eds.) Web Reasoning and Rule Systems - Fourth International Conference (RR",
      "author" : [ "A. Calı", "G. Gottlob", "A. Pieris" ],
      "venue" : "vol. 6333 of Springer Lecture Notes in Computer Science,",
      "citeRegEx" : "36",
      "shortCiteRegEx" : "36",
      "year" : 2010
    }, {
      "title" : "Generalized schema-mappings: from termination to tractability,",
      "author" : [ "B. Marnette" ],
      "venue" : "Proceedings of the twenty-eighth ACM SIGMOD-SIGACTSIGART symposium on Principles of database systems, PODS ’09,",
      "citeRegEx" : "37",
      "shortCiteRegEx" : "37",
      "year" : 2009
    }, {
      "title" : "Extending decidable existential rules by joining acyclicity and guardedness,",
      "author" : [ "M. Krötzsch", "S. Rudolph" ],
      "venue" : "Toby Walsh (Ed.) Proceedings of the 22nd International Joint Conference on Artificial Intelligence (IJCAI’11) (T. Walsh, ed.),",
      "citeRegEx" : "38",
      "shortCiteRegEx" : "38",
      "year" : 2011
    }, {
      "title" : "Conjunctive Queries for EL with Role Composition",
      "author" : [ "M. Krötzsch", "S. Rudolph" ],
      "venue" : "Tessaris (Eds.): Proceedings of the 20th International Workshop on Description Logics (DL’07) (D. Calvanese, ed.),",
      "citeRegEx" : "39",
      "shortCiteRegEx" : "39",
      "year" : 2007
    }, {
      "title" : "Description logic rules",
      "author" : [ "M. Krötzsch", "S. Rudolph", "Pascal Hitzler" ],
      "venue" : "Proceedings of the 18th European Conference on Artificial Intelligence",
      "citeRegEx" : "40",
      "shortCiteRegEx" : "40",
      "year" : 2008
    }, {
      "title" : "Annotated RDF,",
      "author" : [ "O. Udrea", "D.R. Recupero", "V.S. Subrahmanian" ],
      "venue" : "ACM Transactions in Computational Logic, vol. 11,",
      "citeRegEx" : "42",
      "shortCiteRegEx" : "42",
      "year" : 2010
    } ],
    "referenceMentions" : [ {
      "referenceID" : 0,
      "context" : "Other benefits of quads over triples are that they allow knowledge creators to specify various attributes of meta-knowledge that further qualify knowledge [2], and also allow users to query for this meta knowledge [3].",
      "startOffset" : 155,
      "endOffset" : 158
    }, {
      "referenceID" : 1,
      "context" : "Other benefits of quads over triples are that they allow knowledge creators to specify various attributes of meta-knowledge that further qualify knowledge [2], and also allow users to query for this meta knowledge [3].",
      "startOffset" : 214,
      "endOffset" : 217
    }, {
      "referenceID" : 6,
      "context" : "When reasoning with knowledge in quad form, since knowledge can be grouped and divided context wise and simultaneously be fed to separate reasoning engines, this approach improves both efficiency and scalability [9].",
      "startOffset" : 212,
      "endOffset" : 215
    }, {
      "referenceID" : 2,
      "context" : "Besides the above flexibility, bridge rules [5] can be provided for inter-operating the knowledge in different contexts.",
      "startOffset" : 44,
      "endOffset" : 47
    }, {
      "referenceID" : 2,
      "context" : "In this work, we study contextual reasoning and query answering over contextualized RDF/OWL knowledge bases in the presence of forall-existential bridge rules that allow conjunctions and existential quantifiers in them, and hence are more expressive than those in DDL [5] and McCarthy et al.",
      "startOffset" : 268,
      "endOffset" : 271
    }, {
      "referenceID" : 3,
      "context" : "[6].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 14,
      "context" : "For query answering, we use the notion of a distributed chase, which is an extension of the standard chase [20, 21] that is widely used in the knowledge representation (KR) and Database (DB) settings for similar purposes.",
      "startOffset" : 107,
      "endOffset" : 115
    }, {
      "referenceID" : 2,
      "context" : "As far as the semantics for reasoning is concerned, we adopt the approach given in works such as Distributed Description Logics [5], E-connections [22], and two-dimensional logic of contexts [23], to use a set of interpretation structures as a model for contextualized knowledge.",
      "startOffset" : 128,
      "endOffset" : 131
    }, {
      "referenceID" : 15,
      "context" : "As far as the semantics for reasoning is concerned, we adopt the approach given in works such as Distributed Description Logics [5], E-connections [22], and two-dimensional logic of contexts [23], to use a set of interpretation structures as a model for contextualized knowledge.",
      "startOffset" : 147,
      "endOffset" : 151
    }, {
      "referenceID" : 19,
      "context" : "Some of the alternatives for the local semantics satisfying the above mentioned criterion are Simple, RDF, RDFS [31], OWL-Horst [27] etc.",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 14,
      "context" : "In order to build a procedure for query answering over a quad-system, we employ what has been called in the literature a chase [20, 21].",
      "startOffset" : 127,
      "endOffset" : 135
    }, {
      "referenceID" : 16,
      "context" : "[24] (also called non-oblivious chase).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[15]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 22,
      "context" : "A model I of a quad-system QSC is called universal [30], iff the following holds: I is a model of QSC , and for any model I ′C of QSC there exists a homomorphism from I to I ′C .",
      "startOffset" : 51,
      "endOffset" : 55
    }, {
      "referenceID" : 17,
      "context" : "An anolog of the above theorem for DLs and Databases is stated and proved in [25].",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 17,
      "context" : "Since the proof in [25] can easily be adapted to our case, we refer the reader to [25] for the proof.",
      "startOffset" : 19,
      "endOffset" : 23
    }, {
      "referenceID" : 17,
      "context" : "Since the proof in [25] can easily be adapted to our case, we refer the reader to [25] for the proof.",
      "startOffset" : 82,
      "endOffset" : 86
    }, {
      "referenceID" : 20,
      "context" : "[28] provides an algorithm for CQ entailment based on query rewriting.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[15], Krötzsch et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 30,
      "context" : "[39], or Beeri et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 9,
      "context" : "[14] can trivially be applied in our setting to obtain the undecidability result for unrestricted quad-systems.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 24,
      "context" : "Deciding whether the language generated by the grammars L(G1) and L(G2) have non-empty intersection is known to be undecidable [33].",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 16,
      "context" : "Techniques such as Weak acyclicity [24], Joint acyclicity [38], and Acyclic graph of rule dependencies [15] belong to type (ii), as these notions ignore the instance part.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 29,
      "context" : "Techniques such as Weak acyclicity [24], Joint acyclicity [38], and Acyclic graph of rule dependencies [15] belong to type (ii), as these notions ignore the instance part.",
      "startOffset" : 58,
      "endOffset" : 62
    }, {
      "referenceID" : 10,
      "context" : "Techniques such as Weak acyclicity [24], Joint acyclicity [38], and Acyclic graph of rule dependencies [15] belong to type (ii), as these notions ignore the instance part.",
      "startOffset" : 103,
      "endOffset" : 107
    }, {
      "referenceID" : 23,
      "context" : "Whereas techniques such as model faithful acyclicity [32] and model summarizing acyclicity [32] are of type (i) as both the rules and instance part is considered.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 23,
      "context" : "Whereas techniques such as model faithful acyclicity [32] and model summarizing acyclicity [32] are of type (i) as both the rules and instance part is considered.",
      "startOffset" : 91,
      "endOffset" : 95
    }, {
      "referenceID" : 26,
      "context" : "We notify the reader that the technique we follow is, similar to works such as [35, 36], to iteratively generate a doubly exponential number of objects that represent the configurations and cells of the tape of the DTM, and then simulate its working by appropriate BRs.",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 27,
      "context" : "We notify the reader that the technique we follow is, similar to works such as [35, 36], to iteratively generate a doubly exponential number of objects that represent the configurations and cells of the tape of the DTM, and then simulate its working by appropriate BRs.",
      "startOffset" : 79,
      "endOffset" : 87
    }, {
      "referenceID" : 10,
      "context" : "Borrowing the parlance from the ∀∃ rules setting, where rules whose variables in the head part are contained in the variables in the body part are called range restricted rules [15], we call such BRs range restricted (RR) BRs.",
      "startOffset" : 177,
      "endOffset" : 181
    }, {
      "referenceID" : 22,
      "context" : "[30], it follows that for any quad-systemQSC = 〈QC , R〉 and a boolean CCQ CQ, QSC |= CQ iff τ(QSC) |=fol τccq(CQ).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[15], where it is shown that the ∀∃ rule EP is polynomially reducible to fact (a set of instances) EP, and fact EP are equivalent to CQ EP.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 25,
      "context" : "Also, Cali et al [34] show that CQ containment problem, which is equivalent to ∀∃ rule EP, is reducible to CQ EP.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 29,
      "context" : "If P ∈ WA, then P ∈ JA (from [38]), 2.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 23,
      "context" : "If P ∈ JA, then P ∈ MFA (from [32]), 3.",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 29,
      "context" : "WA ⊂ JA ⊂ MFA (from [38] and [32]).",
      "startOffset" : 20,
      "endOffset" : 24
    }, {
      "referenceID" : 23,
      "context" : "WA ⊂ JA ⊂ MFA (from [38] and [32]).",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 16,
      "context" : "Weak acyclicity [24, 26] is a popular technique used to detect whether a ∀∃ rule set has a finite chase, thus ensuring decidability of query answering.",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 18,
      "context" : "Weak acyclicity [24, 26] is a popular technique used to detect whether a ∀∃ rule set has a finite chase, thus ensuring decidability of query answering.",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 29,
      "context" : "Joint acyclicity [38] extends weak acyclicity, by also taking into consideration the join between variables in body of ∀∃ rules while analyzing the rules for acyclicity.",
      "startOffset" : 17,
      "endOffset" : 21
    }, {
      "referenceID" : 23,
      "context" : "[32], is an acyclicity technique that guarantees finiteness of chase and decidability of query answering, in the realm of ∀∃ rules.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 23,
      "context" : "[32] that if P is MFA, then P has a finite chase, thus ensuring decidability of query answering.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "[17] and Local Model Semantics by Giunchiglia et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 5,
      "context" : "[8].",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 2,
      "context" : "Some of the initial works on contexts relevant to semantic web were the ones like Distributed Description Logics [5] by Borgida et al.",
      "startOffset" : 113,
      "endOffset" : 116
    }, {
      "referenceID" : 4,
      "context" : ", and Context-OWL [7] by Bouquet et al.",
      "startOffset" : 18,
      "endOffset" : 21
    }, {
      "referenceID" : 8,
      "context" : ", and the work of CKR [13, 10] by Serafini et al.",
      "startOffset" : 22,
      "endOffset" : 30
    }, {
      "referenceID" : 7,
      "context" : ", and the work of CKR [13, 10] by Serafini et al.",
      "startOffset" : 22,
      "endOffset" : 30
    }, {
      "referenceID" : 32,
      "context" : "[42] and Straccia et al.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "[29] giving rise to the SWRL [29] language.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 21,
      "context" : "[29] giving rise to the SWRL [29] language.",
      "startOffset" : 29,
      "endOffset" : 33
    }, {
      "referenceID" : 31,
      "context" : "Since SWRL is undecidable in general, studies on computable sub-fragments gave rise to works like Description Logic Rules [40], where the authors deal with rules that can be totally internalized by a DL knowledge base, and hence if the DL considered is decidable, then also is a DL+rules KB.",
      "startOffset" : 122,
      "endOffset" : 126
    }, {
      "referenceID" : 9,
      "context" : "∀∃ rules, TGDs, Datalog+- rules Query answering over rules with universal-existential quantifiers in the context of databases, where these rules are called Datalog+- rules/tuple generating dependencies (TGDs), was done by Beeri and Vardi [14] even in the early 80s, where the authors show that the query entailment problem, in general, is undecidable.",
      "startOffset" : 238,
      "endOffset" : 242
    }, {
      "referenceID" : 10,
      "context" : "These classes (according to [15]) can broadly be divided into the following three categories: (i) bounded treewidth sets (BTS), (ii) finite unification sets (FUS), and (iii) finite extension sets (FES).",
      "startOffset" : 28,
      "endOffset" : 32
    }, {
      "referenceID" : 14,
      "context" : "Some of the important classes of these sets are the linear ∀∃ rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38].",
      "startOffset" : 68,
      "endOffset" : 72
    }, {
      "referenceID" : 25,
      "context" : "Some of the important classes of these sets are the linear ∀∃ rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38].",
      "startOffset" : 97,
      "endOffset" : 101
    }, {
      "referenceID" : 10,
      "context" : "Some of the important classes of these sets are the linear ∀∃ rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 29,
      "context" : "Some of the important classes of these sets are the linear ∀∃ rules [20], (weakly) guarded rules [34], (weakly) frontier guarded rules [15], and jointly frontier guarded rules [38].",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 11,
      "context" : "[16].",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "FUS classes include the class of ‘sticky’ rules [36, 35], atomic hypothesis rules in which the body of each rule contains only a single atom, and also the class of linear ∀∃ rules.",
      "startOffset" : 48,
      "endOffset" : 56
    }, {
      "referenceID" : 26,
      "context" : "FUS classes include the class of ‘sticky’ rules [36, 35], atomic hypothesis rules in which the body of each rule contains only a single atom, and also the class of linear ∀∃ rules.",
      "startOffset" : 48,
      "endOffset" : 56
    }, {
      "referenceID" : 16,
      "context" : "Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37].",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 18,
      "context" : "Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37].",
      "startOffset" : 16,
      "endOffset" : 24
    }, {
      "referenceID" : 29,
      "context" : "Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37].",
      "startOffset" : 98,
      "endOffset" : 102
    }, {
      "referenceID" : 28,
      "context" : "Weak acyclicity [24, 26], was one of the first such notions, and was extended to joint acyclicity [38] and super weak acyclicity [37].",
      "startOffset" : 129,
      "endOffset" : 133
    }, {
      "referenceID" : 23,
      "context" : "[32], where existence of cyclic Skolem blank-node/constant generations in the chase is detected by augmenting the rules with extra information that keeps track of the Skolem function used to generate each Skolem blank-node.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 16,
      "context" : "Data integration Studies in query answering on integrated heterogeneous databases with expressive integration rules in the realm of data integration is primarily studied in the following two settings: (i) Data exchange [24], in which there is a source database and target database that are connected with existential rules, and (ii) Peer-to-peer data management systems (PDMS) [19], where there are an arbitrary number of peers that are interconnected using existential rules.",
      "startOffset" : 219,
      "endOffset" : 223
    }, {
      "referenceID" : 13,
      "context" : "Data integration Studies in query answering on integrated heterogeneous databases with expressive integration rules in the realm of data integration is primarily studied in the following two settings: (i) Data exchange [24], in which there is a source database and target database that are connected with existential rules, and (ii) Peer-to-peer data management systems (PDMS) [19], where there are an arbitrary number of peers that are interconnected using existential rules.",
      "startOffset" : 377,
      "endOffset" : 381
    }, {
      "referenceID" : 13,
      "context" : "in the context of peer-peer data management systems [19], and decidability is attained by not allowing any kind of cycles in the peer topology.",
      "startOffset" : 52,
      "endOffset" : 56
    }, {
      "referenceID" : 16,
      "context" : "Whereas in the context of Data exchange, WA is used in [24, 26] to assure decidability, and the recent work by Marnette [37] employs the super weak acyclicity (SWA) to ensure decidability.",
      "startOffset" : 55,
      "endOffset" : 63
    }, {
      "referenceID" : 18,
      "context" : "Whereas in the context of Data exchange, WA is used in [24, 26] to assure decidability, and the recent work by Marnette [37] employs the super weak acyclicity (SWA) to ensure decidability.",
      "startOffset" : 55,
      "endOffset" : 63
    }, {
      "referenceID" : 28,
      "context" : "Whereas in the context of Data exchange, WA is used in [24, 26] to assure decidability, and the recent work by Marnette [37] employs the super weak acyclicity (SWA) to ensure decidability.",
      "startOffset" : 120,
      "endOffset" : 124
    }, {
      "referenceID" : 23,
      "context" : "It was shown in Cuenca Grau et al [32] that their MFA technique strictly subsumes both WA and SWA techniques in expressivity.",
      "startOffset" : 34,
      "endOffset" : 38
    } ],
    "year" : 2015,
    "abstractText" : "The proliferation of contextualized knowledge in the Semantic Web (SW) has led to the popularity of knowledge formats such as quads in the SW community. A quad is an extension of an RDF triple with contextual information of the triple. In this paper, we study the problem of query answering over quads augmented with forall-existential bridge rules that enable interoperability of reasoning between triples in various contexts. We call a set of quads together with such expressive bridge rules, a quad-system. Query answering over quadsystems is undecidable, in general. We derive decidable classes of quad-systems, for which query answering can be done using forward chaining. Sound, complete and terminating procedures, which are adaptations of the well known chase algorithm, are provided for these classes for deciding query entailment. Safe, msafe, and csafe class of quad-systems restrict the structure of blank nodes generated during the chase computation process to be directed acyclic graphs (DAGs) of bounded depth. RR and restricted RR classes do not allow the generation of blank nodes during the chase computation process. Both data and combined complexity of query entailment has been established for the classes derived. We further show that quad-systems are equivalent to forall-existential rules whose predicates are restricted to ternary arity, modulo polynomial time translations. We subsequently show that the technique of safety, strictly subsumes in expressivity, some of the well known and expressive techniques, such as joint acyclicity and model faithful acyclicity, used for decidability guarantees in the realm of forall-existential rules.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}