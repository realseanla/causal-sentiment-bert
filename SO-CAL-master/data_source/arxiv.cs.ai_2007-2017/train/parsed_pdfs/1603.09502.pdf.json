{
  "name" : "1603.09502.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Verifiability of Argumentation Semantics∗",
    "authors" : [ "Ringo Baumann", "Thomas Linsbichler", "Stefan Woltran" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "Introduction",
      "text" : "In the late 1980s the idea of using argumentation to model nonmonotonic reasoning emerged (see (Loui 1987; Pollock 1987) as well as (Prakken and Vreeswijk 2002) for excellent overviews). Nowadays argumentation theory is a vibrant subfield of Artificial Intelligence, covering aspects of knowledge representation, multi-agent systems, and also philosophical questions. Among other approaches which have been proposed for capturing representative patterns of inference in argumentation theory (Besnard et al. 2014), Dung’s abstract argumentation frameworks (AFs) (Dung 1995) play an important role within this research area. At the heart of Dung’s approach lie the so-called argumentation semantics (cf. (Baroni, Caminada, and Giacomin 2011) for an excellent overview). Given an AF F , which is set-theoretically just a directed graph encoding arguments and attacks between them, a certain argumentation semantics σ returns acceptable sets of arguments σ(F ), so-called σ-extensions. Each of these sets represents a reasonable position w.r.t. F and σ.\nOver the last 20 years a series of abstract argumentation semantics were introduced. The motivations of these semantics range from the desired treatment of specific examples to ∗This research has been supported by DFG (project BR 1817/7- 1) and FWF (projects I1102 and P25521).\nfulfilling a number of abstract principles. The comparison via abstract criteria of the different semantics available is a topic which emerged quite recently in the community ((Baroni and Giacomin 2007b) can be seen as the first paper in this line). Our work takes a further step towards a comprehensive understanding of argumentation semantics. In particular, we study the following question: Do we really need the entire AF F to compute a certain argumentation semantics σ? In other words, is it possible to unambiguously determine acceptable sets w.r.t. σ, given only partial information of the underlying framework F . In order to solve this problem let us start with the following reflections:\n1. As a matter of fact, one basic requirement of almost all existing semantics1 is that of conflict-freeness, i.e. arguments within a reasonable position are not allowed to attack each other. Consequently, knowledge about conflict-free sets is an essential part for computing semantics.\n2. The second step is to ask the following: Which information on top on conflict-free sets has to be added? Imagine the set of conflict-free sets given by {∅, {a}, {b}}. Consequently, there has to be at least one attack between a and b. Unfortunately, this information is not sufficient to compute any standard semantics (except naive extensions, which are defined as ⊆-maximal conflict-free sets) since we know nothing precise about the neighborhood of a and b. The following three AFs possess exactly the mentioned conflict-free sets, but differ with respect to other\naF : b aG : b aH : b\n3. The final step is to try to minimize the added information. That is, which kind of knowledge about the neighborhood is somehow dispensable in the light of computation? Clearly, this will depend on the considered semantics. For instance, in case of stage semantics (Verheij 1996), which requests conflict-free sets of maximal range, we do not need any information about incoming attacks. This information can not be omitted in case of admissible-based semantics since incoming attacks require counterattacks.\nThe above considerations motivate the introduction of socalled verification classes specifying a certain amount of\n1See (Jakobovits and Vermeir 1999; Arieli 2012; Grossi and Modgil 2015) for exemptions.\nar X\niv :1\n60 3.\n09 50\n2v 1\n[ cs\n.A I]\n3 1\nM ar\n2 01\n6\ninformation. In a first step, we study the relation of these classes to each other. We therefore introduce the notion of being more informative capturing the intuition that a certain class can reproduce the information of an other. We present a hierarchy w.r.t. this ordering. The hierarchy contains 15 different verification classes only. This is due to the fact that many syntactically different classes collapse to the same amount of information.\nWe then formally define the essential property of a semantics σ being verifiable w.r.t. a certain verification class. We present a general theorem stating that any rational semantics is exactly verifiable w.r.t. one of the 15 different verification classes. Roughly speaking, a semantics is rational if attacks inbetween two self-loops can be omitted without affecting the set of extensions. An important aside hereby is that even the most informative class contains indeed less information than the entire framework by itself.\nIn this paper we consider a representative set of standard semantics. All of them satisfy rationality and thus, are exactly verifiable w.r.t. a certain class. Since the theorem does not provide an answer to which verification class perfectly matches a certain rational semantics we study this problem one by one for any considered semantics. As a result, only 6 different classes are essential to classify the considered standard semantics.\nIn the last part of the paper we study an application of the concept of verifiability. More precisely, we address the question of strong equivalence for semantics lying inbetween known semantics, so-called intermediate semantics. Strong equivalence is the natural counterpart to ordinary equivalence in monotonic theories (see (Oikarinen and Woltran 2011; Baumann 2016) for abstract argumentation and (Maher 1986; Lifschitz, Pearce, and Valverde 2001; Turner 2004; Truszczynski 2006) for other nonmonotonic theories). We provide characterization theorems relying on the notion of verifiability and thus, contributing to a more abstract understanding of the different features argumentation semantics offer. Besides these main results, we also give new characterizations for strong equivalence with respect to naive extensions and strong admissible sets."
    }, {
      "heading" : "Preliminaries",
      "text" : "An argumentation framework (AF) F = (A,R) is a directed graph whose nodes A ⊆ U (with U being an infinite set of arguments, so-called universe) are interpreted as arguments and whose edges R ⊆ A × A represent conflicts between them. We assume that all AFs possess finitely2 many arguments only and denote the collection of all AFs by A . If (a, b) ∈ R we say that a attacks b. Alternatively, we write a b as well as, for some S ⊆ A, a S or S b if there is some c ∈ S attacked by a or attacking b, respectively. An argument a ∈ A is defended by a set S ⊆ A if for each b ∈ A with b a, S b. We define the range of S (in F ) as S+F = S ∪ {a | S a}. Similarly, we use S − F to denote the anti-range of S (in F ) as S ∪ {a | a S}. Furthermore, 2Finiteness of AFs is a common assumption in argumentation papers. A systematic study of the infinite case has begun quite recently (cf. (Baumann and Spanring 2015) for an overview).\nwe say that a set S is conflict-free (in F ) if there is no argument a ∈ S s.t. S a. The set of all conflict-free sets of an AF F is denoted by cf(F ). For an AF F = (B,S) we use A(F ) and R(F ) to refer to B and S, respectively. Furthermore, we use L(F ) = {a | (a, a) ∈ R(F )} for the set of all self-defeating arguments. Finally, we introduce the union of AFs F and G as F ∪G = (A(F ) ∪A(G), R(F ) ∪R(G))."
    }, {
      "heading" : "Semantics",
      "text" : "A semantics σ assigns to each F = (A,R) a set σ(F ) ⊆ 2A where the elements are called σ-extensions. Numerous semantics are available. Each of them captures different intuitions about how to reason about conflicting knowledge. We consider σ ∈ {ad, na, stb, pr, co, gr, ss, stg, id, eg} for admissible, naive, stable, preferred, complete, grounded, semi-stable, stage, ideal, and eager semantics (Dung 1995; Caminada, Carnielli, and Dunne 2012; Verheij 1996; Dung, Mancarella, and Toni 2007; Caminada 2007).\nDefinition 1. Given an AF F = (A,R) and let S ⊆ A. 1. S ∈ ad(F ) iff S ∈ cf(F ) and each a ∈ S is defended\nby S, 2. S ∈ na(F ) iff S ∈ cf(F ) and there is no S′ ∈ cf(F ) s.t. S ( S′,\n3. S ∈ stb(F ) iff S ∈ cf(F ) and S+F = A, 4. S ∈ pr(F ) iff S ∈ ad(F ) and there is no S′ ∈ ad(F ) s.t. S ( S′,\n5. S ∈ co(F ) iff S ∈ ad(F ) and for any a ∈ A defended by S, a ∈ S, 6. S ∈ gr(F ) iff S ∈ co(F ) and there is no S′ ∈ co(F ) s.t. S′ ( S, 7. S ∈ ss(F ) iff S ∈ ad(F ) and there is no S′ ∈ ad(F ) s.t. S+F ( S ′+ F , 8. S ∈ stg(F ) iff S ∈ cf(F ) and there is no S′ ∈ cf(F ) s.t. S+F ( S ′+ F ,\n9. S ∈ id(F ) iff S ∈ ad(F ), S ⊆ ⋂ pr(F ) and there is no\nS′ ∈ ad(F ) satisfying S′ ⊆ ⋂ pr(F ) s.t. S ( S′,\n10. S ∈ eg(F ) iff S ∈ ad(F ), S ⊆ ⋂\nss(F ) and there is no S′ ∈ ad(F ) satisfying S′ ⊆ ⋂ ss(F ) s.t. S ( S′.\nFor two semantics σ, τ we use σ ⊆ τ to indicate that σ(F ) ⊆ τ(F ) for each AF F ∈ A . If we have ρ ⊆ σ and σ ⊆ τ for semantics ρ, σ, τ , we say that σ is ρ-τ -intermediate. Well-known relations between semantics are stb ⊆ ss ⊆ pr ⊆ co ⊆ ad, meaning, for instance, that ss is stb-pr - intermediate.\nDefinition 2. We call a semantics σ rational if self-loopchains are irrelevant. That is, for every AF F it holds that σ(F ) = σ(F l), where F l = (A(F ), R(F ) \\ {(a, b) ∈ R(F ) | (a, a), (b, b) ∈ R(F ), a 6= b}).\nIndeed, all semantics introduced in Definition 1 are rational. A prominent semantics that is based on conflict-free sets, but is not rational is the cf2-semantics (Baroni, Giacomin, and Guida 2005), since here chains of self-loops can have an influence on the SCCs of an AF (see also (Gaggl and Woltran 2013))."
    }, {
      "heading" : "Equivalence and Kernels",
      "text" : "The following definition captures the two main notions of equivalence available for non-monotonic formalisms, namely ordinary (or standard) equivalence and strong (or expansion) equivalence. A detailed overview of equivalence notion including their relations to each other can be found in (Baumann and Brewka 2013; Baumann and Brewka 2015).\nDefinition 3. Given a semantics σ. Two AFs F and G are\n• standard equivalent w.r.t. σ (F ≡σ G) iff σ(F ) = σ(G), • expansion equivalent w.r.t. σ (F ≡σE G) iff for all AFs H : F ∪H ≡σ G ∪H Expansion equivalence can be decided syntactically via so-called kernels (Oikarinen and Woltran 2011). A kernel is a function k : A 7→ A mapping each AF F to another AF k(F ) (which we may also denote as F k ). Consider the following definitions.\nDefinition 4. Given an AF F = (A,R) and a semantics σ. We define σ-kernels F k(σ) = ( A,Rk(σ) ) whereby\nRk(stb) = R \\ {(a, b) | a 6= b, (a, a) ∈ R}, Rk(ad) = R \\ {(a, b) | a 6= b, (a, a) ∈ R, {(b, a), (b, b)} ∩R 6= ∅}, Rk(gr) = R \\ {(a, b) | a 6= b, (b, b) ∈ R, {(a, a), (b, a)} ∩R 6= ∅}, Rk(co) = R \\ {(a, b) | a 6= b, (a, a), (b, b) ∈ R}.\nWe say that a relation ≡ ⊆ A × A is characterizable through kernels if there is a kernel k , s.t. F ≡ G iff F k = Gk. Moreover, we say that a semantics σ is compatible with a kernel k if F ≡σE G iff F k = Gk. All semantics (except naive semantics) considered in this paper are compatible with one of the four kernels introduced above. In the next section, we will complete these results taking naive semantics and strong admissible sets into account.\nTheorem 1. (Oikarinen and Woltran 2011; Baumann and Woltran 2014) For any AFs F and G ,\n1. F ≡σE G ⇔ F k(σ) = Gk(σ) with σ ∈ {stb, ad, co, gr}, 2. F ≡τE G ⇔ F k(ad) = Gk(ad) with τ ∈ {pr , id , ss, eg}, 3. F ≡stgE G ⇔ F k(stb) = Gk(stb)."
    }, {
      "heading" : "Complementing Previous Results",
      "text" : "In order to provide an exhaustive analysis of intermediate semantics (confer penultimate section) we provide missing kernels for naive semantics as well as strongly admissible sets. We start with the so-called naive kernel characterizing expansion equivalence w.r.t. naive semantics. As an aside, the following kernel is the first one which adds attacks to the former attack relation.\nDefinition 5. Given an AF F = (A,R). We define the naive kernel F k(na) = ( A,Rk(na) ) whereby Rk(na) = R ∪ {(a, b) | a 6= b, {(a, a), (b, a), (b, b)} ∩R 6= ∅} . The following example illustrates the definition above.\nExample 1. Consider the AFs F and G . Note that na(F ) = na (G) = {{a, c}, {a, d}}. Consequently, F ≡na G .\naF : b c d\naG : b c d\nIn accordance with Definition 5 we observe that both AFs possess the same naive kernel H = F k(na) = Gk(na).\naH : b c d\nThe following theorem proves that possessing the same kernels is necessary as well as sufficient for being strongly equivalent, i.e. F ≡naE G . Theorem 2. For all AFs F ,G ,\nF ≡naE G ⇔ F k(na) = Gk(na). Proof. In (Baumann and Woltran 2014) it was already shown that F ≡naE G iff jointly A(F ) = A(G) and na(F ) = na(G). Consequently, it suffices to prove that F k(na) = Gk(na) implies A(F ) = A(G) as well as na(F ) = na(G) and vice versa.\n(⇐) Given F k(na) = Gk(na). By Definition 5 we immediately haveA(F ) = A(G). Assume now that na(F ) 6= na(G) and without loss of generality let S ∈ na(F ) \\ na(G). Obviously, for any AF H , cf(H ) = cf ( H k(na) ) . Hence, there is an S′, s.t. S ( S′ ∈ cf(G) \\ cf(F ). Thus, there are a, b ∈ S′ \\ S, s.t. (a, b) ∈ R(F ) \\ R(G). Furthermore, (a, a), (b, b) /∈ R(G) and since for any AF H , L(H ) = L ( H k(na) ) we obtain (a, a), (b, b) /∈ R(F ). Consequently, we have to consider a 6= b. Since (a, b) ∈ R(F ) \\ R(G), we obtain (a, b), (b, a) ∈ R ( F k(na) ) . Since F k(na) = Gk(na)\nis assumed we derive (a, b), (b, a) ∈ R ( Gk(na) ) . By Definition 5 we must have (b, a) ∈ R(G) contradicting the conflict-freeness of S′ in G .\n(⇒) We show the contrapositive, i.e. F k(na) 6= Gk(na) implies A(F ) 6= A(G) or na(F ) 6= na(G). Observe that for any AF H , A(H ) = A ( H k(na) ) . Consequently, if\nA ( F k(na) ) 6= A ( Gk(na) ) , then A(F ) 6= A(G). Assume\nnow R ( F k(na) ) 6= R ( Gk(na) ) . Without loss of general-\nity let (a, b) ∈ R ( F k(na) ) \\ R ( Gk(na) ) . Since for any AF\nH , L(H ) = L ( H k(na) ) we obtain a 6= b. Furthermore,\n(a, b) ∈ R ( F k(na) ) implies {(a, a), (a, b), (b, a), (b, b)} ∩ R (F ) 6= ∅ and consequently, for any S ∈ na(F ), {a, b} 6⊆ S. Since (a, b) /∈ R ( Gk(na) ) we deduce {(a, a), (a, b), (b, a), (b, b)} ∩ R (F ) = ∅. Hence, {a, b} ∈ cf(G) and thus, there exists a set S ∈ na(G), s.t. {a, b} ⊆ S (compare (Baumann and Spanring 2015, Lemma 3)) witnessing na(F ) 6= na(G).\nWe turn now to strongly admissible sets (for short, sad) (Baroni and Giacomin 2007b). We will show that, beside grounded (Oikarinen and Woltran 2011) and resolution based grounded semantics (Baroni, Dunne, and Giacomin 2011; Dvořák et al. 2014), strongly admissible sets are characterizable through the grounded kernel. Consider the following self-referential definition taken from (Caminada 2014).\nDefinition 6. Given an AF F = (A,R). A set S ⊆ A is strongly admissible, i.e. S ∈ sad(F ) iff any a ∈ S is defended by a strongly admissible set S′ ⊆ S \\ {a}.\nThe following properties are needed to prove the characterization theorem. The first two of them are already shown in (Baroni and Giacomin 2007a). The third statement is an immediate consequence of the former.\nProposition 1. Given two AFs F and G , then 1. gr(F ) ⊆ sad(F ) ⊆ ad(F ), 2. if S ∈ gr(F ) we have: S′ ⊆ S for all S′ ∈ sad(F ), and 3. sad(F ) = sad(G) implies gr(F ) = gr(G).\nThe following definition provides us with an alternative criterion for being a strong admissible set. In contrast to the former it allows one to construct strong admissible sets step by step. Thus, a construction method is given.\nDefinition 7. Given an AF F = (A,R). A set S ⊆ A is strongly admissible, i.e. S ∈ sad(F ) iff there are finitely many and pairwise disjoint sets A1, ..., An, s.t. S = ⋃ 1≤i≤nAi and A1 ⊆ ΓF (∅)3 and furthermore,⋃\n1≤i≤j Ai defends Aj+1 for 1 ≤ j ≤ n− 1. Proposition 2. Definitions 6 and 7 are equivalent.\nProof. For the proof we use S ∈ sadk(F ) as a shorthand for S ∈ sad(F ) in the sense of Definition k. (⇐) Given S ∈ sad7(F ). Hence, there is a finite partition, s.t. S = ⋃ 1≤i≤nAi, A1 ⊆ ΓF (∅) and⋃\n1≤i≤j Ai defends Aj+1 for 1 ≤ j ≤ n − 1. Observe that⋃ 1≤i≤j Ai ∈ sad7(F ) for any j ≤ n. Let a ∈ S. Consequently, there is an index i∗, s.t. a ∈ Ai∗ . Furthermore, since ⋃ 1≤i≤i∗−1Ai defends Ai∗ by definition, we deduce\nthat ⋃\n1≤i≤i∗−1Ai ⊆ S \\ {a} defends a. We have to show now that (the smaller set w.r.t. ⊆) ⋃ 1≤i≤i∗−1Ai ∈ sad6(F ).\nNote that ⋃\n1≤i≤i∗−1Ai ∈ sad7(F ). Since we are dealing with finite AFs we may iterate our construction. Hence, no matter which elements are chosen we end up with a ⊆-chain, s.t. ∅ ⊆ ⋃ 1≤i≤ie Ai ⊆ Se \\ ae and ∅ defends ae for some index ie, set Se and element ae. This means, the question whether S ∈ sad6(F ) can be decided positively by proving ∅ ∈ sad6(F ). Since the empty set does not contain any elements we find ∅ ∈ sad6(F ) concluding sad7 ⊆ sad6. (⇒) Given S ∈ sad6(F ), consider the following sets Si: S1 = (Γ(∅) \\ ∅) ∩ S, S2 = (Γ(S1) \\ S1) ∩ S, S3 = ( Γ( ⋃2 i=1 Si) \\ ⋃2 i=1 Si ) ∩ S, . . . , Sn =(\nΓ( ⋃n−1 i=1 Si) \\ ⋃n−1 i=1 Si ) ∩ S. Since we are dealing with finite AFs there has to be a natural n ∈ N, s.t. Sn = Sn+1 = Sn+2 = . . . . Consider now the union of these sets, i.e. ⋃n i=1 Si. We show now that ⋃n i=1 Si ∈\nsad7(F ) and ⋃n i=1 Si = S. By construction we have\nS1 ⊆ Γ(∅). Moreover, ⋃\n1≤i≤j Si defends Sj+1 for 1 ≤ j ≤ n − 1. This can be seen as follows. By definition\n3Hereby, Γ is the so-called characteristic function (Dung 1995) with ΓF (S) = {a ∈ A | a is defended by S in F}. The term ΓF (∅) can be equivalently replaced by {a ∈ A | a is unattacked}.\nSj+1 = ( Γ( ⋃j i=1 Si) \\ ⋃j i=1 Si ) ∩ S. This means, Sj+1 ⊆\nΓ( ⋃j i=1 Si). Since Γ( ⋃j i=1 Si) contains all elements de-\nfended by ⋃j i=1 Si we obtain ⋃n i=1 Si ∈ sad7(F ). Obvi-\nously, ⋃j i=1 Si ⊆ S. In order to derive a contradiction we sup-\npose S 6⊆ ⋃n i=1 Si. This means there is a nonempty set S\n∗, s.t. S = S∗ ∪ ⋃n i=1 Si. Let S\n∗ = {s1, . . . , sk}. Observe that no element si is defended by ⋃n i=1 Si (*). Since S ∈ sad6(F ) we obtain a set S∗1 ⊆ S \\ {s1}, s.t. S∗1 ∈ sad6(F ) and S∗1 defends s1. We now iterate this procedure ending up with a set S∗k ⊆ S∗k−1 \\ {sk} ⊆ ⋃n i=1 Si, s.t. S ∗ k ∈ sad6(F ) and S∗k defends sk contradicting (*) and concluding the proof.\nThe following example shows how to use the new construction method. Example 2. Consider the following AF F .\naF : b\nc\nd\ne f\nWe have ΓF (∅) = {a, d}. Hence, for all S ⊆ {a, d}, S ∈ sad(F ). Furthermore, ΓF ({a}) = {a, c}, ΓF ({d}) = {d, f} and ΓF ({a, d}) = {a, d, c, f}. This means, additionally {a, c}, {d, f}, {a, d, c}, {a, d, f}, {a, d, c, f} ∈ sad(F ). Finally, ΓF ({a, c}) = {a, c, f} justifying the last missing set {a, c, f} ∈ sad(F ).\nThe following corollary is an immediate consequence of Definition 7. It is essential to prove the characterization theorem for strongly admissible sets. Corollary 1. Given an AF F and two sets B,B′ ⊆ A(F ). If B defends B′, then B ∪B′ is strong admissible if B is.\nThe following lemma shows that the grounded kernel is insensitive w.r.t. strong admissible sets.\nLemma 1. For any AF F , sad (F ) = sad ( F k(gr) ) .\nProof. The grounded kernel is node- and loop-preserving, i.e. A(F ) = A ( F k(gr) ) and L(F ) = L ( F k(gr) ) . Furthermore,\ncf(F ) = cf ( F k(gr) ) and ΓF (∅) = ΓFk(gr)(∅) as shown in (Oikarinen and Woltran 2011, Lemma 6). (⊆) Given S ∈ sad (F ). The proof is by induction on n indicating the number of sets forming a suitable (according to Definition 7) partition of S. Let n = 1. In consideration of the grounded kernel we observe ΓF (∅) = ΓFk(gr)(∅), i.e. the set of unattacked arguments does not change. Since S ⊆ ΓF (∅) is assumed we are done. Assume now that the assertion is proven for any k-partition. Let S be a (k + 1)-partition, i.e. S = ⋃k+1 i=1 Ai. According to induction hypothesis as well\nas Corollary 1 it suffices to prove ⋃k i=1Ai defends Ak+1 in F k(gr). Assume not, i.e. there are arguments b ∈ A(F ) \\ S, c ∈ Ak+1 s.t. (b, c) ∈ R ( F k(gr)\n) ⊆ R(F ) and for all a ∈⋃k\ni=1Ai, (a, b) /∈ R ( F k(gr) ) (*). Since ⋃k i=1Ai defends\nAk+1 in F we deduce the existence of an argument a ∈⋃k i=1Ai s.t. (a, b) ∈ R (F ). Thus, (a, b) is redundant w.r.t. the grounded kernel. According to Definition 4 and due to\nthe conflict-freeness of ⋃k i=1Ai we have (a, a) /∈ R (F ) and (b, a), (b, b) ∈ R (F ). Consequently, (b, a) ∈ F k(gr). Since⋃k i=1Ai is a strong admissible k-partition in F we obtain\nby induction hypothesis that ⋃k i=1Ai is strong admissible in F k(gr) and therefore, admissible in F k(gr) (Proposition 1). Hence there has to be an argument a ∈ ⋃k i=1Ai, s.t. (a, b) ∈\nR ( F k(gr) ) , contradicting (*).\n(⊇) Assume S ∈ sad ( F k(gr) ) . We show S ∈ sad (F ) by\ninduction on n indicating that S is a n-partition in F k(gr). Due to ΓF (∅) = ΓFk(gr)(∅) the base case is immediately clear. For the induction step let S be a (k + 1)-partition, i.e. S = ⋃k+1 i=1 Ai. By induction hypothesis we may assume\nthat ⋃k i=1Ai is strongly admissible in F . Using Corollary 1\nit suffices to prove ⋃k i=1Ai defends Ak+1 in F . Assume not, i.e. there are arguments b ∈ A(F ) \\ S, c ∈ Ak+1 s.t. (b, c) ∈ R (F ) and for all a ∈ ⋃k i=1Ai, (a, b) /∈ R (F ). We\neven have (a, b) /∈ R ( F k(gr) ) since R ( F k(gr) ) ⊆ R (F ).\nConsequently, (b, c) has to be deleted in F k(gr). Definition 4 requires (c, c) ∈ R ( F k(gr) ) contradicting the conflict-\nfreeness of S in F k(gr).\nTheorem 3. For any two AFs F and G we have,\nF ≡sadE G ⇔ F k(gr) = Gk(gr)\nProof. (⇒) We show the contrapositive, i.e. F k(gr) 6= Gk(gr) ⇒ F 6≡sadE G . Assuming F k(gr) 6= Gk(gr) implies F 6≡grE G (Theorem 1). This means, there is an AF H , s.t. gr(F ∪ H) 6= gr(G ∪ H). Due to statement 3 of Proposition 1, we deduce sad(F ∪ H) 6= sad(G ∪ H) proving F 6≡sadE G . (⇐) Given F k(gr) = Gk(gr). Since expansion equivalence is a congruence w.r.t. ∪ we obtain (F ∪H )k(gr) = (G ∪H )k(gr)\nfor any AF H . Consequently, sad ( (F ∪H )k(gr) ) =\nsad ( (G ∪H )k(gr) )\n. Due to Lemma 1 we deduce sad(F ∪ H ) = sad(G ∪H ), concluding the proof."
    }, {
      "heading" : "Verifiability",
      "text" : "In this section we study the question whether we really need the entire AF F to compute the extensions of a given semantics. Let us consider naive semantics. Obviously, in order to determine naive extensions it suffices to know all conflictfree sets. Conversely, knowing cf(F ) only does not allow to reconstruct F unambiguously. This means, knowledge about cf(F ) is indeed less information than the entire AF by itself. In fact, most of the existing semantics do not need information of the entire framework. We will categorize the amount of information by taking the conflict-free sets as a basis and distinguish between different amounts of knowledge about the neighborhood, that is range and anti-range, of these sets.\nDefinition 8. We call a function rx : 2U × 2U → ( 2U )n (n > 0) which is expressible via basic set operations only neighborhood function. A neighborhood function rx induces\nthe verification class mapping each AF F to\nF̃x = {(S, rx(S+F , S − F )) | S ∈ cf(F )}.\nWe coined the term neighborhood function because the induced verification classes apply these functions to the neighborhoods, i.e. range and anti-range of conflict-free sets. The notion of expressible via basic set operations simply means that (in case of n = 1) the expression rx(A,B) is in the language generated by the following BNF:\nX ::= A | B | (X ∪X) | (X ∩X) | (X \\X). Consequently, in case of n = 1, we may distinguish eight set theoretically different neighborhood functions, namely\nr (S, S′) = ∅ r+(S, S′) = S\nr−(S, S′) = S′\nr∓(S, S′) = S′ \\ S r±(S, S′) = S \\ S′\nr∩(S, S′) = S ∩ S′\nr∪(S, S′) = S ∪ S′\nr∆(S, S′) = (S ∪ S′) \\ (S ∩ S′) A verification class encapsulates a certain amount of infor-\nmation about an AF, as the following example illustrates. Example 3. Consider the following AF F :\naF : b c\nNow take, for instance, the verification class induced by r+, that is F̃+ = {(S, r+(S+F , S − F )) | S ∈ cf(F )} = {(S, S+F ) | S ∈ cf(F )}, storing information about conflictfree sets together with their associated ranges w.r.t. F . It contains the following tuples: (∅, ∅), ({a}, {b}), ({c}, {b}), and ({a, c}, {b}). The verification class induced by r± contains the same tuples but ({a}, ∅) instead of ({a}, {b}).\nIntuitively, it should be clear that the set F̃+ suffices to compute stage extensions (i.e., range-maximal conflict-free sets) of F . This intuitive understanding of verifiability will be formally specified in Definition 10. Note that a neighborhood function rx may return n-tuples. Consequently, in consideration of the eight listed basic function we obtain (modulo reordering, duplicates, empty set) 27 + 1 syntactically different neighborhood functions and therefore the same number of verification classes. As usual, we will denote the n-ary combination of basic functions (rx1(S, S′), . . . , rxn(S, S′)) as rx(S, S′) with x = x1 . . . xn.\nWith the following definition we can put neighborhood functions into relation w.r.t. their information. This will help us to show that actually many of the induced classes collapse to the same amount of information. Definition 9. Given neighborhood functions rx and ry returning n-tuples and m-tuples, respectively, we say that rx is more informative than ry, for short rx ry, iff there is a function δ : ( 2U )n → (2U)m such that for any two sets of arguments S, S′ ⊆ U , we have δ (rx(S, S′)) = ry (S, S′).\nWe will denote the strict part of by , i.e. rx ry iff rx ry and ry 6 rx. Moreover rx ≈ ry in case rx ry and ry rx, we say that rx represents ry and vice versa. Lemma 2. All neighborhood functions are represented by the ones depicted in Figure 1 and the ≺-relation represented by arcs in Figure 1 holds.\nProof. We begin by showing that all neighborhood functions are represented in Figure 1. Clearly, each neighborhood function rx represents itself, i.e. rx ≈ rx. All neighborhood functions for n = 1 are are depicted in Figure 1. We turn to n = 2. Consider the neighborhood functions r+±, r+∩, and r±∩, defined as r+±(S, S′) = (S, S \\S′), r+∩(S, S′) = (S, S∩S′), and r±∩(S, S′) = (S \\ S′, S ∩ S′) for S, S′ ⊆ U . Observe that S = (S \\ S′) ∪ (S ∩ S′). Hence, we can easily define functions in the spirit of Definition 9 mapping the images of the function to one another:\n• δ1(r+±(S, S′)) = δ1(S, S \\S′) =def (S, S \\ (S \\S′)) = (S, S ∩ S′) = r+∩(S, S′); • δ2(r+∩(S, S′)) = δ2(S, S ∩ S′) =def (S \\ (S ∩ S′), S ∩ S′) = (S \\ S′, S ∩ S′) = r±∩(S, S′);\n• δ3(r±∩(S, S′)) = δ3(S \\ S′, S ∩ S′) =def ((S \\ S′) ∪ (S ∩ S′), S \\ S′) = (S, S \\ S′) = r+±(S, S′).\nTherefore, r+± ≈ r+∩ ≈ r±∩. In particular, they are all represented by r±. We can apply the same reasoning to other combinations of neighborhood functions and get the following equivalences w.r.t. information content: r+∓ ≈ r+∪ ≈ r∓∪; r±∓ ≈ r±∆ ≈ r∓∆; r∩∪ ≈ r∩∆ ≈ r∪∆; r−± ≈ r−∪ ≈ r±∪; and r−∓ ≈ r−∩ ≈ r∓∩, with the functions stated first acting as representatives in Figure 1.\nFor the remaining functions returning 2-tuples we get r+− ≈ r+∆ ≈ r−∆ by\n• δ4(r+−(S, S′)) = δ4(S, S′) =def (S, (S ∪ S′) \\ (S ∩ S′)) = r+∆(S, S′);\n• δ5(r+∆(S, S′)) = δ5(S, (S ∪ S′) \\ (S ∩ S′)) =def ((S \\ ((S ∪ S′) \\ (S ∩ S′))) ∪ ((S ∪ S′) \\ (S ∩ S′)) \\ S, (S ∪ S′) \\ (S ∩S′)) = (S′, (S ∪S′) \\ (S ∩S′)) = r−∩(S, S′);\n• δ6(r−∆(S, S′)) = δ6(S′, (S∪S′)\\ (S∩S′)) =def ((S′ \\ ((S ∪S′) \\ (S ∩S′)))∪ ((S ∪S′) \\ (S ∩S′)) \\S′, S′) = (S, S′) = r+−(S, S′).\nFinally, every neighborhood function rx1...xn with n ≥ 3 is represented by r+− since we can compute all possible sets from S and S′.\nNow consider two functions rx and ry such that there is an arrow from x to y in Figure 1. It is easy to see that ry rx since, for sets of arguments S and S′, rx(S, S′) is either contained in ry(S, S′) or obtainable from ry(S, S′) by basic set operations. The fact that rx 6 ry, entailing ry rx, follows from the impossibility of finding a function δ such that δ(rx(S, S′)) = ry(S, S′).\nIf the information provided by a neighborhood function is sufficient to compute the extensions, we say the semantics is verifiable by the class induced by the neighborhood function. Definition 10. A semantics σ is verifiable by the verification class induced by the neighborhood function rx returning ntuples (or simply, x-verifiable) iff there is a function (also called criterion) γσ : ( 2U )n × 2U → 22U s.t. for every AF F ∈ A we have: γσ ( F̃x, A(F ) ) = σ(F ).\nMoreover, σ is exactly x-verifiable iff σ is x-verifiable and there is no verification class induced by ry with ry ≺ rx such that σ is y-verifiable.\nObserve that if a semantics σ is x-verifiable then for any two AFs F and G with F̃x = G̃x andA(F ) = A(G) it must hold that σ(F ) = σ(G).\nWe proceed with a list of criteria showing that any semantics mentioned in Definition 1 is verifiable by a verification class induced by a certain neighborhood function. In the following, we abbreviate the tuple (F̃x, A(F )) by F̃xA.\nγna(F̃ A) = {S | S ∈ F̃ , S is ⊆ -maximal in F̃};\nγstg(F̃ + A ) = {S | (S, S +) ∈ F̃+, S+ is ⊆ -maximal in\n{C+ | (C,C+) ∈ F̃+}};\nγstb(F̃ + A ) = {S | (S, S +) ∈ F̃+, S+ = A}; γad(F̃ ∓ A ) = {S | (S, S ∓) ∈ F̃∓, S∓ = ∅}; γpr(F̃ ∓ A ) = {S | S ∈ γad(F̃ ∓ A ), S is ⊆ -maximal in γad(F̃ ∓ A )};\nγss(F̃ +∓ A ) = {S | S ∈ γad(F̃ ∓ A ), S + is ⊆ -maximal in\n{C+ | (C,C+, C∓) ∈ F̃+∓, C ∈ γad(F̃∓A )}};\nγid(F̃ ∓ A ) = {S | S is ⊆ -maximal in {C | C ∈ γad(F̃∓A ), C ⊆ ⋂ γpr(F̃ ∓ A )}};\nγeg(F̃ +∓ A ) = {S | S is ⊆ -maximal in {C | C ∈ γad(F̃∓A ), C ⊆ ⋂ γss(F̃ +∓ A )}};\nγsad(F̃ −± A ) = {S | (S, S −, S±) ∈ F̃−±,\n∃(S0, S−0 , S ± 0 ), . . . , (Sn, S − n , S ± n ) ∈ F̃−± : (∅ = S0 ⊂ · · · ⊂ Sn = S∧ ∀i ∈ {1, . . . , n} : S−i ⊆ S ± i−1)};\nγgr(F̃ −± A ) = {S | S ∈ γsad(F̃ −± A ),\n∀(S̄, S̄−, S̄±) ∈ F̃−± : S̄⊃S ⇒ (S̄−\\S±) 6=∅)};\nγco(F̃ +− A ) = {S | (S, S +, S−) ∈ F̃+−, (S− \\ S+) = ∅,\n∀(S̄, S̄+, S̄−) ∈ F̃+− : S̄⊃S ⇒ (S̄−\\S+)6=∅)}.\nInstead of a formal proof we give the following explanations. First of all it is easy to see that the naive semantics is verifiable by the verification class induced by r since the naive extensions can be determined by the conflict-free sets. Stable and stage semantics, on the other hand, utilize the range of each conflict-free set in addition. Hence they are verifiable by the verification class induced by r+. Now consider admissible sets. Recall that a conflict-free S set is admissible if and only if it attacks all attackers. This is captured exactly by the condition S∓ = ∅, hence admissible sets are verifiable by the verification class induced by r∓. The same holds for preferred semantics, since we just have to determine the maximal conflict-free sets with S∓ = ∅. Semi-stable semantics, however, needs the range of each conflict-free set in addition, see γss, which makes it verifiable by the verification class induced by r+∓. Finally consider the criterion γco. The first two conditions for a set of arguments S stand for conflict-freeness and admissibility, respectively. Now assume the third condition does not hold, i.e., there exists a tuple (S̄, S̄+, S̄−) ∈ F̃+− with S̄ ⊃ S and S̄− \\ S+ = ∅. This means that every argument attacking S̄ is attacked by S, i.e., S̄ is defended by S. Hence S is not a complete extension, showing that γco(F̃+−A ) = co(F ) for each F ∈ A . One can verify that all criteria from the list are adequate in the sense that they describe the extensions of the corresponding semantics.\nWe show now that the formal concepts of verifiability and being more informative behave correctly in the sense that the use of more informative neighborhood functions do not lead to a loss of verification capacity. Proposition 3. If a semantics σ is x-verifiable, then σ is verifiable by all verification classes induced by some ry with ry rx.\nProof. As σ is verifiable by the verification class induced by rx it holds that there is some γσ such that for all F ∈ A , γσ(F̃\nx, A(F )) = σ(F ). Now let ry rx, meaning that there is some δ such that δ(ry(S, S′)) = rx. We define γ′σ(F̃\ny, A(F )) = γσ({(S, δ(S)) | (S,S) ∈ F̃ y}, A(F )) and observe that {(S, δ(S)) | (S,S) ∈ F̃ y} = F̃x, hence γ′σ(F̃ y, A(F )) = σ(F ) for each F ∈ A .\nIn order to prove unverifiability of a semantics σ w.r.t. a class induced by a certain rx it suffices to present two AFs F and G such that σ(F ) 6= σ(G) but, F̃x = G̃x and A(F ) = A(G). Then the verification class induced by rx does not provide enough information to verify σ.\nIn the following we will use this strategy to show exact verifiability. Consider a semantics σ which is verifiable by a class induced by rx. If σ is unverifiable by all verifiability\nclasses induced by ry with ry ≺ rx we have that σ is exactly verifiable by rx. The following examples study this issue for the semantics under consideration. Example 4. The complete semantics is +−-verifiable as seen before. The following AFs show that it is even exactly verifiable by that class.\naF1 : b aF ′ 1 : b\naF2 : b c aF ′ 2 : b c\naF3 : b aF ′ 3 : b\naF4 : b aF ′ 4 : b\naF5 : b aF ′ 5 : b\naF6 : b aF ′ 6 : b\nFirst consider the AFs F1 and F ′1, and observe that F̃1 +± = {(∅, ∅, ∅), ({a}, ∅, ∅)} = F̃ ′1 +±\n. On the other hand F1 and F ′1 differ in their complete extensions since co(F1) = {∅} but co(F ′1) = {{a}}. Therefore complete semantics is unverifiable by the verification class induced by r+±. Likewise, this can be shown for the classes induced by r−∓, r±∓, r−±, r+∓, and r∩∪, respectively:\n• F̃2 −∓\n= {(∅, ∅, ∅), ({a}, ∅, ∅), ({a, c}, {b}, ∅), ({c}, {b}, ∅)} = F̃ ′2 −∓ , but co(F2) = {{a}, {a, c}} 6=\n{{a, c}} = co(F ′2). • F̃3 ±∓ = F̃ ′3 ±∓ , but co(F3) = {∅, {a}} 6= {{a}} = co(F ′3). • F̃4 −± = F̃ ′4 −±\n, but co(F4) = {∅, {a}} 6= {∅} = co(F ′4). • F̃5 +∓ = F̃ ′5 +∓ , but co(F5) = {∅, {a}} 6= {{a}} = co(F ′5). • F̃6 ∩∪ = F̃ ′6 ∩∪ , but co(F6) = {{a}} 6= {∅} = co(F ′6).\nHence the complete semantics is exactly verifiable by the verification class induced by r+−. Example 5. Consider the semi-stable and eager semantics and recall that they are +∓-verifiable In order to show exact verifiability it suffices to show unverifiability by the classes induced by r+, r∪, and r∓ (cf. Figure 1); F1 and F6 are taken from Example 4 above.\n• F̃1 + = F̃ ′1 +\n, but ss(F1) = eg(F1) = {∅} 6= {{a}} = ss(F ′1) = eg(F ′ 1).\n• F̃6 ∪ = F̃ ′6 ∪\n, but ss(F6) = eg(F6) = {{a}} 6= {∅} = ss(F ′6) = eg(F ′ 6).\n• F̃7 ∓ = F̃ ′7 ∓\n, but ss(F7) = {{b}} 6= {{a}, {b}} = ss(F ′7) and eg(F7) = {{b}} 6= {∅} = eg(F ′7).\naF7 : b c aF ′ 7 : b c\nHence, both the semi-stable and eager semantics are exactly verifiable by the verification class induced by r+∓.\nExample 6. Now consider the grounded and strong admissible semantics and recall that they are −±-verifiable In order to show exact verifiability we have to show unverifiability by the classes induced by r±, r−, and r∪ (cf. Figure 1); again, the AFs from Example 4 can be reused.\n• F̃1 ± = F̃ ′1 ±\n, but gr(F1) = {∅} 6= {{a}} = gr(F ′1) and sad(F1) = {∅} 6= {∅, {a}} = sad(F ′1).\n• F̃2 − = F̃ ′2 −\n, but gr(F2) = {{a}} 6= {a, c} = gr(F ′2) and sad(F2) = {∅, {a}} 6= {∅, {a}, {a, c}} = sad(F ′2)\n• F̃6 ∪ = F̃ ′6 ∪\n, but gr(F6) = {{a}} 6= {∅} = gr(F ′6) and sad(F6) = {∅, {a}} 6= {∅} = sad(F ′6).\nHence, both the grounded and strong admissible semantics are exactly verifiable by the verification class induced by r+∓.\nExample 7. Finally consider stable, stage, admissible, preferred and ideal semantics. They are either +-verifiable (stb and stg) or ∓-verifiable (ad, pr , and id ). In order to show that these verification classes are exact we have to show unverifiability w.r.t. the verification class induced by r . Consider, for instance, the AFs F4 and F ′4 from Example 4. We have F̃4 = F̃ ′4 , but ad(F4) = {∅, {a}} 6= {∅} = ad(F ′4), stb(F4) = {{a}} 6= ∅ = stb(F ′4), and σ(F4) = {{a}} 6= {∅} = σ(F ′4) for σ ∈ {stg , pr , id}, showing exactness of the respective verification classes.\nThe insights obtained through Examples 4, 5, 6, and 7 show that the verification classes obtained from the criteria given above are indeed exact. Figure 2 shows the relation between the semantics under consideration with respect to their exact verification classes.\nWe turn now to the main theorem stating that any rational semantics (recall that all semantics we consider in this paper are rational) is exactly verifiable by one of the 15 different verification classes.\nTheorem 4. Every semantics which is rational is exactly verifiable by a verification class induced by one of the neighborhood functions presented in Figure 1.\nProof. First of all note that by Lemma 2, r is the least informative neighborhood function and for every other neighborhood function rx it holds that r r−. Therefore, if a semantics is verifiable by the verification class induced by any rx then it is exactly verifiable by a verification class induced by some ry with r ry rx. Moreover, if a semantics is exactly verifiable by a class, then it is by definition also verifiable by this class. Hence it remains to show that every\nsemantics which is rational is verifiable by a verification class presented in Figure 1.\nWe show the contrapositive, i.e., if a semantics is not verifiable by a verification class induced by one of the neighborhood functions presented in Figure 1 then it is not rational.\nAssume a semantics σ is not verifiable by one of the verification classes. This means σ is not verifiable by the verification class induced by r+−. Hence there exist two AFs F and G such that F̃+− = G̃+− and A(F ) = A(G), but σ(F ) 6= σ(G). For every argument a which is not selfattacking, a tuple ({a}, {a}+, {a}−) is contained in F̃+− (and in G̃+−). Hence F and G have the same not-selfattacking arguments and, moreover these arguments have the same ingoing and outgoing attacks in F and G . This, together with A(F ) = A(G) implies that F l = G l (see Definition 2) holds. But since σ(F ) 6= σ(G) we get that σ is not rational, which was to show.\nNote that the criterion giving evidence for verifiability of a semantics by a certain class has access to the set of arguments of a given framework. In fact, only the criterion for stable semantics makes use of that. Indeed, stable semantics needs this information since it is not verifiable by any class when using a weaker notion of verifiability, which rules out the usage of A(F ).\nIntermediate Semantics A type of semantics which has aroused quite some interest in the literature (see e.g. (Baroni and Giacomin 2007a) and (Nieves, Osorio, and Zepeda 2011)) are intermediate semantics, i.e. semantics which yield results lying between two existing semantics. The introduction of σ-τ -intermediate semantics can be motivated by deleting undesired (or add desired) τ -extensions while guaranteeing all reasonable positions w.r.t. σ. In other words, σ-τ -intermediate semantics can be seen as sceptical or credulous acceptance shifts within the range of σ and τ .\nA natural question is whether we can make any statements about compatible kernels of intermediate semantics. In particular, if semantics σ and τ are compatible with some kernel k , is then every σ-τ -intermediate semantics k -compatible. The following example answers this question negatively.\nExample 8. Recall from Theorem 1 that both stable and stage semantics are compatible with k(stb), i.e. F ≡stbE G ⇔ F ≡stgE G ⇔ F k(stb) = Gk(stb). Now we define the following stb-stg-intermediate semantics, say stagle semantics: Given an AF F = (A,R), S ∈ sta(F ) iff S ∈ cf(F ), S+F ∪ S − F = A and for every T ∈ cf(F ) we have S + F 6⊂ T + F . Obviously, it holds that stb ⊆ sta ⊆ stg and stb 6= sta as well as sta 6= stg, as witnessed by the following AF F :\naF : b c\nIt is easy to verify that stb(F ) = ∅ ⊂ sta(F ) = {{b}} ⊂ stg(F ) = {{b}, {c}}. We proceed by showing that stagle semantics is not compatible with k(stb). To this end consider F k(stb), which is depicted below.\naF k(stb) : b c\nNow, sta ( F k(stb) ) = {{b}, {c}} witnesses F 6≡sta F k(stb)\nand therefore, F 6≡staE F k(stb). Since F k(stb) = ( F k(stb) )k(stb) we are done, i.e. stagle semantics is indeed not compatible with the stable kernel.\nIt is the main result of this section that compatibility of intermediate semantics w.r.t. a certain kernel can be guaranteed if verifiability w.r.t. a certain class is presumed. The provided characterization theorems generalize former results presented in (Oikarinen and Woltran 2011). Moreover, due to the abstract character of the theorems the results are applicable to semantics which may be defined in the future.\nBefore turning to the characterization theorems we state some implications of verifiability. In particular, under the assumption that σ is verifiable by a certain class, equality of certain kernels implies expansion equivalence w.r.t. σ.\nProposition 4. For any +-verifiable semantics σ we have\nF k(stb) = Gk(stb) ⇒ F ≡σE G .\nProof. In (Oikarinen and Woltran 2011) it was shown that F k(stb) = Gk(stb) ⇒ (F ∪H )k(stb) = (G ∪H )k(stb) (i). Consider now a +-verifiable semantics σ. In order to show\nσ (F ) = σ ( F k(stb) ) (ii) we prove F̃+ = F̃ k(stb) +\n(*) first. It is easy to see that S ∈ cf(F ) iff S ∈ cf ( F k(stb) ) . Fur-\nthermore, since k(stb) deletes an attack (a, b) only if a is self-defeating we deduce that ranges does not change as long as conflict-free sets are considered. Thus, σ(F ) = (Def.)\nγσ(F̃ +) = (*) γσ(F̃ k(stb)\n+\n) = (Def.) σ(F k(stb)).\nNow assume that F k(stb) = Gk(stb) and let S ∈ σ(F ∪ H ) for some AF H . We have to show that S ∈ σ(G ∪ H ). Applying (ii) we obtain S ∈ σ ( (F ∪H )k(stb) ) . Furthermore,\nusing (i) we deduce S ∈ σ ( (G ∪H )k(stb) ) . Finally, S ∈ σ (G ∪H ) by applying (ii), which concludes the proof.\nThe following results can be shown in a similar manner.\nProposition 5. For any +∓-verifiable semantics σ we have\nF k(ad) = Gk(ad) ⇒ F ≡σE G .\nProposition 6. For any +−-verifiable semantics σ we have\nF k(co) = Gk(co) ⇒ F ≡σE G .\nProposition 7. For any −±-verifiable semantics σ we have\nF k(gr) = Gk(gr) ⇒ F ≡σE G .\nProposition 8. For any -verifiable semantics σ we have\nF k(na) = Gk(na) ⇒ F ≡σE G .\nWe proceed with general characterization theorems. The first one states that stb-stg-intermediate semantics are compatible with stable kernel if +-verifiability is given. Consequently, stagle semantics as defined in Example 8 can not be +-verifiable.\nTheorem 5. Given a semantics σ which is +-verifiable and stb-stg-intermediate, it holds that\nF k(stb) = Gk(stb) ⇔ F ≡σE G .\nProof. (⇒) Follows directly from Proposition 4. (⇐) We show the contrapositive, i.e. F k(stb) 6= Gk(stb) ⇒ F 6≡σE G . Assuming F k(stb) 6= Gk(stb) implies F 6≡ stg E G , i.e. there exists an AF H such that stg(F ∪ H ) 6= stg(G ∪ H ) and therefore, stb(F ∪H ) 6= stb(G ∪H ). Let B = A(F ) ∪ A(G)∪A(H ) and H ′ = (B ∪{a}, {(a, b), (b, a) | b ∈ B}). It is easy to see that stb(F ∪ H ′) = stb(F ∪ H ) ∪ {{a}} and stb(G ∪ H ′) = stb(G ∪ H ) ∪ {{a}}. Since now both stb(F ∪H ′) 6= ∅ and stb(G ∪H ′) 6= ∅ it holds that stb(F ∪ H ′) = stg(F ∪H ′) and stb(G ∪H ′) = stg(G ∪H ′). Hence σ(F ∪H ′) 6= σ(F ∪H ′), showing that F 6≡stbE G .\nThe following theorems can be shown in a similar manner.\nTheorem 6. Given a semantics σ which is +∓-verifiable and ρ-ad-intermediate with ρ ∈ {ss, id, eg}, it holds that\nF k(ad) = Gk(ad) ⇔ F ≡σE G .\nRemember that complete semantics is a ss-ad-intermediate semantics. Furthermore, it is not characterizable by the admissible kernel as already observed in (Oikarinen and Woltran 2011). Consequently, complete semantics is not +∓- verifiable (as we have shown in Example 4 with considerable effort).\nTheorem 7. Given a semantics σ which is −±-verifiable and gr-sad-intermediate, it holds that\nF k(gr) = Gk(gr) ⇔ F ≡σE G .\nConclusions In this work we have contributed to the analysis and comparison of abstract argumentation semantics. The main idea of our approach is to provide a novel categorization in terms of the amount of information required for testing whether a set of arguments is an extension of a certain semantics. The resulting notion of verifiability classes allows us to categorize any new semantics (given it is “rational”) with respect to the information needed and compare it to other semantics. Thus our work is in the tradition of the principle-based evaluation due to Baroni and Giacomin (2007b) and paves the way for a more general view on argumentation semantics, their common features, and their inherent differences.\nUsing our notion of verifiability, we were able to show kernel-compatibility for certain intermediate semantics. Concerning concrete semantics, our results yield the following observation: While preferred, semi-stable, ideal and eager semantics coincide w.r.t. strong equivalence, verifiability of these semantics differs. In fact, preferred and ideal semantics manage to be verifiable with strictly less information.\nFor future work we envisage an extension of the notion of verifiability classes in order to categorize semantics not captured by the approach followed in this paper, such as cf2 (Baroni, Giacomin, and Guida 2005)."
    } ],
    "references" : [ {
      "title" : "Comparing argumentation semantics with respect to skepticism",
      "author" : [ "Baroni", "P. Giacomin 2007a] Baroni", "M. Giacomin" ],
      "venue" : "Computer Science,",
      "citeRegEx" : "Baroni et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Baroni et al\\.",
      "year" : 2007
    }, {
      "title" : "On principle-based evaluation of extension-based argumentation semantics",
      "author" : [ "Baroni", "P. Giacomin 2007b] Baroni", "M. Giacomin" ],
      "venue" : null,
      "citeRegEx" : "Baroni et al\\.,? \\Q2007\\E",
      "shortCiteRegEx" : "Baroni et al\\.",
      "year" : 2007
    }, {
      "title" : "An introduction to argumentation semantics",
      "author" : [ "Caminada Baroni", "P. Giacomin 2011] Baroni", "M. Caminada", "M. Giacomin" ],
      "venue" : "Knowledge Eng. Review 26(4):365–410",
      "citeRegEx" : "Baroni et al\\.,? \\Q2011\\E",
      "shortCiteRegEx" : "Baroni et al\\.",
      "year" : 2011
    }, {
      "title" : "P",
      "author" : [ "Baroni, P.", "Dunne" ],
      "venue" : "E.; and Giacomin, M.",
      "citeRegEx" : "Baroni. Dunne. and Giacomin 2011",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "SCC-Recursiveness: A general schema for argumentation",
      "author" : [ "Giacomin Baroni", "P. Guida 2005] Baroni", "M. Giacomin", "G. Guida" ],
      "venue" : null,
      "citeRegEx" : "Baroni et al\\.,? \\Q2005\\E",
      "shortCiteRegEx" : "Baroni et al\\.",
      "year" : 2005
    }, {
      "title" : "and Brewka",
      "author" : [ "R. Baumann" ],
      "venue" : "G.",
      "citeRegEx" : "Baumann and Brewka 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "and Brewka",
      "author" : [ "R. Baumann" ],
      "venue" : "G.",
      "citeRegEx" : "Baumann and Brewka 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "and Spanring",
      "author" : [ "R. Baumann" ],
      "venue" : "C.",
      "citeRegEx" : "Baumann and Spanring 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "and Woltran",
      "author" : [ "R. Baumann" ],
      "venue" : "S.",
      "citeRegEx" : "Baumann and Woltran 2014",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "Special issue: Tutorials on structured argumentation. Argument and Computation 5(1):1–117",
      "author" : [ "Besnard" ],
      "venue" : null,
      "citeRegEx" : "Besnard,? \\Q2014\\E",
      "shortCiteRegEx" : "Besnard",
      "year" : 2014
    }, {
      "title" : "P",
      "author" : [ "M. Caminada", "W.A. Carnielli", "Dunne" ],
      "venue" : "E.",
      "citeRegEx" : "Caminada. Carnielli. and Dunne 2012",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "P",
      "author" : [ "Dung" ],
      "venue" : "M.; Mancarella, P.; and Toni, F.",
      "citeRegEx" : "Dung. Mancarella. and Toni 2007",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "P",
      "author" : [ "Dung" ],
      "venue" : "M.",
      "citeRegEx" : "Dung 1995",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Resolution-based grounded semantics revisited",
      "author" : [ "Dvořák" ],
      "venue" : "In Computational Models of Argument - Proceedings of COMMA 2014,",
      "citeRegEx" : "Dvořák,? \\Q2014\\E",
      "shortCiteRegEx" : "Dvořák",
      "year" : 2014
    }, {
      "title" : "and Woltran",
      "author" : [ "S.A. Gaggl" ],
      "venue" : "S.",
      "citeRegEx" : "Gaggl and Woltran 2013",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "and Modgil",
      "author" : [ "D. Grossi" ],
      "venue" : "S.",
      "citeRegEx" : "Grossi and Modgil 2015",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "and Vermeir",
      "author" : [ "H. Jakobovits" ],
      "venue" : "D.",
      "citeRegEx" : "Jakobovits and Vermeir 1999",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "Strongly equivalent logic programs",
      "author" : [ "Pearce Lifschitz", "V. Valverde 2001] Lifschitz", "D. Pearce", "A. Valverde" ],
      "venue" : "ACM Transactions on Computational Logic 2(4):526–541",
      "citeRegEx" : "Lifschitz et al\\.,? \\Q2001\\E",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 2001
    }, {
      "title" : "R",
      "author" : [ "Loui" ],
      "venue" : "P.",
      "citeRegEx" : "Loui 1987",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "M",
      "author" : [ "Maher" ],
      "venue" : "J.",
      "citeRegEx" : "Maher 1986",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "J",
      "author" : [ "Nieves" ],
      "venue" : "C.; Osorio, M.; and Zepeda, C.",
      "citeRegEx" : "Nieves. Osorio. and Zepeda 2011",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "and Woltran",
      "author" : [ "E. Oikarinen" ],
      "venue" : "S.",
      "citeRegEx" : "Oikarinen and Woltran 2011",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "J",
      "author" : [ "Pollock" ],
      "venue" : "L.",
      "citeRegEx" : "Pollock 1987",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "and Vreeswijk",
      "author" : [ "H. Prakken" ],
      "venue" : "G.",
      "citeRegEx" : "Prakken and Vreeswijk 2002",
      "shortCiteRegEx" : null,
      "year" : 2002
    } ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Dung’s abstract argumentation theory is a widely used formalism to model conflicting information and to draw conclusions in such situations. Hereby, the knowledge is represented by so-called argumentation frameworks (AFs) and the reasoning is done via semantics extracting acceptable sets. All reasonable semantics are based on the notion of conflict-freeness which means that arguments are only jointly acceptable when they are not linked within the AF. In this paper, we study the question which information on top of conflict-free sets is needed to compute extensions of a semantics at hand. We introduce a hierarchy of so-called verification classes specifying the required amount of information. We show that well-known standard semantics are exactly verifiable through a certain such class. Our framework also gives a means to study semantics lying inbetween known semantics, thus contributing to a more abstract understanding of the different features argumentation semantics offer.",
    "creator" : "LaTeX with hyperref package"
  }
}