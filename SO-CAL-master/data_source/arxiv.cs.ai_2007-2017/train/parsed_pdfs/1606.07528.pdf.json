{
  "name" : "1606.07528.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Dynamic Epistemic Framework for Conformant Planning",
    "authors" : [ "Quan Yu", "Yanjun Li", "Yanjing Wang" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "R. Ramanujam (Ed.): TARK 2015 EPTCS 215, 2016, pp. 298–318, doi:10.4204/EPTCS.215.21\nA Dynamic Epistemic Framework for Conformant Planning\nQuan Yu Department of Computer Science, Sun Yat-sen University, China\nQiannan Normal College for Nationalities, China\nYanjun Li Department of Philosophy, Peking University, China\nFaculty of Philosophy, University of Groningen, The Netherlands\nYanjing Wang∗\nDepartment of Philosophy, Peking University, China\nIn this paper, we introduce a lightweight dynamic epistemic logical framework for automated planning under initial uncertainty. We reduce plan verification and conformant planning to model checking problems of our logic. We show that the model checking problem of the iteration-free fragment is PSPACE-complete. By using two non-standard (but equivalent) semantics, we give novel model checking algorithms to the full language and the iteration-free language."
    }, {
      "heading" : "1 Introduction",
      "text" : "Conformant planning is the problem of finding a linear plan (a sequence of action) to achieve a goal in presence of uncertainty about the initial state (cf. [29]). For example, suppose that you are a rookie spy trapped in a foreign hotel with the following map at hand:1\ns6 s7:Safe s8:Safe\ns1 r // s2 r // u OO s3 r // u OO s4:Safe r // u OO s5\nNow somebody spots you and sets up the alarm. In this case you need to move fast to one of the safe hiding places marked in the map (i.e., s7,s8 and s4). However, since you were in panic, you lost your way and you are not sure whether you are at s2 or s3 (denoted by the circle in the above graph). Now what should you do in order to reach a safe place quickly? Clearly, merely moving r or moving u may not guarantee your safety given the uncertainty. A simple plan is to move r first and then u, since this plan will take you to a safe place, no matter where you actually are initially. This plan is conformant since it does not require any feedback during the execution and it should work in presence of uncertainty about the initial state. More generally, a conformant plan should also work given actions with non-deterministic effects. Such a conformant plan is crucial when there are no feedbacks/observations available during the execution of the plan.2 Note that since no information is provided during the execution, the conformant plan is simply a finite sequence of actions without any conditional moves.\n∗Corresponding author 1It is a variant of the running example in [33]. 2In many other cases, feedbacks may be just too ‘expensive’ to obtain during a plan aiming for quick actions [8].\nAs discussed in [9, 25], conformant planning can be reduced to classical planning, the planning problem without any initial uncertainty, over the space of belief states. Intuitively, a belief state is a subset of the state space, which records the uncertainty during the execution of a plan, e.g., {s2,s3} is an initial belief state in the above example. In order to make sure a goal is achieved eventually, it is crucial to track the transitions of belief states during the execution of the plan, and this may traverse exponentially many belief states in the size of the original state space. As one may expect, conformant planning is computationally harder than classical planning. The complexity of checking the existence of a conformant plan is EXPSPACE-complete in the size of the variables generating the state space [19]. In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.g., [11, 12].\nBesides the traditional AI approaches, we can also take an epistemic-logical perspective on planning in presence of initial uncertainties, based on dynamic epistemic logic (DEL) (cf. e.g., [16]). The central philosophy of DEL takes the meaning of an action as the change it brings to the knowledge of the agents. Intuitively, this is what we need to track the belief states during the execution of a plan3. Indeed, in recent years, there has been a growing interest in using DEL to handle multi-agent planning with knowledge goals (cf. e.g., [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case. In particular, the event models of DEL (cf. [6]) are used to handle non-public actions that may cause different knowledge updates to different agents. In these DEL-based planning frameworks, states are epistemic models, actions are event models and the state transitions are implicitly encoded by the update product which computes a new epistemic model based on an epistemic model and an event model.\nOne advantage of this approach is its expressiveness in handling scenarios which require reasoning about agents’ higher-order knowledge about each other in presence of partially observable actions. However, this expressiveness comes at a price, as shown in [7, 4], that multi-agent epistemic planning is undecidable in general. Many interesting decidable fragments are found in the literature [7, 24, 34, 1], which suggests that the single-agent cases and restrictions on the form of event models are the key to decidability. However, if we focus on the single-agent planning, a natural question arises: how do we compare such DEL approaches with the traditional AI planning? It seems that the DEL-based approaches are more suitable for planning with actions that change (higher-order) knowledge rather than planning with fact-changing actions, although the latter type of actions can also be handled in DEL. Moreover, the standard models of DEL are purely epistemic thus do not encode the temporal information of available actions directly. This may limit the applicability of such approaches to planning problems based on transition systems.\nIn this paper, we tackle the standard single-agent conformant planning problem over transition systems, by using the core idea of DEL, but not its standard formalism. Our formal framework is based on the logic proposed by Wang and Li in [33], where the model is simply a transition system with initial uncertainty as in the motivating example, and an action is interpreted in the semantics as an update on the uncertainty of the agent. Our contributions are summarized as follows:\n• A lightweight dynamic epistemic framework with a simple language and a complete axiomatization.\n• Non-trivial reduction of conformant planning to a model checking problem using our language with programs.\n3Here the belief states are actually about knowledge in epistemic logic.\n• Two novel model checking algorithms based on two alternative semantics for the proposed logic, which make the context-dependency in the original semantics explicit.\n• The complexity of model checking the iteration-free fragment of our language is PSPACE-complete. The model checking problem of the full language is in EXPTIME. The model checking problem of the conformant planning is in PSPACE.\nThe last result may sound contradictory to the aforementioned result that the complexity of conformant planning is EXPSPACE-complete. Actually, the apparent contradiction is due to the fact that the EXPSPACE complexity result is based on the number of state variables which require an exponential blow up to generate an explicit transition system that we use here. We will come back to this issue at the end of Section 4.3.\nOur approach has the following advantages compared to the existing planning approaches:\n• The planning goals can be specified as arbitrary formulas in an epistemic language. Extra plan constraints (e.g., what actions to use) can be expressed explicitly by programs in the language. Therefore it may cover a richer class of (conformant) planning problems compared to the traditional AI approach where a goal is Boolean.4\n• The plans can be specified as regular expressions with tests in terms of arbitrary EPDL formulas, which generalizes the knowledge-based programs in [18, 22].\n• By reducing conformant planning to a model checking problem in an explicit logical language, we also see the subtleties hidden in the planning problem. In principle, there are various model checking techniques to be applied to conformant planning based on this reduction.\n• Our logical language and models are very simple compared to the standard action-model based DEL approach, yet we can encode the externally given executability of the actions in the model, inspired by epistemic temporal logic (ETL) [17, 27].\n• Our approach is flexible enough to provide, in the future, a unified platform to compare different planning problems under uncertainty. By studying different fragments of the logical language and model classes, we may categorize planning problems according to their complexity.\nThe rest of the paper is organized as follows: We introduce our basic logical framework and its axiomatization in Section 2, and extend it in Section 3 with programs to handle the conformant planning. The complexity analysis of the model checking problems is in Section 4 and we conclude in Section 5 with future directions."
    }, {
      "heading" : "2 Basic framework",
      "text" : ""
    }, {
      "heading" : "2.1 Epistemic action language",
      "text" : "To talk about the knowledge of the agent during an execution of a plan, we use the following language proposed in [33].\n4The goal in the standard conformant planning is simply a set of different valuations of basic propositional variables. Our approach can even handle epistemic goals in negative forms, e.g., we want to make sure the agent knows something but does not know too much in the end.\nDefinition 2.1 (Epistemic Action Language (EAL)) Given a countable set A of action symbols and a countable set P of atomic proposition letters , the language EALAP is defined as follows: 5\nφ ::=> | p | ¬φ | (φ ∧φ) | [a]φ | Kφ ,\nwhere p∈ P, a∈ A. The following standard abbreviations are used: ⊥ :=¬>, φ∨ψ :=¬(¬φ∧¬ψ),φ→ ψ := ¬φ ∨ψ,〈a〉φ := ¬[a]¬φ , K̂φ := ¬K¬φ .\nKφ says that the agent knows that φ , and [a]φ expresses that if the agent can move forward by action a, then after doing a, φ holds. Throughout the paper, we fix some P and A, and refer to EALAP by EAL.\nThe size of EAL-formulas (notation |ϕ|) is defined inductively: |>| = |p| = 1; |¬φ | = 1+ |φ |; |φ ∧ ψ| = 1+ |φ |+ |ψ|; |Kφ | = |[a]φ | = 1+ |φ |. The set of subformulas of φ ∈ EAL, denoted as sub(φ), is defined as usual.\nDefinition 2.2 (Uncertainty map) Given P and A, a (multimodal) Kripke model N is a tuple 〈S ,{Ra | a ∈ A},V 〉, where S is a non-empty set of states, Ra ⊆ S ×S is a binary relation labelled by a, V : S → 2P is a valuation function. An uncertainty map M is a Kripke model 〈S ,{Ra | a ∈ A},V 〉 with a non-empty set U ⊆ S . Given an uncertainty map M , we refer to its components by SM , RaM , VM , and UM . A pointed uncertainty map M ,s is an uncertainty map M with a designated state s ∈UM . We write s a→ t for (s, t) ∈Ra.\nIntuitively, a Kripke model encodes a map (transition system) and the uncertainty set U encodes the uncertainty that the agent has about where he is in the map. The graph mentioned at the beginning of the introduction is a typical example of an uncertainty map. Note that there may be non-deterministic transitions in the model, i.e., there may be t1 6= t2 such that s a→ t1 and s a→ t2 for some s, t1, t2.\nRemark 1 It is crucial to notice that the designated state in a pointed uncertainty map must be one of the states in the uncertainty set.\nDefinition 2.3 (Semantics) Given any uncertainty map M = 〈S ,{Ra | a ∈ A},V ,U 〉 and any state s ∈U , the semantics is defined as follows:\nM ,s > always M ,s p ⇐⇒ s ∈ V (p) M ,s ¬φ ⇐⇒ M ,s 2 φ M ,s φ ∧ψ ⇐⇒ M ,s φ and M ,s ψ M ,s [a]φ ⇐⇒ ∀t ∈ S : s a→ t implies M |a, t φ M ,s Kφ ⇐⇒ ∀u ∈U : M ,u φ\nwhere M |a = 〈S ,{Ra | a ∈ A},V ,U |a〉 and U |a = {r′ | ∃r ∈U such that r a→ r′}. We say φ is valid (notation: φ ) if it is true on all the pointed uncertainty maps. For a action sequence σ = a1 . . .an, we write U |σ for (. . .((U |a1)|a2) . . .)|an . and write M |σ for (. . .((M |a1)|a2) . . .)|an .\nIntuitively, the agent ‘carries’ the uncertainty set with him when moving forward and obtains a new uncertainty set U |a. Note that here we differ from [33] where the updated uncertainty set is further\n5We do need unboundedly many action symbols to encode the desired problem in the later discussion of model checking complexity.\nrefined according to what the agent can observe at the new state. For conformant planning, we do not consider the observational power of the agent during the execution of a plan.\nLet us call the model mentioned in the introduction M , it is not hard to see that M |r and (M |r)|u are as follows:\ns6 s7:Safe s8:Safe\ns1 r // s2 r //\nu\nOO\ns3 r //\nu\nOO\ns4:Safe r //\nu\nOO\ns5\ns6 s7:Safe s8:Safe\ns1 r // s2 r //\nu\nOO\ns3 r //\nu\nOO\ns4:Safe r //\nu\nOO\ns5\nThus we have:\n• M ,s3 [r](Safe∧¬KSafe)\n• M ,s3 K[r][u](Safe∧KSafe)\nThe usual global model checking algorithm for modal logics labels the states with the subformulas that are true on the states. However, this cannot work here since the truth value of epistemic formulas on the states outside U is simply undefined. Moreover, the exact truth value of an epistemic formula on a state depends on ‘how you get there’, as the following example shows (the underlined states mark the actual states):\ns1 b //\na\ns3 : p\na\ns2\na\n<<\ns4\nb→\ns1 b //\na\ns3 : p\na\ns2\na <<\ns4\ns1 b //\na\ns3 : p\na\ns2\na\n<<\ns4\na→ a→\ns1 b //\na\ns3 : p\na\ns2\na <<\ns4\nLet the left-hand-side model be M then it is clear that M |b,s3 K p while M |aa,s3 2 K p thus M ,s1 〈b〉K p∧〈a〉〈a〉¬K p. This shows that the truth value of an epistemic subformula w.r.t. a state in the model is somehow ‘context-dependent’, which requires new techniques in model checking. We will make this explicit in Section 4.3 when we discuss the model checking algorithm."
    }, {
      "heading" : "2.2 Axiomatization",
      "text" : "Following the axioms proposed in [33], we give the following axiomatization for EALw.r.t. our semantics:\nSystem SELA Axioms Rules TAUT all axioms of propositional logic MP φ ,φ → ψ ψ DISTK K(p→ q)→ (K p→ Kq) NECK φ Kφ DIST(a) [a](p→ q)→ ([a]p→ [a]q) NEC(a) φ\n[a]φ\nT K p→ p SUB φ(p) φ(ψ)\n4 K p→ KK p\n5 ¬K p→ K¬K p\nPR(a) K[a]p→ [a]K p\nNM(a) 〈a〉K p→ K[a]p\nwhere a ranges over A, p,q range over P. PR(·) and NM(·) denote the axioms of perfect recall and no miracles respectively (cf. [32]).\nNote that since we do not assume that the agent can observe the available actions, the axiom OBS(a) : K〈a〉>∨K¬〈a〉> in [33] is abandoned. Due to the same reason, the axiom of no miracles is also simplified.\nWe show the completeness of SELA using a more direct proof strategy compared to the one used in [33].\nTheorem 2.1 SELA is sound and strongly complete w.r.t. EAL on uncertainty maps.\nProof: To prove that SELA is sound on uncertainty maps, we need to show that all the axioms are valid and all the inference rules preserve validity. Since the uncertainty set in an UM denotes an equivalent class, axioms T, 4 and 5 are valid; due to the semantics, the validity of axioms PR(·) and NM(·) can be proved step by step; others can be proved as usual.\nTo prove that SELA is strongly complete on uncertainty maps, we only need to show that every SELA-consistent set of formulas is satisfiable on some uncertainty map. The proof idea is that we construct an uncertainty map consisting of maximal SELA-consistent sets (MCSs), and then with the Lindenbaum-like lemma that every SELA-consistent set of formulas can be extended in to a MCS (we omit the proof here), we only need to prove that every formula holds on the MCS to which it belongs.\nFirstly, we construct a canonical Kripke model N c = 〈S c,{Rca | a ∈ A},V c〉 as follows:\n• S c is the set of all MCSs;\n• sRcat ⇐⇒ 〈a〉φ ∈ s for any φ ∈ t (equivalently φ ∈ t for any [a]φ ∈ s);\n• V c(p) = {s | p ∈ s}.\nGiven s ∈S c, we define U cs = {u ∈S c | Kφ ∈ s iff Kφ ∈ u}, and it is obvious that s ∈U cs . Thus we have that for each s ∈S c, M cs = 〈N c,U cs 〉 is an uncertainty map, and M cs ,s is a pointed uncertainty map.\nSecondly, we prove the following claim.\nClaim 2.1 If s a→ t, then we have U cs |a = U ct .\n⊆: Assuming v ∈ U cs |a, we need to show v ∈ U ct , namely we need to show that Kφ ∈ v ⇐⇒ Kφ ∈ t. Since v ∈ U cs |a, we have that there is u ∈ U cs such that uRcav. If Kφ ∈ t, it follows by axiom 4 that KKφ ∈ t. Thus we have 〈a〉KKφ ∈ s. By axiom NM(a), it follows that K[a]Kφ ∈ s. By u∈U cs and axiom T, we have [a]Kφ ∈ u. It follows by uRcav that Kφ ∈ v. If Kφ 6∈ t, we have ¬Kφ ∈ t. By axiom 5, we have K¬Kφ ∈ t. Similarly, we have ¬Kφ ∈ v. Thus we have Kφ 6∈ v. ⊇: Assuming v ∈U ct , we need to show v ∈U cs |a, namely there is u ∈U cs such that uRcav. Let u− be {Kφ | Kφ ∈ s}∪{〈a〉ψ | ψ ∈ v}. Then u− is consistent. For suppose not, we have ` Kφ1∧ ·· ·∧Kφn→ [a]¬ψ1∨ ·· ·∨ [a]¬ψk for some n and k. Since ` [a]¬ψ1∨ ·· ·∨ [a]¬ψk→ [a](¬ψ1∨ ·· ·∨¬ψk), we have ` Kφ1 ∧ ·· · ∧Kφn → [a](¬ψ1 ∨ ·· · ∨¬ψk). By rule NECK and axiom DISTK, we have ` KKφ1 ∧ ·· · ∧ KKφn→ K[a](¬ψ1∨·· ·∨¬ψk). Since KKφi ∈ s for each 1≤ i≤ n, we have K[a](¬ψ1∨·· ·∨¬ψk) ∈ s. By axiom PR(a), it follows that [a]K(¬ψ1∨·· ·∨¬ψk)∈ s. It follows by sRcat that K(¬ψ1∨·· ·∨¬ψk)∈ t. Since v ∈U ct , by axiom T, we have ¬ψ1∨·· ·∨¬ψk ∈ v. This is contrary with ψi ∈ v for each 1≤ i≤ k. Thus u− is consistent. By Lindenbaum-like Lemma, there exists a MCS u extending u−. It follows by u− ⊆ u that u ∈U cs and uRcav. We conclude that v ∈U cs |a.\nFinally, we will show that M cs ,s φ iff φ ∈ s. we prove it by induction on φ . Please note that the ‘existence lemmas’ (that ¬[a]φ ∈ s implies ¬φ ∈ t for some t such that s a→ t and that ¬Kφ ∈ s implies ¬φ ∈ s′ for some s′ ∈U cs ) also hold in the model N c. We only focus on the case of [a]φ . With Claim 2.1, it follows that M ct = M c s |a if s\na→ t. Then by the induction hypothesis and the existence lemmas, it is easy to show that M cs ,s [a]φ iff [a]φ ∈ s."
    }, {
      "heading" : "3 An extension of EAL for conformant planning",
      "text" : ""
    }, {
      "heading" : "3.1 Epistemic PDL over uncertainty maps",
      "text" : "In this section we extend the language of EAL with programs in propositional dynamic logic and use this extended language to express the existence of a conformant plan.\nDefinition 3.1 (Epistemic PDL) The Epistemic PDL Language (EPDL) is defined as follows:\nφ ::=> | p | ¬φ | (φ ∧φ) | [π]φ | Kφ π ::= a | ?φ | (π;π) | (π +π) | π∗\nwhere p ∈ P, a ∈ A. We use LπMφ to denote [π]φ ∧〈π〉φ , which is logically equivalent to [π]φ ∧〈π〉>. Given a finite B⊆ A, we write B∗ for (Σa∈Ba)∗, i.e., the iteration over the ‘sum’ of all the action symbols in B. The size of EPDL formulas/programs is given by: |[π]φ |= |π|+ |φ |, |a|= 1, |π1;π2|= 1+ |π1|+ |π2|, |?φ |= |π∗|= 1+ |φ |, and |π1 +π2|= 1+ |π1|+ |π2|.\nGiven any uncertainty map M = 〈S ,{Ra | a ∈ A},V ,U 〉, any state s ∈U , the semantics is given by a mutual induction on φ and π (we only show the case about [π]φ , other cases are as in EAL):\nM ,s [π]φ⇔ for all M ′,s′ : (M ,s)JπK(M ′,s′) implies M ′,s′ φ\n(M ,s)JaK(M ′,s′)⇔M ′ = M |a and s a→ s′ (M ,s)J?ψK(M ′,s′)⇔ (M ′,s′) = (M ,s) and M ,s ψ\n(M ,s)Jπ1;π2K(M ′,s′)⇔ (M ,s)Jπ1K◦ Jπ2K(M ′,s′) (M ,s)Jπ1 +π2K(M ′,s′)⇔ (M ,s)Jπ1K∪ Jπ2K(M ′,s′)\n(M ,s)Jπ∗K(M ′,s′)⇔ (M ,s)JπK?(M ′,s′)\nwhere ◦,∪, ? at the right-hand side denote the usual composition, union and reflexive transitive closure of binary relations respectively. Clearly this semantics coincides with the semantics of EAL on EAL formulas.\nNote that each program π can be viewed as a set of computation sequences, which are sequences of actions in A and tests with φ ∈ EPDL:\nL (a) = {a} L (?φ) = {?φ} L (π;π ′) = {ση | σ ∈L (π) and η ∈L (π ′)} L (π +π ′) = L (π)∪L (π ′) L (π∗) = {ε}∪ ⋃ n>0(L (π · · ·π︸ ︷︷ ︸\nn\n)) where ε is the empty sequence\nHere are some valid formulas which are useful in our latter discussion: 〈π;π ′〉φ ↔ 〈π〉〈π ′〉φ [π +π ′]φ ↔ [π]φ ∧ [π ′]φ [?ψ]φ ↔ (ψ → φ ) We leave the complete axiomatization of EPDL on uncertainty maps to future work."
    }, {
      "heading" : "3.2 Conformant planning via model checking EPDL",
      "text" : "Definition 3.2 (Conformant planning) Given an uncertainty map M , a goal formula φ ∈ EPDL, and a set B⊆ A, the conformant planning problem is to find a finite (possibly empty) sequence σ = a1a2 · · ·an ∈ L (B∗) such that for each u ∈UM we have M ,u La1MLa2M · · ·LanMφ . The existence problem of conformant planning is to test whether such a sequence exists.\nRecall that LπMφ is the shorthand of [π]φ ∧〈π〉φ . Intuitively, we want a plan which is both executable and safe w.r.t. non-deterministic actions and initial uncertainty of the agent. It is crucial to observe the difference between La1MLa2M · · ·LanMφ and La1;a2; · · · ;anMφ by the following example: Example 1 Given uncertainty map M depicted as follows, we have M ,s1 La;bMp but M ,s1 2 LaMLbMp.\ns2 b // s4 : p\ns1 a 66\na (( s3\nGiven M and φ , to verify whether σ ∈L (π) is a conformant plan can be formulated as the model checking problem: M ,u KLa1MLa2M · · ·LanMφ . On the other hand, the existence problem of a conformant plan is more complicated to formulate: it asks whether there exists a σ ∈ L (B∗) such that it can be verified as a conformant plan. The simple-minded attempt would be to check whether M ,u K〈B∗〉φ holds. Despite the 〈·〉-vs.-L·M distinction, K〈B∗〉φ may hold on a model where the sequences to guarantee φ on different states in UM are different, as the following example shows:\nExample 2 Given uncertainty map M depicted as follows, let the goal formula be p and B= {a,b}. We have M ,s1 K〈B∗〉p, but there is no solution to this conformant planning problem.\ns1 a // s3 b // s5 : p\ns2 b // s4 a // s6 : p\nThe right formula to check for the existence of a conformant plan w.r.t. B⊆ A and φ ∈ EPDL is:\nθB,φ = 〈(Σa∈B(?K〈a〉>;a))∗〉Kφ .\nFor example, if B = {a1,a2} then θB,φ = 〈((?K〈a1〉>;a1)+ (?K〈a2〉>;a2))∗〉Kφ . Intuitively, the confrmant plan consists of actions that are always executable given the uncertainty of the agent (guaranteed by the guard K〈a〉>). In the end the plan should also make sure that φ must hold given the uncertainty of the agent (guaranteed by Kφ ). In the following, we will prove that this formula is indeed correct.\nFirst, we observe that the rule of substitution of equivalents is valid (φ(ψ/χ) is obtained by replacing any occurrence of χ by ψ , similar for Jπ(ψ/χ)K): Proposition 3.1 If ψ ↔ χ , then:\n(1) φ ↔ φ(ψ/χ); (2) JπK = Jπ(ψ/χ)K.\nProposition 3.2 KLaMφ ↔ 〈?K〈a〉>;a〉Kφ Proof: Since KLaMφ ↔ (K[a]φ ∧K〈a〉φ) and (K〈a〉>∧〈a〉Kφ)↔ 〈?K〈a〉>;a〉Kφ , we only need to show that (K[a]φ ∧K〈a〉φ)↔ (K〈a〉>∧〈a〉Kφ).\nLeft to right: (L1) K[a]φ → [a]Kφ , by validity of Axiom PR(a) (L2) K〈a〉φ → 〈a〉>∧K〈a〉>, by semantics (L3) 〈a〉>∧ [a]Kφ → 〈a〉Kφ , by semantics (L4) K[a]φ ∧K〈a〉φ → K〈a〉>∧〈a〉Kφ , by (L1)-(L3) Right to left: (R1) 〈a〉Kφ → K[a]φ , by validity of Axiom NM(a) (R2) K[a]φ ∧K〈a〉>→ K〈a〉φ , by semantics (R3) K〈a〉>∧〈a〉Kφ → K[a]φ ∧K〈a〉φ , by R(1)-R(2)\nLemma 3.1 For any a1a2 · · ·an ∈L (A∗):\nKLa1MLa2M · · ·LanMφ ↔ 〈?K〈a1〉>;a1; . . . ; ?K〈an〉>;an〉Kφ Proof: It is trivial when n = 0 (i.e., the sequence is ε), since the claim then boils down to Kφ ↔ Kφ . We prove the non-trivial cases by induction on n≥ 1. When n = 1, it follows from Proposition 3.2. Now, as the induction hypothesis, we assume that:\nKLa1MLa2M · · ·LakMφ ↔ 〈?K〈a1〉>;a1; . . . ; ?K〈ak〉>;ak〉Kφ . We need to show:\nKLa1MLa2M · · ·Lak+1Mφ ↔ 〈?K〈a1〉>;a1; . . . ; ?K〈ak+1〉>;ak+1〉Kφ . By IH,\nKLa1MLa2M · · ·Lak+1Mφ ↔ 〈?K〈a1〉>;a1; . . . ; ?K〈ak〉>;ak〉KLak+1Mφ . (1) Due to Propositions 3.1 and 3.2, we have:\n〈?K〈a1〉>;a1; . . . ; ?K〈ak〉>;ak〉KLak+1Mφ ↔ 〈?K〈a1〉>;a1; . . . ; ?K〈an〉>;ak〉〈?K〈ak+1〉>;ak+1〉Kφ . (2) The conclusion is immediate by combining (1) and (2).\nThe following theorem follows from the above lemma.\nTheorem 3.1 Given a pointed uncertainty map M ,s, an EPDL formula φ and a set B⊆ A, the following two are equivalent:\n(1) There is a σ = a1 . . .an ∈L (B∗) such that M ,s KLa1MLa2M · · ·LanMφ ; (2) M ,s 〈(Σa∈B(?K〈a〉>;a))∗〉Kφ .\nWe would like to emphasise that the K operator right before φ in the definition of θB,φ cannot be omitted, as demonstrated by the following example:\nExample 3 Given uncertainty map M depicted as follows, let the goal formula be p. As we can see, there is no solution to this conformant planning problem. Indeed M ,s1 2 〈(Σa∈B(?K〈a〉>;a))∗〉K p with B= {a,b}, but we could have M ,s1 〈(Σa∈B(?K〈a〉>;a))∗〉p.\ns1 a // s2 b //\nb \"\"\ns5 : p\ns4\nWe close this section with an example about planning with both positive and negative epistemic goals (the agent should know something, but not too much).\nExample 4 Given uncertainty map M depicted as follows, let the goal be K p then both a and b are conformant plans. If the goal is K p∧¬Kq, only a is a good plan.\ns1 a // b && s3 : p s2 a //\nb &&\ns4 : p,q\ns5 : p,q"
    }, {
      "heading" : "4 Model checking EPDL: complexity and algorithms",
      "text" : "In this section, we first focus on the model checking problem of the following star-free fragment of EPDL (call it EPDL−):\nφ ::=> | p | ¬φ | (φ ∧φ) | [π]φ | Kφ π ::= a | ?φ | (π;π) | (π +π)\nWe will show that model checking EPDL− is PSPACE-complete. In particular, the upper bound is shown by making use of an alternative context-dependent semantics. Then we give an EXPTIME algorithm for the model checking problem of the full EPDL inspired by another alternative semantics based on 2- dimensional models. Finally we give a PSPACE algorithm for the conformant planning problem in EPDL. Note that throughout this section, we focus on uncertainty maps with finitely many states and assume Ra = /0 for co-finitely many a ∈ A."
    }, {
      "heading" : "4.1 Complexity of model checking EPDL−",
      "text" : ""
    }, {
      "heading" : "4.1.1 Lower Bound",
      "text" : "To show the PSPACE lower bound, we provide a polynomial reduction of QBF (quantified Boolean formula) truth testing to the model checking problem of EPDL−. Note that to determine whether a given\nQBF (even in prenex normal form based on a conjunctive normal form) is true or not is known to be PSPACE-complete [30]. Our method is inspired by [28] which discusses the complexity of model checking temporal logics with past operators. Surprisingly, we can use the uncertainty sets to encode the ‘past’ and use the dual of the knowledge operator to ‘go back’ to the past. This intuitive idea will become more clear in the proof.\nQBF formulas are Q1x1Q2x2 . . .Qnxnφ(x1, . . . ,xn) where:\n• For 1≤ n≤ n,Qi is ∃ if i is odd, and Qi is ∀ if i is even.\n• φ is a propositional formula in CNF based on variables x1, . . . ,xn,\nFor each such QBF α with n variables, we need to find a pointed model Mn,x0 and a formula θα such that α is true iff Mn,x0 θα . The model Mn is defined below.\nDefinition 4.1 Let A= {ai, āi | i≥ 1} and P= {pk,qk | k≥ 1}, the uncertainty map Mn = 〈S ,{Ra | a∈ A},V ,U 〉 is defined as:\n• S = {x0}∪{xi | 1≤ i≤ n}∪{x̄i | 1≤ i≤ n}\n• V (x0) = /0, and V (xi) = {pi},V (x̄i) = {qi} for 1≤ i≤ n.\n• ai→= {(s,s) | s ∈S }∪{(xi−1,xi),(x̄i−1,xi)}\n• āi→= {(s,s) | s ∈S }∪{(xi−1, x̄i),(x̄i−1, x̄i)}\n• U = {x0}\n|Mn| is linear in n and can be depicted as the following:\nx1 : p1\nA\na2 //\nā2\nx2 : p2\nA\na3 //\nā3\n· · · xn−1 : pn−1\nA\nan //\nān\nxn : pn\nA\nx0\nA a1 ::\nā1 ## x̄1 : q1\nA\nWW ā2 //\na2\nAA\nx̄2 : q2\nA\nWW ā3 //\na3\nDD\n· · · x̄n−1 : pn−1 A WW ān //\nan\n>>\nx̄n : qn\nA\nWW\nGiven α = Q1x1Q2x2 . . .Qnxnφ(x1, . . . ,xn), the formula θα is defined as\nQT1 · · ·QTnψ(K̂ p1, · · · , K̂ pn, K̂q1, · · · , K̂qn)\nwhere QTi is 〈(ai+ āi); ?(pi∨qi)〉 if i is odd and QTi is [(ai+ āi); ?(pi∨qi)] if i is even, and ψ is obtained from φ(x1, . . . ,xn) by replacing each xi with K̂ pi and ¬xi with K̂qi.\nTo ease the latter proof, we first define the valuation tree below.\nDefinition 4.2 (V-tree) A V-tree τ is a rooted tree such that 1) each node is 0 or 1 (except the root ε); 2) each internal node in an even level has only one successor; 3) each internal node in an odd level has two successors: one is 0 and the other one is 1; 4) each edge to node 0 of level i is labelled āi; 5) each edge to node 1 of level i is labelled ai. Given a V-tree with depth n, a path σ is a sequence of A1 . . .An where Ai = ai or Ai = āi. A path σ can also be seen as a valuation assignment for x1, . . . ,xn with the convention that σ(xi) = 1 if ai occurs in σ and σ(xi) = 0 if āi occurs in σ . Let path(τ) be the set of all paths of τ .\nAs an example, a V-tree τ can be depicted as below:\nε a1 // 1 ā2 ))\na2 55\n0 a3 //\n1 ā3 //\n1\n0\nIt is not hard to see the following:\nProposition 4.1 For each 1≤ i≤ n, we have: α = Q1x1 . . .QixiQi+1xi+1 . . .Qnxnφ is true iff there exists a V-tree τ with depth i such that for each σ ∈ path(τ) σ(Qi+1xi+1 . . .Qnxnφ) = 1 (σ as a valuation). Now let us see the update result of running a path σ ∈ path(τ) on Mn. Due to the lack of space, we omit the proofs of the following two propositions.\nProposition 4.2 Given Mn, let σ = A1 . . .Ai (1 ≤ i ≤ n) be a sequence of actions such that Ak = ak or Ak = āk for each 1 ≤ k ≤ i, then we have U |σ = {x0,X1, . . . ,Xi} where Xk = xk if Ak = ak else Xk = x̄k for each 1≤ k ≤ i.\nGiven σ = A1 . . .An where Ai is ai or āi for each 1≤ i≤ n, let g(σ) = xn if An = an and g(σ) = x̄n if An = ān. By Proposition 4.2, we always have g(σ)∈UMk |σ with k > n. Thus given Mk and σ =A1 . . .An and k > n, Mk|σ ,g(σ) is a pointed uncertainty map.\nProposition 4.3 For each 1≤ i≤ n, we have Mk,x0 QT1 . . .QTiQTi+1 . . .QTnψ iff there exists a V-tree τ with depth i such that Mk|σ ,g(σ) QTi+1 . . .QTnψ for each σ ∈ path(τ), where k > n and g(σ) is the state corresponds to the last edge of σ , e.g., g(a1ā2) = x̄2.\nTheorem 4.1 The following two are equivalent:\n• α = Q1x1Q2x2 . . .Qnxnφ(x1, . . . ,xn) is true • Mn,x0 QT1 · · ·QTnψ(K̂ p1 · · · K̂ pn, K̂q1 · · · K̂qn) in which ψ is obtained from φ by replacing each\nxi with K̂ pi and ¬xi with K̂qi.\nProof: By Propositions 4.1 and 4.3, we only need to show that given V-tree τ with depth n, σ(φ) = 1 if and only if Mn|σ ,g(σ) ψ for each σ ∈ path(τ). Since φ is in CNF, ψ is also in CNF-like form obtained by replacing each xi with K̂ pi and each ¬xi with K̂qi for 1≤ i≤ n. Thus we only need to show that σ(xi)= 1 iff Mn|σ ,g(σ) K̂ pi and σ(¬xi)= 1 iff Mn|σ ,g(σ) K̂qi. Since σ(xi)= 1 iff σ(¬xi)= 0, we only need to show that σ(xi) = 1 iff Mn|σ ,g(σ) K̂ pi and Mn|σ ,g(σ) K̂ pi iff Mn|σ ,g(σ) ¬K̂qi. By the definition of τ , we know that σ = A1 . . .An where Ai is ai or āi for each 1≤ i≤ n.\nFirstly, we will show that Mn|σ ,g(σ) K̂ pi if and only if Mn|σ ,g(σ) ¬K̂qi. To verify the rightto-left direction, if Mn|σ ,g(σ) K̂ pi, it follows by the definition of Mn that xi ∈ U |σ . Then it must be the case that ai occurs in σ . Suppose not, āi occurs in σ . It follows by Proposition 4.2, U |σ = {x0,X1, . . . ,Xi−1, x̄i,Xi+1, . . . ,Xn}. This is contrary with xi ∈ U |σ . Thus it must be that ai occurs in σ . It follows by Proposition 4.2 that U |σ = {x0,X1, . . . ,Xi−1,xi,Xi+1, . . . ,Xn}. Thus x̄i 6∈ U |σ . By the definition of Mn and the semantics, we have Mn|σ ,g(σ) ¬K̂qi. To verify the left-to-right direction, Mn|σ ,g(σ) ¬K̂qi implies that x̄i 6∈ U |σ . For the similar reason as above, it must be the case that āi does not occur in σ . Thus we have that ai occurs in σ . It follows by Proposition 4.2 that xi ∈U |σ . Thus we have Mn|σ ,g(σ) K̂ pi.\nNext we will show that σ(xi)= 1 iff Mn|σ ,g(σ) K̂ pi. To verify the right-to-left direction, σ(xi)= 1 implies that Ai = ai. It follows by Proposition 4.2 that xi ∈ U |σ . Thus we have Mn|σ ,g(σ) K̂ pi. To verify the left-to-right direction, we will show that σ(xi) = 0 implies Mn|σ ,g(σ) K̂qi. It follows by the definition of σ(xi) = 0 that Ai = āi. It follows by Proposition 4.2 that x̄i ∈ U |σ . Thus we have\nMn|σ ,g(σ) K̂qi.\nThis gives us the desired lower bound:\nTheorem 4.2 The model checking problem for EPDL− is PSPACE-hard."
    }, {
      "heading" : "4.1.2 Upper Bound",
      "text" : "In this section we give a non-trivial model checking algorithm for EPDL− inspired by an equivalent semantics.\nAs we mentioned earlier, the semantics of EPDL is ‘context-dependent’: reaching the same state through different paths may affect the truth value of an epistemic subformula. This means that the usual global model checking algorithm for modal logics may not work here. In order to establish the upper bound, we first give the following equivalent semantics to EPDL− which makes the context dependency explicit in order to facilitate a local model checking algorithm. The idea is to keep the model intact but record the scope of action modalities in order to compute the right uncertainty set for epistemic subformulas. Similar idea appeared in [32] to give an alternative semantics of public announcement logic.\nDefinition 4.3 Given an uncertainty map M = 〈S ,{Ra | a ∈ A},V ,U 〉 and any state s ∈ S , the satisfaction relation is defined using the auxiliary satisfaction relation σ and auxiliary relation\nωσ→, where σ is a finite (possibly empty) sequence of actions in A:\nM ,s φ ⇔M ,s ε φ M ,s σ > ⇔ always M ,s σ p ⇔ p ∈ V (s) M ,s σ ¬φ ⇔M ,s 1σ φ M ,s σ φ ∧ψ⇔M ,s σ φ and M ,s σ ψ M ,s σ Kφ ⇔ for all v ∈U |σ : M ,v σ φ M ,s σ 〈π〉φ ⇔ there exists ω ∈L (π) and t ∈S\nsuch that s ωσ→ t and M , t σr(ω) φ\ns εσ→ t ⇔ s = t s (aω ′)σ→ t ⇔ there exists s′ such that s a→ s′ and s′\nω ′(σa)→ t s (?φω ′)σ→ t ⇔M ,s σ φ and s\nω ′σ→ t where r(ω) is the sequence of actions obtained by eliminating all the tests in ω .\nNote that ω in the above definition is a computation sequence, i.e., a finite sequence of actions and EPDL−-tests, while σ is a test-free sequence of actions.\nThe following can be proved by induction on η : Proposition 4.4 Given an uncertainty map M and sequences of actions and tests η ,ω,ω ′ such that η = ωω ′, we have (s, t) ∈ησ→ iff (s, t) ∈ωσ→◦ ω ′σr(ω)→ for any sequence of actions σ .\nProof: We prove it by induction on |η |. If |η | ≤ 2, it is obvious by the definition. If |η | > 2, there are two cases, that is, η = aη ′ or η =?φη ′.\nCase η = aη ′ : We have ω = aω ′′ for some initial segment ω ′′ of η ′, and (s, t) ∈(aη ′)σ→ iff there exists\ns′ such that s a→ s′ and (s′, t) ∈η ′ σa→. By IH, we have η ′ σa→=ω ′′ σa→ ◦ ω ′σar(ω ′′)→ . Thus we have (s′, t) ∈η ′ σa→ iff there\nexists t ′ such that (s′, t ′) ∈ω ′′ σa→ and (t ′, t) ∈ ω ′σar(ω ′′)→ . By definition, we have that s a→ s′ and (s′, t ′) ∈ω ′′ σa→ iff (s, t ′) ∈aω ′′ σ→ . Thus we have (s, t) ∈aω ′′ σ→ ◦ ω ′σar(ω ′′)→ , namely (s, t) ∈ωσ→◦ ω ′σr(ω)→ .\nCase η =?φη ′ : We have ω =?φω ′′ for some initial segment ω ′′ of η ′, and (s, t) ∈(?φη ′)σ→ iff M ,s σ\nφ and s η ′σ→ t. By IH, we have s η ′ σ→ t iff (s, t) ∈ω ′′ σ→ ◦ ω ′σr(ω ′′)→ . Thus we have there exists s′ such that (s,s′) ∈ω ′′ σ→ and (s′, t) ∈ ω ′σr(ω ′′)→ . This follows that (s,s′) ∈(?φω ′′)σ→ , and (s, t) ∈(?φω ′′)σ→ ◦ ω ′σr(?φω ′′)→ , namely (s, t) ∈ωσ→◦ ω ′σr(ω)→ .\nIn the following we show that coincides with .\nTheorem 4.3 Given an uncertainty map M and an action sequence σ , if U |σ 6= /0, we have that for each s ∈U |σ ,\n(i) M |σ ,sJπKM ′,s′ iff there exists ω ∈L (π) such that M ′ = M |σr(ω) and s ωσ→ s′, (ii) M |σ ,s φ iff M ,s σ φ .\nProof: The proof is by simultaneous induction on π and φ (due to the test actions). For (i), we will only focus on the case of π1;π2; the other cases are straightforward.\nCase π1;π2: We only show the direction from left to right; the other direction is similar. It follows by assumption that there is pointed uncertainty map N , t such that M |σ ,sJπ1KN , t and N , tJπ2KM ′,s′. By IH, we have that there exists ω ∈L (π1) such that N = M |σr(ω) and s\nωσ→ t. Since N , t is a pointed uncertainty map and N =M |σr(ω), we have t ∈U |σr(ω). By IH and M |σr(ω), tJπ2KM ′,s′, we have that\nthere exists ω ′ ∈L (π2) such that M |σr(ω)r(ω ′) = M |σr(ωω ′) = M ′ and t ω ′σr(ω)→ s′. By Proposition 4.4, it follows that ωω ′ ∈L (π1;π2) and s\n(ωω ′)σ→ s′. For (ii), we will focus on the case of 〈π〉φ ; the other cases are straightforward. Case 〈π〉φ : We have M |σ ,s 〈π〉φ if and only if there is pointed uncertainty map M ′,s′ such that M |σ ,sJπKM ′,s′ and M ′,s′ φ . By (i), it follows that M |σ ,sJπKM ′,s′ iff there exists ω ∈L (π) such that M ′ = M |σr(ω) and s ωσ→ s′. By IH, it follows that M |σr(ω),s′ φ iff M ,s′ σr(ω) φ . Thus we have M ,s 〈π〉φ .\nLet σ be ε , we have the equivalence of and . Corollary 4.1 Given pointed uncertainty map M ,s, we have M ,s φ iff M ,s φ for each φ ∈ EPDL−.\nThis alternative semantics induces a natural algorithm to compute the truth value of an EPDL− formula w.r.t. to a pointed uncertainty map. The idea is to recursively call a function MC(M ,s,σ ,φ) which returns the truth value of a subformula φ on state s given the context of σ while keeping M intact. Note that, we do not need to compute all the MC(M ,s,σ ,φ) for each σ and each subformula φ . The only tricky part comes when evaluating 〈π〉φ formulas since it is too space consuming to compute the whole set of L (π) in the search of the right ω . Instead, we can generate one by one in some lexicographical order all the possible sequences up to a bound based on the atomic actions and tests occurring in the formula, and then test whether it belongs to the program π . Note that in this way, we can use the space repeatedly, and the membership testing of L (π) is not expensive (NLOGSPACE-complete according to [20]).\nIn the appendix we present three algorithms based on matrix representation of the model: Algorithm 1 computes the uncertainty set U |σ ; Algorithm 2 computes wσ→ and Algorithm 3 is the main model\nchecking algorithm. Note that Algorithms 2 and 3 involve mutual recursion of each other due to the tests in programs. However, the depth of the recursion is bounded by the length of the formula, and for each call polynomial space suffices. The detailed algorithms and complexity analysis can be found in the appendix. It is not hard to show the following (based on Theorem 4.2)\nTheorem 4.4 (Upper bound) The model checking problem of EPDL− is in PSPACE. Thus it is PSPACEcomplete."
    }, {
      "heading" : "4.2 Upper Bounds for model checking EPDL",
      "text" : "In this section, we give an EXPTIME model checking method for the full EPDL via model checking EPDL over two-dimensional models with both epistemic and action relations. Let us first define such models.\nDefinition 4.4 (Epistemic Temporal Structure) An Epistemic Temporal Structure (ETS) is a Kripke model with both epistemic and action relations. Formally, an ETS model M is a tuple 〈S ,{Ra | a ∈ A},∼,V 〉, where Ra is a binary relation on S , ∼ is an equivalence relation on S and V : S → 2P is a valuation function.\nNow we define an alternative semantics of EPDL over ETSs.6\nDefinition 4.5 (ETS Semantics) Given any ETS model M= 〈S ,{Ra | a ∈ A},∼,V 〉 and any state s ∈S , the satisfaction relation for EPDL formulas is defined as follows (the Boolean cases are as in the standard modal logic):\nM,s Kφ ⇔∀u ∈S : s∼ u implies M,u φ M,s [π]φ⇔∀t ∈ S : s π→ t implies M, t φ a→ = Ra ?φ→ = {(s,s) |M,s φ} π1;π2→ = π1→◦ π2→ π1+π2→ = π1→∪ π2→ π∗→ = ( π→)?\nwhere ◦,∪, ? at right-hand side denote the usual composition, union and reflexive transitive closure of binary relations respectively.\nWe can turn a Kripke model without the epistemic relation into an ETS model by essentially considering all the possible uncertainty sets.\nDefinition 4.6 Given any Kripke model M = 〈S ,{Ra | a ∈ A},V 〉, we define the ETS model M • as follows:\nS • = {sΓ | s ∈S ,Γ ∈ 2S ,s ∈ Γ} R•a = {(sΓ, t∆) | s\na→ t,∆ = Γ|a} ∼• = {(sΓ, t∆) | Γ = ∆} V •(sΓ) =V (s)\nwhere Γ|a = {t ∈S | ∃s ∈ Γ such that s a→ t}. For any Kripke model M and any Γ ∈ 2S \\{ /0}, let M Γ be the uncertainty map 〈M ,Γ〉.\n6Here we abuse the notation to denote the new semantics. Note that it is different from the alternative semantics in the previous section.\nNote that each sΓ can be viewed as an uncertainty set (Γ) with a designated state (s), and the definition of Ra captures the update in the semantics of EPDL, and M • unravels all the updates in a whole picture. Note that the size of M • is |S | ·2|S |−1 where S is the set of states of M .\nNow we can show that and coincide w.r.t. uncertainty map M Γ and ETS model M • (the proofs are omitted due to the lack of space).\nProposition 4.5 Given any map M , we have\n(i) M Γ,sJπKM ∆, t iff sΓ π→ t∆ in M •;7\n(ii) M Γ,s φ iff M •,sΓ φ .\nCorollary 4.2 Given an uncertainty map M = 〈N ,U 〉 and s ∈U , we have M ,s φ iff N •,sU φ .\nBased on the above corollary we can have a model checking method via model checking EPDL over ETS models.\nProposition 4.6 The model checking problem of EPDL on uncertainty maps is in EXPTIME.\nProof: Given an uncertainty map M = 〈N ,U 〉, the construction of ETS N • can be done in exponential time in the size of N due to the fact that there are at most |N | a-successors t∆ of each sΓ since ∆ = Γ|a. By modifying the algorithm for PDL in [23], we can get an algorithm to check EPDL formula φ on N • w.r.t. , and its time complexity is O(|φ |2 · |N •|3). Thus, the time complexity of model checking φ on M is bounded by O(|φ |2 · |SN |3 ·23|SN |−3).\nWe conjecture that the model checking problem of full EPDL is EXPTIME-complete, and leave the lower bound to the extended version of this paper."
    }, {
      "heading" : "4.3 Complexity of conformant planning",
      "text" : "In the rest of this section, let us look at the complexity of conformant planning in terms of EPDL model checking. Although the model checking problem of full EPDL is likely to be EXPTIME-complete, the complexity of model checking the EPDL formula which encodes the conformant planning problem (cf. Theorem 3.1) is in PSPACE if the goal formula is program-free. More precisely, we can show the following:\nTheorem 4.5 The problem of model checking EPDL formulas in the shape of 〈(Σa∈B(?K〈a〉>;a))∗〉Kφ , where φ is an epistemic formula (i.e. program-free) and B⊆ A, is in PSPACE.\nProof: (Sketch) Note that (∑a∈B(?K〈a〉>;a))∗ is a special program which has only simple epistemic tests depending on the structure of the underlying Kripke model. Now given a Kripke model N and a set B ⊆ A we can define an ETS model N ◦ similar to N • but with a different definition for the action relations:\nR◦a = {(sΓ, t∆) | s a→ t,∆ = Γ|a,∀u ∈ Γ∃v st. u a→ v.}\nNote that the extra condition guarantees that the action a is always executable w.r.t. the whole Γ, thus fulfilling the test ?K〈a〉>. Now we can have an analog of Corollary 4.2, and reduce the problem of checking 〈N ,U 〉,s (∑a∈B(?K〈a〉>;a))∗Kφ to the reachability problem in N ◦: whether there is a path from sU in N ◦ such that it can reach a state tU ′ where Kφ holds. Since φ is [π]-free, we can check it easily given U ′ using polynomial space, thus the main task is to find the reachable tU ′ . Note\n7Cf. the definition of π→ in Def. 4.5.\nthat, in the size of N , there are exponentially many such tU ′ and the maximal length of the plan is also exponential. However, we do not need to build the whole N ◦ and the bisection-like algorithm behind the proof of Savitch’s Theorem will do the job.8 More precisely, we first pick up a tU ′ , and then run the recursive bisection method to see whether tU ′ is reachable from sU within 2|N | steps. The depth of the recursion is bounded by log2(2|N |) = |N | and at each recursion we need to record the choice of the state which can be encoded by a (0,1)-vector using log2(2|N |) = |N | space (plus one bit to record the result). Moreover, at the bottom of the recursion we only need to verify one step reachability, i.e., whether two states in N ◦ are linked by R◦a , without building the whole N\n◦. Thus the whole procedure of model checking can be done using polynomial space.\nAs we mentioned in the introduction, the conformant planning problems in the AI literature are usually given by using state variables and actions with preconditions and (conditional) effects, rather than explicit transition systems. The corresponding explicit transition system can be generated by taking all the possible valuations of the state variables as the state space (an exponential blow up), and computing the transitions among the valuations according to the preconditions and the postconditions of the actions. In terms of the size of explicit transition systems, our above result is consistent with the EXPSPACE complexity result in the AI literature for conformant planning with Boolean and modal goals [21, 8]. Actually, the complexity result of Theorem 4.5 can be strengthened to PSPACE-complete based on the corresponding complexity result in the AI literature.\nHowever, not all the transition systems can be generated in this way since the preconditions and postconditions are (usually) purely propositional and thus two states that share the same valuation must have the same executable actions. In an arbitrary transition system, multiple states with the same valuation may have different available actions due to some underlying protocol or other (external) factors not modelled by basic propositions."
    }, {
      "heading" : "5 Conclusions and future work",
      "text" : "In this work we first introduce the logical language EAL over uncertainty maps and axiomatize it completely. EAL is then extended to EPDL with programs to specify conformant and conditional plans. We show that the conformant planning problems can be reduced to model checking problems of EPDL. Finally we showed that model checking star-free EPDL over uncertainty maps is PSPACE-complete and model checking the full fragment is in EXPTIME. On the other hand, model checking the conformant planning problem is in PSPACE.\nNote that our EPDL is a powerful language which can already express conditional plans, for example, (?p;a+?¬p;b);c. This suggests that we can use the very EPDL language (EPDL− is enough) to verify plans in contingent planning w.r.t. a variant of the semantics which can handle feedbacks during the execution. In fact, observational power about the availability of the actions has been already incorporated in [33], which can be extended to general feedbacks discussed in the literature of contingent planning (cf. e.g., [10]). On the other hand, to check the existence of a conditional plan, we are not sure whether EPDL is expressive enough, as subtleties may arise as in the case of conformant planning. We leave the contingent planning to future work.\nAnother natural extension is to go probabilistic, and reduce the probabilistic planning over MDP to some model checking problem of the probabilistic version of our EPDL. Our ultimate goal is to cast all the standard AI planning problems into one unified logical framework in order to facilitate careful\n8A similar algorithm was used to pinpoint complexity of the conformant planning in AI, cf.[21].\ncomparison and categorization. We will then see clearly how the form of the goal formula, the constructor of the plan, and the observational ability matter in the theoretical and practical complexity of planning, in line with the research pioneered in [5].\nAcknowledgement Quan Yu is supported by NSF Grant No.61463044 and Grant No.[2014]7421 from the Joint Fund of the NSF of Guizhou province of China. Yanjun Li thanks the support from China Scholarship Council. Yanjing Wang acknowledges the support from ROCS of SRF by Education Ministry of China and the NSSF major project 12&ZD119."
    }, {
      "heading" : "A Algorithms for EPDL−",
      "text" : "Definition A.1 (Matrix representation) Let Bn×m denote a (0,1)-matrix of size n×m. A matrix Bn×1, or Bn for short, is called a vector. Given finite uncertainty map M , its domain S can be linearly ordered as {s1, · · · ,sn}. Thus M can be represented by a set {Ban×n | a ∈ A} of adjacency matrices for accessibility relation, a vector BUn for U and a set {B p n | p ∈ P} of vectors for atomic propositions.\nDefinition A.2 Given (0,1)-matrices B′n×k,Bk×m, their product B ′′ n×m is defined as: B ′′ n×m[i, j] = 1 iff there exists r ≤ n such that B′n×k[i,r] = Bk×m[r, j] = 1 for all 1≤ i≤ n,1≤ j ≤ m.\nThe following algorithms are to check whether φ holds on a pointed uncertainty map M ,s by Definition 4.3. The main algorithm (Algorithm 3) recursively calls itself for each non-trivial subformula of φ . The complex cases are for the subformulas in the form of 〈π〉φ and Kφ . By Definition 4.3, to check M ,s σ 〈π〉φ , we need to make sure that there exists a sequence ω ∈L (π) and a state t ∈S such that s\nωσ→ t and M , t σr(ω) φ . Since π is star-free, |ω| ≤ |π| for each ω ∈L (π). It is clear that we cannot compute and store the whole set of L (π) within polynomial space. Instead, one by one we generate all the possible sequences that are shorter than |π| and are formed from the alphabet of π (cf. line 14), and check whether they are in L (π). We can order the possible sequences lexicographically according to an ordering of the basic actions and tests in Sig, and compute the next sequence merely from the current one using function next. memb chec(ω,π) checks whether it is the case ω ∈L (π). If ω ∈L (π), we need to check whether there exists s j ∈SM such that s\nωσ→ s j (Algorithm 2) and M ,s j σr(ω) φ , where r(ω) is the test-free subsequence of ω which is easy to compute. For the case of Kφ , we need to calculate the state set U |σ (Algorithm 1)."
    }, {
      "heading" : "B Complexity analysis",
      "text" : "We suppose |SM |= n and |φ |= k. Algorithm 1 uses one variable A to record the uncertainty set which requires O(n) space. Note that there is a mutual recursion in Algorithm 2 and 3, but the depth of the overall recursion is bounded by k. In Algorithm 2, the variable consuming the most of the space is the matrix Bn×n recording the (intermediate) relation. Since σ and ω are also variables in the main algorithm and |ω|+ |σ | ≤ k due to the construction in Algorithm 3, the space usage of Algorithm 2 before the recursive calls of PW and MC is bounded by O(k+n2). For Algorithm 3, the most space-demanding part is the 〈π〉φ case, where we need to store π , Sig, and keep track one ω and one state s in the loop, which are bounded by either k or s. Moreover, according to [20], the complexity of memb chec is NLOGSPACEcomplete in the size of Sig, i.e., the alphabet of π which is bounded again by k. Thus before calling MC and PW again in the 〈π〉φ case, the space requirement is at most linear in both k and n, which is less demanding than PW for each recursion. Recall that the overall recursion depth of MC (and PW ) is bounded by k thus the space usage of the whole algorithm is bounded by O(k(k+n2)) = O(k2 + kn2).\nAlgorithm 1: Function CNU(U ,σ): Calculate the the new uncertainty set U |σ\ninput : U , σ output: BU | σ\nn\n1 A← BUn ; 2 for i← 1 to |σ | do 3 A← A×Bσ [i]n×n; 4 return A;\nAlgorithm 2: Function PW (ω,σ): Calculate the binary relation ωσ→ input : computation sequence ω , action sequence σ output: Bn×n\n1 switch ωσ do 2 case εσ return Matrix({(s,s) | s ∈S }) /* Matrix(R) is the (0,1)-matrix representation of the binary relation R */; 3 case (?φω ′)σ return Matrix({(s,s) |MC(M ,s,σ ,φ) = true })× PW(ω ′,σ ) ; 4 case (aω ′)σ return Ban×n× PW(ω ′,σa) ;\nAlgorithm 3: Function MC(M ,s,σ ,φ): Model checking algorithm for EPDL− (Boolean cases omitted)\ninput : The pointed uncertainty map (M ,s), sequence of actions σ , φ ∈ EPDL−. output: true if M ,s σ φ .\n1 switch φ do 2 case 〈π〉ϕ 3 Let Sig be the array consisting of atomic programs and formulas in π ordered according to their first appearances; 4 ω ← Sig[1] /* ω is the candidate sequence we want to test */; 5 while |ω| ≤ |π| do 6 if memb chec(ω,π) then 7 for i = 1 to SM do 8 if (s,si) ∈ PW (ω,σ) then 9 if MC(M ,s j,σr(ω),ϕ) then return true ;\n10 ω ← next(ω,Sig) /* calculate the next sequence lexicographically according to the order Sig */;\n11 return false; 12 case Kϕ 13 B U |σ n = CNU(U ,σ) /* calculate the vector representation of U |σ */ 14 for m = 1 to |SM | do 15 if (BU | σ\nn )m = 1 and MC(M ,sm,σ ,ϕ) = false then return false ; 16 return true;"
    } ],
    "references" : [ {
      "title" : "DEL-sequents for regression and epistemic planning",
      "author" : [ "Guillaume Aucher" ],
      "venue" : "Journal of Applied Non- Classical Logics",
      "citeRegEx" : "3",
      "shortCiteRegEx" : "3",
      "year" : 2012
    }, {
      "title" : "Undecidability in Epistemic Planning",
      "author" : [ "Guillaume Aucher", "Thomas Bolander" ],
      "venue" : "In: IJCAI,",
      "citeRegEx" : "4",
      "shortCiteRegEx" : "4",
      "year" : 2013
    }, {
      "title" : "All PSPACE-Complete Planning Problems Are Equal but Some Are More Equal than Others",
      "author" : [ "Christer Bäckström", "Peter Jonsson" ],
      "venue" : "SOCS",
      "citeRegEx" : "5",
      "shortCiteRegEx" : "5",
      "year" : 2011
    }, {
      "title" : "Epistemic planning for single and multi-agent systems",
      "author" : [ "Thomas Bolander", "M. Birkegaard Andersen" ],
      "venue" : "Journal of Applied Non-Classical Logics",
      "citeRegEx" : "7",
      "shortCiteRegEx" : "7",
      "year" : 2011
    }, {
      "title" : "Conformant plans and beyond: Principles and complexity",
      "author" : [ "Blai Bonet" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "8",
      "shortCiteRegEx" : "8",
      "year" : 2010
    }, {
      "title" : "Planning with Incomplete Information as Heuristic Search in Belief Space",
      "author" : [ "Blai Bonet", "Hector Geffner" ],
      "venue" : "ICAPS",
      "citeRegEx" : "9",
      "shortCiteRegEx" : "9",
      "year" : 2000
    }, {
      "title" : "Width and Complexity of Belief Tracking in Non-Deterministic Conformant and Contingent Planning",
      "author" : [ "Blai Bonet", "Hector Geffner" ],
      "venue" : "AAAI",
      "citeRegEx" : "10",
      "shortCiteRegEx" : "10",
      "year" : 2012
    }, {
      "title" : "Conformant Planning via Heuristic Forward Search: A New Approach",
      "author" : [ "Ronen I. Brafman", "Jörg Hoffmann" ],
      "venue" : "ICAPS",
      "citeRegEx" : "11",
      "shortCiteRegEx" : "11",
      "year" : 2004
    }, {
      "title" : "Planning Graph Heuristics for Belief Space Search",
      "author" : [ "Daniel Bryce", "Subbarao Kambhampati", "David E. Smith" ],
      "venue" : "Journal of Artificial Intelligence Research",
      "citeRegEx" : "12",
      "shortCiteRegEx" : "12",
      "year" : 2006
    }, {
      "title" : "Conformant Planning via Symbolic Model Checking",
      "author" : [ "Alessandro Cimatti", "Marco Roveri" ],
      "venue" : "Journal of Artificial Intelligence Research",
      "citeRegEx" : "13",
      "shortCiteRegEx" : "13",
      "year" : 2000
    }, {
      "title" : "Conformant Planning via Symbolic Model Checking",
      "author" : [ "Alessandro Cimatti", "Marco Roveri" ],
      "venue" : "CoRR abs/1106.0252",
      "citeRegEx" : "14",
      "shortCiteRegEx" : "14",
      "year" : 2011
    }, {
      "title" : "Conformant planning via symbolic model checking and heuristic search",
      "author" : [ "Alessandro Cimatti", "Marco Roveri", "Piergiorgio Bertoli" ],
      "venue" : "Artificial Intelligence",
      "citeRegEx" : "15",
      "shortCiteRegEx" : "15",
      "year" : 2004
    }, {
      "title" : "Dynamic epistemic logic. Springer, doi:10.1007/978-1-4020-5839-4",
      "author" : [ "Hans van Ditmarsch", "Wiebe van der Hoek", "Barteld Kooi" ],
      "venue" : null,
      "citeRegEx" : "16",
      "shortCiteRegEx" : "16",
      "year" : 2007
    }, {
      "title" : "Y",
      "author" : [ "R. Fagin", "J. Halpern" ],
      "venue" : "Moses & M. Vardi ",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Y",
      "author" : [ "R. Fagin", "J.Y. Halpern" ],
      "venue" : "Moses & M. Y. Vardi ",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Some Results on the Complexity of Planning with Incomplete Information",
      "author" : [ "Patrik Haslum", "Peter Jonsson" ],
      "venue" : "ECP",
      "citeRegEx" : "19",
      "shortCiteRegEx" : "19",
      "year" : 1999
    }, {
      "title" : "A note on the space complexity of some decision problems for finite automata",
      "author" : [ "Tao Jiang", "B. Ravikumar" ],
      "venue" : "Information Processing Letters",
      "citeRegEx" : "20",
      "shortCiteRegEx" : "20",
      "year" : 1991
    }, {
      "title" : "Knowledge-Based Programs as Plans - The Complexity of Plan Verification",
      "author" : [ "Jérôme Lang", "Bruno Zanuttini" ],
      "venue" : "ECAI",
      "citeRegEx" : "22",
      "shortCiteRegEx" : "22",
      "year" : 2012
    }, {
      "title" : "Model checking propositional dynamic logic with all extras",
      "author" : [ "Martin Lange" ],
      "venue" : "Journal of Applied Logic",
      "citeRegEx" : "23",
      "shortCiteRegEx" : "23",
      "year" : 2006
    }, {
      "title" : "DEL planning and some tractable cases",
      "author" : [ "Benedikt Löwe", "Eric Pacuit", "Andreas Witzel" ],
      "venue" : "LORI",
      "citeRegEx" : "24",
      "shortCiteRegEx" : "24",
      "year" : 2011
    }, {
      "title" : "Compiling Uncertainty Away: Solving Conformant Planning Problems using a Classical Planner (Sometimes)",
      "author" : [ "Héctor Palacios", "Hector Geffner" ],
      "venue" : "AAAI",
      "citeRegEx" : "25",
      "shortCiteRegEx" : "25",
      "year" : 2006
    }, {
      "title" : "Strong Planning in the Logics of Communication and Change",
      "author" : [ "Pere Pardo", "Mehrnoosh Sadrzadeh" ],
      "venue" : "Declarative Agent Languages and Technologies X,",
      "citeRegEx" : "26",
      "shortCiteRegEx" : "26",
      "year" : 2013
    }, {
      "title" : "Distributed Processes and the Logic of Knowledge",
      "author" : [ "Rohit. Parikh", "R. Ramanujam" ],
      "venue" : "Proceedings of Conference on Logic of Programs,",
      "citeRegEx" : "27",
      "shortCiteRegEx" : "27",
      "year" : 1985
    }, {
      "title" : "The Complexity of Temporal Logic Model Checking",
      "author" : [ "Philippe Schnoebelen" ],
      "venue" : "AiML",
      "citeRegEx" : "28",
      "shortCiteRegEx" : "28",
      "year" : 2003
    }, {
      "title" : "Word problems requiring exponential time (Preliminary Report)",
      "author" : [ "Larry J Stockmeyer", "Albert R Meyer" ],
      "venue" : "STOC 1973, ACM,",
      "citeRegEx" : "30",
      "shortCiteRegEx" : "30",
      "year" : 1973
    }, {
      "title" : "A New Approach to Conformant Planning Using CNF",
      "author" : [ "Son Thanh To", "Tran Cao Son", "Enrico Pontelli" ],
      "venue" : "ICAPS",
      "citeRegEx" : "31",
      "shortCiteRegEx" : "31",
      "year" : 2010
    }, {
      "title" : "On axiomatizations of public announcement logic",
      "author" : [ "Yanjing Wang", "Qinxiang Cao" ],
      "venue" : "Synthese 190,",
      "citeRegEx" : "32",
      "shortCiteRegEx" : "32",
      "year" : 2013
    }, {
      "title" : "Not All Those Who Wander Are Lost: Dynamic Epistemic Reasoning in Navigation",
      "author" : [ "Yanjing Wang", "Yanjun Li" ],
      "venue" : "AiML",
      "citeRegEx" : "33",
      "shortCiteRegEx" : "33",
      "year" : 2012
    } ],
    "referenceMentions" : [ {
      "referenceID" : 27,
      "context" : "∗Corresponding author 1It is a variant of the running example in [33].",
      "startOffset" : 65,
      "endOffset" : 69
    }, {
      "referenceID" : 4,
      "context" : "2In many other cases, feedbacks may be just too ‘expensive’ to obtain during a plan aiming for quick actions [8].",
      "startOffset" : 109,
      "endOffset" : 112
    }, {
      "referenceID" : 5,
      "context" : "As discussed in [9, 25], conformant planning can be reduced to classical planning, the planning problem without any initial uncertainty, over the space of belief states.",
      "startOffset" : 16,
      "endOffset" : 23
    }, {
      "referenceID" : 20,
      "context" : "As discussed in [9, 25], conformant planning can be reduced to classical planning, the planning problem without any initial uncertainty, over the space of belief states.",
      "startOffset" : 16,
      "endOffset" : 23
    }, {
      "referenceID" : 15,
      "context" : "The complexity of checking the existence of a conformant plan is EXPSPACE-complete in the size of the variables generating the state space [19].",
      "startOffset" : 139,
      "endOffset" : 143
    }, {
      "referenceID" : 9,
      "context" : "In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.",
      "startOffset" : 107,
      "endOffset" : 119
    }, {
      "referenceID" : 11,
      "context" : "In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.",
      "startOffset" : 107,
      "endOffset" : 119
    }, {
      "referenceID" : 10,
      "context" : "In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.",
      "startOffset" : 107,
      "endOffset" : 119
    }, {
      "referenceID" : 25,
      "context" : "In the literature, people proposed compact and implicit representations of the belief spaces, such as OBDD [13, 15, 14] and CNF [31], and different heuristics are used to guide the search for a plan, e.",
      "startOffset" : 128,
      "endOffset" : 132
    }, {
      "referenceID" : 7,
      "context" : ", [11, 12].",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 8,
      "context" : ", [11, 12].",
      "startOffset" : 2,
      "endOffset" : 10
    }, {
      "referenceID" : 12,
      "context" : ", [16]).",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 3,
      "context" : ", [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 19,
      "context" : ", [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 0,
      "context" : ", [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 21,
      "context" : ", [7, 24, 2, 3, 34, 26]), while the traditional AI planning focuses on the single-agent case.",
      "startOffset" : 2,
      "endOffset" : 23
    }, {
      "referenceID" : 3,
      "context" : "However, this expressiveness comes at a price, as shown in [7, 4], that multi-agent epistemic planning is undecidable in general.",
      "startOffset" : 59,
      "endOffset" : 65
    }, {
      "referenceID" : 1,
      "context" : "However, this expressiveness comes at a price, as shown in [7, 4], that multi-agent epistemic planning is undecidable in general.",
      "startOffset" : 59,
      "endOffset" : 65
    }, {
      "referenceID" : 3,
      "context" : "Many interesting decidable fragments are found in the literature [7, 24, 34, 1], which suggests that the single-agent cases and restrictions on the form of event models are the key to decidability.",
      "startOffset" : 65,
      "endOffset" : 79
    }, {
      "referenceID" : 19,
      "context" : "Many interesting decidable fragments are found in the literature [7, 24, 34, 1], which suggests that the single-agent cases and restrictions on the form of event models are the key to decidability.",
      "startOffset" : 65,
      "endOffset" : 79
    }, {
      "referenceID" : 27,
      "context" : "Our formal framework is based on the logic proposed by Wang and Li in [33], where the model is simply a transition system with initial uncertainty as in the motivating example, and an action is interpreted in the semantics as an update on the uncertainty of the agent.",
      "startOffset" : 70,
      "endOffset" : 74
    }, {
      "referenceID" : 14,
      "context" : "4 • The plans can be specified as regular expressions with tests in terms of arbitrary EPDL formulas, which generalizes the knowledge-based programs in [18, 22].",
      "startOffset" : 152,
      "endOffset" : 160
    }, {
      "referenceID" : 17,
      "context" : "4 • The plans can be specified as regular expressions with tests in terms of arbitrary EPDL formulas, which generalizes the knowledge-based programs in [18, 22].",
      "startOffset" : 152,
      "endOffset" : 160
    }, {
      "referenceID" : 13,
      "context" : "• Our logical language and models are very simple compared to the standard action-model based DEL approach, yet we can encode the externally given executability of the actions in the model, inspired by epistemic temporal logic (ETL) [17, 27].",
      "startOffset" : 233,
      "endOffset" : 241
    }, {
      "referenceID" : 22,
      "context" : "• Our logical language and models are very simple compared to the standard action-model based DEL approach, yet we can encode the externally given executability of the actions in the model, inspired by epistemic temporal logic (ETL) [17, 27].",
      "startOffset" : 233,
      "endOffset" : 241
    }, {
      "referenceID" : 27,
      "context" : "To talk about the knowledge of the agent during an execution of a plan, we use the following language proposed in [33].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 27,
      "context" : "Note that here we differ from [33] where the updated uncertainty set is further",
      "startOffset" : 30,
      "endOffset" : 34
    }, {
      "referenceID" : 27,
      "context" : "Following the axioms proposed in [33], we give the following axiomatization for EALw.",
      "startOffset" : 33,
      "endOffset" : 37
    }, {
      "referenceID" : 26,
      "context" : "[32]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 27,
      "context" : "Note that since we do not assume that the agent can observe the available actions, the axiom OBS(a) : K〈a〉>∨K¬〈a〉> in [33] is abandoned.",
      "startOffset" : 118,
      "endOffset" : 122
    }, {
      "referenceID" : 27,
      "context" : "We show the completeness of SELA using a more direct proof strategy compared to the one used in [33].",
      "startOffset" : 96,
      "endOffset" : 100
    }, {
      "referenceID" : 24,
      "context" : "QBF (even in prenex normal form based on a conjunctive normal form) is true or not is known to be PSPACE-complete [30].",
      "startOffset" : 114,
      "endOffset" : 118
    }, {
      "referenceID" : 23,
      "context" : "Our method is inspired by [28] which discusses the complexity of model checking temporal logics with past operators.",
      "startOffset" : 26,
      "endOffset" : 30
    }, {
      "referenceID" : 26,
      "context" : "Similar idea appeared in [32] to give an alternative semantics of public announcement logic.",
      "startOffset" : 25,
      "endOffset" : 29
    }, {
      "referenceID" : 16,
      "context" : "Note that in this way, we can use the space repeatedly, and the membership testing of L (π) is not expensive (NLOGSPACE-complete according to [20]).",
      "startOffset" : 142,
      "endOffset" : 146
    }, {
      "referenceID" : 18,
      "context" : "By modifying the algorithm for PDL in [23], we can get an algorithm to check EPDL formula φ on N • w.",
      "startOffset" : 38,
      "endOffset" : 42
    }, {
      "referenceID" : 4,
      "context" : "In terms of the size of explicit transition systems, our above result is consistent with the EXPSPACE complexity result in the AI literature for conformant planning with Boolean and modal goals [21, 8].",
      "startOffset" : 194,
      "endOffset" : 201
    }, {
      "referenceID" : 27,
      "context" : "In fact, observational power about the availability of the actions has been already incorporated in [33], which can be extended to general feedbacks discussed in the literature of contingent planning (cf.",
      "startOffset" : 100,
      "endOffset" : 104
    }, {
      "referenceID" : 6,
      "context" : ", [10]).",
      "startOffset" : 2,
      "endOffset" : 6
    }, {
      "referenceID" : 2,
      "context" : "We will then see clearly how the form of the goal formula, the constructor of the plan, and the observational ability matter in the theoretical and practical complexity of planning, in line with the research pioneered in [5].",
      "startOffset" : 221,
      "endOffset" : 224
    } ],
    "year" : 2016,
    "abstractText" : "In this paper, we introduce a lightweight dynamic epistemic logical framework for automated planning under initial uncertainty. We reduce plan verification and conformant planning to model checking problems of our logic. We show that the model checking problem of the iteration-free fragment is PSPACE-complete. By using two non-standard (but equivalent) semantics, we give novel model checking algorithms to the full language and the iteration-free language.",
    "creator" : "LaTeX with hyperref package"
  }
}