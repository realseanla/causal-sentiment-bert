{
  "name" : "1603.09545.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Characterizing Realizability in Abstract Argumentation",
    "authors" : [ "Thomas Linsbichler", "Hannes Strass" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n60 3.\n09 54\n5v 1\n[ cs\n.A I]\n3 1\nM ar\n2 01"
    }, {
      "heading" : "1 Introduction",
      "text" : "The abstract argumentation frameworks (AFs) introduced by Dung (1995) have garnered increasing attention in the recent past. In his seminal paper, Dung showed how an abstract notion of argument (seen as an atomic entity) and the notion of individual attacks between arguments together could reconstruct several established KR formalisms in argumentative terms. Despite the generality of those and many more results in the field that was sparked by that paper, researchers also noticed that the restriction to individual attacks is often overly limiting, and devised extensions and generalizations of Dung’s frameworks: directions included generalizing individual attacks to collective attacks (Nielsen and Parsons, 2006), leading to so-called SETAFs; others started offering a support relation between arguments (Cayrol and LagasquieSchiex, 2005), preferences among arguments (Amgoud and Cayrol, 2002; Modgil, 2009), or attacks on attacks into arbitrary depth (Baroni et al., 2011). This is only the tip of an iceberg, for a more comprehensive overview we refer to the work of Brewka, Polberg, and Woltran (2014).\n∗This research has been supported by DFG (project BR 1817/7- 1) and FWF (projects I1102 and P25518).\nOne of the most recent and most comprehensive generalizations of AFs has been presented by Brewka and Woltran (2010) (and later continued by Brewka et al., 2013) in the form of abstract dialectical frameworks (ADFs). These ADFs offer any type of link between arguments: individual attacks (as in AFs), collective attacks (as in SETAFs), and individual and collective support, to name only a few. This generality is achieved through so-called acceptance conditions associated to each statement. Roughly, the meaning of relationships between arguments is not fixed in ADFs, but is specified by the user for each argument in the form of Boolean functions (acceptance functions) on the argument’s parents. However, this generality comes with a price: Strass and Wallner (2015) found that the complexity of the associated reasoning problems of ADFs is in general higher than in AFs (one level up in the polynomial hierarchy). Fortunately, the subclass of bipolar ADFs (defined by Brewka and Woltran, 2010) is as complex as AFs (for all considered semantics) while still offering a wide range of modeling capacities (Strass and Wallner, 2015). However, there has only been little concerted effort so far to exactly analyze and compare the expressiveness of the abovementioned languages.\nThis paper is about exactly analyzing means of expression for argumentation formalisms. Instead of motivating expressiveness in natural language and showing examples that some formalisms seem to be able to express but others do not, we tackle the problem in a formal way. We use a precise mathematical definition of expressiveness: a set of interpretations is realizable by a formalism under a semantics if and only if there exists a knowledge base of the formalism whose semantics is exactly the given set of interpretations. Studying realizability in AFs has been started by Dunne et al. (2013, 2015), who analyzed realizability for extensionbased semantics, that is, interpretations represented by sets where arguments are either accepted (in the extension set) or not accepted (not in the extension set). While their initial work disregarded arguments that are never accepted, there have been continuations where the existence of such “invisible” arguments is ruled out (Baumann et al., 2014; Linsbichler, Spanring, and Woltran, 2015). Dyrkolbotn (2014) began to analyze realizability for labeling-based semantics of AFs, that is, three-valued semantics where arguments can be accepted (mapped to true), rejected (mapped to false) or neither (mapped to unknown). Strass (2015) started to ana-\nlyze the relative expressiveness of two-valued semantics for ADFs (relative with respect to related formalisms). Most recently, Pührer (2015) presented precise characterizations of realizability for ADFs under several three-valued semantics, namely admissible, grounded, complete, and preferred. The term “precise characterizations” means that he gave necessary and sufficient conditions for an interpretation set to be ADF-realizable under a semantics.\nThe present paper continues this line of work by lifting it to a much more general setting. We combine the works of Dunne et al. (2015), Pührer (2015), and Strass (2015) into a unifying framework, and at the same time extend them to formalisms and semantics not considered in the respective papers: we treat several formalisms, namely AFs, SETAFs, and (B)ADFs, while the previous works all used different approaches and techniques. This is possible because all of these formalisms can be seen as subclasses of ADFs that are obtained by suitably restricting the acceptance conditions.\nAnother important feature of our framework is that we uniformly use three-valued interpretations as the underlying model theory. In particular, this means that arguments cannot be “invisible” any more since the underlying vocabulary of arguments is always implicit in each interpretation. Technically, we always assume a fixed underlying vocabulary and consider our results parametric in that vocabulary. In contrast, for example, Dyrkolbotn (2014) presents a construction for realizability that introduces new arguments into the realizing knowledge base; we do not allow that. While sometimes the introduction of new arguments can make sense, for example if new information becomes available about a domain or a debate, it is not sensible in general, as these new arguments would be purely technical with an unclear dialectical meaning. Moreover, it would lead to a different notion of realizability, where most of the realizability problems would be significantly easier, if not trivial.\nThe paper proceeds as follows. We begin with recalling and introducing the basis and basics of our work – the formalisms we analyze and the methodology with which we analyze them. Next we introduce our general framework for realizability; the major novelty is our consistent use of so-called characterization functions, firstly introduced by Pührer (2015), which we adapt to further semantics. The main workhorse of our approach will be a parametric propagate-and-guess algorithm for deciding whether a given interpretation set is realizable in a formalism under a semantics. We then analyze the relative expressiveness of the considered formalisms, presenting several new results that we obtained using an implementation of our framework. We conclude with a discussion."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "We make use of standard mathematical concepts like functions and partially ordered sets. For a function f : X → Y we denote the update of f with a pair (x, y) ∈ X × Y by f |xy : X → Y with z 7→ y if z = x, and z 7→ f(z) otherwise. For a function f : X → Y and y ∈ Y , its preimage is f−1(y) = {x ∈ X | f(x) = y}. A partially ordered set is a pair (S,⊑) with ⊑ a partial order on S. A partially ordered set (S,⊑) is a complete lattice if and only if every\nS′ ⊆ S has both a greatest lower bound (glb) d S′ ∈ S and a least upper bound (lub) ⊔\nS′ ∈ S. A partially ordered set (S,⊑) is a complete meet-semilattice iff every non-empty subset S′ ⊆ S has a greatest lower bound d S′ ∈ S (the meet) and every ascending chain C ⊆ S has a least upper bound ⊔ C ∈ S.\nThree-Valued Interpretations Let A be a fixed finite set of statements. An interpretation is a mapping v : A → {t, f ,u} that assigns one of the truth values true (t), false (f ) or unknown (u) to each statement. An interpretation is two-valued if v(A) ⊆ {t, f}, that is, the truth value u is not assigned. Two-valued interpretations v can be extended to assign truth values v(ϕ) ∈ {t, f} to propositional formulas ϕ as usual.\nThe three truth values are partially ordered according to their information content: we have u <i t and u <i f and no other pair in <i, which intuitively means that the classical truth values contain more information than the truth value unknown. As usual, we denote by ≤i the partial order associated to the strict partial order <i. The pair ({t, f ,u} ,≤i) forms a complete meet-semilattice with the information meet operation ⊓i. This meet can intuitively be interpreted as consensus and assigns t ⊓i t = t, f ⊓i f = f , and returns u otherwise.\nThe information ordering ≤i extends in a straightforward way to interpretations v1, v2 over A in that v1 ≤i v2 iff v1(a) ≤i v2(a) for all a ∈ A. We say for two interpretations v1, v2 that v2 extends v1 iff v1 ≤i v2. The set V of all interpretations over A forms a complete meet-semilattice with respect to the information ordering ≤i. The consensus meet operation ⊓i of this semilattice is given by (v1 ⊓i v2)(a) = v1(a) ⊓i v2(a) for all a ∈ A. The least element of (V ,≤i) is the valuation vu : A → {u} mapping all statements to unknown – the least informative interpretation. By V2 we denote the set of two-valued interpretations; they are the ≤i-maximal elements of the meet-semilattice (V ,≤i). We denote by [v]2 the set of all two-valued interpretations that extend v. The elements of [v]2 form an ≤iantichain with greatest lower bound v = d i[v]2.\nAbstract Argumentation Formalisms An abstract dialectical framework (ADF) is a tuple D = (A,L,C) where A is a set of statements (representing positions one can take or not take in a debate), L ⊆ A×A is a set of links (representing dependencies between the positions), C = {Ca}a∈A is a collection of functions Ca : 2par(a) → {t, f}, one for each statement a ∈ A. The function Ca is the acceptance condition of a and expresses whether a can be accepted, given the acceptance status of its parents par(a) = {b ∈ S | (b, a) ∈ L}. We usually represent each Ca by a propositional formulaϕa over par(a). To specify an acceptance condition, then, we takeCa(M ∩ par (a)) = t to hold iff M is a model for ϕa.\nBrewka and Woltran (2010) introduced a useful subclass of ADFs: an ADF D = (A,L,C) is bipolar iff all links in L are supporting or attacking (or both). A link (b, a) ∈ L is supporting in D iff for all M ⊆ par (a), we have that Ca(M) = t implies Ca(M ∪ {b}) = t. Symmetrically, a link (b, a) ∈ L is attacking in D iff for all M ⊆ par(a), we\nhave that Ca(M ∪ {b}) = t implies Ca(M) = t. If a link (b, a) is both supporting and attacking then b has no actual influence on a. (But the link does not violate bipolarity.) We write BADFs as D = (A,L+ ∪ L−, C) and mean that L+ contains all supporting links and L− all attacking links. The semantics of ADFs can be defined using an operator ΓD over three-valued interpretations (Brewka and Woltran, 2010; Brewka et al., 2013). For an ADF D and a threevalued interpretation v, the interpretation ΓD(v) is given by\na 7→ d\ni {w(ϕa) | w ∈ [v]2}\nThat is, for each statement a, the operator returns the consensus truth value for its acceptance formula ϕa, where the consensus takes into account all possible two-valued interpretations w that extend the input valuation v. If this v is two-valued, we get [v]2 = {v} and thus ΓD(v)(a) = v(ϕa).\nThe standard semantics of ADFs are now defined as follows. For ADF D, an interpretation v : A → {t, f ,u} is\n• admissible iff v ≤i ΓD(v);\n• complete iff ΓD(v) = v;\n• preferred iff it is ≤i-maximal admissible;\n• a two-valued model iff it is two-valued and ΓD(v) = v.\nWe denote the sets of interpretations that are admissible, complete, preferred, and two-valued models by adm(D), com(D), prf (D) and mod(D), respectively. These definitions are proper generalizations of Dung’s notions for AFs: For an AF (A,R), where R ⊆ A × A is the attack relation, the ADF associated to (A,R) is D(A,R) = (A,R,C) with C = {ϕa}a∈A and ϕa = ∧\nb:(b,a)∈R ¬b for all a ∈ A. AFs inherit their semantics from the definitions for ADFs (Brewka et al., 2013, Theorems 2 and 4). In particular, an interpretation is stable for an AF (A,R) if and only if it is a two-valued model of D(A,R).\nA SETAF is a pair S = (A,X)whereX ⊆ (2A \\ {∅})× A is the (set) attack relation. We define three-valued counterparts of the semantics introduced by Nielsen and Parsons (2006), following the same conventions as in three-valued semantics of AFs (Caminada and Gabbay, 2009) and argumentation formalisms in general. Given a statement a ∈ A and an interpretation v we say that a is acceptable wrt. v if ∀(B, a) ∈ X∃a′ ∈ B : v(a′) = f and a is unacceptable wrt. v if ∃(B, a) ∈ X∀a′ ∈ B : v(a′) = t. For an interpretation v : A → {t, f ,u} it holds that\n• v ∈ adm(S) iff for all a ∈ A, a is acceptable wrt. v if v(a) = t and a is unacceptable wrt. v if v(a) = f ;\n• v ∈ com(S) iff for all a ∈ A, a is acceptable wrt. v iff v(a) = t and a is unacceptable wrt. v iff v(a) = f ;\n• v ∈ prf (S) iff v is ≤i-maximal admissible; and\n• v ∈ mod(S) iff v ∈ adm(F ) and ∄a ∈ A : v(a) = u.\nFor a SETAF S = (A,X) the corresponding ADF DS has acceptance formulaϕa = ∧\n(B,a)∈X\n∨\na′∈B ¬a ′ for each state-\nment a ∈ A. (Polberg, 2016)\nProposition 1. For any SETAF S = (A,X) it holds that σ(S) = σ(DS), where σ ∈ {adm , com, prf ,mod}.\nProof. Given interpretation v and statement a, it holds that ΓDS (v)(a) = t iff ∀w ∈ [v]2 : w(a) = t iff ∀(B, a) ∈ X ∃a′ ∈ B : v(a′) = f iff a is acceptable wrt. v and ΓDS (v)(a) = f iff ∀w ∈ [v]2 : w(a) = f iff ∃(B, a) ∈ X ∀a′ ∈ B : v(a′) = t iff a is unacceptable wrt. v. Hence σ(S) = σ(DS) for σ ∈ {adm , com, prf ,mod}.\nRealizability A set V ⊆ V of interpretations is realizable in a formalism F under a semantics σ if and only if there exists a knowledge base kb ∈ F having exactly σ(kb) = V . Pührer (2015) characterized realizability for ADFs under various three-valued semantics. We will reuse the central notions for capturing the complete semantics in this work.\nDefinition 1 (Pührer 2015). Let V be a set of interpretations. A function f : V2 → V2 is a com-characterization of V iff: for each v ∈ V we have v ∈ V iff for each a ∈ A:\n• v(a) 6= u implies f(v2)(a) = v(a) for all v2 ∈ [v]2 and • v(a) = u implies f(v′2)(a) = t and f(v ′′ 2 )(a) = f for\nsome v′2, v ′′ 2 ∈ [v]2. N\nFrom a function of this kind we can build a corresponding ADF by the following construction. For a function f : V2 → V2, we define Df as the ADF where the acceptance formula for each statement a is given by\nϕfa = ∨\nw∈V2,\nf(w)(a)=t\nφw with φw = ∧\nw(a′)=t\na′ ∧ ∧\nw(a′)=f\n¬a′\nObserve that we have v(φw) = t iff v = w by definition. Intuitively, the acceptance condition ϕfa is constructed such that v is a model of ϕfa if and only if we find f(v)(a) = t.\nProposition 2 (Pührer 2015). Let V ⊆ V be a set of interpretations. (1) For each ADF D with com(D) = V , there is a com-characterization fD for V ; (2) for each com-characterization f : V2 → V2 for V we have com(Df ) = V .\nThe result shows that V can be realized under complete semantics if and only if there is a com-characterization for V ."
    }, {
      "heading" : "3 A General Framework for Realizability",
      "text" : "The main underlying idea of our framework is that all abstract argumentation formalisms introduced in the previous section can be viewed as subclasses of abstract dialectical frameworks. This is clear for ADFs themselves and for BADFs by definition; for AFs and SETAFs it is fairly easy to see. However, knowing that these formalisms can be recast as ADFs is not everything. To employ this knowledge for realizability, we must be able to precisely characterize the corresponding subclasses in terms of restricting the ADFs’ acceptance functions. Alas, this is also possible and paves the way for the framework we present in this section. Most importantly, we will make use of the fact that different formalisms and different semantics can be characterized modularly, that is, independently of each other.\nTowards a uniform account of realizability for ADFs under different semantics, we start with a new characterization of realizability for ADFs under admissible semantics that is based on a notion similar in spirit to com-characterizations.\nDefinition 2. Let V be a set of interpretations. A function f : V2 → V2 is an adm-characterization of V iff: for each v ∈ V we have v ∈ V iff for every a ∈ A:\n• v(a) 6= u implies f(v2)(a) = v(a) for all v2 ∈ [v]2. N\nNote that the only difference to Definition 1 is dropping the second condition related to statements with truth value u.\nProposition 3. Let V ⊆ V be a set of interpretations. (1) For each ADF D such that adm(D) = V , there is an adm-characterization fD for V ; (2) for each adm-characterization f : V2 → V2 for V we have adm(Df ) = V .\nProof. (1) We define the function fD : V2 → V2 as fD(v2)(a) = v2(ϕa) for every v2 ∈ V2 and a ∈ A where ϕa is the acceptance formula of a in D. We will show that fD is an adm-characterization for V = adm(D). Let v be an interpretation. Consider the case v ∈ adm(D) and v(a) 6= u for some a ∈ A and some v2 ∈ [v]2. From v ≤i ΓD(v) we get v2(ϕa) = v(a). By definition of fD is follows that fD(v2)(a) = v(a). Now assume v 6∈ adm(D) and consequently v 6≤i ΓD(v). There must be some a ∈ A such that v(a) 6= u and v(a) 6= ΓD(v)(a). Hence, there is some v2 ∈ [v]2 with v2(ϕa) 6= v(a) and fD(v2)(a) 6= v(a) by definition of fD. Thus, fD is an adm-characterization\n(2) Observe that for every two-valued interpretation v2 and every a ∈ A we have f(v2)(a) = v2(ϕfa). (⊆): Let v ∈ adm(Df ) be an interpretation and a ∈ A a statement such that v(a) 6= u. Let v2 be a two-valued interpretation with v2 ∈ [v]2. Since v ≤i ΓDf (v) we have v(a) = v2(ϕ f a). Therefore, by our observation it must also hold that f(v2)(a) = v(a). Thus, by Definition 2, v ∈ V . (⊇): Consider an interpretation v such that v 6∈ adm(Df ). We show that v 6∈ V . From v 6∈ adm(Df ) we get v 6≤i ΓDf (v). There must be some a ∈ A such that v(a) 6= u and v(a) 6= ΓDf (v)(a). Hence, there is some v2 ∈ [v]2 with v2(ϕ f a) 6= v(a) and consequently f(v2)(a) 6= v(a). Thus, by Definition 2 we have v 6∈ V .\nWhen listing sets of interpretations in examples, for the sake of readability we represent three-valued interpretations by sequences of truth values, tacitly assuming that the underlying vocabulary is given and has an associated total ordering. For example, for the vocabulary A = {a, b, c} we represent the interpretation {a 7→ t, b 7→ f , c 7→ u} by the sequence tfu.\nExample 1. Consider the sets V1 = {uuu, tff , ftu} and V2 = {tff , ftu} of interpretations over A = {a, b, c}. The mapping f = {ttt 7→ ftt, ttf 7→ tft, tft 7→ ttt, tff 7→ tff , ftt 7→ ftf , ftf 7→ ftt, f ft 7→ ttf , f f f 7→ ftf} is an adm-characterization for V1. Thus, the ADF Df has V1 as its admissible interpretations. Indeed, the realizing ADF has the following acceptance conditions:\nϕfa ≡ (a ∧ b ∧ ¬c) ∨ (a ∧ ¬b) ∨ (¬a ∧ ¬b ∧ c) ϕfb ≡ (a ∧ c) ∨ (¬a ∧ b) ∨ (¬a ∧ ¬b ∧ ¬c) ϕfc ≡ (a ∧ b) ∨ (¬a ∧ b ∧ ¬c) ∨ (¬b ∧ c)\nFor V2 no adm-characterization exists because uuu 6∈ V2 but the implication of Definition 2 trivially holds for a, b, and c.\nWe have seen that the construction Df for realizing under complete semantics can also be used for realizing a set V of interpretations under admissible semantics. The only difference is that we here require f to be an adm-characterization instead of a com-characterization for V . Note that admissible semantics can be characterized by properties that are easier to check than existence of an adm-characterization (see the work of Pührer, 2015). However, using the same type of characterizations for different semantics allows for a unified approach for checking realizability and constructing a realizing ADF in case one exists.\nFor realizing under the model semantics, we can likewise present an adjusted version of com-characterizations.\nDefinition 3. Let V ⊆ V be a set of interpretations. A function f : V2 → V2 is a mod -characterization of V if and only if: (1) f is defined on V (that is, V ⊆ V2) and (2) for each v ∈ V2, we have v ∈ V iff f(v) = v. N\nAs we can show, there is a one-to-one correspondence between mod -characterizations and ADF realizations.\nProposition 4. Let V ⊆ V be a set of interpretations. (1) For each ADF D such thatmod(D) = V , there is a mod - characterization fD for V ; (2) vice versa, for each mod - characterization f : V2 → V2 for V we find mod(Df ) = V .\nProof. (1) Let D be an ADF with mod(D) = V . It immediately follows that V ⊆ V2. To define fD we can use the construction in the proof of Proposition 3. It follows directly that for any v ∈ V2, we find fD(v) = v iff v ∈ V . Thus fD is a mod -characterization for V .\n(2) Let V ⊆ V2 and f : V2 → V2 be a mod - characterization of V . For any v ∈ V2 we have:\nv ∈ V ⇐⇒ v = f(v)\n⇐⇒ ∀a ∈ A : (v(a) = f(v)(a))\n⇐⇒ ∀a ∈ A : (v(a) = t ↔ f(v)(a) = t)\n⇐⇒ ∀a ∈ A : (v(a) = t ↔ (∃w ∈ V2 : f(w)(a) = t\n∧ v = w))\n⇐⇒ ∀a ∈ A : (v(a) = t ↔ (∃w ∈ V2 : f(w)(a) = t\n∧ v(φw) = t))\n⇐⇒ ∀a ∈ A :\n\n \n\nv(a) = t ↔ v\n\n \n\n∨\nw∈V2,\nf(w)(a)=t\nφw\n\n \n\n= t\n\n \n\n⇐⇒ ∀a ∈ A : v(a) = v\n\n \n\n∨\nw∈V2,\nf(w)(a)=t\nφw\n\n \n\n⇐⇒ ∀a ∈ A : v(a) = v(ϕfa) ⇐⇒ v ∈ mod(Df )\nA related result was given by Strass (2015, Proposition 10). The characterization we presented here fits into the general framework of this paper and is directly usable for our realizability algorithm. Wrapping up, the next result summarizes how ADF realizability can be captured by different types of characterizations for the semantics we considered so far.\nTheorem 5. Let V ⊆ V be a set of interpretations and consider σ ∈ {adm, com,mod}. There is an ADF D such that σ(D) = V if and only if there is a σ-characterization for V .\nThe preferred semantics of an ADF D is closely related to its admissible semantics as, by definition, the preferred interpretations of D are its ≤i-maximal admissible interpretations. As a consequence we can also describe preferred realizability in terms of adm-characterizations. We use the lattice-theoretic standard notationmax≤i V to select the ≤imaximal elements of a given set V of interpretations.\nCorollary 6. Let V ⊆ V be a set of interpretations. There is an ADF D with prf (D) = V iff there is an adm-characterization for some V ′ ⊆ V with V ⊆ V ′ and max≤i V ′ = V .\nFinally, we give a result on the complexity of deciding realizability for the mentioned formalisms and semantics.\nProposition 7. Let F ∈ {AF, SETAF,BADF,ADF} be a formalism and σ ∈ {adm , com, prf ,mod} be a semantics. The decision problem “Given a vocabulary A and a set V ⊆ V of interpretations over A, is there a kb ∈ F such that σ(kb) = V ?” can be decided in nondeterministic time that is polynomial in the size of V .1\nProof. For all considered F and σ, computing all σinterpretations of a given witness kb ∈ F can be done in time that is linear in the size of V . Comparing the result to V can also be done in linear time."
    }, {
      "heading" : "3.1 Deciding Realizability: Algorithm 1",
      "text" : "Our main algorithm for deciding realizability is a propagateand-guess algorithm in the spirit of the DPLL algorithm for deciding propositional satisfiability (Gomes et al., 2008). It is generic with respect to (1) the formalism F and (2) the semantics σ for which should be realized. To this end, the propagation part of the algorithm is kept exchangeable and will vary depending on formalism and semantics. Roughly, in the propagation step the algorithm uses the desired set V of interpretations to derive certain necessary properties of the realizing knowledge base (line 2). This is the essential part of the algorithm: the derivation rules (propagators) used there are based on characterizations of realizability with respect to formalism and semantics. Once propagation of properties has reached a fixed point (line 7), the algorithm checks whether the derived information is sufficient to construct a knowledge base. If so, the knowledge base can be constructed and returned (line 9). Otherwise (no more information can be obtained through propagation and there is not enough information to construct a knowledge base yet), the algorithm guesses another assignment for the characterization (line 11) and calls itself recursively.\nThe main data structure that Algorithm 1 operates on is a set of triples (v, a,x) consisting of a two-valued interpretation v ∈ V2, an atom a ∈ A and a truth value x ∈ {t, f}. This data structure is intended to represent the σ-characterizations introduced in Definitions 1 to 3. There,\n1We assume here that the representation of any V over A has size Θ(3|A|). There might be specific V with smaller representations, but we cannot assume any better for the general case.\nAlgorithm 1 realize(F , σ, V, F )\nInput: • a formalism F • a semantics σ for F • a set V of interpretations v : A → {t, f ,u} • a relation F ⊆ V2 ×A× {t, f}, initially empty Output: a kb ∈ F with σ(kb) = V or “no” if none exists 1: repeat 2: set F∆ := ⋃\np∈PFσ\np(V, F ) \\ F\n3: set F := F ∪ F∆ 4: if ∃v ∈ V2, ∃a ∈ A : {(v, a, t), (v, a, f)} ⊆ F then 5: return “no” 6: end if 7: until F∆ = ∅ 8: if ∀v ∈ V2, ∀a ∈ A, ∃x ∈ {t, f} : (v, a, x) ∈ F then 9: return kbFσ (F )\n10: end if 11: choose v ∈ V2, a ∈ A with (v, a, t) /∈ F , (v, a, f) /∈ F 12: if realize(F , σ, V, F ∪ {(v, a, t)}) 6= “no” then 13: return realize(F , σ, V, F ∪ {(v, a, t)}) 14: else 15: return realize(F , σ, V, F ∪ {(v, a, f)}) 16: end if\na σ-characterization is a function f : V2 → V2 from twovalued interpretations to two-valued interpretations. However, as the algorithm builds the σ-characterization step by step and there might not even be a σ-characterization in the end (because V is not realizable), we use a set F of triples (v, a,x) to be able to represent both partial and incoherent states of affairs. The σ-characterization candidate induced by F is partial if we have that for some v and a, neither (v, a, t) ∈ F nor (v, a, f) ∈ F ; likewise, the candidate is incoherent if for some v and a, both (v, a, t) ∈ F and (v, a, f) ∈ F . If F is neither partial nor incoherent, it gives rise to a unique σ-characterization that can be used to construct the knowledge base realizing the desired set of interpretations. The correspondence to the characterizationfunction is then such that f(v)(a) = x iff (v, a,x) ∈ F .\nIn our presentation of the algorithm we focused on its main features, therefore the guessing step (line 11) is completely “blind”. It is possible to use common CSP techniques, such as shaving (removing guessing possibilities that directly lead to inconsistency). Finally, we remark that the algorithm can be extended to enumerate all possible realizations of a given interpretation set – by keeping all choice points in the guessing step and thus exhaustively exploring the whole search space.\nIn the case where the constructed relation F becomes functional at some point, the algorithm returns a realizing knowledge base kbFσ (F ). For ADFs, this just means that we denote by f the σ-characterization represented by F and set kbADFσ (F ) = D\nf . For the remaining formalisms we will introduce the respective constructions in later subsections.\nThe algorithm is parametric in two dimensions, namely with respect to the formalism F and with respect to the semantics σ. These two aspects come into the algorithm via\nmod = {p ∈ mod , p /∈ mod , p mod}).\nso-called propagators. A propagator is a formalism-specific or semantics-specific set of derivation rules. Given a set V of desired interpretations and a partial σ-characterization F , a propagator p derives new triples (v, a,x) that must necessarily be part of any total σ-characterization f for V such that f extends F . In the following, we present semantics propagators for admissible, complete and two-valued model (in (SET)AF terms stable) semantics, and formalism propagators for BADFs, AFs, and SETAFs."
    }, {
      "heading" : "3.2 Semantics Propagators",
      "text" : "These propagators (cf. Figure 1) are directly derived from the properties of σ-characterizations presented in Definitions 1 to 3. While the definitions provide exact conditions to check whether a given function is a σ-characterization, the propagators allow us to derive definite values of partial characterizations that are necessary to fulfill the conditions for being a σ-characterization.\nFor admissible semantics, the condition for a function f to be an adm-characterization of a desired set of interpretations V (cf. Definition 2) can be split into a condition for desired interpretations v ∈ V and two conditions for undesired interpretations v /∈ V . Propagator p∈adm derives new triples by considering interpretations v ∈ V . Here, for all twovalued interpretations v2 that extend v, the value f(v2) has to be in accordance with v on v’s Boolean part, that is, the algorithm adds (v2, a, v(a)) whenever v(a) 6= u. On the other hand, p/∈adm derives new triples for v /∈ V in order to ensure that there is a two-valued interpretation v2 extending v where f(v2) differs from v on a Boolean value of v. Note that while p∈adm immediately allows us to derive information about F for each desired interpretation v ∈ V , propagator p/∈adm is much weaker in the sense that it only derives a triple of F if there is no other way to meet the conditions for an undesired interpretation. Special treatment is required for the interpretation vu that maps all statements to u and is admissible for every ADF. This is not captured by p∈adm and p/∈adm as these deal only with interpretations that have Boolean mappings. Thus, propagator p adm serves to check whether vu ∈ V . If this is not the case, the propagator immediately makes the relation F incoherent and the algorithm\ncorrectly answers “no”. For complete semantics and interpretations v ∈ V , propagator p∈,tfcom derives triples just like in the admissible case. Propagator p∈,ucom deals with statements a ∈ A having v(a) = u for which there have to be at least two v2, v ′ 2 ∈ [v]2 having f(v2)(a) = t and f(v ′ 2)(a) = f . Hence p∈,ucom derives triple (v2, a,¬x) if for all other v ′ 2 ∈ [v]2 we find a triple (v′2, a,x). For interpretations v /∈ V it must hold that there is some a ∈ A such that (i) v(a) 6= u and f(v2)(a) 6= v(a) for some v2 ∈ [v]2 or (ii) v(a) = u but for all v2 ∈ [v]2, f(v2) assigns the same Boolean truth value x to a. Now if neither (i) nor (ii) can be fulfilled by any statement b ∈ A \\ {a} due to the current contents of F , propagators p 6∈,tfcom and p 6∈,u com derive triple (v2, a,¬v(a)) for v(a) 6= u if needed for a to fulfill (i) and (v2, a,¬x) for v(a) = u if needed for a to fulfill (ii), respectively.\nExample 2. Consider the set V3 = {uuu, fuu,uuf , ftf}. First, we consider a run of realize(ADF, adm , V3, ∅). In the first iteration, propagator p∈adm ensures that F∆ in line 2 contains (f f f , a, f), (ftf , a, f), (ftf , c, f), and (f f f , c, f). Based on the latter three tuples and fuf /∈ V3, propagator p/∈adm derives (f f f , a, t) in the second iteration which together with (f f f , a, f) causes the algorithm to return “no”. Consequently, V3 is not adm-realizable. A run of realize(ADF, com , V3, ∅) on the other hand returns comcharacterization f for V3 that maps ttf to tff , ftt to f ft, ftf and f f f to ftf and all other v2 ∈ V2 to f f f . Hence, ADF Df , given by the acceptance conditions\nϕfa = a ∧ b ∧ ¬c, ϕ f c = ¬a ∧ b ∧ c, ϕfb = (¬a ∧ b¬ ∧ ¬c) ∨ (¬a ∧ ¬b ∧ ¬c)\nhas V3 as its complete semantics.\nFinally, for two-valued model semantics, propagator p∈mod derives new triples by looking at interpretations v ∈ V . For those, we must find f(v) = v in each mod -characterization f by definition. Thus the algorithm adds (v, a, v(a)) for each a ∈ A to the partial characterization F . Propagator p/∈mod looks at interpretations v ∈ V2 \\ V , for which it must hold that f(v) 6= v. Thus there must be a statement a ∈ A with v(a) 6= f(v)(a), which is exactly what this propagator\nAlgorithm 2 realizePrf (F , V )\nInput: • a formalism F • a set V of interpretations v : A → {t, f ,u} Output: Return some kb ∈ F with prf (kb) = V if one exists or “no” otherwise.\n1: if max≤i V 6= V then 2: return “no” 3: end if 4: set V < := {v ∈ V | ∃v′ ∈ V : v <i v′} 5: set X := ∅ 6: repeat 7: choose V ′ ⊆ V < with V ′ /∈ X 8: set X := X ∪ {V ′} 9: set V adm := V ∪ V ′\n10: if realize(F , adm , V adm , ∅) 6= “no” then 11: return realize(F , adm , V adm , ∅) 12: end if 13: until ∀V ′ ⊆ V < : V ′ ∈ X 14: return “no”\nderives whenever it is clear that there is only one statement candidate left. This, in turn, is the case whenever all b ∈ A with the opposite truth value ¬v(a) and all c ∈ A with c 6= a cannot coherently become the necessary witness any more. The propagator p mod checks whether V ⊆ V2, that is, the desired set of interpretations consists entirely of two-valued interpretations. In that case this propagator makes the relation F incoherent, following a similar strategy as p adm .\nPreferred Semantics Realizing a given set of interpretations V under preferred semantics requires special treatment. We do not have a σ-characterization function for σ = prf at hand to directly check realizability of V but have to find some V ′ ⊆ {v ∈ V | ∃v′ ∈ V : v <i v′} such that V ∪ V ′ is realizable under admissible semantics (cf. Corollary 6). Algorithm 2 implements this idea by guessing such a V ′ (line 7) and then using Algorithm 1 to try to realize V ∪ V ′ under admissible semantics (line 11). If realize returns a knowledge base kb realizing V ∪ V ′ under adm we can directly use kb as solution of realizePrf since it holds that prf (kb) = V , given that V is an ≤i-antichain (line 2)."
    }, {
      "heading" : "3.3 Formalism Propagators",
      "text" : "When constructing an ADF realizing a given set V of interpretations under a semantics σ, the function kbADFσ (F ) makes use of the σ-characterization given by F in the following way: v is a model of the acceptance condition ϕa if and only if we find (v, a, t) ∈ F . Now as bipolar ADFs, SETAFs and AFs are all subclasses of ADFs by restricting the acceptance conditions of statements, these restrictions also carry over to the σ-characterizations. The propagators defined below use structural knowledge on the form of acceptance conditions of the respective formalisms to reduce the search space or to induce incoherence of F whenever V is not realizable.\nBipolar ADFs For bipolar ADFs, we use the fact that each of their links must have at least one polarity, that is, must\nbe supporting or attacking. Therefore, if a link is not supporting, it must be attacking, and vice versa. For canonical realization, we obtain the polarities of links, i.e. the sets L+ and L−, as defined in Figure 2.\nAFs To explain the AF propagators, we first need some more definitions. On the two classical truth values, we define the truth ordering f <t t, whence the operations ⊔t and ⊓t with f ⊔t t = t and f ⊓t t = f result. These operations can be lifted pointwise to two-valued interpretations as usual, that is, (v1 ⊔t v2)(a) = v1(a) ⊔t v2(a) and (v1 ⊓t v2)(a) = v1(a) ⊓t v2(a). Again, the reflexive version of <t is denoted by ≤t. The pair (V2,≤t) of twovalued interpretations ordered by the truth ordering forms a complete lattice with glb ⊓t and lub ⊔t. This complete lattice has the least element vf : A → {f}, the interpretation mapping all statements to false, and the greatest element vt : A → {t} mapping all statements to true, respectively.\nAcceptance conditions of AF-based ADFs have the form of conjunctions of negative literals. In the complete lattice (V2,≤t), the model sets of AF acceptance conditions correspond to the lattice-theoretic concept of an ideal, a subset of V2 that is downward-closed with respect to ≤t and upwardclosed with respect to ⊔t. The propagator directly implements these closure properties: application of pAF ensures that when a σ-characterization F that is neither incoherent nor partial is found in line 8 of Algorithm 1, then there is, for each a ∈ A, an interpretation va such that (va, a, t) ∈ F and v ≤t va for each (v, a, t) ∈ F . Hence va is crucial for the acceptance condition, or in AF terms the attacks, of a and we can define kbAFσ (F ) = (A, {(b, a) | a, b ∈ A, va(b) = f}).\nSETAFs The propagator for SETAFs, pSETAF, is a weaker version of that of AFs, since we cannot presume upwardclosure with respect to ⊔t. In SETAF-based ADFs the acceptance formula is in conjunctive normal form containing only negative literals. By a transformation preserving logical equivalence we obtain an acceptance condition in disjunctive normal form, again with only negative literals; in other words, a disjunction of AF acceptance formulas. Thus, the model set of a SETAF acceptance condition is not necessarily an ideal, but a union of ideals. For the canonical realization we can make use of the fact that, for each a ∈ A, the set V ta = {v ∈ V2 | (v, a, t) ∈ F} is downward-closed with respect to ≤t, hence the set of models of ∨\nv∈max≤t V t\n∧\nv(b)=f ¬b is exactly V t a . The clauses\nof its corresponding CNF-formula exactly coincide with the sets of arguments attacking a in kbSETAFσ (F )."
    }, {
      "heading" : "3.4 Correctness",
      "text" : "For a lack of space, we could not include a formal proof of soundness and completeness of Algorithm 1, but rather present arguments for termination and correctness.\nTermination With each recursive call, the set F can never decrease in size, as the only changes to F are adding the results of propagation in line 3 and adding the guesses in line 11. Also within the until-loop, the set F can never decrease in size; furthermore there is only an overall finite number of triples that can be added to F . Thus at some point\nσ ∪ { pF } with pF as defined above. L+ and L− define link polarities for kbBADFσ .\nwe must have F∆ = ∅ and leave the until-loop. Since F always increases in size, at some point it must either become functional or incoherent, whence the algorithm terminates.\nSoundness If the algorithm returns a realizing knowledge base kbFσ (F ), then according to the condition in line 8 the relation F induced a total function f : V2 → V2. In particular, because the until-loop must have been run through at least once, there was at least one propagation step (line 2). Since the propagators are defined such that they enforce everything that must hold in a σ-characterization, we conclude that the induced function f indeed is a σ-characterization for V . By construction, we consequently find that σ(kbFσ (F )) = V .\nCompleteness If the algorithm answers “no”, then the execution reached line 5. Thus, for the constructed set F , there must have been an interpretation v ∈ V2 and a statement a ∈ A such that {(v, a, t), (v, a, f)} ⊆ F , that is, F is incoherent. Since F is initially empty, the only way it could get incoherent is in the propagation step in line 2. (The guessing step cannot create incoherence, since exactly one truth value is guessed for v and a.) However, the propagators are defined such that they infer only assignments (triples) that are necessary for the given F . Consequently, the given interpretation set V is such that either there is no realization within the ADF fragment corresponding to formalism F (that is, the formalism propagator derived the incoherence) or there is no σ-characterization for V with respect to general ADFs (that is, the semantics propagator derived the incoherence). In any case, V is not σ-realizable for F ."
    }, {
      "heading" : "4 Implementation",
      "text" : "As Algorithm 1 is based on propagation, guessing, and checking it is perfectly suited for an implementation using answer set programming (ASP) (Niemelä, 1999; Marek and Truszczyński, 1999) as this allows for exploiting conflict learning strategies and heuristics of modern ASP solvers. Thus, we developed ASP encodings in the Gringo language (Gebser et al., 2012) for our approach. Similar as the algorithm, our declarative encodings are modular, consisting of a main part responsible for constructing set F and separate encodings for the individual propagators. If one wants, e.g., to compute an AF realization under admissible semantics for a set V of interpretations, an input program encoding V is joined with the main encoding, the propagator encoding for admissible semantics as well as the propagator encoding for AFs. Every answer set of such a program encodes a respective characterization function. Our ASP encoding for preferred semantics is based on the admissible encoding and guesses further interpretations following the\nessential idea of Algorithm 2. For constructing a knowledge base with the desired semantics, we also provide two ASP encodings that transform the output to an ADF in the syntax of the DIAMOND tool (Ellmauthaler and Strass, 2014), respectively an AF in ASPARTIX syntax (Egly, Gaggl, and Woltran, 2010; Gaggl et al., 2015). Both argumentation tools are based on ASP themselves. The encodings for all the semantics and formalisms we covered in the paper can be downloaded from http://www.dbai.tuwien.ac. at/research/project/adf/unreal/. A selection of them is depicted in Figure 3 on the next page."
    }, {
      "heading" : "5 Expressiveness Results",
      "text" : "In this section we briefly present some results that we have obtained using our implementation. We first introduce some necessary notation to describe the relative expressiveness of knowledge representation formalisms (Gogic et al., 1995; Strass, 2015). For formalisms F1 and F2 with semantics σ1 and σ2, we say that F2 under σ2 is at least as expressive as F1 under σ1 and write F σ1 1 ≤e F σ2 2 if and only if Σσ1F1 ⊆ Σ σ2 F2\n, where ΣσF = {σ(kb) | kb ∈ F} is the signature of F under σ. As usual, we define F1 <e F2 iff F1 ≤e F2 and F2 6≤e F1.\nWe now start by considering the signatures of AFs, SETAFs and (B)ADFs for the unary vocabulary {a}:\nΣadmAF = Σ adm SETAF = {{u} , {u, t}} ΣcomAF = Σ com SETAF = {{u} , {t}}\nΣprfAF = Σ prf SETAF = {{u} , {t}}\nΣmodAF = Σ mod SETAF = {∅, {t}}\nΣadmADF = Σ adm BADF = Σ adm AF ∪ {{u, f} , {u, t, f}} ΣcomADF = Σ com BADF = Σ com AF ∪ {{f} , {u, t, f}}\nΣprfADF = Σ prf BADF = Σ prf AF ∪ {{f} , {t, f}}\nΣmodADF = Σ mod BADF = Σ mod AF ∪ {{f} , {t, f}}\nThe following result shows that the expressiveness of the formalisms under consideration is in line with the amount of restrictions they impose on acceptance formulas.\nTheorem 8. For any σ ∈ {adm , com , prf ,mod}:\n1. AFσ <e SETAF σ . 2. SETAFσ <e BADF σ . 3. BADFσ <e ADF σ . Proof. (1) AFσ ≤e SETAF σ is clear (by modeling individual attacks via singletons). For SETAFσ 6≤e AF σ the witnessing model sets over vocabulary A = {a, b, c} are {uuu, ttf , tft, ftt} ∈ ΣσSETAF \\ Σ σ AF and {ttf , tft, ftt} ∈\nΣτSETAF \\ Σ τ AF with σ ∈ {adm, com} and τ ∈ {prf ,mod}. By each pair of arguments of A being t in at least one model, a realizing AF cannot feature any attack, immediately giving rise to the model ttt. The respective realizing SETAF is given by the attack relation R = {({a, b}, c), ({a, c}, b), ({b, c}, a)}.\n(2) It is clear that SETAFσ ≤e BADF σ holds (all parents are always attacking). For BADFσ 6≤e SETAF σ the respective counterexamples can be read off the signatures above: for σ ∈ {adm , com} we find {u, t, f} ∈ ΣσBADF \\ Σ σ SETAF and for τ ∈ {prf ,mod} we find {t, f} ∈ ΣτBADF \\Σ τ SETAF.\n(3) For σ = mod the result is known (Strass, 2015, Theorem 14); for the remaining semantics the model sets witnessing ADFσ 6≤e BADF σ over vocabulary A = {a, b} are\n{uu, tu, tt, tf , fu} ∈ ΣadmADF \\ Σ adm BADF {uu, tu, tt, tf , fu} ∈ ΣcomADF \\ Σ com BADF\n{tt, tf , fu} ∈ ΣprfADF \\ Σ prf BADF\nA witnessing ADF is given by ϕa = a and ϕb = a ↔ b.\nTheorem 8 is concerned with the relative expressiveness of the formalisms under consideration, given a certain semantics. Considering different semantics we find that for all formalisms the signatures become incomparable:\nProposition 9. Fσ11 6≤e F σ2 2 and F σ2 2 6≤e F σ1 1 for all formalisms F1,F2 ∈ {AF, SETAF,BADF,ADF} and all semantics σ1, σ2 ∈ {adm , com, prf ,mod} with σ1 6= σ2.\nProof. First, the result for adm and com follows by {u, t} ∈ ΣadmAF , but {u, t} /∈ Σ com ADF and {t} ∈ Σ com AF , but {t} /∈ ΣadmADF . Moreover, taking into account that the set of preferred interpretations (resp. two-valued models) always forms a ≤i-antichain while the set of admissible (resp. complete) interpretations never does, the result follows for σ1 ∈ {adm, com} and σ2 ∈ {prf ,mod}. Finally, since a kb ∈ F may not have any two-valued models and a preferred interpretation is not necessarily two-valued, the result for prf and mod follows.\nDisregarding the possibility of realizing the empty set of interpretations under the two-valued model semantics, we\nobtain the following relation for ADFs.\nProposition 10. (ΣmodADF \\ {∅}) ⊆ Σ prf ADF.\nProof. Consider some V ∈ ΣmodADF with V 6= ∅. Clearly V ⊆ V2 and by Proposition 4 there is a mod - characterization f : V2 → V2 for V , that is, f(v) = v iff v ∈ V . Define f ′ : V2 → V2 such that f ′(v) = f(v) = v for all v ∈ V and f ′(v)(a) = ¬v(a) for all v ∈ V \\ V and a ∈ A. Now it holds that f ′ is an adm-characterization of V ′ = {v ∈ V | ∀v2 ∈ [v]2 : v2 ∈ V } ∪ {vu}. Since max≤i V\n′ = V we get that the ADF D with acceptance formula ϕf ′\na for each a ∈ A has prf (D) = V whence V ∈ ΣprfADF.\nIn contrast, this relation does not hold for AFs, which was shown for extension-based semantics by Linsbichler, Spanring, and Woltran (2015) (Theorem 5) and immediately follows for the three-valued case."
    }, {
      "heading" : "6 Discussion",
      "text" : "We presented a framework for realizability in which AFs, SETAFs, BADFs and general ADFs can be treated in a uniform way. The centerpiece of our approach is an algorithm for deciding realizability of a given interpretation-set in a formalism under a semantics. The algorithm makes use of so-called propagators, by which it can be adapted to the different formalisms and semantics. We also presented an implementation of our framework in answer set programming and several novel expressiveness results that we obtained using our implementation. In related work, Polberg (2016) studies a wide range of abstract argumentation formalisms, in particular their relationship with ADFs. This can be the basis for including further formalisms into our realizability framework: all that remains to do is figuring out suitable ADF fragments and developing propagators for them, just like we did exemplarily for Nielsen and Parsons’s SETAFs. For further future work, we could also streamline existing propagators such that they do not only derive absolutely necessary assignments, but also logically weaker conclusions, such as disjunctions of (non-)assignments."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2016,
    "abstractText" : "Realizability for knowledge representation formalisms studies the following question: Given a semantics and a set of interpretations, is there a knowledge base whose semantics coincides exactly with the given interpretation set? We introduce a general framework for analyzing realizability in abstract dialectical frameworks (ADFs) and various of its subclasses. In particular, the framework applies to Dung argumentation frameworks, SETAFs by Nielsen and Parsons, and bipolar ADFs. We present a uniform characterization method for the admissible, complete, preferred and model/stable semantics. We employ this method to devise an algorithm that decides realizability for the mentioned formalisms and semantics; moreover the algorithm allows for constructing a desired knowledge base whenever one exists. The algorithm is built in a modular way and thus easily extensible to new formalisms and semantics. We have also implemented our approach in answer set programming, and used the implementation to obtain several novel results on the relative expressiveness of the abovementioned formalisms.",
    "creator" : "dvips(k) 5.991 Copyright 2011 Radical Eye Software"
  }
}