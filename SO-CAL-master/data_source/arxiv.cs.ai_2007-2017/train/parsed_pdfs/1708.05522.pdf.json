{
  "name" : "1708.05522.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Exploring Directional Path-Consistency for Solving Constraint Networks",
    "authors" : [ "Shufeng Kong", "Sanjiang Li", "Michael Sioutis" ],
    "emails" : [ "michael.sioutis@oru.se" ],
    "sections" : [ {
      "heading" : null,
      "text" : "We then present a simple variant of the DPC algorithm, called DPC∗, and show that the CSP of a constraint language can be decided by DPC∗ if it is closed under a majority operation. In fact, DPC∗ is sufficient for guaranteeing backtrack-free search for such constraint networks. Examples of majority-closed constraint classes include the classes of connected row-convex (CRC) constraints and tree-preserving constraints, which have found applications in various domains, such as scene labeling, temporal reasoning, geometric reasoning, and logical filtering. Our experimental evaluations show that DPC∗ significantly outperforms the state-of-the-art algorithms for solving majority-closed constraints.\nKeywords: Path-consistency; directional path-consistency; constraint networks"
    }, {
      "heading" : "1 Introduction",
      "text" : "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26]. A constraint network comprises a set of variables ranging over some domain of possible values, and a set of constraints that specify allowed value combinations for these variables. Solving a constraint network amounts to assigning values to its variables such that its constraints are satisfied. Backtracking search is the principal mechanism for solving a constraint network; it assigns values to variables in a depth-first manner, and backtracks to the previous variable assignment if there are no consistent values for the variable at hand. Local consistency techniques are commonly used to reduce the size of the search space before commencing search. However, searching for a complete solution for a constraint network is still hard. In fact, even deciding whether the constraint network has a solution is NP-complete in general. Therefore, given a particular ar X iv :1\n70 8.\n05 52\n2v 1\n[ cs\n.A I]\n1 8\nA ug\n2 01\n7\nform of local consistency, a crucial task is to determine problems that can be solved by backtrack-free search using that local consistency [17].\nThis paper considers a particular form of local consistency, called path-consistency (PC), which is one of the most important and heavily studied local consistencies in the literature (see e.g. [27,29,32,6,10]). Recently, it was shown that PC can be used to decide the satisfiability of a problem if and only if the problem does not have the ability to count [2,1]; however, it remains unclear whether backtrack-free search can be used to extract a solution for such a problem after enforcing PC.\nDirectional path-consistency (DPC) [15] is a weaker notion of PC that considers a given variable ordering and can thus be enforced more efficiently than PC. The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33]. It is then natural to ask what binary constraint networks with finite domains can be solved by DPC. Dechter and Pearl [15] showed that DPC is sufficient for enabling backtrack-free search for networks with constraint graphs of regular width 2. We consider the aforementioned question in the context of constraint languages, which is a widely adopted approach in the study of tractability of constraint satisfaction problems [8]. Specifically, we are interested in finding all binary constraint languages Γ such that the consistency of any constraint network defined over Γ can be decided by DPC.\nTo this end, we first exploit the close connection between DPC and variable elimination by defining constraint languages that have the (weak) variable elimination property (VEP) (which will become clear in Definition 6). We call a constraint language Γ complete if it contains all relations that are definable in Γ (in the sense of Definition 3). Then, we show that the constraint satisfaction problem (CSP) of a complete constraint language Γ can be decided by DPC if it is complete and has VEP, which is shown to be equivalent to the Helly property. However, we also show that no complete VEP constraint language can have a domain with more than 2 values.\nWe then present a simple variant of the algorithm DPC, called DPC∗, and show that the consistency of a constraint network can be decided by DPC∗ if it is defined over any majority-closed constraint language. In fact, we show that DPC∗ is sufficient for guaranteeing backtrack-free search for such constraint networks. Several important constraint classes have been found to be majority-closed. The most well-known one is the class of connected row-convex (CRC) constraints [16], which is further generalized to a larger class of tree-preserving constraints [20]. The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20]. We also conduct experimental evaluations to compare DPC∗ to the state-of-the-art algorithms for solving majority-closed constraints, and show that DPC∗ significantly outperforms the latter algorithms.\nThe remainder of this paper is organized as follows. In Section 2 we introduce basic notions and results that will be used throughout the paper. In Section 3 we present the DPC algorithm, and in Section 4 we discuss the connection between DPC and variable elimination. In Section 5 we prove that a complete constraint language Γ has weak VEP if and only if Γ is majority-closed. We then present in Section 6 our variable\nelimination algorithm DPC∗, and empirically evaluate DPC∗ in Section 7. Finally, Section 8 concludes the paper."
    }, {
      "heading" : "2 Preliminaries",
      "text" : "This section recalls necessary notions and results.\nDefinition 1. A binary constraint network (BCN) N is a triple 〈V,D, C〉, where\n– V = {v1, . . . , vn} is a nonempy finite set of variables; – D = {D1, . . . , Dn}, where Di is the domain of vi; – C = {(sp, Rp) | 1 ≤ p ≤ m} is a set of binary constraints, where sp = (vi, vj)(i 6= j) (called the scope of (sp, Rp)) is a pair of variables in V and Rp (called the constraint relation of (sp, Rp)) is a subset of Di ×Dj .\nGiven a BCN N = 〈V,D, C〉 and any pair of variables (vi, vj) with vi, vj ∈ V and vi 6= vj , we assume that there exists at most one constraint between the pair. For simplicity, we will often denote the constraint between vi and vj by Rij . Further, we assume Rij = R−1ji , which is the inverse of Rji. We write Rij ∈ C throughout the paper to state that a constraint with scope (vi, vj) is in C. Usual operations on relations such as intersection (∩), composition (◦), and inverse (−1) are also assumed.\nA partial solution of N w.r.t. a subset V ′ of V is an assignment of values to variables in V ′ such that all of the constraints Rij with vi, vj ∈ V ′ are satisfied. A partial solution w.r.t. V is called a solution ofN . We say thatN is consistent or satisfiable if it admits a solution, and inconsistent or unsatisfiable otherwise. A BCN N = 〈V,D, C〉 is said to be globally consistent if every partial solution w.r.t. V ′ ⊆ V can be consistently extended to a solution w.r.t. V . Further,N is said to be trivially inconsistent if C contains an empty constraint orD contains an empty domain. Two BCNs are equivalent if they have the same set of solutions.\nExample 1. Consider a BCN N = 〈V,D, C〉, where\n– V = {v1, v2, v3, v4}; – Di = {a, b, c} for i = 1, 2, 3, 4; – C = {R12, R23, R34, R24} where\nR12 = 1 1 11 1 0 1 0 0 , R34 = 1 1 11 0 0 1 0 0 , and R32 = R24 = 1 1 10 1 1 0 0 1 . We use Boolean matrices to represent binary relations. For example, R12 represents the relation {〈a, a〉, 〈a, b〉, 〈a, c〉, 〈b, a〉, 〈b, b〉, 〈c, a〉} between v1 and v2, where the values in both D1 and D2 are ordered as a ≺ b ≺ c. It is easy to check that σ = 〈a, a, a, a〉 is a solution of N .\nThe constraint graph GN of N = 〈V,D, C〉 is the undirected graph (V,E), where eij ∈ E iff Rij ∈ C. We assume eij is always labeled with its corresponding constraint Rij . Fig. 1 shows the constraint graph of the BCN in Example 1.\nAn undirected graph G is triangulated or chordal if every cycle of length greater than 3 has a chord, i.e., an edge connecting two non-consecutive vertices of the cycle. The constraint graphGN of a networkN = 〈V,D, C〉 can be completed or triangulated by adding new edges eij labeled with the universal constraint Di ×Dj .\nTriangulated graphs play a key role in efficiently solving large sparse constraint networks [6,31,33]. A graphG is triangulated iff it admits a perfect elimination ordering (PEO) [18]. An ordering ≺ of the vertices of a graph G = (V,E) is a PEO if Fv = {w | (v, w) ∈ E, v ≺ w} for all of v ∈ V , i.e., the set of successors of v in the ordering induces a complete subgraph of G (see Fig. 1 for an example).\nA variable vi is arc-consistent (AC) relative to a variable vj (or Rij) if for any a ∈ Di we have some b ∈ Dj such that 〈a, b〉 ∈ Rij . Given a constraint graph GN = (V,E), an edge eij ofGN is AC if vi is AC relative to vj . Let π = (v0, · · · , vi, · · · , vk) be a path inGN with e0k ∈ E. We say that π is path-consistent (PC) if for all 〈c0, ck〉 ∈ R0k we can find values for all intermediate variables vi (0 < i < k) such that all the constraints Ri,i+1 (0 ≤ i < k) are satisfied. See Fig. 2 for an illustration. In particular, (v0, v2) is PC relative to a third vertex v1 if e01, e12, and e02 are all in E and the path π = (v0, v1, v2) is PC. A constraint graph GN is AC (resp. PC) iff all edges (resp. paths) in GN are AC (resp. PC); GN is strongly PC iff it is both AC and PC. A constraint network N is AC if GN is AC and N is PC if the competition of GN is PC [6].\nConsider the BCN N in Example 1. We can see that every edges in GN is AC, but the path π = (v3, v2, v4) is not PC as R34 is not contained in R32 ◦R24.\nIn this paper we are concerned with BCNs defined over a particular constraint language and we use constraint languages, constraint classes and sets of relations interchangeably.\nDefinition 2. [19] Let D = {D1, . . . , Dn} be a set of domains. An n-ary relation R overD is a subset ofD1× . . .×Dn. For any tuple t ∈ R and any 1 ≤ i ≤ n, we denote by t[i] the value in the i-th coordinate position of t and write t as 〈t[1], . . . , t[n]〉.\nDefinition 3. [19] Given a set of binary relations Γ , we write Γ+ for the set of relations that can be obtained from Γ using some sequence of the following operations:\n– Cartesian product, i.e., for R1, R2 ∈ Γ,R1 ×R2 = {〈t1, t2〉 | t1 ∈ R1, t2 ∈ R2}, – equality selection, i.e., for R ∈ Γ, τi=j(R) = {t ∈ R | t[i] = t[j]}, and – projection, i.e., for R ∈ Γ, πi1,··· ,ik(R) = {〈t[i1], · · · , t[ik]〉 | t ∈ R}.\nA relation R is said to be definable in Γ if R ∈ Γ+, and a set of binary relations Γ is said to be complete if every binary relation definable in Γ is also contained in Γ . The completion of Γ , written as Γ c, is the set of all binary relations contained in Γ+.\nThe following lemma asserts that a complete set of binary relations Γ is closed under the operations that are used to achieve PC and AC.\nLemma 1. [11] Let Γ be a complete set of binary relations over a domainD. Suppose R,S are binary relations and T a unary relation, all in Γ . Then R ∩ S, R ◦ S, and T ′ = {a ∈ D | 〈a, b〉 ∈ R, b ∈ T} are also all in Γ .\nLet Γ be a set of binary relations. A BCN N = 〈V,D, C〉 is defined over (or, simply, over) Γ if R ∈ Γ for every constraint (s,R) in C. The constraint satisfaction problem (CSP) of Γ , denoted by CSP(Γ ), is the problem of deciding the consistency of BCNs defined over Γ . CSP(Γ+) is log-space reducible to CSP(Γ ) [11].\nA set of binary relations Γ is weakly closed under singletons, if {〈a, b〉} ∈ Γ+ for any R ∈ Γ and any 〈a, b〉 ∈ R.\nIn this paper we often assume that the constraint languages are complete and weakly closed under singletons. We will see that this is not very restrictive as, for any set Γ of binary relations that is closed under a majority operation ϕ, the completion Γ c of Γ is also closed under ϕ [19] and weakly closed under singletons (cf. Proposition 4)."
    }, {
      "heading" : "3 The Strong Directional PC Algorithm",
      "text" : "This section recalls the notions of directional arc-consistency (DAC) and directional path-consistency (DPC), and the strong DPC enforcing algorithm of Dechter and Pearl [13].\nDefinition 4. [13] Let N = 〈V,D, C〉 be a BCN and ≺= (v1, . . . , vn) an ordering of the variables in V . We say that N is directionally arc-consistent (DAC) relative to ≺ if vi is arc-consistent relative to vk for all k > i with Rik ∈ C. Similarly, N is directionally path-consistent (DPC) relative to≺ if, for any i 6= j withRij ∈ C, (vi, vj) is path-consistent relative to vk for all k > i, j whenever Rik, Rjk ∈ C. Meanwhile, N is strongly DPC relative to ≺ if it is both DAC and DPC relative to ≺.\nAlgorithm 1: DPC Input : A binary constraint networkN = 〈V,D, C〉;\nan ordering ≺ = (v1, . . . , vn) on V . Output: An equivalent subnetwork that is strongly DPC relative to ≺, or “Inconsistent”.\n1 for k ← n to 1 do 2 for i < k with Rik ∈ C do 3 Di ← Di ∩Rki(Dk); 4 if Di = ∅ then 5 return “Inconsistent”\n6 for i, j < k with Rik, Rjk ∈ C do 7 if Rij 6∈ C then 8 Rij ← Di ×Dj ; 9 C ← C ∪ {Rij};\n10 Rij ← Rij ∩ (Rik ◦Rkj); 11 if Rij = ∅ then 12 return “Inconsistent”;\n13 returnN .\nThe strong DPC algorithm is presented as Algorithm 1. In comparison with traditional PC algorithms [10], a novelty of this single pass algorithm is its explicit reference to the constraint graph of the input constraint network. As only Line 8 may require extra working space, Algorithm 1 has a very low space complexity in practice. Further, Algorithm 1 runs inO(w∗(≺) ·e · (α+β)) time [13], where e is the number of edges of the output constraint graph, w∗(≺) is the induced width of the ordered graph along ≺, and α, β are the runtimes of relational intersection and composition respectively. Note that w∗(≺) ≤ n and α, β are bounded by O(d), where d is the largest domain size.\nProposition 1. [13] Let (N ,≺) be an input to Algorithm 1, where ≺ = (v1, . . . , vn). Suppose N ′ = 〈V,D′, C ′〉 is the output. Then\n(i) GN ′ is triangulated and ≺−1, the inverse of ≺, is a PEO of GN ′ ; (ii) N ′ is equivalent to N and strongly DPC relative to ≺.\nLet Γ be a set of binary relations. We say that Algorithm 1 decides CSP(Γ ) if, for any given BCN N in CSP(Γ ) and any ordering ≺ of variables of N , Algorithm 1 returns “Inconsistent” iff N is inconsistent.\nThe following corollary follows directly from Proposition 1.\nCorollary 1. Let Γ be a complete set of binary relations. Then the following two conditions are equivalent:\n(i) Algorithm 1 decides CSP(Γ ). (ii) Let N be a non-trivially inconsistent BCN in CSP(Γ ). Suppose N ’s constraint\ngraph GN is triangulated and let ≺−1 = (vn, . . . , v1) be a PEO of it. Then N is consistent if N is strongly DPC relative to ≺.\nExample 2. The graph coloring problemN with domains {red, blue} depicted in Fig. 3 is taken from [13] and can be decided by Algorithm 1. After applying Algorithm 1 to (N ,≺), where ≺= (v1, v2, v3, v4), a solution can be obtained along ≺ in a backtrackfree manner (see Fig. 3b)."
    }, {
      "heading" : "4 Directional PC and Variable Elimination",
      "text" : "This section characterizes the binary constraint languages Γ such that CSP(Γ ) can be decided by DPC. We observe that DPC achieves (strong) DPC using the idea of variable elimination [13]: it iterates variables along the ordering ≺−1, and propagates the constraints of a variable vk to subsequent variables in the ordering with the update rule Rij ← Rij ∩ (Rik ◦Rkj), as if vk is ‘eliminated’.\nThe following definition formalizes the process of elimination.\nDefinition 5. LetN = 〈V,D, C〉 be a BCN with V = {v1, ..., vn} andD = {D1, ..., Dn}. For a variable vx in V , let Ex = {Rix | Rix ∈ C}. The network obtained after vx is eliminated from N , written as\nN−x = 〈V \\ {vx}, {D′1, ..., D′x−1, D′x+1, ..., D′n}, C ′〉,\nis defined as follows:\n– If Ex = {Rix}, we set C ′ = C \\ Ex and let\nD′j =\n{ Di ∩Rxi(Dx), if j = i\nDj , otherwise (1)\n– If |Ex| 6= 1, we set D′j = Dj for all j 6= x, and let\nC ′ = (C \\ Ex) ∪ {Rix ◦Rxj ∩Rij | Rjx, Rix ∈ Ex, i 6= j}.\nRij is assumed to be Di ×Dj if Rij 6∈ C. Fig. 4 illustrates the elimination process.\nDefinition 6. A BCN N = 〈V,D, C〉 is said to have the variable elimination property (VEP), if, for any vx in V , every solution of N−x can be extended to a solution of N . N is said to have weak VEP, if, for any vx in V such that vx is AC relative to all relations in Ex, every solution of N−x can be extended to a solution of N . A set of binary relations Γ is said to have (weak) VEP if every BCN in CSP(Γ )\nhas (weak) VEP. Such a set of binary relations Γ is also called a (weak) VEP class.\nIt is easy to see that, if a BCN (a set of binary relations) has VEP, then it also has weak VEP. The following example explains why we should take special care when eliminating variables with only one successor in Eq. (1).\nExample 3. Let N = 〈V,D, C〉 be a BCN defined by V = {v1, v2, v3}, D1 = D2 = D3 = {0, 1}, and C = {((v3, v2), R), ((v2, v1), R)} with R = {(1, 0)} (see Fig. 5). Suppose we do not have the operation specified in (1) and ≺ = (v3, v2, v1) is the variable elimination ordering. LetN−3 be the restriction ofN to {v1, v2}. ThenN−3 has a unique solution σ but it cannot be extended to a solution of N .\nProposition 2. Let Γ be a complete set of binary relations that is weakly closed under singletons. Then DPC decides CSP(Γ ) iff Γ has VEP.\nProof. We address the ‘if’ part first. Assume that Γ has VEP, and let N = 〈V,D, C〉 be a network in CSP(Γ ) that is non-trivially inconsistent and strongly DPC relative to\n≺= (v1, . . . , vn), where GN is triangulated and≺−1 is a PEO of it. We show thatN is consistent. Let Vi = {v1, . . . , vi} andN|Vi be the restriction ofN to Vi. We claim that N|Vi is consistent for k = 1, . . . , n and prove the claim by induction on k. First, since N is strongly DPC relative to ≺, D1 is not empty and there is an a1 ∈ D1. Then,N|V1 is consistent and has a solution σ1 = 〈a1〉. Further, suppose that N|Vi is consistent and σi = 〈a1, a2, ..., ai〉 is a solution of N|Vi . We show that σi can be extended to a solution σi+1 = 〈a1, . . . , ai, ai+1〉 of N|Vi+1 . We consider three subcases: (i) If Ei+1 is empty, then for any ai+1 ∈ Di+1, σi+1 = 〈a1, a2, ..., ai, ai+1〉 is a solution of N|Vi+1 because there is no constraint between vi and vi+1. (ii) If Ei+1 = {Rj,i+1} is a singleton, then, since N is DAC relative to ≺, we have ai+1 ∈ Di+1 such that 〈ai, ai+1〉 ∈ Ri,i+1 and σi+1 = 〈a1, a2, ..., ai, ai+1〉 is a solution of N|Vi+1 . (iii) If Ei+1 contains more than one variable, for every pair of distinct variables (vx, vy) in Vi with Rx,i+1, Ry,i+1 ∈ Ei+1, we know Rxy ∈ C because ≺−1 is a PEO of GN . Moreover, since (vx, vy) is PC relative to vi+1, we have Rxy ⊆ Rx,i+1 ◦ Ri+1,y . Then since Γ has VEP and N|Vi is indeed the same network as the one obtained by eliminating vi+1 from N|Vi+1 , by Definition 6, σi can be extended to a solution σi+1 of N|Vi+1 . Thus, N is consistent. By Corollary 1, DPC decides CSP(Γ ).\nNext, we address the ‘only if’ part. Assume that DPC decides CSP(Γ ). We show that Γ has VEP. LetN = 〈V,D, C〉 be a non-trivially inconsistent network in CSP(Γ ). Given vx ∈ V , we show that every solution ofN−x can be extended toN . Without loss of generality, we assume that x = n. Let σ = 〈a1, . . . , an−1〉 be a solution ofN−n, and En = {Rin | Rin ∈ C}. By the definition of N−n, for any Rin, Rjn ∈ En(i 6= j), we have 〈ai, aj〉 ∈ Rin ◦ Rnj ∩ Rij . We then construct a new problem N ′ = 〈V,D′, C ′〉 in CSP(Γ ), where D′ = {D′1, ..., D′n−1, Dn} with D′i = {ai} for 1 ≤ i < n and C ′ = {{〈ai, aj〉} | 1 ≤ i 6= j < n}∪En. Clearly, σ is also a solution ofN ′−n andN ′−n is strongly PC and, hence, strongly DPC relative to the ordering (v1, . . . , vn−1). Further, since 〈ai, aj〉 ∈ Rin ◦ Rnj ∩ Rij for any Rin, Rjn ∈ En(i 6= j), we have that N ′ is strong DPC relative to ≺ = (v1, . . . , vn). As GN ′−n is complete, GN ′ is triangulated with ≺−1 being a PEO of it. As DPC decides CSP(Γ ) and N ′ ∈ CSP(Γ ), by Corollary 1, N ′ is consistent and has a solution that extends σ and is also a solution of N . This shows that N is consistent and, hence, Γ has VEP. ut\nTherefore, if N = 〈V,D, C〉 is defined over a complete VEP class, then DPC can decide it. Note that in the above proposition we require Γ to be complete. This is important; for example, every row-convex constraint [3] network has VEP (cf. the proof of [34, Theorem 1]) and, hence, the class of row-convex constraints has VEP. However, DPC does not decide the consistency problem over the row-convex constraint class because it was shown to be NP-hard (cf. e.g. [20]).\nVEP is closely related to the Helly property, defined as follows.\nDefinition 7. A set Γ of binary relations over D = {D1, ..., Dn} is said to have the Helly property if for any k > 2 binary relations,Ri ⊆ Dui×Du0(1 ≤ i ≤ k, 1 ≤ ui 6= u0 ≤ n), in Γ , and for any k values, ai ∈ Dui(1 ≤ i ≤ k), such that Ri(ai) = {b ∈ Du0 | 〈ai, b〉 ∈ Ri} is nonempty, we have ⋂k i=1Ri(ai) 6= ∅ iff Ri(ai) ∩ Rj(aj) 6= ∅ for any 1 ≤ i 6= j ≤ k.\nExample 4. Let Du0 = {a, b, c, d}, Du1 = {e}, Du2 = {f}, Du3 = {g} and R1 = {〈e, a〉, 〈e, b〉, 〈e, c〉}, R2 = {〈f, b〉, 〈f, c〉, 〈f, d〉}, R3 = {〈g, c〉, 〈g, d〉, 〈g, a〉}. See Fig. 6 for an illustration. Then Γ = {R1, R2, R3} over D = {Du0 , Du1 , Du2 , Du3} has the Helly property.\nTheorem 1. A set of binary relations Γ has VEP iff it has the Helly property.\nProof. Suppose Γ has VEP, we show Γ has the Helly property. Let D = {D1, ..., Dn} be the set of domains related to relations in Γ . Suppose Ri ⊆ Dui ×Du0 (1 ≤ i ≤ k, 1 ≤ ui 6= u0 ≤ n) are k > 2 binary relations in Γ and ai ∈ Dui (1 ≤ i ≤ k) are values such that ∅ 6= Ri(ai) ⊆ Du0 . Suppose Ri(ai) ∩ Rj(aj) is nonempty for any i, j with 1 ≤ i 6= j ≤ k. We show that ⋂k i=1Ri(ai) is nonempty. To this end, we construct a BCNN = 〈V,D′, C〉 over Γ with V = {v1, ..., vk, vk+1},D′ = {Du1 , ..., Duk , Du0}, and C = {Ri,k+1 | 1 ≤ i ≤ k}, where Ri,k+1 = Ri. Consider N−(k+1). As Ri(ai) ∩ Rj(aj) 6= ∅, we have 〈ai, aj〉 ∈ Ri,k+1 ◦Rk+1,j . This shows that σ = 〈a1, . . . , ak〉 is a solution ofN−(k+1). Since Γ and, hence,N have VEP,N has a solution that extends σ. Hence there exists a ∈ Du0 such that a ∈ Ri,k+1(ai) for every 1 ≤ i ≤ k. Thus⋂k\ni=1Ri(ai) 6= ∅. This proves that Γ has the Helly property. Suppose Γ has the Helly property, we show Γ has VEP. Let N = 〈V,D, C〉 be a non-trivially inconsistent BCN defined over Γ with V = {v1, v2, ..., vn} and C is a set of binary constraints ((vi, vj), R) with R ∈ Γ . Let En = {Rin | Rin ∈ C}. Assume σ = 〈a1, a2, ..., an−1〉 is a solution of, say, N−n. We show that there exists an ∈ Dn such that 〈a1, ..., an−1, an〉 is a solution ofN . If En is empty, we can take any an from Dn which is nonempty since N is non-trivially inconsistent; if En contains only one constraint, say, ((vi, vn), Rin), by ai ∈ D′i = Di∩Rni(Dn), there exists an ∈ Dn such that 〈ai, an〉 ∈ Rin; if En contains k ≥ 2 constraints and let them be ((vui , vn), Ruin) (1 ≤ i ≤ k), we have 〈ai, aj〉 ∈ Ruiuj ∩ (Ruin ◦Rnuj ) for 1 ≤ i 6= j ≤ k. Therefore, we have Ruin(ai) ∩ Rujn(aj) 6= ∅ for 1 ≤ i 6= j ≤ k. By the Helly property of Γ , we have ⋂k i=1Ruin(ai) 6= ∅. So we can take any an ∈ ⋂k i=1Ruin(ai) so that 〈a1, . . . , an−1, an〉 is a solution of N . Therefore, Γ has VEP. ut\nThe class of row-convex constraints [3] and the class of tree-convex constraints [35] have the Helly property and, thus, they have VEP by Theorem 1.\nProposition 3. Suppose Γ is a set of binary relations that has the Helly property. Let N ∈ CSP(Γ ). Suppose N is non-trivially inconsistent and GN is triangulated with\n≺−1= (vn, . . . , v1) as a PEO of it. Then N is consistent if it is strongly DPC relative to ≺.\nProof. Let N ∈ CSP(Γ ). Suppose N = 〈V,D, C〉 is non-trivially inconsistent and GN is triangulated with ≺−1 = (vn, . . . , v1) being a PEO of it. Suppose N is strongly DPC relative to≺. We show thatN is consistent. Let Vk = {v1, . . . , vk} andNk be the restriction of N to Vk. Since N is non-trivially inconsistent, we have that N1 is consistent. Suppose Nk is consistent, we show Nk+1 is consistent. Let σ = 〈a1, . . . , ak〉 be a solution of Nk. Let Ek+1 = {Ri,k+1 | Ri,k+1 ∈ C, i ≤ k}. Since GN is triangulated and ≺−1= (vn, . . . , v1) is a PEO of it, for any two different constraints Ri,k+1, Rj,k+1 ∈ Ek+1, we haveRij ∈ C. Further, sinceN is strongly DPC relative to ≺, we have 〈ai, aj〉 ∈ Ri,k+1◦Rk+1,j∩Rij . Thus, we haveRi,k+1(ai)∩Rj,k+1(aj) 6= ∅ for any two different constraintsRi,k+1, Rj,k+1 ∈ Ek+1. Since Γ has the Helly property, we have ⋂ Ri,k+1∈Ek+1 Ri,k+1(ai) 6= ∅. Therefore, σ can be extended to a solution ofNk+1 andNk+1 is consistent. By induction on k, we have thatN is consistent. ut"
    }, {
      "heading" : "5 Majority-Closed Constraint Languages",
      "text" : "In this section we characterize weak VEP classes. We will show that a complete set of binary relations Γ has weak VEP iff all relations in Γ are closed under a majority operation, which is defined as follows.\nDefinition 8. [7] Let D = {D1, . . . , Dn} be a set of domains. A multi-sorted majority operation ϕ onD is a set {ϕ1, . . . , ϕn}, where ϕi is a one-sorted majority operation on Di, i.e., a mapping from D3i to Di such that ϕi(e, d, d) = ϕi(d, e, d) = ϕi(d, d, e) = d for all d, e in Di.\nAn m-ary relation R ⊆ Di1 × ...×Dim with i1, ..., im ∈ {1, 2, ..., n} is said to be closed under ϕ if ϕ(t1, t2, t3) = 〈ϕi1(t1[1], t2[1], t3[1]), . . . , ϕim(t1[m], t2[m], t3[m])〉 is in R for any t1, t2, t3 ∈ R.\nA set of relations Γ is said to be closed under ϕ if every R ∈ Γ is closed under ϕ.\nA set of relations Γ is called a majority-closed language if there exists a (multi-sorted) majority operation ϕ such that every relation in Γ is closed under ϕ."
    }, {
      "heading" : "5.1 Tree-Preserving Constraints",
      "text" : "The class of tree-preserving constraints is majority-closed.\nDefinition 9. [21] An undirected graph structure can often be associated to a finite domainD such that there is a bijection between the vertices in the graph and the values in D. If the graph is connected and acyclic, i.e. a tree, then we say it is a tree domain of x, denote as T = (D,E) where E is a set of edges. A constraint Rij over tree domains Ti = (Di, Ei) and Tj = (Dj , Ej) is called tree-preserving if the image of every subtree in Ti is a subtree in Tj .\nAn example of tree-preserving constraint is shown in Fig. 7. A CRC constraint is a special tree-preserving constraint where related tree domains are chains [21].\nDefinition 10. Let Ti be a nonempty tree domain for a variable vi. The standard majority operation mi on Ti is defined as:\n(∀a, b, c ∈ Ti) mi(a, b, c) = πa,b ∩ πb,c ∩ πa,c,\nwhere a, b, c are not necessarily distinct and πu,v denotes the unique path from u to v in Ti.\nThe following result establishes the connection between tree-preserving constraints and majority-closed constraints.\nTheorem 2. [21] Let Ti and Tj be two nonempty tree domains and mi and mj their standard majority operations. Suppose Rij ⊆ Ti × Tj is a nonempty constraint such that both Rij and Rji are arc-consistent. Then Rij is closed under {mi,mj} iff both Rij and Rji are tree-preserving w.r.t. Ti and Tj ."
    }, {
      "heading" : "5.2 Weak VEP Classes and Majority-Closed Classes",
      "text" : "We first study a few properties of majority-closed classes.\nProposition 4. Let Γ be the set of binary relations that is closed under a multi-sorted majority operation ϕ = {ϕ1, ..., ϕn} on D = {D1, ..., Dn}. Then Γ is weakly closed under singletons.\nProof. Suppose R is a relation in Γ and 〈a, b〉 ∈ R ⊆ Di ×Dj . We show that {〈a, b〉} is closed under ϕ. For any t1, t2, t3 ∈ {〈a, b〉}, we have t1 = t2 = t3 = 〈a, b〉, and, hence, ϕ(t1, t2, t3) = 〈ϕi(a, a, a), ϕj(b, b, b)〉 = 〈a, b〉. This shows that {〈a, b〉} is closed under ϕ and, hence, a relation in Γ . ut\nMajority-closed relations are decomposable.\nDefinition 11. An m-ary relation R is said to be r-decomposable if, for any m-tuple t, t ∈ R if πI(t) ∈ πI(R) for all I = (i1, . . . , ik) (a list of indices from {1, . . . ,m}) with k ≤ r, where πI(t) = 〈t[i1], ..., t[ik]〉 and πI(R) = {〈t[i1], ..., t[ik]〉 | t ∈ R}.\nTheorem 3. [19] Let Γ be a set of binary relations over a set of finite domains D = {D1, . . . , Dn}. The following statements are equivalent:\n(1) Γ is a majority-closed constraint language. (2) Every R ∈ Γ+ is 2-decomposable. (3) For every N ∈ CSP(Γ ), establishing strong PC in N ensures global consistency.\nFinally, we show that complete weak VEP classes are majority-closed classes.\nTheorem 4. Let Γ be a complete set of binary relations over a set of finite domains D = {D1, ..., Dn}. Then Γ has weak VEP iff it is a majority-closed class.\nProof. We first deal with the ‘only if’ part. Suppose that Γ is a complete set of binary relations that has weak VEP. By Theorem 3, we only need to show that for every BCN in CSP(Γ ), establishing strong PC ensures global consistency. LetN 0 be a network in CSP(Γ ) and suppose N = 〈V,D, C〉 is the network obtained by enforcing strong PC onN 0. Since Γ is complete and thus closed under operations for achieving AC and PC by Lemma 1,N is also a problem in CSP(Γ ). SupposeN is non-trivially inconsistent. We show that any partial solution of N can be extended to a solution of N .\nSuppose V ′ = {v1, . . . , vm−1} ⊂ V and σ = 〈a1, . . . , am−1〉 is a solution of N|V ′ , which is the restriction of N to V ′. Assume further that vm 6∈ V ′ is a new variable and let V ′′ = V ′ ∪ {vm}. We show that σ can be consistently extended to N|V ′′ , the restriction of N to V ′′. Because N is strongly PC, N|V ′′ is strongly PC as well. In particular, vi is AC relative to vm for any Rim in C, and Rij is PC relative to vm (i.e., Rij ⊆ Rim ◦ Rmj) for any i 6= j such that both Rim and Rjm are in C. By Definition 5,N|V ′ is the same as (N|V ′′)−m, viz., the network obtained by eliminating vm from N|V ′′ . Moreover, since N and, hence, N|V ′′ are AC, vm is AC relative to all constraints Rim that are in C. By the assumption that Γ has weak VEP, σ can be consistently extended to vm. Following this reasoning, we will find a solution ofN that extends σ.\nNext, we consider the ‘if’ part. Suppose that Γ is a complete set of binary relations that is closed under some multi-sorted majority operation ϕ = {ϕ1, . . . , ϕn} on D. Let N = 〈V,D, C〉 be a problem in CSP(Γ ) and vx a variable in V . Let Ex = {Rix | Rix ∈ C}, and N−x = 〈V \\ {vx},D, C ′〉, where C ′ = (C ∪ {Rix ◦ Rxj ∩ Rij | Rjx, Rix ∈ Ex}) \\ Ex. Suppose that vx is AC relative to all relations in Ex. We only need to show that any solution of N−x can be extended to a solution of N . We prove this by contradiction.\nLet σ be a solution of N−x. Assume that σ cannot be extended to a solution of N . Therefore, Ex cannot be empty, otherwise σ can be trivially extended to a solution of N . The case where Ex = {Rix} is a singleton is also impossible, as by (1), vi is AC relative to Rix and we could extend σ to a solution of N by assigning any valid value to vx. Suppose that Ex has q ≥ 2 constraints and let them be ((v1, vx), R1), . . ., ((vq, vx), Rq). We define a new problemN ′ = 〈V,D, Ex〉 as illustrated in Fig. 8. Since vx is AC relative to all relations in Ex, it is easy to verify that N ′ has a solution. For example, one can construct a solution of N ′ by simply picking a value from Dx for vx and then extending that valuation to v1, . . . , vq . Now, we construct a q-ary relation R = {〈γ(v1), . . . , γ(vq)〉 | γ is a solution of N ′}. The solution set S of N ′ can be\nobtained by using a sequence of the Cartesian product, equality selection, and projection operations [19]. Therefore, S ∈ Γ+. Since R = πv1,...,vq (S), we have R ∈ Γ+. By Theorem 3, R should be 2-decomposable; however, in the sequel we show that it is not, which is a contradiction.\nLet t = 〈σ(v1), . . . , σ(vq)〉, where σ is a solution of N−x. It is clear that t is a solution ofN ′|{v1,...,vq}. For any list of indices I chosen from {1, . . . , q}, with |I| ≤ 2, we claim that πI(t) ∈ πI(R). We recall that, for any two relations Rix, Rjx ∈ Ex, the relation between vi and vj in N−x is Rij ∩ (Rix ◦ Rxj). Therefore, any partial solution 〈σ(vi), σ(vj)〉(1 ≤ i, j ≤ q) of N ′ can be consistently extended to vx and, by the construction of N ′, further consistently extended to a solution of N ′. Thus, πI(t) is in πI(R) for any list of indices I chosen from {1, . . . , q}, with |I| ≤ 2. However, t 6∈ R because σ cannot be extended to a solution of N ′, which implies that R is not 2-decomposable. ut"
    }, {
      "heading" : "6 The Variable Elimination Algorithm DPC∗",
      "text" : "This section presents a variant of DPC for solving BCNs defined over any weak VEP class. The new algorithm, called DPC∗ and presented as Algorithm 2, can solve problems that are not solvable by DPC (cf. Example 5 and Proposition 6). Compared with the variable elimination algorithm for solving CRC constraints [34], DPC∗ enforces a weaker AC condition instead of full AC. We first justify the correctness of Algorithm 2.\nTheorem 5. Let Γ be a complete weak VEP class. Suppose N is a BCN defined over Γ and ≺= (v1, . . . , vn) any ordering of variables of N . Then, given N and ≺, Algorithm 2 does not return “Inconsistent” iff N is consistent.\nProof. Suppose the input network N is consistent. Since DPC∗ only prunes off certain infeasible domain values or relation tuples, the algorithm does not find any empty domains or relations in Lines 4, 9, and 19. Thus, it does not return “Inconsistent”.\nSuppose the algorithm does not return “Inconsistent” and let N ′ = 〈V,D′, C ′〉 be the output network, where D′ = {D′1, ..., D′n}. We show N ′ is consistent.\nWriteM(0) forN and writeM(i) for the result of the i-th loop in calling DPC∗ for the inputN and≺= (v1, v2, ..., vn). ThenN ′ =M(n−1) and allM(i) (0 ≤ i < n) are equivalent to N . Let Qk be the restriction ofM(k) to {v1, v2, ..., vn−k} (0 ≤ k < n). In essence, Qk is obtained by eliminating vn−k+1 from Qk−1 (Lines 2-5 or Lines 11- 20), while also enforcing AC (Lines 7-10) for vn−k+1 relative to all its successors if\nAlgorithm 2: DPC∗\nInput : A binary constraint networkN = 〈V,D, C〉; an ordering ≺ = (v1, . . . , vn) on V .\nOutput: An equivalent subnetwork that is decomposable relative to ≺, or “Inconsistent”. 1 for k ← n to 1 do 2 if k has only one successor and that successor is i then 3 Di ← Di ∩Rki(Dk) 4 if Di = ∅ then 5 return “Inconsistent”\n6 else 7 for i < k with Rik ∈ C do 8 Dk ← Dk ∩Rik(Di) 9 if Dk = ∅ then\n10 return “Inconsistent”\n11 for i < k with Rik ∈ C do 12 Rik ← Rik ∩ (Di ×Dk) 13 for j < i with Rjk ∈ C do 14 Rjk ← Rjk ∩ (Dj ×Dk) 15 if Rij 6∈ C then 16 Rij ← Di ×Dj 17 C ← C ∪ {Rij} 18 Rij ← Rij ∩ (Rik ◦Rkj); 19 if Rij = ∅ then 20 return “Inconsistent”\n21 returnN .\nit has more than one successor. Since Γ is a complete weak VEP class, every BCN defined over Γ has weak VEP. In particular, eachQk−1 is defined over Γ and has weak VEP. This implies that every solution of Qk can be extended to a solution of Qk−1. Since no inconsistency is detected in the process, we have D′1 6= ∅ and thus Qn−1 is consistent. By the above analysis, this implies thatQn−2, ...,Q1,Q0 =M(0) = N are all consistent. ut\nThe preceding proof also gives a way to generate all solutions of a consistent input network backtrack-free by appropriately instantiating the variables along the input ordering ≺. Indeed, for all 1 ≤ k < n, a solution 〈a1, . . . , ak〉 of N ′k can be extended to a solution 〈a1, . . . , ak+1〉 of N ′k+1 by choosing an element ak+1 from the intersection of all Ri,k+1(ai) with i ≤ k and Ri,k+1 ∈ C ′, which is always nonempty as shown in the preceding proof. As we know that if Γ is majority-closed, the completion of Γ is also majority-closed [19], and that complete majority-closed classes and complete weak VEP classes are equivalent by Theorem 4, this also proves the following result:\nProposition 5. Suppose N is a consistent BCN defined over a majority-closed class and ≺ = (v1, ..., vn) an ordering of variables ofN . Then, givenN and ≺, Algorithm 2 returns an equivalent subnetwork N ′ that is decomposable relative to ≺, i.e., any partial solution of N ′ on {v1, ..., vk} for any 1 ≤ k < n can be extended to a solution of N ′.\nNote that Lines 2-10 in DPC∗do not achieve DAC of input networks. Therefore, DPC∗ does not achieve strong DPC. Since the overall runtime of Lines 2-10 is the same as enforcing DAC, this places DPC∗ in the same time complexity class as DPC. The following example, however, gives a BCN that can be solved by DPC∗ but not by DPC, which shows that the loop in Lines 7-10 is necessary.\nExample 5. Let D = {a, b, c} and ϕ be the majority operation on D such that for all i, j, k ∈ D, ϕ(i, j, k) = a if i 6= j, j 6= k, and i 6= k, and ϕ(i, j, k) = r otherwise, where r is the repeated value (e.g., ϕ(b, c, b) = b). Let Γ = {R1, R2, R3, R4, R5, R6}, whereR1 = {〈a, a〉, 〈a, c〉},R2 = {〈c, c〉, 〈c, b〉},R3 = {〈b, b〉, 〈b, a〉},R4 = {〈a, c〉}, R5 = {〈c, b〉}, and R6 = {〈a, b〉}. Every R ∈ Γ is closed under the majority operation ϕ on D. Now, consider the constraint network N ∈ CSP(Γ ) as presented in Figure 9. Since Rxw ◦ Rwz = R6, Rxw ◦ Rwy = R4, and Ryw ◦ Rwz = R5, the eliminated network N−w is the same as the restriction of N to the set of variables {vx, vy, vz}. Let σ(vx) = a, σ(vy) = c, σ(vz) = b. Then σ is a solution of N−w, but σ cannot be extended to a solution of N . Thus, N and hence Γ do not have VEP. By Theorem 2, DPC does not decide CSP(Γ ).\nOn the other hand, since Γ is majority-closed, by Proposition 5, DPC∗ can correctly decide the consistency ofN . This observation is confirmed by calling the two algorithms onN . Take the PEO≺= (w, x, y, z) as an example; the other PEOs are analogous. Let (N ,≺) be an input to DPC. After processing w, we haveDx = {a}, Dy = {c}, Dz = {b} and Rxy = {〈a, c〉}, Rxz = {〈a, b〉}, Rzy = {b, c}. We can observe that 〈x = a, y = c, z = b〉 is a solution to the eliminated subnetwork. Thus, if we keep running DPC, it will not detect inconsistency. On the other hand, for DPC∗, when eliminating w, DPC∗ makes w AC relative to its neighbors. Note that DPC does not perform this operation. After that, Dw is empty, and the algorithm will stop and output “Inconsistent”.\nThe following result shows that complete majority-closed classes over domains with more than two elements cannot have VEP.\nProposition 6. Let ϕ = {ϕ1, . . . , ϕn} be a majority operation onD = {D1, . . . , Dn}. If there exists a domain Di in D that contains more than two elements, then the set Γϕ of binary relations that are closed under ϕ has neither the Helly property nor VEP.\nProof. Suppose a, b, c are three different values from Di. It is easy to see that the relations R1 = {〈a, a〉, 〈a, b〉}, R2 = {〈a, b〉, 〈a, c〉}, and R3 = {〈a, a〉, 〈a, c〉} are all closed under ϕ. Therefore, R1, R2, and R3 are all in Γϕ. Because any two of R1(a), R2(a), R3(a) have a common element but R1(a) ∩ R2(a) ∩ R3(a) = ∅, this shows that Γϕ does not have the Helly Property and, hence by Theorem 1, does not have VEP. ut\nThis result shows that no complete VEP class could have a domain with 3 or more values. Therefore, there are no interesting complete constraint languages except the boolean ones that can be decided by DPC (cf. Proposition 2), while all binary majority-closed classes (including CRC and tree-preserving constraints) can be decided by DPC∗ (cf. Proposition 5).\nDPC∗ can also be used to solve majority-closed constraints of higher arities. This is because, by Theorem 3, every relation definable in a majority-closed language is 2- decomposable. Therefore, for each majority relation R of arity m > 2, if a constraint c = ((y1, ..., ym), R) appears in a constraint network N , we could replace c with a set of binary constraints cij = ((yi, yj) | πij(R)) (1 ≤ i < j ≤ m), where πij(R) = {〈t[yi], t[yj ]〉 | t ∈ R}."
    }, {
      "heading" : "7 Evaluations",
      "text" : "In this section we experimentally compare algorithm DPC∗ against the state-of-the-art algorithms for solving majority-closed constraint networks. These are SAC3-SDS [4] and PC2001 [5]. SAC3-SDS is currently the best singleton arc-consistency (SAC) enforcing algorithm [12]. Enforcing either SAC1 or PC correctly decides the consistency of a majority-closed constraint network [9,19].\nTwo different sets of data are considered for experiments, which are described as follows:\n(1) Tree-preserving constraint networks. (2) Random majority-closed constraint networks. These can be used to test the aver-\nage performance of different algorithms. To generate such networks, we need to generate random majority-closed constraint languages as follows. • Randomly define a majority operation⊗i : D3i → Di for each domainDi ∈ D\nas follows: for any x, y, z ∈ Di, ⊗i(x, y, z) = {\nany v ∈ Di, if x, y, z are all different, any repeated value of x, y, z, otherwise.\n(2) 1 Singleton linear arc-consistency (SLAC) is an alternative consistency notion that can be en-\nforced to solve majority-closed constraint network [22], but no practical SLAC algorithms are available so far.\n• Randomly generate constraints Rij ⊆ Di ×Dj and test whether\n{〈⊗i(tx[1], ty[1], tz[1]),⊗j(tx[2], ty[2], tz[2])〉 | tx, ty, tz ∈ Rij} ⊆ Rij (3)\nholds. By definition, Rij is majority-closed under (⊗i,⊗j) iff (3) holds.\nWe used the model in [6,16] to generate random consistent constraint networks for experiments. These constraint networks were generated by varying four parameters: (1) the number of variables n, (2) the size of the domains d, (3) the density of the constraint networks ρ (i.e. the ratio of non-universal constraints to n2) and (4) the looseness of constraints l (i.e. the ratio of the number of allowed tuples to d2). We fix three of the four parameters and vary the remaining parameter. Experiments were carried out on a computer with an Intel Core i5-4570 processor with a 3.2 GHz frequency per CPU core, and 4 GB memory.\nThe graphs in Fig. 10 and Fig. 11 illustrate the experimental comparisons among algorithms DPC∗, SAC3-SDS and PC2001 for solving tree-preserving and random\nmajority-closed constraint networks respectively. The data points in each graph are CPU times averaged over 20 instances.\nFrom Fig. 10 and Fig. 11, we observe that all algorithms behave similarly to one another when solving tree-preserving and random majority-closed constraint networks. Therefore, our analysis only focuses on Fig. 10 and the results are applicable to Fig. 11 as well.\nWe observe in Fig. 10a and Fig. 10b that all algorithms approximately show linear time behaviors with respect to n and d. On the other hand, Fig. 10c shows that PC2001 is not sensitive to the density of networks whereas DPC∗ and SAC3-SDS perform better when the density of networks is lower. Fig. 10d shows that the CPU time for DPC∗\nremains almost unchanged when increasing the looseness of constraints. However, the CPU times for PC2001 and SAC3-SDS both go up and then drop down when increasing the looseness of constraints. Finally, we also observe in all the graphs in Fig. 10 that the performance differences among DPC∗, PC2001 and SAC3-SDS are remarkable. DPC∗\nnot only runs significantly faster than PC2001 and SAC3-SDS, but it also scales up to 7 times and 5 times better than PC2001 and SAC3-SDS respectively. This mainly owes to the fact that DPC∗ is a single pass algorithm over the ordered input constraint networks."
    }, {
      "heading" : "8 Conclusion",
      "text" : "This paper investigated which constraint satisfaction problems can be efficiently decided by enforcing directional path-consistency. Given a complete binary constraint language Γ , it turns out that DPC can decide CSP(Γ ) if Γ is defined over domains with less than three values. For a possibly incomplete binary constraint language Γ , we proved that Γ has the Helly property if, and only if, for any non-trivially inconsistent and triangulated binary constraint network N over Γ , N is consistent if it is strongly DPC relative to the inverse ordering of some perfect elimination ordering of the constraint graph of N . The classes of row-convex [3] and tree-convex [35] constraints are examples of constraint classes which have the Helly property. More importantly, we presented the algorithm DPC∗, a simple variant of DPC, which can decide the CSP of any majority-closed constraint language, and is sufficient for guaranteeing backtrackfree search for majority-closed constraint networks, which have been found applications in various domains, such as scene labeling, temporal reasoning, geometric reasoning, and logical filtering. Our evaluations also show that DPC∗ significantly outperforms the state-of-the-art algorithms for solving majority-closed constraint networks."
    } ],
    "references" : [ {
      "title" : "The collapse of the bounded width hierarchy",
      "author" : [ "L. Barto" ],
      "venue" : "Journal of Logic and Computation 26(3), 923–943",
      "citeRegEx" : "1",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Constraint satisfaction problems solvable by local consistency methods",
      "author" : [ "L. Barto", "M. Kozik" ],
      "venue" : "Journal of the ACM 61(1), 3:1–3:19",
      "citeRegEx" : "2",
      "shortCiteRegEx" : null,
      "year" : 2014
    }, {
      "title" : "On the minimality and global consistency of row-convex constraint networks",
      "author" : [ "P. van Beek", "R. Dechter" ],
      "venue" : "Journal of the ACM 42(3), 543–561",
      "citeRegEx" : "3",
      "shortCiteRegEx" : null,
      "year" : 1995
    }, {
      "title" : "Efficient algorithms for singleton arc consistency",
      "author" : [ "C. Bessière", "S. Cardon", "R. Debruyne", "C. Lecoutre" ],
      "venue" : "Constraints 16(1), 25–53",
      "citeRegEx" : "4",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "An optimal coarse-grained arc consistency algorithm",
      "author" : [ "C. Bessière", "J.C. Régin", "R.H. Yap", "Y. Zhang" ],
      "venue" : "Artificial Intelligence 165(2), 165–185",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Path consistency on triangulated constraint graphs",
      "author" : [ "C. Bliek", "D. Sam-Haroud" ],
      "venue" : "IJCAI. pp. 456–461",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "An algebraic approach to multi-sorted constraints",
      "author" : [ "A.A. Bulatov", "P. Jeavons" ],
      "venue" : "CP. pp. 183–198",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Tractability in constraint satisfaction problems: A survey",
      "author" : [ "C. Carbonnel", "M.C. Cooper" ],
      "venue" : "Constraints 21(2), 115–144",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Arc consistency and friends",
      "author" : [ "H. Chen", "V. Dalmau", "B. Grußien" ],
      "venue" : "Journal of Logic and Computation 23(1), 87–108",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 2011
    }, {
      "title" : "Efficient path-consistency propagation",
      "author" : [ "A. Chmeiss", "P. Jégou" ],
      "venue" : "International Journal on Artificial Intelligence Tools 7(02), 121–142",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "The complexity of constraint languages",
      "author" : [ "D. Cohen", "P. Jeavons" ],
      "venue" : "Handbook of Constraint Programming, pp. 169–204. Elsevier",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Some practicable filtering techniques for the constraint satisfaction problem",
      "author" : [ "R. Debruyne", "C. Bessière" ],
      "venue" : "IJCAI. pp. 412–417",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Constraint processing",
      "author" : [ "R. Dechter" ],
      "venue" : "Morgan Kaufmann",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2003
    }, {
      "title" : "Temporal constraint networks",
      "author" : [ "R. Dechter", "I. Meiri", "J. Pearl" ],
      "venue" : "Artificial Intelligence 49(1-3), 61–95",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 1991
    }, {
      "title" : "Network-based heuristics for constraint-satisfaction problems",
      "author" : [ "R. Dechter", "J. Pearl" ],
      "venue" : "Artificial Intelligence 34(1), 1–38",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 1987
    }, {
      "title" : "Constraint satisfaction over connected row convex constraints",
      "author" : [ "Y. Deville", "O. Barette", "P. van Hentenryck" ],
      "venue" : "Artificial Intelligence 109(1-2), 243–271",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 1999
    }, {
      "title" : "A sufficient condition for backtrack-free search",
      "author" : [ "E.C. Freuder" ],
      "venue" : "Journal of the ACM 29(1), 24–32",
      "citeRegEx" : "17",
      "shortCiteRegEx" : null,
      "year" : 1982
    }, {
      "title" : "Incidence matrices and interval graphs",
      "author" : [ "D. Fulkerson", "O. Gross" ],
      "venue" : "Pacific Journal of Mathematics 15(3), 835–855",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 1965
    }, {
      "title" : "Constraints, consistency and closure",
      "author" : [ "P. Jeavons", "D. Cohen", "M.C. Cooper" ],
      "venue" : "Artificial Intelligence 101(1), 251–265",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 1998
    }, {
      "title" : "On tree-preserving constraints",
      "author" : [ "S. Kong", "S. Li", "Y. Li", "Z. Long" ],
      "venue" : "CP. pp. 244–261",
      "citeRegEx" : "20",
      "shortCiteRegEx" : null,
      "year" : 2015
    }, {
      "title" : "On tree-preserving constraints",
      "author" : [ "S. Kong", "S. Li", "Y. Li", "Z. Long" ],
      "venue" : "Annals of Mathematics and Artificial Intelligence",
      "citeRegEx" : "21",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "Weak consistency notions for all the csps of bounded width",
      "author" : [ "M. Kozik" ],
      "venue" : "LICS. pp. 633– 641",
      "citeRegEx" : "22",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "On geometric CSPs with (near)-linear domains and max-distance constraints",
      "author" : [ "T.K.S. Kumar" ],
      "venue" : "Workshop on Modelling and Solving Problems with Constraints. pp. 125–138",
      "citeRegEx" : "23",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "On the tractability of restricted disjunctive temporal problems",
      "author" : [ "T.K.S. Kumar" ],
      "venue" : "ICAPS. pp. 110–119",
      "citeRegEx" : "24",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "On some tractable cases of logical filtering",
      "author" : [ "T.K.S. Kumar", "S.J. Russell" ],
      "venue" : "ICAPS. pp. 83–92",
      "citeRegEx" : "25",
      "shortCiteRegEx" : null,
      "year" : 2006
    }, {
      "title" : "Qualitative constraint satisfaction problems: an extended framework with landmarks",
      "author" : [ "S. Li", "W. Liu", "S. Wang" ],
      "venue" : "Artificial Intelligence 201, 32–58",
      "citeRegEx" : "26",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "Consistency in networks of relations",
      "author" : [ "A.K. Mackworth" ],
      "venue" : "Artificial Intelligence 8(1), 99–118",
      "citeRegEx" : "27",
      "shortCiteRegEx" : null,
      "year" : 1977
    }, {
      "title" : "Structural disambiguation with constraint propagation",
      "author" : [ "H. Maruyama" ],
      "venue" : "ACL. pp. 31–38",
      "citeRegEx" : "28",
      "shortCiteRegEx" : null,
      "year" : 1990
    }, {
      "title" : "Arc and path consistency revisited",
      "author" : [ "R. Mohr", "T.C. Henderson" ],
      "venue" : "Artificial Intelligence 28(2), 225–233",
      "citeRegEx" : "29",
      "shortCiteRegEx" : null,
      "year" : 1986
    }, {
      "title" : "Networks of constraints: fundamental properties and applications to picture processing",
      "author" : [ "U. Montanari" ],
      "venue" : "Information Science 7, 95–132",
      "citeRegEx" : "30",
      "shortCiteRegEx" : null,
      "year" : 1974
    }, {
      "title" : "PC: A new algorithm for the simple temporal problem",
      "author" : [ "L. Planken", "M. de Weerdt", "R. van der Krogt" ],
      "venue" : "ICAPS. vol. 2008, pp. 256–263",
      "citeRegEx" : "31",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "Path consistency revisited",
      "author" : [ "M. Singh" ],
      "venue" : "International Journal on Artificial Intelligence Tools 5(1-2), 127–142",
      "citeRegEx" : "32",
      "shortCiteRegEx" : null,
      "year" : 1996
    }, {
      "title" : "Efficiently reasoning about qualitative constraints through variable elimination",
      "author" : [ "M. Sioutis", "Z. Long", "S. Li" ],
      "venue" : "SETN. pp. 1:1–1:10",
      "citeRegEx" : "33",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "Solving connected row convex constraints by variable elimination",
      "author" : [ "Y. Zhang", "S. Marisetti" ],
      "venue" : "Artificial Intelligence 173(12), 1204–1219",
      "citeRegEx" : "34",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Consistency and set intersection",
      "author" : [ "Y. Zhang", "R.H.C. Yap" ],
      "venue" : "IJCAI. pp. 263–270",
      "citeRegEx" : "35",
      "shortCiteRegEx" : null,
      "year" : 2003
    } ],
    "referenceMentions" : [ {
      "referenceID" : 29,
      "context" : "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 27,
      "context" : "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].",
      "startOffset" : 115,
      "endOffset" : 119
    }, {
      "referenceID" : 13,
      "context" : "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].",
      "startOffset" : 140,
      "endOffset" : 147
    }, {
      "referenceID" : 30,
      "context" : "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].",
      "startOffset" : 140,
      "endOffset" : 147
    }, {
      "referenceID" : 25,
      "context" : "Many Artificial Intelligence tasks can be formulated as constraint networks [30], such as natural language parsing [28], temporal reasoning [14,31], and spatial reasoning [26].",
      "startOffset" : 171,
      "endOffset" : 175
    }, {
      "referenceID" : 16,
      "context" : "form of local consistency, a crucial task is to determine problems that can be solved by backtrack-free search using that local consistency [17].",
      "startOffset" : 140,
      "endOffset" : 144
    }, {
      "referenceID" : 26,
      "context" : "[27,29,32,6,10]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 28,
      "context" : "[27,29,32,6,10]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 31,
      "context" : "[27,29,32,6,10]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 5,
      "context" : "[27,29,32,6,10]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 9,
      "context" : "[27,29,32,6,10]).",
      "startOffset" : 0,
      "endOffset" : 15
    }, {
      "referenceID" : 1,
      "context" : "Recently, it was shown that PC can be used to decide the satisfiability of a problem if and only if the problem does not have the ability to count [2,1]; however, it remains unclear whether backtrack-free search can be used to extract a solution for such a problem after enforcing PC.",
      "startOffset" : 147,
      "endOffset" : 152
    }, {
      "referenceID" : 0,
      "context" : "Recently, it was shown that PC can be used to decide the satisfiability of a problem if and only if the problem does not have the ability to count [2,1]; however, it remains unclear whether backtrack-free search can be used to extract a solution for such a problem after enforcing PC.",
      "startOffset" : 147,
      "endOffset" : 152
    }, {
      "referenceID" : 14,
      "context" : "Directional path-consistency (DPC) [15] is a weaker notion of PC that considers a given variable ordering and can thus be enforced more efficiently than PC.",
      "startOffset" : 35,
      "endOffset" : 39
    }, {
      "referenceID" : 14,
      "context" : "The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33].",
      "startOffset" : 49,
      "endOffset" : 53
    }, {
      "referenceID" : 13,
      "context" : "The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33].",
      "startOffset" : 147,
      "endOffset" : 154
    }, {
      "referenceID" : 30,
      "context" : "The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33].",
      "startOffset" : 147,
      "endOffset" : 154
    }, {
      "referenceID" : 32,
      "context" : "The DPC enforcing algorithm of Dechter and Pearl [15], denoted by DPC, has been used to efficiently solve reasoning problems in temporal reasoning [14,31] and spatial reasoning [33].",
      "startOffset" : 177,
      "endOffset" : 181
    }, {
      "referenceID" : 14,
      "context" : "Dechter and Pearl [15] showed that DPC is sufficient for enabling backtrack-free search for networks with constraint graphs of regular width 2.",
      "startOffset" : 18,
      "endOffset" : 22
    }, {
      "referenceID" : 7,
      "context" : "We consider the aforementioned question in the context of constraint languages, which is a widely adopted approach in the study of tractability of constraint satisfaction problems [8].",
      "startOffset" : 180,
      "endOffset" : 183
    }, {
      "referenceID" : 15,
      "context" : "The most well-known one is the class of connected row-convex (CRC) constraints [16], which is further generalized to a larger class of tree-preserving constraints [20].",
      "startOffset" : 79,
      "endOffset" : 83
    }, {
      "referenceID" : 19,
      "context" : "The most well-known one is the class of connected row-convex (CRC) constraints [16], which is further generalized to a larger class of tree-preserving constraints [20].",
      "startOffset" : 163,
      "endOffset" : 167
    }, {
      "referenceID" : 23,
      "context" : "The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20].",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 24,
      "context" : "The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20].",
      "startOffset" : 105,
      "endOffset" : 109
    }, {
      "referenceID" : 22,
      "context" : "The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20].",
      "startOffset" : 135,
      "endOffset" : 139
    }, {
      "referenceID" : 19,
      "context" : "The class of CRC constraints has been successfully applied to temporal reasoning [24], logical filtering [25], and geometric reasoning [23], and the class of tree-preserving constraints can model a large subclass of the scene labeling problem [20].",
      "startOffset" : 243,
      "endOffset" : 247
    }, {
      "referenceID" : 5,
      "context" : "2: Path-Consistency [6].",
      "startOffset" : 20,
      "endOffset" : 23
    }, {
      "referenceID" : 5,
      "context" : "Triangulated graphs play a key role in efficiently solving large sparse constraint networks [6,31,33].",
      "startOffset" : 92,
      "endOffset" : 101
    }, {
      "referenceID" : 30,
      "context" : "Triangulated graphs play a key role in efficiently solving large sparse constraint networks [6,31,33].",
      "startOffset" : 92,
      "endOffset" : 101
    }, {
      "referenceID" : 32,
      "context" : "Triangulated graphs play a key role in efficiently solving large sparse constraint networks [6,31,33].",
      "startOffset" : 92,
      "endOffset" : 101
    }, {
      "referenceID" : 17,
      "context" : "A graphG is triangulated iff it admits a perfect elimination ordering (PEO) [18].",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 5,
      "context" : "A constraint network N is AC if GN is AC and N is PC if the competition of GN is PC [6].",
      "startOffset" : 84,
      "endOffset" : 87
    }, {
      "referenceID" : 18,
      "context" : "[19] Let D = {D1, .",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 0,
      "context" : "For any tuple t ∈ R and any 1 ≤ i ≤ n, we denote by t[i] the value in the i-th coordinate position of t and write t as 〈t[1], .",
      "startOffset" : 121,
      "endOffset" : 124
    }, {
      "referenceID" : 18,
      "context" : "[19] Given a set of binary relations Γ , we write Γ for the set of relations that can be obtained from Γ using some sequence of the following operations:",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "[11] Let Γ be a complete set of binary relations over a domainD.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 10,
      "context" : "CSP(Γ) is log-space reducible to CSP(Γ ) [11].",
      "startOffset" : 41,
      "endOffset" : 45
    }, {
      "referenceID" : 18,
      "context" : "We will see that this is not very restrictive as, for any set Γ of binary relations that is closed under a majority operation φ, the completion Γ c of Γ is also closed under φ [19] and weakly closed under singletons (cf.",
      "startOffset" : 176,
      "endOffset" : 180
    }, {
      "referenceID" : 12,
      "context" : "This section recalls the notions of directional arc-consistency (DAC) and directional path-consistency (DPC), and the strong DPC enforcing algorithm of Dechter and Pearl [13].",
      "startOffset" : 170,
      "endOffset" : 174
    }, {
      "referenceID" : 12,
      "context" : "[13] Let N = 〈V,D, C〉 be a BCN and ≺= (v1, .",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 9,
      "context" : "In comparison with traditional PC algorithms [10], a novelty of this single pass algorithm is its explicit reference to the constraint graph of the input constraint network.",
      "startOffset" : 45,
      "endOffset" : 49
    }, {
      "referenceID" : 12,
      "context" : "Further, Algorithm 1 runs inO(w∗(≺) ·e · (α+β)) time [13], where e is the number of edges of the output constraint graph, w∗(≺) is the induced width of the ordered graph along ≺, and α, β are the runtimes of relational intersection and composition respectively.",
      "startOffset" : 53,
      "endOffset" : 57
    }, {
      "referenceID" : 12,
      "context" : "[13] Let (N ,≺) be an input to Algorithm 1, where ≺ = (v1, .",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 12,
      "context" : "3: A graph coloring problem with domain Di = {red, blue} for i = 1, 2, 3, 4 [13].",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 12,
      "context" : "3 is taken from [13] and can be decided by Algorithm 1.",
      "startOffset" : 16,
      "endOffset" : 20
    }, {
      "referenceID" : 12,
      "context" : "We observe that DPC achieves (strong) DPC using the idea of variable elimination [13]: it iterates variables along the ordering ≺−1, and propagates the constraints of a variable vk to subsequent variables in the ordering with the update rule Rij ← Rij ∩ (Rik ◦Rkj), as if vk is ‘eliminated’.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 2,
      "context" : "This is important; for example, every row-convex constraint [3] network has VEP (cf.",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 19,
      "context" : "[20]).",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 2,
      "context" : "The class of row-convex constraints [3] and the class of tree-convex constraints [35] have the Helly property and, thus, they have VEP by Theorem 1.",
      "startOffset" : 36,
      "endOffset" : 39
    }, {
      "referenceID" : 34,
      "context" : "The class of row-convex constraints [3] and the class of tree-convex constraints [35] have the Helly property and, thus, they have VEP by Theorem 1.",
      "startOffset" : 81,
      "endOffset" : 85
    }, {
      "referenceID" : 6,
      "context" : "[7] Let D = {D1, .",
      "startOffset" : 0,
      "endOffset" : 3
    }, {
      "referenceID" : 0,
      "context" : ", n} is said to be closed under φ if φ(t1, t2, t3) = 〈φi1(t1[1], t2[1], t3[1]), .",
      "startOffset" : 60,
      "endOffset" : 63
    }, {
      "referenceID" : 0,
      "context" : ", n} is said to be closed under φ if φ(t1, t2, t3) = 〈φi1(t1[1], t2[1], t3[1]), .",
      "startOffset" : 67,
      "endOffset" : 70
    }, {
      "referenceID" : 0,
      "context" : ", n} is said to be closed under φ if φ(t1, t2, t3) = 〈φi1(t1[1], t2[1], t3[1]), .",
      "startOffset" : 74,
      "endOffset" : 77
    }, {
      "referenceID" : 20,
      "context" : "[21] An undirected graph structure can often be associated to a finite domainD such that there is a bijection between the vertices in the graph and the values in D.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 20,
      "context" : "A CRC constraint is a special tree-preserving constraint where related tree domains are chains [21].",
      "startOffset" : 95,
      "endOffset" : 99
    }, {
      "referenceID" : 20,
      "context" : "[21] Let Ti and Tj be two nonempty tree domains and mi and mj their standard majority operations.",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "[19] Let Γ be a set of binary relations over a set of finite domains D = {D1, .",
      "startOffset" : 0,
      "endOffset" : 4
    }, {
      "referenceID" : 18,
      "context" : "obtained by using a sequence of the Cartesian product, equality selection, and projection operations [19].",
      "startOffset" : 101,
      "endOffset" : 105
    }, {
      "referenceID" : 33,
      "context" : "Compared with the variable elimination algorithm for solving CRC constraints [34], DPC∗ enforces a weaker AC condition instead of full AC.",
      "startOffset" : 77,
      "endOffset" : 81
    }, {
      "referenceID" : 18,
      "context" : "As we know that if Γ is majority-closed, the completion of Γ is also majority-closed [19], and that complete majority-closed classes and complete weak VEP classes are equivalent by Theorem 4, this also proves the following result:",
      "startOffset" : 85,
      "endOffset" : 89
    }, {
      "referenceID" : 3,
      "context" : "These are SAC3-SDS [4] and PC2001 [5].",
      "startOffset" : 19,
      "endOffset" : 22
    }, {
      "referenceID" : 4,
      "context" : "These are SAC3-SDS [4] and PC2001 [5].",
      "startOffset" : 34,
      "endOffset" : 37
    }, {
      "referenceID" : 11,
      "context" : "SAC3-SDS is currently the best singleton arc-consistency (SAC) enforcing algorithm [12].",
      "startOffset" : 83,
      "endOffset" : 87
    }, {
      "referenceID" : 8,
      "context" : "Enforcing either SAC1 or PC correctly decides the consistency of a majority-closed constraint network [9,19].",
      "startOffset" : 102,
      "endOffset" : 108
    }, {
      "referenceID" : 18,
      "context" : "Enforcing either SAC1 or PC correctly decides the consistency of a majority-closed constraint network [9,19].",
      "startOffset" : 102,
      "endOffset" : 108
    }, {
      "referenceID" : 21,
      "context" : "(2) 1 Singleton linear arc-consistency (SLAC) is an alternative consistency notion that can be enforced to solve majority-closed constraint network [22], but no practical SLAC algorithms are available so far.",
      "startOffset" : 148,
      "endOffset" : 152
    }, {
      "referenceID" : 0,
      "context" : "• Randomly generate constraints Rij ⊆ Di ×Dj and test whether {〈⊗i(tx[1], ty[1], tz[1]),⊗j(tx[2], ty[2], tz[2])〉 | tx, ty, tz ∈ Rij} ⊆ Rij (3) holds.",
      "startOffset" : 69,
      "endOffset" : 72
    }, {
      "referenceID" : 0,
      "context" : "• Randomly generate constraints Rij ⊆ Di ×Dj and test whether {〈⊗i(tx[1], ty[1], tz[1]),⊗j(tx[2], ty[2], tz[2])〉 | tx, ty, tz ∈ Rij} ⊆ Rij (3) holds.",
      "startOffset" : 76,
      "endOffset" : 79
    }, {
      "referenceID" : 0,
      "context" : "• Randomly generate constraints Rij ⊆ Di ×Dj and test whether {〈⊗i(tx[1], ty[1], tz[1]),⊗j(tx[2], ty[2], tz[2])〉 | tx, ty, tz ∈ Rij} ⊆ Rij (3) holds.",
      "startOffset" : 83,
      "endOffset" : 86
    }, {
      "referenceID" : 1,
      "context" : "• Randomly generate constraints Rij ⊆ Di ×Dj and test whether {〈⊗i(tx[1], ty[1], tz[1]),⊗j(tx[2], ty[2], tz[2])〉 | tx, ty, tz ∈ Rij} ⊆ Rij (3) holds.",
      "startOffset" : 93,
      "endOffset" : 96
    }, {
      "referenceID" : 1,
      "context" : "• Randomly generate constraints Rij ⊆ Di ×Dj and test whether {〈⊗i(tx[1], ty[1], tz[1]),⊗j(tx[2], ty[2], tz[2])〉 | tx, ty, tz ∈ Rij} ⊆ Rij (3) holds.",
      "startOffset" : 100,
      "endOffset" : 103
    }, {
      "referenceID" : 1,
      "context" : "• Randomly generate constraints Rij ⊆ Di ×Dj and test whether {〈⊗i(tx[1], ty[1], tz[1]),⊗j(tx[2], ty[2], tz[2])〉 | tx, ty, tz ∈ Rij} ⊆ Rij (3) holds.",
      "startOffset" : 107,
      "endOffset" : 110
    }, {
      "referenceID" : 5,
      "context" : "We used the model in [6,16] to generate random consistent constraint networks for experiments.",
      "startOffset" : 21,
      "endOffset" : 27
    }, {
      "referenceID" : 15,
      "context" : "We used the model in [6,16] to generate random consistent constraint networks for experiments.",
      "startOffset" : 21,
      "endOffset" : 27
    }, {
      "referenceID" : 2,
      "context" : "The classes of row-convex [3] and tree-convex [35] constraints are examples of constraint classes which have the Helly property.",
      "startOffset" : 26,
      "endOffset" : 29
    }, {
      "referenceID" : 34,
      "context" : "The classes of row-convex [3] and tree-convex [35] constraints are examples of constraint classes which have the Helly property.",
      "startOffset" : 46,
      "endOffset" : 50
    } ],
    "year" : 2017,
    "abstractText" : "Among the local consistency techniques used for solving constraint networks, path-consistency (PC) has received a great deal of attention. However, enforcing PC is computationally expensive and sometimes even unnecessary. Directional path-consistency (DPC) is a weaker notion of PC that considers a given variable ordering and can thus be enforced more efficiently than PC. This paper shows that DPC (the DPC enforcing algorithm of Dechter and Pearl) decides the constraint satisfaction problem (CSP) of a constraint language Γ if it is complete and has the variable elimination property (VEP). However, we also show that no complete VEP constraint language can have a domain with more than 2 values. We then present a simple variant of the DPC algorithm, called DPC∗, and show that the CSP of a constraint language can be decided by DPC∗ if it is closed under a majority operation. In fact, DPC∗ is sufficient for guaranteeing backtrack-free search for such constraint networks. Examples of majority-closed constraint classes include the classes of connected row-convex (CRC) constraints and tree-preserving constraints, which have found applications in various domains, such as scene labeling, temporal reasoning, geometric reasoning, and logical filtering. Our experimental evaluations show that DPC∗ significantly outperforms the state-of-the-art algorithms for solving majority-closed constraints.",
    "creator" : "LaTeX with hyperref package"
  }
}