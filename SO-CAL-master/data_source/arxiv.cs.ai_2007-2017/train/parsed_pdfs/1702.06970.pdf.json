{
  "name" : "1702.06970.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "A Realistic Dataset for the Smart Home Device Scheduling Problem for DCOPs",
    "authors" : [ "William Kluegel", "Muhammad Aamir Iqbal", "Ferdinando Fioretto", "William Yeoh", "Enrico Pontelli" ],
    "emails" : [ "wkluegel@cs.nmsu.edu,", "miqbal@cs.nmsu.edu,", "wyeoh@cs.nmsu.edu,", "epontell@cs.nmsu.edu,", "fioretto@umich.edu" ],
    "sections" : [ {
      "heading" : "1 Introduction",
      "text" : "Distributed Constraint Optimization Problems (DCOPs) [11,15,18] have emerged as one of the prominent agent models to govern the agents’ autonomous behavior, where both algorithms and communication models are driven by the structure of the specific problem. Since the research field inception a wide variety of algorithms have been proposed to solve DCOPs and typically classified as being either complete or incomplete, based on whether they can guarantee the optimal solution or they trade optimality for shorter execution times. In addition, each of these classes can be categorized into several groups, depending on the degree of locality exploited by the algorithms (e.g., partial centralization) [9,10,16], the way local information is updated (e.g., synchronous [10,14,15] or asynchronous [5,8,11]), and the type of exploration process adopted (e.g., search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).\nWhile techniques to solve DCOPs are abundant and have matured substantially since the field inception, the number of DCOP realistic applications and benchmarks used to assess the performance of DCOP algorithms is lagging behind. Typical DCOP algorithms are evaluated on artificial random problems, or simplified problems that are adapted to the often unrealistic assumptions made by DCOP algorithms (e.g., that each agent controls exactly one variable, and that all problem constraints are binary). To assess the performance of DCOP algorithms it is necessary to introduce realistic problem benchmark of deployable applications.\nMotivated by these issues, we recently introduced the Smart Home Device Scheduling (SHDS) problem [7], which formalizes the problem of coordinating smart devices\nar X\niv :1\n70 2.\n06 97\n0v 1\n[ cs\n.A I]\n2 2\nFe b\n20 17\n(e.g., smart thermostats, circulator heating, washing machines) schedules across multiple smart homes as a multi-agent system (MAS). The SHDS problem is suitable to be modeled as a DCOP due to the presence of both complex individual agents’ goals, describing homes’ energy price consumption, as well as a collective agents’ goal, capturing the energy peaks reduction.\nIn this document we introduce a set of realistic synthetic benchmarks for the SHDS problem for DCOPs. We report the details of the physical models adopted to simulate smart home sensors and actuators, as well as home environments, and describe how the actuator’s actions affects the environments of a home (e.g., home’s temperature, cleanliness, humidity). The datasets, models, and code adopted to generate the SHDS datasets are available at: https://github.com/persoon/SHDS_dataset.\nDCOP A Distributed Constraint Optimization Problem (DCOP) [11,18] is described by a tuple 〈X ,D,F ,A, α〉, where: X = {x1, . . . , xn} is a set of variables; D = {D1, . . . , Dn} is a set of finite domains (i.e., xi∈Di);F={f1, . . . , fe} is a set of utility functions (also called constraints), where fi : \"xj∈xfi Di → R+ ∪ {−∞} and xfi⊆X is the set of the variables (also called the scope) relevant to fi;A={a1, . . . , ap} is a set of agents; and α : X → A is a function that maps each variable to one agent. fi specifies the utility of each combination of values assigned to the variables in xfi . A partial assignment σ is a value assignment to a set of variables Xσ⊆X that is consistent with the variables’ domains. The utilityF(σ)= ∑ f∈F,xf⊆Xσ f(σ) is the sum of the utilities of all the applicable utility functions in σ. A solution is a partial assignment σ for all the variables of the problem, i.e., with Xσ=X . We will denote with x a solution, while xi is the value of xi in x. The goal is to find an optimal solution x∗ = argmaxx F(x)."
    }, {
      "heading" : "2 Scheduling Device in Smart Homes",
      "text" : "A Smart Home Device Scheduling (SHDS) problem is defined by the tuple 〈H,Z,L,PH ,PZ , H, θ〉, where: H = {h1, h2, . . .} is a neighborhood of smart homes, capable of communicating with one another; Z = ∪hi∈HZi is a set of smart devices, where Zi is the set of devices in the smart home hi (e.g., vacuum cleaning robot, smart thermostat). L = ∪hi∈HLi is a set of locations, where Li is the set of locations in the smart home hi (e.g., living room, kitchen); PH is the set of state properties of the smart homes (e.g., cleanliness, temperature); PZ is the set of devices state properties (e.g., battery charge for a vacuum robot); H is the planning horizon of the problem. We denote with T = {1, . . . ,H} the set of time points; θ : T → R+ represents the real-time pricing schema adopted by the energy utility company, which expresses the cost per kWh of energy consumed by consumers. Finally, we use Ωp to denote the set of all possible states for state property p ∈ PH ∪ PZ (e.g., all the different levels of cleanliness for the cleanliness property). Figure 1(right) shows an illustration of a neighborhood of smart homes with each home controlling a set of smart devices."
    }, {
      "heading" : "2.1 Smart Devices",
      "text" : "For each home hi ∈ H, the set of smart devices Zi is partitioned into a set of actuators Ai and a set of sensors Si. Actuators can affect the states of the home (e.g., heaters and\novens can affect the temperature in the home) and possibly their own states (e.g., vacuum cleaning robots drain their battery power when running). On the other hand, sensors monitor the states of the home. Each device z ∈ Zi of a home hi is defined by a tuple 〈`z, Az, γHz , γZz 〉, where `z ∈ Li denotes the relevant location in the home that it can act or sense, Az is the set of actions that it can perform, γHz : Az → 2PH maps the actions of the device to the relevant state properties of the home, and γZz : Az → 2PZ maps the actions of the device to its relevant state properties. We will use the following running example throughout this paper.\nExample 1. Consider a vacuum cleaning robot zv with location `zv = living room. The set of possible actions is Azv = {run, charge, stop} and the mappings are:\nγHzv: run→{cleanliness}; charge→∅; stop→∅ γZzv: run→{battery charge}; charge→{battery charge}; stop→∅\nwhere ∅ represents a null state property."
    }, {
      "heading" : "2.2 Device Schedules",
      "text" : "To control the energy profile of a smart home we need to describe the behavior of the smart devices acting in the smart home during time. We formalize this concept with the notion of device schedules.\nWe use ξtz ∈ Az to denote the action of device z at time step t, and ξtX = {ξtz | z ∈ X} to denote the set of actions of the devices in X ⊆ Z at time step t.\nDefinition 1 (Schedule).A schedule ξ[ta→tb]X = 〈ξ ta X , . . . , ξ tb X〉 is a sequence of actions for the devices in X ⊆ Z within the time interval from ta to tb. Consider the illustration of Figure 1(left). The top row of Figure 1(left) shows a possible schedule 〈R,R,C,C,R,R,C,R〉 for a vacuum cleaning robot starting at time 1400 hrs, where each time step is 30 minutes. The robot’s actions at each time step are shown in the colored boxes with letters in them: red with ‘S’ for stop, green with ‘R’ for run, and blue with ‘C’ for charge.\nAt a high-level, the goal of the SHDS problem is to find a schedule for each of the devices in every smart home that achieve some user-defined objectives (e.g., the home is at a particular temperature within a time window, the home is at a certain cleanliness level by some deadline) that may be personalized for each home. We refer to these objectives as scheduling rules."
    }, {
      "heading" : "2.3 Scheduling Rules",
      "text" : "We define two types of scheduling rules: Active scheduling rules (ASRs) that define user-defined objectives on a desired state of the home (e.g., the living room is cleaned by 1800 hrs), and Passive scheduling rules (PSRs) that define implicit constraints on devices that must hold at all times (e.g., the battery charge on a vacuum cleaning robot is always between 0% and 100%). We provide a formal description for the grammar of scheduling rules in Section 3.4.\nExample 2. The scheduling rule (1) describes an ASR defining a goal state where the living room floor is at least 75% clean (i.e., at least 75% of the floor is cleaned by a vacuum cleaning robot) by 1800 hrs:\nliving room cleanliness ≥ 75 before 1800 (1) zv battery charge ≥ 0 always (2) zv battery charge ≤ 100 always (3)\nand scheduling rules (2) and (3) describe PSRs stating that the battery charge of the vacuum robot zv needs to be between 0 and 100 % of its full charge at all the times:\nWe denote with R[ta→tb]p a scheduling rule over a state property p∈PH∪PZ , and time interval [ta, tb]. Each scheduling rule indicates a goal state at a location or on a device `Rp ∈Li∪Zi of a particular state property p that must hold over the time interval [ta, tb] ⊆ T. The scheduling rule goal state is either a desired state of a home, if it is an ASR (e.g., the cleanliness level of the room floor) or a required state of a device or a home, if it is a PSR (e.g., the battery charge of the vacuum cleaning robot).\nEach rule is associated with a set of actuators Φp ⊆ Ai that can be used to reach the goal state. For instance, in our Example (2), Φp correspond to the vacuum cleaning robot zv , which can operate on the living room floor. Additionally, a rule is associated with a sensor sp ∈ Si capable of sensing the state property p. Finally, in a PSRs the device can also sense its own internal states.\nThe ASR of Equation (1) is illustrated in Figure 1(left) by dotted red lines on the graph. The PSRs are not shown as they must hold for all time steps."
    }, {
      "heading" : "2.4 Feasibility of Schedules",
      "text" : "To ensure that a goal state can be achieved across the desired time window the system uses a predictive model of the various state properties. This predictive model captures the evolution of a state property over time and how such state property is affected by a given joint action of the relevant actuators. We describe the details of the physical predictive models used to generate our benchmark set in Section 3.3.\nDefinition 2 (Predictive Model). A predictive model Γp for a state property p (of either the home or a device) is a function Γp : Ωp × \"z∈Φp Az ∪ {⊥} → Ωp ∪ {⊥}, where ⊥ denotes an infeasible state and ⊥+ (·) = ⊥.\nIn other words, the model describes the transition of state property p from state ωp ∈ Ωp at time step t to time step t + 1 when it is affected by a set of actuators Φp\nrunning joint actions ξtΦp :\nΓ t+1p (ωp, ξ t Φp) = ωp +∆p(ωp, ξ t Φp) (4)\nwhere ∆p(ωp, ξtΦp) is a function describing the effect of the actuators’ joint action ξ t Φp on state property p. We assume here, w.l.o.g. that the state of properties are numeric— when this is not the case, a mapping to the possible states to a numeric representation can be easily defined.\nNotice that a recursive invocation of a predictive model allows us to predict the trajectory of a state property p for future time steps, given a schedule of actions of the relevant actuators Φp. Let us formally define this concept.\nDefinition 3 (Predicted State Trajectory). Given a state property p, its current state ωp at time step ta, and a schedule ξ [ta→tb] Φp of relevant actuators Φp, the predicted state trajectory πp(ωp, ξ [ta→tb] Φp ) of that state property is defined as:\nπp(ωp, ξ [ta→tb] Φp ) = Γ tbp (Γ tb−1 p (. . . (Γ ta p (ωp, ξ ta Φp ), . . .), ξ tb−1 Φp ), ξtbΦp) (5)\nConsider the device scheduling example in Figure 1(left). The predicted state trajectories of the battery charge and cleanliness state properties are shown in the second and third rows of Figure 1(left). These trajectories are predicted given that the vacuum cleaning robot will take on the schedule shown in the first row of the figure. The predicted trajectories of these state properties are also illustrated in the graph, where the dark grey line shows the states for the robot’s battery charge and the black line shows the states for the cleanliness of the room.\nNotice that to verify if a schedule satisfies a scheduling rule it is sufficient to check that the predicted state trajectories are within the set of feasible state trajectories of that rule. Additionally, notice that each active and passive scheduling rule defines a set of feasible state trajectories. For example, the active scheduling rule of Equation (1) allows all possible state trajectories as long as the state at time step 1800 is no smaller than 75. We use Rp[t] ⊆ Ωp to denote the set of states that are feasible according to rule Rp of state property p at time step t. More formally, a schedule ξ[ta→tb]Φp satisfies a scheduling rule R[ta→tb]p (written as ξ [ta→tb] Φp |= R[ta→tb]p ) iff:\n∀t ∈ [ta, tb] : πp(ωtap , ξ [ta→t] Φp ) ∈ Rp[t] (6)\nwhere ωtap is the state of state property p at time step ta.\nDefinition 4 (Feasible Schedule). A schedule is feasible if it satisfies all the passive and active scheduling rules of each home in the SHDS problem.\nIn the example of Figure 1, the evaluated schedule is a feasible schedule since the trajectories of both the battery charge and cleanliness states satisfy both the active scheduling rule (1) and the passive scheduling rules (2) and (3)."
    }, {
      "heading" : "2.5 Optimization Objective",
      "text" : "In addition to finding feasible schedules, the goal in the SHDS problem is to optimize for the aggregated total cost of energy consumed.\nEach action a ∈ Az of device z ∈ Zi in home hi ∈ H has an associated energy consumption ρz : Az → R+, expressed in kWh. The aggregated energy Eti (ξ [0→H] Zi ) across all devices consumed by hi at time step t under trajectory ξ [0→H] Zi is:\nEti (ξ [0→H] Zi ) = ∑ z∈Zi ρz(ξ t z) (7)\nwhere ξtz is the action of device z at time t in the schedule ξ [0→H] Zi . The cost ci(ξ [0→H] Zi ) associated to schedule ξ[0→H]Zi in home hi is:\nci(ξ [0→H] Zi ) = ∑ t∈T ( `ti + E t i (ξ [0→H] Zi )) · θ(t) (8)\nwhere `ti is the home background load produced at time t, which includes all nonschedulable devices (e.g., TV, refrigerator), and sensor devices, which are always active, and θ(t) is the real-time price of energy per kWh at time t.\nThe objective of an SHDS problem is that of minimizing the following weighted bi-objective function:\nmin ξ [0→H] Zi\nαc ·Csum + αe ·Epeak (9)\nsubject to: ∀hi ∈ H, R[ta→tb]p ∈ Ri : ξ [ta→tb] Φp |= R[ta→tb]p (10)\nwhere αc, αe ∈R are weights, Csum = ∑ hi∈H ci(ξ [0→H] Zi ) is the aggregated monetary\ncost across all homes hi; and Epeak = ∑ t∈T ∑ Hj∈H ∑ hi∈Hj ( Eti (ξ [0→H] Zi ) )2\nis a quadratic penalty function on the aggregated energy consumption across all homes hi. Since the SHDS problem is designed for distributed multi-agent systems, in a cooperative approach optimizing Epeak may require each home to share its energy profile with each other home. To take into account data privacy concerns and possible high network loads, we decompose the set of homes H into neighboring subsets of homes H, so that Epeak can be optimized independently within each subset. These coalitions can be exploited by a distributed algorithm to (1) parallelize computations between multiple groups and (2) avoid data exposure over long distances or sensitive areas. Finally, constraint (10) defines the valid trajectories for each scheduling rule r ∈ Ri, where Ri is the set of all scheduling rules of home hi."
    }, {
      "heading" : "2.6 DCOP Mapping",
      "text" : "One can map the SHDS problem to a DCOP as follows: • AGENTS: Each agent ai ∈ A in the DCOP is mapped to a home hi ∈ H. • VARIABLES and DOMAINS: Each agent ai controls the following set of variables:\n• For each actuator z ∈ Ai and each time step t ∈ T, a variable xti,z whose domain is the set of actions in Az . The sensors in Si are considered to be always active, and thus not directly controlled by the agent. • An auxiliary interface variable x̂tj whose domain is the set {0, . . . , ∑ z∈Zi ρ(argmaxa∈Az ρz(a))}, which represents the aggregated en-\nergy consumed by all the devices in the home at each time step t. • CONSTRAINTS: There are three types of constraints: • Local soft constraints (i.e., constraints that involve only variables controlled by the\nagent) whose costs correspond to the weighted summation of monetary costs, as defined in Equation (8).\n• Local hard constraints that enforce Constraint (10). Feasible schedules incur a cost of 0 while infeasible schedules incur a cost of∞.\n• Global soft constraints (i.e., constraints that involve variables controlled by different agents) whose costs correspond to the peak energy consumption, as defined in the second term in Equation (9)."
    }, {
      "heading" : "3 Model Parameters and Realistic Data Set Generation",
      "text" : "This section describes the parameters and models adopted in our SHDS datasets generation. We first describe the house structural parameters, which are used in turn to calculate the house predictive models. Next, we report a detailed list of the smart devices adopted in our datasets, discussing their power consumptions and effects on the house environments. We then describe the predictive models adopted to capture changes in the house’s environments and devices’ states. Finally, we report the BNF for the scheduling rules introduced in Section 2.3, and the pricing scheme adopted in our experiments."
    }, {
      "heading" : "3.1 House Structural Parameters",
      "text" : "We consider three house sizes (small, medium, and large). The floor plans for three house structures are shown in Figure 2. Our house structural model simplifies the floor plans shown in Figure 2 by ignoring internal walls. This abstraction is sufficient to capture the richness of the predictive models introduced in Section 2.4. Table 1 reports the parameters of the houses adopted in our SHDS dataset. The house sizes are expressed in meters (L ×W ). The walls height is assumed to be 2.4m and the window area denotes the area of the walls covered by windows. The overall heat transfer coefficient\n(also referred to as U-value) describes how well a building element conducts heat. It is defined as the rate of heat transfer (in watts) through one unit area (m2) of a structure divided by the difference in temperature across the structure [17].\nThe walls material is considered to be a 150mm poured concrete (1280 kg/m3) with a Heat-Transfer Coefficient (Uwalls) of 3.9 Wm2· ◦ C . We consider vertical double glazed windows, with distance between glasses 30− 60mm whose Heat-Transfer Coefficient (Uwindows) is 2.8 Wm2· ◦ C . Additionally, we consider a 2.54 cm wood roof with 2.54 cm insulation, with Heat-Transfer Coefficient (Uroof) of 1.1 Wm2· ◦ C . Finally, we consider a 5.08 cm wood door, with Heat-Transfer Coefficient of 2.6 Wm2· ◦ C . These are commonly adopted materials in the US house construction industry [17]. We assume a background load consumption which account of a medium-size refrigerator (120W ), a wireless router (6W ), and a set of light bulbs (collectively 40W ) [17]. The heat gain from the background house appliances is computed according to [17](Table 9.8). We consider the heat gain from people within the house, and computed as in [17](Table 9.7), assuming a metabolic rate as light office work."
    }, {
      "heading" : "3.2 Smart Devices",
      "text" : "In this section we report the complete list of smart devices (sensors and actuators) adopted by the smart homes in our SHDS datasets. Sensors Table 2 reports the sensors adopted in our SHDS problem. For each sensor, we report an identifier (ID), the state property (see Section 2.1) it senses, and its location in the house. All sensors are considered to be constantly active, sensing a single state property at a location (e.g., an air temperature sensor is located in a house room, a charge sensor is located on a device). Actuators Table 3 reports the list of the actuators. It tabulates the type of actuator and its model, its possible actions, the power consumption (in kWh), the state properties affected by each of its action, and the effects (∆) on the associated predictive models in the small, medium, and large house sizes. The latter represent the incremental quantity which affects the physical system, given the action of the actuator, as defined in Equation 4. We detail the calculation of the house and devices physical models below."
    }, {
      "heading" : "3.3 Physical models",
      "text" : "In this section we describe the physical models used to compute the effects values ∆ of the actuators’ actions on a predictive model (see Table 3). These values, in turn, are adopted within the SHDS predictive models as described in Equation (4). Battery (Dis)charge Model The battery charge/discharge model we adopt for our battery-powered devices is as follows. For a given battery bwith capacityQb (expressed in KWh), voltage Vb, and electric charge Eb = VbQb (expressed in ampere-hour (Ah)), and assuming a 100% charging/discharging efficiency, the battery charge time b+α and discharge time b−α are computed respectively as:\nb+α = Eb C+ ; b−α = Eb C− , (11)\nexpressed in hours, where C+ and C− are, respectively, the charging amperage and the in-use amperage. Following https://goo.gl/l5TGtz and https://goo.gl/ NmO0fY we report the battery parameters for our Electric Vehicle and robotic vacuum cleaner in Table 4. The devices’ action effects ∆ for charging and discharging time are computed by dividing the total charging and discharging times by |T|. Air Temperature Model The air temperature predictive model is computed following standard principle of heating and ventilation [17] and described as follows. Let G be the ventilation conductance: G = V̇ ·ρa · h̄,where V̇ is the volume flow rate, set to 100, ρa is the density of the air, set to 0.75, and h̄ is the specific heat of the air, set to 0.24 following [17]. The house heat loss coefficient hloss is:\nhloss = Uwalls ·Awalls + Uroof ·Aroof + Uwindows ·Awindows +G (12)\nwhere Uwalls, Uroof, and Uwindows are respectively, the heat transfer coefficients for the walls, roof, and windows of the house, and Awalls, Aroof, and Awindows are respectively the the areas for walls, roof, and windows. Their values are provided in Table 1. Let TA and TZ be the current and a target temperatures; the heating load L̇h is given by:\nL̇h = hloss|TZ − TA| (13)\nThe heating load defines the quantity of heat per unit time (in BTU) that must be supplied in a building to reach the target temperature TZ , from the given temperature TA. Given the heating load L̇h and the heater capacity C of a heater/cooler, the time the device needs to run to reach the desired temperature is given by: LhC . Heating or cooling load is also effected by the outdoor and indoor temperature difference. Consider the example where TA = 12◦C and TZ = 22◦C, and the outdoor temperature changes from TA to TN = 8◦C. We can calculate the new load due to change in temperature by the following relationship given below:\nL̇n = L̇h · |TZ − TN | |TZ − TA|\n(14)\nThe above expression shows that an outdoor temperature drops of 4◦C, causes the heating load to increase by a factor of 1.4 (w.r.t. the previous heating load TA). In our model we need to compute the change in temperature per time step (∆). This can be done using the heat loss relationship:\n∆ = hloss m · cp\n(15)\nwherem is the mass of the air and cp is the specific heat of air. In our model,m depends on volume flow rate of an air in the house, and cp = 1KJ/Kg ·K. Water Temperature Model The rise in the water temperature per unit of time (∆ value) is dependent on the difference in the water temperature flowing into the water heater and the amount of water flowing out of the water heater, as well as water usage We considered a gas-fired demand water heater(tankless). The water usage depends on household size and multiple user activities To calculate the water temperature, in our model, we used the highest potential peak water usage following [2,4], and corresponding to 26.50 liters/min (small house), 29.34 liters/min (medium house), and 38.38 liters/min (large house). The rise in temperature is 39◦C for 18.93 liters/minute of water usage [2]. Thus the rise in temperature for our small, medium, and large house, are, respectively, 27.9◦C, 25.2◦C, and 19.2◦C.\nCleanliness Model Our floor cleanliness model is computed by using the equation: T = A0.313 where, A represents the area of the room (in m\n2) and T is the amount of time (in minutes) it takes the robotic vacuum cleaner to vacuum the entire room. Consumer reports found that it took 57 minutes for the Roomba to clean a 17.84 m2 room [1] (which is approximately 0.313m2/min). In our experiment’s datasets we use three different areas. Asmall = 48, Amedium = 96, and Alarge = 180. Thus the the estimated times to cover a 100% floor for the small, medium, and large houses are, repsectively: T = 153.35, 306.71, and 575.08 minutes. The corresponding ∆ value of Table 3 (which is a percentage) is computed as: ∆ = 100%T\nAll other predictive models (e.g., laundry wash and dry, bake, dish cleanliness, etc.) simply capture the time needed for a device to achieve the required goals by checking that accumulated device effects achieves the desired property. This is discussed in the dataset generation, in Section 4."
    }, {
      "heading" : "3.4 Scheduling Rules",
      "text" : "We report, as follows, the complete Backus-Naur Form (BNF) for the scheduling rules for a smart home hi ∈ H, introduced in Section 2.2\n〈rules〉 ....= 〈simple rule〉 | 〈simple rule〉 ∧ 〈rules〉 〈simple rule〉 ....= 〈active rule〉 | 〈passive rule〉 〈active rule〉 ....= 〈location〉〈state property〉〈relation〉〈goal state〉〈time〉 〈passive rule〉 ....= 〈location〉〈state property〉〈relation〉〈goal state〉 〈location〉 ....= ` ∈ Li\n〈state property〉 ....= s ∈ PH | s ∈ PZ 〈relation〉 ....= ≤ | < | = | 6= | > | ≥ 〈goal state〉 ....= sensor state | actuator state\n〈time〉 ....= at 〈T〉 | before 〈T〉 | after 〈T〉 | within [〈T〉, 〈T〉] | for 〈T〉 time units 〈T〉 ....= t ∈ T\nIn our dataset the device states are mapped to numeric values, i.e., Ωp = N, for all p ∈ PH ∪PZ ."
    }, {
      "heading" : "3.5 Pricing Schema",
      "text" : "For the evaluation of our SHDS datasets we adopted a pricing schema used by the Pacific Gas & Electric Co. for its customers in parts of California,3 which accounts for 7 tiers ranging from $0.198 per kWh to $0.849 per kWh, reported in Table 5\n3 https://goo.gl/vOeNqj"
    }, {
      "heading" : "4 SHDS Dataset",
      "text" : "We now introduce a dataset for the SHDS problem for DCOPs. We generate synthetic microgrid instances sampling neighborhoods in three cities in the United States (Des Moines, IA; Boston, MA; and San Francisco, CA) and estimate the density of houses in each city. The average density (in houses per square kilometers) is 718 in Des Moines, 1357 in Boston, and 3766 in San Francisco. For each city, we created a 200m×200m grid, where the distance between intersections is 20m, and randomly placed houses in this grid until the density is the same as the sampled density. We then divided the city into k (=|H|) coalitions, where each home can communicate with all homes in its coalition. Finally, we ensure that there no two coalitions are disjoint. Tables 9, 10, and 11 report, respectively, the Des Moines, Boston, and San Francisco instances, where we vary (i) the number of agents (n)—up to 1883 for the largest instances—, (ii) the number of coalitions (k), and (iii) the number of actuators within each home m.\nEach home device has an associated active scheduling rule that is randomly generated, and a number of passive rules that must always hold. The parameters to generate active and passive rules are reported, respectively, in Table 6 and Table 7. The time predicates for these rules are generated at random within the given horizon. Additionally, the relations r and goals states gi are randomly generated sampling from the sets corresponding, respectively, to the columns 〈relation〉 and 〈goal state〉 of Table 6.\nWe generate a total of 2351 problem instances (available at: https://github. com/persoon/SHDS_dataset). We set H = 12, and report in Table 8 a summary of the parameters’ settings for our smart homes physical models.\nAdditionally, we provide upper bounds (in the obj column) for each for the instances (Tables 9, 10, and 11 report a subset of the SHDS dataset) by solving an uncoordinated\nDCOP, where each agent reports its best schedule found with a local Constraint Programming solver4 as subroutine, within a 10 seconds timeout."
    }, {
      "heading" : "5 Conclusions",
      "text" : "With the proliferation of smart devices, the automation of smart home scheduling can be a powerful tool for demand-side management within the smart grid vision. In this paper\n4 We adopt the JaCoP solver (http://www.jacop.eu/)\nwe proposed the Smart Home Device Scheduling (SHDS) problem, which formalizes the device scheduling and coordination problem across multiple smart homes as a multi-\nagent system, and its mapping to a DCOP. Furthermore, we described in great details the physical models adopted to model the smart home’s sensors and actuators, as well as the physical model regulating the effect of the devices actions on the house environments properties (e.g., temperature, cleanliness). Finally, we reported a realistic dataset for the SHDS problem for DCOPs which includes 2351 instances of increasing difficulty."
    } ],
    "references" : [ {
      "title" : "Decentralised coordination of low-power embedded devices using the Max-Sum algorithm",
      "author" : [ "A. Farinelli", "A. Rogers", "A. Petcu", "N. Jennings" ],
      "venue" : "In AAMAS, pages 639–646,",
      "citeRegEx" : "5",
      "shortCiteRegEx" : null,
      "year" : 2008
    }, {
      "title" : "A dynamic programming-based MCMC framework for solving DCOPs with GPUs",
      "author" : [ "F. Fioretto", "W. Yeoh", "E. Pontelli" ],
      "venue" : "In Proceedings of the International Conference on Principles and Practice of Constraint Programming (CP), pages 813–831,",
      "citeRegEx" : "6",
      "shortCiteRegEx" : null,
      "year" : 2016
    }, {
      "title" : "A multiagent system approach to scheduling devices in smart homes",
      "author" : [ "F. Fioretto", "W. Yeoh", "E. Pontelli" ],
      "venue" : "In AAMAS, page (to appear),",
      "citeRegEx" : "7",
      "shortCiteRegEx" : null,
      "year" : 2017
    }, {
      "title" : "Asynchronous Forward-Bounding for distributed COPs",
      "author" : [ "A. Gershman", "A. Meisels", "R. Zivan" ],
      "venue" : "JAIR, 34:61–88,",
      "citeRegEx" : "8",
      "shortCiteRegEx" : null,
      "year" : 2009
    }, {
      "title" : "Distributed partial constraint satisfaction problem",
      "author" : [ "K. Hirayama", "M. Yokoo" ],
      "venue" : "In CP, pages 222–236,",
      "citeRegEx" : "9",
      "shortCiteRegEx" : null,
      "year" : 1997
    }, {
      "title" : "Solving distributed constraint optimization problems using cooperative mediation",
      "author" : [ "R. Mailler", "V. Lesser" ],
      "venue" : "In AAMAS, pages 438–445,",
      "citeRegEx" : "10",
      "shortCiteRegEx" : null,
      "year" : 2004
    }, {
      "title" : "ADOPT: Asynchronous distributed constraint optimization with quality guarantees",
      "author" : [ "P. Modi", "W.-M. Shen", "M. Tambe", "M. Yokoo" ],
      "venue" : "AIJ, 161(1–2):149–180,",
      "citeRegEx" : "11",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "Distributed Gibbs: A memory-bounded samplingbased DCOP algorithm",
      "author" : [ "D.T. Nguyen", "W. Yeoh", "H.C. Lau" ],
      "venue" : "In AAMAS, pages 167–174,",
      "citeRegEx" : "12",
      "shortCiteRegEx" : null,
      "year" : 2013
    }, {
      "title" : "DUCT: An upper confidence bound approach to distributed constraint optimization problems",
      "author" : [ "B. Ottens", "C. Dimitrakakis", "B. Faltings" ],
      "venue" : "In AAAI, pages 528–534,",
      "citeRegEx" : "13",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Quality guarantees on k-optimal solutions for distributed constraint optimization problems",
      "author" : [ "J. Pearce", "M. Tambe" ],
      "venue" : "In IJCAI, pages 1446–1451,",
      "citeRegEx" : "14",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "A scalable method for multiagent constraint optimization",
      "author" : [ "A. Petcu", "B. Faltings" ],
      "venue" : "In IJCAI, pages 1413–1420,",
      "citeRegEx" : "15",
      "shortCiteRegEx" : null,
      "year" : 2005
    }, {
      "title" : "PC-DPOP: A new partial centralization algorithm for distributed optimization",
      "author" : [ "A. Petcu", "B. Faltings", "R. Mailler" ],
      "venue" : "In IJCAI, pages 167–172,",
      "citeRegEx" : "16",
      "shortCiteRegEx" : null,
      "year" : 2007
    }, {
      "title" : "Principles of Heating, Ventilation and Air Conditioning in Buildingss",
      "author" : [ "J.E.M.J. W", "Braun" ],
      "venue" : null,
      "citeRegEx" : "17",
      "shortCiteRegEx" : "17",
      "year" : 2012
    }, {
      "title" : "Distributed problem solving",
      "author" : [ "W. Yeoh", "M. Yokoo" ],
      "venue" : "AI Magazine, 33(3):53–65,",
      "citeRegEx" : "18",
      "shortCiteRegEx" : null,
      "year" : 2012
    }, {
      "title" : "Distributed stochastic search and distributed breakout: Properties, comparison and applications to constraint optimization problems in sensor networks",
      "author" : [ "W. Zhang", "G. Wang", "Z. Xing", "L. Wittenberg" ],
      "venue" : "AIJ, 161(1–2):55–87,",
      "citeRegEx" : "19",
      "shortCiteRegEx" : null,
      "year" : 2005
    } ],
    "referenceMentions" : [ {
      "referenceID" : 6,
      "context" : "Distributed Constraint Optimization Problems (DCOPs) [11,15,18] have emerged as one of the prominent agent models to govern the agents’ autonomous behavior, where both algorithms and communication models are driven by the structure of the specific problem.",
      "startOffset" : 53,
      "endOffset" : 63
    }, {
      "referenceID" : 10,
      "context" : "Distributed Constraint Optimization Problems (DCOPs) [11,15,18] have emerged as one of the prominent agent models to govern the agents’ autonomous behavior, where both algorithms and communication models are driven by the structure of the specific problem.",
      "startOffset" : 53,
      "endOffset" : 63
    }, {
      "referenceID" : 13,
      "context" : "Distributed Constraint Optimization Problems (DCOPs) [11,15,18] have emerged as one of the prominent agent models to govern the agents’ autonomous behavior, where both algorithms and communication models are driven by the structure of the specific problem.",
      "startOffset" : 53,
      "endOffset" : 63
    }, {
      "referenceID" : 4,
      "context" : ", partial centralization) [9,10,16], the way local information is updated (e.",
      "startOffset" : 26,
      "endOffset" : 35
    }, {
      "referenceID" : 5,
      "context" : ", partial centralization) [9,10,16], the way local information is updated (e.",
      "startOffset" : 26,
      "endOffset" : 35
    }, {
      "referenceID" : 11,
      "context" : ", partial centralization) [9,10,16], the way local information is updated (e.",
      "startOffset" : 26,
      "endOffset" : 35
    }, {
      "referenceID" : 5,
      "context" : ", synchronous [10,14,15] or asynchronous [5,8,11]), and the type of exploration process adopted (e.",
      "startOffset" : 14,
      "endOffset" : 24
    }, {
      "referenceID" : 9,
      "context" : ", synchronous [10,14,15] or asynchronous [5,8,11]), and the type of exploration process adopted (e.",
      "startOffset" : 14,
      "endOffset" : 24
    }, {
      "referenceID" : 10,
      "context" : ", synchronous [10,14,15] or asynchronous [5,8,11]), and the type of exploration process adopted (e.",
      "startOffset" : 14,
      "endOffset" : 24
    }, {
      "referenceID" : 0,
      "context" : ", synchronous [10,14,15] or asynchronous [5,8,11]), and the type of exploration process adopted (e.",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 3,
      "context" : ", synchronous [10,14,15] or asynchronous [5,8,11]), and the type of exploration process adopted (e.",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 6,
      "context" : ", synchronous [10,14,15] or asynchronous [5,8,11]), and the type of exploration process adopted (e.",
      "startOffset" : 41,
      "endOffset" : 49
    }, {
      "referenceID" : 4,
      "context" : ", search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).",
      "startOffset" : 15,
      "endOffset" : 24
    }, {
      "referenceID" : 6,
      "context" : ", search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).",
      "startOffset" : 15,
      "endOffset" : 24
    }, {
      "referenceID" : 14,
      "context" : ", search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).",
      "startOffset" : 15,
      "endOffset" : 24
    }, {
      "referenceID" : 10,
      "context" : ", search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).",
      "startOffset" : 42,
      "endOffset" : 48
    }, {
      "referenceID" : 0,
      "context" : ", search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).",
      "startOffset" : 42,
      "endOffset" : 48
    }, {
      "referenceID" : 8,
      "context" : ", search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).",
      "startOffset" : 68,
      "endOffset" : 77
    }, {
      "referenceID" : 7,
      "context" : ", search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).",
      "startOffset" : 68,
      "endOffset" : 77
    }, {
      "referenceID" : 1,
      "context" : ", search-based [9,11,19], inference-based [15,5], or sampling-based [13,12,6]).",
      "startOffset" : 68,
      "endOffset" : 77
    }, {
      "referenceID" : 2,
      "context" : "Motivated by these issues, we recently introduced the Smart Home Device Scheduling (SHDS) problem [7], which formalizes the problem of coordinating smart devices ar X iv :1 70 2.",
      "startOffset" : 98,
      "endOffset" : 101
    }, {
      "referenceID" : 6,
      "context" : "DCOP A Distributed Constraint Optimization Problem (DCOP) [11,18] is described by a tuple 〈X ,D,F ,A, α〉, where: X = {x1, .",
      "startOffset" : 58,
      "endOffset" : 65
    }, {
      "referenceID" : 13,
      "context" : "DCOP A Distributed Constraint Optimization Problem (DCOP) [11,18] is described by a tuple 〈X ,D,F ,A, α〉, where: X = {x1, .",
      "startOffset" : 58,
      "endOffset" : 65
    }, {
      "referenceID" : 12,
      "context" : "It is defined as the rate of heat transfer (in watts) through one unit area (m) of a structure divided by the difference in temperature across the structure [17].",
      "startOffset" : 157,
      "endOffset" : 161
    }, {
      "referenceID" : 12,
      "context" : "These are commonly adopted materials in the US house construction industry [17].",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 12,
      "context" : "We assume a background load consumption which account of a medium-size refrigerator (120W ), a wireless router (6W ), and a set of light bulbs (collectively 40W ) [17].",
      "startOffset" : 163,
      "endOffset" : 167
    }, {
      "referenceID" : 12,
      "context" : "The heat gain from the background house appliances is computed according to [17](Table 9.",
      "startOffset" : 76,
      "endOffset" : 80
    }, {
      "referenceID" : 12,
      "context" : "We consider the heat gain from people within the house, and computed as in [17](Table 9.",
      "startOffset" : 75,
      "endOffset" : 79
    }, {
      "referenceID" : 12,
      "context" : "Air Temperature Model The air temperature predictive model is computed following standard principle of heating and ventilation [17] and described as follows.",
      "startOffset" : 127,
      "endOffset" : 131
    }, {
      "referenceID" : 12,
      "context" : "24 following [17].",
      "startOffset" : 13,
      "endOffset" : 17
    }, {
      "referenceID" : 9,
      "context" : "Room air temperature r ∈ {≤, <,=, >,≥} g1 ∈ [14, 28] 〈time〉 Room floor cleanliness r ∈ {=, >,≥} g2 ∈ [0, 100] 〈time〉",
      "startOffset" : 44,
      "endOffset" : 52
    }, {
      "referenceID" : 5,
      "context" : "Electric Vehicle charge r ∈ {=, >,≥} g3 ∈ [0, 100] 〈time〉 Water heater temperature r ∈ {≤, <,=, >,≥} g4 ∈ [10, 45] 〈time〉",
      "startOffset" : 106,
      "endOffset" : 114
    } ],
    "year" : 2017,
    "abstractText" : "The field of Distributed Constraint Optimization has gained momentum in recent years thanks to its ability to address various applications related to multi-agent cooperation. While techniques to solve Distributed Constraint Optimization Problems (DCOPs) are abundant and have matured substantially since the field inception, the number of DCOP realistic applications and benchmark used to asses the performance of DCOP algorithms is lagging behind. To contrast this background we (i) introduce the Smart Home Device Scheduling (SHDS) problem, which describe the problem of coordinating smart devices schedules across multiple homes as a multi-agent system, (ii) detail the physical models adopted to simulate smart sensors, smart actuators, and homes environments, and (iii) introduce a DCOP realistic benchmark for SHDS problems.",
    "creator" : "LaTeX with hyperref package"
  }
}