{
  "name" : "1405.0809.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Implementing Default and Autoepistemic Logics via the Logic of GK",
    "authors" : [ "Jianmin Ji", "Hannes Strass" ],
    "emails" : [ ],
    "sections" : [ {
      "heading" : "Introduction",
      "text" : "Lin and Shoham [1992] proposed a logic with two modal operators K and A, standing for knowledge and assumption, respectively. The idea is that one starts with a set of assumptions (those true under the modal operator A), computes the minimal knowledge under this set of assumptions, and then checks to see if the assumptions were justified in that they agree with the resulting minimal knowledge. For instance, consider the GK formula Ap ⊃ Kp. If we assume p, then we can conclude that we know p, thus the assumption that p holds is justified, and we get a GK model where both Ap and Kp are true. (There is another GK model where we do not assume p and hence do not know p.) However, there is no GK model of ¬Ap ⊃ Kp: if we do not assume p, we are forced to conclude Kp, but then knowledge and assumptions do not coincide; if we do assume p, we cannot conclude that we know p and thus assuming p was not justified.\nTo date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner’s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011]. Among other things, these embeddings shed new light on nonmonotonic reasoning, and have led to an interesting characterization of strong equivalence in\nlogic programming [Lin, 2002; Lin and Zhou, 2011], and helped relate logic programming to circumscription [Lin and Shoham, 1992] as the semantics of GK is just a minimization (of knowledge) together with an identity check (of assumptions and knowledge) after the minimization.\nIn this paper, for the first time, we consider computing models of GK theories by disjunctive logic programs. We shall propose a polynomial translation from a (pure) GK theory to a disjunctive logic program such that there is a one-to-one correspondence between GK models of the GK theory and answer sets of the resulting disjunctive logic program. The result can then be used to compute the extension/expansion semantics of default logic, autoepistemic logic and Turner’s logic of universal causation by disjunctive ASP solvers such as GNT [Janhunen and Niemelä, 2004], cmodels [Giunchiglia, Lierler, and Maratea, 2006], DLV [Leone et al., 2006], claspD [Drescher et al., 2008] and claspD-2 [Gebser, Kaufmann, and Schaub, 2013]. In particular, the recent advances in disjunctive answer set solving [Gebser, Kaufmann, and Schaub, 2013] open up promising research avenues towards applications of expressive nonmonotonic knowledge representation languages.\nTo substantiate this claim, we have implemented the translation and report on some preliminary experiments that we conducted on the special case of computing extensions for Reiter’s default logic [Reiter, 1980]. The implementation, called gk2dlp, is available for download from the second author’s home page.1\nProviding implementations for theoretical formalisms has a long tradition in nonmonotonic reasoning, for an overview see [Dix, Furbach, and Niemelä, 2001]. In fact, nonmonotonic reasoning itself originated from a desire to more accurately model the way humans reason, and was since its conception driven by applications in commonsense reasoning [McCarthy, 1980, 1986]. Today, thanks to extensive research efforts, we know how closely interrelated the different formalisms for nonmonotonic reasoning are, and can use this knowledge to improve the scope of implementations.\nThis paper is organized as follows. Section 2 reviews logic programs, the logic of GK and default and autoepistemic logics. Section 3 presents our main result, the map-\n1http://informatik.uni-leipzig.de/˜strass/ gk2dlp/\nar X\niv :1\n40 5.\n08 09\nv1 [\ncs .A\nI] 5\nM ay\n2 01\n4\nping from GK to disjunctive logic programming. Section 4 presents our prototypical implementation, several experiments we conducted to analyze the translation, possible applications for it, and a comparison with previous and related work. Section 5 concludes with ideas for future work."
    }, {
      "heading" : "Preliminaries",
      "text" : "We assume a propositional language with two zero-place logical connectives > for tautology and ⊥ for contradiction. We denote by Atom the set of atoms, the signature of our language, and Lit the set of literals: Lit = Atom ∪ {¬p | p ∈ Atom}. A set I of literals is called complete if for each atom p, exactly one of {p,¬p} is in I .\nIn this paper, we identify an interpretation with a complete set of literals. If I is a complete set of literals, we use it as an interpretation when we say that it is a model of a formula, and we use it as a set of literals when we say that it entails a formula. In particular, we denote by Th(I) the logical closure of I (considered to be a set of literals)."
    }, {
      "heading" : "Logic Programming",
      "text" : "A nested expression is built from literals using the 0-place connectives > and ⊥, the unary connective “not” and the binary connectives “,” and “;” for conjunction and disjunction. A logic program with nested expressions is a finite set of rules of the form F ← G, where F and G are nested expressions. The answer set of a logic program with nested expressions is defined as in [Lifschitz, Tang, and Turner, 1999]. Given a nested expression F and a set S of literals, we define when S satisfies F , written S |= F below, recursively as follows (l is a literal):\n• S |= l if l ∈ S, • S |= > and S 6|= ⊥, • S |= not F if S 6|= F , • S |= F,G if S |= F and S |= G, and • S |= F ;G if S |= F or S |= G. S satisfies a rule F ← G if S |= F whenever S |= G. S satisfies a logic program P , written S |= P , if S satisfies all rules in P .\nThe reduct PS of P related to S is the result of replacing every maximal subexpression of P that has the form not F with ⊥ if S |= F , and with > otherwise. For a logic program P without not, the answer set of P is any minimal consistent subset S of Lit that satisfies P . We use ΓP (S) to denote the set of answer sets of PS . Now a consistent set S of literals is an answer set of P iff S ∈ ΓP (S). Every logic program with nested expressions can be equivalently translated to disjunctive logic programs with disjunctive rules of the form\nl1; · · · ; lk ←lk+1, . . . , lt, not lt+1, . . . , not lm, not not lm+1, . . . , not not ln\nwhere n ≥ m ≥ t ≥ k ≥ 0 and l1, . . . , ln are propositional literals."
    }, {
      "heading" : "Default Logic",
      "text" : "Default logic [Reiter, 1980] is for making and withdrawing assumptions in the light of incomplete knowledge. This is done by defaults, that allow to express rules of thumb such as “birds usually fly” and “tools usually work.” For a given logical language, a default is any expression of the form φ : ψ1, . . . , ψn/ϕ where φ, ψ1, . . . , ψn, ϕ are formulas of the underlying language. A default theory is a pair (W,D), where W is a set of formulas and D is a set of defaults. The meaning of default theories is given through the notion of extensions. An extension of a default theory (W,D) is “interpreted as an acceptable set of beliefs that one may hold about the incompletely specified world W ” [Reiter, 1980]. For a default theory (W,D) and any set S of formulas let Γ(S) be the smallest set satisfying (1) W ⊆ Γ(S), (2) Th(Γ(S)) = Γ(S), (3) If φ : ψ1, . . . , ψn/ϕ ∈ D, φ ∈ Γ(S) and ¬ψ1, . . . ,¬ψn /∈ S, then ϕ ∈ Γ(S). A set E of formulas is called an extension for (W,D) iff Γ(E) = E."
    }, {
      "heading" : "Autoepistemic Logic",
      "text" : "Moore [1985] strives to formalize an ideally rational agent reasoning about its own beliefs. He uses a belief modality L to explicitly refer to the agent’s belief within the language. Given a set A of formulas (the initial beliefs), a set T is an expansion of A if it coincides with the deductive closure of the set A ∪ {Lϕ | ϕ ∈ T} ∪ {¬Lϕ | ϕ /∈ T}. In words, T is an expansion if it equals what can be derived using the initial beliefs A and positive and negative introspection with respect to T itself. It was later discovered that this definition of expansions allows unfounded, self-justifying beliefs. Such beliefs are however not always desirable when representing the knowledge of agents."
    }, {
      "heading" : "The Logic of GK",
      "text" : "The language of GK proposed by Lin and Shoham [1992] is a modal propositional language with two modal operators, K, for knowledge, and A, for assumption. GK formulas ϕ are propositional formulas with K and A, that is,\nϕ ::= ⊥ | p | ¬ϕ | ϕ ∧ ϕ | ϕ ∨ ϕ | Kϕ | Aϕ\nwhere p is an atom. A GK theory is a set of GK formulas. GK is a nonmonotonic logic, and its semantics is defined using the standard Kripke possible world interpretations. Informally speaking, a GK model is a Kripke interpretation where what is true under K is minimal and exactly the same as what is true under A. The intuition here is that given a GK formula, one first makes some assumptions (those true under A), then one minimizes the knowledge thus entailed, and finally checks to make sure that the initial assumption is justified in the sense that the minimal knowledge is the same as the initial assumption.\nFormally, a Kripke interpretation M is a tuple 〈W,π,RK , RA, s〉, where W is a nonempty set of possible worlds, π a function that maps a possible world to an interpretation, RK and RA binary relations over W representing the accessibility relations for K and A, respectively, and s ∈W , called the actual world of M . The satisfaction relation |= between a Kripke interpretation\nM = 〈W,π,RK , RA, s〉 and a GK formula ϕ is defined in a standard way:\n• M 6|= ⊥, • M |= p iff p ∈ π(s), where p is an atom, • M |= ¬ϕ iff M 6|= ϕ, • M |= ϕ ∧ ψ iff M |= ϕ and M |= ψ, • M |= ϕ ∨ ψ iff M |= ϕ or M |= ψ, • M |= Kϕ iff 〈W,π,RK , RA, w〉 |= ϕ for any w ∈ W\nsuch that (s, w) ∈ RK , • M |= Aϕ iff 〈W,π,RK , RA, w〉 |= ϕ for any w ∈ W\nsuch that (s, w) ∈ RA. Note that for any w ∈W , π(w) is an interpretation. We say that a Kripke interpretationM is a model of a GK formula ϕ if M satisfies ϕ, M is a model of a GK theory T if M satisfies every GK formula in T . In the following, given a Kripke interpretation M , we let\nK(M) = {φ | φ is a propositional formula and M |= Kφ }, A(M) = {φ | φ is a propositional formula and M |= Aφ }.\nNotice that K(M) and A(M) are always closed under classical logical entailment – they are propositional theories.\nGiven a GK formula T , a Kripke interpretation M is a minimal model of T ifM is a model of T and there does not exist another model M1 of T such that A(M1) = A(M) and K(M1) ( K(M). We say that M is a GK model of T if M is a minimal model of T and K(M) = A(M).\nIn this paper, we consider only GK formulas that do not contain nested occurrences of modal operators. Specifically, an A-atom is a formula of the form Aφ and a K-atom is a formula of the form Kφ, where φ is a propositional formula. A GK formula is called a pure GK formula if it is formed from A-atoms, K-atoms and propositional connectives. Similarly, a pure GK theory is a set of pure GK formulas. Given a pure GK formula F , we denote\nAtomK(F ) = {φ | Kφ is a K-atom occurring in F }, AtomA(F ) = {φ | Aφ is an A-atom occurring in F }.\nFor a pure GK theory T , we use AtomK(T ) =⋃ F∈T AtomK(F ) and AtomA(T ) = ⋃ F∈T AtomA(F ) to denote their modal atoms. So far, the applications of the logic of GK only ever use pure GK formulas. We now present some embeddings of well-known nonmonotonic knowledge representation languages into the logic of GK.\nDefault logic A (propositional) default theory ∆ = (W,D) (under extension semantics) is translated into pure GK formulas in the following way: (1) Translate each φ ∈ W to Kφ; (2) translate each (φ : ψ1, . . . , ψn/ϕ) ∈ D to Kφ ∧ ¬A¬ψ1 ∧ · · · ∧ ¬A¬ψn ⊃ Kϕ. For the weak extension semantics, a default (φ : ψ1, . . . , ψn/ϕ) ∈ D is translated to Aφ ∧ ¬A¬ψ1 ∧ · · · ∧ ¬A¬ψn ⊃ Kϕ. Autoepistemic logic An L-sentence of autoepistemic logic that is in normal form [Konolige, 1988], that is, a disjunction of the form ¬Lφ ∨ Lψ1 ∨ · · · ∨ Lψn ∨ ϕ,\nis (under expansion semantics) expressed as Aφ ∧ ¬Aψ1 ∧ · · · ∧ ¬Aψn ⊃ Kϕ. For strong expansion semantics, it becomes Kφ ∧ ¬Aψ1 ∧ · · · ∧ ¬Aψn ⊃ Kϕ.\nNotice that the translation of default and autoepistemic theories into the logic of GK is compatible with Konolige’s translation from default logic into autoepistemic logic [Konolige, 1988]. Indeed, Konolige’s translation perfectly aligns the weak extension semantics of default logic with expansion semantics for autoepistemic logic, and likewise for extension and strong expansion semantics [Denecker, Marek, and Truszczyński, 2003].\nLogic of universal causation The logic of universal causation is a nonmonotonic propositional modal logic with one modality C [Turner, 1999]. A formula of this logic is translated to the pure logic of GK by replacing every occurrence of C by K, adding A before each atom which is not in the range of C in it, and adding Ap∨A¬p for each atom p. For example, if a UCL formula is (p ∧ ¬q) ⊃ C(p ∧ ¬q) and Atom = {p, q}, then the corresponding pure GK formula is ((Ap ∧ ¬Aq) ⊃ K(p ∧ ¬q))∧(Ap∨A¬p)∧(Aq∨A¬q). Disjunctive logic programs A disjunctive LP rule\np1 ∨ · · · ∨ pk ← pk+1, . . . , pl, not pl+1, . . . , not pm,\nwhere p’s are atoms, corresponds to the pure GK formula:\nKpk+1∧· · ·∧Kpl∧¬Apl+1∧· · ·∧¬Apm ⊃ Kp1∨· · ·∨Kpk"
    }, {
      "heading" : "Main Result: From Pure GK to Disjunctive ASP",
      "text" : "Before presenting the translation, we introduce some notations. Let F be a pure GK formula, we use trp(F ) to denote the propositional formula obtained from F by replacing each occurrence of a K-atom Kφ by kφ and each occurrence of an A-atom Aψ by aψ , where kφ and aψ are new atoms with respect to φ and ψ respectively. For a pure GK theory T , we define trp(T ) = ∧ F∈T trp(F ). To illustrate these and the definitions that follow, we use a running example.\nExample 1 (Normal Reiter default) Consider the pure GK theory {F} with F = ¬A¬p ⊃ Kp corresponding to the default > : p/p, and another pure GK theory {F,G} with G = K¬p corresponding to the default > : >/¬p. Then trp({F}) = ¬a¬p ⊃ kp and trp({F,G}) = (¬a¬p ⊃ kp) ∧ k¬p, where a¬p, kp, and k¬p are new atoms.\nHere we introduce a set of new atoms kφ and aψ for each formula φ ∈ AtomK(T ) and ψ ∈ AtomA(T ). Intuitively, the new atom kφ (resp. aψ) will be used to encode containment of the formula φ in K(M) (resp. A(M)) of a GK model M for T .\nGiven a propositional formula φ and an atom a, we use φa to denote the propositional formula obtained from φ by replacing each occurrence of an atom p with a new atom pa with respect to a. These formulas and new atoms will later be used in our main translation to perform the minimality check of the logic of GK’s semantics.\nWe now stepwise work our way towards the main result. We start out with a result that relates a pure GK theory to\na propositional formula that will later reappear in our main translation. Proposition 1 Let T be a pure GK theory. A Kripke interpretation M is a model of T if and only if there exists a model I∗ of the propositional formula ΦT where\nΦT = trp(T ) ∧ Φsnd ∧ ΦKwit ∧ ΦAwit with Φsnd = ∧\nφ∈AtomK(T )\n(kφ ⊃ φk) ∧ ∧\nφ∈AtomA(T )\n(aφ ⊃ φa)\nΦKwit = ∧\nψ∈AtomK(T )\n( ¬kψ ⊃ ΦKψ ) ΦAwit =\n∧ ψ∈AtomA(T ) ( ¬aψ ⊃ ΦAψ ) ΦKψ = ¬ψkψ ∧\n∧ φ∈AtomK(T ) (kφ ⊃ φkψ )\nΦAψ = ¬ψaψ ∧ ∧\nφ∈AtomA(T )\n(aφ ⊃ φaψ )\nsuch that • K(M)∩AtomK(T ) = {φ | φ ∈ AtomK(T ), I∗ |= kφ}; • A(M)∩AtomA(T ) = {φ | φ ∈ AtomA(T ), I∗ |= aφ}.\nThe proposition examines the relationship between models of a pure GK theory and particular models of the propositional formula ΦT . The first conjunct trp(T ) of the formula ΦT indicates that the k-atoms and a-atoms in it can be interpreted in accordance with K(M) and A(M) such that I∗ |= trp(T ) iff M is a model of T . The soundness formula Φsnd achieves that the sets {φ | φ ∈ AtomK(T ) and I∗ |= kφ} and {φ | φ ∈ AtomA(T ) and I∗ |= aφ} are consistent. The witness formulas Φwit indicate that, if I∗ |= ¬kψ for some ψ ∈ AtomK(T ) (resp. ψ ∈ AtomA(T )) then there exists a model I ′ of K(M) (resp. A(M)) such that I ′ |= ¬ψ, where I ′ is explicitly indicated by newly introduced pkψ (resp. paψ ) atoms. So intuitively, if a formula is not known (or not assumed), then there must be a witness for that. This condition is necessary: for instance, the set {kp, kq,¬kp∧q} satisfies the formula (kp∧q ⊃ kp) ∧ (kp∧q ⊃ kq), however, since K(M) is a theory there does not exist a Kripke interpretationM such that p ∈ K(M), q ∈ K(M) and p∧q /∈ K(M). Example 1 (Continued) Formula Φ{F} is given by:\ntrp({F}) = ¬a¬p ⊃ kp Φsnd({F}) = (kp ⊃ pk) ∧ (a¬p ⊃ ¬pa) ΦKwit({F}) = ¬kp ⊃ (¬pkp ∧ (kp ⊃ pkp)) ΦAwit({F}) = ¬a¬p ⊃ (¬¬pa¬p ∧ (a¬p ⊃ ¬pa¬p))\nFormula Φ{F,G} is given by: trp({F,G}) = (¬a¬p ⊃ kp) ∧ k¬p\nΦsnd({F,G}) = Φsnd({F}) ∧ (k¬p ⊃ ¬pk) ΦKwit({F,G}) = (¬kp ⊃ ΦKp ) ∧ (¬k¬p ⊃ ΦK¬p) ΦAwit({F,G}) = ΦAwit({F})\nΦKp = ¬pkp ∧ (kp ⊃ pkp) ∧ (k¬p ⊃ ¬pkp) ΦK¬p = ¬¬pk¬p ∧ (kp ⊃ pk¬p) ∧ (k¬p ⊃ ¬pk¬p)\nwhere pk , pa , pkp , pa¬p , and pk¬p are new atoms. Note that formula Φsnd({F,G}) prevents a model that satisfies both kp and k¬p.\nWhile Proposition 1 aligns Krikpe models and propositional models of the translation, there is yet no mention of GK’s typical minimization step. This is the task of the next result, which extends the above relationship to GK models.\nProposition 2 Let T be a pure GK theory. A Kripke interpretation M is a GK model of T if and only if there exists a model I∗ of the propositional formula ΦT such that • K(M) = A(M) = Th ( {φ | φ ∈ AtomK(T ), I∗ |= kφ} ); • for each ψ ∈ AtomA(T ), I∗ |= aψ iff ψ ∈ Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ})\n• there does not exist another model I∗′ such that I∗′ ∩ {aφ | φ ∈ AtomA(T )} = I∗ ∩ {aφ | φ ∈ AtomA(T )}, I∗′ ∩ {kφ | φ ∈ AtomK(T )} ( I∗ ∩ {kφ | φ ∈ AtomK(T )}. Example 1 (Continued) Clearly the intended reading of our running example {F} is that there is no reason to assume that p is false, and the default lets us conclude that we know p. This is testified by the partial interpretation I∗ = {¬a¬p, kp, pk , pa¬p} (the remaining atoms are not relevant). It is easy to see that I∗ is a model for Φ{F} and there is no model I∗′ with the properties above. Now kp ∈ I∗ shows that p is known in the corresponding GK model.\nSimilarly, G provides a reason to assume that p is false and {F,G} concludes that we know ¬p. Consider the partial interpretation I∗ = {a¬p,¬kp, k¬p,¬pk ,¬pa ,¬pkp}, it specifies a model for Φ{F,G} and there is no model I∗′ with the properties above. In particular, k¬p ∈ I∗ shows that ¬p is known in the corresponding GK model.\nIn Proposition 2, we only need to consider a Kripke interpretation M such that A(M) ∪ K(M) is consistent. This means that formula ΦT can be modified to ΨT where\nΨT = trp(T ) ∧Ψsnd ∧ΨKwit ∧ΨAwit with Ψsnd = ∧\nφ∈AtomK(T )\n(kφ ⊃ φ) ∧ ∧\nφ∈AtomA(T )\n(aφ ⊃ φ)\nΨKwit = ∧\nψ∈AtomK(T )\n( ¬kψ ⊃ ΨKψ )\nΨAwit = ∧\nψ∈AtomA(T )\n( ¬aψ ⊃ ΨAψ )\nΨKψ = ¬ψkψ ∧ ∧\nφ∈AtomK(T )\n(kφ ⊃ φkψ ) ∧\n∧ φ∈AtomA(T ) (aφ ⊃ φkψ )\nΨAψ = ¬ψaψ ∧ ∧\nφ∈AtomK(T )\n(kφ ⊃ φaψ ) ∧\n∧ φ∈AtomA(T ) (aφ ⊃ φaψ )\nSo the soundness formula Ψsnd actually becomes easier, since soundness of knowledge and assumptions is enforced for one and the same vocabulary (the one from the original theory). The witness formulas become somewhat more complicated, as the witnesses have to respect both the knowledge as well as the assumptions of the theory. This is best explained by consulting our running example again.\nExample 1 (Continued) While F ’s propositionalization trp({F}) stays the same, the soundness and witness formulas change in the step from formula Φ{F} to formula Ψ{F}. We only show the first conjunct of the witness formula Ψwit , which is given by\n¬kp ⊃ ( ¬pkp ∧ ( kp ⊃ pkp ) ∧ ( a¬p ⊃ ¬pkp )) Intuitively, the formula expresses that whenever p is not known, then there must be a witness, that is, an interpretation where p is false. Since the witnessing interpretations could in principle be distinct for each K-atom, they have to be indexed by the respective K-atom they refer to, as in pkp . Of course, the witnesses have to obey all that is known and assumed, which is guaranteed in the last two conjuncts.\nUsing this new formula, the result of Proposition 2 can be restated.\nProposition 3 Let T be a pure GK theory. A Kripke interpretation M is a GK model of T if and only if there exists a model I∗ of the propositional formula ΨT such that • K(M) = A(M) = Th ({φ | φ ∈ AtomK(T ), I∗ |= kφ}); • for each ψ ∈ AtomA(T ), we have that I∗ |= aψ implies\nψ ∈ Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ})\n• there does not exist another model I∗′ of ΦT such that\nI∗′ ∩ {aφ | φ ∈ AtomA(T )} = I∗ ∩ {aφ | φ ∈ AtomA(T )} I∗′ ∩ {kφ | φ ∈ AtomK(T )} ( I∗ ∩ {kφ | φ ∈ AtomK(T )}\nWe are now ready for our main result, translating a pure GK theory to a disjunctive logic program. First, we introduce some notations. Let T be a pure GK theory, we use trne(T ) to denote the nested expression obtained from ΨT by first converting it to negation normal form2, then replacing “∧” by “,” and “∨” by “;”. A propositional formula φ can be equivalently translated to conjunctive normal form (involving at most linear blowup)\n(p1 ∨ · · · ∨ pt ∨ ¬pt+1 ∨ · · · ∨ ¬pm) ∧ . . . ∧ (q1 ∨ · · · ∨ qk ∨ ¬qk+1 ∨ · · · ∨ ¬qn)\nwhere p’s and q’s are atoms; we use tr c(φ) to denote the set of rules\np1; . . . ; pt ← pt+1, . . . , pm . . . q1; . . . ; qk ← qk+1, . . . , qn\nWe use φ̂ to denote the propositional formula obtained from φ by replacing each occurrence of an atom p by a new atom p̂.\n2A propositional formula is in Negation Normal Form (NNF) if negation occurs only immediately above atoms, and {⊥,>,¬,∧,∨} are the only allowed connectives.\nWe use T ∗ to denote the propositional formula obtained from the formula ΦT by replacing each occurrence of an atom p (except atoms in {aφ | φ ∈ AtomA(T )}) by a new atom p∗. Intuitively, each atom that is not an a-atom is replaced by a new atom.\nNotice that trne(T ) is obtained from ΨT while T ∗ is obtained from ΦT . Intuitively, by Proposition 3, trne(T ) is used to restrict interpretations for introduced k-atoms and a-atoms so that these interpretations serve as candidates for GK models, and by Proposition 1, T ∗ constructs possible models of the GK theory which are later used to test whether these models prevent the candidate to be a GK model.\nInspired by the linear translation from parallel circumscription into disjunctive logic programs by Janhunen and Oikarinen [2004], we have the following theorem. Theorem 1 Let T be a pure GK theory. A Kripke interpretation M is a GK model of T if and only if there exists an answer set S of the logic program tr lp(T ) in Figure 1 with K(M) = A(M) = Th({φ | φ ∈ AtomK(T ) and kφ ∈ S}).\nThe intuition behind the construction is as follows: • (1) and (2) in tr lp(T ): I∗ is a model of the formula ΨT . • (3–8): if there exists a model I∗′ of the formula ΦT with I∗ ∩ {aφ | φ ∈ AtomA(T )} = I∗′ ∩ {aφ | φ ∈ AtomA(T )} I∗′ ∩ {kφ | φ ∈ AtomK(T )} ( I∗ ∩ {kφ | φ ∈ AtomK(T )},\nthen there exists a set S∗ constructed from new atoms in tr c(T ∗) (which is a copy of the formula ΦT with same aφ for each φ ∈ AtomA(T )) and cφ for some φ ∈ AtomK(T ) such that S∗ satisfies rules (3) to (8) and u /∈ S∗.\n• (9) and (10): if there is such a set S∗ then it is the least set containing u, all p∗’s and c-atoms.\n• (11): such a set S∗ should not exist. (See item 3 in Proposition 3.) • (12) and (13): if there exists a model of the formula∧ φ∈AtomK(T )(kφ ⊃ φ̂)∧¬ ∧ φ∈AtomA(T )(aφ ⊃ φ̂), then\nv should not occur in the minimal model of the program. • (14): ∧ φ∈AtomK(T )(kφ ⊃ φ̂)∧¬ ∧ φ∈AtomA(T )(aφ ⊃ φ̂)\nshould not be consistent. (This is necessary by item 2 in Proposition 3.) Given a model S of the logic program tr lp(T ), the new atom u is used to indicate that the model I∗ of ΨT w.r.t. S (specified by (1) and (2)) satisfies item 3 in Proposition 3. Specifically, if I∗ does not satisfy item 3, then there exists a subset S∗ of p∗’s and c-atoms that satisfies (3) to (8). If in addition u /∈ S∗, then there exists a subset of S that satisfies all rules in tr lp(T ) except (11), thus S cannot be an answer set of tr lp(T ). Similarly, v is used to indicate that I∗ satisfies item 2 in Proposition 3. Specifically, if I∗ does not satisfy item 2, then the propositional formula∧ φ∈AtomK(T )(kφ ⊃ φ̂) ∧ ¬ ∧ φ∈AtomA(T )(aφ ⊃ φ̂) is satisfiable, thus there exists a subset Ŝ of p̂’s that satisfies (12). If in addition v /∈ Ŝ, then there exists a subset of S that satisfies all rules in tr lp(T ) except (14), thus S cannot be an answer set of tr lp(T ).\nExample 1 (Continued) For our running example theory {F} with F = ¬A¬p ⊃ Kp, we find that the logic program translation tr lp({F}) has a single answer set S with kp ∈ S Thus by Theorem 1 we can conclude that the GK theory {F} has a single GK model M in which K(M) = Th({p}). Likewise, the logic program tr lp({F,G}) has a single answer set S′ with k¬p ∈ S′, whence {F,G} has a single GK model M ′ in which K(M ′) = Th({¬p}).\nComputational complexity We have seen in the preliminaries section that disjunctive logic programs can be modularly and equivalently translated into pure formulas of the logic of GK. Conversely, Theorem 1 shows that pure GK formulas can be equivalently translated into disjunctive logic programs. Eiter and Gottlob showed that the problem of deciding whether a disjunctive logic program has an answer set is ΣP2 -complete [Eiter and Gottlob, 1995]. In combination, these results yield the following straightforward complexity result for the satisfiability of pure GK. Proposition 4 Let T be a pure GK theory. The problem of deciding whether T has a GK model is ΣP2 -complete. We remark that the hardness of disjunctive logic programs stems from so-called head cycles (at least two atoms that mutually depend on each other and occur jointly in some rule head). It is straightforwardly checked that our encoding creates such head cycles, for example the head of rule (8) contains the cycle induced by rules (7) and (10)."
    }, {
      "heading" : "Implementation",
      "text" : "We have implemented the translation of Theorem 1 into a working prototype gk2dlp. The program is written in Prolog and uses the disjunctive ASP solver claspD-2 [Gebser, Kaufmann, and Schaub, 2013], which was ranked first place in the 2013 ASP competition.3\nOur prototype is the first implementation of the (pure) logic of GK to date. The restriction to pure formulas seems harmless since all known applications of the logic of GK use only pure formulas. We remark that gk2dlp implements default and autoepistemic logics such that input and target language are of the same complexity.\nEvaluation To have a scalable problem domain and inspired by dl2asp [Chen et al., 2010], we chose the fair division problem [Bouveret and Lang, 2008] for experimental evaluation. An instance of the fair division problem consists of a set of agents, a set of goods, and for each agent a set of constraints that intuitively express which sets of goods the agent is willing to accept. A solution is then an assignment of goods to agents that is a partition of all goods and satisfies all agents’ constraints. Bouveret and Lang [2008] showed that the problem is ΣP2 -complete, and can be naturally encoded in default logic.\n3http://www.mat.unical.it/ianni/storage/ aspcomp-2013-lpnmrtalk.pdf\nWe created random instances of the fair division problem with increasing numbers of agents and goods. We then applied the translation of [Bouveret and Lang, 2008], furthermore the translation from default logic into the logic of GK, then invoked gk2dlp to produce logic programs and finally used gringo 3.0.3 and claspD version 2 (revision 6814) to compute all answer sets of these programs, thus all extensions of the original default theory corresponding to all solutions of the problem instance. The experiments were conducted on a Lenovo laptop with an Intel Core i3 processor with 4 cores and 4GB of RAM running Ubuntu 12.04. We recorded the size of the default theory, the size of the translated logic program, the translation time and the solving time, as well as the number of solutions obtained. We started out with 2 agents and 2 goods, and stepwise increased these numbers towards 6. For each combination in (a, g) ∈ {2, . . . , 6} × {2, . . . , 6}, we tested 20 randomly generated instances. Random generation here means that we create agents’ preferences by iteratively drawing random subsets of goods to add to an agent’s acceptable subsets with probability P , where P is initialized with 1 and discounted by the factor g−1g for each subset that has been drawn.\nIn accordance with our theoretical predictions, we observed that the increase in size from GK formula to logic program is indeed polynomial (albeit with a low exponent). The plot on the right (Figure 2) shows the solving time in relation to the size of the default theory, where the time axis is logarithmic. We can see that the runtime behavior of gk2dlp is satisfactory. We acknowledge however that the runtimes we measured are not competitive with those reported by Chen et al. [2010] for dl2asp. However, a direct comparison of the two systems is problematic for a number of reasons. First of all, the system dl2asp is not publicly available to the best of our knowledge. Furthermore, Chen et al. [2010] do not describe how they create random instances of the fair division problem, so we cannot compare the runtimes they report and the ones we measured. Finally, dl2asp is especially engineered for default logic, and it is not clear how their approach can be generalized to other languages, for example Turner’s logic of universal causation. In general, the approaches to translation that are followed by dl2asp and gk2dlp are completely different: dl2asp translates a ΣP2 -complete problem to an NP-complete problem using a translation in ∆P2 . Our system gk2dlp translates a ΣP2 -complete problem into another Σ P 2 -complete problem using a translation that can be computed in polynomial time.\nApplications We see immediate applicability of the translation of the present paper to several areas. Reiter [1987] provided a theory of diagnosis from first principles, and showed how default logic can be used as an implementation device. Cadoli, Eiter, and Gottlob [1994] proposed to use default logic as an expressive query language on top of relational databases, and gave an example of achieving strategic behavior in an economic setting. In reasoning about actions, Thielscher [1996] used default logic to solve the qualification problem of dealing with unexpected action failures. Martin and Thielscher [2001] later provided an implementation of that approach where extensions are enumer-\nated in Prolog. Recently, Baumann et al. [2010] introduced a method for default reasoning in action theories, that is, an approach to the question what normally holds in a dynamic domain. Our translation yields an implementation of their approach, something that they stated as future work and later achieved to a limited extent (for a restricted sublanguage of their framework [Strass, 2012]). In a similar vein, Pagnucco et al. [2013] looked at belief change in the situation calculus and proposed an implementation based on default logic with preferences [Brewka, 1994; Delgrande and Schaub, 2000].\nRelated work The translation presented in this paper is a generalization of the one presented for Turner’s logic of universal causation by Ji and Lin [2013]. We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemelä [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz’ logic of minimal belief and negation as failure [1994]. Other approaches are restricted to specific languages, where default logic seems to be most popular. The recent system dl2asp [Chen et al., 2010] translates default theories to normal (non-disjunctive) logic programs; the translation figures out all implication relations between formulas occurring in the default theory, just as Junker and Konolige [1990] did. The authors of dl2asp [Chen et al., 2010] already observed that default logic and disjunctive logic programs are of the same complexity; they even stated the search for a polynomial translation from the former to the latter (that we achieved in this paper) as future work. Gadel [Nicolas, Saubion, and Stéphan,\n2000] uses a genetic algorithm to compute extensions of a default theory; likewise the system DeReS [Cholewiński et al., 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics. Risch and Schwind [1994] describe a tableauxbased algorithm for computing all extensions of general default theories, but do not report runtimes for their Prologbased implementation. For autoepistemic logic, Marek and Truszczyński [1991] investigate sceptical reasoning with respect to Moore’s expansion semantics."
    }, {
      "heading" : "Discussion",
      "text" : "We have presented the first translation of pure formulas of the logic of GK to disjunctive answer set programming. Among other things, this directly leads to implementations of Turner’s logic of universal causation as well as implementations of default and autoepistemic logics under different semantics. We have prototypically implemented the translation and experimentally analysed its performance, which we found to be satisfactory given the system’s generality.\nIn the future, we plan to integrate further nonmonotonic reasoning formalisms. This is more or less straightforward due to the generality of this work: to implement a language, it suffices to provide a translation into pure formulas of GK, then Theorem 1 of this paper does the rest. Particular formalism we want to look at are default logics with preferences [Brewka, 1994; Delgrande and Schaub, 2000] and the logic of only-knowing [Lakemeyer and Levesque, 2005]. It also seems worthwhile to check whether our translation can be adapted to the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994; Truszczyński, 2007], that has only one modality instead of two. We finally plan to study the approaches mentioned as applications in the previous section to try out our translation and implementation on agentoriented AI problems."
    }, {
      "heading" : "Appendix",
      "text" : ""
    }, {
      "heading" : "Proof of Proposition 1:",
      "text" : "⇒: Let M be a model of T , I1 ⊆ Lit a model of K(M), and I2 ⊆ Lit a model of A(M). Clearly, for each φ ∈ AtomK(T ), if φ ∈ K(M) then I1 |= φ; if φ /∈ K(M) then there exists a model I ′ of K(M) such that I ′ |= ¬φ. Same results are established for each φ ∈ AtomA(T ).\nThen, we can create an interpretation I∗ such that\nI∗ = {lk | l ∈ I1} ∪ {la | l ∈ I2} ∪ {kφ | φ ∈ AtomK(T ) ∩K(M)} ∪ {aφ | φ ∈ AtomA(T ) ∩A(M)}\n∪ {¬kφ | φ ∈ AtomK(T ) and φ /∈ K(M)} ∪ {¬aφ | φ ∈ AtomA(T ) and φ /∈ A(M)}\n∪ ⋃\nψ∈AtomK(T ) ψ∈K(M)\n{lkψ | l ∈ I1} ∪ ⋃\nψ∈AtomA(T ) ψ∈A(M)\n{laψ | l ∈ I2}\n∪ ⋃\nψ∈AtomK(T ) ψ/∈K(M)\n{ lkψ | l ∈ I ′, I ′ is a model of K(M) ∪ {¬ψ} } ∪\n⋃ ψ∈AtomA(T ) ψ/∈A(M) {laψ | l ∈ I ′, I ′ is a model of A(M) ∪ {¬ψ}} .\nIt is easy to verify that I∗ is a model of ΦT and\n• K(M)∩AtomK(T ) = {φ | φ ∈ AtomK(T ), I∗ |= kφ}; • A(M)∩AtomA(T ) = {φ | φ ∈ AtomA(T ), I∗ |= aφ}. ⇐: Let I∗ be a model of ΦT . We can create a Kripke interpretation M such that\n• K(M) = Th ( {φ | φ ∈ AtomK(T ) and I∗ |= kφ} ); • A(M) = Th ( {φ | φ ∈ AtomA(T ) and I∗ |= aφ} ).\nNote that, {l ∈ Lit | I∗ |= lk} is a model of K(M) and {l ∈ Lit | I∗ |= la} is a model of A(M), then both K(M) and A(M) are consistent.\nFor each φ ∈ AtomK(T ), if I∗ |= kφ then φ ∈ K(M); if I∗ |= ¬kφ then there exists a model I ′ = {l ∈ Lit | I∗ |= lkφ} such that I ′ is a model of K(M) and I ′ |= ¬φ, thus φ /∈ K(M). So I∗ |= kφ iff φ ∈ K(M). The same result is established for each φ ∈ AtomA(T ). Note that, I∗ |= trp(T ) then M is a model of T ."
    }, {
      "heading" : "Proof of Proposition 2:",
      "text" : "⇒: LetM be a GK model of T . From the proof of Proposition 1, we can create a model I∗ of ΦT . Now we want to prove that I∗ satisfies all conditions in the proposition.\nFrom Theorem 3.5 in [Lin and Shoham, 1992], K(M) = Th({φ | φ ∈ AtomK(T ) ∩ K(M)}), then K(M) = A(M) = Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ}).\nAssume that there exists another model I∗′ of ΦT with\nI∗′ ∩ {aφ | φ ∈ AtomA(T )} = I∗ ∩ {aφ | φ ∈ AtomA(T )} I∗′ ∩ {kφ | φ ∈ AtomK(T )} ( I∗ ∩ {kφ | φ ∈ AtomK(T )}\nThen, from Proposition 1, there exists a Kripke interpretation M ′ such that K(M ′) = Th({φ | φ ∈ AtomK(T ) and I∗′ |= kφ}), A(M ′) = A(M), and M ′ is a model of T . Note that, for each φ ∈ AtomK(T ), I∗′ |= ¬kφ implies K(M ′) 6|= φ, then K(M ′) ( K(M). From the definition of GK models, there does not exist such a model M ′, which conflicts to the assumption, then there does not exist such a model I∗′.\nFrom the construction of I∗, for each ψ ∈ AtomA(T ), I∗ |= aψ iff ψ ∈ A(M). Note that, K(M) = A(M) = Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ}), then I∗ |= aψ iff ψ ∈ Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ}).\nSo I∗ is a model of ΦT which satisfies all conditions in the proposition. ⇐: Let I∗ be a model of ΦT which satisfies corresponding conditions in the proposition. We can create a Kripke interpretation M such that K(M) = A(M) = Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ}).\nFrom the third condition in the proposition, I∗ |= aφ iff φ ∈ K(M) for each φ ∈ AtomA(T ). Then A(M) ∩ AtomA(T ) = {φ | φ ∈ AtomA(T ) and I∗ |= aφ}. From the proof of Proposition 1, M is a model of T and I∗ |= kφ (resp. I∗ |= aφ) iff φ ∈ K(M) for each φ ∈ AtomK(T ) (resp. φ ∈ AtomA(T )). Now we want to prove that M is a GK model of T .\nAssume that there exists another model M ′ of T such that A(M ′) = A(M) and K(M ′) ( K(M). Note that K(M) = Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ}), then K(M ′) ∩AtomK(T ) ( K(M) ∩AtomK(T ).\nLet I = I∗ ∩ {lk | l ∈ Lit}, clearly, I is a model of K(M), A(M), and K(M ′). We can construct another model I∗′ of ΦT as\nI∗′ = {lk | l ∈ I} ∪ {la | l ∈ I} ∪ {kφ | φ ∈ AtomK(T ) ∩K(M ′)} ∪ {aφ | φ ∈ AtomA(T ) ∩A(M)}\n∪ {¬kφ | φ ∈ AtomK(T ) and φ /∈ K(M ′)} ∪ {¬aφ | φ ∈ AtomA(T ) and φ /∈ A(M)}\n∪ ⋃\nψ∈AtomK(T ) ψ∈K(M′)\n{lkψ | l ∈ I} ∪ ⋃\nψ∈AtomA(T ) ψ∈A(M)\n{laψ | l ∈ I}\n∪ ⋃\nψ∈AtomK(T ) ψ/∈K(M′)\n{ lkψ | l ∈ I ′, I ′ is a model of K(M ′) ∪ {¬ψ} } ∪\n⋃ ψ∈AtomA(T ) ψ/∈A(M) {laψ | l ∈ I ′, I ′ is a model of A(M) ∪ {¬ψ}} .\nFrom the proof of Proposition 1, I∗′ is a model of ΦT , and\nI∗′ ∩ {aφ | φ ∈ AtomA(T )} = I∗ ∩ {aφ | φ ∈ AtomA(T )} I∗′ ∩ {kφ | φ ∈ AtomK(T )} ( I∗ ∩ {kφ | φ ∈ AtomK(T )}\nThis conflicts to the second condition in the proposition, then the assumption is not valid. So there does not exist another model M ′ of T such that A(M ′) = A(M) and K(M ′) ( K(M), thus M is a GK model of T ."
    }, {
      "heading" : "Proof of Theorem 1:",
      "text" : "⇒: Let M be a GK model of T . From Proposition 3, there exists a model I∗ of ΨT such that K(M) = A(M) = Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ}). We can create a set S of literals as S = I∗ ∪ {u, v} ∪ {p∗ | for each new atom p∗ occurring in tr c(T ∗)} ∪ {cφ | φ ∈ AtomK(T )} ∪ {p̂ | p ∈ Atom}.\nClearly, S satisfies each rule in tr lp(T ). Now we want to prove that S is an answer set of the program.\nAssume that S is not an answer set of tr lp(T ), then there exists another set S′ ( S such that S′ satisfies each rule in the reduct tr lp(T )S . Note that, I∗ ⊆ S′, u implies {p∗ | for each new atom p∗ occurring in tr c(T ∗)} ∪ {cφ | φ ∈ AtomK(T )} and v implies {p̂ | p ∈ Atom}. Then there are only two possible cases: u /∈ S′ or v /∈ S′.\nCase 1: u /∈ S′, then there exists a set\nT = S′ ∩ ( {p∗ | p∗ is a new atom occurring in tr c(T ∗)}\n∪ {aφ | φ ∈ AtomA(T )} )\nsuch that T satisfies tr c(T ∗). For each φ ∈ AtomK(T ), • by the rule u← cφ, not kφ, I∗ |= ¬kφ implies cφ /∈ S′; • by the rule u← k∗φ, not kφ, I∗ |= ¬kφ implies k∗φ /∈ S′; • by rules u ← cφ, k∗φ, not¬kφ and u; cφ; k∗φ ← not¬kφ, I∗ |= kφ implies either cφ or k∗φ is in S′ but not both; • by the rule u; cφ1 ; · · · ; cφm ← >, there exists cψ ∈ S′ for some ψ ∈ AtomK(T ).\nSo there exists ψ ∈ AtomK(T ) such that kψ ∈ S′, cψ ∈ S′ and k∗ψ /∈ S′. Then we could create an interpretation I∗′ as\nI∗′ = {p | p ∈ Atom and p∗ ∈ S′} ∪ {¬p | p ∈ Atom and p∗ /∈ S′}\n∪ {kφ | φ ∈ AtomK(T ) and k∗φ ∈ S′} ∪ {¬kφ | φ ∈ AtomK(T ) and k∗φ /∈ S′} ∪ {aφ | φ ∈ AtomA(T ) and aφ ∈ S′} ∪ {¬aφ | φ ∈ AtomA(T ) and aφ /∈ S′}\n∪ ⋃\nψ∈AtomK(T )\n{pkψ | pkψ∗ ∈ S′}∪ ⋃\nψ∈AtomK(T )\n{¬pkψ | pkψ∗ /∈ S′}\n∪ ⋃\nψ∈AtomA(T )\n{paψ | paψ∗ ∈ S′}∪ ⋃\nψ∈AtomA(T )\n{¬paψ | paψ∗ /∈ S′}.\nClearly, I∗′ is a model of ΨT . From the above results, • I∗′ ∩ {aφ | φ ∈ AtomA(T )} = I∗ ∩ {aφ | φ ∈ AtomA(T )}, and • I∗′ ∩ {kφ | φ ∈ AtomK(T )} ( I∗ ∩ {kφ | φ ∈ AtomK(T )}. From Proposition 3, such I∗′ does not exist. This conflicts to the assumption, then Case 1 is impossible.\nCase 2: v /∈ S′, then there exists a set U = S′ ∩ ( {â | a ∈ Atom} ∪ {kφ | φ ∈ AtomK(T )}\n∪ {aφ | φ ∈ AtomA(T )} )\nsuch that U satisfies each rule in tr c( ∧ φ∈AtomK(T )(kφ ⊃ φ̂) ∧ ¬ ∧ ψ∈AtomA(T )(aψ ⊃ ψ̂)).\nThen there exists ψ ∈ AtomA(T ) such that I∗ |= aψ and there exists an interpretation I ⊆ Lit such that I |=∧ φ∈AtomK(T ),I∗|=kφ φ ∧ ¬ψ, thus ψ /∈ Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ}). From Proposition 3, such ψ does not exist. This conflicts to the assumption, then Case 2 is impossible. So both cases are impossible, then S′ does not exist and S is an answer set of tr lp(T ). ⇐: Let S be an answer set of tr lp(T ). We can create an interpretation I∗ as the intersection of S with the set of atoms occurring in ΨT . Clearly, I∗ is a model of ΨT .\nSimilar to the above proof: If there exists another model I∗′ of ΨT such that I∗′ ∩ {aφ | φ ∈ AtomA(T )} = I∗ ∩ {aφ | φ ∈ AtomA(T )} I∗′ ∩ {kφ | φ ∈ AtomK(T )} ( I∗ ∩ {kφ | φ ∈ AtomK(T )} then there exists another set S′ such that S′ satisfies each rule in the reduct tr lp(T )S and u /∈ S′, thus S′ ( S. This conflicts to the precondition that S is an answer set, then such a model I∗′ does not exist.\nIf there exists ψ ∈ AtomA(T ) such that I∗ |= aψ and ψ /∈ Th({φ | φ ∈ AtomK(T ) and I∗ |= kφ}), then there exists another set S′ such that S′ satisfies each rule in the reduct tr lp(T )S and v /∈ S′, thus S′ ( S. This conflicts to the precondition that S is an answer set, then such ψ does not exist.\nFrom Proposition 3, a Kripke interpretation M such that K(M) = A(M) = Th({φ | φ ∈ AtomK(T ) and kφ ∈ S}) is a GK models of T ."
    } ],
    "references" : [ {
      "title" : "State Defaults and Ramifications in the Unifying Action Calculus",
      "author" : [ "R. Baumann", "G. Brewka", "H. Strass", "M. Thielscher", "V. Zaslawski" ],
      "venue" : "KR, 435–444.",
      "citeRegEx" : "Baumann et al\\.,? 2010",
      "shortCiteRegEx" : "Baumann et al\\.",
      "year" : 2010
    }, {
      "title" : "Efficiency and envy-freeness in fair division of indivisible goods: Logical representation and complexity",
      "author" : [ "S. Bouveret", "J. Lang" ],
      "venue" : "JAIR 32:525–564.",
      "citeRegEx" : "Bouveret and Lang,? 2008",
      "shortCiteRegEx" : "Bouveret and Lang",
      "year" : 2008
    }, {
      "title" : "Adding Priorities and Specificity to Default Logic",
      "author" : [ "G. Brewka" ],
      "venue" : "JELIA, 247–260.",
      "citeRegEx" : "Brewka,? 1994",
      "shortCiteRegEx" : "Brewka",
      "year" : 1994
    }, {
      "title" : "Default logic as a query language",
      "author" : [ "M. Cadoli", "T. Eiter", "G. Gottlob" ],
      "venue" : "KR, 99–108.",
      "citeRegEx" : "Cadoli et al\\.,? 1994",
      "shortCiteRegEx" : "Cadoli et al\\.",
      "year" : 1994
    }, {
      "title" : "dl2asp: Implementing Default Logic via Answer Set Programming",
      "author" : [ "Y. Chen", "H. Wan", "Y. Zhang", "Y. Zhou" ],
      "venue" : "JELIA, volume 6341, 104–116.",
      "citeRegEx" : "Chen et al\\.,? 2010",
      "shortCiteRegEx" : "Chen et al\\.",
      "year" : 2010
    }, {
      "title" : "Computing with default logic",
      "author" : [ "P. Cholewiński", "V.W. Marek", "M. Truszczyński", "A. Mikitiuk" ],
      "venue" : "AIJ 112(1):105–146.",
      "citeRegEx" : "Cholewiński et al\\.,? 1999",
      "shortCiteRegEx" : "Cholewiński et al\\.",
      "year" : 1999
    }, {
      "title" : "Expressing Preferences in Default Logic",
      "author" : [ "J.P. Delgrande", "T. Schaub" ],
      "venue" : "AIJ 123(1–2):41–87.",
      "citeRegEx" : "Delgrande and Schaub,? 2000",
      "shortCiteRegEx" : "Delgrande and Schaub",
      "year" : 2000
    }, {
      "title" : "Uniform Semantic Treatment of Default and Autoepistemic Logics",
      "author" : [ "M. Denecker", "V.W. Marek", "M. Truszczyński" ],
      "venue" : "AIJ 143(1):79–122.",
      "citeRegEx" : "Denecker et al\\.,? 2003",
      "shortCiteRegEx" : "Denecker et al\\.",
      "year" : 2003
    }, {
      "title" : "Nonmonotonic reasoning: Towards efficient calculi and implementations",
      "author" : [ "J. Dix", "U. Furbach", "I. Niemelä" ],
      "venue" : "Handbook of Automated Reasoning 2(18):1121–1234.",
      "citeRegEx" : "Dix et al\\.,? 2001",
      "shortCiteRegEx" : "Dix et al\\.",
      "year" : 2001
    }, {
      "title" : "Conflict-Driven Disjunctive Answer Set Solving",
      "author" : [ "C. Drescher", "M. Gebser", "T. Grote", "B. Kaufmann", "A. König", "M. Ostrowski", "T. Schaub" ],
      "venue" : "KR, 422–432.",
      "citeRegEx" : "Drescher et al\\.,? 2008",
      "shortCiteRegEx" : "Drescher et al\\.",
      "year" : 2008
    }, {
      "title" : "On the computational cost of disjunctive logic programming: Propositional case",
      "author" : [ "T. Eiter", "G. Gottlob" ],
      "venue" : "AMAI 15(3–4):289–323.",
      "citeRegEx" : "Eiter and Gottlob,? 1995",
      "shortCiteRegEx" : "Eiter and Gottlob",
      "year" : 1995
    }, {
      "title" : "Answer sets for propositional theories",
      "author" : [ "P. Ferraris" ],
      "venue" : "LPNMR, 119–131.",
      "citeRegEx" : "Ferraris,? 2005",
      "shortCiteRegEx" : "Ferraris",
      "year" : 2005
    }, {
      "title" : "Advanced conflictdriven disjunctive answer set solving",
      "author" : [ "M. Gebser", "B. Kaufmann", "T. Schaub" ],
      "venue" : "IJCAI.",
      "citeRegEx" : "Gebser et al\\.,? 2013",
      "shortCiteRegEx" : "Gebser et al\\.",
      "year" : 2013
    }, {
      "title" : "Answer Set Programming Based on Propositional Satisfiability",
      "author" : [ "E. Giunchiglia", "Y. Lierler", "M. Maratea" ],
      "venue" : "J. Autom. Reasoning 36(4):345–377.",
      "citeRegEx" : "Giunchiglia et al\\.,? 2006",
      "shortCiteRegEx" : "Giunchiglia et al\\.",
      "year" : 2006
    }, {
      "title" : "Die formalen Regeln der intuitionistischen Logik",
      "author" : [ "A. Heyting" ],
      "venue" : "Sitzungsberichte der preußischen Akademie der Wissenschaften, 42– 65, 57–71, 158–169. Physikalisch-mathematische Klasse.",
      "citeRegEx" : "Heyting,? 1930",
      "shortCiteRegEx" : "Heyting",
      "year" : 1930
    }, {
      "title" : "GnT – A Solver for Disjunctive Logic Programs",
      "author" : [ "T. Janhunen", "I. Niemelä" ],
      "venue" : "LPNMR, 331–335.",
      "citeRegEx" : "Janhunen and Niemelä,? 2004",
      "shortCiteRegEx" : "Janhunen and Niemelä",
      "year" : 2004
    }, {
      "title" : "Capturing parallel circumscription with disjunctive logic programs",
      "author" : [ "T. Janhunen", "E. Oikarinen" ],
      "venue" : "Logics in Artificial Intelligence. 134–146.",
      "citeRegEx" : "Janhunen and Oikarinen,? 2004",
      "shortCiteRegEx" : "Janhunen and Oikarinen",
      "year" : 2004
    }, {
      "title" : "From Turner’s Logic of Universal Causation to the Logic of GK",
      "author" : [ "J. Ji", "F. Lin" ],
      "venue" : "Correct Reasoning, volume 7265, 380–385.",
      "citeRegEx" : "Ji and Lin,? 2012",
      "shortCiteRegEx" : "Ji and Lin",
      "year" : 2012
    }, {
      "title" : "Turner’s logic of universal causation, propositional logic, and logic programming",
      "author" : [ "J. Ji", "F. Lin" ],
      "venue" : "LPNMR, 401–413.",
      "citeRegEx" : "Ji and Lin,? 2013",
      "shortCiteRegEx" : "Ji and Lin",
      "year" : 2013
    }, {
      "title" : "Computing the Extensions of Autoepistemic and Default Logics with a Truth Maintenance System",
      "author" : [ "U. Junker", "K. Konolige" ],
      "venue" : "AAAI, 278–283.",
      "citeRegEx" : "Junker and Konolige,? 1990",
      "shortCiteRegEx" : "Junker and Konolige",
      "year" : 1990
    }, {
      "title" : "On the Relation Between Default and Autoepistemic Logic",
      "author" : [ "K. Konolige" ],
      "venue" : "AIJ 35(3):343–382.",
      "citeRegEx" : "Konolige,? 1988",
      "shortCiteRegEx" : "Konolige",
      "year" : 1988
    }, {
      "title" : "Only-knowing: Taking it beyond autoepistemic reasoning",
      "author" : [ "G. Lakemeyer", "H.J. Levesque" ],
      "venue" : "AAAI, 633–638.",
      "citeRegEx" : "Lakemeyer and Levesque,? 2005",
      "shortCiteRegEx" : "Lakemeyer and Levesque",
      "year" : 2005
    }, {
      "title" : "The DLV system for knowledge representation and reasoning",
      "author" : [ "N. Leone", "G. Pfeifer", "W. Faber", "T. Eiter", "G. Gottlob", "S. Perri", "F. Scarcello" ],
      "venue" : "ACM Transactions on Computational Logic 7(3):499– 562.",
      "citeRegEx" : "Leone et al\\.,? 2006",
      "shortCiteRegEx" : "Leone et al\\.",
      "year" : 2006
    }, {
      "title" : "Nested expressions in logic programs",
      "author" : [ "V. Lifschitz", "L.R. Tang", "H. Turner" ],
      "venue" : "AMAI 25(3-4):369–389.",
      "citeRegEx" : "Lifschitz et al\\.,? 1999",
      "shortCiteRegEx" : "Lifschitz et al\\.",
      "year" : 1999
    }, {
      "title" : "Minimal belief and negation as failure",
      "author" : [ "V. Lifschitz" ],
      "venue" : "AIJ 70(1– 2):53–72.",
      "citeRegEx" : "Lifschitz,? 1994",
      "shortCiteRegEx" : "Lifschitz",
      "year" : 1994
    }, {
      "title" : "A logic of knowledge and justified assumptions",
      "author" : [ "F. Lin", "Y. Shoham" ],
      "venue" : "AIJ 57(2-3):271–289.",
      "citeRegEx" : "Lin and Shoham,? 1992",
      "shortCiteRegEx" : "Lin and Shoham",
      "year" : 1992
    }, {
      "title" : "From answer set logic programming to circumscription via logic of GK",
      "author" : [ "F. Lin", "Y. Zhou" ],
      "venue" : "AIJ 175(1):264–277.",
      "citeRegEx" : "Lin and Zhou,? 2011",
      "shortCiteRegEx" : "Lin and Zhou",
      "year" : 2011
    }, {
      "title" : "Reducing strong equivalence of logic programs to entailment in classical propositional logic",
      "author" : [ "F. Lin" ],
      "venue" : "KR, 170–176.",
      "citeRegEx" : "Lin,? 2002",
      "shortCiteRegEx" : "Lin",
      "year" : 2002
    }, {
      "title" : "Computing intersection of autoepistemic expansions",
      "author" : [ "V.W. Marek", "M. Truszczyński" ],
      "venue" : "LPNMR, 37–50.",
      "citeRegEx" : "Marek and Truszczyński,? 1991",
      "shortCiteRegEx" : "Marek and Truszczyński",
      "year" : 1991
    }, {
      "title" : "Addressing the Qualification Problem in FLUX",
      "author" : [ "Y. Martin", "M. Thielscher" ],
      "venue" : "KI/ÖGAI, 290–304.",
      "citeRegEx" : "Martin and Thielscher,? 2001",
      "shortCiteRegEx" : "Martin and Thielscher",
      "year" : 2001
    }, {
      "title" : "Circumscription – a form of non-monotonic reasoning",
      "author" : [ "J. McCarthy" ],
      "venue" : "AIJ 13:295–323.",
      "citeRegEx" : "McCarthy,? 1980",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1980
    }, {
      "title" : "Applications of circumscription to formalizing commonsense knowledge",
      "author" : [ "J. McCarthy" ],
      "venue" : "AIJ 28:89–118.",
      "citeRegEx" : "McCarthy,? 1986",
      "shortCiteRegEx" : "McCarthy",
      "year" : 1986
    }, {
      "title" : "Semantical considerations on nonmonotonic logic",
      "author" : [ "R. Moore" ],
      "venue" : "AIJ 25(1):75–94.",
      "citeRegEx" : "Moore,? 1985",
      "shortCiteRegEx" : "Moore",
      "year" : 1985
    }, {
      "title" : "Gadel: a genetic algorithm to compute default logic extensions",
      "author" : [ "P. Nicolas", "F. Saubion", "I. Stéphan" ],
      "venue" : "ECAI, 484–490.",
      "citeRegEx" : "Nicolas et al\\.,? 2000",
      "shortCiteRegEx" : "Nicolas et al\\.",
      "year" : 2000
    }, {
      "title" : "A decision method for nonmonotonic reasoning based on autoepistemic reasoning",
      "author" : [ "I. Niemelä" ],
      "venue" : "J. Autom. Reasoning 14(1):3–42.",
      "citeRegEx" : "Niemelä,? 1995",
      "shortCiteRegEx" : "Niemelä",
      "year" : 1995
    }, {
      "title" : "Implementing Belief Change in the Situation Calculus and an Application",
      "author" : [ "M. Pagnucco", "D. Rajaratnam", "H. Strass", "M. Thielscher" ],
      "venue" : "LPNMR, volume 8148, 439–451.",
      "citeRegEx" : "Pagnucco et al\\.,? 2013",
      "shortCiteRegEx" : "Pagnucco et al\\.",
      "year" : 2013
    }, {
      "title" : "A logic for default reasoning",
      "author" : [ "R. Reiter" ],
      "venue" : "AIJ 13(1-2):81–132.",
      "citeRegEx" : "Reiter,? 1980",
      "shortCiteRegEx" : "Reiter",
      "year" : 1980
    }, {
      "title" : "A theory of diagnosis from first principles",
      "author" : [ "R. Reiter" ],
      "venue" : "AIJ 32(1):57–95.",
      "citeRegEx" : "Reiter,? 1987",
      "shortCiteRegEx" : "Reiter",
      "year" : 1987
    }, {
      "title" : "Tableaux-based characterization and theorem proving for default logic",
      "author" : [ "V. Risch", "C. Schwind" ],
      "venue" : "J. Autom. Reasoning 13(2):223– 242.",
      "citeRegEx" : "Risch and Schwind,? 1994",
      "shortCiteRegEx" : "Risch and Schwind",
      "year" : 1994
    }, {
      "title" : "Reasoning about minimal belief and negation as failure",
      "author" : [ "R. Rosati" ],
      "venue" : "JAIR 11:277–300.",
      "citeRegEx" : "Rosati,? 1999",
      "shortCiteRegEx" : "Rosati",
      "year" : 1999
    }, {
      "title" : "An implementation platform for queryanswering in default logics: The XRay system, its implementation and evaluation",
      "author" : [ "T. Schaub", "P. Nicolas" ],
      "venue" : "LPNMR. 441–452.",
      "citeRegEx" : "Schaub and Nicolas,? 1997",
      "shortCiteRegEx" : "Schaub and Nicolas",
      "year" : 1997
    }, {
      "title" : "Minimal knowledge problem: A new approach",
      "author" : [ "G. Schwarz", "M. Truszczynski" ],
      "venue" : "AIJ 67(1):113–141.",
      "citeRegEx" : "Schwarz and Truszczynski,? 1994",
      "shortCiteRegEx" : "Schwarz and Truszczynski",
      "year" : 1994
    }, {
      "title" : "The draculasp system: Default reasoning about actions and change using logic and answer set programming",
      "author" : [ "H. Strass" ],
      "venue" : "NMR.",
      "citeRegEx" : "Strass,? 2012",
      "shortCiteRegEx" : "Strass",
      "year" : 2012
    }, {
      "title" : "Causality and the Qualification Problem",
      "author" : [ "M. Thielscher" ],
      "venue" : "KR, 51–62.",
      "citeRegEx" : "Thielscher,? 1996",
      "shortCiteRegEx" : "Thielscher",
      "year" : 1996
    }, {
      "title" : "The modal logic S4F, the default logic, and the logic here-and-there",
      "author" : [ "M. Truszczyński" ],
      "venue" : "AAAI, 508–514.",
      "citeRegEx" : "Truszczyński,? 2007",
      "shortCiteRegEx" : "Truszczyński",
      "year" : 2007
    }, {
      "title" : "Logic of universal causation",
      "author" : [ "H. Turner" ],
      "venue" : "AIJ 113(1):87–123.",
      "citeRegEx" : "Turner,? 1999",
      "shortCiteRegEx" : "Turner",
      "year" : 1999
    } ],
    "referenceMentions" : [ {
      "referenceID" : 36,
      "context" : "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner’s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].",
      "startOffset" : 55,
      "endOffset" : 69
    }, {
      "referenceID" : 32,
      "context" : "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner’s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].",
      "startOffset" : 94,
      "endOffset" : 107
    }, {
      "referenceID" : 25,
      "context" : "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner’s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].",
      "startOffset" : 127,
      "endOffset" : 149
    }, {
      "referenceID" : 45,
      "context" : "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner’s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].",
      "startOffset" : 194,
      "endOffset" : 208
    }, {
      "referenceID" : 17,
      "context" : "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner’s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].",
      "startOffset" : 228,
      "endOffset" : 246
    }, {
      "referenceID" : 11,
      "context" : "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner’s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].",
      "startOffset" : 287,
      "endOffset" : 303
    }, {
      "referenceID" : 26,
      "context" : "To date, there have been embeddings from default logic [Reiter, 1980] and autoepistemic logic [Moore, 1985] to the logic of GK [Lin and Shoham, 1992], from Turner’s logic of universal causation [Turner, 1999] to the logic of GK [Ji and Lin, 2012], as well as from general logic programs [Ferraris, 2005] to the logic of GK [Lin and Zhou, 2011].",
      "startOffset" : 323,
      "endOffset" : 343
    }, {
      "referenceID" : 27,
      "context" : "Among other things, these embeddings shed new light on nonmonotonic reasoning, and have led to an interesting characterization of strong equivalence in logic programming [Lin, 2002; Lin and Zhou, 2011], and helped relate logic programming to circumscription [Lin and Shoham, 1992] as the semantics of GK is just a minimization (of knowledge) together with an identity check (of assumptions and knowledge) after the minimization.",
      "startOffset" : 170,
      "endOffset" : 201
    }, {
      "referenceID" : 26,
      "context" : "Among other things, these embeddings shed new light on nonmonotonic reasoning, and have led to an interesting characterization of strong equivalence in logic programming [Lin, 2002; Lin and Zhou, 2011], and helped relate logic programming to circumscription [Lin and Shoham, 1992] as the semantics of GK is just a minimization (of knowledge) together with an identity check (of assumptions and knowledge) after the minimization.",
      "startOffset" : 170,
      "endOffset" : 201
    }, {
      "referenceID" : 25,
      "context" : "Among other things, these embeddings shed new light on nonmonotonic reasoning, and have led to an interesting characterization of strong equivalence in logic programming [Lin, 2002; Lin and Zhou, 2011], and helped relate logic programming to circumscription [Lin and Shoham, 1992] as the semantics of GK is just a minimization (of knowledge) together with an identity check (of assumptions and knowledge) after the minimization.",
      "startOffset" : 258,
      "endOffset" : 280
    }, {
      "referenceID" : 15,
      "context" : "The result can then be used to compute the extension/expansion semantics of default logic, autoepistemic logic and Turner’s logic of universal causation by disjunctive ASP solvers such as GNT [Janhunen and Niemelä, 2004], cmodels [Giunchiglia, Lierler, and Maratea, 2006], DLV [Leone et al.",
      "startOffset" : 192,
      "endOffset" : 220
    }, {
      "referenceID" : 22,
      "context" : "The result can then be used to compute the extension/expansion semantics of default logic, autoepistemic logic and Turner’s logic of universal causation by disjunctive ASP solvers such as GNT [Janhunen and Niemelä, 2004], cmodels [Giunchiglia, Lierler, and Maratea, 2006], DLV [Leone et al., 2006], claspD [Drescher et al.",
      "startOffset" : 277,
      "endOffset" : 297
    }, {
      "referenceID" : 9,
      "context" : ", 2006], claspD [Drescher et al., 2008] and claspD-2 [Gebser, Kaufmann, and Schaub, 2013].",
      "startOffset" : 16,
      "endOffset" : 39
    }, {
      "referenceID" : 36,
      "context" : "To substantiate this claim, we have implemented the translation and report on some preliminary experiments that we conducted on the special case of computing extensions for Reiter’s default logic [Reiter, 1980].",
      "startOffset" : 196,
      "endOffset" : 210
    }, {
      "referenceID" : 36,
      "context" : "Default logic [Reiter, 1980] is for making and withdrawing assumptions in the light of incomplete knowledge.",
      "startOffset" : 14,
      "endOffset" : 28
    }, {
      "referenceID" : 36,
      "context" : "An extension of a default theory (W,D) is “interpreted as an acceptable set of beliefs that one may hold about the incompletely specified world W ” [Reiter, 1980].",
      "startOffset" : 148,
      "endOffset" : 162
    }, {
      "referenceID" : 25,
      "context" : "The language of GK proposed by Lin and Shoham [1992] is a modal propositional language with two modal operators, K, for knowledge, and A, for assumption.",
      "startOffset" : 31,
      "endOffset" : 53
    }, {
      "referenceID" : 20,
      "context" : "Autoepistemic logic An L-sentence of autoepistemic logic that is in normal form [Konolige, 1988], that is, a disjunction of the form ¬Lφ ∨ Lψ1 ∨ · · · ∨ Lψn ∨ φ, is (under expansion semantics) expressed as Aφ ∧ ¬Aψ1 ∧ · · · ∧ ¬Aψn ⊃ Kφ.",
      "startOffset" : 80,
      "endOffset" : 96
    }, {
      "referenceID" : 20,
      "context" : "Notice that the translation of default and autoepistemic theories into the logic of GK is compatible with Konolige’s translation from default logic into autoepistemic logic [Konolige, 1988].",
      "startOffset" : 173,
      "endOffset" : 189
    }, {
      "referenceID" : 45,
      "context" : "Logic of universal causation The logic of universal causation is a nonmonotonic propositional modal logic with one modality C [Turner, 1999].",
      "startOffset" : 126,
      "endOffset" : 140
    }, {
      "referenceID" : 16,
      "context" : "Inspired by the linear translation from parallel circumscription into disjunctive logic programs by Janhunen and Oikarinen [2004], we have the following theorem.",
      "startOffset" : 100,
      "endOffset" : 130
    }, {
      "referenceID" : 10,
      "context" : "Eiter and Gottlob showed that the problem of deciding whether a disjunctive logic program has an answer set is Σ2 -complete [Eiter and Gottlob, 1995].",
      "startOffset" : 124,
      "endOffset" : 149
    }, {
      "referenceID" : 4,
      "context" : "Evaluation To have a scalable problem domain and inspired by dl2asp [Chen et al., 2010], we chose the fair division problem [Bouveret and Lang, 2008] for experimental evaluation.",
      "startOffset" : 68,
      "endOffset" : 87
    }, {
      "referenceID" : 1,
      "context" : ", 2010], we chose the fair division problem [Bouveret and Lang, 2008] for experimental evaluation.",
      "startOffset" : 44,
      "endOffset" : 69
    }, {
      "referenceID" : 1,
      "context" : ", 2010], we chose the fair division problem [Bouveret and Lang, 2008] for experimental evaluation. An instance of the fair division problem consists of a set of agents, a set of goods, and for each agent a set of constraints that intuitively express which sets of goods the agent is willing to accept. A solution is then an assignment of goods to agents that is a partition of all goods and satisfies all agents’ constraints. Bouveret and Lang [2008] showed that the problem is Σ2 -complete, and can be naturally encoded in default logic.",
      "startOffset" : 45,
      "endOffset" : 451
    }, {
      "referenceID" : 1,
      "context" : "We then applied the translation of [Bouveret and Lang, 2008], furthermore the translation from default logic into the logic of GK, then invoked gk2dlp to produce logic programs and finally used gringo 3.",
      "startOffset" : 35,
      "endOffset" : 60
    }, {
      "referenceID" : 1,
      "context" : "We then applied the translation of [Bouveret and Lang, 2008], furthermore the translation from default logic into the logic of GK, then invoked gk2dlp to produce logic programs and finally used gringo 3.0.3 and claspD version 2 (revision 6814) to compute all answer sets of these programs, thus all extensions of the original default theory corresponding to all solutions of the problem instance. The experiments were conducted on a Lenovo laptop with an Intel Core i3 processor with 4 cores and 4GB of RAM running Ubuntu 12.04. We recorded the size of the default theory, the size of the translated logic program, the translation time and the solving time, as well as the number of solutions obtained. We started out with 2 agents and 2 goods, and stepwise increased these numbers towards 6. For each combination in (a, g) ∈ {2, . . . , 6} × {2, . . . , 6}, we tested 20 randomly generated instances. Random generation here means that we create agents’ preferences by iteratively drawing random subsets of goods to add to an agent’s acceptable subsets with probability P , where P is initialized with 1 and discounted by the factor g−1 g for each subset that has been drawn. In accordance with our theoretical predictions, we observed that the increase in size from GK formula to logic program is indeed polynomial (albeit with a low exponent). The plot on the right (Figure 2) shows the solving time in relation to the size of the default theory, where the time axis is logarithmic. We can see that the runtime behavior of gk2dlp is satisfactory. We acknowledge however that the runtimes we measured are not competitive with those reported by Chen et al. [2010] for dl2asp.",
      "startOffset" : 36,
      "endOffset" : 1664
    }, {
      "referenceID" : 1,
      "context" : "We then applied the translation of [Bouveret and Lang, 2008], furthermore the translation from default logic into the logic of GK, then invoked gk2dlp to produce logic programs and finally used gringo 3.0.3 and claspD version 2 (revision 6814) to compute all answer sets of these programs, thus all extensions of the original default theory corresponding to all solutions of the problem instance. The experiments were conducted on a Lenovo laptop with an Intel Core i3 processor with 4 cores and 4GB of RAM running Ubuntu 12.04. We recorded the size of the default theory, the size of the translated logic program, the translation time and the solving time, as well as the number of solutions obtained. We started out with 2 agents and 2 goods, and stepwise increased these numbers towards 6. For each combination in (a, g) ∈ {2, . . . , 6} × {2, . . . , 6}, we tested 20 randomly generated instances. Random generation here means that we create agents’ preferences by iteratively drawing random subsets of goods to add to an agent’s acceptable subsets with probability P , where P is initialized with 1 and discounted by the factor g−1 g for each subset that has been drawn. In accordance with our theoretical predictions, we observed that the increase in size from GK formula to logic program is indeed polynomial (albeit with a low exponent). The plot on the right (Figure 2) shows the solving time in relation to the size of the default theory, where the time axis is logarithmic. We can see that the runtime behavior of gk2dlp is satisfactory. We acknowledge however that the runtimes we measured are not competitive with those reported by Chen et al. [2010] for dl2asp. However, a direct comparison of the two systems is problematic for a number of reasons. First of all, the system dl2asp is not publicly available to the best of our knowledge. Furthermore, Chen et al. [2010] do not describe how they create random instances of the fair division problem, so we cannot compare the runtimes they report and the ones we measured.",
      "startOffset" : 36,
      "endOffset" : 1884
    }, {
      "referenceID" : 34,
      "context" : "Reiter [1987] provided a theory of diagnosis from first principles, and showed how default logic can be used as an implementation device.",
      "startOffset" : 0,
      "endOffset" : 14
    }, {
      "referenceID" : 34,
      "context" : "Reiter [1987] provided a theory of diagnosis from first principles, and showed how default logic can be used as an implementation device. Cadoli, Eiter, and Gottlob [1994] proposed to use default logic as an expressive query language on top of relational databases, and gave an example of achieving strategic behavior in an economic setting.",
      "startOffset" : 0,
      "endOffset" : 172
    }, {
      "referenceID" : 34,
      "context" : "Reiter [1987] provided a theory of diagnosis from first principles, and showed how default logic can be used as an implementation device. Cadoli, Eiter, and Gottlob [1994] proposed to use default logic as an expressive query language on top of relational databases, and gave an example of achieving strategic behavior in an economic setting. In reasoning about actions, Thielscher [1996] used default logic to solve the qualification problem of dealing with unexpected action failures.",
      "startOffset" : 0,
      "endOffset" : 388
    }, {
      "referenceID" : 27,
      "context" : "In reasoning about actions, Thielscher [1996] used default logic to solve the qualification problem of dealing with unexpected action failures. Martin and Thielscher [2001] later provided an implementation of that approach where extensions are enumer0.",
      "startOffset" : 106,
      "endOffset" : 173
    }, {
      "referenceID" : 42,
      "context" : "Our translation yields an implementation of their approach, something that they stated as future work and later achieved to a limited extent (for a restricted sublanguage of their framework [Strass, 2012]).",
      "startOffset" : 190,
      "endOffset" : 204
    }, {
      "referenceID" : 2,
      "context" : "[2013] looked at belief change in the situation calculus and proposed an implementation based on default logic with preferences [Brewka, 1994; Delgrande and Schaub, 2000].",
      "startOffset" : 128,
      "endOffset" : 170
    }, {
      "referenceID" : 6,
      "context" : "[2013] looked at belief change in the situation calculus and proposed an implementation based on default logic with preferences [Brewka, 1994; Delgrande and Schaub, 2000].",
      "startOffset" : 128,
      "endOffset" : 170
    }, {
      "referenceID" : 0,
      "context" : "Recently, Baumann et al. [2010] introduced a method for default reasoning in action theories, that is, an approach to the question what normally holds in a dynamic domain.",
      "startOffset" : 10,
      "endOffset" : 32
    }, {
      "referenceID" : 0,
      "context" : "Recently, Baumann et al. [2010] introduced a method for default reasoning in action theories, that is, an approach to the question what normally holds in a dynamic domain. Our translation yields an implementation of their approach, something that they stated as future work and later achieved to a limited extent (for a restricted sublanguage of their framework [Strass, 2012]). In a similar vein, Pagnucco et al. [2013] looked at belief change in the situation calculus and proposed an implementation based on default logic with preferences [Brewka, 1994; Delgrande and Schaub, 2000].",
      "startOffset" : 10,
      "endOffset" : 421
    }, {
      "referenceID" : 24,
      "context" : "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994].",
      "startOffset" : 137,
      "endOffset" : 154
    }, {
      "referenceID" : 14,
      "context" : "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994].",
      "startOffset" : 184,
      "endOffset" : 199
    }, {
      "referenceID" : 41,
      "context" : "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994].",
      "startOffset" : 236,
      "endOffset" : 268
    }, {
      "referenceID" : 4,
      "context" : "The recent system dl2asp [Chen et al., 2010] translates default theories to normal (non-disjunctive) logic programs; the translation figures out all implication relations between formulas occurring in the default theory, just as Junker and Konolige [1990] did.",
      "startOffset" : 25,
      "endOffset" : 44
    }, {
      "referenceID" : 4,
      "context" : "The authors of dl2asp [Chen et al., 2010] already observed that default logic and disjunctive logic programs are of the same complexity; they even stated the search for a polynomial translation from the former to the latter (that we achieved in this paper) as future work.",
      "startOffset" : 22,
      "endOffset" : 41
    }, {
      "referenceID" : 15,
      "context" : "Related work The translation presented in this paper is a generalization of the one presented for Turner’s logic of universal causation by Ji and Lin [2013]. We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994].",
      "startOffset" : 139,
      "endOffset" : 157
    }, {
      "referenceID" : 13,
      "context" : "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemelä [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz’ logic of minimal belief and negation as failure [1994].",
      "startOffset" : 185,
      "endOffset" : 491
    }, {
      "referenceID" : 13,
      "context" : "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemelä [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz’ logic of minimal belief and negation as failure [1994].",
      "startOffset" : 185,
      "endOffset" : 611
    }, {
      "referenceID" : 13,
      "context" : "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemelä [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz’ logic of minimal belief and negation as failure [1994].",
      "startOffset" : 185,
      "endOffset" : 752
    }, {
      "referenceID" : 13,
      "context" : "We chose the logic of GK as general nonmonotonic language, we could also have chosen the logic of minimal belief and negation as failure [Lifschitz, 1994], the logic of here-and-there [Heyting, 1930] or the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994]. In terms of implementations, there are few approaches that treat as broad a range of propositional nonmonotonic knowledge representation languages as gk2dlp. Notable exceptions are the works of Junker and Konolige [1990], who implemented both autoepistemic and default logics by translating them to truth maintenance systems; Niemelä [1995], who provides a decision procedure for autoepistemic logic which also incorporates extension semantics for default logics; and Rosati [1999], who provides algorithms for Lifschitz’ logic of minimal belief and negation as failure [1994]. Other approaches are restricted to specific languages, where default logic seems to be most popular.",
      "startOffset" : 185,
      "endOffset" : 847
    }, {
      "referenceID" : 4,
      "context" : "The recent system dl2asp [Chen et al., 2010] translates default theories to normal (non-disjunctive) logic programs; the translation figures out all implication relations between formulas occurring in the default theory, just as Junker and Konolige [1990] did.",
      "startOffset" : 26,
      "endOffset" : 256
    }, {
      "referenceID" : 5,
      "context" : "2000] uses a genetic algorithm to compute extensions of a default theory; likewise the system DeReS [Cholewiński et al., 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics.",
      "startOffset" : 100,
      "endOffset" : 126
    }, {
      "referenceID" : 40,
      "context" : ", 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics.",
      "startOffset" : 97,
      "endOffset" : 123
    }, {
      "referenceID" : 5,
      "context" : "2000] uses a genetic algorithm to compute extensions of a default theory; likewise the system DeReS [Cholewiński et al., 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics. Risch and Schwind [1994] describe a tableauxbased algorithm for computing all extensions of general default theories, but do not report runtimes for their Prologbased implementation.",
      "startOffset" : 101,
      "endOffset" : 320
    }, {
      "referenceID" : 5,
      "context" : "2000] uses a genetic algorithm to compute extensions of a default theory; likewise the system DeReS [Cholewiński et al., 1999] is not translation-based but directly searches for extensions; similarly the XRay system [Schaub and Nicolas, 1997] implements local query-answering in default logics. Risch and Schwind [1994] describe a tableauxbased algorithm for computing all extensions of general default theories, but do not report runtimes for their Prologbased implementation. For autoepistemic logic, Marek and Truszczyński [1991] investigate sceptical reasoning with respect to Moore’s expansion semantics.",
      "startOffset" : 101,
      "endOffset" : 533
    }, {
      "referenceID" : 2,
      "context" : "Particular formalism we want to look at are default logics with preferences [Brewka, 1994; Delgrande and Schaub, 2000] and the logic of only-knowing [Lakemeyer and Levesque, 2005].",
      "startOffset" : 76,
      "endOffset" : 118
    }, {
      "referenceID" : 6,
      "context" : "Particular formalism we want to look at are default logics with preferences [Brewka, 1994; Delgrande and Schaub, 2000] and the logic of only-knowing [Lakemeyer and Levesque, 2005].",
      "startOffset" : 76,
      "endOffset" : 118
    }, {
      "referenceID" : 21,
      "context" : "Particular formalism we want to look at are default logics with preferences [Brewka, 1994; Delgrande and Schaub, 2000] and the logic of only-knowing [Lakemeyer and Levesque, 2005].",
      "startOffset" : 149,
      "endOffset" : 179
    }, {
      "referenceID" : 41,
      "context" : "It also seems worthwhile to check whether our translation can be adapted to the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994; Truszczyński, 2007], that has only one modality instead of two.",
      "startOffset" : 109,
      "endOffset" : 161
    }, {
      "referenceID" : 44,
      "context" : "It also seems worthwhile to check whether our translation can be adapted to the nonmonotonic modal logic S4F [Schwarz and Truszczynski, 1994; Truszczyński, 2007], that has only one modality instead of two.",
      "startOffset" : 109,
      "endOffset" : 161
    } ],
    "year" : 2014,
    "abstractText" : "The logic of knowledge and justified assumptions, also known as the logic of grounded knowledge (GK), was proposed by Lin and Shoham as a general logic for nonmonotonic reasoning. To date, it has been used to embed in it default logic (propositional case), autoepistemic logic, Turner’s logic of universal causation, and general logic programming under stable model semantics. Besides showing the generality of GK as a logic for nonmonotonic reasoning, these embeddings shed light on the relationships among these other logics. In this paper, for the first time, we show how the logic of GK can be embedded into disjunctive logic programming in a polynomial but non-modular translation with new variables. The result can then be used to compute the extension/expansion semantics of default logic, autoepistemic logic and Turner’s logic of universal causation by disjunctive ASP solvers such as GNT, cmodels, DLV, and claspD(-2).",
    "creator" : "LaTeX with hyperref package"
  }
}