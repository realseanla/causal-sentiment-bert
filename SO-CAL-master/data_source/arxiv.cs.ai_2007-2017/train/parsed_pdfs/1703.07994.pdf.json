{
  "name" : "1703.07994.pdf",
  "metadata" : {
    "source" : "CRF",
    "title" : "Containment for Rule-Based Ontology-Mediated Queries",
    "authors" : [ "Pablo Barceló", "Andreas Pieris" ],
    "emails" : [ "pbarcelo@dcc.uchile.cl", "gberger@dbai.tuwien.ac.at", "apieris@inf.ed.ac.uk" ],
    "sections" : [ {
      "heading" : null,
      "text" : "ar X\niv :1\n70 3.\n07 99\n4v 1\n[ cs\n.D B\n] 2\n3 M\nar 2\n01 7\nMany efforts have been dedicated to identify restrictions on ontologies expressed as tuple-generating dependencies (tgds), a.k.a. existential rules, that lead to the decidability for the problem of answering ontology-mediated queries (OMQs). This has given rise to three families of formalisms: guarded, non-recursive, and sticky sets of tgds. In this work, we study the containment problem for OMQs expressed in such formalisms, which is a key ingredient for solving static analysis tasks associated with them. Our main contribution is the development of specially tailored techniques for OMQ containment under the classes of tgds stated above. This enables us to obtain sharp complexity bounds for the problems at hand.\nWe start with OMQs based on linear (a core fragment of guarded tgds), non-recursive and sticky sets of tgds, which share the property of UCQ rewritability. By exploiting this property, we obtain a small witness property for non-containment that allows us to devise standard “guessand-check” algorithms. Based on this, we prove that OMQ containment for linear tgds is PSpace-complete, but ΠP2 - complete if the arity of the schema is fixed, while for sticky sets of tgds it is coNExpTime-complete, and ΠP2 -complete in the case of fixed arity. For non-recursive sets of tgds, the problem is in ExpSpace and PNEXP-hard even for fixed-arity schemas. Hence, in all the cases the containment problem is harder (under widely accepted complexity assumptions) than query evaluation, with the exception of linear tgds over schemas of unbounded arity, where both problems are complete for PSpace. For OMQs based on guarded tgds, which are not UCQ rewritable in general, we establish a tree witness property, and use it in combination with tree automata techniques to prove that OMQ containment has the same complexity as query evaluation, i.e., 2ExpTimecomplete. Unlike query evaluation, though, OMQ containment for guarded tgds remains 2ExpTime-hard over fixedarity schemas. Lastly, we apply our techniques to pinpoint the complexity of problems associated with two emerging\napplications of OMQ containment: distribution over components and UCQ rewritability of OMQs."
    }, {
      "heading" : "1. INTRODUCTION",
      "text" : "Motivation and goals. The novel application of knowledge representation tools for handling incomplete and heterogeneous data is giving rise to a new field, recently coined as knowledge-enriched data management [5]. A crucial problem in this field is ontology-based data access (OBDA) [42], which refers to the utilization of ontologies (basically, logical theories) for providing a unified conceptual view of various data sources. Users can then pose their queries solely in the schema provided by the ontology, abstracting away from the specifics of the individual sources. In OBDA, one interprets the ontology Σ and the user query q, which is typically a union of conjunctive queries (UCQ), as two components of one composite query Q = (S,Σ, q) known as ontologymediated query (OMQ). Here, S is the data schema, indicating that Q will be posed on databases over S [18]. Thus, OBDA is often realized as the problem of answering OMQs.\nWhile in this setting description logics (DLs) are often used for modeling ontologies, it is widely accepted that for handling arbitrary arity relations in relational databases it is convenient to use tuple-generating dependencies (tgds), a.k.a. existential rules or Datalog± rules; cf. [33]. Several aspects of OMQs in which the ontology corresponds to a set of tgds and the actual query is a UCQ (simply called OMQs from now on) have been studied in the data management literature; most notably (a) query evaluation [7, 22, 23, 24], i.e., given an OMQ Q = (S,Σ, q), a database D over S, and a tuple of constants c̄, does c̄ belong to the evaluation of q over every extension of D that satisfies Σ, or, equivalently, is c̄ a certain answer for Q over D? and (b) relative expressiveness [18, 35, 36]: how does the expressiveness of OMQs compare to the one of other query languages?\nThis work focuses on another crucial task for OMQs; namely, containment: for two OMQs Q1 and Q2 with data schema S, does Q1(D) ⊆ Q2(D) hold for every (finite) database D over S (where Q(D) denotes the certain answers for Q overD)? Apart from the traditional applications of containment, such as query optimization or view-based query answering, it has been recently shown that OMQ containment has applications on other important static analysis tasks, namely, distribution over components [14], and UCQ rewritability [15]. Surprisingly, despite its prominence, no work to date has carried out an in-depth investigation of containment for OMQs based on tgds.\nAs one might expect, when considered in its full generality, i.e., without any restrictions on the set of tgds, the OMQ containment problem is undecidable. To understand, on the other hand, which restrictions lead to decidability, it is important to recall the two main reasons that render the general containment problem undecidable. These are:\nUndecidability of query evaluation: OMQ evaluation is, in general, undecidable [11], and it can be reduced to OMQ containment. More precisely, OMQ containment is undecidable whenever query evaluation for at least one of the involved languages (i.e., the language of the left-hand or the right-hand side query) is undecidable.\nUndecidability of containment for Datalog: decidability of query evaluation does not ensure decidability of query containment. A prime example is Datalog, or, equivalently, the OMQ language based on full tgds. Datalog containment is undecidable [45], and thus, OMQ containment is undecidable if the involved languages extend Datalog.\nIn view of the above observations, we focus on languages that (a) have a decidable query evaluation, and (b) do not extend Datalog. The main classes of tgds, which give rise to OMQ languages with the desirable properties, can be classified into three main families depending on the syntactic restrictions imposed on them: (i) guarded tgds [22], which contain inclusion and linear dependencies, (ii) non-recursive sets of tgds [31], and (iii) sticky sets of tgds [24].\nWhile the decidability of containment for the above OMQ languages can be established via translations into query languages with a decidable containment problem, such translations do not lead to optimal complexity upper bounds (details are given below). Therefore, the main goal of our paper is to develop specially tailored decision procedures for the containment problem under the OMQ languages in question, and ideally obtain precise complexity bounds. Our second goal is to exploit such techniques in the study of distribution over components and UCQ rewritability of OMQs.\nOur contributions. The complexity of OMQ containment for the languages in question is given in Table 1. Using small fonts, we recall the complexity of OMQ evaluation in order to stress that containment is, in general, harder than evaluation. We divide our contributions as follows:\nLinear, non-recursive and sticky sets of tgds. The OMQ languages based on linear, non-recursive, and sticky sets of tgds share a useful property: they are UCQ rewritable (implicit in [33]), that is, an OMQ can be rewritten into a UCQ. This property immediately yields decidability for their associated containment problems, since UCQ containment is decidable [44]. However, the obtained complexity bounds are not optimal, since the UCQ rewritings are unavoidably very large [33]. To obtain more precise bounds, we reduce containment to query evaluation, an idea that is often applied in query containment; see, e.g., [26, 27, 44].\nConsider a UCQ rewritable OMQ language O. If Q1 and Q2 belong to O, both with data schema S, then we can establish a small witness property, which states that noncontainment of Q1 in Q2 can be witnessed via a database over S whose size is bounded by an integer k ≥ 0, the maximal size of a disjunct in a UCQ rewriting of Q1. For linear tgds, such an integer k is polynomial, but for non-recursive and sticky sets of tgds it is exponential (implicit in [33]).\nThe above small witness property allows us to devise a simple non-deterministic algorithm, which makes use of query evaluation as a subroutine for checking non-containment of Q1 in Q2: guess a database D over S of size at most k, and then check if there is a certain answer for Q1 over D that is not a certain answer for Q2 over D. This algorithm allows us to obtain optimal upper bounds for OMQs based on linear and sticky sets of tgds; however, the exact complexity of OMQs based on non-recursive sets of tgds remains open:\n• For OMQs based on linear tgds, the containment problem is in PSpace, and in ΠP2 if the arity of the schema is fixed. The PSpace-hardness is shown by reduction from query evaluation [39], while the ΠP2 -hardness is inherited from [16].\n• For OMQs based on sticky sets of tgds, the problem is in coNExpTime, and in ΠP2 if the arity of the schema is fixed. The coNExpTime-hardness is shown by exploiting the standard tiling problem for the exponential grid, while the ΠP2 -hardness is inherited from [16].\n• Finally, for OMQs based on non-recursive sets of tgds, containment is in ExpSpace and hard for PNEXP, even for fixed arity. The lower bound is shown by exploiting a recently introduced tiling problem [30].\nWe conclude that in all these cases OMQ containment is harder than evaluation, with one exception: the OMQs based on linear tgds over schemas of unbounded arity, where both problems are PSpace-complete.\nGuarded tgds. The OMQ language based on guarded tgds is not UCQ rewritable, which forces us to develop different tools to study its containment problem. Let us remark that guarded OMQs can be rewritten as guarded Datalog queries (by exploiting the translations devised in [8, 36]), for which containment is decidable in 2ExpTime [19]. But, again, the known rewritings are very large [36], and hence the reduction of containment for guarded OMQs to containment for guarded Datalog does not yield optimal upper bounds.\nTo obtain optimal bounds for the problem in question, we exploit two-way alternating parity automata on trees (2WAPA) [28]. We first show that if Q1 and Q2 are guarded OMQs such that Q1 is not contained in Q2, then this is witnessed over a class of “tree-like” databases that can be represented as the set of trees accepted by a 2WAPA A. We then build a 2WAPA B with exponentially many states that recognizes those trees accepted by A that represent witnesses to non-containment of Q1 in Q2. Hence, Q1 is contained in Q2 iff B accepts no tree. Since the emptiness problem for 2WAPA is feasible in exponential time in the number of states [28], we obtain that containment for guarded OMQs is in 2ExpTime. A matching lower bound, even for fixed arity schemas, follows from [15].\nSimilar ideas based on 2WAPA have been recently used to show that containment for OMQs based on expressive DLs is in 2ExpTime [15]. As usual in the DL context, schemas consist only of unary and binary relations. Our automata construction, however, is different from the one in [15] for two reasons: (a) we need to deal with higher arity relations, and (b) even for schemas of unary and binary relations, our OMQ language allows to express properties that are not expressible by the DL-based OMQ languages studied in [15].\nCombining languages. The above complexity results refer to the containment problem relative to a certain OMQ language O, i.e., both queries fall in O. However, it is natural to consider the version of the problem where the involved OMQs fall in different languages. Unsurprisingly, if the lefthand side query is expressed in a UCQ rewritable OMQ language (based on linear, non-recursive or sticky sets of tgds), we can use the algorithm that relies on the small witness property discussed above, which provides optimal upper bounds for almost all the considered cases (the only exception is the containment of sticky in non-recursive OMQs over schemas of unbounded arity). Things are more interesting if the ontology of the left-hand side query is expressed using guarded tgds, while the ontology of the right-hand side query is not guarded. By exploiting automata techniques, we show that containment of guarded in non-recursive OMQs is in 3ExpTime, while containment of guarded in sticky OMQs is in 2ExpTime. We establish matching lower bounds, even over schemas of fixed arity, by refining techniques from [27].\nApplications. Our techniques and results on containment for guarded OMQs can be applied to other important static analysis tasks, in particular, distribution over components and UCQ rewritability.\nThe notion of distribution over components has been introduced in [2], in the context of declarative networking, and it states that the answer to an OMQ Q can be computed by parallelizing it over the (maximally connected) components of the database. If this is the case, then Q can always be evaluated in a distributed and coordination-free manner. The problem of deciding distribution over components for OMQs has been recently studied in [14]. However, the exact complexity of the problem for guarded OMQs has been left open. By exploiting our results on containment, we can show that it is 2ExpTime-complete.\nIt is well-known that the OMQ language based on guarded tgds is not UCQ rewritable. In view of this fact, it is important to study when a given guarded OMQQ can be rewritten as a UCQ. This has been studied for OMQs based on central Horn DLs [15, 17]. Interestingly, our automata-based techniques for guarded OMQ containment can be adapted to decide in 2ExpTime whether an OMQ based on guarded tgds over unary and binary relations is UCQ rewritable; a matching lower bound is inherited from [15]. Our result generalizes the result that deciding UCQ rewritability for OMQs based on ELHI, one of the most expressive members of the EL-family of DLs, is 2ExpTime-complete [15].\nOrganization. Preliminaries are in Section 2. In Section 3 we introduce the OMQ containment problem. Containment for UCQ rewritable OMQs is studied in Section 4, and for\nguarded OMQs in Section 5. In Section 6 we consider the case where the involved queries fall in different languages. In Section 7 we discuss the applications of our results on guarded OMQ containment and we conclude in Section 8. Full proofs and details can be found in the appendix."
    }, {
      "heading" : "2. PRELIMINARIES",
      "text" : "Databases and conjunctive queries. Let C, N, and V be disjoint countably infinite sets of constants, (labeled) nulls and (regular) variables (used in queries and dependencies), respectively. A schema S is a finite set of relation symbols (or predicates) with associated arity. We write R/n to denote that R has arity n. A term is a either a constant, null or variable. An atom over S is an expression of the form R(v̄), where R ∈ S is of arity n > 0 and v̄ is an n-tuple of terms. A fact is an atom whose arguments consist only of constants. An instance over S is a (possibly infinite) set of atoms over S that contain constants and nulls, while a database over S is a finite set of facts over S. We may call an instance and a database over S an S-instance and S-database, respectively. The active domain of an instance I , denoted dom(I), is the set of all terms occurring in I .\nA conjunctive query (CQ) over S is a formula of the form:\nq(x̄) := ∃ȳ ( R1(v̄1) ∧ · · · ∧Rm(v̄m) ) , (1)\nwhere each Ri(v̄i) (1 ≤ i ≤ m) is an atom without nulls over S, each variable mentioned in the v̄i’s appears either in x̄ or ȳ, and x̄ are the free variables of q. If x̄ is empty, then q is a Boolean CQ. As usual, the evaluation of CQs is defined in terms of homomorphisms. Let I be an instance and q(x̄) a CQ of the form (1). A homomorphism from q to I is a mapping h, which is the identity on C, from the variables that appear in q to the set of constants and nulls C ∪ N such that Ri(h(v̄i)) ∈ I , for each 1 ≤ i ≤ m. The evaluation of q(x̄) over I , denoted q(I), is the set of all tuples h(x̄) of constants such that h is a homomorphism from q to I . We denote by CQ the class of conjunctive queries.\nA union of conjunctive queries (UCQ) over S is a formula of the form q(x̄) := q1(x̄)∨ · · · ∨ qn(x̄), where each qi(x̄) is a CQ of the form (1). The evaluation of q(x̄) over I , denoted q(I), is the set of tuples ⋃\n1≤i≤n qi(I). We denote by UCQ the class of union of conjunctive queries.\nTgds and the chase procedure. A tuple-generating dependency (tgd) is a first-order sentence of the form:\n∀x̄∀ȳ ( φ(x̄, ȳ) → ∃z̄ ψ(x̄, z̄) ) , (2)\nwhere φ and ψ are conjunctions of atoms without nulls. For brevity, we write this tgd as φ(x̄, ȳ) → ∃z̄ ψ(x̄, z̄) and use comma instead of ∧ for conjoining atoms. Notice that φ\ncan be empty, in which case the tgd is called fact tgd and is written as ⊤ → ∃z̄ ψ(x̄, z̄). We assume that each variable in x̄ is mentioned in some atom of ψ. We call φ and ψ the body and head of the tgd, respectively. The tgd in (2) is logically equivalent to the expression ∀x̄(qφ(x̄) → qψ(x̄)), where qφ(x̄) and qψ(x̄) are the CQs ∃ȳ φ(x̄, ȳ) and ∃z̄ ψ(x̄, z̄), respectively. Thus, an instance I over S satisfies this tgd iff qφ(I) ⊆ qψ(I). We say that an instance I satisfies a set Σ of tgds, denoted I |= Σ, if I satisfies every tgd in Σ. We denote by TGD the class of (finite) sets of tgds.\nThe chase is a useful algorithmic tool when reasoning with tgds [22, 31, 39, 41]. We start by defining a single chase step. Let I be an instance over a schema S and τ = φ(x̄, ȳ) → ∃z̄ ψ(x̄, z̄) a tgd over S. We say that τ is applicable w.r.t. I if there exists a tuple (ā, b̄) of terms in I such that φ(ā, b̄) holds in I . In this case, the result of applying τ over I with (ā, b̄) is the instance J that extends I with every atom in ψ(ā, ⊥̄), where ⊥̄ is the tuple obtained by simultaneously replacing each variable z ∈ z̄ with a fresh distinct null not occurring in I . For such a single chase step we write I τ,(ā,b̄) −−−−→ J .\nLet us assume now that I is an instance and Σ a finite set of tgds. A chase sequence for I under Σ is a sequence:\nI0 τ0,c̄0−−−→ I1 τ1,c̄1−−−→ I2 · · ·\nof chase steps such that: (1) I0 = I ; (2) for each i ≥ 0, τi is a tgd in Σ; and (3) ⋃\ni≥0 Ii |= Σ. We call ⋃\ni≥0 Ii the result of this chase sequence, which always exists. Although the result of a chase sequence is not necessarily unique (up to isomorphism), each such result is equally useful for our purposes, since it can be homomorphically embedded into every other result. Thus, from now on, we denote by chase(I,Σ) the result of an arbitrary chase sequence for I under Σ.\nOntology-mediated queries. An ontology-mediated query (OMQ) is a triple (S,Σ, q), where S is a schema, Σ is a set of tgds (the ontology), and q is a (U)CQ over S∪ sch(Σ) (and possibly other predicates), with sch(Σ) the set of predicates occurring in Σ.1 We call S the data schema. Notice that the set of tgds can introduce predicates not in S, which allows us to enrich the schema of the UCQ q. Moreover, the tgds can modify the content of a predicate R ∈ S, or, in other words, R can appear in the head of a tgd of Σ. We have explicitly included S in the specification of the OMQ to emphasize that it will be evaluated over S-databases, even though Σ and q might use additional relational symbols.\nThe semantics of an OMQ is given in terms of certain answers. The certain answers to a UCQ q(x̄) w.r.t. a database D and a set Σ of tgds is the set of tuples:\ncert(q,D,Σ) = ⋂\nI⊇D,I|=Σ\n{c̄ ∈ dom(I)|x̄| | c̄ ∈ q(I)}.\nConsider an OMQ Q = (S,Σ, q). The evaluation of Q over an S-database D, denoted Q(D), is defined as cert(q,D,Σ). It is well-known that cert(q,D,Σ) = q(chase(D,Σ)); see, e.g., [22]. Thus, Q(D) = q(chase(D,Σ)).\nOntology-mediated query languages. We write (C,Q) for the OMQ language that consists of all OMQs of the form (S,Σ, q), where Σ falls in the class C of tgds, i.e., C ⊆ TGD (concrete classes of tgds are discussed below), and the query\n1OMQs can be defined for arbitrary first-order theories, not only tgds, and first-order queries, not only UCQs [18].\n(a)\nT(x,y,z) → ∃w S(x,w)\nR(x,y), P(y,z) → ∃w T(x,y,w)\n(b)\n×\nT(x,y,z) → ∃w S(y,w)\nR(x,y), P(y,z) → ∃w T(x,y,w)\nT(x,y,z) → ∃w S(x,w)\nR(x,y), P(y,z) → ∃w T(x,y,w)\ntechniques (more details on query rewriting are given in Section 4). The goal of stickiness is to capture joins among variables that are not expressible via guarded tgds, but without forcing the chase to terminate. The key property underlying this condition can be described as follows: during the chase, terms that are associated (via a homomorphism) with variables that appear more than once in the body of a tgd (i.e., join variables) are always propagated (or “stick”) to the inferred atoms. This is illustrated in Figure 1(a); the left set of tgds is sticky, while the right set is not. The formal definition is based on an inductive marking procedure that marks the variables that may violate the semantic property of the chase described above [24]. Roughly, during the base step of this procedure, a variable that appears in the body of a tgd τ but not in every head-atom of τ is marked. Then, the marking is inductively propagated from head to body as shown in Figure 1(b). Finally, a finite set of tgds Σ is sticky if no tgd in Σ contains two occurrences of a marked variable. Let S be the class of sticky (finite) sets of tgds. Then:\nProposition 4. [24] Eval(S,CQ) and Eval(S,UCQ) are ExpTime-complete, and NP-complete for fixed arity."
    }, {
      "heading" : "3. OMQ CONTAINMENT: THE BASICS",
      "text" : "The goal of this work is to study in depth the problem of checking whether an OMQ Q1 is contained in an OMQ Q2, both over the same data schema S, or, equivalently, whether Q1(D) ⊆ Q2(D) over every (finite) S-database D. In this case we write Q1 ⊆ Q2; we write Q1 ≡ Q2 if Q1 ⊆ Q2 and Q2 ⊆ Q1. The OMQ containment problem in question is defined as follows; O1 and O2 are OMQ languages (C,Q), where C is a class of tgds (e.g., linear, non-recursive, sticky, etc.), and Q ∈ {CQ,UCQ}:\nPROBLEM : Cont(O1,O2) INPUT : Two OMQs Q1 ∈ O1 and Q2 ∈ O2. QUESTION : Does Q1 ⊆ Q2?\nWhenever O1 = O2 = O, we refer to the containment problem by simply writing Cont(O).\nIn what follows, we establish some simple but fundamental results, which help to better understand the nature of our problem. We first investigate the relationship between evaluation and containment, which in turn allows us to obtain an initial boundary for the decidability of our problem, i.e., we can obtain a positive result only if the evaluation problem for the involved OMQ languages is decidable (e.g., those introduced in the previous section). We then focus on the OMQ languages introduced in Section 2 and observe that, once we fix the class of tgds, it does not make a difference whether we consider CQs or UCQs. In other words, we show that an OMQ in (C,UCQ), where C ∈ {G,L,NR, S}, can be rewritten as an OMQ in (C,CQ). This fact simplifies our later complexity analysis since for establishing upper (resp., lower) bounds it suffices to focus on CQs (resp., UCQs)."
    }, {
      "heading" : "3.1 Evaluation vs. Containment",
      "text" : "As one might expect, OMQ evaluation and OMQ containment are strongly connected. In fact, as we explain below, the former can be easily reduced to the latter. But let us first introduce some auxiliary notation. Consider a database D and a tuple c̄ = (c1, . . . , cn) ∈ dom(D)\nn, where n ≥ 0. We denote by qD,c̄(x̄), where x̄ = (xc1 , . . . , xcn), the CQ\nobtained from the conjunction of atoms occurring in D after replacing each constant c with the variable xc. Consider now an OMQ Q = (S,Σ, q(x̄)) ∈ (C,CQ), where C is some class of tgds, an S-database D, and a tuple c̄ ∈ dom(D)|x̄|. It is not difficult to show that\nc̄ ∈ Q(D) ⇐⇒ (sch(Σ),∅, qD,c̄) ︸ ︷︷ ︸\nQ1\n⊆ (sch(Σ),Σ, q) ︸ ︷︷ ︸\nQ2\n.\nLet O∅ be the OMQ language that consists of all OMQs of the form (S,∅, q), i.e., the set of tgds is empty, where q is a CQ. It is clear that Q1 ∈ O∅ and Q2 ∈ (C,CQ). Therefore, for every OMQ language O = (C,CQ), where C is a class of tgds, we immediately get that:\nProposition 5. Eval(O) can be reduced in polynomial time into Cont(O∅,O).\nWe now show that the problem of evaluation is reducible to the complement of containment. Let us say that, for technical reasons which will be made clear in a while, we focus our attention on classes C of tgds that are closed under fact tgd extension, i.e., for every set Σ ∈ C, a set obtained from Σ by adding a (finite) set of fact tgds is still in C. This is not an unnatural assumption since every reasonable class of tgds, such as the ones introduced above, enjoy this property. Consider now an OMQ Q = (S,Σ, q(x̄)) ∈ (C,CQ), where C is some class of tgds, an S-database D, and a tuple c̄ ∈ dom(D)|x̄|. It is easy to see that\nc̄ ∈ Q(D) ⇐⇒ (S,Σ⋆D, q ⋆ c̄ )\n︸ ︷︷ ︸ Q1\n6⊆ (S,∅, ∃xP (x)) ︸ ︷︷ ︸\nQ2\n,\nwhere Σ⋆D is obtained from Σ by renaming each predicate R in Σ into R⋆ 6∈ S and adding the set of fact tgds\n{⊤ → R⋆(c1, . . . , ck) | R(c1, . . . , ck) ∈ D},\nq⋆c̄ is obtained from q(c̄) by renaming each predicate R into R⋆ 6∈ S, and the predicate P does not occur in S. Indeed, the above equivalence holds since P 6∈ S implies that Q2(D) = ∅, for every S-database D. Since C is closed under fact tgd extension, Q1 ∈ (C,CQ), while Q2 ∈ O∅. We write coCont(O1,O2) for the complement of Cont(O1,O2). Hence, for every OMQ language O = (C,CQ), where C is a class of tgds (closed under fact tgd extension), it holds that:\nProposition 6. Eval(O) can be reduced in polynomial time into coCont(O,O∅).\nBy definition, O∅ is contained in every OMQ language (C,CQ), where C is a class of tgds. Therefore, as a corollary of Propositions 5 and 6, we obtain an initial boundary for the decidability of OMQ containment: we can obtain a positive result only if the evaluation problem for the involved OMQ languages is decidable. More formally:\nCorollary 7. Cont(O1,O2) is undecidable if Eval(O1) is undecidable or Eval(O2) is undecidable.\nCan we prove the converse of Corollary 7: Cont(O1,O2) is decidable if both Eval(O1) and Eval(O2) are decidable? The answer to this question is negative. This is due to the fact that containment of Datalog queries is undecidable [45]. Since Datalog queries can be directly encoded in the OMQ language based on the class F of full tgds, i.e., those without existentially quantified variables, we obtain the following:\nProposition 8. [45] Cont((F,CQ)) is undecidable.\nThis result, combined with the fact that Eval(F) is decidable (since the chase under full tgds always terminates), implies that the converse of Corollary 7 does not hold. Proposition 8 also rules out the OMQ languages that are based on classes of tgds that extend F; e.g., the weak versions of the ones introduced in Section 2, called weakly guarded [22], weakly acyclic [31], and weakly sticky [24] that guarantee the decidability of OMQ evaluation.2 The question that comes up concerns the decidability and complexity of containment for the OMQ languages that are based on the non-weak versions of the above classes, i.e., guarded, non-recursive, and sticky. This will be the subject of the next two sections."
    }, {
      "heading" : "3.2 From UCQs to CQs",
      "text" : "Before we proceed with the complexity analysis of containment for the OMQ languages in question, let us state the following useful result:\nProposition 9. Given an OMQ Q ∈ (C,UCQ), where C ∈ {G,L,NR, S}, we can construct in polynomial time an OMQ Q′ ∈ (C,CQ) such that Q ≡ Q′.\nThe proof of Proposition 9 relies on the idea of encoding boolean operations (in our case the ‘or’ operator) using a set of atoms; this idea has been used in several other works (see, e.g., [13, 20, 34]). Proposition 9 allows us to focus on OMQs that are based on CQs; in fact, Cont((C1,CQ), (C2,CQ)) is C-complete, where C1,C2 ∈ {G,L,NR, S} and C is a complexity class that is closed under polynomial time reductions, iff Cont((C1,UCQ), (C2,UCQ)) is C-complete."
    }, {
      "heading" : "3.3 Plan of Attack",
      "text" : "We are now ready to proceed with the complexity analysis of containment for the OMQ languages in question. Our plan of attack can be summarized as follows:\n• We consider, in Section 4, Cont((C,CQ)), for C ∈ {L,NR, S}. These languages enjoy a crucial property, called UCQ rewritability, which is very useful for our purposes. This property allows us to show the following result: if the containment does not hold, then this is witnessed via a “small” database, which in turn allows us to devise simple guess-and-check algorithms. • We then proceed, in Section 5, with Cont((G,CQ)). This OMQ language does not enjoy UCQ rewritability, and the task of establishing a small witness property as above turned out to be challenging. However, we show the following: if the containment does not hold, then this is witnessed via a “tree-shaped” database, which allows us to devise a decision procedure based on two-way alternating parity automata on finite trees. • In Section 6, we study the case where the OMQ containment problem involves two different languages. If the left-hand side language is UCQ rewritable, then we can devise a guess-and-check algorithm by exploiting the above small witness property. The challenging case is when the left-hand side language is (G,CQ), where again we employ techniques based on tree automata.\n2The idea of those classes is the same: relax the conditions in the definition of the class, so that only those positions that receive null values during the chase are taken into account."
    }, {
      "heading" : "4. UCQ REWRITABLE LANGUAGES",
      "text" : "We now focus on OMQ languages that enjoy the crucial property of UCQ rewritability.\nDefinition 1. (UCQ Rewritability) An OMQ language (C,CQ), where C ⊆ TGD, is UCQ rewritable if, for each OMQ Q = (S,Σ, q(x̄)) ∈ (C,CQ) we can construct a UCQ q′(x̄) such that Q(D) = q′(D) for every S-database D.\nWe proceed to establish our desired small witness property, based on UCQ rewritability. By the definition of UCQ rewritability, for each language O that is UCQ rewritable, there exists a computable function fO from O to the natural numbers such that the following holds: for every OMQ Q = (S,Σ, q(x̄)) ∈ O, and UCQ rewriting q1(x̄)∨ · · · ∨ qn(x̄) of Q, it is the case that max1≤i≤n{|qi|} ≤ fO(Q), where |qi| denotes the number of atoms occurring in qi. Then:\nProposition 10. Consider a UCQ rewritable language O, and two OMQs Q ∈ O and Q′ ∈ (TGD,CQ), both with data schema S. If Q 6⊆ Q′, then there exists an S-database D, where |D| ≤ fO(Q), such that Q(D) 6⊆ Q ′(D).\nIn Proposition 10 we assume that the left-hand side query falls in a UCQ rewritable language, be we do not pose any restriction on the language of the right-hand side query. Thus, we immediately get a decision procedure for Cont(O1,O2) if O1 is UCQ rewritable and Eval(O2) is decidable. Given Q1 = (S,Σ1, q1(x̄)) ∈ O1 and Q2 = (S,Σ2, q2(x̄)) ∈ O2:\n1. Guess an S-database D such that |D| ≤ fO1(Q1), and\na tuple c̄ ∈ dom(D)|x̄|; and\n2. Verify that c̄ ∈ Q1(D) and c̄ 6∈ Q2(D).\nWe immediately get that:\nTheorem 11. Cont(O1,O2) is decidable if O1 is UCQ rewritable and Eval(O2) is decidable.\nThis general result shows that Cont((C,CQ)) is decidable for every C ∈ {L,NR, S}, but it says nothing about its complexity. This will be the subject of the rest of the section."
    }, {
      "heading" : "4.1 Linearity",
      "text" : "The problem of computing UCQ rewritings for OMQs in (L,CQ) has been studied in [33], where a resolution-based procedure, called XRewrite, has been proposed. This rewriting algorithm accepts a query Q = (S,Σ, q(x̄)) ∈ (L,CQ) and constructs a UCQ rewriting q′(x̄) over S by starting from q and exhaustively applying rewriting steps based on resolution. Let us illustrate this via a simple example:\nExample 1. Assume that S = {P, T}. Consider the set Σ consisting of the linear tgds\nP (x) → ∃y R(x, y), R(x, y) → P (y), T (x) → P (x),\nand the CQ q(x̄) := ∃y(R(x, y) ∧ P (y)). XRewrite will first resolve the atom P (y) in q using the second tgd, and produce the CQ ∃y(R(x, y)∧R(x, z)), which is equivalent to the CQ ∃y R(x, y). Then, ∃y R(x, y) will be resolved using the first tgd, and the CQ P (x) will be obtained, which in turn will be resolved using the third tgd in order to produce the CQ T (x). The UCQ rewriting q′(x̄) is P (x) ∨ T (x).\nIt is easy to see that, whenever the input OMQ consists of linear tgds, during the execution of XRewrite it is not possible to obtain a CQ that has more atoms than the original one. This is an immediate consequence of the fact that linear tgds have only one atom in their body. Then:\nProposition 12. f(L,CQ) ( (S,Σ, q) ) ≤ |q|.\nHaving the above result in place, it can be shown that the algorithm underlying Theorem 11 guesses a polynomially sized witness to non-containment, and then calls a C-oracle for solving query evaluation under linear OMQs, where C is PSpace in general, and NP if the arity is fixed; these complexity classes are obtained from Proposition 2. Therefore, coCont((L,CQ)) is in PSpace in general, and in ΣP2 in case of fixed arity. Regarding the lower bounds, Proposition 5 allows us to inherit the PSpace-hardness of Eval(L,CQ); this holds even for constant-free tgds. Unfortunately, in the case of fixed arity, we can only obtain NP-hardness, while Proposition 6 allows to obtain coNP-hardness. Nevertheless, it is implicit in [16] (see the proof of Theorem 9), where the containment problem for OMQ languages based on description logics is considered, that Cont((L,CQ)) is ΠP2 -hard, even for tgds of the form P (x) → R(x). Then:\nTheorem 13. Cont((L,CQ)) is PSpace-complete, and ΠP2 -complete if the arity of the schema is fixed. The lower bounds hold even for tgds without constants."
    }, {
      "heading" : "4.2 Non-Recursiveness",
      "text" : "Although the OMQ language (NR,CQ) is not explicitly considered in [33], where the algorithm XRewrite is defined, the same algorithm can deal with (NR,CQ). By analyzing the UCQ rewritings constructed by XRewrite, whenever the input query falls in (NR,CQ), we can establish the following result; here, body(τ ) denotes the body of the tgd τ :\nProposition 14. It holds that\nf(NR,CQ) ( (S,Σ, q) ) ≤ |q| ·\n(\nmax τ∈Σ {|body(τ )|}\n)|sch(Σ)|\n.\nProposition 14 implies that non-containment for queries that fall in (NR,CQ) is witnessed via a database of at most exponential size. We show next that this bound is optimal:\nProposition 15. There are sets of (NR,CQ) OMQs\n{Qn1 = (S,Σ n 1 , q1)}n>0 and {Q n 2 = (S,Σ n 2 , q2)}n>0,\nwhere |sch(Σn1 )| = |sch(Σ n 2 )| = n + 2, such that for every S-database D, if Qn1 (D) 6⊆ Q n 2 (D) then |D| ≥ 2 n−1.\nLet us now focus on the complexity of Cont((NR,CQ)). The algorithm underlying Theorem 11, together with the exponential bound provided by Proposition 14, implies that coCont((NR,CQ)) is feasible in non-deterministic exponential time with access to a NExpTime oracle, which immediately implies that Cont((NR,CQ)) is in ExpSpace. Unfortunately, the exact complexity of Cont((NR,CQ)) is still an open problem, and we conjecture that is PNEXP-complete; recall that NExpTime ⊆ PNEXP ⊆ ExpSpace. In what follows, we briefly explain how the PNEXP-hardness is obtained. To this end, we exploit a tiling problem that has been recently introduced in [30]. Roughly speaking, an instance of\nthis tiling problem is a triple (m,T1, T2), where m is an integer in unary representation, and T1, T2 are standard tiling problems for the exponential grid 2n × 2n. The question is whether, for every initial condition w of length m, T1 has no solution with w or T2 has some solution with w. The initial condition w simply fixes the first m tiles of the first row of the grid. We construct in polynomial time two (NR,CQ) queries Q1 and Q2 such that (m,T1, T2) has a solution iff Q1 ⊆ Q2. The idea is to force every input database to store an initial condition w of length m, and then encode the problem whether Ti has a solution with w into Qi, for each i ∈ {1, 2}. From the above discussion we get that:\nTheorem 16. Cont((NR,CQ)) is in ExpSpace, and PNEXP-hard. The lower bound holds even if the arity of the schema is fixed and the tgds are without constants."
    }, {
      "heading" : "4.3 Stickiness",
      "text" : "We now focus on (S,CQ). As shown in [33], given a query (S,Σ, q), there exists an execution of XRewrite that constructs a UCQ rewriting q1(x̄)∨ · · · ∨ qn(x̄) over S with the following property: for each i ∈ {1, . . . , n}, if a variable v occurs in qi in more than one atom, then v already occurs in q. This property has been used in [33] to bound the number of atoms that can appear in a single CQ qi. We write T (q) for the set of terms (constants and variables) occurring in q, C(Σ) for the set of constants occurring in Σ, and ar(S) for the maximum arity over all predicates of S.\nProposition 17. It holds that\nf(S,CQ)((S,Σ, q)) ≤ |S| · (|T (q)|+ |C(Σ)|+ 1) |ar(S)| .\nProposition 17 implies that non-containment for (S,CQ) queries is witnessed via a database of at most exponential size. As for (NR,CQ) queries, we can show that this bound is optimal; here, for a set Σ of tgds, we denote by ||Σ|| the number of symbols occurring in Σ:\nProposition 18. There exists a set of (S,CQ) OMQs\n{Qn = ({S/n},Σn, q(x̄))}n>0, where ||Σ n|| ∈ O(n2),\nsuch that for every Q = ({S},Σ′, q′(x̄)) ∈ (TGD,CQ) and {S}-database D, if Qn(D) 6⊆ Q(D) then |D| ≥ 2n−2.\nWe now study the complexity of Cont((S,CQ)). We first focus on schemas of unbounded arity. Proposition 17 implies that the algorithm underlying Theorem 11 runs in exponential time assuming access to a C-oracle, where C is a complexity class powerful enough for solving Eval(S,CQ) and its complement. But, since Eval(S,CQ) is in ExpTime (see Proposition 4), both Eval(S,CQ) and its complement are in NExpTime, and thus, the oracle call is not really needed. Consequently, coCont((C,CQ)) is in NExpTime.\nA matching lower bound is obtained by a reduction from the standard tiling problem for the exponential grid 2n×2n. In fact, the same lower bound has been recently established in [14]; however, our result is stronger as it shows that the problem remains hard even if the right-hand side query is a linear OMQ of a simple form – this is also discussed in Section 6, where containment of queries that fall in different OMQ languages is studied. Regarding schemas of fixed arity, Proposition 17 provides a witness for non-containment of polynomial size, which implies that the algorithm underlying\nTheorem 11 runs in polynomial time with access to an NPoracle. Therefore, coEval(S,CQ) is in ΣP2 , while a matching lower bound is implicit in [16]. Then:\nTheorem 19. Cont((S,CQ)) is coNExpTime-complete, even if the set of tgds uses only two constants. In the case of fixed arity, it is ΠP2 -complete, even for constant-free tgds."
    }, {
      "heading" : "5. GUARDEDNESS",
      "text" : "We proceed with the problem of containment for guarded OMQs, and we establish the following result:\nTheorem 20. Cont((G,CQ)) is 2ExpTime-complete. The lower bound holds even if the arity of the schema is fixed, and the tgds are without constants.\nThe lower bound is immediately inherited from [15], where it is shown that containment for OMQs based on the description logic ELI is 2ExpTime-hard. Recall that a set of ELI axioms can be equivalently rewritten as a constant-free set of guarded tgds using only unary and binary predicates, which implies the lower bound stated in Theorem 20. However, we cannot immediately inherit the desired upper bound since the DL-based OMQ languages considered in [15] are either weaker than or incomparable to (G,CQ). Nevertheless, the technique developed in [15] was extremely useful for our analysis. Actually, our automata-based procedure exploits a combination of ideas from [15, 37]. The rest of this section is devoted to providing a high-level explanation of this procedure.\nFor the sake of technical clarity, we focus on constant-free tgds and CQs, but all the results can be extended to the general case at the price of more involved definitions and proofs. Moreover, for simplicity, we focus on Boolean CQs. In other words, we study the problem for (G,BCQ), where BCQ denotes the class of Boolean CQs. This does not affect the generality of our proof since it is known that Cont((G,CQ)) can be reduced in polynomial time to Cont((G,BCQ)) [15].\nA first glimpse. As already said, (G,CQ) is not UCQ rewritable and, therefore, we cannot employ Proposition 10 in order to establish a small witness property as for the languages considered in Section 4. We have tried to establish a small witness property for (G,CQ) by following a different route, but it turned out to be a difficult task. Nevertheless, we can show a tree witness property, which states that non-containment for (G,CQ) is witnessed via a treelike database. This allows us to devise a procedure based on alternating tree automata. Summing up, the proof for the 2ExpTime membership of (G,CQ) proceeds in three steps:\n1. Establish a tree witness property;\n2. Encode the tree-like witnesses as trees that can be accepted by an alternating tree automaton; and\n3. Construct an automaton that decides Cont((G,CQ)); in fact, we reduce Cont((G,CQ)) into emptiness for two-way alternating parity automata on finite trees.\nEach one of the above three steps is discussed in more details in the following three sections."
    }, {
      "heading" : "5.1 Tree Witness Property",
      "text" : "From the above informal discussion, it is clear that treelike databases are crucial for our analysis. Let us make this notion more precise using guarded tree decompositions. A tree decomposition of a database D is a labeled rooted tree T = (V,E, λ), where λ : V → 2dom(D), such that: (i) for each atom R(t1, . . . , tn) ∈ D, there exists v ∈ V such that λ(v) ⊇ {t1, . . . , tn}, and (ii) for every term t ∈ dom(D), the set {v ∈ V | t ∈ λ(v)} induces a connected subtree of T . The tree decomposition T is called [U ]-guarded, where U ⊆ V , if, for every node v ∈ V \\ U , there exists an atom R(t1, . . . , tn) ∈ D such that λ(v) ⊆ {t1, . . . , tn}. We write root(T ) for the root node of T , and DT (v), where v ∈ V , for the subset of D induced by λ(v). We are now ready to formalize the notion of the tree-like database:\nDefinition 2. An S-database D is a C-tree, where C ⊆ D, if there is a tree decomposition T of D such that:\n1. DT (root(T )) = C and\n2. T is [{root(T )}]-guarded.\nRoughly, whenever a database D is a C-tree, C is the cyclic part ofD, while the rest ofD is tree-like. Interestingly, for deciding Cont((G,BCQ)) it suffices to focus on databases that are C-trees and |dom(C)| depends only on the left-hand side OMQ. Recall that for a schema S we write ar(S) for the maximum arity over all predicates of S. Then:\nProposition 21. Let Qi = (S,Σi, qi) ∈ (G,BCQ), for i ∈ {1, 2}. The following are equivalent:\n1. Q1 ⊆ Q2.\n2. Q1(D) ⊆ Q2(D), for every C-tree S-database D such that |dom(C)| ≤ (ar(S ∪ sch(Σ1)) · |q1|).\nThe fact that (1) ⇒ (2) holds trivially, while (2) ⇒ (1) is shown by using a variant of the notion of guarded unravelling and compactness. Let us clarify that the above result does not provide a decision procedure for Cont((G,BCQ)), since we have to consider infinitely many databases that are Ctrees with |dom(C)| ≤ (ar(S ∪ sch(Σ1)) · |q1|)."
    }, {
      "heading" : "5.2 Encoding Tree-like Databases",
      "text" : "It is generally known that a database D whose treewidth3 is bounded by an integer k can be encoded into a tree over a finite alphabet of double-exponential size in k that can be accepted by an alternating tree automaton; see, e.g., [12]. Consider an alphabet Γ, and let N∗ be the set of finite sequences of natural numbers, including the empty sequence. A Γ-labeled tree is a pair L = (T, λ), where T ⊆ N∗ is closed under prefixes, and λ : T → Γ is the labeling function. The elements of T identify the nodes of L. It can be shown that D and a tree decomposition T of D with width k can be encoded as a Γ-labeled tree L, where Γ is an alphabet of double-exponential size in k, such that each node of T corresponds to exactly one node of L and vice versa.\nConsider now a C-tree S-database D, and let T be the tree decomposition that witnesses that D is a C-tree. The width of T is at most k = (|dom(C)| + ar(S) − 1), and thus, the\n3Recall that the treewidth of a database D is the minimum width among all possible tree decompositions T = (V,E, λ) of D, while the width of T is defined as maxv∈V {|λ(v)|}−1.\ntreewidth of D is bounded by k. Hence, from the above discussion, D and T can be encoded as a Γ-labeled tree, where Γ is of double-exponential size in k. In general, given an Sdatabase D that is a C-tree due to the tree decomposition T , we show that D and T can be encoded as a ΓS,l-labeled tree, with |dom(C)| ≤ l and |ΓS,l| being double-exponential in ar(S) and exponential in |S| and l.\nAlthough every C-tree S-database D can be encoded as a ΓS,l-labeled tree, the other direction does not hold. In other words, it is not true that every ΓS,l-labeled tree encodes a C-tree S-database D and its corresponding tree decomposition. In view of this fact, we need the additional notion of consistency. A ΓS,l-labeled tree is called consistent if it satisfies certain syntactic properties – we do not give these properties here since they are not vital in order to understand the high-level idea of the proof. Now, given a consistent ΓS,l-labeled tree L, we can show that L can be decoded into an S-database JLK that is a C-tree with |dom(C)| ≤ l. From the above discussion and Proposition 21, we obtain the following technical lemma:\nLemma 22. Let Qi = (S,Σi, qi) ∈ (G,BCQ), for i ∈ {1, 2}. The following are equivalent:\n1. Q1 ⊆ Q2.\n2. Q1(JLK) ⊆ Q2(JLK), for every consistent ΓS,l-labeled tree L, where l = (ar(S ∪ sch(Σ1)) · |q1|)."
    }, {
      "heading" : "5.3 Constructing Tree Automata",
      "text" : "Having the above result in place, we can now proceed with our automata-based procedure. We make use of twoway alternating parity automata (2WAPA) that run on finite labeled trees. Two-way alternating automata process the input tree while branching in an alternating fashion to successor states, and thereby moving either down or up the input tree; the detailed definition can be found in [10]. Our goal is to reduce Cont((G,BCQ)) to the emptiness problem for 2WAPA. As usual, given a 2WAPA A, we denote by L(A) the language of A, i.e., the set of labeled trees it accepts. The emptiness problem is defined as follows: given a 2WAPA A, does L(A) = ∅? Thus, given Q1, Q2 ∈ (G,BCQ), we need to construct a 2WAPA A such that Q1 ⊆ Q2 iff L(A) = ∅. It is well-known that deciding whether L(A) = ∅ is feasible in exponential time in the number of states, and in polynomial time in the size of the input alphabet [28]. Therefore, in order to obtain the desired 2ExpTime upper bound, we should construct A in double-exponential time, while the number of states must be at most exponential.\nWe first need a way to check consistency of labeled trees. It is not difficult to devise an automaton for this task.\nLemma 23. Consider a schema S and an integer l > 0. There is a 2WAPA CS,l that accepts a ΓS,l-labeled tree L iff L is consistent. The number of states of CS,l is logarithmic in the size of ΓS,l. Furthermore, CS,l can be constructed in polynomial time in the size of ΓS,l.\nNow, the crucial task is, given an OMQ Q ∈ (G,BCQ), to devise an automaton that accepts labeled trees which correspond to databases that make Q true. We write ||Q|| for the number of symbols that appear in Q.\nLemma 24. Let Q = (S,Σ, q) ∈ (G,BCQ). There is a 2WAPA AQ,l, where l > 0, that accepts a consistent ΓS,llabeled tree L iff Q(JLK) 6= ∅. The number of states of\nAQ,l is exponential in ||Q|| and l. Furthermore, AQ,l can be constructed in double-exponential time in ||Q|| and l.\nThe intuition underlying AQ,l can be described as follows. AQ,l tries to identify all the possible ways the CQ q can be mapped to chase(D,Σ), for any C-tree S-database D such that |dom(C)| ≤ l. It then arrives at possible ways how the input tree can satisfy Q. These “possible ways” correspond to squid decompositions, a notion introduced in [22] that indicates which part of the query is mapped to the cyclic part C ofD, and which to the tree-like part of D. The automaton exhaustively checks all squid decompositions by traversing the input tree and, at the same time, explores possible ways how to match the single parts of the squid decomposition at hand. The automaton finally accepts if it finds a squid decomposition that can be mapped to chase(D,Σ).\nHaving the above automata in place, we can proceed with our main technical result, which shows that Cont(G,BCQ) can be reduced to the emptiness problem for 2WAPA. But let us first recall some key results about 2WAPA, which are essential for our final construction. It is well-known that languages accepted by 2WAPAs are closed under intersection and complement. Given two 2WAPAs A1 and A2, we write A1 ∩ A2 for a 2WAPA, which can be constructed in polynomial time, that accepts the language L(A1) ∩ L(A2). Moreover, for a 2WAPA A, we write A for the 2WAPA, which is also constructible in polynomial time, that accepts the complement of L(A). We can now show the following:\nProposition 25. Consider Q1, Q2 ∈ (G,BCQ). We can construct in double-exponential time a 2WAPA A, which has exponentially many states, such that\nQ1 ⊆ Q2 ⇐⇒ L(A) = ∅.\nProof (sketch). Let Qi = (S,Σi, qi), for i ∈ {1, 2}, and l = (ar(S ∪ sch(Σ1)) · |q1|). Then A is defined as:\n(CS,l ∩ AQ1,l) ∩ AQ2,l.\nSince ΓS,l has double-exponential size, Lemmas 23 and 24 imply that A can be constructed in double-exponential time, while it has exponentially many states. Lemma 22 implies that Q1 ⊆ Q2 iff L(A) = ∅, and the claim follows.\nProposition 25 implies that Cont((G,BCQ)) is in 2ExpTime, and Theorem 20 follows."
    }, {
      "heading" : "6. COMBINING LANGUAGES",
      "text" : "In the previous two sections, we studied the containment problem relative to a language O, i.e., both OMQs fall in O. However, it is natural to consider the version of the problem where the involved OMQs fall in different languages. This is the goal of this section. Our analysis proceeds by considering the two cases where the left-hand side (LHS) query falls in a UCQ rewritable OMQ language, or it is guarded."
    }, {
      "heading" : "6.1 The LHS Query is UCQ Rewritable",
      "text" : "As an immediate corollary of Theorem 11 we obtain the following result: Cont((C1,CQ), (C2,CQ)), for C1 6= C2, C1 ∈ {L,NR, S} and C2 ∈ {L,NR, S,G}, is decidable. By exploiting the algorithm underlying Theorem 11, we establish optimal upper bounds for all the problems at hand with the only exception of Cont((S,CQ), (NR,CQ)). For the latter, we obtain an ExpSpace upper bound, by providing\na similar analysis as for Cont((NR,CQ)), while a NExpTime lower bound is inherited from query evaluation by exploiting Proposition 5. It is rather tedious, and not very interesting from a technical point of view, to go through all the containment problems in question4 and explain in details how the exact upper bounds are obtained; a summarization of those complexity results can be found in [10].\nRegarding the matching lower bounds, in most of the cases they are inherited from query evaluation or its complement by exploiting Propositions 5 and 6, respectively. There are, however, some exceptions:\n• Cont((S,CQ), (L,CQ)) in the case of unbounded arity, where the problem is coNExpTime-hard, even for sets of tgds that use only two constants. This is shown by a reduction from the standard tiling problem for the exponential grid 2n × 2n.\n• Cont((L,CQ), (S,CQ)) and Cont((S,CQ), (L,CQ)) in the case of bounded arity, where both problems are ΠP2 -hard even for constant-free tgds; implicit in [16]."
    }, {
      "heading" : "6.2 The LHS Query is Guarded",
      "text" : "We proceed with the case where the LHS query is guarded, and we show the following result:\nTheorem 26. Cont((G,CQ), (C,CQ)) is C-complete:\nC =\n \n\n2ExpTime, C ∈ {L, S},\n3ExpTime, C = NR.\nThe lower bounds hold even if the arity of the schema is fixed. Moreover, for C = L (resp., C ∈ {NR, S}) it holds even for tgds with one constant (resp., without constants).\nUpper bounds. The 2ExpTime membership when C = L is an immediate corollary of Theorem 20. This is not true when C ∈ {NR, S} since the right-hand side query is not guarded. But in this case, since (NR,CQ) and (S,CQ) are UCQ rewritable, one can rewrite the right-hand side query as a UCQ, and then apply the machinery developed in Section 5 for solving Cont((G,CQ)). More precisely, given OMQs Q1 ∈ (G,CQ) and Q2 ∈ (C,CQ), where C ∈ {NR, S}, Q1 ⊆ Q2 iff Q1 ⊆ q, where q is a UCQ rewriting of Q2. Thus, an immediate decision procedure, which exploits the algorithm XRewrite, is the following:\n1. Let q = XRewrite(Q2);\n2. For each q′ ∈ q: if Q1 ⊆ q ′, then proceed; otherwise,\nreject; and\n3. Accept.\nThe above procedure runs in triple-exponential time. The first step is feasible in double-exponential time [33]. Now, for a single CQ q′ ∈ q (which is a guarded OMQ with an empty set of tgds) the check whether Q1 ⊆ q\n′ can be done by using the machinery developed in Section 5, which reduces our problem to checking whether the language of a 2WAPA A is empty. However, it should not be forgotten\n4There are eighteen different cases obtained by considering all the possible pairs (O1,O2) of OMQ languages, where O1 6= O2 and O1 is UCQ rewritable, and the two cases whether the arity of the schema is fixed or not.\nthat q′ is of exponential size, and thus, the automaton A has double-exponentially many states. This in turn implies that checking whether L(A) = ∅ is in 3ExpTime, as claimed.\nAlthough the above algorithm establishes an optimal upper bound for non-recursive OMQs, a more refined analysis is needed for sticky OMQs. In fact, we need a more refined complexity analysis for the problem Cont((G,CQ),UCQ), that is, to decide whether a guarded OMQ is contained in a UCQ. To this end, we provide an automata construction different from the one employed in Section 5, which allows us to establish a refined complexity upper bound for the problem in question. Consider a (G,CQ) query Q, and a UCQ q = q1 ∨ · · · ∨ qn. As usual, we write ||Q|| and ||qi|| for the number of symbols that occur in Q and qi, respectively, and we write var≥2(qi) for the set of variables that appear in more than one atom of qi. By exploiting our new automata-based procedure, we show that the problem of checking if Q ⊆ q is feasible in double-exponential time in (||Q|| + max1≤i≤n{|var≥2(qi)|}), exponential time in max1≤i≤n{||qi||}, and polynomial time in n.\nThis result allows us to show that the above procedure establishes 2ExpTime-membership when the right-hand side OMQ is sticky. But first we need to recall the following key properties of the UCQ rewriting q = XRewrite(Q2), constructed during the first step of the algorithm:\n1. q consists of double-exponentially many CQs,\n2. each CQ of q is of exponential size, and\n3. for each q′ ∈ q, var≥2(q ′) is a subset of the variables\nof the original CQ that appears in Q2.\nBy combining these key properties with the complexity analysis performed above, it is now straightforward to show that Cont((G,CQ), (S,CQ)) is in 2ExpTime.\nLower Bounds. We establish matching lower bounds by refining techniques from [27], where it is shown that containment of Datalog in UCQ is 2ExpTime-complete, while containment of Datalog in non-recursive Datalog is 3ExpTimecomplete; the lower bounds hold for fixed-arity predicates, and constant-free rules. Interestingly, the LHS query can be transformed into a Datalog query such that each rule has a body-atom that contains all the variables, i.e., is guarded. This is achieved by increasing the arity of some predicates in order to have enough positions for all the bodyvariables. However, for each rule, the number of unguarded variables that we need to guard is constant, and thus, the arity of the schema remains constant. We conclude that Cont((G,CQ), (NR,CQ)) is 3ExpTime-hard. Moreover, containment of guarded OMQs in UCQs is 2ExpTime-hard, which in turn allows us to show, by exploiting the construction underlying Proposition 9, that Cont((G,CQ), (L,CQ)) is 2ExpTime-hard, even if the set of linear tgds uses only one constant, while Cont((G,CQ), (S,CQ)) is 2ExpTime-hard, even for tgds without constants."
    }, {
      "heading" : "7. APPLICATIONS",
      "text" : "Interestingly, our results on Cont((G,CQ)) can be applied to other important static analysis tasks, in particular, distribution over components and UCQ rewritability. Each one of those tasks is considered in the following two sections."
    }, {
      "heading" : "7.1 Distribution Over Components",
      "text" : "The notion of distribution over components has been introduced in [2], and it states that the answer to a query can be computed by parallelizing it over the (maximally connected) components of the input database. But let us first make precise what a component is. A set of atoms A is connected if for all c, d ∈ dom(A), there exists a sequence α1, . . . , αn of atoms in A such that c ∈ dom(α1), d ∈ dom(αn), and dom(αi) ∩ dom(αi+1) 6= ∅, for each i ∈ {1, . . . , n − 1}. We call B ⊆ A a component of A if (i) B is connected, and (ii) for every α ∈ A \\ B, B ∪ {α} is not connected.5 Let co(A) be the set of components of A. We are now ready to introduce the notion of distribution over components. Consider an OMQ Q = (S,Σ, q) ∈ (TGD,CQ). We say that Q distributes over components if Q(D) = Q(D1)∪· · ·∪Q(Dn), where co(D) = {D1, . . . , Dn}, for every S-database D. In this case, Q(D) can be computed without any communication over a network using a distribution where every computing node is assigned some of the components of the database, and every component is assigned to at least one computing node. In other words, Q can be evaluated in a distributed and coordination-free manner; for more details on coordination-free evaluation see [2, 3, 4]. Therefore, it would be quite beneficial if we can decide whether an OMQ distributes over components, and thus, we obtain the following interesting static analysis task:\nPROBLEM : Dist(C,CQ) INPUT : An OMQ Q ∈ (C,CQ). QUESTION : Does Q distributes over components?\nThe above problem has been studied in [14], where tight complexity bounds for (L,CQ) and (S,CQ) have been established. However, its exact complexity for guarded OMQs has been left open. Our results on containment for guarded OMQs allow us to close this problem. But first we need to recall a key result that semantically characterizes distribution over components. An OMQ Q with data schema S is unsatisfiable if there is no S-database D such that Q(D) 6= ∅. Moreover, for a CQ q, we write co(q) for its components. The next result has been shown in [14]:\nProposition 27. Let Q = (S,Σ, q(x̄)) ∈ (G,CQ). The following are equivalent:\n1. Q distributes over components.\n2. Q is unsatisfiable or there exists q̂(x̄) ∈ co(q) such that (S,Σ, q̂(x̄)) ⊆ Q.\nChecking unsatisfiability can be easily reduced to containment. Thus, the above result, together with Theorem 20, implies that Dist(G,CQ) is in 2ExpTime, while a matching lower bound is implicit in [14]. Then:\nTheorem 28. Dist(G,CQ) is 2ExpTime-complete."
    }, {
      "heading" : "7.2 Deciding UCQ Rewritability",
      "text" : "Query rewriting is a well-studied method for evaluating OMQs using standard database technology. The key idea is the following: given an OMQ Q = (S,Σ, q(x̄)), combine Σ\n5For technical clarity, the notion of component is defined only for sets of atoms that do not contain 0-ary atoms.\nand q into a new query qΣ(x̄), the so-called rewriting, which can then be evaluated over D yielding the same answer as Q over D, for every S-database D. For this approach to be realistic, though, it is essential that the rewriting is expressed in a language that can be handled by standard database systems. The typical language that is considered in this setting is first-order (FO) queries [25]. Notice, however, that due to Rossman’s Theorem [43], and the fact that OMQs are closed under homomorphisms, FO and UCQ rewritability coincide. Recall that some OMQ languages are UCQ rewritable, such as the ones based on linear, non-recursive and sticky sets of tgds, while others are not, e.g., guarded OMQs. For those languages O that are not UCQ rewritable, it is important to be able to check whether a query Q ∈ O can be rewritten as a UCQ, in which case we say that it is UCQ rewritable. This gives rise to the following fundamental static analysis task for an OMQ language (C,CQ), where C ⊆ TGD:\nPROBLEM : UCQRew(C,CQ) INPUT : An OMQ Q ∈ (C,CQ). QUESTION : Is it the case that Q is UCQ rewritable?\nBienvenu et al. have recently carried out an in-depth study of the above problem for OMQ languages based on central Horn-DLs [15]. One of their main results is that the above problem for the OMQ language based on ELHI, one of the most expressive members of the EL-family of DLs, is 2ExpTime-complete. Interestingly, by adapting the tree automata techniques developed in Section 5, we can generalize the above result: deciding UCQ rewritability for the OMQ language based on guarded tgds over unary and binary relations is in 2ExpTime. Let G2 be the class of (finite) sets of guarded tgds over unary and binary relations. Then:\nTheorem 29. UCQRew(G2,CQ) is 2ExpTime-complete.\nSince the lower bound is inherited from [15], we concentrate on the upper bound. As in Section 5, we can focus on BCQs, i.e., it suffices to show that UCQRew(G2,BCQ) is in 2ExpTime. Our proof proceeds in two steps:\n1. We semantically characterize UCQ rewritability for queries in (G2,CQ) in terms of a certain boundedness property for the set of C-trees defined in Section 5.\n2. We extend the techniques developed in Section 5 and construct in double-exponential time a 2WAPA A that has exponentially many states, such that the aforementioned boundedness property does not hold iff L(A) is infinite. (Such an infinity problem for tree automata has been used to obtain the decidability of the boundedness problem for monadic Datalog [28, 46]).\nOur 2ExpTime upper bound then follows since the infinity problem for a 2WAPA A, i.e., checking if L(A) is infinite, is feasible in exponential time in the number of states, and in polynomial time in the size of the alphabet. This follows from two known results: (a) The 2WAPA A can be converted into an equivalent non-deterministic tree automata B with a single-exponential blow up in the number of states [47], and (b) solving the infinity problem for non-deterministic tree automata is feasible in polynomial time; cf. [46].\nIt is worth contrasting our proof with the one in [15] for ELHI, which does not make use of the infinity problem for\n2WAPA, but applies a different argument based on pumping. This leads to a finer complexity analysis in terms of the size of the different components of the OMQ, but, in our opinion, makes the proof conceptually harder.\nThe semantic characterization. To establish the semantic characterization from step 1, we need to define the notion of distance from the root for an element u in a C-tree database D. Intuitively, this corresponds to the minimal distance between a node that contains u and the root of a tree decomposition T of D that witnesses the fact that D is a C-tree. We do not consider all such tree decompositions, however, but concentrate on a well-behaved subclass, which we call the lean tree decompositions of the C-tree D; the formal definition can be found in [10], as it does not add much to the explanation we provide here. Due to the fact that we focus on unary and binary relations, such lean tree decompositions ensure the invariance of the notion of distance from the root, by severely limiting the level of redundancy allowed in a tree representation of D. Therefore, it does not matter which lean tree decomposition we choose, since in all of them the distance of an element u from the root will be the same. Let D≤k be the subinstance of D induced by the set of elements whose distance from the root is at most k, and let D>k be the subinstance of D induced by the set of elements whose distance from the root is at least k + 1.\nAnother useful notion is the branching degree of a tree decomposition T , that is, the maximum number of child nodes over all nodes of T . Again, lean tree decompositions ensure the invariance of the branching degree. This allows us to define the branching degree of a C-tree database D as the branching degree of a lean tree decomposition that witnesses the fact that D is a C-tree.\nIt follows from [15] that being able to decide containment for the OMQ language (G2,BCQ) (as we have done in Section 5) allows us to concentrate on connected CQs when deciding UCQ rewritability. This simplifies technicalities considerably and, in turn, allows us to obtain our desired semantic characterization of UCQ rewritability:\nProposition 30. Let Q = (S,Σ, q) ∈ (G2,BCQ), where q is connected. The following are equivalent:\n1. Q is UCQ rewritable.\n2. There exist k,m ≥ 0 (which depend only on Q) s.t.\nQ(D) 6= ∅ =⇒ ( Q(D≤k) 6= ∅ or Q(D>0) 6= ∅ ) ,\nfor each C-tree S-database D with |dom(C)| ≤ 2 · |q| and branching degree at most m.\nThe reduction to the infinity problem. We now proceed with step 2, and we explain how the boundedness property established in item (2) of Proposition 30 can be reduced to the infinity problem for 2WAPAs. As in Section 5, we do not reason with C-tree databases directly, but we deal with their encodings as consistent ΓS,l-labeled trees. In fact, using the same ideas as in Lemma 22, we can show by exploiting Proposition 30 that the following are equivalent:\n(i) Q is UCQ rewritable.\n(ii) There are k,m ≥ 0 such that\nQ(JLK) 6= ∅ =⇒ ( Q(JLK≤k) 6= ∅ or Q(JLK>0) 6= ∅ ) ,\nfor every consistent ΓS,l-labeled tree L with l = 2 · |q| and whose branching degree is bounded by m.\nLet us write Boundedness for the property expressed in item (ii) above, which can be reduced to the problem of checking whether some tree language is finite. Let LQ be the set of all ΓS,l-labeled trees L of branching degree at most m such that: (1) Q(JLK) = ∅ and (2) there is some “extension” L′ of L, with branching degree m, such that Q(JL′K) 6= ∅ and Q(JL′K>0) = ∅. Notice that L\n′ can increase the depth but not the branching degree of L. It is not difficult to show that Boundedness holds iff LQ is finite. We then devise in double-exponential time a 2WAPA CQ,l, which has exponentially many states, such that LQ = L(CQ,l). Therefore, the following holds:\nProposition 31. Consider Q ∈ (G2,BCQ). We can construct in double-exponential time a 2WAPA A, which has exponentially many states, such that\nQ is UCQ rewritable ⇐⇒ L(A) is finite.\nSince checking whether L(A) is infinite is feasible in exponential time in the number of states and in polynomial time in the size of the alphabet, Proposition 31 implies that UCQRew(G2,CQ) is in 2ExpTime, as needed."
    }, {
      "heading" : "8. CONCLUSIONS",
      "text" : "We have concentrated on the fundamental problem of containment for OMQ languages based on the main decidable classes of tgds. We have developed specially tailored techniques for OMQ containment that allowed us to obtain a relatively complete picture for the complexity of the problem at hand. Our main conclusion is that for the OMQ languages in question, i.e., those based on linear, sticky, non-recursive and guarded tgds, the containment problem is harder (under widely accepted complexity assumptions) than query evaluation, with the exception of linear OMQs over schemas of unbounded arity, where both problems are complete for PSpace. We have also used our techniques to close problems related to distribution over components and UCQ rewritability. In particular, it is shown that the problem of deciding whether a guarded OMQ distributes over components is 2ExpTime-complete, while the problem of deciding whether a guarded OMQ that mentions only unary and binary relations is UCQ rewritable is also 2ExpTimecomplete. We believe that our techniques for solving containment under guarded OMQs can be extended to frontierguarded OMQs, an interesting extension of guardedness [7]. We are also convinced that our solution to the problem of deciding UCQ rewritability of guarded OMQs over unary and binary relations can be extended to guarded (or even frontier-guarded) OMQs over arbitrary schemas. We are currently investigating these challenging problems."
    }, {
      "heading" : "APPENDIX",
      "text" : ""
    }, {
      "heading" : "PRELIMINARIES Definition of Non-recursiveness",
      "text" : "In the main body of the paper, we define non-recursive sets of tgds via the notion of predicate graph. Here, we give an alternative definition, based on the well-known notion of stratification, which is more convenient for the combinatorial analysis that we are going to perform in the proof of Proposition 14.\nDefinition 3. Consider a set Σ of tgds. A stratification of Σ is a partition {Σ1, . . . ,Σn}, where n > 0, of Σ such that, for some function µ : sch(Σ) → {0, . . . , n}, the following hold:\n1. For each predicate R ∈ sch(Σ), all the tgds with R in their head belong to Σµ(R), i.e., they belong to the same set of the partition.\n2. If there exists a tgd in Σ such that the predicate R appears in its body, while the predicate P appears in its head, then µ(R) < µ(P ).\nWe say that Σ is stratifiable if it admits a stratification.\nIt is an easy exercise to show that the predicate graph of a set Σ of tgds is acyclic iff Σ is stratifiable. Then:\nLemma 32. Σ is non-recursive iff Σ is stratifiable."
    }, {
      "heading" : "Definition of Stickiness",
      "text" : "In the main body of the paper, we provide an intuitive explanation of stickiness. Here, we recall the formal definition of sticky sets of tgds, introduced in [24]. Fix a set Σ of tgds; w.l.o.g., we assume that, for every pair (σ, σ′) ∈ Σ× Σ, σ and σ′ do not share variables. For notational convenience, given an atom α and a variable x occurring in α, pos(α, x) is the set of positions in α at which x occurs; a position P [i] identifies the i-th attribute of the predicate P . The definition of stickiness hinges on the notion of marked variables in a set of tgds.\nDefinition 4. Consider a tgd σ ∈ Σ, and a variable x occurring in the body of σ. We inductively define when x is marked in Σ as follows:\n1. If there exists an atom α in the head of σ such that x does not occur in α, then x is marked in Σ; and\n2. Assuming that there exists an atom α in the head of σ such that x occurs in α, if there exists σ′ ∈ Σ (not necessarily different than σ) and an atom β in the body of σ′ such that (i) α and β have the same predicate and, (ii) each variable in β that occurs at a position of pos(α, x) is marked in Σ, then x is marked in Σ.\nWe are now ready to recall when a set of tgds is sticky:\nDefinition 5. A set Σ of tgds is sticky if, for each σ ∈ Σ, and for each variable x occurring in the body of σ, the following holds: if x is marked in Σ, then x occurs only once in the body of σ."
    }, {
      "heading" : "PROOFS OF SECTION 3 Proof of Proposition 5",
      "text" : "Consider an OMQ Q = (S,Σ, q(x̄)) ∈ (C,CQ), where C is a class of tgds, an S-database D, and a tuple c̄ ∈ dom(D)|x̄|. We show that:\nc̄ ∈ Q(D) ⇐⇒ (sch(Σ),∅, qD,c̄) ︸ ︷︷ ︸\nQ1\n⊆ (sch(Σ),Σ, q) ︸ ︷︷ ︸\nQ2\n.\n(⇒) Assume that Q1 6⊆ Q2. This implies that there exists a sch(Σ)-database D ′, and a tuple t̄ of constants such that\nt̄ ∈ qD,c̄(D ′) and t̄ 6∈ q(chase(D′,Σ)). Due to the monotonicity of CQs, t̄ ∈ qD,c̄(chase(D ′,Σ)). Since, by construction, the instance chase(D′,Σ) satisfies Σ, we conclude that qD,c̄ 6⊆Σ q.\n6 By exploiting the well-known characterization of CQ containment in terms of the chase, we get that c̄ 6∈ q(chase(D,Σ)), which is equivalent to c̄ 6∈ Q(D), as needed.\n(⇐) Conversely, assume that c̄ 6∈ Q(D), or, equivalently, c̄ 6∈ q(chase(D,Σ)). This implies that c̄ 6∈ Q2(D). Observe that c̄ ∈ qD,c̄(D) holds trivially, which in turn implies that c̄ ∈ Q1(D). Therefore, Q1 6⊆ Q2, and the claim follows.\n6This is the standard notation for the fact that qD,c̄(I) 6⊆ q(I), for every (possibly infinite) instance I that satisfies Σ."
    }, {
      "heading" : "Proof of Proposition 9",
      "text" : "The construction underlying Proposition 9 relies on the idea of encoding boolean operations (in our case the ‘or’ operator) using a set of atoms; this idea has been exploited in several other works; see, e.g., [13, 20, 34]. Let Q = (S,Σ, q) ∈ (C,UCQ). Our goal is to construct in polynomial time Q′ = (S,Σ′, q′) ∈ (C,CQ) such that Q ≡ Q′. We assume, w.l.o.g., that the predicates of S do not appear in the head of a tgd of Σ; we can copy the content of a relation R/k ∈ S into an auxiliary predicate R⋆/k, using the tgd R(x1, . . . , xk) → R\n⋆(x1, . . . , xk), while staying inside C, and then rename each predicate P in Σ and q with P ⋆. The set Σ′ consists of the following tgds:\n1. For every R/k ∈ S:\nR(x1, . . . , xk) → R ′(x1, . . . , xk, 1),True(1).\nThese tgds are annotating the database atoms with the truth constant true, indicating that these are true atoms.\n2. Assuming that q = ∃ȳ φ(x̄, ȳ), a tgd:\nTrue(t) → ∃x̄∃ȳ∃f φ′∧(x̄, ȳ, f), ψ(t, f),\nwhere φ′∧ is the conjunction of atoms in φ, after replacing each atom R(v1, . . . , vk) with R ′(v1, . . . , vk, f), and ψ is the conjunction of atoms\nOr(t, t, t),Or(t, f, t),Or(f, t, t),Or(f, f, f).\nThis tgd generates a “copy” of the atoms in q, while annotating them with a null value that represents the truth constant false, indicating that are not necessarily true atoms. Moreover, the truth table of ‘or’ is generated.\n3. Finally, for each tgd φ(x̄, ȳ) → ∃z̄ ψ(x̄, x̄) in Σ, a tgd\nφ′(x̄, ȳ, w) → ∃z̄ ψ′(x̄, z̄, w),\nwhere φ′ and ψ′ are obtained from φ and ψ, respectively, by replacing each atom R(v1, . . . , vk) with R ′(v1, . . . , vk, w). In fact, this is the actual set of tgds Σ, with the difference that the value at the last position of each atom (which indicates whether it is true or false) is propagated to the inferred atoms.\nNow, assuming that q = q1 ∨ · · · ∨ qn, the CQ q ′ is defined as follows; let x̄ = x1 . . . xn and ȳ = y1 . . . yn+1:\n∃x̄∃ȳ (False(y1) ∧ ∧\n1≤i≤n\n(q′i[xi] ∧Or(yi, xi, yi+1)) ∧ True(yn+1)),\nwhere x̄ and ȳ are fresh variables not in q, and q′i[xi] is obtained from qi by replacing each atom R(v1, . . . , vk) with R′(v1, . . . , vk, xi). This completes our construction.\nIt is not difficult to show that Q ≡ Q′, or, equivalently, for every S-database D, q(chase(D,Σ)) = q′(chase(D,Σ′)). The key observation is that in order to satisfy True(yn+1) in the CQ q\n′, at least one of the x̄i’s must be mapped to 1, which means that at least one qi is satisfied by chase(D,Σ). Finally, it is easy to verify that, for each C ∈ {G,L,NR, S}, Σ ∈ C implies Σ′ ∈ C, and Proposition 9 follows."
    }, {
      "heading" : "PROOFS OF SECTION 4 Proof of Proposition 10",
      "text" : "We assume that q(x̄) = ∨n\ni=1 qi(x̄) is a UCQ rewriting of Q. Since, by hypothesis, Q 6⊆ Q ′, we conclude that q 6⊆ Q′, which\nin turn implies that there exists i ∈ {1, . . . , n} such that qi 6⊆ Q ′. Let c(x̄) be a tuple of constants obtained by replacing each variable x in x̄ with the constant c(x), and Dqi the S-database obtained from qi after replacing each variable x in qi with the constant c(x). We show that:\nLemma 33. c(x̄) 6∈ Q′(Dqi).\nProof. Since qi 6⊆ Q ′, there exists an S-database D, and a tuple of constants t̄ such that t̄ ∈ qi(D) and t̄ 6∈ Q ′(D). Clearly, there exists a homomorphism h such that h(qi) ⊆ D and h(x̄) = t̄. Observe also that ρ(Dqi) ⊆ D, where ρ = h ◦ c\n−1. Towards a contradiction, assume that c(x̄) ∈ Q′(Dqi). This implies that there exists a homomorphism γ such that γ(q\n′) ⊆ chase(Dqi ,Σ) and γ(ȳ) = c(x̄), where Q\n′ = (S,Σ, q′(ȳ)). It is not difficult to see that there exists an extension ρ′ of ρ such that ρ′(chase(Dqi ,Σ)) ⊆ chase(D,Σ) and ρ\n′(x̄) = t̄. Hence, ρ′(γ(q′)) ⊆ chase(D,Σ), which implies that t̄ ∈ q′(chase(D,Σ)); thus, t̄ ∈ Q′(D). But this contradicts the fact that t̄ 6∈ Q′(D), and the claim follows.\nObserve that c(x̄) ∈ q(Dqi), which immediately implies that c(x̄) ∈ Q(Dqi). Consequently, by Lemma 33, Q(Dqi) 6⊆ Q ′(Dqi).\nThe claim follows since, by construction, Dqi is an S-database such that |Dqi | ≤ fO(Q).\nAlgorithm 1: The algorithm XRewrite\nInput: An OMQ Q = (S,Σ, q(x̄)) ∈ (TGD,CQ) Output: A UCQ q′(x̄) such that Q(D) = q′(D), for every S-database D\ni := 0; Qrew := {〈q, r, u〉}; repeat\nQtemp := Qrew; foreach 〈q, x, u〉 ∈ Qtemp, where x ∈ {r, f} do\nforeach σ ∈ Σ do /* rewriting step */ foreach S ⊆ body(q) such that σ is applicable to S do\ni := i+ 1; q′ := γS,σi(q[S/body(σ i)]); if there is no (q′′, r, ⋆) ∈ Qrew such that q′ ≃ q′′ then Qrew := Qrew ∪ {〈q′, r, u〉}; end\nend /* factorization step */ foreach S ⊆ body(q) that is factorizable w.r.t. σ do\nq′ := γS(q); if there is no (q′′, ⋆, ⋆) ∈ Qrew such that q′ ≃ q′′ then\nQrew := Qrew ∪ {〈q′, f, u〉}; end\nend\nend /* query q is now explored */ Qrew := (Qrew \\ {(q, x, u)}) ∪ {(q, x, e)};\nend\nuntil Qtemp = Qrew; Qfin := {q | 〈q, r, e〉 ∈ Qrew, and q contains only predicates of S}; return Qfin\nThe Algorithm XRewrite\nIn view of the fact that the rewriting algorithm XRewrite is heavily used in our complexity analysis, we would like to recall its definition. This algorithm is based on resolution, and thus, before we proceed further, we need to recall the crucial notion of unification. A set of atoms A = {α1, . . . , αn}, where n > 2, unifies if there exists a substitution γ, called unifier for A, such that γ(α1) = · · · = γ(αn). A most general unifier (MGU) for A is a unifier for A, denoted as γA, such that for each other unifier γ for A, there exists a substitution γ′ such that γ = γ′ ◦ γA. Notice that if a set of atoms unify, then there exists a MGU. Furthermore, the MGU for a set of atoms is unique (modulo variable renaming).\nThe algorihtm proceeds by exhaustively applying two steps: rewriting and factorization, which in turn rely on the technical notions of applicability and factorizability, respectively. We assume, w.l.o.g., that tgds and CQs do not share variables. Given a CQ q, a variable x is called shared in q if x is a free variable of q, or it occurs more than once in q. In what follows, we assume, w.l.o.g., that tgds are in normal form, i.e., they have only one atom in the head, and only one occurrence of an existentially quantified variable [24]. We write π∃(σ) for the position at which the existentially quantified variable of σ occurs; in case σ does not mention an existentially quantified variable, then π∃(σ) = ε. (Recall that a position P [i] identifies the i-th attribute of a predicate P .) We are now ready to recall applicability and factorizability; in what follows, we write body(q) for the set of atoms occurring in q, and head(σ) for the head-atom of σ.\nDefinition 6. (Applicability) Consider a CQ q and a tgd σ. Given a set of atoms S ⊆ body(q), we say that σ is applicable to S if the following conditions are satisfied:\n1. the set S ∪ {head(σ)} unifies, and\n2. for each α ∈ S, if the term at position π in α is either a constant or a shared variable in q, then π 6= π∃(σ).\nRoughly, whenever σ is applicable to S, this means that the atoms of S may be generated during the chase procedure by applying σ. Therefore, we are allowed to apply a rewriting step (which is essentially a resolution step) that resolves S using σ, i.e., S is replaced by body(σ), and a new CQ that is closer to the input database is obtained.\nIf we start applying rewriting steps blindly, without checking for applicability, then the soundness of the rewriting procedure is not guaranteed. However, it is possible that the applicability condition is not satisfied, but still we should apply a rewriting step. This may happen due to the presence of redundant atoms in a query. For example, given the CQ\nq = ∃x∃y∃z (R(x, y) ∧ R(x, z))\nand the tgd\nσ = P (u, v) → ∃wR(w,u)\nthe applicability condition fails since the shared variable x in q occurs at the position π∃(σ) = R[1]. However, q is essentially the CQ q = ∃x∃yR(x, y), and now the applicability condition is satisfied. From the above informal discussion, we conclude that the applicability condition may prevent the algorithm from being complete since some valid rewriting steps are blocked. Because of this reason, we need the so-called factorization step, which aims at converting some shared variables into nonshared variables, and thus, satisfy the applicability condition. In general, this can be achieved by exhaustively unifying all the atoms that unify in the body of a CQ. However, some of these unifications do not contribute in any way to satisfying the applicability condition, and, as a result, many superfluous CQs are generated. It is thus better to apply a restricted form of factorization that generates a possibly small number of CQs that are vital for the completeness of the rewriting algorithm. This corresponds to the identification of all the atoms in the query whose shared existential variables come from the same atom in the chase, and they can be unified with no loss of information. Summing up, the key idea underlying the notion of factorizability is as follows: in order to apply the factorization step, there must exist a tgd that can be applied to its output.7\nDefinition 7. (Factorizability) Consider a CQ q and a tgd σ. Given a set of atoms S ⊆ body(q), where |S| > 2, we say that S is factorizable w.r.t. σ if the following conditions are satisfied:\n1. S unifies,\n2. π∃(σ) 6= ε, and\n3. there exists a variable x 6∈ var(body(q) \\ S) that occurs in every atom of S only at position π∃(σ).\nHaving the above key notions in place, we are now ready to recall the algorithm XRewrite, which is depicted in Algorithm 1. As said above, the UCQ rewriting of an OMQ q = (S,Σ, q) is computed by exhaustively applying (i.e., until a fixpoint is reached) the rewriting and the factorization steps. Notice that the CQs that are the result of the factorization step, are nothing else than auxiliary queries which are critical for the completeness of the final rewriting, but are not needed in the final rewriting. Thus, during the iterative procedure, the queries are labeled with r (resp., f) in order to keep track which of them are generated by the rewriting (resp., factorization) step. The CQ that is part of the input OMQ, although is not a result of the rewriting step, is labeled by r since it must be part of the final rewriting. Moreover, once the two crucial steps have been exhaustively applied on a CQ q, it is not necessary to revisit q since this will lead to redundant queries. Hence, the queries are also labeled with e (resp., u) indicating that a query has been already explored (resp., is unexplored). Let us now describe the two main steps of the algorithm. In the sequel, consider a triple (q, x, y), where (x, y) ∈ {r, f} × {e, u} (this is how we indicate that q is labeled by x and y), and a tgd σ ∈ Σ. We assume that q is of the form ∃x̄ ϕ(x̄, ȳ).\nRewriting Step. For each S ⊆ body(q) such that σ is applicable to S, the i-th application of the rewriting step generates the query q′ = γS,σi(q[S/body(σ i)]), where σi is the tgd obtained from σ by replacing each variable x with xi, γS,σi\nis the MGU for the set S ∪ {head(σi)} (which is the identity on the variables that appear in the body but not in the head of σi), and q[S/body(σi)] is obtained from q be replacing S with body(σi). By considering σi (instead of σ) we basically rename, using the integer i, the variables of σ. This renaming step is needed in order to avoid undesirable clutters among the variables introduced during different applications of the rewriting step. Finally, if there is no (q′′, r, ⋆) ∈ Qrew, i.e., an (explored or unexplored) query that is the result of the rewriting step, such that q\n′ and q′′ are the same (modulo bijective variable renaming), denoted q′ ≃ q′′, then (q′, r, u) is added to Qrew.\nFactorization Step. For each S ⊆ body(q) that is factorizable w.r.t. σ, the factorization step generates the query q′ = γS(q), where γS is the MGU for S. If there is no (q\n′′, ⋆, ⋆) ∈ Qrew, i.e., a query that is the result of the rewriting or the factorization step, and is explored or unexplored, such that q′ ≃ q′′, then (q′, f, u) is added to Qrew."
    }, {
      "heading" : "Proof of Proposition 14",
      "text" : "We assume, w.l.o.g., that the predicates of S do not appear in the head of a tgd of Σ. Since Σ ∈ NR, by Lemma 32, Σ admits a stratification {Σ1, . . . ,Σn} with stratification function µ : sch(Σ) → {0, . . . , n}. Let us briefly explain how the rewriting tree TQ of the OMQ Q = (S,Σ, q) is defined. TQ is a rooted tree with q being its root. The i-th level of TQ consists of the CQs obtained from the CQs of the (i− 1)-th level by applying rewriting steps (see the algorithm XRewrite for details on the rewriting step) using only tgds from Σn−i+1. It is easy to verify that the CQs of the i-th level contain only predicates P such that µ(P ) < n− i+1. It is now clear that the n-th level of TQ (i.e., the leaves of TQ) consists only of CQs obtained during the execution of XRewrite(Q) that contain only predicates of S. Thus, in order to obtained the desired upper bound, it suffices to show that the number of atoms that occur in a CQ that is a leaf of TQ is at most |q| · (maxτ∈Σ{|body(τ )|}) |sch(Σ)|. To this end, let us focus on one branch B of TQ from the root q to a leaf q ′. Such a branch can be naturally represented as a k-ary forest FBQ , where the root nodes are the atoms of q, and whenever an atom α is resolved during the rewriting step using a tgd τ , the atoms of body(τ ), after applying the appropriate MGU, are the child nodes of α. Therefore, to obtain the desired upper bound, it suffices to show that the number of leaves of FBQ is at most |q| · (maxτ∈Σ{|body(τ )|}) |sch(Σ)|. By construction, FBQ consists, in general, of |q| k-ary rooted trees, where k = maxτ∈Σ{|body(τ )|}, of depth n. Hence, the number of leaves of FBQ is at most |q| · (maxτ∈Σ{|body(τ )|}) n. Since n ≤ |sch(Σ)|, the claim follows. 7Let us clarify that for the purposes of the present work we can rely on the naive approach of exhaustively unifying all the atoms that unify in the body of a CQ. However, we would like to be consistent with [33], where the algorithm XRewrite is proposed, and thus, we stick on the slightly more involved notion of factorizability."
    }, {
      "heading" : "Proof of Theorem 16",
      "text" : "A proof sketch for the coNExpTimeNP upper bound is given in the main body of the paper. We proceed to establish the PNEXP-hardness. Our proof is by reduction from a tiling problem that has been recently introduced in [30], which in turn relies on the standard Exponential Tiling Problem. Let us first recall the latter problem.\nAn instance of the Exponential Tiling Problem is a tuple (n,m,H, V, s), where n,m are numbers (in unary), H,V are subsets of {1, . . . ,m} × {1, . . . ,m}, and s is a sequence of numbers of {1, . . . ,m}. Such a tuple specifies that we desire a 2n × 2n grid, where each cell is tiled with a tile from {1, . . . ,m}. H (resp., V ) is the horizontal (resp., vertical) compatibility relation, while s represents a constraint on the initial part of the first row of the grid. A solution to such an instance of the Exponential Tiling Problem is a function f : {0, . . . , 2n − 1} × {0, . . . , 2n − 1} → {1, . . . ,m} such that:\n1. f(i, 0) = s[i], for each 0 ≤ i ≤ (|s| − 1);\n2. (f(i, j), f(i+ 1, j)) ∈ H , for each 0 ≤ i ≤ 2n − 2 and 0 ≤ j ≤ 2n − 1; and\n3. (f(i, j), f(i, j + 1)) ∈ V , for each 0 ≤ i ≤ 2n − 1 and 0 ≤ j ≤ 2n − 2.\nWe will refer to {0, . . . , 2n−1}×{0, . . . , 2n−1} as a grid, with the pairs in it being cells. A cell consists of two coordinates, the column-coordinate (for short col-coordinate) and the row-coordinate, and any function on a grid is a tiling. The Exponential Tiling Problem is defined as follows: given an instance T as above, decide whether T has a solution. It is known that this problem is NExpTime-hard (see, e.g., Section 3.2 of [38]).\nWe are now ready to recall the tiling problem introduced in [30], called Extended Tiling Problem (ETP), which is PNEXPhard. An instance of this problem is a tuple (k, n,m,H1, V1,H2, V2), where k, n,m are numbers (in unary), and H1, V1,H2, V2 are subsets of {1, . . . ,m} × {1, . . . , m}. The question is as follows: is it the case that for every sequence s, where |s| = k, of numbers of {1, . . . ,m}, (n,m,H1, V1, s) has no solution or (n,m,H2, V2, s) has a solution?\nWe give a reduction from the ETP to Cont(NR,CQ). More precisely, given an instance T = (k, n,m,H1, V1, H2, V2) of the ETP, our goal is to construct in polynomial time two queries Qi = (S,Σi, qi) ∈ (NR,CQ), for i ∈ {1, 2}, such that T has a solution iff Q1 ⊆ Q2."
    }, {
      "heading" : "Data Schema S",
      "text" : "The data schema S consists of:\n• 0-ary predicates Cji , for each i ∈ {0, . . . , k − 1} and j ∈ {1, . . . ,m}; the atom C j i indicates that si = j."
    }, {
      "heading" : "The Query Q1",
      "text" : "The goal of the query Q1 is twofold: (i) to check that the so-called existence property of the input database, i.e., for every i ∈ {0, . . . , k− 1}, there exists at least one atom of the form Cji , is satisfied, and (ii) to check whether (n,m,H1, V1, s), where s is the sequence of tilings encoded in the input database, has a solution. To this end, the query Q1 will mention the following predicates:\n• 0-ary predicate Ci, indicating that there exists at least one atom of the form C j i in the input database.\n• 0-ary predicate Existence, indicating that the input database enjoys the existence property.\n• Unary predicate Tilei, for each i ∈ {1, . . . ,m}; the atom Tilei(x) states that x is the tile i.\n• Binary predicate H ; the atom H(x, y) encodes the fact that (x, y) ∈ H1.\n• Binary predicate V ; the atom V (x, y) encodes the fact that (x, y) ∈ V1.\n• 5-ary predicate Ti, for each i ∈ {1, . . . , n}; the atom Ti(x, x1, x2, x3, x4) states that x is a 2 i × 2i tiling obtained from\nthe 2i−1 × 2i−1 tilings x1, . . . , x4 – details on the inductive construction of 2 i × 2i tilings from 2i−1 × 2i−1 tilings are given below.\n• Unary predicate Initiali, for each i ∈ {0, . . . , k− 1}; the atom Initiali(x) states that s[i] = x, i.e., the i-th element of the sequence s is x.\n• Binary predicate Topji , for each i ∈ {1, . . . , n} and j ∈ {0, . . . , k−1}; the atom Top j i (x, y) states that in the 2 i×2i tiling x the tile at position (j, 0) is y.\n• 0-ary predicate Tiling, indicating that there exists a 2n × 2n tiling that is compatible with the initial tiling s encoded in the input database.\n• 0-ary predicate Goal, which is derived whenever the predicates Existence and Tiling are derived.\nQ1 is defined as the query (S,Σ1,Goal), where Σ1 consists of the following tgds:\n(a) (b)\nX1\nX3\nX2\nX4\nX2\nX4\nY1\nY3\nY1\nY3\nY2\nY4\nX3\nZ1\nX4\nZ2\nX4\nZ2\nY3\nW1\nY3\nW1\nY4\nW2\nZ1\nZ3\nZ2\nZ4\nZ2\nZ4\nW1\nW3\nW1\nW3\nW2\nW4\nX1\nX3\nX2\nX4\nY1\nY3\nY2\nY4\nZ1\nZ3\nZ2\nZ4\nW1\nW3\nW2\nW4\n• Check whether there exists a 2n × 2n tiling that is compatible with the sequence of tilings s\nFor each i ∈ {0, . . . , k − 1} and j ∈ {1, . . . ,m}:\nCji ,Tilej(x) → Initiali(x)\nand the tgd\nTop0n(x, y0), Initial0(y0), · · · ,Top k−1 n (x, yk−1), Initialk−1(yk−1) → Tiling\n• Finally, we have the output tgd\nExistence,Tiling → Goal\nThis concludes the construction of Q1."
    }, {
      "heading" : "The Query Q2",
      "text" : "The goal of the query Q2 is twofold: (i) to check that the so-called uniqueness property of the input database, i.e., for every i ∈ {0, . . . , k− 1}, there exists at most one atom of the form Cji , is satisfied, and (ii) to check whether (n,m,H2, V2, s), where s is the sequence of tilings encoded in the input database, has a solution. The query Q2 mentions the same predicates as Q1, and is defined as (S,Σ2,Goal), where Σ2 consists of the following tgds:\n• Checking the uniqueness property\nFor each i ∈ {0, . . . , k − 1} and j, ℓ ∈ {1, . . . , m} with j < ℓ:\nCji , C ℓ i → Goal\n• The rest of Σ2 encodes the tiling problem (n,m,H2, V2, s) in exactly the same way as Σ1 encodes (n,m,H1, V1, s).\nThis concludes the construction of Q2."
    }, {
      "heading" : "Proof of Proposition 18",
      "text" : "The set Σn consists of the following tgds; for brevity, we write x̄ji for xi, xi+1, . . . , xj : 8\nS(x1, . . . , xn) → Pn(x1, . . . , xn)\nPi(x̄ i−1 1 , z, x̄ n i+1, z, o), Pi(x̄ i−1 1 , o, x̄ n i+1, z, o) → Pi−1(x̄ i−1 1 , z, x̄ n i+1, z, o), 1 ≤ i ≤ n,\nP0(z, . . . , z ︸ ︷︷ ︸\nn\n, z, o) → Ans(z, o),\nwhile q = Ans(0, 1). It can be verified that, for every {S}-database D, Qn(D) 6= ∅ implies that\nD ⊇ {S(c1, . . . , cn−2, 0, 1) | (c1, . . . , cn−2) ∈ {0, 1} n−2},\nand thus, |D| ≥ 2n−2. Let Q = ({S},Σ′, q′), where Σ′ is a set of tgds and q′ a Boolean CQ, and D an {S}-database. Clearly, Qn(D) 6⊆ Q(D) iff Qn(D) 6= ∅ and Q(D) = ∅. This implies that |D| ≥ 2n−2, and the claim follows."
    }, {
      "heading" : "Proof of Theorem 19",
      "text" : "The coNExpTime upper bound, as well as the ΠP2 -hardness in case of fixed-arity predicates, are discussed in the main body of the paper. Here, we show the coNExpTime-hardness. The proof proceeds in two steps:\n1. First, we show that Cont((FNR,CQ), (L,UCQ)) is coNExpTime-hard, where FNR denotes the class of full non-recursive sets of tgds, i.e., non-recursive sets of tgds without existentially quantified variables.\n2. Then, we reduce Cont((FNR,CQ), (L,UCQ)) to Cont((S,CQ), (L,UCQ)) by showing that (under some assumptions that are explained below) every query in (FNR,CQ) can be rewritten as an (S,CQ) query.\nBy Proposition 9, we immediately get that Cont((S,CQ), (L,CQ)) is coNExpTime-hard, as needed.\nStep 1: Cont((FNR,CQ), (L,UCQ)) is coNExpTime-hard\nWe show that Cont((FNR,CQ), (L,UCQ)) is coNExpTime-hard, even if we focus on 0-1 queries, that is, queries Q with following property: for every database D, Q(D) = Q(D01), where D01 ⊆ D is the restriction of D on the binary domain {0, 1}, i.e., D01 = {R(c̄) ∈ D | c̄ ⊆ {0, 1}}. The proof is by reduction from the Exponential Tiling Problem, and is a non-trivial adaptation of the one given in [13] for showing that containment of non-recursive Datalog queries is coNExpTime-hard.\nTheorem 34. Cont((FNR,CQ), (L,UCQ)) is coNExpTime-hard, even for 0-1 queries.\nProof. Given an instance T = (n,m,H,V, s) of the Exponential Tiling Problem, we are going to construct a (FNR,CQ) 0-1 query QT = (S,Σ, q) and a (L,UCQ) 0-1 query Q ′ T = (S,ΣT , qT ) such that T has a solution iff QT 6⊆ Q ′ T . 8A similar construction has been used in [33] for showing a lower bound on the size of a CQ in the UCQ rewriting of a (S,CQ) OMQ."
    }, {
      "heading" : "Data Schema S",
      "text" : "The data schema S consists of:\n• 2n-ary predicates TiledByi, for each i ≤ m; the atom TiledByi(x1, . . . , xn, y1, . . . , yn) indicates that the cell with coordinates ((x1, . . . , xn), (y1, . . . , yn)) ∈ {0, 1}\nn × {0, 1}n is tiled by tile i. Notice that we use n-bit binary numbers to represent a coordinate; this is the key difference between our construction and the one of [13]."
    }, {
      "heading" : "The Query QT",
      "text" : "The goal of the query QT is to assert whether the input database encodes a candidate tiling, i.e., whether the entire grid is tiled, without taking into account the constraints, that is, the compatibility relations and the constraint on the initial part of the first row. To this end, the query QT will mention the following predicates:\n• Unary predicate Bit; the atom Bit(x) simply says that x is a bit, i.e., x ∈ {0, 1}.\n• 2n-ary predicate TiledAboveColi, for each i ≤ n; the atom TiledAboveColi(x̄, ȳ) says that for the row-coordinate ȳ there are tiled cells with coordinates (x̄′, ȳ) for every col-coordinate x̄′ that agrees with x̄ on the first i − 1 bits. In other words, for the row corresponding to ȳ, every column extending the first i − 1 bits of x̄ is tiled. In particular, TiledAboveCol1(x̄, ȳ) says that the entire row ȳ is tiled.\n• 2n-ary predicate TiledAboveRowi, for each i ≤ n; the atom TiledAboveRowi(ȳ) says that for every ȳ ′ that agrees with\nȳ on the first i− 1 bits, the row ȳ′ is fully tiled.\n• n-ary predicate RowTiled; the atom RowTiled(ȳ) says that the row ȳ is fully tiled.\n• 0-ary predicate AllTiled, which asserts that the entire grid is tiled.\n• 0-ary predicate Goal, which is derived whenever the predicate AllTiled is derived.\nQT is defined as the query (S,Σ,Goal), where Σ consists of the following rules:\n• Generate Bit atoms\n→ Bit(0)\n→ Bit(1).\n• RowTiled\nFor each j, k ≤ m:\nTiledByj(x1, . . . , xn−1, 1, y1, . . . , yn),TiledByk(x1, . . . , xn−1, 0, y1, . . . , yn),\nBit(x1), . . . ,Bit(xn−1),Bit(y1), . . . ,Bit(yn),Bit(w) →\nTiledAboveColn(x1, . . . , xn−1, w, y1, . . . , yn)\nFor each 2 ≤ i ≤ n:\nTiledAboveColi(x1, . . . , xi−1, 1, xi+1, . . . , xn, y1, . . . , yn),\nTiledAboveColi(x1, . . . , xi−1, 0, x ′ i+1, . . . , x ′ n, y1, . . . , yn),\nBit(wi), . . . ,Bit(wn) →\nTiledAboveColi−1(x1, . . . , xi−1, wi, . . . , wn, y1, . . . , yn)\nA row is fully tiled:\nTiledAboveCol1(x1, . . . , xn, y1, . . . , yn) → RowTiled(y1, . . . , yn)\n• AllTiled\nRowTiled(y1, . . . , yn−1, 1),RowTiled(y1, . . . , yn−1, 0),Bit(w) → TiledAboveRown(y1, . . . , yn−1, w)\nFor each 2 ≤ i ≤ n:\nTiledAboveRowi(y1, . . . , yi−1, 1, yi+1, . . . , yn),\nTiledAboveRowi(y1, . . . , yi−1, 0, y ′ i+1, . . . , y ′ n),\nBit(wi), . . . ,Bit(wn) →\nTiledAboveRowi−1(y1, . . . , yi−1, wi, . . . , wn)\nThe entire grid is tiled:\nTiledAboveRow1(y1, . . . , yn) → AllTiled\nAllTiled → Goal\nThis concludes the construction of the query QT ."
    }, {
      "heading" : "The Query Q′T",
      "text" : "Q′T is defined in such a way that Q ′ T (D) is non-empty exactly when the input database D encodes an invalid tiling, i.e., when one of the constraints on the tiles is violated. The query Q′T will mention the following intensional predicates:\n• Unary predicate Bit; as above, Bit(x) says that x is a bit.\n• 2i-ary predicate LastFirsti, for each 1 ≤ i ≤ n; the atom LastFirsti(x1, . . . , xi, y1, . . . , yi) says that (x1, . . . , xi) = (1, . . . , 1) and (y1, . . . , yi) = (0, . . . , 0).\n• 2i-ary predicate Succi, for each 1 ≤ i ≤ n; the atom Succi(x̄, ȳ) says that the i-bit binary number ȳ is the successor of the i-bit binary number x̄.\n• 0-ary predicate Goal.\nQ′T is defined as the query (S,Σ ′, q′). The set Σ′ consists of the following linear tgds:\n• Generate Bit atoms:\n→ Bit(0)\n→ Bit(1).\n• Generate the successor predicates:\n→ Succ1(0, 1)\n→ LastFirst1(1, 0).\nFor each 1 ≤ i ≤ n− 1:\nSucci(x1, . . . , xi, y1, . . . , yi) → Succi+1(0, x1, . . . , xi, 0, y1, . . . , yi)\nSucci(x1, . . . , xi, y1, . . . , yi) → Succi+1(1, x1, . . . , xi, 1, y1, . . . , yi)\nLastFirsti(x1, . . . , xi, y1, . . . , yi) → Succi+1(0, x1, . . . , xi, 1, y1, . . . , yi)\nLastFirsti(x1, . . . , xi, y1, . . . , yi) → LastFirsti+1(1, x1, . . . , xi, 0, y1, . . . , yi).\nThe UCQ q′ consists of the following (Boolean) CQs; for brevity, the existential quantifiers in front of the CQs are omitted:\n• Tile Consistency\nFor each i 6= j ≤ m:\nTiledByi(x1, . . . , xn, y1, . . . , yn),TiledByj(x1, . . . , xn, y1, . . . , yn),\nBit(x1), . . . ,Bit(xn),Bit(y1), . . . ,Bit(yn)\n• Tile Compatibility\nFor each (i, j) 6∈ V :\nSuccn(x1, . . . , xn, y1, . . . , yn),\nTiledByi(w1, . . . , wn, x1, . . . , xn),TiledByi(w1, . . . , wn, y1, . . . , yn),\nBit(w1), . . . ,Bit(wn)\nFor each (i, j) 6∈ H :\nSuccn(x1, . . . , xn, y1, . . . , yn),\nTiledByi(x1, . . . , xn, w1, . . . , wn),TiledByi(y1, . . . , yn, w1, . . . , wn),\nBit(w1), . . . ,Bit(wn)\n• Tiling of First Row\nFor each j ≤ n, let fj be the function from {1, . . . , n} into {0, 1} such that fj(1) . . . fj(n) is the number j in binary representation, and let k ∈ {1, . . . ,m} other than s[j]; recall that s is a sequence of numbers of {1, . . . ,m} that represents a constraint on the initial part of the first row of the grid. Then, we have the CQ:\nTiledByk(x1, . . . , xn, z, . . . , z ︸ ︷︷ ︸\nn\n),Succ1(z, o)\nwhere, for each i ∈ {1, . . . , n}, xi = z if fj(i) = 0, and xi = o if fj(i) = 1.\nThis concludes the definition of the query Q′T .\nStep 2: Cont((S,CQ), (L,UCQ)) is coNExpTime-hard\nOur goal is show that every 0-1 query (S,Σ, q) ∈ (F,CQ) can be equivalently rewritten as a 0-1 query (S,Σ′, q′), where all the tgds of Σ′ are lossless, i.e., all the body-variables appear also in the head, which in turn implies that Σ′ is sticky.\nProposition 35. Consider a 0-1 query Q ∈ (F,CQ). We can construct in polynomial time a 0-1 query Q′ ∈ (S,CQ) such that Q ≡ Q′.\nProof. Let Q = (S,Σ, q), and assume that n is the maximum number of variables occurring in the body of a tgd of Σ. We are going to construct in polynomial time a 0-1 query Q′ = (S,Σ′, q′) ∈ (S,CQ) such that Q ≡ Q′.\nThe set Σ′ consists of the following tgds:\n• Initialization Rules\nWe first transform every database atom of the form R(c̄) into an atom R′(c̄, 0, . . . , 0 ︸ ︷︷ ︸\nn\n, 0, 1). This is done as follows:\n→ Bit(0)\n→ Bit(1)\nand, for each k-ary predicate R ∈ S, we have the lossless tgd\nR(x1, . . . , xk),Bit(x1), . . . ,Bit(xk) → R ′(x1, . . . , xk, 0, . . . , 0\n︸ ︷︷ ︸ n\n)\nNotice that we can safely force the variables x1, . . . , xk to take only values from {0, 1} due to the 0-1 property.\n• Transformation into Lossless Tgds\nFor each tgd σ ∈ Σ of the form\nR1(x̄1), . . . , Rk(x̄k) → R0(x̄0)\nwe have the lossless tgd\nR′1(x̄1, 0, . . . , 0 ︸ ︷︷ ︸\nn\n), . . . , R′k(x̄k, 0, . . . , 0 ︸ ︷︷ ︸\nn\n) → R′0(x̄0, y1, . . . , yn),\nwhere, if {v1, . . . , vℓ}, for ℓ ∈ {1, . . . , n}, is the set of variables occurring in the body of σ (the order is not relevant), then yi = vi, for each i ∈ {1, . . . , ℓ}, and yj = v1, for each j ∈ {ℓ+ 1, . . . , n}.\n• Finalization Rules\nObserve that each atom obtained during the chase due to one of the lossless tgds introduced above is of the form R′(x̄, ȳ), where ȳ ∈ {0, 1}n. If ȳ 6= (0, . . . , 0), then we need to ensure that eventually the atom\nR′(x̄, 0, . . . , 0 ︸ ︷︷ ︸\nn\n)\nwill be inferred. This is achieved by adding to Σ′ the following tgds: For each k-ary predicate R occurring in Σ, and for each 1 ≤ i ≤ n, we have the rule:\nR′(x1, . . . , xk, y1, . . . , yi−1, 1, yi+1, . . . , yn) → R ′(x1, . . . , xk, y1, . . . , yi−1, 0, yi+1, . . . , yn).\nThis concludes the definition of Σ′.\nThe CQ q′ is defined analogously. More precisely, assuming that q is of the form (the existential quantifiers are omitted)\nR1(x̄1), . . . , Rk(x̄k)\nthe CQ q′ is defined as\nR′1(x̄1, 0, . . . , 0 ︸ ︷︷ ︸\nn\n), . . . , R′k(x̄k, 0, . . . , 0 ︸ ︷︷ ︸\nn\n).\nIt is easy to verify that Σ′ consists of lossless tgds, and thus, Q′ ∈ (S,CQ). It also not difficult to see that, for every database D over S, Q(D01) = Q ′(D01); thus, by the 0-1 property, Q(D) = Q ′(D), and the claim follows.\nBy Theorem 34 and Proposition 35, we immediately get that Cont((S,CQ), (L,UCQ)) is coNExpTime-hard, as needed."
    }, {
      "heading" : "PROOFS OF SECTION 5",
      "text" : "Recall that, for the sake of technical clarity, we focus on constant-free tgds and CQs, but all the results can be extended to the general case at the price of more involved definitions and proofs. Moreover, we assume that tgds have only one atom in the head. This does not affect the generality of our proof since every set of guarded tgds can be transformed in polynomial time into a set of guarded tgds with the above property; see, e.g., [22]. Finally, for convenience of presentation, we also assume that the body of a tgd is non-empty, i.e., the body of a tgd is always an atom and not the symbol ⊤."
    }, {
      "heading" : "Proof of Proposition 21",
      "text" : "Let us start by recalling the key notion of tree decomposition. Notice that the definition of the tree decomposition that we give here is slightly different than the one in the main body of the paper. The reason is because, for convenience of presentation, we prefer to employ a slightly different notation.\nDefinition 8. Let I be an instance. A tree decomposition of I that omits V , where V ⊆ dom(I), is a pair δ = (T , (Xt)t∈T ),\nwhere T = (T,ET ) is a tree and (Xt)t∈T a family of subsets of dom(I) (called the bags of the decomposition) such that:\n1. For every v ∈ dom(I) \\ V , the set {t ∈ T | v ∈ Xt} is non-empty and connected.\n2. For every atom P (s1, . . . , sn) ∈ I , there is a t ∈ T such that {s1, . . . , sn} ⊆ Xt.\nThe width of a tree decomposition δ = (T , (Xt)t∈T ) omitting V is max{|Xt| : t ∈ T} − 1. The tree-width of I is the minimum among the widths of all tree decompositions of I that omit V . We call a tree decomposition omitting ∅ simply tree decomposition of I . For v ∈ T , we denote by Iδ(v) the subinstance of I induced by Xv.\nNotation. We usually denote the strict partial order among the nodes of a tree T of a tree decomposition δ = (T , (Xt)t∈T ) by ≺. Accordingly, we write v w iff v ≺ w or v = w. For brevity, ε will usually denote the root of a tree decomposition at hand. If ambiguities could possibly arise, we shall use subscripts in these notations. Furthermore, when δ is clear from context, we shall omit it from the expression Iδ(v).\nLet δ = (T , (Xt)t∈T ) be a tree decomposition of I and V ⊆ T . Recall that δ is [V ]-guarded (or guarded except for V ), if for every node v ∈ T \\ V , there is an atom P (s1, . . . , sn) ∈ I such that Xv ⊆ {s1, . . . , sn}. A [∅]-guarded tree decomposition of I is simply called guarded tree decomposition.\nAlso recall the crucial notion of C-tree:\nDefinition 9. An S-instance I is a C-tree, where C ⊆ I , if there is a tree decomposition δ = (T , (Xt)t∈T ) of I such that\n1. Iδ(ε) = C, i.e., the subinstance of I induced by Xε equals C.\n2. δ is guarded except for {ε}.\nIf δ or C is clear from context, we shall often refer to |dom(C)| as the diameter of D and to C as the core of D.\nRemark. The notion of C-tree defined here refers to both instances and databases, i.e., a C-tree may be a (finite) database or an instance. We often do not explicitly mention whether a C-tree at hand is a database or an instance. However, it will be clear from context whether a C-tree is a database or an instance.\nWe proceed to establish the following technical lemma, which in turn allows us to show Proposition 21. It is an adaption of a result in [6] to the case of guarded tgds. Henceforth, for brevity, given a query Q = (S,Σ, q) ∈ (G,BCQ) and an S-database D, we write D |= Q for the fact that Q(D) 6= ∅.\nLemma 36. Let Q = (S,Σ, q) be an OMQ from (G,BCQ). Let D be an S-database and suppose D |= Q. Then there is a\nfinite S-instance Î such that Î |= Q and:\n1. Î is a C-tree such that |dom(C)| ≤ ar(S ∪ sch(Σ)) · |q|.\n2. There is a homomorphism from Î to D.\nBefore we proceed with its formal proof, let us explain why Proposition 21 is an easy consequence of Lemma 36. The fact that the first item implies the second is trivial. Conversely, suppose that Q1 6⊆ Q2, which implies that there exists an S-database D such that D |= Q1 and D 6|= Q2. By Lemma 36, there exists a C-tree Î, where |dom(C)| ≤ ar(S∪sch(Σ1)) · |q1|, such that Î |= Q1. Moreover, there is a homomorphism from Î to D; hence, since Q2 is closed under homomorphisms, it immediately follows that Î 6|= Q2. Consequently, the S-database D̂ obtained from Î after replacing each null z with a distinct constant cz is a C-tree such that Q1(D̂) 6⊆ Q2(D̂), and Proposition 21 follows.\nWe now proceed with the proof of Lemma 36 which is our main task in this section. Before that, we introduce some additional auxiliary concepts."
    }, {
      "heading" : "The Guarded Chase Forest",
      "text" : "Given a database D and a set Σ of guarded tgds, the guarded chase forest for D and Σ is a forest (whose edges and nodes are labeled) constructed as follows:\n1. For each fact R(ā) in D, add a node labeled with R(ā).\n2. For each node v labeled with α ∈ chase(D,Σ) and for every atom β resulting from a one-step application of a rule τ ∈ Σ, if α is the image of the guard in this application of τ , then add a node w labeled with β and introduce an arc from v to w labeled with τ .\nWe can assume that the guarded chase forest is always built inductively according to a fixed, deterministic version of the chase procedure. The non-root nodes are then totally ordered by a relation ≺ that reflects their order of generation. Furthermore, we can extend ≺ to database atoms by picking a lexicographic order among them. Notice that one atom can be the label of multiple nodes. Using the order ≺ we can, however, always refer to the ≺-least node."
    }, {
      "heading" : "Guarded Unraveling",
      "text" : "Let I be an instance over S. We say that X ⊆ dom(I) is guarded in I , if there are a1, . . . , as ∈ dom(I) such that\n• X ⊆ {a1, . . . , as} and\n• there is an R/s ∈ S such that I |= R(a1, . . . , as).\nA tuple t̄ is guarded in I if the set containing the elements of t̄ is guarded in I . In the following paragraph, we largely follow the notions introduced in [1, 12]. Fix an S-instance I and some X0 ⊆ dom(I). Let Π be the set of finite sequences of the form X0X1 · · ·Xn, where, for i > 0, Xi is a guarded set in I , and, for i ≥ 0, Xi+1 = Xi ∪ {a} for some a ∈ dom(I) \\Xi, or Xi ⊇ Xi+1. The sequences from Π can be arranged in a tree by their natural prefix order and each sequence π = X0X1 · · ·Xn identifies a unique node in this tree. In this context, we say that a ∈ dom(I) is represented at π whenever a ∈ Xn. Two sequences π, π\n′ are a-equivalent, if a is represented at each node on the unique shortest path between π and π′. For a represented at π, we denote by [π]a the a-equivalence class of π. The guarded unraveling around X0 is the instance I ∗ over the elements {[π]a | a is represented at π}, where\nI∗ |= R([π1]a1 , . . . , [πn]an) ⇐⇒df I |= R(a1, . . . , an) and\n∃π ∈ Π,∀i ∈ {1, . . . , n} : [π]ai = [πi]ai ,\nfor all R/n ∈ S.\nLemma 37. For every S-instance I and any X0 ⊆ dom(I), the guarded unraveling I ∗ around X0 is a C-tree over S, where\nC is the subinstance of I∗ induced by the elements {[X0]a | a ∈ X0}.\nProof. Let δ = (T , (Xt)t∈T ), where T is the natural tree that arises from ordering the sequences in Π by their prefixes. For π ∈ T , let Xπ := {[π]a | a is represented at π}. Let ε denote the root of T . We need to show that δ is an appropriate tree decomposition witnessing that I∗ is a C-tree. First, note that it is clear that I(ε) = {[X0]a | a ∈ X0} by construction. Let [π]a ∈ dom(I) and consider the set A := {t ∈ T | [π]a ∈ Xt}. This set is certainly non-empty. Moreover, for t1, t2 ∈ A, we know that [t1]a = [t2]a, hence t1 and t2 are a-connected in T . Suppose I\n∗ |= R([π1]a1 , . . . , [πn]an) for some R/n ∈ S. Then there is a π ∈ T such that [π]ai = [πi]ai , for all i = 1, . . . , n. Hence, a1, . . . , an are all represented at π and so {[π1]a1 , . . . , [πn]an} ⊆ Xπ. It remains to show that δ is guarded except for {ε}. Let π 6= ε and consider the set Xt. Since π is a sequence of length greater than one, its last element Y is a guarded set in I . Hence, there are a1, . . . , as such that Y ⊆ {a1, . . . , as} and I |= R(a1, . . . , as) for some R/s ∈ S. Let {a1, . . . , as} \\ Y = {b1, . . . , bm} and define ρ := π · (Y ∪ {b1}) · (Y ∪ {b1, b2}) · · · (Y ∪ {b1, . . . , bm}). Then I∗ |= R([ρ]a1 , . . . , [ρ]as), as desired.\nNotice that this lemma implies that the tree-width of I∗ is bounded by |X0|+ ar(S)− 1. We are now ready to prove Lemma 36:\nProof of Lemma 36. Let q = ∃ȳ ϕ(ȳ) and µ a homomorphism mapping ϕ(ȳ) to chase(D,Σ). Let R1(b̄1), . . . , Rk(b̄k) exhaust all facts from D that are the roots of those ≺-least facts from µ(ϕ(ȳ)) in the guarded chase forest of D and Σ that have an element from dom(D) as argument. Let Gµ := ⋃ 1≤i≤k{b̄i} and let I ∗ be the unraveling of D around Gµ, regarding all elements from dom(I∗) as labeled nulls. Henceforth, for every a ∈ Gµ, we denote by λa the element [Gµ]a. We say that λa represents a. Let C be the substructure of I ∗ induced by the set {λa | a ∈ Gµ}. Notice that I ∗ is an infinite instance that is a C-tree by Lemma 37. We will show later how to get a finite instance from I∗ that satisfies our constraints. We proceed to show that I∗ ∪ Σ logically entails q, denoted I∗,Σ |= q:\nLemma 38. I∗,Σ |= q.\nProof. We will first construct a universal model J of I∗ and Σ. Recall that an instance U is a universal model of I and Σ, if it can be homomorphically mapped to every model of I ∪ Σ; in particular, it is well-known and easy to prove that chase(I,Σ) is always a universal model of I and Σ. Before constructing J , we introduce some additional notions. In the following, given a guarded set G = {a1, . . . , ak} in D, a copy of G in I ∗ is a set Γ = {α1, . . . , αk} which is guarded in I ∗ such\nthat, for i = 1, . . . , k, we have that αi = [πi]ai for some sequences πi and D |= R(ai1 , . . . , aim) iff I ∗ |= R(αi1 , . . . , αim ) for all R ∈ S and ij ∈ {1, . . . , k}. Copies of guarded tuples are defined accordingly. Consider the structure chase(D,Σ). Let G be a guarded set in D and D ↾ G denote the subinstance of D induced by G. It is well-known and easy to prove that chase(D ↾ G,Σ) is acyclic (cf., e.g., [21]). Henceforth, we loosely call chase(D ↾ G,Σ) the tree attached to G. The model J is constructed as follows. Let J0 be the instance C. Furthermore, for each guarded set G = {a1, . . . , ak} in D and each copy Γ = {α1, . . . , αk} of G in I\n∗, construct a new instance JΓ that is isomorphic to the tree attached to G such that (i) the elements ai of G are renamed to αi in JΓ, (ii) dom(J0) ∩ dom(JΓ) = {α1, . . . , αk}, and (iii) Γ ∩ Θ = dom(JΓ) ∩ dom(JΘ), for every copy Θ of G in I∗. The model J is the union of J0 and all the JΓ. If a guarded set X in JΓ arises from renaming elements of a guarded set Y in chase(D ↾ G,Σ), we also say that X is a copy of Y in J . Furthermore, the copies of D that are contained in I∗ (i.e., in J0) are also called copies in J . Observe that J is a model of I\n∗ by construction. We show that it is a model of Σ. To this end, we show the following claim.\nClaim 39. Let t̄ be a guarded tuple in J and let q(x̄) be a guarded conjunctive query9 over S∪ sch(Σ). Suppose t̄ is a copy of s̄ in J, where s̄ is over dom(chase(D,Σ)) and |t̄| = |s̄|. Then J |= q(t̄) iff chase(D,Σ) |= q(s̄).\nProof. Suppose J |= q(t̄). Let {t̄} = {α1, . . . , αk} be a copy of {s̄} = {a1, . . . , ak} in J . Since q(x̄) is guarded, there is a Γ ⊇ ({α1, . . . , αk}∩ dom(J0)) such that JΓ |= q(t̄). Let G ⊇ {s̄} be the guarded set in D of which Γ is a copy in J0. It clearly holds that chase(D ↾ G,Σ) |= q(s̄), whence chase(D,Σ) |= q(s̄) follows.\nSuppose that chase(D,Σ) |= q(s̄). Let t̄ = α1, . . . , αk and s̄ = a1, . . . , ak and suppose that αi = [πi]ai (i = 1, . . . , k). The set {a1, . . . , ak} is guarded in chase(D,Σ). Hence, there is a guarded G ⊇ {a1, . . . , ak} ∩ dom(D) in D such that chase(D ↾ G,Σ) |= q(s̄). We show that there is a Γ ⊇ {α1, . . . , αk} ∩ dom(I\n∗) which is a copy of G in I∗. Suppose G = {b1, . . . , bl}. Let π = X0X1 · · ·Xm be such that [π]ai = [πi]ai for all i = 1, . . . , k. For i = 1, . . . , l, define\nρi := π · (Xm ∪ {b1}) · (Xm ∪ {b1, b2}) · · · (Xm ∪ {b1, . . . , bi}).\nThen bi is represented at ρi. For i = 1, . . . , l, let βi := [ρi]bi . We claim that Γ := {β1, . . . , βl} is a copy of G in I ∗. Let R/s ∈ S and suppose I∗ |= R([ρi1 ]bi1 , . . . , [ρis ]bis ). Then we immediately obtain D |= R(bi1 , . . . , bis ). Conversely, if D |= R(bi1 , . . . , bis), let ρ := ρℓ, where ℓ := max{i1, . . . , is}. Take any j ∈ {i1, . . . , is}. It is easy to see that ρ and ρj are bj-equivalent. Hence, [ρj ]bj = [ρ]bj and it follows that I ∗ |= R([ρi1 ]bi1 , . . . , [ρis ]bis ), as required. It follows that Γ is a copy of G in I∗ and so there is a structure JΓ contained in J that is isomorphic to chase(D ↾ G,Σ) with b1, . . . , bl respectively renamed to β1, . . . , βl. Hence, J |= q(t̄) as required.\nNow let σ : ϕ(x̄, ȳ) → ∃z̄ α(x̄, z̄) be a guarded rule from Σ. Suppose that J |= ∃ȳ ϕ(t̄, ȳ). Since every guarded tuple in J is a copy of some guarded tuple in chase(D,Σ), there is an s̄, of which t̄ is a copy, such that chase(D,Σ) |= ∃ȳ ϕ(s̄, ȳ). Since chase(D,Σ) is a model of Σ, we know that chase(D,Σ) |= ∃z̄ α(s̄, z̄). It follows that J |= ∃z̄ α(s̄, z̄) by the above claim, as required. It remains to show that J is universal:\nClaim 40. J is universal.\nProof. It suffices to show that J can be homomorphically mapped to chase(I∗,Σ) via a homomorphism η. We let η0 be the homomorphism that maps every element of J0 to itself. It remains to treat the structures JΓ. Consider a copy Γ = {α1, . . . , αk} in I\n∗ of a set G = {b1, . . . , bk} which is guarded in D. It suffices to show that JΓ can be mapped to chase(I∗,Σ). To this end, it we show how to map chase(D ↾ G,Σ) to chase(I∗,Σ). We do so by induction on the number of rule applications of chase(D ↾ G,Σ). For the base case, we map D ↾ G to I∗ as follows. Let η0G(bi) := αi, for i = 1, . . . , k. Suppose D ↾ G |= R(bi1 , . . . , bil) for some R ∈ S and ij ∈ {1, . . . , k}, where j = 1, . . . , l. Recall that Γ is guarded in I\n∗. Reviewing the construction of I∗, it is easy to see that this holds iff I∗ |= R(αi1 , . . . , αil ). Hence, η 0 G is indeed a homomorphism from D ↾ G to I∗. The induction step is obvious—we can easily obtain a homomorphism ηiG that maps chase k(D ↾ G,Σ) to chase(I∗,Σ). The desired homomorphism ηG is the union of the η i G (i ≥ 0). We then obtain a homomorphism ηΓ from ηG by appropriately renaming the elements from the domain of the latter as we did in the construction of JΓ—which is nothing else than an isomorphic copy of chase(D ↾ G,Σ). Furthermore, each of these homomorphisms maps each element of Γ to itself. The desired homomorphism η that witnesses that J is universal is the union of η0 and the ηΓ.\nIn order to prove I∗,Σ |= q, it remains to show that there is a homomorphism µ̂ that maps q to J . There are guarded sets G1, . . . , Gl in D such that µ can be understood to map q to chase( ⋃\n1≤i≤l(D ↾ Gi),Σ). By construction, we know\nthat G1, . . . , Gl can be chosen in such a way that Gµ ⊆ ⋃l\ni=1 Gi. Since Σ is guarded, µ can be understood to map q to ⋃\n1≤i≤l chase(D ↾ Gi,Σ)—assuming that the labeled nulls occurring in these instances are mutually new. Let Cµ :=\n{{b̄1}, . . . , {b̄k}}. For every X ∈ Cµ, let ΓX := {λb | b ∈ X}. Notice that ΓX is a copy of X in I ∗. By construction, all the facts from q that are mapped via µ to chase(D,Σ) and which have an element from dom(D) in their image under µ are already mapped to ⋃\nX∈Cµ chase(D ↾ X,Σ). For the other facts, the names of the constants in the databases do not matter.10\nLet Θ1, . . . ,Θs be arbitrary copies of the sets {G1, . . . , Gl} \\ Cµ in I ∗. It follows that we can find our desired match µ̂ in the\n9By a guarded conjunctive query we mean here a CQ that contains an atom that contains all the variables occurring in the CQ as argument.\n10Here, it is of course essential to assume constant-free rules.\nunion of ⋃\nX∈Cµ JΓX and\n⋃ 1≤i≤s JΘi . Notice that ⋃ X∈Cµ JΓX is isomorphic to ⋃ X∈Cµ chase(D ↾ X,Σ) with each b ∈ Gµ\nrepresented by λb.\nNow the database I∗ has the desired form with C being its core. However, I∗ is infinite. Since I∗,Σ |= q due to Lemma 38, by compactness, there is a finite B̂ ⊆ I∗ such that B̂,Σ |= q. Consider a tree decomposition δ = (T , (Xt)t∈T ) witnessing that I∗ is a C-tree. There is a maximum ℓ such that B̂ contains all the subinstances induced by the bags of depth less or equal ℓ. Let Î be the instance that actually contains all the subinstances induced by the bags of level up to ℓ. Hence, Î is itself a C-tree and Î ,Σ |= q, since B̂ ⊆ Î .\nNow there is a natural homomorphism mapping Î to D: we simply specify [π]a 7→ a for all a ∈ dom(D). The instance Î is the one we are looking for."
    }, {
      "heading" : "Proof of Lemma 22",
      "text" : "One can naturally encode instances of bounded tree-width into trees over a finite alphabet such that the alphabet’s size depends only on the tree-width. Our goal here is to appropriately encode C-trees in order to make them accessible to tree automata techniques. Since the tree-width of a C-tree over S depends only on the size of dom(C) and the maximum arity of S, the alphabet of the encoding will depend on the same.\nLabeled trees. Let Γ be an alphabet and (N \\ {0})∗ be the set of finite sequences of positive integers, including the empty sequence ε.11 Let us recall that a Γ-labeled tree is a pair t = (T, µ), where µ : T → Γ is the labeling function and T ⊆ (N\\{0})∗ is closed under prefixes, i.e., x · i ∈ T implies x ∈ T , for all x ∈ (N ∪ {0})∗ and i ∈ (N ∪ {0}). The elements contained in T identify the nodes of t. For i ∈ N \\ {0}, nodes of the form x · i ∈ T are the children of x. A path of length n in T from x to y is a sequence of nodes x = x1, . . . , xn = y such that xi+1 is a child of xi. A branch is a path from the root to a leaf node. For x ∈ T , we set x · i · −1 := x, for all i ∈ N, and x · 0 := x—notice that ε · −1 is not defined.\nEncoding. Let l ≥ 0 and fix a schema S. Let US,l be the disjoint union of two sets Cl and TS, respectively containing l and 2 · ar(S) elements. The elements from US,l will be called names. Elements from the set Cl will describe core elements, while those of TS will describe the others. Furthermore, neighboring nodes may describe overlapping pieces of the instance. In particular, if one name is used in neighboring nodes, this means that the name at hand refers to the same element—this is why we use 2w elements for the non-root bags. Let KS,l be the finite schema capturing the following information:\n• For all a ∈ US,l, there is a unary relation Da ∈ KS,l.\n• For all a ∈ Cl, there is a unary relation Ca ∈ KS,l.\n• For each R ∈ S and every n-tuple ā ∈ UnS,l, there is a unary relation Rā ∈ KS,l.\nLet ΓS,l := 2 KS,l be an alphabet and suppose that D is a (finite) C-tree over S such that |dom(C)| ≤ l. Consider a tree decomposition δ = (T , (Xt)t∈T ) witnessing that D is indeed a C-tree and let ε be the root of T . Fix a function f : dom(D) → US,l such that (i) f ↾ dom(C) is injective and (ii) different elements that occur in neighboring bags of δ are always assigned different names from US,l. Using f , we can encode D and δ into a ΓS,l-labeled tree t = (T̂ , µ) such that each node from T corresponds to exactly one node in T̂ and vice versa. For a node v from T , we denote the corresponding node of T by v̂ in the following and vice versa. In this light, the symbols from KS,l have the following intended meaning:\n• Da ∈ µ(v̂) means that a is used as a name for some element of the bag Xv.\n• Ca ∈ µ(v̂) indicates that a is used as name for an element of the bag Xv that also occurs in Xε, i.e., a names an element from the core of D.\n• Rā ∈ µ(v̂) indicates that R holds in D for the elements named by ā in bag Xv .\nUnder certain assumptions, we can decode a ΓS,l-labeled tree t = (T, µ) into a C-tree whose width is bounded by ar(S)− 1. Let names(v) := {a | Da ∈ µ(v)}. We say that t is consistent, if it satisfies the following properties:\n1. For all nodes v it holds that |names(v)| ≤ ar(S), except for the root whose number of names are accordingly bounded by l. Furthermore, names(ε) ⊆ Cl.\n2. For all Rā ∈ KS,l and all v ∈ T it holds that Rā ∈ µ(v) implies that {ā} ⊆ names(v).\n3. For all a ∈ Cl and all v ∈ T it holds that Da ∈ µ(v) iff Ca ∈ µ(v).\n4. If Ca ∈ µ(v), then Ca ∈ µ(w) for all w ∈ T on the unique shortest path between v and the root.\n5. For all nodes v 6= ε, there is an Rā ∈ KS,l and a node w such that Rā ∈ µ(w), names(v) ⊆ {ā}, and, for all b ∈ names(v), v and w are b-connected.\n11We specify that 0 is included in N as well.\nDecoding trees. Suppose now that t is consistent. We show how we can decode t into a database JtK which is a C-tree whose diameter is bounded by l. Let a be a name used in t. We say that two nodes v, w of t are a-equivalent if Da ∈ µ(u) for all nodes u on the unique shortest path between v and w. Clearly, a-equivalence defines an equivalence relation and we let [v]a := {(w, a) | w is a-equivalent to v} and [v] ∗ a := {w | (w, a) ∈ [v]a}. The domain of JtK is the set {[v]a | v ∈ T, a ∈ µ(v)} and, for R/n ∈ S, we define\nJtK |= R([v1]a1 , . . . , [vn]an) ⇐⇒df there is some v ∈ [v1] ∗ a1 ∩ · · · ∩ [vn] ∗ an such that Ra1,...,an ∈ µ(v).\nLemma 41. Let t be a consistent ΓS,l-labeled tree with root node ε. Then JtK is well-defined and a C-tree over S, where C is the subinstance of JtK induced by the set {[ε]a | a ∈ names(ε)}. Moreover, |dom(C)| is bounded by l.\nProof. Let t = (T, µ) be a consistent, ΓS,l-labeled tree. The fact that JtK is well-defined is left to the reader. We are going to construct an appropriate decomposition δ = (T , (Xt)t∈T ) for JtK. The tree T has the same structure as t. Furthermore, for v ∈ T , we set Xv := {[v]a | a ∈ names(v)}. We need to show that δ is indeed a tree decomposition that satisfies the desired properties.\nLet [v]a ∈ dom(JtK) and consider two nodes v1, v2 ∈ T such that [v]a ∈ Xv1 and [v]a ∈ Xv2 . Then v1, v2 ∈ [v]a and so v1 and v2 are a-connected. Hence, w ∈ [v]a for all w ∈ T which lie on the unique shortest path between v1 and v2. Since a ∈ names(w) for all such w, it follows that [v]a ∈ Xw , and so [v]a is contained in all bags on the unique path between v1 and v2. Suppose JtK |= R([v1]a1 , . . . , [vn]an). Then there is a v ∈ [v1] ∗ a1 ∩ · · · ∩ [vn] ∗ an such that Ra1,...,an ∈ µ(v). By consistency, {a1, . . . , an} ⊆ names(v). Moreover, we know that [vi]ai = [v]ai , for i = 1, . . . , n. It follows that {[v1]a1 , . . . , [vn]an} ⊆ Xv . Now let v ∈ T \\ {ε}. By consistency, there is an Ra1,...,an ∈ KS,l and a w ∈ T such that names(v) := {ai1 , . . . , ais} ⊆ {a1, . . . , an} ⊆ names(w), Ra1,...,an ∈ µ(w), and v and w are bij -connected for j = 1, . . . , s. By construction, Xv = {[v]ai1 , . . . , [v]ais } and {[w]a1 , . . . , [w]an} ⊆ Xw. The claim follows now since [v]aij = [w]aij for j = 1, . . . , s. It is immediate that |dom(C)| is bounded by l.\nNotation. Given a consistent ΓS,l-labeled tree t = (T, µ) and a label ρ ∈ µ(T ), in order to ease notation we often regard ρ as a database consisting of the facts {R(ā) | Rā ∈ ρ}. Furthermore, we let names(ρ) := {a | Da ∈ ρ}.\nProof of Lemma 22. The lemma is an easy consequence of Lemma 41 and the fact that, when encoding a C-tree D over S, together with a tree decomposition witnessing that D is a C-tree, into a consistent ΓS,l-labeled tree t, then JtK and D are isomorphic.\nRoughly, Lemma 22 states that containment among OMQs from (G,BCQ) can be semantically characterized via the decodings of consistent ΓS,l-labeled trees. This makes the problem of deciding containment amenable to tree automata techniques."
    }, {
      "heading" : "Proof of Lemma 23",
      "text" : "Before proceeding to the proof of Lemma 23, we first introduce the relevant automata model."
    }, {
      "heading" : "Automata Techniques",
      "text" : "For a set of propositional variables X, we denote by B+(X) the set of Boolean formulas using variables from X, the connectives ∧,∨, and the constants true, false. Let us now introduce our automata model.\nDefinition 10. A two-way alternating parity automaton (2WAPA) on trees is a tuple A = (S,Γ, δ, s0,Ω), where S is a finite set of states, Γ an alphabet (the input alphabet of A), δ : S × Γ → B+(tran(A)) the transition function, where we set tran(A) := {〈α〉s, [α]s | s ∈ S, α ∈ {−1, 0, ∗}}, s0 ∈ S the initial state, and Ω: S → N the parity condition that assigns to each s ∈ S a priority Ω(s). Elements from tran(A) are called transitions.\nIntuitively, a transition of the form 〈0〉s means that a copy of the automaton should change to state s and stay at the current node. A transition of the form 〈−1〉s means that a copy should be sent to the parent node, which is then required to exist, and proceed in state s, while one of the form 〈∗〉s means that a copy of the automaton that assumes state s is sent to some child node. The transition [0]s means the same as 〈0〉s, while [−1]s means that a copy of the automaton that assumes state s should be sent to the parent node which is there not required to exist at all. Likewise, [∗]s means that a copy of the automaton assuming state s should be sent to all child nodes.\nNotation. We write ✸s for ∨ {〈α〉s | 〈α〉s ∈ tran(A), s ∈ S}, ✷s for ∧ {[α]s | [α]s ∈ tran(A), s ∈ S}, and simply s for 〈0〉s.\nFurthermore, for α ∈ N ∪ {−1, ∗}, we define\nTα(x) :=\n \n\n{x · α}, if α = −1 and x · α ∈ T ,\n{x · i | x · i ∈ T, i ∈ N \\ {0}}, if α = ∗,\n∅, otherwise.\nDefinition 11. A run of a 2WAPA A = (S,Γ, δ, s0,Ω) on a Γ-labeled tree (T, η) is a T × S-labeled tree (Tr, ηr) such that the following holds:\n1. ηr(ε) = (ε, s0),\n2. if y ∈ Tr, ηr(y) = (x, s), and δ(s, η(x)) = ϕ, then there is an I ⊆ tran(A) such that I |= ϕ holds and the following conditions are satisfied:\n• If 〈α〉s′ ∈ I then there is a node x′ ∈ Tα(x) and a child node y ′ ∈ Tr of y such that ηr(y ′) = (x′, s′). • If [α]s′ ∈ I then for all x′ ∈ Tα(x), there is a child node y ′ ∈ Tr of y such that ηr(y ′) = (x′, s′).\nWe say that a run (Tr, ηr) is accepting on A, if on all infinite paths (ε, s0), (x1, s1), (x2, s2), . . . in Tr, the maximum priority among Ω(s0),Ω(s1),Ω(s2), . . . that appears infinitely often is even. A accepts a Γ-labeled tree (T, η), if there is an accepting run on (T, η). We denote by L(A) the set of Γ-labeled trees A accepts, i.e., the language accepted by A.\nRemark. The automaton model defined above resembles that in [48]. However, we explicitly provide transitions that allow the automaton move to the parent node, while the model defined in [48] provides transitions for moving to some neighboring node, including the parent node. Therefore, the automata in [48] offer transitions of the form s, ✸s, and ✷s with their intended meaning as defined above. Using techniques as employed in [47, 48], for a 2WAPA A, one can show that the problem of deciding whether L(A) = ∅ is feasible in exponential time with respect to the number of states of A and in polynomial time with respect to the size of the input alphabet of A.\nProof of Lemma 23. We only give an intuitive explanation for the construction of the desired 2WAPA. To check whether a ΓS,l-labeled tree is consistent, we can check each condition for consistency separately by a dedicated 2WAPA and then take the intersection of all of them. Most of the consistency conditions are easy to check. We give here a more detailed verbal explanation for condition (5). A 2WAPA checking this condition can be constructed as follows. At the beginning of its run, the automaton branches universally to all nodes (except the root) in a state whose intended purpose is to find appropriate guards in the input tree for the names available at the current node. To this end, the automaton has to do a reachability analysis on the input tree and store, using exponentially many states in ar(S), the tuple it seeks to guard. By a guard for the node v here, we mean a node w with an Rā ∈ µ(w) such that (i) {ā} contains all the names present at w and (ii) is b-connected to v for all b ∈ names(v). Notice that such a reachability analysis can be easily performed once we have the means to store the information contained in names(v) in a single state. This is, however, possible since for this task we need somewhat O((ar(S)+ l)ar(S)) states, i.e., polynomially many in the size of ΓS,l."
    }, {
      "heading" : "Proof of Lemma 24",
      "text" : "We first need to introduce some additional auxiliary notions."
    }, {
      "heading" : "Strictly Acyclic Queries",
      "text" : "Let q be a CQ over a schema S. We denote by free(q) the free variables of q; the same notation is used for first-order formulas in general. We can naturally view q as an instance [q] whose domain is the set of variables of q and contains the body atoms of q as facts. In the following, we will often overload notation and write q for both the query q and the instance [q]. The notions of tree-width, acyclicity, etc. then immediately extend to CQs. Given a tree decomposition δ of q (i.e., of [q]), we say that δ is strict, if some bag of δ contains all variables that are free in q (cf. also [32]). Accordingly, q is called strictly acyclic if it has a guarded tree decomposition that is strict.\nStrictly acyclic queries have the convenient property to be equivalent to guarded formulas of a special form. Recall that the set of guarded formulas over a schema S is built inductively by including all atomic formulas, relativizing quantifiers by atomic formulas, and closing under Boolean connectives. More precisely, all quantifier occurrences have one of the forms\n∀ȳ (α(x̄, ȳ) → ϕ) and ∃ȳ (α(x̄, ȳ) ∧ ϕ),\nsuch that the free variables of ϕ are among {x̄, ȳ}. We are interested in the guarded formulas that are build up using conjunction and existential quantification; we restrict ourselves to such formulas in the following. We call a formula from this class strictly guarded, if it is of the form ∃ȳ (α(x̄, ȳ)∧ϕ). We explicitly include the case where ȳ is the empty sequence of variables, i.e., if to formulas of the form α(x̄) ∧ ϕ with free(ϕ) ⊆ {x̄}. Notice that every guarded sentence ϕ (i.e., a formula having no free variables) is strictly guarded, since it is equivalent to ∃y (y = y ∧ ϕ). Furthermore, notice that every usual guarded formula that uses only existential quantifiers and conjunction is equivalent to a conjunction of strictly guarded formulas. The following lemma is proved in [32].\nLemma 42. Every strictly acyclic CQ can be rewritten in polynomial time into an equivalent strictly guarded formula that is built up using conjunction and existential quantification only. The converse holds as well."
    }, {
      "heading" : "Squid Decompositions",
      "text" : "Let q be a BCQ over a schema S having n body atoms. An S-cover of q is a BCQ q+ that contains all the atoms from q and may additionally contain 2n other body atoms over S. It is pretty straightforward that, for an S-instance I , it holds that I |= q iff there is an S-cover q+ of q such that I |= q+.\nDefinition 12. Let I be an instance. For V ⊆ dom(I), we say that I is [V ]-acyclic, if it has a guarded tree decomposition that omits V .\nDefinition 13. Let q be a BCQ over S. A squid decomposition of q is a tuple δ = (q+, µ,H,T, V ), where q+ is an S-cover of q, µ : var(q+) → var(q+) a mapping, V ⊆ var(µ(q+)), and (H,T ) a partition of the atoms µ(q+) such that\n• H is the set of atoms of µ(q+) induced by V ,\n• T = µ(q+) \\H and T is [V ]-acyclic.\nIntuitively, a squid decomposition specifies a way how a BCQ can be mapped to an instance that contains some “cyclic parts”—the set H specifies those atoms that are mapped to such cyclic parts, while A declares those atoms that are mapped to the acyclic parts of the instance at hand. We will make this more precise in Lemma 43 below, where we analyze matches in C-trees.\nGiven a CQ q and a set of variables V ⊆ var(q), the V -reduct of q, denoted qV , is the conjunctive query that arises from q by dropping all the existential quantifiers that bind variables in V .\nLemma 43. Let J be a C-tree over S and q a BCQ over S. Let (T , (Xt)t∈T ) be a witnessing tree decomposition of J. It holds that J |= q iff there is a squid decomposition δ = (q+, µ,H,A, V := {x̄}) of q and a homomorphism η : µ(q+) → J such that\n1. C |= H is witnessed by η,\n2. ⋃\nε≺v J(v) |= A V (η(x̄)) is witnessed by η, and\n3. there are strictly guarded formulas ϕ1, . . . , ϕl such that A V (x̄) ≡ ϕ1 ∧ · · · ∧ ϕl.\nProof. For the direction from right to left, consider such a given squid decomposition δ and a homomorphism η as in the hypothesis of the lemma. It is immediate that η ◦ µ is a homomorphism mapping q+ to J . Since q+ is an S-cover of q, we obtain J |= q as required.\nFor the other direction, suppose that J |= q is witnessed by a homomorphism θ. For each v ∈ T \\ {ε}, let βv be an atom of J such that J(v) |= βv and βv contains all domain elements from J(v) as arguments. Notice that the βv exist, since δ is guarded except for {ε}. Since θ maps q to J , for each atom α of q, there is a node vα such that θ(α) ∈ J(vα). Let W be the set of all these nodes and their closure under greatest lower bounds with respect to , excluding the root node ε of T . Consider the set of atoms Q+ := θ(q) ∪ {βv | v ∈ W }. Notice that at least half of the nodes of W are of the form vα—hence, |Q+| ≤ 3|q|. Let q+ be a BCQ constructed as follows. Take the conjunction of q and for each βv(a1, . . . , an) (v ∈ W ), add an atom βv(x1, . . . , xn), where each xi is a newly chosen variable. Then q\n+ is obviously an S-cover of q. Furthermore, by construction, there is a mapping µ : var(q+) → var(q+) and an isomorphism η : µ(q+) → Q+ such that (η ◦ µ)(q+) = Q+. Now let H be the greatest set of atoms of µ(q+) such that η(H) ⊆ J(ε). Moreover, let V := var(H) and A := µ(q+) \\ H . We claim that δ := (q+, µ, H,A, V ) is a squid decomposition of q that satisfies together with η the points mentioned in the statement of the lemma.\nTo see that δ is a squid decomposition of q, the only nontrivial point to prove is that A is indeed [V ]-acyclic. We will prove this below in the course of establishing the third item.\nThe first two items are immediate by construction. We prove the third item. Suppose V = {x̄} and consider the V -reduct AV (x̄) of A. By construction, the atoms η(A) are contained in ⋃\nε≺v J(v). Now the set W together with the order T gives rise to a forest consisting of trees T1, . . . , Tl whose roots are descendants of ε, i.e., the root of T (recall that ε is not contained in W ). Moreover, we have (i) ⋃l\ni=1 Ti = W , (ii) Ti ∩ Tj = ∅, for i 6= j, and (iii) ⋃ v∈Ti Xv ∩ ⋃ v∈Tj Xv ⊆ dom(C), for i 6= j.\nFor v ∈ T , let Q+(v) := {α ∈ Q+ | J(v) |= α} and, for i = 1, . . . , l, let Q+(Ti) be the set of atoms ⋃\nv∈Ti Q+(v). Now it is\neasy to check using the facts stated before that each Q+(Ti) is acyclic and, hence, so is η −1(Q+(Ti)). Furthermore, denoting by εi the root of Ti, it holds that dom(Q +(Ti)) ∩ η(V ) ⊆ dom(Q +(εi))—indeed, if a ∈ dom(Q +(v)) ∩ η(V ) for some v εi, then, since εi ≻ ε and a ∈ Xε, it must be the case that a ∈ dom(Q +(εi)) by connectivity. It follows that the V -reduct of η−1(Q+(Ti)) (viewed as Boolean query), henceforth denoted q + Ti , is strictly acyclic and is therefore equivalent to a strictly guarded formula ϕi. Hence, the query A V (x̄) is equivalent to ∧l i=1 ϕi. Moreover, it follows that A itself is [V ]-acyclic—notice that A ≡ ∃x̄ ∧l\ni=1 q + Ti and that dom(Q+(Ti)) ∩ dom(Q +(Tj)) ⊆ η(V ), for i 6= j. Hence, var(q + Ti ) ∩ var(q+Tj ) ⊆ V , for i 6= j.\nThe claim now follows since every q+Ti is acyclic."
    }, {
      "heading" : "Derivation trees",
      "text" : "Let D be an S-database and Σ a set of guarded rules. Let q0(x̄) be a strictly acyclic query whose free variables are exactly those from x̄ := x1, . . . , xn and let ā := a1, . . . , an be a tuple from dom(D). A derivation tree for (ā, q0(x̄)) with respect to D and Σ is a finite tree T whose nodes are labeled via a function µ with pairs of the form (b1, . . . , bk; q(y1, . . . , yk)), where b1, . . . , bk are constants from dom(D) and q(y1, . . . , yk) is a strictly acyclic query over S ∪ sch(Σ) having exactly y1, . . . , yk free, such that the following conditions are satisfied:\n1. µ(ε) = (ā, q0(x̄)), where ε is the root node of T .\n2. If µ(v) = (c1, . . . , cm; q(z1, . . . , zm)) for some node v, then one of the following conditions holds (let c̄ := c1, . . . , cm and z̄ := z1, . . . , zm):\n(a) v is a leaf node and q(z̄) ≡ β(z̄), for some atomic formula β(z̄) such that D |= β(c̄).\n(b) The node v has a successor labeled by (c̄, b̄; p(z̄, ȳ)) and it holds that\nΣ |= ∀z̄, ȳ (p(z̄, ȳ) → q(z̄)).\n(c) The query q(z̄) is logically equivalent to q1(zi1,1 , . . . , zi1,k1 )∧· · ·∧ql(zil,1 , . . . , zil,kl ) and v has l successors v1, . . . , vl respectively labeled by (ci1,1 , . . . , ci1,k1 ; q1(zi1,1 , . . . , zi1,ki )), . . . , (cil,1 , . . . , ci1,kl ; ql(zil,1 , . . . , zi1,kl )).\nLemma 44. Let α(x1, . . . , xn) be an atomic formula. Then D,Σ |= α(a1, . . . , an) iff there is a derivation tree for (a1, . . . , an;α(x1, . . . , xn)) with respect to D and Σ.\nProof (sketch). Let ā := a1, . . . , an and x̄ := x1, . . . , xn. The direction from right to left is an easy induction on the construction of the derivation tree. We sketch the other direction. Consider the guarded chase forest (F , η) for D and Σ, where η is a function labeling the nodes and edges of F . We construct a derivation tree for (ā, α(x̄)) by induction on the number of chase steps required to derive α(ā) from D and Σ.\nFor the base case, if D |= α(ā), the claim is obvious since we can apply rule 2.(a). Assume that α(ā) is derived using a rule\nσ : β0(x̄, ȳ), β1, . . . , βk → α(x̄),\nand a homomorphism µ such that µ(x̄) = ā, where β0(x̄, ȳ) is the guard of σ. If µ({x̄, ȳ}) ⊆ dom(D), the result immediately follows by the induction hypothesis. Otherwise, the image of β0(x̄, ȳ) under µ contains some labeled nulls as arguments. Assume that all the β1, . . . , βk contain nulls as their arguments—for those that do not, the induction hypothesis would yield appropriate derivation trees again. Notice that all the nulls occurring in β1, . . . , βk appear in µ({ȳ}). By construction of F , there is a node v0 that is an ancestor of the nodes having the atoms µ(β0), µ(β1), . . . , µ(βk) as labels and which has a label of the form β0(ā, b̄) which contains no nulls at all as arguments. There is a corresponding atomic formula γ0(x̄, z̄) whose image under an appropriate homomorphism equals β0(ā, b̄). Furthermore, there are atoms γ1, . . . , γl such that dom({γ1, . . . , γl}) ⊆ {ā, b̄} and\nΣ |= β0(ā, b̄) ∧ γ1 ∧ · · · ∧ γl → ∃ȳ (β0(ā, ȳ) ∧ β1 ∧ · · · ∧ βk).\nNow regard the γi (i = 1, . . . , l) as atomic formulas with free variables among {x̄, z̄}. The formula p(x̄, z̄) := γ0(x̄, z̄)∧γ1∧· · ·∧γl is then a strictly acyclic query that satisfies Σ |= ∀x̄, z̄ (p(x̄, z̄) → α(x̄)). An application of rule 2.(b) then requires us to find a derivation tree for (ā, b̄; p(x̄, ȳ)), whence an application of rule 2.(c) reduces this task to finding derivation trees for the atoms γ0, γ1, . . . , γl and their corresponding tuples of constants. These trees exist by induction hypothesis and we can simply concatenate them appropriately in order to arrive at a derivation tree for (ā, α(x̄)).\nGiven a guarded formula ϕ(x̄) built up from conjunctions and existential quantification, we define the nesting depth of ϕ(x̄), denoted nd(ϕ(x̄)), inductively:\n• If ϕ(x̄) is an atomic formula, then nd(ϕ(x̄)) := 0.\n• If ϕ(x̄) = (ψ1 ∧ ψ2), then nd(ϕ(x̄)) := max{nd(ψ1),nd(ψ2)}.\n• If ϕ(x̄) = ∃ȳ (α(x̄, ȳ) ∧ ψ) and ȳ 6= ∅, then nd(ϕ(x̄)) := nd(ψ) + 1.\nLemma 45. Let D be a database, Σ a set of guarded rules, and q(x̄) a strictly acyclic conjunctive query. Then D,Σ |= q(ā) iff there is a derivation tree for (ā, q(x̄)) with respect to D and Σ.\nProof (sketch). We again sketch only the direction from left to right. Let ϕ(x̄) be the strictly guarded formula corresponding to q(x̄). We proceed by induction on the nesting depth of ϕ(x̄). If nd(ϕ(x̄)) = 0, then ϕ(x̄) is quantifier free and thus a conjunction of atoms α0(x̄) ∧ α1 ∧ · · · ∧ αk, where var(αi) ⊆ {x̄} for i = 1, . . . , k. An application of rule 2.(c) reduces the problem of building a derivation tree for (ā, ϕ(x̄)) to the problem of building corresponding trees for the αi and their corresponding constants from ā. The existence of these trees is guaranteed by Lemma 44.\nNow suppose that nd(ϕ(x̄)) = n+ 1. Let ϕ(x̄) = ∃ȳ (α(x̄, ȳ) ∧ ψ) and ȳ := y1, . . . , yk. Assume, without loss of generality, that all the bound variables from ϕ(x̄) are pairwise distinct. In the following, we will describe how to construct a derivation tree for (ā, q(x̄)). If D,Σ |= q(ā), then there is a homomorphism µ mapping each atom of q(x̄) to chase(D,Σ) such that µ(x̄) = ā. Furthermore, µ maps each atom of q(x̄) to a node of the guarded chase forest F of D and Σ. Let αµ(ā, λ1, . . . , λk) denote the atom labeling the node of F where α(x̄, ȳ) is mapped to via µ. Let λi1 , . . . , λil exhaust all elements from λ1, . . . , λk that are not from dom(D) and b̄ := λj1 , . . . , λjm exhaust those from λ1, . . . , λk that are from dom(D). Let ϕ\n′(x̄, yj1 , . . . , yjm ) be the formula ∃yi1 , . . . , yil (α(x̄, ȳ) ∧ ψ). Clearly, Σ |= ∀x̄, yj1 , . . . , yjm (ϕ\n′(x̄, yj1 , . . . , yjm) → ϕ(x̄)). Hence, we can create a successor of (ā, ϕ(x̄)) that is labeled by (ā, b̄;ϕ′(x̄, yj1 , . . . , yjm)). Assume now that none of the λ1, . . . , λk is from dom(D). Furthermore, assume that k ≥ 1, since otherwise we can just simply apply rule 2.(c) to reduce q(x̄) to a conjunction of queries of the desired form. As in the proof of Lemma 44, there is a node v0 in F whose label β0(ā, b̄) contains only values from dom(D) as arguments and such that v0 is an ancestor of the node labeling αµ(ā, λ1, . . . , λk). Furthermore, all the atoms from\nµ(q(x̄)) that contain an element from λ1, . . . , λk as argument are also located in the subtree rooted at v0. Let p be the query that results from deleting all atoms from q(x̄) which are mapped via µ into the subtree rooted at v0. Notice that p may be empty and has free variables among x̄. Furthermore p is equivalent to a conjunction p1∧· · ·∧pl of strictly acyclic queries. Let β0(x̄, z̄) be the atomic formula whose image under an appropriate homomorphism equals β0(ā, b̄). A similar line of reasoning as in the proof of Lemma 44 shows that there are atomic formulas β1, . . . , βm such that var(βi) ⊆ {x̄, z̄} and\n∀x̄, z̄ (β0(x̄, z̄) ∧ β1 ∧ · · · ∧ βm ∧ p → ϕ(x̄)),\nwhence an application of rule 2.(b) and rule 2.(c) reduces the problem of constructing a derivation tree for (ā, ϕ(x̄)) to that of constructing corresponding trees for β0, . . . , βm and p. Notice that p is a conjunction of strictly guarded formulas of nesting depth at most n. Hence, the induction hypothesis guarantees the existence of such derivation trees.\nHaving the above results in place, it is easy to show the following statement:\nLemma 46. Let D be a C-tree over S and Q = (S,Σ, q) an OMQ where Σ is guarded and q a BCQ. Then D |= Q iff there is a squid decomposition δ = (q+, µ, H,A, V := {x̄}) of q and a homomorphism η : µ(q+) → chase(D,Σ) such that:\n1. F |= H is witnessed by η, where F is the subinstance of chase(D,Σ) induced by dom(C).\n2. There are strictly acyclic queries q1, . . . , ql such that\n(a) AV (x̄) ≡ q1 ∧ · · · ∧ ql and\n(b) for i = 1, . . . , l and free(qi) = {x̄i}, there are derivation trees for (η(x̄i), qi) with respect to D and Σ.\nProof. We can easily prove by induction on the number of chase steps that chase(D,Σ) is an F -tree, where F is the subinstance of chase(D,Σ) induced by dom(C). Now the lemma at hand is immediate by combining this fact with Lemma 43 and Lemma 45.\nWe are now ready to proceed with the proof of Lemma 24:\nProof of Lemma 24. Lemma 46 will guide the construction of the 2WAPA we are now going to construct. Suppose Q = (S,Σ, q) is an OMQ from (G,BCQ) and let l ≥ 1. We are going to construct a 2WAPA AQ,l = (S,ΓS,l, δ, s0,Ω) that accepts a consistent ΓS,l-labeled tree t iff JtK |= Q. In particular, the number of states of AQ,l will be at most exponential in the size of Q and at most polynomial in l, while the construction of AQ,l will be feasible in 2ExpTime.\nThe state set. Let Λ denote the set of all Boolean acyclic queries over S ∪ sch(Σ) that are of size at most 3|q|. Notice that each of these queries is equivalent to a strictly guarded formula. Furthermore, assume that Λ is closed under V -reducts, for V ⊆ var(q), provided that they are strictly acyclic as well, i.e., if p ∈ Λ and V ⊆ var(q), then also pV ∈ Λ provided pV is strictly acyclic. For {ā} ⊆ US,l, let\nŜ(ā) := {p(x̄/ā) | p ∈ Λ, free(p) = {x̄}, |ā| = |x̄|}\nand let Ŝ be the union of all the sets Ŝ(ā). Now the set of states S consists of an initial state, denoted s0, plus the set Ŝ factorized modulo logical equivalence. We denote by [p] the equivalence class of a query p ∈ Ŝ. Furthermore, for a strictly\nguarded formula ϕ, we may abuse notation and write [ϕ] for the equivalence class of the strictly acyclic query p ∈ Ŝ that is equivalent to ϕ. Notice that the size of S is exponential in the size of Q, since there are only exponentially many CQs of size at most 3|q| that are mutually non-equivalent (cf. [9]).\nThe parity condition. We set Ω(s) := 1, for all s ∈ S. This means that only finite trees are accepted.\nThe transition function. In the following, for each ρ ∈ ΓS,l, we denote by Θ̂(ρ) the set of all pairs that are of the form (α1 ∧ · · · ∧ αn, p1 ∧ · · · ∧ pm) for which there is a squid decomposition of the form (q\n+, µ, H,T, {x̄}) and a function θ : {x̄} → names(ρ) such that:\n• H{x̄}(θ(x̄)) ≡ α1 ∧ · · · ∧ αn, where all the αi are relational ground atoms.\n• T {x̄}(θ(x̄)) ≡ p1 ∧ · · · ∧ pm, where the pi are strictly acyclic queries.\nCall two pairs (ϕ1, ψ1) and (ϕ2, ψ2) as above equivalent if ϕ1 ≡ ϕ2 and ψ1 ≡ ψ2. Let Θ(ρ) be the set of equivalence classes under this relation and denote by [ϕ, ψ] the equivalence of a pair (ϕ,ψ) under this relation. Now we fix for each [p] ∈ S \\ {s0} a strictly guarded formula χ[p] that is equivalent to all queries from [p]. Likewise, we fix a function ϑρ : Θ(ρ) → Θ̂(ρ) such that ϑρ([ϕ, ψ]) ∈ [ϕ,ψ], i.e., which picks a representative for each equivalence class [ϕ,ψ].\nNow let ρ ∈ ΓS,l. Specify δ(·, ρ) as follows:\n1. For the initial state s0, set\nδ(s0, ρ) := ∨ { n∧\ni=1\n[αi] ∧ m∧\ni=1\n[pi] | (α1 ∧ · · · ∧ αn, p1 ∧ · · · ∧ pm) ∈ ϑρ(Θ(ρ))}.\nIntuitively, the automaton selects a squid decomposition where its components are instantiated by names occurring in the root node of the input tree. The automaton tries to verify the single compartments of the squid decomposition, i.e., it tries to match them to the chase expansion of the input database under Σ.\n2. Let [p] ∈ S \\ {s0}. We define δ([p], ρ) according to a case distinction:\n(a) Suppose that p ≡ ⊤. Then δ([p], ρ) := true.\n(b) Suppose χ[p] = ∃ȳ (α(ā, ȳ) ∧ ϕ), where α(ā, ȳ) is an atomic formula (including equality), free(ϕ) ⊆ {ȳ}, and ā exhausts all names occuring in α. If {ā} 6⊆ names(ρ) then δ([p], ρ) := false. Otherwise,\nδ([p], ρ) := ∨ {[ϕ(ȳ/b̄)] | ρ |= α(ā, b̄), {b̄} ⊆ names(ρ)} ∨ ✸[p] ∨ ∨ impl(p, ρ),\nwhere\nimpl(p, ρ) := {[p1] ∧ · · · ∧ [pn] | [p1], . . . , [pn] ∈ S \\ {s0}, {b̄} ⊆ names(ρ),\np1 ∧ · · · ∧ pn ≡ q,\nΣ |= ∀x̄, ȳ (q(ā/x̄, b̄/ȳ) → p(ā/x̄))}.\nWe provide some intuitive explanation for this second case.\n(a) If p is the empty query, it can be satisfied at any input node and, hence, the automaton accepts unconditionally on this computation branch.\n(b) Otherwise, we first inspect the strictly guarded formula χ[p] at hand. If the names occurring in the guard α(ā, ȳ) are not present at the current node, it rejects. Otherwise, it tries to satisfy α(ā, ȳ) with all possible assignments for ȳ at the current node and then proceed in state [ϕ(ȳ/b̄)]. Apart from these possibilities, the automaton can decide to move to any neighboring node (i.e., the parent or a child) while remaining in state [p]. This amounts to an exhaustive search of the input tree that tries to satisfy p in the input tree. Furthermore, the automaton may choose to construct derivation trees for p. There, it uses the information provided by Σ in order to find strictly acyclic queries p1, . . . , pn that imply p. Consequently, it tries to proceed its search with [p1], . . . , [pn].\nWe shall now briefly comment on the running time needed to construct AQ,l. The interesting part of the construction concerns the transition function δ, in particular point 2.(b) involving impl(p, ρ). We have seen that in the proofs of Lemma 44 and Lemma 45 that there are double-exponentially many candidates for the query q(ā/x̄, b̄/ȳ) that (possibly) implies p(ā/x̄) under Σ. Furthermore, q(ā/x̄, b̄/ȳ) consists of at most exponentially many atoms. Each check whether such a query q at hand implies p requires at most double-exponential time in the size of p. This follows from the well-known fact that checking query implication under a set of guarded rules is feasible in 2ExpTime with respect to the size of the right-hand side query, and in polynomial time with respect to the size of the left-hand side query (cf. [21]), i.e., the data complexity of query answering under guarded tgds is polynomial time."
    }, {
      "heading" : "PROOFS OF SECTION 6 Proof of Theorem 26",
      "text" : "A proof sketch is given in the main body of the paper. However, the fact that Cont((G,CQ), (S,CQ)) is in 2ExpTime deserves a formal proof. Recall that to establish the latter result we need a more refined complexity analysis of the problem of deciding whether a guarded OMQ is contained in a UCQ; this is discussed in the main body of the paper. In fact, it suffices to show the following result. As in the previous section, we focus on constant-free tgds and CQs, but all the results can be extended to the general case at the price of more involved definitions and proofs. Moreover, we assume that tgds have only one atom in the head. Recall that we write var≥2(q) for the variables of q that appear in more than one atom, and we also write var=1(q) for the variables of q that appear only in one atom. Then:\nProposition 47. Consider Q ∈ (G,BCQ) and a Boolean CQ q. The problem of deciding whether Q ⊆ q is feasible in\n1. double-exponential time in (||Q||+ |var≥2(q)|); and\n2. exponential time in |var=1(q)|.\nIt is easy to verify that the above result, together with the algorithm devised in the main body of the paper, implies that Cont((G,CQ), (S,CQ)) is in 2ExpTime. The rest of this section is devoted to show the above proposition. Our crucial task is, given a CQ q, to devise an automaton that accepts consistent labeled trees which correspond to databases that make q true.\nLemma 48. Let q be a Boolean CQ over S. There is a 2WAPA Aq,l, where l > 0, that accepts a consistent ΓS,l-labeled tree t iff JtK |= q. The number of states of Aq,l is exponential in |var≥2(q)| and polynomial in (|var=1(q)|+ ar(S)+ l). Furthermore, Aq,l can be constructed in exponential time.\nProof. We are going to construct Aq,l = (S,ΓS,l, δ, s0,Ω). Let x1, . . . , xn be the variables of var=1(q) and fix a total order x1 ≺ x2 ≺ · · · ≺ xn among them. Define the state set S to be\nS := {sy,θ | θ : V → US,l, V ⊆ var≥2(q), y ∈ var=1(q) ∪ {♯}}.\nNotice that |S| = O(|var=1(q)| · (ar(S) + l) |var≥2(q)|). We set s0 := s♯,∅, where ∅ denotes the empty substitution. In the following, we treat q as a set of relational atoms and let X = var≥2(q). For ρ ∈ ΓS,l and sy,θ ∈ S, define δ(sy,θ, ρ) as follows:\n• If y = ♯, distinguish the following cases:\n1. If there is an atom α ∈ θ(q) such that var(α) ∩X 6= ∅ and dom(α) ∩ US,l 6⊆ names(ρ), then δ(s♯,θ, ρ) := false.\n2. Otherwise, let\nδ(s♯,θ, ρ) :=\n{∨ {s♯,η | η ⊇ θ, ρ |= ∃x̄ ∧ (η(q) \\ θ(q))} ∨ ✸s♯,θ, if X ∩ var(θ(q)) 6= ∅,\nsx1,θ , otherwise.\n• Suppose y = xi, for some i = 1, . . . , n. Let αi,θ denote the unique atom α ∈ θ(q) such that xi ∈ var(α). Set\nδ(sxi,θ, ρ) :=\n \n\nsxi+1,θ, if ρ |= ∃x̄ αi,θ and i < n,\ntrue, if ρ |= ∃x̄ αi,θ and i = n,\n✸sxi,θ, otherwise.\nSet the parity condition Ω to be Ω(s) := 1 for all s ∈ S. Intuitively, the automaton works in two passes. The first pass consists of the runs working on states of the form s♯,θ. In this pass, the automaton tries to find an assignment for the variables in the query that appear in at least two distinct atoms. When a candidate assignment θ is found, the automaton changes to state sx1,θ which is the beginning of the second pass. A state of the form sxi,θ means that the assignment θ can be extended to all variables x ≺ xi and, in this state, the automaton tries to extend θ to cover the variable xi. The automaton accepts if it is able to extend the candidate assignment θ to all x1, . . . , xn.\nHaving the above result in place, we can now reduce the problem in question to the emptiness problem for 2WAPA.\nLemma 49. Consider Q ∈ (G,BCQ) and a Boolean CQ q. We can construct in double-exponential time in ||Q|| and in exponential time in ||q|| a 2WAPA A, which has exponentially many states in (||Q|| + |var≥2(q)|) and polynomially many states in |var=1(q)|, such that\nQ ⊆ q ⇐⇒ L(A) = ∅.\nProof. Let Q = (S,Σ, q′) and l = ar(S ∪ sch(Σ)) · |q′|. Then A is defined as:\n(CS,l ∩ AQ,l) ∩ Aq,l.\nIt is an easy task to verify that the claim follows from Lemmas 22, 23, 24, and 48.\nIt is clear that Proposition 47 is an easy consequence of Lemma 49."
    }, {
      "heading" : "PROOFS OF SECTION 7",
      "text" : "Recall that we focus on unary and binary predicates. Moreover, we consider constant-free tgds and CQs, and we assume that tgds have only one atom in the head."
    }, {
      "heading" : "Proof of Proposition 30",
      "text" : "Basics. Let D be a C-tree of width two. We say that a tree decomposition δ = (T , (Xt)t∈T ) witnessing that D is a C-tree is lean, if it satisfies the following conditions:\n• The elements from dom(C) occur only in the root of T and its immediate successors.\n• If w is a child of v in T , then there are unique c, d ∈ dom(D) such that Xv ∩Xw = {c} and Xw \\Xv = {d}. The element d is called new at w.\n• It follows from the previous item that every node v 6= ε in T has a unique new element c ∈ dom(D). We additionally require that c appears in the bag of each child of v.\nIntuitively, C-trees D that have lean tree decomposition represent the actual tree structure of D. It is fairly straightforward to see that every C-tree has a lean tree decomposition.\nRecall that the Gaifman graph of D is the graph G(D) = (V, E) with V := dom(D) and (a, b) ∈ E if a and b coexist in some atom of D. Given two nodes a, b from G(D), the distance from a to b in G(D), denoted dG(D)(a, b), is the minimum length of a path between a and b, and ∞ if such a path does not exist. For a, b ∈ dom(D), we denote by dδ(a, b) the minimum distance among two nodes of T that respectively have a and b in their bags. We call dδ(a, b) the distance from a to b in δ.\nNotice that in a tree decomposition δ witnessing that D is a C-tree, any element a ∈ dom(D), if a appears in the bag of v, then it occurs only at v, at v and its children, or at v and its parent. Since furthermore the bag of the root node is uniquely determined by C, each node in the tree has a uniquely determined set of child nodes whose bags are determined by the structure of D alone. Therefore, the following two lemmas follow immediately.\nLemma 50. Let δ = (T , (Xt)t∈T ) be a lean tree decomposition witnessing that D is a C-tree. Then dδ(a, b) ≤ dG(D)(a, b) for all a, b ∈ dom(D).\nLemma 51. Let δ and δ′ be two lean tree decompositions witnessing that D is a C-tree. Then dδ(a, b) = dδ′(a, b) for all a, b ∈ dom(D).\nIn the following, we denote byD≤k the subinstance of D induced by the set of elements whose distance from any a ∈ dom(C) in any lean tree decomposition δ is bounded by k. The subinstance D>k is defined analogously.The branching degree of a lean tree decomposition is the maximum number of child nodes of any node contained in the tree of δ. Notice that two lean tree decompositions of a C-tree D always have the same branching degree; the argument is similar as for the two lemmas above. Hence, we can simply speak about the branching degree of D.\nEncodings. Recall that a consistent ΓS,l-labeled tree t = (T, µ) encodes information on an S-database D and an appropriate tree decomposition δ of D. It is clear that JtK has a lean tree decomposition, but it is not guaranteed that this is reflected in δ as well. We call (the consistent) t lean, if the tree decomposition δt = (T := (T,E), (Xv)v∈T ) is, where xEy iff y = x · i for some i ∈ N \\ {0} and Xv := {[v]a | a ∈ names(v)}. The following is easy to prove:\nLemma 52. There is a 2WAPA on trees LS,l that accepts a consistent ΓS,l-labeled tree iff it is lean. The number of states of LS,l is bounded logarithmically in the size of ΓS,l and LS,l can be constructed in polynomial time in the size of ΓS,l.\nLet t = (T, µ) be a labeled tree. The branching degree of a node x ∈ T is the cardinality of {i | x · i ∈ T, i ∈ N \\ {0}}; the branching degree of t is the maximum over all branching degrees of its nodes and ∞ is this maximum does not exist. We also say that t is m-ary if the branching degree of t is bounded by m. A node x ∈ T is a leaf node of t if it has branching degree zero. The depth of T is the maximum length among the lengths of all branches and ∞ if this maximum does not exist. Let us remark that the branching degree of the lean ΓS,l-labeled tree t as defined for labeled trees equals the branching degree of JtK as defined above.\nLemma 53. Let Q = (S,Σ, q) be an OMQ from (G2,BCQ). There is an m ≥ 0 such that the following are equivalent:\n1. There is an S-database D such that D |= Q.\n2. There is a C-tree D̂ with |dom(C)| ≤ 2|q| and branching degree at most m such that D̂ |= Q.\nProof. Let l := 2|q| and, let AQ,l be the 2WAPA from Lemma 24. Take the intersection of AQ,l with (i) the 2WAPA CS,l from Lemma 23 and (ii) the 2WAPA from Lemma 52 that checks leanness. Call the resulting automaton B. Then B accepts a ΓS,l-labeled tree t iff t is lean and consistent and JtK |= Q. We let m be the number of states of B and claim that this is the required bound on the branching degree.\nFirst of all, notice that the first item of the lemma trivially implies the second independently from the choice of m. For the other direction, suppose that D |= Q for some S-database D. Then there is a C-tree B such that dom(C) ≤ 2|q| and B |= Q. Being a C-tree, B has a lean tree decomposition δ and the encoding of B together with δ corresponds to a lean ΓS,l-labeled tree t. It follows that t ∈ L(B). By the results of [37], it follows that there is a t′ ∈ L(B) whose branching degree is bounded by the number of states of B, i.e., by m. The tree t′ is lean and consistent, therefore Jt′K is a C′-tree of branching degree at most m for some C′ ⊆ JtK such that |dom(C′)| ≤ 2|q|. Furthermore, Jt′K |= Q, as required.\nWe are now ready to prove Proposition 30:\nProof of Proposition 30. We largely follow [15] here. Choose m as in Lemma 53 above. Suppose first that Q is UCQ rewritable. Let p := p1 ∨ · · · ∨ pn be a corresponding UCQ rewriting. Since the query q is connected, we can assume that p is as well. We choose k > max{|pi| : i = 1, . . . , n} and suppose that D |= Q for some C-tree D. Since p is a UCQ rewriting, D |= pi for some i = 1, . . . , n. Fix a homomorphism µ witnessing that D |= pi. We distinguish cases. Suppose first that µ(var(pi)) ∩ dom(C) 6= ∅. Since p is connected, it follows D≤k |= pi by Lemma 50 and so D≤k |= p. On the other hand, if µ(var(p)) ∩ dom(C) = ∅, then it is also easy to check that D>0 |= p.\nFor the other direction, suppose that the second item of the proposition’s statement holds, i.e., there is a k ≥ 0 such that for all C-trees D over S with |dom(C)| ≤ 2|q| and branching degree at most m it holds that D |= Q implies D≤k |= Q or D>0 |= Q. Let Λ be the set of all C-trees such that |dom(C)| ≤ 2|q| and that have branching degree at most m such that D |= Q. We regard Λ as a set of BCQs and regard it as factorized modulo logical equivalence. It is clear that Λ is finite then and we claim that p :=\n∨n i=1 pi is a UCQ rewriting of Q. We explicitly include the case where Λ is empty, in which case\np is equivalent to the empty disjunction ⊥ and there is no database D at all such that D |= Q. To see that p is indeed a UCQ rewriting of Q, let D be an S-database such that D |= p. Then there is an i = 1, . . . , n such that D |= pi. Furthermore, [pi] |= Q and so D |= Q as well, since Q is closed under homomorphisms. Suppose now D |= Q. We know that there is a C-tree D̂ with |dom(C)| ≤ l := 2|q| and branching degree at most m such that D̂ |= Q and—when we regard D̂ as an instance—there is a homomorphism from D̂ to D. Let D′ ⊆ D̂ be a minimal connected subset of D̂ such that D′ |= Q. D′ is again a C′-tree for some C′ ⊆ D′. Therefore D′≤k |= Q or D ′ >0 |= Q. The latter is impossible by minimality of D\n′. Hence, D′≤k |= Q and so there is a (logically equivalent) copy of D ′ ≤k contained in Λ. Hence, D ′ ≤k |= p, therefore D ′ |= p, and hence D̂ |= p. Recall that, when D̂ is regarded as an instance, there is a homomorphism from D̂ toD. Therefore, D |= p."
    }, {
      "heading" : "Proof of Proposition 31",
      "text" : "Let Q = (S,Σ, q) be an OMQ from (G2,BCQ) such that q is connected. We are going to show that the desired 2WAPA A can be constructed in 2ExpTime. Notice that, using similar results as in [15], this gives us a decision procedure for deciding UCQRew(G2,CQ) also for non-connected queries. Let us first introduce some auxiliary notions.\n2WAPAs on m-ary trees. A 2WAPA B on m-ary trees is just defined as a 2WAPA, except that its transitions tran(B) are {〈k〉s, [k]s | −1 ≤ k ≤ m, s ∈ S}, where S is the state set of B. The notion of run is then defined on m-ary trees only and its definition is modified in the obvious way so as to deal with the transitions 〈k〉s, [k]s. Intuitively, for k = 1, . . . ,m, a transition 〈k〉s means that the automaton should move to the k-th child of the current node (which is then required to exist) and assume state s. Correspondingly, [k]s means that the automaton should move to the k-th child and assume state s provided that this k-th child exists at all. We remark that all 2WAPAs constructed in this paper so far can easily be modified to work on m-ary trees as well and we shall assume in the following that they do so. Furthermore, deciding whether L(B) is feasible in exponential time in the number of states of B and in polynomial time in the size of the input alphabet of B (cf. [47]).\nLet m be as in Proposition 30. In the following, we shall regard all trees mentioned in the following as m-ary and let l := 2|q|. Before proceeding to a proof of Proposition 31, we must make the notion of being an “extension” of a labeled tree more precise.\nExtensions of trees. Let BQ be a 2WAPA that accepts a ΓS,l-labeled tree t iff (i) t is lean and consistent, (ii) JtK |= Q, and (iii) JtK>0 6|= Q. Notice that a 2WAPA A >0 Q that accepts a lean and consistent ΓS,l-labeled tree iff JtK>0 6|= Q can be easily constructed using the construction in Lemma 24. Hence, BQ can be constructed intersecting several 2WAPAs we have already encountered.\nLet Π be the set of all tuples of the form (s, s′), where s and s′ are states of BQ. We define a new alphabet Λ := 2 KS,l∪Π. Notice that Λ is of double-exponential size in the size of Q. For ρ ∈ Λ, we denote by ρ ↾ ΓS,l the restriction of ρ to ΓS,l, that is, ρ∩KS,l. The restriction of a Λ-labeled tree t to ΓS,l, denoted t ↾ ΓS,l, is the tree that arises from t when we restrict the label of each node of t to ΓS,l. We say that a Λ-labeled tree is consistent if (i) its restriction to ΓS,l is consistent and (ii) symbols ρ ∈ Λ such that ρ ∩ Π 6= ∅ appear only in leaf nodes of t. Likewise, we say that a consistent t is lean if t ↾ ΓS,l is. The decoding JtK of t is naturally extended to consistent Λ-labeled trees by setting JtK := Jt ↾ ΓS,lK. The following lemma is a straightforward extension of Lemmas 23 and 52.\nLemma 54. There are 2WAPAs CΛ and LΛ that respectively accept a Λ-labeled tree iff it is consistent and lean. Both have logarithmically many states in the size of Λ and can be constructed in polynomial time in the size of Λ.\nLet t be a lean and consistent Λ-labeled tree. We say that t′ is an extension of t if t′ is a ΓS,l-labeled tree that arises from t by attaching ΓS,l-labeled trees to those leaves of t that contain elements from Π. Furthermore, for such nodes, the labels of the corresponding nodes in t′ are those of t restricted to ΓS,l.\nDefinition 14. Let LQ be the set of all lean and consistent Λ-labeled trees t such that JtK 6|= Q, yet there is an extension t ′\nof t such that Jt′K |= Q and Jt′K>0 6|= Q.\nLemma 55. LQ is infinite iff Q is not UCQ rewritable.\nProof. Suppose LQ is infinite. Since the trees at hand have bounded branching degree, for every k ≥ 0, there is a t ∈ LQ such that JtK is a C-tree (for some C ⊆ JtK) that contains individuals whose distance from any a ∈ dom(C) is greater than or equal to k and JtK 6|= Q, yet for some extension t′ of t, we have Jt′K |= Q but Jt′K>0 6|= Q. Suppose now that Q is UCQ rewritable. Let ℓ be such that for all C′-trees D (of the appropriate dimensions), D |= Q implies D≤ℓ |= Q or D>0 |= Q. Choose k > ℓ and t, t′ such that (i) t′ is an extension of t, (ii) t has depth greater than k, and (iii) JtK 6|= Q but Jt′K |= Q and Jt′K>0 6|= Q. Since Jt ′K |= Q, we know that Jt′K≤ℓ |= Q or Jt ′K>0 |= Q. The latter is impossible by assumption, the former contradicts the fact JtK 6|= Q, since k > ℓ. This proves the direction from left to right. The other direction is immediate.\nWe are now ready to establish Proposition 31:\nProof of Proposition 31. We are now going to describe the construction of a 2WAPA A such that L(A) = LQ, which will prove the claim by virtue of Lemma 55. This automaton is the intersection of several ones. First of all, we ensure that all the accepted Λ-trees are lean and consistent (cf. Lemma 54). We additionally intersect the automaton with the complement of AQ,l from Lemma 23 (more precisely, the version of it running on Λ-labeled trees) and another automaton DQ = (S,Λ, δ, s0,Ω) whose construction we shall describe in more detail here. On a high level, DQ will be constructed so as to accept a lean and consistent Λ-labeled tree if and only if there is an extension t′ of t such that BQ accepts t ′. Let Ŝ be the set of states of BQ, δ̂ its transition function, and Ω̂ its parity function. For σ ∈ ΓS,l, let B̂(σ) be the set of tuples (s, s ′) ∈ Ŝ × (Ŝ ∪ {true}) such that the following holds:\n• There is a ΓS,l-labeled tree t = (T, η) such that η(ε) = σ and a run tr = (Tr, ηr) of BQ on t such that\n1. ηr(ε) = (ε, s), i.e., tr starts from s; 12\n12Strictly speaking, tr is, of course, not a run since it does not start in the initial state.\n2. s′ = true and tr is accepting on BQ, or there is a node v ∈ Tr such that ηr(v) = (ε, s ′).\nNow the set of states of DQ is the same as of BQ, i.e., S := Ŝ. Accordingly, the initial state of DQ is that of BQ. Furthermore Ω(s) := Ω̂(s), for every s ∈ S. Given s ∈ S and ρ ∈ Λ, we let\nδ(s, ρ) := ∨ {s′ | (s, s′) ∈ ρ ∩ B̂(ΓS,l ↾ ρ)} ∨ δ̂(s,ΓS,l ↾ ρ).\nWe are going to give an intuitive explanation of this construction in the following. Roughly, a pair (s, s′) ∈ B̂(σ) indicates that there is a ΓS,l-labeled tree t and run of BQ on t such that the root of t is labeled with σ, the run starts in state s, and either BQ accepts t, or it traverses the root again at some point, then being in state s ′. The set B̂(σ) can be computed a priori in 2ExpTime; considering that ΓS,l is of double-exponential size in the size of Q, it follows that the collection {B̂(σ)}σ∈ΓS,l can be computed in 2ExpTime. Now the input tree for DQ comes with labels from Π of the form (s, s′) in its leaves. These “types” amount to guesses of possible extensions of the input tree. Utilizing the sets B̂(σ), DQ thus explores the possible ways how the given input tree can be extended to a ΓS,l-labeled tree t ′ that is accepted byBQ."
    }, {
      "heading" : "9. REFERENCES",
      "text" : "[1] A. Amarilli, M. Benedikt, P. Bourhis, and M. Vanden Boom. Query answering with transitive and linear-ordered data.\nIn IJCAI, pages 893–899, 2016.\n[2] T. J. Ameloot, B. Ketsman, F. Neven, and D. Zinn. Weaker forms of monotonicity for declarative networking: A more fine-grained answer to the calm-conjecture. In PODS, pages 64–75, 2014.\n[3] T. J. Ameloot, B. Ketsman, F. Neven, and D. Zinn. Datalog queries distributing over components. In ICDT, pages 308–323, 2015.\n[4] T. J. Ameloot, F. Neven, and J. V. den Bussche. Relational transducers for declarative networking. J. ACM, 60(2):15, 2013.\n[5] M. Arenas, R. Hull, W. Martens, T. Milo, and T. Schwentick. Foundations of Data Management (Dagstuhl perspectives workshop 16151). Dagstuhl Reports, 6(4):39–56, 2016.\n[6] F. Baader, M. Bienvenu, C. Lutz, and F. Wolter. Query and predicate emptiness in ontology-based data access. J. Artif. Intell. Res. (JAIR), 56:1–59, 2016.\n[7] J.-F. Baget, M. Leclère, M.-L. Mugnier, and E. Salvat. On rules with existential variables: Walking the decidability line. Artif. Intell., 175(9-10):1620–1654, 2011.\n[8] V. Bárány, M. Benedikt, and B. ten Cate. Rewriting guarded negation queries. In MFCS, pages 98–110, 2013.\n[9] V. Bárány, G. Gottlob, and M. Otto. Querying the guarded fragment. Logical Methods in Computer Science, 10(2), 2014.\n[10] P. Barceló, G. Berger, and A. Pieris. Containment for rule-based ontology-mediated queries. 2017.\n[11] C. Beeri and M. Y. Vardi. The implication problem for data dependencies. In ICALP, pages 73–85, 1981.\n[12] M. Benedikt, P. Bourhis, and M. Vanden Boom. A step up in expressiveness of decidable fixpoint logics. In LICS, pages 817–826, 2016.\n[13] M. Benedikt and G. Gottlob. The impact of virtual views on containment. PVLDB, 3(1):297–308, 2010.\n[14] G. Berger and A. Pieris. Ontology-mediated queries distributing over components. In IJCAI, pages 943–949, 2016.\n[15] M. Bienvenu, P. Hansen, C. Lutz, and F. Wolter. First order-rewritability and containment of conjunctive queries in horn description logics. In IJCAI, pages 965–971, 2016.\n[16] M. Bienvenu, C. Lutz, and F. Wolter. Query containment in description logics reconsidered. In KR, 2012.\n[17] M. Bienvenu, C. Lutz, and F. Wolter. First-order rewritability of atomic queries in horn description logics. In IJCAI, pages 754–760, 2013.\n[18] M. Bienvenu, B. ten Cate, C. Lutz, and F. Wolter. Ontology-based data access: a study through disjunctive datalog, csp, and MMSNP. In PODS, pages 213–224, 2013.\n[19] P. Bourhis, M. Krötzsch, and S. Rudolph. Reasonable highly expressive query languages. In IJCAI, pages 2826–2832, 2015.\n[20] P. Bourhis, M. Manna, M. Morak, and A. Pieris. Guarded-based disjunctive tuple-generating dependencies. ACM Trans. Database Syst., 41(4), 2016.\n[21] A. Cal̀ı, G. Gottlob, and M. Kifer. Taming the infinite chase: Query answering under expressive relational constraints. In KR, pages 70–80, 2008.\n[22] A. Cal̀ı, G. Gottlob, and M. Kifer. Taming the infinite chase: Query answering under expressive relational constraints. J. Artif. Intell. Res., 48:115–174, 2013.\n[23] A. Cal̀ı, G. Gottlob, and T. Lukasiewicz. A general Datalog-based framework for tractable query answering over ontologies. J. Web Sem., 14:57–83, 2012.\n[24] A. Cal̀ı, G. Gottlob, and A. Pieris. Towards more expressive ontology languages: The query answering problem. Artif. Intell., 193:87–128, 2012.\n[25] D. Calvanese, G. De Giacomo, D. Lembo, M. Lenzerini, and R. Rosati. Tractable reasoning and efficient query answering in description logics: The DL-Lite family. J. Autom. Reasoning, 39(3):385–429, 2007.\n[26] A. K. Chandra and P. M. Merlin. Optimal implementation of conjunctive queries in relational data bases. In STOC, pages 77–90, 1977.\n[27] S. Chaudhuri and M. Y. Vardi. On the equivalence of recursive and nonrecursive datalog programs. J. Comput. Syst. Sci., 54(1):61–78, 1997.\n[28] S. S. Cosmadakis, H. Gaifman, P. C. Kanellakis, and M. Y. Vardi. Decidable optimization problems for database logic programs (preliminary report). In STOC, pages 477–490, 1988.\n[29] E. Dantsin and A. Voronkov. Complexity of query answering in logic databases with complex values. In LFCS, pages 56–66, 1997.\n[30] T. Eiter, T. Lukasiewicz, and L. Predoiu. Generalized consistent query answering under existential rules. In KR, pages 359–368, 2016.\n[31] R. Fagin, P. G. Kolaitis, R. J. Miller, and L. Popa. Data exchange: Semantics and query answering. Theor. Comput. Sci., 336(1):89–124, 2005.\n[32] J. Flum, M. Frick, and M. Grohe. Query evaluation via tree-decompositions. J. ACM, 49(6):716–752, 2002.\n[33] G. Gottlob, G. Orsi, and A. Pieris. Query rewriting and optimization for ontological databases. ACM Trans. Database Syst., 39(3):25:1–25:46, 2014.\n[34] G. Gottlob and C. H. Papadimitriou. On the complexity of single-rule datalog queries. Inf. Comput., 183(1):104–122, 2003.\n[35] G. Gottlob, A. Pieris, and M. Simkus. The impact of active domain predicates on guarded existential rules. In RR, pages 94–110, 2016.\n[36] G. Gottlob, S. Rudolph, and M. Simkus. Expressiveness of guarded existential rule languages. In PODS, pages 27–38, 2014.\n[37] E. Grädel and I. Walukiewicz. Guarded fixed point logic. In LICS, pages 45–54, 1999.\n[38] D. S. Johnson. A catalog of complexity classes. In Handbook of Theoretical Computer Science, pages 67–161. 1990.\n[39] D. S. Johnson and A. C. Klug. Testing containment of conjunctive queries under functional and inclusion dependencies. J. Comput. Syst. Sci., 28(1):167–189, 1984.\n[40] T. Lukasiewicz, M. V. Martinez, A. Pieris, and G. I. Simari. From classical to consistent query answering under existential rules. In AAAI, pages 1546–1552, 2015.\n[41] D. Maier, A. O. Mendelzon, and Y. Sagiv. Testing implications of data dependencies. ACM Trans. Database Syst., 4(4):455–469, 1979.\n[42] A. Poggi, D. Lembo, D. Calvanese, G. De Giacomo, M. Lenzerini, and R. Rosati. Linking data to ontologies. J. Data Semantics, 10:133–173, 2008.\n[43] B. Rossman. Homomorphism preservation theorems. J. ACM, 55(3), 2008.\n[44] Y. Sagiv and M. Yannakakis. Equivalences among relational expressions with the union and difference operators. J. ACM, 27(4):633–655, 1980.\n[45] O. Shmueli. Equivalence of DATALOG queries is undecidable. J. Log. Program., 15(3):231–241, 1993.\n[46] M. Y. Vardi. Automata theory for database theoreticans. In Theoretical Studies in Computer Science, pages 153–180, 1992.\n[47] M. Y. Vardi. Reasoning about the past with two-way automata. In ICALP, pages 628–641, 1998.\n[48] T. Wilke. Alternating tree automata, parity games, and modal µ-calculus. Bull. Belg. Math. Soc. Simon Stevin, 8(2):359–391, 2001."
    } ],
    "references" : [ ],
    "referenceMentions" : [ ],
    "year" : 2017,
    "abstractText" : "Many efforts have been dedicated to identify restrictions<lb>on ontologies expressed as tuple-generating dependencies<lb>(tgds), a.k.a. existential rules, that lead to the decidabil-<lb>ity for the problem of answering ontology-mediated queries<lb>(OMQs). This has given rise to three families of formalisms:<lb>guarded, non-recursive, and sticky sets of tgds. In this work,<lb>we study the containment problem for OMQs expressed in<lb>such formalisms, which is a key ingredient for solving static<lb>analysis tasks associated with them. Our main contribu-<lb>tion is the development of specially tailored techniques for<lb>OMQ containment under the classes of tgds stated above.<lb>This enables us to obtain sharp complexity bounds for the<lb>problems at hand.<lb>We start with OMQs based on linear (a core fragment<lb>of guarded tgds), non-recursive and sticky sets of tgds,<lb>which share the property of UCQ rewritability. By exploit-<lb>ing this property, we obtain a small witness property for<lb>non-containment that allows us to devise standard “guess-<lb>and-check” algorithms. Based on this, we prove that OMQ<lb>containment for linear tgds is PSpace-complete, but<lb>Π2 -<lb>complete if the arity of the schema is fixed, while for sticky<lb>sets of tgds it is coNExpTime-complete, and<lb>Π2 -complete<lb>in the case of fixed arity. For non-recursive sets of tgds, the<lb>problem is in ExpSpace and P-hard even for fixed-arity<lb>schemas. Hence, in all the cases the containment problem<lb>is harder (under widely accepted complexity assumptions)<lb>than query evaluation, with the exception of linear tgds<lb>over schemas of unbounded arity, where both problems are<lb>complete for PSpace. For OMQs based on guarded tgds,<lb>which are not UCQ rewritable in general, we establish a<lb>tree witness property, and use it in combination with tree<lb>automata techniques to prove that OMQ containment has<lb>the same complexity as query evaluation, i.e., 2ExpTime-<lb>complete. Unlike query evaluation, though, OMQ contain-<lb>ment for guarded tgds remains 2ExpTime-hard over fixed-<lb>arity schemas. Lastly, we apply our techniques to pinpoint<lb>the complexity of problems associated with two emerging<lb>applications of OMQ containment: distribution over com-<lb>ponents and UCQ rewritability of OMQs.",
    "creator" : "LaTeX with hyperref package"
  }
}